[
    {
        "problemsName": " 2651.计算列车到站时间",
        "hardRate": "EASY",
        "passRate": "86.42%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-delayed-arrival-time/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-delayed-arrival-time/solution",
        "problemsDesc": "<p>给你一个正整数 <code>arrivalTime</code> 表示列车正点到站的时间（单位：小时），另给你一个正整数 <code>delayedTime</code> 表示列车延误的小时数。</p>\n\n<p>返回列车实际到站的时间。</p>\n\n<p>注意，该问题中的时间采用 24 小时制。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arrivalTime = 15, delayedTime = 5 \n<strong>输出：</strong>20 \n<strong>解释：</strong>列车正点到站时间是 15:00 ，延误 5 小时，所以列车实际到站的时间是 15 + 5 = 20（20:00）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arrivalTime = 13, delayedTime = 11\n<strong>输出：</strong>0\n<strong>解释：</strong>列车正点到站时间是 13:00 ，延误 11 小时，所以列车实际到站的时间是 13 + 11 = 24（在 24 小时制中表示为 00:00 ，所以返回 0）。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arrivaltime &lt;&nbsp;24</code></li>\n\t<li><code>1 &lt;= delayedTime &lt;= 24</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2652.倍数求和",
        "hardRate": "EASY",
        "passRate": "83.28%",
        "problemsUrl": "https://leetcode.cn/problems/sum-multiples/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-multiples/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> ，请你计算在 <code>[1，n]</code> 范围内能被 <code>3</code>、<code>5</code>、<code>7</code> 整除的所有整数之和。</p>\n\n<p>返回一个整数，用于表示给定范围内所有满足约束条件的数字之和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 7\n<strong>输出：</strong>21\n<strong>解释：</strong>在 <code>[1, 7]</code> 范围内能被 3、<code>5、</code><code>7 整除的所有整数分别是</code><code> 3、5、6、7</code> 。数字之和为 <code>21</code> 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 10\n<strong>输出：</strong>40\n<strong>解释：</strong>在 <code>[1, 10]</code> 范围内能被 3、<code>5、</code><code>7 整除的所有整数分别是</code><code> 3、5、6、7、9、10</code> 。数字之和为 <code>40</code> 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 9\n<strong>输出：</strong>30\n<strong>解释：</strong>在 <code>[1, 9]</code> 范围内能被 3、<code>5、</code><code>7 整除的所有整数分别是</code><code> 3、5、6、7、9</code> 。数字之和为 <code>30</code> 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>3</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2653.滑动子数组的美丽值",
        "hardRate": "MEDIUM",
        "passRate": "34.97%",
        "problemsUrl": "https://leetcode.cn/problems/sliding-subarray-beauty/",
        "solutionsUrl": "https://leetcode.cn/problems/sliding-subarray-beauty/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;，请你求出每个长度为&nbsp;<code>k</code>&nbsp;的子数组的 <b>美丽值</b>&nbsp;。</p>\n\n<p>一个子数组的 <strong>美丽值</strong>&nbsp;定义为：如果子数组中第 <code>x</code>&nbsp;<strong>小整数</strong>&nbsp;是 <strong>负数</strong>&nbsp;，那么美丽值为第 <code>x</code>&nbsp;小的数，否则美丽值为 <code>0</code>&nbsp;。</p>\n\n<p>请你返回一个包含<em>&nbsp;</em><code>n - k + 1</code>&nbsp;个整数的数组，<strong>依次</strong>&nbsp;表示数组中从第一个下标开始，每个长度为&nbsp;<code>k</code>&nbsp;的子数组的<strong>&nbsp;美丽值</strong>&nbsp;。</p>\n\n<ul>\n\t<li>\n\t<p>子数组指的是数组中一段连续 <strong>非空</strong>&nbsp;的元素序列。</p>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,-1,-3,-2,3], k = 3, x = 2\n<b>输出：</b>[-1,-2,-2]\n<b>解释：</b>总共有 3 个 k = 3 的子数组。\n第一个子数组是 <code>[1, -1, -3]</code> ，第二小的数是负数 -1 。\n第二个子数组是 <code>[-1, -3, -2]</code> ，第二小的数是负数 -2 。\n第三个子数组是 <code>[-3, -2, 3]&nbsp;，第二小的数是负数 -2 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [-1,-2,-3,-4,-5], k = 2, x = 2\n<b>输出：</b>[-1,-2,-3,-4]\n<b>解释：</b>总共有 4 个 k = 2 的子数组。\n<code>[-1, -2] 中第二小的数是负数 -1 。</code>\n<code>[-2, -3] 中第二小的数是负数 -2 。</code>\n<code>[-3, -4] 中第二小的数是负数 -3 。</code>\n<code>[-4, -5] 中第二小的数是负数 -4 。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [-3,1,2,-3,0,-3], k = 2, x = 1\n<b>输出：</b>[-3,0,-3,-3,-3]\n<b>解释：</b>总共有 5 个 k = 2 的子数组。\n<code>[-3, 1] 中最小的数是负数 -3 。</code>\n<code>[1, 2] 中最小的数不是负数，所以美丽值为 0 。</code>\n<code>[2, -3] 中最小的数是负数 -3 。</code>\n<code>[-3, 0] 中最小的数是负数 -3 。</code>\n<code>[0, -3] 中最小的数是负数 -3 。</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length&nbsp;</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n\t<li><code>1 &lt;= x &lt;= k&nbsp;</code></li>\n\t<li><code>-50&nbsp;&lt;= nums[i] &lt;= 50&nbsp;</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2654.使数组所有元素变成 1 的最少操作次数",
        "hardRate": "MEDIUM",
        "passRate": "40.18%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的 <strong>正</strong>&nbsp;整数数组&nbsp;<code>nums</code>&nbsp;。你可以对数组执行以下操作 <strong>任意</strong>&nbsp;次：</p>\n\n<ul>\n\t<li>选择一个满足&nbsp;<code>0 &lt;= i &lt; n - 1</code>&nbsp;的下标 <code>i</code>&nbsp;，将&nbsp;<code>nums[i]</code> 或者&nbsp;<code>nums[i+1]</code>&nbsp;两者之一替换成它们的最大公约数。</li>\n</ul>\n\n<p>请你返回使数组 <code>nums</code>&nbsp;中所有元素都等于 <code>1</code>&nbsp;的 <strong>最少</strong>&nbsp;操作次数。如果无法让数组全部变成 <code>1</code>&nbsp;，请你返回 <code>-1</code>&nbsp;。</p>\n\n<p>两个正整数的最大公约数指的是能整除这两个数的最大正整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,6,3,4]\n<b>输出：</b>4\n<b>解释：</b>我们可以执行以下操作：\n- 选择下标 i = 2 ，将 nums[2] 替换为 gcd(3,4) = 1 ，得到 nums = [2,6,1,4] 。\n- 选择下标 i = 1 ，将 nums[1] 替换为 gcd(6,1) = 1 ，得到 nums = [2,1,1,4] 。\n- 选择下标 i = 0 ，将 nums[0] 替换为 gcd(2,1) = 1 ，得到 nums = [1,1,1,4] 。\n- 选择下标 i = 2 ，将 nums[3] 替换为 gcd(1,4) = 1 ，得到 nums = [1,1,1,1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,10,6,14]\n<b>输出：</b>-1\n<b>解释：</b>无法将所有元素都变成 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2655.寻找最大长度的未覆盖区间",
        "hardRate": "MEDIUM",
        "passRate": "62.69%",
        "problemsUrl": "https://leetcode.cn/problems/find-maximal-uncovered-ranges/",
        "solutionsUrl": "https://leetcode.cn/problems/find-maximal-uncovered-ranges/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2656.K 个元素的最大和",
        "hardRate": "EASY",
        "passRate": "83.88%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-with-exactly-k-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-with-exactly-k-elements/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code> 和一个整数&nbsp;<code>k</code>&nbsp;。你需要执行以下操作<strong>&nbsp;恰好</strong> <code>k</code>&nbsp;次，最大化你的得分：</p>\n\n<ol>\n\t<li>从 <code>nums</code>&nbsp;中选择一个元素&nbsp;<code>m</code>&nbsp;。</li>\n\t<li>将选中的元素&nbsp;<code>m</code>&nbsp;从数组中删除。</li>\n\t<li>将新元素&nbsp;<code>m + 1</code>&nbsp;添加到数组中。</li>\n\t<li>你的得分增加&nbsp;<code>m</code>&nbsp;。</li>\n</ol>\n\n<p>请你返回执行以上操作恰好 <code>k</code>&nbsp;次后的最大得分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4,5], k = 3\n<b>输出：</b>18\n<b>解释：</b>我们需要从 nums 中恰好选择 3 个元素并最大化得分。\n第一次选择 5 。和为 5 ，nums = [1,2,3,4,6] 。\n第二次选择 6 。和为 6 ，nums = [1,2,3,4,7] 。\n第三次选择 7 。和为 5 + 6 + 7 = 18 ，nums = [1,2,3,4,8] 。\n所以我们返回 18 。\n18 是可以得到的最大答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5,5,5], k = 2\n<b>输出：</b>11\n<b>解释：</b>我们需要从 nums 中恰好选择 2 个元素并最大化得分。\n第一次选择 5 。和为 5 ，nums = [5,5,6] 。\n第二次选择 6 。和为 6 ，nums = [5,5,7] 。\n所以我们返回 11 。\n11 是可以得到的最大答案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2657.找到两个数组的前缀公共数组",
        "hardRate": "MEDIUM",
        "passRate": "82.82%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-prefix-common-array-of-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-prefix-common-array-of-two-arrays/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数排列&nbsp;<code>A</code> 和&nbsp;<code>B</code>&nbsp;。</p>\n\n<p><code>A</code>&nbsp;和&nbsp;<code>B</code>&nbsp;的 <strong>前缀公共数组</strong>&nbsp;定义为数组&nbsp;<code>C</code>&nbsp;，其中&nbsp;<code>C[i]</code>&nbsp;是数组&nbsp;<code>A</code> 和&nbsp;<code>B</code>&nbsp;到下标为&nbsp;<code>i</code>&nbsp;之前公共元素的数目。</p>\n\n<p>请你返回 <code>A</code>&nbsp;和 <code>B</code>&nbsp;的 <strong>前缀公共数组</strong>&nbsp;。</p>\n\n<p>如果一个长度为 <code>n</code>&nbsp;的数组包含 <code>1</code>&nbsp;到 <code>n</code>&nbsp;的元素恰好一次，我们称这个数组是一个长度为 <code>n</code>&nbsp;的 <strong>排列</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>A = [1,3,2,4], B = [3,1,2,4]\n<b>输出：</b>[0,2,3,4]\n<b>解释：</b>i = 0：没有公共元素，所以 C[0] = 0 。\ni = 1：1 和 3 是两个数组的前缀公共元素，所以 C[1] = 2 。\ni = 2：1，2 和 3 是两个数组的前缀公共元素，所以 C[2] = 3 。\ni = 3：1，2，3 和 4 是两个数组的前缀公共元素，所以 C[3] = 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>A = [2,3,1], B = [3,1,2]\n<b>输出：</b>[0,1,3]\n<b>解释：</b>i = 0：没有公共元素，所以 C[0] = 0 。\ni = 1：只有 3 是公共元素，所以 C[1] = 1 。\ni = 2：1，2 和 3 是两个数组的前缀公共元素，所以 C[2] = 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= A.length == B.length == n &lt;= 50</code></li>\n\t<li><code>1 &lt;= A[i], B[i] &lt;= n</code></li>\n\t<li>题目保证&nbsp;<code>A</code>&nbsp;和&nbsp;<code>B</code>&nbsp;两个数组都是&nbsp;<code>n</code>&nbsp;个元素的排列。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2658.网格图中鱼的最大数目",
        "hardRate": "MEDIUM",
        "passRate": "60.42%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-fish-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-fish-in-a-grid/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始大小为 <code>m x n</code>&nbsp;的二维整数数组&nbsp;<code>grid</code>&nbsp;，其中下标在&nbsp;<code>(r, c)</code>&nbsp;处的整数表示：</p>\n\n<ul>\n\t<li>如果&nbsp;<code>grid[r][c] = 0</code>&nbsp;，那么它是一块 <strong>陆地</strong>&nbsp;。</li>\n\t<li>如果&nbsp;<code>grid[r][c] &gt; 0</code>&nbsp;，那么它是一块&nbsp;<strong>水域</strong>&nbsp;，且包含&nbsp;<code>grid[r][c]</code>&nbsp;条鱼。</li>\n</ul>\n\n<p>一位渔夫可以从任意 <strong>水域</strong>&nbsp;格子&nbsp;<code>(r, c)</code>&nbsp;出发，然后执行以下操作任意次：</p>\n\n<ul>\n\t<li>捕捞格子&nbsp;<code>(r, c)</code>&nbsp;处所有的鱼，或者</li>\n\t<li>移动到相邻的 <strong>水域</strong>&nbsp;格子。</li>\n</ul>\n\n<p>请你返回渔夫最优策略下，&nbsp;<strong>最多</strong>&nbsp;可以捕捞多少条鱼。如果没有水域格子，请你返回 <code>0</code>&nbsp;。</p>\n\n<p>格子&nbsp;<code>(r, c)</code>&nbsp;<strong>相邻</strong>&nbsp;的格子为&nbsp;<code>(r, c + 1)</code>&nbsp;，<code>(r, c - 1)</code>&nbsp;，<code>(r + 1, c)</code> 和&nbsp;<code>(r - 1, c)</code>&nbsp;，前提是相邻格子在网格图内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/29/example.png\" style=\"width: 241px; height: 161px;\"></p>\n\n<pre><b>输入：</b>grid = [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]\n<b>输出：</b>7\n<b>解释：</b>渔夫可以从格子 <code>(1,3)</code> 出发，捕捞 3 条鱼，然后移动到格子 <code>(2,3)</code>&nbsp;，捕捞 4 条鱼。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/29/example2.png\"></p>\n\n<pre><b>输入：</b>grid = [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]\n<b>输出：</b>1\n<b>解释：</b>渔夫可以从格子 (0,0) 或者 (3,3) ，捕捞 1 条鱼。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2659.将数组清空",
        "hardRate": "HARD",
        "passRate": "38.91%",
        "problemsUrl": "https://leetcode.cn/problems/make-array-empty/",
        "solutionsUrl": "https://leetcode.cn/problems/make-array-empty/solution",
        "problemsDesc": "<p>给你一个包含若干 <strong>互不相同</strong>&nbsp;整数的数组&nbsp;<code>nums</code>&nbsp;，你需要执行以下操作 <strong>直到</strong><strong>数组为空</strong>&nbsp;：</p>\n\n<ul>\n\t<li>如果数组中第一个元素是当前数组中的 <strong>最小值</strong>&nbsp;，则删除它。</li>\n\t<li>否则，将第一个元素移动到数组的 <strong>末尾</strong>&nbsp;。</li>\n</ul>\n\n<p>请你返回需要多少个操作使<em>&nbsp;</em><code>nums</code><em>&nbsp;</em>为空。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,4,-1]\n<b>输出：</b>5\n</pre>\n\n<table style=\"border: 2px solid black; border-collapse: collapse;\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Operation</th>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Array</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">1</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[4, -1, 3]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">2</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[-1, 3, 4]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">3</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[3, 4]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">4</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[4]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">5</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[]</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,4,3]\n<b>输出：</b>5\n</pre>\n\n<table style=\"border: 2px solid black; border-collapse: collapse;\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Operation</th>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Array</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">1</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[2, 4, 3]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">2</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[4, 3]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">3</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[3, 4]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">4</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[4]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">5</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[]</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3]\n<b>输出：</b>3\n</pre>\n\n<table style=\"border: 2px solid black; border-collapse: collapse;\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Operation</th>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Array</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">1</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[2, 3]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">2</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[3]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">3</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[]</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9&nbsp;</sup>&lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums</code>&nbsp;中的元素 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2660.保龄球游戏的获胜者",
        "hardRate": "EASY",
        "passRate": "33.71%",
        "problemsUrl": "https://leetcode.cn/problems/determine-the-winner-of-a-bowling-game/",
        "solutionsUrl": "https://leetcode.cn/problems/determine-the-winner-of-a-bowling-game/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong> 开始的整数数组 <code>player1</code> 和 <code>player2</code> ，分别表示玩家 1 和玩家 2 击中的瓶数。</p>\n\n<p>保龄球比赛由 <code>n</code> 轮组成，每轮的瓶数恰好为 <code>10</code> 。</p>\n\n<p>假设玩家在第 <code>i</code> 轮中击中&nbsp;<code>x<sub>i</sub></code> 个瓶子。玩家第 <code>i</code> 轮的价值为：</p>\n\n<ul>\n\t<li>如果玩家在该轮的前两轮的任何一轮中击中了 <code>10</code> 个瓶子，则为 <code>2x<sub>i</sub></code> 。</li>\n\t<li>否则，为&nbsp;<code>x<sub>i</sub></code> 。</li>\n</ul>\n\n<p>玩家的得分是其 <code>n</code> 轮价值的总和。</p>\n\n<p>返回</p>\n\n<ul>\n\t<li>如果玩家 1 的得分高于玩家 2 的得分，则为 <code>1</code> ；</li>\n\t<li>如果玩家 2 的得分高于玩家 1 的得分，则为 <code>2</code> ；</li>\n\t<li>如果平局，则为 <code>0</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>player1 = [4,10,7,9], player2 = [6,5,2,3]\n<strong>输出：</strong>1\n<strong>解释：</strong>player1 的得分是 4 + 10 + 2*7 + 2*9 = 46 。\nplayer2 的得分是 6 + 5 + 2 + 3 = 16 。\nplayer1 的得分高于 player2 的得分，所以 play1 在比赛中获胜，答案为 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>player1 = [3,5,7,6], player2 = [8,10,10,2]\n<strong>输出：</strong>2\n<strong>解释：</strong>player1 的得分是 3 + 5 + 7 + 6 = 21 。\nplayer2 的得分是 8 + 10 + 2*10 + 2*2 = 42 。\nplayer2 的得分高于 player1 的得分，所以 play2 在比赛中获胜，答案为 2 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>player1 = [2,3], player2 = [4,1]\n<strong>输出：</strong>0\n<strong>解释：</strong>player1 的得分是 2 + 3 = 5 。\nplayer2 的得分是 4 + 1 = 5 。\nplayer1 的得分等于 player2 的得分，所以这一场比赛平局，答案为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == player1.length == player2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= player1[i], player2[i] &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2661.找出叠涂元素",
        "hardRate": "MEDIUM",
        "passRate": "51.19%",
        "problemsUrl": "https://leetcode.cn/problems/first-completely-painted-row-or-column/",
        "solutionsUrl": "https://leetcode.cn/problems/first-completely-painted-row-or-column/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>arr</code> 和一个 <code>m x n</code> 的整数 <strong>矩阵</strong> <code>mat</code> 。<code>arr</code> 和 <code>mat</code> 都包含范围 <code>[1，m * n]</code> 内的 <strong>所有</strong> 整数。</p>\n\n<p>从下标 <code>0</code> 开始遍历 <code>arr</code> 中的每个下标 <code>i</code> ，并将包含整数 <code>arr[i]</code> 的 <code>mat</code> 单元格涂色。</p>\n\n<p>请你找出 <code>arr</code> 中在 <code>mat</code> 的某一行或某一列上都被涂色且下标最小的元素，并返回其下标 <code>i</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"image explanation for example 1\" src=\"https://assets.leetcode.com/uploads/2023/01/18/grid1.jpg\" style=\"width: 321px; height: 81px;\" />\n<pre>\n<strong>输入：</strong>arr = [1,3,4,2], mat = [[1,4],[2,3]]\n<strong>输出：</strong>2\n<strong>解释：</strong>遍历如上图所示，arr[2] 在矩阵中的第一行或第二列上都被涂色。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"image explanation for example 2\" src=\"https://assets.leetcode.com/uploads/2023/01/18/grid2.jpg\" style=\"width: 601px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]]\n<strong>输出：</strong>3\n<strong>解释：</strong>遍历如上图所示，arr[3] 在矩阵中的第二列上都被涂色。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n = mat[i].length</code></li>\n\t<li><code>arr.length == m * n</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i], mat[r][c] &lt;= m * n</code></li>\n\t<li><code>arr</code> 中的所有整数 <strong>互不相同</strong></li>\n\t<li><code>mat</code> 中的所有整数 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2662.前往目标的最小代价",
        "hardRate": "MEDIUM",
        "passRate": "36.74%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-of-a-path-with-special-roads/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-of-a-path-with-special-roads/solution",
        "problemsDesc": "<p>给你一个数组 <code>start</code> ，其中 <code>start = [startX, startY]</code> 表示你的初始位置位于二维空间上的 <code>(startX, startY)</code> 。另给你一个数组 <code>target</code> ，其中 <code>target = [targetX, targetY]</code> 表示你的目标位置 <code>(targetX, targetY)</code> 。</p>\n\n<p>从位置 <code>(x1, y1)</code> 到空间中任一其他位置 <code>(x2, y2)</code> 的代价是 <code>|x2 - x1| + |y2 - y1|</code> 。</p>\n\n<p>给你一个二维数组 <code>specialRoads</code> ，表示空间中存在的一些特殊路径。其中 <code>specialRoads[i] = [x1<sub>i</sub>, y1<sub>i</sub>, x2<sub>i</sub>, y2<sub>i</sub>, cost<sub>i</sub>]</code> 表示第 <code>i</code> 条特殊路径可以从 <code>(x1<sub>i</sub>, y1<sub>i</sub>)</code> 到 <code>(x2<sub>i</sub>, y2<sub>i</sub>)</code> ，但成本等于 <code>cost<sub>i</sub></code> 。你可以使用每条特殊路径任意次数。</p>\n\n<p>返回从 <code>(startX, startY)</code> 到 <code>(targetX, targetY)</code> 所需的最小代价。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>start = [1,1], target = [4,5], specialRoads = [[1,2,3,3,2],[3,4,4,5,1]]\n<strong>输出：</strong>5\n<strong>解释：</strong>从 (1,1) 到 (4,5) 的最优路径如下：\n- (1,1) -&gt; (1,2) ，移动的代价是 |1 - 1| + |2 - 1| = 1 。\n- (1,2) -&gt; (3,3) ，移动使用第一条特殊路径，代价是 2 。\n- (3,3) -&gt; (3,4) ，移动的代价是 |3 - 3| + |4 - 3| = 1.\n- (3,4) -&gt; (4,5) ，移动使用第二条特殊路径，代价是 1 。\n总代价是 1 + 2 + 1 + 1 = 5 。\n可以证明无法以小于 5 的代价完成从 (1,1) 到 (4,5) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>start = [3,2], target = [5,7], specialRoads = [[3,2,3,4,4],[3,3,5,5,5],[3,4,5,6,6]]\n<strong>输出：</strong>7\n<strong>解释：</strong>最优路径是不使用任何特殊路径，直接以 |5 - 3| + |7 - 2| = 7 的代价从初始位置到达目标位置。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>start.length == target.length == 2</code></li>\n\t<li><code>1 &lt;= startX &lt;= targetX &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= startY &lt;= targetY &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= specialRoads.length &lt;= 200</code></li>\n\t<li><code>specialRoads[i].length == 5</code></li>\n\t<li><code>startX &lt;= x1<sub>i</sub>, x2<sub>i</sub> &lt;= targetX</code></li>\n\t<li><code>startY &lt;= y1<sub>i</sub>, y2<sub>i</sub> &lt;= targetY</code></li>\n\t<li><code>1 &lt;= cost<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2663.字典序最小的美丽字符串",
        "hardRate": "HARD",
        "passRate": "45.79%",
        "problemsUrl": "https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/",
        "solutionsUrl": "https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/solution",
        "problemsDesc": "<p>如果一个字符串满足以下条件，则称其为 <strong>美丽字符串</strong> ：</p>\n\n<ul>\n\t<li>它由英语小写字母表的前 <code>k</code> 个字母组成。</li>\n\t<li>它不包含任何长度为 <code>2</code> 或更长的回文子字符串。</li>\n</ul>\n\n<p>给你一个长度为 <code>n</code> 的美丽字符串 <code>s</code> 和一个正整数 <code>k</code> 。</p>\n\n<p>请你找出并返回一个长度为 <code>n</code> 的美丽字符串，该字符串还满足：在字典序大于 <code>s</code> 的所有美丽字符串中字典序最小。如果不存在这样的字符串，则返回一个空字符串。</p>\n\n<p>对于长度相同的两个字符串 <code>a</code> 和 <code>b</code> ，如果字符串 <code>a</code> 在与字符串 <code>b</code> 不同的第一个位置上的字符字典序更大，则字符串 <code>a</code> 的字典序大于字符串 <code>b</code> 。</p>\n\n<ul>\n\t<li>例如，<code>\"abcd\"</code> 的字典序比 <code>\"abcc\"</code> 更大，因为在不同的第一个位置（第四个字符）上 <code>d</code> 的字典序大于 <code>c</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcz\", k = 26\n<strong>输出：</strong>\"abda\"\n<strong>解释：</strong>字符串 \"abda\" 既是美丽字符串，又满足字典序大于 \"abcz\" 。\n可以证明不存在字符串同时满足字典序大于 \"abcz\"、美丽字符串、字典序小于 \"abda\" 这三个条件。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"dc\", k = 4\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>可以证明，不存在既是美丽字符串，又字典序大于 \"dc\" 的字符串。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>4 &lt;= k &lt;= 26</code></li>\n\t<li><code>s</code> 是一个美丽字符串</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2664.巡逻的骑士",
        "hardRate": "MEDIUM",
        "passRate": "65.32%",
        "problemsUrl": "https://leetcode.cn/problems/the-knights-tour/",
        "solutionsUrl": "https://leetcode.cn/problems/the-knights-tour/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2665.计数器 II",
        "hardRate": "EASY",
        "passRate": "61.18%",
        "problemsUrl": "https://leetcode.cn/problems/counter-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/counter-ii/solution",
        "problemsDesc": "<p>请你写一个函数&nbsp;<code>createCounter</code>. 这个函数接收一个初始的整数值 <code>init</code>&nbsp;&nbsp;并返回一个包含三个函数的对象。</p>\n\n<p>这三个函数是：</p>\n\n<ul>\n\t<li><code>increment()</code>&nbsp;将当前值加 1 并返回。</li>\n\t<li><code>decrement()</code>&nbsp;将当前值减 1 并返回。</li>\n\t<li><code>reset()</code>&nbsp;将当前值设置为 <code>init</code> 并返回。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>init = 5, calls = [\"increment\",\"reset\",\"decrement\"]\n<b>输出：</b>[6,5,4]\n<strong>解释：</strong>\nconst counter = createCounter(5);\ncounter.increment(); // 6\ncounter.reset(); // 5\ncounter.decrement(); // 4\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>init = 0, calls = [\"increment\",\"increment\",\"decrement\",\"reset\",\"reset\"]\n<b>输出：</b>[1,2,1,0,0]\n<strong>解释：</strong>\nconst counter = createCounter(0);\ncounter.increment(); // 1\ncounter.increment(); // 2\ncounter.decrement(); // 1\ncounter.reset(); // 0\ncounter.reset(); // 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-1000 &lt;= init &lt;= 1000</code></li>\n\t<li><code>总调用次数不会超过&nbsp;1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2666.只允许一次函数调用",
        "hardRate": "EASY",
        "passRate": "80.73%",
        "problemsUrl": "https://leetcode.cn/problems/allow-one-function-call/",
        "solutionsUrl": "https://leetcode.cn/problems/allow-one-function-call/solution",
        "problemsDesc": "<p>给定一个函数 <code>fn</code> ，它返回一个新的函数，返回的函数与原始函数完全相同，只不过它确保 <code>fn</code> 最多被调用一次。</p>\n\n<ul>\n\t<li>第一次调用返回的函数时，它应该返回与 <code>fn</code> 相同的结果。</li>\n\t<li>第一次后的每次调用，它应该返回 <code>undefined</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre>\n<b>输入：</b>fn = (a,b,c) =&gt; (a + b + c), calls = [[1,2,3],[2,3,6]]\n<b>输出：</b>[{\"calls\":1,\"value\":6}]\n<strong>解释：</strong>\nconst onceFn = once(fn);\nonceFn(1, 2, 3); // 6\nonceFn(2, 3, 6); // undefined, fn 没有被调用\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>fn = (a,b,c) =&gt; (a * b * c), calls = [[5,7,4],[2,3,6],[4,6,8]]\n<b>输出：</b>[{\"calls\":1,\"value\":140}]\n<strong>解释：</strong>\nconst onceFn = once(fn);\nonceFn(5, 7, 4); // 140\nonceFn(2, 3, 6); // undefined, fn 没有被调用\nonceFn(4, 6, 8); // undefined, fn 没有被调用\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= calls.length &lt;= 10</code></li>\n\t<li><code>1 &lt;= calls[i].length &lt;= 100</code></li>\n\t<li><code>2 &lt;= JSON.stringify(calls).length &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2667.创建 Hello World 函数",
        "hardRate": "EASY",
        "passRate": "84.64%",
        "problemsUrl": "https://leetcode.cn/problems/create-hello-world-function/",
        "solutionsUrl": "https://leetcode.cn/problems/create-hello-world-function/solution",
        "problemsDesc": "请你编写一个名为 <code>createHelloWorld</code> 的函数。它应该返回一个新的函数，该函数总是返回 <code>\"Hello World\"</code>&nbsp;。\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>args = []\n<b>输出：</b>\"Hello World\"\n<strong>解释：</strong>\nconst f = createHelloWorld();\nf(); // \"Hello World\"\n\ncreateHelloWorld 返回的函数应始终返回 \"Hello World\"。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>args = [{},null,42]\n<b>输出：</b>\"Hello World\"\n<strong>解释：</strong>\nconst f = createHelloWorld();\nf({}, null, 42); // \"Hello World\"\n\n可以传递任何参数给函数，但它应始终返回 \"Hello World\"。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= args.length &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2668.查询员工当前薪水",
        "hardRate": "EASY",
        "passRate": "69.80%",
        "problemsUrl": "https://leetcode.cn/problems/find-latest-salaries/",
        "solutionsUrl": "https://leetcode.cn/problems/find-latest-salaries/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2669.统计 Spotify 排行榜上艺术家出现次数",
        "hardRate": "EASY",
        "passRate": "71.43%",
        "problemsUrl": "https://leetcode.cn/problems/count-artist-occurrences-on-spotify-ranking-list/",
        "solutionsUrl": "https://leetcode.cn/problems/count-artist-occurrences-on-spotify-ranking-list/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2670.找出不同元素数目差数组",
        "hardRate": "EASY",
        "passRate": "75.76%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-distinct-difference-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-distinct-difference-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，数组长度为 <code>n</code> 。</p>\n\n<p><code>nums</code> 的 <strong>不同元素数目差</strong> 数组可以用一个长度为 <code>n</code> 的数组 <code>diff</code> 表示，其中 <code>diff[i]</code> 等于前缀 <code>nums[0, ..., i]</code> 中不同元素的数目 <strong>减去</strong> 后缀 <code>nums[i + 1, ..., n - 1]</code> 中不同元素的数目。</p>\n\n<p>返回<em> </em><code>nums</code> 的 <strong>不同元素数目差</strong> 数组。</p>\n\n<p>注意 <code>nums[i, ..., j]</code> 表示 <code>nums</code> 的一个从下标 <code>i</code> 开始到下标 <code>j</code> 结束的子数组（包含下标 <code>i</code> 和 <code>j</code> 对应元素）。特别需要说明的是，如果 <code>i &gt; j</code> ，则 <code>nums[i, ..., j]</code> 表示一个空子数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4,5]\n<strong>输出：</strong>[-3,-1,1,3,5]\n<strong>解释：\n</strong>对于 i = 0，前缀中有 1 个不同的元素，而在后缀中有 4 个不同的元素。因此，diff[0] = 1 - 4 = -3 。\n对于 i = 1，前缀中有 2 个不同的元素，而在后缀中有 3 个不同的元素。因此，diff[1] = 2 - 3 = -1 。\n对于 i = 2，前缀中有 3 个不同的元素，而在后缀中有 2 个不同的元素。因此，diff[2] = 3 - 2 = 1 。\n对于 i = 3，前缀中有 4 个不同的元素，而在后缀中有 1 个不同的元素。因此，diff[3] = 4 - 1 = 3 。\n对于 i = 4，前缀中有 5 个不同的元素，而在后缀中有 0 个不同的元素。因此，diff[4] = 5 - 0 = 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,3,4,2]\n<strong>输出：</strong>[-2,-1,0,2,3]\n<strong>解释：</strong>\n对于 i = 0，前缀中有 1 个不同的元素，而在后缀中有 3 个不同的元素。因此，diff[0] = 1 - 3 = -2 。\n对于 i = 1，前缀中有 2 个不同的元素，而在后缀中有 3 个不同的元素。因此，diff[1] = 2 - 3 = -1 。\n对于 i = 2，前缀中有 2 个不同的元素，而在后缀中有 2 个不同的元素。因此，diff[2] = 2 - 2 = 0 。\n对于 i = 3，前缀中有 3 个不同的元素，而在后缀中有 1 个不同的元素。因此，diff[3] = 3 - 1 = 2 。\n对于 i = 4，前缀中有 3 个不同的元素，而在后缀中有 0 个不同的元素。因此，diff[4] = 3 - 0 = 3 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == nums.length&nbsp;&lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2671.频率跟踪器",
        "hardRate": "MEDIUM",
        "passRate": "32.53%",
        "problemsUrl": "https://leetcode.cn/problems/frequency-tracker/",
        "solutionsUrl": "https://leetcode.cn/problems/frequency-tracker/solution",
        "problemsDesc": "<p>请你设计并实现一个能够对其中的值进行跟踪的数据结构，并支持对频率相关查询进行应答。</p>\n\n<p>实现 <code>FrequencyTracker</code> 类：</p>\n\n<ul>\n\t<li><code>FrequencyTracker()</code>：使用一个空数组初始化 <code>FrequencyTracker</code> 对象。</li>\n\t<li><code>void add(int number)</code>：添加一个 <code>number</code> 到数据结构中。</li>\n\t<li><code>void deleteOne(int number)</code>：从数据结构中删除一个 <code>number</code> 。数据结构 <strong>可能不包含</strong> <code>number</code> ，在这种情况下不删除任何内容。</li>\n\t<li><code>bool hasFrequency(int frequency)</code>: 如果数据结构中存在出现 <code>frequency</code> 次的数字，则返回 <code>true</code>，否则返回 <code>false</code>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"FrequencyTracker\", \"add\", \"add\", \"hasFrequency\"]\n[[], [3], [3], [2]]\n<strong>输出</strong>\n[null, null, null, true]\n\n<strong>解释</strong>\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.add(3); // 数据结构现在包含 [3]\nfrequencyTracker.add(3); // 数据结构现在包含 [3, 3]\nfrequencyTracker.hasFrequency(2); // 返回 true ，因为 3 出现 2 次\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"FrequencyTracker\", \"add\", \"deleteOne\", \"hasFrequency\"]\n[[], [1], [1], [1]]\n<strong>输出</strong>\n[null, null, null, false]\n\n<strong>解释</strong>\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.add(1); // 数据结构现在包含 [1]\nfrequencyTracker.deleteOne(1); // 数据结构现在为空 []\nfrequencyTracker.hasFrequency(1); // 返回 false ，因为数据结构为空\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"FrequencyTracker\", \"hasFrequency\", \"add\", \"hasFrequency\"]\n[[], [2], [3], [1]]\n<strong>输出</strong>\n[null, false, null, true]\n\n<strong>解释</strong>\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.hasFrequency(2); // 返回 false ，因为数据结构为空\nfrequencyTracker.add(3); // 数据结构现在包含 [3]\nfrequencyTracker.hasFrequency(1); // 返回 true ，因为 3 出现 1 次\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= number &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= frequency &lt;= 10<sup>5</sup></code></li>\n\t<li>最多调用 <code>add</code>、<code>deleteOne</code> 和 <code>hasFrequency</code> <strong>共计</strong> <code>2 *&nbsp;10<sup>5</sup></code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2672.有相同颜色的相邻元素数目",
        "hardRate": "MEDIUM",
        "passRate": "58.31%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-adjacent-elements-with-the-same-color/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-adjacent-elements-with-the-same-color/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始、长度为 <code>n</code>&nbsp;的数组&nbsp;<code>nums</code>&nbsp;。一开始，所有元素都是 <strong>未染色</strong>&nbsp;（值为 <code>0</code>&nbsp;）的。</p>\n\n<p>给你一个二维整数数组&nbsp;<code>queries</code>&nbsp;，其中&nbsp;<code>queries[i] = [index<sub>i</sub>, color<sub>i</sub>]</code>&nbsp;。</p>\n\n<p>对于每个操作，你需要将数组 <code>nums</code>&nbsp;中下标为&nbsp;<code>index<sub>i</sub></code>&nbsp;的格子染色为&nbsp;<code>color<sub>i</sub></code>&nbsp;。</p>\n\n<p>请你返回一个长度与 <code>queries</code>&nbsp;相等的数组<em>&nbsp;</em><code>answer</code><em>&nbsp;</em>，其中<em>&nbsp;</em><code>answer[i]</code>是前 <code>i</code>&nbsp;个操作&nbsp;<strong>之后</strong>&nbsp;，相邻元素颜色相同的数目。</p>\n\n<p>更正式的，<code>answer[i]</code>&nbsp;是执行完前 <code>i</code>&nbsp;个操作后，<code>0 &lt;= j &lt; n - 1</code>&nbsp;的下标 <code>j</code>&nbsp;中，满足&nbsp;<code>nums[j] == nums[j + 1]</code> 且&nbsp;<code>nums[j] != 0</code>&nbsp;的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 4, queries = [[0,2],[1,2],[3,1],[1,1],[2,1]]\n<b>输出：</b>[0,1,1,0,2]\n<b>解释：</b>一开始数组 nums = [0,0,0,0] ，0 表示数组中还没染色的元素。\n- 第 1 个操作后，nums = [2,0,0,0] 。相邻元素颜色相同的数目为 0 。\n- 第 2 个操作后，nums = [2,2,0,0] 。相邻元素颜色相同的数目为 1 。\n- 第 3 个操作后，nums = [2,2,0,1] 。相邻元素颜色相同的数目为 1 。\n- 第 4 个操作后，nums = [2,1,0,1] 。相邻元素颜色相同的数目为 0 。\n- 第 5 个操作后，nums = [2,1,1,1] 。相邻元素颜色相同的数目为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 1, queries = [[0,100000]]\n<b>输出：</b>[0]\n<b>解释：</b>一开始数组 nums = [0] ，0 表示数组中还没染色的元素。\n- 第 1 个操作后，nums = [100000] 。相邻元素颜色相同的数目为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length&nbsp;== 2</code></li>\n\t<li><code>0 &lt;= index<sub>i</sub>&nbsp;&lt;= n - 1</code></li>\n\t<li><code>1 &lt;=&nbsp; color<sub>i</sub>&nbsp;&lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2673.使二叉树所有路径值相等的最小代价",
        "hardRate": "MEDIUM",
        "passRate": "66.02%",
        "problemsUrl": "https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;表示一棵 <b>满二叉树</b>&nbsp;里面节点的数目，节点编号从 <code>1</code>&nbsp;到 <code>n</code>&nbsp;。根节点编号为 <code>1</code>&nbsp;，树中每个非叶子节点&nbsp;<code>i</code>&nbsp;都有两个孩子，分别是左孩子&nbsp;<code>2 * i</code>&nbsp;和右孩子&nbsp;<code>2 * i + 1</code>&nbsp;。</p>\n\n<p>树中每个节点都有一个值，用下标从<b>&nbsp;0</b>&nbsp;开始、长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>cost</code>&nbsp;表示，其中&nbsp;<code>cost[i]</code>&nbsp;是第&nbsp;<code>i + 1</code>&nbsp;个节点的值。每次操作，你可以将树中&nbsp;<strong>任意</strong>&nbsp;节点的值&nbsp;<strong>增加</strong>&nbsp;<code>1</code>&nbsp;。你可以执行操作 <strong>任意</strong> 次。</p>\n\n<p>你的目标是让根到每一个 <strong>叶子结点</strong>&nbsp;的路径值相等。请你返回 <strong>最少</strong>&nbsp;需要执行增加操作多少次。</p>\n\n<p><b>注意：</b></p>\n\n<ul>\n\t<li><strong>满二叉树</strong>&nbsp;指的是一棵树，它满足树中除了叶子节点外每个节点都恰好有 2 个节点，且所有叶子节点距离根节点距离相同。</li>\n\t<li><strong>路径值</strong> 指的是路径上所有节点的值之和。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/04/binaryytreeedrawio-4.png\" /></p>\n\n<pre>\n<b>输入：</b>n = 7, cost = [1,5,2,2,3,3,1]\n<b>输出：</b>6\n<b>解释：</b>我们执行以下的增加操作：\n- 将节点 4 的值增加一次。\n- 将节点 3 的值增加三次。\n- 将节点 7 的值增加两次。\n从根到叶子的每一条路径值都为 9 。\n总共增加次数为 1 + 3 + 2 = 6 。\n这是最小的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/04/binaryytreee2drawio.png\" style=\"width: 205px; height: 151px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 3, cost = [5,3,3]\n<b>输出：</b>0\n<b>解释：</b>两条路径已经有相等的路径值，所以不需要执行任何增加操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>n + 1</code> 是&nbsp;<code>2</code>&nbsp;的幂</li>\n\t<li><code>cost.length == n</code></li>\n\t<li><code>1 &lt;= cost[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2674.拆分循环链表",
        "hardRate": "MEDIUM",
        "passRate": "83.96%",
        "problemsUrl": "https://leetcode.cn/problems/split-a-circular-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/split-a-circular-linked-list/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2675.将对象数组转换为矩阵",
        "hardRate": "MEDIUM",
        "passRate": "60.44%",
        "problemsUrl": "https://leetcode.cn/problems/array-of-objects-to-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/array-of-objects-to-matrix/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2676.节流",
        "hardRate": "MEDIUM",
        "passRate": "43.71%",
        "problemsUrl": "https://leetcode.cn/problems/throttle/",
        "solutionsUrl": "https://leetcode.cn/problems/throttle/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2677.分块数组",
        "hardRate": "EASY",
        "passRate": "71.25%",
        "problemsUrl": "https://leetcode.cn/problems/chunk-array/",
        "solutionsUrl": "https://leetcode.cn/problems/chunk-array/solution",
        "problemsDesc": "<p>给定一个数组&nbsp;<code>arr</code>&nbsp;和一个块大小&nbsp;<code>size</code>&nbsp;，返回一个 <strong>分块</strong>&nbsp;的数组。<strong>分块</strong>&nbsp;的数组包含了&nbsp;<code>arr</code>&nbsp;中的原始元素，但是每个子数组的长度都是&nbsp;<code>size</code>&nbsp;。如果&nbsp;<code>arr.length</code>&nbsp;不能被&nbsp;<code>size</code>&nbsp;整除，那么最后一个子数组的长度可能小于&nbsp;<code>size</code>&nbsp;。</p>\n\n<p>你可以假设该数组是&nbsp;<code>JSON.parse</code>&nbsp;的输出结果。换句话说，它是有效的JSON。</p>\n\n<p>请你在不使用 lodash 的函数&nbsp;<code>_.chunk</code>&nbsp;的情况下解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [1,2,3,4,5], size = 1\n<b>输出：</b>[[1],[2],[3],[4],[5]]\n<b>解释：</b>数组 <code>arr </code>被分割成了每个只有一个元素的子数组。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [1,9,6,3,2], size = 3\n<b>输出：</b>[[1,9,6],[3,2]]\n<b>解释：</b>数组 <code>arr </code>被分割成了每个有三个元素的子数组。然而，第二个子数组只有两个元素。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [8,5,3,2,6], size = 6\n<b>输出：</b>[[8,5,3,2,6]]\n<b>解释：</b><code>size </code>大于 <code>arr.length </code>，因此所有元素都在第一个子数组中。\n</pre>\n\n<p><strong class=\"example\">示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [], size = 1\n<b>输出：</b>[]\n<b>解释：</b>没有元素需要分块，因此返回一个空数组。</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>arr is a valid JSON array</code></li>\n\t<li><code>2 &lt;= JSON.stringify(arr).length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= size &lt;= arr.length + 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2678.老人的数目",
        "hardRate": "EASY",
        "passRate": "82.85%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-senior-citizens/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-senior-citizens/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>details</code>&nbsp;。<code>details</code>&nbsp;中每个元素都是一位乘客的信息，信息用长度为 <code>15</code>&nbsp;的字符串表示，表示方式如下：</p>\n\n<ul>\n\t<li>前十个字符是乘客的手机号码。</li>\n\t<li>接下来的一个字符是乘客的性别。</li>\n\t<li>接下来两个字符是乘客的年龄。</li>\n\t<li>最后两个字符是乘客的座位号。</li>\n</ul>\n\n<p>请你返回乘客中年龄 <strong>严格大于 60 岁</strong>&nbsp;的人数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>details = [\"7868190130M7522\",\"5303914400F9211\",\"9273338290F4010\"]\n<b>输出：</b>2\n<b>解释：</b>下标为 0 ，1 和 2 的乘客年龄分别为 75 ，92 和 40 。所以有 2 人年龄大于 60 岁。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>details = [\"1313579440F2036\",\"2921522980M5644\"]\n<b>输出：</b>0\n<b>解释：</b>没有乘客的年龄大于 60 岁。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= details.length &lt;= 100</code></li>\n\t<li><code>details[i].length == 15</code></li>\n\t<li><code>details[i]</code>&nbsp;中的数字只包含&nbsp;<code>'0'</code>&nbsp;到&nbsp;<code>'9'</code>&nbsp;。</li>\n\t<li><code>details[i][10]</code>&nbsp;是 <code>'M'</code>&nbsp;，<code>'F'</code>&nbsp;或者&nbsp;<code>'O'</code>&nbsp;之一。</li>\n\t<li>所有乘客的手机号码和座位号互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2679.矩阵中的和",
        "hardRate": "MEDIUM",
        "passRate": "78.49%",
        "problemsUrl": "https://leetcode.cn/problems/sum-in-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-in-a-matrix/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>nums</code>&nbsp;。一开始你的分数为&nbsp;<code>0</code>&nbsp;。你需要执行以下操作直到矩阵变为空：</p>\n\n<ol>\n\t<li>矩阵中每一行选取最大的一个数，并删除它。如果一行中有多个最大的数，选择任意一个并删除。</li>\n\t<li>在步骤 1 删除的所有数字中找到最大的一个数字，将它添加到你的 <strong>分数</strong>&nbsp;中。</li>\n</ol>\n\n<p>请你返回最后的 <strong>分数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [[7,2,1],[6,4,2],[6,5,3],[3,2,1]]\n<b>输出：</b>15\n<b>解释：</b>第一步操作中，我们删除 7 ，6 ，6 和 3 ，将分数增加 7 。下一步操作中，删除 2 ，4 ，5 和 2 ，将分数增加 5 。最后删除 1 ，2 ，3 和 1 ，将分数增加 3 。所以总得分为 7 + 5 + 3 = 15 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [[1]]\n<b>输出：</b>1\n<b>解释：</b>我们删除 1 并将分数增加 1 ，所以返回 1 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= nums[i].length &lt;= 500</code></li>\n\t<li><code>0 &lt;= nums[i][j] &lt;= 10<sup>3</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2680.最大或值",
        "hardRate": "MEDIUM",
        "passRate": "42.52%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-or/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-or/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code> 。每一次操作中，你可以选择一个数并将它乘&nbsp;<code>2</code>&nbsp;。</p>\n\n<p>你最多可以进行 <code>k</code>&nbsp;次操作，请你返回<em>&nbsp;</em><code>nums[0] | nums[1] | ... | nums[n - 1]</code>&nbsp;的最大值。</p>\n\n<p><code>a | b</code>&nbsp;表示两个整数 <code>a</code>&nbsp;和 <code>b</code>&nbsp;的 <strong>按位或</strong>&nbsp;运算。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [12,9], k = 1\n<b>输出：</b>30\n<b>解释：</b>如果我们对下标为 1 的元素进行操作，新的数组为 [12,18] 。此时得到最优答案为 12 和 18 的按位或运算的结果，也就是 30 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [8,1,2], k = 2\n<b>输出：</b>35\n<b>解释：</b>如果我们对下标 0 处的元素进行操作，得到新数组 [32,1,2] 。此时得到最优答案为 32|1|2 = 35 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 15</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2681.英雄的力量",
        "hardRate": "HARD",
        "passRate": "36.77%",
        "problemsUrl": "https://leetcode.cn/problems/power-of-heroes/",
        "solutionsUrl": "https://leetcode.cn/problems/power-of-heroes/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，它表示英雄的能力值。如果我们选出一部分英雄，这组英雄的 <strong>力量</strong>&nbsp;定义为：</p>\n\n<ul>\n\t<li><code>i<sub>0</sub></code>&nbsp;，<code>i<sub>1</sub></code>&nbsp;，<span style=\"\">... </span><code><span style=\"\">i<sub>k</sub></span></code><span style=\"\">&nbsp;</span>表示这组英雄在数组中的下标。那么这组英雄的力量为&nbsp;<code><font face=\"monospace\">max(nums[</font>i<sub>0</sub><font face=\"monospace\">],nums[</font>i<sub>1</sub><font face=\"monospace\">] ... nums[</font><span style=\"font-size:10.8333px\">i<sub>k</sub></span><font face=\"monospace\">])<sup>2</sup> * min(nums[</font>i<sub>0</sub><font face=\"monospace\">],nums[</font>i<sub>1</sub><font face=\"monospace\">] ... nums[</font><span style=\"font-size:10.8333px\">i<sub>k</sub></span><font face=\"monospace\">])</font></code> 。</li>\n</ul>\n\n<p>请你返回所有可能的 <strong>非空</strong> 英雄组的 <strong>力量</strong> 之和。由于答案可能非常大，请你将结果对&nbsp;<code>10<sup>9 </sup>+ 7</code>&nbsp;<strong>取余。</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,1,4]\n<b>输出：</b>141\n<b>解释：</b>\n第 1&nbsp;组：[2] 的力量为 2<sup>2</sup>&nbsp;* 2 = 8 。\n第 2&nbsp;组：[1] 的力量为 1<sup>2</sup> * 1 = 1 。\n第 3&nbsp;组：[4] 的力量为 4<sup>2</sup> * 4 = 64 。\n第 4&nbsp;组：[2,1] 的力量为 2<sup>2</sup> * 1 = 4 。\n第 5 组：[2,4] 的力量为 4<sup>2</sup> * 2 = 32 。\n第 6&nbsp;组：[1,4] 的力量为 4<sup>2</sup> * 1 = 16 。\n第​ ​​​​​​7&nbsp;组：[2,1,4] 的力量为 4<sup>2</sup>​​​​​​​ * 1 = 16 。\n所有英雄组的力量之和为 8 + 1 + 64 + 4 + 32 + 16 + 16 = 141 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,1,1]\n<b>输出：</b>7\n<b>解释：</b>总共有 7 个英雄组，每一组的力量都是 1 。所以所有英雄组的力量之和为 7 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2682.找出转圈游戏输家",
        "hardRate": "EASY",
        "passRate": "54.01%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-losers-of-the-circular-game/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-losers-of-the-circular-game/solution",
        "problemsDesc": "<p><code>n</code> 个朋友在玩游戏。这些朋友坐成一个圈，按 <strong>顺时针方向</strong> 从 <code>1</code> 到 <code>n</code> 编号。从第 <code>i</code> 个朋友的位置开始顺时针移动 <code>1</code> 步会到达第 <code>(i + 1)</code> 个朋友的位置（<code>1 &lt;= i &lt; n</code>），而从第 <code>n</code> 个朋友的位置开始顺时针移动 <code>1</code> 步会回到第 <code>1</code> 个朋友的位置。</p>\n\n<p>游戏规则如下：</p>\n\n<p>第 <code>1</code> 个朋友接球。</p>\n\n<ul>\n\t<li>接着，第 <code>1</code> 个朋友将球传给距离他顺时针方向 <code>k</code> 步的朋友。</li>\n\t<li>然后，接球的朋友应该把球传给距离他顺时针方向 <code>2 * k</code> 步的朋友。</li>\n\t<li>接着，接球的朋友应该把球传给距离他顺时针方向 <code>3 * k</code> 步的朋友，以此类推。</li>\n</ul>\n\n<p>换句话说，在第 <code>i</code> 轮中持有球的那位朋友需要将球传递给距离他顺时针方向 <code>i * k</code> 步的朋友。</p>\n\n<p>当某个朋友第 2 次接到球时，游戏结束。</p>\n\n<p>在整场游戏中没有接到过球的朋友是 <strong>输家</strong> 。</p>\n\n<p>给你参与游戏的朋友数量 <code>n</code> 和一个整数 <code>k</code> ，请按升序排列返回包含所有输家编号的数组 <code>answer</code> 作为答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, k = 2\n<strong>输出：</strong>[4,5]\n<strong>解释：</strong>以下为游戏进行情况：\n1）第 1 个朋友接球，第 <code>1</code> 个朋友将球传给距离他顺时针方向 2 步的玩家 —— 第 3 个朋友。\n2）第 3 个朋友将球传给距离他顺时针方向 4 步的玩家 —— 第 2 个朋友。\n3）第 2 个朋友将球传给距离他顺时针方向 6 步的玩家 —— 第 3 个朋友。\n4）第 3 个朋友接到两次球，游戏结束。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, k = 4\n<strong>输出：</strong>[2,3,4]\n<strong>解释：</strong>以下为游戏进行情况：\n1）第 1 个朋友接球，第 <code>1</code> 个朋友将球传给距离他顺时针方向 4 步的玩家 —— 第 1 个朋友。\n2）第 1 个朋友接到两次球，游戏结束。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2683.相邻值的按位异或",
        "hardRate": "MEDIUM",
        "passRate": "69.08%",
        "problemsUrl": "https://leetcode.cn/problems/neighboring-bitwise-xor/",
        "solutionsUrl": "https://leetcode.cn/problems/neighboring-bitwise-xor/solution",
        "problemsDesc": "<p>下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的数组 <code>derived</code> 是由同样长度为 <code>n</code> 的原始 <strong>二进制数组</strong> <code>original</code> 通过计算相邻值的 <strong>按位异或（⊕）</strong>派生而来。</p>\n\n<p>特别地，对于范围&nbsp;<code>[0, n - 1]</code> 内的每个下标 <code>i</code> ：</p>\n\n<ul>\n\t<li>如果 <code>i = n - 1</code> ，那么 <code>derived[i] = original[i] ⊕ original[0]</code></li>\n\t<li>否则 <code>derived[i] = original[i] ⊕ original[i + 1]</code></li>\n</ul>\n\n<p>给你一个数组 <code>derived</code> ，请判断是否存在一个能够派生得到 <code>derived</code> 的 <strong>有效原始二进制数组</strong> <code>original</code> 。</p>\n\n<p>如果存在满足要求的原始二进制数组，返回 <em><strong>true</strong> </em>；否则，返回<em> <strong>false</strong> </em>。</p>\n\n<ul>\n\t<li>二进制数组是仅由 <strong>0</strong> 和 <strong>1</strong> 组成的数组。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>derived = [1,1,0]\n<strong>输出：</strong>true\n<strong>解释：</strong>能够派生得到 [1,1,0] 的有效原始二进制数组是 [0,1,0] ：\nderived[0] = original[0] ⊕ original[1] = 0 ⊕ 1 = 1 \nderived[1] = original[1] ⊕ original[2] = 1 ⊕ 0 = 1\nderived[2] = original[2] ⊕ original[0] = 0 ⊕ 0 = 0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>derived = [1,1]\n<strong>输出：</strong>true\n<strong>解释：</strong>能够派生得到 [1,1] 的有效原始二进制数组是 [0,1] ：\nderived[0] = original[0] ⊕ original[1] = 1\nderived[1] = original[1] ⊕ original[0] = 1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>derived = [1,0]\n<strong>输出：</strong>false\n<strong>解释：</strong>不存在能够派生得到 [1,0] 的有效原始二进制数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == derived.length</code></li>\n\t<li><code>1 &lt;= n&nbsp;&lt;= 10<sup>5</sup></code></li>\n\t<li><code>derived</code> 中的值不是 <strong>0</strong> 就是 <strong>1</strong> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2684.矩阵中移动的最大次数",
        "hardRate": "MEDIUM",
        "passRate": "40.88%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-moves-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-moves-in-a-grid/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>m x n</code> 的矩阵 <code>grid</code> ，矩阵由若干 <strong>正</strong> 整数组成。</p>\n\n<p>你可以从矩阵第一列中的 <strong>任一</strong> 单元格出发，按以下方式遍历&nbsp;<code>grid</code> ：</p>\n\n<ul>\n\t<li>从单元格 <code>(row, col)</code> 可以移动到&nbsp;<code>(row - 1, col + 1)</code>、<code>(row, col + 1)</code> 和 <code>(row + 1, col + 1)</code> 三个单元格中任一满足值 <strong>严格</strong> 大于当前单元格的单元格。</li>\n</ul>\n\n<p>返回你在矩阵中能够 <strong>移动</strong> 的 <strong>最大</strong> 次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/11/yetgriddrawio-10.png\" style=\"width: 201px; height: 201px;\">\n<pre><strong>输入：</strong>grid = [[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]]\n<strong>输出：</strong>3\n<strong>解释：</strong>可以从单元格 (0, 0) 开始并且按下面的路径移动：\n- (0, 0) -&gt; (0, 1).\n- (0, 1) -&gt; (1, 2).\n- (1, 2) -&gt; (2, 3).\n可以证明这是能够移动的最大次数。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/12/yetgrid4drawio.png\">\n<strong>输入：</strong>grid = [[3,2,4],[2,1,9],[1,1,7]]\n<strong>输出：</strong>0\n<strong>解释：</strong>从第一列的任一单元格开始都无法移动。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2685.统计完全连通分量的数量",
        "hardRate": "MEDIUM",
        "passRate": "67.38%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-complete-components/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-complete-components/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> 。现有一个包含 <code>n</code> 个顶点的 <strong>无向</strong> 图，顶点按从 <code>0</code> 到 <code>n - 1</code> 编号。给你一个二维整数数组 <code>edges</code> 其中 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示顶点 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间存在一条 <strong>无向</strong> 边。</p>\n\n<p>返回图中 <strong>完全连通分量</strong> 的数量。</p>\n\n<p>如果在子图中任意两个顶点之间都存在路径，并且子图中没有任何一个顶点与子图外部的顶点共享边，则称其为 <strong>连通分量</strong> 。</p>\n\n<p>如果连通分量中每对节点之间都存在一条边，则称其为 <strong>完全连通分量</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/11/screenshot-from-2023-04-11-23-31-23.png\" style=\"width: 671px; height: 270px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6, edges = [[0,1],[0,2],[1,2],[3,4]]\n<strong>输出：</strong>3\n<strong>解释：</strong>如上图所示，可以看到此图所有分量都是完全连通分量。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/11/screenshot-from-2023-04-11-23-32-00.png\" style=\"width: 671px; height: 270px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6, edges = [[0,1],[0,2],[1,2],[3,4],[3,5]]\n<strong>输出：</strong>1\n<strong>解释：</strong>包含节点 0、1 和 2 的分量是完全连通分量，因为每对节点之间都存在一条边。\n包含节点 3 、4 和 5 的分量不是完全连通分量，因为节点 4 和 5 之间不存在边。\n因此，在图中完全连接分量的数量是 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>0 &lt;= edges.length &lt;= n * (n - 1) / 2</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>不存在重复的边</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2686.即时食物配送 III",
        "hardRate": "MEDIUM",
        "passRate": "68.63%",
        "problemsUrl": "https://leetcode.cn/problems/immediate-food-delivery-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/immediate-food-delivery-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2687.自行车的最后使用时间",
        "hardRate": "EASY",
        "passRate": "86.64%",
        "problemsUrl": "https://leetcode.cn/problems/bikes-last-time-used/",
        "solutionsUrl": "https://leetcode.cn/problems/bikes-last-time-used/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2688.查找活跃用户",
        "hardRate": "MEDIUM",
        "passRate": "45.97%",
        "problemsUrl": "https://leetcode.cn/problems/find-active-users/",
        "solutionsUrl": "https://leetcode.cn/problems/find-active-users/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2689.从 Rope 树中提取第 K 个字符",
        "hardRate": "EASY",
        "passRate": "76.98%",
        "problemsUrl": "https://leetcode.cn/problems/extract-kth-character-from-the-rope-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/extract-kth-character-from-the-rope-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2690.无穷方法对象",
        "hardRate": "EASY",
        "passRate": "95.05%",
        "problemsUrl": "https://leetcode.cn/problems/infinite-method-object/",
        "solutionsUrl": "https://leetcode.cn/problems/infinite-method-object/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2691.不可变辅助工具",
        "hardRate": "HARD",
        "passRate": "26.71%",
        "problemsUrl": "https://leetcode.cn/problems/immutability-helper/",
        "solutionsUrl": "https://leetcode.cn/problems/immutability-helper/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2692.使对象不可变",
        "hardRate": "MEDIUM",
        "passRate": "51.26%",
        "problemsUrl": "https://leetcode.cn/problems/make-object-immutable/",
        "solutionsUrl": "https://leetcode.cn/problems/make-object-immutable/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2693.使用自定义上下文调用函数",
        "hardRate": "MEDIUM",
        "passRate": "70.88%",
        "problemsUrl": "https://leetcode.cn/problems/call-function-with-custom-context/",
        "solutionsUrl": "https://leetcode.cn/problems/call-function-with-custom-context/solution",
        "problemsDesc": "<p>增强所有函数，使其具有&nbsp;<code>callPolyfill</code>&nbsp;方法。该方法接受一个对象&nbsp;<code>obj</code>&nbsp;作为第一个参数，以及任意数量的附加参数。<code>obj</code>&nbsp;成为函数的&nbsp;<code>this</code>&nbsp;上下文。附加参数将传递给该函数（即&nbsp;<code>callPolyfill</code>&nbsp;方法所属的函数）。</p>\n\n<p>例如，如果有以下函数：</p>\n\n<pre>\nfunction tax(price, taxRate) {\n  const totalCost = price * (1 + taxRate);\n&nbsp; console.log(`The cost of ${this.item} is ${totalCost}`);\n}\n</pre>\n\n<p>调用&nbsp;<code>tax(10, 0.1)</code>&nbsp;将输出&nbsp;<code>\"The cost of undefined is 11\"</code>&nbsp;。这是因为&nbsp;<code>this</code>&nbsp;上下文未定义。</p>\n\n<p>然而，调用&nbsp;<code>tax.callPolyfill({item: \"salad\"}, 10, 0.1)</code>&nbsp;将输出&nbsp;<code>\"The cost of salad is 11\"</code>&nbsp;。<code>this</code>&nbsp;上下文被正确设置，函数输出了适当的结果。</p>\n\n<p>请在不使用内置的&nbsp;<code>Function.call</code>&nbsp;方法的情况下解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nfn = function add(b) {\n  return this.a + b;\n}\nargs = [{\"a\": 5}, 7]\n<b>输出：</b>12\n<strong>解释：</strong>\nfn.callPolyfill({\"a\": 5}, 7); // 12\n<code>callPolyfill </code>将 \"this\" 上下文设置为 <code>{\"a\": 5} </code>，并将 7 作为参数传递。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>\nfn = function tax(price, taxRate) { \n&nbsp;return `The cost of the ${this.item} is ${price * taxRate}`; \n}\nargs = [{\"item\": \"burger\"}, 10, 1,1]\n<b>输出：</b>\"The cost of the burger is 11\"\n<b>解释：</b><code>callPolyfill </code>将 \"this\" 上下文设置为 <code>{\"item\": \"burger\"} </code>，并将 10 和 1.1 作为附加参数传递。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul style=\"list-style-type:square;\">\n\t<li><code><font face=\"monospace\">typeof args[0] == 'object' and args[0] != null</font></code></li>\n\t<li><code>1 &lt;= args.length &lt;= 100</code></li>\n\t<li><code>2 &lt;= JSON.stringify(args[0]).length &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2694.事件发射器",
        "hardRate": "MEDIUM",
        "passRate": "57.16%",
        "problemsUrl": "https://leetcode.cn/problems/event-emitter/",
        "solutionsUrl": "https://leetcode.cn/problems/event-emitter/solution",
        "problemsDesc": "<p>设计一个 <code>EventEmitter</code> 类。这个接口与 Node.js 或 DOM 的 Event Target 接口相似，但有一些差异。<code>EventEmitter</code> 应该允许订阅事件和触发事件。</p>\n\n<p>你的 <code>EventEmitter</code> 类应该有以下两个方法：</p>\n\n<ul>\n\t<li><strong>subscribe</strong> - 这个方法接收两个参数：一个作为字符串的事件名和一个回调函数。当事件被触发时，这个回调函数将被调用。 一个事件应该能够有多个监听器。当触发带有多个回调函数的事件时，应按照订阅的顺序依次调用每个回调函数。应返回一个结果数组。你可以假设传递给 <code>subscribe</code> 的回调函数都不是引用相同的。 <code>subscribe</code> 方法还应返回一个对象，其中包含一个 <code>unsubscribe</code> 方法，使用户可以取消订阅。当调用 <code>unsubscribe</code> 方法时，回调函数应该从订阅列表中删除，并返回 undefined。</li>\n\t<li><strong>emit</strong> - 这个方法接收两个参数：一个作为字符串的事件名和一个可选的参数数组，这些参数将传递给回调函数。如果没有订阅给定事件的回调函数，则返回一个空数组。否则，按照它们被订阅的顺序返回所有回调函数调用的结果数组。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>actions = [\"EventEmitter\", \"emit\", \"subscribe\", \"subscribe\", \"emit\"], values = [[], [\"firstEvent\", \"function cb1() { return 5; }\"],  [\"firstEvent\", \"function cb1() { return 5; }\"], [\"firstEvent\"]]\n<b>输出：</b>[[],[\"emitted\",[]],[\"subscribed\"],[\"subscribed\"],[\"emitted\",[5,6]]]\n<b>解释：</b>\nconst emitter = new EventEmitter();\nemitter.emit(\"firstEvent\"); // [], 还没有订阅任何回调函数\nemitter.subscribe(\"firstEvent\", function cb1() { return 5; });\nemitter.subscribe(\"firstEvent\", function cb2() { return 6; });\nemitter.emit(\"firstEvent\"); // [5, 6], 返回 cb1 和 cb2 的输出\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>actions = [\"EventEmitter\", \"subscribe\", \"emit\", \"emit\"], values = [[], [\"firstEvent\", \"function cb1(...args) { return args.join(','); }\"], [\"firstEvent\", [1,2,3]], [\"firstEvent\", [3,4,6]]]\n<b>输出：</b>[[],[\"subscribed\"],[\"emitted\",[\"1,2,3\"]],[\"emitted\",[\"3,4,6\"]]]\n<strong>解释：</strong>注意 emit 方法应该能够接受一个可选的参数数组。\n\nconst emitter = new EventEmitter();\nemitter.subscribe(\"firstEvent, function cb1(...args) { return args.join(','); });\nemitter.emit(\"firstEvent\", [1, 2, 3]); // [\"1,2,3\"]\nemitter.emit(\"firstEvent\", [3, 4, 6]); // [\"3,4,6\"]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>actions = [\"EventEmitter\", \"subscribe\", \"emit\", \"unsubscribe\", \"emit\"], values = [[], [\"firstEvent\", \"(...args) =&gt; args.join(',')\"], [\"firstEvent\", [1,2,3]], [0], [\"firstEvent\", [4,5,6]]]\n<b>输出：</b>[[],[\"subscribed\"],[\"emitted\",[\"1,2,3\"]],[\"unsubscribed\",0],[\"emitted\",[]]]\n<b>解释：</b>\nconst emitter = new EventEmitter();\nconst sub = emitter.subscribe(\"firstEvent\", (...args) =&gt; args.join(','));\nemitter.emit(\"firstEvent\", [1, 2, 3]); // [\"1,2,3\"]\nsub.unsubscribe(); // undefined\nemitter.emit(\"firstEvent\", [4, 5, 6]); // [], 没有订阅者\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>actions = [\"EventEmitter\", \"subscribe\", \"subscribe\", \"unsubscribe\", \"emit\"], values = [[], [\"firstEvent\", \"x =&gt; x + 1\"], [\"firstEvent\", \"x =&gt; x + 2\"], [0], [\"firstEvent\", [5]]]\n<b>输出：</b>[[],[\"subscribed\"],[\"emitted\",[\"1,2,3\"]],[\"unsubscribed\",0],[\"emitted\",[7]]]\n<b>解释：</b>\nconst emitter = new EventEmitter();\nconst sub1 = emitter.subscribe(\"firstEvent\", x =&gt; x + 1);\nconst sub2 = emitter.subscribe(\"firstEvent\", x =&gt; x + 2);\nsub1.unsubscribe(); // undefined\nemitter.emit(\"firstEvent\", [5]); // [7]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= actions.length &lt;= 10</code></li>\n\t<li><code>values.length === actions.length</code></li>\n\t<li>所有测试用例都是有效的。例如，你不需要处理取消一个不存在的订阅的情况。</li>\n\t<li>只有 4 种不同的操作：<code>EventEmitter</code>、<code>emit</code>、<code>subscribe</code> 和 <code>unsubscribe</code>&nbsp;。 <code>EventEmitter</code> 操作没有参数。</li>\n\t<li><code>emit</code> 操作接收 1 或 2 个参数。第一个参数是要触发的事件名，第二个参数传递给回调函数。</li>\n\t<li><code>subscribe</code> 操作接收 2 个参数，第一个是事件名，第二个是回调函数。</li>\n\t<li><code>unsubscribe</code> 操作接收一个参数，即之前进行订阅的顺序（从 0 开始）。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2695.包装数组",
        "hardRate": "EASY",
        "passRate": "72.51%",
        "problemsUrl": "https://leetcode.cn/problems/array-wrapper/",
        "solutionsUrl": "https://leetcode.cn/problems/array-wrapper/solution",
        "problemsDesc": "<p>创建一个名为 <code>ArrayWrapper</code> 的类，它在其构造函数中接受一个整数数组作为参数。该类应具有以下两个特性：</p>\n\n<ul>\n\t<li>当使用 <code>+</code> 运算符将两个该类的实例相加时，结果值为两个数组中所有元素的总和。</li>\n\t<li>当在实例上调用 <code>String()</code> 函数时，它将返回一个由逗号分隔的括在方括号中的字符串。例如，<code>[1,2,3]</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [[1,2],[3,4]], operation = \"Add\"\n<b>输出：</b>10\n<b>解释：</b>\nconst obj1 = new ArrayWrapper([1,2]);\nconst obj2 = new ArrayWrapper([3,4]);\nobj1 + obj2; // 10\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [[23,98,42,70]], operation = \"String\"\n<b>输出：</b>\"[23,98,42,70]\"\n<strong>解释：</strong>\nconst obj = new ArrayWrapper([23,98,42,70]);\nString(obj); // \"[23,98,42,70]\"\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [[],[]], operation = \"Add\"\n<b>输出：</b>0\n<strong>解释：</strong>\nconst obj1 = new ArrayWrapper([]);\nconst obj2 = new ArrayWrapper([]);\nobj1 + obj2; // 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i]&nbsp;&lt;= 1000</code></li>\n\t<li><code>注意：nums 是传递给构造函数的数组。</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2696.删除子串后的字符串最小长度",
        "hardRate": "EASY",
        "passRate": "72.51%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-string-length-after-removing-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-string-length-after-removing-substrings/solution",
        "problemsDesc": "<p>给你一个仅由 <strong>大写</strong> 英文字符组成的字符串 <code>s</code> 。</p>\n\n<p>你可以对此字符串执行一些操作，在每一步操作中，你可以从 <code>s</code> 中删除 <strong>任一个</strong> <code>\"AB\"</code> 或 <code>\"CD\"</code> 子字符串。</p>\n\n<p>通过执行操作，删除所有&nbsp;<code>\"AB\"</code> 和 <code>\"CD\"</code> 子串，返回可获得的最终字符串的 <strong>最小</strong> 可能长度。</p>\n\n<p><strong>注意</strong>，删除子串后，重新连接出的字符串可能会产生新的&nbsp;<code>\"AB\"</code> 或 <code>\"CD\"</code> 子串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ABFCACDB\"\n<strong>输出：</strong>2\n<strong>解释：</strong>你可以执行下述操作：\n- 从 \"<em><strong>AB</strong></em>FCACDB\" 中删除子串 \"AB\"，得到 s = \"FCACDB\" 。\n- 从 \"FCA<em><strong>CD</strong></em>B\" 中删除子串 \"CD\"，得到 s = \"FCAB\" 。\n- 从 \"FC<strong><em>AB</em></strong>\" 中删除子串 \"AB\"，得到 s = \"FC\" 。\n最终字符串的长度为 2 。\n可以证明 2 是可获得的最小长度。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ACBBD\"\n<strong>输出：</strong>5\n<strong>解释：</strong>无法执行操作，字符串长度不变。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 仅由大写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2697.字典序最小回文串",
        "hardRate": "EASY",
        "passRate": "82.66%",
        "problemsUrl": "https://leetcode.cn/problems/lexicographically-smallest-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/lexicographically-smallest-palindrome/solution",
        "problemsDesc": "<p>给你一个由 <strong>小写英文字母</strong> 组成的字符串 <code>s</code> ，你可以对其执行一些操作。在一步操作中，你可以用其他小写英文字母 <strong>替换</strong>&nbsp; <code>s</code> 中的一个字符。</p>\n\n<p>请你执行 <strong>尽可能少的操作</strong> ，使 <code>s</code> 变成一个 <strong>回文串</strong> 。如果执行 <strong>最少</strong> 操作次数的方案不止一种，则只需选取 <strong>字典序最小</strong> 的方案。</p>\n\n<p>对于两个长度相同的字符串 <code>a</code> 和 <code>b</code> ，在 <code>a</code> 和 <code>b</code> 出现不同的第一个位置，如果该位置上 <code>a</code> 中对应字母比 <code>b</code> 中对应字母在字母表中出现顺序更早，则认为 <code>a</code> 的字典序比 <code>b</code> 的字典序要小。</p>\n\n<p>返回最终的回文字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"egcfe\"\n<strong>输出：</strong>\"efcfe\"\n<strong>解释：</strong>将 \"egcfe\" 变成回文字符串的最小操作次数为 1 ，修改 1 次得到的字典序最小回文字符串是 \"efcfe\"，只需将 'g' 改为 'f' 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\"\n<strong>输出：</strong>\"abba\"\n<strong>解释：</strong>将 \"abcd\" 变成回文字符串的最小操作次数为 2 ，修改 2 次得到的字典序最小回文字符串是 \"abba\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"seven\"\n<strong>输出：</strong>\"neven\"\n<strong>解释：</strong>将 \"seven\" 变成回文字符串的最小操作次数为 1 ，修改 1 次得到的字典序最小回文字符串是 \"neven\" 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2698.求一个整数的惩罚数",
        "hardRate": "MEDIUM",
        "passRate": "67.05%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/solution",
        "problemsDesc": "<p>给你一个正整数&nbsp;<code>n</code>&nbsp;，请你返回&nbsp;<code>n</code>&nbsp;的&nbsp;<strong>惩罚数</strong>&nbsp;。</p>\n\n<p><code>n</code>&nbsp;的 <strong>惩罚数</strong>&nbsp;定义为所有满足以下条件 <code>i</code>&nbsp;的数的平方和：</p>\n\n<ul>\n\t<li><code>1 &lt;= i &lt;= n</code></li>\n\t<li><code>i * i</code> 的十进制表示的字符串可以分割成若干连续子字符串，且这些子字符串对应的整数值之和等于 <code>i</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 10\n<b>输出：</b>182\n<b>解释：</b>总共有 3 个整数 i 满足要求：\n- 1 ，因为 1 * 1 = 1\n- 9 ，因为 9 * 9 = 81 ，且 81 可以分割成 8 + 1 。\n- 10 ，因为 10 * 10 = 100 ，且 100 可以分割成 10 + 0 。\n因此，10 的惩罚数为 1 + 81 + 100 = 182\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 37\n<b>输出：</b>1478\n<b>解释：</b>总共有 4 个整数 i 满足要求：\n- 1 ，因为 1 * 1 = 1\n- 9 ，因为 9 * 9 = 81 ，且 81 可以分割成 8 + 1 。\n- 10 ，因为 10 * 10 = 100 ，且 100 可以分割成 10 + 0 。\n- 36 ，因为 36 * 36 = 1296 ，且 1296 可以分割成 1 + 29 + 6 。\n因此，37 的惩罚数为 1 + 81 + 100 + 1296 = 1478\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2699.修改图中的边权",
        "hardRate": "HARD",
        "passRate": "52.52%",
        "problemsUrl": "https://leetcode.cn/problems/modify-graph-edge-weights/",
        "solutionsUrl": "https://leetcode.cn/problems/modify-graph-edge-weights/solution",
        "problemsDesc": "<p>给你一个 <code>n</code>&nbsp;个节点的 <strong>无向带权连通</strong>&nbsp;图，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，再给你一个整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>, w<sub>i</sub>]</code>&nbsp;表示节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条边权为&nbsp;<code>w<sub>i</sub></code>&nbsp;的边。</p>\n\n<p>部分边的边权为&nbsp;<code>-1</code>（<code>w<sub>i</sub> = -1</code>），其他边的边权都为 <strong>正</strong>&nbsp;数（<code>w<sub>i</sub> &gt; 0</code>）。</p>\n\n<p>你需要将所有边权为 <code>-1</code>&nbsp;的边都修改为范围&nbsp;<code>[1, 2 * 10<sup>9</sup>]</code>&nbsp;中的 <strong>正整数</strong>&nbsp;，使得从节点&nbsp;<code>source</code>&nbsp;到节点&nbsp;<code>destination</code>&nbsp;的 <strong>最短距离</strong>&nbsp;为整数&nbsp;<code>target</code>&nbsp;。如果有 <strong>多种</strong>&nbsp;修改方案可以使&nbsp;<code>source</code> 和&nbsp;<code>destination</code>&nbsp;之间的最短距离等于&nbsp;<code>target</code>&nbsp;，你可以返回任意一种方案。</p>\n\n<p>如果存在使 <code>source</code>&nbsp;到 <code>destination</code>&nbsp;最短距离为 <code>target</code>&nbsp;的方案，请你按任意顺序返回包含所有边的数组（包括未修改边权的边）。如果不存在这样的方案，请你返回一个 <strong>空数组</strong>&nbsp;。</p>\n\n<p><strong>注意：</strong>你不能修改一开始边权为正数的边。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/18/graph.png\" style=\"width: 300px; height: 300px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>n = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5\n<b>输出：</b>[[4,1,1],[2,0,1],[0,3,3],[4,3,1]]\n<b>解释：</b>上图展示了一个满足题意的修改方案，从 0 到 1 的最短距离为 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/18/graph-2.png\" style=\"width: 300px; height: 300px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>n = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6\n<b>输出：</b>[]\n<b>解释：</b>上图是一开始的图。没有办法通过修改边权为 -1 的边，使得 0 到 2 的最短距离等于 6 ，所以返回一个空数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/19/graph-3.png\" style=\"width: 300px; height: 300px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>n = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6\n<b>输出：</b>[[1,0,4],[1,2,3],[2,3,5],[0,3,1]]\n<b>解释：</b>上图展示了一个满足题意的修改方案，从 0 到 2 的最短距离为 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= n * (n - 1) / 2</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i&nbsp;</sub>&lt;&nbsp;n</code></li>\n\t<li><code>w<sub>i</sub>&nbsp;= -1</code> 或者 <code>1 &lt;= w<sub>i&nbsp;</sub>&lt;= 10<sup><span style=\"\">7</span></sup></code></li>\n\t<li><code>a<sub>i&nbsp;</sub>!=&nbsp;b<sub>i</sub></code></li>\n\t<li><code>0 &lt;= source, destination &lt; n</code></li>\n\t<li><code>source != destination</code></li>\n\t<li><code>1 &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li>输入的图是连通图，且没有自环和重边。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2700.两个对象之间的差异",
        "hardRate": "MEDIUM",
        "passRate": "58.42%",
        "problemsUrl": "https://leetcode.cn/problems/differences-between-two-objects/",
        "solutionsUrl": "https://leetcode.cn/problems/differences-between-two-objects/solution",
        "problemsDesc": null,
        "isPlus": true
    }
]