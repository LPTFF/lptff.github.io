[
    {
        "problemsName": " 51.N 皇后",
        "hardRate": "HARD",
        "passRate": "74.09%",
        "problemsUrl": "https://leetcode.cn/problems/n-queens/",
        "solutionsUrl": "https://leetcode.cn/problems/n-queens/solution",
        "problemsDesc": "<p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p>\n\n<p><strong>n&nbsp;皇后问题</strong> 研究的是如何将 <code>n</code>&nbsp;个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>\n\n<p>给你一个整数 <code>n</code> ，返回所有不同的&nbsp;<strong>n<em>&nbsp;</em>皇后问题</strong> 的解决方案。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>每一种解法包含一个不同的&nbsp;<strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code> 分别代表了皇后和空位。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/queens.jpg\" style=\"width: 600px; height: 268px;\" />\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n<strong>解释：</strong>如上图所示，4 皇后问题存在两个不同的解法。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>[[\"Q\"]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 9</code></li>\n</ul>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 52.N 皇后 II",
        "hardRate": "HARD",
        "passRate": "82.38%",
        "problemsUrl": "https://leetcode.cn/problems/n-queens-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/n-queens-ii/solution",
        "problemsDesc": "<p><strong>n&nbsp;皇后问题</strong> 研究的是如何将 <code>n</code>&nbsp;个皇后放置在 <code>n × n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>\n\n<p>给你一个整数 <code>n</code> ，返回 <strong>n 皇后问题</strong> 不同的解决方案的数量。</p>\n\n<p>&nbsp;</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/queens.jpg\" style=\"width: 600px; height: 268px;\" />\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>如上图所示，4 皇后问题存在两个不同的解法。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 9</code></li>\n</ul>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 53.最大子数组和",
        "hardRate": "MEDIUM",
        "passRate": "54.80%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-subarray/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n\n<p><strong>子数组 </strong>是数组中的一个连续部分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-2,1,-3,4,-1,2,1,-5,4]\n<strong>输出：</strong>6\n<strong>解释：</strong>连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,4,-1,7,8]\n<strong>输出：</strong>23\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 54.螺旋矩阵",
        "hardRate": "MEDIUM",
        "passRate": "49.35%",
        "problemsUrl": "https://leetcode.cn/problems/spiral-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/spiral-matrix/solution",
        "problemsDesc": "<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>[1,2,3,6,9,8,7,4,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n<strong>输出：</strong>[1,2,3,4,8,12,11,10,9,5,6,7]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 <= m, n <= 10</code></li>\n\t<li><code>-100 <= matrix[i][j] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 55.跳跃游戏",
        "hardRate": "MEDIUM",
        "passRate": "43.55%",
        "problemsUrl": "https://leetcode.cn/problems/jump-game/",
        "solutionsUrl": "https://leetcode.cn/problems/jump-game/solution",
        "problemsDesc": "<p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p>\n\n<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n\n<p>判断你是否能够到达最后一个下标。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,1,1,4]\n<strong>输出：</strong>true\n<strong>解释：</strong>可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,1,0,4]\n<strong>输出：</strong>false\n<strong>解释：</strong>无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 <= nums[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 56.合并区间",
        "hardRate": "MEDIUM",
        "passRate": "49.36%",
        "problemsUrl": "https://leetcode.cn/problems/merge-intervals/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-intervals/solution",
        "problemsDesc": "<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 。请你合并所有重叠的区间，并返回&nbsp;<em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,3],[2,6],[8,10],[15,18]]\n<strong>输出：</strong>[[1,6],[8,10],[15,18]]\n<strong>解释：</strong>区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,4],[4,5]]\n<strong>输出：</strong>[[1,5]]\n<strong>解释：</strong>区间 [1,4] 和 [4,5] 可被视为重叠区间。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 57.插入区间",
        "hardRate": "MEDIUM",
        "passRate": "41.95%",
        "problemsUrl": "https://leetcode.cn/problems/insert-interval/",
        "solutionsUrl": "https://leetcode.cn/problems/insert-interval/solution",
        "problemsDesc": "<p>给你一个<strong> 无重叠的</strong><em> ，</em>按照区间起始端点排序的区间列表。</p>\n\n<p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,3],[6,9]], newInterval = [2,5]\n<strong>输出：</strong>[[1,5],[6,9]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n<strong>输出：</strong>[[1,2],[3,10],[12,16]]\n<strong>解释：</strong>这是因为新的区间 <code>[4,8]</code> 与 <code>[3,5],[6,7],[8,10]</code> 重叠。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [], newInterval = [5,7]\n<strong>输出：</strong>[[5,7]]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,5]], newInterval = [2,3]\n<strong>输出：</strong>[[1,5]]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,5]], newInterval = [2,7]\n<strong>输出：</strong>[[1,7]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= intervals.length <= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 <= intervals[i][0] <= intervals[i][1] <= 10<sup>5</sup></code></li>\n\t<li><code>intervals</code> 根据 <code>intervals[i][0]</code> 按 <strong>升序</strong> 排列</li>\n\t<li><code>newInterval.length == 2</code></li>\n\t<li><code>0 <= newInterval[0] <= newInterval[1] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 58.最后一个单词的长度",
        "hardRate": "EASY",
        "passRate": "42.87%",
        "problemsUrl": "https://leetcode.cn/problems/length-of-last-word/",
        "solutionsUrl": "https://leetcode.cn/problems/length-of-last-word/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code>，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 <strong>最后一个</strong> 单词的长度。</p>\n\n<p><strong>单词</strong> 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"Hello World\"\n<strong>输出：</strong>5\n<strong>解释：</strong>最后一个单词是“World”，长度为5。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"   fly me   to   the moon  \"\n<strong>输出：</strong>4<strong>\n解释：</strong>最后一个单词是“moon”，长度为4。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"luffy is still joyboy\"\n<strong>输出：</strong>6\n<strong>解释：</strong>最后一个单词是长度为6的“joyboy”。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> 仅有英文字母和空格 <code>' '</code> 组成</li>\n\t<li><code>s</code> 中至少存在一个单词</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 59.螺旋矩阵 II",
        "hardRate": "MEDIUM",
        "passRate": "72.64%",
        "problemsUrl": "https://leetcode.cn/problems/spiral-matrix-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/spiral-matrix-ii/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n<sup>2</sup></code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>[[1,2,3],[8,9,4],[7,6,5]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>[[1]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 60.排列序列",
        "hardRate": "HARD",
        "passRate": "53.47%",
        "problemsUrl": "https://leetcode.cn/problems/permutation-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/permutation-sequence/solution",
        "problemsDesc": "<p>给出集合 <code>[1,2,3,...,n]</code>，其所有元素共有 <code>n!</code> 种排列。</p>\n\n<p>按大小顺序列出所有排列情况，并一一标记，当 <code>n = 3</code> 时, 所有排列如下：</p>\n\n<ol>\n\t<li><code>\"123\"</code></li>\n\t<li><code>\"132\"</code></li>\n\t<li><code>\"213\"</code></li>\n\t<li><code>\"231\"</code></li>\n\t<li><code>\"312\"</code></li>\n\t<li><code>\"321\"</code></li>\n</ol>\n\n<p>给定 <code>n</code> 和 <code>k</code>，返回第 <code>k</code> 个排列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 3\n<strong>输出：</strong>\"213\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, k = 9\n<strong>输出：</strong>\"2314\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 1\n<strong>输出：</strong>\"123\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 9</code></li>\n\t<li><code>1 <= k <= n!</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 61.旋转链表",
        "hardRate": "MEDIUM",
        "passRate": "41.40%",
        "problemsUrl": "https://leetcode.cn/problems/rotate-list/",
        "solutionsUrl": "https://leetcode.cn/problems/rotate-list/solution",
        "problemsDesc": "<p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动&nbsp;<code>k</code><em>&nbsp;</em>个位置。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg\" style=\"width: 450px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], k = 2\n<strong>输出：</strong>[4,5,1,2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg\" style=\"width: 305px; height: 350px;\" />\n<pre>\n<strong>输入：</strong>head = [0,1,2], k = 4\n<strong>输出：</strong>[2,0,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目在范围 <code>[0, 500]</code> 内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>0 &lt;= k &lt;= 2 * 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 62.不同路径",
        "hardRate": "MEDIUM",
        "passRate": "67.80%",
        "problemsUrl": "https://leetcode.cn/problems/unique-paths/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-paths/solution",
        "problemsDesc": "<p>一个机器人位于一个 <code>m x n</code><em> </em>网格的左上角 （起始点在下图中标记为 “Start” ）。</p>\n\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>\n\n<p>问总共有多少条不同的路径？</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png\" />\n<pre>\n<strong>输入：</strong>m = 3, n = 7\n<strong>输出：</strong>28</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 3, n = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -> 向下 -> 向下\n2. 向下 -> 向下 -> 向右\n3. 向下 -> 向右 -> 向下\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 7, n = 3\n<strong>输出：</strong>28\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 3, n = 3\n<strong>输出：</strong>6</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= m, n <= 100</code></li>\n\t<li>题目数据保证答案小于等于 <code>2 * 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 63.不同路径 II",
        "hardRate": "MEDIUM",
        "passRate": "41.10%",
        "problemsUrl": "https://leetcode.cn/problems/unique-paths-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-paths-ii/solution",
        "problemsDesc": "<p>一个机器人位于一个<meta charset=\"UTF-8\" />&nbsp;<code>m x n</code>&nbsp;网格的左上角 （起始点在下图中标记为 “Start” ）。</p>\n\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p>\n\n<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>\n\n<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg\" />\n<pre>\n<strong>输入：</strong>obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n<strong>输出：</strong>2\n<strong>解释：</strong>3x3 网格的正中间有一个障碍物。\n从左上角到右下角一共有 <code>2</code> 条不同的路径：\n1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下\n2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg\" />\n<pre>\n<strong>输入：</strong>obstacleGrid = [[0,1],[0,0]]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m ==&nbsp;obstacleGrid.length</code></li>\n\t<li><code>n ==&nbsp;obstacleGrid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 64.最小路径和",
        "hardRate": "MEDIUM",
        "passRate": "69.54%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-path-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-path-sum/solution",
        "problemsDesc": "<p>给定一个包含非负整数的 <code><em>m</em>&nbsp;x&nbsp;<em>n</em></code>&nbsp;网格&nbsp;<code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>\n\n<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,3,1],[1,5,1],[4,2,1]]\n<strong>输出：</strong>7\n<strong>解释：</strong>因为路径 1→3→1→1→1 的总和最小。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,2,3],[4,5,6]]\n<strong>输出：</strong>12\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 200</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 65.有效数字",
        "hardRate": "HARD",
        "passRate": "27.61%",
        "problemsUrl": "https://leetcode.cn/problems/valid-number/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-number/solution",
        "problemsDesc": "<p><strong>有效数字</strong>（按顺序）可以分成以下几个部分：</p>\n\n<ol>\n\t<li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li>\n\t<li>（可选）一个 <code>'e'</code> 或 <code>'E'</code> ，后面跟着一个 <strong>整数</strong></li>\n</ol>\n\n<p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p>\n\n<ol>\n\t<li>（可选）一个符号字符（<code>'+'</code> 或 <code>'-'</code>）</li>\n\t<li>下述格式之一：\n\t<ol>\n\t\t<li>至少一位数字，后面跟着一个点 <code>'.'</code></li>\n\t\t<li>至少一位数字，后面跟着一个点 <code>'.'</code> ，后面再跟着至少一位数字</li>\n\t\t<li>一个点 <code>'.'</code> ，后面跟着至少一位数字</li>\n\t</ol>\n\t</li>\n</ol>\n\n<p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p>\n\n<ol>\n\t<li>（可选）一个符号字符（<code>'+'</code> 或 <code>'-'</code>）</li>\n\t<li>至少一位数字</li>\n</ol>\n\n<p>部分有效数字列举如下：<code>[\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"]</code></p>\n\n<p>部分无效数字列举如下：<code>[\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"]</code></p>\n\n<p>给你一个字符串 <code>s</code> ，如果 <code>s</code> 是一个 <strong>有效数字</strong> ，请返回 <code>true</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"e\"\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \".\"\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>'+'</code> ，减号 <code>'-'</code> ，或者点 <code>'.'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 66.加一",
        "hardRate": "EASY",
        "passRate": "45.12%",
        "problemsUrl": "https://leetcode.cn/problems/plus-one/",
        "solutionsUrl": "https://leetcode.cn/problems/plus-one/solution",
        "problemsDesc": "<p>给定一个由 <strong>整数 </strong>组成的<strong> 非空</strong> 数组所表示的非负整数，在该数的基础上加一。</p>\n\n<p>最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。</p>\n\n<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = [1,2,3]\n<strong>输出：</strong>[1,2,4]\n<strong>解释：</strong>输入数组表示数字 123。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = [4,3,2,1]\n<strong>输出：</strong>[4,3,2,2]\n<strong>解释：</strong>输入数组表示数字 4321。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = [0]\n<strong>输出：</strong>[1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= digits.length <= 100</code></li>\n\t<li><code>0 <= digits[i] <= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 67.二进制求和",
        "hardRate": "EASY",
        "passRate": "52.96%",
        "problemsUrl": "https://leetcode.cn/problems/add-binary/",
        "solutionsUrl": "https://leetcode.cn/problems/add-binary/solution",
        "problemsDesc": "<p>给你两个二进制字符串 <code>a</code> 和 <code>b</code> ，以二进制字符串的形式返回它们的和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入:</strong>a = \"11\", b = \"1\"\n<strong>输出：</strong>\"100\"</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = \"1010\", b = \"1011\"\n<strong>输出：</strong>\"10101\"</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>a</code> 和 <code>b</code> 仅由字符 <code>'0'</code> 或 <code>'1'</code> 组成</li>\n\t<li>字符串如果不是 <code>\"0\"</code> ，就不含前导零</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 68.文本左右对齐",
        "hardRate": "HARD",
        "passRate": "52.34%",
        "problemsUrl": "https://leetcode.cn/problems/text-justification/",
        "solutionsUrl": "https://leetcode.cn/problems/text-justification/solution",
        "problemsDesc": "<p>给定一个单词数组&nbsp;<code>words</code> 和一个长度&nbsp;<code>maxWidth</code>&nbsp;，重新排版单词，使其成为每行恰好有&nbsp;<code>maxWidth</code>&nbsp;个字符，且左右两端对齐的文本。</p>\n\n<p>你应该使用 “<strong>贪心算法</strong>” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格&nbsp;<code>' '</code>&nbsp;填充，使得每行恰好有 <em>maxWidth</em>&nbsp;个字符。</p>\n\n<p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p>\n\n<p>文本的最后一行应为左对齐，且单词之间不插入<strong>额外的</strong>空格。</p>\n\n<p><strong>注意:</strong></p>\n\n<ul>\n\t<li>单词是指由非空格字符组成的字符序列。</li>\n\t<li>每个单词的长度大于 0，小于等于&nbsp;<em>maxWidth</em>。</li>\n\t<li>输入单词数组 <code>words</code>&nbsp;至少包含一个单词。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\n<strong>输出:</strong>\n[\n&nbsp; &nbsp;\"This &nbsp; &nbsp;is &nbsp; &nbsp;an\",\n&nbsp; &nbsp;\"example &nbsp;of text\",\n&nbsp; &nbsp;\"justification. &nbsp;\"\n]\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong>words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\n<strong>输出:</strong>\n[\n&nbsp; \"What &nbsp; must &nbsp; be\",\n&nbsp; \"acknowledgment &nbsp;\",\n&nbsp; \"shall be &nbsp; &nbsp; &nbsp; &nbsp;\"\n]\n<strong>解释: </strong>注意最后一行的格式应为 \"shall be    \" 而不是 \"shall     be\",\n&nbsp;    因为最后一行应为左对齐，而不是左右两端对齐。       \n     第二行同样为左对齐，这是因为这行只包含一个单词。\n</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre>\n<strong>输入:</strong>words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"]，maxWidth = 20\n<strong>输出:</strong>\n[\n&nbsp; \"Science &nbsp;is &nbsp;what we\",\n  \"understand &nbsp; &nbsp; &nbsp;well\",\n&nbsp; \"enough to explain to\",\n&nbsp; \"a &nbsp;computer. &nbsp;Art is\",\n&nbsp; \"everything &nbsp;else &nbsp;we\",\n&nbsp; \"do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\"\n]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 20</code></li>\n\t<li><code>words[i]</code>&nbsp;由小写英文字母和符号组成</li>\n\t<li><code>1 &lt;= maxWidth &lt;= 100</code></li>\n\t<li><code>words[i].length &lt;= maxWidth</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 69.x 的平方根 ",
        "hardRate": "EASY",
        "passRate": "38.41%",
        "problemsUrl": "https://leetcode.cn/problems/sqrtx/",
        "solutionsUrl": "https://leetcode.cn/problems/sqrtx/solution",
        "problemsDesc": "<p>给你一个非负整数 <code>x</code> ，计算并返回&nbsp;<code>x</code>&nbsp;的 <strong>算术平方根</strong> 。</p>\n\n<p>由于返回类型是整数，结果只保留 <strong>整数部分 </strong>，小数部分将被 <strong>舍去 。</strong></p>\n\n<p><strong>注意：</strong>不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 4\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 8\n<strong>输出：</strong>2\n<strong>解释：</strong>8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= x &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 70.爬楼梯",
        "hardRate": "EASY",
        "passRate": "54.06%",
        "problemsUrl": "https://leetcode.cn/problems/climbing-stairs/",
        "solutionsUrl": "https://leetcode.cn/problems/climbing-stairs/solution",
        "problemsDesc": "<p>假设你正在爬楼梯。需要 <code>n</code>&nbsp;阶你才能到达楼顶。</p>\n\n<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>有两种方法可以爬到楼顶。\n1. 1 阶 + 1 阶\n2. 2 阶</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>有三种方法可以爬到楼顶。\n1. 1 阶 + 1 阶 + 1 阶\n2. 1 阶 + 2 阶\n3. 2 阶 + 1 阶\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 45</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 71.简化路径",
        "hardRate": "MEDIUM",
        "passRate": "44.18%",
        "problemsUrl": "https://leetcode.cn/problems/simplify-path/",
        "solutionsUrl": "https://leetcode.cn/problems/simplify-path/solution",
        "problemsDesc": "<p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的 Unix 风格 <strong>绝对路径 </strong>（以 <code>'/'</code> 开头），请你将其转化为更加简洁的规范路径。</p>\n\n<p class=\"MachineTrans-lang-zh-CN\">在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code>'//'</code>）都被视为单个斜杠 <code>'/'</code> 。 对于此问题，任何其他格式的点（例如，<code>'...'</code>）均被视为文件/目录名称。</p>\n\n<p>请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p>\n\n<ul>\n\t<li>始终以斜杠 <code>'/'</code> 开头。</li>\n\t<li>两个目录名之间必须只有一个斜杠 <code>'/'</code> 。</li>\n\t<li>最后一个目录名（如果存在）<strong>不能 </strong>以 <code>'/'</code> 结尾。</li>\n\t<li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 <code>'.'</code> 或 <code>'..'</code>）。</li>\n</ul>\n\n<p>返回简化后得到的 <strong>规范路径</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>path = \"/home/\"\n<strong>输出：</strong>\"/home\"\n<strong>解释：</strong>注意，最后一个目录名后面没有斜杠。 </pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>path = \"/../\"\n<strong>输出：</strong>\"/\"\n<strong>解释：</strong>从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>path = \"/home//foo/\"\n<strong>输出：</strong>\"/home/foo\"\n<strong>解释：</strong>在规范路径中，多个连续斜杠需要用一个斜杠替换。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>path = \"/a/./b/../../c/\"\n<strong>输出：</strong>\"/c\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= path.length <= 3000</code></li>\n\t<li><code>path</code> 由英文字母，数字，<code>'.'</code>，<code>'/'</code> 或 <code>'_'</code> 组成。</li>\n\t<li><code>path</code> 是一个有效的 Unix 风格绝对路径。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 72.编辑距离",
        "hardRate": "HARD",
        "passRate": "62.79%",
        "problemsUrl": "https://leetcode.cn/problems/edit-distance/",
        "solutionsUrl": "https://leetcode.cn/problems/edit-distance/solution",
        "problemsDesc": "<p>给你两个单词&nbsp;<code>word1</code> 和&nbsp;<code>word2</code>， <em>请返回将&nbsp;<code>word1</code>&nbsp;转换成&nbsp;<code>word2</code> 所使用的最少操作数</em> &nbsp;。</p>\n\n<p>你可以对一个单词进行如下三种操作：</p>\n\n<ul>\n\t<li>插入一个字符</li>\n\t<li>删除一个字符</li>\n\t<li>替换一个字符</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"horse\", word2 = \"ros\"\n<strong>输出：</strong>3\n<strong>解释：</strong>\nhorse -&gt; rorse (将 'h' 替换为 'r')\nrorse -&gt; rose (删除 'r')\nrose -&gt; ros (删除 'e')\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"intention\", word2 = \"execution\"\n<strong>输出：</strong>5\n<strong>解释：</strong>\nintention -&gt; inention (删除 't')\ninention -&gt; enention (将 'i' 替换为 'e')\nenention -&gt; exention (将 'n' 替换为 'x')\nexention -&gt; exection (将 'n' 替换为 'c')\nexection -&gt; execution (插入 'u')\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>\n\t<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 73.矩阵置零",
        "hardRate": "MEDIUM",
        "passRate": "63.26%",
        "problemsUrl": "https://leetcode.cn/problems/set-matrix-zeroes/",
        "solutionsUrl": "https://leetcode.cn/problems/set-matrix-zeroes/solution",
        "problemsDesc": "<p>给定一个&nbsp;<code><em>m</em> x <em>n</em></code> 的矩阵，如果一个元素为 <strong>0 </strong>，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a href=\"http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\">原地</a></strong> 算法<strong>。</strong></p>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg\" style=\"width: 450px; height: 169px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,1,1],[1,0,1],[1,1,1]]\n<strong>输出：</strong>[[1,0,1],[0,0,0],[1,0,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg\" style=\"width: 450px; height: 137px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n<strong>输出：</strong>[[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[0].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= matrix[i][j] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>一个直观的解决方案是使用 &nbsp;<code>O(<em>m</em><em>n</em>)</code>&nbsp;的额外空间，但这并不是一个好的解决方案。</li>\n\t<li>一个简单的改进方案是使用 <code>O(<em>m</em>&nbsp;+&nbsp;<em>n</em>)</code> 的额外空间，但这仍然不是最好的解决方案。</li>\n\t<li>你能想出一个仅使用常量空间的解决方案吗？</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 74.搜索二维矩阵",
        "hardRate": "MEDIUM",
        "passRate": "48.73%",
        "problemsUrl": "https://leetcode.cn/problems/search-a-2d-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/search-a-2d-matrix/solution",
        "problemsDesc": "<p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p>\n\n<ul>\n\t<li>每行中的整数从左到右按非递减顺序排列。</li>\n\t<li>每行的第一个整数大于前一行的最后一个整数。</li>\n</ul>\n\n<p>给你一个整数 <code>target</code> ，如果 <code>target</code> 在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/mat.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= matrix[i][j], target &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 75.颜色分类",
        "hardRate": "MEDIUM",
        "passRate": "60.44%",
        "problemsUrl": "https://leetcode.cn/problems/sort-colors/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-colors/solution",
        "problemsDesc": "<p>给定一个包含红色、白色和蓝色、共&nbsp;<code>n</code><em> </em>个元素的数组<meta charset=\"UTF-8\" />&nbsp;<code>nums</code>&nbsp;，<strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\">原地</a></strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>\n\n<p>我们使用整数 <code>0</code>、&nbsp;<code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p>\n\n<ul>\n</ul>\n\n<p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,0,2,1,1,0]\n<strong>输出：</strong>[0,0,1,1,2,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,0,1]\n<strong>输出：</strong>[0,1,2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 300</code></li>\n\t<li><code>nums[i]</code> 为 <code>0</code>、<code>1</code> 或 <code>2</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 76.最小覆盖子串",
        "hardRate": "HARD",
        "passRate": "45.20%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-window-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-window-substring/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>\"\"</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>\n\t<li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ADOBECODEBANC\", t = \"ABC\"\n<strong>输出：</strong>\"BANC\"\n<strong>解释：</strong>最小覆盖子串 \"BANC\" 包含来自字符串 t 的 'A'、'B' 和 'C'。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a\", t = \"a\"\n<strong>输出：</strong>\"a\"\n<strong>解释：</strong>整个字符串 s 是最小覆盖子串。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"a\", t = \"aa\"\n<strong>输出:</strong> \"\"\n<strong>解释:</strong> t 中两个字符 'a' 均应包含在 s 的子串中，\n因此没有符合条件的子字符串，返回空字符串。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code><sup>m == s.length</sup></code></li>\n\t<li><code><sup>n == t.length</sup></code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>进阶：</strong>你能设计一个在 <code>o(m+n)</code> 时间内解决此问题的算法吗？",
        "isPlus": false
    },
    {
        "problemsName": " 77.组合",
        "hardRate": "MEDIUM",
        "passRate": "77.10%",
        "problemsUrl": "https://leetcode.cn/problems/combinations/",
        "solutionsUrl": "https://leetcode.cn/problems/combinations/solution",
        "problemsDesc": "<p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>\n\n<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, k = 2\n<strong>输出：</strong>\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, k = 1\n<strong>输出：</strong>[[1]]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 20</code></li>\n\t<li><code>1 <= k <= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 78.子集",
        "hardRate": "MEDIUM",
        "passRate": "81.12%",
        "problemsUrl": "https://leetcode.cn/problems/subsets/",
        "solutionsUrl": "https://leetcode.cn/problems/subsets/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>\n\n<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>[[],[0]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10</code></li>\n\t<li><code>-10 <= nums[i] <= 10</code></li>\n\t<li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 79.单词搜索",
        "hardRate": "MEDIUM",
        "passRate": "46.25%",
        "problemsUrl": "https://leetcode.cn/problems/word-search/",
        "solutionsUrl": "https://leetcode.cn/problems/word-search/solution",
        "problemsDesc": "<p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word2.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/word3.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n = board[i].length</code></li>\n\t<li><code>1 <= m, n <= 6</code></li>\n\t<li><code>1 <= word.length <= 15</code></li>\n\t<li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你可以使用搜索剪枝的技术来优化解决方案，使其在 <code>board</code> 更大的情况下可以更快解决问题？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 80.删除有序数组中的重复项 II",
        "hardRate": "MEDIUM",
        "passRate": "61.64%",
        "problemsUrl": "https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/solution",
        "problemsDesc": "<p>给你一个有序数组 <code>nums</code> ，请你<strong><a href=\"http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\"> 原地</a></strong> 删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong> ，返回删除后数组的新长度。</p>\n\n<p>不要使用额外的数组空间，你必须在 <strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\">原地 </a>修改输入数组 </strong>并在使用 O(1) 额外空间的条件下完成。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>说明：</strong></p>\n\n<p>为什么返回数值是整数，但输出的答案是数组呢？</p>\n\n<p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>\n\n<p>你可以想象内部操作如下:</p>\n\n<pre>\n// <strong>nums</strong> 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中<strong> 该长度范围内</strong> 的所有元素。\nfor (int i = 0; i &lt; len; i++) {\n&nbsp; &nbsp; print(nums[i]);\n}\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,2,2,3]\n<strong>输出：</strong>5, nums = [1,1,2,2,3]\n<strong>解释：</strong>函数应返回新长度 length = <strong><code>5</code></strong>, 并且原数组的前五个元素被修改为 <strong><code>1, 1, 2, 2,</code></strong> <strong>3 </strong>。 不需要考虑数组中超出新长度后面的元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,0,1,1,1,1,2,3,3]\n<strong>输出：</strong>7, nums = [0,0,1,1,2,3,3]\n<strong>解释：</strong>函数应返回新长度 length = <strong><code>7</code></strong>, 并且原数组的前五个元素被修改为&nbsp;<strong><code>0</code></strong>, <strong>0</strong>, <strong>1</strong>, <strong>1</strong>, <strong>2</strong>, <strong>3</strong>, <strong>3 。</strong> 不需要考虑数组中超出新长度后面的元素。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> 已按升序排列</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 81.搜索旋转排序数组 II",
        "hardRate": "MEDIUM",
        "passRate": "40.97%",
        "problemsUrl": "https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/solution",
        "problemsDesc": "<p>已知存在一个按非降序排列的整数数组 <code>nums</code> ，数组中的值不必互不相同。</p>\n\n<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转 </strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,4,4,5,6,6,7]</code> 在下标 <code>5</code> 处经旋转后可能变为 <code>[4,5,6,6,7,0,1,2,4,4]</code> 。</p>\n\n<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p>你必须尽可能减少整个操作步骤。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2<code>,5,6,0,0,1,2]</code>, target = 0\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2<code>,5,6,0,0,1,2]</code>, target = 3\n<strong>输出：</strong>false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>这是 <a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/\">搜索旋转排序数组</a>&nbsp;的延伸题目，本题中的&nbsp;<code>nums</code>&nbsp; 可能包含重复元素。</li>\n\t<li>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 82.删除排序链表中的重复元素 II",
        "hardRate": "MEDIUM",
        "passRate": "53.53%",
        "problemsUrl": "https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/solution",
        "problemsDesc": "<p>给定一个已排序的链表的头&nbsp;<code>head</code> ，&nbsp;<em>删除原始链表中所有重复数字的节点，只留下不同的数字</em>&nbsp;。返回 <em>已排序的链表</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg\" style=\"height: 142px; width: 500px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,3,4,4,5]\n<strong>输出：</strong>[1,2,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg\" style=\"height: 164px; width: 400px;\" />\n<pre>\n<strong>输入：</strong>head = [1,1,1,2,3]\n<strong>输出：</strong>[2,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点数目在范围 <code>[0, 300]</code> 内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li>题目数据保证链表已经按升序 <strong>排列</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 83.删除排序链表中的重复元素",
        "hardRate": "EASY",
        "passRate": "53.09%",
        "problemsUrl": "https://leetcode.cn/problems/remove-duplicates-from-sorted-list/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-duplicates-from-sorted-list/solution",
        "problemsDesc": "<p>给定一个已排序的链表的头<meta charset=\"UTF-8\" />&nbsp;<code>head</code>&nbsp;，&nbsp;<em>删除所有重复的元素，使每个元素只出现一次</em>&nbsp;。返回 <em>已排序的链表</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/list1.jpg\" style=\"height: 160px; width: 200px;\" />\n<pre>\n<strong>输入：</strong>head = [1,1,2]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/list2.jpg\" style=\"height: 123px; width: 300px;\" />\n<pre>\n<strong>输入：</strong>head = [1,1,2,3,3]\n<strong>输出：</strong>[1,2,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点数目在范围 <code>[0, 300]</code> 内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li>题目数据保证链表已经按升序 <strong>排列</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 84.柱状图中最大的矩形",
        "hardRate": "HARD",
        "passRate": "45.02%",
        "problemsUrl": "https://leetcode.cn/problems/largest-rectangle-in-histogram/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-rectangle-in-histogram/solution",
        "problemsDesc": "<p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>\n\n<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>heights = [2,1,5,6,2,3]\n<strong>输出：</strong>10\n<strong>解释：</strong>最大的矩形为图中红色区域，面积为 10\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong> heights = [2,4]\n<b>输出：</b> 4</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= heights.length <=10<sup>5</sup></code></li>\n\t<li><code>0 <= heights[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 85.最大矩形",
        "hardRate": "HARD",
        "passRate": "54.69%",
        "problemsUrl": "https://leetcode.cn/problems/maximal-rectangle/",
        "solutionsUrl": "https://leetcode.cn/problems/maximal-rectangle/solution",
        "problemsDesc": "<p>给定一个仅包含&nbsp;<code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg\" style=\"width: 402px; height: 322px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\n<strong>输出：</strong>6\n<strong>解释：</strong>最大矩形如上图所示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = []\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[\"0\"]]\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[\"1\"]]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[\"0\",\"0\"]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rows == matrix.length</code></li>\n\t<li><code>cols == matrix[0].length</code></li>\n\t<li><code>1 &lt;= row, cols &lt;= 200</code></li>\n\t<li><code>matrix[i][j]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 86.分隔链表",
        "hardRate": "MEDIUM",
        "passRate": "64.21%",
        "problemsUrl": "https://leetcode.cn/problems/partition-list/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-list/solution",
        "problemsDesc": "<p>给你一个链表的头节点 <code>head</code> 和一个特定值<em> </em><code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。</p>\n\n<p>你应当 <strong>保留</strong> 两个分区中每个节点的初始相对位置。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/partition.jpg\" style=\"width: 662px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>head = [1,4,3,2,5,2], x = 3\n<strong>输出</strong>：[1,2,2,4,3,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [2,1], x = 2\n<strong>输出</strong>：[1,2]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目在范围 <code>[0, 200]</code> 内</li>\n\t<li><code>-100 <= Node.val <= 100</code></li>\n\t<li><code>-200 <= x <= 200</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 87.扰乱字符串",
        "hardRate": "HARD",
        "passRate": "47.34%",
        "problemsUrl": "https://leetcode.cn/problems/scramble-string/",
        "solutionsUrl": "https://leetcode.cn/problems/scramble-string/solution",
        "problemsDesc": "使用下面描述的算法可以扰乱字符串 <code>s</code> 得到字符串 <code>t</code> ：\n<ol>\n\t<li>如果字符串的长度为 1 ，算法停止</li>\n\t<li>如果字符串的长度 > 1 ，执行下述步骤：\n\t<ul>\n\t\t<li>在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 <code>s</code> ，则可以将其分成两个子字符串 <code>x</code> 和 <code>y</code> ，且满足 <code>s = x + y</code> 。</li>\n\t\t<li><strong>随机</strong> 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，<code>s</code> 可能是 <code>s = x + y</code> 或者 <code>s = y + x</code> 。</li>\n\t\t<li>在 <code>x</code> 和 <code>y</code> 这两个子字符串上继续从步骤 1 开始递归执行此算法。</li>\n\t</ul>\n\t</li>\n</ol>\n\n<p>给你两个 <strong>长度相等</strong> 的字符串 <code>s1</code><em> </em>和 <code>s2</code>，判断 <code>s2</code><em> </em>是否是 <code>s1</code><em> </em>的扰乱字符串。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"great\", s2 = \"rgeat\"\n<strong>输出：</strong>true\n<strong>解释：</strong>s1 上可能发生的一种情形是：\n\"great\" --> \"gr/eat\" // 在一个随机下标处分割得到两个子字符串\n\"gr/eat\" --> \"gr/eat\" // 随机决定：「保持这两个子字符串的顺序不变」\n\"gr/eat\" --> \"g/r / e/at\" // 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割\n\"g/r / e/at\" --> \"r/g / e/at\" // 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // 继续递归执行此算法，将 \"at\" 分割得到 \"a/t\"\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // 随机决定：「保持这两个子字符串的顺序不变」\n算法终止，结果字符串和 s2 相同，都是 \"rgeat\"\n这是一种能够扰乱 s1 得到 s2 的情形，可以认为 s2 是 s1 的扰乱字符串，返回 true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"abcde\", s2 = \"caebd\"\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"a\", s2 = \"a\"\n<strong>输出：</strong>true\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s1.length == s2.length</code></li>\n\t<li><code>1 <= s1.length <= 30</code></li>\n\t<li><code>s1</code> 和 <code>s2</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 88.合并两个有序数组",
        "hardRate": "EASY",
        "passRate": "52.47%",
        "problemsUrl": "https://leetcode.cn/problems/merge-sorted-array/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-sorted-array/solution",
        "problemsDesc": "<p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组&nbsp;<code>nums1</code><em> </em>和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p>\n\n<p>请你 <strong>合并</strong> <code>nums2</code><em> </em>到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p>\n\n<p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n<strong>输出：</strong>[1,2,2,3,5,6]\n<strong>解释：</strong>需要合并 [1,2,3] 和 [2,5,6] 。\n合并结果是 [<em><strong>1</strong></em>,<em><strong>2</strong></em>,2,<em><strong>3</strong></em>,5,6] ，其中斜体加粗标注的为 nums1 中的元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1], m = 1, nums2 = [], n = 0\n<strong>输出：</strong>[1]\n<strong>解释：</strong>需要合并 [1] 和 [] 。\n合并结果是 [1] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [0], m = 0, nums2 = [1], n = 1\n<strong>输出：</strong>[1]\n<strong>解释：</strong>需要合并的数组是 [] 和 [1] 。\n合并结果是 [1] 。\n注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums1.length == m + n</code></li>\n\t<li><code>nums2.length == n</code></li>\n\t<li><code>0 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>1 &lt;= m + n &lt;= 200</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums1[i], nums2[j] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以设计实现一个时间复杂度为 <code>O(m + n)</code> 的算法解决此问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 89.格雷编码",
        "hardRate": "MEDIUM",
        "passRate": "75.53%",
        "problemsUrl": "https://leetcode.cn/problems/gray-code/",
        "solutionsUrl": "https://leetcode.cn/problems/gray-code/solution",
        "problemsDesc": "<strong>n 位格雷码序列</strong> 是一个由 <code>2<sup>n</sup></code> 个整数组成的序列，其中：\n<ul>\n\t<li>每个整数都在范围 <code>[0, 2<sup>n</sup> - 1]</code> 内（含 <code>0</code> 和 <code>2<sup>n</sup> - 1</code>）</li>\n\t<li>第一个整数是 <code>0</code></li>\n\t<li>一个整数在序列中出现 <strong>不超过一次</strong></li>\n\t<li>每对 <strong>相邻</strong> 整数的二进制表示 <strong>恰好一位不同</strong> ，且</li>\n\t<li><strong>第一个</strong> 和 <strong>最后一个</strong> 整数的二进制表示 <strong>恰好一位不同</strong></li>\n</ul>\n\n<p>给你一个整数 <code>n</code> ，返回任一有效的 <strong>n 位格雷码序列</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>[0,1,3,2]\n<strong>解释：</strong>\n[0,1,3,2] 的二进制表示是 [00,01,11,10] 。\n- 0<strong><em>0</em></strong> 和 0<em><strong>1</strong></em> 有一位不同\n- <em><strong>0</strong></em>1 和 <em><strong>1</strong></em>1 有一位不同\n- 1<em><strong>1</strong></em> 和 1<em><strong>0</strong></em> 有一位不同\n- <em><strong>1</strong></em>0 和 <em><strong>0</strong></em>0 有一位不同\n[0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。\n- <em><strong>0</strong></em>0 和 <em><strong>1</strong></em>0 有一位不同\n- 1<em><strong>0</strong></em> 和 1<em><strong>1</strong></em> 有一位不同\n- <em><strong>1</strong></em>1 和 <em><strong>0</strong></em>1 有一位不同\n- 0<em><strong>1</strong></em> 和 0<em><strong>0</strong></em> 有一位不同\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>[0,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 16</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 90.子集 II",
        "hardRate": "MEDIUM",
        "passRate": "63.60%",
        "problemsUrl": "https://leetcode.cn/problems/subsets-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/subsets-ii/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>\n\n<p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2]\n<strong>输出：</strong>[[],[1],[1,2],[1,2,2],[2],[2,2]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>[[],[0]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10</code></li>\n\t<li><code>-10 <= nums[i] <= 10</code></li>\n</ul>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 91.解码方法",
        "hardRate": "MEDIUM",
        "passRate": "33.19%",
        "problemsUrl": "https://leetcode.cn/problems/decode-ways/",
        "solutionsUrl": "https://leetcode.cn/problems/decode-ways/solution",
        "problemsDesc": "<p>一条包含字母&nbsp;<code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p>\n\n<pre>\n'A' -&gt; \"1\"\n'B' -&gt; \"2\"\n...\n'Z' -&gt; \"26\"</pre>\n\n<p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>\"11106\"</code> 可以映射为：</p>\n\n<ul>\n\t<li><code>\"AAJF\"</code> ，将消息分组为 <code>(1 1 10 6)</code></li>\n\t<li><code>\"KJF\"</code> ，将消息分组为 <code>(11 10 6)</code></li>\n</ul>\n\n<p>注意，消息不能分组为&nbsp; <code>(1 11 06)</code> ，因为 <code>\"06\"</code> 不能映射为 <code>\"F\"</code> ，这是由于 <code>\"6\"</code> 和 <code>\"06\"</code> 在映射中并不等价。</p>\n\n<p>给你一个只含数字的 <strong>非空 </strong>字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p>\n\n<p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"12\"\n<strong>输出：</strong>2\n<strong>解释：</strong>它可以解码为 \"AB\"（1 2）或者 \"L\"（12）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"226\"\n<strong>输出：</strong>3\n<strong>解释：</strong>它可以解码为 \"BZ\" (2 26), \"VF\" (22 6), 或者 \"BBF\" (2 2 6) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"06\"\n<strong>输出：</strong>0\n<strong>解释：</strong>\"06\" 无法映射到 \"F\" ，因为存在前导零（\"6\" 和 \"06\" 并不等价）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 只包含数字，并且可能包含前导零。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 92.反转链表 II",
        "hardRate": "MEDIUM",
        "passRate": "55.68%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-linked-list-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-linked-list-ii/solution",
        "problemsDesc": "给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left <= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], left = 2, right = 4\n<strong>输出：</strong>[1,4,3,2,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [5], left = 1, right = 1\n<strong>输出：</strong>[5]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点数目为 <code>n</code></li>\n\t<li><code>1 <= n <= 500</code></li>\n\t<li><code>-500 <= Node.val <= 500</code></li>\n\t<li><code>1 <= left <= right <= n</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong> 你可以使用一趟扫描完成反转吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 93.复原 IP 地址",
        "hardRate": "MEDIUM",
        "passRate": "58.11%",
        "problemsUrl": "https://leetcode.cn/problems/restore-ip-addresses/",
        "solutionsUrl": "https://leetcode.cn/problems/restore-ip-addresses/solution",
        "problemsDesc": "<p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>'.'</code> 分隔。</p>\n\n<ul>\n\t<li>例如：<code>\"0.1.2.201\"</code> 和<code> \"192.168.1.1\"</code> 是 <strong>有效</strong> IP 地址，但是 <code>\"0.011.255.245\"</code>、<code>\"192.168.1.312\"</code> 和 <code>\"192.168@1.1\"</code> 是 <strong>无效</strong> IP 地址。</li>\n</ul>\n\n<p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入&nbsp;<code>'.'</code> 来形成。你 <strong>不能</strong>&nbsp;重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"25525511135\"\n<strong>输出：</strong>[\"255.255.11.135\",\"255.255.111.35\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0000\"\n<strong>输出：</strong>[\"0.0.0.0\"]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"101023\"\n<strong>输出：</strong>[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>s</code> 仅由数字组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 94.二叉树的中序遍历",
        "hardRate": "EASY",
        "passRate": "76.21%",
        "problemsUrl": "https://leetcode.cn/problems/binary-tree-inorder-traversal/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-tree-inorder-traversal/solution",
        "problemsDesc": "<p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong>&nbsp;遍历</em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg\" style=\"height: 200px; width: 125px;\" />\n<pre>\n<strong>输入：</strong>root = [1,null,2,3]\n<strong>输出：</strong>[1,3,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶:</strong>&nbsp;递归算法很简单，你可以通过迭代算法完成吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 95.不同的二叉搜索树 II",
        "hardRate": "MEDIUM",
        "passRate": "73.43%",
        "problemsUrl": "https://leetcode.cn/problems/unique-binary-search-trees-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-binary-search-trees-ii/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong><em> </em>。可以按 <strong>任意顺序</strong> 返回答案。</p>\n\n<p> </p>\n\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg\" style=\"width: 600px; height: 148px;\" />\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>[[1]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 8</code></li>\n</ul>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 96.不同的二叉搜索树",
        "hardRate": "MEDIUM",
        "passRate": "70.87%",
        "problemsUrl": "https://leetcode.cn/problems/unique-binary-search-trees/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-binary-search-trees/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg\" style=\"width: 600px; height: 148px;\" />\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 19</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 97.交错字符串",
        "hardRate": "MEDIUM",
        "passRate": "44.65%",
        "problemsUrl": "https://leetcode.cn/problems/interleaving-string/",
        "solutionsUrl": "https://leetcode.cn/problems/interleaving-string/solution",
        "problemsDesc": "<p>给定三个字符串&nbsp;<code>s1</code>、<code>s2</code>、<code>s3</code>，请你帮忙验证&nbsp;<code>s3</code>&nbsp;是否是由&nbsp;<code>s1</code>&nbsp;和&nbsp;<code>s2</code><em> </em><strong>交错 </strong>组成的。</p>\n\n<p>两个字符串 <code>s</code> 和 <code>t</code> <strong>交错</strong> 的定义与过程如下，其中每个字符串都会被分割成若干 <strong>非空</strong> 子字符串：</p>\n\n<ul>\n\t<li><code>s = s<sub>1</sub> + s<sub>2</sub> + ... + s<sub>n</sub></code></li>\n\t<li><code>t = t<sub>1</sub> + t<sub>2</sub> + ... + t<sub>m</sub></code></li>\n\t<li><code>|n - m| &lt;= 1</code></li>\n\t<li><strong>交错</strong> 是 <code>s<sub>1</sub> + t<sub>1</sub> + s<sub>2</sub> + t<sub>2</sub> + s<sub>3</sub> + t<sub>3</sub> + ...</code> 或者 <code>t<sub>1</sub> + s<sub>1</sub> + t<sub>2</sub> + s<sub>2</sub> + t<sub>3</sub> + s<sub>3</sub> + ...</code></li>\n</ul>\n\n<p><strong>注意：</strong><code>a + b</code> 意味着字符串 <code>a</code> 和 <code>b</code> 连接。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg\" />\n<pre>\n<strong>输入：</strong>s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"\", s2 = \"\", s3 = \"\"\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s1.length, s2.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= s3.length &lt;= 200</code></li>\n\t<li><code>s1</code>、<code>s2</code>、和 <code>s3</code> 都由小写英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>您能否仅使用 <code>O(s2.length)</code> 额外的内存空间来解决它?</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 98.验证二叉搜索树",
        "hardRate": "MEDIUM",
        "passRate": "37.03%",
        "problemsUrl": "https://leetcode.cn/problems/validate-binary-search-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/validate-binary-search-tree/solution",
        "problemsDesc": "<p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>\n\n<p><strong>有效</strong> 二叉搜索树定义如下：</p>\n\n<ul>\n\t<li>节点的左子树只包含<strong> 小于 </strong>当前节点的数。</li>\n\t<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>\n\t<li>所有左子树和右子树自身必须也是二叉搜索树。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg\" style=\"width: 302px; height: 182px;\" />\n<pre>\n<strong>输入：</strong>root = [2,1,3]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg\" style=\"width: 422px; height: 292px;\" />\n<pre>\n<strong>输入：</strong>root = [5,1,4,null,null,3,6]\n<strong>输出：</strong>false\n<strong>解释：</strong>根节点的值是 5 ，但是右子节点的值是 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目范围在<code>[1, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 99.恢复二叉搜索树",
        "hardRate": "MEDIUM",
        "passRate": "60.26%",
        "problemsUrl": "https://leetcode.cn/problems/recover-binary-search-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/recover-binary-search-tree/solution",
        "problemsDesc": "<p>给你二叉搜索树的根节点 <code>root</code> ，该树中的 <strong>恰好</strong> 两个节点的值被错误地交换。<em>请在不改变其结构的情况下，恢复这棵树&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg\" style=\"width: 300px;\" />\n<pre>\n<strong>输入：</strong>root = [1,3,null,null,2]\n<strong>输出：</strong>[3,1,null,null,2]\n<strong>解释：</strong>3 不能是 1 的左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg\" style=\"height: 208px; width: 400px;\" />\n<pre>\n<strong>输入：</strong>root = [3,1,4,null,null,2]\n<strong>输出：</strong>[2,1,4,null,null,3]\n<strong>解释：</strong>2 不能在 3 的右子树中，因为 2 &lt; 3 。交换 2 和 3 使二叉搜索树有效。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树上节点的数目在范围 <code>[2, 1000]</code> 内</li>\n\t<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>使用 <code>O(n)</code> 空间复杂度的解法很容易实现。你能想出一个只使用&nbsp;<code>O(1)</code> 空间的解决方案吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 100.相同的树",
        "hardRate": "EASY",
        "passRate": "60.00%",
        "problemsUrl": "https://leetcode.cn/problems/same-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/same-tree/solution",
        "problemsDesc": "<p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p>\n\n<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg\" style=\"width: 622px; height: 182px;\" />\n<pre>\n<strong>输入：</strong>p = [1,2,3], q = [1,2,3]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg\" style=\"width: 382px; height: 182px;\" />\n<pre>\n<strong>输入：</strong>p = [1,2], q = [1,null,2]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg\" style=\"width: 622px; height: 182px;\" />\n<pre>\n<strong>输入：</strong>p = [1,2,1], q = [1,1,2]\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>两棵树上的节点数目都在范围 <code>[0, 100]</code> 内</li>\n\t<li><code>-10<sup>4</sup> <= Node.val <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    }
]