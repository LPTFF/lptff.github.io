[
    {
        "problemsName": " 2101.引爆最多的炸弹",
        "hardRate": "MEDIUM",
        "passRate": "39.64%",
        "problemsUrl": "https://leetcode.cn/problems/detonate-the-maximum-bombs/",
        "solutionsUrl": "https://leetcode.cn/problems/detonate-the-maximum-bombs/solution",
        "problemsDesc": "<p>给你一个炸弹列表。一个炸弹的 <strong>爆炸范围</strong>&nbsp;定义为以炸弹为圆心的一个圆。</p>\n\n<p>炸弹用一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>bombs</code>&nbsp;表示，其中&nbsp;<code>bombs[i] = [x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub>]</code>&nbsp;。<code>x<sub>i</sub></code> 和&nbsp;<code>y<sub>i</sub></code>&nbsp;表示第 <code>i</code>&nbsp;个炸弹的 X 和 Y 坐标，<code>r<sub>i</sub></code>&nbsp;表示爆炸范围的 <strong>半径</strong>&nbsp;。</p>\n\n<p>你需要选择引爆 <strong>一个&nbsp;</strong>炸弹。当这个炸弹被引爆时，<strong>所有</strong> 在它爆炸范围内的炸弹都会被引爆，这些炸弹会进一步将它们爆炸范围内的其他炸弹引爆。</p>\n\n<p>给你数组&nbsp;<code>bombs</code>&nbsp;，请你返回在引爆&nbsp;<strong>一个</strong>&nbsp;炸弹的前提下，<strong>最多</strong>&nbsp;能引爆的炸弹数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-3.png\" style=\"width: 300px; height: 300px;\"></p>\n\n<pre><b>输入：</b>bombs = [[2,1,3],[6,1,4]]\n<b>输出：</b>2\n<strong>解释：</strong>\n上图展示了 2 个炸弹的位置和爆炸范围。\n如果我们引爆左边的炸弹，右边的炸弹不会被影响。\n但如果我们引爆右边的炸弹，两个炸弹都会爆炸。\n所以最多能引爆的炸弹数目是 max(1, 2) = 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-2.png\" style=\"width: 300px; height: 300px;\"></p>\n\n<pre><b>输入：</b>bombs = [[1,1,5],[10,10,5]]\n<b>输出：</b>1\n<strong>解释：\n</strong>引爆任意一个炸弹都不会引爆另一个炸弹。所以最多能引爆的炸弹数目为 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/07/desmos-eg1.png\" style=\"width: 300px; height: 300px;\"></p>\n\n<pre><b>输入：</b>bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]\n<b>输出：</b>5\n<strong>解释：</strong>\n最佳引爆炸弹为炸弹 0 ，因为：\n- 炸弹 0 引爆炸弹 1 和 2 。红色圆表示炸弹 0 的爆炸范围。\n- 炸弹 2 引爆炸弹 3 。蓝色圆表示炸弹 2 的爆炸范围。\n- 炸弹 3 引爆炸弹 4 。绿色圆表示炸弹 3 的爆炸范围。\n所以总共有 5 个炸弹被引爆。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= bombs.length&nbsp;&lt;= 100</code></li>\n\t<li><code>bombs[i].length == 3</code></li>\n\t<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2102.序列顺序查询",
        "hardRate": "HARD",
        "passRate": "55.69%",
        "problemsUrl": "https://leetcode.cn/problems/sequentially-ordinal-rank-tracker/",
        "solutionsUrl": "https://leetcode.cn/problems/sequentially-ordinal-rank-tracker/solution",
        "problemsDesc": "<p>一个观光景点由它的名字&nbsp;<code>name</code> 和景点评分&nbsp;<code>score</code>&nbsp;组成，其中&nbsp;<code>name</code>&nbsp;是所有观光景点中&nbsp;<strong>唯一</strong>&nbsp;的字符串，<code>score</code>&nbsp;是一个整数。景点按照最好到最坏排序。景点评分 <strong>越高</strong>&nbsp;，这个景点越好。如果有两个景点的评分一样，那么 <strong>字典序较小</strong>&nbsp;的景点更好。</p>\n\n<p>你需要搭建一个系统，查询景点的排名。初始时系统里没有任何景点。这个系统支持：</p>\n\n<ul>\n\t<li><strong>添加</strong> 景点，每次添加 <strong>一个</strong> 景点。</li>\n\t<li><strong>查询 </strong>已经添加景点中第&nbsp;<code>i</code>&nbsp;<strong>好</strong>&nbsp;的景点，其中&nbsp;<code>i</code>&nbsp;是系统目前位置查询的次数（包括当前这一次）。\n\t<ul>\n\t\t<li>比方说，如果系统正在进行第 <code>4</code>&nbsp;次查询，那么需要返回所有已经添加景点中第 <code>4</code>&nbsp;好的。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>注意，测试数据保证&nbsp;<strong>任意查询时刻</strong>&nbsp;，查询次数都 <strong>不超过</strong>&nbsp;系统中景点的数目。</p>\n\n<p>请你实现&nbsp;<code>SORTracker</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>SORTracker()</code>&nbsp;初始化系统。</li>\n\t<li><code>void add(string name, int score)</code>&nbsp;向系统中添加一个名为&nbsp;<code>name</code> 评分为&nbsp;<code>score</code>&nbsp;的景点。</li>\n\t<li><code>string get()</code>&nbsp;查询第 <code>i</code>&nbsp;好的景点，其中 <code>i</code>&nbsp;是目前系统查询的次数（包括当前这次查询）。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"SORTracker\", \"add\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"get\"]\n[[], [\"bradford\", 2], [\"branford\", 3], [], [\"alps\", 2], [], [\"orland\", 2], [], [\"orlando\", 3], [], [\"alpine\", 2], [], []]\n<strong>输出：</strong>\n[null, null, null, \"branford\", null, \"alps\", null, \"bradford\", null, \"bradford\", null, \"bradford\", \"orland\"]\n\n<strong>解释：</strong>\nSORTracker tracker = new SORTracker(); // 初始化系统\ntracker.add(\"bradford\", 2); // 添加 name=\"bradford\" 且 score=2 的景点。\ntracker.add(\"branford\", 3); // 添加 name=\"branford\" 且 score=3 的景点。\ntracker.get();              // 从好带坏的景点为：branford ，bradford 。\n                            // 注意到 branford 比 bradford 好，因为它的 <strong>评分更高</strong> (3 &gt; 2) 。\n                            // 这是第 1 次调用 get() ，所以返回最好的景点：\"branford\" 。\ntracker.add(\"alps\", 2);     // 添加 name=\"alps\" 且 score=2 的景点。\ntracker.get();              // 从好到坏的景点为：branford, alps, bradford 。\n                            // 注意 alps 比 bradford 好，虽然它们评分相同，都为 2 。\n                            // 这是因为 \"alps\" <strong>字典序</strong>&nbsp;比 \"bradford\" 小。\n                            // 返回第 2 好的地点 \"alps\" ，因为当前为第 2 次调用 get() 。\ntracker.add(\"orland\", 2);   // 添加 name=\"orland\" 且 score=2 的景点。\ntracker.get();              // 从好到坏的景点为：branford, alps, bradford, orland 。\n                            // 返回 \"bradford\" ，因为当前为第 3 次调用 get() 。\ntracker.add(\"orlando\", 3);  // 添加 name=\"orlando\" 且 score=3 的景点。\ntracker.get();              // 从好到坏的景点为：branford, orlando, alps, bradford, orland 。\n                            // 返回 \"bradford\".\ntracker.add(\"alpine\", 2);   // 添加 name=\"alpine\" 且 score=2 的景点。\ntracker.get();              // 从好到坏的景点为：branford, orlando, alpine, alps, bradford, orland 。\n                            // 返回 \"bradford\" 。\ntracker.get();              // 从好到坏的景点为：branford, orlando, alpine, alps, bradford, orland 。\n                            // 返回 \"orland\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>name</code>&nbsp;只包含小写英文字母，且每个景点名字互不相同。</li>\n\t<li><code>1 &lt;= name.length &lt;= 10</code></li>\n\t<li><code>1 &lt;= score &lt;= 10<sup>5</sup></code></li>\n\t<li>任意时刻，调用&nbsp;<code>get</code>&nbsp;的次数都不超过调用&nbsp;<code>add</code>&nbsp;的次数。</li>\n\t<li><strong>总共</strong>&nbsp;调用&nbsp;<code>add</code> 和&nbsp;<code>get</code>&nbsp;不超过&nbsp;<code>4 * 10<sup>4</sup></code>&nbsp;</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2103.环和杆",
        "hardRate": "EASY",
        "passRate": "79.62%",
        "problemsUrl": "https://leetcode.cn/problems/rings-and-rods/",
        "solutionsUrl": "https://leetcode.cn/problems/rings-and-rods/solution",
        "problemsDesc": "<p>总计有 <code>n</code> 个环，环的颜色可以是红、绿、蓝中的一种。这些环分布穿在 10 根编号为 <code>0</code> 到 <code>9</code> 的杆上。</p>\n\n<p>给你一个长度为 <code>2n</code> 的字符串 <code>rings</code> ，表示这 <code>n</code> 个环在杆上的分布。<code>rings</code> 中每两个字符形成一个 <strong>颜色位置对</strong> ，用于描述每个环：</p>\n\n<ul>\n\t<li>第 <code>i</code> 对中的 <strong>第一个</strong> 字符表示第 <code>i</code> 个环的 <strong>颜色</strong>（<code>'R'</code>、<code>'G'</code>、<code>'B'</code>）。</li>\n\t<li>第 <code>i</code> 对中的 <strong>第二个</strong> 字符表示第 <code>i</code> 个环的 <strong>位置</strong>，也就是位于哪根杆上（<code>'0'</code> 到 <code>'9'</code>）。</li>\n</ul>\n\n<p>例如，<code>\"R3G2B1\"</code> 表示：共有 <code>n == 3</code> 个环，红色的环在编号为 3 的杆上，绿色的环在编号为 2 的杆上，蓝色的环在编号为 1 的杆上。</p>\n\n<p>找出所有集齐 <strong>全部三种颜色</strong> 环的杆，并返回这种杆的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/23/ex1final.png\" style=\"width: 258px; height: 130px;\">\n<pre><strong>输入：</strong>rings = \"B0B6G0R6R0R6G9\"\n<strong>输出：</strong>1\n<strong>解释：</strong>\n- 编号 0 的杆上有 3 个环，集齐全部颜色：红、绿、蓝。\n- 编号 6 的杆上有 3 个环，但只有红、蓝两种颜色。\n- 编号 9 的杆上只有 1 个绿色环。\n因此，集齐全部三种颜色环的杆的数目为 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/23/ex2final.png\" style=\"width: 266px; height: 130px;\">\n<pre><strong>输入：</strong>rings = \"B0R0G0R9R0B0G0\"\n<strong>输出：</strong>1\n<strong>解释：</strong>\n- 编号 0 的杆上有 6 个环，集齐全部颜色：红、绿、蓝。\n- 编号 9 的杆上只有 1 个红色环。\n因此，集齐全部三种颜色环的杆的数目为 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>rings = \"G4\"\n<strong>输出：</strong>0\n<strong>解释：</strong>\n只给了一个环，因此，不存在集齐全部三种颜色环的杆。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rings.length == 2 * n</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li>如 <code>i</code> 是 <strong>偶数</strong> ，则&nbsp;<code>rings[i]</code> 的值可以取 <code>'R'</code>、<code>'G'</code> 或 <code>'B'</code>（下标从 <strong>0</strong> 开始计数）</li>\n\t<li>如 <code>i</code> 是 <strong>奇数</strong> ，则&nbsp;<code>rings[i]</code> 的值可以取 <code>'0'</code> 到 <code>'9'</code> 中的一个数字（下标从 <strong>0</strong> 开始计数）</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2104.子数组范围和",
        "hardRate": "MEDIUM",
        "passRate": "62.91%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-subarray-ranges/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-subarray-ranges/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。<code>nums</code> 中，子数组的 <strong>范围</strong> 是子数组中最大元素和最小元素的差值。</p>\n\n<p>返回 <code>nums</code> 中 <strong>所有</strong> 子数组范围的 <strong>和</strong> <em>。</em></p>\n\n<p>子数组是数组中一个连续 <strong>非空</strong> 的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>4\n<strong>解释：</strong>nums 的 6 个子数组如下所示：\n[1]，范围 = 最大 - 最小 = 1 - 1 = 0 \n[2]，范围 = 2 - 2 = 0\n[3]，范围 = 3 - 3 = 0\n[1,2]，范围 = 2 - 1 = 1\n[2,3]，范围 = 3 - 2 = 1\n[1,2,3]，范围 = 3 - 1 = 2\n所有范围的和是 0 + 0 + 0 + 1 + 1 + 2 = 4</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,3]\n<strong>输出：</strong>4\n<strong>解释：</strong>nums 的 6 个子数组如下所示：\n[1]，范围 = 最大 - 最小 = 1 - 1 = 0\n[3]，范围 = 3 - 3 = 0\n[3]，范围 = 3 - 3 = 0\n[1,3]，范围 = 3 - 1 = 2\n[3,3]，范围 = 3 - 3 = 0\n[1,3,3]，范围 = 3 - 1 = 2\n所有范围的和是 0 + 0 + 0 + 2 + 0 + 2 = 4\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,-2,-3,4,1]\n<strong>输出：</strong>59\n<strong>解释：</strong>nums 中所有子数组范围的和是 59\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以设计一种时间复杂度为 <code>O(n)</code> 的解决方案吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2105.给植物浇水 II",
        "hardRate": "MEDIUM",
        "passRate": "52.98%",
        "problemsUrl": "https://leetcode.cn/problems/watering-plants-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/watering-plants-ii/solution",
        "problemsDesc": "<p>Alice 和 Bob 打算给花园里的 <code>n</code> 株植物浇水。植物排成一行，从左到右进行标记，编号从 <code>0</code> 到 <code>n - 1</code> 。其中，第 <code>i</code> 株植物的位置是 <code>x = i</code> 。</p>\n\n<p>每一株植物都需要浇特定量的水。Alice 和 Bob 每人有一个水罐，<strong>最初是满的 </strong>。他们按下面描述的方式完成浇水：</p>\n\n<ul>\n\t<li>&nbsp;Alice 按 <strong>从左到右</strong> 的顺序给植物浇水，从植物 <code>0</code> 开始。Bob 按 <strong>从右到左</strong> 的顺序给植物浇水，从植物 <code>n - 1</code> 开始。他们 <strong>同时</strong> 给植物浇水。</li>\n\t<li>如果没有足够的水 <strong>完全</strong> 浇灌下一株植物，他 / 她会立即重新灌满浇水罐。</li>\n\t<li>不管植物需要多少水，浇水所耗费的时间都是一样的。</li>\n\t<li><strong>不能</strong> 提前重新灌满水罐。</li>\n\t<li>每株植物都可以由 Alice 或者 Bob 来浇水。</li>\n\t<li>如果 Alice 和 Bob 到达同一株植物，那么当前水罐中水更多的人会给这株植物浇水。如果他俩水量相同，那么 Alice 会给这株植物浇水。</li>\n</ul>\n\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>plants</code> ，数组由 <code>n</code> 个整数组成。其中，<code>plants[i]</code> 为第 <code>i</code> 株植物需要的水量。另有两个整数 <code>capacityA</code> 和&nbsp;<code>capacityB</code> 分别表示 Alice 和 Bob 水罐的容量。返回两人浇灌所有植物过程中重新灌满水罐的 <strong>次数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>plants = [2,2,3,3], capacityA = 5, capacityB = 5\n<strong>输出：</strong>1\n<strong>解释：</strong>\n- 最初，Alice 和 Bob 的水罐中各有 5 单元水。\n- Alice 给植物 0 浇水，Bob 给植物 3 浇水。\n- Alice 和 Bob 现在分别剩下 3 单元和 2 单元水。\n- Alice 有足够的水给植物 1 ，所以她直接浇水。Bob 的水不够给植物 2 ，所以他先重新装满水，再浇水。\n所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 + 0 + 1 + 0 = 1 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>plants = [2,2,3,3], capacityA = 3, capacityB = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>\n- 最初，Alice 的水罐中有 3 单元水，Bob 的水罐中有 4 单元水。\n- Alice 给植物 0 浇水，Bob 给植物 3 浇水。\n- Alice 和 Bob 现在都只有 1 单元水，并分别需要给植物 1 和植物 2 浇水。\n- 由于他们的水量均不足以浇水，所以他们重新灌满水罐再进行浇水。\n所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 + 1 + 1 + 0 = 2 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>plants = [5], capacityA = 10, capacityB = 8\n<strong>输出：</strong>0\n<strong>解释：</strong>\n- 只有一株植物\n- Alice 的水罐有 10 单元水，Bob 的水罐有 8 单元水。因此 Alice 的水罐中水更多，她会给这株植物浇水。\n所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == plants.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= plants[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>max(plants[i]) &lt;= capacityA, capacityB &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2106.摘水果",
        "hardRate": "HARD",
        "passRate": "45.09%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/solution",
        "problemsDesc": "<p>在一个无限的 x 坐标轴上，有许多水果分布在其中某些位置。给你一个二维整数数组 <code>fruits</code> ，其中 <code>fruits[i] = [position<sub>i</sub>, amount<sub>i</sub>]</code> 表示共有 <code>amount<sub>i</sub></code> 个水果放置在 <code>position<sub>i</sub></code> 上。<code>fruits</code> 已经按 <code>position<sub>i</sub></code> <strong>升序排列</strong> ，每个 <code>position<sub>i</sub></code> <strong>互不相同</strong> 。</p>\n\n<p>另给你两个整数 <code>startPos</code> 和 <code>k</code> 。最初，你位于 <code>startPos</code> 。从任何位置，你可以选择 <strong>向左或者向右</strong> 走。在 x 轴上每移动 <strong>一个单位</strong> ，就记作 <strong>一步</strong> 。你总共可以走 <strong>最多</strong> <code>k</code> 步。你每达到一个位置，都会摘掉全部的水果，水果也将从该位置消失（不会再生）。</p>\n\n<p>返回你可以摘到水果的 <strong>最大总数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/21/1.png\" style=\"width: 472px; height: 115px;\">\n<pre><strong>输入：</strong>fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4\n<strong>输出：</strong>9\n<strong>解释：</strong>\n最佳路线为：\n- 向右移动到位置 6 ，摘到 3 个水果\n- 向右移动到位置 8 ，摘到 6 个水果\n移动 3 步，共摘到 3 + 6 = 9 个水果\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/21/2.png\" style=\"width: 512px; height: 129px;\">\n<pre><strong>输入：</strong>fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4\n<strong>输出：</strong>14\n<strong>解释：</strong>\n可以移动最多 k = 4 步，所以无法到达位置 0 和位置 10 。\n最佳路线为：\n- 在初始位置 5 ，摘到 7 个水果\n- 向左移动到位置 4 ，摘到 1 个水果\n- 向右移动到位置 6 ，摘到 2 个水果\n- 向右移动到位置 7 ，摘到 4 个水果\n移动 1 + 3 = 4 步，共摘到 7 + 1 + 2 + 4 = 14 个水果\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/21/3.png\" style=\"width: 476px; height: 100px;\">\n<pre><strong>输入：</strong>fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2\n<strong>输出：</strong>0\n<strong>解释：</strong>\n最多可以移动 k = 2 步，无法到达任一有水果的地方\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= fruits.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>fruits[i].length == 2</code></li>\n\t<li><code>0 &lt;= startPos, position<sub>i</sub> &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li>对于任意 <code>i &gt; 0</code> ，<code>position<sub>i-1</sub> &lt; position<sub>i</sub></code> 均成立（下标从 <strong>0</strong> 开始计数）</li>\n\t<li><code>1 &lt;= amount<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 2 * 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2107.分享 K 个糖果后独特口味的数量",
        "hardRate": "MEDIUM",
        "passRate": "39.07%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-unique-flavors-after-sharing-k-candies/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-unique-flavors-after-sharing-k-candies/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2108.找出数组中的第一个回文字符串",
        "hardRate": "EASY",
        "passRate": "77.54%",
        "problemsUrl": "https://leetcode.cn/problems/find-first-palindromic-string-in-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-first-palindromic-string-in-the-array/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>words</code> ，找出并返回数组中的 <strong>第一个回文字符串</strong> 。如果不存在满足要求的字符串，返回一个 <strong>空字符串</strong><em> </em><code>\"\"</code> 。</p>\n\n<p><strong>回文字符串</strong> 的定义为：如果一个字符串正着读和反着读一样，那么该字符串就是一个 <strong>回文字符串</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]\n<strong>输出：</strong>\"ada\"\n<strong>解释：</strong>第一个回文字符串是 \"ada\" 。\n注意，\"racecar\" 也是回文字符串，但它不是第一个。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"notapalindrome\",\"racecar\"]\n<strong>输出：</strong>\"racecar\"\n<strong>解释：</strong>第一个也是唯一一个回文字符串是 \"racecar\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"def\",\"ghi\"]\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>不存在回文字符串，所以返回一个空字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><code>words[i]</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2109.向字符串添加空格",
        "hardRate": "MEDIUM",
        "passRate": "61.58%",
        "problemsUrl": "https://leetcode.cn/problems/adding-spaces-to-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/adding-spaces-to-a-string/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，以及一个下标从 <strong>0</strong> 开始的整数数组 <code>spaces</code> 。</p>\n\n<p>数组 <code>spaces</code> 描述原字符串中需要添加空格的下标。每个空格都应该插入到给定索引处的字符值 <strong>之前</strong> 。</p>\n\n<ul>\n\t<li>例如，<code>s = \"EnjoyYourCoffee\"</code> 且 <code>spaces = [5, 9]</code> ，那么我们需要在 <code>'Y'</code> 和 <code>'C'</code> 之前添加空格，这两个字符分别位于下标 <code>5</code> 和下标 <code>9</code> 。因此，最终得到 <code>\"Enjoy <em><strong>Y</strong></em>our <em><strong>C</strong></em>offee\"</code> 。</li>\n</ul>\n\n<p>请你添加空格，并返回修改后的字符串<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"LeetcodeHelpsMeLearn\", spaces = [8,13,15]\n<strong>输出：</strong>\"Leetcode Helps Me Learn\"\n<strong>解释：</strong>\n下标 8、13 和 15 对应 \"Leetcode<em><strong>H</strong></em>elps<em><strong>M</strong></em>e<em><strong>L</strong></em>earn\" 中加粗斜体字符。\n接着在这些字符前添加空格。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"icodeinpython\", spaces = [1,5,7,9]\n<strong>输出：</strong>\"i code in py thon\"\n<strong>解释：</strong>\n下标 1、5、7 和 9 对应 \"i<em><strong>c</strong></em>ode<em><strong>i</strong></em>n<em><strong>p</strong></em>y<em><strong>t</strong></em>hon\" 中加粗斜体字符。\n接着在这些字符前添加空格。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"spacing\", spaces = [0,1,2,3,4,5,6]\n<strong>输出：</strong>\" s p a c i n g\"\n<strong>解释：</strong>\n字符串的第一个字符前可以添加空格。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> 仅由大小写英文字母组成</li>\n\t<li><code>1 &lt;= spaces.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= spaces[i] &lt;= s.length - 1</code></li>\n\t<li><code>spaces</code> 中的所有值 <strong>严格递增</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2110.股票平滑下跌阶段的数目",
        "hardRate": "MEDIUM",
        "passRate": "52.85%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-smooth-descent-periods-of-a-stock/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-smooth-descent-periods-of-a-stock/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>prices</code>&nbsp;，表示一支股票的历史每日股价，其中&nbsp;<code>prices[i]</code>&nbsp;是这支股票第&nbsp;<code>i</code>&nbsp;天的价格。</p>\n\n<p>一个 <strong>平滑下降的阶段</strong>&nbsp;定义为：对于&nbsp;<strong>连续一天或者多天</strong>&nbsp;，每日股价都比 <strong>前一日股价恰好少 </strong><code>1</code>&nbsp;，这个阶段第一天的股价没有限制。</p>\n\n<p>请你返回 <strong>平滑下降阶段</strong>&nbsp;的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>prices = [3,2,1,4]\n<b>输出：</b>7\n<b>解释：</b>总共有 7 个平滑下降阶段：\n[3], [2], [1], [4], [3,2], [2,1] 和 [3,2,1]\n注意，仅一天按照定义也是平滑下降阶段。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>prices = [8,6,7,7]\n<b>输出：</b>4\n<b>解释：</b>总共有 4 个连续平滑下降阶段：[8], [6], [7] 和 [7]\n由于 8 - 6 ≠ 1 ，所以 [8,6] 不是平滑下降阶段。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>prices = [1]\n<b>输出：</b>1\n<b>解释：</b>总共有 1 个平滑下降阶段：[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= prices[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2111.使数组 K 递增的最少操作次数",
        "hardRate": "HARD",
        "passRate": "35.03%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-array-k-increasing/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-array-k-increasing/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始包含 <code>n</code>&nbsp;个正整数的数组&nbsp;<code>arr</code>&nbsp;，和一个正整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>如果对于每个满足&nbsp;<code>k &lt;= i &lt;= n-1</code>&nbsp;的下标&nbsp;<code>i</code>&nbsp;，都有&nbsp;<code>arr[i-k] &lt;= arr[i]</code>&nbsp;，那么我们称&nbsp;<code>arr</code>&nbsp;是 <strong>K</strong>&nbsp;<strong>递增</strong> 的。</p>\n\n<ul>\n\t<li>比方说，<code>arr = [4, 1, 5, 2, 6, 2]</code>&nbsp;对于&nbsp;<code>k = 2</code>&nbsp;是 K 递增的，因为：\n\n\t<ul>\n\t\t<li><code>arr[0] &lt;= arr[2] (4 &lt;= 5)</code></li>\n\t\t<li><code>arr[1] &lt;= arr[3] (1 &lt;= 2)</code></li>\n\t\t<li><code>arr[2] &lt;= arr[4] (5 &lt;= 6)</code></li>\n\t\t<li><code>arr[3] &lt;= arr[5] (2 &lt;= 2)</code></li>\n\t</ul>\n\t</li>\n\t<li>但是，相同的数组&nbsp;<code>arr</code>&nbsp;对于&nbsp;<code>k = 1</code>&nbsp;不是 K 递增的（因为&nbsp;<code>arr[0] &gt; arr[1]</code>），对于&nbsp;<code>k = 3</code>&nbsp;也不是 K 递增的（因为&nbsp;<code>arr[0] &gt; arr[3]</code>&nbsp;）。</li>\n</ul>\n\n<p>每一次 <strong>操作</strong>&nbsp;中，你可以选择一个下标&nbsp;<code>i</code> 并将&nbsp;<code>arr[i]</code> <strong>改成任意&nbsp;</strong>正整数。</p>\n\n<p>请你返回对于给定的 <code>k</code>&nbsp;，使数组变成 K 递增的 <strong>最少操作次数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>arr = [5,4,3,2,1], k = 1\n<b>输出：</b>4\n<strong>解释：\n</strong>对于 k = 1 ，数组最终必须变成非递减的。\n可行的 K 递增结果数组为 [5,<em><strong>6</strong></em>,<em><strong>7</strong></em>,<em><strong>8</strong></em>,<em><strong>9</strong></em>]，[<em><strong>1</strong></em>,<em><strong>1</strong></em>,<em><strong>1</strong></em>,<em><strong>1</strong></em>,1]，[<em><strong>2</strong></em>,<em><strong>2</strong></em>,3,<em><strong>4</strong></em>,<em><strong>4</strong></em>] 。它们都需要 4 次操作。\n次优解是将数组变成比方说 [<em><strong>6</strong></em>,<em><strong>7</strong></em>,<em><strong>8</strong></em>,<em><strong>9</strong></em>,<em><strong>10</strong></em>] ，因为需要 5 次操作。\n显然我们无法使用少于 4 次操作将数组变成 K 递增的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>arr = [4,1,5,2,6,2], k = 2\n<b>输出：</b>0\n<strong>解释：</strong>\n这是题目描述中的例子。\n对于每个满足 2 &lt;= i &lt;= 5 的下标 i ，有 arr[i-2] &lt;=<b> </b>arr[i] 。\n由于给定数组已经是 K 递增的，我们不需要进行任何操作。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [4,1,5,2,6,2], k = 3\n<b>输出：</b>2\n<strong>解释：</strong>\n下标 3 和 5 是仅有的 3 &lt;= i &lt;= 5 且不满足 arr[i-3] &lt;= arr[i] 的下标。\n将数组变成 K 递增的方法之一是将 arr[3] 变为 4 ，且将 arr[5] 变成 5 。\n数组变为 [4,1,5,<em><strong>4</strong></em>,6,<em><strong>5</strong></em>] 。\n可能有其他方法将数组变为 K 递增的，但没有任何一种方法需要的操作次数小于 2 次。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i], k &lt;= arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2112.最繁忙的机场",
        "hardRate": "MEDIUM",
        "passRate": "68.39%",
        "problemsUrl": "https://leetcode.cn/problems/the-airport-with-the-most-traffic/",
        "solutionsUrl": "https://leetcode.cn/problems/the-airport-with-the-most-traffic/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2113.查询删除和添加元素后的数组",
        "hardRate": "MEDIUM",
        "passRate": "61.72%",
        "problemsUrl": "https://leetcode.cn/problems/elements-in-array-after-removing-and-replacing-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/elements-in-array-after-removing-and-replacing-elements/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2114.句子中的最多单词数",
        "hardRate": "EASY",
        "passRate": "84.98%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-words-found-in-sentences/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-words-found-in-sentences/solution",
        "problemsDesc": "<p>一个 <strong>句子</strong>&nbsp;由一些 <strong>单词</strong>&nbsp;以及它们之间的单个空格组成，句子的开头和结尾不会有多余空格。</p>\n\n<p>给你一个字符串数组&nbsp;<code>sentences</code>&nbsp;，其中&nbsp;<code>sentences[i]</code>&nbsp;表示单个 <strong>句子</strong>&nbsp;。</p>\n\n<p>请你返回单个句子里 <strong>单词的最多数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>sentences = [\"alice and bob love leetcode\", \"i think so too\", <em><strong>\"this is great thanks very much\"</strong></em>]\n<b>输出：</b>6\n<b>解释：</b>\n- 第一个句子 \"alice and bob love leetcode\" 总共有 5 个单词。\n- 第二个句子 \"i think so too\" 总共有 4 个单词。\n- 第三个句子 \"this is great thanks very much\" 总共有 6 个单词。\n所以，单个句子中有最多单词数的是第三个句子，总共有 6 个单词。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>sentences = [\"please wait\", <em><strong>\"continue to fight\"</strong></em>, <em><strong>\"continue to win\"</strong></em>]\n<b>输出：</b>3\n<b>解释：</b>可能有多个句子有相同单词数。\n这个例子中，第二个句子和第三个句子（加粗斜体）有相同数目的单词数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentences.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= sentences[i].length &lt;= 100</code></li>\n\t<li><code>sentences[i]</code>&nbsp;只包含小写英文字母和&nbsp;<code>' '</code>&nbsp;。</li>\n\t<li><code>sentences[i]</code>&nbsp;的开头和结尾都没有空格。</li>\n\t<li><code>sentences[i]</code>&nbsp;中所有单词由单个空格隔开。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2115.从给定原材料中找到所有可以做出的菜",
        "hardRate": "MEDIUM",
        "passRate": "42.50%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-possible-recipes-from-given-supplies/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-possible-recipes-from-given-supplies/solution",
        "problemsDesc": "<p>你有 <code>n</code>&nbsp;道不同菜的信息。给你一个字符串数组&nbsp;<code>recipes</code>&nbsp;和一个二维字符串数组&nbsp;<code>ingredients</code>&nbsp;。第&nbsp;<code>i</code>&nbsp;道菜的名字为&nbsp;<code>recipes[i]</code>&nbsp;，如果你有它&nbsp;<strong>所有</strong>&nbsp;的原材料&nbsp;<code>ingredients[i]</code>&nbsp;，那么你可以&nbsp;<strong>做出</strong>&nbsp;这道菜。一道菜的原材料可能是&nbsp;<strong>另一道</strong>&nbsp;菜，也就是说&nbsp;<code>ingredients[i]</code>&nbsp;可能包含&nbsp;<code>recipes</code>&nbsp;中另一个字符串。</p>\n\n<p>同时给你一个字符串数组&nbsp;<code>supplies</code>&nbsp;，它包含你初始时拥有的所有原材料，每一种原材料你都有无限多。</p>\n\n<p>请你返回你可以做出的所有菜。你可以以 <strong>任意顺序</strong>&nbsp;返回它们。</p>\n\n<p>注意两道菜在它们的原材料中可能互相包含。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\n<b>输出：</b>[\"bread\"]\n<strong>解释：</strong>\n我们可以做出 \"bread\" ，因为我们有原材料 \"yeast\" 和 \"flour\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\n<b>输出：</b>[\"bread\",\"sandwich\"]\n<strong>解释：</strong>\n我们可以做出 \"bread\" ，因为我们有原材料 \"yeast\" 和 \"flour\" 。\n我们可以做出 \"sandwich\" ，因为我们有原材料 \"meat\" 且可以做出原材料 \"bread\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\n<b>输出：</b>[\"bread\",\"sandwich\",\"burger\"]\n<strong>解释：</strong>\n我们可以做出 \"bread\" ，因为我们有原材料 \"yeast\" 和 \"flour\" 。\n我们可以做出 \"sandwich\" ，因为我们有原材料 \"meat\" 且可以做出原材料 \"bread\" 。\n我们可以做出 \"burger\" ，因为我们有原材料 \"meat\" 且可以做出原材料 \"bread\" 和 \"sandwich\" 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\"]\n<b>输出：</b>[]\n<strong>解释：</strong>\n我们没法做出任何菜，因为我们只有原材料 \"yeast\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == recipes.length == ingredients.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= ingredients[i].length, supplies.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= recipes[i].length, ingredients[i][j].length, supplies[k].length &lt;= 10</code></li>\n\t<li><code>recipes[i], ingredients[i][j]</code>&nbsp;和&nbsp;<code>supplies[k]</code>&nbsp;只包含小写英文字母。</li>\n\t<li>所有&nbsp;<code>recipes</code> 和&nbsp;<code>supplies</code>&nbsp;中的值互不相同。</li>\n\t<li><code>ingredients[i]</code>&nbsp;中的字符串互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2116.判断一个括号字符串是否有效",
        "hardRate": "MEDIUM",
        "passRate": "32.05%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-a-parentheses-string-can-be-valid/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-a-parentheses-string-can-be-valid/solution",
        "problemsDesc": "<p>一个括号字符串是只由&nbsp;<code>'('</code> 和&nbsp;<code>')'</code>&nbsp;组成的&nbsp;<strong>非空</strong>&nbsp;字符串。如果一个字符串满足下面 <b>任意</b>&nbsp;一个条件，那么它就是有效的：</p>\n\n<ul>\n\t<li>字符串为&nbsp;<code>()</code>.</li>\n\t<li>它可以表示为 <code>AB</code><span style=\"\">（</span><code>A</code>&nbsp;与&nbsp;<code>B</code>&nbsp;连接），其中<code>A</code> 和&nbsp;<code>B</code>&nbsp;都是有效括号字符串。</li>\n\t<li>它可以表示为&nbsp;<code>(A)</code>&nbsp;，其中&nbsp;<code>A</code>&nbsp;是一个有效括号字符串。</li>\n</ul>\n\n<p>给你一个括号字符串&nbsp;<code>s</code>&nbsp;和一个字符串&nbsp;<code>locked</code>&nbsp;，两者长度都为&nbsp;<code>n</code>&nbsp;。<code>locked</code>&nbsp;是一个二进制字符串，只包含&nbsp;<code>'0'</code>&nbsp;和&nbsp;<code>'1'</code>&nbsp;。对于&nbsp;<code>locked</code>&nbsp;中&nbsp;<strong>每一个</strong>&nbsp;下标&nbsp;<code>i</code> ：</p>\n\n<ul>\n\t<li>如果&nbsp;<code>locked[i]</code>&nbsp;是&nbsp;<code>'1'</code>&nbsp;，你 <strong>不能</strong>&nbsp;改变&nbsp;<code>s[i]</code>&nbsp;。</li>\n\t<li>如果&nbsp;<code>locked[i]</code>&nbsp;是&nbsp;<code>'0'</code>&nbsp;，你&nbsp;<strong>可以</strong>&nbsp;将&nbsp;<code>s[i]</code>&nbsp;变为&nbsp;<code>'('</code>&nbsp;或者&nbsp;<code>')'</code>&nbsp;。</li>\n</ul>\n\n<p>如果你可以将 <code>s</code>&nbsp;变为有效括号字符串，请你返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/06/eg1.png\" style=\"width: 311px; height: 101px;\" /></p>\n\n<pre>\n<b>输入：</b>s = \"))()))\", locked = \"010100\"\n<b>输出：</b>true\n<b>解释：</b>locked[1] == '1' 和 locked[3] == '1' ，所以我们无法改变 s[1] 或者 s[3] 。\n我们可以将 s[0] 和 s[4] 变为 '(' ，不改变 s[2] 和 s[5] ，使 s 变为有效字符串。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"()()\", locked = \"0000\"\n<b>输出：</b>true\n<b>解释：</b>我们不需要做任何改变，因为 s 已经是有效字符串了。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \")\", locked = \"0\"\n<b>输出：</b>false\n<b>解释：</b>locked 允许改变 s[0] 。\n但无论将 s[0] 变为 '(' 或者 ')' 都无法使 s 变为有效字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == s.length == locked.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code>&nbsp;要么是&nbsp;<code>'('</code>&nbsp;要么是&nbsp;<code>')'</code>&nbsp;。</li>\n\t<li><code>locked[i]</code> 要么是&nbsp;<code>'0'</code>&nbsp;要么是&nbsp;<code>'1'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2117.一个区间内所有数乘积的缩写",
        "hardRate": "HARD",
        "passRate": "30.74%",
        "problemsUrl": "https://leetcode.cn/problems/abbreviating-the-product-of-a-range/",
        "solutionsUrl": "https://leetcode.cn/problems/abbreviating-the-product-of-a-range/solution",
        "problemsDesc": "<p>给你两个正整数&nbsp;<code>left</code>&nbsp;和&nbsp;<code>right</code>&nbsp;，满足&nbsp;<code>left &lt;= right</code>&nbsp;。请你计算&nbsp;<strong>闭区间</strong>&nbsp;<code>[left, right]</code>&nbsp;中所有整数的&nbsp;<strong>乘积</strong>&nbsp;。</p>\n\n<p>由于乘积可能非常大，你需要将它按照以下步骤 <strong>缩写</strong>&nbsp;：</p>\n\n<ol>\n\t<li>统计乘积中&nbsp;<strong>后缀</strong> 0 的数目，并 <strong>移除</strong> 这些 0 ，将这个数目记为&nbsp;<code>C</code>&nbsp;。\n\n\t<ul>\n\t\t<li>比方说，<code>1000</code>&nbsp;中有 <code>3</code> 个后缀 0&nbsp;，<code>546</code>&nbsp;中没有后缀 0 。</li>\n\t</ul>\n\t</li>\n\t<li>将乘积中剩余数字的位数记为&nbsp;<code>d</code>&nbsp;。如果&nbsp;<code>d &gt; 10</code>&nbsp;，那么将乘积表示为&nbsp;<code>&lt;pre&gt;...&lt;suf&gt;</code>&nbsp;的形式，其中&nbsp;<code>&lt;pre&gt;</code>&nbsp;表示乘积最 <strong>开始</strong>&nbsp;的 <code>5</code>&nbsp;个数位，<code>&lt;suf&gt;</code>&nbsp;表示删除后缀 0 <strong>之后</strong>&nbsp;结尾的 <code>5</code>&nbsp;个数位。如果&nbsp;<code>d &lt;= 10</code>&nbsp;，我们不对它做修改。\n\t<ul>\n\t\t<li>比方说，我们将&nbsp;<code>1234567654321</code>&nbsp;表示为&nbsp;<code>12345...54321</code>&nbsp;，但是&nbsp;<code>1234567</code>&nbsp;仍然表示为&nbsp;<code>1234567</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n\t<li>最后，将乘积表示为 <strong>字符串</strong>&nbsp;<code>\"&lt;pre&gt;...&lt;suf&gt;eC\"</code>&nbsp;。\n\t<ul>\n\t\t<li>比方说，<code>12345678987600000</code>&nbsp;被表示为&nbsp;<code>\"12345...89876e5\"</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n</ol>\n\n<p>请你返回一个字符串，表示 <strong>闭区间</strong>&nbsp;<code>[left, right]</code>&nbsp;中所有整数&nbsp;<strong>乘积</strong>&nbsp;的&nbsp;<strong>缩写</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>left = 1, right = 4\n<b>输出：</b>\"24e0\"\n<strong>解释：</strong>\n乘积为 1 × 2 × 3 × 4 = 24 。\n由于没有后缀 0 ，所以 24 保持不变，缩写的结尾为 \"e0\" 。\n因为乘积的结果是 2 位数，小于 10 ，所欲我们不进一步将它缩写。\n所以，最终将乘积表示为 \"24e0\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>left = 2, right = 11\n<strong>输出：</strong>\"399168e2\"\n<strong>解释：</strong>乘积为 39916800 。\n有 2 个后缀 0 ，删除后得到 399168 。缩写的结尾为 \"e2\" 。 \n删除后缀 0 后是 6 位数，不需要进一步缩写。 \n所以，最终将乘积表示为 \"399168e2\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>left = 371, right = 375\n<strong>输出：</strong>\"7219856259e3\"\n<strong>解释：</strong>乘积为 7219856259000 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= left &lt;= right &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2118.建立方程",
        "hardRate": "HARD",
        "passRate": "54.65%",
        "problemsUrl": "https://leetcode.cn/problems/build-the-equation/",
        "solutionsUrl": "https://leetcode.cn/problems/build-the-equation/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2119.反转两次的数字",
        "hardRate": "EASY",
        "passRate": "73.64%",
        "problemsUrl": "https://leetcode.cn/problems/a-number-after-a-double-reversal/",
        "solutionsUrl": "https://leetcode.cn/problems/a-number-after-a-double-reversal/solution",
        "problemsDesc": "<p><strong>反转</strong> 一个整数意味着倒置它的所有位。</p>\n\n<ul>\n\t<li>例如，反转 <code>2021</code> 得到 <code>1202</code> 。反转 <code>12300</code> 得到 <code>321</code> ，<strong>不保留前导零</strong> 。</li>\n</ul>\n\n<p>给你一个整数 <code>num</code> ，<strong>反转</strong> <code>num</code> 得到 <code>reversed1</code> ，<strong>接着反转</strong> <code>reversed1</code> 得到 <code>reversed2</code> 。如果 <code>reversed2</code> 等于 <code>num</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 526\n<strong>输出：</strong>true\n<strong>解释：</strong>反转 num 得到 625 ，接着反转 625 得到 526 ，等于 num 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 1800\n<strong>输出：</strong>false\n<strong>解释：</strong>反转 num 得到 81 ，接着反转 81 得到 18 ，不等于 num 。 </pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = 0\n<strong>输出：</strong>true\n<strong>解释：</strong>反转 num 得到 0 ，接着反转 0 得到 0 ，等于 num 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2120.执行所有后缀指令",
        "hardRate": "MEDIUM",
        "passRate": "82.50%",
        "problemsUrl": "https://leetcode.cn/problems/execution-of-all-suffix-instructions-staying-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/execution-of-all-suffix-instructions-staying-in-a-grid/solution",
        "problemsDesc": "<p>现有一个 <code>n x n</code> 大小的网格，左上角单元格坐标 <code>(0, 0)</code> ，右下角单元格坐标 <code>(n - 1, n - 1)</code> 。给你整数 <code>n</code> 和一个整数数组 <code>startPos</code> ，其中 <code>startPos = [start<sub>row</sub>, start<sub>col</sub>]</code> 表示机器人最开始在坐标为 <code>(start<sub>row</sub>, start<sub>col</sub>)</code> 的单元格上。</p>\n\n<p>另给你一个长度为 <code>m</code> 、下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，其中 <code>s[i]</code> 是对机器人的第 <code>i</code> 条指令：<code>'L'</code>（向左移动），<code>'R'</code>（向右移动），<code>'U'</code>（向上移动）和 <code>'D'</code>（向下移动）。</p>\n\n<p>机器人可以从 <code>s</code> 中的任一第 <code>i</code> 条指令开始执行。它将会逐条执行指令直到 <code>s</code> 的末尾，但在满足下述条件之一时，机器人将会停止：</p>\n\n<ul>\n\t<li>下一条指令将会导致机器人移动到网格外。</li>\n\t<li>没有指令可以执行。</li>\n</ul>\n\n<p>返回一个长度为 <code>m</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是机器人从第 <code>i</code>&nbsp;条指令 <strong>开始</strong>&nbsp;，可以执行的 <strong>指令数目</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/09/1.png\" style=\"width: 145px; height: 142px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 3, startPos = [0,1], s = \"RRDDLU\"\n<strong>输出：</strong>[1,5,4,3,1,0]\n<strong>解释：</strong>机器人从 startPos 出发，并从第 i 条指令开始执行：\n- 0: \"<em><strong>R</strong></em>RDDLU\" 在移动到网格外之前，只能执行一条 \"R\" 指令。\n- 1:  \"<em><strong>RDDLU</strong></em>\" 可以执行全部五条指令，机器人仍在网格内，最终到达 (0, 0) 。\n- 2:   \"<em><strong>DDLU</strong></em>\" 可以执行全部四条指令，机器人仍在网格内，最终到达 (0, 0) 。\n- 3:    \"<em><strong>DLU</strong></em>\" 可以执行全部三条指令，机器人仍在网格内，最终到达 (0, 0) 。\n- 4:     \"<em><strong>L</strong></em>U\" 在移动到网格外之前，只能执行一条 \"L\" 指令。\n- 5:      \"U\" 如果向上移动，将会移动到网格外。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/09/2.png\" style=\"width: 106px; height: 103px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 2, startPos = [1,1], s = \"LURD\"\n<strong>输出：</strong>[4,1,0,0]\n<strong>解释：</strong>\n- 0: \"<em><strong>LURD</strong></em>\"\n- 1:  \"<em><strong>U</strong></em>RD\"\n- 2:   \"RD\"\n- 3:    \"D\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/09/3.png\" style=\"width: 67px; height: 64px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 1, startPos = [0,0], s = \"LRUD\"\n<strong>输出：</strong>[0,0,0,0]\n<strong>解释：</strong>无论机器人从哪条指令开始执行，都会移动到网格外。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == s.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 500</code></li>\n\t<li><code>startPos.length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>row</sub>, start<sub>col</sub> &lt; n</code></li>\n\t<li><code>s</code> 由 <code>'L'</code>、<code>'R'</code>、<code>'U'</code> 和 <code>'D'</code> 组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2121.相同元素的间隔之和",
        "hardRate": "MEDIUM",
        "passRate": "38.67%",
        "problemsUrl": "https://leetcode.cn/problems/intervals-between-identical-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/intervals-between-identical-elements/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、由 <code>n</code> 个整数组成的数组 <code>arr</code> 。</p>\n\n<p><code>arr</code> 中两个元素的 <strong>间隔</strong> 定义为它们下标之间的 <strong>绝对差</strong> 。更正式地，<code>arr[i]</code> 和 <code>arr[j]</code> 之间的间隔是 <code>|i - j|</code> 。</p>\n\n<p>返回一个长度为 <code>n</code> 的数组&nbsp;<code>intervals</code> ，其中 <code>intervals[i]</code> 是<em> </em><code>arr[i]</code><em> </em>和<em> </em><code>arr</code><em> </em>中每个相同元素（与 <code>arr[i]</code> 的值相同）的 <strong>间隔之和</strong> <em>。</em></p>\n\n<p><strong>注意：</strong><code>|x|</code> 是 <code>x</code> 的绝对值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,1,3,1,2,3,3]\n<strong>输出：</strong>[4,2,7,2,4,4,5]\n<strong>解释：</strong>\n- 下标 0 ：另一个 2 在下标 4 ，|0 - 4| = 4\n- 下标 1 ：另一个 1 在下标 3 ，|1 - 3| = 2\n- 下标 2 ：另两个 3 在下标 5 和 6 ，|2 - 5| + |2 - 6| = 7\n- 下标 3 ：另一个 1 在下标 1 ，|3 - 1| = 2\n- 下标 4 ：另一个 2 在下标 0 ，|4 - 0| = 4\n- 下标 5 ：另两个 3 在下标 2 和 6 ，|5 - 2| + |5 - 6| = 4\n- 下标 6 ：另两个 3 在下标 2 和 5 ，|6 - 2| + |6 - 5| = 5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [10,5,10,10]\n<strong>输出：</strong>[5,0,3,4]\n<strong>解释：</strong>\n- 下标 0 ：另两个 10 在下标 2 和 3 ，|0 - 2| + |0 - 3| = 5\n- 下标 1 ：只有这一个 5 在数组中，所以到相同元素的间隔之和是 0\n- 下标 2 ：另两个 10 在下标 0 和 3 ，|2 - 0| + |2 - 3| = 3\n- 下标 3 ：另两个 10 在下标 0 和 2 ，|3 - 0| + |3 - 2| = 4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == arr.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2122.还原原数组",
        "hardRate": "HARD",
        "passRate": "42.09%",
        "problemsUrl": "https://leetcode.cn/problems/recover-the-original-array/",
        "solutionsUrl": "https://leetcode.cn/problems/recover-the-original-array/solution",
        "problemsDesc": "<p>Alice 有一个下标从 <strong>0</strong> 开始的数组 <code>arr</code> ，由 <code>n</code> 个正整数组成。她会选择一个任意的 <strong>正整数 </strong><code>k</code> 并按下述方式创建两个下标从 <strong>0</strong> 开始的新整数数组 <code>lower</code> 和 <code>higher</code> ：</p>\n\n<ol>\n\t<li>对每个满足 <code>0 &lt;= i &lt; n</code> 的下标 <code>i</code> ，<code>lower[i] = arr[i] - k</code></li>\n\t<li>对每个满足 <code>0 &lt;= i &lt; n</code> 的下标 <code>i</code> ，<code>higher[i] = arr[i] + k</code></li>\n</ol>\n\n<p>不幸地是，Alice 丢失了全部三个数组。但是，她记住了在数组 <code>lower</code> 和 <code>higher</code> 中出现的整数，但不知道每个整数属于哪个数组。请你帮助 Alice 还原原数组。</p>\n\n<p>给你一个由 2n 个整数组成的整数数组 <code>nums</code> ，其中 <strong>恰好</strong> <code>n</code> 个整数出现在 <code>lower</code> ，剩下的出现在 <code>higher</code> ，还原并返回 <strong>原数组</strong> <code>arr</code> 。如果出现答案不唯一的情况，返回 <strong>任一</strong> 有效数组。</p>\n\n<p><strong>注意：</strong>生成的测试用例保证存在 <strong>至少一个</strong> 有效数组 <code>arr</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,10,6,4,8,12]\n<strong>输出：</strong>[3,7,11]\n<strong>解释：</strong>\n如果 arr = [3,7,11] 且 k = 1 ，那么 lower = [2,6,10] 且 higher = [4,8,12] 。\n组合 lower 和 higher 得到 [2,6,10,4,8,12] ，这是 nums 的一个排列。\n另一个有效的数组是 arr = [5,7,9] 且 k = 3 。在这种情况下，lower = [2,4,6] 且 higher = [8,10,12] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,3,3]\n<strong>输出：</strong>[2,2]\n<strong>解释：</strong>\n如果 arr = [2,2] 且 k = 1 ，那么 lower = [1,1] 且 higher = [3,3] 。\n组合 lower 和 higher 得到 [1,1,3,3] ，这是 nums 的一个排列。\n注意，数组不能是 [1,3] ，因为在这种情况下，获得 [1,1,3,3] 唯一可行的方案是 k = 0 。\n这种方案是无效的，k 必须是一个正整数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,435]\n<strong>输出：</strong>[220]\n<strong>解释：</strong>\n唯一可行的组合是 arr = [220] 且 k = 215 。在这种情况下，lower = [5] 且 higher = [435] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 * n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>生成的测试用例保证存在 <strong>至少一个</strong> 有效数组 <code>arr</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2123.使矩阵中的 1 互不相邻的最小操作数",
        "hardRate": "HARD",
        "passRate": "53.76%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-remove-adjacent-ones-in-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-remove-adjacent-ones-in-matrix/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2124.检查是否所有 A 都在 B 之前",
        "hardRate": "EASY",
        "passRate": "69.18%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-all-as-appears-before-all-bs/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-all-as-appears-before-all-bs/solution",
        "problemsDesc": "<p>给你一个 <strong>仅</strong> 由字符 <code>'a'</code> 和 <code>'b'</code> 组成的字符串&nbsp; <code>s</code> 。如果字符串中 <strong>每个</strong> <em> </em><code>'a'</code> 都出现在 <strong>每个</strong><em> </em><code>'b'</code><em> </em>之前，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"aaabbb\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\n'a' 位于下标 0、1 和 2 ；而 'b' 位于下标 3、4 和 5 。\n因此，每个 'a' 都出现在每个 'b' 之前，所以返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abab\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\n存在一个 'a' 位于下标 2 ，而一个 'b' 位于下标 1 。\n因此，不能满足每个 'a' 都出现在每个 'b' 之前，所以返回 false 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = \"bbb\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\n不存在 'a' ，因此可以视作每个 'a' 都出现在每个 'b' 之前，所以返回 true 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s[i]</code> 为 <code>'a'</code> 或 <code>'b'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2125.银行中的激光束数量",
        "hardRate": "MEDIUM",
        "passRate": "83.18%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-laser-beams-in-a-bank/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-laser-beams-in-a-bank/solution",
        "problemsDesc": "<p>银行内部的防盗安全装置已经激活。给你一个下标从 <strong>0</strong> 开始的二进制字符串数组 <code>bank</code> ，表示银行的平面图，这是一个大小为 <code>m x n</code> 的二维矩阵。 <code>bank[i]</code> 表示第 <code>i</code> 行的设备分布，由若干 <code>'0'</code> 和若干 <code>'1'</code> 组成。<code>'0'</code> 表示单元格是空的，而 <code>'1'</code> 表示单元格有一个安全设备。</p>\n\n<p>对任意两个安全设备而言，<strong>如果</strong><strong>同时</strong> 满足下面两个条件，则二者之间存在 <strong>一个</strong> 激光束：</p>\n\n<ul>\n\t<li>两个设备位于两个 <strong>不同行</strong> ：<code>r<sub>1</sub></code> 和 <code>r<sub>2</sub></code> ，其中 <code>r<sub>1</sub> &lt; r<sub>2</sub></code> 。</li>\n\t<li>满足&nbsp;<code>r<sub>1</sub> &lt; i &lt; r<sub>2</sub></code>&nbsp;的 <strong>所有&nbsp;</strong>行&nbsp;<code>i</code>&nbsp;，都&nbsp;<strong>没有安全设备</strong> 。</li>\n</ul>\n\n<p>激光束是独立的，也就是说，一个激光束既不会干扰另一个激光束，也不会与另一个激光束合并成一束。</p>\n\n<p>返回银行中激光束的总数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/24/laser1.jpg\" style=\"width: 400px; height: 368px;\" /></p>\n\n<pre>\n<strong>输入：</strong>bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\n<strong>输出：</strong>8\n<strong>解释：</strong>在下面每组设备对之间，存在一条激光束。总共是 8 条激光束：\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\n注意，第 0 行和第 3 行上的设备之间不存在激光束。\n这是因为第 2 行存在安全设备，这不满足第 2 个条件。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/24/laser2.jpg\" style=\"width: 244px; height: 325px;\" /></p>\n\n<pre>\n<strong>输入：</strong>bank = [\"000\",\"111\",\"000\"]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在两个位于不同行的设备\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == bank.length</code></li>\n\t<li><code>n == bank[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>bank[i][j]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2126.摧毁小行星",
        "hardRate": "MEDIUM",
        "passRate": "48.87%",
        "problemsUrl": "https://leetcode.cn/problems/destroying-asteroids/",
        "solutionsUrl": "https://leetcode.cn/problems/destroying-asteroids/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>mass</code>&nbsp;，它表示一颗行星的初始质量。再给你一个整数数组&nbsp;<code>asteroids</code>&nbsp;，其中&nbsp;<code>asteroids[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;颗小行星的质量。</p>\n\n<p>你可以按 <strong>任意顺序</strong>&nbsp;重新安排小行星的顺序，然后让行星跟它们发生碰撞。如果行星碰撞时的质量 <strong>大于等于</strong>&nbsp;小行星的质量，那么小行星被 <strong>摧毁</strong>&nbsp;，并且行星会 <strong>获得</strong>&nbsp;这颗小行星的质量。否则，行星将被摧毁。</p>\n\n<p>如果所有小行星 <strong>都</strong>&nbsp;能被摧毁，请返回 <code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>mass = 10, asteroids = [3,9,19,5,21]\n<b>输出：</b>true\n<b>解释：</b>一种安排小行星的方式为 [9,19,5,3,21] ：\n- 行星与质量为 9 的小行星碰撞。新的行星质量为：10 + 9 = 19\n- 行星与质量为 19 的小行星碰撞。新的行星质量为：19 + 19 = 38\n- 行星与质量为 5 的小行星碰撞。新的行星质量为：38 + 5 = 43\n- 行星与质量为 3 的小行星碰撞。新的行星质量为：43 + 3 = 46\n- 行星与质量为 21 的小行星碰撞。新的行星质量为：46 + 21 = 67\n所有小行星都被摧毁。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>mass = 5, asteroids = [4,9,23,4]\n<b>输出：</b>false\n<b>解释：</b>\n行星无论如何没法获得足够质量去摧毁质量为 23 的小行星。\n行星把别的小行星摧毁后，质量为 5 + 4 + 9 + 4 = 22 。\n它比 23 小，所以无法摧毁最后一颗小行星。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= mass &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= asteroids.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= asteroids[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2127.参加会议的最多员工数",
        "hardRate": "HARD",
        "passRate": "34.23%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/solution",
        "problemsDesc": "<p>一个公司准备组织一场会议，邀请名单上有&nbsp;<code>n</code>&nbsp;位员工。公司准备了一张 <strong>圆形</strong>&nbsp;的桌子，可以坐下 <strong>任意数目</strong>&nbsp;的员工。</p>\n\n<p>员工编号为 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;。每位员工都有一位 <strong>喜欢</strong>&nbsp;的员工，每位员工&nbsp;<strong>当且仅当</strong>&nbsp;他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工 <strong>不会</strong>&nbsp;是他自己。</p>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>favorite</code>&nbsp;，其中&nbsp;<code>favorite[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;位员工喜欢的员工。请你返回参加会议的&nbsp;<strong>最多员工数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/14/ex1.png\" style=\"width: 236px; height: 195px;\"></p>\n\n<pre><b>输入：</b>favorite = [2,2,1,2]\n<b>输出：</b>3\n<strong>解释：</strong>\n上图展示了公司邀请员工 0，1 和 2 参加会议以及他们在圆桌上的座位。\n没办法邀请所有员工参与会议，因为员工 2 没办法同时坐在 0，1 和 3 员工的旁边。\n注意，公司也可以邀请员工 1，2 和 3 参加会议。\n所以最多参加会议的员工数目为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>favorite = [1,2,0]\n<b>输出：</b>3\n<b>解释：</b>\n每个员工都至少是另一个员工喜欢的员工。所以公司邀请他们所有人参加会议的前提是所有人都参加了会议。\n座位安排同图 1 所示：\n- 员工 0 坐在员工 2 和 1 之间。\n- 员工 1 坐在员工 0 和 2 之间。\n- 员工 2 坐在员工 1 和 0 之间。\n参与会议的最多员工数目为 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/14/ex2.png\" style=\"width: 219px; height: 220px;\"></p>\n\n<pre><b>输入：</b>favorite = [3,0,1,4,1]\n<b>输出：</b>4\n<b>解释：</b>\n上图展示了公司可以邀请员工 0，1，3 和 4 参加会议以及他们在圆桌上的座位。\n员工 2 无法参加，因为他喜欢的员工 0 旁边的座位已经被占领了。\n所以公司只能不邀请员工 2 。\n参加会议的最多员工数目为 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == favorite.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= favorite[i] &lt;=&nbsp;n - 1</code></li>\n\t<li><code>favorite[i] != i</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2128.通过翻转行或列来去除所有的 1",
        "hardRate": "MEDIUM",
        "passRate": "75.63%",
        "problemsUrl": "https://leetcode.cn/problems/remove-all-ones-with-row-and-column-flips/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-all-ones-with-row-and-column-flips/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2129.将标题首字母大写",
        "hardRate": "EASY",
        "passRate": "60.65%",
        "problemsUrl": "https://leetcode.cn/problems/capitalize-the-title/",
        "solutionsUrl": "https://leetcode.cn/problems/capitalize-the-title/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>title</code>&nbsp;，它由单个空格连接一个或多个单词组成，每个单词都只包含英文字母。请你按以下规则将每个单词的首字母 <strong>大写</strong>&nbsp;：</p>\n\n<ul>\n\t<li>如果单词的长度为&nbsp;<code>1</code>&nbsp;或者&nbsp;<code>2</code>&nbsp;，所有字母变成小写。</li>\n\t<li>否则，将单词首字母大写，剩余字母变成小写。</li>\n</ul>\n\n<p>请你返回 <strong>大写后</strong>&nbsp;的<em>&nbsp;</em><code>title</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre><b>输入：</b>title = \"capiTalIze tHe titLe\"\n<b>输出：</b>\"Capitalize The Title\"\n<strong>解释：</strong>\n由于所有单词的长度都至少为 3 ，将每个单词首字母大写，剩余字母变为小写。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>title = \"First leTTeR of EACH Word\"\n<b>输出：</b>\"First Letter of Each Word\"\n<strong>解释：</strong>\n单词 \"of\" 长度为 2 ，所以它保持完全小写。\n其他单词长度都至少为 3 ，所以其他单词首字母大写，剩余字母小写。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>title = \"i lOve leetcode\"\n<b>输出：</b>\"i Love Leetcode\"\n<strong>解释：</strong>\n单词 \"i\" 长度为 1 ，所以它保留小写。\n其他单词长度都至少为 3 ，所以其他单词首字母大写，剩余字母小写。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= title.length &lt;= 100</code></li>\n\t<li><code>title</code>&nbsp;由单个空格隔开的单词组成，且不含有任何前导或后缀空格。</li>\n\t<li>每个单词由大写和小写英文字母组成，且都是 <strong>非空</strong>&nbsp;的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2130.链表最大孪生和",
        "hardRate": "MEDIUM",
        "passRate": "80.05%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-twin-sum-of-a-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-twin-sum-of-a-linked-list/solution",
        "problemsDesc": "<p>在一个大小为&nbsp;<code>n</code>&nbsp;且 <code>n</code>&nbsp;为&nbsp;<strong>偶数</strong> 的链表中，对于&nbsp;<code>0 &lt;= i &lt;= (n / 2) - 1</code>&nbsp;的 <code>i</code>&nbsp;，第&nbsp;<code>i</code>&nbsp;个节点（下标从 <strong>0</strong>&nbsp;开始）的孪生节点为第&nbsp;<code>(n-1-i)</code>&nbsp;个节点 。</p>\n\n<ul>\n\t<li>比方说，<code>n = 4</code>&nbsp;那么节点&nbsp;<code>0</code>&nbsp;是节点 <code>3</code>&nbsp;的孪生节点，节点 <code>1</code>&nbsp;是节点 <code>2</code>&nbsp;的孪生节点。这是长度为 <code><span style=\"\">n = 4</span></code>&nbsp;的链表中所有的孪生节点。</li>\n</ul>\n\n<p><strong>孪生和</strong>&nbsp;定义为一个节点和它孪生节点两者值之和。</p>\n\n<p>给你一个长度为偶数的链表的头节点&nbsp;<code>head</code>&nbsp;，请你返回链表的 <strong>最大孪生和</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/03/eg1drawio.png\" style=\"width: 250px; height: 70px;\"></p>\n\n<pre><b>输入：</b>head = [5,4,2,1]\n<b>输出：</b>6\n<strong>解释：</strong>\n节点 0 和节点 1 分别是节点 3 和 2 的孪生节点。孪生和都为 6 。\n链表中没有其他孪生节点。\n所以，链表的最大孪生和是 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/03/eg2drawio.png\" style=\"width: 250px; height: 70px;\"></p>\n\n<pre><b>输入：</b>head = [4,2,2,3]\n<b>输出：</b>7\n<strong>解释：</strong>\n链表中的孪生节点为：\n- 节点 0 是节点 3 的孪生节点，孪生和为 4 + 3 = 7 。\n- 节点 1 是节点 2 的孪生节点，孪生和为 2 + 2 = 4 。\n所以，最大孪生和为 max(7, 4) = 7 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/03/eg3drawio.png\" style=\"width: 200px; height: 88px;\"></p>\n\n<pre><b>输入：</b>head = [1,100000]\n<b>输出：</b>100001\n<strong>解释：</strong>\n链表中只有一对孪生节点，孪生和为 1 + 100000 = 100001 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表的节点数目是&nbsp;<code>[2, 10<sup>5</sup>]</code>&nbsp;中的&nbsp;<strong>偶数</strong>&nbsp;。</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2131.连接两字母单词得到的最长回文串",
        "hardRate": "MEDIUM",
        "passRate": "42.93%",
        "problemsUrl": "https://leetcode.cn/problems/longest-palindrome-by-concatenating-two-letter-words/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-palindrome-by-concatenating-two-letter-words/solution",
        "problemsDesc": "<p>给你一个字符串数组&nbsp;<code>words</code>&nbsp;。<code>words</code>&nbsp;中每个元素都是一个包含 <strong>两个</strong>&nbsp;小写英文字母的单词。</p>\n\n<p>请你从 <code>words</code>&nbsp;中选择一些元素并按 <b>任意顺序</b>&nbsp;连接它们，并得到一个 <strong>尽可能长的回文串</strong>&nbsp;。每个元素 <strong>至多</strong>&nbsp;只能使用一次。</p>\n\n<p>请你返回你能得到的最长回文串的 <strong>长度</strong>&nbsp;。如果没办法得到任何一个回文串，请你返回 <code>0</code>&nbsp;。</p>\n\n<p><strong>回文串</strong>&nbsp;指的是从前往后和从后往前读一样的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>words = [\"lc\",\"cl\",\"gg\"]\n<b>输出：</b>6\n<b>解释：</b>一个最长的回文串为 \"lc\" + \"gg\" + \"cl\" = \"lcggcl\" ，长度为 6 。\n\"clgglc\" 是另一个可以得到的最长回文串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>words = [\"ab\",\"ty\",\"yt\",\"lc\",\"cl\",\"ab\"]\n<b>输出：</b>8\n<strong>解释：</strong>最长回文串是 \"ty\" + \"lc\" + \"cl\" + \"yt\" = \"tylcclyt\" ，长度为 8 。\n\"lcyttycl\" 是另一个可以得到的最长回文串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>words = [\"cc\",\"ll\",\"xx\"]\n<b>输出：</b>2\n<b>解释：</b>最长回文串是 \"cc\" ，长度为 2 。\n\"ll\" 是另一个可以得到的最长回文串。\"xx\" 也是。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>words[i].length == 2</code></li>\n\t<li><code>words[i]</code>&nbsp;仅包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2132.用邮票贴满网格图",
        "hardRate": "HARD",
        "passRate": "30.83%",
        "problemsUrl": "https://leetcode.cn/problems/stamping-the-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/stamping-the-grid/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的二进制矩阵&nbsp;<code>grid</code>&nbsp;，每个格子要么为&nbsp;<code>0</code>&nbsp;（空）要么为&nbsp;<code>1</code>&nbsp;（被占据）。</p>\n\n<p>给你邮票的尺寸为&nbsp;<code>stampHeight x stampWidth</code>&nbsp;。我们想将邮票贴进二进制矩阵中，且满足以下&nbsp;<strong>限制</strong>&nbsp;和&nbsp;<strong>要求</strong>&nbsp;：</p>\n\n<ol>\n\t<li>覆盖所有 <strong>空</strong>&nbsp;格子。</li>\n\t<li>不覆盖任何 <strong>被占据&nbsp;</strong>的格子。</li>\n\t<li>我们可以放入任意数目的邮票。</li>\n\t<li>邮票可以相互有 <strong>重叠</strong>&nbsp;部分。</li>\n\t<li>邮票不允许 <strong>旋转</strong>&nbsp;。</li>\n\t<li>邮票必须完全在矩阵 <strong>内</strong>&nbsp;。</li>\n</ol>\n\n<p>如果在满足上述要求的前提下，可以放入邮票，请返回&nbsp;<code>true</code>&nbsp;，否则返回<i>&nbsp;</i><code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/03/ex1.png\" style=\"width: 180px; height: 237px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3\n<b>输出：</b>true\n<b>解释：</b>我们放入两个有重叠部分的邮票（图中标号为 1 和 2），它们能覆盖所有与空格子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/03/ex2.png\" style=\"width: 170px; height: 179px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 \n<b>输出：</b>false \n<b>解释：</b>没办法放入邮票覆盖所有的空格子，且邮票不超出网格图以外。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[r].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>grid[r][c]</code> 要么是&nbsp;<code>0</code>&nbsp;，要么是&nbsp;<code>1</code> 。</li>\n\t<li><code>1 &lt;= stampHeight, stampWidth &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2133.检查是否每一行每一列都包含全部整数",
        "hardRate": "EASY",
        "passRate": "55.58%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-every-row-and-column-contains-all-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-every-row-and-column-contains-all-numbers/solution",
        "problemsDesc": "<p>对一个大小为 <code>n x n</code> 的矩阵而言，如果其每一行和每一列都包含从 <code>1</code> 到 <code>n</code> 的 <strong>全部</strong> 整数（含 <code>1</code> 和 <code>n</code>），则认为该矩阵是一个 <strong>有效</strong> 矩阵。</p>\n\n<p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>matrix</code> ，请你判断矩阵是否为一个有效矩阵：如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/21/example1drawio.png\" style=\"width: 250px; height: 251px;\" /></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3],[3,1,2],[2,3,1]]\n<strong>输出：</strong>true\n<strong>解释：</strong>在此例中，n = 3 ，每一行和每一列都包含数字 1、2、3 。\n因此，返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/21/example2drawio.png\" style=\"width: 250px; height: 251px;\" /></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,1,1],[1,2,3],[1,2,3]]\n<strong>输出：</strong>false\n<strong>解释：</strong>在此例中，n = 3 ，但第一行和第一列不包含数字 2 和 3 。\n因此，返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == matrix.length == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= matrix[i][j] &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2134.最少交换次数来组合所有的 1 II",
        "hardRate": "MEDIUM",
        "passRate": "48.84%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together-ii/solution",
        "problemsDesc": "<p><strong>交换</strong> 定义为选中一个数组中的两个 <strong>互不相同</strong> 的位置并交换二者的值。</p>\n\n<p><strong>环形</strong> 数组是一个数组，可以认为 <strong>第一个</strong> 元素和 <strong>最后一个</strong> 元素 <strong>相邻</strong> 。</p>\n\n<p>给你一个 <strong>二进制环形</strong> 数组 <code>nums</code> ，返回在 <strong>任意位置</strong> 将数组中的所有 <code>1</code> 聚集在一起需要的最少交换次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,0,1,1,0,0]\n<strong>输出：</strong>1\n<strong>解释：</strong>这里列出一些能够将所有 1 聚集在一起的方案：\n[0,<strong><em>0</em></strong>,<em><strong>1</strong></em>,1,1,0,0] 交换 1 次。\n[0,1,<em><strong>1</strong></em>,1,<em><strong>0</strong></em>,0,0] 交换 1 次。\n[1,1,0,0,0,0,1] 交换 2 次（利用数组的环形特性）。\n无法在交换 0 次的情况下将数组中的所有 1 聚集在一起。\n因此，需要的最少交换次数为 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,1,1,0,0,1,1,0]\n<strong>输出：</strong>2\n<strong>解释：</strong>这里列出一些能够将所有 1 聚集在一起的方案：\n[1,1,1,0,0,0,0,1,1] 交换 2 次（利用数组的环形特性）。\n[1,1,1,1,1,0,0,0,0] 交换 2 次。\n无法在交换 0 次或 1 次的情况下将数组中的所有 1 聚集在一起。\n因此，需要的最少交换次数为 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,0,0,1]\n<strong>输出：</strong>0\n<strong>解释：</strong>得益于数组的环形特性，所有的 1 已经聚集在一起。\n因此，需要的最少交换次数为 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> 为 <code>0</code> 或者 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2135.统计追加字母可以获得的单词数",
        "hardRate": "MEDIUM",
        "passRate": "36.16%",
        "problemsUrl": "https://leetcode.cn/problems/count-words-obtained-after-adding-a-letter/",
        "solutionsUrl": "https://leetcode.cn/problems/count-words-obtained-after-adding-a-letter/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong> 开始的字符串数组 <code>startWords</code> 和 <code>targetWords</code> 。每个字符串都仅由 <strong>小写英文字母</strong> 组成。</p>\n\n<p>对于 <code>targetWords</code> 中的每个字符串，检查是否能够从 <code>startWords</code> 中选出一个字符串，执行一次 <strong>转换操作</strong>&nbsp;，得到的结果与当前&nbsp;<code>targetWords</code> 字符串相等。</p>\n\n<p><strong>转换操作</strong> 如下面两步所述：</p>\n\n<ol>\n\t<li><strong>追加</strong> 任何 <strong>不存在</strong> 于当前字符串的任一小写字母到当前字符串的末尾。\n\n\t<ul>\n\t\t<li>例如，如果字符串为 <code>\"abc\"</code> ，那么字母 <code>'d'</code>、<code>'e'</code> 或 <code>'y'</code> 都可以加到该字符串末尾，但 <code>'a'</code> 就不行。如果追加的是 <code>'d'</code> ，那么结果字符串为 <code>\"abcd\"</code> 。</li>\n\t</ul>\n\t</li>\n\t<li><strong>重排</strong> 新字符串中的字母，可以按 <strong>任意</strong> 顺序重新排布字母。\n\t<ul>\n\t\t<li>例如，<code>\"abcd\"</code> 可以重排为 <code>\"acbd\"</code>、<code>\"bacd\"</code>、<code>\"cbda\"</code>，以此类推。注意，它也可以重排为 <code>\"abcd\"</code> 自身。</li>\n\t</ul>\n\t</li>\n</ol>\n\n<p>找出 <code>targetWords</code> 中有多少字符串能够由&nbsp;<code>startWords</code> 中的 <strong>任一</strong> 字符串执行上述转换操作获得。返回<em> </em><code>targetWords</code><em> </em>中这类 <strong>字符串的数目</strong> 。</p>\n\n<p><strong>注意：</strong>你仅能验证 <code>targetWords</code> 中的字符串是否可以由 <code>startWords</code> 中的某个字符串经执行操作获得。<code>startWords</code>&nbsp; 中的字符串在这一过程中 <strong>不</strong> 发生实际变更。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>startWords = [\"ant\",\"act\",\"tack\"], targetWords = [\"tack\",\"act\",\"acti\"]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n- 为了形成 targetWords[0] = \"tack\" ，可以选用 startWords[1] = \"act\" ，追加字母 'k' ，并重排 \"actk\" 为 \"tack\" 。\n- startWords 中不存在可以用于获得 targetWords[1] = \"act\" 的字符串。\n  注意 \"act\" 确实存在于 startWords ，但是 <strong>必须</strong> 在重排前给这个字符串追加一个字母。\n- 为了形成 targetWords[2] = \"acti\" ，可以选用 startWords[1] = \"act\" ，追加字母 'i' ，并重排 \"acti\" 为 \"acti\" 自身。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>startWords = [\"ab\",\"a\"], targetWords = [\"abc\",\"abcd\"]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n- 为了形成 targetWords[0] = \"abc\" ，可以选用 startWords[0] = \"ab\" ，追加字母 'c' ，并重排为 \"abc\" 。\n- startWords 中不存在可以用于获得 targetWords[1] = \"abcd\" 的字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= startWords.length, targetWords.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= startWords[i].length, targetWords[j].length &lt;= 26</code></li>\n\t<li><code>startWords</code> 和 <code>targetWords</code> 中的每个字符串都仅由小写英文字母组成</li>\n\t<li>在 <code>startWords</code> 或 <code>targetWords</code> 的任一字符串中，每个字母至多出现一次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2136.全部开花的最早一天",
        "hardRate": "HARD",
        "passRate": "66.04%",
        "problemsUrl": "https://leetcode.cn/problems/earliest-possible-day-of-full-bloom/",
        "solutionsUrl": "https://leetcode.cn/problems/earliest-possible-day-of-full-bloom/solution",
        "problemsDesc": "<p>你有 <code>n</code> 枚花的种子。每枚种子必须先种下，才能开始生长、开花。播种需要时间，种子的生长也是如此。给你两个下标从 <strong>0</strong> 开始的整数数组 <code>plantTime</code> 和 <code>growTime</code> ，每个数组的长度都是 <code>n</code> ：</p>\n\n<ul>\n\t<li><code>plantTime[i]</code> 是 <strong>播种</strong> 第 <code>i</code> 枚种子所需的 <strong>完整天数</strong> 。每天，你只能为播种某一枚种子而劳作。<strong>无须</strong> 连续几天都在种同一枚种子，但是种子播种必须在你工作的天数达到 <code>plantTime[i]</code> 之后才算完成。</li>\n\t<li><code>growTime[i]</code> 是第 <code>i</code> 枚种子完全种下后生长所需的 <strong>完整天数 </strong>。在它生长的最后一天 <strong>之后</strong> ，将会开花并且永远 <strong>绽放</strong> 。</li>\n</ul>\n\n<p>从第 <code>0</code> 开始，你可以按 <strong>任意</strong> 顺序播种种子。</p>\n\n<p>返回所有种子都开花的 <strong>最早</strong> 一天是第几天。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/21/1.png\" style=\"width: 453px; height: 149px;\">\n<pre><strong>输入：</strong>plantTime = [1,4,3], growTime = [2,3,1]\n<strong>输出：</strong>9\n<strong>解释：</strong>灰色的花盆表示播种的日子，彩色的花盆表示生长的日子，花朵表示开花的日子。\n一种最优方案是：\n第 0 天，播种第 0 枚种子，种子生长 2 整天。并在第 3 天开花。\n第 1、2、3、4 天，播种第 1 枚种子。种子生长 3 整天，并在第 8 天开花。\n第 5、6、7 天，播种第 2 枚种子。种子生长 1 整天，并在第 9 天开花。\n因此，在第 9 天，所有种子都开花。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/21/2.png\" style=\"width: 454px; height: 184px;\">\n<pre><strong>输入：</strong>plantTime = [1,2,3,2], growTime = [2,1,2,1]\n<strong>输出：</strong>9\n<strong>解释：</strong>灰色的花盆表示播种的日子，彩色的花盆表示生长的日子，花朵表示开花的日子。 \n一种最优方案是：\n第 1 天，播种第 0 枚种子，种子生长 2 整天。并在第 4 天开花。\n第 0、3 天，播种第 1 枚种子。种子生长 1 整天，并在第 5 天开花。\n第 2、4、5 天，播种第 2 枚种子。种子生长 2 整天，并在第 8 天开花。\n第 6、7 天，播种第 3 枚种子。种子生长 1 整天，并在第 9 天开花。\n因此，在第 9 天，所有种子都开花。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>plantTime = [1], growTime = [1]\n<strong>输出：</strong>2\n<strong>解释：</strong>第 0 天，播种第 0 枚种子。种子需要生长 1 整天，然后在第 2 天开花。\n因此，在第 2 天，所有种子都开花。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == plantTime.length == growTime.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= plantTime[i], growTime[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2137.通过倒水操作让所有的水桶所含水量相等",
        "hardRate": "MEDIUM",
        "passRate": "64.72%",
        "problemsUrl": "https://leetcode.cn/problems/pour-water-between-buckets-to-make-water-levels-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/pour-water-between-buckets-to-make-water-levels-equal/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2138.将字符串拆分为若干长度为 k 的组",
        "hardRate": "EASY",
        "passRate": "66.39%",
        "problemsUrl": "https://leetcode.cn/problems/divide-a-string-into-groups-of-size-k/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-a-string-into-groups-of-size-k/solution",
        "problemsDesc": "<p>字符串 <code>s</code> 可以按下述步骤划分为若干长度为 <code>k</code> 的组：</p>\n\n<ul>\n\t<li>第一组由字符串中的前 <code>k</code> 个字符组成，第二组由接下来的 <code>k</code> 个字符串组成，依此类推。每个字符都能够成为 <strong>某一个</strong> 组的一部分。</li>\n\t<li>对于最后一组，如果字符串剩下的字符 <strong>不足</strong> <code>k</code> 个，需使用字符 <code>fill</code> 来补全这一组字符。</li>\n</ul>\n\n<p>注意，在去除最后一个组的填充字符 <code>fill</code>（如果存在的话）并按顺序连接所有的组后，所得到的字符串应该是 <code>s</code> 。</p>\n\n<p>给你一个字符串 <code>s</code> ，以及每组的长度 <code>k</code> 和一个用于填充的字符 <code>fill</code> ，按上述步骤处理之后，返回一个字符串数组，该数组表示 <code>s</code> 分组后 <strong>每个组的组成情况</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abcdefghi\", k = 3, fill = \"x\"\n<strong>输出：</strong>[\"abc\",\"def\",\"ghi\"]\n<strong>解释：</strong>\n前 3 个字符是 \"abc\" ，形成第一组。\n接下来 3 个字符是 \"def\" ，形成第二组。\n最后 3 个字符是 \"ghi\" ，形成第三组。\n由于所有组都可以由字符串中的字符完全填充，所以不需要使用填充字符。\n因此，形成 3 组，分别是 \"abc\"、\"def\" 和 \"ghi\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abcdefghij\", k = 3, fill = \"x\"\n<strong>输出：</strong>[\"abc\",\"def\",\"ghi\",\"jxx\"]\n<strong>解释：</strong>\n与前一个例子类似，形成前三组 \"abc\"、\"def\" 和 \"ghi\" 。\n对于最后一组，字符串中仅剩下字符 'j' 可以用。为了补全这一组，使用填充字符 'x' 两次。\n因此，形成 4 组，分别是 \"abc\"、\"def\"、\"ghi\" 和 \"jxx\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n\t<li><code>fill</code> 是一个小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2139.得到目标值的最少行动次数",
        "hardRate": "MEDIUM",
        "passRate": "51.53%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-moves-to-reach-target-score/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-moves-to-reach-target-score/solution",
        "problemsDesc": "<p>你正在玩一个整数游戏。从整数 <code>1</code> 开始，期望得到整数 <code>target</code> 。</p>\n\n<p>在一次行动中，你可以做下述两种操作之一：</p>\n\n<ul>\n\t<li><strong>递增</strong>，将当前整数的值加 1（即， <code>x = x + 1</code>）。</li>\n\t<li><strong>加倍</strong>，使当前整数的值翻倍（即，<code>x = 2 * x</code>）。</li>\n</ul>\n\n<p>在整个游戏过程中，你可以使用 <strong>递增</strong> 操作 <strong>任意</strong> 次数。但是只能使用 <strong>加倍</strong> 操作 <strong>至多</strong> <code>maxDoubles</code> 次。</p>\n\n<p>给你两个整数 <code>target</code> 和 <code>maxDoubles</code> ，返回从 1 开始得到<em> </em><code>target</code><em> </em>需要的最少行动次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>target = 5, maxDoubles = 0\n<strong>输出：</strong>4\n<strong>解释：</strong>一直递增 1 直到得到 target 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>target = 19, maxDoubles = 2\n<strong>输出：</strong>7\n<strong>解释：</strong>最初，x = 1 。\n递增 3 次，x = 4 。\n加倍 1 次，x = 8 。\n递增 1 次，x = 9 。\n加倍 1 次，x = 18 。\n递增 1 次，x = 19 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>target = 10, maxDoubles = 4\n<strong>输出：</strong>4\n<strong>解释：</strong>\n最初，x = 1 。 \n递增 1 次，x = 2 。 \n加倍 1 次，x = 4 。 \n递增 1 次，x = 5 。 \n加倍 1 次，x = 10 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= maxDoubles &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2140.解决智力问题",
        "hardRate": "MEDIUM",
        "passRate": "44.05%",
        "problemsUrl": "https://leetcode.cn/problems/solving-questions-with-brainpower/",
        "solutionsUrl": "https://leetcode.cn/problems/solving-questions-with-brainpower/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>questions</code>&nbsp;，其中&nbsp;<code>questions[i] = [points<sub>i</sub>, brainpower<sub>i</sub>]</code>&nbsp;。</p>\n\n<p>这个数组表示一场考试里的一系列题目，你需要 <strong>按顺序</strong>&nbsp;（也就是从问题 <code>0</code><strong>&nbsp;</strong>开始依次解决），针对每个问题选择 <strong>解决</strong>&nbsp;或者 <strong>跳过</strong>&nbsp;操作。解决问题 <code>i</code>&nbsp;将让你 <b>获得</b>&nbsp;&nbsp;<code>points<sub>i</sub></code>&nbsp;的分数，但是你将 <strong>无法</strong>&nbsp;解决接下来的&nbsp;<code>brainpower<sub>i</sub></code>&nbsp;个问题（即只能跳过接下来的 <code>brainpower<sub>i</sub></code><sub>&nbsp;</sub>个问题）。如果你跳过问题&nbsp;<code>i</code>&nbsp;，你可以对下一个问题决定使用哪种操作。</p>\n\n<ul>\n\t<li>比方说，给你&nbsp;<code>questions = [[3, 2], [4, 3], [4, 4], [2, 5]]</code>&nbsp;：\n\n\t<ul>\n\t\t<li>如果问题&nbsp;<code>0</code>&nbsp;被解决了， 那么你可以获得&nbsp;<code>3</code>&nbsp;分，但你不能解决问题&nbsp;<code>1</code> 和&nbsp;<code>2</code>&nbsp;。</li>\n\t\t<li>如果你跳过问题&nbsp;<code>0</code>&nbsp;，且解决问题&nbsp;<code>1</code>&nbsp;，你将获得 <code>4</code> 分但是不能解决问题&nbsp;<code>2</code> 和&nbsp;<code>3</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回这场考试里你能获得的 <strong>最高</strong>&nbsp;分数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>questions = [[3,2],[4,3],[4,4],[2,5]]\n<b>输出：</b>5\n<b>解释：</b>解决问题 0 和 3 得到最高分。\n- 解决问题 0 ：获得 3 分，但接下来 2 个问题都不能解决。\n- 不能解决问题 1 和 2\n- 解决问题 3 ：获得 2 分\n总得分为：3 + 2 = 5 。没有别的办法获得 5 分或者多于 5 分。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]\n<b>输出：</b>7\n<b>解释：</b>解决问题 1 和 4 得到最高分。\n- 跳过问题 0\n- 解决问题 1 ：获得 2 分，但接下来 2 个问题都不能解决。\n- 不能解决问题 2 和 3\n- 解决问题 4 ：获得 5 分\n总得分为：2 + 5 = 7 。没有别的办法获得 7 分或者多于 7 分。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= questions.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>questions[i].length == 2</code></li>\n\t<li><code>1 &lt;= points<sub>i</sub>, brainpower<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2141.同时运行 N 台电脑的最长时间",
        "hardRate": "HARD",
        "passRate": "40.58%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-running-time-of-n-computers/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-running-time-of-n-computers/solution",
        "problemsDesc": "<p>你有&nbsp;<code>n</code>&nbsp;台电脑。给你整数&nbsp;<code>n</code>&nbsp;和一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>batteries</code>&nbsp;，其中第&nbsp;<code>i</code>&nbsp;个电池可以让一台电脑 <strong>运行&nbsp;</strong><code>batteries[i]</code>&nbsp;分钟。你想使用这些电池让&nbsp;<strong>全部</strong>&nbsp;<code>n</code>&nbsp;台电脑 <b>同时</b>&nbsp;运行。</p>\n\n<p>一开始，你可以给每台电脑连接 <strong>至多一个电池</strong>&nbsp;。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 <strong>任意次</strong>&nbsp;。新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。</p>\n\n<p>注意，你不能给电池充电。</p>\n\n<p>请你返回你可以让 <code>n</code>&nbsp;台电脑同时运行的 <strong>最长</strong>&nbsp;分钟数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/01/06/example1-fit.png\" style=\"width: 762px; height: 150px;\"></p>\n\n<pre><b>输入：</b>n = 2, batteries = [3,3,3]\n<b>输出：</b>4\n<b>解释：</b>\n一开始，将第一台电脑与电池 0 连接，第二台电脑与电池 1 连接。\n2 分钟后，将第二台电脑与电池 1 断开连接，并连接电池 2 。注意，电池 0 还可以供电 1 分钟。\n在第 3 分钟结尾，你需要将第一台电脑与电池 0 断开连接，然后连接电池 1 。\n在第 4 分钟结尾，电池 1 也被耗尽，第一台电脑无法继续运行。\n我们最多能同时让两台电脑同时运行 4 分钟，所以我们返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/01/06/example2.png\" style=\"width: 629px; height: 150px;\"></p>\n\n<pre><b>输入：</b>n = 2, batteries = [1,1,1,1]\n<b>输出：</b>2\n<b>解释：</b>\n一开始，将第一台电脑与电池 0 连接，第二台电脑与电池 2 连接。\n一分钟后，电池 0 和电池 2 同时耗尽，所以你需要将它们断开连接，并将电池 1 和第一台电脑连接，电池 3 和第二台电脑连接。\n1 分钟后，电池 1 和电池 3 也耗尽了，所以两台电脑都无法继续运行。\n我们最多能让两台电脑同时运行 2 分钟，所以我们返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= batteries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= batteries[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2142.每辆车的乘客人数 I",
        "hardRate": "MEDIUM",
        "passRate": "46.57%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-passengers-in-each-bus-i/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-passengers-in-each-bus-i/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2143.在两个数组的区间中选取数字",
        "hardRate": "HARD",
        "passRate": "55.30%",
        "problemsUrl": "https://leetcode.cn/problems/choose-numbers-from-two-arrays-in-range/",
        "solutionsUrl": "https://leetcode.cn/problems/choose-numbers-from-two-arrays-in-range/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2144.打折购买糖果的最小开销",
        "hardRate": "EASY",
        "passRate": "66.91%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-of-buying-candies-with-discount/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-of-buying-candies-with-discount/solution",
        "problemsDesc": "<p>一家商店正在打折销售糖果。每购买 <strong>两个</strong>&nbsp;糖果，商店会 <strong>免费</strong>&nbsp;送一个糖果。</p>\n\n<p>免费送的糖果唯一的限制是：它的价格需要小于等于购买的两个糖果价格的 <strong>较小值</strong>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，总共有 <code>4</code>&nbsp;个糖果，价格分别为&nbsp;<code>1</code>&nbsp;，<code>2</code>&nbsp;，<code>3</code>&nbsp;和&nbsp;<code>4</code>&nbsp;，一位顾客买了价格为&nbsp;<code>2</code> 和&nbsp;<code>3</code>&nbsp;的糖果，那么他可以免费获得价格为 <code>1</code>&nbsp;的糖果，但不能获得价格为&nbsp;<code>4</code>&nbsp;的糖果。</li>\n</ul>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>cost</code>&nbsp;，其中&nbsp;<code>cost[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个糖果的价格，请你返回获得 <strong>所有</strong>&nbsp;糖果的 <strong>最小</strong>&nbsp;总开销。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>cost = [1,2,3]\n<b>输出：</b>5\n<b>解释：</b>我们购买价格为 2 和 3 的糖果，然后免费获得价格为 1 的糖果。\n总开销为 2 + 3 = 5 。这是开销最小的 <strong>唯一</strong>&nbsp;方案。\n注意，我们不能购买价格为 1 和 3 的糖果，并免费获得价格为 2 的糖果。\n这是因为免费糖果的价格必须小于等于购买的 2 个糖果价格的较小值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>cost = [6,5,7,9,2,2]\n<b>输出：</b>23\n<b>解释：</b>最小总开销购买糖果方案为：\n- 购买价格为 9 和 7 的糖果\n- 免费获得价格为 6 的糖果\n- 购买价格为 5 和 2 的糖果\n- 免费获得价格为 2 的最后一个糖果\n因此，最小总开销为 9 + 7 + 5 + 2 = 23 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>cost = [5,5]\n<b>输出：</b>10\n<b>解释：</b>由于只有 2 个糖果，我们需要将它们都购买，而且没有免费糖果。\n所以总最小开销为 5 + 5 = 10 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= cost.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= cost[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2145.统计隐藏数组数目",
        "hardRate": "MEDIUM",
        "passRate": "35.88%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-hidden-sequences/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-hidden-sequences/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始且长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>differences</code>&nbsp;，它表示一个长度为&nbsp;<code>n + 1</code>&nbsp;的&nbsp;<strong>隐藏</strong>&nbsp;数组&nbsp;<strong>相邻</strong>&nbsp;元素之间的&nbsp;<strong>差值</strong>&nbsp;。更正式的表述为：我们将隐藏数组记作&nbsp;<code>hidden</code>&nbsp;，那么&nbsp;<code>differences[i] = hidden[i + 1] - hidden[i]</code>&nbsp;。</p>\n\n<p>同时给你两个整数&nbsp;<code>lower</code> 和&nbsp;<code>upper</code>&nbsp;，它们表示隐藏数组中所有数字的值都在 <strong>闭</strong>&nbsp;区间&nbsp;<code>[lower, upper]</code>&nbsp;之间。</p>\n\n<ul>\n\t<li>比方说，<code>differences = [1, -3, 4]</code>&nbsp;，<code>lower = 1</code>&nbsp;，<code>upper = 6</code>&nbsp;，那么隐藏数组是一个长度为 <code>4</code>&nbsp;且所有值都在&nbsp;<code>1</code>&nbsp;和&nbsp;<code>6</code>&nbsp;（包含两者）之间的数组。\n\n\t<ul>\n\t\t<li><code>[3, 4, 1, 5]</code> 和&nbsp;<code>[4, 5, 2, 6]</code>&nbsp;都是符合要求的隐藏数组。</li>\n\t\t<li><code>[5, 6, 3, 7]</code>&nbsp;不符合要求，因为它包含大于 <code>6</code>&nbsp;的元素。</li>\n\t\t<li><code>[1, 2, 3, 4]</code>&nbsp;不符合要求，因为相邻元素的差值不符合给定数据。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回 <strong>符合</strong>&nbsp;要求的隐藏数组的数目。如果没有符合要求的隐藏数组，请返回 <code>0</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>differences = [1,-3,4], lower = 1, upper = 6\n<b>输出：</b>2\n<b>解释：</b>符合要求的隐藏数组为：\n- [3, 4, 1, 5]\n- [4, 5, 2, 6]\n所以返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>differences = [3,-4,5,1,-2], lower = -4, upper = 5\n<b>输出：</b>4\n<b>解释：</b>符合要求的隐藏数组为：\n- [-3, 0, -4, 1, 2, 0]\n- [-2, 1, -3, 2, 3, 1]\n- [-1, 2, -2, 3, 4, 2]\n- [0, 3, -1, 4, 5, 3]\n所以返回 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>differences = [4,-7,2], lower = 3, upper = 6\n<b>输出：</b>0\n<b>解释：</b>没有符合要求的隐藏数组，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == differences.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= differences[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= lower &lt;= upper &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2146.价格范围内最高排名的 K 样物品",
        "hardRate": "MEDIUM",
        "passRate": "40.19%",
        "problemsUrl": "https://leetcode.cn/problems/k-highest-ranked-items-within-a-price-range/",
        "solutionsUrl": "https://leetcode.cn/problems/k-highest-ranked-items-within-a-price-range/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>grid</code>&nbsp;，它的大小为&nbsp;<code>m x n</code>&nbsp;，表示一个商店中物品的分布图。数组中的整数含义为：</p>\n\n<ul>\n\t<li><code>0</code>&nbsp;表示无法穿越的一堵墙。</li>\n\t<li><code>1</code>&nbsp;表示可以自由通过的一个空格子。</li>\n\t<li>所有其他正整数表示该格子内的一样物品的价格。你可以自由经过这些格子。</li>\n</ul>\n\n<p>从一个格子走到上下左右相邻格子花费&nbsp;<code>1</code>&nbsp;步。</p>\n\n<p>同时给你一个整数数组&nbsp;<code>pricing</code> 和&nbsp;<code>start</code>&nbsp;，其中&nbsp;<code>pricing = [low, high]</code> 且&nbsp;<code>start = [row, col]</code>&nbsp;，表示你开始位置为&nbsp;<code>(row, col)</code>&nbsp;，同时你只对物品价格在<strong>&nbsp;闭区间</strong>&nbsp;<code>[low, high]</code>&nbsp;之内的物品感兴趣。同时给你一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>你想知道给定范围 <strong>内</strong>&nbsp;且 <strong>排名最高</strong>&nbsp;的 <code>k</code>&nbsp;件物品的 <strong>位置</strong>&nbsp;。排名按照优先级从高到低的以下规则制定：</p>\n\n<ol>\n\t<li>距离：定义为从&nbsp;<code>start</code>&nbsp;到一件物品的最短路径需要的步数（<strong>较近</strong>&nbsp;距离的排名更高）。</li>\n\t<li>价格：<strong>较低</strong>&nbsp;价格的物品有更高优先级，但只考虑在给定范围之内的价格。</li>\n\t<li>行坐标：<strong>较小</strong>&nbsp;行坐标的有更高优先级。</li>\n\t<li>列坐标：<strong>较小</strong>&nbsp;列坐标的有更高优先级。</li>\n</ol>\n\n<p>请你返回给定价格内排名最高的 <code>k</code>&nbsp;件物品的坐标，将它们按照排名排序后返回。如果给定价格内少于 <code>k</code>&nbsp;件物品，那么请将它们的坐标&nbsp;<strong>全部</strong>&nbsp;返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/16/example1drawio.png\" style=\"width: 200px; height: 151px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,2,0,1],[1,3,0,1],[0,2,5,1]], pricing = [2,5], start = [0,0], k = 3\n<b>输出：</b>[[0,1],[1,1],[2,1]]\n<b>解释：</b>起点为 (0,0) 。\n价格范围为 [2,5] ，我们可以选择的物品坐标为 (0,1)，(1,1)，(2,1) 和 (2,2) 。\n这些物品的排名为：\n- (0,1) 距离为 1\n- (1,1) 距离为 2\n- (2,1) 距离为 3\n- (2,2) 距离为 4\n所以，给定价格范围内排名最高的 3 件物品的坐标为 (0,1)，(1,1) 和 (2,1) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/16/example2drawio1.png\" style=\"width: 200px; height: 151px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,2,0,1],[1,3,3,1],[0,2,5,1]], pricing = [2,3], start = [2,3], k = 2\n<b>输出：</b>[[2,1],[1,2]]\n<b>解释：</b>起点为 (2,3) 。\n价格范围为 [2,3] ，我们可以选择的物品坐标为 (0,1)，(1,1)，(1,2) 和 (2,1) 。\n这些物品的排名为： \n- (2,1) 距离为 2 ，价格为 2\n- (1,2) 距离为 2 ，价格为 3\n- (1,1) 距离为 3\n- (0,1) 距离为 4\n所以，给定价格范围内排名最高的 2 件物品的坐标为 (2,1) 和 (1,2) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/30/example3.png\" style=\"width: 149px; height: 150px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,1,1],[0,0,1],[2,3,4]], pricing = [2,3], start = [0,0], k = 3\n<b>输出：</b>[[2,1],[2,0]]\n<b>解释：</b>起点为 (0,0) 。\n价格范围为 [2,3] ，我们可以选择的物品坐标为 (2,0) 和 (2,1) 。\n这些物品的排名为：\n- (2,1) 距离为 5\n- (2,0) 距离为 6\n所以，给定价格范围内排名最高的 2 件物品的坐标为 (2,1) 和 (2,0) 。\n注意，k = 3 但给定价格范围内只有 2 件物品。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pricing.length == 2</code></li>\n\t<li><code>2 &lt;= low &lt;= high &lt;= 10<sup>5</sup></code></li>\n\t<li><code>start.length == 2</code></li>\n\t<li><code>0 &lt;= row &lt;= m - 1</code></li>\n\t<li><code>0 &lt;= col &lt;= n - 1</code></li>\n\t<li><code>grid[row][col] &gt; 0</code></li>\n\t<li><code>1 &lt;= k &lt;= m * n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2147.分隔长廊的方案数",
        "hardRate": "HARD",
        "passRate": "41.47%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-divide-a-long-corridor/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-divide-a-long-corridor/solution",
        "problemsDesc": "<p>在一个图书馆的长廊里，有一些座位和装饰植物排成一列。给你一个下标从 <strong>0</strong>&nbsp;开始，长度为 <code>n</code>&nbsp;的字符串&nbsp;<code>corridor</code>&nbsp;，它包含字母&nbsp;<code>'S'</code> 和&nbsp;<code>'P'</code>&nbsp;，其中每个&nbsp;<code>'S'</code>&nbsp;表示一个座位，每个&nbsp;<code>'P'</code>&nbsp;表示一株植物。</p>\n\n<p>在下标 <code>0</code>&nbsp;的左边和下标 <code>n - 1</code>&nbsp;的右边 <strong>已经</strong>&nbsp;分别各放了一个屏风。你还需要额外放置一些屏风。每一个位置&nbsp;<code>i - 1</code> 和&nbsp;<code>i</code>&nbsp;之间（<code>1 &lt;= i &lt;= n - 1</code>），至多能放一个屏风。</p>\n\n<p>请你将走廊用屏风划分为若干段，且每一段内都 <strong>恰好有两个座位</strong>&nbsp;，而每一段内植物的数目没有要求。可能有多种划分方案，如果两个方案中有任何一个屏风的位置不同，那么它们被视为 <strong>不同</strong> 方案。</p>\n\n<p>请你返回划分走廊的方案数。由于答案可能很大，请你返回它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;的结果。如果没有任何方案，请返回&nbsp;<code>0</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/04/1.png\" style=\"width: 410px; height: 199px;\"></p>\n\n<pre><b>输入：</b>corridor = \"SSPPSPS\"\n<b>输出：</b>3\n<b>解释：</b>总共有 3 种不同分隔走廊的方案。\n上图中黑色的竖线表示已经放置好的屏风。\n上图每种方案中，每一段都恰好有 <strong>两个</strong>&nbsp;座位。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/04/2.png\" style=\"width: 357px; height: 68px;\"></p>\n\n<pre><b>输入：</b>corridor = \"PPSPSP\"\n<b>输出：</b>1\n<b>解释：</b>只有 1 种分隔走廊的方案，就是不放置任何屏风。\n放置任何的屏风都会导致有一段无法恰好有 2 个座位。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/12/3.png\" style=\"width: 115px; height: 68px;\"></p>\n\n<pre><b>输入：</b>corridor = \"S\"\n<b>输出：</b>0\n<b>解释：</b>没有任何方案，因为总是有一段无法恰好有 2 个座位。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == corridor.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>corridor[i]</code>&nbsp;要么是&nbsp;<code>'S'</code>&nbsp;，要么是&nbsp;<code>'P'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2148.元素计数",
        "hardRate": "EASY",
        "passRate": "57.73%",
        "problemsUrl": "https://leetcode.cn/problems/count-elements-with-strictly-smaller-and-greater-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/count-elements-with-strictly-smaller-and-greater-elements/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，统计并返回在 <code>nums</code> 中同时至少具有一个严格较小元素和一个严格较大元素的元素数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [11,7,2,15]\n<strong>输出：</strong>2\n<strong>解释：</strong>元素 7 ：严格较小元素是元素 2 ，严格较大元素是元素 11 。\n元素 11 ：严格较小元素是元素 7 ，严格较大元素是元素 15 。\n总计有 2 个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-3,3,3,90]\n<strong>输出：</strong>2\n<strong>解释：</strong>元素 3 ：严格较小元素是元素 -3 ，严格较大元素是元素 90 。\n由于有两个元素的值为 3 ，总计有 2 个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2149.按符号重排数组",
        "hardRate": "MEDIUM",
        "passRate": "79.75%",
        "problemsUrl": "https://leetcode.cn/problems/rearrange-array-elements-by-sign/",
        "solutionsUrl": "https://leetcode.cn/problems/rearrange-array-elements-by-sign/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，数组长度为 <strong>偶数</strong> ，由数目相等的正整数和负整数组成。</p>\n\n<p>你需要 <strong>重排</strong> <code>nums</code> 中的元素，使修改后的数组满足下述条件：</p>\n\n<ol>\n\t<li>任意&nbsp;<strong>连续</strong> 的两个整数 <strong>符号相反</strong></li>\n\t<li>对于符号相同的所有整数，<strong>保留</strong> 它们在 <code>nums</code> 中的 <strong>顺序</strong> 。</li>\n\t<li>重排后数组以正整数开头。</li>\n</ol>\n\n<p>重排元素满足上述条件后，返回修改后的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,1,-2,-5,2,-4]\n<strong>输出：</strong>[3,-2,1,-5,2,-4]\n<strong>解释：</strong>\nnums 中的正整数是 [3,1,2] ，负整数是 [-2,-5,-4] 。\n重排的唯一可行方案是 [3,-2,1,-5,2,-4]，能满足所有条件。\n像 [1,-2,2,-5,3,-4]、[3,1,2,-2,-5,-4]、[-2,3,-5,1,-4,2] 这样的其他方案是不正确的，因为不满足一个或者多个条件。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,1]\n<strong>输出：</strong>[1,-1]\n<strong>解释：</strong>\n1 是 nums 中唯一一个正整数，-1 是 nums 中唯一一个负整数。\n所以 nums 重排为 [1,-1] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>nums.length</code> 是 <strong>偶数</strong></li>\n\t<li><code>1 &lt;= |nums[i]| &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums</code> 由 <strong>相等</strong> 数量的正整数和负整数组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2150.找出数组中的所有孤独数字",
        "hardRate": "MEDIUM",
        "passRate": "59.49%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-lonely-numbers-in-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-lonely-numbers-in-the-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。如果数字 <code>x</code> 在数组中仅出现 <strong>一次</strong> ，且没有 <strong>相邻</strong> 数字（即，<code>x + 1</code> 和 <code>x - 1</code>）出现在数组中，则认为数字 <code>x</code> 是 <strong>孤独数字</strong> 。</p>\n\n<p>返回<em> </em><code>nums</code> 中的 <strong>所有</strong> 孤独数字。你可以按 <strong>任何顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [10,6,5,8]\n<strong>输出：</strong>[10,8]\n<strong>解释：</strong>\n- 10 是一个孤独数字，因为它只出现一次，并且 9 和 11 没有在 nums 中出现。\n- 8 是一个孤独数字，因为它只出现一次，并且 7 和 9 没有在 nums 中出现。\n- 5 不是一个孤独数字，因为 6 出现在 nums 中，反之亦然。\n因此，nums 中的孤独数字是 [10, 8] 。\n注意，也可以返回 [8, 10] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3,5,3]\n<strong>输出：</strong>[1,5]\n<strong>解释：</strong>\n- 1 是一个孤独数字，因为它只出现一次，并且 0 和 2 没有在 nums 中出现。\n- 5 是一个孤独数字，因为它只出现一次，并且 4 和 6 没有在 nums 中出现。\n- 3 不是一个孤独数字，因为它出现两次。\n因此，nums 中的孤独数字是 [1, 5] 。\n注意，也可以返回 [5, 1] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    }
]