[
    {
        "problemsName": " 2051.商店中每个成员的级别",
        "hardRate": "MEDIUM",
        "passRate": "65.17%",
        "problemsUrl": "https://leetcode.cn/problems/the-category-of-each-member-in-the-store/",
        "solutionsUrl": "https://leetcode.cn/problems/the-category-of-each-member-in-the-store/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2052.将句子分隔成行的最低成本",
        "hardRate": "MEDIUM",
        "passRate": "48.41%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-separate-sentence-into-rows/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-separate-sentence-into-rows/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2053.数组中第 K 个独一无二的字符串",
        "hardRate": "EASY",
        "passRate": "71.13%",
        "problemsUrl": "https://leetcode.cn/problems/kth-distinct-string-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-distinct-string-in-an-array/solution",
        "problemsDesc": "<p><strong>独一无二的字符串</strong>&nbsp;指的是在一个数组中只出现过 <strong>一次</strong>&nbsp;的字符串。</p>\n\n<p>给你一个字符串数组&nbsp;<code>arr</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;，请你返回&nbsp;<code>arr</code>&nbsp;中第&nbsp;<code>k</code>&nbsp;个&nbsp;<strong>独一无二的字符串</strong>&nbsp;。如果&nbsp;<strong>少于</strong>&nbsp;<code>k</code>&nbsp;个独一无二的字符串，那么返回&nbsp;<strong>空字符串</strong>&nbsp;<code>\"\"</code>&nbsp;。</p>\n\n<p>注意，按照字符串在原数组中的 <strong>顺序</strong>&nbsp;找到第 <code>k</code>&nbsp;个独一无二字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><b>输入：</b>arr = [\"d\",\"b\",\"c\",\"b\",\"c\",\"a\"], k = 2\n<b>输出：</b>\"a\"\n<strong>解释：</strong>\narr 中独一无二字符串包括 \"d\" 和 \"a\"<code>&nbsp;。</code>\n\"d\" 首先出现，所以它是第 1 个独一无二字符串。\n\"a\" 第二个出现，所以它是 2 个独一无二字符串。\n由于 k == 2 ，返回 \"a\" 。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><b>输入：</b>arr = [\"aaa\",\"aa\",\"a\"], k = 1\n<b>输出：</b>\"aaa\"\n<strong>解释：</strong>\narr 中所有字符串都是独一无二的，所以返回第 1 个字符串 \"aaa\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>arr = [\"a\",\"b\",\"a\"], k = 3\n<b>输出：</b>\"\"\n<strong>解释：</strong>\n唯一一个独一无二字符串是 \"b\" 。由于少于 3 个独一无二字符串，我们返回空字符串 \"\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= arr[i].length &lt;= 5</code></li>\n\t<li><code>arr[i]</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2054.两个最好的不重叠活动",
        "hardRate": "MEDIUM",
        "passRate": "38.33%",
        "problemsUrl": "https://leetcode.cn/problems/two-best-non-overlapping-events/",
        "solutionsUrl": "https://leetcode.cn/problems/two-best-non-overlapping-events/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>events</code>&nbsp;，其中&nbsp;<code>events[i] = [startTime<sub>i</sub>, endTime<sub>i</sub>, value<sub>i</sub>]</code>&nbsp;。第&nbsp;<code>i</code>&nbsp;个活动开始于&nbsp;<code>startTime<sub>i</sub></code>&nbsp;，结束于&nbsp;<code>endTime<sub>i</sub></code>&nbsp;，如果你参加这个活动，那么你可以得到价值&nbsp;<code>value<sub>i</sub></code>&nbsp;。你 <strong>最多</strong>&nbsp;可以参加&nbsp;<strong>两个时间不重叠</strong>&nbsp;活动，使得它们的价值之和 <strong>最大</strong>&nbsp;。</p>\n\n<p>请你返回价值之和的 <strong>最大值</strong>&nbsp;。</p>\n\n<p>注意，活动的开始时间和结束时间是 <strong>包括</strong>&nbsp;在活动时间内的，也就是说，你不能参加两个活动且它们之一的开始时间等于另一个活动的结束时间。更具体的，如果你参加一个活动，且结束时间为 <code>t</code>&nbsp;，那么下一个活动必须在&nbsp;<code>t + 1</code>&nbsp;或之后的时间开始。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/21/picture5.png\" style=\"width: 400px; height: 75px;\"></p>\n\n<pre><b>输入：</b>events = [[1,3,2],[4,5,2],[2,4,3]]\n<b>输出：</b>4\n<strong>解释：</strong>选择绿色的活动 0 和 1 ，价值之和为 2 + 2 = 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"Example 1 Diagram\" src=\"https://assets.leetcode.com/uploads/2021/09/21/picture1.png\" style=\"width: 400px; height: 77px;\"></p>\n\n<pre><b>输入：</b>events = [[1,3,2],[4,5,2],[1,5,5]]\n<b>输出：</b>5\n<strong>解释：</strong>选择活动 2 ，价值和为 5 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/21/picture3.png\" style=\"width: 400px; height: 66px;\"></p>\n\n<pre><b>输入：</b>events = [[1,5,3],[1,5,1],[6,6,5]]\n<b>输出：</b>8\n<strong>解释：</strong>选择活动 0 和 2 ，价值之和为 3 + 5 = 8 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= events.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>events[i].length == 3</code></li>\n\t<li><code>1 &lt;= startTime<sub>i</sub> &lt;= endTime<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= value<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2055.蜡烛之间的盘子",
        "hardRate": "MEDIUM",
        "passRate": "43.42%",
        "problemsUrl": "https://leetcode.cn/problems/plates-between-candles/",
        "solutionsUrl": "https://leetcode.cn/problems/plates-between-candles/solution",
        "problemsDesc": "<p>给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>s</code>&nbsp;，它只包含字符&nbsp;<code>'*'</code> 和&nbsp;<code>'|'</code>&nbsp;，其中&nbsp;<code>'*'</code>&nbsp;表示一个 <strong>盘子</strong>&nbsp;，<code>'|'</code>&nbsp;表示一支&nbsp;<strong>蜡烛</strong>&nbsp;。</p>\n\n<p>同时给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>queries</code>&nbsp;，其中&nbsp;<code>queries[i] = [left<sub>i</sub>, right<sub>i</sub>]</code>&nbsp;表示 <strong>子字符串</strong>&nbsp;<code>s[left<sub>i</sub>...right<sub>i</sub>]</code>&nbsp;（<strong>包含左右端点的字符</strong>）。对于每个查询，你需要找到 <strong>子字符串中</strong>&nbsp;在 <strong>两支蜡烛之间</strong>&nbsp;的盘子的 <b>数目</b>&nbsp;。如果一个盘子在 <strong>子字符串中</strong>&nbsp;左边和右边 <strong>都</strong>&nbsp;至少有一支蜡烛，那么这个盘子满足在 <strong>两支蜡烛之间</strong>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，<code>s = \"||**||**|*\"</code>&nbsp;，查询&nbsp;<code>[3, 8]</code>&nbsp;，表示的是子字符串&nbsp;<code>\"*||<strong><em>**</em></strong>|\"</code>&nbsp;。子字符串中在两支蜡烛之间的盘子数目为&nbsp;<code>2</code>&nbsp;，子字符串中右边两个盘子在它们左边和右边 <strong>都 </strong>至少有一支蜡烛。</li>\n</ul>\n\n<p>请你返回一个整数数组&nbsp;<code>answer</code>&nbsp;，其中&nbsp;<code>answer[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个查询的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"ex-1\" src=\"https://assets.leetcode.com/uploads/2021/10/04/ex-1.png\" style=\"width: 400px; height: 134px;\"></p>\n\n<pre><b>输入：</b>s = \"**|**|***|\", queries = [[2,5],[5,9]]\n<b>输出：</b>[2,3]\n<b>解释：</b>\n- queries[0] 有两个盘子在蜡烛之间。\n- queries[1] 有三个盘子在蜡烛之间。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img alt=\"ex-2\" src=\"https://assets.leetcode.com/uploads/2021/10/04/ex-2.png\" style=\"width: 600px; height: 193px;\"></p>\n\n<pre><b>输入：</b>s = \"***|**|*****|**||**|*\", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]\n<b>输出：</b>[9,0,0,0,0]\n<strong>解释：</strong>\n- queries[0] 有 9 个盘子在蜡烛之间。\n- 另一个查询没有盘子在蜡烛之间。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含字符&nbsp;<code>'*'</code> 和&nbsp;<code>'|'</code>&nbsp;。</li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>0 &lt;= left<sub>i</sub> &lt;= right<sub>i</sub> &lt; s.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2056.棋盘上有效移动组合的数目",
        "hardRate": "HARD",
        "passRate": "58.87%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-valid-move-combinations-on-chessboard/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-valid-move-combinations-on-chessboard/solution",
        "problemsDesc": "<p>有一个&nbsp;<code>8 x 8</code>&nbsp;的棋盘，它包含&nbsp;<code>n</code>&nbsp;个棋子（棋子包括车，后和象三种）。给你一个长度为 <code>n</code>&nbsp;的字符串数组&nbsp;<code>pieces</code>&nbsp;，其中&nbsp;<code>pieces[i]</code>&nbsp;表示第 <code>i</code>&nbsp;个棋子的类型（车，后或象）。除此以外，还给你一个长度为 <code>n</code>&nbsp;的二维整数数组&nbsp;<code>positions</code>&nbsp;，其中 <code>positions[i] = [r<sub>i</sub>, c<sub>i</sub>]</code>&nbsp;表示第 <code>i</code>&nbsp;个棋子现在在棋盘上的位置为&nbsp;<code>(r<sub>i</sub>, c<sub>i</sub>)</code>&nbsp;，棋盘下标从 <strong>1</strong>&nbsp;开始。</p>\n\n<p>棋盘上每个棋子都可以移动 <b>至多一次</b>&nbsp;。每个棋子的移动中，首先选择移动的 <strong>方向</strong>&nbsp;，然后选择 <strong>移动的步数</strong>&nbsp;，同时你要确保移动过程中棋子不能移到棋盘以外的地方。棋子需按照以下规则移动：</p>\n\n<ul>\n\t<li>车可以 <strong>水平或者竖直</strong>&nbsp;从&nbsp;<code>(r, c)</code>&nbsp;沿着方向&nbsp;<code>(r+1, c)</code>，<code>(r-1, c)</code>，<code>(r, c+1)</code>&nbsp;或者&nbsp;<code>(r, c-1)</code>&nbsp;移动。</li>\n\t<li>后可以 <strong>水平竖直或者斜对角</strong>&nbsp;从&nbsp;<code>(r, c)</code> 沿着方向&nbsp;<code>(r+1, c)</code>，<code>(r-1, c)</code>，<code>(r, c+1)</code>，<code>(r, c-1)</code>，<code>(r+1, c+1)</code>，<code>(r+1, c-1)</code>，<code>(r-1, c+1)</code>，<code>(r-1, c-1)</code>&nbsp;移动。</li>\n\t<li>象可以 <strong>斜对角</strong>&nbsp;从&nbsp;<code>(r, c)</code>&nbsp;沿着方向&nbsp;<code>(r+1, c+1)</code>，<code>(r+1, c-1)</code>，<code>(r-1, c+1)</code>，<code>(r-1, c-1)</code>&nbsp;移动。</li>\n</ul>\n\n<p><strong>移动组合</strong>&nbsp;包含所有棋子的 <strong>移动</strong>&nbsp;。每一秒，每个棋子都沿着它们选择的方向往前移动 <strong>一步</strong>&nbsp;，直到它们到达目标位置。所有棋子从时刻 <code>0</code>&nbsp;开始移动。如果在某个时刻，两个或者更多棋子占据了同一个格子，那么这个移动组合 <strong>不有效</strong>&nbsp;。</p>\n\n<p>请你返回 <strong>有效</strong>&nbsp;移动组合的数目。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>初始时，<strong>不会有两个棋子</strong>&nbsp;在 <strong>同一个位置 。</strong></li>\n\t<li>有可能在一个移动组合中，有棋子不移动。</li>\n\t<li>如果两个棋子 <strong>直接相邻</strong>&nbsp;且两个棋子下一秒要互相占据对方的位置，可以将它们在同一秒内 <strong>交换位置</strong>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/23/a1.png\" style=\"width: 215px; height: 215px;\" /></p>\n\n<pre>\n<b>输入：</b>pieces = [\"rook\"], positions = [[1,1]]\n<b>输出：</b>15\n<b>解释：</b>上图展示了棋子所有可能的移动。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/23/a2.png\" style=\"width: 215px; height: 215px;\" /></p>\n\n<pre>\n<b>输入：</b>pieces = [\"queen\"], positions = [[1,1]]\n<b>输出：</b>22\n<b>解释：</b>上图展示了棋子所有可能的移动。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/23/a3.png\" style=\"width: 214px; height: 215px;\" /></p>\n\n<pre>\n<b>输入：</b>pieces = [\"bishop\"], positions = [[4,3]]\n<b>输出：</b>12\n<b>解释：</b>上图展示了棋子所有可能的移动。\n</pre>\n\n<p><strong>示例 4:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/23/a4.png\" style=\"width: 216px; height: 219px;\" /></p>\n\n<pre>\n<b>输入：</b>pieces = [\"rook\",\"rook\"], positions = [[1,1],[8,8]]\n<b>输出：</b>223\n<b>解释：</b>每个车有 15 种移动，所以总共有 15 * 15 = 225 种移动组合。\n但是，有两个是不有效的移动组合：\n- 将两个车都移动到 (8, 1) ，会导致它们在同一个格子相遇。\n- 将两个车都移动到 (1, 8) ，会导致它们在同一个格子相遇。\n所以，总共有 225 - 2 = 223 种有效移动组合。\n注意，有两种有效的移动组合，分别是一个车在 (1, 8) ，另一个车在 (8, 1) 。\n即使棋盘状态是相同的，这两个移动组合被视为不同的，因为每个棋子移动操作是不相同的。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/23/a5.png\" style=\"width: 214px; height: 213px;\" /></p>\n\n<pre>\n<b>输入：</b>pieces = [\"queen\",\"bishop\"], positions = [[5,7],[3,4]]\n<b>输出：</b>281\n<b>解释：</b>总共有 12 * 24 = 288 种移动组合。\n但是，有一些不有效的移动组合：\n- 如果后停在 (6, 7) ，它会阻挡象到达 (6, 7) 或者 (7, 8) 。\n- 如果后停在 (5, 6) ，它会阻挡象到达 (5, 6) ，(6, 7) 或者 (7, 8) 。\n- 如果象停在 (5, 2) ，它会阻挡后到达 (5, 2) 或者 (5, 1) 。\n在 288 个移动组合当中，281 个是有效的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == pieces.length </code></li>\n\t<li><code>n == positions.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 4</code></li>\n\t<li><code>pieces</code>&nbsp;只包含字符串&nbsp;<code>\"rook\"</code>&nbsp;，<code>\"queen\"</code>&nbsp;和&nbsp;<code>\"bishop\"</code>&nbsp;。</li>\n\t<li>棋盘上总共最多只有一个后。</li>\n\t<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 8</code></li>\n\t<li>每一个&nbsp;<code>positions[i]</code>&nbsp;互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2057.值相等的最小索引",
        "hardRate": "EASY",
        "passRate": "75.40%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-index-with-equal-value/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-index-with-equal-value/solution",
        "problemsDesc": "<p>给你一个下标从 0 开始的整数数组 <code>nums</code> ，返回 <code>nums</code> 中满足<em> </em><code>i mod 10 == nums[i]</code><em> </em>的最小下标 <code>i</code> ；如果不存在这样的下标，返回<em> </em><code>-1</code><em> </em>。</p>\n\n<p><code>x mod y</code> 表示 <code>x</code> 除以 <code>y</code> 的 <strong>余数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,2]\n<strong>输出：</strong>0\n<strong>解释：</strong>\ni=0: 0 mod 10 = 0 == nums[0].\ni=1: 1 mod 10 = 1 == nums[1].\ni=2: 2 mod 10 = 2 == nums[2].\n所有下标都满足 i mod 10 == nums[i] ，所以返回最小下标 0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,3,2,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>\ni=0: 0 mod 10 = 0 != nums[0].\ni=1: 1 mod 10 = 1 != nums[1].\ni=2: 2 mod 10 = 2 == nums[2].\ni=3: 3 mod 10 = 3 != nums[3].\n2 唯一一个满足 i mod 10 == nums[i] 的下标\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,5,6,7,8,9,0]\n<strong>输出：</strong>-1\n<strong>解释：</strong>不存在满足 i mod 10 == nums[i] 的下标\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,1,3,5,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>1 是唯一一个满足 i mod 10 == nums[i] 的下标\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2058.找出临界点之间的最小和最大距离",
        "hardRate": "MEDIUM",
        "passRate": "56.51%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/solution",
        "problemsDesc": "<p>链表中的 <strong>临界点</strong> 定义为一个 <strong>局部极大值点</strong> <strong>或</strong> <strong>局部极小值点 。</strong></p>\n\n<p>如果当前节点的值 <strong>严格大于</strong> 前一个节点和后一个节点，那么这个节点就是一个<strong>&nbsp; 局部极大值点</strong> 。</p>\n\n<p>如果当前节点的值 <strong>严格小于</strong> 前一个节点和后一个节点，那么这个节点就是一个<strong>&nbsp; 局部极小值点</strong> 。</p>\n\n<p>注意：节点只有在同时存在前一个节点和后一个节点的情况下，才能成为一个 <strong>局部极大值点 / 极小值点</strong> 。</p>\n\n<p>给你一个链表 <code>head</code> ，返回一个长度为 2 的数组<em> </em><code>[minDistance, maxDistance]</code> ，其中<em> </em><code>minDistance</code><em> </em>是任意两个不同临界点之间的最小距离，<code>maxDistance</code> 是任意两个不同临界点之间的最大距离。如果临界点少于两个，则返回 <code>[-1，-1]</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/13/a1.png\" style=\"width: 148px; height: 55px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [3,1]\n<strong>输出：</strong>[-1,-1]\n<strong>解释：</strong>链表 [3,1] 中不存在临界点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/13/a2.png\" style=\"width: 624px; height: 46px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [5,3,1,2,5,1,2]\n<strong>输出：</strong>[1,3]\n<strong>解释：</strong>存在三个临界点：\n- [5,3,<em><strong>1</strong></em>,2,5,1,2]：第三个节点是一个局部极小值点，因为 1 比 3 和 2 小。\n- [5,3,1,2,<em><strong>5</strong></em>,1,2]：第五个节点是一个局部极大值点，因为 5 比 2 和 1 大。\n- [5,3,1,2,5,<em><strong>1</strong></em>,2]：第六个节点是一个局部极小值点，因为 1 比 5 和 2 小。\n第五个节点和第六个节点之间距离最小。minDistance = 6 - 5 = 1 。\n第三个节点和第六个节点之间距离最大。maxDistance = 6 - 3 = 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/14/a5.png\" style=\"width: 624px; height: 39px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,3,2,2,3,2,2,2,7]\n<strong>输出：</strong>[3,3]\n<strong>解释：</strong>存在两个临界点：\n- [1,<em><strong>3</strong></em>,2,2,3,2,2,2,7]：第二个节点是一个局部极大值点，因为 3 比 1 和 2 大。\n- [1,3,2,2,<em><strong>3</strong></em>,2,2,2,7]：第五个节点是一个局部极大值点，因为 3 比 2 和 2 大。\n最小和最大距离都存在于第二个节点和第五个节点之间。\n因此，minDistance 和 maxDistance 是 5 - 2 = 3 。\n注意，最后一个节点不算一个局部极大值点，因为它之后就没有节点了。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/13/a4.png\" style=\"width: 345px; height: 52px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [2,3,3,2]\n<strong>输出：</strong>[-1,-1]\n<strong>解释：</strong>链表 [2,3,3,2] 中不存在临界点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数量在范围 <code>[2, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2059.转化数字的最小运算数",
        "hardRate": "MEDIUM",
        "passRate": "48.23%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-convert-number/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-convert-number/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，该数组由 <strong>互不相同</strong> 的数字组成。另给你两个整数 <code>start</code> 和 <code>goal</code> 。</p>\n\n<p>整数 <code>x</code> 的值最开始设为 <code>start</code> ，你打算执行一些运算使 <code>x</code> 转化为 <code>goal</code> 。你可以对数字 <code>x</code> 重复执行下述运算：</p>\n\n<p>如果 <code>0 &lt;= x &lt;= 1000</code> ，那么，对于数组中的任一下标 <code>i</code>（<code>0 &lt;= i &lt; nums.length</code>），可以将 <code>x</code> 设为下述任一值：</p>\n\n<ul>\n\t<li><code>x + nums[i]</code></li>\n\t<li><code>x - nums[i]</code></li>\n\t<li><code>x ^ nums[i]</code>（按位异或 XOR）</li>\n</ul>\n\n<p>注意，你可以按任意顺序使用每个 <code>nums[i]</code> 任意次。使 <code>x</code> 越过 <code>0 &lt;= x &lt;= 1000</code> 范围的运算同样可以生效，但该该运算执行后将不能执行其他运算。</p>\n\n<p>返回将 <code>x = start</code><em> </em>转化为<em> </em><code>goal</code><em> </em>的最小操作数；如果无法完成转化，则返回<em> </em><code>-1</code><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,4,12], start = 2, goal = 12\n<strong>输出：</strong>2\n<strong>解释：</strong>\n可以按 2 → 14 → 12 的转化路径进行，只需执行下述 2 次运算：\n- 2 + 12 = 14\n- 14 - 2 = 12\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,5,7], start = 0, goal = -4\n<strong>输出：</strong>2\n<strong>解释：</strong>\n可以按 0 → 3 → -4 的转化路径进行，只需执行下述 2 次运算：\n- 0 + 3 = 3\n- 3 - 7 = -4\n注意，最后一步运算使 x 超过范围 0 &lt;= x &lt;= 1000 ，但该运算仍然可以生效。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,8,16], start = 0, goal = 1\n<strong>输出：</strong>-1\n<strong>解释：</strong>\n无法将 0 转化为 1</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i], goal &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= start &lt;= 1000</code></li>\n\t<li><code>start != goal</code></li>\n\t<li><code>nums</code> 中的所有整数互不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2060.同源字符串检测",
        "hardRate": "HARD",
        "passRate": "40.43%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-an-original-string-exists-given-two-encoded-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-an-original-string-exists-given-two-encoded-strings/solution",
        "problemsDesc": "<p>原字符串由小写字母组成，可以按下述步骤编码：</p>\n\n<ul>\n\t<li>任意将其 <strong>分割</strong> 为由若干 <strong>非空</strong> 子字符串组成的一个 <strong>序列</strong> 。</li>\n\t<li>任意选择序列中的一些元素（也可能不选择），然后将这些元素替换为元素各自的长度（作为一个数字型的字符串）。</li>\n\t<li>重新 <strong>顺次连接</strong> 序列，得到编码后的字符串。</li>\n</ul>\n\n<p>例如，编码 <code>\"abcdefghijklmnop\"</code> 的一种方法可以描述为：</p>\n\n<ul>\n\t<li>将原字符串分割得到一个序列：<code>[\"ab\", \"cdefghijklmn\", \"o\", \"p\"]</code> 。</li>\n\t<li>选出其中第二个和第三个元素并分别替换为它们自身的长度。序列变为 <code>[\"ab\", \"12\", \"1\", \"p\"]</code> 。</li>\n\t<li>重新顺次连接序列中的元素，得到编码后的字符串：<code>\"ab121p\"</code> 。</li>\n</ul>\n\n<p>给你两个编码后的字符串 <code>s1</code> 和 <code>s2</code> ，由小写英文字母和数字 <code>1-9</code> 组成。如果存在能够同时编码得到 <code>s1</code> 和 <code>s2</code> 原字符串，返回 <code>true</code> ；否则，返回 <code>false</code>。</p>\n\n<p><strong>注意：</strong>生成的测试用例满足 <code>s1</code> 和 <code>s2</code> 中连续数字数不超过 <code>3</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"internationalization\", s2 = \"i18n\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\"internationalization\" 可以作为原字符串\n- \"internationalization\" \n  -&gt; 分割：      [\"internationalization\"]\n  -&gt; 不替换任何元素\n  -&gt; 连接：      \"internationalization\"，得到 s1\n- \"internationalization\"\n  -&gt; 分割：      [\"i\", \"nternationalizatio\", \"n\"]\n  -&gt; 替换：      [\"i\", \"18\",                 \"n\"]\n  -&gt; 连接：      \"i18n\"，得到 s2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"l123e\", s2 = \"44\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\"leetcode\" 可以作为原字符串\n- \"leetcode\" \n  -&gt; 分割：       [\"l\", \"e\", \"et\", \"cod\", \"e\"]\n  -&gt; 替换：       [\"l\", \"1\", \"2\",  \"3\",   \"e\"]\n  -&gt; 连接：       \"l123e\"，得到 s1\n- \"leetcode\" \n  -&gt; 分割：       [\"leet\", \"code\"]\n  -&gt; 替换：       [\"4\",    \"4\"]\n  -&gt; 连接：       \"44\"，得到 s2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"a5b\", s2 = \"c5b\"\n<strong>输出：</strong>false\n<strong>解释：</strong>不存在这样的原字符串\n- 编码为 s1 的字符串必须以字母 'a' 开头\n- 编码为 s2 的字符串必须以字母 'c' 开头\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"112s\", s2 = \"g841\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\"gaaaaaaaaaaaas\" 可以作为原字符串\n- \"gaaaaaaaaaaaas\"\n  -&gt; 分割：       [\"g\", \"aaaaaaaaaaaa\", \"s\"]\n  -&gt; 替换：       [\"1\", \"12\",           \"s\"]\n  -&gt; 连接：       \"112s\"，得到 s1\n- \"gaaaaaaaaaaaas\"\n  -&gt; 分割：       [\"g\", \"aaaaaaaa\", \"aaaa\", \"s\"]\n  -&gt; 替换：       [\"g\", \"8\",        \"4\",    \"1\"]\n  -&gt; 连接         \"g841\"，得到 s2\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"ab\", s2 = \"a2\"\n<strong>输出：</strong>false\n<strong>解释：</strong>不存在这样的原字符串\n- 编码为 s1 的字符串由两个字母组成\n- 编码为 s2 的字符串由三个字母组成\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 40</code></li>\n\t<li><code>s1</code> 和 <code>s2</code> 仅由数字 <code>1-9</code> 和小写英文字母组成</li>\n\t<li><code>s1</code> 和 <code>s2</code> 中连续数字数不超过 <code>3</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2061.扫地机器人清扫过的空间个数",
        "hardRate": "MEDIUM",
        "passRate": "49.78%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-spaces-cleaning-robot-cleaned/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-spaces-cleaning-robot-cleaned/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2062.统计字符串中的元音子字符串",
        "hardRate": "EASY",
        "passRate": "62.56%",
        "problemsUrl": "https://leetcode.cn/problems/count-vowel-substrings-of-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/count-vowel-substrings-of-a-string/solution",
        "problemsDesc": "<p><strong>子字符串</strong> 是字符串中的一个连续（非空）的字符序列。</p>\n\n<p><strong>元音子字符串</strong> 是 <strong>仅</strong> 由元音（<code>'a'</code>、<code>'e'</code>、<code>'i'</code>、<code>'o'</code> 和 <code>'u'</code>）组成的一个子字符串，且必须包含 <strong>全部五种</strong> 元音。</p>\n\n<p>给你一个字符串 <code>word</code> ，统计并返回 <code>word</code> 中 <strong>元音子字符串的数目</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"aeiouu\"\n<strong>输出：</strong>2\n<strong>解释：</strong>下面列出 word 中的元音子字符串（斜体加粗部分）：\n- \"<em><strong>aeiou</strong></em>u\"\n- \"<strong><em>aeiouu</em></strong>\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"unicornarihan\"\n<strong>输出：</strong>0\n<strong>解释：</strong>word 中不含 5 种元音，所以也不会存在元音子字符串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"cuaieuouac\"\n<strong>输出：</strong>7\n<strong>解释：</strong>下面列出 word 中的元音子字符串（斜体加粗部分）：\n- \"c<em><strong>uaieuo</strong></em>uac\"\n- \"c<em><strong>uaieuou</strong></em>ac\"\n- \"c<em><strong>uaieuoua</strong></em>c\"\n- \"cu<em><strong>aieuo</strong></em>uac\"\n- \"cu<em><strong>aieuou</strong></em>ac\"\n- \"cu<em><strong>aieuoua</strong></em>c\"\n- \"cua<em><strong>ieuoua</strong></em>c\"</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"bbaeixoubb\"\n<strong>输出：</strong>0\n<strong>解释：</strong>所有包含全部五种元音的子字符串都含有辅音，所以不存在元音子字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 100</code></li>\n\t<li><code>word</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2063.所有子字符串中的元音",
        "hardRate": "MEDIUM",
        "passRate": "51.75%",
        "problemsUrl": "https://leetcode.cn/problems/vowels-of-all-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/vowels-of-all-substrings/solution",
        "problemsDesc": "<p>给你一个字符串 <code>word</code> ，返回 <code>word</code> 的所有子字符串中 <strong>元音的总数</strong> ，元音是指 <code>'a'</code>、<code>'e'</code><em>、</em><code>'i'</code><em>、</em><code>'o'</code><em> </em>和 <code>'u'</code><em> 。</em></p>\n\n<p><strong>子字符串</strong> 是字符串中一个连续（非空）的字符序列。</p>\n\n<p><strong>注意：</strong>由于对 <code>word</code> 长度的限制比较宽松，答案可能超过有符号 32 位整数的范围。计算时需当心。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"aba\"\n<strong>输出：</strong>6\n<strong>解释：</strong>\n所有子字符串是：\"a\"、\"ab\"、\"aba\"、\"b\"、\"ba\" 和 \"a\" 。\n- \"b\" 中有 0 个元音\n- \"a\"、\"ab\"、\"ba\" 和 \"a\" 每个都有 1 个元音\n- \"aba\" 中有 2 个元音\n因此，元音总数 = 0 + 1 + 1 + 1 + 1 + 2 = 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"abc\"\n<strong>输出：</strong>3\n<strong>解释：</strong>\n所有子字符串是：\"a\"、\"ab\"、\"abc\"、\"b\"、\"bc\" 和 \"c\" 。\n- \"a\"、\"ab\" 和 \"abc\" 每个都有 1 个元音\n- \"b\"、\"bc\" 和 \"c\" 每个都有 0 个元音\n因此，元音总数 = 1 + 1 + 1 + 0 + 0 + 0 = 3 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"ltcd\"\n<strong>输出：</strong>0\n<strong>解释：</strong>\"ltcd\" 的子字符串均不含元音。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"noosabasboosa\"\n<strong>输出：</strong>237\n<strong>解释：</strong>所有子字符串中共有 237 个元音。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>word</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2064.分配给商店的最多商品的最小值",
        "hardRate": "MEDIUM",
        "passRate": "45.06%",
        "problemsUrl": "https://leetcode.cn/problems/minimized-maximum-of-products-distributed-to-any-store/",
        "solutionsUrl": "https://leetcode.cn/problems/minimized-maximum-of-products-distributed-to-any-store/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;，表示有&nbsp;<code>n</code>&nbsp;间零售商店。总共有&nbsp;<code>m</code>&nbsp;种产品，每种产品的数目用一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>quantities</code>&nbsp;表示，其中&nbsp;<code>quantities[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;种商品的数目。</p>\n\n<p>你需要将 <strong>所有商品</strong>&nbsp;分配到零售商店，并遵守这些规则：</p>\n\n<ul>\n\t<li>一间商店 <strong>至多</strong>&nbsp;只能有 <strong>一种商品</strong> ，但一间商店拥有的商品数目可以为&nbsp;<strong>任意</strong>&nbsp;件。</li>\n\t<li>分配后，每间商店都会被分配一定数目的商品（可能为 <code>0</code>&nbsp;件）。用&nbsp;<code>x</code>&nbsp;表示所有商店中分配商品数目的最大值，你希望 <code>x</code>&nbsp;越小越好。也就是说，你想 <strong>最小化</strong>&nbsp;分配给任意商店商品数目的 <strong>最大值</strong>&nbsp;。</li>\n</ul>\n\n<p>请你返回最小的可能的&nbsp;<code>x</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 6, quantities = [11,6]\n<b>输出：</b>3\n<strong>解释： </strong>一种最优方案为：\n- 11 件种类为 0 的商品被分配到前 4 间商店，分配数目分别为：2，3，3，3 。\n- 6 件种类为 1 的商品被分配到另外 2 间商店，分配数目分别为：3，3 。\n分配给所有商店的最大商品数目为 max(2, 3, 3, 3, 3, 3) = 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 7, quantities = [15,10,10]\n<b>输出：</b>5\n<b>解释：</b>一种最优方案为：\n- 15 件种类为 0 的商品被分配到前 3 间商店，分配数目为：5，5，5 。\n- 10 件种类为 1 的商品被分配到接下来 2 间商店，数目为：5，5 。\n- 10 件种类为 2 的商品被分配到最后 2 间商店，数目为：5，5 。\n分配给所有商店的最大商品数目为 max(5, 5, 5, 5, 5, 5, 5) = 5 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 1, quantities = [100000]\n<b>输出：</b>100000\n<b>解释：</b>唯一一种最优方案为：\n- 所有 100000 件商品 0 都分配到唯一的商店中。\n分配给所有商店的最大商品数目为 max(100000) = 100000 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == quantities.length</code></li>\n\t<li><code>1 &lt;= m &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= quantities[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2065.最大化一张图中的路径价值",
        "hardRate": "HARD",
        "passRate": "54.24%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-path-quality-of-a-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-path-quality-of-a-graph/solution",
        "problemsDesc": "<p>给你一张 <strong>无向</strong>&nbsp;图，图中有 <code>n</code>&nbsp;个节点，节点编号从 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;（<strong>都包括</strong>）。同时给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>values</code>&nbsp;，其中&nbsp;<code>values[i]</code>&nbsp;是第 <code>i</code>&nbsp;个节点的 <strong>价值</strong>&nbsp;。同时给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[j] = [u<sub>j</sub>, v<sub>j</sub>, time<sub>j</sub>]</code>&nbsp;表示节点&nbsp;<code>u<sub>j</sub></code> 和&nbsp;<code>v<sub>j</sub></code>&nbsp;之间有一条需要&nbsp;<code>time<sub>j</sub></code>&nbsp;秒才能通过的无向边。最后，给你一个整数&nbsp;<code>maxTime</code>&nbsp;。</p>\n\n<p><strong>合法路径</strong>&nbsp;指的是图中任意一条从节点&nbsp;<code>0</code>&nbsp;开始，最终回到节点 <code>0</code>&nbsp;，且花费的总时间 <strong>不超过</strong>&nbsp;<code>maxTime</code> 秒的一条路径。你可以访问一个节点任意次。一条合法路径的 <b>价值</b>&nbsp;定义为路径中 <strong>不同节点</strong>&nbsp;的价值 <strong>之和</strong>&nbsp;（每个节点的价值 <strong>至多</strong>&nbsp;算入价值总和中一次）。</p>\n\n<p>请你返回一条合法路径的 <strong>最大</strong>&nbsp;价值。</p>\n\n<p><strong>注意：</strong>每个节点 <strong>至多</strong>&nbsp;有 <strong>四条</strong>&nbsp;边与之相连。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/19/ex1drawio.png\" style=\"width: 269px; height: 170px;\" /></p>\n\n<pre>\n<b>输入：</b>values = [0,32,10,43], edges = [[0,1,10],[1,2,15],[0,3,10]], maxTime = 49\n<b>输出：</b>75\n<strong>解释：</strong>\n一条可能的路径为：0 -&gt; 1 -&gt; 0 -&gt; 3 -&gt; 0 。总花费时间为 10 + 10 + 10 + 10 = 40 &lt;= 49 。\n访问过的节点为 0 ，1 和 3 ，最大路径价值为 0 + 32 + 43 = 75 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/19/ex2drawio.png\" style=\"width: 269px; height: 170px;\" /></p>\n\n<pre>\n<b>输入：</b>values = [5,10,15,20], edges = [[0,1,10],[1,2,10],[0,3,10]], maxTime = 30\n<b>输出：</b>25\n<strong>解释：</strong>\n一条可能的路径为：0 -&gt; 3 -&gt; 0 。总花费时间为 10 + 10 = 20 &lt;= 30 。\n访问过的节点为 0 和 3 ，最大路径价值为 5 + 20 = 25 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/19/ex31drawio.png\" style=\"width: 236px; height: 170px;\" /></p>\n\n<pre>\n<b>输入：</b>values = [1,2,3,4], edges = [[0,1,10],[1,2,11],[2,3,12],[1,3,13]], maxTime = 50\n<b>输出：</b>7\n<strong>解释：</strong>\n一条可能的路径为：0 -&gt; 1 -&gt; 3 -&gt; 1 -&gt; 0 。总花费时间为 10 + 13 + 13 + 10 = 46 &lt;= 50 。\n访问过的节点为 0 ，1 和 3 ，最大路径价值为 1 + 2 + 4 = 7 。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/21/ex4drawio.png\" style=\"width: 270px; height: 71px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>values = [0,1,2], edges = [[1,2,10]], maxTime = 10\n<b>输出：</b>0\n<b>解释：</b>\n唯一一条路径为 0 。总花费时间为 0 。\n唯一访问过的节点为 0 ，最大路径价值为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == values.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= values[i] &lt;= 10<sup>8</sup></code></li>\n\t<li><code>0 &lt;= edges.length &lt;= 2000</code></li>\n\t<li><code>edges[j].length == 3 </code></li>\n\t<li><code>0 &lt;= u<sub>j </sub>&lt; v<sub>j</sub> &lt;= n - 1</code></li>\n\t<li><code>10 &lt;= time<sub>j</sub>, maxTime &lt;= 100</code></li>\n\t<li><code>[u<sub>j</sub>, v<sub>j</sub>]</code>&nbsp;所有节点对 <strong>互不相同</strong>&nbsp;。</li>\n\t<li>每个节点 <strong>至多有四条&nbsp;</strong>边。</li>\n\t<li>图可能不连通。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2066.账户余额",
        "hardRate": "MEDIUM",
        "passRate": "78.73%",
        "problemsUrl": "https://leetcode.cn/problems/account-balance/",
        "solutionsUrl": "https://leetcode.cn/problems/account-balance/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2067.等计数子串的数量",
        "hardRate": "MEDIUM",
        "passRate": "55.07%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-equal-count-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-equal-count-substrings/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2068.检查两个字符串是否几乎相等",
        "hardRate": "EASY",
        "passRate": "69.78%",
        "problemsUrl": "https://leetcode.cn/problems/check-whether-two-strings-are-almost-equivalent/",
        "solutionsUrl": "https://leetcode.cn/problems/check-whether-two-strings-are-almost-equivalent/solution",
        "problemsDesc": "<p>如果两个字符串 <code>word1</code>&nbsp;和 <code>word2</code>&nbsp;中从 <code>'a'</code>&nbsp;到 <code>'z'</code>&nbsp;每一个字母出现频率之差都 <strong>不超过</strong>&nbsp;<code>3</code>&nbsp;，那么我们称这两个字符串&nbsp;<code>word1</code> 和&nbsp;<code>word2</code> <strong>几乎相等</strong>&nbsp;。</p>\n\n<p>给你两个长度都为&nbsp;<code>n</code>&nbsp;的字符串&nbsp;<code>word1</code> 和&nbsp;<code>word2</code>&nbsp;，如果&nbsp;<code>word1</code>&nbsp;和&nbsp;<code>word2</code>&nbsp;<strong>几乎相等</strong>&nbsp;，请你返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>一个字母 <code>x</code>&nbsp;的出现 <strong>频率</strong>&nbsp;指的是它在字符串中出现的次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>word1 = \"aaaa\", word2 = \"bccb\"\n<b>输出：</b>false\n<b>解释：</b>字符串 \"aaaa\" 中有 4 个 'a' ，但是 \"bccb\" 中有 0 个 'a' 。\n两者之差为 4 ，大于上限 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>word1 = \"abcdeef\", word2 = \"abaaacc\"\n<b>输出：</b>true\n<b>解释：</b>word1 和 word2 中每个字母出现频率之差至多为 3 ：\n- 'a' 在 word1 中出现了 1 次，在 word2 中出现了 4 次，差为 3 。\n- 'b' 在 word1 中出现了 1 次，在 word2 中出现了 1 次，差为 0 。\n- 'c' 在 word1 中出现了 1 次，在 word2 中出现了 2 次，差为 1 。\n- 'd' 在 word1 中出现了 1 次，在 word2 中出现了 0 次，差为 1 。\n- 'e' 在 word1 中出现了 2 次，在 word2 中出现了 0 次，差为 2 。\n- 'f' 在 word1 中出现了 1 次，在 word2 中出现了 0 次，差为 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>word1 = \"cccddabba\", word2 = \"babababab\"\n<b>输出：</b>true\n<b>解释：</b>word1 和 word2 中每个字母出现频率之差至多为 3 ：\n- 'a' 在 word1 中出现了 2 次，在 word2 中出现了 4 次，差为 2 。\n- 'b' 在 word1 中出现了 2 次，在 word2 中出现了 5 次，差为 3 。\n- 'c' 在 word1 中出现了 3 次，在 word2 中出现了 0 次，差为 3 。\n- 'd' 在 word1 中出现了 2 次，在 word2 中出现了 0 次，差为 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == word1.length == word2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>word1</code> 和&nbsp;<code>word2</code>&nbsp;都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2069.模拟行走机器人 II",
        "hardRate": "MEDIUM",
        "passRate": "22.12%",
        "problemsUrl": "https://leetcode.cn/problems/walking-robot-simulation-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/walking-robot-simulation-ii/solution",
        "problemsDesc": "<p>给你一个在 XY 平面上的&nbsp;<code>width x height</code>&nbsp;的网格图，<strong>左下角</strong>&nbsp;的格子为&nbsp;<code>(0, 0)</code>&nbsp;，<strong>右上角</strong>&nbsp;的格子为&nbsp;<code>(width - 1, height - 1)</code>&nbsp;。网格图中相邻格子为四个基本方向之一（<code>\"North\"</code>，<code>\"East\"</code>，<code>\"South\"</code>&nbsp;和&nbsp;<code>\"West\"</code>）。一个机器人 <strong>初始</strong>&nbsp;在格子&nbsp;<code>(0, 0)</code>&nbsp;，方向为&nbsp;<code>\"East\"</code>&nbsp;。</p>\n\n<p>机器人可以根据指令移动指定的 <strong>步数</strong>&nbsp;。每一步，它可以执行以下操作。</p>\n\n<ol>\n\t<li>沿着当前方向尝试 <strong>往前一步</strong>&nbsp;。</li>\n\t<li>如果机器人下一步将到达的格子 <strong>超出了边界</strong>&nbsp;，机器人会 <strong>逆时针</strong>&nbsp;转 90 度，然后再尝试往前一步。</li>\n</ol>\n\n<p>如果机器人完成了指令要求的移动步数，它将停止移动并等待下一个指令。</p>\n\n<p>请你实现&nbsp;<code>Robot</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>Robot(int width, int height)</code>&nbsp;初始化一个&nbsp;<code>width x height</code>&nbsp;的网格图，机器人初始在&nbsp;<code>(0, 0)</code>&nbsp;，方向朝&nbsp;<code>\"East\"</code>&nbsp;。</li>\n\t<li><code>void step(int num)</code>&nbsp;给机器人下达前进&nbsp;<code>num</code>&nbsp;步的指令。</li>\n\t<li><code>int[] getPos()</code>&nbsp;返回机器人当前所处的格子位置，用一个长度为 2 的数组&nbsp;<code>[x, y]</code>&nbsp;表示。</li>\n\t<li><code>String getDir()</code>&nbsp;返回当前机器人的朝向，为&nbsp;<code>\"North\"</code>&nbsp;，<code>\"East\"</code>&nbsp;，<code>\"South\"</code>&nbsp;或者&nbsp;<code>\"West\"</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"example-1\" src=\"https://assets.leetcode.com/uploads/2021/10/09/example-1.png\" style=\"width: 498px; height: 268px;\" /></p>\n\n<pre>\n<strong>输入：</strong>\n[\"Robot\", \"step\", \"step\", \"getPos\", \"getDir\", \"step\", \"step\", \"step\", \"getPos\", \"getDir\"]\n[[6, 3], [2], [2], [], [], [2], [1], [4], [], []]\n<strong>输出：</strong>\n[null, null, null, [4, 0], \"East\", null, null, null, [1, 2], \"West\"]\n\n<strong>解释：</strong>\nRobot robot = new Robot(6, 3); // 初始化网格图，机器人在 (0, 0) ，朝东。\nrobot.step(2);  // 机器人朝东移动 2 步，到达 (2, 0) ，并朝东。\nrobot.step(2);  // 机器人朝东移动 2 步，到达 (4, 0) ，并朝东。\nrobot.getPos(); // 返回 [4, 0]\nrobot.getDir(); // 返回 \"East\"\nrobot.step(2);  // 朝东移动 1 步到达 (5, 0) ，并朝东。\n                // 下一步继续往东移动将出界，所以逆时针转变方向朝北。\n                // 然后，往北移动 1 步到达 (5, 1) ，并朝北。\nrobot.step(1);  // 朝北移动 1 步到达 (5, 2) ，并朝 <strong>北</strong> （不是朝西）。\nrobot.step(4);  // 下一步继续往北移动将出界，所以逆时针转变方向朝西。\n                // 然后，移动 4 步到 (1, 2) ，并朝西。\nrobot.getPos(); // 返回 [1, 2]\nrobot.getDir(); // 返回 \"West\"\n\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= width, height &lt;= 100</code></li>\n\t<li><code>1 &lt;= num &lt;= 10<sup>5</sup></code></li>\n\t<li><code>step</code> ，<code>getPos</code>&nbsp;和&nbsp;<code>getDir</code>&nbsp;<strong>总共&nbsp;</strong>调用次数不超过&nbsp;<code>10<sup>4</sup></code>&nbsp;次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2070.每一个查询的最大美丽值",
        "hardRate": "MEDIUM",
        "passRate": "45.16%",
        "problemsUrl": "https://leetcode.cn/problems/most-beautiful-item-for-each-query/",
        "solutionsUrl": "https://leetcode.cn/problems/most-beautiful-item-for-each-query/solution",
        "problemsDesc": "<p>给你一个二维整数数组&nbsp;<code>items</code>&nbsp;，其中&nbsp;<code>items[i] = [price<sub>i</sub>, beauty<sub>i</sub>]</code>&nbsp;分别表示每一个物品的 <strong>价格</strong>&nbsp;和 <strong>美丽值</strong>&nbsp;。</p>\n\n<p>同时给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>queries</code>&nbsp;。对于每个查询&nbsp;<code>queries[j]</code>&nbsp;，你想求出价格小于等于&nbsp;<code>queries[j]</code>&nbsp;的物品中，<strong>最大的美丽值</strong>&nbsp;是多少。如果不存在符合条件的物品，那么查询的结果为&nbsp;<code>0</code>&nbsp;。</p>\n\n<p>请你返回一个长度与 <code>queries</code>&nbsp;相同的数组<em>&nbsp;</em><code>answer</code>，其中<em>&nbsp;</em><code>answer[j]</code>是第&nbsp;<code>j</code>&nbsp;个查询的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]\n<b>输出：</b>[2,4,5,5,6,6]\n<strong>解释：</strong>\n- queries[0]=1 ，[1,2] 是唯一价格 &lt;= 1 的物品。所以这个查询的答案为 2 。\n- queries[1]=2 ，符合条件的物品有 [1,2] 和 [2,4] 。\n  它们中的最大美丽值为 4 。\n- queries[2]=3 和 queries[3]=4 ，符合条件的物品都为 [1,2] ，[3,2] ，[2,4] 和 [3,5] 。\n  它们中的最大美丽值为 5 。\n- queries[4]=5 和 queries[5]=6 ，所有物品都符合条件。\n  所以，答案为所有物品中的最大美丽值，为 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]\n<b>输出：</b>[4]\n<b>解释：</b>\n每个物品的价格均为 1 ，所以我们选择最大美丽值 4 。\n注意，多个物品可能有相同的价格和美丽值。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>items = [[10,1000]], queries = [5]\n<b>输出：</b>[0]\n<strong>解释：</strong>\n没有物品的价格小于等于 5 ，所以没有物品可以选择。\n因此，查询的结果为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= items.length, queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>items[i].length == 2</code></li>\n\t<li><code>1 &lt;= price<sub>i</sub>, beauty<sub>i</sub>, queries[j] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2071.你可以安排的最多任务数目",
        "hardRate": "HARD",
        "passRate": "29.94%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-tasks-you-can-assign/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-tasks-you-can-assign/solution",
        "problemsDesc": "<p>给你&nbsp;<code>n</code>&nbsp;个任务和&nbsp;<code>m</code>&nbsp;个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>tasks</code>&nbsp;中，第 <code>i</code>&nbsp;个任务需要&nbsp;<code>tasks[i]</code>&nbsp;的力量才能完成。每个工人的力量值保存在下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>workers</code>&nbsp;中，第&nbsp;<code>j</code>&nbsp;个工人的力量值为&nbsp;<code>workers[j]</code>&nbsp;。每个工人只能完成 <strong>一个</strong>&nbsp;任务，且力量值需要 <strong>大于等于</strong>&nbsp;该任务的力量要求值（即&nbsp;<code>workers[j] &gt;= tasks[i]</code>&nbsp;）。</p>\n\n<p>除此以外，你还有&nbsp;<code>pills</code>&nbsp;个神奇药丸，可以给 <strong>一个工人的力量值</strong>&nbsp;增加&nbsp;<code>strength</code>&nbsp;。你可以决定给哪些工人使用药丸，但每个工人&nbsp;<strong>最多</strong>&nbsp;只能使用&nbsp;<strong>一片</strong>&nbsp;药丸。</p>\n\n<p>给你下标从 <strong>0</strong>&nbsp;开始的整数数组<code>tasks</code> 和&nbsp;<code>workers</code>&nbsp;以及两个整数&nbsp;<code>pills</code> 和&nbsp;<code>strength</code>&nbsp;，请你返回 <strong>最多</strong>&nbsp;有多少个任务可以被完成。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>tasks = [<em><strong>3</strong></em>,<em><strong>2</strong></em>,<em><strong>1</strong></em>], workers = [<em><strong>0</strong></em>,<em><strong>3</strong></em>,<em><strong>3</strong></em>], pills = 1, strength = 1\n<b>输出：</b>3\n<strong>解释：</strong>\n我们可以按照如下方案安排药丸：\n- 给 0 号工人药丸。\n- 0 号工人完成任务 2（0 + 1 &gt;= 1）\n- 1 号工人完成任务 1（3 &gt;= 2）\n- 2 号工人完成任务 0（3 &gt;= 3）\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>tasks = [<em><strong>5</strong></em>,4], workers = [<em><strong>0</strong></em>,0,0], pills = 1, strength = 5\n<b>输出：</b>1\n<strong>解释：</strong>\n我们可以按照如下方案安排药丸：\n- 给 0 号工人药丸。\n- 0 号工人完成任务 0（0 + 5 &gt;= 5）\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>tasks = [<em><strong>10</strong></em>,<em><strong>15</strong></em>,30], workers = [<em><strong>0</strong></em>,<em><strong>10</strong></em>,10,10,10], pills = 3, strength = 10\n<b>输出：</b>2\n<strong>解释：</strong>\n我们可以按照如下方案安排药丸：\n- 给 0 号和 1 号工人药丸。\n- 0 号工人完成任务 0（0 + 10 &gt;= 10）\n- 1 号工人完成任务 1（10 + 10 &gt;= 15）\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>tasks = [<em><strong>5</strong></em>,9,<em><strong>8</strong></em>,<em><strong>5</strong></em>,9], workers = [1,<em><strong>6</strong></em>,<em><strong>4</strong></em>,2,<em><strong>6</strong></em>], pills = 1, strength = 5\n<b>输出：</b>3\n<strong>解释：</strong>\n我们可以按照如下方案安排药丸：\n- 给 2 号工人药丸。\n- 1 号工人完成任务 0（6 &gt;= 5）\n- 2 号工人完成任务 2（4 + 5 &gt;= 8）\n- 4 号工人完成任务 3（6 &gt;= 5）\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == tasks.length</code></li>\n\t<li><code>m == workers.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= pills &lt;= m</code></li>\n\t<li><code>0 &lt;= tasks[i], workers[j], strength &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2072.赢得比赛的大学",
        "hardRate": "EASY",
        "passRate": "68.76%",
        "problemsUrl": "https://leetcode.cn/problems/the-winner-university/",
        "solutionsUrl": "https://leetcode.cn/problems/the-winner-university/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2073.买票需要的时间",
        "hardRate": "EASY",
        "passRate": "61.67%",
        "problemsUrl": "https://leetcode.cn/problems/time-needed-to-buy-tickets/",
        "solutionsUrl": "https://leetcode.cn/problems/time-needed-to-buy-tickets/solution",
        "problemsDesc": "<p>有 <code>n</code> 个人前来排队买票，其中第 <code>0</code> 人站在队伍 <strong>最前方</strong> ，第 <code>(n - 1)</code> 人站在队伍 <strong>最后方</strong> 。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>tickets</code> ，数组长度为 <code>n</code> ，其中第 <code>i</code> 人想要购买的票数为 <code>tickets[i]</code> 。</p>\n\n<p>每个人买票都需要用掉 <strong>恰好 1 秒</strong> 。一个人 <strong>一次只能买一张票</strong> ，如果需要购买更多票，他必须走到&nbsp; <strong>队尾</strong> 重新排队（<strong>瞬间 </strong>发生，不计时间）。如果一个人没有剩下需要买的票，那他将会 <strong>离开</strong> 队伍。</p>\n\n<p>返回位于位置 <code>k</code>（下标从 <strong>0</strong> 开始）的人完成买票需要的时间（以秒为单位）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>tickets = [2,3,2], k = 2\n<strong>输出：</strong>6\n<strong>解释：</strong> \n- 第一轮，队伍中的每个人都买到一张票，队伍变为 [1, 2, 1] 。\n- 第二轮，队伍中的每个都又都买到一张票，队伍变为 [0, 1, 0] 。\n位置 2 的人成功买到 2 张票，用掉 3 + 3 = 6 秒。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>tickets = [5,1,1,1], k = 0\n<strong>输出：</strong>8\n<strong>解释：</strong>\n- 第一轮，队伍中的每个人都买到一张票，队伍变为 [4, 0, 0, 0] 。\n- 接下来的 4 轮，只有位置 0 的人在买票。\n位置 0 的人成功买到 5 张票，用掉 4 + 1 + 1 + 1 + 1 = 8 秒。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == tickets.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= tickets[i] &lt;= 100</code></li>\n\t<li><code>0 &lt;= k &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2074.反转偶数长度组的节点",
        "hardRate": "MEDIUM",
        "passRate": "45.78%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-nodes-in-even-length-groups/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-nodes-in-even-length-groups/solution",
        "problemsDesc": "<p>给你一个链表的头节点 <code>head</code> 。</p>\n\n<p>链表中的节点 <strong>按顺序</strong> 划分成若干 <strong>非空</strong> 组，这些非空组的长度构成一个自然数序列（<code>1, 2, 3, 4, ...</code>）。一个组的 <strong>长度</strong> 就是组中分配到的节点数目。换句话说：</p>\n\n<ul>\n\t<li>节点 <code>1</code> 分配给第一组</li>\n\t<li>节点 <code>2</code> 和 <code>3</code> 分配给第二组</li>\n\t<li>节点 <code>4</code>、<code>5</code> 和 <code>6</code> 分配给第三组，以此类推</li>\n</ul>\n\n<p>注意，最后一组的长度可能小于或者等于 <code>1 + 倒数第二组的长度</code> 。</p>\n\n<p><strong>反转</strong> 每个 <strong>偶数</strong> 长度组中的节点，并返回修改后链表的头节点 <code>head</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/25/eg1.png\" style=\"width: 699px; height: 124px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [5,2,6,3,9,1,7,3,8,4]\n<strong>输出：</strong>[5,6,2,3,9,1,4,8,3,7]\n<strong>解释：</strong>\n- 第一组长度为 1 ，奇数，没有发生反转。\n- 第二组长度为 2 ，偶数，节点反转。\n- 第三组长度为 3 ，奇数，没有发生反转。\n- 最后一组长度为 4 ，偶数，节点反转。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/25/eg2.png\" style=\"width: 284px; height: 114px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,1,0,6]\n<strong>输出：</strong>[1,0,1,6]\n<strong>解释：</strong>\n- 第一组长度为 1 ，没有发生反转。\n- 第二组长度为 2 ，节点反转。\n- 最后一组长度为 1 ，没有发生反转。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/28/eg3.png\" style=\"width: 139px; height: 114px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [2,1]\n<strong>输出：</strong>[2,1]\n<strong>解释：</strong>\n- 第一组长度为 1 ，没有发生反转。\n- 最后一组长度为 1 ，没有发生反转。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点数目范围是 <code>[1, 10<sup>5</sup>]</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2075.解码斜向换位密码",
        "hardRate": "MEDIUM",
        "passRate": "47.02%",
        "problemsUrl": "https://leetcode.cn/problems/decode-the-slanted-ciphertext/",
        "solutionsUrl": "https://leetcode.cn/problems/decode-the-slanted-ciphertext/solution",
        "problemsDesc": "<p>字符串 <code>originalText</code> 使用 <strong>斜向换位密码</strong> ，经由 <strong>行数固定</strong> 为 <code>rows</code> 的矩阵辅助，加密得到一个字符串 <code>encodedText</code> 。</p>\n\n<p><code>originalText</code> 先按从左上到右下的方式放置到矩阵中。</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/07/exa11.png\" style=\"width: 300px; height: 185px;\" />\n<p>先填充蓝色单元格，接着是红色单元格，然后是黄色单元格，以此类推，直到到达 <code>originalText</code> 末尾。箭头指示顺序即为单元格填充顺序。所有空单元格用 <code>' '</code> 进行填充。矩阵的列数需满足：用 <code>originalText</code> 填充之后，最右侧列 <strong>不为空</strong> 。</p>\n\n<p>接着按行将字符附加到矩阵中，构造&nbsp;<code>encodedText</code> 。</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/07/exa12.png\" style=\"width: 300px; height: 200px;\" />\n<p>先把蓝色单元格中的字符附加到 <code>encodedText</code> 中，接着是红色单元格，最后是黄色单元格。箭头指示单元格访问顺序。</p>\n\n<p>例如，如果 <code>originalText = \"cipher\"</code> 且 <code>rows = 3</code> ，那么我们可以按下述方法将其编码：</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/25/desc2.png\" style=\"width: 281px; height: 211px;\" />\n<p>蓝色箭头标识 <code>originalText</code> 是如何放入矩阵中的，红色箭头标识形成 <code>encodedText</code> 的顺序。在上述例子中，<code>encodedText = \"ch&nbsp; &nbsp;ie&nbsp; &nbsp;pr\"</code> 。</p>\n\n<p>给你编码后的字符串 <code>encodedText</code> 和矩阵的行数 <code>rows</code> ，返回源字符串 <code>originalText</code> 。</p>\n\n<p><strong>注意：</strong><code>originalText</code> <strong>不</strong> 含任何尾随空格 <code>' '</code> 。生成的测试用例满足 <strong>仅存在一个</strong> 可能的 <code>originalText</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>encodedText = \"ch   ie   pr\", rows = 3\n<strong>输出：</strong>\"cipher\"\n<strong>解释：</strong>此示例与问题描述中的例子相同。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/26/exam1.png\" style=\"width: 250px; height: 168px;\" /></p>\n\n<pre>\n<strong>输入：</strong>encodedText = \"iveo    eed   l te   olc\", rows = 4\n<strong>输出：</strong>\"i love leetcode\"\n<strong>解释：</strong>上图标识用于编码 originalText 的矩阵。 \n蓝色箭头展示如何从 encodedText 找到 originalText 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/26/eg2.png\" style=\"width: 300px; height: 51px;\" /></p>\n\n<pre>\n<strong>输入：</strong>encodedText = \"coding\", rows = 1\n<strong>输出：</strong>\"coding\"\n<strong>解释：</strong>由于只有 1 行，所以 originalText 和 encodedText 是相同的。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/26/exam3.png\" style=\"width: 150px; height: 101px;\" />\n<pre>\n<strong>输入：</strong>encodedText = \" b  ac\", rows = 2\n<strong>输出：</strong>\" abc\"\n<strong>解释：</strong>originalText 不能含尾随空格，但它可能会有一个或者多个前置空格。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= encodedText.length &lt;= 10<sup>6</sup></code></li>\n\t<li><code>encodedText</code> 仅由小写英文字母和 <code>' '</code> 组成</li>\n\t<li><code>encodedText</code> 是对某个 <strong>不含</strong> 尾随空格的 <code>originalText</code> 的一个有效编码</li>\n\t<li><code>1 &lt;= rows &lt;= 1000</code></li>\n\t<li>生成的测试用例满足 <strong>仅存在一个</strong> 可能的 <code>originalText</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2076.处理含限制条件的好友请求",
        "hardRate": "HARD",
        "passRate": "50.96%",
        "problemsUrl": "https://leetcode.cn/problems/process-restricted-friend-requests/",
        "solutionsUrl": "https://leetcode.cn/problems/process-restricted-friend-requests/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，表示网络上的用户数目。每个用户按从 <code>0</code> 到 <code>n - 1</code> 进行编号。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>restrictions</code> ，其中 <code>restrictions[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 意味着用户 <code>x<sub>i</sub></code> 和用户 <code>y<sub>i</sub></code> <strong>不能</strong> 成为 <strong>朋友</strong> ，不管是 <strong>直接</strong> 还是通过其他用户 <strong>间接</strong> 。</p>\n\n<p>最初，用户里没有人是其他用户的朋友。给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>requests</code> 表示好友请求的列表，其中 <code>requests[j] = [u<sub>j</sub>, v<sub>j</sub>]</code> 是用户 <code>u<sub>j</sub></code> 和用户 <code>v<sub>j</sub></code> 之间的一条好友请求。</p>\n\n<p>如果 <code>u<sub>j</sub></code> 和 <code>v<sub>j</sub></code> 可以成为 <strong>朋友</strong> ，那么好友请求将会 <strong>成功</strong> 。每个好友请求都会按列表中给出的顺序进行处理（即，<code>requests[j]</code> 会在 <code>requests[j + 1]</code> 前）。一旦请求成功，那么对所有未来的好友请求而言， <code>u<sub>j</sub></code> 和 <code>v<sub>j</sub></code> 将会 <strong>成为直接朋友 。</strong></p>\n\n<p>返回一个 <strong>布尔数组</strong> <code>result</code> ，其中元素遵循此规则：如果第 <code>j</code> 个好友请求 <strong>成功</strong><em> </em>，那么 <code>result[j]</code><em> </em>就是<em> </em><code>true</code><em> </em>；否则，为<em> </em><code>false</code> 。</p>\n\n<p><strong>注意：</strong>如果 <code>u<sub>j</sub></code> 和 <code>v<sub>j</sub></code> 已经是直接朋友，那么他们之间的请求将仍然&nbsp;<strong>成功</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]]\n<strong>输出：</strong>[true,false]\n<strong>解释：\n</strong>请求 0 ：用户 0 和 用户 2 可以成为朋友，所以他们成为直接朋友。 \n请求 1 ：用户 2 和 用户 1 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (1--2--0) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]]\n<strong>输出：</strong>[true,false]\n<strong>解释：</strong>\n请求 0 ：用户 1 和 用户 2 可以成为朋友，所以他们成为直接朋友。 \n请求 1 ：用户 0 和 用户 2 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (0--2--1) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]]\n<strong>输出：</strong>[true,false,true,false]\n<strong>解释：\n</strong>请求 0 ：用户 0 和 用户 4 可以成为朋友，所以他们成为直接朋友。 \n请求 1 ：用户 1 和 用户 2 不能成为朋友，因为他们之间存在限制。\n请求 2 ：用户 3 和 用户 1 可以成为朋友，所以他们成为直接朋友。 \n请求 3 ：用户 3 和 用户 4 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (0--4--3--1) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= restrictions.length &lt;= 1000</code></li>\n\t<li><code>restrictions[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>\n\t<li><code>1 &lt;= requests.length &lt;= 1000</code></li>\n\t<li><code>requests[j].length == 2</code></li>\n\t<li><code>0 &lt;= u<sub>j</sub>, v<sub>j</sub> &lt;= n - 1</code></li>\n\t<li><code>u<sub>j</sub> != v<sub>j</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2077.殊途同归",
        "hardRate": "MEDIUM",
        "passRate": "63.34%",
        "problemsUrl": "https://leetcode.cn/problems/paths-in-maze-that-lead-to-same-room/",
        "solutionsUrl": "https://leetcode.cn/problems/paths-in-maze-that-lead-to-same-room/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2078.两栋颜色不同且距离最远的房子",
        "hardRate": "EASY",
        "passRate": "72.36%",
        "problemsUrl": "https://leetcode.cn/problems/two-furthest-houses-with-different-colors/",
        "solutionsUrl": "https://leetcode.cn/problems/two-furthest-houses-with-different-colors/solution",
        "problemsDesc": "<p>街上有 <code>n</code> 栋房子整齐地排成一列，每栋房子都粉刷上了漂亮的颜色。给你一个下标从 <strong>0</strong> 开始且长度为 <code>n</code> 的整数数组 <code>colors</code> ，其中 <code>colors[i]</code> 表示第&nbsp; <code>i</code> 栋房子的颜色。</p>\n\n<p>返回 <strong>两栋</strong> 颜色 <strong>不同</strong> 房子之间的 <strong>最大</strong> 距离。</p>\n\n<p>第 <code>i</code> 栋房子和第 <code>j</code> 栋房子之间的距离是 <code>abs(i - j)</code> ，其中 <code>abs(x)</code> 是 <code>x</code> 的绝对值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/31/eg1.png\" style=\"width: 610px; height: 84px;\" /></p>\n\n<pre>\n<strong>输入：</strong>colors = [<strong><em>1</em></strong>,1,1,<em><strong>6</strong></em>,1,1,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>上图中，颜色 1 标识成蓝色，颜色 6 标识成红色。\n两栋颜色不同且距离最远的房子是房子 0 和房子 3 。\n房子 0 的颜色是颜色 1 ，房子 3 的颜色是颜色 6 。两栋房子之间的距离是 abs(0 - 3) = 3 。\n注意，房子 3 和房子 6 也可以产生最佳答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/31/eg2.png\" style=\"width: 426px; height: 84px;\" /></p>\n\n<pre>\n<strong>输入：</strong>colors = [<em><strong>1</strong></em>,8,3,8,<em><strong>3</strong></em>]\n<strong>输出：</strong>4\n<strong>解释：</strong>上图中，颜色 1 标识成蓝色，颜色 8 标识成黄色，颜色 3 标识成绿色。\n两栋颜色不同且距离最远的房子是房子 0 和房子 4 。\n房子 0 的颜色是颜色 1 ，房子 4 的颜色是颜色 3 。两栋房子之间的距离是 abs(0 - 4) = 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>colors = [<em><strong>0</strong></em>,<em><strong>1</strong></em>]\n<strong>输出：</strong>1\n<strong>解释：</strong>两栋颜色不同且距离最远的房子是房子 0 和房子 1 。\n房子 0 的颜色是颜色 0 ，房子 1 的颜色是颜色 1 。两栋房子之间的距离是 abs(0 - 1) = 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n ==&nbsp;colors.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= colors[i] &lt;= 100</code></li>\n\t<li>生成的测试数据满足 <strong>至少 </strong>存在 2 栋颜色不同的房子</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2079.给植物浇水",
        "hardRate": "MEDIUM",
        "passRate": "77.65%",
        "problemsUrl": "https://leetcode.cn/problems/watering-plants/",
        "solutionsUrl": "https://leetcode.cn/problems/watering-plants/solution",
        "problemsDesc": "<p>你打算用一个水罐给花园里的 <code>n</code> 株植物浇水。植物排成一行，从左到右进行标记，编号从 <code>0</code> 到 <code>n - 1</code> 。其中，第 <code>i</code> 株植物的位置是 <code>x = i</code> 。<code>x = -1</code>&nbsp;处有一条河，你可以在那里重新灌满你的水罐。</p>\n\n<p>每一株植物都需要浇特定量的水。你将会按下面描述的方式完成浇水：</p>\n\n<ul>\n\t<li>按从左到右的顺序给植物浇水。</li>\n\t<li>在给当前植物浇完水之后，如果你没有足够的水 <strong>完全</strong> 浇灌下一株植物，那么你就需要返回河边重新装满水罐。</li>\n\t<li>你 <strong>不能</strong> 提前重新灌满水罐。</li>\n</ul>\n\n<p>最初，你在河边（也就是，<code>x = -1</code>），在 x 轴上每移动 <strong>一个单位</strong>&nbsp;都需要 <strong>一步</strong> 。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>plants</code> ，数组由 <code>n</code> 个整数组成。其中，<code>plants[i]</code> 为第 <code>i</code> 株植物需要的水量。另有一个整数 <code>capacity</code> 表示水罐的容量，返回浇灌所有植物需要的 <strong>步数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>plants = [2,2,3,3], capacity = 5\n<strong>输出：</strong>14\n<strong>解释：</strong>从河边开始，此时水罐是装满的：\n- 走到植物 0 (1 步) ，浇水。水罐中还有 3 单位的水。\n- 走到植物 1 (1 步) ，浇水。水罐中还有 1 单位的水。\n- 由于不能完全浇灌植物 2 ，回到河边取水 (2 步)。\n- 走到植物 2 (3 步) ，浇水。水罐中还有 2 单位的水。\n- 由于不能完全浇灌植物 3 ，回到河边取水 (3 步)。\n- 走到植物 3 (4 步) ，浇水。\n需要的步数是 = 1 + 1 + 2 + 3 + 3 + 4 = 14 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>plants = [1,1,1,4,2,3], capacity = 4\n<strong>输出：</strong>30\n<strong>解释：</strong>从河边开始，此时水罐是装满的：\n- 走到植物 0，1，2 (3 步) ，浇水。回到河边取水 (3 步)。\n- 走到植物 3 (4 步) ，浇水。回到河边取水 (4 步)。\n- 走到植物 4 (5 步) ，浇水。回到河边取水 (5 步)。\n- 走到植物 5 (6 步) ，浇水。\n需要的步数是 = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>plants = [7,7,7,7,7,7,7], capacity = 8\n<strong>输出：</strong>49\n<strong>解释：</strong>每次浇水都需要重新灌满水罐。\n需要的步数是 = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == plants.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= plants[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>max(plants[i]) &lt;= capacity &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2080.区间内查询数字的频率",
        "hardRate": "MEDIUM",
        "passRate": "31.45%",
        "problemsUrl": "https://leetcode.cn/problems/range-frequency-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/range-frequency-queries/solution",
        "problemsDesc": "<p>请你设计一个数据结构，它能求出给定子数组内一个给定值的 <strong>频率</strong>&nbsp;。</p>\n\n<p>子数组中一个值的 <strong>频率</strong>&nbsp;指的是这个子数组中这个值的出现次数。</p>\n\n<p>请你实现&nbsp;<code>RangeFreqQuery</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>RangeFreqQuery(int[] arr)</code>&nbsp;用下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>arr</code>&nbsp;构造一个类的实例。</li>\n\t<li><code>int query(int left, int right, int value)</code>&nbsp;返回子数组&nbsp;<code>arr[left...right]</code>&nbsp;中&nbsp;<code>value</code>&nbsp;的&nbsp;<strong>频率</strong>&nbsp;。</li>\n</ul>\n\n<p>一个 <strong>子数组</strong> 指的是数组中一段连续的元素。<code>arr[left...right]</code>&nbsp;指的是 <code>nums</code>&nbsp;中包含下标 <code>left</code>&nbsp;和 <code>right</code>&nbsp;<strong>在内</strong>&nbsp;的中间一段连续元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>\n[\"RangeFreqQuery\", \"query\", \"query\"]\n[[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]\n<strong>输出：</strong>\n[null, 1, 2]\n\n<strong>解释：</strong>\nRangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]);\nrangeFreqQuery.query(1, 2, 4); // 返回 1 。4 在子数组 [33, 4] 中出现 1 次。\nrangeFreqQuery.query(0, 11, 33); // 返回 2 。33 在整个子数组中出现 2 次。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i], value &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= left &lt;= right &lt; arr.length</code></li>\n\t<li>调用&nbsp;<code>query</code>&nbsp;不超过&nbsp;<code>10<sup>5</sup></code>&nbsp;次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2081.k 镜像数字的和",
        "hardRate": "HARD",
        "passRate": "43.58%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-k-mirror-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-k-mirror-numbers/solution",
        "problemsDesc": "<p>一个 <strong>k 镜像数字</strong>&nbsp;指的是一个在十进制和 k 进制下从前往后读和从后往前读都一样的&nbsp;<strong>没有前导 0</strong>&nbsp;的&nbsp;<strong>正</strong>&nbsp;整数。</p>\n\n<ul>\n\t<li>比方说，<code>9</code>&nbsp;是一个 2 镜像数字。<code>9</code>&nbsp;在十进制下为&nbsp;<code>9</code>&nbsp;，二进制下为&nbsp;<code>1001</code>&nbsp;，两者从前往后读和从后往前读都一样。</li>\n\t<li>相反地，<code>4</code>&nbsp;不是一个 2 镜像数字。<code>4</code>&nbsp;在二进制下为&nbsp;<code>100</code>&nbsp;，从前往后和从后往前读不相同。</li>\n</ul>\n\n<p>给你进制&nbsp;<code>k</code>&nbsp;和一个数字&nbsp;<code>n</code>&nbsp;，请你返回 k 镜像数字中 <strong>最小</strong> 的 <code>n</code>&nbsp;个数 <strong>之和</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre><b>输入：</b>k = 2, n = 5\n<b>输出：</b>25\n<strong>解释：\n</strong>最小的 5 个 2 镜像数字和它们的二进制表示如下：\n  十进制       二进制\n    1          1\n    3          11\n    5          101\n    7          111\n    9          1001\n它们的和为 1 + 3 + 5 + 7 + 9 = 25 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>k = 3, n = 7\n<b>输出：</b>499\n<strong>解释：\n</strong>7 个最小的 3 镜像数字和它们的三进制表示如下：\n  十进制       三进制\n    1          1\n    2          2\n    4          11\n    8          22\n    121        11111\n    151        12121\n    212        21212\n它们的和为 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>k = 7, n = 17\n<b>输出：</b>20379000\n<b>解释：</b>17 个最小的 7 镜像数字分别为：\n1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= k &lt;= 9</code></li>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2082.富有客户的数量",
        "hardRate": "EASY",
        "passRate": "74.21%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-rich-customers/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-rich-customers/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2083.求以相同字母开头和结尾的子串总数",
        "hardRate": "MEDIUM",
        "passRate": "61.18%",
        "problemsUrl": "https://leetcode.cn/problems/substrings-that-begin-and-end-with-the-same-letter/",
        "solutionsUrl": "https://leetcode.cn/problems/substrings-that-begin-and-end-with-the-same-letter/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2084.为订单类型为 0 的客户删除类型为 1 的订单",
        "hardRate": "MEDIUM",
        "passRate": "82.58%",
        "problemsUrl": "https://leetcode.cn/problems/drop-type-1-orders-for-customers-with-type-0-orders/",
        "solutionsUrl": "https://leetcode.cn/problems/drop-type-1-orders-for-customers-with-type-0-orders/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2085.统计出现过一次的公共字符串",
        "hardRate": "EASY",
        "passRate": "71.33%",
        "problemsUrl": "https://leetcode.cn/problems/count-common-words-with-one-occurrence/",
        "solutionsUrl": "https://leetcode.cn/problems/count-common-words-with-one-occurrence/solution",
        "problemsDesc": "<p>给你两个字符串数组&nbsp;<code>words1</code>&nbsp;和&nbsp;<code>words2</code>&nbsp;，请你返回在两个字符串数组中 <strong>都恰好出现一次</strong>&nbsp;的字符串的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>words1 = [\"leetcode\",\"is\",\"amazing\",\"as\",\"is\"], words2 = [\"amazing\",\"leetcode\",\"is\"]\n<b>输出：</b>2\n<strong>解释：</strong>\n- \"leetcode\" 在两个数组中都恰好出现一次，计入答案。\n- \"amazing\" 在两个数组中都恰好出现一次，计入答案。\n- \"is\" 在两个数组中都出现过，但在 words1 中出现了 2 次，不计入答案。\n- \"as\" 在 words1 中出现了一次，但是在 words2 中没有出现过，不计入答案。\n所以，有 2 个字符串在两个数组中都恰好出现了一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>words1 = [\"b\",\"bb\",\"bbb\"], words2 = [\"a\",\"aa\",\"aaa\"]\n<b>输出：</b>0\n<b>解释：</b>没有字符串在两个数组中都恰好出现一次。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>words1 = [\"a\",\"ab\"], words2 = [\"a\",\"a\",\"a\",\"ab\"]\n<b>输出：</b>1\n<b>解释：</b>唯一在两个数组中都出现一次的字符串是 \"ab\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words1.length, words2.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words1[i].length, words2[j].length &lt;= 30</code></li>\n\t<li><code>words1[i]</code> 和&nbsp;<code>words2[j]</code>&nbsp;都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2086.从房屋收集雨水需要的最少水桶数",
        "hardRate": "MEDIUM",
        "passRate": "46.79%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-food-buckets-to-feed-the-hamsters/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-food-buckets-to-feed-the-hamsters/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>street</code>&nbsp;。<code>street</code>&nbsp;中每个字符要么是表示房屋的&nbsp;<code>'H'</code> ，要么是表示空位的&nbsp;<code>'.'</code>&nbsp;。</p>\n\n<p>你可以在 <strong>空位</strong>&nbsp;放置水桶，从相邻的房屋收集雨水。位置在 <code>i - 1</code>&nbsp;<strong>或者</strong> <code>i + 1</code>&nbsp;的水桶可以收集位置为 <code>i</code>&nbsp;处房屋的雨水。一个水桶如果相邻两个位置都有房屋，那么它可以收集 <strong>两个</strong> 房屋的雨水。</p>\n\n<p>在确保 <strong>每个</strong>&nbsp;房屋旁边都 <strong>至少</strong>&nbsp;有一个水桶的前提下，请你返回需要的 <strong>最少</strong>&nbsp;水桶数。如果无解请返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>street = \"H..H\"\n<b>输出：</b>2\n<strong>解释：</strong>\n我们可以在下标为 1 和 2 处放水桶。\n\"H..H\" -&gt; \"HBBH\"（'B' 表示放置水桶）。\n下标为 0 处的房屋右边有水桶，下标为 3 处的房屋左边有水桶。\n所以每个房屋旁边都至少有一个水桶收集雨水。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>street = \".H.H.\"\n<b>输出：</b>1\n<strong>解释：</strong>\n我们可以在下标为 2 处放置一个水桶。\n\".H.H.\" -&gt; \".HBH.\"（'B' 表示放置水桶）。\n下标为 1 处的房屋右边有水桶，下标为 3 处的房屋左边有水桶。\n所以每个房屋旁边都至少有一个水桶收集雨水。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>street = \".HHH.\"\n<b>输出：</b>-1\n<strong>解释：</strong>\n没有空位可以放置水桶收集下标为 2 处的雨水。\n所以没有办法收集所有房屋的雨水。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>street = \"H\"\n<b>输出：</b>-1\n<strong>解释：</strong>\n没有空位放置水桶。\n所以没有办法收集所有房屋的雨水。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><b>输入：</b>street = \".\"\n<b>输出：</b>0\n<strong>解释：</strong>\n没有房屋需要收集雨水。\n所以需要 0 个水桶。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= street.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>street[i]</code>&nbsp;要么是&nbsp;<code>'H'</code>&nbsp;，要么是&nbsp;<code>'.'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2087.网格图中机器人回家的最小代价",
        "hardRate": "MEDIUM",
        "passRate": "50.19%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-homecoming-of-a-robot-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-homecoming-of-a-robot-in-a-grid/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的网格图，其中&nbsp;<code>(0, 0)</code>&nbsp;是最左上角的格子，<code>(m - 1, n - 1)</code>&nbsp;是最右下角的格子。给你一个整数数组&nbsp;<code>startPos</code>&nbsp;，<code>startPos = [start<sub>row</sub>, start<sub>col</sub>]</code>&nbsp;表示 <strong>初始</strong>&nbsp;有一个 <strong>机器人</strong>&nbsp;在格子&nbsp;<code>(start<sub>row</sub>, start<sub>col</sub>)</code>&nbsp;处。同时给你一个整数数组&nbsp;<code>homePos</code>&nbsp;，<code>homePos = [home<sub>row</sub>, home<sub>col</sub>]</code>&nbsp;表示机器人的 <strong>家</strong>&nbsp;在格子&nbsp;<code>(home<sub>row</sub>, home<sub>col</sub>)</code>&nbsp;处。</p>\n\n<p>机器人需要回家。每一步它可以往四个方向移动：<strong>上</strong>，<strong>下</strong>，<strong>左</strong>，<strong>右</strong>，同时机器人不能移出边界。每一步移动都有一定代价。再给你两个下标从&nbsp;<strong>0</strong>&nbsp;开始的额整数数组：长度为&nbsp;<code>m</code>&nbsp;的数组&nbsp;<code>rowCosts</code> &nbsp;和长度为 <code>n</code>&nbsp;的数组&nbsp;<code>colCosts</code>&nbsp;。</p>\n\n<ul>\n\t<li>如果机器人往 <strong>上</strong>&nbsp;或者往 <strong>下</strong>&nbsp;移动到第 <code>r</code>&nbsp;<strong>行</strong>&nbsp;的格子，那么代价为&nbsp;<code>rowCosts[r]</code>&nbsp;。</li>\n\t<li>如果机器人往 <strong>左</strong>&nbsp;或者往 <strong>右</strong>&nbsp;移动到第 <code>c</code>&nbsp;<strong>列</strong> 的格子，那么代价为&nbsp;<code>colCosts[c]</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回机器人回家需要的 <strong>最小总代价</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/11/eg-1.png\" style=\"width: 282px; height: 217px;\"></p>\n\n<pre><strong>输入：</strong>startPos = [1, 0], homePos = [2, 3], rowCosts = [5, 4, 3], colCosts = [8, 2, 6, 7]\n<b>输出：</b>18\n<b>解释：</b>一个最优路径为：\n从 (1, 0) 开始\n-&gt; 往下走到 (<em><strong>2</strong></em>, 0) 。代价为 rowCosts[2] = 3 。\n-&gt; 往右走到 (2, <em><strong>1</strong></em>) 。代价为 colCosts[1] = 2 。\n-&gt; 往右走到 (2, <em><strong>2</strong></em>) 。代价为 colCosts[2] = 6 。\n-&gt; 往右走到 (2, <em><strong>3</strong></em>) 。代价为 colCosts[3] = 7 。\n总代价为 3 + 2 + 6 + 7 = 18</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>startPos = [0, 0], homePos = [0, 0], rowCosts = [5], colCosts = [26]\n<b>输出：</b>0\n<b>解释：</b>机器人已经在家了，所以不需要移动。总代价为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == rowCosts.length</code></li>\n\t<li><code>n == colCosts.length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= rowCosts[r], colCosts[c] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>startPos.length == 2</code></li>\n\t<li><code>homePos.length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>row</sub>, home<sub>row</sub> &lt; m</code></li>\n\t<li><code>0 &lt;= start<sub>col</sub>, home<sub>col</sub> &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2088.统计农场中肥沃金字塔的数目",
        "hardRate": "HARD",
        "passRate": "63.47%",
        "problemsUrl": "https://leetcode.cn/problems/count-fertile-pyramids-in-a-land/",
        "solutionsUrl": "https://leetcode.cn/problems/count-fertile-pyramids-in-a-land/solution",
        "problemsDesc": "<p>有一个 <strong>矩形网格</strong>&nbsp;状的农场，划分为&nbsp;<code>m</code>&nbsp;行&nbsp;<code>n</code>&nbsp;列的单元格。每个格子要么是 <strong>肥沃的</strong>&nbsp;（用 <code>1</code>&nbsp;表示），要么是 <strong>贫瘠</strong>&nbsp;的（用 <code>0</code>&nbsp;表示）。网格图以外的所有与格子都视为贫瘠的。</p>\n\n<p>农场中的&nbsp;<strong>金字塔</strong>&nbsp;区域定义如下：</p>\n\n<ol>\n\t<li>区域内格子数目 <strong>大于&nbsp;</strong><code>1</code>&nbsp;且所有格子都是 <strong>肥沃的</strong>&nbsp;。</li>\n\t<li>金字塔 <strong>顶端</strong>&nbsp;是这个金字塔 <strong>最上方</strong>&nbsp;的格子。金字塔的高度是它所覆盖的行数。令&nbsp;<code>(r, c)</code>&nbsp;为金字塔的顶端且高度为 <code>h</code>&nbsp;，那么金字塔区域内包含的任一格子&nbsp;<code>(i, j)</code>&nbsp;需满足&nbsp;<code>r &lt;= i &lt;= r + h - 1</code>&nbsp;<strong>且</strong>&nbsp;<code>c - (i - r) &lt;= j &lt;= c + (i - r)</code>&nbsp;。</li>\n</ol>\n\n<p>一个 <strong>倒金字塔</strong>&nbsp;类似定义如下：</p>\n\n<ol>\n\t<li>区域内格子数目 <strong>大于</strong>&nbsp;<code>1</code>&nbsp;且所有格子都是 <b>肥沃的</b>&nbsp;。</li>\n\t<li>倒金字塔的 <strong>顶端</strong>&nbsp;是这个倒金字塔 <strong>最下方</strong>&nbsp;的格子。倒金字塔的高度是它所覆盖的行数。令&nbsp;<code>(r, c)</code>&nbsp;为金字塔的顶端且高度为 <code>h</code>&nbsp;，那么金字塔区域内包含的任一格子&nbsp;<code>(i, j)</code>&nbsp;需满足&nbsp;<code>r - h + 1 &lt;= i &lt;= r</code> <strong>且</strong> <code>c - (r - i) &lt;= j &lt;= c + (r - i)</code>&nbsp;。</li>\n</ol>\n\n<p>下图展示了部分符合定义和不符合定义的金字塔区域。黑色区域表示肥沃的格子。</p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/11/08/image.png\" style=\"width: 700px; height: 156px;\"></p>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始且大小为 <code>m x n</code>&nbsp;的二进制矩阵&nbsp;<code>grid</code>&nbsp;，它表示农场，请你返回 <code>grid</code>&nbsp;中金字塔和倒金字塔的&nbsp;<strong>总数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/eg11.png\" style=\"width: 200px; height: 102px;\">&nbsp;<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/exa12.png\" style=\"width: 200px; height: 102px;\">&nbsp;<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/exa13.png\" style=\"width: 200px; height: 102px;\"></p>\n\n<pre><b>输入：</b>grid = [[0,1,1,0],[1,1,1,1]]\n<b>输出：</b>2\n<strong>解释：</strong>\n2 个可能的金字塔区域分别如上图蓝色和红色区域所示。\n这个网格图中没有倒金字塔区域。\n所以金字塔区域总数为 2 + 0 = 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/eg21.png\" style=\"width: 180px; height: 122px;\">&nbsp;<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/exa22.png\" style=\"width: 180px; height: 122px;\">&nbsp;<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/exa23.png\" style=\"width: 180px; height: 122px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,1,1],[1,1,1]]\n<b>输出：</b>2\n<strong>解释：</strong>\n金字塔区域如上图蓝色区域所示，倒金字塔如上图红色区域所示。\n所以金字塔区域总数目为 1 + 1 = 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/eg3.png\" style=\"width: 149px; height: 150px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,0,1],[0,0,0],[1,0,1]]\n<b>输出：</b>0\n<strong>解释：</strong>\n网格图中没有任何金字塔或倒金字塔区域。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/eg41.png\" style=\"width: 180px; height: 144px;\">&nbsp;<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/eg42.png\" style=\"width: 180px; height: 144px;\">&nbsp;<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/eg43.png\" style=\"width: 180px; height: 144px;\">&nbsp;<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/eg44.png\" style=\"width: 180px; height: 144px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]]\n<b>输出：</b>13\n<strong>解释：</strong>\n有 7 个金字塔区域。上图第二和第三张图中展示了它们中的 3 个。\n有 6 个倒金字塔区域。上图中最后一张图展示了它们中的 2 个。\n所以金字塔区域总数目为 7 + 6 = 13.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>grid[i][j]</code>&nbsp;要么是&nbsp;<code>0</code>&nbsp;，要么是&nbsp;<code>1</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2089.找出数组排序后的目标下标",
        "hardRate": "EASY",
        "passRate": "78.33%",
        "problemsUrl": "https://leetcode.cn/problems/find-target-indices-after-sorting-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-target-indices-after-sorting-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 以及一个目标元素 <code>target</code> 。</p>\n\n<p><strong>目标下标</strong> 是一个满足&nbsp;<code>nums[i] == target</code> 的下标 <code>i</code> 。</p>\n\n<p>将 <code>nums</code> 按 <strong>非递减</strong> 顺序排序后，返回由 <code>nums</code> 中目标下标组成的列表。如果不存在目标下标，返回一个 <strong>空</strong> 列表。返回的列表必须按 <strong>递增</strong> 顺序排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,5,2,3], target = 2\n<strong>输出：</strong>[1,2]\n<strong>解释：</strong>排序后，nums 变为 [1,<em><strong>2</strong></em>,<em><strong>2</strong></em>,3,5] 。\n满足 nums[i] == 2 的下标是 1 和 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,5,2,3], target = 3\n<strong>输出：</strong>[3]\n<strong>解释：</strong>排序后，nums 变为 [1,2,2,<em><strong>3</strong></em>,5] 。\n满足 nums[i] == 3 的下标是 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,5,2,3], target = 5\n<strong>输出：</strong>[4]\n<strong>解释：</strong>排序后，nums 变为 [1,2,2,3,<em><strong>5</strong></em>] 。\n满足 nums[i] == 5 的下标是 4 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,5,2,3], target = 4\n<strong>输出：</strong>[]\n<strong>解释：</strong>nums 中不含值为 4 的元素。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i], target &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2090.半径为 k 的子数组平均值",
        "hardRate": "MEDIUM",
        "passRate": "37.56%",
        "problemsUrl": "https://leetcode.cn/problems/k-radius-subarray-averages/",
        "solutionsUrl": "https://leetcode.cn/problems/k-radius-subarray-averages/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，数组中有 <code>n</code> 个整数，另给你一个整数 <code>k</code> 。</p>\n\n<p><strong>半径为 k 的子数组平均值</strong> 是指：<code>nums</code> 中一个以下标 <code>i</code> 为 <strong>中心</strong> 且 <strong>半径</strong> 为 <code>k</code> 的子数组中所有元素的平均值，即下标在&nbsp;<code>i - k</code> 和 <code>i + k</code> 范围（<strong>含</strong> <code>i - k</code> 和 <code>i + k</code>）内所有元素的平均值。如果在下标 <code>i</code> 前或后不足 <code>k</code> 个元素，那么<strong> 半径为 k 的子数组平均值 </strong>是 <code>-1</code> 。</p>\n\n<p>构建并返回一个长度为 <code>n</code> 的数组<em> </em><code>avgs</code><em> </em>，其中<em> </em><code>avgs[i]</code><em> </em>是以下标 <code>i</code> 为中心的子数组的<strong> 半径为 k 的子数组平均值 </strong>。</p>\n\n<p><code>x</code> 个元素的 <strong>平均值</strong> 是 <code>x</code> 个元素相加之和除以 <code>x</code> ，此时使用截断式 <strong>整数除法</strong> ，即需要去掉结果的小数部分。</p>\n\n<ul>\n\t<li>例如，四个元素 <code>2</code>、<code>3</code>、<code>1</code> 和 <code>5</code> 的平均值是 <code>(2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75</code>，截断后得到 <code>2</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/07/eg1.png\" style=\"width: 343px; height: 119px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [7,4,3,9,1,8,5,2,6], k = 3\n<strong>输出：</strong>[-1,-1,-1,5,4,4,-1,-1,-1]\n<strong>解释：</strong>\n- avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。\n- 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。\n  使用截断式 <strong>整数除法</strong>，avg[3] = 37 / 7 = 5 。\n- 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。\n- 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。\n- avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [100000], k = 0\n<strong>输出：</strong>[100000]\n<strong>解释：</strong>\n- 中心为下标 0 且半径 0 的子数组的元素总和是：100000 。\n  avg[0] = 100000 / 1 = 100000 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [8], k = 100000\n<strong>输出：</strong>[-1]\n<strong>解释：</strong>\n- avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i], k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2091.从数组中移除最大值和最小值",
        "hardRate": "MEDIUM",
        "passRate": "56.55%",
        "problemsUrl": "https://leetcode.cn/problems/removing-minimum-and-maximum-from-array/",
        "solutionsUrl": "https://leetcode.cn/problems/removing-minimum-and-maximum-from-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，数组由若干 <strong>互不相同</strong> 的整数组成。</p>\n\n<p><code>nums</code> 中有一个值最小的元素和一个值最大的元素。分别称为 <strong>最小值</strong> 和 <strong>最大值</strong> 。你的目标是从数组中移除这两个元素。</p>\n\n<p>一次 <strong>删除</strong> 操作定义为从数组的 <strong>前面</strong> 移除一个元素或从数组的 <strong>后面</strong> 移除一个元素。</p>\n\n<p>返回将数组中最小值和最大值 <strong>都</strong> 移除需要的最小删除次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,<em><strong>10</strong></em>,7,5,4,<em><strong>1</strong></em>,8,6]\n<strong>输出：</strong>5\n<strong>解释：</strong>\n数组中的最小元素是 nums[5] ，值为 1 。\n数组中的最大元素是 nums[1] ，值为 10 。\n将最大值和最小值都移除需要从数组前面移除 2 个元素，从数组后面移除 3 个元素。\n结果是 2 + 3 = 5 ，这是所有可能情况中的最小删除次数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,<em><strong>-4</strong></em>,<em><strong>19</strong></em>,1,8,-2,-3,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n数组中的最小元素是 nums[1] ，值为 -4 。\n数组中的最大元素是 nums[2] ，值为 19 。\n将最大值和最小值都移除需要从数组前面移除 3 个元素。\n结果是 3 ，这是所有可能情况中的最小删除次数。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<em><strong>101</strong></em>]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n数组中只有这一个元素，那么它既是数组中的最小值又是数组中的最大值。\n移除它只需要 1 次删除操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums</code> 中的整数 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2092.找出知晓秘密的所有专家",
        "hardRate": "HARD",
        "passRate": "29.04%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-people-with-secret/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-people-with-secret/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，表示有 <code>n</code> 个专家从 <code>0</code> 到 <code>n - 1</code> 编号。另外给你一个下标从 0 开始的二维整数数组 <code>meetings</code> ，其中 <code>meetings[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>]</code> 表示专家 <code>x<sub>i</sub></code> 和专家 <code>y<sub>i</sub></code> 在时间 <code>time<sub>i</sub></code> 要开一场会。一个专家可以同时参加 <strong>多场会议</strong> 。最后，给你一个整数 <code>firstPerson</code> 。</p>\n\n<p>专家 <code>0</code> 有一个 <strong>秘密</strong> ，最初，他在时间&nbsp;<code>0</code> 将这个秘密分享给了专家 <code>firstPerson</code> 。接着，这个秘密会在每次有知晓这个秘密的专家参加会议时进行传播。更正式的表达是，每次会议，如果专家 <code>x<sub>i</sub></code> 在时间 <code>time<sub>i</sub></code> 时知晓这个秘密，那么他将会与专家 <code>y<sub>i</sub></code> 分享这个秘密，反之亦然。</p>\n\n<p>秘密共享是 <strong>瞬时发生</strong> 的。也就是说，在同一时间，一个专家不光可以接收到秘密，还能在其他会议上与其他专家分享。</p>\n\n<p>在所有会议都结束之后，返回所有知晓这个秘密的专家列表。你可以按 <strong>任何顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1\n<strong>输出：</strong>[0,1,2,3,5]\n<strong>解释：\n</strong>时间 0 ，专家 0 将秘密与专家 1 共享。\n时间 5 ，专家 1 将秘密与专家 2 共享。\n时间 8 ，专家 2 将秘密与专家 3 共享。\n时间 10 ，专家 1 将秘密与专家 5 共享。\n因此，在所有会议结束后，专家 0、1、2、3 和 5 都将知晓这个秘密。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3\n<strong>输出：</strong>[0,1,3]\n<strong>解释：</strong>\n时间 0 ，专家 0 将秘密与专家 3 共享。\n时间 2 ，专家 1 与专家 2 都不知晓这个秘密。\n时间 3 ，专家 3 将秘密与专家 0 和专家 1 共享。\n因此，在所有会议结束后，专家 0、1 和 3 都将知晓这个秘密。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1\n<strong>输出：</strong>[0,1,2,3,4]\n<strong>解释：</strong>\n时间 0 ，专家 0 将秘密与专家 1 共享。\n时间 1 ，专家 1 将秘密与专家 2 共享，专家 2 将秘密与专家 3 共享。\n注意，专家 2 可以在收到秘密的同一时间分享此秘密。\n时间 2 ，专家 3 将秘密与专家 4 共享。\n因此，在所有会议结束后，专家 0、1、2、3 和 4 都将知晓这个秘密。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= meetings.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>meetings[i].length == 3</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i </sub>&lt;= n - 1</code></li>\n\t<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>\n\t<li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= firstPerson &lt;= n - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2093.前往目标城市的最小费用",
        "hardRate": "MEDIUM",
        "passRate": "58.85%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-reach-city-with-discounts/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-reach-city-with-discounts/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2094.找出 3 位偶数",
        "hardRate": "EASY",
        "passRate": "55.71%",
        "problemsUrl": "https://leetcode.cn/problems/finding-3-digit-even-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/finding-3-digit-even-numbers/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>digits</code> ，其中每个元素是一个数字（<code>0 - 9</code>）。数组中可能存在重复元素。</p>\n\n<p>你需要找出 <strong>所有</strong> 满足下述条件且 <strong>互不相同</strong> 的整数：</p>\n\n<ul>\n\t<li>该整数由 <code>digits</code> 中的三个元素按 <strong>任意</strong> 顺序 <strong>依次连接</strong> 组成。</li>\n\t<li>该整数不含 <strong>前导零</strong></li>\n\t<li>该整数是一个 <strong>偶数</strong></li>\n</ul>\n\n<p>例如，给定的 <code>digits</code> 是 <code>[1, 2, 3]</code> ，整数 <code>132</code> 和 <code>312</code> 满足上面列出的全部条件。</p>\n\n<p>将找出的所有互不相同的整数按 <strong>递增顺序</strong> 排列，并以数组形式返回<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = [2,1,3,0]\n<strong>输出：</strong>[102,120,130,132,210,230,302,310,312,320]\n<strong>解释：</strong>\n所有满足题目条件的整数都在输出数组中列出。 \n注意，答案数组中不含有 <strong>奇数</strong> 或带 <strong>前导零</strong> 的整数。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = [2,2,8,8,2]\n<strong>输出：</strong>[222,228,282,288,822,828,882]\n<strong>解释：</strong>\n同样的数字（0 - 9）在构造整数时可以重复多次，重复次数最多与其在 <code>digits</code> 中出现的次数一样。 \n在这个例子中，数字 8 在构造 288、828 和 882 时都重复了两次。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = [3,7,5]\n<strong>输出：</strong>[]\n<strong>解释：</strong>\n使用给定的 digits 无法构造偶数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;=&nbsp;digits.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= digits[i] &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2095.删除链表的中间节点",
        "hardRate": "MEDIUM",
        "passRate": "57.29%",
        "problemsUrl": "https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/solution",
        "problemsDesc": "<p>给你一个链表的头节点 <code>head</code> 。<strong>删除</strong> 链表的 <strong>中间节点</strong> ，并返回修改后的链表的头节点 <code>head</code> 。</p>\n\n<p>长度为 <code>n</code> 链表的中间节点是从头数起第 <code>⌊n / 2⌋</code> 个节点（下标从 <strong>0</strong> 开始），其中 <code>⌊x⌋</code> 表示小于或等于 <code>x</code> 的最大整数。</p>\n\n<ul>\n\t<li>对于 <code>n</code> = <code>1</code>、<code>2</code>、<code>3</code>、<code>4</code> 和 <code>5</code> 的情况，中间节点的下标分别是 <code>0</code>、<code>1</code>、<code>1</code>、<code>2</code> 和 <code>2</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/16/eg1drawio.png\" style=\"width: 500px; height: 77px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,3,4,7,1,2,6]\n<strong>输出：</strong>[1,3,4,1,2,6]\n<strong>解释：</strong>\n上图表示给出的链表。节点的下标分别标注在每个节点的下方。\n由于 n = 7 ，值为 7 的节点 3 是中间节点，用红色标注。\n返回结果为移除节点后的新链表。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/16/eg2drawio.png\" style=\"width: 250px; height: 43px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,3,4]\n<strong>输出：</strong>[1,2,4]\n<strong>解释：</strong>\n上图表示给出的链表。\n对于 n = 4 ，值为 3 的节点 2 是中间节点，用红色标注。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/16/eg3drawio.png\" style=\"width: 150px; height: 58px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [2,1]\n<strong>输出：</strong>[2]\n<strong>解释：</strong>\n上图表示给出的链表。\n对于 n = 2 ，值为 1 的节点 1 是中间节点，用红色标注。\n值为 2 的节点 0 是移除节点 1 后剩下的唯一一个节点。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2096.从二叉树一个节点到另一个节点每一步的方向",
        "hardRate": "MEDIUM",
        "passRate": "44.59%",
        "problemsUrl": "https://leetcode.cn/problems/step-by-step-directions-from-a-binary-tree-node-to-another/",
        "solutionsUrl": "https://leetcode.cn/problems/step-by-step-directions-from-a-binary-tree-node-to-another/solution",
        "problemsDesc": "<p>给你一棵 <strong>二叉树</strong>&nbsp;的根节点&nbsp;<code>root</code>&nbsp;，这棵二叉树总共有&nbsp;<code>n</code>&nbsp;个节点。每个节点的值为&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;中的一个整数，且互不相同。给你一个整数&nbsp;<code>startValue</code>&nbsp;，表示起点节点 <code>s</code>&nbsp;的值，和另一个不同的整数&nbsp;<code>destValue</code>&nbsp;，表示终点节点&nbsp;<code>t</code>&nbsp;的值。</p>\n\n<p>请找到从节点&nbsp;<code>s</code>&nbsp;到节点 <code>t</code>&nbsp;的 <strong>最短路径</strong>&nbsp;，并以字符串的形式返回每一步的方向。每一步用 <strong>大写</strong>&nbsp;字母&nbsp;<code>'L'</code>&nbsp;，<code>'R'</code>&nbsp;和&nbsp;<code>'U'</code>&nbsp;分别表示一种方向：</p>\n\n<ul>\n\t<li><code>'L'</code>&nbsp;表示从一个节点前往它的 <strong>左孩子</strong>&nbsp;节点。</li>\n\t<li><code>'R'</code>&nbsp;表示从一个节点前往它的 <strong>右孩子</strong>&nbsp;节点。</li>\n\t<li><code>'U'</code>&nbsp;表示从一个节点前往它的 <strong>父</strong>&nbsp;节点。</li>\n</ul>\n\n<p>请你返回从 <code>s</code>&nbsp;到 <code>t</code>&nbsp;<strong>最短路径</strong>&nbsp;每一步的方向。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/15/eg1.png\" style=\"width: 214px; height: 163px;\"></p>\n\n<pre><b>输入：</b>root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6\n<b>输出：</b>\"UURL\"\n<b>解释：</b>最短路径为：3 → 1 → 5 → 2 → 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/15/eg2.png\" style=\"width: 74px; height: 102px;\"></p>\n\n<pre><b>输入：</b>root = [2,1], startValue = 2, destValue = 1\n<b>输出：</b>\"L\"\n<b>解释：</b>最短路径为：2 → 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目为&nbsp;<code>n</code>&nbsp;。</li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= Node.val &lt;= n</code></li>\n\t<li>树中所有节点的值 <strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>1 &lt;= startValue, destValue &lt;= n</code></li>\n\t<li><code>startValue != destValue</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2097.合法重新排列数对",
        "hardRate": "HARD",
        "passRate": "37.97%",
        "problemsUrl": "https://leetcode.cn/problems/valid-arrangement-of-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-arrangement-of-pairs/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>pairs</code>&nbsp;，其中&nbsp;<code>pairs[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>&nbsp;。如果 <code>pairs</code>&nbsp;的一个重新排列，满足对每一个下标 <code>i</code> （&nbsp;<code>1 &lt;= i &lt; pairs.length</code>&nbsp;）都有&nbsp;<code>end<sub>i-1</sub> == start<sub>i</sub></code><sub> </sub>，那么我们就认为这个重新排列是&nbsp;<code>pairs</code> 的一个 <strong>合法重新排列</strong> 。</p>\n\n<p>请你返回 <strong>任意一个</strong>&nbsp;<code>pairs</code> 的合法重新排列。</p>\n\n<p><b>注意：</b>数据保证至少存在一个 <code>pairs</code>&nbsp;的合法重新排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>pairs = [[5,1],[4,5],[11,9],[9,4]]\n<b>输出：</b>[[11,9],[9,4],[4,5],[5,1]]\n<strong>解释：\n</strong>输出的是一个合法重新排列，因为每一个 end<sub>i-1</sub> 都等于 start<sub>i</sub>&nbsp;。\nend<sub>0</sub> = 9 == 9 = start<sub>1</sub> \nend<sub>1</sub> = 4 == 4 = start<sub>2</sub>\nend<sub>2</sub> = 5 == 5 = start<sub>3</sub>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>pairs = [[1,3],[3,2],[2,1]]\n<b>输出：</b>[[1,3],[3,2],[2,1]]\n<strong>解释：</strong>\n输出的是一个合法重新排列，因为每一个 end<sub>i-1</sub> 都等于 start<sub>i</sub>&nbsp;。\nend<sub>0</sub> = 3 == 3 = start<sub>1</sub>\nend<sub>1</sub> = 2 == 2 = start<sub>2</sub>\n重新排列后的数组 [[2,1],[1,3],[3,2]] 和 [[3,2],[2,1],[1,3]] 都是合法的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>pairs = [[1,2],[1,3],[2,1]]\n<b>输出：</b>[[1,2],[2,1],[1,3]]\n<strong>解释：</strong>\n输出的是一个合法重新排列，因为每一个 end<sub>i-1</sub> 都等于 start<sub>i</sub>&nbsp;。\nend<sub>0</sub> = 2 == 2 = start<sub>1</sub>\nend<sub>1</sub> = 1 == 1 = start<sub>2</sub>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pairs.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pairs[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub>, end<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>start<sub>i</sub> != end<sub>i</sub></code></li>\n\t<li><code>pairs</code>&nbsp;中不存在一模一样的数对。</li>\n\t<li>至少 <strong>存在</strong> 一个合法的&nbsp;<code>pairs</code>&nbsp;重新排列。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2098.长度为 K 的最大偶数和子序列",
        "hardRate": "MEDIUM",
        "passRate": "35.44%",
        "problemsUrl": "https://leetcode.cn/problems/subsequence-of-size-k-with-the-largest-even-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/subsequence-of-size-k-with-the-largest-even-sum/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2099.找到和最大的长度为 K 的子序列",
        "hardRate": "EASY",
        "passRate": "48.30%",
        "problemsUrl": "https://leetcode.cn/problems/find-subsequence-of-length-k-with-the-largest-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/find-subsequence-of-length-k-with-the-largest-sum/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。你需要找到&nbsp;<code>nums</code>&nbsp;中长度为 <code>k</code>&nbsp;的 <strong>子序列</strong>&nbsp;，且这个子序列的&nbsp;<strong>和最大&nbsp;</strong>。</p>\n\n<p>请你返回 <strong>任意</strong> 一个长度为&nbsp;<code>k</code>&nbsp;的整数子序列。</p>\n\n<p><strong>子序列</strong>&nbsp;定义为从一个数组里删除一些元素后，不改变剩下元素的顺序得到的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,1,3,3], k = 2\n<b>输出：</b>[3,3]\n<strong>解释：</strong>\n子序列有最大和：3 + 3 = 6 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [-1,-2,3,4], k = 3\n<b>输出：</b>[-1,3,4]\n<b>解释：</b>\n子序列有最大和：-1 + 3 + 4 = 6 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [3,4,3,3], k = 2\n<b>输出：</b>[3,4]\n<strong>解释：</strong>\n子序列有最大和：3 + 4 = 7 。\n另一个可行的子序列为 [4, 3] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2100.适合打劫银行的日子",
        "hardRate": "MEDIUM",
        "passRate": "48.69%",
        "problemsUrl": "https://leetcode.cn/problems/find-good-days-to-rob-the-bank/",
        "solutionsUrl": "https://leetcode.cn/problems/find-good-days-to-rob-the-bank/solution",
        "problemsDesc": "<p>你和一群强盗准备打劫银行。给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>security</code>&nbsp;，其中&nbsp;<code>security[i]</code>&nbsp;是第 <code>i</code>&nbsp;天执勤警卫的数量。日子从 <code>0</code>&nbsp;开始编号。同时给你一个整数&nbsp;<code>time</code>&nbsp;。</p>\n\n<p>如果第 <code>i</code>&nbsp;天满足以下所有条件，我们称它为一个适合打劫银行的日子：</p>\n\n<ul>\n\t<li>第 <code>i</code>&nbsp;天前和后都分别至少有 <code>time</code>&nbsp;天。</li>\n\t<li>第 <code>i</code>&nbsp;天前连续 <code>time</code>&nbsp;天警卫数目都是非递增的。</li>\n\t<li>第 <code>i</code>&nbsp;天后连续 <code>time</code>&nbsp;天警卫数目都是非递减的。</li>\n</ul>\n\n<p>更正式的，第 <code>i</code> 天是一个合适打劫银行的日子当且仅当：<code>security[i - time] &gt;= security[i - time + 1] &gt;= ... &gt;= security[i] &lt;= ... &lt;= security[i + time - 1] &lt;= security[i + time]</code>.</p>\n\n<p>请你返回一个数组，包含 <strong>所有</strong> 适合打劫银行的日子（下标从 <strong>0</strong>&nbsp;开始）。返回的日子可以 <strong>任意</strong>&nbsp;顺序排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>security = [5,3,3,3,5,6,2], time = 2\n<b>输出：</b>[2,3]\n<strong>解释：</strong>\n第 2 天，我们有 security[0] &gt;= security[1] &gt;= security[2] &lt;= security[3] &lt;= security[4] 。\n第 3 天，我们有 security[1] &gt;= security[2] &gt;= security[3] &lt;= security[4] &lt;= security[5] 。\n没有其他日子符合这个条件，所以日子 2 和 3 是适合打劫银行的日子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>security = [1,1,1,1,1], time = 0\n<b>输出：</b>[0,1,2,3,4]\n<strong>解释：</strong>\n因为 time 等于 0 ，所以每一天都是适合打劫银行的日子，所以返回每一天。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>security = [1,2,3,4,5,6], time = 2\n<b>输出：</b>[]\n<strong>解释：</strong>\n没有任何一天的前 2 天警卫数目是非递增的。\n所以没有适合打劫银行的日子，返回空数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= security.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= security[i], time &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    }
]