[
    {
        "problemsName": " 1851.包含每个查询的最小区间",
        "hardRate": "HARD",
        "passRate": "44.19%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-interval-to-include-each-query/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-interval-to-include-each-query/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>intervals</code> ，其中 <code>intervals[i] = [left<sub>i</sub>, right<sub>i</sub>]</code> 表示第 <code>i</code> 个区间开始于 <code>left<sub>i</sub></code> 、结束于 <code>right<sub>i</sub></code>（包含两侧取值，<strong>闭区间</strong>）。区间的 <strong>长度</strong> 定义为区间中包含的整数数目，更正式地表达是 <code>right<sub>i</sub> - left<sub>i</sub> + 1</code> 。</p>\n\n<p>再给你一个整数数组 <code>queries</code> 。第 <code>j</code> 个查询的答案是满足 <code>left<sub>i</sub> <= queries[j] <= right<sub>i</sub></code> 的 <strong>长度最小区间 <code>i</code> 的长度</strong> 。如果不存在这样的区间，那么答案是 <code>-1</code> 。</p>\n\n<p>以数组形式返回对应查询的所有答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]\n<strong>输出：</strong>[3,3,1,4]\n<strong>解释：</strong>查询处理如下：\n- Query = 2 ：区间 [2,4] 是包含 2 的最小区间，答案为 4 - 2 + 1 = 3 。\n- Query = 3 ：区间 [2,4] 是包含 3 的最小区间，答案为 4 - 2 + 1 = 3 。\n- Query = 4 ：区间 [4,4] 是包含 4 的最小区间，答案为 4 - 4 + 1 = 1 。\n- Query = 5 ：区间 [3,6] 是包含 5 的最小区间，答案为 6 - 3 + 1 = 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]\n<strong>输出：</strong>[2,-1,4,6]\n<strong>解释：</strong>查询处理如下：\n- Query = 2 ：区间 [2,3] 是包含 2 的最小区间，答案为 3 - 2 + 1 = 2 。\n- Query = 19：不存在包含 19 的区间，答案为 -1 。\n- Query = 5 ：区间 [2,5] 是包含 5 的最小区间，答案为 5 - 2 + 1 = 4 。\n- Query = 22：区间 [20,25] 是包含 22 的最小区间，答案为 25 - 20 + 1 = 6 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= intervals.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= queries.length <= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>1 <= left<sub>i</sub> <= right<sub>i</sub> <= 10<sup>7</sup></code></li>\n\t<li><code>1 <= queries[j] <= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1852.每个子数组的数字种类数",
        "hardRate": "MEDIUM",
        "passRate": "59.61%",
        "problemsUrl": "https://leetcode.cn/problems/distinct-numbers-in-each-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/distinct-numbers-in-each-subarray/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1853.转换日期格式",
        "hardRate": "EASY",
        "passRate": "62.79%",
        "problemsUrl": "https://leetcode.cn/problems/convert-date-format/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-date-format/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1854.人口最多的年份",
        "hardRate": "EASY",
        "passRate": "72.34%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-population-year/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-population-year/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>logs</code> ，其中每个 <code>logs[i] = [birth<sub>i</sub>, death<sub>i</sub>]</code> 表示第 <code>i</code> 个人的出生和死亡年份。</p>\n\n<p>年份 <code>x</code> 的 <strong>人口</strong> 定义为这一年期间活着的人的数目。第 <code>i</code> 个人被计入年份 <code>x</code> 的人口需要满足：<code>x</code> 在闭区间 <code>[birth<sub>i</sub>, death<sub>i</sub> - 1]</code> 内。注意，人不应当计入他们死亡当年的人口中。</p>\n\n<p>返回 <strong>人口最多</strong> 且 <strong>最早</strong> 的年份。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>logs = [[1993,1999],[2000,2010]]\n<strong>输出：</strong>1993\n<strong>解释：</strong>人口最多为 1 ，而 1993 是人口为 1 的最早年份。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>logs = [[1950,1961],[1960,1971],[1970,1981]]\n<strong>输出：</strong>1960\n<strong>解释：</strong> \n人口最多为 2 ，分别出现在 1960 和 1970 。\n其中最早年份是 1960 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= logs.length &lt;= 100</code></li>\n\t<li><code>1950 &lt;= birth<sub>i</sub> &lt; death<sub>i</sub> &lt;= 2050</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1855.下标对中的最大距离",
        "hardRate": "MEDIUM",
        "passRate": "59.39%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-distance-between-a-pair-of-values/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-distance-between-a-pair-of-values/solution",
        "problemsDesc": "<p>给你两个 <strong>非递增</strong> 的整数数组 <code>nums1</code>​​​​​​ 和 <code>nums2</code>​​​​​​ ，数组下标均 <strong>从 0 开始</strong> 计数。</p>\n\n<p>下标对 <code>(i, j)</code> 中 <code>0 &lt;= i &lt; nums1.length</code> 且 <code>0 &lt;= j &lt; nums2.length</code> 。如果该下标对同时满足 <code>i &lt;= j</code> 且 <code>nums1[i] &lt;= nums2[j]</code> ，则称之为 <strong>有效</strong> 下标对，该下标对的 <strong>距离</strong> 为 <code>j - i</code>​​ 。​​</p>\n\n<p>返回所有 <strong>有效</strong> 下标对<em> </em><code>(i, j)</code><em> </em>中的 <strong>最大距离</strong> 。如果不存在有效下标对，返回 <code>0</code> 。</p>\n\n<p>一个数组 <code>arr</code> ，如果每个 <code>1 &lt;= i &lt; arr.length</code> 均有 <code>arr[i-1] &gt;= arr[i]</code> 成立，那么该数组是一个 <strong>非递增</strong> 数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [55,30,5,4,2], nums2 = [100,20,10,10,5]\n<strong>输出：</strong>2\n<strong>解释：</strong>有效下标对是 (0,0), (2,2), (2,3), (2,4), (3,3), (3,4) 和 (4,4) 。\n最大距离是 2 ，对应下标对 (2,4) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [2,2,2], nums2 = [10,10,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>有效下标对是 (0,0), (0,1) 和 (1,1) 。\n最大距离是 1 ，对应下标对 (0,1) 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [30,29,19,5], nums2 = [25,25,25,25,25]\n<strong>输出：</strong>2\n<strong>解释：</strong>有效下标对是 (2,2), (2,3), (2,4), (3,3) 和 (3,4) 。\n最大距离是 2 ，对应下标对 (2,4) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums1</code> 和 <code>nums2</code> 都是 <strong>非递增</strong> 数组</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1856.子数组最小乘积的最大值",
        "hardRate": "MEDIUM",
        "passRate": "37.55%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-subarray-min-product/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-subarray-min-product/solution",
        "problemsDesc": "<p>一个数组的 <strong>最小乘积</strong> 定义为这个数组中 <strong>最小值</strong> <strong>乘以 </strong>数组的 <strong>和</strong> 。</p>\n\n<ul>\n\t<li>比方说，数组 <code>[3,2,5]</code> （最小值是 <code>2</code>）的最小乘积为 <code>2 * (3+2+5) = 2 * 10 = 20</code> 。</li>\n</ul>\n\n<p>给你一个正整数数组 <code>nums</code> ，请你返回 <code>nums</code> 任意 <strong>非空子数组</strong> 的<strong>最小乘积</strong> 的 <strong>最大值</strong> 。由于答案可能很大，请你返回答案对  <code>10<sup>9</sup> + 7</code> <strong>取余 </strong>的结果。</p>\n\n<p>请注意，最小乘积的最大值考虑的是取余操作 <strong>之前</strong> 的结果。题目保证最小乘积的最大值在 <strong>不取余</strong> 的情况下可以用 <strong>64 位有符号整数</strong> 保存。</p>\n\n<p><strong>子数组</strong> 定义为一个数组的 <strong>连续</strong> 部分。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,<strong>2,3,2</strong>]\n<b>输出：</b>14\n<b>解释：</b>最小乘积的最大值由子数组 [2,3,2] （最小值是 2）得到。\n2 * (2+3+2) = 2 * 7 = 14 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,<strong>3,3</strong>,1,2]\n<b>输出：</b>18\n<b>解释：</b>最小乘积的最大值由子数组 [3,3] （最小值是 3）得到。\n3 * (3+3) = 3 * 6 = 18 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,1,<strong>5,6,4</strong>,2]\n<b>输出：</b>60\n<b>解释：</b>最小乘积的最大值由子数组 [5,6,4] （最小值是 4）得到。\n4 * (5+6+4) = 4 * 15 = 60 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1857.有向图中最大颜色值",
        "hardRate": "HARD",
        "passRate": "49.09%",
        "problemsUrl": "https://leetcode.cn/problems/largest-color-value-in-a-directed-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-color-value-in-a-directed-graph/solution",
        "problemsDesc": "<p>给你一个 <strong>有向图</strong> ，它含有 <code>n</code> 个节点和 <code>m</code> 条边。节点编号从 <code>0</code> 到 <code>n - 1</code> 。</p>\n\n<p>给你一个字符串 <code>colors</code> ，其中 <code>colors[i]</code> 是小写英文字母，表示图中第 <code>i</code> 个节点的 <b>颜色</b> （下标从 <strong>0</strong> 开始）。同时给你一个二维数组 <code>edges</code> ，其中 <code>edges[j] = [a<sub>j</sub>, b<sub>j</sub>]</code> 表示从节点 <code>a<sub>j</sub></code> 到节点 <code>b<sub>j</sub></code><sub> </sub>有一条 <strong>有向边</strong> 。</p>\n\n<p>图中一条有效 <strong>路径</strong> 是一个点序列 <code>x<sub>1</sub> -&gt; x<sub>2</sub> -&gt; x<sub>3</sub> -&gt; ... -&gt; x<sub>k</sub></code> ，对于所有 <code>1 &lt;= i &lt; k</code> ，从 <code>x<sub>i</sub></code> 到 <code>x<sub>i+1</sub></code> 在图中有一条有向边。路径的 <strong>颜色值</strong> 是路径中 <strong>出现次数最多</strong> 颜色的节点数目。</p>\n\n<p>请你返回给定图中有效路径里面的 <strong>最大颜色值</strong><strong> 。</strong>如果图中含有环，请返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/21/leet1.png\" style=\"width: 400px; height: 182px;\"></p>\n\n<pre><b>输入：</b>colors = \"abaca\", edges = [[0,1],[0,2],[2,3],[3,4]]\n<b>输出：</b>3\n<b>解释：</b>路径 0 -&gt; 2 -&gt; 3 -&gt; 4 含有 3 个颜色为 <code>\"a\" 的节点（上图中的红色节点）。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/21/leet2.png\" style=\"width: 85px; height: 85px;\"></p>\n\n<pre><b>输入：</b>colors = \"a\", edges = [[0,0]]\n<b>输出：</b>-1\n<b>解释：</b>从 0 到 0 有一个环。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == colors.length</code></li>\n\t<li><code>m == edges.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>colors</code> 只含有小写英文字母。</li>\n\t<li><code>0 &lt;= a<sub>j</sub>, b<sub>j</sub> &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1858.包含所有前缀的最长单词",
        "hardRate": "MEDIUM",
        "passRate": "66.85%",
        "problemsUrl": "https://leetcode.cn/problems/longest-word-with-all-prefixes/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-word-with-all-prefixes/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1859.将句子排序",
        "hardRate": "EASY",
        "passRate": "72.86%",
        "problemsUrl": "https://leetcode.cn/problems/sorting-the-sentence/",
        "solutionsUrl": "https://leetcode.cn/problems/sorting-the-sentence/solution",
        "problemsDesc": "<p>一个 <strong>句子</strong> 指的是一个序列的单词用单个空格连接起来，且开头和结尾没有任何空格。每个单词都只包含小写或大写英文字母。</p>\n\n<p>我们可以给一个句子添加 <strong>从 1 开始的单词位置索引 </strong>，并且将句子中所有单词 <strong>打乱顺序</strong> 。</p>\n\n<ul>\n\t<li>比方说，句子 <code>\"This is a sentence\"</code> 可以被打乱顺序得到 <code>\"sentence4 a3 is2 This1\"</code> 或者 <code>\"is2 sentence4 This1 a3\"</code> 。</li>\n</ul>\n\n<p>给你一个 <strong>打乱顺序</strong> 的句子 <code>s</code> ，它包含的单词不超过 <code>9</code> 个，请你重新构造并得到原本顺序的句子。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"is2 sentence4 This1 a3\"\n<b>输出：</b>\"This is a sentence\"\n<b>解释：</b>将 s 中的单词按照初始位置排序，得到 \"This1 is2 a3 sentence4\" ，然后删除数字。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"Myself2 Me1 I4 and3\"\n<b>输出：</b>\"Me Myself and I\"\n<b>解释：</b>将 s 中的单词按照初始位置排序，得到 \"Me1 Myself2 and3 I4\" ，然后删除数字。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= s.length <= 200</code></li>\n\t<li><code>s</code> 只包含小写和大写英文字母、空格以及从 <code>1</code> 到 <code>9</code> 的数字。</li>\n\t<li><code>s</code> 中单词数目为 <code>1</code> 到 <code>9</code> 个。</li>\n\t<li><code>s</code> 中的单词由单个空格分隔。</li>\n\t<li><code>s</code> 不包含任何前导或者后缀空格。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1860.增长的内存泄露",
        "hardRate": "MEDIUM",
        "passRate": "75.99%",
        "problemsUrl": "https://leetcode.cn/problems/incremental-memory-leak/",
        "solutionsUrl": "https://leetcode.cn/problems/incremental-memory-leak/solution",
        "problemsDesc": "<p>给你两个整数 <code>memory1</code> 和 <code>memory2</code> 分别表示两个内存条剩余可用内存的位数。现在有一个程序每秒递增的速度消耗着内存。</p>\n\n<p>在第 <code>i</code> 秒（秒数从 1 开始），有 <code>i</code> 位内存被分配到 <strong>剩余内存较多</strong> 的内存条（如果两者一样多，则分配到第一个内存条）。如果两者剩余内存都不足 <code>i</code> 位，那么程序将 <b>意外退出</b> 。</p>\n\n<p>请你返回一个数组，包含<em> </em><code>[crashTime, memory1<sub>crash</sub>, memory2<sub>crash</sub>]</code> ，其中 <code>crashTime</code>是程序意外退出的时间（单位为秒），<em> </em><code>memory1<sub>crash</sub></code><em> </em>和<em> </em><code>memory2<sub>crash</sub></code><em> </em>分别是两个内存条最后剩余内存的位数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>memory1 = 2, memory2 = 2\n<b>输出：</b>[3,1,0]\n<b>解释：</b>内存分配如下：\n- 第 1 秒，内存条 1 被占用 1 位内存。内存条 1 现在有 1 位剩余可用内存。\n- 第 2 秒，内存条 2 被占用 2 位内存。内存条 2 现在有 0 位剩余可用内存。\n- 第 3 秒，程序意外退出，两个内存条分别有 1 位和 0 位剩余可用内存。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>memory1 = 8, memory2 = 11\n<b>输出：</b>[6,0,4]\n<b>解释：</b>内存分配如下：\n- 第 1 秒，内存条 2 被占用 1 位内存，内存条 2 现在有 10 位剩余可用内存。\n- 第 2 秒，内存条 2 被占用 2 位内存，内存条 2 现在有 8 位剩余可用内存。\n- 第 3 秒，内存条 1 被占用 3 位内存，内存条 1 现在有 5 位剩余可用内存。\n- 第 4 秒，内存条 2 被占用 4 位内存，内存条 2 现在有 4 位剩余可用内存。\n- 第 5 秒，内存条 1 被占用 5 位内存，内存条 1 现在有 0 位剩余可用内存。\n- 第 6 秒，程序意外退出，两个内存条分别有 0 位和 4 位剩余可用内存。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= memory1, memory2 &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1861.旋转盒子",
        "hardRate": "MEDIUM",
        "passRate": "63.31%",
        "problemsUrl": "https://leetcode.cn/problems/rotating-the-box/",
        "solutionsUrl": "https://leetcode.cn/problems/rotating-the-box/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的字符矩阵 <code>box</code> ，它表示一个箱子的侧视图。箱子的每一个格子可能为：</p>\n\n<ul>\n\t<li><code>'#'</code> 表示石头</li>\n\t<li><code>'*'</code> 表示固定的障碍物</li>\n\t<li><code>'.'</code> 表示空位置</li>\n</ul>\n\n<p>这个箱子被 <strong>顺时针旋转 90 度</strong> ，由于重力原因，部分石头的位置会发生改变。每个石头会垂直掉落，直到它遇到障碍物，另一个石头或者箱子的底部。重力 <strong>不会</strong> 影响障碍物的位置，同时箱子旋转不会产生<strong>惯性</strong> ，也就是说石头的水平位置不会发生改变。</p>\n\n<p>题目保证初始时 <code>box</code> 中的石头要么在一个障碍物上，要么在另一个石头上，要么在箱子的底部。</p>\n\n<p>请你返回一个<em> </em><code>n x m</code>的矩阵，表示按照上述旋转后，箱子内的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcodewithstones.png\" style=\"width: 300px; height: 150px;\"></p>\n\n<pre><b>输入：</b>box = [[\"#\",\".\",\"#\"]]\n<b>输出：</b>[[\".\"],\n      [\"#\"],\n      [\"#\"]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcode2withstones.png\" style=\"width: 375px; height: 195px;\"></p>\n\n<pre><b>输入：</b>box = [[\"#\",\".\",\"*\",\".\"],\n            [\"#\",\"#\",\"*\",\".\"]]\n<b>输出：</b>[[\"#\",\".\"],\n      [\"#\",\"#\"],\n      [\"*\",\"*\"],\n      [\".\",\".\"]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcode3withstone.png\" style=\"width: 400px; height: 218px;\"></p>\n\n<pre><b>输入：</b>box = [[\"#\",\"#\",\"*\",\".\",\"*\",\".\"],\n            [\"#\",\"#\",\"#\",\"*\",\".\",\".\"],\n            [\"#\",\"#\",\"#\",\".\",\"#\",\".\"]]\n<b>输出：</b>[[\".\",\"#\",\"#\"],\n      [\".\",\"#\",\"#\"],\n      [\"#\",\"#\",\"*\"],\n      [\"#\",\"*\",\".\"],\n      [\"#\",\".\",\"*\"],\n      [\"#\",\".\",\".\"]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == box.length</code></li>\n\t<li><code>n == box[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>box[i][j]</code> 只可能是 <code>'#'</code> ，<code>'*'</code> 或者 <code>'.'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1862.向下取整数对和",
        "hardRate": "HARD",
        "passRate": "34.69%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-floored-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-floored-pairs/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，请你返回所有下标对 <code>0 &lt;= i, j &lt; nums.length</code> 的 <code>floor(nums[i] / nums[j])</code> 结果之和。由于答案可能会很大，请你返回答案对<code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p>函数 <code>floor()</code> 返回输入数字的整数部分。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,5,9]\n<b>输出：</b>10\n<strong>解释：</strong>\nfloor(2 / 5) = floor(2 / 9) = floor(5 / 9) = 0\nfloor(2 / 2) = floor(5 / 5) = floor(9 / 9) = 1\nfloor(5 / 2) = 2\nfloor(9 / 2) = 4\nfloor(9 / 5) = 1\n我们计算每一个数对商向下取整的结果并求和得到 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [7,7,7,7,7,7,7]\n<b>输出：</b>49\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1863.找出所有子集的异或总和再求和",
        "hardRate": "EASY",
        "passRate": "84.02%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-all-subset-xor-totals/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-all-subset-xor-totals/solution",
        "problemsDesc": "<p>一个数组的<strong> 异或总和</strong> 定义为数组中所有元素按位 <code>XOR</code> 的结果；如果数组为 <strong>空</strong> ，则异或总和为 <code>0</code> 。</p>\n\n<ul>\n\t<li>例如，数组 <code>[2,5,6]</code> 的 <strong>异或总和</strong> 为 <code>2 XOR 5 XOR 6 = 1</code> 。</li>\n</ul>\n\n<p>给你一个数组 <code>nums</code> ，请你求出 <code>nums</code> 中每个 <strong>子集</strong> 的 <strong>异或总和</strong> ，计算并返回这些值相加之 <strong>和</strong> 。</p>\n\n<p><strong>注意：</strong>在本题中，元素 <strong>相同</strong> 的不同子集应 <strong>多次</strong> 计数。</p>\n\n<p>数组 <code>a</code> 是数组 <code>b</code> 的一个 <strong>子集</strong> 的前提条件是：从 <code>b</code> 删除几个（也可能不删除）元素能够得到 <code>a</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3]\n<strong>输出：</strong>6\n<strong>解释：</strong>[1,3] 共有 4 个子集：\n- 空子集的异或总和是 0 。\n- [1] 的异或总和为 1 。\n- [3] 的异或总和为 3 。\n- [1,3] 的异或总和为 1 XOR 3 = 2 。\n0 + 1 + 3 + 2 = 6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,1,6]\n<strong>输出：</strong>28\n<strong>解释：</strong>[5,1,6] 共有 8 个子集：\n- 空子集的异或总和是 0 。\n- [5] 的异或总和为 5 。\n- [1] 的异或总和为 1 。\n- [6] 的异或总和为 6 。\n- [5,1] 的异或总和为 5 XOR 1 = 4 。\n- [5,6] 的异或总和为 5 XOR 6 = 3 。\n- [1,6] 的异或总和为 1 XOR 6 = 7 。\n- [5,1,6] 的异或总和为 5 XOR 1 XOR 6 = 2 。\n0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,4,5,6,7,8]\n<strong>输出：</strong>480\n<strong>解释：</strong>每个子集的全部异或总和值之和为 480 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 12</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1864.构成交替字符串需要的最小交换次数",
        "hardRate": "MEDIUM",
        "passRate": "40.64%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating/solution",
        "problemsDesc": "<p>给你一个二进制字符串 <code>s</code> ，现需要将其转化为一个 <strong>交替字符串</strong> 。请你计算并返回转化所需的 <strong>最小</strong> 字符交换次数，如果无法完成转化，返回<em> </em><code>-1</code><em> </em>。</p>\n\n<p><strong>交替字符串</strong> 是指：相邻字符之间不存在相等情况的字符串。例如，字符串 <code>\"010\"</code> 和 <code>\"1010\"</code> 属于交替字符串，但 <code>\"0100\"</code> 不是。</p>\n\n<p>任意两个字符都可以进行交换，<strong>不必相邻</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"111000\"\n<strong>输出：</strong>1\n<strong>解释：</strong>交换位置 1 和 4：\"1<em><strong>1</strong></em>10<em><strong>0</strong></em>0\" -> \"1<em><strong>0</strong></em>10<em><strong>1</strong></em>0\" ，字符串变为交替字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"010\"\n<strong>输出：</strong>0\n<strong>解释：</strong>字符串已经是交替字符串了，不需要交换。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1110\"\n<strong>输出：</strong>-1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 1000</code></li>\n\t<li><code>s[i]</code> 的值为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1865.找出和为指定值的下标对",
        "hardRate": "MEDIUM",
        "passRate": "50.81%",
        "problemsUrl": "https://leetcode.cn/problems/finding-pairs-with-a-certain-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/finding-pairs-with-a-certain-sum/solution",
        "problemsDesc": "<p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，请你实现一个支持下述两类查询的数据结构：</p>\n\n<ol>\n\t<li><strong>累加</strong> ，将一个正整数加到 <code>nums2</code> 中指定下标对应元素上。</li>\n\t<li><strong>计数 </strong>，统计满足 <code>nums1[i] + nums2[j]</code> 等于指定值的下标对 <code>(i, j)</code> 数目（<code>0 <= i < nums1.length</code> 且 <code>0 <= j < nums2.length</code>）。</li>\n</ol>\n\n<p>实现 <code>FindSumPairs</code> 类：</p>\n\n<ul>\n\t<li><code>FindSumPairs(int[] nums1, int[] nums2)</code> 使用整数数组 <code>nums1</code> 和 <code>nums2</code> 初始化 <code>FindSumPairs</code> 对象。</li>\n\t<li><code>void add(int index, int val)</code> 将 <code>val</code> 加到 <code>nums2[index]</code> 上，即，执行 <code>nums2[index] += val</code> 。</li>\n\t<li><code>int count(int tot)</code> 返回满足 <code>nums1[i] + nums2[j] == tot</code> 的下标对 <code>(i, j)</code> 数目。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"FindSumPairs\", \"count\", \"add\", \"count\", \"count\", \"add\", \"add\", \"count\"]\n[[[1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]], [7], [3, 2], [8], [4], [0, 1], [1, 1], [7]]\n<strong>输出：</strong>\n[null, 8, null, 2, 1, null, null, 11]\n\n<strong>解释：</strong>\nFindSumPairs findSumPairs = new FindSumPairs([1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]);\nfindSumPairs.count(7);  // 返回 8 ; 下标对 (2,2), (3,2), (4,2), (2,4), (3,4), (4,4) 满足 2 + 5 = 7 ，下标对 (5,1), (5,5) 满足 3 + 4 = 7\nfindSumPairs.add(3, 2); // 此时 nums2 = [1,4,5,<em><strong>4</strong></em><code>,5,4</code>]\nfindSumPairs.count(8);  // 返回 2 ；下标对 (5,2), (5,4) 满足 3 + 5 = 8\nfindSumPairs.count(4);  // 返回 1 ；下标对 (5,0) 满足 3 + 1 = 4\nfindSumPairs.add(0, 1); // 此时 nums2 = [<em><strong><code>2</code></strong></em>,4,5,4<code>,5,4</code>]\nfindSumPairs.add(1, 1); // 此时 nums2 = [<code>2</code>,<em><strong>5</strong></em>,5,4<code>,5,4</code>]\nfindSumPairs.count(7);  // 返回 11 ；下标对 (2,1), (2,2), (2,4), (3,1), (3,2), (3,4), (4,1), (4,2), (4,4) 满足 2 + 5 = 7 ，下标对 (5,3), (5,5) 满足 3 + 4 = 7\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums1.length <= 1000</code></li>\n\t<li><code>1 <= nums2.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums1[i] <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= nums2[i] <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= index < nums2.length</code></li>\n\t<li><code>1 <= val <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= tot <= 10<sup>9</sup></code></li>\n\t<li>最多调用 <code>add</code> 和 <code>count</code> 函数各 <code>1000</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1866.恰有 K 根木棍可以看到的排列数目",
        "hardRate": "HARD",
        "passRate": "61.84%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/solution",
        "problemsDesc": "<p>有 <code>n</code> 根长度互不相同的木棍，长度为从 <code>1</code> 到 <code>n</code> 的整数。请你将这些木棍排成一排，并满足从左侧 <strong>可以看到</strong> <strong>恰好</strong> <code>k</code> 根木棍。从左侧 <strong>可以看到</strong> 木棍的前提是这个木棍的 <strong>左侧</strong> 不存在比它 <strong>更长的</strong> 木棍。</p>\n\n<ul>\n\t<li>例如，如果木棍排列为 <code>[<em><strong>1</strong></em>,<em><strong>3</strong></em>,2,<em><strong>5</strong></em>,4]</code> ，那么从左侧可以看到的就是长度分别为 <code>1</code>、<code>3</code> 、<code>5</code> 的木棍。</li>\n</ul>\n\n<p>给你 <code>n</code> 和 <code>k</code> ，返回符合题目要求的排列 <strong>数目</strong> 。由于答案可能很大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余 </strong>的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 3, k = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>[<strong><em>1</em></strong>,<strong><em>3</em></strong>,2], [<em><strong>2</strong></em>,<em><strong>3</strong></em>,1] 和 [<em><strong>2</strong></em>,1,<em><strong>3</strong></em>] 是仅有的能满足恰好 2 根木棍可以看到的排列。\n可以看到的木棍已经用粗体+斜体标识。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 5, k = 5\n<strong>输出：</strong>1\n<strong>解释：</strong>[<em><strong>1</strong></em>,<em><strong>2</strong></em>,<em><strong>3</strong></em>,<em><strong>4</strong></em>,<em><strong>5</strong></em>] 是唯一一种能满足全部 5 根木棍可以看到的排列。\n可以看到的木棍已经用粗体+斜体标识。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 20, k = 11\n<strong>输出：</strong>647427950\n<strong>解释：</strong>总共有 647427950 (mod 10<sup>9 </sup>+ 7) 种能满足恰好有 11 根木棍可以看到的排列。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1867.最大数量高于平均水平的订单",
        "hardRate": "MEDIUM",
        "passRate": "68.08%",
        "problemsUrl": "https://leetcode.cn/problems/orders-with-maximum-quantity-above-average/",
        "solutionsUrl": "https://leetcode.cn/problems/orders-with-maximum-quantity-above-average/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1868.两个行程编码数组的积",
        "hardRate": "MEDIUM",
        "passRate": "48.82%",
        "problemsUrl": "https://leetcode.cn/problems/product-of-two-run-length-encoded-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/product-of-two-run-length-encoded-arrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1869.哪种连续子字符串更长",
        "hardRate": "EASY",
        "passRate": "70.51%",
        "problemsUrl": "https://leetcode.cn/problems/longer-contiguous-segments-of-ones-than-zeros/",
        "solutionsUrl": "https://leetcode.cn/problems/longer-contiguous-segments-of-ones-than-zeros/solution",
        "problemsDesc": "<p>给你一个二进制字符串 <code>s</code> 。如果字符串中由 <code>1</code> 组成的 <strong>最长</strong> 连续子字符串 <strong>严格长于</strong> 由 <code>0</code> 组成的 <strong>最长</strong> 连续子字符串，返回 <code>true</code> ；否则，返回 <code>false</code><em> </em>。</p>\n\n<ul>\n\t<li>例如，<code>s = \"<strong>11</strong>01<strong>000</strong>10\"</code> 中，由 <code>1</code> 组成的最长连续子字符串的长度是 <code>2</code> ，由 <code>0</code> 组成的最长连续子字符串的长度是 <code>3</code> 。</li>\n</ul>\n\n<p>注意，如果字符串中不存在 <code>0</code> ，此时认为由 <code>0</code> 组成的最长连续子字符串的长度是 <code>0</code> 。字符串中不存在 <code>1</code> 的情况也适用此规则。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1101\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\n由 <code>1</code> 组成的最长连续子字符串的长度是 2：\"<strong>11</strong>01\"\n由 <code>0</code> 组成的最长连续子字符串的长度是 1：\"11<strong>0</strong>1\"\n由 1 组成的子字符串更长，故返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"111000\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\n由 <code>1</code> 组成的最长连续子字符串的长度是 3：\"<strong>111</strong>000\"\n由<code> 0</code> 组成的最长连续子字符串的长度是 3：\"111<strong>000</strong>\"\n由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"110100010\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\n由 <code>1</code> 组成的最长连续子字符串的长度是 2：\"<strong>11</strong>0100010\"\n由 <code>0</code> 组成的最长连续子字符串的长度是 3：\"1101<strong>000</strong>10\"\n由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 100</code></li>\n\t<li><code>s[i]</code> 不是 <code>'0'</code> 就是 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1870.准时到达的列车最小时速",
        "hardRate": "MEDIUM",
        "passRate": "42.10%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/solution",
        "problemsDesc": "<p>给你一个浮点数 <code>hour</code> ，表示你到达办公室可用的总通勤时间。要到达办公室，你必须按给定次序乘坐 <code>n</code> 趟列车。另给你一个长度为 <code>n</code> 的整数数组 <code>dist</code> ，其中 <code>dist[i]</code> 表示第 <code>i</code> 趟列车的行驶距离（单位是千米）。</p>\n\n<p>每趟列车均只能在整点发车，所以你可能需要在两趟列车之间等待一段时间。</p>\n\n<ul>\n\t<li>例如，第 <code>1</code> 趟列车需要 <code>1.5</code> 小时，那你必须再等待 <code>0.5</code> 小时，搭乘在第 2 小时发车的第 <code>2</code> 趟列车。</li>\n</ul>\n\n<p>返回能满足你准时到达办公室所要求全部列车的<strong> 最小正整数 </strong>时速（单位：千米每小时），如果无法准时到达，则返回 <code>-1</code> 。</p>\n\n<p>生成的测试用例保证答案不超过 <code>10<sup>7</sup></code> ，且 <code>hour</code> 的 <strong>小数点后最多存在两位数字</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [1,3,2], hour = 6\n<strong>输出：</strong>1\n<strong>解释：</strong>速度为 1 时：\n- 第 1 趟列车运行需要 1/1 = 1 小时。\n- 由于是在整数时间到达，可以立即换乘在第 1 小时发车的列车。第 2 趟列车运行需要 3/1 = 3 小时。\n- 由于是在整数时间到达，可以立即换乘在第 4 小时发车的列车。第 3 趟列车运行需要 2/1 = 2 小时。\n- 你将会恰好在第 6 小时到达。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [1,3,2], hour = 2.7\n<strong>输出：</strong>3\n<strong>解释：</strong>速度为 3 时：\n- 第 1 趟列车运行需要 1/3 = 0.33333 小时。\n- 由于不是在整数时间到达，故需要等待至第 1 小时才能搭乘列车。第 2 趟列车运行需要 3/3 = 1 小时。\n- 由于是在整数时间到达，可以立即换乘在第 2 小时发车的列车。第 3 趟列车运行需要 2/3 = 0.66667 小时。\n- 你将会在第 2.66667 小时到达。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [1,3,2], hour = 1.9\n<strong>输出：</strong>-1\n<strong>解释：</strong>不可能准时到达，因为第 3 趟列车最早是在第 2 小时发车。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == dist.length</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= dist[i] <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= hour <= 10<sup>9</sup></code></li>\n\t<li><code>hours</code> 中，小数点后最多存在两位数字</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1871.跳跃游戏 VII",
        "hardRate": "MEDIUM",
        "passRate": "28.32%",
        "problemsUrl": "https://leetcode.cn/problems/jump-game-vii/",
        "solutionsUrl": "https://leetcode.cn/problems/jump-game-vii/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0 </strong>开始的二进制字符串 <code>s</code> 和两个整数 <code>minJump</code> 和 <code>maxJump</code> 。一开始，你在下标 <code>0</code> 处，且该位置的值一定为 <code>'0'</code> 。当同时满足如下条件时，你可以从下标 <code>i</code> 移动到下标 <code>j</code> 处：</p>\n\n<ul>\n\t<li><code>i + minJump <= j <= min(i + maxJump, s.length - 1)</code> 且</li>\n\t<li><code>s[j] == '0'</code>.</li>\n</ul>\n\n<p>如果你可以到达 <code>s</code> 的下标<i> </i><code>s.length - 1</code> 处，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"<strong>0</strong>11<strong>0</strong>1<strong>0</strong>\", minJump = 2, maxJump = 3\n<b>输出：</b>true\n<strong>解释：</strong>\n第一步，从下标 0 移动到下标 3 。\n第二步，从下标 3 移动到下标 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"01101110\", minJump = 2, maxJump = 3\n<b>输出：</b>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= s.length <= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 要么是 <code>'0'</code> ，要么是 <code>'1'</code></li>\n\t<li><code>s[0] == '0'</code></li>\n\t<li><code>1 <= minJump <= maxJump < s.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1872.石子游戏 VIII",
        "hardRate": "HARD",
        "passRate": "61.33%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game-viii/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game-viii/solution",
        "problemsDesc": "<p>Alice 和 Bob 玩一个游戏，两人轮流操作， <strong>Alice 先手</strong> 。</p>\n\n<p>总共有 <code>n</code> 个石子排成一行。轮到某个玩家的回合时，如果石子的数目 <strong>大于 1</strong> ，他将执行以下操作：</p>\n\n<ol>\n\t<li>选择一个整数 <code>x &gt; 1</code> ，并且 <strong>移除</strong> 最左边的 <code>x</code> 个石子。</li>\n\t<li>将<strong> 移除</strong> 的石子价值之 <strong>和</strong> 累加到该玩家的分数中。</li>\n\t<li>将一个 <strong>新的石子</strong> 放在最左边，且新石子的值为被移除石子值之和。</li>\n</ol>\n\n<p>当只剩下 <strong>一个</strong> 石子时，游戏结束。</p>\n\n<p>Alice 和 Bob 的 <strong>分数之差</strong> 为 <code>(Alice 的分数 - Bob 的分数)</code> 。 Alice 的目标是<strong> 最大化</strong> 分数差，Bob 的目标是 <strong>最小化</strong> 分数差。</p>\n\n<p>给你一个长度为 <code>n</code> 的整数数组 <code>stones</code> ，其中 <code>stones[i]</code> 是 <strong>从左边起</strong> 第 <code>i</code> 个石子的价值。请你返回在双方都采用 <strong>最优</strong> 策略的情况下，Alice 和 Bob 的 <strong>分数之差</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>stones = [-1,2,-3,4,-5]\n<b>输出：</b>5\n<strong>解释：</strong>\n- Alice 移除最左边的 4 个石子，得分增加 (-1) + 2 + (-3) + 4 = 2 ，并且将一个价值为 2 的石子放在最左边。stones = [2,-5] 。\n- Bob 移除最左边的 2 个石子，得分增加 2 + (-5) = -3 ，并且将一个价值为 -3 的石子放在最左边。stones = [-3] 。\n两者分数之差为 2 - (-3) = 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>stones = [7,-6,5,10,5,-2,-6]\n<b>输出：</b>13\n<b>解释：</b>\n- Alice 移除所有石子，得分增加 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 ，并且将一个价值为 13 的石子放在最左边。stones = [13] 。\n两者分数之差为 13 - 0 = 13 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>stones = [-10,-12]\n<b>输出：</b>-22\n<strong>解释：</strong>\n- Alice 只有一种操作，就是移除所有石子。得分增加 (-10) + (-12) = -22 ，并且将一个价值为 -22 的石子放在最左边。stones = [-22] 。\n两者分数之差为 (-22) - 0 = -22 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == stones.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= stones[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1873.计算特殊奖金",
        "hardRate": "EASY",
        "passRate": "62.71%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-special-bonus/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-special-bonus/solution",
        "problemsDesc": "<p>表: <code>Employees</code></p>\n\n<pre>\n+-------------+---------+\n| 列名        | 类型     |\n+-------------+---------+\n| employee_id | int     |\n| name        | varchar |\n| salary      | int     |\n+-------------+---------+\nemployee_id 是这个表的主键。\n此表的每一行给出了雇员id ，名字和薪水。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>计算每个雇员的奖金。如果一个雇员的id是奇数并且他的名字不是以'M'开头，那么他的奖金是他工资的100%，否则奖金为0。</p>\n\n<p>&nbsp;</p>\n\n<p>返回的结果集请按照<code>employee_id</code>排序。</p>\n\n<p>返回结果格式如下面的例子所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nEmployees 表:\n+-------------+---------+--------+\n| employee_id | name    | salary |\n+-------------+---------+--------+\n| 2           | Meir    | 3000   |\n| 3           | Michael | 3800   |\n| 7           | Addilyn | 7400   |\n| 8           | Juan    | 6100   |\n| 9           | Kannon  | 7700   |\n+-------------+---------+--------+\n<strong>输出：</strong>\n+-------------+-------+\n| employee_id | bonus |\n+-------------+-------+\n| 2           | 0     |\n| 3           | 0     |\n| 7           | 7400  |\n| 8           | 0     |\n| 9           | 7700  |\n+-------------+-------+\n<strong>解释：</strong>\n因为雇员id是偶数，所以雇员id 是2和8的两个雇员得到的奖金是0。\n雇员id为3的因为他的名字以'M'开头，所以，奖金是0。\n其他的雇员得到了百分之百的奖金。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1874.两个数组的最小乘积和",
        "hardRate": "MEDIUM",
        "passRate": "86.63%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-product-sum-of-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-product-sum-of-two-arrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1875.将工资相同的雇员分组",
        "hardRate": "MEDIUM",
        "passRate": "64.39%",
        "problemsUrl": "https://leetcode.cn/problems/group-employees-of-the-same-salary/",
        "solutionsUrl": "https://leetcode.cn/problems/group-employees-of-the-same-salary/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1876.长度为三且各字符不同的子字符串",
        "hardRate": "EASY",
        "passRate": "70.48%",
        "problemsUrl": "https://leetcode.cn/problems/substrings-of-size-three-with-distinct-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/substrings-of-size-three-with-distinct-characters/solution",
        "problemsDesc": "<p>如果一个字符串不含有任何重复字符，我们称这个字符串为 <strong>好</strong> 字符串。</p>\n\n<p>给你一个字符串 <code>s</code> ，请你返回 <code>s</code> 中长度为 <strong>3</strong> 的 <strong>好子字符串</strong> 的数量。</p>\n\n<p>注意，如果相同的好子字符串出现多次，每一次都应该被记入答案之中。</p>\n\n<p><strong>子字符串</strong> 是一个字符串中连续的字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"xyzzaz\"\n<b>输出：</b>1\n<b>解释：</b>总共有 4 个长度为 3 的子字符串：\"xyz\"，\"yzz\"，\"zza\" 和 \"zaz\" 。\n唯一的长度为 3 的好子字符串是 \"xyz\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aababcabc\"\n<b>输出：</b>4\n<b>解释：</b>总共有 7 个长度为 3 的子字符串：\"aab\"，\"aba\"，\"bab\"，\"abc\"，\"bca\"，\"cab\" 和 \"abc\" 。\n好子字符串包括 \"abc\"，\"bca\"，\"cab\" 和 \"abc\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 100</code></li>\n\t<li><code>s</code>​​​​​​ 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1877.数组中最大数对和的最小值",
        "hardRate": "MEDIUM",
        "passRate": "81.14%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-maximum-pair-sum-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-maximum-pair-sum-in-array/solution",
        "problemsDesc": "<p>一个数对 <code>(a,b)</code> 的 <strong>数对和</strong> 等于 <code>a + b</code> 。<strong>最大数对和</strong> 是一个数对数组中最大的 <strong>数对和</strong> 。</p>\n\n<ul>\n\t<li>比方说，如果我们有数对 <code>(1,5)</code> ，<code>(2,3)</code> 和 <code>(4,4)</code>，<strong>最大数对和</strong> 为 <code>max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8</code> 。</li>\n</ul>\n\n<p>给你一个长度为 <strong>偶数</strong> <code>n</code> 的数组 <code>nums</code> ，请你将 <code>nums</code> 中的元素分成 <code>n / 2</code> 个数对，使得：</p>\n\n<ul>\n\t<li><code>nums</code> 中每个元素 <strong>恰好</strong> 在 <strong>一个</strong> 数对中，且</li>\n\t<li><strong>最大数对和</strong> 的值 <strong>最小</strong> 。</li>\n</ul>\n\n<p>请你在最优数对划分的方案下，返回最小的 <strong>最大数对和</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [3,5,2,3]\n<b>输出：</b>7\n<b>解释：</b>数组中的元素可以分为数对 (3,3) 和 (5,2) 。\n最大数对和为 max(3+3, 5+2) = max(6, 7) = 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [3,5,4,2,4,6]\n<b>输出：</b>8\n<b>解释：</b>数组中的元素可以分为数对 (3,5)，(4,4) 和 (6,2) 。\n最大数对和为 max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>n</code> 是 <strong>偶数</strong> 。</li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1878.矩阵中最大的三个菱形和",
        "hardRate": "MEDIUM",
        "passRate": "45.64%",
        "problemsUrl": "https://leetcode.cn/problems/get-biggest-three-rhombus-sums-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/get-biggest-three-rhombus-sums-in-a-grid/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的整数矩阵 <code>grid</code> 。</p>\n\n<p><strong>菱形和</strong> 指的是 <code>grid</code> 中一个正菱形 <strong>边界</strong> 上的元素之和。本题中的菱形必须为正方形旋转45度，且四个角都在一个格子当中。下图是四个可行的菱形，每个菱形和应该包含的格子都用了相应颜色标注在图中。</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-desc-2.png\" style=\"width: 385px; height: 385px;\" />\n<p> </p>\n\n<p>注意，菱形可以是一个面积为 0 的区域，如上图中右下角的紫色菱形所示。</p>\n\n<p>请你按照 <strong>降序</strong> 返回 <code>grid</code> 中三个最大的 <strong>互不相同的菱形和</strong> 。如果不同的和少于三个，则将它们全部返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-ex1.png\" style=\"width: 360px; height: 361px;\" />\n<pre>\n<b>输入：</b>grid = [[3,4,5,1,3],[3,3,4,2,3],[20,30,200,40,10],[1,5,5,4,1],[4,3,2,2,5]]\n<b>输出：</b>[228,216,211]\n<b>解释：</b>最大的三个菱形和如上图所示。\n- 蓝色：20 + 3 + 200 + 5 = 228\n- 红色：200 + 2 + 10 + 4 = 216\n- 绿色：5 + 200 + 4 + 2 = 211\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-ex2.png\" style=\"width: 217px; height: 217px;\" />\n<pre>\n<b>输入：</b>grid = [[1,2,3],[4,5,6],[7,8,9]]\n<b>输出：</b>[20,9,8]\n<b>解释：</b>最大的三个菱形和如上图所示。\n- 蓝色：4 + 2 + 6 + 8 = 20\n- 红色：9 （右下角红色的面积为 0 的菱形）\n- 绿色：8 （下方中央面积为 0 的菱形）\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>grid = [[7,7,7]]\n<b>输出：</b>[7]\n<b>解释：</b>所有三个可能的菱形和都相同，所以返回 [7] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 <= m, n <= 100</code></li>\n\t<li><code>1 <= grid[i][j] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1879.两个数组最小的异或值之和",
        "hardRate": "HARD",
        "passRate": "50.39%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-xor-sum-of-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-xor-sum-of-two-arrays/solution",
        "problemsDesc": "<p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，它们长度都为 <code>n</code> 。</p>\n\n<p>两个数组的 <strong>异或值之和</strong> 为 <code>(nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1])</code> （<strong>下标从 0 开始</strong>）。</p>\n\n<ul>\n\t<li>比方说，<code>[1,2,3]</code> 和 <code>[3,2,1]</code> 的 <strong>异或值之和</strong> 等于 <code>(1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4</code> 。</li>\n</ul>\n\n<p>请你将 <code>nums2</code> 中的元素重新排列，使得 <strong>异或值之和</strong> <strong>最小</strong> 。</p>\n\n<p>请你返回重新排列之后的 <strong>异或值之和</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,2], nums2 = [2,3]\n<b>输出：</b>2\n<b>解释：</b>将 <code>nums2</code> 重新排列得到 <code>[3,2] 。</code>\n异或值之和为 (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,0,3], nums2 = [5,3,4]\n<b>输出：</b>8\n<b>解释：</b>将 <code>nums2 重新排列得到</code> <code>[5,4,3] 。</code>\n异或值之和为 (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length</code></li>\n\t<li><code>n == nums2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 14</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1880.检查某单词是否等于两单词之和",
        "hardRate": "EASY",
        "passRate": "76.20%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-word-equals-summation-of-two-words/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-word-equals-summation-of-two-words/solution",
        "problemsDesc": "<p>字母的 <strong>字母值</strong> 取决于字母在字母表中的位置，<strong>从 0 开始</strong> 计数。即，<code>'a' -&gt; 0</code>、<code>'b' -&gt; 1</code>、<code>'c' -&gt; 2</code>，以此类推。</p>\n\n<p>对某个由小写字母组成的字符串 <code>s</code> 而言，其 <strong>数值</strong> 就等于将 <code>s</code> 中每个字母的 <strong>字母值</strong> 按顺序 <strong>连接</strong> 并 <strong>转换</strong> 成对应整数。</p>\n\n<ul>\n\t<li>例如，<code>s = \"acb\"</code> ，依次连接每个字母的字母值可以得到 <code>\"021\"</code> ，转换为整数得到 <code>21</code> 。</li>\n</ul>\n\n<p>给你三个字符串 <code>firstWord</code>、<code>secondWord</code> 和 <code>targetWord</code> ，每个字符串都由从 <code>'a'</code> 到 <code>'j'</code> （<strong>含 </strong><code>'a'</code> 和 <code>'j'</code><strong> </strong>）的小写英文字母组成。</p>\n\n<p>如果 <code>firstWord</code><em> </em>和<em> </em><code>secondWord</code> 的 <strong>数值之和</strong> 等于<em> </em><code>targetWord</code><em> </em>的数值，返回 <code>true</code> ；否则，返回<em> </em><code>false</code><em> </em>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>firstWord = \"acb\", secondWord = \"cba\", targetWord = \"cdb\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\nfirstWord 的数值为 \"acb\" -&gt; \"021\" -&gt; 21\nsecondWord 的数值为 \"cba\" -&gt; \"210\" -&gt; 210\ntargetWord 的数值为 \"cdb\" -&gt; \"231\" -&gt; 231\n由于 21 + 210 == 231 ，返回 true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aab\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\nfirstWord 的数值为 \"aaa\" -&gt; \"000\" -&gt; 0\nsecondWord 的数值为 \"a\" -&gt; \"0\" -&gt; 0\ntargetWord 的数值为 \"aab\" -&gt; \"001\" -&gt; 1\n由于 0 + 0 != 1 ，返回 false</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aaaa\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\nfirstWord 的数值为 \"aaa\" -&gt; \"000\" -&gt; 0\nsecondWord 的数值为 \"a\" -&gt; \"0\" -&gt; 0\ntargetWord 的数值为 \"aaaa\" -&gt; \"0000\" -&gt; 0\n由于 0 + 0 == 0 ，返回 true\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= firstWord.length, </code><code>secondWord.length, </code><code>targetWord.length &lt;= 8</code></li>\n\t<li><code>firstWord</code>、<code>secondWord</code> 和 <code>targetWord</code> 仅由从 <code>'a'</code> 到 <code>'j'</code> （<strong>含 </strong><code>'a'</code> 和 <code>'j'</code><strong> </strong>）的小写英文字母组成<strong>。</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1881.插入后的最大值",
        "hardRate": "MEDIUM",
        "passRate": "37.76%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-value-after-insertion/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-value-after-insertion/solution",
        "problemsDesc": "<p>给你一个非常大的整数 <code>n</code> 和一个整数数字 <code>x</code> ，大整数 <code>n</code> 用一个字符串表示。<code>n</code> 中每一位数字和数字 <code>x</code> 都处于闭区间 <code>[1, 9]</code> 中，且 <code>n</code> 可能表示一个 <strong>负数</strong> 。</p>\n\n<p>你打算通过在 <code>n</code> 的十进制表示的任意位置插入 <code>x</code> 来 <strong>最大化</strong> <code>n</code> 的 <strong>数值</strong> ​​​​​​。但 <strong>不能</strong> 在负号的左边插入 <code>x</code> 。</p>\n\n<ul>\n\t<li>例如，如果 <code>n = 73</code> 且 <code>x = 6</code> ，那么最佳方案是将 <code>6</code> 插入 <code>7</code> 和 <code>3</code> 之间，使 <code>n = 763</code> 。</li>\n\t<li>如果 <code>n = -55</code> 且 <code>x = 2</code> ，那么最佳方案是将 <code>2</code> 插在第一个 <code>5</code> 之前，使 <code>n = -255</code> 。</li>\n</ul>\n\n<p>返回插入操作后，用字符串表示的 <code>n</code> 的最大值。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = \"99\", x = 9\n<strong>输出：</strong>\"999\"\n<strong>解释：</strong>不管在哪里插入 9 ，结果都是相同的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = \"-13\", x = 2\n<strong>输出：</strong>\"-123\"\n<strong>解释：</strong>向 n 中插入 x 可以得到 -213、-123 或者 -132 ，三者中最大的是 -123 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= x <= 9</code></li>\n\t<li><code>n</code>​​​ 中每一位的数字都在闭区间 <code>[1, 9]</code> 中。</li>\n\t<li><code>n</code> 代表一个有效的整数。</li>\n\t<li>当 <code>n</code> 表示负数时，将会以字符 <code>'-'</code> 开始。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1882.使用服务器处理任务",
        "hardRate": "MEDIUM",
        "passRate": "30.78%",
        "problemsUrl": "https://leetcode.cn/problems/process-tasks-using-servers/",
        "solutionsUrl": "https://leetcode.cn/problems/process-tasks-using-servers/solution",
        "problemsDesc": "<p>给你两个 <strong>下标从 0 开始</strong> 的整数数组 <code>servers</code> 和 <code>tasks</code> ，长度分别为 <code>n</code>​​​​​​ 和 <code>m</code>​​​​​​ 。<code>servers[i]</code> 是第 <code>i<sup>​​​​​​</sup></code>​​​​ 台服务器的 <strong>权重</strong> ，而 <code>tasks[j]</code> 是处理第 <code>j<sup>​​​​​​</sup></code> 项任务 <strong>所需要的时间</strong>（单位：秒）。</p>\n\n<p>你正在运行一个仿真系统，在处理完所有任务后，该系统将会关闭。每台服务器只能同时处理一项任务。第 <code>0</code> 项任务在第 <code>0</code> 秒可以开始处理，相应地，第 <code>j</code> 项任务在第 <code>j</code> 秒可以开始处理。处理第 <code>j</code> 项任务时，你需要为它分配一台 <strong>权重最小</strong> 的空闲服务器。如果存在多台相同权重的空闲服务器，请选择 <strong>下标最小</strong> 的服务器。如果一台空闲服务器在第 <code>t</code> 秒分配到第 <code>j</code> 项任务，那么在 <code>t + tasks[j]</code> 时它将恢复空闲状态。</p>\n\n<p>如果没有空闲服务器，则必须等待，直到出现一台空闲服务器，并 <strong>尽可能早</strong> 地处理剩余任务。 如果有多项任务等待分配，则按照 <strong>下标递增</strong> 的顺序完成分配。</p>\n\n<p>如果同一时刻存在多台空闲服务器，可以同时将多项任务分别分配给它们。</p>\n\n<p>构建长度为 <code>m</code> 的答案数组 <code>ans</code> ，其中 <code>ans[j]</code> 是第 <code>j</code> 项任务分配的服务器的下标。</p>\n\n<p>返回答案数组<em> </em><code>ans</code>​​​​ 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>servers = [3,3,2], tasks = [1,2,3,2,1,2]\n<strong>输出：</strong>[2,2,0,2,1,2]\n<strong>解释：</strong>事件按时间顺序如下：\n- 0 秒时，第 0 项任务加入到任务队列，使用第 2 台服务器处理到 1 秒。\n- 1 秒时，第 2 台服务器空闲，第 1 项任务加入到任务队列，使用第 2 台服务器处理到 3 秒。\n- 2 秒时，第 2 项任务加入到任务队列，使用第 0 台服务器处理到 5 秒。\n- 3 秒时，第 2 台服务器空闲，第 3 项任务加入到任务队列，使用第 2 台服务器处理到 5 秒。\n- 4 秒时，第 4 项任务加入到任务队列，使用第 1 台服务器处理到 5 秒。\n- 5 秒时，所有服务器都空闲，第 5 项任务加入到任务队列，使用第 2 台服务器处理到 7 秒。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>servers = [5,1,4,3,2], tasks = [2,1,2,4,5,2,1]\n<strong>输出：</strong>[1,4,1,4,1,3,2]\n<strong>解释：</strong>事件按时间顺序如下：\n- 0 秒时，第 0 项任务加入到任务队列，使用第 1 台服务器处理到 2 秒。\n- 1 秒时，第 1 项任务加入到任务队列，使用第 4 台服务器处理到 2 秒。\n- 2 秒时，第 1 台和第 4 台服务器空闲，第 2 项任务加入到任务队列，使用第 1 台服务器处理到 4 秒。\n- 3 秒时，第 3 项任务加入到任务队列，使用第 4 台服务器处理到 7 秒。\n- 4 秒时，第 1 台服务器空闲，第 4 项任务加入到任务队列，使用第 1 台服务器处理到 9 秒。\n- 5 秒时，第 5 项任务加入到任务队列，使用第 3 台服务器处理到 7 秒。\n- 6 秒时，第 6 项任务加入到任务队列，使用第 2 台服务器处理到 7 秒。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>servers.length == n</code></li>\n\t<li><code>tasks.length == m</code></li>\n\t<li><code>1 <= n, m <= 2 * 10<sup>5</sup></code></li>\n\t<li><code>1 <= servers[i], tasks[j] <= 2 * 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1883.准时抵达会议现场的最小跳过休息次数",
        "hardRate": "HARD",
        "passRate": "40.25%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-skips-to-arrive-at-meeting-on-time/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-skips-to-arrive-at-meeting-on-time/solution",
        "problemsDesc": "<p>给你一个整数 <code>hoursBefore</code> ，表示你要前往会议所剩下的可用小时数。要想成功抵达会议现场，你必须途经 <code>n</code> 条道路。道路的长度用一个长度为 <code>n</code> 的整数数组 <code>dist</code> 表示，其中 <code>dist[i]</code> 表示第 <code>i</code> 条道路的长度（单位：<strong>千米</strong>）。另给你一个整数 <code>speed</code> ，表示你在道路上前进的速度（单位：<strong>千米每小时</strong>）。</p>\n\n<p>当你通过第 <code>i</code> 条路之后，就必须休息并等待，直到 <strong>下一个整数小时</strong> 才能开始继续通过下一条道路。注意：你不需要在通过最后一条道路后休息，因为那时你已经抵达会议现场。</p>\n\n<ul>\n\t<li>例如，如果你通过一条道路用去 <code>1.4</code> 小时，那你必须停下来等待，到 <code>2</code> 小时才可以继续通过下一条道路。如果通过一条道路恰好用去 <code>2</code> 小时，就无需等待，可以直接继续。</li>\n</ul>\n\n<p>然而，为了能准时到达，你可以选择 <strong>跳过</strong> 一些路的休息时间，这意味着你不必等待下一个整数小时。注意，这意味着与不跳过任何休息时间相比，你可能在不同时刻到达接下来的道路。</p>\n\n<ul>\n\t<li>例如，假设通过第 <code>1</code> 条道路用去 <code>1.4</code> 小时，且通过第 <code>2</code> 条道路用去 <code>0.6</code> 小时。跳过第 <code>1</code> 条道路的休息时间意味着你将会在恰好 <code>2</code> 小时完成通过第 <code>2</code> 条道路，且你能够立即开始通过第 <code>3</code> 条道路。</li>\n</ul>\n\n<p>返回准时抵达会议现场所需要的 <strong>最小跳过次数</strong> ，如果 <strong>无法准时参会</strong> ，返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [1,3,2], speed = 4, hoursBefore = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>\n不跳过任何休息时间，你将用 (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 小时才能抵达会议现场。\n可以跳过第 1 次休息时间，共用 ((1/4 + <strong>0</strong>) + (3/4 + 0)) + (2/4) = 1.5 小时抵达会议现场。\n注意，第 2 次休息时间缩短为 0 ，由于跳过第 1 次休息时间，你是在整数小时处完成通过第 2 条道路。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [7,3,5,5], speed = 2, hoursBefore = 10\n<strong>输出：</strong>2\n<strong>解释：</strong>\n不跳过任何休息时间，你将用 (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 小时才能抵达会议现场。\n可以跳过第 1 次和第 3 次休息时间，共用 ((7/2 + <strong>0</strong>) + (3/2 + 0)) + ((5/2 + <strong>0</strong>) + (5/2)) = 10 小时抵达会议现场。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [7,3,5,5], speed = 1, hoursBefore = 10\n<strong>输出：</strong>-1\n<strong>解释：</strong>即使跳过所有的休息时间，也无法准时参加会议。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == dist.length</code></li>\n\t<li><code>1 <= n <= 1000</code></li>\n\t<li><code>1 <= dist[i] <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= speed <= 10<sup>6</sup></code></li>\n\t<li><code>1 <= hoursBefore <= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1884.鸡蛋掉落-两枚鸡蛋",
        "hardRate": "MEDIUM",
        "passRate": "70.47%",
        "problemsUrl": "https://leetcode.cn/problems/egg-drop-with-2-eggs-and-n-floors/",
        "solutionsUrl": "https://leetcode.cn/problems/egg-drop-with-2-eggs-and-n-floors/solution",
        "problemsDesc": "<p>给你 <strong>2&nbsp;枚相同 </strong>的鸡蛋，和一栋从第 <code>1</code>&nbsp;层到第 <code>n</code> 层共有 <code>n</code> 层楼的建筑。</p>\n\n<p>已知存在楼层 <code>f</code> ，满足&nbsp;<code>0 &lt;= f &lt;= n</code> ，任何从 <strong>高于 </strong><code>f</code> 的楼层落下的鸡蛋都<strong> 会碎 </strong>，从 <strong><code>f</code> 楼层或比它低 </strong>的楼层落下的鸡蛋都 <strong>不会碎 </strong>。</p>\n\n<p>每次操作，你可以取一枚<strong> 没有碎</strong> 的鸡蛋并把它从任一楼层 <code>x</code> 扔下（满足&nbsp;<code>1 &lt;= x &lt;= n</code>）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中<strong> 重复使用 </strong>这枚鸡蛋。</p>\n\n<p>请你计算并返回要确定 <code>f</code> <strong>确切的值 </strong>的 <strong>最小操作次数</strong> 是多少？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>我们可以将第一枚鸡蛋从 1 楼扔下，然后将第二枚从 2 楼扔下。\n如果第一枚鸡蛋碎了，可知 f = 0；\n如果第二枚鸡蛋碎了，但第一枚没碎，可知 f = 1；\n否则，当两个鸡蛋都没碎时，可知 f = 2。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 100\n<strong>输出：</strong>14\n<strong>解释：\n</strong>一种最优的策略是：\n- 将第一枚鸡蛋从 9 楼扔下。如果碎了，那么 f 在 0 和 8 之间。将第二枚从 1 楼扔下，然后每扔一次上一层楼，在 8 次内找到 f 。总操作次数 = 1 + 8 = 9 。\n- 如果第一枚鸡蛋没有碎，那么再把第一枚鸡蛋从 22 层扔下。如果碎了，那么 f 在 9 和 21 之间。将第二枚鸡蛋从 10 楼扔下，然后每扔一次上一层楼，在 12 次内找到 f 。总操作次数 = 2 + 12 = 14 。\n- 如果第一枚鸡蛋没有再次碎掉，则按照类似的方法从 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99 和 100 楼分别扔下第一枚鸡蛋。\n不管结果如何，最多需要扔 14 次来确定 f 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1885.统计数对",
        "hardRate": "MEDIUM",
        "passRate": "59.08%",
        "problemsUrl": "https://leetcode.cn/problems/count-pairs-in-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/count-pairs-in-two-arrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1886.判断矩阵经轮转后是否一致",
        "hardRate": "EASY",
        "passRate": "59.35%",
        "problemsUrl": "https://leetcode.cn/problems/determine-whether-matrix-can-be-obtained-by-rotation/",
        "solutionsUrl": "https://leetcode.cn/problems/determine-whether-matrix-can-be-obtained-by-rotation/solution",
        "problemsDesc": "<p>给你两个大小为 <code>n x n</code> 的二进制矩阵 <code>mat</code> 和 <code>target</code> 。现<strong> 以 90 度顺时针轮转 </strong>矩阵 <code>mat</code> 中的元素 <strong>若干次</strong> ，如果能够使 <code>mat</code> 与 <code>target</code> 一致，返回 <code>true</code> ；否则，返回<em> </em><code>false</code><em> 。</em></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/20/grid3.png\" style=\"width: 301px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>mat = [[0,1],[1,0]], target = [[1,0],[0,1]]\n<strong>输出：</strong>true\n<strong>解释：</strong>顺时针轮转 90 度一次可以使 mat 和 target 一致。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/20/grid4.png\" style=\"width: 301px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>mat = [[0,1],[1,1]], target = [[1,0],[0,1]]\n<strong>输出：</strong>false\n<strong>解释：</strong>无法通过轮转矩阵中的元素使 equal 与 target 一致。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/26/grid4.png\" style=\"width: 661px; height: 184px;\" />\n<pre>\n<strong>输入：</strong>mat = [[0,0,0],[0,1,0],[1,1,1]], target = [[1,1,1],[0,1,0],[0,0,0]]\n<strong>输出：</strong>true\n<strong>解释：</strong>顺时针轮转 90 度两次可以使 mat 和 target 一致。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == mat.length == target.length</code></li>\n\t<li><code>n == mat[i].length == target[i].length</code></li>\n\t<li><code>1 <= n <= 10</code></li>\n\t<li><code>mat[i][j]</code> 和 <code>target[i][j]</code> 不是 <code>0</code> 就是 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1887.使数组元素相等的减少操作次数",
        "hardRate": "MEDIUM",
        "passRate": "65.54%",
        "problemsUrl": "https://leetcode.cn/problems/reduction-operations-to-make-the-array-elements-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/reduction-operations-to-make-the-array-elements-equal/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，你的目标是令 <code>nums</code> 中的所有元素相等。完成一次减少操作需要遵照下面的几个步骤：</p>\n\n<ol>\n\t<li>找出 <code>nums</code> 中的 <strong>最大</strong> 值。记这个值为 <code>largest</code> 并取其下标 <code>i</code> （<strong>下标从 0 开始计数</strong>）。如果有多个元素都是最大值，则取最小的 <code>i</code> 。</li>\n\t<li>找出 <code>nums</code> 中的 <strong>下一个最大</strong> 值，这个值 <strong>严格小于</strong> <code>largest</code> ，记为 <code>nextLargest</code> 。</li>\n\t<li>将 <code>nums[i]</code> 减少到 <code>nextLargest</code> 。</li>\n</ol>\n\n<p>返回使<em> </em><code>nums</code><em> </em>中的所有元素相等的操作次数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,1,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>需要 3 次操作使 nums 中的所有元素相等：\n1. largest = 5 下标为 0 。nextLargest = 3 。将 nums[0] 减少到 3 。nums = [<strong>3</strong>,1,3] 。\n2. largest = 3 下标为 0 。nextLargest = 1 。将 nums[0] 减少到 1 。nums = [<strong>1</strong>,1,3] 。\n3. largest = 3 下标为 2 。nextLargest = 1 。将 nums[2] 减少到 1 。nums = [<strong>1</strong>,1,<strong>1</strong>] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1]\n<strong>输出：</strong>0\n<strong>解释：</strong>nums 中的所有元素已经是相等的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,2,2,3]\n<strong>输出：</strong>4\n<strong>解释：</strong>需要 4 次操作使 nums 中的所有元素相等：\n1. largest = 3 下标为 4 。nextLargest = 2 。将 nums[4] 减少到 2 。nums = [1,1,2,2,<strong>2</strong>] 。\n2. largest = 2 下标为 2 。nextLargest = 1 。将 nums[2] 减少到 1 。nums = [1,1,<strong>1</strong>,2,2] 。 \n3. largest = 2 下标为 3 。nextLargest = 1 。将 nums[3] 减少到 1 。nums = [1,1,1,<strong>1</strong>,2] 。 \n4. largest = 2 下标为 4 。nextLargest = 1 。将 nums[4] 减少到 1 。nums = [1,1,1,1,<strong>1</strong>] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= nums[i] <= 5 * 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1888.使二进制字符串字符交替的最少反转次数",
        "hardRate": "MEDIUM",
        "passRate": "36.54%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/solution",
        "problemsDesc": "<p>给你一个二进制字符串 <code>s</code> 。你可以按任意顺序执行以下两种操作任意次：</p>\n\n<ul>\n\t<li><strong>类型 1 ：删除</strong> 字符串 <code>s</code> 的第一个字符并将它 <strong>添加</strong> 到字符串结尾。</li>\n\t<li><strong>类型 2 ：选择 </strong>字符串 <code>s</code> 中任意一个字符并将该字符 <strong>反转 </strong>，也就是如果值为 <code>'0'</code> ，则反转得到 <code>'1'</code> ，反之亦然。</li>\n</ul>\n\n<p>请你返回使 <code>s</code> 变成 <strong>交替</strong> 字符串的前提下， <strong>类型 2 </strong>的 <strong>最少</strong> 操作次数 。</p>\n\n<p>我们称一个字符串是 <strong>交替</strong> 的，需要满足任意相邻字符都不同。</p>\n\n<ul>\n\t<li>比方说，字符串 <code>\"010\"</code> 和 <code>\"1010\"</code> 都是交替的，但是字符串 <code>\"0100\"</code> 不是。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"111000\"\n<b>输出：</b>2\n<b>解释：</b>执行第一种操作两次，得到 s = \"100011\" 。\n然后对第三个和第六个字符执行第二种操作，得到 s = \"10<strong>1</strong>01<strong>0</strong>\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"010\"\n<b>输出：</b>0\n<strong>解释：</strong>字符串已经是交替的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>s = \"1110\"\n<b>输出：</b>1\n<b>解释：</b>对第二个字符执行第二种操作，得到 s = \"1<strong>0</strong>10\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 要么是 <code>'0'</code> ，要么是 <code>'1'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1889.装包裹的最小浪费空间",
        "hardRate": "HARD",
        "passRate": "29.54%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-space-wasted-from-packaging/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-space-wasted-from-packaging/solution",
        "problemsDesc": "<p>给你 <code>n</code> 个包裹，你需要把它们装在箱子里，<strong>每个箱子装一个包裹</strong>。总共有 <code>m</code> 个供应商提供 <strong>不同尺寸</strong> 的箱子（每个规格都有无数个箱子）。如果一个包裹的尺寸 <strong>小于等于</strong> 一个箱子的尺寸，那么这个包裹就可以放入这个箱子之中。</p>\n\n<p>包裹的尺寸用一个整数数组 <code>packages</code> 表示，其中 <code>packages[i]</code> 是第 <code>i</code> 个包裹的尺寸。供应商用二维数组 <code>boxes</code> 表示，其中 <code>boxes[j]</code> 是第 <code>j</code> 个供应商提供的所有箱子尺寸的数组。</p>\n\n<p>你想要选择 <strong>一个供应商</strong> 并只使用该供应商提供的箱子，使得 <strong>总浪费空间最小</strong> 。对于每个装了包裹的箱子，我们定义 <strong>浪费的</strong> 空间等于 <code>箱子的尺寸 - 包裹的尺寸</code> 。<strong>总浪费空间</strong> 为 <strong>所有</strong> 箱子中浪费空间的总和。</p>\n\n<ul>\n\t<li>比方说，如果你想要用尺寸数组为 <code>[4,8]</code> 的箱子装下尺寸为 <code>[2,3,5]</code> 的包裹，你可以将尺寸为 <code>2</code> 和 <code>3</code> 的两个包裹装入两个尺寸为 <code>4</code> 的箱子中，同时把尺寸为 <code>5</code> 的包裹装入尺寸为 <code>8</code> 的箱子中。总浪费空间为 <code>(4-2) + (4-3) + (8-5) = 6</code> 。</li>\n</ul>\n\n<p>请你选择 <strong>最优</strong> 箱子供应商，使得 <strong>总浪费空间最小</strong> 。如果 <strong>无法</strong> 将所有包裹放入箱子中，请你返回 <code>-1</code> 。由于答案可能会 <strong>很大</strong> ，请返回它对<strong> </strong><code>10<sup>9</sup> + 7</code> <b>取余</b> 的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>packages = [2,3,5], boxes = [[4,8],[2,8]]\n<b>输出：</b>6\n<b>解释：</b>选择第一个供应商最优，用两个尺寸为 4 的箱子和一个尺寸为 8 的箱子。\n总浪费空间为 (4-2) + (4-3) + (8-5) = 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>packages = [2,3,5], boxes = [[1,4],[2,3],[3,4]]\n<b>输出：</b>-1\n<b>解释：</b>没有箱子能装下尺寸为 5 的包裹。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>packages = [3,5,8,10,11,12], boxes = [[12],[11,9],[10,5,14]]\n<b>输出：</b>9\n<b>解释：</b>选择第三个供应商最优，用两个尺寸为 5 的箱子，两个尺寸为 10 的箱子和两个尺寸为 14 的箱子。\n总浪费空间为 (5-3) + (5-5) + (10-8) + (10-10) + (14-11) + (14-12) = 9 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == packages.length</code></li>\n\t<li><code>m == boxes.length</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= m <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= packages[i] <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= boxes[j].length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= boxes[j][k] <= 10<sup>5</sup></code></li>\n\t<li><code>sum(boxes[j].length) <= 10<sup>5</sup></code></li>\n\t<li><code>boxes[j]</code> 中的元素 <strong>互不相同</strong> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1890.2020年最后一次登录",
        "hardRate": "EASY",
        "passRate": "69.96%",
        "problemsUrl": "https://leetcode.cn/problems/the-latest-login-in-2020/",
        "solutionsUrl": "https://leetcode.cn/problems/the-latest-login-in-2020/solution",
        "problemsDesc": "<p>表: <code>Logins</code></p>\n\n<pre>\n+----------------+----------+\n| 列名           | 类型      |\n+----------------+----------+\n| user_id        | int      |\n| time_stamp     | datetime |\n+----------------+----------+\n(user_id, time_stamp) 是这个表的主键。\n每一行包含的信息是user_id 这个用户的登录时间。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个 SQL 查询，该查询可以获取在 <code>2020</code> 年登录过的所有用户的本年度 <strong>最后一次 </strong>登录时间。结果集 <strong>不</strong> 包含 <code>2020</code> 年没有登录过的用户。</p>\n\n<p>返回的结果集可以按 <strong>任意顺序 </strong>排列。</p>\n\n<p>查询结果格式如下例。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nLogins 表:\n+---------+---------------------+\n| user_id | time_stamp          |\n+---------+---------------------+\n| 6       | 2020-06-30 15:06:07 |\n| 6       | 2021-04-21 14:06:06 |\n| 6       | 2019-03-07 00:18:15 |\n| 8       | 2020-02-01 05:10:53 |\n| 8       | 2020-12-30 00:46:50 |\n| 2       | 2020-01-16 02:49:50 |\n| 2       | 2019-08-25 07:59:08 |\n| 14      | 2019-07-14 09:00:00 |\n| 14      | 2021-01-06 11:59:59 |\n+---------+---------------------+\n<strong>输出：</strong>\n+---------+---------------------+\n| user_id | last_stamp          |\n+---------+---------------------+\n| 6       | 2020-06-30 15:06:07 |\n| 8       | 2020-12-30 00:46:50 |\n| 2       | 2020-01-16 02:49:50 |\n+---------+---------------------+\n<strong>解释：</strong>\n6号用户登录了3次，但是在2020年仅有一次，所以结果集应包含此次登录。\n8号用户在2020年登录了2次，一次在2月，一次在12月，所以，结果集应该包含12月的这次登录。\n2号用户登录了2次，但是在2020年仅有一次，所以结果集应包含此次登录。\n14号用户在2020年没有登录，所以结果集不应包含。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1891.割绳子",
        "hardRate": "MEDIUM",
        "passRate": "42.15%",
        "problemsUrl": "https://leetcode.cn/problems/cutting-ribbons/",
        "solutionsUrl": "https://leetcode.cn/problems/cutting-ribbons/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1892.页面推荐Ⅱ",
        "hardRate": "HARD",
        "passRate": "37.72%",
        "problemsUrl": "https://leetcode.cn/problems/page-recommendations-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/page-recommendations-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1893.检查是否区域内所有整数都被覆盖",
        "hardRate": "EASY",
        "passRate": "58.86%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-all-the-integers-in-a-range-are-covered/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-all-the-integers-in-a-range-are-covered/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>ranges</code> 和两个整数 <code>left</code> 和 <code>right</code> 。每个 <code>ranges[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 表示一个从 <code>start<sub>i</sub></code> 到 <code>end<sub>i</sub></code> 的 <strong>闭区间</strong> 。</p>\n\n<p>如果闭区间 <code>[left, right]</code> 内每个整数都被 <code>ranges</code> 中 <strong>至少一个</strong> 区间覆盖，那么请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p>已知区间 <code>ranges[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> ，如果整数 <code>x</code> 满足 <code>start<sub>i</sub> <= x <= end<sub>i</sub></code> ，那么我们称整数<code>x</code> 被覆盖了。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5\n<b>输出：</b>true\n<b>解释：</b>2 到 5 的每个整数都被覆盖了：\n- 2 被第一个区间覆盖。\n- 3 和 4 被第二个区间覆盖。\n- 5 被第三个区间覆盖。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>ranges = [[1,10],[10,20]], left = 21, right = 21\n<b>输出：</b>false\n<b>解释：</b>21 没有被任何一个区间覆盖。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= ranges.length <= 50</code></li>\n\t<li><code>1 <= start<sub>i</sub> <= end<sub>i</sub> <= 50</code></li>\n\t<li><code>1 <= left <= right <= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1894.找到需要补充粉笔的学生编号",
        "hardRate": "MEDIUM",
        "passRate": "45.84%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-student-that-will-replace-the-chalk/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-student-that-will-replace-the-chalk/solution",
        "problemsDesc": "<p>一个班级里有&nbsp;<code>n</code>&nbsp;个学生，编号为 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;。每个学生会依次回答问题，编号为 <code>0</code>&nbsp;的学生先回答，然后是编号为 <code>1</code>&nbsp;的学生，以此类推，直到编号为 <code>n - 1</code>&nbsp;的学生，然后老师会重复这个过程，重新从编号为 <code>0</code>&nbsp;的学生开始回答问题。</p>\n\n<p>给你一个长度为 <code>n</code>&nbsp;且下标从 <code>0</code>&nbsp;开始的整数数组&nbsp;<code>chalk</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。一开始粉笔盒里总共有&nbsp;<code>k</code>&nbsp;支粉笔。当编号为&nbsp;<code>i</code>&nbsp;的学生回答问题时，他会消耗 <code>chalk[i]</code>&nbsp;支粉笔。如果剩余粉笔数量 <strong>严格小于</strong>&nbsp;<code>chalk[i]</code>&nbsp;，那么学生 <code>i</code>&nbsp;需要 <strong>补充</strong>&nbsp;粉笔。</p>\n\n<p>请你返回需要 <strong>补充</strong>&nbsp;粉笔的学生 <strong>编号</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>chalk = [5,1,5], k = 22\n<b>输出：</b>0\n<strong>解释：</strong>学生消耗粉笔情况如下：\n- 编号为 0 的学生使用 5 支粉笔，然后 k = 17 。\n- 编号为 1 的学生使用 1 支粉笔，然后 k = 16 。\n- 编号为 2 的学生使用 5 支粉笔，然后 k = 11 。\n- 编号为 0 的学生使用 5 支粉笔，然后 k = 6 。\n- 编号为 1 的学生使用 1 支粉笔，然后 k = 5 。\n- 编号为 2 的学生使用 5 支粉笔，然后 k = 0 。\n编号为 0 的学生没有足够的粉笔，所以他需要补充粉笔。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>chalk = [3,4,1,2], k = 25\n<b>输出：</b>1\n<b>解释：</b>学生消耗粉笔情况如下：\n- 编号为 0 的学生使用 3 支粉笔，然后 k = 22 。\n- 编号为 1 的学生使用 4 支粉笔，然后 k = 18 。\n- 编号为 2 的学生使用 1 支粉笔，然后 k = 17 。\n- 编号为 3 的学生使用 2 支粉笔，然后 k = 15 。\n- 编号为 0 的学生使用 3 支粉笔，然后 k = 12 。\n- 编号为 1 的学生使用 4 支粉笔，然后 k = 8 。\n- 编号为 2 的学生使用 1 支粉笔，然后 k = 7 。\n- 编号为 3 的学生使用 2 支粉笔，然后 k = 5 。\n- 编号为 0 的学生使用 3 支粉笔，然后 k = 2 。\n编号为 1 的学生没有足够的粉笔，所以他需要补充粉笔。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>chalk.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= chalk[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1895.最大的幻方",
        "hardRate": "MEDIUM",
        "passRate": "56.32%",
        "problemsUrl": "https://leetcode.cn/problems/largest-magic-square/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-magic-square/solution",
        "problemsDesc": "<p>一个 <code>k x k</code> 的<strong> 幻方</strong> 指的是一个 <code>k x k</code> 填满整数的方格阵，且每一行、每一列以及两条对角线的和 <strong>全部</strong><strong>相等</strong> 。幻方中的整数 <strong>不需要互不相同</strong> 。显然，每个 <code>1 x 1</code> 的方格都是一个幻方。</p>\n\n<p>给你一个 <code>m x n</code> 的整数矩阵 <code>grid</code> ，请你返回矩阵中 <strong>最大幻方</strong> 的 <strong>尺寸</strong> （即边长 <code>k</code>）。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/29/magicsquare-grid.jpg\" style=\"width: 413px; height: 335px;\">\n<pre><b>输入：</b>grid = [[7,1,4,5,6],[2,5,1,6,4],[1,5,4,3,2],[1,2,7,3,4]]\n<b>输出：</b>3\n<b>解释：</b>最大幻方尺寸为 3 。\n每一行，每一列以及两条对角线的和都等于 12 。\n- 每一行的和：5+1+6 = 5+4+3 = 2+7+3 = 12\n- 每一列的和：5+5+2 = 1+4+7 = 6+3+3 = 12\n- 对角线的和：5+4+3 = 6+4+2 = 12\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/29/magicsquare2-grid.jpg\" style=\"width: 333px; height: 255px;\">\n<pre><b>输入：</b>grid = [[5,1,3,1],[9,3,3,1],[1,3,3,8]]\n<b>输出：</b>2\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1896.反转表达式值的最少操作次数",
        "hardRate": "HARD",
        "passRate": "51.63%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-change-the-final-value-of-expression/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-change-the-final-value-of-expression/solution",
        "problemsDesc": "<p>给你一个 <strong>有效的</strong> 布尔表达式，用字符串 <code>expression</code> 表示。这个字符串包含字符 <code>'1'</code>，<code>'0'</code>，<code>'&amp;'</code>（按位 <strong>与</strong> 运算），<code>'|'</code>（按位 <strong>或</strong> 运算），<code>'('</code> 和 <code>')'</code> 。</p>\n\n<ul>\n\t<li>比方说，<code>\"()1|1\"</code> 和 <code>\"(1)&amp;()\"</code> <strong>不是有效</strong> 布尔表达式。而 <code>\"1\"</code>， <code>\"(((1))|(0))\"</code> 和 <code>\"1|(0&amp;(1))\"</code> 是 <strong>有效</strong> 布尔表达式。</li>\n</ul>\n\n<p>你的目标是将布尔表达式的 <strong>值</strong> <strong>反转 </strong>（也就是将 <code>0</code> 变为 <code>1</code> ，或者将 <code>1</code> 变为 <code>0</code>），请你返回达成目标需要的 <strong>最少操作</strong> 次数。</p>\n\n<ul>\n\t<li>比方说，如果表达式 <code>expression = \"1|1|(0&amp;0)&amp;1\"</code> ，它的 <strong>值</strong> 为 <code>1|1|(0&amp;0)&amp;1 = 1|1|0&amp;1 = 1|0&amp;1 = 1&amp;1 = 1</code> 。我们想要执行操作将 <strong>新的</strong> 表达式的值变成 <code>0</code> 。</li>\n</ul>\n\n<p>可执行的 <strong>操作</strong> 如下：</p>\n\n<ul>\n\t<li>将一个 <code>'1'</code> 变成一个 <code>'0'</code> 。</li>\n\t<li>将一个 <code>'0'</code> 变成一个 <code>'1'</code> 。</li>\n\t<li>将一个 <code>'&amp;'</code> 变成一个 <code>'|'</code> 。</li>\n\t<li>将一个 <code>'|'</code> 变成一个 <code>'&amp;'</code> 。</li>\n</ul>\n\n<p><strong>注意：</strong><code>'&amp;'</code> 的 <strong>运算优先级</strong> 与 <code>'|'</code> <strong>相同</strong> 。计算表达式时，括号优先级 <strong>最高</strong> ，然后按照 <strong>从左到右</strong> 的顺序运算。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>expression = \"1&amp;(0|1)\"\n<b>输出：</b>1\n<b>解释：</b>我们可以将 \"1&amp;(0<strong>|</strong>1)\" 变成 \"1&amp;(0<strong>&amp;</strong>1)\" ，执行的操作为将一个 '|' 变成一个 '&amp;' ，执行了 1 次操作。\n新表达式的值为 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>expression = \"(0&amp;0)&amp;(0&amp;0&amp;0)\"\n<b>输出：</b>3\n<b>解释：</b>我们可以将 \"(0<strong>&amp;0</strong>)<strong>&amp;</strong>(0&amp;0&amp;0)\" 变成 \"(0<strong>|1</strong>)<strong>|</strong>(0&amp;0&amp;0)\" ，执行了 3 次操作。\n新表达式的值为 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>expression = \"(0|(1|0&amp;1))\"\n<b>输出：</b>1\n<b>解释：</b>我们可以将 \"(0|(<strong>1</strong>|0&amp;1))\" 变成 \"(0|(<strong>0</strong>|0&amp;1))\" ，执行了 1 次操作。\n新表达式的值为 0 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= expression.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>expression</code> 只包含 <code>'1'</code>，<code>'0'</code>，<code>'&amp;'</code>，<code>'|'</code>，<code>'('</code> 和 <code>')'</code></li>\n\t<li>所有括号都有与之匹配的对应括号。</li>\n\t<li>不会有空的括号（也就是说 <code>\"()\"</code> 不是 <code>expression</code> 的子字符串）。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1897.重新分配字符使所有字符串都相等",
        "hardRate": "EASY",
        "passRate": "55.27%",
        "problemsUrl": "https://leetcode.cn/problems/redistribute-characters-to-make-all-strings-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/redistribute-characters-to-make-all-strings-equal/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>words</code>（下标 <strong>从 0 开始</strong> 计数）。</p>\n\n<p>在一步操作中，需先选出两个 <strong>不同</strong> 下标 <code>i</code> 和 <code>j</code>，其中 <code>words[i]</code> 是一个非空字符串，接着将 <code>words[i]</code> 中的 <strong>任一</strong> 字符移动到 <code>words[j]</code> 中的 <strong>任一</strong> 位置上。</p>\n\n<p>如果执行任意步操作可以使 <code>words</code> 中的每个字符串都相等，返回 <code>true</code><em> </em>；否则，返回<em> </em><code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"abc\",\"aabc\",\"bc\"]\n<strong>输出：</strong>true\n<strong>解释：</strong>将 <code>words[1] 中的第一个</code> 'a' 移动到<code> words[2] 的最前面。\n使 </code><code>words[1]</code> = \"abc\" 且 words[2] = \"abc\" 。\n所有字符串都等于 \"abc\" ，所以返回 <code>true</code> 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"ab\",\"a\"]\n<strong>输出：</strong>false\n<strong>解释：</strong>执行操作无法使所有字符串都相等。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><code>words[i]</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1898.可移除字符的最大数目",
        "hardRate": "MEDIUM",
        "passRate": "38.11%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-removable-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-removable-characters/solution",
        "problemsDesc": "<p>给你两个字符串 <code>s</code> 和 <code>p</code> ，其中 <code>p</code> 是 <code>s</code> 的一个 <strong>子序列</strong> 。同时，给你一个元素 <strong>互不相同</strong> 且下标 <strong>从 0 开始</strong> 计数的整数数组 <code>removable</code> ，该数组是 <code>s</code> 中下标的一个子集（<code>s</code> 的下标也 <strong>从 0 开始</strong> 计数）。</p>\n\n<p>请你找出一个整数 <code>k</code>（<code>0 <= k <= removable.length</code>），选出 <code>removable</code> 中的 <strong>前</strong> <code>k</code> 个下标，然后从 <code>s</code> 中移除这些下标对应的 <code>k</code> 个字符。整数 <code>k</code> 需满足：在执行完上述步骤后， <code>p</code> 仍然是 <code>s</code> 的一个 <strong>子序列</strong> 。更正式的解释是，对于每个 <code>0 <= i < k</code> ，先标记出位于 <code>s[removable[i]]</code> 的字符，接着移除所有标记过的字符，然后检查 <code>p</code> 是否仍然是 <code>s</code> 的一个子序列。</p>\n\n<p>返回你可以找出的 <strong>最大</strong><em> </em><code>k</code><em> </em>，满足在移除字符后<em> </em><code>p</code><em> </em>仍然是 <code>s</code> 的一个子序列。</p>\n\n<p>字符串的一个 <strong>子序列</strong> 是一个由原字符串生成的新字符串，生成过程中可能会移除原字符串中的一些字符（也可能不移除）但不改变剩余字符之间的相对顺序。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcacb\", p = \"ab\", removable = [3,1,0]\n<strong>输出：</strong>2\n<strong>解释：</strong>在移除下标 3 和 1 对应的字符后，\"a<strong>b</strong>c<strong>a</strong>cb\" 变成 \"accb\" 。\n\"ab\" 是 \"<strong>a</strong>cc<strong>b</strong>\" 的一个子序列。\n如果移除下标 3、1 和 0 对应的字符后，\"<strong>ab</strong>c<strong>a</strong>cb\" 变成 \"ccb\" ，那么 \"ab\" 就不再是 s 的一个子序列。\n因此，最大的 k 是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcbddddd\", p = \"abcd\", removable = [3,2,1,4,5,6]\n<strong>输出：</strong>1\n<strong>解释：</strong>在移除下标 3 对应的字符后，\"abc<strong>b</strong>ddddd\" 变成 \"abcddddd\" 。\n\"abcd\" 是 \"<strong>abcd</strong>dddd\" 的一个子序列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcab\", p = \"abc\", removable = [0,1,2,3,4]\n<strong>输出：</strong>0\n<strong>解释：</strong>如果移除数组 removable 的第一个下标，\"abc\" 就不再是 s 的一个子序列。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= p.length <= s.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= removable.length < s.length</code></li>\n\t<li><code>0 <= removable[i] < s.length</code></li>\n\t<li><code>p</code> 是 <code>s</code> 的一个 <strong>子字符串</strong></li>\n\t<li><code>s</code> 和 <code>p</code> 都由小写英文字母组成</li>\n\t<li><code>removable</code> 中的元素 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1899.合并若干三元组以形成目标三元组",
        "hardRate": "MEDIUM",
        "passRate": "65.44%",
        "problemsUrl": "https://leetcode.cn/problems/merge-triplets-to-form-target-triplet/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-triplets-to-form-target-triplet/solution",
        "problemsDesc": "<p><strong>三元组</strong> 是一个由三个整数组成的数组。给你一个二维整数数组 <code>triplets</code> ，其中 <code>triplets[i] = [a<sub>i</sub>, b<sub>i</sub>, c<sub>i</sub>]</code> 表示第 <code>i</code> 个 <strong>三元组</strong> 。同时，给你一个整数数组 <code>target = [x, y, z]</code> ，表示你想要得到的 <strong>三元组</strong> 。</p>\n\n<p>为了得到 <code>target</code> ，你需要对 <code>triplets</code> 执行下面的操作 <strong>任意次</strong>（可能 <strong>零</strong> 次）：</p>\n\n<ul>\n\t<li>选出两个下标（下标 <strong>从 0 开始</strong> 计数）<code>i</code> 和 <code>j</code>（<code>i != j</code>），并 <strong>更新</strong> <code>triplets[j]</code> 为 <code>[max(a<sub>i</sub>, a<sub>j</sub>), max(b<sub>i</sub>, b<sub>j</sub>), max(c<sub>i</sub>, c<sub>j</sub>)]</code> 。\n\n\t<ul>\n\t\t<li>例如，<code>triplets[i] = [2, 5, 3]</code> 且 <code>triplets[j] = [1, 7, 5]</code>，<code>triplets[j]</code> 将会更新为 <code>[max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5]</code> 。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>如果通过以上操作我们可以使得目标 <strong>三元组</strong> <code>target</code> 成为 <code>triplets</code> 的一个 <strong>元素</strong> ，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>执行下述操作：\n- 选择第一个和最后一个三元组 [<strong>[2,5,3]</strong>,[1,8,4],<strong>[1,7,5]</strong>] 。更新最后一个三元组为 [max(2,1), max(5,7), max(3,5)] = [2,7,5] 。triplets = [[2,5,3],[1,8,4],<strong>[2,7,5]</strong>]\n目标三元组 [2,7,5] 现在是 triplets 的一个元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>triplets = [[1,3,4],[2,5,8]], target = [2,5,8]\n<strong>输出：</strong>true\n<strong>解释：</strong>目标三元组 [2,5,8] 已经是 triplets 的一个元素。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], target = [5,5,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>执行下述操作：\n- 选择第一个和第三个三元组 [<strong>[2,5,3]</strong>,[2,3,4],<strong>[1,2,5]</strong>,[5,2,3]] 。更新第三个三元组为 [max(2,1), max(5,2), max(3,5)] = [2,5,5] 。triplets = [[2,5,3],[2,3,4],<strong>[2,5,5]</strong>,[5,2,3]] 。\n- 选择第三个和第四个三元组 [[2,5,3],[2,3,4],<strong>[2,5,5]</strong>,<strong>[5,2,3]</strong>] 。更新第四个三元组为 [max(2,5), max(5,2), max(5,3)] = [5,5,5] 。triplets = [[2,5,3],[2,3,4],[2,5,5],<strong>[5,5,5]</strong>] 。\n目标三元组 [5,5,5] 现在是 triplets 的一个元素。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>triplets = [[3,4,5],[4,5,6]], target = [3,2,5]\n<strong>输出：</strong>false\n<strong>解释：</strong>无法得到 [3,2,5] ，因为 triplets 不含 2 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= triplets.length <= 10<sup>5</sup></code></li>\n\t<li><code>triplets[i].length == target.length == 3</code></li>\n\t<li><code>1 <= a<sub>i</sub>, b<sub>i</sub>, c<sub>i</sub>, x, y, z <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1900.最佳运动员的比拼回合",
        "hardRate": "HARD",
        "passRate": "46.01%",
        "problemsUrl": "https://leetcode.cn/problems/the-earliest-and-latest-rounds-where-players-compete/",
        "solutionsUrl": "https://leetcode.cn/problems/the-earliest-and-latest-rounds-where-players-compete/solution",
        "problemsDesc": "<p><code>n</code> 名运动员参与一场锦标赛，所有运动员站成一排，并根据 <strong>最开始的</strong> 站位从 <code>1</code> 到 <code>n</code> 编号（运动员 <code>1</code> 是这一排中的第一个运动员，运动员 <code>2</code> 是第二个运动员，依此类推）。</p>\n\n<p>锦标赛由多个回合组成（从回合 <code>1</code> 开始）。每一回合中，这一排从前往后数的第 <code>i</code> 名运动员需要与从后往前数的第 <code>i</code> 名运动员比拼，获胜者将会进入下一回合。如果当前回合中运动员数目为奇数，那么中间那位运动员将轮空晋级下一回合。</p>\n\n<ul>\n\t<li>例如，当前回合中，运动员 <code>1, 2, 4, 6, 7</code> 站成一排\n\n\t<ul>\n\t\t<li>运动员 <code>1</code> 需要和运动员 <code>7</code> 比拼</li>\n\t\t<li>运动员 <code>2</code> 需要和运动员 <code>6</code> 比拼</li>\n\t\t<li>运动员 <code>4</code> 轮空晋级下一回合</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>每回合结束后，获胜者将会基于最开始分配给他们的原始顺序（升序）重新排成一排。</p>\n\n<p>编号为 <code>firstPlayer</code> 和 <code>secondPlayer</code> 的运动员是本场锦标赛中的最佳运动员。在他们开始比拼之前，完全可以战胜任何其他运动员。而任意两个其他运动员进行比拼时，其中任意一个都有获胜的可能，因此你可以 <strong>裁定</strong> 谁是这一回合的获胜者。</p>\n\n<p>给你三个整数 <code>n</code>、<code>firstPlayer</code> 和 <code>secondPlayer</code> 。返回一个由两个值组成的整数数组，分别表示两位最佳运动员在本场锦标赛中比拼的 <strong>最早</strong> 回合数和 <strong>最晚</strong> 回合数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 11, firstPlayer = 2, secondPlayer = 4\n<strong>输出：</strong>[3,4]\n<strong>解释：</strong>\n一种能够产生最早回合数的情景是：\n回合 1：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n回合 2：2, 3, 4, 5, 6, 11\n回合 3：2, 3, 4\n一种能够产生最晚回合数的情景是：\n回合 1：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n回合 2：1, 2, 3, 4, 5, 6\n回合 3：1, 2, 4\n回合 4：2, 4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 5, firstPlayer = 1, secondPlayer = 5\n<strong>输出：</strong>[1,1]\n<strong>解释：</strong>两名最佳运动员 1 和 5 将会在回合 1 进行比拼。\n不存在使他们在其他回合进行比拼的可能。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 28</code></li>\n\t<li><code>1 &lt;= firstPlayer &lt; secondPlayer &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    }
]