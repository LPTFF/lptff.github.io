[
    {
        "problemsName": " 251.展开二维向量",
        "hardRate": "MEDIUM",
        "passRate": "54.88%",
        "problemsUrl": "https://leetcode.cn/problems/flatten-2d-vector/",
        "solutionsUrl": "https://leetcode.cn/problems/flatten-2d-vector/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 252.会议室",
        "hardRate": "EASY",
        "passRate": "57.77%",
        "problemsUrl": "https://leetcode.cn/problems/meeting-rooms/",
        "solutionsUrl": "https://leetcode.cn/problems/meeting-rooms/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 253.会议室 II",
        "hardRate": "MEDIUM",
        "passRate": "52.21%",
        "problemsUrl": "https://leetcode.cn/problems/meeting-rooms-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/meeting-rooms-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 254.因子的组合",
        "hardRate": "MEDIUM",
        "passRate": "57.01%",
        "problemsUrl": "https://leetcode.cn/problems/factor-combinations/",
        "solutionsUrl": "https://leetcode.cn/problems/factor-combinations/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 255.验证前序遍历序列二叉搜索树",
        "hardRate": "MEDIUM",
        "passRate": "49.59%",
        "problemsUrl": "https://leetcode.cn/problems/verify-preorder-sequence-in-binary-search-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/verify-preorder-sequence-in-binary-search-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 256.粉刷房子",
        "hardRate": "MEDIUM",
        "passRate": "69.86%",
        "problemsUrl": "https://leetcode.cn/problems/paint-house/",
        "solutionsUrl": "https://leetcode.cn/problems/paint-house/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 257.二叉树的所有路径",
        "hardRate": "EASY",
        "passRate": "70.69%",
        "problemsUrl": "https://leetcode.cn/problems/binary-tree-paths/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-tree-paths/solution",
        "problemsDesc": "<p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>\n\n<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg\" style=\"width: 207px; height: 293px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,null,5]\n<strong>输出：</strong>[\"1-&gt;2-&gt;5\",\"1-&gt;3\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[\"1\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 100]</code> 内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 258.各位相加",
        "hardRate": "EASY",
        "passRate": "71.02%",
        "problemsUrl": "https://leetcode.cn/problems/add-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/add-digits/solution",
        "problemsDesc": "<p>给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> num =<strong> </strong><code>38</code>\n<strong>输出:</strong> 2 \n<strong>解释: </strong>各位相加的过程为<strong>：\n</strong>38 --&gt; 3 + 8 --&gt; 11\n11 --&gt; 1 + 1 --&gt; 2\n由于&nbsp;<code>2</code> 是一位数，所以返回 2。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> num =<strong> </strong>0\n<strong>输出:</strong> 0</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以不使用循环或者递归，在 <code>O(1)</code> 时间复杂度内解决这个问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 259.较小的三数之和",
        "hardRate": "MEDIUM",
        "passRate": "55.05%",
        "problemsUrl": "https://leetcode.cn/problems/3sum-smaller/",
        "solutionsUrl": "https://leetcode.cn/problems/3sum-smaller/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 260.只出现一次的数字 III",
        "hardRate": "MEDIUM",
        "passRate": "71.93%",
        "problemsUrl": "https://leetcode.cn/problems/single-number-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/single-number-iii/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>\n\n<p>你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,3,2,5]\n<strong>输出：</strong>[3,5]\n<strong>解释：</strong>[5, 3] 也是有效的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,0]\n<strong>输出：</strong>[-1,0]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1]\n<strong>输出：</strong>[1,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>除两个只出现一次的整数外，<code>nums</code> 中的其他数字都出现两次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 261.以图判树",
        "hardRate": "MEDIUM",
        "passRate": "51.03%",
        "problemsUrl": "https://leetcode.cn/problems/graph-valid-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/graph-valid-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 262.行程和用户",
        "hardRate": "HARD",
        "passRate": "41.57%",
        "problemsUrl": "https://leetcode.cn/problems/trips-and-users/",
        "solutionsUrl": "https://leetcode.cn/problems/trips-and-users/solution",
        "problemsDesc": "表：<code>Trips</code>\n<div class=\"original__bRMd\">\n<div>\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| id          | int      |\n| client_id   | int      |\n| driver_id   | int      |\n| city_id     | int      |\n| status      | enum     |\n| request_at  | date     |     \n+-------------+----------+\nid 是这张表的主键。\n这张表中存所有出租车的行程信息。每段行程有唯一 id ，其中 client_id 和 driver_id 是 Users 表中 users_id 的外键。\nstatus 是一个表示行程状态的枚举类型，枚举成员为(‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>表：<code>Users</code></p>\n</div>\n</div>\n\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| users_id    | int      |\n| banned      | enum     |\n| role        | enum     |\n+-------------+----------+\nusers_id 是这张表的主键。\n这张表中存所有用户，每个用户都有一个唯一的 users_id ，role 是一个表示用户身份的枚举类型，枚举成员为 (‘client’, ‘driver’, ‘partner’) 。\nbanned 是一个表示用户是否被禁止的枚举类型，枚举成员为 (‘Yes’, ‘No’) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>取消率</strong> 的计算方式如下：(被司机或乘客取消的非禁止用户生成的订单数量) / (非禁止用户生成的订单总数)。</p>\n\n<p>写一段 SQL 语句查出&nbsp;<code>\"2013-10-01\"</code><strong>&nbsp;</strong>至&nbsp;<code>\"2013-10-03\"</code><strong>&nbsp;</strong>期间非禁止用户（<strong>乘客和司机都必须未被禁止</strong>）的取消率。非禁止用户即 banned 为 No 的用户，禁止用户即 banned 为 Yes 的用户。</p>\n\n<p>返回结果表中的数据可以按任意顺序组织。其中取消率 <code>Cancellation Rate</code> 需要四舍五入保留 <strong>两位小数</strong> 。</p>\n\n<p>查询结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong> \nTrips 表：\n+----+-----------+-----------+---------+---------------------+------------+\n| id | client_id | driver_id | city_id | status              | request_at |\n+----+-----------+-----------+---------+---------------------+------------+\n| 1  | 1         | 10        | 1       | completed           | 2013-10-01 |\n| 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 |\n| 3  | 3         | 12        | 6       | completed           | 2013-10-01 |\n| 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 |\n| 5  | 1         | 10        | 1       | completed           | 2013-10-02 |\n| 6  | 2         | 11        | 6       | completed           | 2013-10-02 |\n| 7  | 3         | 12        | 6       | completed           | 2013-10-02 |\n| 8  | 2         | 12        | 12      | completed           | 2013-10-03 |\n| 9  | 3         | 10        | 12      | completed           | 2013-10-03 |\n| 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |\n+----+-----------+-----------+---------+---------------------+------------+\n\nUsers 表：\n+----------+--------+--------+\n| users_id | banned | role   |\n+----------+--------+--------+\n| 1        | No     | client |\n| 2        | Yes    | client |\n| 3        | No     | client |\n| 4        | No     | client |\n| 10       | No     | driver |\n| 11       | No     | driver |\n| 12       | No     | driver |\n| 13       | No     | driver |\n+----------+--------+--------+\n<strong>输出：</strong>\n+------------+-------------------+\n| Day        | Cancellation Rate |\n+------------+-------------------+\n| 2013-10-01 | 0.33              |\n| 2013-10-02 | 0.00              |\n| 2013-10-03 | 0.50              |\n+------------+-------------------+\n<strong>解释：</strong>\n2013-10-01：\n  - 共有 4 条请求，其中 2 条取消。\n  - 然而，id=2 的请求是由禁止用户（user_id=2）发出的，所以计算时应当忽略它。\n  - 因此，总共有 3 条非禁止请求参与计算，其中 1 条取消。\n  - 取消率为 (1 / 3) = 0.33\n2013-10-02：\n  - 共有 3 条请求，其中 0 条取消。\n  - 然而，id=6 的请求是由禁止用户发出的，所以计算时应当忽略它。\n  - 因此，总共有 2 条非禁止请求参与计算，其中 0 条取消。\n  - 取消率为 (0 / 2) = 0.00\n2013-10-03：\n  - 共有 3 条请求，其中 1 条取消。\n  - 然而，id=8 的请求是由禁止用户发出的，所以计算时应当忽略它。\n  - 因此，总共有 2 条非禁止请求参与计算，其中 1 条取消。\n  - 取消率为 (1 / 2) = 0.50\n</pre>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 263.丑数",
        "hardRate": "EASY",
        "passRate": "50.52%",
        "problemsUrl": "https://leetcode.cn/problems/ugly-number/",
        "solutionsUrl": "https://leetcode.cn/problems/ugly-number/solution",
        "problemsDesc": "<p><strong>丑数 </strong>就是只包含质因数&nbsp;<code>2</code>、<code>3</code> 和 <code>5</code>&nbsp;的正整数。</p>\n\n<p>给你一个整数 <code>n</code> ，请你判断 <code>n</code> 是否为 <strong>丑数</strong> 。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6\n<strong>输出：</strong>true\n<strong>解释：</strong>6 = 2 × 3</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>true\n<strong>解释：</strong>1 没有质因数，因此它的全部质因数是 {2, 3, 5} 的空集。习惯上将其视作第一个丑数。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 14\n<strong>输出：</strong>false\n<strong>解释：</strong>14 不是丑数，因为它包含了另外一个质因数&nbsp;<code>7 </code>。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 264.丑数 II",
        "hardRate": "MEDIUM",
        "passRate": "58.60%",
        "problemsUrl": "https://leetcode.cn/problems/ugly-number-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/ugly-number-ii/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，请你找出并返回第 <code>n</code> 个 <strong>丑数</strong> 。</p>\n\n<p><strong>丑数 </strong>就是只包含质因数 <code>2</code>、<code>3</code> 和/或 <code>5</code> 的正整数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10\n<strong>输出：</strong>12\n<strong>解释：</strong>[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>1 通常被视为丑数。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 1690</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 265.粉刷房子 II",
        "hardRate": "HARD",
        "passRate": "63.52%",
        "problemsUrl": "https://leetcode.cn/problems/paint-house-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/paint-house-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 266.回文排列",
        "hardRate": "EASY",
        "passRate": "70.14%",
        "problemsUrl": "https://leetcode.cn/problems/palindrome-permutation/",
        "solutionsUrl": "https://leetcode.cn/problems/palindrome-permutation/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 267.回文排列 II",
        "hardRate": "MEDIUM",
        "passRate": "46.88%",
        "problemsUrl": "https://leetcode.cn/problems/palindrome-permutation-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/palindrome-permutation-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 268.丢失的数字",
        "hardRate": "EASY",
        "passRate": "66.33%",
        "problemsUrl": "https://leetcode.cn/problems/missing-number/",
        "solutionsUrl": "https://leetcode.cn/problems/missing-number/solution",
        "problemsDesc": "<p>给定一个包含 <code>[0, n]</code>&nbsp;中&nbsp;<code>n</code>&nbsp;个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,0,1]\n<strong>输出：</strong>2\n<b>解释：</b>n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1]\n<strong>输出：</strong>2\n<b>解释：</b>n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [9,6,4,2,3,5,7,0,1]\n<strong>输出：</strong>8\n<b>解释：</b>n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>1\n<b>解释：</b>n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= n</code></li>\n\t<li><code>nums</code> 中的所有数字都 <strong>独一无二</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 269.火星词典",
        "hardRate": "HARD",
        "passRate": "36.58%",
        "problemsUrl": "https://leetcode.cn/problems/alien-dictionary/",
        "solutionsUrl": "https://leetcode.cn/problems/alien-dictionary/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 270.最接近的二叉搜索树值",
        "hardRate": "EASY",
        "passRate": "56.64%",
        "problemsUrl": "https://leetcode.cn/problems/closest-binary-search-tree-value/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-binary-search-tree-value/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 271.字符串的编码与解码",
        "hardRate": "MEDIUM",
        "passRate": "57.75%",
        "problemsUrl": "https://leetcode.cn/problems/encode-and-decode-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/encode-and-decode-strings/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 272.最接近的二叉搜索树值 II",
        "hardRate": "HARD",
        "passRate": "66.08%",
        "problemsUrl": "https://leetcode.cn/problems/closest-binary-search-tree-value-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-binary-search-tree-value-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 273.整数转换英文表示",
        "hardRate": "HARD",
        "passRate": "36.49%",
        "problemsUrl": "https://leetcode.cn/problems/integer-to-english-words/",
        "solutionsUrl": "https://leetcode.cn/problems/integer-to-english-words/solution",
        "problemsDesc": "<p>将非负整数 <code>num</code> 转换为其对应的英文表示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 123\n<strong>输出：</strong>\"One Hundred Twenty Three\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 12345\n<strong>输出：</strong>\"Twelve Thousand Three Hundred Forty Five\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 1234567\n<strong>输出：</strong>\"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 274.H 指数",
        "hardRate": "MEDIUM",
        "passRate": "44.49%",
        "problemsUrl": "https://leetcode.cn/problems/h-index/",
        "solutionsUrl": "https://leetcode.cn/problems/h-index/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>citations</code> ，其中 <code>citations[i]</code> 表示研究者的第 <code>i</code> 篇论文被引用的次数。计算并返回该研究者的 <strong><code>h</code><em>&nbsp;</em>指数</strong>。</p>\n\n<p>根据维基百科上&nbsp;<a href=\"https://baike.baidu.com/item/h-index/3991452?fr=aladdin\" target=\"_blank\">h 指数的定义</a>：<code>h</code> 代表“高引用次数” ，一名科研人员的 <code>h</code><strong> 指数 </strong>是指他（她）至少发表了 <code>h</code> 篇论文，并且每篇论文<strong> 至少</strong> 被引用 <code>h</code> 次。如果 <code>h</code><em> </em>有多种可能的值，<strong><code>h</code> 指数 </strong>是其中最大的那个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong><code>citations = [3,0,6,1,5]</code>\n<strong>输出：</strong>3 \n<strong>解释：</strong>给定数组表示研究者总共有 <code>5</code> 篇论文，每篇论文相应的被引用了 <code>3, 0, 6, 1, 5</code> 次。\n&nbsp;    由于研究者有 <code>3 </code>篇论文每篇 <strong>至少 </strong>被引用了 <code>3</code> 次，其余两篇论文每篇被引用 <strong>不多于</strong> <code>3</code> 次，所以她的 <em>h </em>指数是 <code>3</code>。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>citations = [1,3,1]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == citations.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>0 &lt;= citations[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 275.H 指数 II",
        "hardRate": "MEDIUM",
        "passRate": "45.13%",
        "problemsUrl": "https://leetcode.cn/problems/h-index-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/h-index-ii/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>citations</code> ，其中 <code>citations[i]</code> 表示研究者的第 <code>i</code> 篇论文被引用的次数，<code>citations</code> 已经按照&nbsp;<strong>升序排列&nbsp;</strong>。计算并返回该研究者的 h<strong><em>&nbsp;</em></strong>指数。</p>\n\n<p><a href=\"https://baike.baidu.com/item/h-index/3991452?fr=aladdin\" target=\"_blank\">h 指数的定义</a>：h 代表“高引用次数”（high citations），一名科研人员的 <code>h</code> 指数是指他（她）的 （<code>n</code> 篇论文中）<strong>总共</strong>有 <code>h</code> 篇论文分别被引用了<strong>至少</strong> <code>h</code> 次。</p>\n\n<p>请你设计并实现对数时间复杂度的算法解决此问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入<code>：</code></strong><code>citations = [0,1,3,5,6]</code>\n<strong>输出：</strong>3 \n<strong>解释：</strong>给定数组表示研究者总共有 <code>5</code> 篇论文，每篇论文相应的被引用了 0<code>, 1, 3, 5, 6</code> 次。\n&nbsp;    由于研究者有 <code>3 </code>篇论文每篇<strong> 至少 </strong>被引用了 <code>3</code> 次，其余两篇论文每篇被引用<strong> 不多于</strong> <code>3</code> 次，所以她的<em> h </em>指数是 <code>3</code> 。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>citations = [1,2,100]\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == citations.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= citations[i] &lt;= 1000</code></li>\n\t<li><code>citations</code> 按 <strong>升序排列</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 276.栅栏涂色",
        "hardRate": "MEDIUM",
        "passRate": "53.56%",
        "problemsUrl": "https://leetcode.cn/problems/paint-fence/",
        "solutionsUrl": "https://leetcode.cn/problems/paint-fence/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 277.搜寻名人",
        "hardRate": "MEDIUM",
        "passRate": "57.83%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-celebrity/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-celebrity/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 278.第一个错误的版本",
        "hardRate": "EASY",
        "passRate": "45.34%",
        "problemsUrl": "https://leetcode.cn/problems/first-bad-version/",
        "solutionsUrl": "https://leetcode.cn/problems/first-bad-version/solution",
        "problemsDesc": "<p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>\n\n<p>假设你有 <code>n</code> 个版本 <code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。</p>\n\n<p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 <code>version</code> 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>\n \n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, bad = 4\n<strong>输出：</strong>4\n<strong>解释：</strong>\n<code>调用 isBadVersion(3) -> false \n调用 isBadVersion(5) -> true \n调用 isBadVersion(4) -> true</code>\n<code>所以，4 是第一个错误的版本。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, bad = 1\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= bad <= n <= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 279.完全平方数",
        "hardRate": "MEDIUM",
        "passRate": "66.20%",
        "problemsUrl": "https://leetcode.cn/problems/perfect-squares/",
        "solutionsUrl": "https://leetcode.cn/problems/perfect-squares/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p>\n\n<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = <code>12</code>\n<strong>输出：</strong>3 \n<strong>解释：</strong><code>12 = 4 + 4 + 4</code></pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = <code>13</code>\n<strong>输出：</strong>2\n<strong>解释：</strong><code>13 = 4 + 9</code></pre>\n&nbsp;\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 280.摆动排序",
        "hardRate": "MEDIUM",
        "passRate": "68.86%",
        "problemsUrl": "https://leetcode.cn/problems/wiggle-sort/",
        "solutionsUrl": "https://leetcode.cn/problems/wiggle-sort/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 281.锯齿迭代器",
        "hardRate": "MEDIUM",
        "passRate": "76.77%",
        "problemsUrl": "https://leetcode.cn/problems/zigzag-iterator/",
        "solutionsUrl": "https://leetcode.cn/problems/zigzag-iterator/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 282.给表达式添加运算符",
        "hardRate": "HARD",
        "passRate": "46.88%",
        "problemsUrl": "https://leetcode.cn/problems/expression-add-operators/",
        "solutionsUrl": "https://leetcode.cn/problems/expression-add-operators/solution",
        "problemsDesc": "<p>给定一个仅包含数字&nbsp;<code>0-9</code>&nbsp;的字符串 <code>num</code> 和一个目标值整数 <code>target</code> ，在 <code>num</code> 的数字之间添加 <strong>二元 </strong>运算符（不是一元）<code>+</code>、<code>-</code>&nbsp;或&nbsp;<code>*</code>&nbsp;，返回 <strong>所有</strong> 能够得到 <code>target </code>的表达式。</p>\n\n<p>注意，返回表达式中的操作数 <strong>不应该</strong> 包含前导零。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>num = </code>\"123\", target = 6\n<strong>输出: </strong>[\"1+2+3\", \"1*2*3\"] \n<strong>解释: </strong>“1*2*3” 和 “1+2+3” 的值都是6。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>num = </code>\"232\", target = 8\n<strong>输出: </strong>[\"2*3+2\", \"2+3*2\"]\n<strong>解释:</strong> “2*3+2” 和 “2+3*2” 的值都是8。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>num = </code>\"3456237490\", target = 9191\n<strong>输出: </strong>[]\n<strong>解释: </strong>表达式 “3456237490” 无法得到 9191 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 10</code></li>\n\t<li><code>num</code> 仅含数字</li>\n\t<li><code>-2<sup>31</sup> &lt;= target &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 283.移动零",
        "hardRate": "EASY",
        "passRate": "63.79%",
        "problemsUrl": "https://leetcode.cn/problems/move-zeroes/",
        "solutionsUrl": "https://leetcode.cn/problems/move-zeroes/solution",
        "problemsDesc": "<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>\n\n<p><strong>请注意</strong>&nbsp;，必须在不复制数组的情况下原地对数组进行操作。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = <code>[0,1,0,3,12]</code>\n<strong>输出:</strong> <code>[1,3,12,0,0]</code>\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = <code>[0]</code>\n<strong>输出:</strong> <code>[0]</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示</strong>:</p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= nums[i] &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>进阶：</b>你能尽量减少完成的操作次数吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 284.顶端迭代器",
        "hardRate": "MEDIUM",
        "passRate": "76.56%",
        "problemsUrl": "https://leetcode.cn/problems/peeking-iterator/",
        "solutionsUrl": "https://leetcode.cn/problems/peeking-iterator/solution",
        "problemsDesc": "<p>请你在设计一个迭代器，在集成现有迭代器拥有的&nbsp;<code>hasNext</code> 和 <code>next</code> 操作的基础上，还额外支持 <code>peek</code> 操作。</p>\n\n<p>实现 <code>PeekingIterator</code> 类：</p>\n\n<ul>\n\t<li><code>PeekingIterator(Iterator&lt;int&gt; nums)</code> 使用指定整数迭代器&nbsp;<code>nums</code> 初始化迭代器。</li>\n\t<li><code>int next()</code> 返回数组中的下一个元素，并将指针移动到下个元素处。</li>\n\t<li><code>bool hasNext()</code> 如果数组中存在下一个元素，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n\t<li><code>int peek()</code> 返回数组中的下一个元素，但 <strong>不</strong> 移动指针。</li>\n</ul>\n\n<p><strong>注意：</strong>每种语言可能有不同的构造函数和迭代器&nbsp;<code>Iterator</code>，但均支持 <code>int next()</code> 和 <code>boolean hasNext()</code> 函数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"PeekingIterator\", \"next\", \"peek\", \"next\", \"next\", \"hasNext\"]\n[[[1, 2, 3]], [], [], [], [], []]\n<strong>输出：</strong>\n[null, 1, 2, 2, 3, false]\n\n<strong>解释：</strong>\nPeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [<u><strong>1</strong></u>,2,3]\npeekingIterator.next();    // 返回 1 ，指针移动到下一个元素 [1,<u><strong>2</strong></u>,3]\npeekingIterator.peek();    // 返回 2 ，指针未发生移动 [1,<u><strong>2</strong></u>,3]\npeekingIterator.next();    // 返回 2 ，指针移动到下一个元素 [1,2,<u><strong>3</strong></u>]\npeekingIterator.next();    // 返回 3 ，指针移动到下一个元素 [1,2,3]\npeekingIterator.hasNext(); // 返回 False\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>对 <code>next</code> 和 <code>peek</code> 的调用均有效</li>\n\t<li><code>next</code>、<code>hasNext</code> 和 <code>peek </code>最多调用&nbsp; <code>1000</code> 次</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你将如何拓展你的设计？使之变得通用化，从而适应所有的类型，而不只是整数型？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 285.二叉搜索树中的中序后继",
        "hardRate": "MEDIUM",
        "passRate": "64.43%",
        "problemsUrl": "https://leetcode.cn/problems/inorder-successor-in-bst/",
        "solutionsUrl": "https://leetcode.cn/problems/inorder-successor-in-bst/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 286.墙与门",
        "hardRate": "MEDIUM",
        "passRate": "54.90%",
        "problemsUrl": "https://leetcode.cn/problems/walls-and-gates/",
        "solutionsUrl": "https://leetcode.cn/problems/walls-and-gates/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 287.寻找重复数",
        "hardRate": "MEDIUM",
        "passRate": "64.23%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-duplicate-number/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-duplicate-number/solution",
        "problemsDesc": "<p>给定一个包含&nbsp;<code>n + 1</code> 个整数的数组&nbsp;<code>nums</code> ，其数字都在&nbsp;<code>[1, n]</code>&nbsp;范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p>\n\n<p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回&nbsp;<strong>这个重复的数</strong> 。</p>\n\n<p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,4,2,2]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,1,3,4,2]\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums.length == n + 1</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= n</code></li>\n\t<li><code>nums</code> 中 <strong>只有一个整数</strong> 出现 <strong>两次或多次</strong> ，其余整数均只出现 <strong>一次</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>进阶：</b></p>\n\n<ul>\n\t<li>如何证明 <code>nums</code> 中至少存在一个重复的数字?</li>\n\t<li>你可以设计一个线性级时间复杂度 <code>O(n)</code> 的解决方案吗？</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 288.单词的唯一缩写",
        "hardRate": "MEDIUM",
        "passRate": "49.30%",
        "problemsUrl": "https://leetcode.cn/problems/unique-word-abbreviation/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-word-abbreviation/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 289.生命游戏",
        "hardRate": "MEDIUM",
        "passRate": "75.76%",
        "problemsUrl": "https://leetcode.cn/problems/game-of-life/",
        "solutionsUrl": "https://leetcode.cn/problems/game-of-life/solution",
        "problemsDesc": "<p>根据&nbsp;<a href=\"https://baike.baidu.com/item/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/2926434?fr=aladdin\" target=\"_blank\">百度百科</a>&nbsp;，&nbsp;<strong>生命游戏</strong>&nbsp;，简称为 <strong>生命</strong> ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</p>\n\n<p>给定一个包含 <code>m × n</code>&nbsp;个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： <code>1</code> 即为 <strong>活细胞</strong> （live），或 <code>0</code> 即为 <strong>死细胞</strong> （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p>\n\n<ol>\n\t<li>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</li>\n\t<li>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</li>\n\t<li>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</li>\n\t<li>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</li>\n</ol>\n\n<p>下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 <code>m x n</code> 网格面板 <code>board</code> 的当前状态，返回下一个状态。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/26/grid1.jpg\" />\n<pre>\n<strong>输入：</strong>board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\n<strong>输出：</strong>[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/26/grid2.jpg\" />\n<pre>\n<strong>输入：</strong>board = [[1,1],[1,0]]\n<strong>输出：</strong>[[1,1],[1,1]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 25</code></li>\n\t<li><code>board[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。</li>\n\t<li>本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 290.单词规律",
        "hardRate": "EASY",
        "passRate": "44.62%",
        "problemsUrl": "https://leetcode.cn/problems/word-pattern/",
        "solutionsUrl": "https://leetcode.cn/problems/word-pattern/solution",
        "problemsDesc": "<p>给定一种规律 <code>pattern</code>&nbsp;和一个字符串&nbsp;<code>s</code>&nbsp;，判断 <code>s</code>&nbsp;是否遵循相同的规律。</p>\n\n<p>这里的&nbsp;<strong>遵循&nbsp;</strong>指完全匹配，例如，&nbsp;<code>pattern</code>&nbsp;里的每个字母和字符串&nbsp;<code>s</code><strong>&nbsp;</strong>中的每个非空单词之间存在着双向连接的对应规律。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre>\n<strong>输入:</strong> pattern = <code>\"abba\"</code>, s = <code>\"dog cat cat dog\"</code>\n<strong>输出:</strong> true</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong>pattern = <code>\"abba\"</code>, s = <code>\"dog cat cat fish\"</code>\n<strong>输出:</strong> false</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> pattern = <code>\"aaaa\"</code>, s = <code>\"dog cat cat dog\"</code>\n<strong>输出:</strong> false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pattern.length &lt;= 300</code></li>\n\t<li><code>pattern</code>&nbsp;只包含小写英文字母</li>\n\t<li><code>1 &lt;= s.length &lt;= 3000</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母和&nbsp;<code>' '</code></li>\n\t<li><code>s</code>&nbsp;<strong>不包含</strong> 任何前导或尾随对空格</li>\n\t<li><code>s</code>&nbsp;中每个单词都被 <strong>单个空格 </strong>分隔</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 291.单词规律 II",
        "hardRate": "MEDIUM",
        "passRate": "51.83%",
        "problemsUrl": "https://leetcode.cn/problems/word-pattern-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/word-pattern-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 292.Nim 游戏",
        "hardRate": "EASY",
        "passRate": "70.44%",
        "problemsUrl": "https://leetcode.cn/problems/nim-game/",
        "solutionsUrl": "https://leetcode.cn/problems/nim-game/solution",
        "problemsDesc": "<p>你和你的朋友，两个人一起玩&nbsp;<a href=\"https://baike.baidu.com/item/Nim游戏/6737105\" target=\"_blank\">Nim 游戏</a>：</p>\n\n<ul>\n\t<li>桌子上有一堆石头。</li>\n\t<li>你们轮流进行自己的回合，&nbsp;<strong>你作为先手&nbsp;</strong>。</li>\n\t<li>每一回合，轮到的人拿掉&nbsp;1 - 3 块石头。</li>\n\t<li>拿掉最后一块石头的人就是获胜者。</li>\n</ul>\n\n<p>假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 <code>n</code> 的情况下赢得游戏。如果可以赢，返回 <code>true</code>；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong><code>n = 4</code>\n<strong>输出：</strong>false \n<strong>解释：</strong>以下是可能的结果:\n1. 移除1颗石头。你的朋友移走了3块石头，包括最后一块。你的朋友赢了。\n2. 移除2个石子。你的朋友移走2块石头，包括最后一块。你的朋友赢了。\n3.你移走3颗石子。你的朋友移走了最后一块石头。你的朋友赢了。\n在所有结果中，你的朋友是赢家。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 293.翻转游戏",
        "hardRate": "EASY",
        "passRate": "72.69%",
        "problemsUrl": "https://leetcode.cn/problems/flip-game/",
        "solutionsUrl": "https://leetcode.cn/problems/flip-game/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 294.翻转游戏 II",
        "hardRate": "MEDIUM",
        "passRate": "59.53%",
        "problemsUrl": "https://leetcode.cn/problems/flip-game-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/flip-game-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 295.数据流的中位数",
        "hardRate": "HARD",
        "passRate": "53.46%",
        "problemsUrl": "https://leetcode.cn/problems/find-median-from-data-stream/",
        "solutionsUrl": "https://leetcode.cn/problems/find-median-from-data-stream/solution",
        "problemsDesc": "<p><strong>中位数</strong>是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p>\n\n<ul>\n\t<li>例如 <code>arr = [2,3,4]</code>&nbsp;的中位数是 <code>3</code>&nbsp;。</li>\n\t<li>例如&nbsp;<code>arr = [2,3]</code> 的中位数是 <code>(2 + 3) / 2 = 2.5</code> 。</li>\n</ul>\n\n<p>实现 MedianFinder 类:</p>\n\n<ul>\n\t<li>\n\t<p><code>MedianFinder() </code>初始化 <code>MedianFinder</code>&nbsp;对象。</p>\n\t</li>\n\t<li>\n\t<p><code>void addNum(int num)</code> 将数据流中的整数 <code>num</code> 添加到数据结构中。</p>\n\t</li>\n\t<li>\n\t<p><code>double findMedian()</code> 返回到目前为止所有元素的中位数。与实际答案相差&nbsp;<code>10<sup>-5</sup></code>&nbsp;以内的答案将被接受。</p>\n\t</li>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\n[[], [1], [2], [], [3], []]\n<strong>输出</strong>\n[null, null, null, 1.5, null, 2.0]\n\n<strong>解释</strong>\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.addNum(2);    // arr = [1, 2]\nmedianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)\nmedianFinder.addNum(3);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0</pre>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= num &lt;= 10<sup>5</sup></code></li>\n\t<li>在调用 <code>findMedian</code>&nbsp;之前，数据结构中至少有一个元素</li>\n\t<li>最多&nbsp;<code>5 * 10<sup>4</sup></code>&nbsp;次调用&nbsp;<code>addNum</code>&nbsp;和&nbsp;<code>findMedian</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 296.最佳的碰头地点",
        "hardRate": "HARD",
        "passRate": "61.15%",
        "problemsUrl": "https://leetcode.cn/problems/best-meeting-point/",
        "solutionsUrl": "https://leetcode.cn/problems/best-meeting-point/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 297.二叉树的序列化与反序列化",
        "hardRate": "HARD",
        "passRate": "58.88%",
        "problemsUrl": "https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/solution",
        "problemsDesc": "<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>\n\n<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>\n\n<p><strong>提示: </strong>输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 <a href=\"/faq/#binary-tree\">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg\" style=\"width: 442px; height: 324px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,null,null,4,5]\n<strong>输出：</strong>[1,2,3,null,null,4,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中结点数在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-1000 <= Node.val <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 298.二叉树最长连续序列",
        "hardRate": "MEDIUM",
        "passRate": "59.84%",
        "problemsUrl": "https://leetcode.cn/problems/binary-tree-longest-consecutive-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-tree-longest-consecutive-sequence/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 299.猜数字游戏",
        "hardRate": "MEDIUM",
        "passRate": "57.41%",
        "problemsUrl": "https://leetcode.cn/problems/bulls-and-cows/",
        "solutionsUrl": "https://leetcode.cn/problems/bulls-and-cows/solution",
        "problemsDesc": "<p>你在和朋友一起玩 <a href=\"https://baike.baidu.com/item/%E7%8C%9C%E6%95%B0%E5%AD%97/83200?fromtitle=Bulls+and+Cows&amp;fromid=12003488&amp;fr=aladdin\" target=\"_blank\">猜数字（Bulls and Cows）</a>游戏，该游戏规则如下：</p>\n\n<p>写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示：</p>\n\n<ul>\n\t<li>猜测数字中有多少位属于数字和确切位置都猜对了（称为 \"Bulls\"，公牛），</li>\n\t<li>有多少位属于数字猜对了但是位置不对（称为 \"Cows\"，奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。</li>\n</ul>\n\n<p>给你一个秘密数字&nbsp;<code>secret</code> 和朋友猜测的数字&nbsp;<code>guess</code> ，请你返回对朋友这次猜测的提示。</p>\n\n<p>提示的格式为 <code>\"xAyB\"</code> ，<code>x</code> 是公牛个数， <code>y</code> 是奶牛个数，<code>A</code> 表示公牛，<code>B</code>&nbsp;表示奶牛。</p>\n\n<p>请注意秘密数字和朋友猜测的数字都可能含有重复数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>secret = \"1807\", guess = \"7810\"\n<strong>输出：</strong>\"1A3B\"\n<strong>解释：</strong>数字和位置都对（公牛）用 '|' 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。\n\"1807\"\n  |\n\"<em><strong>7</strong></em>8<em><strong>10</strong></em>\"</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>secret = \"1123\", guess = \"0111\"\n<strong>输出：</strong>\"1A1B\"\n<strong>解释：</strong>数字和位置都对（公牛）用 '|' 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。\n\"1123\"        \"1123\"\n  |      or     |\n\"01<em><strong>1</strong></em>1\"        \"011<em><strong>1</strong></em>\"\n注意，两个不匹配的 1 中，只有一个会算作奶牛（数字猜对位置不对）。通过重新排列非公牛数字，其中仅有一个 1 可以成为公牛数字。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= secret.length, guess.length &lt;= 1000</code></li>\n\t<li><code>secret.length == guess.length</code></li>\n\t<li><code>secret</code> 和 <code>guess</code> 仅由数字组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 300.最长递增子序列",
        "hardRate": "MEDIUM",
        "passRate": "54.82%",
        "problemsUrl": "https://leetcode.cn/problems/longest-increasing-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-increasing-subsequence/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>\n\n<p><strong>子序列&nbsp;</strong>是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,9,2,5,3,7,101,18]\n<strong>输出：</strong>4\n<strong>解释：</strong>最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,0,3,2,3]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [7,7,7,7,7,7,7]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2500</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>进阶：</b></p>\n\n<ul>\n\t<li>你能将算法的时间复杂度降低到&nbsp;<code>O(n log(n))</code> 吗?</li>\n</ul>\n",
        "isPlus": false
    }
]