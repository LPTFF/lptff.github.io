[
    {
        "problemsName": " 1651.Hopper 公司查询 III",
        "hardRate": "HARD",
        "passRate": "63.99%",
        "problemsUrl": "https://leetcode.cn/problems/hopper-company-queries-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/hopper-company-queries-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1652.拆炸弹",
        "hardRate": "EASY",
        "passRate": "66.41%",
        "problemsUrl": "https://leetcode.cn/problems/defuse-the-bomb/",
        "solutionsUrl": "https://leetcode.cn/problems/defuse-the-bomb/solution",
        "problemsDesc": "<p>你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 <code>n</code> 的 <strong>循环</strong> 数组 <code>code</code> 以及一个密钥 <code>k</code> 。</p>\n\n<p>为了获得正确的密码，你需要替换掉每一个数字。所有数字会 <strong>同时</strong> 被替换。</p>\n\n<ul>\n\t<li>如果 <code>k > 0</code> ，将第 <code>i</code> 个数字用 <strong>接下来</strong> <code>k</code> 个数字之和替换。</li>\n\t<li>如果 <code>k < 0</code> ，将第 <code>i</code> 个数字用 <strong>之前</strong> <code>k</code> 个数字之和替换。</li>\n\t<li>如果 <code>k == 0</code> ，将第 <code>i</code> 个数字用 <code>0</code> 替换。</li>\n</ul>\n\n<p>由于 <code>code</code> 是循环的， <code>code[n-1]</code> 下一个元素是 <code>code[0]</code> ，且 <code>code[0]</code> 前一个元素是 <code>code[n-1]</code> 。</p>\n\n<p>给你 <strong>循环</strong> 数组 <code>code</code> 和整数密钥 <code>k</code> ，请你返回解密后的结果来拆除炸弹！</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>code = [5,7,1,4], k = 3\n<b>输出：</b>[12,10,16,13]\n<b>解释：</b>每个数字都被接下来 3 个数字之和替换。解密后的密码为 [7+1+4, 1+4+5, 4+5+7, 5+7+1]。注意到数组是循环连接的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>code = [1,2,3,4], k = 0\n<b>输出：</b>[0,0,0,0]\n<b>解释：</b>当 k 为 0 时，所有数字都被 0 替换。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>code = [2,4,9,3], k = -2\n<b>输出：</b>[12,5,6,13]\n<b>解释：</b>解密后的密码为 [3+9, 2+3, 4+2, 9+4] 。注意到数组是循环连接的。如果 k 是负数，那么和为 <strong>之前</strong> 的数字。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == code.length</code></li>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>1 <= code[i] <= 100</code></li>\n\t<li><code>-(n - 1) <= k <= n - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1653.使字符串平衡的最少删除次数",
        "hardRate": "MEDIUM",
        "passRate": "60.99%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-string-balanced/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-string-balanced/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，它仅包含字符&nbsp;<code>'a'</code> 和&nbsp;<code>'b'</code>​​​​ 。</p>\n\n<p>你可以删除&nbsp;<code>s</code>&nbsp;中任意数目的字符，使得&nbsp;<code>s</code> <strong>平衡</strong>&nbsp;。当不存在下标对&nbsp;<code>(i,j)</code>&nbsp;满足&nbsp;<code>i &lt; j</code> ，且&nbsp;<code>s[i] = 'b'</code> 的同时&nbsp;<code>s[j]= 'a'</code> ，此时认为 <code>s</code> 是 <strong>平衡 </strong>的。</p>\n\n<p>请你返回使 <code>s</code>&nbsp;<strong>平衡</strong>&nbsp;的 <strong>最少</strong>&nbsp;删除次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aababbab\"\n<b>输出：</b>2\n<b>解释：</b>你可以选择以下任意一种方案：\n下标从 0 开始，删除第 2 和第 6 个字符（\"aa<strong>b</strong>abb<strong>a</strong>b\" -&gt; \"aaabbb\"），\n下标从 0 开始，删除第 3 和第 6 个字符（\"aab<strong>a</strong>bb<strong>a</strong>b\" -&gt; \"aabbbb\"）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"bbaaaaabb\"\n<b>输出：</b>2\n<b>解释：</b>唯一的最优解是删除最前面两个字符。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code>&nbsp;要么是&nbsp;<code>'a'</code> 要么是&nbsp;<code>'b'</code>​<strong>&nbsp;</strong>。​</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1654.到家的最少跳跃次数",
        "hardRate": "MEDIUM",
        "passRate": "31.21%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-jumps-to-reach-home/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-jumps-to-reach-home/solution",
        "problemsDesc": "<p>有一只跳蚤的家在数轴上的位置 <code>x</code> 处。请你帮助它从位置 <code>0</code> 出发，到达它的家。</p>\n\n<p>跳蚤跳跃的规则如下：</p>\n\n<ul>\n\t<li>它可以 <strong>往前</strong> 跳恰好 <code>a</code> 个位置（即往右跳）。</li>\n\t<li>它可以 <strong>往后</strong> 跳恰好 <code>b</code> 个位置（即往左跳）。</li>\n\t<li>它不能 <strong>连续</strong> 往后跳 <code>2</code> 次。</li>\n\t<li>它不能跳到任何 <code>forbidden</code> 数组中的位置。</li>\n</ul>\n\n<p>跳蚤可以往前跳 <strong>超过</strong> 它的家的位置，但是它 <strong>不能跳到负整数</strong> 的位置。</p>\n\n<p>给你一个整数数组 <code>forbidden</code> ，其中 <code>forbidden[i]</code> 是跳蚤不能跳到的位置，同时给你整数 <code>a</code>， <code>b</code> 和 <code>x</code> ，请你返回跳蚤到家的最少跳跃次数。如果没有恰好到达 <code>x</code> 的可行方案，请你返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>forbidden = [14,4,18,1,15], a = 3, b = 15, x = 9\n<b>输出：</b>3\n<b>解释：</b>往前跳 3 次（0 -> 3 -> 6 -> 9），跳蚤就到家了。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11\n<b>输出：</b>-1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>forbidden = [1,6,2,14,5,17,4], a = 16, b = 9, x = 7\n<b>输出：</b>2\n<b>解释：</b>往前跳一次（0 -> 16），然后往回跳一次（16 -> 7），跳蚤就到家了。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= forbidden.length <= 1000</code></li>\n\t<li><code>1 <= a, b, forbidden[i] <= 2000</code></li>\n\t<li><code>0 <= x <= 2000</code></li>\n\t<li><code>forbidden</code> 中所有位置互不相同。</li>\n\t<li>位置 <code>x</code> 不在 <code>forbidden</code> 中。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1655.分配重复整数",
        "hardRate": "HARD",
        "passRate": "39.53%",
        "problemsUrl": "https://leetcode.cn/problems/distribute-repeating-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/distribute-repeating-integers/solution",
        "problemsDesc": "<p>给你一个长度为&nbsp;<code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;，这个数组中至多有&nbsp;<code>50</code>&nbsp;个不同的值。同时你有 <code>m</code>&nbsp;个顾客的订单 <code>quantity</code>&nbsp;，其中，整数&nbsp;<code>quantity[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;位顾客订单的数目。请你判断是否能将 <code>nums</code>&nbsp;中的整数分配给这些顾客，且满足：</p>\n\n<ul>\n\t<li>第&nbsp;<code>i</code>&nbsp;位顾客 <strong>恰好&nbsp;</strong>有&nbsp;<code>quantity[i]</code>&nbsp;个整数。</li>\n\t<li>第&nbsp;<code>i</code>&nbsp;位顾客拿到的整数都是 <strong>相同的</strong>&nbsp;。</li>\n\t<li>每位顾客都满足上述两个要求。</li>\n</ul>\n\n<p>如果你可以分配 <code>nums</code>&nbsp;中的整数满足上面的要求，那么请返回&nbsp;<code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4], quantity = [2]\n<b>输出：</b>false\n<strong>解释：</strong>第 0 位顾客没办法得到两个相同的整数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,3], quantity = [2]\n<b>输出：</b>true\n<b>解释：</b>第 0 位顾客得到 [3,3] 。整数 [1,2] 都没有被使用。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,1,2,2], quantity = [2,2]\n<b>输出：</b>true\n<b>解释：</b>第 0 位顾客得到 [1,1] ，第 1 位顾客得到 [2,2] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>m == quantity.length</code></li>\n\t<li><code>1 &lt;= m &lt;= 10</code></li>\n\t<li><code>1 &lt;= quantity[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums</code>&nbsp;中至多有&nbsp;<code>50</code>&nbsp;个不同的数字。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1656.设计有序流",
        "hardRate": "EASY",
        "passRate": "84.07%",
        "problemsUrl": "https://leetcode.cn/problems/design-an-ordered-stream/",
        "solutionsUrl": "https://leetcode.cn/problems/design-an-ordered-stream/solution",
        "problemsDesc": "<p>有 <code>n</code> 个 <code>(id, value)</code> 对，其中 <code>id</code> 是 <code>1</code> 到 <code>n</code> 之间的一个整数，<code>value</code> 是一个字符串。不存在 <code>id</code> 相同的两个 <code>(id, value)</code> 对。</p>\n\n<p>设计一个流，以 <strong>任意</strong> 顺序获取 <code>n</code> 个 <code>(id, value)</code> 对，并在多次调用时 <strong>按 <code>id</code> 递增的顺序</strong> 返回一些值。</p>\n\n<p>实现 <code>OrderedStream</code> 类：</p>\n\n<ul>\n\t<li><code>OrderedStream(int n)</code> 构造一个能接收 <code>n</code> 个值的流，并将当前指针 <code>ptr</code> 设为 <code>1</code> 。</li>\n\t<li><code>String[] insert(int id, String value)</code> 向流中存储新的 <code>(id, value)</code> 对。存储后：\n\t<ul>\n\t\t<li>如果流存储有 <code>id = ptr</code> 的 <code>(id, value)</code> 对，则找出从 <code>id = ptr</code> 开始的 <strong>最长 id 连续递增序列</strong> ，并 <strong>按顺序</strong> 返回与这些 id 关联的值的列表。然后，将 <code>ptr</code> 更新为最后那个  <code>id + 1</code> 。</li>\n\t\t<li>\n\t\t<p>否则，返回一个空列表。</p>\n\t\t</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/15/q1.gif\" style=\"width: 682px; height: 240px;\" /></strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"OrderedStream\", \"insert\", \"insert\", \"insert\", \"insert\", \"insert\"]\n[[5], [3, \"ccccc\"], [1, \"aaaaa\"], [2, \"bbbbb\"], [5, \"eeeee\"], [4, \"ddddd\"]]\n<strong>输出</strong>\n[null, [], [\"aaaaa\"], [\"bbbbb\", \"ccccc\"], [], [\"ddddd\", \"eeeee\"]]\n\n<strong>解释</strong>\nOrderedStream os= new OrderedStream(5);\nos.insert(3, \"ccccc\"); // 插入 (3, \"ccccc\")，返回 []\nos.insert(1, \"aaaaa\"); // 插入 (1, \"aaaaa\")，返回 [\"aaaaa\"]\nos.insert(2, \"bbbbb\"); // 插入 (2, \"bbbbb\")，返回 [\"bbbbb\", \"ccccc\"]\nos.insert(5, \"eeeee\"); // 插入 (5, \"eeeee\")，返回 []\nos.insert(4, \"ddddd\"); // 插入 (4, \"ddddd\")，返回 [\"ddddd\", \"eeeee\"]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 1000</code></li>\n\t<li><code>1 <= id <= n</code></li>\n\t<li><code>value.length == 5</code></li>\n\t<li><code>value</code> 仅由小写字母组成</li>\n\t<li>每次调用 <code>insert</code> 都会使用一个唯一的 <code>id</code></li>\n\t<li>恰好调用 <code>n</code> 次 <code>insert</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1657.确定两个字符串是否接近",
        "hardRate": "MEDIUM",
        "passRate": "47.06%",
        "problemsUrl": "https://leetcode.cn/problems/determine-if-two-strings-are-close/",
        "solutionsUrl": "https://leetcode.cn/problems/determine-if-two-strings-are-close/solution",
        "problemsDesc": "<p>如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串 <strong>接近</strong> ：</p>\n\n<ul>\n\t<li>操作 1：交换任意两个 <strong>现有</strong> 字符。\n\n\t<ul>\n\t\t<li>例如，<code>a<strong>b</strong>cd<strong>e</strong> -> a<strong>e</strong>cd<strong>b</strong></code></li>\n\t</ul>\n\t</li>\n\t<li>操作 2：将一个 <strong>现有</strong> 字符的每次出现转换为另一个 <strong>现有</strong> 字符，并对另一个字符执行相同的操作。\n\t<ul>\n\t\t<li>例如，<code><strong>aa</strong>c<strong>abb</strong> -> <strong>bb</strong>c<strong>baa</strong></code>（所有 <code>a</code> 转化为 <code>b</code> ，而所有的 <code>b</code> 转换为 <code>a</code> ）</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>你可以根据需要对任意一个字符串多次使用这两种操作。</p>\n\n<p>给你两个字符串，<code>word1</code> 和 <code>word2</code> 。如果<em> </em><code>word1</code><em> </em>和<em> </em><code>word2</code><em> </em><strong>接近 </strong>，就返回 <code>true</code> ；否则，返回<em> </em><code>false</code><em> </em>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"abc\", word2 = \"bca\"\n<strong>输出：</strong>true\n<strong>解释：</strong>2 次操作从 word1 获得 word2 。\n执行操作 1：\"a<strong>bc</strong>\" -> \"a<strong>cb</strong>\"\n执行操作 1：\"<strong>a</strong>c<strong>b</strong>\" -> \"<strong>b</strong>c<strong>a</strong>\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"a\", word2 = \"aa\"\n<strong>输出：</strong>false\n<strong>解释：</strong>不管执行多少次操作，都无法从 word1 得到 word2 ，反之亦然。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"cabbba\", word2 = \"abbccc\"\n<strong>输出：</strong>true\n<strong>解释：</strong>3 次操作从 word1 获得 word2 。\n执行操作 1：\"ca<strong>b</strong>bb<strong>a</strong>\" -> \"ca<strong>a</strong>bb<strong>b</strong>\"\n执行操作 2：<code>\"</code><strong>c</strong>aa<strong>bbb</strong>\" -> \"<strong>b</strong>aa<strong>ccc</strong>\"\n执行操作 2：\"<strong>baa</strong>ccc\" -> \"<strong>abb</strong>ccc\"\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"cabbba\", word2 = \"aabbss\"\n<strong>输出：</strong>false\n<strong>解释：</strong>不管执行多少次操作，都无法从 word1 得到 word2 ，反之亦然。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word1.length, word2.length <= 10<sup>5</sup></code></li>\n\t<li><code>word1</code> 和 <code>word2</code> 仅包含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1658.将 x 减到 0 的最小操作数",
        "hardRate": "MEDIUM",
        "passRate": "39.26%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>x</code> 。每一次操作时，你应当移除数组 <code>nums</code> 最左边或最右边的元素，然后从 <code>x</code> 中减去该元素的值。请注意，需要 <strong>修改</strong> 数组以供接下来的操作使用。</p>\n\n<p>如果可以将 <code>x</code> <strong>恰好</strong> 减到 <code>0</code> ，返回<strong> 最小操作数 </strong>；否则，返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,4,2,3], x = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>最佳解决方案是移除后两个元素，将 x 减到 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,6,7,8,9], x = 4\n<strong>输出：</strong>-1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,20,1,1,3], x = 10\n<strong>输出：</strong>5\n<strong>解释：</strong>最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= x <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1659.最大化网格幸福感",
        "hardRate": "HARD",
        "passRate": "64.79%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-grid-happiness/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-grid-happiness/solution",
        "problemsDesc": "<p>给你四个整数 <code>m</code>、<code>n</code>、<code>introvertsCount</code> 和 <code>extrovertsCount</code> 。有一个 <code>m x n</code> 网格，和两种类型的人：内向的人和外向的人。总共有 <code>introvertsCount</code> 个内向的人和 <code>extrovertsCount</code> 个外向的人。</p>\n\n<p>请你决定网格中应当居住多少人，并为每个人分配一个网格单元。 注意，<strong>不必</strong> 让所有人都生活在网格中。</p>\n\n<p>每个人的 <strong>幸福感</strong> 计算如下：</p>\n\n<ul>\n\t<li>内向的人 <strong>开始</strong> 时有 <code>120</code> 个幸福感，但每存在一个邻居（内向的或外向的）他都会 <strong>失去</strong>  <code>30</code> 个幸福感。</li>\n\t<li>外向的人 <strong>开始</strong> 时有 <code>40</code> 个幸福感，每存在一个邻居（内向的或外向的）他都会 <strong>得到</strong>  <code>20</code> 个幸福感。</li>\n</ul>\n\n<p>邻居是指居住在一个人所在单元的上、下、左、右四个直接相邻的单元中的其他人。</p>\n\n<p><strong>网格幸福感</strong> 是每个人幸福感的 <strong>总和</strong> 。 返回 <strong>最大可能的网格幸福感</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/15/grid_happiness.png\" style=\"width: 261px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2\n<strong>输出：</strong>240\n<strong>解释：</strong>假设网格坐标 (row, column) 从 1 开始编号。\n将内向的人放置在单元 (1,1) ，将外向的人放置在单元 (1,3) 和 (2,3) 。\n- 位于 (1,1) 的内向的人的幸福感：120（初始幸福感）- (0 * 30)（0 位邻居）= 120\n- 位于 (1,3) 的外向的人的幸福感：40（初始幸福感）+ (1 * 20)（1 位邻居）= 60\n- 位于 (2,3) 的外向的人的幸福感：40（初始幸福感）+ (1 * 20)（1 位邻居）= 60\n网格幸福感为：120 + 60 + 60 = 240\n上图展示该示例对应网格中每个人的幸福感。内向的人在浅绿色单元中，而外向的人在浅紫色单元中。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1\n<strong>输出：</strong>260\n<strong>解释：</strong>将内向的人放置在单元 (1,1) 和 (3,1) ，将外向的人放置在单元 (2,1) 。\n- 位于 (1,1) 的内向的人的幸福感：120（初始幸福感）- (1 * 30)（1 位邻居）= 90\n- 位于 (2,1) 的外向的人的幸福感：40（初始幸福感）+ (2 * 20)（2 位邻居）= 80\n- 位于 (3,1) 的内向的人的幸福感：120（初始幸福感）- (1 * 30)（1 位邻居）= 90\n网格幸福感为 90 + 80 + 90 = 260\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0\n<strong>输出：</strong>240\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= m, n <= 5</code></li>\n\t<li><code>0 <= introvertsCount, extrovertsCount <= min(m * n, 6)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1660.纠正二叉树",
        "hardRate": "MEDIUM",
        "passRate": "76.06%",
        "problemsUrl": "https://leetcode.cn/problems/correct-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/correct-a-binary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1661.每台机器的进程平均运行时间",
        "hardRate": "EASY",
        "passRate": "72.70%",
        "problemsUrl": "https://leetcode.cn/problems/average-time-of-process-per-machine/",
        "solutionsUrl": "https://leetcode.cn/problems/average-time-of-process-per-machine/solution",
        "problemsDesc": "<p>表: <code>Activity</code></p>\n\n<pre>\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| machine_id     | int     |\n| process_id     | int     |\n| activity_type  | enum    |\n| timestamp      | float   |\n+----------------+---------+\n该表展示了一家工厂网站的用户活动.\n(machine_id, process_id, activity_type) 是当前表的主键.\nmachine_id 是一台机器的ID号.\nprocess_id 是运行在各机器上的进程ID号.\nactivity_type 是枚举类型 ('start', 'end').\ntimestamp 是浮点类型,代表当前时间(以秒为单位).\n'start' 代表该进程在这台机器上的开始运行时间戳 , 'end' 代表该进程在这台机器上的终止运行时间戳.\n同一台机器，同一个进程都有一对开始时间戳和结束时间戳，而且开始时间戳永远在结束时间戳前面.</pre>\n\n<p>&nbsp;</p>\n\n<p>现在有一个工厂网站由几台机器运行，每台机器上运行着相同数量的进程. 请写出一条SQL计算每台机器各自完成一个进程任务的平均耗时.</p>\n\n<p>完成一个进程任务的时间指进程的<code>'end' 时间戳</code> 减去&nbsp;<code>'start' 时间戳</code>. 平均耗时通过计算每台机器上所有进程任务的总耗费时间除以机器上的总进程数量获得.</p>\n\n<p>结果表必须包含<code>machine_id（机器ID）</code> 和对应的&nbsp;<strong>average time（平均耗时）</strong>&nbsp;别名&nbsp;<code>processing_time</code>, 且<strong>四舍五入保留3位小数.</strong></p>\n\n<p>以 <strong>任意顺序</strong> 返回表。</p>\n\n<p>具体参考例子如下。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nActivity table:\n+------------+------------+---------------+-----------+\n| machine_id | process_id | activity_type | timestamp |\n+------------+------------+---------------+-----------+\n| 0          | 0          | start         | 0.712     |\n| 0          | 0          | end           | 1.520     |\n| 0          | 1          | start         | 3.140     |\n| 0          | 1          | end           | 4.120     |\n| 1          | 0          | start         | 0.550     |\n| 1          | 0          | end           | 1.550     |\n| 1          | 1          | start         | 0.430     |\n| 1          | 1          | end           | 1.420     |\n| 2          | 0          | start         | 4.100     |\n| 2          | 0          | end           | 4.512     |\n| 2          | 1          | start         | 2.500     |\n| 2          | 1          | end           | 5.000     |\n+------------+------------+---------------+-----------+\n<strong>输出：</strong>\n+------------+-----------------+\n| machine_id | processing_time |\n+------------+-----------------+\n| 0          | 0.894           |\n| 1          | 0.995           |\n| 2          | 1.456           |\n+------------+-----------------+\n<strong>解释：</strong>\n一共有3台机器,每台机器运行着两个进程.\n机器 0 的平均耗时: ((1.520 - 0.712) + (4.120 - 3.140)) / 2 = 0.894\n机器 1 的平均耗时: ((1.550 - 0.550) + (1.420 - 0.430)) / 2 = 0.995\n机器 2 的平均耗时: ((4.512 - 4.100) + (5.000 - 2.500)) / 2 = 1.456</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1662.检查两个字符串数组是否相等",
        "hardRate": "EASY",
        "passRate": "80.99%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-two-string-arrays-are-equivalent/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-two-string-arrays-are-equivalent/solution",
        "problemsDesc": "<p>给你两个字符串数组 <code>word1</code> 和 <code>word2</code> 。如果两个数组表示的字符串相同，返回<em> </em><code>true</code><em> </em>；否则，返回 <code>false</code><em> 。</em></p>\n\n<p><strong>数组表示的字符串</strong> 是由数组中的所有元素 <strong>按顺序</strong> 连接形成的字符串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\n<strong>输出：</strong>true\n<strong>解释：</strong>\nword1 表示的字符串为 \"ab\" + \"c\" -> \"abc\"\nword2 表示的字符串为 \"a\" + \"bc\" -> \"abc\"\n两个字符串相同，返回 true</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\n<strong>输出：</strong>true\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word1.length, word2.length <= 10<sup>3</sup></code></li>\n\t<li><code>1 <= word1[i].length, word2[i].length <= 10<sup>3</sup></code></li>\n\t<li><code>1 <= sum(word1[i].length), sum(word2[i].length) <= 10<sup>3</sup></code></li>\n\t<li><code>word1[i]</code> 和 <code>word2[i]</code> 由小写字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1663.具有给定数值的最小字符串",
        "hardRate": "MEDIUM",
        "passRate": "65.05%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-string-with-a-given-numeric-value/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-string-with-a-given-numeric-value/solution",
        "problemsDesc": "<p><strong>小写字符 </strong>的 <strong>数值</strong> 是它在字母表中的位置（从 <code>1</code> 开始），因此 <code>a</code> 的数值为 <code>1</code> ，<code>b</code> 的数值为 <code>2</code> ，<code>c</code> 的数值为 <code>3</code> ，以此类推。</p>\n\n<p>字符串由若干小写字符组成，<strong>字符串的数值</strong> 为各字符的数值之和。例如，字符串 <code>\"abe\"</code> 的数值等于 <code>1 + 2 + 5 = 8</code> 。</p>\n\n<p>给你两个整数 <code>n</code> 和 <code>k</code> 。返回 <strong>长度</strong> 等于 <code>n</code> 且 <strong>数值</strong> 等于 <code>k</code> 的 <strong>字典序最小</strong> 的字符串。</p>\n\n<p>注意，如果字符串 <code>x</code> 在字典排序中位于 <code>y</code> 之前，就认为 <code>x</code> 字典序比 <code>y</code> 小，有以下两种情况：</p>\n\n<ul>\n\t<li><code>x</code> 是 <code>y</code> 的一个前缀；</li>\n\t<li>如果 <code>i</code> 是 <code>x[i] != y[i]</code> 的第一个位置，且 <code>x[i]</code> 在字母表中的位置比 <code>y[i]</code> 靠前。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 27\n<strong>输出：</strong>\"aay\"\n<strong>解释：</strong>字符串的数值为 1 + 1 + 25 = 27，它是数值满足要求且长度等于 3 字典序最小的字符串。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, k = 73\n<strong>输出：</strong>\"aaszz\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>n <= k <= 26 * n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1664.生成平衡数组的方案数",
        "hardRate": "MEDIUM",
        "passRate": "66.51%",
        "problemsUrl": "https://leetcode.cn/problems/ways-to-make-a-fair-array/",
        "solutionsUrl": "https://leetcode.cn/problems/ways-to-make-a-fair-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。你需要选择 <strong>恰好</strong> 一个下标（下标从 <strong>0</strong> 开始）并删除对应的元素。请注意剩下元素的下标可能会因为删除操作而发生改变。</p>\n\n<p>比方说，如果 <code>nums = [6,1,7,4,1]</code> ，那么：</p>\n\n<ul>\n\t<li>选择删除下标 <code>1</code> ，剩下的数组为 <code>nums = [6,7,4,1]</code> 。</li>\n\t<li>选择删除下标 <code>2</code> ，剩下的数组为 <code>nums = [6,1,4,1]</code> 。</li>\n\t<li>选择删除下标 <code>4</code> ，剩下的数组为 <code>nums = [6,1,7,4]</code> 。</li>\n</ul>\n\n<p>如果一个数组满足奇数下标元素的和与偶数下标元素的和相等，该数组就是一个 <strong>平衡数组</strong> 。</p>\n\n<p>请你返回删除操作后，剩下的数组<em> </em><code>nums</code><em> </em>是 <strong>平衡数组</strong> 的 <strong>方案数</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,1,6,4]\n<b>输出：</b>1\n<strong>解释：</strong>\n删除下标 0 ：[1,6,4] -> 偶数元素下标为：1 + 4 = 5 。奇数元素下标为：6 。不平衡。\n删除下标 1 ：[2,6,4] -> 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：6 。平衡。\n删除下标 2 ：[2,1,4] -> 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：1 。不平衡。\n删除下标 3 ：[2,1,6] -> 偶数元素下标为：2 + 6 = 8 。奇数元素下标为：1 。不平衡。\n只有一种让剩余数组成为平衡数组的方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,1,1]\n<b>输出：</b>3\n<b>解释：</b>你可以删除任意元素，剩余数组都是平衡数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3]\n<b>输出：</b>0\n<b>解释：</b>不管删除哪个元素，剩下数组都不是平衡数组。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1665.完成所有任务的最少初始能量",
        "hardRate": "HARD",
        "passRate": "65.44%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-initial-energy-to-finish-tasks/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-initial-energy-to-finish-tasks/solution",
        "problemsDesc": "<p>给你一个任务数组 <code>tasks</code> ，其中 <code>tasks[i] = [actual<sub>i</sub>, minimum<sub>i</sub>]</code> ：</p>\n\n<ul>\n\t<li><code>actual<sub>i</sub></code> 是完成第 <code>i</code> 个任务 <strong>需要耗费</strong> 的实际能量。</li>\n\t<li><code>minimum<sub>i</sub></code> 是开始第 <code>i</code> 个任务前需要达到的最低能量。</li>\n</ul>\n\n<p>比方说，如果任务为 <code>[10, 12]</code> 且你当前的能量为 <code>11</code> ，那么你不能开始这个任务。如果你当前的能量为 <code>13</code> ，你可以完成这个任务，且完成它后剩余能量为 <code>3</code> 。</p>\n\n<p>你可以按照 <strong>任意顺序</strong> 完成任务。</p>\n\n<p>请你返回完成所有任务的 <strong>最少</strong> 初始能量。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>tasks = [[1,2],[2,4],[4,8]]\n<b>输出：</b>8\n<strong>解释：</strong>\n一开始有 8 能量，我们按照如下顺序完成任务：\n    - 完成第 3 个任务，剩余能量为 8 - 4 = 4 。\n    - 完成第 2 个任务，剩余能量为 4 - 2 = 2 。\n    - 完成第 1 个任务，剩余能量为 2 - 1 = 1 。\n注意到尽管我们有能量剩余，但是如果一开始只有 7 能量是不能完成所有任务的，因为我们无法开始第 3 个任务。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>tasks = [[1,3],[2,4],[10,11],[10,12],[8,9]]\n<b>输出：</b>32\n<strong>解释：</strong>\n一开始有 32 能量，我们按照如下顺序完成任务：\n    - 完成第 1 个任务，剩余能量为 32 - 1 = 31 。\n    - 完成第 2 个任务，剩余能量为 31 - 2 = 29 。\n    - 完成第 3 个任务，剩余能量为 29 - 10 = 19 。\n    - 完成第 4 个任务，剩余能量为 19 - 10 = 9 。\n    - 完成第 5 个任务，剩余能量为 9 - 8 = 1 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>tasks = [[1,7],[2,8],[3,9],[4,10],[5,11],[6,12]]\n<b>输出：</b>27\n<strong>解释：</strong>\n一开始有 27 能量，我们按照如下顺序完成任务：\n    - 完成第 5 个任务，剩余能量为 27 - 5 = 22 。\n    - 完成第 2 个任务，剩余能量为 22 - 2 = 20 。\n    - 完成第 3 个任务，剩余能量为 20 - 3 = 17 。\n    - 完成第 1 个任务，剩余能量为 17 - 1 = 16 。\n    - 完成第 4 个任务，剩余能量为 16 - 4 = 12 。\n    - 完成第 6 个任务，剩余能量为 12 - 6 = 6 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tasks.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= actual<sub>​i</sub> &lt;= minimum<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1666.改变二叉树的根节点",
        "hardRate": "MEDIUM",
        "passRate": "66.92%",
        "problemsUrl": "https://leetcode.cn/problems/change-the-root-of-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/change-the-root-of-a-binary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1667.修复表中的名字",
        "hardRate": "EASY",
        "passRate": "63.54%",
        "problemsUrl": "https://leetcode.cn/problems/fix-names-in-a-table/",
        "solutionsUrl": "https://leetcode.cn/problems/fix-names-in-a-table/solution",
        "problemsDesc": "<p>表： <code>Users</code></p>\n\n<pre>\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| user_id        | int     |\n| name           | varchar |\n+----------------+---------+\nuser_id 是该表的主键。\n该表包含用户的 ID 和名字。名字仅由小写和大写字符组成。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个 SQL 查询来修复名字，使得只有第一个字符是大写的，其余都是小写的。</p>\n\n<p>返回按 <code>user_id</code> 排序的结果表。</p>\n\n<p>查询结果格式示例如下。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nUsers table:\n+---------+-------+\n| user_id | name  |\n+---------+-------+\n| 1       | aLice |\n| 2       | bOB   |\n+---------+-------+\n<strong>输出：</strong>\n+---------+-------+\n| user_id | name  |\n+---------+-------+\n| 1       | Alice |\n| 2       | Bob   |\n+---------+-------+</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1668.最大重复子字符串",
        "hardRate": "EASY",
        "passRate": "47.00%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-repeating-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-repeating-substring/solution",
        "problemsDesc": "<p>给你一个字符串 <code>sequence</code> ，如果字符串 <code>word</code> 连续重复 <code>k</code> 次形成的字符串是 <code>sequence</code> 的一个子字符串，那么单词 <code>word</code> 的 <strong>重复值为 <code>k</code></strong><strong> </strong>。单词 <code>word</code> 的 <strong>最</strong><strong>大重复值</strong> 是单词 <code>word</code> 在 <code>sequence</code> 中最大的重复值。如果 <code>word</code> 不是 <code>sequence</code> 的子串，那么重复值 <code>k</code> 为 <code>0</code> 。</p>\n\n<p>给你一个字符串 <code>sequence</code> 和 <code>word</code> ，请你返回 <strong>最大重复值 <code>k</code> </strong>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>sequence = \"ababc\", word = \"ab\"\n<b>输出：</b>2\n<strong>解释：</strong>\"abab\" 是 \"<strong>abab</strong>c\" 的子字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>sequence = \"ababc\", word = \"ba\"\n<b>输出：</b>1\n<strong>解释：</strong>\"ba\" 是 \"a<strong>ba</strong>bc\" 的子字符串，但 \"baba\" 不是 \"ababc\" 的子字符串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>sequence = \"ababc\", word = \"ac\"\n<b>输出：</b>0\n<strong>解释：</strong>\"ac\" 不是 \"ababc\" 的子字符串。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= sequence.length <= 100</code></li>\n\t<li><code>1 <= word.length <= 100</code></li>\n\t<li><code>sequence</code> 和 <code>word</code> 都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1669.合并两个链表",
        "hardRate": "MEDIUM",
        "passRate": "77.28%",
        "problemsUrl": "https://leetcode.cn/problems/merge-in-between-linked-lists/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-in-between-linked-lists/solution",
        "problemsDesc": "<p>给你两个链表&nbsp;<code>list1</code> 和&nbsp;<code>list2</code>&nbsp;，它们包含的元素分别为&nbsp;<code>n</code> 个和&nbsp;<code>m</code> 个。</p>\n\n<p>请你将&nbsp;<code>list1</code>&nbsp;中下标从 <code>a</code> 到 <code>b</code> 的全部节点都删除，并将<code>list2</code>&nbsp;接在被删除节点的位置。</p>\n\n<p>下图中蓝色边和节点展示了操作后的结果：</p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/28/fig1.png\" style=\"height: 130px; width: 504px;\" />\n<p>请你返回结果链表的头指针。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/28/merge_linked_list_ex1.png\" style=\"width: 406px; height: 140px;\" /></p>\n\n<pre>\n<b>输入：</b>list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]\n<b>输出：</b>[0,1,2,1000000,1000001,1000002,5]\n<b>解释：</b>我们删除 list1 中下标为 3 和 4 的两个节点，并将 list2 接在该位置。上图中蓝色的边和节点为答案链表。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/28/merge_linked_list_ex2.png\" style=\"width: 463px; height: 140px;\" />\n<pre>\n<b>输入：</b>list1 = [0,1,2,3,4,5,6], a = 2, b = 5, list2 = [1000000,1000001,1000002,1000003,1000004]\n<b>输出：</b>[0,1,1000000,1000001,1000002,1000003,1000004,6]\n<b>解释：</b>上图中蓝色的边和节点为答案链表。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= list1.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= a &lt;= b &lt; list1.length - 1</code></li>\n\t<li><code>1 &lt;= list2.length &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1670.设计前中后队列",
        "hardRate": "MEDIUM",
        "passRate": "52.01%",
        "problemsUrl": "https://leetcode.cn/problems/design-front-middle-back-queue/",
        "solutionsUrl": "https://leetcode.cn/problems/design-front-middle-back-queue/solution",
        "problemsDesc": "<p>请你设计一个队列，支持在前，中，后三个位置的 <code>push</code> 和 <code>pop</code> 操作。</p>\n\n<p>请你完成 <code>FrontMiddleBack</code> 类：</p>\n\n<ul>\n\t<li><code>FrontMiddleBack()</code> 初始化队列。</li>\n\t<li><code>void pushFront(int val)</code> 将 <code>val</code> 添加到队列的 <strong>最前面</strong> 。</li>\n\t<li><code>void pushMiddle(int val)</code> 将 <code>val</code> 添加到队列的 <strong>正中间</strong> 。</li>\n\t<li><code>void pushBack(int val)</code> 将 <code>val</code> 添加到队里的 <strong>最后面</strong> 。</li>\n\t<li><code>int popFront()</code> 将 <strong>最前面</strong> 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 <code>-1</code> 。</li>\n\t<li><code>int popMiddle()</code> 将 <b>正中间</b> 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 <code>-1</code> 。</li>\n\t<li><code>int popBack()</code> 将 <strong>最后面</strong> 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 <code>-1</code> 。</li>\n</ul>\n\n<p>请注意当有 <strong>两个</strong> 中间位置的时候，选择靠前面的位置进行操作。比方说：</p>\n\n<ul>\n\t<li>将 <code>6</code> 添加到 <code>[1, 2, 3, 4, 5]</code> 的中间位置，结果数组为 <code>[1, 2, <strong>6</strong>, 3, 4, 5]</code> 。</li>\n\t<li>从 <code>[1, 2, <strong>3</strong>, 4, 5, 6]</code> 的中间位置弹出元素，返回 <code>3</code> ，数组变为 <code>[1, 2, 4, 5, 6]</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"FrontMiddleBackQueue\", \"pushFront\", \"pushBack\", \"pushMiddle\", \"pushMiddle\", \"popFront\", \"popMiddle\", \"popMiddle\", \"popBack\", \"popFront\"]\n[[], [1], [2], [3], [4], [], [], [], [], []]\n<strong>输出：</strong>\n[null, null, null, null, null, 1, 3, 4, 2, -1]\n\n<strong>解释：</strong>\nFrontMiddleBackQueue q = new FrontMiddleBackQueue();\nq.pushFront(1);   // [<strong>1</strong>]\nq.pushBack(2);    // [1, <strong>2</strong>]\nq.pushMiddle(3);  // [1, <strong>3</strong>, 2]\nq.pushMiddle(4);  // [1, <strong>4</strong>, 3, 2]\nq.popFront();     // 返回 1 -> [4, 3, 2]\nq.popMiddle();    // 返回 3 -> [4, 2]\nq.popMiddle();    // 返回 4 -> [2]\nq.popBack();      // 返回 2 -> []\nq.popFront();     // 返回 -1 -> [] （队列为空）\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= val <= 10<sup>9</sup></code></li>\n\t<li>最多调用 <code>1000</code> 次 <code>pushFront</code>， <code>pushMiddle</code>， <code>pushBack</code>， <code>popFront</code>， <code>popMiddle</code> 和 <code>popBack</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1671.得到山形数组的最少删除次数",
        "hardRate": "HARD",
        "passRate": "46.62%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array/solution",
        "problemsDesc": "<p>我们定义&nbsp;<code>arr</code>&nbsp;是 <b>山形数组</b>&nbsp;当且仅当它满足：</p>\n\n<ul>\n\t<li><code>arr.length &gt;= 3</code></li>\n\t<li>存在某个下标&nbsp;<code>i</code>&nbsp;（<strong>从 0 开始</strong>）&nbsp;满足&nbsp;<code>0 &lt; i &lt; arr.length - 1</code>&nbsp;且：\n\t<ul>\n\t\t<li><code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]</code></li>\n\t\t<li><code>arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>给你整数数组&nbsp;<code>nums</code>​ ，请你返回将 <code>nums</code>&nbsp;变成 <strong>山形状数组</strong>&nbsp;的​ <strong>最少</strong>&nbsp;删除次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,3,1]\n<b>输出：</b>0\n<b>解释：</b>数组本身就是山形数组，所以我们不需要删除任何元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,1,1,5,6,2,3,1]\n<b>输出：</b>3\n<b>解释：</b>一种方法是将下标为 0，1 和 5 的元素删除，剩余元素为 [1,5,6,3,1] ，是山形数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>题目保证&nbsp;<code>nums</code> 删除一些元素后一定能得到山形数组。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1672.最富有客户的资产总量",
        "hardRate": "EASY",
        "passRate": "83.70%",
        "problemsUrl": "https://leetcode.cn/problems/richest-customer-wealth/",
        "solutionsUrl": "https://leetcode.cn/problems/richest-customer-wealth/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的整数网格 <code>accounts</code> ，其中 <code>accounts[i][j]</code> 是第 <code>i​​​​​<sup>​​​​​​</sup>​</code> 位客户在第 <code>j</code> 家银行托管的资产数量。返回最富有客户所拥有的 <strong>资产总量</strong> 。</p>\n\n<p>客户的 <strong>资产总量</strong> 就是他们在各家银行托管的资产数量之和。最富有客户就是 <strong>资产总量</strong> 最大的客户。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>accounts = [[1,2,3],[3,2,1]]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n<code>第 1 位客户的资产总量 = 1 + 2 + 3 = 6\n第 2 位客户的资产总量 = 3 + 2 + 1 = 6\n</code>两位客户都是最富有的，资产总量都是 6 ，所以返回 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>accounts = [[1,5],[7,3],[3,5]]\n<strong>输出：</strong>10\n<strong>解释：</strong>\n<code>第 1 位客户的资产总量</code> = 6\n<code>第 2 位客户的资产总量</code> = 10 \n<code>第 3 位客户的资产总量</code> = 8\n第 2 位客户是最富有的，资产总量是 10</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>accounts = [[2,8,7],[7,1,3],[1,9,5]]\n<strong>输出：</strong>17\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == accounts.length</code></li>\n\t<li><code>n == accounts[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>1 &lt;= accounts[i][j] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1673.找出最具竞争力的子序列",
        "hardRate": "MEDIUM",
        "passRate": "39.55%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-most-competitive-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-most-competitive-subsequence/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个正整数 <code>k</code> ，返回长度为 <code>k</code> 且最具 <strong>竞争力</strong> 的<em> </em><code>nums</code> 子序列。</p>\n\n<p>数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。</p>\n\n<p>在子序列 <code>a</code> 和子序列 <code>b</code> 第一个不相同的位置上，如果 <code>a</code> 中的数字小于 <code>b</code> 中对应的数字，那么我们称子序列 <code>a</code> 比子序列 <code>b</code>（相同长度下）更具 <strong>竞争力</strong> 。 例如，<code>[1,3,4]</code> 比 <code>[1,3,5]</code> 更具竞争力，在第一个不相同的位置，也就是最后一个位置上， <code>4</code> 小于 <code>5</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,5,2,6], k = 2\n<strong>输出：</strong>[2,6]\n<strong>解释：</strong>在所有可能的子序列集合 {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 最具竞争力。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,4,3,3,5,4,9,6], k = 4\n<strong>输出：</strong>[2,3,3,4]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= nums[i] <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= k <= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1674.使数组互补的最少操作次数",
        "hardRate": "MEDIUM",
        "passRate": "41.88%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-moves-to-make-array-complementary/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-moves-to-make-array-complementary/solution",
        "problemsDesc": "<p>给你一个长度为<strong> 偶数</strong> <code>n</code> 的整数数组 <code>nums</code> 和一个整数 <code>limit</code> 。每一次操作，你可以将 <code>nums</code> 中的任何整数替换为 <code>1</code> 到 <code>limit</code> 之间的另一个整数。</p>\n\n<p>如果对于所有下标 <code>i</code>（<strong>下标从 </strong><code>0</code><strong> 开始</strong>），<code>nums[i] + nums[n - 1 - i]</code> 都等于同一个数，则数组 <code>nums</code> 是 <strong>互补的</strong> 。例如，数组 <code>[1,2,3,4]</code> 是互补的，因为对于所有下标 <code>i</code> ，<code>nums[i] + nums[n - 1 - i] = 5</code> 。</p>\n\n<p>返回使数组 <strong>互补</strong> 的 <strong>最少</strong> 操作次数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,4,3], limit = 4\n<strong>输出：</strong>1\n<strong>解释：</strong>经过 1 次操作，你可以将数组 nums 变成 [1,2,<strong>2</strong>,3]（加粗元素是变更的数字）：\nnums[0] + nums[3] = 1 + 3 = 4.\nnums[1] + nums[2] = 2 + 2 = 4.\nnums[2] + nums[1] = 2 + 2 = 4.\nnums[3] + nums[0] = 3 + 1 = 4.\n对于每个 i ，nums[i] + nums[n-1-i] = 4 ，所以 nums 是互补的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2,1], limit = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>经过 2 次操作，你可以将数组 nums 变成 [<strong>2</strong>,2,2,<strong>2</strong>] 。你不能将任何数字变更为 3 ，因为 3 > limit 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,2], limit = 2\n<strong>输出：</strong>0\n<strong>解释：</strong>nums 已经是互补的。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>2 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= limit <= 10<sup>5</sup></code></li>\n\t<li><code>n</code> 是偶数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1675.数组的最小偏移量",
        "hardRate": "HARD",
        "passRate": "45.57%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-deviation-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-deviation-in-array/solution",
        "problemsDesc": "<p>给你一个由 <code>n</code> 个正整数组成的数组 <code>nums</code> 。</p>\n\n<p>你可以对数组的任意元素执行任意次数的两类操作：</p>\n\n<ul>\n\t<li>如果元素是<strong> 偶数</strong> ，<strong>除以</strong> <code>2</code>\n\n\t<ul>\n\t\t<li>例如，如果数组是 <code>[1,2,3,4]</code> ，那么你可以对最后一个元素执行此操作，使其变成 <code>[1,2,3,<strong>2</strong>]</code></li>\n\t</ul>\n\t</li>\n\t<li>如果元素是 <strong>奇数</strong> ，<strong>乘上</strong> <code>2</code>\n\t<ul>\n\t\t<li>例如，如果数组是 <code>[1,2,3,4]</code> ，那么你可以对第一个元素执行此操作，使其变成 <code>[<strong>2</strong>,2,3,4]</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>数组的 <strong>偏移量</strong> 是数组中任意两个元素之间的 <strong>最大差值</strong> 。</p>\n\n<p>返回数组在执行某些操作之后可以拥有的 <strong>最小偏移量</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>1\n<strong>解释：</strong>你可以将数组转换为 [1,2,3,<strong>2</strong>]，然后转换成 [<strong>2</strong>,2,3,2]，偏移量是 3 - 2 = 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,1,5,20,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>两次操作后，你可以将数组转换为 [4,<strong>2</strong>,5,<strong>5</strong>,3]，偏移量是 5 - 2 = 3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,10,8]\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 5 * 10<sup><span style=\"font-size: 10.8333px;\">4</span></sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1676.二叉树的最近公共祖先 IV",
        "hardRate": "MEDIUM",
        "passRate": "79.91%",
        "problemsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iv/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1677.发票中的产品金额",
        "hardRate": "EASY",
        "passRate": "35.32%",
        "problemsUrl": "https://leetcode.cn/problems/products-worth-over-invoices/",
        "solutionsUrl": "https://leetcode.cn/problems/products-worth-over-invoices/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1678.设计 Goal 解析器",
        "hardRate": "EASY",
        "passRate": "86.10%",
        "problemsUrl": "https://leetcode.cn/problems/goal-parser-interpretation/",
        "solutionsUrl": "https://leetcode.cn/problems/goal-parser-interpretation/solution",
        "problemsDesc": "<p>请你设计一个可以解释字符串 <code>command</code> 的 <strong>Goal 解析器</strong> 。<code>command</code> 由 <code>\"G\"</code>、<code>\"()\"</code> 和/或 <code>\"(al)\"</code> 按某种顺序组成。Goal 解析器会将 <code>\"G\"</code> 解释为字符串 <code>\"G\"</code>、<code>\"()\"</code> 解释为字符串 <code>\"o\"</code> ，<code>\"(al)\"</code> 解释为字符串 <code>\"al\"</code> 。然后，按原顺序将经解释得到的字符串连接成一个字符串。</p>\n\n<p>给你字符串 <code>command</code> ，返回<em> </em><strong>Goal<em><strong> </strong></em>解析器 </strong>对<em> </em><code>command</code> 的解释结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>command = \"G()(al)\"\n<strong>输出：</strong>\"Goal\"\n<strong>解释：</strong>Goal 解析器解释命令的步骤如下所示：\nG -&gt; G\n() -&gt; o\n(al) -&gt; al\n最后连接得到的结果是 \"Goal\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>command = \"G()()()()(al)\"\n<strong>输出：</strong>\"Gooooal\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>command = \"(al)G(al)()()G\"\n<strong>输出：</strong>\"alGalooG\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= command.length &lt;= 100</code></li>\n\t<li><code>command</code> 由 <code>\"G\"</code>、<code>\"()\"</code> 和/或 <code>\"(al)\"</code> 按某种顺序组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1679.K 和数对的最大数目",
        "hardRate": "MEDIUM",
        "passRate": "54.09%",
        "problemsUrl": "https://leetcode.cn/problems/max-number-of-k-sum-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/max-number-of-k-sum-pairs/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>\n\n<p>每一步操作中，你需要从数组中选出和为 <code>k</code> 的两个整数，并将它们移出数组。</p>\n\n<p>返回你可以对数组执行的最大操作数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4], k = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>开始时 nums = [1,2,3,4]：\n- 移出 1 和 4 ，之后 nums = [2,3]\n- 移出 2 和 3 ，之后 nums = []\n不再有和为 5 的数对，因此最多执行 2 次操作。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,1,3,4,3], k = 6\n<strong>输出：</strong>1\n<strong>解释：</strong>开始时 nums = [3,1,3,4,3]：\n- 移出前两个 3 ，之后nums = [1,4,3]\n不再有和为 6 的数对，因此最多执行 1 次操作。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= k <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1680.连接连续二进制数字",
        "hardRate": "MEDIUM",
        "passRate": "49.97%",
        "problemsUrl": "https://leetcode.cn/problems/concatenation-of-consecutive-binary-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/concatenation-of-consecutive-binary-numbers/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，请你将 <code>1</code> 到 <code>n</code> 的二进制表示连接起来，并返回连接结果对应的 <strong>十进制</strong> 数字对 <code>10<sup>9</sup> + 7</code> 取余的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 1\n<b>输出：</b>1\n<strong>解释：</strong>二进制的 \"1\" 对应着十进制的 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 3\n<b>输出：</b>27\n<strong>解释：</strong>二进制下，1，2 和 3 分别对应 \"1\" ，\"10\" 和 \"11\" 。\n将它们依次连接，我们得到 \"11011\" ，对应着十进制的 27 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>n = 12\n<b>输出：</b>505379714\n<b>解释：</b>连接结果为 \"1101110010111011110001001101010111100\" 。\n对应的十进制数字为 118505380540 。\n对 10<sup>9</sup> + 7 取余后，结果为 505379714 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1681.最小不兼容性",
        "hardRate": "HARD",
        "passRate": "58.84%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-incompatibility/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-incompatibility/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>​​​ 和一个整数 <code>k</code> 。你需要将这个数组划分到 <code>k</code> 个相同大小的子集中，使得同一个子集里面没有两个相同的元素。</p>\n\n<p>一个子集的 <strong>不兼容性</strong> 是该子集里面最大值和最小值的差。</p>\n\n<p>请你返回将数组分成 <code>k</code> 个子集后，各子集 <strong>不兼容性 </strong>的<strong> 和</strong> 的 <strong>最小值</strong> ，如果无法分成分成 <code>k</code> 个子集，返回 <code>-1</code> 。</p>\n\n<p>子集的定义是数组中一些数字的集合，对数字顺序没有要求。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,1,4], k = 2\n<b>输出：</b>4\n<b>解释：</b>最优的分配是 [1,2] 和 [1,4] 。\n不兼容性和为 (2-1) + (4-1) = 4 。\n注意到 [1,1] 和 [2,4] 可以得到更小的和，但是第一个集合有 2 个相同的元素，所以不可行。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [6,3,8,1,3,1,2,2], k = 4\n<b>输出：</b>6\n<b>解释：</b>最优的子集分配为 [1,2]，[2,3]，[6,8] 和 [1,3] 。\n不兼容性和为 (2-1) + (3-2) + (8-6) + (3-1) = 6 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5,3,3,6,3,3], k = 3\n<b>输出：</b>-1\n<b>解释：</b>没办法将这些数字分配到 3 个子集且满足每个子集里没有相同数字。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= k <= nums.length <= 16</code></li>\n\t<li><code>nums.length</code> 能被 <code>k</code> 整除。</li>\n\t<li><code>1 <= nums[i] <= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1682.最长回文子序列 II",
        "hardRate": "MEDIUM",
        "passRate": "57.25%",
        "problemsUrl": "https://leetcode.cn/problems/longest-palindromic-subsequence-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-palindromic-subsequence-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1683.无效的推文",
        "hardRate": "EASY",
        "passRate": "87.12%",
        "problemsUrl": "https://leetcode.cn/problems/invalid-tweets/",
        "solutionsUrl": "https://leetcode.cn/problems/invalid-tweets/solution",
        "problemsDesc": "<p>表：<code>Tweets</code></p>\n\n<pre>+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| tweet_id       | int     |\n| content        | varchar |\n+----------------+---------+\ntweet_id 是这个表的主键。\n这个表包含某社交媒体 App 中所有的推文。</pre>\n\n<p> </p>\n\n<p>写一条 SQL 语句，查询所有无效推文的编号（ID）。当推文内容中的字符数<strong>严格大于</strong> <code>15</code> 时，该推文是无效的。</p>\n\n<p>以<strong>任意顺序</strong>返回结果表。</p>\n\n<p>查询结果格式如下示例所示：</p>\n\n<p> </p>\n\n<pre>Tweets 表：\n+----------+----------------------------------+\n| tweet_id | content                          |\n+----------+----------------------------------+\n| 1        | Vote for Biden                   |\n| 2        | Let us make America great again! |\n+----------+----------------------------------+\n\n结果表：\n+----------+\n| tweet_id |\n+----------+\n| 2        |\n+----------+\n推文 1 的长度 length = 14。该推文是有效的。\n推文 2 的长度 length = 32。该推文是无效的。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1684.统计一致字符串的数目",
        "hardRate": "EASY",
        "passRate": "85.19%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-consistent-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-consistent-strings/solution",
        "problemsDesc": "<p>给你一个由不同字符组成的字符串 <code>allowed</code> 和一个字符串数组 <code>words</code> 。如果一个字符串的每一个字符都在 <code>allowed</code> 中，就称这个字符串是 <strong>一致字符串 </strong>。</p>\n\n<p>请你返回 <code>words</code> 数组中 <strong>一致字符串</strong> 的数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>allowed = \"ab\", words = [\"ad\",\"bd\",\"aaab\",\"baa\",\"badab\"]\n<b>输出：</b>2\n<b>解释：</b>字符串 \"aaab\" 和 \"baa\" 都是一致字符串，因为它们只包含字符 'a' 和 'b' 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>allowed = \"abc\", words = [\"a\",\"b\",\"c\",\"ab\",\"ac\",\"bc\",\"abc\"]\n<b>输出：</b>7\n<b>解释：</b>所有字符串都是一致的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>allowed = \"cad\", words = [\"cc\",\"acd\",\"b\",\"ba\",\"bac\",\"bad\",\"ac\",\"d\"]\n<b>输出：</b>4\n<b>解释：</b>字符串 \"cc\"，\"acd\"，\"ac\" 和 \"d\" 是一致字符串。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= words.length <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= allowed.length <=<sup> </sup>26</code></li>\n\t<li><code>1 <= words[i].length <= 10</code></li>\n\t<li><code>allowed</code> 中的字符 <strong>互不相同</strong> 。</li>\n\t<li><code>words[i]</code> 和 <code>allowed</code> 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1685.有序数组中差绝对值之和",
        "hardRate": "MEDIUM",
        "passRate": "64.89%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-absolute-differences-in-a-sorted-array/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-absolute-differences-in-a-sorted-array/solution",
        "problemsDesc": "<p>给你一个 <strong>非递减 </strong>有序整数数组 <code>nums</code> 。</p>\n\n<p>请你建立并返回一个整数数组<em> </em><code>result</code>，它跟<em> </em><code>nums</code> 长度相同，且<code>result[i]</code> 等于<em> </em><code>nums[i]</code> 与数组中所有其他元素差的绝对值之和。</p>\n\n<p>换句话说， <code>result[i]</code> 等于 <code>sum(|nums[i]-nums[j]|)</code> ，其中 <code>0 <= j < nums.length</code> 且 <code>j != i</code> （下标从 0 开始）。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,3,5]\n<b>输出：</b>[4,3,5]\n<b>解释：</b>假设数组下标从 0 开始，那么\nresult[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4，\nresult[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3，\nresult[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,4,6,8,10]\n<b>输出：</b>[24,15,13,15,21]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= nums[i + 1] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1686.石子游戏 VI",
        "hardRate": "MEDIUM",
        "passRate": "50.21%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game-vi/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game-vi/solution",
        "problemsDesc": "<p>Alice 和 Bob 轮流玩一个游戏，Alice 先手。</p>\n\n<p>一堆石子里总共有 <code>n</code> 个石子，轮到某个玩家时，他可以 <strong>移出</strong> 一个石子并得到这个石子的价值。Alice 和 Bob 对石子价值有 <strong>不一样的的评判标准</strong> 。双方都知道对方的评判标准。</p>\n\n<p>给你两个长度为 <code>n</code> 的整数数组 <code>aliceValues</code> 和 <code>bobValues</code> 。<code>aliceValues[i]</code> 和 <code>bobValues[i]</code> 分别表示 Alice 和 Bob 认为第 <code>i</code> 个石子的价值。</p>\n\n<p>所有石子都被取完后，得分较高的人为胜者。如果两个玩家得分相同，那么为平局。两位玩家都会采用 <b>最优策略</b> 进行游戏。</p>\n\n<p>请你推断游戏的结果，用如下的方式表示：</p>\n\n<ul>\n\t<li>如果 Alice 赢，返回 <code>1</code> 。</li>\n\t<li>如果 Bob 赢，返回 <code>-1</code> 。</li>\n\t<li>如果游戏平局，返回 <code>0</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>aliceValues = [1,3], bobValues = [2,1]\n<b>输出：</b>1\n<strong>解释：</strong>\n如果 Alice 拿石子 1 （下标从 0开始），那么 Alice 可以得到 3 分。\nBob 只能选择石子 0 ，得到 2 分。\nAlice 获胜。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>aliceValues = [1,2], bobValues = [3,1]\n<b>输出：</b>0\n<strong>解释：</strong>\nAlice 拿石子 0 ， Bob 拿石子 1 ，他们得分都为 1 分。\n打平。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>aliceValues = [2,4,3], bobValues = [1,6,7]\n<b>输出：</b>-1\n<strong>解释：</strong>\n不管 Alice 怎么操作，Bob 都可以得到比 Alice 更高的得分。\n比方说，Alice 拿石子 1 ，Bob 拿石子 2 ， Alice 拿石子 0 ，Alice 会得到 6 分而 Bob 得分为 7 分。\nBob 会获胜。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == aliceValues.length == bobValues.length</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= aliceValues[i], bobValues[i] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1687.从仓库到码头运输箱子",
        "hardRate": "HARD",
        "passRate": "58.80%",
        "problemsUrl": "https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/",
        "solutionsUrl": "https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/solution",
        "problemsDesc": "<p>你有一辆货运卡车，你需要用这一辆车把一些箱子从仓库运送到码头。这辆卡车每次运输有&nbsp;<strong>箱子数目的限制</strong>&nbsp;和 <strong>总重量的限制</strong>&nbsp;。</p>\n\n<p>给你一个箱子数组&nbsp;<code>boxes</code>&nbsp;和三个整数 <code>portsCount</code>, <code>maxBoxes</code>&nbsp;和&nbsp;<code>maxWeight</code>&nbsp;，其中&nbsp;<code>boxes[i] = [ports<sub>​​i</sub>​, weight<sub>i</sub>]</code>&nbsp;。</p>\n\n<ul>\n\t<li><code>ports<sub>​​i</sub></code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个箱子需要送达的码头，&nbsp;<code>weights<sub>i</sub></code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个箱子的重量。</li>\n\t<li><code>portsCount</code>&nbsp;是码头的数目。</li>\n\t<li><code>maxBoxes</code> 和&nbsp;<code>maxWeight</code>&nbsp;分别是卡车每趟运输箱子数目和重量的限制。</li>\n</ul>\n\n<p>箱子需要按照 <strong>数组顺序</strong>&nbsp;运输，同时每次运输需要遵循以下步骤：</p>\n\n<ul>\n\t<li>卡车从&nbsp;<code>boxes</code>&nbsp;队列中按顺序取出若干个箱子，但不能违反&nbsp;<code>maxBoxes</code> 和&nbsp;<code>maxWeight</code>&nbsp;限制。</li>\n\t<li>对于在卡车上的箱子，我们需要 <strong>按顺序</strong>&nbsp;处理它们，卡车会通过 <strong>一趟行程</strong>&nbsp;将最前面的箱子送到目的地码头并卸货。如果卡车已经在对应的码头，那么不需要 <strong>额外行程</strong>&nbsp;，箱子也会立马被卸货。</li>\n\t<li>卡车上所有箱子都被卸货后，卡车需要 <strong>一趟行程</strong>&nbsp;回到仓库，从箱子队列里再取出一些箱子。</li>\n</ul>\n\n<p>卡车在将所有箱子运输并卸货后，最后必须回到仓库。</p>\n\n<p>请你返回将所有箱子送到相应码头的&nbsp;<b>最少行程</b>&nbsp;次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3\n<b>输出：</b>4\n<b>解释：</b>最优策略如下：\n- 卡车将所有箱子装上车，到达码头 1 ，然后去码头 2 ，然后再回到码头 1 ，最后回到仓库，总共需要 4 趟行程。\n所以总行程数为 4 。\n注意到第一个和第三个箱子不能同时被卸货，因为箱子需要按顺序处理（也就是第二个箱子需要先被送到码头 2 ，然后才能处理第三个箱子）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6\n<b>输出：</b>6\n<b>解释：</b>最优策略如下：\n- 卡车首先运输第一个箱子，到达码头 1 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第二、第三、第四个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第五个箱子，到达码头 2 ，回到仓库，总共 2 趟行程。\n总行程数为 2 + 2 + 2 = 6 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>boxes = [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], portsCount = 3, maxBoxes = 6, maxWeight = 7\n<b>输出：</b>6\n<b>解释：</b>最优策略如下：\n- 卡车运输第一和第二个箱子，到达码头 1 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第三和第四个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第五和第六个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。\n总行程数为 2 + 2 + 2 = 6 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>boxes = [[2,4],[2,5],[3,1],[3,2],[3,7],[3,1],[4,4],[1,3],[5,2]], portsCount = 5, maxBoxes = 5, maxWeight = 7\n<b>输出：</b>14\n<b>解释：</b>最优策略如下：\n- 卡车运输第一个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第二个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第三和第四个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第五个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第六和第七个箱子，到达码头 3 ，然后去码头 4 ，然后回到仓库，总共 3 趟行程。\n- 卡车运输第八和第九个箱子，到达码头 1 ，然后去码头 5 ，然后回到仓库，总共 3 趟行程。\n总行程数为 2 + 2 + 2 + 2 + 3 + 3 = 14 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= boxes.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= portsCount, maxBoxes, maxWeight &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= ports<sub>​​i</sub> &lt;= portsCount</code></li>\n\t<li><code>1 &lt;= weights<sub>i</sub> &lt;= maxWeight</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1688.比赛中的配对次数",
        "hardRate": "EASY",
        "passRate": "83.77%",
        "problemsUrl": "https://leetcode.cn/problems/count-of-matches-in-tournament/",
        "solutionsUrl": "https://leetcode.cn/problems/count-of-matches-in-tournament/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，表示比赛中的队伍数。比赛遵循一种独特的赛制：</p>\n\n<ul>\n\t<li>如果当前队伍数是 <strong>偶数</strong> ，那么每支队伍都会与另一支队伍配对。总共进行 <code>n / 2</code> 场比赛，且产生 <code>n / 2</code> 支队伍进入下一轮。</li>\n\t<li>如果当前队伍数为 <strong>奇数</strong> ，那么将会随机轮空并晋级一支队伍，其余的队伍配对。总共进行 <code>(n - 1) / 2</code> 场比赛，且产生 <code>(n - 1) / 2 + 1</code> 支队伍进入下一轮。</li>\n</ul>\n\n<p>返回在比赛中进行的配对次数，直到决出获胜队伍为止。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 7\n<strong>输出：</strong>6\n<strong>解释：</strong>比赛详情：\n- 第 1 轮：队伍数 = 7 ，配对次数 = 3 ，4 支队伍晋级。\n- 第 2 轮：队伍数 = 4 ，配对次数 = 2 ，2 支队伍晋级。\n- 第 3 轮：队伍数 = 2 ，配对次数 = 1 ，决出 1 支获胜队伍。\n总配对次数 = 3 + 2 + 1 = 6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 14\n<strong>输出：</strong>13\n<strong>解释：</strong>比赛详情：\n- 第 1 轮：队伍数 = 14 ，配对次数 = 7 ，7 支队伍晋级。\n- 第 2 轮：队伍数 = 7 ，配对次数 = 3 ，4 支队伍晋级。 \n- 第 3 轮：队伍数 = 4 ，配对次数 = 2 ，2 支队伍晋级。\n- 第 4 轮：队伍数 = 2 ，配对次数 = 1 ，决出 1 支获胜队伍。\n总配对次数 = 7 + 3 + 2 + 1 = 13\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1689.十-二进制数的最少数目",
        "hardRate": "MEDIUM",
        "passRate": "86.56%",
        "problemsUrl": "https://leetcode.cn/problems/partitioning-into-minimum-number-of-deci-binary-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution",
        "problemsDesc": "<p>如果一个十进制数字不含任何前导零，且每一位上的数字不是 <code>0</code> 就是 <code>1</code> ，那么该数字就是一个 <strong>十-二进制数</strong> 。例如，<code>101</code> 和 <code>1100</code> 都是 <strong>十-二进制数</strong>，而 <code>112</code> 和 <code>3001</code> 不是。</p>\n\n<p>给你一个表示十进制整数的字符串 <code>n</code> ，返回和为 <code>n</code> 的 <strong>十-二进制数 </strong>的最少数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = \"32\"\n<strong>输出：</strong>3\n<strong>解释：</strong>10 + 11 + 11 = 32\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = \"82734\"\n<strong>输出：</strong>8\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = \"27346209830709182346\"\n<strong>输出：</strong>9\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>n</code> 仅由数字组成</li>\n\t<li><code>n</code> 不含任何前导零并总是表示正整数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1690.石子游戏 VII",
        "hardRate": "MEDIUM",
        "passRate": "55.75%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game-vii/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game-vii/solution",
        "problemsDesc": "<p>石子游戏中，爱丽丝和鲍勃轮流进行自己的回合，<strong>爱丽丝先开始</strong> 。</p>\n\n<p>有 <code>n</code> 块石子排成一排。每个玩家的回合中，可以从行中 <strong>移除</strong> 最左边的石头或最右边的石头，并获得与该行中剩余石头值之 <strong>和</strong> 相等的得分。当没有石头可移除时，得分较高者获胜。</p>\n\n<p>鲍勃发现他总是输掉游戏（可怜的鲍勃，他总是输），所以他决定尽力 <strong>减小得分的差值</strong> 。爱丽丝的目标是最大限度地 <strong>扩大得分的差值</strong> 。</p>\n\n<p>给你一个整数数组 <code>stones</code> ，其中 <code>stones[i]</code> 表示 <strong>从左边开始</strong> 的第 <code>i</code> 个石头的值，如果爱丽丝和鲍勃都 <strong>发挥出最佳水平</strong> ，请返回他们 <strong>得分的差值</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [5,3,1,4,2]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n- 爱丽丝移除 2 ，得分 5 + 3 + 1 + 4 = 13 。游戏情况：爱丽丝 = 13 ，鲍勃 = 0 ，石子 = [5,3,1,4] 。\n- 鲍勃移除 5 ，得分 3 + 1 + 4 = 8 。游戏情况：爱丽丝 = 13 ，鲍勃 = 8 ，石子 = [3,1,4] 。\n- 爱丽丝移除 3 ，得分 1 + 4 = 5 。游戏情况：爱丽丝 = 18 ，鲍勃 = 8 ，石子 = [1,4] 。\n- 鲍勃移除 1 ，得分 4 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [4] 。\n- 爱丽丝移除 4 ，得分 0 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [] 。\n得分的差值 18 - 12 = 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [7,90,5,1,100,10,10,2]\n<strong>输出：</strong>122</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == stones.length</code></li>\n\t<li><code>2 <= n <= 1000</code></li>\n\t<li><code>1 <= stones[i] <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1691.堆叠长方体的最大高度",
        "hardRate": "HARD",
        "passRate": "65.01%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-height-by-stacking-cuboids/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-height-by-stacking-cuboids/solution",
        "problemsDesc": "<p>给你 <code>n</code> 个长方体 <code>cuboids</code> ，其中第 <code>i</code> 个长方体的长宽高表示为 <code>cuboids[i] = [width<sub>i</sub>, length<sub>i</sub>, height<sub>i</sub>]</code>（<strong>下标从 0 开始</strong>）。请你从 <code>cuboids</code> 选出一个 <strong>子集</strong> ，并将它们堆叠起来。</p>\n\n<p>如果 <code>width<sub>i</sub> <= width<sub>j</sub></code> 且 <code>length<sub>i</sub> <= length<sub>j</sub></code> 且 <code>height<sub>i</sub> <= height<sub>j</sub></code> ，你就可以将长方体 <code>i</code> 堆叠在长方体 <code>j</code> 上。你可以通过旋转把长方体的长宽高重新排列，以将它放在另一个长方体上。</p>\n\n<p>返回 <strong>堆叠长方体</strong> <code>cuboids</code> 可以得到的 <strong>最大高度</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/12/image.jpg\" style=\"width: 420px; height: 299px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>cuboids = [[50,45,20],[95,37,53],[45,23,12]]\n<strong>输出：</strong>190\n<strong>解释：</strong>\n第 1 个长方体放在底部，53x37 的一面朝下，高度为 95 。\n第 0 个长方体放在中间，45x20 的一面朝下，高度为 50 。\n第 2 个长方体放在上面，23x12 的一面朝下，高度为 45 。\n总高度是 95 + 50 + 45 = 190 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>cuboids = [[38,25,45],[76,35,3]]\n<strong>输出：</strong>76\n<strong>解释：</strong>\n无法将任何长方体放在另一个上面。\n选择第 1 个长方体然后旋转它，使 35x3 的一面朝下，其高度为 76 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]]\n<strong>输出：</strong>102\n<strong>解释：</strong>\n重新排列长方体后，可以看到所有长方体的尺寸都相同。\n你可以把 11x7 的一面朝下，这样它们的高度就是 17 。\n堆叠长方体的最大高度为 6 * 17 = 102 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == cuboids.length</code></li>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>1 <= width<sub>i</sub>, length<sub>i</sub>, height<sub>i</sub> <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1692.计算分配糖果的不同方式",
        "hardRate": "HARD",
        "passRate": "66.11%",
        "problemsUrl": "https://leetcode.cn/problems/count-ways-to-distribute-candies/",
        "solutionsUrl": "https://leetcode.cn/problems/count-ways-to-distribute-candies/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1693.每天的领导和合伙人",
        "hardRate": "EASY",
        "passRate": "81.91%",
        "problemsUrl": "https://leetcode.cn/problems/daily-leads-and-partners/",
        "solutionsUrl": "https://leetcode.cn/problems/daily-leads-and-partners/solution",
        "problemsDesc": "<p>表：<code>DailySales</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| date_id     | date    |\n| make_name   | varchar |\n| lead_id     | int     |\n| partner_id  | int     |\n+-------------+---------+\n该表没有主键。\n该表包含日期、产品的名称，以及售给的领导和合伙人的编号。\n名称只包含小写英文字母。</pre>\n\n<p>&nbsp;</p>\n\n<p>写一条 SQL 语句，使得对于每一个&nbsp;<code>date_id</code>&nbsp;和&nbsp;<code>make_name</code>，返回<strong>不同</strong>的&nbsp;<code>lead_id</code>&nbsp;以及<strong>不同</strong>的&nbsp;<code>partner_id</code>&nbsp;的数量。</p>\n\n<p>按 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式如下示例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nDailySales 表：\n+-----------+-----------+---------+------------+\n| date_id   | make_name | lead_id | partner_id |\n+-----------+-----------+---------+------------+\n| 2020-12-8 | toyota    | 0       | 1          |\n| 2020-12-8 | toyota    | 1       | 0          |\n| 2020-12-8 | toyota    | 1       | 2          |\n| 2020-12-7 | toyota    | 0       | 2          |\n| 2020-12-7 | toyota    | 0       | 1          |\n| 2020-12-8 | honda     | 1       | 2          |\n| 2020-12-8 | honda     | 2       | 1          |\n| 2020-12-7 | honda     | 0       | 1          |\n| 2020-12-7 | honda     | 1       | 2          |\n| 2020-12-7 | honda     | 2       | 1          |\n+-----------+-----------+---------+------------+\n<strong>输出：</strong>\n+-----------+-----------+--------------+-----------------+\n| date_id   | make_name | unique_leads | unique_partners |\n+-----------+-----------+--------------+-----------------+\n| 2020-12-8 | toyota    | 2            | 3               |\n| 2020-12-7 | toyota    | 1            | 2               |\n| 2020-12-8 | honda     | 2            | 2               |\n| 2020-12-7 | honda     | 3            | 2               |\n+-----------+-----------+--------------+-----------------+\n<strong>解释：</strong>\n在 2020-12-8，丰田（toyota）有领导者 = [0, 1] 和合伙人 = [0, 1, 2] ，同时本田（honda）有领导者 = [1, 2] 和合伙人 = [1, 2]。\n在 2020-12-7，丰田（toyota）有领导者 = [0] 和合伙人 = [1, 2] ，同时本田（honda）有领导者 = [0, 1, 2] 和合伙人 = [1, 2]。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1694.重新格式化电话号码",
        "hardRate": "EASY",
        "passRate": "66.10%",
        "problemsUrl": "https://leetcode.cn/problems/reformat-phone-number/",
        "solutionsUrl": "https://leetcode.cn/problems/reformat-phone-number/solution",
        "problemsDesc": "<p>给你一个字符串形式的电话号码 <code>number</code> 。<code>number</code> 由数字、空格 <code>' '</code>、和破折号 <code>'-'</code> 组成。</p>\n\n<p>请你按下述方式重新格式化电话号码。</p>\n\n<ul>\n\t<li>首先，<strong>删除</strong> 所有的空格和破折号。</li>\n\t<li>其次，将数组从左到右 <strong>每 3 个一组</strong> 分块，<strong>直到 </strong>剩下 4 个或更少数字。剩下的数字将按下述规定再分块：\n\t<ul>\n\t\t<li>2 个数字：单个含 2 个数字的块。</li>\n\t\t<li>3 个数字：单个含 3 个数字的块。</li>\n\t\t<li>4 个数字：两个分别含 2 个数字的块。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>最后用破折号将这些块连接起来。注意，重新格式化过程中 <strong>不应该</strong> 生成仅含 1 个数字的块，并且 <strong>最多</strong> 生成两个含 2 个数字的块。</p>\n\n<p>返回格式化后的电话号码。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>number = \"1-23-45 6\"\n<strong>输出：</strong>\"123-456\"\n<strong>解释：</strong>数字是 \"123456\"\n步骤 1：共有超过 4 个数字，所以先取 3 个数字分为一组。第 1 个块是 \"123\" 。\n步骤 2：剩下 3 个数字，将它们放入单个含 3 个数字的块。第 2 个块是 \"456\" 。\n连接这些块后得到 \"123-456\" 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>number = \"123 4-567\"\n<strong>输出：</strong>\"123-45-67\"\n<strong>解释：</strong>数字是 \"1234567\".\n步骤 1：共有超过 4 个数字，所以先取 3 个数字分为一组。第 1 个块是 \"123\" 。\n步骤 2：剩下 4 个数字，所以将它们分成两个含 2 个数字的块。这 2 块分别是 \"45\" 和 \"67\" 。\n连接这些块后得到 \"123-45-67\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>number = \"123 4-5678\"\n<strong>输出：</strong>\"123-456-78\"\n<strong>解释：</strong>数字是 \"12345678\" 。\n步骤 1：第 1 个块 \"123\" 。\n步骤 2：第 2 个块 \"456\" 。\n步骤 3：剩下 2 个数字，将它们放入单个含 2 个数字的块。第 3 个块是 \"78\" 。\n连接这些块后得到 \"123-456-78\" 。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>number = \"12\"\n<strong>输出：</strong>\"12\"\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>number = \"--17-5 229 35-39475 \"\n<strong>输出：</strong>\"175-229-353-94-75\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= number.length <= 100</code></li>\n\t<li><code>number</code> 由数字和字符 <code>'-'</code> 及 <code>' '</code> 组成。</li>\n\t<li><code>number</code> 中至少含 <strong>2</strong> 个数字。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1695.删除子数组的最大得分",
        "hardRate": "MEDIUM",
        "passRate": "51.98%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-erasure-value/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-erasure-value/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>nums</code> ，请你从中删除一个含有 <strong>若干不同元素</strong> 的子数组<strong>。</strong>删除子数组的 <strong>得分</strong> 就是子数组各元素之 <strong>和</strong> 。</p>\n\n<p>返回 <strong>只删除一个</strong> 子数组可获得的 <strong>最大得分</strong><em> 。</em></p>\n\n<p>如果数组 <code>b</code> 是数组 <code>a</code> 的一个连续子序列，即如果它等于 <code>a[l],a[l+1],...,a[r]</code> ，那么它就是 <code>a</code> 的一个子数组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,2,4,5,6]\n<strong>输出：</strong>17\n<strong>解释：</strong>最优子数组是 [2,4,5,6]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,2,1,2,5,2,1,2,5]\n<strong>输出：</strong>8\n<strong>解释：</strong>最优子数组是 [5,2,1] 或 [1,2,5]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1696.跳跃游戏 VI",
        "hardRate": "MEDIUM",
        "passRate": "40.23%",
        "problemsUrl": "https://leetcode.cn/problems/jump-game-vi/",
        "solutionsUrl": "https://leetcode.cn/problems/jump-game-vi/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>\n\n<p>一开始你在下标 <code>0</code> 处。每一步，你最多可以往前跳 <code>k</code> 步，但你不能跳出数组的边界。也就是说，你可以从下标 <code>i</code> 跳到 <code>[i + 1， min(n - 1, i + k)]</code> <strong>包含</strong> 两个端点的任意位置。</p>\n\n<p>你的目标是到达数组最后一个位置（下标为 <code>n - 1</code> ），你的 <strong>得分</strong> 为经过的所有数字之和。</p>\n\n<p>请你返回你能得到的 <strong>最大得分</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [<strong>1</strong>,<strong>-1</strong>,-2,<strong>4</strong>,-7,<strong>3</strong>], k = 2\n<b>输出：</b>7\n<b>解释：</b>你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<strong>10</strong>,-5,-2,<strong>4</strong>,0,<strong>3</strong>], k = 3\n<b>输出：</b>17\n<b>解释：</b>你可以选择子序列 [10,4,3] （上面加粗数字），和为 17 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,-5,-20,4,-1,3,-6,-3], k = 2\n<b>输出：</b>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li> <code>1 <= nums.length, k <= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1697.检查边长度限制的路径是否存在",
        "hardRate": "HARD",
        "passRate": "64.92%",
        "problemsUrl": "https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/",
        "solutionsUrl": "https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/solution",
        "problemsDesc": "<p>给你一个 <code>n</code> 个点组成的无向图边集 <code>edgeList</code> ，其中 <code>edgeList[i] = [u<sub>i</sub>, v<sub>i</sub>, dis<sub>i</sub>]</code> 表示点 <code>u<sub>i</sub></code> 和点 <code>v<sub>i</sub></code> 之间有一条长度为 <code>dis<sub>i</sub></code> 的边。请注意，两个点之间可能有 <strong>超过一条边 </strong>。</p>\n\n<p>给你一个查询数组<code>queries</code> ，其中 <code>queries[j] = [p<sub>j</sub>, q<sub>j</sub>, limit<sub>j</sub>]</code> ，你的任务是对于每个查询 <code>queries[j]</code> ，判断是否存在从 <code>p<sub>j</sub></code> 到 <code>q<sub>j</sub></code><sub> </sub>的路径，且这条路径上的每一条边都 <strong>严格小于</strong> <code>limit<sub>j</sub></code> 。</p>\n\n<p>请你返回一个 <b>布尔数组</b><em> </em><code>answer</code><em> </em>，其中<em> </em><code>answer.length == queries.length</code> ，当 <code>queries[j]</code> 的查询结果为 <code>true</code> 时， <code>answer</code> 第<em> </em><code>j</code> 个值为<em> </em><code>true</code><em> </em>，否则为 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/19/h.png\" style=\"width: 267px; height: 262px;\" />\n<pre>\n<b>输入：</b>n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]\n<b>输出：</b>[false,true]\n<b>解释：</b>上图为给定的输入数据。注意到 0 和 1 之间有两条重边，分别为 2 和 16 。\n对于第一个查询，0 和 1 之间没有小于 2 的边，所以我们返回 false 。\n对于第二个查询，有一条路径（0 -> 1 -> 2）两条边都小于 5 ，所以这个查询我们返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/19/q.png\" style=\"width: 390px; height: 358px;\" />\n<pre>\n<b>输入：</b>n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]\n<b>输出：</b>[true,false]\n<b>解释：</b>上图为给定数据。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= edgeList.length, queries.length <= 10<sup>5</sup></code></li>\n\t<li><code>edgeList[i].length == 3</code></li>\n\t<li><code>queries[j].length == 3</code></li>\n\t<li><code>0 <= u<sub>i</sub>, v<sub>i</sub>, p<sub>j</sub>, q<sub>j</sub> <= n - 1</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n\t<li><code>p<sub>j</sub> != q<sub>j</sub></code></li>\n\t<li><code>1 <= dis<sub>i</sub>, limit<sub>j</sub> <= 10<sup>9</sup></code></li>\n\t<li>两个点之间可能有 <strong>多条</strong> 边。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1698.字符串的不同子字符串个数",
        "hardRate": "MEDIUM",
        "passRate": "55.32%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-distinct-substrings-in-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-distinct-substrings-in-a-string/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1699.两人之间的通话次数",
        "hardRate": "MEDIUM",
        "passRate": "76.43%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-calls-between-two-persons/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-calls-between-two-persons/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1700.无法吃午餐的学生数量",
        "hardRate": "EASY",
        "passRate": "73.19%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/solution",
        "problemsDesc": "<p>学校的自助午餐提供圆形和方形的三明治，分别用数字 <code>0</code> 和 <code>1</code> 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。<br>\n餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 <strong>栈</strong> 里，每一轮：</p>\n\n<ul>\n\t<li>如果队列最前面的学生 <strong>喜欢</strong> 栈顶的三明治，那么会 <strong>拿走它</strong> 并离开队列。</li>\n\t<li>否则，这名学生会 <strong>放弃这个三明治</strong> 并回到队列的尾部。</li>\n</ul>\n\n<p>这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。</p>\n\n<p>给你两个整数数组 <code>students</code> 和 <code>sandwiches</code> ，其中 <code>sandwiches[i]</code> 是栈里面第 <code>i<sup>​​​​​​</sup></code> 个三明治的类型（<code>i = 0</code> 是栈的顶部）， <code>students[j]</code> 是初始队列里第 <code>j<sup>​​​​​​</sup></code> 名学生对三明治的喜好（<code>j = 0</code> 是队列的最开始位置）。请你返回无法吃午餐的学生数量。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>students = [1,1,0,0], sandwiches = [0,1,0,1]\n<b>输出：</b>0<strong> \n解释：</strong>\n- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [1,0,0,1]。\n- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [0,0,1,1]。\n- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [0,1,1]，三明治栈为 sandwiches = [1,0,1]。\n- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [1,1,0]。\n- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [1,0]，三明治栈为 sandwiches = [0,1]。\n- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [0,1]。\n- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [1]，三明治栈为 sandwiches = [1]。\n- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = []，三明治栈为 sandwiches = []。\n所以所有学生都有三明治吃。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]\n<b>输出：</b>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= students.length, sandwiches.length &lt;= 100</code></li>\n\t<li><code>students.length == sandwiches.length</code></li>\n\t<li><code>sandwiches[i]</code> 要么是 <code>0</code> ，要么是 <code>1</code> 。</li>\n\t<li><code>students[i]</code> 要么是 <code>0</code> ，要么是 <code>1</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1701.平均等待时间",
        "hardRate": "MEDIUM",
        "passRate": "60.56%",
        "problemsUrl": "https://leetcode.cn/problems/average-waiting-time/",
        "solutionsUrl": "https://leetcode.cn/problems/average-waiting-time/solution",
        "problemsDesc": "<p>有一个餐厅，只有一位厨师。你有一个顾客数组 <code>customers</code> ，其中 <code>customers[i] = [arrival<sub>i</sub>, time<sub>i</sub>]</code> ：</p>\n\n<ul>\n\t<li><code>arrival<sub>i</sub></code> 是第 <code>i</code> 位顾客到达的时间，到达时间按 <strong>非递减</strong> 顺序排列。</li>\n\t<li><code>time<sub>i</sub></code> 是给第 <code>i</code> 位顾客做菜需要的时间。</li>\n</ul>\n\n<p>当一位顾客到达时，他将他的订单给厨师，厨师一旦空闲的时候就开始做这位顾客的菜。每位顾客会一直等待到厨师完成他的订单。厨师同时只能做一个人的订单。厨师会严格按照 <strong>订单给他的顺序</strong> 做菜。</p>\n\n<p>请你返回所有顾客需要等待的 <strong>平均 </strong>时间。与标准答案误差在 <code>10<sup>-5</sup></code> 范围以内，都视为正确结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>customers = [[1,2],[2,5],[4,3]]\n<b>输出：</b>5.00000\n<strong>解释：\n</strong>1) 第一位顾客在时刻 1 到达，厨师拿到他的订单并在时刻 1 立马开始做菜，并在时刻 3 完成，第一位顾客等待时间为 3 - 1 = 2 。\n2) 第二位顾客在时刻 2 到达，厨师在时刻 3 开始为他做菜，并在时刻 8 完成，第二位顾客等待时间为 8 - 2 = 6 。\n3) 第三位顾客在时刻 4 到达，厨师在时刻 8 开始为他做菜，并在时刻 11 完成，第三位顾客等待时间为 11 - 4 = 7 。\n平均等待时间为 (2 + 6 + 7) / 3 = 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>customers = [[5,2],[5,4],[10,3],[20,1]]\n<b>输出：</b>3.25000\n<strong>解释：\n</strong>1) 第一位顾客在时刻 5 到达，厨师拿到他的订单并在时刻 5 立马开始做菜，并在时刻 7 完成，第一位顾客等待时间为 7 - 5 = 2 。\n2) 第二位顾客在时刻 5 到达，厨师在时刻 7 开始为他做菜，并在时刻 11 完成，第二位顾客等待时间为 11 - 5 = 6 。\n3) 第三位顾客在时刻 10 到达，厨师在时刻 11 开始为他做菜，并在时刻 14 完成，第三位顾客等待时间为 14 - 10 = 4 。\n4) 第四位顾客在时刻 20 到达，厨师拿到他的订单并在时刻 20 立马开始做菜，并在时刻 21 完成，第四位顾客等待时间为 21 - 20 = 1 。\n平均等待时间为 (2 + 6 + 4 + 1) / 4 = 3.25 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= customers.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= arrival<sub>i</sub>, time<sub>i</sub> <= 10<sup>4</sup></code></li>\n\t<li><code>arrival<sub>i </sub><= arrival<sub>i+1</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1702.修改后的最大二进制字符串",
        "hardRate": "MEDIUM",
        "passRate": "48.30%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-binary-string-after-change/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-binary-string-after-change/solution",
        "problemsDesc": "<p>给你一个二进制字符串 <code>binary</code> ，它仅有 <code>0</code> 或者 <code>1</code> 组成。你可以使用下面的操作任意次对它进行修改：</p>\n\n<ul>\n\t<li>操作 1 ：如果二进制串包含子字符串 <code>\"00\"</code> ，你可以用 <code>\"10\"</code> 将其替换。\n\n\t<ul>\n\t\t<li>比方说， <code>\"<strong>00</strong>010\" -> \"<strong>10</strong>010\"</code></li>\n\t</ul>\n\t</li>\n\t<li>操作 2 ：如果二进制串包含子字符串 <code>\"10\"</code> ，你可以用 <code>\"01\"</code> 将其替换。\n\t<ul>\n\t\t<li>比方说， <code>\"000<strong>10</strong>\" -> \"000<strong>01</strong>\"</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回执行上述操作任意次以后能得到的 <strong>最大二进制字符串</strong> 。如果二进制字符串 <code>x</code> 对应的十进制数字大于二进制字符串 <code>y</code> 对应的十进制数字，那么我们称二进制字符串<em> </em><code>x</code><em> </em>大于二进制字符串<em> </em><code>y</code><em> </em>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>binary = \"000110\"\n<b>输出：</b>\"111011\"\n<b>解释：</b>一个可行的转换为：\n\"0001<strong>10</strong>\" -> \"0001<strong>01</strong>\" \n\"<strong>00</strong>0101\" -> \"<strong>10</strong>0101\" \n\"1<strong>00</strong>101\" -> \"1<strong>10</strong>101\" \n\"110<strong>10</strong>1\" -> \"110<strong>01</strong>1\" \n\"11<strong>00</strong>11\" -> \"11<strong>10</strong>11\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>binary = \"01\"\n<b>输出：</b>\"01\"\n<b>解释：</b>\"01\" 没办法进行任何转换。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= binary.length <= 10<sup>5</sup></code></li>\n\t<li><code>binary</code> 仅包含 <code>'0'</code> 和 <code>'1'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1703.得到连续 K 个 1 的最少相邻交换次数",
        "hardRate": "HARD",
        "passRate": "56.55%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-adjacent-swaps-for-k-consecutive-ones/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-adjacent-swaps-for-k-consecutive-ones/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。 <code>nums</code> 仅包含 <code>0</code> 和 <code>1</code> 。每一次移动，你可以选择 <strong>相邻</strong> 两个数字并将它们交换。</p>\n\n<p>请你返回使 <code>nums</code> 中包含 <code>k</code> 个 <strong>连续 </strong><code>1</code> 的 <strong>最少</strong> 交换次数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,0,0,1,0,1], k = 2\n<b>输出：</b>1\n<b>解释：</b>在第一次操作时，nums 可以变成 [1,0,0,0,<strong>1</strong>,<strong>1</strong>] 得到连续两个 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,0,0,0,0,0,1,1], k = 3\n<b>输出：</b>5\n<b>解释：</b>通过 5 次操作，最左边的 1 可以移到右边直到 nums 变为 [0,0,0,0,0,<strong>1</strong>,<strong>1</strong>,<strong>1</strong>] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [1,1,0,1], k = 2\n<b>输出：</b>0\n<b>解释：</b>nums 已经有连续 2 个 1 了。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> 要么是 <code>0</code> ，要么是 <code>1</code> 。</li>\n\t<li><code>1 &lt;= k &lt;= sum(nums)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1704.判断字符串的两半是否相似",
        "hardRate": "EASY",
        "passRate": "78.32%",
        "problemsUrl": "https://leetcode.cn/problems/determine-if-string-halves-are-alike/",
        "solutionsUrl": "https://leetcode.cn/problems/determine-if-string-halves-are-alike/solution",
        "problemsDesc": "<p>给你一个偶数长度的字符串 <code>s</code> 。将其拆分成长度相同的两半，前一半为 <code>a</code> ，后一半为 <code>b</code> 。</p>\n\n<p>两个字符串 <strong>相似</strong> 的前提是它们都含有相同数目的元音（<code>'a'</code>，<code>'e'</code>，<code>'i'</code>，<code>'o'</code>，<code>'u'</code>，<code>'A'</code>，<code>'E'</code>，<code>'I'</code>，<code>'O'</code>，<code>'U'</code>）。注意，<code>s</code> 可能同时含有大写和小写字母。</p>\n\n<p>如果<em> </em><code>a</code><em> </em>和<em> </em><code>b</code> 相似，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"book\"\n<strong>输出：</strong>true\n<strong>解释：</strong>a = \"b<strong>o</strong>\" 且 b = \"<strong>o</strong>k\" 。a 中有 1 个元音，b 也有 1 个元音。所以，a 和 b 相似。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"textbook\"\n<strong>输出：</strong>false\n<strong>解释：</strong>a = \"t<strong>e</strong>xt\" 且 b = \"b<strong>oo</strong>k\" 。a 中有 1 个元音，b 中有 2 个元音。因此，a 和 b 不相似。\n注意，元音 o 在 b 中出现两次，记为 2 个。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s.length</code> 是偶数</li>\n\t<li><code>s</code> 由 <strong>大写和小写</strong> 字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1705.吃苹果的最大数目",
        "hardRate": "MEDIUM",
        "passRate": "45.44%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-eaten-apples/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-eaten-apples/solution",
        "problemsDesc": "<p>有一棵特殊的苹果树，一连 <code>n</code> 天，每天都可以长出若干个苹果。在第 <code>i</code> 天，树上会长出 <code>apples[i]</code> 个苹果，这些苹果将会在 <code>days[i]</code> 天后（也就是说，第 <code>i + days[i]</code> 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 <code>apples[i] == 0</code> 且 <code>days[i] == 0</code> 表示。</p>\n\n<p>你打算每天 <strong>最多</strong> 吃一个苹果来保证营养均衡。注意，你可以在这 <code>n</code> 天之后继续吃苹果。</p>\n\n<p>给你两个长度为 <code>n</code> 的整数数组 <code>days</code> 和 <code>apples</code> ，返回你可以吃掉的苹果的最大数目<em>。</em></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>apples = [1,2,3,5,2], days = [3,2,1,4,2]\n<strong>输出：</strong>7\n<strong>解释：</strong>你可以吃掉 7 个苹果：\n- 第一天，你吃掉第一天长出来的苹果。\n- 第二天，你吃掉一个第二天长出来的苹果。\n- 第三天，你吃掉一个第二天长出来的苹果。过了这一天，第三天长出来的苹果就已经腐烂了。\n- 第四天到第七天，你吃的都是第四天长出来的苹果。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2]\n<strong>输出：</strong>5\n<strong>解释：</strong>你可以吃掉 5 个苹果：\n- 第一天到第三天，你吃的都是第一天长出来的苹果。\n- 第四天和第五天不吃苹果。\n- 第六天和第七天，你吃的都是第六天长出来的苹果。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>apples.length == n</code></li>\n\t<li><code>days.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= apples[i], days[i] &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li>只有在 <code>apples[i] = 0</code> 时，<code>days[i] = 0</code> 才成立</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1706.球会落何处",
        "hardRate": "MEDIUM",
        "passRate": "69.04%",
        "problemsUrl": "https://leetcode.cn/problems/where-will-the-ball-fall/",
        "solutionsUrl": "https://leetcode.cn/problems/where-will-the-ball-fall/solution",
        "problemsDesc": "<p>用一个大小为 <code>m x n</code> 的二维网格 <code>grid</code> 表示一个箱子。你有 <code>n</code> 颗球。箱子的顶部和底部都是开着的。</p>\n\n<p>箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。</p>\n\n<ul>\n\t<li>将球导向右侧的挡板跨过左上角和右下角，在网格中用 <code>1</code> 表示。</li>\n\t<li>将球导向左侧的挡板跨过右上角和左下角，在网格中用 <code>-1</code> 表示。</li>\n</ul>\n\n<p>在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 \"V\" 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。</p>\n\n<p>返回一个大小为 <code>n</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是球放在顶部的第 <code>i</code> 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/26/ball.jpg\" style=\"width: 500px; height: 385px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]\n<strong>输出：</strong>[1,-1,-1,-1,-1]\n<strong>解释：</strong>示例如图：\nb0 球开始放在第 0 列上，最终从箱子底部第 1 列掉出。\nb1 球开始放在第 1 列上，会卡在第 2、3 列和第 1 行之间的 \"V\" 形里。\nb2 球开始放在第 2 列上，会卡在第 2、3 列和第 0 行之间的 \"V\" 形里。\nb3 球开始放在第 3 列上，会卡在第 2、3 列和第 0 行之间的 \"V\" 形里。\nb4 球开始放在第 4 列上，会卡在第 2、3 列和第 1 行之间的 \"V\" 形里。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[-1]]\n<strong>输出：</strong>[-1]\n<strong>解释：</strong>球被卡在箱子左侧边上。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]\n<strong>输出：</strong>[0,1,2,3,4,-1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 <= m, n <= 100</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>1</code> 或 <code>-1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1707.与数组中元素的最大异或值",
        "hardRate": "HARD",
        "passRate": "50.94%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-xor-with-an-element-from-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-xor-with-an-element-from-array/solution",
        "problemsDesc": "<p>给你一个由非负整数组成的数组 <code>nums</code> 。另有一个查询数组 <code>queries</code> ，其中 <code>queries[i] = [x<sub>i</sub>, m<sub>i</sub>]</code> 。</p>\n\n<p>第 <code>i</code> 个查询的答案是 <code>x<sub>i</sub></code> 和任何 <code>nums</code> 数组中不超过 <code>m<sub>i</sub></code> 的元素按位异或（<code>XOR</code>）得到的最大值。换句话说，答案是 <code>max(nums[j] XOR x<sub>i</sub>)</code> ，其中所有 <code>j</code> 均满足 <code>nums[j] &lt;= m<sub>i</sub></code> 。如果 <code>nums</code> 中的所有元素都大于 <code>m<sub>i</sub></code>，最终答案就是 <code>-1</code> 。</p>\n\n<p>返回一个整数数组<em> </em><code>answer</code><em> </em>作为查询的答案，其中<em> </em><code>answer.length == queries.length</code><em> </em>且<em> </em><code>answer[i]</code><em> </em>是第<em> </em><code>i</code><em> </em>个查询的答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]\n<strong>输出：</strong>[3,3,7]\n<strong>解释：</strong>\n1) 0 和 1 是仅有的两个不超过 1 的整数。0 XOR 3 = 3 而 1 XOR 3 = 2 。二者中的更大值是 3 。\n2) 1 XOR 2 = 3.\n3) 5 XOR 2 = 7.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]\n<strong>输出：</strong>[15,-1,5]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>0 &lt;= nums[j], x<sub>i</sub>, m<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1708.长度为 K 的最大子数组",
        "hardRate": "EASY",
        "passRate": "67.08%",
        "problemsUrl": "https://leetcode.cn/problems/largest-subarray-length-k/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-subarray-length-k/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1709.访问日期之间最大的空档期",
        "hardRate": "MEDIUM",
        "passRate": "69.05%",
        "problemsUrl": "https://leetcode.cn/problems/biggest-window-between-visits/",
        "solutionsUrl": "https://leetcode.cn/problems/biggest-window-between-visits/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1710.卡车上的最大单元数",
        "hardRate": "EASY",
        "passRate": "73.43%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-units-on-a-truck/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-units-on-a-truck/solution",
        "problemsDesc": "<p>请你将一些箱子装在 <strong>一辆卡车</strong> 上。给你一个二维数组 <code>boxTypes</code> ，其中 <code>boxTypes[i] = [numberOfBoxes<sub>i</sub>, numberOfUnitsPerBox<sub>i</sub>]</code> ：</p>\n\n<ul>\n\t<li><code>numberOfBoxes<sub>i</sub></code> 是类型 <code>i</code> 的箱子的数量。</li>\n\t<li><code>numberOfUnitsPerBox<sub>i</sub></code><sub> </sub>是类型 <code>i</code> 每个箱子可以装载的单元数量。</li>\n</ul>\n\n<p>整数 <code>truckSize</code> 表示卡车上可以装载 <strong>箱子</strong> 的 <strong>最大数量</strong> 。只要箱子数量不超过 <code>truckSize</code> ，你就可以选择任意箱子装到卡车上。</p>\n\n<p>返回卡车可以装载 <strong>单元</strong> 的 <strong>最大</strong> 总数<em>。</em></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4\n<strong>输出：</strong>8\n<strong>解释：</strong>箱子的情况如下：\n- 1 个第一类的箱子，里面含 3 个单元。\n- 2 个第二类的箱子，每个里面含 2 个单元。\n- 3 个第三类的箱子，每个里面含 1 个单元。\n可以选择第一类和第二类的所有箱子，以及第三类的一个箱子。\n单元总数 = (1 * 3) + (2 * 2) + (1 * 1) = 8</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10\n<strong>输出：</strong>91\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= boxTypes.length <= 1000</code></li>\n\t<li><code>1 <= numberOfBoxes<sub>i</sub>, numberOfUnitsPerBox<sub>i</sub> <= 1000</code></li>\n\t<li><code>1 <= truckSize <= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1711.大餐计数",
        "hardRate": "MEDIUM",
        "passRate": "35.97%",
        "problemsUrl": "https://leetcode.cn/problems/count-good-meals/",
        "solutionsUrl": "https://leetcode.cn/problems/count-good-meals/solution",
        "problemsDesc": "<p><strong>大餐</strong> 是指 <strong>恰好包含两道不同餐品</strong> 的一餐，其美味程度之和等于 2 的幂。</p>\n\n<p>你可以搭配 <strong>任意</strong> 两道餐品做一顿大餐。</p>\n\n<p>给你一个整数数组 <code>deliciousness</code> ，其中 <code>deliciousness[i]</code> 是第 <code>i<sup>​​​​​​</sup>​​​​</code>​​​​ 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 <strong>大餐</strong> 的数量。结果需要对 <code>10<sup>9</sup> + 7</code> 取余。</p>\n\n<p>注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>deliciousness = [1,3,5,7,9]\n<strong>输出：</strong>4\n<strong>解释：</strong>大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。\n它们各自的美味程度之和分别为 4 、8 、8 和 16 ，都是 2 的幂。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>deliciousness = [1,1,1,3,3,3,7]\n<strong>输出：</strong>15\n<strong>解释：</strong>大餐的美味程度组合为 3 种 (1,1) ，9 种 (1,3) ，和 3 种 (1,7) 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= deliciousness.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= deliciousness[i] <= 2<sup>20</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1712.将数组分成三个子数组的方案数",
        "hardRate": "MEDIUM",
        "passRate": "28.55%",
        "problemsUrl": "https://leetcode.cn/problems/ways-to-split-array-into-three-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/ways-to-split-array-into-three-subarrays/solution",
        "problemsDesc": "<p>我们称一个分割整数数组的方案是 <strong>好的</strong> ，当它满足：</p>\n\n<ul>\n\t<li>数组被分成三个 <strong>非空</strong> 连续子数组，从左至右分别命名为 <code>left</code> ， <code>mid</code> ， <code>right</code> 。</li>\n\t<li><code>left</code> 中元素和小于等于 <code>mid</code> 中元素和，<code>mid</code> 中元素和小于等于 <code>right</code> 中元素和。</li>\n</ul>\n\n<p>给你一个 <strong>非负</strong> 整数数组 <code>nums</code> ，请你返回 <strong>好的</strong> 分割 <code>nums</code> 方案数目。由于答案可能会很大，请你将结果对 <code>10<sup>9 </sup>+ 7</code> 取余后返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,1,1]\n<b>输出：</b>1\n<b>解释：</b>唯一一种好的分割方案是将 nums 分成 [1] [1] [1] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,2,2,5,0]\n<b>输出：</b>3\n<b>解释：</b>nums 总共有 3 种好的分割方案：\n[1] [2] [2,2,5,0]\n[1] [2,2] [2,5,0]\n[1,2] [2,2] [5,0]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,2,1]\n<b>输出：</b>0\n<b>解释：</b>没有好的分割方案。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1713.得到子序列的最少操作次数",
        "hardRate": "HARD",
        "passRate": "49.92%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-a-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-a-subsequence/solution",
        "problemsDesc": "<p>给你一个数组 <code>target</code> ，包含若干 <strong>互不相同</strong> 的整数，以及另一个整数数组 <code>arr</code> ，<code>arr</code> <strong>可能</strong> 包含重复元素。</p>\n\n<p>每一次操作中，你可以在 <code>arr</code> 的任意位置插入任一整数。比方说，如果 <code>arr = [1,4,1,2]</code> ，那么你可以在中间添加 <code>3</code> 得到 <code>[1,4,<strong>3</strong>,1,2]</code> 。你可以在数组最开始或最后面添加整数。</p>\n\n<p>请你返回 <strong>最少</strong> 操作次数，使得<em> </em><code>target</code><em> </em>成为 <code>arr</code> 的一个子序列。</p>\n\n<p>一个数组的 <strong>子序列</strong> 指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，<code>[2,7,4]</code> 是 <code>[4,<strong>2</strong>,3,<strong>7</strong>,2,1,<strong>4</strong>]</code> 的子序列（加粗元素），但 <code>[2,4,2]</code> 不是子序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>target = [5,1,3], <code>arr</code> = [9,4,2,3,4]\n<b>输出：</b>2\n<b>解释：</b>你可以添加 5 和 1 ，使得 arr 变为 [<strong>5</strong>,9,4,<strong>1</strong>,2,3,4] ，target 为 arr 的子序列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>target = [6,4,8,1,3,2], <code>arr</code> = [4,7,6,2,3,8,6,1]\n<b>输出：</b>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target.length, arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= target[i], arr[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>target</code> 不包含任何重复元素。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1714.数组中特殊等间距元素的和",
        "hardRate": "HARD",
        "passRate": "60.12%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-special-evenly-spaced-elements-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-special-evenly-spaced-elements-in-array/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1715.苹果和橘子的个数",
        "hardRate": "MEDIUM",
        "passRate": "71.80%",
        "problemsUrl": "https://leetcode.cn/problems/count-apples-and-oranges/",
        "solutionsUrl": "https://leetcode.cn/problems/count-apples-and-oranges/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1716.计算力扣银行的钱",
        "hardRate": "EASY",
        "passRate": "69.07%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-money-in-leetcode-bank/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-money-in-leetcode-bank/solution",
        "problemsDesc": "<p>Hercy 想要为购买第一辆车存钱。他 <strong>每天</strong> 都往力扣银行里存钱。</p>\n\n<p>最开始，他在周一的时候存入 <code>1</code> 块钱。从周二到周日，他每天都比前一天多存入 <code>1</code> 块钱。在接下来每一个周一，他都会比 <strong>前一个周一</strong> 多存入 <code>1</code> 块钱。<span style=\"\"> </span></p>\n\n<p>给你 <code>n</code> ，请你返回在第 <code>n</code> 天结束的时候他在力扣银行总共存了多少块钱。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 4\n<b>输出：</b>10\n<b>解释：</b>第 4 天后，总额为 1 + 2 + 3 + 4 = 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 10\n<b>输出：</b>37\n<b>解释：</b>第 10 天后，总额为 (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37 。注意到第二个星期一，Hercy 存入 2 块钱。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>n = 20\n<b>输出：</b>96\n<b>解释：</b>第 20 天后，总额为 (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1717.删除子字符串的最大得分",
        "hardRate": "MEDIUM",
        "passRate": "46.16%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-from-removing-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-from-removing-substrings/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和两个整数 <code>x</code> 和 <code>y</code> 。你可以执行下面两种操作任意次。</p>\n\n<ul>\n\t<li>删除子字符串 <code>\"ab\"</code> 并得到 <code>x</code> 分。\n\n\t<ul>\n\t\t<li>比方说，从 <code>\"c<strong>ab</strong>xbae\"</code> 删除 <code>ab</code> ，得到 <code>\"cxbae\"</code> 。</li>\n\t</ul>\n\t</li>\n\t<li>删除子字符串<code>\"ba\"</code> 并得到 <code>y</code> 分。\n\t<ul>\n\t\t<li>比方说，从 <code>\"cabx<strong>ba</strong>e\"</code> 删除 <code>ba</code> ，得到 <code>\"cabxe\"</code> 。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请返回对 <code>s</code> 字符串执行上面操作若干次能得到的最大得分。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"cdbcbbaaabab\", x = 4, y = 5\n<b>输出：</b>19\n<strong>解释：</strong>\n- 删除 \"cdbcbbaaa<strong>ba</strong>b\" 中加粗的 \"ba\" ，得到 s = \"cdbcbbaaab\" ，加 5 分。\n- 删除 \"cdbcbbaa<strong>ab</strong>\" 中加粗的 \"ab\" ，得到 s = \"cdbcbbaa\" ，加 4 分。\n- 删除 \"cdbcb<strong>ba</strong>a\" 中加粗的 \"ba\" ，得到 s = \"cdbcba\" ，加 5 分。\n- 删除 \"cdbc<strong>ba</strong>\" 中加粗的 \"ba\" ，得到 s = \"cdbc\" ，加 5 分。\n总得分为 5 + 4 + 5 + 5 = 19 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"aabbaaxybbaabb\", x = 5, y = 4\n<b>输出：</b>20\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= x, y &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1718.构建字典序最大的可行序列",
        "hardRate": "MEDIUM",
        "passRate": "50.89%",
        "problemsUrl": "https://leetcode.cn/problems/construct-the-lexicographically-largest-valid-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-the-lexicographically-largest-valid-sequence/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，请你找到满足下面条件的一个序列：</p>\n\n<ul>\n\t<li>整数 <code>1</code> 在序列中只出现一次。</li>\n\t<li><code>2</code> 到 <code>n</code> 之间每个整数都恰好出现两次。</li>\n\t<li>对于每个 <code>2</code> 到 <code>n</code> 之间的整数 <code>i</code> ，两个 <code>i</code> 之间出现的距离恰好为 <code>i</code> 。</li>\n</ul>\n\n<p>序列里面两个数 <code>a[i]</code> 和 <code>a[j]</code> 之间的 <strong>距离</strong> ，我们定义为它们下标绝对值之差 <code>|j - i|</code> 。</p>\n\n<p>请你返回满足上述条件中 <strong>字典序最大</strong> 的序列。题目保证在给定限制条件下，一定存在解。</p>\n\n<p>一个序列 <code>a</code> 被认为比序列 <code>b</code> （两者长度相同）字典序更大的条件是： <code>a</code> 和 <code>b</code> 中第一个不一样的数字处，<code>a</code> 序列的数字比 <code>b</code> 序列的数字大。比方说，<code>[0,1,9,0]</code> 比 <code>[0,1,5,6]</code> 字典序更大，因为第一个不同的位置是第三个数字，且 <code>9</code> 比 <code>5</code> 大。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 3\n<b>输出：</b>[3,1,2,3,2]\n<b>解释：</b>[2,3,2,1,3] 也是一个可行的序列，但是 [3,1,2,3,2] 是字典序最大的序列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 5\n<b>输出：</b>[5,3,1,4,3,5,2,4,2]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1719.重构一棵树的方案数",
        "hardRate": "HARD",
        "passRate": "69.02%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-reconstruct-a-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-reconstruct-a-tree/solution",
        "problemsDesc": "<p>给你一个数组 <code>pairs</code> ，其中 <code>pairs[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> ，并且满足：</p>\n\n<ul>\n\t<li><code>pairs</code> 中没有重复元素</li>\n\t<li><code>x<sub>i</sub> < y<sub>i</sub></code></li>\n</ul>\n\n<p>令 <code>ways</code> 为满足下面条件的有根树的方案数：</p>\n\n<ul>\n\t<li>树所包含的所有节点值都在 <code>pairs</code> 中。</li>\n\t<li>一个数对 <code>[x<sub>i</sub>, y<sub>i</sub>]</code> 出现在 <code>pairs</code> 中 <strong>当且仅当</strong><strong> </strong><code>x<sub>i</sub></code> 是 <code>y<sub>i</sub></code> 的祖先或者 <code>y<sub>i</sub></code> 是 <code>x<sub>i</sub></code><sub> </sub>的祖先。</li>\n\t<li><strong>注意：</strong>构造出来的树不一定是二叉树。</li>\n</ul>\n\n<p>两棵树被视为不同的方案当存在至少一个节点在两棵树中有不同的父节点。</p>\n\n<p>请你返回：</p>\n\n<ul>\n\t<li>如果 <code>ways == 0</code> ，返回 <code>0</code> 。</li>\n\t<li>如果 <code>ways == 1</code> ，返回 <code>1</code> 。</li>\n\t<li>如果 <code>ways > 1</code> ，返回 <code>2</code> 。</li>\n</ul>\n\n<p>一棵 <strong>有根树</strong> 指的是只有一个根节点的树，所有边都是从根往外的方向。</p>\n\n<p>我们称从根到一个节点路径上的任意一个节点（除去节点本身）都是该节点的 <strong>祖先</strong> 。根节点没有祖先。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/09/trees2.png\" style=\"width: 208px; height: 221px;\" />\n<pre>\n<b>输入：</b>pairs = [[1,2],[2,3]]\n<b>输出：</b>1\n<b>解释：</b>如上图所示，有且只有一个符合规定的有根树。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/09/tree.png\" style=\"width: 234px; height: 241px;\" />\n<pre>\n<b>输入：</b>pairs = [[1,2],[2,3],[1,3]]\n<b>输出：</b>2\n<b>解释：</b>有多个符合规定的有根树，其中三个如上图所示。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>pairs = [[1,2],[2,3],[2,4],[1,5]]\n<b>输出：</b>0\n<b>解释：</b>没有符合规定的有根树。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= pairs.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= x<sub>i </sub>< y<sub>i</sub> <= 500</code></li>\n\t<li><code>pairs</code> 中的元素互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1720.解码异或后的数组",
        "hardRate": "EASY",
        "passRate": "85.94%",
        "problemsUrl": "https://leetcode.cn/problems/decode-xored-array/",
        "solutionsUrl": "https://leetcode.cn/problems/decode-xored-array/solution",
        "problemsDesc": "<p><strong>未知</strong> 整数数组 <code>arr</code> 由 <code>n</code> 个非负整数组成。</p>\n\n<p>经编码后变为长度为 <code>n - 1</code> 的另一个整数数组 <code>encoded</code> ，其中 <code>encoded[i] = arr[i] XOR arr[i + 1]</code> 。例如，<code>arr = [1,0,2,1]</code> 经编码后得到 <code>encoded = [1,2,3]</code> 。</p>\n\n<p>给你编码后的数组 <code>encoded</code> 和原数组 <code>arr</code> 的第一个元素 <code>first</code>（<code>arr[0]</code>）。</p>\n\n<p>请解码返回原数组 <code>arr</code> 。可以证明答案存在并且是唯一的。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>encoded = [1,2,3], first = 1\n<strong>输出：</strong>[1,0,2,1]\n<strong>解释：</strong>若 arr = [1,0,2,1] ，那么 first = 1 且 encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>encoded = [6,2,7,3], first = 4\n<strong>输出：</strong>[4,2,0,7,4]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 10<sup>4</sup></code></li>\n\t<li><code>encoded.length == n - 1</code></li>\n\t<li><code>0 <= encoded[i] <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= first <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1721.交换链表中的节点",
        "hardRate": "MEDIUM",
        "passRate": "63.63%",
        "problemsUrl": "https://leetcode.cn/problems/swapping-nodes-in-a-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/swapping-nodes-in-a-linked-list/solution",
        "problemsDesc": "<p>给你链表的头节点 <code>head</code> 和一个整数 <code>k</code> 。</p>\n\n<p><strong>交换</strong> 链表正数第 <code>k</code> 个节点和倒数第 <code>k</code> 个节点的值后，返回链表的头节点（链表 <strong>从 1 开始索引</strong>）。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/10/linked1.jpg\" style=\"width: 722px; height: 202px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], k = 2\n<strong>输出：</strong>[1,4,3,2,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [7,9,6,6,7,8,3,0,9,5], k = 5\n<strong>输出：</strong>[7,9,6,6,8,7,3,0,9,5]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1], k = 1\n<strong>输出：</strong>[1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2], k = 1\n<strong>输出：</strong>[2,1]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,3], k = 2\n<strong>输出：</strong>[1,2,3]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目是 <code>n</code></li>\n\t<li><code>1 <= k <= n <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= Node.val <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1722.执行交换操作后的最小汉明距离",
        "hardRate": "MEDIUM",
        "passRate": "51.03%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-hamming-distance-after-swap-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-hamming-distance-after-swap-operations/solution",
        "problemsDesc": "<p>给你两个整数数组 <code>source</code> 和 <code>target</code> ，长度都是 <code>n</code> 。还有一个数组 <code>allowedSwaps</code> ，其中每个 <code>allowedSwaps[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示你可以交换数组 <code>source</code> 中下标为 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code>（<strong>下标从 0 开始</strong>）的两个元素。注意，你可以按 <strong>任意</strong> 顺序 <strong>多次</strong> 交换一对特定下标指向的元素。</p>\n\n<p>相同长度的两个数组 <code>source</code> 和 <code>target</code> 间的 <strong>汉明距离</strong> 是元素不同的下标数量。形式上，其值等于满足 <code>source[i] != target[i]</code> （<strong>下标从 0 开始</strong>）的下标 <code>i</code>（<code>0 &lt;= i &lt;= n-1</code>）的数量。</p>\n\n<p>在对数组 <code>source</code> 执行 <strong>任意</strong> 数量的交换操作后，返回 <code>source</code> 和 <code>target</code> 间的 <strong>最小汉明距离</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]]\n<strong>输出：</strong>1\n<strong>解释：</strong>source 可以按下述方式转换：\n- 交换下标 0 和 1 指向的元素：source = [<strong>2</strong>,<strong>1</strong>,3,4]\n- 交换下标 2 和 3 指向的元素：source = [2,1,<strong>4</strong>,<strong>3</strong>]\nsource 和 target 间的汉明距离是 1 ，二者有 1 处元素不同，在下标 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = []\n<strong>输出：</strong>2\n<strong>解释：</strong>不能对 source 执行交换操作。\nsource 和 target 间的汉明距离是 2 ，二者有 2 处元素不同，在下标 1 和下标 2 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>source = [5,1,2,4,3], target = [1,5,4,2,3], allowedSwaps = [[0,4],[4,2],[1,3],[1,4]]\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == source.length == target.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= source[i], target[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= allowedSwaps.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>allowedSwaps[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1723.完成所有工作的最短时间",
        "hardRate": "HARD",
        "passRate": "50.86%",
        "problemsUrl": "https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/",
        "solutionsUrl": "https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>jobs</code> ，其中 <code>jobs[i]</code> 是完成第 <code>i</code> 项工作要花费的时间。</p>\n\n<p>请你将这些工作分配给 <code>k</code> 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 <strong>工作时间</strong> 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 <strong>最大工作时间</strong> 得以 <strong>最小化</strong> 。</p>\n\n<p>返回分配方案中尽可能 <strong>最小</strong> 的 <strong>最大工作时间</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>jobs = [3,2,3], k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>给每位工人分配一项工作，最大工作时间是 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>jobs = [1,2,4,7,8], k = 2\n<strong>输出：</strong>11\n<strong>解释：</strong>按下述方式分配工作：\n1 号工人：1、2、8（工作时间 = 1 + 2 + 8 = 11）\n2 号工人：4、7（工作时间 = 4 + 7 = 11）\n最大工作时间是 11 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= k <= jobs.length <= 12</code></li>\n\t<li><code>1 <= jobs[i] <= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1724.检查边长度限制的路径是否存在 II",
        "hardRate": "HARD",
        "passRate": "58.40%",
        "problemsUrl": "https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1725.可以形成最大正方形的矩形数目",
        "hardRate": "EASY",
        "passRate": "82.80%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-rectangles-that-can-form-the-largest-square/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-rectangles-that-can-form-the-largest-square/solution",
        "problemsDesc": "<p>给你一个数组 <code>rectangles</code> ，其中 <code>rectangles[i] = [l<sub>i</sub>, w<sub>i</sub>]</code> 表示第 <code>i</code> 个矩形的长度为 <code>l<sub>i</sub></code> 、宽度为 <code>w<sub>i</sub></code> 。</p>\n\n<p>如果存在 <code>k</code> 同时满足 <code>k <= l<sub>i</sub></code> 和 <code>k <= w<sub>i</sub></code> ，就可以将第 <code>i</code> 个矩形切成边长为 <code>k</code> 的正方形。例如，矩形 <code>[4,6]</code> 可以切成边长最大为 <code>4</code> 的正方形。</p>\n\n<p>设 <code>maxLen</code> 为可以从矩形数组 <code>rectangles</code> 切分得到的 <strong>最大正方形</strong> 的边长。</p>\n\n<p>请你统计有多少个矩形能够切出边长为<em> </em><code>maxLen</code> 的正方形，并返回矩形 <strong>数目</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rectangles = [[5,8],[3,9],[5,12],[16,5]]\n<strong>输出：</strong>3\n<strong>解释：</strong>能从每个矩形中切出的最大正方形边长分别是 [5,3,5,5] 。\n最大正方形的边长为 5 ，可以由 3 个矩形切分得到。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rectangles = [[2,3],[3,7],[4,3],[3,7]]\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= rectangles.length <= 1000</code></li>\n\t<li><code>rectangles[i].length == 2</code></li>\n\t<li><code>1 <= l<sub>i</sub>, w<sub>i</sub> <= 10<sup>9</sup></code></li>\n\t<li><code>l<sub>i</sub> != w<sub>i</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1726.同积元组",
        "hardRate": "MEDIUM",
        "passRate": "52.21%",
        "problemsUrl": "https://leetcode.cn/problems/tuple-with-same-product/",
        "solutionsUrl": "https://leetcode.cn/problems/tuple-with-same-product/solution",
        "problemsDesc": "<p>给你一个由 <strong>不同</strong> 正整数组成的数组 <code>nums</code> ，请你返回满足&nbsp;<code>a * b = c * d</code> 的元组<em> </em><code>(a, b, c, d)</code><em> </em>的数量。其中 <code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> 都是 <code>nums</code> 中的元素，且 <code>a != b != c != d</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,4,6]\n<strong>输出：</strong>8\n<strong>解释：</strong>存在 8 个满足题意的元组：\n(2,6,3,4) , (2,6,4,3) , (6,2,3,4) , (6,2,4,3)\n(3,4,2,6) , (4,3,2,6) , (3,4,6,2) , (4,3,6,2)\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,4,5,10]\n<strong>输出：</strong>16\n<strong>解释：</strong>存在 16 个满足题意的元组：\n(1,10,2,5) , (1,10,5,2) , (10,1,2,5) , (10,1,5,2)\n(2,5,1,10) , (2,5,10,1) , (5,2,1,10) , (5,2,10,1)\n(2,10,4,5) , (2,10,5,4) , (10,2,4,5) , (10,2,4,5)\n(4,5,2,10) , (4,5,10,2) , (5,4,2,10) , (5,4,10,2)\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1727.重新排列后的最大子矩阵",
        "hardRate": "MEDIUM",
        "passRate": "59.25%",
        "problemsUrl": "https://leetcode.cn/problems/largest-submatrix-with-rearrangements/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-submatrix-with-rearrangements/solution",
        "problemsDesc": "<p>给你一个二进制矩阵 <code>matrix</code> ，它的大小为 <code>m x n</code> ，你可以将 <code>matrix</code> 中的 <strong>列</strong> 按任意顺序重新排列。</p>\n\n<p>请你返回最优方案下将 <code>matrix</code> 重新排列后，全是 <code>1</code> 的子矩阵面积。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/17/screenshot-2020-12-30-at-40536-pm.png\" style=\"width: 300px; height: 144px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>matrix = [[0,0,1],[1,1,1],[1,0,1]]\n<b>输出：</b>4\n<b>解释：</b>你可以按照上图方式重新排列矩阵的每一列。\n最大的全 1 子矩阵是上图中加粗的部分，面积为 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/17/screenshot-2020-12-30-at-40852-pm.png\" style=\"width: 500px; height: 62px;\" /></p>\n\n<pre>\n<b>输入：</b>matrix = [[1,0,1,0,1]]\n<b>输出：</b>3\n<b>解释：</b>你可以按照上图方式重新排列矩阵的每一列。\n最大的全 1 子矩阵是上图中加粗的部分，面积为 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>matrix = [[1,1,0],[1,0,1]]\n<b>输出：</b>2\n<b>解释：</b>由于你只能整列整列重新排布，所以没有比面积为 2 更大的全 1 子矩形。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>matrix = [[0,0],[0,0]]\n<b>输出：</b>0\n<b>解释：</b>由于矩阵中没有 1 ，没有任何全 1 的子矩阵，所以面积为 0 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 <= m * n <= 10<sup>5</sup></code></li>\n\t<li><code>matrix[i][j]</code> 要么是 <code>0</code> ，要么是 <code>1</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1728.猫和老鼠 II",
        "hardRate": "HARD",
        "passRate": "64.11%",
        "problemsUrl": "https://leetcode.cn/problems/cat-and-mouse-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/cat-and-mouse-ii/solution",
        "problemsDesc": "<p>一只猫和一只老鼠在玩一个叫做猫和老鼠的游戏。</p>\n\n<p>它们所处的环境设定是一个 <code>rows x cols</code> 的方格 <code>grid</code> ，其中每个格子可能是一堵墙、一块地板、一位玩家（猫或者老鼠）或者食物。</p>\n\n<ul>\n\t<li>玩家由字符 <code>'C'</code> （代表猫）和 <code>'M'</code> （代表老鼠）表示。</li>\n\t<li>地板由字符 <code>'.'</code> 表示，玩家可以通过这个格子。</li>\n\t<li>墙用字符 <code>'#'</code> 表示，玩家不能通过这个格子。</li>\n\t<li>食物用字符 <code>'F'</code> 表示，玩家可以通过这个格子。</li>\n\t<li>字符 <code>'C'</code> ， <code>'M'</code> 和 <code>'F'</code> 在 <code>grid</code> 中都只会出现一次。</li>\n</ul>\n\n<p>猫和老鼠按照如下规则移动：</p>\n\n<ul>\n\t<li>老鼠 <strong>先移动</strong> ，然后两名玩家轮流移动。</li>\n\t<li>每一次操作时，猫和老鼠可以跳到上下左右四个方向之一的格子，他们不能跳过墙也不能跳出 <code>grid</code> 。</li>\n\t<li><code>catJump</code> 和 <code>mouseJump</code> 是猫和老鼠分别跳一次能到达的最远距离，它们也可以跳小于最大距离的长度。</li>\n\t<li>它们可以停留在原地。</li>\n\t<li>老鼠可以跳跃过猫的位置。</li>\n</ul>\n\n<p>游戏有 4 种方式会结束：</p>\n\n<ul>\n\t<li>如果猫跟老鼠处在相同的位置，那么猫获胜。</li>\n\t<li>如果猫先到达食物，那么猫获胜。</li>\n\t<li>如果老鼠先到达食物，那么老鼠获胜。</li>\n\t<li>如果老鼠不能在 1000 次操作以内到达食物，那么猫获胜。</li>\n</ul>\n\n<p>给你 <code>rows x cols</code> 的矩阵 <code>grid</code> 和两个整数 <code>catJump</code> 和 <code>mouseJump</code> ，双方都采取最优策略，如果老鼠获胜，那么请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/17/sample_111_1955.png\" style=\"width: 580px; height: 239px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>grid = [\"####F\",\"#C...\",\"M....\"], catJump = 1, mouseJump = 2\n<b>输出：</b>true\n<b>解释：</b>猫无法抓到老鼠，也没法比老鼠先到达食物。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/17/sample_2_1955.png\" style=\"width: 580px; height: 175px;\" /></p>\n\n<pre>\n<b>输入：</b>grid = [\"M.C...F\"], catJump = 1, mouseJump = 4\n<b>输出：</b>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>grid = [\"M.C...F\"], catJump = 1, mouseJump = 3\n<b>输出：</b>false\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>grid = [\"C...#\",\"...#F\",\"....#\",\"M....\"], catJump = 2, mouseJump = 5\n<b>输出：</b>false\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<b>输入：</b>grid = [\".M...\",\"..#..\",\"#..#.\",\"C#.#.\",\"...#F\"], catJump = 3, mouseJump = 1\n<b>输出：</b>true\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rows == grid.length</code></li>\n\t<li><code>cols = grid[i].length</code></li>\n\t<li><code>1 <= rows, cols <= 8</code></li>\n\t<li><code>grid[i][j]</code> 只包含字符 <code>'C'</code> ，<code>'M'</code> ，<code>'F'</code> ，<code>'.'</code> 和 <code>'#'</code> 。</li>\n\t<li><code>grid</code> 中只包含一个 <code>'C'</code> ，<code>'M'</code> 和 <code>'F'</code> 。</li>\n\t<li><code>1 <= catJump, mouseJump <= 8</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1729.求关注者的数量",
        "hardRate": "EASY",
        "passRate": "61.46%",
        "problemsUrl": "https://leetcode.cn/problems/find-followers-count/",
        "solutionsUrl": "https://leetcode.cn/problems/find-followers-count/solution",
        "problemsDesc": "<p>表：&nbsp;<code>Followers</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| user_id     | int  |\n| follower_id | int  |\n+-------------+------+\n(user_id, follower_id) 是这个表的主键。\n该表包含一个关注关系中关注者和用户的编号，其中关注者关注用户。</pre>\n\n<p>&nbsp;</p>\n\n<p>写出 SQL 语句，对于每一个用户，返回该用户的关注者数量。</p>\n\n<p>按&nbsp;<code>user_id</code>&nbsp;的顺序返回结果表。</p>\n\n<p>查询结果的格式如下示例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nFollowers 表：\n+---------+-------------+\n| user_id | follower_id |\n+---------+-------------+\n| 0       | 1           |\n| 1       | 0           |\n| 2       | 0           |\n| 2       | 1           |\n+---------+-------------+\n<strong>输出：</strong>\n+---------+----------------+\n| user_id | followers_count|\n+---------+----------------+\n| 0       | 1              |\n| 1       | 1              |\n| 2       | 2              |\n+---------+----------------+\n<strong>解释：</strong>\n0 的关注者有 {1}\n1 的关注者有 {0}\n2 的关注者有 {0,1}</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1730.获取食物的最短路径",
        "hardRate": "MEDIUM",
        "passRate": "52.73%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-path-to-get-food/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-path-to-get-food/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1731.每位经理的下属员工数量",
        "hardRate": "EASY",
        "passRate": "47.06%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-employees-which-report-to-each-employee/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-employees-which-report-to-each-employee/solution",
        "problemsDesc": "<p>Table: <code>Employees</code></p>\n\n<pre>+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| employee_id | int      |\n| name        | varchar  |\n| reports_to  | int      |\n| age         | int      |\n+-------------+----------+\nemployee_id 是这个表的主键.\n该表包含员工以及需要听取他们汇报的上级经理的ID的信息。 有些员工不需要向任何人汇报（reports_to 为空）。\n</pre>\n\n<p> </p>\n\n<p>对于此问题，我们将至少有一个其他员工需要向他汇报的员工，视为一个经理。</p>\n\n<p>编写SQL查询需要听取汇报的所有经理的ID、名称、直接向该经理汇报的员工人数，以及这些员工的平均年龄，其中该平均年龄需要四舍五入到最接近的整数。</p>\n\n<p>返回的结果集需要按照 <code>employee_id </code>进行排序。</p>\n\n<p>查询结果的格式如下：</p>\n\n<p> </p>\n\n<pre>Employees table:\n+-------------+---------+------------+-----+\n| employee_id | name    | reports_to | age |\n+-------------+---------+------------+-----+\n| 9           | Hercy   | null       | 43  |\n| 6           | Alice   | 9          | 41  |\n| 4           | Bob     | 9          | 36  |\n| 2           | Winston | null       | 37  |\n+-------------+---------+------------+-----+\n\nResult table:\n+-------------+-------+---------------+-------------+\n| employee_id | name  | reports_count | average_age |\n+-------------+-------+---------------+-------------+\n| 9           | Hercy | 2             | 39          |\n+-------------+-------+---------------+-------------+\nHercy 有两个需要向他汇报的员工, 他们是 Alice and Bob. 他们的平均年龄是 (41+36)/2 = 38.5, 四舍五入的结果是 39.\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1732.找到最高海拔",
        "hardRate": "EASY",
        "passRate": "81.27%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-highest-altitude/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-highest-altitude/solution",
        "problemsDesc": "<p>有一个自行车手打算进行一场公路骑行，这条路线总共由 <code>n + 1</code> 个不同海拔的点组成。自行车手从海拔为 <code>0</code> 的点 <code>0</code> 开始骑行。</p>\n\n<p>给你一个长度为 <code>n</code> 的整数数组 <code>gain</code> ，其中 <code>gain[i]</code> 是点 <code>i</code> 和点 <code>i + 1</code> 的 <strong>净海拔高度差</strong>（<code>0 <= i < n</code>）。请你返回 <strong>最高点的海拔</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>gain = [-5,1,5,0,-7]\n<b>输出：</b>1\n<b>解释：</b>海拔高度依次为 [0,-5,-4,1,1,-6] 。最高海拔为 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>gain = [-4,-3,-2,-1,4,3,2]\n<b>输出：</b>0\n<b>解释：</b>海拔高度依次为 [0,-4,-7,-9,-10,-6,-3,-1] 。最高海拔为 0 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == gain.length</code></li>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>-100 <= gain[i] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1733.需要教语言的最少人数",
        "hardRate": "MEDIUM",
        "passRate": "48.60%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-people-to-teach/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-people-to-teach/solution",
        "problemsDesc": "<p>在一个由 <code>m</code> 个用户组成的社交网络里，我们获取到一些用户之间的好友关系。两个用户之间可以相互沟通的条件是他们都掌握同一门语言。</p>\n\n<p>给你一个整数 <code>n</code> ，数组 <code>languages</code> 和数组 <code>friendships</code> ，它们的含义如下：</p>\n\n<ul>\n\t<li>总共有 <code>n</code> 种语言，编号从 <code>1</code> 到 <code>n</code> 。</li>\n\t<li><code>languages[i]</code> 是第 <code>i</code> 位用户掌握的语言集合。</li>\n\t<li><code>friendships[i] = [u<sub>​​​​​​i</sub>​​​, v<sub>​​​​​​i</sub>]</code> 表示 <code>u<sup>​​​​​</sup><sub>​​​​​​i</sub></code>​​​​​ 和 <code>v<sub>i</sub></code> 为好友关系。</li>\n</ul>\n\n<p>你可以选择 <strong>一门</strong> 语言并教会一些用户，使得所有好友之间都可以相互沟通。请返回你 <strong>最少</strong> 需要教会多少名用户。</p>\n请注意，好友关系没有传递性，也就是说如果 <code>x</code> 和 <code>y</code> 是好友，且 <code>y</code> 和 <code>z</code> 是好友， <code>x</code> 和 <code>z</code> 不一定是好友。\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 2, languages = [[1],[2],[1,2]], friendships = [[1,2],[1,3],[2,3]]\n<b>输出：</b>1\n<b>解释：</b>你可以选择教用户 1 第二门语言，也可以选择教用户 2 第一门语言。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, languages = [[2],[1,3],[1,2],[3]], friendships = [[1,4],[1,2],[3,4],[2,3]]\n<b>输出：</b>2\n<b>解释：</b>教用户 1 和用户 3 第三门语言，需要教 2 名用户。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 500</code></li>\n\t<li><code>languages.length == m</code></li>\n\t<li><code>1 <= m <= 500</code></li>\n\t<li><code>1 <= languages[i].length <= n</code></li>\n\t<li><code>1 <= languages[i][j] <= n</code></li>\n\t<li><code>1 <= u<sub>​​​​​​i</sub> < v<sub>​​​​​​i</sub> <= languages.length</code></li>\n\t<li><code>1 <= friendships.length <= 500</code></li>\n\t<li>所有的好友关系 <code>(u<sub>​​​​​i, </sub>v<sub>​​​​​​i</sub>)</code> 都是唯一的。</li>\n\t<li><code>languages[i]</code> 中包含的值互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1734.解码异或后的排列",
        "hardRate": "MEDIUM",
        "passRate": "72.45%",
        "problemsUrl": "https://leetcode.cn/problems/decode-xored-permutation/",
        "solutionsUrl": "https://leetcode.cn/problems/decode-xored-permutation/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>perm</code> ，它是前 <code>n</code> 个正整数的排列，且 <code>n</code> 是个 <strong>奇数</strong> 。</p>\n\n<p>它被加密成另一个长度为 <code>n - 1</code> 的整数数组 <code>encoded</code> ，满足 <code>encoded[i] = perm[i] XOR perm[i + 1]</code> 。比方说，如果 <code>perm = [1,3,2]</code> ，那么 <code>encoded = [2,1]</code> 。</p>\n\n<p>给你 <code>encoded</code> 数组，请你返回原始数组 <code>perm</code> 。题目保证答案存在且唯一。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>encoded = [3,1]\n<b>输出：</b>[1,2,3]\n<b>解释：</b>如果 perm = [1,2,3] ，那么 encoded = [1 XOR 2,2 XOR 3] = [3,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>encoded = [6,5,4,6]\n<b>输出：</b>[2,4,1,5,3]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt; 10<sup>5</sup></code></li>\n\t<li><code>n</code> 是奇数。</li>\n\t<li><code>encoded.length == n - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1735.生成乘积数组的方案数",
        "hardRate": "HARD",
        "passRate": "52.46%",
        "problemsUrl": "https://leetcode.cn/problems/count-ways-to-make-array-with-product/",
        "solutionsUrl": "https://leetcode.cn/problems/count-ways-to-make-array-with-product/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>queries</code> ，其中 <code>queries[i] = [n<sub>i</sub>, k<sub>i</sub>]</code> 。第 <code>i</code> 个查询 <code>queries[i]</code> 要求构造长度为 <code>n<sub>i</sub></code> 、每个元素都是正整数的数组，且满足所有元素的乘积为 <code>k<sub>i</sub></code><sub> </sub>，请你找出有多少种可行的方案。由于答案可能会很大，方案数需要对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 。</p>\n\n<p>请你返回一个整数数组<em> </em><code>answer</code>，满足<em> </em><code>answer.length == queries.length</code> ，其中<em> </em><code>answer[i]</code>是第<em> </em><code>i</code> 个查询的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>queries = [[2,6],[5,1],[73,660]]\n<b>输出：</b>[4,1,50734910]\n<b>解释：</b>每个查询之间彼此独立。\n[2,6]：总共有 4 种方案得到长度为 2 且乘积为 6 的数组：[1,6]，[2,3]，[3,2]，[6,1]。\n[5,1]：总共有 1 种方案得到长度为 5 且乘积为 1 的数组：[1,1,1,1,1]。\n[73,660]：总共有 1050734917 种方案得到长度为 73 且乘积为 660 的数组。1050734917 对 10<sup>9</sup> + 7 取余得到 50734910 。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre>\n<b>输入：</b>queries = [[1,1],[2,2],[3,3],[4,4],[5,5]]\n<b>输出：</b>[1,2,3,10,5]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= queries.length <= 10<sup>4</sup> </code></li>\n\t<li><code>1 <= n<sub>i</sub>, k<sub>i</sub> <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1736.替换隐藏数字得到的最晚时间",
        "hardRate": "EASY",
        "passRate": "44.44%",
        "problemsUrl": "https://leetcode.cn/problems/latest-time-by-replacing-hidden-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/latest-time-by-replacing-hidden-digits/solution",
        "problemsDesc": "<p>给你一个字符串 <code>time</code> ，格式为 <code> hh:mm</code>（小时：分钟），其中某几位数字被隐藏（用 <code>?</code> 表示）。</p>\n\n<p>有效的时间为 <code>00:00</code> 到 <code>23:59</code> 之间的所有时间，包括 <code>00:00</code> 和 <code>23:59</code> 。</p>\n\n<p>替换 <code>time</code> 中隐藏的数字，返回你可以得到的最晚有效时间。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>time = \"2?:?0\"\n<strong>输出：</strong>\"23:50\"\n<strong>解释：</strong>以数字 '2' 开头的最晚一小时是 23 ，以 '0' 结尾的最晚一分钟是 50 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>time = \"0?:3?\"\n<strong>输出：</strong>\"09:39\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>time = \"1?:22\"\n<strong>输出：</strong>\"19:22\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>time</code> 的格式为 <code>hh:mm</code></li>\n\t<li>题目数据保证你可以由输入的字符串生成有效的时间</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1737.满足三条件之一需改变的最少字符数",
        "hardRate": "MEDIUM",
        "passRate": "35.82%",
        "problemsUrl": "https://leetcode.cn/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/",
        "solutionsUrl": "https://leetcode.cn/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/solution",
        "problemsDesc": "<p>给你两个字符串 <code>a</code> 和 <code>b</code> ，二者均由小写字母组成。一步操作中，你可以将 <code>a</code> 或 <code>b</code> 中的 <strong>任一字符</strong> 改变为 <strong>任一小写字母</strong> 。</p>\n\n<p>操作的最终目标是满足下列三个条件 <strong>之一</strong> ：</p>\n\n<ul>\n\t<li><code>a</code> 中的 <strong>每个字母</strong> 在字母表中 <strong>严格小于</strong> <code>b</code> 中的 <strong>每个字母</strong> 。</li>\n\t<li><code>b</code> 中的 <strong>每个字母</strong> 在字母表中 <strong>严格小于</strong> <code>a</code> 中的 <strong>每个字母</strong> 。</li>\n\t<li><code>a</code> 和 <code>b</code> <strong>都</strong> 由 <strong>同一个</strong> 字母组成。</li>\n</ul>\n\n<p>返回达成目标所需的 <strong>最少</strong> 操作数<em>。</em></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>a = \"aba\", b = \"caa\"\n<strong>输出：</strong>2\n<strong>解释：</strong>满足每个条件的最佳方案分别是：\n1) 将 b 变为 \"ccc\"，2 次操作，满足 a 中的每个字母都小于 b 中的每个字母；\n2) 将 a 变为 \"bbb\" 并将 b 变为 \"aaa\"，3 次操作，满足 b 中的每个字母都小于 a 中的每个字母；\n3) 将 a 变为 \"aaa\" 并将 b 变为 \"aaa\"，2 次操作，满足 a 和 b 由同一个字母组成。\n最佳的方案只需要 2 次操作（满足条件 1 或者条件 3）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>a = \"dabadd\", b = \"cda\"\n<strong>输出：</strong>3\n<strong>解释：</strong>满足条件 1 的最佳方案是将 b 变为 \"eee\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>a</code> 和 <code>b</code> 只由小写字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1738.找出第 K 大的异或坐标值",
        "hardRate": "MEDIUM",
        "passRate": "65.11%",
        "problemsUrl": "https://leetcode.cn/problems/find-kth-largest-xor-coordinate-value/",
        "solutionsUrl": "https://leetcode.cn/problems/find-kth-largest-xor-coordinate-value/solution",
        "problemsDesc": "<p>给你一个二维矩阵 <code>matrix</code> 和一个整数 <code>k</code> ，矩阵大小为 <code>m x n</code> 由非负整数组成。</p>\n\n<p>矩阵中坐标 <code>(a, b)</code> 的 <strong>值</strong> 可由对所有满足 <code>0 &lt;= i &lt;= a &lt; m</code> 且 <code>0 &lt;= j &lt;= b &lt; n</code> 的元素 <code>matrix[i][j]</code>（<strong>下标从 0 开始计数</strong>）执行异或运算得到。</p>\n\n<p>请你找出 <code>matrix</code> 的所有坐标中第 <code>k</code> 大的值（<strong><code>k</code> 的值从 1 开始计数</strong>）。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>matrix = [[5,2],[1,6]], k = 1\n<strong>输出：</strong>7\n<strong>解释：</strong>坐标 (0,1) 的值是 5 XOR 2 = 7 ，为最大的值。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>matrix = [[5,2],[1,6]], k = 2\n<strong>输出：</strong>5\n<strong>解释：</strong>坐标 (0,0) 的值是 5 = 5 ，为第 2 大的值。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>matrix = [[5,2],[1,6]], k = 3\n<strong>输出：</strong>4\n<strong>解释：</strong>坐标 (1,0) 的值是 5 XOR 1 = 4 ，为第 3 大的值。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>matrix = [[5,2],[1,6]], k = 4\n<strong>输出：</strong>0\n<strong>解释：</strong>坐标 (1,1) 的值是 5 XOR 2 XOR 1 XOR 6 = 0 ，为第 4 大的值。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= matrix[i][j] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= m * n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1739.放置盒子",
        "hardRate": "HARD",
        "passRate": "64.35%",
        "problemsUrl": "https://leetcode.cn/problems/building-boxes/",
        "solutionsUrl": "https://leetcode.cn/problems/building-boxes/solution",
        "problemsDesc": "<p>有一个立方体房间，其长度、宽度和高度都等于 <code>n</code> 个单位。请你在房间里放置 <code>n</code> 个盒子，每个盒子都是一个单位边长的立方体。放置规则如下：</p>\n\n<ul>\n\t<li>你可以把盒子放在地板上的任何地方。</li>\n\t<li>如果盒子 <code>x</code> 需要放置在盒子 <code>y</code> 的顶部，那么盒子 <code>y</code> 竖直的四个侧面都 <strong>必须</strong> 与另一个盒子或墙相邻。</li>\n</ul>\n\n<p>给你一个整数 <code>n</code> ，返回接触地面的盒子的 <strong>最少</strong> 可能数量<em>。</em></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/24/3-boxes.png\" style=\"width: 135px; height: 143px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>上图是 3 个盒子的摆放位置。\n这些盒子放在房间的一角，对应左侧位置。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/24/4-boxes.png\" style=\"width: 135px; height: 179px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>上图是 3 个盒子的摆放位置。\n这些盒子放在房间的一角，对应左侧位置。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/24/10-boxes.png\" style=\"width: 271px; height: 257px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 10\n<strong>输出：</strong>6\n<strong>解释：</strong>上图是 10 个盒子的摆放位置。\n这些盒子放在房间的一角，对应后方位置。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1740.找到二叉树中的距离",
        "hardRate": "MEDIUM",
        "passRate": "67.04%",
        "problemsUrl": "https://leetcode.cn/problems/find-distance-in-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/find-distance-in-a-binary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1741.查找每个员工花费的总时间",
        "hardRate": "EASY",
        "passRate": "84.56%",
        "problemsUrl": "https://leetcode.cn/problems/find-total-time-spent-by-each-employee/",
        "solutionsUrl": "https://leetcode.cn/problems/find-total-time-spent-by-each-employee/solution",
        "problemsDesc": "<p>表: <code>Employees</code></p>\n\n<pre>+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| emp_id      | int  |\n| event_day   | date |\n| in_time     | int  |\n| out_time    | int  |\n+-------------+------+\n(emp_id, event_day, in_time) 是这个表的主键。\n该表显示了员工在办公室的出入情况。\nevent_day 是此事件发生的日期，in_time 是员工进入办公室的时间，而 out_time 是他们离开办公室的时间。\nin_time 和 out_time 的取值在1到1440之间。\n题目保证同一天没有两个事件在时间上是相交的，并且保证 in_time 小于 out_time。\n</pre>\n\n<p> </p>\n\n<p>编写一个SQL查询以计算每位员工每天在办公室花费的总时间（以分钟为单位）。 请注意，在一天之内，同一员工是可以多次进入和离开办公室的。 在办公室里一次进出所花费的时间为out_time 减去 in_time。</p>\n\n<p>返回结果表单的顺序无要求。<br>\n查询结果的格式如下：</p>\n\n<pre>Employees table:\n+--------+------------+---------+----------+\n| emp_id | event_day  | in_time | out_time |\n+--------+------------+---------+----------+\n| 1      | 2020-11-28 | 4       | 32       |\n| 1      | 2020-11-28 | 55      | 200      |\n| 1      | 2020-12-03 | 1       | 42       |\n| 2      | 2020-11-28 | 3       | 33       |\n| 2      | 2020-12-09 | 47      | 74       |\n+--------+------------+---------+----------+\nResult table:\n+------------+--------+------------+\n| day        | emp_id | total_time |\n+------------+--------+------------+\n| 2020-11-28 | 1      | 173        |\n| 2020-11-28 | 2      | 30         |\n| 2020-12-03 | 1      | 41         |\n| 2020-12-09 | 2      | 27         |\n+------------+--------+------------+\n雇员 1 有三次进出: 有两次发生在 2020-11-28 花费的时间为 (32 - 4) + (200 - 55) = 173, 有一次发生在 2020-12-03 花费的时间为 (42 - 1) = 41。\n雇员 2 有两次进出: 有一次发生在 2020-11-28 花费的时间为 (33 - 3) = 30,  有一次发生在 2020-12-09 花费的时间为 (74 - 47) = 27。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1742.盒子中小球的最大数量",
        "hardRate": "EASY",
        "passRate": "75.79%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-balls-in-a-box/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-balls-in-a-box/solution",
        "problemsDesc": "<p>你在一家生产小球的玩具厂工作，有 <code>n</code> 个小球，编号从 <code>lowLimit</code> 开始，到 <code>highLimit</code> 结束（包括 <code>lowLimit</code> 和 <code>highLimit</code> ，即 <code>n == highLimit - lowLimit + 1</code>）。另有无限数量的盒子，编号从 <code>1</code> 到 <code>infinity</code> 。</p>\n\n<p>你的工作是将每个小球放入盒子中，其中盒子的编号应当等于小球编号上每位数字的和。例如，编号 <code>321</code> 的小球应当放入编号 <code>3 + 2 + 1 = 6</code> 的盒子，而编号 <code>10</code> 的小球应当放入编号 <code>1 + 0 = 1</code> 的盒子。</p>\n\n<p>给你两个整数 <code>lowLimit</code> 和 <code>highLimit</code> ，返回放有最多小球的盒子中的小球数量<em>。</em>如果有多个盒子都满足放有最多小球，只需返回其中任一盒子的小球数量。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>lowLimit = 1, highLimit = 10\n<strong>输出：</strong>2\n<strong>解释：</strong>\n盒子编号：1 2 3 4 5 6 7 8 9 10 11 ...\n小球数量：2 1 1 1 1 1 1 1 1 0  0  ...\n编号 1 的盒子放有最多小球，小球数量为 2 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>lowLimit = 5, highLimit = 15\n<strong>输出：</strong>2\n<strong>解释：</strong>\n盒子编号：1 2 3 4 5 6 7 8 9 10 11 ...\n小球数量：1 1 1 1 2 2 1 1 1 0  0  ...\n编号 5 和 6 的盒子放有最多小球，每个盒子中的小球数量都是 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>lowLimit = 19, highLimit = 28\n<strong>输出：</strong>2\n<strong>解释：</strong>\n盒子编号：1 2 3 4 5 6 7 8 9 10 11 12 ...\n小球数量：0 1 1 1 1 1 1 1 1 2  0  0  ...\n编号 10 的盒子放有最多小球，小球数量为 2 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= lowLimit <= highLimit <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1743.从相邻元素对还原数组",
        "hardRate": "MEDIUM",
        "passRate": "69.59%",
        "problemsUrl": "https://leetcode.cn/problems/restore-the-array-from-adjacent-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/restore-the-array-from-adjacent-pairs/solution",
        "problemsDesc": "<p>存在一个由 <code>n</code> 个不同元素组成的整数数组 <code>nums</code> ，但你已经记不清具体内容。好在你还记得 <code>nums</code> 中的每一对相邻元素。</p>\n\n<p>给你一个二维整数数组 <code>adjacentPairs</code> ，大小为 <code>n - 1</code> ，其中每个 <code>adjacentPairs[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> 表示元素 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code> 在 <code>nums</code> 中相邻。</p>\n\n<p>题目数据保证所有由元素 <code>nums[i]</code> 和 <code>nums[i+1]</code> 组成的相邻元素对都存在于 <code>adjacentPairs</code> 中，存在形式可能是 <code>[nums[i], nums[i+1]]</code> ，也可能是 <code>[nums[i+1], nums[i]]</code> 。这些相邻元素对可以 <strong>按任意顺序</strong> 出现。</p>\n\n<p>返回 <strong>原始数组</strong><em> </em><code>nums</code><em> </em>。如果存在多种解答，返回 <strong>其中任意一个</strong> 即可。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>adjacentPairs = [[2,1],[3,4],[3,2]]\n<strong>输出：</strong>[1,2,3,4]\n<strong>解释：</strong>数组的所有相邻元素对都在 adjacentPairs 中。\n特别要注意的是，adjacentPairs[i] 只表示两个元素相邻，并不保证其 左-右 顺序。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>adjacentPairs = [[4,-2],[1,4],[-3,1]]\n<strong>输出：</strong>[-2,4,1,-3]\n<strong>解释：</strong>数组中可能存在负数。\n另一种解答是 [-3,1,4,-2] ，也会被视作正确答案。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>adjacentPairs = [[100000,-100000]]\n<strong>输出：</strong>[100000,-100000]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length == n</code></li>\n\t<li><code>adjacentPairs.length == n - 1</code></li>\n\t<li><code>adjacentPairs[i].length == 2</code></li>\n\t<li><code>2 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> <= nums[i], u<sub>i</sub>, v<sub>i</sub> <= 10<sup>5</sup></code></li>\n\t<li>题目数据保证存在一些以 <code>adjacentPairs</code> 作为元素对的数组 <code>nums</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1744.你能在你最喜欢的那天吃到你最喜欢的糖果吗？",
        "hardRate": "MEDIUM",
        "passRate": "36.37%",
        "problemsUrl": "https://leetcode.cn/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/",
        "solutionsUrl": "https://leetcode.cn/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的正整数数组 <code>candiesCount</code> ，其中 <code>candiesCount[i]</code> 表示你拥有的第 <code>i</code> 类糖果的数目。同时给你一个二维数组 <code>queries</code> ，其中 <code>queries[i] = [favoriteType<sub>i</sub>, favoriteDay<sub>i</sub>, dailyCap<sub>i</sub>]</code> 。</p>\n\n<p>你按照如下规则进行一场游戏：</p>\n\n<ul>\n\t<li>你从第 <code><strong>0</strong></code><strong> </strong>天开始吃糖果。</li>\n\t<li>你在吃完 <strong>所有</strong> 第 <code>i - 1</code> 类糖果之前，<strong>不能</strong> 吃任何一颗第 <code>i</code> 类糖果。</li>\n\t<li>在吃完所有糖果之前，你必须每天 <strong>至少</strong> 吃 <strong>一颗</strong> 糖果。</li>\n</ul>\n\n<p>请你构建一个布尔型数组 <code>answer</code> ，用以给出 <code>queries</code> 中每一项的对应答案。此数组满足：</p>\n\n<ul>\n\t<li><code>answer.length == queries.length</code> 。<code>answer[i]</code> 是 <code>queries[i]</code> 的答案。</li>\n\t<li><code>answer[i]</code> 为 <code>true</code> 的条件是：在每天吃 <strong>不超过</strong> <code>dailyCap<sub>i</sub></code><sub> </sub>颗糖果的前提下，你可以在第 <code>favoriteDay<sub>i</sub></code> 天吃到第 <code>favoriteType<sub>i</sub></code> 类糖果；否则 <code>answer[i]</code> 为 <code>false</code> 。</li>\n</ul>\n\n<p>注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。</p>\n\n<p>请你返回得到的数组<em> </em><code>answer</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]\n<b>输出：</b>[true,false,true]\n<strong>提示：</strong>\n1- 在第 0 天吃 2 颗糖果(类型 0），第 1 天吃 2 颗糖果（类型 0），第 2 天你可以吃到类型 0 的糖果。\n2- 每天你最多吃 4 颗糖果。即使第 0 天吃 4 颗糖果（类型 0），第 1 天吃 4 颗糖果（类型 0 和类型 1），你也没办法在第 2 天吃到类型 4 的糖果。换言之，你没法在每天吃 4 颗糖果的限制下在第 2 天吃到第 4 类糖果。\n3- 如果你每天吃 1 颗糖果，你可以在第 13 天吃到类型 2 的糖果。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]\n<b>输出：</b>[false,true,true,false,false]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= candiesCount.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= candiesCount[i] <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= queries.length <= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length == 3</code></li>\n\t<li><code>0 <= favoriteType<sub>i</sub> < candiesCount.length</code></li>\n\t<li><code>0 <= favoriteDay<sub>i</sub> <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= dailyCap<sub>i</sub> <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1745.回文串分割 IV",
        "hardRate": "HARD",
        "passRate": "50.50%",
        "problemsUrl": "https://leetcode.cn/problems/palindrome-partitioning-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/palindrome-partitioning-iv/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，如果可以将它分割成三个 <strong>非空</strong> 回文子字符串，那么返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p>当一个字符串正着读和反着读是一模一样的，就称其为 <strong>回文字符串</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"abcbdd\"\n<b>输出：</b>true\n<strong>解释：</strong>\"abcbdd\" = \"a\" + \"bcb\" + \"dd\"，三个子字符串都是回文的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"bcbddxy\"\n<b>输出：</b>false\n<strong>解释：</strong>s 没办法被分割成 3 个回文子字符串。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 <= s.length <= 2000</code></li>\n\t<li><code>s</code>​​​​​​ 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1746.经过一次操作后的最大子数组和",
        "hardRate": "MEDIUM",
        "passRate": "60.65%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-subarray-sum-after-one-operation/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-subarray-sum-after-one-operation/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1747.应该被禁止的 Leetflex 账户",
        "hardRate": "MEDIUM",
        "passRate": "65.61%",
        "problemsUrl": "https://leetcode.cn/problems/leetflex-banned-accounts/",
        "solutionsUrl": "https://leetcode.cn/problems/leetflex-banned-accounts/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1748.唯一元素的和",
        "hardRate": "EASY",
        "passRate": "76.80%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-unique-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-unique-elements/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。数组中唯一元素是那些只出现 <strong>恰好一次</strong> 的元素。</p>\n\n<p>请你返回 <code>nums</code> 中唯一元素的 <strong>和</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,2]\n<b>输出：</b>4\n<b>解释：</b>唯一元素为 [1,3] ，和为 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,1,1,1,1]\n<b>输出：</b>0\n<b>解释：</b>没有唯一元素，和为 0 。\n</pre>\n\n<p><strong>示例 3 ：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4,5]\n<b>输出：</b>15\n<b>解释：</b>唯一元素为 [1,2,3,4,5] ，和为 15 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1749.任意子数组和的绝对值的最大值",
        "hardRate": "MEDIUM",
        "passRate": "54.55%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-absolute-sum-of-any-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-absolute-sum-of-any-subarray/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。一个子数组 <code>[nums<sub>l</sub>, nums<sub>l+1</sub>, ..., nums<sub>r-1</sub>, nums<sub>r</sub>]</code> 的 <strong>和的绝对值</strong> 为 <code>abs(nums<sub>l</sub> + nums<sub>l+1</sub> + ... + nums<sub>r-1</sub> + nums<sub>r</sub>)</code> 。</p>\n\n<p>请你找出 <code>nums</code> 中 <strong>和的绝对值</strong> 最大的任意子数组（<b>可能为空</b>），并返回该 <strong>最大值</strong> 。</p>\n\n<p><code>abs(x)</code> 定义如下：</p>\n\n<ul>\n\t<li>如果 <code>x</code> 是负整数，那么 <code>abs(x) = -x</code> 。</li>\n\t<li>如果 <code>x</code> 是非负整数，那么 <code>abs(x) = x</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,-3,2,3,-4]\n<b>输出：</b>5\n<b>解释：</b>子数组 [2,3] 和的绝对值最大，为 abs(2+3) = abs(5) = 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,-5,1,-4,3,-2]\n<b>输出：</b>8\n<b>解释：</b>子数组 [-5,1,-4] 和的绝对值最大，为 abs(-5+1-4) = abs(-8) = 8 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1750.删除字符串两端相同字符后的最短长度",
        "hardRate": "MEDIUM",
        "passRate": "50.64%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-length-of-string-after-deleting-similar-ends/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-length-of-string-after-deleting-similar-ends/solution",
        "problemsDesc": "<p>给你一个只包含字符 <code>'a'</code>，<code>'b'</code> 和 <code>'c'</code> 的字符串 <code>s</code> ，你可以执行下面这个操作（5 个步骤）任意次：</p>\n\n<ol>\n\t<li>选择字符串 <code>s</code> 一个 <strong>非空</strong> 的前缀，这个前缀的所有字符都相同。</li>\n\t<li>选择字符串 <code>s</code> 一个 <strong>非空</strong> 的后缀，这个后缀的所有字符都相同。</li>\n\t<li>前缀和后缀在字符串中任意位置都不能有交集。</li>\n\t<li>前缀和后缀包含的所有字符都要相同。</li>\n\t<li>同时删除前缀和后缀。</li>\n</ol>\n\n<p>请你返回对字符串 <code>s</code> 执行上面操作任意次以后（可能 0 次），能得到的 <strong>最短长度</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"ca\"\n<b>输出：</b>2\n<strong>解释：</strong>你没法删除任何一个字符，所以字符串长度仍然保持不变。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"cabaabac\"\n<b>输出：</b>0\n<b>解释：</b>最优操作序列为：\n- 选择前缀 \"c\" 和后缀 \"c\" 并删除它们，得到 s = \"abaaba\" 。\n- 选择前缀 \"a\" 和后缀 \"a\" 并删除它们，得到 s = \"baab\" 。\n- 选择前缀 \"b\" 和后缀 \"b\" 并删除它们，得到 s = \"aa\" 。\n- 选择前缀 \"a\" 和后缀 \"a\" 并删除它们，得到 s = \"\" 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aabccabba\"\n<b>输出：</b>3\n<b>解释：</b>最优操作序列为：\n- 选择前缀 \"aa\" 和后缀 \"a\" 并删除它们，得到 s = \"bccabb\" 。\n- 选择前缀 \"b\" 和后缀 \"bb\" 并删除它们，得到 s = \"cca\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 只包含字符 <code>'a'</code>，<code>'b'</code> 和 <code>'c'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1751.最多可以参加的会议数目 II",
        "hardRate": "HARD",
        "passRate": "54.19%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended-ii/solution",
        "problemsDesc": "<p>给你一个 <code>events</code> 数组，其中 <code>events[i] = [startDay<sub>i</sub>, endDay<sub>i</sub>, value<sub>i</sub>]</code> ，表示第 <code>i</code> 个会议在 <code>startDay<sub>i</sub></code><sub> </sub>天开始，第 <code>endDay<sub>i</sub></code> 天结束，如果你参加这个会议，你能得到价值 <code>value<sub>i</sub></code> 。同时给你一个整数 <code>k</code> 表示你能参加的最多会议数目。</p>\n\n<p>你同一时间只能参加一个会议。如果你选择参加某个会议，那么你必须 <strong>完整</strong> 地参加完这个会议。会议结束日期是包含在会议内的，也就是说你不能同时参加一个开始日期与另一个结束日期相同的两个会议。</p>\n\n<p>请你返回能得到的会议价值 <strong>最大和</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/06/screenshot-2021-01-11-at-60048-pm.png\" style=\"width: 400px; height: 103px;\" /></p>\n\n<pre>\n<b>输入：</b>events = [[1,2,4],[3,4,3],[2,3,1]], k = 2\n<b>输出：</b>7\n<strong>解释：</strong>选择绿色的活动会议 0 和 1，得到总价值和为 4 + 3 = 7 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/06/screenshot-2021-01-11-at-60150-pm.png\" style=\"width: 400px; height: 103px;\" /></p>\n\n<pre>\n<b>输入：</b>events = [[1,2,4],[3,4,3],[2,3,10]], k = 2\n<b>输出：</b>10\n<b>解释：</b>参加会议 2 ，得到价值和为 10 。\n你没法再参加别的会议了，因为跟会议 2 有重叠。你 <strong>不</strong> 需要参加满 k 个会议。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/06/screenshot-2021-01-11-at-60703-pm.png\" style=\"width: 400px; height: 126px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3\n<b>输出：</b>9\n<b>解释：</b>尽管会议互不重叠，你只能参加 3 个会议，所以选择价值最大的 3 个会议。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= k <= events.length</code></li>\n\t<li><code>1 <= k * events.length <= 10<sup>6</sup></code></li>\n\t<li><code>1 <= startDay<sub>i</sub> <= endDay<sub>i</sub> <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= value<sub>i</sub> <= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1752.检查数组是否经排序和轮转得到",
        "hardRate": "EASY",
        "passRate": "58.06%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-array-is-sorted-and-rotated/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-array-is-sorted-and-rotated/solution",
        "problemsDesc": "<p>给你一个数组 <code>nums</code> 。<code>nums</code> 的源数组中，所有元素与 <code>nums</code> 相同，但按非递减顺序排列。</p>\n\n<p>如果&nbsp;<code>nums</code> 能够由源数组轮转若干位置（包括 0 个位置）得到，则返回 <code>true</code><em> </em>；否则，返回 <code>false</code> 。</p>\n\n<p>源数组中可能存在 <strong>重复项</strong> 。</p>\n\n<p><strong>注意：</strong>我们称数组 <code>A</code> 在轮转 <code>x</code> 个位置后得到长度相同的数组 <code>B</code> ，当它们满足 <code>A[i] == B[(i+x) % A.length]</code> ，其中 <code>%</code> 为取余运算。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,5,1,2]\n<strong>输出：</strong>true\n<strong>解释：</strong>[1,2,3,4,5] 为有序的源数组。\n可以轮转 x = 3 个位置，使新数组从值为 3 的元素开始：[3,4,5,1,2] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,3,4]\n<strong>输出：</strong>false\n<strong>解释：</strong>源数组无法经轮转得到 nums 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>true\n<strong>解释：</strong>[1,2,3] 为有序的源数组。\n可以轮转 x = 0 个位置（即不轮转）得到 nums 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1753.移除石子的最大得分",
        "hardRate": "MEDIUM",
        "passRate": "70.67%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-from-removing-stones/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-from-removing-stones/solution",
        "problemsDesc": "<p>你正在玩一个单人游戏，面前放置着大小分别为 <code>a</code>​​​​​​、<code>b</code> 和 <code>c</code>​​​​​​ 的 <strong>三堆</strong> 石子。</p>\n\n<p>每回合你都要从两个 <strong>不同的非空堆</strong> 中取出一颗石子，并在得分上加 <code>1</code> 分。当存在 <strong>两个或更多</strong> 的空堆时，游戏停止。</p>\n\n<p>给你三个整数 <code>a</code> 、<code>b</code> 和 <code>c</code> ，返回可以得到的 <strong>最大分数</strong> 。</p>\n \n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 2, b = 4, c = 6\n<strong>输出：</strong>6\n<strong>解释：</strong>石子起始状态是 (2, 4, 6) ，最优的一组操作是：\n- 从第一和第三堆取，石子状态现在是 (1, 4, 5)\n- 从第一和第三堆取，石子状态现在是 (0, 4, 4)\n- 从第二和第三堆取，石子状态现在是 (0, 3, 3)\n- 从第二和第三堆取，石子状态现在是 (0, 2, 2)\n- 从第二和第三堆取，石子状态现在是 (0, 1, 1)\n- 从第二和第三堆取，石子状态现在是 (0, 0, 0)\n总分：6 分 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 4, b = 4, c = 6\n<strong>输出：</strong>7\n<strong>解释：</strong>石子起始状态是 (4, 4, 6) ，最优的一组操作是：\n- 从第一和第二堆取，石子状态现在是 (3, 3, 6)\n- 从第一和第三堆取，石子状态现在是 (2, 3, 5)\n- 从第一和第三堆取，石子状态现在是 (1, 3, 4)\n- 从第一和第三堆取，石子状态现在是 (0, 3, 3)\n- 从第二和第三堆取，石子状态现在是 (0, 2, 2)\n- 从第二和第三堆取，石子状态现在是 (0, 1, 1)\n- 从第二和第三堆取，石子状态现在是 (0, 0, 0)\n总分：7 分 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 1, b = 8, c = 8\n<strong>输出：</strong>8\n<strong>解释：</strong>最优的一组操作是连续从第二和第三堆取 8 回合，直到将它们取空。\n注意，由于第二和第三堆已经空了，游戏结束，不能继续从第一堆中取石子。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= a, b, c <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1754.构造字典序最大的合并字符串",
        "hardRate": "MEDIUM",
        "passRate": "56.28%",
        "problemsUrl": "https://leetcode.cn/problems/largest-merge-of-two-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-merge-of-two-strings/solution",
        "problemsDesc": "<p>给你两个字符串 <code>word1</code> 和 <code>word2</code> 。你需要按下述方式构造一个新字符串 <code>merge</code> ：如果 <code>word1</code> 或 <code>word2</code> 非空，选择 <strong>下面选项之一</strong> 继续操作：</p>\n\n<ul>\n\t<li>如果 <code>word1</code> 非空，将 <code>word1</code> 中的第一个字符附加到 <code>merge</code> 的末尾，并将其从 <code>word1</code> 中移除。\n\n\t<ul>\n\t\t<li>例如，<code>word1 = \"abc\" </code>且 <code>merge = \"dv\"</code> ，在执行此选项操作之后，<code>word1 = \"bc\"</code> ，同时 <code>merge = \"dva\"</code> 。</li>\n\t</ul>\n\t</li>\n\t<li>如果 <code>word2</code> 非空，将 <code>word2</code> 中的第一个字符附加到 <code>merge</code> 的末尾，并将其从 <code>word2</code> 中移除。\n\t<ul>\n\t\t<li>例如，<code>word2 = \"abc\" </code>且 <code>merge = \"\"</code> ，在执行此选项操作之后，<code>word2 = \"bc\"</code> ，同时 <code>merge = \"a\"</code> 。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>返回你可以构造的字典序 <strong>最大</strong> 的合并字符串<em> </em><code>merge</code><em> 。</em></p>\n\n<p>长度相同的两个字符串 <code>a</code> 和 <code>b</code> 比较字典序大小，如果在 <code>a</code> 和 <code>b</code> 出现不同的第一个位置，<code>a</code> 中字符在字母表中的出现顺序位于 <code>b</code> 中相应字符之后，就认为字符串 <code>a</code> 按字典序比字符串 <code>b</code> 更大。例如，<code>\"abcd\"</code> 按字典序比 <code>\"abcc\"</code> 更大，因为两个字符串出现不同的第一个位置是第四个字符，而 <code>d</code> 在字母表中的出现顺序位于 <code>c</code> 之后。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"cabaa\", word2 = \"bcaaa\"\n<strong>输出：</strong>\"cbcabaaaaa\"\n<strong>解释：</strong>构造字典序最大的合并字符串，可行的一种方法如下所示：\n- 从 word1 中取第一个字符：merge = \"c\"，word1 = \"abaa\"，word2 = \"bcaaa\"\n- 从 word2 中取第一个字符：merge = \"cb\"，word1 = \"abaa\"，word2 = \"caaa\"\n- 从 word2 中取第一个字符：merge = \"cbc\"，word1 = \"abaa\"，word2 = \"aaa\"\n- 从 word1 中取第一个字符：merge = \"cbca\"，word1 = \"baa\"，word2 = \"aaa\"\n- 从 word1 中取第一个字符：merge = \"cbcab\"，word1 = \"aa\"，word2 = \"aaa\"\n- 将 word1 和 word2 中剩下的 5 个 a 附加到 merge 的末尾。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"abcabc\", word2 = \"abdcaba\"\n<strong>输出：</strong>\"abdcabcabcaba\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word1.length, word2.length <= 3000</code></li>\n\t<li><code>word1</code> 和 <code>word2</code> 仅由小写英文组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1755.最接近目标值的子序列和",
        "hardRate": "HARD",
        "passRate": "45.11%",
        "problemsUrl": "https://leetcode.cn/problems/closest-subsequence-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-subsequence-sum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个目标值 <code>goal</code> 。</p>\n\n<p>你需要从 <code>nums</code> 中选出一个子序列，使子序列元素总和最接近 <code>goal</code> 。也就是说，如果子序列元素和为 <code>sum</code> ，你需要 <strong>最小化绝对差</strong> <code>abs(sum - goal)</code> 。</p>\n\n<p>返回 <code>abs(sum - goal)</code> 可能的 <strong>最小值</strong> 。</p>\n\n<p>注意，数组的子序列是通过移除原始数组中的某些元素（可能全部或无）而形成的数组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,-7,3,5], goal = 6\n<strong>输出：</strong>0\n<strong>解释：</strong>选择整个数组作为选出的子序列，元素和为 6 。\n子序列和与目标值相等，所以绝对差为 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [7,-9,15,-2], goal = -5\n<strong>输出：</strong>1\n<strong>解释：</strong>选出子序列 [7,-9,-2] ，元素和为 -4 。\n绝对差为 abs(-4 - (-5)) = abs(1) = 1 ，是可能的最小值。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3], goal = -7\n<strong>输出：</strong>7\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 40</code></li>\n\t<li><code>-10<sup>7</sup> &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= goal &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1756.设计最近使用（MRU）队列",
        "hardRate": "MEDIUM",
        "passRate": "82.40%",
        "problemsUrl": "https://leetcode.cn/problems/design-most-recently-used-queue/",
        "solutionsUrl": "https://leetcode.cn/problems/design-most-recently-used-queue/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1757.可回收且低脂的产品",
        "hardRate": "EASY",
        "passRate": "87.61%",
        "problemsUrl": "https://leetcode.cn/problems/recyclable-and-low-fat-products/",
        "solutionsUrl": "https://leetcode.cn/problems/recyclable-and-low-fat-products/solution",
        "problemsDesc": "<p>表：<code>Products</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| product_id  | int     |\n| low_fats    | enum    |\n| recyclable  | enum    |\n+-------------+---------+\nproduct_id 是这个表的主键。\nlow_fats 是枚举类型，取值为以下两种 ('Y', 'N')，其中 'Y' 表示该产品是低脂产品，'N' 表示不是低脂产品。\nrecyclable 是枚举类型，取值为以下两种 ('Y', 'N')，其中 'Y' 表示该产品可回收，而 'N' 表示不可回收。</pre>\n\n<p> </p>\n\n<p>写出 SQL 语句，查找既是低脂又是可回收的产品编号。</p>\n\n<p>返回结果 <strong>无顺序要求</strong> 。</p>\n\n<p>查询结果格式如下例所示：</p>\n\n<pre>\nProducts 表：\n+-------------+----------+------------+\n| product_id  | low_fats | recyclable |\n+-------------+----------+------------+\n| 0           | Y        | N          |\n| 1           | Y        | Y          |\n| 2           | N        | Y          |\n| 3           | Y        | Y          |\n| 4           | N        | N          |\n+-------------+----------+------------+\nResult 表：\n+-------------+\n| product_id  |\n+-------------+\n| 1           |\n| 3           |\n+-------------+\n只有产品 id 为 1 和 3 的产品，既是低脂又是可回收的产品。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1758.生成交替二进制字符串的最少操作数",
        "hardRate": "EASY",
        "passRate": "69.72%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-changes-to-make-alternating-binary-string/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-changes-to-make-alternating-binary-string/solution",
        "problemsDesc": "<p>给你一个仅由字符 <code>'0'</code> 和 <code>'1'</code> 组成的字符串 <code>s</code> 。一步操作中，你可以将任一 <code>'0'</code> 变成 <code>'1'</code> ，或者将 <code>'1'</code> 变成 <code>'0'</code> 。</p>\n\n<p><strong>交替字符串</strong> 定义为：如果字符串中不存在相邻两个字符相等的情况，那么该字符串就是交替字符串。例如，字符串 <code>\"010\"</code> 是交替字符串，而字符串 <code>\"0100\"</code> 不是。</p>\n\n<p>返回使 <code>s</code> 变成 <strong>交替字符串</strong> 所需的 <strong>最少</strong> 操作数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"0100\"\n<strong>输出：</strong>1\n<strong>解释：</strong>如果将最后一个字符变为 '1' ，s 就变成 \"0101\" ，即符合交替字符串定义。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"10\"\n<strong>输出：</strong>0\n<strong>解释：</strong>s 已经是交替字符串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = \"1111\"\n<strong>输出：</strong>2\n<strong>解释：</strong>需要 2 步操作得到 \"0101\" 或 \"1010\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s[i]</code> 是 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1759.统计同质子字符串的数目",
        "hardRate": "MEDIUM",
        "passRate": "51.10%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-homogenous-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-homogenous-substrings/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，返回<em> </em><code>s</code><em> </em>中 <strong>同质子字符串</strong> 的数目。由于答案可能很大，只需返回对 <code>10<sup>9</sup> + 7</code> <strong>取余 </strong>后的结果。</p>\n\n<p><strong>同质字符串</strong> 的定义为：如果一个字符串中的所有字符都相同，那么该字符串就是同质字符串。</p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abbcccaa\"\n<strong>输出：</strong>13\n<strong>解释：</strong>同质子字符串如下所列：\n\"a\"   出现 3 次。\n\"aa\"  出现 1 次。\n\"b\"   出现 2 次。\n\"bb\"  出现 1 次。\n\"c\"   出现 3 次。\n\"cc\"  出现 2 次。\n\"ccc\" 出现 1 次。\n3 + 1 + 2 + 1 + 3 + 2 + 1 = 13</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"xy\"\n<strong>输出：</strong>2\n<strong>解释：</strong>同质子字符串是 \"x\" 和 \"y\" 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"zzzzz\"\n<strong>输出：</strong>15\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写字符串组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1760.袋子里最少数目的球",
        "hardRate": "MEDIUM",
        "passRate": "64.10%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 表示第 <code>i</code> 个袋子里球的数目。同时给你一个整数 <code>maxOperations</code> 。</p>\n\n<p>你可以进行如下操作至多 <code>maxOperations</code> 次：</p>\n\n<ul>\n\t<li>选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 <strong>正整数</strong> 个球。\n\n\t<ul>\n\t\t<li>比方说，一个袋子里有 <code>5</code> 个球，你可以把它们分到两个新袋子里，分别有 <code>1</code> 个和 <code>4</code> 个球，或者分别有 <code>2</code> 个和 <code>3</code> 个球。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>你的开销是单个袋子里球数目的 <strong>最大值</strong> ，你想要 <strong>最小化</strong> 开销。</p>\n\n<p>请你返回进行上述操作后的最小开销。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [9], maxOperations = 2\n<b>输出：</b>3\n<b>解释：</b>\n- 将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[<strong>9</strong>] -> [6,3] 。\n- 将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[<strong>6</strong>,3] -> [3,3,3] 。\n装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,4,8,2], maxOperations = 4\n<b>输出：</b>2\n<strong>解释：</strong>\n- 将装有 8 个球的袋子分成装有 4 个和 4 个球的袋子。[2,4,<strong>8</strong>,2] -> [2,4,4,4,2] 。\n- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,<strong>4</strong>,4,4,2] -> [2,2,2,4,4,2] 。\n- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,<strong>4</strong>,4,2] -> [2,2,2,2,2,4,2] 。\n- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,2,2,<strong>4</strong>,2] -> [2,2,2,2,2,2,2,2] 。\n装有最多球的袋子里装有 2 个球，所以开销为 2 并返回 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [7,17], maxOperations = 2\n<b>输出：</b>7\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= maxOperations, nums[i] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1761.一个图中连通三元组的最小度数",
        "hardRate": "HARD",
        "passRate": "46.22%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph/solution",
        "problemsDesc": "<p>给你一个无向图，整数 <code>n</code> 表示图中节点的数目，<code>edges</code> 数组表示图中的边，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> ，表示 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code><sub> </sub>之间有一条无向边。</p>\n\n<p>一个 <strong>连通三元组</strong> 指的是 <strong>三个</strong> 节点组成的集合且这三个点之间 <strong>两两</strong> 有边。</p>\n\n<p><strong>连通三元组的度数</strong> 是所有满足此条件的边的数目：一个顶点在这个三元组内，而另一个顶点不在这个三元组内。</p>\n\n<p>请你返回所有连通三元组中度数的 <strong>最小值</strong> ，如果图中没有连通三元组，那么返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/14/trios1.png\" style=\"width: 388px; height: 164px;\" />\n<pre>\n<b>输入：</b>n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]\n<b>输出：</b>3\n<b>解释：</b>只有一个三元组 [1,2,3] 。构成度数的边在上图中已被加粗。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/14/trios2.png\" style=\"width: 388px; height: 164px;\" />\n<pre>\n<b>输入：</b>n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]\n<b>输出：</b>0\n<b>解释：</b>有 3 个三元组：\n1) [1,4,3]，度数为 0 。\n2) [2,5,6]，度数为 2 。\n3) [5,6,7]，度数为 2 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 400</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 <= edges.length <= n * (n-1) / 2</code></li>\n\t<li><code>1 <= u<sub>i</sub>, v<sub>i</sub> <= n</code></li>\n\t<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>\n\t<li>图中没有重复的边。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1762.能看到海景的建筑物",
        "hardRate": "MEDIUM",
        "passRate": "71.53%",
        "problemsUrl": "https://leetcode.cn/problems/buildings-with-an-ocean-view/",
        "solutionsUrl": "https://leetcode.cn/problems/buildings-with-an-ocean-view/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1763.最长的美好子字符串",
        "hardRate": "EASY",
        "passRate": "67.25%",
        "problemsUrl": "https://leetcode.cn/problems/longest-nice-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-nice-substring/solution",
        "problemsDesc": "<p>当一个字符串 <code>s</code> 包含的每一种字母的大写和小写形式 <strong>同时</strong> 出现在 <code>s</code> 中，就称这个字符串 <code>s</code> 是 <strong>美好</strong> 字符串。比方说，<code>\"abABB\"</code> 是美好字符串，因为 <code>'A'</code> 和 <code>'a'</code> 同时出现了，且 <code>'B'</code> 和 <code>'b'</code> 也同时出现了。然而，<code>\"abA\"</code> 不是美好字符串因为 <code>'b'</code> 出现了，而 <code>'B'</code> 没有出现。</p>\n\n<p>给你一个字符串 <code>s</code> ，请你返回 <code>s</code> 最长的 <strong>美好子字符串</strong> 。如果有多个答案，请你返回 <strong>最早</strong> 出现的一个。如果不存在美好子字符串，请你返回一个空字符串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"YazaAay\"\n<b>输出：</b>\"aAa\"\n<strong>解释：</strong>\"aAa\" 是一个美好字符串，因为这个子串中仅含一种字母，其小写形式 'a' 和大写形式 'A' 也同时出现了。\n\"aAa\" 是最长的美好子字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"Bb\"\n<b>输出：</b>\"Bb\"\n<b>解释：</b>\"Bb\" 是美好字符串，因为 'B' 和 'b' 都出现了。整个字符串也是原字符串的子字符串。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"c\"\n<b>输出：</b>\"\"\n<b>解释：</b>没有美好子字符串。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"dDzeE\"\n<b>输出：</b>\"dD\"\n<strong>解释：</strong>\"dD\" 和 \"eE\" 都是最长美好子字符串。\n由于有多个美好子字符串，返回 \"dD\" ，因为它出现得最早。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 100</code></li>\n\t<li><code>s</code> 只包含大写和小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1764.通过连接另一个数组的子数组得到一个数组",
        "hardRate": "MEDIUM",
        "passRate": "55.75%",
        "problemsUrl": "https://leetcode.cn/problems/form-array-by-concatenating-subarrays-of-another-array/",
        "solutionsUrl": "https://leetcode.cn/problems/form-array-by-concatenating-subarrays-of-another-array/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的二维整数数组 <code>groups</code> ，同时给你一个整数数组 <code>nums</code> 。</p>\n\n<p>你是否可以从 <code>nums</code> 中选出 <code>n</code> 个 <strong>不相交</strong> 的子数组，使得第 <code>i</code> 个子数组与 <code>groups[i]</code> （下标从 <strong>0</strong> 开始）完全相同，且如果 <code>i > 0</code> ，那么第 <code>(i-1)</code> 个子数组在 <code>nums</code> 中出现的位置在第 <code>i</code> 个子数组前面。（也就是说，这些子数组在 <code>nums</code> 中出现的顺序需要与 <code>groups</code> 顺序相同）</p>\n\n<p>如果你可以找出这样的 <code>n</code> 个子数组，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p>如果不存在下标为 <code>k</code> 的元素 <code>nums[k]</code> 属于不止一个子数组，就称这些子数组是 <strong>不相交</strong> 的。子数组指的是原数组中连续元素组成的一个序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>groups = [[1,-1,-1],[3,-2,0]], nums = [1,-1,0,1,-1,-1,3,-2,0]\n<b>输出：</b>true\n<b>解释：</b>你可以分别在 nums 中选出第 0 个子数组 [1,-1,0,<strong>1,</strong><strong>-1,</strong><strong>-1</strong>,3,-2,0] 和第 1 个子数组 [1,-1,0,1,-1,-1,<strong>3,</strong><strong>-2,0</strong>] 。\n这两个子数组是不相交的，因为它们没有任何共同的元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>groups = [[10,-2],[1,2,3,4]], nums = [1,2,3,4,10,-2]\n<b>输出：</b>false\n<strong>解释：</strong>选择子数组 [<strong>1,2,3,4</strong>,10,-2] 和 [1,2,3,4,<strong>10,-2</strong>] 是不正确的，因为它们出现的顺序与 groups 中顺序不同。\n[10,-2] 必须出现在 [1,2,3,4] 之前。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>groups = [[1,2,3],[3,4]], nums = [7,7,1,2,3,4,7,7]\n<b>输出：</b>false\n<strong>解释：</strong>选择子数组 [7,7,<strong>1,2,3</strong>,4,7,7] 和 [7,7,1,2,<strong>3,4</strong>,7,7] 是不正确的，因为它们不是不相交子数组。\n它们有一个共同的元素 nums[4] （下标从 0 开始）。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>groups.length == n</code></li>\n\t<li><code>1 <= n <= 10<sup>3</sup></code></li>\n\t<li><code>1 <= groups[i].length, sum(groups[i].length) <= 10<sup><span style=\"\">3</span></sup></code></li>\n\t<li><code>1 <= nums.length <= 10<sup>3</sup></code></li>\n\t<li><code>-10<sup>7</sup> <= groups[i][j], nums[k] <= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1765.地图中的最高点",
        "hardRate": "MEDIUM",
        "passRate": "66.35%",
        "problemsUrl": "https://leetcode.cn/problems/map-of-highest-peak/",
        "solutionsUrl": "https://leetcode.cn/problems/map-of-highest-peak/solution",
        "problemsDesc": "<p>给你一个大小为&nbsp;<code>m x n</code>&nbsp;的整数矩阵&nbsp;<code>isWater</code>&nbsp;，它代表了一个由 <strong>陆地</strong>&nbsp;和 <strong>水域</strong>&nbsp;单元格组成的地图。</p>\n\n<ul>\n\t<li>如果&nbsp;<code>isWater[i][j] == 0</code>&nbsp;，格子&nbsp;<code>(i, j)</code>&nbsp;是一个 <strong>陆地</strong>&nbsp;格子。</li>\n\t<li>如果&nbsp;<code>isWater[i][j] == 1</code>&nbsp;，格子&nbsp;<code>(i, j)</code>&nbsp;是一个 <strong>水域</strong>&nbsp;格子。</li>\n</ul>\n\n<p>你需要按照如下规则给每个单元格安排高度：</p>\n\n<ul>\n\t<li>每个格子的高度都必须是非负的。</li>\n\t<li>如果一个格子是 <strong>水域</strong>&nbsp;，那么它的高度必须为 <code>0</code>&nbsp;。</li>\n\t<li>任意相邻的格子高度差 <strong>至多</strong>&nbsp;为 <code>1</code>&nbsp;。当两个格子在正东、南、西、北方向上相互紧挨着，就称它们为相邻的格子。（也就是说它们有一条公共边）</li>\n</ul>\n\n<p>找到一种安排高度的方案，使得矩阵中的最高高度值&nbsp;<strong>最大</strong>&nbsp;。</p>\n\n<p>请你返回一个大小为&nbsp;<code>m x n</code>&nbsp;的整数矩阵 <code>height</code>&nbsp;，其中 <code>height[i][j]</code>&nbsp;是格子 <code>(i, j)</code>&nbsp;的高度。如果有多种解法，请返回&nbsp;<strong>任意一个</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-82045-am.png\" style=\"width: 220px; height: 219px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>isWater = [[0,1],[0,0]]\n<b>输出：</b>[[1,0],[2,1]]\n<b>解释：</b>上图展示了给各个格子安排的高度。\n蓝色格子是水域格，绿色格子是陆地格。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-82050-am.png\" style=\"width: 300px; height: 296px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>isWater = [[0,0,1],[1,0,0],[0,0,0]]\n<b>输出：</b>[[1,1,0],[0,1,1],[1,2,2]]\n<b>解释：</b>所有安排方案中，最高可行高度为 2 。\n任意安排方案中，只要最高高度为 2 且符合上述规则的，都为可行方案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == isWater.length</code></li>\n\t<li><code>n == isWater[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>isWater[i][j]</code>&nbsp;要么是&nbsp;<code>0</code>&nbsp;，要么是&nbsp;<code>1</code>&nbsp;。</li>\n\t<li>至少有 <strong>1</strong>&nbsp;个水域格子。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1766.互质树",
        "hardRate": "HARD",
        "passRate": "40.23%",
        "problemsUrl": "https://leetcode.cn/problems/tree-of-coprimes/",
        "solutionsUrl": "https://leetcode.cn/problems/tree-of-coprimes/solution",
        "problemsDesc": "<p>给你一个 <code>n</code> 个节点的树（也就是一个无环连通无向图），节点编号从 <code>0</code> 到 <code>n - 1</code> ，且恰好有 <code>n - 1</code> 条边，每个节点有一个值。树的 <strong>根节点</strong> 为 0 号点。</p>\n\n<p>给你一个整数数组 <code>nums</code> 和一个二维数组 <code>edges</code> 来表示这棵树。<code>nums[i]</code> 表示第 <code>i</code> 个点的值，<code>edges[j] = [u<sub>j</sub>, v<sub>j</sub>]</code> 表示节点 <code>u<sub>j</sub></code> 和节点 <code>v<sub>j</sub></code> 在树中有一条边。</p>\n\n<p>当 <code>gcd(x, y) == 1</code> ，我们称两个数 <code>x</code> 和 <code>y</code> 是 <strong>互质的</strong> ，其中 <code>gcd(x, y)</code> 是 <code>x</code> 和 <code>y</code> 的 <strong>最大公约数</strong> 。</p>\n\n<p>从节点 <code>i</code> 到 <strong>根</strong> 最短路径上的点都是节点 <code>i</code> 的祖先节点。一个节点 <strong>不是</strong> 它自己的祖先节点。</p>\n\n<p>请你返回一个大小为 <code>n</code> 的数组 <code>ans</code> ，其中<em> </em><code>ans[i]</code>是离节点 <code>i</code> 最近的祖先节点且满足<em> </em><code>nums[i]</code> 和<em> </em><code>nums[ans[i]]</code> 是 <strong>互质的</strong> ，如果不存在这样的祖先节点，<code>ans[i]</code> 为 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/20/untitled-diagram.png\" style=\"width: 191px; height: 281px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,3,3,2], edges = [[0,1],[1,2],[1,3]]\n<b>输出：</b>[-1,0,0,1]\n<b>解释：</b>上图中，每个节点的值在括号中表示。\n- 节点 0 没有互质祖先。\n- 节点 1 只有一个祖先节点 0 。它们的值是互质的（gcd(2,3) == 1）。\n- 节点 2 有两个祖先节点，分别是节点 1 和节点 0 。节点 1 的值与它的值不是互质的（gcd(3,3) == 3）但节点 0 的值是互质的(gcd(2,3) == 1)，所以节点 0 是最近的符合要求的祖先节点。\n- 节点 3 有两个祖先节点，分别是节点 1 和节点 0 。它与节点 1 互质（gcd(3,2) == 1），所以节点 1 是离它最近的符合要求的祖先节点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/20/untitled-diagram1.png\" style=\"width: 441px; height: 291px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,6,10,2,3,6,15], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]\n<b>输出：</b>[-1,0,-1,0,0,0,-1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length == n</code></li>\n\t<li><code>1 <= nums[i] <= 50</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[j].length == 2</code></li>\n\t<li><code>0 <= u<sub>j</sub>, v<sub>j</sub> < n</code></li>\n\t<li><code>u<sub>j</sub> != v<sub>j</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1767.寻找没有被执行的任务对",
        "hardRate": "HARD",
        "passRate": "80.14%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-subtasks-that-did-not-execute/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-subtasks-that-did-not-execute/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1768.交替合并字符串",
        "hardRate": "EASY",
        "passRate": "76.03%",
        "problemsUrl": "https://leetcode.cn/problems/merge-strings-alternately/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-strings-alternately/solution",
        "problemsDesc": "<p>给你两个字符串 <code>word1</code> 和 <code>word2</code> 。请你从 <code>word1</code> 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。</p>\n\n<p>返回 <strong>合并后的字符串</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"abc\", word2 = \"pqr\"\n<strong>输出：</strong>\"apbqcr\"\n<strong>解释：</strong>字符串合并情况如下所示：\nword1：  a   b   c\nword2：    p   q   r\n合并后：  a p b q c r\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"ab\", word2 = \"pqrs\"\n<strong>输出：</strong>\"apbqrs\"\n<strong>解释：</strong>注意，word2 比 word1 长，\"rs\" 需要追加到合并后字符串的末尾。\nword1：  a   b \nword2：    p   q   r   s\n合并后：  a p b q   r   s\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"abcd\", word2 = \"pq\"\n<strong>输出：</strong>\"apbqcd\"\n<strong>解释：</strong>注意，word1 比 word2 长，\"cd\" 需要追加到合并后字符串的末尾。\nword1：  a   b   c   d\nword2：    p   q \n合并后：  a p b q c   d\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word1.length, word2.length <= 100</code></li>\n\t<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1769.移动所有球到每个盒子所需的最小操作数",
        "hardRate": "MEDIUM",
        "passRate": "87.87%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/solution",
        "problemsDesc": "<p>有 <code>n</code> 个盒子。给你一个长度为 <code>n</code> 的二进制字符串 <code>boxes</code> ，其中 <code>boxes[i]</code> 的值为 <code>'0'</code> 表示第 <code>i</code> 个盒子是 <strong>空</strong> 的，而 <code>boxes[i]</code> 的值为 <code>'1'</code> 表示盒子里有 <strong>一个</strong> 小球。</p>\n\n<p>在一步操作中，你可以将 <strong>一个</strong> 小球从某个盒子移动到一个与之相邻的盒子中。第 <code>i</code> 个盒子和第 <code>j</code> 个盒子相邻需满足 <code>abs(i - j) == 1</code> 。注意，操作执行后，某些盒子中可能会存在不止一个小球。</p>\n\n<p>返回一个长度为 <code>n</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是将所有小球移动到第 <code>i</code> 个盒子所需的 <strong>最小</strong> 操作数。</p>\n\n<p>每个 <code>answer[i]</code> 都需要根据盒子的 <strong>初始状态</strong> 进行计算。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>boxes = \"110\"\n<strong>输出：</strong>[1,1,3]\n<strong>解释：</strong>每个盒子对应的最小操作数如下：\n1) 第 1 个盒子：将一个小球从第 2 个盒子移动到第 1 个盒子，需要 1 步操作。\n2) 第 2 个盒子：将一个小球从第 1 个盒子移动到第 2 个盒子，需要 1 步操作。\n3) 第 3 个盒子：将一个小球从第 1 个盒子移动到第 3 个盒子，需要 2 步操作。将一个小球从第 2 个盒子移动到第 3 个盒子，需要 1 步操作。共计 3 步操作。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>boxes = \"001011\"\n<strong>输出：</strong>[11,8,5,4,3,4]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == boxes.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2000</code></li>\n\t<li><code>boxes[i]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1770.执行乘法运算的最大分数",
        "hardRate": "HARD",
        "passRate": "39.70%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-from-performing-multiplication-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-from-performing-multiplication-operations/solution",
        "problemsDesc": "<p>给你两个长度分别 <code>n</code> 和 <code>m</code> 的整数数组 <code>nums</code> 和 <code>multipliers</code><strong> </strong>，其中 <code>n &gt;= m</code> ，数组下标 <strong>从 1 开始</strong> 计数。</p>\n\n<p>初始时，你的分数为 <code>0</code> 。你需要执行恰好 <code>m</code> 步操作。在第 <code>i</code> 步操作（<strong>从 1 开始</strong> 计数）中，需要：</p>\n\n<ul>\n\t<li>选择数组 <code>nums</code> <strong>开头处或者末尾处</strong> 的整数 <code>x</code> 。</li>\n\t<li>你获得 <code>multipliers[i] * x</code> 分，并累加到你的分数中。</li>\n\t<li>将 <code>x</code> 从数组 <code>nums</code> 中移除。</li>\n</ul>\n\n<p>在执行<em> </em><code>m</code> 步操作后，返回 <strong>最大</strong> 分数<em>。</em></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3], multipliers = [3,2,1]\n<strong>输出：</strong>14\n<strong>解释：</strong>一种最优解决方案如下：\n- 选择末尾处的整数 3 ，[1,2,<strong>3</strong>] ，得 3 * 3 = 9 分，累加到分数中。\n- 选择末尾处的整数 2 ，[1,<strong>2</strong>] ，得 2 * 2 = 4 分，累加到分数中。\n- 选择末尾处的整数 1 ，[<strong>1</strong>] ，得 1 * 1 = 1 分，累加到分数中。\n总分数为 9 + 4 + 1 = 14 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]\n<strong>输出：</strong>102\n<strong>解释：</strong>一种最优解决方案如下：\n- 选择开头处的整数 -5 ，[<strong>-5</strong>,-3,-3,-2,7,1] ，得 -5 * -10 = 50 分，累加到分数中。\n- 选择开头处的整数 -3 ，[<strong>-3</strong>,-3,-2,7,1] ，得 -3 * -5 = 15 分，累加到分数中。\n- 选择开头处的整数 -3 ，[<strong>-3</strong>,-2,7,1] ，得 -3 * 3 = -9 分，累加到分数中。\n- 选择末尾处的整数 1 ，[-2,7,<strong>1</strong>] ，得 1 * 4 = 4 分，累加到分数中。\n- 选择末尾处的整数 7 ，[-2,<strong>7</strong>] ，得 7 * 6 = 42 分，累加到分数中。\n总分数为 50 + 15 - 9 + 4 + 42 = 102 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>m == multipliers.length</code></li>\n\t<li><code>1 &lt;= m &lt;= 10<sup>3</sup></code></li>\n\t<li><code>m &lt;= n &lt;= 10<sup>5</sup></code><code> </code></li>\n\t<li><code>-1000 &lt;= nums[i], multipliers[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1771.由子序列构造的最长回文串的长度",
        "hardRate": "HARD",
        "passRate": "38.49%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-palindrome-length-from-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-palindrome-length-from-subsequences/solution",
        "problemsDesc": "<p>给你两个字符串 <code>word1</code> 和 <code>word2</code> ，请你按下述方法构造一个字符串：</p>\n\n<ul>\n\t<li>从 <code>word1</code> 中选出某个 <strong>非空</strong> 子序列 <code>subsequence1</code> 。</li>\n\t<li>从 <code>word2</code> 中选出某个 <strong>非空</strong> 子序列 <code>subsequence2</code> 。</li>\n\t<li>连接两个子序列 <code>subsequence1 + subsequence2</code> ，得到字符串。</li>\n</ul>\n\n<p>返回可按上述方法构造的最长 <strong>回文串</strong> 的 <strong>长度</strong> 。如果无法构造回文串，返回 <code>0</code> 。</p>\n\n<p>字符串 <code>s</code> 的一个 <strong>子序列</strong> 是通过从 <code>s</code> 中删除一些（也可能不删除）字符而不更改其余字符的顺序生成的字符串。</p>\n\n<p><strong>回文串</strong> 是正着读和反着读结果一致的字符串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>word1 = \"cacb\", word2 = \"cbba\"\n<strong>输出：</strong>5\n<strong>解释：</strong>从 word1 中选出 \"ab\" ，从 word2 中选出 \"cba\" ，得到回文串 \"abcba\" 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>word1 = \"ab\", word2 = \"ab\"\n<strong>输出：</strong>3\n<strong>解释：</strong>从 word1 中选出 \"ab\" ，从 word2 中选出 \"a\" ，得到回文串 \"aba\" 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>word1 = \"aa\", word2 = \"bb\"\n<strong>输出：</strong>0\n<strong>解释：</strong>无法按题面所述方法构造回文串，所以返回 0 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word1.length, word2.length &lt;= 1000</code></li>\n\t<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1772.按受欢迎程度排列功能",
        "hardRate": "MEDIUM",
        "passRate": "47.22%",
        "problemsUrl": "https://leetcode.cn/problems/sort-features-by-popularity/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-features-by-popularity/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1773.统计匹配检索规则的物品数量",
        "hardRate": "EASY",
        "passRate": "86.50%",
        "problemsUrl": "https://leetcode.cn/problems/count-items-matching-a-rule/",
        "solutionsUrl": "https://leetcode.cn/problems/count-items-matching-a-rule/solution",
        "problemsDesc": "<p>给你一个数组 <code>items</code> ，其中 <code>items[i] = [type<sub>i</sub>, color<sub>i</sub>, name<sub>i</sub>]</code> ，描述第 <code>i</code> 件物品的类型、颜色以及名称。</p>\n\n<p>另给你一条由两个字符串 <code>ruleKey</code> 和 <code>ruleValue</code> 表示的检索规则。</p>\n\n<p>如果第 <code>i</code> 件物品能满足下述条件之一，则认为该物品与给定的检索规则 <strong>匹配</strong> ：</p>\n\n<ul>\n\t<li><code>ruleKey == \"type\"</code> 且 <code>ruleValue == type<sub>i</sub></code> 。</li>\n\t<li><code>ruleKey == \"color\"</code> 且 <code>ruleValue == color<sub>i</sub></code> 。</li>\n\t<li><code>ruleKey == \"name\"</code> 且 <code>ruleValue == name<sub>i</sub></code> 。</li>\n</ul>\n\n<p>统计并返回 <strong>匹配检索规则的物品数量</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"color\", ruleValue = \"silver\"\n<strong>输出：</strong>1\n<strong>解释：</strong>只有一件物品匹配检索规则，这件物品是 [\"computer\",\"silver\",\"lenovo\"] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"type\", ruleValue = \"phone\"\n<strong>输出：</strong>2\n<strong>解释：</strong>只有两件物品匹配检索规则，这两件物品分别是 [\"phone\",\"blue\",\"pixel\"] 和 [\"phone\",\"gold\",\"iphone\"] 。注意，[\"computer\",\"silver\",\"phone\"] 未匹配检索规则。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= items.length <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= type<sub>i</sub>.length, color<sub>i</sub>.length, name<sub>i</sub>.length, ruleValue.length <= 10</code></li>\n\t<li><code>ruleKey</code> 等于 <code>\"type\"</code>、<code>\"color\"</code> 或 <code>\"name\"</code></li>\n\t<li>所有字符串仅由小写字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1774.最接近目标价格的甜点成本",
        "hardRate": "MEDIUM",
        "passRate": "57.52%",
        "problemsUrl": "https://leetcode.cn/problems/closest-dessert-cost/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-dessert-cost/solution",
        "problemsDesc": "<p>你打算做甜点，现在需要购买配料。目前共有 <code>n</code> 种冰激凌基料和 <code>m</code> 种配料可供选购。而制作甜点需要遵循以下几条规则：</p>\n\n<ul>\n\t<li>必须选择 <strong>一种</strong> 冰激凌基料。</li>\n\t<li>可以添加 <strong>一种或多种</strong> 配料，也可以不添加任何配料。</li>\n\t<li>每种类型的配料 <strong>最多两份</strong> 。</li>\n</ul>\n\n<p>给你以下三个输入：</p>\n\n<ul>\n\t<li><code>baseCosts</code> ，一个长度为 <code>n</code> 的整数数组，其中每个 <code>baseCosts[i]</code> 表示第 <code>i</code> 种冰激凌基料的价格。</li>\n\t<li><code>toppingCosts</code>，一个长度为 <code>m</code> 的整数数组，其中每个 <code>toppingCosts[i]</code> 表示 <strong>一份</strong> 第 <code>i</code> 种冰激凌配料的价格。</li>\n\t<li><code>target</code> ，一个整数，表示你制作甜点的目标价格。</li>\n</ul>\n\n<p>你希望自己做的甜点总成本尽可能接近目标价格 <code>target</code> 。</p>\n\n<p>返回最接近<em> </em><code>target</code> 的甜点成本。如果有多种方案，返回 <strong>成本相对较低</strong> 的一种。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>baseCosts = [1,7], toppingCosts = [3,4], target = 10\n<strong>输出：</strong>10\n<strong>解释：</strong>考虑下面的方案组合（所有下标均从 0 开始）：\n- 选择 1 号基料：成本 7\n- 选择 1 份 0 号配料：成本 1 x 3 = 3\n- 选择 0 份 1 号配料：成本 0 x 4 = 0\n总成本：7 + 3 + 0 = 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\n<strong>输出：</strong>17\n<strong>解释：</strong>考虑下面的方案组合（所有下标均从 0 开始）：\n- 选择 1 号基料：成本 3\n- 选择 1 份 0 号配料：成本 1 x 4 = 4\n- 选择 2 份 1 号配料：成本 2 x 5 = 10\n- 选择 0 份 2 号配料：成本 0 x 100 = 0\n总成本：3 + 4 + 10 + 0 = 17 。不存在总成本为 18 的甜点制作方案。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>baseCosts = [3,10], toppingCosts = [2,5], target = 9\n<strong>输出：</strong>8\n<strong>解释：</strong>可以制作总成本为 8 和 10 的甜点。返回 8 ，因为这是成本更低的方案。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>baseCosts = [10], toppingCosts = [1], target = 1\n<strong>输出：</strong>10\n<strong>解释：</strong>注意，你可以选择不添加任何配料，但你必须选择一种基料。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == baseCosts.length</code></li>\n\t<li><code>m == toppingCosts.length</code></li>\n\t<li><code>1 <= n, m <= 10</code></li>\n\t<li><code>1 <= baseCosts[i], toppingCosts[i] <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= target <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1775.通过最少操作次数使数组的和相等",
        "hardRate": "MEDIUM",
        "passRate": "56.44%",
        "problemsUrl": "https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/solution",
        "problemsDesc": "<p>给你两个长度可能不等的整数数组 <code>nums1</code> 和 <code>nums2</code> 。两个数组中的所有值都在 <code>1</code> 到 <code>6</code> 之间（包含 <code>1</code> 和 <code>6</code>）。</p>\n\n<p>每次操作中，你可以选择 <strong>任意</strong> 数组中的任意一个整数，将它变成 <code>1</code> 到 <code>6</code> 之间 <strong>任意</strong> 的值（包含 <code>1</code> 和 <code><span style=\"\">6</span></code>）。</p>\n\n<p>请你返回使 <code>nums1</code> 中所有数的和与 <code>nums2</code> 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2]\n<b>输出：</b>3\n<b>解释：</b>你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。\n- 将 nums2[0] 变为 6 。 nums1 = [1,2,3,4,5,6], nums2 = [<strong>6</strong>,1,2,2,2,2] 。\n- 将 nums1[5] 变为 1 。 nums1 = [1,2,3,4,5,<strong>1</strong>], nums2 = [6,1,2,2,2,2] 。\n- 将 nums1[2] 变为 2 。 nums1 = [1,2,<strong>2</strong>,4,5,1], nums2 = [6,1,2,2,2,2] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,1,1,1,1,1,1], nums2 = [6]\n<b>输出：</b>-1\n<b>解释：</b>没有办法减少 nums1 的和或者增加 nums2 的和使二者相等。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums1 = [6,6], nums2 = [1]\n<b>输出：</b>3\n<b>解释：</b>你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。\n- 将 nums1[0] 变为 2 。 nums1 = [<strong>2</strong>,6], nums2 = [1] 。\n- 将 nums1[1] 变为 2 。 nums1 = [2,<strong>2</strong>], nums2 = [1] 。\n- 将 nums2[0] 变为 4 。 nums1 = [2,2], nums2 = [<strong>4</strong>] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1776.车队 II",
        "hardRate": "HARD",
        "passRate": "48.62%",
        "problemsUrl": "https://leetcode.cn/problems/car-fleet-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/car-fleet-ii/solution",
        "problemsDesc": "<p>在一条单车道上有 <code>n</code> 辆车，它们朝着同样的方向行驶。给你一个长度为 <code>n</code> 的数组 <code>cars</code> ，其中 <code>cars[i] = [position<sub>i</sub>, speed<sub>i</sub>]</code> ，它表示：</p>\n\n<ul>\n\t<li><code>position<sub>i</sub></code> 是第 <code>i</code> 辆车和道路起点之间的距离（单位：米）。题目保证 <code>position<sub>i</sub> < position<sub>i+1</sub></code><sub> </sub>。</li>\n\t<li><code>speed<sub>i</sub></code> 是第 <code>i</code> 辆车的初始速度（单位：米/秒）。</li>\n</ul>\n\n<p>简单起见，所有车子可以视为在数轴上移动的点。当两辆车占据同一个位置时，我们称它们相遇了。一旦两辆车相遇，它们会合并成一个车队，这个车队里的车有着同样的位置和相同的速度，速度为这个车队里 <strong>最慢</strong> 一辆车的速度。</p>\n\n<p>请你返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 <code>i</code> 辆车与下一辆车相遇的时间（单位：秒），如果这辆车不会与下一辆车相遇，则 <code>answer[i]</code> 为 <code>-1</code> 。答案精度误差需在 <code>10<sup>-5</sup></code> 以内。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>cars = [[1,2],[2,1],[4,3],[7,2]]\n<b>输出：</b>[1.00000,-1.00000,3.00000,-1.00000]\n<b>解释：</b>经过恰好 1 秒以后，第一辆车会与第二辆车相遇，并形成一个 1 m/s 的车队。经过恰好 3 秒以后，第三辆车会与第四辆车相遇，并形成一个 2 m/s 的车队。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>cars = [[3,4],[5,4],[6,3],[9,1]]\n<b>输出：</b>[2.00000,1.00000,1.50000,-1.00000]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= cars.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= position<sub>i</sub>, speed<sub>i</sub> <= 10<sup>6</sup></code></li>\n\t<li><code>position<sub>i</sub> < position<sub>i+1</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1777.每家商店的产品价格",
        "hardRate": "EASY",
        "passRate": "78.37%",
        "problemsUrl": "https://leetcode.cn/problems/products-price-for-each-store/",
        "solutionsUrl": "https://leetcode.cn/problems/products-price-for-each-store/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1778.未知网格中的最短路径",
        "hardRate": "MEDIUM",
        "passRate": "48.09%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-path-in-a-hidden-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-path-in-a-hidden-grid/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1779.找到最近的有相同 X 或 Y 坐标的点",
        "hardRate": "EASY",
        "passRate": "68.96%",
        "problemsUrl": "https://leetcode.cn/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate/",
        "solutionsUrl": "https://leetcode.cn/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate/solution",
        "problemsDesc": "<p>给你两个整数&nbsp;<code>x</code> 和&nbsp;<code>y</code>&nbsp;，表示你在一个笛卡尔坐标系下的&nbsp;<code>(x, y)</code>&nbsp;处。同时，在同一个坐标系下给你一个数组&nbsp;<code>points</code>&nbsp;，其中&nbsp;<code>points[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示在&nbsp;<code>(a<sub>i</sub>, b<sub>i</sub>)</code>&nbsp;处有一个点。当一个点与你所在的位置有相同的 <code>x</code> 坐标或者相同的 <code>y</code> 坐标时，我们称这个点是 <b>有效的</b>&nbsp;。</p>\n\n<p>请返回距离你当前位置&nbsp;<strong>曼哈顿距离</strong>&nbsp;最近的&nbsp;<strong>有效</strong>&nbsp;点的下标（下标从 <strong>0</strong> 开始）。如果有多个最近的有效点，请返回下标&nbsp;<strong>最小</strong>&nbsp;的一个。如果没有有效点，请返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>两个点 <code>(x<sub>1</sub>, y<sub>1</sub>)</code>&nbsp;和 <code>(x<sub>2</sub>, y<sub>2</sub>)</code>&nbsp;之间的 <strong>曼哈顿距离</strong>&nbsp;为&nbsp;<code>abs(x<sub>1</sub> - x<sub>2</sub>) + abs(y<sub>1</sub> - y<sub>2</sub>)</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]]\n<b>输出：</b>2\n<b>解释：</b>所有点中，[3,1]，[2,4] 和 [4,4] 是有效点。有效点中，[2,4] 和 [4,4] 距离你当前位置的曼哈顿距离最小，都为 1 。[2,4] 的下标最小，所以返回 2 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>x = 3, y = 4, points = [[3,4]]\n<b>输出：</b>0\n<b>提示：</b>答案可以与你当前所在位置坐标相同。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>x = 3, y = 4, points = [[2,3]]\n<b>输出：</b>-1\n<b>解释：</b>没有 有效点。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= points.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>1 &lt;= x, y, a<sub>i</sub>, b<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1780.判断一个数字是否可以表示成三的幂的和",
        "hardRate": "MEDIUM",
        "passRate": "74.79%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-number-is-a-sum-of-powers-of-three/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-number-is-a-sum-of-powers-of-three/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，如果你可以将 <code>n</code> 表示成若干个不同的三的幂之和，请你返回 <code>true</code> ，否则请返回 <code>false</code> 。</p>\n\n<p>对于一个整数 <code>y</code> ，如果存在整数 <code>x</code> 满足 <code>y == 3<sup>x</sup></code> ，我们称这个整数 <code>y</code> 是三的幂。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 12\n<b>输出：</b>true\n<b>解释：</b>12 = 3<sup>1</sup> + 3<sup>2</sup>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 91\n<b>输出：</b>true\n<b>解释：</b>91 = 3<sup>0</sup> + 3<sup>2</sup> + 3<sup>4</sup>\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>n = 21\n<b>输出：</b>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1781.所有子字符串美丽值之和",
        "hardRate": "MEDIUM",
        "passRate": "66.50%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-beauty-of-all-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-beauty-of-all-substrings/solution",
        "problemsDesc": "<p>一个字符串的 <strong>美丽值</strong> 定义为：出现频率最高字符与出现频率最低字符的出现次数之差。</p>\n\n<ul>\n\t<li>比方说，<code>\"abaacc\"</code> 的美丽值为 <code>3 - 1 = 2</code> 。</li>\n</ul>\n\n<p>给你一个字符串 <code>s</code> ，请你返回它所有子字符串的 <strong>美丽值</strong> 之和。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aabcb\"\n<b>输出：</b>5\n<strong>解释：</strong>美丽值不为零的字符串包括 [\"aab\",\"aabc\",\"aabcb\",\"abcb\",\"bcb\"] ，每一个字符串的美丽值都为 1 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aabcbaa\"\n<b>输出：</b>17\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <=<sup> </sup>500</code></li>\n\t<li><code>s</code> 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1782.统计点对的数目",
        "hardRate": "HARD",
        "passRate": "35.76%",
        "problemsUrl": "https://leetcode.cn/problems/count-pairs-of-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/count-pairs-of-nodes/solution",
        "problemsDesc": "<p>给你一个无向图，无向图由整数 <code>n</code>  ，表示图中节点的数目，和 <code>edges</code> 组成，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> 表示 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code><sub> </sub>之间有一条无向边。同时给你一个代表查询的整数数组 <code>queries</code> 。</p>\n\n<p>第 <code>j</code> 个查询的答案是满足如下条件的点对 <code>(a, b)</code> 的数目：</p>\n\n<ul>\n\t<li><code>a < b</code></li>\n\t<li><code>cnt</code> 是与 <code>a</code> <strong>或者 </strong><code>b</code> 相连的边的数目，且 <code>cnt</code> <strong>严格大于 </strong><code>queries[j]</code> 。</li>\n</ul>\n\n<p>请你返回一个数组 <code>answers</code> ，其中 <code>answers.length == queries.length</code> 且 <code>answers[j]</code> 是第 <code>j</code> 个查询的答案。</p>\n\n<p>请注意，图中可能会有 <strong>重复边</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://pic.leetcode-cn.com/1614828447-GMnLVg-image.png\" style=\"width: 310px; height: 278px;\" />\n<pre>\n<b>输入：</b>n = 4, edges = [[1,2],[2,4],[1,3],[2,3],[2,1]], queries = [2,3]\n<b>输出：</b>[6,5]\n<b>解释：</b>每个点对中，与至少一个点相连的边的数目如上图所示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5, edges = [[1,5],[1,5],[3,4],[2,5],[1,3],[5,1],[2,3],[2,5]], queries = [1,2,3,4,5]\n<b>输出：</b>[10,10,9,8,6]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= edges.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= u<sub>i</sub>, v<sub>i</sub> <= n</code></li>\n\t<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>\n\t<li><code>1 <= queries.length <= 20</code></li>\n\t<li><code>0 <= queries[j] < edges.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1783.大满贯数量",
        "hardRate": "MEDIUM",
        "passRate": "80.58%",
        "problemsUrl": "https://leetcode.cn/problems/grand-slam-titles/",
        "solutionsUrl": "https://leetcode.cn/problems/grand-slam-titles/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1784.检查二进制字符串字段",
        "hardRate": "EASY",
        "passRate": "59.48%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-binary-string-has-at-most-one-segment-of-ones/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-binary-string-has-at-most-one-segment-of-ones/solution",
        "problemsDesc": "<p>给你一个二进制字符串 <code>s</code> ，该字符串 <strong>不含前导零</strong> 。</p>\n\n<p>如果 <code>s</code> 包含 <strong>零个或一个由连续的 <code>'1'</code> 组成的字段</strong> ，返回 <code>true</code>​​​ 。否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1001\"\n<strong>输出：</strong>false\n<strong>解释：</strong>由连续若干个&nbsp;<code>'1'</code> 组成的字段数量为 2，返回 false\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"110\"\n<strong>输出：</strong>true</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s[i]</code>​​​​ 为 <code>'0'</code> 或 <code>'1'</code></li>\n\t<li><code>s[0]</code> 为 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1785.构成特定和需要添加的最少元素",
        "hardRate": "MEDIUM",
        "passRate": "43.56%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-elements-to-add-to-form-a-given-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-elements-to-add-to-form-a-given-sum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，和两个整数 <code>limit</code> 与 <code>goal</code> 。数组 <code>nums</code> 有一条重要属性：<code>abs(nums[i]) <= limit</code> 。</p>\n\n<p>返回使数组元素总和等于 <code>goal</code> 所需要向数组中添加的 <strong>最少元素数量</strong> ，添加元素 <strong>不应改变</strong> 数组中 <code>abs(nums[i]) <= limit</code> 这一属性。</p>\n\n<p>注意，如果 <code>x >= 0</code> ，那么 <code>abs(x)</code> 等于 <code>x</code> ；否则，等于 <code>-x</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,-1,1], limit = 3, goal = -4\n<strong>输出：</strong>2\n<strong>解释：</strong>可以将 -2 和 -3 添加到数组中，数组的元素总和变为 1 - 1 + 1 - 2 - 3 = -4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,-10,9,1], limit = 100, goal = 0\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= limit <= 10<sup>6</sup></code></li>\n\t<li><code>-limit <= nums[i] <= limit</code></li>\n\t<li><code>-10<sup>9</sup> <= goal <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1786.从第一个节点出发到最后一个节点的受限路径数",
        "hardRate": "MEDIUM",
        "passRate": "36.38%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-restricted-paths-from-first-to-last-node/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-restricted-paths-from-first-to-last-node/solution",
        "problemsDesc": "<p>现有一个加权无向连通图。给你一个正整数 <code>n</code> ，表示图中有 <code>n</code> 个节点，并按从 <code>1</code> 到 <code>n</code> 给节点编号；另给你一个数组 <code>edges</code> ，其中每个 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, weight<sub>i</sub>]</code> 表示存在一条位于节点 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code> 之间的边，这条边的权重为 <code>weight<sub>i</sub></code> 。</p>\n\n<p>从节点 <code>start</code> 出发到节点 <code>end</code> 的路径是一个形如 <code>[z<sub>0</sub>, z<sub>1</sub>,<sub> </sub>z<sub>2</sub>, ..., z<sub>k</sub>]</code> 的节点序列，满足 <code>z<sub>0 </sub>= start</code> 、<code>z<sub>k</sub> = end</code> 且在所有符合 <code>0 <= i <= k-1</code> 的节点 <code>z<sub>i</sub></code> 和 <code>z<sub>i+1</sub></code> 之间存在一条边。</p>\n\n<p>路径的距离定义为这条路径上所有边的权重总和。用 <code>distanceToLastNode(x)</code> 表示节点 <code>n</code> 和 <code>x</code> 之间路径的最短距离。<strong>受限路径</strong> 为满足 <code>distanceToLastNode(z<sub>i</sub>) > distanceToLastNode(z<sub>i+1</sub>)</code> 的一条路径，其中 <code>0 <= i <= k-1</code> 。</p>\n\n<p>返回从节点 <code>1</code> 出发到节点 <code>n</code> 的 <strong>受限路径数</strong> 。由于数字可能很大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/07/restricted_paths_ex1.png\" style=\"width: 351px; height: 341px;\" />\n<pre>\n<strong>输入：</strong>n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]]\n<strong>输出：</strong>3\n<strong>解释：</strong>每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。三条受限路径分别是：\n1) 1 --> 2 --> 5\n2) 1 --> 2 --> 3 --> 5\n3) 1 --> 3 --> 5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/07/restricted_paths_ex22.png\" style=\"width: 356px; height: 401px;\" />\n<pre>\n<strong>输入：</strong>n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]]\n<strong>输出：</strong>1\n<strong>解释：</strong>每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。唯一一条受限路径是：1 --> 3 --> 7 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 2 * 10<sup>4</sup></code></li>\n\t<li><code>n - 1 <= edges.length <= 4 * 10<sup>4</sup></code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>1 <= u<sub>i</sub>, v<sub>i</sub> <= n</code></li>\n\t<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>\n\t<li><code>1 <= weight<sub>i</sub> <= 10<sup>5</sup></code></li>\n\t<li>任意两个节点之间至多存在一条边</li>\n\t<li>任意两个节点之间至少存在一条路径</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1787.使所有区间的异或结果为零",
        "hardRate": "HARD",
        "passRate": "64.30%",
        "problemsUrl": "https://leetcode.cn/problems/make-the-xor-of-all-segments-equal-to-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/make-the-xor-of-all-segments-equal-to-zero/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>​​​ 和一个整数 <code>k</code>​​​​​ 。区间 <code>[left, right]</code>（<code>left <= right</code>）的 <strong>异或结果</strong> 是对下标位于 <code>left</code> 和 <code>right</code>（包括 <code>left</code> 和 <code>right</code> ）之间所有元素进行 <code>XOR</code> 运算的结果：<code>nums[left] XOR nums[left+1] XOR ... XOR nums[right]</code> 。</p>\n\n<p>返回数组中 <strong>要更改的最小元素数</strong> ，以使所有长度为 <code>k</code> 的区间异或结果等于零。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,0,3,0], k = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>将数组 [<strong>1</strong>,<strong>2</strong>,0,<strong>3</strong>,0] 修改为 [<strong>0</strong>,<strong>0</strong>,0,<strong>0</strong>,0]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,5,2,1,7,3,4,7], k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>将数组 [3,4,<strong>5</strong>,<strong>2</strong>,<strong>1</strong>,7,3,4,7] 修改为 [3,4,<strong>7</strong>,<strong>3</strong>,<strong>4</strong>,7,3,4,7]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,4,1,2,5,1,2,6], k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>将数组[1,2,<strong>4,</strong>1,2,<strong>5</strong>,1,2,<strong>6</strong>] 修改为 [1,2,<strong>3</strong>,1,2,<strong>3</strong>,1,2,<strong>3</strong>]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= k <= nums.length <= 2000</code></li>\n\t<li><code>​​​​​​0 <= nums[i] < 2<sup>10</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1788.最大化花园的美观度",
        "hardRate": "HARD",
        "passRate": "65.40%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-the-beauty-of-the-garden/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-the-beauty-of-the-garden/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1789.员工的直属部门",
        "hardRate": "EASY",
        "passRate": "72.01%",
        "problemsUrl": "https://leetcode.cn/problems/primary-department-for-each-employee/",
        "solutionsUrl": "https://leetcode.cn/problems/primary-department-for-each-employee/solution",
        "problemsDesc": "<p>Table: <code>Employee</code></p>\n\n<pre>+---------------+---------+\n| Column Name   |  Type   |\n+---------------+---------+\n| employee_id   | int     |\n| department_id | int     |\n| primary_flag  | varchar |\n+---------------+---------+\n这张表的主键为 employee_id, department_id\nemployee_id 是员工的ID\ndepartment_id 是部门的ID，表示员工与该部门有关系\nprimary_flag 是一个枚举类型，值分别为('Y', 'N'). 如果值为'Y',表示该部门是员工的直属部门。 如果值是'N',则否\n</pre>\n\n<p> </p>\n\n<p>一个员工可以属于多个部门。</p>\n\n<p>当一个员工加入<strong>超过一个部门</strong>的时候，他需要决定哪个部门是他的直属部门。</p>\n\n<p>请注意，当员工只加入一个部门的时候，那这个部门将默认为他的直属部门，虽然表记录的值为<code>'N'</code>.</p>\n\n<p>请编写一段SQL，查出员工所属的直属部门。</p>\n\n<p>返回结果没有顺序要求。</p>\n\n<p> </p>\n\n<p>示例：</p>\n\n<pre>Employee table:\n+-------------+---------------+--------------+\n| employee_id | department_id | primary_flag |\n+-------------+---------------+--------------+\n| 1           | 1             | N            |\n| 2           | 1             | Y            |\n| 2           | 2             | N            |\n| 3           | 3             | N            |\n| 4           | 2             | N            |\n| 4           | 3             | Y            |\n| 4           | 4             | N            |\n+-------------+---------------+--------------+\n\nResult table:\n+-------------+---------------+\n| employee_id | department_id |\n+-------------+---------------+\n| 1           | 1             |\n| 2           | 1             |\n| 3           | 3             |\n| 4           | 3             |\n+-------------+---------------+\n- 员工1的直属部门是1\n- 员工2的直属部门是1\n- 员工3的直属部门是3\n- 员工4的直属部门是3</pre>\n\n<p> </p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1790.仅执行一次字符串交换能否使两个字符串相等",
        "hardRate": "EASY",
        "passRate": "52.52%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-one-string-swap-can-make-strings-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-one-string-swap-can-make-strings-equal/solution",
        "problemsDesc": "<p>给你长度相等的两个字符串 <code>s1</code> 和 <code>s2</code> 。一次<strong> 字符串交换 </strong>操作的步骤如下：选出某个字符串中的两个下标（不必不同），并交换这两个下标所对应的字符。</p>\n\n<p>如果对 <strong>其中一个字符串</strong> 执行 <strong>最多一次字符串交换</strong> 就可以使两个字符串相等，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"bank\", s2 = \"kanb\"\n<strong>输出：</strong>true\n<strong>解释：</strong>例如，交换 s2 中的第一个和最后一个字符可以得到 \"bank\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"attack\", s2 = \"defend\"\n<strong>输出：</strong>false\n<strong>解释：</strong>一次字符串交换无法使两个字符串相等\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"kelb\", s2 = \"kelb\"\n<strong>输出：</strong>true\n<strong>解释：</strong>两个字符串已经相等，所以不需要进行字符串交换\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"abcd\", s2 = \"dcba\"\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 100</code></li>\n\t<li><code>s1.length == s2.length</code></li>\n\t<li><code>s1</code> 和 <code>s2</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1791.找出星型图的中心节点",
        "hardRate": "EASY",
        "passRate": "83.07%",
        "problemsUrl": "https://leetcode.cn/problems/find-center-of-star-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/find-center-of-star-graph/solution",
        "problemsDesc": "<p>有一个无向的 <strong>星型</strong> 图，由 <code>n</code> 个编号从 <code>1</code> 到 <code>n</code> 的节点组成。星型图有一个 <strong>中心</strong> 节点，并且恰有 <code>n - 1</code> 条边将中心节点与其他每个节点连接起来。</p>\n\n<p>给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> 表示在节点 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code> 之间存在一条边。请你找出并返回 <code>edges</code> 所表示星型图的中心节点。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/14/star_graph.png\" style=\"width: 331px; height: 321px;\" />\n<pre>\n<strong>输入：</strong>edges = [[1,2],[2,3],[4,2]]\n<strong>输出：</strong>2\n<strong>解释：</strong>如上图所示，节点 2 与其他每个节点都相连，所以节点 2 是中心节点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>edges = [[1,2],[5,1],[1,3],[1,4]]\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 <= u<sub>i,</sub> v<sub>i</sub> <= n</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n\t<li>题目数据给出的 <code>edges</code> 表示一个有效的星型图</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1792.最大平均通过率",
        "hardRate": "MEDIUM",
        "passRate": "58.85%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-average-pass-ratio/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-average-pass-ratio/solution",
        "problemsDesc": "<p>一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 <code>classes</code> ，其中 <code>classes[i] = [pass<sub>i</sub>, total<sub>i</sub>]</code> ，表示你提前知道了第 <code>i</code> 个班级总共有 <code>total<sub>i</sub></code> 个学生，其中只有 <code>pass<sub>i</sub></code> 个学生可以通过考试。</p>\n\n<p>给你一个整数 <code>extraStudents</code> ，表示额外有 <code>extraStudents</code> 个聪明的学生，他们 <strong>一定</strong> 能通过任何班级的期末考。你需要给这 <code>extraStudents</code> 个学生每人都安排一个班级，使得 <strong>所有</strong> 班级的 <strong>平均</strong> 通过率 <strong>最大</strong> 。</p>\n\n<p>一个班级的 <strong>通过率</strong> 等于这个班级通过考试的学生人数除以这个班级的总人数。<strong>平均通过率</strong> 是所有班级的通过率之和除以班级数目。</p>\n\n<p>请你返回在安排这 <code><span style=\"\">extraStudents</span></code> 个学生去对应班级后的 <strong>最大</strong> 平均通过率。与标准答案误差范围在 <code>10<sup>-5</sup></code> 以内的结果都会视为正确结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>classes = [[1,2],[3,5],[2,2]], <code>extraStudents</code> = 2\n<b>输出：</b>0.78333\n<b>解释：</b>你可以将额外的两个学生都安排到第一个班级，平均通过率为 (3/4 + 3/5 + 2/2) / 3 = 0.78333 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>classes = [[2,4],[3,9],[4,5],[2,10]], <code>extraStudents</code> = 4\n<strong>输出：</strong>0.53485\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= classes.length <= 10<sup>5</sup></code></li>\n\t<li><code>classes[i].length == 2</code></li>\n\t<li><code>1 <= pass<sub>i</sub> <= total<sub>i</sub> <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= extraStudents <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1793.好子数组的最大分数",
        "hardRate": "HARD",
        "passRate": "45.51%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-of-a-good-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-of-a-good-subarray/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> <strong>（下标从 0 开始）</strong>和一个整数 <code>k</code> 。</p>\n\n<p>一个子数组 <code>(i, j)</code> 的 <strong>分数</strong> 定义为 <code>min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)</code> 。一个 <strong>好</strong> 子数组的两个端点下标需要满足 <code>i &lt;= k &lt;= j</code> 。</p>\n\n<p>请你返回 <strong>好</strong> 子数组的最大可能 <strong>分数</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,4,3,7,4,5], k = 3\n<b>输出：</b>15\n<b>解释：</b>最优子数组的左右端点下标是 (1, 5) ，分数为 min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [5,5,4,5,4,1,1,1], k = 0\n<b>输出：</b>20\n<b>解释：</b>最优子数组的左右端点下标是 (0, 4) ，分数为 min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= k &lt; nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1794.统计距离最小的子串对个数",
        "hardRate": "MEDIUM",
        "passRate": "55.39%",
        "problemsUrl": "https://leetcode.cn/problems/count-pairs-of-equal-substrings-with-minimum-difference/",
        "solutionsUrl": "https://leetcode.cn/problems/count-pairs-of-equal-substrings-with-minimum-difference/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1795.每个产品在不同商店的价格",
        "hardRate": "EASY",
        "passRate": "78.20%",
        "problemsUrl": "https://leetcode.cn/problems/rearrange-products-table/",
        "solutionsUrl": "https://leetcode.cn/problems/rearrange-products-table/solution",
        "problemsDesc": "<p>表：<code>Products</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| product_id  | int     |\n| store1      | int     |\n| store2      | int     |\n| store3      | int     |\n+-------------+---------+\n这张表的主键是product_id（产品Id）。\n每行存储了这一产品在不同商店store1, store2, store3的价格。\n如果这一产品在商店里没有出售，则值将为null。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>请你重构 <code>Products</code> 表，查询每个产品在不同商店的价格，使得输出的格式变为<code>(product_id, store, price)</code> 。如果这一产品在商店里没有出售，则不输出这一行。</p>\n\n<p>输出结果表中的 <strong>顺序不作要求</strong> 。</p>\n\n<p>查询输出格式请参考下面示例。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nProducts table:\n+------------+--------+--------+--------+\n| product_id | store1 | store2 | store3 |\n+------------+--------+--------+--------+\n| 0          | 95     | 100    | 105    |\n| 1          | 70     | null   | 80     |\n+------------+--------+--------+--------+\n<strong>输出：</strong>\n+------------+--------+-------+\n| product_id | store  | price |\n+------------+--------+-------+\n| 0          | store1 | 95    |\n| 0          | store2 | 100   |\n| 0          | store3 | 105   |\n| 1          | store1 | 70    |\n| 1          | store3 | 80    |\n+------------+--------+-------+\n<strong>解释：</strong>\n产品0在store1，store2,store3的价格分别为95,100,105。\n产品1在store1，store3的价格分别为70,80。在store2无法买到。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1796.字符串中第二大的数字",
        "hardRate": "EASY",
        "passRate": "54.88%",
        "problemsUrl": "https://leetcode.cn/problems/second-largest-digit-in-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/second-largest-digit-in-a-string/solution",
        "problemsDesc": "<p>给你一个混合字符串 <code>s</code> ，请你返回 <code>s</code> 中 <strong>第二大 </strong>的数字，如果不存在第二大的数字，请你返回 <code>-1</code> 。</p>\n\n<p><strong>混合字符串 </strong>由小写英文字母和数字组成。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"dfa12321afd\"\n<b>输出：</b>2\n<b>解释：</b>出现在 s 中的数字包括 [1, 2, 3] 。第二大的数字是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"abc1111\"\n<b>输出：</b>-1\n<b>解释：</b>出现在 s 中的数字只包含 [1] 。没有第二大的数字。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 500</code></li>\n\t<li><code>s</code> 只包含小写英文字母和（或）数字。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1797.设计一个验证系统",
        "hardRate": "MEDIUM",
        "passRate": "64.93%",
        "problemsUrl": "https://leetcode.cn/problems/design-authentication-manager/",
        "solutionsUrl": "https://leetcode.cn/problems/design-authentication-manager/solution",
        "problemsDesc": "<p>你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在 <code>currentTime</code> 时刻之后 <code>timeToLive</code> 秒过期。如果验证码被更新了，那么它会在 <code>currentTime</code> （可能与之前的 <code>currentTime</code> 不同）时刻延长 <code>timeToLive</code> 秒。</p>\n\n<p>请你实现 <code>AuthenticationManager</code> 类：</p>\n\n<ul>\n\t<li><code>AuthenticationManager(int timeToLive)</code> 构造 <code>AuthenticationManager</code> 并设置 <code>timeToLive</code> 参数。</li>\n\t<li><code>generate(string tokenId, int currentTime)</code> 给定 <code>tokenId</code> ，在当前时间 <code>currentTime</code> 生成一个新的验证码。</li>\n\t<li><code>renew(string tokenId, int currentTime)</code> 将给定 <code>tokenId</code> 且 <strong>未过期</strong> 的验证码在 <code>currentTime</code> 时刻更新。如果给定 <code>tokenId</code> 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。</li>\n\t<li><code>countUnexpiredTokens(int currentTime)</code> 请返回在给定 <code>currentTime</code> 时刻，<strong>未过期</strong> 的验证码数目。</li>\n</ul>\n\n<p>如果一个验证码在时刻 <code>t</code> 过期，且另一个操作恰好在时刻 <code>t</code> 发生（<code>renew</code> 或者 <code>countUnexpiredTokens</code> 操作），过期事件 <strong>优先于</strong> 其他操作。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/25/copy-of-pc68_q2.png\" style=\"width: 500px; height: 287px;\" />\n<pre>\n<strong>输入：</strong>\n[\"AuthenticationManager\", \"<code>renew</code>\", \"generate\", \"<code>countUnexpiredTokens</code>\", \"generate\", \"<code>renew</code>\", \"<code>renew</code>\", \"<code>countUnexpiredTokens</code>\"]\n[[5], [\"aaa\", 1], [\"aaa\", 2], [6], [\"bbb\", 7], [\"aaa\", 8], [\"bbb\", 10], [15]]\n<strong>输出：</strong>\n[null, null, null, 1, null, null, null, 0]\n\n<strong>解释：</strong>\nAuthenticationManager authenticationManager = new AuthenticationManager(5); // 构造 AuthenticationManager ，设置 <code>timeToLive</code> = 5 秒。\nauthenticationManager.<code>renew</code>(\"aaa\", 1); // 时刻 1 时，没有验证码的 tokenId 为 \"aaa\" ，没有验证码被更新。\nauthenticationManager.generate(\"aaa\", 2); // 时刻 2 时，生成一个 tokenId 为 \"aaa\" 的新验证码。\nauthenticationManager.<code>countUnexpiredTokens</code>(6); // 时刻 6 时，只有 tokenId 为 \"aaa\" 的验证码未过期，所以返回 1 。\nauthenticationManager.generate(\"bbb\", 7); // 时刻 7 时，生成一个 tokenId 为 \"bbb\" 的新验证码。\nauthenticationManager.<code>renew</code>(\"aaa\", 8); // tokenId 为 \"aaa\" 的验证码在时刻 7 过期，且 8 >= 7 ，所以时刻 8 的renew 操作被忽略，没有验证码被更新。\nauthenticationManager.<code>renew</code>(\"bbb\", 10); // tokenId 为 \"bbb\" 的验证码在时刻 10 没有过期，所以 renew 操作会执行，该 token 将在时刻 15 过期。\nauthenticationManager.<code>countUnexpiredTokens</code>(15); // tokenId 为 \"bbb\" 的验证码在时刻 15 过期，tokenId 为 \"aaa\" 的验证码在时刻 7 过期，所有验证码均已过期，所以返回 0 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= timeToLive <= 10<sup>8</sup></code></li>\n\t<li><code>1 <= currentTime <= 10<sup>8</sup></code></li>\n\t<li><code>1 <= tokenId.length <= 5</code></li>\n\t<li><code>tokenId</code> 只包含小写英文字母。</li>\n\t<li>所有 <code>generate</code> 函数的调用都会包含独一无二的 <code>tokenId</code> 值。</li>\n\t<li>所有函数调用中，<code>currentTime</code> 的值 <strong>严格递增</strong> 。</li>\n\t<li>所有函数的调用次数总共不超过 <code>2000</code> 次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1798.你能构造出连续值的最大数目",
        "hardRate": "MEDIUM",
        "passRate": "70.97%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-consecutive-values-you-can-make/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-consecutive-values-you-can-make/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的整数数组 <code>coins</code> ，它代表你拥有的 <code>n</code> 个硬币。第 <code>i</code> 个硬币的值为 <code>coins[i]</code> 。如果你从这些硬币中选出一部分硬币，它们的和为 <code>x</code> ，那么称，你可以 <strong>构造</strong> 出 <code>x</code> 。</p>\n\n<p>请返回从 <code>0</code> 开始（<strong>包括</strong> <code>0</code> ），你最多能 <strong>构造</strong> 出多少个连续整数。</p>\n\n<p>你可能有多个相同值的硬币。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>coins = [1,3]\n<b>输出：</b>2\n<strong>解释：</strong>你可以得到以下这些值：\n- 0：什么都不取 []\n- 1：取 [1]\n从 0 开始，你可以构造出 2 个连续整数。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>coins = [1,1,1,4]\n<b>输出：</b>8\n<strong>解释：</strong>你可以得到以下这些值：\n- 0：什么都不取 []\n- 1：取 [1]\n- 2：取 [1,1]\n- 3：取 [1,1,1]\n- 4：取 [4]\n- 5：取 [4,1]\n- 6：取 [4,1,1]\n- 7：取 [4,1,1,1]\n从 0 开始，你可以构造出 8 个连续整数。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,4,10,3,1]\n<b>输出：</b>20</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>coins.length == n</code></li>\n\t<li><code>1 <= n <= 4 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= coins[i] <= 4 * 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1799.N 次操作后的最大分数和",
        "hardRate": "HARD",
        "passRate": "65.68%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-score-after-n-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-score-after-n-operations/solution",
        "problemsDesc": "<p>给你 <code>nums</code> ，它是一个大小为 <code>2 * n</code> 的正整数数组。你必须对这个数组执行 <code>n</code> 次操作。</p>\n\n<p>在第 <code>i</code> 次操作时（操作编号从 <strong>1</strong> 开始），你需要：</p>\n\n<ul>\n\t<li>选择两个元素 <code>x</code> 和 <code>y</code> 。</li>\n\t<li>获得分数 <code>i * gcd(x, y)</code> 。</li>\n\t<li>将 <code>x</code> 和 <code>y</code> 从 <code>nums</code> 中删除。</li>\n</ul>\n\n<p>请你返回 <code>n</code> 次操作后你能获得的分数和最大为多少。</p>\n\n<p>函数 <code>gcd(x, y)</code> 是 <code>x</code> 和 <code>y</code> 的最大公约数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2]\n<b>输出：</b>1\n<b>解释：</b>最优操作是：\n(1 * gcd(1, 2)) = 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [3,4,6,8]\n<b>输出：</b>11\n<b>解释：</b>最优操作是：\n(1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4,5,6]\n<b>输出：</b>14\n<b>解释：</b>最优操作是：\n(1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 7</code></li>\n\t<li><code>nums.length == 2 * n</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1800.最大升序子数组和",
        "hardRate": "EASY",
        "passRate": "68.69%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-ascending-subarray-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-ascending-subarray-sum/solution",
        "problemsDesc": "<p>给你一个正整数组成的数组 <code>nums</code> ，返回 <code>nums</code> 中一个 <strong>升序 </strong>子数组的最大可能元素和。</p>\n\n<p>子数组是数组中的一个连续数字序列。</p>\n\n<p>已知子数组 <code>[nums<sub>l</sub>, nums<sub>l+1</sub>, ..., nums<sub>r-1</sub>, nums<sub>r</sub>]</code> ，若对所有 <code>i</code>（<code>l <= i < r</code>），<code>nums<sub>i </sub> < nums<sub>i+1</sub></code> 都成立，则称这一子数组为 <strong>升序</strong> 子数组。注意，大小为 <code>1</code> 的子数组也视作 <strong>升序</strong> 子数组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,20,30,5,10,50]\n<strong>输出：</strong>65\n<strong>解释：</strong>[5,10,50] 是元素和最大的升序子数组，最大元素和为 65 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,20,30,40,50]\n<strong>输出：</strong>150\n<strong>解释：</strong>[10,20,30,40,50] 是元素和最大的升序子数组，最大元素和为 150 。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [12,17,15,13,10,11,12]\n<strong>输出：</strong>33\n<strong>解释：</strong>[10,11,12] 是元素和最大的升序子数组，最大元素和为 33 。 \n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [100,10,1]\n<strong>输出：</strong>100\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 100</code></li>\n\t<li><code>1 <= nums[i] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    }
]