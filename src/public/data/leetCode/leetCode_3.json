[
    {
        "problemsName": " 1001网格照明",
        "hardRate": "HARD",
        "passRate": "44.86%",
        "problemsUrl": "https://leetcode.cn/problems/grid-illumination/",
        "solutionsUrl": "https://leetcode.cn/problems/grid-illumination/solution",
        "problemsDesc": "<p>在大小为 <code>n x n</code> 的网格 <code>grid</code> 上，每个单元格都有一盏灯，最初灯都处于 <strong>关闭</strong> 状态。</p>\n\n<p>给你一个由灯的位置组成的二维数组&nbsp;<code>lamps</code> ，其中 <code>lamps[i] = [row<sub>i</sub>, col<sub>i</sub>]</code> 表示 <strong>打开</strong> 位于 <code>grid[row<sub>i</sub>][col<sub>i</sub>]</code> 的灯。即便同一盏灯可能在 <code>lamps</code> 中多次列出，不会影响这盏灯处于 <strong>打开</strong> 状态。</p>\n\n<p>当一盏灯处于打开状态，它将会照亮 <strong>自身所在单元格</strong> 以及同一 <strong>行</strong> 、同一 <strong>列</strong> 和两条 <strong>对角线</strong> 上的 <strong>所有其他单元格</strong> 。</p>\n\n<p>另给你一个二维数组 <code>queries</code> ，其中 <code>queries[j] = [row<sub>j</sub>, col<sub>j</sub>]</code> 。对于第 <code>j</code> 个查询，如果单元格 <code>[row<sub>j</sub>, col<sub>j</sub>]</code> 是被照亮的，则查询结果为 <code>1</code> ，否则为 <code>0</code> 。在第 <code>j</code> 次查询之后 [按照查询的顺序] ，<strong>关闭</strong> 位于单元格 <code>grid[row<sub>j</sub>][col<sub>j</sub>]</code> 上及相邻 8 个方向上（与单元格 <code>grid[row<sub>i</sub>][col<sub>i</sub>]</code> 共享角或边）的任何灯。</p>\n\n<p>返回一个整数数组 <code>ans</code> 作为答案， <code>ans[j]</code> 应等于第 <code>j</code> 次查询&nbsp;<code>queries[j]</code>&nbsp;的结果，<code>1</code> 表示照亮，<code>0</code> 表示未照亮。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/19/illu_1.jpg\" style=\"height: 209px; width: 750px;\" />\n<pre>\n<strong>输入：</strong>n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]\n<strong>输出：</strong>[1,0]\n<strong>解释：</strong>最初所有灯都是关闭的。在执行查询之前，打开位于 [0, 0] 和 [4, 4] 的灯。第 0&nbsp;次查询检查 grid[1][1] 是否被照亮（蓝色方框）。该单元格被照亮，所以 ans[0] = 1 。然后，关闭红色方框中的所有灯。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/19/illu_step1.jpg\" style=\"height: 218px; width: 500px;\" />\n第 1&nbsp;次查询检查 grid[1][0] 是否被照亮（蓝色方框）。该单元格没有被照亮，所以 ans[1] = 0 。然后，关闭红色矩形中的所有灯。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/19/illu_step2.jpg\" style=\"height: 219px; width: 500px;\" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,1]]\n<strong>输出：</strong>[1,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, lamps = [[0,0],[0,4]], queries = [[0,4],[0,1],[1,4]]\n<strong>输出：</strong>[1,1,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= lamps.length &lt;= 20000</code></li>\n\t<li><code>0 &lt;= queries.length &lt;= 20000</code></li>\n\t<li><code>lamps[i].length == 2</code></li>\n\t<li><code>0 &lt;= row<sub>i</sub>, col<sub>i</sub> &lt; n</code></li>\n\t<li><code>queries[j].length == 2</code></li>\n\t<li><code>0 &lt;= row<sub>j</sub>, col<sub>j</sub> &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1002查找共用字符",
        "hardRate": "EASY",
        "passRate": "70.63%",
        "problemsUrl": "https://leetcode.cn/problems/find-common-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/find-common-characters/solution",
        "problemsDesc": "给你一个字符串数组 <code>words</code> ，请你找出所有在 <code>words</code> 的每个字符串中都出现的共用字符（ <strong>包括重复字符</strong>），并以数组形式返回。你可以按 <strong>任意顺序</strong> 返回答案。\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"bella\",\"label\",\"roller\"]\n<strong>输出：</strong>[\"e\",\"l\",\"l\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"cool\",\"lock\",\"cook\"]\n<strong>输出：</strong>[\"c\",\"o\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><code>words[i]</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1003检查替换后的词是否有效",
        "hardRate": "MEDIUM",
        "passRate": "63.64%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-word-is-valid-after-substitutions/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-word-is-valid-after-substitutions/solution",
        "problemsDesc": "给你一个字符串 <code>s</code> ，请你判断它是否 <strong>有效</strong> 。\n<p>字符串 <code>s</code> <strong>有效</strong> 需要满足：假设开始有一个空字符串 <code>t = \"\"</code> ，你可以执行 <strong>任意次</strong> 下述操作将<strong> </strong><code>t</code><strong> 转换为 </strong><code>s</code> ：</p>\n\n<ul>\n\t<li>将字符串 <code>\"abc\"</code> 插入到 <code>t</code> 中的任意位置。形式上，<code>t</code> 变为 <code>t<sub>left</sub> + \"abc\" + t<sub>right</sub></code>，其中 <code>t == t<sub>left</sub> + t<sub>right</sub></code> 。注意，<code>t<sub>left</sub></code> 和 <code>t<sub>right</sub></code> 可能为 <strong>空</strong> 。</li>\n</ul>\n\n<p>如果字符串 <code>s</code> 有效，则返回 <code>true</code>；否则，返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aabcbc\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\n\"\" -&gt; \"<strong>abc</strong>\" -&gt; \"a<strong>abc</strong>bc\"\n因此，\"aabcbc\" 有效。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcabcababcc\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\n\"\" -&gt; \"<strong>abc</strong>\" -&gt; \"abc<strong>abc</strong>\" -&gt; \"abcabc<strong>abc</strong>\" -&gt; \"abcabcab<strong>abc</strong>c\"\n因此，\"abcabcababcc\" 有效。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abccba\"\n<strong>输出：</strong>false\n<strong>解释：</strong>执行操作无法得到 \"abccba\" 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> 由字母 <code>'a'</code>、<code>'b'</code> 和 <code>'c'</code> 组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1004最大连续1的个数 III",
        "hardRate": "MEDIUM",
        "passRate": "59.51%",
        "problemsUrl": "https://leetcode.cn/problems/max-consecutive-ones-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/max-consecutive-ones-iii/solution",
        "problemsDesc": "<p>给定一个二进制数组&nbsp;<code>nums</code>&nbsp;和一个整数 <code>k</code>，如果可以翻转最多 <code>k</code> 个 <code>0</code> ，则返回 <em>数组中连续 <code>1</code> 的最大个数</em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2\n<strong>输出：</strong>6\n<strong>解释：</strong>[1,1,1,0,0,<strong>1</strong>,1,1,1,1,<strong>1</strong>]\n粗体数字从 0 翻转到 1，最长的子数组长度为 6。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3\n<strong>输出：</strong>10\n<strong>解释：</strong>[0,0,1,1,<strong>1</strong>,<strong>1</strong>,1,1,1,<strong>1</strong>,1,1,0,0,0,1,1,1,1]\n粗体数字从 0 翻转到 1，最长的子数组长度为 10。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code>&nbsp;不是&nbsp;<code>0</code>&nbsp;就是&nbsp;<code>1</code></li>\n\t<li><code>0 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1005K 次取反后最大化的数组和",
        "hardRate": "EASY",
        "passRate": "50.84%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，按以下方法修改该数组：</p>\n\n<ul>\n\t<li>选择某个下标 <code>i</code>&nbsp;并将 <code>nums[i]</code> 替换为 <code>-nums[i]</code> 。</li>\n</ul>\n\n<p>重复这个过程恰好 <code>k</code> 次。可以多次选择同一个下标 <code>i</code> 。</p>\n\n<p>以这种方式修改数组后，返回数组 <strong>可能的最大和</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,2,3], k = 1\n<strong>输出：</strong>5\n<strong>解释：</strong>选择下标 1 ，nums 变为 [4,-2,3] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,-1,0,2], k = 3\n<strong>输出：</strong>6\n<strong>解释：</strong>选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,-3,-1,5,-4], k = 2\n<strong>输出：</strong>13\n<strong>解释：</strong>选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1006笨阶乘",
        "hardRate": "MEDIUM",
        "passRate": "62.73%",
        "problemsUrl": "https://leetcode.cn/problems/clumsy-factorial/",
        "solutionsUrl": "https://leetcode.cn/problems/clumsy-factorial/solution",
        "problemsDesc": "<p>通常，正整数 <code>n</code> 的阶乘是所有小于或等于 <code>n</code> 的正整数的乘积。例如，<code>factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1</code>。</p>\n\n<p>相反，我们设计了一个笨阶乘 <code>clumsy</code>：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。</p>\n\n<p>例如，<code>clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1</code>。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。</p>\n\n<p>另外，我们使用的除法是地板除法（<em>floor division</em>），所以&nbsp;<code>10 * 9 / 8</code>&nbsp;等于&nbsp;<code>11</code>。这保证结果是一个整数。</p>\n\n<p>实现上面定义的笨函数：给定一个整数 <code>N</code>，它返回 <code>N</code> 的笨阶乘。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>4\n<strong>输出：</strong>7\n<strong>解释：</strong>7 = 4 * 3 / 2 + 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>10\n<strong>输出：</strong>12\n<strong>解释：</strong>12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= N &lt;= 10000</code></li>\n\t<li><code>-2^31 &lt;= answer &lt;= 2^31 - 1</code>&nbsp; （答案保证符合 32 位整数。）</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1007行相等的最少多米诺旋转",
        "hardRate": "MEDIUM",
        "passRate": "47.78%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-domino-rotations-for-equal-row/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-domino-rotations-for-equal-row/solution",
        "problemsDesc": "<p>在一排多米诺骨牌中，<code>tops[i]</code> 和 <code>bottoms[i]</code>&nbsp;分别代表第 <code>i</code> 个多米诺骨牌的上半部分和下半部分。（一个多米诺是两个从 1 到 6 的数字同列平铺形成的&nbsp;—— 该平铺的每一半上都有一个数字。）</p>\n\n<p>我们可以旋转第&nbsp;<code>i</code>&nbsp;张多米诺，使得 <code>tops[i]</code> 和 <code>bottoms[i]</code>&nbsp;的值交换。</p>\n\n<p>返回能使 <code>tops</code> 中所有值或者 <code>bottoms</code> 中所有值都相同的最小旋转次数。</p>\n\n<p>如果无法做到，返回&nbsp;<code>-1</code>.</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/14/domino.png\" style=\"height: 300px; width: 421px;\" />\n<pre>\n<strong>输入：</strong>tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2]\n<strong>输出：</strong>2\n<strong>解释：</strong> \n图一表示：在我们旋转之前， tops 和 bottoms 给出的多米诺牌。 \n如果我们旋转第二个和第四个多米诺骨牌，我们可以使上面一行中的每个值都等于 2，如图二所示。 \n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>tops = [3,5,1,2,3], bottoms = [3,6,3,3,4]\n<strong>输出：</strong>-1\n<strong>解释：</strong> 在这种情况下，不可能旋转多米诺牌使一行的值相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= tops.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>bottoms.length == tops.length</code></li>\n\t<li><code>1 &lt;= tops[i], bottoms[i] &lt;= 6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1008前序遍历构造二叉搜索树",
        "hardRate": "MEDIUM",
        "passRate": "71.77%",
        "problemsUrl": "https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/solution",
        "problemsDesc": "<p>给定一个整数数组，它表示BST(即 <strong>二叉搜索树</strong> )的 <strong>先</strong><strong>序遍历</strong> ，构造树并返回其根。</p>\n\n<p><strong>保证</strong> 对于给定的测试用例，总是有可能找到具有给定需求的二叉搜索树。</p>\n\n<p><strong>二叉搜索树</strong> 是一棵二叉树，其中每个节点，&nbsp;<code>Node.left</code>&nbsp;的任何后代的值 <strong>严格小于</strong> <code>Node.val</code>&nbsp;,&nbsp;<code>Node.right</code>&nbsp;的任何后代的值 <strong>严格大于</strong> <code>Node.val</code>。</p>\n\n<p>二叉树的 <strong>前序遍历</strong> 首先显示节点的值，然后遍历<code>Node.left</code>，最后遍历<code>Node.right</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2019/03/06/1266.png\" /></p>\n\n<pre>\n<strong>输入：</strong>preorder = [8,5,1,7,10,12]\n<strong>输出：</strong>[8,5,10,1,7,null,12]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> preorder = [1,3]\n<strong>输出:</strong> [1,null,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= preorder.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= preorder[i]&nbsp;&lt;= 10^8</code></li>\n\t<li><code>preorder</code> 中的值 <strong>互不相同</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1009十进制整数的反码",
        "hardRate": "EASY",
        "passRate": "58.62%",
        "problemsUrl": "https://leetcode.cn/problems/complement-of-base-10-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/complement-of-base-10-integer/solution",
        "problemsDesc": "<p>每个非负整数&nbsp;<code>N</code>&nbsp;都有其二进制表示。例如，&nbsp;<code>5</code>&nbsp;可以被表示为二进制&nbsp;<code>&quot;101&quot;</code>，<code>11</code> 可以用二进制&nbsp;<code>&quot;1011&quot;</code>&nbsp;表示，依此类推。注意，除&nbsp;<code>N = 0</code>&nbsp;外，任何二进制表示中都不含前导零。</p>\n\n<p>二进制的反码表示是将每个&nbsp;<code>1</code>&nbsp;改为&nbsp;<code>0</code>&nbsp;且每个&nbsp;<code>0</code>&nbsp;变为&nbsp;<code>1</code>。例如，二进制数&nbsp;<code>&quot;101&quot;</code>&nbsp;的二进制反码为&nbsp;<code>&quot;010&quot;</code>。</p>\n\n<p>给你一个十进制数&nbsp;<code>N</code>，请你返回其二进制表示的反码所对应的十进制整数。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>5\n<strong>输出：</strong>2\n<strong>解释：</strong>5 的二进制表示为 &quot;101&quot;，其二进制反码为 &quot;010&quot;，也就是十进制中的 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>7\n<strong>输出：</strong>0\n<strong>解释：</strong>7 的二进制表示为 &quot;111&quot;，其二进制反码为 &quot;000&quot;，也就是十进制中的 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>10\n<strong>输出：</strong>5\n<strong>解释：</strong>10 的二进制表示为 &quot;1010&quot;，其二进制反码为 &quot;0101&quot;，也就是十进制中的 5 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>0 &lt;= N &lt; 10^9</code></li>\n\t<li>本题与 476：<a href=\"https://leetcode-cn.com/problems/number-complement/\">https://leetcode-cn.com/problems/number-complement/</a> 相同</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1010总持续时间可被 60 整除的歌曲",
        "hardRate": "MEDIUM",
        "passRate": "49.63%",
        "problemsUrl": "https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60/",
        "solutionsUrl": "https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60/solution",
        "problemsDesc": "<p>在歌曲列表中，第 <code>i</code> 首歌曲的持续时间为 <code>time[i]</code> 秒。</p>\n\n<p>返回其总持续时间（以秒为单位）可被 <code>60</code> 整除的歌曲对的数量。形式上，我们希望下标数字 <code>i</code> 和 <code>j</code> 满足&nbsp; <code>i &lt; j</code> 且有&nbsp;<code>(time[i] + time[j]) % 60 == 0</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>time = [30,20,150,100,40]\n<strong>输出：</strong>3\n<strong>解释：</strong>这三对的总持续时间可被 60 整除：\n(time[0] = 30, time[2] = 150): 总持续时间 180\n(time[1] = 20, time[3] = 100): 总持续时间 120\n(time[1] = 20, time[4] = 40): 总持续时间 60\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>time = [60,60,60]\n<strong>输出：</strong>3\n<strong>解释：</strong>所有三对的总持续时间都是 120，可以被 60 整除。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= time.length &lt;= 6 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= time[i] &lt;= 500</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1011在 D 天内送达包裹的能力",
        "hardRate": "MEDIUM",
        "passRate": "62.04%",
        "problemsUrl": "https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/",
        "solutionsUrl": "https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/solution",
        "problemsDesc": "<p>传送带上的包裹必须在 <code>days</code> 天内从一个港口运送到另一个港口。</p>\n\n<p>传送带上的第 <code>i</code>&nbsp;个包裹的重量为&nbsp;<code>weights[i]</code>。每一天，我们都会按给出重量（<code>weights</code>）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p>\n\n<p>返回能在 <code>days</code> 天内将传送带上的所有包裹送达的船的最低运载能力。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>weights = [1,2,3,4,5,6,7,8,9,10], days = 5\n<strong>输出：</strong>15\n<strong>解释：</strong>\n船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：\n第 1 天：1, 2, 3, 4, 5\n第 2 天：6, 7\n第 3 天：8\n第 4 天：9\n第 5 天：10\n\n请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>weights = [3,2,2,4,1,4], days = 3\n<strong>输出：</strong>6\n<strong>解释：</strong>\n船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：\n第 1 天：3, 2\n第 2 天：2, 4\n第 3 天：1, 4\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>weights = [1,2,3,1,1], days = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>\n第 1 天：1\n第 2 天：2\n第 3 天：3\n第 4 天：1, 1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= days &lt;= weights.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= weights[i] &lt;= 500</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1012至少有 1 位重复的数字",
        "hardRate": "HARD",
        "passRate": "52.42%",
        "problemsUrl": "https://leetcode.cn/problems/numbers-with-repeated-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/numbers-with-repeated-digits/solution",
        "problemsDesc": "<p>给定正整数&nbsp;<code>n</code>，返回在<em>&nbsp;</em><code>[1, n]</code><em>&nbsp;</em>范围内具有 <strong>至少 1 位</strong> 重复数字的正整数的个数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 20\n<strong>输出：</strong>1\n<strong>解释：</strong>具有至少 1 位重复数字的正数（&lt;= 20）只有 11 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 100\n<strong>输出：</strong>10\n<strong>解释：</strong>具有至少 1 位重复数字的正数（&lt;= 100）有 11，22，33，44，55，66，77，88，99 和 100 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1000\n<strong>输出：</strong>262\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1013将数组分成和相等的三个部分",
        "hardRate": "EASY",
        "passRate": "38.53%",
        "problemsUrl": "https://leetcode.cn/problems/partition-array-into-three-parts-with-equal-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-array-into-three-parts-with-equal-sum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code>，只有可以将其划分为三个和相等的 <strong>非空</strong> 部分时才返回 <code>true</code>，否则返回 <code>false</code>。</p>\n\n<p>形式上，如果可以找出索引 <code>i + 1 < j</code> 且满足 <code>(arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])</code> 就可以将数组三等分。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,2,1,-6,6,-7,9,1,2,0,1]\n<strong>输出：</strong>true\n<strong>解释：</strong>0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,2,1,-6,6,7,9,-1,2,0,1]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [3,3,6,5,-2,2,5,1,-9,4]\n<strong>输出：</strong>true\n<strong>解释：</strong>3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 <= arr.length <= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= arr[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1014最佳观光组合",
        "hardRate": "MEDIUM",
        "passRate": "57.11%",
        "problemsUrl": "https://leetcode.cn/problems/best-sightseeing-pair/",
        "solutionsUrl": "https://leetcode.cn/problems/best-sightseeing-pair/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>values</code>，其中 <code>values[i]</code> 表示第 <code>i</code> 个观光景点的评分，并且两个景点 <code>i</code> 和 <code>j</code> 之间的 <strong>距离</strong> 为 <code>j - i</code>。</p>\n\n<p>一对景点（<code>i < j</code>）组成的观光组合的得分为 <code>values[i] + values[j] + i - j</code> ，也就是景点的评分之和<strong> 减去 </strong>它们两者之间的距离。</p>\n\n<p>返回一对观光景点能取得的最高分。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>values = [8,1,5,2,6]\n<strong>输出：</strong>11\n<strong>解释：</strong>i = 0, j = 2, values[i] + values[j] + i - j = 8 + 5 + 0 - 2 = 11\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>values = [1,2]\n<strong>输出：</strong>2\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= values.length <= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= values[i] <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1015可被 K 整除的最小整数",
        "hardRate": "MEDIUM",
        "passRate": "46.53%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-integer-divisible-by-k/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-integer-divisible-by-k/solution",
        "problemsDesc": "<p>给定正整数 <code>k</code>&nbsp;，你需要找出可以被 <code>k</code>&nbsp;整除的、仅包含数字 <code><strong>1</strong></code> 的最 <strong>小</strong> 正整数 <code>n</code>&nbsp;的长度。</p>\n\n<p>返回 <code>n</code>&nbsp;的长度。如果不存在这样的 <code>n</code>&nbsp;，就返回-1。</p>\n\n<p><strong>注意：</strong> <code>n</code> 可能不符合 64 位带符号整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>最小的答案是 n = 1，其长度为 1。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 2\n<strong>输出：</strong>-1\n<strong>解释：</strong>不存在可被 2 整除的正整数 n 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>最小的答案是 n = 111，其长度为 3。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1016子串能表示从 1 到 N 数字的二进制串",
        "hardRate": "MEDIUM",
        "passRate": "63.27%",
        "problemsUrl": "https://leetcode.cn/problems/binary-string-with-substrings-representing-1-to-n/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-string-with-substrings-representing-1-to-n/solution",
        "problemsDesc": "<p>给定一个二进制字符串&nbsp;<code>s</code>&nbsp;和一个正整数&nbsp;<code>n</code>，如果对于&nbsp;<code>[1, n]</code>&nbsp;范围内的每个整数，<em>其二进制表示都是&nbsp;<code>s</code> 的 <strong>子字符串</strong> ，就返回 <code>true</code>，否则返回 <code>false</code>&nbsp;</em>。</p>\n\n<p><strong>子字符串</strong>&nbsp;是字符串中连续的字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0110\", n = 3\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0110\", n = 4\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i]</code>&nbsp;不是&nbsp;<code>'0'</code>&nbsp;就是&nbsp;<code>'1'</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1017负二进制转换",
        "hardRate": "MEDIUM",
        "passRate": "65.02%",
        "problemsUrl": "https://leetcode.cn/problems/convert-to-base-2/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-to-base-2/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，以二进制字符串的形式返回该整数的 <strong>负二进制（<code>base -2</code>）</strong>表示。</p>\n\n<p><strong>注意，</strong>除非字符串就是&nbsp;<code>\"0\"</code>，否则返回的字符串中不能含有前导零。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>\"110\"\n<strong>解释：</strong>(-2)<sup>2</sup> + (-2)<sup>1</sup> = 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>\"111\"\n<strong>解释：</strong>(-2)<sup>2</sup> + (-2)<sup>1</sup> + (-2)<sup>0</sup> = 3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>\"100\"\n<strong>解释：</strong>(-2)<sup>2</sup> = 4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1018可被 5 整除的二进制前缀",
        "hardRate": "EASY",
        "passRate": "50.62%",
        "problemsUrl": "https://leetcode.cn/problems/binary-prefix-divisible-by-5/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-prefix-divisible-by-5/solution",
        "problemsDesc": "<p>给定一个二进制数组 <code>nums</code> (&nbsp;<strong>索引从0开始&nbsp;</strong>)。</p>\n\n<p>我们将<code>x<sub>i</sub></code>&nbsp;定义为其二进制表示形式为子数组&nbsp;<code>nums[0..i]</code>&nbsp;(从最高有效位到最低有效位)。</p>\n\n<ul>\n\t<li>例如，如果 <code>nums =[1,0,1]</code> ，那么&nbsp;<code>x<sub>0</sub>&nbsp;= 1</code>,&nbsp;<code>x<sub>1</sub>&nbsp;= 2</code>, 和&nbsp;<code>x<sub>2</sub>&nbsp;= 5</code>。</li>\n</ul>\n\n<p>返回布尔值列表&nbsp;<code>answer</code>，只有当&nbsp;<code>x<sub>i</sub></code><em>&nbsp;</em>可以被 <code>5</code>&nbsp;整除时，答案&nbsp;<code>answer[i]</code> 为&nbsp;<code>true</code>，否则为 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,1]\n<strong>输出：</strong>[true,false,false]\n<strong>解释：</strong>\n输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1]\n<strong>输出：</strong>[false,false,false]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code><sup>&nbsp;</sup></li>\n\t<li><code>nums[i]</code>&nbsp;仅为&nbsp;<code>0</code>&nbsp;或&nbsp;<code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1019链表中的下一个更大节点",
        "hardRate": "MEDIUM",
        "passRate": "64.23%",
        "problemsUrl": "https://leetcode.cn/problems/next-greater-node-in-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/next-greater-node-in-linked-list/solution",
        "problemsDesc": "<p>给定一个长度为&nbsp;<code>n</code>&nbsp;的链表&nbsp;<code>head</code></p>\n\n<p>对于列表中的每个节点，查找下一个 <strong>更大节点</strong> 的值。也就是说，对于每个节点，找到它旁边的第一个节点的值，这个节点的值 <strong>严格大于</strong> 它的值。</p>\n\n<p>返回一个整数数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 <code>i</code> 个节点( <strong>从1开始</strong> )的下一个更大的节点的值。如果第 <code>i</code> 个节点没有下一个更大的节点，设置&nbsp;<code>answer[i] = 0</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/05/linkedlistnext1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [2,1,5]\n<strong>输出：</strong>[5,5,0]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/05/linkedlistnext2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [2,7,4,3,5]\n<strong>输出：</strong>[7,0,5,5,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点数为&nbsp;<code>n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1020飞地的数量",
        "hardRate": "MEDIUM",
        "passRate": "62.35%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-enclaves/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-enclaves/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> ，其中 <code>0</code> 表示一个海洋单元格、<code>1</code> 表示一个陆地单元格。</p>\n\n<p>一次 <strong>移动</strong> 是指从一个陆地单元格走到另一个相邻（<strong>上、下、左、右</strong>）的陆地单元格或跨过 <code>grid</code> 的边界。</p>\n\n<p>返回网格中<strong> 无法 </strong>在任意次数的移动中离开网格边界的陆地单元格的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/enclaves1.jpg\" style=\"height: 200px; width: 200px;\" />\n<pre>\n<strong>输入：</strong>grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]\n<strong>输出：</strong>3\n<strong>解释：</strong>有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/enclaves2.jpg\" style=\"height: 200px; width: 200px;\" />\n<pre>\n<strong>输入：</strong>grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]\n<strong>输出：</strong>0\n<strong>解释：</strong>所有 1 都在边界上或可以到达边界。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>grid[i][j]</code> 的值为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1021删除最外层的括号",
        "hardRate": "EASY",
        "passRate": "81.39%",
        "problemsUrl": "https://leetcode.cn/problems/remove-outermost-parentheses/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-outermost-parentheses/solution",
        "problemsDesc": "<p>有效括号字符串为空 <code>\"\"</code>、<code>\"(\" + A + \")\"</code> 或 <code>A + B</code> ，其中 <code>A</code> 和 <code>B</code> 都是有效的括号字符串，<code>+</code> 代表字符串的连接。</p>\n\n<ul>\n\t<li>例如，<code>\"\"</code>，<code>\"()\"</code>，<code>\"(())()\"</code> 和 <code>\"(()(()))\"</code> 都是有效的括号字符串。</li>\n</ul>\n\n<p>如果有效字符串 <code>s</code> 非空，且不存在将其拆分为 <code>s = A + B</code> 的方法，我们称其为<strong>原语（primitive）</strong>，其中 <code>A</code> 和 <code>B</code> 都是非空有效括号字符串。</p>\n\n<p>给出一个非空有效字符串 <code>s</code>，考虑将其进行原语化分解，使得：<code>s = P_1 + P_2 + ... + P_k</code>，其中 <code>P_i</code> 是有效括号字符串原语。</p>\n\n<p>对 <code>s</code> 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 <code>s</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(()())(())\"\n<strong>输出：</strong>\"()()()\"\n<strong>解释：\n</strong>输入字符串为 \"(()())(())\"，原语化分解得到 \"(()())\" + \"(())\"，\n删除每个部分中的最外层括号后得到 \"()()\" + \"()\" = \"()()()\"。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(()())(())(()(()))\"\n<strong>输出：</strong>\"()()()()(())\"\n<strong>解释：</strong>\n输入字符串为 \"(()())(())(()(()))\"，原语化分解得到 \"(()())\" + \"(())\" + \"(()(()))\"，\n删除每个部分中的最外层括号后得到 \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\"。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"()()\"\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>\n输入字符串为 \"()()\"，原语化分解得到 \"()\" + \"()\"，\n删除每个部分中的最外层括号后得到 \"\" + \"\" = \"\"。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 为 <code>'('</code> 或 <code>')'</code></li>\n\t<li><code>s</code> 是一个有效括号字符串</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1022从根到叶的二进制数之和",
        "hardRate": "EASY",
        "passRate": "74.78%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/solution",
        "problemsDesc": "<p>给出一棵二叉树，其上每个结点的值都是&nbsp;<code>0</code>&nbsp;或&nbsp;<code>1</code>&nbsp;。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。</p>\n\n<ul>\n\t<li>例如，如果路径为&nbsp;<code>0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1</code>，那么它表示二进制数&nbsp;<code>01101</code>，也就是&nbsp;<code>13</code>&nbsp;。</li>\n</ul>\n\n<p>对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。</p>\n\n<p>返回这些数字之和。题目数据保证答案是一个 <strong>32 位 </strong>整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/04/04/sum-of-root-to-leaf-binary-numbers.png\" />\n<pre>\n<strong>输入：</strong>root = [1,0,1,0,1,0,1]\n<strong>输出：</strong>22\n<strong>解释：</strong>(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [0]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数在&nbsp;<code>[1, 1000]</code>&nbsp;范围内</li>\n\t<li><code>Node.val</code>&nbsp;仅为 <code>0</code> 或 <code>1</code>&nbsp;</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1023驼峰式匹配",
        "hardRate": "MEDIUM",
        "passRate": "64.57%",
        "problemsUrl": "https://leetcode.cn/problems/camelcase-matching/",
        "solutionsUrl": "https://leetcode.cn/problems/camelcase-matching/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>queries</code>，和一个表示模式的字符串&nbsp;<code>pattern</code>，请你返回一个布尔数组 <code>answer</code> 。只有在待查项&nbsp;<code>queries[i]</code> 与模式串&nbsp;<code>pattern</code> 匹配时，&nbsp;<code>answer[i]</code>&nbsp;才为 <code>true</code>，否则为 <code>false</code>。</p>\n\n<p>如果可以将<strong>小写字母</strong>插入模式串&nbsp;<code>pattern</code>&nbsp;得到待查询项&nbsp;<code>query</code>，那么待查询项与给定模式串匹配。可以在任何位置插入每个字符，也可以不插入字符。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>queries = [\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"], pattern = \"FB\"\n<strong>输出：</strong>[true,false,true,true,false]\n<strong>示例：</strong>\n\"FooBar\" 可以这样生成：\"F\" + \"oo\" + \"B\" + \"ar\"。\n\"FootBall\" 可以这样生成：\"F\" + \"oot\" + \"B\" + \"all\".\n\"FrameBuffer\" 可以这样生成：\"F\" + \"rame\" + \"B\" + \"uffer\".</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>queries = [\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"], pattern = \"FoBa\"\n<strong>输出：</strong>[true,false,true,false,false]\n<strong>解释：</strong>\n\"FooBar\" 可以这样生成：\"Fo\" + \"o\" + \"Ba\" + \"r\".\n\"FootBall\" 可以这样生成：\"Fo\" + \"ot\" + \"Ba\" + \"ll\".\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>queries = [\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"], pattern = \"FoBaT\"\n<strong>输出：</strong>[false,true,false,false,false]\n<strong>解释： </strong>\n\"FooBarTest\" 可以这样生成：\"Fo\" + \"o\" + \"Ba\" + \"r\" + \"T\" + \"est\".\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pattern.length, queries.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= queries[i].length &lt;= 100</code></li>\n\t<li><code>queries[i]</code> 和 <code>pattern</code> 由英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1024视频拼接",
        "hardRate": "MEDIUM",
        "passRate": "53.12%",
        "problemsUrl": "https://leetcode.cn/problems/video-stitching/",
        "solutionsUrl": "https://leetcode.cn/problems/video-stitching/solution",
        "problemsDesc": "<p>你将会获得一系列视频片段，这些片段来自于一项持续时长为&nbsp;<code>time</code>&nbsp;秒的体育赛事。这些片段可能有所重叠，也可能长度不一。</p>\n\n<p>使用数组&nbsp;<code>clips</code> 描述所有的视频片段，其中 <code>clips[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 表示：某个视频片段开始于&nbsp;<code>start<sub>i</sub></code>&nbsp;并于&nbsp;<code>end<sub>i</sub></code>&nbsp;结束。</p>\n\n<p>甚至可以对这些片段自由地再剪辑：</p>\n\n<ul>\n\t<li>例如，片段&nbsp;<code>[0, 7]</code>&nbsp;可以剪切成&nbsp;<code>[0, 1] +&nbsp;[1, 3] + [3, 7]</code>&nbsp;三部分。</li>\n</ul>\n\n<p>我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（<code>[0, time]</code>）。返回所需片段的最小数目，如果无法完成该任务，则返回&nbsp;<code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10\n<strong>输出：</strong>3\n<strong>解释：</strong>\n选中 [0,2], [8,10], [1,9] 这三个片段。\n然后，按下面的方案重制比赛片段：\n将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。\n现在手上的片段为 [0,2] + [2,8] + [8,10]，而这些覆盖了整场比赛 [0, 10]。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>clips = [[0,1],[1,2]], time = 5\n<strong>输出：</strong>-1\n<strong>解释：</strong>\n无法只用 [0,1] 和 [1,2] 覆盖 [0,5] 的整个过程。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], time = 9\n<strong>输出：</strong>3\n<strong>解释： </strong>\n选取片段 [0,4], [4,7] 和 [6,9] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= clips.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 100</code></li>\n\t<li><code>1 &lt;= time &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1025除数博弈",
        "hardRate": "EASY",
        "passRate": "70.66%",
        "problemsUrl": "https://leetcode.cn/problems/divisor-game/",
        "solutionsUrl": "https://leetcode.cn/problems/divisor-game/solution",
        "problemsDesc": "<p>爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。</p>\n\n<p>最初，黑板上有一个数字&nbsp;<code>n</code>&nbsp;。在每个玩家的回合，玩家需要执行以下操作：</p>\n\n<ul>\n\t<li>选出任一&nbsp;<code>x</code>，满足&nbsp;<code>0 &lt; x &lt; n</code>&nbsp;且&nbsp;<code>n % x == 0</code>&nbsp;。</li>\n\t<li>用 <code>n - x</code>&nbsp;替换黑板上的数字&nbsp;<code>n</code> 。</li>\n</ul>\n\n<p>如果玩家无法执行这些操作，就会输掉游戏。</p>\n\n<p><em>只有在爱丽丝在游戏中取得胜利时才返回&nbsp;<code>true</code>&nbsp;。假设两个玩家都以最佳状态参与游戏。</em></p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>爱丽丝选择 1，鲍勃无法进行操作。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>false\n<strong>解释：</strong>爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1026节点与其祖先之间的最大差值",
        "hardRate": "MEDIUM",
        "passRate": "75.16%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/solution",
        "problemsDesc": "<p>给定二叉树的根节点 <code>root</code>，找出存在于 <strong>不同</strong> 节点 <code>A</code> 和 <code>B</code> 之间的最大值 <code>V</code>，其中 <code>V = |A.val - B.val|</code>，且 <code>A</code> 是 <code>B</code> 的祖先。</p>\n\n<p>（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/09/tmp-tree.jpg\" style=\"width: 400px; height: 390px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [8,3,10,1,6,null,14,null,null,4,7,13]\n<strong>输出：</strong>7\n<strong>解释： </strong>\n我们有大量的节点与其祖先的差值，其中一些如下：\n|8 - 3| = 5\n|3 - 7| = 4\n|8 - 1| = 7\n|10 - 13| = 3\n在所有可能的差值中，最大值 7 由 |8 - 1| = 7 得出。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/09/tmp-tree-1.jpg\" style=\"width: 250px; height: 349px;\" />\n<pre>\n<strong>输入：</strong>root = [1,null,2,null,0,3]\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数在 <code>2</code> 到 <code>5000</code> 之间。</li>\n\t<li><code>0 <= Node.val <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1027最长等差数列",
        "hardRate": "MEDIUM",
        "passRate": "49.40%",
        "problemsUrl": "https://leetcode.cn/problems/longest-arithmetic-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-arithmetic-subsequence/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>，返回 <code>nums</code>&nbsp;中最长等差子序列的<strong>长度</strong>。</p>\n\n<p>回想一下，<code>nums</code> 的子序列是一个列表&nbsp;<code>nums[i<sub>1</sub>], nums[i<sub>2</sub>], ..., nums[i<sub>k</sub>]</code> ，且&nbsp;<code>0 &lt;= i<sub>1</sub> &lt; i<sub>2</sub> &lt; ... &lt; i<sub>k</sub> &lt;= nums.length - 1</code>。并且如果&nbsp;<code>seq[i+1] - seq[i]</code>(&nbsp;<code>0 &lt;= i &lt; seq.length - 1</code>) 的值都相同，那么序列&nbsp;<code>seq</code>&nbsp;是等差的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,6,9,12]\n<strong>输出：</strong>4\n<strong>解释： </strong>\n整个数组是公差为 3 的等差数列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [9,4,7,2,10]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n最长的等差子序列是 [4,7,10]。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [20,1,15,3,10,5,8]\n<strong>输出：</strong>4\n<strong>解释：</strong>\n最长的等差子序列是 [20,15,10,5]。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 500</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1028从先序遍历还原二叉树",
        "hardRate": "HARD",
        "passRate": "72.87%",
        "problemsUrl": "https://leetcode.cn/problems/recover-a-tree-from-preorder-traversal/",
        "solutionsUrl": "https://leetcode.cn/problems/recover-a-tree-from-preorder-traversal/solution",
        "problemsDesc": "<p>我们从二叉树的根节点 <code>root</code>&nbsp;开始进行深度优先搜索。</p>\n\n<p>在遍历中的每个节点处，我们输出&nbsp;<code>D</code>&nbsp;条短划线（其中&nbsp;<code>D</code>&nbsp;是该节点的深度），然后输出该节点的值。（<em>如果节点的深度为 <code>D</code>，则其直接子节点的深度为 <code>D + 1</code>。根节点的深度为 <code>0</code>）。</em></p>\n\n<p>如果节点只有一个子节点，那么保证该子节点为左子节点。</p>\n\n<p>给出遍历输出&nbsp;<code>S</code>，还原树并返回其根节点&nbsp;<code>root</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/12/recover-a-tree-from-preorder-traversal.png\" style=\"height: 200px; width: 320px;\"></strong></p>\n\n<pre><strong>输入：</strong>&quot;1-2--3--4-5--6--7&quot;\n<strong>输出：</strong>[1,2,5,3,4,6,7]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/12/screen-shot-2019-04-10-at-114101-pm.png\" style=\"height: 250px; width: 256px;\"></strong></p>\n\n<pre><strong>输入：</strong>&quot;1-2--3---4-5--6---7&quot;\n<strong>输出：</strong>[1,2,5,3,null,6,null,4,null,7]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/12/screen-shot-2019-04-10-at-114955-pm.png\" style=\"height: 250px; width: 276px;\"></p>\n\n<pre><strong>输入：</strong>&quot;1-401--349---90--88&quot;\n<strong>输出：</strong>[1,401,null,349,88,90]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>原始树中的节点数介于 <code>1</code> 和 <code>1000</code> 之间。</li>\n\t<li>每个节点的值介于 <code>1</code> 和 <code>10 ^ 9</code> 之间。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1029两地调度",
        "hardRate": "MEDIUM",
        "passRate": "68.77%",
        "problemsUrl": "https://leetcode.cn/problems/two-city-scheduling/",
        "solutionsUrl": "https://leetcode.cn/problems/two-city-scheduling/solution",
        "problemsDesc": "<p>公司计划面试 <code>2n</code> 人。给你一个数组 <code>costs</code> ，其中 <code>costs[i] = [aCost<sub>i</sub>, bCost<sub>i</sub>]</code> 。第 <code>i</code> 人飞往 <code>a</code> 市的费用为 <code>aCost<sub>i</sub></code> ，飞往 <code>b</code> 市的费用为 <code>bCost<sub>i</sub></code> 。</p>\n\n<p>返回将每个人都飞到 <code>a</code> 、<code>b</code> 中某座城市的最低费用，要求每个城市都有 <code>n</code> 人抵达<strong>。</strong></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>costs = [[10,20],[30,200],[400,50],[30,20]]\n<strong>输出：</strong>110\n<strong>解释：</strong>\n第一个人去 a 市，费用为 10。\n第二个人去 a 市，费用为 30。\n第三个人去 b 市，费用为 50。\n第四个人去 b 市，费用为 20。\n\n最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>costs = [[259,770],[448,54],[926,667],[184,139],[840,118],[577,469]]\n<strong>输出：</strong>1859\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>costs = [[515,563],[451,713],[537,709],[343,819],[855,779],[457,60],[650,359],[631,42]]\n<strong>输出：</strong>3086\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 * n == costs.length</code></li>\n\t<li><code>2 <= costs.length <= 100</code></li>\n\t<li><code>costs.length</code> 为偶数</li>\n\t<li><code>1 <= aCost<sub>i</sub>, bCost<sub>i</sub> <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1030距离顺序排列矩阵单元格",
        "hardRate": "EASY",
        "passRate": "70.61%",
        "problemsUrl": "https://leetcode.cn/problems/matrix-cells-in-distance-order/",
        "solutionsUrl": "https://leetcode.cn/problems/matrix-cells-in-distance-order/solution",
        "problemsDesc": "<p>给定四个整数 <code>rows</code>&nbsp;,&nbsp; &nbsp;<code>cols</code> ,&nbsp; <code>rCenter</code> 和 <code>cCenter</code> 。有一个&nbsp;<code>rows x cols</code>&nbsp;的矩阵，你在单元格上的坐标是&nbsp;<code>(rCenter, cCenter)</code> 。</p>\n\n<p>返回矩阵中的所有单元格的坐标，并按与<em>&nbsp;</em><code>(rCenter, cCenter)</code><em>&nbsp;</em>的 <strong>距离</strong> 从最小到最大的顺序排。你可以按 <strong>任何</strong> 满足此条件的顺序返回答案。</p>\n\n<p>单元格<code>(r1, c1)</code> 和 <code>(r2, c2)</code> 之间的距离为<code>|r1 - r2| + |c1 - c2|</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rows = 1, cols = 2, rCenter = 0, cCenter = 0\n<strong>输出：</strong>[[0,0],[0,1]]\n<strong>解释</strong>：从 (r0, c0) 到其他单元格的距离为：[0,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rows = 2, cols = 2, rCenter = 0, cCenter = 1\n<strong>输出：</strong>[[0,1],[0,0],[1,1],[1,0]]\n<strong>解释</strong>：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2]\n[[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>rows = 2, cols = 3, rCenter = 1, cCenter = 2\n<strong>输出：</strong>[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]\n<strong>解释</strong>：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3]\n其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rows, cols &lt;= 100</code></li>\n\t<li><code>0 &lt;= rCenter &lt; rows</code></li>\n\t<li><code>0 &lt;= cCenter &lt; cols</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1031两个非重叠子数组的最大和",
        "hardRate": "MEDIUM",
        "passRate": "65.57%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-of-two-non-overlapping-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-of-two-non-overlapping-subarrays/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和两个整数 <code>firstLen</code> 和 <code>secondLen</code>，请你找出并返回两个非重叠<strong> 子数组 </strong>中元素的最大和<em>，</em>长度分别为 <code>firstLen</code> 和 <code>secondLen</code> 。</p>\n\n<p>长度为 <code>firstLen</code> 的子数组可以出现在长为 <code>secondLen</code> 的子数组之前或之后，但二者必须是不重叠的。</p>\n\n<p>子数组是数组的一个 <strong>连续</strong> 部分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,6,5,2,2,5,1,9,4], firstLen = 1, secondLen = 2\n<strong>输出：</strong>20\n<strong>解释：</strong>子数组的一种选择中，[9] 长度为 1，[6,5] 长度为 2。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,8,1,3,2,1,8,9,0], firstLen = 3, secondLen = 2\n<strong>输出：</strong>29\n<strong>解释：</strong>子数组的一种选择中，[3,8,1] 长度为 3，[8,9] 长度为 2。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,5,6,0,9,5,0,3,8], firstLen = 4, secondLen = 3\n<strong>输出：</strong>31\n<strong>解释：</strong>子数组的一种选择中，[5,6,0,9] 长度为 4，[0,3,8] 长度为 3。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= firstLen, secondLen &lt;= 1000</code></li>\n\t<li><code>2 &lt;= firstLen + secondLen &lt;= 1000</code></li>\n\t<li><code>firstLen + secondLen &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1032字符流",
        "hardRate": "HARD",
        "passRate": "56.59%",
        "problemsUrl": "https://leetcode.cn/problems/stream-of-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/stream-of-characters/solution",
        "problemsDesc": "<p>设计一个算法：接收一个字符流，并检查这些字符的后缀是否是字符串数组 <code>words</code> 中的一个字符串。</p>\n\n<p>例如，<code>words = [\"abc\", \"xyz\"]</code> 且字符流中逐个依次加入 4 个字符 <code>'a'</code>、<code>'x'</code>、<code>'y'</code> 和 <code>'z'</code> ，你所设计的算法应当可以检测到&nbsp;<code>\"axyz\"</code> 的后缀 <code>\"xyz\"</code> 与&nbsp;<code>words</code> 中的字符串 <code>\"xyz\"</code> 匹配。</p>\n\n<p>按下述要求实现 <code>StreamChecker</code> 类：</p>\n\n<ul>\n\t<li><code>StreamChecker(String[] words)</code> ：构造函数，用字符串数组&nbsp;<code>words</code> 初始化数据结构。</li>\n\t<li><code>boolean query(char letter)</code>：从字符流中接收一个新字符，如果字符流中的任一非空后缀能匹配 <code>words</code> 中的某一字符串，返回 <code>true</code> ；否则，返回 <code>false</code>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"StreamChecker\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\"]\n[[[\"cd\", \"f\", \"kl\"]], [\"a\"], [\"b\"], [\"c\"], [\"d\"], [\"e\"], [\"f\"], [\"g\"], [\"h\"], [\"i\"], [\"j\"], [\"k\"], [\"l\"]]\n<strong>输出：</strong>\n[null, false, false, false, true, false, true, false, false, false, false, false, true]\n\n<strong>解释：</strong>\nStreamChecker streamChecker = new StreamChecker([\"cd\", \"f\", \"kl\"]);\nstreamChecker.query(\"a\"); // 返回 False\nstreamChecker.query(\"b\"); // 返回 False\nstreamChecker.query(\"c\"); // 返回n False\nstreamChecker.query(\"d\"); // 返回 True ，因为 'cd' 在 words 中\nstreamChecker.query(\"e\"); // 返回 False\nstreamChecker.query(\"f\"); // 返回 True ，因为 'f' 在 words 中\nstreamChecker.query(\"g\"); // 返回 False\nstreamChecker.query(\"h\"); // 返回 False\nstreamChecker.query(\"i\"); // 返回 False\nstreamChecker.query(\"j\"); // 返回 False\nstreamChecker.query(\"k\"); // 返回 False\nstreamChecker.query(\"l\"); // 返回 True ，因为 'kl' 在 words 中\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 2000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 200</code></li>\n\t<li><code>words[i]</code> 由小写英文字母组成</li>\n\t<li><code>letter</code> 是一个小写英文字母</li>\n\t<li>最多调用查询 <code>4 * 10<sup>4</sup></code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1033移动石子直到连续",
        "hardRate": "MEDIUM",
        "passRate": "49.31%",
        "problemsUrl": "https://leetcode.cn/problems/moving-stones-until-consecutive/",
        "solutionsUrl": "https://leetcode.cn/problems/moving-stones-until-consecutive/solution",
        "problemsDesc": "<p>三枚石子放置在数轴上，位置分别为 <code>a</code>，<code>b</code>，<code>c</code>。</p>\n\n<p>每一回合，你可以从两端之一拿起一枚石子（位置最大或最小），并将其放入两端之间的任一空闲位置。形式上，假设这三枚石子当前分别位于位置 <code>x, y, z</code> 且 <code>x < y < z</code>。那么就可以从位置 <code>x</code> 或者是位置 <code>z</code> 拿起一枚石子，并将该石子移动到某一整数位置 <code>k</code> 处，其中 <code>x < k < z</code> 且 <code>k != y</code>。</p>\n\n<p>当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。</p>\n\n<p>要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：<code>answer = [minimum_moves, maximum_moves]</code></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 1, b = 2, c = 5\n<strong>输出：</strong>[1, 2]\n<strong>解释：</strong>将石子从 5 移动到 4 再移动到 3，或者我们可以直接将石子移动到 3。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 4, b = 3, c = 2\n<strong>输出：</strong>[0, 0]\n<strong>解释：</strong>我们无法进行任何移动。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 <= a <= 100</code></li>\n\t<li><code>1 <= b <= 100</code></li>\n\t<li><code>1 <= c <= 100</code></li>\n\t<li><code>a != b, b != c, c != a</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1034边界着色",
        "hardRate": "MEDIUM",
        "passRate": "55.13%",
        "problemsUrl": "https://leetcode.cn/problems/coloring-a-border/",
        "solutionsUrl": "https://leetcode.cn/problems/coloring-a-border/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的整数矩阵 <code>grid</code> ，表示一个网格。另给你三个整数&nbsp;<code>row</code>、<code>col</code> 和 <code>color</code> 。网格中的每个值表示该位置处的网格块的颜色。</p>\n\n<p>如果两个方块在任意 4 个方向上相邻，则称它们&nbsp;<strong>相邻 </strong>。</p>\n\n<p>如果两个方块具有相同的颜色且相邻，它们则属于同一个 <strong>连通分量</strong> 。</p>\n\n<p><strong>连通分量的边界</strong><strong> </strong>是指连通分量中满足下述条件之一的所有网格块：</p>\n\n<ul>\n\t<li>在上、下、左、右任意一个方向上与不属于同一连通分量的网格块相邻</li>\n\t<li>在网格的边界上（第一行/列或最后一行/列）</li>\n</ul>\n\n<p>请你使用指定颜色&nbsp;<code>color</code> 为所有包含网格块&nbsp;<code>grid[row][col]</code> 的 <strong>连通分量的边界</strong> 进行着色。</p>\n\n<p>并返回最终的网格&nbsp;<code>grid</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,1],[1,2]], row = 0, col = 0, color = 3\n<strong>输出：</strong>[[3,3],[3,2]]</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3\n<strong>输出：</strong>[[1,3,3],[2,3,3]]</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2\n<strong>输出：</strong>[[2,2,2],[2,1,2],[2,2,2]]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>1 &lt;= grid[i][j], color &lt;= 1000</code></li>\n\t<li><code>0 &lt;= row &lt; m</code></li>\n\t<li><code>0 &lt;= col &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1035不相交的线",
        "hardRate": "MEDIUM",
        "passRate": "70.29%",
        "problemsUrl": "https://leetcode.cn/problems/uncrossed-lines/",
        "solutionsUrl": "https://leetcode.cn/problems/uncrossed-lines/solution",
        "problemsDesc": "<p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数。</p>\n\n<p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code>&nbsp;和 <code>nums2[j]</code>&nbsp;的直线，这些直线需要同时满足满足：</p>\n\n<ul>\n\t<li>&nbsp;<code>nums1[i] == nums2[j]</code></li>\n\t<li>且绘制的直线不与任何其他连线（非水平线）相交。</li>\n</ul>\n\n<p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p>\n\n<p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/04/26/142.png\" style=\"width: 400px; height: 286px;\" />\n<pre>\n<strong>输入：</strong>nums1 = <span id=\"example-input-1-1\">[1,4,2]</span>, nums2 = <span id=\"example-input-1-2\">[1,2,4]</span>\n<strong>输出：</strong><span id=\"example-output-1\">2</span>\n<strong>解释：</strong>可以画出两条不交叉的线，如上图所示。 \n但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。\n</pre>\n\n<div>\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = <span id=\"example-input-2-1\">[2,5,1,2,5]</span>, nums2 = <span id=\"example-input-2-2\">[10,5,2,1,5,2]</span>\n<strong>输出：</strong><span id=\"example-output-2\">3</span>\n</pre>\n\n<div>\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = <span id=\"example-input-3-1\">[1,3,7,1,7,5]</span>, nums2 = <span id=\"example-input-3-2\">[1,9,2,5,1]</span>\n<strong>输出：</strong><span id=\"example-output-3\">2</span></pre>\n\n<p>&nbsp;</p>\n</div>\n</div>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[j] &lt;= 2000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1036逃离大迷宫",
        "hardRate": "HARD",
        "passRate": "46.81%",
        "problemsUrl": "https://leetcode.cn/problems/escape-a-large-maze/",
        "solutionsUrl": "https://leetcode.cn/problems/escape-a-large-maze/solution",
        "problemsDesc": "<p>在一个 10<sup>6</sup> x 10<sup>6</sup> 的网格中，每个网格上方格的坐标为 <code>(x, y)</code> 。</p>\n\n<p>现在从源方格 <code>source = [s<sub>x</sub>, s<sub>y</sub>]</code> 开始出发，意图赶往目标方格 <code>target = [t<sub>x</sub>, t<sub>y</sub>]</code> 。数组 <code>blocked</code> 是封锁的方格列表，其中每个 <code>blocked[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示坐标为 <code>(x<sub>i</sub>, y<sub>i</sub>)</code> 的方格是禁止通行的。</p>\n\n<p>每次移动，都可以走到网格中在四个方向上相邻的方格，只要该方格 <strong>不</strong> 在给出的封锁列表 <code>blocked</code> 上。同时，不允许走出网格。</p>\n\n<p>只有在可以通过一系列的移动从源方格 <code>source</code> 到达目标方格 <code>target</code> 时才返回 <code>true</code>。否则，返回 <code>false</code>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]\n<strong>输出：</strong>false\n<strong>解释：</strong>\n从源方格无法到达目标方格，因为我们无法在网格中移动。\n无法向北或者向东移动是因为方格禁止通行。\n无法向南或者向西移动是因为不能走出网格。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>blocked = [], source = [0,0], target = [999999,999999]\n<strong>输出：</strong>true\n<strong>解释：</strong>\n因为没有方格被封锁，所以一定可以到达目标方格。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= blocked.length <= 200</code></li>\n\t<li><code>blocked[i].length == 2</code></li>\n\t<li><code>0 <= x<sub>i</sub>, y<sub>i</sub> < 10<sup>6</sup></code></li>\n\t<li><code>source.length == target.length == 2</code></li>\n\t<li><code>0 <= s<sub>x</sub>, s<sub>y</sub>, t<sub>x</sub>, t<sub>y</sub> < 10<sup>6</sup></code></li>\n\t<li><code>source != target</code></li>\n\t<li>题目数据保证 <code>source</code> 和 <code>target</code> 不在封锁列表内</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1037有效的回旋镖",
        "hardRate": "EASY",
        "passRate": "48.54%",
        "problemsUrl": "https://leetcode.cn/problems/valid-boomerang/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-boomerang/solution",
        "problemsDesc": "<p>给定一个数组<meta charset=\"UTF-8\" />&nbsp;<code>points</code>&nbsp;，其中<meta charset=\"UTF-8\" />&nbsp;<code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;表示 <strong>X-Y</strong> 平面上的一个点，<em>如果这些点构成一个&nbsp;</em><strong>回旋镖</strong>&nbsp;则返回&nbsp;<code>true</code>&nbsp;。</p>\n\n<p><strong>回旋镖</strong>&nbsp;定义为一组三个点，这些点&nbsp;<strong>各不相同</strong>&nbsp;且&nbsp;<strong>不在一条直线上</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[1,1],[2,3],[3,2]]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[1,1],[2,2],[3,3]]\n<strong>输出：</strong>false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>points.length == 3</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1038从二叉搜索树到更大和树",
        "hardRate": "MEDIUM",
        "passRate": "81.30%",
        "problemsUrl": "https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/solution",
        "problemsDesc": "<p><span style=\"font-size:10.5pt\"><span style=\"font-family:Calibri\"><span style=\"font-size:10.5000pt\"><span style=\"font-family:宋体\"><font face=\"宋体\">给定一个二叉搜索树</font></span></span></span></span>&nbsp;<code>root</code>&nbsp;(BST)<span style=\"font-size:10.5pt\"><span style=\"font-family:Calibri\"><span style=\"font-size:10.5000pt\"><span style=\"font-family:宋体\"><font face=\"宋体\">，请将它的每个</font></span></span></span></span>节点<span style=\"font-size:10.5pt\"><span style=\"font-family:Calibri\"><span style=\"font-size:10.5000pt\"><span style=\"font-family:宋体\"><font face=\"宋体\">的值替换成树中大于或者等于该</font></span></span></span></span>节点<span style=\"font-size:10.5pt\"><span style=\"font-family:Calibri\"><span style=\"font-size:10.5000pt\"><span style=\"font-family:宋体\"><font face=\"宋体\">值的所有</font></span></span></span></span>节点<span style=\"font-size:10.5pt\"><span style=\"font-family:Calibri\"><span style=\"font-size:10.5000pt\"><span style=\"font-family:宋体\"><font face=\"宋体\">值之和。</font></span></span></span></span></p>\n\n<p>提醒一下， <em>二叉搜索树</em> 满足下列约束条件：</p>\n\n<ul>\n\t<li>节点的左子树仅包含键<strong> 小于 </strong>节点键的节点。</li>\n\t<li>节点的右子树仅包含键<strong> 大于</strong> 节点键的节点。</li>\n\t<li>左右子树也必须是二叉搜索树。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png\" style=\"height:273px; width:400px\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n<strong>输出：</strong>[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [0,null,1]\n<strong>输出：</strong>[1,null,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数在&nbsp;<code>[1, 100]</code>&nbsp;范围内。</li>\n\t<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n\t<li>树中的所有值均 <strong>不重复</strong>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>该题目与 538:&nbsp;<a href=\"https://leetcode-cn.com/problems/convert-bst-to-greater-tree/\">https://leetcode-cn.com/problems/convert-bst-to-greater-tree/&nbsp; </a>相同</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1039多边形三角剖分的最低得分",
        "hardRate": "MEDIUM",
        "passRate": "64.49%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/solution",
        "problemsDesc": "<p>你有一个凸的<meta charset=\"UTF-8\" />&nbsp;<code>n</code>&nbsp;边形，其每个顶点都有一个整数值。给定一个整数数组<meta charset=\"UTF-8\" />&nbsp;<code>values</code>&nbsp;，其中<meta charset=\"UTF-8\" />&nbsp;<code>values[i]</code>&nbsp;是第 <code>i</code> 个顶点的值（即 <strong>顺时针顺序</strong> ）。</p>\n\n<p>假设将多边形 <strong>剖分</strong>&nbsp;为 <code>n - 2</code>&nbsp;个三角形。对于每个三角形，该三角形的值是顶点标记的<strong>乘积</strong>，三角剖分的分数是进行三角剖分后所有 <code>n - 2</code>&nbsp;个三角形的值之和。</p>\n\n<p>返回 <em>多边形进行三角剖分后可以得到的最低分</em> 。<br />\n&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/25/shape1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>values = [1,2,3]\n<strong>输出：</strong>6\n<strong>解释：</strong>多边形已经三角化，唯一三角形的分数为 6。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/25/shape2.jpg\" style=\"height: 163px; width: 446px;\" /></p>\n\n<pre>\n<strong>输入：</strong>values = [3,7,4,5]\n<strong>输出：</strong>144\n<strong>解释：</strong>有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 = 245，或 3*4*5 + 3*4*7 = 144。最低分数为 144。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/25/shape3.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>values = [1,3,1,4,1,5]\n<strong>输出：</strong>13\n<strong>解释：</strong>最低分数三角剖分的得分情况为 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == values.length</code></li>\n\t<li><code>3 &lt;= n &lt;= 50</code></li>\n\t<li><code>1 &lt;= values[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1040移动石子直到连续 II",
        "hardRate": "MEDIUM",
        "passRate": "66.19%",
        "problemsUrl": "https://leetcode.cn/problems/moving-stones-until-consecutive-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/moving-stones-until-consecutive-ii/solution",
        "problemsDesc": "<p>在一个长度 <strong>无限 </strong>的数轴上，第 <code>i</code> 颗石子的位置为 <code>stones[i]</code>。如果一颗石子的位置最小/最大，那么该石子被称作 <strong>端点石子 </strong>。</p>\n\n<p>每个回合，你可以将一颗端点石子拿起并移动到一个未占用的位置，使得该石子不再是一颗端点石子。</p>\n\n<p>值得注意的是，如果石子像 <code>stones = [1,2,5]</code> 这样，你将 <strong>无法 </strong>移动位于位置 5 的端点石子，因为无论将它移动到任何位置（例如 0 或 3），该石子都仍然会是端点石子。</p>\n\n<p>当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。</p>\n\n<p>要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：<code>answer = [minimum_moves, maximum_moves]</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>[7,4,9]\n<strong>输出：</strong>[1,2]\n<strong>解释：</strong>\n我们可以移动一次，4 -> 8，游戏结束。\n或者，我们可以移动两次 9 -> 5，4 -> 6，游戏结束。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>[6,5,4,3,10]\n<strong>输出：</strong>[2,3]\n<strong>解释：</strong>\n我们可以移动 3 -> 8，接着是 10 -> 7，游戏结束。\n或者，我们可以移动 3 -> 7, 4 -> 8, 5 -> 9，游戏结束。\n注意，我们无法进行 10 -> 2 这样的移动来结束游戏，因为这是不合要求的移动。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>[100,101,104,102,103]\n<strong>输出：</strong>[0,0]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 <= stones.length <= 10^4</code></li>\n\t<li><code>1 <= stones[i] <= 10^9</code></li>\n\t<li><code>stones[i]</code> 的值各不相同。</li>\n</ul>\n\n<p> </p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1041困于环中的机器人",
        "hardRate": "MEDIUM",
        "passRate": "57.05%",
        "problemsUrl": "https://leetcode.cn/problems/robot-bounded-in-circle/",
        "solutionsUrl": "https://leetcode.cn/problems/robot-bounded-in-circle/solution",
        "problemsDesc": "<p>在无限的平面上，机器人最初位于&nbsp;<code>(0, 0)</code>&nbsp;处，面朝北方。注意:</p>\n\n<ul>\n\t<li><strong>北方向</strong> 是y轴的正方向。</li>\n\t<li><strong>南方向</strong> 是y轴的负方向。</li>\n\t<li><strong>东方向</strong> 是x轴的正方向。</li>\n\t<li><strong>西方向</strong> 是x轴的负方向。</li>\n</ul>\n\n<p>机器人可以接受下列三条指令之一：</p>\n\n<ul>\n\t<li><code>\"G\"</code>：直走 1 个单位</li>\n\t<li><code>\"L\"</code>：左转 90 度</li>\n\t<li><code>\"R\"</code>：右转 90 度</li>\n</ul>\n\n<p>机器人按顺序执行指令&nbsp;<code>instructions</code>，并一直重复它们。</p>\n\n<p>只有在平面中存在环使得机器人永远无法离开时，返回&nbsp;<code>true</code>。否则，返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>instructions = \"GGLLGG\"\n<strong>输出：</strong>true\n<strong>解释：</strong>机器人最初在(0,0)处，面向北方。\n“G”:移动一步。位置:(0,1)方向:北。\n“G”:移动一步。位置:(0,2).方向:北。\n“L”:逆时针旋转90度。位置:(0,2).方向:西。\n“L”:逆时针旋转90度。位置:(0,2)方向:南。\n“G”:移动一步。位置:(0,1)方向:南。\n“G”:移动一步。位置:(0,0)方向:南。\n重复指令，机器人进入循环:(0,0)——&gt;(0,1)——&gt;(0,2)——&gt;(0,1)——&gt;(0,0)。\n在此基础上，我们返回true。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>instructions = \"GG\"\n<strong>输出：</strong>false\n<strong>解释：</strong>机器人最初在(0,0)处，面向北方。\n“G”:移动一步。位置:(0,1)方向:北。\n“G”:移动一步。位置:(0,2).方向:北。\n重复这些指示，继续朝北前进，不会进入循环。\n在此基础上，返回false。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>instructions = \"GL\"\n<strong>输出：</strong>true\n<strong>解释：</strong>机器人最初在(0,0)处，面向北方。\n“G”:移动一步。位置:(0,1)方向:北。\n“L”:逆时针旋转90度。位置:(0,1).方向:西。\n“G”:移动一步。位置:(- 1,1)方向:西。\n“L”:逆时针旋转90度。位置:(- 1,1)方向:南。\n“G”:移动一步。位置:(- 1,0)方向:南。\n“L”:逆时针旋转90度。位置:(- 1,0)方向:东方。\n“G”:移动一步。位置:(0,0)方向:东方。\n“L”:逆时针旋转90度。位置:(0,0)方向:北。\n重复指令，机器人进入循环:(0,0)——&gt;(0,1)——&gt;(- 1,1)——&gt;(- 1,0)——&gt;(0,0)。\n在此基础上，我们返回true。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= instructions.length &lt;= 100</code></li>\n\t<li><code>instructions[i]</code>&nbsp;仅包含&nbsp;<code>'G', 'L', 'R'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1042不邻接植花",
        "hardRate": "MEDIUM",
        "passRate": "61.15%",
        "problemsUrl": "https://leetcode.cn/problems/flower-planting-with-no-adjacent/",
        "solutionsUrl": "https://leetcode.cn/problems/flower-planting-with-no-adjacent/solution",
        "problemsDesc": "<p>有 <code>n</code> 个花园，按从&nbsp;<code>1</code>&nbsp;到 <code>n</code> 标记。另有数组 <code>paths</code> ，其中 <code>paths[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;描述了花园&nbsp;<code>x<sub>i</sub></code> 到花园&nbsp;<code>y<sub>i</sub></code> 的双向路径。在每个花园中，你打算种下四种花之一。</p>\n\n<p>另外，所有花园 <strong>最多</strong> 有 <strong>3</strong> 条路径可以进入或离开.</p>\n\n<p>你需要为每个花园选择一种花，使得通过路径相连的任何两个花园中的花的种类互不相同。</p>\n\n<p><em>以数组形式返回 <strong>任一</strong> 可行的方案作为答案&nbsp;<code>answer</code>，其中&nbsp;<code>answer[i]</code>&nbsp;为在第&nbsp;<code>(i+1)</code>&nbsp;个花园中种植的花的种类。花的种类用 &nbsp;1、2、3、4 表示。保证存在答案。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, paths = [[1,2],[2,3],[3,1]]\n<strong>输出：</strong>[1,2,3]\n<strong>解释：</strong>\n花园 1 和 2 花的种类不同。\n花园 2 和 3 花的种类不同。\n花园 3 和 1 花的种类不同。\n因此，[1,2,3] 是一个满足题意的答案。其他满足题意的答案有 [1,2,4]、[1,4,2] 和 [3,2,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, paths = [[1,2],[3,4]]\n<strong>输出：</strong>[1,2,1,2]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]]\n<strong>输出：</strong>[1,2,3,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= paths.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>paths[i].length == 2</code></li>\n\t<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= n</code></li>\n\t<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>\n\t<li>每个花园 <strong>最多</strong> 有 <strong>3</strong> 条路径可以进入或离开</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1043分隔数组以得到最大和",
        "hardRate": "MEDIUM",
        "passRate": "75.48%",
        "problemsUrl": "https://leetcode.cn/problems/partition-array-for-maximum-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-array-for-maximum-sum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code>，请你将该数组分隔为长度 <strong>最多 </strong>为 k 的一些（连续）子数组。分隔完成后，每个子数组的中的所有值都会变为该子数组中的最大值。</p>\n\n<p>返回将数组分隔变换后能够得到的元素最大和。本题所用到的测试用例会确保答案是一个 32 位整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,15,7,9,2,5,10], k = 3\n<strong>输出：</strong>84\n<strong>解释：</strong>数组变为 [15,15,15,9,10,10,10]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\n<strong>输出：</strong>83\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1], k = 1\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 500</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1044最长重复子串",
        "hardRate": "HARD",
        "passRate": "35.40%",
        "problemsUrl": "https://leetcode.cn/problems/longest-duplicate-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-duplicate-substring/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，考虑其所有 <em>重复子串</em> ：即&nbsp;<code>s</code> 的（连续）子串，在 <code>s</code> 中出现 2 次或更多次。这些出现之间可能存在重叠。</p>\n\n<p>返回 <strong>任意一个</strong> 可能具有最长长度的重复子串。如果 <code>s</code> 不含重复子串，那么答案为 <code>\"\"</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"banana\"\n<strong>输出：</strong>\"ana\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\"\n<strong>输出：</strong>\"\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1045买下所有产品的客户",
        "hardRate": "MEDIUM",
        "passRate": "61.51%",
        "problemsUrl": "https://leetcode.cn/problems/customers-who-bought-all-products/",
        "solutionsUrl": "https://leetcode.cn/problems/customers-who-bought-all-products/solution",
        "problemsDesc": "<p><code>Customer</code>&nbsp;表：</p>\n\n<pre>+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| customer_id | int     |\n| product_key | int     |\n+-------------+---------+\nproduct_key 是 <code>Customer 表的外键</code>。\n</pre>\n\n<p><code>Product</code>&nbsp;表：</p>\n\n<pre>+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| product_key | int     |\n+-------------+---------+\nproduct_key 是这张表的主键。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一条 SQL 查询语句，从 <code>Customer</code> 表中查询购买了 <code>Product</code> 表中所有产品的客户的 id。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>Customer 表：\n+-------------+-------------+\n| customer_id | product_key |\n+-------------+-------------+\n| 1           | 5           |\n| 2           | 6           |\n| 3           | 5           |\n| 3           | 6           |\n| 1           | 6           |\n+-------------+-------------+\n\nProduct 表：\n+-------------+\n| product_key |\n+-------------+\n| 5           |\n| 6           |\n+-------------+\n\nResult 表：\n+-------------+\n| customer_id |\n+-------------+\n| 1           |\n| 3           |\n+-------------+\n购买了所有产品（5 和 6）的客户的 id 是 1 和 3 。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1046最后一块石头的重量",
        "hardRate": "EASY",
        "passRate": "65.56%",
        "problemsUrl": "https://leetcode.cn/problems/last-stone-weight/",
        "solutionsUrl": "https://leetcode.cn/problems/last-stone-weight/solution",
        "problemsDesc": "<p>有一堆石头，每块石头的重量都是正整数。</p>\n\n<p>每一回合，从中选出两块<strong> 最重的</strong> 石头，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x <= y</code>。那么粉碎的可能结果如下：</p>\n\n<ul>\n\t<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>\n\t<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>\n</ul>\n\n<p>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 <code>0</code>。</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>[2,7,4,1,8,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，\n再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，\n接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，\n最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= stones.length <= 30</code></li>\n\t<li><code>1 <= stones[i] <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1047删除字符串中的所有相邻重复项",
        "hardRate": "EASY",
        "passRate": "72.37%",
        "problemsUrl": "https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/solution",
        "problemsDesc": "<p>给出由小写字母组成的字符串&nbsp;<code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p>\n\n<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>\n\n<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>&quot;abbaca&quot;\n<strong>输出：</strong>&quot;ca&quot;\n<strong>解释：</strong>\n例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= S.length &lt;= 20000</code></li>\n\t<li><code>S</code> 仅由小写英文字母组成。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1048最长字符串链",
        "hardRate": "MEDIUM",
        "passRate": "55.76%",
        "problemsUrl": "https://leetcode.cn/problems/longest-string-chain/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-string-chain/solution",
        "problemsDesc": "<p>给出一个单词数组&nbsp;<code>words</code>&nbsp;，其中每个单词都由小写英文字母组成。</p>\n\n<p>如果我们可以&nbsp;<strong>不改变其他字符的顺序&nbsp;</strong>，在 <code>word<sub>A</sub></code>&nbsp;的任何地方添加 <strong>恰好一个</strong> 字母使其变成&nbsp;<code>word<sub>B</sub></code>&nbsp;，那么我们认为&nbsp;<code>word<sub>A</sub></code>&nbsp;是&nbsp;<code>word<sub>B</sub></code>&nbsp;的 <strong>前身</strong> 。</p>\n\n<ul>\n\t<li>例如，<code>\"abc\"</code>&nbsp;是&nbsp;<code>\"abac\"</code>&nbsp;的 <strong>前身</strong>&nbsp;，而&nbsp;<code>\"cba\"</code>&nbsp;不是&nbsp;<code>\"bcad\"</code>&nbsp;的 <strong>前身</strong></li>\n</ul>\n\n<p><strong>词链</strong>是单词&nbsp;<code>[word_1, word_2, ..., word_k]</code>&nbsp;组成的序列，<code>k &gt;= 1</code>，其中&nbsp;<code>word<sub>1</sub></code>&nbsp;是&nbsp;<code>word<sub>2</sub></code>&nbsp;的前身，<code>word<sub>2</sub></code>&nbsp;是&nbsp;<code>word<sub>3</sub></code>&nbsp;的前身，依此类推。一个单词通常是 <code>k == 1</code> 的 <strong>单词链</strong>&nbsp;。</p>\n\n<p>从给定单词列表 <code>words</code> 中选择单词组成词链，返回 词链的&nbsp;<strong>最长可能长度</strong> 。<br />\n&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\n<strong>输出：</strong>4\n<strong>解释：</strong>最长单词链之一为 [\"a\",\"<u>b</u>a\",\"b<u>d</u>a\",\"bd<u>c</u>a\"]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"xbc\",\"pcxbcf\",\"xb\",\"cxbc\",\"pcxbc\"]\n<b>输出：</b>5\n<b>解释：</b>所有的单词都可以放入单词链 [\"xb\", \"xb<u>c</u>\", \"<u>c</u>xbc\", \"<u>p</u>cxbc\", \"pcxbc<u>f</u>\"].\n</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"abcd\",\"dbqca\"]\n<strong>输出：</strong>1\n<b>解释：</b>字链[\"abcd\"]是最长的字链之一。\n[\"abcd\"，\"dbqca\"]不是一个有效的单词链，因为字母的顺序被改变了。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 16</code></li>\n\t<li><code>words[i]</code>&nbsp;仅由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1049最后一块石头的重量 II",
        "hardRate": "MEDIUM",
        "passRate": "69.23%",
        "problemsUrl": "https://leetcode.cn/problems/last-stone-weight-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/last-stone-weight-ii/solution",
        "problemsDesc": "<p>有一堆石头，用整数数组&nbsp;<code>stones</code> 表示。其中&nbsp;<code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p>\n\n<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为&nbsp;<code>x</code> 和&nbsp;<code>y</code>，且&nbsp;<code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>\n\n<ul>\n\t<li>如果&nbsp;<code>x == y</code>，那么两块石头都会被完全粉碎；</li>\n\t<li>如果&nbsp;<code>x != y</code>，那么重量为&nbsp;<code>x</code>&nbsp;的石头将会完全粉碎，而重量为&nbsp;<code>y</code>&nbsp;的石头新重量为&nbsp;<code>y-x</code>。</li>\n</ul>\n\n<p>最后，<strong>最多只会剩下一块 </strong>石头。返回此石头 <strong>最小的可能重量 </strong>。如果没有石头剩下，就返回 <code>0</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [2,7,4,1,8,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，\n组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，\n组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，\n组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [31,26,33,21,40]\n<strong>输出：</strong>5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= stones.length &lt;= 30</code></li>\n\t<li><code>1 &lt;= stones[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1050合作过至少三次的演员和导演",
        "hardRate": "EASY",
        "passRate": "76.72%",
        "problemsUrl": "https://leetcode.cn/problems/actors-and-directors-who-cooperated-at-least-three-times/",
        "solutionsUrl": "https://leetcode.cn/problems/actors-and-directors-who-cooperated-at-least-three-times/solution",
        "problemsDesc": "<p><code>ActorDirector</code>&nbsp;表：</p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| actor_id    | int     |\n| director_id | int     |\n| timestamp   | int     |\n+-------------+---------+\ntimestamp 是这张表的主键.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一条SQL查询语句获取合作过至少三次的演员和导演的 id 对&nbsp;<code>(actor_id, director_id)</code></p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\nActorDirector 表：\n+-------------+-------------+-------------+\n| actor_id    | director_id | timestamp   |\n+-------------+-------------+-------------+\n| 1           | 1           | 0           |\n| 1           | 1           | 1           |\n| 1           | 1           | 2           |\n| 1           | 2           | 3           |\n| 1           | 2           | 4           |\n| 2           | 1           | 5           |\n| 2           | 1           | 6           |\n+-------------+-------------+-------------+\n\nResult 表：\n+-------------+-------------+\n| actor_id    | director_id |\n+-------------+-------------+\n| 1           | 1           |\n+-------------+-------------+\n唯一的 id 对是 (1, 1)，他们恰好合作了 3 次。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1051高度检查器",
        "hardRate": "EASY",
        "passRate": "80.05%",
        "problemsUrl": "https://leetcode.cn/problems/height-checker/",
        "solutionsUrl": "https://leetcode.cn/problems/height-checker/solution",
        "problemsDesc": "<p>学校打算为全体学生拍一张年度纪念照。根据要求，学生需要按照 <strong>非递减</strong> 的高度顺序排成一行。</p>\n\n<p>排序后的高度情况用整数数组 <code>expected</code> 表示，其中 <code>expected[i]</code> 是预计排在这一行中第 <code>i</code> 位的学生的高度（<strong>下标从 0 开始</strong>）。</p>\n\n<p>给你一个整数数组 <code>heights</code> ，表示 <strong>当前学生站位</strong> 的高度情况。<code>heights[i]</code> 是这一行中第 <code>i</code> 位学生的高度（<strong>下标从 0 开始</strong>）。</p>\n\n<p>返回满足<em> </em><code>heights[i] != expected[i]</code> 的 <strong>下标数量</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>heights =&nbsp;[1,1,4,2,1,3]\n<strong>输出：</strong>3 \n<strong>解释：</strong>\n高度：[1,1,<em><strong>4</strong></em>,2,<em><strong>1</strong></em>,<em><strong>3</strong></em>]\n预期：[1,1,<em><strong>1</strong></em>,2,<em><strong>3</strong></em>,<em><strong>4</strong></em>]\n下标 2 、4 、5 处的学生高度不匹配。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>heights = [5,1,2,3,4]\n<strong>输出：</strong>5\n<strong>解释：</strong>\n高度：[<em><strong>5</strong></em>,<em><strong>1</strong></em>,<em><strong>2</strong></em>,<em><strong>3</strong></em>,<em><strong>4</strong></em>]\n预期：[<em><strong>1</strong></em>,<em><strong>2</strong></em>,<em><strong>3</strong></em>,<em><strong>4</strong></em>,<em><strong>5</strong></em>]\n所有下标的对应学生高度都不匹配。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>heights = [1,2,3,4,5]\n<strong>输出：</strong>0\n<strong>解释：</strong>\n高度：[1,2,3,4,5]\n预期：[1,2,3,4,5]\n所有下标的对应学生高度都匹配。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= heights.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= heights[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1052爱生气的书店老板",
        "hardRate": "MEDIUM",
        "passRate": "58.00%",
        "problemsUrl": "https://leetcode.cn/problems/grumpy-bookstore-owner/",
        "solutionsUrl": "https://leetcode.cn/problems/grumpy-bookstore-owner/solution",
        "problemsDesc": "<p>有一个书店老板，他的书店开了&nbsp;<code>n</code>&nbsp;分钟。每分钟都有一些顾客进入这家商店。给定一个长度为 <code>n</code> 的整数数组 <code>customers</code> ，其中 <code>customers[i]</code> 是在第 <code>i</code> 分钟开始时进入商店的顾客数量，所有这些顾客在第 <code>i</code> 分钟结束后离开。</p>\n\n<p>在某些时候，书店老板会生气。 如果书店老板在第 <code>i</code> 分钟生气，那么 <code>grumpy[i] = 1</code>，否则 <code>grumpy[i] = 0</code>。</p>\n\n<p>当书店老板生气时，那一分钟的顾客就会不满意，若老板不生气则顾客是满意的。</p>\n\n<p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续&nbsp;<code>minutes</code>&nbsp;分钟不生气，但却只能使用一次。</p>\n\n<p>请你返回 <em>这一天营业下来，最多有多少客户能够感到满意</em> 。<br />\n&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\n<strong>输出：</strong>16\n<strong>解释：</strong>书店老板在最后 3 分钟保持冷静。\n感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>customers = [1], grumpy = [0], minutes = 1\n<strong>输出：</strong>1</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == customers.length == grumpy.length</code></li>\n\t<li><code>1 &lt;= minutes &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= customers[i] &lt;= 1000</code></li>\n\t<li><code>grumpy[i] == 0 or 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1053交换一次的先前排列",
        "hardRate": "MEDIUM",
        "passRate": "48.32%",
        "problemsUrl": "https://leetcode.cn/problems/previous-permutation-with-one-swap/",
        "solutionsUrl": "https://leetcode.cn/problems/previous-permutation-with-one-swap/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>arr</code>（可能存在重复的元素），请你返回可在&nbsp;<strong>一次交换</strong>（交换两数字 <code>arr[i]</code> 和 <code>arr[j]</code> 的位置）后得到的、按字典序排列小于 <code>arr</code> 的最大排列。</p>\n\n<p>如果无法这么操作，就请返回原数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [3,2,1]\n<strong>输出：</strong>[3,1,2]\n<strong>解释：</strong>交换 2 和 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,1,5]\n<strong>输出：</strong>[1,1,5]\n<strong>解释：</strong>已经是最小排列\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,9,4,6,7]\n<strong>输出：</strong>[1,7,4,6,9]\n<strong>解释：</strong>交换 9 和 7\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1054距离相等的条形码",
        "hardRate": "MEDIUM",
        "passRate": "44.82%",
        "problemsUrl": "https://leetcode.cn/problems/distant-barcodes/",
        "solutionsUrl": "https://leetcode.cn/problems/distant-barcodes/solution",
        "problemsDesc": "<p>在一个仓库里，有一排条形码，其中第 <code>i</code> 个条形码为&nbsp;<code>barcodes[i]</code>。</p>\n\n<p>请你重新排列这些条形码，使其中任意两个相邻的条形码不能相等。 你可以返回任何满足该要求的答案，此题保证存在答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>barcodes = [1,1,1,2,2,2]\n<strong>输出：</strong>[2,1,2,1,2,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>barcodes = [1,1,1,1,2,2,3,3]\n<strong>输出：</strong>[1,3,1,3,2,1,2,1]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= barcodes.length &lt;= 10000</code></li>\n\t<li><code>1 &lt;= barcodes[i] &lt;= 10000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1055形成字符串的最短路径",
        "hardRate": "MEDIUM",
        "passRate": "60.45%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-way-to-form-string/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-way-to-form-string/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1056易混淆数",
        "hardRate": "EASY",
        "passRate": "43.61%",
        "problemsUrl": "https://leetcode.cn/problems/confusing-number/",
        "solutionsUrl": "https://leetcode.cn/problems/confusing-number/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1057校园自行车分配",
        "hardRate": "MEDIUM",
        "passRate": "51.00%",
        "problemsUrl": "https://leetcode.cn/problems/campus-bikes/",
        "solutionsUrl": "https://leetcode.cn/problems/campus-bikes/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1058最小化舍入误差以满足目标",
        "hardRate": "MEDIUM",
        "passRate": "37.36%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-rounding-error-to-meet-target/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-rounding-error-to-meet-target/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1059从始点到终点的所有路径",
        "hardRate": "MEDIUM",
        "passRate": "35.78%",
        "problemsUrl": "https://leetcode.cn/problems/all-paths-from-source-lead-to-destination/",
        "solutionsUrl": "https://leetcode.cn/problems/all-paths-from-source-lead-to-destination/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1060有序数组中的缺失元素",
        "hardRate": "MEDIUM",
        "passRate": "54.71%",
        "problemsUrl": "https://leetcode.cn/problems/missing-element-in-sorted-array/",
        "solutionsUrl": "https://leetcode.cn/problems/missing-element-in-sorted-array/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1061按字典序排列最小的等效字符串",
        "hardRate": "MEDIUM",
        "passRate": "64.60%",
        "problemsUrl": "https://leetcode.cn/problems/lexicographically-smallest-equivalent-string/",
        "solutionsUrl": "https://leetcode.cn/problems/lexicographically-smallest-equivalent-string/solution",
        "problemsDesc": "<p>给出长度相同的两个字符串<code>s1</code> 和&nbsp;<code>s2</code>&nbsp;，还有一个字符串&nbsp;<code>baseStr</code>&nbsp;。</p>\n\n<p>其中 &nbsp;<code>s1[i]</code>&nbsp;和&nbsp;<code>s2[i]</code>&nbsp; 是一组等价字符。</p>\n\n<ul>\n\t<li>举个例子，如果&nbsp;<code>s1 = \"abc\"</code> 且&nbsp;<code>s2 = \"cde\"</code>，那么就有&nbsp;<code>'a' == 'c', 'b' == 'd', 'c' == 'e'</code>。</li>\n</ul>\n\n<p>等价字符遵循任何等价关系的一般规则：</p>\n\n<ul>\n\t<li><strong>&nbsp;自反性&nbsp;</strong>：<code>'a' == 'a'</code></li>\n\t<li>&nbsp;<strong>对称性&nbsp;</strong>：<code>'a' == 'b'</code> 则必定有 <code>'b' == 'a'</code></li>\n\t<li>&nbsp;<strong>传递性</strong> ：<code>'a' == 'b'</code> 且 <code>'b' == 'c'</code> 就表明 <code>'a' == 'c'</code></li>\n</ul>\n\n<p>例如，&nbsp;<code>s1 = \"abc\"</code>&nbsp;和&nbsp;<code>s2 = \"cde\"</code>&nbsp;的等价信息和之前的例子一样，那么&nbsp;<code>baseStr = \"eed\"</code>&nbsp;, <code>\"acd\"</code>&nbsp;或&nbsp;<code>\"aab\"</code>，这三个字符串都是等价的，而&nbsp;<code>\"aab\"</code>&nbsp;是&nbsp;<code>baseStr</code>&nbsp;的按字典序最小的等价字符串</p>\n\n<p>利用<em>&nbsp;</em><code>s1</code>&nbsp;和&nbsp;<code>s2</code>&nbsp;的等价信息，找出并返回<em>&nbsp;</em><code>baseStr</code><em>&nbsp;</em>的按字典序排列最小的等价字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\n<strong>输出：</strong>\"makkek\"\n<strong>解释：</strong>根据 <code>A</code> 和 <code>B 中的等价信息，</code>我们可以将这些字符分为 <code>[m,p]</code>, <code>[a,o]</code>, <code>[k,r,s]</code>, <code>[e,i] 共 4 组</code>。每组中的字符都是等价的，并按字典序排列。所以答案是 <code>\"makkek\"</code>。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"hello\", s2 = \"world\", baseStr = \"hold\"\n<strong>输出：</strong>\"hdld\"\n<strong>解释：</strong>根据 <code>A</code> 和 <code>B 中的等价信息，</code>我们可以将这些字符分为 <code>[h,w]</code>, <code>[d,e,o]</code>, <code>[l,r] 共 3 组</code>。所以只有 S 中的第二个字符 <code>'o'</code> 变成 <code>'d'，最后答案为 </code><code>\"hdld\"</code>。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"leetcode\", s2 = \"programs\", baseStr = \"sourcecode\"\n<strong>输出：</strong>\"aauaaaaada\"\n<strong>解释：</strong>我们可以把 A 和 B 中的等价字符分为 <code>[a,o,e,r,s,c]</code>, <code>[l,p]</code>, <code>[g,t]</code> 和 <code>[d,m] 共 4 组</code>，因此 <code>S</code> 中除了 <code>'u'</code> 和 <code>'d'</code> 之外的所有字母都转化成了 <code>'a'</code>，最后答案为 <code>\"aauaaaaada\"</code>。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length, baseStr &lt;= 1000</code></li>\n\t<li><code>s1.length == s2.length</code></li>\n\t<li>字符串<code>s1</code>,&nbsp;<code>s2</code>, and&nbsp;<code>baseStr</code>&nbsp;仅由从&nbsp;<code>'a'</code> 到&nbsp;<code>'z'</code>&nbsp;的小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1062最长重复子串",
        "hardRate": "MEDIUM",
        "passRate": "56.95%",
        "problemsUrl": "https://leetcode.cn/problems/longest-repeating-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-repeating-substring/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1063有效子数组的数目",
        "hardRate": "HARD",
        "passRate": "73.81%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-valid-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-valid-subarrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1064不动点",
        "hardRate": "EASY",
        "passRate": "64.78%",
        "problemsUrl": "https://leetcode.cn/problems/fixed-point/",
        "solutionsUrl": "https://leetcode.cn/problems/fixed-point/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1065字符串的索引对",
        "hardRate": "EASY",
        "passRate": "56.42%",
        "problemsUrl": "https://leetcode.cn/problems/index-pairs-of-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/index-pairs-of-a-string/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1066校园自行车分配 II",
        "hardRate": "MEDIUM",
        "passRate": "51.32%",
        "problemsUrl": "https://leetcode.cn/problems/campus-bikes-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/campus-bikes-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1067范围内的数字计数",
        "hardRate": "HARD",
        "passRate": "48.28%",
        "problemsUrl": "https://leetcode.cn/problems/digit-count-in-range/",
        "solutionsUrl": "https://leetcode.cn/problems/digit-count-in-range/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1068产品销售分析 I",
        "hardRate": "EASY",
        "passRate": "86.70%",
        "problemsUrl": "https://leetcode.cn/problems/product-sales-analysis-i/",
        "solutionsUrl": "https://leetcode.cn/problems/product-sales-analysis-i/solution",
        "problemsDesc": "<p>销售表&nbsp;<code>Sales</code>：</p>\n\n<pre>\n+-------------+-------+\n| Column Name | Type  |\n+-------------+-------+\n| sale_id     | int   |\n| product_id  | int   |\n| year        | int   |\n| quantity    | int   |\n| price       | int   |\n+-------------+-------+\n(sale_id, year) 是销售表 Sales 的主键.\nproduct_id 是关联到产品表 Product 的外键.\n注意: price 表示每单位价格\n</pre>\n\n<p>产品表&nbsp;<code>Product</code>：</p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| product_id   | int     |\n| product_name | varchar |\n+--------------+---------+\nproduct_id&nbsp;是表的主键.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一条SQL&nbsp;查询语句获取 <code>Sales</code>&nbsp;表中所有产品对应的 <strong>产品名称 product_name</strong> 以及该产品的所有 <strong>售卖年份 year</strong>&nbsp;和 <strong>价格 price</strong> 。</p>\n\n<p>查询结果中的顺序无特定要求。</p>\n\n<p>查询结果格式示例如下：</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<code>Sales</code> 表：\n+---------+------------+------+----------+-------+\n| sale_id | product_id | year | quantity | price |\n+---------+------------+------+----------+-------+ \n| 1       | 100        | 2008 | 10       | 5000  |\n| 2       | 100        | 2009 | 12       | 5000  |\n| 7       | 200        | 2011 | 15       | 9000  |\n+---------+------------+------+----------+-------+\n\nProduct 表：\n+------------+--------------+\n| product_id | product_name |\n+------------+--------------+\n| 100        | Nokia        |\n| 200        | Apple        |\n| 300        | Samsung      |\n+------------+--------------+\n\nResult 表：\n+--------------+-------+-------+\n| product_name | year  | price |\n+--------------+-------+-------+\n| Nokia        | 2008  | 5000  |\n| Nokia        | 2009  | 5000  |\n| Apple        | 2011  | 9000  |\n+--------------+-------+-------+\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1069产品销售分析 II",
        "hardRate": "EASY",
        "passRate": "81.76%",
        "problemsUrl": "https://leetcode.cn/problems/product-sales-analysis-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/product-sales-analysis-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1070产品销售分析 III",
        "hardRate": "MEDIUM",
        "passRate": "47.95%",
        "problemsUrl": "https://leetcode.cn/problems/product-sales-analysis-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/product-sales-analysis-iii/solution",
        "problemsDesc": "<p>销售表&nbsp;<code>Sales</code>：</p>\n\n<pre>\n+-------------+-------+\n| Column Name | Type  |\n+-------------+-------+\n| sale_id     | int   |\n| product_id  | int   |\n| year        | int   |\n| quantity    | int   |\n| price       | int   |\n+-------------+-------+\n(sale_id, year) 是这张表的主键。\nproduct_id 是产品表的外键。\n这张表的每一行都表示：编号 product_id 的产品在某一年的销售额。\n请注意，价格是按每单位计的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>产品表&nbsp;<code>Product</code>：</p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| product_id   | int     |\n| product_name | varchar |\n+--------------+---------+\nproduct_id 是这张表的主键。\n这张表的每一行都标识：每个产品的 id 和 产品名称。</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个 SQL 查询，选出每个销售产品&nbsp;<strong>第一年</strong> 销售的 <strong>产品 id</strong>、<strong>年份</strong>、<strong>数量&nbsp;</strong>和 <strong>价格</strong>。</p>\n\n<p>结果表中的条目可以按 <strong>任意顺序</strong> 排列。</p>\n\n<p>查询结果格式如下例所示：</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nSales 表：\n+---------+------------+------+----------+-------+\n| sale_id | product_id | year | quantity | price |\n+---------+------------+------+----------+-------+ \n| 1       | 100        | 2008 | 10       | 5000  |\n| 2       | 100        | 2009 | 12       | 5000  |\n| 7       | 200        | 2011 | 15       | 9000  |\n+---------+------------+------+----------+-------+\nProduct 表：\n+------------+--------------+\n| product_id | product_name |\n+------------+--------------+\n| 100        | Nokia        |\n| 200        | Apple        |\n| 300        | Samsung      |\n+------------+--------------+\n<strong>输出：</strong>\n+------------+------------+----------+-------+\n| product_id | first_year | quantity | price |\n+------------+------------+----------+-------+ \n| 100        | 2008       | 10       | 5000  |\n| 200        | 2011       | 15       | 9000  |\n+------------+------------+----------+-------+</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1071字符串的最大公因子",
        "hardRate": "EASY",
        "passRate": "57.78%",
        "problemsUrl": "https://leetcode.cn/problems/greatest-common-divisor-of-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/greatest-common-divisor-of-strings/solution",
        "problemsDesc": "<p>对于字符串&nbsp;<code>s</code> 和&nbsp;<code>t</code>，只有在&nbsp;<code>s = t + ... + t</code>（<code>t</code> 自身连接 1 次或多次）时，我们才认定&nbsp;“<code>t</code> 能除尽 <code>s</code>”。</p>\n\n<p>给定两个字符串&nbsp;<code>str1</code>&nbsp;和&nbsp;<code>str2</code>&nbsp;。返回 <em>最长字符串&nbsp;<code>x</code>，要求满足&nbsp;<code>x</code> 能除尽 <code>str1</code> 且 <code>x</code> 能除尽 <code>str2</code></em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>str1 = \"ABCABC\", str2 = \"ABC\"\n<strong>输出：</strong>\"ABC\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>str1 = \"ABABAB\", str2 = \"ABAB\"\n<strong>输出：</strong>\"AB\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>str1 = \"LEET\", str2 = \"CODE\"\n<strong>输出：</strong>\"\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= str1.length, str2.length &lt;= 1000</code></li>\n\t<li><code>str1</code>&nbsp;和&nbsp;<code>str2</code>&nbsp;由大写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1072按列翻转得到最大值等行数",
        "hardRate": "MEDIUM",
        "passRate": "71.37%",
        "problemsUrl": "https://leetcode.cn/problems/flip-columns-for-maximum-number-of-equal-rows/",
        "solutionsUrl": "https://leetcode.cn/problems/flip-columns-for-maximum-number-of-equal-rows/solution",
        "problemsDesc": "<p>给定&nbsp;<code>m x n</code>&nbsp;矩阵&nbsp;<code>matrix</code>&nbsp;。</p>\n\n<p>你可以从中选出任意数量的列并翻转其上的&nbsp;<strong>每个&nbsp;</strong>单元格。（即翻转后，单元格的值从 <code>0</code> 变成 <code>1</code>，或者从 <code>1</code> 变为 <code>0</code> 。）</p>\n\n<p>返回 <em>经过一些翻转后，行内所有值都相等的最大行数</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[0,1],[1,1]]\n<strong>输出：</strong>1\n<strong>解释：</strong>不进行翻转，有 1 行所有值都相等。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[0,1],[1,0]]\n<strong>输出：</strong>2\n<strong>解释：</strong>翻转第一列的值之后，这两行都由相等的值组成。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[0,0,0],[0,0,1],[1,1,0]]\n<strong>输出：</strong>2\n<strong>解释：</strong>翻转前两列的值之后，后两行由相等的值组成。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>matrix[i][j] == 0</code> 或&nbsp;<code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1073负二进制数相加",
        "hardRate": "MEDIUM",
        "passRate": "41.60%",
        "problemsUrl": "https://leetcode.cn/problems/adding-two-negabinary-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/adding-two-negabinary-numbers/solution",
        "problemsDesc": "<p>给出基数为 <strong>-2</strong>&nbsp;的两个数&nbsp;<code>arr1</code> 和&nbsp;<code>arr2</code>，返回两数相加的结果。</p>\n\n<p>数字以&nbsp;<em>数组形式</em><strong>&nbsp;</strong>给出：数组由若干 0 和 1 组成，按最高有效位到最低有效位的顺序排列。例如，<code>arr&nbsp;= [1,1,0,1]</code>&nbsp;表示数字&nbsp;<code>(-2)^3&nbsp;+ (-2)^2 + (-2)^0 = -3</code>。<em>数组形式</em>&nbsp;中的数字 <code>arr</code> 也同样不含前导零：即&nbsp;<code>arr == [0]</code>&nbsp;或&nbsp;<code>arr[0] == 1</code>。</p>\n\n<p>返回相同表示形式的 <code>arr1</code> 和 <code>arr2</code> 相加的结果。两数的表示形式为：不含前导零、由若干 0 和 1 组成的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr1 = [1,1,1,1,1], arr2 = [1,0,1]\n<strong>输出：</strong>[1,0,0,0,0]\n<strong>解释：</strong>arr1 表示 11，arr2 表示 5，输出表示 16 。\n</pre>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr1 = [0], arr2 = [0]\n<strong>输出：</strong>[0]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr1 = [0], arr2 = [1]\n<strong>输出：</strong>[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>1 &lt;= arr1.length,&nbsp;arr2.length &lt;= 1000</code></li>\n\t<li><code>arr1[i]</code>&nbsp;和&nbsp;<code>arr2[i]</code>&nbsp;都是&nbsp;<code>0</code>&nbsp;或&nbsp;<code>1</code></li>\n\t<li><code>arr1</code>&nbsp;和&nbsp;<code>arr2</code>&nbsp;都没有前导0</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1074元素和为目标值的子矩阵数量",
        "hardRate": "HARD",
        "passRate": "67.39%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-submatrices-that-sum-to-target/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-submatrices-that-sum-to-target/solution",
        "problemsDesc": "<p>给出矩阵 <code>matrix</code> 和目标值 <code>target</code>，返回元素总和等于目标值的非空子矩阵的数量。</p>\n\n<p>子矩阵 <code>x1, y1, x2, y2</code> 是满足 <code>x1 <= x <= x2</code> 且 <code>y1 <= y <= y2</code> 的所有单元 <code>matrix[x][y]</code> 的集合。</p>\n\n<p>如果 <code>(x1, y1, x2, y2)</code> 和 <code>(x1', y1', x2', y2')</code> 两个子矩阵中部分坐标不同（如：<code>x1 != x1'</code>），那么这两个子矩阵也不同。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/02/mate1.jpg\" style=\"width: 242px; height: 242px;\" /></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0\n<strong>输出：</strong>4\n<strong>解释：</strong>四个只含 0 的 1x1 子矩阵。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,-1],[-1,1]], target = 0\n<strong>输出：</strong>5\n<strong>解释：</strong>两个 1x2 子矩阵，加上两个 2x1 子矩阵，再加上一个 2x2 子矩阵。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[904]], target = 0\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong><strong>提示：</strong></strong></p>\n\n<ul>\n\t<li><code>1 <= matrix.length <= 100</code></li>\n\t<li><code>1 <= matrix[0].length <= 100</code></li>\n\t<li><code>-1000 <= matrix[i] <= 1000</code></li>\n\t<li><code>-10^8 <= target <= 10^8</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1075项目员工 I",
        "hardRate": "EASY",
        "passRate": "70.12%",
        "problemsUrl": "https://leetcode.cn/problems/project-employees-i/",
        "solutionsUrl": "https://leetcode.cn/problems/project-employees-i/solution",
        "problemsDesc": "<p>项目表&nbsp;<code>Project</code>：&nbsp;</p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| project_id  | int     |\n| employee_id | int     |\n+-------------+---------+\n主键为 (project_id, employee_id)。\nemployee_id 是员工表 <code>Employee 表的外键。</code>\n</pre>\n\n<p>员工表&nbsp;<code>Employee</code>：</p>\n\n<pre>\n+------------------+---------+\n| Column Name      | Type    |\n+------------------+---------+\n| employee_id      | int     |\n| name             | varchar |\n| experience_years | int     |\n+------------------+---------+\n主键是 employee_id。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>请写一个 SQL&nbsp;语句，查询每一个项目中员工的&nbsp;<strong>平均&nbsp;</strong>工作年限，<strong>精确到小数点后两位</strong>。</p>\n\n<p>查询结果的格式如下：</p>\n\n<pre>\nProject 表：\n+-------------+-------------+\n| project_id  | employee_id |\n+-------------+-------------+\n| 1           | 1           |\n| 1           | 2           |\n| 1           | 3           |\n| 2           | 1           |\n| 2           | 4           |\n+-------------+-------------+\n\nEmployee 表：\n+-------------+--------+------------------+\n| employee_id | name   | experience_years |\n+-------------+--------+------------------+\n| 1           | Khaled | 3                |\n| 2           | Ali    | 2                |\n| 3           | John   | 1                |\n| 4           | Doe    | 2                |\n+-------------+--------+------------------+\n\nResult 表：\n+-------------+---------------+\n| project_id  | average_years |\n+-------------+---------------+\n| 1           | 2.00          |\n| 2           | 2.50          |\n+-------------+---------------+\n第一个项目中，员工的平均工作年限是 (3 + 2 + 1) / 3 = 2.00；第二个项目中，员工的平均工作年限是 (3 + 2) / 2 = 2.50\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1076项目员工II",
        "hardRate": "EASY",
        "passRate": "49.36%",
        "problemsUrl": "https://leetcode.cn/problems/project-employees-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/project-employees-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1077项目员工 III",
        "hardRate": "MEDIUM",
        "passRate": "72.32%",
        "problemsUrl": "https://leetcode.cn/problems/project-employees-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/project-employees-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1078Bigram 分词",
        "hardRate": "EASY",
        "passRate": "65.16%",
        "problemsUrl": "https://leetcode.cn/problems/occurrences-after-bigram/",
        "solutionsUrl": "https://leetcode.cn/problems/occurrences-after-bigram/solution",
        "problemsDesc": "<p>给出第一个词&nbsp;<code>first</code> 和第二个词&nbsp;<code>second</code>，考虑在某些文本&nbsp;<code>text</code>&nbsp;中可能以 <code>\"first second third\"</code> 形式出现的情况，其中&nbsp;<code>second</code>&nbsp;紧随&nbsp;<code>first</code>&nbsp;出现，<code>third</code>&nbsp;紧随&nbsp;<code>second</code>&nbsp;出现。</p>\n\n<p>对于每种这样的情况，将第三个词 \"<code>third</code>\" 添加到答案中，并返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = \"alice is a good girl she is a good student\", first = \"a\", second = \"good\"\n<strong>输出：</strong>[\"girl\",\"student\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = \"we will we will rock you\", first = \"we\", second = \"will\"\n<strong>输出：</strong>[\"we\",\"rock\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 1000</code></li>\n\t<li><code>text</code>&nbsp;由小写英文字母和空格组成</li>\n\t<li><code>text</code> 中的所有单词之间都由 <strong>单个空格字符</strong> 分隔</li>\n\t<li><code>1 &lt;= first.length, second.length &lt;= 10</code></li>\n\t<li><code>first</code> 和&nbsp;<code>second</code>&nbsp;由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1079活字印刷",
        "hardRate": "MEDIUM",
        "passRate": "79.09%",
        "problemsUrl": "https://leetcode.cn/problems/letter-tile-possibilities/",
        "solutionsUrl": "https://leetcode.cn/problems/letter-tile-possibilities/solution",
        "problemsDesc": "<p>你有一套活字字模&nbsp;<code>tiles</code>，其中每个字模上都刻有一个字母&nbsp;<code>tiles[i]</code>。返回你可以印出的非空字母序列的数目。</p>\n\n<p><strong>注意：</strong>本题中，每个活字字模只能使用一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\"AAB\"\n<strong>输出：</strong>8\n<strong>解释：</strong>可能的序列为 \"A\", \"B\", \"AA\", \"AB\", \"BA\", \"AAB\", \"ABA\", \"BAA\"。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>\"AAABBC\"\n<strong>输出：</strong>188\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>\"V\"\n<strong>输出：</strong>1</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tiles.length &lt;= 7</code></li>\n\t<li><code>tiles</code> 由大写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1080根到叶路径上的不足节点",
        "hardRate": "MEDIUM",
        "passRate": "61.45%",
        "problemsUrl": "https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/",
        "solutionsUrl": "https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/solution",
        "problemsDesc": "<p>给你二叉树的根节点 <code>root</code> 和一个整数 <code>limit</code> ，请你同时删除树中所有 <strong>不足节点 </strong>，并返回最终二叉树的根节点。</p>\n\n<p>假如通过节点 <code>node</code> 的每种可能的 “根-叶” 路径上值的总和全都小于给定的 <code>limit</code>，则该节点被称之为<strong> 不足节点 </strong>，需要被删除。</p>\n\n<p><strong>叶子节点</strong>，就是没有子节点的节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/06/05/insufficient-11.png\" style=\"width: 500px; height: 207px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1\n<strong>输出：</strong>[1,2,3,4,null,null,7,8,9,null,14]\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/06/05/insufficient-3.png\" style=\"width: 400px; height: 274px;\" />\n<pre>\n<strong>输入：</strong>root = [5,4,8,11,null,17,4,7,1,null,null,5,3], limit = 22\n<strong>输出：</strong>[5,4,8,11,null,17,4,7,null,null,null,5]\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/06/11/screen-shot-2019-06-11-at-83301-pm.png\" style=\"width: 250px; height: 199px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,-3,-5,null,4,null], limit = -1\n<strong>输出：</strong>[1,null,-3,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[1, 5000]</code> 内</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= limit &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1081不同字符的最小子序列",
        "hardRate": "MEDIUM",
        "passRate": "58.39%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters/solution",
        "problemsDesc": "<p>返回 <code>s</code> 字典序最小的子序列，该子序列包含 <code>s</code> 的所有不同字符，且只包含一次。</p>\n\n<p><strong>注意：</strong>该题与 316 <a href=\"https://leetcode.com/problems/remove-duplicate-letters/\">https://leetcode.com/problems/remove-duplicate-letters/</a> 相同</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong><code>s = \"bcabc\"</code>\n<strong>输出<code>：</code></strong><code>\"abc\"</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong><code>s = \"cbacdcbc\"</code>\n<strong>输出：</strong><code>\"acdb\"</code></pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 1000</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1082销售分析 I ",
        "hardRate": "EASY",
        "passRate": "76.55%",
        "problemsUrl": "https://leetcode.cn/problems/sales-analysis-i/",
        "solutionsUrl": "https://leetcode.cn/problems/sales-analysis-i/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1083销售分析 II",
        "hardRate": "EASY",
        "passRate": "52.98%",
        "problemsUrl": "https://leetcode.cn/problems/sales-analysis-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/sales-analysis-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1084销售分析III",
        "hardRate": "EASY",
        "passRate": "52.16%",
        "problemsUrl": "https://leetcode.cn/problems/sales-analysis-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/sales-analysis-iii/solution",
        "problemsDesc": "<p>Table:&nbsp;<code>Product</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| product_id   | int     |\n| product_name | varchar |\n| unit_price   | int     |\n+--------------+---------+\nProduct_id是该表的主键。\n该表的每一行显示每个产品的名称和价格。\n</pre>\n\n<p>Table:&nbsp;<code>Sales</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| seller_id   | int     |\n| product_id  | int     |\n| buyer_id    | int     |\n| sale_date   | date    |\n| quantity    | int     |\n| price       | int     |\n+------ ------+---------+\n这个表没有主键，它可以有重复的行。\nproduct_id 是 Product 表的外键。\n该表的每一行包含关于一个销售的一些信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个SQL查询，报告<code>2019年春季</code>才售出的产品。即<strong>仅</strong>在<code><strong>2019-01-01</strong></code>至<code><strong>2019-03-31</strong></code>（含）之间出售的商品。</p>\n\n<p>以 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nProduct table:\n+------------+--------------+------------+\n| product_id | product_name | unit_price |\n+------------+--------------+------------+\n| 1          | S8           | 1000       |\n| 2          | G4           | 800        |\n| 3          | iPhone       | 1400       |\n+------------+--------------+------------+\n<code>Sales </code>table:\n+-----------+------------+----------+------------+----------+-------+\n| seller_id | product_id | buyer_id | sale_date  | quantity | price |\n+-----------+------------+----------+------------+----------+-------+\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\n| 2         | 2          | 3        | 2019-06-02 | 1        | 800   |\n| 3         | 3          | 4        | 2019-05-13 | 2        | 2800  |\n+-----------+------------+----------+------------+----------+-------+\n<strong>输出：</strong>\n+-------------+--------------+\n| product_id  | product_name |\n+-------------+--------------+\n| 1           | S8           |\n+-------------+--------------+\n<strong>解释:</strong>\nid为1的产品仅在2019年春季销售。\nid为2的产品在2019年春季销售，但也在2019年春季之后销售。\nid 3的产品在2019年春季之后销售。\n我们只退回产品1，因为它是2019年春季才销售的产品。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1085最小元素各数位之和",
        "hardRate": "EASY",
        "passRate": "77.93%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-digits-in-the-minimum-number/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-digits-in-the-minimum-number/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1086前五科的均分",
        "hardRate": "EASY",
        "passRate": "67.82%",
        "problemsUrl": "https://leetcode.cn/problems/high-five/",
        "solutionsUrl": "https://leetcode.cn/problems/high-five/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1087花括号展开",
        "hardRate": "MEDIUM",
        "passRate": "56.82%",
        "problemsUrl": "https://leetcode.cn/problems/brace-expansion/",
        "solutionsUrl": "https://leetcode.cn/problems/brace-expansion/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1088易混淆数 II",
        "hardRate": "HARD",
        "passRate": "49.88%",
        "problemsUrl": "https://leetcode.cn/problems/confusing-number-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/confusing-number-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1089复写零",
        "hardRate": "EASY",
        "passRate": "60.11%",
        "problemsUrl": "https://leetcode.cn/problems/duplicate-zeros/",
        "solutionsUrl": "https://leetcode.cn/problems/duplicate-zeros/solution",
        "problemsDesc": "<p>给你一个长度固定的整数数组&nbsp;<code>arr</code> ，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。</p>\n\n<p>注意：请不要在超过该数组长度的位置写入元素。请对输入的数组&nbsp;<strong>就地&nbsp;</strong>进行上述修改，不要从函数返回任何东西。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,0,2,3,0,4,5,0]\n<strong>输出：</strong>[1,0,0,2,3,0,0,4]\n<strong>解释：</strong>调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3]\n<strong>输出：</strong>[1,2,3]\n<strong>解释：</strong>调用函数后，输入的数组将被修改为：[1,2,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1090受标签影响的最大值",
        "hardRate": "MEDIUM",
        "passRate": "66.86%",
        "problemsUrl": "https://leetcode.cn/problems/largest-values-from-labels/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-values-from-labels/solution",
        "problemsDesc": "<p>我们有一个&nbsp;<code>n</code>&nbsp;项的集合。给出两个整数数组&nbsp;<code>values</code>&nbsp;和 <code>labels</code>&nbsp;，第 <code>i</code> 个元素的值和标签分别是&nbsp;<code>values[i]</code>&nbsp;和&nbsp;<code>labels[i]</code>。还会给出两个整数&nbsp;<code>numWanted</code>&nbsp;和 <code>useLimit</code> 。</p>\n\n<p>从 <code>n</code> 个元素中选择一个子集 <code>s</code> :</p>\n\n<ul>\n\t<li>子集 <code>s</code> 的大小&nbsp;<strong>小于或等于</strong> <code>numWanted</code> 。</li>\n\t<li><code>s</code> 中 <strong>最多</strong> 有相同标签的 <code>useLimit</code> 项。</li>\n</ul>\n\n<p>一个子集的&nbsp;<strong>分数&nbsp;</strong>是该子集的值之和。</p>\n\n<p>返回子集&nbsp;<code>s</code> 的最大 <strong>分数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>values = [5,4,3,2,1], labels = [1,1,2,2,3], numWanted = 3, useLimit = 1\n<strong>输出：</strong>9\n<strong>解释：</strong>选出的子集是第一项，第三项和第五项。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>values = [5,4,3,2,1], labels = [1,3,3,3,2], numWanted = 3, useLimit = 2\n<strong>输出：</strong>12\n<strong>解释：</strong>选出的子集是第一项，第二项和第三项。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>values = [9,8,8,7,6], labels = [0,0,0,1,1], numWanted = 3, useLimit = 1\n<strong>输出：</strong>16\n<strong>解释：</strong>选出的子集是第一项和第四项。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == values.length == labels.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= values[i], labels[i] &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= numWanted, useLimit &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1091二进制矩阵中的最短路径",
        "hardRate": "MEDIUM",
        "passRate": "40.37%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-path-in-binary-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-path-in-binary-matrix/solution",
        "problemsDesc": "<p>给你一个 <code>n x n</code> 的二进制矩阵 <code>grid</code> 中，返回矩阵中最短 <strong>畅通路径</strong> 的长度。如果不存在这样的路径，返回 <code>-1</code> 。</p>\n\n<p>二进制矩阵中的 畅通路径 是一条从 <strong>左上角</strong> 单元格（即，<code>(0, 0)</code>）到 右下角 单元格（即，<code>(n - 1, n - 1)</code>）的路径，该路径同时满足下述要求：</p>\n\n<ul>\n\t<li>路径途经的所有单元格的值都是 <code>0</code> 。</li>\n\t<li>路径中所有相邻的单元格应当在 <strong>8 个方向之一</strong> 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。</li>\n</ul>\n\n<p><strong>畅通路径的长度</strong> 是该路径途经的单元格总数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/example1_1.png\" style=\"width: 500px; height: 234px;\" />\n<pre>\n<strong>输入：</strong>grid = [[0,1],[1,0]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/example2_1.png\" style=\"height: 216px; width: 500px;\" />\n<pre>\n<strong>输入：</strong>grid = [[0,0,0],[1,1,0],[1,1,0]]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,0,0],[1,1,0],[1,1,0]]\n<strong>输出：</strong>-1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1092最短公共超序列",
        "hardRate": "HARD",
        "passRate": "58.45%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-common-supersequence/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-common-supersequence/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>str1</code> 和&nbsp;<code>str2</code>，返回同时以&nbsp;<code>str1</code>&nbsp;和&nbsp;<code>str2</code>&nbsp;作为 <strong>子序列</strong> 的最短字符串。如果答案不止一个，则可以返回满足条件的 <strong>任意一个</strong> 答案。</p>\n\n<p>如果从字符串 <code>t</code> 中删除一些字符（也可能不删除），可以得到字符串 <code>s</code> ，那么 <code>s</code> 就是 t 的一个子序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>str1 = \"abac\", str2 = \"cab\"\n<strong>输出：</strong>\"cabac\"\n<strong>解释：</strong>\nstr1 = \"abac\" 是 \"cabac\" 的一个子串，因为我们可以删去 \"cabac\" 的第一个 \"c\"得到 \"abac\"。 \nstr2 = \"cab\" 是 \"cabac\" 的一个子串，因为我们可以删去 \"cabac\" 末尾的 \"ac\" 得到 \"cab\"。\n最终我们给出的答案是满足上述属性的最短字符串。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>str1 = \"aaaaaaaa\", str2 = \"aaaaaaaa\"\n<strong>输出：</strong>\"aaaaaaaa\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= str1.length, str2.length &lt;= 1000</code></li>\n\t<li><code>str1</code> 和&nbsp;<code>str2</code>&nbsp;都由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1093大样本统计",
        "hardRate": "MEDIUM",
        "passRate": "41.92%",
        "problemsUrl": "https://leetcode.cn/problems/statistics-from-a-large-sample/",
        "solutionsUrl": "https://leetcode.cn/problems/statistics-from-a-large-sample/solution",
        "problemsDesc": "<p>我们对&nbsp;<code>0</code>&nbsp;到&nbsp;<code>255</code>&nbsp;之间的整数进行采样，并将结果存储在数组&nbsp;<code>count</code>&nbsp;中：<code>count[k]</code>&nbsp;就是整数&nbsp;<code>k</code> 在样本中出现的次数。</p>\n\n<p>计算以下统计数据:</p>\n\n<ul>\n\t<li><code>minimum</code>&nbsp;：样本中的最小元素。</li>\n\t<li><code>maximum</code>&nbsp;：样品中的最大元素。</li>\n\t<li><code>mean</code>&nbsp;：样本的平均值，计算为所有元素的总和除以元素总数。</li>\n\t<li><code>median</code>&nbsp;：\n\t<ul>\n\t\t<li>如果样本的元素个数是奇数，那么一旦样本排序后，中位数 <code>median</code> 就是中间的元素。</li>\n\t\t<li>如果样本中有偶数个元素，那么中位数<code>median</code> 就是样本排序后中间两个元素的平均值。</li>\n\t</ul>\n\t</li>\n\t<li><code>mode</code>&nbsp;：样本中出现次数最多的数字。保众数是 <strong>唯一</strong> 的。</li>\n</ul>\n\n<p>以浮点数数组的形式返回样本的统计信息<em>&nbsp;</em><code>[minimum, maximum, mean, median, mode]</code>&nbsp;。与真实答案误差在<em>&nbsp;</em><code>10<sup>-5</sup></code><em>&nbsp;</em>内的答案都可以通过。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n<strong>输出：</strong>[1.00000,3.00000,2.37500,2.50000,3.00000]\n<strong>解释：</strong>用count表示的样本为[1,2,2,2,3,3,3,3]。\n最小值和最大值分别为1和3。\n均值是(1+2+2+2+3+3+3+3) / 8 = 19 / 8 = 2.375。\n因为样本的大小是偶数，所以中位数是中间两个元素2和3的平均值，也就是2.5。\n众数为3，因为它在样本中出现的次数最多。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n<strong>输出：</strong>[1.00000,4.00000,2.18182,2.00000,1.00000]\n<strong>解释：</strong>用count表示的样本为[1,1,1,1,2,2,3,3,3,4,4]。\n最小值为1，最大值为4。\n平均数是(1+1+1+1+2+2+2+3+3+4+4)/ 11 = 24 / 11 = 2.18181818…(为了显示，输出显示了整数2.18182)。\n因为样本的大小是奇数，所以中值是中间元素2。\n众数为1，因为它在样本中出现的次数最多。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>count.length == 256</code></li>\n\t<li><code>0 &lt;= count[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= sum(count) &lt;= 10<sup>9</sup></code></li>\n\t<li>&nbsp;<code>count</code>&nbsp;的众数是 <strong>唯一</strong> 的</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1094拼车",
        "hardRate": "MEDIUM",
        "passRate": "51.75%",
        "problemsUrl": "https://leetcode.cn/problems/car-pooling/",
        "solutionsUrl": "https://leetcode.cn/problems/car-pooling/solution",
        "problemsDesc": "<p>车上最初有&nbsp;<code>capacity</code>&nbsp;个空座位。车&nbsp;<strong>只能&nbsp;</strong>向一个方向行驶（也就是说，<strong>不允许掉头或改变方向</strong>）</p>\n\n<p>给定整数&nbsp;<code>capacity</code>&nbsp;和一个数组 <code>trips</code> , &nbsp;<code>trip[i] = [numPassengers<sub>i</sub>, from<sub>i</sub>, to<sub>i</sub>]</code>&nbsp;表示第 <code>i</code> 次旅行有&nbsp;<code>numPassengers<sub>i</sub></code>&nbsp;乘客，接他们和放他们的位置分别是&nbsp;<code>from<sub>i</sub></code>&nbsp;和&nbsp;<code>to<sub>i</sub></code>&nbsp;。这些位置是从汽车的初始位置向东的公里数。</p>\n\n<p>当且仅当你可以在所有给定的行程中接送所有乘客时，返回&nbsp;<code>true</code>，否则请返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>trips = [[2,1,5],[3,3,7]], capacity = 4\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>trips = [[2,1,5],[3,3,7]], capacity = 5\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= trips.length &lt;= 1000</code></li>\n\t<li><code>trips[i].length == 3</code></li>\n\t<li><code>1 &lt;= numPassengers<sub>i</sub>&nbsp;&lt;= 100</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub>&nbsp;&lt; to<sub>i</sub>&nbsp;&lt;= 1000</code></li>\n\t<li><code>1 &lt;= capacity &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1095山脉数组中查找目标值",
        "hardRate": "HARD",
        "passRate": "37.73%",
        "problemsUrl": "https://leetcode.cn/problems/find-in-mountain-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-in-mountain-array/solution",
        "problemsDesc": "<p>（这是一个 <strong>交互式问题&nbsp;</strong>）</p>\n\n<p>给你一个 <strong>山脉数组</strong>&nbsp;<code>mountainArr</code>，请你返回能够使得&nbsp;<code>mountainArr.get(index)</code>&nbsp;<strong>等于</strong>&nbsp;<code>target</code>&nbsp;<strong>最小</strong>&nbsp;的下标 <code>index</code>&nbsp;值。</p>\n\n<p>如果不存在这样的下标 <code>index</code>，就请返回&nbsp;<code>-1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p>何为山脉数组？如果数组&nbsp;<code>A</code> 是一个山脉数组的话，那它满足如下条件：</p>\n\n<p><strong>首先</strong>，<code>A.length &gt;= 3</code></p>\n\n<p><strong>其次</strong>，在&nbsp;<code>0 &lt; i&nbsp;&lt; A.length - 1</code>&nbsp;条件下，存在 <code>i</code> 使得：</p>\n\n<ul>\n\t<li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li>\n\t<li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>你将&nbsp;<strong>不能直接访问该山脉数组</strong>，必须通过&nbsp;<code>MountainArray</code>&nbsp;接口来获取数据：</p>\n\n<ul>\n\t<li><code>MountainArray.get(k)</code>&nbsp;- 会返回数组中索引为<code>k</code>&nbsp;的元素（下标从 0 开始）</li>\n\t<li><code>MountainArray.length()</code>&nbsp;- 会返回该数组的长度</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong></p>\n\n<p>对&nbsp;<code>MountainArray.get</code>&nbsp;发起超过 <code>100</code> 次调用的提交将被视为错误答案。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。</p>\n\n<p>为了帮助大家更好地理解交互式问题，我们准备了一个样例 &ldquo;<strong>答案</strong>&rdquo;：<a href=\"https://leetcode-cn.com/playground/RKhe3ave\" target=\"_blank\">https://leetcode-cn.com/playground/RKhe3ave</a>，请注意这 <strong>不是一个正确答案</strong>。</p>\n\n<ol>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>array = [1,2,3,4,5,3,1], target = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>array = [0,1,2,4,2,1], target = 3\n<strong>输出：</strong>-1\n<strong>解释：</strong>3 在数组中没有出现，返回 -1。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= mountain_arr.length() &lt;= 10000</code></li>\n\t<li><code>0 &lt;= target &lt;= 10^9</code></li>\n\t<li><code>0 &lt;= mountain_arr.get(index) &lt;=&nbsp;10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1096花括号展开 II",
        "hardRate": "HARD",
        "passRate": "73.53%",
        "problemsUrl": "https://leetcode.cn/problems/brace-expansion-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/brace-expansion-ii/solution",
        "problemsDesc": "<p>如果你熟悉 Shell 编程，那么一定了解过花括号展开，它可以用来生成任意字符串。</p>\n\n<p>花括号展开的表达式可以看作一个由 <strong>花括号</strong>、<strong>逗号</strong> 和 <strong>小写英文字母</strong> 组成的字符串，定义下面几条语法规则：</p>\n\n<ul>\n\t<li>如果只给出单一的元素&nbsp;<code>x</code>，那么表达式表示的字符串就只有&nbsp;<code>\"x\"</code>。<code>R(x) = {x}</code>\n\n\t<ul>\n\t\t<li>例如，表达式 <code>\"a\"</code> 表示字符串 <code>\"a\"</code>。</li>\n\t\t<li>而表达式 <code>\"w\"</code> 就表示字符串 <code>\"w\"</code>。</li>\n\t</ul>\n\t</li>\n\t<li>当两个或多个表达式并列，以逗号分隔，我们取这些表达式中元素的并集。<code>R({e_1,e_2,...}) = R(e_1)&nbsp;∪ R(e_2)&nbsp;∪ ...</code>\n\t<ul>\n\t\t<li>例如，表达式 <code>\"{a,b,c}\"</code> 表示字符串&nbsp;<code>\"a\",\"b\",\"c\"</code>。</li>\n\t\t<li>而表达式 <code>\"{{a,b},{b,c}}\"</code> 也可以表示字符串&nbsp;<code>\"a\",\"b\",\"c\"</code>。</li>\n\t</ul>\n\t</li>\n\t<li>要是两个或多个表达式相接，中间没有隔开时，我们从这些表达式中各取一个元素依次连接形成字符串。<code>R(e_1 + e_2) = {a + b for (a, b) in&nbsp;R(e_1)&nbsp;× R(e_2)}</code>\n\t<ul>\n\t\t<li>例如，表达式 <code>\"{a,b}{c,d}\"</code> 表示字符串&nbsp;<code>\"ac\",\"ad\",\"bc\",\"bd\"</code>。</li>\n\t</ul>\n\t</li>\n\t<li>表达式之间允许嵌套，单一元素与表达式的连接也是允许的。\n\t<ul>\n\t\t<li>例如，表达式 <code>\"a{b,c,d}\"</code> 表示字符串&nbsp;<code>\"ab\",\"ac\",\"ad\"​​​​​​</code>。</li>\n\t\t<li>例如，表达式 <code>\"a{b,c}{d,e}f{g,h}\"</code> 可以表示字符串&nbsp;<code>\"abdfg\", \"abdfh\", \"abefg\", \"abefh\", \"acdfg\", \"acdfh\", \"acefg\", \"acefh\"</code>。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>给出表示基于给定语法规则的表达式&nbsp;<code>expression</code>，返回它所表示的所有字符串组成的有序列表。</p>\n\n<p>假如你希望以「集合」的概念了解此题，也可以通过点击 “<strong>显示英文描述</strong>” 获取详情。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"{a,b}{c,{d,e}}\"\n<strong>输出：</strong>[\"ac\",\"ad\",\"ae\",\"bc\",\"bd\",\"be\"]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"{{a,z},a{b,c},{ab,z}}\"\n<strong>输出：</strong>[\"a\",\"ab\",\"ac\",\"z\"]\n<strong>解释：</strong>输出中 <strong>不应 </strong>出现重复的组合结果。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= expression.length &lt;= 60</code></li>\n\t<li><code>expression[i]</code> 由 <code>'{'</code>，<code>'}'</code>，<code>','</code>&nbsp;或小写英文字母组成</li>\n\t<li>给出的表达式&nbsp;<code>expression</code>&nbsp;用以表示一组基于题目描述中语法构造的字符串</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1097游戏玩法分析 V",
        "hardRate": "HARD",
        "passRate": "52.38%",
        "problemsUrl": "https://leetcode.cn/problems/game-play-analysis-v/",
        "solutionsUrl": "https://leetcode.cn/problems/game-play-analysis-v/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1098小众书籍",
        "hardRate": "MEDIUM",
        "passRate": "47.16%",
        "problemsUrl": "https://leetcode.cn/problems/unpopular-books/",
        "solutionsUrl": "https://leetcode.cn/problems/unpopular-books/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1099小于 K 的两数之和",
        "hardRate": "EASY",
        "passRate": "59.85%",
        "problemsUrl": "https://leetcode.cn/problems/two-sum-less-than-k/",
        "solutionsUrl": "https://leetcode.cn/problems/two-sum-less-than-k/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1100长度为 K 的无重复字符子串",
        "hardRate": "MEDIUM",
        "passRate": "69.86%",
        "problemsUrl": "https://leetcode.cn/problems/find-k-length-substrings-with-no-repeated-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/find-k-length-substrings-with-no-repeated-characters/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1101彼此熟识的最早时间",
        "hardRate": "MEDIUM",
        "passRate": "68.84%",
        "problemsUrl": "https://leetcode.cn/problems/the-earliest-moment-when-everyone-become-friends/",
        "solutionsUrl": "https://leetcode.cn/problems/the-earliest-moment-when-everyone-become-friends/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1102得分最高的路径",
        "hardRate": "MEDIUM",
        "passRate": "40.21%",
        "problemsUrl": "https://leetcode.cn/problems/path-with-maximum-minimum-value/",
        "solutionsUrl": "https://leetcode.cn/problems/path-with-maximum-minimum-value/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1103分糖果 II",
        "hardRate": "EASY",
        "passRate": "63.72%",
        "problemsUrl": "https://leetcode.cn/problems/distribute-candies-to-people/",
        "solutionsUrl": "https://leetcode.cn/problems/distribute-candies-to-people/solution",
        "problemsDesc": "<p>排排坐，分糖果。</p>\n\n<p>我们买了一些糖果 <code>candies</code>，打算把它们分给排好队的 <strong><code>n = num_people</code></strong> 个小朋友。</p>\n\n<p>给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 <code>n</code>&nbsp;颗糖果。</p>\n\n<p>然后，我们再回到队伍的起点，给第一个小朋友 <code>n&nbsp;+ 1</code> 颗糖果，第二个小朋友 <code>n&nbsp;+ 2</code> 颗，依此类推，直到给最后一个小朋友 <code>2 * n</code>&nbsp;颗糖果。</p>\n\n<p>重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。</p>\n\n<p>返回一个长度为 <code>num_people</code>、元素之和为 <code>candies</code> 的数组，以表示糖果的最终分发情况（即 <code>ans[i]</code> 表示第 <code>i</code> 个小朋友分到的糖果数）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>candies = 7, num_people = 4\n<strong>输出：</strong>[1,2,3,1]\n<strong>解释：</strong>\n第一次，ans[0] += 1，数组变为 [1,0,0,0]。\n第二次，ans[1] += 2，数组变为 [1,2,0,0]。\n第三次，ans[2] += 3，数组变为 [1,2,3,0]。\n第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>candies = 10, num_people = 3\n<strong>输出：</strong>[5,2,3]\n<strong>解释：</strong>\n第一次，ans[0] += 1，数组变为 [1,0,0]。\n第二次，ans[1] += 2，数组变为 [1,2,0]。\n第三次，ans[2] += 3，数组变为 [1,2,3]。\n第四次，ans[0] += 4，最终数组变为 [5,2,3]。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= candies &lt;= 10^9</code></li>\n\t<li><code>1 &lt;= num_people &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1104二叉树寻路",
        "hardRate": "MEDIUM",
        "passRate": "75.86%",
        "problemsUrl": "https://leetcode.cn/problems/path-in-zigzag-labelled-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/path-in-zigzag-labelled-binary-tree/solution",
        "problemsDesc": "<p>在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 <strong>逐行</strong> 依次按&nbsp;&ldquo;之&rdquo; 字形进行标记。</p>\n\n<p>如下图所示，在奇数行（即，第一行、第三行、第五行&hellip;&hellip;）中，按从左到右的顺序进行标记；</p>\n\n<p>而偶数行（即，第二行、第四行、第六行&hellip;&hellip;）中，按从右到左的顺序进行标记。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/06/28/tree.png\" style=\"height: 138px; width: 300px;\"></p>\n\n<p>给你树上某一个节点的标号 <code>label</code>，请你返回从根节点到该标号为 <code>label</code> 节点的路径，该路径是由途经的节点标号所组成的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>label = 14\n<strong>输出：</strong>[1,3,4,14]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>label = 26\n<strong>输出：</strong>[1,2,6,10,26]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= label &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1105填充书架",
        "hardRate": "MEDIUM",
        "passRate": "67.24%",
        "problemsUrl": "https://leetcode.cn/problems/filling-bookcase-shelves/",
        "solutionsUrl": "https://leetcode.cn/problems/filling-bookcase-shelves/solution",
        "problemsDesc": "<p>给定一个数组 <code>books</code> ，其中&nbsp;<code>books[i] = [thickness<sub>i</sub>, height<sub>i</sub>]</code>&nbsp;表示第 <code>i</code> 本书的厚度和高度。你也会得到一个整数 <code>shelfWidth</code> 。</p>\n\n<p><strong>按顺序</strong>&nbsp;将这些书摆放到总宽度为 <code>shelfWidth</code> 的书架上。</p>\n\n<p>先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 <code>shelfWidth</code> ），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。</p>\n\n<p>需要注意的是，在上述过程的每个步骤中，<strong>摆放书的顺序与给定图书数组 </strong><code>books</code><strong> 顺序相同</strong>。</p>\n\n<ul>\n\t<li>例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。</li>\n</ul>\n\n<p>每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。</p>\n\n<p>以这种方式布置书架，返回书架整体可能的最小高度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2019/06/24/shelves.png\" style=\"width: 337px; height: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelfWidth = 4\n<strong>输出：</strong>6\n<strong>解释：</strong>\n3 层书架的高度和为 1 + 3 + 2 = 6 。\n第 2 本书不必放在第一层书架上。\n</pre>\n\n<p><strong class=\"example\">示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> books = [[1,3],[2,4],[3,2]], shelfWidth = 6\n<strong>输出:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= books.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= thickness<sub>i</sub>&nbsp;&lt;= shelfWidth &lt;= 1000</code></li>\n\t<li><code>1 &lt;= height<sub>i</sub>&nbsp;&lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1106解析布尔表达式",
        "hardRate": "HARD",
        "passRate": "68.54%",
        "problemsUrl": "https://leetcode.cn/problems/parsing-a-boolean-expression/",
        "solutionsUrl": "https://leetcode.cn/problems/parsing-a-boolean-expression/solution",
        "problemsDesc": "<p><strong>布尔表达式</strong> 是计算结果不是 <code>true</code> 就是 <code>false</code> 的表达式。有效的表达式需遵循以下约定：</p>\n\n<ul>\n\t<li><code>'t'</code>，运算结果为 <code>true</code></li>\n\t<li><code>'f'</code>，运算结果为 <code>false</code></li>\n\t<li><code>'!(subExpr)'</code>，运算过程为对内部表达式 <code>subExpr</code> 进行 <strong>逻辑非</strong>（NOT）运算</li>\n\t<li><code>'&amp;(subExpr<sub>1</sub>, subExpr<sub>2</sub>, ..., subExpr<sub>n</sub>)'</code>，运算过程为对 2 个或以上内部表达式 <code>subExpr<sub>1</sub>, subExpr<sub>2</sub>, ..., subExpr<sub>n</sub></code> 进行 <strong>逻辑与</strong>（AND）运算</li>\n\t<li><code>'|(subExpr<sub>1</sub>, subExpr<sub>2</sub>, ..., subExpr<sub>n</sub>)'</code>，运算过程为对 2 个或以上内部表达式 <code>subExpr<sub>1</sub>, subExpr<sub>2</sub>, ..., subExpr<sub>n</sub></code> 进行 <strong>逻辑或</strong>（OR）运算</li>\n</ul>\n\n<p>给你一个以字符串形式表述的&nbsp;<a href=\"https://baike.baidu.com/item/%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F/1574380?fr=aladdin\" target=\"_blank\">布尔表达式</a> <code>expression</code>，返回该式的运算结果。</p>\n\n<p>题目测试用例所给出的表达式均为有效的布尔表达式，遵循上述约定。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"&amp;(|(f))\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\n首先，计算 |(f) --&gt; f ，表达式变为 \"&amp;(f)\" 。\n接着，计算 &amp;(f) --&gt; f ，表达式变为 \"f\" 。\n最后，返回 false 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"|(f,f,f,t)\"\n<strong>输出：</strong>true\n<strong>解释：</strong>计算 (false OR false OR false OR true) ，结果为 true 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"!(&amp;(f,t))\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\n首先，计算 &amp;(f,t) --&gt; (false AND true) --&gt; false --&gt; f ，表达式变为 \"!(f)\" 。\n接着，计算 !(f) --&gt; NOT false --&gt; true ，返回 true 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= expression.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>expression[i]</code> 为 <code>'('</code>、<code>')'</code>、<code>'&amp;'</code>、<code>'|'</code>、<code>'!'</code>、<code>'t'</code>、<code>'f'</code> 和 <code>','</code> 之一</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1107每日新用户统计",
        "hardRate": "MEDIUM",
        "passRate": "41.19%",
        "problemsUrl": "https://leetcode.cn/problems/new-users-daily-count/",
        "solutionsUrl": "https://leetcode.cn/problems/new-users-daily-count/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1108IP 地址无效化",
        "hardRate": "EASY",
        "passRate": "85.40%",
        "problemsUrl": "https://leetcode.cn/problems/defanging-an-ip-address/",
        "solutionsUrl": "https://leetcode.cn/problems/defanging-an-ip-address/solution",
        "problemsDesc": "<p>给你一个有效的 <a href=\"https://baike.baidu.com/item/IPv4\" target=\"_blank\">IPv4</a> 地址&nbsp;<code>address</code>，返回这个 IP 地址的无效化版本。</p>\n\n<p>所谓无效化&nbsp;IP 地址，其实就是用&nbsp;<code>&quot;[.]&quot;</code>&nbsp;代替了每个 <code>&quot;.&quot;</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>address = &quot;1.1.1.1&quot;\n<strong>输出：</strong>&quot;1[.]1[.]1[.]1&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>address = &quot;255.100.50.0&quot;\n<strong>输出：</strong>&quot;255[.]100[.]50[.]0&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给出的&nbsp;<code>address</code>&nbsp;是一个有效的 IPv4 地址</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1109航班预订统计",
        "hardRate": "MEDIUM",
        "passRate": "63.61%",
        "problemsUrl": "https://leetcode.cn/problems/corporate-flight-bookings/",
        "solutionsUrl": "https://leetcode.cn/problems/corporate-flight-bookings/solution",
        "problemsDesc": "<p>这里有&nbsp;<code>n</code>&nbsp;个航班，它们分别从 <code>1</code> 到 <code>n</code> 进行编号。</p>\n\n<p>有一份航班预订表&nbsp;<code>bookings</code> ，表中第&nbsp;<code>i</code>&nbsp;条预订记录&nbsp;<code>bookings[i] = [first<sub>i</sub>, last<sub>i</sub>, seats<sub>i</sub>]</code>&nbsp;意味着在从 <code>first<sub>i</sub></code>&nbsp;到 <code>last<sub>i</sub></code> （<strong>包含</strong> <code>first<sub>i</sub></code> 和 <code>last<sub>i</sub></code> ）的 <strong>每个航班</strong> 上预订了 <code>seats<sub>i</sub></code>&nbsp;个座位。</p>\n\n<p>请你返回一个长度为 <code>n</code> 的数组&nbsp;<code>answer</code>，里面的元素是每个航班预定的座位总数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5\n<strong>输出：</strong>[10,55,45,25,25]\n<strong>解释：</strong>\n航班编号        1   2   3   4   5\n预订记录 1 ：   10  10\n预订记录 2 ：       20  20\n预订记录 3 ：       25  25  25  25\n总座位数：      10  55  45  25  25\n因此，answer = [10,55,45,25,25]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>bookings = [[1,2,10],[2,2,15]], n = 2\n<strong>输出：</strong>[10,25]\n<strong>解释：</strong>\n航班编号        1   2\n预订记录 1 ：   10  10\n预订记录 2 ：       15\n总座位数：      10  25\n因此，answer = [10,25]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= bookings.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>bookings[i].length == 3</code></li>\n\t<li><code>1 &lt;= first<sub>i</sub> &lt;= last<sub>i</sub> &lt;= n</code></li>\n\t<li><code>1 &lt;= seats<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1110删点成林",
        "hardRate": "MEDIUM",
        "passRate": "69.39%",
        "problemsUrl": "https://leetcode.cn/problems/delete-nodes-and-return-forest/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-nodes-and-return-forest/solution",
        "problemsDesc": "<p>给出二叉树的根节点&nbsp;<code>root</code>，树上每个节点都有一个不同的值。</p>\n\n<p>如果节点值在&nbsp;<code>to_delete</code>&nbsp;中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。</p>\n\n<p>返回森林中的每棵树。你可以按任意顺序组织答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/05/screen-shot-2019-07-01-at-53836-pm.png\" style=\"height: 150px; width: 237px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,5,6,7], to_delete = [3,5]\n<strong>输出：</strong>[[1,2,null,4],[6],[7]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,4,null,3], to_delete = [3]\n<strong>输出：</strong>[[1,2,4]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数最大为&nbsp;<code>1000</code>。</li>\n\t<li>每个节点都有一个介于&nbsp;<code>1</code> 到&nbsp;<code>1000</code>&nbsp;之间的值，且各不相同。</li>\n\t<li><code>to_delete.length &lt;= 1000</code></li>\n\t<li><code>to_delete</code> 包含一些从&nbsp;<code>1</code> 到&nbsp;<code>1000</code>、各不相同的值。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1111有效括号的嵌套深度",
        "hardRate": "MEDIUM",
        "passRate": "76.80%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solution",
        "problemsDesc": "<p><strong>有效括号字符串 </strong>定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「<strong>有效括号字符串</strong>」部分。</p>\n\n<p><strong>嵌套深度</strong> <code>depth</code> 定义：即有效括号字符串嵌套的层数，<code>depth(A)</code> 表示有效括号字符串 <code>A</code> 的嵌套深度。详情参见题末「<strong>嵌套深度</strong>」部分。</p>\n\n<p>有效括号字符串类型与对应的嵌套深度计算方法如下图所示：</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/01/1111.png\" style=\"height: 152px; width: 600px;\"></p>\n\n<p>&nbsp;</p>\n\n<p>给你一个「有效括号字符串」 <code>seq</code>，请你将其分成两个不相交的有效括号字符串，<code>A</code> 和&nbsp;<code>B</code>，并使这两个字符串的深度最小。</p>\n\n<ul>\n\t<li>不相交：每个 <code>seq[i]</code> 只能分给 <code>A</code> 和 <code>B</code> 二者中的一个，不能既属于 <code>A</code> 也属于 <code>B</code> 。</li>\n\t<li><code>A</code> 或 <code>B</code> 中的元素在原字符串中可以不连续。</li>\n\t<li><code>A.length + B.length = seq.length</code></li>\n\t<li>深度最小：<code>max(depth(A), depth(B))</code>&nbsp;的可能取值最小。&nbsp;</li>\n</ul>\n\n<p>划分方案用一个长度为 <code>seq.length</code> 的答案数组 <code>answer</code> 表示，编码规则如下：</p>\n\n<ul>\n\t<li><code>answer[i] = 0</code>，<code>seq[i]</code> 分给 <code>A</code> 。</li>\n\t<li><code>answer[i] = 1</code>，<code>seq[i]</code> 分给 <code>B</code> 。</li>\n</ul>\n\n<p>如果存在多个满足要求的答案，只需返回其中任意 <strong>一个 </strong>即可。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>seq = &quot;(()())&quot;\n<strong>输出：</strong>[0,1,1,1,1,0]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>seq = &quot;()(())()&quot;\n<strong>输出：</strong>[0,0,0,1,1,0,1,1]\n<strong>解释：</strong>本示例答案不唯一。\n按此输出 A = &quot;()()&quot;, B = &quot;()()&quot;, max(depth(A), depth(B)) = 1，它们的深度最小。\n像 [1,1,1,0,0,1,1,1]，也是正确结果，其中 A = &quot;()()()&quot;, B = &quot;()&quot;, max(depth(A), depth(B)) = 1 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;&nbsp;seq.size &lt;= 10000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>有效括号字符串：</strong></p>\n\n<pre>仅由&nbsp;<code>&quot;(&quot;</code> 和&nbsp;<code>&quot;)&quot;</code>&nbsp;构成的字符串，对于每个左括号，都能找到与之对应的右括号，反之亦然。\n下述几种情况同样属于有效括号字符串：\n\n  1. 空字符串\n  2. 连接，可以记作&nbsp;<code>AB</code>（<code>A</code> 与 <code>B</code> 连接），其中&nbsp;<code>A</code>&nbsp;和&nbsp;<code>B</code>&nbsp;都是有效括号字符串\n  3. 嵌套，可以记作&nbsp;<code>(A)</code>，其中&nbsp;<code>A</code>&nbsp;是有效括号字符串\n</pre>\n\n<p><strong>嵌套深度：</strong></p>\n\n<pre>类似地，我们可以定义任意有效括号字符串 <code>s</code> 的 <strong>嵌套深度</strong>&nbsp;<code>depth(S)</code>：\n\n  1.<code> s</code> 为空时，<code>depth(&quot;&quot;) = 0</code>\n<code>  2. s</code> 为 <code>A</code> 与 <code>B</code> 连接时，<code>depth(A + B) = max(depth(A), depth(B))</code>，其中&nbsp;<code>A</code> 和&nbsp;<code>B</code>&nbsp;都是有效括号字符串\n<code>  3. s</code> 为嵌套情况，<code>depth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A)</code>，其中 <code>A</code> 是有效括号字符串\n\n例如：<code>&quot;&quot;</code>，<code>&quot;()()&quot;</code>，和&nbsp;<code>&quot;()(()())&quot;</code>&nbsp;都是有效括号字符串，嵌套深度分别为 0，1，2，而&nbsp;<code>&quot;)(&quot;</code> 和&nbsp;<code>&quot;(()&quot;</code>&nbsp;都不是有效括号字符串。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1112每位学生的最高成绩",
        "hardRate": "MEDIUM",
        "passRate": "65.93%",
        "problemsUrl": "https://leetcode.cn/problems/highest-grade-for-each-student/",
        "solutionsUrl": "https://leetcode.cn/problems/highest-grade-for-each-student/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1113报告的记录",
        "hardRate": "EASY",
        "passRate": "53.42%",
        "problemsUrl": "https://leetcode.cn/problems/reported-posts/",
        "solutionsUrl": "https://leetcode.cn/problems/reported-posts/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1114按序打印",
        "hardRate": "EASY",
        "passRate": "65.18%",
        "problemsUrl": "https://leetcode.cn/problems/print-in-order/",
        "solutionsUrl": "https://leetcode.cn/problems/print-in-order/solution",
        "problemsDesc": "<p>给你一个类：</p>\n\n<pre>\npublic class Foo {\n&nbsp; public void first() { print(\"first\"); }\n&nbsp; public void second() { print(\"second\"); }\n&nbsp; public void third() { print(\"third\"); }\n}</pre>\n\n<p>三个不同的线程 A、B、C 将会共用一个&nbsp;<code>Foo</code>&nbsp;实例。</p>\n\n<ul>\n\t<li>线程 A 将会调用 <code>first()</code> 方法</li>\n\t<li>线程 B 将会调用&nbsp;<code>second()</code> 方法</li>\n\t<li>线程 C 将会调用 <code>third()</code> 方法</li>\n</ul>\n\n<p>请设计修改程序，以确保 <code>second()</code> 方法在 <code>first()</code> 方法之后被执行，<code>third()</code> 方法在 <code>second()</code> 方法之后被执行。</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。</li>\n\t<li>你看到的输入格式主要是为了确保测试的全面性。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>\"firstsecondthird\"\n<strong>解释：</strong>\n有三个线程会被异步启动。输入 [1,2,3] 表示线程 A 将会调用 first() 方法，线程 B 将会调用 second() 方法，线程 C 将会调用 third() 方法。正确的输出是 \"firstsecondthird\"。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,2]\n<strong>输出：</strong>\"firstsecondthird\"\n<strong>解释：</strong>\n输入 [1,3,2] 表示线程 A 将会调用 first() 方法，线程 B 将会调用 third() 方法，线程 C 将会调用 second() 方法。正确的输出是 \"firstsecondthird\"。</pre>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n<strong>提示：</strong>\n\n<ul>\n\t<li><code>nums</code> 是 <code>[1, 2, 3]</code> 的一组排列</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1115交替打印 FooBar",
        "hardRate": "MEDIUM",
        "passRate": "57.05%",
        "problemsUrl": "https://leetcode.cn/problems/print-foobar-alternately/",
        "solutionsUrl": "https://leetcode.cn/problems/print-foobar-alternately/solution",
        "problemsDesc": "<p>给你一个类：</p>\n\n<pre>\nclass FooBar {\n  public void foo() {\n&nbsp; &nbsp; for (int i = 0; i &lt; n; i++) {\n&nbsp; &nbsp; &nbsp; print(\"foo\");\n&nbsp;   }\n  }\n\n  public void bar() {\n&nbsp; &nbsp; for (int i = 0; i &lt; n; i++) {\n&nbsp; &nbsp; &nbsp; print(\"bar\");\n&nbsp; &nbsp; }\n  }\n}\n</pre>\n\n<p>两个不同的线程将会共用一个 <code>FooBar</code>&nbsp;实例：</p>\n\n<ul>\n\t<li>线程 A 将会调用&nbsp;<code>foo()</code>&nbsp;方法，而</li>\n\t<li>线程 B 将会调用&nbsp;<code>bar()</code>&nbsp;方法</li>\n</ul>\n\n<p>请设计修改程序，以确保 <code>\"foobar\"</code> 被输出 <code>n</code> 次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>\"foobar\"\n<strong>解释：</strong>这里有两个线程被异步启动。其中一个调用 foo() 方法, 另一个调用 bar() 方法，\"foobar\" 将被输出一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>\"foobarfoobar\"\n<strong>解释：</strong>\"foobar\" 将被输出两次。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1116打印零与奇偶数",
        "hardRate": "MEDIUM",
        "passRate": "54.30%",
        "problemsUrl": "https://leetcode.cn/problems/print-zero-even-odd/",
        "solutionsUrl": "https://leetcode.cn/problems/print-zero-even-odd/solution",
        "problemsDesc": "<p>现有函数 <code>printNumber</code> 可以用一个整数参数调用，并输出该整数到控制台。</p>\n\n<ul>\n\t<li>例如，调用 <code>printNumber(7)</code> 将会输出 <code>7</code> 到控制台。</li>\n</ul>\n\n<p>给你类 <code>ZeroEvenOdd</code> 的一个实例，该类中有三个函数：<code>zero</code>、<code>even</code> 和 <code>odd</code> 。<code>ZeroEvenOdd</code> 的相同实例将会传递给三个不同线程：</p>\n\n<ul>\n\t<li><strong>线程 A：</strong>调用 <code>zero()</code> ，只输出 <code>0</code></li>\n\t<li><strong>线程 B：</strong>调用 <code>even()</code> ，只输出偶数</li>\n\t<li><strong>线程 C：</strong>调用 <code>odd()</code> ，只输出奇数</li>\n</ul>\n\n<p>修改给出的类，以输出序列 <code>\"010203040506...\"</code> ，其中序列的长度必须为 <code>2n</code> 。</p>\n\n<p>实现 <code>ZeroEvenOdd</code> 类：</p>\n\n<ul>\n\t<li><code>ZeroEvenOdd(int n)</code> 用数字 <code>n</code> 初始化对象，表示需要输出的数。</li>\n\t<li><code>void zero(printNumber)</code> 调用 <code>printNumber</code> 以输出一个 0 。</li>\n\t<li><code>void even(printNumber)</code> 调用<code>printNumber</code> 以输出偶数。</li>\n\t<li><code>void odd(printNumber)</code> 调用 <code>printNumber</code> 以输出奇数。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>\"0102\"\n<strong>解释：</strong>三条线程异步执行，其中一个调用 zero()，另一个线程调用 even()，最后一个线程调用odd()。正确的输出为 \"0102\"。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>\"0102030405\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1117H2O 生成",
        "hardRate": "MEDIUM",
        "passRate": "53.94%",
        "problemsUrl": "https://leetcode.cn/problems/building-h2o/",
        "solutionsUrl": "https://leetcode.cn/problems/building-h2o/solution",
        "problemsDesc": "<p>现在有两种线程，氧 <code>oxygen</code> 和氢 <code>hydrogen</code>，你的目标是组织这两种线程来产生水分子。</p>\n\n<p>存在一个屏障（barrier）使得每个线程必须等候直到一个完整水分子能够被产生出来。</p>\n\n<p>氢和氧线程会被分别给予 <code>releaseHydrogen</code> 和 <code>releaseOxygen</code> 方法来允许它们突破屏障。</p>\n\n<p>这些线程应该三三成组突破屏障并能立即组合产生一个水分子。</p>\n\n<p>你必须保证产生一个水分子所需线程的结合必须发生在下一个水分子产生之前。</p>\n\n<p>换句话说:</p>\n\n<ul>\n\t<li>如果一个氧线程到达屏障时没有氢线程到达，它必须等候直到两个氢线程到达。</li>\n\t<li>如果一个氢线程到达屏障时没有其它线程到达，它必须等候直到一个氧线程和另一个氢线程到达。</li>\n</ul>\n\n<p>书写满足这些限制条件的氢、氧线程同步代码。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>water = \"HOH\"\n<strong>输出: </strong>\"HHO\"\n<strong>解释:</strong> \"HOH\" 和 \"OHH\" 依然都是有效解。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>water = \"OOHHHH\"\n<strong>输出: </strong>\"HHOHHO\"\n<strong>解释:</strong> \"HOHHHO\", \"OHHHHO\", \"HHOHOH\", \"HOHHOH\", \"OHHHOH\", \"HHOOHH\", \"HOHOHH\" 和 \"OHHOHH\" 依然都是有效解。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 * n == water.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>water[i] == 'O' or 'H'</code></li>\n\t<li>输入字符串&nbsp;<code>water</code>&nbsp;中的 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">'H'</span></span></font></font>&nbsp;总数将会是 <code>2 * n</code> 。</li>\n\t<li>输入字符串&nbsp;<code>water</code>&nbsp;中的 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">'O'</span></span></font></font>&nbsp;总数将会是 <code>n</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1118一月有多少天",
        "hardRate": "EASY",
        "passRate": "64.93%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-days-in-a-month/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-days-in-a-month/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1119删去字符串中的元音",
        "hardRate": "EASY",
        "passRate": "87.17%",
        "problemsUrl": "https://leetcode.cn/problems/remove-vowels-from-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-vowels-from-a-string/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1120子树的最大平均值",
        "hardRate": "MEDIUM",
        "passRate": "62.89%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-average-subtree/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-average-subtree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1121将数组分成几个递增序列",
        "hardRate": "HARD",
        "passRate": "60.55%",
        "problemsUrl": "https://leetcode.cn/problems/divide-array-into-increasing-sequences/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-array-into-increasing-sequences/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1122数组的相对排序",
        "hardRate": "EASY",
        "passRate": "70.54%",
        "problemsUrl": "https://leetcode.cn/problems/relative-sort-array/",
        "solutionsUrl": "https://leetcode.cn/problems/relative-sort-array/solution",
        "problemsDesc": "<p>给你两个数组，<code>arr1</code> 和&nbsp;<code>arr2</code>，<code>arr2</code>&nbsp;中的元素各不相同，<code>arr2</code> 中的每个元素都出现在&nbsp;<code>arr1</code>&nbsp;中。</p>\n\n<p>对 <code>arr1</code>&nbsp;中的元素进行排序，使 <code>arr1</code> 中项的相对顺序和&nbsp;<code>arr2</code>&nbsp;中的相对顺序相同。未在&nbsp;<code>arr2</code>&nbsp;中出现过的元素需要按照升序放在&nbsp;<code>arr1</code>&nbsp;的末尾。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]\n<strong>输出：</strong>[2,2,2,1,4,3,3,9,6,7,19]\n</pre>\n\n<p><strong>示例 &nbsp;2:</strong></p>\n\n<pre>\n<strong>输入：</strong>arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]\n<strong>输出：</strong>[22,28,8,6,17,44]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr1.length, arr2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= arr1[i], arr2[i] &lt;= 1000</code></li>\n\t<li><code>arr2</code>&nbsp;中的元素&nbsp;<code>arr2[i]</code>&nbsp;&nbsp;<strong>各不相同</strong>&nbsp;</li>\n\t<li><code>arr2</code> 中的每个元素&nbsp;<code>arr2[i]</code>&nbsp;都出现在&nbsp;<code>arr1</code>&nbsp;中</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1123最深叶节点的最近公共祖先",
        "hardRate": "MEDIUM",
        "passRate": "71.78%",
        "problemsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/",
        "solutionsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/solution",
        "problemsDesc": "<p>给你一个有根节点<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;的二叉树，返回它&nbsp;<em>最深的叶节点的最近公共祖先</em>&nbsp;。</p>\n\n<p>回想一下：</p>\n\n<ul>\n\t<li><strong>叶节点</strong> 是二叉树中没有子节点的节点</li>\n\t<li>树的根节点的&nbsp;<strong>深度&nbsp;</strong>为&nbsp;<code>0</code>，如果某一节点的深度为&nbsp;<code>d</code>，那它的子节点的深度就是&nbsp;<code>d+1</code></li>\n\t<li>如果我们假定 <code>A</code> 是一组节点&nbsp;<code>S</code>&nbsp;的 <strong>最近公共祖先</strong>，<code>S</code>&nbsp;中的每个节点都在以 <code>A</code> 为根节点的子树中，且 <code>A</code>&nbsp;的深度达到此条件下可能的最大值。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png\" style=\"height: 340px; width: 400px;\" />\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4]\n<strong>输出：</strong>[2,7,4]\n<strong>解释：</strong>我们返回值为 2 的节点，在图中用黄色标记。\n在图中用蓝色标记的是树的最深的节点。\n注意，节点 6、0 和 8 也是叶节点，但是它们的深度是 2 ，而节点 7 和 4 的深度是 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[1]\n<strong>解释：</strong>根节点是树中最深的节点，它是它本身的最近公共祖先。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [0,1,3,null,2]\n<strong>输出：</strong>[2]\n<strong>解释：</strong>树中最深的叶节点是 2 ，最近公共祖先是它自己。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数将在<meta charset=\"UTF-8\" />&nbsp;<code>[1, 1000]</code>&nbsp;的范围内。</li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n\t<li>每个节点的值都是&nbsp;<strong>独一无二</strong>&nbsp;的。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与力扣 865 重复：<a href=\"https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/\">https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1124表现良好的最长时间段",
        "hardRate": "MEDIUM",
        "passRate": "39.22%",
        "problemsUrl": "https://leetcode.cn/problems/longest-well-performing-interval/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-well-performing-interval/solution",
        "problemsDesc": "<p>给你一份工作时间表&nbsp;<code>hours</code>，上面记录着某一位员工每天的工作小时数。</p>\n\n<p>我们认为当员工一天中的工作小时数大于&nbsp;<code>8</code> 小时的时候，那么这一天就是「<strong>劳累的一天</strong>」。</p>\n\n<p>所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格<strong> 大于</strong>「不劳累的天数」。</p>\n\n<p>请你返回「表现良好时间段」的最大长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>hours = [9,9,6,0,6,6,9]\n<strong>输出：</strong>3\n<strong>解释：</strong>最长的表现良好时间段是 [9,9,6]。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>hours = [6,6,6]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= hours.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= hours[i] &lt;= 16</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1125最小的必要团队",
        "hardRate": "HARD",
        "passRate": "61.01%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-sufficient-team/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-sufficient-team/solution",
        "problemsDesc": "<p>作为项目经理，你规划了一份需求的技能清单 <code>req_skills</code>，并打算从备选人员名单 <code>people</code> 中选出些人组成一个「必要团队」（ 编号为 <code>i</code> 的备选人员 <code>people[i]</code> 含有一份该备选人员掌握的技能列表）。</p>\n\n<p>所谓「必要团队」，就是在这个团队中，对于所需求的技能列表 <code>req_skills</code> 中列出的每项技能，团队中至少有一名成员已经掌握。可以用每个人的编号来表示团队中的成员：</p>\n\n<ul>\n\t<li>例如，团队 <code>team = [0, 1, 3]</code> 表示掌握技能分别为 <code>people[0]</code>，<code>people[1]</code>，和 <code>people[3]</code> 的备选人员。</li>\n</ul>\n\n<p>请你返回 <strong>任一</strong> 规模最小的必要团队，团队成员用人员编号表示。你可以按 <strong>任意顺序</strong> 返回答案，题目数据保证答案存在。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>req_skills = [\"java\",\"nodejs\",\"reactjs\"], people = [[\"java\"],[\"nodejs\"],[\"nodejs\",\"reactjs\"]]\n<strong>输出：</strong>[0,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>req_skills = [\"algorithms\",\"math\",\"java\",\"reactjs\",\"csharp\",\"aws\"], people = [[\"algorithms\",\"math\",\"java\"],[\"algorithms\",\"math\",\"reactjs\"],[\"java\",\"csharp\",\"aws\"],[\"reactjs\",\"csharp\"],[\"csharp\",\"math\"],[\"aws\",\"java\"]]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= req_skills.length <= 16</code></li>\n\t<li><code>1 <= req_skills[i].length <= 16</code></li>\n\t<li><code>req_skills[i]</code> 由小写英文字母组成</li>\n\t<li><code>req_skills</code> 中的所有字符串 <strong>互不相同</strong></li>\n\t<li><code>1 <= people.length <= 60</code></li>\n\t<li><code>0 <= people[i].length <= 16</code></li>\n\t<li><code>1 <= people[i][j].length <= 16</code></li>\n\t<li><code>people[i][j]</code> 由小写英文字母组成</li>\n\t<li><code>people[i]</code> 中的所有字符串 <strong>互不相同</strong></li>\n\t<li><code>people[i]</code> 中的每个技能是 <code>req_skills</code> 中的技能</li>\n\t<li>题目数据保证「必要团队」一定存在</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1126查询活跃业务",
        "hardRate": "MEDIUM",
        "passRate": "68.05%",
        "problemsUrl": "https://leetcode.cn/problems/active-businesses/",
        "solutionsUrl": "https://leetcode.cn/problems/active-businesses/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1127用户购买平台",
        "hardRate": "HARD",
        "passRate": "42.95%",
        "problemsUrl": "https://leetcode.cn/problems/user-purchase-platform/",
        "solutionsUrl": "https://leetcode.cn/problems/user-purchase-platform/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1128等价多米诺骨牌对的数量",
        "hardRate": "EASY",
        "passRate": "54.11%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-equivalent-domino-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-equivalent-domino-pairs/solution",
        "problemsDesc": "<p>给你一个由一些多米诺骨牌组成的列表&nbsp;<code>dominoes</code>。</p>\n\n<p>如果其中某一张多米诺骨牌可以通过旋转 <code>0</code>&nbsp;度或 <code>180</code> 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。</p>\n\n<p>形式上，<code>dominoes[i] = [a, b]</code>&nbsp;和&nbsp;<code>dominoes[j] = [c, d]</code>&nbsp;等价的前提是&nbsp;<code>a==c</code>&nbsp;且&nbsp;<code>b==d</code>，或是&nbsp;<code>a==d</code> 且&nbsp;<code>b==c</code>。</p>\n\n<p>在&nbsp;<code>0 &lt;= i &lt; j &lt; dominoes.length</code>&nbsp;的前提下，找出满足&nbsp;<code>dominoes[i]</code> 和&nbsp;<code>dominoes[j]</code>&nbsp;等价的骨牌对 <code>(i, j)</code> 的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>dominoes = [[1,2],[2,1],[3,4],[5,6]]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= dominoes.length &lt;= 40000</code></li>\n\t<li><code>1 &lt;= dominoes[i][j] &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1129颜色交替的最短路径",
        "hardRate": "MEDIUM",
        "passRate": "48.71%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-path-with-alternating-colors/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-path-with-alternating-colors/solution",
        "problemsDesc": "<p>给定一个整数 <code>n</code>，即有向图中的节点数，其中节点标记为 <code>0</code> 到 <code>n - 1</code>。图中的每条边为红色或者蓝色，并且可能存在自环或平行边。</p>\n\n<p>给定两个数组&nbsp;<code>redEdges</code>&nbsp;和&nbsp;<code>blueEdges</code>，其中：</p>\n\n<ul>\n\t<li><code>redEdges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示图中存在一条从节点&nbsp;<code>a<sub>i</sub></code>&nbsp;到节点&nbsp;<code>b<sub>i</sub></code>&nbsp;的红色有向边，</li>\n\t<li><code>blueEdges[j] = [u<sub>j</sub>, v<sub>j</sub>]</code>&nbsp;表示图中存在一条从节点&nbsp;<code>u<sub>j</sub></code>&nbsp;到节点&nbsp;<code>v<sub>j</sub></code>&nbsp;的蓝色有向边。</li>\n</ul>\n\n<p>返回长度为 <code>n</code> 的数组&nbsp;<code>answer</code>，其中&nbsp;<code>answer[X]</code>&nbsp;是从节点&nbsp;<code>0</code>&nbsp;到节点&nbsp;<code>X</code>&nbsp;的红色边和蓝色边交替出现的最短路径的长度。如果不存在这样的路径，那么 <code>answer[x] = -1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, red_edges = [[0,1],[1,2]], blue_edges = []\n<strong>输出：</strong>[0,1,-1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, red_edges = [[0,1]], blue_edges = [[2,1]]\n<strong>输出：</strong>[0,1,-1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= redEdges.length,&nbsp;blueEdges.length &lt;= 400</code></li>\n\t<li><code>redEdges[i].length == blueEdges[j].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub>, u<sub>j</sub>, v<sub>j</sub>&nbsp;&lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1130叶值的最小代价生成树",
        "hardRate": "MEDIUM",
        "passRate": "70.80%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-tree-from-leaf-values/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-tree-from-leaf-values/solution",
        "problemsDesc": "<p>给你一个正整数数组&nbsp;<code>arr</code>，考虑所有满足以下条件的二叉树：</p>\n\n<ul>\n\t<li>每个节点都有 <code>0</code> 个或是 <code>2</code> 个子节点。</li>\n\t<li>数组&nbsp;<code>arr</code>&nbsp;中的值与树的中序遍历中每个叶节点的值一一对应。</li>\n\t<li>每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。</li>\n</ul>\n\n<p>在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个&nbsp;32 位整数。</p>\n\n<p>如果一个节点有 0 个子节点，那么该节点为叶节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/10/tree1.jpg\" style=\"width: 500px; height: 169px;\" />\n<pre>\n<strong>输入：</strong>arr = [6,2,4]\n<strong>输出：</strong>32\n<strong>解释：</strong>有两种可能的树，第一种的非叶节点的总和为 36 ，第二种非叶节点的总和为 32 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/10/tree2.jpg\" style=\"width: 224px; height: 145px;\" />\n<pre>\n<strong>输入：</strong>arr = [4,11]\n<strong>输出：</strong>44\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 40</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 15</code></li>\n\t<li>答案保证是一个 32 位带符号整数，即小于&nbsp;<code>2<sup>31</sup></code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1131绝对值表达式的最大值",
        "hardRate": "MEDIUM",
        "passRate": "47.46%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-of-absolute-value-expression/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-of-absolute-value-expression/solution",
        "problemsDesc": "<p>给你两个长度相等的整数数组，返回下面表达式的最大值：</p>\n\n<p><code>|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|</code></p>\n\n<p>其中下标 <code>i</code>，<code>j</code> 满足&nbsp;<code>0 &lt;= i, j &lt; arr1.length</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr1 = [1,2,3,4], arr2 = [-1,4,5,6]\n<strong>输出：</strong>13\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]\n<strong>输出：</strong>20</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr1.length == arr2.length &lt;= 40000</code></li>\n\t<li><code>-10^6 &lt;= arr1[i], arr2[i] &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1132报告的记录 II",
        "hardRate": "MEDIUM",
        "passRate": "38.63%",
        "problemsUrl": "https://leetcode.cn/problems/reported-posts-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/reported-posts-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1133最大唯一数",
        "hardRate": "EASY",
        "passRate": "65.68%",
        "problemsUrl": "https://leetcode.cn/problems/largest-unique-number/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-unique-number/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1134阿姆斯特朗数",
        "hardRate": "EASY",
        "passRate": "77.43%",
        "problemsUrl": "https://leetcode.cn/problems/armstrong-number/",
        "solutionsUrl": "https://leetcode.cn/problems/armstrong-number/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1135最低成本联通所有城市",
        "hardRate": "MEDIUM",
        "passRate": "57.85%",
        "problemsUrl": "https://leetcode.cn/problems/connecting-cities-with-minimum-cost/",
        "solutionsUrl": "https://leetcode.cn/problems/connecting-cities-with-minimum-cost/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1136并行课程",
        "hardRate": "MEDIUM",
        "passRate": "60.33%",
        "problemsUrl": "https://leetcode.cn/problems/parallel-courses/",
        "solutionsUrl": "https://leetcode.cn/problems/parallel-courses/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1137第 N 个泰波那契数",
        "hardRate": "EASY",
        "passRate": "61.03%",
        "problemsUrl": "https://leetcode.cn/problems/n-th-tribonacci-number/",
        "solutionsUrl": "https://leetcode.cn/problems/n-th-tribonacci-number/solution",
        "problemsDesc": "<p>泰波那契序列&nbsp;T<sub>n</sub>&nbsp;定义如下：&nbsp;</p>\n\n<p>T<sub>0</sub> = 0, T<sub>1</sub> = 1, T<sub>2</sub> = 1, 且在 n &gt;= 0&nbsp;的条件下 T<sub>n+3</sub> = T<sub>n</sub> + T<sub>n+1</sub> + T<sub>n+2</sub></p>\n\n<p>给你整数&nbsp;<code>n</code>，请返回第 n 个泰波那契数&nbsp;T<sub>n </sub>的值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 4\n<strong>输出：</strong>4\n<strong>解释：</strong>\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 25\n<strong>输出：</strong>1389537\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 37</code></li>\n\t<li>答案保证是一个 32 位整数，即&nbsp;<code>answer &lt;= 2^31 - 1</code>。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1138字母板上的路径",
        "hardRate": "MEDIUM",
        "passRate": "51.77%",
        "problemsUrl": "https://leetcode.cn/problems/alphabet-board-path/",
        "solutionsUrl": "https://leetcode.cn/problems/alphabet-board-path/solution",
        "problemsDesc": "<p>我们从一块字母板上的位置&nbsp;<code>(0, 0)</code>&nbsp;出发，该坐标对应的字符为&nbsp;<code>board[0][0]</code>。</p>\n\n<p>在本题里，字母板为<code>board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]</code>，如下所示。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/07/28/azboard.png\" style=\"width: 300px;\" /></p>\n\n<p>我们可以按下面的指令规则行动：</p>\n\n<ul>\n\t<li>如果方格存在，<code>'U'</code>&nbsp;意味着将我们的位置上移一行；</li>\n\t<li>如果方格存在，<code>'D'</code>&nbsp;意味着将我们的位置下移一行；</li>\n\t<li>如果方格存在，<code>'L'</code>&nbsp;意味着将我们的位置左移一列；</li>\n\t<li>如果方格存在，<code>'R'</code>&nbsp;意味着将我们的位置右移一列；</li>\n\t<li><code>'!'</code>&nbsp;会把在我们当前位置 <code>(r, c)</code> 的字符&nbsp;<code>board[r][c]</code>&nbsp;添加到答案中。</li>\n</ul>\n\n<p>（注意，字母板上只存在有字母的位置。）</p>\n\n<p>返回指令序列，用最小的行动次数让答案和目标&nbsp;<code>target</code>&nbsp;相同。你可以返回任何达成目标的路径。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = \"leet\"\n<strong>输出：</strong>\"DDR!UURRR!!DDD!\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = \"code\"\n<strong>输出：</strong>\"RR!DDRR!UUL!R!\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target.length &lt;= 100</code></li>\n\t<li><code>target</code>&nbsp;仅含有小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1139最大的以 1 为边界的正方形",
        "hardRate": "MEDIUM",
        "passRate": "56.12%",
        "problemsUrl": "https://leetcode.cn/problems/largest-1-bordered-square/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-1-bordered-square/solution",
        "problemsDesc": "<p>给你一个由若干 <code>0</code> 和 <code>1</code> 组成的二维网格&nbsp;<code>grid</code>，请你找出边界全部由 <code>1</code> 组成的最大 <strong>正方形</strong> 子网格，并返回该子网格中的元素数量。如果不存在，则返回 <code>0</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[1,1,1],[1,0,1],[1,1,1]]\n<strong>输出：</strong>9\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[1,1,0,0]]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= grid.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= grid[0].length &lt;= 100</code></li>\n\t<li><code>grid[i][j]</code> 为&nbsp;<code>0</code>&nbsp;或&nbsp;<code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1140石子游戏 II",
        "hardRate": "MEDIUM",
        "passRate": "70.44%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game-ii/solution",
        "problemsDesc": "<p>爱丽丝和鲍勃继续他们的石子游戏。许多堆石子&nbsp;<strong>排成一行</strong>，每堆都有正整数颗石子&nbsp;<code>piles[i]</code>。游戏以谁手中的石子最多来决出胜负。</p>\n\n<p>爱丽丝和鲍勃轮流进行，爱丽丝先开始。最初，<code>M = 1</code>。</p>\n\n<p>在每个玩家的回合中，该玩家可以拿走剩下的&nbsp;<strong>前</strong>&nbsp;<code>X</code>&nbsp;堆的所有石子，其中&nbsp;<code>1 &lt;= X &lt;= 2M</code>。然后，令&nbsp;<code>M = max(M, X)</code>。</p>\n\n<p>游戏一直持续到所有石子都被拿走。</p>\n\n<p>假设爱丽丝和鲍勃都发挥出最佳水平，返回爱丽丝可以得到的最大数量的石头。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [2,7,9,4,4]\n<strong>输出：</strong>10\n<strong>解释：</strong>如果一开始Alice取了一堆，Bob取了两堆，然后Alice再取两堆。爱丽丝可以得到2 + 4 + 4 = 10堆。如果Alice一开始拿走了两堆，那么Bob可以拿走剩下的三堆。在这种情况下，Alice得到2 + 7 = 9堆。返回10，因为它更大。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [1,2,3,4,5,100]\n<strong>输出：</strong>104\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= piles.length &lt;= 100</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>1 &lt;= piles[i]&nbsp;&lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1141查询近30天活跃用户数",
        "hardRate": "EASY",
        "passRate": "44.92%",
        "problemsUrl": "https://leetcode.cn/problems/user-activity-for-the-past-30-days-i/",
        "solutionsUrl": "https://leetcode.cn/problems/user-activity-for-the-past-30-days-i/solution",
        "problemsDesc": "<p>活动记录表：<code>Activity</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| user_id       | int     |\n| session_id    | int     |\n| activity_date | date    |\n| activity_type | enum    |\n+---------------+---------+\n该表是用户在社交网站的活动记录。\n该表没有主键，可能包含重复数据。\nactivity_type 字段为以下四种值 ('open_session', 'end_session', 'scroll_down', 'send_message')。\n每个 session_id 只属于一个用户。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>请写SQL查询出截至&nbsp;<code>2019-07-27</code>（包含2019-07-27），近<strong>&nbsp;</strong><code>30</code> 天的每日活跃用户数（当天只要有一条活动记录，即为活跃用户）。</p>\n\n<p>以 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果示例如下。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nActivity table:\n+---------+------------+---------------+---------------+\n| user_id | session_id | activity_date | activity_type |\n+---------+------------+---------------+---------------+\n| 1       | 1          | 2019-07-20    | open_session  |\n| 1       | 1          | 2019-07-20    | scroll_down   |\n| 1       | 1          | 2019-07-20    | end_session   |\n| 2       | 4          | 2019-07-20    | open_session  |\n| 2       | 4          | 2019-07-21    | send_message  |\n| 2       | 4          | 2019-07-21    | end_session   |\n| 3       | 2          | 2019-07-21    | open_session  |\n| 3       | 2          | 2019-07-21    | send_message  |\n| 3       | 2          | 2019-07-21    | end_session   |\n| 4       | 3          | 2019-06-25    | open_session  |\n| 4       | 3          | 2019-06-25    | end_session   |\n+---------+------------+---------------+---------------+\n<strong>输出：</strong>\n+------------+--------------+ \n| day        | active_users |\n+------------+--------------+ \n| 2019-07-20 | 2            |\n| 2019-07-21 | 2            |\n+------------+--------------+ <strong>\n解释：</strong>注意非活跃用户的记录不需要展示。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1142过去30天的用户活动 II",
        "hardRate": "EASY",
        "passRate": "37.19%",
        "problemsUrl": "https://leetcode.cn/problems/user-activity-for-the-past-30-days-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/user-activity-for-the-past-30-days-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1143最长公共子序列",
        "hardRate": "MEDIUM",
        "passRate": "64.89%",
        "problemsUrl": "https://leetcode.cn/problems/longest-common-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-common-subsequence/solution",
        "problemsDesc": "<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>\n\n<p>一个字符串的 <strong>子序列</strong><em> </em>是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>\n\n<ul>\n\t<li>例如，<code>\"ace\"</code> 是 <code>\"abcde\"</code> 的子序列，但 <code>\"aec\"</code> 不是 <code>\"abcde\"</code> 的子序列。</li>\n</ul>\n\n<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>text1 = \"abcde\", text2 = \"ace\" \n<strong>输出：</strong>3  \n<strong>解释：</strong>最长公共子序列是 \"ace\" ，它的长度为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>text1 = \"abc\", text2 = \"abc\"\n<strong>输出：</strong>3\n<strong>解释：</strong>最长公共子序列是 \"abc\" ，它的长度为 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>text1 = \"abc\", text2 = \"def\"\n<strong>输出：</strong>0\n<strong>解释：</strong>两个字符串没有公共子序列，返回 0 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= text1.length, text2.length <= 1000</code></li>\n\t<li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1144递减元素使数组呈锯齿状",
        "hardRate": "MEDIUM",
        "passRate": "50.53%",
        "problemsUrl": "https://leetcode.cn/problems/decrease-elements-to-make-array-zigzag/",
        "solutionsUrl": "https://leetcode.cn/problems/decrease-elements-to-make-array-zigzag/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>，每次 <strong>操作</strong>&nbsp;会从中选择一个元素并 <strong>将该元素的值减少&nbsp;1</strong>。</p>\n\n<p>如果符合下列情况之一，则数组&nbsp;<code>A</code>&nbsp;就是 <strong>锯齿数组</strong>：</p>\n\n<ul>\n\t<li>每个偶数索引对应的元素都大于相邻的元素，即&nbsp;<code>A[0] &gt; A[1] &lt; A[2] &gt; A[3] &lt; A[4] &gt; ...</code></li>\n\t<li>或者，每个奇数索引对应的元素都大于相邻的元素，即&nbsp;<code>A[0] &lt; A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; ...</code></li>\n</ul>\n\n<p>返回将数组&nbsp;<code>nums</code>&nbsp;转换为锯齿数组所需的最小操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>我们可以把 2 递减到 0，或把 3 递减到 1。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [9,6,1,6,2]\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1145二叉树着色游戏",
        "hardRate": "MEDIUM",
        "passRate": "55.41%",
        "problemsUrl": "https://leetcode.cn/problems/binary-tree-coloring-game/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-tree-coloring-game/solution",
        "problemsDesc": "<p>有两位极客玩家参与了一场「二叉树着色」的游戏。游戏中，给出二叉树的根节点&nbsp;<code>root</code>，树上总共有 <code>n</code> 个节点，且 <code>n</code> 为奇数，其中每个节点上的值从&nbsp;<code>1</code> 到&nbsp;<code>n</code>&nbsp;各不相同。</p>\n\n<p>最开始时：</p>\n\n<ul>\n\t<li>「一号」玩家从 <code>[1, n]</code>&nbsp;中取一个值&nbsp;<code>x</code>（<code>1 &lt;= x &lt;= n</code>）；</li>\n\t<li>「二号」玩家也从&nbsp;<code>[1, n]</code>&nbsp;中取一个值&nbsp;<code>y</code>（<code>1 &lt;= y &lt;= n</code>）且&nbsp;<code>y != x</code>。</li>\n</ul>\n\n<p>「一号」玩家给值为&nbsp;<code>x</code>&nbsp;的节点染上红色，而「二号」玩家给值为&nbsp;<code>y</code>&nbsp;的节点染上蓝色。</p>\n\n<p>之后两位玩家轮流进行操作，「一号」玩家先手。每一回合，玩家选择一个被他染过色的节点，将所选节点一个 <strong>未着色 </strong>的邻节点（即左右子节点、或父节点）进行染色（「一号」玩家染红色，「二号」玩家染蓝色）。</p>\n\n<p>如果（且仅在此种情况下）当前玩家无法找到这样的节点来染色时，其回合就会被跳过。</p>\n\n<p>若两个玩家都没有可以染色的节点时，游戏结束。着色节点最多的那位玩家获得胜利 ✌️。</p>\n\n<p>现在，假设你是「二号」玩家，根据所给出的输入，假如存在一个&nbsp;<code>y</code>&nbsp;值可以确保你赢得这场游戏，则返回&nbsp;<code>true</code> ；若无法获胜，就请返回 <code>false</code> 。</p>\n&nbsp;\n\n<p><strong class=\"example\">示例 1 ：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/08/01/1480-binary-tree-coloring-game.png\" style=\"width: 500px; height: 310px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3\n<strong>输出：</strong>true\n<strong>解释：</strong>第二个玩家可以选择值为 2 的节点。</pre>\n\n<p><strong class=\"example\">示例 2 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3], n = 3, x = 1\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目为 <code>n</code></li>\n\t<li><code>1 &lt;= x &lt;= n &lt;= 100</code></li>\n\t<li><code>n</code> 是奇数</li>\n\t<li><code>1 &lt;= Node.val &lt;= n</code></li>\n\t<li>树中所有值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1146快照数组",
        "hardRate": "MEDIUM",
        "passRate": "33.50%",
        "problemsUrl": "https://leetcode.cn/problems/snapshot-array/",
        "solutionsUrl": "https://leetcode.cn/problems/snapshot-array/solution",
        "problemsDesc": "<p>实现支持下列接口的「快照数组」-&nbsp;SnapshotArray：</p>\n\n<ul>\n\t<li><code>SnapshotArray(int length)</code>&nbsp;- 初始化一个与指定长度相等的 类数组 的数据结构。<strong>初始时，每个元素都等于</strong><strong>&nbsp;0</strong>。</li>\n\t<li><code>void set(index, val)</code>&nbsp;- 会将指定索引&nbsp;<code>index</code>&nbsp;处的元素设置为&nbsp;<code>val</code>。</li>\n\t<li><code>int snap()</code>&nbsp;- 获取该数组的快照，并返回快照的编号&nbsp;<code>snap_id</code>（快照号是调用&nbsp;<code>snap()</code>&nbsp;的总次数减去&nbsp;<code>1</code>）。</li>\n\t<li><code>int get(index, snap_id)</code>&nbsp;- 根据指定的&nbsp;<code>snap_id</code>&nbsp;选择快照，并返回该快照指定索引 <code>index</code>&nbsp;的值。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>[&quot;SnapshotArray&quot;,&quot;set&quot;,&quot;snap&quot;,&quot;set&quot;,&quot;get&quot;]\n     [[3],[0,5],[],[0,6],[0,0]]\n<strong>输出：</strong>[null,null,0,null,5]\n<strong>解释：\n</strong>SnapshotArray snapshotArr = new SnapshotArray(3); // 初始化一个长度为 3 的快照数组\nsnapshotArr.set(0,5);  // 令 array[0] = 5\nsnapshotArr.snap();  // 获取快照，返回 snap_id = 0\nsnapshotArr.set(0,6);\nsnapshotArr.get(0,0);  // 获取 snap_id = 0 的快照中 array[0] 的值，返回 5</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= length&nbsp;&lt;= 50000</code></li>\n\t<li>题目最多进行<code>50000</code> 次<code>set</code>，<code>snap</code>，和&nbsp;<code>get</code>的调用 。</li>\n\t<li><code>0 &lt;= index&nbsp;&lt;&nbsp;length</code></li>\n\t<li><code>0 &lt;=&nbsp;snap_id &lt;&nbsp;</code>我们调用&nbsp;<code>snap()</code>&nbsp;的总次数</li>\n\t<li><code>0 &lt;=&nbsp;val &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1147段式回文",
        "hardRate": "HARD",
        "passRate": "59.01%",
        "problemsUrl": "https://leetcode.cn/problems/longest-chunked-palindrome-decomposition/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-chunked-palindrome-decomposition/solution",
        "problemsDesc": "<p>你会得到一个字符串&nbsp;<code>text</code>&nbsp;。你应该把它分成 <code>k</code>&nbsp;个子字符串&nbsp;<code>(subtext1, subtext2，…， subtextk)</code>&nbsp;，要求满足:</p>\n\n<ul>\n\t<li><code>subtext<sub>i</sub></code><sub>&nbsp;</sub>是 <strong>非空&nbsp;</strong>字符串</li>\n\t<li>所有子字符串的连接等于 <code>text</code> ( 即<code>subtext<sub>1</sub>&nbsp;+ subtext<sub>2</sub>&nbsp;+ ... + subtext<sub>k</sub>&nbsp;== text</code>&nbsp;)</li>\n\t<li>对于所有 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">i</span></span></font></font>&nbsp;的有效值( 即&nbsp;<code>1 &lt;= i&nbsp;&lt;= k</code> ) ，<code>subtext<sub>i</sub>&nbsp;== subtext<sub>k - i + 1</sub></code> 均成立</li>\n</ul>\n\n<p>返回<code>k</code>可能最大值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = \"ghiabcdefhelloadamhelloabcdefghi\"\n<strong>输出：</strong>7\n<strong>解释：</strong>我们可以把字符串拆分成 \"(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)\"。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = \"merchant\"\n<strong>输出：</strong>1\n<strong>解释：</strong>我们可以把字符串拆分成 \"(merchant)\"。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = \"antaprezatepzapreanta\"\n<strong>输出：</strong>11\n<strong>解释：</strong>我们可以把字符串拆分成 \"(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)\"。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 1000</code></li>\n\t<li><code>text</code>&nbsp;仅由小写英文字符组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1148文章浏览 I",
        "hardRate": "EASY",
        "passRate": "71.33%",
        "problemsUrl": "https://leetcode.cn/problems/article-views-i/",
        "solutionsUrl": "https://leetcode.cn/problems/article-views-i/solution",
        "problemsDesc": "<p><code>Views</code>&nbsp;表：</p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| article_id    | int     |\n| author_id     | int     |\n| viewer_id     | int     |\n| view_date     | date    |\n+---------------+---------+\n此表无主键，因此可能会存在重复行。\n此表的每一行都表示某人在某天浏览了某位作者的某篇文章。\n请注意，同一人的 author_id 和 viewer_id 是相同的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>请编写一条 SQL 查询以找出所有浏览过自己文章的作者，结果按照 id 升序排列。</p>\n\n<p>查询结果的格式如下所示：</p>\n\n<pre>\nViews 表：\n+------------+-----------+-----------+------------+\n| article_id | author_id | viewer_id | view_date  |\n+------------+-----------+-----------+------------+\n| 1          | 3         | 5         | 2019-08-01 |\n| 1          | 3         | 6         | 2019-08-02 |\n| 2          | 7         | 7         | 2019-08-01 |\n| 2          | 7         | 6         | 2019-08-02 |\n| 4          | 7         | 1         | 2019-07-22 |\n| 3          | 4         | 4         | 2019-07-21 |\n| 3          | 4         | 4         | 2019-07-21 |\n+------------+-----------+-----------+------------+\n\n结果表：\n+------+\n| id   |\n+------+\n| 4    |\n| 7    |\n+------+\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1149文章浏览 II",
        "hardRate": "MEDIUM",
        "passRate": "44.47%",
        "problemsUrl": "https://leetcode.cn/problems/article-views-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/article-views-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1150检查一个数是否在数组中占绝大多数",
        "hardRate": "EASY",
        "passRate": "59.56%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-a-number-is-majority-element-in-a-sorted-array/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-a-number-is-majority-element-in-a-sorted-array/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1151最少交换次数来组合所有的 1",
        "hardRate": "MEDIUM",
        "passRate": "52.81%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1152用户网站访问行为分析",
        "hardRate": "MEDIUM",
        "passRate": "41.45%",
        "problemsUrl": "https://leetcode.cn/problems/analyze-user-website-visit-pattern/",
        "solutionsUrl": "https://leetcode.cn/problems/analyze-user-website-visit-pattern/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1153字符串转化",
        "hardRate": "HARD",
        "passRate": "37.82%",
        "problemsUrl": "https://leetcode.cn/problems/string-transforms-into-another-string/",
        "solutionsUrl": "https://leetcode.cn/problems/string-transforms-into-another-string/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1154一年中的第几天",
        "hardRate": "EASY",
        "passRate": "62.49%",
        "problemsUrl": "https://leetcode.cn/problems/day-of-the-year/",
        "solutionsUrl": "https://leetcode.cn/problems/day-of-the-year/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>date</code> ，按 <code>YYYY-MM-DD</code> 格式表示一个 <a href=\"https://baike.baidu.com/item/公元/17855\" target=\"_blank\">现行公元纪年法</a> 日期。返回该日期是当年的第几天。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>date = \"2019-01-09\"\n<strong>输出：</strong>9\n<strong>解释：</strong>给定日期是2019年的第九天。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>date = \"2019-02-10\"\n<strong>输出：</strong>41\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>date.length == 10</code></li>\n\t<li><code>date[4] == date[7] == '-'</code>，其他的&nbsp;<code>date[i]</code>&nbsp;都是数字</li>\n\t<li><code>date</code> 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1155掷骰子等于目标和的方法数",
        "hardRate": "MEDIUM",
        "passRate": "50.92%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/solution",
        "problemsDesc": "<p>这里有&nbsp;<code>n</code>&nbsp;个一样的骰子，每个骰子上都有&nbsp;<code>k</code>&nbsp;个面，分别标号为&nbsp;<code>1</code>&nbsp;到 <code>k</code> 。</p>\n\n<p>给定三个整数 <code>n</code> ,&nbsp; <code>k</code> 和&nbsp;<code>target</code>&nbsp;，返回可能的方式(从总共<em>&nbsp;</em><code>k<sup>n</sup></code><em>&nbsp;</em>种方式中)滚动骰子的数量，使正面朝上的数字之和等于<em>&nbsp;</em><code>target</code>&nbsp;。</p>\n\n<p>答案可能很大，你需要对&nbsp;<code>10<sup>9</sup>&nbsp;+ 7</code> <strong>取模</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, k = 6, target = 3\n<strong>输出：</strong>1\n<strong>解释：</strong>你扔一个有6张脸的骰子。\n得到3的和只有一种方法。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, k = 6, target = 7\n<strong>输出：</strong>6\n<strong>解释：</strong>你扔两个骰子，每个骰子有6个面。\n得到7的和有6种方法1+6 2+5 3+4 4+3 5+2 6+1。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 30, k = 30, target = 500\n<strong>输出：</strong>222616187\n<strong>解释：</strong>返回的结果必须是对 10<sup>9</sup> + 7 取模。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n, k &lt;= 30</code></li>\n\t<li><code>1 &lt;= target &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1156单字符重复子串的最大长度",
        "hardRate": "MEDIUM",
        "passRate": "51.27%",
        "problemsUrl": "https://leetcode.cn/problems/swap-for-longest-repeated-character-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/swap-for-longest-repeated-character-substring/solution",
        "problemsDesc": "<p>如果字符串中的所有字符都相同，那么这个字符串是单字符重复的字符串。</p>\n\n<p>给你一个字符串&nbsp;<code>text</code>，你只能交换其中两个字符一次或者什么都不做，然后得到一些单字符重复的子串。返回其中最长的子串的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;ababa&quot;\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;aaabaaa&quot;\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;aaabbaaa&quot;\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;aaaaa&quot;\n<strong>输出：</strong>5\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;abcdef&quot;\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 20000</code></li>\n\t<li><code>text</code> 仅由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1157子数组中占绝大多数的元素",
        "hardRate": "HARD",
        "passRate": "46.16%",
        "problemsUrl": "https://leetcode.cn/problems/online-majority-element-in-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/online-majority-element-in-subarray/solution",
        "problemsDesc": "<p>设计一个数据结构，有效地找到给定子数组的 <strong>多数元素</strong> 。</p>\n\n<p>子数组的 <strong>多数元素</strong> 是在子数组中出现&nbsp;<code>threshold</code>&nbsp;次数或次数以上的元素。</p>\n\n<p>实现 <code>MajorityChecker</code> 类:</p>\n\n<ul>\n\t<li><code>MajorityChecker(int[] arr)</code>&nbsp;会用给定的数组 <code>arr</code>&nbsp;对&nbsp;<code>MajorityChecker</code> 初始化。</li>\n\t<li><code>int query(int left, int right, int threshold)</code>&nbsp;返回子数组中的元素 &nbsp;<code>arr[left...right]</code>&nbsp;至少出现&nbsp;<code>threshold</code>&nbsp;次数，如果不存在这样的元素则返回 <code>-1</code>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong>\n[\"MajorityChecker\", \"query\", \"query\", \"query\"]\n[[[1, 1, 2, 2, 1, 1]], [0, 5, 4], [0, 3, 3], [2, 3, 2]]\n<strong>输出：</strong>\n[null, 1, -1, 2]\n\n<b>解释：</b>\nMajorityChecker majorityChecker = new MajorityChecker([1,1,2,2,1,1]);\nmajorityChecker.query(0,5,4); // 返回 1\nmajorityChecker.query(0,3,3); // 返回 -1\nmajorityChecker.query(2,3,2); // 返回 2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= left &lt;= right &lt; arr.length</code></li>\n\t<li><code>threshold &lt;= right - left + 1</code></li>\n\t<li><code>2 * threshold &gt; right - left + 1</code></li>\n\t<li>调用&nbsp;<code>query</code>&nbsp;的次数最多为&nbsp;<code>10<sup>4</sup></code>&nbsp;</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1158市场分析 I",
        "hardRate": "MEDIUM",
        "passRate": "54.50%",
        "problemsUrl": "https://leetcode.cn/problems/market-analysis-i/",
        "solutionsUrl": "https://leetcode.cn/problems/market-analysis-i/solution",
        "problemsDesc": "<p>Table: <code>Users</code></p>\n\n<pre>\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| user_id        | int     |\n| join_date      | date    |\n| favorite_brand | varchar |\n+----------------+---------+\n此表主键是 user_id。\n表中描述了购物网站的用户信息，用户可以在此网站上进行商品买卖。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Orders</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| order_id      | int     |\n| order_date    | date    |\n| item_id       | int     |\n| buyer_id      | int     |\n| seller_id     | int     |\n+---------------+---------+\n此表主键是 order_id。\n外键是 item_id 和（buyer_id，seller_id）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Items</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| item_id       | int     |\n| item_brand    | varchar |\n+---------------+---------+\n此表主键是 item_id。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>请写出一条SQL语句以查询每个用户的注册日期和在 <strong><code>2019</code> </strong>年作为买家的订单总数。</p>\n\n<p>以 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式如下。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nUsers 表:\n+---------+------------+----------------+\n| user_id | join_date  | favorite_brand |\n+---------+------------+----------------+\n| 1       | 2018-01-01 | Lenovo         |\n| 2       | 2018-02-09 | Samsung        |\n| 3       | 2018-01-19 | LG             |\n| 4       | 2018-05-21 | HP             |\n+---------+------------+----------------+\nOrders 表:\n+----------+------------+---------+----------+-----------+\n| order_id | order_date | item_id | buyer_id | seller_id |\n+----------+------------+---------+----------+-----------+\n| 1        | 2019-08-01 | 4       | 1        | 2         |\n| 2        | 2018-08-02 | 2       | 1        | 3         |\n| 3        | 2019-08-03 | 3       | 2        | 3         |\n| 4        | 2018-08-04 | 1       | 4        | 2         |\n| 5        | 2018-08-04 | 1       | 3        | 4         |\n| 6        | 2019-08-05 | 2       | 2        | 4         |\n+----------+------------+---------+----------+-----------+\nItems 表:\n+---------+------------+\n| item_id | item_brand |\n+---------+------------+\n| 1       | Samsung    |\n| 2       | Lenovo     |\n| 3       | LG         |\n| 4       | HP         |\n+---------+------------+\n<strong>输出：</strong>\n+-----------+------------+----------------+\n| buyer_id  | join_date  | orders_in_2019 |\n+-----------+------------+----------------+\n| 1         | 2018-01-01 | 1              |\n| 2         | 2018-02-09 | 2              |\n| 3         | 2018-01-19 | 0              |\n| 4         | 2018-05-21 | 0              |\n+-----------+------------+----------------+</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1159市场分析 II",
        "hardRate": "HARD",
        "passRate": "50.59%",
        "problemsUrl": "https://leetcode.cn/problems/market-analysis-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/market-analysis-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1160拼写单词",
        "hardRate": "EASY",
        "passRate": "68.20%",
        "problemsUrl": "https://leetcode.cn/problems/find-words-that-can-be-formed-by-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/find-words-that-can-be-formed-by-characters/solution",
        "problemsDesc": "<p>给你一份『词汇表』（字符串数组）&nbsp;<code>words</code>&nbsp;和一张『字母表』（字符串）&nbsp;<code>chars</code>。</p>\n\n<p>假如你可以用&nbsp;<code>chars</code>&nbsp;中的『字母』（字符）拼写出 <code>words</code>&nbsp;中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</p>\n\n<p>注意：每次拼写（指拼写词汇表中的一个单词）时，<code>chars</code> 中的每个字母都只能用一次。</p>\n\n<p>返回词汇表&nbsp;<code>words</code>&nbsp;中你掌握的所有单词的 <strong>长度之和</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot;\n<strong>输出：</strong>6\n<strong>解释： </strong>\n可以形成字符串 &quot;cat&quot; 和 &quot;hat&quot;，所以答案是 3 + 3 = 6。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars = &quot;welldonehoneyr&quot;\n<strong>输出：</strong>10\n<strong>解释：</strong>\n可以形成字符串 &quot;hello&quot; 和 &quot;world&quot;，所以答案是 5 + 5 = 10。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length, chars.length&nbsp;&lt;= 100</code></li>\n\t<li>所有字符串中都仅包含小写英文字母</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1161最大层内元素和",
        "hardRate": "MEDIUM",
        "passRate": "66.14%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/solution",
        "problemsDesc": "<p>给你一个二叉树的根节点&nbsp;<code>root</code>。设根节点位于二叉树的第 <code>1</code> 层，而根节点的子节点位于第 <code>2</code> 层，依此类推。</p>\n\n<p>请返回层内元素之和 <strong>最大</strong> 的那几层（可能只有一层）的层号，并返回其中&nbsp;<strong>最小</strong> 的那个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/08/17/capture.jpeg\" style=\"height: 175px; width: 200px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,7,0,7,-8,null,null]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n第 1 层各元素之和为 1，\n第 2 层各元素之和为 7 + 0 = 7，\n第 3 层各元素之和为 7 + -8 = -1，\n所以我们返回第 2 层的层号，它的层内元素之和最大。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [989,null,10250,98693,-89388,null,null,null,-32127]\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数在<meta charset=\"UTF-8\" />&nbsp;<code>[1, 10<sup>4</sup>]</code>范围内<meta charset=\"UTF-8\" /></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1162地图分析",
        "hardRate": "MEDIUM",
        "passRate": "46.72%",
        "problemsUrl": "https://leetcode.cn/problems/as-far-from-land-as-possible/",
        "solutionsUrl": "https://leetcode.cn/problems/as-far-from-land-as-possible/solution",
        "problemsDesc": "<p>你现在手里有一份大小为<meta charset=\"UTF-8\" />&nbsp;<code>n x n</code>&nbsp;的 网格 <code>grid</code>，上面的每个 单元格 都用&nbsp;<code>0</code>&nbsp;和&nbsp;<code>1</code>&nbsp;标记好了。其中&nbsp;<code>0</code>&nbsp;代表海洋，<code>1</code>&nbsp;代表陆地。</p>\n\n<p>请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的，并返回该距离。如果网格上只有陆地或者海洋，请返回&nbsp;<code>-1</code>。</p>\n\n<p>我们这里说的距离是「曼哈顿距离」（&nbsp;Manhattan Distance）：<code>(x0, y0)</code> 和&nbsp;<code>(x1, y1)</code>&nbsp;这两个单元格之间的距离是&nbsp;<code>|x0 - x1| + |y0 - y1|</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/08/17/1336_ex1.jpeg\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,0,1],[0,0,0],[1,0,1]]\n<strong>输出：</strong>2\n<strong>解释： </strong>\n海洋单元格 (1, 1) 和所有陆地单元格之间的距离都达到最大，最大距离为 2。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/08/17/1336_ex2.jpeg\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,0,0],[0,0,0],[0,0,0]]\n<strong>输出：</strong>4\n<strong>解释： </strong>\n海洋单元格 (2, 2) 和所有陆地单元格之间的距离都达到最大，最大距离为 4。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= n&nbsp;&lt;= 100</code></li>\n\t<li><code>grid[i][j]</code>&nbsp;不是&nbsp;<code>0</code>&nbsp;就是&nbsp;<code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1163按字典序排在最后的子串",
        "hardRate": "HARD",
        "passRate": "35.24%",
        "problemsUrl": "https://leetcode.cn/problems/last-substring-in-lexicographical-order/",
        "solutionsUrl": "https://leetcode.cn/problems/last-substring-in-lexicographical-order/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，找出它的所有子串并按字典序排列，返回排在最后的那个子串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abab\"\n<strong>输出：</strong>\"bab\"\n<strong>解释：</strong>我们可以找出 7 个子串 [\"a\", \"ab\", \"aba\", \"abab\", \"b\", \"ba\", \"bab\"]。按字典序排在最后的子串是 \"bab\"。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"leetcode\"\n<strong>输出：</strong>\"tcode\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 4 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> 仅含有小写英文字符。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1164指定日期的产品价格",
        "hardRate": "MEDIUM",
        "passRate": "58.41%",
        "problemsUrl": "https://leetcode.cn/problems/product-price-at-a-given-date/",
        "solutionsUrl": "https://leetcode.cn/problems/product-price-at-a-given-date/solution",
        "problemsDesc": "<p>产品数据表: <code>Products</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| product_id    | int     |\n| new_price     | int     |\n| change_date   | date    |\n+---------------+---------+\n这张表的主键是 (product_id, change_date)。\n这张表的每一行分别记录了 某产品 在某个日期 更改后 的新价格。</pre>\n\n<p>&nbsp;</p>\n\n<p>写一段 SQL来查找在&nbsp;<code>2019-08-16</code><strong> </strong>时全部产品的价格，假设所有产品在修改前的价格都是&nbsp;<code>10</code><strong> 。</strong></p>\n\n<p>以 <strong>任意顺序 </strong>返回结果表。</p>\n\n<p>查询结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<code><strong>输入：</strong>\nProducts</code> 表:\n+------------+-----------+-------------+\n| product_id | new_price | change_date |\n+------------+-----------+-------------+\n| 1          | 20        | 2019-08-14  |\n| 2          | 50        | 2019-08-14  |\n| 1          | 30        | 2019-08-15  |\n| 1          | 35        | 2019-08-16  |\n| 2          | 65        | 2019-08-17  |\n| 3          | 20        | 2019-08-18  |\n+------------+-----------+-------------+\n<strong>输出：</strong>\n+------------+-------+\n| product_id | price |\n+------------+-------+\n| 2          | 50    |\n| 1          | 35    |\n| 3          | 10    |\n+------------+-------+</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1165单行键盘",
        "hardRate": "EASY",
        "passRate": "84.07%",
        "problemsUrl": "https://leetcode.cn/problems/single-row-keyboard/",
        "solutionsUrl": "https://leetcode.cn/problems/single-row-keyboard/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1166设计文件系统",
        "hardRate": "MEDIUM",
        "passRate": "49.66%",
        "problemsUrl": "https://leetcode.cn/problems/design-file-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-file-system/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1167连接棒材的最低费用",
        "hardRate": "MEDIUM",
        "passRate": "51.30%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-connect-sticks/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-connect-sticks/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1168水资源分配优化",
        "hardRate": "HARD",
        "passRate": "62.52%",
        "problemsUrl": "https://leetcode.cn/problems/optimize-water-distribution-in-a-village/",
        "solutionsUrl": "https://leetcode.cn/problems/optimize-water-distribution-in-a-village/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1169查询无效交易",
        "hardRate": "MEDIUM",
        "passRate": "32.99%",
        "problemsUrl": "https://leetcode.cn/problems/invalid-transactions/",
        "solutionsUrl": "https://leetcode.cn/problems/invalid-transactions/solution",
        "problemsDesc": "<p>如果出现下述两种情况，交易 <strong>可能无效</strong>：</p>\n\n<ul>\n\t<li>交易金额超过<meta charset=\"UTF-8\" />&nbsp;<code>$1000</code></li>\n\t<li>或者，它和&nbsp;<strong>另一个城市</strong>&nbsp;中 <strong>同名</strong> 的另一笔交易相隔不超过 <code>60</code> 分钟（包含 60 分钟整）</li>\n</ul>\n\n<p>给定字符串数组交易清单<meta charset=\"UTF-8\" />&nbsp;<code>transaction</code>&nbsp;。每个交易字符串&nbsp;<code>transactions[i]</code>&nbsp;由一些用逗号分隔的值组成，这些值分别表示交易的名称，时间（以分钟计），金额以及城市。</p>\n\n<p>返回&nbsp;<code>transactions</code>，返回可能无效的交易列表。你可以按 <strong>任何顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>transactions = [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\n<strong>输出：</strong>[\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\n<strong>解释：</strong>第一笔交易是无效的，因为第二笔交易和它间隔不超过 60 分钟、名称相同且发生在不同的城市。同样，第二笔交易也是无效的。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>transactions = [\"alice,20,800,mtv\",\"alice,50,1200,mtv\"]\n<strong>输出：</strong>[\"alice,50,1200,mtv\"]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>transactions = [\"alice,20,800,mtv\",\"bob,50,1200,mtv\"]\n<strong>输出：</strong>[\"bob,50,1200,mtv\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>transactions.length &lt;= 1000</code></li>\n\t<li>每笔交易&nbsp;<code>transactions[i]</code>&nbsp;按&nbsp;<code>\"{name},{time},{amount},{city}\"</code>&nbsp;的格式进行记录</li>\n\t<li>每个交易名称&nbsp;<code>{name}</code>&nbsp;和城市&nbsp;<code>{city}</code>&nbsp;都由小写英文字母组成，长度在&nbsp;<code>1</code>&nbsp;到&nbsp;<code>10</code>&nbsp;之间</li>\n\t<li>每个交易时间&nbsp;<code>{time}</code>&nbsp;由一些数字组成，表示一个&nbsp;<code>0</code>&nbsp;到&nbsp;<code>1000</code>&nbsp;之间的整数</li>\n\t<li>每笔交易金额&nbsp;<code>{amount}</code>&nbsp;由一些数字组成，表示一个&nbsp;<code>0</code> 到&nbsp;<code>2000</code>&nbsp;之间的整数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1170比较字符串最小字母出现频次",
        "hardRate": "MEDIUM",
        "passRate": "66.31%",
        "problemsUrl": "https://leetcode.cn/problems/compare-strings-by-frequency-of-the-smallest-character/",
        "solutionsUrl": "https://leetcode.cn/problems/compare-strings-by-frequency-of-the-smallest-character/solution",
        "problemsDesc": "<p>定义一个函数 <code>f(s)</code>，统计 <code>s</code>  中<strong>（按字典序比较）最小字母的出现频次</strong> ，其中 <code>s</code> 是一个非空字符串。</p>\n\n<p>例如，若 <code>s = \"dcce\"</code>，那么 <code>f(s) = 2</code>，因为字典序最小字母是 <code>\"c\"</code>，它出现了 2 次。</p>\n\n<p>现在，给你两个字符串数组待查表 <code>queries</code> 和词汇表 <code>words</code> 。对于每次查询 <code>queries[i]</code> ，需统计 <code>words</code> 中满足 <code>f(queries[i])</code> < <code>f(W)</code> 的<strong> 词的数目</strong> ，<code>W</code> 表示词汇表 <code>words</code> 中的每个词。</p>\n\n<p>请你返回一个整数数组 <code>answer</code> 作为答案，其中每个 <code>answer[i]</code> 是第 <code>i</code> 次查询的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>queries = [\"cbd\"], words = [\"zaaaz\"]\n<strong>输出：</strong>[1]\n<strong>解释：</strong>查询 f(\"cbd\") = 1，而 f(\"zaaaz\") = 3 所以 f(\"cbd\") < f(\"zaaaz\")。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>queries = [\"bbb\",\"cc\"], words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\n<strong>输出：</strong>[1,2]\n<strong>解释：</strong>第一个查询 f(\"bbb\") < f(\"aaaa\")，第二个查询 f(\"aaa\") 和 f(\"aaaa\") 都 > f(\"cc\")。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= queries.length <= 2000</code></li>\n\t<li><code>1 <= words.length <= 2000</code></li>\n\t<li><code>1 <= queries[i].length, words[i].length <= 10</code></li>\n\t<li><code>queries[i][j]</code>、<code>words[i][j]</code> 都由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1171从链表中删去总和值为零的连续节点",
        "hardRate": "MEDIUM",
        "passRate": "53.06%",
        "problemsUrl": "https://leetcode.cn/problems/remove-zero-sum-consecutive-nodes-from-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-zero-sum-consecutive-nodes-from-linked-list/solution",
        "problemsDesc": "<p>给你一个链表的头节点&nbsp;<code>head</code>，请你编写代码，反复删去链表中由 <strong>总和</strong>&nbsp;值为 <code>0</code> 的连续节点组成的序列，直到不存在这样的序列为止。</p>\n\n<p>删除完毕后，请你返回最终结果链表的头节点。</p>\n\n<p>&nbsp;</p>\n\n<p>你可以返回任何满足题目要求的答案。</p>\n\n<p>（注意，下面示例中的所有序列，都是对&nbsp;<code>ListNode</code>&nbsp;对象序列化的表示。）</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>head = [1,2,-3,3,1]\n<strong>输出：</strong>[3,1]\n<strong>提示：</strong>答案 [1,2,1] 也是正确的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>head = [1,2,3,-3,4]\n<strong>输出：</strong>[1,2,4]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>head = [1,2,3,-3,-2]\n<strong>输出：</strong>[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给你的链表中可能有 <code>1</code> 到&nbsp;<code>1000</code>&nbsp;个节点。</li>\n\t<li>对于链表中的每个节点，节点的值：<code>-1000 &lt;= node.val &lt;= 1000</code>.</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1172餐盘栈",
        "hardRate": "HARD",
        "passRate": "40.02%",
        "problemsUrl": "https://leetcode.cn/problems/dinner-plate-stacks/",
        "solutionsUrl": "https://leetcode.cn/problems/dinner-plate-stacks/solution",
        "problemsDesc": "<p>我们把无限数量 &infin; 的栈排成一行，按从左到右的次序从 0 开始编号。每个栈的的最大容量&nbsp;<code>capacity</code> 都相同。</p>\n\n<p>实现一个叫「餐盘」的类&nbsp;<code>DinnerPlates</code>：</p>\n\n<ul>\n\t<li><code>DinnerPlates(int capacity)</code>&nbsp;- 给出栈的最大容量&nbsp;<code>capacity</code>。</li>\n\t<li><code>void push(int val)</code>&nbsp;- 将给出的正整数&nbsp;<code>val</code>&nbsp;推入&nbsp;<strong>从左往右第一个&nbsp;</strong>没有满的栈。</li>\n\t<li><code>int pop()</code>&nbsp;- 返回&nbsp;<strong>从右往左第一个&nbsp;</strong>非空栈顶部的值，并将其从栈中删除；如果所有的栈都是空的，请返回&nbsp;<code>-1</code>。</li>\n\t<li><code>int popAtStack(int index)</code>&nbsp;- 返回编号&nbsp;<code>index</code>&nbsp;的栈顶部的值，并将其从栈中删除；如果编号&nbsp;<code>index</code>&nbsp;的栈是空的，请返回 <code>-1</code>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入： </strong>\n[&quot;DinnerPlates&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;popAtStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;popAtStack&quot;,&quot;popAtStack&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;]\n[[2],[1],[2],[3],[4],[5],[0],[20],[21],[0],[2],[],[],[],[],[]]\n<strong>输出：</strong>\n[null,null,null,null,null,null,2,null,null,20,21,5,4,3,1,-1]\n\n<strong>解释：</strong>\nDinnerPlates D = DinnerPlates(2);  // 初始化，栈最大容量 capacity = 2\nD.push(1);\nD.push(2);\nD.push(3);\nD.push(4);\nD.push(5);         // 栈的现状为：    2 &nbsp;4\n&nbsp;                                   1 &nbsp;3 &nbsp;5\n                                    ﹈ ﹈ ﹈\nD.popAtStack(0);   // 返回 2。栈的现状为：     &nbsp;4\n            &nbsp;                             1 &nbsp;3 &nbsp;5\n                                          ﹈ ﹈ ﹈\nD.push(20);        // 栈的现状为：  20  4\n&nbsp;                                  1 &nbsp;3 &nbsp;5\n                                   ﹈ ﹈ ﹈\nD.push(21);        // 栈的现状为：  20  4 21\n&nbsp;                                  1 &nbsp;3 &nbsp;5\n                                   ﹈ ﹈ ﹈\nD.popAtStack(0);   // 返回 20。栈的现状为：       4 21\n             &nbsp;                              1 &nbsp;3 &nbsp;5\n                                            ﹈ ﹈ ﹈\nD.popAtStack(2);   // 返回 21。栈的现状为：       4\n             &nbsp;                              1 &nbsp;3 &nbsp;5\n                                            ﹈ ﹈ ﹈ \nD.pop()            // 返回 5。栈的现状为：        4\n             &nbsp;                              1 &nbsp;3 \n                                            ﹈ ﹈  \nD.pop()            // 返回 4。栈的现状为：    1  3 \n                                           ﹈ ﹈   \nD.pop()            // 返回 3。栈的现状为：    1 \n                                           ﹈   \nD.pop()            // 返回 1。现在没有栈。\nD.pop()            // 返回 -1。仍然没有栈。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= capacity&nbsp;&lt;= 20000</code></li>\n\t<li><code>1 &lt;= val&nbsp;&lt;= 20000</code></li>\n\t<li><code>0 &lt;= index&nbsp;&lt;= 100000</code></li>\n\t<li>最多会对&nbsp;<code>push</code>，<code>pop</code>，和&nbsp;<code>popAtStack</code>&nbsp;进行 <code>200000</code> 次调用。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1173即时食物配送 I",
        "hardRate": "EASY",
        "passRate": "76.46%",
        "problemsUrl": "https://leetcode.cn/problems/immediate-food-delivery-i/",
        "solutionsUrl": "https://leetcode.cn/problems/immediate-food-delivery-i/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1174即时食物配送 II",
        "hardRate": "MEDIUM",
        "passRate": "61.77%",
        "problemsUrl": "https://leetcode.cn/problems/immediate-food-delivery-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/immediate-food-delivery-ii/solution",
        "problemsDesc": "<p>配送表: <code>Delivery</code></p>\n\n<pre>+-----------------------------+---------+\n| Column Name                 | Type    |\n+-----------------------------+---------+\n| delivery_id                 | int     |\n| customer_id                 | int     |\n| order_date                  | date    |\n| customer_pref_delivery_date | date    |\n+-----------------------------+---------+\ndelivery_id 是表的主键。\n该表保存着顾客的食物配送信息，顾客在某个日期下了订单，并指定了一个期望的配送日期（和下单日期相同或者在那之后）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>如果顾客期望的配送日期和下单日期相同，则该订单称为 「即时订单」，否则称为「计划订单」。</p>\n\n<p>「首次订单」是顾客最早创建的订单。我们保证一个顾客只会有一个「首次订单」。</p>\n\n<p>写一条 SQL 查询语句获取即时订单在所有用户的首次订单中的比例。<strong>保留两位小数。</strong></p>\n\n<p>&nbsp;</p>\n\n<p>查询结果如下所示：</p>\n\n<pre>Delivery 表：\n+-------------+-------------+------------+-----------------------------+\n| delivery_id | customer_id | order_date | customer_pref_delivery_date |\n+-------------+-------------+------------+-----------------------------+\n| 1           | 1           | 2019-08-01 | 2019-08-02                  |\n| 2           | 2           | 2019-08-02 | 2019-08-02                  |\n| 3           | 1           | 2019-08-11 | 2019-08-12                  |\n| 4           | 3           | 2019-08-24 | 2019-08-24                  |\n| 5           | 3           | 2019-08-21 | 2019-08-22                  |\n| 6           | 2           | 2019-08-11 | 2019-08-13                  |\n| 7           | 4           | 2019-08-09 | 2019-08-09                  |\n+-------------+-------------+------------+-----------------------------+\n\nResult 表：\n+----------------------+\n| immediate_percentage |\n+----------------------+\n| 50.00                |\n+----------------------+\n1 号顾客的 1 号订单是首次订单，并且是计划订单。\n2 号顾客的 2 号订单是首次订单，并且是即时订单。\n3 号顾客的 5 号订单是首次订单，并且是计划订单。\n4 号顾客的 7 号订单是首次订单，并且是即时订单。\n因此，一半顾客的首次订单是即时的。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1175质数排列",
        "hardRate": "EASY",
        "passRate": "56.31%",
        "problemsUrl": "https://leetcode.cn/problems/prime-arrangements/",
        "solutionsUrl": "https://leetcode.cn/problems/prime-arrangements/solution",
        "problemsDesc": "<p>请你帮忙给从 <code>1</code> 到 <code>n</code>&nbsp;的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。</p>\n\n<p>让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。</p>\n\n<p>由于答案可能会很大，所以请你返回答案 <strong>模 mod&nbsp;<code>10^9 + 7</code></strong>&nbsp;之后的结果即可。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 5\n<strong>输出：</strong>12\n<strong>解释：</strong>举个例子，[1,2,5,4,3] 是一个有效的排列，但 [5,2,3,4,1] 不是，因为在第二种情况里质数 5 被错误地放在索引为 1 的位置上。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 100\n<strong>输出：</strong>682289015\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1176健身计划评估",
        "hardRate": "EASY",
        "passRate": "48.51%",
        "problemsUrl": "https://leetcode.cn/problems/diet-plan-performance/",
        "solutionsUrl": "https://leetcode.cn/problems/diet-plan-performance/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1177构建回文串检测",
        "hardRate": "MEDIUM",
        "passRate": "41.90%",
        "problemsUrl": "https://leetcode.cn/problems/can-make-palindrome-from-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/can-make-palindrome-from-substring/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>，请你对&nbsp;<code>s</code>&nbsp;的子串进行检测。</p>\n\n<p>每次检测，待检子串都可以表示为&nbsp;<code>queries[i] = [left, right, k]</code>。我们可以 <strong>重新排列</strong> 子串&nbsp;<code>s[left], ..., s[right]</code>，并从中选择 <strong>最多</strong> <code>k</code>&nbsp;项替换成任何小写英文字母。&nbsp;</p>\n\n<p>如果在上述检测过程中，子串可以变成回文形式的字符串，那么检测结果为&nbsp;<code>true</code>，否则结果为&nbsp;<code>false</code>。</p>\n\n<p>返回答案数组&nbsp;<code>answer[]</code>，其中&nbsp;<code>answer[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个待检子串&nbsp;<code>queries[i]</code>&nbsp;的检测结果。</p>\n\n<p>注意：在替换时，子串中的每个字母都必须作为 <strong>独立的</strong> 项进行计数，也就是说，如果&nbsp;<code>s[left..right] = &quot;aaa&quot;</code>&nbsp;且&nbsp;<code>k = 2</code>，我们只能替换其中的两个字母。（另外，任何检测都不会修改原始字符串 <code>s</code>，可以认为每次检测都是独立的）</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abcda&quot;, queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]\n<strong>输出：</strong>[true,false,false,true,true]\n<strong>解释：</strong>\nqueries[0] : 子串 = &quot;d&quot;，回文。\nqueries[1] :&nbsp;子串 = &quot;bc&quot;，不是回文。\nqueries[2] :&nbsp;子串 = &quot;abcd&quot;，只替换 1 个字符是变不成回文串的。\nqueries[3] :&nbsp;子串 = &quot;abcd&quot;，可以变成回文的 &quot;abba&quot;。 也可以变成 &quot;baab&quot;，先重新排序变成 &quot;bacd&quot;，然后把 &quot;cd&quot; 替换为 &quot;ab&quot;。\nqueries[4] :&nbsp;子串 = &quot;abcda&quot;，可以变成回文的 &quot;abcba&quot;。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length,&nbsp;queries.length&nbsp;&lt;= 10^5</code></li>\n\t<li><code>0 &lt;= queries[i][0] &lt;= queries[i][1] &lt;&nbsp;s.length</code></li>\n\t<li><code>0 &lt;= queries[i][2] &lt;= s.length</code></li>\n\t<li><code>s</code> 中只有小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1178猜字谜",
        "hardRate": "HARD",
        "passRate": "46.72%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-valid-words-for-each-puzzle/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-valid-words-for-each-puzzle/solution",
        "problemsDesc": "<p>外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。</p>\n\n<p>字谜的迷面 <code>puzzle</code> 按字符串形式给出，如果一个单词 <code>word</code> 符合下面两个条件，那么它就可以算作谜底：</p>\n\n<ul>\n\t<li>单词 <code>word</code> 中包含谜面 <code>puzzle</code> 的第一个字母。</li>\n\t<li>单词 <code>word</code> 中的每一个字母都可以在谜面 <code>puzzle</code> 中找到。<br />\n\t例如，如果字谜的谜面是 \"abcdefg\"，那么可以作为谜底的单词有 \"faced\", \"cabbage\", 和 \"baggage\"；而 \"beefed\"（不含字母 \"a\"）以及 \"based\"（其中的 \"s\" 没有出现在谜面中）都不能作为谜底。</li>\n</ul>\n\n<p>返回一个答案数组 <code>answer</code>，数组中的每个元素 <code>answer[i]</code> 是在给出的单词列表 <code>words</code> 中可以作为字谜迷面 <code>puzzles[i]</code> 所对应的谜底的单词数目。</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nwords = [\"aaaa\",\"asas\",\"able\",\"ability\",\"actt\",\"actor\",\"access\"], \npuzzles = [\"aboveyz\",\"abrodyz\",\"abslute\",\"absoryz\",\"actresz\",\"gaswxyz\"]\n<strong>输出：</strong>[1,1,3,2,4,0]\n<strong>解释：</strong>\n1 个单词可以作为 \"aboveyz\" 的谜底 : \"aaaa\" \n1 个单词可以作为 \"abrodyz\" 的谜底 : \"aaaa\"\n3 个单词可以作为 \"abslute\" 的谜底 : \"aaaa\", \"asas\", \"able\"\n2 个单词可以作为 \"absoryz\" 的谜底 : \"aaaa\", \"asas\"\n4 个单词可以作为 \"actresz\" 的谜底 : \"aaaa\", \"asas\", \"actt\", \"access\"\n没有单词可以作为 \"gaswxyz\" 的谜底，因为列表中的单词都不含字母 'g'。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= words.length <= 10^5</code></li>\n\t<li><code>4 <= words[i].length <= 50</code></li>\n\t<li><code>1 <= puzzles.length <= 10^4</code></li>\n\t<li><code>puzzles[i].length == 7</code></li>\n\t<li><code>words[i][j]</code>, <code>puzzles[i][j]</code> 都是小写英文字母。</li>\n\t<li>每个 <code>puzzles[i]</code> 所包含的字符都不重复。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1179重新格式化部门表",
        "hardRate": "EASY",
        "passRate": "64.82%",
        "problemsUrl": "https://leetcode.cn/problems/reformat-department-table/",
        "solutionsUrl": "https://leetcode.cn/problems/reformat-department-table/solution",
        "problemsDesc": "<p>部门表&nbsp;<code>Department</code>：</p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| revenue       | int     |\n| month         | varchar |\n+---------------+---------+\n(id, month) 是表的联合主键。\n这个表格有关于每个部门每月收入的信息。\n月份（month）可以取下列值 [&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;,&quot;Apr&quot;,&quot;May&quot;,&quot;Jun&quot;,&quot;Jul&quot;,&quot;Aug&quot;,&quot;Sep&quot;,&quot;Oct&quot;,&quot;Nov&quot;,&quot;Dec&quot;]。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个 SQL 查询来重新格式化表，使得新的表中有一个部门 id 列和一些对应&nbsp;<strong>每个月 </strong>的收入（revenue）列。</p>\n\n<p>查询结果格式如下面的示例所示：</p>\n\n<pre>\nDepartment 表：\n+------+---------+-------+\n| id   | revenue | month |\n+------+---------+-------+\n| 1    | 8000    | Jan   |\n| 2    | 9000    | Jan   |\n| 3    | 10000   | Feb   |\n| 1    | 7000    | Feb   |\n| 1    | 6000    | Mar   |\n+------+---------+-------+\n\n查询得到的结果表：\n+------+-------------+-------------+-------------+-----+-------------+\n| id   | Jan_Revenue | Feb_Revenue | Mar_Revenue | ... | Dec_Revenue |\n+------+-------------+-------------+-------------+-----+-------------+\n| 1    | 8000        | 7000        | 6000        | ... | null        |\n| 2    | 9000        | null        | null        | ... | null        |\n| 3    | null        | 10000       | null        | ... | null        |\n+------+-------------+-------------+-------------+-----+-------------+\n\n注意，结果表有 13 列 (1个部门 id 列 + 12个月份的收入列)。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1180统计只含单一字母的子串",
        "hardRate": "EASY",
        "passRate": "78.12%",
        "problemsUrl": "https://leetcode.cn/problems/count-substrings-with-only-one-distinct-letter/",
        "solutionsUrl": "https://leetcode.cn/problems/count-substrings-with-only-one-distinct-letter/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1181前后拼接",
        "hardRate": "MEDIUM",
        "passRate": "39.80%",
        "problemsUrl": "https://leetcode.cn/problems/before-and-after-puzzle/",
        "solutionsUrl": "https://leetcode.cn/problems/before-and-after-puzzle/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1182与目标颜色间的最短距离",
        "hardRate": "MEDIUM",
        "passRate": "47.72%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-distance-to-target-color/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-distance-to-target-color/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1183矩阵中 1 的最大数量",
        "hardRate": "HARD",
        "passRate": "62.50%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-ones/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-ones/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1184公交站间的距离",
        "hardRate": "EASY",
        "passRate": "61.79%",
        "problemsUrl": "https://leetcode.cn/problems/distance-between-bus-stops/",
        "solutionsUrl": "https://leetcode.cn/problems/distance-between-bus-stops/solution",
        "problemsDesc": "<p>环形公交路线上有&nbsp;<code>n</code>&nbsp;个站，按次序从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;进行编号。我们已知每一对相邻公交站之间的距离，<code>distance[i]</code>&nbsp;表示编号为&nbsp;<code>i</code>&nbsp;的车站和编号为&nbsp;<code>(i + 1) % n</code>&nbsp;的车站之间的距离。</p>\n\n<p>环线上的公交车都可以按顺时针和逆时针的方向行驶。</p>\n\n<p>返回乘客从出发点&nbsp;<code>start</code>&nbsp;到目的地&nbsp;<code>destination</code>&nbsp;之间的最短距离。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1.jpg\" style=\"height: 240px; width: 388px;\"></p>\n\n<pre><strong>输入：</strong>distance = [1,2,3,4], start = 0, destination = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>公交站 0 和 1 之间的距离是 1 或 9，最小值是 1。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1-1.jpg\" style=\"height: 240px; width: 388px;\"></p>\n\n<pre><strong>输入：</strong>distance = [1,2,3,4], start = 0, destination = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>公交站 0 和 2 之间的距离是 3 或 7，最小值是 3。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1-2.jpg\" style=\"height: 240px; width: 388px;\"></p>\n\n<pre><strong>输入：</strong>distance = [1,2,3,4], start = 0, destination = 3\n<strong>输出：</strong>4\n<strong>解释：</strong>公交站 0 和 3 之间的距离是 6 或 4，最小值是 4。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n&nbsp;&lt;= 10^4</code></li>\n\t<li><code>distance.length == n</code></li>\n\t<li><code>0 &lt;= start, destination &lt; n</code></li>\n\t<li><code>0 &lt;= distance[i] &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1185一周中的第几天",
        "hardRate": "EASY",
        "passRate": "62.20%",
        "problemsUrl": "https://leetcode.cn/problems/day-of-the-week/",
        "solutionsUrl": "https://leetcode.cn/problems/day-of-the-week/solution",
        "problemsDesc": "<p>给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。</p>\n\n<p>输入为三个整数：<code>day</code>、<code>month</code> 和&nbsp;<code>year</code>，分别表示日、月、年。</p>\n\n<p>您返回的结果必须是这几个值中的一个&nbsp;<code>{&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;}</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>day = 31, month = 8, year = 2019\n<strong>输出：</strong>&quot;Saturday&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>day = 18, month = 7, year = 1999\n<strong>输出：</strong>&quot;Sunday&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>day = 15, month = 8, year = 1993\n<strong>输出：</strong>&quot;Sunday&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给出的日期一定是在&nbsp;<code>1971</code> 到&nbsp;<code>2100</code>&nbsp;年之间的有效日期。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1186删除一次得到子数组最大和",
        "hardRate": "MEDIUM",
        "passRate": "48.02%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/solution",
        "problemsDesc": "<p>给你一个整数数组，返回它的某个&nbsp;<strong>非空</strong> 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。</p>\n\n<p>注意，删除一个元素后，子数组 <strong>不能为空</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,-2,0,3]\n<strong>输出：</strong>4\n<strong>解释：</strong>我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,-2,-2,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>我们直接选出 [3]，这就是最大和。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [-1,-1,-1,-1]\n<strong>输出：</strong>-1\n<strong>解释：</strong>最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。\n     我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= arr[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1187使数组严格递增",
        "hardRate": "HARD",
        "passRate": "59.84%",
        "problemsUrl": "https://leetcode.cn/problems/make-array-strictly-increasing/",
        "solutionsUrl": "https://leetcode.cn/problems/make-array-strictly-increasing/solution",
        "problemsDesc": "<p>给你两个整数数组&nbsp;<code>arr1</code> 和 <code>arr2</code>，返回使&nbsp;<code>arr1</code>&nbsp;严格递增所需要的最小「操作」数（可能为 0）。</p>\n\n<p>每一步「操作」中，你可以分别从 <code>arr1</code> 和 <code>arr2</code> 中各选出一个索引，分别为&nbsp;<code>i</code> 和&nbsp;<code>j</code>，<code>0 &lt;=&nbsp;i &lt; arr1.length</code>&nbsp;和&nbsp;<code>0 &lt;= j &lt; arr2.length</code>，然后进行赋值运算&nbsp;<code>arr1[i] = arr2[j]</code>。</p>\n\n<p>如果无法让&nbsp;<code>arr1</code>&nbsp;严格递增，请返回&nbsp;<code>-1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]\n<strong>输出：</strong>1\n<strong>解释：</strong>用 2 来替换 <code>5，之后</code> <code>arr1 = [1, 2, 3, 6, 7]</code>。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr1 = [1,5,3,6,7], arr2 = [4,3,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>用 3 来替换 <code>5，然后</code>用 4 来替换 3<code>，得到</code> <code>arr1 = [1, 3, 4, 6, 7]</code>。\n</pre>\n\n<p><strong class=\"example\">示例&nbsp;3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]\n<strong>输出：</strong>-1\n<strong>解释：</strong>无法使 <code>arr1 严格递增</code>。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr1.length, arr2.length &lt;= 2000</code></li>\n\t<li><code>0 &lt;= arr1[i], arr2[i] &lt;= 10^9</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1188设计有限阻塞队列",
        "hardRate": "MEDIUM",
        "passRate": "70.31%",
        "problemsUrl": "https://leetcode.cn/problems/design-bounded-blocking-queue/",
        "solutionsUrl": "https://leetcode.cn/problems/design-bounded-blocking-queue/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1189“气球” 的最大数量",
        "hardRate": "EASY",
        "passRate": "68.27%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-balloons/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-balloons/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>text</code>，你需要使用 <code>text</code> 中的字母来拼凑尽可能多的单词&nbsp;<strong>&quot;balloon&quot;（气球）</strong>。</p>\n\n<p>字符串&nbsp;<code>text</code> 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词&nbsp;<strong>&quot;balloon&quot;</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/14/1536_ex1_upd.jpeg\" style=\"height: 35px; width: 154px;\"></strong></p>\n\n<pre><strong>输入：</strong>text = &quot;nlaebolko&quot;\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/14/1536_ex2_upd.jpeg\" style=\"height: 35px; width: 233px;\"></strong></p>\n\n<pre><strong>输入：</strong>text = &quot;loonbalxballpoon&quot;\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;leetcode&quot;\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 10^4</code></li>\n\t<li><code>text</code>&nbsp;全部由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1190反转每对括号间的子串",
        "hardRate": "MEDIUM",
        "passRate": "64.77%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-substrings-between-each-pair-of-parentheses/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-substrings-between-each-pair-of-parentheses/solution",
        "problemsDesc": "<p>给出一个字符串&nbsp;<code>s</code>（仅含有小写英文字母和括号）。</p>\n\n<p>请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。</p>\n\n<p>注意，您的结果中 <strong>不应</strong> 包含任何括号。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(abcd)\"\n<strong>输出：</strong>\"dcba\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(u(love)i)\"\n<strong>输出：</strong>\"iloveu\"\n<strong>解释：</strong>先反转子字符串 \"love\" ，然后反转整个字符串。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(ed(et(oc))el)\"\n<strong>输出：</strong>\"leetcode\"\n<strong>解释：</strong>先反转子字符串 \"oc\" ，接着反转 \"etco\" ，然后反转整个字符串。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a(bcdefghijkl(mno)p)q\"\n<strong>输出：</strong>\"apmnolkjihgfedcbq\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code> 中只有小写英文字母和括号</li>\n\t<li>题目测试用例确保所有括号都是成对出现的</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1191K 次串联后最大子数组之和",
        "hardRate": "MEDIUM",
        "passRate": "27.04%",
        "problemsUrl": "https://leetcode.cn/problems/k-concatenation-maximum-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/k-concatenation-maximum-sum/solution",
        "problemsDesc": "<p>给定一个整数数组&nbsp;<code>arr</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;，通过重复&nbsp;<code>k</code>&nbsp;次来修改数组。</p>\n\n<p>例如，如果&nbsp;<code>arr = [1, 2]</code>&nbsp;，<meta charset=\"UTF-8\" />&nbsp;<code>k = 3</code>&nbsp;，那么修改后的数组将是 <code>[1, 2, 1, 2, 1, 2]</code> 。</p>\n\n<p>返回修改后的数组中的最大的子数组之和。注意，子数组长度可以是 <code>0</code>，在这种情况下它的总和也是 <code>0</code>。</p>\n\n<p>由于&nbsp;<strong>结果可能会很大</strong>，需要返回的<meta charset=\"UTF-8\" />&nbsp;<code>10<sup>9</sup>&nbsp;+ 7</code>&nbsp;的&nbsp;<strong>模</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2], k = 3\n<strong>输出：</strong>9\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,-2,1], k = 5\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [-1,-2], k = 7\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= arr[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1192查找集群内的关键连接",
        "hardRate": "HARD",
        "passRate": "54.34%",
        "problemsUrl": "https://leetcode.cn/problems/critical-connections-in-a-network/",
        "solutionsUrl": "https://leetcode.cn/problems/critical-connections-in-a-network/solution",
        "problemsDesc": "<p>力扣数据中心有&nbsp;<code>n</code>&nbsp;台服务器，分别按从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n-1</code>&nbsp;的方式进行了编号。它们之间以 <strong>服务器到服务器</strong> 的形式相互连接组成了一个内部集群，连接是无向的。用 &nbsp;<code>connections</code> 表示集群网络，<code>connections[i] = [a, b]</code>&nbsp;表示服务器 <code>a</code>&nbsp;和 <code>b</code>&nbsp;之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。</p>\n\n<p><strong>关键连接</strong><em> </em>是在该集群中的重要连接，假如我们将它移除，便会导致某些服务器无法访问其他服务器。</p>\n\n<p>请你以任意顺序返回该集群内的所有 <strong>关键连接</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/critical-connections-in-a-network.png\" style=\"height: 205px; width: 200px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]\n<strong>输出：</strong>[[1,3]]\n<strong>解释：</strong>[[3,1]] 也是正确的。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<b>输入：</b>n = 2, connections = [[0,1]]\n<b>输出：</b>[[0,1]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>n - 1 &lt;= connections.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>不存在重复的连接</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1193每月交易 I",
        "hardRate": "MEDIUM",
        "passRate": "60.81%",
        "problemsUrl": "https://leetcode.cn/problems/monthly-transactions-i/",
        "solutionsUrl": "https://leetcode.cn/problems/monthly-transactions-i/solution",
        "problemsDesc": "<p>Table: <code>Transactions</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| country       | varchar |\n| state         | enum    |\n| amount        | int     |\n| trans_date    | date    |\n+---------------+---------+\nid 是这个表的主键。\n该表包含有关传入事务的信息。\nstate 列类型为 “[”批准“，”拒绝“] 之一。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个 sql 查询来查找每个月和每个国家/地区的事务数及其总金额、已批准的事务数及其总金额。</p>\n\n<p>以 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<code><strong>输入：</strong>\nTransactions</code> table:\n+------+---------+----------+--------+------------+\n| id   | country | state    | amount | trans_date |\n+------+---------+----------+--------+------------+\n| 121  | US      | approved | 1000   | 2018-12-18 |\n| 122  | US      | declined | 2000   | 2018-12-19 |\n| 123  | US      | approved | 2000   | 2019-01-01 |\n| 124  | DE      | approved | 2000   | 2019-01-07 |\n+------+---------+----------+--------+------------+\n<strong>输出：</strong>\n+----------+---------+-------------+----------------+--------------------+-----------------------+\n| month    | country | trans_count | approved_count | trans_total_amount | approved_total_amount |\n+----------+---------+-------------+----------------+--------------------+-----------------------+\n| 2018-12  | US      | 2           | 1              | 3000               | 1000                  |\n| 2019-01  | US      | 1           | 1              | 2000               | 2000                  |\n| 2019-01  | DE      | 1           | 1              | 2000               | 2000                  |\n+----------+---------+-------------+----------------+--------------------+-----------------------+</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1194锦标赛优胜者",
        "hardRate": "HARD",
        "passRate": "51.09%",
        "problemsUrl": "https://leetcode.cn/problems/tournament-winners/",
        "solutionsUrl": "https://leetcode.cn/problems/tournament-winners/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1195交替打印字符串",
        "hardRate": "MEDIUM",
        "passRate": "65.00%",
        "problemsUrl": "https://leetcode.cn/problems/fizz-buzz-multithreaded/",
        "solutionsUrl": "https://leetcode.cn/problems/fizz-buzz-multithreaded/solution",
        "problemsDesc": "<p>编写一个可以从 1 到 n 输出代表这个数字的字符串的程序，但是：</p>\n\n<ul>\n\t<li>如果这个数字可以被 3 整除，输出 \"fizz\"。</li>\n\t<li>如果这个数字可以被 5 整除，输出 \"buzz\"。</li>\n\t<li>如果这个数字可以同时被 3 和 5 整除，输出 \"fizzbuzz\"。</li>\n</ul>\n\n<p>例如，当 <code>n = 15</code>，输出： <code>1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz</code>。</p>\n\n<p>假设有这么一个类：</p>\n\n<pre>\nclass FizzBuzz {\n  public FizzBuzz(int n) { ... }               // constructor\n  public void fizz(printFizz) { ... }          // only output \"fizz\"\n  public void buzz(printBuzz) { ... }          // only output \"buzz\"\n  public void fizzbuzz(printFizzBuzz) { ... }  // only output \"fizzbuzz\"\n  public void number(printNumber) { ... }      // only output the numbers\n}</pre>\n\n<p>请你实现一个有四个线程的多线程版  <code>FizzBuzz</code>， 同一个 <code>FizzBuzz</code> 实例会被如下四个线程使用：</p>\n\n<ol>\n\t<li>线程A将调用 <code>fizz()</code> 来判断是否能被 3 整除，如果可以，则输出 <code>fizz</code>。</li>\n\t<li>线程B将调用 <code>buzz()</code> 来判断是否能被 5 整除，如果可以，则输出 <code>buzz</code>。</li>\n\t<li>线程C将调用 <code>fizzbuzz()</code> 来判断是否同时能被 3 和 5 整除，如果可以，则输出 <code>fizzbuzz</code>。</li>\n\t<li>线程D将调用 <code>number()</code> 来实现输出既不能被 3 整除也不能被 5 整除的数字。</li>\n</ol>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>本题已经提供了打印字符串的相关方法，如 <code>printFizz()</code> 等，具体方法名请参考答题模板中的注释部分。</li>\n</ul>\n\n<p> </p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1196最多可以买到的苹果数量",
        "hardRate": "EASY",
        "passRate": "68.21%",
        "problemsUrl": "https://leetcode.cn/problems/how-many-apples-can-you-put-into-the-basket/",
        "solutionsUrl": "https://leetcode.cn/problems/how-many-apples-can-you-put-into-the-basket/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1197进击的骑士",
        "hardRate": "MEDIUM",
        "passRate": "39.20%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-knight-moves/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-knight-moves/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1198找出所有行中最小公共元素",
        "hardRate": "MEDIUM",
        "passRate": "73.94%",
        "problemsUrl": "https://leetcode.cn/problems/find-smallest-common-element-in-all-rows/",
        "solutionsUrl": "https://leetcode.cn/problems/find-smallest-common-element-in-all-rows/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1199建造街区的最短时间",
        "hardRate": "HARD",
        "passRate": "47.27%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-build-blocks/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-build-blocks/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1200最小绝对差",
        "hardRate": "EASY",
        "passRate": "72.46%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-absolute-difference/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-absolute-difference/solution",
        "problemsDesc": "<p>给你个整数数组&nbsp;<code>arr</code>，其中每个元素都 <strong>不相同</strong>。</p>\n\n<p>请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。</p>\n\n<p>每对元素对 <code>[a,b</code>] 如下：</p>\n\n<ul>\n\t<li><code>a ,&nbsp;b</code>&nbsp;均为数组&nbsp;<code>arr</code>&nbsp;中的元素</li>\n\t<li><code>a &lt; b</code></li>\n\t<li><code>b - a</code>&nbsp;等于 <code>arr</code> 中任意两个元素的最小绝对差</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [4,2,1,3]\n<strong>输出：</strong>[[1,2],[2,3],[3,4]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,3,6,10,15]\n<strong>输出：</strong>[[1,3]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [3,8,-10,23,19,-4,-14,27]\n<strong>输出：</strong>[[-14,-10],[19,23],[23,27]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 10^5</code></li>\n\t<li><code>-10^6 &lt;= arr[i] &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1201丑数 III",
        "hardRate": "MEDIUM",
        "passRate": "28.47%",
        "problemsUrl": "https://leetcode.cn/problems/ugly-number-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/ugly-number-iii/solution",
        "problemsDesc": "<p>给你四个整数：<code>n</code> 、<code>a</code> 、<code>b</code> 、<code>c</code> ，请你设计一个算法来找出第 <code>n</code> 个丑数。</p>\n\n<p>丑数是可以被 <code>a</code> <strong>或</strong> <code>b</code> <strong>或</strong> <code>c</code> 整除的 <strong>正整数</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, a = 2, b = 3, c = 5\n<strong>输出：</strong>4\n<strong>解释：</strong>丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, a = 2, b = 3, c = 4\n<strong>输出：</strong>6\n<strong>解释：</strong>丑数序列为 2, 3, 4, 6, 8, 9, 10, 12... 其中第 4 个是 6。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, a = 2, b = 11, c = 13\n<strong>输出：</strong>10\n<strong>解释：</strong>丑数序列为 2, 4, 6, 8, 10, 11, 12, 13... 其中第 5 个是 10。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1000000000, a = 2, b = 217983653, c = 336916467\n<strong>输出：</strong>1999999984\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n, a, b, c <= 10^9</code></li>\n\t<li><code>1 <= a * b * c <= 10^18</code></li>\n\t<li>本题结果在 <code>[1, 2 * 10^9]</code> 的范围内</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1202交换字符串中的元素",
        "hardRate": "MEDIUM",
        "passRate": "51.35%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-string-with-swaps/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-string-with-swaps/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>，以及该字符串中的一些「索引对」数组&nbsp;<code>pairs</code>，其中&nbsp;<code>pairs[i] =&nbsp;[a, b]</code>&nbsp;表示字符串中的两个索引（编号从 0 开始）。</p>\n\n<p>你可以 <strong>任意多次交换</strong> 在&nbsp;<code>pairs</code>&nbsp;中任意一对索引处的字符。</p>\n\n<p>返回在经过若干次交换后，<code>s</code>&nbsp;可以变成的按字典序最小的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;dcab&quot;, pairs = [[0,3],[1,2]]\n<strong>输出：</strong>&quot;bacd&quot;\n<strong>解释：</strong> \n交换 s[0] 和 s[3], s = &quot;bcad&quot;\n交换 s[1] 和 s[2], s = &quot;bacd&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;dcab&quot;, pairs = [[0,3],[1,2],[0,2]]\n<strong>输出：</strong>&quot;abcd&quot;\n<strong>解释：</strong>\n交换 s[0] 和 s[3], s = &quot;bcad&quot;\n交换 s[0] 和 s[2], s = &quot;acbd&quot;\n交换 s[1] 和 s[2], s = &quot;abcd&quot;</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;cba&quot;, pairs = [[0,1],[1,2]]\n<strong>输出：</strong>&quot;abc&quot;\n<strong>解释：</strong>\n交换 s[0] 和 s[1], s = &quot;bca&quot;\n交换 s[1] 和 s[2], s = &quot;bac&quot;\n交换 s[0] 和 s[1], s = &quot;abc&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= pairs.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= pairs[i][0], pairs[i][1] &lt;&nbsp;s.length</code></li>\n\t<li><code>s</code>&nbsp;中只含有小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1203项目管理",
        "hardRate": "HARD",
        "passRate": "60.83%",
        "problemsUrl": "https://leetcode.cn/problems/sort-items-by-groups-respecting-dependencies/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-items-by-groups-respecting-dependencies/solution",
        "problemsDesc": "<p>有 <code>n</code> 个项目，每个项目或者不属于任何小组，或者属于 <code>m</code> 个小组之一。<code>group[i]</code> 表示第 <code>i</code> 个项目所属的小组，如果第 <code>i</code> 个项目不属于任何小组，则 <code>group[i]</code> 等于 <code>-1</code>。项目和小组都是从零开始编号的。可能存在小组不负责任何项目，即没有任何项目属于这个小组。</p>\n\n<p>请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：</p>\n\n<ul>\n\t<li>同一小组的项目，排序后在列表中彼此相邻。</li>\n\t<li>项目之间存在一定的依赖关系，我们用一个列表 <code>beforeItems</code> 来表示，其中 <code>beforeItems[i]</code> 表示在进行第 <code>i</code> 个项目前（位于第 <code>i</code> 个项目左侧）应该完成的所有项目。</li>\n</ul>\n\n<p>如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个 <strong>空列表 </strong>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/22/1359_ex1.png\" style=\"height: 181px; width: 191px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]\n<strong>输出：</strong>[6,3,4,1,5,2,0,7]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]\n<strong>输出：</strong>[]\n<strong>解释：</strong>与示例 1 大致相同，但是在排序后的列表中，4 必须放在 6 的前面。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= m <= n <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>group.length == beforeItems.length == n</code></li>\n\t<li><code>-1 <= group[i] <= m - 1</code></li>\n\t<li><code>0 <= beforeItems[i].length <= n - 1</code></li>\n\t<li><code>0 <= beforeItems[i][j] <= n - 1</code></li>\n\t<li><code>i != beforeItems[i][j]</code></li>\n\t<li><code>beforeItems[i]</code> 不含重复元素</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1204最后一个能进入电梯的人",
        "hardRate": "MEDIUM",
        "passRate": "73.97%",
        "problemsUrl": "https://leetcode.cn/problems/last-person-to-fit-in-the-bus/",
        "solutionsUrl": "https://leetcode.cn/problems/last-person-to-fit-in-the-bus/solution",
        "problemsDesc": "<p>表: <code>Queue</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| person_id   | int     |\n| person_name | varchar |\n| weight      | int     |\n| turn        | int     |\n+-------------+---------+\nperson_id 是这个表的主键。\n该表展示了所有等待电梯的人的信息。\n表中 person_id 和 turn 列将包含从 1 到 n 的所有数字，其中 n 是表中的行数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>有一群人在等着上公共汽车。然而，巴士有<code>1000</code>&nbsp;公斤的重量限制，所以可能会有一些人不能上。</p>\n\n<p>写一条 SQL 查询语句查找 <strong>最后一个</strong> 能进入电梯且不超过重量限制的 <code>person_name</code> 。题目确保队列中第一位的人可以进入电梯，不会超重。</p>\n\n<p>查询结果如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nQueue 表\n+-----------+-------------------+--------+------+\n| person_id | person_name       | weight | turn |\n+-----------+-------------------+--------+------+\n| 5         | George Washington | 250    | 1    |\n| 3         | John Adams        | 350    | 2    |\n| 6         | Thomas Jefferson  | 400    | 3    |\n| 2         | Will Johnliams    | 200    | 4    |\n| 4         | Thomas Jefferson  | 175    | 5    |\n| 1         | James Elephant    | 500    | 6    |\n+-----------+-------------------+--------+------+\n<strong>输出：</strong>\n+-------------------+\n| person_name       |\n+-------------------+\n| Thomas Jefferson  |\n+-------------------+\n<strong>解释：</strong>\n为了简化，Queue 表按 turn 列由小到大排序。\n上例中 George Washington(id 5), John Adams(id 3) 和 Thomas Jefferson(id 6) 将可以进入电梯,因为他们的体重和为 250 + 350 + 400 = 1000。\nThomas Jefferson(id 6) 是最后一个体重合适并进入电梯的人。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1205每月交易II",
        "hardRate": "MEDIUM",
        "passRate": "45.73%",
        "problemsUrl": "https://leetcode.cn/problems/monthly-transactions-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/monthly-transactions-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1206设计跳表",
        "hardRate": "HARD",
        "passRate": "68.25%",
        "problemsUrl": "https://leetcode.cn/problems/design-skiplist/",
        "solutionsUrl": "https://leetcode.cn/problems/design-skiplist/solution",
        "problemsDesc": "<p>不使用任何库函数，设计一个 <strong>跳表</strong> 。</p>\n\n<p><strong>跳表</strong> 是在 <code>O(log(n))</code> 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。</p>\n\n<p>例如，一个跳表包含 <code>[30, 40, 50, 60, 70, 90]</code> ，然后增加 <code>80</code>、<code>45</code> 到跳表中，以下图的方式操作：</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/27/1506_skiplist.gif\" /><br />\n<small>Artyom Kalinin [CC BY-SA 3.0], via <a href=\"https://commons.wikimedia.org/wiki/File:Skip_list_add_element-en.gif\" target=\"_blank\" title=\"Artyom Kalinin [CC BY-SA 3.0 (https://creativecommons.org/licenses/by-sa/3.0)], via Wikimedia Commons\">Wikimedia Commons</a></small></p>\n\n<p>跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 <code>O(n)</code>。跳表的每一个操作的平均时间复杂度是 <code>O(log(n))</code>，空间复杂度是 <code>O(n)</code>。</p>\n\n<p>了解更多 :&nbsp;<a href=\"https://en.wikipedia.org/wiki/Skip_list\" target=\"_blank\">https://en.wikipedia.org/wiki/Skip_list</a></p>\n\n<p>在本题中，你的设计应该要包含这些函数：</p>\n\n<ul>\n\t<li><code>bool search(int target)</code> : 返回target是否存在于跳表中。</li>\n\t<li><code>void add(int num)</code>:&nbsp;插入一个元素到跳表。</li>\n\t<li><code>bool erase(int num)</code>: 在跳表中删除一个值，如果&nbsp;<code>num</code>&nbsp;不存在，直接返回false. 如果存在多个&nbsp;<code>num</code>&nbsp;，删除其中任意一个即可。</li>\n</ul>\n\n<p>注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<b>输入</b>\n[\"Skiplist\", \"add\", \"add\", \"add\", \"search\", \"add\", \"search\", \"erase\", \"erase\", \"search\"]\n[[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]\n<strong>输出</strong>\n[null, null, null, null, false, null, true, false, true, false]\n\n<strong>解释</strong>\nSkiplist skiplist = new Skiplist();\nskiplist.add(1);\nskiplist.add(2);\nskiplist.add(3);\nskiplist.search(0);   // 返回 false\nskiplist.add(4);\nskiplist.search(1);   // 返回 true\nskiplist.erase(0);    // 返回 false，0 不在跳表中\nskiplist.erase(1);    // 返回 true\nskiplist.search(1);   // 返回 false，1 已被擦除\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num, target &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li>调用<code>search</code>, <code>add</code>, &nbsp;<code>erase</code>操作次数不大于&nbsp;<code>5 * 10<sup>4</sup></code>&nbsp;</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1207独一无二的出现次数",
        "hardRate": "EASY",
        "passRate": "72.79%",
        "problemsUrl": "https://leetcode.cn/problems/unique-number-of-occurrences/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-number-of-occurrences/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code>，请你帮忙统计数组中每个数的出现次数。</p>\n\n<p>如果每个数的出现次数都是独一无二的，就返回&nbsp;<code>true</code>；否则返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,2,1,1,3]\n<strong>输出：</strong>true\n<strong>解释：</strong>在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [-3,0,1,-3,1,1,1,-3,10,0]\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length&nbsp;&lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= arr[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1208尽可能使字符串相等",
        "hardRate": "MEDIUM",
        "passRate": "50.00%",
        "problemsUrl": "https://leetcode.cn/problems/get-equal-substrings-within-budget/",
        "solutionsUrl": "https://leetcode.cn/problems/get-equal-substrings-within-budget/solution",
        "problemsDesc": "<p>给你两个长度相同的字符串，<code>s</code> 和 <code>t</code>。</p>\n\n<p>将 <code>s</code> 中的第 <code>i</code> 个字符变到 <code>t</code> 中的第 <code>i</code> 个字符需要 <code>|s[i] - t[i]|</code> 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。</p>\n\n<p>用于变更字符串的最大预算是 <code>maxCost</code>。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。</p>\n\n<p>如果你可以将 <code>s</code> 的子字符串转化为它在 <code>t</code> 中对应的子字符串，则返回可以转化的最大长度。</p>\n\n<p>如果 <code>s</code> 中没有子字符串可以转化成 <code>t</code> 中对应的子字符串，则返回 <code>0</code>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\", t = \"bcdf\", maxCost = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>s<strong> </strong>中的<strong> </strong>\"abc\" 可以变为 \"bcd\"。开销为 3，所以最大长度为 3。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\", t = \"cdef\", maxCost = 3\n<strong>输出：</strong>1\n<strong>解释：</strong>s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为<code> 1。</code>\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\", t = \"acde\", maxCost = 0\n<strong>输出：</strong>1\n<strong>解释：</strong>a -> a, cost = 0，字符串未发生变化，所以最大长度为 1。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length, t.length <= 10^5</code></li>\n\t<li><code>0 <= maxCost <= 10^6</code></li>\n\t<li><code>s</code> 和 <code>t</code> 都只含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1209删除字符串中的所有相邻重复项 II",
        "hardRate": "MEDIUM",
        "passRate": "50.69%",
        "problemsUrl": "https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string-ii/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>，「<code>k</code> 倍重复项删除操作」将会从 <code>s</code>&nbsp;中选择&nbsp;<code>k</code>&nbsp;个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。</p>\n\n<p>你需要对&nbsp;<code>s</code>&nbsp;重复进行无限次这样的删除操作，直到无法继续为止。</p>\n\n<p>在执行完所有删除操作后，返回最终得到的字符串。</p>\n\n<p>本题答案保证唯一。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abcd&quot;, k = 2\n<strong>输出：</strong>&quot;abcd&quot;\n<strong>解释：</strong>没有要删除的内容。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;deeedbbcccbdaa&quot;, k = 3\n<strong>输出：</strong>&quot;aa&quot;\n<strong>解释： \n</strong>先删除 &quot;eee&quot; 和 &quot;ccc&quot;，得到 &quot;ddbbbdaa&quot;\n再删除 &quot;bbb&quot;，得到 &quot;dddaa&quot;\n最后删除 &quot;ddd&quot;，得到 &quot;aa&quot;</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;pbbcggttciiippooaais&quot;, k = 2\n<strong>输出：</strong>&quot;ps&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>2 &lt;= k &lt;= 10^4</code></li>\n\t<li><code>s</code>&nbsp;中只含有小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1210穿过迷宫的最少移动次数",
        "hardRate": "HARD",
        "passRate": "64.32%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-moves-to-reach-target-with-rotations/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-moves-to-reach-target-with-rotations/solution",
        "problemsDesc": "<p>你还记得那条风靡全球的贪吃蛇吗？</p>\n\n<p>我们在一个&nbsp;<code>n*n</code>&nbsp;的网格上构建了新的迷宫地图，蛇的长度为 2，也就是说它会占去两个单元格。蛇会从左上角（<code>(0, 0)</code>&nbsp;和&nbsp;<code>(0, 1)</code>）开始移动。我们用 <code>0</code> 表示空单元格，用 1 表示障碍物。蛇需要移动到迷宫的右下角（<code>(n-1, n-2)</code>&nbsp;和&nbsp;<code>(n-1, n-1)</code>）。</p>\n\n<p>每次移动，蛇可以这样走：</p>\n\n<ul>\n\t<li>如果没有障碍，则向右移动一个单元格。并仍然保持身体的水平／竖直状态。</li>\n\t<li>如果没有障碍，则向下移动一个单元格。并仍然保持身体的水平／竖直状态。</li>\n\t<li>如果它处于水平状态并且其下面的两个单元都是空的，就顺时针旋转 90 度。蛇从（<code>(r, c)</code>、<code>(r, c+1)</code>）移动到 （<code>(r, c)</code>、<code>(r+1, c)</code>）。<br>\n\t<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/28/image-2.png\" style=\"height: 134px; width: 300px;\"></li>\n\t<li>如果它处于竖直状态并且其右面的两个单元都是空的，就逆时针旋转 90 度。蛇从（<code>(r, c)</code>、<code>(r+1, c)</code>）移动到（<code>(r, c)</code>、<code>(r, c+1)</code>）。<br>\n\t<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/28/image-1.png\" style=\"height: 121px; width: 300px;\"></li>\n</ul>\n\n<p>返回蛇抵达目的地所需的最少移动次数。</p>\n\n<p>如果无法到达目的地，请返回&nbsp;<code>-1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/28/image.png\" style=\"height: 439px; width: 400px;\"></strong></p>\n\n<pre><strong>输入：</strong>grid = [[0,0,0,0,0,1],\n               [1,1,0,0,1,0],\n&nbsp;              [0,0,0,0,1,1],\n&nbsp;              [0,0,1,0,1,0],\n&nbsp;              [0,1,1,0,0,0],\n&nbsp;              [0,1,1,0,0,0]]\n<strong>输出：</strong>11\n<strong>解释：\n</strong>一种可能的解决方案是 [右, 右, 顺时针旋转, 右, 下, 下, 下, 下, 逆时针旋转, 右, 下]。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[0,0,1,1,1,1],\n&nbsp;              [0,0,0,0,1,1],\n&nbsp;              [1,1,0,0,0,1],\n&nbsp;              [1,1,1,0,0,1],\n&nbsp;              [1,1,1,0,0,1],\n&nbsp;              [1,1,1,0,0,0]]\n<strong>输出：</strong>9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 1</code></li>\n\t<li>蛇保证从空单元格开始出发。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1211查询结果的质量和占比",
        "hardRate": "EASY",
        "passRate": "67.42%",
        "problemsUrl": "https://leetcode.cn/problems/queries-quality-and-percentage/",
        "solutionsUrl": "https://leetcode.cn/problems/queries-quality-and-percentage/solution",
        "problemsDesc": "<p>查询表 <code>Queries</code>：&nbsp;</p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| query_name  | varchar |\n| result      | varchar |\n| position    | int     |\n| rating      | int     |\n+-------------+---------+\n此表没有主键，并可能有重复的行。\n此表包含了一些从数据库中收集的查询信息。\n&ldquo;位置&rdquo;（<code>position</code>）列的值为 1 到 500 。\n&ldquo;评分&rdquo;（<code>rating</code>）列的值为 1 到 5 。评分小于 3 的查询被定义为质量很差的查询。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>将查询结果的质量 <code>quality</code> 定义为：</p>\n\n<blockquote>\n<p>各查询结果的评分与其位置之间比率的平均值。</p>\n</blockquote>\n\n<p>将劣质查询百分比&nbsp;<code>poor_query_percentage</code> 为：</p>\n\n<blockquote>\n<p>评分小于 3 的查询结果占全部查询结果的百分比。</p>\n</blockquote>\n\n<p>编写一组 SQL 来查找每次查询的<code>名称</code>(<code>query_name</code>)、<code>质量</code>(<code>quality</code>) 和&nbsp;<code>劣质查询百分比</code>(<code>poor_query_percentage</code>)。</p>\n\n<p><code>质量</code>(<code>quality</code>) 和<code>劣质查询百分比</code>(<code>poor_query_percentage</code>) 都应四舍五入到小数点后两位。</p>\n\n<p>查询结果格式如下所示：</p>\n\n<pre>\nQueries table:\n+------------+-------------------+----------+--------+\n| query_name | result            | position | rating |\n+------------+-------------------+----------+--------+\n| Dog        | Golden Retriever  | 1        | 5      |\n| Dog        | German Shepherd   | 2        | 5      |\n| Dog        | Mule              | 200      | 1      |\n| Cat        | Shirazi           | 5        | 2      |\n| Cat        | Siamese           | 3        | 3      |\n| Cat        | Sphynx            | 7        | 4      |\n+------------+-------------------+----------+--------+\n\nResult table:\n+------------+---------+-----------------------+\n| query_name | quality | poor_query_percentage |\n+------------+---------+-----------------------+\n| Dog        | 2.50    | 33.33                 |\n| Cat        | 0.66    | 33.33                 |\n+------------+---------+-----------------------+\n\nDog 查询结果的质量为 ((5 / 1) + (5 / 2) + (1 / 200)) / 3 = 2.50\nDog 查询结果的劣质查询百分比为 (1 / 3) * 100 = 33.33\n\nCat 查询结果的质量为 ((2 / 5) + (3 / 3) + (4 / 7)) / 3 = 0.66\nCat 查询结果的劣质查询百分比为 (1 / 3) * 100 = 33.33\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1212查询球队积分",
        "hardRate": "MEDIUM",
        "passRate": "51.44%",
        "problemsUrl": "https://leetcode.cn/problems/team-scores-in-football-tournament/",
        "solutionsUrl": "https://leetcode.cn/problems/team-scores-in-football-tournament/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1213三个有序数组的交集",
        "hardRate": "EASY",
        "passRate": "78.32%",
        "problemsUrl": "https://leetcode.cn/problems/intersection-of-three-sorted-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/intersection-of-three-sorted-arrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1214查找两棵二叉搜索树之和",
        "hardRate": "MEDIUM",
        "passRate": "65.89%",
        "problemsUrl": "https://leetcode.cn/problems/two-sum-bsts/",
        "solutionsUrl": "https://leetcode.cn/problems/two-sum-bsts/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1215步进数",
        "hardRate": "MEDIUM",
        "passRate": "43.32%",
        "problemsUrl": "https://leetcode.cn/problems/stepping-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/stepping-numbers/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1216验证回文字符串 III",
        "hardRate": "HARD",
        "passRate": "57.77%",
        "problemsUrl": "https://leetcode.cn/problems/valid-palindrome-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-palindrome-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1217玩筹码",
        "hardRate": "EASY",
        "passRate": "74.64%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-move-chips-to-the-same-position/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-move-chips-to-the-same-position/solution",
        "problemsDesc": "<p>有&nbsp;<code>n</code>&nbsp;个筹码。第 <code>i</code> 个筹码的位置是<meta charset=\"UTF-8\" />&nbsp;<code>position[i]</code>&nbsp;。</p>\n\n<p>我们需要把所有筹码移到同一个位置。在一步中，我们可以将第 <code>i</code> 个筹码的位置从&nbsp;<code>position[i]</code>&nbsp;改变为:</p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>position[i] + 2</code>&nbsp;或&nbsp;<code>position[i] - 2</code>&nbsp;，此时&nbsp;<code>cost = 0</code></li>\n\t<li><code>position[i] + 1</code>&nbsp;或&nbsp;<code>position[i] - 1</code>&nbsp;，此时&nbsp;<code>cost = 1</code></li>\n</ul>\n\n<p>返回将所有筹码移动到同一位置上所需要的 <em>最小代价</em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/15/chips_e1.jpg\" style=\"height: 217px; width: 750px;\" /></p>\n\n<pre>\n<strong>输入：</strong>position = [1,2,3]\n<strong>输出：</strong>1\n<strong>解释：</strong>第一步:将位置3的筹码移动到位置1，成本为0。\n第二步:将位置2的筹码移动到位置1，成本= 1。\n总成本是1。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/15/chip_e2.jpg\" style=\"height: 306px; width: 750px;\" /></p>\n\n<pre>\n<strong>输入：</strong>position = [2,2,2,3,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>我们可以把位置3的两个筹码移到位置2。每一步的成本为1。总成本= 2。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入：</strong>position = [1,1000000000]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= position.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= position[i] &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1218最长定差子序列",
        "hardRate": "MEDIUM",
        "passRate": "51.59%",
        "problemsUrl": "https://leetcode.cn/problems/longest-arithmetic-subsequence-of-given-difference/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-arithmetic-subsequence-of-given-difference/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> 和一个整数 <code>difference</code>，请你找出并返回 <code>arr</code> 中最长等差子序列的长度，该子序列中相邻元素之间的差等于 <code>difference</code> 。</p>\n\n<p><strong>子序列</strong> 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 <code>arr</code> 派生出来的序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,4], difference = 1\n<strong>输出：</strong>4\n<strong>解释：</strong>最长的等差子序列是 [1,2,3,4]。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,3,5,7], difference = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>最长的等差子序列是任意单个元素。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,5,7,8,5,3,4,2,1], difference = -2\n<strong>输出：</strong>4\n<strong>解释：</strong>最长的等差子序列是 [7,5,3,1]。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= arr.length <= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= arr[i], difference <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1219黄金矿工",
        "hardRate": "MEDIUM",
        "passRate": "69.11%",
        "problemsUrl": "https://leetcode.cn/problems/path-with-maximum-gold/",
        "solutionsUrl": "https://leetcode.cn/problems/path-with-maximum-gold/solution",
        "problemsDesc": "<p>你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为&nbsp;<code>m * n</code> 的网格 <code>grid</code> 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 <code>0</code>。</p>\n\n<p>为了使收益最大化，矿工需要按以下规则来开采黄金：</p>\n\n<ul>\n\t<li>每当矿工进入一个单元，就会收集该单元格中的所有黄金。</li>\n\t<li>矿工每次可以从当前位置向上下左右四个方向走。</li>\n\t<li>每个单元格只能被开采（进入）一次。</li>\n\t<li><strong>不得开采</strong>（进入）黄金数目为 <code>0</code> 的单元格。</li>\n\t<li>矿工可以从网格中 <strong>任意一个</strong> 有黄金的单元格出发或者是停止。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[0,6,0],[5,8,7],[0,9,0]]\n<strong>输出：</strong>24\n<strong>解释：</strong>\n[[0,6,0],\n [5,8,7],\n [0,9,0]]\n一种收集最多黄金的路线是：9 -&gt; 8 -&gt; 7。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]\n<strong>输出：</strong>28\n<strong>解释：</strong>\n[[1,0,7],\n [2,0,6],\n [3,4,5],\n [0,3,0],\n [9,0,20]]\n一种收集最多黄金的路线是：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= grid.length,&nbsp;grid[i].length &lt;= 15</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 100</code></li>\n\t<li>最多 <strong>25 </strong>个单元格中有黄金。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1220统计元音字母序列的数目",
        "hardRate": "HARD",
        "passRate": "60.73%",
        "problemsUrl": "https://leetcode.cn/problems/count-vowels-permutation/",
        "solutionsUrl": "https://leetcode.cn/problems/count-vowels-permutation/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>，请你帮忙统计一下我们可以按下述规则形成多少个长度为&nbsp;<code>n</code>&nbsp;的字符串：</p>\n\n<ul>\n\t<li>字符串中的每个字符都应当是小写元音字母（<code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;u&#39;</code>）</li>\n\t<li>每个元音&nbsp;<code>&#39;a&#39;</code>&nbsp;后面都只能跟着&nbsp;<code>&#39;e&#39;</code></li>\n\t<li>每个元音&nbsp;<code>&#39;e&#39;</code>&nbsp;后面只能跟着&nbsp;<code>&#39;a&#39;</code>&nbsp;或者是&nbsp;<code>&#39;i&#39;</code></li>\n\t<li>每个元音&nbsp;<code>&#39;i&#39;</code>&nbsp;后面&nbsp;<strong>不能</strong> 再跟着另一个&nbsp;<code>&#39;i&#39;</code></li>\n\t<li>每个元音&nbsp;<code>&#39;o&#39;</code>&nbsp;后面只能跟着&nbsp;<code>&#39;i&#39;</code>&nbsp;或者是&nbsp;<code>&#39;u&#39;</code></li>\n\t<li>每个元音&nbsp;<code>&#39;u&#39;</code>&nbsp;后面只能跟着&nbsp;<code>&#39;a&#39;</code></li>\n</ul>\n\n<p>由于答案可能会很大，所以请你返回 模&nbsp;<code>10^9 + 7</code>&nbsp;之后的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>5\n<strong>解释：</strong>所有可能的字符串分别是：&quot;a&quot;, &quot;e&quot;, &quot;i&quot; , &quot;o&quot; 和 &quot;u&quot;。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>10\n<strong>解释：</strong>所有可能的字符串分别是：&quot;ae&quot;, &quot;ea&quot;, &quot;ei&quot;, &quot;ia&quot;, &quot;ie&quot;, &quot;io&quot;, &quot;iu&quot;, &quot;oi&quot;, &quot;ou&quot; 和 &quot;ua&quot;。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 5\n<strong>输出：</strong>68</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1221分割平衡字符串",
        "hardRate": "EASY",
        "passRate": "85.00%",
        "problemsUrl": "https://leetcode.cn/problems/split-a-string-in-balanced-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/split-a-string-in-balanced-strings/solution",
        "problemsDesc": "<p><strong>平衡字符串</strong> 中，<code>'L'</code> 和 <code>'R'</code> 字符的数量是相同的。</p>\n\n<p>给你一个平衡字符串&nbsp;<code>s</code>，请你将它分割成尽可能多的子字符串，并满足：</p>\n\n<ul>\n\t<li>每个子字符串都是平衡字符串。</li>\n</ul>\n\n<p>返回可以通过分割得到的平衡字符串的 <strong>最大数量</strong> <strong>。</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"RLRRLLRLRL\"\n<strong>输出：</strong>4\n<strong>解释：</strong>s 可以分割为 \"RL\"、\"RRLL\"、\"RL\"、\"RL\" ，每个子字符串中都包含相同数量的 'L' 和 'R' 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"RLRRRLLRLL\"\n<strong>输出：</strong>2\n<strong>解释：</strong>s 可以分割为 \"RL\"、\"RRRLLRLL\"，每个子字符串中都包含相同数量的 'L' 和 'R' 。\n注意，s 无法分割为 \"RL\"、\"RR\"、\"RL\"、\"LR\"、\"LL\" 因为第 2 个和第 5 个子字符串不是平衡字符串。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"LLLLRRRR\"\n<strong>输出：</strong>1\n<strong>解释：</strong>s 只能保持原样 \"LLLLRRRR\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i] = 'L' 或 'R'</code></li>\n\t<li><code>s</code> 是一个 <strong>平衡</strong> 字符串</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1222可以攻击国王的皇后",
        "hardRate": "MEDIUM",
        "passRate": "69.46%",
        "problemsUrl": "https://leetcode.cn/problems/queens-that-can-attack-the-king/",
        "solutionsUrl": "https://leetcode.cn/problems/queens-that-can-attack-the-king/solution",
        "problemsDesc": "<p>在一个&nbsp;<strong>8x8</strong>&nbsp;的棋盘上，放置着若干「黑皇后」和一个「白国王」。</p>\n\n<p>给定一个由整数坐标组成的数组&nbsp;<code>queens</code>&nbsp;，表示黑皇后的位置；以及一对坐标&nbsp;<code>king</code> ，表示白国王的位置，返回所有可以攻击国王的皇后的坐标(任意顺序)。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/13/untitled-diagram.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]], king = [0,0]\n<strong>输出：</strong>[[0,1],[1,0],[3,3]]\n<strong>解释：</strong> \n[0,1] 的皇后可以攻击到国王，因为他们在同一行上。 \n[1,0] 的皇后可以攻击到国王，因为他们在同一列上。 \n[3,3] 的皇后可以攻击到国王，因为他们在同一条对角线上。 \n[0,4] 的皇后无法攻击到国王，因为她被位于 [0,1] 的皇后挡住了。 \n[4,0] 的皇后无法攻击到国王，因为她被位于 [1,0] 的皇后挡住了。 \n[2,4] 的皇后无法攻击到国王，因为她和国王不在同一行/列/对角线上。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/13/untitled-diagram-1.jpg\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>queens = [[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]], king = [3,3]\n<strong>输出：</strong>[[2,2],[3,4],[4,4]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/13/untitled-diagram-2.jpg\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>queens = [[5,6],[7,7],[2,1],[0,7],[1,6],[5,1],[3,7],[0,3],[4,0],[1,2],[6,3],[5,0],[0,4],[2,2],[1,1],[6,4],[5,4],[0,0],[2,6],[4,5],[5,2],[1,4],[7,5],[2,3],[0,5],[4,2],[1,0],[2,7],[0,1],[4,6],[6,1],[0,6],[4,3],[1,7]], king = [3,4]\n<strong>输出：</strong>[[2,3],[1,4],[1,6],[3,7],[4,3],[5,4],[4,5]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= queens.length&nbsp;&lt;= 63</code></li>\n\t<li><code>queens[i].length == 2</code></li>\n\t<li><code>0 &lt;= queens[i][j] &lt;&nbsp;8</code></li>\n\t<li><code>king.length == 2</code></li>\n\t<li><code>0 &lt;= king[0], king[1] &lt; 8</code></li>\n\t<li>一个棋盘格上最多只能放置一枚棋子。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1223掷骰子模拟",
        "hardRate": "HARD",
        "passRate": "61.89%",
        "problemsUrl": "https://leetcode.cn/problems/dice-roll-simulation/",
        "solutionsUrl": "https://leetcode.cn/problems/dice-roll-simulation/solution",
        "problemsDesc": "<p>有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。</p>\n\n<p>不过我们在使用它时有个约束，就是使得投掷骰子时，<strong>连续</strong> 掷出数字&nbsp;<code>i</code>&nbsp;的次数不能超过&nbsp;<code>rollMax[i]</code>（<code>i</code>&nbsp;从 1 开始编号）。</p>\n\n<p>现在，给你一个整数数组&nbsp;<code>rollMax</code>&nbsp;和一个整数&nbsp;<code>n</code>，请你来计算掷&nbsp;<code>n</code>&nbsp;次骰子可得到的不同点数序列的数量。</p>\n\n<p>假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 <strong>模&nbsp;<code>10^9 + 7</code></strong>&nbsp;之后的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, rollMax = [1,1,2,2,2,3]\n<strong>输出：</strong>34\n<strong>解释：</strong>我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 = 36 种可能的组合。但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, rollMax = [1,1,1,1,1,1]\n<strong>输出：</strong>30\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 3, rollMax = [1,1,1,2,2,3]\n<strong>输出：</strong>181\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>rollMax.length == 6</code></li>\n\t<li><code>1 &lt;= rollMax[i] &lt;= 15</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1224最大相等频率",
        "hardRate": "HARD",
        "passRate": "43.63%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-equal-frequency/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-equal-frequency/solution",
        "problemsDesc": "<p>给你一个正整数数组&nbsp;<code>nums</code>，请你帮忙从该数组中找出能满足下面要求的 <strong>最长</strong> 前缀，并返回该前缀的长度：</p>\n\n<ul>\n\t<li>从前缀中 <strong>恰好删除一个</strong> 元素后，剩下每个数字的出现次数都相同。</li>\n</ul>\n\n<p>如果删除这个元素后没有剩余元素存在，仍可认为每个数字都具有相同的出现次数（也就是 0 次）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,1,1,5,3,3,5]\n<strong>输出：</strong>7\n<strong>解释：</strong>对于长度为 7 的子数组 [2,2,1,1,5,3,3]，如果我们从中删去 nums[4] = 5，就可以得到 [2,2,1,1,3,3]，里面每个数字都出现了两次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,2,2,2,3,3,3,4,4,4,5]\n<strong>输出：</strong>13\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1225报告系统状态的连续日期",
        "hardRate": "HARD",
        "passRate": "53.58%",
        "problemsUrl": "https://leetcode.cn/problems/report-contiguous-dates/",
        "solutionsUrl": "https://leetcode.cn/problems/report-contiguous-dates/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1226哲学家进餐",
        "hardRate": "MEDIUM",
        "passRate": "59.39%",
        "problemsUrl": "https://leetcode.cn/problems/the-dining-philosophers/",
        "solutionsUrl": "https://leetcode.cn/problems/the-dining-philosophers/solution",
        "problemsDesc": "<p>5 个沉默寡言的哲学家围坐在圆桌前，每人面前一盘意面。叉子放在哲学家之间的桌面上。（5 个哲学家，5 根叉子）</p>\n\n<p>所有的哲学家都只会在思考和进餐两种行为间交替。哲学家只有同时拿到左边和右边的叉子才能吃到面，而同一根叉子在同一时间只能被一个哲学家使用。每个哲学家吃完面后都需要把叉子放回桌面以供其他哲学家吃面。只要条件允许，哲学家可以拿起左边或者右边的叉子，但在没有同时拿到左右叉子时不能进食。</p>\n\n<p>假设面的数量没有限制，哲学家也能随便吃，不需要考虑吃不吃得下。</p>\n\n<p>设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/23/an_illustration_of_the_dining_philosophers_problem.png\" style=\"height: 415px; width: 400px;\"></p>\n\n<p><em>问题描述和图片来自维基百科&nbsp;<a href=\"https://en.wikipedia.org/wiki/Dining_philosophers_problem\" target=\"_blank\">wikipedia.org</a></em></p>\n\n<p>&nbsp;</p>\n\n<p>哲学家从&nbsp;<strong>0</strong> 到 <strong>4</strong> 按 <strong>顺时针</strong> 编号。请实现函数&nbsp;<code>void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork)</code>：</p>\n\n<ul>\n\t<li><code>philosopher</code>&nbsp;哲学家的编号。</li>\n\t<li><code>pickLeftFork</code>&nbsp;和&nbsp;<code>pickRightFork</code>&nbsp;表示拿起左边或右边的叉子。</li>\n\t<li><code>eat</code>&nbsp;表示吃面。</li>\n\t<li><code>putLeftFork</code>&nbsp;和&nbsp;<code>putRightFork</code>&nbsp;表示放下左边或右边的叉子。</li>\n\t<li>由于哲学家不是在吃面就是在想着啥时候吃面，所以思考这个方法没有对应的回调。</li>\n</ul>\n\n<p>给你 5 个线程，每个都代表一个哲学家，请你使用类的同一个对象来模拟这个过程。在最后一次调用结束之前，可能会为同一个哲学家多次调用该函数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>[[4,2,1],[4,1,1],[0,1,1],[2,2,1],[2,1,1],[2,0,3],[2,1,2],[2,2,2],[4,0,3],[4,1,2],[0,2,1],[4,2,2],[3,2,1],[3,1,1],[0,0,3],[0,1,2],[0,2,2],[1,2,1],[1,1,1],[3,0,3],[3,1,2],[3,2,2],[1,0,3],[1,1,2],[1,2,2]]\n<strong>解释:</strong>\nn 表示每个哲学家需要进餐的次数。\n输出数组描述了叉子的控制和进餐的调用，它的格式如下：\noutput[i] = [a, b, c] (3个整数)\n- a 哲学家编号。\n- b 指定叉子：{1 : 左边, 2 : 右边}.\n- c 指定行为：{1 : 拿起, 2 : 放下, 3 : 吃面}。\n如 [4,2,1] 表示 4 号哲学家拿起了右边的叉子。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 60</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1227飞机座位分配概率",
        "hardRate": "MEDIUM",
        "passRate": "66.97%",
        "problemsUrl": "https://leetcode.cn/problems/airplane-seat-assignment-probability/",
        "solutionsUrl": "https://leetcode.cn/problems/airplane-seat-assignment-probability/solution",
        "problemsDesc": "<p>有 <code>n</code> 位乘客即将登机，飞机正好有 <code>n</code> 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。</p>\n\n<p>剩下的乘客将会：</p>\n\n<ul>\n\t<li>\n\t<p>如果他们自己的座位还空着，就坐到自己的座位上，</p>\n\t</li>\n\t<li>当他们自己的座位被占用时，随机选择其他座位</li>\n</ul>\n\n<p>第 <code>n</code>&nbsp;位乘客坐在自己的座位上的概率是多少？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>1.00000\n<strong>解释：</strong>第一个人只会坐在自己的位置上。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 2\n<strong>输出:</strong> 0.50000\n<strong>解释：</strong>在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1228等差数列中缺失的数字",
        "hardRate": "EASY",
        "passRate": "53.94%",
        "problemsUrl": "https://leetcode.cn/problems/missing-number-in-arithmetic-progression/",
        "solutionsUrl": "https://leetcode.cn/problems/missing-number-in-arithmetic-progression/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1229安排会议日程",
        "hardRate": "MEDIUM",
        "passRate": "46.54%",
        "problemsUrl": "https://leetcode.cn/problems/meeting-scheduler/",
        "solutionsUrl": "https://leetcode.cn/problems/meeting-scheduler/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1230抛掷硬币",
        "hardRate": "MEDIUM",
        "passRate": "54.27%",
        "problemsUrl": "https://leetcode.cn/problems/toss-strange-coins/",
        "solutionsUrl": "https://leetcode.cn/problems/toss-strange-coins/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1231分享巧克力",
        "hardRate": "HARD",
        "passRate": "58.92%",
        "problemsUrl": "https://leetcode.cn/problems/divide-chocolate/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-chocolate/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1232缀点成线",
        "hardRate": "EASY",
        "passRate": "45.47%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-it-is-a-straight-line/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-it-is-a-straight-line/solution",
        "problemsDesc": "<p>给定一个数组&nbsp;<code>coordinates</code>&nbsp;，其中&nbsp;<code>coordinates[i] = [x, y]</code>&nbsp;，<meta charset=\"UTF-8\" />&nbsp;<code>[x, y]</code>&nbsp;表示横坐标为 <code>x</code>、纵坐标为 <code>y</code>&nbsp;的点。请你来判断，这些点是否在该坐标系中属于同一条直线上。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/untitled-diagram-2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/untitled-diagram-1.jpg\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;=&nbsp;coordinates.length &lt;= 1000</code></li>\n\t<li><code>coordinates[i].length == 2</code></li>\n\t<li><code>-10^4 &lt;=&nbsp;coordinates[i][0],&nbsp;coordinates[i][1] &lt;= 10^4</code></li>\n\t<li><code>coordinates</code>&nbsp;中不含重复的点</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1233删除子文件夹",
        "hardRate": "MEDIUM",
        "passRate": "61.53%",
        "problemsUrl": "https://leetcode.cn/problems/remove-sub-folders-from-the-filesystem/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-sub-folders-from-the-filesystem/solution",
        "problemsDesc": "<p>你是一位系统管理员，手里有一份文件夹列表 <code>folder</code>，你的任务是要删除该列表中的所有 <strong>子文件夹</strong>，并以 <strong>任意顺序</strong> 返回剩下的文件夹。</p>\n\n<p>如果文件夹&nbsp;<code>folder[i]</code>&nbsp;位于另一个文件夹&nbsp;<code>folder[j]</code>&nbsp;下，那么&nbsp;<code>folder[i]</code>&nbsp;就是&nbsp;<code>folder[j]</code>&nbsp;的 <strong>子文件夹</strong> 。</p>\n\n<p>文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：<font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">'/'</span></span></font></font>&nbsp;后跟一个或者多个小写英文字母。</p>\n\n<ul>\n\t<li>例如，<code>\"/leetcode\"</code>&nbsp;和&nbsp;<code>\"/leetcode/problems\"</code>&nbsp;都是有效的路径，而空字符串和&nbsp;<code>\"/\"</code>&nbsp;不是。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>folder = [\"/a\",\"/a/b\",\"/c/d\",\"/c/d/e\",\"/c/f\"]\n<strong>输出：</strong>[\"/a\",\"/c/d\",\"/c/f\"]\n<strong>解释：</strong>\"/a/b\" 是 \"/a\" 的子文件夹，而 \"/c/d/e\" 是 \"/c/d\" 的子文件夹。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>folder = [\"/a\",\"/a/b/c\",\"/a/b/d\"]\n<strong>输出：</strong>[\"/a\"]\n<strong>解释：</strong>文件夹 \"/a/b/c\" 和 \"/a/b/d\" 都会被删除，因为它们都是 \"/a\" 的子文件夹。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入:</strong> folder = [\"/a/b/c\",\"/a/b/ca\",\"/a/b/d\"]\n<strong>输出:</strong> [\"/a/b/c\",\"/a/b/ca\",\"/a/b/d\"]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= folder.length &lt;= 4 * 10<sup>4</sup></code></li>\n\t<li><code>2 &lt;= folder[i].length &lt;= 100</code></li>\n\t<li><code>folder[i]</code>&nbsp;只包含小写字母和 <code>'/'</code></li>\n\t<li><code>folder[i]</code>&nbsp;总是以字符 <code>'/'</code>&nbsp;起始</li>\n\t<li><code>folder</code>&nbsp;每个元素都是 <strong>唯一</strong> 的</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1234替换子串得到平衡字符串",
        "hardRate": "MEDIUM",
        "passRate": "44.90%",
        "problemsUrl": "https://leetcode.cn/problems/replace-the-substring-for-balanced-string/",
        "solutionsUrl": "https://leetcode.cn/problems/replace-the-substring-for-balanced-string/solution",
        "problemsDesc": "<p>有一个只含有&nbsp;<code>'Q', 'W', 'E',&nbsp;'R'</code>&nbsp;四种字符，且长度为 <code>n</code>&nbsp;的字符串。</p>\n\n<p>假如在该字符串中，这四个字符都恰好出现&nbsp;<code>n/4</code>&nbsp;次，那么它就是一个「平衡字符串」。</p>\n\n<p>&nbsp;</p>\n\n<p>给你一个这样的字符串 <code>s</code>，请通过「替换一个子串」的方式，使原字符串 <code>s</code> 变成一个「平衡字符串」。</p>\n\n<p>你可以用和「待替换子串」长度相同的&nbsp;<strong>任何</strong> 其他字符串来完成替换。</p>\n\n<p>请返回待替换子串的最小可能长度。</p>\n\n<p>如果原字符串自身就是一个平衡字符串，则返回 <code>0</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"QWER\"\n<strong>输出：</strong>0\n<strong>解释：</strong>s 已经是平衡的了。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"QQWE\"\n<strong>输出：</strong>1\n<strong>解释：</strong>我们需要把一个 'Q' 替换成 'R'，这样得到的 \"RQWE\" (或 \"QRWE\") 是平衡的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"QQQW\"\n<strong>输出：</strong>2\n<strong>解释：</strong>我们可以把前面的 \"QQ\" 替换成 \"ER\"。 \n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"QQQQ\"\n<strong>输出：</strong>3\n<strong>解释：</strong>我们可以替换后 3 个 'Q'，使 s = \"QWER\"。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>s.length</code>&nbsp;是&nbsp;<code>4</code>&nbsp;的倍数</li>\n\t<li><code>s</code>&nbsp;中只含有&nbsp;<code>'Q'</code>, <code>'W'</code>, <code>'E'</code>,&nbsp;<code>'R'</code>&nbsp;四种字符</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1235规划兼职工作",
        "hardRate": "HARD",
        "passRate": "57.76%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-profit-in-job-scheduling/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-profit-in-job-scheduling/solution",
        "problemsDesc": "<p>你打算利用空闲时间来做兼职工作赚些零花钱。</p>\n\n<p>这里有&nbsp;<code>n</code>&nbsp;份兼职工作，每份工作预计从&nbsp;<code>startTime[i]</code>&nbsp;开始到&nbsp;<code>endTime[i]</code>&nbsp;结束，报酬为&nbsp;<code>profit[i]</code>。</p>\n\n<p>给你一份兼职工作表，包含开始时间&nbsp;<code>startTime</code>，结束时间&nbsp;<code>endTime</code>&nbsp;和预计报酬&nbsp;<code>profit</code>&nbsp;三个数组，请你计算并返回可以获得的最大报酬。</p>\n\n<p>注意，时间上出现重叠的 2 份工作不能同时进行。</p>\n\n<p>如果你选择的工作在时间&nbsp;<code>X</code>&nbsp;结束，那么你可以立刻进行在时间&nbsp;<code>X</code>&nbsp;开始的下一份工作。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/sample1_1584.png\" style=\"width: 300px;\"></strong></p>\n\n<pre><strong>输入：</strong>startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]\n<strong>输出：</strong>120\n<strong>解释：\n</strong>我们选出第 1 份和第 4 份工作， \n时间范围是 [1-3]+[3-6]，共获得报酬 120 = 50 + 70。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/sample22_1584.png\" style=\"height: 112px; width: 600px;\"> </strong></p>\n\n<pre><strong>输入：</strong>startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]\n<strong>输出：</strong>150\n<strong>解释：\n</strong>我们选择第 1，4，5 份工作。 \n共获得报酬 150 = 20 + 70 + 60。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/sample3_1584.png\" style=\"height: 112px; width: 400px;\"></strong></p>\n\n<pre><strong>输入：</strong>startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]\n<strong>输出：</strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= startTime.length == endTime.length ==&nbsp;profit.length&nbsp;&lt;= 5 * 10^4</code></li>\n\t<li><code>1 &lt;=&nbsp;startTime[i] &lt;&nbsp;endTime[i] &lt;= 10^9</code></li>\n\t<li><code>1 &lt;=&nbsp;profit[i] &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1236网络爬虫",
        "hardRate": "MEDIUM",
        "passRate": "57.33%",
        "problemsUrl": "https://leetcode.cn/problems/web-crawler/",
        "solutionsUrl": "https://leetcode.cn/problems/web-crawler/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1237找出给定方程的正整数解",
        "hardRate": "MEDIUM",
        "passRate": "78.17%",
        "problemsUrl": "https://leetcode.cn/problems/find-positive-integer-solution-for-a-given-equation/",
        "solutionsUrl": "https://leetcode.cn/problems/find-positive-integer-solution-for-a-given-equation/solution",
        "problemsDesc": "<p>给你一个函数  <code>f(x, y)</code> 和一个目标结果 <code>z</code>，函数公式未知，请你计算方程 <code>f(x,y) == z</code> 所有可能的正整数 <strong>数对</strong> <code>x</code> 和 <code>y</code>。满足条件的结果数对可以按任意顺序返回。</p>\n\n<p>尽管函数的具体式子未知，但它是单调递增函数，也就是说：</p>\n\n<ul>\n\t<li><code>f(x, y) < f(x + 1, y)</code></li>\n\t<li><code>f(x, y) < f(x, y + 1)</code></li>\n</ul>\n\n<p>函数接口定义如下：</p>\n\n<pre>\ninterface CustomFunction {\npublic:\n  // Returns some positive integer f(x, y) for two positive integers x and y based on a formula.\n  int f(int x, int y);\n};</pre>\n\n<p>你的解决方案将按如下规则进行评判：</p>\n\n<ul>\n\t<li>判题程序有一个由 <code>CustomFunction</code> 的 <code>9</code> 种实现组成的列表，以及一种为特定的 <code>z</code> 生成所有有效数对的答案的方法。</li>\n\t<li>判题程序接受两个输入：<code>function_id</code>（决定使用哪种实现测试你的代码）以及目标结果 <code>z</code> 。</li>\n\t<li>判题程序将会调用你实现的 <code>findSolution</code> 并将你的结果与答案进行比较。</li>\n\t<li>如果你的结果与答案相符，那么解决方案将被视作正确答案，即 <code>Accepted</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>function_id = 1, z = 5\n<strong>输出：</strong>[[1,4],[2,3],[3,2],[4,1]]\n<strong>解释：</strong>function_id = 1 暗含的函数式子为 f(x, y) = x + y\n以下 x 和 y 满足 f(x, y) 等于 5：\nx=1, y=4 -> f(1, 4) = 1 + 4 = 5\nx=2, y=3 -> f(2, 3) = 2 + 3 = 5\nx=3, y=2 -> f(3, 2) = 3 + 2 = 5\nx=4, y=1 -> f(4, 1) = 4 + 1 = 5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>function_id = 2, z = 5\n<strong>输出：</strong>[[1,5],[5,1]]\n<strong>解释：</strong>function_id = 2 暗含的函数式子为 f(x, y) = x * y\n以下 x 和 y 满足 f(x, y) 等于 5：\nx=1, y=5 -> f(1, 5) = 1 * 5 = 5\nx=5, y=1 -> f(5, 1) = 5 * 1 = 5</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= function_id <= 9</code></li>\n\t<li><code>1 <= z <= 100</code></li>\n\t<li>题目保证 <code>f(x, y) == z</code> 的解处于 <code>1 <= x, y <= 1000</code> 的范围内。</li>\n\t<li>在 <code>1 <= x, y <= 1000</code> 的前提下，题目保证 <code>f(x, y)</code> 是一个 32 位有符号整数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1238循环码排列",
        "hardRate": "MEDIUM",
        "passRate": "77.54%",
        "problemsUrl": "https://leetcode.cn/problems/circular-permutation-in-binary-representation/",
        "solutionsUrl": "https://leetcode.cn/problems/circular-permutation-in-binary-representation/solution",
        "problemsDesc": "<p>给你两个整数&nbsp;<code>n</code> 和 <code>start</code>。你的任务是返回任意 <code>(0,1,2,,...,2^n-1)</code> 的排列 <code>p</code>，并且满足：</p>\n\n<ul>\n\t<li><code>p[0] = start</code></li>\n\t<li><code>p[i]</code> 和 <code>p[i+1]</code>&nbsp;的二进制表示形式只有一位不同</li>\n\t<li><code>p[0]</code> 和 <code>p[2^n -1]</code>&nbsp;的二进制表示形式也只有一位不同</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, start = 3\n<strong>输出：</strong>[3,2,0,1]\n<strong>解释：</strong>这个排列的二进制表示是 (11,10,00,01)\n     所有的相邻元素都有一位是不同的，另一个有效的排列是 [3,1,0,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, start = 2\n<strong>输出：</strong>[2,6,7,5,4,0,1,3]\n<strong>解释：</strong>这个排列的二进制表示是 (010,110,111,101,100,000,001,011)\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 16</code></li>\n\t<li><code>0 &lt;= start&nbsp;&lt;&nbsp;2^n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1239串联字符串的最大长度",
        "hardRate": "MEDIUM",
        "passRate": "49.09%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-length-of-a-concatenated-string-with-unique-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-length-of-a-concatenated-string-with-unique-characters/solution",
        "problemsDesc": "<p>给定一个字符串数组 <code>arr</code>，字符串 <code>s</code> 是将 <code>arr</code>&nbsp;的含有 <strong>不同字母</strong> 的&nbsp;<strong>子序列</strong> 字符串 <strong>连接</strong> 所得的字符串。</p>\n\n<p>请返回所有可行解 <code>s</code> 中最长长度。</p>\n\n<p><strong>子序列</strong> 是一种可以从另一个数组派生而来的数组，通过删除某些元素或不删除元素而不改变其余元素的顺序。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [\"un\",\"iq\",\"ue\"]\n<strong>输出：</strong>4\n<strong>解释：</strong>所有可能的串联组合是：\n- \"\"\n- \"un\"\n- \"iq\"\n- \"ue\"\n- \"uniq\" (\"un\" + \"iq\")\n- \"ique\" (\"iq\" + \"ue\")\n最大长度为 4。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [\"cha\",\"r\",\"act\",\"ers\"]\n<strong>输出：</strong>6\n<strong>解释：</strong>可能的解答有 \"chaers\" 和 \"acters\"。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [\"abcdefghijklmnopqrstuvwxyz\"]\n<strong>输出：</strong>26\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 16</code></li>\n\t<li><code>1 &lt;= arr[i].length &lt;= 26</code></li>\n\t<li><code>arr[i]</code>&nbsp;中只含有小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1240铺瓷砖",
        "hardRate": "HARD",
        "passRate": "65.77%",
        "problemsUrl": "https://leetcode.cn/problems/tiling-a-rectangle-with-the-fewest-squares/",
        "solutionsUrl": "https://leetcode.cn/problems/tiling-a-rectangle-with-the-fewest-squares/solution",
        "problemsDesc": "<p>你是一位施工队的工长，根据设计师的要求准备为一套设计风格独特的房子进行室内装修。</p>\n\n<p>房子的客厅大小为&nbsp;<code>n</code>&nbsp;x <code>m</code>，为保持极简的风格，需要使用尽可能少的 <strong>正方形</strong> 瓷砖来铺盖地面。</p>\n\n<p>假设正方形瓷砖的规格不限，边长都是整数。</p>\n\n<p>请你帮设计师计算一下，最少需要用到多少块方形瓷砖？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/25/sample_11_1592.png\" style=\"height: 106px; width: 154px;\"></p>\n\n<pre><strong>输入：</strong>n = 2, m = 3\n<strong>输出：</strong>3\n<code><strong>解释：</strong>3</code> 块地砖就可以铺满卧室。\n<code>     2</code> 块 <code>1x1 地砖</code>\n<code>     1</code> 块 <code>2x2 地砖</code></pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/25/sample_22_1592.png\" style=\"height: 126px; width: 224px;\"></p>\n\n<pre><strong>输入：</strong>n = 5, m = 8\n<strong>输出：</strong>5\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/25/sample_33_1592.png\" style=\"height: 189px; width: 224px;\"></p>\n\n<pre><strong>输入：</strong>n = 11, m = 13\n<strong>输出：</strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 13</code></li>\n\t<li><code>1 &lt;= m&nbsp;&lt;=&nbsp;13</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1241每个帖子的评论数",
        "hardRate": "EASY",
        "passRate": "59.71%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-comments-per-post/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-comments-per-post/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1242多线程网页爬虫",
        "hardRate": "MEDIUM",
        "passRate": "48.24%",
        "problemsUrl": "https://leetcode.cn/problems/web-crawler-multithreaded/",
        "solutionsUrl": "https://leetcode.cn/problems/web-crawler-multithreaded/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1243数组变换",
        "hardRate": "EASY",
        "passRate": "53.82%",
        "problemsUrl": "https://leetcode.cn/problems/array-transformation/",
        "solutionsUrl": "https://leetcode.cn/problems/array-transformation/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1244力扣排行榜",
        "hardRate": "MEDIUM",
        "passRate": "63.40%",
        "problemsUrl": "https://leetcode.cn/problems/design-a-leaderboard/",
        "solutionsUrl": "https://leetcode.cn/problems/design-a-leaderboard/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1245树的直径",
        "hardRate": "MEDIUM",
        "passRate": "54.44%",
        "problemsUrl": "https://leetcode.cn/problems/tree-diameter/",
        "solutionsUrl": "https://leetcode.cn/problems/tree-diameter/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1246删除回文子数组",
        "hardRate": "HARD",
        "passRate": "50.28%",
        "problemsUrl": "https://leetcode.cn/problems/palindrome-removal/",
        "solutionsUrl": "https://leetcode.cn/problems/palindrome-removal/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1247交换字符使得字符串相同",
        "hardRate": "MEDIUM",
        "passRate": "69.11%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-swaps-to-make-strings-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-swaps-to-make-strings-equal/solution",
        "problemsDesc": "<p>有两个长度相同的字符串&nbsp;<code>s1</code> 和&nbsp;<code>s2</code>，且它们其中&nbsp;<strong>只含有</strong>&nbsp;字符&nbsp;<code>\"x\"</code> 和&nbsp;<code>\"y\"</code>，你需要通过「交换字符」的方式使这两个字符串相同。</p>\n\n<p>每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。</p>\n\n<p>交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换&nbsp;<code>s1[i]</code> 和&nbsp;<code>s2[j]</code>，但不能交换&nbsp;<code>s1[i]</code> 和&nbsp;<code>s1[j]</code>。</p>\n\n<p>最后，请你返回使 <code>s1</code> 和 <code>s2</code> 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回&nbsp;<code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"xx\", s2 = \"yy\"\n<strong>输出：</strong>1\n<strong>解释：\n</strong>交换 s1[0] 和 s2[1]，得到 s1 = \"yx\"，s2 = \"yx\"。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"xy\", s2 = \"yx\"\n<strong>输出：</strong>2\n<strong>解释：\n</strong>交换 s1[0] 和 s2[0]，得到 s1 = \"yy\"，s2 = \"xx\" 。\n交换 s1[0] 和 s2[1]，得到 s1 = \"xy\"，s2 = \"xy\" 。\n注意，你不能交换 s1[0] 和 s1[1] 使得 s1 变成 \"yx\"，因为我们只能交换属于两个不同字符串的字符。</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"xx\", s2 = \"xy\"\n<strong>输出：</strong>-1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 1000</code></li>\n\t<li><code>s1.length == s2.length</code></li>\n\t<li><code>s1, s2</code>&nbsp;只包含&nbsp;<code>'x'</code>&nbsp;或&nbsp;<code>'y'</code>。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1248统计「优美子数组」",
        "hardRate": "MEDIUM",
        "passRate": "57.94%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-nice-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-nice-subarrays/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code> 和一个整数 <code>k</code>。如果某个连续子数组中恰好有 <code>k</code> 个奇数数字，我们就认为这个子数组是「<strong>优美子数组</strong>」。</p>\n\n<p>请返回这个数组中 <strong>「优美子数组」</strong> 的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,2,1,1], k = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,4,6], k = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>数列中不包含任何奇数，所以不存在优美子数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,2,1,2,2,1,2,2,2], k = 2\n<strong>输出：</strong>16\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 50000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1249移除无效的括号",
        "hardRate": "MEDIUM",
        "passRate": "59.36%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses/solution",
        "problemsDesc": "<p>给你一个由 <code>'('</code>、<code>')'</code> 和小写字母组成的字符串 <code>s</code>。</p>\n\n<p>你需要从字符串中删除最少数目的 <code>'('</code> 或者 <code>')'</code>&nbsp;（可以删除任意位置的括号)，使得剩下的「括号字符串」有效。</p>\n\n<p>请返回任意一个合法字符串。</p>\n\n<p>有效「括号字符串」应当符合以下&nbsp;<strong>任意一条&nbsp;</strong>要求：</p>\n\n<ul>\n\t<li>空字符串或只包含小写字母的字符串</li>\n\t<li>可以被写作&nbsp;<code>AB</code>（<code>A</code>&nbsp;连接&nbsp;<code>B</code>）的字符串，其中&nbsp;<code>A</code>&nbsp;和&nbsp;<code>B</code>&nbsp;都是有效「括号字符串」</li>\n\t<li>可以被写作&nbsp;<code>(A)</code>&nbsp;的字符串，其中&nbsp;<code>A</code>&nbsp;是一个有效的「括号字符串」</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"lee(t(c)o)de)\"\n<strong>输出：</strong>\"lee(t(c)o)de\"\n<strong>解释：</strong>\"lee(t(co)de)\" , \"lee(t(c)ode)\" 也是一个可行答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a)b(c)d\"\n<strong>输出：</strong>\"ab(c)d\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"))((\"\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>空字符串也是有效的\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code>&nbsp;可能是&nbsp;<code>'('</code>、<code>')'</code>&nbsp;或英文小写字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1250检查「好数组」",
        "hardRate": "HARD",
        "passRate": "70.99%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-it-is-a-good-array/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-it-is-a-good-array/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>nums</code>，你需要从中任选一些子集，然后将子集中每一个数乘以一个 <strong>任意整数</strong>，并求出他们的和。</p>\n\n<p>假如该和结果为&nbsp;<code>1</code>，那么原数组就是一个「<strong>好数组</strong>」，则返回 <code>True</code>；否则请返回 <code>False</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [12,5,7,23]\n<strong>输出：</strong>true\n<strong>解释：</strong>挑选数字 5 和 7。\n5*3 + 7*(-2) = 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [29,6,10]\n<strong>输出：</strong>true\n<strong>解释：</strong>挑选数字 29, 6 和 10。\n29*1 + 6*(-3) + 10*(-1) = 1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,6]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1251平均售价",
        "hardRate": "EASY",
        "passRate": "75.30%",
        "problemsUrl": "https://leetcode.cn/problems/average-selling-price/",
        "solutionsUrl": "https://leetcode.cn/problems/average-selling-price/solution",
        "problemsDesc": "<p>Table: <code>Prices</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| product_id    | int     |\n| start_date    | date    |\n| end_date      | date    |\n| price         | int     |\n+---------------+---------+\n(product_id，start_date，end_date) 是 <code>Prices </code>表的主键。\n<code>Prices </code>表的每一行表示的是某个产品在一段时期内的价格。\n每个产品的对应时间段是不会重叠的，这也意味着同一个产品的价格时段不会出现交叉。</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>UnitsSold</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| product_id    | int     |\n| purchase_date | date    |\n| units         | int     |\n+---------------+---------+\n<code>UnitsSold </code>表没有主键，它可能包含重复项。\n<code>UnitsSold </code>表的每一行表示的是每种产品的出售日期，单位和产品 id。</pre>\n\n<p>&nbsp;</p>\n\n<p>编写SQL查询以查找每种产品的平均售价。<br />\n<code>average_price</code> 应该四舍五入到小数点后两位。<br />\n查询结果格式如下例所示：</p>\n\n<pre>\nPrices table:\n+------------+------------+------------+--------+\n| product_id | start_date | end_date   | price  |\n+------------+------------+------------+--------+\n| 1          | 2019-02-17 | 2019-02-28 | 5      |\n| 1          | 2019-03-01 | 2019-03-22 | 20     |\n| 2          | 2019-02-01 | 2019-02-20 | 15     |\n| 2          | 2019-02-21 | 2019-03-31 | 30     |\n+------------+------------+------------+--------+\n \nUnitsSold table:\n+------------+---------------+-------+\n| product_id | purchase_date | units |\n+------------+---------------+-------+\n| 1          | 2019-02-25    | 100   |\n| 1          | 2019-03-01    | 15    |\n| 2          | 2019-02-10    | 200   |\n| 2          | 2019-03-22    | 30    |\n+------------+---------------+-------+\n\nResult table:\n+------------+---------------+\n| product_id | average_price |\n+------------+---------------+\n| 1          | 6.96          |\n| 2          | 16.96         |\n+------------+---------------+\n平均售价 = 产品总价 / 销售的产品数量。\n产品 1 的平均售价 = ((100 * 5)+(15 * 20) )/ 115 = 6.96\n产品 2 的平均售价 = ((200 * 15)+(30 * 30) )/ 230 = 16.96</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1252奇数值单元格的数目",
        "hardRate": "EASY",
        "passRate": "79.59%",
        "problemsUrl": "https://leetcode.cn/problems/cells-with-odd-values-in-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/cells-with-odd-values-in-a-matrix/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的矩阵，最开始的时候，每个单元格中的值都是 <code>0</code>。</p>\n\n<p>另有一个二维索引数组 <code>indices</code>，<code>indices[i] = [ri, ci]</code> 指向矩阵中的某个位置，其中 <code>ri</code> 和 <code>ci</code> 分别表示指定的行和列（<strong>从 <code>0</code> 开始编号</strong>）。</p>\n\n<p>对 <code>indices[i]</code> 所指向的每个位置，应同时执行下述增量操作：</p>\n\n<ol>\n\t<li><code>r<sub>i</sub></code> 行上的所有单元格，加 <code>1</code> 。</li>\n\t<li><code>c<sub>i</sub></code> 列上的所有单元格，加 <code>1</code> 。</li>\n</ol>\n\n<p>给你 <code>m</code>、<code>n</code> 和 <code>indices</code> 。请你在执行完所有 <code>indices</code> 指定的增量操作后，返回矩阵中 <strong>奇数值单元格</strong> 的数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/06/e1.png\" style=\"height: 118px; width: 600px;\" /></p>\n\n<pre>\n<strong>输入：</strong>m = 2, n = 3, indices = [[0,1],[1,1]]\n<strong>输出：</strong>6\n<strong>解释：</strong>最开始的矩阵是 [[0,0,0],[0,0,0]]。\n第一次增量操作后得到 [[1,2,1],[0,1,0]]。\n最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/06/e2.png\" style=\"height: 150px; width: 600px;\" /></p>\n\n<pre>\n<strong>输入：</strong>m = 2, n = 2, indices = [[1,1],[0,0]]\n<strong>输出：</strong>0\n<strong>解释：</strong>最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= m, n <= 50</code></li>\n\t<li><code>1 <= indices.length <= 100</code></li>\n\t<li><code>0 <= r<sub>i</sub> < m</code></li>\n\t<li><code>0 <= c<sub>i</sub> < n</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(n + m + indices.length)</code> 且仅用 <code>O(n + m)</code> 额外空间的算法来解决此问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1253重构 2 行二进制矩阵",
        "hardRate": "MEDIUM",
        "passRate": "48.27%",
        "problemsUrl": "https://leetcode.cn/problems/reconstruct-a-2-row-binary-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/reconstruct-a-2-row-binary-matrix/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>2</code>&nbsp;行 <code>n</code> 列的二进制数组：</p>\n\n<ul>\n\t<li>矩阵是一个二进制矩阵，这意味着矩阵中的每个元素不是&nbsp;<code>0</code>&nbsp;就是&nbsp;<code>1</code>。</li>\n\t<li>第 <code>0</code> 行的元素之和为&nbsp;<code>upper</code>。</li>\n\t<li>第 <code>1</code> 行的元素之和为 <code>lower</code>。</li>\n\t<li>第 <code>i</code> 列（从 <code>0</code> 开始编号）的元素之和为&nbsp;<code>colsum[i]</code>，<code>colsum</code>&nbsp;是一个长度为&nbsp;<code>n</code>&nbsp;的整数数组。</li>\n</ul>\n\n<p>你需要利用&nbsp;<code>upper</code>，<code>lower</code>&nbsp;和&nbsp;<code>colsum</code>&nbsp;来重构这个矩阵，并以二维整数数组的形式返回它。</p>\n\n<p>如果有多个不同的答案，那么任意一个都可以通过本题。</p>\n\n<p>如果不存在符合要求的答案，就请返回一个空的二维数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>upper = 2, lower = 1, colsum = [1,1,1]\n<strong>输出：</strong>[[1,1,0],[0,0,1]]\n<strong>解释：</strong>[[1,0,1],[0,1,0]] 和 [[0,1,1],[1,0,0]] 也是正确答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>upper = 2, lower = 3, colsum = [2,2,1,1]\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>upper = 5, lower = 5, colsum = [2,1,2,0,1,0,1,2,0,1]\n<strong>输出：</strong>[[1,1,1,0,1,0,0,1,0,0],[1,0,1,0,0,0,1,1,0,1]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= colsum.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= upper, lower &lt;= colsum.length</code></li>\n\t<li><code>0 &lt;= colsum[i] &lt;= 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1254统计封闭岛屿的数目",
        "hardRate": "MEDIUM",
        "passRate": "64.23%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-closed-islands/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-closed-islands/solution",
        "problemsDesc": "<p>二维矩阵 <code>grid</code>&nbsp;由 <code>0</code>&nbsp;（土地）和 <code>1</code>&nbsp;（水）组成。岛是由最大的4个方向连通的 <code>0</code>&nbsp;组成的群，封闭岛是一个&nbsp;<code>完全</code> 由1包围（左、上、右、下）的岛。</p>\n\n<p>请返回 <em>封闭岛屿</em> 的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/10/31/sample_3_1610.png\" style=\"height: 151px; width: 240px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 1 区域包围）。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/07/sample_4_1610.png\" style=\"height: 98px; width: 160px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,1,1,1,1,1,1],\n&nbsp;            [1,0,0,0,0,0,1],\n&nbsp;            [1,0,1,1,1,0,1],\n&nbsp;            [1,0,1,0,1,0,1],\n&nbsp;            [1,0,1,1,1,0,1],\n&nbsp;            [1,0,0,0,0,0,1],\n             [1,1,1,1,1,1,1]]\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= grid.length, grid[0].length &lt;= 100</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;=1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1255得分最高的单词集合",
        "hardRate": "HARD",
        "passRate": "79.91%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-words-formed-by-letters/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-words-formed-by-letters/solution",
        "problemsDesc": "<p>你将会得到一份单词表&nbsp;<code>words</code>，一个字母表&nbsp;<code>letters</code>&nbsp;（可能会有重复字母），以及每个字母对应的得分情况表&nbsp;<code>score</code>。</p>\n\n<p>请你帮忙计算玩家在单词拼写游戏中所能获得的「最高得分」：能够由&nbsp;<code>letters</code>&nbsp;里的字母拼写出的&nbsp;<strong>任意</strong>&nbsp;属于 <code>words</code>&nbsp;单词子集中，分数最高的单词集合的得分。</p>\n\n<p>单词拼写游戏的规则概述如下：</p>\n\n<ul>\n\t<li>玩家需要用字母表&nbsp;<code>letters</code> 里的字母来拼写单词表&nbsp;<code>words</code>&nbsp;中的单词。</li>\n\t<li>可以只使用字母表&nbsp;<code>letters</code> 中的部分字母，但是每个字母最多被使用一次。</li>\n\t<li>单词表 <code>words</code>&nbsp;中每个单词只能计分（使用）一次。</li>\n\t<li>根据字母得分情况表<code>score</code>，字母 <code>&#39;a&#39;</code>,&nbsp;<code>&#39;b&#39;</code>,&nbsp;<code>&#39;c&#39;</code>, ... ,&nbsp;<code>&#39;z&#39;</code> 对应的得分分别为 <code>score[0]</code>, <code>score[1]</code>,&nbsp;...,&nbsp;<code>score[25]</code>。</li>\n\t<li>本场游戏的「得分」是指：玩家所拼写出的单词集合里包含的所有字母的得分之和。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;dog&quot;,&quot;cat&quot;,&quot;dad&quot;,&quot;good&quot;], letters = [&quot;a&quot;,&quot;a&quot;,&quot;c&quot;,&quot;d&quot;,&quot;d&quot;,&quot;d&quot;,&quot;g&quot;,&quot;o&quot;,&quot;o&quot;], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]\n<strong>输出：</strong>23\n<strong>解释：</strong>\n字母得分为  a=1, c=9, d=5, g=3, o=2\n使用给定的字母表 letters，我们可以拼写单词 &quot;dad&quot; (5+1+5)和 &quot;good&quot; (3+2+2+5)，得分为 23 。\n而单词 &quot;dad&quot; 和 &quot;dog&quot; 只能得到 21 分。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;xxxz&quot;,&quot;ax&quot;,&quot;bx&quot;,&quot;cx&quot;], letters = [&quot;z&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;x&quot;,&quot;x&quot;,&quot;x&quot;], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]\n<strong>输出：</strong>27\n<strong>解释：</strong>\n字母得分为  a=4, b=4, c=4, x=5, z=10\n使用给定的字母表 letters，我们可以组成单词 &quot;ax&quot; (4+5)， &quot;bx&quot; (4+5) 和 &quot;cx&quot; (4+5) ，总得分为 27 。\n单词 &quot;xxxz&quot; 的得分仅为 25 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;leetcode&quot;], letters = [&quot;l&quot;,&quot;e&quot;,&quot;t&quot;,&quot;c&quot;,&quot;o&quot;,&quot;d&quot;], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]\n<strong>输出：</strong>0\n<strong>解释：</strong>\n字母 &quot;e&quot; 在字母表 letters 中只出现了一次，所以无法组成单词表 words 中的单词。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 14</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 15</code></li>\n\t<li><code>1 &lt;= letters.length &lt;= 100</code></li>\n\t<li><code>letters[i].length == 1</code></li>\n\t<li><code>score.length ==&nbsp;26</code></li>\n\t<li><code>0 &lt;= score[i] &lt;= 10</code></li>\n\t<li><code>words[i]</code>&nbsp;和&nbsp;<code>letters[i]</code>&nbsp;只包含小写的英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1256加密数字",
        "hardRate": "MEDIUM",
        "passRate": "68.71%",
        "problemsUrl": "https://leetcode.cn/problems/encode-number/",
        "solutionsUrl": "https://leetcode.cn/problems/encode-number/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1257最小公共区域",
        "hardRate": "MEDIUM",
        "passRate": "59.18%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-common-region/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-common-region/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1258近义词句子",
        "hardRate": "MEDIUM",
        "passRate": "59.25%",
        "problemsUrl": "https://leetcode.cn/problems/synonymous-sentences/",
        "solutionsUrl": "https://leetcode.cn/problems/synonymous-sentences/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1259不相交的握手",
        "hardRate": "HARD",
        "passRate": "53.17%",
        "problemsUrl": "https://leetcode.cn/problems/handshakes-that-dont-cross/",
        "solutionsUrl": "https://leetcode.cn/problems/handshakes-that-dont-cross/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1260二维网格迁移",
        "hardRate": "EASY",
        "passRate": "65.36%",
        "problemsUrl": "https://leetcode.cn/problems/shift-2d-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/shift-2d-grid/solution",
        "problemsDesc": "<p>给你一个 <code>m</code> 行 <code>n</code> 列的二维网格 <code>grid</code> 和一个整数 <code>k</code>。你需要将 <code>grid</code> 迁移 <code>k</code> 次。</p>\n\n<p>每次「迁移」操作将会引发下述活动：</p>\n\n<ul>\n\t<li>位于 <code>grid[i][j]</code> 的元素将会移动到 <code>grid[i][j + 1]</code>。</li>\n\t<li>位于 <code>grid[i][n - 1]</code> 的元素将会移动到 <code>grid[i + 1][0]</code>。</li>\n\t<li>位于 <code>grid[m - 1][n - 1]</code> 的元素将会移动到 <code>grid[0][0]</code>。</li>\n</ul>\n\n<p>请你返回 <code>k</code> 次迁移操作后最终得到的 <strong>二维网格</strong>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/e1-1.png\" style=\"height: 158px; width: 400px;\" /></p>\n\n<pre>\n<code><strong>输入：</strong>grid</code> = [[1,2,3],[4,5,6],[7,8,9]], k = 1\n<strong>输出：</strong>[[9,1,2],[3,4,5],[6,7,8]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/e2-1.png\" style=\"height: 166px; width: 400px;\" /></p>\n\n<pre>\n<code><strong>输入：</strong>grid</code> = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4\n<strong>输出：</strong>[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<code><strong>输入：</strong>grid</code> = [[1,2,3],[4,5,6],[7,8,9]], k = 9\n<strong>输出：</strong>[[1,2,3],[4,5,6],[7,8,9]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 <= m <= 50</code></li>\n\t<li><code>1 <= n <= 50</code></li>\n\t<li><code>-1000 <= grid[i][j] <= 1000</code></li>\n\t<li><code>0 <= k <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1261在受污染的二叉树中查找元素",
        "hardRate": "MEDIUM",
        "passRate": "73.56%",
        "problemsUrl": "https://leetcode.cn/problems/find-elements-in-a-contaminated-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/find-elements-in-a-contaminated-binary-tree/solution",
        "problemsDesc": "<p>给出一个满足下述规则的二叉树：</p>\n\n<ol>\n\t<li><code>root.val == 0</code></li>\n\t<li>如果 <code>treeNode.val == x</code> 且&nbsp;<code>treeNode.left != null</code>，那么&nbsp;<code>treeNode.left.val == 2 * x + 1</code></li>\n\t<li>如果 <code>treeNode.val == x</code> 且 <code>treeNode.right != null</code>，那么&nbsp;<code>treeNode.right.val == 2 * x + 2</code></li>\n</ol>\n\n<p>现在这个二叉树受到「污染」，所有的&nbsp;<code>treeNode.val</code>&nbsp;都变成了&nbsp;<code>-1</code>。</p>\n\n<p>请你先还原二叉树，然后实现&nbsp;<code>FindElements</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>FindElements(TreeNode* root)</code>&nbsp;用受污染的二叉树初始化对象，你需要先把它还原。</li>\n\t<li><code>bool find(int target)</code>&nbsp;判断目标值&nbsp;<code>target</code>&nbsp;是否存在于还原后的二叉树中并返回结果。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/untitled-diagram-4-1.jpg\" style=\"height: 119px; width: 320px;\"></strong></p>\n\n<pre><strong>输入：</strong>\n[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;]\n[[[-1,null,-1]],[1],[2]]\n<strong>输出：</strong>\n[null,false,true]\n<strong>解释：</strong>\nFindElements findElements = new FindElements([-1,null,-1]); \nfindElements.find(1); // return False \nfindElements.find(2); // return True </pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/untitled-diagram-4.jpg\" style=\"height: 198px; width: 400px;\"></strong></p>\n\n<pre><strong>输入：</strong>\n[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;]\n[[[-1,-1,-1,-1,-1]],[1],[3],[5]]\n<strong>输出：</strong>\n[null,true,true,false]\n<strong>解释：</strong>\nFindElements findElements = new FindElements([-1,-1,-1,-1,-1]);\nfindElements.find(1); // return True\nfindElements.find(3); // return True\nfindElements.find(5); // return False</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/untitled-diagram-4-1-1.jpg\" style=\"height: 274px; width: 306px;\"></strong></p>\n\n<pre><strong>输入：</strong>\n[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;]\n[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]\n<strong>输出：</strong>\n[null,true,false,false,true]\n<strong>解释：</strong>\nFindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);\nfindElements.find(2); // return True\nfindElements.find(3); // return False\nfindElements.find(4); // return False\nfindElements.find(5); // return True\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>TreeNode.val == -1</code></li>\n\t<li>二叉树的高度不超过&nbsp;<code>20</code></li>\n\t<li>节点的总数在&nbsp;<code>[1,&nbsp;10^4]</code>&nbsp;之间</li>\n\t<li>调用&nbsp;<code>find()</code>&nbsp;的总次数在&nbsp;<code>[1,&nbsp;10^4]</code>&nbsp;之间</li>\n\t<li><code>0 &lt;= target &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1262可被三整除的最大和",
        "hardRate": "MEDIUM",
        "passRate": "56.28%",
        "problemsUrl": "https://leetcode.cn/problems/greatest-sum-divisible-by-three/",
        "solutionsUrl": "https://leetcode.cn/problems/greatest-sum-divisible-by-three/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>，请你找出并返回能被三整除的元素最大和。</p>\n\n<ol>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,6,5,1,8]\n<strong>输出：</strong>18\n<strong>解释：</strong>选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4]\n<strong>输出：</strong>0\n<strong>解释：</strong>4 不能被 3 整除，所以无法选出数字，返回 0。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,4]\n<strong>输出：</strong>12\n<strong>解释：</strong>选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 4 * 10^4</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1263推箱子",
        "hardRate": "HARD",
        "passRate": "54.30%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-moves-to-move-a-box-to-their-target-location/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-moves-to-move-a-box-to-their-target-location/solution",
        "problemsDesc": "<p>「推箱子」是一款风靡全球的益智小游戏，玩家需要将箱子推到仓库中的目标位置。</p>\n\n<p>游戏地图用大小为&nbsp;<code>m x n</code>&nbsp;的网格 <code>grid</code> 表示，其中每个元素可以是墙、地板或者是箱子。</p>\n\n<p>现在你将作为玩家参与游戏，按规则将箱子&nbsp;<code>'B'</code>&nbsp;移动到目标位置&nbsp;<code>'T'</code> ：</p>\n\n<ul>\n\t<li>玩家用字符&nbsp;<code>'S'</code>&nbsp;表示，只要他在地板上，就可以在网格中向上、下、左、右四个方向移动。</li>\n\t<li>地板用字符&nbsp;<code>'.'</code>&nbsp;表示，意味着可以自由行走。</li>\n\t<li>墙用字符&nbsp;<code>'#'</code>&nbsp;表示，意味着障碍物，不能通行。&nbsp;</li>\n\t<li>箱子仅有一个，用字符&nbsp;<code>'B'</code>&nbsp;表示。相应地，网格上有一个目标位置&nbsp;<code>'T'</code>。</li>\n\t<li>玩家需要站在箱子旁边，然后沿着箱子的方向进行移动，此时箱子会被移动到相邻的地板单元格。记作一次「推动」。</li>\n\t<li>玩家无法越过箱子。</li>\n</ul>\n\n<p>返回将箱子推到目标位置的最小 <strong>推动</strong> 次数，如果无法做到，请返回&nbsp;<code>-1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/sample_1_1620.png\" style=\"height: 335px; width: 500px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n             [\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\n&nbsp;            [\"#\",\".\",\".\",\"B\",\".\",\"#\"],\n&nbsp;            [\"#\",\".\",\"#\",\"#\",\".\",\"#\"],\n&nbsp;            [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n&nbsp;            [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\n<strong>输出：</strong>3\n<strong>解释：</strong>我们只需要返回推箱子的次数。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n             [\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\n&nbsp;            [\"#\",\".\",\".\",\"B\",\".\",\"#\"],\n&nbsp;            [\"#\",\"#\",\"#\",\"#\",\".\",\"#\"],\n&nbsp;            [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n&nbsp;            [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\n<strong>输出：</strong>-1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n&nbsp;            [\"#\",\"T\",\".\",\".\",\"#\",\"#\"],\n&nbsp;            [\"#\",\".\",\"#\",\"B\",\".\",\"#\"],\n&nbsp;            [\"#\",\".\",\".\",\".\",\".\",\"#\"],\n&nbsp;            [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n&nbsp;            [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\n<strong>输出：</strong>5\n<strong>解释：</strong>向下、向左、向左、向上再向上。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 20</code></li>\n\t<li><code>grid</code> 仅包含字符&nbsp;<code>'.'</code>, <code>'#'</code>,&nbsp; <code>'S'</code> , <code>'T'</code>, 以及&nbsp;<code>'B'</code>。</li>\n\t<li><code>grid</code>&nbsp;中&nbsp;<code>'S'</code>, <code>'B'</code>&nbsp;和&nbsp;<code>'T'</code>&nbsp;各只能出现一个。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1264页面推荐",
        "hardRate": "MEDIUM",
        "passRate": "56.99%",
        "problemsUrl": "https://leetcode.cn/problems/page-recommendations/",
        "solutionsUrl": "https://leetcode.cn/problems/page-recommendations/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1265逆序打印不可变链表",
        "hardRate": "MEDIUM",
        "passRate": "90.69%",
        "problemsUrl": "https://leetcode.cn/problems/print-immutable-linked-list-in-reverse/",
        "solutionsUrl": "https://leetcode.cn/problems/print-immutable-linked-list-in-reverse/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1266访问所有点的最小时间",
        "hardRate": "EASY",
        "passRate": "82.80%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-visiting-all-points/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-visiting-all-points/solution",
        "problemsDesc": "<p>平面上有 <code>n</code> 个点，点的位置用整数坐标表示 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 。请你计算访问所有这些点需要的 <strong>最小时间</strong>（以秒为单位）。</p>\n\n<p>你需要按照下面的规则在平面上移动：</p>\n\n<ul>\n\t<li>每一秒内，你可以：\n\t<ul>\n\t\t<li>沿水平方向移动一个单位长度，或者</li>\n\t\t<li>沿竖直方向移动一个单位长度，或者</li>\n\t\t<li>跨过对角线移动 <code>sqrt(2)</code> 个单位长度（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。</li>\n\t</ul>\n\t</li>\n\t<li>必须按照数组中出现的顺序来访问这些点。</li>\n\t<li>在访问某个点时，可以经过该点后面出现的点，但经过的那些点不算作有效访问。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/24/1626_example_1.png\" style=\"height: 428px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>points = [[1,1],[3,4],[-1,0]]\n<strong>输出：</strong>7\n<strong>解释：</strong>一条最佳的访问路径是： <strong>[1,1]</strong> -> [2,2] -> [3,3] -> <strong>[3,4] </strong>-> [2,3] -> [1,2] -> [0,1] -> <strong>[-1,0]</strong>   \n从 [1,1] 到 [3,4] 需要 3 秒 \n从 [3,4] 到 [-1,0] 需要 4 秒\n一共需要 7 秒</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[3,2],[-2,2]]\n<strong>输出：</strong>5\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>points.length == n</code></li>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>-1000 <= points[i][0], points[i][1] <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1267统计参与通信的服务器",
        "hardRate": "MEDIUM",
        "passRate": "61.88%",
        "problemsUrl": "https://leetcode.cn/problems/count-servers-that-communicate/",
        "solutionsUrl": "https://leetcode.cn/problems/count-servers-that-communicate/solution",
        "problemsDesc": "<p>这里有一幅服务器分布图，服务器的位置标识在&nbsp;<code>m * n</code>&nbsp;的整数矩阵网格&nbsp;<code>grid</code>&nbsp;中，1 表示单元格上有服务器，0 表示没有。</p>\n\n<p>如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。</p>\n\n<p>请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/24/untitled-diagram-6.jpg\" style=\"height: 203px; width: 202px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[1,0],[0,1]]\n<strong>输出：</strong>0\n<strong>解释：</strong>没有一台服务器能与其他服务器进行通信。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/24/untitled-diagram-4-1.jpg\" style=\"height: 203px; width: 203px;\"></strong></p>\n\n<pre><strong>输入：</strong>grid = [[1,0],[1,1]]\n<strong>输出：</strong>3\n<strong>解释：</strong>所有这些服务器都至少可以与一台别的服务器进行通信。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/24/untitled-diagram-1-3.jpg\" style=\"height: 443px; width: 443px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]\n<strong>输出：</strong>4\n<strong>解释：</strong>第一行的两台服务器互相通信，第三列的两台服务器互相通信，但右下角的服务器无法与其他服务器通信。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m &lt;= 250</code></li>\n\t<li><code>1 &lt;= n &lt;= 250</code></li>\n\t<li><code>grid[i][j] == 0 or 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1268搜索推荐系统",
        "hardRate": "MEDIUM",
        "passRate": "59.40%",
        "problemsUrl": "https://leetcode.cn/problems/search-suggestions-system/",
        "solutionsUrl": "https://leetcode.cn/problems/search-suggestions-system/solution",
        "problemsDesc": "<p>给你一个产品数组&nbsp;<code>products</code>&nbsp;和一个字符串&nbsp;<code>searchWord</code>&nbsp;，<code>products</code>&nbsp; 数组中每个产品都是一个字符串。</p>\n\n<p>请你设计一个推荐系统，在依次输入单词&nbsp;<code>searchWord</code> 的每一个字母后，推荐&nbsp;<code>products</code> 数组中前缀与&nbsp;<code>searchWord</code> 相同的最多三个产品。如果前缀相同的可推荐产品超过三个，请按字典序返回最小的三个。</p>\n\n<p>请你以二维列表的形式，返回在输入&nbsp;<code>searchWord</code>&nbsp;每个字母后相应的推荐产品的列表。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>products = [&quot;mobile&quot;,&quot;mouse&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mousepad&quot;], searchWord = &quot;mouse&quot;\n<strong>输出：</strong>[\n[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],\n[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],\n[&quot;mouse&quot;,&quot;mousepad&quot;],\n[&quot;mouse&quot;,&quot;mousepad&quot;],\n[&quot;mouse&quot;,&quot;mousepad&quot;]\n]\n<strong>解释：</strong>按字典序排序后的产品列表是 [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mouse&quot;,&quot;mousepad&quot;]\n输入 m 和 mo，由于所有产品的前缀都相同，所以系统返回字典序最小的三个产品 [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;]\n输入 mou， mous 和 mouse 后系统都返回 [&quot;mouse&quot;,&quot;mousepad&quot;]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>products = [&quot;havana&quot;], searchWord = &quot;havana&quot;\n<strong>输出：</strong>[[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>products = [&quot;bags&quot;,&quot;baggage&quot;,&quot;banner&quot;,&quot;box&quot;,&quot;cloths&quot;], searchWord = &quot;bags&quot;\n<strong>输出：</strong>[[&quot;baggage&quot;,&quot;bags&quot;,&quot;banner&quot;],[&quot;baggage&quot;,&quot;bags&quot;,&quot;banner&quot;],[&quot;baggage&quot;,&quot;bags&quot;],[&quot;bags&quot;]]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>products = [&quot;havana&quot;], searchWord = &quot;tatiana&quot;\n<strong>输出：</strong>[[],[],[],[],[],[],[]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= products.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= &Sigma; products[i].length &lt;= 2 * 10^4</code></li>\n\t<li><code>products[i]</code>&nbsp;中所有的字符都是小写英文字母。</li>\n\t<li><code>1 &lt;= searchWord.length &lt;= 1000</code></li>\n\t<li><code>searchWord</code>&nbsp;中所有字符都是小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1269停在原地的方案数",
        "hardRate": "HARD",
        "passRate": "49.03%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/solution",
        "problemsDesc": "<p>有一个长度为 <code>arrLen</code> 的数组，开始有一个指针在索引 <code>0</code> 处。</p>\n\n<p>每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。</p>\n\n<p>给你两个整数 <code>steps</code> 和 <code>arrLen</code> ，请你计算并返回：在恰好执行 <code>steps</code> 次操作以后，指针仍然指向索引 <code>0</code> 处的方案数。</p>\n\n<p>由于答案可能会很大，请返回方案数 <strong>模</strong> <code>10^9 + 7</code> 后的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>steps = 3, arrLen = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>3 步后，总共有 4 种不同的方法可以停在索引 0 处。\n向右，向左，不动\n不动，向右，向左\n向右，不动，向左\n不动，不动，不动\n</pre>\n\n<p><strong>示例  2：</strong></p>\n\n<pre>\n<strong>输入：</strong>steps = 2, arrLen = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>2 步后，总共有 2 种不同的方法可以停在索引 0 处。\n向右，向左\n不动，不动\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>steps = 4, arrLen = 2\n<strong>输出：</strong>8\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= steps <= 500</code></li>\n\t<li><code>1 <= arrLen <= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1270向公司CEO汇报工作的所有人",
        "hardRate": "MEDIUM",
        "passRate": "79.70%",
        "problemsUrl": "https://leetcode.cn/problems/all-people-report-to-the-given-manager/",
        "solutionsUrl": "https://leetcode.cn/problems/all-people-report-to-the-given-manager/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1271十六进制魔术数字",
        "hardRate": "EASY",
        "passRate": "52.37%",
        "problemsUrl": "https://leetcode.cn/problems/hexspeak/",
        "solutionsUrl": "https://leetcode.cn/problems/hexspeak/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1272删除区间",
        "hardRate": "MEDIUM",
        "passRate": "56.84%",
        "problemsUrl": "https://leetcode.cn/problems/remove-interval/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-interval/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1273删除树节点",
        "hardRate": "MEDIUM",
        "passRate": "57.09%",
        "problemsUrl": "https://leetcode.cn/problems/delete-tree-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-tree-nodes/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1274矩形内船只的数目",
        "hardRate": "HARD",
        "passRate": "64.89%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ships-in-a-rectangle/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ships-in-a-rectangle/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1275找出井字棋的获胜者",
        "hardRate": "EASY",
        "passRate": "55.10%",
        "problemsUrl": "https://leetcode.cn/problems/find-winner-on-a-tic-tac-toe-game/",
        "solutionsUrl": "https://leetcode.cn/problems/find-winner-on-a-tic-tac-toe-game/solution",
        "problemsDesc": "<p><em>A</em> 和&nbsp;<em>B</em>&nbsp;在一个&nbsp;<em>3</em>&nbsp;x&nbsp;<em>3</em>&nbsp;的网格上玩井字棋。</p>\n\n<p>井字棋游戏的规则如下：</p>\n\n<ul>\n\t<li>玩家轮流将棋子放在空方格 (&quot; &quot;) 上。</li>\n\t<li>第一个玩家 A 总是用&nbsp;&quot;X&quot; 作为棋子，而第二个玩家 B 总是用 &quot;O&quot; 作为棋子。</li>\n\t<li>&quot;X&quot; 和 &quot;O&quot; 只能放在空方格中，而不能放在已经被占用的方格上。</li>\n\t<li>只要有 3 个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。</li>\n\t<li>如果所有方块都放满棋子（不为空），游戏也会结束。</li>\n\t<li>游戏结束后，棋子无法再进行任何移动。</li>\n</ul>\n\n<p>给你一个数组 <code>moves</code>，其中每个元素是大小为 <code>2</code> 的另一个数组（元素分别对应网格的行和列），它按照 <em>A</em> 和 <em>B</em> 的行动顺序（先 <em>A</em> 后 <em>B</em>）记录了两人各自的棋子位置。</p>\n\n<p>如果游戏存在获胜者（<em>A</em> 或 <em>B</em>），就返回该游戏的获胜者；如果游戏以平局结束，则返回 &quot;Draw&quot;；如果仍会有行动（游戏未结束），则返回 &quot;Pending&quot;。</p>\n\n<p>你可以假设&nbsp;<code>moves</code>&nbsp;都 <strong>有效</strong>（遵循井字棋规则），网格最初是空的，<em>A</em> 将先行动。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]\n<strong>输出：</strong>&quot;A&quot;\n<strong>解释：</strong>&quot;A&quot; 获胜，他总是先走。\n&quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;    &quot;<strong>X</strong>  &quot;\n&quot;   &quot; -&gt; &quot;   &quot; -&gt; &quot; X &quot; -&gt; &quot; X &quot; -&gt; &quot; <strong>X</strong> &quot;\n&quot;   &quot;    &quot;O  &quot;    &quot;O  &quot;    &quot;OO &quot;    &quot;OO<strong>X</strong>&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]\n<strong>输出：</strong>&quot;B&quot;\n<strong>解释：</strong>&quot;B&quot; 获胜。\n&quot;X  &quot;    &quot;X  &quot;    &quot;XX &quot;    &quot;XXO&quot;    &quot;XXO&quot;    &quot;XX<strong>O</strong>&quot;\n&quot;   &quot; -&gt; &quot; O &quot; -&gt; &quot; O &quot; -&gt; &quot; O &quot; -&gt; &quot;XO &quot; -&gt; &quot;X<strong>O</strong> &quot; \n&quot;   &quot;    &quot;   &quot;    &quot;   &quot;    &quot;   &quot;    &quot;   &quot;    &quot;<strong>O</strong>  &quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]\n<strong>输出：</strong>&quot;Draw&quot;\n<strong>输出：</strong>由于没有办法再行动，游戏以平局结束。\n&quot;XXO&quot;\n&quot;OOX&quot;\n&quot;XOX&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>moves = [[0,0],[1,1]]\n<strong>输出：</strong>&quot;Pending&quot;\n<strong>解释：</strong>游戏还没有结束。\n&quot;X  &quot;\n&quot; O &quot;\n&quot;   &quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= moves.length &lt;= 9</code></li>\n\t<li><code>moves[i].length == 2</code></li>\n\t<li><code>0 &lt;= moves[i][j] &lt;= 2</code></li>\n\t<li><code>moves</code>&nbsp;里没有重复的元素。</li>\n\t<li><code>moves</code> 遵循井字棋的规则。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1276不浪费原料的汉堡制作方案",
        "hardRate": "MEDIUM",
        "passRate": "50.29%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-burgers-with-no-waste-of-ingredients/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-burgers-with-no-waste-of-ingredients/solution",
        "problemsDesc": "<p>圣诞活动预热开始啦，汉堡店推出了全新的汉堡套餐。为了避免浪费原料，请你帮他们制定合适的制作计划。</p>\n\n<p>给你两个整数&nbsp;<code>tomatoSlices</code>&nbsp;和&nbsp;<code>cheeseSlices</code>，分别表示番茄片和奶酪片的数目。不同汉堡的原料搭配如下：</p>\n\n<ul>\n\t<li><strong>巨无霸汉堡：</strong>4 片番茄和 1 片奶酪</li>\n\t<li><strong>小皇堡：</strong>2 片番茄和&nbsp;1 片奶酪</li>\n</ul>\n\n<p>请你以&nbsp;<code>[total_jumbo, total_small]</code>（[巨无霸汉堡总数，小皇堡总数]）的格式返回恰当的制作方案，使得剩下的番茄片&nbsp;<code>tomatoSlices</code>&nbsp;和奶酪片&nbsp;<code>cheeseSlices</code>&nbsp;的数量都是&nbsp;<code>0</code>。</p>\n\n<p>如果无法使剩下的番茄片&nbsp;<code>tomatoSlices</code>&nbsp;和奶酪片&nbsp;<code>cheeseSlices</code>&nbsp;的数量为&nbsp;<code>0</code>，就请返回&nbsp;<code>[]</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>tomatoSlices = 16, cheeseSlices = 7\n<strong>输出：</strong>[1,6]\n<strong>解释：</strong>制作 1 个巨无霸汉堡和 6 个小皇堡需要 4*1 + 2*6 = 16 片番茄和 1 + 6 = 7 片奶酪。不会剩下原料。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>tomatoSlices = 17, cheeseSlices = 4\n<strong>输出：</strong>[]\n<strong>解释：</strong>只制作小皇堡和巨无霸汉堡无法用光全部原料。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>tomatoSlices = 4, cheeseSlices = 17\n<strong>输出：</strong>[]\n<strong>解释：</strong>制作 1 个巨无霸汉堡会剩下 16 片奶酪，制作 2 个小皇堡会剩下 15 片奶酪。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>tomatoSlices = 0, cheeseSlices = 0\n<strong>输出：</strong>[0,0]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>tomatoSlices = 2, cheeseSlices = 1\n<strong>输出：</strong>[0,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= tomatoSlices &lt;= 10^7</code></li>\n\t<li><code>0 &lt;= cheeseSlices &lt;= 10^7</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1277统计全为 1 的正方形子矩阵",
        "hardRate": "MEDIUM",
        "passRate": "73.50%",
        "problemsUrl": "https://leetcode.cn/problems/count-square-submatrices-with-all-ones/",
        "solutionsUrl": "https://leetcode.cn/problems/count-square-submatrices-with-all-ones/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m * n</code>&nbsp;的矩阵，矩阵中的元素不是 <code>0</code> 就是 <code>1</code>，请你统计并返回其中完全由 <code>1</code> 组成的 <strong>正方形</strong> 子矩阵的个数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>matrix =\n[\n&nbsp; [0,1,1,1],\n&nbsp; [1,1,1,1],\n&nbsp; [0,1,1,1]\n]\n<strong>输出：</strong>15\n<strong>解释：</strong> \n边长为 1 的正方形有 <strong>10</strong> 个。\n边长为 2 的正方形有 <strong>4</strong> 个。\n边长为 3 的正方形有 <strong>1</strong> 个。\n正方形的总数 = 10 + 4 + 1 = <strong>15</strong>.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>matrix = \n[\n  [1,0,1],\n  [1,1,0],\n  [1,1,0]\n]\n<strong>输出：</strong>7\n<strong>解释：</strong>\n边长为 1 的正方形有 <strong>6</strong> 个。 \n边长为 2 的正方形有 <strong>1</strong> 个。\n正方形的总数 = 6 + 1 = <strong>7</strong>.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length&nbsp;&lt;= 300</code></li>\n\t<li><code>1 &lt;= arr[0].length&nbsp;&lt;= 300</code></li>\n\t<li><code>0 &lt;= arr[i][j] &lt;= 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1278分割回文串 III",
        "hardRate": "HARD",
        "passRate": "62.21%",
        "problemsUrl": "https://leetcode.cn/problems/palindrome-partitioning-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/palindrome-partitioning-iii/solution",
        "problemsDesc": "<p>给你一个由小写字母组成的字符串&nbsp;<code>s</code>，和一个整数&nbsp;<code>k</code>。</p>\n\n<p>请你按下面的要求分割字符串：</p>\n\n<ul>\n\t<li>首先，你可以将&nbsp;<code>s</code>&nbsp;中的部分字符修改为其他的小写英文字母。</li>\n\t<li>接着，你需要把&nbsp;<code>s</code>&nbsp;分割成&nbsp;<code>k</code>&nbsp;个非空且不相交的子串，并且每个子串都是回文串。</li>\n</ul>\n\n<p>请返回以这种方式分割字符串所需修改的最少字符数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abc&quot;, k = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>你可以把字符串分割成 &quot;ab&quot; 和 &quot;c&quot;，并修改 &quot;ab&quot; 中的 1 个字符，将它变成回文串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aabbc&quot;, k = 3\n<strong>输出：</strong>0\n<strong>解释：</strong>你可以把字符串分割成 &quot;aa&quot;、&quot;bb&quot; 和 &quot;c&quot;，它们都是回文串。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;leetcode&quot;, k = 8\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code>&nbsp;中只含有小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1279红绿灯路口",
        "hardRate": "EASY",
        "passRate": "57.54%",
        "problemsUrl": "https://leetcode.cn/problems/traffic-light-controlled-intersection/",
        "solutionsUrl": "https://leetcode.cn/problems/traffic-light-controlled-intersection/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1280学生们参加各科测试的次数",
        "hardRate": "EASY",
        "passRate": "49.48%",
        "problemsUrl": "https://leetcode.cn/problems/students-and-examinations/",
        "solutionsUrl": "https://leetcode.cn/problems/students-and-examinations/solution",
        "problemsDesc": "<p>学生表: <code>Students</code></p>\n\n<pre>+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| student_id    | int     |\n| student_name  | varchar |\n+---------------+---------+\n主键为 student_id（学生ID），该表内的每一行都记录有学校一名学生的信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>科目表: <code>Subjects</code></p>\n\n<pre>+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| subject_name | varchar |\n+--------------+---------+\n主键为 subject_name（科目名称），每一行记录学校的一门科目名称。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>考试表: <code>Examinations</code></p>\n\n<pre>+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| student_id   | int     |\n| subject_name | varchar |\n+--------------+---------+\n这张表压根没有主键，可能会有重复行。\n学生表里的一个学生修读科目表里的每一门科目，而这张考试表的每一行记录就表示学生表里的某个学生参加了一次科目表里某门科目的测试。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>要求写一段 SQL 语句，查询出每个学生参加每一门科目测试的次数，结果按 <code>student_id</code> 和 <code>subject_name</code> 排序。</p>\n\n<p>查询结构格式如下所示：</p>\n\n<pre>Students table:\n+------------+--------------+\n| student_id | student_name |\n+------------+--------------+\n| 1          | Alice        |\n| 2          | Bob          |\n| 13         | John         |\n| 6          | Alex         |\n+------------+--------------+\nSubjects table:\n+--------------+\n| subject_name |\n+--------------+\n| Math         |\n| Physics      |\n| Programming  |\n+--------------+\nExaminations table:\n+------------+--------------+\n| student_id | subject_name |\n+------------+--------------+\n| 1          | Math         |\n| 1          | Physics      |\n| 1          | Programming  |\n| 2          | Programming  |\n| 1          | Physics      |\n| 1          | Math         |\n| 13         | Math         |\n| 13         | Programming  |\n| 13         | Physics      |\n| 2          | Math         |\n| 1          | Math         |\n+------------+--------------+\nResult table:\n+------------+--------------+--------------+----------------+\n| student_id | student_name | subject_name | attended_exams |\n+------------+--------------+--------------+----------------+\n| 1          | Alice        | Math         | 3              |\n| 1          | Alice        | Physics      | 2              |\n| 1          | Alice        | Programming  | 1              |\n| 2          | Bob          | Math         | 1              |\n| 2          | Bob          | Physics      | 0              |\n| 2          | Bob          | Programming  | 1              |\n| 6          | Alex         | Math         | 0              |\n| 6          | Alex         | Physics      | 0              |\n| 6          | Alex         | Programming  | 0              |\n| 13         | John         | Math         | 1              |\n| 13         | John         | Physics      | 1              |\n| 13         | John         | Programming  | 1              |\n+------------+--------------+--------------+----------------+\n结果表需包含所有学生和所有科目（即便测试次数为0）：\nAlice 参加了 3 次数学测试, 2 次物理测试，以及 1 次编程测试；\nBob 参加了 1 次数学测试, 1 次编程测试，没有参加物理测试；\nAlex 啥测试都没参加；\nJohn  参加了数学、物理、编程测试各 1 次。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1281整数的各位积和之差",
        "hardRate": "EASY",
        "passRate": "83.15%",
        "problemsUrl": "https://leetcode.cn/problems/subtract-the-product-and-sum-of-digits-of-an-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/subtract-the-product-and-sum-of-digits-of-an-integer/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 234\n<strong>输出：</strong>15 \n<strong>解释：</strong>\n各位数之积 = 2 * 3 * 4 = 24 \n各位数之和 = 2 + 3 + 4 = 9 \n结果 = 24 - 9 = 15\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 4421\n<strong>输出：</strong>21\n<strong>解释： \n</strong>各位数之积 = 4 * 4 * 2 * 1 = 32 \n各位数之和 = 4 + 4 + 2 + 1 = 11 \n结果 = 32 - 11 = 21\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1282用户分组",
        "hardRate": "MEDIUM",
        "passRate": "86.46%",
        "problemsUrl": "https://leetcode.cn/problems/group-the-people-given-the-group-size-they-belong-to/",
        "solutionsUrl": "https://leetcode.cn/problems/group-the-people-given-the-group-size-they-belong-to/solution",
        "problemsDesc": "<p>有&nbsp;<code>n</code>&nbsp;个人被分成数量未知的组。每个人都被标记为一个从 <code>0</code> 到 <code>n - 1</code> 的<strong>唯一ID</strong>&nbsp;。</p>\n\n<p>给定一个整数数组 <code>groupSizes</code> ，其中<meta charset=\"UTF-8\" />&nbsp;<code>groupSizes[i]</code>&nbsp;是第 <code>i</code> 个人所在的组的大小。例如，如果&nbsp;<code>groupSizes[1] = 3</code>&nbsp;，则第 <code>1</code> 个人必须位于大小为 <code>3</code> 的组中。</p>\n\n<p>返回一个组列表，使每个人 <code>i</code> 都在一个大小为<meta charset=\"UTF-8\" /><em>&nbsp;<code>groupSizes[i]</code>&nbsp;</em>的组中。</p>\n\n<p>每个人应该&nbsp;<strong>恰好只&nbsp;</strong>出现在&nbsp;<strong>一个组&nbsp;</strong>中，并且每个人必须在一个组中。如果有多个答案，返回其中&nbsp;<strong>任何&nbsp;</strong>一个。可以&nbsp;<strong>保证&nbsp;</strong>给定输入&nbsp;<strong>至少有一个&nbsp;</strong>有效的解。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>groupSizes = [3,3,3,3,3,1,3]\n<strong>输出：</strong>[[5],[0,1,2],[3,4,6]]\n<strong>解释：\n</strong>第一组是 [5]，大小为 1，groupSizes[5] = 1。\n第二组是 [0,1,2]，大小为 3，groupSizes[0] = groupSizes[1] = groupSizes[2] = 3。\n第三组是 [3,4,6]，大小为 3，groupSizes[3] = groupSizes[4] = groupSizes[6] = 3。 \n其他可能的解决方案有 [[2,1,6],[5],[0,4,3]] 和 [[5],[0,6,2],[4,3,1]]。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>groupSizes = [2,1,3,3,3,2]\n<strong>输出：</strong>[[1],[0,5],[2,3,4]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>groupSizes.length == n</code></li>\n\t<li><code>1 &lt;= n&nbsp;&lt;= 500</code></li>\n\t<li><code>1 &lt;=&nbsp;groupSizes[i] &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1283使结果不超过阈值的最小除数",
        "hardRate": "MEDIUM",
        "passRate": "49.15%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code> 和一个正整数&nbsp;<code>threshold</code> &nbsp;，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。</p>\n\n<p>请你找出能够使上述结果小于等于阈值&nbsp;<code>threshold</code>&nbsp;的除数中 <strong>最小</strong> 的那个。</p>\n\n<p>每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。</p>\n\n<p>题目保证一定有解。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,5,9], threshold = 6\n<strong>输出：</strong>5\n<strong>解释：</strong>如果除数为 1 ，我们可以得到和为 17 （1+2+5+9）。\n如果除数为 4 ，我们可以得到和为 7 (1+1+2+3) 。如果除数为 5 ，和为 5 (1+1+1+2)。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,5,7,11], threshold = 11\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [19], threshold = 5\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10^4</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^6</code></li>\n\t<li><code>nums.length &lt;=&nbsp;threshold &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1284转化为全零矩阵的最少反转次数",
        "hardRate": "HARD",
        "passRate": "68.01%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的二进制矩阵&nbsp;<code>mat</code>。每一步，你可以选择一个单元格并将它反转（反转表示 <code>0</code> 变 <code>1</code> ，<code>1</code> 变 <code>0</code> ）。如果存在和它相邻的单元格，那么这些相邻的单元格也会被反转。相邻的两个单元格共享同一条边。</p>\n\n<p>请你返回将矩阵&nbsp;<code>mat</code> 转化为全零矩阵的<em>最少反转次数</em>，如果无法转化为全零矩阵，请返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p><strong>二进制矩阵</strong>&nbsp;的每一个格子要么是 <code>0</code> 要么是 <code>1</code> 。</p>\n\n<p><strong>全零矩阵</strong>&nbsp;是所有格子都为 <code>0</code> 的矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/13/matrix.png\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[0,0],[0,1]]\n<strong>输出：</strong>3\n<strong>解释：</strong>一个可能的解是反转 (1, 0)，然后 (0, 1) ，最后是 (1, 1) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[0]]\n<strong>输出：</strong>0\n<strong>解释：</strong>给出的矩阵是全零矩阵，所以你不需要改变它。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1,0,0],[1,0,0]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>该矩阵无法转变成全零矩阵\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m ==&nbsp;mat.length</code></li>\n\t<li><code>n ==&nbsp;mat[0].length</code></li>\n\t<li><code>1 &lt;= m&nbsp;&lt;= 3</code></li>\n\t<li><code>1 &lt;= n&nbsp;&lt;= 3</code></li>\n\t<li><code>mat[i][j]</code>&nbsp;是 0 或 1 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1285找到连续区间的开始和结束数字",
        "hardRate": "MEDIUM",
        "passRate": "80.93%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-start-and-end-number-of-continuous-ranges/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-start-and-end-number-of-continuous-ranges/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1286字母组合迭代器",
        "hardRate": "MEDIUM",
        "passRate": "65.10%",
        "problemsUrl": "https://leetcode.cn/problems/iterator-for-combination/",
        "solutionsUrl": "https://leetcode.cn/problems/iterator-for-combination/solution",
        "problemsDesc": "<p>请你设计一个迭代器类&nbsp;<code>CombinationIterator</code>&nbsp;，包括以下内容：</p>\n\n<ul>\n\t<li><code>CombinationIterator(string characters, int combinationLength)</code>&nbsp;一个构造函数，输入参数包括：用一个&nbsp;<strong>有序且字符唯一&nbsp;</strong>的字符串&nbsp;<code>characters</code>（该字符串只包含小写英文字母）和一个数字&nbsp;<code>combinationLength</code>&nbsp;。</li>\n\t<li>函数&nbsp;<em><code>next()</code>&nbsp;</em>，按&nbsp;<strong>字典序&nbsp;</strong>返回长度为&nbsp;<code>combinationLength</code> 的下一个字母组合。</li>\n\t<li>函数&nbsp;<em><code>hasNext()</code>&nbsp;</em>，只有存在长度为&nbsp;<code>combinationLength</code> 的下一个字母组合时，才返回&nbsp;<code>true</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong>\n[\"CombinationIterator\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[\"abc\", 2], [], [], [], [], [], []]\n<strong>输出：</strong>\n[null, \"ab\", true, \"ac\", true, \"bc\", false]\n<strong>解释：\n</strong>CombinationIterator iterator = new CombinationIterator(\"abc\", 2); // 创建迭代器 iterator\niterator.next(); // 返回 \"ab\"\niterator.hasNext(); // 返回 true\niterator.next(); // 返回 \"ac\"\niterator.hasNext(); // 返回 true\niterator.next(); // 返回 \"bc\"\niterator.hasNext(); // 返回 false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= combinationLength &lt;=&nbsp;characters.length &lt;= 15</code></li>\n\t<li>&nbsp;<code>characters</code>&nbsp;中每个字符都 <strong>不同</strong></li>\n\t<li>每组测试数据最多对&nbsp;<code>next</code>&nbsp;和&nbsp;<code>hasNext</code>&nbsp;调用&nbsp;<code>10<sup>4</sup></code>次</li>\n\t<li>题目保证每次调用函数&nbsp;<code>next</code>&nbsp;时都存在下一个字母组合。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1287有序数组中出现次数超过25%的元素",
        "hardRate": "EASY",
        "passRate": "58.74%",
        "problemsUrl": "https://leetcode.cn/problems/element-appearing-more-than-25-in-sorted-array/",
        "solutionsUrl": "https://leetcode.cn/problems/element-appearing-more-than-25-in-sorted-array/solution",
        "problemsDesc": "<p>给你一个非递减的&nbsp;<strong>有序&nbsp;</strong>整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。</p>\n\n<p>请你找到并返回这个整数</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,2,6,6,6,6,7,10]\n<strong>输出：</strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10^4</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1288删除被覆盖区间",
        "hardRate": "MEDIUM",
        "passRate": "56.02%",
        "problemsUrl": "https://leetcode.cn/problems/remove-covered-intervals/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-covered-intervals/solution",
        "problemsDesc": "<p>给你一个区间列表，请你删除列表中被其他区间所覆盖的区间。</p>\n\n<p>只有当&nbsp;<code>c &lt;= a</code>&nbsp;且&nbsp;<code>b &lt;= d</code>&nbsp;时，我们才认为区间&nbsp;<code>[a,b)</code> 被区间&nbsp;<code>[c,d)</code> 覆盖。</p>\n\n<p>在完成所有删除操作后，请你返回列表中剩余区间的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,4],[3,6],[2,8]]\n<strong>输出：</strong>2\n<strong>解释：</strong>区间 [3,6] 被区间 [2,8] 覆盖，所以它被删除了。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong>​​​​​​</p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= intervals[i][0] &lt;&nbsp;intervals[i][1] &lt;= 10^5</code></li>\n\t<li>对于所有的&nbsp;<code>i != j</code>：<code>intervals[i] != intervals[j]</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1289下降路径最小和  II",
        "hardRate": "HARD",
        "passRate": "58.30%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-falling-path-sum-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-falling-path-sum-ii/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>n x n</code> 整数矩阵&nbsp;<code>grid</code>&nbsp;，请你返回 <strong>非零偏移下降路径</strong> 数字和的最小值。</p>\n\n<p><strong>非零偏移下降路径</strong> 定义为：从&nbsp;<code>grid</code> 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/10/falling-grid.jpg\" style=\"width: 244px; height: 245px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>13\n<strong>解释：</strong>\n所有非零偏移下降路径包括：\n[1,5,9], [1,5,7], [1,6,7], [1,6,8],\n[2,4,8], [2,4,9], [2,6,7], [2,6,8],\n[3,4,8], [3,4,9], [3,5,7], [3,5,9]\n下降路径中数字和最小的是&nbsp;[1,5,7] ，所以答案是&nbsp;13 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[7]]\n<strong>输出：</strong>7\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>-99 &lt;= grid[i][j] &lt;= 99</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1290二进制链表转整数",
        "hardRate": "EASY",
        "passRate": "80.52%",
        "problemsUrl": "https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer/solution",
        "problemsDesc": "<p>给你一个单链表的引用结点&nbsp;<code>head</code>。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。</p>\n\n<p>请你返回该链表所表示数字的 <strong>十进制值</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/15/graph-1.png\" style=\"height: 108px; width: 426px;\"></p>\n\n<pre><strong>输入：</strong>head = [1,0,1]\n<strong>输出：</strong>5\n<strong>解释：</strong>二进制数 (101) 转化为十进制数 (5)\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>head = [0]\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>head = [1]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]\n<strong>输出：</strong>18880\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>head = [0,0]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表不为空。</li>\n\t<li>链表的结点总数不超过&nbsp;<code>30</code>。</li>\n\t<li>每个结点的值不是&nbsp;<code>0</code> 就是 <code>1</code>。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1291顺次数",
        "hardRate": "MEDIUM",
        "passRate": "53.51%",
        "problemsUrl": "https://leetcode.cn/problems/sequential-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/sequential-digits/solution",
        "problemsDesc": "<p>我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 <code>1</code> 的整数。</p>\n\n<p>请你返回由&nbsp;<code>[low, high]</code>&nbsp;范围内所有顺次数组成的 <strong>有序</strong> 列表（从小到大排序）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输出：</strong>low = 100, high = 300\n<strong>输出：</strong>[123,234]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输出：</strong>low = 1000, high = 13000\n<strong>输出：</strong>[1234,2345,3456,4567,5678,6789,12345]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>10 &lt;= low &lt;= high &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1292元素和小于等于阈值的正方形的最大边长",
        "hardRate": "MEDIUM",
        "passRate": "50.71%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/solution",
        "problemsDesc": "<p>给你一个大小为&nbsp;<code>m x n</code>&nbsp;的矩阵&nbsp;<code>mat</code>&nbsp;和一个整数阈值&nbsp;<code>threshold</code>。</p>\n\n<p>请你返回元素总和小于或等于阈值的正方形区域的最大边长；如果没有这样的正方形区域，则返回 <strong>0&nbsp;</strong>。<br />\n&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/15/e1.png\" style=\"height: 186px; width: 335px;\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>总和小于或等于 4 的正方形的最大边长为 2，如图所示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>0 &lt;= mat[i][j] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= threshold &lt;= 10<sup>5</sup></code><sup>&nbsp;</sup></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1293网格中的最短路径",
        "hardRate": "HARD",
        "passRate": "38.34%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-path-in-a-grid-with-obstacles-elimination/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-path-in-a-grid-with-obstacles-elimination/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m * n</code>&nbsp;的网格，其中每个单元格不是&nbsp;<code>0</code>（空）就是&nbsp;<code>1</code>（障碍物）。每一步，您都可以在空白单元格中上、下、左、右移动。</p>\n\n<p>如果您 <strong>最多</strong> 可以消除 <code>k</code> 个障碍物，请找出从左上角 <code>(0, 0)</code> 到右下角 <code>(m-1, n-1)</code> 的最短路径，并返回通过该路径所需的步数。如果找不到这样的路径，则返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/09/30/short1-grid.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong> grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1\n<strong>输出：</strong>6\n<strong>解释：\n</strong>不消除任何障碍的最短路径是 10。\n消除位置 (3,2) 处的障碍后，最短路径是 6 。该路径是 <code>(0,0) -&gt; (0,1) -&gt; (0,2) -&gt; (1,2) -&gt; (2,2) -&gt; <strong>(3,2)</strong> -&gt; (4,2)</code>.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/09/30/short2-grid.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1\n<strong>输出：</strong>-1\n<strong>解释：</strong>我们至少需要消除两个障碍才能找到这样的路径。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>grid.length&nbsp;== m</code></li>\n\t<li><code>grid[0].length&nbsp;== n</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 40</code></li>\n\t<li><code>1 &lt;= k &lt;= m*n</code></li>\n\t<li><code>grid[i][j]</code>&nbsp;是&nbsp;<code>0</code>&nbsp;或<strong>&nbsp;</strong><code>1</code></li>\n\t<li><code>grid[0][0] == grid[m-1][n-1] == 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1294不同国家的天气类型",
        "hardRate": "EASY",
        "passRate": "65.54%",
        "problemsUrl": "https://leetcode.cn/problems/weather-type-in-each-country/",
        "solutionsUrl": "https://leetcode.cn/problems/weather-type-in-each-country/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1295统计位数为偶数的数字",
        "hardRate": "EASY",
        "passRate": "80.06%",
        "problemsUrl": "https://leetcode.cn/problems/find-numbers-with-even-number-of-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/find-numbers-with-even-number-of-digits/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>，请你返回其中位数为&nbsp;<strong>偶数</strong>&nbsp;的数字的个数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [12,345,2,6,7896]\n<strong>输出：</strong>2\n<strong>解释：\n</strong>12 是 2 位数字（位数为偶数）&nbsp;\n345 是 3 位数字（位数为奇数）&nbsp;&nbsp;\n2 是 1 位数字（位数为奇数）&nbsp;\n6 是 1 位数字 位数为奇数）&nbsp;\n7896 是 4 位数字（位数为偶数）&nbsp;&nbsp;\n因此只有 12 和 7896 是位数为偶数的数字\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [555,901,482,1771]\n<strong>输出：</strong>1 \n<strong>解释： </strong>\n只有 1771 是位数为偶数的数字。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1296划分数组为连续数字的集合",
        "hardRate": "MEDIUM",
        "passRate": "49.10%",
        "problemsUrl": "https://leetcode.cn/problems/divide-array-in-sets-of-k-consecutive-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-array-in-sets-of-k-consecutive-numbers/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;和一个正整数&nbsp;<code>k</code>，请你判断是否可以把这个数组划分成一些由&nbsp;<code>k</code>&nbsp;个连续数字组成的集合。<br />\n如果可以，请返回 <code>true</code>；否则，返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,3,4,4,5,6], k = 4\n<strong>输出：</strong>true\n<strong>解释：</strong>数组可以分成 [1,2,3,4] 和 [3,4,5,6]。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3\n<strong>输出：</strong>true\n<strong>解释：</strong>数组可以分成 [1,2,3] , [2,3,4] , [3,4,5] 和 [9,10,11]。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,3,2,2,1,1], k = 3\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4], k = 3\n<strong>输出：</strong>false\n<strong>解释：</strong>数组不能分成几个大小为 3 的子数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>此题目与 846 重复：<a href=\"https://leetcode-cn.com/problems/hand-of-straights/\" target=\"_blank\">https://leetcode-cn.com/problems/hand-of-straights/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1297子串的最大出现次数",
        "hardRate": "MEDIUM",
        "passRate": "48.33%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-occurrences-of-a-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-occurrences-of-a-substring/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code> ，请你返回满足以下条件且出现次数最大的&nbsp;<strong>任意</strong>&nbsp;子串的出现次数：</p>\n\n<ul>\n\t<li>子串中不同字母的数目必须小于等于 <code>maxLetters</code> 。</li>\n\t<li>子串的长度必须大于等于&nbsp;<code>minSize</code> 且小于等于&nbsp;<code>maxSize</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aababcaab&quot;, maxLetters = 2, minSize = 3, maxSize = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>子串 &quot;aab&quot; 在原字符串中出现了 2 次。\n它满足所有的要求：2 个不同的字母，长度为 3 （在 minSize 和 maxSize 范围内）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aaaa&quot;, maxLetters = 1, minSize = 3, maxSize = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>子串 &quot;aaa&quot; 在原字符串中出现了 2 次，且它们有重叠部分。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aabcabcab&quot;, maxLetters = 2, minSize = 2, maxSize = 3\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abcde&quot;, maxLetters = 2, minSize = 3, maxSize = 3\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= maxLetters &lt;= 26</code></li>\n\t<li><code>1 &lt;= minSize &lt;= maxSize &lt;= min(26, s.length)</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1298你能从盒子里获得的最大糖果数",
        "hardRate": "HARD",
        "passRate": "59.79%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-candies-you-can-get-from-boxes/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-candies-you-can-get-from-boxes/solution",
        "problemsDesc": "<p>给你&nbsp;<code>n</code>&nbsp;个盒子，每个盒子的格式为&nbsp;<code>[status, candies, keys, containedBoxes]</code>&nbsp;，其中：</p>\n\n<ul>\n\t<li>状态字&nbsp;<code>status[i]</code>：整数，如果&nbsp;<code>box[i]</code>&nbsp;是开的，那么是 <strong>1&nbsp;</strong>，否则是 <strong>0&nbsp;</strong>。</li>\n\t<li>糖果数&nbsp;<code>candies[i]</code>: 整数，表示&nbsp;<code>box[i]</code> 中糖果的数目。</li>\n\t<li>钥匙&nbsp;<code>keys[i]</code>：数组，表示你打开&nbsp;<code>box[i]</code>&nbsp;后，可以得到一些盒子的钥匙，每个元素分别为该钥匙对应盒子的下标。</li>\n\t<li>内含的盒子&nbsp;<code>containedBoxes[i]</code>：整数，表示放在&nbsp;<code>box[i]</code>&nbsp;里的盒子所对应的下标。</li>\n</ul>\n\n<p>给你一个&nbsp;<code>initialBoxes</code> 数组，表示你现在得到的盒子，你可以获得里面的糖果，也可以用盒子里的钥匙打开新的盒子，还可以继续探索从这个盒子里找到的其他盒子。</p>\n\n<p>请你按照上述规则，返回可以获得糖果的 <strong>最大数目&nbsp;</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>status = [1,0,1,0], candies = [7,5,4,100], keys = [[],[],[1],[]], containedBoxes = [[1,2],[3],[],[]], initialBoxes = [0]\n<strong>输出：</strong>16\n<strong>解释：\n</strong>一开始你有盒子 0 。你将获得它里面的 7 个糖果和盒子 1 和 2。\n盒子 1 目前状态是关闭的，而且你还没有对应它的钥匙。所以你将会打开盒子 2 ，并得到里面的 4 个糖果和盒子 1 的钥匙。\n在盒子 1 中，你会获得 5 个糖果和盒子 3 ，但是你没法获得盒子 3 的钥匙所以盒子 3 会保持关闭状态。\n你总共可以获得的糖果数目 = 7 + 4 + 5 = 16 个。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>status = [1,0,0,0,0,0], candies = [1,1,1,1,1,1], keys = [[1,2,3,4,5],[],[],[],[],[]], containedBoxes = [[1,2,3,4,5],[],[],[],[],[]], initialBoxes = [0]\n<strong>输出：</strong>6\n<strong>解释：\n</strong>你一开始拥有盒子 0 。打开它你可以找到盒子 1,2,3,4,5 和它们对应的钥匙。\n打开这些盒子，你将获得所有盒子的糖果，所以总糖果数为 6 个。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>status = [1,1,1], candies = [100,1,100], keys = [[],[0,2],[]], containedBoxes = [[],[],[]], initialBoxes = [1]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>status = [1], candies = [100], keys = [[]], containedBoxes = [[]], initialBoxes = []\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>status = [1,1,1], candies = [2,3,2], keys = [[],[],[]], containedBoxes = [[],[],[]], initialBoxes = [2,1,0]\n<strong>输出：</strong>7\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= status.length &lt;= 1000</code></li>\n\t<li><code>status.length == candies.length == keys.length == containedBoxes.length == n</code></li>\n\t<li><code>status[i]</code> 要么是&nbsp;<code>0</code>&nbsp;要么是&nbsp;<code>1</code> 。</li>\n\t<li><code>1 &lt;= candies[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= keys[i].length &lt;= status.length</code></li>\n\t<li><code>0 &lt;= keys[i][j] &lt; status.length</code></li>\n\t<li><code>keys[i]</code>&nbsp;中的值都是互不相同的。</li>\n\t<li><code>0 &lt;= containedBoxes[i].length &lt;= status.length</code></li>\n\t<li><code>0 &lt;= containedBoxes[i][j] &lt; status.length</code></li>\n\t<li><code>containedBoxes[i]</code>&nbsp;中的值都是互不相同的。</li>\n\t<li>每个盒子最多被一个盒子包含。</li>\n\t<li><code>0 &lt;= initialBoxes.length&nbsp;&lt;= status.length</code></li>\n\t<li><code>0 &lt;= initialBoxes[i] &lt; status.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1299将每个元素替换为右侧最大元素",
        "hardRate": "EASY",
        "passRate": "77.03%",
        "problemsUrl": "https://leetcode.cn/problems/replace-elements-with-greatest-element-on-right-side/",
        "solutionsUrl": "https://leetcode.cn/problems/replace-elements-with-greatest-element-on-right-side/solution",
        "problemsDesc": "<p>给你一个数组 <code>arr</code> ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 <code>-1</code> 替换。</p>\n\n<p>完成所有替换操作后，请你返回这个数组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [17,18,5,4,6,1]\n<strong>输出：</strong>[18,6,6,6,1,-1]\n<strong>解释：</strong>\n- 下标 0 的元素 --> 右侧最大元素是下标 1 的元素 (18)\n- 下标 1 的元素 --> 右侧最大元素是下标 4 的元素 (6)\n- 下标 2 的元素 --> 右侧最大元素是下标 4 的元素 (6)\n- 下标 3 的元素 --> 右侧最大元素是下标 4 的元素 (6)\n- 下标 4 的元素 --> 右侧最大元素是下标 5 的元素 (1)\n- 下标 5 的元素 --> 右侧没有其他元素，替换为 -1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [400]\n<strong>输出：</strong>[-1]\n<strong>解释：</strong>下标<strong> </strong>0 的元素右侧没有其他元素。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= arr.length <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= arr[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1300转变数组后最接近目标值的数组和",
        "hardRate": "MEDIUM",
        "passRate": "46.78%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-mutated-array-closest-to-target/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-mutated-array-closest-to-target/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code> 和一个目标值&nbsp;<code>target</code> ，请你返回一个整数&nbsp;<code>value</code>&nbsp;，使得将数组中所有大于&nbsp;<code>value</code> 的值变成&nbsp;<code>value</code> 后，数组的和最接近&nbsp; <code>target</code>&nbsp;（最接近表示两者之差的绝对值最小）。</p>\n\n<p>如果有多种使得和最接近&nbsp;<code>target</code>&nbsp;的方案，请你返回这些整数中的最小值。</p>\n\n<p>请注意，答案不一定是&nbsp;<code>arr</code> 中的数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [4,9,3], target = 10\n<strong>输出：</strong>3\n<strong>解释：</strong>当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,3,5], target = 10\n<strong>输出：</strong>5\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [60864,25176,27249,21296,20204], target = 56803\n<strong>输出：</strong>11361\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10^4</code></li>\n\t<li><code>1 &lt;= arr[i], target &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1301最大得分的路径数目",
        "hardRate": "HARD",
        "passRate": "37.76%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-paths-with-max-score/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-paths-with-max-score/solution",
        "problemsDesc": "<p>给你一个正方形字符数组&nbsp;<code>board</code>&nbsp;，你从数组最右下方的字符&nbsp;<code>&#39;S&#39;</code>&nbsp;出发。</p>\n\n<p>你的目标是到达数组最左上角的字符&nbsp;<code>&#39;E&#39;</code> ，数组剩余的部分为数字字符&nbsp;<code>1, 2, ..., 9</code>&nbsp;或者障碍 <code>&#39;X&#39;</code>。在每一步移动中，你可以向上、向左或者左上方移动，可以移动的前提是到达的格子没有障碍。</p>\n\n<p>一条路径的 「得分」 定义为：路径上所有数字的和。</p>\n\n<p>请你返回一个列表，包含两个整数：第一个整数是 「得分」 的最大值，第二个整数是得到最大得分的方案数，请把结果对&nbsp;<strong><code>10^9 + 7</code></strong> <strong>取余</strong>。</p>\n\n<p>如果没有任何路径可以到达终点，请返回&nbsp;<code>[0, 0]</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = [&quot;E23&quot;,&quot;2X2&quot;,&quot;12S&quot;]\n<strong>输出：</strong>[7,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = [&quot;E12&quot;,&quot;1X1&quot;,&quot;21S&quot;]\n<strong>输出：</strong>[4,2]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = [&quot;E11&quot;,&quot;XXX&quot;,&quot;11S&quot;]\n<strong>输出：</strong>[0,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= board.length == board[i].length &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1302层数最深叶子节点的和",
        "hardRate": "MEDIUM",
        "passRate": "85.51%",
        "problemsUrl": "https://leetcode.cn/problems/deepest-leaves-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/deepest-leaves-sum/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点 <code>root</code> ，请你返回 <strong>层数最深的叶子节点的和</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/28/1483_ex1.png\" style=\"height: 265px; width: 273px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,5,null,6,7,null,null,null,null,8]\n<strong>输出：</strong>15\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]\n<strong>输出：</strong>19\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[1, 10<sup>4</sup>]</code> 之间。</li>\n\t<li><code>1 <= Node.val <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1303求团队人数",
        "hardRate": "EASY",
        "passRate": "82.52%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-team-size/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-team-size/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1304和为零的 N 个不同整数",
        "hardRate": "EASY",
        "passRate": "70.33%",
        "problemsUrl": "https://leetcode.cn/problems/find-n-unique-integers-sum-up-to-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/find-n-unique-integers-sum-up-to-zero/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>，请你返回 <strong>任意&nbsp;</strong>一个由 <code>n</code>&nbsp;个 <strong>各不相同&nbsp;</strong>的整数组成的数组，并且这 <code>n</code> 个数相加和为 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 5\n<strong>输出：</strong>[-7,-1,1,3,4]\n<strong>解释：</strong>这些数组也是正确的 [-5,-1,1,2,3]，[-3,-1,2,-2,4]。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 3\n<strong>输出：</strong>[-1,0,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>[0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1305两棵二叉搜索树中的所有元素",
        "hardRate": "MEDIUM",
        "passRate": "78.05%",
        "problemsUrl": "https://leetcode.cn/problems/all-elements-in-two-binary-search-trees/",
        "solutionsUrl": "https://leetcode.cn/problems/all-elements-in-two-binary-search-trees/solution",
        "problemsDesc": "<p>给你&nbsp;<code>root1</code> 和 <code>root2</code>&nbsp;这两棵二叉搜索树。请你返回一个列表，其中包含&nbsp;<strong>两棵树&nbsp;</strong>中的所有整数并按 <strong>升序</strong> 排序。.</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/29/q2-e1.png\" /></p>\n\n<pre>\n<strong>输入：</strong>root1 = [2,1,4], root2 = [1,0,3]\n<strong>输出：</strong>[0,1,1,2,3,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/29/q2-e5-.png\" /></p>\n\n<pre>\n<strong>输入：</strong>root1 = [1,null,8], root2 = [8,1]\n<strong>输出：</strong>[1,1,8,8]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每棵树的节点数在&nbsp;<code>[0, 5000]</code> 范围内</li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1306跳跃游戏 III",
        "hardRate": "MEDIUM",
        "passRate": "58.18%",
        "problemsUrl": "https://leetcode.cn/problems/jump-game-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/jump-game-iii/solution",
        "problemsDesc": "<p>这里有一个非负整数数组&nbsp;<code>arr</code>，你最开始位于该数组的起始下标&nbsp;<code>start</code>&nbsp;处。当你位于下标&nbsp;<code>i</code>&nbsp;处时，你可以跳到&nbsp;<code>i + arr[i]</code> 或者 <code>i - arr[i]</code>。</p>\n\n<p>请你判断自己是否能够跳到对应元素值为 0 的 <strong>任一</strong> 下标处。</p>\n\n<p>注意，不管是什么情况下，你都无法跳到数组之外。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [4,2,3,0,3,1,2], start = 5\n<strong>输出：</strong>true\n<strong>解释：</strong>\n到达值为 0 的下标 3 有以下可能方案： \n下标 5 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3 \n下标 5 -&gt; 下标 6 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [4,2,3,0,3,1,2], start = 0\n<strong>输出：</strong>true \n<strong>解释：\n</strong>到达值为 0 的下标 3 有以下可能方案： \n下标 0 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,0,2,1,2], start = 2\n<strong>输出：</strong>false\n<strong>解释：</strong>无法到达值为 0 的下标 1 处。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 5 * 10^4</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;&nbsp;arr.length</code></li>\n\t<li><code>0 &lt;= start &lt; arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1307口算难题",
        "hardRate": "HARD",
        "passRate": "34.98%",
        "problemsUrl": "https://leetcode.cn/problems/verbal-arithmetic-puzzle/",
        "solutionsUrl": "https://leetcode.cn/problems/verbal-arithmetic-puzzle/solution",
        "problemsDesc": "<p>给你一个方程，左边用&nbsp;<code>words</code>&nbsp;表示，右边用&nbsp;<code>result</code> 表示。</p>\n\n<p>你需要根据以下规则检查方程是否可解：</p>\n\n<ul>\n\t<li>每个字符都会被解码成一位数字（0 - 9）。</li>\n\t<li>每对不同的字符必须映射到不同的数字。</li>\n\t<li>每个 <code>words[i]</code> 和 <code>result</code>&nbsp;都会被解码成一个没有前导零的数字。</li>\n\t<li>左侧数字之和（<code>words</code>）等于右侧数字（<code>result</code>）。&nbsp;</li>\n</ul>\n\n<p>如果方程可解，返回&nbsp;<code>True</code>，否则返回&nbsp;<code>False</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;SEND&quot;,&quot;MORE&quot;], result = &quot;MONEY&quot;\n<strong>输出：</strong>true\n<strong>解释：</strong>映射 &#39;S&#39;-&gt; 9, &#39;E&#39;-&gt;5, &#39;N&#39;-&gt;6, &#39;D&#39;-&gt;7, &#39;M&#39;-&gt;1, &#39;O&#39;-&gt;0, &#39;R&#39;-&gt;8, &#39;Y&#39;-&gt;&#39;2&#39;\n所以 &quot;SEND&quot; + &quot;MORE&quot; = &quot;MONEY&quot; ,  9567 + 1085 = 10652</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;SIX&quot;,&quot;SEVEN&quot;,&quot;SEVEN&quot;], result = &quot;TWENTY&quot;\n<strong>输出：</strong>true\n<strong>解释：</strong>映射 &#39;S&#39;-&gt; 6, &#39;I&#39;-&gt;5, &#39;X&#39;-&gt;0, &#39;E&#39;-&gt;8, &#39;V&#39;-&gt;7, &#39;N&#39;-&gt;2, &#39;T&#39;-&gt;1, &#39;W&#39;-&gt;&#39;3&#39;, &#39;Y&#39;-&gt;4\n所以 &quot;SIX&quot; + &quot;SEVEN&quot; + &quot;SEVEN&quot; = &quot;TWENTY&quot; ,  650 + 68782 + 68782 = 138214</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;THIS&quot;,&quot;IS&quot;,&quot;TOO&quot;], result = &quot;FUNNY&quot;\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;LEET&quot;,&quot;CODE&quot;], result = &quot;POINT&quot;\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= words.length &lt;= 5</code></li>\n\t<li><code>1 &lt;= words[i].length,&nbsp;results.length&nbsp;&lt;= 7</code></li>\n\t<li><code>words[i], result</code>&nbsp;只含有大写英文字母</li>\n\t<li>表达式中使用的不同字符数最大为&nbsp;10</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1308不同性别每日分数总计",
        "hardRate": "MEDIUM",
        "passRate": "73.57%",
        "problemsUrl": "https://leetcode.cn/problems/running-total-for-different-genders/",
        "solutionsUrl": "https://leetcode.cn/problems/running-total-for-different-genders/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1309解码字母到整数映射",
        "hardRate": "EASY",
        "passRate": "76.80%",
        "problemsUrl": "https://leetcode.cn/problems/decrypt-string-from-alphabet-to-integer-mapping/",
        "solutionsUrl": "https://leetcode.cn/problems/decrypt-string-from-alphabet-to-integer-mapping/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>，它由数字（<code>'0'</code> - <code>'9'</code>）和&nbsp;<code>'#'</code>&nbsp;组成。我们希望按下述规则将&nbsp;<code>s</code>&nbsp;映射为一些小写英文字符：</p>\n\n<ul>\n\t<li>字符（<code>'a'</code> - <code>'i'</code>）分别用（<code>'1'</code> -&nbsp;<code>'9'</code>）表示。</li>\n\t<li>字符（<code>'j'</code> - <code>'z'</code>）分别用（<code>'10#'</code>&nbsp;-&nbsp;<code>'26#'</code>）表示。&nbsp;</li>\n</ul>\n\n<p>返回映射之后形成的新字符串。</p>\n\n<p>题目数据保证映射始终唯一。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"10#11#12\"\n<strong>输出：</strong>\"jkab\"\n<strong>解释：</strong>\"j\" -&gt; \"10#\" , \"k\" -&gt; \"11#\" , \"a\" -&gt; \"1\" , \"b\" -&gt; \"2\".\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1326#\"\n<strong>输出：</strong>\"acz\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i]</code> 只包含数字（<code>'0'</code>-<code>'9'</code>）和&nbsp;<code>'#'</code>&nbsp;字符。</li>\n\t<li><code>s</code>&nbsp;是映射始终存在的有效字符串。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1310子数组异或查询",
        "hardRate": "MEDIUM",
        "passRate": "72.02%",
        "problemsUrl": "https://leetcode.cn/problems/xor-queries-of-a-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/xor-queries-of-a-subarray/solution",
        "problemsDesc": "<p>有一个正整数数组 <code>arr</code>，现给你一个对应的查询数组 <code>queries</code>，其中 <code>queries[i] = [L<sub>i, </sub>R<sub>i</sub>]</code>。</p>\n\n<p>对于每个查询 <code>i</code>，请你计算从 <code>L<sub>i</sub></code> 到 <code>R<sub>i</sub></code> 的 <strong>XOR</strong> 值（即 <code>arr[L<sub>i</sub>] <strong>xor</strong> arr[L<sub>i</sub>+1] <strong>xor</strong> ... <strong>xor</strong> arr[R<sub>i</sub>]</code>）作为本次查询的结果。</p>\n\n<p>并返回一个包含给定查询 <code>queries</code> 所有结果的数组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]\n<strong>输出：</strong>[2,7,14,8] \n<strong>解释：</strong>\n数组中元素的二进制表示形式是：\n1 = 0001 \n3 = 0011 \n4 = 0100 \n8 = 1000 \n查询的 XOR 值为：\n[0,1] = 1 xor 3 = 2 \n[1,2] = 3 xor 4 = 7 \n[0,3] = 1 xor 3 xor 4 xor 8 = 14 \n[3,3] = 8\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]\n<strong>输出：</strong>[8,0,4,4]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= arr.length <= 3 * 10^4</code></li>\n\t<li><code>1 <= arr[i] <= 10^9</code></li>\n\t<li><code>1 <= queries.length <= 3 * 10^4</code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>0 <= queries[i][0] <= queries[i][1] < arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1311获取你好友已观看的视频",
        "hardRate": "MEDIUM",
        "passRate": "40.05%",
        "problemsUrl": "https://leetcode.cn/problems/get-watched-videos-by-your-friends/",
        "solutionsUrl": "https://leetcode.cn/problems/get-watched-videos-by-your-friends/solution",
        "problemsDesc": "<p>有&nbsp;<code>n</code> 个人，每个人都有一个&nbsp; <code>0</code>&nbsp;到&nbsp;<code>n-1</code>&nbsp;的唯一&nbsp;<em>id</em>&nbsp;。</p>\n\n<p>给你数组 <code>watchedVideos</code>&nbsp; 和&nbsp;<code>friends</code>&nbsp;，其中&nbsp;<code>watchedVideos[i]</code>&nbsp; 和&nbsp;<code>friends[i]</code>&nbsp;分别表示&nbsp;<code>id = i</code>&nbsp;的人观看过的视频列表和他的好友列表。</p>\n\n<p>Level&nbsp;<strong>1</strong>&nbsp;的视频包含所有你好友观看过的视频，level&nbsp;<strong>2</strong>&nbsp;的视频包含所有你好友的好友观看过的视频，以此类推。一般的，Level 为 <strong>k</strong>&nbsp;的视频包含所有从你出发，最短距离为&nbsp;<strong>k</strong>&nbsp;的好友观看过的视频。</p>\n\n<p>给定你的&nbsp;<code>id</code>&nbsp; 和一个&nbsp;<code>level</code>&nbsp;值，请你找出所有指定 <code>level</code> 的视频，并将它们按观看频率升序返回。如果有频率相同的视频，请将它们按字母顺序从小到大排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/03/leetcode_friends_1.png\" style=\"height: 179px; width: 129px;\"></strong></p>\n\n<pre><strong>输入：</strong>watchedVideos = [[&quot;A&quot;,&quot;B&quot;],[&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1\n<strong>输出：</strong>[&quot;B&quot;,&quot;C&quot;] \n<strong>解释：</strong>\n你的 id 为 0（绿色），你的朋友包括（黄色）：\nid 为 1 -&gt; watchedVideos = [&quot;C&quot;]&nbsp;\nid 为 2 -&gt; watchedVideos = [&quot;B&quot;,&quot;C&quot;]&nbsp;\n你朋友观看过视频的频率为：\nB -&gt; 1&nbsp;\nC -&gt; 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/03/leetcode_friends_2.png\" style=\"height: 179px; width: 129px;\"></strong></p>\n\n<pre><strong>输入：</strong>watchedVideos = [[&quot;A&quot;,&quot;B&quot;],[&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2\n<strong>输出：</strong>[&quot;D&quot;]\n<strong>解释：</strong>\n你的 id 为 0（绿色），你朋友的朋友只有一个人，他的 id 为 3（黄色）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == watchedVideos.length ==&nbsp;friends.length</code></li>\n\t<li><code>2 &lt;= n&nbsp;&lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;watchedVideos[i].length &lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;watchedVideos[i][j].length &lt;= 8</code></li>\n\t<li><code>0 &lt;= friends[i].length &lt; n</code></li>\n\t<li><code>0 &lt;= friends[i][j]&nbsp;&lt; n</code></li>\n\t<li><code>0 &lt;= id &lt; n</code></li>\n\t<li><code>1 &lt;= level &lt; n</code></li>\n\t<li>如果&nbsp;<code>friends[i]</code> 包含&nbsp;<code>j</code>&nbsp;，那么&nbsp;<code>friends[j]</code> 包含&nbsp;<code>i</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1312让字符串成为回文串的最少插入次数",
        "hardRate": "HARD",
        "passRate": "69.11%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，每一次操作你都可以在字符串的任意位置插入任意字符。</p>\n\n<p>请你返回让&nbsp;<code>s</code>&nbsp;成为回文串的&nbsp;<strong>最少操作次数</strong>&nbsp;。</p>\n\n<p>「回文串」是正读和反读都相同的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"zzazz\"\n<strong>输出：</strong>0\n<strong>解释：</strong>字符串 \"zzazz\" 已经是回文串了，所以不需要做任何插入操作。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"mbadm\"\n<strong>输出：</strong>2\n<strong>解释：</strong>字符串可变为 \"mbdadbm\" 或者 \"mdbabdm\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"leetcode\"\n<strong>输出：</strong>5\n<strong>解释：</strong>插入 5 个字符后字符串变为 \"leetcodocteel\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>s</code>&nbsp;中所有字符都是小写字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1313解压缩编码列表",
        "hardRate": "EASY",
        "passRate": "83.25%",
        "problemsUrl": "https://leetcode.cn/problems/decompress-run-length-encoded-list/",
        "solutionsUrl": "https://leetcode.cn/problems/decompress-run-length-encoded-list/solution",
        "problemsDesc": "<p>给你一个以行程长度编码压缩的整数列表 <code>nums</code> 。</p>\n\n<p>考虑每对相邻的两个元素 <code>[freq, val] = [nums[2*i], nums[2*i+1]]</code> （其中 <code>i >= 0</code> ），每一对都表示解压后子列表中有 <code>freq</code> 个值为 <code>val</code> 的元素，你需要从左到右连接所有子列表以生成解压后的列表。</p>\n\n<p>请你返回解压后的列表。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>[2,4,4,4]\n<strong>解释：</strong>第一对 [1,2] 代表着 2 的出现频次为 1，所以生成数组 [2]。\n第二对 [3,4] 代表着 4 的出现频次为 3，所以生成数组 [4,4,4]。\n最后将它们串联到一起 [2] + [4,4,4] = [2,4,4,4]。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,2,3]\n<strong>输出：</strong>[1,3,3]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= nums.length <= 100</code></li>\n\t<li><code>nums.length % 2 == 0</code></li>\n\t<li><code>1 <= nums[i] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1314矩阵区域和",
        "hardRate": "MEDIUM",
        "passRate": "75.54%",
        "problemsUrl": "https://leetcode.cn/problems/matrix-block-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/matrix-block-sum/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的矩阵 <code>mat</code> 和一个整数 <code>k</code> ，请你返回一个矩阵 <code>answer</code> ，其中每个 <code>answer[i][j]</code> 是所有满足下述条件的元素 <code>mat[r][c]</code> 的和： </p>\n\n<ul>\n\t<li><code>i - k <= r <= i + k, </code></li>\n\t<li><code>j - k <= c <= j + k</code> 且</li>\n\t<li><code>(r, c)</code> 在矩阵内。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1\n<strong>输出：</strong>[[12,21,16],[27,45,33],[24,39,28]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2\n<strong>输出：</strong>[[45,45,45],[45,45,45],[45,45,45]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 <= m, n, k <= 100</code></li>\n\t<li><code>1 <= mat[i][j] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1315祖父节点值为偶数的节点和",
        "hardRate": "MEDIUM",
        "passRate": "81.61%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-nodes-with-even-valued-grandparent/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-nodes-with-even-valued-grandparent/solution",
        "problemsDesc": "<p>给你一棵二叉树，请你返回满足以下条件的所有节点的值之和：</p>\n\n<ul>\n\t<li>该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）</li>\n</ul>\n\n<p>如果不存在祖父节点值为偶数的节点，那么返回&nbsp;<code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/10/1473_ex1.png\" style=\"height: 214px; width: 350px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]\n<strong>输出：</strong>18\n<strong>解释：</strong>图中红色节点的祖父节点的值为偶数，蓝色节点为这些红色节点的祖父节点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在&nbsp;<code>1</code> 到&nbsp;<code>10^4</code>&nbsp;之间。</li>\n\t<li>每个节点的值在&nbsp;<code>1</code> 到&nbsp;<code>100</code> 之间。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1316不同的循环子字符串",
        "hardRate": "HARD",
        "passRate": "48.35%",
        "problemsUrl": "https://leetcode.cn/problems/distinct-echo-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/distinct-echo-substrings/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>text</code> ，请你返回满足下述条件的&nbsp;<strong>不同</strong> 非空子字符串的数目：</p>\n\n<ul>\n\t<li>可以写成某个字符串与其自身相连接的形式（即，可以写为 <code>a&nbsp;+ a</code>，其中 <code>a</code> 是某个字符串）。</li>\n</ul>\n\n<p>例如，<code>abcabc</code>&nbsp;就是&nbsp;<code>abc</code>&nbsp;和它自身连接形成的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;abcabcabc&quot;\n<strong>输出：</strong>3\n<strong>解释：</strong>3 个子字符串分别为 &quot;abcabc&quot;，&quot;bcabca&quot; 和 &quot;cabcab&quot; 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;leetcodeleetcode&quot;\n<strong>输出：</strong>2\n<strong>解释：</strong>2 个子字符串为 &quot;ee&quot; 和 &quot;leetcodeleetcode&quot; 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 2000</code></li>\n\t<li><code>text</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1317将整数转换为两个无零整数的和",
        "hardRate": "EASY",
        "passRate": "61.87%",
        "problemsUrl": "https://leetcode.cn/problems/convert-integer-to-the-sum-of-two-no-zero-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-integer-to-the-sum-of-two-no-zero-integers/solution",
        "problemsDesc": "<p>「无零整数」是十进制表示中 <strong>不含任何 0</strong>&nbsp;的正整数。</p>\n\n<p>给你一个整数&nbsp;<code>n</code>，请你返回一个 <strong>由两个整数组成的列表</strong> <code>[A, B]</code>，满足：</p>\n\n<ul>\n\t<li><code>A</code> 和 <code>B</code>&nbsp;都是无零整数</li>\n\t<li><code>A + B = n</code></li>\n</ul>\n\n<p>题目数据保证至少有一个有效的解决方案。</p>\n\n<p>如果存在多个有效解决方案，你可以返回其中任意一个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>[1,1]\n<strong>解释：</strong>A = 1, B = 1. A + B = n 并且 A 和 B 的十进制表示形式都不包含任何 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 11\n<strong>输出：</strong>[2,9]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 10000\n<strong>输出：</strong>[1,9999]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 69\n<strong>输出：</strong>[1,68]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>n = 1010\n<strong>输出：</strong>[11,999]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1318或运算的最小翻转次数",
        "hardRate": "MEDIUM",
        "passRate": "66.72%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-flips-to-make-a-or-b-equal-to-c/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-flips-to-make-a-or-b-equal-to-c/solution",
        "problemsDesc": "<p>给你三个正整数&nbsp;<code>a</code>、<code>b</code> 和 <code>c</code>。</p>\n\n<p>你可以对 <code>a</code> 和 <code>b</code>&nbsp;的二进制表示进行位翻转操作，返回能够使按位或运算&nbsp; &nbsp;<code>a</code> OR <code>b</code> == <code>c</code>&nbsp;&nbsp;成立的最小翻转次数。</p>\n\n<p>「位翻转操作」是指将一个数的二进制表示任何单个位上的 1 变成 0 或者 0 变成 1 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_3_1676.png\" style=\"height: 87px; width: 260px;\"></p>\n\n<pre><strong>输入：</strong>a = 2, b = 6, c = 5\n<strong>输出：</strong>3\n<strong>解释：</strong>翻转后 a = 1 , b = 4 , c = 5 使得 <code>a</code> OR <code>b</code> == <code>c</code></pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>a = 4, b = 2, c = 7\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>a = 1, b = 2, c = 3\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a &lt;= 10^9</code></li>\n\t<li><code>1 &lt;= b&nbsp;&lt;= 10^9</code></li>\n\t<li><code>1 &lt;= c&nbsp;&lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1319连通网络的操作次数",
        "hardRate": "MEDIUM",
        "passRate": "62.35%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-operations-to-make-network-connected/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-operations-to-make-network-connected/solution",
        "problemsDesc": "<p>用以太网线缆将&nbsp;<code>n</code>&nbsp;台计算机连接成一个网络，计算机的编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n-1</code>。线缆用&nbsp;<code>connections</code>&nbsp;表示，其中&nbsp;<code>connections[i] = [a, b]</code>&nbsp;连接了计算机&nbsp;<code>a</code>&nbsp;和&nbsp;<code>b</code>。</p>\n\n<p>网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。</p>\n\n<p>给你这个计算机网络的初始布线&nbsp;<code>connections</code>，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回&nbsp;-1 。&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_1_1677.png\" style=\"height: 167px; width: 570px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 4, connections = [[0,1],[0,2],[1,2]]\n<strong>输出：</strong>1\n<strong>解释：</strong>拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_2_1677.png\" style=\"height: 175px; width: 660px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>线缆数量不足。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 5, connections = [[0,1],[0,2],[3,4],[2,3]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= connections.length &lt;= min(n*(n-1)/2, 10^5)</code></li>\n\t<li><code>connections[i].length == 2</code></li>\n\t<li><code>0 &lt;= connections[i][0], connections[i][1]&nbsp;&lt; n</code></li>\n\t<li><code>connections[i][0] != connections[i][1]</code></li>\n\t<li>没有重复的连接。</li>\n\t<li>两台计算机不会通过多条线缆连接。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1320二指输入的的最小距离",
        "hardRate": "HARD",
        "passRate": "60.67%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-distance-to-type-a-word-using-two-fingers/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-distance-to-type-a-word-using-two-fingers/solution",
        "problemsDesc": "<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/leetcode_keyboard.png\" /></p>\n\n<p>二指输入法定制键盘在 <strong>X-Y</strong> 平面上的布局如上图所示，其中每个大写英文字母都位于某个坐标处。</p>\n\n<ul>\n\t<li>例如字母&nbsp;<strong>A</strong>&nbsp;位于坐标&nbsp;<strong>(0,0)</strong>，字母&nbsp;<strong>B</strong>&nbsp;位于坐标&nbsp;<strong>(0,1)</strong>，字母&nbsp;<strong>P</strong>&nbsp;位于坐标&nbsp;<strong>(2,3)</strong>&nbsp;且字母 <strong>Z</strong>&nbsp;位于坐标&nbsp;<strong>(4,1)</strong>。</li>\n</ul>\n\n<p>给你一个待输入字符串&nbsp;<code>word</code>，请你计算并返回在仅使用两根手指的情况下，键入该字符串需要的最小移动总距离。</p>\n\n<p>坐标<code>&nbsp;<strong>(x<sub>1</sub>,y<sub>1</sub>)</strong> </code>和 <code><strong>(x<sub>2</sub>,y<sub>2</sub>)</strong></code> 之间的 <strong>距离</strong> 是&nbsp;<code><strong>|x<sub>1</sub> - x<sub>2</sub>| + |y<sub>1</sub> - y<sub>2</sub>|</strong></code>。&nbsp;</p>\n\n<p><strong>注意</strong>，两根手指的起始位置是零代价的，不计入移动总距离。你的两根手指的起始位置也不必从首字母或者前两个字母开始。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"CAKE\"\n<strong>输出：</strong>3\n<strong>解释： \n</strong>使用两根手指输入 \"CAKE\" 的最佳方案之一是： \n手指 1 在字母 'C' 上 -&gt; 移动距离 = 0 \n手指 1 在字母 'A' 上 -&gt; 移动距离 = 从字母 'C' 到字母 'A' 的距离 = 2 \n手指 2 在字母 'K' 上 -&gt; 移动距离 = 0 \n手指 2 在字母 'E' 上 -&gt; 移动距离 = 从字母 'K' 到字母 'E' 的距离  = 1 \n总距离 = 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"HAPPY\"\n<strong>输出：</strong>6\n<strong>解释： </strong>\n使用两根手指输入 \"HAPPY\" 的最佳方案之一是：\n手指 1 在字母 'H' 上 -&gt; 移动距离 = 0\n手指 1 在字母 'A' 上 -&gt; 移动距离 = 从字母 'H' 到字母 'A' 的距离 = 2\n手指 2 在字母 'P' 上 -&gt; 移动距离 = 0\n手指 2 在字母 'P' 上 -&gt; 移动距离 = 从字母 'P' 到字母 'P' 的距离 = 0\n手指 1 在字母 'Y' 上 -&gt; 移动距离 = 从字母 'A' 到字母 'Y' 的距离 = 4\n总距离 = 6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= word.length &lt;= 300</code></li>\n\t<li>每个 <code>word[i]</code>&nbsp;都是一个大写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1321餐馆营业额变化增长",
        "hardRate": "MEDIUM",
        "passRate": "61.85%",
        "problemsUrl": "https://leetcode.cn/problems/restaurant-growth/",
        "solutionsUrl": "https://leetcode.cn/problems/restaurant-growth/solution",
        "problemsDesc": "<p>表: <code>Customer</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| customer_id   | int     |\n| name          | varchar |\n| visited_on    | date    |\n| amount        | int     |\n+---------------+---------+\n(customer_id, visited_on) 是该表的主键。\n该表包含一家餐馆的顾客交易数据。\nvisited_on 表示 (customer_id) 的顾客在 visited_on 那天访问了餐馆。\namount 是一个顾客某一天的消费总额。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>你是餐馆的老板，现在你想分析一下可能的营业额变化增长（每天至少有一位顾客）。</p>\n\n<p>写一条 SQL 查询计算以 7 天（某日期 + 该日期前的 6 天）为一个时间段的顾客消费平均值。<code>average_amount</code>&nbsp;要 <strong>保留两位小数。</strong></p>\n\n<p>查询结果按 <code>visited_on</code> 排序。</p>\n\n<p>查询结果格式的例子如下。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nCustomer 表:\n+-------------+--------------+--------------+-------------+\n| customer_id | name         | visited_on   | amount      |\n+-------------+--------------+--------------+-------------+\n| 1           | Jhon         | 2019-01-01   | 100         |\n| 2           | Daniel       | 2019-01-02   | 110         |\n| 3           | Jade         | 2019-01-03   | 120         |\n| 4           | Khaled       | 2019-01-04   | 130         |\n| 5           | Winston      | 2019-01-05   | 110         | \n| 6           | Elvis        | 2019-01-06   | 140         | \n| 7           | Anna         | 2019-01-07   | 150         |\n| 8           | Maria        | 2019-01-08   | 80          |\n| 9           | Jaze         | 2019-01-09   | 110         | \n| 1           | Jhon         | 2019-01-10   | 130         | \n| 3           | Jade         | 2019-01-10   | 150         | \n+-------------+--------------+--------------+-------------+\n<strong>输出：</strong>\n+--------------+--------------+----------------+\n| visited_on   | amount       | average_amount |\n+--------------+--------------+----------------+\n| 2019-01-07   | 860          | 122.86         |\n| 2019-01-08   | 840          | 120            |\n| 2019-01-09   | 840          | 120            |\n| 2019-01-10   | 1000         | 142.86         |\n+--------------+--------------+----------------+\n<strong>解释：</strong>\n第一个七天消费平均值从 2019-01-01 到 2019-01-07 是restaurant-growth/restaurant-growth/ (100 + 110 + 120 + 130 + 110 + 140 + 150)/7 = 122.86\n第二个七天消费平均值从 2019-01-02 到 2019-01-08 是 (110 + 120 + 130 + 110 + 140 + 150 + 80)/7 = 120\n第三个七天消费平均值从 2019-01-03 到 2019-01-09 是 (120 + 130 + 110 + 140 + 150 + 80 + 110)/7 = 120\n第四个七天消费平均值从 2019-01-04 到 2019-01-10 是 (130 + 110 + 140 + 150 + 80 + 110 + 130 + 150)/7 = 142.86</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1322广告效果",
        "hardRate": "EASY",
        "passRate": "59.55%",
        "problemsUrl": "https://leetcode.cn/problems/ads-performance/",
        "solutionsUrl": "https://leetcode.cn/problems/ads-performance/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 13236 和 9 组成的最大数字",
        "hardRate": "EASY",
        "passRate": "74.97%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-69-number/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-69-number/solution",
        "problemsDesc": "<p>给你一个仅由数字 6 和 9 组成的正整数&nbsp;<code>num</code>。</p>\n\n<p>你最多只能翻转一位数字，将 6 变成&nbsp;9，或者把&nbsp;9 变成&nbsp;6 。</p>\n\n<p>请返回你可以得到的最大数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 9669\n<strong>输出：</strong>9969\n<strong>解释：</strong>\n改变第一位数字可以得到 6669 。\n改变第二位数字可以得到 9969 。\n改变第三位数字可以得到 9699 。\n改变第四位数字可以得到 9666 。\n其中最大的数字是 9969 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 9996\n<strong>输出：</strong>9999\n<strong>解释：</strong>将最后一位从 6 变到 9，其结果 9999 是最大的数。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = 9999\n<strong>输出：</strong>9999\n<strong>解释：</strong>无需改变就已经是最大的数字了。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10^4</code></li>\n\t<li><code>num</code>&nbsp;每一位上的数字都是 6 或者&nbsp;9 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1324竖直打印单词",
        "hardRate": "MEDIUM",
        "passRate": "59.24%",
        "problemsUrl": "https://leetcode.cn/problems/print-words-vertically/",
        "solutionsUrl": "https://leetcode.cn/problems/print-words-vertically/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>。请你按照单词在 <code>s</code> 中的出现顺序将它们全部竖直返回。<br>\n单词应该以字符串列表的形式返回，必要时用空格补位，但输出尾部的空格需要删除（不允许尾随空格）。<br>\n每个单词只能放在一列上，每一列中也只能有一个单词。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;HOW ARE YOU&quot;\n<strong>输出：</strong>[&quot;HAY&quot;,&quot;ORO&quot;,&quot;WEU&quot;]\n<strong>解释：</strong>每个单词都应该竖直打印。 \n &quot;HAY&quot;\n&nbsp;&quot;ORO&quot;\n&nbsp;&quot;WEU&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;TO BE OR NOT TO BE&quot;\n<strong>输出：</strong>[&quot;TBONTB&quot;,&quot;OEROOE&quot;,&quot;   T&quot;]\n<strong>解释：</strong>题目允许使用空格补位，但不允许输出末尾出现空格。\n&quot;TBONTB&quot;\n&quot;OEROOE&quot;\n&quot;   T&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;CONTEST IS COMING&quot;\n<strong>输出：</strong>[&quot;CIC&quot;,&quot;OSO&quot;,&quot;N M&quot;,&quot;T I&quot;,&quot;E N&quot;,&quot;S G&quot;,&quot;T&quot;]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 200</code></li>\n\t<li><code>s</code>&nbsp;仅含大写英文字母。</li>\n\t<li>题目数据保证两个单词之间只有一个空格。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1325删除给定值的叶子节点",
        "hardRate": "MEDIUM",
        "passRate": "73.30%",
        "problemsUrl": "https://leetcode.cn/problems/delete-leaves-with-a-given-value/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-leaves-with-a-given-value/solution",
        "problemsDesc": "<p>给你一棵以&nbsp;<code>root</code>&nbsp;为根的二叉树和一个整数&nbsp;<code>target</code>&nbsp;，请你删除所有值为&nbsp;<code>target</code> 的&nbsp;<strong>叶子节点</strong> 。</p>\n\n<p>注意，一旦删除值为&nbsp;<code>target</code>&nbsp;的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是&nbsp;<code>target</code> ，那么这个节点也应该被删除。</p>\n\n<p>也就是说，你需要重复此过程直到不能继续删除。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/16/sample_1_1684.png\" style=\"height: 120px; width: 550px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [1,2,3,2,null,2,4], target = 2\n<strong>输出：</strong>[1,null,3,null,4]\n<strong>解释：\n</strong>上面左边的图中，绿色节点为叶子节点，且它们的值与 target 相同（同为 2 ），它们会被删除，得到中间的图。\n有一个新的节点变成了叶子节点且它的值与 target 相同，所以将再次进行删除，从而得到最右边的图。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/16/sample_2_1684.png\" style=\"height: 120px; width: 300px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [1,3,3,3,2], target = 3\n<strong>输出：</strong>[1,3,null,null,2]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/16/sample_3_1684.png\" style=\"width: 450px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [1,2,null,2,null,2], target = 2\n<strong>输出：</strong>[1]\n<strong>解释：</strong>每一步都删除一个绿色的叶子节点（值为 2）。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>root = [1,1,1], target = 1\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>root = [1,2,3], target = 1\n<strong>输出：</strong>[1,2,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target&nbsp;&lt;= 1000</code></li>\n\t<li>每一棵树最多有 <code>3000</code> 个节点。</li>\n\t<li>每一个节点值的范围是&nbsp;<code>[1, 1000]</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1326灌溉花园的最少水龙头数目",
        "hardRate": "HARD",
        "passRate": "54.17%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/solution",
        "problemsDesc": "<p>在 x 轴上有一个一维的花园。花园长度为&nbsp;<code>n</code>，从点&nbsp;<code>0</code>&nbsp;开始，到点&nbsp;<code>n</code>&nbsp;结束。</p>\n\n<p>花园里总共有&nbsp;<code>n + 1</code> 个水龙头，分别位于&nbsp;<code>[0, 1, ..., n]</code> 。</p>\n\n<p>给你一个整数&nbsp;<code>n</code>&nbsp;和一个长度为&nbsp;<code>n + 1</code> 的整数数组&nbsp;<code>ranges</code>&nbsp;，其中&nbsp;<code>ranges[i]</code> （下标从 0 开始）表示：如果打开点&nbsp;<code>i</code>&nbsp;处的水龙头，可以灌溉的区域为&nbsp;<code>[i -&nbsp; ranges[i], i + ranges[i]]</code>&nbsp;。</p>\n\n<p>请你返回可以灌溉整个花园的&nbsp;<strong>最少水龙头数目</strong>&nbsp;。如果花园始终存在无法灌溉到的地方，请你返回&nbsp;<strong>-1</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/19/1685_example_1.png\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 5, ranges = [3,4,1,1,0,0]\n<strong>输出：</strong>1\n<strong>解释：\n</strong>点 0 处的水龙头可以灌溉区间 [-3,3]\n点 1 处的水龙头可以灌溉区间 [-3,5]\n点 2 处的水龙头可以灌溉区间 [1,3]\n点 3 处的水龙头可以灌溉区间 [2,4]\n点 4 处的水龙头可以灌溉区间 [4,4]\n点 5 处的水龙头可以灌溉区间 [5,5]\n只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, ranges = [0,0,0,0]\n<strong>输出：</strong>-1\n<strong>解释：</strong>即使打开所有水龙头，你也无法灌溉整个花园。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>ranges.length == n + 1</code></li>\n\t<li><code>0 &lt;= ranges[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1327列出指定时间段内所有的下单产品",
        "hardRate": "EASY",
        "passRate": "69.48%",
        "problemsUrl": "https://leetcode.cn/problems/list-the-products-ordered-in-a-period/",
        "solutionsUrl": "https://leetcode.cn/problems/list-the-products-ordered-in-a-period/solution",
        "problemsDesc": "<p>表: <code>Products</code></p>\n\n<pre>\n+------------------+---------+\n| Column Name      | Type    |\n+------------------+---------+\n| product_id       | int     |\n| product_name     | varchar |\n| product_category | varchar |\n+------------------+---------+\nproduct_id 是该表主键。\n该表包含该公司产品的数据。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>表: <code>Orders</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| product_id    | int     |\n| order_date    | date    |\n| unit          | int     |\n+---------------+---------+\n该表无主键，可能包含重复行。\nproduct_id 是表单 Products 的外键。\nunit 是在日期 order_date 内下单产品的数目。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一个 SQL 语句，要求获取在 2020 年 2 月份下单的数量不少于 100 的产品的名字和数目。</p>\n\n<p>返回结果表单的 <strong>顺序无要求 </strong>。</p>\n\n<p>查询结果的格式如下。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nProducts 表:\n+-------------+-----------------------+------------------+\n| product_id  | product_name          | product_category |\n+-------------+-----------------------+------------------+\n| 1           | Leetcode Solutions    | Book             |\n| 2           | Jewels of Stringology | Book             |\n| 3           | HP                    | Laptop           |\n| 4           | Lenovo                | Laptop           |\n| 5           | Leetcode Kit          | T-shirt          |\n+-------------+-----------------------+------------------+\nOrders 表:\n+--------------+--------------+----------+\n| product_id   | order_date   | unit     |\n+--------------+--------------+----------+\n| 1            | 2020-02-05   | 60       |\n| 1            | 2020-02-10   | 70       |\n| 2            | 2020-01-18   | 30       |\n| 2            | 2020-02-11   | 80       |\n| 3            | 2020-02-17   | 2        |\n| 3            | 2020-02-24   | 3        |\n| 4            | 2020-03-01   | 20       |\n| 4            | 2020-03-04   | 30       |\n| 4            | 2020-03-04   | 60       |\n| 5            | 2020-02-25   | 50       |\n| 5            | 2020-02-27   | 50       |\n| 5            | 2020-03-01   | 50       |\n+--------------+--------------+----------+\n<strong>输出：</strong>\n+--------------------+---------+\n| product_name       | unit    |\n+--------------------+---------+\n| Leetcode Solutions | 130     |\n| Leetcode Kit       | 100     |\n+--------------------+---------+\n<strong>解释：</strong>\n2020 年 2 月份下单 product_id = 1 的产品的数目总和为 (60 + 70) = 130 。\n2020 年 2 月份下单 product_id = 2 的产品的数目总和为 80 。\n2020 年 2 月份下单 product_id = 3 的产品的数目总和为 (2 + 3) = 5 。\n2020 年 2 月份 product_id = 4 的产品并没有下单。\n2020 年 2 月份下单 product_id = 5 的产品的数目总和为 (50 + 50) = 100 。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1328破坏回文串",
        "hardRate": "MEDIUM",
        "passRate": "47.06%",
        "problemsUrl": "https://leetcode.cn/problems/break-a-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/break-a-palindrome/solution",
        "problemsDesc": "<p>给你一个由小写英文字母组成的回文字符串&nbsp;<code>palindrome</code> ，请你将其中&nbsp;<strong>一个</strong> 字符用任意小写英文字母替换，使得结果字符串的 <strong>字典序最小</strong> ，且&nbsp;<strong>不是</strong>&nbsp;回文串。</p>\n\n<p>请你返回结果字符串。如果无法做到，则返回一个 <strong>空串</strong> 。</p>\n\n<p>如果两个字符串长度相同，那么字符串 <code>a</code> 字典序比字符串 <code>b</code> 小可以这样定义：在 <code>a</code> 和 <code>b</code> 出现不同的第一个位置上，字符串 <code>a</code> 中的字符严格小于 <code>b</code> 中的对应字符。例如，<code>\"abcc”</code> 字典序比 <code>\"abcd\"</code> 小，因为不同的第一个位置是在第四个字符，显然 <code>'c'</code> 比 <code>'d'</code> 小。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>palindrome = \"abccba\"\n<strong>输出：</strong>\"aaccba\"\n<strong>解释：</strong>存在多种方法可以使 \"abccba\" 不是回文，例如 \"<em><strong>z</strong></em>bccba\", \"a<em><strong>a</strong></em>ccba\", 和 \"ab<em><strong>a</strong></em>cba\" 。\n在所有方法中，\"aaccba\" 的字典序最小。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>palindrome = \"a\"\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>不存在替换一个字符使 \"a\" 变成非回文的方法，所以返回空字符串。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= palindrome.length &lt;= 1000</code></li>\n\t<li><code>palindrome</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1329将矩阵按对角线排序",
        "hardRate": "MEDIUM",
        "passRate": "77.83%",
        "problemsUrl": "https://leetcode.cn/problems/sort-the-matrix-diagonally/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-the-matrix-diagonally/solution",
        "problemsDesc": "<p><strong>矩阵对角线</strong> 是一条从矩阵最上面行或者最左侧列中的某个元素开始的对角线，沿右下方向一直到矩阵末尾的元素。例如，矩阵 <code>mat</code> 有 <code>6</code> 行 <code>3</code> 列，从 <code>mat[2][0]</code> 开始的 <strong>矩阵对角线</strong> 将会经过 <code>mat[2][0]</code>、<code>mat[3][1]</code> 和 <code>mat[4][2]</code> 。</p>\n\n<p>给你一个 <code>m * n</code> 的整数矩阵 <code>mat</code> ，请你将同一条 <strong>矩阵对角线 </strong>上的元素按升序排序后，返回排好序的矩阵。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/25/1482_example_1_2.png\" style=\"height: 198px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]\n<strong>输出：</strong>[[1,1,1,1],[1,2,2,2],[1,2,3,3]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]\n<strong>输出：</strong>[[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 <= m, n <= 100</code></li>\n\t<li><code>1 <= mat[i][j] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1330翻转子数组得到最大的数组值",
        "hardRate": "HARD",
        "passRate": "57.71%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-subarray-to-maximize-array-value/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-subarray-to-maximize-array-value/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code> 。「数组值」定义为所有满足&nbsp;<code>0 &lt;= i &lt; nums.length-1</code>&nbsp;的&nbsp;<code>|nums[i]-nums[i+1]|</code>&nbsp;的和。</p>\n\n<p>你可以选择给定数组的任意子数组，并将该子数组翻转。但你只能执行这个操作&nbsp;<strong>一次</strong> 。</p>\n\n<p>请你找到可行的最大 <strong>数组值&nbsp;</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,3,1,5,4]\n<strong>输出：</strong>10\n<strong>解释：</strong>通过翻转子数组 [3,1,5] ，数组变成 [2,5,1,3,4] ，数组值为 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,4,9,24,2,1,10]\n<strong>输出：</strong>68\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3*10^4</code></li>\n\t<li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1331数组序号转换",
        "hardRate": "EASY",
        "passRate": "60.38%",
        "problemsUrl": "https://leetcode.cn/problems/rank-transform-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/rank-transform-of-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code> ，请你将数组中的每个元素替换为它们排序后的序号。</p>\n\n<p>序号代表了一个元素有多大。序号编号的规则如下：</p>\n\n<ul>\n\t<li>序号从 1 开始编号。</li>\n\t<li>一个元素越大，那么序号越大。如果两个元素相等，那么它们的序号相同。</li>\n\t<li>每个数字的序号都应该尽可能地小。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [40,10,20,30]\n<strong>输出：</strong>[4,1,2,3]\n<strong>解释：</strong>40 是最大的元素。 10 是最小的元素。 20 是第二小的数字。 30 是第三小的数字。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [100,100,100]\n<strong>输出：</strong>[1,1,1]\n<strong>解释：</strong>所有元素有相同的序号。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [37,12,28,9,100,56,80,5,12]\n<strong>输出：</strong>[5,3,4,2,8,6,7,1,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1332删除回文子序列",
        "hardRate": "EASY",
        "passRate": "77.75%",
        "problemsUrl": "https://leetcode.cn/problems/remove-palindromic-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-palindromic-subsequences/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>，它仅由字母&nbsp;<code>'a'</code> 和 <code>'b'</code>&nbsp;组成。每一次删除操作都可以从 <code>s</code> 中删除一个回文 <strong>子序列</strong>。</p>\n\n<p>返回删除给定字符串中所有字符（字符串为空）的最小删除次数。</p>\n\n<p>「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。</p>\n\n<p>「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ababa\"\n<strong>输出：</strong>1\n<strong>解释：</strong>字符串本身就是回文序列，只需要删除一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abb\"\n<strong>输出：</strong>2\n<strong>解释：</strong>\"<strong>a</strong>bb\" -&gt; \"<strong>bb</strong>\" -&gt; \"\". \n先删除回文子序列 \"a\"，然后再删除 \"bb\"。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"baabb\"\n<strong>输出：</strong>2\n<strong>解释：</strong>\"<strong>baa</strong>b<strong>b</strong>\" -&gt; \"b\" -&gt; \"\". \n先删除回文子序列 \"baab\"，然后再删除 \"b\"。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> 仅包含字母&nbsp;<code>'a'</code>&nbsp; 和 <code>'b'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1333餐厅过滤器",
        "hardRate": "MEDIUM",
        "passRate": "56.70%",
        "problemsUrl": "https://leetcode.cn/problems/filter-restaurants-by-vegan-friendly-price-and-distance/",
        "solutionsUrl": "https://leetcode.cn/problems/filter-restaurants-by-vegan-friendly-price-and-distance/solution",
        "problemsDesc": "<p>给你一个餐馆信息数组&nbsp;<code>restaurants</code>，其中&nbsp;&nbsp;<code>restaurants[i] = [id<sub>i</sub>, rating<sub>i</sub>, veganFriendly<sub>i</sub>, price<sub>i</sub>, distance<sub>i</sub>]</code>。你必须使用以下三个过滤器来过滤这些餐馆信息。</p>\n\n<p>其中素食者友好过滤器&nbsp;<code>veganFriendly</code>&nbsp;的值可以为 <code>true</code> 或者 <code>false</code>，如果为 <em>true</em>&nbsp;就意味着你应该只包括&nbsp;<code>veganFriendly<sub>i</sub></code>&nbsp;为 true 的餐馆，为&nbsp;<em>false</em>&nbsp;则意味着可以包括任何餐馆。此外，我们还有最大价格&nbsp;<code>maxPrice</code>&nbsp;和最大距离&nbsp;<code>maxDistance</code>&nbsp;两个过滤器，它们分别考虑餐厅的价格因素和距离因素的最大值。</p>\n\n<p>过滤后返回餐馆的 <strong><em>id</em></strong>，按照 <em><strong>rating</strong></em>&nbsp;从高到低排序。如果 <em><strong>rating</strong></em> 相同，那么按 <em><strong>id</strong></em> 从高到低排序。简单起见，&nbsp;<code>veganFriendly<sub>i</sub></code> 和 <code>veganFriendly</code>&nbsp;为&nbsp;<em>true</em>&nbsp;时取值为 <em>1</em>，为 <em>false</em> 时，取值为&nbsp;<em>0 。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, maxDistance = 10\n<strong>输出：</strong>[3,1,5] \n<strong>解释： \n</strong>这些餐馆为：\n餐馆 1 [id=1, rating=4, veganFriendly=1, price=40, distance=10]\n餐馆 2 [id=2, rating=8, veganFriendly=0, price=50, distance=5]\n餐馆 3 [id=3, rating=8, veganFriendly=1, price=30, distance=4]\n餐馆 4 [id=4, rating=10, veganFriendly=0, price=10, distance=3]\n餐馆 5 [id=5, rating=1, veganFriendly=1, price=15, distance=1] \n在按照 veganFriendly = 1, maxPrice = 50 和 maxDistance = 10 进行过滤后，我们得到了餐馆 3, 餐馆 1 和 餐馆 5（按评分从高到低排序）。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 50, maxDistance = 10\n<strong>输出：</strong>[4,3,2,1,5]\n<strong>解释：</strong>餐馆与示例 1 相同，但在 veganFriendly = 0 的过滤条件下，应该考虑所有餐馆。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 30, maxDistance = 3\n<strong>输出：</strong>[4,5]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;restaurants.length &lt;= 10^4</code></li>\n\t<li><code>restaurants[i].length == 5</code></li>\n\t<li><code>1 &lt;=&nbsp;id<sub>i</sub>, rating<sub>i</sub>, price<sub>i</sub>, distance<sub>i </sub>&lt;= 10^5</code></li>\n\t<li><code>1 &lt;=&nbsp;maxPrice,&nbsp;maxDistance &lt;= 10^5</code></li>\n\t<li><code>veganFriendly<sub>i</sub></code> 和&nbsp;<code>veganFriendly</code>&nbsp;的值为 0 或 1 。</li>\n\t<li>所有 <code>id<sub>i</sub></code> 各不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1334阈值距离内邻居最少的城市",
        "hardRate": "MEDIUM",
        "passRate": "52.73%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/solution",
        "problemsDesc": "<p>有 <code>n</code> 个城市，按从 <code>0</code> 到 <code>n-1</code> 编号。给你一个边数组 <code>edges</code>，其中 <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>, weight<sub>i</sub>]</code> 代表 <code>from<sub>i</sub></code> 和 <code>to<sub>i</sub></code><sub> </sub>两个城市之间的双向加权边，距离阈值是一个整数 <code>distanceThreshold</code>。</p>\n\n<p>返回能通过某些路径到达其他城市数目最少、且路径距离 <strong>最大</strong> 为 <code>distanceThreshold</code> 的城市。如果有多个这样的城市，则返回编号最大的城市。</p>\n\n<p>注意，连接城市 <em><strong>i</strong></em> 和 <em><strong>j</strong></em> 的路径的距离等于沿该路径的所有边的权重之和。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/find_the_city_01.png\" style=\"height: 225px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>城市分布图如上。\n每个城市阈值距离 distanceThreshold = 4 内的邻居城市分别是：\n城市 0 -> [城市 1, 城市 2] \n城市 1 -> [城市 0, 城市 2, 城市 3] \n城市 2 -> [城市 0, 城市 1, 城市 3] \n城市 3 -> [城市 1, 城市 2] \n城市 0 和 3 在阈值距离 4 以内都有 2 个邻居城市，但是我们必须返回城市 3，因为它的编号最大。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/find_the_city_02.png\" style=\"height: 225px; width: 300px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2\n<strong>输出：</strong>0\n<strong>解释：</strong>城市分布图如上。 \n每个城市阈值距离 distanceThreshold = 2 内的邻居城市分别是：\n城市 0 -> [城市 1] \n城市 1 -> [城市 0, 城市 4] \n城市 2 -> [城市 3, 城市 4] \n城市 3 -> [城市 2, 城市 4]\n城市 4 -> [城市 1, 城市 2, 城市 3] \n城市 0 在阈值距离 2 以内只有 1 个邻居城市。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 100</code></li>\n\t<li><code>1 <= edges.length <= n * (n - 1) / 2</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 <= from<sub>i</sub> < to<sub>i</sub> < n</code></li>\n\t<li><code>1 <= weight<sub>i</sub>, distanceThreshold <= 10^4</code></li>\n\t<li>所有 <code>(from<sub>i</sub>, to<sub>i</sub>)</code> 都是不同的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1335工作计划的最低难度",
        "hardRate": "HARD",
        "passRate": "66.69%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-difficulty-of-a-job-schedule/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-difficulty-of-a-job-schedule/solution",
        "problemsDesc": "<p>你需要制定一份&nbsp;<code>d</code>&nbsp;天的工作计划表。工作之间存在依赖，要想执行第&nbsp;<code>i</code>&nbsp;项工作，你必须完成全部&nbsp;<code>j</code>&nbsp;项工作（&nbsp;<code>0 &lt;= j &lt; i</code>）。</p>\n\n<p>你每天 <strong>至少</strong>&nbsp;需要完成一项任务。工作计划的总难度是这&nbsp;<code>d</code>&nbsp;天每一天的难度之和，而一天的工作难度是当天应该完成工作的最大难度。</p>\n\n<p>给你一个整数数组&nbsp;<code>jobDifficulty</code>&nbsp;和一个整数&nbsp;<code>d</code>，分别代表工作难度和需要计划的天数。第&nbsp;<code>i</code>&nbsp;项工作的难度是&nbsp;<code>jobDifficulty[i]</code>。</p>\n\n<p>返回整个工作计划的 <strong>最小难度</strong> 。如果无法制定工作计划，则返回&nbsp;<strong>-1&nbsp;</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/untitled.png\" style=\"height: 304px; width: 365px;\"></p>\n\n<pre><strong>输入：</strong>jobDifficulty = [6,5,4,3,2,1], d = 2\n<strong>输出：</strong>7\n<strong>解释：</strong>第一天，您可以完成前 5 项工作，总难度 = 6.\n第二天，您可以完成最后一项工作，总难度 = 1.\n计划表的难度 = 6 + 1 = 7 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>jobDifficulty = [9,9,9], d = 4\n<strong>输出：</strong>-1\n<strong>解释：</strong>就算你每天完成一项工作，仍然有一天是空闲的，你无法制定一份能够满足既定工作时间的计划表。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>jobDifficulty = [1,1,1], d = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>工作计划为每天一项工作，总难度为 3 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>jobDifficulty = [7,1,7,1,7,1], d = 3\n<strong>输出：</strong>15\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>jobDifficulty = [11,111,22,222,33,333,44,444], d = 6\n<strong>输出：</strong>843\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= jobDifficulty.length &lt;= 300</code></li>\n\t<li><code>0 &lt;=&nbsp;jobDifficulty[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= d &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1336每次访问的交易次数",
        "hardRate": "HARD",
        "passRate": "45.52%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-transactions-per-visit/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-transactions-per-visit/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1337矩阵中战斗力最弱的 K 行",
        "hardRate": "EASY",
        "passRate": "68.60%",
        "problemsUrl": "https://leetcode.cn/problems/the-k-weakest-rows-in-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/the-k-weakest-rows-in-a-matrix/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m * n</code> 的矩阵 <code>mat</code>，矩阵由若干军人和平民组成，分别用 1 和 0 表示。</p>\n\n<p>请你返回矩阵中战斗力最弱的 <code>k</code> 行的索引，按从最弱到最强排序。</p>\n\n<p>如果第 <em><strong>i</strong></em> 行的军人数量少于第 <em><strong>j</strong></em> 行，或者两行军人数量相同但<em><strong> i</strong></em> 小于 <em><strong>j</strong></em>，那么我们认为第<em><strong> i </strong></em>行的战斗力比第<em><strong> j </strong></em>行弱。</p>\n\n<p>军人 <strong>总是</strong> 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = \n[[1,1,0,0,0],\n [1,1,1,1,0],\n [1,0,0,0,0],\n [1,1,0,0,0],\n [1,1,1,1,1]], \nk = 3\n<strong>输出：</strong>[2,0,3]\n<strong>解释：</strong>\n每行中的军人数目：\n行 0 -> 2 \n行 1 -> 4 \n行 2 -> 1 \n行 3 -> 2 \n行 4 -> 5 \n从最弱到最强对这些行排序后得到 [2,0,3,1,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = \n[[1,0,0,0],\n [1,1,1,1],\n [1,0,0,0],\n [1,0,0,0]], \nk = 2\n<strong>输出：</strong>[0,2]\n<strong>解释：</strong> \n每行中的军人数目：\n行 0 -> 1 \n行 1 -> 4 \n行 2 -> 1 \n行 3 -> 1 \n从最弱到最强对这些行排序后得到 [0,2,3,1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>2 <= n, m <= 100</code></li>\n\t<li><code>1 <= k <= m</code></li>\n\t<li><code>matrix[i][j]</code> 不是 0 就是 1</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1338数组大小减半",
        "hardRate": "MEDIUM",
        "passRate": "64.85%",
        "problemsUrl": "https://leetcode.cn/problems/reduce-array-size-to-the-half/",
        "solutionsUrl": "https://leetcode.cn/problems/reduce-array-size-to-the-half/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code>。你可以从中选出一个整数集合，并删除这些整数在数组中的每次出现。</p>\n\n<p>返回&nbsp;<strong>至少</strong>&nbsp;能删除数组中的一半整数的整数集合的最小大小。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [3,3,3,3,5,5,5,2,2,7]\n<strong>输出：</strong>2\n<strong>解释：</strong>选择 {3,7} 使得结果数组为 [5,5,5,2,2]、长度为 5（原数组长度的一半）。\n大小为 2 的可行集合有 {3,5},{3,2},{5,2}。\n选择 {2,7} 是不可行的，它的结果数组为 [3,3,3,3,5,5,5]，新数组长度大于原数组的二分之一。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [7,7,7,7,7,7]\n<strong>输出：</strong>1\n<strong>解释：</strong>我们只能选择集合 {7}，结果数组为空。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>arr.length</code>&nbsp;为偶数</li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1339分裂二叉树的最大乘积",
        "hardRate": "MEDIUM",
        "passRate": "41.53%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-product-of-splitted-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-product-of-splitted-binary-tree/solution",
        "problemsDesc": "<p>给你一棵二叉树，它的根为&nbsp;<code>root</code> 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。</p>\n\n<p>由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/02/sample_1_1699.png\" style=\"height: 200px; width: 495px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [1,2,3,4,5,6]\n<strong>输出：</strong>110\n<strong>解释：</strong>删除红色的边，得到 2 棵子树，和分别为 11 和 10 。它们的乘积是 110 （11*10）\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/02/sample_2_1699.png\" style=\"height: 200px; width: 495px;\"></p>\n\n<pre><strong>输入：</strong>root = [1,null,2,3,4,null,null,5,6]\n<strong>输出：</strong>90\n<strong>解释：</strong>移除红色的边，得到 2 棵子树，和分别是 15 和 6 。它们的乘积为 90 （15*6）\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>root = [2,3,9,10,7,8,6,5,4,11,1]\n<strong>输出：</strong>1025\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>root = [1,1]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每棵树最多有&nbsp;<code>50000</code>&nbsp;个节点，且至少有&nbsp;<code>2</code>&nbsp;个节点。</li>\n\t<li>每个节点的值在&nbsp;<code>[1, 10000]</code>&nbsp;之间。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1340跳跃游戏 V",
        "hardRate": "HARD",
        "passRate": "59.28%",
        "problemsUrl": "https://leetcode.cn/problems/jump-game-v/",
        "solutionsUrl": "https://leetcode.cn/problems/jump-game-v/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code> 和一个整数&nbsp;<code>d</code> 。每一步你可以从下标&nbsp;<code>i</code>&nbsp;跳到：</p>\n\n<ul>\n\t<li><code>i + x</code>&nbsp;，其中&nbsp;<code>i + x &lt; arr.length</code>&nbsp;且&nbsp;<code>0 &lt; x &lt;= d</code>&nbsp;。</li>\n\t<li><code>i - x</code>&nbsp;，其中&nbsp;<code>i - x &gt;= 0</code>&nbsp;且&nbsp;<code>0 &lt; x &lt;= d</code>&nbsp;。</li>\n</ul>\n\n<p>除此以外，你从下标&nbsp;<code>i</code> 跳到下标 <code>j</code>&nbsp;需要满足：<code>arr[i] &gt; arr[j]</code>&nbsp;且 <code>arr[i] &gt; arr[k]</code>&nbsp;，其中下标&nbsp;<code>k</code>&nbsp;是所有 <code>i</code>&nbsp;到 <code>j</code>&nbsp;之间的数字（更正式的，<code>min(i, j) &lt; k &lt; max(i, j)</code>）。</p>\n\n<p>你可以选择数组的任意下标开始跳跃。请你返回你 <strong>最多</strong>&nbsp;可以访问多少个下标。</p>\n\n<p>请注意，任何时刻你都不能跳到数组的外面。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/02/meta-chart.jpeg\" style=\"height: 419px; width: 633px;\"></p>\n\n<pre><strong>输入：</strong>arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>你可以从下标 10 出发，然后如上图依次经过 10 --&gt; 8 --&gt; 6 --&gt; 7 。\n注意，如果你从下标 6 开始，你只能跳到下标 7 处。你不能跳到下标 5 处因为 13 &gt; 9 。你也不能跳到下标 4 处，因为下标 5 在下标 4 和 6 之间且 13 &gt; 9 。\n类似的，你不能从下标 3 处跳到下标 2 或者下标 1 处。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,3,3,3,3], d = 3\n<strong>输出：</strong>1\n<strong>解释：</strong>你可以从任意下标处开始且你永远无法跳到任何其他坐标。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [7,6,5,4,3,2,1], d = 1\n<strong>输出：</strong>7\n<strong>解释：</strong>从下标 0 处开始，你可以按照数值从大到小，访问所有的下标。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [7,1,7,1,7,1], d = 2\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [66], d = 1\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= d &lt;= arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1341电影评分",
        "hardRate": "MEDIUM",
        "passRate": "40.28%",
        "problemsUrl": "https://leetcode.cn/problems/movie-rating/",
        "solutionsUrl": "https://leetcode.cn/problems/movie-rating/solution",
        "problemsDesc": "<p>表：<code>Movies</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| movie_id      | int     |\n| title         | varchar |\n+---------------+---------+\nmovie_id 是这个表的主键。\ntitle 是电影的名字。\n</pre>\n\n<p>表：<code>Users</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| user_id       | int     |\n| name          | varchar |\n+---------------+---------+\nuser_id 是表的主键。\n</pre>\n\n<p>表：<code>MovieRating</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| movie_id      | int     |\n| user_id       | int     |\n| rating        | int     |\n| created_at    | date    |\n+---------------+---------+\n(movie_id, user_id) 是这个表的主键。\n这个表包含用户在其评论中对电影的评分 rating 。\ncreated_at 是用户的点评日期。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p>请你编写一组&nbsp;SQL 查询：</p>\n\n<ul>\n\t<li>查找评论电影数量最多的用户名。如果出现平局，返回字典序较小的用户名。</li>\n\t<li>查找在 <code>February 2020</code><strong> 平均评分最高</strong> 的电影名称。如果出现平局，返回字典序较小的电影名称。</li>\n</ul>\n\n<p><strong>字典序</strong> ，即按字母在字典中出现顺序对字符串排序，字典序较小则意味着排序靠前。</p>\n\n<p>查询结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nMovies 表：\n+-------------+--------------+\n| movie_id    |  title       |\n+-------------+--------------+\n| 1           | Avengers     |\n| 2           | Frozen 2     |\n| 3           | Joker        |\n+-------------+--------------+\nUsers 表：\n+-------------+--------------+\n| user_id     |  name        |\n+-------------+--------------+\n| 1           | Daniel       |\n| 2           | Monica       |\n| 3           | Maria        |\n| 4           | James        |\n+-------------+--------------+\nMovieRating 表：\n+-------------+--------------+--------------+-------------+\n| movie_id    | user_id      | rating       | created_at  |\n+-------------+--------------+--------------+-------------+\n| 1           | 1            | 3            | 2020-01-12  |\n| 1           | 2            | 4            | 2020-02-11  |\n| 1           | 3            | 2            | 2020-02-12  |\n| 1           | 4            | 1            | 2020-01-01  |\n| 2           | 1            | 5            | 2020-02-17  | \n| 2           | 2            | 2            | 2020-02-01  | \n| 2           | 3            | 2            | 2020-03-01  |\n| 3           | 1            | 3            | 2020-02-22  | \n| 3           | 2            | 4            | 2020-02-25  | \n+-------------+--------------+--------------+-------------+\n<strong>输出：</strong>\nResult 表：\n+--------------+\n| results      |\n+--------------+\n| Daniel       |\n| Frozen 2     |\n+--------------+\n<strong>解释：</strong>\nDaniel 和 Monica 都点评了 3 部电影（\"Avengers\", \"Frozen 2\" 和 \"Joker\"） 但是 Daniel 字典序比较小。\nFrozen 2 和 Joker 在 2 月的评分都是 3.5，但是 Frozen 2 的字典序比较小。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1342将数字变成 0 的操作次数",
        "hardRate": "EASY",
        "passRate": "75.97%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-to-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-to-zero/solution",
        "problemsDesc": "<p>给你一个非负整数&nbsp;<code>num</code>&nbsp;，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 14\n<strong>输出：</strong>6\n<strong>解释：\n</strong>步骤 1) 14 是偶数，除以 2 得到 7 。\n步骤 2） 7 是奇数，减 1 得到 6 。\n步骤 3） 6 是偶数，除以 2 得到 3 。\n步骤 4） 3 是奇数，减 1 得到 2 。\n步骤 5） 2 是偶数，除以 2 得到 1 。\n步骤 6） 1 是奇数，减 1 得到 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 8\n<strong>输出：</strong>4\n<strong>解释：</strong>\n步骤 1） 8 是偶数，除以 2 得到 4 。\n步骤 2） 4 是偶数，除以 2 得到 2 。\n步骤 3） 2 是偶数，除以 2 得到 1 。\n步骤 4） 1 是奇数，减 1 得到 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = 123\n<strong>输出：</strong>12\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1343大小为 K 且平均值大于等于阈值的子数组数目",
        "hardRate": "MEDIUM",
        "passRate": "57.41%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code>&nbsp;和两个整数 <code>k</code>&nbsp;和 <code>threshold</code>&nbsp;。</p>\n\n<p>请你返回长度为 <code>k</code>&nbsp;且平均值大于等于&nbsp;<code>threshold</code>&nbsp;的子数组数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>子数组 [2,5,5],[5,5,5] 和 [5,5,8] 的平均值分别为 4，5 和 6 。其他长度为 3 的子数组的平均值都小于 4 （threshold 的值)。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5\n<strong>输出：</strong>6\n<strong>解释：</strong>前 6 个长度为 3 的子数组平均值都大于 5 。注意平均值不是整数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= arr.length</code></li>\n\t<li><code>0 &lt;= threshold &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1344时钟指针的夹角",
        "hardRate": "MEDIUM",
        "passRate": "60.06%",
        "problemsUrl": "https://leetcode.cn/problems/angle-between-hands-of-a-clock/",
        "solutionsUrl": "https://leetcode.cn/problems/angle-between-hands-of-a-clock/solution",
        "problemsDesc": "<p>给你两个数&nbsp;<code>hour</code>&nbsp;和&nbsp;<code>minutes</code>&nbsp;。请你返回在时钟上，由给定时间的时针和分针组成的较小角的角度（60 单位制）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/08/sample_1_1673.png\" style=\"height: 225px; width: 230px;\"></p>\n\n<pre><strong>输入：</strong>hour = 12, minutes = 30\n<strong>输出：</strong>165\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/08/sample_2_1673.png\" style=\"height: 225px; width: 230px;\"></p>\n\n<pre><strong>输入：</strong>hour = 3, minutes = 30\n<strong>输出；</strong>75\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/08/sample_3_1673.png\" style=\"height: 231px; width: 230px;\"></strong></p>\n\n<pre><strong>输入：</strong>hour = 3, minutes = 15\n<strong>输出：</strong>7.5\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>hour = 4, minutes = 50\n<strong>输出：</strong>155\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>hour = 12, minutes = 0\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= hour &lt;= 12</code></li>\n\t<li><code>0 &lt;= minutes &lt;= 59</code></li>\n\t<li>与标准答案误差在&nbsp;<code>10^-5</code>&nbsp;以内的结果都被视为正确结果。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1345跳跃游戏 IV",
        "hardRate": "HARD",
        "passRate": "45.71%",
        "problemsUrl": "https://leetcode.cn/problems/jump-game-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/jump-game-iv/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code>&nbsp;，你一开始在数组的第一个元素处（下标为 0）。</p>\n\n<p>每一步，你可以从下标&nbsp;<code>i</code>&nbsp;跳到下标&nbsp;<code>i + 1</code> 、<code>i - 1</code> 或者 <code>j</code> ：</p>\n\n<ul>\n\t<li><code>i + 1</code> 需满足：<code>i + 1 &lt; arr.length</code></li>\n\t<li><code>i - 1</code>&nbsp;需满足：<code>i - 1 &gt;= 0</code></li>\n\t<li><code>j</code>&nbsp;需满足：<code>arr[i] == arr[j]</code>&nbsp;且&nbsp;<code>i != j</code></li>\n</ul>\n\n<p>请你返回到达数组最后一个元素的下标处所需的&nbsp;<strong>最少操作次数</strong>&nbsp;。</p>\n\n<p>注意：任何时候你都不能跳到数组外面。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [100,-23,-23,404,100,23,23,23,3,404]\n<strong>输出：</strong>3\n<strong>解释：</strong>那你需要跳跃 3 次，下标依次为 0 --&gt; 4 --&gt; 3 --&gt; 9 。下标 9 为数组的最后一个元素的下标。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [7]\n<strong>输出：</strong>0\n<strong>解释：</strong>一开始就在最后一个元素处，所以你不需要跳跃。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [7,6,9,6,9,6,9,7]\n<strong>输出：</strong>1\n<strong>解释：</strong>你可以直接从下标 0 处跳到下标 7 处，也就是数组的最后一个元素处。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>8</sup>&nbsp;&lt;= arr[i] &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1346检查整数及其两倍数是否存在",
        "hardRate": "EASY",
        "passRate": "41.97%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-n-and-its-double-exist/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-n-and-its-double-exist/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code>，请你检查是否存在两个整数&nbsp;<code>N</code> 和 <code>M</code>，满足&nbsp;<code>N</code>&nbsp;是&nbsp;<code>M</code>&nbsp;的两倍（即，<code>N = 2 * M</code>）。</p>\n\n<p>更正式地，检查是否存在两个下标&nbsp;<code>i</code> 和 <code>j</code> 满足：</p>\n\n<ul>\n\t<li><code>i != j</code></li>\n\t<li><code>0 &lt;= i, j &lt; arr.length</code></li>\n\t<li><code>arr[i] == 2 * arr[j]</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [10,2,5,3]\n<strong>输出：</strong>true\n<strong>解释：</strong>N<code> = 10</code> 是 M<code> = 5 的两倍</code>，即 <code>10 = 2 * 5 。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [7,1,14,11]\n<strong>输出：</strong>true\n<strong>解释：</strong>N<code> = 14</code> 是 M<code> = 7 的两倍</code>，即 <code>14 = 2 * 7 </code>。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,1,7,11]\n<strong>输出：</strong>false\n<strong>解释：</strong>在该情况下不存在 N 和 M 满足 N = 2 * M 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 500</code></li>\n\t<li><code>-10^3 &lt;= arr[i] &lt;= 10^3</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1347制造字母异位词的最小步骤数",
        "hardRate": "MEDIUM",
        "passRate": "76.15%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-steps-to-make-two-strings-anagram/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-steps-to-make-two-strings-anagram/solution",
        "problemsDesc": "<p>给你两个长度相等的字符串&nbsp;<code>s</code> 和 <code>t</code>。每一个步骤中，你可以选择将&nbsp;<code>t</code>&nbsp;中的 <strong>任一字符</strong> 替换为 <strong>另一个字符</strong>。</p>\n\n<p>返回使&nbsp;<code>t</code>&nbsp;成为&nbsp;<code>s</code>&nbsp;的字母异位词的最小步骤数。</p>\n\n<p><strong>字母异位词</strong> 指字母相同，但排列不同（也可能相同）的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输出：</strong>s = &quot;bab&quot;, t = &quot;aba&quot;\n<strong>输出：</strong>1\n<strong>提示：</strong>用 &#39;b&#39; 替换 t 中的第一个 &#39;a&#39;，t = &quot;bba&quot; 是 s 的一个字母异位词。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输出：</strong>s = &quot;leetcode&quot;, t = &quot;practice&quot;\n<strong>输出：</strong>5\n<strong>提示：</strong>用合适的字符替换 t 中的 &#39;p&#39;, &#39;r&#39;, &#39;a&#39;, &#39;i&#39; 和 &#39;c&#39;，使 t 变成 s 的字母异位词。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输出：</strong>s = &quot;anagram&quot;, t = &quot;mangaar&quot;\n<strong>输出：</strong>0\n<strong>提示：</strong>&quot;anagram&quot; 和 &quot;mangaar&quot; 本身就是一组字母异位词。 \n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输出：</strong>s = &quot;xxyyzz&quot;, t = &quot;xxyyzz&quot;\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输出：</strong>s = &quot;friend&quot;, t = &quot;family&quot;\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 50000</code></li>\n\t<li><code>s.length == t.length</code></li>\n\t<li><code>s</code> 和 <code>t</code>&nbsp;只包含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1348推文计数",
        "hardRate": "MEDIUM",
        "passRate": "35.00%",
        "problemsUrl": "https://leetcode.cn/problems/tweet-counts-per-frequency/",
        "solutionsUrl": "https://leetcode.cn/problems/tweet-counts-per-frequency/solution",
        "problemsDesc": "<p>一家社交媒体公司正试图通过分析特定时间段内出现的推文数量来监控其网站上的活动。这些时间段可以根据特定的频率（&nbsp;<strong>每分钟&nbsp;</strong>、<strong>每小时&nbsp;</strong>或 <strong>每一天</strong> ）划分为更小的 <strong>时间段</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p>例如，周期 <code>[10,10000]</code>&nbsp;（以 <strong>秒</strong> 为单位）将被划分为以下频率的 <strong>时间块</strong> :</p>\n\n<ul>\n\t<li>每 <strong>分钟</strong> (60秒 块)：<meta charset=\"UTF-8\" />&nbsp;<code>[10,69]</code>,&nbsp;<code>[70,129]</code>,&nbsp;<code>[130,189]</code>,&nbsp;<code>...</code>,&nbsp;<code>[9970,10000]</code></li>\n\t<li>每 <strong>小时</strong> (3600秒 块)：<meta charset=\"UTF-8\" /><code>[10,3609]</code>,&nbsp;<code>[3610,7209]</code>,&nbsp;<code>[7210,10000]</code></li>\n\t<li>每 <strong>天</strong> (86400秒 块)：<meta charset=\"UTF-8\" />&nbsp;<code>[10,10000]</code></li>\n</ul>\n\n<p>注意，最后一个块可能比指定频率的块大小更短，并且总是以时间段的结束时间结束(在上面的示例中为 <code>10000</code> )。</p>\n\n<p>设计和实现一个API来帮助公司进行分析。</p>\n\n<p>实现 <code>TweetCounts</code> 类:</p>\n\n<ul>\n\t<li><code>TweetCounts()</code> 初始化 <code>TweetCounts</code> 对象。</li>\n\t<li>存储记录时间的 <code>tweetName</code> (以秒为单位)。</li>\n\t<li><code>List&lt;integer&gt; getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime)</code>&nbsp;返回一个整数列表，表示给定时间 <code>[startTime, endTime]</code>&nbsp;（单位秒）和频率频率中，每个 <strong>时间块</strong> 中带有 <code>tweetName</code> 的 <code>tweet</code> 的数量。\n\t<ul>\n\t\t<li><code>freq</code> 是 <code>“minute”</code> 、 <code>“hour”</code> 或 <code>“day”</code> 中的一个，分别表示 <strong>每分钟</strong> 、 <strong>每小时</strong> 或 <strong>每一天</strong> 的频率。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"TweetCounts\",\"recordTweet\",\"recordTweet\",\"recordTweet\",\"getTweetCountsPerFrequency\",\"getTweetCountsPerFrequency\",\"recordTweet\",\"getTweetCountsPerFrequency\"]\n[[],[\"tweet3\",0],[\"tweet3\",60],[\"tweet3\",10],[\"minute\",\"tweet3\",0,59],[\"minute\",\"tweet3\",0,60],[\"tweet3\",120],[\"hour\",\"tweet3\",0,210]]\n\n<strong>输出：</strong>\n[null,null,null,null,[2],[2,1],null,[4]]\n\n<strong>解释：</strong>\nTweetCounts tweetCounts = new TweetCounts();\ntweetCounts.recordTweet(\"tweet3\", 0);\ntweetCounts.recordTweet(\"tweet3\", 60);\ntweetCounts.recordTweet(\"tweet3\", 10);                             //&nbsp;\"tweet3\"&nbsp;发布推文的时间分别是&nbsp;0,&nbsp;10&nbsp;和&nbsp;60 。\ntweetCounts.getTweetCountsPerFrequency(\"minute\", \"tweet3\", 0, 59); //&nbsp;返回&nbsp;[2]。统计频率是每分钟（60 秒），因此只有一个有效时间间隔 [0,60&gt;&nbsp;-&nbsp;&gt;&nbsp;2&nbsp;条推文。\ntweetCounts.getTweetCountsPerFrequency(\"minute\", \"tweet3\", 0, 60); //&nbsp;返回&nbsp;[2,1]。统计频率是每分钟（60 秒），因此有两个有效时间间隔&nbsp;<strong>1)</strong>&nbsp;[0,60&gt;&nbsp;-&nbsp;&gt;&nbsp;2&nbsp;条推文，和&nbsp;<strong>2)</strong>&nbsp;[60,61&gt;&nbsp;-&nbsp;&gt;&nbsp;1&nbsp;条推文。 \ntweetCounts.recordTweet(\"tweet3\", 120);                            // \"tweet3\"&nbsp;发布推文的时间分别是 0, 10, 60 和 120 。\ntweetCounts.getTweetCountsPerFrequency(\"hour\", \"tweet3\", 0, 210);  //&nbsp;返回&nbsp;[4]。统计频率是每小时（3600 秒），因此只有一个有效时间间隔 [0,211&gt;&nbsp;-&nbsp;&gt;&nbsp;4&nbsp;条推文。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= time, startTime, endTime &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= endTime - startTime &lt;= 10<sup>4</sup></code></li>\n\t<li><code>recordTweet</code>&nbsp;和&nbsp;<code>getTweetCountsPerFrequency</code>，最多有<meta charset=\"UTF-8\" />&nbsp;<code>10<sup>4</sup></code>&nbsp;次操作。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1349参加考试的最大学生数",
        "hardRate": "HARD",
        "passRate": "54.25%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-students-taking-exam/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-students-taking-exam/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m&nbsp;* n</code>&nbsp;的矩阵 <code>seats</code>&nbsp;表示教室中的座位分布。如果座位是坏的（不可用），就用&nbsp;<code>&#39;#&#39;</code>&nbsp;表示；否则，用&nbsp;<code>&#39;.&#39;</code>&nbsp;表示。</p>\n\n<p>学生可以看到左侧、右侧、左上、右上这四个方向上紧邻他的学生的答卷，但是看不到直接坐在他前面或者后面的学生的答卷。请你计算并返回该考场可以容纳的一起参加考试且无法作弊的最大学生人数。</p>\n\n<p>学生必须坐在状况良好的座位上。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/09/image.png\" style=\"height: 197px; width: 339px;\"></p>\n\n<pre><strong>输入：</strong>seats = [[&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;],\n&nbsp;             [&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;],\n&nbsp;             [&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;]]\n<strong>输出：</strong>4\n<strong>解释：</strong>教师可以让 4 个学生坐在可用的座位上，这样他们就无法在考试中作弊。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>seats = [[&quot;.&quot;,&quot;#&quot;],\n&nbsp;             [&quot;#&quot;,&quot;#&quot;],\n&nbsp;             [&quot;#&quot;,&quot;.&quot;],\n&nbsp;             [&quot;#&quot;,&quot;#&quot;],\n&nbsp;             [&quot;.&quot;,&quot;#&quot;]]\n<strong>输出：</strong>3\n<strong>解释：</strong>让所有学生坐在可用的座位上。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>seats = [[&quot;#&quot;,&quot;.&quot;,&quot;<strong>.</strong>&quot;,&quot;.&quot;,&quot;#&quot;],\n&nbsp;             [&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;],\n&nbsp;             [&quot;<strong>.</strong>&quot;,&quot;.&quot;,&quot;#&quot;,&quot;.&quot;,&quot;<strong>.</strong>&quot;],\n&nbsp;             [&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;],\n&nbsp;             [&quot;#&quot;,&quot;.&quot;,&quot;<strong>.</strong>&quot;,&quot;.&quot;,&quot;#&quot;]]\n<strong>输出：</strong>10\n<strong>解释：</strong>让学生坐在第 1、3 和 5 列的可用座位上。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>seats</code>&nbsp;只包含字符&nbsp;<code>&#39;.&#39;&nbsp;和</code><code>&#39;#&#39;</code></li>\n\t<li><code>m ==&nbsp;seats.length</code></li>\n\t<li><code>n ==&nbsp;seats[i].length</code></li>\n\t<li><code>1 &lt;= m &lt;= 8</code></li>\n\t<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1350院系无效的学生",
        "hardRate": "EASY",
        "passRate": "85.04%",
        "problemsUrl": "https://leetcode.cn/problems/students-with-invalid-departments/",
        "solutionsUrl": "https://leetcode.cn/problems/students-with-invalid-departments/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1351统计有序矩阵中的负数",
        "hardRate": "EASY",
        "passRate": "74.26%",
        "problemsUrl": "https://leetcode.cn/problems/count-negative-numbers-in-a-sorted-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/count-negative-numbers-in-a-sorted-matrix/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m&nbsp;* n</code>&nbsp;的矩阵&nbsp;<code>grid</code>，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。&nbsp;请你统计并返回&nbsp;<code>grid</code>&nbsp;中 <strong>负数</strong> 的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]\n<strong>输出：</strong>8\n<strong>解释：</strong>矩阵中共有 8 个负数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[3,2],[1,0]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>-100 &lt;= grid[i][j] &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(n + m)</code> 的解决方案吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1352最后 K 个数的乘积",
        "hardRate": "MEDIUM",
        "passRate": "48.35%",
        "problemsUrl": "https://leetcode.cn/problems/product-of-the-last-k-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/product-of-the-last-k-numbers/solution",
        "problemsDesc": "<p>请你实现一个「数字乘积类」<code>ProductOfNumbers</code>，要求支持下述两种方法：</p>\n\n<p>1.<code>&nbsp;add(int num)</code></p>\n\n<ul>\n\t<li>将数字&nbsp;<code>num</code>&nbsp;添加到当前数字列表的最后面。</li>\n</ul>\n\n<p>2.<code> getProduct(int k)</code></p>\n\n<ul>\n\t<li>返回当前数字列表中，最后&nbsp;<code>k</code>&nbsp;个数字的乘积。</li>\n\t<li>你可以假设当前列表中始终 <strong>至少</strong> 包含 <code>k</code> 个数字。</li>\n</ul>\n\n<p>题目数据保证：任何时候，任一连续数字序列的乘积都在 32-bit 整数范围内，不会溢出。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>\n[&quot;ProductOfNumbers&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;getProduct&quot;,&quot;getProduct&quot;,&quot;getProduct&quot;,&quot;add&quot;,&quot;getProduct&quot;]\n[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]\n\n<strong>输出：</strong>\n[null,null,null,null,null,null,20,40,0,null,32]\n\n<strong>解释：</strong>\nProductOfNumbers productOfNumbers = new ProductOfNumbers();\nproductOfNumbers.add(3);        // [3]\nproductOfNumbers.add(0);        // [3,0]\nproductOfNumbers.add(2);        // [3,0,2]\nproductOfNumbers.add(5);        // [3,0,2,5]\nproductOfNumbers.add(4);        // [3,0,2,5,4]\nproductOfNumbers.getProduct(2); // 返回 20 。最后 2 个数字的乘积是 5 * 4 = 20\nproductOfNumbers.getProduct(3); // 返回 40 。最后 3 个数字的乘积是 2 * 5 * 4 = 40\nproductOfNumbers.getProduct(4); // 返回  0 。最后 4 个数字的乘积是 0 * 2 * 5 * 4 = 0\nproductOfNumbers.add(8);        // [3,0,2,5,4,8]\nproductOfNumbers.getProduct(2); // 返回 32 。最后 2 个数字的乘积是 4 * 8 = 32 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>add</code> 和 <code>getProduct</code>&nbsp;两种操作加起来总共不会超过&nbsp;<code>40000</code>&nbsp;次。</li>\n\t<li><code>0 &lt;= num&nbsp;&lt;=&nbsp;100</code></li>\n\t<li><code>1 &lt;= k &lt;= 40000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1353最多可以参加的会议数目",
        "hardRate": "MEDIUM",
        "passRate": "29.48%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>events</code>，其中&nbsp;<code>events[i] = [startDay<sub>i</sub>, endDay<sub>i</sub>]</code>&nbsp;，表示会议&nbsp;<code>i</code>&nbsp;开始于&nbsp;<code>startDay<sub>i</sub></code>&nbsp;，结束于&nbsp;<code>endDay<sub>i</sub></code>&nbsp;。</p>\n\n<p>你可以在满足&nbsp;<code>startDay<sub>i</sub>&nbsp;&lt;= d &lt;= endDay<sub>i</sub></code><sub>&nbsp;</sub>中的任意一天&nbsp;<code>d</code>&nbsp;参加会议&nbsp;<code>i</code>&nbsp;。注意，一天只能参加一个会议。</p>\n\n<p>请你返回你可以参加的&nbsp;<strong>最大&nbsp;</strong>会议数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/16/e1.png\" style=\"height: 267px; width: 400px;\" /></p>\n\n<pre>\n<strong>输入：</strong>events = [[1,2],[2,3],[3,4]]\n<strong>输出：</strong>3\n<strong>解释：</strong>你可以参加所有的三个会议。\n安排会议的一种方案如上图。\n第 1 天参加第一个会议。\n第 2 天参加第二个会议。\n第 3 天参加第三个会议。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>events= [[1,2],[2,3],[3,4],[1,2]]\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong>​​​​​​</p>\n\n<ul>\n\t<li><code>1 &lt;= events.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>events[i].length == 2</code></li>\n\t<li><code>1 &lt;= startDay<sub>i</sub>&nbsp;&lt;= endDay<sub>i</sub>&nbsp;&lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1354多次求和构造目标数组",
        "hardRate": "HARD",
        "passRate": "28.99%",
        "problemsUrl": "https://leetcode.cn/problems/construct-target-array-with-multiple-sums/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-target-array-with-multiple-sums/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>target</code> 。一开始，你有一个数组&nbsp;<code>A</code> ，它的所有元素均为 1 ，你可以执行以下操作：</p>\n\n<ul>\n\t<li>令&nbsp;<code>x</code>&nbsp;为你数组里所有元素的和</li>\n\t<li>选择满足&nbsp;<code>0 &lt;= i &lt; target.size</code>&nbsp;的任意下标&nbsp;<code>i</code>&nbsp;，并让&nbsp;<code>A</code>&nbsp;数组里下标为&nbsp;<code>i</code>&nbsp;处的值为&nbsp;<code>x</code>&nbsp;。</li>\n\t<li>你可以重复该过程任意次</li>\n</ul>\n\n<p>如果能从&nbsp;<code>A</code>&nbsp;开始构造出目标数组&nbsp;<code>target</code>&nbsp;，请你返回 True ，否则返回 False 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>target = [9,3,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>从 [1, 1, 1] 开始\n[1, 1, 1], 和为 3 ，选择下标 1\n[1, 3, 1], 和为 5， 选择下标 2\n[1, 3, 5], 和为 9， 选择下标 0\n[9, 3, 5] 完成\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>target = [1,1,1,2]\n<strong>输出：</strong>false\n<strong>解释：</strong>不可能从 [1,1,1,1] 出发构造目标数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>target = [8,5]\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>N == target.length</code></li>\n\t<li><code>1 &lt;= target.length&nbsp;&lt;= 5 * 10^4</code></li>\n\t<li><code>1 &lt;= target[i] &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1355活动参与者",
        "hardRate": "MEDIUM",
        "passRate": "66.81%",
        "problemsUrl": "https://leetcode.cn/problems/activity-participants/",
        "solutionsUrl": "https://leetcode.cn/problems/activity-participants/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1356根据数字二进制下 1 的数目排序",
        "hardRate": "EASY",
        "passRate": "73.46%",
        "problemsUrl": "https://leetcode.cn/problems/sort-integers-by-the-number-of-1-bits/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-integers-by-the-number-of-1-bits/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code>&nbsp;。请你将数组中的元素按照其二进制表示中数字 <strong>1</strong> 的数目升序排序。</p>\n\n<p>如果存在多个数字二进制中&nbsp;<strong>1</strong>&nbsp;的数目相同，则必须将它们按照数值大小升序排列。</p>\n\n<p>请你返回排序后的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [0,1,2,3,4,5,6,7,8]\n<strong>输出：</strong>[0,1,2,4,8,3,5,6,7]\n<strong>解释：</strong>[0] 是唯一一个有 0 个 1 的数。\n[1,2,4,8] 都有 1 个 1 。\n[3,5,6] 有 2 个 1 。\n[7] 有 3 个 1 。\n按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1024,512,256,128,64,32,16,8,4,2,1]\n<strong>输出：</strong>[1,2,4,8,16,32,64,128,256,512,1024]\n<strong>解释：</strong>数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [10000,10000]\n<strong>输出：</strong>[10000,10000]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,3,5,7,11,13,17,19]\n<strong>输出：</strong>[2,3,5,17,7,11,13,19]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [10,100,1000,10000]\n<strong>输出：</strong>[10,100,10000,1000]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 500</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1357每隔 n 个顾客打折",
        "hardRate": "MEDIUM",
        "passRate": "54.57%",
        "problemsUrl": "https://leetcode.cn/problems/apply-discount-every-n-orders/",
        "solutionsUrl": "https://leetcode.cn/problems/apply-discount-every-n-orders/solution",
        "problemsDesc": "<p>超市里正在举行打折活动，每隔&nbsp;<code>n</code>&nbsp;个顾客会得到 <code>discount</code>&nbsp;的折扣。</p>\n\n<p>超市里有一些商品，第&nbsp;<code>i</code>&nbsp;种商品为&nbsp;<code>products[i]</code>&nbsp;且每件单品的价格为&nbsp;<code>prices[i]</code>&nbsp;。</p>\n\n<p>结账系统会统计顾客的数目，每隔&nbsp;<code>n</code>&nbsp;个顾客结账时，该顾客的账单都会打折，折扣为&nbsp;<code>discount</code>&nbsp;（也就是如果原本账单为&nbsp;<code>x</code>&nbsp;，那么实际金额会变成&nbsp;<code>x - (discount * x) / 100</code>&nbsp;），然后系统会重新开始计数。</p>\n\n<p>顾客会购买一些商品，&nbsp;<code>product[i]</code>&nbsp;是顾客购买的第&nbsp;<code>i</code>&nbsp;种商品，&nbsp;<code>amount[i]</code>&nbsp;是对应的购买该种商品的数目。</p>\n\n<p>请你实现&nbsp;<code>Cashier</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>Cashier(int n, int discount, int[] products, int[] prices)</code>&nbsp;初始化实例对象，参数分别为打折频率&nbsp;<code>n</code>&nbsp;，折扣大小 <code>discount</code>&nbsp;，超市里的商品列表 <code>products</code>&nbsp;和它们的价格 <code>prices</code>&nbsp;。</li>\n\t<li><code>double&nbsp;getBill(int[] product, int[] amount)</code>&nbsp;返回账单的实际金额（如果有打折，请返回打折后的结果）。返回结果与标准答案误差在&nbsp;<code>10^-5</code>&nbsp;以内都视为正确结果。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入</strong>\n[&quot;Cashier&quot;,&quot;getBill&quot;,&quot;getBill&quot;,&quot;getBill&quot;,&quot;getBill&quot;,&quot;getBill&quot;,&quot;getBill&quot;,&quot;getBill&quot;]\n[[3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]],[[1,2],[1,2]],[[3,7],[10,10]],[[1,2,3,4,5,6,7],[1,1,1,1,1,1,1]],[[4],[10]],[[7,3],[10,10]],[[7,5,3,1,6,4,2],[10,10,10,9,9,9,7]],[[2,3,5],[5,3,2]]]\n<strong>输出</strong>\n[null,500.0,4000.0,800.0,4000.0,4000.0,7350.0,2500.0]\n<strong>解释</strong>\nCashier cashier = new Cashier(3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]);\ncashier.getBill([1,2],[1,2]);                        // 返回 500.0, 账单金额为 = 1 * 100 + 2 * 200 = 500.\ncashier.getBill([3,7],[10,10]);                      // 返回 4000.0\ncashier.getBill([1,2,3,4,5,6,7],[1,1,1,1,1,1,1]);    // 返回 800.0 ，账单原本为 1600.0 ，但由于该顾客是第三位顾客，他将得到 50% 的折扣，所以实际金额为 1600 - 1600 * (50 / 100) = 800 。\ncashier.getBill([4],[10]);                           // 返回 4000.0\ncashier.getBill([7,3],[10,10]);                      // 返回 4000.0\ncashier.getBill([7,5,3,1,6,4,2],[10,10,10,9,9,9,7]); // 返回 7350.0 ，账单原本为 14700.0 ，但由于系统计数再次达到三，该顾客将得到 50% 的折扣，实际金额为 7350.0 。\ncashier.getBill([2,3,5],[5,3,2]);                    // 返回 2500.0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^4</code></li>\n\t<li><code>0 &lt;= discount &lt;= 100</code></li>\n\t<li><code>1 &lt;= products.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= products[i] &lt;= 200</code></li>\n\t<li><code>products</code>&nbsp;列表中&nbsp;<strong>不会</strong>&nbsp;有重复的元素。</li>\n\t<li><code>prices.length == products.length</code></li>\n\t<li><code>1 &lt;= prices[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= product.length &lt;= products.length</code></li>\n\t<li><code>product[i]</code>&nbsp;在&nbsp;<code>products</code>&nbsp;出现过。</li>\n\t<li><code>amount.length == product.length</code></li>\n\t<li><code>1 &lt;= amount[i] &lt;= 1000</code></li>\n\t<li>最多有&nbsp;<code>1000</code> 次对&nbsp;<code>getBill</code>&nbsp;函数的调用。</li>\n\t<li>返回结果与标准答案误差在&nbsp;<code>10^-5</code>&nbsp;以内都视为正确结果。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1358包含所有三种字符的子字符串数目",
        "hardRate": "MEDIUM",
        "passRate": "52.93%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code>&nbsp;，它只包含三种字符 a, b 和 c 。</p>\n\n<p>请你返回 a，b 和 c 都&nbsp;<strong>至少&nbsp;</strong>出现过一次的子字符串数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abcabc&quot;\n<strong>输出：</strong>10\n<strong>解释：</strong>包含 a，b 和 c 各至少一次的子字符串为<em> &quot;</em>abc<em>&quot;, &quot;</em>abca<em>&quot;, &quot;</em>abcab<em>&quot;, &quot;</em>abcabc<em>&quot;, &quot;</em>bca<em>&quot;, &quot;</em>bcab<em>&quot;, &quot;</em>bcabc<em>&quot;, &quot;</em>cab<em>&quot;, &quot;</em>cabc<em>&quot; </em>和<em> &quot;</em>abc<em>&quot; </em>(<strong>相同</strong><strong>字符串算多次</strong>)<em>。</em>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aaacb&quot;\n<strong>输出：</strong>3\n<strong>解释：</strong>包含 a，b 和 c 各至少一次的子字符串为<em> &quot;</em>aaacb<em>&quot;, &quot;</em>aacb<em>&quot; </em>和<em> &quot;</em>acb<em>&quot; 。</em>\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abc&quot;\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= s.length &lt;= 5 x 10^4</code></li>\n\t<li><code>s</code>&nbsp;只包含字符 a，b 和 c 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1359有效的快递序列数目",
        "hardRate": "HARD",
        "passRate": "58.41%",
        "problemsUrl": "https://leetcode.cn/problems/count-all-valid-pickup-and-delivery-options/",
        "solutionsUrl": "https://leetcode.cn/problems/count-all-valid-pickup-and-delivery-options/solution",
        "problemsDesc": "<p>给你&nbsp;<code>n</code>&nbsp;笔订单，每笔订单都需要快递服务。</p>\n\n<p>请你统计所有有效的 收件/配送 序列的数目，确保第 <code>i</code> 个物品的配送服务&nbsp;<code>delivery(i)</code> 总是在其收件服务&nbsp;<code>pickup(i)</code> 之后。</p>\n\n<p>由于答案可能很大，请返回答案对 <code>10^9 + 7</code> 取余的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>只有一种序列 (P1, D1)，物品 1 的配送服务（D1）在物品 1 的收件服务（P1）后。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>6\n<strong>解释：</strong>所有可能的序列包括：\n(P1,P2,D1,D2)，(P1,P2,D2,D1)，(P1,D1,P2,D2)，(P2,P1,D1,D2)，(P2,P1,D2,D1) 和 (P2,D2,P1,D1)。\n(P1,D2,P2,D1) 是一个无效的序列，因为物品 2 的收件服务（P2）不应在物品 2 的配送服务（D2）之后。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 3\n<strong>输出：</strong>90\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1360日期之间隔几天",
        "hardRate": "EASY",
        "passRate": "51.02%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-days-between-two-dates/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-days-between-two-dates/solution",
        "problemsDesc": "<p>请你编写一个程序来计算两个日期之间隔了多少天。</p>\n\n<p>日期以字符串形式给出，格式为&nbsp;<code>YYYY-MM-DD</code>，如示例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>date1 = &quot;2019-06-29&quot;, date2 = &quot;2019-06-30&quot;\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>date1 = &quot;2020-01-15&quot;, date2 = &quot;2019-12-31&quot;\n<strong>输出：</strong>15\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给定的日期是&nbsp;<code>1971</code>&nbsp;年到 <code>2100</code>&nbsp;年之间的有效日期。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1361验证二叉树",
        "hardRate": "MEDIUM",
        "passRate": "39.87%",
        "problemsUrl": "https://leetcode.cn/problems/validate-binary-tree-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/validate-binary-tree-nodes/solution",
        "problemsDesc": "<p>二叉树上有 <code>n</code>&nbsp;个节点，按从&nbsp;<code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;编号，其中节点&nbsp;<code>i</code>&nbsp;的两个子节点分别是&nbsp;<code>leftChild[i]</code>&nbsp;和&nbsp;<code>rightChild[i]</code>。</p>\n\n<p>只有 <strong>所有</strong> 节点能够形成且 <strong>只</strong> 形成 <strong>一颗</strong>&nbsp;有效的二叉树时，返回&nbsp;<code>true</code>；否则返回 <code>false</code>。</p>\n\n<p>如果节点&nbsp;<code>i</code>&nbsp;没有左子节点，那么&nbsp;<code>leftChild[i]</code>&nbsp;就等于&nbsp;<code>-1</code>。右子节点也符合该规则。</p>\n\n<p>注意：节点没有值，本问题中仅仅使用节点编号。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/23/1503_ex1.png\" style=\"height: 287px; width: 195px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/23/1503_ex2.png\" style=\"height: 272px; width: 183px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/23/1503_ex3.png\" style=\"height: 174px; width: 82px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 2, leftChild = [1,0], rightChild = [-1,-1]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/23/1503_ex4.png\" style=\"height: 191px; width: 470px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 6, leftChild = [1,-1,-1,4,-1,-1], rightChild = [2,-1,-1,5,-1,-1]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^4</code></li>\n\t<li><code>leftChild.length == rightChild.length == n</code></li>\n\t<li><code>-1 &lt;= leftChild[i], rightChild[i] &lt;= n - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1362最接近的因数",
        "hardRate": "MEDIUM",
        "passRate": "54.75%",
        "problemsUrl": "https://leetcode.cn/problems/closest-divisors/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-divisors/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>num</code>，请你找出同时满足下面全部要求的两个整数：</p>\n\n<ul>\n\t<li>两数乘积等于 &nbsp;<code>num + 1</code>&nbsp;或&nbsp;<code>num + 2</code></li>\n\t<li>以绝对差进行度量，两数大小最接近</li>\n</ul>\n\n<p>你可以按任意顺序返回这两个整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 8\n<strong>输出：</strong>[3,3]\n<strong>解释：</strong>对于 num + 1 = 9，最接近的两个因数是 3 &amp; 3；对于 num + 2 = 10, 最接近的两个因数是 2 &amp; 5，因此返回 3 &amp; 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 123\n<strong>输出：</strong>[5,25]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = 999\n<strong>输出：</strong>[40,25]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1363形成三的最大倍数",
        "hardRate": "HARD",
        "passRate": "35.92%",
        "problemsUrl": "https://leetcode.cn/problems/largest-multiple-of-three/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-multiple-of-three/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>digits</code>，你可以通过按任意顺序连接其中某些数字来形成 <strong>3</strong> 的倍数，请你返回所能得到的最大的 3 的倍数。</p>\n\n<p>由于答案可能不在整数数据类型范围内，请以字符串形式返回答案。</p>\n\n<p>如果无法得到答案，请返回一个空字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>digits = [8,1,9]\n<strong>输出：</strong>&quot;981&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>digits = [8,6,7,1,0]\n<strong>输出：</strong>&quot;8760&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>digits = [1]\n<strong>输出：</strong>&quot;&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>digits = [0,0,0,0,0,0]\n<strong>输出：</strong>&quot;0&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= digits.length &lt;= 10^4</code></li>\n\t<li><code>0 &lt;= digits[i] &lt;= 9</code></li>\n\t<li>返回的结果不应包含不必要的前导零。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1364顾客的可信联系人数量",
        "hardRate": "MEDIUM",
        "passRate": "68.37%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-trusted-contacts-of-a-customer/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-trusted-contacts-of-a-customer/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1365有多少小于当前数字的数字",
        "hardRate": "EASY",
        "passRate": "82.37%",
        "problemsUrl": "https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/",
        "solutionsUrl": "https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>nums</code>，对于其中每个元素&nbsp;<code>nums[i]</code>，请你统计数组中比它小的所有数字的数目。</p>\n\n<p>换而言之，对于每个&nbsp;<code>nums[i]</code>&nbsp;你必须计算出有效的&nbsp;<code>j</code>&nbsp;的数量，其中 <code>j</code> 满足&nbsp;<code>j != i</code> <strong>且</strong> <code>nums[j] &lt; nums[i]</code>&nbsp;。</p>\n\n<p>以数组形式返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [8,1,2,2,3]\n<strong>输出：</strong>[4,0,1,1,3]\n<strong>解释：</strong> \n对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 \n对于 nums[1]=1 不存在比它小的数字。\n对于 nums[2]=2 存在一个比它小的数字：（1）。 \n对于 nums[3]=2 存在一个比它小的数字：（1）。 \n对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [6,5,4,8]\n<strong>输出：</strong>[2,1,0,3]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [7,7,7,7]\n<strong>输出：</strong>[0,0,0,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1366通过投票对团队排名",
        "hardRate": "MEDIUM",
        "passRate": "51.13%",
        "problemsUrl": "https://leetcode.cn/problems/rank-teams-by-votes/",
        "solutionsUrl": "https://leetcode.cn/problems/rank-teams-by-votes/solution",
        "problemsDesc": "<p>现在有一个特殊的排名系统，依据参赛团队在投票人心中的次序进行排名，每个投票者都需要按从高到低的顺序对参与排名的所有团队进行排位。</p>\n\n<p>排名规则如下：</p>\n\n<ul>\n\t<li>参赛团队的排名次序依照其所获「排位第一」的票的多少决定。如果存在多个团队并列的情况，将继续考虑其「排位第二」的票的数量。以此类推，直到不再存在并列的情况。</li>\n\t<li>如果在考虑完所有投票情况后仍然出现并列现象，则根据团队字母的字母顺序进行排名。</li>\n</ul>\n\n<p>给你一个字符串数组&nbsp;<code>votes</code> 代表全体投票者给出的排位情况，请你根据上述排名规则对所有参赛团队进行排名。</p>\n\n<p>请你返回能表示按排名系统 <strong>排序后</strong> 的所有团队排名的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>votes = [&quot;ABC&quot;,&quot;ACB&quot;,&quot;ABC&quot;,&quot;ACB&quot;,&quot;ACB&quot;]\n<strong>输出：</strong>&quot;ACB&quot;\n<strong>解释：</strong>A 队获得五票「排位第一」，没有其他队获得「排位第一」，所以 A 队排名第一。\nB 队获得两票「排位第二」，三票「排位第三」。\nC 队获得三票「排位第二」，两票「排位第三」。\n由于 C 队「排位第二」的票数较多，所以 C 队排第二，B 队排第三。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>votes = [&quot;WXYZ&quot;,&quot;XYZW&quot;]\n<strong>输出：</strong>&quot;XWYZ&quot;\n<strong>解释：</strong>X 队在并列僵局打破后成为排名第一的团队。X 队和 W 队的「排位第一」票数一样，但是 X 队有一票「排位第二」，而 W 没有获得「排位第二」。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>votes = [&quot;ZMNAGUEDSJYLBOPHRQICWFXTVK&quot;]\n<strong>输出：</strong>&quot;ZMNAGUEDSJYLBOPHRQICWFXTVK&quot;\n<strong>解释：</strong>只有一个投票者，所以排名完全按照他的意愿。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>votes = [&quot;BCA&quot;,&quot;CAB&quot;,&quot;CBA&quot;,&quot;ABC&quot;,&quot;ACB&quot;,&quot;BAC&quot;]\n<strong>输出：</strong>&quot;ABC&quot;\n<strong>解释：</strong> \nA 队获得两票「排位第一」，两票「排位第二」，两票「排位第三」。\nB 队获得两票「排位第一」，两票「排位第二」，两票「排位第三」。\nC 队获得两票「排位第一」，两票「排位第二」，两票「排位第三」。\n完全并列，所以我们需要按照字母升序排名。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>votes = [&quot;M&quot;,&quot;M&quot;,&quot;M&quot;,&quot;M&quot;]\n<strong>输出：</strong>&quot;M&quot;\n<strong>解释：</strong>只有 M 队参赛，所以它排名第一。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= votes.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= votes[i].length &lt;= 26</code></li>\n\t<li><code>votes[i].length ==&nbsp;votes[j].length</code> for&nbsp;<code>0 &lt;= i, j &lt; votes.length</code></li>\n\t<li><code>votes[i][j]</code>&nbsp;是英文 <strong>大写</strong> 字母</li>\n\t<li><code>votes[i]</code>&nbsp;中的所有字母都是唯一的</li>\n\t<li><code>votes[0]</code>&nbsp;中出现的所有字母 <strong>同样也</strong> 出现在&nbsp;<code>votes[j]</code>&nbsp;中，其中&nbsp;<code>1 &lt;= j &lt; votes.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1367二叉树中的链表",
        "hardRate": "MEDIUM",
        "passRate": "43.72%",
        "problemsUrl": "https://leetcode.cn/problems/linked-list-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/linked-list-in-binary-tree/solution",
        "problemsDesc": "<p>给你一棵以&nbsp;<code>root</code>&nbsp;为根的二叉树和一个&nbsp;<code>head</code>&nbsp;为第一个节点的链表。</p>\n\n<p>如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以&nbsp;<code>head</code>&nbsp;为首的链表中每个节点的值，那么请你返回 <code>True</code> ，否则返回 <code>False</code> 。</p>\n\n<p>一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/sample_1_1720.png\" style=\"height: 280px; width: 220px;\"></strong></p>\n\n<pre><strong>输入：</strong>head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n<strong>输出：</strong>true\n<strong>解释：</strong>树中蓝色的节点构成了与链表对应的子路径。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/sample_2_1720.png\" style=\"height: 280px; width: 220px;\"></strong></p>\n\n<pre><strong>输入：</strong>head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n<strong>输出：</strong>false\n<strong>解释：</strong>二叉树中不存在一一对应链表的路径。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉树和链表中的每个节点的值都满足&nbsp;<code>1 &lt;= node.val&nbsp;&lt;= 100</code>&nbsp;。</li>\n\t<li>链表包含的节点数目在&nbsp;<code>1</code>&nbsp;到&nbsp;<code>100</code>&nbsp;之间。</li>\n\t<li>二叉树包含的节点数目在&nbsp;<code>1</code>&nbsp;到&nbsp;<code>2500</code>&nbsp;之间。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1368使网格图至少有一条有效路径的最小代价",
        "hardRate": "HARD",
        "passRate": "59.66%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/solution",
        "problemsDesc": "<p>给你一个 m x n 的网格图&nbsp;<code>grid</code>&nbsp;。&nbsp;<code>grid</code>&nbsp;中每个格子都有一个数字，对应着从该格子出发下一步走的方向。&nbsp;<code>grid[i][j]</code>&nbsp;中的数字可能为以下几种情况：</p>\n\n<ul>\n\t<li><strong>1</strong>&nbsp;，下一步往右走，也就是你会从 <code>grid[i][j]</code>&nbsp;走到 <code>grid[i][j + 1]</code></li>\n\t<li><strong>2</strong>&nbsp;，下一步往左走，也就是你会从 <code>grid[i][j]</code>&nbsp;走到 <code>grid[i][j - 1]</code></li>\n\t<li><strong>3</strong>&nbsp;，下一步往下走，也就是你会从 <code>grid[i][j]</code>&nbsp;走到 <code>grid[i + 1][j]</code></li>\n\t<li><strong>4</strong>&nbsp;，下一步往上走，也就是你会从 <code>grid[i][j]</code>&nbsp;走到 <code>grid[i - 1][j]</code></li>\n</ul>\n\n<p>注意网格图中可能会有&nbsp;<strong>无效数字</strong>&nbsp;，因为它们可能指向&nbsp;<code>grid</code>&nbsp;以外的区域。</p>\n\n<p>一开始，你会从最左上角的格子&nbsp;<code>(0,0)</code>&nbsp;出发。我们定义一条&nbsp;<strong>有效路径</strong>&nbsp;为从格子&nbsp;<code>(0,0)</code>&nbsp;出发，每一步都顺着数字对应方向走，最终在最右下角的格子&nbsp;<code>(m - 1, n - 1)</code>&nbsp;结束的路径。有效路径&nbsp;<strong>不需要是最短路径</strong>&nbsp;。</p>\n\n<p>你可以花费&nbsp;<code>cost = 1</code>&nbsp;的代价修改一个格子中的数字，但每个格子中的数字&nbsp;<strong>只能修改一次</strong>&nbsp;。</p>\n\n<p>请你返回让网格图至少有一条有效路径的最小代价。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid1.png\" style=\"height: 528px; width: 542px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]\n<strong>输出：</strong>3\n<strong>解释：</strong>你将从点 (0, 0) 出发。\n到达 (3, 3) 的路径为： (0, 0) --&gt; (0, 1) --&gt; (0, 2) --&gt; (0, 3) 花费代价 cost = 1 使方向向下 --&gt; (1, 3) --&gt; (1, 2) --&gt; (1, 1) --&gt; (1, 0) 花费代价 cost = 1 使方向向下 --&gt; (2, 0) --&gt; (2, 1) --&gt; (2, 2) --&gt; (2, 3) 花费代价 cost = 1 使方向向下 --&gt; (3, 3)\n总花费为 cost = 3.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid2.png\" style=\"height: 408px; width: 419px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[1,1,3],[3,2,2],[1,1,4]]\n<strong>输出：</strong>0\n<strong>解释：</strong>不修改任何数字你就可以从 (0, 0) 到达 (2, 2) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid3.png\" style=\"height: 302px; width: 314px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[1,2],[4,3]]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[2,2,2],[2,2,2]]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[4]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1369获取最近第二次的活动",
        "hardRate": "HARD",
        "passRate": "61.58%",
        "problemsUrl": "https://leetcode.cn/problems/get-the-second-most-recent-activity/",
        "solutionsUrl": "https://leetcode.cn/problems/get-the-second-most-recent-activity/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1370上升下降字符串",
        "hardRate": "EASY",
        "passRate": "78.96%",
        "problemsUrl": "https://leetcode.cn/problems/increasing-decreasing-string/",
        "solutionsUrl": "https://leetcode.cn/problems/increasing-decreasing-string/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，请你根据下面的算法重新构造字符串：</p>\n\n<ol>\n\t<li>从 <code>s</code>&nbsp;中选出 <strong>最小</strong>&nbsp;的字符，将它 <strong>接在</strong>&nbsp;结果字符串的后面。</li>\n\t<li>从 <code>s</code>&nbsp;剩余字符中选出&nbsp;<strong>最小</strong>&nbsp;的字符，且该字符比上一个添加的字符大，将它 <strong>接在</strong>&nbsp;结果字符串后面。</li>\n\t<li>重复步骤 2 ，直到你没法从 <code>s</code>&nbsp;中选择字符。</li>\n\t<li>从 <code>s</code>&nbsp;中选出 <strong>最大</strong>&nbsp;的字符，将它 <strong>接在</strong>&nbsp;结果字符串的后面。</li>\n\t<li>从 <code>s</code>&nbsp;剩余字符中选出&nbsp;<strong>最大</strong>&nbsp;的字符，且该字符比上一个添加的字符小，将它 <strong>接在</strong>&nbsp;结果字符串后面。</li>\n\t<li>重复步骤 5&nbsp;，直到你没法从 <code>s</code>&nbsp;中选择字符。</li>\n\t<li>重复步骤 1 到 6 ，直到 <code>s</code>&nbsp;中所有字符都已经被选过。</li>\n</ol>\n\n<p>在任何一步中，如果最小或者最大字符不止一个&nbsp;，你可以选择其中任意一个，并将其添加到结果字符串。</p>\n\n<p>请你返回将&nbsp;<code>s</code>&nbsp;中字符重新排序后的 <strong>结果字符串</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aaaabbbbcccc&quot;\n<strong>输出：</strong>&quot;abccbaabccba&quot;\n<strong>解释：</strong>第一轮的步骤 1，2，3 后，结果字符串为 result = &quot;abc&quot;\n第一轮的步骤 4，5，6 后，结果字符串为 result = &quot;abccba&quot;\n第一轮结束，现在 s = &quot;aabbcc&quot; ，我们再次回到步骤 1\n第二轮的步骤 1，2，3 后，结果字符串为 result = &quot;abccbaabc&quot;\n第二轮的步骤 4，5，6 后，结果字符串为 result = &quot;abccbaabccba&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;rat&quot;\n<strong>输出：</strong>&quot;art&quot;\n<strong>解释：</strong>单词 &quot;rat&quot; 在上述算法重排序以后变成 &quot;art&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;leetcode&quot;\n<strong>输出：</strong>&quot;cdelotee&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;ggggggg&quot;\n<strong>输出：</strong>&quot;ggggggg&quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;spo&quot;\n<strong>输出：</strong>&quot;ops&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1371每个元音包含偶数次的最长子字符串",
        "hardRate": "MEDIUM",
        "passRate": "59.08%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即&nbsp;&#39;a&#39;，&#39;e&#39;，&#39;i&#39;，&#39;o&#39;，&#39;u&#39; ，在子字符串中都恰好出现了偶数次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;eleetminicoworoep&quot;\n<strong>输出：</strong>13\n<strong>解释：</strong>最长子字符串是 &quot;leetminicowor&quot; ，它包含 <strong>e，i，o</strong>&nbsp;各 2 个，以及 0 个 <strong>a</strong>，<strong>u </strong>。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;leetcodeisgreat&quot;\n<strong>输出：</strong>5\n<strong>解释：</strong>最长子字符串是 &quot;leetc&quot; ，其中包含 2 个 <strong>e</strong> 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;bcbcbc&quot;\n<strong>输出：</strong>6\n<strong>解释：</strong>这个示例中，字符串 &quot;bcbcbc&quot; 本身就是最长的，因为所有的元音 <strong>a，</strong><strong>e，</strong><strong>i，</strong><strong>o，</strong><strong>u</strong> 都出现了 0 次。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 x 10^5</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1372二叉树中的最长交错路径",
        "hardRate": "MEDIUM",
        "passRate": "54.71%",
        "problemsUrl": "https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/solution",
        "problemsDesc": "<p>给你一棵以&nbsp;<code>root</code>&nbsp;为根的二叉树，二叉树中的交错路径定义如下：</p>\n\n<ul>\n\t<li>选择二叉树中 <strong>任意</strong>&nbsp;节点和一个方向（左或者右）。</li>\n\t<li>如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。</li>\n\t<li>改变前进方向：左变右或者右变左。</li>\n\t<li>重复第二步和第三步，直到你在树中无法继续移动。</li>\n</ul>\n\n<p>交错路径的长度定义为：<strong>访问过的节点数目 - 1</strong>（单个节点的路径长度为 0 ）。</p>\n\n<p>请你返回给定树中最长 <strong>交错路径</strong>&nbsp;的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/07/sample_1_1702.png\" style=\"height: 283px; width: 151px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>蓝色节点为树中最长交错路径（右 -&gt; 左 -&gt; 右）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/07/sample_2_1702.png\" style=\"height: 253px; width: 120px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [1,1,1,null,1,null,null,1,1,null,1]\n<strong>输出：</strong>4\n<strong>解释：</strong>蓝色节点为树中最长交错路径（左 -&gt; 右 -&gt; 左 -&gt; 右）。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>root = [1]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每棵树最多有&nbsp;<code>50000</code>&nbsp;个节点。</li>\n\t<li>每个节点的值在&nbsp;<code>[1, 100]</code> 之间。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1373二叉搜索子树的最大键值和",
        "hardRate": "HARD",
        "passRate": "47.81%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/solution",
        "problemsDesc": "<p>给你一棵以 <code>root</code> 为根的 <strong>二叉树</strong> ，请你返回 <strong>任意</strong> 二叉搜索子树的最大键值和。</p>\n\n<p>二叉搜索树的定义如下：</p>\n\n<ul>\n\t<li>任意节点的左子树中的键值都 <strong>小于</strong> 此节点的键值。</li>\n\t<li>任意节点的右子树中的键值都 <strong>大于</strong> 此节点的键值。</li>\n\t<li>任意节点的左子树和右子树都是二叉搜索树。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/07/sample_1_1709.png\" style=\"height: 250px; width: 320px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]\n<strong>输出：</strong>20\n<strong>解释：</strong>键值为 3 的子树是和最大的二叉搜索树。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/07/sample_2_1709.png\" style=\"height: 180px; width: 134px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [4,3,null,1,2]\n<strong>输出：</strong>2\n<strong>解释：</strong>键值为 2 的单节点子树是和最大的二叉搜索树。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [-4,-2,-5]\n<strong>输出：</strong>0\n<strong>解释：</strong>所有节点键值都为负数，和最大的二叉搜索树为空。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [2,1,3]\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [5,4,8,3,null,6,3]\n<strong>输出：</strong>7\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每棵树有 <code>1</code> 到 <code>40000</code> 个节点。</li>\n\t<li>每个节点的键值在 <code>[-4 * 10^4 , 4 * 10^4]</code> 之间。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1374生成每种字符都是奇数个的字符串",
        "hardRate": "EASY",
        "passRate": "77.65%",
        "problemsUrl": "https://leetcode.cn/problems/generate-a-string-with-characters-that-have-odd-counts/",
        "solutionsUrl": "https://leetcode.cn/problems/generate-a-string-with-characters-that-have-odd-counts/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code>，请你返回一个含<em> <code>n</code> </em>个字符的字符串，其中每种字符在该字符串中都恰好出现 <strong>奇数次</strong> <em><strong>。</strong></em></p>\n\n<p>返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 4\n<strong>输出：</strong>&quot;pppz&quot;\n<strong>解释：</strong>&quot;pppz&quot; 是一个满足题目要求的字符串，因为 &#39;p&#39; 出现 3 次，且 &#39;z&#39; 出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：&quot;ohhh&quot; 和 &quot;love&quot;。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>&quot;xy&quot;\n<strong>解释：</strong>&quot;xy&quot; 是一个满足题目要求的字符串，因为 &#39;x&#39; 和 &#39;y&#39; 各出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：&quot;ag&quot; 和 &quot;ur&quot;。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 7\n<strong>输出：</strong>&quot;holasss&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1375二进制字符串前缀一致的次数",
        "hardRate": "MEDIUM",
        "passRate": "68.09%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-times-binary-string-is-prefix-aligned/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-times-binary-string-is-prefix-aligned/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 、下标从 <strong>1</strong> 开始的二进制字符串，所有位最开始都是 <code>0</code> 。我们会按步翻转该二进制字符串的所有位（即，将 <code>0</code> 变为 <code>1</code>）。</p>\n\n<p>给你一个下标从 <strong>1</strong> 开始的整数数组 <code>flips</code> ，其中 <code>flips[i]</code> 表示对应下标 <code>i</code> 的位将会在第 <code>i</code> 步翻转。</p>\n\n<p>二进制字符串 <strong>前缀一致</strong> 需满足：在第 <code>i</code> 步之后，在 <strong>闭</strong> 区间&nbsp;<code>[1, i]</code> 内的所有位都是 1 ，而其他位都是 0 。</p>\n\n<p>返回二进制字符串在翻转过程中 <strong>前缀一致</strong> 的次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>flips = [3,2,4,1,5]\n<strong>输出：</strong>2\n<strong>解释：</strong>二进制字符串最开始是 \"00000\" 。\n执行第 1 步：字符串变为 \"00100\" ，不属于前缀一致的情况。\n执行第 2 步：字符串变为 \"01100\" ，不属于前缀一致的情况。\n执行第 3 步：字符串变为 \"01110\" ，不属于前缀一致的情况。\n执行第 4 步：字符串变为 \"11110\" ，属于前缀一致的情况。\n执行第 5 步：字符串变为 \"11111\" ，属于前缀一致的情况。\n在翻转过程中，前缀一致的次数为 2 ，所以返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>flips = [4,1,2,3]\n<strong>输出：</strong>1\n<strong>解释：</strong>二进制字符串最开始是 \"0000\" 。\n执行第 1 步：字符串变为 \"0001\" ，不属于前缀一致的情况。\n执行第 2 步：字符串变为 \"1001\" ，不属于前缀一致的情况。\n执行第 3 步：字符串变为 \"1101\" ，不属于前缀一致的情况。\n执行第 4 步：字符串变为 \"1111\" ，属于前缀一致的情况。\n在翻转过程中，前缀一致的次数为 1 ，所以返回 1 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == flips.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>flips</code> 是范围 <code>[1, n]</code> 中所有整数构成的一个排列</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1376通知所有员工所需的时间",
        "hardRate": "MEDIUM",
        "passRate": "60.17%",
        "problemsUrl": "https://leetcode.cn/problems/time-needed-to-inform-all-employees/",
        "solutionsUrl": "https://leetcode.cn/problems/time-needed-to-inform-all-employees/solution",
        "problemsDesc": "<p>公司里有 <code>n</code> 名员工，每个员工的 ID 都是独一无二的，编号从 <code>0</code> 到 <code>n - 1</code>。公司的总负责人通过 <code>headID</code> 进行标识。</p>\n\n<p>在 <code>manager</code> 数组中，每个员工都有一个直属负责人，其中 <code>manager[i]</code> 是第 <code>i</code> 名员工的直属负责人。对于总负责人，<code>manager[headID] = -1</code>。题目保证从属关系可以用树结构显示。</p>\n\n<p>公司总负责人想要向公司所有员工通告一条紧急消息。他将会首先通知他的直属下属们，然后由这些下属通知他们的下属，直到所有的员工都得知这条紧急消息。</p>\n\n<p>第 <code>i</code> 名员工需要 <code>informTime[i]</code> 分钟来通知它的所有直属下属（也就是说在 <code>informTime[i]</code> 分钟后，他的所有直属下属都可以开始传播这一消息）。</p>\n\n<p>返回通知所有员工这一紧急消息所需要的 <strong>分钟数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, headID = 0, manager = [-1], informTime = [0]\n<strong>输出：</strong>0\n<strong>解释：</strong>公司总负责人是该公司的唯一一名员工。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/08/graph.png\" style=\"height: 174px; width: 404px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]\n<strong>输出：</strong>1\n<strong>解释：</strong>id = 2 的员工是公司的总负责人，也是其他所有员工的直属负责人，他需要 1 分钟来通知所有员工。\n上图显示了公司员工的树结构。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= headID &lt; n</code></li>\n\t<li><code>manager.length == n</code></li>\n\t<li><code>0 &lt;= manager[i] &lt; n</code></li>\n\t<li><code>manager[headID] == -1</code></li>\n\t<li><code>informTime.length&nbsp;== n</code></li>\n\t<li><code>0 &lt;= informTime[i] &lt;= 1000</code></li>\n\t<li>如果员工 <code>i</code> 没有下属，<code>informTime[i] == 0</code> 。</li>\n\t<li>题目 <strong>保证</strong> 所有员工都可以收到通知。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1377T 秒后青蛙的位置",
        "hardRate": "HARD",
        "passRate": "42.66%",
        "problemsUrl": "https://leetcode.cn/problems/frog-position-after-t-seconds/",
        "solutionsUrl": "https://leetcode.cn/problems/frog-position-after-t-seconds/solution",
        "problemsDesc": "<p>给你一棵由 <code>n</code> 个顶点组成的无向树，顶点编号从 <code>1</code> 到 <code>n</code>。青蛙从 <strong>顶点 1</strong> 开始起跳。规则如下：</p>\n\n<ul>\n\t<li>在一秒内，青蛙从它所在的当前顶点跳到另一个 <strong>未访问</strong> 过的顶点（如果它们直接相连）。</li>\n\t<li>青蛙无法跳回已经访问过的顶点。</li>\n\t<li>如果青蛙可以跳到多个不同顶点，那么它跳到其中任意一个顶点上的机率都相同。</li>\n\t<li>如果青蛙不能跳到任何未访问过的顶点上，那么它每次跳跃都会停留在原地。</li>\n</ul>\n\n<p>无向树的边用数组 <code>edges</code> 描述，其中 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 意味着存在一条直接连通 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 两个顶点的边。</p>\n\n<p>返回青蛙在 <em><code>t</code></em> 秒后位于目标顶点 <em><code>target</code> </em>上的概率。与实际答案相差不超过 <code>10<sup>-5</sup></code> 的结果将被视为正确答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/12/21/frog1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4\n<strong>输出：</strong>0.16666666666666666 \n<strong>解释：</strong>上图显示了青蛙的跳跃路径。青蛙从顶点 1 起跳，第 <strong>1 秒</strong> 有 1/3 的概率跳到顶点 2 ，然后第 <strong>2 秒</strong> 有 1/2 的概率跳到顶点 4，因此青蛙在 2 秒后位于顶点 4 的概率是 1/3 * 1/2 = 1/6 = 0.16666666666666666 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/12/21/frog2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7\n<strong>输出：</strong>0.3333333333333333\n<strong>解释：</strong>上图显示了青蛙的跳跃路径。青蛙从顶点 1 起跳，有 1/3 = 0.3333333333333333 的概率能够 <strong>1 秒</strong> 后跳到顶点 7 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub>&nbsp;&lt;= n</code></li>\n\t<li><code>1 &lt;= t &lt;= 50</code></li>\n\t<li><code>1 &lt;= target &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1378使用唯一标识码替换员工ID",
        "hardRate": "EASY",
        "passRate": "85.54%",
        "problemsUrl": "https://leetcode.cn/problems/replace-employee-id-with-the-unique-identifier/",
        "solutionsUrl": "https://leetcode.cn/problems/replace-employee-id-with-the-unique-identifier/solution",
        "problemsDesc": "<p><code>Employees</code> 表：</p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| name          | varchar |\n+---------------+---------+\nid 是这张表的主键。\n这张表的每一行分别代表了某公司其中一位员工的名字和 ID 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><code>EmployeeUNI</code>&nbsp;表：</p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| unique_id     | int     |\n+---------------+---------+\n(id, unique_id) 是这张表的主键。\n这张表的每一行包含了该公司某位员工的 ID 和他的唯一标识码（unique ID）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一段SQL查询来展示每位用户的<strong> 唯一标识码（unique ID ）</strong>；如果某位员工没有唯一标识码，使用 null 填充即可。</p>\n\n<p>你可以以<strong> 任意</strong> 顺序返回结果表。</p>\n\n<p>查询结果的格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<code><strong>输入：</strong>\nEmployees</code> 表:\n+----+----------+\n| id | name     |\n+----+----------+\n| 1  | Alice    |\n| 7  | Bob      |\n| 11 | Meir     |\n| 90 | Winston  |\n| 3  | Jonathan |\n+----+----------+\n<code>EmployeeUNI</code> 表:\n+----+-----------+\n| id | unique_id |\n+----+-----------+\n| 3  | 1         |\n| 11 | 2         |\n| 90 | 3         |\n+----+-----------+\n<strong>输出：</strong>\n+-----------+----------+\n| unique_id | name     |\n+-----------+----------+\n| null      | Alice    |\n| null      | Bob      |\n| 2         | Meir     |\n| 3         | Winston  |\n| 1         | Jonathan |\n+-----------+----------+\n<strong>解释：</strong>\nAlice and Bob 没有唯一标识码, 因此我们使用 null 替代。\nMeir 的唯一标识码是 2 。\nWinston 的唯一标识码是 3 。\nJonathan 唯一标识码是 1 。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1379找出克隆二叉树中的相同节点",
        "hardRate": "EASY",
        "passRate": "83.26%",
        "problemsUrl": "https://leetcode.cn/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/solution",
        "problemsDesc": "<p>给你两棵二叉树，原始树 <code>original</code> 和克隆树 <code>cloned</code>，以及一个位于原始树 <code>original</code>&nbsp;中的目标节点&nbsp;<code>target</code>。</p>\n\n<p>其中，克隆树 <code>cloned</code>&nbsp;是原始树 <code>original</code>&nbsp;的一个<strong> 副本 </strong>。</p>\n\n<p>请找出在树&nbsp;<code>cloned</code>&nbsp;中，与&nbsp;<code>target</code>&nbsp;<strong>相同&nbsp;</strong>的节点，并返回对该节点的引用（在 C/C++ 等有指针的语言中返回 节点指针，其他语言返回节点本身）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>你 <strong>不能</strong> 对两棵二叉树，以及 <code>target</code>&nbsp;节点进行更改。<strong>只能</strong> 返回对克隆树&nbsp;<code>cloned</code>&nbsp;中已有的节点的引用。</p>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/21/e1.png\" /></p>\n\n<pre>\n<strong>输入:</strong> tree = [7,4,3,null,null,6,19], target = 3\n<strong>输出:</strong> 3\n<strong>解释:</strong> 上图画出了树 original 和 cloned。target 节点在树 original 中，用绿色标记。答案是树 cloned 中的黄颜色的节点（其他示例类似）。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/21/e2.png\" /></p>\n\n<pre>\n<strong>输入:</strong> tree = [7], target =  7\n<strong>输出:</strong> 7\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/21/e3.png\" /></p>\n\n<pre>\n<strong>输入:</strong> tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4\n<strong>输出:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数量范围为<meta charset=\"UTF-8\" />&nbsp;<code>[1, 10<sup>4</sup>]</code>&nbsp;。</li>\n\t<li>同一棵树中，没有值相同的节点。</li>\n\t<li><code>target</code>&nbsp;节点是树&nbsp;<code>original</code>&nbsp;中的一个节点，并且不会是&nbsp;<code>null</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>如果树中允许出现值相同的节点，将如何解答？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1380矩阵中的幸运数",
        "hardRate": "EASY",
        "passRate": "76.35%",
        "problemsUrl": "https://leetcode.cn/problems/lucky-numbers-in-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/lucky-numbers-in-a-matrix/solution",
        "problemsDesc": "<p>给你一个 <code>m * n</code> 的矩阵，矩阵中的数字 <strong>各不相同</strong> 。请你按 <strong>任意</strong> 顺序返回矩阵中的所有幸运数。</p>\n\n<p><strong>幸运数</strong> 是指矩阵中满足同时下列两个条件的元素：</p>\n\n<ul>\n\t<li>在同一行的所有元素中最小</li>\n\t<li>在同一列的所有元素中最大</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[3,7,8],[9,11,13],[15,16,17]]\n<strong>输出：</strong>[15]\n<strong>解释：</strong>15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]\n<strong>输出：</strong>[12]\n<strong>解释：</strong>12 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[7,8],[1,2]]\n<strong>输出：</strong>[7]\n<strong>解释：</strong>7是唯一的幸运数字，因为它是行中的最小值，列中的最大值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 50</code></li>\n\t<li><code>1 &lt;=&nbsp;matrix[i][j]&nbsp;&lt;= 10^5</code></li>\n\t<li>矩阵中的所有元素都是不同的</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1381设计一个支持增量操作的栈",
        "hardRate": "MEDIUM",
        "passRate": "72.42%",
        "problemsUrl": "https://leetcode.cn/problems/design-a-stack-with-increment-operation/",
        "solutionsUrl": "https://leetcode.cn/problems/design-a-stack-with-increment-operation/solution",
        "problemsDesc": "<p>请你设计一个支持对其元素进行增量操作的栈。</p>\n\n<p>实现自定义栈类 <code>CustomStack</code> ：</p>\n\n<ul>\n\t<li><code>CustomStack(int maxSize)</code>：用 <code>maxSize</code> 初始化对象，<code>maxSize</code> 是栈中最多能容纳的元素数量。</li>\n\t<li><code>void push(int x)</code>：如果栈还未增长到 <code>maxSize</code> ，就将 <code>x</code> 添加到栈顶。</li>\n\t<li><code>int pop()</code>：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 <strong>-1</strong> 。</li>\n\t<li><code>void inc(int k, int val)</code>：栈底的 <code>k</code> 个元素的值都增加 <code>val</code> 。如果栈中元素总数小于 <code>k</code> ，则栈中的所有元素都增加 <code>val</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n<strong>输出：</strong>\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n<strong>解释：</strong>\nCustomStack stk = new CustomStack(3); // 栈是空的 []\nstk.push(1);                          // 栈变为 [1]\nstk.push(2);                          // 栈变为 [1, 2]\nstk.pop();                            // 返回 2 --&gt; 返回栈顶值 2，栈变为 [1]\nstk.push(2);                          // 栈变为 [1, 2]\nstk.push(3);                          // 栈变为 [1, 2, 3]\nstk.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\nstk.increment(5, 100);                // 栈变为 [101, 102, 103]\nstk.increment(2, 100);                // 栈变为 [201, 202, 103]\nstk.pop();                            // 返回 103 --&gt; 返回栈顶值 103，栈变为 [201, 202]\nstk.pop();                            // 返回 202 --&gt; 返回栈顶值 202，栈变为 [201]\nstk.pop();                            // 返回 201 --&gt; 返回栈顶值 201，栈变为 []\nstk.pop();                            // 返回 -1 --&gt; 栈为空，返回 -1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= maxSize, x, k &lt;= 1000</code></li>\n\t<li><code>0 &lt;= val &lt;= 100</code></li>\n\t<li>每种方法 <code>increment</code>，<code>push</code> 以及 <code>pop</code> 分别最多调用 <code>1000</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1382将二叉搜索树变平衡",
        "hardRate": "MEDIUM",
        "passRate": "73.60%",
        "problemsUrl": "https://leetcode.cn/problems/balance-a-binary-search-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/balance-a-binary-search-tree/solution",
        "problemsDesc": "<p>给你一棵二叉搜索树，请你返回一棵&nbsp;<strong>平衡后</strong>&nbsp;的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。</p>\n\n<p>如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 <code>1</code> ，我们就称这棵二叉搜索树是&nbsp;<strong>平衡的</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/10/balance1-tree.jpg\" style=\"height: 319px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,null,2,null,3,null,4,null,null]\n<strong>输出：</strong>[2,1,3,null,null,null,4]\n<strong>解释：</strong>这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/10/balanced2-tree.jpg\" style=\"height: 145px; width: 224px;\" /></p>\n\n<pre>\n<strong>输入:</strong> root = [2,1,3]\n<strong>输出:</strong> [2,1,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树节点的数目在&nbsp;<code>[1, 10<sup>4</sup>]</code>&nbsp;范围内。</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1383最大的团队表现值",
        "hardRate": "HARD",
        "passRate": "35.33%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-performance-of-a-team/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-performance-of-a-team/solution",
        "problemsDesc": "<p>公司有编号为 <code>1</code>&nbsp;到 <code>n</code>&nbsp;的 <code>n</code>&nbsp;个工程师，给你两个数组 <code>speed</code>&nbsp;和 <code>efficiency</code>&nbsp;，其中 <code>speed[i]</code>&nbsp;和 <code>efficiency[i]</code>&nbsp;分别代表第 <code>i</code>&nbsp;位工程师的速度和效率。请你返回由最多&nbsp;<code>k</code>&nbsp;个工程师组成的&nbsp;<strong>​​​​​​最大团队表现值</strong>&nbsp;，由于答案可能很大，请你返回结果对 <code>10^9 + 7</code> 取余后的结果。</p>\n\n<p><strong>团队表现值</strong>&nbsp;的定义为：一个团队中「所有工程师速度的和」乘以他们「效率值中的最小值」。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2\n<strong>输出：</strong>60\n<strong>解释：</strong>\n我们选择工程师 2（speed=10 且 efficiency=4）和工程师 5（speed=5 且 efficiency=7）。他们的团队表现值为 performance = (10 + 5) * min(4, 7) = 60 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3\n<strong>输出：</strong>68\n<strong>解释：\n</strong>此示例与第一个示例相同，除了 k = 3 。我们可以选择工程师 1 ，工程师 2 和工程师 5 得到最大的团队表现值。表现值为 performance = (2 + 10 + 5) * min(5, 4, 7) = 68 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4\n<strong>输出：</strong>72\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>speed.length == n</code></li>\n\t<li><code>efficiency.length == n</code></li>\n\t<li><code>1 &lt;= speed[i] &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= efficiency[i] &lt;= 10^8</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1384按年度列出销售总额",
        "hardRate": "HARD",
        "passRate": "57.69%",
        "problemsUrl": "https://leetcode.cn/problems/total-sales-amount-by-year/",
        "solutionsUrl": "https://leetcode.cn/problems/total-sales-amount-by-year/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1385两个数组间的距离值",
        "hardRate": "EASY",
        "passRate": "64.08%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-distance-value-between-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-distance-value-between-two-arrays/solution",
        "problemsDesc": "<p>给你两个整数数组&nbsp;<code>arr1</code>&nbsp;，&nbsp;<code>arr2</code>&nbsp;和一个整数&nbsp;<code>d</code>&nbsp;，请你返回两个数组之间的&nbsp;<strong>距离值</strong>&nbsp;。</p>\n\n<p>「<strong>距离值</strong>」<strong>&nbsp;</strong>定义为符合此距离要求的元素数目：对于元素&nbsp;<code>arr1[i]</code>&nbsp;，不存在任何元素&nbsp;<code>arr2[j]</code>&nbsp;满足 <code>|arr1[i]-arr2[j]| &lt;= d</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>\n对于 arr1[0]=4 我们有：\n|4-10|=6 &gt; d=2 \n|4-9|=5 &gt; d=2 \n|4-1|=3 &gt; d=2 \n|4-8|=4 &gt; d=2 \n所以 arr1[0]=4 符合距离要求\n\n对于 arr1[1]=5 我们有：\n|5-10|=5 &gt; d=2 \n|5-9|=4 &gt; d=2 \n|5-1|=4 &gt; d=2 \n|5-8|=3 &gt; d=2\n所以 arr1[1]=5 也符合距离要求\n\n对于 arr1[2]=8 我们有：\n<strong>|8-10|=2 &lt;= d=2</strong>\n<strong>|8-9|=1 &lt;= d=2</strong>\n|8-1|=7 &gt; d=2\n<strong>|8-8|=0 &lt;= d=2</strong>\n存在距离小于等于 2 的情况，不符合距离要求 \n\n故而只有 arr1[0]=4 和 arr1[1]=5 两个符合距离要求，距离值为 2</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr1.length, arr2.length &lt;= 500</code></li>\n\t<li><code>-10^3 &lt;= arr1[i], arr2[j] &lt;= 10^3</code></li>\n\t<li><code>0 &lt;= d &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1386安排电影院座位",
        "hardRate": "MEDIUM",
        "passRate": "35.53%",
        "problemsUrl": "https://leetcode.cn/problems/cinema-seat-allocation/",
        "solutionsUrl": "https://leetcode.cn/problems/cinema-seat-allocation/solution",
        "problemsDesc": "<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/cinema_seats_1.png\" style=\"height: 149px; width: 400px;\"></p>\n\n<p>如上图所示，电影院的观影厅中有 <code>n</code>&nbsp;行座位，行编号从 1&nbsp;到 <code>n</code>&nbsp;，且每一行内总共有 10 个座位，列编号从 1 到 10 。</p>\n\n<p>给你数组&nbsp;<code>reservedSeats</code>&nbsp;，包含所有已经被预约了的座位。比如说，<code>researvedSeats[i]=[3,8]</code>&nbsp;，它表示第&nbsp;<strong>3</strong>&nbsp;行第&nbsp;<strong>8</strong>&nbsp;个座位被预约了。</p>\n\n<p>请你返回&nbsp;<strong>最多能安排多少个 4 人家庭</strong>&nbsp;。4 人家庭要占据&nbsp;<strong>同一行内连续&nbsp;</strong>的 4 个座位。隔着过道的座位（比方说 [3,3] 和 [3,4]）不是连续的座位，但是如果你可以将 4 人家庭拆成过道两边各坐 2 人，这样子是允许的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/cinema_seats_3.png\" style=\"height: 96px; width: 400px;\"></p>\n\n<pre><strong>输入：</strong>n = 3, reservedSeats = [[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]]\n<strong>输出：</strong>4\n<strong>解释：</strong>上图所示是最优的安排方案，总共可以安排 4 个家庭。蓝色的叉表示被预约的座位，橙色的连续座位表示一个 4 人家庭。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, reservedSeats = [[2,1],[1,8],[2,6]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 4, reservedSeats = [[4,3],[1,4],[4,6],[1,7]]\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^9</code></li>\n\t<li><code>1 &lt;=&nbsp;reservedSeats.length &lt;= min(10*n, 10^4)</code></li>\n\t<li><code>reservedSeats[i].length == 2</code></li>\n\t<li><code>1&nbsp;&lt;=&nbsp;reservedSeats[i][0] &lt;= n</code></li>\n\t<li><code>1 &lt;=&nbsp;reservedSeats[i][1] &lt;= 10</code></li>\n\t<li>所有&nbsp;<code>reservedSeats[i]</code> 都是互不相同的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1387将整数按权重排序",
        "hardRate": "MEDIUM",
        "passRate": "69.52%",
        "problemsUrl": "https://leetcode.cn/problems/sort-integers-by-the-power-value/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-integers-by-the-power-value/solution",
        "problemsDesc": "<p>我们将整数 <code>x</code>&nbsp;的 <strong>权重</strong> 定义为按照下述规则将 <code>x</code>&nbsp;变成 <code>1</code>&nbsp;所需要的步数：</p>\n\n<ul>\n\t<li>如果&nbsp;<code>x</code>&nbsp;是偶数，那么&nbsp;<code>x = x / 2</code></li>\n\t<li>如果&nbsp;<code>x</code>&nbsp;是奇数，那么&nbsp;<code>x = 3 * x + 1</code></li>\n</ul>\n\n<p>比方说，x=3 的权重为 7 。因为 3 需要 7 步变成 1 （3 --&gt; 10 --&gt; 5 --&gt; 16 --&gt; 8 --&gt; 4 --&gt; 2 --&gt; 1）。</p>\n\n<p>给你三个整数&nbsp;<code>lo</code>，&nbsp;<code>hi</code> 和&nbsp;<code>k</code>&nbsp;。你的任务是将区间&nbsp;<code>[lo, hi]</code>&nbsp;之间的整数按照它们的权重&nbsp;<strong>升序排序&nbsp;</strong>，如果大于等于 2 个整数有&nbsp;<strong>相同</strong>&nbsp;的权重，那么按照数字自身的数值&nbsp;<strong>升序排序</strong>&nbsp;。</p>\n\n<p>请你返回区间&nbsp;<code>[lo, hi]</code>&nbsp;之间的整数按权重排序后的第&nbsp;<code>k</code>&nbsp;个数。</p>\n\n<p>注意，题目保证对于任意整数&nbsp;<code>x</code>&nbsp;<code>（lo &lt;= x &lt;= hi）</code>&nbsp;，它变成&nbsp;<code>1</code> 所需要的步数是一个 32 位有符号整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>lo = 12, hi = 15, k = 2\n<strong>输出：</strong>13\n<strong>解释：</strong>12 的权重为 9（12 --&gt; 6 --&gt; 3 --&gt; 10 --&gt; 5 --&gt; 16 --&gt; 8 --&gt; 4 --&gt; 2 --&gt; 1）\n13 的权重为 9\n14 的权重为 17\n15 的权重为 17\n区间内的数按权重排序以后的结果为 [12,13,14,15] 。对于 k = 2 ，答案是第二个整数也就是 13 。\n注意，12 和 13 有相同的权重，所以我们按照它们本身升序排序。14 和 15 同理。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>lo = 7, hi = 11, k = 4\n<strong>输出：</strong>7\n<strong>解释：</strong>区间内整数 [7, 8, 9, 10, 11] 对应的权重为 [16, 3, 19, 6, 14] 。\n按权重排序后得到的结果为 [8, 10, 11, 7, 9] 。\n排序后数组中第 4 个数字为 7 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= lo &lt;= hi &lt;= 1000</code></li>\n\t<li><code>1 &lt;= k &lt;= hi - lo + 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 13883n 块披萨",
        "hardRate": "HARD",
        "passRate": "56.49%",
        "problemsUrl": "https://leetcode.cn/problems/pizza-with-3n-slices/",
        "solutionsUrl": "https://leetcode.cn/problems/pizza-with-3n-slices/solution",
        "problemsDesc": "<p>给你一个披萨，它由 3n 块不同大小的部分组成，现在你和你的朋友们需要按照如下规则来分披萨：</p>\n\n<ul>\n\t<li>你挑选 <strong>任意</strong>&nbsp;一块披萨。</li>\n\t<li>Alice 将会挑选你所选择的披萨逆时针方向的下一块披萨。</li>\n\t<li>Bob 将会挑选你所选择的披萨顺时针方向的下一块披萨。</li>\n\t<li>重复上述过程直到没有披萨剩下。</li>\n</ul>\n\n<p>每一块披萨的大小按顺时针方向由循环数组 <code>slices</code>&nbsp;表示。</p>\n\n<p>请你返回你可以获得的披萨大小总和的最大值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/sample_3_1723.png\" style=\"height: 240px; width: 475px;\" /></p>\n\n<pre>\n<strong>输入：</strong>slices = [1,2,3,4,5,6]\n<strong>输出：</strong>10\n<strong>解释：</strong>选择大小为 4 的披萨，Alice 和 Bob 分别挑选大小为 3 和 5 的披萨。然后你选择大小为 6 的披萨，Alice 和 Bob 分别挑选大小为 2 和 1 的披萨。你获得的披萨总大小为 4 + 6 = 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/sample_4_1723.png\" style=\"height: 250px; width: 475px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>slices = [8,9,8,6,1,1]\n<strong>输出：</strong>16\n<strong>解释：</strong>两轮都选大小为 8 的披萨。如果你选择大小为 9 的披萨，你的朋友们就会选择大小为 8 的披萨，这种情况下你的总和不是最大的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= slices.length &lt;= 500</code></li>\n\t<li><code>slices.length % 3 == 0</code></li>\n\t<li><code>1 &lt;= slices[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1389按既定顺序创建目标数组",
        "hardRate": "EASY",
        "passRate": "82.99%",
        "problemsUrl": "https://leetcode.cn/problems/create-target-array-in-the-given-order/",
        "solutionsUrl": "https://leetcode.cn/problems/create-target-array-in-the-given-order/solution",
        "problemsDesc": "<p>给你两个整数数组 <code>nums</code> 和 <code>index</code>。你需要按照以下规则创建目标数组：</p>\n\n<ul>\n\t<li>目标数组 <code>target</code> 最初为空。</li>\n\t<li>按从左到右的顺序依次读取 <code>nums[i]</code> 和 <code>index[i]</code>，在 <code>target</code> 数组中的下标 <code>index[i]</code> 处插入值 <code>nums[i]</code> 。</li>\n\t<li>重复上一步，直到在 <code>nums</code> 和 <code>index</code> 中都没有要读取的元素。</li>\n</ul>\n\n<p>请你返回目标数组。</p>\n\n<p>题目保证数字插入位置总是存在。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,2,3,4], index = [0,1,2,2,1]\n<strong>输出：</strong>[0,4,1,3,2]\n<strong>解释：</strong>\nnums       index     target\n0            0        [0]\n1            1        [0,1]\n2            2        [0,1,2]\n3            2        [0,1,3,2]\n4            1        [0,4,1,3,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,0], index = [0,1,2,3,0]\n<strong>输出：</strong>[0,1,2,3,4]\n<strong>解释：</strong>\nnums       index     target\n1            0        [1]\n2            1        [1,2]\n3            2        [1,2,3]\n4            3        [1,2,3,4]\n0            0        [0,1,2,3,4]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1], index = [0]\n<strong>输出：</strong>[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, index.length &lt;= 100</code></li>\n\t<li><code>nums.length == index.length</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>0 &lt;= index[i] &lt;= i</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1390四因数",
        "hardRate": "MEDIUM",
        "passRate": "38.91%",
        "problemsUrl": "https://leetcode.cn/problems/four-divisors/",
        "solutionsUrl": "https://leetcode.cn/problems/four-divisors/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>，请你返回该数组中恰有四个因数的这些整数的各因数之和。如果数组中不存在满足题意的整数，则返回 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [21,4,7]\n<strong>输出：</strong>32\n<strong>解释：</strong>\n21 有 4 个因数：1, 3, 7, 21\n4 有 3 个因数：1, 2, 4\n7 有 2 个因数：1, 7\n答案仅为 21 的所有因数的和。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [21,21]\n<strong>输出:</strong> 64\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,3,4,5]\n<strong>输出:</strong> 0</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1391检查网格中是否存在有效路径",
        "hardRate": "MEDIUM",
        "passRate": "41.98%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-there-is-a-valid-path-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-there-is-a-valid-path-in-a-grid/solution",
        "problemsDesc": "<p>给你一个 <em>m</em> x <em>n</em> 的网格 <code>grid</code>。网格里的每个单元都代表一条街道。<code>grid[i][j]</code> 的街道可以是：</p>\n\n<ul>\n\t<li><strong>1</strong> 表示连接左单元格和右单元格的街道。</li>\n\t<li><strong>2</strong> 表示连接上单元格和下单元格的街道。</li>\n\t<li><strong>3</strong>&nbsp;表示连接左单元格和下单元格的街道。</li>\n\t<li><strong>4</strong> 表示连接右单元格和下单元格的街道。</li>\n\t<li><strong>5</strong> 表示连接左单元格和上单元格的街道。</li>\n\t<li><strong>6</strong> 表示连接右单元格和上单元格的街道。</li>\n</ul>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/main.png\" style=\"height: 708px; width: 450px;\"></p>\n\n<p>你最开始从左上角的单元格 <code>(0,0)</code> 开始出发，网格中的「有效路径」是指从左上方的单元格 <code>(0,0)</code> 开始、一直到右下方的 <code>(m-1,n-1)</code> 结束的路径。<strong>该路径必须只沿着街道走</strong>。</p>\n\n<p><strong>注意：</strong>你 <strong>不能</strong> 变更街道。</p>\n\n<p>如果网格中存在有效的路径，则返回 <code>true</code>，否则返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/e1.png\" style=\"height: 311px; width: 455px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[2,4,3],[6,5,2]]\n<strong>输出：</strong>true\n<strong>解释：</strong>如图所示，你可以从 (0, 0) 开始，访问网格中的所有单元格并到达 (m - 1, n - 1) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/e2.png\" style=\"height: 293px; width: 455px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[1,2,1],[1,2,1]]\n<strong>输出：</strong>false\n<strong>解释：</strong>如图所示，单元格 (0, 0) 上的街道没有与任何其他单元格上的街道相连，你只会停在 (0, 0) 处。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[1,1,2]]\n<strong>输出：</strong>false\n<strong>解释：</strong>你会停在 (0, 1)，而且无法到达 (0, 2) 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[1,1,1,1,1,1,3]]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[2],[2],[2],[2],[2],[2],[6]]\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1392最长快乐前缀",
        "hardRate": "HARD",
        "passRate": "44.54%",
        "problemsUrl": "https://leetcode.cn/problems/longest-happy-prefix/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-happy-prefix/solution",
        "problemsDesc": "<p><strong>「快乐前缀」</strong>&nbsp;是在原字符串中既是&nbsp;<strong>非空</strong> 前缀也是后缀（不包括原字符串自身）的字符串。</p>\n\n<p>给你一个字符串 <code>s</code>，请你返回它的 <strong>最长快乐前缀</strong>。如果不存在满足题意的前缀，则返回一个空字符串<meta charset=\"UTF-8\" />&nbsp;<code>\"\"</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"level\"\n<strong>输出：</strong>\"l\"\n<strong>解释：</strong>不包括 s 自己，一共有 4 个前缀（\"l\", \"le\", \"lev\", \"leve\"）和 4 个后缀（\"l\", \"el\", \"vel\", \"evel\"）。最长的既是前缀也是后缀的字符串是 \"l\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ababab\"\n<strong>输出：</strong>\"abab\"\n<strong>解释：</strong>\"abab\" 是最长的既是前缀也是后缀的字符串。题目允许前后缀在原字符串中重叠。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 只含有小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1393股票的资本损益",
        "hardRate": "MEDIUM",
        "passRate": "83.77%",
        "problemsUrl": "https://leetcode.cn/problems/capital-gainloss/",
        "solutionsUrl": "https://leetcode.cn/problems/capital-gainloss/solution",
        "problemsDesc": "<p><code>Stocks</code>&nbsp;表：</p>\n\n<pre>+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| stock_name    | varchar |\n| operation     | enum    |\n| operation_day | int     |\n| price         | int     |\n+---------------+---------+\n(stock_name, day) 是这张表的主键\noperation 列使用的是一种枚举类型，包括：(&#39;Sell&#39;,&#39;Buy&#39;)\n此表的每一行代表了名为 stock_name 的某支股票在 operation_day 这一天的操作价格。\n保证股票的每次&#39;Sell&#39;操作前，都有相应的&#39;Buy&#39;操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个SQL查询来报告每支股票的资本损益。</p>\n\n<p>股票的资本损益是一次或多次买卖股票后的全部收益或损失。</p>\n\n<p>以任意顺序返回结果即可。</p>\n\n<p>SQL查询结果的格式如下例所示：</p>\n\n<pre><code>Stocks</code> 表:\n+---------------+-----------+---------------+--------+\n| stock_name    | operation | operation_day | price  |\n+---------------+-----------+---------------+--------+\n| Leetcode      | Buy       | 1             | 1000   |\n| Corona Masks  | Buy       | 2             | 10     |\n| Leetcode      | Sell      | 5             | 9000   |\n| Handbags      | Buy       | 17            | 30000  |\n| Corona Masks  | Sell      | 3             | 1010   |\n| Corona Masks  | Buy       | 4             | 1000   |\n| Corona Masks  | Sell      | 5             | 500    |\n| Corona Masks  | Buy       | 6             | 1000   |\n| Handbags      | Sell      | 29            | 7000   |\n| Corona Masks  | Sell      | 10            | 10000  |\n+---------------+-----------+---------------+--------+\n\nResult 表:\n+---------------+-------------------+\n| stock_name    | capital_gain_loss |\n+---------------+-------------------+\n| Corona Masks  | 9500              |\n| Leetcode      | 8000              |\n| Handbags      | -23000            |\n+---------------+-------------------+\nLeetcode 股票在第一天以1000美元的价格买入，在第五天以9000美元的价格卖出。资本收益=9000-1000=8000美元。\nHandbags 股票在第17天以30000美元的价格买入，在第29天以7000美元的价格卖出。资本损失=7000-30000=-23000美元。\nCorona Masks 股票在第1天以10美元的价格买入，在第3天以1010美元的价格卖出。在第4天以1000美元的价格再次购买，在第5天以500美元的价格出售。最后，它在第6天以1000美元的价格被买走，在第10天以10000美元的价格被卖掉。资本损益是每次（&rsquo;Buy&#39;-&gt;&#39;Sell&#39;）操作资本收益或损失的和=（1010-10）+（500-1000）+（10000-1000）=1000-500+9000=9500美元。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1394找出数组中的幸运数",
        "hardRate": "EASY",
        "passRate": "65.58%",
        "problemsUrl": "https://leetcode.cn/problems/find-lucky-integer-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-lucky-integer-in-an-array/solution",
        "problemsDesc": "<p>在整数数组中，如果一个整数的出现频次和它的数值大小相等，我们就称这个整数为「幸运数」。</p>\n\n<p>给你一个整数数组 <code>arr</code>，请你从中找出并返回一个幸运数。</p>\n\n<ul>\n\t<li>如果数组中存在多个幸运数，只需返回 <strong>最大</strong> 的那个。</li>\n\t<li>如果数组中不含幸运数，则返回 <strong>-1 </strong>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,2,3,4]\n<strong>输出：</strong>2\n<strong>解释：</strong>数组中唯一的幸运数是 2 ，因为数值 2 的出现频次也是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,2,3,3,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>1、2 以及 3 都是幸运数，只需要返回其中最大的 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,2,2,3,3]\n<strong>输出：</strong>-1\n<strong>解释：</strong>数组中不存在幸运数。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [5]\n<strong>输出：</strong>-1\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [7,7,7,7,7,7,7]\n<strong>输出：</strong>7\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 500</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1395统计作战单位数",
        "hardRate": "MEDIUM",
        "passRate": "71.30%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-teams/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-teams/solution",
        "problemsDesc": "<p> <code>n</code> 名士兵站成一排。每个士兵都有一个 <strong>独一无二</strong> 的评分 <code>rating</code> 。</p>\n\n<p>每 <strong>3</strong> 个士兵可以组成一个作战单位，分组规则如下：</p>\n\n<ul>\n\t<li>从队伍中选出下标分别为 <code>i</code>、<code>j</code>、<code>k</code> 的 3 名士兵，他们的评分分别为 <code>rating[i]</code>、<code>rating[j]</code>、<code>rating[k]</code></li>\n\t<li>作战单位需满足： <code>rating[i] < rating[j] < rating[k]</code> 或者 <code>rating[i] > rating[j] > rating[k]</code> ，其中  <code>0 <= i < j < k < n</code></li>\n</ul>\n\n<p>请你返回按上述条件可以组建的作战单位数量。每个士兵都可以是多个作战单位的一部分。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rating = [2,5,3,4,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>我们可以组建三个作战单位 (2,3,4)、(5,4,1)、(5,3,1) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rating = [2,1,3]\n<strong>输出：</strong>0\n<strong>解释：</strong>根据题目条件，我们无法组建作战单位。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>rating = [1,2,3,4]\n<strong>输出：</strong>4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == rating.length</code></li>\n\t<li><code>3 <= n <= 1000</code></li>\n\t<li><code>1 <= rating[i] <= 10^5</code></li>\n\t<li><code>rating</code> 中的元素都是唯一的</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1396设计地铁系统",
        "hardRate": "MEDIUM",
        "passRate": "41.92%",
        "problemsUrl": "https://leetcode.cn/problems/design-underground-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-underground-system/solution",
        "problemsDesc": "<p>地铁系统跟踪不同车站之间的乘客出行时间，并使用这一数据来计算从一站到另一站的平均时间。</p>\n\n<p>实现 <code>UndergroundSystem</code> 类：</p>\n\n<ul>\n\t<li><code>void checkIn(int id, string stationName, int t)</code>\n\n\t<ul>\n\t\t<li>通行卡 ID 等于 <code>id</code> 的乘客，在时间 <code>t</code> ，从 <code>stationName</code> 站进入</li>\n\t\t<li>乘客一次只能从一个站进入</li>\n\t</ul>\n\t</li>\n\t<li><code>void checkOut(int id, string stationName, int t)</code>\n\t<ul>\n\t\t<li>通行卡 ID 等于 <code>id</code> 的乘客，在时间 <code>t</code> ，从 <code>stationName</code> 站离开</li>\n\t</ul>\n\t</li>\n\t<li><code>double getAverageTime(string startStation, string endStation)</code>\n\t<ul>\n\t\t<li>返回从 <code>startStation</code> 站到 <code>endStation</code> 站的平均时间</li>\n\t\t<li>平均时间会根据截至目前所有从 <code>startStation</code> 站 <strong>直接</strong> 到达 <code>endStation</code> 站的行程进行计算，也就是从 <code>startStation</code> 站进入并从 <code>endStation</code> 离开的行程</li>\n\t\t<li>从 <code>startStation</code> 到 <code>endStation</code> 的行程时间与从 <code>endStation</code> 到 <code>startStation</code> 的行程时间可能不同</li>\n\t\t<li>在调用 <code>getAverageTime</code> 之前，至少有一名乘客从 <code>startStation</code> 站到达 <code>endStation</code> 站</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>你可以假设对 <code>checkIn</code> 和 <code>checkOut</code> 方法的所有调用都是符合逻辑的。如果一名乘客在时间 <code>t<sub>1</sub></code> 进站、时间 <code>t<sub>2</sub></code> 出站，那么 <code>t<sub>1</sub> &lt; t<sub>2</sub></code> 。所有时间都按时间顺序发生。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"]\n[[],[45,\"Leyton\",3],[32,\"Paradise\",8],[27,\"Leyton\",10],[45,\"Waterloo\",15],[27,\"Waterloo\",20],[32,\"Cambridge\",22],[\"Paradise\",\"Cambridge\"],[\"Leyton\",\"Waterloo\"],[10,\"Leyton\",24],[\"Leyton\",\"Waterloo\"],[10,\"Waterloo\",38],[\"Leyton\",\"Waterloo\"]]\n\n<strong>输出</strong>\n[null,null,null,null,null,null,null,14.00000,11.00000,null,11.00000,null,12.00000]\n\n<strong>解释</strong>\nUndergroundSystem undergroundSystem = new UndergroundSystem();\nundergroundSystem.checkIn(45, \"Leyton\", 3);\nundergroundSystem.checkIn(32, \"Paradise\", 8);\nundergroundSystem.checkIn(27, \"Leyton\", 10);\nundergroundSystem.checkOut(45, \"Waterloo\", 15);  // 乘客 45 \"Leyton\" -&gt; \"Waterloo\" ，用时 15-3 = 12\nundergroundSystem.checkOut(27, \"Waterloo\", 20);  // 乘客 27 \"Leyton\" -&gt; \"Waterloo\" ，用时 20-10 = 10\nundergroundSystem.checkOut(32, \"Cambridge\", 22); // 乘客 32 \"Paradise\" -&gt; \"Cambridge\" ，用时 22-8 = 14\nundergroundSystem.getAverageTime(\"Paradise\", \"Cambridge\"); // 返回 14.00000 。只有一个 \"Paradise\" -&gt; \"Cambridge\" 的行程，(14) / 1 = 14\nundergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\");    // 返回 11.00000 。有两个 \"Leyton\" -&gt; \"Waterloo\" 的行程，(10 + 12) / 2 = 11\nundergroundSystem.checkIn(10, \"Leyton\", 24);\nundergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\");    // 返回 11.00000\nundergroundSystem.checkOut(10, \"Waterloo\", 38);  // 乘客 10 \"Leyton\" -&gt; \"Waterloo\" ，用时 38-24 = 14\nundergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\");    // 返回 12.00000 。有三个 \"Leyton\" -&gt; \"Waterloo\" 的行程，(10 + 12 + 14) / 3 = 12\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[10,\"Leyton\",3],[10,\"Paradise\",8],[\"Leyton\",\"Paradise\"],[5,\"Leyton\",10],[5,\"Paradise\",16],[\"Leyton\",\"Paradise\"],[2,\"Leyton\",21],[2,\"Paradise\",30],[\"Leyton\",\"Paradise\"]]\n\n<strong>输出</strong>\n[null,null,null,5.00000,null,null,5.50000,null,null,6.66667]\n\n<strong>解释</strong>\nUndergroundSystem undergroundSystem = new UndergroundSystem();\nundergroundSystem.checkIn(10, \"Leyton\", 3);\nundergroundSystem.checkOut(10, \"Paradise\", 8); // 乘客 10 \"Leyton\" -&gt; \"Paradise\" ，用时 8-3 = 5\nundergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // 返回 5.00000 ，(5) / 1 = 5\nundergroundSystem.checkIn(5, \"Leyton\", 10);\nundergroundSystem.checkOut(5, \"Paradise\", 16); // 乘客 5 \"Leyton\" -&gt; \"Paradise\" ，用时 16-10 = 6\nundergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // 返回 5.50000 ，(5 + 6) / 2 = 5.5\nundergroundSystem.checkIn(2, \"Leyton\", 21);\nundergroundSystem.checkOut(2, \"Paradise\", 30); // 乘客 2 \"Leyton\" -&gt; \"Paradise\" ，用时 30-21 = 9\nundergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // 返回 6.66667 ，(5 + 6 + 9) / 3 = 6.66667\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= id, t &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= stationName.length, startStation.length, endStation.length &lt;= 10</code> 次</li>\n\t<li>所有字符串由大小写英文字母与数字组成</li>\n\t<li>总共最多调用 <code>checkIn</code>、<code>checkOut</code> 和 <code>getAverageTime</code> 方法 <code>2 * 10<sup>4 </sup></code></li>\n\t<li>与标准答案误差在 <code>10<sup>-5</sup></code> 以内的结果都被视为正确结果</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1397找到所有好字符串",
        "hardRate": "HARD",
        "passRate": "43.73%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-good-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-good-strings/solution",
        "problemsDesc": "<p>给你两个长度为 <code>n</code>&nbsp;的字符串&nbsp;<code>s1</code> 和&nbsp;<code>s2</code>&nbsp;，以及一个字符串&nbsp;<code>evil</code>&nbsp;。请你返回 <strong>好字符串&nbsp;</strong>的数目。</p>\n\n<p><strong>好字符串</strong>&nbsp;的定义为：它的长度为&nbsp;<code>n</code>&nbsp;，字典序大于等于&nbsp;<code>s1</code>&nbsp;，字典序小于等于&nbsp;<code>s2</code>&nbsp;，且不包含&nbsp;<code>evil</code>&nbsp;为子字符串。</p>\n\n<p>由于答案可能很大，请你返回答案对 10^9 + 7 取余的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, s1 = &quot;aa&quot;, s2 = &quot;da&quot;, evil = &quot;b&quot;\n<strong>输出：</strong>51 \n<strong>解释：</strong>总共有 25 个以 &#39;a&#39; 开头的好字符串：&quot;aa&quot;，&quot;ac&quot;，&quot;ad&quot;，...，&quot;az&quot;。还有 25 个以 &#39;c&#39; 开头的好字符串：&quot;ca&quot;，&quot;cc&quot;，&quot;cd&quot;，...，&quot;cz&quot;。最后，还有一个以 &#39;d&#39; 开头的好字符串：&quot;da&quot;。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 8, s1 = &quot;leetcode&quot;, s2 = &quot;leetgoes&quot;, evil = &quot;leet&quot;\n<strong>输出：</strong>0 \n<strong>解释：</strong>所有字典序大于等于 s1 且小于等于 s2 的字符串都以 evil 字符串 &quot;leet&quot; 开头。所以没有好字符串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, s1 = &quot;gx&quot;, s2 = &quot;gz&quot;, evil = &quot;x&quot;\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s1.length == n</code></li>\n\t<li><code>s2.length == n</code></li>\n\t<li><code>s1 &lt;= s2</code></li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= evil.length &lt;= 50</code></li>\n\t<li>所有字符串都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1398购买了产品 A 和产品 B 却没有购买产品 C 的顾客",
        "hardRate": "MEDIUM",
        "passRate": "72.15%",
        "problemsUrl": "https://leetcode.cn/problems/customers-who-bought-products-a-and-b-but-not-c/",
        "solutionsUrl": "https://leetcode.cn/problems/customers-who-bought-products-a-and-b-but-not-c/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1399统计最大组的数目",
        "hardRate": "EASY",
        "passRate": "67.04%",
        "problemsUrl": "https://leetcode.cn/problems/count-largest-group/",
        "solutionsUrl": "https://leetcode.cn/problems/count-largest-group/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code>&nbsp;。请你先求出从 <code>1</code>&nbsp;到 <code>n</code> 的每个整数 10 进制表示下的数位和（每一位上的数字相加），然后把数位和相等的数字放到同一个组中。</p>\n\n<p>请你统计每个组中的数字数目，并返回数字数目并列最多的组有多少个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 13\n<strong>输出：</strong>4\n<strong>解释：</strong>总共有 9 个组，将 1 到 13 按数位求和后这些组分别是：\n[1,10]，[2,11]，[3,12]，[4,13]，[5]，[6]，[7]，[8]，[9]。总共有 4 个组拥有的数字并列最多。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>总共有 2 个大小为 1 的组 [1]，[2]。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 15\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 24\n<strong>输出：</strong>5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1400构造 K 个回文字符串",
        "hardRate": "MEDIUM",
        "passRate": "61.30%",
        "problemsUrl": "https://leetcode.cn/problems/construct-k-palindrome-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-k-palindrome-strings/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code>&nbsp;和一个整数 <code>k</code>&nbsp;。请你用 <code>s</code>&nbsp;字符串中 <strong>所有字符</strong>&nbsp;构造 <code>k</code>&nbsp;个非空 <strong>回文串</strong>&nbsp;。</p>\n\n<p>如果你可以用&nbsp;<code>s</code>&nbsp;中所有字符构造&nbsp;<code>k</code>&nbsp;个回文字符串，那么请你返回 <strong>True</strong>&nbsp;，否则返回&nbsp;<strong>False</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;annabelle&quot;, k = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>可以用 s 中所有字符构造 2 个回文字符串。\n一些可行的构造方案包括：&quot;anna&quot; + &quot;elble&quot;，&quot;anbna&quot; + &quot;elle&quot;，&quot;anellena&quot; + &quot;b&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;leetcode&quot;, k = 3\n<strong>输出：</strong>false\n<strong>解释：</strong>无法用 s 中所有字符构造 3 个回文串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;true&quot;, k = 4\n<strong>输出：</strong>true\n<strong>解释：</strong>唯一可行的方案是让 s 中每个字符单独构成一个字符串。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;yzyzyzyzyzyzyzy&quot;, k = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>你只需要将所有的 z 放在一个字符串中，所有的 y 放在另一个字符串中。那么两个字符串都是回文串。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;cr&quot;, k = 7\n<strong>输出：</strong>false\n<strong>解释：</strong>我们没有足够的字符去构造 7 个回文串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>s</code>&nbsp;中所有字符都是小写英文字母。</li>\n\t<li><code>1 &lt;= k &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1401圆和矩形是否有重叠",
        "hardRate": "MEDIUM",
        "passRate": "51.69%",
        "problemsUrl": "https://leetcode.cn/problems/circle-and-rectangle-overlapping/",
        "solutionsUrl": "https://leetcode.cn/problems/circle-and-rectangle-overlapping/solution",
        "problemsDesc": "<p>给你一个以 <code>(radius, xCenter, yCenter)</code> 表示的圆和一个与坐标轴平行的矩形 <code>(x1, y1, x2, y2)</code> ，其中 <code>(x1, y1)</code> 是矩形左下角的坐标，而 <code>(x2, y2)</code> 是右上角的坐标。</p>\n\n<p>如果圆和矩形有重叠的部分，请你返回 <code>true</code> ，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>换句话说，请你检测是否 <strong>存在</strong> 点 <code>(x<sub>i</sub>, y<sub>i</sub>)</code> ，它既在圆上也在矩形上（两者都包括点落在边界上的情况）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1 ：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/20/sample_4_1728.png\" style=\"width: 258px; height: 167px;\" />\n<pre>\n<strong>输入：</strong>radius = 1, xCenter = 0, yCenter = 0, x1 = 1, y1 = -1, x2 = 3, y2 = 1\n<strong>输出：</strong>true\n<strong>解释：</strong>圆和矩形存在公共点 (1,0) 。\n</pre>\n\n<p><strong class=\"example\">示例 2 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>radius = 1, xCenter = 1, yCenter = 1, x1 = 1, y1 = -3, x2 = 2, y2 = -1\n<strong>输出：</strong>false\n</pre>\n\n<p><strong class=\"example\">示例 3 ：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/20/sample_2_1728.png\" style=\"width: 150px; height: 135px;\" />\n<pre>\n<strong>输入：</strong>radius = 1, xCenter = 0, yCenter = 0, x1 = -1, y1 = 0, x2 = 0, y2 = 1\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= radius &lt;= 2000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= xCenter, yCenter &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= x1 &lt; x2 &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= y1 &lt; y2 &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1402做菜顺序",
        "hardRate": "HARD",
        "passRate": "76.08%",
        "problemsUrl": "https://leetcode.cn/problems/reducing-dishes/",
        "solutionsUrl": "https://leetcode.cn/problems/reducing-dishes/solution",
        "problemsDesc": "<p>一个厨师收集了他&nbsp;<code>n</code>&nbsp;道菜的满意程度&nbsp;<code>satisfaction</code>&nbsp;，这个厨师做出每道菜的时间都是 1 单位时间。</p>\n\n<p>一道菜的 「喜爱时间」系数定义为烹饪这道菜以及之前每道菜所花费的时间乘以这道菜的满意程度，也就是&nbsp;<code>time[i]</code>*<code>satisfaction[i]</code>&nbsp;。</p>\n\n<p>请你返回做完所有菜 「喜爱时间」总和的最大值为多少。</p>\n\n<p>你可以按&nbsp;<strong>任意</strong>&nbsp;顺序安排做菜的顺序，你也可以选择放弃做某些菜来获得更大的总和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>satisfaction = [-1,-8,0,5,-9]\n<strong>输出：</strong>14\n<strong>解释：</strong>去掉第二道和最后一道菜，最大的喜爱时间系数和为 (-1*1 + 0*2 + 5*3 = 14) 。每道菜都需要花费 1 单位时间完成。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>satisfaction = [4,3,2]\n<strong>输出：</strong>20\n<strong>解释：</strong>按照原来顺序相反的时间做菜 (2*1 + 3*2 + 4*3 = 20)\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>satisfaction = [-1,-4,-5]\n<strong>输出：</strong>0\n<strong>解释：</strong>大家都不喜欢这些菜，所以不做任何菜可以获得最大的喜爱时间系数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == satisfaction.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>-1000 &lt;= satisfaction[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1403非递增顺序的最小子序列",
        "hardRate": "EASY",
        "passRate": "73.33%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-subsequence-in-non-increasing-order/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-subsequence-in-non-increasing-order/solution",
        "problemsDesc": "<p>给你一个数组 <code>nums</code>，请你从中抽取一个子序列，满足该子序列的元素之和 <strong>严格</strong> 大于未包含在该子序列中的各元素之和。</p>\n\n<p>如果存在多个解决方案，只需返回 <strong>长度最小</strong> 的子序列。如果仍然有多个解决方案，则返回 <strong>元素之和最大</strong> 的子序列。</p>\n\n<p>与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。</p>\n\n<p><strong>注意</strong>，题目数据保证满足所有约束条件的解决方案是 <strong>唯一</strong> 的。同时，返回的答案应当按 <strong>非递增顺序</strong> 排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,3,10,9,8]\n<strong>输出：</strong>[10,9] \n<strong>解释：</strong>子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。&nbsp;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,4,7,6,7]\n<strong>输出：</strong>[7,7,6] \n<strong>解释：</strong>子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。  \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [6]\n<strong>输出：</strong>[6]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1404将二进制表示减到 1 的步骤数",
        "hardRate": "MEDIUM",
        "passRate": "50.91%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/solution",
        "problemsDesc": "<p>给你一个以二进制形式表示的数字 <code>s</code> 。请你返回按下述规则将其减少到 1 所需要的步骤数：</p>\n\n<ul>\n\t<li>\n\t<p>如果当前数字为偶数，则将其除以 2 。</p>\n\t</li>\n\t<li>\n\t<p>如果当前数字为奇数，则将其加上 1 。</p>\n\t</li>\n</ul>\n\n<p>题目保证你总是可以按上述规则将测试用例变为 1 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1101&quot;\n<strong>输出：</strong>6\n<strong>解释：</strong>&quot;1101&quot; 表示十进制数 13 。\nStep 1) 13 是奇数，加 1 得到 14&nbsp;\nStep 2) 14 是偶数，除 2 得到 7\nStep 3) 7  是奇数，加 1 得到 8\nStep 4) 8  是偶数，除 2 得到 4&nbsp; \nStep 5) 4  是偶数，除 2 得到 2&nbsp;\nStep 6) 2  是偶数，除 2 得到 1&nbsp; \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;10&quot;\n<strong>输出：</strong>1\n<strong>解释：</strong>&quot;10&quot; 表示十进制数 2 。\nStep 1) 2 是偶数，除 2 得到 1 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1&quot;\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length&nbsp;&lt;= 500</code></li>\n\t<li><code>s</code> 由字符 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code> 组成。</li>\n\t<li><code>s[0] == &#39;1&#39;</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1405最长快乐字符串",
        "hardRate": "MEDIUM",
        "passRate": "63.56%",
        "problemsUrl": "https://leetcode.cn/problems/longest-happy-string/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-happy-string/solution",
        "problemsDesc": "<p>如果字符串中不含有任何 <code>&#39;aaa&#39;</code>，<code>&#39;bbb&#39;</code> 或 <code>&#39;ccc&#39;</code> 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。</p>\n\n<p>给你三个整数 <code>a</code>，<code>b</code> ，<code>c</code>，请你返回 <strong>任意一个</strong> 满足下列全部条件的字符串 <code>s</code>：</p>\n\n<ul>\n\t<li><code>s</code> 是一个尽可能长的快乐字符串。</li>\n\t<li><code>s</code> 中 <strong>最多</strong> 有<code>a</code> 个字母 <code>&#39;a&#39;</code>、<code>b</code>&nbsp;个字母 <code>&#39;b&#39;</code>、<code>c</code> 个字母 <code>&#39;c&#39;</code> 。</li>\n\t<li><code>s </code>中只含有 <code>&#39;a&#39;</code>、<code>&#39;b&#39;</code> 、<code>&#39;c&#39;</code> 三种字母。</li>\n</ul>\n\n<p>如果不存在这样的字符串 <code>s</code> ，请返回一个空字符串 <code>&quot;&quot;</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>a = 1, b = 1, c = 7\n<strong>输出：</strong>&quot;ccaccbcc&quot;\n<strong>解释：</strong>&quot;ccbccacc&quot; 也是一种正确答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>a = 2, b = 2, c = 1\n<strong>输出：</strong>&quot;aabbc&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>a = 7, b = 1, c = 0\n<strong>输出：</strong>&quot;aabaa&quot;\n<strong>解释：</strong>这是该测试用例的唯一正确答案。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= a, b, c &lt;= 100</code></li>\n\t<li><code>a + b + c &gt; 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1406石子游戏 III",
        "hardRate": "HARD",
        "passRate": "59.18%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game-iii/solution",
        "problemsDesc": "<p>Alice 和 Bob 继续他们的石子游戏。几堆石子 <strong>排成一行</strong> ，每堆石子都对应一个得分，由数组 <code>stoneValue</code> 给出。</p>\n\n<p>Alice 和 Bob 轮流取石子，<strong>Alice</strong> 总是先开始。在每个玩家的回合中，该玩家可以拿走剩下石子中的的前 <strong>1、2 或 3 堆石子</strong> 。比赛一直持续到所有石头都被拿走。</p>\n\n<p>每个玩家的最终得分为他所拿到的每堆石子的对应得分之和。每个玩家的初始分数都是 <strong>0</strong> 。</p>\n\n<p>比赛的目标是决出最高分，得分最高的选手将会赢得比赛，比赛也可能会出现平局。</p>\n\n<p>假设 Alice 和 Bob 都采取 <strong>最优策略</strong> 。</p>\n\n<p>如果 Alice 赢了就返回 <code>\"Alice\"</code> <em>，</em>Bob 赢了就返回<em> </em><code>\"Bob\"</code><em>，</em>分数相同返回 <code>\"Tie\"</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>values = [1,2,3,7]\n<strong>输出：</strong>\"Bob\"\n<strong>解释：</strong>Alice 总是会输，她的最佳选择是拿走前三堆，得分变成 6 。但是 Bob 的得分为 7，Bob 获胜。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>values = [1,2,3,-9]\n<strong>输出：</strong>\"Alice\"\n<strong>解释：</strong>Alice 要想获胜就必须在第一个回合拿走前三堆石子，给 Bob 留下负分。\n如果 Alice 只拿走第一堆，那么她的得分为 1，接下来 Bob 拿走第二、三堆，得分为 5 。之后 Alice 只能拿到分数 -9 的石子堆，输掉比赛。\n如果 Alice 拿走前两堆，那么她的得分为 3，接下来 Bob 拿走第三堆，得分为 3 。之后 Alice 只能拿到分数 -9 的石子堆，同样会输掉比赛。\n注意，他们都应该采取 <strong>最优策略 </strong>，所以在这里 Alice 将选择能够使她获胜的方案。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>values = [1,2,3,6]\n<strong>输出：</strong>\"Tie\"\n<strong>解释：</strong>Alice 无法赢得比赛。如果她决定选择前三堆，她可以以平局结束比赛，否则她就会输。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= stoneValue.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-1000&nbsp;&lt;= stoneValue[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1407排名靠前的旅行者",
        "hardRate": "EASY",
        "passRate": "56.78%",
        "problemsUrl": "https://leetcode.cn/problems/top-travellers/",
        "solutionsUrl": "https://leetcode.cn/problems/top-travellers/solution",
        "problemsDesc": "<p>表：<code>Users</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| name          | varchar |\n+---------------+---------+\nid 是该表单主键。\nname 是用户名字。</pre>\n\n<p> </p>\n\n<p>表：<code>Rides</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| user_id       | int     |\n| distance      | int     |\n+---------------+---------+\nid 是该表单主键。\nuser_id 是本次行程的用户的 id, 而该用户此次行程距离为 distance 。\n</pre>\n\n<p> </p>\n\n<p>写一段 SQL , 报告每个用户的旅行距离。</p>\n\n<p>返回的结果表单，以 <code>travelled_distance</code> <strong>降序排列</strong> ，如果有两个或者更多的用户旅行了相同的距离, 那么再以 <code>name</code> <strong>升序排列</strong> 。</p>\n\n<p>查询结果格式如下例所示。</p>\n\n<pre>\nUsers 表：\n+------+-----------+\n| id   | name      |\n+------+-----------+\n| 1    | Alice     |\n| 2    | Bob       |\n| 3    | Alex      |\n| 4    | Donald    |\n| 7    | Lee       |\n| 13   | Jonathan  |\n| 19   | Elvis     |\n+------+-----------+\n\nRides 表：\n+------+----------+----------+\n| id   | user_id  | distance |\n+------+----------+----------+\n| 1    | 1        | 120      |\n| 2    | 2        | 317      |\n| 3    | 3        | 222      |\n| 4    | 7        | 100      |\n| 5    | 13       | 312      |\n| 6    | 19       | 50       |\n| 7    | 7        | 120      |\n| 8    | 19       | 400      |\n| 9    | 7        | 230      |\n+------+----------+----------+\n\nResult 表：\n+----------+--------------------+\n| name     | travelled_distance |\n+----------+--------------------+\n| Elvis    | 450                |\n| Lee      | 450                |\n| Bob      | 317                |\n| Jonathan | 312                |\n| Alex     | 222                |\n| Alice    | 120                |\n| Donald   | 0                  |\n+----------+--------------------+\nElvis 和 Lee 旅行了 450 英里，Elvis 是排名靠前的旅行者，因为他的名字在字母表上的排序比 Lee 更小。\nBob, Jonathan, Alex 和 Alice 只有一次行程，我们只按此次行程的全部距离对他们排序。\nDonald 没有任何行程, 他的旅行距离为 0。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1408数组中的字符串匹配",
        "hardRate": "EASY",
        "passRate": "64.38%",
        "problemsUrl": "https://leetcode.cn/problems/string-matching-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/string-matching-in-an-array/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>words</code> ，数组中的每个字符串都可以看作是一个单词。请你按 <strong>任意</strong> 顺序返回 <code>words</code> 中是其他单词的子字符串的所有单词。</p>\n\n<p>如果你可以删除 <code>words[j]</code>&nbsp;最左侧和/或最右侧的若干字符得到 <code>words[i]</code> ，那么字符串 <code>words[i]</code> 就是 <code>words[j]</code> 的一个子字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"mass\",\"as\",\"hero\",\"superhero\"]\n<strong>输出：</strong>[\"as\",\"hero\"]\n<strong>解释：</strong>\"as\" 是 \"mass\" 的子字符串，\"hero\" 是 \"superhero\" 的子字符串。\n[\"hero\",\"as\"] 也是有效的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"leetcode\",\"et\",\"code\"]\n<strong>输出：</strong>[\"et\",\"code\"]\n<strong>解释：</strong>\"et\" 和 \"code\" 都是 \"leetcode\" 的子字符串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"blue\",\"green\",\"bu\"]\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li><code>words[i]</code> 仅包含小写英文字母。</li>\n\t<li>题目数据 <strong>保证</strong> 每个 <code>words[i]</code> 都是独一无二的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1409查询带键的排列",
        "hardRate": "MEDIUM",
        "passRate": "81.38%",
        "problemsUrl": "https://leetcode.cn/problems/queries-on-a-permutation-with-key/",
        "solutionsUrl": "https://leetcode.cn/problems/queries-on-a-permutation-with-key/solution",
        "problemsDesc": "<p>给你一个待查数组 <code>queries</code> ，数组中的元素为 <code>1</code> 到 <code>m</code> 之间的正整数。 请你根据以下规则处理所有待查项 <code>queries[i]</code>（从 <code>i=0</code> 到 <code>i=queries.length-1</code>）：</p>\n\n<ul>\n\t<li>一开始，排列 <code>P=[1,2,3,...,m]</code>。</li>\n\t<li>对于当前的 <code>i</code> ，请你找出待查项 <code>queries[i]</code> 在排列 <code>P</code> 中的位置（<strong>下标从 0 开始</strong>），然后将其从原位置移动到排列 <code>P</code> 的起始位置（即下标为 0 处）。注意， <code>queries[i]</code> 在 <code>P</code> 中的位置就是 <code>queries[i]</code> 的查询结果。</li>\n</ul>\n\n<p>请你以数组形式返回待查数组&nbsp; <code>queries</code> 的查询结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>queries = [3,1,2,1], m = 5\n<strong>输出：</strong>[2,1,2,1] \n<strong>解释：</strong>待查数组 queries 处理如下：\n对于 i=0: queries[i]=3, P=[1,2,3,4,5], 3 在 P 中的位置是 <strong>2</strong>，接着我们把 3 移动到 P 的起始位置，得到 P=[3,1,2,4,5] 。\n对于 i=1: queries[i]=1, P=[3,1,2,4,5], 1 在 P 中的位置是 <strong>1</strong>，接着我们把 1 移动到 P 的起始位置，得到 P=[1,3,2,4,5] 。 \n对于 i=2: queries[i]=2, P=[1,3,2,4,5], 2 在 P 中的位置是 <strong>2</strong>，接着我们把 2 移动到 P 的起始位置，得到 P=[2,1,3,4,5] 。\n对于 i=3: queries[i]=1, P=[2,1,3,4,5], 1 在 P 中的位置是 <strong>1</strong>，接着我们把 1 移动到 P 的起始位置，得到 P=[1,2,3,4,5] 。 \n因此，返回的结果数组为 [2,1,2,1] 。  \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>queries = [4,1,2,2], m = 4\n<strong>输出：</strong>[3,1,2,0]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>queries = [7,5,5,8,3], m = 8\n<strong>输出：</strong>[6,5,0,7,5]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m &lt;= 10^3</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= m</code></li>\n\t<li><code>1 &lt;= queries[i] &lt;= m</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1410HTML 实体解析器",
        "hardRate": "MEDIUM",
        "passRate": "46.99%",
        "problemsUrl": "https://leetcode.cn/problems/html-entity-parser/",
        "solutionsUrl": "https://leetcode.cn/problems/html-entity-parser/solution",
        "problemsDesc": "<p>「HTML&nbsp;实体解析器」 是一种特殊的解析器，它将 HTML 代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。</p>\n\n<p>HTML 里这些特殊字符和它们对应的字符实体包括：</p>\n\n<ul>\n\t<li><strong>双引号：</strong>字符实体为&nbsp;<code>&amp;quot;</code>&nbsp;，对应的字符是&nbsp;<code>&quot;</code>&nbsp;。</li>\n\t<li><strong>单引号：</strong>字符实体为&nbsp;<code>&amp;apos;</code>&nbsp;，对应的字符是&nbsp;<code>&#39;</code>&nbsp;。</li>\n\t<li><strong>与符号：</strong>字符实体为&nbsp;<code>&amp;amp;</code>&nbsp;，对应对的字符是&nbsp;<code>&amp;</code>&nbsp;。</li>\n\t<li><strong>大于号：</strong>字符实体为&nbsp;<code>&amp;gt;</code>&nbsp;，对应的字符是&nbsp;<code>&gt;</code>&nbsp;。</li>\n\t<li><strong>小于号：</strong>字符实体为&nbsp;<code>&amp;lt;</code>&nbsp;，对应的字符是&nbsp;<code>&lt;</code>&nbsp;。</li>\n\t<li><strong>斜线号：</strong>字符实体为&nbsp;<code>&amp;frasl;</code>&nbsp;，对应的字符是&nbsp;<code>/</code>&nbsp;。</li>\n</ul>\n\n<p>给你输入字符串&nbsp;<code>text</code>&nbsp;，请你实现一个 HTML&nbsp;实体解析器，返回解析器解析后的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = &quot;&amp;amp; is an HTML entity but &amp;ambassador; is not.&quot;\n<strong>输出：</strong>&quot;&amp; is an HTML entity but &amp;ambassador; is not.&quot;\n<strong>解释：</strong>解析器把字符实体 &amp;amp; 用 &amp; 替换\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = &quot;and I quote: &amp;quot;...&amp;quot;&quot;\n<strong>输出：</strong>&quot;and I quote: \\&quot;...\\&quot;&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = &quot;Stay home! Practice on Leetcode :)&quot;\n<strong>输出：</strong>&quot;Stay home! Practice on Leetcode :)&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = &quot;x &amp;gt; y &amp;amp;&amp;amp; x &amp;lt; y is always false&quot;\n<strong>输出：</strong>&quot;x &gt; y &amp;&amp; x &lt; y is always false&quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = &quot;leetcode.com&amp;frasl;problemset&amp;frasl;all&quot;\n<strong>输出：</strong>&quot;leetcode.com/problemset/all&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 10^5</code></li>\n\t<li>字符串可能包含 256 个ASCII 字符中的任意字符。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1411给 N x 3 网格图涂色的方案数",
        "hardRate": "HARD",
        "passRate": "57.19%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-paint-n-3-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-paint-n-3-grid/solution",
        "problemsDesc": "<p>你有一个 <code>n x 3</code>&nbsp;的网格图 <code>grid</code>&nbsp;，你需要用 <strong>红，黄，绿</strong>&nbsp;三种颜色之一给每一个格子上色，且确保相邻格子颜色不同（也就是有相同水平边或者垂直边的格子颜色不同）。</p>\n\n<p>给你网格图的行数 <code>n</code>&nbsp;。</p>\n\n<p>请你返回给&nbsp;<code>grid</code>&nbsp;涂色的方案数。由于答案可能会非常大，请你返回答案对&nbsp;<code>10^9 + 7</code>&nbsp;取余的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>12\n<strong>解释：</strong>总共有 12 种可行的方法：\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/12/e1.png\" style=\"height: 289px; width: 450px;\">\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>54\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 3\n<strong>输出：</strong>246\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 7\n<strong>输出：</strong>106494\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>n = 5000\n<strong>输出：</strong>30228214\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>grid[i].length == 3</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1412查找成绩处于中游的学生",
        "hardRate": "HARD",
        "passRate": "54.41%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-quiet-students-in-all-exams/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-quiet-students-in-all-exams/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1413逐步求和得到正数的最小值",
        "hardRate": "EASY",
        "passRate": "73.05%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-value-to-get-positive-step-by-step-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-value-to-get-positive-step-by-step-sum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>&nbsp;。你可以选定任意的&nbsp;<strong>正数</strong> startValue 作为初始值。</p>\n\n<p>你需要从左到右遍历 <code>nums</code>&nbsp;数组，并将 startValue 依次累加上&nbsp;<code>nums</code>&nbsp;数组中的值。</p>\n\n<p>请你在确保累加和始终大于等于 1 的前提下，选出一个最小的&nbsp;<strong>正数</strong>&nbsp;作为 startValue 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-3,2,-3,4,2]\n<strong>输出：</strong>5\n<strong>解释：</strong>如果你选择 startValue = 4，在第三次累加时，和小于 1 。\n<strong>                累加求和\n&nbsp;               startValue = 4 | startValue = 5 | nums\n</strong>&nbsp;                 (4 <strong>-3</strong> ) = 1  | (5 <strong>-3</strong> ) = 2    |  -3\n&nbsp;                 (1 <strong>+2</strong> ) = 3  | (2 <strong>+2</strong> ) = 4    |   2\n&nbsp;                 (3 <strong>-3</strong> ) = 0  | (4 <strong>-3</strong> ) = 1    |  -3\n&nbsp;                 (0 <strong>+4</strong> ) = 4  | (1 <strong>+4</strong> ) = 5    |   4\n&nbsp;                 (4 <strong>+2</strong> ) = 6  | (5 <strong>+2</strong> ) = 7    |   2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>最小的 startValue 需要是正数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,-2,-3]\n<strong>输出：</strong>5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1414和为 K 的最少斐波那契数字数目",
        "hardRate": "MEDIUM",
        "passRate": "70.36%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/solution",
        "problemsDesc": "<p>给你数字 <code>k</code>&nbsp;，请你返回和为&nbsp;<code>k</code>&nbsp;的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。</p>\n\n<p>斐波那契数字定义为：</p>\n\n<ul>\n\t<li>F<sub>1</sub> = 1</li>\n\t<li>F<sub>2</sub> = 1</li>\n\t<li>F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub>&nbsp;， 其中 n &gt; 2 。</li>\n</ul>\n\n<p>数据保证对于给定的 <code>k</code>&nbsp;，一定能找到可行解。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>k = 7\n<strong>输出：</strong>2 \n<strong>解释：</strong>斐波那契数字为：1，1，2，3，5，8，13，&hellip;&hellip;\n对于 k = 7 ，我们可以得到 2 + 5 = 7 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>k = 10\n<strong>输出：</strong>2 \n<strong>解释：</strong>对于 k = 10 ，我们可以得到 2 + 8 = 10 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>k = 19\n<strong>输出：</strong>3 \n<strong>解释：</strong>对于 k = 19 ，我们可以得到 1 + 5 + 13 = 19 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1415长度为 n 的开心字符串中字典序第 k 小的字符串",
        "hardRate": "MEDIUM",
        "passRate": "68.61%",
        "problemsUrl": "https://leetcode.cn/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/",
        "solutionsUrl": "https://leetcode.cn/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/solution",
        "problemsDesc": "<p>一个 「开心字符串」定义为：</p>\n\n<ul>\n\t<li>仅包含小写字母&nbsp;<code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code>.</li>\n\t<li>对所有在&nbsp;<code>1</code>&nbsp;到&nbsp;<code>s.length - 1</code>&nbsp;之间的&nbsp;<code>i</code>&nbsp;，满足&nbsp;<code>s[i] != s[i + 1]</code>&nbsp;（字符串的下标从 1 开始）。</li>\n</ul>\n\n<p>比方说，字符串&nbsp;<strong>&quot;abc&quot;</strong>，<strong>&quot;ac&quot;，&quot;b&quot;</strong> 和&nbsp;<strong>&quot;abcbabcbcb&quot;</strong>&nbsp;都是开心字符串，但是&nbsp;<strong>&quot;aa&quot;</strong>，<strong>&quot;baa&quot;</strong>&nbsp;和&nbsp;<strong>&quot;ababbc&quot;</strong>&nbsp;都不是开心字符串。</p>\n\n<p>给你两个整数 <code>n</code>&nbsp;和 <code>k</code>&nbsp;，你需要将长度为 <code>n</code>&nbsp;的所有开心字符串按字典序排序。</p>\n\n<p>请你返回排序后的第 k 个开心字符串，如果长度为 <code>n</code>&nbsp;的开心字符串少于 <code>k</code>&nbsp;个，那么请你返回 <strong>空字符串</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 1, k = 3\n<strong>输出：</strong>&quot;c&quot;\n<strong>解释：</strong>列表 [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 包含了所有长度为 1 的开心字符串。按照字典序排序后第三个字符串为 &quot;c&quot; 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 1, k = 4\n<strong>输出：</strong>&quot;&quot;\n<strong>解释：</strong>长度为 1 的开心字符串只有 3 个。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 3, k = 9\n<strong>输出：</strong>&quot;cab&quot;\n<strong>解释：</strong>长度为 3 的开心字符串总共有 12 个 [&quot;aba&quot;, &quot;abc&quot;, &quot;aca&quot;, &quot;acb&quot;, &quot;bab&quot;, &quot;bac&quot;, &quot;bca&quot;, &quot;bcb&quot;, &quot;cab&quot;, &quot;cac&quot;, &quot;cba&quot;, &quot;cbc&quot;] 。第 9 个字符串为 &quot;cab&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, k = 7\n<strong>输出：</strong>&quot;&quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>n = 10, k = 100\n<strong>输出：</strong>&quot;abacbabacb&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10</code></li>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1416恢复数组",
        "hardRate": "HARD",
        "passRate": "42.69%",
        "problemsUrl": "https://leetcode.cn/problems/restore-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/restore-the-array/solution",
        "problemsDesc": "<p>某个程序本来应该输出一个整数数组。但是这个程序忘记输出空格了以致输出了一个数字字符串，我们所知道的信息只有：数组中所有整数都在 <code>[1, k]</code>&nbsp;之间，且数组中的数字都没有前导 0 。</p>\n\n<p>给你字符串&nbsp;<code>s</code>&nbsp;和整数&nbsp;<code>k</code>&nbsp;。可能会有多种不同的数组恢复结果。</p>\n\n<p>按照上述程序，请你返回所有可能输出字符串&nbsp;<code>s</code>&nbsp;的数组方案数。</p>\n\n<p>由于数组方案数可能会很大，请你返回它对&nbsp;<code>10^9 + 7</code>&nbsp;<strong>取余</strong>&nbsp;后的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1000&quot;, k = 10000\n<strong>输出：</strong>1\n<strong>解释：</strong>唯一一种可能的数组方案是 [1000]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1000&quot;, k = 10\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在任何数组方案满足所有整数都 &gt;= 1 且 &lt;= 10 同时输出结果为 s 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1317&quot;, k = 2000\n<strong>输出：</strong>8\n<strong>解释：</strong>可行的数组方案为 [1317]，[131,7]，[13,17]，[1,317]，[13,1,7]，[1,31,7]，[1,3,17]，[1,3,1,7]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;2020&quot;, k = 30\n<strong>输出：</strong>1\n<strong>解释：</strong>唯一可能的数组方案是 [20,20] 。 [2020] 不是可行的数组方案，原因是 2020 &gt; 30 。 [2,020] 也不是可行的数组方案，因为 020 含有前导 0 。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1234567890&quot;, k = 90\n<strong>输出：</strong>34\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code>.</li>\n\t<li><code>s</code>&nbsp;只包含数字且不包含前导 0 。</li>\n\t<li><code>1 &lt;= k &lt;= 10^9</code>.</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1417重新格式化字符串",
        "hardRate": "EASY",
        "passRate": "55.16%",
        "problemsUrl": "https://leetcode.cn/problems/reformat-the-string/",
        "solutionsUrl": "https://leetcode.cn/problems/reformat-the-string/solution",
        "problemsDesc": "<p>给你一个混合了数字和字母的字符串 <code>s</code>，其中的字母均为小写英文字母。</p>\n\n<p>请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。</p>\n\n<p>请你返回 <strong>重新格式化后</strong> 的字符串；如果无法按要求重新格式化，则返回一个 <strong>空字符串</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;a0b1c2&quot;\n<strong>输出：</strong>&quot;0a1b2c&quot;\n<strong>解释：</strong>&quot;0a1b2c&quot; 中任意两个相邻字符的类型都不同。 &quot;a0b1c2&quot;, &quot;0a1b2c&quot;, &quot;0c2a1b&quot; 也是满足题目要求的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;leetcode&quot;\n<strong>输出：</strong>&quot;&quot;\n<strong>解释：</strong>&quot;leetcode&quot; 中只有字母，所以无法满足重新格式化的条件。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1229857369&quot;\n<strong>输出：</strong>&quot;&quot;\n<strong>解释：</strong>&quot;1229857369&quot; 中只有数字，所以无法满足重新格式化的条件。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;covid2019&quot;\n<strong>输出：</strong>&quot;c2o0v1i9d&quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;ab123&quot;\n<strong>输出：</strong>&quot;1a2b3&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>s</code> 仅由小写英文字母和/或数字组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1418点菜展示表",
        "hardRate": "MEDIUM",
        "passRate": "73.14%",
        "problemsUrl": "https://leetcode.cn/problems/display-table-of-food-orders-in-a-restaurant/",
        "solutionsUrl": "https://leetcode.cn/problems/display-table-of-food-orders-in-a-restaurant/solution",
        "problemsDesc": "<p>给你一个数组 <code>orders</code>，表示客户在餐厅中完成的订单，确切地说， <code>orders[i]=[customerName<sub>i</sub>,tableNumber<sub>i</sub>,foodItem<sub>i</sub>]</code> ，其中 <code>customerName<sub>i</sub></code> 是客户的姓名，<code>tableNumber<sub>i</sub></code> 是客户所在餐桌的桌号，而 <code>foodItem<sub>i</sub></code> 是客户点的餐品名称。</p>\n\n<p>请你返回该餐厅的 <strong>点菜展示表</strong><em> 。</em>在这张表中，表中第一行为标题，其第一列为餐桌桌号 &ldquo;Table&rdquo; ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。</p>\n\n<p>注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>orders = [[&quot;David&quot;,&quot;3&quot;,&quot;Ceviche&quot;],[&quot;Corina&quot;,&quot;10&quot;,&quot;Beef Burrito&quot;],[&quot;David&quot;,&quot;3&quot;,&quot;Fried Chicken&quot;],[&quot;Carla&quot;,&quot;5&quot;,&quot;Water&quot;],[&quot;Carla&quot;,&quot;5&quot;,&quot;Ceviche&quot;],[&quot;Rous&quot;,&quot;3&quot;,&quot;Ceviche&quot;]]\n<strong>输出：</strong>[[&quot;Table&quot;,&quot;Beef Burrito&quot;,&quot;Ceviche&quot;,&quot;Fried Chicken&quot;,&quot;Water&quot;],[&quot;3&quot;,&quot;0&quot;,&quot;2&quot;,&quot;1&quot;,&quot;0&quot;],[&quot;5&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;],[&quot;10&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]] \n<strong>解释：\n</strong>点菜展示表如下所示：\n<strong>Table,Beef Burrito,Ceviche,Fried Chicken,Water</strong>\n3    ,0           ,2      ,1            ,0\n5    ,0           ,1      ,0            ,1\n10   ,1           ,0      ,0            ,0\n对于餐桌 3：David 点了 &quot;Ceviche&quot; 和 &quot;Fried Chicken&quot;，而 Rous 点了 &quot;Ceviche&quot;\n而餐桌 5：Carla 点了 &quot;Water&quot; 和 &quot;Ceviche&quot;\n餐桌 10：Corina 点了 &quot;Beef Burrito&quot; \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>orders = [[&quot;James&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Ratesh&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Amadeus&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Adam&quot;,&quot;1&quot;,&quot;Canadian Waffles&quot;],[&quot;Brianna&quot;,&quot;1&quot;,&quot;Canadian Waffles&quot;]]\n<strong>输出：</strong>[[&quot;Table&quot;,&quot;Canadian Waffles&quot;,&quot;Fried Chicken&quot;],[&quot;1&quot;,&quot;2&quot;,&quot;0&quot;],[&quot;12&quot;,&quot;0&quot;,&quot;3&quot;]] \n<strong>解释：</strong>\n对于餐桌 1：Adam 和 Brianna 都点了 &quot;Canadian Waffles&quot;\n而餐桌 12：James, Ratesh 和 Amadeus 都点了 &quot;Fried Chicken&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>orders = [[&quot;Laura&quot;,&quot;2&quot;,&quot;Bean Burrito&quot;],[&quot;Jhon&quot;,&quot;2&quot;,&quot;Beef Burrito&quot;],[&quot;Melissa&quot;,&quot;2&quot;,&quot;Soda&quot;]]\n<strong>输出：</strong>[[&quot;Table&quot;,&quot;Bean Burrito&quot;,&quot;Beef Burrito&quot;,&quot;Soda&quot;],[&quot;2&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;orders.length &lt;= 5 * 10^4</code></li>\n\t<li><code>orders[i].length == 3</code></li>\n\t<li><code>1 &lt;= customerName<sub>i</sub>.length, foodItem<sub>i</sub>.length &lt;= 20</code></li>\n\t<li><code>customerName<sub>i</sub></code> 和 <code>foodItem<sub>i</sub></code> 由大小写英文字母及空格字符 <code>&#39; &#39;</code> 组成。</li>\n\t<li><code>tableNumber<sub>i</sub></code> 是 <code>1</code> 到 <code>500</code> 范围内的整数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1419数青蛙",
        "hardRate": "MEDIUM",
        "passRate": "50.22%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-frogs-croaking/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-frogs-croaking/solution",
        "problemsDesc": "<p>给你一个字符串 <code>croakOfFrogs</code>，它表示不同青蛙发出的蛙鸣声（字符串 <code>\"croak\"</code> ）的组合。由于同一时间可以有多只青蛙呱呱作响，所以&nbsp;<code>croakOfFrogs</code> 中会混合多个 <code>“croak”</code> <em>。</em></p>\n\n<p>请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。</p>\n\n<p>要想发出蛙鸣 \"croak\"，青蛙必须 <strong>依序</strong> 输出 <code>‘c’, ’r’, ’o’, ’a’, ’k’</code> 这 5 个字母。如果没有输出全部五个字母，那么它就不会发出声音。如果字符串 <code>croakOfFrogs</code> 不是由若干有效的 \"croak\" 字符混合而成，请返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>croakOfFrogs = \"croakcroak\"\n<strong>输出：</strong>1 \n<strong>解释：</strong>一只青蛙 “呱呱” 两次\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>croakOfFrogs = \"crcoakroak\"\n<strong>输出：</strong>2 \n<strong>解释：</strong>最少需要两只青蛙，“呱呱” 声用黑体标注\n第一只青蛙 \"<strong>cr</strong>c<strong>oak</strong>roak\"\n第二只青蛙 \"cr<strong>c</strong>oak<strong>roak</strong>\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>croakOfFrogs = \"croakcrook\"\n<strong>输出：</strong>-1\n<strong>解释：</strong>给出的字符串不是 \"croak<strong>\"</strong> 的有效组合。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= croakOfFrogs.length &lt;= 10<sup>5</sup></code></li>\n\t<li>字符串中的字符只有 <code>'c'</code>, <code>'r'</code>, <code>'o'</code>, <code>'a'</code> 或者 <code>'k'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1420生成数组",
        "hardRate": "HARD",
        "passRate": "63.60%",
        "problemsUrl": "https://leetcode.cn/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/",
        "solutionsUrl": "https://leetcode.cn/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/solution",
        "problemsDesc": "<p>给你三个整数 <code>n</code>、<code>m</code> 和 <code>k</code> 。下图描述的算法用于找出正整数数组中最大的元素。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/19/e.png\" style=\"height: 372px; width: 424px;\"></p>\n\n<p>请你生成一个具有下述属性的数组 <code>arr</code> ：</p>\n\n<ul>\n\t<li><code>arr</code> 中有 <code>n</code> 个整数。</li>\n\t<li><code>1 &lt;= arr[i] &lt;= m</code> 其中 <code>(0 &lt;= i &lt; n)</code> 。</li>\n\t<li>将上面提到的算法应用于 <code>arr</code> ，<code>search_cost</code> 的值等于 <code>k</code> 。</li>\n</ul>\n\n<p>返回上述条件下生成数组 <code>arr</code> 的 <strong>方法数</strong> ，由于答案可能会很大，所以 <strong>必须</strong> 对 <code>10^9 + 7</code> 取余。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, m = 3, k = 1\n<strong>输出：</strong>6\n<strong>解释：</strong>可能的数组分别为 [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 5, m = 2, k = 3\n<strong>输出：</strong>0\n<strong>解释：</strong>没有数组可以满足上述条件\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 9, m = 1, k = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>可能的数组只有 [1, 1, 1, 1, 1, 1, 1, 1, 1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 50, m = 100, k = 25\n<strong>输出：</strong>34549172\n<strong>解释：</strong>不要忘了对 1000000007 取余\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>n = 37, m = 17, k = 7\n<strong>输出：</strong>418930126\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>1 &lt;= m &lt;= 100</code></li>\n\t<li><code>0 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1421净现值查询",
        "hardRate": "EASY",
        "passRate": "70.93%",
        "problemsUrl": "https://leetcode.cn/problems/npv-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/npv-queries/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1422分割字符串的最大得分",
        "hardRate": "EASY",
        "passRate": "56.75%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-after-splitting-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-after-splitting-a-string/solution",
        "problemsDesc": "<p>给你一个由若干 0 和 1 组成的字符串 <code>s</code> ，请你计算并返回将该字符串分割成两个 <strong>非空</strong> 子字符串（即&nbsp;<strong>左</strong> 子字符串和 <strong>右</strong> 子字符串）所能获得的最大得分。</p>\n\n<p>「分割字符串的得分」为 <strong>左</strong> 子字符串中 <strong>0</strong> 的数量加上 <strong>右</strong> 子字符串中 <strong>1</strong> 的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;011101&quot;\n<strong>输出：</strong>5 \n<strong>解释：</strong>\n将字符串 s 划分为两个非空子字符串的可行方案有：\n左子字符串 = &quot;0&quot; 且 右子字符串 = &quot;11101&quot;，得分 = 1 + 4 = 5 \n左子字符串 = &quot;01&quot; 且 右子字符串 = &quot;1101&quot;，得分 = 1 + 3 = 4 \n左子字符串 = &quot;011&quot; 且 右子字符串 = &quot;101&quot;，得分 = 1 + 2 = 3 \n左子字符串 = &quot;0111&quot; 且 右子字符串 = &quot;01&quot;，得分 = 1 + 1 = 2 \n左子字符串 = &quot;01110&quot; 且 右子字符串 = &quot;1&quot;，得分 = 2 + 1 = 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;00111&quot;\n<strong>输出：</strong>5\n<strong>解释：</strong>当 左子字符串 = &quot;00&quot; 且 右子字符串 = &quot;111&quot; 时，我们得到最大得分 = 2 + 3 = 5\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1111&quot;\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 500</code></li>\n\t<li>字符串 <code>s</code> 仅由字符 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1423可获得的最大点数",
        "hardRate": "MEDIUM",
        "passRate": "55.00%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/solution",
        "problemsDesc": "<p>几张卡牌<strong> 排成一行</strong>，每张卡牌都有一个对应的点数。点数由整数数组 <code>cardPoints</code> 给出。</p>\n\n<p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 <code>k</code> 张卡牌。</p>\n\n<p>你的点数就是你拿到手中的所有卡牌的点数之和。</p>\n\n<p>给你一个整数数组 <code>cardPoints</code> 和整数 <code>k</code>，请你返回可以获得的最大点数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>cardPoints = [1,2,3,4,5,6,1], k = 3\n<strong>输出：</strong>12\n<strong>解释：</strong>第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>cardPoints = [2,2,2], k = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>无论你拿起哪两张卡牌，可获得的点数总是 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>cardPoints = [9,7,7,9,7,7,9], k = 7\n<strong>输出：</strong>55\n<strong>解释：</strong>你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>cardPoints = [1,1000,1], k = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。 \n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>cardPoints = [1,79,80,1,1,1,200,1], k = 3\n<strong>输出：</strong>202\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= cardPoints.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= cardPoints[i] &lt;= 10^4</code></li>\n\t<li><code>1 &lt;= k &lt;= cardPoints.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1424对角线遍历 II",
        "hardRate": "MEDIUM",
        "passRate": "42.25%",
        "problemsUrl": "https://leetcode.cn/problems/diagonal-traverse-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/diagonal-traverse-ii/solution",
        "problemsDesc": "<p>给你一个列表&nbsp;<code>nums</code>&nbsp;，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回&nbsp;<code>nums</code>&nbsp;中对角线上的整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/23/sample_1_1784.png\" style=\"height: 143px; width: 158px;\"></strong></p>\n\n<pre><strong>输入：</strong>nums = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>[1,4,2,7,5,3,8,6,9]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/23/sample_2_1784.png\" style=\"height: 177px; width: 230px;\"></strong></p>\n\n<pre><strong>输入：</strong>nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]\n<strong>输出：</strong>[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]]\n<strong>输出：</strong>[1,4,2,5,3,8,6,9,7,10,11]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums = [[1,2,3,4,5,6]]\n<strong>输出：</strong>[1,2,3,4,5,6]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= nums[i].length &lt;=&nbsp;10^5</code></li>\n\t<li><code>1 &lt;= nums[i][j] &lt;= 10^9</code></li>\n\t<li><code>nums</code>&nbsp;中最多有&nbsp;<code>10^5</code>&nbsp;个数字。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1425带限制的子序列和",
        "hardRate": "HARD",
        "passRate": "47.55%",
        "problemsUrl": "https://leetcode.cn/problems/constrained-subsequence-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/constrained-subsequence-sum/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;，请你返回 <strong>非空</strong>&nbsp;子序列元素和的最大值，子序列需要满足：子序列中每两个 <strong>相邻</strong>&nbsp;的整数&nbsp;<code>nums[i]</code>&nbsp;和&nbsp;<code>nums[j]</code>&nbsp;，它们在原数组中的下标&nbsp;<code>i</code>&nbsp;和&nbsp;<code>j</code>&nbsp;满足&nbsp;<code>i &lt; j</code>&nbsp;且 <code>j - i &lt;= k</code> 。</p>\n\n<p>数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [10,2,-10,5,20], k = 2\n<strong>输出：</strong>37\n<strong>解释：</strong>子序列为 [10, 2, 5, 20] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [-1,-2,-3], k = 1\n<strong>输出：</strong>-1\n<strong>解释：</strong>子序列必须是非空的，所以我们选择最大的数字。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [10,-2,-10,-5,20], k = 2\n<strong>输出：</strong>23\n<strong>解释：</strong>子序列为 [10, -2, -5, 20] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>-10^4&nbsp;&lt;= nums[i] &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1426数元素",
        "hardRate": "EASY",
        "passRate": "69.66%",
        "problemsUrl": "https://leetcode.cn/problems/counting-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/counting-elements/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1427字符串的左右移",
        "hardRate": "EASY",
        "passRate": "58.56%",
        "problemsUrl": "https://leetcode.cn/problems/perform-string-shifts/",
        "solutionsUrl": "https://leetcode.cn/problems/perform-string-shifts/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1428至少有一个 1 的最左端列",
        "hardRate": "MEDIUM",
        "passRate": "61.39%",
        "problemsUrl": "https://leetcode.cn/problems/leftmost-column-with-at-least-a-one/",
        "solutionsUrl": "https://leetcode.cn/problems/leftmost-column-with-at-least-a-one/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1429第一个唯一数字",
        "hardRate": "MEDIUM",
        "passRate": "53.41%",
        "problemsUrl": "https://leetcode.cn/problems/first-unique-number/",
        "solutionsUrl": "https://leetcode.cn/problems/first-unique-number/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1430判断给定的序列是否是二叉树从根到叶的路径",
        "hardRate": "MEDIUM",
        "passRate": "54.58%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1431拥有最多糖果的孩子",
        "hardRate": "EASY",
        "passRate": "84.58%",
        "problemsUrl": "https://leetcode.cn/problems/kids-with-the-greatest-number-of-candies/",
        "solutionsUrl": "https://leetcode.cn/problems/kids-with-the-greatest-number-of-candies/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>candies</code>&nbsp;和一个整数&nbsp;<code>extraCandies</code>&nbsp;，其中&nbsp;<code>candies[i]</code>&nbsp;代表第 <code>i</code> 个孩子拥有的糖果数目。</p>\n\n<p>对每一个孩子，检查是否存在一种方案，将额外的&nbsp;<code>extraCandies</code>&nbsp;个糖果分配给孩子们之后，此孩子有 <strong>最多</strong>&nbsp;的糖果。注意，允许有多个孩子同时拥有 <strong>最多</strong>&nbsp;的糖果数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>candies = [2,3,5,1,3], extraCandies = 3\n<strong>输出：</strong>[true,true,true,false,true] \n<strong>解释：</strong>\n孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。\n孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。\n孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。\n孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。\n孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>candies = [4,2,1,1,2], extraCandies = 1\n<strong>输出：</strong>[true,false,false,false,false] \n<strong>解释：</strong>只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>candies = [12,1,12], extraCandies = 10\n<strong>输出：</strong>[true,false,true]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= candies.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= candies[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= extraCandies &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1432改变一个整数能得到的最大差值",
        "hardRate": "MEDIUM",
        "passRate": "39.89%",
        "problemsUrl": "https://leetcode.cn/problems/max-difference-you-can-get-from-changing-an-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/max-difference-you-can-get-from-changing-an-integer/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>num</code>&nbsp;。你可以对它进行如下步骤恰好 <strong>两次</strong>&nbsp;：</p>\n\n<ul>\n\t<li>选择一个数字&nbsp;<code>x (0&nbsp;&lt;= x &lt;= 9)</code>.</li>\n\t<li>选择另一个数字&nbsp;<code>y (0&nbsp;&lt;= y &lt;= 9)</code>&nbsp;。数字&nbsp;<code>y</code>&nbsp;可以等于&nbsp;<code>x</code>&nbsp;。</li>\n\t<li>将 <code>num</code>&nbsp;中所有出现 <code>x</code>&nbsp;的数位都用 <code>y</code>&nbsp;替换。</li>\n\t<li>得到的新的整数 <strong>不能</strong>&nbsp;有前导 0 ，得到的新整数也 <strong>不能</strong>&nbsp;是 0&nbsp;。</li>\n</ul>\n\n<p>令两次对 <code>num</code>&nbsp;的操作得到的结果分别为&nbsp;<code>a</code>&nbsp;和&nbsp;<code>b</code>&nbsp;。</p>\n\n<p>请你返回&nbsp;<code>a</code> 和&nbsp;<code>b</code>&nbsp;的 <strong>最大差值</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 555\n<strong>输出：</strong>888\n<strong>解释：</strong>第一次选择 x = 5 且 y = 9 ，并把得到的新数字保存在 a 中。\n第二次选择 x = 5 且 y = 1 ，并把得到的新数字保存在 b 中。\n现在，我们有 a = 999 和 b = 111 ，最大差值为 888\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 9\n<strong>输出：</strong>8\n<strong>解释：</strong>第一次选择 x = 9 且 y = 9 ，并把得到的新数字保存在 a 中。\n第二次选择 x = 9 且 y = 1 ，并把得到的新数字保存在 b 中。\n现在，我们有 a = 9 和 b = 1 ，最大差值为 8\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = 123456\n<strong>输出：</strong>820000\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>num = 10000\n<strong>输出：</strong>80000\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>num = 9288\n<strong>输出：</strong>8700\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10^8</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1433检查一个字符串是否可以打破另一个字符串",
        "hardRate": "MEDIUM",
        "passRate": "64.70%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-a-string-can-break-another-string/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-a-string-can-break-another-string/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>s1</code>&nbsp;和&nbsp;<code>s2</code>&nbsp;，它们长度相等，请你检查是否存在一个&nbsp;<code>s1</code>&nbsp; 的排列可以打破 <code>s2</code>&nbsp;的一个排列，或者是否存在一个&nbsp;<code>s2</code>&nbsp;的排列可以打破 <code>s1</code> 的一个排列。</p>\n\n<p>字符串&nbsp;<code>x</code>&nbsp;可以打破字符串&nbsp;<code>y</code>&nbsp;（两者长度都为&nbsp;<code>n</code>&nbsp;）需满足对于所有&nbsp;<code>i</code>（在&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;之间）都有&nbsp;<code>x[i] &gt;= y[i]</code>（字典序意义下的顺序）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s1 = &quot;abc&quot;, s2 = &quot;xya&quot;\n<strong>输出：</strong>true\n<strong>解释：</strong>&quot;ayx&quot; 是 s2=&quot;xya&quot; 的一个排列，&quot;abc&quot; 是字符串 s1=&quot;abc&quot; 的一个排列，且 &quot;ayx&quot; 可以打破 &quot;abc&quot; 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s1 = &quot;abe&quot;, s2 = &quot;acd&quot;\n<strong>输出：</strong>false \n<strong>解释：</strong>s1=&quot;abe&quot; 的所有排列包括：&quot;abe&quot;，&quot;aeb&quot;，&quot;bae&quot;，&quot;bea&quot;，&quot;eab&quot; 和 &quot;eba&quot; ，s2=&quot;acd&quot; 的所有排列包括：&quot;acd&quot;，&quot;adc&quot;，&quot;cad&quot;，&quot;cda&quot;，&quot;dac&quot; 和 &quot;dca&quot;。然而没有任何 s1 的排列可以打破 s2 的排列。也没有 s2 的排列能打破 s1 的排列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s1 = &quot;leetcodee&quot;, s2 = &quot;interview&quot;\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s1.length == n</code></li>\n\t<li><code>s2.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li>所有字符串都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1434每个人戴不同帽子的方案数",
        "hardRate": "HARD",
        "passRate": "51.68%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-wear-different-hats-to-each-other/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-wear-different-hats-to-each-other/solution",
        "problemsDesc": "<p>总共有 <code>n</code>&nbsp;个人和 <code>40</code> 种不同的帽子，帽子编号从 <code>1</code> 到 <code>40</code> 。</p>\n\n<p>给你一个整数列表的列表&nbsp;<code>hats</code>&nbsp;，其中&nbsp;<code>hats[i]</code>&nbsp;是第 <code>i</code>&nbsp;个人所有喜欢帽子的列表。</p>\n\n<p>请你给每个人安排一顶他喜欢的帽子，确保每个人戴的帽子跟别人都不一样，并返回方案数。</p>\n\n<p>由于答案可能很大，请返回它对&nbsp;<code>10^9 + 7</code>&nbsp;取余后的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>hats = [[3,4],[4,5],[5]]\n<strong>输出：</strong>1\n<strong>解释：</strong>给定条件下只有一种方法选择帽子。\n第一个人选择帽子 3，第二个人选择帽子 4，最后一个人选择帽子 5。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>hats = [[3,5,1],[3,5]]\n<strong>输出：</strong>4\n<strong>解释：</strong>总共有 4 种安排帽子的方法：\n(3,5)，(5,3)，(1,3) 和 (1,5)\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]\n<strong>输出：</strong>24\n<strong>解释：</strong>每个人都可以从编号为 1 到 4 的帽子中选。\n(1,2,3,4) 4 个帽子的排列方案数为 24 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>hats = [[1,2,3],[2,3,5,6],[1,3,7,9],[1,8,9],[2,5,7]]\n<strong>输出：</strong>111\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == hats.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10</code></li>\n\t<li><code>1 &lt;= hats[i].length &lt;= 40</code></li>\n\t<li><code>1 &lt;= hats[i][j] &lt;= 40</code></li>\n\t<li><code>hats[i]</code>&nbsp;包含一个数字互不相同的整数列表。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1435制作会话柱状图",
        "hardRate": "EASY",
        "passRate": "63.73%",
        "problemsUrl": "https://leetcode.cn/problems/create-a-session-bar-chart/",
        "solutionsUrl": "https://leetcode.cn/problems/create-a-session-bar-chart/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1436旅行终点站",
        "hardRate": "EASY",
        "passRate": "81.75%",
        "problemsUrl": "https://leetcode.cn/problems/destination-city/",
        "solutionsUrl": "https://leetcode.cn/problems/destination-city/solution",
        "problemsDesc": "<p>给你一份旅游线路图，该线路图中的旅行线路用数组 <code>paths</code> 表示，其中 <code>paths[i] = [cityA<sub>i</sub>, cityB<sub>i</sub>]</code> 表示该线路将会从 <code>cityA<sub>i</sub></code> 直接前往 <code>cityB<sub>i</sub></code> 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市<em>。</em></p>\n\n<p>题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>paths = [[\"London\",\"New York\"],[\"New York\",\"Lima\"],[\"Lima\",\"Sao Paulo\"]]\n<strong>输出：</strong>\"Sao Paulo\" \n<strong>解释：</strong>从 \"London\" 出发，最后抵达终点站 \"Sao Paulo\" 。本次旅行的路线是 \"London\" -&gt; \"New York\" -&gt; \"Lima\" -&gt; \"Sao Paulo\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>paths = [[\"B\",\"C\"],[\"D\",\"B\"],[\"C\",\"A\"]]\n<strong>输出：</strong>\"A\"\n<strong>解释：</strong>所有可能的线路是：\n\"D\" -&gt; \"B\" -&gt; \"C\" -&gt; \"A\".&nbsp;\n\"B\" -&gt; \"C\" -&gt; \"A\".&nbsp;\n\"C\" -&gt; \"A\".&nbsp;\n\"A\".&nbsp;\n显然，旅行终点站是 \"A\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>paths = [[\"A\",\"Z\"]]\n<strong>输出：</strong>\"Z\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= paths.length &lt;= 100</code></li>\n\t<li><code>paths[i].length == 2</code></li>\n\t<li><code>1 &lt;=&nbsp;cityA<sub>i</sub>.length,&nbsp;cityB<sub>i</sub>.length &lt;= 10</code></li>\n\t<li><code>cityA<sub>i&nbsp;</sub>!=&nbsp;cityB<sub>i</sub></code></li>\n\t<li>所有字符串均由大小写英文字母和空格字符组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1437是否所有 1 都至少相隔 k 个元素",
        "hardRate": "EASY",
        "passRate": "55.60%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-all-1s-are-at-least-length-k-places-away/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-all-1s-are-at-least-length-k-places-away/solution",
        "problemsDesc": "<p>给你一个由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>nums</code> 以及整数 <code>k</code>。如果所有 <code>1</code> 都至少相隔 <code>k</code> 个元素，则返回 <code>True</code> ；否则，返回 <code>False</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/03/sample_1_1791.png\" style=\"width: 214px;\"></strong></p>\n\n<pre><strong>输入：</strong>nums = [1,0,0,0,1,0,0,1], k = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>每个 1 都至少相隔 2 个元素。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/03/sample_2_1791.png\" style=\"height: 86px; width: 160px;\"></strong></p>\n\n<pre><strong>输入：</strong>nums = [1,0,0,1,0,1], k = 2\n<strong>输出：</strong>false\n<strong>解释：</strong>第二个 1 和第三个 1 之间只隔了 1 个元素。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,1,1,1], k = 0\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,0,1], k = 1\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= k &lt;= nums.length</code></li>\n\t<li><code>nums[i]</code> 的值为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1438绝对差不超过限制的最长连续子数组",
        "hardRate": "MEDIUM",
        "passRate": "49.65%",
        "problemsUrl": "https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，和一个表示限制的整数 <code>limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 <code>limit</code><em> 。</em></p>\n\n<p>如果不存在满足条件的子数组，则返回 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [8,2,4,7], limit = 4\n<strong>输出：</strong>2 \n<strong>解释：</strong>所有子数组如下：\n[8] 最大绝对差 |8-8| = 0 &lt;= 4.\n[8,2] 最大绝对差 |8-2| = 6 &gt; 4. \n[8,2,4] 最大绝对差 |8-2| = 6 &gt; 4.\n[8,2,4,7] 最大绝对差 |8-2| = 6 &gt; 4.\n[2] 最大绝对差 |2-2| = 0 &lt;= 4.\n[2,4] 最大绝对差 |2-4| = 2 &lt;= 4.\n[2,4,7] 最大绝对差 |2-7| = 5 &gt; 4.\n[4] 最大绝对差 |4-4| = 0 &lt;= 4.\n[4,7] 最大绝对差 |4-7| = 3 &lt;= 4.\n[7] 最大绝对差 |7-7| = 0 &lt;= 4. \n因此，满足题意的最长子数组的长度为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [10,1,2,4,7,2], limit = 5\n<strong>输出：</strong>4 \n<strong>解释：</strong>满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 &lt;= 5 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,2,2,2,4,4,2,2], limit = 0\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>\n\t<li><code>0 &lt;= limit &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1439有序矩阵中的第 k 个最小数组和",
        "hardRate": "HARD",
        "passRate": "66.51%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/solution",
        "problemsDesc": "<p>给你一个 <code>m&nbsp;* n</code> 的矩阵 <code>mat</code>，以及一个整数 <code>k</code> ，矩阵中的每一行都以非递减的顺序排列。</p>\n\n<p>你可以从每一行中选出 1 个元素形成一个数组。返回所有可能数组中的第 k 个 <strong>最小</strong> 数组和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[1,3,11],[2,4,6]], k = 5\n<strong>输出：</strong>7\n<strong>解释：</strong>从每一行中选出一个元素，前 k 个和最小的数组分别是：\n[1,2], [1,4], [3,2], [3,4], [1,6]。其中第 5 个的和是 7 。  </pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[1,3,11],[2,4,6]], k = 9\n<strong>输出：</strong>17\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7\n<strong>输出：</strong>9\n<strong>解释：</strong>从每一行中选出一个元素，前 k 个和最小的数组分别是：\n[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]。其中第 7 个的和是 9 。 \n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[1,1,10],[2,2,9]], k = 7\n<strong>输出：</strong>12\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat.length[i]</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 40</code></li>\n\t<li><code>1 &lt;= k &lt;= min(200, n ^&nbsp;m)</code></li>\n\t<li><code>1 &lt;= mat[i][j] &lt;= 5000</code></li>\n\t<li><code>mat[i]</code> 是一个非递减数组</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1440计算布尔表达式的值",
        "hardRate": "MEDIUM",
        "passRate": "69.73%",
        "problemsUrl": "https://leetcode.cn/problems/evaluate-boolean-expression/",
        "solutionsUrl": "https://leetcode.cn/problems/evaluate-boolean-expression/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1441用栈操作构建数组",
        "hardRate": "MEDIUM",
        "passRate": "71.55%",
        "problemsUrl": "https://leetcode.cn/problems/build-an-array-with-stack-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/build-an-array-with-stack-operations/solution",
        "problemsDesc": "<p>给你一个数组 <code>target</code> 和一个整数 <code>n</code>。每次迭代，需要从&nbsp; <code>list = { 1 , 2 , 3 ..., n }</code> 中依次读取一个数字。</p>\n\n<p>请使用下述操作来构建目标数组 <code>target</code> ：</p>\n\n<ul>\n\t<li><code>\"Push\"</code>：从 <code>list</code> 中读取一个新元素， 并将其推入数组中。</li>\n\t<li><code>\"Pop\"</code>：删除数组中的最后一个元素。</li>\n\t<li>如果目标数组构建完成，就停止读取更多元素。</li>\n</ul>\n\n<p>题目数据保证目标数组严格递增，并且只包含 <code>1</code> 到 <code>n</code> 之间的数字。</p>\n\n<p>请返回构建目标数组所用的操作序列。如果存在多个可行方案，返回任一即可。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = [1,3], n = 3\n<strong>输出：</strong>[\"Push\",\"Push\",\"Pop\",\"Push\"]\n<strong>解释： \n</strong>读取 1 并自动推入数组 -&gt; [1]\n读取 2 并自动推入数组，然后删除它 -&gt; [1]\n读取 3 并自动推入数组 -&gt; [1,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = [1,2,3], n = 3\n<strong>输出：</strong>[\"Push\",\"Push\",\"Push\"]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = [1,2], n = 4\n<strong>输出：</strong>[\"Push\",\"Push\"]\n<strong>解释：</strong>只需要读取前 2 个数字就可以停止。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= target[i] &lt;= n</code></li>\n\t<li><code>target</code> 严格递增</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1442形成两个异或相等数组的三元组数目",
        "hardRate": "MEDIUM",
        "passRate": "79.32%",
        "problemsUrl": "https://leetcode.cn/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/",
        "solutionsUrl": "https://leetcode.cn/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> 。</p>\n\n<p>现需要从数组中取三个下标 <code>i</code>、<code>j</code> 和 <code>k</code> ，其中 <code>(0 &lt;= i &lt; j &lt;= k &lt; arr.length)</code> 。</p>\n\n<p><code>a</code> 和 <code>b</code> 定义如下：</p>\n\n<ul>\n\t<li><code>a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]</code></li>\n\t<li><code>b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]</code></li>\n</ul>\n\n<p>注意：<strong>^</strong> 表示 <strong>按位异或</strong> 操作。</p>\n\n<p>请返回能够令 <code>a == b</code> 成立的三元组 (<code>i</code>, <code>j</code> , <code>k</code>) 的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,3,1,6,7]\n<strong>输出：</strong>4\n<strong>解释：</strong>满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4)\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,1,1,1,1]\n<strong>输出：</strong>10\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,3]\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,3,5,7,9]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [7,11,12,9,5,2,7,17,22]\n<strong>输出：</strong>8\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10^8</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1443收集树上所有苹果的最少时间",
        "hardRate": "MEDIUM",
        "passRate": "43.10%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-collect-all-apples-in-a-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-collect-all-apples-in-a-tree/solution",
        "problemsDesc": "<p>给你一棵有&nbsp;<code>n</code>&nbsp;个节点的无向树，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n-1</code>&nbsp;，它们中有一些节点有苹果。通过树上的一条边，需要花费 1 秒钟。你从&nbsp;<strong>节点 0&nbsp;</strong>出发，请你返回最少需要多少秒，可以收集到所有苹果，并回到节点 0 。</p>\n\n<p>无向树的边由&nbsp;<code>edges</code>&nbsp;给出，其中&nbsp;<code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>]</code>&nbsp;，表示有一条边连接&nbsp;<code>from</code>&nbsp;和&nbsp;<code>to<sub>i</sub></code> 。除此以外，还有一个布尔数组&nbsp;<code>hasApple</code> ，其中&nbsp;<code>hasApple[i] = true</code>&nbsp;代表节点&nbsp;<code>i</code>&nbsp;有一个苹果，否则，节点&nbsp;<code>i</code>&nbsp;没有苹果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/10/min_time_collect_apple_1.png\" style=\"height: 212px; width: 300px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n<strong>输出：</strong>8 \n<strong>解释：</strong>上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/10/min_time_collect_apple_2.png\" style=\"height: 212px; width: 300px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n<strong>输出：</strong>6\n<strong>解释：</strong>上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>&nbsp;&lt; b<sub>i</sub>&nbsp;&lt;= n - 1</code></li>\n\t<li><code>hasApple.length == n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1444切披萨的方案数",
        "hardRate": "HARD",
        "passRate": "54.31%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-of-cutting-a-pizza/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-of-cutting-a-pizza/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>rows x cols</code>&nbsp;大小的矩形披萨和一个整数 <code>k</code>&nbsp;，矩形包含两种字符：&nbsp;<code>&#39;A&#39;</code> （表示苹果）和&nbsp;<code>&#39;.&#39;</code>&nbsp;（表示空白格子）。你需要切披萨 <code>k-1</code> 次，得到&nbsp;<code>k</code>&nbsp;块披萨并送给别人。</p>\n\n<p>切披萨的每一刀，先要选择是向垂直还是水平方向切，再在矩形的边界上选一个切的位置，将披萨一分为二。如果垂直地切披萨，那么需要把左边的部分送给一个人，如果水平地切，那么需要把上面的部分送给一个人。在切完最后一刀后，需要把剩下来的一块送给最后一个人。</p>\n\n<p>请你返回确保每一块披萨包含&nbsp;<strong>至少</strong>&nbsp;一个苹果的切披萨方案数。由于答案可能是个很大的数字，请你返回它对 10^9 + 7 取余的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/10/ways_to_cut_apple_1.png\" style=\"height: 378px; width: 500px;\"></strong></p>\n\n<pre><strong>输入：</strong>pizza = [&quot;A..&quot;,&quot;AAA&quot;,&quot;...&quot;], k = 3\n<strong>输出：</strong>3 \n<strong>解释：</strong>上图展示了三种切披萨的方案。注意每一块披萨都至少包含一个苹果。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>pizza = [&quot;A..&quot;,&quot;AA.&quot;,&quot;...&quot;], k = 3\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>pizza = [&quot;A..&quot;,&quot;A..&quot;,&quot;...&quot;], k = 1\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rows, cols &lt;= 50</code></li>\n\t<li><code>rows ==&nbsp;pizza.length</code></li>\n\t<li><code>cols ==&nbsp;pizza[i].length</code></li>\n\t<li><code>1 &lt;= k &lt;= 10</code></li>\n\t<li><code>pizza</code>&nbsp;只包含字符&nbsp;<code>&#39;A&#39;</code>&nbsp;和&nbsp;<code>&#39;.&#39;</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1445苹果和桔子",
        "hardRate": "MEDIUM",
        "passRate": "84.15%",
        "problemsUrl": "https://leetcode.cn/problems/apples-oranges/",
        "solutionsUrl": "https://leetcode.cn/problems/apples-oranges/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1446连续字符",
        "hardRate": "EASY",
        "passRate": "60.30%",
        "problemsUrl": "https://leetcode.cn/problems/consecutive-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/consecutive-characters/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，字符串的<strong>「能量」</strong>定义为：只包含一种字符的最长非空子字符串的长度。</p>\n\n<p>请你返回字符串 <code>s</code> 的 <strong>能量</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"leetcode\"\n<strong>输出：</strong>2\n<strong>解释：</strong>子字符串 \"ee\" 长度为 2 ，只包含字符 'e' 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abbcccddddeeeeedcba\"\n<strong>输出：</strong>5\n<strong>解释：</strong>子字符串 \"eeeee\" 长度为 5 ，只包含字符 'e' 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1447最简分数",
        "hardRate": "MEDIUM",
        "passRate": "67.50%",
        "problemsUrl": "https://leetcode.cn/problems/simplified-fractions/",
        "solutionsUrl": "https://leetcode.cn/problems/simplified-fractions/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于&nbsp;&nbsp;<code>n</code>&nbsp;的 <strong>最简&nbsp;</strong>分数&nbsp;。分数可以以 <strong>任意&nbsp;</strong>顺序返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>[&quot;1/2&quot;]\n<strong>解释：</strong>&quot;1/2&quot; 是唯一一个分母小于等于 2 的最简分数。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 3\n<strong>输出：</strong>[&quot;1/2&quot;,&quot;1/3&quot;,&quot;2/3&quot;]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 4\n<strong>输出：</strong>[&quot;1/2&quot;,&quot;1/3&quot;,&quot;1/4&quot;,&quot;2/3&quot;,&quot;3/4&quot;]\n<strong>解释：</strong>&quot;2/4&quot; 不是最简分数，因为它可以化简为 &quot;1/2&quot; 。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1448统计二叉树中好节点的数目",
        "hardRate": "MEDIUM",
        "passRate": "71.57%",
        "problemsUrl": "https://leetcode.cn/problems/count-good-nodes-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/count-good-nodes-in-binary-tree/solution",
        "problemsDesc": "<p>给你一棵根为&nbsp;<code>root</code>&nbsp;的二叉树，请你返回二叉树中好节点的数目。</p>\n\n<p>「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/16/test_sample_1.png\" style=\"height: 156px; width: 263px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [3,1,4,3,null,1,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>图中蓝色节点为好节点。\n根节点 (3) 永远是个好节点。\n节点 4 -&gt; (3,4) 是路径中的最大值。\n节点 5 -&gt; (3,4,5) 是路径中的最大值。\n节点 3 -&gt; (3,1,3) 是路径中的最大值。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/16/test_sample_2.png\" style=\"height: 161px; width: 157px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [3,3,null,4,2]\n<strong>输出：</strong>3\n<strong>解释：</strong>节点 2 -&gt; (3, 3, 2) 不是好节点，因为 &quot;3&quot; 比它大。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>root = [1]\n<strong>输出：</strong>1\n<strong>解释：</strong>根节点是好节点。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉树中节点数目范围是&nbsp;<code>[1, 10^5]</code>&nbsp;。</li>\n\t<li>每个节点权值的范围是&nbsp;<code>[-10^4, 10^4]</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1449数位成本和为目标值的最大数字",
        "hardRate": "HARD",
        "passRate": "62.30%",
        "problemsUrl": "https://leetcode.cn/problems/form-largest-integer-with-digits-that-add-up-to-target/",
        "solutionsUrl": "https://leetcode.cn/problems/form-largest-integer-with-digits-that-add-up-to-target/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>cost</code> 和一个整数 <code>target</code> 。请你返回满足如下规则可以得到的 <strong>最大</strong> 整数：</p>\n\n<ul>\n\t<li>给当前结果添加一个数位（<code>i + 1</code>）的成本为 <code>cost[i]</code> （<code>cost</code> 数组下标从 0 开始）。</li>\n\t<li>总成本必须恰好等于 <code>target</code> 。</li>\n\t<li>添加的数位中没有数字 0 。</li>\n</ul>\n\n<p>由于答案可能会很大，请你以字符串形式返回。</p>\n\n<p>如果按照上述要求无法得到任何整数，请你返回 \"0\" 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>cost = [4,3,2,5,6,7,2,5,5], target = 9\n<strong>输出：</strong>\"7772\"\n<strong>解释：</strong>添加数位 '7' 的成本为 2 ，添加数位 '2' 的成本为 3 。所以 \"7772\" 的代价为 2*3+ 3*1 = 9 。 \"977\" 也是满足要求的数字，但 \"7772\" 是较大的数字。\n<strong> 数字     成本</strong>\n  1  ->   4\n  2  ->   3\n  3  ->   2\n  4  ->   5\n  5  ->   6\n  6  ->   7\n  7  ->   2\n  8  ->   5\n  9  ->   5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>cost = [7,6,5,5,5,6,8,7,8], target = 12\n<strong>输出：</strong>\"85\"\n<strong>解释：</strong>添加数位 '8' 的成本是 7 ，添加数位 '5' 的成本是 5 。\"85\" 的成本为 7 + 5 = 12 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>cost = [2,4,6,2,4,6,4,4,4], target = 5\n<strong>输出：</strong>\"0\"\n<strong>解释：</strong>总成本是 target 的条件下，无法生成任何整数。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>cost = [6,10,15,40,40,40,40,40,40], target = 47\n<strong>输出：</strong>\"32211\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>cost.length == 9</code></li>\n\t<li><code>1 <= cost[i] <= 5000</code></li>\n\t<li><code>1 <= target <= 5000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1450在既定时间做作业的学生人数",
        "hardRate": "EASY",
        "passRate": "82.37%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/solution",
        "problemsDesc": "<p>给你两个整数数组 <code>startTime</code>（开始时间）和 <code>endTime</code>（结束时间），并指定一个整数 <code>queryTime</code> 作为查询时间。</p>\n\n<p>已知，第 <code>i</code> 名学生在 <code>startTime[i]</code> 时开始写作业并于 <code>endTime[i]</code> 时完成作业。</p>\n\n<p>请返回在查询时间 <code>queryTime</code> 时正在做作业的学生人数。形式上，返回能够使 <code>queryTime</code> 处于区间 <code>[startTime[i], endTime[i]]</code>（含）的学生人数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>startTime = [1,2,3], endTime = [3,2,7], queryTime = 4\n<strong>输出：</strong>1\n<strong>解释：</strong>一共有 3 名学生。\n第一名学生在时间 1 开始写作业，并于时间 3 完成作业，在时间 4 没有处于做作业的状态。\n第二名学生在时间 2 开始写作业，并于时间 2 完成作业，在时间 4 没有处于做作业的状态。\n第三名学生在时间 3 开始写作业，预计于时间 7 完成作业，这是是唯一一名在时间 4 时正在做作业的学生。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>startTime = [4], endTime = [4], queryTime = 4\n<strong>输出：</strong>1\n<strong>解释：</strong>在查询时间只有一名学生在做作业。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>startTime = [4], endTime = [4], queryTime = 5\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>startTime = [1,1,1,1], endTime = [1,3,2,4], queryTime = 7\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>startTime = [9,8,7,6,5,4,3,2,1], endTime = [10,10,10,10,10,10,10,10,10], queryTime = 5\n<strong>输出：</strong>5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>startTime.length == endTime.length</code></li>\n\t<li><code>1 &lt;= startTime.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= startTime[i] &lt;= endTime[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;=&nbsp;queryTime &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1451重新排列句子中的单词",
        "hardRate": "MEDIUM",
        "passRate": "53.96%",
        "problemsUrl": "https://leetcode.cn/problems/rearrange-words-in-a-sentence/",
        "solutionsUrl": "https://leetcode.cn/problems/rearrange-words-in-a-sentence/solution",
        "problemsDesc": "<p>「句子」是一个用空格分隔单词的字符串。给你一个满足下述格式的句子 <code>text</code> :</p>\n\n<ul>\n\t<li>句子的首字母大写</li>\n\t<li><code>text</code> 中的每个单词都用单个空格分隔。</li>\n</ul>\n\n<p>请你重新排列 <code>text</code> 中的单词，使所有单词按其长度的升序排列。如果两个单词的长度相同，则保留其在原句子中的相对顺序。</p>\n\n<p>请同样按上述格式返回新的句子。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;Leetcode is cool&quot;\n<strong>输出：</strong>&quot;Is cool leetcode&quot;\n<strong>解释：</strong>句子中共有 3 个单词，长度为 8 的 &quot;Leetcode&quot; ，长度为 2 的 &quot;is&quot; 以及长度为 4 的 &quot;cool&quot; 。\n输出需要按单词的长度升序排列，新句子中的第一个单词首字母需要大写。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;Keep calm and code on&quot;\n<strong>输出：</strong>&quot;On and keep calm code&quot;\n<strong>解释：</strong>输出的排序情况如下：\n&quot;On&quot; 2 个字母。\n&quot;and&quot; 3 个字母。\n&quot;keep&quot; 4 个字母，因为存在长度相同的其他单词，所以它们之间需要保留在原句子中的相对顺序。\n&quot;calm&quot; 4 个字母。\n&quot;code&quot; 4 个字母。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;To be or not to be&quot;\n<strong>输出：</strong>&quot;To be or to be not&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>text</code> 以大写字母开头，然后包含若干小写字母以及单词间的单个空格。</li>\n\t<li><code>1 &lt;= text.length &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1452收藏清单",
        "hardRate": "MEDIUM",
        "passRate": "51.06%",
        "problemsUrl": "https://leetcode.cn/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/",
        "solutionsUrl": "https://leetcode.cn/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/solution",
        "problemsDesc": "<p>给你一个数组 <code>favoriteCompanies</code> ，其中 <code>favoriteCompanies[i]</code> 是第 <code>i</code> 名用户收藏的公司清单（<strong>下标从 0 开始</strong>）。</p>\n\n<p>请找出不是其他任何人收藏的公司清单的子集的收藏清单，并返回该清单下标<em>。</em>下标需要按升序排列<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>favoriteCompanies = [[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;],[&quot;google&quot;,&quot;microsoft&quot;],[&quot;google&quot;,&quot;facebook&quot;],[&quot;google&quot;],[&quot;amazon&quot;]]\n<strong>输出：</strong>[0,1,4] \n<strong>解释：</strong>\nfavoriteCompanies[2]=[&quot;google&quot;,&quot;facebook&quot;] 是 favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;] 的子集。\nfavoriteCompanies[3]=[&quot;google&quot;] 是 favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;] 和 favoriteCompanies[1]=[&quot;google&quot;,&quot;microsoft&quot;] 的子集。\n其余的收藏清单均不是其他任何人收藏的公司清单的子集，因此，答案为 [0,1,4] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>favoriteCompanies = [[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;],[&quot;leetcode&quot;,&quot;amazon&quot;],[&quot;facebook&quot;,&quot;google&quot;]]\n<strong>输出：</strong>[0,1] \n<strong>解释：</strong>favoriteCompanies[2]=[&quot;facebook&quot;,&quot;google&quot;] 是 favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;] 的子集，因此，答案为 [0,1] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>favoriteCompanies = [[&quot;leetcode&quot;],[&quot;google&quot;],[&quot;facebook&quot;],[&quot;amazon&quot;]]\n<strong>输出：</strong>[0,1,2,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;favoriteCompanies.length &lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;favoriteCompanies[i].length &lt;= 500</code></li>\n\t<li><code>1 &lt;=&nbsp;favoriteCompanies[i][j].length &lt;= 20</code></li>\n\t<li><code>favoriteCompanies[i]</code> 中的所有字符串 <strong>各不相同</strong> 。</li>\n\t<li>用户收藏的公司清单也 <strong>各不相同</strong> ，也就是说，即便我们按字母顺序排序每个清单， <code>favoriteCompanies[i] != favoriteCompanies[j] </code>仍然成立。</li>\n\t<li>所有字符串仅包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1453圆形靶内的最大飞镖数量",
        "hardRate": "HARD",
        "passRate": "37.77%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/solution",
        "problemsDesc": "<p>Alice 向一面非常大的墙上掷出 <code>n</code> 支飞镖。给你一个数组 <code>darts</code> ，其中 <code>darts[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示 Alice 掷出的第 <code>i</code> 支飞镖落在墙上的位置。</p>\n\n<p>Bob 知道墙上所有 <code>n</code> 支飞镖的位置。他想要往墙上放置一个半径为 <code>r</code> 的圆形靶。使 Alice 掷出的飞镖尽可能多地落在靶上。</p>\n\n<p>给你整数 <code>r</code> ，请返回能够落在 <strong>任意</strong> 半径为 <code>r</code> 的圆形靶内或靶上的最大飞镖数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1 ：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/04/29/sample_1_1806.png\" style=\"width: 248px; height: 211px;\" />\n<pre>\n<strong>输入：</strong>darts = [[-2,0],[2,0],[0,2],[0,-2]], r = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>如果圆形靶的圆心为 (0,0) ，半径为 2 ，所有的飞镖都落在靶上，此时落在靶上的飞镖数最大，值为 4 。\n</pre>\n\n<p><strong class=\"example\">示例 2 ：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/04/29/sample_2_1806.png\" style=\"width: 306px; height: 244px;\" />\n<pre>\n<strong>输入：</strong>darts = [[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], r = 5\n<strong>输出：</strong>5\n<strong>解释：</strong>如果圆形靶的圆心为 (0,4) ，半径为 5 ，则除了 (7,8) 之外的飞镖都落在靶上，此时落在靶上的飞镖数最大，值为 5 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= darts.length &lt;= 100</code></li>\n\t<li><code>darts[i].length == 2</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li><code>darts</code> 中的元素互不相同</li>\n\t<li><code>1 &lt;= r &lt;= 5000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1454活跃用户",
        "hardRate": "MEDIUM",
        "passRate": "38.26%",
        "problemsUrl": "https://leetcode.cn/problems/active-users/",
        "solutionsUrl": "https://leetcode.cn/problems/active-users/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1455检查单词是否为句中其他单词的前缀",
        "hardRate": "EASY",
        "passRate": "64.80%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/solution",
        "problemsDesc": "<p>给你一个字符串 <code>sentence</code> 作为句子并指定检索词为 <code>searchWord</code> ，其中句子由若干用 <strong>单个空格</strong> 分隔的单词组成。请你检查检索词 <code>searchWord</code> 是否为句子 <code>sentence</code> 中任意单词的前缀。</p>\n\n<p>如果&nbsp;<code>searchWord</code> 是某一个单词的前缀，则返回句子&nbsp;<code>sentence</code> 中该单词所对应的下标（<strong>下标从 1 开始</strong>）。如果 <code>searchWord</code> 是多个单词的前缀，则返回匹配的第一个单词的下标（<strong>最小下标</strong>）。如果 <code>searchWord</code> 不是任何单词的前缀，则返回 <code>-1</code><strong> </strong>。</p>\n\n<p>字符串 <code>s</code> 的 <strong>前缀</strong> 是 <code>s</code> 的任何前导连续子字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"i love eating burger\", searchWord = \"burg\"\n<strong>输出：</strong>4\n<strong>解释：</strong>\"burg\" 是 \"burger\" 的前缀，而 \"burger\" 是句子中第 4 个单词。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"this problem is an easy problem\", searchWord = \"pro\"\n<strong>输出：</strong>2\n<strong>解释：</strong>\"pro\" 是 \"problem\" 的前缀，而 \"problem\" 是句子中第 2 个也是第 6 个单词，但是应该返回最小下标 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"i am tired\", searchWord = \"you\"\n<strong>输出：</strong>-1\n<strong>解释：</strong>\"you\" 不是句子中任何单词的前缀。\n\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentence.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= searchWord.length &lt;= 10</code></li>\n\t<li><code>sentence</code> 由小写英文字母和空格组成。</li>\n\t<li><code>searchWord</code> 由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1456定长子串中元音的最大数目",
        "hardRate": "MEDIUM",
        "passRate": "54.58%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solution",
        "problemsDesc": "<p>给你字符串 <code>s</code> 和整数 <code>k</code> 。</p>\n\n<p>请返回字符串 <code>s</code> 中长度为 <code>k</code> 的单个子字符串中可能包含的最大元音字母数。</p>\n\n<p>英文中的 <strong>元音字母 </strong>为（<code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abciiidef&quot;, k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>子字符串 &quot;iii&quot; 包含 3 个元音字母。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aeiou&quot;, k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>任意长度为 2 的子字符串都包含 2 个元音字母。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;leetcode&quot;, k = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>&quot;lee&quot;、&quot;eet&quot; 和 &quot;ode&quot; 都包含 2 个元音字母。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;rhythms&quot;, k = 4\n<strong>输出：</strong>0\n<strong>解释：</strong>字符串 s 中不含任何元音字母。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;tryhard&quot;, k = 4\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n\t<li><code>1 &lt;= k &lt;= s.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1457二叉树中的伪回文路径",
        "hardRate": "MEDIUM",
        "passRate": "62.07%",
        "problemsUrl": "https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/solution",
        "problemsDesc": "<p>给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「<strong>伪回文</strong>」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。</p>\n\n<p>请你返回从根到叶子节点的所有路径中&nbsp;<strong>伪回文&nbsp;</strong>路径的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/23/palindromic_paths_1.png\" style=\"height: 201px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [2,3,1,3,1,null,1]\n<strong>输出：</strong>2 \n<strong>解释：</strong>上图为给定的二叉树。总共有 3 条从根到叶子的路径：红色路径 [2,3,3] ，绿色路径 [2,1,1] 和路径 [2,3,1] 。\n     在这些路径中，只有红色和绿色的路径是伪回文路径，因为红色路径 [2,3,3] 存在回文排列 [3,2,3] ，绿色路径 [2,1,1] 存在回文排列 [1,2,1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/23/palindromic_paths_2.png\" style=\"height: 314px; width: 300px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [2,1,1,1,3,null,null,null,null,null,1]\n<strong>输出：</strong>1 \n<strong>解释：</strong>上图为给定二叉树。总共有 3 条从根到叶子的路径：绿色路径 [2,1,1] ，路径 [2,1,3,1] 和路径 [2,1] 。\n     这些路径中只有绿色路径是伪回文路径，因为 [2,1,1] 存在回文排列 [1,2,1] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [9]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给定二叉树的节点数目在范围&nbsp;<code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1458两个子序列的最大点积",
        "hardRate": "HARD",
        "passRate": "46.87%",
        "problemsUrl": "https://leetcode.cn/problems/max-dot-product-of-two-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/max-dot-product-of-two-subsequences/solution",
        "problemsDesc": "<p>给你两个数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>&nbsp;。</p>\n\n<p>请你返回 <code>nums1</code> 和 <code>nums2</code> 中两个长度相同的 <strong>非空</strong> 子序列的最大点积。</p>\n\n<p>数组的非空子序列是通过删除原数组中某些元素（可能一个也不删除）后剩余数字组成的序列，但不能改变数字间相对顺序。比方说，<code>[2,3,5]</code>&nbsp;是&nbsp;<code>[1,2,3,4,5]</code>&nbsp;的一个子序列而&nbsp;<code>[1,5,3]</code>&nbsp;不是。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [2,1,-2,5], nums2 = [3,0,-6]\n<strong>输出：</strong>18\n<strong>解释：</strong>从 nums1 中得到子序列 [2,-2] ，从 nums2 中得到子序列 [3,-6] 。\n它们的点积为 (2*3 + (-2)*(-6)) = 18 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [3,-2], nums2 = [2,-6,7]\n<strong>输出：</strong>21\n<strong>解释：</strong>从 nums1 中得到子序列 [3] ，从 nums2 中得到子序列 [7] 。\n它们的点积为 (3*7) = 21 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [-1,-1], nums2 = [1,1]\n<strong>输出：</strong>-1\n<strong>解释：</strong>从 nums1 中得到子序列 [-1] ，从 nums2 中得到子序列 [1] 。\n它们的点积为 -1 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 500</code></li>\n\t<li><code>-1000 &lt;= nums1[i], nums2[i] &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>点积：</strong></p>\n\n<pre>\n定义 <code><strong>a</strong>&nbsp;= [<em>a</em><sub>1</sub>,&nbsp;<em>a</em><sub>2</sub>,…,&nbsp;<em>a</em><sub><em>n</em></sub>]</code> 和<strong> <code>b</code></strong><code>&nbsp;= [<em>b</em><sub>1</sub>,&nbsp;<em>b</em><sub>2</sub>,…,&nbsp;<em>b</em><sub><em>n</em></sub>]</code> 的点积为：\n\n<img alt=\"\\mathbf{a}\\cdot \\mathbf{b} = \\sum_{i=1}^n a_ib_i = a_1b_1 + a_2b_2 + \\cdots + a_nb_n \" class=\"tex\" src=\"https://pic.leetcode-cn.com/1666164309-PBJMQp-image.png\" />\n\n这里的 <strong>Σ</strong> 指示总和符号。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1459矩形面积",
        "hardRate": "MEDIUM",
        "passRate": "62.63%",
        "problemsUrl": "https://leetcode.cn/problems/rectangles-area/",
        "solutionsUrl": "https://leetcode.cn/problems/rectangles-area/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1460通过翻转子数组使两个数组相等",
        "hardRate": "EASY",
        "passRate": "77.17%",
        "problemsUrl": "https://leetcode.cn/problems/make-two-arrays-equal-by-reversing-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/make-two-arrays-equal-by-reversing-subarrays/solution",
        "problemsDesc": "<p>给你两个长度相同的整数数组&nbsp;<code>target</code>&nbsp;和&nbsp;<code>arr</code>&nbsp;。每一步中，你可以选择&nbsp;<code>arr</code>&nbsp;的任意 <strong>非空子数组</strong>&nbsp;并将它翻转。你可以执行此过程任意次。</p>\n\n<p><em>如果你能让 <code>arr</code>&nbsp;变得与 <code>target</code>&nbsp;相同，返回 True；否则，返回 False 。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = [1,2,3,4], arr = [2,4,1,3]\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以按照如下步骤使 arr 变成 target：\n1- 翻转子数组 [2,4,1] ，arr 变成 [1,4,2,3]\n2- 翻转子数组 [4,2] ，arr 变成 [1,2,4,3]\n3- 翻转子数组 [4,3] ，arr 变成 [1,2,3,4]\n上述方法并不是唯一的，还存在多种将 arr 变成 target 的方法。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = [7], arr = [7]\n<strong>输出：</strong>true\n<strong>解释：</strong>arr 不需要做任何翻转已经与 target 相等。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = [3,7,9], arr = [3,7,11]\n<strong>输出：</strong>false\n<strong>解释：</strong>arr 没有数字 9 ，所以无论如何也无法变成 target 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>target.length == arr.length</code></li>\n\t<li><code>1 &lt;= target.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= target[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1461检查一个字符串是否包含所有长度为 K 的二进制子串",
        "hardRate": "MEDIUM",
        "passRate": "52.54%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-a-string-contains-all-binary-codes-of-size-k/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-a-string-contains-all-binary-codes-of-size-k/solution",
        "problemsDesc": "<p>给你一个二进制字符串&nbsp;<code>s</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。如果所有长度为 <code>k</code>&nbsp;的二进制字符串都是 <code>s</code>&nbsp;的子串，请返回 <code>true</code> ，否则请返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"00110110\", k = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>长度为 2 的二进制串包括 \"00\"，\"01\"，\"10\" 和 \"11\"。它们分别是 s 中下标为 0，1，3，2 开始的长度为 2 的子串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0110\", k = 1\n<strong>输出：</strong>true\n<strong>解释：</strong>长度为 1 的二进制串包括 \"0\" 和 \"1\"，显然它们都是 s 的子串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0110\", k = 2\n<strong>输出：</strong>false\n<strong>解释：</strong>长度为 2 的二进制串 \"00\" 没有出现在 s 中。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 不是<code>'0'</code> 就是 <code>'1'</code></li>\n\t<li><code>1 &lt;= k &lt;= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1462课程表 IV",
        "hardRate": "MEDIUM",
        "passRate": "45.77%",
        "problemsUrl": "https://leetcode.cn/problems/course-schedule-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/course-schedule-iv/solution",
        "problemsDesc": "<p>你总共需要上<meta charset=\"UTF-8\" />&nbsp;<code>numCourses</code>&nbsp;门课，课程编号依次为 <code>0</code>&nbsp;到&nbsp;<code>numCourses-1</code>&nbsp;。你会得到一个数组&nbsp;<code>prerequisite</code> ，其中<meta charset=\"UTF-8\" />&nbsp;<code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示如果你想选<meta charset=\"UTF-8\" />&nbsp;<code>b<sub>i</sub></code> 课程，你<strong> 必须</strong> 先选<meta charset=\"UTF-8\" />&nbsp;<code>a<sub>i</sub></code>&nbsp;课程。</p>\n\n<ul>\n\t<li>有的课会有直接的先修课程，比如如果想上课程 <code>1</code>&nbsp;，你必须先上课程 <code>0</code>&nbsp;，那么会以 <code>[0,1]</code>&nbsp;数对的形式给出先修课程数对。</li>\n</ul>\n\n<p>先决条件也可以是 <strong>间接</strong> 的。如果课程 <code>a</code> 是课程 <code>b</code> 的先决条件，课程 <code>b</code> 是课程 <code>c</code> 的先决条件，那么课程 <code>a</code> 就是课程 <code>c</code> 的先决条件。</p>\n\n<p>你也得到一个数组<meta charset=\"UTF-8\" />&nbsp;<code>queries</code>&nbsp;，其中<meta charset=\"UTF-8\" />&nbsp;<code>queries[j] = [u<sub>j</sub>, v<sub>j</sub>]</code>。对于第 <code>j</code> 个查询，您应该回答课程<meta charset=\"UTF-8\" />&nbsp;<code>u<sub>j</sub></code>&nbsp;是否是课程<meta charset=\"UTF-8\" />&nbsp;<code>v<sub>j</sub></code>&nbsp;的先决条件。</p>\n\n<p>返回一个布尔数组 <code>answer</code> ，其中 <code>answer[j]</code> 是第 <code>j</code> 个查询的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/01/courses4-1-graph.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]\n<strong>输出：</strong>[false,true]\n<strong>解释：</strong>课程 0 不是课程 1 的先修课程，但课程 1 是课程 0 的先修课程。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>numCourses = 2, prerequisites = [], queries = [[1,0],[0,1]]\n<strong>输出：</strong>[false,false]\n<strong>解释：</strong>没有先修课程对，所以每门课程之间是独立的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/01/courses4-3-graph.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]]\n<strong>输出：</strong>[true,true]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>2 &lt;= numCourses &lt;= 100</code></li>\n\t<li><code>0 &lt;= prerequisites.length &lt;= (numCourses * (numCourses - 1) / 2)</code></li>\n\t<li><code>prerequisites[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub>&nbsp;&lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub>&nbsp;!= b<sub>i</sub></code></li>\n\t<li>每一对<meta charset=\"UTF-8\" />&nbsp;<code>[a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;都 <strong>不同</strong></li>\n\t<li>先修课程图中没有环。</li>\n\t<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub>&nbsp;&lt;= n - 1</code></li>\n\t<li><code>u<sub>i</sub>&nbsp;!= v<sub>i</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1463摘樱桃 II",
        "hardRate": "HARD",
        "passRate": "62.14%",
        "problemsUrl": "https://leetcode.cn/problems/cherry-pickup-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/cherry-pickup-ii/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>rows x cols</code> 的矩阵&nbsp;<code>grid</code>&nbsp;来表示一块樱桃地。 <code>grid</code>&nbsp;中每个格子的数字表示你能获得的樱桃数目。</p>\n\n<p>你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 <code>(0,0)</code> 出发，机器人 2 从右上角格子 <code>(0, cols-1)</code> 出发。</p>\n\n<p>请你按照如下规则，返回两个机器人能收集的最多樱桃数目：</p>\n\n<ul>\n\t<li>从格子&nbsp;<code>(i,j)</code> 出发，机器人可以移动到格子&nbsp;<code>(i+1, j-1)</code>，<code>(i+1, j)</code> 或者&nbsp;<code>(i+1, j+1)</code>&nbsp;。</li>\n\t<li>当一个机器人经过某个格子时，它会把该格子内所有的樱桃都摘走，然后这个位置会变成空格子，即没有樱桃的格子。</li>\n\t<li>当两个机器人同时到达同一个格子时，它们中只有一个可以摘到樱桃。</li>\n\t<li>两个机器人在任意时刻都不能移动到 <code>grid</code>&nbsp;外面。</li>\n\t<li>两个机器人最后都要到达&nbsp;<code>grid</code>&nbsp;最底下一行。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_1_1802.png\" style=\"height: 182px; width: 139px;\"></strong></p>\n\n<pre><strong>输入：</strong>grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]\n<strong>输出：</strong>24\n<strong>解释：</strong>机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。\n机器人 1 摘的樱桃数目为 (3 + 2 + 5 + 2) = 12 。\n机器人 2 摘的樱桃数目为 (1 + 5 + 5 + 1) = 12 。\n樱桃总数为： 12 + 12 = 24 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_2_1802.png\" style=\"height: 257px; width: 284px;\"></strong></p>\n\n<pre><strong>输入：</strong>grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]\n<strong>输出：</strong>28\n<strong>解释：</strong>机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。\n机器人 1 摘的樱桃数目为 (1 + 9 + 5 + 2) = 17 。\n机器人 2 摘的樱桃数目为 (1 + 3 + 4 + 3) = 11 。\n樱桃总数为： 17 + 11 = 28 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[1,0,0,3],[0,0,0,3],[0,0,3,3],[9,0,3,3]]\n<strong>输出：</strong>22\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[1,1],[1,1]]\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rows == grid.length</code></li>\n\t<li><code>cols == grid[i].length</code></li>\n\t<li><code>2 &lt;= rows, cols &lt;= 70</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 100&nbsp;</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1464数组中两元素的最大乘积",
        "hardRate": "EASY",
        "passRate": "78.58%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-product-of-two-elements-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-product-of-two-elements-in-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>，请你选择数组的两个不同下标 <code>i</code> 和 <code>j</code><em>，</em>使 <code>(nums[i]-1)*(nums[j]-1)</code> 取得最大值。</p>\n\n<p>请你计算并返回该式的最大值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,4,5,2]\n<strong>输出：</strong>12 \n<strong>解释：</strong>如果选择下标 i=1 和 j=2（下标从 0 开始），则可以获得最大值，(nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,5,4,5]\n<strong>输出：</strong>16\n<strong>解释：</strong>选择下标 i=1 和 j=3（下标从 0 开始），则可以获得最大值 (5-1)*(5-1) = 16 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,7]\n<strong>输出：</strong>12\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^3</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1465切割后面积最大的蛋糕",
        "hardRate": "MEDIUM",
        "passRate": "32.83%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/solution",
        "problemsDesc": "<p>矩形蛋糕的高度为 <code>h</code> 且宽度为 <code>w</code>，给你两个整数数组 <code>horizontalCuts</code> 和 <code>verticalCuts</code>，其中：</p>\n\n<ul>\n\t<li>&nbsp;<code>horizontalCuts[i]</code> 是从矩形蛋糕顶部到第&nbsp; <code>i</code> 个水平切口的距离</li>\n\t<li><code>verticalCuts[j]</code> 是从矩形蛋糕的左侧到第 <code>j</code> 个竖直切口的距离</li>\n</ul>\n\n<p>请你按数组 <em><code>horizontalCuts</code> </em>和<em> <code>verticalCuts</code> </em>中提供的水平和竖直位置切割后，请你找出 <strong>面积最大</strong> 的那份蛋糕，并返回其 <strong>面积</strong> 。由于答案可能是一个很大的数字，因此需要将结果&nbsp;<strong>对</strong>&nbsp;<code>10<sup>9</sup>&nbsp;+ 7</code>&nbsp;<strong>取余</strong> 后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/leetcode_max_area_2.png\" /></p>\n\n<pre>\n<strong>输入：</strong>h = 5, w = 4, horizontalCuts = [1,2,4], verticalCuts = [1,3]\n<strong>输出：</strong>4 \n<strong>解释：</strong>上图所示的矩阵蛋糕中，红色线表示水平和竖直方向上的切口。切割蛋糕后，绿色的那份蛋糕面积最大。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/leetcode_max_area_3.png\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>h = 5, w = 4, horizontalCuts = [3,1], verticalCuts = [1]\n<strong>输出：</strong>6\n<strong>解释：</strong>上图所示的矩阵蛋糕中，红色线表示水平和竖直方向上的切口。切割蛋糕后，绿色和黄色的两份蛋糕面积最大。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>h = 5, w = 4, horizontalCuts = [3], verticalCuts = [3]\n<strong>输出：</strong>9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= h, w &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= horizontalCuts.length &lt;= min(h - 1, 10<sup>5</sup>)</code></li>\n\t<li><code>1 &lt;= verticalCuts.length &lt;= min(w - 1, 10<sup>5</sup>)</code></li>\n\t<li><code>1 &lt;= horizontalCuts[i] &lt; h</code></li>\n\t<li><code>1 &lt;= verticalCuts[i] &lt; w</code></li>\n\t<li>题目数据保证 <code>horizontalCuts</code> 中的所有元素各不相同</li>\n\t<li>题目数据保证 <code>verticalCuts</code>&nbsp;中的所有元素各不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1466重新规划路线",
        "hardRate": "MEDIUM",
        "passRate": "51.11%",
        "problemsUrl": "https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/solution",
        "problemsDesc": "<p><code>n</code> 座城市，从 <code>0</code> 到 <code>n-1</code> 编号，其间共有 <code>n-1</code> 条路线。因此，要想在两座不同城市之间旅行只有唯一一条路线可供选择（路线网形成一颗树）。去年，交通运输部决定重新规划路线，以改变交通拥堵的状况。</p>\n\n<p>路线用 <code>connections</code> 表示，其中 <code>connections[i] = [a, b]</code> 表示从城市 <code>a</code> 到 <code>b</code> 的一条有向路线。</p>\n\n<p>今年，城市 0 将会举办一场大型比赛，很多游客都想前往城市 0 。</p>\n\n<p>请你帮助重新规划路线方向，使每个城市都可以访问城市 0 。返回需要变更方向的最小路线数。</p>\n\n<p>题目数据 <strong>保证</strong> 每个城市在重新规划路线方向后都能到达城市 0 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_1_1819.png\" style=\"height: 150px; width: 240px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]\n<strong>输出：</strong>3\n<strong>解释：</strong>更改以红色显示的路线的方向，使每个城市都可以到达城市 0 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_2_1819.png\" style=\"height: 60px; width: 380px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]\n<strong>输出：</strong>2\n<strong>解释：</strong>更改以红色显示的路线的方向，使每个城市都可以到达城市 0 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 3, connections = [[1,0],[2,0]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 5 * 10^4</code></li>\n\t<li><code>connections.length == n-1</code></li>\n\t<li><code>connections[i].length == 2</code></li>\n\t<li><code>0 &lt;= connections[i][0], connections[i][1] &lt;= n-1</code></li>\n\t<li><code>connections[i][0] != connections[i][1]</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1467两个盒子中球的颜色数相同的概率",
        "hardRate": "HARD",
        "passRate": "63.16%",
        "problemsUrl": "https://leetcode.cn/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/",
        "solutionsUrl": "https://leetcode.cn/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/solution",
        "problemsDesc": "<p>桌面上有 <code>2n</code> 个颜色不完全相同的球，球上的颜色共有 <code>k</code> 种。给你一个大小为 <code>k</code> 的整数数组 <code>balls</code> ，其中 <code>balls[i]</code> 是颜色为&nbsp;<code>i</code> 的球的数量。</p>\n\n<p>所有的球都已经 <strong>随机打乱顺序</strong> ，前 <code>n</code> 个球放入第一个盒子，后 <code>n</code> 个球放入另一个盒子（请认真阅读示例 2 的解释部分）。</p>\n\n<p><strong>注意：</strong>这两个盒子是不同的。例如，两个球颜色分别为 <code>a</code> 和 <code>b</code>，盒子分别为 <code>[]</code> 和 <code>()</code>，那么 <code>[a] (b)</code> 和 <code>[b] (a)</code> 这两种分配方式是不同的（请认真阅读示例的解释部分）。</p>\n\n<p>请返回「两个盒子中球的颜色数相同」的情况的概率。答案与真实值误差在 <code>10^-5</code> 以内，则被视为正确答案</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>balls = [1,1]\n<strong>输出：</strong>1.00000\n<strong>解释：</strong>球平均分配的方式只有两种：\n- 颜色为 1 的球放入第一个盒子，颜色为 2 的球放入第二个盒子\n- 颜色为 2 的球放入第一个盒子，颜色为 1 的球放入第二个盒子\n这两种分配，两个盒子中球的颜色数都相同。所以概率为 2/2 = 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>balls = [2,1,1]\n<strong>输出：</strong>0.66667\n<strong>解释：</strong>球的列表为 [1, 1, 2, 3]\n随机打乱，得到 12 种等概率的不同打乱方案，每种方案概率为 1/12 ：\n[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\n然后，我们将前两个球放入第一个盒子，后两个球放入第二个盒子。\n这 12 种可能的随机打乱方式中的 8 种满足「两个盒子中球的颜色数相同」。\n概率 = 8/12 = 0.66667\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>balls = [1,2,1,2]\n<strong>输出：</strong>0.60000\n<strong>解释：</strong>球的列表为 [1, 2, 2, 3, 4, 4]。要想显示所有 180 种随机打乱方案是很难的，但只检查「两个盒子中球的颜色数相同」的 108 种情况是比较容易的。\n概率 = 108 / 180 = 0.6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= balls.length &lt;= 8</code></li>\n\t<li><code>1 &lt;= balls[i] &lt;= 6</code></li>\n\t<li><code>sum(balls)</code> 是偶数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1468计算税后工资",
        "hardRate": "MEDIUM",
        "passRate": "69.97%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-salaries/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-salaries/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1469寻找所有的独生节点",
        "hardRate": "EASY",
        "passRate": "82.22%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-the-lonely-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-the-lonely-nodes/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1470重新排列数组",
        "hardRate": "EASY",
        "passRate": "84.88%",
        "problemsUrl": "https://leetcode.cn/problems/shuffle-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/shuffle-the-array/solution",
        "problemsDesc": "<p>给你一个数组 <code>nums</code> ，数组中有 <code>2n</code> 个元素，按 <code>[x<sub>1</sub>,x<sub>2</sub>,...,x<sub>n</sub>,y<sub>1</sub>,y<sub>2</sub>,...,y<sub>n</sub>]</code> 的格式排列。</p>\n\n<p>请你将数组按 <code>[x<sub>1</sub>,y<sub>1</sub>,x<sub>2</sub>,y<sub>2</sub>,...,x<sub>n</sub>,y<sub>n</sub>]</code> 格式重新排列，返回重排后的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,5,1,3,4,7], n = 3\n<strong>输出：</strong>[2,3,5,4,1,7] \n<strong>解释：</strong>由于 x<sub>1</sub>=2, x<sub>2</sub>=5, x<sub>3</sub>=1, y<sub>1</sub>=3, y<sub>2</sub>=4, y<sub>3</sub>=7 ，所以答案为 [2,3,5,4,1,7]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,4,3,2,1], n = 4\n<strong>输出：</strong>[1,4,2,3,3,2,4,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,2,2], n = 2\n<strong>输出：</strong>[1,2,1,2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>nums.length == 2n</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^3</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1471数组中的 k 个最强值",
        "hardRate": "MEDIUM",
        "passRate": "55.55%",
        "problemsUrl": "https://leetcode.cn/problems/the-k-strongest-values-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/the-k-strongest-values-in-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> 和一个整数 <code>k</code> 。</p>\n\n<p>设 <code>m</code> 为数组的中位数，只要满足下述两个前提之一，就可以判定 <code>arr[i]</code> 的值比 <code>arr[j]</code> 的值更强：</p>\n\n<ul>\n\t<li>&nbsp;<code>|arr[i] - m| &gt; |arr[j]&nbsp;- m|</code></li>\n\t<li>&nbsp;<code>|arr[i] - m| == |arr[j] - m|</code>，且 <code>arr[i] &gt; arr[j]</code></li>\n</ul>\n\n<p>请返回由数组中最强的 <code>k</code> 个值组成的列表。答案可以以 <strong>任意顺序</strong> 返回。</p>\n\n<p><strong>中位数</strong> 是一个有序整数列表中处于中间位置的值。形式上，如果列表的长度为 <code>n</code> ，那么中位数就是该有序列表（下标从 0 开始）中位于 <code>((n - 1) / 2)</code> 的元素。</p>\n\n<ul>\n\t<li>例如 <code>arr =&nbsp;[6, -3, 7, 2, 11]</code>，<code>n = 5</code>：数组排序后得到 <code>arr = [-3, 2, 6, 7, 11]</code> ，数组的中间位置为 <code>m = ((5 - 1) / 2) = 2</code> ，中位数 <code>arr[m]</code> 的值为 <code>6</code> 。</li>\n\t<li>例如 <code>arr =&nbsp;[-7, 22, 17,&thinsp;3]</code>，<code>n = 4</code>：数组排序后得到&nbsp;<code>arr = [-7, 3, 17, 22]</code> ，数组的中间位置为&nbsp;<code>m = ((4 - 1) / 2) = 1</code> ，中位数 <code>arr[m]</code> 的值为 <code>3</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,3,4,5], k = 2\n<strong>输出：</strong>[5,1]\n<strong>解释：</strong>中位数为 3，按从强到弱顺序排序后，数组变为 [5,1,4,2,3]。最强的两个元素是 [5, 1]。[1, 5] 也是正确答案。\n注意，尽管 |5 - 3| == |1 - 3| ，但是 5 比 1 更强，因为 5 &gt; 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,1,3,5,5], k = 2\n<strong>输出：</strong>[5,5]\n<strong>解释：</strong>中位数为 3, 按从强到弱顺序排序后，数组变为 [5,5,1,1,3]。最强的两个元素是 [5, 5]。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [6,7,11,7,6,8], k = 5\n<strong>输出：</strong>[11,8,6,6,7]\n<strong>解释：</strong>中位数为 7, 按从强到弱顺序排序后，数组变为 [11,8,6,6,7,7]。\n[11,8,6,6,7] 的任何排列都是正确答案。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [6,-3,7,2,11], k = 3\n<strong>输出：</strong>[-3,11,2]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [-7,22,17,3], k = 2\n<strong>输出：</strong>[22,17]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>\n\t<li><code>-10^5 &lt;= arr[i] &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= k &lt;= arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1472设计浏览器历史记录",
        "hardRate": "MEDIUM",
        "passRate": "61.48%",
        "problemsUrl": "https://leetcode.cn/problems/design-browser-history/",
        "solutionsUrl": "https://leetcode.cn/problems/design-browser-history/solution",
        "problemsDesc": "<p>你有一个只支持单个标签页的 <strong>浏览器</strong>&nbsp;，最开始你浏览的网页是&nbsp;<code>homepage</code>&nbsp;，你可以访问其他的网站&nbsp;<code>url</code>&nbsp;，也可以在浏览历史中后退&nbsp;<code>steps</code>&nbsp;步或前进&nbsp;<code>steps</code>&nbsp;步。</p>\n\n<p>请你实现&nbsp;<code>BrowserHistory</code> 类：</p>\n\n<ul>\n\t<li><code>BrowserHistory(string homepage)</code>&nbsp;，用&nbsp;<code>homepage</code>&nbsp;初始化浏览器类。</li>\n\t<li><code>void visit(string url)</code>&nbsp;从当前页跳转访问 <code>url</code> 对应的页面&nbsp;&nbsp;。执行此操作会把浏览历史前进的记录全部删除。</li>\n\t<li><code>string back(int steps)</code>&nbsp;在浏览历史中后退&nbsp;<code>steps</code>&nbsp;步。如果你只能在浏览历史中后退至多&nbsp;<code>x</code> 步且&nbsp;<code>steps &gt; x</code>&nbsp;，那么你只后退&nbsp;<code>x</code>&nbsp;步。请返回后退 <strong>至多</strong> <code>steps</code>&nbsp;步以后的&nbsp;<code>url</code>&nbsp;。</li>\n\t<li><code>string forward(int steps)</code>&nbsp;在浏览历史中前进&nbsp;<code>steps</code>&nbsp;步。如果你只能在浏览历史中前进至多&nbsp;<code>x</code>&nbsp;步且&nbsp;<code>steps &gt; x</code>&nbsp;，那么你只前进 <code>x</code>&nbsp;步。请返回前进&nbsp;<strong>至多</strong>&nbsp;<code>steps</code>步以后的 <code>url</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>\n[&quot;BrowserHistory&quot;,&quot;visit&quot;,&quot;visit&quot;,&quot;visit&quot;,&quot;back&quot;,&quot;back&quot;,&quot;forward&quot;,&quot;visit&quot;,&quot;forward&quot;,&quot;back&quot;,&quot;back&quot;]\n[[&quot;leetcode.com&quot;],[&quot;google.com&quot;],[&quot;facebook.com&quot;],[&quot;youtube.com&quot;],[1],[1],[1],[&quot;linkedin.com&quot;],[2],[2],[7]]\n<strong>输出：</strong>\n[null,null,null,null,&quot;facebook.com&quot;,&quot;google.com&quot;,&quot;facebook.com&quot;,null,&quot;linkedin.com&quot;,&quot;google.com&quot;,&quot;leetcode.com&quot;]\n\n<strong>解释：</strong>\nBrowserHistory browserHistory = new BrowserHistory(&quot;leetcode.com&quot;);\nbrowserHistory.visit(&quot;google.com&quot;);       // 你原本在浏览 &quot;leetcode.com&quot; 。访问 &quot;google.com&quot;\nbrowserHistory.visit(&quot;facebook.com&quot;);     // 你原本在浏览 &quot;google.com&quot; 。访问 &quot;facebook.com&quot;\nbrowserHistory.visit(&quot;youtube.com&quot;);      // 你原本在浏览 &quot;facebook.com&quot; 。访问 &quot;youtube.com&quot;\nbrowserHistory.back(1);                   // 你原本在浏览 &quot;youtube.com&quot; ，后退到 &quot;facebook.com&quot; 并返回 &quot;facebook.com&quot;\nbrowserHistory.back(1);                   // 你原本在浏览 &quot;facebook.com&quot; ，后退到 &quot;google.com&quot; 并返回 &quot;google.com&quot;\nbrowserHistory.forward(1);                // 你原本在浏览 &quot;google.com&quot; ，前进到 &quot;facebook.com&quot; 并返回 &quot;facebook.com&quot;\nbrowserHistory.visit(&quot;linkedin.com&quot;);     // 你原本在浏览 &quot;facebook.com&quot; 。 访问 &quot;linkedin.com&quot;\nbrowserHistory.forward(2);                // 你原本在浏览 &quot;linkedin.com&quot; ，你无法前进任何步数。\nbrowserHistory.back(2);                   // 你原本在浏览 &quot;linkedin.com&quot; ，后退两步依次先到 &quot;facebook.com&quot; ，然后到 &quot;google.com&quot; ，并返回 &quot;google.com&quot;\nbrowserHistory.back(7);                   // 你原本在浏览 &quot;google.com&quot;， 你只能后退一步到 &quot;leetcode.com&quot; ，并返回 &quot;leetcode.com&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= homepage.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= url.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= steps &lt;= 100</code></li>\n\t<li><code>homepage</code> 和&nbsp;<code>url</code>&nbsp;都只包含&nbsp;&#39;.&#39; 或者小写英文字母。</li>\n\t<li>最多调用&nbsp;<code>5000</code>&nbsp;次&nbsp;<code>visit</code>，&nbsp;<code>back</code>&nbsp;和&nbsp;<code>forward</code>&nbsp;函数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1473粉刷房子 III",
        "hardRate": "HARD",
        "passRate": "66.34%",
        "problemsUrl": "https://leetcode.cn/problems/paint-house-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/paint-house-iii/solution",
        "problemsDesc": "<p>在一个小城市里，有 <code>m</code> 个房子排成一排，你需要给每个房子涂上 <code>n</code> 种颜色之一（颜色编号为 <code>1</code> 到 <code>n</code> ）。有的房子去年夏天已经涂过颜色了，所以这些房子不可以被重新涂色。</p>\n\n<p>我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 <code>houses = [1,2,2,3,3,2,1,1]</code> ，它包含 5 个街区 <code> [{1}, {2,2}, {3,3}, {2}, {1,1}]</code> 。）</p>\n\n<p>给你一个数组 <code>houses</code> ，一个 <code>m * n</code> 的矩阵 <code>cost</code> 和一个整数 <code>target</code> ，其中：</p>\n\n<ul>\n\t<li><code>houses[i]</code>：是第 <code>i</code> 个房子的颜色，<strong>0</strong> 表示这个房子还没有被涂色。</li>\n\t<li><code>cost[i][j]</code>：是将第 <code>i</code> 个房子涂成颜色 <code>j+1</code> 的花费。</li>\n</ul>\n\n<p>请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成 <code>target</code> 个街区。如果没有可用的涂色方案，请返回 <strong>-1</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3\n<strong>输出：</strong>9\n<strong>解释：</strong>房子涂色方案为 [1,2,2,1,1]\n此方案包含 target = 3 个街区，分别是 [{1}, {2,2}, {1,1}]。\n涂色的总花费为 (1 + 1 + 1 + 1 + 5) = 9。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3\n<strong>输出：</strong>11\n<strong>解释：</strong>有的房子已经被涂色了，在此基础上涂色方案为 [2,2,1,2,2]\n此方案包含 target = 3 个街区，分别是 [{2,2}, {1}, {2,2}]。\n给第一个和最后一个房子涂色的花费为 (10 + 1) = 11。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>houses = [0,0,0,0,0], cost = [[1,10],[10,1],[1,10],[10,1],[1,10]], m = 5, n = 2, target = 5\n<strong>输出：</strong>5\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3\n<strong>输出：</strong>-1\n<strong>解释：</strong>房子已经被涂色并组成了 4 个街区，分别是 [{3},{1},{2},{3}] ，无法形成 target = 3 个街区。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == houses.length == cost.length</code></li>\n\t<li><code>n == cost[i].length</code></li>\n\t<li><code>1 <= m <= 100</code></li>\n\t<li><code>1 <= n <= 20</code></li>\n\t<li><code>1 <= target <= m</code></li>\n\t<li><code>0 <= houses[i] <= n</code></li>\n\t<li><code>1 <= cost[i][j] <= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1474删除链表 M 个节点之后的 N 个节点",
        "hardRate": "EASY",
        "passRate": "69.15%",
        "problemsUrl": "https://leetcode.cn/problems/delete-n-nodes-after-m-nodes-of-a-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-n-nodes-after-m-nodes-of-a-linked-list/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1475商品折扣后的最终价格",
        "hardRate": "EASY",
        "passRate": "73.28%",
        "problemsUrl": "https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/",
        "solutionsUrl": "https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>prices</code>&nbsp;，其中&nbsp;<code>prices[i]</code>&nbsp;是商店里第&nbsp;<code>i</code>&nbsp;件商品的价格。</p>\n\n<p>商店里正在进行促销活动，如果你要买第&nbsp;<code>i</code>&nbsp;件商品，那么你可以得到与 <code>prices[j]</code> 相等的折扣，其中&nbsp;<code>j</code>&nbsp;是满足&nbsp;<code>j &gt; i</code>&nbsp;且&nbsp;<code>prices[j] &lt;= prices[i]</code>&nbsp;的&nbsp;<strong>最小下标</strong>&nbsp;，如果没有满足条件的&nbsp;<code>j</code>&nbsp;，你将没有任何折扣。</p>\n\n<p>请你返回一个数组，数组中第&nbsp;<code>i</code>&nbsp;个元素是折扣后你购买商品 <code>i</code>&nbsp;最终需要支付的价格。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>prices = [8,4,6,2,3]\n<strong>输出：</strong>[4,2,4,2,3]\n<strong>解释：</strong>\n商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。\n商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。\n商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。\n商品 3 和 4 都没有折扣。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>prices = [1,2,3,4,5]\n<strong>输出：</strong>[1,2,3,4,5]\n<strong>解释：</strong>在这个例子中，所有商品都没有折扣。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>prices = [10,1,1,6]\n<strong>输出：</strong>[9,0,1,6]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= prices[i] &lt;= 10^3</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1476子矩形查询",
        "hardRate": "MEDIUM",
        "passRate": "86.59%",
        "problemsUrl": "https://leetcode.cn/problems/subrectangle-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/subrectangle-queries/solution",
        "problemsDesc": "<p>请你实现一个类&nbsp;<code>SubrectangleQueries</code>&nbsp;，它的构造函数的参数是一个 <code>rows x cols</code>&nbsp;的矩形（这里用整数矩阵表示），并支持以下两种操作：</p>\n\n<p>1.<code>&nbsp;updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)</code></p>\n\n<ul>\n\t<li>用&nbsp;<code>newValue</code>&nbsp;更新以&nbsp;<code>(row1,col1)</code>&nbsp;为左上角且以&nbsp;<code>(row2,col2)</code>&nbsp;为右下角的子矩形。</li>\n</ul>\n\n<p>2.<code>&nbsp;getValue(int row, int col)</code></p>\n\n<ul>\n\t<li>返回矩形中坐标 <code>(row,col)</code> 的当前值。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>\n[&quot;SubrectangleQueries&quot;,&quot;getValue&quot;,&quot;updateSubrectangle&quot;,&quot;getValue&quot;,&quot;getValue&quot;,&quot;updateSubrectangle&quot;,&quot;getValue&quot;,&quot;getValue&quot;]\n[[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]]\n<strong>输出：</strong>\n[null,1,null,5,5,null,10,5]\n<strong>解释：</strong>\nSubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]);  \n// 初始的 (4x3) 矩形如下：\n// 1 2 1\n// 4 3 4\n// 3 2 1\n// 1 1 1\nsubrectangleQueries.getValue(0, 2); // 返回 1\nsubrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5);\n// 此次更新后矩形变为：\n// 5 5 5\n// 5 5 5\n// 5 5 5\n// 5 5 5 \nsubrectangleQueries.getValue(0, 2); // 返回 5\nsubrectangleQueries.getValue(3, 1); // 返回 5\nsubrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10);\n// 此次更新后矩形变为：\n// 5   5   5\n// 5   5   5\n// 5   5   5\n// 10  10  10 \nsubrectangleQueries.getValue(3, 1); // 返回 10\nsubrectangleQueries.getValue(0, 2); // 返回 5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>\n[&quot;SubrectangleQueries&quot;,&quot;getValue&quot;,&quot;updateSubrectangle&quot;,&quot;getValue&quot;,&quot;getValue&quot;,&quot;updateSubrectangle&quot;,&quot;getValue&quot;]\n[[[[1,1,1],[2,2,2],[3,3,3]]],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]]\n<strong>输出：</strong>\n[null,1,null,100,100,null,20]\n<strong>解释：</strong>\nSubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,1,1],[2,2,2],[3,3,3]]);\nsubrectangleQueries.getValue(0, 0); // 返回 1\nsubrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100);\nsubrectangleQueries.getValue(0, 0); // 返回 100\nsubrectangleQueries.getValue(2, 2); // 返回 100\nsubrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20);\nsubrectangleQueries.getValue(2, 2); // 返回 20\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>最多有&nbsp;<code>500</code>&nbsp;次<code>updateSubrectangle</code> 和&nbsp;<code>getValue</code>&nbsp;操作。</li>\n\t<li><code>1 &lt;= rows, cols &lt;= 100</code></li>\n\t<li><code>rows ==&nbsp;rectangle.length</code></li>\n\t<li><code>cols == rectangle[i].length</code></li>\n\t<li><code>0 &lt;= row1 &lt;= row2 &lt; rows</code></li>\n\t<li><code>0 &lt;= col1 &lt;= col2 &lt; cols</code></li>\n\t<li><code>1 &lt;= newValue, rectangle[i][j] &lt;= 10^9</code></li>\n\t<li><code>0 &lt;= row &lt; rows</code></li>\n\t<li><code>0 &lt;= col &lt; cols</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1477找两个和为目标值且不重叠的子数组",
        "hardRate": "MEDIUM",
        "passRate": "31.17%",
        "problemsUrl": "https://leetcode.cn/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code> 和一个整数值&nbsp;<code>target</code>&nbsp;。</p>\n\n<p>请你在 <code>arr</code>&nbsp;中找 <strong>两个互不重叠的子数组</strong>&nbsp;且它们的和都等于&nbsp;<code>target</code>&nbsp;。可能会有多种方案，请你返回满足要求的两个子数组长度和的 <strong>最小值</strong> 。</p>\n\n<p>请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 <strong>-1</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,2,2,4,3], target = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>只有两个子数组和为 3 （[3] 和 [3]）。它们的长度和为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [7,3,4,7], target = 7\n<strong>输出：</strong>2\n<strong>解释：</strong>尽管我们有 3 个互不重叠的子数组和为 7 （[7], [3,4] 和 [7]），但我们会选择第一个和第三个子数组，因为它们的长度和 2 是最小值。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [4,3,2,6,2,3,4], target = 6\n<strong>输出：</strong>-1\n<strong>解释：</strong>我们只有一个和为 6 的子数组。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [5,5,4,4,5], target = 3\n<strong>输出：</strong>-1\n<strong>解释：</strong>我们无法找到和为 3 的子数组。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,1,1,1,5,1,2,1], target = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>注意子数组 [1,2] 和 [2,1] 不能成为一个方案因为它们重叠了。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= target &lt;= 10^8</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1478安排邮筒",
        "hardRate": "HARD",
        "passRate": "62.68%",
        "problemsUrl": "https://leetcode.cn/problems/allocate-mailboxes/",
        "solutionsUrl": "https://leetcode.cn/problems/allocate-mailboxes/solution",
        "problemsDesc": "<p>给你一个房屋数组<code>houses</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;，其中&nbsp;<code>houses[i]</code>&nbsp;是第 <code>i</code>&nbsp;栋房子在一条街上的位置，现需要在这条街上安排 <code>k</code>&nbsp;个邮筒。</p>\n\n<p>请你返回每栋房子与离它最近的邮筒之间的距离的 <strong>最小 </strong>总和。</p>\n\n<p>答案保证在 32 位有符号整数范围以内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/13/sample_11_1816.png\" style=\"height: 154px; width: 454px;\"></p>\n\n<pre><strong>输入：</strong>houses = [1,4,8,10,20], k = 3\n<strong>输出：</strong>5\n<strong>解释：</strong>将邮筒分别安放在位置 3， 9 和 20 处。\n每个房子到最近邮筒的距离和为 |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/13/sample_2_1816.png\" style=\"height: 154px; width: 433px;\"></strong></p>\n\n<pre><strong>输入：</strong>houses = [2,3,5,12,18], k = 2\n<strong>输出：</strong>9\n<strong>解释：</strong>将邮筒分别安放在位置 3 和 14 处。\n每个房子到最近邮筒距离和为 |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>houses = [7,4,6,1], k = 1\n<strong>输出：</strong>8\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>houses = [3,6,14,10], k = 4\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == houses.length</code></li>\n\t<li><code>1 &lt;= n&nbsp;&lt;= 100</code></li>\n\t<li><code>1 &lt;= houses[i] &lt;= 10^4</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n\t<li>数组&nbsp;<code>houses</code>&nbsp;中的整数互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1479周内每天的销售情况",
        "hardRate": "HARD",
        "passRate": "55.71%",
        "problemsUrl": "https://leetcode.cn/problems/sales-by-day-of-the-week/",
        "solutionsUrl": "https://leetcode.cn/problems/sales-by-day-of-the-week/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1480一维数组的动态和",
        "hardRate": "EASY",
        "passRate": "76.53%",
        "problemsUrl": "https://leetcode.cn/problems/running-sum-of-1d-array/",
        "solutionsUrl": "https://leetcode.cn/problems/running-sum-of-1d-array/solution",
        "problemsDesc": "<p>给你一个数组 <code>nums</code> 。数组「动态和」的计算公式为：<code>runningSum[i] = sum(nums[0]&hellip;nums[i])</code> 。</p>\n\n<p>请返回 <code>nums</code> 的动态和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>[1,3,6,10]\n<strong>解释：</strong>动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,1,1,1]\n<strong>输出：</strong>[1,2,3,4,5]\n<strong>解释：</strong>动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,1,2,10,1]\n<strong>输出：</strong>[3,4,6,16,17]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-10^6&nbsp;&lt;= nums[i] &lt;=&nbsp;10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1481不同整数的最少数目",
        "hardRate": "MEDIUM",
        "passRate": "45.24%",
        "problemsUrl": "https://leetcode.cn/problems/least-number-of-unique-integers-after-k-removals/",
        "solutionsUrl": "https://leetcode.cn/problems/least-number-of-unique-integers-after-k-removals/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> 和一个整数 <code>k</code> 。现需要从数组中恰好移除 <code>k</code> 个元素，请找出移除后数组中不同整数的最少数目。</p>\n\n<ol>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [5,5,4], k = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>移除 1 个 4 ，数组中只剩下 5 一种整数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [4,3,1,1,3,3,2], k = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>先移除 4、2 ，然后再移除两个 1 中的任意 1 个或者三个 3 中的任意 1 个，最后剩下 1 和 3 两种整数。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length&nbsp;&lt;= 10^5</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10^9</code></li>\n\t<li><code>0 &lt;= k&nbsp;&lt;= arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1482制作 m 束花所需的最少天数",
        "hardRate": "MEDIUM",
        "passRate": "56.77%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>bloomDay</code>，以及两个整数 <code>m</code> 和 <code>k</code> 。</p>\n\n<p>现需要制作 <code>m</code> 束花。制作花束时，需要使用花园中 <strong>相邻的 <code>k</code> 朵花</strong> 。</p>\n\n<p>花园中有 <code>n</code> 朵花，第 <code>i</code> 朵花会在 <code>bloomDay[i]</code> 时盛开，<strong>恰好</strong> 可以用于 <strong>一束</strong> 花中。</p>\n\n<p>请你返回从花园中摘 <code>m</code> 束花需要等待的最少的天数。如果不能摘到 <code>m</code> 束花则返回 <strong>-1</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>bloomDay = [1,10,3,10,2], m = 3, k = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。\n现在需要制作 3 束花，每束只需要 1 朵。\n1 天后：[x, _, _, _, _]   // 只能制作 1 束花\n2 天后：[x, _, _, _, x]   // 只能制作 2 束花\n3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>bloomDay = [1,10,3,10,2], m = 3, k = 2\n<strong>输出：</strong>-1\n<strong>解释：</strong>要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3\n<strong>输出：</strong>12\n<strong>解释：</strong>要制作 2 束花，每束需要 3 朵。\n花园在 7 天后和 12 天后的情况如下：\n7 天后：[x, x, x, x, _, x, x]\n可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。\n12 天后：[x, x, x, x, x, x, x]\n显然，我们可以用不同的方式制作两束花。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>bloomDay = [1000000000,1000000000], m = 1, k = 1\n<strong>输出：</strong>1000000000\n<strong>解释：</strong>需要等 1000000000 天才能采到花来制作花束\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2\n<strong>输出：</strong>9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>bloomDay.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= bloomDay[i] &lt;= 10^9</code></li>\n\t<li><code>1 &lt;= m &lt;= 10^6</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1483树节点的第 K 个祖先",
        "hardRate": "HARD",
        "passRate": "44.94%",
        "problemsUrl": "https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/solution",
        "problemsDesc": "<p>给你一棵树，树上有 <code>n</code> 个节点，按从 <code>0</code> 到 <code>n-1</code> 编号。树以父节点数组的形式给出，其中 <code>parent[i]</code> 是节点 <code>i</code> 的父节点。树的根节点是编号为 <code>0</code> 的节点。</p>\n\n<p>树节点的第 <em><code>k</code> </em>个祖先节点是从该节点到根节点路径上的第 <code>k</code> 个节点。</p>\n\n<p>实现 <code>TreeAncestor</code> 类：</p>\n\n<ul>\n\t<li><code>TreeAncestor（int n， int[] parent）</code> 对树和父数组中的节点数初始化对象。</li>\n\t<li><code>getKthAncestor</code><code>(int node, int k)</code> 返回节点 <code>node</code> 的第 <code>k</code> 个祖先节点。如果不存在这样的祖先节点，返回 <code>-1</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/14/1528_ex1.png\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"TreeAncestor\",\"getKthAncestor\",\"getKthAncestor\",\"getKthAncestor\"]\n[[7,[-1,0,0,1,1,2,2]],[3,1],[5,2],[6,3]]\n\n<strong>输出：</strong>\n[null,1,0,-1]\n\n<strong>解释：</strong>\nTreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);\n\ntreeAncestor.getKthAncestor(3, 1);  // 返回 1 ，它是 3 的父节点\ntreeAncestor.getKthAncestor(5, 2);  // 返回 0 ，它是 5 的祖父节点\ntreeAncestor.getKthAncestor(6, 3);  // 返回 -1 因为不存在满足要求的祖先节点\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>parent[0] == -1</code> 表示编号为 <code>0</code> 的节点是根节点。</li>\n\t<li>对于所有的 <code>0 &lt;&nbsp;i &lt; n</code> ，<code>0 &lt;= parent[i] &lt; n</code> 总成立</li>\n\t<li><code>0 &lt;= node &lt; n</code></li>\n\t<li>至多查询&nbsp;<code>5 * 10<sup>4</sup></code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1484按日期分组销售产品",
        "hardRate": "EASY",
        "passRate": "67.75%",
        "problemsUrl": "https://leetcode.cn/problems/group-sold-products-by-the-date/",
        "solutionsUrl": "https://leetcode.cn/problems/group-sold-products-by-the-date/solution",
        "problemsDesc": "<p>表&nbsp;<code>Activities</code>：</p>\n\n<pre>\n+-------------+---------+\n| 列名         | 类型    |\n+-------------+---------+\n| sell_date   | date    |\n| product     | varchar |\n+-------------+---------+\n此表没有主键，它可能包含重复项。\n此表的每一行都包含产品名称和在市场上销售的日期。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个 SQL 查询来查找每个日期、销售的不同产品的数量及其名称。<br />\n每个日期的销售产品名称应按词典序排列。<br />\n返回按&nbsp;<code>sell_date</code> 排序的结果表。<br />\n查询结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<code><strong>输入：</strong>\nActivities</code> 表：\n+------------+-------------+\n| sell_date  | product     |\n+------------+-------------+\n| 2020-05-30 | Headphone   |\n| 2020-06-01 | Pencil      |\n| 2020-06-02 | Mask        |\n| 2020-05-30 | Basketball  |\n| 2020-06-01 | Bible       |\n| 2020-06-02 | Mask        |\n| 2020-05-30 | T-Shirt     |\n+------------+-------------+\n<strong>输出：</strong>\n+------------+----------+------------------------------+\n| sell_date  | num_sold | products                     |\n+------------+----------+------------------------------+\n| 2020-05-30 | 3        | Basketball,Headphone,T-shirt |\n| 2020-06-01 | 2        | Bible,Pencil                 |\n| 2020-06-02 | 1        | Mask                         |\n+------------+----------+------------------------------+\n<strong>解释：</strong>\n对于2020-05-30，出售的物品是 (Headphone, Basketball, T-shirt)，按词典序排列，并用逗号 ',' 分隔。\n对于2020-06-01，出售的物品是 (Pencil, Bible)，按词典序排列，并用逗号分隔。\n对于2020-06-02，出售的物品是 (Mask)，只需返回该物品名。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1485克隆含随机指针的二叉树",
        "hardRate": "MEDIUM",
        "passRate": "78.64%",
        "problemsUrl": "https://leetcode.cn/problems/clone-binary-tree-with-random-pointer/",
        "solutionsUrl": "https://leetcode.cn/problems/clone-binary-tree-with-random-pointer/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1486数组异或操作",
        "hardRate": "EASY",
        "passRate": "85.50%",
        "problemsUrl": "https://leetcode.cn/problems/xor-operation-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/xor-operation-in-an-array/solution",
        "problemsDesc": "<p>给你两个整数，<code>n</code> 和 <code>start</code> 。</p>\n\n<p>数组 <code>nums</code> 定义为：<code>nums[i] = start + 2*i</code>（下标从 0 开始）且 <code>n == nums.length</code> 。</p>\n\n<p>请返回 <code>nums</code> 中所有元素按位异或（<strong>XOR</strong>）后得到的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 5, start = 0\n<strong>输出：</strong>8\n<strong>解释：</strong>数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。\n     &quot;^&quot; 为按位异或 XOR 运算符。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 4, start = 3\n<strong>输出：</strong>8\n<strong>解释：</strong>数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8.</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 1, start = 7\n<strong>输出：</strong>7\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 10, start = 5\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= start &lt;= 1000</code></li>\n\t<li><code>n == nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1487保证文件名唯一",
        "hardRate": "MEDIUM",
        "passRate": "41.53%",
        "problemsUrl": "https://leetcode.cn/problems/making-file-names-unique/",
        "solutionsUrl": "https://leetcode.cn/problems/making-file-names-unique/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的字符串数组 <code>names</code> 。你将会在文件系统中创建 <code>n</code> 个文件夹：在第 <code>i</code> 分钟，新建名为 <code>names[i]</code> 的文件夹。</p>\n\n<p>由于两个文件 <strong>不能</strong> 共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，系统会以 <code>(k)</code> 的形式为新文件夹的文件名添加后缀，其中 <code>k</code> 是能保证文件名唯一的 <strong>最小正整数</strong> 。</p>\n\n<p>返回长度为<em> <code>n</code></em> 的字符串数组，其中 <code>ans[i]</code> 是创建第 <code>i</code> 个文件夹时系统分配给该文件夹的实际名称。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>names = [&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;]\n<strong>输出：</strong>[&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;]\n<strong>解释：</strong>文件系统将会这样创建文件名：\n&quot;pes&quot; --&gt; 之前未分配，仍为 &quot;pes&quot;\n&quot;fifa&quot; --&gt; 之前未分配，仍为 &quot;fifa&quot;\n&quot;gta&quot; --&gt; 之前未分配，仍为 &quot;gta&quot;\n&quot;pes(2019)&quot; --&gt; 之前未分配，仍为 &quot;pes(2019)&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>names = [&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta&quot;,&quot;avalon&quot;]\n<strong>输出：</strong>[&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta(2)&quot;,&quot;avalon&quot;]\n<strong>解释：</strong>文件系统将会这样创建文件名：\n&quot;gta&quot; --&gt; 之前未分配，仍为 &quot;gta&quot;\n&quot;gta(1)&quot; --&gt; 之前未分配，仍为 &quot;gta(1)&quot;\n&quot;gta&quot; --&gt; 文件名被占用，系统为该名称添加后缀 (k)，由于 &quot;gta(1)&quot; 也被占用，所以 k = 2 。实际创建的文件名为 &quot;gta(2)&quot; 。\n&quot;avalon&quot; --&gt; 之前未分配，仍为 &quot;avalon&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>names = [&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece&quot;]\n<strong>输出：</strong>[&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece(4)&quot;]\n<strong>解释：</strong>当创建最后一个文件夹时，最小的正有效 k 为 4 ，文件名变为 &quot;onepiece(4)&quot;。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>names = [&quot;wano&quot;,&quot;wano&quot;,&quot;wano&quot;,&quot;wano&quot;]\n<strong>输出：</strong>[&quot;wano&quot;,&quot;wano(1)&quot;,&quot;wano(2)&quot;,&quot;wano(3)&quot;]\n<strong>解释：</strong>每次创建文件夹 &quot;wano&quot; 时，只需增加后缀中 k 的值即可。</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>names = [&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido&quot;,&quot;kaido(1)&quot;]\n<strong>输出：</strong>[&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido(2)&quot;,&quot;kaido(1)(1)&quot;]\n<strong>解释：</strong>注意，如果含后缀文件名被占用，那么系统也会按规则在名称后添加新的后缀 (k) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= names.length &lt;= 5 * 10^4</code></li>\n\t<li><code>1 &lt;= names[i].length &lt;= 20</code></li>\n\t<li><code>names[i]</code> 由小写英文字母、数字和/或圆括号组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1488避免洪水泛滥",
        "hardRate": "MEDIUM",
        "passRate": "26.31%",
        "problemsUrl": "https://leetcode.cn/problems/avoid-flood-in-the-city/",
        "solutionsUrl": "https://leetcode.cn/problems/avoid-flood-in-the-city/solution",
        "problemsDesc": "<p>你的国家有无数个湖泊，所有湖泊一开始都是空的。当第 <code>n</code>&nbsp;个湖泊下雨前是空的，那么它就会装满水。如果第 <code>n</code>&nbsp;个湖泊下雨前是 <strong>满的&nbsp;</strong>，这个湖泊会发生 <strong>洪水</strong> 。你的目标是避免任意一个湖泊发生洪水。</p>\n\n<p>给你一个整数数组&nbsp;<code>rains</code>&nbsp;，其中：</p>\n\n<ul>\n\t<li><code>rains[i] &gt; 0</code>&nbsp;表示第 <code>i</code>&nbsp;天时，第 <code>rains[i]</code>&nbsp;个湖泊会下雨。</li>\n\t<li><code>rains[i] == 0</code>&nbsp;表示第 <code>i</code>&nbsp;天没有湖泊会下雨，你可以选择 <strong>一个</strong>&nbsp;湖泊并 <strong>抽干</strong>&nbsp;这个湖泊的水。</li>\n</ul>\n\n<p>请返回一个数组<em>&nbsp;</em><code>ans</code>&nbsp;，满足：</p>\n\n<ul>\n\t<li><code>ans.length == rains.length</code></li>\n\t<li>如果&nbsp;<code>rains[i] &gt; 0</code> ，那么<code>ans[i] == -1</code>&nbsp;。</li>\n\t<li>如果&nbsp;<code>rains[i] == 0</code>&nbsp;，<code>ans[i]</code>&nbsp;是你第&nbsp;<code>i</code>&nbsp;天选择抽干的湖泊。</li>\n</ul>\n\n<p>如果有多种可行解，请返回它们中的 <strong>任意一个</strong>&nbsp;。如果没办法阻止洪水，请返回一个 <strong>空的数组</strong>&nbsp;。</p>\n\n<p>请注意，如果你选择抽干一个装满水的湖泊，它会变成一个空的湖泊。但如果你选择抽干一个空的湖泊，那么将无事发生。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rains = [1,2,3,4]\n<strong>输出：</strong>[-1,-1,-1,-1]\n<strong>解释：</strong>第一天后，装满水的湖泊包括 [1]\n第二天后，装满水的湖泊包括 [1,2]\n第三天后，装满水的湖泊包括 [1,2,3]\n第四天后，装满水的湖泊包括 [1,2,3,4]\n没有哪一天你可以抽干任何湖泊的水，也没有湖泊会发生洪水。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rains = [1,2,0,0,2,1]\n<strong>输出：</strong>[-1,-1,2,1,-1,-1]\n<strong>解释：</strong>第一天后，装满水的湖泊包括 [1]\n第二天后，装满水的湖泊包括 [1,2]\n第三天后，我们抽干湖泊 2 。所以剩下装满水的湖泊包括 [1]\n第四天后，我们抽干湖泊 1 。所以暂时没有装满水的湖泊了。\n第五天后，装满水的湖泊包括 [2]。\n第六天后，装满水的湖泊包括 [1,2]。\n可以看出，这个方案下不会有洪水发生。同时， [-1,-1,1,2,-1,-1] 也是另一个可行的没有洪水的方案。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>rains = [1,2,0,1,2]\n<strong>输出：</strong>[]\n<strong>解释：</strong>第二天后，装满水的湖泊包括 [1,2]。我们可以在第三天抽干一个湖泊的水。\n但第三天后，湖泊 1 和 2 都会再次下雨，所以不管我们第三天抽干哪个湖泊的水，另一个湖泊都会发生洪水。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rains.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= rains[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1489找到最小生成树里的关键边和伪关键边",
        "hardRate": "HARD",
        "passRate": "66.55%",
        "problemsUrl": "https://leetcode.cn/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/solution",
        "problemsDesc": "<p>给你一个 <code>n</code>&nbsp;个点的带权无向连通图，节点编号为 <code>0</code>&nbsp;到 <code>n-1</code>&nbsp;，同时还有一个数组 <code>edges</code>&nbsp;，其中 <code>edges[i] = [from</code><code><sub>i</sub>, to<sub>i</sub>, weight<sub>i</sub>]</code>&nbsp;表示在&nbsp;<code>from<sub>i</sub></code>&nbsp;和&nbsp;<code>to<sub>i</sub></code>&nbsp;节点之间有一条带权无向边。最小生成树&nbsp;(MST) 是给定图中边的一个子集，它连接了所有节点且没有环，而且这些边的权值和最小。</p>\n\n<p>请你找到给定图中最小生成树的所有关键边和伪关键边。如果从图中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。</p>\n\n<p>请注意，你可以分别以任意顺序返回关键边的下标和伪关键边的下标。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/21/ex1.png\" style=\"height: 262px; width: 259px;\"></p>\n\n<pre><strong>输入：</strong>n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\n<strong>输出：</strong>[[0,1],[2,3,4,5]]\n<strong>解释：</strong>上图描述了给定图。\n下图是所有的最小生成树。\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/21/msts.png\" style=\"height: 553px; width: 540px;\">\n注意到第 0 条边和第 1 条边出现在了所有最小生成树中，所以它们是关键边，我们将这两个下标作为输出的第一个列表。\n边 2，3，4 和 5 是所有 MST 的剩余边，所以它们是伪关键边。我们将它们作为输出的第二个列表。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/21/ex2.png\" style=\"height: 253px; width: 247px;\"></p>\n\n<pre><strong>输入：</strong>n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]\n<strong>输出：</strong>[[],[0,1,2,3]]\n<strong>解释：</strong>可以观察到 4 条边都有相同的权值，任选它们中的 3 条可以形成一棵 MST 。所以 4 条边都是伪关键边。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= min(200, n * (n - 1) / 2)</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub> &lt; to<sub>i</sub> &lt; n</code></li>\n\t<li><code>1 &lt;= weight<sub>i</sub>&nbsp;&lt;= 1000</code></li>\n\t<li>所有 <code>(from<sub>i</sub>, to<sub>i</sub>)</code>&nbsp;数对都是互不相同的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1490克隆 N 叉树",
        "hardRate": "MEDIUM",
        "passRate": "83.54%",
        "problemsUrl": "https://leetcode.cn/problems/clone-n-ary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/clone-n-ary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1491去掉最低工资和最高工资后的工资平均值",
        "hardRate": "EASY",
        "passRate": "62.69%",
        "problemsUrl": "https://leetcode.cn/problems/average-salary-excluding-the-minimum-and-maximum-salary/",
        "solutionsUrl": "https://leetcode.cn/problems/average-salary-excluding-the-minimum-and-maximum-salary/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>salary</code>&nbsp;，数组里每个数都是 <strong>唯一</strong>&nbsp;的，其中&nbsp;<code>salary[i]</code> 是第&nbsp;<code>i</code>&nbsp;个员工的工资。</p>\n\n<p>请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>salary = [4000,3000,1000,2000]\n<strong>输出：</strong>2500.00000\n<strong>解释：</strong>最低工资和最高工资分别是 1000 和 4000 。\n去掉最低工资和最高工资以后的平均工资是 (2000+3000)/2= 2500\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>salary = [1000,2000,3000]\n<strong>输出：</strong>2000.00000\n<strong>解释：</strong>最低工资和最高工资分别是 1000 和 3000 。\n去掉最低工资和最高工资以后的平均工资是 (2000)/1= 2000\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>salary = [6000,5000,4000,3000,2000,1000]\n<strong>输出：</strong>3500.00000\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>salary = [8000,9000,2000,3000,6000,1000]\n<strong>输出：</strong>4750.00000\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= salary.length &lt;= 100</code></li>\n\t<li><code>10^3&nbsp;&lt;= salary[i] &lt;= 10^6</code></li>\n\t<li><code>salary[i]</code>&nbsp;是唯一的。</li>\n\t<li>与真实值误差在&nbsp;<code>10^-5</code> 以内的结果都将视为正确答案。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1492n 的第 k 个因子",
        "hardRate": "MEDIUM",
        "passRate": "60.79%",
        "problemsUrl": "https://leetcode.cn/problems/the-kth-factor-of-n/",
        "solutionsUrl": "https://leetcode.cn/problems/the-kth-factor-of-n/solution",
        "problemsDesc": "<p>给你两个正整数&nbsp;<code>n</code> 和&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>如果正整数 <code>i</code> 满足 <code>n % i == 0</code> ，那么我们就说正整数 <code>i</code> 是整数 <code>n</code>&nbsp;的因子。</p>\n\n<p>考虑整数 <code>n</code>&nbsp;的所有因子，将它们 <strong>升序排列</strong>&nbsp;。请你返回第 <code>k</code>&nbsp;个因子。如果 <code>n</code>&nbsp;的因子数少于 <code>k</code>&nbsp;，请你返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 12, k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>因子列表包括 [1, 2, 3, 4, 6, 12]，第 3 个因子是 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 7, k = 2\n<strong>输出：</strong>7\n<strong>解释：</strong>因子列表包括 [1, 7] ，第 2 个因子是 7 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, k = 4\n<strong>输出：</strong>-1\n<strong>解释：</strong>因子列表包括 [1, 2, 4] ，只有 3 个因子，所以我们应该返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<p>你可以设计时间复杂度小于 O(n) 的算法来解决此问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1493删掉一个元素以后全为 1 的最长子数组",
        "hardRate": "MEDIUM",
        "passRate": "59.56%",
        "problemsUrl": "https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/solution",
        "problemsDesc": "<p>给你一个二进制数组&nbsp;<code>nums</code>&nbsp;，你需要从中删掉一个元素。</p>\n\n<p>请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。</p>\n\n<p>如果不存在这样的子数组，请返回 0 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,0,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,1,1,0,1,1,0,1]\n<strong>输出：</strong>5\n<strong>解释：</strong>删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>你必须要删除一个元素。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code>&nbsp;要么是&nbsp;<code>0</code>&nbsp;要么是&nbsp;<code>1</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1494并行课程 II",
        "hardRate": "HARD",
        "passRate": "51.85%",
        "problemsUrl": "https://leetcode.cn/problems/parallel-courses-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/parallel-courses-ii/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;表示某所大学里课程的数目，编号为&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;，数组&nbsp;<code>relations</code>&nbsp;中，&nbsp;<code>relations[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp; 表示一个先修课的关系，也就是课程&nbsp;<code>x<sub>i</sub></code>&nbsp;必须在课程&nbsp;<code>y<sub>i</sub></code><sub>&nbsp;</sub>之前上。同时你还有一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>在一个学期中，你 <strong>最多</strong>&nbsp;可以同时上 <code>k</code>&nbsp;门课，前提是这些课的先修课在之前的学期里已经上过了。</p>\n\n<p>请你返回上完所有课最少需要多少个学期。题目保证一定存在一种上完所有课的方式。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/27/leetcode_parallel_courses_1.png\" style=\"height: 164px; width: 300px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, relations = [[2,1],[3,1],[1,4]], k = 2\n<strong>输出：</strong>3 \n<strong>解释：</strong>上图展示了题目输入的图。在第一个学期中，我们可以上课程 2 和课程 3 。然后第二个学期上课程 1 ，第三个学期上课程 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/27/leetcode_parallel_courses_2.png\" style=\"height: 234px; width: 300px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2\n<strong>输出：</strong>4 \n<strong>解释：</strong>上图展示了题目输入的图。一个最优方案是：第一学期上课程 2 和 3，第二学期上课程 4 ，第三学期上课程 1 ，第四学期上课程 5 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 11, relations = [], k = 2\n<strong>输出：</strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 15</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n\t<li><code>0 &lt;=&nbsp;relations.length &lt;= n * (n-1) / 2</code></li>\n\t<li><code>relations[i].length == 2</code></li>\n\t<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= n</code></li>\n\t<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>\n\t<li>所有先修关系都是不同的，也就是说&nbsp;<code>relations[i] != relations[j]</code>&nbsp;。</li>\n\t<li>题目输入的图是个有向无环图。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1495上月播放的儿童适宜电影",
        "hardRate": "EASY",
        "passRate": "53.56%",
        "problemsUrl": "https://leetcode.cn/problems/friendly-movies-streamed-last-month/",
        "solutionsUrl": "https://leetcode.cn/problems/friendly-movies-streamed-last-month/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1496判断路径是否相交",
        "hardRate": "EASY",
        "passRate": "53.53%",
        "problemsUrl": "https://leetcode.cn/problems/path-crossing/",
        "solutionsUrl": "https://leetcode.cn/problems/path-crossing/solution",
        "problemsDesc": "<p>给你一个字符串 <code>path</code>，其中 <code>path[i]</code> 的值可以是 <code>'N'</code>、<code>'S'</code>、<code>'E'</code> 或者 <code>'W'</code>，分别表示向北、向南、向东、向西移动一个单位。</p>\n\n<p>你从二维平面上的原点 <code>(0, 0)</code> 处开始出发，按 <code>path</code> 所指示的路径行走。</p>\n\n<p>如果路径在任何位置上与自身相交，也就是走到之前已经走过的位置，请返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/28/screen-shot-2020-06-10-at-123929-pm.png\" style=\"height: 358px; width: 400px;\" /></p>\n\n<pre>\n<strong>输入：</strong>path = \"NES\"\n<strong>输出：</strong>false \n<strong>解释：</strong>该路径没有在任何位置相交。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/28/screen-shot-2020-06-10-at-123843-pm.png\" style=\"height: 339px; width: 400px;\" /></p>\n\n<pre>\n<strong>输入：</strong>path = \"NESWW\"\n<strong>输出：</strong>true\n<strong>解释：</strong>该路径经过原点两次。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= path.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>path[i]</code> 为 <code>'N'</code>、<code>'S'</code>、<code>'E'</code> 或 <code>'W'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1497检查数组对是否可以被 k 整除",
        "hardRate": "MEDIUM",
        "passRate": "40.15%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-array-pairs-are-divisible-by-k/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-array-pairs-are-divisible-by-k/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> 和一个整数 <code>k</code> ，其中数组长度是偶数，值为 <code>n</code> 。</p>\n\n<p>现在需要把数组恰好分成 <code>n /&nbsp;2</code> 对，以使每对数字的和都能够被 <code>k</code> 整除。</p>\n\n<p>如果存在这样的分法，请返回 <em>True</em> ；否则，返回 <em>False</em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n<strong>输出：</strong>true\n<strong>解释：</strong>划分后的数字对为 (1,9),(2,8),(3,7),(4,6) 以及 (5,10) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,4,5,6], k = 7\n<strong>输出：</strong>true\n<strong>解释：</strong>划分后的数字对为 (1,6),(2,5) 以及 (3,4) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,4,5,6], k = 10\n<strong>输出：</strong>false\n<strong>解释：</strong>无法在将数组中的数字分为三对的同时满足每对数字和能够被 10 整除的条件。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>arr.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>n</code> 为偶数<meta charset=\"UTF-8\" /></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1498满足条件的子序列数目",
        "hardRate": "MEDIUM",
        "passRate": "38.22%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>\n\n<p>请你统计并返回 <code>nums</code> 中能满足其最小元素与最大元素的 <strong>和</strong> 小于或等于 <code>target</code> 的 <strong>非空</strong> 子序列的数目。</p>\n\n<p>由于答案可能很大，请将结果对<meta charset=\"UTF-8\" />&nbsp;<code>10<sup>9</sup>&nbsp;+ 7</code>&nbsp;取余后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,5,6,7], target = 9\n<strong>输出：</strong>4\n<strong>解释：</strong>有 4 个子序列满足该条件。\n[3] -&gt; 最小元素 + 最大元素 &lt;= target (3 + 3 &lt;= 9)\n[3,5] -&gt; (3 + 5 &lt;= 9)\n[3,5,6] -&gt; (3 + 6 &lt;= 9)\n[3,6] -&gt; (3 + 6 &lt;= 9)\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,3,6,8], target = 10\n<strong>输出：</strong>6\n<strong>解释：</strong>有 6 个子序列满足该条件。（nums 中可以有重复数字）\n[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,3,4,6,7], target = 12\n<strong>输出：</strong>61\n<strong>解释：</strong>共有 63 个非空子序列，其中 2 个不满足条件（[6,7], [7]）\n有效序列总数为（63 - 2 = 61）\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= target &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1499满足不等式的最大值",
        "hardRate": "HARD",
        "passRate": "40.97%",
        "problemsUrl": "https://leetcode.cn/problems/max-value-of-equation/",
        "solutionsUrl": "https://leetcode.cn/problems/max-value-of-equation/solution",
        "problemsDesc": "<p>给你一个数组 <code>points</code> 和一个整数 <code>k</code> 。数组中每个元素都表示二维平面上的点的坐标，并按照横坐标 x 的值从小到大排序。也就是说 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> ，并且在 <code>1 &lt;= i &lt; j &lt;= points.length</code> 的前提下， <code>x<sub>i</sub> &lt; x<sub>j</sub></code> 总成立。</p>\n\n<p>请你找出<em> </em><code>y<sub>i</sub>&nbsp;+ y<sub>j</sub>&nbsp;+ |x<sub>i</sub>&nbsp;- x<sub>j</sub>|</code> 的 <strong>最大值</strong>，其中 <code>|x<sub>i</sub>&nbsp;- x<sub>j</sub>|&nbsp;&lt;= k</code> 且 <code>1 &lt;= i &lt; j &lt;= points.length</code>。</p>\n\n<p>题目测试数据保证至少存在一对能够满足 <code>|x<sub>i</sub>&nbsp;- x<sub>j</sub>|&nbsp;&lt;= k</code> 的点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>points = [[1,3],[2,0],[5,10],[6,-10]], k = 1\n<strong>输出：</strong>4\n<strong>解释：</strong>前两个点满足 |x<sub>i</sub>&nbsp;- x<sub>j</sub>| &lt;= 1 ，代入方程计算，则得到值 3 + 0 + |1 - 2| = 4 。第三个和第四个点也满足条件，得到值 10 + -10 + |5 - 6| = 1 。\n没有其他满足条件的点，所以返回 4 和 1 中最大的那个。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>points = [[0,0],[3,0],[9,2]], k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>只有前两个点满足 |x<sub>i</sub>&nbsp;- x<sub>j</sub>| &lt;= 3 ，代入方程后得到值 0 + 0 + |0 - 3| = 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= points.length &lt;= 10^5</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>-10^8&nbsp;&lt;= points[i][0], points[i][1] &lt;= 10^8</code></li>\n\t<li><code>0 &lt;= k &lt;= 2 * 10^8</code></li>\n\t<li>对于所有的<code>1 &lt;= i &lt; j &lt;= points.length</code> ，<code>points[i][0] &lt; points[j][0]</code> 都成立。也就是说，<code>x<sub>i</sub></code> 是严格递增的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1500设计文件分享系统",
        "hardRate": "MEDIUM",
        "passRate": "29.76%",
        "problemsUrl": "https://leetcode.cn/problems/design-a-file-sharing-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-a-file-sharing-system/solution",
        "problemsDesc": null,
        "isPlus": true
    }
]