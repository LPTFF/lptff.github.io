[
    {
        "problemsName": " 601.体育馆的人流量",
        "hardRate": "HARD",
        "passRate": "48.02%",
        "problemsUrl": "https://leetcode.cn/problems/human-traffic-of-stadium/",
        "solutionsUrl": "https://leetcode.cn/problems/human-traffic-of-stadium/solution",
        "problemsDesc": "表：<code>Stadium</code>\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| visit_date    | date    |\n| people        | int     |\n+---------------+---------+\nvisit_date 是表的主键\n每日人流量信息被记录在这三列信息中：<strong>序号</strong> (id)、<strong>日期</strong> (visit_date)、&nbsp;<strong>人流量</strong> (people)\n每天只有一行记录，日期随着 id 的增加而增加\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个 SQL 查询以找出每行的人数大于或等于 <code>100</code> 且 <code>id</code> 连续的三行或更多行记录。</p>\n\n<p>返回按 <code>visit_date</code> <strong>升序排列</strong> 的结果表。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<code><strong>输入：</strong>\nStadium</code> 表:\n+------+------------+-----------+\n| id   | visit_date | people    |\n+------+------------+-----------+\n| 1    | 2017-01-01 | 10        |\n| 2    | 2017-01-02 | 109       |\n| 3    | 2017-01-03 | 150       |\n| 4    | 2017-01-04 | 99        |\n| 5    | 2017-01-05 | 145       |\n| 6    | 2017-01-06 | 1455      |\n| 7    | 2017-01-07 | 199       |\n| 8    | 2017-01-09 | 188       |\n+------+------------+-----------+\n<strong>输出：</strong>\n+------+------------+-----------+\n| id   | visit_date | people    |\n+------+------------+-----------+\n| 5    | 2017-01-05 | 145       |\n| 6    | 2017-01-06 | 1455      |\n| 7    | 2017-01-07 | 199       |\n| 8    | 2017-01-09 | 188       |\n+------+------------+-----------+\n<strong>解释：\nid</strong> 为 5、6、7、8 的四行 id 连续，并且每行都有 &gt;= 100 的人数记录。\n请注意，即使第 7 行和第 8 行的 visit_date 不是连续的，输出也应当包含第 8 行，因为我们只需要考虑 id 连续的记录。\n不输出 id 为 2 和 3 的行，因为至少需要三条 id 连续的记录。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 602.好友申请 II ：谁有最多的好友",
        "hardRate": "MEDIUM",
        "passRate": "61.07%",
        "problemsUrl": "https://leetcode.cn/problems/friend-requests-ii-who-has-the-most-friends/",
        "solutionsUrl": "https://leetcode.cn/problems/friend-requests-ii-who-has-the-most-friends/solution",
        "problemsDesc": "<p>在 Facebook 或者 Twitter 这样的社交应用中，人们经常会发好友申请也会收到其他人的好友申请。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p><code>RequestAccepted</code> 表：</p>\n\n<pre>\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| requester_id   | int     |\n| accepter_id    | int     |\n| accept_date    | date    |\n+----------------+---------+\n(requester_id, accepter_id) 是这张表的主键。\n这张表包含发送好友请求的人的 ID ，接收好友请求的人的 ID ，以及好友请求通过的日期。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一个查询语句，找出拥有最多的好友的人和他拥有的好友数目。</p>\n\n<p>生成的测试用例保证拥有最多好友数目的只有 1 个人。</p>\n\n<p>查询结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nRequestAccepted 表：\n+--------------+-------------+-------------+\n| requester_id | accepter_id | accept_date |\n+--------------+-------------+-------------+\n| 1            | 2           | 2016/06/03  |\n| 1            | 3           | 2016/06/08  |\n| 2            | 3           | 2016/06/08  |\n| 3            | 4           | 2016/06/09  |\n+--------------+-------------+-------------+\n<strong>输出：</strong>\n+----+-----+\n| id | num |\n+----+-----+\n| 3  | 3   |\n+----+-----+\n<strong>解释：</strong>\n编号为 3 的人是编号为 1 ，2 和 4 的人的好友，所以他总共有 3 个好友，比其他人都多。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>在真实世界里，可能会有多个人拥有好友数相同且最多，你能找到所有这些人吗？</p>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 603.连续空余座位",
        "hardRate": "EASY",
        "passRate": "64.03%",
        "problemsUrl": "https://leetcode.cn/problems/consecutive-available-seats/",
        "solutionsUrl": "https://leetcode.cn/problems/consecutive-available-seats/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 604.迭代压缩字符串",
        "hardRate": "EASY",
        "passRate": "38.81%",
        "problemsUrl": "https://leetcode.cn/problems/design-compressed-string-iterator/",
        "solutionsUrl": "https://leetcode.cn/problems/design-compressed-string-iterator/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 605.种花问题",
        "hardRate": "EASY",
        "passRate": "32.29%",
        "problemsUrl": "https://leetcode.cn/problems/can-place-flowers/",
        "solutionsUrl": "https://leetcode.cn/problems/can-place-flowers/solution",
        "problemsDesc": "<p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>\n\n<p>给你一个整数数组&nbsp;<code>flowerbed</code> 表示花坛，由若干 <code>0</code> 和 <code>1</code> 组成，其中 <code>0</code> 表示没种植花，<code>1</code> 表示种植了花。另有一个数&nbsp;<code>n</code><strong> </strong>，能否在不打破种植规则的情况下种入&nbsp;<code>n</code><strong>&nbsp;</strong>朵花？能则返回 <code>true</code> ，不能则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>flowerbed = [1,0,0,0,1], n = 1\n<strong>输出：</strong>true\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>flowerbed = [1,0,0,0,1], n = 2\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= flowerbed.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>flowerbed[i]</code> 为 <code>0</code> 或 <code>1</code></li>\n\t<li><code>flowerbed</code> 中不存在相邻的两朵花</li>\n\t<li><code>0 &lt;= n &lt;= flowerbed.length</code></li>\n</ul>",
        "isPlus": false
    },
    {
        "problemsName": " 606.根据二叉树创建字符串",
        "hardRate": "EASY",
        "passRate": "62.20%",
        "problemsUrl": "https://leetcode.cn/problems/construct-string-from-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-string-from-binary-tree/solution",
        "problemsDesc": "<p>给你二叉树的根节点 <code>root</code> ，请你采用前序遍历的方式，将二叉树转化为一个由括号和整数组成的字符串，返回构造出的字符串。</p>\n\n<p>空节点使用一对空括号对 <code>\"()\"</code> 表示，转化后需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/cons1-tree.jpg\" style=\"width: 292px; height: 301px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,4]\n<strong>输出：</strong>\"1(2(4))(3)\"\n<strong>解释：</strong>初步转化后得到 \"1(2(4)())(3()())\" ，但省略所有不必要的空括号对后，字符串应该是\"1(2(4))(3)\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/cons2-tree.jpg\" style=\"width: 207px; height: 293px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,null,4]\n<strong>输出：</strong>\"1(2()(4))(3)\"\n<strong>解释：</strong>和第一个示例类似，但是无法省略第一个空括号对，否则会破坏输入与输出一一映射的关系。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目范围是 <code>[1, 10<sup>4</sup>]</code></li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 607.销售员",
        "hardRate": "EASY",
        "passRate": "68.18%",
        "problemsUrl": "https://leetcode.cn/problems/sales-person/",
        "solutionsUrl": "https://leetcode.cn/problems/sales-person/solution",
        "problemsDesc": "<p>表:&nbsp;<code>SalesPerson</code></p>\n\n<pre>\n+-----------------+---------+\n| Column Name     | Type    |\n+-----------------+---------+\n| sales_id        | int     |\n| name            | varchar |\n| salary          | int     |\n| commission_rate | int     |\n| hire_date       | date    |\n+-----------------+---------+\nsales_id 是该表的主键列。\n该表的每一行都显示了销售人员的姓名和 ID ，以及他们的工资、佣金率和雇佣日期。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>表:&nbsp;<code>Company</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| com_id      | int     |\n| name        | varchar |\n| city        | varchar |\n+-------------+---------+\ncom_id 是该表的主键列。\n该表的每一行都表示公司的名称和 ID ，以及公司所在的城市。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>表:&nbsp;<code>Orders</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| order_id    | int  |\n| order_date  | date |\n| com_id      | int  |\n| sales_id    | int  |\n| amount      | int  |\n+-------------+------+\norder_id 是该表的主键列。\ncom_id 是 Company 表中 com_id 的外键。\nsales_id 是来自销售员表 sales_id 的外键。\n该表的每一行包含一个订单的信息。这包括公司的 ID 、销售人员的 ID 、订单日期和支付的金额。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个SQL查询，报告没有任何与名为 <strong>“RED”</strong> 的公司相关的订单的所有销售人员的姓名。</p>\n\n<p>以 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nSalesPerson 表:\n+----------+------+--------+-----------------+------------+\n| sales_id | name | salary | commission_rate | hire_date  |\n+----------+------+--------+-----------------+------------+\n| 1        | John | 100000 | 6               | 4/1/2006   |\n| 2        | Amy  | 12000  | 5               | 5/1/2010   |\n| 3        | Mark | 65000  | 12              | 12/25/2008 |\n| 4        | Pam  | 25000  | 25              | 1/1/2005   |\n| 5        | Alex | 5000   | 10              | 2/3/2007   |\n+----------+------+--------+-----------------+------------+\nCompany 表:\n+--------+--------+----------+\n| com_id | name   | city     |\n+--------+--------+----------+\n| 1      | RED    | Boston   |\n| 2      | ORANGE | New York |\n| 3      | YELLOW | Boston   |\n| 4      | GREEN  | Austin   |\n+--------+--------+----------+\nOrders 表:\n+----------+------------+--------+----------+--------+\n| order_id | order_date | com_id | sales_id | amount |\n+----------+------------+--------+----------+--------+\n| 1        | 1/1/2014   | 3      | 4        | 10000  |\n| 2        | 2/1/2014   | 4      | 5        | 5000   |\n| 3        | 3/1/2014   | 1      | 1        | 50000  |\n| 4        | 4/1/2014   | 1      | 4        | 25000  |\n+----------+------------+--------+----------+--------+\n<strong>输出：</strong>\n+------+\n| name |\n+------+\n| Amy  |\n| Mark |\n| Alex |\n+------+\n<strong>解释：</strong>\n根据表&nbsp;<code>orders</code>&nbsp;中的订单 '3' 和 '4' ，容易看出只有 'John' 和 'Pam' 两个销售员曾经向公司 'RED' 销售过。\n所以我们需要输出表&nbsp;<code>salesperson</code>&nbsp;中所有其他人的名字。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 608.树节点",
        "hardRate": "MEDIUM",
        "passRate": "61.05%",
        "problemsUrl": "https://leetcode.cn/problems/tree-node/",
        "solutionsUrl": "https://leetcode.cn/problems/tree-node/solution",
        "problemsDesc": "<p>给定一个表&nbsp;<code>tree</code>，<strong>id</strong> 是树节点的编号，&nbsp;<strong>p_id</strong>&nbsp;是它父节点的&nbsp;<strong>id 。</strong></p>\n\n<pre>+----+------+\n| id | p_id |\n+----+------+\n| 1  | null |\n| 2  | 1    |\n| 3  | 1    |\n| 4  | 2    |\n| 5  | 2    |\n+----+------+</pre>\n\n<p>树中每个节点属于以下三种类型之一：</p>\n\n<ul>\n\t<li>叶子：如果这个节点没有任何孩子节点。</li>\n\t<li>根：如果这个节点是整棵树的根，即没有父节点。</li>\n\t<li>内部节点：如果这个节点既不是叶子节点也不是根节点。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>写一个查询语句，输出所有节点的编号和节点的类型，并将结果按照节点编号排序。上面样例的结果为：</p>\n\n<p>&nbsp;</p>\n\n<pre>+----+------+\n| id | Type |\n+----+------+\n| 1  | Root |\n| 2  | Inner|\n| 3  | Leaf |\n| 4  | Leaf |\n| 5  | Leaf |\n+----+------+\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>解释</strong></p>\n\n<ul>\n\t<li>节点 &#39;1&#39; 是根节点，因为它的父节点是 NULL ，同时它有孩子节点 &#39;2&#39; 和 &#39;3&#39; 。</li>\n\t<li>节点 &#39;2&#39; 是内部节点，因为它有父节点 &#39;1&#39; ，也有孩子节点 &#39;4&#39; 和 &#39;5&#39; 。</li>\n\t<li>节点 &#39;3&#39;, &#39;4&#39; 和 &#39;5&#39; 都是叶子节点，因为它们都有父节点同时没有孩子节点。</li>\n\t<li>样例中树的形态如下：\n\t<p>&nbsp;</p>\n\n\t<pre>\t\t\t  1\n\t\t\t/   \\\n                      2       3\n                    /   \\\n                  4       5\n</pre>\n\n\t<p>&nbsp;</p>\n\t</li>\n</ul>\n\n<p><strong>注意</strong></p>\n\n<p>如果树中只有一个节点，你只需要输出它的根属性。</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 609.在系统中查找重复文件",
        "hardRate": "MEDIUM",
        "passRate": "52.45%",
        "problemsUrl": "https://leetcode.cn/problems/find-duplicate-file-in-system/",
        "solutionsUrl": "https://leetcode.cn/problems/find-duplicate-file-in-system/solution",
        "problemsDesc": "<p>给你一个目录信息列表&nbsp;<code>paths</code> ，包括目录路径，以及该目录中的所有文件及其内容，请你按路径返回文件系统中的所有重复文件。答案可按 <strong>任意顺序</strong> 返回。</p>\n\n<p>一组重复的文件至少包括 <strong>两个 </strong>具有完全相同内容的文件。</p>\n\n<p><strong>输入 </strong>列表中的单个目录信息字符串的格式如下：</p>\n\n<ul>\n\t<li><code>\"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)\"</code></li>\n</ul>\n\n<p>这意味着，在目录&nbsp;<code>root/d1/d2/.../dm</code>&nbsp;下，有 <code>n</code> 个文件 ( <code>f1.txt</code>,&nbsp;<code>f2.txt</code>&nbsp;...&nbsp;<code>fn.txt</code> ) 的内容分别是 ( <code>f1_content</code>,&nbsp;<code>f2_content</code>&nbsp;...&nbsp;<code>fn_content</code> ) 。注意：<code>n &gt;= 1</code> 且 <code>m &gt;= 0</code> 。如果 <code>m = 0</code> ，则表示该目录是根目录。</p>\n\n<p><strong>输出 </strong>是由 <strong>重复文件路径组</strong> 构成的列表。其中每个组由所有具有相同内容文件的文件路径组成。文件路径是具有下列格式的字符串：</p>\n\n<ul>\n\t<li><code>\"directory_path/file_name.txt\"</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]\n<strong>输出：</strong>[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]\n<strong>输出：</strong>[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= paths.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= paths[i].length &lt;= 3000</code></li>\n\t<li><code>1 &lt;= sum(paths[i].length) &lt;= 5 * 10<sup>5</sup></code></li>\n\t<li><code>paths[i]</code> 由英文字母、数字、字符 <code>'/'</code>、<code>'.'</code>、<code>'('</code>、<code>')'</code> 和 <code>' '</code> 组成</li>\n\t<li>你可以假设在同一目录中没有任何文件或目录共享相同的名称。</li>\n\t<li>你可以假设每个给定的目录信息代表一个唯一的目录。目录路径和文件信息用单个空格分隔。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>假设您有一个真正的文件系统，您将如何搜索文件？广度搜索还是宽度搜索？</li>\n\t<li>如果文件内容非常大（GB级别），您将如何修改您的解决方案？</li>\n\t<li>如果每次只能读取 1 kb 的文件，您将如何修改解决方案？</li>\n\t<li>修改后的解决方案的时间复杂度是多少？其中最耗时的部分和消耗内存的部分是什么？如何优化？</li>\n\t<li>如何确保您发现的重复文件不是误报？</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 610.判断三角形",
        "hardRate": "EASY",
        "passRate": "64.43%",
        "problemsUrl": "https://leetcode.cn/problems/triangle-judgement/",
        "solutionsUrl": "https://leetcode.cn/problems/triangle-judgement/solution",
        "problemsDesc": "<p>表:&nbsp;<code>Triangle</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| x           | int  |\n| y           | int  |\n| z           | int  |\n+-------------+------+\n(x, y, z)是该表的主键列。\n该表的每一行包含三个线段的长度。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一个SQL查询，每三个线段报告它们是否可以形成一个三角形。</p>\n\n<p>以&nbsp;<strong>任意顺序&nbsp;</strong>返回结果表。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nTriangle 表:\n+----+----+----+\n| x  | y  | z  |\n+----+----+----+\n| 13 | 15 | 30 |\n| 10 | 20 | 15 |\n+----+----+----+\n<strong>输出:</strong> \n+----+----+----+----------+\n| x  | y  | z  | triangle |\n+----+----+----+----------+\n| 13 | 15 | 30 | No       |\n| 10 | 20 | 15 | Yes      |\n+----+----+----+----------+</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 611.有效三角形的个数",
        "hardRate": "MEDIUM",
        "passRate": "53.73%",
        "problemsUrl": "https://leetcode.cn/problems/valid-triangle-number/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-triangle-number/solution",
        "problemsDesc": "<p>给定一个包含非负整数的数组&nbsp;<code>nums</code> ，返回其中可以组成三角形三条边的三元组个数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [2,2,3,4]\n<strong>输出:</strong> 3\n<strong>解释:</strong>有效的组合是: \n2,3,4 (使用第一个 2)\n2,3,4 (使用第二个 2)\n2,2,3\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [4,2,3,4]\n<strong>输出:</strong> 4</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 612.平面上的最近距离",
        "hardRate": "MEDIUM",
        "passRate": "64.97%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-distance-in-a-plane/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-distance-in-a-plane/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 613.直线上的最近距离",
        "hardRate": "EASY",
        "passRate": "79.64%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-distance-in-a-line/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-distance-in-a-line/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 614.二级关注者",
        "hardRate": "MEDIUM",
        "passRate": "37.27%",
        "problemsUrl": "https://leetcode.cn/problems/second-degree-follower/",
        "solutionsUrl": "https://leetcode.cn/problems/second-degree-follower/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 615.平均工资：部门与公司比较",
        "hardRate": "HARD",
        "passRate": "42.33%",
        "problemsUrl": "https://leetcode.cn/problems/average-salary-departments-vs-company/",
        "solutionsUrl": "https://leetcode.cn/problems/average-salary-departments-vs-company/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 616.给字符串添加加粗标签",
        "hardRate": "MEDIUM",
        "passRate": "49.31%",
        "problemsUrl": "https://leetcode.cn/problems/add-bold-tag-in-string/",
        "solutionsUrl": "https://leetcode.cn/problems/add-bold-tag-in-string/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 617.合并二叉树",
        "hardRate": "EASY",
        "passRate": "79.15%",
        "problemsUrl": "https://leetcode.cn/problems/merge-two-binary-trees/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-two-binary-trees/solution",
        "problemsDesc": "<p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p>\n\n<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p>\n\n<p>返回合并后的二叉树。</p>\n\n<p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/05/merge.jpg\" style=\"height: 163px; width: 600px;\" />\n<pre>\n<strong>输入：</strong>root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\n<strong>输出：</strong>[3,4,5,5,4,null,7]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root1 = [1], root2 = [1,2]\n<strong>输出：</strong>[2,2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 618.学生地理信息报告",
        "hardRate": "HARD",
        "passRate": "62.23%",
        "problemsUrl": "https://leetcode.cn/problems/students-report-by-geography/",
        "solutionsUrl": "https://leetcode.cn/problems/students-report-by-geography/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 619.只出现一次的最大数字",
        "hardRate": "EASY",
        "passRate": "48.27%",
        "problemsUrl": "https://leetcode.cn/problems/biggest-single-number/",
        "solutionsUrl": "https://leetcode.cn/problems/biggest-single-number/solution",
        "problemsDesc": "<p><code>MyNumbers</code> 表：</p>\n\n<div class=\"original__bRMd\">\n<div>\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| num         | int  |\n+-------------+------+\n这张表没有主键。可能包含重复数字。\n这张表的每一行都含有一个整数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>单一数字</strong> 是在 <code>MyNumbers</code> 表中只出现一次的数字。</p>\n\n<p>请你编写一个 SQL 查询来报告最大的 <strong>单一数字</strong> 。如果不存在 <strong>单一数字</strong> ，查询需报告 <code>null</code> 。</p>\n\n<p>查询结果如下例所示。</p>\n<ptable> </ptable>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nMyNumbers 表：\n+-----+\n| num |\n+-----+\n| 8   |\n| 8   |\n| 3   |\n| 3   |\n| 1   |\n| 4   |\n| 5   |\n| 6   |\n+-----+\n<strong>输出：</strong>\n+-----+\n| num |\n+-----+\n| 6   |\n+-----+\n<strong>解释：</strong>单一数字有 1、4、5 和 6 。\n6 是最大的单一数字，返回 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nMyNumbers table:\n+-----+\n| num |\n+-----+\n| 8   |\n| 8   |\n| 7   |\n| 7   |\n| 3   |\n| 3   |\n| 3   |\n+-----+\n<strong>输出：</strong>\n+------+\n| num  |\n+------+\n| null |\n+------+\n<strong>解释：</strong>输入的表中不存在单一数字，所以返回 null 。\n</pre>\n</div>\n</div>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 620.有趣的电影",
        "hardRate": "EASY",
        "passRate": "77.15%",
        "problemsUrl": "https://leetcode.cn/problems/not-boring-movies/",
        "solutionsUrl": "https://leetcode.cn/problems/not-boring-movies/solution",
        "problemsDesc": "<p>某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。</p>\n\n<p>作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为<strong>非</strong>&nbsp;<code>boring</code>&nbsp;(不无聊)&nbsp;的并且<strong> id 为奇数&nbsp;</strong>的影片，结果请按等级 <code>rating</code> 排列。</p>\n\n<p>&nbsp;</p>\n\n<p>例如，下表 <code>cinema</code>:</p>\n\n<pre>\n+---------+-----------+--------------+-----------+\n|   id    | movie     |  description |  rating   |\n+---------+-----------+--------------+-----------+\n|   1     | War       |   great 3D   |   8.9     |\n|   2     | Science   |   fiction    |   8.5     |\n|   3     | irish     |   boring     |   6.2     |\n|   4     | Ice song  |   Fantacy    |   8.6     |\n|   5     | House card|   Interesting|   9.1     |\n+---------+-----------+--------------+-----------+\n</pre>\n\n<p>对于上面的例子，则正确的输出是为：</p>\n\n<pre>\n+---------+-----------+--------------+-----------+\n|   id    | movie     |  description |  rating   |\n+---------+-----------+--------------+-----------+\n|   5     | House card|   Interesting|   9.1     |\n|   1     | War       |   great 3D   |   8.9     |\n+---------+-----------+--------------+-----------+\n</pre>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 621.任务调度器",
        "hardRate": "MEDIUM",
        "passRate": "59.75%",
        "problemsUrl": "https://leetcode.cn/problems/task-scheduler/",
        "solutionsUrl": "https://leetcode.cn/problems/task-scheduler/solution",
        "problemsDesc": "<p>给你一个用字符数组 <code>tasks</code> 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p>\n\n<p>然而，两个<strong> 相同种类</strong> 的任务之间必须有长度为整数<strong> </strong><code>n</code><strong> </strong>的冷却时间，因此至少有连续 <code>n</code> 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p>\n\n<p>你需要计算完成所有任务所需要的<strong> 最短时间</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\n<strong>输出：</strong>8\n<strong>解释：</strong>A -> B -> (待命) -> A -> B -> (待命) -> A -> B\n     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 </pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 0\n<strong>输出：</strong>6\n<strong>解释：</strong>在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0\n[\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"]\n[\"A\",\"B\",\"A\",\"B\",\"A\",\"B\"]\n[\"B\",\"B\",\"B\",\"A\",\"A\",\"A\"]\n...\n诸如此类\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>tasks = [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"], n = 2\n<strong>输出：</strong>16\n<strong>解释：</strong>一种可能的解决方案是：\n     A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> (待命) -> (待命) -> A -> (待命) -> (待命) -> A\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= task.length <= 10<sup>4</sup></code></li>\n\t<li><code>tasks[i]</code> 是大写英文字母</li>\n\t<li><code>n</code> 的取值范围为 <code>[0, 100]</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 622.设计循环队列",
        "hardRate": "MEDIUM",
        "passRate": "47.11%",
        "problemsUrl": "https://leetcode.cn/problems/design-circular-queue/",
        "solutionsUrl": "https://leetcode.cn/problems/design-circular-queue/solution",
        "problemsDesc": "<p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为&ldquo;环形缓冲器&rdquo;。</p>\n\n<p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p>\n\n<p>你的实现应该支持如下操作：</p>\n\n<ul>\n\t<li><code>MyCircularQueue(k)</code>: 构造器，设置队列长度为 k 。</li>\n\t<li><code>Front</code>: 从队首获取元素。如果队列为空，返回 -1 。</li>\n\t<li><code>Rear</code>: 获取队尾元素。如果队列为空，返回 -1 。</li>\n\t<li><code>enQueue(value)</code>: 向循环队列插入一个元素。如果成功插入则返回真。</li>\n\t<li><code>deQueue()</code>: 从循环队列中删除一个元素。如果成功删除则返回真。</li>\n\t<li><code>isEmpty()</code>: 检查循环队列是否为空。</li>\n\t<li><code>isFull()</code>: 检查循环队列是否已满。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3\ncircularQueue.enQueue(1); &nbsp;// 返回 true\ncircularQueue.enQueue(2); &nbsp;// 返回 true\ncircularQueue.enQueue(3); &nbsp;// 返回 true\ncircularQueue.enQueue(4); &nbsp;// 返回 false，队列已满\ncircularQueue.Rear(); &nbsp;// 返回 3\ncircularQueue.isFull(); &nbsp;// 返回 true\ncircularQueue.deQueue(); &nbsp;// 返回 true\ncircularQueue.enQueue(4); &nbsp;// 返回 true\ncircularQueue.Rear(); &nbsp;// 返回 4</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>所有的值都在 0&nbsp;至 1000 的范围内；</li>\n\t<li>操作数将在 1 至 1000 的范围内；</li>\n\t<li>请不要使用内置的队列库。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 623.在二叉树中增加一行",
        "hardRate": "MEDIUM",
        "passRate": "60.11%",
        "problemsUrl": "https://leetcode.cn/problems/add-one-row-to-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/add-one-row-to-tree/solution",
        "problemsDesc": "<p>给定一个二叉树的根&nbsp;<code>root</code>&nbsp;和两个整数 <code>val</code> 和&nbsp;<code>depth</code>&nbsp;，在给定的深度&nbsp;<code>depth</code>&nbsp;处添加一个值为 <code>val</code> 的节点行。</p>\n\n<p>注意，根节点&nbsp;<code>root</code>&nbsp;位于深度&nbsp;<code>1</code>&nbsp;。</p>\n\n<p>加法规则如下:</p>\n\n<ul>\n\t<li>给定整数&nbsp;<code>depth</code>，对于深度为&nbsp;<code>depth - 1</code> 的每个非空树节点 <code>cur</code> ，创建两个值为 <code>val</code> 的树节点作为 <code>cur</code> 的左子树根和右子树根。</li>\n\t<li><code>cur</code> 原来的左子树应该是新的左子树根的左子树。</li>\n\t<li><code>cur</code> 原来的右子树应该是新的右子树根的右子树。</li>\n\t<li>如果 <code>depth == 1 </code>意味着&nbsp;<code>depth - 1</code>&nbsp;根本没有深度，那么创建一个树节点，值 <code>val </code>作为整个原始树的新根，而原始树就是新根的左子树。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/03/15/addrow-tree.jpg\" style=\"height: 231px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入:</strong> root = [4,2,6,3,1,5], val = 1, depth = 2\n<strong>输出:</strong> [4,1,1,2,null,null,6,3,1,5]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/03/11/add2-tree.jpg\" style=\"height: 277px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入:</strong> root = [4,2,null,3,1], val = 1, depth = 3\n<strong>输出:</strong>  [4,2,null,1,1,3,null,null,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>节点数在&nbsp;<code>[1, 10<sup>4</sup>]</code>&nbsp;范围内</li>\n\t<li>树的深度在&nbsp;<code>[1, 10<sup>4</sup>]</code>范围内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= depth &lt;= the depth of tree + 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 624.数组列表中的最大距离",
        "hardRate": "MEDIUM",
        "passRate": "40.75%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-distance-in-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-distance-in-arrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 625.最小因式分解",
        "hardRate": "MEDIUM",
        "passRate": "34.57%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-factorization/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-factorization/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 626.换座位",
        "hardRate": "MEDIUM",
        "passRate": "67.97%",
        "problemsUrl": "https://leetcode.cn/problems/exchange-seats/",
        "solutionsUrl": "https://leetcode.cn/problems/exchange-seats/solution",
        "problemsDesc": "<p>表:&nbsp;<code>Seat</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\nId是该表的主键列。\n该表的每一行都表示学生的姓名和ID。\nId是一个连续的增量。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写SQL查询来交换每两个连续的学生的座位号。如果学生的数量是奇数，则最后一个学生的id不交换。</p>\n\n<p>按 <code>id</code> <strong>升序</strong> 返回结果表。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nSeat 表:\n+----+---------+\n| id | student |\n+----+---------+\n| 1  | Abbot   |\n| 2  | Doris   |\n| 3  | Emerson |\n| 4  | Green   |\n| 5  | Jeames  |\n+----+---------+\n<strong>输出:</strong> \n+----+---------+\n| id | student |\n+----+---------+\n| 1  | Doris   |\n| 2  | Abbot   |\n| 3  | Green   |\n| 4  | Emerson |\n| 5  | Jeames  |\n+----+---------+\n<strong>解释:\n</strong>请注意，如果学生人数为奇数，则不需要更换最后一名学生的座位。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 627.变更性别",
        "hardRate": "EASY",
        "passRate": "82.12%",
        "problemsUrl": "https://leetcode.cn/problems/swap-salary/",
        "solutionsUrl": "https://leetcode.cn/problems/swap-salary/solution",
        "problemsDesc": "<div class=\"original__bRMd\">\n<div>\n<p><code>Salary</code> 表：</p>\n\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| id          | int      |\n| name        | varchar  |\n| sex         | ENUM     |\n| salary      | int      |\n+-------------+----------+\nid 是这个表的主键。\nsex 这一列的值是 ENUM 类型，只能从 ('m', 'f') 中取。\n本表包含公司雇员的信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>请你编写一个 SQL 查询来交换所有的 <code>'f'</code> 和 <code>'m'</code> （即，将所有 <code>'f'</code> 变为 <code>'m'</code> ，反之亦然），仅使用 <strong>单个 update 语句</strong> ，且不产生中间临时表。</p>\n\n<p>注意，你必须仅使用一条 update 语句，且 <strong>不能</strong> 使用 select 语句。</p>\n\n<p>查询结果如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nSalary 表：\n+----+------+-----+--------+\n| id | name | sex | salary |\n+----+------+-----+--------+\n| 1  | A    | m   | 2500   |\n| 2  | B    | f   | 1500   |\n| 3  | C    | m   | 5500   |\n| 4  | D    | f   | 500    |\n+----+------+-----+--------+\n<strong>输出：</strong>\n+----+------+-----+--------+\n| id | name | sex | salary |\n+----+------+-----+--------+\n| 1  | A    | f   | 2500   |\n| 2  | B    | m   | 1500   |\n| 3  | C    | f   | 5500   |\n| 4  | D    | m   | 500    |\n+----+------+-----+--------+\n<strong>解释：</strong>\n(1, A) 和 (3, C) 从 'm' 变为 'f' 。\n(2, B) 和 (4, D) 从 'f' 变为 'm' 。</pre>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 628.三个数的最大乘积",
        "hardRate": "EASY",
        "passRate": "51.99%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-product-of-three-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-product-of-three-numbers/solution",
        "problemsDesc": "<p>给你一个整型数组 <code>nums</code> ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>24\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,-2,-3]\n<strong>输出：</strong>-6\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 <= nums.length <= 10<sup>4</sup></code></li>\n\t<li><code>-1000 <= nums[i] <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 629.K 个逆序对数组",
        "hardRate": "HARD",
        "passRate": "51.10%",
        "problemsUrl": "https://leetcode.cn/problems/k-inverse-pairs-array/",
        "solutionsUrl": "https://leetcode.cn/problems/k-inverse-pairs-array/solution",
        "problemsDesc": "<p>逆序对的定义如下：对于数组 <code>nums</code> 的第 <code>i</code> 个和第 <code>j</code> 个元素，如果满足 <code>0 &lt;= i &lt; j &lt; nums.length</code> 且&nbsp;<code>nums[i] &gt; nums[j]</code>，则其为一个逆序对；否则不是。</p>\n\n<p>给你两个整数&nbsp;<code>n</code>&nbsp;和&nbsp;<code>k</code>，找出所有包含从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;的数字，且恰好拥有&nbsp;<code>k</code>&nbsp;个 <strong>逆序对</strong> 的不同的数组的个数。由于答案可能很大，只需要返回对 <code>10<sup>9</sup>&nbsp;+ 7</code> 取余的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 0\n<strong>输出：</strong>1\n<strong>解释：</strong>\n只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>\n数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= k &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 630.课程表 III",
        "hardRate": "HARD",
        "passRate": "46.23%",
        "problemsUrl": "https://leetcode.cn/problems/course-schedule-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/course-schedule-iii/solution",
        "problemsDesc": "<p>这里有 <code>n</code> 门不同的在线课程，按从 <code>1</code> 到 <code>n</code>&nbsp;编号。给你一个数组 <code>courses</code> ，其中 <code>courses[i] = [duration<sub>i</sub>, lastDay<sub>i</sub>]</code> 表示第 <code>i</code> 门课将会 <strong>持续</strong> 上 <code>duration<sub>i</sub></code> 天课，并且必须在不晚于 <code>lastDay<sub>i</sub></code> 的时候完成。</p>\n\n<p>你的学期从第 <code>1</code> 天开始。且不能同时修读两门及两门以上的课程。</p>\n\n<p>返回你最多可以修读的课程数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>courses = [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n这里一共有 4 门课程，但是你最多可以修 3 门：\n首先，修第 1 门课，耗费 100 天，在第 100 天完成，在第 101 天开始下门课。\n第二，修第 3 门课，耗费 1000 天，在第 1100 天完成，在第 1101 天开始下门课程。\n第三，修第 2 门课，耗时 200 天，在第 1300 天完成。\n第 4 门课现在不能修，因为将会在第 3300 天完成它，这已经超出了关闭日期。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>courses = [[1,2]]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>courses = [[3,2],[4,3]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= courses.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= duration<sub>i</sub>, lastDay<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 631.设计 Excel 求和公式",
        "hardRate": "HARD",
        "passRate": "33.44%",
        "problemsUrl": "https://leetcode.cn/problems/design-excel-sum-formula/",
        "solutionsUrl": "https://leetcode.cn/problems/design-excel-sum-formula/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 632.最小区间",
        "hardRate": "HARD",
        "passRate": "60.73%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/solution",
        "problemsDesc": "<p>你有&nbsp;<code>k</code>&nbsp;个 <strong>非递减排列</strong> 的整数列表。找到一个 <strong>最小 </strong>区间，使得&nbsp;<code>k</code>&nbsp;个列表中的每个列表至少有一个数包含在其中。</p>\n\n<p>我们定义如果&nbsp;<code>b-a &lt; d-c</code>&nbsp;或者在&nbsp;<code>b-a == d-c</code>&nbsp;时&nbsp;<code>a &lt; c</code>，则区间 <code>[a,b]</code> 比 <code>[c,d]</code> 小。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]\n<strong>输出：</strong>[20,24]\n<strong>解释：</strong> \n列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。\n列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。\n列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[1,2,3],[1,2,3],[1,2,3]]\n<strong>输出：</strong>[1,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length == k</code></li>\n\t<li><code>1 &lt;= k &lt;= 3500</code></li>\n\t<li><code>1 &lt;= nums[i].length &lt;= 50</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> 按非递减顺序排列</li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 633.平方数之和",
        "hardRate": "MEDIUM",
        "passRate": "38.27%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-square-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-square-numbers/solution",
        "problemsDesc": "<p>给定一个非负整数&nbsp;<code>c</code>&nbsp;，你要判断是否存在两个整数 <code>a</code> 和 <code>b</code>，使得&nbsp;<code>a<sup>2</sup> + b<sup>2</sup> = c</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>c = 5\n<strong>输出：</strong>true\n<strong>解释：</strong>1 * 1 + 2 * 2 = 5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>c = 3\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= c &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 634.寻找数组的错位排列",
        "hardRate": "MEDIUM",
        "passRate": "47.37%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-derangement-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-derangement-of-an-array/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 635.设计日志存储系统",
        "hardRate": "MEDIUM",
        "passRate": "56.36%",
        "problemsUrl": "https://leetcode.cn/problems/design-log-storage-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-log-storage-system/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 636.函数的独占时间",
        "hardRate": "MEDIUM",
        "passRate": "66.01%",
        "problemsUrl": "https://leetcode.cn/problems/exclusive-time-of-functions/",
        "solutionsUrl": "https://leetcode.cn/problems/exclusive-time-of-functions/solution",
        "problemsDesc": "<p>有一个 <strong>单线程</strong> CPU 正在运行一个含有 <code>n</code> 道函数的程序。每道函数都有一个位于  <code>0</code> 和 <code>n-1</code> 之间的唯一标识符。</p>\n\n<p>函数调用 <strong>存储在一个 <a href=\"https://baike.baidu.com/item/%E8%B0%83%E7%94%A8%E6%A0%88/22718047?fr=aladdin\" target=\"_blank\">调用栈</a> 上</strong> ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 <strong>当前正在执行的函数</strong> 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。</p>\n\n<p>给你一个由日志组成的列表 <code>logs</code> ，其中 <code>logs[i]</code> 表示第 <code>i</code> 条日志消息，该消息是一个按 <code>\"{function_id}:{\"start\" | \"end\"}:{timestamp}\"</code> 进行格式化的字符串。例如，<code>\"0:start:3\"</code> 意味着标识符为 <code>0</code> 的函数调用在时间戳 <code>3</code> 的 <strong>起始开始执行</strong> ；而 <code>\"1:end:2\"</code> 意味着标识符为 <code>1</code> 的函数调用在时间戳 <code>2</code> 的 <strong>末尾结束执行</strong>。注意，函数可以 <strong>调用多次，可能存在递归调用 </strong>。</p>\n\n<p>函数的 <strong>独占时间</strong> 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 <code>2</code> 单位时间，另一次调用执行 <code>1</code> 单位时间，那么该函数的 <strong>独占时间</strong> 为 <code>2 + 1 = 3</code> 。</p>\n\n<p>以数组形式返回每个函数的 <strong>独占时间</strong> ，其中第 <code>i</code> 个下标对应的值表示标识符 <code>i</code> 的函数的独占时间。</p>\n \n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/04/05/diag1b.png\" style=\"width: 550px; height: 239px;\" />\n<pre>\n<strong>输入：</strong>n = 2, logs = [\"0:start:0\",\"1:start:2\",\"1:end:5\",\"0:end:6\"]\n<strong>输出：</strong>[3,4]\n<strong>解释：</strong>\n函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，于时间戳 1 的末尾结束执行。 \n函数 1 在时间戳 2 的起始开始执行，执行 4 个单位时间，于时间戳 5 的末尾结束执行。 \n函数 0 在时间戳 6 的开始恢复执行，执行 1 个单位时间。 \n所以函数 0 总共执行 2 + 1 = 3 个单位时间，函数 1 总共执行 4 个单位时间。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"0:start:6\",\"0:end:6\",\"0:end:7\"]\n<strong>输出：</strong>[8]\n<strong>解释：</strong>\n函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。\n函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。\n函数 0（初始调用）恢复执行，并立刻再次调用它自身。\n函数 0（第二次递归调用）在时间戳 6 的起始开始执行，执行 1 个单位时间。\n函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间。\n所以函数 0 总共执行 2 + 4 + 1 + 1 = 8 个单位时间。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:6\",\"1:end:6\",\"0:end:7\"]\n<strong>输出：</strong>[7,1]\n<strong>解释：</strong>\n函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。\n函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。\n函数 0（初始调用）恢复执行，并立刻调用函数 1 。\n函数 1在时间戳 6 的起始开始执行，执行 1 个单位时间，于时间戳 6 的末尾结束执行。\n函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间，于时间戳 7 的末尾结束执行。\n所以函数 0 总共执行 2 + 4 + 1 = 7 个单位时间，函数 1 总共执行 1 个单位时间。 </pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\n<strong>输出：</strong>[8,1]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, logs = [\"0:start:0\",\"0:end:0\"]\n<strong>输出：</strong>[1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>1 <= logs.length <= 500</code></li>\n\t<li><code>0 <= function_id < n</code></li>\n\t<li><code>0 <= timestamp <= 10<sup>9</sup></code></li>\n\t<li>两个开始事件不会在同一时间戳发生</li>\n\t<li>两个结束事件不会在同一时间戳发生</li>\n\t<li>每道函数都有一个对应 <code>\"start\"</code> 日志的 <code>\"end\"</code> 日志</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 637.二叉树的层平均值",
        "hardRate": "EASY",
        "passRate": "69.79%",
        "problemsUrl": "https://leetcode.cn/problems/average-of-levels-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/average-of-levels-in-binary-tree/solution",
        "problemsDesc": "<p>给定一个非空二叉树的根节点<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;, 以数组的形式返回每一层节点的平均值。与实际答案相差&nbsp;<code>10<sup>-5</sup></code> 以内的答案可以被接受。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [3,9,20,null,null,15,7]\n<strong>输出：</strong>[3.00000,14.50000,11.00000]\n<strong>解释：</strong>第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。\n因此返回 [3, 14.5, 11] 。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [3,9,20,15,7]\n<strong>输出：</strong>[3.00000,14.50000,11.00000]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li>树中节点数量在&nbsp;<code>[1, 10<sup>4</sup>]</code> 范围内</li>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= Node.val &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 638.大礼包",
        "hardRate": "MEDIUM",
        "passRate": "62.86%",
        "problemsUrl": "https://leetcode.cn/problems/shopping-offers/",
        "solutionsUrl": "https://leetcode.cn/problems/shopping-offers/solution",
        "problemsDesc": "<p>在 LeetCode 商店中， 有 <code>n</code> 件在售的物品。每件物品都有对应的价格。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。</p>\n\n<p>给你一个整数数组 <code>price</code> 表示物品价格，其中 <code>price[i]</code> 是第 <code>i</code> 件物品的价格。另有一个整数数组 <code>needs</code> 表示购物清单，其中 <code>needs[i]</code> 是需要购买第 <code>i</code> 件物品的数量。</p>\n\n<p>还有一个数组 <code>special</code> 表示大礼包，<code>special[i]</code> 的长度为 <code>n + 1</code> ，其中 <code>special[i][j]</code> 表示第 <code>i</code> 个大礼包中内含第 <code>j</code> 件物品的数量，且 <code>special[i][n]</code> （也就是数组中的最后一个整数）为第 <code>i</code> 个大礼包的价格。</p>\n\n<p>返回<strong> 确切 </strong>满足购物清单所需花费的最低价格，你可以充分利用大礼包的优惠活动。你不能购买超出购物清单指定数量的物品，即使那样会降低整体价格。任意大礼包可无限次购买。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]\n<strong>输出：</strong>14\n<strong>解释：</strong>有 A 和 B 两种物品，价格分别为 ¥2 和 ¥5 。 \n大礼包 1 ，你可以以 ¥5 的价格购买 3A 和 0B 。 \n大礼包 2 ，你可以以 ¥10 的价格购买 1A 和 2B 。 \n需要购买 3 个 A 和 2 个 B ， 所以付 ¥10 购买 1A 和 2B（大礼包 2），以及 ¥4 购买 2A 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]\n<strong>输出：</strong>11\n<strong>解释：</strong>A ，B ，C 的价格分别为 ¥2 ，¥3 ，¥4 。\n可以用 ¥4 购买 1A 和 1B ，也可以用 ¥9 购买 2A ，2B 和 1C 。 \n需要买 1A ，2B 和 1C ，所以付 ¥4 买 1A 和 1B（大礼包 1），以及 ¥3 购买 1B ， ¥4 购买 1C 。 \n不可以购买超出待购清单的物品，尽管购买大礼包 2 更加便宜。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == price.length</code></li>\n\t<li><code>n == needs.length</code></li>\n\t<li><code>1 <= n <= 6</code></li>\n\t<li><code>0 <= price[i] <= 10</code></li>\n\t<li><code>0 <= needs[i] <= 10</code></li>\n\t<li><code>1 <= special.length <= 100</code></li>\n\t<li><code>special[i].length == n + 1</code></li>\n\t<li><code>0 <= special[i][j] <= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 639.解码方法 II",
        "hardRate": "HARD",
        "passRate": "37.38%",
        "problemsUrl": "https://leetcode.cn/problems/decode-ways-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/decode-ways-ii/solution",
        "problemsDesc": "<p>一条包含字母&nbsp;<code>A-Z</code> 的消息通过以下的方式进行了 <strong>编码</strong> ：</p>\n\n<pre>\n'A' -&gt; \"1\"\n'B' -&gt; \"2\"\n...\n'Z' -&gt; \"26\"</pre>\n\n<p>要 <strong>解码</strong> 一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，<code>\"11106\"</code> 可以映射为：</p>\n\n<ul>\n\t<li><code>\"AAJF\"</code> 对应分组 <code>(1 1 10 6)</code></li>\n\t<li><code>\"KJF\"</code> 对应分组 <code>(11 10 6)</code></li>\n</ul>\n\n<p>注意，像 <code>(1 11 06)</code> 这样的分组是无效的，因为 <code>\"06\"</code> 不可以映射为 <code>'F'</code> ，因为 <code>\"6\"</code> 与 <code>\"06\"</code> 不同。</p>\n\n<p><strong>除了</strong> 上面描述的数字字母映射方案，编码消息中可能包含 <code>'*'</code> 字符，可以表示从 <code>'1'</code> 到 <code>'9'</code> 的任一数字（不包括 <code>'0'</code>）。例如，编码字符串 <code>\"1*\"</code> 可以表示 <code>\"11\"</code>、<code>\"12\"</code>、<code>\"13\"</code>、<code>\"14\"</code>、<code>\"15\"</code>、<code>\"16\"</code>、<code>\"17\"</code>、<code>\"18\"</code> 或 <code>\"19\"</code> 中的任意一条消息。对 <code>\"1*\"</code> 进行解码，相当于解码该字符串可以表示的任何编码消息。</p>\n\n<p>给你一个字符串 <code>s</code> ，由数字和 <code>'*'</code> 字符组成，返回 <strong>解码</strong> 该字符串的方法 <strong>数目</strong> 。</p>\n\n<p>由于答案数目可能非常大，返回&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;的&nbsp;<b>模</b>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"*\"\n<strong>输出：</strong>9\n<strong>解释：</strong>这一条编码消息可以表示 \"1\"、\"2\"、\"3\"、\"4\"、\"5\"、\"6\"、\"7\"、\"8\" 或 \"9\" 中的任意一条。\n可以分别解码成字符串 \"A\"、\"B\"、\"C\"、\"D\"、\"E\"、\"F\"、\"G\"、\"H\" 和 \"I\" 。\n因此，\"*\" 总共有 9 种解码方法。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1*\"\n<strong>输出：</strong>18\n<strong>解释：</strong>这一条编码消息可以表示 \"11\"、\"12\"、\"13\"、\"14\"、\"15\"、\"16\"、\"17\"、\"18\" 或 \"19\" 中的任意一条。\n每种消息都可以由 2 种方法解码（例如，\"11\" 可以解码成 \"AA\" 或 \"K\"）。\n因此，\"1*\" 共有 9 * 2 = 18 种解码方法。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"2*\"\n<strong>输出：</strong>15\n<strong>解释：</strong>这一条编码消息可以表示 \"21\"、\"22\"、\"23\"、\"24\"、\"25\"、\"26\"、\"27\"、\"28\" 或 \"29\" 中的任意一条。\n\"21\"、\"22\"、\"23\"、\"24\"、\"25\" 和 \"26\" 由 2 种解码方法，但 \"27\"、\"28\" 和 \"29\" 仅有 1 种解码方法。\n因此，\"2*\" 共有 (6 * 2) + (3 * 1) = 12 + 3 = 15 种解码方法。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 是 <code>0 - 9</code> 中的一位数字或字符 <code>'*'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 640.求解方程",
        "hardRate": "MEDIUM",
        "passRate": "44.60%",
        "problemsUrl": "https://leetcode.cn/problems/solve-the-equation/",
        "solutionsUrl": "https://leetcode.cn/problems/solve-the-equation/solution",
        "problemsDesc": "<p>求解一个给定的方程，将<code>x</code>以字符串 <code>\"x=#value\"</code>&nbsp;的形式返回。该方程仅包含 <code>'+'</code> ， <code>'-'</code> 操作，变量&nbsp;<code>x</code>&nbsp;和其对应系数。</p>\n\n<p>如果方程没有解或存在的解不为整数，请返回&nbsp;<code>\"No solution\"</code>&nbsp;。如果方程有无限解，则返回 <code>“Infinite solutions”</code> 。</p>\n\n<p>题目保证，如果方程中只有一个解，则 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">'x'</span></span></font></font> 的值是一个整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> equation = \"x+5-3+x=6+x-2\"\n<strong>输出:</strong> \"x=2\"\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> equation = \"x=x\"\n<strong>输出:</strong> \"Infinite solutions\"\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> equation = \"2x=x\"\n<strong>输出:</strong> \"x=0\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= equation.length &lt;= 1000</code></li>\n\t<li><code>equation</code>&nbsp;只有一个&nbsp;<code>'='</code>.&nbsp;</li>\n\t<li>方程由绝对值在&nbsp;<code>[0, 100]</code>&nbsp; 范围内且无任何前导零的整数和变量 <code>'x'</code>&nbsp;组成。<span style=\"display:block\"><span style=\"height:0px\"><span style=\"position:absolute\">​​​</span></span></span></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 641.设计循环双端队列",
        "hardRate": "MEDIUM",
        "passRate": "57.10%",
        "problemsUrl": "https://leetcode.cn/problems/design-circular-deque/",
        "solutionsUrl": "https://leetcode.cn/problems/design-circular-deque/solution",
        "problemsDesc": "<p>设计实现双端队列。</p>\n\n<p>实现 <code>MyCircularDeque</code> 类:</p>\n\n<ul>\n\t<li><code>MyCircularDeque(int k)</code>&nbsp;：构造函数,双端队列最大为 <code>k</code> 。</li>\n\t<li><code>boolean insertFront()</code>：将一个元素添加到双端队列头部。 如果操作成功返回 <code>true</code>&nbsp;，否则返回 <code>false</code> 。</li>\n\t<li><code>boolean insertLast()</code>&nbsp;：将一个元素添加到双端队列尾部。如果操作成功返回 <code>true</code>&nbsp;，否则返回 <code>false</code> 。</li>\n\t<li><code>boolean deleteFront()</code>&nbsp;：从双端队列头部删除一个元素。 如果操作成功返回 <code>true</code>&nbsp;，否则返回 <code>false</code> 。</li>\n\t<li><code>boolean deleteLast()</code>&nbsp;：从双端队列尾部删除一个元素。如果操作成功返回 <code>true</code>&nbsp;，否则返回 <code>false</code> 。</li>\n\t<li><code>int getFront()</code>&nbsp;)：从双端队列头部获得一个元素。如果双端队列为空，返回 <code>-1</code>&nbsp;。</li>\n\t<li><code>int getRear()</code>&nbsp;：获得双端队列的最后一个元素。&nbsp;如果双端队列为空，返回 <code>-1</code> 。</li>\n\t<li><code>boolean isEmpty()</code>&nbsp;：若双端队列为空，则返回&nbsp;<code>true</code>&nbsp;，否则返回 <code>false</code> &nbsp;。</li>\n\t<li><code>boolean isFull()</code>&nbsp;：若双端队列满了，则返回&nbsp;<code>true</code>&nbsp;，否则返回 <code>false</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\n[[3], [1], [2], [3], [4], [], [], [], [4], []]\n<strong>输出</strong>\n[null, true, true, true, false, 2, true, true, true, 4]\n\n<strong>解释</strong>\nMyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3\ncircularDeque.insertLast(1);\t\t\t        // 返回 true\ncircularDeque.insertLast(2);\t\t\t        // 返回 true\ncircularDeque.insertFront(3);\t\t\t        // 返回 true\ncircularDeque.insertFront(4);\t\t\t        // 已经满了，返回 false\ncircularDeque.getRear();  \t\t\t\t// 返回 2\ncircularDeque.isFull();\t\t\t\t        // 返回 true\ncircularDeque.deleteLast();\t\t\t        // 返回 true\ncircularDeque.insertFront(4);\t\t\t        // 返回 true\ncircularDeque.getFront();\t\t\t\t// 返回 4\n&nbsp;</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 1000</code></li>\n\t<li><code>0 &lt;= value &lt;= 1000</code></li>\n\t<li><code>insertFront</code>,&nbsp;<code>insertLast</code>,&nbsp;<code>deleteFront</code>,&nbsp;<code>deleteLast</code>,&nbsp;<code>getFront</code>,&nbsp;<code>getRear</code>,&nbsp;<code>isEmpty</code>,&nbsp;<code>isFull</code>&nbsp; 调用次数不大于&nbsp;<code>2000</code>&nbsp;次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 642.设计搜索自动补全系统",
        "hardRate": "HARD",
        "passRate": "56.09%",
        "problemsUrl": "https://leetcode.cn/problems/design-search-autocomplete-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-search-autocomplete-system/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 643.子数组最大平均数 I",
        "hardRate": "EASY",
        "passRate": "43.34%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-average-subarray-i/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-average-subarray-i/solution",
        "problemsDesc": "<p>给你一个由 <code>n</code> 个元素组成的整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>\n\n<p>请你找出平均数最大且 <strong>长度为 <code>k</code></strong> 的连续子数组，并输出该最大平均数。</p>\n\n<p>任何误差小于 <code>10<sup>-5</sup></code> 的答案都将被视为正确答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,12,-5,-6,50,3], k = 4\n<strong>输出：</strong>12.75\n<strong>解释：</strong>最大平均数 (12-5-6+50)/4 = 51/4 = 12.75\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5], k = 1\n<strong>输出：</strong>5.00000\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 644.子数组最大平均数 II",
        "hardRate": "HARD",
        "passRate": "44.39%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-average-subarray-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-average-subarray-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 645.错误的集合",
        "hardRate": "EASY",
        "passRate": "39.74%",
        "problemsUrl": "https://leetcode.cn/problems/set-mismatch/",
        "solutionsUrl": "https://leetcode.cn/problems/set-mismatch/solution",
        "problemsDesc": "<p>集合 <code>s</code> 包含从 <code>1</code> 到 <code>n</code> 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 <strong>丢失了一个数字</strong> 并且 <strong>有一个数字重复</strong> 。</p>\n\n<p>给定一个数组 <code>nums</code> 代表了集合 <code>S</code> 发生错误后的结果。</p>\n\n<p>请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2,4]\n<strong>输出：</strong>[2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= nums.length <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 646.最长数对链",
        "hardRate": "MEDIUM",
        "passRate": "62.25%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-length-of-pair-chain/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-length-of-pair-chain/solution",
        "problemsDesc": "<p>给你一个由&nbsp;<code>n</code>&nbsp;个数对组成的数对数组&nbsp;<code>pairs</code>&nbsp;，其中&nbsp;<code>pairs[i] = [left<sub>i</sub>, right<sub>i</sub>]</code>&nbsp;且&nbsp;<code>left<sub>i</sub>&nbsp;&lt; right<sub>i</sub></code><sub> 。</sub></p>\n\n<p>现在，我们定义一种 <strong>跟随</strong> 关系，当且仅当&nbsp;<code>b &lt; c</code>&nbsp;时，数对&nbsp;<code>p2 = [c, d]</code>&nbsp;才可以跟在&nbsp;<code>p1 = [a, b]</code>&nbsp;后面。我们用这种形式来构造 <strong>数对链</strong> 。</p>\n\n<p>找出并返回能够形成的 <strong>最长数对链的长度</strong> 。</p>\n\n<p>你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>pairs =&nbsp;[[1,2], [2,3], [3,4]]\n<strong>输出：</strong>2\n<strong>解释：</strong>最长的数对链是 [1,2] -&gt; [3,4] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>pairs = [[1,2],[7,8],[4,5]]\n<b>输出：</b>3\n<b>解释：</b>最长的数对链是 [1,2] -&gt; [4,5] -&gt; [7,8] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == pairs.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= left<sub>i</sub>&nbsp;&lt; right<sub>i</sub>&nbsp;&lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 647.回文子串",
        "hardRate": "MEDIUM",
        "passRate": "66.87%",
        "problemsUrl": "https://leetcode.cn/problems/palindromic-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/palindromic-substrings/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p>\n\n<p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p>\n\n<p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p>\n\n<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\"\n<strong>输出：</strong>3\n<strong>解释：</strong>三个回文子串: \"a\", \"b\", \"c\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aaa\"\n<strong>输出：</strong>6\n<strong>解释：</strong>6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\"</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 648.单词替换",
        "hardRate": "MEDIUM",
        "passRate": "63.97%",
        "problemsUrl": "https://leetcode.cn/problems/replace-words/",
        "solutionsUrl": "https://leetcode.cn/problems/replace-words/solution",
        "problemsDesc": "<p>在英语中，我们有一个叫做&nbsp;<code>词根</code>(root) 的概念，可以词根<strong>后面</strong>添加其他一些词组成另一个较长的单词——我们称这个词为&nbsp;<code>继承词</code>(successor)。例如，词根<code>an</code>，跟随着单词&nbsp;<code>other</code>(其他)，可以形成新的单词&nbsp;<code>another</code>(另一个)。</p>\n\n<p>现在，给定一个由许多<strong>词根</strong>组成的词典 <code>dictionary</code> 和一个用空格分隔单词形成的句子 <code>sentence</code>。你需要将句子中的所有<strong>继承词</strong>用<strong>词根</strong>替换掉。如果<strong>继承词</strong>有许多可以形成它的<strong>词根</strong>，则用<strong>最短</strong>的词根替换它。</p>\n\n<p>你需要输出替换之后的句子。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"\n<strong>输出：</strong>\"the cat was rat by the bat\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf absbs bbab cadsfafs\"\n<strong>输出：</strong>\"a a b c\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= dictionary.length&nbsp;&lt;= 1000</code></li>\n\t<li><code>1 &lt;= dictionary[i].length &lt;= 100</code></li>\n\t<li><code>dictionary[i]</code>&nbsp;仅由小写字母组成。</li>\n\t<li><code>1 &lt;= sentence.length &lt;= 10^6</code></li>\n\t<li><code>sentence</code>&nbsp;仅由小写字母和空格组成。</li>\n\t<li><code>sentence</code> 中单词的总量在范围 <code>[1, 1000]</code> 内。</li>\n\t<li><code>sentence</code> 中每个单词的长度在范围 <code>[1, 1000]</code> 内。</li>\n\t<li><code>sentence</code> 中单词之间由一个空格隔开。</li>\n\t<li><code>sentence</code>&nbsp;没有前导或尾随空格。</li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 649.Dota2 参议院",
        "hardRate": "MEDIUM",
        "passRate": "48.15%",
        "problemsUrl": "https://leetcode.cn/problems/dota2-senate/",
        "solutionsUrl": "https://leetcode.cn/problems/dota2-senate/solution",
        "problemsDesc": "<p>Dota2 的世界里有两个阵营：<code>Radiant</code>（天辉）和&nbsp;<code>Dire</code>（夜魇）</p>\n\n<p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的 <strong>一 </strong>项：</p>\n\n<ul>\n\t<li><strong>禁止一名参议员的权利</strong>：参议员可以让另一位参议员在这一轮和随后的几轮中丧失<strong> 所有的权利 </strong>。</li>\n\t<li><strong>宣布胜利</strong>：如果参议员发现有权利投票的参议员都是 <strong>同一个阵营的</strong> ，他可以宣布胜利并决定在游戏中的有关变化。</li>\n</ul>\n\n<p>给你一个字符串&nbsp;<code>senate</code> 代表每个参议员的阵营。字母 <code>'R'</code> 和 <code>'D'</code>分别代表了&nbsp;<code>Radiant</code>（天辉）和&nbsp;<code>Dire</code>（夜魇）。然后，如果有 <code>n</code> 个参议员，给定字符串的大小将是&nbsp;<code>n</code>。</p>\n\n<p>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</p>\n\n<p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是&nbsp;<code>\"Radiant\"</code> 或 <code>\"Dire\"</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>senate = \"RD\"\n<strong>输出：</strong>\"Radiant\"\n<strong>解释：\n</strong><code>第 1 轮时，第一个参议员来自 Radiant 阵营，他可以使用第一项权利让第二个参议员失去所有权利。\n这一轮中，第二个参议员将会被跳过，因为他的权利被禁止了。\n第 2 轮时，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人</code>。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>senate = \"RDD\"\n<strong>输出：</strong>\"Dire\"\n<strong>解释：</strong>\n第 1 轮时，第一个<code>来自 Radiant 阵营的</code>参议员可以使用第一项权利禁止第二个参议员的权利。\n<code>这一轮中，</code>第二个<code>来自 Dire 阵营的</code>参议员会将被跳过，因为他的权利被禁止了。\n<code>这一轮中，</code>第三个<code>来自 Dire 阵营的</code>参议员可以使用他的第一项权利禁止第一个参议员的权利。\n因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == senate.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>senate[i]</code> 为 <code>'R'</code> 或 <code>'D'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 650.只有两个键的键盘",
        "hardRate": "MEDIUM",
        "passRate": "57.70%",
        "problemsUrl": "https://leetcode.cn/problems/2-keys-keyboard/",
        "solutionsUrl": "https://leetcode.cn/problems/2-keys-keyboard/solution",
        "problemsDesc": "<p>最初记事本上只有一个字符 <code>'A'</code> 。你每次可以对这个记事本进行两种操作：</p>\n\n<ul>\n\t<li><code>Copy All</code>（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。</li>\n\t<li><code>Paste</code>（粘贴）：粘贴<strong> 上一次 </strong>复制的字符。</li>\n</ul>\n\n<p>给你一个数字&nbsp;<code>n</code> ，你需要使用最少的操作次数，在记事本上输出 <strong>恰好</strong>&nbsp;<code>n</code>&nbsp;个 <code>'A'</code> 。返回能够打印出&nbsp;<code>n</code>&nbsp;个 <code>'A'</code> 的最少操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>3\n<strong>输出：</strong>3\n<strong>解释：</strong>\n最初, 只有一个字符 'A'。\n第 1 步, 使用 <strong>Copy All</strong> 操作。\n第 2 步, 使用 <strong>Paste </strong>操作来获得 'AA'。\n第 3 步, 使用 <strong>Paste</strong> 操作来获得 'AAA'。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 651.4键键盘",
        "hardRate": "MEDIUM",
        "passRate": "59.73%",
        "problemsUrl": "https://leetcode.cn/problems/4-keys-keyboard/",
        "solutionsUrl": "https://leetcode.cn/problems/4-keys-keyboard/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 652.寻找重复的子树",
        "hardRate": "MEDIUM",
        "passRate": "61.32%",
        "problemsUrl": "https://leetcode.cn/problems/find-duplicate-subtrees/",
        "solutionsUrl": "https://leetcode.cn/problems/find-duplicate-subtrees/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点 <code>root</code> ，返回所有 <strong>重复的子树 </strong>。</p>\n\n<p>对于同一类的重复子树，你只需要返回其中任意 <strong>一棵 </strong>的根结点即可。</p>\n\n<p>如果两棵树具有<strong> 相同的结构</strong> 和 <strong>相同的结点值 </strong>，则认为二者是 <strong>重复 </strong>的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/16/e1.jpg\" style=\"height: 236px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,null,2,4,null,null,4]\n<strong>输出：</strong>[[2,4],[4]]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/16/e2.jpg\" style=\"height: 125px; width: 200px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [2,1,1]\n<strong>输出：</strong>[[1]]</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/16/e33.jpg\" style=\"height: 202px; width: 300px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [2,2,2,3,null,3,null]\n<strong>输出：</strong>[[2,3],[3]]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的结点数在 <code>[1, 5000]</code> 范围内。</li>\n\t<li><code>-200 &lt;= Node.val &lt;= 200</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 653.两数之和 IV - 输入二叉搜索树",
        "hardRate": "EASY",
        "passRate": "63.52%",
        "problemsUrl": "https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/",
        "solutionsUrl": "https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/solution",
        "problemsDesc": "<p>给定一个二叉搜索树 <code>root</code> 和一个目标结果 <code>k</code>，如果二叉搜索树中存在两个元素且它们的和等于给定的目标结果，则返回 <code>true</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg\" style=\"height: 229px; width: 400px;\" />\n<pre>\n<strong>输入:</strong> root = [5,3,6,2,4,null,7], k = 9\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/21/sum_tree_2.jpg\" style=\"height: 229px; width: 400px;\" />\n<pre>\n<strong>输入:</strong> root = [5,3,6,2,4,null,7], k = 28\n<strong>输出:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是&nbsp;&nbsp;<code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>题目数据保证，输入的 <code>root</code> 是一棵 <strong>有效</strong> 的二叉搜索树</li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 654.最大二叉树",
        "hardRate": "MEDIUM",
        "passRate": "82.56%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-binary-tree/solution",
        "problemsDesc": "<p>给定一个不重复的整数数组&nbsp;<code>nums</code> 。&nbsp;<strong>最大二叉树</strong>&nbsp;可以用下面的算法从&nbsp;<code>nums</code> 递归地构建:</p>\n\n<ol>\n\t<li>创建一个根节点，其值为&nbsp;<code>nums</code> 中的最大值。</li>\n\t<li>递归地在最大值&nbsp;<strong>左边</strong>&nbsp;的&nbsp;<strong>子数组前缀上</strong>&nbsp;构建左子树。</li>\n\t<li>递归地在最大值 <strong>右边</strong> 的&nbsp;<strong>子数组后缀上</strong>&nbsp;构建右子树。</li>\n</ol>\n\n<p>返回&nbsp;<em><code>nums</code> 构建的 </em><strong><em>最大二叉树</em> </strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg\" />\n<pre>\n<strong>输入：</strong>nums = [3,2,1,6,0,5]\n<strong>输出：</strong>[6,3,5,null,2,0,null,null,1]\n<strong>解释：</strong>递归调用如下所示：\n- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。\n    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。\n        - 空数组，无子节点。\n        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。\n            - 空数组，无子节点。\n            - 只有一个元素，所以子节点是一个值为 1 的节点。\n    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。\n        - 只有一个元素，所以子节点是一个值为 0 的节点。\n        - 空数组，无子节点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg\" />\n<pre>\n<strong>输入：</strong>nums = [3,2,1]\n<strong>输出：</strong>[3,null,2,null,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 655.输出二叉树",
        "hardRate": "MEDIUM",
        "passRate": "69.66%",
        "problemsUrl": "https://leetcode.cn/problems/print-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/print-binary-tree/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点 <code>root</code> ，请你构造一个下标从 <strong>0</strong> 开始、大小为 <code>m x n</code> 的字符串矩阵 <code>res</code> ，用以表示树的 <strong>格式化布局</strong> 。构造此格式化布局矩阵需要遵循以下规则：</p>\n\n<ul>\n\t<li>树的 <strong>高度</strong> 为 <code>height</code> ，矩阵的行数 <code>m</code> 应该等于 <code>height + 1</code> 。</li>\n\t<li>矩阵的列数 <code>n</code> 应该等于 <code>2<sup>height+1</sup> - 1</code> 。</li>\n\t<li><strong>根节点</strong> 需要放置在 <strong>顶行</strong> 的 <strong>正中间</strong> ，对应位置为 <code>res[0][(n-1)/2]</code> 。</li>\n\t<li>对于放置在矩阵中的每个节点，设对应位置为 <code>res[r][c]</code> ，将其左子节点放置在 <code>res[r+1][c-2<sup>height-r-1</sup>]</code> ，右子节点放置在 <code>res[r+1][c+2<sup>height-r-1</sup>]</code> 。</li>\n\t<li>继续这一过程，直到树中的所有节点都妥善放置。</li>\n\t<li>任意空单元格都应该包含空字符串 <code>\"\"</code> 。</li>\n</ul>\n\n<p>返回构造得到的矩阵<em> </em><code>res</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/print1-tree.jpg\" style=\"width: 141px; height: 181px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2]\n<strong>输出：</strong>\n[[\"\",\"1\",\"\"],\n&nbsp;[\"2\",\"\",\"\"]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/print2-tree.jpg\" style=\"width: 207px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,null,4]\n<strong>输出：</strong>\n[[\"\",\"\",\"\",\"1\",\"\",\"\",\"\"],\n&nbsp;[\"\",\"2\",\"\",\"\",\"\",\"3\",\"\"],\n&nbsp;[\"\",\"\",\"4\",\"\",\"\",\"\",\"\"]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数在范围 <code>[1, 2<sup>10</sup>]</code> 内</li>\n\t<li><code>-99 &lt;= Node.val &lt;= 99</code></li>\n\t<li>树的深度在范围 <code>[1, 10]</code> 内</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 656.金币路径",
        "hardRate": "HARD",
        "passRate": "34.23%",
        "problemsUrl": "https://leetcode.cn/problems/coin-path/",
        "solutionsUrl": "https://leetcode.cn/problems/coin-path/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 657.机器人能否返回原点",
        "hardRate": "EASY",
        "passRate": "78.97%",
        "problemsUrl": "https://leetcode.cn/problems/robot-return-to-origin/",
        "solutionsUrl": "https://leetcode.cn/problems/robot-return-to-origin/solution",
        "problemsDesc": "<p>在二维平面上，有一个机器人从原点 <code>(0, 0)</code> 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在<strong>&nbsp;<code>(0, 0)</code> 处结束</strong>。</p>\n\n<p>移动顺序由字符串&nbsp;<code>moves</code>&nbsp;表示。字符 <code>move[i]</code> 表示其第 <code>i</code> 次移动。机器人的有效动作有&nbsp;<code>R</code>（右），<code>L</code>（左），<code>U</code>（上）和 <code>D</code>（下）。</p>\n\n<p>如果机器人在完成所有动作后返回原点，则返回 <code>true</code>。否则，返回 <code>false</code>。</p>\n\n<p><strong>注意：</strong>机器人“面朝”的方向无关紧要。 <code>“R”</code> 将始终使机器人向右移动一次，<code>“L”</code> 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> moves = \"UD\"\n<strong>输出:</strong> true\n<strong>解释：</strong>机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> moves = \"LL\"\n<strong>输出:</strong> false\n<strong>解释：</strong>机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= moves.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>moves</code>&nbsp;只包含字符&nbsp;<code>'U'</code>,&nbsp;<code>'D'</code>,&nbsp;<code>'L'</code>&nbsp;和&nbsp;<code>'R'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 658.找到 K 个最接近的元素",
        "hardRate": "MEDIUM",
        "passRate": "47.91%",
        "problemsUrl": "https://leetcode.cn/problems/find-k-closest-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/find-k-closest-elements/solution",
        "problemsDesc": "<p>给定一个 <strong>排序好</strong> 的数组&nbsp;<code>arr</code> ，两个整数 <code>k</code> 和 <code>x</code> ，从数组中找到最靠近 <code>x</code>（两数之差最小）的 <code>k</code> 个数。返回的结果必须要是按升序排好的。</p>\n\n<p>整数 <code>a</code> 比整数 <code>b</code> 更接近 <code>x</code> 需要满足：</p>\n\n<ul>\n\t<li><code>|a - x| &lt; |b - x|</code> 或者</li>\n\t<li><code>|a - x| == |b - x|</code> 且 <code>a &lt; b</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,4,5], k = 4, x = 3\n<strong>输出：</strong>[1,2,3,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,4,5], k = 4, x = -1\n<strong>输出：</strong>[1,2,3,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= arr.length</code></li>\n\t<li><code>1 &lt;= arr.length&nbsp;&lt;= 10<sup>4</sup></code><meta charset=\"UTF-8\" /></li>\n\t<li><code>arr</code>&nbsp;按 <strong>升序</strong> 排列</li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= arr[i], x &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 659.分割数组为连续子序列",
        "hardRate": "MEDIUM",
        "passRate": "54.70%",
        "problemsUrl": "https://leetcode.cn/problems/split-array-into-consecutive-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/split-array-into-consecutive-subsequences/solution",
        "problemsDesc": "<p>给你一个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums</code> 。</p>\n\n<p>请你判断是否能在将 <code>nums</code> 分割成 <strong>一个或多个子序列</strong> 的同时满足下述 <strong>两个</strong> 条件：</p>\n\n<div class=\"original__bRMd\">\n<div>\n<ul>\n\t<li>每个子序列都是一个 <strong>连续递增序列</strong>（即，每个整数 <strong>恰好</strong> 比前一个整数大 <strong>1</strong> ）。</li>\n\t<li>所有子序列的长度 <strong>至少</strong> 为 <code>3</code><strong> </strong>。</li>\n</ul>\n\n<p>如果可以分割 <code>nums</code> 并满足上述条件，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,3,4,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>nums 可以分割成以下子序列：\n[<em><strong>1</strong></em>,<em><strong>2</strong></em>,<em><strong>3</strong></em>,3,4,5] --&gt; 1, 2, 3\n[1,2,3,<em><strong>3</strong></em>,<em><strong>4</strong></em>,<em><strong>5</strong></em>] --&gt; 3, 4, 5\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,3,4,4,5,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>nums 可以分割成以下子序列：\n[<em><strong>1</strong></em>,<em><strong>2</strong></em>,<em><strong>3</strong></em>,3,<em><strong>4</strong></em>,4,<em><strong>5</strong></em>,5] --&gt; 1, 2, 3, 4, 5\n[1,2,3,<em><strong>3</strong></em>,4,<em><strong>4</strong></em>,5,<em><strong>5</strong></em>] --&gt; 3, 4, 5\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4,4,5]\n<strong>输出：</strong>false\n<strong>解释：</strong>无法将 nums 分割成长度至少为 3 的连续递增子序列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>nums</code> 按非递减顺序排列</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 660.移除 9",
        "hardRate": "HARD",
        "passRate": "64.98%",
        "problemsUrl": "https://leetcode.cn/problems/remove-9/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-9/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 661.图片平滑器",
        "hardRate": "EASY",
        "passRate": "64.18%",
        "problemsUrl": "https://leetcode.cn/problems/image-smoother/",
        "solutionsUrl": "https://leetcode.cn/problems/image-smoother/solution",
        "problemsDesc": "<p><strong>图像平滑器</strong> 是大小为&nbsp;<code>3 x 3</code> 的过滤器，用于对图像的每个单元格平滑处理，平滑处理后单元格的值为该单元格的平均灰度。</p>\n\n<p>每个单元格的<strong>&nbsp; 平均灰度</strong> 定义为：该单元格自身及其周围的 8 个单元格的平均值，结果需向下取整。（即，需要计算蓝色平滑器中 9 个单元格的平均值）。</p>\n\n<p>如果一个单元格周围存在单元格缺失的情况，则计算平均灰度时不考虑缺失的单元格（即，需要计算红色平滑器中 4 个单元格的平均值）。</p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/05/03/smoother-grid.jpg\" style=\"height: 493px; width: 493px;\" /></p>\n\n<p>给你一个表示图像灰度的 <code>m x n</code> 整数矩阵 <code>img</code> ，返回对图像的每个单元格平滑处理后的图像&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/05/03/smooth-grid.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong>img = [[1,1,1],[1,0,1],[1,1,1]]\n<strong>输出:</strong>[[0, 0, 0],[0, 0, 0], [0, 0, 0]]\n<strong>解释:</strong>\n对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0\n对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0\n对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0\n</pre>\n\n<p><strong>示例 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/smooth2-grid.jpg\" />\n<pre>\n<strong>输入:</strong> img = [[100,200,100],[200,50,200],[100,200,100]]\n<strong>输出:</strong> [[137,141,137],[141,138,141],[137,141,137]]\n<strong>解释:</strong>\n对于点 (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137\n对于点 (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141\n对于点 (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>m == img.length</code></li>\n\t<li><code>n == img[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= img[i][j] &lt;= 255</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 662.二叉树最大宽度",
        "hardRate": "MEDIUM",
        "passRate": "43.65%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-width-of-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-width-of-binary-tree/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点 <code>root</code> ，返回树的 <strong>最大宽度</strong> 。</p>\n\n<p>树的 <strong>最大宽度</strong> 是所有层中最大的 <strong>宽度</strong> 。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>每一层的 <strong>宽度</strong> 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 <code>null</code> 节点，这些 <code>null</code> 节点也计入长度。</p>\n\n<p>题目数据保证答案将会在&nbsp; <strong>32 位</strong> 带符号整数范围内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/width1-tree.jpg\" style=\"width: 359px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>root = [1,3,2,5,3,null,9]\n<strong>输出：</strong>4\n<strong>解释：</strong>最大宽度出现在树的第 3 层，宽度为 4 (5,3,null,9) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/14/maximum-width-of-binary-tree-v3.jpg\" style=\"width: 442px; height: 422px;\" />\n<pre>\n<strong>输入：</strong>root = [1,3,2,5,null,null,9,6,null,7]\n<strong>输出：</strong>7\n<strong>解释：</strong>最大宽度出现在树的第 4 层，宽度为 7 (6,null,null,null,null,null,7) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/width3-tree.jpg\" style=\"width: 289px; height: 299px;\" />\n<pre>\n<strong>输入：</strong>root = [1,3,2,5]\n<strong>输出：</strong>2\n<strong>解释：</strong>最大宽度出现在树的第 2 层，宽度为 2 (3,2) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目范围是 <code>[1, 3000]</code></li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 663.均匀树划分",
        "hardRate": "MEDIUM",
        "passRate": "45.93%",
        "problemsUrl": "https://leetcode.cn/problems/equal-tree-partition/",
        "solutionsUrl": "https://leetcode.cn/problems/equal-tree-partition/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 664.奇怪的打印机",
        "hardRate": "HARD",
        "passRate": "65.32%",
        "problemsUrl": "https://leetcode.cn/problems/strange-printer/",
        "solutionsUrl": "https://leetcode.cn/problems/strange-printer/solution",
        "problemsDesc": "<p>有台奇怪的打印机有以下两个特殊要求：</p>\n\n<ul>\n\t<li>打印机每次只能打印由 <strong>同一个字符</strong> 组成的序列。</li>\n\t<li>每次可以在从起始到结束的任意位置打印新字符，并且会覆盖掉原来已有的字符。</li>\n</ul>\n\n<p>给你一个字符串 <code>s</code> ，你的任务是计算这个打印机打印它需要的最少打印次数。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aaabbb\"\n<strong>输出：</strong>2\n<strong>解释：</strong>首先打印 \"aaa\" 然后打印 \"bbb\"。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aba\"\n<strong>输出：</strong>2\n<strong>解释：</strong>首先打印 \"aaa\" 然后在第二个位置打印 \"b\" 覆盖掉原来的字符 'a'。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 665.非递减数列",
        "hardRate": "MEDIUM",
        "passRate": "27.67%",
        "problemsUrl": "https://leetcode.cn/problems/non-decreasing-array/",
        "solutionsUrl": "https://leetcode.cn/problems/non-decreasing-array/solution",
        "problemsDesc": "<p>给你一个长度为&nbsp;<code>n</code>&nbsp;的整数数组<meta charset=\"UTF-8\" />&nbsp;<code>nums</code>&nbsp;，请你判断在 <strong>最多 </strong>改变&nbsp;<code>1</code> 个元素的情况下，该数组能否变成一个非递减数列。</p>\n\n<p>我们是这样定义一个非递减数列的：&nbsp;对于数组中任意的&nbsp;<code>i</code> <code>(0 &lt;= i &lt;= n-2)</code>，总满足 <code>nums[i] &lt;= nums[i + 1]</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [4,2,3]\n<strong>输出:</strong> true\n<strong>解释:</strong> 你可以通过把第一个 4 变成 1 来使得它成为一个非递减数列。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [4,2,1]\n<strong>输出:</strong> false\n<strong>解释:</strong> 你不能在只改变一个元素的情况下将其变为非递减数列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 666.路径总和 IV",
        "hardRate": "MEDIUM",
        "passRate": "62.66%",
        "problemsUrl": "https://leetcode.cn/problems/path-sum-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/path-sum-iv/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 667.优美的排列 II",
        "hardRate": "MEDIUM",
        "passRate": "66.73%",
        "problemsUrl": "https://leetcode.cn/problems/beautiful-arrangement-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/beautiful-arrangement-ii/solution",
        "problemsDesc": "<p>给你两个整数 <code>n</code> 和 <code>k</code> ，请你构造一个答案列表 <code>answer</code> ，该列表应当包含从 <code>1</code> 到 <code>n</code> 的 <code>n</code> 个不同正整数，并同时满足下述条件：</p>\n\n<ul>\n\t<li>假设该列表是 <code>answer = [a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, ... , a<sub>n</sub>]</code> ，那么列表 <code>[|a<sub>1</sub> - a<sub>2</sub>|, |a<sub>2</sub> - a<sub>3</sub>|, |a<sub>3</sub> - a<sub>4</sub>|, ... , |a<sub>n-1</sub> - a<sub>n</sub>|]</code> 中应该有且仅有 <code>k</code> 个不同整数。</li>\n</ul>\n\n<p>返回列表 <code>answer</code> 。如果存在多种答案，只需返回其中 <strong>任意一种</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 1\n<strong>输出：</strong>[1, 2, 3]\n<strong>解释：</strong>[1, 2, 3] 包含 3 个范围在 1-3 的不同整数，并且 [1, 1] 中有且仅有 1 个不同整数：1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 2\n<strong>输出：</strong>[1, 3, 2]\n<strong>解释：</strong>[1, 3, 2] 包含 3 个范围在 1-3 的不同整数，并且 [2, 1] 中有且仅有 2 个不同整数：1 和 2\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= k < n <= 10<sup>4</sup></code></li>\n</ul>\n\n<p> </p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 668.乘法表中第k小的数",
        "hardRate": "HARD",
        "passRate": "58.53%",
        "problemsUrl": "https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/solution",
        "problemsDesc": "<p>几乎每一个人都用&nbsp;<a href=\"https://baike.baidu.com/item/%E4%B9%98%E6%B3%95%E8%A1%A8\">乘法表</a>。但是你能在乘法表中快速找到第 <code>k</code> 小的数字吗？</p>\n\n<p>乘法表是大小为 <code>m x n</code> 的一个整数矩阵，其中&nbsp;<code>mat[i][j] == i * j</code>（下标从 <strong>1</strong> 开始）。</p>\n\n<p>给你三个整数 <code>m</code>、<code>n</code> 和 <code>k</code>，请你在大小为&nbsp;<code>m x n</code> 的乘法表中，找出并返回第 <code>k</code>&nbsp;小的数字。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/02/multtable1-grid.jpg\" style=\"width: 500px; height: 254px;\" />\n<pre>\n<strong>输入：</strong>m = 3, n = 3, k = 5\n<strong>输出：</strong>3\n<strong>解释：</strong>第 5 小的数字是 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/02/multtable2-grid.jpg\" style=\"width: 493px; height: 293px;\" />\n<pre>\n<strong>输入：</strong>m = 2, n = 3, k = 6\n<strong>输出：</strong>6\n<strong>解释：</strong>第 6 小的数字是 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= m * n</code></li>\n</ul>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 669.修剪二叉搜索树",
        "hardRate": "MEDIUM",
        "passRate": "67.47%",
        "problemsUrl": "https://leetcode.cn/problems/trim-a-binary-search-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/trim-a-binary-search-tree/solution",
        "problemsDesc": "<p>给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界<code>low</code> 和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树 <strong>不应该</strong>&nbsp;改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在&nbsp;<strong>唯一的答案</strong>&nbsp;。</p>\n\n<p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg\" style=\"height: 126px; width: 450px;\" />\n<pre>\n<strong>输入：</strong>root = [1,0,2], low = 1, high = 2\n<strong>输出：</strong>[1,null,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg\" style=\"height: 277px; width: 450px;\" />\n<pre>\n<strong>输入：</strong>root = [3,0,4,null,2,null,null,1], low = 1, high = 3\n<strong>输出：</strong>[3,2,null,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数在范围 <code>[1, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>树中每个节点的值都是 <strong>唯一</strong> 的</li>\n\t<li>题目数据保证输入是一棵有效的二叉搜索树</li>\n\t<li><code>0 &lt;= low &lt;= high &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 670.最大交换",
        "hardRate": "MEDIUM",
        "passRate": "47.89%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-swap/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-swap/solution",
        "problemsDesc": "<p>给定一个非负整数，你<strong>至多</strong>可以交换一次数字中的任意两位。返回你能得到的最大值。</p>\n\n<p><strong>示例 1 :</strong></p>\n\n<pre>\n<strong>输入:</strong> 2736\n<strong>输出:</strong> 7236\n<strong>解释:</strong> 交换数字2和数字7。\n</pre>\n\n<p><strong>示例 2 :</strong></p>\n\n<pre>\n<strong>输入:</strong> 9973\n<strong>输出:</strong> 9973\n<strong>解释:</strong> 不需要交换。\n</pre>\n\n<p><strong>注意:</strong></p>\n\n<ol>\n\t<li>给定数字的范围是&nbsp;[0, 10<sup>8</sup>]</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 671.二叉树中第二小的节点",
        "hardRate": "EASY",
        "passRate": "48.00%",
        "problemsUrl": "https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/solution",
        "problemsDesc": "<p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为&nbsp;<code>2</code>&nbsp;或&nbsp;<code>0</code>。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</p>\n\n<p>更正式地说，即&nbsp;<code>root.val = min(root.left.val, root.right.val)</code> 总成立。</p>\n\n<p>给出这样的一个二叉树，你需要输出所有节点中的&nbsp;<strong>第二小的值 </strong>。</p>\n\n<p>如果第二小的值不存在的话，输出 -1 <strong>。</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/smbt1.jpg\" style=\"height: 210px; width: 300px;\" />\n<pre>\n<strong>输入：</strong>root = [2,2,5,null,null,5,7]\n<strong>输出：</strong>5\n<strong>解释：</strong>最小的值是 2 ，第二小的值是 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/smbt2.jpg\" style=\"height: 113px; width: 200px;\" />\n<pre>\n<strong>输入：</strong>root = [2,2,2]\n<strong>输出：</strong>-1\n<strong>解释：</strong>最小的值是 2, 但是不存在第二小的值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[1, 25]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>对于树中每个节点 <code>root.val == min(root.left.val, root.right.val)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 672.灯泡开关 Ⅱ",
        "hardRate": "MEDIUM",
        "passRate": "60.78%",
        "problemsUrl": "https://leetcode.cn/problems/bulb-switcher-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/bulb-switcher-ii/solution",
        "problemsDesc": "<p>房间中有 <code>n</code>&nbsp;只已经打开的灯泡，编号从 <code>1</code> 到 <code>n</code> 。墙上挂着 <strong>4 个开关</strong> 。</p>\n\n<p>这 4 个开关各自都具有不同的功能，其中：</p>\n\n<ul>\n\t<li><strong>开关 1 ：</strong>反转当前所有灯的状态（即开变为关，关变为开）</li>\n\t<li><strong>开关 2 ：</strong>反转编号为偶数的灯的状态（即 <code>0, 2, 4, ...</code>）</li>\n\t<li><strong>开关 3 ：</strong>反转编号为奇数的灯的状态（即 <code>1, 3, ...</code>）</li>\n\t<li><strong>开关 4 ：</strong>反转编号为 <code>j = 3k + 1</code> 的灯的状态，其中 <code>k = 0, 1, 2, ...</code>（即 <code>1, 4, 7, 10, ...</code>）</li>\n</ul>\n\n<p>你必须 <strong>恰好</strong> 按压开关 <code>presses</code> 次。每次按压，你都需要从 4 个开关中选出一个来执行按压操作。</p>\n\n<p>给你两个整数 <code>n</code> 和 <code>presses</code> ，执行完所有按压之后，返回 <strong>不同可能状态</strong> 的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, presses = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>状态可以是：\n- 按压开关 1 ，[关]\n- 按压开关 2 ，[开]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, presses = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>状态可以是：\n- 按压开关 1 ，[关, 关]\n- 按压开关 2 ，[开, 关]\n- 按压开关 3 ，[关, 开]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, presses = 1\n<strong>输出：</strong>4\n<strong>解释：</strong>状态可以是：\n- 按压开关 1 ，[关, 关, 关]\n- 按压开关 2 ，[关, 开, 关]\n- 按压开关 3 ，[开, 关, 开]\n- 按压开关 4 ，[关, 开, 开]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= presses &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 673.最长递增子序列的个数",
        "hardRate": "MEDIUM",
        "passRate": "44.64%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-longest-increasing-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-longest-increasing-subsequence/solution",
        "problemsDesc": "<p>给定一个未排序的整数数组<meta charset=\"UTF-8\" />&nbsp;<code>nums</code>&nbsp;，&nbsp;<em>返回最长递增子序列的个数</em>&nbsp;。</p>\n\n<p><strong>注意</strong>&nbsp;这个数列必须是 <strong>严格</strong> 递增的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> [1,3,5,4,7]\n<strong>输出:</strong> 2\n<strong>解释:</strong> 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> [2,2,2,2,2]\n<strong>输出:</strong> 5\n<strong>解释:</strong> 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2000</code></li>\n\t<li><code>-10<sup>6</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 674.最长连续递增序列",
        "hardRate": "EASY",
        "passRate": "55.63%",
        "problemsUrl": "https://leetcode.cn/problems/longest-continuous-increasing-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-continuous-increasing-subsequence/solution",
        "problemsDesc": "<p>给定一个未经排序的整数数组，找到最长且<strong> 连续递增的子序列</strong>，并返回该序列的长度。</p>\n\n<p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l < r</code>）确定，如果对于每个 <code>l <= i < r</code>，都有 <code>nums[i] < nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,5,4,7]\n<strong>输出：</strong>3\n<strong>解释：</strong>最长连续递增序列是 [1,3,5], 长度为3。\n尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,2,2,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>最长连续递增序列是 [2], 长度为1。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 675.为高尔夫比赛砍树",
        "hardRate": "HARD",
        "passRate": "52.45%",
        "problemsUrl": "https://leetcode.cn/problems/cut-off-trees-for-golf-event/",
        "solutionsUrl": "https://leetcode.cn/problems/cut-off-trees-for-golf-event/solution",
        "problemsDesc": "<p>你被请来给一个要举办高尔夫比赛的树林砍树。树林由一个 <code>m x n</code> 的矩阵表示， 在这个矩阵中：</p>\n\n<ul>\n\t<li><code>0</code> 表示障碍，无法触碰</li>\n\t<li><code>1</code> 表示地面，可以行走</li>\n\t<li><code>比 1 大的数</code> 表示有树的单元格，可以行走，数值表示树的高度</li>\n</ul>\n\n<p>每一步，你都可以向上、下、左、右四个方向之一移动一个单位，如果你站的地方有一棵树，那么你可以决定是否要砍倒它。</p>\n\n<p>你需要按照树的高度从低向高砍掉所有的树，每砍过一颗树，该单元格的值变为 <code>1</code>（即变为地面）。</p>\n\n<p>你将从 <code>(0, 0)</code> 点开始工作，返回你砍完所有树需要走的最小步数。 如果你无法砍完所有的树，返回 <code>-1</code> 。</p>\n\n<p>可以保证的是，没有两棵树的高度是相同的，并且你至少需要砍倒一棵树。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/trees1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>forest = [[1,2,3],[0,0,4],[7,6,5]]\n<strong>输出：</strong>6\n<strong>解释：</strong>沿着上面的路径，你可以用 6 步，按从最矮到最高的顺序砍掉这些树。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/trees2.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>forest = [[1,2,3],[0,0,0],[7,6,5]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>由于中间一行被障碍阻塞，无法访问最下面一行中的树。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>forest = [[2,3,4],[0,0,5],[8,7,6]]\n<strong>输出：</strong>6\n<strong>解释：</strong>可以按与示例 1 相同的路径来砍掉所有的树。\n(0,0) 位置的树，可以直接砍去，不用算步数。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == forest.length</code></li>\n\t<li><code>n == forest[i].length</code></li>\n\t<li><code>1 <= m, n <= 50</code></li>\n\t<li><code>0 <= forest[i][j] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 676.实现一个魔法字典",
        "hardRate": "MEDIUM",
        "passRate": "65.27%",
        "problemsUrl": "https://leetcode.cn/problems/implement-magic-dictionary/",
        "solutionsUrl": "https://leetcode.cn/problems/implement-magic-dictionary/solution",
        "problemsDesc": "<p>设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 <strong>互不相同</strong> 。 如果给出一个单词，请判定能否只将这个单词中<strong>一个</strong>字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。</p>\n\n<p>实现 <code>MagicDictionary</code> 类：</p>\n\n<ul>\n\t<li><code>MagicDictionary()</code> 初始化对象</li>\n\t<li><code>void buildDict(String[] dictionary)</code> 使用字符串数组 <code>dictionary</code> 设定该数据结构，<code>dictionary</code> 中的字符串互不相同</li>\n\t<li><code>bool search(String searchWord)</code> 给定一个字符串 <code>searchWord</code> ，判定能否只将字符串中<strong> 一个 </strong>字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n</ul>\n\n<p> </p>\n\n<div class=\"top-view__1vxA\">\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"]\n[[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]\n<strong>输出</strong>\n[null, null, false, true, false, false]\n\n<strong>解释</strong>\nMagicDictionary magicDictionary = new MagicDictionary();\nmagicDictionary.buildDict([\"hello\", \"leetcode\"]);\nmagicDictionary.search(\"hello\"); // 返回 False\nmagicDictionary.search(\"hhllo\"); // 将第二个 'h' 替换为 'e' 可以匹配 \"hello\" ，所以返回 True\nmagicDictionary.search(\"hell\"); // 返回 False\nmagicDictionary.search(\"leetcoded\"); // 返回 False\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= dictionary.length <= 100</code></li>\n\t<li><code>1 <= dictionary[i].length <= 100</code></li>\n\t<li><code>dictionary[i]</code> 仅由小写英文字母组成</li>\n\t<li><code>dictionary</code> 中的所有字符串 <strong>互不相同</strong></li>\n\t<li><code>1 <= searchWord.length <= 100</code></li>\n\t<li><code>searchWord</code> 仅由小写英文字母组成</li>\n\t<li><code>buildDict</code> 仅在 <code>search</code> 之前调用一次</li>\n\t<li>最多调用 <code>100</code> 次 <code>search</code></li>\n</ul>\n</div>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 677.键值映射",
        "hardRate": "MEDIUM",
        "passRate": "65.67%",
        "problemsUrl": "https://leetcode.cn/problems/map-sum-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/map-sum-pairs/solution",
        "problemsDesc": "<p>设计一个 map ，满足以下几点:</p>\n\n<ul>\n\t<li>字符串表示键，整数表示值</li>\n\t<li>返回具有前缀等于给定字符串的键的值的总和</li>\n</ul>\n\n<p>实现一个 <code>MapSum</code> 类：</p>\n\n<ul>\n\t<li><code>MapSum()</code> 初始化 <code>MapSum</code> 对象</li>\n\t<li><code>void insert(String key, int val)</code> 插入 <code>key-val</code> 键值对，字符串表示键 <code>key</code> ，整数表示值 <code>val</code> 。如果键 <code>key</code> 已经存在，那么原来的键值对&nbsp;<code>key-value</code>&nbsp;将被替代成新的键值对。</li>\n\t<li><code>int sum(string prefix)</code> 返回所有以该前缀 <code>prefix</code> 开头的键 <code>key</code> 的值的总和。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"]\n[[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]\n<strong>输出：</strong>\n[null, null, 3, null, 5]\n\n<strong>解释：</strong>\nMapSum mapSum = new MapSum();\nmapSum.insert(\"apple\", 3);  \nmapSum.sum(\"ap\");           // 返回 3 (<u>ap</u>ple = 3)\nmapSum.insert(\"app\", 2);    \nmapSum.sum(\"ap\");           // 返回 5 (<u>ap</u>ple + <u>ap</u>p = 3 + 2 = 5)\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= key.length, prefix.length &lt;= 50</code></li>\n\t<li><code>key</code> 和 <code>prefix</code> 仅由小写英文字母组成</li>\n\t<li><code>1 &lt;= val &lt;= 1000</code></li>\n\t<li>最多调用 <code>50</code> 次 <code>insert</code> 和 <code>sum</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 678.有效的括号字符串",
        "hardRate": "MEDIUM",
        "passRate": "39.25%",
        "problemsUrl": "https://leetcode.cn/problems/valid-parenthesis-string/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-parenthesis-string/solution",
        "problemsDesc": "<p>给你一个只包含三种字符的字符串，支持的字符类型分别是 <code>'('</code>、<code>')'</code> 和 <code>'*'</code>。请你检验这个字符串是否为有效字符串，如果是有效字符串返回 <code>true</code> 。</p>\n\n<p>有效字符串符合如下规则：</p>\n\n<ul>\n\t<li>任何左括号 <code>'('</code>&nbsp;必须有相应的右括号 <code>')'</code>。</li>\n\t<li>任何右括号 <code>')'</code>&nbsp;必须有相应的左括号 <code>'('</code>&nbsp;。</li>\n\t<li>左括号 <code>'('</code> 必须在对应的右括号之前 <code>')'</code>。</li>\n\t<li><code>'*'</code>&nbsp;可以被视为单个右括号 <code>')'</code>&nbsp;，或单个左括号 <code>'('</code>&nbsp;，或一个空字符串。</li>\n\t<li>一个空字符串也被视为有效字符串。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"()\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(*)\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(*))\"\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s[i]</code> 为 <code>'('</code>、<code>')'</code> 或 <code>'*'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 679.24 点游戏",
        "hardRate": "HARD",
        "passRate": "53.80%",
        "problemsUrl": "https://leetcode.cn/problems/24-game/",
        "solutionsUrl": "https://leetcode.cn/problems/24-game/solution",
        "problemsDesc": "<p>给定一个长度为4的整数数组&nbsp;<code>cards</code>&nbsp;。你有 <code>4</code> 张卡片，每张卡片上都包含一个范围在 <code>[1,9]</code> 的数字。您应该使用运算符&nbsp;<code>['+', '-', '*', '/']</code>&nbsp;和括号&nbsp;<code>'('</code>&nbsp;和&nbsp;<code>')'</code>&nbsp;将这些卡片上的数字排列成数学表达式，以获得值24。</p>\n\n<p>你须遵守以下规则:</p>\n\n<ul>\n\t<li>除法运算符 <code>'/'</code> 表示实数除法，而不是整数除法。\n\n\t<ul>\n\t\t<li>例如，&nbsp;<code>4 /(1 - 2 / 3)= 4 /(1 / 3)= 12</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n\t<li>每个运算都在两个数字之间。特别是，不能使用 <code>“-”</code> 作为一元运算符。\n\t<ul>\n\t\t<li>例如，如果 <code>cards =[1,1,1,1]</code> ，则表达式 <code>“-1 -1 -1 -1”</code> 是 <strong>不允许</strong> 的。</li>\n\t</ul>\n\t</li>\n\t<li>你不能把数字串在一起\n\t<ul>\n\t\t<li>例如，如果 <code>cards =[1,2,1,2]</code> ，则表达式 <code>“12 + 12”</code> 无效。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>如果可以得到这样的表达式，其计算结果为 <code>24</code> ，则返回 <code>true </code>，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> cards = [4, 1, 8, 7]\n<strong>输出:</strong> true\n<strong>解释:</strong> (8-4) * (7-1) = 24\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> cards = [1, 2, 1, 2]\n<strong>输出:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>cards.length == 4</code></li>\n\t<li><code>1 &lt;= cards[i] &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 680.验证回文串 II",
        "hardRate": "EASY",
        "passRate": "39.98%",
        "problemsUrl": "https://leetcode.cn/problems/valid-palindrome-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-palindrome-ii/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>，<strong>最多</strong> 可以从中删除一个字符。</p>\n\n<p>请你判断 <code>s</code> 是否能成为回文字符串：如果能，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aba\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abca\"\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以删除字符 'c' 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\"\n<strong>输出：</strong>false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 681.最近时刻",
        "hardRate": "MEDIUM",
        "passRate": "49.88%",
        "problemsUrl": "https://leetcode.cn/problems/next-closest-time/",
        "solutionsUrl": "https://leetcode.cn/problems/next-closest-time/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 682.棒球比赛",
        "hardRate": "EASY",
        "passRate": "71.28%",
        "problemsUrl": "https://leetcode.cn/problems/baseball-game/",
        "solutionsUrl": "https://leetcode.cn/problems/baseball-game/solution",
        "problemsDesc": "<p>你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。</p>\n\n<p>比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 <code>ops</code>，其中 <code>ops[i]</code> 是你需要记录的第 <code>i</code> 项操作，<code>ops</code> 遵循下述规则：</p>\n\n<ol>\n\t<li>整数 <code>x</code> - 表示本回合新获得分数 <code>x</code></li>\n\t<li><code>\"+\"</code> - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。</li>\n\t<li><code>\"D\"</code> - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。</li>\n\t<li><code>\"C\"</code> - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。</li>\n</ol>\n\n<p>请你返回记录中所有得分的总和。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]\n<strong>输出：</strong>30\n<strong>解释：</strong>\n\"5\" - 记录加 5 ，记录现在是 [5]\n\"2\" - 记录加 2 ，记录现在是 [5, 2]\n\"C\" - 使前一次得分的记录无效并将其移除，记录现在是 [5].\n\"D\" - 记录加 2 * 5 = 10 ，记录现在是 [5, 10].\n\"+\" - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15].\n所有得分的总和 5 + 10 + 15 = 30\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\n<strong>输出：</strong>27\n<strong>解释：</strong>\n\"5\" - 记录加 5 ，记录现在是 [5]\n\"-2\" - 记录加 -2 ，记录现在是 [5, -2]\n\"4\" - 记录加 4 ，记录现在是 [5, -2, 4]\n\"C\" - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2]\n\"D\" - 记录加 2 * -2 = -4 ，记录现在是 [5, -2, -4]\n\"9\" - 记录加 9 ，记录现在是 [5, -2, -4, 9]\n\"+\" - 记录加 -4 + 9 = 5 ，记录现在是 [5, -2, -4, 9, 5]\n\"+\" - 记录加 9 + 5 = 14 ，记录现在是 [5, -2, -4, 9, 5, 14]\n所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 = 27\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>ops = [\"1\"]\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= ops.length <= 1000</code></li>\n\t<li><code>ops[i]</code> 为 <code>\"C\"</code>、<code>\"D\"</code>、<code>\"+\"</code>，或者一个表示整数的字符串。整数范围是 <code>[-3 * 10<sup>4</sup>, 3 * 10<sup>4</sup>]</code></li>\n\t<li>对于 <code>\"+\"</code> 操作，题目数据保证记录此操作时前面总是存在两个有效的分数</li>\n\t<li>对于 <code>\"C\"</code> 和 <code>\"D\"</code> 操作，题目数据保证记录此操作时前面总是存在一个有效的分数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 683.K 个关闭的灯泡",
        "hardRate": "HARD",
        "passRate": "45.92%",
        "problemsUrl": "https://leetcode.cn/problems/k-empty-slots/",
        "solutionsUrl": "https://leetcode.cn/problems/k-empty-slots/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 684.冗余连接",
        "hardRate": "MEDIUM",
        "passRate": "67.42%",
        "problemsUrl": "https://leetcode.cn/problems/redundant-connection/",
        "solutionsUrl": "https://leetcode.cn/problems/redundant-connection/solution",
        "problemsDesc": "<p>树可以看成是一个连通且 <strong>无环&nbsp;</strong>的&nbsp;<strong>无向&nbsp;</strong>图。</p>\n\n<p>给定往一棵&nbsp;<code>n</code> 个节点 (节点值&nbsp;<code>1～n</code>) 的树中添加一条边后的图。添加的边的两个顶点包含在 <code>1</code> 到 <code>n</code>&nbsp;中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 <code>n</code> 的二维数组 <code>edges</code>&nbsp;，<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示图中在 <code>ai</code> 和 <code>bi</code> 之间存在一条边。</p>\n\n<p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 <code>n</code> 个节点的树。如果有多个答案，则返回数组&nbsp;<code>edges</code>&nbsp;中最后出现的那个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626676174-hOEVUL-image.png\" style=\"width: 152px; \" /></p>\n\n<pre>\n<strong>输入:</strong> edges = [[1,2], [1,3], [2,3]]\n<strong>输出:</strong> [2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626676179-kGxcmu-image.png\" style=\"width: 250px; \" /></p>\n\n<pre>\n<strong>输入:</strong> edges = [[1,2], [2,3], [3,4], [1,4], [1,5]]\n<strong>输出:</strong> [1,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>3 &lt;= n &lt;= 1000</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 &lt;= ai&nbsp;&lt; bi&nbsp;&lt;= edges.length</code></li>\n\t<li><code>ai != bi</code></li>\n\t<li><code>edges</code> 中无重复元素</li>\n\t<li>给定的图是连通的&nbsp;</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 685.冗余连接 II",
        "hardRate": "HARD",
        "passRate": "42.22%",
        "problemsUrl": "https://leetcode.cn/problems/redundant-connection-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/redundant-connection-ii/solution",
        "problemsDesc": "<p>在本问题中，有根树指满足以下条件的 <strong>有向</strong> 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。</p>\n\n<p>输入一个有向图，该图由一个有着 <code>n</code> 个节点（节点值不重复，从 <code>1</code> 到 <code>n</code>）的树及一条附加的有向边构成。附加的边包含在 <code>1</code> 到 <code>n</code> 中的两个不同顶点间，这条附加的边不属于树中已存在的边。</p>\n\n<p>结果图是一个以边组成的二维数组 <code>edges</code> 。 每个元素是一对 <code>[u<sub>i</sub>, v<sub>i</sub>]</code>，用以表示 <strong>有向 </strong>图中连接顶点 <code>u<sub>i</sub></code> 和顶点 <code>v<sub>i</sub></code> 的边，其中 <code>u<sub>i</sub></code> 是 <code>v<sub>i</sub></code> 的一个父节点。</p>\n\n<p>返回一条能删除的边，使得剩下的图是有 <code>n</code> 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/graph1.jpg\" style=\"width: 222px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>edges = [[1,2],[1,3],[2,3]]\n<strong>输出：</strong>[2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/graph2.jpg\" style=\"width: 222px; height: 382px;\" />\n<pre>\n<strong>输入：</strong>edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]\n<strong>输出：</strong>[4,1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>3 <= n <= 1000</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 <= u<sub>i</sub>, v<sub>i</sub> <= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 686.重复叠加字符串匹配",
        "hardRate": "MEDIUM",
        "passRate": "39.84%",
        "problemsUrl": "https://leetcode.cn/problems/repeated-string-match/",
        "solutionsUrl": "https://leetcode.cn/problems/repeated-string-match/solution",
        "problemsDesc": "<p>给定两个字符串&nbsp;<code>a</code> 和 <code>b</code>，寻找重复叠加字符串 <code>a</code> 的最小次数，使得字符串 <code>b</code> 成为叠加后的字符串 <code>a</code> 的子串，如果不存在则返回 <code>-1</code>。</p>\n\n<p><strong>注意：</strong>字符串 <code>&quot;abc&quot;</code>&nbsp;重复叠加 0 次是 <code>&quot;&quot;</code>，重复叠加 1 次是&nbsp;<code>&quot;abc&quot;</code>，重复叠加 2 次是&nbsp;<code>&quot;abcabc&quot;</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>a = &quot;abcd&quot;, b = &quot;cdabcdab&quot;\n<strong>输出：</strong>3\n<strong>解释：</strong>a 重复叠加三遍后为 &quot;ab<strong>cdabcdab</strong>cd&quot;, 此时 b 是其子串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>a = &quot;a&quot;, b = &quot;aa&quot;\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>a = &quot;a&quot;, b = &quot;a&quot;\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>a = &quot;abc&quot;, b = &quot;wxyz&quot;\n<strong>输出：</strong>-1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= b.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>a</code> 和 <code>b</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 687.最长同值路径",
        "hardRate": "MEDIUM",
        "passRate": "47.65%",
        "problemsUrl": "https://leetcode.cn/problems/longest-univalue-path/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-univalue-path/solution",
        "problemsDesc": "<p>给定一个二叉树的<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;，返回&nbsp;<em>最长的路径的长度</em> ，这个路径中的&nbsp;<em>每个节点具有相同值</em>&nbsp;。 这条路径可以经过也可以不经过根节点。</p>\n\n<p><strong>两个节点之间的路径长度</strong>&nbsp;由它们之间的边数表示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/ex1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,4,5,1,1,5]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/ex2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,4,5,4,4,5]\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>树的节点数的范围是<meta charset=\"UTF-8\" />&nbsp;<code>[0, 10<sup>4</sup>]</code>&nbsp;</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li>树的深度将不超过 <code>1000</code>&nbsp;</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 688.骑士在棋盘上的概率",
        "hardRate": "MEDIUM",
        "passRate": "58.15%",
        "problemsUrl": "https://leetcode.cn/problems/knight-probability-in-chessboard/",
        "solutionsUrl": "https://leetcode.cn/problems/knight-probability-in-chessboard/solution",
        "problemsDesc": "<p>在一个&nbsp;<code>n x n</code>&nbsp;的国际象棋棋盘上，一个骑士从单元格 <code>(row, column)</code>&nbsp;开始，并尝试进行 <code>k</code> 次移动。行和列是 <strong>从 0 开始</strong> 的，所以左上单元格是 <code>(0,0)</code> ，右下单元格是 <code>(n - 1, n - 1)</code> 。</p>\n\n<p>象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。</p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/knight.png\" style=\"height: 300px; width: 300px;\" /></p>\n\n<p>每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。</p>\n\n<p>骑士继续移动，直到它走了 <code>k</code> 步或离开了棋盘。</p>\n\n<p>返回 <em>骑士在棋盘停止移动后仍留在棋盘上的概率</em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 3, k = 2, row = 0, column = 0\n<strong>输出:</strong> 0.0625\n<strong>解释:</strong> 有两步(到(1,2)，(2,1))可以让骑士留在棋盘上。\n在每一个位置上，也有两种移动可以让骑士留在棋盘上。\n骑士留在棋盘上的总概率是0.0625。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 1, k = 0, row = 0, column = 0\n<strong>输出:</strong> 1.00000\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 25</code></li>\n\t<li><code>0 &lt;= k &lt;= 100</code></li>\n\t<li><code>0 &lt;= row, column &lt;= n - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 689.三个无重叠子数组的最大和",
        "hardRate": "HARD",
        "passRate": "56.18%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-of-3-non-overlapping-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-of-3-non-overlapping-subarrays/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，找出三个长度为 <code>k</code> 、互不重叠、且全部数字和（<code>3 * k</code> 项）最大的子数组，并返回这三个子数组。</p>\n\n<p>以下标的数组形式返回结果，数组中的每一项分别指示每个子数组的起始位置（下标从 <strong>0</strong> 开始）。如果有多个结果，返回字典序最小的一个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,2,6,7,5,1], k = 2\n<strong>输出：</strong>[0,3,5]\n<strong>解释：</strong>子数组 [1, 2], [2, 6], [7, 5] 对应的起始下标为 [0, 3, 5]。\n也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,2,1,2,1,2,1], k = 2\n<strong>输出：</strong>[0,2,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;&nbsp;2<sup>16</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= floor(nums.length / 3)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 690.员工的重要性",
        "hardRate": "MEDIUM",
        "passRate": "65.70%",
        "problemsUrl": "https://leetcode.cn/problems/employee-importance/",
        "solutionsUrl": "https://leetcode.cn/problems/employee-importance/solution",
        "problemsDesc": "<p>给定一个保存员工信息的数据结构，它包含了员工 <strong>唯一的 id </strong>，<strong>重要度 </strong>和 <strong>直系下属的 id </strong>。</p>\n\n<p>比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。注意虽然员工 3 也是员工 1 的一个下属，但是由于 <strong>并不是直系</strong> 下属，因此没有体现在员工 1 的数据结构中。</p>\n\n<p>现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1\n<strong>输出：</strong>11\n<strong>解释：</strong>\n员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1 的总重要度是 5 + 3 + 3 = 11 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>一个员工最多有一个<strong> 直系 </strong>领导，但是可以有多个 <strong>直系 </strong>下属</li>\n\t<li>员工数量不超过 2000 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 691.贴纸拼词",
        "hardRate": "HARD",
        "passRate": "58.81%",
        "problemsUrl": "https://leetcode.cn/problems/stickers-to-spell-word/",
        "solutionsUrl": "https://leetcode.cn/problems/stickers-to-spell-word/solution",
        "problemsDesc": "<p>我们有 <code>n</code> 种不同的贴纸。每个贴纸上都有一个小写的英文单词。</p>\n\n<p>您想要拼写出给定的字符串 <code>target</code>&nbsp;，方法是从收集的贴纸中切割单个字母并重新排列它们。如果你愿意，你可以多次使用每个贴纸，每个贴纸的数量是无限的。</p>\n\n<p>返回你需要拼出 <code>target</code>&nbsp;的最小贴纸数量。如果任务不可能，则返回 <code>-1</code> 。</p>\n\n<p><strong>注意：</strong>在所有的测试用例中，所有的单词都是从 <code>1000</code> 个最常见的美国英语单词中随机选择的，并且 <code>target</code>&nbsp;被选择为两个随机单词的连接。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong> stickers = [\"with\",\"example\",\"science\"], target = \"thehat\"\n<b>输出：</b>3\n<strong>解释：\n</strong>我们可以使用 2 个 \"with\" 贴纸，和 1 个 \"example\" 贴纸。\n把贴纸上的字母剪下来并重新排列后，就可以形成目标 “thehat“ 了。\n此外，这是形成目标字符串所需的最小贴纸数量。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<b>输入：</b>stickers = [\"notice\",\"possible\"], target = \"basicbasic\"\n<b>输出：</b>-1\n<strong>解释：</strong>我们不能通过剪切给定贴纸的字母来形成目标“basicbasic”。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>n == stickers.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>1 &lt;= stickers[i].length &lt;= 10</code></li>\n\t<li><code>1 &lt;= target.length &lt;= 15</code></li>\n\t<li><code>stickers[i]</code>&nbsp;和&nbsp;<code>target</code>&nbsp;由小写英文单词组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 692.前K个高频单词",
        "hardRate": "MEDIUM",
        "passRate": "56.23%",
        "problemsUrl": "https://leetcode.cn/problems/top-k-frequent-words/",
        "solutionsUrl": "https://leetcode.cn/problems/top-k-frequent-words/solution",
        "problemsDesc": "<p>给定一个单词列表&nbsp;<code>words</code>&nbsp;和一个整数 <code>k</code> ，返回前&nbsp;<code>k</code><em>&nbsp;</em>个出现次数最多的单词。</p>\n\n<p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， <strong>按字典顺序</strong> 排序。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> words = [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\n<strong>输出:</strong> [\"i\", \"love\"]\n<strong>解析:</strong> \"i\" 和 \"love\" 为出现次数最多的两个单词，均为2次。\n    注意，按字母顺序 \"i\" 在 \"love\" 之前。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\n<strong>输出:</strong> [\"the\", \"is\", \"sunny\", \"day\"]\n<strong>解析:</strong> \"the\", \"is\", \"sunny\" 和 \"day\" 是出现次数最多的四个单词，\n    出现次数依次为 4, 3, 2 和 1 次。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= words[i] &lt;= 10</code></li>\n\t<li><code>words[i]</code>&nbsp;由小写英文字母组成。</li>\n\t<li><code>k</code> 的取值范围是&nbsp;<code>[1, <strong>不同</strong> words[i] 的数量]</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>尝试以&nbsp;<code>O(n log k)</code> 时间复杂度和&nbsp;<code>O(n)</code> 空间复杂度解决。</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 693.交替位二进制数",
        "hardRate": "EASY",
        "passRate": "65.14%",
        "problemsUrl": "https://leetcode.cn/problems/binary-number-with-alternating-bits/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-number-with-alternating-bits/solution",
        "problemsDesc": "<p>给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>true\n<strong>解释：</strong>5 的二进制表示是：101\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 7\n<strong>输出：</strong>false\n<strong>解释：</strong>7 的二进制表示是：111.</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 11\n<strong>输出：</strong>false\n<strong>解释：</strong>11 的二进制表示是：1011.</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 694.不同岛屿的数量",
        "hardRate": "MEDIUM",
        "passRate": "57.58%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-distinct-islands/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-distinct-islands/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 695.岛屿的最大面积",
        "hardRate": "MEDIUM",
        "passRate": "68.03%",
        "problemsUrl": "https://leetcode.cn/problems/max-area-of-island/",
        "solutionsUrl": "https://leetcode.cn/problems/max-area-of-island/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> 。</p>\n\n<p><strong>岛屿</strong>&nbsp;是由一些相邻的&nbsp;<code>1</code>&nbsp;(代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在 <strong>水平或者竖直的四个方向上 </strong>相邻。你可以假设&nbsp;<code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p>\n\n<p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目。</p>\n\n<p>计算并返回 <code>grid</code> 中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg\" style=\"width: 500px; height: 310px;\" />\n<pre>\n<strong>输入：</strong>grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\n<strong>输出：</strong>6\n<strong>解释：</strong>答案不应该是 <code>11</code> ，因为岛屿只能包含水平或垂直这四个方向上的 <code>1</code> 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,0,0,0,0,0,0,0]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 696.计数二进制子串",
        "hardRate": "EASY",
        "passRate": "63.69%",
        "problemsUrl": "https://leetcode.cn/problems/count-binary-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/count-binary-substrings/solution",
        "problemsDesc": "<p>给定一个字符串&nbsp;<code>s</code>，统计并返回具有相同数量 <code>0</code> 和 <code>1</code> 的非空（连续）子字符串的数量，并且这些子字符串中的所有 <code>0</code> 和所有 <code>1</code> 都是成组连续的。</p>\n\n<p>重复出现（不同位置）的子串也要统计它们出现的次数。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"00110011\"\n<strong>输出：</strong>6\n<strong>解释：</strong>6 个子串满足具有相同数量的连续 1 和 0 ：\"0011\"、\"01\"、\"1100\"、\"10\"、\"0011\" 和 \"01\" 。\n注意，一些重复出现的子串（不同位置）要统计它们出现的次数。\n另外，\"00110011\" 不是有效的子串，因为所有的 0（还有 1 ）没有组合在一起。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"10101\"\n<strong>输出：</strong>4\n<strong>解释：</strong>有 4 个子串：\"10\"、\"01\"、\"10\"、\"01\" ，具有相同数量的连续 1 和 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 697.数组的度",
        "hardRate": "EASY",
        "passRate": "59.33%",
        "problemsUrl": "https://leetcode.cn/problems/degree-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/degree-of-an-array/solution",
        "problemsDesc": "<p>给定一个非空且只包含非负数的整数数组&nbsp;<code>nums</code>，数组的 <strong>度</strong> 的定义是指数组里任一元素出现频数的最大值。</p>\n\n<p>你的任务是在 <code>nums</code> 中找到与&nbsp;<code>nums</code>&nbsp;拥有相同大小的度的最短连续子数组，返回其长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2,3,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n输入数组的度是 2 ，因为元素 1 和 2 的出现频数最大，均为 2 。\n连续子数组里面拥有相同度的有如下所示：\n[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]\n最短连续子数组 [2, 2] 的长度为 2 ，所以返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2,3,1,4,2]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n数组的度是 3 ，因为元素 2 重复出现 3 次。\n所以 [2,2,3,1,4,2] 是最短子数组，因此返回 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length</code>&nbsp;在 <code>1</code> 到 <code>50,000</code> 范围内。</li>\n\t<li><code>nums[i]</code>&nbsp;是一个在 <code>0</code> 到 <code>49,999</code> 范围内的整数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 698.划分为k个相等的子集",
        "hardRate": "MEDIUM",
        "passRate": "42.12%",
        "problemsUrl": "https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/solution",
        "problemsDesc": "<p>给定一个整数数组&nbsp;&nbsp;<code>nums</code> 和一个正整数 <code>k</code>，找出是否有可能把这个数组分成 <code>k</code> 个非空子集，其总和都相等。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong> nums = [4, 3, 2, 3, 5, 2, 1], k = 4\n<strong>输出：</strong> True\n<strong>说明：</strong> 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,3,4], k = 3\n<strong>输出:</strong> false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= len(nums) &lt;= 16</code></li>\n\t<li><code>0 &lt; nums[i] &lt; 10000</code></li>\n\t<li>每个元素的频率在 <code>[1,4]</code> 范围内</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 699.掉落的方块",
        "hardRate": "HARD",
        "passRate": "54.82%",
        "problemsUrl": "https://leetcode.cn/problems/falling-squares/",
        "solutionsUrl": "https://leetcode.cn/problems/falling-squares/solution",
        "problemsDesc": "<p>在二维平面上的 x 轴上，放置着一些方块。</p>\n\n<p>给你一个二维整数数组 <code>positions</code> ，其中 <code>positions[i] = [left<sub>i</sub>, sideLength<sub>i</sub>]</code> 表示：第 <code>i</code> 个方块边长为 <code>sideLength<sub>i</sub></code> ，其左侧边与 x 轴上坐标点&nbsp;<code>left<sub>i</sub></code> 对齐。</p>\n\n<p>每个方块都从一个比目前所有的落地方块更高的高度掉落而下。方块沿 y 轴负方向下落，直到着陆到 <strong>另一个正方形的顶边</strong> 或者是 <strong>x 轴上</strong> 。一个方块仅仅是擦过另一个方块的左侧边或右侧边不算着陆。一旦着陆，它就会固定在原地，无法移动。</p>\n\n<p>在每个方块掉落后，你必须记录目前所有已经落稳的 <strong>方块堆叠的最高高度</strong> 。</p>\n\n<p>返回一个整数数组 <code>ans</code> ，其中 <code>ans[i]</code> 表示在第 <code>i</code> 块方块掉落后堆叠的最高高度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/28/fallingsq1-plane.jpg\" style=\"width: 500px; height: 505px;\" />\n<pre>\n<strong>输入：</strong>positions = [[1,2],[2,3],[6,1]]\n<strong>输出：</strong>[2,5,5]\n<strong>解释：</strong>\n第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 2 。\n第 2 个方块掉落后，最高的堆叠由方块 1 和 2 组成，堆叠的最高高度为 5 。\n第 3 个方块掉落后，最高的堆叠仍然由方块 1 和 2 组成，堆叠的最高高度为 5 。\n因此，返回 [2, 5, 5] 作为答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>positions = [[100,100],[200,100]]\n<strong>输出：</strong>[100,100]\n<strong>解释：</strong>\n第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 100 。\n第 2 个方块掉落后，最高的堆叠可以由方块 1 组成也可以由方块 2 组成，堆叠的最高高度为 100 。\n因此，返回 [100, 100] 作为答案。\n注意，方块 2 擦过方块 1 的右侧边，但不会算作在方块 1 上着陆。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= positions.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= left<sub>i</sub> &lt;= 10<sup>8</sup></code></li>\n\t<li><code>1 &lt;= sideLength<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 700.二叉搜索树中的搜索",
        "hardRate": "EASY",
        "passRate": "77.56%",
        "problemsUrl": "https://leetcode.cn/problems/search-in-a-binary-search-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/search-in-a-binary-search-tree/solution",
        "problemsDesc": "<p>给定二叉搜索树（BST）的根节点<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;和一个整数值<meta charset=\"UTF-8\" />&nbsp;<code>val</code>。</p>\n\n<p>你需要在 BST 中找到节点值等于&nbsp;<code>val</code>&nbsp;的节点。 返回以该节点为根的子树。 如果节点不存在，则返回<meta charset=\"UTF-8\" />&nbsp;<code>null</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg\" style=\"height: 179px; width: 250px;\" /><meta charset=\"UTF-8\" /></p>\n\n<pre>\n<b>输入：</b>root = [4,2,7,1,3], val = 2\n<b>输出：</b>[2,1,3]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg\" style=\"height: 179px; width: 250px;\" />\n<pre>\n<b>输入：</b>root = [4,2,7,1,3], val = 5\n<b>输出：</b>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>数中节点数在&nbsp;<code>[1, 5000]</code>&nbsp;范围内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>7</sup></code></li>\n\t<li><code>root</code>&nbsp;是二叉搜索树</li>\n\t<li><code>1 &lt;= val &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 701.二叉搜索树中的插入操作",
        "hardRate": "MEDIUM",
        "passRate": "70.84%",
        "problemsUrl": "https://leetcode.cn/problems/insert-into-a-binary-search-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/insert-into-a-binary-search-tree/solution",
        "problemsDesc": "<p>给定二叉搜索树（BST）的根节点<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;和要插入树中的值<meta charset=\"UTF-8\" />&nbsp;<code>value</code>&nbsp;，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p>\n\n<p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg\" />\n<pre>\n<strong>输入：</strong>root = [4,2,7,1,3], val = 5\n<strong>输出：</strong>[4,2,7,1,3,5]\n<strong>解释：</strong>另一个满足题目要求可以通过的树是：\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/bst.jpg\" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [40,20,60,10,30,50,70], val = 25\n<strong>输出：</strong>[40,20,60,10,30,50,70,null,null,25]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\n<strong>输出：</strong>[4,2,7,1,3,5]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数将在<meta charset=\"UTF-8\" />&nbsp;<code>[0,&nbsp;10<sup>4</sup>]</code>的范围内。<meta charset=\"UTF-8\" /></li>\n\t<li><code>-10<sup>8</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>8</sup></code></li>\n\t<li>所有值&nbsp;<meta charset=\"UTF-8\" /><code>Node.val</code>&nbsp;是&nbsp;<strong>独一无二</strong>&nbsp;的。</li>\n\t<li><code>-10<sup>8</sup>&nbsp;&lt;= val &lt;= 10<sup>8</sup></code></li>\n\t<li><strong>保证</strong>&nbsp;<code>val</code>&nbsp;在原始BST中不存在。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 702.搜索长度未知的有序数组",
        "hardRate": "MEDIUM",
        "passRate": "74.81%",
        "problemsUrl": "https://leetcode.cn/problems/search-in-a-sorted-array-of-unknown-size/",
        "solutionsUrl": "https://leetcode.cn/problems/search-in-a-sorted-array-of-unknown-size/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 703.数据流中的第 K 大元素",
        "hardRate": "EASY",
        "passRate": "52.53%",
        "problemsUrl": "https://leetcode.cn/problems/kth-largest-element-in-a-stream/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-largest-element-in-a-stream/solution",
        "problemsDesc": "<p>设计一个找到数据流中第 <code>k</code> 大元素的类（class）。注意是排序后的第 <code>k</code> 大元素，不是第 <code>k</code> 个不同的元素。</p>\n\n<p>请实现 <code>KthLargest</code> 类：</p>\n\n<ul>\n\t<li><code>KthLargest(int k, int[] nums)</code> 使用整数 <code>k</code> 和整数流 <code>nums</code> 初始化对象。</li>\n\t<li><code>int add(int val)</code> 将 <code>val</code> 插入数据流 <code>nums</code> 后，返回当前数据流中第 <code>k</code> 大的元素。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\n<strong>输出：</strong>\n[null, 4, 5, 5, 8, 8]\n\n<strong>解释：</strong>\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8\n</pre>\n\n<p> </p>\n<strong>提示：</strong>\n\n<ul>\n\t<li><code>1 <= k <= 10<sup>4</sup></code></li>\n\t<li><code>0 <= nums.length <= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= val <= 10<sup>4</sup></code></li>\n\t<li>最多调用 <code>add</code> 方法 <code>10<sup>4</sup></code> 次</li>\n\t<li>题目数据保证，在查找第 <code>k</code> 大元素时，数组中至少有 <code>k</code> 个元素</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 704.二分查找",
        "hardRate": "EASY",
        "passRate": "54.49%",
        "problemsUrl": "https://leetcode.cn/problems/binary-search/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-search/solution",
        "problemsDesc": "<p>给定一个&nbsp;<code>n</code>&nbsp;个元素有序的（升序）整型数组&nbsp;<code>nums</code> 和一个目标值&nbsp;<code>target</code> &nbsp;，写一个函数搜索&nbsp;<code>nums</code>&nbsp;中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p>\n\n<p><br>\n<strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> <code>nums</code> = [-1,0,3,5,9,12], <code>target</code> = 9\n<strong>输出:</strong> 4\n<strong>解释:</strong> 9 出现在 <code>nums</code> 中并且下标为 4\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> <code>nums</code> = [-1,0,3,5,9,12], <code>target</code> = 2\n<strong>输出:</strong> -1\n<strong>解释:</strong> 2 不存在 <code>nums</code> 中因此返回 -1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>你可以假设 <code>nums</code>&nbsp;中的所有元素是不重复的。</li>\n\t<li><code>n</code>&nbsp;将在&nbsp;<code>[1, 10000]</code>之间。</li>\n\t<li><code>nums</code>&nbsp;的每个元素都将在&nbsp;<code>[-9999, 9999]</code>之间。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 705.设计哈希集合",
        "hardRate": "EASY",
        "passRate": "63.33%",
        "problemsUrl": "https://leetcode.cn/problems/design-hashset/",
        "solutionsUrl": "https://leetcode.cn/problems/design-hashset/solution",
        "problemsDesc": "<p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。</p>\n\n<p>实现 <code>MyHashSet</code> 类：</p>\n\n<ul>\n\t<li><code>void add(key)</code> 向哈希集合中插入值 <code>key</code> 。</li>\n\t<li><code>bool contains(key)</code> 返回哈希集合中是否存在这个值 <code>key</code> 。</li>\n\t<li><code>void remove(key)</code> 将给定值 <code>key</code> 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</li>\n</ul>\n&nbsp;\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"]\n[[], [1], [2], [1], [3], [2], [2], [2], [2]]\n<strong>输出：</strong>\n[null, null, null, true, false, null, true, null, false]\n\n<strong>解释：</strong>\nMyHashSet myHashSet = new MyHashSet();\nmyHashSet.add(1);      // set = [1]\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(1); // 返回 True\nmyHashSet.contains(3); // 返回 False ，（未找到）\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(2); // 返回 True\nmyHashSet.remove(2);   // set = [1]\nmyHashSet.contains(2); // 返回 False ，（已移除）</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= key &lt;= 10<sup>6</sup></code></li>\n\t<li>最多调用 <code>10<sup>4</sup></code> 次 <code>add</code>、<code>remove</code> 和 <code>contains</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 706.设计哈希映射",
        "hardRate": "EASY",
        "passRate": "63.62%",
        "problemsUrl": "https://leetcode.cn/problems/design-hashmap/",
        "solutionsUrl": "https://leetcode.cn/problems/design-hashmap/solution",
        "problemsDesc": "<p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。</p>\n\n<p>实现 <code>MyHashMap</code> 类：</p>\n\n<ul>\n\t<li><code>MyHashMap()</code> 用空映射初始化对象</li>\n\t<li><code>void put(int key, int value)</code> 向 HashMap 插入一个键值对 <code>(key, value)</code> 。如果 <code>key</code> 已经存在于映射中，则更新其对应的值 <code>value</code> 。</li>\n\t<li><code>int get(int key)</code> 返回特定的 <code>key</code> 所映射的 <code>value</code> ；如果映射中不包含 <code>key</code> 的映射，返回 <code>-1</code> 。</li>\n\t<li><code>void remove(key)</code> 如果映射中存在 <code>key</code> 的映射，则移除 <code>key</code> 和它所对应的 <code>value</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>：\n[\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"]\n[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]\n<strong>输出</strong>：\n[null, null, null, 1, -1, null, 1, null, -1]\n\n<strong>解释</strong>：\nMyHashMap myHashMap = new MyHashMap();\nmyHashMap.put(1, 1); // myHashMap 现在为 [[1,1]]\nmyHashMap.put(2, 2); // myHashMap 现在为 [[1,1], [2,2]]\nmyHashMap.get(1);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,2]]\nmyHashMap.get(3);    // 返回 -1（未找到），myHashMap 现在为 [[1,1], [2,2]]\nmyHashMap.put(2, 1); // myHashMap 现在为 [[1,1], [2,1]]（更新已有的值）\nmyHashMap.get(2);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,1]]\nmyHashMap.remove(2); // 删除键为 2 的数据，myHashMap 现在为 [[1,1]]\nmyHashMap.get(2);    // 返回 -1（未找到），myHashMap 现在为 [[1,1]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= key, value &lt;= 10<sup>6</sup></code></li>\n\t<li>最多调用 <code>10<sup>4</sup></code> 次 <code>put</code>、<code>get</code> 和 <code>remove</code> 方法</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 707.设计链表",
        "hardRate": "MEDIUM",
        "passRate": "34.64%",
        "problemsUrl": "https://leetcode.cn/problems/design-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/design-linked-list/solution",
        "problemsDesc": "<p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p>\n\n<p>单链表中的节点应该具备两个属性：<code>val</code> 和 <code>next</code> 。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针/引用。</p>\n\n<p>如果是双向链表，则还需要属性&nbsp;<code>prev</code>&nbsp;以指示链表中的上一个节点。假设链表中的所有节点下标从 <strong>0</strong> 开始。</p>\n\n<p>实现 <code>MyLinkedList</code> 类：</p>\n\n<ul>\n\t<li><code>MyLinkedList()</code> 初始化 <code>MyLinkedList</code> 对象。</li>\n\t<li><code>int get(int index)</code> 获取链表中下标为 <code>index</code> 的节点的值。如果下标无效，则返回 <code>-1</code> 。</li>\n\t<li><code>void addAtHead(int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li>\n\t<li><code>void addAtTail(int val)</code> 将一个值为 <code>val</code> 的节点追加到链表中作为链表的最后一个元素。</li>\n\t<li><code>void addAtIndex(int index, int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中下标为 <code>index</code> 的节点之前。如果 <code>index</code> 等于链表的长度，那么该节点会被追加到链表的末尾。如果 <code>index</code> 比长度更大，该节点将 <strong>不会插入</strong> 到链表中。</li>\n\t<li><code>void deleteAtIndex(int index)</code> 如果下标有效，则删除链表中下标为 <code>index</code> 的节点。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"MyLinkedList\", \"addAtHead\", \"addAtTail\", \"addAtIndex\", \"get\", \"deleteAtIndex\", \"get\"]\n[[], [1], [3], [1, 2], [1], [1], [1]]\n<strong>输出</strong>\n[null, null, null, null, 2, null, 3]\n\n<strong>解释</strong>\nMyLinkedList myLinkedList = new MyLinkedList();\nmyLinkedList.addAtHead(1);\nmyLinkedList.addAtTail(3);\nmyLinkedList.addAtIndex(1, 2);    // 链表变为 1-&gt;2-&gt;3\nmyLinkedList.get(1);              // 返回 2\nmyLinkedList.deleteAtIndex(1);    // 现在，链表变为 1-&gt;3\nmyLinkedList.get(1);              // 返回 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= index, val &lt;= 1000</code></li>\n\t<li>请不要使用内置的 LinkedList 库。</li>\n\t<li>调用 <code>get</code>、<code>addAtHead</code>、<code>addAtTail</code>、<code>addAtIndex</code> 和 <code>deleteAtIndex</code> 的次数不超过 <code>2000</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 708.循环有序列表的插入",
        "hardRate": "MEDIUM",
        "passRate": "37.71%",
        "problemsUrl": "https://leetcode.cn/problems/insert-into-a-sorted-circular-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/insert-into-a-sorted-circular-linked-list/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 709.转换成小写字母",
        "hardRate": "EASY",
        "passRate": "76.83%",
        "problemsUrl": "https://leetcode.cn/problems/to-lower-case/",
        "solutionsUrl": "https://leetcode.cn/problems/to-lower-case/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"Hello\"\n<strong>输出：</strong>\"hello\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"here\"\n<strong>输出：</strong>\"here\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"LOVELY\"\n<strong>输出：</strong>\"lovely\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 100</code></li>\n\t<li><code>s</code> 由 ASCII 字符集中的可打印字符组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 710.黑名单中的随机数",
        "hardRate": "HARD",
        "passRate": "43.68%",
        "problemsUrl": "https://leetcode.cn/problems/random-pick-with-blacklist/",
        "solutionsUrl": "https://leetcode.cn/problems/random-pick-with-blacklist/solution",
        "problemsDesc": "<p>给定一个整数 <code>n</code> 和一个 <strong>无重复</strong> 黑名单整数数组&nbsp;<code>blacklist</code>&nbsp;。设计一种算法，从 <code>[0, n - 1]</code> 范围内的任意整数中选取一个&nbsp;<strong>未加入&nbsp;</strong>黑名单&nbsp;<code>blacklist</code>&nbsp;的整数。任何在上述范围内且不在黑名单&nbsp;<code>blacklist</code>&nbsp;中的整数都应该有 <strong>同等的可能性</strong> 被返回。</p>\n\n<p>优化你的算法，使它最小化调用语言 <strong>内置</strong> 随机函数的次数。</p>\n\n<p>实现&nbsp;<code>Solution</code>&nbsp;类:</p>\n\n<ul>\n\t<li><code>Solution(int n, int[] blacklist)</code>&nbsp;初始化整数 <code>n</code> 和被加入黑名单&nbsp;<code>blacklist</code>&nbsp;的整数</li>\n\t<li><code>int pick()</code>&nbsp;返回一个范围为 <code>[0, n - 1]</code> 且不在黑名单&nbsp;<code>blacklist</code> 中的随机整数</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]\n<strong>输出</strong>\n[null, 0, 4, 1, 6, 1, 0, 4]\n\n<b>解释\n</b>Solution solution = new Solution(7, [2, 3, 5]);\nsolution.pick(); // 返回0，任何[0,1,4,6]的整数都可以。注意，对于每一个pick的调用，\n                 // 0、1、4和6的返回概率必须相等(即概率为1/4)。\nsolution.pick(); // 返回 4\nsolution.pick(); // 返回 1\nsolution.pick(); // 返回 6\nsolution.pick(); // 返回 1\nsolution.pick(); // 返回 0\nsolution.pick(); // 返回 4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= blacklist.length &lt;= min(10<sup>5</sup>, n - 1)</code></li>\n\t<li><code>0 &lt;= blacklist[i] &lt; n</code></li>\n\t<li><code>blacklist</code>&nbsp;中所有值都 <strong>不同</strong></li>\n\t<li>&nbsp;<code>pick</code>&nbsp;最多被调用&nbsp;<code>2 * 10<sup>4</sup></code>&nbsp;次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 711.不同岛屿的数量 II",
        "hardRate": "HARD",
        "passRate": "56.03%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-distinct-islands-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-distinct-islands-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 712.两个字符串的最小ASCII删除和",
        "hardRate": "MEDIUM",
        "passRate": "68.90%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/solution",
        "problemsDesc": "<p>给定两个字符串<code>s1</code>&nbsp;和&nbsp;<code>s2</code>，返回 <em>使两个字符串相等所需删除字符的&nbsp;<strong>ASCII&nbsp;</strong>值的最小和&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> s1 = \"sea\", s2 = \"eat\"\n<strong>输出:</strong> 231\n<strong>解释:</strong> 在 \"sea\" 中删除 \"s\" 并将 \"s\" 的值(115)加入总和。\n在 \"eat\" 中删除 \"t\" 并将 116 加入总和。\n结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s1 = \"delete\", s2 = \"leet\"\n<strong>输出:</strong> 403\n<strong>解释:</strong> 在 \"delete\" 中删除 \"dee\" 字符串变成 \"let\"，\n将 100[d]+101[e]+101[e] 加入总和。在 \"leet\" 中删除 \"e\" 将 101[e] 加入总和。\n结束时，两个字符串都等于 \"let\"，结果即为 100+101+101+101 = 403 。\n如果改为将两个字符串转换为 \"lee\" 或 \"eet\"，我们会得到 433 或 417 的结果，比答案更大。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s1.length, s2.length &lt;= 1000</code></li>\n\t<li><code>s1</code>&nbsp;和&nbsp;<code>s2</code>&nbsp;由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 713.乘积小于 K 的子数组",
        "hardRate": "MEDIUM",
        "passRate": "49.58%",
        "problemsUrl": "https://leetcode.cn/problems/subarray-product-less-than-k/",
        "solutionsUrl": "https://leetcode.cn/problems/subarray-product-less-than-k/solution",
        "problemsDesc": "给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回子数组内所有元素的乘积严格小于<em> </em><code>k</code> 的连续子数组的数目。\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,5,2,6], k = 100\n<strong>输出：</strong>8\n<strong>解释：</strong>8 个乘积小于 100 的子数组分别为：[10]、[5]、[2],、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。\n需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3], k = 0\n<strong>输出：</strong>0</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:&nbsp;</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 714.买卖股票的最佳时机含手续费",
        "hardRate": "MEDIUM",
        "passRate": "75.25%",
        "problemsUrl": "https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/",
        "solutionsUrl": "https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution",
        "problemsDesc": "<p>给定一个整数数组&nbsp;<code>prices</code>，其中 <code>prices[i]</code>表示第&nbsp;<code>i</code>&nbsp;天的股票价格 ；整数&nbsp;<code>fee</code> 代表了交易股票的手续费用。</p>\n\n<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>\n\n<p>返回获得利润的最大值。</p>\n\n<p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [1, 3, 2, 8, 4, 9], fee = 2\n<strong>输出：</strong>8\n<strong>解释：</strong>能够达到的最大利润:  \n在此处买入&nbsp;prices[0] = 1\n在此处卖出 prices[3] = 8\n在此处买入 prices[4] = 4\n在此处卖出 prices[5] = 9\n总利润:&nbsp;((8 - 1) - 2) + ((9 - 4) - 2) = 8</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [1,3,7,5,10,3], fee = 3\n<strong>输出：</strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= prices[i] &lt; 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= fee &lt; 5 * 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 715.Range 模块",
        "hardRate": "HARD",
        "passRate": "52.90%",
        "problemsUrl": "https://leetcode.cn/problems/range-module/",
        "solutionsUrl": "https://leetcode.cn/problems/range-module/solution",
        "problemsDesc": "<p>Range模块是跟踪数字范围的模块。设计一个数据结构来跟踪表示为 <strong>半开区间</strong> 的范围并查询它们。</p>\n\n<p><strong>半开区间</strong>&nbsp;<code>[left, right)</code>&nbsp;表示所有&nbsp;<code>left &lt;= x &lt; right</code>&nbsp;的实数 <code>x</code> 。</p>\n\n<p>实现 <code>RangeModule</code> 类:</p>\n\n<ul>\n\t<li><code>RangeModule()</code>&nbsp;初始化数据结构的对象。</li>\n\t<li><code>void addRange(int left, int right)</code> 添加 <strong>半开区间</strong>&nbsp;<code>[left, right)</code>，跟踪该区间中的每个实数。添加与当前跟踪的数字部分重叠的区间时，应当添加在区间&nbsp;<code>[left, right)</code>&nbsp;中尚未跟踪的任何数字到该区间中。</li>\n\t<li><code>boolean queryRange(int left, int right)</code>&nbsp;只有在当前正在跟踪区间&nbsp;<code>[left, right)</code>&nbsp;中的每一个实数时，才返回 <code>true</code>&nbsp;，否则返回 <code>false</code> 。</li>\n\t<li><code>void removeRange(int left, int right)</code>&nbsp;停止跟踪 <strong>半开区间</strong>&nbsp;<code>[left, right)</code>&nbsp;中当前正在跟踪的每个实数。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"RangeModule\", \"addRange\", \"removeRange\", \"queryRange\", \"queryRange\", \"queryRange\"]\n[[], [10, 20], [14, 16], [10, 14], [13, 15], [16, 17]]\n<strong>输出</strong>\n[null, null, null, true, false, true]\n\n<strong>解释</strong>\nRangeModule rangeModule = new RangeModule();\nrangeModule.addRange(10, 20);\nrangeModule.removeRange(14, 16);\nrangeModule.queryRange(10, 14); 返回 true （区间 [10, 14) 中的每个数都正在被跟踪）\nrangeModule.queryRange(13, 15); 返回 false（未跟踪区间 [13, 15) 中像 14, 14.03, 14.17 这样的数字）\nrangeModule.queryRange(16, 17); 返回 true （尽管执行了删除操作，区间 [16, 17) 中的数字 16 仍然会被跟踪）\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= left &lt; right &lt;= 10<sup>9</sup></code></li>\n\t<li>在单个测试用例中，对&nbsp;<code>addRange</code>&nbsp;、&nbsp; <code>queryRange</code>&nbsp;和 <code>removeRange</code> 的调用总数不超过&nbsp;<code>10<sup>4</sup></code>&nbsp;次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 716.最大栈",
        "hardRate": "HARD",
        "passRate": "44.28%",
        "problemsUrl": "https://leetcode.cn/problems/max-stack/",
        "solutionsUrl": "https://leetcode.cn/problems/max-stack/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 717.1 比特与 2 比特字符",
        "hardRate": "EASY",
        "passRate": "55.27%",
        "problemsUrl": "https://leetcode.cn/problems/1-bit-and-2-bit-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/1-bit-and-2-bit-characters/solution",
        "problemsDesc": "<p>有两种特殊字符：</p>\n\n<ul>\n\t<li>第一种字符可以用一比特&nbsp;<code>0</code> 表示</li>\n\t<li>第二种字符可以用两比特（<code>10</code>&nbsp;或&nbsp;<code>11</code>）表示</li>\n</ul>\n\n<p>给你一个以 <code>0</code> 结尾的二进制数组&nbsp;<code>bits</code>&nbsp;，如果最后一个字符必须是一个一比特字符，则返回 <code>true</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> bits = [1, 0, 0]\n<strong>输出:</strong> true\n<strong>解释:</strong> 唯一的解码方式是将其解析为一个两比特字符和一个一比特字符。\n所以最后一个字符是一比特字符。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入：</strong>bits = [1,1,1,0]\n<strong>输出：</strong>false\n<strong>解释：</strong>唯一的解码方式是将其解析为两比特字符和两比特字符。\n所以最后一个字符不是一比特字符。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= bits.length &lt;= 1000</code></li>\n\t<li><code>bits[i]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 718.最长重复子数组",
        "hardRate": "MEDIUM",
        "passRate": "56.91%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-length-of-repeated-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-length-of-repeated-subarray/solution",
        "problemsDesc": "<p>给两个整数数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>&nbsp;，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]\n<strong>输出：</strong>3\n<strong>解释：</strong>长度最长的公共子数组是 [3,2,1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]\n<strong>输出：</strong>5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 719.找出第 K 小的数对距离",
        "hardRate": "HARD",
        "passRate": "46.68%",
        "problemsUrl": "https://leetcode.cn/problems/find-k-th-smallest-pair-distance/",
        "solutionsUrl": "https://leetcode.cn/problems/find-k-th-smallest-pair-distance/solution",
        "problemsDesc": "<p>数对 <code>(a,b)</code> 由整数 <code>a</code> 和 <code>b</code> 组成，其数对距离定义为 <code>a</code> 和 <code>b</code> 的绝对差值。</p>\n\n<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，数对由 <code>nums[i]</code> 和 <code>nums[j]</code> 组成且满足 <code>0 &lt;= i &lt; j &lt; nums.length</code> 。返回 <strong>所有数对距离中</strong> 第 <code>k</code> 小的数对距离。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,1], k = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>数对和对应的距离如下：\n(1,3) -&gt; 2\n(1,1) -&gt; 0\n(3,1) -&gt; 2\n距离第 1 小的数对是 (1,1) ，距离为 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1], k = 2\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,6,1], k = 3\n<strong>输出：</strong>5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n * (n - 1) / 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 720.词典中最长的单词",
        "hardRate": "MEDIUM",
        "passRate": "51.87%",
        "problemsUrl": "https://leetcode.cn/problems/longest-word-in-dictionary/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-word-in-dictionary/solution",
        "problemsDesc": "<p>给出一个字符串数组&nbsp;<code>words</code> 组成的一本英语词典。返回&nbsp;<code>words</code> 中最长的一个单词，该单词是由&nbsp;<code>words</code>&nbsp;词典中其他单词逐步添加一个字母组成。</p>\n\n<p>若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"w\",\"wo\",\"wor\",\"worl\", \"world\"]\n<strong>输出：</strong>\"world\"\n<strong>解释：</strong> 单词\"world\"可由\"w\", \"wo\", \"wor\", 和 \"worl\"逐步添加一个字母组成。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"a\", \"banana\", \"app\", \"appl\", \"ap\", \"apply\", \"apple\"]\n<strong>输出：</strong>\"apple\"\n<strong>解释：</strong>\"apply\" 和 \"apple\" 都能由词典中的单词组成。但是 \"apple\" 的字典序小于 \"apply\" \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li>所有输入的字符串&nbsp;<code>words[i]</code>&nbsp;都只包含小写字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 721.账户合并",
        "hardRate": "MEDIUM",
        "passRate": "48.21%",
        "problemsUrl": "https://leetcode.cn/problems/accounts-merge/",
        "solutionsUrl": "https://leetcode.cn/problems/accounts-merge/solution",
        "problemsDesc": "<p>给定一个列表 <code>accounts</code>，每个元素 <code>accounts[i]</code>&nbsp;是一个字符串列表，其中第一个元素 <code>accounts[i][0]</code>&nbsp;是&nbsp;<em>名称 (name)</em>，其余元素是 <em><strong>emails</strong> </em>表示该账户的邮箱地址。</p>\n\n<p>现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。</p>\n\n<p>合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是 <strong>按字符 ASCII 顺序排列</strong> 的邮箱地址。账户本身可以以 <strong>任意顺序</strong> 返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>accounts = [[\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"], [\"John\", \"johnnybravo@mail.com\"], [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"], [\"Mary\", \"mary@mail.com\"]]\n<b>输出：</b>[[\"John\", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  [\"John\", \"johnnybravo@mail.com\"], [\"Mary\", \"mary@mail.com\"]]\n<b>解释：</b>\n第一个和第三个 John 是同一个人，因为他们有共同的邮箱地址 \"johnsmith@mail.com\"。 \n第二个 John 和 Mary 是不同的人，因为他们的邮箱地址没有被其他帐户使用。\n可以以任何顺序返回这些列表，例如答案 [['Mary'，'mary@mail.com']，['John'，'johnnybravo@mail.com']，\n['John'，'john00@mail.com'，'john_newyork@mail.com'，'johnsmith@mail.com']] 也是正确的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]\n<strong>输出：</strong>[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= accounts.length &lt;= 1000</code></li>\n\t<li><code>2 &lt;= accounts[i].length &lt;= 10</code></li>\n\t<li><code>1 &lt;= accounts[i][j].length &lt;= 30</code></li>\n\t<li><code>accounts[i][0]</code> 由英文字母组成</li>\n\t<li><code>accounts[i][j] (for j &gt; 0)</code> 是有效的邮箱地址</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 722.删除注释",
        "hardRate": "MEDIUM",
        "passRate": "34.17%",
        "problemsUrl": "https://leetcode.cn/problems/remove-comments/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-comments/solution",
        "problemsDesc": "<p>给一个 C++ 程序，删除程序中的注释。这个程序<code>source</code>是一个数组，其中<code>source[i]</code>表示第&nbsp;<code>i</code>&nbsp;行源码。&nbsp;这表示每行源码由<font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\"> <code>'\\n'&nbsp;</code></span></span></font></font>分隔。</p>\n\n<p>在 C++ 中有两种注释风格，行内注释和块注释。</p>\n\n<ul>\n\t<li>字符串<code>//</code> 表示行注释，表示<code>//</code>和其右侧的其余字符应该被忽略。</li>\n\t<li>字符串<code>/*</code> 表示一个块注释，它表示直到下一个（非重叠）出现的<code>*/</code>之间的所有字符都应该被忽略。（阅读顺序为从左到右）非重叠是指，字符串<code>/*/</code>并没有结束块注释，因为注释的结尾与开头相重叠。</li>\n</ul>\n\n<p>第一个有效注释优先于其他注释。</p>\n\n<ul>\n\t<li>如果字符串<code>//</code>出现在块注释中会被忽略。</li>\n\t<li>同样，如果字符串<code>/*</code>出现在行或块注释中也会被忽略。</li>\n</ul>\n\n<p>如果一行在删除注释之后变为空字符串，那么<strong>不要</strong>输出该行。即，答案列表中的每个字符串都是非空的。</p>\n\n<p>样例中<strong>没有</strong>控制字符，单引号或双引号字符。</p>\n\n<ul>\n\t<li>比如，<code>source = \"string s = \"/* Not a comment. */\";\"</code> 不会出现在测试样例里。</li>\n</ul>\n\n<p>此外，没有其他内容（如定义或宏）会干扰注释。</p>\n\n<p>我们保证每一个块注释最终都会被闭合， 所以在行或块注释之外的<code>/*</code>总是开始新的注释。</p>\n\n<p>最后，隐式换行符<strong>可以</strong>通过块注释删除。 有关详细信息，请参阅下面的示例。</p>\n\n<p>从源代码中删除注释后，需要以相同的格式返回源代码。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> source = [\"/*Test program */\", \"int main()\", \"{ \", \"  // variable declaration \", \"int a, b, c;\", \"/* This is a test\", \"   multiline  \", \"   comment for \", \"   testing */\", \"a = b + c;\", \"}\"]\n<strong>输出:</strong> [\"int main()\",\"{ \",\"  \",\"int a, b, c;\",\"a = b + c;\",\"}\"]\n<strong>解释:</strong> 示例代码可以编排成这样:\n/*Test program */\nint main()\n{ \n  // variable declaration \nint a, b, c;\n/* This is a test\n   multiline  \n   comment for \n   testing */\na = b + c;\n}\n第 1 行和第 6-9 行的字符串 /* 表示块注释。第 4 行的字符串 // 表示行注释。\n编排后: \nint main()\n{ \n  \nint a, b, c;\na = b + c;\n}</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> source = [\"a/*comment\", \"line\", \"more_comment*/b\"]\n<strong>输出:</strong> [\"ab\"]\n<strong>解释:</strong> 原始的 source 字符串是 \"a/*comment<strong>\\n</strong>line<strong>\\n</strong>more_comment*/b\", 其中我们用粗体显示了换行符。删除注释后，隐含的换行符被删除，留下字符串 \"ab\" 用换行符分隔成数组时就是 [\"ab\"].\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= source.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= source[i].length &lt;= 80</code></li>\n\t<li><code>source[i]</code>&nbsp;由可打印的 <strong>ASCII</strong> 字符组成。</li>\n\t<li>每个块注释都会被闭合。</li>\n\t<li>给定的源码中不会有单引号、双引号或其他控制字符。</li>\n</ul>\n<span style=\"display:block\"><span style=\"height:0px\"><span style=\"position:absolute\"><span style=\"top:0px\"><span style=\"left:-9999px\"><span style=\"opacity:0\"><span style=\"overflow:hidden\">&nbsp;</span></span></span></span></span></span>​​​​​​</span>",
        "isPlus": false
    },
    {
        "problemsName": " 723.粉碎糖果",
        "hardRate": "MEDIUM",
        "passRate": "73.94%",
        "problemsUrl": "https://leetcode.cn/problems/candy-crush/",
        "solutionsUrl": "https://leetcode.cn/problems/candy-crush/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 724.寻找数组的中心下标",
        "hardRate": "EASY",
        "passRate": "51.59%",
        "problemsUrl": "https://leetcode.cn/problems/find-pivot-index/",
        "solutionsUrl": "https://leetcode.cn/problems/find-pivot-index/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code> ，请计算数组的 <strong>中心下标 </strong>。</p>\n\n<p>数组<strong> 中心下标</strong><strong> </strong>是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p>\n\n<p>如果中心下标位于数组最左端，那么左侧数之和视为 <code>0</code> ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p>\n\n<p>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1, 7, 3, 6, 5, 6]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n中心下标是 3 。\n左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，\n右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1, 2, 3]\n<strong>输出：</strong>-1\n<strong>解释：</strong>\n数组中不存在满足此条件的中心下标。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2, 1, -1]\n<strong>输出：</strong>0\n<strong>解释：</strong>\n中心下标是 0 。\n左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），\n右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与主站 1991 题相同：<a href=\"https://leetcode-cn.com/problems/find-the-middle-index-in-array/\" target=\"_blank\">https://leetcode-cn.com/problems/find-the-middle-index-in-array/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 725.分隔链表",
        "hardRate": "MEDIUM",
        "passRate": "60.46%",
        "problemsUrl": "https://leetcode.cn/problems/split-linked-list-in-parts/",
        "solutionsUrl": "https://leetcode.cn/problems/split-linked-list-in-parts/solution",
        "problemsDesc": "<p>给你一个头结点为 <code>head</code> 的单链表和一个整数 <code>k</code> ，请你设计一个算法将链表分隔为 <code>k</code> 个连续的部分。</p>\n\n<p>每部分的长度应该尽可能的相等：任意两部分的长度差距不能超过 1 。这可能会导致有些部分为 null 。</p>\n\n<p>这 <code>k</code> 个部分应该按照在链表中出现的顺序排列，并且排在前面的部分的长度应该大于或等于排在后面的长度。</p>\n\n<p>返回一个由上述 <code>k</code> 部分组成的数组。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/13/split1-lc.jpg\" style=\"width: 400px; height: 134px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3], k = 5\n<strong>输出：</strong>[[1],[2],[3],[],[]]\n<strong>解释：</strong>\n第一个元素 output[0] 为 output[0].val = 1 ，output[0].next = null 。\n最后一个元素 output[4] 为 null ，但它作为 ListNode 的字符串表示是 [] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/13/split2-lc.jpg\" style=\"width: 600px; height: 60px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5,6,7,8,9,10], k = 3\n<strong>输出：</strong>[[1,2,3,4],[5,6,7],[8,9,10]]\n<strong>解释：</strong>\n输入被分成了几个连续的部分，并且每部分的长度相差不超过 1 。前面部分的长度大于等于后面部分的长度。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目在范围 <code>[0, 1000]</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n\t<li><code>1 &lt;= k &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 726.原子的数量",
        "hardRate": "HARD",
        "passRate": "55.19%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-atoms/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-atoms/solution",
        "problemsDesc": "<p>给你一个字符串化学式 <code>formula</code> ，返回 <strong>每种原子的数量</strong> 。</p>\n\n<p>原子总是以一个大写字母开始，接着跟随 0 个或任意个小写字母，表示原子的名字。</p>\n\n<p>如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。</p>\n\n<ul>\n\t<li>例如，<code>\"H2O\"</code> 和 <code>\"H2O2\"</code> 是可行的，但 <code>\"H1O2\"</code> 这个表达是不可行的。</li>\n</ul>\n\n<p>两个化学式连在一起可以构成新的化学式。</p>\n\n<ul>\n\t<li>例如 <code>\"H2O2He3Mg4\"</code> 也是化学式。</li>\n</ul>\n\n<p>由括号括起的化学式并佐以数字（可选择性添加）也是化学式。</p>\n\n<ul>\n\t<li>例如 <code>\"(H2O2)\"</code> 和 <code>\"(H2O2)3\"</code> 是化学式。</li>\n</ul>\n\n<p>返回所有原子的数量，格式为：第一个（按字典序）原子的名字，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>formula = \"H2O\"\n<strong>输出：</strong>\"H2O\"\n<strong>解释：</strong>原子的数量是 {'H': 2, 'O': 1}。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>formula = \"Mg(OH)2\"\n<strong>输出：</strong>\"H2MgO2\"\n<strong>解释：</strong>原子的数量是 {'H': 2, 'Mg': 1, 'O': 2}。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>formula = \"K4(ON(SO3)2)2\"\n<strong>输出：</strong>\"K4N2O14S4\"\n<strong>解释：</strong>原子的数量是 {'K': 4, 'N': 2, 'O': 14, 'S': 4}。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= formula.length&nbsp;&lt;= 1000</code></li>\n\t<li><code>formula</code> 由英文字母、数字、<code>'('</code> 和 <code>')'</code> 组成</li>\n\t<li><code>formula</code> 总是有效的化学式</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 727.最小窗口子序列",
        "hardRate": "HARD",
        "passRate": "42.44%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-window-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-window-subsequence/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 728.自除数",
        "hardRate": "EASY",
        "passRate": "77.18%",
        "problemsUrl": "https://leetcode.cn/problems/self-dividing-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/self-dividing-numbers/solution",
        "problemsDesc": "<p><strong>自除数</strong><em>&nbsp;</em>是指可以被它包含的每一位数整除的数。</p>\n\n<ul>\n\t<li>例如，<code>128</code> 是一个 <strong>自除数</strong> ，因为&nbsp;<code>128 % 1 == 0</code>，<code>128 % 2 == 0</code>，<code>128 % 8 == 0</code>。</li>\n</ul>\n\n<p><strong>自除数</strong> 不允许包含 0 。</p>\n\n<p>给定两个整数&nbsp;<code>left</code>&nbsp;和&nbsp;<code>right</code> ，返回一个列表，<em>列表的元素是范围&nbsp;<code>[left, right]</code>&nbsp;内所有的 <strong>自除数</strong></em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>left = 1, right = 22\n<strong>输出：</strong>[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<b>输入：</b>left = 47, right = 85\n<b>输出：</b>[48,55,66,77]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= left &lt;= right &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 729.我的日程安排表 I",
        "hardRate": "MEDIUM",
        "passRate": "58.37%",
        "problemsUrl": "https://leetcode.cn/problems/my-calendar-i/",
        "solutionsUrl": "https://leetcode.cn/problems/my-calendar-i/solution",
        "problemsDesc": "<p>实现一个 <code>MyCalendar</code> 类来存放你的日程安排。如果要添加的日程安排不会造成 <strong>重复预订</strong> ，则可以存储这个新的日程安排。</p>\n\n<p>当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生 <strong>重复预订</strong> 。</p>\n\n<p>日程可以用一对整数 <code>start</code> 和 <code>end</code> 表示，这里的时间是半开区间，即 <code>[start, end)</code>, 实数&nbsp;<code>x</code> 的范围为， &nbsp;<code>start &lt;= x &lt; end</code> 。</p>\n\n<p>实现 <code>MyCalendar</code> 类：</p>\n\n<ul>\n\t<li><code>MyCalendar()</code> 初始化日历对象。</li>\n\t<li><code>boolean book(int start, int end)</code> 如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 <code>true</code> 。否则，返回 <code>false</code>&nbsp;并且不要将该日程安排添加到日历中。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"MyCalendar\", \"book\", \"book\", \"book\"]\n[[], [10, 20], [15, 25], [20, 30]]\n<strong>输出：</strong>\n[null, true, false, true]\n\n<strong>解释：</strong>\nMyCalendar myCalendar = new MyCalendar();\nmyCalendar.book(10, 20); // return True\nmyCalendar.book(15, 25); // return False ，这个日程安排不能添加到日历中，因为时间 15 已经被另一个日程安排预订了。\nmyCalendar.book(20, 30); // return True ，这个日程安排可以添加到日历中，因为第一个日程安排预订的每个时间都小于 20 ，且不包含时间 20 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= start &lt; end &lt;= 10<sup>9</sup></code></li>\n\t<li>每个测试用例，调用 <code>book</code> 方法的次数最多不超过 <code>1000</code> 次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 730.统计不同回文子序列",
        "hardRate": "HARD",
        "passRate": "64.16%",
        "problemsUrl": "https://leetcode.cn/problems/count-different-palindromic-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/count-different-palindromic-subsequences/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，返回 <code>s</code>&nbsp;中不同的非空回文子序列个数 。由于答案可能很大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p>字符串的子序列可以经由字符串删除 0 个或多个字符获得。</p>\n\n<p>如果一个序列与它反转后的序列一致，那么它是回文序列。</p>\n\n<p>如果存在某个 <code>i</code> , 满足&nbsp;<code>a<sub>i</sub>&nbsp;!= b<sub>i</sub></code><sub>&nbsp;</sub>，则两个序列&nbsp;<code>a<sub>1</sub>, a<sub>2</sub>, ...</code>&nbsp;和&nbsp;<code>b<sub>1</sub>, b<sub>2</sub>, ...</code>&nbsp;不同。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = 'bccb'\n<strong>输出：</strong>6\n<strong>解释：</strong>6 个不同的非空回文子字符序列分别为：'b', 'c', 'bb', 'cc', 'bcb', 'bccb'。\n注意：'bcb' 虽然出现两次但仅计数一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = 'abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba'\n<strong>输出：</strong>104860361\n<strong>解释：</strong>共有 3104860382 个不同的非空回文子序列，104860361 是对 10<sup>9</sup> + 7 取余后的值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i]</code>&nbsp;仅包含&nbsp;<code>'a'</code>,&nbsp;<code>'b'</code>,&nbsp;<code>'c'</code>&nbsp;或&nbsp;<code>'d'</code>&nbsp;</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 731.我的日程安排表 II",
        "hardRate": "MEDIUM",
        "passRate": "62.74%",
        "problemsUrl": "https://leetcode.cn/problems/my-calendar-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/my-calendar-ii/solution",
        "problemsDesc": "<p>实现一个 <code>MyCalendar</code> 类来存放你的日程安排。如果要添加的时间内不会导致三重预订时，则可以存储这个新的日程安排。</p>\n\n<p><code>MyCalendar</code> 有一个 <code>book(int start, int end)</code>方法。它意味着在 <code>start</code> 到 <code>end</code> 时间内增加一个日程安排，注意，这里的时间是半开区间，即 <code>[start, end)</code>, 实数&nbsp;<code>x</code> 的范围为， &nbsp;<code>start &lt;= x &lt; end</code>。</p>\n\n<p>当三个日程安排有一些时间上的交叉时（例如三个日程安排都在同一时间内），就会产生三重预订。</p>\n\n<p>每次调用 <code>MyCalendar.book</code>方法时，如果可以将日程安排成功添加到日历中而不会导致三重预订，返回 <code>true</code>。否则，返回 <code>false</code> 并且不要将该日程安排添加到日历中。</p>\n\n<p>请按照以下步骤调用<code>MyCalendar</code> 类: <code>MyCalendar cal = new MyCalendar();</code> <code>MyCalendar.book(start, end)</code></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>MyCalendar();\nMyCalendar.book(10, 20); // returns true\nMyCalendar.book(50, 60); // returns true\nMyCalendar.book(10, 40); // returns true\nMyCalendar.book(5, 15); // returns false\nMyCalendar.book(5, 10); // returns true\nMyCalendar.book(25, 55); // returns true\n<strong>解释：</strong> \n前两个日程安排可以添加至日历中。 第三个日程安排会导致双重预订，但可以添加至日历中。\n第四个日程安排活动（5,15）不能添加至日历中，因为它会导致三重预订。\n第五个日程安排（5,10）可以添加至日历中，因为它未使用已经双重预订的时间10。\n第六个日程安排（25,55）可以添加至日历中，因为时间 [25,40] 将和第三个日程安排双重预订；\n时间 [40,50] 将单独预订，时间 [50,55）将和第二个日程安排双重预订。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每个测试用例，调用&nbsp;<code>MyCalendar.book</code>&nbsp;函数最多不超过&nbsp;<code>1000</code>次。</li>\n\t<li>调用函数&nbsp;<code>MyCalendar.book(start, end)</code>时，&nbsp;<code>start</code> 和&nbsp;<code>end</code> 的取值范围为&nbsp;<code>[0, 10^9]</code>。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 732.我的日程安排表 III",
        "hardRate": "HARD",
        "passRate": "71.42%",
        "problemsUrl": "https://leetcode.cn/problems/my-calendar-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/my-calendar-iii/solution",
        "problemsDesc": "<p>当 <code>k</code> 个日程安排有一些时间上的交叉时（例如 <code>k</code> 个日程安排都在同一时间内），就会产生 <code>k</code> 次预订。</p>\n\n<p>给你一些日程安排 <code>[start, end)</code> ，请你在每个日程安排添加后，返回一个整数 <code>k</code> ，表示所有先前日程安排会产生的最大 <code>k</code> 次预订。</p>\n\n<p>实现一个 <code>MyCalendarThree</code> 类来存放你的日程安排，你可以一直添加新的日程安排。</p>\n\n<ul>\n\t<li><code>MyCalendarThree()</code> 初始化对象。</li>\n\t<li><code>int book(int start, int end)</code> 返回一个整数 <code>k</code> ，表示日历中存在的 <code>k</code> 次预订的最大值。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"]\n[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]\n<strong>输出：</strong>\n[null, 1, 1, 2, 3, 3, 3]\n\n<strong>解释：</strong>\nMyCalendarThree myCalendarThree = new MyCalendarThree();\nmyCalendarThree.book(10, 20); // 返回 1 ，第一个日程安排可以预订并且不存在相交，所以最大 k 次预订是 1 次预订。\nmyCalendarThree.book(50, 60); // 返回 1 ，第二个日程安排可以预订并且不存在相交，所以最大 k 次预订是 1 次预订。\nmyCalendarThree.book(10, 40); // 返回 2 ，第三个日程安排 [10, 40) 与第一个日程安排相交，所以最大 k 次预订是 2 次预订。\nmyCalendarThree.book(5, 15); // 返回 3 ，剩下的日程安排的最大 k 次预订是 3 次预订。\nmyCalendarThree.book(5, 10); // 返回 3\nmyCalendarThree.book(25, 55); // 返回 3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= start < end <= 10<sup>9</sup></code></li>\n\t<li>每个测试用例，调用 <code>book</code> 函数最多不超过 <code>400</code>次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 733.图像渲染",
        "hardRate": "EASY",
        "passRate": "58.66%",
        "problemsUrl": "https://leetcode.cn/problems/flood-fill/",
        "solutionsUrl": "https://leetcode.cn/problems/flood-fill/solution",
        "problemsDesc": "<p>有一幅以&nbsp;<code>m x n</code>&nbsp;的二维整数数组表示的图画&nbsp;<code>image</code>&nbsp;，其中&nbsp;<code>image[i][j]</code>&nbsp;表示该图画的像素值大小。</p>\n\n<p>你也被给予三个整数 <code>sr</code> ,&nbsp; <code>sc</code> 和 <code>newColor</code> 。你应该从像素&nbsp;<code>image[sr][sc]</code>&nbsp;开始对图像进行 上色<strong>填充</strong> 。</p>\n\n<p>为了完成<strong> 上色工作</strong> ，从初始像素开始，记录初始坐标的 <strong>上下左右四个方向上</strong> 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 <strong>四个方向上</strong> 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为&nbsp;<code>newColor</code>&nbsp;。</p>\n\n<p>最后返回 <em>经过上色渲染后的图像&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/01/flood1-grid.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> image = [[1,1,1],[1,1,0],[1,0,1]]，sr = 1, sc = 1, newColor = 2\n<strong>输出:</strong> [[2,2,2],[2,2,0],[2,0,1]]\n<strong>解析:</strong> 在图像的正中间，(坐标(sr,sc)=(1,1)),在路径上所有符合条件的像素点的颜色都被更改成2。\n注意，右下角的像素没有更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2\n<strong>输出:</strong> [[2,2,2],[2,2,2]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>m == image.length</code></li>\n\t<li><code>n == image[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>0 &lt;= image[i][j], newColor &lt; 2<sup>16</sup></code></li>\n\t<li><code>0 &lt;= sr &lt;&nbsp;m</code></li>\n\t<li><code>0 &lt;= sc &lt;&nbsp;n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 734.句子相似性",
        "hardRate": "EASY",
        "passRate": "46.67%",
        "problemsUrl": "https://leetcode.cn/problems/sentence-similarity/",
        "solutionsUrl": "https://leetcode.cn/problems/sentence-similarity/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 735.行星碰撞",
        "hardRate": "MEDIUM",
        "passRate": "42.89%",
        "problemsUrl": "https://leetcode.cn/problems/asteroid-collision/",
        "solutionsUrl": "https://leetcode.cn/problems/asteroid-collision/solution",
        "problemsDesc": "<p>给定一个整数数组 <code>asteroids</code>，表示在同一行的行星。</p>\n\n<p>对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。</p>\n\n<p>找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>asteroids = [5,10,-5]\n<strong>输出：</strong>[5,10]\n<b>解释：</b>10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>asteroids = [8,-8]\n<strong>输出：</strong>[]\n<b>解释：</b>8 和 -8 碰撞后，两者都发生爆炸。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>asteroids = [10,2,-5]\n<strong>输出：</strong>[10]\n<b>解释：</b>2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下 10 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= asteroids.length&nbsp;&lt;= 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= asteroids[i] &lt;= 1000</code></li>\n\t<li><code>asteroids[i] != 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 736.Lisp 语法解析",
        "hardRate": "HARD",
        "passRate": "66.35%",
        "problemsUrl": "https://leetcode.cn/problems/parse-lisp-expression/",
        "solutionsUrl": "https://leetcode.cn/problems/parse-lisp-expression/solution",
        "problemsDesc": "<p>给你一个类似 Lisp 语句的字符串表达式 <code>expression</code>，求出其计算结果。</p>\n\n<p>表达式语法如下所示:</p>\n\n<ul>\n\t<li>表达式可以为整数，<strong>let</strong> 表达式，<strong>add</strong> 表达式，<strong>mult</strong> 表达式，或赋值的变量。表达式的结果总是一个整数。</li>\n\t<li>(整数可以是正整数、负整数、0)</li>\n\t<li><strong>let</strong> 表达式采用&nbsp;<code>\"(let v<sub>1</sub> e<sub>1</sub> v<sub>2</sub> e<sub>2</sub> ... v<sub>n</sub> e<sub>n</sub> expr)\"</code> 的形式，其中&nbsp;<code>let</code> 总是以字符串&nbsp;<code>\"let\"</code>来表示，接下来会跟随一对或多对交替的变量和表达式，也就是说，第一个变量&nbsp;<code>v<sub>1</sub></code>被分配为表达式&nbsp;<code>e<sub>1</sub></code>&nbsp;的值，第二个变量&nbsp;<code>v<sub>2</sub></code>&nbsp;被分配为表达式&nbsp;<code>e<sub>2</sub></code>&nbsp;的值，<strong>依次类推</strong>；最终 <code>let</code> 表达式的值为&nbsp;<code>expr</code>表达式的值。</li>\n\t<li><strong>add </strong>表达式表示为&nbsp;<code>\"(add e<sub>1</sub> e<sub>2</sub>)\"</code> ，其中&nbsp;<code>add</code> 总是以字符串&nbsp;<code>\"add\"</code> 来表示，该表达式总是包含两个表达式 <code>e<sub>1</sub></code>、<code>e<sub>2</sub></code> ，最终结果是&nbsp;<code>e<sub>1</sub></code> 表达式的值与&nbsp;<code>e<sub>2</sub></code>&nbsp;表达式的值之 <strong>和 </strong>。</li>\n\t<li><strong>mult</strong> 表达式表示为&nbsp;<code>\"(mult e<sub>1</sub> e<sub>2</sub>)\"</code>&nbsp;，其中&nbsp;<code>mult</code> 总是以字符串 <code>\"mult\"</code> 表示，该表达式总是包含两个表达式 <code>e<sub>1</sub></code>、<code>e<sub>2</sub></code>，最终结果是&nbsp;<code>e<sub>1</sub></code> 表达式的值与&nbsp;<code>e<sub>2</sub></code>&nbsp;表达式的值之<strong> 积 </strong>。</li>\n\t<li>在该题目中，变量名以小写字符开始，之后跟随 0 个或多个小写字符或数字。为了方便，<code>\"add\"</code> ，<code>\"let\"</code> ，<code>\"mult\"</code> 会被定义为 \"关键字\" ，不会用作变量名。</li>\n\t<li>最后，要说一下作用域的概念。计算变量名所对应的表达式时，在计算上下文中，首先检查最内层作用域（按括号计），然后按顺序依次检查外部作用域。测试用例中每一个表达式都是合法的。有关作用域的更多详细信息，请参阅示例。</li>\n</ul>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"(let x 2 (mult x (let x 3 y 4 (add x y))))\"\n<strong>输出：</strong>14\n<strong>解释：</strong>\n计算表达式 (add x y), 在检查变量 x 值时，\n在变量的上下文中由最内层作用域依次向外检查。\n首先找到 x = 3, 所以此处的 x 值是 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"(let x 3 x 2 x)\"\n<strong>输出：</strong>2\n<strong>解释：</strong>let 语句中的赋值运算按顺序处理即可。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"(let x 1 y 2 x (add x y) (add x y))\"\n<strong>输出：</strong>5\n<strong>解释：</strong>\n第一个 (add x y) 计算结果是 3，并且将此值赋给了 x 。 \n第二个 (add x y) 计算结果是 3 + 2 = 5 。\n</pre>\n&nbsp;\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= expression.length &lt;= 2000</code></li>\n\t<li><code>exprssion</code> 中不含前导和尾随空格</li>\n\t<li><code>expressoin</code> 中的不同部分（token）之间用单个空格进行分隔</li>\n\t<li>答案和所有中间计算结果都符合 <strong>32-bit</strong> 整数范围</li>\n\t<li>测试用例中的表达式均为合法的且最终结果为整数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 737.句子相似性 II",
        "hardRate": "MEDIUM",
        "passRate": "48.39%",
        "problemsUrl": "https://leetcode.cn/problems/sentence-similarity-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/sentence-similarity-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 738.单调递增的数字",
        "hardRate": "MEDIUM",
        "passRate": "50.33%",
        "problemsUrl": "https://leetcode.cn/problems/monotone-increasing-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/monotone-increasing-digits/solution",
        "problemsDesc": "<p>当且仅当每个相邻位数上的数字&nbsp;<code>x</code>&nbsp;和&nbsp;<code>y</code>&nbsp;满足&nbsp;<code>x &lt;= y</code>&nbsp;时，我们称这个整数是<strong>单调递增</strong>的。</p>\n\n<p>给定一个整数 <code>n</code> ，返回 <em>小于或等于 <code>n</code> 的最大数字，且数字呈 <strong>单调递增</strong></em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 10\n<strong>输出:</strong> 9\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 1234\n<strong>输出:</strong> 1234\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 332\n<strong>输出:</strong> 299\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 739.每日温度",
        "hardRate": "MEDIUM",
        "passRate": "68.89%",
        "problemsUrl": "https://leetcode.cn/problems/daily-temperatures/",
        "solutionsUrl": "https://leetcode.cn/problems/daily-temperatures/solution",
        "problemsDesc": "<p>给定一个整数数组&nbsp;<code>temperatures</code>&nbsp;，表示每天的温度，返回一个数组&nbsp;<code>answer</code>&nbsp;，其中&nbsp;<code>answer[i]</code>&nbsp;是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用&nbsp;<code>0</code> 来代替。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>temperatures</code> = [73,74,75,71,69,72,76,73]\n<strong>输出:</strong>&nbsp;[1,1,4,2,1,1,0,0]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> temperatures = [30,40,50,60]\n<strong>输出:</strong>&nbsp;[1,1,1,0]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> temperatures = [30,60,90]\n<strong>输出: </strong>[1,1,0]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;temperatures.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>30 &lt;=&nbsp;temperatures[i]&nbsp;&lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 740.删除并获得点数",
        "hardRate": "MEDIUM",
        "passRate": "62.01%",
        "problemsUrl": "https://leetcode.cn/problems/delete-and-earn/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-and-earn/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，你可以对它进行一些操作。</p>\n\n<p>每次操作中，选择任意一个 <code>nums[i]</code> ，删除它并获得 <code>nums[i]</code> 的点数。之后，你必须删除 <strong>所有 </strong>等于 <code>nums[i] - 1</code> 和 <code>nums[i] + 1</code> 的元素。</p>\n\n<p>开始你拥有 <code>0</code> 个点数。返回你能通过这些操作获得的最大点数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,2]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n删除 4 获得 4 个点数，因此 3 也被删除。\n之后，删除 2 获得 2 个点数。总共获得 6 个点数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,3,3,3,4]\n<strong>输出：</strong>9\n<strong>解释：</strong>\n删除 3 获得 3 个点数，接着要删除两个 2 和 4 。\n之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。\n总共获得 9 个点数。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 741.摘樱桃",
        "hardRate": "HARD",
        "passRate": "50.52%",
        "problemsUrl": "https://leetcode.cn/problems/cherry-pickup/",
        "solutionsUrl": "https://leetcode.cn/problems/cherry-pickup/solution",
        "problemsDesc": "<p>给你一个 <code>n x n</code> 的网格 <code>grid</code> ，代表一块樱桃地，每个格子由以下三种数字的一种来表示：</p>\n\n<ul>\n\t<li><code>0</code> 表示这个格子是空的，所以你可以穿过它。</li>\n\t<li><code>1</code> 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。</li>\n\t<li><code>-1</code> 表示这个格子里有荆棘，挡着你的路。</li>\n</ul>\n\n<p>请你统计并返回：在遵守下列规则的情况下，能摘到的最多樱桃数：</p>\n\n<ul>\n\t<li>从位置&nbsp;<code>(0, 0)</code> 出发，最后到达 <code>(n - 1, n - 1)</code> ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为 <code>0</code> 或者 <code>1</code> 的格子）；</li>\n\t<li>当到达 <code>(n - 1, n&nbsp;- 1)</code> 后，你要继续走，直到返回到 <code>(0, 0) </code>，只能向上或向左走，并且只能穿越有效的格子；</li>\n\t<li>当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为 <code>0</code> ）；</li>\n\t<li>如果在 <code>(0, 0)</code> 和 <code>(n - 1, n - 1)</code> 之间不存在一条可经过的路径，则无法摘到任何一个樱桃。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/14/grid.jpg\" />\n<pre>\n<b>输入：</b>grid = [[0,1,-1],[1,0,-1],[1,1,1]]\n<b>输出：</b>5\n<b>解释：</b>玩家从 (0, 0) 出发：向下、向下、向右、向右移动至 (2, 2) 。\n在这一次行程中捡到 4 个樱桃，矩阵变成 [[0,1,-1],[0,0,-1],[0,0,0]] 。\n然后，玩家向左、向上、向上、向左返回起点，再捡到 1 个樱桃。\n总共捡到 5 个樱桃，这是最大可能值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>grid = [[1,1,-1],[1,-1,1],[-1,1,1]]\n<b>输出：</b>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>grid[i][j]</code>&nbsp;为&nbsp;<code>-1</code>、<code>0</code>&nbsp;或&nbsp;<code>1</code></li>\n\t<li><code>grid[0][0] != -1</code></li>\n\t<li><code>grid[n - 1][n - 1] != -1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 742.二叉树最近的叶节点",
        "hardRate": "MEDIUM",
        "passRate": "48.90%",
        "problemsUrl": "https://leetcode.cn/problems/closest-leaf-in-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-leaf-in-a-binary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 743.网络延迟时间",
        "hardRate": "MEDIUM",
        "passRate": "55.65%",
        "problemsUrl": "https://leetcode.cn/problems/network-delay-time/",
        "solutionsUrl": "https://leetcode.cn/problems/network-delay-time/solution",
        "problemsDesc": "<p>有 <code>n</code> 个网络节点，标记为&nbsp;<code>1</code>&nbsp;到 <code>n</code>。</p>\n\n<p>给你一个列表&nbsp;<code>times</code>，表示信号经过 <strong>有向</strong> 边的传递时间。&nbsp;<code>times[i] = (u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>)</code>，其中&nbsp;<code>u<sub>i</sub></code>&nbsp;是源节点，<code>v<sub>i</sub></code>&nbsp;是目标节点， <code>w<sub>i</sub></code>&nbsp;是一个信号从源节点传递到目标节点的时间。</p>\n\n<p>现在，从某个节点&nbsp;<code>K</code>&nbsp;发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回&nbsp;<code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png\" style=\"height: 220px; width: 200px;\" /></p>\n\n<pre>\n<strong>输入：</strong>times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>times = [[1,2,1]], n = 2, k = 1\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>times = [[1,2,1]], n = 2, k = 2\n<strong>输出：</strong>-1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= times.length &lt;= 6000</code></li>\n\t<li><code>times[i].length == 3</code></li>\n\t<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n\t<li><code>0 &lt;= w<sub>i</sub> &lt;= 100</code></li>\n\t<li>所有 <code>(u<sub>i</sub>, v<sub>i</sub>)</code> 对都 <strong>互不相同</strong>（即，不含重复边）</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 744.寻找比目标字母大的最小字母",
        "hardRate": "EASY",
        "passRate": "48.36%",
        "problemsUrl": "https://leetcode.cn/problems/find-smallest-letter-greater-than-target/",
        "solutionsUrl": "https://leetcode.cn/problems/find-smallest-letter-greater-than-target/solution",
        "problemsDesc": "<p>给你一个字符数组 <code>letters</code>，该数组按<strong>非递减顺序</strong>排序，以及一个字符 <code>target</code>。<code>letters</code>&nbsp;里<strong>至少有两个不同</strong>的字符。</p>\n\n<p>返回&nbsp;<code>letters</code>&nbsp;中大于 <code>target</code> 的最小的字符。如果不存在这样的字符，则返回&nbsp;<code>letters</code> 的第一个字符。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>letters = [\"c\", \"f\", \"j\"]，target = \"a\"\n<strong>输出:</strong> \"c\"\n<strong>解释：</strong>letters 中字典上比 'a' 大的最小字符是 'c'。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> letters = [\"c\",\"f\",\"j\"], target = \"c\"\n<strong>输出:</strong> \"f\"\n<strong>解释：</strong>letters 中字典顺序上大于 'c' 的最小字符是 'f'。</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> letters = [\"x\",\"x\",\"y\",\"y\"], target = \"z\"\n<strong>输出:</strong> \"x\"\n<strong>解释：</strong>letters 中没有一个字符在字典上大于 'z'，所以我们返回 letters[0]。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= letters.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>letters[i]</code>&nbsp;是一个小写字母</li>\n\t<li><code>letters</code> 按<strong>非递减顺序</strong>排序</li>\n\t<li><code>letters</code> 最少包含两个不同的字母</li>\n\t<li><code>target</code> 是一个小写字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 745.前缀和后缀搜索",
        "hardRate": "HARD",
        "passRate": "43.92%",
        "problemsUrl": "https://leetcode.cn/problems/prefix-and-suffix-search/",
        "solutionsUrl": "https://leetcode.cn/problems/prefix-and-suffix-search/solution",
        "problemsDesc": "<p>设计一个包含一些单词的特殊词典，并能够通过前缀和后缀来检索单词。</p>\n\n<p>实现 <code>WordFilter</code> 类：</p>\n\n<ul>\n\t<li><code>WordFilter(string[] words)</code> 使用词典中的单词 <code>words</code> 初始化对象。</li>\n\t<li><code>f(string pref, string suff)</code> 返回词典中具有前缀&nbsp;<code>prefix</code>&nbsp;和后缀 <code>suff</code>&nbsp;的单词的下标。如果存在不止一个满足要求的下标，返回其中 <strong>最大的下标</strong> 。如果不存在这样的单词，返回 <code>-1</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"WordFilter\", \"f\"]\n[[[\"apple\"]], [\"a\", \"e\"]]\n<strong>输出</strong>\n[null, 0]\n<strong>解释</strong>\nWordFilter wordFilter = new WordFilter([\"apple\"]);\nwordFilter.f(\"a\", \"e\"); // 返回 0 ，因为下标为 0 的单词：前缀 prefix = \"a\" 且 后缀 suff = \"e\" 。\n</pre>\n&nbsp;\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 7</code></li>\n\t<li><code>1 &lt;= pref.length, suff.length &lt;= 7</code></li>\n\t<li><code>words[i]</code>、<code>pref</code> 和 <code>suff</code> 仅由小写英文字母组成</li>\n\t<li>最多对函数 <code>f</code> 执行 <code>10<sup>4</sup></code> 次调用</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 746.使用最小花费爬楼梯",
        "hardRate": "EASY",
        "passRate": "64.75%",
        "problemsUrl": "https://leetcode.cn/problems/min-cost-climbing-stairs/",
        "solutionsUrl": "https://leetcode.cn/problems/min-cost-climbing-stairs/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>\n\n<p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p>\n\n<p>请你计算并返回达到楼梯顶部的最低花费。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>cost = [10,<em><strong>15</strong></em>,20]\n<strong>输出：</strong>15\n<strong>解释：</strong>你将从下标为 1 的台阶开始。\n- 支付 15 ，向上爬两个台阶，到达楼梯顶部。\n总花费为 15 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>cost = [<em><strong>1</strong></em>,100,<em><strong>1</strong></em>,1,<em><strong>1</strong></em>,100,<em><strong>1</strong></em>,<em><strong>1</strong></em>,100,<em><strong>1</strong></em>]\n<strong>输出：</strong>6\n<strong>解释：</strong>你将从下标为 0 的台阶开始。\n- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。\n- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。\n- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。\n- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。\n- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。\n- 支付 1 ，向上爬一个台阶，到达楼梯顶部。\n总花费为 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= cost.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= cost[i] &lt;= 999</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 747.至少是其他数字两倍的最大数",
        "hardRate": "EASY",
        "passRate": "46.34%",
        "problemsUrl": "https://leetcode.cn/problems/largest-number-at-least-twice-of-others/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-number-at-least-twice-of-others/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，其中总是存在 <strong>唯一的</strong> 一个最大整数 。</p>\n\n<p>请你找出数组中的最大元素并检查它是否 <strong>至少是数组中每个其他数字的两倍</strong> 。如果是，则返回 <strong>最大元素的下标</strong> ，否则返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,6,1,0]\n<strong>输出：</strong>1\n<strong>解释：</strong>6 是最大的整数，对于数组中的其他整数，6 至少是数组中其他元素的两倍。6 的下标是 1 ，所以返回 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>-1\n<strong>解释：</strong>4 没有超过 3 的两倍大，所以返回 -1 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1]\n<strong>输出：</strong>0\n<strong>解释：</strong>因为不存在其他数字，所以认为现有数字 1 至少是其他数字的两倍。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>nums</code> 中的最大元素是唯一的</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 748.最短补全词",
        "hardRate": "EASY",
        "passRate": "66.66%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-completing-word/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-completing-word/solution",
        "problemsDesc": "<p>给你一个字符串 <code>licensePlate</code> 和一个字符串数组 <code>words</code> ，请你找出&nbsp;<code>words</code> 中的 <strong>最短补全词</strong> 。</p>\n\n<p><strong>补全词 </strong>是一个包含 <code>licensePlate</code> 中所有字母的单词。<strong>忽略</strong>&nbsp;<code>licensePlate</code> 中的 <strong>数字和空格 </strong>。<strong>不区分大小写</strong>。如果某个字母在 <code>licensePlate</code> 中出现不止一次，那么该字母在补全词中的出现次数应当一致或者更多。</p>\n\n<p>例如：<code>licensePlate</code><code> = \"aBc 12c\"</code>，那么它的补全词应当包含字母 <code>'a'</code>、<code>'b'</code> （忽略大写）和两个 <code>'c'</code> 。可能的 <strong>补全词</strong> 有 <code>\"abccdef\"</code>、<code>\"caaacab\"</code> 以及 <code>\"cbca\"</code> 。</p>\n\n<p>请返回 <code>words</code> 中的 <strong>最短补全词</strong> 。题目数据保证一定存在一个最短补全词。当有多个单词都符合最短补全词的匹配条件时取 <code>words</code> 中 <strong>第一个</strong> 出现的那个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>licensePlate = \"1s3 PSt\", words = [\"step\", \"steps\", \"stripe\", \"stepple\"]\n<strong>输出：</strong>\"steps\"\n<strong>解释：</strong>最短补全词应该包括 \"s\"、\"p\"、\"s\"（忽略大小写） 以及 \"t\"。\n\"step\" 包含 \"t\"、\"p\"，但只包含一个 \"s\"，所以它不符合条件。\n\"steps\" 包含 \"t\"、\"p\" 和两个 \"s\"。\n\"stripe\" 缺一个 \"s\"。\n\"stepple\" 缺一个 \"s\"。\n因此，\"steps\" 是唯一一个包含所有字母的单词，也是本例的答案。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>licensePlate = \"1s3 456\", words = [\"looks\", \"pest\", \"stew\", \"show\"]\n<strong>输出：</strong>\"pest\"\n<strong>解释：</strong>licensePlate 只包含字母 \"s\" 。所有的单词都包含字母 \"s\" ，其中 \"pest\"、\"stew\"、和 \"show\" 三者最短。答案是 \"pest\" ，因为它是三个单词中在 words 里最靠前的那个。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= licensePlate.length &lt;= 7</code></li>\n\t<li><code>licensePlate</code> 由数字、大小写字母或空格 <code>' '</code> 组成</li>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 15</code></li>\n\t<li><code>words[i]</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 749.隔离病毒",
        "hardRate": "HARD",
        "passRate": "69.05%",
        "problemsUrl": "https://leetcode.cn/problems/contain-virus/",
        "solutionsUrl": "https://leetcode.cn/problems/contain-virus/solution",
        "problemsDesc": "<p>病毒扩散得很快，现在你的任务是尽可能地通过安装防火墙来隔离病毒。</p>\n\n<p>假设世界由&nbsp;<code>m x n</code>&nbsp;的二维矩阵&nbsp;<code>isInfected</code>&nbsp;组成，&nbsp;<code>isInfected[i][j] == 0</code>&nbsp;表示该区域未感染病毒，而 &nbsp;<code>isInfected[i][j] == 1</code>&nbsp;表示该区域已感染病毒。可以在任意 2 个相邻单元之间的共享边界上安装一个防火墙（并且只有一个防火墙）。</p>\n\n<p>每天晚上，病毒会从被感染区域向相邻未感染区域扩散，除非被防火墙隔离。现由于资源有限，每天你只能安装一系列防火墙来隔离其中一个被病毒感染的区域（一个区域或连续的一片区域），且该感染区域对未感染区域的威胁最大且 <strong>保证唯一&nbsp;</strong>。</p>\n\n<p>你需要努力使得最后有部分区域不被病毒感染，如果可以成功，那么返回需要使用的防火墙个数; 如果无法实现，则返回在世界被病毒全部感染时已安装的防火墙个数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/01/virus11-grid.jpg\" style=\"height: 255px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入:</strong> isInfected = [[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]]\n<strong>输出:</strong> 10\n<strong>解释:</strong>一共有两块被病毒感染的区域。\n在第一天，添加 5 墙隔离病毒区域的左侧。病毒传播后的状态是:\n<img src=\"https://assets.leetcode.com/uploads/2021/06/01/virus12edited-grid.jpg\" style=\"height: 261px; width: 500px;\" />\n第二天，在右侧添加 5 个墙来隔离病毒区域。此时病毒已经被完全控制住了。\n<img src=\"https://assets.leetcode.com/uploads/2021/06/01/virus13edited-grid.jpg\" style=\"height: 261px; width: 500px;\" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/01/virus2-grid.jpg\" style=\"height: 253px; width: 653px;\" /></p>\n\n<pre>\n<strong>输入:</strong> isInfected = [[1,1,1],[1,0,1],[1,1,1]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> 虽然只保存了一个小区域，但却有四面墙。\n注意，防火墙只建立在两个不同区域的共享边界上。\n</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre>\n<strong>输入:</strong> isInfected = [[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]]\n<strong>输出:</strong> 13\n<strong>解释:</strong> 在隔离右边感染区域后，隔离左边病毒区域只需要 2 个防火墙。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>m ==&nbsp;isInfected.length</code></li>\n\t<li><code>n ==&nbsp;isInfected[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>isInfected[i][j]</code>&nbsp;is either&nbsp;<code>0</code>&nbsp;or&nbsp;<code>1</code></li>\n\t<li>在整个描述的过程中，总有一个相邻的病毒区域，它将在下一轮 <strong>严格地感染更多未受污染的方块</strong>&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 750.角矩形的数量",
        "hardRate": "MEDIUM",
        "passRate": "73.11%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-corner-rectangles/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-corner-rectangles/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 751.IP 到 CIDR",
        "hardRate": "MEDIUM",
        "passRate": "48.37%",
        "problemsUrl": "https://leetcode.cn/problems/ip-to-cidr/",
        "solutionsUrl": "https://leetcode.cn/problems/ip-to-cidr/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 752.打开转盘锁",
        "hardRate": "MEDIUM",
        "passRate": "52.71%",
        "problemsUrl": "https://leetcode.cn/problems/open-the-lock/",
        "solutionsUrl": "https://leetcode.cn/problems/open-the-lock/solution",
        "problemsDesc": "<p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： <code>'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'</code> 。每个拨轮可以自由旋转：例如把 <code>'9'</code> 变为&nbsp;<code>'0'</code>，<code>'0'</code> 变为 <code>'9'</code> 。每次旋转都只能旋转一个拨轮的一位数字。</p>\n\n<p>锁的初始数字为 <code>'0000'</code> ，一个代表四个拨轮的数字的字符串。</p>\n\n<p>列表 <code>deadends</code> 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p>\n\n<p>字符串 <code>target</code> 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"\n<strong>输出：</strong>6\n<strong>解释：</strong>\n可能的移动序列为 \"0000\" -&gt; \"1000\" -&gt; \"1100\" -&gt; \"1200\" -&gt; \"1201\" -&gt; \"1202\" -&gt; \"0202\"。\n注意 \"0000\" -&gt; \"0001\" -&gt; \"0002\" -&gt; \"0102\" -&gt; \"0202\" 这样的序列是不能解锁的，\n因为当拨动到 \"0102\" 时这个锁就会被锁定。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> deadends = [\"8888\"], target = \"0009\"\n<strong>输出：</strong>1\n<strong>解释：</strong>把最后一位反向旋转一次即可 \"0000\" -&gt; \"0009\"。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"\n<strong>输出：</strong>-1\n<strong>解释：</strong>无法旋转到目标数字且不被锁定。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;deadends.length &lt;= 500</code></li>\n\t<li><code><font face=\"monospace\">deadends[i].length == 4</font></code></li>\n\t<li><code><font face=\"monospace\">target.length == 4</font></code></li>\n\t<li><code>target</code> <strong>不在</strong> <code>deadends</code> 之中</li>\n\t<li><code>target</code> 和 <code>deadends[i]</code> 仅由若干位数字组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 753.破解保险箱",
        "hardRate": "HARD",
        "passRate": "74.87%",
        "problemsUrl": "https://leetcode.cn/problems/cracking-the-safe/",
        "solutionsUrl": "https://leetcode.cn/problems/cracking-the-safe/solution",
        "problemsDesc": "<p>有一个需要密码才能打开的保险箱。密码是&nbsp;<code>n</code> 位数, 密码的每一位都是范围&nbsp;<code>[0, k - 1]</code>&nbsp;中的一个数字。</p>\n\n<p>保险箱有一种特殊的密码校验方法，你可以随意输入密码序列，保险箱会自动记住 <strong>最后&nbsp;<code>n</code>&nbsp;位输入</strong> ，如果匹配，则能够打开保险箱。</p>\n\n<ul>\n\t<li>例如，正确的密码是 <code>\"345\"</code> ，并且你输入的是 <code>\"012345\"</code> ：\n\n\t<ul>\n\t\t<li>输入 <code>0</code> 之后，最后 <code>3</code> 位输入是 <code>\"0\"</code> ，不正确。</li>\n\t\t<li>输入 <code>1</code> 之后，最后 <code>3</code> 位输入是 <code>\"01\"</code> ，不正确。</li>\n\t\t<li>输入 <code>2</code> 之后，最后 <code>3</code> 位输入是 <code>\"012\"</code> ，不正确。</li>\n\t\t<li>输入 <code>3</code> 之后，最后 <code>3</code> 位输入是 <code>\"123\"</code> ，不正确。</li>\n\t\t<li>输入 <code>4</code> 之后，最后 <code>3</code> 位输入是 <code>\"234\"</code> ，不正确。</li>\n\t\t<li>输入 <code>5</code> 之后，最后 <code>3</code> 位输入是 <code>\"345\"</code> ，正确，打开保险箱。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>在只知道密码位数 <code>n</code> 和范围边界 <code>k</code> 的前提下，请你找出并返回确保在输入的 <strong>某个时刻</strong> 能够打开保险箱的任一 <strong>最短</strong> 密码序列 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, k = 2\n<strong>输出：</strong>\"10\"\n<strong>解释：</strong>密码只有 1 位，所以输入每一位就可以。\"01\" 也能够确保打开保险箱。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, k = 2\n<strong>输出：</strong>\"01100\"\n<strong>解释：</strong>对于每种可能的密码：\n- \"00\" 从第 4 位开始输入。\n- \"01\" 从第 1 位开始输入。\n- \"10\" 从第 3 位开始输入。\n- \"11\" 从第 2 位开始输入。\n因此 \"01100\" 可以确保打开保险箱。\"01100\"、\"10011\" 和 \"11001\" 也可以确保打开保险箱。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 4</code></li>\n\t<li><code>1 &lt;= k &lt;= 10</code></li>\n\t<li><code>1 &lt;= k<sup>n</sup> &lt;= 4096</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 754.到达终点数字",
        "hardRate": "MEDIUM",
        "passRate": "51.42%",
        "problemsUrl": "https://leetcode.cn/problems/reach-a-number/",
        "solutionsUrl": "https://leetcode.cn/problems/reach-a-number/solution",
        "problemsDesc": "<p>在一根无限长的数轴上，你站在<code>0</code>的位置。终点在<code>target</code>的位置。</p>\n\n<p>你可以做一些数量的移动 <code>numMoves</code> :</p>\n\n<ul>\n\t<li>每次你可以选择向左或向右移动。</li>\n\t<li>第 <code>i</code>&nbsp;次移动（从 &nbsp;<code>i == 1</code>&nbsp;开始，到&nbsp;<code>i == numMoves</code> ），在选择的方向上走 <code>i</code>&nbsp;步。</li>\n</ul>\n\n<p>给定整数&nbsp;<code>target</code> ，返回 <em>到达目标所需的 <strong>最小&nbsp;</strong>移动次数(即最小 <code>numMoves</code> )&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> target = 2\n<strong>输出:</strong> 3\n<strong>解释:</strong>\n第一次移动，从 0 到 1 。\n第二次移动，从 1 到 -1 。\n第三次移动，从 -1 到 2 。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> target = 3\n<strong>输出:</strong> 2\n<strong>解释:</strong>\n第一次移动，从 0 到 1 。\n第二次移动，从 1 到 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><code>target != 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 755.倒水",
        "hardRate": "MEDIUM",
        "passRate": "48.26%",
        "problemsUrl": "https://leetcode.cn/problems/pour-water/",
        "solutionsUrl": "https://leetcode.cn/problems/pour-water/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 756.金字塔转换矩阵",
        "hardRate": "MEDIUM",
        "passRate": "52.17%",
        "problemsUrl": "https://leetcode.cn/problems/pyramid-transition-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/pyramid-transition-matrix/solution",
        "problemsDesc": "<p>你正在把积木堆成金字塔。每个块都有一个颜色，用一个字母表示。每一行的块比它下面的行 <strong>少一个块</strong> ，并且居中。</p>\n\n<p>为了使金字塔美观，只有特定的 <strong>三角形图案</strong> 是允许的。一个三角形的图案由&nbsp;<strong>两个块</strong>&nbsp;和叠在上面的 <strong>单个块</strong> 组成。模式是以三个字母字符串的列表形式&nbsp;<code>allowed</code>&nbsp;给出的，其中模式的前两个字符分别表示左右底部块，第三个字符表示顶部块。</p>\n\n<ul>\n\t<li>例如，<code>\"ABC\"</code>&nbsp;表示一个三角形图案，其中一个 <code>“C”</code> 块堆叠在一个&nbsp;<code>'A'</code>&nbsp;块(左)和一个&nbsp;<code>'B'</code>&nbsp;块(右)之上。请注意，这与 <code>\"BAC\"</code>&nbsp;不同，<code>\"B\"</code>&nbsp;在左下角，<code>\"A\"</code>&nbsp;在右下角。</li>\n</ul>\n\n<p>你从底部的一排积木&nbsp;<code>bottom</code>&nbsp;开始，作为一个单一的字符串，你 <strong>必须</strong> 使用作为金字塔的底部。</p>\n\n<p>在给定&nbsp;<code>bottom</code>&nbsp;和&nbsp;<code>allowed</code>&nbsp;的情况下，如果你能一直构建到金字塔顶部，使金字塔中的 <strong>每个三角形图案</strong> 都是允许的，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/26/pyramid1-grid.jpg\" style=\"height: 232px; width: 600px;\" /></p>\n\n<pre>\n<strong>输入：</strong>bottom = \"BCD\", allowed = [\"BCC\",\"CDE\",\"CEA\",\"FFF\"]\n<strong>输出：</strong>true\n<strong>解释：</strong>允许的三角形模式显示在右边。\n从最底层(第3层)开始，我们可以在第2层构建“CE”，然后在第1层构建“E”。\n金字塔中有三种三角形图案，分别是“BCC”、“CDE”和“CEA”。都是允许的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/26/pyramid2-grid.jpg\" style=\"height: 359px; width: 600px;\" /></p>\n\n<pre>\n<strong>输入：</strong>bottom = \"AAAA\", allowed = [\"AAB\",\"AAC\",\"BCD\",\"BBE\",\"DEF\"]\n<strong>输出：</strong>false\n<strong>解释：</strong>允许的三角形模式显示在右边。\n从最底层(游戏邦注:即第4个关卡)开始，创造第3个关卡有多种方法，但如果尝试所有可能性，你便会在创造第1个关卡前陷入困境。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= bottom.length &lt;= 6</code></li>\n\t<li><code>0 &lt;= allowed.length &lt;= 216</code></li>\n\t<li><code>allowed[i].length == 3</code></li>\n\t<li>所有输入字符串中的字母来自集合&nbsp;<code>{'A', 'B', 'C', 'D', 'E', 'F', 'G'}</code>。</li>\n\t<li>&nbsp;<code>allowed</code>&nbsp;中所有值都是 <strong>唯一的</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 757.设置交集大小至少为2",
        "hardRate": "HARD",
        "passRate": "56.07%",
        "problemsUrl": "https://leetcode.cn/problems/set-intersection-size-at-least-two/",
        "solutionsUrl": "https://leetcode.cn/problems/set-intersection-size-at-least-two/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>intervals</code> ，其中 <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 表示从 <code>start<sub>i</sub></code> 到 <code>end<sub>i</sub></code> 的所有整数，包括 <code>start<sub>i</sub></code> 和 <code>end<sub>i</sub></code> 。</p>\n\n<p><strong>包含集合</strong> 是一个名为 <code>nums</code> 的数组，并满足 <code>intervals</code> 中的每个区间都 <strong>至少</strong> 有 <strong>两个</strong> 整数在 <code>nums</code> 中。</p>\n\n<ul>\n\t<li>例如，如果 <code>intervals = [[1,3], [3,7], [8,9]]</code> ，那么 <code>[1,2,4,7,8,9]</code> 和 <code>[2,3,4,8,9]</code> 都符合 <strong>包含集合</strong> 的定义。</li>\n</ul>\n\n<p>返回包含集合可能的最小大小。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,3],[3,7],[8,9]]\n<strong>输出：</strong>5\n<strong>解释：</strong>nums = [2, 3, 4, 8, 9].\n可以证明不存在元素数量为 4 的包含集合。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,3],[1,4],[2,5],[3,5]]\n<strong>输出：</strong>3\n<strong>解释：</strong>nums = [2, 3, 4].\n可以证明不存在元素数量为 2 的包含集合。 \n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,2],[2,3],[2,4],[4,5]]\n<strong>输出：</strong>5\n<strong>解释：</strong>nums = [1, 2, 3, 4, 5].\n可以证明不存在元素数量为 4 的包含集合。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 3000</code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt; end<sub>i</sub> &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 758.字符串中的加粗单词",
        "hardRate": "MEDIUM",
        "passRate": "48.33%",
        "problemsUrl": "https://leetcode.cn/problems/bold-words-in-string/",
        "solutionsUrl": "https://leetcode.cn/problems/bold-words-in-string/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 759.员工空闲时间",
        "hardRate": "HARD",
        "passRate": "70.54%",
        "problemsUrl": "https://leetcode.cn/problems/employee-free-time/",
        "solutionsUrl": "https://leetcode.cn/problems/employee-free-time/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 760.找出变位映射",
        "hardRate": "EASY",
        "passRate": "84.38%",
        "problemsUrl": "https://leetcode.cn/problems/find-anagram-mappings/",
        "solutionsUrl": "https://leetcode.cn/problems/find-anagram-mappings/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 761.特殊的二进制序列",
        "hardRate": "HARD",
        "passRate": "75.23%",
        "problemsUrl": "https://leetcode.cn/problems/special-binary-string/",
        "solutionsUrl": "https://leetcode.cn/problems/special-binary-string/solution",
        "problemsDesc": "<p>特殊的二进制序列是具有以下两个性质的二进制序列：</p>\n\n<ul>\n\t<li>0 的数量与 1 的数量相等。</li>\n\t<li>二进制序列的每一个前缀码中 1 的数量要大于等于 0 的数量。</li>\n</ul>\n\n<p>给定一个特殊的二进制序列&nbsp;<code>S</code>，以字符串形式表示。定义一个<em>操作 </em>为首先选择&nbsp;<code>S</code>&nbsp;的两个连续且非空的特殊的子串，然后将它们交换。（两个子串为连续的当且仅当第一个子串的最后一个字符恰好为第二个子串的第一个字符的前一个字符。)</p>\n\n<p>在任意次数的操作之后，交换后的字符串按照字典序排列的最大的结果是什么？</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> S = &quot;11011000&quot;\n<strong>输出:</strong> &quot;11100100&quot;\n<strong>解释:</strong>\n将子串 &quot;10&quot; （在S[1]出现） 和 &quot;1100&quot; （在S[3]出现）进行交换。\n这是在进行若干次操作后按字典序排列最大的结果。\n</pre>\n\n<p><strong>说明:</strong></p>\n\n<ol>\n\t<li><code>S</code>&nbsp;的长度不超过&nbsp;<code>50</code>。</li>\n\t<li><code>S</code>&nbsp;保证为一个满足上述定义的<em>特殊 </em>的二进制序列。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 762.二进制表示中质数个计算置位",
        "hardRate": "EASY",
        "passRate": "75.31%",
        "problemsUrl": "https://leetcode.cn/problems/prime-number-of-set-bits-in-binary-representation/",
        "solutionsUrl": "https://leetcode.cn/problems/prime-number-of-set-bits-in-binary-representation/solution",
        "problemsDesc": "<p>给你两个整数&nbsp;<code>left</code>&nbsp;和&nbsp;<code>right</code> ，在闭区间 <code>[left, right]</code>&nbsp;范围内，统计并返回 <strong>计算置位位数为质数</strong> 的整数个数。</p>\n\n<p><strong>计算置位位数</strong> 就是二进制表示中 <code>1</code> 的个数。</p>\n\n<ul>\n\t<li>例如， <code>21</code>&nbsp;的二进制表示&nbsp;<code>10101</code>&nbsp;有 <code>3</code> 个计算置位。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>left = 6, right = 10\n<strong>输出：</strong>4\n<strong>解释：</strong>\n6 -&gt; 110 (2 个计算置位，2 是质数)\n7 -&gt; 111 (3 个计算置位，3 是质数)\n9 -&gt; 1001 (2 个计算置位，2 是质数)\n10-&gt; 1010 (2 个计算置位，2 是质数)\n共计 4 个计算置位为质数的数字。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>left = 10, right = 15\n<strong>输出：</strong>5\n<strong>解释：</strong>\n10 -&gt; 1010 (2 个计算置位, 2 是质数)\n11 -&gt; 1011 (3 个计算置位, 3 是质数)\n12 -&gt; 1100 (2 个计算置位, 2 是质数)\n13 -&gt; 1101 (3 个计算置位, 3 是质数)\n14 -&gt; 1110 (3 个计算置位, 3 是质数)\n15 -&gt; 1111 (4 个计算置位, 4 不是质数)\n共计 5 个计算置位为质数的数字。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= left &lt;= right &lt;= 10<sup>6</sup></code></li>\n\t<li><code>0 &lt;= right - left &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 763.划分字母区间",
        "hardRate": "MEDIUM",
        "passRate": "76.79%",
        "problemsUrl": "https://leetcode.cn/problems/partition-labels/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-labels/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p>\n\n<p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code> 。</p>\n\n<p>返回一个表示每个字符串片段的长度的列表。</p>\n\n<p>&nbsp;</p>\n<strong class=\"example\">示例 1：</strong>\n\n<pre>\n<strong>输入：</strong>s = \"ababcbacadefegdehijhklij\"\n<strong>输出：</strong>[9,7,8]\n<strong>解释：</strong>\n划分结果为 \"ababcbaca\"、\"defegde\"、\"hijhklij\" 。\n每个字母最多出现在一个片段中。\n像 \"ababcbacadefegde\", \"hijhklij\" 这样的划分是错误的，因为划分的片段数较少。 </pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"eccbbbbdec\"\n<strong>输出：</strong>[10]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 764.最大加号标志",
        "hardRate": "MEDIUM",
        "passRate": "54.24%",
        "problemsUrl": "https://leetcode.cn/problems/largest-plus-sign/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-plus-sign/solution",
        "problemsDesc": "<p>在一个 <code>n x n</code> 的矩阵&nbsp;<code>grid</code>&nbsp;中，除了在数组&nbsp;<code>mines</code>&nbsp;中给出的元素为&nbsp;<code>0</code>，其他每个元素都为&nbsp;<code>1</code>。<code>mines[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>表示&nbsp;<code>grid[x<sub>i</sub>][y<sub>i</sub>] == 0</code></p>\n\n<p>返回 <em>&nbsp;</em><code>grid</code><em> 中包含&nbsp;<code>1</code>&nbsp;的最大的 <strong>轴对齐</strong> 加号标志的阶数</em> 。如果未找到加号标志，则返回 <code>0</code> 。</p>\n\n<p>一个&nbsp;<code>k</code>&nbsp;阶由&nbsp;<em><code>1</code></em>&nbsp;组成的 <strong>“轴对称”加号标志</strong> 具有中心网格&nbsp;<code>grid[r][c] == 1</code>&nbsp;，以及4个从中心向上、向下、向左、向右延伸，长度为&nbsp;<code>k-1</code>，由&nbsp;<code>1</code>&nbsp;组成的臂。注意，只有加号标志的所有网格要求为 <code>1</code> ，别的网格可能为 <code>0</code> 也可能为 <code>1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/13/plus1-grid.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> n = 5, mines = [[4, 2]]\n<strong>输出:</strong> 2\n<strong>解释: </strong>在上面的网格中，最大加号标志的阶只能是2。一个标志已在图中标出。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/13/plus2-grid.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> n = 1, mines = [[0, 0]]\n<strong>输出:</strong> 0\n<strong>解释: </strong>没有加号标志，返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= mines.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt; n</code></li>\n\t<li>每一对&nbsp;<code>(x<sub>i</sub>, y<sub>i</sub>)</code>&nbsp;都 <strong>不重复</strong>​​​​​​​</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 765.情侣牵手",
        "hardRate": "HARD",
        "passRate": "65.93%",
        "problemsUrl": "https://leetcode.cn/problems/couples-holding-hands/",
        "solutionsUrl": "https://leetcode.cn/problems/couples-holding-hands/solution",
        "problemsDesc": "<p><code>n</code> 对情侣坐在连续排列的 <code>2n</code>&nbsp;个座位上，想要牵到对方的手。</p>\n\n<p>人和座位由一个整数数组 <code>row</code> 表示，其中 <code>row[i]</code> 是坐在第 <code>i </code>个座位上的人的 <strong>ID</strong>。情侣们按顺序编号，第一对是&nbsp;<code>(0, 1)</code>，第二对是&nbsp;<code>(2, 3)</code>，以此类推，最后一对是&nbsp;<code>(2n-2, 2n-1)</code>。</p>\n\n<p>返回 <em>最少交换座位的次数，以便每对情侣可以并肩坐在一起</em>。 <i>每次</i>交换可选择任意两人，让他们站起来交换座位。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> row = [0,2,1,3]\n<strong>输出:</strong> 1\n<strong>解释:</strong> 只需要交换row[1]和row[2]的位置即可。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> row = [3,2,0,1]\n<strong>输出:</strong> 0\n<strong>解释:</strong> 无需交换座位，所有的情侣都已经可以手牵手了。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>2n == row.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 30</code></li>\n\t<li><code>n</code>&nbsp;是偶数</li>\n\t<li><code>0 &lt;= row[i] &lt; 2n</code></li>\n\t<li><code>row</code>&nbsp;中所有元素均<strong>无重复</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 766.托普利茨矩阵",
        "hardRate": "EASY",
        "passRate": "70.24%",
        "problemsUrl": "https://leetcode.cn/problems/toeplitz-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/toeplitz-matrix/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> 。如果这个矩阵是托普利茨矩阵，返回 <code>true</code> ；否则，返回<em> </em><code>false</code><em> 。</em></p>\n\n<p>如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是<em> </em><strong>托普利茨矩阵</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/ex1.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]\n<strong>输出：</strong>true\n<strong>解释：</strong>\n在上述矩阵中, 其对角线为: \n\"[9]\", \"[5, 5]\", \"[1, 1, 1]\", \"[2, 2, 2]\", \"[3, 3]\", \"[4]\"。 \n各条对角线上的所有元素均相同, 因此答案是 True 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/ex2.jpg\" style=\"width: 162px; height: 162px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,2],[2,2]]\n<strong>输出：</strong>false\n<strong>解释：</strong>\n对角线 \"[1, 2]\" 上的元素不同。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 <= m, n <= 20</code></li>\n\t<li><code>0 <= matrix[i][j] <= 99</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>如果矩阵存储在磁盘上，并且内存有限，以至于一次最多只能将矩阵的一行加载到内存中，该怎么办？</li>\n\t<li>如果矩阵太大，以至于一次只能将不完整的一行加载到内存中，该怎么办？</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 767.重构字符串",
        "hardRate": "MEDIUM",
        "passRate": "48.45%",
        "problemsUrl": "https://leetcode.cn/problems/reorganize-string/",
        "solutionsUrl": "https://leetcode.cn/problems/reorganize-string/solution",
        "problemsDesc": "<p>给定一个字符串&nbsp;<code>s</code>&nbsp;，检查是否能重新排布其中的字母，使得两相邻的字符不同。</p>\n\n<p>返回<em> <code>s</code>&nbsp;的任意可能的重新排列。若不可行，返回空字符串&nbsp;<code>\"\"</code></em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"aab\"\n<strong>输出:</strong> \"aba\"\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"aaab\"\n<strong>输出:</strong> \"\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>s</code> 只包含小写字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 768.最多能完成排序的块 II",
        "hardRate": "HARD",
        "passRate": "58.73%",
        "problemsUrl": "https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> 。</p>\n\n<p>将 <code>arr</code> 分割成若干 <strong>块</strong> ，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。</p>\n\n<p>返回能将数组分成的最多块数？</p>\n&nbsp;\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [5,4,3,2,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n将数组分成2块或者更多块，都无法得到所需的结果。 \n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 \n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [2,1,3,4,4]\n<strong>输出：</strong>4\n<strong>解释：</strong>\n可以把它分成两块，例如 [2, 1], [3, 4, 4]。 \n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 2000</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 769.最多能完成排序的块",
        "hardRate": "MEDIUM",
        "passRate": "59.24%",
        "problemsUrl": "https://leetcode.cn/problems/max-chunks-to-make-sorted/",
        "solutionsUrl": "https://leetcode.cn/problems/max-chunks-to-make-sorted/solution",
        "problemsDesc": "<p>给定一个长度为 <code>n</code> 的整数数组 <code>arr</code> ，它表示在 <code>[0, n - 1]</code> 范围内的整数的排列。</p>\n\n<p>我们将 <code>arr</code> 分割成若干 <strong>块</strong> (即分区)，并对每个块单独排序。将它们连接起来后，使得连接的结果和按升序排序后的原数组相同。</p>\n\n<p>返回数组能分成的最多块数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> arr = [4,3,2,1,0]\n<strong>输出:</strong> 1\n<strong>解释:</strong>\n将数组分成2块或者更多块，都无法得到所需的结果。\n例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> arr = [1,0,2,3,4]\n<strong>输出:</strong> 4\n<strong>解释:</strong>\n我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。\n然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。\n对每个块单独排序后，结果为 [0, 1], [2], [3], [4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>n == arr.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10</code></li>\n\t<li><code>0 &lt;= arr[i] &lt; n</code></li>\n\t<li><code>arr</code>&nbsp;中每个元素都 <strong>不同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 770.基本计算器 IV",
        "hardRate": "HARD",
        "passRate": "56.07%",
        "problemsUrl": "https://leetcode.cn/problems/basic-calculator-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/basic-calculator-iv/solution",
        "problemsDesc": "<p>给定一个表达式如&nbsp;<code>expression = \"e + 8 - a + 5\"</code>&nbsp;和一个求值映射，如&nbsp;<code>{\"e\": 1}</code>（给定的形式为&nbsp;<code>evalvars = [\"e\"]</code> 和&nbsp;<code>evalints = [1]</code>），返回表示简化表达式的标记列表，例如 <code>[\"-1*a\",\"14\"]</code></p>\n\n<ul>\n\t<li>表达式交替使用块和符号，每个块和符号之间有一个空格。</li>\n\t<li>块要么是括号中的表达式，要么是变量，要么是非负整数。</li>\n\t<li>变量是一个由小写字母组成的字符串（不包括数字）。请注意，变量可以是多个字母，并注意变量从不具有像&nbsp;<code>\"2x\"</code>&nbsp;或&nbsp;<code>\"-x\"</code>&nbsp;这样的前导系数或一元运算符&nbsp;。</li>\n</ul>\n\n<p>表达式按通常顺序进行求值：先是括号，然后求乘法，再计算加法和减法。</p>\n\n<ul>\n\t<li>例如，<code>expression = \"1 + 2 * 3\"</code>&nbsp;的答案是 <code>[\"7\"]</code>。</li>\n</ul>\n\n<p>输出格式如下：</p>\n\n<ul>\n\t<li>对于系数非零的每个自变量项，我们按字典排序的顺序将自变量写在一个项中。\n\t<ul>\n\t\t<li>例如，我们永远不会写像 <code>“b*a*c”</code> 这样的项，只写 <code>“a*b*c”</code>。</li>\n\t</ul>\n\t</li>\n\t<li>项的次数等于被乘的自变量的数目，并计算重复项。我们先写出答案的最大次数项，用字典顺序打破关系，此时忽略词的前导系数。\n\t<ul>\n\t\t<li>例如，<code>\"a*a*b*c\"</code> 的次数为 4。</li>\n\t</ul>\n\t</li>\n\t<li>项的前导系数直接放在左边，用星号将它与变量分隔开(如果存在的话)。前导系数 1 仍然要打印出来。</li>\n\t<li>格式良好的一个示例答案是&nbsp;<code>[\"-2*a*a*a\", \"3*a*a*b\", \"3*b*b\", \"4*a\", \"5*c\", \"-6\"]</code>&nbsp;。</li>\n\t<li>系数为 <code>0</code> 的项（包括常数项）不包括在内。\n\t<ul>\n\t\t<li>例如，<code>“0”</code> 的表达式输出为&nbsp;<code>[]</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p><strong>注意：</strong>你可以假设给定的表达式均有效。所有中间结果都在区间 <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code> 内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"e + 8 - a + 5\", evalvars = [\"e\"], evalints = [1]\n<strong>输出：</strong>[\"-1*a\",\"14\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"e - 8 + temperature - pressure\",\nevalvars = [\"e\", \"temperature\"], evalints = [1, 12]\n<strong>输出：</strong>[\"-1*pressure\",\"5\"]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"(e + 8) * (e - 8)\", evalvars = [], evalints = []\n<strong>输出：</strong>[\"1*e*e\",\"-64\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= expression.length &lt;= 250</code></li>\n\t<li><code>expression</code>&nbsp;由小写英文字母，数字&nbsp;<code>'+'</code>,&nbsp;<code>'-'</code>,&nbsp;<code>'*'</code>,&nbsp;<code>'('</code>,&nbsp;<code>')'</code>,&nbsp;<code>' '</code>&nbsp;组成</li>\n\t<li><code>expression</code>&nbsp;不包含任何前空格或后空格</li>\n\t<li><code>expression</code>&nbsp;中的所有符号都用一个空格隔开</li>\n\t<li><code>0 &lt;= evalvars.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= evalvars[i].length &lt;= 20</code></li>\n\t<li><code>evalvars[i]</code>&nbsp;由小写英文字母组成</li>\n\t<li><code>evalints.length == evalvars.length</code></li>\n\t<li><code>-100 &lt;= evalints[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 771.宝石与石头",
        "hardRate": "EASY",
        "passRate": "85.13%",
        "problemsUrl": "https://leetcode.cn/problems/jewels-and-stones/",
        "solutionsUrl": "https://leetcode.cn/problems/jewels-and-stones/solution",
        "problemsDesc": "<p>&nbsp;给你一个字符串 <code>jewels</code>&nbsp;代表石头中宝石的类型，另有一个字符串 <code>stones</code> 代表你拥有的石头。&nbsp;<code>stones</code>&nbsp;中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p>\n\n<p>字母区分大小写，因此 <code>\"a\"</code> 和 <code>\"A\"</code> 是不同类型的石头。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>jewels = \"aA\", stones = \"aAAbbbb\"\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>jewels = \"z\", stones = \"ZZ\"\n<strong>输出：</strong>0<strong>\n</strong></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;jewels.length, stones.length &lt;= 50</code></li>\n\t<li><code>jewels</code> 和 <code>stones</code> 仅由英文字母组成</li>\n\t<li><code>jewels</code> 中的所有字符都是 <strong>唯一的</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 772.基本计算器 III",
        "hardRate": "HARD",
        "passRate": "53.05%",
        "problemsUrl": "https://leetcode.cn/problems/basic-calculator-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/basic-calculator-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 773.滑动谜题",
        "hardRate": "HARD",
        "passRate": "70.20%",
        "problemsUrl": "https://leetcode.cn/problems/sliding-puzzle/",
        "solutionsUrl": "https://leetcode.cn/problems/sliding-puzzle/solution",
        "problemsDesc": "<p>在一个 <code>2 x 3</code> 的板上（<code>board</code>）有 5 块砖瓦，用数字 <code>1~5</code> 来表示, 以及一块空缺用&nbsp;<code>0</code>&nbsp;来表示。一次 <strong>移动</strong> 定义为选择&nbsp;<code>0</code>&nbsp;与一个相邻的数字（上下左右）进行交换.</p>\n\n<p>最终当板&nbsp;<code>board</code>&nbsp;的结果是&nbsp;<code>[[1,2,3],[4,5,0]]</code>&nbsp;谜板被解开。</p>\n\n<p>给出一个谜板的初始状态&nbsp;<code>board</code>&nbsp;，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/29/slide1-grid.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>board = [[1,2,3],[4,0,5]]\n<strong>输出：</strong>1\n<strong>解释：</strong>交换 0 和 5 ，1 步完成\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/29/slide2-grid.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>board = [[1,2,3],[5,4,0]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>没有办法完成谜板\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/29/slide3-grid.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>board = [[4,1,2],[5,0,3]]\n<strong>输出：</strong>5\n<strong>解释：</strong>\n最少完成谜板的最少移动次数是 5 ，\n一种移动路径:\n尚未移动: [[4,1,2],[5,0,3]]\n移动 1 次: [[4,1,2],[0,5,3]]\n移动 2 次: [[0,1,2],[4,5,3]]\n移动 3 次: [[1,0,2],[4,5,3]]\n移动 4 次: [[1,2,0],[4,5,3]]\n移动 5 次: [[1,2,3],[4,5,0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>board.length == 2</code></li>\n\t<li><code>board[i].length == 3</code></li>\n\t<li><code>0 &lt;= board[i][j] &lt;= 5</code></li>\n\t<li><code>board[i][j]</code>&nbsp;中每个值都 <strong>不同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 774.最小化去加油站的最大距离",
        "hardRate": "HARD",
        "passRate": "63.97%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-max-distance-to-gas-station/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-max-distance-to-gas-station/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 775.全局倒置与局部倒置",
        "hardRate": "MEDIUM",
        "passRate": "49.43%",
        "problemsUrl": "https://leetcode.cn/problems/global-and-local-inversions/",
        "solutionsUrl": "https://leetcode.cn/problems/global-and-local-inversions/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，表示由范围 <code>[0, n - 1]</code> 内所有整数组成的一个排列。</p>\n\n<p><strong>全局倒置</strong> 的数目等于满足下述条件不同下标对 <code>(i, j)</code> 的数目：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; n</code></li>\n\t<li><code>nums[i] &gt; nums[j]</code></li>\n</ul>\n\n<p><strong>局部倒置</strong> 的数目等于满足下述条件的下标 <code>i</code> 的数目：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; n - 1</code></li>\n\t<li><code>nums[i] &gt; nums[i + 1]</code></li>\n</ul>\n\n<p>当数组 <code>nums</code> 中 <strong>全局倒置</strong> 的数量等于 <strong>局部倒置</strong> 的数量时，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,0,2]\n<strong>输出：</strong>true\n<strong>解释：</strong>有 1 个全局倒置，和 1 个局部倒置。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,0]\n<strong>输出：</strong>false\n<strong>解释：</strong>有 2 个全局倒置，和 1 个局部倒置。\n</pre>\n&nbsp;\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt; n</code></li>\n\t<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>\n\t<li><code>nums</code> 是范围 <code>[0, n - 1]</code> 内所有数字组成的一个排列</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 776.拆分二叉搜索树",
        "hardRate": "MEDIUM",
        "passRate": "59.79%",
        "problemsUrl": "https://leetcode.cn/problems/split-bst/",
        "solutionsUrl": "https://leetcode.cn/problems/split-bst/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 777.在LR字符串中交换相邻字符",
        "hardRate": "MEDIUM",
        "passRate": "38.38%",
        "problemsUrl": "https://leetcode.cn/problems/swap-adjacent-in-lr-string/",
        "solutionsUrl": "https://leetcode.cn/problems/swap-adjacent-in-lr-string/solution",
        "problemsDesc": "<p>在一个由 <code>&#39;L&#39;</code> , <code>&#39;R&#39;</code> 和 <code>&#39;X&#39;</code> 三个字符组成的字符串（例如<code>&quot;RXXLRXRXL&quot;</code>）中进行移动操作。一次移动操作指用一个<code>&quot;LX&quot;</code>替换一个<code>&quot;XL&quot;</code>，或者用一个<code>&quot;XR&quot;</code>替换一个<code>&quot;RX&quot;</code>。现给定起始字符串<code>start</code>和结束字符串<code>end</code>，请编写代码，当且仅当存在一系列移动操作使得<code>start</code>可以转换成<code>end</code>时， 返回<code>True</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 :</strong></p>\n\n<pre><strong>输入:</strong> start = &quot;RXXLRXRXL&quot;, end = &quot;XRLXXRRLX&quot;\n<strong>输出:</strong> True\n<strong>解释:</strong>\n我们可以通过以下几步将start转换成end:\nRXXLRXRXL -&gt;\nXRXLRXRXL -&gt;\nXRLXRXRXL -&gt;\nXRLXXRRXL -&gt;\nXRLXXRRLX\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= len(start) = len(end) &lt;= 10000</code>。</li>\n\t<li><code>start</code>和<code>end</code>中的字符串仅限于<code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>和<code>&#39;X&#39;</code>。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 778.水位上升的泳池中游泳",
        "hardRate": "HARD",
        "passRate": "59.06%",
        "problemsUrl": "https://leetcode.cn/problems/swim-in-rising-water/",
        "solutionsUrl": "https://leetcode.cn/problems/swim-in-rising-water/solution",
        "problemsDesc": "<p>在一个 <code>n x n</code>&nbsp;的整数矩阵&nbsp;<code>grid</code> 中，每一个方格的值 <code>grid[i][j]</code> 表示位置 <code>(i, j)</code> 的平台高度。</p>\n\n<p>当开始下雨时，在时间为&nbsp;<code>t</code>&nbsp;时，水池中的水位为&nbsp;<code>t</code>&nbsp;。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。</p>\n\n<p>你从坐标方格的左上平台&nbsp;<code>(0，0)</code> 出发。返回 <em>你到达坐标方格的右下平台&nbsp;<code>(n-1, n-1)</code>&nbsp;所需的最少时间 。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/29/swim1-grid.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> grid = [[0,2],[1,3]]\n<strong>输出:</strong> 3\n<strong>解释:</strong>\n时间为0时，你位于坐标方格的位置为 <code>(0, 0)。</code>\n此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。\n等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/29/swim2-grid-1.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]\n<strong>输出:</strong> 16\n<strong>解释: </strong>最终的路线用加粗进行了标记。\n我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;&nbsp;n<sup>2</sup></code></li>\n\t<li><code>grid[i][j]</code>&nbsp;中每个值&nbsp;<strong>均无重复</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 779.第K个语法符号",
        "hardRate": "MEDIUM",
        "passRate": "49.74%",
        "problemsUrl": "https://leetcode.cn/problems/k-th-symbol-in-grammar/",
        "solutionsUrl": "https://leetcode.cn/problems/k-th-symbol-in-grammar/solution",
        "problemsDesc": "<p>我们构建了一个包含 <code>n</code> 行(&nbsp;<strong>索引从 1&nbsp; 开始&nbsp;</strong>)的表。首先在第一行我们写上一个 <code>0</code>。接下来的每一行，将前一行中的<code>0</code>替换为<code>01</code>，<code>1</code>替换为<code>10</code>。</p>\n\n<ul>\n\t<li>例如，对于 <code>n = 3</code> ，第 <code>1</code> 行是 <code>0</code> ，第 <code>2</code> 行是 <code>01</code> ，第3行是 <code>0110</code> 。</li>\n</ul>\n\n<p>给定行数&nbsp;<code>n</code>&nbsp;和序数 <code>k</code>，返回第 <code>n</code> 行中第 <code>k</code>&nbsp;个字符。（&nbsp;<code>k</code>&nbsp;<strong>从索引 1 开始</strong>）</p>\n\n<p><br />\n<strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 1, k = 1\n<strong>输出:</strong> 0\n<strong>解释: </strong>第一行：<u>0</u>\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 2, k = 1\n<strong>输出:</strong> 0\n<strong>解释:</strong> \n第一行: 0 \n第二行: <u>0</u>1\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 2, k = 2\n<strong>输出:</strong> 1\n<strong>解释:</strong>\n第一行: 0\n第二行: 0<u>1</u>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n\t<li><code>1 &lt;= k &lt;= 2<sup>n - 1</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 780.到达终点",
        "hardRate": "HARD",
        "passRate": "37.64%",
        "problemsUrl": "https://leetcode.cn/problems/reaching-points/",
        "solutionsUrl": "https://leetcode.cn/problems/reaching-points/solution",
        "problemsDesc": "<p>给定四个整数&nbsp;<code>sx</code>&nbsp;,&nbsp;<code>sy</code>&nbsp;，<code>tx</code>&nbsp;和&nbsp;<code>ty</code>，如果通过一系列的<strong>转换</strong>可以从起点&nbsp;<code>(sx, sy)</code>&nbsp;到达终点&nbsp;<code>(tx, ty)</code>，则返回 <code>true</code>，否则返回&nbsp;<code>false</code>。</p>\n\n<p>从点&nbsp;<code>(x, y)</code>&nbsp;可以<strong>转换</strong>到&nbsp;<code>(x, x+y)</code>&nbsp; 或者&nbsp;<code>(x+y, y)</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> sx = 1, sy = 1, tx = 3, ty = 5\n<strong>输出:</strong> true\n<strong>解释:\n</strong>可以通过以下一系列<strong>转换</strong>从起点转换到终点：\n(1, 1) -&gt; (1, 2)\n(1, 2) -&gt; (3, 2)\n(3, 2) -&gt; (3, 5)\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> sx = 1, sy = 1, tx = 2, ty = 2 \n<strong>输出:</strong> false\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> sx = 1, sy = 1, tx = 1, ty = 1 \n<strong>输出:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sx, sy, tx, ty &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 781.森林中的兔子",
        "hardRate": "MEDIUM",
        "passRate": "58.87%",
        "problemsUrl": "https://leetcode.cn/problems/rabbits-in-forest/",
        "solutionsUrl": "https://leetcode.cn/problems/rabbits-in-forest/solution",
        "problemsDesc": "<p>森林中有未知数量的兔子。提问其中若干只兔子<strong> \"还有多少只兔子与你（指被提问的兔子）颜色相同?\"</strong> ，将答案收集到一个整数数组 <code>answers</code> 中，其中 <code>answers[i]</code> 是第 <code>i</code> 只兔子的回答。</p>\n\n<p>给你数组 <code>answers</code> ，返回森林中兔子的最少数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>answers = [1,1,2]\n<strong>输出：</strong>5\n<strong>解释：</strong>\n两只回答了 \"1\" 的兔子可能有相同的颜色，设为红色。 \n之后回答了 \"2\" 的兔子不会是红色，否则他们的回答会相互矛盾。\n设回答了 \"2\" 的兔子为蓝色。 \n此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。 \n因此森林中兔子的最少数量是 5 只：3 只回答的和 2 只没有回答的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>answers = [10,10,10]\n<strong>输出：</strong>11\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= answers.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= answers[i] &lt; 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 782.变为棋盘",
        "hardRate": "HARD",
        "passRate": "59.64%",
        "problemsUrl": "https://leetcode.cn/problems/transform-to-chessboard/",
        "solutionsUrl": "https://leetcode.cn/problems/transform-to-chessboard/solution",
        "problemsDesc": "<p>一个&nbsp;<code>n x n</code>&nbsp;的二维网络&nbsp;<code>board</code>&nbsp;仅由&nbsp;<code>0</code>&nbsp;和&nbsp;<code>1</code>&nbsp;组成&nbsp;。每次移动，你能任意交换两列或是两行的位置。</p>\n\n<p>返回 <em>将这个矩阵变为<strong>&nbsp; “棋盘”&nbsp;&nbsp;</strong>所需的最小移动次数&nbsp;</em>。如果不存在可行的变换，输出 <code>-1</code>。</p>\n\n<p><strong>“棋盘”</strong> 是指任意一格的上下左右四个方向的值均与本身不同的矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/29/chessboard1-grid.jpg\" style=\"height: 145px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入:</strong> board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]\n<strong>输出:</strong> 2\n<strong>解释:</strong>一种可行的变换方式如下，从左到右：\n第一次移动交换了第一列和第二列。\n第二次移动交换了第二行和第三行。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/29/chessboard2-grid.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> board = [[0, 1], [1, 0]]\n<strong>输出:</strong> 0\n<strong>解释: </strong>注意左上角的格值为0时也是合法的棋盘，也是合法的棋盘.\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/29/chessboard3-grid.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> board = [[1, 0], [1, 0]]\n<strong>输出:</strong> -1\n<strong>解释: </strong>任意的变换都不能使这个输入变为合法的棋盘。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 30</code></li>\n\t<li><code>board[i][j]</code>&nbsp;将只包含&nbsp;<code>0</code>或&nbsp;<code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 783.二叉搜索树节点最小距离",
        "hardRate": "EASY",
        "passRate": "60.12%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-distance-between-bst-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-distance-between-bst-nodes/solution",
        "problemsDesc": "<p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p>\n\n<p>差值是一个正数，其数值等于两值之差的绝对值。</p>\n\n<p>&nbsp;</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg\" style=\"width: 292px; height: 301px;\" />\n<pre>\n<strong>输入：</strong>root = [4,2,6,1,3]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg\" style=\"width: 282px; height: 301px;\" />\n<pre>\n<strong>输入：</strong>root = [1,0,48,null,null,12,49]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目范围是 <code>[2, 100]</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与 530：<a href=\"https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/\">https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/</a> 相同</p>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 784.字母大小写全排列",
        "hardRate": "MEDIUM",
        "passRate": "72.56%",
        "problemsUrl": "https://leetcode.cn/problems/letter-case-permutation/",
        "solutionsUrl": "https://leetcode.cn/problems/letter-case-permutation/solution",
        "problemsDesc": "<p>给定一个字符串&nbsp;<code>s</code>&nbsp;，通过将字符串&nbsp;<code>s</code>&nbsp;中的每个字母转变大小写，我们可以获得一个新的字符串。</p>\n\n<p>返回 <em>所有可能得到的字符串集合</em> 。以 <strong>任意顺序</strong> 返回输出。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a1b2\"\n<strong>输出：</strong>[\"a1b2\", \"a1B2\", \"A1b2\", \"A1B2\"]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"3z4\"\n<strong>输出:</strong> [\"3z4\",\"3Z4\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 12</code></li>\n\t<li><code>s</code>&nbsp;由小写英文字母、大写英文字母和数字组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 785.判断二分图",
        "hardRate": "MEDIUM",
        "passRate": "54.66%",
        "problemsUrl": "https://leetcode.cn/problems/is-graph-bipartite/",
        "solutionsUrl": "https://leetcode.cn/problems/is-graph-bipartite/solution",
        "problemsDesc": "存在一个 <strong>无向图</strong> ，图中有 <code>n</code> 个节点。其中每个节点都有一个介于 <code>0</code> 到 <code>n - 1</code> 之间的唯一编号。给你一个二维数组 <code>graph</code> ，其中 <code>graph[u]</code> 是一个节点数组，由节点 <code>u</code> 的邻接节点组成。形式上，对于 <code>graph[u]</code> 中的每个 <code>v</code> ，都存在一条位于节点 <code>u</code> 和节点 <code>v</code> 之间的无向边。该无向图同时具有以下属性：\n<ul>\n\t<li>不存在自环（<code>graph[u]</code> 不包含 <code>u</code>）。</li>\n\t<li>不存在平行边（<code>graph[u]</code> 不包含重复值）。</li>\n\t<li>如果 <code>v</code> 在 <code>graph[u]</code> 内，那么 <code>u</code> 也应该在 <code>graph[v]</code> 内（该图是无向图）</li>\n\t<li>这个图可能不是连通图，也就是说两个节点 <code>u</code> 和 <code>v</code> 之间可能不存在一条连通彼此的路径。</li>\n</ul>\n\n<p><strong>二分图</strong> 定义：如果能将一个图的节点集合分割成两个独立的子集 <code>A</code> 和 <code>B</code> ，并使图中的每一条边的两个节点一个来自 <code>A</code> 集合，一个来自 <code>B</code> 集合，就将这个图称为 <strong>二分图</strong> 。</p>\n\n<p>如果图是二分图，返回 <code>true</code><em> </em>；否则，返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg\" style=\"width: 222px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\n<strong>输出：</strong>false\n<strong>解释：</strong><code>不能将节点分割成两个独立的子集，</code>以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg\" style=\"width: 222px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>graph = [[1,3],[0,2],[1,3],[0,2]]\n<strong>输出：</strong>true\n<strong>解释：</strong><code>可以将节点分成两组: {0, 2} 和 {1, 3} 。</code></pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>graph.length == n</code></li>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>0 <= graph[u].length < n</code></li>\n\t<li><code>0 <= graph[u][i] <= n - 1</code></li>\n\t<li><code>graph[u]</code> 不会包含 <code>u</code></li>\n\t<li><code>graph[u]</code> 的所有值 <strong>互不相同</strong></li>\n\t<li>如果 <code>graph[u]</code> 包含 <code>v</code>，那么 <code>graph[v]</code> 也会包含 <code>u</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 786.第 K 个最小的素数分数",
        "hardRate": "MEDIUM",
        "passRate": "67.62%",
        "problemsUrl": "https://leetcode.cn/problems/k-th-smallest-prime-fraction/",
        "solutionsUrl": "https://leetcode.cn/problems/k-th-smallest-prime-fraction/solution",
        "problemsDesc": "<p>给你一个按递增顺序排序的数组 <code>arr</code> 和一个整数 <code>k</code> 。数组 <code>arr</code> 由 <code>1</code> 和若干 <strong>素数</strong>&nbsp; 组成，且其中所有整数互不相同。</p>\n\n<p>对于每对满足 <code>0 &lt;= i &lt; j &lt; arr.length</code> 的 <code>i</code> 和 <code>j</code> ，可以得到分数 <code>arr[i] / arr[j]</code> 。</p>\n\n<p>那么第&nbsp;<code>k</code>&nbsp;个最小的分数是多少呢?&nbsp; 以长度为 <code>2</code> 的整数数组返回你的答案, 这里&nbsp;<code>answer[0] == arr[i]</code>&nbsp;且&nbsp;<code>answer[1] == arr[j]</code> 。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,5], k = 3\n<strong>输出：</strong>[2,5]\n<strong>解释：</strong>已构造好的分数,排序后如下所示: \n1/5, 1/3, 2/5, 1/2, 3/5, 2/3\n很明显第三个最小的分数是 2/5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,7], k = 1\n<strong>输出：</strong>[1,7]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>arr[0] == 1</code></li>\n\t<li><code>arr[i]</code> 是一个 <strong>素数</strong> ，<code>i &gt; 0</code></li>\n\t<li><code>arr</code> 中的所有数字 <strong>互不相同</strong> ，且按 <strong>严格递增</strong> 排序</li>\n\t<li><code>1 &lt;= k &lt;= arr.length * (arr.length - 1) / 2</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以设计并实现时间复杂度小于 <code>O(n<sup>2</sup>)</code> 的算法解决此问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 787.K 站中转内最便宜的航班",
        "hardRate": "MEDIUM",
        "passRate": "39.67%",
        "problemsUrl": "https://leetcode.cn/problems/cheapest-flights-within-k-stops/",
        "solutionsUrl": "https://leetcode.cn/problems/cheapest-flights-within-k-stops/solution",
        "problemsDesc": "<p>有 <code>n</code> 个城市通过一些航班连接。给你一个数组&nbsp;<code>flights</code> ，其中&nbsp;<code>flights[i] = [from<sub>i</sub>, to<sub>i</sub>, price<sub>i</sub>]</code> ，表示该航班都从城市 <code>from<sub>i</sub></code> 开始，以价格 <code>price<sub>i</sub></code> 抵达 <code>to<sub>i</sub></code>。</p>\n\n<p>现在给定所有的城市和航班，以及出发城市 <code>src</code> 和目的地 <code>dst</code>，你的任务是找到出一条最多经过 <code>k</code>&nbsp;站中转的路线，使得从 <code>src</code> 到 <code>dst</code> 的 <strong>价格最便宜</strong> ，并返回该价格。 如果不存在这样的路线，则输出 <code>-1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> \nn = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]\nsrc = 0, dst = 2, k = 1\n<strong>输出:</strong> 200\n<strong>解释:</strong> \n城市航班图如下\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png\" style=\"height: 180px; width: 246px;\" />\n\n从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> \nn = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]\nsrc = 0, dst = 2, k = 0\n<strong>输出:</strong> 500\n<strong>解释:</strong> \n城市航班图如下\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png\" style=\"height: 180px; width: 246px;\" />\n\n从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= flights.length &lt;= (n * (n - 1) / 2)</code></li>\n\t<li><code>flights[i].length == 3</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt; n</code></li>\n\t<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>\n\t<li><code>1 &lt;= price<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li>航班没有重复，且不存在自环</li>\n\t<li><code>0 &lt;= src, dst, k &lt; n</code></li>\n\t<li><code>src != dst</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 788.旋转数字",
        "hardRate": "MEDIUM",
        "passRate": "66.24%",
        "problemsUrl": "https://leetcode.cn/problems/rotated-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/rotated-digits/solution",
        "problemsDesc": "<p>我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。</p>\n\n<p>如果一个数的每位数字被旋转以后仍然还是一个数字，&nbsp;则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，2 和 5 互为镜像）；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。</p>\n\n<p>现在我们有一个正整数&nbsp;<code>N</code>, 计算从&nbsp;<code>1</code> 到&nbsp;<code>N</code> 中有多少个数&nbsp;X 是好数？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入:</strong> 10\n<strong>输出:</strong> 4\n<strong>解释:</strong> \n在[1, 10]中有四个好数： 2, 5, 6, 9。\n注意 1 和 10 不是好数, 因为他们在旋转之后不变。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>N&nbsp;的取值范围是&nbsp;<code>[1, 10000]</code>。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 789.逃脱阻碍者",
        "hardRate": "MEDIUM",
        "passRate": "68.48%",
        "problemsUrl": "https://leetcode.cn/problems/escape-the-ghosts/",
        "solutionsUrl": "https://leetcode.cn/problems/escape-the-ghosts/solution",
        "problemsDesc": "<p>你在进行一个简化版的吃豆人游戏。你从 <code>[0, 0]</code> 点开始出发，你的目的地是&nbsp;<code>target = [x<sub>target</sub>, y<sub>target</sub>]</code> 。地图上有一些阻碍者，以数组 <code>ghosts</code> 给出，第 <code>i</code> 个阻碍者从&nbsp;<code>ghosts[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;出发。所有输入均为 <strong>整数坐标</strong> 。</p>\n\n<p>每一回合，你和阻碍者们可以同时向东，西，南，北四个方向移动，每次可以移动到距离原位置 <strong>1 个单位</strong> 的新位置。当然，也可以选择 <strong>不动</strong> 。所有动作 <strong>同时</strong> 发生。</p>\n\n<p>如果你可以在任何阻碍者抓住你 <strong>之前</strong> 到达目的地（阻碍者可以采取任意行动方式），则被视为逃脱成功。如果你和阻碍者 <strong>同时</strong> 到达了一个位置（包括目的地）&nbsp;<strong>都不算</strong>&nbsp;是逃脱成功。</p>\n\n<p>如果不管阻碍者怎么移动都可以成功逃脱时，输出 <code>true</code> ；否则，输出 <code>false</code> 。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>ghosts = [[1,0],[0,3]], target = [0,1]\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以直接一步到达目的地 (0,1) ，在 (1, 0) 或者 (0, 3) 位置的阻碍者都不可能抓住你。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>ghosts = [[1,0]], target = [2,0]\n<strong>输出：</strong>false\n<strong>解释：</strong>你需要走到位于 (2, 0) 的目的地，但是在 (1, 0) 的阻碍者位于你和目的地之间。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>ghosts = [[2,0]], target = [1,0]\n<strong>输出：</strong>false\n<strong>解释：</strong>阻碍者可以和你同时达到目的地。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= ghosts.length &lt;= 100</code></li>\n\t<li><code>ghosts[i].length == 2</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li>同一位置可能有 <strong>多个阻碍者</strong> 。</li>\n\t<li><code>target.length == 2</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sub>target</sub>, y<sub>target</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 790.多米诺和托米诺平铺",
        "hardRate": "MEDIUM",
        "passRate": "55.73%",
        "problemsUrl": "https://leetcode.cn/problems/domino-and-tromino-tiling/",
        "solutionsUrl": "https://leetcode.cn/problems/domino-and-tromino-tiling/solution",
        "problemsDesc": "<p>有两种形状的瓷砖：一种是&nbsp;<code>2 x 1</code> 的多米诺形，另一种是形如&nbsp;\"L\" 的托米诺形。两种形状都可以旋转。</p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/15/lc-domino.jpg\" style=\"height: 195px; width: 362px;\" /></p>\n\n<p>给定整数 n ，返回可以平铺&nbsp;<code>2 x n</code> 的面板的方法的数量。<strong>返回对</strong>&nbsp;<code>10<sup>9</sup>&nbsp;+ 7</code>&nbsp;<strong>取模&nbsp;</strong>的值。</p>\n\n<p>平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/15/lc-domino1.jpg\" style=\"height: 226px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入:</strong> n = 3\n<strong>输出:</strong> 5\n<strong>解释:</strong> 五种不同的方法如上所示。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 1\n<strong>输出:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 791.自定义字符串排序",
        "hardRate": "MEDIUM",
        "passRate": "74.18%",
        "problemsUrl": "https://leetcode.cn/problems/custom-sort-string/",
        "solutionsUrl": "https://leetcode.cn/problems/custom-sort-string/solution",
        "problemsDesc": "<p>给定两个字符串 <code>order</code> 和 <code>s</code> 。<code>order</code> 的所有字母都是 <strong>唯一</strong> 的，并且以前按照一些自定义的顺序排序。</p>\n\n<p>对 <code>s</code> 的字符进行置换，使其与排序的&nbsp;<code>order</code>&nbsp;相匹配。更具体地说，如果在&nbsp;<code>order</code>&nbsp;中的字符 <code>x</code> 出现字符 <code>y</code> 之前，那么在排列后的字符串中， <code>x</code>&nbsp;也应该出现在 <code>y</code> 之前。</p>\n\n<p>返回 <em>满足这个性质的 <code>s</code> 的任意一种排列&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> order = \"cba\", s = \"abcd\"\n<strong>输出:</strong> \"cbad\"\n<strong>解释:</strong> \n“a”、“b”、“c”是按顺序出现的，所以“a”、“b”、“c”的顺序应该是“c”、“b”、“a”。\n因为“d”不是按顺序出现的，所以它可以在返回的字符串中的任何位置。“dcba”、“cdba”、“cbda”也是有效的输出。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> order = \"cbafg\", s = \"abcd\"\n<strong>输出:</strong> \"cbad\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= order.length &lt;= 26</code></li>\n\t<li><code>1 &lt;= s.length &lt;= 200</code></li>\n\t<li><code>order</code>&nbsp;和&nbsp;<code>s</code>&nbsp;由小写英文字母组成</li>\n\t<li><code>order</code>&nbsp;中的所有字符都 <strong>不同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 792.匹配子序列的单词数",
        "hardRate": "MEDIUM",
        "passRate": "51.00%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-matching-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-matching-subsequences/solution",
        "problemsDesc": "<p>给定字符串 <code>s</code>&nbsp;和字符串数组&nbsp;<code>words</code>, 返回&nbsp;&nbsp;<em><code>words[i]</code>&nbsp;中是<code>s</code>的子序列的单词个数</em>&nbsp;。</p>\n\n<p>字符串的 <strong>子序列</strong> 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。</p>\n\n<ul>\n\t<li>例如， <code>“ace”</code> 是 <code>“abcde”</code> 的子序列。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"abcde\", words = [\"a\",\"bb\",\"acd\",\"ace\"]\n<strong>输出:</strong> 3\n<strong>解释:</strong> 有三个是&nbsp;s 的子序列的单词: \"a\", \"acd\", \"ace\"。\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"dsahjpjauf\", words = [\"ahjpjau\",\"ja\",\"ahbwzgqnuk\",\"tnmlanowax\"]\n<strong>输出:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words.length &lt;= 5000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 50</code></li>\n\t<li><code>words[i]</code>和 <font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size: 12.6px; background-color: rgb(249, 242, 244);\">s</span></font>&nbsp;都只由小写字母组成。</li>\n</ul>\n<span style=\"display:block\"><span style=\"height:0px\"><span style=\"position:absolute\">​​​​</span></span></span>",
        "isPlus": false
    },
    {
        "problemsName": " 793.阶乘函数后 K 个零",
        "hardRate": "HARD",
        "passRate": "48.67%",
        "problemsUrl": "https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/",
        "solutionsUrl": "https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/solution",
        "problemsDesc": "<p>&nbsp;<code>f(x)</code>&nbsp;是&nbsp;<code>x!</code>&nbsp;末尾是 0 的数量。回想一下&nbsp;<code>x! = 1 * 2 * 3 * ... * x</code>，且 <code>0! = 1</code>&nbsp;。</p>\n\n<ul>\n\t<li>例如，&nbsp;<code>f(3) = 0</code>&nbsp;，因为 <code>3! = 6</code> 的末尾没有 0 ；而 <code>f(11) = 2</code>&nbsp;，因为 <code>11!= 39916800</code> 末端有 2 个 0 。</li>\n</ul>\n\n<p>给定&nbsp;<code>k</code>，找出返回能满足 <code>f(x) = k</code>&nbsp;的非负整数 <code>x</code>&nbsp;的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong><strong> </strong></p>\n\n<pre>\n<strong>输入：</strong>k = 0<strong>\n输出：</strong>5<strong>\n解释：</strong>0!, 1!, 2!, 3!, 和 4!&nbsp;均符合 k = 0 的条件。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 5\n<strong>输出：</strong>0\n<strong>解释：</strong>没有匹配到这样的 x!，符合 k = 5 的条件。</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> k = 3\n<strong>输出:</strong> 5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 794.有效的井字游戏",
        "hardRate": "MEDIUM",
        "passRate": "38.61%",
        "problemsUrl": "https://leetcode.cn/problems/valid-tic-tac-toe-state/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-tic-tac-toe-state/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>board</code> 表示井字游戏的棋盘。当且仅当在井字游戏过程中，棋盘有可能达到 <code>board</code> 所显示的状态时，才返回 <code>true</code> 。</p>\n\n<p>井字游戏的棋盘是一个 <code>3 x 3</code> 数组，由字符 <code>' '</code>，<code>'X'</code> 和 <code>'O'</code> 组成。字符 <code>' '</code> 代表一个空位。</p>\n\n<p>以下是井字游戏的规则：</p>\n\n<ul>\n\t<li>玩家轮流将字符放入空位（<code>' '</code>）中。</li>\n\t<li>玩家 1 总是放字符 <code>'X'</code> ，而玩家 2 总是放字符 <code>'O'</code> 。</li>\n\t<li><code>'X'</code> 和 <code>'O'</code> 只允许放置在空位中，不允许对已放有字符的位置进行填充。</li>\n\t<li>当有 3 个相同（且非空）的字符填充任何行、列或对角线时，游戏结束。</li>\n\t<li>当所有位置非空时，也算为游戏结束。</li>\n\t<li>如果游戏结束，玩家不允许再放置字符。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/15/tictactoe1-grid.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>输入：</strong>board = [\"O  \",\"   \",\"   \"]\n<strong>输出：</strong>false\n<strong>解释：</strong>玩家 1 总是放字符 \"X\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/15/tictactoe2-grid.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>输入：</strong>board = [\"XOX\",\" X \",\"   \"]\n<strong>输出：</strong>false\n<strong>解释：</strong>玩家应该轮流放字符。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/15/tictactoe4-grid.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>输入：</strong>board = [\"XOX\",\"O O\",\"XOX\"]\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>board.length == 3</code></li>\n\t<li><code>board[i].length == 3</code></li>\n\t<li><code>board[i][j]</code> 为 <code>'X'</code>、<code>'O'</code> 或 <code>' '</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 795.区间子数组个数",
        "hardRate": "MEDIUM",
        "passRate": "57.77%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和两个整数：<code>left</code> 及 <code>right</code> 。找出 <code>nums</code> 中连续、非空且其中最大元素在范围&nbsp;<code>[left, right]</code> 内的子数组，并返回满足条件的子数组的个数。</p>\n\n<p>生成的测试用例保证结果符合 <strong>32-bit</strong> 整数范围。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,4,3], left = 2, right = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>满足条件的三个子数组：[2], [2, 1], [3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,9,2,5,6], left = 2, right = 8\n<strong>输出：</strong>7\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= left &lt;= right &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 796.旋转字符串",
        "hardRate": "EASY",
        "passRate": "63.29%",
        "problemsUrl": "https://leetcode.cn/problems/rotate-string/",
        "solutionsUrl": "https://leetcode.cn/problems/rotate-string/solution",
        "problemsDesc": "<p>给定两个字符串, <code>s</code>&nbsp;和&nbsp;<code>goal</code>。如果在若干次旋转操作之后，<code>s</code>&nbsp;能变成&nbsp;<code>goal</code>&nbsp;，那么返回&nbsp;<code>true</code>&nbsp;。</p>\n\n<p><code>s</code>&nbsp;的 <strong>旋转操作</strong> 就是将&nbsp;<code>s</code> 最左边的字符移动到最右边。&nbsp;</p>\n\n<ul>\n\t<li>例如, 若&nbsp;<code>s = 'abcde'</code>，在旋转一次之后结果就是<code>'bcdea'</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"abcde\", goal = \"cdeab\"\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"abcde\", goal = \"abced\"\n<strong>输出:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, goal.length &lt;= 100</code></li>\n\t<li><code>s</code>&nbsp;和&nbsp;<code>goal</code>&nbsp;由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 797.所有可能的路径",
        "hardRate": "MEDIUM",
        "passRate": "78.86%",
        "problemsUrl": "https://leetcode.cn/problems/all-paths-from-source-to-target/",
        "solutionsUrl": "https://leetcode.cn/problems/all-paths-from-source-to-target/solution",
        "problemsDesc": "<p>给你一个有&nbsp;<code>n</code>&nbsp;个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code>&nbsp;到节点 <code>n-1</code>&nbsp;的路径并输出（<strong>不要求按特定顺序</strong>）</p>\n\n<p><meta charset=\"UTF-8\" />&nbsp;<code>graph[i]</code>&nbsp;是一个从节点 <code>i</code> 可以访问的所有节点的列表（即从节点 <code>i</code> 到节点&nbsp;<code>graph[i][j]</code>存在一条有向边）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,2],[3],[3],[]]\n<strong>输出：</strong>[[0,1,3],[0,2,3]]\n<strong>解释：</strong>有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>graph = [[4,3,1],[3,2,4],[3],[4],[]]\n<strong>输出：</strong>[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == graph.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 15</code></li>\n\t<li><code>0 &lt;= graph[i][j] &lt; n</code></li>\n\t<li><code>graph[i][j] != i</code>（即不存在自环）</li>\n\t<li><code>graph[i]</code> 中的所有元素 <strong>互不相同</strong></li>\n\t<li>保证输入为 <strong>有向无环图（DAG）</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 798.得分最高的最小轮调",
        "hardRate": "HARD",
        "passRate": "61.59%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-rotation-with-highest-score/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-rotation-with-highest-score/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>nums</code>，我们可以将它按一个非负整数 <code>k</code> 进行轮调，这样可以使数组变为&nbsp;<code>[nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]</code>&nbsp;的形式。此后，任何值小于或等于其索引的项都可以记作一分。</p>\n\n<ul>\n\t<li>例如，数组为&nbsp;<code>nums = [2,4,1,3,0]</code>，我们按&nbsp;<code>k = 2</code>&nbsp;进行轮调后，它将变成&nbsp;<code>[1,3,0,2,4]</code>。这将记为 <code>3</code> 分，因为 <code>1 &gt; 0</code> [不计分]、<code>3 &gt; 1</code> [不计分]、<code>0 &lt;= 2</code> [计 1 分]、<code>2 &lt;= 3</code> [计 1 分]，<code>4 &lt;= 4</code> [计 1 分]。</li>\n</ul>\n\n<p>在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调下标 <code>k</code> 。如果有多个答案，返回满足条件的最小的下标 <code>k</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,1,4,0]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n下面列出了每个 k 的得分：\nk = 0,  nums = [2,3,1,4,0],    score 2\nk = 1,  nums = [3,1,4,0,2],    score 3\nk = 2,  nums = [1,4,0,2,3],    score 3\nk = 3,  nums = [4,0,2,3,1],    score 4\nk = 4,  nums = [0,2,3,1,4],    score 3\n所以我们应当选择&nbsp;k = 3，得分最高。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,0,2,4]\n<strong>输出：</strong>0\n<strong>解释：</strong>\nnums 无论怎么变化总是有 3 分。\n所以我们将选择最小的 k，即 0。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt; nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 799.香槟塔",
        "hardRate": "MEDIUM",
        "passRate": "53.02%",
        "problemsUrl": "https://leetcode.cn/problems/champagne-tower/",
        "solutionsUrl": "https://leetcode.cn/problems/champagne-tower/solution",
        "problemsDesc": "<p>我们把玻璃杯摆成金字塔的形状，其中&nbsp;<strong>第一层</strong>&nbsp;有 <code>1</code> 个玻璃杯， <strong>第二层</strong>&nbsp;有 <code>2</code> 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。</p>\n\n<p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p>\n\n<p>例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。</p>\n\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/09/tower.png\" style=\"height: 241px; width: 350px;\" /></p>\n\n<p>现在当倾倒了非负整数杯香槟后，返回第 <code>i</code> 行 <code>j</code>&nbsp;个玻璃杯所盛放的香槟占玻璃杯容积的比例（ <code>i</code> 和 <code>j</code>&nbsp;都从0开始）。</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<strong>示例 1:</strong>\n<strong>输入:</strong> poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1\n<strong>输出:</strong> 0.00000\n<strong>解释:</strong> 我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。\n\n<strong>示例 2:</strong>\n<strong>输入:</strong> poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1\n<strong>输出:</strong> 0.50000\n<strong>解释:</strong> 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。\n</pre>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> poured = 100000009, query_row = 33, query_glass = 17\n<strong>输出:</strong> 1.00000\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;=&nbsp;poured &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= query_glass &lt;= query_row&nbsp;&lt; 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 800.相似 RGB 颜色",
        "hardRate": "EASY",
        "passRate": "70.24%",
        "problemsUrl": "https://leetcode.cn/problems/similar-rgb-color/",
        "solutionsUrl": "https://leetcode.cn/problems/similar-rgb-color/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 801.使序列递增的最小交换次数",
        "hardRate": "HARD",
        "passRate": "50.61%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/solution",
        "problemsDesc": "<p>我们有两个长度相等且不为空的整型数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>&nbsp;。在一次操作中，我们可以交换&nbsp;<code>nums1[i]</code>&nbsp;和&nbsp;<code>nums2[i]</code>的元素。</p>\n\n<ul>\n\t<li>例如，如果 <code>nums1 = [1,2,3,<u>8</u>]</code> ， <code>nums2 =[5,6,7,<u>4</u>]</code> ，你可以交换 <code>i = 3</code> 处的元素，得到 <code>nums1 =[1,2,3,4]</code> 和 <code>nums2 =[5,6,7,8]</code> 。</li>\n</ul>\n\n<p>返回 <em>使 <code>nums1</code> 和 <code>nums2</code> <strong>严格递增&nbsp;</strong>所需操作的最小次数</em> 。</p>\n\n<p>数组&nbsp;<code>arr</code>&nbsp;<strong>严格递增</strong> 且&nbsp;&nbsp;<code>arr[0] &lt; arr[1] &lt; arr[2] &lt; ... &lt; arr[arr.length - 1]</code>&nbsp;。</p>\n\n<p><b>注意：</b></p>\n\n<ul>\n\t<li>用例保证可以实现操作。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums1 = [1,3,5,4], nums2 = [1,2,3,7]\n<strong>输出:</strong> 1\n<strong>解释: </strong>\n交换 A[3] 和 B[3] 后，两个数组如下:\nA = [1, 3, 5, 7] ， B = [1, 2, 3, 4]\n两个数组均为严格递增的。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums1 = [0,3,5,8,9], nums2 = [2,1,4,6,9]\n<strong>输出:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums1.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums2.length == nums1.length</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 2 * 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 802.找到最终的安全状态",
        "hardRate": "MEDIUM",
        "passRate": "59.22%",
        "problemsUrl": "https://leetcode.cn/problems/find-eventual-safe-states/",
        "solutionsUrl": "https://leetcode.cn/problems/find-eventual-safe-states/solution",
        "problemsDesc": "<p>有一个有 <code>n</code> 个节点的有向图，节点按 <code>0</code> 到 <code>n - 1</code> 编号。图由一个 <strong>索引从 0 开始</strong> 的 2D 整数数组&nbsp;<code>graph</code>表示，&nbsp;<code>graph[i]</code>是与节点 <code>i</code> 相邻的节点的整数数组，这意味着从节点 <code>i</code> 到&nbsp;<code>graph[i]</code>中的每个节点都有一条边。</p>\n\n<p>如果一个节点没有连出的有向边，则该节点是 <strong>终端节点</strong> 。如果从该节点开始的所有可能路径都通向 <strong>终端节点</strong> ，则该节点为 <strong>安全节点</strong> 。</p>\n\n<p>返回一个由图中所有 <strong>安全节点</strong> 组成的数组作为答案。答案数组中的元素应当按 <strong>升序</strong> 排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"Illustration of graph\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png\" /></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,2],[2,3],[5],[0],[5],[],[]]\n<strong>输出：</strong>[2,4,5,6]\n<strong>解释：</strong>示意图如上。\n节点 5 和节点 6 是终端节点，因为它们都没有出边。\n从节点 2、4、5 和 6 开始的所有路径都指向节点 5 或 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\n<strong>输出：</strong>[4]\n<strong>解释:</strong>\n只有节点 4 是终端节点，从节点 4 开始的所有路径都通向节点 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == graph.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= graph[i].length &lt;= n</code></li>\n\t<li><code>0 &lt;= graph[i][j] &lt;= n - 1</code></li>\n\t<li><code>graph[i]</code> 按严格递增顺序排列。</li>\n\t<li>图中可能包含自环。</li>\n\t<li>图中边的数目在范围 <code>[1, 4 * 10<sup>4</sup>]</code> 内。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 803.打砖块",
        "hardRate": "HARD",
        "passRate": "47.05%",
        "problemsUrl": "https://leetcode.cn/problems/bricks-falling-when-hit/",
        "solutionsUrl": "https://leetcode.cn/problems/bricks-falling-when-hit/solution",
        "problemsDesc": "<p>有一个 <code>m x n</code> 的二元网格<meta charset=\"UTF-8\" />&nbsp;<code>grid</code>&nbsp;，其中 <code>1</code> 表示砖块，<code>0</code> 表示空白。砖块 <strong>稳定</strong>（不会掉落）的前提是：</p>\n\n<ul>\n\t<li>一块砖直接连接到网格的顶部，或者</li>\n\t<li>至少有一块相邻（4&nbsp;个方向之一）砖块<strong> 稳定 </strong>不会掉落时</li>\n</ul>\n\n<p>给你一个数组 <code>hits</code> ，这是需要依次消除砖块的位置。每当消除&nbsp;<code>hits[i] = (rowi, coli)</code> 位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而 <strong>掉落</strong> 。一旦砖块掉落，它会 <strong>立即</strong> 从网格&nbsp;<code>grid</code>&nbsp;中消失（即，它不会落在其他稳定的砖块上）。</p>\n\n<p>返回一个数组 <code>result</code> ，其中 <code>result[i]</code> 表示第 <code>i</code> 次消除操作对应掉落的砖块数目。</p>\n\n<p><strong>注意</strong>，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]\n<strong>输出：</strong>[2]\n<strong>解释：</strong>网格开始为：\n[[1,0,0,0]，\n [<strong>1</strong>,1,1,0]]\n消除 (1,0) 处加粗的砖块，得到网格：\n[[1,0,0,0]\n [0,<strong>1</strong>,<strong>1</strong>,0]]\n两个加粗的砖不再稳定，因为它们不再与顶部相连，也不再与另一个稳定的砖相邻，因此它们将掉落。得到网格：\n[[1,0,0,0],\n [0,0,0,0]]\n因此，结果为 [2] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]\n<strong>输出：</strong>[0,0]\n<strong>解释：</strong>网格开始为：\n[[1,0,0,0],\n [1,<strong>1</strong>,0,0]]\n消除 (1,1) 处加粗的砖块，得到网格：\n[[1,0,0,0],\n [1,0,0,0]]\n剩下的砖都很稳定，所以不会掉落。网格保持不变：\n[[1,0,0,0], \n [<strong>1</strong>,0,0,0]]\n接下来消除 (1,0) 处加粗的砖块，得到网格：\n[[1,0,0,0],\n [0,0,0,0]]\n剩下的砖块仍然是稳定的，所以不会有砖块掉落。\n因此，结果为 [0,0] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n\t<li><code>1 &lt;= hits.length &lt;= 4 * 10<sup>4</sup></code></li>\n\t<li><code>hits[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i&nbsp;</sub>&lt;= m - 1</code></li>\n\t<li><code>0 &lt;=&nbsp;y<sub>i</sub> &lt;= n - 1</code></li>\n\t<li>所有 <code>(x<sub>i</sub>, y<sub>i</sub>)</code> 互不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 804.唯一摩尔斯密码词",
        "hardRate": "EASY",
        "passRate": "82.20%",
        "problemsUrl": "https://leetcode.cn/problems/unique-morse-code-words/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-morse-code-words/solution",
        "problemsDesc": "<p>国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串，&nbsp;比如:</p>\n\n<ul>\n\t<li><code>'a'</code> 对应 <code>\".-\"</code> ，</li>\n\t<li><code>'b'</code> 对应 <code>\"-...\"</code> ，</li>\n\t<li><code>'c'</code> 对应 <code>\"-.-.\"</code> ，以此类推。</li>\n</ul>\n\n<p>为了方便，所有 <code>26</code> 个英文字母的摩尔斯密码表如下：</p>\n\n<pre>\n[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]</pre>\n\n<p>给你一个字符串数组 <code>words</code> ，每个单词可以写成每个字母对应摩尔斯密码的组合。</p>\n\n<ul>\n\t<li>例如，<code>\"cab\"</code> 可以写成 <code>\"-.-..--...\"</code> ，(即 <code>\"-.-.\"</code> + <code>\".-\"</code> + <code>\"-...\"</code> 字符串的结合)。我们将这样一个连接过程称作 <strong>单词翻译</strong> 。</li>\n</ul>\n\n<p>对<strong> </strong><code>words</code> 中所有单词进行单词翻译，返回不同 <strong>单词翻译</strong> 的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> words = [\"gin\", \"zen\", \"gig\", \"msg\"]\n<strong>输出:</strong> 2\n<strong>解释: </strong>\n各单词翻译如下:\n\"gin\" -&gt; \"--...-.\"\n\"zen\" -&gt; \"--...-.\"\n\"gig\" -&gt; \"--...--.\"\n\"msg\" -&gt; \"--...--.\"\n\n共有 2 种不同翻译, \"--...-.\" 和 \"--...--.\".\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"a\"]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 12</code></li>\n\t<li><code>words[i]</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 805.数组的均值分割",
        "hardRate": "HARD",
        "passRate": "42.96%",
        "problemsUrl": "https://leetcode.cn/problems/split-array-with-same-average/",
        "solutionsUrl": "https://leetcode.cn/problems/split-array-with-same-average/solution",
        "problemsDesc": "<p>给定你一个整数数组<meta charset=\"UTF-8\" />&nbsp;<code>nums</code></p>\n\n<p>我们要将<meta charset=\"UTF-8\" />&nbsp;<code>nums</code>&nbsp;数组中的每个元素移动到&nbsp;<code>A</code>&nbsp;数组 或者&nbsp;<code>B</code>&nbsp;数组中，使得&nbsp;<code>A</code>&nbsp;数组和<meta charset=\"UTF-8\" />&nbsp;<code>B</code>&nbsp;数组不为空，并且<meta charset=\"UTF-8\" />&nbsp;<code>average(A) == average(B)</code>&nbsp;。</p>\n\n<p>如果可以完成则返回<code>true</code>&nbsp;， 否则返回 <code>false</code>&nbsp;&nbsp;。</p>\n\n<p><strong>注意：</strong>对于数组<meta charset=\"UTF-8\" />&nbsp;<code>arr</code>&nbsp;, <meta charset=\"UTF-8\" />&nbsp;<code>average(arr)</code>&nbsp;是<meta charset=\"UTF-8\" />&nbsp;<code>arr</code>&nbsp;的所有元素的和除以<meta charset=\"UTF-8\" />&nbsp;<code>arr</code>&nbsp;长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,3,4,5,6,7,8]\n<strong>输出:</strong> true\n<strong>解释: </strong>我们可以将数组分割为 [1,4,5,8] 和 [2,3,6,7], 他们的平均值都是4.5。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [3,1]\n<strong>输出:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 30</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 806.写字符串需要的行数",
        "hardRate": "EASY",
        "passRate": "68.41%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-lines-to-write-string/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-lines-to-write-string/solution",
        "problemsDesc": "<p>我们要把给定的字符串 <code>S</code>&nbsp;从左到右写到每一行上，每一行的最大宽度为100个单位，如果我们在写某个字母的时候会使这行超过了100 个单位，那么我们应该把这个字母写到下一行。我们给定了一个数组&nbsp;<code>widths</code>&nbsp;，这个数组&nbsp;widths[0] 代表 &#39;a&#39; 需要的单位，&nbsp;widths[1] 代表 &#39;b&#39; 需要的单位，...，&nbsp;widths[25] 代表 &#39;z&#39; 需要的单位。</p>\n\n<p>现在回答两个问题：至少多少行能放下<code>S</code>，以及最后一行使用的宽度是多少个单位？将你的答案作为长度为2的整数列表返回。</p>\n\n<pre>\n<strong>示例 1:</strong>\n<strong>输入:</strong> \nwidths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]\nS = &quot;abcdefghijklmnopqrstuvwxyz&quot;\n<strong>输出:</strong> [3, 60]\n<strong>解释: \n</strong>所有的字符拥有相同的占用单位10。所以书写所有的26个字母，\n我们需要2个整行和占用60个单位的一行。\n</pre>\n\n<pre>\n<strong>示例 2:</strong>\n<strong>输入:</strong> \nwidths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]\nS = &quot;bbbcccdddaaa&quot;\n<strong>输出:</strong> [2, 4]\n<strong>解释: \n</strong>除去字母&#39;a&#39;所有的字符都是相同的单位10，并且字符串 &quot;bbbcccdddaa&quot; 将会覆盖 9 * 10 + 2 * 4 = 98 个单位.\n最后一个字母 &#39;a&#39; 将会被写到第二行，因为第一行只剩下2个单位了。\n所以，这个答案是2行，第二行有4个单位宽度。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>注:</strong></p>\n\n<ul>\n\t<li>字符串&nbsp;<code>S</code> 的长度在&nbsp;[1, 1000] 的范围。</li>\n\t<li><code>S</code> 只包含小写字母。</li>\n\t<li><code>widths</code> 是长度为&nbsp;<code>26</code>的数组。</li>\n\t<li><code>widths[i]</code>&nbsp;值的范围在&nbsp;<code>[2, 10]</code>。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 807.保持城市天际线",
        "hardRate": "MEDIUM",
        "passRate": "88.08%",
        "problemsUrl": "https://leetcode.cn/problems/max-increase-to-keep-city-skyline/",
        "solutionsUrl": "https://leetcode.cn/problems/max-increase-to-keep-city-skyline/solution",
        "problemsDesc": "<p>给你一座由 <code>n x n</code> 个街区组成的城市，每个街区都包含一座立方体建筑。给你一个下标从 <strong>0</strong> 开始的 <code>n x n</code> 整数矩阵 <code>grid</code> ，其中 <code>grid[r][c]</code> 表示坐落于 <code>r</code> 行 <code>c</code> 列的建筑物的 <strong>高度</strong> 。</p>\n\n<p>城市的 <strong>天际线</strong> 是从远处观察城市时，所有建筑物形成的外部轮廓。从东、南、西、北四个主要方向观测到的 <strong>天际线</strong> 可能不同。</p>\n\n<p>我们被允许为 <strong>任意数量的建筑物 </strong>的高度增加<strong> 任意增量（不同建筑物的增量可能不同）</strong> 。 高度为 <code>0</code> 的建筑物的高度也可以增加。然而，增加的建筑物高度 <strong>不能影响</strong> 从任何主要方向观察城市得到的 <strong>天际线</strong> 。</p>\n\n<p>在 <strong>不改变</strong> 从任何主要方向观测到的城市 <strong>天际线</strong> 的前提下，返回建筑物可以增加的 <strong>最大高度增量总和</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/21/807-ex1.png\" style=\"width: 700px; height: 603px;\" />\n<pre>\n<strong>输入：</strong>grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]\n<strong>输出：</strong>35\n<strong>解释：</strong>建筑物的高度如上图中心所示。\n用红色绘制从不同方向观看得到的天际线。\n在不影响天际线的情况下，增加建筑物的高度：\ngridNew = [ [8, 4, 8, 7],\n            [7, 4, 7, 7],\n            [9, 4, 8, 7],\n            [3, 3, 3, 3] ]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,0,0],[0,0,0],[0,0,0]]\n<strong>输出：</strong>0\n<strong>解释：</strong>增加任何建筑物的高度都会导致天际线的变化。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[r].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 50</code></li>\n\t<li><code>0 &lt;= grid[r][c] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 808.分汤",
        "hardRate": "MEDIUM",
        "passRate": "58.77%",
        "problemsUrl": "https://leetcode.cn/problems/soup-servings/",
        "solutionsUrl": "https://leetcode.cn/problems/soup-servings/solution",
        "problemsDesc": "<p>有&nbsp;<strong>A&nbsp;和&nbsp;B 两种类型&nbsp;</strong>的汤。一开始每种类型的汤有&nbsp;<code>n</code>&nbsp;毫升。有四种分配操作：</p>\n\n<ol>\n\t<li>提供 <code>100ml</code> 的 <strong>汤A</strong> 和 <code>0ml</code> 的 <strong>汤B</strong> 。</li>\n\t<li>提供 <code>75ml</code> 的 <strong>汤A</strong> 和 <code>25ml</code> 的 <strong>汤B</strong> 。</li>\n\t<li>提供 <code>50ml</code> 的 <strong>汤A</strong> 和 <code>50ml</code> 的 <strong>汤B</strong> 。</li>\n\t<li>提供 <code>25ml</code> 的 <strong>汤A</strong> 和 <code>75ml</code> 的 <strong>汤B</strong> 。</li>\n</ol>\n\n<p>当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为 <code>0.25</code> 的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。</p>\n\n<p><strong>注意&nbsp;</strong>不存在先分配 <code>100</code> ml <strong>汤B</strong> 的操作。</p>\n\n<p>需要返回的值：&nbsp;<strong>汤A&nbsp;</strong>先分配完的概率 +&nbsp;&nbsp;<strong>汤A和汤B&nbsp;</strong>同时分配完的概率 / 2。返回值在正确答案&nbsp;<code>10<sup>-5</sup></code>&nbsp;的范围内将被认为是正确的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 50\n<strong>输出:</strong> 0.62500\n<strong>解释:</strong>如果我们选择前两个操作<strong>，</strong>A 首先将变为空。\n对于第三个操作，A 和 B 会同时变为空。\n对于第四个操作，B 首先将变为空。<strong>\n</strong>所以 A 变为空的总概率加上 A 和 B 同时变为空的概率的一半是 0.25 *(1 + 1 + 0.5 + 0)= 0.625。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 100\n<strong>输出:</strong> 0.71875\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code>​​​​​​​</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 809.情感丰富的文字",
        "hardRate": "MEDIUM",
        "passRate": "48.94%",
        "problemsUrl": "https://leetcode.cn/problems/expressive-words/",
        "solutionsUrl": "https://leetcode.cn/problems/expressive-words/solution",
        "problemsDesc": "<p>有时候人们会用重复写一些字母来表示额外的感受，比如 <code>\"hello\" -&gt; \"heeellooo\"</code>, <code>\"hi\" -&gt; \"hiii\"</code>。我们将相邻字母都相同的一串字符定义为相同字母组，例如：\"h\", \"eee\", \"ll\", \"ooo\"。</p>\n\n<p>对于一个给定的字符串 S ，如果另一个单词能够通过将一些字母组扩张从而使其和 S 相同，我们将这个单词定义为可扩张的（stretchy）。扩张操作定义如下：选择一个字母组（包含字母&nbsp;<code>c</code>&nbsp;），然后往其中添加相同的字母&nbsp;<code>c</code>&nbsp;使其长度达到 3 或以上。</p>\n\n<p>例如，以&nbsp;\"hello\" 为例，我们可以对字母组&nbsp;\"o\" 扩张得到 \"hellooo\"，但是无法以同样的方法得到 \"helloo\" 因为字母组 \"oo\" 长度小于&nbsp;3。此外，我们可以进行另一种扩张 \"ll\" -&gt; \"lllll\" 以获得&nbsp;\"helllllooo\"。如果&nbsp;<code>s = \"helllllooo\"</code>，那么查询词&nbsp;\"hello\" 是可扩张的，因为可以对它执行这两种扩张操作使得&nbsp;<code>query = \"hello\" -&gt; \"hellooo\" -&gt;&nbsp;\"helllllooo\" = s</code>。</p>\n\n<p>输入一组查询单词，输出其中可扩张的单词数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong> \ns = \"heeellooo\"\nwords = [\"hello\", \"hi\", \"helo\"]\n<strong>输出：</strong>1\n<strong>解释</strong>：\n我们能通过扩张 \"hello\" 的 \"e\" 和 \"o\" 来得到 \"heeellooo\"。\n我们不能通过扩张 \"helo\" 来得到 \"heeellooo\" 因为 \"ll\" 的长度小于 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size: 12.6px; background-color: rgb(249, 242, 244);\">s</span></font> 和所有在&nbsp;<code>words</code>&nbsp;中的单词都只由小写字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 810.黑板异或游戏",
        "hardRate": "HARD",
        "passRate": "72.54%",
        "problemsUrl": "https://leetcode.cn/problems/chalkboard-xor-game/",
        "solutionsUrl": "https://leetcode.cn/problems/chalkboard-xor-game/solution",
        "problemsDesc": "<p>黑板上写着一个非负整数数组 <code>nums[i]</code> 。</p>\n\n<p>Alice 和 Bob 轮流从黑板上擦掉一个数字，Alice 先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 <code>0</code> 的话，当前玩家游戏失败。&nbsp;另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为&nbsp;<code>0</code>。</p>\n\n<p>并且，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 <code>0</code> ，这个玩家获胜。</p>\n\n<p>假设两个玩家每步都使用最优解，当且仅当 Alice 获胜时返回 <code>true</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,1,2]\n<strong>输出:</strong> false\n<strong>解释:</strong> \nAlice 有两个选择: 擦掉数字 1 或 2。\n如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 = 3。那么 Bob 可以擦掉任意数字，因为 Alice 会成为擦掉最后一个数字的人，她总是会输。\n如果 Alice 擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 = 0。Alice 仍然会输掉游戏。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [0,1]\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,3]\n<strong>输出:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt; 2<sup>16</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 811.子域名访问计数",
        "hardRate": "MEDIUM",
        "passRate": "76.64%",
        "problemsUrl": "https://leetcode.cn/problems/subdomain-visit-count/",
        "solutionsUrl": "https://leetcode.cn/problems/subdomain-visit-count/solution",
        "problemsDesc": "<p>网站域名 <code>\"discuss.leetcode.com\"</code> 由多个子域名组成。顶级域名为 <code>\"com\"</code> ，二级域名为 <code>\"leetcode.com\"</code> ，最低一级为 <code>\"discuss.leetcode.com\"</code> 。当访问域名 <code>\"discuss.leetcode.com\"</code> 时，同时也会隐式访问其父域名 <code>\"leetcode.com\" </code>以及 <code>\"com\"</code> 。</p>\n\n<p><strong>计数配对域名</strong> 是遵循 <code>\"rep d1.d2.d3\"</code> 或 <code>\"rep d1.d2\"</code> 格式的一个域名表示，其中 <code>rep</code> 表示访问域名的次数，<code>d1.d2.d3</code> 为域名本身。</p>\n\n<ul>\n\t<li>例如，<code>\"9001 discuss.leetcode.com\"</code> 就是一个 <strong>计数配对域名</strong> ，表示 <code>discuss.leetcode.com</code> 被访问了 <code>9001</code> 次。</li>\n</ul>\n\n<p>给你一个<strong> 计数配对域名 </strong>组成的数组 <code>cpdomains</code> ，解析得到输入中每个子域名对应的&nbsp;<strong>计数配对域名</strong> ，并以数组形式返回。可以按 <strong>任意顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>cpdomains = [\"9001 discuss.leetcode.com\"]\n<strong>输出：</strong>[\"9001 leetcode.com\",\"9001 discuss.leetcode.com\",\"9001 com\"]\n<strong>解释：</strong>例子中仅包含一个网站域名：\"discuss.leetcode.com\"。\n按照前文描述，子域名 \"leetcode.com\" 和 \"com\" 都会被访问，所以它们都被访问了 9001 次。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>cpdomains = [\"900 google.mail.com\", \"50 yahoo.com\", \"1 intel.mail.com\", \"5 wiki.org\"]\n<strong>输出：</strong>[\"901 mail.com\",\"50 yahoo.com\",\"900 google.mail.com\",\"5 wiki.org\",\"5 org\",\"1 intel.mail.com\",\"951 com\"]\n<strong>解释：</strong>按照前文描述，会访问 \"google.mail.com\" 900 次，\"yahoo.com\" 50 次，\"intel.mail.com\" 1 次，\"wiki.org\" 5 次。\n而对于父域名，会访问 \"mail.com\" 900 + 1 = 901 次，\"com\" 900 + 50 + 1 = 951 次，和 \"org\" 5 次。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= cpdomain.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= cpdomain[i].length &lt;= 100</code></li>\n\t<li><code>cpdomain[i]</code> 会遵循 <code>\"rep<sub>i</sub> d1<sub>i</sub>.d2<sub>i</sub>.d3<sub>i</sub>\"</code> 或 <code>\"rep<sub>i</sub> d1<sub>i</sub>.d2<sub>i</sub>\"</code> 格式</li>\n\t<li><code>rep<sub>i</sub></code> 是范围 <code>[1, 10<sup>4</sup>]</code> 内的一个整数</li>\n\t<li><code>d1<sub>i</sub></code>、<code>d2<sub>i</sub></code> 和 <code>d3<sub>i</sub></code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 812.最大三角形面积",
        "hardRate": "EASY",
        "passRate": "68.21%",
        "problemsUrl": "https://leetcode.cn/problems/largest-triangle-area/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-triangle-area/solution",
        "problemsDesc": "<p>给你一个由 <strong>X-Y</strong> 平面上的点组成的数组 <code>points</code> ，其中 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 。从其中取任意三个不同的点组成三角形，返回能组成的最大三角形的面积。与真实值误差在 <code>10<sup>-5</sup></code> 内的答案将会视为正确答案<strong>。</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/04/1027.png\" style=\"height: 369px; width: 450px;\" />\n<pre>\n<strong>输入：</strong>points = [[0,0],[0,1],[1,0],[0,2],[2,0]]\n<strong>输出：</strong>2.00000\n<strong>解释：</strong>输入中的 5 个点如上图所示，红色的三角形面积最大。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[1,0],[0,0],[0,1]]\n<strong>输出：</strong>0.50000\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= points.length &lt;= 50</code></li>\n\t<li><code>-50 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 50</code></li>\n\t<li>给出的所有点 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 813.最大平均值和的分组",
        "hardRate": "MEDIUM",
        "passRate": "61.71%",
        "problemsUrl": "https://leetcode.cn/problems/largest-sum-of-averages/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-sum-of-averages/solution",
        "problemsDesc": "<p>给定数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。我们将给定的数组&nbsp;<code>nums</code>&nbsp;分成 <strong>最多</strong>&nbsp;<code>k</code>&nbsp;个相邻的非空子数组 。&nbsp;<strong>分数</strong> 由每个子数组内的平均值的总和构成。</p>\n\n<p>注意我们必须使用 <code>nums</code> 数组中的每一个数进行分组，并且分数不一定需要是整数。</p>\n\n<p>返回我们所能得到的最大 <strong>分数</strong> 是多少。答案误差在&nbsp;<code>10<sup>-6</sup></code>&nbsp;内被视为是正确的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [9,1,2,3,9], k = 3\n<strong>输出:</strong> 20.00000\n<strong>解释:</strong> \nnums 的最优分组是[9], [1, 2, 3], [9]. 得到的分数是 9 + (1 + 2 + 3) / 3 + 9 = 20. \n我们也可以把 nums 分成[9, 1], [2], [3, 9]. \n这样的分组得到的分数为 5 + 2 + 6 = 13, 但不是最大值.\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,3,4,5,6,7], k = 4\n<strong>输出:</strong> 20.50000\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 814.二叉树剪枝",
        "hardRate": "MEDIUM",
        "passRate": "72.55%",
        "problemsUrl": "https://leetcode.cn/problems/binary-tree-pruning/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-tree-pruning/solution",
        "problemsDesc": "<p>给你二叉树的根结点&nbsp;<code>root</code>&nbsp;，此外树的每个结点的值要么是 <code>0</code> ，要么是 <code>1</code> 。</p>\n\n<p>返回移除了所有不包含 <code>1</code> 的子树的原二叉树。</p>\n\n<p>节点 <code>node</code> 的子树为 <code>node</code> 本身加上所有 <code>node</code> 的后代。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_2.png\" style=\"width: 500px; height: 140px;\" />\n<pre>\n<strong>输入：</strong>root = [1,null,0,0,1]\n<strong>输出：</strong>[1,null,0,null,1]\n<strong>解释：</strong>\n只有红色节点满足条件“所有不包含 1 的子树”。 右图为返回的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_1.png\" style=\"width: 500px; height: 115px;\" />\n<pre>\n<strong>输入：</strong>root = [1,0,1,0,0,0,1]\n<strong>输出：</strong>[1,null,1,null,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/05/1028.png\" style=\"width: 500px; height: 134px;\" />\n<pre>\n<strong>输入：</strong>root = [1,1,0,1,1,0,1,0]\n<strong>输出：</strong>[1,1,0,1,1,null,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 200]</code> 内</li>\n\t<li><code>Node.val</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 815.公交路线",
        "hardRate": "HARD",
        "passRate": "44.42%",
        "problemsUrl": "https://leetcode.cn/problems/bus-routes/",
        "solutionsUrl": "https://leetcode.cn/problems/bus-routes/solution",
        "problemsDesc": "<p>给你一个数组 <code>routes</code> ，表示一系列公交线路，其中每个 <code>routes[i]</code> 表示一条公交线路，第 <code>i</code> 辆公交车将会在上面循环行驶。</p>\n\n<ul>\n\t<li>例如，路线 <code>routes[0] = [1, 5, 7]</code> 表示第 <code>0</code> 辆公交车会一直按序列 <code>1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ...</code> 这样的车站路线行驶。</li>\n</ul>\n\n<p>现在从 <code>source</code> 车站出发（初始时不在公交车上），要前往 <code>target</code> 车站。 期间仅可乘坐公交车。</p>\n\n<p>求出 <strong>最少乘坐的公交车数量</strong> 。如果不可能到达终点车站，返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>routes = [[1,2,7],[3,6,7]], source = 1, target = 6\n<strong>输出：</strong>2\n<strong>解释：</strong>最优策略是先乘坐第一辆公交车到达车站 7 , 然后换乘第二辆公交车到车站 6 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12\n<strong>输出：</strong>-1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= routes.length <= 500</code>.</li>\n\t<li><code>1 <= routes[i].length <= 10<sup>5</sup></code></li>\n\t<li><code>routes[i]</code> 中的所有值 <strong>互不相同</strong></li>\n\t<li><code>sum(routes[i].length) <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= routes[i][j] < 10<sup>6</sup></code></li>\n\t<li><code>0 <= source, target < 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 816.模糊坐标",
        "hardRate": "MEDIUM",
        "passRate": "62.59%",
        "problemsUrl": "https://leetcode.cn/problems/ambiguous-coordinates/",
        "solutionsUrl": "https://leetcode.cn/problems/ambiguous-coordinates/solution",
        "problemsDesc": "<p>我们有一些二维坐标，如&nbsp;<code>&quot;(1, 3)&quot;</code>&nbsp;或&nbsp;<code>&quot;(2, 0.5)&quot;</code>，然后我们移除所有逗号，小数点和空格，得到一个字符串<code>S</code>。返回所有可能的原始字符串到一个列表中。</p>\n\n<p>原始的坐标表示法不会存在多余的零，所以不会出现类似于&quot;00&quot;, &quot;0.0&quot;, &quot;0.00&quot;, &quot;1.0&quot;, &quot;001&quot;, &quot;00.01&quot;或一些其他更小的数来表示坐标。此外，一个小数点前至少存在一个数，所以也不会出现&ldquo;.1&rdquo;形式的数字。</p>\n\n<p>最后返回的列表可以是任意顺序的。而且注意返回的两个数字中间（逗号之后）都有一个空格。</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<strong>示例 1:</strong>\n<strong>输入:</strong> &quot;(123)&quot;\n<strong>输出:</strong> [&quot;(1, 23)&quot;, &quot;(12, 3)&quot;, &quot;(1.2, 3)&quot;, &quot;(1, 2.3)&quot;]\n</pre>\n\n<pre>\n<strong>示例 2:</strong>\n<strong>输入:</strong> &quot;(00011)&quot;\n<strong>输出:</strong> &nbsp;[&quot;(0.001, 1)&quot;, &quot;(0, 0.011)&quot;]\n<strong>解释:</strong> \n0.0, 00, 0001 或 00.01 是不被允许的。\n</pre>\n\n<pre>\n<strong>示例 3:</strong>\n<strong>输入:</strong> &quot;(0123)&quot;\n<strong>输出:</strong> [&quot;(0, 123)&quot;, &quot;(0, 12.3)&quot;, &quot;(0, 1.23)&quot;, &quot;(0.1, 23)&quot;, &quot;(0.1, 2.3)&quot;, &quot;(0.12, 3)&quot;]\n</pre>\n\n<pre>\n<strong>示例 4:</strong>\n<strong>输入:</strong> &quot;(100)&quot;\n<strong>输出:</strong> [(10, 0)]\n<strong>解释:</strong> \n1.0 是不被允许的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示: </strong></p>\n\n<ul>\n\t<li><code>4 &lt;= S.length &lt;= 12</code>.</li>\n\t<li><code>S[0]</code> = &quot;(&quot;, <code>S[S.length - 1]</code> = &quot;)&quot;, 且字符串&nbsp;<code>S</code>&nbsp;中的其他元素都是数字。</li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 817.链表组件",
        "hardRate": "MEDIUM",
        "passRate": "61.39%",
        "problemsUrl": "https://leetcode.cn/problems/linked-list-components/",
        "solutionsUrl": "https://leetcode.cn/problems/linked-list-components/solution",
        "problemsDesc": "<p>给定链表头结点&nbsp;<code>head</code>，该链表上的每个结点都有一个 <strong>唯一的整型值</strong> 。同时给定列表&nbsp;<code>nums</code>，该列表是上述链表中整型值的一个子集。</p>\n\n<p>返回列表&nbsp;<code>nums</code>&nbsp;中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表&nbsp;<code>nums</code>&nbsp;中）构成的集合。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/22/lc-linkedlistcom1.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> head = [0,1,2,3], nums = [0,1,3]\n<strong>输出:</strong> 2\n<strong>解释:</strong> 链表中,0 和 1 是相连接的，且 nums 中不包含 2，所以 [0, 1] 是 nums 的一个组件，同理 [3] 也是一个组件，故返回 2。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong>&nbsp;</strong><img src=\"https://assets.leetcode.com/uploads/2021/07/22/lc-linkedlistcom2.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> head = [0,1,2,3,4], nums = [0,3,1,4]\n<strong>输出:</strong> 2\n<strong>解释:</strong> 链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点数为<code>n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= Node.val &lt; n</code></li>\n\t<li><code>Node.val</code>&nbsp;中所有值 <strong>不同</strong></li>\n\t<li><code>1 &lt;= nums.length &lt;= n</code></li>\n\t<li><code>0 &lt;= nums[i] &lt; n</code></li>\n\t<li><code>nums</code> 中所有值 <strong>不同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 818.赛车",
        "hardRate": "HARD",
        "passRate": "44.83%",
        "problemsUrl": "https://leetcode.cn/problems/race-car/",
        "solutionsUrl": "https://leetcode.cn/problems/race-car/solution",
        "problemsDesc": "你的赛车可以从位置 <code>0</code> 开始，并且速度为 <code>+1</code> ，在一条无限长的数轴上行驶。赛车也可以向负方向行驶。赛车可以按照由加速指令 <code>'A'</code> 和倒车指令 <code>'R'</code> 组成的指令序列自动行驶。\n<ul>\n\t<li>当收到指令 <code>'A'</code> 时，赛车这样行驶：\n\t<ul>\n\t\t<li><code>position += speed</code></li>\n\t\t<li><code>speed *= 2</code></li>\n\t</ul>\n\t</li>\n\t<li>当收到指令 <code>'R'</code> 时，赛车这样行驶：\n\t<ul>\n\t\t<li>如果速度为正数，那么<code>speed = -1</code></li>\n\t\t<li>否则 <code>speed = 1</code></li>\n\t</ul>\n\t当前所处位置不变。</li>\n</ul>\n\n<p>例如，在执行指令 <code>\"AAR\"</code> 后，赛车位置变化为 <code>0 --&gt; 1 --&gt; 3 --&gt; 3</code> ，速度变化为 <code>1 --&gt; 2 --&gt; 4 --&gt; -1</code> 。</p>\n\n<p>给你一个目标位置 <code>target</code> ，返回能到达目标位置的最短指令序列的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>\n最短指令序列是 \"AA\" 。\n位置变化 0 --&gt; 1 --&gt; 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 6\n<strong>输出：</strong>5\n<strong>解释：</strong>\n最短指令序列是 \"AAARA\" 。\n位置变化 0 --&gt; 1 --&gt; 3 --&gt; 7 --&gt; 7 --&gt; 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 819.最常见的单词",
        "hardRate": "EASY",
        "passRate": "45.62%",
        "problemsUrl": "https://leetcode.cn/problems/most-common-word/",
        "solutionsUrl": "https://leetcode.cn/problems/most-common-word/solution",
        "problemsDesc": "<p>给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不在禁用列表中的单词。</p>\n\n<p>题目保证至少有一个词不在禁用列表中，而且答案唯一。</p>\n\n<p>禁用列表中的单词用小写字母表示，不含标点符号。段落中的单词不区分大小写。答案都是小写字母。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入:</strong> \nparagraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;\nbanned = [&quot;hit&quot;]\n<strong>输出:</strong> &quot;ball&quot;\n<strong>解释:</strong> \n&quot;hit&quot; 出现了3次，但它是一个禁用的单词。\n&quot;ball&quot; 出现了2次 (同时没有其他单词出现2次)，所以它是段落里出现次数最多的，且不在禁用列表中的单词。 \n注意，所有这些单词在段落里不区分大小写，标点符号需要忽略（即使是紧挨着单词也忽略， 比如 &quot;ball,&quot;）， \n&quot;hit&quot;不是最终的答案，虽然它出现次数更多，但它在禁用单词列表中。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= 段落长度 &lt;= 1000</code></li>\n\t<li><code>0 &lt;= 禁用单词个数 &lt;= 100</code></li>\n\t<li><code>1 &lt;= 禁用单词长度 &lt;= 10</code></li>\n\t<li>答案是唯一的, 且都是小写字母&nbsp;(即使在 <code>paragraph</code> 里是大写的，即使是一些特定的名词，答案都是小写的。)</li>\n\t<li><code>paragraph</code>&nbsp;只包含字母、空格和下列标点符号<code>!?&#39;,;.</code></li>\n\t<li>不存在没有连字符或者带有连字符的单词。</li>\n\t<li>单词里只包含字母，不会出现省略号或者其他标点符号。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 820.单词的压缩编码",
        "hardRate": "MEDIUM",
        "passRate": "52.08%",
        "problemsUrl": "https://leetcode.cn/problems/short-encoding-of-words/",
        "solutionsUrl": "https://leetcode.cn/problems/short-encoding-of-words/solution",
        "problemsDesc": "<p>单词数组 <code>words</code> 的 <strong>有效编码</strong> 由任意助记字符串 <code>s</code> 和下标数组 <code>indices</code> 组成，且满足：</p>\n\n<ul>\n\t<li><code>words.length == indices.length</code></li>\n\t<li>助记字符串 <code>s</code> 以 <code>'#'</code> 字符结尾</li>\n\t<li>对于每个下标 <code>indices[i]</code> ，<code>s</code> 的一个从 <code>indices[i]</code> 开始、到下一个 <code>'#'</code> 字符结束（但不包括 <code>'#'</code>）的 <strong>子字符串</strong> 恰好与 <code>words[i]</code> 相等</li>\n</ul>\n\n<p>给你一个单词数组 <code>words</code> ，返回成功对 <code>words</code> 进行编码的最小助记字符串 <code>s</code> 的长度 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"time\", \"me\", \"bell\"]\n<strong>输出：</strong>10\n<strong>解释：</strong>一组有效编码为 s = <code>\"time#bell#\" 和 indices = [0, 2, 5</code>] 。\nwords[0] = \"time\" ，s 开始于 indices[0] = 0 到下一个 '#' 结束的子字符串，如加粗部分所示 \"<strong>time</strong>#bell#\"\nwords[1] = \"me\" ，s 开始于 indices[1] = 2 到下一个 '#' 结束的子字符串，如加粗部分所示 \"ti<strong>me</strong>#bell#\"\nwords[2] = \"bell\" ，s 开始于 indices[2] = 5 到下一个 '#' 结束的子字符串，如加粗部分所示 \"time#<strong>bell</strong>#\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"t\"]\n<strong>输出：</strong>2\n<strong>解释：</strong>一组有效编码为 s = \"t#\" 和 indices = [0] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= words.length <= 2000</code></li>\n\t<li><code>1 <= words[i].length <= 7</code></li>\n\t<li><code>words[i]</code> 仅由小写字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 821.字符的最短距离",
        "hardRate": "EASY",
        "passRate": "72.87%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-distance-to-a-character/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-distance-to-a-character/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和一个字符 <code>c</code> ，且 <code>c</code> 是 <code>s</code> 中出现过的字符。</p>\n\n<p>返回一个整数数组 <code>answer</code> ，其中 <code>answer.length == s.length</code> 且 <code>answer[i]</code> 是 <code>s</code> 中从下标 <code>i</code> 到离它 <strong>最近</strong> 的字符 <code>c</code> 的 <strong>距离</strong> 。</p>\n\n<p>两个下标&nbsp;<code>i</code> 和 <code>j</code> 之间的 <strong>距离</strong> 为 <code>abs(i - j)</code> ，其中 <code>abs</code> 是绝对值函数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"loveleetcode\", c = \"e\"\n<strong>输出：</strong>[3,2,1,0,1,0,0,1,2,2,1,0]\n<strong>解释：</strong>字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aaab\", c = \"b\"\n<strong>输出：</strong>[3,2,1,0]\n</pre>\n\n<p>&nbsp;</p>\n<strong>提示：</strong>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s[i]</code> 和 <code>c</code> 均为小写英文字母</li>\n\t<li>题目数据保证 <code>c</code> 在 <code>s</code> 中至少出现一次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 822.翻转卡片游戏",
        "hardRate": "MEDIUM",
        "passRate": "51.67%",
        "problemsUrl": "https://leetcode.cn/problems/card-flipping-game/",
        "solutionsUrl": "https://leetcode.cn/problems/card-flipping-game/solution",
        "problemsDesc": "<p>在桌子上有 <code>N</code> 张卡片，每张卡片的正面和背面都写着一个正数（正面与背面上的数有可能不一样）。</p>\n\n<p>我们可以先翻转任意张卡片，然后选择其中一张卡片。</p>\n\n<p>如果选中的那张卡片背面的数字 <code>X</code> 与任意一张卡片的正面的数字都不同，那么这个数字是我们想要的数字。</p>\n\n<p>哪个数是这些想要的数字中最小的数（找到这些数中的最小值）呢？如果没有一个数字符合要求的，输出 0。</p>\n\n<p>其中, <code>fronts[i]</code>&nbsp;和&nbsp;<code>backs[i]</code>&nbsp;分别代表第&nbsp;<code>i</code>&nbsp;张卡片的正面和背面的数字。</p>\n\n<p>如果我们通过翻转卡片来交换正面与背面上的数，那么当初在正面的数就变成背面的数，背面的数就变成正面的数。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>fronts = [1,2,4,4,7], backs = [1,3,4,1,3]\n<strong>输出：</strong><code>2</code>\n<strong>解释：</strong>假设我们翻转第二张卡片，那么在正面的数变成了 <code>[1,3,4,4,7]</code> ， 背面的数变成了 <code>[1,2,4,1,3]。</code>\n接着我们选择第二张卡片，因为现在该卡片的背面的数是 2，2 与任意卡片上正面的数都不同，所以 2 就是我们想要的数字。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= fronts.length == backs.length&nbsp;&lt;=&nbsp;1000</code></li>\n\t<li><code>1 &lt;=&nbsp;fronts[i]&nbsp;&lt;= 2000</code></li>\n\t<li><code>1 &lt;= backs[i]&nbsp;&lt;= 2000</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 823.带因子的二叉树",
        "hardRate": "MEDIUM",
        "passRate": "43.46%",
        "problemsUrl": "https://leetcode.cn/problems/binary-trees-with-factors/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-trees-with-factors/solution",
        "problemsDesc": "<p>给出一个含有不重复整数元素的数组 <code>arr</code> ，每个整数 <code>arr[i]</code> 均大于 1。</p>\n\n<p>用这些整数来构建二叉树，每个整数可以使用任意次数。其中：每个非叶结点的值应等于它的两个子结点的值的乘积。</p>\n\n<p>满足条件的二叉树一共有多少个？答案可能很大，返回<strong> 对 </strong><code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>arr = [2, 4]</code>\n<strong>输出:</strong> 3\n<strong>解释:</strong> 可以得到这些二叉树: <code>[2], [4], [4, 2, 2]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>arr = [2, 4, 5, 10]</code>\n<strong>输出:</strong> <code>7</code>\n<strong>解释:</strong> 可以得到这些二叉树: <code>[2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2]</code>.</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>2 &lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>arr</code> 中的所有值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 824.山羊拉丁文",
        "hardRate": "EASY",
        "passRate": "65.09%",
        "problemsUrl": "https://leetcode.cn/problems/goat-latin/",
        "solutionsUrl": "https://leetcode.cn/problems/goat-latin/solution",
        "problemsDesc": "<p>给你一个由若干单词组成的句子&nbsp;<code>sentence</code> ，单词间由空格分隔。每个单词仅由大写和小写英文字母组成。</p>\n\n<p>请你将句子转换为 <em>“</em>山羊拉丁文（<em>Goat Latin</em>）<em>”</em>（一种类似于 猪拉丁文&nbsp;- Pig Latin 的虚构语言）。山羊拉丁文的规则如下：</p>\n\n<ul>\n\t<li>如果单词以元音开头（<code>'a'</code>, <code>'e'</code>, <code>'i'</code>, <code>'o'</code>, <code>'u'</code>），在单词后添加<code>\"ma\"</code>。\n\n\t<ul>\n\t\t<li>例如，单词 <code>\"apple\"</code> 变为 <code>\"applema\"</code> 。</li>\n\t</ul>\n\t</li>\n\t<li>如果单词以辅音字母开头（即，非元音字母），移除第一个字符并将它放到末尾，之后再添加<code>\"ma\"</code>。\n\t<ul>\n\t\t<li>例如，单词 <code>\"goat\"</code> 变为 <code>\"oatgma\"</code> 。</li>\n\t</ul>\n\t</li>\n\t<li>根据单词在句子中的索引，在单词最后添加与索引相同数量的字母<code>'a'</code>，索引从 <code>1</code> 开始。\n\t<ul>\n\t\t<li>例如，在第一个单词后添加 <code>\"a\"</code> ，在第二个单词后添加 <code>\"aa\"</code> ，以此类推。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>返回将 <code>sentence</code> 转换为山羊拉丁文后的句子。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"I speak Goat Latin\"\n<strong>输出：</strong>\"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"The quick brown fox jumped over the lazy dog\"\n<strong>输出：</strong>\"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentence.length &lt;= 150</code></li>\n\t<li><code>sentence</code> 由英文字母和空格组成</li>\n\t<li><code>sentence</code> 不含前导或尾随空格</li>\n\t<li><code>sentence</code> 中的所有单词由单个空格分隔</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 825.适龄的朋友",
        "hardRate": "MEDIUM",
        "passRate": "45.40%",
        "problemsUrl": "https://leetcode.cn/problems/friends-of-appropriate-ages/",
        "solutionsUrl": "https://leetcode.cn/problems/friends-of-appropriate-ages/solution",
        "problemsDesc": "<p>在社交媒体网站上有 <code>n</code> 个用户。给你一个整数数组 <code>ages</code> ，其中 <code>ages[i]</code> 是第 <code>i</code> 个用户的年龄。</p>\n\n<p>如果下述任意一个条件为真，那么用户 <code>x</code> 将不会向用户 <code>y</code>（<code>x != y</code>）发送好友请求：</p>\n\n<ul>\n\t<li><code>ages[y] &lt;= 0.5 * ages[x] + 7</code></li>\n\t<li><code>ages[y] &gt; ages[x]</code></li>\n\t<li><code>ages[y] &gt; 100 &amp;&amp; ages[x] &lt; 100</code></li>\n</ul>\n\n<p>否则，<code>x</code> 将会向 <code>y</code> 发送一条好友请求。</p>\n\n<p>注意，如果 <code>x</code> 向 <code>y</code> 发送一条好友请求，<code>y</code> 不必也向 <code>x</code> 发送一条好友请求。另外，用户不会向自己发送好友请求。</p>\n\n<p>返回在该社交媒体网站上产生的好友请求总数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>ages = [16,16]\n<strong>输出：</strong>2\n<strong>解释：</strong>2 人互发好友请求。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>ages = [16,17,18]\n<strong>输出：</strong>2\n<strong>解释：</strong>产生的好友请求为 17 -&gt; 16 ，18 -&gt; 17 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>ages = [20,30,100,110,120]\n<strong>输出：</strong>3\n<strong>解释：</strong>产生的好友请求为 110 -&gt; 100 ，120 -&gt; 110 ，120 -&gt; 100 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == ages.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= ages[i] &lt;= 120</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 826.安排工作以达到最大收益",
        "hardRate": "MEDIUM",
        "passRate": "42.57%",
        "problemsUrl": "https://leetcode.cn/problems/most-profit-assigning-work/",
        "solutionsUrl": "https://leetcode.cn/problems/most-profit-assigning-work/solution",
        "problemsDesc": "<p>你有 <code>n</code>&nbsp;个工作和 <code>m</code> 个工人。给定三个数组：&nbsp;<code>difficulty</code>,&nbsp;<code>profit</code>&nbsp;和&nbsp;<code>worker</code>&nbsp;，其中:</p>\n\n<ul>\n\t<li><code>difficulty[i]</code>&nbsp;表示第 <code>i</code> 个工作的难度，<code>profit[i]</code> 表示第 <code>i</code> 个工作的收益。</li>\n\t<li><code>worker[i]</code> 是第 <code>i</code> 个工人的能力，即该工人只能完成难度小于等于 <code>worker[i]</code> 的工作。</li>\n</ul>\n\n<p>每个工人&nbsp;<strong>最多</strong> 只能安排 <strong>一个</strong> 工作，但是一个工作可以 <strong>完成多次</strong> 。</p>\n\n<ul>\n\t<li>举个例子，如果 3 个工人都尝试完成一份报酬为 <code>$1</code> 的同样工作，那么总收益为 <code>$3</code>&nbsp;。如果一个工人不能完成任何工作，他的收益为 <code>$0</code> 。</li>\n</ul>\n\n<p>返回 <em>在把工人分配到工作岗位后，我们所能获得的最大利润&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]\n<strong>输出: </strong>100 \n<strong>解释: </strong>工人被分配的工作难度是 [4,4,6,6] ，分别获得 [20,20,30,30] 的收益。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]\n<strong>输出:</strong> 0</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>n == difficulty.length</code></li>\n\t<li><code>n == profit.length</code></li>\n\t<li><code>m == worker.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= difficulty[i], profit[i], worker[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 827.最大人工岛",
        "hardRate": "HARD",
        "passRate": "47.10%",
        "problemsUrl": "https://leetcode.cn/problems/making-a-large-island/",
        "solutionsUrl": "https://leetcode.cn/problems/making-a-large-island/solution",
        "problemsDesc": "<p>给你一个大小为 <code>n x n</code> 二进制矩阵 <code>grid</code> 。<strong>最多</strong> 只能将一格 <code>0</code> 变成 <code>1</code> 。</p>\n\n<p>返回执行此操作后，<code>grid</code> 中最大的岛屿面积是多少？</p>\n\n<p><strong>岛屿</strong> 由一组上、下、左、右四个方向相连的 <code>1</code> 形成。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>grid = [[1, 0], [0, 1]]\n<strong>输出:</strong> 3\n<strong>解释:</strong> 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>grid =<strong> </strong>[[1, 1], [1, 0]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> 将一格0变成1，岛屿的面积扩大为 4。</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入: </strong>grid = [[1, 1], [1, 1]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> 没有0可以让我们变成1，面积依然为 4。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 <= n <= 500</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 828.统计子串中的唯一字符",
        "hardRate": "HARD",
        "passRate": "65.60%",
        "problemsUrl": "https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/",
        "solutionsUrl": "https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/solution",
        "problemsDesc": "<p>我们定义了一个函数 <code>countUniqueChars(s)</code> 来统计字符串 <code>s</code> 中的唯一字符，并返回唯一字符的个数。</p>\n\n<p>例如：<code>s = \"LEETCODE\"</code> ，则其中 <code>\"L\"</code>, <code>\"T\"</code>,<code>\"C\"</code>,<code>\"O\"</code>,<code>\"D\"</code> 都是唯一字符，因为它们只出现一次，所以 <code>countUniqueChars(s) = 5</code> 。</p>\n\n<p>本题将会给你一个字符串 <code>s</code> ，我们需要返回 <code>countUniqueChars(t)</code> 的总和，其中 <code>t</code> 是 <code>s</code> 的子字符串。输入用例保证返回值为&nbsp;32 位整数。</p>\n\n<p>注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 <code>s</code> 的所有子字符串中的唯一字符）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"ABC\"\n<strong>输出: </strong>10\n<strong>解释:</strong> 所有可能的子串为：\"A\",\"B\",\"C\",\"AB\",\"BC\" 和 \"ABC\"。\n     其中，每一个子串都由独特字符构成。\n     所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"ABA\"\n<strong>输出: </strong>8\n<strong>解释: </strong>除<code>了 countUniqueChars</code>(\"ABA\") = 1 之外，其余与示例 1 相同。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"LEETCODE\"\n<strong>输出：</strong>92\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>s</code> 只包含大写英文字符</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 829.连续整数求和",
        "hardRate": "HARD",
        "passRate": "46.25%",
        "problemsUrl": "https://leetcode.cn/problems/consecutive-numbers-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/consecutive-numbers-sum/solution",
        "problemsDesc": "<p>给定一个正整数 <code>n</code>，返回 <em>连续正整数满足所有数字之和为 <code>n</code>&nbsp;的组数</em> 。&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示</strong><strong>例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>n = 5\n<strong>输出: </strong>2\n<strong>解释: </strong>5 = 2 + 3，共有两组连续整数([5],[2,3])求和后为 5。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>n = 9\n<strong>输出: </strong>3\n<strong>解释: </strong>9 = 4 + 5 = 2 + 3 + 4</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入: </strong>n = 15\n<strong>输出: </strong>4\n<strong>解释: </strong>15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code>​​​​​​​</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 830.较大分组的位置",
        "hardRate": "EASY",
        "passRate": "54.10%",
        "problemsUrl": "https://leetcode.cn/problems/positions-of-large-groups/",
        "solutionsUrl": "https://leetcode.cn/problems/positions-of-large-groups/solution",
        "problemsDesc": "<p>在一个由小写字母构成的字符串 <code>s</code> 中，包含由一些连续的相同字符所构成的分组。</p>\n\n<p>例如，在字符串 <code>s = \"abbxxxxzyy\"</code> 中，就含有 <code>\"a\"</code>, <code>\"bb\"</code>, <code>\"xxxx\"</code>, <code>\"z\"</code> 和 <code>\"yy\"</code> 这样的一些分组。</p>\n\n<p>分组可以用区间 <code>[start, end]</code> 表示，其中 <code>start</code> 和 <code>end</code> 分别表示该分组的起始和终止位置的下标。上例中的 <code>\"xxxx\"</code> 分组用区间表示为 <code>[3,6]</code> 。</p>\n\n<p>我们称所有包含大于或等于三个连续字符的分组为 <strong>较大分组</strong> 。</p>\n\n<p>找到每一个 <strong>较大分组</strong> 的区间，<strong>按起始位置下标递增顺序排序后</strong>，返回结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abbxxxxzzy\"\n<strong>输出：</strong>[[3,6]]\n<strong>解释</strong><strong>：</strong><code>\"xxxx\" 是一个起始于 3 且终止于 6 的较大分组</code>。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\"\n<strong>输出：</strong>[]\n<strong>解释：</strong>\"a\",\"b\" 和 \"c\" 均不是符合要求的较大分组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcdddeeeeaabbbcd\"\n<strong>输出：</strong>[[3,5],[6,9],[12,14]]\n<strong>解释：</strong>较大分组为 \"ddd\", \"eeee\" 和 \"bbb\"</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aba\"\n<strong>输出：</strong>[]\n</pre>\n \n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 1000</code></li>\n\t<li><code>s</code> 仅含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 831.隐藏个人信息",
        "hardRate": "MEDIUM",
        "passRate": "53.78%",
        "problemsUrl": "https://leetcode.cn/problems/masking-personal-information/",
        "solutionsUrl": "https://leetcode.cn/problems/masking-personal-information/solution",
        "problemsDesc": "<p>给你一条个人信息字符串 <code>s</code> ，可能表示一个 <strong>邮箱地址</strong> ，也可能表示一串 <strong>电话号码</strong> 。返回按如下规则 <strong>隐藏</strong> 个人信息后的结果：</p>\n\n<p><em><strong>电子邮件地址：</strong></em></p>\n\n<p>一个电子邮件地址由以下部分组成：</p>\n\n<ul>\n\t<li>一个 <strong>名字</strong> ，由大小写英文字母组成，后面跟着</li>\n\t<li>一个 <code>'@'</code> 字符，后面跟着</li>\n\t<li>一个 <strong>域名</strong> ，由大小写英文字母和一个位于中间的 <code>'.'</code> 字符组成。<code>'.'</code> 不会是域名的第一个或者最后一个字符。</li>\n</ul>\n\n<p>要想隐藏电子邮件地址中的个人信息：</p>\n\n<ul>\n\t<li><strong>名字</strong> 和 <strong>域名</strong> 部分的大写英文字母应当转换成小写英文字母。</li>\n\t<li><strong>名字</strong> 中间的字母（即，除第一个和最后一个字母外）必须用 5 个 <code>\"*****\"</code> 替换。</li>\n</ul>\n\n<p><em><strong>电话号码：</strong></em></p>\n\n<p>一个电话号码应当按下述格式组成：</p>\n\n<ul>\n\t<li>电话号码可以由 10-13 位数字组成</li>\n\t<li>后 10 位构成 <strong>本地号码</strong></li>\n\t<li>前面剩下的 0-3 位，构成 <strong>国家代码</strong></li>\n\t<li>利用 <code>{'+', '-', '(', ')', ' '}</code> 这些 <strong>分隔字符</strong> 按某种形式对上述数字进行分隔</li>\n</ul>\n\n<p>要想隐藏电话号码中的个人信息：</p>\n\n<ul>\n\t<li>移除所有 <strong>分隔字符</strong></li>\n\t<li>隐藏个人信息后的电话号码应该遵从这种格式：\n\t<ul>\n\t\t<li><code>\"***-***-XXXX\"</code> 如果国家代码为 0 位数字</li>\n\t\t<li><code>\"+*-***-***-XXXX\"</code> 如果国家代码为 1 位数字</li>\n\t\t<li><code>\"+**-***-***-XXXX\"</code> 如果国家代码为 2 位数字</li>\n\t\t<li><code>\"+***-***-***-XXXX\"</code> 如果国家代码为 3 位数字</li>\n\t</ul>\n\t</li>\n\t<li><code>\"XXXX\"</code> 是最后 4 位 <strong>本地号码</strong></li>\n</ul>\n&nbsp;\n\n<div class=\"top-view__1vxA\">\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"LeetCode@LeetCode.com\"\n<strong>输出：</strong>\"l*****e@leetcode.com\"\n<strong>解释：</strong>s 是一个电子邮件地址。\n名字和域名都转换为小写，名字的中间用 5 个 * 替换。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"AB@qq.com\"\n<strong>输出：</strong>\"a*****b@qq.com\"\n<strong>解释：</strong>s 是一个电子邮件地址。\n名字和域名都转换为小写，名字的中间用 5 个 * 替换。\n注意，尽管 \"ab\" 只有两个字符，但中间仍然必须有 5 个 * 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1(234)567-890\"\n<strong>输出：</strong>\"***-***-7890\"\n<strong>解释：</strong>s 是一个电话号码。\n共计 10 位数字，所以本地号码为 10 位数字，国家代码为 0 位数字。\n因此，隐藏后的电话号码应该是 \"***-***-7890\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s</code> 是一个 <strong>有效</strong> 的电子邮件或者电话号码</li>\n\t<li>如果 <code>s</code> 是一个电子邮件：\n\t<ul>\n\t\t<li><code>8 &lt;= s.length &lt;= 40</code></li>\n\t\t<li><code>s</code> 是由大小写英文字母，恰好一个 <code>'@'</code> 字符，以及 <code>'.'</code> 字符组成</li>\n\t</ul>\n\t</li>\n\t<li>如果 <code>s</code> 是一个电话号码：\n\t<ul>\n\t\t<li><code>10 &lt;= s.length &lt;= 20</code></li>\n\t\t<li><code>s</code> 是由数字、空格、字符 <code>'('</code>、<code>')'</code>、<code>'-'</code> 和 <code>'+'</code> 组成</li>\n\t</ul>\n\t</li>\n</ul>\n</div>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 832.翻转图像",
        "hardRate": "EASY",
        "passRate": "79.47%",
        "problemsUrl": "https://leetcode.cn/problems/flipping-an-image/",
        "solutionsUrl": "https://leetcode.cn/problems/flipping-an-image/solution",
        "problemsDesc": "<p>给定一个<meta charset=\"UTF-8\" />&nbsp;<code>n x n</code>&nbsp;的二进制矩阵&nbsp;<code>image</code>&nbsp;，先 <strong>水平</strong> 翻转图像，然后&nbsp;<strong>反转&nbsp;</strong>图像并返回&nbsp;<em>结果</em>&nbsp;。</p>\n\n<p><strong>水平</strong>翻转图片就是将图片的每一行都进行翻转，即逆序。</p>\n\n<ul>\n\t<li>例如，水平翻转&nbsp;<code>[1,1,0]</code>&nbsp;的结果是&nbsp;<code>[0,1,1]</code>。</li>\n</ul>\n\n<p><strong>反转</strong>图片的意思是图片中的&nbsp;<code>0</code>&nbsp;全部被&nbsp;<code>1</code>&nbsp;替换，&nbsp;<code>1</code>&nbsp;全部被&nbsp;<code>0</code>&nbsp;替换。</p>\n\n<ul>\n\t<li>例如，反转&nbsp;<code>[0,1,1]</code>&nbsp;的结果是&nbsp;<code>[1,0,0]</code>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>image = [[1,1,0],[1,0,1],[0,0,0]]\n<strong>输出：</strong>[[1,0,0],[0,1,0],[1,1,1]]\n<strong>解释：</strong>首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；\n     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\n<strong>输出：</strong>[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n<strong>解释：</strong>首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；\n     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>n == image.length</code></li>\n\t<li><code>n == image[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>images[i][j]</code>&nbsp;==&nbsp;<code>0</code>&nbsp;或&nbsp;<code>1</code>.</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 833.字符串中的查找与替换",
        "hardRate": "MEDIUM",
        "passRate": "43.99%",
        "problemsUrl": "https://leetcode.cn/problems/find-and-replace-in-string/",
        "solutionsUrl": "https://leetcode.cn/problems/find-and-replace-in-string/solution",
        "problemsDesc": "<p>你会得到一个字符串 <code>s</code>&nbsp;(索引从 0 开始)，你必须对它执行 <code>k</code> 个替换操作。替换操作以三个长度均为 <code>k</code> 的并行数组给出：<code>indices</code>,&nbsp;<code>sources</code>,&nbsp;&nbsp;<code>targets</code>。</p>\n\n<p>要完成第 <code>i</code> 个替换操作:</p>\n\n<ol>\n\t<li>检查 <strong>子字符串</strong> &nbsp;<code>sources[i]</code>&nbsp;是否出现在 <strong>原字符串</strong> <code>s</code> 的索引&nbsp;<code>indices[i]</code>&nbsp;处。</li>\n\t<li>如果没有出现，&nbsp;<strong>什么也不做</strong>&nbsp;。</li>\n\t<li>如果出现，则用&nbsp;<code>targets[i]</code>&nbsp;<strong>替换</strong>&nbsp;该子字符串。</li>\n</ol>\n\n<p>例如，如果 <code>s = \"abcd\"</code>&nbsp;，&nbsp;<code>indices[i] = 0</code> ,&nbsp;<code>sources[i] = \"ab\"</code>， <code>targets[i] = \"eee\"</code> ，那么替换的结果将是 <code>\"<u>eee</u>cd\"</code> 。</p>\n\n<p>所有替换操作必须 <strong>同时</strong> 发生，这意味着替换操作不应该影响彼此的索引。测试用例保证元素间<strong>不会重叠 </strong>。</p>\n\n<ul>\n\t<li>例如，一个 <code>s = \"abc\"</code> ，&nbsp; <code>indices = [0,1]</code> ， <code>sources = [\"ab\"，\"bc\"]</code>&nbsp;的测试用例将不会生成，因为 <code>\"ab\"</code> 和 <code>\"bc\"</code> 替换重叠。</li>\n</ul>\n\n<p><em>在对 <code>s</code>&nbsp;执行所有替换操作后返回 <strong>结果字符串</strong> 。</em></p>\n\n<p><strong>子字符串</strong> 是字符串中连续的字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/12/833-ex1.png\" style=\"height: 251px; width: 411px;\" /></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\", indexes = [0,2], sources = [\"a\",\"cd\"], targets = [\"eee\",\"ffff\"]\n<strong>输出：</strong>\"eeebffff\"\n<strong>解释：\n</strong>\"a\" 从 s 中的索引 0 开始，所以它被替换为 \"eee\"。\n\"cd\" 从 s 中的索引 2 开始，所以它被替换为 \"ffff\"。\n</pre>\n\n<p><strong>示例 2：</strong><img src=\"https://assets.leetcode.com/uploads/2021/06/12/833-ex2-1.png\" style=\"height: 251px; width: 411px;\" /></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\", indexes = [0,2], sources = [\"ab\",\"ec\"], targets = [\"eee\",\"ffff\"]\n<strong>输出：</strong>\"eeecd\"\n<strong>解释：\n</strong>\"ab\" 从 s 中的索引 0 开始，所以它被替换为 \"eee\"。\n\"ec\" 没有从<strong>原始的</strong> S 中的索引 2 开始，所以它没有被替换。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>k == indices.length == sources.length == targets.length</code></li>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n\t<li><code>0 &lt;= indexes[i] &lt; s.length</code></li>\n\t<li><code>1 &lt;= sources[i].length, targets[i].length &lt;= 50</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n\t<li><code>sources[i]</code> 和 <code>targets[i]</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 834.树中距离之和",
        "hardRate": "HARD",
        "passRate": "54.43%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-distances-in-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-distances-in-tree/solution",
        "problemsDesc": "<p>给定一个无向、连通的树。树中有 <code>n</code> 个标记为 <code>0...n-1</code> 的节点以及 <code>n-1</code>&nbsp;条边&nbsp;。</p>\n\n<p>给定整数 <code>n</code> 和数组&nbsp;<code>edges</code>&nbsp;，&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>表示树中的节点&nbsp;<code>a<sub>i</sub></code>&nbsp;和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条边。</p>\n\n<p>返回长度为 <code>n</code> 的数组&nbsp;<code>answer</code>&nbsp;，其中&nbsp;<code>answer[i]</code>&nbsp;是树中第 <code>i</code> 个节点与所有其他节点之间的距离之和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-sumdist1.jpg\" /></p>\n\n<pre>\n<strong>输入: </strong>n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]\n<strong>输出: </strong>[8,12,6,10,10,10]\n<strong>解释: </strong>树如图所示。\n我们可以计算出 dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) \n也就是 1 + 1 + 2 + 2 + 2 = 8。 因此，answer[0] = 8，以此类推。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-sumdist2.jpg\" />\n<pre>\n<strong>输入:</strong> n = 1, edges = []\n<strong>输出:</strong> [0]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-sumdist3.jpg\" />\n<pre>\n<strong>输入:</strong> n = 2, edges = [[1,0]]\n<strong>输出:</strong> [1,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub>&nbsp;&lt; n</code></li>\n\t<li><code>a<sub>i</sub>&nbsp;!= b<sub>i</sub></code></li>\n\t<li>给定的输入保证为有效的树</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 835.图像重叠",
        "hardRate": "MEDIUM",
        "passRate": "58.26%",
        "problemsUrl": "https://leetcode.cn/problems/image-overlap/",
        "solutionsUrl": "https://leetcode.cn/problems/image-overlap/solution",
        "problemsDesc": "<p>给你两个图像 <code>img1</code> 和 <code>img2</code> ，两个图像的大小都是 <code>n x n</code> ，用大小相同的二进制正方形矩阵表示。二进制矩阵仅由若干 <code>0</code> 和若干 <code>1</code> 组成。</p>\n\n<p><strong>转换</strong> 其中一个图像，将所有的 <code>1</code> 向左，右，上，或下滑动任何数量的单位；然后把它放在另一个图像的上面。该转换的 <strong>重叠</strong> 是指两个图像 <strong>都</strong> 具有 <code>1</code> 的位置的数目。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>请注意，转换 <strong>不包括</strong> 向任何方向旋转。越过矩阵边界的 <code>1</code> 都将被清除。</p>\n\n<p>最大可能的重叠数量是多少？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/overlap1.jpg\" style=\"width: 450px; height: 231px;\" />\n<pre>\n<strong>输入：</strong>img1 = [[1,1,0],[0,1,0],[0,1,0]], img2 = [[0,0,0],[0,1,1],[0,0,1]]\n<strong>输出：</strong>3\n<strong>解释：</strong>将 img1 向右移动 1 个单位，再向下移动 1 个单位。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/overlap_step1.jpg\" style=\"width: 450px; height: 105px;\" />\n两个图像都具有 <code>1</code> 的位置的数目是 3（用红色标识）。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/overlap_step2.jpg\" style=\"width: 450px; height: 231px;\" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>img1 = [[1]], img2 = [[1]]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>img1 = [[0]], img2 = [[0]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == img1.length == img1[i].length</code></li>\n\t<li><code>n == img2.length == img2[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n\t<li><code>img1[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n\t<li><code>img2[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 836.矩形重叠",
        "hardRate": "EASY",
        "passRate": "49.01%",
        "problemsUrl": "https://leetcode.cn/problems/rectangle-overlap/",
        "solutionsUrl": "https://leetcode.cn/problems/rectangle-overlap/solution",
        "problemsDesc": "<p>矩形以列表 <code>[x1, y1, x2, y2]</code> 的形式表示，其中 <code>(x1, y1)</code> 为左下角的坐标，<code>(x2, y2)</code> 是右上角的坐标。矩形的上下边平行于 x 轴，左右边平行于 y 轴。</p>\n\n<p>如果相交的面积为 <strong>正</strong> ，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</p>\n\n<p>给出两个矩形 <code>rec1</code> 和 <code>rec2</code> 。如果它们重叠，返回 <code>true</code>；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rec1 = [0,0,2,2], rec2 = [1,1,3,3]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rec1 = [0,0,1,1], rec2 = [1,0,2,1]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>rec1 = [0,0,1,1], rec2 = [2,2,3,3]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rect1.length == 4</code></li>\n\t<li><code>rect2.length == 4</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= rec1[i], rec2[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>rec1</code> 和 <code>rec2</code> 表示一个面积不为零的有效矩形</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 837.新 21 点",
        "hardRate": "MEDIUM",
        "passRate": "39.75%",
        "problemsUrl": "https://leetcode.cn/problems/new-21-game/",
        "solutionsUrl": "https://leetcode.cn/problems/new-21-game/solution",
        "problemsDesc": "<p>爱丽丝参与一个大致基于纸牌游戏 <strong>“21点”</strong> 规则的游戏，描述如下：</p>\n\n<p>爱丽丝以 <code>0</code> 分开始，并在她的得分少于 <code>k</code> 分时抽取数字。 抽取时，她从 <code>[1, maxPts]</code> 的范围中随机获得一个整数作为分数进行累计，其中 <code>maxPts</code> 是一个整数。 每次抽取都是独立的，其结果具有相同的概率。</p>\n\n<p>当爱丽丝获得 <code>k</code> 分 <strong>或更多分</strong> 时，她就停止抽取数字。</p>\n\n<p>爱丽丝的分数不超过 <code>n</code> 的概率是多少？</p>\n\n<p>与实际答案误差不超过&nbsp;<code>10<sup>-5</sup></code> 的答案将被视为正确答案。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10, k = 1, maxPts = 10\n<strong>输出：</strong>1.00000\n<strong>解释：</strong>爱丽丝得到一张牌，然后停止。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6, k = 1, maxPts = 10\n<strong>输出：</strong>0.60000\n<strong>解释：</strong>爱丽丝得到一张牌，然后停止。 在 10 种可能性中的 6 种情况下，她的得分不超过 6 分。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 21, k = 17, maxPts = 10\n<strong>输出：</strong>0.73278\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= k &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= maxPts &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 838.推多米诺",
        "hardRate": "MEDIUM",
        "passRate": "55.65%",
        "problemsUrl": "https://leetcode.cn/problems/push-dominoes/",
        "solutionsUrl": "https://leetcode.cn/problems/push-dominoes/solution",
        "problemsDesc": "<p><code>n</code> 张多米诺骨牌排成一行，将每张多米诺骨牌垂直竖立。在开始时，同时把一些多米诺骨牌向左或向右推。</p>\n\n<p>每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。</p>\n\n<p>如果一张垂直竖立的多米诺骨牌的两侧同时有多米诺骨牌倒下时，由于受力平衡， 该骨牌仍然保持不变。</p>\n\n<p>就这个问题而言，我们会认为一张正在倒下的多米诺骨牌不会对其它正在倒下或已经倒下的多米诺骨牌施加额外的力。</p>\n\n<p>给你一个字符串 <code>dominoes</code> 表示这一行多米诺骨牌的初始状态，其中：</p>\n\n<ul>\n\t<li><code>dominoes[i] = 'L'</code>，表示第 <code>i</code> 张多米诺骨牌被推向左侧，</li>\n\t<li><code>dominoes[i] = 'R'</code>，表示第 <code>i</code> 张多米诺骨牌被推向右侧，</li>\n\t<li><code>dominoes[i] = '.'</code>，表示没有推动第 <code>i</code> 张多米诺骨牌。</li>\n</ul>\n\n<p>返回表示最终状态的字符串。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>dominoes = \"RR.L\"\n<strong>输出：</strong>\"RR.L\"\n<strong>解释：</strong>第一张多米诺骨牌没有给第二张施加额外的力。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/05/18/domino.png\" style=\"height: 196px; width: 512px;\" />\n<pre>\n<strong>输入：</strong>dominoes = \".L.R...LR..L..\"\n<strong>输出：</strong>\"LL.RR.LLRRLL..\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == dominoes.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>dominoes[i]</code> 为 <code>'L'</code>、<code>'R'</code> 或 <code>'.'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 839.相似字符串组",
        "hardRate": "HARD",
        "passRate": "58.85%",
        "problemsUrl": "https://leetcode.cn/problems/similar-string-groups/",
        "solutionsUrl": "https://leetcode.cn/problems/similar-string-groups/solution",
        "problemsDesc": "<p>如果交换字符串&nbsp;<code>X</code> 中的两个不同位置的字母，使得它和字符串&nbsp;<code>Y</code> 相等，那么称 <code>X</code> 和 <code>Y</code> 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。</p>\n\n<p>例如，<code>\"tars\"</code> 和 <code>\"rats\"</code> 是相似的 (交换 <code>0</code> 与 <code>2</code> 的位置)；&nbsp;<code>\"rats\"</code> 和 <code>\"arts\"</code> 也是相似的，但是 <code>\"star\"</code> 不与 <code>\"tars\"</code>，<code>\"rats\"</code>，或 <code>\"arts\"</code> 相似。</p>\n\n<p>总之，它们通过相似性形成了两个关联组：<code>{\"tars\", \"rats\", \"arts\"}</code> 和 <code>{\"star\"}</code>。注意，<code>\"tars\"</code> 和 <code>\"arts\"</code> 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。</p>\n\n<p>给你一个字符串列表 <code>strs</code>。列表中的每个字符串都是 <code>strs</code> 中其它所有字符串的一个字母异位词。请问 <code>strs</code> 中有多少个相似字符串组？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"tars\",\"rats\",\"arts\",\"star\"]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"omv\",\"ovm\"]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= strs[i].length &lt;= 300</code></li>\n\t<li><code>strs[i]</code> 只包含小写字母。</li>\n\t<li><code>strs</code> 中的所有单词都具有相同的长度，且是彼此的字母异位词。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 840.矩阵中的幻方",
        "hardRate": "MEDIUM",
        "passRate": "36.62%",
        "problemsUrl": "https://leetcode.cn/problems/magic-squares-in-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/magic-squares-in-grid/solution",
        "problemsDesc": "<p><code>3 x 3</code> 的幻方是一个填充有&nbsp;<strong>从 <code>1</code> 到 <code>9</code>&nbsp;</strong> 的不同数字的 <code>3 x 3</code> 矩阵，其中每行，每列以及两条对角线上的各数之和都相等。</p>\n\n<p>给定一个由整数组成的<code>row x col</code>&nbsp;的 <code>grid</code>，其中有多少个&nbsp;<code>3 × 3</code> 的 “幻方” 子矩阵？（每个子矩阵都是连续的）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/11/magic_main.jpg\" /></p>\n\n<pre>\n<strong>输入: </strong>grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]\n<strong>输出: </strong>1\n<strong>解释: </strong>\n下面的子矩阵是一个 3 x 3 的幻方：\n<img src=\"https://assets.leetcode.com/uploads/2020/09/11/magic_valid.jpg\" />\n而这一个不是：\n<img src=\"https://assets.leetcode.com/uploads/2020/09/11/magic_invalid.jpg\" />\n总的来说，在本示例所给定的矩阵中只有一个 3 x 3 的幻方子矩阵。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输出:</strong> grid = [[8]]\n<strong>输入:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>row == grid.length</code></li>\n\t<li><code>col == grid[i].length</code></li>\n\t<li><code>1 &lt;= row, col &lt;= 10</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 15</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 841.钥匙和房间",
        "hardRate": "MEDIUM",
        "passRate": "67.94%",
        "problemsUrl": "https://leetcode.cn/problems/keys-and-rooms/",
        "solutionsUrl": "https://leetcode.cn/problems/keys-and-rooms/solution",
        "problemsDesc": "<p>有 <code>n</code> 个房间，房间按从 <code>0</code> 到 <code>n - 1</code> 编号。最初，除 <code>0</code> 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。</p>\n\n<p>当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。</p>\n\n<p>给你一个数组 <code>rooms</code> 其中 <code>rooms[i]</code> 是你进入 <code>i</code> 号房间可以获得的钥匙集合。如果能进入 <strong>所有</strong> 房间返回 <code>true</code>，否则返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rooms = [[1],[2],[3],[]]\n<strong>输出：</strong>true\n<strong>解释：</strong>\n我们从 0 号房间开始，拿到钥匙 1。\n之后我们去 1 号房间，拿到钥匙 2。\n然后我们去 2 号房间，拿到钥匙 3。\n最后我们去了 3 号房间。\n由于我们能够进入每个房间，我们返回 true。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rooms = [[1,3],[3,0,1],[2],[0]]\n<strong>输出：</strong>false\n<strong>解释：</strong>我们不能进入 2 号房间。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == rooms.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= sum(rooms[i].length) &lt;= 3000</code></li>\n\t<li><code>0 &lt;= rooms[i][j] &lt; n</code></li>\n\t<li>所有 <code>rooms[i]</code> 的值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 842.将数组拆分成斐波那契序列",
        "hardRate": "MEDIUM",
        "passRate": "48.30%",
        "problemsUrl": "https://leetcode.cn/problems/split-array-into-fibonacci-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/split-array-into-fibonacci-sequence/solution",
        "problemsDesc": "<p>给定一个数字字符串 <code>num</code>，比如 <code>\"123456579\"</code>，我们可以将它分成「斐波那契式」的序列 <code>[123, 456, 579]</code>。</p>\n\n<p>形式上，<strong>斐波那契式&nbsp;</strong>序列是一个非负整数列表 <code>f</code>，且满足：</p>\n\n<ul>\n\t<li><code>0 &lt;= f[i] &lt; 2<sup>31</sup></code>&nbsp;，（也就是说，每个整数都符合 <strong>32 位</strong>&nbsp;有符号整数类型）</li>\n\t<li><code>f.length &gt;= 3</code></li>\n\t<li>对于所有的<code>0 &lt;= i &lt; f.length - 2</code>，都有 <code>f[i] + f[i + 1] = f[i + 2]</code></li>\n</ul>\n\n<p>另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 <code>0</code> 本身。</p>\n\n<p>返回从 <code>num</code> 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 <code>[]</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"1101111\"\n<strong>输出：</strong>[11,0,11,11]\n<strong>解释：</strong>输出[110,1,111]也可以。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>num = \"112358130\"\n<strong>输出: </strong>[]\n<strong>解释: </strong>无法拆分。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>\"0123\"\n<strong>输出：</strong>[]\n<strong>解释：</strong>每个块的数字不能以零开头，因此 \"01\"，\"2\"，\"3\" 不是有效答案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 200</code></li>\n\t<li><code>num</code>&nbsp;中只含有数字</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 843.猜猜这个单词",
        "hardRate": "HARD",
        "passRate": "36.70%",
        "problemsUrl": "https://leetcode.cn/problems/guess-the-word/",
        "solutionsUrl": "https://leetcode.cn/problems/guess-the-word/solution",
        "problemsDesc": "<p>给你一个由 <strong>不同</strong> 字符串组成的单词列表&nbsp;<code>words</code> ，其中 <code>words[i]</code>&nbsp;长度均为&nbsp;<code>6</code> 。<code>words</code> 中的一个单词将被选作秘密单词 <code>secret</code>&nbsp;。</p>\n\n<p>另给你一个辅助对象&nbsp;<code>Master</code> ，你可以调用&nbsp;<code>Master.guess(word)</code> 来猜单词，其中参数 <code>word</code> 长度为 6 且必须是 <code>words</code> 中的字符串。</p>\n\n<p><code>Master.guess(word)</code> 将会返回如下结果：</p>\n\n<ul>\n\t<li>如果 <code>word</code> 不是 <code>words</code> 中的字符串，返回 <code>-1</code> ，或者</li>\n\t<li>一个整数，表示你所猜测的单词 <code>word</code> 与 <strong>秘密单词</strong>&nbsp;<code>secret</code>&nbsp;的准确匹配（值和位置同时匹配）的数目。</li>\n</ul>\n\n<p>每组测试用例都会包含一个参数 <code>allowedGuesses</code> ，其中 <code>allowedGuesses</code> 是你可以调用 <code>Master.guess(word)</code> 的最大次数。</p>\n\n<p>对于每组测试用例，在不超过允许猜测的次数的前提下，你应该调用 <code>Master.guess</code> 来猜出秘密单词。最终，你将会得到以下结果：</p>\n\n<ul>\n\t<li>如果你调用 <code>Master.guess</code> 的次数大于 <code>allowedGuesses</code> 所限定的次数或者你没有用 <code>Master.guess</code> 猜到秘密单词，则得到 <strong><code>\"Either you took too many guesses, or you did not find the secret word.\"</code> 。</strong></li>\n\t<li>如果你调用 <code>Master.guess</code> 猜到秘密单词，且调用 <code>Master.guess</code> 的次数小于或等于 <code>allowedGuesses</code> ，则得到 <strong><code>\"You guessed the secret word correctly.\"</code> 。</strong></li>\n</ul>\n\n<p>生成的测试用例保证你可以利用某种合理的策略（而不是暴力）猜到秘密单词。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>secret = \"acckzz\", words = [\"acckzz\",\"ccbazz\",\"eiowzz\",\"abcczz\"], allowedGuesses = 10\n<strong>输出：</strong>You guessed the secret word correctly.\n<strong>解释：</strong>\nmaster.guess(\"aaaaaa\") 返回 -1 ，因为 \"aaaaaa\" 不在 words 中。\nmaster.guess(\"acckzz\") 返回 6 ，因为 \"acckzz\" 是秘密单词 secret ，共有 6 个字母匹配。\nmaster.guess(\"ccbazz\") 返回 3 ，因为 \"ccbazz\" 共有 3 个字母匹配。\nmaster.guess(\"eiowzz\") 返回 2 ，因为 \"eiowzz\" 共有 2 个字母匹配。\nmaster.guess(\"abcczz\") 返回 4 ，因为 \"abcczz\" 共有 4 个字母匹配。\n一共调用 5 次 master.guess ，其中一个为秘密单词，所以通过测试用例。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>secret = \"hamada\", words = [\"hamada\",\"khaled\"], allowedGuesses = 10\n<strong>输出：</strong>You guessed the secret word correctly.\n<strong>解释：</strong>共有 2 个单词，且其中一个为秘密单词，可以通过测试用例。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>words[i].length == 6</code></li>\n\t<li><code>words[i]</code> 仅由小写英文字母组成</li>\n\t<li><code>words</code> 中所有字符串 <strong>互不相同</strong></li>\n\t<li><code>secret</code> 存在于 <code>words</code> 中</li>\n\t<li><code>10 &lt;= allowedGuesses &lt;= 30</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 844.比较含退格的字符串",
        "hardRate": "EASY",
        "passRate": "47.89%",
        "problemsUrl": "https://leetcode.cn/problems/backspace-string-compare/",
        "solutionsUrl": "https://leetcode.cn/problems/backspace-string-compare/solution",
        "problemsDesc": "<p>给定 <code>s</code> 和 <code>t</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 <code>true</code> 。<code>#</code> 代表退格字符。</p>\n\n<p><strong>注意：</strong>如果对空文本输入退格字符，文本继续为空。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ab#c\", t = \"ad#c\"\n<strong>输出：</strong>true\n<strong>解释：</strong>s 和 t 都会变成 \"ac\"。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ab##\", t = \"c#d#\"\n<strong>输出：</strong>true\n<strong>解释：</strong>s 和 t 都会变成 \"\"。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a#c\", t = \"b\"\n<strong>输出：</strong>false\n<strong>解释：</strong>s 会变成 \"c\"，但 t 仍然是 \"b\"。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 200</code></li>\n\t<li><code>s</code> 和 <code>t</code> 只含有小写字母以及字符 <code>'#'</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你可以用 <code>O(n)</code> 的时间复杂度和 <code>O(1)</code> 的空间复杂度解决该问题吗？</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 845.数组中的最长山脉",
        "hardRate": "MEDIUM",
        "passRate": "42.31%",
        "problemsUrl": "https://leetcode.cn/problems/longest-mountain-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-mountain-in-array/solution",
        "problemsDesc": "<p>把符合下列属性的数组 <code>arr</code> 称为 <strong>山脉数组</strong> ：</p>\n\n<ul>\n\t<li><code>arr.length &gt;= 3</code></li>\n\t<li>存在下标 <code>i</code>（<code>0 &lt; i &lt; arr.length - 1</code>），满足\n\t<ul>\n\t\t<li><code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]</code></li>\n\t\t<li><code>arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>给出一个整数数组 <code>arr</code>，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [2,1,4,7,3,2,5]\n<strong>输出：</strong>5\n<strong>解释：</strong>最长的山脉子数组是 [1,4,7,3,2]，长度为 5。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [2,2,2]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在山脉子数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你可以仅用一趟扫描解决此问题吗？</li>\n\t<li>你可以用 <code>O(1)</code> 空间解决此问题吗？</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 846.一手顺子",
        "hardRate": "MEDIUM",
        "passRate": "57.24%",
        "problemsUrl": "https://leetcode.cn/problems/hand-of-straights/",
        "solutionsUrl": "https://leetcode.cn/problems/hand-of-straights/solution",
        "problemsDesc": "<p>Alice 手中有一把牌，她想要重新排列这些牌，分成若干组，使每一组的牌数都是 <code>groupSize</code> ，并且由 <code>groupSize</code> 张连续的牌组成。</p>\n\n<p>给你一个整数数组 <code>hand</code> 其中 <code>hand[i]</code> 是写在第 <code>i</code> 张牌上的<strong>数值</strong>。如果她可能重新排列这些牌，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>hand = [1,2,3,6,2,3,4,7,8], groupSize = 3\n<strong>输出：</strong>true\n<strong>解释：</strong>Alice 手中的牌可以被重新排列为 <code>[1,2,3]，[2,3,4]，[6,7,8]</code>。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>hand = [1,2,3,4,5], groupSize = 4\n<strong>输出：</strong>false\n<strong>解释：</strong>Alice 手中的牌无法被重新排列成几个大小为 4 的组。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= hand.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= hand[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= groupSize &lt;= hand.length</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>此题目与 1296 重复：<a href=\"https://leetcode-cn.com/problems/divide-array-in-sets-of-k-consecutive-numbers/\" target=\"_blank\">https://leetcode-cn.com/problems/divide-array-in-sets-of-k-consecutive-numbers/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 847.访问所有节点的最短路径",
        "hardRate": "HARD",
        "passRate": "67.56%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-path-visiting-all-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-path-visiting-all-nodes/solution",
        "problemsDesc": "<p>存在一个由 <code>n</code> 个节点组成的无向连通图，图中的节点按从 <code>0</code> 到 <code>n - 1</code> 编号。</p>\n\n<p>给你一个数组 <code>graph</code> 表示这个图。其中，<code>graph[i]</code> 是一个列表，由所有与节点 <code>i</code> 直接相连的节点组成。</p>\n\n<p>返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/12/shortest1-graph.jpg\" style=\"width: 222px; height: 183px;\" />\n<pre>\n<strong>输入：</strong>graph = [[1,2,3],[0],[0],[0]]\n<strong>输出：</strong>4\n<strong>解释：</strong>一种可能的路径为 [1,0,2,0,3]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/12/shortest2-graph.jpg\" style=\"width: 382px; height: 222px;\" /></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]\n<strong>输出：</strong>4\n<strong>解释：</strong>一种可能的路径为 [0,1,4,2,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == graph.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 12</code></li>\n\t<li><code>0 &lt;= graph[i].length &lt;&nbsp;n</code></li>\n\t<li><code>graph[i]</code> 不包含 <code>i</code></li>\n\t<li>如果 <code>graph[a]</code> 包含 <code>b</code> ，那么 <code>graph[b]</code> 也包含 <code>a</code></li>\n\t<li>输入的图总是连通图</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 848.字母移位",
        "hardRate": "MEDIUM",
        "passRate": "46.19%",
        "problemsUrl": "https://leetcode.cn/problems/shifting-letters/",
        "solutionsUrl": "https://leetcode.cn/problems/shifting-letters/solution",
        "problemsDesc": "<p>有一个由小写字母组成的字符串 <code>s</code>，和一个长度相同的整数数组 <code>shifts</code>。</p>\n\n<p>我们将字母表中的下一个字母称为原字母的 <em>移位</em>&nbsp;<code>shift()</code>&nbsp;（由于字母表是环绕的， <code>'z'</code>&nbsp;将会变成&nbsp;<code>'a'</code>）。</p>\n\n<ul>\n\t<li>例如，<code>shift('a') = 'b'<font color=\"#333333\"><font face=\"Helvetica Neue, Helvetica, Arial, sans-serif\"><span style=\"font-size:14px\"><span style=\"background-color:#ffffff\">,&nbsp;</span></span></font></font></code><code>shift('t') = 'u'</code>,&nbsp;以及&nbsp;<code>shift('z') = 'a'</code>。</li>\n</ul>\n\n<p>对于每个&nbsp;<code>shifts[i] = x</code>&nbsp;， 我们会将 <code>s</code>&nbsp;中的前&nbsp;<code>i + 1</code>&nbsp;个字母移位&nbsp;<code>x</code>&nbsp;次。</p>\n\n<p>返回 <em>将所有这些移位都应用到 <code>s</code> 后最终得到的字符串</em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\", shifts = [3,5,9]\n<strong>输出：</strong>\"rpl\"\n<strong>解释： </strong>\n我们以 \"abc\" 开始。\n将 S 中的第 1 个字母移位 3 次后，我们得到 \"dbc\"。\n再将 S 中的前 2 个字母移位 5 次后，我们得到 \"igc\"。\n最后将 S 中的这 3 个字母移位 9 次后，我们得到答案 \"rpl\"。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"aaa\", shifts = [1,2,3]\n<strong>输出:</strong> \"gfd\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;由小写英文字母组成</li>\n\t<li><code>shifts.length == s.length</code></li>\n\t<li><code>0 &lt;= shifts[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n<span style=\"display:block\"><span style=\"height:0px\"><span style=\"position:absolute\">​​​​​​</span></span></span>",
        "isPlus": false
    },
    {
        "problemsName": " 849.到最近的人的最大距离",
        "hardRate": "MEDIUM",
        "passRate": "44.15%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-distance-to-closest-person/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-distance-to-closest-person/solution",
        "problemsDesc": "<p>给你一个数组 <code>seats</code> 表示一排座位，其中 <code>seats[i] = 1</code> 代表有人坐在第 <code>i</code> 个座位上，<code>seats[i] = 0</code> 代表座位 <code>i</code> 上是空的（<strong>下标从 0 开始</strong>）。</p>\n\n<p>至少有一个空座位，且至少有一人已经坐在座位上。</p>\n\n<p>亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。</p>\n\n<p>返回他到离他最近的人的最大距离。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/10/distance.jpg\" style=\"width: 650px; height: 257px;\" />\n<pre>\n<strong>输入：</strong>seats = [1,0,0,0,1,0,1]\n<strong>输出：</strong>2\n<strong>解释：\n</strong>如果亚历克斯坐在第二个空位（seats[2]）上，他到离他最近的人的距离为 2 。\n如果亚历克斯坐在其它任何一个空位上，他到离他最近的人的距离为 1 。\n因此，他到离他最近的人的最大距离是 2 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>seats = [1,0,0,0]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n如果亚历克斯坐在最后一个座位上，他离最近的人有 3 个座位远。\n这是可能的最大距离，所以答案是 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>seats = [0,1]\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= seats.length <= 2 * 10<sup>4</sup></code></li>\n\t<li><code>seats[i]</code> 为 <code>0</code> 或 <code>1</code></li>\n\t<li>至少有一个 <strong>空座位</strong></li>\n\t<li>至少有一个 <strong>座位上有人</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 850.矩形面积 II",
        "hardRate": "HARD",
        "passRate": "62.91%",
        "problemsUrl": "https://leetcode.cn/problems/rectangle-area-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/rectangle-area-ii/solution",
        "problemsDesc": "<p>给你一个轴对齐的二维数组&nbsp;<code>rectangles</code>&nbsp;。 对于&nbsp;<code>rectangle[i] = [x1, y1, x2, y2]</code>，其中（x1，y1）是矩形&nbsp;<code>i</code>&nbsp;左下角的坐标，<meta charset=\"UTF-8\" />&nbsp;<code>(x<sub>i1</sub>, y<sub>i1</sub>)</code>&nbsp;是该矩形 <strong>左下角</strong> 的坐标，<meta charset=\"UTF-8\" />&nbsp;<code>(x<sub>i2</sub>, y<sub>i2</sub>)</code>&nbsp;是该矩形&nbsp;<strong>右上角</strong> 的坐标。</p>\n\n<p>计算平面中所有&nbsp;<code>rectangles</code>&nbsp;所覆盖的 <strong>总面积 </strong>。任何被两个或多个矩形覆盖的区域应只计算 <strong>一次</strong> 。</p>\n\n<p>返回<em> <strong>总面积</strong> </em>。因为答案可能太大，返回<meta charset=\"UTF-8\" />&nbsp;<code>10<sup>9</sup>&nbsp;+ 7</code> 的&nbsp;<strong>模</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/06/rectangle_area_ii_pic.png\" style=\"height: 360px; width: 480px;\" /></p>\n\n<pre>\n<strong>输入：</strong>rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]\n<strong>输出：</strong>6\n<strong>解释：</strong>如图所示，三个矩形覆盖了总面积为 6 的区域。\n从(1,1)到(2,2)，绿色矩形和红色矩形重叠。\n从(1,0)到(2,3)，三个矩形都重叠。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rectangles = [[0,0,1000000000,1000000000]]\n<strong>输出：</strong>49\n<strong>解释：</strong>答案是 10<sup>18</sup> 对 (10<sup>9</sup> + 7) 取模的结果， 即 49 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rectangles.length &lt;= 200</code></li>\n\t<li><code>rectanges[i].length = 4</code><meta charset=\"UTF-8\" /></li>\n\t<li><code>0 &lt;= x<sub>i1</sub>, y<sub>i1</sub>, x<sub>i2</sub>, y<sub>i2</sub>&nbsp;&lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 851.喧闹和富有",
        "hardRate": "MEDIUM",
        "passRate": "63.09%",
        "problemsUrl": "https://leetcode.cn/problems/loud-and-rich/",
        "solutionsUrl": "https://leetcode.cn/problems/loud-and-rich/solution",
        "problemsDesc": "<p>有一组 <code>n</code> 个人作为实验对象，从 <code>0</code> 到 <code>n - 1</code> 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为&nbsp;<code>x</code>&nbsp;的人简称为 \"person&nbsp;<code>x</code>&nbsp;\"。</p>\n\n<p>给你一个数组 <code>richer</code> ，其中 <code>richer[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示 person&nbsp;<code>a<sub>i</sub></code>&nbsp;比 person&nbsp;<code>b<sub>i</sub></code>&nbsp;更有钱。另给你一个整数数组 <code>quiet</code> ，其中&nbsp;<code>quiet[i]</code> 是 person <code>i</code> 的安静值。<code>richer</code> 中所给出的数据 <strong>逻辑自洽</strong>（也就是说，在 person <code>x</code> 比 person <code>y</code> 更有钱的同时，不会出现 person <code>y</code> 比 person <code>x</code> 更有钱的情况 ）。</p>\n\n<p>现在，返回一个整数数组 <code>answer</code> 作为答案，其中&nbsp;<code>answer[x] = y</code>&nbsp;的前提是，在所有拥有的钱肯定不少于&nbsp;person&nbsp;<code>x</code>&nbsp;的人中，person&nbsp;<code>y</code>&nbsp;是最安静的人（也就是安静值&nbsp;<code>quiet[y]</code>&nbsp;最小的人）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\n<strong>输出：</strong>[5,5,2,5,4,5,6,7]\n<strong>解释： </strong>\nanswer[0] = 5，\nperson 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。\n唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7，\n但是目前还不清楚他是否比 person 0 更有钱。\nanswer[7] = 7，\n在所有拥有的钱肯定不少于 person 7 的人中（这可能包括 person 3，4，5，6 以及 7），\n最安静（有较低安静值 quiet[x]）的人是 person 7。\n其他的答案也可以用类似的推理来解释。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>richer = [], quiet = [0]\n<strong>输出：</strong>[0]\n</pre>\n&nbsp;\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == quiet.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>0 &lt;= quiet[i] &lt; n</code></li>\n\t<li><code>quiet</code> 的所有值 <strong>互不相同</strong></li>\n\t<li><code>0 &lt;= richer.length &lt;= n * (n - 1) / 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i </sub>!= b<sub>i</sub></code></li>\n\t<li><code>richer</code> 中的所有数对 <strong>互不相同</strong></li>\n\t<li>对<strong> </strong><code>richer</code> 的观察在逻辑上是一致的</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 852.山脉数组的峰顶索引",
        "hardRate": "MEDIUM",
        "passRate": "68.64%",
        "problemsUrl": "https://leetcode.cn/problems/peak-index-in-a-mountain-array/",
        "solutionsUrl": "https://leetcode.cn/problems/peak-index-in-a-mountain-array/solution",
        "problemsDesc": "符合下列属性的数组 <code>arr</code> 称为 <strong>山脉数组</strong> ：\n<ul>\n\t<li><code>arr.length &gt;= 3</code></li>\n\t<li>存在 <code>i</code>（<code>0 &lt; i&nbsp;&lt; arr.length - 1</code>）使得：\n\t<ul>\n\t\t<li><code>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] </code></li>\n\t\t<li><code>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>给你由整数组成的山脉数组 <code>arr</code> ，返回满足 <code>arr[0] &lt; arr[1] &lt; ... arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code> 的下标 <code>i</code> 。</p>\n\n<p>你必须设计并实现时间复杂度为 <code>O(log(n))</code> 的解决方案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,1,0]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,2,1,0]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,10,5,2]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10<sup>6</sup></code></li>\n\t<li>题目数据保证 <code>arr</code> 是一个山脉数组</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 853.车队",
        "hardRate": "MEDIUM",
        "passRate": "41.38%",
        "problemsUrl": "https://leetcode.cn/problems/car-fleet/",
        "solutionsUrl": "https://leetcode.cn/problems/car-fleet/solution",
        "problemsDesc": "<p>在一条单行道上，有 <code>n</code> 辆车开往同一目的地。目的地是几英里以外的&nbsp;<code>target</code>&nbsp;。</p>\n\n<p>给定两个整数数组&nbsp;<code>position</code>&nbsp;和&nbsp;<code>speed</code>&nbsp;，长度都是 <code>n</code> ，其中&nbsp;<code>position[i]</code>&nbsp;是第 <code>i</code> 辆车的位置，&nbsp;<code>speed[i]</code>&nbsp;是第 <code>i</code> 辆车的速度(单位是英里/小时)。</p>\n\n<p>一辆车永远不会超过前面的另一辆车，但它可以追上去，并与前车 <strong>以相同的速度</strong> 紧接着行驶。此时，我们会忽略这两辆车之间的距离，也就是说，它们被假定处于相同的位置。</p>\n\n<p><strong>车队</strong><em>&nbsp;</em>是一些由行驶在相同位置、具有相同速度的车组成的非空集合。注意，一辆车也可以是一个车队。</p>\n\n<p>即便一辆车在目的地才赶上了一个车队，它们仍然会被视作是同一个车队。</p>\n\n<p>返回到达目的地的 <strong>车队数量</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n从 10 和 8 开始的车会组成一个车队，它们在 12 处相遇。\n从 0 处开始的车无法追上其它车，所以它自己就是一个车队。\n从 5 和 3 开始的车会组成一个车队，它们在 6 处相遇。\n请注意，在到达目的地之前没有其它车会遇到这些车队，所以答案是 3。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> target = 10, position = [3], speed = [3]\n<strong>输出:</strong> 1\n<strong>解释:</strong> 只有一辆车，因此只有一个车队。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> target = 100, position = [0,2,4], speed = [4,2,1]\n<strong>输出:</strong> 1\n<strong>解释:</strong>\n以0(速度4)和2(速度2)出发的车辆组成车队，在4点相遇。舰队以2的速度前进。\n然后，车队(速度2)和以4(速度1)出发的汽车组成一个车队，在6点相遇。舰队以1的速度前进，直到到达目标。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == position.length == speed.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt; target &lt;= 10<sup>6</sup></code></li>\n\t<li><code>0 &lt;= position[i] &lt; target</code></li>\n\t<li><code>position</code>&nbsp;中每个值都 <strong>不同</strong></li>\n\t<li><code>0 &lt; speed[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 854.相似度为 K 的字符串",
        "hardRate": "HARD",
        "passRate": "46.77%",
        "problemsUrl": "https://leetcode.cn/problems/k-similar-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/k-similar-strings/solution",
        "problemsDesc": "<p>对于某些非负整数 <code>k</code> ，如果交换 <code>s1</code> 中两个字母的位置恰好 <code>k</code> 次，能够使结果字符串等于 <code>s2</code> ，则认为字符串 <code>s1</code> 和 <code>s2</code> 的<strong> 相似度为 </strong><code>k</code><strong> </strong><strong>。</strong></p>\n\n<p>给你两个字母异位词 <code>s1</code> 和 <code>s2</code> ，返回 <code>s1</code> 和 <code>s2</code> 的相似度 <code>k</code><strong> </strong>的最小值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"ab\", s2 = \"ba\"\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"abc\", s2 = \"bca\"\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length &lt;= 20</code></li>\n\t<li><code>s2.length == s1.length</code></li>\n\t<li><code>s1</code>&nbsp;和&nbsp;<code>s2</code>&nbsp;&nbsp;只包含集合&nbsp;<code>{'a', 'b', 'c', 'd', 'e', 'f'}</code>&nbsp;中的小写字母</li>\n\t<li><code>s2</code> 是 <code>s1</code> 的一个字母异位词</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 855.考场就座",
        "hardRate": "MEDIUM",
        "passRate": "47.70%",
        "problemsUrl": "https://leetcode.cn/problems/exam-room/",
        "solutionsUrl": "https://leetcode.cn/problems/exam-room/solution",
        "problemsDesc": "<p>在考场里，一排有&nbsp;<code>N</code>&nbsp;个座位，分别编号为&nbsp;<code>0, 1, 2, ..., N-1</code>&nbsp;。</p>\n\n<p>当学生进入考场后，他必须坐在能够使他与离他最近的人之间的距离达到最大化的座位上。如果有多个这样的座位，他会坐在编号最小的座位上。(另外，如果考场里没有人，那么学生就坐在 0 号座位上。)</p>\n\n<p>返回&nbsp;<code>ExamRoom(int N)</code>&nbsp;类，它有两个公开的函数：其中，函数&nbsp;<code>ExamRoom.seat()</code>&nbsp;会返回一个&nbsp;<code>int</code>&nbsp;（整型数据），代表学生坐的位置；函数&nbsp;<code>ExamRoom.leave(int p)</code>&nbsp;代表坐在座位 <code>p</code> 上的学生现在离开了考场。每次调用&nbsp;<code>ExamRoom.leave(p)</code>&nbsp;时都保证有学生坐在座位&nbsp;<code>p</code>&nbsp;上。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>[&quot;ExamRoom&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;leave&quot;,&quot;seat&quot;], [[10],[],[],[],[],[4],[]]\n<strong>输出：</strong>[null,0,9,4,2,null,5]\n<strong>解释：</strong>\nExamRoom(10) -&gt; null\nseat() -&gt; 0，没有人在考场里，那么学生坐在 0 号座位上。\nseat() -&gt; 9，学生最后坐在 9 号座位上。\nseat() -&gt; 4，学生最后坐在 4 号座位上。\nseat() -&gt; 2，学生最后坐在 2 号座位上。\nleave(4) -&gt; null\nseat() -&gt; 5，学生最后坐在 5 号座位上。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= N &lt;= 10^9</code></li>\n\t<li>在所有的测试样例中&nbsp;<code>ExamRoom.seat()</code>&nbsp;和&nbsp;<code>ExamRoom.leave()</code>&nbsp;最多被调用&nbsp;<code>10^4</code>&nbsp;次。</li>\n\t<li>保证在调用&nbsp;<code>ExamRoom.leave(p)</code>&nbsp;时有学生正坐在座位 <code>p</code> 上。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 856.括号的分数",
        "hardRate": "MEDIUM",
        "passRate": "68.43%",
        "problemsUrl": "https://leetcode.cn/problems/score-of-parentheses/",
        "solutionsUrl": "https://leetcode.cn/problems/score-of-parentheses/solution",
        "problemsDesc": "<p>给定一个平衡括号字符串&nbsp;<code>S</code>，按下述规则计算该字符串的分数：</p>\n\n<ul>\n\t<li><code>()</code> 得 1 分。</li>\n\t<li><code>AB</code> 得&nbsp;<code>A + B</code>&nbsp;分，其中 A 和 B 是平衡括号字符串。</li>\n\t<li><code>(A)</code> 得&nbsp;<code>2 * A</code>&nbsp;分，其中 A 是平衡括号字符串。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入： </strong>&quot;()&quot;\n<strong>输出： </strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入： </strong>&quot;(())&quot;\n<strong>输出： </strong>2\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre><strong>输入： </strong>&quot;()()&quot;\n<strong>输出： </strong>2\n</pre>\n\n<p><strong>示例&nbsp;4：</strong></p>\n\n<pre><strong>输入： </strong>&quot;(()(()))&quot;\n<strong>输出： </strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>S</code>&nbsp;是平衡括号字符串，且只含有&nbsp;<code>(</code>&nbsp;和&nbsp;<code>)</code>&nbsp;。</li>\n\t<li><code>2 &lt;= S.length &lt;= 50</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 857.雇佣 K 名工人的最低成本",
        "hardRate": "HARD",
        "passRate": "63.58%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/solution",
        "problemsDesc": "<p>有 <code>n</code>&nbsp;名工人。&nbsp;给定两个数组&nbsp;<code>quality</code>&nbsp;和&nbsp;<code>wage</code>&nbsp;，其中，<code>quality[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;名工人的工作质量，其最低期望工资为&nbsp;<code>wage[i]</code>&nbsp;。</p>\n\n<p>现在我们想雇佣&nbsp;<code>k</code>&nbsp;名工人组成一个<em>工资组。</em>在雇佣&nbsp;一组 <code>k</code>&nbsp;名工人时，我们必须按照下述规则向他们支付工资：</p>\n\n<ol>\n\t<li>对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。</li>\n\t<li>工资组中的每名工人至少应当得到他们的最低期望工资。</li>\n</ol>\n\n<p>给定整数 <code>k</code> ，返回 <em>组成满足上述条件的付费群体所需的最小金额&nbsp;</em>。在实际答案的&nbsp;<code>10<sup>-5</sup></code>&nbsp;以内的答案将被接受。。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入： </strong>quality = [10,20,5], wage = [70,50,30], k = 2\n<strong>输出： </strong>105.00000\n<strong>解释：</strong> 我们向 0 号工人支付 70，向 2 号工人支付 35。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入： </strong>quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3\n<strong>输出： </strong>30.66667\n<strong>解释： </strong>我们向 0 号工人支付 4，向 2 号和 3 号分别支付 13.33333。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == quality.length == wage.length</code></li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= quality[i], wage[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 858.镜面反射",
        "hardRate": "MEDIUM",
        "passRate": "57.47%",
        "problemsUrl": "https://leetcode.cn/problems/mirror-reflection/",
        "solutionsUrl": "https://leetcode.cn/problems/mirror-reflection/solution",
        "problemsDesc": "<p>有一个特殊的正方形房间，每面墙上都有一面镜子。除西南角以外，每个角落都放有一个接受器，编号为&nbsp;<code>0</code>，&nbsp;<code>1</code>，以及&nbsp;<code>2</code>。</p>\n\n<p>正方形房间的墙壁长度为&nbsp;<code>p</code>，一束激光从西南角射出，首先会与东墙相遇，入射点到接收器 <code>0</code> 的距离为 <code>q</code> 。</p>\n\n<p>返回光线最先遇到的接收器的编号（保证光线最终会遇到一个接收器）。</p>\n&nbsp;\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/18/reflection.png\" style=\"width: 218px; height: 217px;\" />\n<pre>\n<strong>输入：</strong>p = 2, q = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>这条光线在第一次被反射回左边的墙时就遇到了接收器 2 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>p = 3, q = 1\n<strong>输入：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= q &lt;= p &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 859.亲密字符串",
        "hardRate": "EASY",
        "passRate": "34.51%",
        "problemsUrl": "https://leetcode.cn/problems/buddy-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/buddy-strings/solution",
        "problemsDesc": "<p>给你两个字符串 <code>s</code> 和 <code>goal</code> ，只要我们可以通过交换 <code>s</code> 中的两个字母得到与 <code>goal</code> 相等的结果，就返回&nbsp;<code>true</code>&nbsp;；否则返回 <code>false</code> 。</p>\n\n<p>交换字母的定义是：取两个下标 <code>i</code> 和 <code>j</code> （下标从 <code>0</code> 开始）且满足 <code>i != j</code> ，接着交换 <code>s[i]</code> 和 <code>s[j]</code> 处的字符。</p>\n\n<ul>\n\t<li>例如，在 <code>\"abcd\"</code> 中交换下标 <code>0</code> 和下标 <code>2</code> 的元素可以生成 <code>\"cbad\"</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ab\", goal = \"ba\"\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以交换 s[0] = 'a' 和 s[1] = 'b' 生成 \"ba\"，此时 s 和 goal 相等。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ab\", goal = \"ab\"\n<strong>输出：</strong>false\n<strong>解释：</strong>你只能交换 s[0] = 'a' 和 s[1] = 'b' 生成 \"ba\"，此时 s 和 goal 不相等。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aa\", goal = \"aa\"\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以交换 s[0] = 'a' 和 s[1] = 'a' 生成 \"aa\"，此时 s 和 goal 相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, goal.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> 和 <code>goal</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 860.柠檬水找零",
        "hardRate": "EASY",
        "passRate": "58.60%",
        "problemsUrl": "https://leetcode.cn/problems/lemonade-change/",
        "solutionsUrl": "https://leetcode.cn/problems/lemonade-change/solution",
        "problemsDesc": "<p>在柠檬水摊上，每一杯柠檬水的售价为&nbsp;<code>5</code>&nbsp;美元。顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p>\n\n<p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p>\n\n<p>注意，一开始你手头没有任何零钱。</p>\n\n<p>给你一个整数数组 <code>bills</code> ，其中 <code>bills[i]</code> 是第 <code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回&nbsp;<code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>bills = [5,5,5,10,20]\n<strong>输出：</strong>true\n<strong>解释：\n</strong>前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。\n第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。\n第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。\n由于所有客户都得到了正确的找零，所以我们输出 true。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>bills = [5,5,10,10,20]\n<strong>输出：</strong>false\n<strong>解释：</strong>\n前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。\n对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。\n对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。\n由于不是每位顾客都得到了正确的找零，所以答案是 false。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= bills.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>bills[i]</code>&nbsp;不是&nbsp;<code>5</code>&nbsp;就是&nbsp;<code>10</code>&nbsp;或是&nbsp;<code>20</code>&nbsp;</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 861.翻转矩阵后的得分",
        "hardRate": "MEDIUM",
        "passRate": "80.78%",
        "problemsUrl": "https://leetcode.cn/problems/score-after-flipping-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/score-after-flipping-matrix/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的二元矩阵 <code>grid</code> ，矩阵中每个元素的值为 <code>0</code> 或 <code>1</code> 。</p>\n\n<p>一次 <strong>移动</strong> 是指选择任一行或列，并转换该行或列中的每一个值：将所有 <code>0</code> 都更改为 <code>1</code>，将所有 <code>1</code> 都更改为 <code>0</code>。</p>\n\n<p>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的 <strong>得分</strong> 就是这些数字的总和。</p>\n\n<p>在执行任意次 <strong>移动</strong> 后（含 0 次），返回可能的最高分数。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-toogle1.jpg\" style=\"width: 500px; height: 299px;\" />\n<pre>\n<strong>输入：</strong>grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]\n<strong>输出：</strong>39\n<strong>解释：</strong>0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0]]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 20</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 862.和至少为 K 的最短子数组",
        "hardRate": "HARD",
        "passRate": "26.52%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，找出 <code>nums</code> 中和至少为 <code>k</code> 的 <strong>最短非空子数组</strong> ，并返回该子数组的长度。如果不存在这样的 <strong>子数组</strong> ，返回 <code>-1</code> 。</p>\n\n<p><strong>子数组</strong> 是数组中 <strong>连续</strong> 的一部分。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1], k = 1\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2], k = 4\n<strong>输出：</strong>-1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,-1,2], k = 3\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 863.二叉树中所有距离为 K 的结点",
        "hardRate": "MEDIUM",
        "passRate": "61.40%",
        "problemsUrl": "https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/solution",
        "problemsDesc": "<p>给定一个二叉树（具有根结点&nbsp;<code>root</code>），&nbsp;一个目标结点&nbsp;<code>target</code>&nbsp;，和一个整数值 <code>k</code> 。</p>\n\n<p>返回到目标结点 <code>target</code> 距离为 <code>k</code> 的所有结点的值的列表。 答案可以以 <strong>任何顺序</strong> 返回。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png\" style=\"height: 429px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2\n<strong>输出：</strong>[7,4,1]\n<strong>解释：</strong>所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> root = [1], target = 1, k = 3\n<strong>输出:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>节点数在&nbsp;<code>[1, 500]</code>&nbsp;范围内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 500</code></li>\n\t<li><code>Node.val</code>&nbsp;中所有值 <strong>不同</strong></li>\n\t<li>目标结点&nbsp;<code>target</code>&nbsp;是树上的结点。</li>\n\t<li><code>0 &lt;= k &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 864.获取所有钥匙的最短路径",
        "hardRate": "HARD",
        "passRate": "59.51%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-path-to-get-all-keys/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-path-to-get-all-keys/solution",
        "problemsDesc": "<p>给定一个二维网格&nbsp;<code>grid</code>&nbsp;，其中：</p>\n\n<ul>\n\t<li><font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">'.'</span></span></font></font> 代表一个空房间</li>\n\t<li><font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">'#'</span></span></font></font> 代表一堵墙</li>\n\t<li><font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">'@'</span></span></font></font>&nbsp;是起点</li>\n\t<li>小写字母代表钥匙</li>\n\t<li>大写字母代表锁</li>\n</ul>\n\n<p>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。</p>\n\n<p>假设 k&nbsp;为 钥匙/锁 的个数，且满足&nbsp;<code>1 &lt;= k&nbsp;&lt;= 6</code>，字母表中的前 <code>k</code>&nbsp;个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。</p>\n\n<p>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-keys2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [\"@.a.#\",\"###.#\",\"b.A.B\"]\n<strong>输出：</strong>8\n<strong>解释：</strong>目标是获得所有钥匙，而不是打开所有锁。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-key2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [\"@..aA\",\"..B#.\",\"....b\"]\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-keys3.jpg\" />\n<pre>\n<strong>输入:</strong> grid = [\"@Aa\"]\n<strong>输出:</strong> -1</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 30</code></li>\n\t<li><code>grid[i][j]</code>&nbsp;只含有&nbsp;<code>'.'</code>,&nbsp;<code>'#'</code>,&nbsp;<code>'@'</code>,&nbsp;<code>'a'-</code><code>'f</code><code>'</code>&nbsp;以及&nbsp;<code>'A'-'F'</code></li>\n\t<li>钥匙的数目范围是&nbsp;<code>[1, 6]</code>&nbsp;</li>\n\t<li>每个钥匙都对应一个 <strong>不同</strong> 的字母</li>\n\t<li>每个钥匙正好打开一个对应的锁</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 865.具有所有最深节点的最小子树",
        "hardRate": "MEDIUM",
        "passRate": "68.91%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/solution",
        "problemsDesc": "<p>给定一个根为&nbsp;<code>root</code>&nbsp;的二叉树，每个节点的深度是 <strong>该节点到根的最短距离</strong> 。</p>\n\n<p>返回包含原始树中所有 <strong>最深节点</strong> 的 <em>最小子树</em> 。</p>\n\n<p>如果一个节点在 <strong>整个树 </strong>的任意节点之间具有最大的深度，则该节点是 <strong>最深的</strong> 。</p>\n\n<p>一个节点的 <strong>子树</strong> 是该节点加上它的所有后代的集合。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png\" style=\"width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4]\n<strong>输出：</strong>[2,7,4]\n<strong>解释：</strong>\n我们返回值为 2 的节点，在图中用黄色标记。\n在图中用蓝色标记的是树的最深的节点。\n注意，节点 5、3 和 2 包含树中最深的节点，但节点 2 的子树最小，因此我们返回它。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[1]\n<strong>解释：</strong>根节点是树中最深的节点。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [0,1,3,null,2]\n<strong>输出：</strong>[2]\n<strong>解释：</strong>树中最深的节点为 2 ，有效子树为节点 2、1 和 0 的子树，但节点 2 的子树最小。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数量在<meta charset=\"UTF-8\" />&nbsp;<code>[1, 500]</code>&nbsp;范围内。</li>\n\t<li><code>0 &lt;= Node.val &lt;= 500</code></li>\n\t<li>每个节点的值都是 <strong>独一无二</strong> 的。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与力扣 1123 重复：<a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/\" target=\"_blank\">https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 866.回文素数",
        "hardRate": "MEDIUM",
        "passRate": "23.84%",
        "problemsUrl": "https://leetcode.cn/problems/prime-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/prime-palindrome/solution",
        "problemsDesc": "<p>求出大于或等于&nbsp;<code>N</code>&nbsp;的最小回文素数。</p>\n\n<p>回顾一下，如果一个数大于 1，且其因数只有 1 和它自身，那么这个数是<em>素数</em>。</p>\n\n<p>例如，2，3，5，7，11 以及&nbsp;13 是素数。</p>\n\n<p>回顾一下，如果一个数从左往右读与从右往左读是一样的，那么这个数是<em>回文数。</em></p>\n\n<p>例如，12321 是回文数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>6\n<strong>输出：</strong>7\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre><strong>输入：</strong>8\n<strong>输出：</strong>11\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre><strong>输入：</strong>13\n<strong>输出：</strong>101</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= N &lt;= 10^8</code></li>\n\t<li>答案肯定存在，且小于&nbsp;<code>2 * 10^8</code>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 867.转置矩阵",
        "hardRate": "EASY",
        "passRate": "66.77%",
        "problemsUrl": "https://leetcode.cn/problems/transpose-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/transpose-matrix/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>matrix</code>， 返回 <code>matrix</code> 的 <strong>转置矩阵</strong> 。</p>\n\n<p>矩阵的 <strong>转置</strong> 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/10/hint_transpose.png\" style=\"width: 600px; height: 197px;\" /></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>[[1,4,7],[2,5,8],[3,6,9]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3],[4,5,6]]\n<strong>输出：</strong>[[1,4],[2,5],[3,6]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 <= m, n <= 1000</code></li>\n\t<li><code>1 <= m * n <= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> <= matrix[i][j] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 868.二进制间距",
        "hardRate": "EASY",
        "passRate": "69.35%",
        "problemsUrl": "https://leetcode.cn/problems/binary-gap/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-gap/solution",
        "problemsDesc": "<p>给定一个正整数 <code>n</code>，找到并返回 <code>n</code> 的二进制表示中两个 <strong>相邻</strong> 1 之间的<strong> 最长距离 </strong>。如果不存在两个相邻的 1，返回 <code>0</code> 。</p>\n\n<p>如果只有 <code>0</code> 将两个 <code>1</code> 分隔开（可能不存在 <code>0</code> ），则认为这两个 1 彼此 <strong>相邻</strong> 。两个 <code>1</code> 之间的距离是它们的二进制表示中位置的绝对差。例如，<code>\"1001\"</code> 中的两个 <code>1</code> 的距离为 3 。</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 22\n<strong>输出：</strong>2\n<strong>解释：</strong>22 的二进制是 \"10110\" 。\n在 22 的二进制表示中，有三个 1，组成两对相邻的 1 。\n第一对相邻的 1 中，两个 1 之间的距离为 2 。\n第二对相邻的 1 中，两个 1 之间的距离为 1 。\n答案取两个距离之中最大的，也就是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 8\n<strong>输出：</strong>0\n<strong>解释：</strong>8 的二进制是 \"1000\" 。\n在 8 的二进制表示中没有相邻的两个 1，所以返回 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>5 的二进制是 \"101\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 869.重新排序得到 2 的幂",
        "hardRate": "MEDIUM",
        "passRate": "63.60%",
        "problemsUrl": "https://leetcode.cn/problems/reordered-power-of-2/",
        "solutionsUrl": "https://leetcode.cn/problems/reordered-power-of-2/solution",
        "problemsDesc": "<p>给定正整数&nbsp;<code>n</code>&nbsp;，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。</p>\n\n<p>如果我们可以通过上述方式得到&nbsp;2 的幂，返回 <code>true</code>；否则，返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 870.优势洗牌",
        "hardRate": "MEDIUM",
        "passRate": "50.40%",
        "problemsUrl": "https://leetcode.cn/problems/advantage-shuffle/",
        "solutionsUrl": "https://leetcode.cn/problems/advantage-shuffle/solution",
        "problemsDesc": "<p>给定两个长度相等的数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>，<code>nums1</code>&nbsp;相对于 <code>nums2</code> 的<em>优势</em>可以用满足&nbsp;<code>nums1[i] &gt; nums2[i]</code>&nbsp;的索引 <code>i</code>&nbsp;的数目来描述。</p>\n\n<p>返回 <font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\" size=\"1\"><span style=\"background-color: rgb(249, 242, 244);\">nums1</span></font>&nbsp;的<strong>任意</strong>排列，使其相对于 <code>nums2</code>&nbsp;的优势最大化。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [2,7,11,15], nums2 = [1,10,4,11]\n<strong>输出：</strong>[2,11,7,15]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [12,24,8,32], nums2 = [13,25,32,11]\n<strong>输出：</strong>[24,32,8,12]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums2.length == nums1.length</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 871.最低加油次数",
        "hardRate": "HARD",
        "passRate": "43.23%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-refueling-stops/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-refueling-stops/solution",
        "problemsDesc": "<p>汽车从起点出发驶向目的地，该目的地位于出发位置东面 <code>target</code>&nbsp;英里处。</p>\n\n<p>沿途有加油站，用数组&nbsp;<code>stations</code> 表示。其中 <code>stations[i] = [position<sub>i</sub>, fuel<sub>i</sub>]</code> 表示第 <code>i</code> 个加油站位于出发位置东面&nbsp;<code>position<sub>i</sub></code> 英里处，并且有&nbsp;<code>fuel<sub>i</sub></code>&nbsp;升汽油。</p>\n\n<p>假设汽车油箱的容量是无限的，其中最初有&nbsp;<code>startFuel</code>&nbsp;升燃料。它每行驶 1 英里就会用掉 1 升汽油。当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。</p>\n\n<p>为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 <code>-1</code> 。</p>\n\n<p>注意：如果汽车到达加油站时剩余燃料为 <code>0</code>，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 <code>0</code>，仍然认为它已经到达目的地。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 1, startFuel = 1, stations = []\n<strong>输出：</strong>0\n<strong>解释：</strong>可以在不加油的情况下到达目的地。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 100, startFuel = 1, stations = [[10,100]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>无法抵达目的地，甚至无法到达第一个加油站。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n出发时有 10 升燃料。\n开车来到距起点 10 英里处的加油站，消耗 10 升燃料。将汽油从 0 升加到 60 升。\n然后，从 10 英里处的加油站开到 60 英里处的加油站（消耗 50 升燃料），\n并将汽油从 10 升加到 50 升。然后开车抵达目的地。\n沿途在两个加油站停靠，所以返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target, startFuel &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= stations.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= position<sub>i</sub> &lt; position<sub>i+1</sub> &lt; target</code></li>\n\t<li><code>1 &lt;= fuel<sub>i</sub> &lt; 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 872.叶子相似的树",
        "hardRate": "EASY",
        "passRate": "64.99%",
        "problemsUrl": "https://leetcode.cn/problems/leaf-similar-trees/",
        "solutionsUrl": "https://leetcode.cn/problems/leaf-similar-trees/solution",
        "problemsDesc": "<p>请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个&nbsp;<strong>叶值序列 </strong>。</p>\n\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png\" style=\"height: 336px; width: 400px;\" /></p>\n\n<p>举个例子，如上图所示，给定一棵叶值序列为&nbsp;<code>(6, 7, 4, 9, 8)</code>&nbsp;的树。</p>\n\n<p>如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是&nbsp;<em>叶相似&nbsp;</em>的。</p>\n\n<p>如果给定的两个根结点分别为&nbsp;<code>root1</code> 和&nbsp;<code>root2</code>&nbsp;的树是叶相似的，则返回&nbsp;<code>true</code>；否则返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-1.jpg\" style=\"height: 237px; width: 600px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-2.jpg\" style=\"height: 110px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root1 = [1,2,3], root2 = [1,3,2]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给定的两棵树结点数在&nbsp;<code>[1, 200]</code> 范围内</li>\n\t<li>给定的两棵树上的值在&nbsp;<code>[0, 200]</code> 范围内</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 873.最长的斐波那契子序列的长度",
        "hardRate": "MEDIUM",
        "passRate": "56.26%",
        "problemsUrl": "https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/solution",
        "problemsDesc": "<p>如果序列 <code>X_1, X_2, ..., X_n</code> 满足下列条件，就说它是 <em>斐波那契式 </em>的：</p>\n\n<ul>\n\t<li><code>n >= 3</code></li>\n\t<li>对于所有 <code>i + 2 <= n</code>，都有 <code>X_i + X_{i+1} = X_{i+2}</code></li>\n</ul>\n\n<p>给定一个<strong>严格递增</strong>的正整数数组形成序列 arr ，找到 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.600000381469727px\"><span style=\"caret-color:#c7254e\"><span style=\"background-color:#f9f2f4\">arr</span></span></span></font></font> 中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。</p>\n\n<p><em>（回想一下，子序列是从原序列 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.600000381469727px\"><span style=\"caret-color:#c7254e\"><span style=\"background-color:#f9f2f4\">arr</span></span></span></font></font> 中派生出来的，它从 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.600000381469727px\"><span style=\"caret-color:#c7254e\"><span style=\"background-color:#f9f2f4\">arr</span></span></span></font></font> 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， <code>[3, 5, 8]</code> 是 <code>[3, 4, 5, 6, 7, 8]</code> 的一个子序列）</em></p>\n\n<p> </p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>arr =<strong> </strong>[1,2,3,4,5,6,7,8]\n<strong>输出: </strong>5\n<strong>解释: </strong>最长的斐波那契式子序列为 [1,2,3,5,8] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>arr =<strong> </strong>[1,3,7,11,12,14,18]\n<strong>输出: </strong>3\n<strong>解释</strong>: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 <= arr.length <= 1000</code></li>\n\t<li>\n\t<p><code>1 <= arr[i] < arr[i + 1] <= 10^9</code></p>\n\t</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 874.模拟行走机器人",
        "hardRate": "MEDIUM",
        "passRate": "43.09%",
        "problemsUrl": "https://leetcode.cn/problems/walking-robot-simulation/",
        "solutionsUrl": "https://leetcode.cn/problems/walking-robot-simulation/solution",
        "problemsDesc": "<p>机器人在一个无限大小的 XY 网格平面上行走，从点 <code>(0, 0)</code> 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 <code>commands</code> ：</p>\n\n<ul>\n\t<li><code>-2</code> ：向左转 <code>90</code> 度</li>\n\t<li><code>-1</code> ：向右转 <code>90</code> 度</li>\n\t<li><code>1 <= x <= 9</code> ：向前移动 <code>x</code> 个单位长度</li>\n</ul>\n\n<p>在网格上有一些格子被视为障碍物 <code>obstacles</code> 。第 <code>i</code> 个障碍物位于网格点  <code>obstacles[i] = (x<sub>i</sub>, y<sub>i</sub>)</code> 。</p>\n\n<p>机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续尝试进行该路线的其余部分。</p>\n\n<p>返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。（即，如果距离为 <code>5</code> ，则返回 <code>25</code> ）</p>\n\n<div class=\"d-google dictRoot saladict-panel isAnimate\">\n<div>\n<div class=\"MachineTrans-Text\">\n<div class=\"MachineTrans-Lines\">\n<div class=\"MachineTrans-Lines-collapse MachineTrans-lang-en\"> </div>\n</div>\n\n<div class=\"MachineTrans-Lines\">\n<p class=\"MachineTrans-lang-zh-CN\"><strong>注意：</strong></p>\n\n<ul>\n\t<li class=\"MachineTrans-lang-zh-CN\">北表示 <code>+Y</code> 方向。</li>\n\t<li class=\"MachineTrans-lang-zh-CN\">东表示 <code>+X</code> 方向。</li>\n\t<li class=\"MachineTrans-lang-zh-CN\">南表示 <code>-Y</code> 方向。</li>\n\t<li class=\"MachineTrans-lang-zh-CN\">西表示 <code>-X</code> 方向。</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>commands = [4,-1,3], obstacles = []\n<strong>输出：</strong>25\n<strong>解释：\n</strong>机器人开始位于 (0, 0)：\n1. 向北移动 4 个单位，到达 (0, 4)\n2. 右转\n3. 向东移动 3 个单位，到达 (3, 4)\n距离原点最远的是 (3, 4) ，距离为 3<sup>2</sup> + 4<sup>2</sup> = 25</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>commands = [4,-1,4,-2,4], obstacles = [[2,4]]\n<strong>输出：</strong>65\n<strong>解释</strong>：机器人开始位于 (0, 0)：\n1. 向北移动 4 个单位，到达 (0, 4)\n2. 右转\n3. 向东移动 1 个单位，然后被位于 (2, 4) 的障碍物阻挡，机器人停在 (1, 4)\n4. 左转\n5. 向北走 4 个单位，到达 (1, 8)\n距离原点最远的是 (1, 8) ，距离为 1<sup>2</sup> + 8<sup>2</sup> = 65</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= commands.length <= 10<sup>4</sup></code></li>\n\t<li><code>commands[i]</code> is one of the values in the list <code>[-2,-1,1,2,3,4,5,6,7,8,9]</code>.</li>\n\t<li><code>0 <= obstacles.length <= 10<sup>4</sup></code></li>\n\t<li><code>-3 * 10<sup>4</sup> <= x<sub>i</sub>, y<sub>i</sub> <= 3 * 10<sup>4</sup></code></li>\n\t<li>答案保证小于 <code>2<sup>31</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 875.爱吃香蕉的珂珂",
        "hardRate": "MEDIUM",
        "passRate": "49.47%",
        "problemsUrl": "https://leetcode.cn/problems/koko-eating-bananas/",
        "solutionsUrl": "https://leetcode.cn/problems/koko-eating-bananas/solution",
        "problemsDesc": "<p>珂珂喜欢吃香蕉。这里有 <code>n</code> 堆香蕉，第 <code>i</code> 堆中有&nbsp;<code>piles[i]</code>&nbsp;根香蕉。警卫已经离开了，将在 <code>h</code> 小时后回来。</p>\n\n<p>珂珂可以决定她吃香蕉的速度 <code>k</code> （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 <code>k</code> 根。如果这堆香蕉少于 <code>k</code> 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。&nbsp;&nbsp;</p>\n\n<p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p>\n\n<p>返回她可以在 <code>h</code> 小时内吃掉所有香蕉的最小速度 <code>k</code>（<code>k</code> 为整数）。</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [3,6,7,11], h = 8\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [30,11,23,4,20], h = 5\n<strong>输出：</strong>30\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [30,11,23,4,20], h = 6\n<strong>输出：</strong>23\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= piles.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>piles.length &lt;= h &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= piles[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 876.链表的中间结点",
        "hardRate": "EASY",
        "passRate": "70.19%",
        "problemsUrl": "https://leetcode.cn/problems/middle-of-the-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/middle-of-the-linked-list/solution",
        "problemsDesc": "<p>给你单链表的头结点 <code>head</code> ，请你找出并返回链表的中间结点。</p>\n\n<p>如果有两个中间结点，则返回第二个中间结点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg\" style=\"width: 544px; height: 65px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5]\n<strong>输出：</strong>[3,4,5]\n<strong>解释：</strong>链表只有一个中间结点，值为 3 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-midlist2.jpg\" style=\"width: 664px; height: 65px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5,6]\n<strong>输出：</strong>[4,5,6]\n<strong>解释：</strong>该链表有两个中间结点，值分别为 3 和 4 ，返回第二个结点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表的结点数范围是 <code>[1, 100]</code></li>\n\t<li><code>1 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 877.石子游戏",
        "hardRate": "MEDIUM",
        "passRate": "76.46%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game/solution",
        "problemsDesc": "<p>Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，<strong>排成一行</strong>；每堆都有 <strong>正</strong> 整数颗石子，数目为 <code>piles[i]</code>&nbsp;。</p>\n\n<p>游戏以谁手中的石子最多来决出胜负。石子的 <strong>总数</strong> 是 <strong>奇数</strong> ，所以没有平局。</p>\n\n<p>Alice 和 Bob 轮流进行，<strong>Alice 先开始</strong> 。 每回合，玩家从行的 <strong>开始</strong> 或 <strong>结束</strong> 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 <strong>石子最多</strong> 的玩家 <strong>获胜</strong> 。</p>\n\n<p>假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回&nbsp;<code>true</code>&nbsp;，当 Bob 赢得比赛时返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [5,3,4,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>\nAlice 先开始，只能拿前 5 颗或后 5 颗石子 。\n假设他取了前 5 颗，这一行就变成了 [3,4,5] 。\n如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。\n如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。\n这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [3,7,2,3]\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= piles.length &lt;= 500</code></li>\n\t<li><code>piles.length</code> 是 <strong>偶数</strong></li>\n\t<li><code>1 &lt;= piles[i] &lt;= 500</code></li>\n\t<li><code>sum(piles[i])</code>&nbsp;是 <strong>奇数</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 878.第 N 个神奇数字",
        "hardRate": "HARD",
        "passRate": "40.00%",
        "problemsUrl": "https://leetcode.cn/problems/nth-magical-number/",
        "solutionsUrl": "https://leetcode.cn/problems/nth-magical-number/solution",
        "problemsDesc": "<p>一个正整数如果能被 <code>a</code> 或 <code>b</code> 整除，那么它是神奇的。</p>\n\n<p>给定三个整数 <code>n</code> ,&nbsp;<code>a</code> , <code>b</code> ，返回第 <code>n</code> 个神奇的数字。因为答案可能很大，所以返回答案&nbsp;<strong>对&nbsp;</strong><code>10<sup>9</sup>&nbsp;+ 7</code> <strong>取模&nbsp;</strong>后的值。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, a = 2, b = 3\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, a = 2, b = 3\n<strong>输出：</strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n\t<li><code>2 &lt;= a, b &lt;= 4 * 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 879.盈利计划",
        "hardRate": "HARD",
        "passRate": "54.66%",
        "problemsUrl": "https://leetcode.cn/problems/profitable-schemes/",
        "solutionsUrl": "https://leetcode.cn/problems/profitable-schemes/solution",
        "problemsDesc": "<p>集团里有 <code>n</code> 名员工，他们可以完成各种各样的工作创造利润。</p>\n\n<p>第 <code>i</code> 种工作会产生 <code>profit[i]</code> 的利润，它要求 <code>group[i]</code> 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。</p>\n\n<p>工作的任何至少产生 <code>minProfit</code> 利润的子集称为 <strong>盈利计划</strong> 。并且工作的成员总数最多为 <code>n</code> 。</p>\n\n<p>有多少种计划可以选择？因为答案很大，所以<strong> 返回结果模 </strong><code>10^9 + 7</code><strong> 的值</strong>。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, minProfit = 3, group = [2,2], profit = [2,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。\n总的来说，有两种计划。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]\n<strong>输出：</strong>7\n<strong>解释：</strong>至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。\n有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。</pre>\n</div>\n</div>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>0 <= minProfit <= 100</code></li>\n\t<li><code>1 <= group.length <= 100</code></li>\n\t<li><code>1 <= group[i] <= 100</code></li>\n\t<li><code>profit.length == group.length</code></li>\n\t<li><code>0 <= profit[i] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 880.索引处的解码字符串",
        "hardRate": "MEDIUM",
        "passRate": "26.93%",
        "problemsUrl": "https://leetcode.cn/problems/decoded-string-at-index/",
        "solutionsUrl": "https://leetcode.cn/problems/decoded-string-at-index/solution",
        "problemsDesc": "<p>给定一个编码字符串 <code>S</code>。请你找出<em> </em><strong>解码字符串</strong> 并将其写入磁带。解码时，从编码字符串中<strong> 每次读取一个字符 </strong>，并采取以下步骤：</p>\n\n<ul>\n\t<li>如果所读的字符是字母，则将该字母写在磁带上。</li>\n\t<li>如果所读的字符是数字（例如 <code>d</code>），则整个当前磁带总共会被重复写&nbsp;<code>d-1</code> 次。</li>\n</ul>\n\n<p>现在，对于给定的编码字符串 <code>S</code> 和索引 <code>K</code>，查找并返回解码字符串中的第&nbsp;<code>K</code>&nbsp;个字母。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>S = &quot;leet2code3&quot;, K = 10\n<strong>输出：</strong>&quot;o&quot;\n<strong>解释：</strong>\n解码后的字符串为 &quot;leetleetcodeleetleetcodeleetleetcode&quot;。\n字符串中的第 10 个字母是 &quot;o&quot;。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>S = &quot;ha22&quot;, K = 5\n<strong>输出：</strong>&quot;h&quot;\n<strong>解释：</strong>\n解码后的字符串为 &quot;hahahaha&quot;。第 5 个字母是 &quot;h&quot;。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>S = &quot;a2345678999999999999999&quot;, K = 1\n<strong>输出：</strong>&quot;a&quot;\n<strong>解释：</strong>\n解码后的字符串为 &quot;a&quot; 重复 8301530446056247680 次。第 1 个字母是 &quot;a&quot;。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= S.length &lt;= 100</code></li>\n\t<li><code>S</code>&nbsp;只包含小写字母与数字 <code>2</code> 到 <code>9</code> 。</li>\n\t<li><code>S</code>&nbsp;以字母开头。</li>\n\t<li><code>1 &lt;= K &lt;= 10^9</code></li>\n\t<li>题目保证 <code>K</code> 小于或等于解码字符串的长度。</li>\n\t<li>解码后的字符串保证少于&nbsp;<code>2^63</code>&nbsp;个字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 881.救生艇",
        "hardRate": "MEDIUM",
        "passRate": "53.73%",
        "problemsUrl": "https://leetcode.cn/problems/boats-to-save-people/",
        "solutionsUrl": "https://leetcode.cn/problems/boats-to-save-people/solution",
        "problemsDesc": "<p>给定数组<meta charset=\"UTF-8\" />&nbsp;<code>people</code>&nbsp;。<code>people[i]</code>表示第 <code>i</code><sup>&nbsp;</sup>个人的体重&nbsp;，<strong>船的数量不限</strong>，每艘船可以承载的最大重量为&nbsp;<code>limit</code>。</p>\n\n<p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为&nbsp;<code>limit</code>。</p>\n\n<p>返回 <em>承载所有人所需的最小船数</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>people = [1,2], limit = 3\n<strong>输出：</strong>1\n<strong>解释：</strong>1 艘船载 (1, 2)\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>people = [3,2,2,1], limit = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>3 艘船分别载 (1, 2), (2) 和 (3)\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>people = [3,5,3,4], limit = 5\n<strong>输出：</strong>4\n<strong>解释：</strong>4 艘船分别载 (3), (3), (4), (5)</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= people.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= people[i] &lt;= limit &lt;= 3 * 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 882.细分图中的可到达节点",
        "hardRate": "HARD",
        "passRate": "64.06%",
        "problemsUrl": "https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/solution",
        "problemsDesc": "<p>给你一个无向图（<strong>原始图</strong>），图中有 <code>n</code> 个节点，编号从 <code>0</code> 到 <code>n - 1</code> 。你决定将图中的每条边 <strong>细分</strong> 为一条节点链，每条边之间的新节点数各不相同。</p>\n\n<p>图用由边组成的二维数组 <code>edges</code> 表示，其中&nbsp;<code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, cnt<sub>i</sub>]</code> 表示原始图中节点&nbsp;<code>u<sub>i</sub></code> 和&nbsp;<code>v<sub>i</sub></code> 之间存在一条边，<code>cnt<sub>i</sub></code> 是将边 <strong>细分</strong> 后的新节点总数。注意，<code>cnt<sub>i</sub> == 0</code> 表示边不可细分。</p>\n\n<p>要 <strong>细分</strong> 边 <code>[ui, vi]</code> ，需要将其替换为 <code>(cnt<sub>i</sub> + 1)</code> 条新边，和&nbsp;<code>cnt<sub>i</sub></code> 个新节点。新节点为 <code>x<sub>1</sub></code>, <code>x<sub>2</sub></code>, ..., <code>x<sub>cnt<sub>i</sub></sub></code> ，新边为 <code>[u<sub>i</sub>, x<sub>1</sub>]</code>, <code>[x<sub>1</sub>, x<sub>2</sub>]</code>, <code>[x<sub>2</sub>, x<sub>3</sub>]</code>, ..., <code>[x<sub>cnt<sub>i</sub>-1</sub>, x<sub>cnt<sub>i</sub></sub>]</code>, <code>[x<sub>cnt<sub>i</sub></sub>, v<sub>i</sub>]</code> 。</p>\n\n<p>现在得到一个&nbsp;<strong>新的细分图</strong> ，请你计算从节点 <code>0</code> 出发，可以到达多少个节点？如果节点间距离是 <code>maxMoves</code> 或更少，则视为 <strong>可以到达</strong> 。</p>\n\n<p>给你原始图和 <code>maxMoves</code> ，返回 <em>新的细分图中从节点 <code>0</code> 出发</em><strong><em> 可到达的节点数</em></strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/01/origfinal.png\" style=\"height: 247px; width: 600px;\" />\n<pre>\n<strong>输入：</strong>edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3\n<strong>输出：</strong>13\n<strong>解释：</strong>边的细分情况如上图所示。\n可以到达的节点已经用黄色标注出来。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4\n<strong>输出：</strong>23\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5\n<strong>输出：</strong>1\n<strong>解释：</strong>节点 0 与图的其余部分没有连通，所以只有节点 0 可以到达。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= edges.length &lt;= min(n * (n - 1) / 2, 10<sup>4</sup>)</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub> &lt; v<sub>i</sub> &lt; n</code></li>\n\t<li>图中 <strong>不存在平行边</strong></li>\n\t<li><code>0 &lt;= cnt<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= maxMoves &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= n &lt;= 3000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 883.三维形体投影面积",
        "hardRate": "EASY",
        "passRate": "76.36%",
        "problemsUrl": "https://leetcode.cn/problems/projection-area-of-3d-shapes/",
        "solutionsUrl": "https://leetcode.cn/problems/projection-area-of-3d-shapes/solution",
        "problemsDesc": "<p>在<meta charset=\"UTF-8\" />&nbsp;<code>n x n</code>&nbsp;的网格<meta charset=\"UTF-8\" />&nbsp;<code>grid</code>&nbsp;中，我们放置了一些与 x，y，z 三轴对齐的<meta charset=\"UTF-8\" />&nbsp;<code>1 x 1 x 1</code>&nbsp;立方体。</p>\n\n<p>每个值&nbsp;<code>v = grid[i][j]</code>&nbsp;表示 <code>v</code>&nbsp;个正方体叠放在单元格&nbsp;<code>(i, j)</code>&nbsp;上。</p>\n\n<p>现在，我们查看这些立方体在 <code>xy</code>&nbsp;、<code>yz</code>&nbsp;和 <code>zx</code>&nbsp;平面上的<em>投影</em>。</p>\n\n<p><strong>投影</strong>&nbsp;就像影子，将 <strong>三维</strong> 形体映射到一个 <strong>二维</strong> 平面上。从顶部、前面和侧面看立方体时，我们会看到“影子”。</p>\n\n<p>返回 <em>所有三个投影的总面积</em> 。</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<ul>\n</ul>\n\n<ul>\n</ul>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/02/shadow.png\" style=\"height: 214px; width: 800px;\" /></p>\n\n<pre>\n<strong>输入：</strong>[[1,2],[3,4]]\n<strong>输出：</strong>17\n<strong>解释：</strong>这里有该形体在三个轴对齐平面上的三个投影(“阴影部分”)。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[2]]\n<strong>输出：</strong>5\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>[[1,0],[0,2]]\n<strong>输出：</strong>8\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 884.两句话中的不常见单词",
        "hardRate": "EASY",
        "passRate": "71.25%",
        "problemsUrl": "https://leetcode.cn/problems/uncommon-words-from-two-sentences/",
        "solutionsUrl": "https://leetcode.cn/problems/uncommon-words-from-two-sentences/solution",
        "problemsDesc": "<p><strong>句子</strong> 是一串由空格分隔的单词。每个 <strong>单词</strong><em> </em>仅由小写字母组成。</p>\n\n<p>如果某个单词在其中一个句子中恰好出现一次，在另一个句子中却 <strong>没有出现</strong> ，那么这个单词就是 <strong>不常见的</strong><em> </em>。</p>\n\n<p>给你两个 <strong>句子</strong> <code>s1</code> 和 <code>s2</code> ，返回所有 <strong>不常用单词</strong> 的列表。返回列表中单词可以按 <strong>任意顺序</strong> 组织。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"this apple is sweet\", s2 = \"this apple is sour\"\n<strong>输出：</strong>[\"sweet\",\"sour\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"apple apple\", s2 = \"banana\"\n<strong>输出：</strong>[\"banana\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 200</code></li>\n\t<li><code>s1</code> 和 <code>s2</code> 由小写英文字母和空格组成</li>\n\t<li><code>s1</code> 和 <code>s2</code> 都不含前导或尾随空格</li>\n\t<li><code>s1</code> 和 <code>s2</code> 中的所有单词间均由单个空格分隔</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 885.螺旋矩阵 III",
        "hardRate": "MEDIUM",
        "passRate": "71.16%",
        "problemsUrl": "https://leetcode.cn/problems/spiral-matrix-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/spiral-matrix-iii/solution",
        "problemsDesc": "<p>在 <code>rows x cols</code> 的网格上，你从单元格 <code>(rStart, cStart)</code> 面朝东面开始。网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。</p>\n\n<p>你需要以顺时针按螺旋状行走，访问此网格中的每个位置。每当移动到网格的边界之外时，需要继续在网格之外行走（但稍后可能会返回到网格边界）。</p>\n\n<p>最终，我们到过网格的所有&nbsp;<code>rows x cols</code>&nbsp;个空间。</p>\n\n<p>按照访问顺序返回表示网格位置的坐标列表。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_1.png\" style=\"width: 174px; height: 99px;\" />\n<pre>\n<strong>输入：</strong>rows = 1, cols = 4, rStart = 0, cStart = 0\n<strong>输出：</strong>[[0,0],[0,1],[0,2],[0,3]]\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_2.png\" style=\"width: 202px; height: 142px;\" />\n<pre>\n<strong>输入：</strong>rows = 5, cols = 6, rStart = 1, cStart = 4\n<strong>输出：</strong>[[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rows, cols &lt;= 100</code></li>\n\t<li><code>0 &lt;= rStart &lt; rows</code></li>\n\t<li><code>0 &lt;= cStart &lt; cols</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 886.可能的二分法",
        "hardRate": "MEDIUM",
        "passRate": "52.09%",
        "problemsUrl": "https://leetcode.cn/problems/possible-bipartition/",
        "solutionsUrl": "https://leetcode.cn/problems/possible-bipartition/solution",
        "problemsDesc": "<p>给定一组&nbsp;<code>n</code>&nbsp;人（编号为&nbsp;<code>1, 2, ..., n</code>），&nbsp;我们想把每个人分进<strong>任意</strong>大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。</p>\n\n<p>给定整数 <code>n</code>&nbsp;和数组 <code>dislikes</code>&nbsp;，其中&nbsp;<code>dislikes[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;，表示不允许将编号为 <code>a<sub>i</sub></code>&nbsp;和&nbsp;&nbsp;<code>b<sub>i</sub></code>的人归入同一组。当可以用这种方法将所有人分进两组时，返回 <code>true</code>；否则返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, dislikes = [[1,2],[1,3],[2,4]]\n<strong>输出：</strong>true\n<strong>解释：</strong>group1 [1,4], group2 [2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, dislikes = [[1,2],[1,3],[2,3]]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2000</code></li>\n\t<li><code>0 &lt;= dislikes.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>dislikes[i].length == 2</code></li>\n\t<li><code>1 &lt;= dislikes[i][j] &lt;= n</code></li>\n\t<li><code>a<sub>i</sub>&nbsp;&lt; b<sub>i</sub></code></li>\n\t<li><code>dislikes</code>&nbsp;中每一组都 <strong>不同</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 887.鸡蛋掉落",
        "hardRate": "HARD",
        "passRate": "30.64%",
        "problemsUrl": "https://leetcode.cn/problems/super-egg-drop/",
        "solutionsUrl": "https://leetcode.cn/problems/super-egg-drop/solution",
        "problemsDesc": "<p>给你 <code>k</code> 枚相同的鸡蛋，并可以使用一栋从第 <code>1</code> 层到第 <code>n</code> 层共有 <code>n</code> 层楼的建筑。</p>\n\n<p>已知存在楼层 <code>f</code> ，满足 <code>0 <= f <= n</code> ，任何从<strong> 高于</strong> <code>f</code> 的楼层落下的鸡蛋都会碎，从 <code>f</code> 楼层或比它低的楼层落下的鸡蛋都不会破。</p>\n\n<p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 <code>x</code> 扔下（满足 <code>1 <= x <= n</code>）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 <strong>重复使用</strong> 这枚鸡蛋。</p>\n\n<p>请你计算并返回要确定 <code>f</code> <strong>确切的值</strong> 的 <strong>最小操作次数</strong> 是多少？</p>\n \n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 1, n = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>\n鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。 \n否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。 \n如果它没碎，那么肯定能得出 f = 2 。 \n因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 2, n = 6\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 3, n = 14\n<strong>输出：</strong>4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= k <= 100</code></li>\n\t<li><code>1 <= n <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 888.公平的糖果交换",
        "hardRate": "EASY",
        "passRate": "63.57%",
        "problemsUrl": "https://leetcode.cn/problems/fair-candy-swap/",
        "solutionsUrl": "https://leetcode.cn/problems/fair-candy-swap/solution",
        "problemsDesc": "<p>爱丽丝和鲍勃拥有不同总数量的糖果。给你两个数组 <code>aliceSizes</code> 和 <code>bobSizes</code> ，<code>aliceSizes[i]</code> 是爱丽丝拥有的第 <code>i</code> 盒糖果中的糖果数量，<code>bobSizes[j]</code> 是鲍勃拥有的第 <code>j</code> 盒糖果中的糖果数量。</p>\n\n<p>两人想要互相交换一盒糖果，这样在交换之后，他们就可以拥有相同总数量的糖果。一个人拥有的糖果总数量是他们每盒糖果数量的总和。</p>\n\n<p>返回一个整数数组 <code>answer</code>，其中 <code>answer[0]</code> 是爱丽丝必须交换的糖果盒中的糖果的数目，<code>answer[1]</code> 是鲍勃必须交换的糖果盒中的糖果的数目。如果存在多个答案，你可以返回其中 <strong>任何一个</strong> 。题目测试用例保证存在与输入对应的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>aliceSizes = [1,1], bobSizes = [2,2]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>aliceSizes = [1,2], bobSizes = [2,3]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>aliceSizes = [2], bobSizes = [1,3]\n<strong>输出：</strong>[2,3]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>aliceSizes = [1,2,5], bobSizes = [2,4]\n<strong>输出：</strong>[5,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= aliceSizes.length, bobSizes.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= aliceSizes[i], bobSizes[j] &lt;= 10<sup>5</sup></code></li>\n\t<li>爱丽丝和鲍勃的糖果总数量不同。</li>\n\t<li>题目数据保证对于给定的输入至少存在一个有效答案。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 889.根据前序和后序遍历构造二叉树",
        "hardRate": "MEDIUM",
        "passRate": "68.01%",
        "problemsUrl": "https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/solution",
        "problemsDesc": "<p>给定两个整数数组，<code>preorder</code>&nbsp;和 <code>postorder</code> ，其中 <code>preorder</code> 是一个具有 <strong>无重复</strong> 值的二叉树的前序遍历，<code>postorder</code> 是同一棵树的后序遍历，重构并返回二叉树。</p>\n\n<p>如果存在多个答案，您可以返回其中 <strong>任何</strong> 一个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/24/lc-prepost.jpg\" style=\"height: 265px; width: 304px;\" /></p>\n\n<pre>\n<strong>输入：</strong>preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\n<strong>输出：</strong>[1,2,3,4,5,6,7]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> preorder = [1], postorder = [1]\n<strong>输出:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= preorder.length &lt;= 30</code></li>\n\t<li><code>1 &lt;= preorder[i] &lt;= preorder.length</code></li>\n\t<li><code>preorder</code>&nbsp;中所有值都 <strong>不同</strong></li>\n\t<li><code>postorder.length == preorder.length</code></li>\n\t<li><code>1 &lt;= postorder[i] &lt;= postorder.length</code></li>\n\t<li><code>postorder</code>&nbsp;中所有值都 <strong>不同</strong></li>\n\t<li>保证 <code>preorder</code>&nbsp;和 <code>postorder</code>&nbsp;是同一棵二叉树的前序遍历和后序遍历</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 890.查找和替换模式",
        "hardRate": "MEDIUM",
        "passRate": "78.58%",
        "problemsUrl": "https://leetcode.cn/problems/find-and-replace-pattern/",
        "solutionsUrl": "https://leetcode.cn/problems/find-and-replace-pattern/solution",
        "problemsDesc": "<p>你有一个单词列表&nbsp;<code>words</code>&nbsp;和一个模式&nbsp;&nbsp;<code>pattern</code>，你想知道 <code>words</code> 中的哪些单词与模式匹配。</p>\n\n<p>如果存在字母的排列 <code>p</code>&nbsp;，使得将模式中的每个字母 <code>x</code> 替换为 <code>p(x)</code> 之后，我们就得到了所需的单词，那么单词与模式是匹配的。</p>\n\n<p><em>（回想一下，字母的排列是从字母到字母的双射：每个字母映射到另一个字母，没有两个字母映射到同一个字母。）</em></p>\n\n<p>返回 <code>words</code> 中与给定模式匹配的单词列表。</p>\n\n<p>你可以按任何顺序返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;], pattern = &quot;abb&quot;\n<strong>输出：</strong>[&quot;mee&quot;,&quot;aqq&quot;]\n<strong>解释：\n</strong>&quot;mee&quot; 与模式匹配，因为存在排列 {a -&gt; m, b -&gt; e, ...}。\n&quot;ccc&quot; 与模式不匹配，因为 {a -&gt; c, b -&gt; c, ...} 不是排列。\n因为 a 和 b 映射到同一个字母。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= pattern.length = words[i].length&nbsp;&lt;= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 891.子序列宽度之和",
        "hardRate": "HARD",
        "passRate": "46.52%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-subsequence-widths/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-subsequence-widths/solution",
        "problemsDesc": "<p>一个序列的 <strong>宽度</strong> 定义为该序列中最大元素和最小元素的差值。</p>\n\n<p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 的所有非空 <strong>子序列</strong> 的 <strong>宽度之和</strong> 。由于答案可能非常大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后的结果。</p>\n\n<p><strong>子序列</strong> 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，<code>[3,6,2,7]</code> 就是数组 <code>[0,3,1,6,2,2,7]</code> 的一个子序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,3]\n<strong>输出：</strong>6\n<strong>解释：</strong>子序列为 [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3] 。\n相应的宽度是 0, 0, 0, 1, 1, 2, 2 。\n宽度之和是 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 892.三维形体的表面积",
        "hardRate": "EASY",
        "passRate": "64.44%",
        "problemsUrl": "https://leetcode.cn/problems/surface-area-of-3d-shapes/",
        "solutionsUrl": "https://leetcode.cn/problems/surface-area-of-3d-shapes/solution",
        "problemsDesc": "<p>给你一个 <code>n * n</code> 的网格&nbsp;<code>grid</code> ，上面放置着一些&nbsp;<code>1 x 1 x 1</code>&nbsp;的正方体。每个值&nbsp;<code>v = grid[i][j]</code>&nbsp;表示&nbsp;<code>v</code>&nbsp;个正方体叠放在对应单元格&nbsp;<code>(i, j)</code>&nbsp;上。</p>\n\n<p>放置好正方体后，任何直接相邻的正方体都会互相粘在一起，形成一些不规则的三维形体。</p>\n\n<p>请你返回最终这些形体的总表面积。</p>\n\n<p><strong>注意：</strong>每个形体的底面也需要计入表面积中。</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/08/tmp-grid2.jpg\" style=\"height: 80px; width: 80px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,2],[3,4]]\n<strong>输出：</strong>34\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/08/tmp-grid4.jpg\" style=\"height: 100px; width: 100px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,1,1],[1,0,1],[1,1,1]]\n<strong>输出：</strong>32\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/08/tmp-grid5.jpg\" style=\"height: 100px; width: 100px;\" />\n<pre>\n<strong>输入：</strong>grid = [[2,2,2],[2,1,2],[2,2,2]]\n<strong>输出：</strong>46\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 893.特殊等价字符串组",
        "hardRate": "MEDIUM",
        "passRate": "73.00%",
        "problemsUrl": "https://leetcode.cn/problems/groups-of-special-equivalent-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/groups-of-special-equivalent-strings/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>words</code>。</p>\n\n<p>一步操作中，你可以交换字符串 <code>words[i]</code> 的任意两个偶数下标对应的字符或任意两个奇数下标对应的字符。</p>\n\n<p>对两个字符串&nbsp;<code>words[i]</code> 和 <code>words[j]</code> 而言，如果经过任意次数的操作，<code>words[i] == words[j]</code> ，那么这两个字符串是 <strong>特殊等价 </strong>的。</p>\n\n<ul>\n\t<li>例如，<code>words[i] = \"zzxy\"</code> 和 <code>words[j] = \"xyzz\"</code> 是一对 <strong>特殊等价</strong> 字符串，因为可以按 <code>\"zzxy\" -&gt; \"xzzy\" -&gt; \"xyzz\"</code> 的操作路径使&nbsp;<code>words[i] == words[j]</code> 。</li>\n</ul>\n\n<p>现在规定，<strong><code>words</code> </strong>的 <strong>一组特殊等价字符串 </strong>就是 <code>words</code> 的一个同时满足下述条件的非空子集：</p>\n\n<ul>\n\t<li>该组中的每一对字符串都是<strong> 特殊等价 </strong>的</li>\n\t<li>该组字符串已经涵盖了该类别中的所有特殊等价字符串，容量达到理论上的最大值（也就是说，如果一个字符串不在该组中，那么这个字符串就 <strong>不会</strong> 与该组内任何字符串特殊等价）</li>\n</ul>\n\n<p>返回 <code>words</code> 中 <strong>特殊等价字符串组</strong> 的数量。</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"abcd\",\"cdab\",\"cbad\",\"xyzz\",\"zzxy\",\"zzyx\"]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n其中一组为 [\"abcd\", \"cdab\", \"cbad\"]，因为它们是成对的特殊等价字符串，且没有其他字符串与这些字符串特殊等价。\n另外两组分别是 [\"xyzz\", \"zzxy\"] 和 [\"zzyx\"]。特别需要注意的是，\"zzxy\" 不与 \"zzyx\" 特殊等价。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\n<strong>输出：</strong>3\n<strong>解释：</strong>3 组 [\"abc\",\"cba\"]，[\"acb\",\"bca\"]，[\"bac\",\"cab\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 20</code></li>\n\t<li>所有 <code>words[i]</code>&nbsp;都只由小写字母组成。</li>\n\t<li>所有 <code>words[i]</code>&nbsp;都具有相同的长度。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 894.所有可能的真二叉树",
        "hardRate": "MEDIUM",
        "passRate": "77.67%",
        "problemsUrl": "https://leetcode.cn/problems/all-possible-full-binary-trees/",
        "solutionsUrl": "https://leetcode.cn/problems/all-possible-full-binary-trees/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，请你找出所有可能含 <code>n</code> 个节点的 <strong>真二叉树</strong> ，并以列表形式返回。答案中每棵树的每个节点都必须符合 <code>Node.val == 0</code> 。</p>\n\n<p>答案的每个元素都是一棵真二叉树的根节点。你可以按 <strong>任意顺序</strong> 返回最终的真二叉树列表<strong>。</strong></p>\n\n<p><strong>真二叉树</strong> 是一类二叉树，树中每个节点恰好有 <code>0</code> 或 <code>2</code> 个子节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png\" style=\"width: 700px; height: 400px;\" />\n<pre>\n<strong>输入：</strong>n = 7\n<strong>输出：</strong>[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>[[0,0,0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 895.最大频率栈",
        "hardRate": "HARD",
        "passRate": "64.38%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-frequency-stack/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-frequency-stack/solution",
        "problemsDesc": "<p>设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出<strong>出现频率</strong>最高的元素。</p>\n\n<p>实现 <code>FreqStack</code>&nbsp;类:</p>\n\n<ul>\n\t<li><meta charset=\"UTF-8\" /><code>FreqStack()</code>&nbsp;构造一个空的堆栈。</li>\n\t<li><meta charset=\"UTF-8\" /><code>void push(int val)</code>&nbsp;将一个整数&nbsp;<code>val</code>&nbsp;压入栈顶。</li>\n\t<li><meta charset=\"UTF-8\" /><code>int pop()</code>&nbsp;删除并返回堆栈中出现频率最高的元素。\n\t<ul>\n\t\t<li>如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"FreqStack\",\"push\",\"push\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"pop\",\"pop\",\"pop\"],\n[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]\n<strong>输出：</strong>[null,null,null,null,null,null,null,5,7,5,4]\n<strong>解释：</strong>\nFreqStack = new FreqStack();\nfreqStack.push (5);//堆栈为 [5]\nfreqStack.push (7);//堆栈是 [5,7]\nfreqStack.push (5);//堆栈是 [5,7,5]\nfreqStack.push (7);//堆栈是 [5,7,5,7]\nfreqStack.push (4);//堆栈是 [5,7,5,7,4]\nfreqStack.push (5);//堆栈是 [5,7,5,7,4,5]\nfreqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。\nfreqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。\nfreqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。\nfreqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= val &lt;= 10<sup>9</sup></code></li>\n\t<li><code>push</code>&nbsp;和 <code>pop</code>&nbsp;的操作数不大于 <code>2 * 10<sup>4</sup></code>。</li>\n\t<li>输入保证在调用&nbsp;<code>pop</code>&nbsp;之前堆栈中至少有一个元素。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 896.单调数列",
        "hardRate": "EASY",
        "passRate": "57.04%",
        "problemsUrl": "https://leetcode.cn/problems/monotonic-array/",
        "solutionsUrl": "https://leetcode.cn/problems/monotonic-array/solution",
        "problemsDesc": "<p>如果数组是单调递增或单调递减的，那么它是&nbsp;<strong>单调 </strong><em>的</em>。</p>\n\n<p>如果对于所有 <code>i &lt;= j</code>，<code>nums[i] &lt;= nums[j]</code>，那么数组 <code>nums</code> 是单调递增的。 如果对于所有 <code>i &lt;= j</code>，<code>nums[i]&gt; = nums[j]</code>，那么数组 <code>nums</code>&nbsp;是单调递减的。</p>\n\n<p>当给定的数组 <code>nums</code>&nbsp;是单调数组时返回 <code>true</code>，否则返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2,3]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [6,5,4,4]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,2]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 897.递增顺序搜索树",
        "hardRate": "EASY",
        "passRate": "74.02%",
        "problemsUrl": "https://leetcode.cn/problems/increasing-order-search-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/increasing-order-search-tree/solution",
        "problemsDesc": "<p>给你一棵二叉搜索树的<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;，请你 <strong>按中序遍历</strong> 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg\" style=\"height: 350px; width: 600px;\" />\n<pre>\n<strong>输入：</strong>root = [5,3,6,2,4,null,8,1,null,null,null,7,9]\n<strong>输出：</strong>[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/17/ex2.jpg\" style=\"height: 114px; width: 300px;\" />\n<pre>\n<strong>输入：</strong>root = [5,1,7]\n<strong>输出：</strong>[1,null,5,null,7]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数的取值范围是 <code>[1, 100]</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 898.子数组按位或操作",
        "hardRate": "MEDIUM",
        "passRate": "39.09%",
        "problemsUrl": "https://leetcode.cn/problems/bitwise-ors-of-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/bitwise-ors-of-subarrays/solution",
        "problemsDesc": "<p>我们有一个非负整数数组<meta charset=\"UTF-8\" />&nbsp;<code>arr</code>&nbsp;。</p>\n\n<p>对于每个（连续的）子数组<meta charset=\"UTF-8\" />&nbsp;<code>sub = [arr[i], arr[i + 1], ..., arr[j]]</code>&nbsp;（&nbsp;<code>i &lt;= j</code>），我们对<meta charset=\"UTF-8\" />&nbsp;<code>sub</code>&nbsp;中的每个元素进行按位或操作，获得结果<meta charset=\"UTF-8\" />&nbsp;<code>arr[i] | arr[i + 1] | ... | arr[j]</code>&nbsp;。</p>\n\n<p>返回可能结果的数量。 多次出现的结果在最终答案中仅计算一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n只有一个可能的结果 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,1,2]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n可能的子数组为 [1]，[1]，[2]，[1, 1]，[1, 2]，[1, 1, 2]。\n产生的结果为 1，1，2，1，3，3 。\n有三个唯一值，所以答案是 3 。\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,4]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n可能的结果是 1，2，3，4，6，以及 7 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i]&nbsp;&lt;= 10<sup>9</sup></code>​​​​​​​</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 899.有序队列",
        "hardRate": "HARD",
        "passRate": "64.12%",
        "problemsUrl": "https://leetcode.cn/problems/orderly-queue/",
        "solutionsUrl": "https://leetcode.cn/problems/orderly-queue/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>&nbsp;。你可以从 <code>s</code> 的前 <code>k</code> 个字母中选择一个，并把它加到字符串的末尾。</p>\n\n<p>返回 <em>在应用上述步骤的任意数量的移动后，字典上最小的字符串&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"cba\", k = 1\n<strong>输出：</strong>\"acb\"\n<strong>解释：</strong>\n在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “bac”。\n在第二步中，我们将第一个字符（“b”）移动到最后，获得最终结果 “acb”。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"baaca\", k = 3\n<strong>输出：</strong>\"aaabc\"\n<strong>解释：\n</strong>在第一步中，我们将第一个字符（“b”）移动到最后，获得字符串 “aacab”。\n在第二步中，我们将第三个字符（“c”）移动到最后，获得最终结果 “aaabc”。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k&nbsp;&lt;= S.length&nbsp;&lt;= 1000</code></li>\n\t<li><code>s</code>&nbsp;只由小写字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 900.RLE 迭代器",
        "hardRate": "MEDIUM",
        "passRate": "51.27%",
        "problemsUrl": "https://leetcode.cn/problems/rle-iterator/",
        "solutionsUrl": "https://leetcode.cn/problems/rle-iterator/solution",
        "problemsDesc": "<p>我们可以使用游程编码(即&nbsp;<strong>RLE&nbsp;</strong>)来编码一个整数序列。在偶数长度&nbsp;<code>encoding</code>&nbsp;( <strong>从 0 开始</strong> )的游程编码数组中，对于所有偶数 <code>i</code> ，<code>encoding[i]</code>&nbsp;告诉我们非负整数&nbsp;<code>encoding[i + 1]</code>&nbsp;在序列中重复的次数。</p>\n\n<ul>\n\t<li>例如，序列&nbsp;<code>arr = [8,8,8,5,5]</code>&nbsp;可以被编码为 <code>encoding =[3,8,2,5]</code> 。<code>encoding =[3,8,0,9,2,5]</code>&nbsp;和 <code>encoding =[2,8,1,8,2,5]</code> 也是&nbsp;<code>arr</code> 有效的 <strong>RLE</strong> 。</li>\n</ul>\n\n<p>给定一个游程长度的编码数组，设计一个迭代器来遍历它。</p>\n\n<p>实现 <code>RLEIterator</code> 类:</p>\n\n<ul>\n\t<li><code>RLEIterator(int[] encoded)</code>&nbsp;用编码后的数组初始化对象。</li>\n\t<li><code>int next(int n)</code> 以这种方式耗尽后 <code>n</code> 个元素并返回最后一个耗尽的元素。如果没有剩余的元素要耗尽，则返回 <code>-1</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：\n</strong>[\"RLEIterator\",\"next\",\"next\",\"next\",\"next\"]\n[[[3,8,0,9,2,5]],[2],[1],[1],[2]]\n<strong>输出：\n</strong>[null,8,8,5,-1]\n<strong>解释：</strong>\nRLEIterator rLEIterator = new RLEIterator([3, 8, 0, 9, 2, 5]); // 这映射到序列 [8,8,8,5,5]。\nrLEIterator.next(2); // 耗去序列的 2 个项，返回 8。现在剩下的序列是 [8, 5, 5]。\nrLEIterator.next(1); // 耗去序列的 1 个项，返回 8。现在剩下的序列是 [5, 5]。\nrLEIterator.next(1); // 耗去序列的 1 个项，返回 5。现在剩下的序列是 [5]。\nrLEIterator.next(2); // 耗去序列的 2 个项，返回 -1。 这是由于第一个被耗去的项是 5，\n但第二个项并不存在。由于最后一个要耗去的项不存在，我们返回 -1。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= encoding.length &lt;= 1000</code></li>\n\t<li><code>encoding.length</code>&nbsp;为偶</li>\n\t<li><code>0 &lt;= encoding[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n\t<li>每个测试用例调用<code>next </code>不高于&nbsp;<code>1000</code>&nbsp;次&nbsp;</li>\n</ul>\n",
        "isPlus": false
    }
]