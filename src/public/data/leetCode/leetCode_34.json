[
    {
        "problemsName": " 2476.二叉搜索树最近节点查询",
        "hardRate": "MEDIUM",
        "passRate": "41.51%",
        "problemsUrl": "https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/solution",
        "problemsDesc": "<p>给你一个 <strong>二叉搜索树</strong> 的根节点 <code>root</code> ，和一个由正整数组成、长度为 <code>n</code> 的数组 <code>queries</code> 。</p>\n\n<p>请你找出一个长度为 <code>n</code> 的 <strong>二维</strong> 答案数组 <code>answer</code> ，其中 <code>answer[i] = [min<sub>i</sub>, max<sub>i</sub>]</code> ：</p>\n\n<ul>\n\t<li><code>min<sub>i</sub></code> 是树中小于等于&nbsp;<code>queries[i]</code> 的 <strong>最大值</strong> 。如果不存在这样的值，则使用 <code>-1</code> 代替。</li>\n\t<li><code>max<sub>i</sub></code> 是树中大于等于&nbsp;<code>queries[i]</code> 的 <strong>最小值</strong> 。如果不存在这样的值，则使用 <code>-1</code> 代替。</li>\n</ul>\n\n<p>返回数组 <code>answer</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1 ：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/28/bstreeedrawioo.png\" style=\"width: 261px; height: 281px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]\n<strong>输出：</strong>[[2,2],[4,6],[15,-1]]\n<strong>解释：</strong>按下面的描述找出并返回查询的答案：\n- 树中小于等于 2 的最大值是 2 ，且大于等于 2 的最小值也是 2 。所以第一个查询的答案是 [2,2] 。\n- 树中小于等于 5 的最大值是 4 ，且大于等于 5 的最小值是 6 。所以第二个查询的答案是 [4,6] 。\n- 树中小于等于 16 的最大值是 15 ，且大于等于 16 的最小值不存在。所以第三个查询的答案是 [15,-1] 。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/28/bstttreee.png\" style=\"width: 101px; height: 121px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [4,null,9], queries = [3]\n<strong>输出：</strong>[[-1,4]]\n<strong>解释：</strong>树中不存在小于等于 3 的最大值，且大于等于 3 的最小值是 4 。所以查询的答案是 [-1,4] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[2, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>\n\t<li><code>n == queries.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= queries[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2477.到达首都的最少油耗",
        "hardRate": "MEDIUM",
        "passRate": "53.00%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/solution",
        "problemsDesc": "<p>给你一棵 <code>n</code>&nbsp;个节点的树（一个无向、连通、无环图），每个节点表示一个城市，编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，且恰好有&nbsp;<code>n - 1</code>&nbsp;条路。<code>0</code>&nbsp;是首都。给你一个二维整数数组&nbsp;<code>roads</code>&nbsp;，其中&nbsp;<code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;，表示城市&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条&nbsp;<strong>双向路</strong>&nbsp;。</p>\n\n<p>每个城市里有一个代表，他们都要去首都参加一个会议。</p>\n\n<p>每座城市里有一辆车。给你一个整数&nbsp;<code>seats</code>&nbsp;表示每辆车里面座位的数目。</p>\n\n<p>城市里的代表可以选择乘坐所在城市的车，或者乘坐其他城市的车。相邻城市之间一辆车的油耗是一升汽油。</p>\n\n<p>请你返回到达首都最少需要多少升汽油。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/22/a4c380025e3ff0c379525e96a7d63a3.png\" style=\"width: 303px; height: 332px;\"></p>\n\n<pre><b>输入：</b>roads = [[0,1],[0,2],[0,3]], seats = 5\n<b>输出：</b>3\n<b>解释：</b>\n- 代表 1 直接到达首都，消耗 1 升汽油。\n- 代表 2 直接到达首都，消耗 1 升汽油。\n- 代表 3 直接到达首都，消耗 1 升汽油。\n最少消耗 3 升汽油。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/16/2.png\" style=\"width: 274px; height: 340px;\"></p>\n\n<pre><b>输入：</b>roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2\n<b>输出：</b>7\n<b>解释：</b>\n- 代表 2 到达城市 3 ，消耗 1 升汽油。\n- 代表 2 和代表 3 一起到达城市 1 ，消耗 1 升汽油。\n- 代表 2 和代表 3 一起到达首都，消耗 1 升汽油。\n- 代表 1 直接到达首都，消耗 1 升汽油。\n- 代表 5 直接到达首都，消耗 1 升汽油。\n- 代表 6 到达城市 4 ，消耗 1 升汽油。\n- 代表 4 和代表 6 一起到达首都，消耗 1 升汽油。\n最少消耗 7 升汽油。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/27/efcf7f7be6830b8763639cfd01b690a.png\" style=\"width: 108px; height: 86px;\"></p>\n\n<pre><b>输入：</b>roads = [], seats = 1\n<b>输出：</b>0\n<b>解释：</b>没有代表需要从别的城市到达首都。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>roads.length == n - 1</code></li>\n\t<li><code>roads[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>roads</code>&nbsp;表示一棵合法的树。</li>\n\t<li><code>1 &lt;= seats &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2478.完美分割的方案数",
        "hardRate": "HARD",
        "passRate": "39.90%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-beautiful-partitions/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-beautiful-partitions/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，每个字符是数字&nbsp;<code>'1'</code>&nbsp;到&nbsp;<code>'9'</code>&nbsp;，再给你两个整数&nbsp;<code>k</code> 和&nbsp;<code>minLength</code>&nbsp;。</p>\n\n<p>如果对 <code>s</code>&nbsp;的分割满足以下条件，那么我们认为它是一个 <strong>完美</strong>&nbsp;分割：</p>\n\n<ul>\n\t<li><code>s</code>&nbsp;被分成 <code>k</code>&nbsp;段互不相交的子字符串。</li>\n\t<li>每个子字符串长度都 <strong>至少</strong>&nbsp;为&nbsp;<code>minLength</code>&nbsp;。</li>\n\t<li>每个子字符串的第一个字符都是一个 <b>质数</b> 数字，最后一个字符都是一个 <strong>非质数</strong>&nbsp;数字。质数数字为&nbsp;<code>'2'</code>&nbsp;，<code>'3'</code>&nbsp;，<code>'5'</code>&nbsp;和&nbsp;<code>'7'</code>&nbsp;，剩下的都是非质数数字。</li>\n</ul>\n\n<p>请你返回 <code>s</code>&nbsp;的 <strong>完美</strong>&nbsp;分割数目。由于答案可能很大，请返回答案对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后的结果。</p>\n\n<p>一个 <strong>子字符串</strong>&nbsp;是字符串中一段连续字符串序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"23542185131\", k = 3, minLength = 2\n<b>输出：</b>3\n<b>解释：</b>存在 3 种完美分割方案：\n\"2354 | 218 | 5131\"\n\"2354 | 21851 | 31\"\n\"2354218 | 51 | 31\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"23542185131\", k = 3, minLength = 3\n<b>输出：</b>1\n<b>解释：</b>存在一种完美分割方案：\"2354 | 218 | 5131\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"3312958\", k = 3, minLength = 1\n<b>输出：</b>1\n<b>解释：</b>存在一种完美分割方案：\"331 | 29 | 58\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k, minLength &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code>&nbsp;每个字符都为数字&nbsp;<code>'1'</code>&nbsp;到&nbsp;<code>'9'</code> 之一。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2479.两个不重叠子树的最大异或值",
        "hardRate": "HARD",
        "passRate": "65.74%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-xor-of-two-non-overlapping-subtrees/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-xor-of-two-non-overlapping-subtrees/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2480.形成化学键",
        "hardRate": "EASY",
        "passRate": "84.40%",
        "problemsUrl": "https://leetcode.cn/problems/form-a-chemical-bond/",
        "solutionsUrl": "https://leetcode.cn/problems/form-a-chemical-bond/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2481.分割圆的最少切割次数",
        "hardRate": "EASY",
        "passRate": "58.68%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cuts-to-divide-a-circle/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cuts-to-divide-a-circle/solution",
        "problemsDesc": "<p>圆内一个 <strong>有效切割</strong>&nbsp;，符合以下二者之一：</p>\n\n<ul>\n\t<li>该切割是两个端点在圆上的线段，且该线段经过圆心。</li>\n\t<li>该切割是一端在圆心另一端在圆上的线段。</li>\n</ul>\n\n<p>一些有效和无效的切割如下图所示。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/29/alldrawio.png\" style=\"width: 450px; height: 174px;\" /></p>\n\n<p>给你一个整数&nbsp;<code>n</code>&nbsp;，请你返回将圆切割成相等的&nbsp;<code>n</code>&nbsp;等分的&nbsp;<strong>最少</strong>&nbsp;切割次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/24/11drawio.png\" style=\"width: 200px; height: 200px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 4\n<b>输出：</b>2\n<b>解释：</b>\n上图展示了切割圆 2 次，得到四等分。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/24/22drawio.png\" style=\"width: 200px; height: 201px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 3\n<b>输出：</b>3\n<strong>解释：</strong>\n最少需要切割 3 次，将圆切成三等分。\n少于 3 次切割无法将圆切成大小相等面积相同的 3 等分。\n同时可以观察到，第一次切割无法将圆切割开。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2482.行和列中一和零的差值",
        "hardRate": "MEDIUM",
        "passRate": "82.40%",
        "problemsUrl": "https://leetcode.cn/problems/difference-between-ones-and-zeros-in-row-and-column/",
        "solutionsUrl": "https://leetcode.cn/problems/difference-between-ones-and-zeros-in-row-and-column/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;二进制矩阵&nbsp;<code>grid</code>&nbsp;。</p>\n\n<p>我们按照如下过程，定义一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;差值矩阵&nbsp;<code>diff</code>&nbsp;：</p>\n\n<ul>\n\t<li>令第&nbsp;<code>i</code>&nbsp;行一的数目为&nbsp;<code>onesRow<sub>i</sub></code>&nbsp;。</li>\n\t<li>令第&nbsp;<code>j</code>&nbsp;列一的数目为&nbsp;<code>onesCol<sub>j</sub></code><sub>&nbsp;</sub>。</li>\n\t<li>令第&nbsp;<code>i</code>&nbsp;行零的数目为&nbsp;<code>zerosRow<sub>i</sub></code>&nbsp;。</li>\n\t<li>令第&nbsp;<code>j</code>&nbsp;列零的数目为&nbsp;<code>zerosCol<sub>j</sub></code>&nbsp;。</li>\n\t<li><code>diff[i][j] = onesRow<sub>i</sub> + onesCol<sub>j</sub> - zerosRow<sub>i</sub> - zerosCol<sub>j</sub></code></li>\n</ul>\n\n<p>请你返回差值矩阵<em>&nbsp;</em><code>diff</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2022/11/06/image-20221106171729-5.png\" style=\"width: 400px; height: 208px;\"></p>\n\n<pre><b>输入：</b>grid = [[0,1,1],[1,0,1],[0,0,1]]\n<b>输出：</b>[[0,0,4],[0,0,4],[-2,-2,2]]\n<b>解释：</b>\n- diff[0][0] = <code>onesRow<sub>0</sub> + onesCol<sub>0</sub> - zerosRow<sub>0</sub> - zerosCol<sub>0</sub></code> = 2 + 1 - 1 - 2 = 0 \n- diff[0][1] = <code>onesRow<sub>0</sub> + onesCol<sub>1</sub> - zerosRow<sub>0</sub> - zerosCol<sub>1</sub></code> = 2 + 1 - 1 - 2 = 0 \n- diff[0][2] = <code>onesRow<sub>0</sub> + onesCol<sub>2</sub> - zerosRow<sub>0</sub> - zerosCol<sub>2</sub></code> = 2 + 3 - 1 - 0 = 4 \n- diff[1][0] = <code>onesRow<sub>1</sub> + onesCol<sub>0</sub> - zerosRow<sub>1</sub> - zerosCol<sub>0</sub></code> = 2 + 1 - 1 - 2 = 0 \n- diff[1][1] = <code>onesRow<sub>1</sub> + onesCol<sub>1</sub> - zerosRow<sub>1</sub> - zerosCol<sub>1</sub></code> = 2 + 1 - 1 - 2 = 0 \n- diff[1][2] = <code>onesRow<sub>1</sub> + onesCol<sub>2</sub> - zerosRow<sub>1</sub> - zerosCol<sub>2</sub></code> = 2 + 3 - 1 - 0 = 4 \n- diff[2][0] = <code>onesRow<sub>2</sub> + onesCol<sub>0</sub> - zerosRow<sub>2</sub> - zerosCol<sub>0</sub></code> = 1 + 1 - 2 - 2 = -2\n- diff[2][1] = <code>onesRow<sub>2</sub> + onesCol<sub>1</sub> - zerosRow<sub>2</sub> - zerosCol<sub>1</sub></code> = 1 + 1 - 2 - 2 = -2\n- diff[2][2] = <code>onesRow<sub>2</sub> + onesCol<sub>2</sub> - zerosRow<sub>2</sub> - zerosCol<sub>2</sub></code> = 1 + 3 - 2 - 0 = 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2022/11/06/image-20221106171747-6.png\" style=\"width: 358px; height: 150px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,1,1],[1,1,1]]\n<b>输出：</b>[[5,5,5],[5,5,5]]\n<strong>解释：</strong>\n- diff[0][0] = onesRow<sub>0</sub> + onesCol<sub>0</sub> - zerosRow<sub>0</sub> - zerosCol<sub>0</sub> = 3 + 2 - 0 - 0 = 5\n- diff[0][1] = onesRow<sub>0</sub> + onesCol<sub>1</sub> - zerosRow<sub>0</sub> - zerosCol<sub>1</sub> = 3 + 2 - 0 - 0 = 5\n- diff[0][2] = onesRow<sub>0</sub> + onesCol<sub>2</sub> - zerosRow<sub>0</sub> - zerosCol<sub>2</sub> = 3 + 2 - 0 - 0 = 5\n- diff[1][0] = onesRow<sub>1</sub> + onesCol<sub>0</sub> - zerosRow<sub>1</sub> - zerosCol<sub>0</sub> = 3 + 2 - 0 - 0 = 5\n- diff[1][1] = onesRow<sub>1</sub> + onesCol<sub>1</sub> - zerosRow<sub>1</sub> - zerosCol<sub>1</sub> = 3 + 2 - 0 - 0 = 5\n- diff[1][2] = onesRow<sub>1</sub> + onesCol<sub>2</sub> - zerosRow<sub>1</sub> - zerosCol<sub>2</sub> = 3 + 2 - 0 - 0 = 5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>grid[i][j]</code>&nbsp;要么是&nbsp;<code>0</code>&nbsp;，要么是&nbsp;<code>1</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2483.商店的最少代价",
        "hardRate": "MEDIUM",
        "passRate": "63.25%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-penalty-for-a-shop/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-penalty-for-a-shop/solution",
        "problemsDesc": "<p>给你一个顾客访问商店的日志，用一个下标从 <strong>0</strong>&nbsp;开始且只包含字符&nbsp;<code>'N'</code> 和&nbsp;<code>'Y'</code>&nbsp;的字符串&nbsp;<code>customers</code>&nbsp;表示：</p>\n\n<ul>\n\t<li>如果第&nbsp;<code>i</code>&nbsp;个字符是&nbsp;<code>'Y'</code>&nbsp;，它表示第&nbsp;<code>i</code>&nbsp;小时有顾客到达。</li>\n\t<li>如果第&nbsp;<code>i</code>&nbsp;个字符是&nbsp;<code>'N'</code>&nbsp;，它表示第 <code>i</code>&nbsp;小时没有顾客到达。</li>\n</ul>\n\n<p>如果商店在第&nbsp;<code>j</code>&nbsp;小时关门（<code>0 &lt;= j &lt;= n</code>），代价按如下方式计算：</p>\n\n<ul>\n\t<li>在开门期间，如果某一个小时没有顾客到达，代价增加 <code>1</code>&nbsp;。</li>\n\t<li>在关门期间，如果某一个小时有顾客到达，代价增加&nbsp;<code>1</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回在确保代价 <strong>最小</strong>&nbsp;的前提下，商店的&nbsp;<strong>最早</strong>&nbsp;关门时间。</p>\n\n<p>注意，商店在第 <code>j</code>&nbsp;小时关门表示在第 <code>j</code> 小时以及之后商店处于关门状态。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>customers = \"YYNY\"\n<b>输出：</b>2\n<b>解释：</b>\n- 第 0 小时关门，总共 1+1+0+1 = 3 代价。\n- 第 1 小时关门，总共 0+1+0+1 = 2 代价。\n- 第 2 小时关门，总共 0+0+0+1 = 1 代价。\n- 第 3 小时关门，总共 0+0+1+1 = 2 代价。\n- 第 4 小时关门，总共 0+0+1+0 = 1 代价。\n在第 2 或第 4 小时关门代价都最小。由于第 2 小时更早，所以最优关门时间是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>customers = \"NNNNN\"\n<b>输出：</b>0\n<b>解释：</b>最优关门时间是 0 ，因为自始至终没有顾客到达。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>customers = \"YYYY\"\n<b>输出：</b>4\n<b>解释：</b>最优关门时间是 4 ，因为每一小时均有顾客到达。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= customers.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>customers</code>&nbsp;只包含字符&nbsp;<code>'Y'</code>&nbsp;和&nbsp;<code>'N'</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2484.统计回文子序列数目",
        "hardRate": "HARD",
        "passRate": "47.17%",
        "problemsUrl": "https://leetcode.cn/problems/count-palindromic-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/count-palindromic-subsequences/solution",
        "problemsDesc": "<p>给你数字字符串&nbsp;<code>s</code>&nbsp;，请你返回&nbsp;<code>s</code>&nbsp;中长度为&nbsp;<code>5</code>&nbsp;的 <b>回文子序列</b>&nbsp;数目。由于答案可能很大，请你将答案对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>如果一个字符串从前往后和从后往前读相同，那么它是 <strong>回文字符串</strong>&nbsp;。</li>\n\t<li>子序列是一个字符串中删除若干个字符后，不改变字符顺序，剩余字符构成的字符串。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"103301\"\n<b>输出：</b>2\n<b>解释：</b>\n总共有 6 长度为 5 的子序列：\"10330\" ，\"10331\" ，\"10301\" ，\"10301\" ，\"13301\" ，\"03301\" 。\n它们中有两个（都是 \"10301\"）是回文的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"0000000\"\n<b>输出：</b>21\n<b>解释：</b>所有 21 个长度为 5 的子序列都是 \"00000\" ，都是回文的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>s = \"9999900000\"\n<b>输出：</b>2\n<b>解释：</b>仅有的两个回文子序列是 \"99999\" 和 \"00000\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含数字字符。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2485.找出中枢整数",
        "hardRate": "EASY",
        "passRate": "80.70%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-pivot-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-pivot-integer/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> ，找出满足下述条件的<strong> 中枢整数</strong> <code>x</code> ：</p>\n\n<ul>\n\t<li><code>1</code> 和 <code>x</code> 之间的所有元素之和等于 <code>x</code> 和 <code>n</code> 之间所有元素之和。</li>\n</ul>\n\n<p>返回中枢整数<em> </em><code>x</code> 。如果不存在中枢整数，则返回 <code>-1</code> 。题目保证对于给定的输入，至多存在一个中枢整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 8\n<strong>输出：</strong>6\n<strong>解释：</strong>6 是中枢整数，因为 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>1 是中枢整数，因为 1 = 1 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>-1\n<strong>解释：</strong>可以证明不存在满足题目要求的整数。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2486.追加字符以获得子序列",
        "hardRate": "MEDIUM",
        "passRate": "65.16%",
        "problemsUrl": "https://leetcode.cn/problems/append-characters-to-string-to-make-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/append-characters-to-string-to-make-subsequence/solution",
        "problemsDesc": "<p>给你两个仅由小写英文字母组成的字符串 <code>s</code> 和 <code>t</code> 。</p>\n\n<p>现在需要通过向 <code>s</code> 末尾追加字符的方式使 <code>t</code> 变成 <code>s</code> 的一个 <strong>子序列</strong> ，返回需要追加的最少字符数。</p>\n\n<p>子序列是一个可以由其他字符串删除部分（或不删除）字符但不改变剩下字符顺序得到的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"coaching\", t = \"coding\"\n<strong>输出：</strong>4\n<strong>解释：</strong>向 s 末尾追加字符串 \"ding\" ，s = \"coachingding\" 。\n现在，t 是 s (\"<em><strong>co</strong></em>aching<em><strong>ding</strong></em>\") 的一个子序列。\n可以证明向 s 末尾追加任何 3 个字符都无法使 t 成为 s 的一个子序列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcde\", t = \"a\"\n<strong>输出：</strong>0\n<strong>解释：</strong>t 已经是 s (\"<em><strong>a</strong></em>bcde\") 的一个子序列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"z\", t = \"abcde\"\n<strong>输出：</strong>5\n<strong>解释：</strong>向 s 末尾追加字符串 \"abcde\" ，s = \"zabcde\" 。\n现在，t 是 s (\"z<em><strong>abcde</strong></em>\") 的一个子序列。 \n可以证明向 s 末尾追加任何 4 个字符都无法使 t 成为 s 的一个子序列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 和 <code>t</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2487.从链表中移除节点",
        "hardRate": "MEDIUM",
        "passRate": "68.91%",
        "problemsUrl": "https://leetcode.cn/problems/remove-nodes-from-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-nodes-from-linked-list/solution",
        "problemsDesc": "<p>给你一个链表的头节点 <code>head</code> 。</p>\n\n<p>对于列表中的每个节点 <code>node</code> ，如果其右侧存在一个具有 <strong>严格更大</strong> 值的节点，则移除 <code>node</code> 。</p>\n\n<p>返回修改后链表的头节点<em> </em><code>head</code><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/02/drawio.png\" style=\"width: 631px; height: 51px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [5,2,13,3,8]\n<strong>输出：</strong>[13,8]\n<strong>解释：</strong>需要移除的节点是 5 ，2 和 3 。\n- 节点 13 在节点 5 右侧。\n- 节点 13 在节点 2 右侧。\n- 节点 8 在节点 3 右侧。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,1,1,1]\n<strong>输出：</strong>[1,1,1,1]\n<strong>解释：</strong>每个节点的值都是 1 ，所以没有需要移除的节点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给定列表中的节点数目在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2488.统计中位数为 K 的子数组",
        "hardRate": "HARD",
        "passRate": "50.74%",
        "problemsUrl": "https://leetcode.cn/problems/count-subarrays-with-median-k/",
        "solutionsUrl": "https://leetcode.cn/problems/count-subarrays-with-median-k/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的数组 <code>nums</code> ，该数组由从 <code>1</code> 到 <code>n</code> 的 <strong>不同</strong> 整数组成。另给你一个正整数 <code>k</code> 。</p>\n\n<p>统计并返回 <code>nums</code> 中的 <strong>中位数</strong> 等于 <code>k</code> 的非空子数组的数目。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>数组的中位数是按 <strong>递增</strong> 顺序排列后位于 <strong>中间</strong> 的那个元素，如果数组长度为偶数，则中位数是位于中间靠 <strong>左</strong> 的那个元素。\n\n\t<ul>\n\t\t<li>例如，<code>[2,3,1,4]</code> 的中位数是 <code>2</code> ，<code>[8,4,3,5,1]</code> 的中位数是 <code>4</code> 。</li>\n\t</ul>\n\t</li>\n\t<li>子数组是数组中的一个连续部分。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,1,4,5], k = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>中位数等于 4 的子数组有：[4]、[4,5] 和 [1,4,5] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,1], k = 3\n<strong>输出：</strong>1\n<strong>解释：</strong>[3] 是唯一一个中位数等于 3 的子数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= n</code></li>\n\t<li><code>nums</code> 中的整数互不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2489.固定比率的子字符串数",
        "hardRate": "MEDIUM",
        "passRate": "68.54%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-substrings-with-fixed-ratio/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-substrings-with-fixed-ratio/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2490.回环句",
        "hardRate": "EASY",
        "passRate": "73.67%",
        "problemsUrl": "https://leetcode.cn/problems/circular-sentence/",
        "solutionsUrl": "https://leetcode.cn/problems/circular-sentence/solution",
        "problemsDesc": "<p><strong>句子</strong> 是由单个空格分隔的一组单词，且不含前导或尾随空格。</p>\n\n<ul>\n\t<li>例如，<code>\"Hello World\"</code>、<code>\"HELLO\"</code>、<code>\"hello world hello world\"</code> 都是符合要求的句子。</li>\n</ul>\n\n<p>单词 <strong>仅</strong> 由大写和小写英文字母组成。且大写和小写字母会视作不同字符。</p>\n\n<p>如果句子满足下述全部条件，则认为它是一个 <strong>回环句</strong> ：</p>\n\n<ul>\n\t<li>单词的最后一个字符和下一个单词的第一个字符相等。</li>\n\t<li>最后一个单词的最后一个字符和第一个单词的第一个字符相等。</li>\n</ul>\n\n<p>例如，<code>\"leetcode exercises sound delightful\"</code>、<code>\"eetcode\"</code>、<code>\"leetcode eats soul\"</code> 都是回环句。然而，<code>\"Leetcode is cool\"</code>、<code>\"happy Leetcode\"</code>、<code>\"Leetcode\"</code> 和 <code>\"I like Leetcode\"</code> 都 <strong>不</strong> 是回环句。</p>\n\n<p>给你一个字符串 <code>sentence</code> ，请你判断它是不是一个回环句。如果是，返回 <code>true</code><em> </em>；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"leetcode exercises sound delightful\"\n<strong>输出：</strong>true\n<strong>解释：</strong>句子中的单词是 [\"leetcode\", \"exercises\", \"sound\", \"delightful\"] 。\n- leetcod<strong><em>e</em></strong> 的最后一个字符和 <strong><em>e</em></strong>xercises 的第一个字符相等。\n- exercise<em><strong>s</strong></em> 的最后一个字符和 <em><strong>s</strong></em>ound 的第一个字符相等。\n- <em><strong>s</strong></em>ound 的最后一个字符和 delightfu<em><strong>l</strong></em> 的第一个字符相等。\n- delightfu<em><strong>l</strong></em> 的最后一个字符和 <em><strong>l</strong></em>eetcode 的第一个字符相等。\n这个句子是回环句。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"eetcode\"\n<strong>输出：</strong>true\n<strong>解释：</strong>句子中的单词是 [\"eetcode\"] 。\n- eetcod<em><strong>e</strong></em> 的最后一个字符和 <em><strong>e</strong></em>etcod<em>e</em> 的第一个字符相等。\n这个句子是回环句。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"Leetcode is cool\"\n<strong>输出：</strong>false\n<strong>解释：</strong>句子中的单词是 [\"Leetcode\", \"is\", \"cool\"] 。\n- Leetcod<em><strong>e</strong></em>&nbsp;的最后一个字符和 <em><strong>i</strong></em>s 的第一个字符 <strong>不</strong> 相等。 \n这个句子 <strong>不</strong> 是回环句。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentence.length &lt;= 500</code></li>\n\t<li><code>sentence</code> 仅由大小写英文字母和空格组成</li>\n\t<li><code>sentence</code> 中的单词由单个空格进行分隔</li>\n\t<li>不含任何前导或尾随空格</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2491.划分技能点相等的团队",
        "hardRate": "MEDIUM",
        "passRate": "55.26%",
        "problemsUrl": "https://leetcode.cn/problems/divide-players-into-teams-of-equal-skill/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-players-into-teams-of-equal-skill/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>skill</code> ，数组长度为 <strong>偶数</strong> <code>n</code> ，其中 <code>skill[i]</code> 表示第 <code>i</code> 个玩家的技能点。将所有玩家分成 <code>n / 2</code> 个 <code>2</code> 人团队，使每一个团队的技能点之和 <strong>相等</strong> 。</p>\n\n<p>团队的 <strong>化学反应</strong> 等于团队中玩家的技能点 <strong>乘积</strong> 。</p>\n\n<p>返回所有团队的 <strong>化学反应</strong> 之和，如果无法使每个团队的技能点之和相等，则返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>skill = [3,2,5,1,3,4]\n<strong>输出：</strong>22\n<strong>解释：</strong>\n将玩家分成 3 个团队 (1, 5), (2, 4), (3, 3) ，每个团队的技能点之和都是 6 。\n所有团队的化学反应之和是 1 * 5 + 2 * 4 + 3 * 3 = 5 + 8 + 9 = 22 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>skill = [3,4]\n<strong>输出：</strong>12\n<strong>解释：</strong>\n两个玩家形成一个团队，技能点之和是 7 。\n团队的化学反应是 3 * 4 = 12 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>skill = [1,1,2,3]\n<strong>输出：</strong>-1\n<strong>解释：</strong>\n无法将玩家分成每个团队技能点都相等的若干个 2 人团队。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= skill.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>skill.length</code> 是偶数</li>\n\t<li><code>1 &lt;= skill[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2492.两个城市间路径的最小分数",
        "hardRate": "MEDIUM",
        "passRate": "41.40%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-score-of-a-path-between-two-cities/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-score-of-a-path-between-two-cities/solution",
        "problemsDesc": "<p>给你一个正整数&nbsp;<code>n</code>&nbsp;，表示总共有&nbsp;<code>n</code>&nbsp;个城市，城市从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;编号。给你一个二维数组&nbsp;<code>roads</code>&nbsp;，其中&nbsp;<code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>, distance<sub>i</sub>]</code>&nbsp;表示城市&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条 <strong>双向</strong>&nbsp;道路，道路距离为&nbsp;<code>distance<sub>i</sub></code>&nbsp;。城市构成的图不一定是连通的。</p>\n\n<p>两个城市之间一条路径的 <strong>分数</strong>&nbsp;定义为这条路径中道路的 <strong>最小</strong>&nbsp;距离。</p>\n\n<p><span class=\"text-only\" data-eleid=\"20\" style=\"white-space: pre;\">城市</span><span class=\"text-only text-font-italic\" data-eleid=\"21\" style=\"white-space: pre;\"> </span><code><span class=\"text-only\" data-eleid=\"22\" style=\"white-space: pre;\">1</span></code><span class=\"text-only text-font-italic\" data-eleid=\"23\" style=\"white-space: pre;\"> </span><span class=\"text-only\" data-eleid=\"24\" style=\"white-space: pre;\">和城市</span><span class=\"text-only text-font-italic\" data-eleid=\"25\" style=\"white-space: pre;\"> </span><span class=\"text-only\" data-eleid=\"26\" style=\"white-space: pre;\"><code>n</code> 之间的所有路径的 </span><strong><span class=\"text-only\" data-eleid=\"27\" style=\"white-space: pre;\">最小</span></strong><span class=\"text-only\" data-eleid=\"28\" style=\"white-space: pre;\"> 分数。</span></p>\n\n<p><b>注意：</b></p>\n\n<ul>\n\t<li>一条路径指的是两个城市之间的道路序列。</li>\n\t<li>一条路径可以 <strong>多次</strong> 包含同一条道路，你也可以沿着路径多次到达城市 <code>1</code>&nbsp;和城市 <code>n</code>&nbsp;。</li>\n\t<li>测试数据保证城市 <code>1</code>&nbsp;和城市<code>n</code>&nbsp;之间 <strong>至少</strong>&nbsp;有一条路径。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/12/graph11.png\" style=\"width: 190px; height: 231px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]\n<b>输出：</b>5\n<b>解释：</b>城市 1 到城市 4 的路径中，分数最小的一条为：1 -&gt; 2 -&gt; 4 。这条路径的分数是 min(9,5) = 5 。\n不存在分数更小的路径。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/12/graph22.png\" style=\"width: 190px; height: 231px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]]\n<b>输出：</b>2\n<b>解释：</b>城市 1 到城市 4 分数最小的路径是：1 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4 。这条路径的分数是 min(2,2,4,7) = 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= roads.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>roads[i].length == 3</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>1 &lt;= distance<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li>不会有重复的边。</li>\n\t<li>城市 <code>1</code>&nbsp;和城市 <code>n</code>&nbsp;之间至少有一条路径。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2493.将节点分成尽可能多的组",
        "hardRate": "HARD",
        "passRate": "43.65%",
        "problemsUrl": "https://leetcode.cn/problems/divide-nodes-into-the-maximum-number-of-groups/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-nodes-into-the-maximum-number-of-groups/solution",
        "problemsDesc": "<p>给你一个正整数&nbsp;<code>n</code>&nbsp;，表示一个 <strong>无向</strong>&nbsp;图中的节点数目，节点编号从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;。</p>\n\n<p>同时给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i, </sub>b<sub>i</sub>]</code>&nbsp;表示节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code><sub>&nbsp;</sub>之间有一条&nbsp;<strong>双向</strong>&nbsp;边。注意给定的图可能是不连通的。</p>\n\n<p>请你将图划分为&nbsp;<code>m</code>&nbsp;个组（编号从 <strong>1</strong>&nbsp;开始），满足以下要求：</p>\n\n<ul>\n\t<li>图中每个节点都只属于一个组。</li>\n\t<li>图中每条边连接的两个点&nbsp;<code>[a<sub>i, </sub>b<sub>i</sub>]</code>&nbsp;，如果&nbsp;<code>a<sub>i</sub></code>&nbsp;属于编号为&nbsp;<code>x</code>&nbsp;的组，<code>b<sub>i</sub></code>&nbsp;属于编号为&nbsp;<code>y</code>&nbsp;的组，那么&nbsp;<code>|y - x| = 1</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回最多可以将节点分为多少个组（也就是最大的<em>&nbsp;</em><code>m</code>&nbsp;）。如果没办法在给定条件下分组，请你返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/13/example1.png\" style=\"width: 352px; height: 201px;\"></p>\n\n<pre><b>输入：</b>n = 6, edges = [[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]]\n<b>输出：</b>4\n<b>解释：</b>如上图所示，\n- 节点 5 在第一个组。\n- 节点 1 在第二个组。\n- 节点 2 和节点 4 在第三个组。\n- 节点 3 和节点 6 在第四个组。\n所有边都满足题目要求。\n如果我们创建第五个组，将第三个组或者第四个组中任何一个节点放到第五个组，至少有一条边连接的两个节点所属的组编号不符合题目要求。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 3, edges = [[1,2],[2,3],[3,1]]\n<b>输出：</b>-1\n<b>解释：</b>如果我们将节点 1 放入第一个组，节点 2 放入第二个组，节点 3 放入第三个组，前两条边满足题目要求，但第三条边不满足题目要求。\n没有任何符合题目要求的分组方式。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>两个点之间至多只有一条边。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2494.合并在同一个大厅重叠的活动",
        "hardRate": "HARD",
        "passRate": "39.31%",
        "problemsUrl": "https://leetcode.cn/problems/merge-overlapping-events-in-the-same-hall/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-overlapping-events-in-the-same-hall/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2495.乘积为偶数的子数组数",
        "hardRate": "MEDIUM",
        "passRate": "68.77%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-subarrays-having-even-product/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-subarrays-having-even-product/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2496.数组中字符串的最大值",
        "hardRate": "EASY",
        "passRate": "79.46%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-value-of-a-string-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-value-of-a-string-in-an-array/solution",
        "problemsDesc": "<p>一个由字母和数字组成的字符串的 <strong>值</strong>&nbsp;定义如下：</p>\n\n<ul>\n\t<li>如果字符串 <strong>只</strong> 包含数字，那么值为该字符串在 <code>10</code>&nbsp;进制下的所表示的数字。</li>\n\t<li>否则，值为字符串的 <strong>长度&nbsp;</strong>。</li>\n</ul>\n\n<p>给你一个字符串数组&nbsp;<code>strs</code>&nbsp;，每个字符串都只由字母和数字组成，请你返回 <code>strs</code>&nbsp;中字符串的 <strong>最大值</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"alic3\",\"bob\",\"3\",\"4\",\"00000\"]\n<b>输出：</b>5\n<b>解释：</b>\n- \"alic3\" 包含字母和数字，所以值为长度 5 。\n- \"bob\" 只包含字母，所以值为长度 3 。\n- \"3\" 只包含数字，所以值为 3 。\n- \"4\" 只包含数字，所以值为 4 。\n- \"00000\" 只包含数字，所以值为 0 。\n所以最大的值为 5 ，是字符串 \"alic3\" 的值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>strs = [\"1\",\"01\",\"001\",\"0001\"]\n<b>输出：</b>1\n<b>解释：</b>\n数组中所有字符串的值都是 1 ，所以我们返回 1 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= strs[i].length &lt;= 9</code></li>\n\t<li><code>strs[i]</code>&nbsp;只包含小写英文字母和数字。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2497.图中最大星和",
        "hardRate": "MEDIUM",
        "passRate": "38.25%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-star-sum-of-a-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-star-sum-of-a-graph/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>n</code>&nbsp;个点的无向图，节点从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;编号。给你一个长度为 <code>n</code>&nbsp;下标从&nbsp;<strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>vals</code>&nbsp;，其中&nbsp;<code>vals[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个节点的值。</p>\n\n<p>同时给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条双向边。</p>\n\n<p><strong>星图</strong>&nbsp;是给定图中的一个子图，它包含一个中心节点和&nbsp;<code>0</code>&nbsp;个或更多个邻居。换言之，星图是给定图中一个边的子集，且这些边都有一个公共节点。</p>\n\n<p>下图分别展示了有 <code>3</code>&nbsp;个和 <code>4</code>&nbsp;个邻居的星图，蓝色节点为中心节点。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/07/max-star-sum-descdrawio.png\" style=\"width: 400px; height: 179px;\"></p>\n\n<p><strong>星和</strong> 定义为星图中所有节点值的和。</p>\n\n<p>给你一个整数&nbsp;<code>k</code>&nbsp;，请你返回 <strong>至多</strong>&nbsp;包含 <code>k</code>&nbsp;条边的星图中的 <strong>最大星和</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/07/max-star-sum-example1drawio.png\" style=\"width: 300px; height: 291px;\"></p>\n\n<pre><b>输入：</b>vals = [1,2,3,4,10,-10,-20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2\n<b>输出：</b>16\n<b>解释：</b>上图展示了输入示例。\n最大星和对应的星图在上图中用蓝色标出。中心节点是 3 ，星图中还包含邻居 1 和 4 。\n无法得到一个和大于 16 且边数不超过 2 的星图。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>vals = [-5], edges = [], k = 0\n<b>输出：</b>-5\n<b>解释：</b>只有一个星图，就是节点 0 自己。\n所以我们返回 -5 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == vals.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= vals[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= edges.length &lt;= min(n * (n - 1) / 2</code><code>, 10<sup>5</sup>)</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>0 &lt;= k &lt;= n - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2498.青蛙过河 II",
        "hardRate": "MEDIUM",
        "passRate": "64.58%",
        "problemsUrl": "https://leetcode.cn/problems/frog-jump-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/frog-jump-ii/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>stones</code>&nbsp;，数组中的元素&nbsp;<strong>严格递增</strong>&nbsp;，表示一条河中石头的位置。</p>\n\n<p>一只青蛙一开始在第一块石头上，它想到达最后一块石头，然后回到第一块石头。同时每块石头 <strong>至多</strong> 到达 <strong>一次。</strong></p>\n\n<p>一次跳跃的 <strong>长度</strong>&nbsp;是青蛙跳跃前和跳跃后所在两块石头之间的距离。</p>\n\n<ul>\n\t<li>更正式的，如果青蛙从&nbsp;<code>stones[i]</code>&nbsp;跳到&nbsp;<code>stones[j]</code>&nbsp;，跳跃的长度为&nbsp;<code>|stones[i] - stones[j]|</code>&nbsp;。</li>\n</ul>\n\n<p>一条路径的 <b>代价</b>&nbsp;是这条路径里的&nbsp;<b>最大跳跃长度</b>&nbsp;。</p>\n\n<p>请你返回这只青蛙的 <strong>最小代价</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/14/example-1.png\" style=\"width: 600px; height: 219px;\" /></p>\n\n<pre>\n<b>输入：</b>stones = [0,2,5,6,7]\n<b>输出：</b>5\n<b>解释：</b>上图展示了一条最优路径。\n这条路径的代价是 5 ，是这条路径中的最大跳跃长度。\n无法得到一条代价小于 5 的路径，我们返回 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/14/example-2.png\" style=\"width: 500px; height: 171px;\" /></p>\n\n<pre>\n<b>输入：</b>stones = [0,3,9]\n<b>输出：</b>9\n<b>解释：</b>\n青蛙可以直接跳到最后一块石头，然后跳回第一块石头。\n在这条路径中，每次跳跃长度都是 9 。所以路径代价是 max(9, 9) = 9 。\n这是可行路径中的最小代价。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= stones.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= stones[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>stones[0] == 0</code></li>\n\t<li><code>stones</code>&nbsp;中的元素严格递增。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2499.让数组不相等的最小总代价",
        "hardRate": "HARD",
        "passRate": "41.95%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-total-cost-to-make-arrays-unequal/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-total-cost-to-make-arrays-unequal/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>&nbsp;，两者长度都为&nbsp;<code>n</code>&nbsp;。</p>\n\n<p>每次操作中，你可以选择交换 <code>nums1</code>&nbsp;中任意两个下标处的值。操作的 <strong>开销</strong>&nbsp;为两个下标的 <strong>和</strong>&nbsp;。</p>\n\n<p>你的目标是对于所有的 <code>0 &lt;= i &lt;= n - 1</code>&nbsp;，都满足&nbsp;<code>nums1[i] != nums2[i]</code>&nbsp;，你可以进行 <strong>任意次</strong>&nbsp;操作，请你返回达到这个目标的 <strong>最小</strong>&nbsp;总代价。</p>\n\n<p>请你返回让<em>&nbsp;</em><code>nums1</code> 和&nbsp;<code>nums2</code><em>&nbsp;</em>满足上述条件的 <strong>最小总代价</strong> ，如果无法达成目标，返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]\n<b>输出：</b>10\n<b>解释：</b>\n实现目标的其中一种方法为：\n- 交换下标为 0 和 3 的两个值，代价为 0 + 3 = 3 。现在 nums1 = [4,2,3,1,5] 。\n- 交换下标为 1 和 2 的两个值，代价为 1 + 2 = 3 。现在 nums1 = [4,3,2,1,5] 。\n- 交换下标为 0 和 4 的两个值，代价为 0 + 4 = 4 。现在 nums1 = [5,3,2,1,4] 。\n最后，对于每个下标 i ，都有 nums1[i] != nums2[i] 。总代价为 10 。\n还有别的交换值的方法，但是无法得到代价和小于 10 的方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]\n<b>输出：</b>10\n<b>解释：</b>\n实现目标的一种方法为：\n- 交换下标为 2 和 3 的两个值，代价为 2 + 3 = 5 。现在 nums1 = [2,2,1,2,3] 。\n- 交换下标为 1 和 4 的两个值，代价为 1 + 4 = 5 。现在 nums1 = [2,3,1,2,2] 。\n总代价为 10 ，是所有方案中的最小代价。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums1 = [1,2,2], nums2 = [1,2,2]\n<b>输出：</b>-1\n<b>解释：</b>\n不管怎么操作，都无法满足题目要求。\n所以返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length == nums2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2500.删除每行中的最大值",
        "hardRate": "EASY",
        "passRate": "82.70%",
        "problemsUrl": "https://leetcode.cn/problems/delete-greatest-value-in-each-row/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-greatest-value-in-each-row/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 大小的矩阵 <code>grid</code> ，由若干正整数组成。</p>\n\n<p>执行下述操作，直到 <code>grid</code> 变为空矩阵：</p>\n\n<ul>\n\t<li>从每一行删除值最大的元素。如果存在多个这样的值，删除其中任何一个。</li>\n\t<li>将删除元素中的最大值与答案相加。</li>\n</ul>\n\n<p><strong>注意</strong> 每执行一次操作，矩阵中列的数据就会减 1 。</p>\n\n<p>返回执行上述操作后的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/19/q1ex1.jpg\" style=\"width: 600px; height: 135px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,2,4],[3,3,1]]\n<strong>输出：</strong>8\n<strong>解释：</strong>上图展示在每一步中需要移除的值。\n- 在第一步操作中，从第一行删除 4 ，从第二行删除 3（注意，有两个单元格中的值为 3 ，我们可以删除任一）。在答案上加 4 。\n- 在第二步操作中，从第一行删除 2 ，从第二行删除 3 。在答案上加 3 。\n- 在第三步操作中，从第一行删除 1 ，从第二行删除 1 。在答案上加 1 。\n最终，答案 = 4 + 3 + 1 = 8 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/19/q1ex2.jpg\" style=\"width: 83px; height: 83px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[10]]\n<strong>输出：</strong>10\n<strong>解释：</strong>上图展示在每一步中需要移除的值。\n- 在第一步操作中，从第一行删除 10 。在答案上加 10 。\n最终，答案 = 10 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2501.数组中最长的方波",
        "hardRate": "MEDIUM",
        "passRate": "41.28%",
        "problemsUrl": "https://leetcode.cn/problems/longest-square-streak-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-square-streak-in-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。如果 <code>nums</code> 的子序列满足下述条件，则认为该子序列是一个 <strong>方波</strong> ：</p>\n\n<ul>\n\t<li>子序列的长度至少为 <code>2</code> ，并且</li>\n\t<li>将子序列从小到大排序 <strong>之后</strong> ，除第一个元素外，每个元素都是前一个元素的 <strong>平方</strong> 。</li>\n</ul>\n\n<p>返回<em> </em><code>nums</code><em> </em>中 <strong>最长方波</strong> 的长度，如果不存在 <strong>方波</strong><em> </em>则返回<em> </em><code>-1</code> 。</p>\n\n<p><strong>子序列</strong> 也是一个数组，可以由另一个数组删除一些或不删除元素且不改变剩余元素的顺序得到。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1 ：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,3,6,16,8,2]\n<strong>输出：</strong>3\n<strong>解释：</strong>选出子序列 [4,16,2] 。排序后，得到 [2,4,16] 。\n- 4 = 2 * 2.\n- 16 = 4 * 4.\n因此，[4,16,2] 是一个方波.\n可以证明长度为 4 的子序列都不是方波。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,3,5,6,7]\n<strong>输出：</strong>-1\n<strong>解释：</strong>nums 不存在方波，所以返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2502.设计内存分配器",
        "hardRate": "MEDIUM",
        "passRate": "52.28%",
        "problemsUrl": "https://leetcode.cn/problems/design-memory-allocator/",
        "solutionsUrl": "https://leetcode.cn/problems/design-memory-allocator/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，表示下标从 <strong>0</strong> 开始的内存数组的大小。所有内存单元开始都是空闲的。</p>\n\n<p>请你设计一个具备以下功能的内存分配器：</p>\n\n<ol>\n\t<li><strong>分配 </strong>一块大小为 <code>size</code> 的连续空闲内存单元并赋 id <code>mID</code> 。</li>\n\t<li><strong>释放</strong> 给定 id <code>mID</code> 对应的所有内存单元。</li>\n</ol>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>多个块可以被分配到同一个 <code>mID</code> 。</li>\n\t<li>你必须释放 <code>mID</code> 对应的所有内存单元，即便这些内存单元被分配在不同的块中。</li>\n</ul>\n\n<p>实现 <code>Allocator</code> 类：</p>\n\n<ul>\n\t<li><code>Allocator(int n)</code> 使用一个大小为 <code>n</code> 的内存数组初始化 <code>Allocator</code> 对象。</li>\n\t<li><code>int allocate(int size, int mID)</code> 找出大小为 <code>size</code> 个连续空闲内存单元且位于&nbsp; <strong>最左侧</strong> 的块，分配并赋 id <code>mID</code> 。返回块的第一个下标。如果不存在这样的块，返回 <code>-1</code> 。</li>\n\t<li><code>int free(int mID)</code> 释放 id <code>mID</code> 对应的所有内存单元。返回释放的内存单元数目。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入</strong>\n[\"Allocator\", \"allocate\", \"allocate\", \"allocate\", \"free\", \"allocate\", \"allocate\", \"allocate\", \"free\", \"allocate\", \"free\"]\n[[10], [1, 1], [1, 2], [1, 3], [2], [3, 4], [1, 1], [1, 1], [1], [10, 2], [7]]\n<strong>输出</strong>\n[null, 0, 1, 2, 1, 3, 1, 6, 3, -1, 0]\n\n<strong>解释</strong>\nAllocator loc = new Allocator(10); // 初始化一个大小为 10 的内存数组，所有内存单元都是空闲的。\nloc.allocate(1, 1); // 最左侧的块的第一个下标是 0 。内存数组变为 [<strong>1</strong>, , , , , , , , , ]。返回 0 。\nloc.allocate(1, 2); // 最左侧的块的第一个下标是 1 。内存数组变为 [1,<strong>2</strong>, , , , , , , , ]。返回 1 。\nloc.allocate(1, 3); // 最左侧的块的第一个下标是 2 。内存数组变为 [1,2,<strong>3</strong>, , , , , , , ]。返回 2 。\nloc.free(2); // 释放 mID 为 2 的所有内存单元。内存数组变为 [1, ,<strong>3</strong>, , , , , , , ] 。返回 1 ，因为只有 1 个 mID 为 2 的内存单元。\nloc.allocate(3, 4); // 最左侧的块的第一个下标是 3 。内存数组变为 [1, ,3,<strong>4</strong>,<strong>4</strong>,<strong>4</strong>, , , , ]。返回 3 。\nloc.allocate(1, 1); // 最左侧的块的第一个下标是 1 。内存数组变为 [1,<strong>1</strong>,3,4,4,4, , , , ]。返回 1 。\nloc.allocate(1, 1); // 最左侧的块的第一个下标是 6 。内存数组变为 [1,1,3,4,4,4,<strong>1</strong>, , , ]。返回 6 。\nloc.free(1); // 释放 mID 为 1 的所有内存单元。内存数组变为 [ , ,3,4,4,4,<strong> </strong>, , , ] 。返回 3 ，因为有 3 个 mID 为 1 的内存单元。\nloc.allocate(10, 2); // 无法找出长度为 10 个连续空闲内存单元的空闲块，所有返回 -1 。\nloc.free(7); // 释放 mID 为 7 的所有内存单元。内存数组保持原状，因为不存在 mID 为 7 的内存单元。返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n, size, mID &lt;= 1000</code></li>\n\t<li>最多调用 <code>allocate</code> 和 <code>free</code> 方法 <code>1000</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2503.矩阵查询可获得的最大分数",
        "hardRate": "HARD",
        "passRate": "43.39%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-points-from-grid-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-points-from-grid-queries/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的整数矩阵 <code>grid</code> 和一个大小为 <code>k</code> 的数组 <code>queries</code> 。</p>\n\n<p>找出一个大小为 <code>k</code> 的数组 <code>answer</code> ，且满足对于每个整数 <code>queries[i]</code> ，你从矩阵 <strong>左上角</strong> 单元格开始，重复以下过程：</p>\n\n<ul>\n\t<li>如果 <code>queries[i]</code> <strong>严格</strong> 大于你当前所处位置单元格，如果该单元格是第一次访问，则获得 1 分，并且你可以移动到所有 <code>4</code> 个方向（上、下、左、右）上任一 <strong>相邻</strong> 单元格。</li>\n\t<li>否则，你不能获得任何分，并且结束这一过程。</li>\n</ul>\n\n<p>在过程结束后，<code>answer[i]</code> 是你可以获得的最大分数。注意，对于每个查询，你可以访问同一个单元格 <strong>多次</strong> 。</p>\n\n<p>返回结果数组 <code>answer</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/19/yetgriddrawio.png\" style=\"width: 571px; height: 151px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]\n<strong>输出：</strong>[5,8,1]\n<strong>解释：</strong>上图展示了每个查询中访问并获得分数的单元格。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/20/yetgriddrawio-2.png\" />\n<pre>\n<strong>输入：</strong>grid = [[5,2,1],[1,1,2]], queries = [3]\n<strong>输出：</strong>[0]\n<strong>解释：</strong>无法获得分数，因为左上角单元格的值大于等于 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>k == queries.length</code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= grid[i][j], queries[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2504.把名字和职业联系起来",
        "hardRate": "EASY",
        "passRate": "76.36%",
        "problemsUrl": "https://leetcode.cn/problems/concatenate-the-name-and-the-profession/",
        "solutionsUrl": "https://leetcode.cn/problems/concatenate-the-name-and-the-profession/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2505.所有子序列和的按位或",
        "hardRate": "MEDIUM",
        "passRate": "59.25%",
        "problemsUrl": "https://leetcode.cn/problems/bitwise-or-of-all-subsequence-sums/",
        "solutionsUrl": "https://leetcode.cn/problems/bitwise-or-of-all-subsequence-sums/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2506.统计相似字符串对的数目",
        "hardRate": "EASY",
        "passRate": "78.32%",
        "problemsUrl": "https://leetcode.cn/problems/count-pairs-of-similar-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/count-pairs-of-similar-strings/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串数组 <code>words</code> 。</p>\n\n<p>如果两个字符串由相同的字符组成，则认为这两个字符串 <strong>相似</strong> 。</p>\n\n<ul>\n\t<li>例如，<code>\"abca\"</code> 和 <code>\"cba\"</code> 相似，因为它们都由字符 <code>'a'</code>、<code>'b'</code>、<code>'c'</code> 组成。</li>\n\t<li>然而，<code>\"abacba\"</code> 和 <code>\"bcfd\"</code> 不相似，因为它们不是相同字符组成的。</li>\n</ul>\n\n<p>请你找出满足字符串&nbsp;<code>words[i]</code><em> </em>和<em> </em><code>words[j]</code> 相似的下标对<em> </em><code>(i, j)</code><em> </em>，并返回下标对的数目，其中 <code>0 &lt;= i &lt; j &lt;= word.length - 1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"aba\",\"aabb\",\"abcd\",\"bac\",\"aabc\"]\n<strong>输出：</strong>2\n<strong>解释：</strong>共有 2 对满足条件：\n- i = 0 且 j = 1 ：words[0] 和 words[1] 只由字符 'a' 和 'b' 组成。 \n- i = 3 且 j = 4 ：words[3] 和 words[4] 只由字符 'a'、'b' 和 'c' 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"aabb\",\"ab\",\"ba\"]\n<strong>输出：</strong>3\n<strong>解释：</strong>共有 3 对满足条件：\n- i = 0 且 j = 1 ：words[0] 和 words[1] 只由字符 'a' 和 'b' 组成。 \n- i = 0 且 j = 2 ：words[0] 和 words[2] 只由字符 'a' 和 'b' 组成。 \n- i = 1 且 j = 2 ：words[1] 和 words[2] 只由字符 'a' 和 'b' 组成。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"nba\",\"cba\",\"dba\"]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在满足条件的下标对，返回 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><code>words[i]</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2507.使用质因数之和替换后可以取到的最小值",
        "hardRate": "MEDIUM",
        "passRate": "50.00%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-value-after-replacing-with-sum-of-prime-factors/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-value-after-replacing-with-sum-of-prime-factors/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> 。</p>\n\n<p>请你将 <code>n</code> 的值替换为 <code>n</code> 的 <strong>质因数</strong> 之和，重复这一过程。</p>\n\n<ul>\n\t<li>注意，如果 <code>n</code> 能够被某个质因数多次整除，则在求和时，应当包含这个质因数同样次数。</li>\n</ul>\n\n<p>返回<em> </em><code>n</code><em> </em>可以取到的最小值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 15\n<strong>输出：</strong>5\n<strong>解释：</strong>最开始，n = 15 。\n15 = 3 * 5 ，所以 n 替换为 3 + 5 = 8 。\n8 = 2 * 2 * 2 ，所以 n 替换为 2 + 2 + 2 = 6 。\n6 = 2 * 3 ，所以 n 替换为 2 + 3 = 5 。\n5 是 n 可以取到的最小值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>最开始，n = 3 。\n3 是 n 可以取到的最小值。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2508.添加边使所有节点度数都为偶数",
        "hardRate": "HARD",
        "passRate": "29.44%",
        "problemsUrl": "https://leetcode.cn/problems/add-edges-to-make-degrees-of-all-nodes-even/",
        "solutionsUrl": "https://leetcode.cn/problems/add-edges-to-make-degrees-of-all-nodes-even/solution",
        "problemsDesc": "<p>给你一个有 <code>n</code>&nbsp;个节点的 <strong>无向</strong>&nbsp;图，节点编号为&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;。再给你整数&nbsp;<code>n</code>&nbsp;和一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条边。图不一定连通。</p>\n\n<p>你可以给图中添加 <strong>至多</strong>&nbsp;两条额外的边（也可以一条边都不添加），使得图中没有重边也没有自环。</p>\n\n<p>如果添加额外的边后，可以使得图中所有点的度数都是偶数，返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>点的度数是连接一个点的边的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/26/agraphdrawio.png\" style=\"width: 500px; height: 190px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]\n<b>输出：</b>true\n<b>解释：</b>上图展示了添加一条边的合法方案。\n最终图中每个节点都连接偶数条边。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/26/aagraphdrawio.png\" style=\"width: 400px; height: 120px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 4, edges = [[1,2],[3,4]]\n<b>输出：</b>true\n<b>解释：</b>上图展示了添加两条边的合法方案。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/26/aaagraphdrawio.png\" style=\"width: 150px; height: 158px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 4, edges = [[1,2],[1,3],[1,4]]\n<b>输出：</b>false\n<b>解释：</b>无法添加至多 2 条边得到一个符合要求的图。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>图中不会有重边</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2509.查询树中环的长度",
        "hardRate": "HARD",
        "passRate": "65.22%",
        "problemsUrl": "https://leetcode.cn/problems/cycle-length-queries-in-a-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/cycle-length-queries-in-a-tree/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;，表示你有一棵含有&nbsp;<code>2<sup>n</sup> - 1</code>&nbsp;个节点的 <strong>完全二叉树</strong>&nbsp;。根节点的编号是&nbsp;<code>1</code>&nbsp;，树中编号在<code>[1, 2<sup>n - 1</sup> - 1]</code>&nbsp;之间，编号为&nbsp;<code>val</code>&nbsp;的节点都有两个子节点，满足：</p>\n\n<ul>\n\t<li>左子节点的编号为&nbsp;<code>2 * val</code></li>\n\t<li>右子节点的编号为&nbsp;<code>2 * val + 1</code></li>\n</ul>\n\n<p>给你一个长度为 <code>m</code>&nbsp;的查询数组 <code>queries</code>&nbsp;，它是一个二维整数数组，其中&nbsp;<code>queries[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;。对于每个查询，求出以下问题的解：</p>\n\n<ol>\n\t<li>在节点编号为&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间添加一条边。</li>\n\t<li>求出图中环的长度。</li>\n\t<li>删除节点编号为&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间新添加的边。</li>\n</ol>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><strong>环</strong> 是开始和结束于同一节点的一条路径，路径中每条边都只会被访问一次。</li>\n\t<li>环的长度是环中边的数目。</li>\n\t<li>在树中添加额外的边后，两个点之间可能会有多条边。</li>\n</ul>\n\n<p>请你返回一个长度为 <code>m</code>&nbsp;的数组<em>&nbsp;</em><code>answer</code>&nbsp;，其中&nbsp;<code>answer[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个查询的结果<i>。</i></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/25/bexample1.png\" style=\"width: 647px; height: 128px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 3, queries = [[5,3],[4,7],[2,3]]\n<b>输出：</b>[4,5,3]\n<b>解释：</b>上图是一棵有 2<sup>3</sup> - 1 个节点的树。红色节点表示添加额外边后形成环的节点。\n- 在节点 3 和节点 5 之间添加边后，环为 [5,2,1,3] ，所以第一个查询的结果是 4 。删掉添加的边后处理下一个查询。\n- 在节点 4 和节点 7 之间添加边后，环为 [4,2,1,3,7] ，所以第二个查询的结果是 5 。删掉添加的边后处理下一个查询。\n- 在节点 2 和节点 3 之间添加边后，环为 [2,1,3] ，所以第三个查询的结果是 3 。删掉添加的边。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/25/aexample2.png\" style=\"width: 146px; height: 71px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 2, queries = [[1,2]]\n<b>输出：</b>[2]\n<b>解释：</b>上图是一棵有 2<sup>2</sup> - 1 个节点的树。红色节点表示添加额外边后形成环的节点。\n- 在节点 1 和节点 2 之间添加边后，环为 [2,1] ，所以第一个查询的结果是 2 。删掉添加的边。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 30</code></li>\n\t<li><code>m == queries.length</code></li>\n\t<li><code>1 &lt;= m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= 2<sup>n</sup> - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2510.检查是否有路径经过相同数量的 0 和 1",
        "hardRate": "MEDIUM",
        "passRate": "68.88%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-there-is-a-path-with-equal-number-of-0s-and-1s/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-there-is-a-path-with-equal-number-of-0s-and-1s/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2511.最多可以摧毁的敌人城堡数目",
        "hardRate": "EASY",
        "passRate": "49.45%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-enemy-forts-that-can-be-captured/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-enemy-forts-that-can-be-captured/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;，下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>forts</code>&nbsp;，表示一些城堡。<code>forts[i]</code> 可以是&nbsp;<code>-1</code>&nbsp;，<code>0</code>&nbsp;或者&nbsp;<code>1</code>&nbsp;，其中：</p>\n\n<ul>\n\t<li><code>-1</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个位置 <strong>没有</strong>&nbsp;城堡。</li>\n\t<li><code>0</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个位置有一个 <strong>敌人</strong>&nbsp;的城堡。</li>\n\t<li><code>1</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个位置有一个你控制的城堡。</li>\n</ul>\n\n<p>现在，你需要决定，将你的军队从某个你控制的城堡位置&nbsp;<code>i</code>&nbsp;移动到一个空的位置&nbsp;<code>j</code>&nbsp;，满足：</p>\n\n<ul>\n\t<li><code>0 &lt;= i, j &lt;= n - 1</code></li>\n\t<li>军队经过的位置 <strong>只有</strong>&nbsp;敌人的城堡。正式的，对于所有&nbsp;<code>min(i,j) &lt; k &lt; max(i,j)</code>&nbsp;的&nbsp;<code>k</code>&nbsp;，都满足&nbsp;<code>forts[k] == 0</code>&nbsp;。</li>\n</ul>\n\n<p>当军队移动时，所有途中经过的敌人城堡都会被 <strong>摧毁</strong> 。</p>\n\n<p>请你返回 <strong>最多</strong>&nbsp;可以摧毁的敌人城堡数目。如果 <strong>无法</strong>&nbsp;移动你的军队，或者没有你控制的城堡，请返回 <code>0</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>forts = [1,0,0,-1,0,0,0,0,1]\n<b>输出：</b>4\n<strong>解释：</strong>\n- 将军队从位置 0 移动到位置 3 ，摧毁 2 个敌人城堡，位置分别在 1 和 2 。\n- 将军队从位置 8 移动到位置 3 ，摧毁 4 个敌人城堡。\n4 是最多可以摧毁的敌人城堡数目，所以我们返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>forts = [0,0,1,-1]\n<b>输出：</b>0\n<b>解释：</b>由于无法摧毁敌人的城堡，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= forts.length &lt;= 1000</code></li>\n\t<li><code>-1 &lt;= forts[i] &lt;= 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2512.奖励最顶尖的 K 名学生",
        "hardRate": "MEDIUM",
        "passRate": "46.34%",
        "problemsUrl": "https://leetcode.cn/problems/reward-top-k-students/",
        "solutionsUrl": "https://leetcode.cn/problems/reward-top-k-students/solution",
        "problemsDesc": "<p>给你两个字符串数组&nbsp;<code>positive_feedback</code> 和&nbsp;<code>negative_feedback</code>&nbsp;，分别包含表示正面的和负面的词汇。<strong>不会</strong>&nbsp;有单词同时是正面的和负面的。</p>\n\n<p>一开始，每位学生分数为&nbsp;<code>0</code>&nbsp;。每个正面的单词会给学生的分数 <strong>加&nbsp;</strong><code>3</code>&nbsp;分，每个负面的词会给学生的分数 <strong>减&nbsp;</strong>&nbsp;<code>1</code>&nbsp;分。</p>\n\n<p>给你&nbsp;<code>n</code>&nbsp;个学生的评语，用一个下标从 <strong>0</strong>&nbsp;开始的字符串数组&nbsp;<code>report</code>&nbsp;和一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>student_id</code>&nbsp;表示，其中&nbsp;<code>student_id[i]</code>&nbsp;表示这名学生的 ID ，这名学生的评语是&nbsp;<code>report[i]</code>&nbsp;。每名学生的 ID <strong>互不相同</strong>。</p>\n\n<p>给你一个整数&nbsp;<code>k</code>&nbsp;，请你返回按照得分&nbsp;<strong>从高到低</strong>&nbsp;最顶尖的<em>&nbsp;</em><code>k</code>&nbsp;名学生。如果有多名学生分数相同，ID 越小排名越前。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>positive_feedback = [\"smart\",\"brilliant\",\"studious\"], negative_feedback = [\"not\"], report = [\"this student is studious\",\"the student is smart\"], student_id = [1,2], k = 2\n<b>输出：</b>[1,2]\n<b>解释：</b>\n两名学生都有 1 个正面词汇，都得到 3 分，学生 1 的 ID 更小所以排名更前。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>positive_feedback = [\"smart\",\"brilliant\",\"studious\"], negative_feedback = [\"not\"], report = [\"this student is not studious\",\"the student is smart\"], student_id = [1,2], k = 2\n<b>输出：</b>[2,1]\n<b>解释：</b>\n- ID 为 1 的学生有 1 个正面词汇和 1 个负面词汇，所以得分为 3-1=2 分。\n- ID 为 2 的学生有 1 个正面词汇，得分为 3 分。\n学生 2 分数更高，所以返回 [2,1] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= positive_feedback.length, negative_feedback.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= positive_feedback[i].length, negative_feedback[j].length &lt;= 100</code></li>\n\t<li><code>positive_feedback[i]</code> 和&nbsp;<code>negative_feedback[j]</code>&nbsp;都只包含小写英文字母。</li>\n\t<li><code>positive_feedback</code> 和&nbsp;<code>negative_feedback</code>&nbsp;中不会有相同单词。</li>\n\t<li><code>n == report.length == student_id.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>report[i]</code>&nbsp;只包含小写英文字母和空格&nbsp;<code>' '</code>&nbsp;。</li>\n\t<li><code>report[i]</code>&nbsp;中连续单词之间有单个空格隔开。</li>\n\t<li><code>1 &lt;= report[i].length &lt;= 100</code></li>\n\t<li><code>1 &lt;= student_id[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>student_id[i]</code>&nbsp;的值 <strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2513.最小化两个数组中的最大值",
        "hardRate": "MEDIUM",
        "passRate": "34.66%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-the-maximum-of-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-the-maximum-of-two-arrays/solution",
        "problemsDesc": "<p>给你两个数组&nbsp;<code>arr1</code> 和&nbsp;<code>arr2</code>&nbsp;，它们一开始都是空的。你需要往它们中添加正整数，使它们满足以下条件：</p>\n\n<ul>\n\t<li><code>arr1</code>&nbsp;包含&nbsp;<code>uniqueCnt1</code>&nbsp;个<strong>&nbsp;互不相同</strong>&nbsp;的正整数，每个整数都&nbsp;<strong>不能 </strong>被&nbsp;<code>divisor1</code>&nbsp;<strong>整除</strong>&nbsp;。</li>\n\t<li><code>arr2</code>&nbsp;包含&nbsp;<code>uniqueCnt2</code>&nbsp;个<strong>&nbsp;互不相同</strong>&nbsp;的正整数，每个整数都&nbsp;<strong>不能</strong>&nbsp;被&nbsp;<code>divisor2</code>&nbsp;<strong>整除</strong>&nbsp;。</li>\n\t<li><code>arr1</code> 和&nbsp;<code>arr2</code>&nbsp;中的元素&nbsp;<strong>互不相同</strong>&nbsp;。</li>\n</ul>\n\n<p>给你&nbsp;<code>divisor1</code>&nbsp;，<code>divisor2</code>&nbsp;，<code>uniqueCnt1</code>&nbsp;和&nbsp;<code>uniqueCnt2</code>&nbsp;，请你返回两个数组中&nbsp;<strong>最大元素</strong>&nbsp;的&nbsp;<strong>最小值</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>divisor1 = 2, divisor2 = 7, uniqueCnt1 = 1, uniqueCnt2 = 3\n<b>输出：</b>4\n<b>解释：</b>\n我们可以把前 4 个自然数划分到 arr1 和 arr2 中。\narr1 = [1] 和 arr2 = [2,3,4] 。\n可以看出两个数组都满足条件。\n最大值是 4 ，所以返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>divisor1 = 3, divisor2 = 5, uniqueCnt1 = 2, uniqueCnt2 = 1\n<b>输出：</b>3\n<b>解释：</b>\narr1 = [1,2] 和 arr2 = [3] 满足所有条件。\n最大值是 3 ，所以返回 3 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>divisor1 = 2, divisor2 = 4, uniqueCnt1 = 8, uniqueCnt2 = 2\n<b>输出：</b>15\n<b>解释：</b>\n最终数组为 arr1 = [1,3,5,7,9,11,13,15] 和 arr2 = [2,6] 。\n上述方案是满足所有条件的最优解。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= divisor1, divisor2 &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= uniqueCnt1, uniqueCnt2 &lt; 10<sup>9</sup></code></li>\n\t<li><code>2 &lt;= uniqueCnt1 + uniqueCnt2 &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2514.统计同位异构字符串数目",
        "hardRate": "HARD",
        "passRate": "46.24%",
        "problemsUrl": "https://leetcode.cn/problems/count-anagrams/",
        "solutionsUrl": "https://leetcode.cn/problems/count-anagrams/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，它包含一个或者多个单词。单词之间用单个空格&nbsp;<code>' '</code>&nbsp;隔开。</p>\n\n<p>如果字符串 <code>t</code>&nbsp;中第 <code>i</code>&nbsp;个单词是 <code>s</code>&nbsp;中第 <code>i</code>&nbsp;个单词的一个&nbsp;<strong>排列</strong>&nbsp;，那么我们称字符串&nbsp;<code>t</code>&nbsp;是字符串&nbsp;<code>s</code>&nbsp;的同位异构字符串。</p>\n\n<ul>\n\t<li>比方说，<code>\"acb dfe\"</code>&nbsp;是&nbsp;<code>\"abc def\"</code>&nbsp;的同位异构字符串，但是&nbsp;<code>\"def cab\"</code>&nbsp;和&nbsp;<code>\"adc bef\"</code>&nbsp;不是。</li>\n</ul>\n\n<p>请你返回<em>&nbsp;</em><code>s</code>&nbsp;的同位异构字符串的数目，由于答案可能很大，请你将它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong> 后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"too hot\"\n<b>输出：</b>18\n<b>解释：</b>输入字符串的一些同位异构字符串为 \"too hot\" ，\"oot hot\" ，\"oto toh\" ，\"too toh\" 以及 \"too oht\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"aa\"\n<b>输出：</b>1\n<strong>解释：</strong>输入字符串只有一个同位异构字符串。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 只包含小写英文字母和空格&nbsp;<code>' '</code>&nbsp;。</li>\n\t<li>相邻单词之间由单个空格隔开。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2515.到目标字符串的最短距离",
        "hardRate": "EASY",
        "passRate": "55.53%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-distance-to-target-string-in-a-circular-array/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-distance-to-target-string-in-a-circular-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的 <strong>环形</strong> 字符串数组 <code>words</code> 和一个字符串 <code>target</code> 。<strong>环形数组</strong> 意味着数组首尾相连。</p>\n\n<ul>\n\t<li>形式上， <code>words[i]</code> 的下一个元素是 <code>words[(i + 1) % n]</code> ，而 <code>words[i]</code> 的前一个元素是 <code>words[(i - 1 + n) % n]</code> ，其中 <code>n</code> 是 <code>words</code> 的长度。</li>\n</ul>\n\n<p>从 <code>startIndex</code> 开始，你一次可以用 <code>1</code> 步移动到下一个或者前一个单词。</p>\n\n<p>返回到达目标字符串 <code>target</code> 所需的最短距离。如果 <code>words</code> 中不存在字符串 <code>target</code> ，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"hello\",\"i\",\"am\",\"leetcode\",\"hello\"], target = \"hello\", startIndex = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>从下标 1 开始，可以经由以下步骤到达 \"hello\" ：\n- 向右移动 3 个单位，到达下标 4 。\n- 向左移动 2 个单位，到达下标 4 。\n- 向右移动 4 个单位，到达下标 0 。\n- 向左移动 1 个单位，到达下标 0 。\n到达 \"hello\" 的最短距离是 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"a\",\"b\",\"leetcode\"], target = \"leetcode\", startIndex = 0\n<strong>输出：</strong>1\n<strong>解释：</strong>从下标 0 开始，可以经由以下步骤到达 \"leetcode\" ：\n- 向右移动 2 个单位，到达下标 3 。\n- 向左移动 1 个单位，到达下标 3 。\n到达 \"leetcode\" 的最短距离是 1 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"i\",\"eat\",\"leetcode\"], target = \"ate\", startIndex = 0\n<strong>输出：</strong>-1\n<strong>解释：</strong>因为 words 中不存在字符串 \"ate\" ，所以返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><code>words[i]</code> 和 <code>target</code> 仅由小写英文字母组成</li>\n\t<li><code>0 &lt;= startIndex &lt; words.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2516.每种字符至少取 K 个",
        "hardRate": "MEDIUM",
        "passRate": "37.34%",
        "problemsUrl": "https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/",
        "solutionsUrl": "https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/solution",
        "problemsDesc": "<p>给你一个由字符 <code>'a'</code>、<code>'b'</code>、<code>'c'</code> 组成的字符串 <code>s</code> 和一个非负整数 <code>k</code> 。每分钟，你可以选择取走 <code>s</code> <strong>最左侧</strong> 还是 <strong>最右侧</strong> 的那个字符。</p>\n\n<p>你必须取走每种字符 <strong>至少</strong> <code>k</code> 个，返回需要的 <strong>最少</strong> 分钟数；如果无法取到，则返回<em> </em><code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aabaaaacaabc\", k = 2\n<strong>输出：</strong>8\n<strong>解释：</strong>\n从 s 的左侧取三个字符，现在共取到两个字符 'a' 、一个字符 'b' 。\n从 s 的右侧取五个字符，现在共取到四个字符 'a' 、两个字符 'b' 和两个字符 'c' 。\n共需要 3 + 5 = 8 分钟。\n可以证明需要的最少分钟数是 8 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a\", k = 1\n<strong>输出：</strong>-1\n<strong>解释：</strong>无法取到一个字符 'b' 或者 'c'，所以返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 仅由字母 <code>'a'</code>、<code>'b'</code>、<code>'c'</code> 组成</li>\n\t<li><code>0 &lt;= k &lt;= s.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2517.礼盒的最大甜蜜度",
        "hardRate": "MEDIUM",
        "passRate": "71.94%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>price</code> ，其中 <code>price[i]</code> 表示第 <code>i</code> 类糖果的价格，另给你一个正整数 <code>k</code> 。</p>\n\n<p>商店组合 <code>k</code> 类 <strong>不同</strong> 糖果打包成礼盒出售。礼盒的 <strong>甜蜜度</strong> 是礼盒中任意两种糖果 <strong>价格</strong> 绝对差的最小值。</p>\n\n<p>返回礼盒的 <strong>最大 </strong>甜蜜度<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>price = [13,5,1,8,21,2], k = 3\n<strong>输出：</strong>8\n<strong>解释：</strong>选出价格分别为 [13,5,21] 的三类糖果。\n礼盒的甜蜜度为 min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8 。\n可以证明能够取得的最大甜蜜度就是 8 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>price = [1,3,1], k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>选出价格分别为 [1,3] 的两类糖果。 \n礼盒的甜蜜度为 min(|1 - 3|) = min(2) = 2 。\n可以证明能够取得的最大甜蜜度就是 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>price = [7,7,7,7], k = 2\n<strong>输出：</strong>0\n<strong>解释：</strong>从现有的糖果中任选两类糖果，甜蜜度都会是 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= k &lt;= price.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= price[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2518.好分区的数目",
        "hardRate": "HARD",
        "passRate": "42.54%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-great-partitions/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-great-partitions/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>\n\n<p><strong>分区</strong> 的定义是：将数组划分成两个有序的 <strong>组</strong> ，并满足每个元素 <strong>恰好</strong> 存在于 <strong>某一个</strong> 组中。如果分区中每个组的元素和都大于等于 <code>k</code> ，则认为分区是一个好分区。</p>\n\n<p>返回 <strong>不同</strong> 的好分区的数目。由于答案可能很大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后的结果。</p>\n\n<p>如果在两个分区中，存在某个元素 <code>nums[i]</code> 被分在不同的组中，则认为这两个分区不同。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4], k = 4\n<strong>输出：</strong>6\n<strong>解释：</strong>好分区的情况是 ([1,2,3], [4]), ([1,3], [2,4]), ([1,4], [2,3]), ([2,3], [1,4]), ([2,4], [1,3]) 和 ([4], [1,2,3]) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,3,3], k = 4\n<strong>输出：</strong>0\n<strong>解释：</strong>数组中不存在好分区。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [6,6], k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>可以将 nums[0] 放入第一个分区或第二个分区中。\n好分区的情况是 ([6], [6]) 和 ([6], [6]) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, k &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2519.统计 K-Big 索引的数量",
        "hardRate": "HARD",
        "passRate": "74.89%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-k-big-indices/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-k-big-indices/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2520.统计能整除数字的位数",
        "hardRate": "EASY",
        "passRate": "83.14%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-digits-that-divide-a-number/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-digits-that-divide-a-number/solution",
        "problemsDesc": "<p>给你一个整数 <code>num</code> ，返回 <code>num</code> 中能整除 <code>num</code> 的数位的数目。</p>\n\n<p>如果满足&nbsp;<code>nums % val == 0</code> ，则认为整数 <code>val</code> 可以整除 <code>nums</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 7\n<strong>输出：</strong>1\n<strong>解释：</strong>7 被自己整除，因此答案是 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 121\n<strong>输出：</strong>2\n<strong>解释：</strong>121 可以被 1 整除，但无法被 2 整除。由于 1 出现两次，所以返回 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = 1248\n<strong>输出：</strong>4\n<strong>解释：</strong>1248 可以被它每一位上的数字整除，因此答案是 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10<sup>9</sup></code></li>\n\t<li><code>num</code> 的数位中不含 <code>0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2521.数组乘积中的不同质因数数目",
        "hardRate": "MEDIUM",
        "passRate": "62.72%",
        "problemsUrl": "https://leetcode.cn/problems/distinct-prime-factors-of-product-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/distinct-prime-factors-of-product-of-array/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>nums</code> ，对 <code>nums</code> 所有元素求积之后，找出并返回乘积中 <strong>不同质因数</strong> 的数目。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><strong>质数</strong> 是指大于 <code>1</code> 且仅能被 <code>1</code> 及自身整除的数字。</li>\n\t<li>如果 <code>val2 / val1</code> 是一个整数，则整数 <code>val1</code> 是另一个整数 <code>val2</code> 的一个因数。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,4,3,7,10,6]\n<strong>输出：</strong>4\n<strong>解释：</strong>\nnums 中所有元素的乘积是：2 * 4 * 3 * 7 * 10 * 6 = 10080 = 2<sup>5</sup> * 3<sup>2</sup> * 5 * 7 。\n共有 4 个不同的质因数，所以返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,4,8,16]\n<strong>输出：</strong>1\n<strong>解释：</strong>\nnums 中所有元素的乘积是：2 * 4 * 8 * 16 = 1024 = 2<sup>10</sup> 。\n共有 1 个不同的质因数，所以返回 1 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>2 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2522.将字符串分割成值不超过 K 的子字符串",
        "hardRate": "MEDIUM",
        "passRate": "49.50%",
        "problemsUrl": "https://leetcode.cn/problems/partition-string-into-substrings-with-values-at-most-k/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-string-into-substrings-with-values-at-most-k/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，它每一位都是&nbsp;<code>1</code>&nbsp;到&nbsp;<code>9</code>&nbsp;之间的数字组成，同时给你一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>如果一个字符串 <code>s</code>&nbsp;的分割满足以下条件，我们称它是一个 <strong>好</strong>&nbsp;分割：</p>\n\n<ul>\n\t<li><code>s</code>&nbsp;中每个数位 <strong>恰好</strong>&nbsp;属于一个子字符串。</li>\n\t<li>每个子字符串的值都小于等于&nbsp;<code>k</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回 <code>s</code>&nbsp;所有的 <strong>好</strong>&nbsp;分割中，子字符串的&nbsp;<strong>最少</strong>&nbsp;数目。如果不存在 <code>s</code>&nbsp;的<strong>&nbsp;好</strong>&nbsp;分割，返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p><b>注意：</b></p>\n\n<ul>\n\t<li>一个字符串的 <strong>值</strong>&nbsp;是这个字符串对应的整数。比方说，<code>\"123\"</code>&nbsp;的值为&nbsp;<code>123</code>&nbsp;，<code>\"1\"</code>&nbsp;的值是&nbsp;<code>1</code>&nbsp;。</li>\n\t<li><strong>子字符串</strong>&nbsp;是字符串中一段连续的字符序列。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"165462\", k = 60\n<b>输出：</b>4\n<b>解释：</b>我们将字符串分割成子字符串 \"16\" ，\"54\" ，\"6\" 和 \"2\" 。每个子字符串的值都小于等于 k = 60 。\n不存在小于 4 个子字符串的好分割。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"238182\", k = 5\n<b>输出：</b>-1\n<strong>解释：</strong>这个字符串不存在好分割。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code>&nbsp;是&nbsp;<code>'1'</code>&nbsp;到&nbsp;<code>'9'</code>&nbsp;之间的数字。</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2523.范围内最接近的两个质数",
        "hardRate": "MEDIUM",
        "passRate": "41.37%",
        "problemsUrl": "https://leetcode.cn/problems/closest-prime-numbers-in-range/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-prime-numbers-in-range/solution",
        "problemsDesc": "<p>给你两个正整数&nbsp;<code>left</code> 和&nbsp;<code>right</code>&nbsp;，请你找到两个整数&nbsp;<code>num1</code> 和&nbsp;<code>num2</code>&nbsp;，它们满足：</p>\n\n<ul>\n\t<li><code>left &lt;= nums1 &lt; nums2 &lt;= right&nbsp;</code>&nbsp;。</li>\n\t<li><code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;都是 <strong>质数</strong>&nbsp;。</li>\n\t<li><code>nums2 - nums1</code>&nbsp;是满足上述条件的质数对中的 <strong>最小值</strong>&nbsp;。</li>\n</ul>\n\n<p>请你返回正整数数组&nbsp;<code>ans = [nums1, nums2]</code>&nbsp;。如果有多个整数对满足上述条件，请你返回&nbsp;<code>nums1</code>&nbsp;最小的质数对。如果不存在符合题意的质数对，请你返回&nbsp;<code>[-1, -1]</code>&nbsp;。</p>\n\n<p>如果一个整数大于&nbsp;<code>1</code>&nbsp;，且只能被&nbsp;<code>1</code> 和它自己整除，那么它是一个质数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>left = 10, right = 19\n<b>输出：</b>[11,13]\n<b>解释：</b>10 到 19 之间的质数为 11 ，13 ，17 和 19 。\n质数对的最小差值是 2 ，[11,13] 和 [17,19] 都可以得到最小差值。\n由于 11 比 17 小，我们返回第一个质数对。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>left = 4, right = 6\n<b>输出：</b>[-1,-1]\n<b>解释：</b>给定范围内只有一个质数，所以题目条件无法被满足。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= left &lt;= right &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2524.子数组的最大频率分数",
        "hardRate": "HARD",
        "passRate": "50.52%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-frequency-score-of-a-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-frequency-score-of-a-subarray/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2525.根据规则将箱子分类",
        "hardRate": "EASY",
        "passRate": "47.42%",
        "problemsUrl": "https://leetcode.cn/problems/categorize-box-according-to-criteria/",
        "solutionsUrl": "https://leetcode.cn/problems/categorize-box-according-to-criteria/solution",
        "problemsDesc": "<p>给你四个整数&nbsp;<code>length</code>&nbsp;，<code>width</code>&nbsp;，<code>height</code>&nbsp;和&nbsp;<code>mass</code>&nbsp;，分别表示一个箱子的三个维度和质量，请你返回一个表示箱子 <strong>类别</strong> 的字符串。</p>\n\n<ul>\n\t<li>如果满足以下条件，那么箱子是&nbsp;<code>\"Bulky\"</code>&nbsp;的：\n\n\t<ul>\n\t\t<li>箱子 <strong>至少有一个</strong> 维度大于等于 <code>10<sup>4</sup></code>&nbsp;。</li>\n\t\t<li>或者箱子的 <strong>体积</strong> 大于等于&nbsp;<code>10<sup>9</sup></code>&nbsp;。</li>\n\t</ul>\n\t</li>\n\t<li>如果箱子的质量大于等于&nbsp;<code>100</code>&nbsp;，那么箱子是&nbsp;<code>\"Heavy\"</code>&nbsp;的。</li>\n\t<li>如果箱子同时是&nbsp;<code>\"Bulky\"</code> 和&nbsp;<code>\"Heavy\"</code>&nbsp;，那么返回类别为&nbsp;<code>\"Both\"</code>&nbsp;。</li>\n\t<li>如果箱子既不是&nbsp;<code>\"Bulky\"</code>&nbsp;，也不是&nbsp;<code>\"Heavy\"</code>&nbsp;，那么返回类别为&nbsp;<code>\"Neither\"</code>&nbsp;。</li>\n\t<li>如果箱子是&nbsp;<code>\"Bulky\"</code>&nbsp;但不是&nbsp;<code>\"Heavy\"</code>&nbsp;，那么返回类别为&nbsp;<code>\"Bulky\"</code>&nbsp;。</li>\n\t<li>如果箱子是&nbsp;<code>\"Heavy\"</code>&nbsp;但不是&nbsp;<code>\"Bulky\"</code>&nbsp;，那么返回类别为&nbsp;<code>\"Heavy\"</code>&nbsp;。</li>\n</ul>\n\n<p><strong>注意</strong>，箱子的体积等于箱子的长度、宽度和高度的乘积。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>length = 1000, width = 35, height = 700, mass = 300\n<b>输出：</b>\"Heavy\"\n<b>解释：</b>\n箱子没有任何维度大于等于 10<sup>4 </sup>。\n体积为 24500000 &lt;= 10<sup>9 </sup>。所以不能归类为 \"Bulky\" 。\n但是质量 &gt;= 100 ，所以箱子是 \"Heavy\" 的。\n由于箱子不是 \"Bulky\" 但是是 \"Heavy\" ，所以我们返回 \"Heavy\" 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>length = 200, width = 50, height = 800, mass = 50\n<b>输出：</b>\"Neither\"\n<b>解释：</b>\n箱子没有任何维度大于等于 10<sup>4</sup>&nbsp;。\n体积为 8 * 10<sup>6</sup> &lt;= 10<sup>9</sup>&nbsp;。所以不能归类为 \"Bulky\" 。\n质量小于 100 ，所以不能归类为 \"Heavy\" 。\n由于不属于上述两者任何一类，所以我们返回 \"Neither\" 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= length, width, height &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= mass &lt;= 10<sup>3</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2526.找到数据流中的连续整数",
        "hardRate": "MEDIUM",
        "passRate": "54.27%",
        "problemsUrl": "https://leetcode.cn/problems/find-consecutive-integers-from-a-data-stream/",
        "solutionsUrl": "https://leetcode.cn/problems/find-consecutive-integers-from-a-data-stream/solution",
        "problemsDesc": "<p>给你一个整数数据流，请你实现一个数据结构，检查数据流中最后&nbsp;<code>k</code>&nbsp;个整数是否 <strong>等于</strong> 给定值&nbsp;<code>value</code>&nbsp;。</p>\n\n<p>请你实现&nbsp;<strong>DataStream</strong>&nbsp;类：</p>\n\n<ul>\n\t<li><code>DataStream(int value, int k)</code>&nbsp;用两个整数 <code>value</code>&nbsp;和 <code>k</code>&nbsp;初始化一个空的整数数据流。</li>\n\t<li><code>boolean consec(int num)</code>&nbsp;将&nbsp;<code>num</code>&nbsp;添加到整数数据流。如果后 <code>k</code>&nbsp;个整数都等于&nbsp;<code>value</code>&nbsp;，返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。如果少于&nbsp;<code>k</code>&nbsp;个整数，条件不满足，所以也返回&nbsp;<code>false</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"DataStream\", \"consec\", \"consec\", \"consec\", \"consec\"]\n[[4, 3], [4], [4], [4], [3]]\n<strong>输出：</strong>\n[null, false, false, true, false]\n\n<strong>解释：</strong>\nDataStream dataStream = new DataStream(4, 3); // value = 4, k = 3 \ndataStream.consec(4); // 数据流中只有 1 个整数，所以返回 False 。\ndataStream.consec(4); // 数据流中只有 2 个整数\n                      // 由于 2 小于 k ，返回 False 。\ndataStream.consec(4); // 数据流最后 3 个整数都等于 value， 所以返回 True 。\ndataStream.consec(3); // 最后 k 个整数分别是 [4,4,3] 。\n                      // 由于 3 不等于 value ，返回 False 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= value, num &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li>至多调用 <code>consec</code>&nbsp;次数为&nbsp;<code>10<sup>5</sup></code>&nbsp;次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2527.查询数组 Xor 美丽值",
        "hardRate": "MEDIUM",
        "passRate": "70.42%",
        "problemsUrl": "https://leetcode.cn/problems/find-xor-beauty-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-xor-beauty-of-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>三个下标&nbsp;<code>i</code>&nbsp;，<code>j</code>&nbsp;和&nbsp;<code>k</code>&nbsp;的 <strong>有效值</strong>&nbsp;定义为&nbsp;<code>((nums[i] | nums[j]) &amp; nums[k])</code>&nbsp;。</p>\n\n<p>一个数组的 <strong>xor 美丽值</strong>&nbsp;是数组中所有满足&nbsp;<code>0 &lt;= i, j, k &lt; n</code>&nbsp;&nbsp;<strong>的三元组</strong>&nbsp;<code>(i, j, k)</code>&nbsp;的 <strong>有效值</strong>&nbsp;的异或结果。</p>\n\n<p>请你返回&nbsp;<code>nums</code>&nbsp;的 xor 美丽值。</p>\n\n<p><b>注意：</b></p>\n\n<ul>\n\t<li><code>val1 | val2</code>&nbsp;是&nbsp;<code>val1</code> 和&nbsp;<code>val2</code>&nbsp;的按位或。</li>\n\t<li><code>val1 &amp; val2</code>&nbsp;是&nbsp;<code>val1</code> 和&nbsp;<code>val2</code>&nbsp;的按位与。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,4]\n<b>输出：</b>5\n<b>解释：</b>\n三元组和它们对应的有效值如下：\n- (0,0,0) 有效值为 ((1 | 1) &amp; 1) = 1\n- (0,0,1) 有效值为 ((1 | 1) &amp; 4) = 0\n- (0,1,0) 有效值为 ((1 | 4) &amp; 1) = 1\n- (0,1,1) 有效值为 ((1 | 4) &amp; 4) = 4\n- (1,0,0) 有效值为 ((4 | 1) &amp; 1) = 1\n- (1,0,1) 有效值为 ((4 | 1) &amp; 4) = 4\n- (1,1,0) 有效值为 ((4 | 4) &amp; 1) = 0\n- (1,1,1) 有效值为 ((4 | 4) &amp; 4) = 4 \n数组的 xor 美丽值为所有有效值的按位异或 1 ^ 0 ^ 1 ^ 4 ^ 1 ^ 4 ^ 0 ^ 4 = 5 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [15,45,20,2,34,35,5,44,32,30]\n<b>输出：</b>34\n<code><span style=\"\"><b>解释：</b>数组的 xor 美丽值为</span> 34 。</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length&nbsp;&lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2528.最大化城市的最小供电站数目",
        "hardRate": "HARD",
        "passRate": "40.66%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-the-minimum-powered-city/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-the-minimum-powered-city/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>stations</code>&nbsp;，其中&nbsp;<code>stations[i]</code>&nbsp;表示第 <code>i</code>&nbsp;座城市的供电站数目。</p>\n\n<p>每个供电站可以在一定 <strong>范围</strong>&nbsp;内给所有城市提供电力。换句话说，如果给定的范围是&nbsp;<code>r</code>&nbsp;，在城市&nbsp;<code>i</code>&nbsp;处的供电站可以给所有满足&nbsp;<code>|i - j| &lt;= r</code> 且&nbsp;<code>0 &lt;= i, j &lt;= n - 1</code>&nbsp;的城市&nbsp;<code>j</code>&nbsp;供电。</p>\n\n<ul>\n\t<li><code>|x|</code>&nbsp;表示 <code>x</code>&nbsp;的 <strong>绝对值</strong>&nbsp;。比方说，<code>|7 - 5| = 2</code>&nbsp;，<code>|3 - 10| = 7</code>&nbsp;。</li>\n</ul>\n\n<p>一座城市的 <strong>电量</strong>&nbsp;是所有能给它供电的供电站数目。</p>\n\n<p>政府批准了可以额外建造 <code>k</code>&nbsp;座供电站，你需要决定这些供电站分别应该建在哪里，这些供电站与已经存在的供电站有相同的供电范围。</p>\n\n<p>给你两个整数&nbsp;<code>r</code> 和&nbsp;<code>k</code>&nbsp;，如果以最优策略建造额外的发电站，返回所有城市中，最小供电站数目的最大值是多少。</p>\n\n<p>这 <code>k</code>&nbsp;座供电站可以建在多个城市。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>stations = [1,2,4,5,0], r = 1, k = 2\n<b>输出：</b>5\n<b>解释：</b>\n最优方案之一是把 2 座供电站都建在城市 1 。\n每座城市的供电站数目分别为 [1,4,4,5,0] 。\n- 城市 0 的供电站数目为 1 + 4 = 5 。\n- 城市 1 的供电站数目为 1 + 4 + 4 = 9 。\n- 城市 2 的供电站数目为 4 + 4 + 5 = 13 。\n- 城市 3 的供电站数目为 5 + 4 = 9 。\n- 城市 4 的供电站数目为 5 + 0 = 5 。\n供电站数目最少是 5 。\n无法得到更优解，所以我们返回 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>stations = [4,4,4,4], r = 0, k = 3\n<b>输出：</b>4\n<b>解释：</b>\n无论如何安排，总有一座城市的供电站数目是 4 ，所以最优解是 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == stations.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= stations[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= r&nbsp;&lt;= n - 1</code></li>\n\t<li><code>0 &lt;= k&nbsp;&lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2529.正整数和负整数的最大计数",
        "hardRate": "EASY",
        "passRate": "76.08%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/solution",
        "problemsDesc": "<p>给你一个按 <strong>非递减顺序</strong> 排列的数组 <code>nums</code> ，返回正整数数目和负整数数目中的最大值。</p>\n\n<ul>\n\t<li>换句话讲，如果 <code>nums</code> 中正整数的数目是 <code>pos</code> ，而负整数的数目是 <code>neg</code> ，返回 <code>pos</code> 和 <code>neg</code>二者中的最大值。</li>\n</ul>\n\n<p><strong>注意：</strong><code>0</code> 既不是正整数也不是负整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-2,-1,-1,1,2,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>共有 3 个正整数和 3 个负整数。计数得到的最大值是 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-3,-2,-1,0,0,1,2]\n<strong>输出：</strong>3\n<strong>解释：</strong>共有 2 个正整数和 3 个负整数。计数得到的最大值是 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,20,66,1314]\n<strong>输出：</strong>4\n<strong>解释：</strong>共有 4 个正整数和 0 个负整数。计数得到的最大值是 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2000</code></li>\n\t<li><code>-2000 &lt;= nums[i] &lt;= 2000</code></li>\n\t<li><code>nums</code> 按 <strong>非递减顺序</strong> 排列。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以设计并实现时间复杂度为 <code>O(log(n))</code> 的算法解决此问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2530.执行 K 次操作后的最大分数",
        "hardRate": "MEDIUM",
        "passRate": "45.02%",
        "problemsUrl": "https://leetcode.cn/problems/maximal-score-after-applying-k-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/maximal-score-after-applying-k-operations/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>k</code> 。你的 <strong>起始分数</strong> 为 <code>0</code> 。</p>\n\n<p>在一步 <strong>操作</strong> 中：</p>\n\n<ol>\n\t<li>选出一个满足 <code>0 &lt;= i &lt; nums.length</code> 的下标 <code>i</code> ，</li>\n\t<li>将你的 <strong>分数</strong> 增加 <code>nums[i]</code> ，并且</li>\n\t<li>将 <code>nums[i]</code> 替换为 <code>ceil(nums[i] / 3)</code> 。</li>\n</ol>\n\n<p>返回在 <strong>恰好</strong> 执行 <code>k</code> 次操作后，你可能获得的最大分数。</p>\n\n<p>向上取整函数 <code>ceil(val)</code> 的结果是大于或等于 <code>val</code> 的最小整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,10,10,10,10], k = 5\n<strong>输出：</strong>50\n<strong>解释：</strong>对数组中每个元素执行一次操作。最后分数是 10 + 10 + 10 + 10 + 10 = 50 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,10,3,3,3], k = 3\n<strong>输出：</strong>17\n<strong>解释：</strong>可以执行下述操作：\n第 1 步操作：选中 i = 1 ，nums 变为 [1,<em><strong>4</strong></em>,3,3,3] 。分数增加 10 。\n第 2 步操作：选中 i = 1 ，nums 变为 [1,<em><strong>2</strong></em>,3,3,3] 。分数增加 4 。\n第 3 步操作：选中 i = 2 ，nums 变为 [1,1,<em><strong>1</strong></em>,3,3] 。分数增加 3 。\n最后分数是 10 + 4 + 3 = 17 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2531.使字符串总不同字符的数目相等",
        "hardRate": "MEDIUM",
        "passRate": "29.72%",
        "problemsUrl": "https://leetcode.cn/problems/make-number-of-distinct-characters-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/make-number-of-distinct-characters-equal/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong> 开始的字符串 <code>word1</code> 和 <code>word2</code> 。</p>\n\n<p>一次 <strong>移动</strong> 由以下两个步骤组成：</p>\n\n<ul>\n\t<li>选中两个下标&nbsp;<code>i</code> 和 <code>j</code> ，分别满足 <code>0 &lt;= i &lt; word1.length</code> 和 <code>0 &lt;= j &lt; word2.length</code> ，</li>\n\t<li>交换 <code>word1[i]</code> 和 <code>word2[j]</code> 。</li>\n</ul>\n\n<p>如果可以通过 <strong>恰好一次</strong> 移动，使 <code>word1</code> 和 <code>word2</code> 中不同字符的数目相等，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>word1 = \"ac\", word2 = \"b\"\n<strong>输出：</strong>false\n<strong>解释：</strong>交换任何一组下标都会导致第一个字符串中有 2 个不同的字符，而在第二个字符串中只有 1 个不同字符。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>word1 = \"abcc\", word2 = \"aab\"\n<strong>输出：</strong>true\n<strong>解释：</strong>交换第一个字符串的下标 2 和第二个字符串的下标 0 。之后得到 word1 = \"abac\" 和 word2 = \"cab\" ，各有 3 个不同字符。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>word1 = \"abcde\", word2 = \"fghij\"\n<strong>输出：</strong>true\n<strong>解释：</strong>无论交换哪一组下标，两个字符串中都会有 5 个不同字符。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word1.length, word2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>word1</code> 和 <code>word2</code> 仅由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2532.过桥的时间",
        "hardRate": "HARD",
        "passRate": "69.01%",
        "problemsUrl": "https://leetcode.cn/problems/time-to-cross-a-bridge/",
        "solutionsUrl": "https://leetcode.cn/problems/time-to-cross-a-bridge/solution",
        "problemsDesc": "<p>共有 <code>k</code> 位工人计划将 <code>n</code> 个箱子从旧仓库移动到新仓库。给你两个整数 <code>n</code> 和 <code>k</code>，以及一个二维整数数组 <code>time</code> ，数组的大小为 <code>k x 4</code> ，其中 <code>time[i] = [leftToRight<sub>i</sub>, pickOld<sub>i</sub>, rightToLeft<sub>i</sub>, putNew<sub>i</sub>]</code> 。</p>\n\n<p>一条河将两座仓库分隔，只能通过一座桥通行。旧仓库位于河的右岸，新仓库在河的左岸。开始时，所有 <code>k</code> 位工人都在桥的左侧等待。为了移动这些箱子，第 <code>i</code> 位工人（下标从 <strong>0</strong> 开始）可以：</p>\n\n<ul>\n\t<li>从左岸（新仓库）跨过桥到右岸（旧仓库），用时 <code>leftToRight<sub>i</sub></code> 分钟。</li>\n\t<li>从旧仓库选择一个箱子，并返回到桥边，用时 <code>pickOld<sub>i</sub></code> 分钟。不同工人可以同时搬起所选的箱子。</li>\n\t<li>从右岸（旧仓库）跨过桥到左岸（新仓库），用时 <code>rightToLeft<sub>i</sub></code> 分钟。</li>\n\t<li>将箱子放入新仓库，并返回到桥边，用时 <code>putNew<sub>i</sub></code> 分钟。不同工人可以同时放下所选的箱子。</li>\n</ul>\n\n<p>如果满足下面任一条件，则认为工人 <code>i</code> 的 <strong>效率低于</strong> 工人 <code>j</code> ：</p>\n\n<ul>\n\t<li><code>leftToRight<sub>i</sub> + rightToLeft<sub>i</sub> &gt; leftToRight<sub>j</sub> + rightToLeft<sub>j</sub></code></li>\n\t<li><code>leftToRight<sub>i</sub> + rightToLeft<sub>i</sub> == leftToRight<sub>j</sub> + rightToLeft<sub>j</sub></code> 且 <code>i &gt; j</code></li>\n</ul>\n\n<p>工人通过桥时需要遵循以下规则：</p>\n\n<ul>\n\t<li>如果工人 <code>x</code> 到达桥边时，工人 <code>y</code> 正在过桥，那么工人 <code>x</code> 需要在桥边等待。</li>\n\t<li>如果没有正在过桥的工人，那么在桥右边等待的工人可以先过桥。如果同时有多个工人在右边等待，那么 <strong>效率最低</strong> 的工人会先过桥。</li>\n\t<li>如果没有正在过桥的工人，且桥右边也没有在等待的工人，同时旧仓库还剩下至少一个箱子需要搬运，此时在桥左边的工人可以过桥。如果同时有多个工人在左边等待，那么 <strong>效率最低</strong> 的工人会先过桥。</li>\n</ul>\n\n<p>所有 <code>n</code> 个盒子都需要放入新仓库，<span class=\"text-only\" data-eleid=\"8\" style=\"white-space: pre;\">请你返回最后一个搬运箱子的工人 </span><strong><span class=\"text-only\" data-eleid=\"9\" style=\"white-space: pre;\">到达河左岸</span></strong><span class=\"text-only\" data-eleid=\"10\" style=\"white-space: pre;\"> 的时间。</span></p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, k = 3, time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n从 0 到 1 ：工人 2 从左岸过桥到达右岸。\n从 1 到 2 ：工人 2 从旧仓库搬起一个箱子。\n从 2 到 6 ：工人 2 从右岸过桥到达左岸。\n从 6 到 7 ：工人 2 将箱子放入新仓库。\n整个过程在 7 分钟后结束。因为问题关注的是最后一个工人到达左岸的时间，所以返回 6 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 2, time = [[1,9,1,8],[10,10,10,10]]\n<strong>输出：</strong>50\n<strong>解释：</strong>\n从 0 到 10 ：工人 1 从左岸过桥到达右岸。\n从 10 到 20 ：工人 1 从旧仓库搬起一个箱子。\n从 10 到 11 ：工人 0 从左岸过桥到达右岸。\n从 11 到 20 ：工人 0 从旧仓库搬起一个箱子。\n从 20 到 30 ：工人 1 从右岸过桥到达左岸。\n从 30 到 40 ：工人 1 将箱子放入新仓库。\n从 30 到 31 ：工人 0 从右岸过桥到达左岸。\n从 31 到 39 ：工人 0 将箱子放入新仓库。\n从 39 到 40 ：工人 0 从左岸过桥到达右岸。\n从 40 到 49 ：工人 0 从旧仓库搬起一个箱子。\n从 49 到 50 ：工人 0 从右岸过桥到达左岸。\n从 50 到 58 ：工人 0 将箱子放入新仓库。\n整个过程在 58 分钟后结束。因为问题关注的是最后一个工人到达左岸的时间，所以返回 50 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n, k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>time.length == k</code></li>\n\t<li><code>time[i].length == 4</code></li>\n\t<li><code>1 &lt;= leftToRight<sub>i</sub>, pickOld<sub>i</sub>, rightToLeft<sub>i</sub>, putNew<sub>i</sub> &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2533.好二进制字符串的数量",
        "hardRate": "MEDIUM",
        "passRate": "69.48%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-good-binary-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-good-binary-strings/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2534.通过门的时间",
        "hardRate": "HARD",
        "passRate": "63.69%",
        "problemsUrl": "https://leetcode.cn/problems/time-taken-to-cross-the-door/",
        "solutionsUrl": "https://leetcode.cn/problems/time-taken-to-cross-the-door/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2535.数组元素和与数字和的绝对差",
        "hardRate": "EASY",
        "passRate": "84.08%",
        "problemsUrl": "https://leetcode.cn/problems/difference-between-element-sum-and-digit-sum-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/difference-between-element-sum-and-digit-sum-of-an-array/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>nums</code> 。</p>\n\n<ul>\n\t<li><strong>元素和</strong> 是 <code>nums</code> 中的所有元素相加求和。</li>\n\t<li><strong>数字和</strong> 是&nbsp;<code>nums</code> 中每一个元素的每一数位（重复数位需多次求和）相加求和。</li>\n</ul>\n\n<p>返回 <strong>元素和</strong> 与 <strong>数字和</strong> 的绝对差。</p>\n\n<p><strong>注意：</strong>两个整数 <code>x</code> 和 <code>y</code> 的绝对差定义为 <code>|x - y|</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,15,6,3]\n<strong>输出：</strong>9\n<strong>解释：</strong>\nnums 的元素和是 1 + 15 + 6 + 3 = 25 。\nnums 的数字和是 1 + 1 + 5 + 6 + 3 = 16 。\n元素和与数字和的绝对差是 |25 - 16| = 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>0\n<strong>解释：</strong>\nnums 的元素和是 1 + 2 + 3 + 4 = 10 。\nnums 的数字和是 1 + 2 + 3 + 4 = 10 。\n元素和与数字和的绝对差是 |10 - 10| = 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 2000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2536.子矩阵元素加 1",
        "hardRate": "MEDIUM",
        "passRate": "60.67%",
        "problemsUrl": "https://leetcode.cn/problems/increment-submatrices-by-one/",
        "solutionsUrl": "https://leetcode.cn/problems/increment-submatrices-by-one/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> ，表示最初有一个 <code>n x n</code> 、下标从 <strong>0</strong> 开始的整数矩阵 <code>mat</code> ，矩阵中填满了 0 。</p>\n\n<p>另给你一个二维整数数组 <code>query</code> 。针对每个查询 <code>query[i] = [row1<sub>i</sub>, col1<sub>i</sub>, row2<sub>i</sub>, col2<sub>i</sub>]</code> ，请你执行下述操作：</p>\n\n<ul>\n\t<li>找出 <strong>左上角</strong> 为 <code>(row1<sub>i</sub>, col1<sub>i</sub>)</code> 且 <strong>右下角</strong> 为 <code>(row2<sub>i</sub>, col2<sub>i</sub>)</code> 的子矩阵，将子矩阵中的 <strong>每个元素</strong> 加 <code>1</code> 。也就是给所有满足 <code>row1<sub>i</sub> &lt;= x &lt;= row2<sub>i</sub></code> 和 <code>col1<sub>i</sub> &lt;= y &lt;= col2<sub>i</sub></code> 的 <code>mat[x][y]</code> 加 <code>1</code> 。</li>\n</ul>\n\n<p>返回执行完所有操作后得到的矩阵 <code>mat</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/24/p2example11.png\" style=\"width: 531px; height: 121px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 3, queries = [[1,1,2,2],[0,0,1,1]]\n<strong>输出：</strong>[[1,1,0],[1,2,1],[0,1,1]]\n<strong>解释：</strong>上图所展示的分别是：初始矩阵、执行完第一个操作后的矩阵、执行完第二个操作后的矩阵。\n- 第一个操作：将左上角为 (1, 1) 且右下角为 (2, 2) 的子矩阵中的每个元素加 1 。 \n- 第二个操作：将左上角为 (0, 0) 且右下角为 (1, 1) 的子矩阵中的每个元素加 1 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/24/p2example22.png\" style=\"width: 261px; height: 82px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 2, queries = [[0,0,1,1]]\n<strong>输出：</strong>[[1,1],[1,1]]\n<strong>解释：</strong>上图所展示的分别是：初始矩阵、执行完第一个操作后的矩阵。 \n- 第一个操作：将矩阵中的每个元素加 1 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= row1<sub>i</sub> &lt;= row2<sub>i</sub> &lt; n</code></li>\n\t<li><code>0 &lt;= col1<sub>i</sub> &lt;= col2<sub>i</sub> &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2537.统计好子数组的数目",
        "hardRate": "MEDIUM",
        "passRate": "48.78%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-good-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-good-subarrays/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>&nbsp;和一个整数 <code>k</code>&nbsp;，请你返回 <code>nums</code>&nbsp;中 <strong>好</strong>&nbsp;子数组的数目。</p>\n\n<p>一个子数组 <code>arr</code>&nbsp;如果有 <strong>至少</strong>&nbsp;<code>k</code>&nbsp;对下标 <code>(i, j)</code>&nbsp;满足 <code>i &lt; j</code>&nbsp;且 <code>arr[i] == arr[j]</code>&nbsp;，那么称它是一个 <strong>好</strong>&nbsp;子数组。</p>\n\n<p><strong>子数组</strong>&nbsp;是原数组中一段连续 <strong>非空</strong>&nbsp;的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,1,1,1,1], k = 10\n<b>输出：</b>1\n<b>解释：</b>唯一的好子数组是这个数组本身。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [3,1,4,3,2,2,4], k = 2\n<b>输出：</b>4\n<b>解释：</b>总共有 4 个不同的好子数组：\n- [3,1,4,3,2,2] 有 2 对。\n- [3,1,4,3,2,2,4] 有 3 对。\n- [1,4,3,2,2,4] 有 2 对。\n- [4,3,2,2,4] 有 2 对。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2538.最大价值和与最小价值和的差值",
        "hardRate": "HARD",
        "passRate": "48.48%",
        "problemsUrl": "https://leetcode.cn/problems/difference-between-maximum-and-minimum-price-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/difference-between-maximum-and-minimum-price-sum/solution",
        "problemsDesc": "<p>给你一个 <code>n</code>&nbsp;个节点的无向无根图，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。给你一个整数&nbsp;<code>n</code>&nbsp;和一个长度为 <code>n - 1</code>&nbsp;的二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示树中节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条边。</p>\n\n<p>每个节点都有一个价值。给你一个整数数组&nbsp;<code>price</code>&nbsp;，其中&nbsp;<code>price[i]</code>&nbsp;是第 <code>i</code>&nbsp;个节点的价值。</p>\n\n<p>一条路径的 <strong>价值和</strong>&nbsp;是这条路径上所有节点的价值之和。</p>\n\n<p>你可以选择树中任意一个节点作为根节点&nbsp;<code>root</code>&nbsp;。选择 <code>root</code>&nbsp;为根的 <strong>开销</strong>&nbsp;是以 <code>root</code>&nbsp;为起点的所有路径中，<strong>价值和</strong>&nbsp;最大的一条路径与最小的一条路径的差值。</p>\n\n<p>请你返回所有节点作为根节点的选择中，<strong>最大</strong>&nbsp;的 <strong>开销</strong>&nbsp;为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/01/example14.png\" style=\"width: 556px; height: 231px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\n<b>输出：</b>24\n<b>解释：</b>上图展示了以节点 2 为根的树。左图（红色的节点）是最大价值和路径，右图（蓝色的节点）是最小价值和路径。\n- 第一条路径节点为 [2,1,3,4]：价值为 [7,8,6,10] ，价值和为 31 。\n- 第二条路径节点为 [2] ，价值为 [7] 。\n最大路径和与最小路径和的差值为 24 。24 是所有方案中的最大开销。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/24/p1_example2.png\" style=\"width: 352px; height: 184px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 3, edges = [[0,1],[1,2]], price = [1,1,1]\n<b>输出：</b>2\n<b>解释：</b>上图展示了以节点 0 为根的树。左图（红色的节点）是最大价值和路径，右图（蓝色的节点）是最小价值和路径。\n- 第一条路径包含节点 [0,1,2]：价值为 [1,1,1] ，价值和为 3 。\n- 第二条路径节点为 [0] ，价值为 [1] 。\n最大路径和与最小路径和的差值为 2 。2 是所有方案中的最大开销。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>edges</code> 表示一棵符合题面要求的树。</li>\n\t<li><code>price.length == n</code></li>\n\t<li><code>1 &lt;= price[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2539.好子序列的个数",
        "hardRate": "MEDIUM",
        "passRate": "62.93%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-good-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-good-subsequences/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2540.最小公共值",
        "hardRate": "EASY",
        "passRate": "60.34%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-common-value/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-common-value/solution",
        "problemsDesc": "<p>给你两个整数数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;，它们已经按非降序排序，请你返回两个数组的 <strong>最小公共整数</strong>&nbsp;。如果两个数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;没有公共整数，请你返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>如果一个整数在两个数组中都 <strong>至少出现一次</strong>&nbsp;，那么这个整数是数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;<strong>公共</strong>&nbsp;的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,2,3], nums2 = [2,4]\n<b>输出：</b>2\n<b>解释：</b>两个数组的最小公共元素是 2 ，所以我们返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,2,3,6], nums2 = [2,3,4,5]\n<b>输出：</b>2\n<b>解释：</b>两个数组中的公共元素是 2 和 3 ，2 是较小值，所以返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[j] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;都是 <strong>非降序</strong>&nbsp;的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2541.使数组中所有元素相等的最小操作数 II",
        "hardRate": "MEDIUM",
        "passRate": "31.27%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-array-equal-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-array-equal-ii/solution",
        "problemsDesc": "<p>给你两个整数数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;，两个数组长度都是&nbsp;<code>n</code>&nbsp;，再给你一个整数&nbsp;<code>k</code>&nbsp;。你可以对数组&nbsp;<code>nums1</code>&nbsp;进行以下操作：</p>\n\n<ul>\n\t<li>选择两个下标&nbsp;<code>i</code> 和&nbsp;<code>j</code>&nbsp;，将&nbsp;<code>nums1[i]</code>&nbsp;增加&nbsp;<code>k</code>&nbsp;，将&nbsp;<code>nums1[j]</code>&nbsp;减少&nbsp;<code>k</code>&nbsp;。换言之，<code>nums1[i] = nums1[i] + k</code> 且&nbsp;<code>nums1[j] = nums1[j] - k</code>&nbsp;。</li>\n</ul>\n\n<p>如果对于所有满足&nbsp;<code>0 &lt;= i &lt; n</code>&nbsp;都有&nbsp;<code>num1[i] == nums2[i]</code>&nbsp;，那么我们称&nbsp;<code>nums1</code> <strong>等于</strong>&nbsp;<code>nums2</code>&nbsp;。</p>\n\n<p>请你返回使<em>&nbsp;</em><code>nums1</code><em> </em>等于<em>&nbsp;</em><code>nums2</code>&nbsp;的&nbsp;<strong>最少</strong>&nbsp;操作数。如果没办法让它们相等，请你返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [4,3,1,4], nums2 = [1,3,7,1], k = 3\n<b>输出：</b>2\n<b>解释：</b>我们可以通过 2 个操作将 nums1 变成 nums2 。\n第 1 个操作：i = 2 ，j = 0 。操作后得到 nums1 = [1,3,4,4] 。\n第 2 个操作：i = 2 ，j = 3 。操作后得到 nums1 = [1,3,7,1] 。\n无法用更少操作使两个数组相等。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [3,8,5,2], nums2 = [2,4,1,6], k = 1\n<b>输出：</b>-1\n<b>解释：</b>无法使两个数组相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length == nums2.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[j] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2542.最大子序列的分数",
        "hardRate": "MEDIUM",
        "passRate": "51.78%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-subsequence-score/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-subsequence-score/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>&nbsp;，两者长度都是&nbsp;<code>n</code>&nbsp;，再给你一个正整数&nbsp;<code>k</code>&nbsp;。你必须从&nbsp;<code>nums1</code>&nbsp;中选一个长度为 <code>k</code>&nbsp;的 <strong>子序列</strong>&nbsp;对应的下标。</p>\n\n<p>对于选择的下标&nbsp;<code>i<sub>0</sub></code>&nbsp;，<code>i<sub>1</sub></code>&nbsp;，...，&nbsp;<code>i<sub>k - 1</sub></code>&nbsp;，你的&nbsp;<strong>分数</strong>&nbsp;定义如下：</p>\n\n<ul>\n\t<li><code>nums1</code>&nbsp;中下标对应元素求和，乘以&nbsp;<code>nums2</code>&nbsp;中下标对应元素的&nbsp;<strong>最小值</strong>&nbsp;。</li>\n\t<li>用公示表示：&nbsp;<code>(nums1[i<sub>0</sub>] + nums1[i<sub>1</sub>] +...+ nums1[i<sub>k - 1</sub>]) * min(nums2[i<sub>0</sub>] , nums2[i<sub>1</sub>], ... ,nums2[i<sub>k - 1</sub>])</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回 <strong>最大</strong>&nbsp;可能的分数。</p>\n\n<p>一个数组的 <strong>子序列</strong>&nbsp;下标是集合&nbsp;<code>{0, 1, ..., n-1}</code>&nbsp;中删除若干元素得到的剩余集合，也可以不删除任何元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3\n<b>输出：</b>12\n<b>解释：</b>\n四个可能的子序列分数为：\n- 选择下标 0 ，1 和 2 ，得到分数 (1+3+3) * min(2,1,3) = 7 。\n- 选择下标 0 ，1 和 3 ，得到分数 (1+3+2) * min(2,1,4) = 6 。\n- 选择下标 0 ，2 和 3 ，得到分数 (1+3+2) * min(2,3,4) = 12 。\n- 选择下标 1 ，2 和 3 ，得到分数 (3+3+2) * min(1,3,4) = 8 。\n所以最大分数为 12 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [4,2,3,1,1], nums2 = [7,5,10,9,6], k = 1\n<b>输出：</b>30\n<b>解释：</b>\n选择下标 2 最优：nums1[2] * nums2[2] = 3 * 10 = 30 是最大可能分数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length == nums2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2543.判断一个点是否可以到达",
        "hardRate": "HARD",
        "passRate": "46.13%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-point-is-reachable/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-point-is-reachable/solution",
        "problemsDesc": "<p>给你一个无穷大的网格图。一开始你在&nbsp;<code>(1, 1)</code>&nbsp;，你需要通过有限步移动到达点&nbsp;<code>(targetX, targetY)</code>&nbsp;。</p>\n\n<p><b>每一步</b>&nbsp;，你可以从点&nbsp;<code>(x, y)</code>&nbsp;移动到以下点之一：</p>\n\n<ul>\n\t<li><code>(x, y - x)</code></li>\n\t<li><code>(x - y, y)</code></li>\n\t<li><code>(2 * x, y)</code></li>\n\t<li><code>(x, 2 * y)</code></li>\n</ul>\n\n<p>给你两个整数&nbsp;<code>targetX</code> 和&nbsp;<code>targetY</code>&nbsp;，分别表示你最后需要到达点的 X 和 Y 坐标。如果你可以从&nbsp;<code>(1, 1)</code>&nbsp;出发到达这个点，请你返回<code>true</code> ，否则返回<em>&nbsp;</em><code>false</code><em>&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>targetX = 6, targetY = 9\n<b>输出：</b>false\n<b>解释：</b>没法从 (1,1) 出发到达 (6,9) ，所以返回 false 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>targetX = 4, targetY = 7\n<b>输出：</b>true\n<b>解释：</b>你可以按照以下路径到达：(1,1) -&gt; (1,2) -&gt; (1,4) -&gt; (1,8) -&gt; (1,7) -&gt; (2,7) -&gt; (4,7) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= targetX, targetY&nbsp;&lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2544.交替数字和",
        "hardRate": "EASY",
        "passRate": "79.78%",
        "problemsUrl": "https://leetcode.cn/problems/alternating-digit-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/alternating-digit-sum/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> 。<code>n</code> 中的每一位数字都会按下述规则分配一个符号：</p>\n\n<ul>\n\t<li><strong>最高有效位</strong> 上的数字分配到 <strong>正</strong> 号。</li>\n\t<li>剩余每位上数字的符号都与其相邻数字相反。</li>\n</ul>\n\n<p>返回所有数字及其对应符号的和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 521\n<strong>输出：</strong>4\n<strong>解释：</strong>(+5) + (-2) + (+1) = 4</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 111\n<strong>输出：</strong>1\n<strong>解释：</strong>(+1) + (-1) + (+1) = 1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 886996\n<strong>输出：</strong>0\n<strong>解释：</strong>(+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2545.根据第 K 场考试的分数排序",
        "hardRate": "MEDIUM",
        "passRate": "86.41%",
        "problemsUrl": "https://leetcode.cn/problems/sort-the-students-by-their-kth-score/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-the-students-by-their-kth-score/solution",
        "problemsDesc": "<p>班里有 <code>m</code> 位学生，共计划组织 <code>n</code> 场考试。给你一个下标从 <strong>0</strong> 开始、大小为 <code>m x n</code> 的整数矩阵 <code>score</code> ，其中每一行对应一位学生，而 <code>score[i][j]</code> 表示第 <code>i</code> 位学生在第 <code>j</code> 场考试取得的分数。矩阵 <code>score</code> 包含的整数&nbsp;<strong>互不相同</strong>&nbsp;。</p>\n\n<p>另给你一个整数 <code>k</code> 。请你按第 <code>k</code> 场考试分数从高到低完成对这些学生（矩阵中的行）的排序。</p>\n\n<p>返回排序后的矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/30/example1.png\" style=\"width: 600px; height: 136px;\" /></p>\n\n<pre>\n<strong>输入：</strong>score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2\n<strong>输出：</strong>[[7,5,11,2],[10,6,9,1],[4,8,3,15]]\n<strong>解释：</strong>在上图中，S 表示学生，E 表示考试。\n- 下标为 1 的学生在第 2 场考试取得的分数为 11 ，这是考试的最高分，所以 TA 需要排在第一。\n- 下标为 0 的学生在第 2 场考试取得的分数为 9 ，这是考试的第二高分，所以 TA 需要排在第二。\n- 下标为 2 的学生在第 2 场考试取得的分数为 3 ，这是考试的最低分，所以 TA 需要排在第三。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/30/example2.png\" style=\"width: 486px; height: 121px;\" /></p>\n\n<pre>\n<strong>输入：</strong>score = [[3,4],[5,6]], k = 0\n<strong>输出：</strong>[[5,6],[3,4]]\n<strong>解释：</strong>在上图中，S 表示学生，E 表示考试。\n- 下标为 1 的学生在第 0 场考试取得的分数为 5 ，这是考试的最高分，所以 TA 需要排在第一。\n- 下标为 0 的学生在第 0 场考试取得的分数为 3 ，这是考试的最低分，所以 TA 需要排在第二。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == score.length</code></li>\n\t<li><code>n == score[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 250</code></li>\n\t<li><code>1 &lt;= score[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>score</code> 由 <strong>不同</strong> 的整数组成</li>\n\t<li><code>0 &lt;= k &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2546.执行逐位运算使字符串相等",
        "hardRate": "MEDIUM",
        "passRate": "42.20%",
        "problemsUrl": "https://leetcode.cn/problems/apply-bitwise-operations-to-make-strings-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/apply-bitwise-operations-to-make-strings-equal/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong> 开始的 <strong>二元</strong> 字符串 <code>s</code> 和 <code>target</code> ，两个字符串的长度均为 <code>n</code> 。你可以对 <code>s</code> 执行下述操作 <strong>任意</strong> 次：</p>\n\n<ul>\n\t<li>选择两个 <strong>不同</strong> 的下标 <code>i</code> 和 <code>j</code> ，其中 <code>0 &lt;= i, j &lt; n</code> 。</li>\n\t<li>同时，将 <code>s[i]</code> 替换为 (<code>s[i]</code> <strong>OR</strong> <code>s[j]</code>) ，<code>s[j]</code> 替换为 (<code>s[i]</code> <strong>XOR</strong> <code>s[j]</code>) 。</li>\n</ul>\n\n<p>例如，如果 <code>s = \"0110\"</code> ，你可以选择 <code>i = 0</code> 和 <code>j = 2</code>，然后同时将 <code>s[0]</code> 替换为 (<code>s[0]</code> <strong>OR</strong> <code>s[2]</code> = <code>0</code> <strong>OR</strong> <code>1</code> = <code>1</code>)，并将 <code>s[2]</code> 替换为 (<code>s[0]</code> <strong>XOR</strong> <code>s[2]</code> = <code>0</code> <strong>XOR</strong> <code>1</code> = <code>1</code>)，最终得到 <code>s = \"1110\"</code> 。</p>\n\n<p>如果可以使 <code>s</code> 等于 <code>target</code> ，返回 <code>true</code> ，否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"1010\", target = \"0110\"\n<strong>输出：</strong>true\n<strong>解释：</strong>可以执行下述操作：\n- 选择 i = 2 和 j = 0 ，得到 s = \"<em><strong>0</strong></em>0<em><strong>1</strong></em>0\".\n- 选择 i = 2 和 j = 1 ，得到 s = \"0<em><strong>11</strong></em>0\".\n可以使 s 等于 target ，返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"11\", target = \"00\"\n<strong>输出：</strong>false\n<strong>解释：</strong>执行任意次操作都无法使 s 等于 target 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == s.length == target.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 和 <code>target</code> 仅由数字 <code>0</code> 和 <code>1</code> 组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2547.拆分数组的最小代价",
        "hardRate": "HARD",
        "passRate": "56.58%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-split-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-split-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>\n\n<p>将数组拆分成一些非空子数组。拆分的 <strong>代价</strong> 是每个子数组中的 <strong>重要性</strong> 之和。</p>\n\n<p>令 <code>trimmed(subarray)</code> 作为子数组的一个特征，其中所有仅出现一次的数字将会被移除。</p>\n\n<ul>\n\t<li>例如，<code>trimmed([3,1,2,4,3,4]) = [3,4,3,4]</code> 。</li>\n</ul>\n\n<p>子数组的 <strong>重要性</strong> 定义为 <code>k + trimmed(subarray).length</code> 。</p>\n\n<ul>\n\t<li>例如，如果一个子数组是 <code>[1,2,3,3,3,4,4]</code> ，<code>trimmed([1,2,3,3,3,4,4]) = [3,3,3,4,4]</code> 。这个子数组的重要性就是 <code>k + 5</code> 。</li>\n</ul>\n\n<p>找出并返回拆分 <code>nums</code> 的所有可行方案中的最小代价。</p>\n\n<p><strong>子数组</strong> 是数组的一个连续 <strong>非空</strong> 元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,2,1,3,3], k = 2\n<strong>输出：</strong>8\n<strong>解释：</strong>将 nums 拆分成两个子数组：[1,2], [1,2,1,3,3]\n[1,2] 的重要性是 2 + (0) = 2 。\n[1,2,1,3,3] 的重要性是 2 + (2 + 2) = 6 。\n拆分的代价是 2 + 6 = 8 ，可以证明这是所有可行的拆分方案中的最小代价。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,2,1], k = 2\n<strong>输出：</strong>6\n<strong>解释：</strong>将 nums 拆分成两个子数组：[1,2], [1,2,1] 。\n[1,2] 的重要性是 2 + (0) = 2 。\n[1,2,1] 的重要性是 2 + (2) = 4 。\n拆分的代价是 2 + 4 = 6 ，可以证明这是所有可行的拆分方案中的最小代价。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,2,1], k = 5\n<strong>输出：</strong>10\n<strong>解释：</strong>将 nums 拆分成一个子数组：[1,2,1,2,1].\n[1,2,1,2,1] 的重要性是 5 + (3 + 2) = 10 。\n拆分的代价是 10 ，可以证明这是所有可行的拆分方案中的最小代价。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt; nums.length</code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2548.填满背包的最大价格",
        "hardRate": "MEDIUM",
        "passRate": "57.84%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-price-to-fill-a-bag/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-price-to-fill-a-bag/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2549.统计桌面上的不同数字",
        "hardRate": "EASY",
        "passRate": "62.68%",
        "problemsUrl": "https://leetcode.cn/problems/count-distinct-numbers-on-board/",
        "solutionsUrl": "https://leetcode.cn/problems/count-distinct-numbers-on-board/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> ，开始时，它放在桌面上。在 <code>10<sup>9</sup></code> 天内，每天都要执行下述步骤：</p>\n\n<ul>\n\t<li>对于出现在桌面上的每个数字 <code>x</code> ，找出符合 <code>1 &lt;= i &lt;= n</code> 且满足 <code>x % i == 1</code> 的所有数字 <code>i</code> 。</li>\n\t<li>然后，将这些数字放在桌面上。</li>\n</ul>\n\n<p>返回在 <code>10<sup>9</sup></code> 天之后，出现在桌面上的 <strong>不同</strong> 整数的数目。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>一旦数字放在桌面上，则会一直保留直到结束。</li>\n\t<li><code>%</code> 表示取余运算。例如，<code>14 % 3</code> 等于 <code>2</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>4\n<strong>解释：</strong>最开始，5 在桌面上。 \n第二天，2 和 4 也出现在桌面上，因为 5 % 2 == 1 且 5 % 4 == 1 。 \n再过一天 3 也出现在桌面上，因为 4 % 3 == 1 。 \n在十亿天结束时，桌面上的不同数字有 2 、3 、4 、5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3 \n<strong>输出：</strong>2\n<strong>解释：</strong> \n因为 3 % 2 == 1 ，2 也出现在桌面上。 \n在十亿天结束时，桌面上的不同数字只有两个：2 和 3 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2550.猴子碰撞的方法数",
        "hardRate": "MEDIUM",
        "passRate": "29.01%",
        "problemsUrl": "https://leetcode.cn/problems/count-collisions-of-monkeys-on-a-polygon/",
        "solutionsUrl": "https://leetcode.cn/problems/count-collisions-of-monkeys-on-a-polygon/solution",
        "problemsDesc": "<p>现在有一个正凸多边形，其上共有 <code>n</code> 个顶点。顶点按顺时针方向从 <code>0</code> 到 <code>n - 1</code> 依次编号。每个顶点上 <strong>正好有一只猴子</strong> 。下图中是一个 6 个顶点的凸多边形。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/22/hexagon.jpg\" style=\"width: 300px; height: 293px;\" /></p>\n\n<p>每个猴子同时移动到相邻的顶点。顶点 <code>i</code> 的相邻顶点可以是：</p>\n\n<ul>\n\t<li>顺时针方向的顶点 <code>(i + 1) % n</code> ，或</li>\n\t<li>逆时针方向的顶点 <code>(i - 1 + n) % n</code> 。</li>\n</ul>\n\n<p>如果移动后至少有两只猴子停留在同一个顶点上或者相交在一条边上，则会发生 <strong>碰撞</strong> 。</p>\n\n<p>返回猴子至少发生 <strong>一次碰撞 </strong>的移动方法数。由于答案可能非常大，请返回对 <code>10<sup>9</sup>+7</code> 取余后的结果。</p>\n\n<p><strong>注意</strong>，每只猴子只能移动一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>6\n<strong>解释：</strong>共计 8 种移动方式。\n下面列出两种会发生碰撞的方式：\n- 猴子 1 顺时针移动；猴子 2 逆时针移动；猴子 3 顺时针移动。猴子 1 和猴子 2 碰撞。\n- 猴子 1 逆时针移动；猴子 2 逆时针移动；猴子 3 顺时针移动。猴子 1 和猴子 3 碰撞。\n可以证明，有 6 种让猴子碰撞的方法。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>14\n<strong>解释：</strong>可以证明，有 14 种让猴子碰撞的方法。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    }
]