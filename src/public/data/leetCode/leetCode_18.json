[
    {
        "problemsName": " 851.喧闹和富有",
        "hardRate": "MEDIUM",
        "passRate": "63.09%",
        "problemsUrl": "https://leetcode.cn/problems/loud-and-rich/",
        "solutionsUrl": "https://leetcode.cn/problems/loud-and-rich/solution",
        "problemsDesc": "<p>有一组 <code>n</code> 个人作为实验对象，从 <code>0</code> 到 <code>n - 1</code> 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为&nbsp;<code>x</code>&nbsp;的人简称为 \"person&nbsp;<code>x</code>&nbsp;\"。</p>\n\n<p>给你一个数组 <code>richer</code> ，其中 <code>richer[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示 person&nbsp;<code>a<sub>i</sub></code>&nbsp;比 person&nbsp;<code>b<sub>i</sub></code>&nbsp;更有钱。另给你一个整数数组 <code>quiet</code> ，其中&nbsp;<code>quiet[i]</code> 是 person <code>i</code> 的安静值。<code>richer</code> 中所给出的数据 <strong>逻辑自洽</strong>（也就是说，在 person <code>x</code> 比 person <code>y</code> 更有钱的同时，不会出现 person <code>y</code> 比 person <code>x</code> 更有钱的情况 ）。</p>\n\n<p>现在，返回一个整数数组 <code>answer</code> 作为答案，其中&nbsp;<code>answer[x] = y</code>&nbsp;的前提是，在所有拥有的钱肯定不少于&nbsp;person&nbsp;<code>x</code>&nbsp;的人中，person&nbsp;<code>y</code>&nbsp;是最安静的人（也就是安静值&nbsp;<code>quiet[y]</code>&nbsp;最小的人）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\n<strong>输出：</strong>[5,5,2,5,4,5,6,7]\n<strong>解释： </strong>\nanswer[0] = 5，\nperson 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。\n唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7，\n但是目前还不清楚他是否比 person 0 更有钱。\nanswer[7] = 7，\n在所有拥有的钱肯定不少于 person 7 的人中（这可能包括 person 3，4，5，6 以及 7），\n最安静（有较低安静值 quiet[x]）的人是 person 7。\n其他的答案也可以用类似的推理来解释。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>richer = [], quiet = [0]\n<strong>输出：</strong>[0]\n</pre>\n&nbsp;\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == quiet.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>0 &lt;= quiet[i] &lt; n</code></li>\n\t<li><code>quiet</code> 的所有值 <strong>互不相同</strong></li>\n\t<li><code>0 &lt;= richer.length &lt;= n * (n - 1) / 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i </sub>!= b<sub>i</sub></code></li>\n\t<li><code>richer</code> 中的所有数对 <strong>互不相同</strong></li>\n\t<li>对<strong> </strong><code>richer</code> 的观察在逻辑上是一致的</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 852.山脉数组的峰顶索引",
        "hardRate": "MEDIUM",
        "passRate": "68.64%",
        "problemsUrl": "https://leetcode.cn/problems/peak-index-in-a-mountain-array/",
        "solutionsUrl": "https://leetcode.cn/problems/peak-index-in-a-mountain-array/solution",
        "problemsDesc": "符合下列属性的数组 <code>arr</code> 称为 <strong>山脉数组</strong> ：\n<ul>\n\t<li><code>arr.length &gt;= 3</code></li>\n\t<li>存在 <code>i</code>（<code>0 &lt; i&nbsp;&lt; arr.length - 1</code>）使得：\n\t<ul>\n\t\t<li><code>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] </code></li>\n\t\t<li><code>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>给你由整数组成的山脉数组 <code>arr</code> ，返回满足 <code>arr[0] &lt; arr[1] &lt; ... arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code> 的下标 <code>i</code> 。</p>\n\n<p>你必须设计并实现时间复杂度为 <code>O(log(n))</code> 的解决方案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,1,0]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,2,1,0]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,10,5,2]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10<sup>6</sup></code></li>\n\t<li>题目数据保证 <code>arr</code> 是一个山脉数组</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 853.车队",
        "hardRate": "MEDIUM",
        "passRate": "41.40%",
        "problemsUrl": "https://leetcode.cn/problems/car-fleet/",
        "solutionsUrl": "https://leetcode.cn/problems/car-fleet/solution",
        "problemsDesc": "<p>在一条单行道上，有 <code>n</code> 辆车开往同一目的地。目的地是几英里以外的&nbsp;<code>target</code>&nbsp;。</p>\n\n<p>给定两个整数数组&nbsp;<code>position</code>&nbsp;和&nbsp;<code>speed</code>&nbsp;，长度都是 <code>n</code> ，其中&nbsp;<code>position[i]</code>&nbsp;是第 <code>i</code> 辆车的位置，&nbsp;<code>speed[i]</code>&nbsp;是第 <code>i</code> 辆车的速度(单位是英里/小时)。</p>\n\n<p>一辆车永远不会超过前面的另一辆车，但它可以追上去，并与前车 <strong>以相同的速度</strong> 紧接着行驶。此时，我们会忽略这两辆车之间的距离，也就是说，它们被假定处于相同的位置。</p>\n\n<p><strong>车队</strong><em>&nbsp;</em>是一些由行驶在相同位置、具有相同速度的车组成的非空集合。注意，一辆车也可以是一个车队。</p>\n\n<p>即便一辆车在目的地才赶上了一个车队，它们仍然会被视作是同一个车队。</p>\n\n<p>返回到达目的地的 <strong>车队数量</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n从 10 和 8 开始的车会组成一个车队，它们在 12 处相遇。\n从 0 处开始的车无法追上其它车，所以它自己就是一个车队。\n从 5 和 3 开始的车会组成一个车队，它们在 6 处相遇。\n请注意，在到达目的地之前没有其它车会遇到这些车队，所以答案是 3。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> target = 10, position = [3], speed = [3]\n<strong>输出:</strong> 1\n<strong>解释:</strong> 只有一辆车，因此只有一个车队。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> target = 100, position = [0,2,4], speed = [4,2,1]\n<strong>输出:</strong> 1\n<strong>解释:</strong>\n以0(速度4)和2(速度2)出发的车辆组成车队，在4点相遇。舰队以2的速度前进。\n然后，车队(速度2)和以4(速度1)出发的汽车组成一个车队，在6点相遇。舰队以1的速度前进，直到到达目标。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == position.length == speed.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt; target &lt;= 10<sup>6</sup></code></li>\n\t<li><code>0 &lt;= position[i] &lt; target</code></li>\n\t<li><code>position</code>&nbsp;中每个值都 <strong>不同</strong></li>\n\t<li><code>0 &lt; speed[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 854.相似度为 K 的字符串",
        "hardRate": "HARD",
        "passRate": "46.73%",
        "problemsUrl": "https://leetcode.cn/problems/k-similar-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/k-similar-strings/solution",
        "problemsDesc": "<p>对于某些非负整数 <code>k</code> ，如果交换 <code>s1</code> 中两个字母的位置恰好 <code>k</code> 次，能够使结果字符串等于 <code>s2</code> ，则认为字符串 <code>s1</code> 和 <code>s2</code> 的<strong> 相似度为 </strong><code>k</code><strong> </strong><strong>。</strong></p>\n\n<p>给你两个字母异位词 <code>s1</code> 和 <code>s2</code> ，返回 <code>s1</code> 和 <code>s2</code> 的相似度 <code>k</code><strong> </strong>的最小值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"ab\", s2 = \"ba\"\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"abc\", s2 = \"bca\"\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length &lt;= 20</code></li>\n\t<li><code>s2.length == s1.length</code></li>\n\t<li><code>s1</code>&nbsp;和&nbsp;<code>s2</code>&nbsp;&nbsp;只包含集合&nbsp;<code>{'a', 'b', 'c', 'd', 'e', 'f'}</code>&nbsp;中的小写字母</li>\n\t<li><code>s2</code> 是 <code>s1</code> 的一个字母异位词</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 855.考场就座",
        "hardRate": "MEDIUM",
        "passRate": "47.67%",
        "problemsUrl": "https://leetcode.cn/problems/exam-room/",
        "solutionsUrl": "https://leetcode.cn/problems/exam-room/solution",
        "problemsDesc": "<p>在考场里，一排有&nbsp;<code>N</code>&nbsp;个座位，分别编号为&nbsp;<code>0, 1, 2, ..., N-1</code>&nbsp;。</p>\n\n<p>当学生进入考场后，他必须坐在能够使他与离他最近的人之间的距离达到最大化的座位上。如果有多个这样的座位，他会坐在编号最小的座位上。(另外，如果考场里没有人，那么学生就坐在 0 号座位上。)</p>\n\n<p>返回&nbsp;<code>ExamRoom(int N)</code>&nbsp;类，它有两个公开的函数：其中，函数&nbsp;<code>ExamRoom.seat()</code>&nbsp;会返回一个&nbsp;<code>int</code>&nbsp;（整型数据），代表学生坐的位置；函数&nbsp;<code>ExamRoom.leave(int p)</code>&nbsp;代表坐在座位 <code>p</code> 上的学生现在离开了考场。每次调用&nbsp;<code>ExamRoom.leave(p)</code>&nbsp;时都保证有学生坐在座位&nbsp;<code>p</code>&nbsp;上。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>[&quot;ExamRoom&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;leave&quot;,&quot;seat&quot;], [[10],[],[],[],[],[4],[]]\n<strong>输出：</strong>[null,0,9,4,2,null,5]\n<strong>解释：</strong>\nExamRoom(10) -&gt; null\nseat() -&gt; 0，没有人在考场里，那么学生坐在 0 号座位上。\nseat() -&gt; 9，学生最后坐在 9 号座位上。\nseat() -&gt; 4，学生最后坐在 4 号座位上。\nseat() -&gt; 2，学生最后坐在 2 号座位上。\nleave(4) -&gt; null\nseat() -&gt; 5，学生最后坐在 5 号座位上。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= N &lt;= 10^9</code></li>\n\t<li>在所有的测试样例中&nbsp;<code>ExamRoom.seat()</code>&nbsp;和&nbsp;<code>ExamRoom.leave()</code>&nbsp;最多被调用&nbsp;<code>10^4</code>&nbsp;次。</li>\n\t<li>保证在调用&nbsp;<code>ExamRoom.leave(p)</code>&nbsp;时有学生正坐在座位 <code>p</code> 上。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 856.括号的分数",
        "hardRate": "MEDIUM",
        "passRate": "68.44%",
        "problemsUrl": "https://leetcode.cn/problems/score-of-parentheses/",
        "solutionsUrl": "https://leetcode.cn/problems/score-of-parentheses/solution",
        "problemsDesc": "<p>给定一个平衡括号字符串&nbsp;<code>S</code>，按下述规则计算该字符串的分数：</p>\n\n<ul>\n\t<li><code>()</code> 得 1 分。</li>\n\t<li><code>AB</code> 得&nbsp;<code>A + B</code>&nbsp;分，其中 A 和 B 是平衡括号字符串。</li>\n\t<li><code>(A)</code> 得&nbsp;<code>2 * A</code>&nbsp;分，其中 A 是平衡括号字符串。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入： </strong>&quot;()&quot;\n<strong>输出： </strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入： </strong>&quot;(())&quot;\n<strong>输出： </strong>2\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre><strong>输入： </strong>&quot;()()&quot;\n<strong>输出： </strong>2\n</pre>\n\n<p><strong>示例&nbsp;4：</strong></p>\n\n<pre><strong>输入： </strong>&quot;(()(()))&quot;\n<strong>输出： </strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>S</code>&nbsp;是平衡括号字符串，且只含有&nbsp;<code>(</code>&nbsp;和&nbsp;<code>)</code>&nbsp;。</li>\n\t<li><code>2 &lt;= S.length &lt;= 50</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 857.雇佣 K 名工人的最低成本",
        "hardRate": "HARD",
        "passRate": "63.58%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/solution",
        "problemsDesc": "<p>有 <code>n</code>&nbsp;名工人。&nbsp;给定两个数组&nbsp;<code>quality</code>&nbsp;和&nbsp;<code>wage</code>&nbsp;，其中，<code>quality[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;名工人的工作质量，其最低期望工资为&nbsp;<code>wage[i]</code>&nbsp;。</p>\n\n<p>现在我们想雇佣&nbsp;<code>k</code>&nbsp;名工人组成一个<em>工资组。</em>在雇佣&nbsp;一组 <code>k</code>&nbsp;名工人时，我们必须按照下述规则向他们支付工资：</p>\n\n<ol>\n\t<li>对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。</li>\n\t<li>工资组中的每名工人至少应当得到他们的最低期望工资。</li>\n</ol>\n\n<p>给定整数 <code>k</code> ，返回 <em>组成满足上述条件的付费群体所需的最小金额&nbsp;</em>。在实际答案的&nbsp;<code>10<sup>-5</sup></code>&nbsp;以内的答案将被接受。。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入： </strong>quality = [10,20,5], wage = [70,50,30], k = 2\n<strong>输出： </strong>105.00000\n<strong>解释：</strong> 我们向 0 号工人支付 70，向 2 号工人支付 35。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入： </strong>quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3\n<strong>输出： </strong>30.66667\n<strong>解释： </strong>我们向 0 号工人支付 4，向 2 号和 3 号分别支付 13.33333。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == quality.length == wage.length</code></li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= quality[i], wage[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 858.镜面反射",
        "hardRate": "MEDIUM",
        "passRate": "57.46%",
        "problemsUrl": "https://leetcode.cn/problems/mirror-reflection/",
        "solutionsUrl": "https://leetcode.cn/problems/mirror-reflection/solution",
        "problemsDesc": "<p>有一个特殊的正方形房间，每面墙上都有一面镜子。除西南角以外，每个角落都放有一个接受器，编号为&nbsp;<code>0</code>，&nbsp;<code>1</code>，以及&nbsp;<code>2</code>。</p>\n\n<p>正方形房间的墙壁长度为&nbsp;<code>p</code>，一束激光从西南角射出，首先会与东墙相遇，入射点到接收器 <code>0</code> 的距离为 <code>q</code> 。</p>\n\n<p>返回光线最先遇到的接收器的编号（保证光线最终会遇到一个接收器）。</p>\n&nbsp;\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/18/reflection.png\" style=\"width: 218px; height: 217px;\" />\n<pre>\n<strong>输入：</strong>p = 2, q = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>这条光线在第一次被反射回左边的墙时就遇到了接收器 2 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>p = 3, q = 1\n<strong>输入：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= q &lt;= p &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 859.亲密字符串",
        "hardRate": "EASY",
        "passRate": "34.51%",
        "problemsUrl": "https://leetcode.cn/problems/buddy-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/buddy-strings/solution",
        "problemsDesc": "<p>给你两个字符串 <code>s</code> 和 <code>goal</code> ，只要我们可以通过交换 <code>s</code> 中的两个字母得到与 <code>goal</code> 相等的结果，就返回&nbsp;<code>true</code>&nbsp;；否则返回 <code>false</code> 。</p>\n\n<p>交换字母的定义是：取两个下标 <code>i</code> 和 <code>j</code> （下标从 <code>0</code> 开始）且满足 <code>i != j</code> ，接着交换 <code>s[i]</code> 和 <code>s[j]</code> 处的字符。</p>\n\n<ul>\n\t<li>例如，在 <code>\"abcd\"</code> 中交换下标 <code>0</code> 和下标 <code>2</code> 的元素可以生成 <code>\"cbad\"</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ab\", goal = \"ba\"\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以交换 s[0] = 'a' 和 s[1] = 'b' 生成 \"ba\"，此时 s 和 goal 相等。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ab\", goal = \"ab\"\n<strong>输出：</strong>false\n<strong>解释：</strong>你只能交换 s[0] = 'a' 和 s[1] = 'b' 生成 \"ba\"，此时 s 和 goal 不相等。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aa\", goal = \"aa\"\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以交换 s[0] = 'a' 和 s[1] = 'a' 生成 \"aa\"，此时 s 和 goal 相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, goal.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> 和 <code>goal</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 860.柠檬水找零",
        "hardRate": "EASY",
        "passRate": "58.60%",
        "problemsUrl": "https://leetcode.cn/problems/lemonade-change/",
        "solutionsUrl": "https://leetcode.cn/problems/lemonade-change/solution",
        "problemsDesc": "<p>在柠檬水摊上，每一杯柠檬水的售价为&nbsp;<code>5</code>&nbsp;美元。顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p>\n\n<p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p>\n\n<p>注意，一开始你手头没有任何零钱。</p>\n\n<p>给你一个整数数组 <code>bills</code> ，其中 <code>bills[i]</code> 是第 <code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回&nbsp;<code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>bills = [5,5,5,10,20]\n<strong>输出：</strong>true\n<strong>解释：\n</strong>前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。\n第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。\n第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。\n由于所有客户都得到了正确的找零，所以我们输出 true。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>bills = [5,5,10,10,20]\n<strong>输出：</strong>false\n<strong>解释：</strong>\n前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。\n对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。\n对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。\n由于不是每位顾客都得到了正确的找零，所以答案是 false。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= bills.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>bills[i]</code>&nbsp;不是&nbsp;<code>5</code>&nbsp;就是&nbsp;<code>10</code>&nbsp;或是&nbsp;<code>20</code>&nbsp;</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 861.翻转矩阵后的得分",
        "hardRate": "MEDIUM",
        "passRate": "80.79%",
        "problemsUrl": "https://leetcode.cn/problems/score-after-flipping-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/score-after-flipping-matrix/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的二元矩阵 <code>grid</code> ，矩阵中每个元素的值为 <code>0</code> 或 <code>1</code> 。</p>\n\n<p>一次 <strong>移动</strong> 是指选择任一行或列，并转换该行或列中的每一个值：将所有 <code>0</code> 都更改为 <code>1</code>，将所有 <code>1</code> 都更改为 <code>0</code>。</p>\n\n<p>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的 <strong>得分</strong> 就是这些数字的总和。</p>\n\n<p>在执行任意次 <strong>移动</strong> 后（含 0 次），返回可能的最高分数。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-toogle1.jpg\" style=\"width: 500px; height: 299px;\" />\n<pre>\n<strong>输入：</strong>grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]\n<strong>输出：</strong>39\n<strong>解释：</strong>0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0]]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 20</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 862.和至少为 K 的最短子数组",
        "hardRate": "HARD",
        "passRate": "26.54%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，找出 <code>nums</code> 中和至少为 <code>k</code> 的 <strong>最短非空子数组</strong> ，并返回该子数组的长度。如果不存在这样的 <strong>子数组</strong> ，返回 <code>-1</code> 。</p>\n\n<p><strong>子数组</strong> 是数组中 <strong>连续</strong> 的一部分。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1], k = 1\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2], k = 4\n<strong>输出：</strong>-1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,-1,2], k = 3\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 863.二叉树中所有距离为 K 的结点",
        "hardRate": "MEDIUM",
        "passRate": "61.44%",
        "problemsUrl": "https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/solution",
        "problemsDesc": "<p>给定一个二叉树（具有根结点&nbsp;<code>root</code>），&nbsp;一个目标结点&nbsp;<code>target</code>&nbsp;，和一个整数值 <code>k</code> 。</p>\n\n<p>返回到目标结点 <code>target</code> 距离为 <code>k</code> 的所有结点的值的列表。 答案可以以 <strong>任何顺序</strong> 返回。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png\" style=\"height: 429px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2\n<strong>输出：</strong>[7,4,1]\n<strong>解释：</strong>所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> root = [1], target = 1, k = 3\n<strong>输出:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>节点数在&nbsp;<code>[1, 500]</code>&nbsp;范围内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 500</code></li>\n\t<li><code>Node.val</code>&nbsp;中所有值 <strong>不同</strong></li>\n\t<li>目标结点&nbsp;<code>target</code>&nbsp;是树上的结点。</li>\n\t<li><code>0 &lt;= k &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 864.获取所有钥匙的最短路径",
        "hardRate": "HARD",
        "passRate": "59.44%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-path-to-get-all-keys/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-path-to-get-all-keys/solution",
        "problemsDesc": "<p>给定一个二维网格&nbsp;<code>grid</code>&nbsp;，其中：</p>\n\n<ul>\n\t<li><font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">'.'</span></span></font></font> 代表一个空房间</li>\n\t<li><font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">'#'</span></span></font></font> 代表一堵墙</li>\n\t<li><font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">'@'</span></span></font></font>&nbsp;是起点</li>\n\t<li>小写字母代表钥匙</li>\n\t<li>大写字母代表锁</li>\n</ul>\n\n<p>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。</p>\n\n<p>假设 k&nbsp;为 钥匙/锁 的个数，且满足&nbsp;<code>1 &lt;= k&nbsp;&lt;= 6</code>，字母表中的前 <code>k</code>&nbsp;个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。</p>\n\n<p>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-keys2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [\"@.a.#\",\"###.#\",\"b.A.B\"]\n<strong>输出：</strong>8\n<strong>解释：</strong>目标是获得所有钥匙，而不是打开所有锁。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-key2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [\"@..aA\",\"..B#.\",\"....b\"]\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-keys3.jpg\" />\n<pre>\n<strong>输入:</strong> grid = [\"@Aa\"]\n<strong>输出:</strong> -1</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 30</code></li>\n\t<li><code>grid[i][j]</code>&nbsp;只含有&nbsp;<code>'.'</code>,&nbsp;<code>'#'</code>,&nbsp;<code>'@'</code>,&nbsp;<code>'a'-</code><code>'f</code><code>'</code>&nbsp;以及&nbsp;<code>'A'-'F'</code></li>\n\t<li>钥匙的数目范围是&nbsp;<code>[1, 6]</code>&nbsp;</li>\n\t<li>每个钥匙都对应一个 <strong>不同</strong> 的字母</li>\n\t<li>每个钥匙正好打开一个对应的锁</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 865.具有所有最深节点的最小子树",
        "hardRate": "MEDIUM",
        "passRate": "68.75%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/solution",
        "problemsDesc": "<p>给定一个根为&nbsp;<code>root</code>&nbsp;的二叉树，每个节点的深度是 <strong>该节点到根的最短距离</strong> 。</p>\n\n<p>返回包含原始树中所有 <strong>最深节点</strong> 的 <em>最小子树</em> 。</p>\n\n<p>如果一个节点在 <strong>整个树 </strong>的任意节点之间具有最大的深度，则该节点是 <strong>最深的</strong> 。</p>\n\n<p>一个节点的 <strong>子树</strong> 是该节点加上它的所有后代的集合。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png\" style=\"width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4]\n<strong>输出：</strong>[2,7,4]\n<strong>解释：</strong>\n我们返回值为 2 的节点，在图中用黄色标记。\n在图中用蓝色标记的是树的最深的节点。\n注意，节点 5、3 和 2 包含树中最深的节点，但节点 2 的子树最小，因此我们返回它。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[1]\n<strong>解释：</strong>根节点是树中最深的节点。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [0,1,3,null,2]\n<strong>输出：</strong>[2]\n<strong>解释：</strong>树中最深的节点为 2 ，有效子树为节点 2、1 和 0 的子树，但节点 2 的子树最小。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数量在<meta charset=\"UTF-8\" />&nbsp;<code>[1, 500]</code>&nbsp;范围内。</li>\n\t<li><code>0 &lt;= Node.val &lt;= 500</code></li>\n\t<li>每个节点的值都是 <strong>独一无二</strong> 的。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与力扣 1123 重复：<a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/\" target=\"_blank\">https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 866.回文素数",
        "hardRate": "MEDIUM",
        "passRate": "23.88%",
        "problemsUrl": "https://leetcode.cn/problems/prime-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/prime-palindrome/solution",
        "problemsDesc": "<p>求出大于或等于&nbsp;<code>N</code>&nbsp;的最小回文素数。</p>\n\n<p>回顾一下，如果一个数大于 1，且其因数只有 1 和它自身，那么这个数是<em>素数</em>。</p>\n\n<p>例如，2，3，5，7，11 以及&nbsp;13 是素数。</p>\n\n<p>回顾一下，如果一个数从左往右读与从右往左读是一样的，那么这个数是<em>回文数。</em></p>\n\n<p>例如，12321 是回文数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>6\n<strong>输出：</strong>7\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre><strong>输入：</strong>8\n<strong>输出：</strong>11\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre><strong>输入：</strong>13\n<strong>输出：</strong>101</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= N &lt;= 10^8</code></li>\n\t<li>答案肯定存在，且小于&nbsp;<code>2 * 10^8</code>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 867.转置矩阵",
        "hardRate": "EASY",
        "passRate": "66.76%",
        "problemsUrl": "https://leetcode.cn/problems/transpose-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/transpose-matrix/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>matrix</code>， 返回 <code>matrix</code> 的 <strong>转置矩阵</strong> 。</p>\n\n<p>矩阵的 <strong>转置</strong> 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/10/hint_transpose.png\" style=\"width: 600px; height: 197px;\" /></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>[[1,4,7],[2,5,8],[3,6,9]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3],[4,5,6]]\n<strong>输出：</strong>[[1,4],[2,5],[3,6]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 <= m, n <= 1000</code></li>\n\t<li><code>1 <= m * n <= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> <= matrix[i][j] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 868.二进制间距",
        "hardRate": "EASY",
        "passRate": "69.34%",
        "problemsUrl": "https://leetcode.cn/problems/binary-gap/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-gap/solution",
        "problemsDesc": "<p>给定一个正整数 <code>n</code>，找到并返回 <code>n</code> 的二进制表示中两个 <strong>相邻</strong> 1 之间的<strong> 最长距离 </strong>。如果不存在两个相邻的 1，返回 <code>0</code> 。</p>\n\n<p>如果只有 <code>0</code> 将两个 <code>1</code> 分隔开（可能不存在 <code>0</code> ），则认为这两个 1 彼此 <strong>相邻</strong> 。两个 <code>1</code> 之间的距离是它们的二进制表示中位置的绝对差。例如，<code>\"1001\"</code> 中的两个 <code>1</code> 的距离为 3 。</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 22\n<strong>输出：</strong>2\n<strong>解释：</strong>22 的二进制是 \"10110\" 。\n在 22 的二进制表示中，有三个 1，组成两对相邻的 1 。\n第一对相邻的 1 中，两个 1 之间的距离为 2 。\n第二对相邻的 1 中，两个 1 之间的距离为 1 。\n答案取两个距离之中最大的，也就是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 8\n<strong>输出：</strong>0\n<strong>解释：</strong>8 的二进制是 \"1000\" 。\n在 8 的二进制表示中没有相邻的两个 1，所以返回 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>5 的二进制是 \"101\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 869.重新排序得到 2 的幂",
        "hardRate": "MEDIUM",
        "passRate": "63.58%",
        "problemsUrl": "https://leetcode.cn/problems/reordered-power-of-2/",
        "solutionsUrl": "https://leetcode.cn/problems/reordered-power-of-2/solution",
        "problemsDesc": "<p>给定正整数&nbsp;<code>n</code>&nbsp;，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。</p>\n\n<p>如果我们可以通过上述方式得到&nbsp;2 的幂，返回 <code>true</code>；否则，返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 870.优势洗牌",
        "hardRate": "MEDIUM",
        "passRate": "50.45%",
        "problemsUrl": "https://leetcode.cn/problems/advantage-shuffle/",
        "solutionsUrl": "https://leetcode.cn/problems/advantage-shuffle/solution",
        "problemsDesc": "<p>给定两个长度相等的数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>，<code>nums1</code>&nbsp;相对于 <code>nums2</code> 的<em>优势</em>可以用满足&nbsp;<code>nums1[i] &gt; nums2[i]</code>&nbsp;的索引 <code>i</code>&nbsp;的数目来描述。</p>\n\n<p>返回 <font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\" size=\"1\"><span style=\"background-color: rgb(249, 242, 244);\">nums1</span></font>&nbsp;的<strong>任意</strong>排列，使其相对于 <code>nums2</code>&nbsp;的优势最大化。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [2,7,11,15], nums2 = [1,10,4,11]\n<strong>输出：</strong>[2,11,7,15]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [12,24,8,32], nums2 = [13,25,32,11]\n<strong>输出：</strong>[24,32,8,12]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums2.length == nums1.length</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 871.最低加油次数",
        "hardRate": "HARD",
        "passRate": "43.22%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-refueling-stops/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-refueling-stops/solution",
        "problemsDesc": "<p>汽车从起点出发驶向目的地，该目的地位于出发位置东面 <code>target</code>&nbsp;英里处。</p>\n\n<p>沿途有加油站，用数组&nbsp;<code>stations</code> 表示。其中 <code>stations[i] = [position<sub>i</sub>, fuel<sub>i</sub>]</code> 表示第 <code>i</code> 个加油站位于出发位置东面&nbsp;<code>position<sub>i</sub></code> 英里处，并且有&nbsp;<code>fuel<sub>i</sub></code>&nbsp;升汽油。</p>\n\n<p>假设汽车油箱的容量是无限的，其中最初有&nbsp;<code>startFuel</code>&nbsp;升燃料。它每行驶 1 英里就会用掉 1 升汽油。当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。</p>\n\n<p>为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 <code>-1</code> 。</p>\n\n<p>注意：如果汽车到达加油站时剩余燃料为 <code>0</code>，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 <code>0</code>，仍然认为它已经到达目的地。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 1, startFuel = 1, stations = []\n<strong>输出：</strong>0\n<strong>解释：</strong>可以在不加油的情况下到达目的地。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 100, startFuel = 1, stations = [[10,100]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>无法抵达目的地，甚至无法到达第一个加油站。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n出发时有 10 升燃料。\n开车来到距起点 10 英里处的加油站，消耗 10 升燃料。将汽油从 0 升加到 60 升。\n然后，从 10 英里处的加油站开到 60 英里处的加油站（消耗 50 升燃料），\n并将汽油从 10 升加到 50 升。然后开车抵达目的地。\n沿途在两个加油站停靠，所以返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target, startFuel &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= stations.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= position<sub>i</sub> &lt; position<sub>i+1</sub> &lt; target</code></li>\n\t<li><code>1 &lt;= fuel<sub>i</sub> &lt; 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 872.叶子相似的树",
        "hardRate": "EASY",
        "passRate": "65.00%",
        "problemsUrl": "https://leetcode.cn/problems/leaf-similar-trees/",
        "solutionsUrl": "https://leetcode.cn/problems/leaf-similar-trees/solution",
        "problemsDesc": "<p>请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个&nbsp;<strong>叶值序列 </strong>。</p>\n\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png\" style=\"height: 336px; width: 400px;\" /></p>\n\n<p>举个例子，如上图所示，给定一棵叶值序列为&nbsp;<code>(6, 7, 4, 9, 8)</code>&nbsp;的树。</p>\n\n<p>如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是&nbsp;<em>叶相似&nbsp;</em>的。</p>\n\n<p>如果给定的两个根结点分别为&nbsp;<code>root1</code> 和&nbsp;<code>root2</code>&nbsp;的树是叶相似的，则返回&nbsp;<code>true</code>；否则返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-1.jpg\" style=\"height: 237px; width: 600px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-2.jpg\" style=\"height: 110px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root1 = [1,2,3], root2 = [1,3,2]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给定的两棵树结点数在&nbsp;<code>[1, 200]</code> 范围内</li>\n\t<li>给定的两棵树上的值在&nbsp;<code>[0, 200]</code> 范围内</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 873.最长的斐波那契子序列的长度",
        "hardRate": "MEDIUM",
        "passRate": "56.25%",
        "problemsUrl": "https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/solution",
        "problemsDesc": "<p>如果序列 <code>X_1, X_2, ..., X_n</code> 满足下列条件，就说它是 <em>斐波那契式 </em>的：</p>\n\n<ul>\n\t<li><code>n >= 3</code></li>\n\t<li>对于所有 <code>i + 2 <= n</code>，都有 <code>X_i + X_{i+1} = X_{i+2}</code></li>\n</ul>\n\n<p>给定一个<strong>严格递增</strong>的正整数数组形成序列 arr ，找到 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.600000381469727px\"><span style=\"caret-color:#c7254e\"><span style=\"background-color:#f9f2f4\">arr</span></span></span></font></font> 中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。</p>\n\n<p><em>（回想一下，子序列是从原序列 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.600000381469727px\"><span style=\"caret-color:#c7254e\"><span style=\"background-color:#f9f2f4\">arr</span></span></span></font></font> 中派生出来的，它从 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.600000381469727px\"><span style=\"caret-color:#c7254e\"><span style=\"background-color:#f9f2f4\">arr</span></span></span></font></font> 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， <code>[3, 5, 8]</code> 是 <code>[3, 4, 5, 6, 7, 8]</code> 的一个子序列）</em></p>\n\n<p> </p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>arr =<strong> </strong>[1,2,3,4,5,6,7,8]\n<strong>输出: </strong>5\n<strong>解释: </strong>最长的斐波那契式子序列为 [1,2,3,5,8] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>arr =<strong> </strong>[1,3,7,11,12,14,18]\n<strong>输出: </strong>3\n<strong>解释</strong>: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 <= arr.length <= 1000</code></li>\n\t<li>\n\t<p><code>1 <= arr[i] < arr[i + 1] <= 10^9</code></p>\n\t</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 874.模拟行走机器人",
        "hardRate": "MEDIUM",
        "passRate": "43.14%",
        "problemsUrl": "https://leetcode.cn/problems/walking-robot-simulation/",
        "solutionsUrl": "https://leetcode.cn/problems/walking-robot-simulation/solution",
        "problemsDesc": "<p>机器人在一个无限大小的 XY 网格平面上行走，从点 <code>(0, 0)</code> 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 <code>commands</code> ：</p>\n\n<ul>\n\t<li><code>-2</code> ：向左转 <code>90</code> 度</li>\n\t<li><code>-1</code> ：向右转 <code>90</code> 度</li>\n\t<li><code>1 <= x <= 9</code> ：向前移动 <code>x</code> 个单位长度</li>\n</ul>\n\n<p>在网格上有一些格子被视为障碍物 <code>obstacles</code> 。第 <code>i</code> 个障碍物位于网格点  <code>obstacles[i] = (x<sub>i</sub>, y<sub>i</sub>)</code> 。</p>\n\n<p>机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续尝试进行该路线的其余部分。</p>\n\n<p>返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。（即，如果距离为 <code>5</code> ，则返回 <code>25</code> ）</p>\n\n<div class=\"d-google dictRoot saladict-panel isAnimate\">\n<div>\n<div class=\"MachineTrans-Text\">\n<div class=\"MachineTrans-Lines\">\n<div class=\"MachineTrans-Lines-collapse MachineTrans-lang-en\"> </div>\n</div>\n\n<div class=\"MachineTrans-Lines\">\n<p class=\"MachineTrans-lang-zh-CN\"><strong>注意：</strong></p>\n\n<ul>\n\t<li class=\"MachineTrans-lang-zh-CN\">北表示 <code>+Y</code> 方向。</li>\n\t<li class=\"MachineTrans-lang-zh-CN\">东表示 <code>+X</code> 方向。</li>\n\t<li class=\"MachineTrans-lang-zh-CN\">南表示 <code>-Y</code> 方向。</li>\n\t<li class=\"MachineTrans-lang-zh-CN\">西表示 <code>-X</code> 方向。</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>commands = [4,-1,3], obstacles = []\n<strong>输出：</strong>25\n<strong>解释：\n</strong>机器人开始位于 (0, 0)：\n1. 向北移动 4 个单位，到达 (0, 4)\n2. 右转\n3. 向东移动 3 个单位，到达 (3, 4)\n距离原点最远的是 (3, 4) ，距离为 3<sup>2</sup> + 4<sup>2</sup> = 25</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>commands = [4,-1,4,-2,4], obstacles = [[2,4]]\n<strong>输出：</strong>65\n<strong>解释</strong>：机器人开始位于 (0, 0)：\n1. 向北移动 4 个单位，到达 (0, 4)\n2. 右转\n3. 向东移动 1 个单位，然后被位于 (2, 4) 的障碍物阻挡，机器人停在 (1, 4)\n4. 左转\n5. 向北走 4 个单位，到达 (1, 8)\n距离原点最远的是 (1, 8) ，距离为 1<sup>2</sup> + 8<sup>2</sup> = 65</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= commands.length <= 10<sup>4</sup></code></li>\n\t<li><code>commands[i]</code> is one of the values in the list <code>[-2,-1,1,2,3,4,5,6,7,8,9]</code>.</li>\n\t<li><code>0 <= obstacles.length <= 10<sup>4</sup></code></li>\n\t<li><code>-3 * 10<sup>4</sup> <= x<sub>i</sub>, y<sub>i</sub> <= 3 * 10<sup>4</sup></code></li>\n\t<li>答案保证小于 <code>2<sup>31</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 875.爱吃香蕉的珂珂",
        "hardRate": "MEDIUM",
        "passRate": "49.44%",
        "problemsUrl": "https://leetcode.cn/problems/koko-eating-bananas/",
        "solutionsUrl": "https://leetcode.cn/problems/koko-eating-bananas/solution",
        "problemsDesc": "<p>珂珂喜欢吃香蕉。这里有 <code>n</code> 堆香蕉，第 <code>i</code> 堆中有&nbsp;<code>piles[i]</code>&nbsp;根香蕉。警卫已经离开了，将在 <code>h</code> 小时后回来。</p>\n\n<p>珂珂可以决定她吃香蕉的速度 <code>k</code> （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 <code>k</code> 根。如果这堆香蕉少于 <code>k</code> 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。&nbsp;&nbsp;</p>\n\n<p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p>\n\n<p>返回她可以在 <code>h</code> 小时内吃掉所有香蕉的最小速度 <code>k</code>（<code>k</code> 为整数）。</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [3,6,7,11], h = 8\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [30,11,23,4,20], h = 5\n<strong>输出：</strong>30\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [30,11,23,4,20], h = 6\n<strong>输出：</strong>23\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= piles.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>piles.length &lt;= h &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= piles[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 876.链表的中间结点",
        "hardRate": "EASY",
        "passRate": "70.22%",
        "problemsUrl": "https://leetcode.cn/problems/middle-of-the-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/middle-of-the-linked-list/solution",
        "problemsDesc": "<p>给你单链表的头结点 <code>head</code> ，请你找出并返回链表的中间结点。</p>\n\n<p>如果有两个中间结点，则返回第二个中间结点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg\" style=\"width: 544px; height: 65px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5]\n<strong>输出：</strong>[3,4,5]\n<strong>解释：</strong>链表只有一个中间结点，值为 3 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-midlist2.jpg\" style=\"width: 664px; height: 65px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5,6]\n<strong>输出：</strong>[4,5,6]\n<strong>解释：</strong>该链表有两个中间结点，值分别为 3 和 4 ，返回第二个结点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表的结点数范围是 <code>[1, 100]</code></li>\n\t<li><code>1 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 877.石子游戏",
        "hardRate": "MEDIUM",
        "passRate": "76.47%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game/solution",
        "problemsDesc": "<p>Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，<strong>排成一行</strong>；每堆都有 <strong>正</strong> 整数颗石子，数目为 <code>piles[i]</code>&nbsp;。</p>\n\n<p>游戏以谁手中的石子最多来决出胜负。石子的 <strong>总数</strong> 是 <strong>奇数</strong> ，所以没有平局。</p>\n\n<p>Alice 和 Bob 轮流进行，<strong>Alice 先开始</strong> 。 每回合，玩家从行的 <strong>开始</strong> 或 <strong>结束</strong> 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 <strong>石子最多</strong> 的玩家 <strong>获胜</strong> 。</p>\n\n<p>假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回&nbsp;<code>true</code>&nbsp;，当 Bob 赢得比赛时返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [5,3,4,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>\nAlice 先开始，只能拿前 5 颗或后 5 颗石子 。\n假设他取了前 5 颗，这一行就变成了 [3,4,5] 。\n如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。\n如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。\n这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [3,7,2,3]\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= piles.length &lt;= 500</code></li>\n\t<li><code>piles.length</code> 是 <strong>偶数</strong></li>\n\t<li><code>1 &lt;= piles[i] &lt;= 500</code></li>\n\t<li><code>sum(piles[i])</code>&nbsp;是 <strong>奇数</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 878.第 N 个神奇数字",
        "hardRate": "HARD",
        "passRate": "39.97%",
        "problemsUrl": "https://leetcode.cn/problems/nth-magical-number/",
        "solutionsUrl": "https://leetcode.cn/problems/nth-magical-number/solution",
        "problemsDesc": "<p>一个正整数如果能被 <code>a</code> 或 <code>b</code> 整除，那么它是神奇的。</p>\n\n<p>给定三个整数 <code>n</code> ,&nbsp;<code>a</code> , <code>b</code> ，返回第 <code>n</code> 个神奇的数字。因为答案可能很大，所以返回答案&nbsp;<strong>对&nbsp;</strong><code>10<sup>9</sup>&nbsp;+ 7</code> <strong>取模&nbsp;</strong>后的值。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, a = 2, b = 3\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, a = 2, b = 3\n<strong>输出：</strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n\t<li><code>2 &lt;= a, b &lt;= 4 * 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 879.盈利计划",
        "hardRate": "HARD",
        "passRate": "54.66%",
        "problemsUrl": "https://leetcode.cn/problems/profitable-schemes/",
        "solutionsUrl": "https://leetcode.cn/problems/profitable-schemes/solution",
        "problemsDesc": "<p>集团里有 <code>n</code> 名员工，他们可以完成各种各样的工作创造利润。</p>\n\n<p>第 <code>i</code> 种工作会产生 <code>profit[i]</code> 的利润，它要求 <code>group[i]</code> 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。</p>\n\n<p>工作的任何至少产生 <code>minProfit</code> 利润的子集称为 <strong>盈利计划</strong> 。并且工作的成员总数最多为 <code>n</code> 。</p>\n\n<p>有多少种计划可以选择？因为答案很大，所以<strong> 返回结果模 </strong><code>10^9 + 7</code><strong> 的值</strong>。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, minProfit = 3, group = [2,2], profit = [2,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。\n总的来说，有两种计划。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]\n<strong>输出：</strong>7\n<strong>解释：</strong>至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。\n有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。</pre>\n</div>\n</div>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>0 <= minProfit <= 100</code></li>\n\t<li><code>1 <= group.length <= 100</code></li>\n\t<li><code>1 <= group[i] <= 100</code></li>\n\t<li><code>profit.length == group.length</code></li>\n\t<li><code>0 <= profit[i] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 880.索引处的解码字符串",
        "hardRate": "MEDIUM",
        "passRate": "26.94%",
        "problemsUrl": "https://leetcode.cn/problems/decoded-string-at-index/",
        "solutionsUrl": "https://leetcode.cn/problems/decoded-string-at-index/solution",
        "problemsDesc": "<p>给定一个编码字符串 <code>S</code>。请你找出<em> </em><strong>解码字符串</strong> 并将其写入磁带。解码时，从编码字符串中<strong> 每次读取一个字符 </strong>，并采取以下步骤：</p>\n\n<ul>\n\t<li>如果所读的字符是字母，则将该字母写在磁带上。</li>\n\t<li>如果所读的字符是数字（例如 <code>d</code>），则整个当前磁带总共会被重复写&nbsp;<code>d-1</code> 次。</li>\n</ul>\n\n<p>现在，对于给定的编码字符串 <code>S</code> 和索引 <code>K</code>，查找并返回解码字符串中的第&nbsp;<code>K</code>&nbsp;个字母。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>S = &quot;leet2code3&quot;, K = 10\n<strong>输出：</strong>&quot;o&quot;\n<strong>解释：</strong>\n解码后的字符串为 &quot;leetleetcodeleetleetcodeleetleetcode&quot;。\n字符串中的第 10 个字母是 &quot;o&quot;。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>S = &quot;ha22&quot;, K = 5\n<strong>输出：</strong>&quot;h&quot;\n<strong>解释：</strong>\n解码后的字符串为 &quot;hahahaha&quot;。第 5 个字母是 &quot;h&quot;。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>S = &quot;a2345678999999999999999&quot;, K = 1\n<strong>输出：</strong>&quot;a&quot;\n<strong>解释：</strong>\n解码后的字符串为 &quot;a&quot; 重复 8301530446056247680 次。第 1 个字母是 &quot;a&quot;。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= S.length &lt;= 100</code></li>\n\t<li><code>S</code>&nbsp;只包含小写字母与数字 <code>2</code> 到 <code>9</code> 。</li>\n\t<li><code>S</code>&nbsp;以字母开头。</li>\n\t<li><code>1 &lt;= K &lt;= 10^9</code></li>\n\t<li>题目保证 <code>K</code> 小于或等于解码字符串的长度。</li>\n\t<li>解码后的字符串保证少于&nbsp;<code>2^63</code>&nbsp;个字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 881.救生艇",
        "hardRate": "MEDIUM",
        "passRate": "53.72%",
        "problemsUrl": "https://leetcode.cn/problems/boats-to-save-people/",
        "solutionsUrl": "https://leetcode.cn/problems/boats-to-save-people/solution",
        "problemsDesc": "<p>给定数组<meta charset=\"UTF-8\" />&nbsp;<code>people</code>&nbsp;。<code>people[i]</code>表示第 <code>i</code><sup>&nbsp;</sup>个人的体重&nbsp;，<strong>船的数量不限</strong>，每艘船可以承载的最大重量为&nbsp;<code>limit</code>。</p>\n\n<p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为&nbsp;<code>limit</code>。</p>\n\n<p>返回 <em>承载所有人所需的最小船数</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>people = [1,2], limit = 3\n<strong>输出：</strong>1\n<strong>解释：</strong>1 艘船载 (1, 2)\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>people = [3,2,2,1], limit = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>3 艘船分别载 (1, 2), (2) 和 (3)\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>people = [3,5,3,4], limit = 5\n<strong>输出：</strong>4\n<strong>解释：</strong>4 艘船分别载 (3), (3), (4), (5)</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= people.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= people[i] &lt;= limit &lt;= 3 * 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 882.细分图中的可到达节点",
        "hardRate": "HARD",
        "passRate": "63.95%",
        "problemsUrl": "https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/solution",
        "problemsDesc": "<p>给你一个无向图（<strong>原始图</strong>），图中有 <code>n</code> 个节点，编号从 <code>0</code> 到 <code>n - 1</code> 。你决定将图中的每条边 <strong>细分</strong> 为一条节点链，每条边之间的新节点数各不相同。</p>\n\n<p>图用由边组成的二维数组 <code>edges</code> 表示，其中&nbsp;<code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, cnt<sub>i</sub>]</code> 表示原始图中节点&nbsp;<code>u<sub>i</sub></code> 和&nbsp;<code>v<sub>i</sub></code> 之间存在一条边，<code>cnt<sub>i</sub></code> 是将边 <strong>细分</strong> 后的新节点总数。注意，<code>cnt<sub>i</sub> == 0</code> 表示边不可细分。</p>\n\n<p>要 <strong>细分</strong> 边 <code>[ui, vi]</code> ，需要将其替换为 <code>(cnt<sub>i</sub> + 1)</code> 条新边，和&nbsp;<code>cnt<sub>i</sub></code> 个新节点。新节点为 <code>x<sub>1</sub></code>, <code>x<sub>2</sub></code>, ..., <code>x<sub>cnt<sub>i</sub></sub></code> ，新边为 <code>[u<sub>i</sub>, x<sub>1</sub>]</code>, <code>[x<sub>1</sub>, x<sub>2</sub>]</code>, <code>[x<sub>2</sub>, x<sub>3</sub>]</code>, ..., <code>[x<sub>cnt<sub>i</sub>-1</sub>, x<sub>cnt<sub>i</sub></sub>]</code>, <code>[x<sub>cnt<sub>i</sub></sub>, v<sub>i</sub>]</code> 。</p>\n\n<p>现在得到一个&nbsp;<strong>新的细分图</strong> ，请你计算从节点 <code>0</code> 出发，可以到达多少个节点？如果节点间距离是 <code>maxMoves</code> 或更少，则视为 <strong>可以到达</strong> 。</p>\n\n<p>给你原始图和 <code>maxMoves</code> ，返回 <em>新的细分图中从节点 <code>0</code> 出发</em><strong><em> 可到达的节点数</em></strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/01/origfinal.png\" style=\"height: 247px; width: 600px;\" />\n<pre>\n<strong>输入：</strong>edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3\n<strong>输出：</strong>13\n<strong>解释：</strong>边的细分情况如上图所示。\n可以到达的节点已经用黄色标注出来。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4\n<strong>输出：</strong>23\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5\n<strong>输出：</strong>1\n<strong>解释：</strong>节点 0 与图的其余部分没有连通，所以只有节点 0 可以到达。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= edges.length &lt;= min(n * (n - 1) / 2, 10<sup>4</sup>)</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub> &lt; v<sub>i</sub> &lt; n</code></li>\n\t<li>图中 <strong>不存在平行边</strong></li>\n\t<li><code>0 &lt;= cnt<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= maxMoves &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= n &lt;= 3000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 883.三维形体投影面积",
        "hardRate": "EASY",
        "passRate": "76.37%",
        "problemsUrl": "https://leetcode.cn/problems/projection-area-of-3d-shapes/",
        "solutionsUrl": "https://leetcode.cn/problems/projection-area-of-3d-shapes/solution",
        "problemsDesc": "<p>在<meta charset=\"UTF-8\" />&nbsp;<code>n x n</code>&nbsp;的网格<meta charset=\"UTF-8\" />&nbsp;<code>grid</code>&nbsp;中，我们放置了一些与 x，y，z 三轴对齐的<meta charset=\"UTF-8\" />&nbsp;<code>1 x 1 x 1</code>&nbsp;立方体。</p>\n\n<p>每个值&nbsp;<code>v = grid[i][j]</code>&nbsp;表示 <code>v</code>&nbsp;个正方体叠放在单元格&nbsp;<code>(i, j)</code>&nbsp;上。</p>\n\n<p>现在，我们查看这些立方体在 <code>xy</code>&nbsp;、<code>yz</code>&nbsp;和 <code>zx</code>&nbsp;平面上的<em>投影</em>。</p>\n\n<p><strong>投影</strong>&nbsp;就像影子，将 <strong>三维</strong> 形体映射到一个 <strong>二维</strong> 平面上。从顶部、前面和侧面看立方体时，我们会看到“影子”。</p>\n\n<p>返回 <em>所有三个投影的总面积</em> 。</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<ul>\n</ul>\n\n<ul>\n</ul>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/02/shadow.png\" style=\"height: 214px; width: 800px;\" /></p>\n\n<pre>\n<strong>输入：</strong>[[1,2],[3,4]]\n<strong>输出：</strong>17\n<strong>解释：</strong>这里有该形体在三个轴对齐平面上的三个投影(“阴影部分”)。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[2]]\n<strong>输出：</strong>5\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>[[1,0],[0,2]]\n<strong>输出：</strong>8\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 884.两句话中的不常见单词",
        "hardRate": "EASY",
        "passRate": "71.22%",
        "problemsUrl": "https://leetcode.cn/problems/uncommon-words-from-two-sentences/",
        "solutionsUrl": "https://leetcode.cn/problems/uncommon-words-from-two-sentences/solution",
        "problemsDesc": "<p><strong>句子</strong> 是一串由空格分隔的单词。每个 <strong>单词</strong><em> </em>仅由小写字母组成。</p>\n\n<p>如果某个单词在其中一个句子中恰好出现一次，在另一个句子中却 <strong>没有出现</strong> ，那么这个单词就是 <strong>不常见的</strong><em> </em>。</p>\n\n<p>给你两个 <strong>句子</strong> <code>s1</code> 和 <code>s2</code> ，返回所有 <strong>不常用单词</strong> 的列表。返回列表中单词可以按 <strong>任意顺序</strong> 组织。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"this apple is sweet\", s2 = \"this apple is sour\"\n<strong>输出：</strong>[\"sweet\",\"sour\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"apple apple\", s2 = \"banana\"\n<strong>输出：</strong>[\"banana\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 200</code></li>\n\t<li><code>s1</code> 和 <code>s2</code> 由小写英文字母和空格组成</li>\n\t<li><code>s1</code> 和 <code>s2</code> 都不含前导或尾随空格</li>\n\t<li><code>s1</code> 和 <code>s2</code> 中的所有单词间均由单个空格分隔</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 885.螺旋矩阵 III",
        "hardRate": "MEDIUM",
        "passRate": "71.21%",
        "problemsUrl": "https://leetcode.cn/problems/spiral-matrix-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/spiral-matrix-iii/solution",
        "problemsDesc": "<p>在 <code>rows x cols</code> 的网格上，你从单元格 <code>(rStart, cStart)</code> 面朝东面开始。网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。</p>\n\n<p>你需要以顺时针按螺旋状行走，访问此网格中的每个位置。每当移动到网格的边界之外时，需要继续在网格之外行走（但稍后可能会返回到网格边界）。</p>\n\n<p>最终，我们到过网格的所有&nbsp;<code>rows x cols</code>&nbsp;个空间。</p>\n\n<p>按照访问顺序返回表示网格位置的坐标列表。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_1.png\" style=\"width: 174px; height: 99px;\" />\n<pre>\n<strong>输入：</strong>rows = 1, cols = 4, rStart = 0, cStart = 0\n<strong>输出：</strong>[[0,0],[0,1],[0,2],[0,3]]\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_2.png\" style=\"width: 202px; height: 142px;\" />\n<pre>\n<strong>输入：</strong>rows = 5, cols = 6, rStart = 1, cStart = 4\n<strong>输出：</strong>[[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rows, cols &lt;= 100</code></li>\n\t<li><code>0 &lt;= rStart &lt; rows</code></li>\n\t<li><code>0 &lt;= cStart &lt; cols</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 886.可能的二分法",
        "hardRate": "MEDIUM",
        "passRate": "52.11%",
        "problemsUrl": "https://leetcode.cn/problems/possible-bipartition/",
        "solutionsUrl": "https://leetcode.cn/problems/possible-bipartition/solution",
        "problemsDesc": "<p>给定一组&nbsp;<code>n</code>&nbsp;人（编号为&nbsp;<code>1, 2, ..., n</code>），&nbsp;我们想把每个人分进<strong>任意</strong>大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。</p>\n\n<p>给定整数 <code>n</code>&nbsp;和数组 <code>dislikes</code>&nbsp;，其中&nbsp;<code>dislikes[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;，表示不允许将编号为 <code>a<sub>i</sub></code>&nbsp;和&nbsp;&nbsp;<code>b<sub>i</sub></code>的人归入同一组。当可以用这种方法将所有人分进两组时，返回 <code>true</code>；否则返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, dislikes = [[1,2],[1,3],[2,4]]\n<strong>输出：</strong>true\n<strong>解释：</strong>group1 [1,4], group2 [2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, dislikes = [[1,2],[1,3],[2,3]]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2000</code></li>\n\t<li><code>0 &lt;= dislikes.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>dislikes[i].length == 2</code></li>\n\t<li><code>1 &lt;= dislikes[i][j] &lt;= n</code></li>\n\t<li><code>a<sub>i</sub>&nbsp;&lt; b<sub>i</sub></code></li>\n\t<li><code>dislikes</code>&nbsp;中每一组都 <strong>不同</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 887.鸡蛋掉落",
        "hardRate": "HARD",
        "passRate": "30.64%",
        "problemsUrl": "https://leetcode.cn/problems/super-egg-drop/",
        "solutionsUrl": "https://leetcode.cn/problems/super-egg-drop/solution",
        "problemsDesc": "<p>给你 <code>k</code> 枚相同的鸡蛋，并可以使用一栋从第 <code>1</code> 层到第 <code>n</code> 层共有 <code>n</code> 层楼的建筑。</p>\n\n<p>已知存在楼层 <code>f</code> ，满足 <code>0 <= f <= n</code> ，任何从<strong> 高于</strong> <code>f</code> 的楼层落下的鸡蛋都会碎，从 <code>f</code> 楼层或比它低的楼层落下的鸡蛋都不会破。</p>\n\n<p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 <code>x</code> 扔下（满足 <code>1 <= x <= n</code>）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 <strong>重复使用</strong> 这枚鸡蛋。</p>\n\n<p>请你计算并返回要确定 <code>f</code> <strong>确切的值</strong> 的 <strong>最小操作次数</strong> 是多少？</p>\n \n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 1, n = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>\n鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。 \n否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。 \n如果它没碎，那么肯定能得出 f = 2 。 \n因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 2, n = 6\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 3, n = 14\n<strong>输出：</strong>4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= k <= 100</code></li>\n\t<li><code>1 <= n <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 888.公平的糖果交换",
        "hardRate": "EASY",
        "passRate": "63.55%",
        "problemsUrl": "https://leetcode.cn/problems/fair-candy-swap/",
        "solutionsUrl": "https://leetcode.cn/problems/fair-candy-swap/solution",
        "problemsDesc": "<p>爱丽丝和鲍勃拥有不同总数量的糖果。给你两个数组 <code>aliceSizes</code> 和 <code>bobSizes</code> ，<code>aliceSizes[i]</code> 是爱丽丝拥有的第 <code>i</code> 盒糖果中的糖果数量，<code>bobSizes[j]</code> 是鲍勃拥有的第 <code>j</code> 盒糖果中的糖果数量。</p>\n\n<p>两人想要互相交换一盒糖果，这样在交换之后，他们就可以拥有相同总数量的糖果。一个人拥有的糖果总数量是他们每盒糖果数量的总和。</p>\n\n<p>返回一个整数数组 <code>answer</code>，其中 <code>answer[0]</code> 是爱丽丝必须交换的糖果盒中的糖果的数目，<code>answer[1]</code> 是鲍勃必须交换的糖果盒中的糖果的数目。如果存在多个答案，你可以返回其中 <strong>任何一个</strong> 。题目测试用例保证存在与输入对应的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>aliceSizes = [1,1], bobSizes = [2,2]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>aliceSizes = [1,2], bobSizes = [2,3]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>aliceSizes = [2], bobSizes = [1,3]\n<strong>输出：</strong>[2,3]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>aliceSizes = [1,2,5], bobSizes = [2,4]\n<strong>输出：</strong>[5,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= aliceSizes.length, bobSizes.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= aliceSizes[i], bobSizes[j] &lt;= 10<sup>5</sup></code></li>\n\t<li>爱丽丝和鲍勃的糖果总数量不同。</li>\n\t<li>题目数据保证对于给定的输入至少存在一个有效答案。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 889.根据前序和后序遍历构造二叉树",
        "hardRate": "MEDIUM",
        "passRate": "68.02%",
        "problemsUrl": "https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/solution",
        "problemsDesc": "<p>给定两个整数数组，<code>preorder</code>&nbsp;和 <code>postorder</code> ，其中 <code>preorder</code> 是一个具有 <strong>无重复</strong> 值的二叉树的前序遍历，<code>postorder</code> 是同一棵树的后序遍历，重构并返回二叉树。</p>\n\n<p>如果存在多个答案，您可以返回其中 <strong>任何</strong> 一个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/24/lc-prepost.jpg\" style=\"height: 265px; width: 304px;\" /></p>\n\n<pre>\n<strong>输入：</strong>preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\n<strong>输出：</strong>[1,2,3,4,5,6,7]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> preorder = [1], postorder = [1]\n<strong>输出:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= preorder.length &lt;= 30</code></li>\n\t<li><code>1 &lt;= preorder[i] &lt;= preorder.length</code></li>\n\t<li><code>preorder</code>&nbsp;中所有值都 <strong>不同</strong></li>\n\t<li><code>postorder.length == preorder.length</code></li>\n\t<li><code>1 &lt;= postorder[i] &lt;= postorder.length</code></li>\n\t<li><code>postorder</code>&nbsp;中所有值都 <strong>不同</strong></li>\n\t<li>保证 <code>preorder</code>&nbsp;和 <code>postorder</code>&nbsp;是同一棵二叉树的前序遍历和后序遍历</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 890.查找和替换模式",
        "hardRate": "MEDIUM",
        "passRate": "78.58%",
        "problemsUrl": "https://leetcode.cn/problems/find-and-replace-pattern/",
        "solutionsUrl": "https://leetcode.cn/problems/find-and-replace-pattern/solution",
        "problemsDesc": "<p>你有一个单词列表&nbsp;<code>words</code>&nbsp;和一个模式&nbsp;&nbsp;<code>pattern</code>，你想知道 <code>words</code> 中的哪些单词与模式匹配。</p>\n\n<p>如果存在字母的排列 <code>p</code>&nbsp;，使得将模式中的每个字母 <code>x</code> 替换为 <code>p(x)</code> 之后，我们就得到了所需的单词，那么单词与模式是匹配的。</p>\n\n<p><em>（回想一下，字母的排列是从字母到字母的双射：每个字母映射到另一个字母，没有两个字母映射到同一个字母。）</em></p>\n\n<p>返回 <code>words</code> 中与给定模式匹配的单词列表。</p>\n\n<p>你可以按任何顺序返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;], pattern = &quot;abb&quot;\n<strong>输出：</strong>[&quot;mee&quot;,&quot;aqq&quot;]\n<strong>解释：\n</strong>&quot;mee&quot; 与模式匹配，因为存在排列 {a -&gt; m, b -&gt; e, ...}。\n&quot;ccc&quot; 与模式不匹配，因为 {a -&gt; c, b -&gt; c, ...} 不是排列。\n因为 a 和 b 映射到同一个字母。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= pattern.length = words[i].length&nbsp;&lt;= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 891.子序列宽度之和",
        "hardRate": "HARD",
        "passRate": "46.56%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-subsequence-widths/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-subsequence-widths/solution",
        "problemsDesc": "<p>一个序列的 <strong>宽度</strong> 定义为该序列中最大元素和最小元素的差值。</p>\n\n<p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 的所有非空 <strong>子序列</strong> 的 <strong>宽度之和</strong> 。由于答案可能非常大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后的结果。</p>\n\n<p><strong>子序列</strong> 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，<code>[3,6,2,7]</code> 就是数组 <code>[0,3,1,6,2,2,7]</code> 的一个子序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,3]\n<strong>输出：</strong>6\n<strong>解释：</strong>子序列为 [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3] 。\n相应的宽度是 0, 0, 0, 1, 1, 2, 2 。\n宽度之和是 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 892.三维形体的表面积",
        "hardRate": "EASY",
        "passRate": "64.44%",
        "problemsUrl": "https://leetcode.cn/problems/surface-area-of-3d-shapes/",
        "solutionsUrl": "https://leetcode.cn/problems/surface-area-of-3d-shapes/solution",
        "problemsDesc": "<p>给你一个 <code>n * n</code> 的网格&nbsp;<code>grid</code> ，上面放置着一些&nbsp;<code>1 x 1 x 1</code>&nbsp;的正方体。每个值&nbsp;<code>v = grid[i][j]</code>&nbsp;表示&nbsp;<code>v</code>&nbsp;个正方体叠放在对应单元格&nbsp;<code>(i, j)</code>&nbsp;上。</p>\n\n<p>放置好正方体后，任何直接相邻的正方体都会互相粘在一起，形成一些不规则的三维形体。</p>\n\n<p>请你返回最终这些形体的总表面积。</p>\n\n<p><strong>注意：</strong>每个形体的底面也需要计入表面积中。</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/08/tmp-grid2.jpg\" style=\"height: 80px; width: 80px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,2],[3,4]]\n<strong>输出：</strong>34\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/08/tmp-grid4.jpg\" style=\"height: 100px; width: 100px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,1,1],[1,0,1],[1,1,1]]\n<strong>输出：</strong>32\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/08/tmp-grid5.jpg\" style=\"height: 100px; width: 100px;\" />\n<pre>\n<strong>输入：</strong>grid = [[2,2,2],[2,1,2],[2,2,2]]\n<strong>输出：</strong>46\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 893.特殊等价字符串组",
        "hardRate": "MEDIUM",
        "passRate": "72.99%",
        "problemsUrl": "https://leetcode.cn/problems/groups-of-special-equivalent-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/groups-of-special-equivalent-strings/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>words</code>。</p>\n\n<p>一步操作中，你可以交换字符串 <code>words[i]</code> 的任意两个偶数下标对应的字符或任意两个奇数下标对应的字符。</p>\n\n<p>对两个字符串&nbsp;<code>words[i]</code> 和 <code>words[j]</code> 而言，如果经过任意次数的操作，<code>words[i] == words[j]</code> ，那么这两个字符串是 <strong>特殊等价 </strong>的。</p>\n\n<ul>\n\t<li>例如，<code>words[i] = \"zzxy\"</code> 和 <code>words[j] = \"xyzz\"</code> 是一对 <strong>特殊等价</strong> 字符串，因为可以按 <code>\"zzxy\" -&gt; \"xzzy\" -&gt; \"xyzz\"</code> 的操作路径使&nbsp;<code>words[i] == words[j]</code> 。</li>\n</ul>\n\n<p>现在规定，<strong><code>words</code> </strong>的 <strong>一组特殊等价字符串 </strong>就是 <code>words</code> 的一个同时满足下述条件的非空子集：</p>\n\n<ul>\n\t<li>该组中的每一对字符串都是<strong> 特殊等价 </strong>的</li>\n\t<li>该组字符串已经涵盖了该类别中的所有特殊等价字符串，容量达到理论上的最大值（也就是说，如果一个字符串不在该组中，那么这个字符串就 <strong>不会</strong> 与该组内任何字符串特殊等价）</li>\n</ul>\n\n<p>返回 <code>words</code> 中 <strong>特殊等价字符串组</strong> 的数量。</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"abcd\",\"cdab\",\"cbad\",\"xyzz\",\"zzxy\",\"zzyx\"]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n其中一组为 [\"abcd\", \"cdab\", \"cbad\"]，因为它们是成对的特殊等价字符串，且没有其他字符串与这些字符串特殊等价。\n另外两组分别是 [\"xyzz\", \"zzxy\"] 和 [\"zzyx\"]。特别需要注意的是，\"zzxy\" 不与 \"zzyx\" 特殊等价。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\n<strong>输出：</strong>3\n<strong>解释：</strong>3 组 [\"abc\",\"cba\"]，[\"acb\",\"bca\"]，[\"bac\",\"cab\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 20</code></li>\n\t<li>所有 <code>words[i]</code>&nbsp;都只由小写字母组成。</li>\n\t<li>所有 <code>words[i]</code>&nbsp;都具有相同的长度。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 894.所有可能的真二叉树",
        "hardRate": "MEDIUM",
        "passRate": "77.62%",
        "problemsUrl": "https://leetcode.cn/problems/all-possible-full-binary-trees/",
        "solutionsUrl": "https://leetcode.cn/problems/all-possible-full-binary-trees/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，请你找出所有可能含 <code>n</code> 个节点的 <strong>真二叉树</strong> ，并以列表形式返回。答案中每棵树的每个节点都必须符合 <code>Node.val == 0</code> 。</p>\n\n<p>答案的每个元素都是一棵真二叉树的根节点。你可以按 <strong>任意顺序</strong> 返回最终的真二叉树列表<strong>。</strong></p>\n\n<p><strong>真二叉树</strong> 是一类二叉树，树中每个节点恰好有 <code>0</code> 或 <code>2</code> 个子节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png\" style=\"width: 700px; height: 400px;\" />\n<pre>\n<strong>输入：</strong>n = 7\n<strong>输出：</strong>[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>[[0,0,0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 895.最大频率栈",
        "hardRate": "HARD",
        "passRate": "64.35%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-frequency-stack/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-frequency-stack/solution",
        "problemsDesc": "<p>设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出<strong>出现频率</strong>最高的元素。</p>\n\n<p>实现 <code>FreqStack</code>&nbsp;类:</p>\n\n<ul>\n\t<li><meta charset=\"UTF-8\" /><code>FreqStack()</code>&nbsp;构造一个空的堆栈。</li>\n\t<li><meta charset=\"UTF-8\" /><code>void push(int val)</code>&nbsp;将一个整数&nbsp;<code>val</code>&nbsp;压入栈顶。</li>\n\t<li><meta charset=\"UTF-8\" /><code>int pop()</code>&nbsp;删除并返回堆栈中出现频率最高的元素。\n\t<ul>\n\t\t<li>如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"FreqStack\",\"push\",\"push\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"pop\",\"pop\",\"pop\"],\n[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]\n<strong>输出：</strong>[null,null,null,null,null,null,null,5,7,5,4]\n<strong>解释：</strong>\nFreqStack = new FreqStack();\nfreqStack.push (5);//堆栈为 [5]\nfreqStack.push (7);//堆栈是 [5,7]\nfreqStack.push (5);//堆栈是 [5,7,5]\nfreqStack.push (7);//堆栈是 [5,7,5,7]\nfreqStack.push (4);//堆栈是 [5,7,5,7,4]\nfreqStack.push (5);//堆栈是 [5,7,5,7,4,5]\nfreqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。\nfreqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。\nfreqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。\nfreqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= val &lt;= 10<sup>9</sup></code></li>\n\t<li><code>push</code>&nbsp;和 <code>pop</code>&nbsp;的操作数不大于 <code>2 * 10<sup>4</sup></code>。</li>\n\t<li>输入保证在调用&nbsp;<code>pop</code>&nbsp;之前堆栈中至少有一个元素。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 896.单调数列",
        "hardRate": "EASY",
        "passRate": "57.03%",
        "problemsUrl": "https://leetcode.cn/problems/monotonic-array/",
        "solutionsUrl": "https://leetcode.cn/problems/monotonic-array/solution",
        "problemsDesc": "<p>如果数组是单调递增或单调递减的，那么它是&nbsp;<strong>单调 </strong><em>的</em>。</p>\n\n<p>如果对于所有 <code>i &lt;= j</code>，<code>nums[i] &lt;= nums[j]</code>，那么数组 <code>nums</code> 是单调递增的。 如果对于所有 <code>i &lt;= j</code>，<code>nums[i]&gt; = nums[j]</code>，那么数组 <code>nums</code>&nbsp;是单调递减的。</p>\n\n<p>当给定的数组 <code>nums</code>&nbsp;是单调数组时返回 <code>true</code>，否则返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2,3]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [6,5,4,4]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,2]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 897.递增顺序搜索树",
        "hardRate": "EASY",
        "passRate": "74.01%",
        "problemsUrl": "https://leetcode.cn/problems/increasing-order-search-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/increasing-order-search-tree/solution",
        "problemsDesc": "<p>给你一棵二叉搜索树的<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;，请你 <strong>按中序遍历</strong> 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg\" style=\"height: 350px; width: 600px;\" />\n<pre>\n<strong>输入：</strong>root = [5,3,6,2,4,null,8,1,null,null,null,7,9]\n<strong>输出：</strong>[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/17/ex2.jpg\" style=\"height: 114px; width: 300px;\" />\n<pre>\n<strong>输入：</strong>root = [5,1,7]\n<strong>输出：</strong>[1,null,5,null,7]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数的取值范围是 <code>[1, 100]</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 898.子数组按位或操作",
        "hardRate": "MEDIUM",
        "passRate": "39.15%",
        "problemsUrl": "https://leetcode.cn/problems/bitwise-ors-of-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/bitwise-ors-of-subarrays/solution",
        "problemsDesc": "<p>我们有一个非负整数数组<meta charset=\"UTF-8\" />&nbsp;<code>arr</code>&nbsp;。</p>\n\n<p>对于每个（连续的）子数组<meta charset=\"UTF-8\" />&nbsp;<code>sub = [arr[i], arr[i + 1], ..., arr[j]]</code>&nbsp;（&nbsp;<code>i &lt;= j</code>），我们对<meta charset=\"UTF-8\" />&nbsp;<code>sub</code>&nbsp;中的每个元素进行按位或操作，获得结果<meta charset=\"UTF-8\" />&nbsp;<code>arr[i] | arr[i + 1] | ... | arr[j]</code>&nbsp;。</p>\n\n<p>返回可能结果的数量。 多次出现的结果在最终答案中仅计算一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n只有一个可能的结果 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,1,2]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n可能的子数组为 [1]，[1]，[2]，[1, 1]，[1, 2]，[1, 1, 2]。\n产生的结果为 1，1，2，1，3，3 。\n有三个唯一值，所以答案是 3 。\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,4]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n可能的结果是 1，2，3，4，6，以及 7 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i]&nbsp;&lt;= 10<sup>9</sup></code>​​​​​​​</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 899.有序队列",
        "hardRate": "HARD",
        "passRate": "64.09%",
        "problemsUrl": "https://leetcode.cn/problems/orderly-queue/",
        "solutionsUrl": "https://leetcode.cn/problems/orderly-queue/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>&nbsp;。你可以从 <code>s</code> 的前 <code>k</code> 个字母中选择一个，并把它加到字符串的末尾。</p>\n\n<p>返回 <em>在应用上述步骤的任意数量的移动后，字典上最小的字符串&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"cba\", k = 1\n<strong>输出：</strong>\"acb\"\n<strong>解释：</strong>\n在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “bac”。\n在第二步中，我们将第一个字符（“b”）移动到最后，获得最终结果 “acb”。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"baaca\", k = 3\n<strong>输出：</strong>\"aaabc\"\n<strong>解释：\n</strong>在第一步中，我们将第一个字符（“b”）移动到最后，获得字符串 “aacab”。\n在第二步中，我们将第三个字符（“c”）移动到最后，获得最终结果 “aaabc”。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k&nbsp;&lt;= S.length&nbsp;&lt;= 1000</code></li>\n\t<li><code>s</code>&nbsp;只由小写字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 900.RLE 迭代器",
        "hardRate": "MEDIUM",
        "passRate": "51.29%",
        "problemsUrl": "https://leetcode.cn/problems/rle-iterator/",
        "solutionsUrl": "https://leetcode.cn/problems/rle-iterator/solution",
        "problemsDesc": "<p>我们可以使用游程编码(即&nbsp;<strong>RLE&nbsp;</strong>)来编码一个整数序列。在偶数长度&nbsp;<code>encoding</code>&nbsp;( <strong>从 0 开始</strong> )的游程编码数组中，对于所有偶数 <code>i</code> ，<code>encoding[i]</code>&nbsp;告诉我们非负整数&nbsp;<code>encoding[i + 1]</code>&nbsp;在序列中重复的次数。</p>\n\n<ul>\n\t<li>例如，序列&nbsp;<code>arr = [8,8,8,5,5]</code>&nbsp;可以被编码为 <code>encoding =[3,8,2,5]</code> 。<code>encoding =[3,8,0,9,2,5]</code>&nbsp;和 <code>encoding =[2,8,1,8,2,5]</code> 也是&nbsp;<code>arr</code> 有效的 <strong>RLE</strong> 。</li>\n</ul>\n\n<p>给定一个游程长度的编码数组，设计一个迭代器来遍历它。</p>\n\n<p>实现 <code>RLEIterator</code> 类:</p>\n\n<ul>\n\t<li><code>RLEIterator(int[] encoded)</code>&nbsp;用编码后的数组初始化对象。</li>\n\t<li><code>int next(int n)</code> 以这种方式耗尽后 <code>n</code> 个元素并返回最后一个耗尽的元素。如果没有剩余的元素要耗尽，则返回 <code>-1</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：\n</strong>[\"RLEIterator\",\"next\",\"next\",\"next\",\"next\"]\n[[[3,8,0,9,2,5]],[2],[1],[1],[2]]\n<strong>输出：\n</strong>[null,8,8,5,-1]\n<strong>解释：</strong>\nRLEIterator rLEIterator = new RLEIterator([3, 8, 0, 9, 2, 5]); // 这映射到序列 [8,8,8,5,5]。\nrLEIterator.next(2); // 耗去序列的 2 个项，返回 8。现在剩下的序列是 [8, 5, 5]。\nrLEIterator.next(1); // 耗去序列的 1 个项，返回 8。现在剩下的序列是 [5, 5]。\nrLEIterator.next(1); // 耗去序列的 1 个项，返回 5。现在剩下的序列是 [5]。\nrLEIterator.next(2); // 耗去序列的 2 个项，返回 -1。 这是由于第一个被耗去的项是 5，\n但第二个项并不存在。由于最后一个要耗去的项不存在，我们返回 -1。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= encoding.length &lt;= 1000</code></li>\n\t<li><code>encoding.length</code>&nbsp;为偶</li>\n\t<li><code>0 &lt;= encoding[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n\t<li>每个测试用例调用<code>next </code>不高于&nbsp;<code>1000</code>&nbsp;次&nbsp;</li>\n</ul>\n",
        "isPlus": false
    }
]