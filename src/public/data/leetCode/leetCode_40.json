[
    {
        "problemsName": " 1951.查询具有最多共同关注者的所有两两结对组",
        "hardRate": "MEDIUM",
        "passRate": "65.29%",
        "problemsUrl": "https://leetcode.cn/problems/all-the-pairs-with-the-maximum-number-of-common-followers/",
        "solutionsUrl": "https://leetcode.cn/problems/all-the-pairs-with-the-maximum-number-of-common-followers/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1952.三除数",
        "hardRate": "EASY",
        "passRate": "54.80%",
        "problemsUrl": "https://leetcode.cn/problems/three-divisors/",
        "solutionsUrl": "https://leetcode.cn/problems/three-divisors/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> 。如果 <code>n</code> <strong>恰好有三个正除数</strong> ，返回 <code>true</code><em> </em>；否则，返回<em> </em><code>false</code> 。</p>\n\n<p>如果存在整数 <code>k</code> ，满足 <code>n = k * m</code> ，那么整数 <code>m</code> 就是 <code>n</code> 的一个 <strong>除数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>false\n<strong>解释：</strong>2 只有两个除数：1 和 2 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 4\n<strong>输出：</strong>true\n<strong>解释：</strong>4 有三个除数：1、2 和 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1953.你可以工作的最大周数",
        "hardRate": "MEDIUM",
        "passRate": "37.27%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-weeks-for-which-you-can-work/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-weeks-for-which-you-can-work/solution",
        "problemsDesc": "<p>给你&nbsp;<code>n</code> 个项目，编号从 <code>0</code> 到 <code>n - 1</code> 。同时给你一个整数数组 <code>milestones</code> ，其中每个 <code>milestones[i]</code> 表示第 <code>i</code> 个项目中的阶段任务数量。</p>\n\n<p>你可以按下面两个规则参与项目中的工作：</p>\n\n<ul>\n\t<li>每周，你将会完成 <strong>某一个</strong> 项目中的 <strong>恰好一个</strong>&nbsp;阶段任务。你每周都 <strong>必须</strong> 工作。</li>\n\t<li>在 <strong>连续的</strong> 两周中，你 <strong>不能</strong> 参与并完成同一个项目中的两个阶段任务。</li>\n</ul>\n\n<p>一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将&nbsp;<strong>停止工作</strong> 。注意，由于这些条件的限制，你可能无法完成所有阶段任务。</p>\n\n<p>返回在不违反上面规则的情况下你&nbsp;<strong>最多</strong>&nbsp;能工作多少周。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>milestones = [1,2,3]\n<strong>输出：</strong>6\n<strong>解释：</strong>一种可能的情形是：\n​​​​- 第 1 周，你参与并完成项目 0 中的一个阶段任务。\n- 第 2 周，你参与并完成项目 2 中的一个阶段任务。\n- 第 3 周，你参与并完成项目 1 中的一个阶段任务。\n- 第 4 周，你参与并完成项目 2 中的一个阶段任务。\n- 第 5 周，你参与并完成项目 1 中的一个阶段任务。\n- 第 6 周，你参与并完成项目 2 中的一个阶段任务。\n总周数是 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>milestones = [5,2,1]\n<strong>输出：</strong>7\n<strong>解释：</strong>一种可能的情形是：\n- 第 1 周，你参与并完成项目 0 中的一个阶段任务。\n- 第 2 周，你参与并完成项目 1 中的一个阶段任务。\n- 第 3 周，你参与并完成项目 0 中的一个阶段任务。\n- 第 4 周，你参与并完成项目 1 中的一个阶段任务。\n- 第 5 周，你参与并完成项目 0 中的一个阶段任务。\n- 第 6 周，你参与并完成项目 2 中的一个阶段任务。\n- 第 7 周，你参与并完成项目 0 中的一个阶段任务。\n总周数是 7 。\n注意，你不能在第 8 周参与完成项目 0 中的最后一个阶段任务，因为这会违反规则。\n因此，项目 0 中会有一个阶段任务维持未完成状态。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == milestones.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= milestones[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1954.收集足够苹果的最小花园周长",
        "hardRate": "MEDIUM",
        "passRate": "49.80%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-garden-perimeter-to-collect-enough-apples/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-garden-perimeter-to-collect-enough-apples/solution",
        "problemsDesc": "<p>给你一个用无限二维网格表示的花园，<strong>每一个</strong>&nbsp;整数坐标处都有一棵苹果树。整数坐标&nbsp;<code>(i, j)</code>&nbsp;处的苹果树有 <code>|i| + |j|</code>&nbsp;个苹果。</p>\n\n<p>你将会买下正中心坐标是 <code>(0, 0)</code>&nbsp;的一块 <strong>正方形土地</strong>&nbsp;，且每条边都与两条坐标轴之一平行。</p>\n\n<p>给你一个整数&nbsp;<code>neededApples</code>&nbsp;，请你返回土地的&nbsp;<strong>最小周长</strong>&nbsp;，使得&nbsp;<strong>至少</strong>&nbsp;有<strong>&nbsp;</strong><code>neededApples</code>&nbsp;个苹果在土地&nbsp;<strong>里面或者边缘上</strong>。</p>\n\n<p><code>|x|</code>&nbsp;的值定义为：</p>\n\n<ul>\n\t<li>如果&nbsp;<code>x &gt;= 0</code>&nbsp;，那么值为&nbsp;<code>x</code></li>\n\t<li>如果&nbsp;<code>x &lt;&nbsp;0</code>&nbsp;，那么值为&nbsp;<code>-x</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://pic.leetcode-cn.com/1627790803-qcBKFw-image.png\" style=\"width: 442px; height: 449px;\" />\n<pre>\n<b>输入：</b>neededApples = 1\n<b>输出：</b>8\n<b>解释：</b>边长长度为 1 的正方形不包含任何苹果。\n但是边长为 2 的正方形包含 12 个苹果（如上图所示）。\n周长为 2 * 4 = 8 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>neededApples = 13\n<b>输出：</b>16\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>neededApples = 1000000000\n<b>输出：</b>5040\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= neededApples &lt;= 10<sup>15</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1955.统计特殊子序列的数目",
        "hardRate": "HARD",
        "passRate": "52.55%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-special-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-special-subsequences/solution",
        "problemsDesc": "<p><strong>特殊序列</strong> 是由&nbsp;<strong>正整数</strong>&nbsp;个 <code>0</code>&nbsp;，紧接着&nbsp;<strong>正整数</strong>&nbsp;个 <code>1</code>&nbsp;，最后 <strong>正整数</strong>&nbsp;个 <code>2</code>&nbsp;组成的序列。</p>\n\n<ul>\n\t<li>比方说，<code>[0,1,2]</code> 和&nbsp;<code>[0,0,1,1,1,2]</code>&nbsp;是特殊序列。</li>\n\t<li>相反，<code>[2,1,0]</code>&nbsp;，<code>[1]</code>&nbsp;和&nbsp;<code>[0,1,2,0]</code>&nbsp;就不是特殊序列。</li>\n</ul>\n\n<p>给你一个数组&nbsp;<code>nums</code>&nbsp;（<strong>仅</strong>&nbsp;包含整数&nbsp;<code>0</code>，<code>1</code>&nbsp;和&nbsp;<code>2</code>），请你返回 <b>不同特殊子序列的数目</b>&nbsp;。由于答案可能很大，请你将它对&nbsp;<code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后返回。</p>\n\n<p>一个数组的 <strong>子序列</strong>&nbsp;是从原数组中删除零个或者若干个元素后，剩下元素不改变顺序得到的序列。如果两个子序列的 <strong>下标集合</strong>&nbsp;不同，那么这两个子序列是 <strong>不同的</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [0,1,2,2]\n<b>输出：</b>3\n<b>解释：</b>特殊子序列为 [<strong>0</strong>,<strong>1</strong>,<strong>2</strong>,2]，[<strong>0</strong>,<strong>1</strong>,2,<strong>2</strong>] 和 [<strong>0</strong>,<strong>1</strong>,<strong>2</strong>,<strong>2</strong>] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,2,0,0]\n<b>输出：</b>0\n<b>解释：</b>数组 [2,2,0,0] 中没有特殊子序列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [0,1,2,0,1,2]\n<b>输出：</b>7\n<b>解释：</b>特殊子序列包括：\n- [<strong>0</strong>,<strong>1</strong>,<strong>2</strong>,0,1,2]\n- [<strong>0</strong>,<strong>1</strong>,2,0,1,<strong>2</strong>]\n- [<strong>0</strong>,<strong>1</strong>,<strong>2</strong>,0,1,<strong>2</strong>]\n- [<strong>0</strong>,<strong>1</strong>,2,0,<strong>1</strong>,<strong>2</strong>]\n- [<strong>0</strong>,1,2,<strong>0</strong>,<strong>1</strong>,<strong>2</strong>]\n- [<strong>0</strong>,1,2,0,<strong>1</strong>,<strong>2</strong>]\n- [0,1,2,<strong>0</strong>,<strong>1</strong>,<strong>2</strong>]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1956.感染 K 种病毒所需的最短时间",
        "hardRate": "HARD",
        "passRate": "36.51%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-for-k-virus-variants-to-spread/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-for-k-virus-variants-to-spread/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1957.删除字符使字符串变好",
        "hardRate": "EASY",
        "passRate": "59.99%",
        "problemsUrl": "https://leetcode.cn/problems/delete-characters-to-make-fancy-string/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-characters-to-make-fancy-string/solution",
        "problemsDesc": "<p>一个字符串如果没有 <strong>三个连续</strong>&nbsp;相同字符，那么它就是一个 <strong>好字符串</strong>&nbsp;。</p>\n\n<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，请你从 <code>s</code>&nbsp;删除&nbsp;<strong>最少</strong>&nbsp;的字符，使它变成一个 <strong>好字符串</strong> 。</p>\n\n<p>请你返回删除后的字符串。题目数据保证答案总是 <strong>唯一的 </strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"le<strong>e</strong>etcode\"\n<b>输出：</b>\"leetcode\"\n<strong>解释：</strong>\n从第一组 'e' 里面删除一个 'e' ，得到 \"leetcode\" 。\n没有连续三个相同字符，所以返回 \"leetcode\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"<strong>a</strong>aab<strong>aa</strong>aa\"\n<b>输出：</b>\"aabaa\"\n<strong>解释：</strong>\n从第一组 'a' 里面删除一个 'a' ，得到 \"aabaaaa\" 。\n从第二组 'a' 里面删除两个 'a' ，得到 \"aabaa\" 。\n没有连续三个相同字符，所以返回 \"aabaa\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aab\"\n<b>输出：</b>\"aab\"\n<b>解释：</b>没有连续三个相同字符，所以返回 \"aab\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1958.检查操作是否合法",
        "hardRate": "MEDIUM",
        "passRate": "44.83%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-move-is-legal/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-move-is-legal/solution",
        "problemsDesc": "<p>给你一个下标从&nbsp;<strong>0</strong>&nbsp;开始的&nbsp;<code>8 x 8</code> 网格&nbsp;<code>board</code>&nbsp;，其中&nbsp;<code>board[r][c]</code>&nbsp;表示游戏棋盘上的格子&nbsp;<code>(r, c)</code>&nbsp;。棋盘上空格用&nbsp;<code>'.'</code>&nbsp;表示，白色格子用&nbsp;<code>'W'</code>&nbsp;表示，黑色格子用&nbsp;<code>'B'</code>&nbsp;表示。</p>\n\n<p>游戏中每次操作步骤为：选择一个空格子，将它变成你正在执行的颜色（要么白色，要么黑色）。但是，<strong>合法 </strong>操作必须满足：涂色后这个格子是 <strong>好线段的一个端点</strong>&nbsp;（好线段可以是水平的，竖直的或者是对角线）。</p>\n\n<p><strong>好线段</strong>&nbsp;指的是一个包含 <strong>三个或者更多格子（包含端点格子）</strong>的线段，线段两个端点格子为 <strong>同一种颜色</strong>&nbsp;，且中间剩余格子的颜色都为 <strong>另一种颜色</strong>&nbsp;（线段上不能有任何空格子）。你可以在下图找到好线段的例子：</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/22/goodlines5.png\" style=\"width: 500px; height: 312px;\" />\n<p>给你两个整数&nbsp;<code>rMove</code> 和&nbsp;<code>cMove</code>&nbsp;以及一个字符&nbsp;<code>color</code>&nbsp;，表示你正在执行操作的颜色（白或者黑），如果将格子&nbsp;<code>(rMove, cMove)</code>&nbsp;变成颜色&nbsp;<code>color</code>&nbsp;后，是一个&nbsp;<strong>合法</strong>&nbsp;操作，那么返回&nbsp;<code>true</code>&nbsp;，如果不是合法操作返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/10/grid11.png\" style=\"width: 350px; height: 350px;\" /></p>\n\n<pre>\n<b>输入：</b>board = [[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\"W\",\"B\",\"B\",\".\",\"W\",\"W\",\"W\",\"B\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"]], rMove = 4, cMove = 3, color = \"B\"\n<b>输出：</b>true\n<b>解释：</b>'.'，'W' 和 'B' 分别用颜色蓝色，白色和黑色表示。格子 (rMove, cMove) 用 'X' 标记。\n以选中格子为端点的两个好线段在上图中用红色矩形标注出来了。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/10/grid2.png\" style=\"width: 350px; height: 351px;\" /></p>\n\n<pre>\n<b>输入：</b>board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"B\",\".\",\".\",\"W\",\".\",\".\",\".\"],[\".\",\".\",\"W\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\"B\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"B\",\"W\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"W\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"B\"]], rMove = 4, cMove = 4, color = \"W\"\n<b>输出：</b>false\n<b>解释：</b>虽然选中格子涂色后，棋盘上产生了好线段，但选中格子是作为中间格子，没有产生以选中格子为端点的好线段。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>board.length == board[r].length == 8</code></li>\n\t<li><code>0 &lt;= rMove, cMove &lt; 8</code></li>\n\t<li><code>board[rMove][cMove] == '.'</code></li>\n\t<li><code>color</code>&nbsp;要么是&nbsp;<code>'B'</code> 要么是&nbsp;<code>'W'</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1959.K 次调整数组大小浪费的最小总空间",
        "hardRate": "MEDIUM",
        "passRate": "46.16%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-total-space-wasted-with-k-resizing-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-total-space-wasted-with-k-resizing-operations/solution",
        "problemsDesc": "<p>你正在设计一个动态数组。给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，其中&nbsp;<code>nums[i]</code>&nbsp;是&nbsp;<code>i</code>&nbsp;时刻数组中的元素数目。除此以外，你还有一个整数 <code>k</code>&nbsp;，表示你可以 <strong>调整</strong>&nbsp;数组大小的 <strong>最多</strong>&nbsp;次数（每次都可以调整成 <strong>任意</strong>&nbsp;大小）。</p>\n\n<p><code>t</code>&nbsp;时刻数组的大小&nbsp;<code>size<sub>t</sub></code>&nbsp;必须大于等于&nbsp;<code>nums[t]</code>&nbsp;，因为数组需要有足够的空间容纳所有元素。<code>t</code>&nbsp;时刻 <strong>浪费的空间</strong>&nbsp;为&nbsp;<code>size<sub>t</sub> - nums[t]</code>&nbsp;，<strong>总</strong>&nbsp;浪费空间为满足&nbsp;<code>0 &lt;= t &lt; nums.length</code>&nbsp;的每一个时刻&nbsp;<code>t</code>&nbsp;浪费的空间&nbsp;<strong>之和</strong>&nbsp;。</p>\n\n<p>在调整数组大小不超过 <code>k</code>&nbsp;次的前提下，请你返回 <strong>最小总浪费空间</strong>&nbsp;。</p>\n\n<p><strong>注意：</strong>数组最开始时可以为&nbsp;<strong>任意大小</strong>&nbsp;，且&nbsp;<strong>不计入</strong>&nbsp;调整大小的操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [10,20], k = 0\n<b>输出：</b>10\n<b>解释：</b>size = [20,20].\n我们可以让数组初始大小为 20 。\n总浪费空间为 (20 - 10) + (20 - 20) = 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [10,20,30], k = 1\n<b>输出：</b>10\n<b>解释：</b>size = [20,20,30].\n我们可以让数组初始大小为 20 ，然后时刻 2 调整大小为 30 。\n总浪费空间为 (20 - 10) + (20 - 20) + (30 - 30) = 10 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [10,20,15,30,20], k = 2\n<b>输出：</b>15\n<b>解释：</b>size = [10,20,20,30,30].\n我们可以让数组初始大小为 10 ，时刻 1 调整大小为 20 ，时刻 3 调整大小为 30 。\n总浪费空间为 (10 - 10) + (20 - 20) + (20 - 15) + (30 - 30) + (30 - 20) = 15 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= nums.length - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1960.两个回文子字符串长度的最大乘积",
        "hardRate": "HARD",
        "passRate": "32.43%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-product-of-the-length-of-two-palindromic-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-product-of-the-length-of-two-palindromic-substrings/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>s</code>&nbsp;，你需要找到两个 <strong>不重叠</strong><strong>的回文&nbsp;</strong>子字符串，它们的长度都必须为 <strong>奇数</strong>&nbsp;，使得它们长度的乘积最大。</p>\n\n<p>更正式地，你想要选择四个整数&nbsp;<code>i</code>&nbsp;，<code>j</code>&nbsp;，<code>k</code>&nbsp;，<code>l</code>&nbsp;，使得&nbsp;<code>0 &lt;= i &lt;= j &lt; k &lt;= l &lt; s.length</code>&nbsp;，且子字符串&nbsp;<code>s[i...j]</code> 和&nbsp;<code>s[k...l]</code>&nbsp;都是回文串且长度为奇数。<code>s[i...j]</code>&nbsp;表示下标从 <code>i</code>&nbsp;到 <code>j</code>&nbsp;且 <strong>包含</strong>&nbsp;两端下标的子字符串。</p>\n\n<p>请你返回两个不重叠回文子字符串长度的 <strong>最大</strong>&nbsp;乘积。</p>\n\n<p><strong>回文字符串</strong>&nbsp;指的是一个从前往后读和从后往前读一模一样的字符串。<strong>子字符串</strong>&nbsp;指的是一个字符串中一段连续字符。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"ababbb\"\n<b>输出：</b>9\n<b>解释：</b>子字符串 \"aba\" 和 \"bbb\" 为奇数长度的回文串。乘积为 3 * 3 = 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"zaaaxbbby\"\n<b>输出：</b>9\n<b>解释：</b>子字符串 \"aaa\" 和 \"bbb\" 为奇数长度的回文串。乘积为 3 * 3 = 9 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1961.检查字符串是否为数组前缀",
        "hardRate": "EASY",
        "passRate": "52.72%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-string-is-a-prefix-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-string-is-a-prefix-of-array/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和一个字符串数组 <code>words</code> ，请你判断 <code>s</code> 是否为 <code>words</code> 的 <strong>前缀字符串</strong> 。</p>\n\n<p>字符串 <code>s</code> 要成为 <code>words</code> 的 <strong>前缀字符串</strong> ，需要满足：<code>s</code> 可以由 <code>words</code> 中的前 <code>k</code>（<code>k</code> 为 <strong>正数</strong> ）个字符串按顺序相连得到，且 <code>k</code> 不超过 <code>words.length</code> 。</p>\n\n<p>如果 <code>s</code> 是 <code>words</code> 的 <strong>前缀字符串</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"iloveleetcode\", words = [\"i\",\"love\",\"leetcode\",\"apples\"]\n<strong>输出：</strong>true\n<strong>解释：</strong>\ns 可以由 \"i\"、\"love\" 和 \"leetcode\" 相连得到。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"iloveleetcode\", words = [\"apples\",\"i\",\"love\",\"leetcode\"]\n<strong>输出：</strong>false\n<strong>解释：</strong>\n数组的前缀相连无法得到 s 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 20</code></li>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>words[i]</code> 和 <code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1962.移除石子使总数最小",
        "hardRate": "MEDIUM",
        "passRate": "46.70%",
        "problemsUrl": "https://leetcode.cn/problems/remove-stones-to-minimize-the-total/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-stones-to-minimize-the-total/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>piles</code> ，数组 <strong>下标从 0 开始</strong> ，其中 <code>piles[i]</code> 表示第 <code>i</code> 堆石子中的石子数量。另给你一个整数 <code>k</code> ，请你执行下述操作 <strong>恰好</strong> <code>k</code> 次：</p>\n\n<ul>\n\t<li>选出任一石子堆 <code>piles[i]</code> ，并从中 <strong>移除</strong> <code>floor(piles[i] / 2)</code> 颗石子。</li>\n</ul>\n\n<p><strong>注意：</strong>你可以对 <strong>同一堆</strong> 石子多次执行此操作。</p>\n\n<p>返回执行 <code>k</code> 次操作后，剩下石子的 <strong>最小</strong> 总数。</p>\n\n<p><code>floor(x)</code> 为 <strong>小于</strong> 或 <strong>等于</strong> <code>x</code> 的 <strong>最大</strong> 整数。（即，对 <code>x</code> 向下取整）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [5,4,9], k = 2\n<strong>输出：</strong>12\n<strong>解释：</strong>可能的执行情景如下：\n- 对第 2 堆石子执行移除操作，石子分布情况变成 [5,4,<strong><em>5</em></strong>] 。\n- 对第 0 堆石子执行移除操作，石子分布情况变成 [<strong><em>3</em></strong>,4,5] 。\n剩下石子的总数为 12 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [4,3,6,7], k = 3\n<strong>输出：</strong>12\n<strong>解释：</strong>可能的执行情景如下：\n- 对第 2 堆石子执行移除操作，石子分布情况变成 [4,3,<strong><em>3</em></strong>,7] 。\n- 对第 3 堆石子执行移除操作，石子分布情况变成 [4,3,3,<strong><em>4</em></strong>] 。\n- 对第 0 堆石子执行移除操作，石子分布情况变成 [<strong><em>2</em></strong>,3,3,4] 。\n剩下石子的总数为 12 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= piles.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= piles[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1963.使字符串平衡的最小交换次数",
        "hardRate": "MEDIUM",
        "passRate": "64.60%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-swaps-to-make-the-string-balanced/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-swaps-to-make-the-string-balanced/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，<strong>下标从 0 开始</strong> ，且长度为偶数 <code>n</code> 。字符串 <strong>恰好</strong> 由 <code>n / 2</code> 个开括号 <code>'['</code> 和 <code>n / 2</code> 个闭括号 <code>']'</code> 组成。</p>\n\n<p>只有能满足下述所有条件的字符串才能称为 <strong>平衡字符串</strong> ：</p>\n\n<ul>\n\t<li>字符串是一个空字符串，或者</li>\n\t<li>字符串可以记作 <code>AB</code> ，其中 <code>A</code> 和 <code>B</code> 都是 <strong>平衡字符串</strong> ，或者</li>\n\t<li>字符串可以写成 <code>[C]</code> ，其中 <code>C</code> 是一个 <strong>平衡字符串</strong> 。</li>\n</ul>\n\n<p>你可以交换 <strong>任意</strong> 两个下标所对应的括号 <strong>任意</strong> 次数。</p>\n\n<p>返回使<em> </em><code>s</code> 变成 <strong>平衡字符串</strong> 所需要的 <strong>最小</strong> 交换次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"][][\"\n<strong>输出：</strong>1\n<strong>解释：</strong>交换下标 0 和下标 3 对应的括号，可以使字符串变成平衡字符串。\n最终字符串变成 \"[[]]\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"]]][[[\"\n<strong>输出：</strong>2\n<strong>解释：</strong>执行下述操作可以使字符串变成平衡字符串：\n- 交换下标 0 和下标 4 对应的括号，s = \"[]][][\" 。\n- 交换下标 1 和下标 5 对应的括号，s = \"[[][]]\" 。\n最终字符串变成 \"[[][]]\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"[]\"\n<strong>输出：</strong>0\n<strong>解释：</strong>这个字符串已经是平衡字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == s.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>6</sup></code></li>\n\t<li><code>n</code> 为偶数</li>\n\t<li><code>s[i]</code> 为<code>'['</code> 或 <code>']'</code></li>\n\t<li>开括号 <code>'['</code> 的数目为 <code>n / 2</code> ，闭括号 <code>']'</code> 的数目也是 <code>n / 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1964.找出到每个位置为止最长的有效障碍赛跑路线",
        "hardRate": "HARD",
        "passRate": "43.73%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-longest-valid-obstacle-course-at-each-position/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-longest-valid-obstacle-course-at-each-position/solution",
        "problemsDesc": "<p>你打算构建一些障碍赛跑路线。给你一个 <strong>下标从 0 开始</strong> 的整数数组 <code>obstacles</code> ，数组长度为 <code>n</code> ，其中 <code>obstacles[i]</code> 表示第 <code>i</code> 个障碍的高度。</p>\n\n<p>对于每个介于 <code>0</code> 和 <code>n - 1</code> 之间（包含 <code>0</code> 和 <code>n - 1</code>）的下标&nbsp; <code>i</code> ，在满足下述条件的前提下，请你找出&nbsp;<code>obstacles</code> 能构成的最长障碍路线的长度：</p>\n\n<ul>\n\t<li>你可以选择下标介于 <code>0</code> 到 <code>i</code> 之间（包含 <code>0</code> 和 <code>i</code>）的任意个障碍。</li>\n\t<li>在这条路线中，必须包含第 <code>i</code> 个障碍。</li>\n\t<li>你必须按障碍在&nbsp;<code>obstacles</code>&nbsp;中的<strong> </strong><strong>出现顺序</strong> 布置这些障碍。</li>\n\t<li>除第一个障碍外，路线中每个障碍的高度都必须和前一个障碍 <strong>相同</strong> 或者 <strong>更高</strong> 。</li>\n</ul>\n\n<p>返回长度为 <code>n</code> 的答案数组 <code>ans</code> ，其中 <code>ans[i]</code> 是上面所述的下标 <code>i</code> 对应的最长障碍赛跑路线的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>obstacles = [1,2,3,2]\n<strong>输出：</strong>[1,2,3,3]\n<strong>解释：</strong>每个位置的最长有效障碍路线是：\n- i = 0: [<em><strong>1</strong></em>], [1] 长度为 1\n- i = 1: [<em><strong>1</strong></em>,<em><strong>2</strong></em>], [1,2] 长度为 2\n- i = 2: [<em><strong>1</strong></em>,<em><strong>2</strong></em>,<em><strong>3</strong></em>], [1,2,3] 长度为 3\n- i = 3: [<em><strong>1</strong></em>,<em><strong>2</strong></em>,3,<em><strong>2</strong></em>], [1,2,2] 长度为 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>obstacles = [2,2,1]\n<strong>输出：</strong>[1,2,1]\n<strong>解释：</strong>每个位置的最长有效障碍路线是：\n- i = 0: [<em><strong>2</strong></em>], [2] 长度为 1\n- i = 1: [<em><strong>2</strong></em>,<em><strong>2</strong></em>], [2,2] 长度为 2\n- i = 2: [2,2,<em><strong>1</strong></em>], [1] 长度为 1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>obstacles = [3,1,5,6,4,2]\n<strong>输出：</strong>[1,1,2,3,2,2]\n<strong>解释：</strong>每个位置的最长有效障碍路线是：\n- i = 0: [<em><strong>3</strong></em>], [3] 长度为 1\n- i = 1: [3,<em><strong>1</strong></em>], [1] 长度为 1\n- i = 2: [<em><strong>3</strong></em>,1,<em><strong>5</strong></em>], [3,5] 长度为 2, [1,5] 也是有效的障碍赛跑路线\n- i = 3: [<em><strong>3</strong></em>,1,<em><strong>5</strong></em>,<em><strong>6</strong></em>], [3,5,6] 长度为 3, [1,5,6] 也是有效的障碍赛跑路线\n- i = 4: [<em><strong>3</strong></em>,1,5,6,<em><strong>4</strong></em>], [3,4] 长度为 2, [1,4] 也是有效的障碍赛跑路线\n- i = 5: [3,<em><strong>1</strong></em>,5,6,4,<em><strong>2</strong></em>], [1,2] 长度为 2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == obstacles.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= obstacles[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1965.丢失信息的雇员",
        "hardRate": "EASY",
        "passRate": "71.05%",
        "problemsUrl": "https://leetcode.cn/problems/employees-with-missing-information/",
        "solutionsUrl": "https://leetcode.cn/problems/employees-with-missing-information/solution",
        "problemsDesc": "<p>表: <code>Employees</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| employee_id | int     |\n| name        | varchar |\n+-------------+---------+\nemployee_id 是这个表的主键。\n每一行表示雇员的id 和他的姓名。\n</pre>\n\n<p>表: <code>Salaries</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| employee_id | int     |\n| salary      | int     |\n+-------------+---------+\nemployee_id is 这个表的主键。\n每一行表示雇员的id 和他的薪水。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写出一个查询语句，找到所有 <strong>丢失信息</strong> 的雇员id。当满足下面一个条件时，就被认为是雇员的信息丢失：</p>\n\n<ul>\n\t<li>雇员的 <strong>姓名</strong> 丢失了，或者</li>\n\t<li>雇员的 <strong>薪水信息</strong> 丢失了，或者</li>\n</ul>\n\n<p>返回这些雇员的id &nbsp;<code>employee_id</code>&nbsp;，&nbsp;<strong>从小到大排序&nbsp;</strong>。</p>\n\n<p>查询结果格式如下面的例子所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nEmployees table:\n+-------------+----------+\n| employee_id | name     |\n+-------------+----------+\n| 2           | Crew     |\n| 4           | Haven    |\n| 5           | Kristian |\n+-------------+----------+\nSalaries table:\n+-------------+--------+\n| employee_id | salary |\n+-------------+--------+\n| 5           | 76071  |\n| 1           | 22517  |\n| 4           | 63539  |\n+-------------+--------+\n<strong>输出：</strong>\n+-------------+\n| employee_id |\n+-------------+\n| 1           |\n| 2           |\n+-------------+\n<strong>解释：</strong>\n雇员1，2，4，5 都工作在这个公司。\n1号雇员的姓名丢失了。\n2号雇员的薪水信息丢失了。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1966.未排序数组中的可被二分搜索的数",
        "hardRate": "MEDIUM",
        "passRate": "63.71%",
        "problemsUrl": "https://leetcode.cn/problems/binary-searchable-numbers-in-an-unsorted-array/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-searchable-numbers-in-an-unsorted-array/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1967.作为子字符串出现在单词中的字符串数目",
        "hardRate": "EASY",
        "passRate": "79.31%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-strings-that-appear-as-substrings-in-word/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-strings-that-appear-as-substrings-in-word/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>patterns</code> 和一个字符串 <code>word</code> ，统计 <code>patterns</code> 中有多少个字符串是 <code>word</code> 的子字符串。返回字符串数目。</p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>patterns = [\"a\",\"abc\",\"bc\",\"d\"], word = \"abc\"\n<strong>输出：</strong>3\n<strong>解释：</strong>\n- \"a\" 是 \"<em><strong>a</strong></em>bc\" 的子字符串。\n- \"abc\" 是 \"<em><strong>abc</strong></em>\" 的子字符串。\n- \"bc\" 是 \"a<em><strong>bc</strong></em>\" 的子字符串。\n- \"d\" 不是 \"abc\" 的子字符串。\npatterns 中有 3 个字符串作为子字符串出现在 word 中。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>patterns = [\"a\",\"b\",\"c\"], word = \"aaaaabbbbb\"\n<strong>输出：</strong>2\n<strong>解释：</strong>\n- \"a\" 是 \"a<em><strong>a</strong></em>aaabbbbb\" 的子字符串。\n- \"b\" 是 \"aaaaabbbb<em><strong>b</strong></em>\" 的子字符串。\n- \"c\" 不是 \"aaaaabbbbb\" 的字符串。\npatterns 中有 2 个字符串作为子字符串出现在 word 中。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>patterns = [\"a\",\"a\",\"a\"], word = \"ab\"\n<strong>输出：</strong>3\n<strong>解释：</strong>patterns 中的每个字符串都作为子字符串出现在 word \"<em><strong>a</strong></em>b\" 中。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= patterns.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= patterns[i].length &lt;= 100</code></li>\n\t<li><code>1 &lt;= word.length &lt;= 100</code></li>\n\t<li><code>patterns[i]</code> 和 <code>word</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1968.构造元素不等于两相邻元素平均值的数组",
        "hardRate": "MEDIUM",
        "passRate": "39.31%",
        "problemsUrl": "https://leetcode.cn/problems/array-with-elements-not-equal-to-average-of-neighbors/",
        "solutionsUrl": "https://leetcode.cn/problems/array-with-elements-not-equal-to-average-of-neighbors/solution",
        "problemsDesc": "<p>给你一个 <strong>下标从 0 开始</strong> 的数组 <code>nums</code> ，数组由若干 <strong>互不相同的</strong> 整数组成。你打算重新排列数组中的元素以满足：重排后，数组中的每个元素都 <strong>不等于</strong> 其两侧相邻元素的 <strong>平均值</strong> 。</p>\n\n<p>更公式化的说法是，重新排列的数组应当满足这一属性：对于范围&nbsp;<code>1 &lt;= i &lt; nums.length - 1</code> 中的每个 <code>i</code> ，<code>(nums[i-1] + nums[i+1]) / 2</code> <strong>不等于</strong> <code>nums[i]</code> 均成立 。</p>\n\n<p>返回满足题意的任一重排结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,5]\n<strong>输出：</strong>[1,2,4,5,3]\n<strong>解释：</strong>\ni=1, nums[i] = 2, 两相邻元素平均值为 (1+4) / 2 = 2.5\ni=2, nums[i] = 4, 两相邻元素平均值为 (2+5) / 2 = 3.5\ni=3, nums[i] = 5, 两相邻元素平均值为 (4+3) / 2 = 3.5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [6,2,0,9,7]\n<strong>输出：</strong>[9,7,6,2,0]\n<strong>解释：</strong>\ni=1, nums[i] = 7, 两相邻元素平均值为 (9+6) / 2 = 7.5\ni=2, nums[i] = 6, 两相邻元素平均值为 (7+2) / 2 = 4.5\ni=3, nums[i] = 2, 两相邻元素平均值为 (6+0) / 2 = 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1969.数组元素的最小非零乘积",
        "hardRate": "MEDIUM",
        "passRate": "29.87%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-non-zero-product-of-the-array-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-non-zero-product-of-the-array-elements/solution",
        "problemsDesc": "<p>给你一个正整数&nbsp;<code>p</code>&nbsp;。你有一个下标从 <strong>1</strong>&nbsp;开始的数组&nbsp;<code>nums</code>&nbsp;，这个数组包含范围&nbsp;<code>[1, 2<sup>p</sup> - 1]</code>&nbsp;内所有整数的二进制形式（两端都 <strong>包含</strong>）。你可以进行以下操作 <strong>任意</strong>&nbsp;次：</p>\n\n<ul>\n\t<li>从 <code>nums</code>&nbsp;中选择两个元素&nbsp;<code>x</code>&nbsp;和&nbsp;<code>y</code>&nbsp; 。</li>\n\t<li>选择 <code>x</code>&nbsp;中的一位与 <code>y</code>&nbsp;对应位置的位交换。对应位置指的是两个整数 <strong>相同位置</strong>&nbsp;的二进制位。</li>\n</ul>\n\n<p>比方说，如果&nbsp;<code>x = 11<em><strong>0</strong></em>1</code>&nbsp;且&nbsp;<code>y = 00<em><strong>1</strong></em>1</code>&nbsp;，交换右边数起第 <code>2</code>&nbsp;位后，我们得到&nbsp;<code>x = 11<em><strong>1</strong></em>1</code> 和&nbsp;<code>y = 00<em><strong>0</strong></em>1</code>&nbsp;。</p>\n\n<p>请你算出进行以上操作 <strong>任意次</strong>&nbsp;以后，<code>nums</code>&nbsp;能得到的 <strong>最小非零</strong>&nbsp;乘积。将乘积对<em>&nbsp;</em><code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong> 后返回。</p>\n\n<p><strong>注意：</strong>答案应为取余 <strong>之前</strong>&nbsp;的最小值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>p = 1\n<b>输出：</b>1\n<b>解释：</b>nums = [1] 。\n只有一个元素，所以乘积为该元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>p = 2\n<b>输出：</b>6\n<b>解释：</b>nums = [01, 10, 11] 。\n所有交换要么使乘积变为 0 ，要么乘积与初始乘积相同。\n所以，数组乘积 1 * 2 * 3 = 6 已经是最小值。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>p = 3\n<b>输出：</b>1512\n<b>解释：</b>nums = [001, 010, 011, 100, 101, 110, 111]\n- 第一次操作中，我们交换第二个和第五个元素最左边的数位。\n    - 结果数组为 [001, <em><strong>1</strong></em>10, 011, 100, <em><strong>0</strong></em>01, 110, 111] 。\n- 第二次操作中，我们交换第三个和第四个元素中间的数位。\n    - 结果数组为 [001, 110, 0<em><strong>0</strong></em>1, 1<em><strong>1</strong></em>0, 001, 110, 111] 。\n数组乘积 1 * 6 * 1 * 6 * 1 * 6 * 7 = 1512 是最小乘积。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= p &lt;= 60</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1970.你能穿过矩阵的最后一天",
        "hardRate": "HARD",
        "passRate": "50.80%",
        "problemsUrl": "https://leetcode.cn/problems/last-day-where-you-can-still-cross/",
        "solutionsUrl": "https://leetcode.cn/problems/last-day-where-you-can-still-cross/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>1</strong>&nbsp;开始的二进制矩阵，其中&nbsp;<code>0</code>&nbsp;表示陆地，<code>1</code>&nbsp;表示水域。同时给你&nbsp;<code>row</code> 和&nbsp;<code>col</code>&nbsp;分别表示矩阵中行和列的数目。</p>\n\n<p>一开始在第&nbsp;<code>0</code>&nbsp;天，<strong>整个</strong>&nbsp;矩阵都是&nbsp;<strong>陆地</strong>&nbsp;。但每一天都会有一块新陆地被&nbsp;<strong>水</strong>&nbsp;淹没变成水域。给你一个下标从&nbsp;<strong>1</strong>&nbsp;开始的二维数组&nbsp;<code>cells</code>&nbsp;，其中&nbsp;<code>cells[i] = [r<sub>i</sub>, c<sub>i</sub>]</code>&nbsp;表示在第&nbsp;<code>i</code>&nbsp;天，第&nbsp;<code>r<sub>i</sub></code>&nbsp;行&nbsp;<code>c<sub>i</sub></code>&nbsp;列（下标都是从 <strong>1</strong>&nbsp;开始）的陆地会变成 <strong>水域</strong>&nbsp;（也就是 <code>0</code>&nbsp;变成 <code>1</code>&nbsp;）。</p>\n\n<p>你想知道从矩阵最 <strong>上面</strong>&nbsp;一行走到最 <strong>下面</strong>&nbsp;一行，且只经过陆地格子的 <strong>最后一天</strong>&nbsp;是哪一天。你可以从最上面一行的&nbsp;<strong>任意</strong>&nbsp;格子出发，到达最下面一行的&nbsp;<strong>任意</strong>&nbsp;格子。你只能沿着&nbsp;<strong>四个</strong>&nbsp;基本方向移动（也就是上下左右）。</p>\n\n<p>请返回只经过陆地格子能从最 <strong>上面</strong>&nbsp;一行走到最 <strong>下面</strong>&nbsp;一行的 <strong>最后一天</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/27/1.png\" style=\"width: 624px; height: 162px;\">\n<pre><b>输入：</b>row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]\n<b>输出：</b>2\n<b>解释：</b>上图描述了矩阵从第 0 天开始是如何变化的。\n可以从最上面一行到最下面一行的最后一天是第 2 天。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/27/2.png\" style=\"width: 504px; height: 178px;\">\n<pre><b>输入：</b>row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]]\n<b>输出：</b>1\n<b>解释：</b>上图描述了矩阵从第 0 天开始是如何变化的。\n可以从最上面一行到最下面一行的最后一天是第 1 天。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/27/3.png\" style=\"width: 666px; height: 167px;\">\n<pre><b>输入：</b>row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]\n<b>输出：</b>3\n<b>解释：</b>上图描述了矩阵从第 0 天开始是如何变化的。\n可以从最上面一行到最下面一行的最后一天是第 3 天。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= row, col &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>4 &lt;= row * col &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>cells.length == row * col</code></li>\n\t<li><code>1 &lt;= r<sub>i</sub> &lt;= row</code></li>\n\t<li><code>1 &lt;= c<sub>i</sub> &lt;= col</code></li>\n\t<li><code>cells</code>&nbsp;中的所有格子坐标都是 <strong>唯一</strong>&nbsp;的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1971.寻找图中是否存在路径",
        "hardRate": "EASY",
        "passRate": "54.05%",
        "problemsUrl": "https://leetcode.cn/problems/find-if-path-exists-in-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/find-if-path-exists-in-graph/solution",
        "problemsDesc": "<p>有一个具有 <code>n</code> 个顶点的 <strong>双向</strong> 图，其中每个顶点标记从 <code>0</code> 到 <code>n - 1</code>（包含 <code>0</code> 和 <code>n - 1</code>）。图中的边用一个二维整数数组 <code>edges</code> 表示，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> 表示顶点 <code>ui</code> 和顶点 <code>vi</code> 之间的双向边。 每个顶点对由 <strong>最多一条</strong> 边连接，并且没有顶点存在与自身相连的边。</p>\n\n<p>请你确定是否存在从顶点 <code>source</code> 开始，到顶点 <code>destination</code> 结束的 <strong>有效路径</strong> 。</p>\n\n<p>给你数组 <code>edges</code> 和整数 <code>n</code>、<code>source</code> 和 <code>destination</code>，如果从 <code>source</code> 到 <code>destination</code> 存在 <strong>有效路径</strong> ，则返回 <code>true</code>，否则返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/14/validpath-ex1.png\" style=\"width: 141px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>存在由顶点 0 到顶点 2 的路径:\n- 0 → 1 → 2 \n- 0 → 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/14/validpath-ex2.png\" style=\"width: 281px; height: 141px;\" />\n<pre>\n<strong>输入：</strong>n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5\n<strong>输出：</strong>false\n<strong>解释：</strong>不存在由顶点 0 到顶点 5 的路径.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= edges.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n\t<li><code>0 &lt;= source, destination &lt;= n - 1</code></li>\n\t<li>不存在重复边</li>\n\t<li>不存在指向顶点自身的边</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1972.同一天的第一个电话和最后一个电话",
        "hardRate": "HARD",
        "passRate": "42.61%",
        "problemsUrl": "https://leetcode.cn/problems/first-and-last-call-on-the-same-day/",
        "solutionsUrl": "https://leetcode.cn/problems/first-and-last-call-on-the-same-day/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1973.值等于子节点值之和的节点数量",
        "hardRate": "MEDIUM",
        "passRate": "60.23%",
        "problemsUrl": "https://leetcode.cn/problems/count-nodes-equal-to-sum-of-descendants/",
        "solutionsUrl": "https://leetcode.cn/problems/count-nodes-equal-to-sum-of-descendants/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1974.使用特殊打字机键入单词的最少时间",
        "hardRate": "EASY",
        "passRate": "71.29%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-type-word-using-special-typewriter/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-type-word-using-special-typewriter/solution",
        "problemsDesc": "<p>有一个特殊打字机，它由一个 <strong>圆盘</strong> 和一个 <strong>指针</strong>&nbsp;组成， 圆盘上标有小写英文字母&nbsp;<code>'a'</code> 到&nbsp;<code>'z'</code>。<strong>只有</strong>&nbsp;当指针指向某个字母时，它才能被键入。指针 <strong>初始时</strong>&nbsp;指向字符 <code>'a'</code>&nbsp;。</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/31/chart.jpg\" style=\"width: 530px; height: 410px;\" />\n<p>每一秒钟，你可以执行以下操作之一：</p>\n\n<ul>\n\t<li>将指针 <strong>顺时针</strong>&nbsp;或者 <b>逆时针</b>&nbsp;移动一个字符。</li>\n\t<li>键入指针 <strong>当前</strong>&nbsp;指向的字符。</li>\n</ul>\n\n<p>给你一个字符串&nbsp;<code>word</code>&nbsp;，请你返回键入&nbsp;<code>word</code>&nbsp;所表示单词的 <b>最少</b>&nbsp;秒数&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>word = \"abc\"\n<b>输出：</b>5\n<strong>解释：\n</strong>单词按如下操作键入：\n- 花 1 秒键入字符 'a' in 1 ，因为指针初始指向 'a' ，故不需移动指针。\n- 花 1 秒将指针顺时针移到 'b' 。\n- 花 1 秒键入字符 'b' 。\n- 花 1 秒将指针顺时针移到 'c' 。\n- 花 1 秒键入字符 'c' 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>word = \"bza\"\n<b>输出：</b>7\n<strong>解释：\n</strong>单词按如下操作键入：\n- 花 1 秒将指针顺时针移到 'b' 。\n- 花 1 秒键入字符 'b' 。\n- 花 2 秒将指针逆时针移到 'z' 。\n- 花 1 秒键入字符 'z' 。\n- 花 1 秒将指针顺时针移到 'a' 。\n- 花 1 秒键入字符 'a' 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>word = \"zjpc\"\n<b>输出：</b>34\n<strong>解释：</strong>\n单词按如下操作键入：\n- 花 1 秒将指针逆时针移到 'z' 。\n- 花 1 秒键入字符 'z' 。\n- 花 10 秒将指针顺时针移到 'j' 。\n- 花 1 秒键入字符 'j' 。\n- 花 6 秒将指针顺时针移到 'p' 。\n- 花 1 秒键入字符 'p' 。\n- 花 13 秒将指针逆时针移到 'c' 。\n- 花 1 秒键入字符 'c' 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 100</code></li>\n\t<li><code>word</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1975.最大方阵和",
        "hardRate": "MEDIUM",
        "passRate": "41.67%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-matrix-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-matrix-sum/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>n x n</code>&nbsp;的整数方阵&nbsp;<code>matrix</code>&nbsp;。你可以执行以下操作&nbsp;<strong>任意次</strong>&nbsp;：</p>\n\n<ul>\n\t<li>选择&nbsp;<code>matrix</code>&nbsp;中&nbsp;<strong>相邻</strong>&nbsp;两个元素，并将它们都 <strong>乘以</strong>&nbsp;<code>-1</code>&nbsp;。</li>\n</ul>\n\n<p>如果两个元素有 <strong>公共边</strong>&nbsp;，那么它们就是 <strong>相邻</strong>&nbsp;的。</p>\n\n<p>你的目的是 <strong>最大化</strong>&nbsp;方阵元素的和。请你在执行以上操作之后，返回方阵的&nbsp;<strong>最大</strong>&nbsp;和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/16/pc79-q2ex1.png\" style=\"width: 401px; height: 81px;\">\n<pre><b>输入：</b>matrix = [[1,-1],[-1,1]]\n<b>输出：</b>4\n<b>解释：</b>我们可以执行以下操作使和等于 4 ：\n- 将第一行的 2 个元素乘以 -1 。\n- 将第一列的 2 个元素乘以 -1 。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/16/pc79-q2ex2.png\" style=\"width: 321px; height: 121px;\">\n<pre><b>输入：</b>matrix = [[1,2,3],[-1,-2,-3],[1,2,3]]\n<b>输出：</b>16\n<b>解释：</b>我们可以执行以下操作使和等于 16 ：\n- 将第二行的最后 2 个元素乘以 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == matrix.length == matrix[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 250</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= matrix[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1976.到达目的地的方案数",
        "hardRate": "MEDIUM",
        "passRate": "36.51%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/solution",
        "problemsDesc": "<p>你在一个城市里，城市由 <code>n</code>&nbsp;个路口组成，路口编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，某些路口之间有 <strong>双向</strong>&nbsp;道路。输入保证你可以从任意路口出发到达其他任意路口，且任意两个路口之间最多有一条路。</p>\n\n<p>给你一个整数&nbsp;<code>n</code>&nbsp;和二维整数数组&nbsp;<code>roads</code>&nbsp;，其中&nbsp;<code>roads[i] = [u<sub>i</sub>, v<sub>i</sub>, time<sub>i</sub>]</code>&nbsp;表示在路口&nbsp;<code>u<sub>i</sub></code>&nbsp;和&nbsp;<code>v<sub>i</sub></code>&nbsp;之间有一条需要花费&nbsp;<code>time<sub>i</sub></code>&nbsp;时间才能通过的道路。你想知道花费 <strong>最少时间</strong>&nbsp;从路口&nbsp;<code>0</code>&nbsp;出发到达路口&nbsp;<code>n - 1</code>&nbsp;的方案数。</p>\n\n<p>请返回花费 <strong>最少时间</strong>&nbsp;到达目的地的 <strong>路径数目</strong>&nbsp;。由于答案可能很大，将结果对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/17/graph2.png\" style=\"width: 235px; height: 381px;\">\n<pre><b>输入：</b>n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]\n<b>输出：</b>4\n<b>解释：</b>从路口 0 出发到路口 6 花费的最少时间是 7 分钟。\n四条花费 7 分钟的路径分别为：\n- 0 ➝ 6\n- 0 ➝ 4 ➝ 6\n- 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6\n- 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 2, roads = [[1,0,10]]\n<b>输出：</b>1\n<b>解释：</b>只有一条从路口 0 到路口 1 的路，花费 10 分钟。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>n - 1 &lt;= roads.length &lt;= n * (n - 1) / 2</code></li>\n\t<li><code>roads[i].length == 3</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>\n\t<li>任意两个路口之间至多有一条路。</li>\n\t<li>从任意路口出发，你能够到达其他任意路口。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1977.划分数字的方案数",
        "hardRate": "HARD",
        "passRate": "30.23%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-separate-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-separate-numbers/solution",
        "problemsDesc": "<p>你写下了若干 <strong>正整数</strong>&nbsp;，并将它们连接成了一个字符串&nbsp;<code>num</code>&nbsp;。但是你忘记给这些数字之间加逗号了。你只记得这一列数字是 <strong>非递减</strong>&nbsp;的且&nbsp;<strong>没有</strong> 任何数字有前导 0 。</p>\n\n<p>请你返回有多少种可能的 <strong>正整数数组</strong>&nbsp;可以得到字符串&nbsp;<code>num</code>&nbsp;。由于答案可能很大，将结果对 <code>10<sup>9</sup> + 7</code>&nbsp;<b>取余</b>&nbsp;后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>num = \"327\"\n<b>输出：</b>2\n<b>解释：</b>以下为可能的方案：\n3, 27\n327\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>num = \"094\"\n<b>输出：</b>0\n<b>解释：</b>不能有数字有前导 0 ，且所有数字均为正数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>num = \"0\"\n<b>输出：</b>0\n<strong>解释：</strong>不能有数字有前导 0 ，且所有数字均为正数。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>num = \"9999999999999\"\n<b>输出：</b>101\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 3500</code></li>\n\t<li><code>num</code>&nbsp;只含有数字&nbsp;<code>'0'</code> 到&nbsp;<code>'9'</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1978.上级经理已离职的公司员工",
        "hardRate": "EASY",
        "passRate": "49.92%",
        "problemsUrl": "https://leetcode.cn/problems/employees-whose-manager-left-the-company/",
        "solutionsUrl": "https://leetcode.cn/problems/employees-whose-manager-left-the-company/solution",
        "problemsDesc": "<p>表: <code>Employees</code></p>\n\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| employee_id | int      |\n| name        | varchar  |\n| manager_id  | int      |\n| salary      | int      |\n+-------------+----------+\nemployee_id 是这个表的主键。\n这个表包含了员工，他们的薪水和上级经理的id。\n有一些员工没有上级经理（其manager_id 是空值）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一个查询语句，查询出，这些员工的id，他们的薪水严格少于<code>$30000</code>&nbsp;并且他们的上级经理已离职。当一个经理离开公司时，他们的信息需要从员工表中删除掉，但是表中的员工的<code>manager_id</code> &nbsp;这一列还是设置的离职经理的id&nbsp;。</p>\n\n<p>返回的结果按照<code>employee_id&nbsp;</code>从小到大排序。</p>\n\n<p>查询结果如下所示：</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nEmployees table:\n+-------------+-----------+------------+--------+\n| employee_id | name      | manager_id | salary |\n+-------------+-----------+------------+--------+\n| 3           | Mila      | 9          | 60301  |\n| 12          | Antonella | null       | 31000  |\n| 13          | Emery     | null       | 67084  |\n| 1           | Kalel     | 11         | 21241  |\n| 9           | Mikaela   | null       | 50937  |\n| 11          | Joziah    | 6          | 28485  |\n+-------------+-----------+------------+--------+\n<strong>输出：</strong>\n+-------------+\n| employee_id |\n+-------------+\n| 11          |\n+-------------+\n\n<strong>解释：</strong>\n薪水少于30000美元的员工有1号(Kalel) and 11号 (Joziah)。\nKalel的上级经理是11号员工，他还在公司上班(他是Joziah)。\nJoziah的上级经理是6号员工，他已经离职，因为员工表里面已经没有6号员工的信息了，它被删除了。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1979.找出数组的最大公约数",
        "hardRate": "EASY",
        "passRate": "77.05%",
        "problemsUrl": "https://leetcode.cn/problems/find-greatest-common-divisor-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-greatest-common-divisor-of-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，返回数组中最大数和最小数的 <strong>最大公约数</strong> 。</p>\n\n<p>两个数的&nbsp;<strong>最大公约数</strong> 是能够被两个数整除的最大正整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,5,6,9,10]\n<strong>输出：</strong>2\n<strong>解释：</strong>\nnums 中最小的数是 2\nnums 中最大的数是 10\n2 和 10 的最大公约数是 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [7,5,6,8,3]\n<strong>输出：</strong>1\n<strong>解释：</strong>\nnums 中最小的数是 3\nnums 中最大的数是 8\n3 和 8 的最大公约数是 1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>\nnums 中最小的数是 3\nnums 中最大的数是 3\n3 和 3 的最大公约数是 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1980.找出不同的二进制字符串",
        "hardRate": "MEDIUM",
        "passRate": "59.79%",
        "problemsUrl": "https://leetcode.cn/problems/find-unique-binary-string/",
        "solutionsUrl": "https://leetcode.cn/problems/find-unique-binary-string/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>nums</code> ，该数组由 <code>n</code> 个 <strong>互不相同</strong> 的二进制字符串组成，且每个字符串长度都是 <code>n</code> 。请你找出并返回一个长度为&nbsp;<code>n</code>&nbsp;且&nbsp;<strong>没有出现</strong> 在 <code>nums</code> 中的二进制字符串<em>。</em>如果存在多种答案，只需返回 <strong>任意一个</strong> 即可。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [\"01\",\"10\"]\n<strong>输出：</strong>\"11\"\n<strong>解释：</strong>\"11\" 没有出现在 nums 中。\"00\" 也是正确答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [\"00\",\"01\"]\n<strong>输出：</strong>\"11\"\n<strong>解释：</strong>\"11\" 没有出现在 nums 中。\"10\" 也是正确答案。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [\"111\",\"011\",\"001\"]\n<strong>输出：</strong>\"101\"\n<strong>解释：</strong>\"101\" 没有出现在 nums 中。\"000\"、\"010\"、\"100\"、\"110\" 也是正确答案。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 16</code></li>\n\t<li><code>nums[i].length == n</code></li>\n\t<li><code>nums[i] </code>为 <code>'0'</code> 或 <code>'1'</code></li>\n\t<li><code>nums</code> 中的所有字符串 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1981.最小化目标值与所选元素的差",
        "hardRate": "MEDIUM",
        "passRate": "33.25%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-the-difference-between-target-and-chosen-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-the-difference-between-target-and-chosen-elements/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的整数矩阵 <code>mat</code> 和一个整数 <code>target</code> 。</p>\n\n<p>从矩阵的 <strong>每一行</strong> 中选择一个整数，你的目标是&nbsp;<strong>最小化</strong>&nbsp;所有选中元素之&nbsp;<strong>和</strong>&nbsp;与目标值 <code>target</code> 的 <strong>绝对差</strong> 。</p>\n\n<p>返回 <strong>最小的绝对差</strong> 。</p>\n\n<p><code>a</code> 和 <code>b</code> 两数字的 <strong>绝对差</strong> 是 <code>a - b</code> 的绝对值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/03/matrix1.png\" style=\"width: 181px; height: 181px;\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1,2,3],[4,5,6],[7,8,9]], target = 13\n<strong>输出：</strong>0\n<strong>解释：</strong>一种可能的最优选择方案是：\n- 第一行选出 1\n- 第二行选出 5\n- 第三行选出 7\n所选元素的和是 13 ，等于目标值，所以绝对差是 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/03/matrix1-1.png\" style=\"width: 61px; height: 181px;\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1],[2],[3]], target = 100\n<strong>输出：</strong>94\n<strong>解释：</strong>唯一一种选择方案是：\n- 第一行选出 1\n- 第二行选出 2\n- 第三行选出 3\n所选元素的和是 6 ，绝对差是 94 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/03/matrix1-3.png\" style=\"width: 301px; height: 61px;\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1,2,9,8,7]], target = 6\n<strong>输出：</strong>1\n<strong>解释：</strong>最优的选择方案是选出第一行的 7 。\n绝对差是 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 70</code></li>\n\t<li><code>1 &lt;= mat[i][j] &lt;= 70</code></li>\n\t<li><code>1 &lt;= target &lt;= 800</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1982.从子集的和还原数组",
        "hardRate": "HARD",
        "passRate": "48.43%",
        "problemsUrl": "https://leetcode.cn/problems/find-array-given-subset-sums/",
        "solutionsUrl": "https://leetcode.cn/problems/find-array-given-subset-sums/solution",
        "problemsDesc": "<p>存在一个未知数组需要你进行还原，给你一个整数 <code>n</code> 表示该数组的长度。另给你一个数组 <code>sums</code> ，由未知数组中全部 <code>2<sup>n</sup></code> 个 <strong>子集的和</strong> 组成（子集中的元素没有特定的顺序）。</p>\n\n<p>返回一个长度为 <code>n</code> 的数组<em> </em><code>ans</code><em> </em>表示还原得到的未知数组。如果存在 <strong>多种</strong> 答案，只需返回其中 <strong>任意一个</strong> 。</p>\n\n<p>如果可以由数组 <code>arr</code> 删除部分元素（也可能不删除或全删除）得到数组 <code>sub</code> ，那么数组 <code>sub</code> 就是数组 <code>arr</code> 的一个<strong> 子集</strong> 。<code>sub</code> 的元素之和就是 <code>arr</code> 的一个 <strong>子集的和</strong> 。一个空数组的元素之和为 <code>0</code> 。</p>\n\n<p><strong>注意：</strong>生成的测试用例将保证至少存在一个正确答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, sums = [-3,-2,-1,0,0,1,2,3]\n<strong>输出：</strong>[1,2,-3]\n<strong>解释：</strong>[1,2,-3] 能够满足给出的子集的和：\n- []：和是 0\n- [1]：和是 1\n- [2]：和是 2\n- [1,2]：和是 3\n- [-3]：和是 -3\n- [1,-3]：和是 -2\n- [2,-3]：和是 -1\n- [1,2,-3]：和是 0\n注意，[1,2,-3] 的任何排列和 [-1,-2,3] 的任何排列都会被视作正确答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, sums = [0,0,0,0]\n<strong>输出：</strong>[0,0]\n<strong>解释：</strong>唯一的正确答案是 [0,0] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, sums = [0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8]\n<strong>输出：</strong>[0,-1,4,5]\n<strong>解释：</strong>[0,-1,4,5] 能够满足给出的子集的和。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 15</code></li>\n\t<li><code>sums.length == 2<sup>n</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= sums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1983.范围和相等的最宽索引对",
        "hardRate": "MEDIUM",
        "passRate": "48.16%",
        "problemsUrl": "https://leetcode.cn/problems/widest-pair-of-indices-with-equal-range-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/widest-pair-of-indices-with-equal-range-sum/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1984.学生分数的最小差值",
        "hardRate": "EASY",
        "passRate": "61.77%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-difference-between-highest-and-lowest-of-k-scores/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-difference-between-highest-and-lowest-of-k-scores/solution",
        "problemsDesc": "<p>给你一个 <strong>下标从 0 开始</strong> 的整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 表示第 <code>i</code> 名学生的分数。另给你一个整数 <code>k</code> 。</p>\n\n<p>从数组中选出任意 <code>k</code> 名学生的分数，使这 <code>k</code> 个分数间 <strong>最高分</strong> 和 <strong>最低分</strong> 的 <strong>差值</strong> 达到<strong> 最小化</strong> 。</p>\n\n<p>返回可能的 <strong>最小差值</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [90], k = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>选出 1 名学生的分数，仅有 1 种方法：\n- [<em><strong>90</strong></em>] 最高分和最低分之间的差值是 90 - 90 = 0\n可能的最小差值是 0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [9,4,1,7], k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>选出 2 名学生的分数，有 6 种方法：\n- [<em><strong>9</strong></em>,<em><strong>4</strong></em>,1,7] 最高分和最低分之间的差值是 9 - 4 = 5\n- [<em><strong>9</strong></em>,4,<em><strong>1</strong></em>,7] 最高分和最低分之间的差值是 9 - 1 = 8\n- [<em><strong>9</strong></em>,4,1,<em><strong>7</strong></em>] 最高分和最低分之间的差值是 9 - 7 = 2\n- [9,<em><strong>4</strong></em>,<em><strong>1</strong></em>,7] 最高分和最低分之间的差值是 4 - 1 = 3\n- [9,<em><strong>4</strong></em>,1,<em><strong>7</strong></em>] 最高分和最低分之间的差值是 7 - 4 = 3\n- [9,4,<em><strong>1</strong></em>,<em><strong>7</strong></em>] 最高分和最低分之间的差值是 7 - 1 = 6\n可能的最小差值是 2</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1985.找出数组中的第 K 大整数",
        "hardRate": "MEDIUM",
        "passRate": "42.14%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-kth-largest-integer-in-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-kth-largest-integer-in-the-array/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>nums</code> 和一个整数 <code>k</code> 。<code>nums</code> 中的每个字符串都表示一个不含前导零的整数。</p>\n\n<p>返回 <code>nums</code> 中表示第 <code>k</code> 大整数的字符串。</p>\n\n<p><strong>注意：</strong>重复的数字在统计时会视为不同元素考虑。例如，如果 <code>nums</code> 是 <code>[\"1\",\"2\",\"2\"]</code>，那么 <code>\"2\"</code> 是最大的整数，<code>\"2\"</code> 是第二大的整数，<code>\"1\"</code> 是第三大的整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [\"3\",\"6\",\"7\",\"10\"], k = 4\n<strong>输出：</strong>\"3\"\n<strong>解释：</strong>\nnums 中的数字按非递减顺序排列为 [\"3\",\"6\",\"7\",\"10\"]\n其中第 4 大整数是 \"3\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [\"2\",\"21\",\"12\",\"1\"], k = 3\n<strong>输出：</strong>\"2\"\n<strong>解释：</strong>\nnums 中的数字按非递减顺序排列为 [\"1\",\"2\",\"12\",\"21\"]\n其中第 3 大整数是 \"2\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [\"0\",\"0\"], k = 2\n<strong>输出：</strong>\"0\"\n<strong>解释：</strong>\nnums 中的数字按非递减顺序排列为 [\"0\",\"0\"]\n其中第 2 大整数是 \"0\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i].length &lt;= 100</code></li>\n\t<li><code>nums[i]</code> 仅由数字组成</li>\n\t<li><code>nums[i]</code> 不含任何前导零</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1986.完成任务的最少工作时间段",
        "hardRate": "MEDIUM",
        "passRate": "33.27%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-work-sessions-to-finish-the-tasks/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-work-sessions-to-finish-the-tasks/solution",
        "problemsDesc": "<p>你被安排了 <code>n</code>&nbsp;个任务。任务需要花费的时间用长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>tasks</code>&nbsp;表示，第 <code>i</code>&nbsp;个任务需要花费&nbsp;<code>tasks[i]</code>&nbsp;小时完成。一个 <strong>工作时间段</strong>&nbsp;中，你可以 <strong>至多</strong>&nbsp;连续工作&nbsp;<code>sessionTime</code>&nbsp;个小时，然后休息一会儿。</p>\n\n<p>你需要按照如下条件完成给定任务：</p>\n\n<ul>\n\t<li>如果你在某一个时间段开始一个任务，你需要在 <strong>同一个</strong>&nbsp;时间段完成它。</li>\n\t<li>完成一个任务后，你可以 <strong>立马</strong>&nbsp;开始一个新的任务。</li>\n\t<li>你可以按 <strong>任意顺序</strong>&nbsp;完成任务。</li>\n</ul>\n\n<p>给你&nbsp;<code>tasks</code> 和&nbsp;<code>sessionTime</code>&nbsp;，请你按照上述要求，返回完成所有任务所需要的&nbsp;<strong>最少</strong>&nbsp;数目的&nbsp;<strong>工作时间段</strong>&nbsp;。</p>\n\n<p>测试数据保证&nbsp;<code>sessionTime</code> <strong>大于等于</strong>&nbsp;<code>tasks[i]</code>&nbsp;中的&nbsp;<strong>最大值</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>tasks = [1,2,3], sessionTime = 3\n<b>输出：</b>2\n<b>解释：</b>你可以在两个工作时间段内完成所有任务。\n- 第一个工作时间段：完成第一和第二个任务，花费 1 + 2 = 3 小时。\n- 第二个工作时间段：完成第三个任务，花费 3 小时。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>tasks = [3,1,3,1,1], sessionTime = 8\n<b>输出：</b>2\n<b>解释：</b>你可以在两个工作时间段内完成所有任务。\n- 第一个工作时间段：完成除了最后一个任务以外的所有任务，花费 3 + 1 + 3 + 1 = 8 小时。\n- 第二个工作时间段，完成最后一个任务，花费 1 小时。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>tasks = [1,2,3,4,5], sessionTime = 15\n<b>输出：</b>1\n<b>解释：</b>你可以在一个工作时间段以内完成所有任务。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == tasks.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 14</code></li>\n\t<li><code>1 &lt;= tasks[i] &lt;= 10</code></li>\n\t<li><code>max(tasks[i]) &lt;= sessionTime &lt;= 15</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1987.不同的好子序列数目",
        "hardRate": "HARD",
        "passRate": "50.49%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-unique-good-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-unique-good-subsequences/solution",
        "problemsDesc": "<p>给你一个二进制字符串&nbsp;<code>binary</code>&nbsp;。&nbsp;<code>binary</code>&nbsp;的一个 <strong>子序列</strong>&nbsp;如果是 <strong>非空</strong>&nbsp;的且没有 <b>前导</b>&nbsp;<strong>0</strong>&nbsp;（除非数字是 <code>\"0\"</code>&nbsp;本身），那么它就是一个 <strong>好</strong>&nbsp;的子序列。</p>\n\n<p>请你找到&nbsp;<code>binary</code>&nbsp;<strong>不同好子序列</strong>&nbsp;的数目。</p>\n\n<ul>\n\t<li>比方说，如果&nbsp;<code>binary = \"001\"</code>&nbsp;，那么所有 <strong>好</strong>&nbsp;子序列为&nbsp;<code>[\"0\", \"0\", \"1\"]</code>&nbsp;，所以 <b>不同</b>&nbsp;的好子序列为&nbsp;<code>\"0\"</code> 和&nbsp;<code>\"1\"</code>&nbsp;。 注意，子序列&nbsp;<code>\"00\"</code>&nbsp;，<code>\"01\"</code>&nbsp;和&nbsp;<code>\"001\"</code>&nbsp;不是好的，因为它们有前导 0 。</li>\n</ul>\n\n<p>请你返回&nbsp;<code>binary</code>&nbsp;中&nbsp;<strong>不同好子序列</strong>&nbsp;的数目。由于答案可能很大，请将它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong> 后返回。</p>\n\n<p>一个 <strong>子序列</strong>&nbsp;指的是从原数组中删除若干个（可以一个也不删除）元素后，不改变剩余元素顺序得到的序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>binary = \"001\"\n<b>输出：</b>2\n<b>解释：</b>好的二进制子序列为 [\"0\", \"0\", \"1\"] 。\n不同的好子序列为 \"0\" 和 \"1\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>binary = \"11\"\n<b>输出：</b>2\n<b>解释：</b>好的二进制子序列为 [\"1\", \"1\", \"11\"] 。\n不同的好子序列为 \"1\" 和 \"11\" 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>binary = \"101\"\n<b>输出：</b>5\n<b>解释：</b>好的二进制子序列为 [\"1\", \"0\", \"1\", \"10\", \"11\", \"101\"] 。\n不同的好子序列为 \"0\" ，\"1\" ，\"10\" ，\"11\" 和 \"101\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= binary.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>binary</code>&nbsp;只含有&nbsp;<code>'0'</code>&nbsp;和&nbsp;<code>'1'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1988.找出每所学校的最低分数要求",
        "hardRate": "MEDIUM",
        "passRate": "64.64%",
        "problemsUrl": "https://leetcode.cn/problems/find-cutoff-score-for-each-school/",
        "solutionsUrl": "https://leetcode.cn/problems/find-cutoff-score-for-each-school/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1989.捉迷藏中可捕获的最大人数",
        "hardRate": "MEDIUM",
        "passRate": "55.65%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-people-that-can-be-caught-in-tag/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-people-that-can-be-caught-in-tag/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1990.统计实验的数量",
        "hardRate": "MEDIUM",
        "passRate": "47.10%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-experiments/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-experiments/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1991.找到数组的中间位置",
        "hardRate": "EASY",
        "passRate": "63.90%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-middle-index-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-middle-index-in-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，请你找到 <strong>最左边</strong>&nbsp;的中间位置&nbsp;<code>middleIndex</code>&nbsp;（也就是所有可能中间位置下标最小的一个）。</p>\n\n<p>中间位置&nbsp;<code>middleIndex</code>&nbsp;是满足&nbsp;<code>nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1]</code>&nbsp;的数组下标。</p>\n\n<p>如果&nbsp;<code>middleIndex == 0</code>&nbsp;，左边部分的和定义为 <code>0</code>&nbsp;。类似的，如果&nbsp;<code>middleIndex == nums.length - 1</code>&nbsp;，右边部分的和定义为&nbsp;<code>0</code>&nbsp;。</p>\n\n<p>请你返回满足上述条件 <strong>最左边</strong>&nbsp;的<em>&nbsp;</em><code>middleIndex</code>&nbsp;，如果不存在这样的中间位置，请你返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,3,-1,<em><strong>8</strong></em>,4]\n<b>输出：</b>3\n<strong>解释：</strong>\n下标 3 之前的数字和为：2 + 3 + -1 = 4\n下标 3 之后的数字和为：4 = 4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,-1,<em><strong>4</strong></em>]\n<b>输出：</b>2\n<strong>解释：</strong>\n下标 2 之前的数字和为：1 + -1 = 0\n下标 2 之后的数字和为：0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,5]\n<b>输出：</b>-1\n<b>解释：</b>\n不存在符合要求的 middleIndex 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [<em><strong>1</strong></em>]\n<b>输出：</b>0\n<strong>解释：</strong>\n下标 0 之前的数字和为：0\n下标 0 之后的数字和为：0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与主站 724 题相同：<a href=\"https://leetcode-cn.com/problems/find-pivot-index/\" target=\"_blank\">https://leetcode-cn.com/problems/find-pivot-index/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1992.找到所有的农场组",
        "hardRate": "MEDIUM",
        "passRate": "61.24%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-groups-of-farmland/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-groups-of-farmland/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始，大小为&nbsp;<code>m x n</code>&nbsp;的二进制矩阵&nbsp;<code>land</code>&nbsp;，其中 <code>0</code>&nbsp;表示一单位的森林土地，<code>1</code>&nbsp;表示一单位的农场土地。</p>\n\n<p>为了让农场保持有序，农场土地之间以矩形的 <strong>农场组</strong> 的形式存在。每一个农场组都 <strong>仅</strong>&nbsp;包含农场土地。且题目保证不会有两个农场组相邻，也就是说一个农场组中的任何一块土地都 <strong>不会</strong>&nbsp;与另一个农场组的任何一块土地在四个方向上相邻。</p>\n\n<p><code>land</code>&nbsp;可以用坐标系统表示，其中 <code>land</code>&nbsp;左上角坐标为&nbsp;<code>(0, 0)</code>&nbsp;，右下角坐标为&nbsp;<code>(m-1, n-1)</code>&nbsp;。请你找到所有 <b>农场组</b>&nbsp;最左上角和最右下角的坐标。一个左上角坐标为&nbsp;<code>(r<sub>1</sub>, c<sub>1</sub>)</code>&nbsp;且右下角坐标为&nbsp;<code>(r<sub>2</sub>, c<sub>2</sub>)</code>&nbsp;的 <strong>农场组</strong> 用长度为 4 的数组&nbsp;<code>[r<sub>1</sub>, c<sub>1</sub>, r<sub>2</sub>, c<sub>2</sub>]</code>&nbsp;表示。</p>\n\n<p>请你返回一个二维数组，它包含若干个长度为 4 的子数组，每个子数组表示 <code>land</code>&nbsp;中的一个 <strong>农场组</strong>&nbsp;。如果没有任何农场组，请你返回一个空数组。可以以 <strong>任意顺序</strong>&nbsp;返回所有农场组。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/27/screenshot-2021-07-27-at-12-23-15-copy-of-diagram-drawio-diagrams-net.png\" style=\"width: 300px; height: 300px;\"></p>\n\n<pre><b>输入：</b>land = [[1,0,0],[0,1,1],[0,1,1]]\n<b>输出：</b>[[0,0,0,0],[1,1,2,2]]\n<strong>解释：</strong>\n第一个农场组的左上角为 land[0][0] ，右下角为 land[0][0] 。\n第二个农场组的左上角为 land[1][1] ，右下角为 land[2][2] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/27/screenshot-2021-07-27-at-12-30-26-copy-of-diagram-drawio-diagrams-net.png\" style=\"width: 200px; height: 200px;\"></p>\n\n<pre><b>输入：</b>land = [[1,1],[1,1]]\n<b>输出：</b>[[0,0,1,1]]\n<strong>解释：</strong>\n第一个农场组左上角为 land[0][0] ，右下角为 land[1][1] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/27/screenshot-2021-07-27-at-12-32-24-copy-of-diagram-drawio-diagrams-net.png\" style=\"width: 100px; height: 100px;\"></p>\n\n<pre><b>输入：</b>land = [[0]]\n<b>输出：</b>[]\n<b>解释：</b>\n没有任何农场组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == land.length</code></li>\n\t<li><code>n == land[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>land</code>&nbsp;只包含&nbsp;<code>0</code>&nbsp;和&nbsp;<code>1</code>&nbsp;。</li>\n\t<li>农场组都是 <strong>矩形</strong>&nbsp;的形状。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1993.树上的操作",
        "hardRate": "MEDIUM",
        "passRate": "40.05%",
        "problemsUrl": "https://leetcode.cn/problems/operations-on-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/operations-on-tree/solution",
        "problemsDesc": "<p>给你一棵&nbsp;<code>n</code>&nbsp;个节点的树，编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，以父节点数组&nbsp;<code>parent</code>&nbsp;的形式给出，其中&nbsp;<code>parent[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个节点的父节点。树的根节点为 <code>0</code>&nbsp;号节点，所以&nbsp;<code>parent[0] = -1</code>&nbsp;，因为它没有父节点。你想要设计一个数据结构实现树里面对节点的加锁，解锁和升级操作。</p>\n\n<p>数据结构需要支持如下函数：</p>\n\n<ul>\n\t<li><strong>Lock：</strong>指定用户给指定节点 <strong>上锁</strong>&nbsp;，上锁后其他用户将无法给同一节点上锁。只有当节点处于未上锁的状态下，才能进行上锁操作。</li>\n\t<li><strong>Unlock：</strong>指定用户给指定节点 <strong>解锁</strong>&nbsp;，只有当指定节点当前正被指定用户锁住时，才能执行该解锁操作。</li>\n\t<li><b>Upgrade：</b>指定用户给指定节点&nbsp;<strong>上锁</strong>&nbsp;，并且将该节点的所有子孙节点&nbsp;<strong>解锁</strong>&nbsp;。只有如下 3 个条件 <strong>全部</strong> 满足时才能执行升级操作：\n\t<ul>\n\t\t<li>指定节点当前状态为未上锁。</li>\n\t\t<li>指定节点至少有一个上锁状态的子孙节点（可以是 <strong>任意</strong>&nbsp;用户上锁的）。</li>\n\t\t<li>指定节点没有任何上锁的祖先节点。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你实现&nbsp;<code>LockingTree</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>LockingTree(int[] parent)</code>&nbsp;用父节点数组初始化数据结构。</li>\n\t<li><code>lock(int num, int user)</code> 如果&nbsp;id 为&nbsp;<code>user</code>&nbsp;的用户可以给节点&nbsp;<code>num</code>&nbsp;上锁，那么返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。如果可以执行此操作，节点&nbsp;<code>num</code>&nbsp;会被 id 为 <code>user</code>&nbsp;的用户 <strong>上锁</strong>&nbsp;。</li>\n\t<li><code>unlock(int num, int user)</code>&nbsp;如果 id 为 <code>user</code>&nbsp;的用户可以给节点 <code>num</code>&nbsp;解锁，那么返回&nbsp;<code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。如果可以执行此操作，节点 <code>num</code>&nbsp;变为 <strong>未上锁</strong>&nbsp;状态。</li>\n\t<li><code>upgrade(int num, int user)</code>&nbsp;如果 id 为 <code>user</code>&nbsp;的用户可以给节点 <code>num</code>&nbsp;升级，那么返回&nbsp;<code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。如果可以执行此操作，节点 <code>num</code>&nbsp;会被&nbsp;<strong>升级 </strong>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/29/untitled.png\" style=\"width: 375px; height: 246px;\"></p>\n\n<pre><strong>输入：</strong>\n[\"LockingTree\", \"lock\", \"unlock\", \"unlock\", \"lock\", \"upgrade\", \"lock\"]\n[[[-1, 0, 0, 1, 1, 2, 2]], [2, 2], [2, 3], [2, 2], [4, 5], [0, 1], [0, 1]]\n<strong>输出：</strong>\n[null, true, false, true, true, true, false]\n\n<strong>解释：</strong>\nLockingTree lockingTree = new LockingTree([-1, 0, 0, 1, 1, 2, 2]);\nlockingTree.lock(2, 2);    // 返回 true ，因为节点 2 未上锁。\n                           // 节点 2 被用户 2 上锁。\nlockingTree.unlock(2, 3);  // 返回 false ，因为用户 3 无法解锁被用户 2 上锁的节点。\nlockingTree.unlock(2, 2);  // 返回 true ，因为节点 2 之前被用户 2 上锁。\n                           // 节点 2 现在变为未上锁状态。\nlockingTree.lock(4, 5);    // 返回 true ，因为节点 4 未上锁。\n                           // 节点 4 被用户 5 上锁。\nlockingTree.upgrade(0, 1); // 返回 true ，因为节点 0 未上锁且至少有一个被上锁的子孙节点（节点 4）。\n                           // 节点 0 被用户 1 上锁，节点 4 变为未上锁。\nlockingTree.lock(0, 1);    // 返回 false ，因为节点 0 已经被上锁了。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == parent.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 2000</code></li>\n\t<li>对于&nbsp;<code>i != 0</code>&nbsp;，满足&nbsp;<code>0 &lt;= parent[i] &lt;= n - 1</code></li>\n\t<li><code>parent[0] == -1</code></li>\n\t<li><code>0 &lt;= num &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= user &lt;= 10<sup>4</sup></code></li>\n\t<li><code>parent</code>&nbsp;表示一棵合法的树。</li>\n\t<li><code>lock</code>&nbsp;，<code>unlock</code>&nbsp;和&nbsp;<code>upgrade</code>&nbsp;的调用&nbsp;<strong>总共&nbsp;</strong>不超过&nbsp;<code>2000</code>&nbsp;次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1994.好子集的数目",
        "hardRate": "HARD",
        "passRate": "56.19%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-good-subsets/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-good-subsets/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;。如果&nbsp;<code>nums</code>&nbsp;的一个子集中，所有元素的乘积可以表示为一个或多个 <strong>互不相同的质数</strong> 的乘积，那么我们称它为&nbsp;<strong>好子集</strong>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，如果&nbsp;<code>nums = [1, 2, 3, 4]</code>&nbsp;：\n\n\t<ul>\n\t\t<li><code>[2, 3]</code>&nbsp;，<code>[1, 2, 3]</code>&nbsp;和&nbsp;<code>[1, 3]</code>&nbsp;是 <strong>好</strong>&nbsp;子集，乘积分别为&nbsp;<code>6 = 2*3</code>&nbsp;，<code>6 = 2*3</code>&nbsp;和&nbsp;<code>3 = 3</code>&nbsp;。</li>\n\t\t<li><code>[1, 4]</code> 和&nbsp;<code>[4]</code>&nbsp;不是 <strong>好</strong>&nbsp;子集，因为乘积分别为&nbsp;<code>4 = 2*2</code> 和&nbsp;<code>4 = 2*2</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回 <code>nums</code>&nbsp;中不同的&nbsp;<strong>好</strong>&nbsp;子集的数目对<em>&nbsp;</em><code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;的结果。</p>\n\n<p><code>nums</code>&nbsp;中的 <strong>子集</strong>&nbsp;是通过删除 <code>nums</code>&nbsp;中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4]\n<b>输出：</b>6\n<b>解释：</b>好子集为：\n- [1,2]：乘积为 2 ，可以表示为质数 2 的乘积。\n- [1,2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。\n- [1,3]：乘积为 3 ，可以表示为质数 3 的乘积。\n- [2]：乘积为 2 ，可以表示为质数 2 的乘积。\n- [2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。\n- [3]：乘积为 3 ，可以表示为质数 3 的乘积。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [4,2,3,15]\n<b>输出：</b>5\n<b>解释：</b>好子集为：\n- [2]：乘积为 2 ，可以表示为质数 2 的乘积。\n- [2,3]：乘积为 6 ，可以表示为互不相同质数 2 和 3 的乘积。\n- [2,15]：乘积为 30 ，可以表示为互不相同质数 2，3 和 5 的乘积。\n- [3]：乘积为 3 ，可以表示为质数 3 的乘积。\n- [15]：乘积为 15 ，可以表示为互不相同质数 3 和 5 的乘积。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 30</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1995.统计特殊四元组",
        "hardRate": "EASY",
        "passRate": "66.28%",
        "problemsUrl": "https://leetcode.cn/problems/count-special-quadruplets/",
        "solutionsUrl": "https://leetcode.cn/problems/count-special-quadruplets/solution",
        "problemsDesc": "<p>给你一个 <strong>下标从 0 开始</strong> 的整数数组 <code>nums</code> ，返回满足下述条件的 <strong>不同</strong> 四元组 <code>(a, b, c, d)</code> 的 <strong>数目</strong> ：</p>\n\n<ul>\n\t<li><code>nums[a] + nums[b] + nums[c] == nums[d]</code> ，且</li>\n\t<li><code>a &lt; b &lt; c &lt; d</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,6]\n<strong>输出：</strong>1\n<strong>解释：</strong>满足要求的唯一一个四元组是 (0, 1, 2, 3) 因为 1 + 2 + 3 == 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,3,6,4,5]\n<strong>输出：</strong>0\n<strong>解释：</strong>[3,3,6,4,5] 中不存在满足要求的四元组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,1,3,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>满足要求的 4 个四元组如下：\n- (0, 1, 2, 3): 1 + 1 + 1 == 3\n- (0, 1, 3, 4): 1 + 1 + 3 == 5\n- (0, 2, 3, 4): 1 + 1 + 3 == 5\n- (1, 2, 3, 4): 1 + 1 + 3 == 5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>4 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1996.游戏中弱角色的数量",
        "hardRate": "MEDIUM",
        "passRate": "41.50%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-weak-characters-in-the-game/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-weak-characters-in-the-game/solution",
        "problemsDesc": "<p>你正在参加一个多角色游戏，每个角色都有两个主要属性：<strong>攻击</strong> 和 <strong>防御</strong> 。给你一个二维整数数组 <code>properties</code> ，其中 <code>properties[i] = [attack<sub>i</sub>, defense<sub>i</sub>]</code> 表示游戏中第 <code>i</code> 个角色的属性。</p>\n\n<p>如果存在一个其他角色的攻击和防御等级 <strong>都严格高于</strong> 该角色的攻击和防御等级，则认为该角色为 <strong>弱角色</strong> 。更正式地，如果认为角色 <code>i</code> <strong>弱于</strong> 存在的另一个角色 <code>j</code> ，那么 <code>attack<sub>j</sub> &gt; attack<sub>i</sub></code> 且 <code>defense<sub>j</sub> &gt; defense<sub>i</sub></code> 。</p>\n\n<p>返回 <strong>弱角色</strong> 的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>properties = [[5,5],[6,3],[3,6]]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在攻击和防御都严格高于其他角色的角色。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>properties = [[2,2],[3,3]]\n<strong>输出：</strong>1\n<strong>解释：</strong>第一个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>properties = [[1,5],[10,4],[4,3]]\n<strong>输出：</strong>1\n<strong>解释：</strong>第三个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= properties.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>properties[i].length == 2</code></li>\n\t<li><code>1 &lt;= attack<sub>i</sub>, defense<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1997.访问完所有房间的第一天",
        "hardRate": "MEDIUM",
        "passRate": "35.21%",
        "problemsUrl": "https://leetcode.cn/problems/first-day-where-you-have-been-in-all-the-rooms/",
        "solutionsUrl": "https://leetcode.cn/problems/first-day-where-you-have-been-in-all-the-rooms/solution",
        "problemsDesc": "<p>你需要访问&nbsp;<code>n</code> 个房间，房间从 <code>0</code> 到 <code>n - 1</code> 编号。同时，每一天都有一个日期编号，从 <code>0</code> 开始，依天数递增。你每天都会访问一个房间。</p>\n\n<p>最开始的第 <code>0</code> 天，你访问&nbsp;<code>0</code> 号房间。给你一个长度为 <code>n</code> 且 <strong>下标从 0 开始</strong> 的数组 <code>nextVisit</code> 。在接下来的几天中，你访问房间的 <strong>次序</strong> 将根据下面的 <strong>规则</strong> 决定：</p>\n\n<ul>\n\t<li>假设某一天，你访问&nbsp;<code>i</code> 号房间。</li>\n\t<li>如果算上本次访问，访问&nbsp;<code>i</code> 号房间的次数为 <strong>奇数</strong> ，那么 <strong>第二天</strong> 需要访问&nbsp;<code>nextVisit[i]</code> 所指定的房间，其中 <code>0 &lt;= nextVisit[i] &lt;= i</code> 。</li>\n\t<li>如果算上本次访问，访问&nbsp;<code>i</code> 号房间的次数为 <strong>偶数</strong> ，那么 <strong>第二天</strong> 需要访问&nbsp;<code>(i + 1) mod n</code> 号房间。</li>\n</ul>\n\n<p>请返回你访问完所有房间的第一天的日期编号。题目数据保证总是存在这样的一天。由于答案可能很大，返回对 <code>10<sup>9</sup> + 7</code> 取余后的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nextVisit = [0,0]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n- 第 0 天，你访问房间 0 。访问 0 号房间的总次数为 1 ，次数为奇数。\n&nbsp; 下一天你需要访问房间的编号是 nextVisit[0] = 0\n- 第 1 天，你访问房间 0 。访问 0 号房间的总次数为 2 ，次数为偶数。\n&nbsp; 下一天你需要访问房间的编号是 (0 + 1) mod 2 = 1\n- 第 2 天，你访问房间 1 。这是你第一次完成访问所有房间的那天。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nextVisit = [0,0,2]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n你每天访问房间的次序是 [0,0,1,0,0,1,2,...] 。\n第 6 天是你访问完所有房间的第一天。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nextVisit = [0,1,2,0]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n你每天访问房间的次序是 [0,0,1,1,2,2,3,...] 。\n第 6 天是你访问完所有房间的第一天。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nextVisit.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nextVisit[i] &lt;= i</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1998.数组的最大公因数排序",
        "hardRate": "HARD",
        "passRate": "45.85%",
        "problemsUrl": "https://leetcode.cn/problems/gcd-sort-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/gcd-sort-of-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，你可以在 <code>nums</code> 上执行下述操作 <strong>任意次</strong> ：</p>\n\n<ul>\n\t<li>如果 <code>gcd(nums[i], nums[j]) &gt; 1</code> ，交换 <code>nums[i]</code> 和 <code>nums[j]</code> 的位置。其中 <code>gcd(nums[i], nums[j])</code> 是&nbsp;<code>nums[i]</code> 和 <code>nums[j]</code> 的最大公因数。</li>\n</ul>\n\n<p>如果能使用上述交换方式将 <code>nums</code> 按 <strong>非递减顺序</strong> 排列，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [7,21,3]\n<strong>输出：</strong>true\n<strong>解释：</strong>可以执行下述操作完成对 [7,21,3] 的排序：\n- 交换 7 和 21 因为 gcd(7,21) = 7 。nums = [<em><strong>21</strong></em>,<em><strong>7</strong></em>,3]\n- 交换 21 和 3 因为 gcd(21,3) = 3 。nums = [<em><strong>3</strong></em>,7,<em><strong>21</strong></em>]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,2,6,2]\n<strong>输出：</strong>false\n<strong>解释：</strong>无法完成排序，因为 5 不能与其他元素交换。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [10,5,9,3,15]\n<strong>输出：</strong>true\n<strong>解释：</strong>\n可以执行下述操作完成对 [10,5,9,3,15] 的排序：\n- 交换 10 和 15 因为 gcd(10,15) = 5 。nums = [<em><strong>15</strong></em>,5,9,3,<em><strong>10</strong></em>]\n- 交换 15 和 3 因为 gcd(15,3) = 3 。nums = [<em><strong>3</strong></em>,5,9,<em><strong>15</strong></em>,10]\n- 交换 10 和 15 因为 gcd(10,15) = 5 。nums = [3,5,9,<em><strong>10</strong></em>,<em><strong>15</strong></em>]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>2 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1999.最小的仅由两个数组成的倍数",
        "hardRate": "MEDIUM",
        "passRate": "46.67%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-greater-multiple-made-of-two-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-greater-multiple-made-of-two-digits/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2000.反转单词前缀",
        "hardRate": "EASY",
        "passRate": "77.40%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-prefix-of-word/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-prefix-of-word/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>word</code> 和一个字符 <code>ch</code> 。找出 <code>ch</code> 第一次出现的下标 <code>i</code> ，<strong>反转 </strong><code>word</code> 中从下标 <code>0</code> 开始、直到下标 <code>i</code> 结束（含下标 <code>i</code> ）的那段字符。如果 <code>word</code> 中不存在字符 <code>ch</code> ，则无需进行任何操作。</p>\n\n<ul>\n\t<li>例如，如果 <code>word = \"abcdefd\"</code> 且 <code>ch = \"d\"</code> ，那么你应该 <strong>反转</strong> 从下标 0 开始、直到下标 <code>3</code> 结束（含下标 <code>3</code> ）。结果字符串将会是 <code>\"<em><strong>dcba</strong></em>efd\"</code> 。</li>\n</ul>\n\n<p>返回 <strong>结果字符串</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>word = \"<em><strong>abcd</strong></em>efd\", ch = \"d\"\n<strong>输出：</strong>\"<em><strong>dcba</strong></em>efd\"\n<strong>解释：</strong>\"d\" 第一次出现在下标 3 。 \n反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 \"dcbaefd\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>word = \"<em><strong>xyxz</strong></em>xe\", ch = \"z\"\n<strong>输出：</strong>\"<em><strong>zxyx</strong></em>xe\"\n<strong>解释：</strong>\"z\" 第一次也是唯一一次出现是在下标 3 。\n反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 \"zxyxxe\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>word = \"abcd\", ch = \"z\"\n<strong>输出：</strong>\"abcd\"\n<strong>解释：</strong>\"z\" 不存在于 word 中。\n无需执行反转操作，结果字符串是 \"abcd\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 250</code></li>\n\t<li><code>word</code> 由小写英文字母组成</li>\n\t<li><code>ch</code> 是一个小写英文字母</li>\n</ul>\n",
        "isPlus": false
    }
]