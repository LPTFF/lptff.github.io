[
    {
        "problemsName": " 1876.长度为三且各字符不同的子字符串",
        "hardRate": "EASY",
        "passRate": "70.45%",
        "problemsUrl": "https://leetcode.cn/problems/substrings-of-size-three-with-distinct-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/substrings-of-size-three-with-distinct-characters/solution",
        "problemsDesc": "<p>如果一个字符串不含有任何重复字符，我们称这个字符串为 <strong>好</strong> 字符串。</p>\n\n<p>给你一个字符串 <code>s</code> ，请你返回 <code>s</code> 中长度为 <strong>3</strong> 的 <strong>好子字符串</strong> 的数量。</p>\n\n<p>注意，如果相同的好子字符串出现多次，每一次都应该被记入答案之中。</p>\n\n<p><strong>子字符串</strong> 是一个字符串中连续的字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"xyzzaz\"\n<b>输出：</b>1\n<b>解释：</b>总共有 4 个长度为 3 的子字符串：\"xyz\"，\"yzz\"，\"zza\" 和 \"zaz\" 。\n唯一的长度为 3 的好子字符串是 \"xyz\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aababcabc\"\n<b>输出：</b>4\n<b>解释：</b>总共有 7 个长度为 3 的子字符串：\"aab\"，\"aba\"，\"bab\"，\"abc\"，\"bca\"，\"cab\" 和 \"abc\" 。\n好子字符串包括 \"abc\"，\"bca\"，\"cab\" 和 \"abc\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 100</code></li>\n\t<li><code>s</code>​​​​​​ 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1877.数组中最大数对和的最小值",
        "hardRate": "MEDIUM",
        "passRate": "81.16%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-maximum-pair-sum-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-maximum-pair-sum-in-array/solution",
        "problemsDesc": "<p>一个数对 <code>(a,b)</code> 的 <strong>数对和</strong> 等于 <code>a + b</code> 。<strong>最大数对和</strong> 是一个数对数组中最大的 <strong>数对和</strong> 。</p>\n\n<ul>\n\t<li>比方说，如果我们有数对 <code>(1,5)</code> ，<code>(2,3)</code> 和 <code>(4,4)</code>，<strong>最大数对和</strong> 为 <code>max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8</code> 。</li>\n</ul>\n\n<p>给你一个长度为 <strong>偶数</strong> <code>n</code> 的数组 <code>nums</code> ，请你将 <code>nums</code> 中的元素分成 <code>n / 2</code> 个数对，使得：</p>\n\n<ul>\n\t<li><code>nums</code> 中每个元素 <strong>恰好</strong> 在 <strong>一个</strong> 数对中，且</li>\n\t<li><strong>最大数对和</strong> 的值 <strong>最小</strong> 。</li>\n</ul>\n\n<p>请你在最优数对划分的方案下，返回最小的 <strong>最大数对和</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [3,5,2,3]\n<b>输出：</b>7\n<b>解释：</b>数组中的元素可以分为数对 (3,3) 和 (5,2) 。\n最大数对和为 max(3+3, 5+2) = max(6, 7) = 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [3,5,4,2,4,6]\n<b>输出：</b>8\n<b>解释：</b>数组中的元素可以分为数对 (3,5)，(4,4) 和 (6,2) 。\n最大数对和为 max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>n</code> 是 <strong>偶数</strong> 。</li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1878.矩阵中最大的三个菱形和",
        "hardRate": "MEDIUM",
        "passRate": "45.52%",
        "problemsUrl": "https://leetcode.cn/problems/get-biggest-three-rhombus-sums-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/get-biggest-three-rhombus-sums-in-a-grid/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的整数矩阵 <code>grid</code> 。</p>\n\n<p><strong>菱形和</strong> 指的是 <code>grid</code> 中一个正菱形 <strong>边界</strong> 上的元素之和。本题中的菱形必须为正方形旋转45度，且四个角都在一个格子当中。下图是四个可行的菱形，每个菱形和应该包含的格子都用了相应颜色标注在图中。</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-desc-2.png\" style=\"width: 385px; height: 385px;\" />\n<p> </p>\n\n<p>注意，菱形可以是一个面积为 0 的区域，如上图中右下角的紫色菱形所示。</p>\n\n<p>请你按照 <strong>降序</strong> 返回 <code>grid</code> 中三个最大的 <strong>互不相同的菱形和</strong> 。如果不同的和少于三个，则将它们全部返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-ex1.png\" style=\"width: 360px; height: 361px;\" />\n<pre>\n<b>输入：</b>grid = [[3,4,5,1,3],[3,3,4,2,3],[20,30,200,40,10],[1,5,5,4,1],[4,3,2,2,5]]\n<b>输出：</b>[228,216,211]\n<b>解释：</b>最大的三个菱形和如上图所示。\n- 蓝色：20 + 3 + 200 + 5 = 228\n- 红色：200 + 2 + 10 + 4 = 216\n- 绿色：5 + 200 + 4 + 2 = 211\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-ex2.png\" style=\"width: 217px; height: 217px;\" />\n<pre>\n<b>输入：</b>grid = [[1,2,3],[4,5,6],[7,8,9]]\n<b>输出：</b>[20,9,8]\n<b>解释：</b>最大的三个菱形和如上图所示。\n- 蓝色：4 + 2 + 6 + 8 = 20\n- 红色：9 （右下角红色的面积为 0 的菱形）\n- 绿色：8 （下方中央面积为 0 的菱形）\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>grid = [[7,7,7]]\n<b>输出：</b>[7]\n<b>解释：</b>所有三个可能的菱形和都相同，所以返回 [7] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 <= m, n <= 100</code></li>\n\t<li><code>1 <= grid[i][j] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1879.两个数组最小的异或值之和",
        "hardRate": "HARD",
        "passRate": "50.14%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-xor-sum-of-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-xor-sum-of-two-arrays/solution",
        "problemsDesc": "<p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，它们长度都为 <code>n</code> 。</p>\n\n<p>两个数组的 <strong>异或值之和</strong> 为 <code>(nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1])</code> （<strong>下标从 0 开始</strong>）。</p>\n\n<ul>\n\t<li>比方说，<code>[1,2,3]</code> 和 <code>[3,2,1]</code> 的 <strong>异或值之和</strong> 等于 <code>(1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4</code> 。</li>\n</ul>\n\n<p>请你将 <code>nums2</code> 中的元素重新排列，使得 <strong>异或值之和</strong> <strong>最小</strong> 。</p>\n\n<p>请你返回重新排列之后的 <strong>异或值之和</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,2], nums2 = [2,3]\n<b>输出：</b>2\n<b>解释：</b>将 <code>nums2</code> 重新排列得到 <code>[3,2] 。</code>\n异或值之和为 (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,0,3], nums2 = [5,3,4]\n<b>输出：</b>8\n<b>解释：</b>将 <code>nums2 重新排列得到</code> <code>[5,4,3] 。</code>\n异或值之和为 (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length</code></li>\n\t<li><code>n == nums2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 14</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1880.检查某单词是否等于两单词之和",
        "hardRate": "EASY",
        "passRate": "76.21%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-word-equals-summation-of-two-words/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-word-equals-summation-of-two-words/solution",
        "problemsDesc": "<p>字母的 <strong>字母值</strong> 取决于字母在字母表中的位置，<strong>从 0 开始</strong> 计数。即，<code>'a' -&gt; 0</code>、<code>'b' -&gt; 1</code>、<code>'c' -&gt; 2</code>，以此类推。</p>\n\n<p>对某个由小写字母组成的字符串 <code>s</code> 而言，其 <strong>数值</strong> 就等于将 <code>s</code> 中每个字母的 <strong>字母值</strong> 按顺序 <strong>连接</strong> 并 <strong>转换</strong> 成对应整数。</p>\n\n<ul>\n\t<li>例如，<code>s = \"acb\"</code> ，依次连接每个字母的字母值可以得到 <code>\"021\"</code> ，转换为整数得到 <code>21</code> 。</li>\n</ul>\n\n<p>给你三个字符串 <code>firstWord</code>、<code>secondWord</code> 和 <code>targetWord</code> ，每个字符串都由从 <code>'a'</code> 到 <code>'j'</code> （<strong>含 </strong><code>'a'</code> 和 <code>'j'</code><strong> </strong>）的小写英文字母组成。</p>\n\n<p>如果 <code>firstWord</code><em> </em>和<em> </em><code>secondWord</code> 的 <strong>数值之和</strong> 等于<em> </em><code>targetWord</code><em> </em>的数值，返回 <code>true</code> ；否则，返回<em> </em><code>false</code><em> </em>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>firstWord = \"acb\", secondWord = \"cba\", targetWord = \"cdb\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\nfirstWord 的数值为 \"acb\" -&gt; \"021\" -&gt; 21\nsecondWord 的数值为 \"cba\" -&gt; \"210\" -&gt; 210\ntargetWord 的数值为 \"cdb\" -&gt; \"231\" -&gt; 231\n由于 21 + 210 == 231 ，返回 true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aab\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\nfirstWord 的数值为 \"aaa\" -&gt; \"000\" -&gt; 0\nsecondWord 的数值为 \"a\" -&gt; \"0\" -&gt; 0\ntargetWord 的数值为 \"aab\" -&gt; \"001\" -&gt; 1\n由于 0 + 0 != 1 ，返回 false</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aaaa\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\nfirstWord 的数值为 \"aaa\" -&gt; \"000\" -&gt; 0\nsecondWord 的数值为 \"a\" -&gt; \"0\" -&gt; 0\ntargetWord 的数值为 \"aaaa\" -&gt; \"0000\" -&gt; 0\n由于 0 + 0 == 0 ，返回 true\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= firstWord.length, </code><code>secondWord.length, </code><code>targetWord.length &lt;= 8</code></li>\n\t<li><code>firstWord</code>、<code>secondWord</code> 和 <code>targetWord</code> 仅由从 <code>'a'</code> 到 <code>'j'</code> （<strong>含 </strong><code>'a'</code> 和 <code>'j'</code><strong> </strong>）的小写英文字母组成<strong>。</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1881.插入后的最大值",
        "hardRate": "MEDIUM",
        "passRate": "37.74%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-value-after-insertion/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-value-after-insertion/solution",
        "problemsDesc": "<p>给你一个非常大的整数 <code>n</code> 和一个整数数字 <code>x</code> ，大整数 <code>n</code> 用一个字符串表示。<code>n</code> 中每一位数字和数字 <code>x</code> 都处于闭区间 <code>[1, 9]</code> 中，且 <code>n</code> 可能表示一个 <strong>负数</strong> 。</p>\n\n<p>你打算通过在 <code>n</code> 的十进制表示的任意位置插入 <code>x</code> 来 <strong>最大化</strong> <code>n</code> 的 <strong>数值</strong> ​​​​​​。但 <strong>不能</strong> 在负号的左边插入 <code>x</code> 。</p>\n\n<ul>\n\t<li>例如，如果 <code>n = 73</code> 且 <code>x = 6</code> ，那么最佳方案是将 <code>6</code> 插入 <code>7</code> 和 <code>3</code> 之间，使 <code>n = 763</code> 。</li>\n\t<li>如果 <code>n = -55</code> 且 <code>x = 2</code> ，那么最佳方案是将 <code>2</code> 插在第一个 <code>5</code> 之前，使 <code>n = -255</code> 。</li>\n</ul>\n\n<p>返回插入操作后，用字符串表示的 <code>n</code> 的最大值。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = \"99\", x = 9\n<strong>输出：</strong>\"999\"\n<strong>解释：</strong>不管在哪里插入 9 ，结果都是相同的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = \"-13\", x = 2\n<strong>输出：</strong>\"-123\"\n<strong>解释：</strong>向 n 中插入 x 可以得到 -213、-123 或者 -132 ，三者中最大的是 -123 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= x <= 9</code></li>\n\t<li><code>n</code>​​​ 中每一位的数字都在闭区间 <code>[1, 9]</code> 中。</li>\n\t<li><code>n</code> 代表一个有效的整数。</li>\n\t<li>当 <code>n</code> 表示负数时，将会以字符 <code>'-'</code> 开始。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1882.使用服务器处理任务",
        "hardRate": "MEDIUM",
        "passRate": "30.79%",
        "problemsUrl": "https://leetcode.cn/problems/process-tasks-using-servers/",
        "solutionsUrl": "https://leetcode.cn/problems/process-tasks-using-servers/solution",
        "problemsDesc": "<p>给你两个 <strong>下标从 0 开始</strong> 的整数数组 <code>servers</code> 和 <code>tasks</code> ，长度分别为 <code>n</code>​​​​​​ 和 <code>m</code>​​​​​​ 。<code>servers[i]</code> 是第 <code>i<sup>​​​​​​</sup></code>​​​​ 台服务器的 <strong>权重</strong> ，而 <code>tasks[j]</code> 是处理第 <code>j<sup>​​​​​​</sup></code> 项任务 <strong>所需要的时间</strong>（单位：秒）。</p>\n\n<p>你正在运行一个仿真系统，在处理完所有任务后，该系统将会关闭。每台服务器只能同时处理一项任务。第 <code>0</code> 项任务在第 <code>0</code> 秒可以开始处理，相应地，第 <code>j</code> 项任务在第 <code>j</code> 秒可以开始处理。处理第 <code>j</code> 项任务时，你需要为它分配一台 <strong>权重最小</strong> 的空闲服务器。如果存在多台相同权重的空闲服务器，请选择 <strong>下标最小</strong> 的服务器。如果一台空闲服务器在第 <code>t</code> 秒分配到第 <code>j</code> 项任务，那么在 <code>t + tasks[j]</code> 时它将恢复空闲状态。</p>\n\n<p>如果没有空闲服务器，则必须等待，直到出现一台空闲服务器，并 <strong>尽可能早</strong> 地处理剩余任务。 如果有多项任务等待分配，则按照 <strong>下标递增</strong> 的顺序完成分配。</p>\n\n<p>如果同一时刻存在多台空闲服务器，可以同时将多项任务分别分配给它们。</p>\n\n<p>构建长度为 <code>m</code> 的答案数组 <code>ans</code> ，其中 <code>ans[j]</code> 是第 <code>j</code> 项任务分配的服务器的下标。</p>\n\n<p>返回答案数组<em> </em><code>ans</code>​​​​ 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>servers = [3,3,2], tasks = [1,2,3,2,1,2]\n<strong>输出：</strong>[2,2,0,2,1,2]\n<strong>解释：</strong>事件按时间顺序如下：\n- 0 秒时，第 0 项任务加入到任务队列，使用第 2 台服务器处理到 1 秒。\n- 1 秒时，第 2 台服务器空闲，第 1 项任务加入到任务队列，使用第 2 台服务器处理到 3 秒。\n- 2 秒时，第 2 项任务加入到任务队列，使用第 0 台服务器处理到 5 秒。\n- 3 秒时，第 2 台服务器空闲，第 3 项任务加入到任务队列，使用第 2 台服务器处理到 5 秒。\n- 4 秒时，第 4 项任务加入到任务队列，使用第 1 台服务器处理到 5 秒。\n- 5 秒时，所有服务器都空闲，第 5 项任务加入到任务队列，使用第 2 台服务器处理到 7 秒。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>servers = [5,1,4,3,2], tasks = [2,1,2,4,5,2,1]\n<strong>输出：</strong>[1,4,1,4,1,3,2]\n<strong>解释：</strong>事件按时间顺序如下：\n- 0 秒时，第 0 项任务加入到任务队列，使用第 1 台服务器处理到 2 秒。\n- 1 秒时，第 1 项任务加入到任务队列，使用第 4 台服务器处理到 2 秒。\n- 2 秒时，第 1 台和第 4 台服务器空闲，第 2 项任务加入到任务队列，使用第 1 台服务器处理到 4 秒。\n- 3 秒时，第 3 项任务加入到任务队列，使用第 4 台服务器处理到 7 秒。\n- 4 秒时，第 1 台服务器空闲，第 4 项任务加入到任务队列，使用第 1 台服务器处理到 9 秒。\n- 5 秒时，第 5 项任务加入到任务队列，使用第 3 台服务器处理到 7 秒。\n- 6 秒时，第 6 项任务加入到任务队列，使用第 2 台服务器处理到 7 秒。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>servers.length == n</code></li>\n\t<li><code>tasks.length == m</code></li>\n\t<li><code>1 <= n, m <= 2 * 10<sup>5</sup></code></li>\n\t<li><code>1 <= servers[i], tasks[j] <= 2 * 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1883.准时抵达会议现场的最小跳过休息次数",
        "hardRate": "HARD",
        "passRate": "40.22%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-skips-to-arrive-at-meeting-on-time/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-skips-to-arrive-at-meeting-on-time/solution",
        "problemsDesc": "<p>给你一个整数 <code>hoursBefore</code> ，表示你要前往会议所剩下的可用小时数。要想成功抵达会议现场，你必须途经 <code>n</code> 条道路。道路的长度用一个长度为 <code>n</code> 的整数数组 <code>dist</code> 表示，其中 <code>dist[i]</code> 表示第 <code>i</code> 条道路的长度（单位：<strong>千米</strong>）。另给你一个整数 <code>speed</code> ，表示你在道路上前进的速度（单位：<strong>千米每小时</strong>）。</p>\n\n<p>当你通过第 <code>i</code> 条路之后，就必须休息并等待，直到 <strong>下一个整数小时</strong> 才能开始继续通过下一条道路。注意：你不需要在通过最后一条道路后休息，因为那时你已经抵达会议现场。</p>\n\n<ul>\n\t<li>例如，如果你通过一条道路用去 <code>1.4</code> 小时，那你必须停下来等待，到 <code>2</code> 小时才可以继续通过下一条道路。如果通过一条道路恰好用去 <code>2</code> 小时，就无需等待，可以直接继续。</li>\n</ul>\n\n<p>然而，为了能准时到达，你可以选择 <strong>跳过</strong> 一些路的休息时间，这意味着你不必等待下一个整数小时。注意，这意味着与不跳过任何休息时间相比，你可能在不同时刻到达接下来的道路。</p>\n\n<ul>\n\t<li>例如，假设通过第 <code>1</code> 条道路用去 <code>1.4</code> 小时，且通过第 <code>2</code> 条道路用去 <code>0.6</code> 小时。跳过第 <code>1</code> 条道路的休息时间意味着你将会在恰好 <code>2</code> 小时完成通过第 <code>2</code> 条道路，且你能够立即开始通过第 <code>3</code> 条道路。</li>\n</ul>\n\n<p>返回准时抵达会议现场所需要的 <strong>最小跳过次数</strong> ，如果 <strong>无法准时参会</strong> ，返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [1,3,2], speed = 4, hoursBefore = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>\n不跳过任何休息时间，你将用 (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 小时才能抵达会议现场。\n可以跳过第 1 次休息时间，共用 ((1/4 + <strong>0</strong>) + (3/4 + 0)) + (2/4) = 1.5 小时抵达会议现场。\n注意，第 2 次休息时间缩短为 0 ，由于跳过第 1 次休息时间，你是在整数小时处完成通过第 2 条道路。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [7,3,5,5], speed = 2, hoursBefore = 10\n<strong>输出：</strong>2\n<strong>解释：</strong>\n不跳过任何休息时间，你将用 (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 小时才能抵达会议现场。\n可以跳过第 1 次和第 3 次休息时间，共用 ((7/2 + <strong>0</strong>) + (3/2 + 0)) + ((5/2 + <strong>0</strong>) + (5/2)) = 10 小时抵达会议现场。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [7,3,5,5], speed = 1, hoursBefore = 10\n<strong>输出：</strong>-1\n<strong>解释：</strong>即使跳过所有的休息时间，也无法准时参加会议。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == dist.length</code></li>\n\t<li><code>1 <= n <= 1000</code></li>\n\t<li><code>1 <= dist[i] <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= speed <= 10<sup>6</sup></code></li>\n\t<li><code>1 <= hoursBefore <= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1884.鸡蛋掉落-两枚鸡蛋",
        "hardRate": "MEDIUM",
        "passRate": "70.47%",
        "problemsUrl": "https://leetcode.cn/problems/egg-drop-with-2-eggs-and-n-floors/",
        "solutionsUrl": "https://leetcode.cn/problems/egg-drop-with-2-eggs-and-n-floors/solution",
        "problemsDesc": "<p>给你 <strong>2&nbsp;枚相同 </strong>的鸡蛋，和一栋从第 <code>1</code>&nbsp;层到第 <code>n</code> 层共有 <code>n</code> 层楼的建筑。</p>\n\n<p>已知存在楼层 <code>f</code> ，满足&nbsp;<code>0 &lt;= f &lt;= n</code> ，任何从 <strong>高于 </strong><code>f</code> 的楼层落下的鸡蛋都<strong> 会碎 </strong>，从 <strong><code>f</code> 楼层或比它低 </strong>的楼层落下的鸡蛋都 <strong>不会碎 </strong>。</p>\n\n<p>每次操作，你可以取一枚<strong> 没有碎</strong> 的鸡蛋并把它从任一楼层 <code>x</code> 扔下（满足&nbsp;<code>1 &lt;= x &lt;= n</code>）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中<strong> 重复使用 </strong>这枚鸡蛋。</p>\n\n<p>请你计算并返回要确定 <code>f</code> <strong>确切的值 </strong>的 <strong>最小操作次数</strong> 是多少？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>我们可以将第一枚鸡蛋从 1 楼扔下，然后将第二枚从 2 楼扔下。\n如果第一枚鸡蛋碎了，可知 f = 0；\n如果第二枚鸡蛋碎了，但第一枚没碎，可知 f = 1；\n否则，当两个鸡蛋都没碎时，可知 f = 2。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 100\n<strong>输出：</strong>14\n<strong>解释：\n</strong>一种最优的策略是：\n- 将第一枚鸡蛋从 9 楼扔下。如果碎了，那么 f 在 0 和 8 之间。将第二枚从 1 楼扔下，然后每扔一次上一层楼，在 8 次内找到 f 。总操作次数 = 1 + 8 = 9 。\n- 如果第一枚鸡蛋没有碎，那么再把第一枚鸡蛋从 22 层扔下。如果碎了，那么 f 在 9 和 21 之间。将第二枚鸡蛋从 10 楼扔下，然后每扔一次上一层楼，在 12 次内找到 f 。总操作次数 = 2 + 12 = 14 。\n- 如果第一枚鸡蛋没有再次碎掉，则按照类似的方法从 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99 和 100 楼分别扔下第一枚鸡蛋。\n不管结果如何，最多需要扔 14 次来确定 f 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1885.统计数对",
        "hardRate": "MEDIUM",
        "passRate": "59.03%",
        "problemsUrl": "https://leetcode.cn/problems/count-pairs-in-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/count-pairs-in-two-arrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1886.判断矩阵经轮转后是否一致",
        "hardRate": "EASY",
        "passRate": "59.35%",
        "problemsUrl": "https://leetcode.cn/problems/determine-whether-matrix-can-be-obtained-by-rotation/",
        "solutionsUrl": "https://leetcode.cn/problems/determine-whether-matrix-can-be-obtained-by-rotation/solution",
        "problemsDesc": "<p>给你两个大小为 <code>n x n</code> 的二进制矩阵 <code>mat</code> 和 <code>target</code> 。现<strong> 以 90 度顺时针轮转 </strong>矩阵 <code>mat</code> 中的元素 <strong>若干次</strong> ，如果能够使 <code>mat</code> 与 <code>target</code> 一致，返回 <code>true</code> ；否则，返回<em> </em><code>false</code><em> 。</em></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/20/grid3.png\" style=\"width: 301px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>mat = [[0,1],[1,0]], target = [[1,0],[0,1]]\n<strong>输出：</strong>true\n<strong>解释：</strong>顺时针轮转 90 度一次可以使 mat 和 target 一致。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/20/grid4.png\" style=\"width: 301px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>mat = [[0,1],[1,1]], target = [[1,0],[0,1]]\n<strong>输出：</strong>false\n<strong>解释：</strong>无法通过轮转矩阵中的元素使 equal 与 target 一致。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/26/grid4.png\" style=\"width: 661px; height: 184px;\" />\n<pre>\n<strong>输入：</strong>mat = [[0,0,0],[0,1,0],[1,1,1]], target = [[1,1,1],[0,1,0],[0,0,0]]\n<strong>输出：</strong>true\n<strong>解释：</strong>顺时针轮转 90 度两次可以使 mat 和 target 一致。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == mat.length == target.length</code></li>\n\t<li><code>n == mat[i].length == target[i].length</code></li>\n\t<li><code>1 <= n <= 10</code></li>\n\t<li><code>mat[i][j]</code> 和 <code>target[i][j]</code> 不是 <code>0</code> 就是 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1887.使数组元素相等的减少操作次数",
        "hardRate": "MEDIUM",
        "passRate": "65.54%",
        "problemsUrl": "https://leetcode.cn/problems/reduction-operations-to-make-the-array-elements-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/reduction-operations-to-make-the-array-elements-equal/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，你的目标是令 <code>nums</code> 中的所有元素相等。完成一次减少操作需要遵照下面的几个步骤：</p>\n\n<ol>\n\t<li>找出 <code>nums</code> 中的 <strong>最大</strong> 值。记这个值为 <code>largest</code> 并取其下标 <code>i</code> （<strong>下标从 0 开始计数</strong>）。如果有多个元素都是最大值，则取最小的 <code>i</code> 。</li>\n\t<li>找出 <code>nums</code> 中的 <strong>下一个最大</strong> 值，这个值 <strong>严格小于</strong> <code>largest</code> ，记为 <code>nextLargest</code> 。</li>\n\t<li>将 <code>nums[i]</code> 减少到 <code>nextLargest</code> 。</li>\n</ol>\n\n<p>返回使<em> </em><code>nums</code><em> </em>中的所有元素相等的操作次数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,1,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>需要 3 次操作使 nums 中的所有元素相等：\n1. largest = 5 下标为 0 。nextLargest = 3 。将 nums[0] 减少到 3 。nums = [<strong>3</strong>,1,3] 。\n2. largest = 3 下标为 0 。nextLargest = 1 。将 nums[0] 减少到 1 。nums = [<strong>1</strong>,1,3] 。\n3. largest = 3 下标为 2 。nextLargest = 1 。将 nums[2] 减少到 1 。nums = [<strong>1</strong>,1,<strong>1</strong>] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1]\n<strong>输出：</strong>0\n<strong>解释：</strong>nums 中的所有元素已经是相等的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,2,2,3]\n<strong>输出：</strong>4\n<strong>解释：</strong>需要 4 次操作使 nums 中的所有元素相等：\n1. largest = 3 下标为 4 。nextLargest = 2 。将 nums[4] 减少到 2 。nums = [1,1,2,2,<strong>2</strong>] 。\n2. largest = 2 下标为 2 。nextLargest = 1 。将 nums[2] 减少到 1 。nums = [1,1,<strong>1</strong>,2,2] 。 \n3. largest = 2 下标为 3 。nextLargest = 1 。将 nums[3] 减少到 1 。nums = [1,1,1,<strong>1</strong>,2] 。 \n4. largest = 2 下标为 4 。nextLargest = 1 。将 nums[4] 减少到 1 。nums = [1,1,1,1,<strong>1</strong>] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= nums[i] <= 5 * 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1888.使二进制字符串字符交替的最少反转次数",
        "hardRate": "MEDIUM",
        "passRate": "36.51%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/solution",
        "problemsDesc": "<p>给你一个二进制字符串 <code>s</code> 。你可以按任意顺序执行以下两种操作任意次：</p>\n\n<ul>\n\t<li><strong>类型 1 ：删除</strong> 字符串 <code>s</code> 的第一个字符并将它 <strong>添加</strong> 到字符串结尾。</li>\n\t<li><strong>类型 2 ：选择 </strong>字符串 <code>s</code> 中任意一个字符并将该字符 <strong>反转 </strong>，也就是如果值为 <code>'0'</code> ，则反转得到 <code>'1'</code> ，反之亦然。</li>\n</ul>\n\n<p>请你返回使 <code>s</code> 变成 <strong>交替</strong> 字符串的前提下， <strong>类型 2 </strong>的 <strong>最少</strong> 操作次数 。</p>\n\n<p>我们称一个字符串是 <strong>交替</strong> 的，需要满足任意相邻字符都不同。</p>\n\n<ul>\n\t<li>比方说，字符串 <code>\"010\"</code> 和 <code>\"1010\"</code> 都是交替的，但是字符串 <code>\"0100\"</code> 不是。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"111000\"\n<b>输出：</b>2\n<b>解释：</b>执行第一种操作两次，得到 s = \"100011\" 。\n然后对第三个和第六个字符执行第二种操作，得到 s = \"10<strong>1</strong>01<strong>0</strong>\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"010\"\n<b>输出：</b>0\n<strong>解释：</strong>字符串已经是交替的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>s = \"1110\"\n<b>输出：</b>1\n<b>解释：</b>对第二个字符执行第二种操作，得到 s = \"1<strong>0</strong>10\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 要么是 <code>'0'</code> ，要么是 <code>'1'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1889.装包裹的最小浪费空间",
        "hardRate": "HARD",
        "passRate": "29.55%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-space-wasted-from-packaging/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-space-wasted-from-packaging/solution",
        "problemsDesc": "<p>给你 <code>n</code> 个包裹，你需要把它们装在箱子里，<strong>每个箱子装一个包裹</strong>。总共有 <code>m</code> 个供应商提供 <strong>不同尺寸</strong> 的箱子（每个规格都有无数个箱子）。如果一个包裹的尺寸 <strong>小于等于</strong> 一个箱子的尺寸，那么这个包裹就可以放入这个箱子之中。</p>\n\n<p>包裹的尺寸用一个整数数组 <code>packages</code> 表示，其中 <code>packages[i]</code> 是第 <code>i</code> 个包裹的尺寸。供应商用二维数组 <code>boxes</code> 表示，其中 <code>boxes[j]</code> 是第 <code>j</code> 个供应商提供的所有箱子尺寸的数组。</p>\n\n<p>你想要选择 <strong>一个供应商</strong> 并只使用该供应商提供的箱子，使得 <strong>总浪费空间最小</strong> 。对于每个装了包裹的箱子，我们定义 <strong>浪费的</strong> 空间等于 <code>箱子的尺寸 - 包裹的尺寸</code> 。<strong>总浪费空间</strong> 为 <strong>所有</strong> 箱子中浪费空间的总和。</p>\n\n<ul>\n\t<li>比方说，如果你想要用尺寸数组为 <code>[4,8]</code> 的箱子装下尺寸为 <code>[2,3,5]</code> 的包裹，你可以将尺寸为 <code>2</code> 和 <code>3</code> 的两个包裹装入两个尺寸为 <code>4</code> 的箱子中，同时把尺寸为 <code>5</code> 的包裹装入尺寸为 <code>8</code> 的箱子中。总浪费空间为 <code>(4-2) + (4-3) + (8-5) = 6</code> 。</li>\n</ul>\n\n<p>请你选择 <strong>最优</strong> 箱子供应商，使得 <strong>总浪费空间最小</strong> 。如果 <strong>无法</strong> 将所有包裹放入箱子中，请你返回 <code>-1</code> 。由于答案可能会 <strong>很大</strong> ，请返回它对<strong> </strong><code>10<sup>9</sup> + 7</code> <b>取余</b> 的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>packages = [2,3,5], boxes = [[4,8],[2,8]]\n<b>输出：</b>6\n<b>解释：</b>选择第一个供应商最优，用两个尺寸为 4 的箱子和一个尺寸为 8 的箱子。\n总浪费空间为 (4-2) + (4-3) + (8-5) = 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>packages = [2,3,5], boxes = [[1,4],[2,3],[3,4]]\n<b>输出：</b>-1\n<b>解释：</b>没有箱子能装下尺寸为 5 的包裹。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>packages = [3,5,8,10,11,12], boxes = [[12],[11,9],[10,5,14]]\n<b>输出：</b>9\n<b>解释：</b>选择第三个供应商最优，用两个尺寸为 5 的箱子，两个尺寸为 10 的箱子和两个尺寸为 14 的箱子。\n总浪费空间为 (5-3) + (5-5) + (10-8) + (10-10) + (14-11) + (14-12) = 9 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == packages.length</code></li>\n\t<li><code>m == boxes.length</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= m <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= packages[i] <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= boxes[j].length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= boxes[j][k] <= 10<sup>5</sup></code></li>\n\t<li><code>sum(boxes[j].length) <= 10<sup>5</sup></code></li>\n\t<li><code>boxes[j]</code> 中的元素 <strong>互不相同</strong> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1890.2020年最后一次登录",
        "hardRate": "EASY",
        "passRate": "69.97%",
        "problemsUrl": "https://leetcode.cn/problems/the-latest-login-in-2020/",
        "solutionsUrl": "https://leetcode.cn/problems/the-latest-login-in-2020/solution",
        "problemsDesc": "<p>表: <code>Logins</code></p>\n\n<pre>\n+----------------+----------+\n| 列名           | 类型      |\n+----------------+----------+\n| user_id        | int      |\n| time_stamp     | datetime |\n+----------------+----------+\n(user_id, time_stamp) 是这个表的主键。\n每一行包含的信息是user_id 这个用户的登录时间。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个 SQL 查询，该查询可以获取在 <code>2020</code> 年登录过的所有用户的本年度 <strong>最后一次 </strong>登录时间。结果集 <strong>不</strong> 包含 <code>2020</code> 年没有登录过的用户。</p>\n\n<p>返回的结果集可以按 <strong>任意顺序 </strong>排列。</p>\n\n<p>查询结果格式如下例。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nLogins 表:\n+---------+---------------------+\n| user_id | time_stamp          |\n+---------+---------------------+\n| 6       | 2020-06-30 15:06:07 |\n| 6       | 2021-04-21 14:06:06 |\n| 6       | 2019-03-07 00:18:15 |\n| 8       | 2020-02-01 05:10:53 |\n| 8       | 2020-12-30 00:46:50 |\n| 2       | 2020-01-16 02:49:50 |\n| 2       | 2019-08-25 07:59:08 |\n| 14      | 2019-07-14 09:00:00 |\n| 14      | 2021-01-06 11:59:59 |\n+---------+---------------------+\n<strong>输出：</strong>\n+---------+---------------------+\n| user_id | last_stamp          |\n+---------+---------------------+\n| 6       | 2020-06-30 15:06:07 |\n| 8       | 2020-12-30 00:46:50 |\n| 2       | 2020-01-16 02:49:50 |\n+---------+---------------------+\n<strong>解释：</strong>\n6号用户登录了3次，但是在2020年仅有一次，所以结果集应包含此次登录。\n8号用户在2020年登录了2次，一次在2月，一次在12月，所以，结果集应该包含12月的这次登录。\n2号用户登录了2次，但是在2020年仅有一次，所以结果集应包含此次登录。\n14号用户在2020年没有登录，所以结果集不应包含。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1891.割绳子",
        "hardRate": "MEDIUM",
        "passRate": "42.13%",
        "problemsUrl": "https://leetcode.cn/problems/cutting-ribbons/",
        "solutionsUrl": "https://leetcode.cn/problems/cutting-ribbons/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1892.页面推荐Ⅱ",
        "hardRate": "HARD",
        "passRate": "37.65%",
        "problemsUrl": "https://leetcode.cn/problems/page-recommendations-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/page-recommendations-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1893.检查是否区域内所有整数都被覆盖",
        "hardRate": "EASY",
        "passRate": "58.86%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-all-the-integers-in-a-range-are-covered/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-all-the-integers-in-a-range-are-covered/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>ranges</code> 和两个整数 <code>left</code> 和 <code>right</code> 。每个 <code>ranges[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 表示一个从 <code>start<sub>i</sub></code> 到 <code>end<sub>i</sub></code> 的 <strong>闭区间</strong> 。</p>\n\n<p>如果闭区间 <code>[left, right]</code> 内每个整数都被 <code>ranges</code> 中 <strong>至少一个</strong> 区间覆盖，那么请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p>已知区间 <code>ranges[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> ，如果整数 <code>x</code> 满足 <code>start<sub>i</sub> <= x <= end<sub>i</sub></code> ，那么我们称整数<code>x</code> 被覆盖了。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5\n<b>输出：</b>true\n<b>解释：</b>2 到 5 的每个整数都被覆盖了：\n- 2 被第一个区间覆盖。\n- 3 和 4 被第二个区间覆盖。\n- 5 被第三个区间覆盖。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>ranges = [[1,10],[10,20]], left = 21, right = 21\n<b>输出：</b>false\n<b>解释：</b>21 没有被任何一个区间覆盖。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= ranges.length <= 50</code></li>\n\t<li><code>1 <= start<sub>i</sub> <= end<sub>i</sub> <= 50</code></li>\n\t<li><code>1 <= left <= right <= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1894.找到需要补充粉笔的学生编号",
        "hardRate": "MEDIUM",
        "passRate": "45.84%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-student-that-will-replace-the-chalk/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-student-that-will-replace-the-chalk/solution",
        "problemsDesc": "<p>一个班级里有&nbsp;<code>n</code>&nbsp;个学生，编号为 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;。每个学生会依次回答问题，编号为 <code>0</code>&nbsp;的学生先回答，然后是编号为 <code>1</code>&nbsp;的学生，以此类推，直到编号为 <code>n - 1</code>&nbsp;的学生，然后老师会重复这个过程，重新从编号为 <code>0</code>&nbsp;的学生开始回答问题。</p>\n\n<p>给你一个长度为 <code>n</code>&nbsp;且下标从 <code>0</code>&nbsp;开始的整数数组&nbsp;<code>chalk</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。一开始粉笔盒里总共有&nbsp;<code>k</code>&nbsp;支粉笔。当编号为&nbsp;<code>i</code>&nbsp;的学生回答问题时，他会消耗 <code>chalk[i]</code>&nbsp;支粉笔。如果剩余粉笔数量 <strong>严格小于</strong>&nbsp;<code>chalk[i]</code>&nbsp;，那么学生 <code>i</code>&nbsp;需要 <strong>补充</strong>&nbsp;粉笔。</p>\n\n<p>请你返回需要 <strong>补充</strong>&nbsp;粉笔的学生 <strong>编号</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>chalk = [5,1,5], k = 22\n<b>输出：</b>0\n<strong>解释：</strong>学生消耗粉笔情况如下：\n- 编号为 0 的学生使用 5 支粉笔，然后 k = 17 。\n- 编号为 1 的学生使用 1 支粉笔，然后 k = 16 。\n- 编号为 2 的学生使用 5 支粉笔，然后 k = 11 。\n- 编号为 0 的学生使用 5 支粉笔，然后 k = 6 。\n- 编号为 1 的学生使用 1 支粉笔，然后 k = 5 。\n- 编号为 2 的学生使用 5 支粉笔，然后 k = 0 。\n编号为 0 的学生没有足够的粉笔，所以他需要补充粉笔。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>chalk = [3,4,1,2], k = 25\n<b>输出：</b>1\n<b>解释：</b>学生消耗粉笔情况如下：\n- 编号为 0 的学生使用 3 支粉笔，然后 k = 22 。\n- 编号为 1 的学生使用 4 支粉笔，然后 k = 18 。\n- 编号为 2 的学生使用 1 支粉笔，然后 k = 17 。\n- 编号为 3 的学生使用 2 支粉笔，然后 k = 15 。\n- 编号为 0 的学生使用 3 支粉笔，然后 k = 12 。\n- 编号为 1 的学生使用 4 支粉笔，然后 k = 8 。\n- 编号为 2 的学生使用 1 支粉笔，然后 k = 7 。\n- 编号为 3 的学生使用 2 支粉笔，然后 k = 5 。\n- 编号为 0 的学生使用 3 支粉笔，然后 k = 2 。\n编号为 1 的学生没有足够的粉笔，所以他需要补充粉笔。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>chalk.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= chalk[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1895.最大的幻方",
        "hardRate": "MEDIUM",
        "passRate": "56.26%",
        "problemsUrl": "https://leetcode.cn/problems/largest-magic-square/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-magic-square/solution",
        "problemsDesc": "<p>一个 <code>k x k</code> 的<strong> 幻方</strong> 指的是一个 <code>k x k</code> 填满整数的方格阵，且每一行、每一列以及两条对角线的和 <strong>全部</strong><strong>相等</strong> 。幻方中的整数 <strong>不需要互不相同</strong> 。显然，每个 <code>1 x 1</code> 的方格都是一个幻方。</p>\n\n<p>给你一个 <code>m x n</code> 的整数矩阵 <code>grid</code> ，请你返回矩阵中 <strong>最大幻方</strong> 的 <strong>尺寸</strong> （即边长 <code>k</code>）。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/29/magicsquare-grid.jpg\" style=\"width: 413px; height: 335px;\">\n<pre><b>输入：</b>grid = [[7,1,4,5,6],[2,5,1,6,4],[1,5,4,3,2],[1,2,7,3,4]]\n<b>输出：</b>3\n<b>解释：</b>最大幻方尺寸为 3 。\n每一行，每一列以及两条对角线的和都等于 12 。\n- 每一行的和：5+1+6 = 5+4+3 = 2+7+3 = 12\n- 每一列的和：5+5+2 = 1+4+7 = 6+3+3 = 12\n- 对角线的和：5+4+3 = 6+4+2 = 12\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/29/magicsquare2-grid.jpg\" style=\"width: 333px; height: 255px;\">\n<pre><b>输入：</b>grid = [[5,1,3,1],[9,3,3,1],[1,3,3,8]]\n<b>输出：</b>2\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1896.反转表达式值的最少操作次数",
        "hardRate": "HARD",
        "passRate": "51.61%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-change-the-final-value-of-expression/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-change-the-final-value-of-expression/solution",
        "problemsDesc": "<p>给你一个 <strong>有效的</strong> 布尔表达式，用字符串 <code>expression</code> 表示。这个字符串包含字符 <code>'1'</code>，<code>'0'</code>，<code>'&amp;'</code>（按位 <strong>与</strong> 运算），<code>'|'</code>（按位 <strong>或</strong> 运算），<code>'('</code> 和 <code>')'</code> 。</p>\n\n<ul>\n\t<li>比方说，<code>\"()1|1\"</code> 和 <code>\"(1)&amp;()\"</code> <strong>不是有效</strong> 布尔表达式。而 <code>\"1\"</code>， <code>\"(((1))|(0))\"</code> 和 <code>\"1|(0&amp;(1))\"</code> 是 <strong>有效</strong> 布尔表达式。</li>\n</ul>\n\n<p>你的目标是将布尔表达式的 <strong>值</strong> <strong>反转 </strong>（也就是将 <code>0</code> 变为 <code>1</code> ，或者将 <code>1</code> 变为 <code>0</code>），请你返回达成目标需要的 <strong>最少操作</strong> 次数。</p>\n\n<ul>\n\t<li>比方说，如果表达式 <code>expression = \"1|1|(0&amp;0)&amp;1\"</code> ，它的 <strong>值</strong> 为 <code>1|1|(0&amp;0)&amp;1 = 1|1|0&amp;1 = 1|0&amp;1 = 1&amp;1 = 1</code> 。我们想要执行操作将 <strong>新的</strong> 表达式的值变成 <code>0</code> 。</li>\n</ul>\n\n<p>可执行的 <strong>操作</strong> 如下：</p>\n\n<ul>\n\t<li>将一个 <code>'1'</code> 变成一个 <code>'0'</code> 。</li>\n\t<li>将一个 <code>'0'</code> 变成一个 <code>'1'</code> 。</li>\n\t<li>将一个 <code>'&amp;'</code> 变成一个 <code>'|'</code> 。</li>\n\t<li>将一个 <code>'|'</code> 变成一个 <code>'&amp;'</code> 。</li>\n</ul>\n\n<p><strong>注意：</strong><code>'&amp;'</code> 的 <strong>运算优先级</strong> 与 <code>'|'</code> <strong>相同</strong> 。计算表达式时，括号优先级 <strong>最高</strong> ，然后按照 <strong>从左到右</strong> 的顺序运算。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>expression = \"1&amp;(0|1)\"\n<b>输出：</b>1\n<b>解释：</b>我们可以将 \"1&amp;(0<strong>|</strong>1)\" 变成 \"1&amp;(0<strong>&amp;</strong>1)\" ，执行的操作为将一个 '|' 变成一个 '&amp;' ，执行了 1 次操作。\n新表达式的值为 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>expression = \"(0&amp;0)&amp;(0&amp;0&amp;0)\"\n<b>输出：</b>3\n<b>解释：</b>我们可以将 \"(0<strong>&amp;0</strong>)<strong>&amp;</strong>(0&amp;0&amp;0)\" 变成 \"(0<strong>|1</strong>)<strong>|</strong>(0&amp;0&amp;0)\" ，执行了 3 次操作。\n新表达式的值为 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>expression = \"(0|(1|0&amp;1))\"\n<b>输出：</b>1\n<b>解释：</b>我们可以将 \"(0|(<strong>1</strong>|0&amp;1))\" 变成 \"(0|(<strong>0</strong>|0&amp;1))\" ，执行了 1 次操作。\n新表达式的值为 0 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= expression.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>expression</code> 只包含 <code>'1'</code>，<code>'0'</code>，<code>'&amp;'</code>，<code>'|'</code>，<code>'('</code> 和 <code>')'</code></li>\n\t<li>所有括号都有与之匹配的对应括号。</li>\n\t<li>不会有空的括号（也就是说 <code>\"()\"</code> 不是 <code>expression</code> 的子字符串）。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1897.重新分配字符使所有字符串都相等",
        "hardRate": "EASY",
        "passRate": "55.25%",
        "problemsUrl": "https://leetcode.cn/problems/redistribute-characters-to-make-all-strings-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/redistribute-characters-to-make-all-strings-equal/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>words</code>（下标 <strong>从 0 开始</strong> 计数）。</p>\n\n<p>在一步操作中，需先选出两个 <strong>不同</strong> 下标 <code>i</code> 和 <code>j</code>，其中 <code>words[i]</code> 是一个非空字符串，接着将 <code>words[i]</code> 中的 <strong>任一</strong> 字符移动到 <code>words[j]</code> 中的 <strong>任一</strong> 位置上。</p>\n\n<p>如果执行任意步操作可以使 <code>words</code> 中的每个字符串都相等，返回 <code>true</code><em> </em>；否则，返回<em> </em><code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"abc\",\"aabc\",\"bc\"]\n<strong>输出：</strong>true\n<strong>解释：</strong>将 <code>words[1] 中的第一个</code> 'a' 移动到<code> words[2] 的最前面。\n使 </code><code>words[1]</code> = \"abc\" 且 words[2] = \"abc\" 。\n所有字符串都等于 \"abc\" ，所以返回 <code>true</code> 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"ab\",\"a\"]\n<strong>输出：</strong>false\n<strong>解释：</strong>执行操作无法使所有字符串都相等。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><code>words[i]</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1898.可移除字符的最大数目",
        "hardRate": "MEDIUM",
        "passRate": "38.08%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-removable-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-removable-characters/solution",
        "problemsDesc": "<p>给你两个字符串 <code>s</code> 和 <code>p</code> ，其中 <code>p</code> 是 <code>s</code> 的一个 <strong>子序列</strong> 。同时，给你一个元素 <strong>互不相同</strong> 且下标 <strong>从 0 开始</strong> 计数的整数数组 <code>removable</code> ，该数组是 <code>s</code> 中下标的一个子集（<code>s</code> 的下标也 <strong>从 0 开始</strong> 计数）。</p>\n\n<p>请你找出一个整数 <code>k</code>（<code>0 <= k <= removable.length</code>），选出 <code>removable</code> 中的 <strong>前</strong> <code>k</code> 个下标，然后从 <code>s</code> 中移除这些下标对应的 <code>k</code> 个字符。整数 <code>k</code> 需满足：在执行完上述步骤后， <code>p</code> 仍然是 <code>s</code> 的一个 <strong>子序列</strong> 。更正式的解释是，对于每个 <code>0 <= i < k</code> ，先标记出位于 <code>s[removable[i]]</code> 的字符，接着移除所有标记过的字符，然后检查 <code>p</code> 是否仍然是 <code>s</code> 的一个子序列。</p>\n\n<p>返回你可以找出的 <strong>最大</strong><em> </em><code>k</code><em> </em>，满足在移除字符后<em> </em><code>p</code><em> </em>仍然是 <code>s</code> 的一个子序列。</p>\n\n<p>字符串的一个 <strong>子序列</strong> 是一个由原字符串生成的新字符串，生成过程中可能会移除原字符串中的一些字符（也可能不移除）但不改变剩余字符之间的相对顺序。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcacb\", p = \"ab\", removable = [3,1,0]\n<strong>输出：</strong>2\n<strong>解释：</strong>在移除下标 3 和 1 对应的字符后，\"a<strong>b</strong>c<strong>a</strong>cb\" 变成 \"accb\" 。\n\"ab\" 是 \"<strong>a</strong>cc<strong>b</strong>\" 的一个子序列。\n如果移除下标 3、1 和 0 对应的字符后，\"<strong>ab</strong>c<strong>a</strong>cb\" 变成 \"ccb\" ，那么 \"ab\" 就不再是 s 的一个子序列。\n因此，最大的 k 是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcbddddd\", p = \"abcd\", removable = [3,2,1,4,5,6]\n<strong>输出：</strong>1\n<strong>解释：</strong>在移除下标 3 对应的字符后，\"abc<strong>b</strong>ddddd\" 变成 \"abcddddd\" 。\n\"abcd\" 是 \"<strong>abcd</strong>dddd\" 的一个子序列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcab\", p = \"abc\", removable = [0,1,2,3,4]\n<strong>输出：</strong>0\n<strong>解释：</strong>如果移除数组 removable 的第一个下标，\"abc\" 就不再是 s 的一个子序列。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= p.length <= s.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= removable.length < s.length</code></li>\n\t<li><code>0 <= removable[i] < s.length</code></li>\n\t<li><code>p</code> 是 <code>s</code> 的一个 <strong>子字符串</strong></li>\n\t<li><code>s</code> 和 <code>p</code> 都由小写英文字母组成</li>\n\t<li><code>removable</code> 中的元素 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1899.合并若干三元组以形成目标三元组",
        "hardRate": "MEDIUM",
        "passRate": "65.41%",
        "problemsUrl": "https://leetcode.cn/problems/merge-triplets-to-form-target-triplet/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-triplets-to-form-target-triplet/solution",
        "problemsDesc": "<p><strong>三元组</strong> 是一个由三个整数组成的数组。给你一个二维整数数组 <code>triplets</code> ，其中 <code>triplets[i] = [a<sub>i</sub>, b<sub>i</sub>, c<sub>i</sub>]</code> 表示第 <code>i</code> 个 <strong>三元组</strong> 。同时，给你一个整数数组 <code>target = [x, y, z]</code> ，表示你想要得到的 <strong>三元组</strong> 。</p>\n\n<p>为了得到 <code>target</code> ，你需要对 <code>triplets</code> 执行下面的操作 <strong>任意次</strong>（可能 <strong>零</strong> 次）：</p>\n\n<ul>\n\t<li>选出两个下标（下标 <strong>从 0 开始</strong> 计数）<code>i</code> 和 <code>j</code>（<code>i != j</code>），并 <strong>更新</strong> <code>triplets[j]</code> 为 <code>[max(a<sub>i</sub>, a<sub>j</sub>), max(b<sub>i</sub>, b<sub>j</sub>), max(c<sub>i</sub>, c<sub>j</sub>)]</code> 。\n\n\t<ul>\n\t\t<li>例如，<code>triplets[i] = [2, 5, 3]</code> 且 <code>triplets[j] = [1, 7, 5]</code>，<code>triplets[j]</code> 将会更新为 <code>[max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5]</code> 。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>如果通过以上操作我们可以使得目标 <strong>三元组</strong> <code>target</code> 成为 <code>triplets</code> 的一个 <strong>元素</strong> ，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>执行下述操作：\n- 选择第一个和最后一个三元组 [<strong>[2,5,3]</strong>,[1,8,4],<strong>[1,7,5]</strong>] 。更新最后一个三元组为 [max(2,1), max(5,7), max(3,5)] = [2,7,5] 。triplets = [[2,5,3],[1,8,4],<strong>[2,7,5]</strong>]\n目标三元组 [2,7,5] 现在是 triplets 的一个元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>triplets = [[1,3,4],[2,5,8]], target = [2,5,8]\n<strong>输出：</strong>true\n<strong>解释：</strong>目标三元组 [2,5,8] 已经是 triplets 的一个元素。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], target = [5,5,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>执行下述操作：\n- 选择第一个和第三个三元组 [<strong>[2,5,3]</strong>,[2,3,4],<strong>[1,2,5]</strong>,[5,2,3]] 。更新第三个三元组为 [max(2,1), max(5,2), max(3,5)] = [2,5,5] 。triplets = [[2,5,3],[2,3,4],<strong>[2,5,5]</strong>,[5,2,3]] 。\n- 选择第三个和第四个三元组 [[2,5,3],[2,3,4],<strong>[2,5,5]</strong>,<strong>[5,2,3]</strong>] 。更新第四个三元组为 [max(2,5), max(5,2), max(5,3)] = [5,5,5] 。triplets = [[2,5,3],[2,3,4],[2,5,5],<strong>[5,5,5]</strong>] 。\n目标三元组 [5,5,5] 现在是 triplets 的一个元素。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>triplets = [[3,4,5],[4,5,6]], target = [3,2,5]\n<strong>输出：</strong>false\n<strong>解释：</strong>无法得到 [3,2,5] ，因为 triplets 不含 2 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= triplets.length <= 10<sup>5</sup></code></li>\n\t<li><code>triplets[i].length == target.length == 3</code></li>\n\t<li><code>1 <= a<sub>i</sub>, b<sub>i</sub>, c<sub>i</sub>, x, y, z <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1900.最佳运动员的比拼回合",
        "hardRate": "HARD",
        "passRate": "45.98%",
        "problemsUrl": "https://leetcode.cn/problems/the-earliest-and-latest-rounds-where-players-compete/",
        "solutionsUrl": "https://leetcode.cn/problems/the-earliest-and-latest-rounds-where-players-compete/solution",
        "problemsDesc": "<p><code>n</code> 名运动员参与一场锦标赛，所有运动员站成一排，并根据 <strong>最开始的</strong> 站位从 <code>1</code> 到 <code>n</code> 编号（运动员 <code>1</code> 是这一排中的第一个运动员，运动员 <code>2</code> 是第二个运动员，依此类推）。</p>\n\n<p>锦标赛由多个回合组成（从回合 <code>1</code> 开始）。每一回合中，这一排从前往后数的第 <code>i</code> 名运动员需要与从后往前数的第 <code>i</code> 名运动员比拼，获胜者将会进入下一回合。如果当前回合中运动员数目为奇数，那么中间那位运动员将轮空晋级下一回合。</p>\n\n<ul>\n\t<li>例如，当前回合中，运动员 <code>1, 2, 4, 6, 7</code> 站成一排\n\n\t<ul>\n\t\t<li>运动员 <code>1</code> 需要和运动员 <code>7</code> 比拼</li>\n\t\t<li>运动员 <code>2</code> 需要和运动员 <code>6</code> 比拼</li>\n\t\t<li>运动员 <code>4</code> 轮空晋级下一回合</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>每回合结束后，获胜者将会基于最开始分配给他们的原始顺序（升序）重新排成一排。</p>\n\n<p>编号为 <code>firstPlayer</code> 和 <code>secondPlayer</code> 的运动员是本场锦标赛中的最佳运动员。在他们开始比拼之前，完全可以战胜任何其他运动员。而任意两个其他运动员进行比拼时，其中任意一个都有获胜的可能，因此你可以 <strong>裁定</strong> 谁是这一回合的获胜者。</p>\n\n<p>给你三个整数 <code>n</code>、<code>firstPlayer</code> 和 <code>secondPlayer</code> 。返回一个由两个值组成的整数数组，分别表示两位最佳运动员在本场锦标赛中比拼的 <strong>最早</strong> 回合数和 <strong>最晚</strong> 回合数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 11, firstPlayer = 2, secondPlayer = 4\n<strong>输出：</strong>[3,4]\n<strong>解释：</strong>\n一种能够产生最早回合数的情景是：\n回合 1：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n回合 2：2, 3, 4, 5, 6, 11\n回合 3：2, 3, 4\n一种能够产生最晚回合数的情景是：\n回合 1：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n回合 2：1, 2, 3, 4, 5, 6\n回合 3：1, 2, 4\n回合 4：2, 4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 5, firstPlayer = 1, secondPlayer = 5\n<strong>输出：</strong>[1,1]\n<strong>解释：</strong>两名最佳运动员 1 和 5 将会在回合 1 进行比拼。\n不存在使他们在其他回合进行比拼的可能。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 28</code></li>\n\t<li><code>1 &lt;= firstPlayer &lt; secondPlayer &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1901.寻找峰值 II",
        "hardRate": "MEDIUM",
        "passRate": "58.93%",
        "problemsUrl": "https://leetcode.cn/problems/find-a-peak-element-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/find-a-peak-element-ii/solution",
        "problemsDesc": "<p>一个 2D 网格中的 <strong>峰值</strong><strong> </strong>是指那些 <strong>严格大于 </strong>其相邻格子(上、下、左、右)的元素。</p>\n\n<p>给你一个<strong> 从 0 开始编号 </strong>的 <code>m x n</code> 矩阵 <code>mat</code> ，其中任意两个相邻格子的值都<strong> 不相同</strong> 。找出 <strong>任意一个 峰值</strong> <code>mat[i][j]</code> 并 <strong>返回其位置 </strong><code>[i,j]</code> 。</p>\n\n<p>你可以假设整个矩阵周边环绕着一圈值为 <code>-1</code> 的格子。</p>\n\n<p>要求必须写出时间复杂度为 <code>O(m log(n))</code> 或 <code>O(n log(m))</code> 的算法</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/08/1.png\" style=\"width: 206px; height: 209px;\" /></p>\n\n<pre>\n<strong>输入:</strong> mat = [[1,4],[3,2]]\n<strong>输出:</strong> [0,1]\n<strong>解释:</strong>&nbsp;3 和 4 都是峰值，所以[1,0]和[0,1]都是可接受的答案。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/07/3.png\" style=\"width: 254px; height: 257px;\" /></strong></p>\n\n<pre>\n<strong>输入:</strong> mat = [[10,20,15],[21,30,14],[7,16,32]]\n<strong>输出:</strong> [1,1]\n<strong>解释:</strong>&nbsp;30 和 32 都是峰值，所以[1,1]和[2,2]都是可接受的答案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>1 &lt;= mat[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li>任意两个相邻元素均不相等.</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1902.给定二叉搜索树的插入顺序求深度",
        "hardRate": "MEDIUM",
        "passRate": "51.10%",
        "problemsUrl": "https://leetcode.cn/problems/depth-of-bst-given-insertion-order/",
        "solutionsUrl": "https://leetcode.cn/problems/depth-of-bst-given-insertion-order/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1903.字符串中的最大奇数",
        "hardRate": "EASY",
        "passRate": "60.46%",
        "problemsUrl": "https://leetcode.cn/problems/largest-odd-number-in-string/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-odd-number-in-string/solution",
        "problemsDesc": "<p>给你一个字符串 <code>num</code> ，表示一个大整数。请你在字符串 <code>num</code> 的所有 <strong>非空子字符串</strong> 中找出 <strong>值最大的奇数</strong> ，并以字符串形式返回。如果不存在奇数，则返回一个空字符串<em> </em><code>\"\"</code><em> </em>。</p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续的字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"52\"\n<strong>输出：</strong>\"5\"\n<strong>解释：</strong>非空子字符串仅有 \"5\"、\"2\" 和 \"52\" 。\"5\" 是其中唯一的奇数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"4206\"\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>在 \"4206\" 中不存在奇数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"35427\"\n<strong>输出：</strong>\"35427\"\n<strong>解释：</strong>\"35427\" 本身就是一个奇数。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= num.length <= 10<sup>5</sup></code></li>\n\t<li><code>num</code> 仅由数字组成且不含前导零</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1904.你完成的完整对局数",
        "hardRate": "MEDIUM",
        "passRate": "31.41%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-full-rounds-you-have-played/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-full-rounds-you-have-played/solution",
        "problemsDesc": "<p>一款新的在线电子游戏在近期发布，在该电子游戏中，以 <strong>刻钟</strong> 为周期规划若干时长为 <strong>15 分钟</strong> 的游戏对局。这意味着，在 <code>HH:00</code>、<code>HH:15</code>、<code>HH:30</code> 和 <code>HH:45</code> ，将会开始一个新的对局，其中 <code>HH</code> 用一个从 <code>00</code> 到 <code>23</code> 的整数表示。游戏中使用 <strong>24 小时制的时钟</strong> ，所以一天中最早的时间是 <code>00:00</code> ，最晚的时间是 <code>23:59</code> 。</p>\n\n<p>给你两个字符串 <code>startTime</code> 和 <code>finishTime</code> ，均符合 <code>\"HH:MM\"</code> 格式，分别表示你 <strong>进入</strong> 和 <strong>退出</strong> 游戏的确切时间，请计算在整个游戏会话期间，你完成的 <strong>完整对局的对局数</strong> 。</p>\n\n<ul>\n\t<li>例如，如果 <code>startTime = \"05:20\"</code> 且 <code>finishTime = \"05:59\"</code> ，这意味着你仅仅完成从 <code>05:30</code> 到 <code>05:45</code> 这一个完整对局。而你没有完成从 <code>05:15</code> 到 <code>05:30</code> 的完整对局，因为你是在对局开始后进入的游戏；同时，你也没有完成从 <code>05:45</code> 到 <code>06:00</code> 的完整对局，因为你是在对局结束前退出的游戏。</li>\n</ul>\n\n<p>如果 <code>finishTime</code> <strong>早于</strong> <code>startTime</code> ，这表示你玩了个通宵（也就是从 <code>startTime</code> 到午夜，再从午夜到 <code>finishTime</code>）。</p>\n\n<p>假设你是从 <code>startTime</code> 进入游戏，并在 <code>finishTime</code> 退出游戏，请计算并返回你完成的 <strong>完整对局的对局数</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>startTime = \"12:01\", finishTime = \"12:44\"\n<strong>输出：</strong>1\n<strong>解释：</strong>你完成了从 12:15 到 12:30 的一个完整对局。\n你没有完成从 12:00 到 12:15 的完整对局，因为你是在对局开始后的 12:01 进入的游戏。\n你没有完成从 12:30 到 12:45 的完整对局，因为你是在对局结束前的 12:44 退出的游戏。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>startTime = \"20:00\", finishTime = \"06:00\"\n<strong>输出：</strong>40\n<strong>解释：</strong>你完成了从 20:00 到 00:00 的 16 个完整的对局，以及从 00:00 到 06:00 的 24 个完整的对局。\n16 + 24 = 40\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>startTime = \"00:00\", finishTime = \"23:59\"\n<strong>输出：</strong>95\n<strong>解释：</strong>除最后一个小时你只完成了 3 个完整对局外，其余每个小时均完成了 4 场完整对局。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>startTime</code> 和 <code>finishTime</code> 的格式为 <code>HH:MM</code></li>\n\t<li><code>00 <= HH <= 23</code></li>\n\t<li><code>00 <= MM <= 59</code></li>\n\t<li><code>startTime</code> 和 <code>finishTime</code> 不相等</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1905.统计子岛屿",
        "hardRate": "MEDIUM",
        "passRate": "67.15%",
        "problemsUrl": "https://leetcode.cn/problems/count-sub-islands/",
        "solutionsUrl": "https://leetcode.cn/problems/count-sub-islands/solution",
        "problemsDesc": "<p>给你两个 <code>m x n</code> 的二进制矩阵 <code>grid1</code> 和 <code>grid2</code> ，它们只包含 <code>0</code> （表示水域）和 <code>1</code> （表示陆地）。一个 <strong>岛屿</strong> 是由 <strong>四个方向</strong> （水平或者竖直）上相邻的 <code>1</code> 组成的区域。任何矩阵以外的区域都视为水域。</p>\n\n<p>如果 <code>grid2</code> 的一个岛屿，被 <code>grid1</code> 的一个岛屿 <strong>完全</strong> 包含，也就是说 <code>grid2</code> 中该岛屿的每一个格子都被 <code>grid1</code> 中同一个岛屿完全包含，那么我们称 <code>grid2</code> 中的这个岛屿为 <strong>子岛屿</strong> 。</p>\n\n<p>请你返回 <code>grid2</code> 中 <strong>子岛屿</strong> 的 <strong>数目</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/10/test1.png\" style=\"width: 493px; height: 205px;\">\n<pre><b>输入：</b>grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]\n<b>输出：</b>3\n<strong>解释：</strong>如上图所示，左边为 grid1 ，右边为 grid2 。\ngrid2 中标红的 1 区域是子岛屿，总共有 3 个子岛屿。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/03/testcasex2.png\" style=\"width: 491px; height: 201px;\">\n<pre><b>输入：</b>grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\n<b>输出：</b>2 \n<strong>解释：</strong>如上图所示，左边为 grid1 ，右边为 grid2 。\ngrid2 中标红的 1 区域是子岛屿，总共有 2 个子岛屿。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid1.length == grid2.length</code></li>\n\t<li><code>n == grid1[i].length == grid2[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>grid1[i][j]</code> 和 <code>grid2[i][j]</code> 都要么是 <code>0</code> 要么是 <code>1</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1906.查询差绝对值的最小值",
        "hardRate": "MEDIUM",
        "passRate": "45.03%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-absolute-difference-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-absolute-difference-queries/solution",
        "problemsDesc": "<p>一个数组 <code>a</code> 的 <strong>差绝对值的最小值</strong> 定义为：<code>0 <= i < j < a.length</code> 且 <code>a[i] != a[j]</code> 的<strong> </strong><code><span style=\"\">|a[i] - a[j]|</span></code> 的 <strong>最小值</strong>。如果 <code>a</code> 中所有元素都 <strong>相同</strong> ，那么差绝对值的最小值为 <code>-1</code> 。</p>\n\n<ul>\n\t<li>比方说，数组 <code>[5,<strong>2</strong>,<strong>3</strong>,7,2]</code> 差绝对值的最小值是 <code>|2 - 3| = 1</code> 。注意答案不为 <code>0</code> ，因为 <code>a[i]</code> 和 <code>a[j]</code> 必须不相等。</li>\n</ul>\n\n<p>给你一个整数数组 <code>nums</code> 和查询数组 <code>queries</code> ，其中 <code>queries[i] = [l<sub>i</sub>, r<sub>i</sub>]</code> 。对于每个查询 <code>i</code> ，计算 <strong>子数组</strong> <code>nums[l<sub>i</sub>...r<sub>i</sub>]</code> 中 <strong>差绝对值的最小值</strong> ，子数组 <code>nums[l<sub>i</sub>...r<sub>i</sub>]</code> 包含 <code>nums</code> 数组（下标从 <strong>0</strong> 开始）中下标在 <code>l<sub>i</sub></code> 和 <code>r<sub>i</sub></code> 之间的所有元素（包含 <code>l<sub>i</sub></code> 和 <code>r<sub>i</sub></code> 在内）。</p>\n\n<p>请你返回 <code>ans</code> <strong>数组</strong>，其中 <code>ans[i]</code> 是第 <code>i</code> 个查询的答案。</p>\n\n<p><strong>子数组</strong> 是一个数组中连续的一段元素。</p>\n\n<p><code>|x|</code> 的值定义为：</p>\n\n<ul>\n\t<li>如果 <code>x >= 0</code> ，那么值为 <code>x</code> 。</li>\n\t<li>如果 <code>x < 0</code> ，那么值为 <code>-x</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,3,4,8], queries = [[0,1],[1,2],[2,3],[0,3]]\n<b>输出：</b>[2,1,4,1]\n<b>解释：</b>查询结果如下：\n- queries[0] = [0,1]：子数组是 [<strong>1</strong>,<strong>3</strong>] ，差绝对值的最小值为 |1-3| = 2 。\n- queries[1] = [1,2]：子数组是 [<strong>3</strong>,<strong>4</strong>] ，差绝对值的最小值为 |3-4| = 1 。\n- queries[2] = [2,3]：子数组是 [<strong>4</strong>,<strong>8</strong>] ，差绝对值的最小值为 |4-8| = 4 。\n- queries[3] = [0,3]：子数组是 [1,<strong>3</strong>,<strong>4</strong>,8] ，差的绝对值的最小值为 |3-4| = 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [4,5,2,2,7,10], queries = [[2,3],[0,2],[0,5],[3,5]]\n<b>输出：</b>[-1,1,1,3]\n<strong>解释：</strong>查询结果如下：\n- queries[0] = [2,3]：子数组是 [2,2] ，差绝对值的最小值为 -1 ，因为所有元素相等。\n- queries[1] = [0,2]：子数组是 [<strong>4</strong>,<strong>5</strong>,2] ，差绝对值的最小值为 |4-5| = 1 。\n- queries[2] = [0,5]：子数组是 [<strong>4</strong>,<strong>5</strong>,2,2,7,10] ，差绝对值的最小值为 |4-5| = 1 。\n- queries[3] = [3,5]：子数组是 [2,<strong>7</strong>,<strong>10</strong>] ，差绝对值的最小值为 |7-10| = 3 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 100</code></li>\n\t<li><code>1 <= queries.length <= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 <= l<sub>i</sub> < r<sub>i</sub> < nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1907.按分类统计薪水",
        "hardRate": "MEDIUM",
        "passRate": "63.62%",
        "problemsUrl": "https://leetcode.cn/problems/count-salary-categories/",
        "solutionsUrl": "https://leetcode.cn/problems/count-salary-categories/solution",
        "problemsDesc": "<p>表: <code>Accounts</code></p>\n\n<pre>\n+-------------+------+\n| 列名        | 类型  |\n+-------------+------+\n| account_id  | int  |\n| income      | int  |\n+-------------+------+\naccount_id&nbsp;是这个表的主键。\n每一行都包含一个银行帐户的月收入的信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写出一个&nbsp;SQL&nbsp;查询，来报告每个工资类别的银行账户数量。&nbsp;工资类别如下：</p>\n\n<ul>\n\t<li><code>\"Low Salary\"</code>：所有工资 <strong>严格低于</strong> <code>20000</code> 美元。</li>\n\t<li><code>\"Average Salary\"</code>： <strong>包含</strong> 范围内的所有工资&nbsp;<code>[$20000,&nbsp;$50000]</code> 。</li>\n\t<li>\n\t<p><code>\"High Salary\"</code>：所有工资 <strong>严格大于</strong> <code>50000</code> 美元。</p>\n\t</li>\n</ul>\n\n<p>结果表 <strong>必须</strong> 包含所有三个类别。&nbsp;如果某个类别中没有帐户，则报告&nbsp;<code>0</code> 。</p>\n\n<p>按 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式如下示例。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>\nAccounts 表:\n+------------+--------+\n| account_id | income |\n+------------+--------+\n| 3          | 108939 |\n| 2          | 12747  |\n| 8          | 87709  |\n| 6          | 91796  |\n+------------+--------+\n<strong>输出：</strong>\n+----------------+----------------+\n| category       | accounts_count |\n+----------------+----------------+\n| Low Salary     | 1              |\n| Average Salary | 0              |\n| High Salary    | 3              |\n+----------------+----------------+\n<strong>解释：</strong>\n低薪: 数量为 2.\n中等薪水: 没有.\n高薪: 有三个账户，他们是 3, 6和 8.</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1908.Nim 游戏 II",
        "hardRate": "MEDIUM",
        "passRate": "62.45%",
        "problemsUrl": "https://leetcode.cn/problems/game-of-nim/",
        "solutionsUrl": "https://leetcode.cn/problems/game-of-nim/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1909.删除一个元素使数组严格递增",
        "hardRate": "EASY",
        "passRate": "29.98%",
        "problemsUrl": "https://leetcode.cn/problems/remove-one-element-to-make-the-array-strictly-increasing/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-one-element-to-make-the-array-strictly-increasing/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，如果 <strong>恰好</strong> 删除 <strong>一个</strong> 元素后，数组 <strong>严格递增</strong> ，那么请你返回 <code>true</code> ，否则返回 <code>false</code> 。如果数组本身已经是严格递增的，请你也返回 <code>true</code> 。</p>\n\n<p>数组 <code>nums</code> 是 <strong>严格递增</strong> 的定义为：对于任意下标的 <code>1 &lt;= i &lt; nums.length</code> 都满足 <code>nums[i - 1] &lt; nums[i]</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,<strong>10</strong>,5,7]\n<b>输出：</b>true\n<b>解释：</b>从 nums 中删除下标 2 处的 10 ，得到 [1,2,5,7] 。\n[1,2,5,7] 是严格递增的，所以返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,3,1,2]\n<b>输出：</b>false\n<b>解释：</b>\n[3,1,2] 是删除下标 0 处元素后得到的结果。\n[2,1,2] 是删除下标 1 处元素后得到的结果。\n[2,3,2] 是删除下标 2 处元素后得到的结果。\n[2,3,1] 是删除下标 3 处元素后得到的结果。\n没有任何结果数组是严格递增的，所以返回 false 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [1,1,1]\n<b>输出：</b>false\n<b>解释：</b>删除任意元素后的结果都是 [1,1] 。\n[1,1] 不是严格递增的，所以返回 false 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3]\n<b>输出：</b>true\n<b>解释：</b>[1,2,3] 已经是严格递增的，所以返回 true 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1910.删除一个字符串中所有出现的给定子字符串",
        "hardRate": "MEDIUM",
        "passRate": "66.42%",
        "problemsUrl": "https://leetcode.cn/problems/remove-all-occurrences-of-a-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-all-occurrences-of-a-substring/solution",
        "problemsDesc": "<p>给你两个字符串 <code>s</code> 和 <code>part</code> ，请你对 <code>s</code> 反复执行以下操作直到 <b>所有</b> 子字符串 <code>part</code> 都被删除：</p>\n\n<ul>\n\t<li>找到 <code>s</code> 中 <strong>最左边</strong> 的子字符串 <code>part</code> ，并将它从 <code>s</code> 中删除。</li>\n</ul>\n\n<p>请你返回从 <code>s</code> 中删除所有 <code>part</code> 子字符串以后得到的剩余字符串。</p>\n\n<p>一个 <strong>子字符串</strong> 是一个字符串中连续的字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"daabcbaabcbc\", part = \"abc\"\n<b>输出：</b>\"dab\"\n<b>解释：</b>以下操作按顺序执行：\n- s = \"da<strong>abc</strong>baabcbc\" ，删除下标从 2 开始的 \"abc\" ，得到 s = \"dabaabcbc\" 。\n- s = \"daba<strong>abc</strong>bc\" ，删除下标从 4 开始的 \"abc\" ，得到 s = \"dababc\" 。\n- s = \"dab<strong>abc</strong>\" ，删除下标从 3 开始的 \"abc\" ，得到 s = \"dab\" 。\n此时 s 中不再含有子字符串 \"abc\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"axxxxyyyyb\", part = \"xy\"\n<b>输出：</b>\"ab\"\n<b>解释：</b>以下操作按顺序执行：\n- s = \"axxx<strong>xy</strong>yyyb\" ，删除下标从 4 开始的 \"xy\" ，得到 s = \"axxxyyyb\" 。\n- s = \"axx<strong>xy</strong>yyb\" ，删除下标从 3 开始的 \"xy\" ，得到 s = \"axxyyb\" 。\n- s = \"ax<strong>xy</strong>yb\" ，删除下标从 2 开始的 \"xy\" ，得到 s = \"axyb\" 。\n- s = \"a<strong>xy</strong>b\" ，删除下标从 1 开始的 \"xy\" ，得到 s = \"ab\" 。\n此时 s 中不再含有子字符串 \"xy\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= part.length &lt;= 1000</code></li>\n\t<li><code>s</code>​​​​​​ 和 <code>part</code> 只包小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1911.最大子序列交替和",
        "hardRate": "MEDIUM",
        "passRate": "66.48%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-alternating-subsequence-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-alternating-subsequence-sum/solution",
        "problemsDesc": "<p>一个下标从 <strong>0</strong> 开始的数组的 <strong>交替和</strong> 定义为 <strong>偶数</strong> 下标处元素之 <strong>和</strong> 减去 <strong>奇数</strong> 下标处元素之 <strong>和</strong> 。</p>\n\n<ul>\n\t<li>比方说，数组 <code>[4,2,5,3]</code> 的交替和为 <code>(4 + 5) - (2 + 3) = 4</code> 。</li>\n</ul>\n\n<p>给你一个数组 <code>nums</code> ，请你返回 <code>nums</code> 中任意子序列的 <strong>最大交替和</strong> （子序列的下标 <strong>重新</strong> 从 0 开始编号）。</p>\n\n<ul>\n</ul>\n\n<p>一个数组的 <strong>子序列</strong> 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。比方说，<code>[2,7,4]</code> 是 <code>[4,<strong>2</strong>,3,<strong>7</strong>,2,1,<strong>4</strong>]</code> 的一个子序列（加粗元素），但是 <code>[2,4,2]</code> 不是。</p>\n\n<p> </p>\n\n<p><b>示例 1：</b></p>\n\n<pre><b>输入：</b>nums = [<strong>4</strong>,<strong>2</strong>,<strong>5</strong>,3]\n<b>输出：</b>7\n<b>解释：</b>最优子序列为 [4,2,5] ，交替和为 (4 + 5) - 2 = 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [5,6,7,<strong>8</strong>]\n<b>输出：</b>8\n<b>解释：</b>最优子序列为 [8] ，交替和为 8 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [<strong>6</strong>,2,<strong>1</strong>,2,4,<strong>5</strong>]\n<b>输出：</b>10\n<b>解释：</b>最优子序列为 [6,1,5] ，交替和为 (6 + 5) - 1 = 10 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1912.设计电影租借系统",
        "hardRate": "HARD",
        "passRate": "24.15%",
        "problemsUrl": "https://leetcode.cn/problems/design-movie-rental-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-movie-rental-system/solution",
        "problemsDesc": "<p>你有一个电影租借公司和 <code>n</code> 个电影商店。你想要实现一个电影租借系统，它支持查询、预订和返还电影的操作。同时系统还能生成一份当前被借出电影的报告。</p>\n\n<p>所有电影用二维整数数组 <code>entries</code> 表示，其中 <code>entries[i] = [shop<sub>i</sub>, movie<sub>i</sub>, price<sub>i</sub>]</code> 表示商店 <code>shop<sub>i</sub></code> 有一份电影 <code>movie<sub>i</sub></code> 的拷贝，租借价格为 <code>price<sub>i</sub></code> 。每个商店有 <strong>至多一份</strong> 编号为 <code>movie<sub>i</sub></code> 的电影拷贝。</p>\n\n<p>系统需要支持以下操作：</p>\n\n<ul>\n\t<li><strong>Search：</strong>找到拥有指定电影且 <strong>未借出</strong> 的商店中 <strong>最便宜的 5 个</strong> 。商店需要按照 <strong>价格</strong> 升序排序，如果价格相同，则 <code>shop<sub>i</sub></code> <strong>较小</strong> 的商店排在前面。如果查询结果少于 5 个商店，则将它们全部返回。如果查询结果没有任何商店，则返回空列表。</li>\n\t<li><strong>Rent：</strong>从指定商店借出指定电影，题目保证指定电影在指定商店 <strong>未借出</strong> 。</li>\n\t<li><strong>Drop：</strong>在指定商店返还 <strong>之前已借出</strong> 的指定电影。</li>\n\t<li><strong>Report：</strong>返回 <strong>最便宜的 5 部已借出电影</strong> （可能有重复的电影 ID），将结果用二维列表 <code>res</code> 返回，其中 <code>res[j] = [shop<sub>j</sub>, movie<sub>j</sub>]</code> 表示第 <code>j</code> 便宜的已借出电影是从商店 <code>shop<sub>j</sub></code> 借出的电影 <code>movie<sub>j</sub></code> 。<code>res</code> 中的电影需要按 <strong>价格</strong> 升序排序；如果价格相同，则<strong> </strong><code>shop<sub>j</sub></code> <strong>较小</strong> 的排在前面；如果仍然相同，则 <code>movie<sub>j</sub></code> <strong>较小 </strong>的排在前面。如果当前借出的电影小于 5 部，则将它们全部返回。如果当前没有借出电影，则返回一个空的列表。</li>\n</ul>\n\n<p>请你实现 <code>MovieRentingSystem</code> 类：</p>\n\n<ul>\n\t<li><code>MovieRentingSystem(int n, int[][] entries)</code> 将 <code>MovieRentingSystem</code> 对象用 <code>n</code> 个商店和 <code>entries</code> 表示的电影列表初始化。</li>\n\t<li><code>List&lt;Integer&gt; search(int movie)</code> 如上所述，返回 <strong>未借出</strong> 指定 <code>movie</code> 的商店列表。</li>\n\t<li><code>void rent(int shop, int movie)</code> 从指定商店 <code>shop</code> 借出指定电影 <code>movie</code> 。</li>\n\t<li><code>void drop(int shop, int movie)</code> 在指定商店 <code>shop</code> 返还之前借出的电影 <code>movie</code> 。</li>\n\t<li><code>List&lt;List&lt;Integer&gt;&gt; report()</code> 如上所述，返回最便宜的 <strong>已借出</strong> 电影列表。</li>\n</ul>\n\n<p><strong>注意：</strong>测试数据保证 <code>rent</code> 操作中指定商店拥有 <strong>未借出 </strong>的指定电影，且 <code>drop</code> 操作指定的商店 <strong>之前已借出</strong> 指定电影。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"MovieRentingSystem\", \"search\", \"rent\", \"rent\", \"report\", \"drop\", \"search\"]\n[[3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]], [1], [0, 1], [1, 2], [], [1, 2], [2]]\n<strong>输出：</strong>\n[null, [1, 0, 2], null, null, [[0, 1], [1, 2]], null, [0, 1]]\n\n<strong>解释：</strong>\nMovieRentingSystem movieRentingSystem = new MovieRentingSystem(3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]);\nmovieRentingSystem.search(1);  // 返回 [1, 0, 2] ，商店 1，0 和 2 有未借出的 ID 为 1 的电影。商店 1 最便宜，商店 0 和 2 价格相同，所以按商店编号排序。\nmovieRentingSystem.rent(0, 1); // 从商店 0 借出电影 1 。现在商店 0 未借出电影编号为 [2,3] 。\nmovieRentingSystem.rent(1, 2); // 从商店 1 借出电影 2 。现在商店 1 未借出的电影编号为 [1] 。\nmovieRentingSystem.report();   // 返回 [[0, 1], [1, 2]] 。商店 0 借出的电影 1 最便宜，然后是商店 1 借出的电影 2 。\nmovieRentingSystem.drop(1, 2); // 在商店 1 返还电影 2 。现在商店 1 未借出的电影编号为 [1,2] 。\nmovieRentingSystem.search(2);  // 返回 [0, 1] 。商店 0 和 1 有未借出的 ID 为 2 的电影。商店 0 最便宜，然后是商店 1 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 3 * 10<sup>5</sup></code></li>\n\t<li><code>1 <= entries.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= shop<sub>i</sub> < n</code></li>\n\t<li><code>1 <= movie<sub>i</sub>, price<sub>i</sub> <= 10<sup>4</sup></code></li>\n\t<li>每个商店 <strong>至多</strong> 有一份电影 <code>movie<sub>i</sub></code> 的拷贝。</li>\n\t<li><code>search</code>，<code>rent</code>，<code>drop</code> 和 <code>report</code> 的调用 <strong>总共</strong> 不超过 <code>10<sup>5</sup></code> 次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1913.两个数对之间的最大乘积差",
        "hardRate": "EASY",
        "passRate": "81.41%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-product-difference-between-two-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-product-difference-between-two-pairs/solution",
        "problemsDesc": "<p>两个数对 <code>(a, b)</code> 和 <code>(c, d)</code> 之间的 <strong>乘积差</strong> 定义为 <code>(a * b) - (c * d)</code> 。</p>\n\n<ul>\n\t<li>例如，<code>(5, 6)</code> 和 <code>(2, 7)</code> 之间的乘积差是 <code>(5 * 6) - (2 * 7) = 16</code> 。</li>\n</ul>\n\n<p>给你一个整数数组 <code>nums</code> ，选出四个 <strong>不同的</strong> 下标 <code>w</code>、<code>x</code>、<code>y</code> 和 <code>z</code> ，使数对 <code>(nums[w], nums[x])</code> 和 <code>(nums[y], nums[z])</code> 之间的 <strong>乘积差</strong> 取到 <strong>最大值</strong> 。</p>\n\n<p>返回以这种方式取得的乘积差中的 <strong>最大值</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,6,2,7,4]\n<strong>输出：</strong>34\n<strong>解释：</strong>可以选出下标为 1 和 3 的元素构成第一个数对 (6, 7) 以及下标 2 和 4 构成第二个数对 (2, 4)\n乘积差是 (6 * 7) - (2 * 4) = 34\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,2,5,9,7,4,8]\n<strong>输出：</strong>64\n<strong>解释：</strong>可以选出下标为 3 和 6 的元素构成第一个数对 (9, 8) 以及下标 1 和 5 构成第二个数对 (2, 4)\n乘积差是 (9 * 8) - (2 * 4) = 64\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>4 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1914.循环轮转矩阵",
        "hardRate": "MEDIUM",
        "passRate": "46.55%",
        "problemsUrl": "https://leetcode.cn/problems/cyclically-rotating-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/cyclically-rotating-a-grid/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的整数矩阵 <code>grid</code>​​​ ，其中 <code>m</code> 和 <code>n</code> 都是 <strong>偶数</strong> ；另给你一个整数 <code>k</code> 。</p>\n\n<p>矩阵由若干层组成，如下图所示，每种颜色代表一层：</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/10/ringofgrid.png\" style=\"width: 231px; height: 258px;\"></p>\n\n<p>矩阵的循环轮转是通过分别循环轮转矩阵中的每一层完成的。在对某一层进行一次循环旋转操作时，层中的每一个元素将会取代其 <strong>逆时针 </strong>方向的相邻元素。轮转示例如下：</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/22/explanation_grid.jpg\" style=\"width: 500px; height: 268px;\">\n<p>返回执行 <code>k</code> 次循环轮转操作后的矩阵。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/19/rod2.png\" style=\"width: 421px; height: 191px;\">\n<pre><strong>输入：</strong>grid = [[40,10],[30,20]], k = 1\n<strong>输出：</strong>[[10,20],[40,30]]\n<strong>解释：</strong>上图展示了矩阵在执行循环轮转操作时每一步的状态。</pre>\n\n<p><strong>示例 2：</strong></p>\n<strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/10/ringofgrid5.png\" style=\"width: 231px; height: 262px;\"></strong> <strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/10/ringofgrid6.png\" style=\"width: 231px; height: 262px;\"></strong> <strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/10/ringofgrid7.png\" style=\"width: 231px; height: 262px;\"></strong>\n\n<pre><strong>输入：</strong>grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2\n<strong>输出：</strong>[[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]]\n<strong>解释：</strong>上图展示了矩阵在执行循环轮转操作时每一步的状态。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>m</code> 和 <code>n</code> 都是 <strong>偶数</strong></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;=<sup> </sup>5000</code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1915.最美子字符串的数目",
        "hardRate": "MEDIUM",
        "passRate": "44.63%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-wonderful-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-wonderful-substrings/solution",
        "problemsDesc": "<p>如果某个字符串中 <strong>至多一个</strong> 字母出现 <strong>奇数</strong> 次，则称其为 <strong>最美</strong> 字符串。</p>\n\n<ul>\n\t<li>例如，<code>\"ccjjc\"</code> 和 <code>\"abab\"</code> 都是最美字符串，但 <code>\"ab\"</code> 不是。</li>\n</ul>\n\n<p>给你一个字符串 <code>word</code> ，该字符串由前十个小写英文字母组成（<code>'a'</code> 到 <code>'j'</code>）。请你返回 <code>word</code> 中 <strong>最美非空子字符串</strong> 的数目<em>。</em>如果同样的子字符串在<em> </em><code>word</code> 中出现多次，那么应当对 <strong>每次出现</strong> 分别计数<em>。</em></p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"aba\"\n<strong>输出：</strong>4\n<strong>解释：</strong>4 个最美子字符串如下所示：\n- \"<strong>a</strong>ba\" -> \"a\"\n- \"a<strong>b</strong>a\" -> \"b\"\n- \"ab<strong>a</strong>\" -> \"a\"\n- \"<strong>aba</strong>\" -> \"aba\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"aabb\"\n<strong>输出：</strong>9\n<strong>解释：</strong>9 个最美子字符串如下所示：\n- \"<strong>a</strong>abb\" -> \"a\"\n- \"<strong>aa</strong>bb\" -> \"aa\"\n- \"<strong>aab</strong>b\" -> \"aab\"\n- \"<strong>aabb</strong>\" -> \"aabb\"\n- \"a<strong>a</strong>bb\" -> \"a\"\n- \"a<strong>abb</strong>\" -> \"abb\"\n- \"aa<strong>b</strong>b\" -> \"b\"\n- \"aa<strong>bb</strong>\" -> \"bb\"\n- \"aab<strong>b</strong>\" -> \"b\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"he\"\n<strong>输出：</strong>2\n<strong>解释：</strong>2 个最美子字符串如下所示：\n- \"<b>h</b>e\" -> \"h\"\n- \"h<strong>e</strong>\" -> \"e\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word.length <= 10<sup>5</sup></code></li>\n\t<li><code>word</code> 由从 <code>'a'</code> 到 <code>'j'</code> 的小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1916.统计为蚁群构筑房间的不同顺序",
        "hardRate": "HARD",
        "passRate": "55.62%",
        "problemsUrl": "https://leetcode.cn/problems/count-ways-to-build-rooms-in-an-ant-colony/",
        "solutionsUrl": "https://leetcode.cn/problems/count-ways-to-build-rooms-in-an-ant-colony/solution",
        "problemsDesc": "<p>你是一只蚂蚁，负责为蚁群构筑 <code>n</code> 间编号从 <code>0</code> 到 <code>n-1</code> 的新房间。给你一个 <strong>下标从 0 开始</strong> 且长度为 <code>n</code> 的整数数组&nbsp;<code>prevRoom</code> 作为扩建计划。其中，<code>prevRoom[i]</code> 表示在构筑房间 <code>i</code> 之前，你必须先构筑房间 <code>prevRoom[i]</code> ，并且这两个房间必须 <strong>直接</strong> 相连。房间 <code>0</code> 已经构筑完成，所以 <code>prevRoom[0] = -1</code> 。扩建计划中还有一条硬性要求，在完成所有房间的构筑之后，从房间 <code>0</code> 可以访问到每个房间。</p>\n\n<p>你一次只能构筑 <strong>一个</strong> 房间。你可以在 <strong>已经构筑好的</strong> 房间之间自由穿行，只要这些房间是 <strong>相连的</strong> 。如果房间&nbsp;<code>prevRoom[i]</code> 已经构筑完成，那么你就可以构筑房间 <code>i</code>。</p>\n\n<p>返回你构筑所有房间的 <strong>不同顺序的数目</strong> 。由于答案可能很大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/19/d1.JPG\" style=\"width: 200px; height: 212px;\" />\n<pre>\n<strong>输入：</strong><code>prevRoom</code> = [-1,0,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>仅有一种方案可以完成所有房间的构筑：0 → 1 → 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/19/d2.JPG\" style=\"width: 200px; height: 239px;\" /></strong>\n\n<pre>\n<strong>输入：</strong><code>prevRoom</code> = [-1,0,0,1,2]\n<strong>输出：</strong>6\n<strong>解释：\n</strong>有 6 种不同顺序：\n0 → 1 → 3 → 2 → 4\n0 → 2 → 4 → 1 → 3\n0 → 1 → 2 → 3 → 4\n0 → 1 → 2 → 4 → 3\n0 → 2 → 1 → 3 → 4\n0 → 2 → 1 → 4 → 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == prevRoom.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>prevRoom[0] == -1</code></li>\n\t<li>对于所有的&nbsp;<code>1 &lt;= i &lt; n</code>&nbsp;，都有&nbsp;<code>0 &lt;= prevRoom[i] &lt; n</code></li>\n\t<li>题目保证所有房间都构筑完成后，从房间 <code>0</code> 可以访问到每个房间</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1917.Leetcodify 好友推荐",
        "hardRate": "HARD",
        "passRate": "31.61%",
        "problemsUrl": "https://leetcode.cn/problems/leetcodify-friends-recommendations/",
        "solutionsUrl": "https://leetcode.cn/problems/leetcodify-friends-recommendations/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1918.第 K 小的子数组和·",
        "hardRate": "MEDIUM",
        "passRate": "48.07%",
        "problemsUrl": "https://leetcode.cn/problems/kth-smallest-subarray-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-smallest-subarray-sum/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1919.兴趣相同的朋友",
        "hardRate": "HARD",
        "passRate": "43.39%",
        "problemsUrl": "https://leetcode.cn/problems/leetcodify-similar-friends/",
        "solutionsUrl": "https://leetcode.cn/problems/leetcodify-similar-friends/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1920.基于排列构建数组",
        "hardRate": "EASY",
        "passRate": "86.61%",
        "problemsUrl": "https://leetcode.cn/problems/build-array-from-permutation/",
        "solutionsUrl": "https://leetcode.cn/problems/build-array-from-permutation/solution",
        "problemsDesc": "<p>给你一个 <strong>从 0 开始的排列</strong> <code>nums</code>（<strong>下标也从 0 开始</strong>）。请你构建一个 <strong>同样长度</strong> 的数组 <code>ans</code> ，其中，对于每个 <code>i</code>（<code>0 &lt;= i &lt; nums.length</code>），都满足 <code>ans[i] = nums[nums[i]]</code> 。返回构建好的数组 <code>ans</code> 。</p>\n\n<p><strong>从 0 开始的排列</strong> <code>nums</code> 是一个由 <code>0</code> 到 <code>nums.length - 1</code>（<code>0</code> 和 <code>nums.length - 1</code> 也包含在内）的不同整数组成的数组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,2,1,5,3,4]\n<strong>输出：</strong>[0,1,2,4,5,3]<strong>\n解释：</strong>数组 ans 构建如下：\nans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n    = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]]\n    = [0,1,2,4,5,3]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,0,1,2,3,4]\n<strong>输出：</strong>[4,5,0,1,2,3]\n<strong>解释：</strong>数组 ans 构建如下：\nans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n    = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]]\n    = [4,5,0,1,2,3]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt; nums.length</code></li>\n\t<li><code>nums</code> 中的元素 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1921.消灭怪物的最大数量",
        "hardRate": "MEDIUM",
        "passRate": "37.02%",
        "problemsUrl": "https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/",
        "solutionsUrl": "https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/solution",
        "problemsDesc": "<p>你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。给你一个 <strong>下标从 0 开始</strong> 且长度为 <code>n</code> 的整数数组 <code>dist</code> ，其中 <code>dist[i]</code> 是第 <code>i</code> 个怪物与城市的 <strong>初始距离</strong>（单位：米）。</p>\n\n<p>怪物以 <strong>恒定</strong> 的速度走向城市。给你一个长度为 <code>n</code> 的整数数组 <code>speed</code> 表示每个怪物的速度，其中 <code>speed[i]</code> 是第 <code>i</code> 个怪物的速度（单位：米/分）。</p>\n\n<p>怪物从 <strong>第 0 分钟</strong> 时开始移动。你有一把武器，并可以 <strong>选择</strong> 在每一分钟的开始时使用，包括第 0 分钟。但是你无法在一分钟的中间使用武器。这种武器威力惊人，一次可以消灭任一还活着的怪物。</p>\n\n<p>一旦任一怪物到达城市，你就输掉了这场游戏。如果某个怪物 <strong>恰</strong> 在某一分钟开始时到达城市，这会被视为<strong> 输掉</strong> 游戏，在你可以使用武器之前，游戏就会结束。</p>\n\n<p>返回在你输掉游戏前可以消灭的怪物的 <strong>最大</strong> 数量。如果你可以在所有怪物到达城市前将它们全部消灭，返回  <code>n</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [1,3,4], speed = [1,1,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n第 0 分钟开始时，怪物的距离是 [1,3,4]，你消灭了第一个怪物。\n第 1 分钟开始时，怪物的距离是 [X,2,3]，你没有消灭任何怪物。\n第 2 分钟开始时，怪物的距离是 [X,1,2]，你消灭了第二个怪物。\n第 3 分钟开始时，怪物的距离是 [X,X,1]，你消灭了第三个怪物。\n所有 3 个怪物都可以被消灭。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [1,1,2,3], speed = [1,1,1,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n第 0 分钟开始时，怪物的距离是 [1,1,2,3]，你消灭了第一个怪物。\n第 1 分钟开始时，怪物的距离是 [X,0,1,2]，你输掉了游戏。\n你只能消灭 1 个怪物。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [3,2,4], speed = [5,3,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n第 0 分钟开始时，怪物的距离是 [3,2,4]，你消灭了第一个怪物。\n第 1 分钟开始时，怪物的距离是 [X,0,2]，你输掉了游戏。 \n你只能消灭 1 个怪物。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == dist.length == speed.length</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= dist[i], speed[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1922.统计好数字的数目",
        "hardRate": "MEDIUM",
        "passRate": "36.21%",
        "problemsUrl": "https://leetcode.cn/problems/count-good-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/count-good-numbers/solution",
        "problemsDesc": "<p>我们称一个数字字符串是 <strong>好数字</strong> 当它满足（下标从 <strong>0</strong> 开始）<strong>偶数</strong> 下标处的数字为 <strong>偶数</strong> 且 <strong>奇数</strong> 下标处的数字为 <strong>质数</strong> （<code>2</code>，<code>3</code>，<code>5</code> 或 <code>7</code>）。</p>\n\n<ul>\n\t<li>比方说，<code>\"2582\"</code> 是好数字，因为偶数下标处的数字（<code>2</code> 和 <code>8</code>）是偶数且奇数下标处的数字（<code>5</code> 和 <code>2</code>）为质数。但 <code>\"3245\"</code> <strong>不是</strong> 好数字，因为 <code>3</code> 在偶数下标处但不是偶数。</li>\n</ul>\n\n<p>给你一个整数 <code>n</code> ，请你返回长度为 <code>n</code> 且为好数字的数字字符串 <strong>总数</strong> 。由于答案可能会很大，请你将它对<strong> </strong><code>10<sup>9</sup> + 7</code> <strong>取余后返回</strong> 。</p>\n\n<p>一个 <strong>数字字符串</strong> 是每一位都由 <code>0</code> 到 <code>9</code> 组成的字符串，且可能包含前导 0 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 1\n<b>输出：</b>5\n<b>解释：</b>长度为 1 的好数字包括 \"0\"，\"2\"，\"4\"，\"6\"，\"8\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 4\n<b>输出：</b>400\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 50\n<b>输出：</b>564908303\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 10<sup>15</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1923.最长公共子路径",
        "hardRate": "HARD",
        "passRate": "26.80%",
        "problemsUrl": "https://leetcode.cn/problems/longest-common-subpath/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-common-subpath/solution",
        "problemsDesc": "<p>一个国家由 <code>n</code> 个编号为 <code>0</code> 到 <code>n - 1</code> 的城市组成。在这个国家里，<strong>每两个</strong> 城市之间都有一条道路连接。</p>\n\n<p>总共有 <code>m</code> 个编号为 <code>0</code> 到 <code>m - 1</code> 的朋友想在这个国家旅游。他们每一个人的路径都会包含一些城市。每条路径都由一个整数数组表示，每个整数数组表示一个朋友按顺序访问过的城市序列。同一个城市在一条路径中可能 <strong>重复</strong> 出现，但同一个城市在一条路径中不会连续出现。</p>\n\n<p>给你一个整数 <code>n</code> 和二维数组 <code>paths</code> ，其中 <code>paths[i]</code> 是一个整数数组，表示第 <code>i</code> 个朋友走过的路径，请你返回 <strong>每一个</strong> 朋友都走过的 <strong>最长公共子路径</strong> 的长度，如果不存在公共子路径，请你返回 <code>0</code> 。</p>\n\n<p>一个 <strong>子路径</strong> 指的是一条路径中连续的城市序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5, paths = [[0,1,<strong>2,3</strong>,4],\n                     [<strong>2,3</strong>,4],\n                     [4,0,1,<strong>2,3</strong>]]\n<b>输出：</b>2\n<b>解释：</b>最长公共子路径为 [2,3] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, paths = [[0],[1],[2]]\n<b>输出：</b>0\n<b>解释：</b>三条路径没有公共子路径。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5, paths = [[<strong>0</strong>,1,2,3,4],\n                     [4,3,2,1,<strong>0</strong>]]\n<b>输出：</b>1\n<b>解释：</b>最长公共子路径为 [0]，[1]，[2]，[3] 和 [4] 。它们长度都为 1 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>m == paths.length</code></li>\n\t<li><code>2 <= m <= 10<sup>5</sup></code></li>\n\t<li><code>sum(paths[i].length) <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= paths[i][j] < n</code></li>\n\t<li><code>paths[i]</code> 中同一个城市不会连续重复出现。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1924.安装栅栏 II",
        "hardRate": "HARD",
        "passRate": "46.40%",
        "problemsUrl": "https://leetcode.cn/problems/erect-the-fence-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/erect-the-fence-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1925.统计平方和三元组的数目",
        "hardRate": "EASY",
        "passRate": "69.57%",
        "problemsUrl": "https://leetcode.cn/problems/count-square-sum-triples/",
        "solutionsUrl": "https://leetcode.cn/problems/count-square-sum-triples/solution",
        "problemsDesc": "<p>一个 <strong>平方和三元组</strong> <code>(a,b,c)</code> 指的是满足 <code>a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup></code> 的 <strong>整数 </strong>三元组 <code>a</code>，<code>b</code> 和 <code>c</code> 。</p>\n\n<p>给你一个整数 <code>n</code> ，请你返回满足<em> </em><code>1 &lt;= a, b, c &lt;= n</code> 的 <strong>平方和三元组</strong> 的数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 5\n<b>输出：</b>2\n<b>解释：</b>平方和三元组为 (3,4,5) 和 (4,3,5) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 10\n<b>输出：</b>4\n<b>解释：</b>平方和三元组为 (3,4,5)，(4,3,5)，(6,8,10) 和 (8,6,10) 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 250</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1926.迷宫中离入口最近的出口",
        "hardRate": "MEDIUM",
        "passRate": "39.46%",
        "problemsUrl": "https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/",
        "solutionsUrl": "https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的迷宫矩阵 <code>maze</code> （<strong>下标从 0 开始</strong>），矩阵中有空格子（用 <code>'.'</code> 表示）和墙（用 <code>'+'</code> 表示）。同时给你迷宫的入口 <code>entrance</code> ，用 <code>entrance = [entrance<sub>row</sub>, entrance<sub>col</sub>]</code> 表示你一开始所在格子的行和列。</p>\n\n<p>每一步操作，你可以往 <strong>上</strong>，<strong>下</strong>，<strong>左</strong> 或者 <strong>右</strong> 移动一个格子。你不能进入墙所在的格子，你也不能离开迷宫。你的目标是找到离 <code>entrance</code> <strong>最近</strong> 的出口。<strong>出口</strong> 的含义是 <code>maze</code> <strong>边界</strong> 上的 <strong>空格子</strong>。<code>entrance</code> 格子 <strong>不算</strong> 出口。</p>\n\n<p>请你返回从 <code>entrance</code> 到最近出口的最短路径的 <strong>步数</strong> ，如果不存在这样的路径，请你返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/nearest1-grid.jpg\" style=\"width: 333px; height: 253px;\">\n<pre><b>输入：</b>maze = [[\"+\",\"+\",\".\",\"+\"],[\".\",\".\",\".\",\"+\"],[\"+\",\"+\",\"+\",\".\"]], entrance = [1,2]\n<b>输出：</b>1\n<b>解释：</b>总共有 3 个出口，分别位于 (1,0)，(0,2) 和 (2,3) 。\n一开始，你在入口格子 (1,2) 处。\n- 你可以往左移动 2 步到达 (1,0) 。\n- 你可以往上移动 1 步到达 (0,2) 。\n从入口处没法到达 (2,3) 。\n所以，最近的出口是 (0,2) ，距离为 1 步。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/nearesr2-grid.jpg\" style=\"width: 253px; height: 253px;\">\n<pre><b>输入：</b>maze = [[\"+\",\"+\",\"+\"],[\".\",\".\",\".\"],[\"+\",\"+\",\"+\"]], entrance = [1,0]\n<b>输出：</b>2\n<b>解释：</b>迷宫中只有 1 个出口，在 (1,2) 处。\n(1,0) 不算出口，因为它是入口格子。\n初始时，你在入口与格子 (1,0) 处。\n- 你可以往右移动 2 步到达 (1,2) 处。\n所以，最近的出口为 (1,2) ，距离为 2 步。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/nearest3-grid.jpg\" style=\"width: 173px; height: 93px;\">\n<pre><b>输入：</b>maze = [[\".\",\"+\"]], entrance = [0,0]\n<b>输出：</b>-1\n<b>解释：</b>这个迷宫中没有出口。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>maze.length == m</code></li>\n\t<li><code>maze[i].length == n</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>maze[i][j]</code> 要么是 <code>'.'</code> ，要么是 <code>'+'</code> 。</li>\n\t<li><code>entrance.length == 2</code></li>\n\t<li><code>0 &lt;= entrance<sub>row</sub> &lt; m</code></li>\n\t<li><code>0 &lt;= entrance<sub>col</sub> &lt; n</code></li>\n\t<li><code>entrance</code> 一定是空格子。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1927.求和游戏",
        "hardRate": "MEDIUM",
        "passRate": "43.52%",
        "problemsUrl": "https://leetcode.cn/problems/sum-game/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-game/solution",
        "problemsDesc": "<p>Alice 和 Bob 玩一个游戏，两人轮流行动，<strong>Alice 先手</strong> 。</p>\n\n<p>给你一个 <strong>偶数长度</strong> 的字符串 <code>num</code> ，每一个字符为数字字符或者 <code>'?'</code> 。每一次操作中，如果 <code>num</code> 中至少有一个 <code>'?'</code> ，那么玩家可以执行以下操作：</p>\n\n<ol>\n\t<li>选择一个下标 <code>i</code> 满足 <code>num[i] == '?'</code> 。</li>\n\t<li>将 <code>num[i]</code> 用 <code>'0'</code> 到 <code>'9'</code> 之间的一个数字字符替代。</li>\n</ol>\n\n<p>当 <code>num</code> 中没有<span style=\"\"> </span><code>'?'</code> 时，游戏结束。</p>\n\n<p>Bob 获胜的条件是 <code>num</code> 中前一半数字的和 <strong>等于</strong> 后一半数字的和。Alice 获胜的条件是前一半的和与后一半的和 <strong>不相等</strong> 。</p>\n\n<ul>\n\t<li>比方说，游戏结束时 <code>num = \"243801\"</code> ，那么 Bob 获胜，因为 <code>2+4+3 = 8+0+1</code> 。如果游戏结束时 <code>num = \"243803\"</code> ，那么 Alice 获胜，因为 <code>2+4+3 != 8+0+3</code> 。</li>\n</ul>\n\n<p>在 Alice 和 Bob 都采取 <strong>最优</strong> 策略的前提下，如果 Alice 获胜，请返回 <code>true</code> ，如果 Bob 获胜，请返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>num = \"5023\"\n<b>输出：</b>false\n<b>解释：</b>num 中没有 '?' ，没法进行任何操作。\n前一半的和等于后一半的和：5 + 0 = 2 + 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>num = \"25??\"\n<b>输出：</b>true\n<strong>解释：</strong>Alice 可以将两个 '?' 中的一个替换为 '9' ，Bob 无论如何都无法使前一半的和等于后一半的和。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>num = \"?3295???\"\n<b>输出：</b>false\n<b>解释：</b>Bob 总是能赢。一种可能的结果是：\n- Alice 将第一个 '?' 用 '9' 替换。num = \"93295???\" 。\n- Bob 将后面一半中的一个 '?' 替换为 '9' 。num = \"932959??\" 。\n- Alice 将后面一半中的一个 '?' 替换为 '2' 。num = \"9329592?\" 。\n- Bob 将后面一半中最后一个 '?' 替换为 '7' 。num = \"93295927\" 。\nBob 获胜，因为 9 + 3 + 2 + 9 = 5 + 9 + 2 + 7 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= num.length <= 10<sup>5</sup></code></li>\n\t<li><code>num.length</code> 是 <strong>偶数</strong> 。</li>\n\t<li><code>num</code> 只包含数字字符和 <code>'?'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1928.规定时间内到达终点的最小花费",
        "hardRate": "HARD",
        "passRate": "45.93%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/solution",
        "problemsDesc": "<p>一个国家有 <code>n</code> 个城市，城市编号为 <code>0</code> 到 <code>n - 1</code> ，题目保证 <strong>所有城市</strong> 都由双向道路 <b>连接在一起</b> 。道路由二维整数数组 <code>edges</code> 表示，其中 <code>edges[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>]</code> 表示城市 <code>x<sub>i</sub></code> 和 <code>y<sub>i</sub></code> 之间有一条双向道路，耗费时间为 <code>time<sub>i</sub></code> 分钟。两个城市之间可能会有多条耗费时间不同的道路，但是不会有道路两头连接着同一座城市。</p>\n\n<p>每次经过一个城市时，你需要付通行费。通行费用一个长度为 <code>n</code> 且下标从 <strong>0</strong> 开始的整数数组 <code>passingFees</code> 表示，其中 <code>passingFees[j]</code> 是你经过城市 <code>j</code> 需要支付的费用。</p>\n\n<p>一开始，你在城市 <code>0</code> ，你想要在 <code>maxTime</code> <strong>分钟以内</strong> （包含 <code>maxTime</code> 分钟）到达城市 <code>n - 1</code> 。旅行的 <strong>费用</strong> 为你经过的所有城市 <strong>通行费之和</strong> （<strong>包括</strong> 起点和终点城市的通行费）。</p>\n\n<p>给你 <code>maxTime</code>，<code>edges</code> 和 <code>passingFees</code> ，请你返回完成旅行的 <strong>最小费用</strong> ，如果无法在 <code>maxTime</code> 分钟以内完成旅行，请你返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/leetgraph1-1.png\" style=\"width: 371px; height: 171px;\" /></p>\n\n<pre>\n<b>输入：</b>maxTime = 30, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n<b>输出：</b>11\n<b>解释：</b>最优路径为 0 -> 1 -> 2 -> 5 ，总共需要耗费 30 分钟，需要支付 11 的通行费。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/copy-of-leetgraph1-1.png\" style=\"width: 371px; height: 171px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>maxTime = 29, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n<b>输出：</b>48\n<b>解释：</b>最优路径为 0 -> 3 -> 4 -> 5 ，总共需要耗费 26 分钟，需要支付 48 的通行费。\n你不能选择路径 0 -> 1 -> 2 -> 5 ，因为这条路径耗费的时间太长。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>maxTime = 25, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n<b>输出：</b>-1\n<b>解释：</b>无法在 25 分钟以内从城市 0 到达城市 5 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= maxTime <= 1000</code></li>\n\t<li><code>n == passingFees.length</code></li>\n\t<li><code>2 <= n <= 1000</code></li>\n\t<li><code>n - 1 <= edges.length <= 1000</code></li>\n\t<li><code>0 <= x<sub>i</sub>, y<sub>i</sub> <= n - 1</code></li>\n\t<li><code>1 <= time<sub>i</sub> <= 1000</code></li>\n\t<li><code>1 <= passingFees[j] <= 1000</code> </li>\n\t<li>图中两个节点之间可能有多条路径。</li>\n\t<li>图中不含有自环。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1929.数组串联",
        "hardRate": "EASY",
        "passRate": "86.11%",
        "problemsUrl": "https://leetcode.cn/problems/concatenation-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/concatenation-of-array/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 。请你构建一个长度为 <code>2n</code> 的答案数组 <code>ans</code> ，数组下标<strong> 从 0 开始计数 </strong>，对于所有 <code>0 <= i < n</code> 的 <code>i</code> ，满足下述所有要求：</p>\n\n<ul>\n\t<li><code>ans[i] == nums[i]</code></li>\n\t<li><code>ans[i + n] == nums[i]</code></li>\n</ul>\n\n<p>具体而言，<code>ans</code> 由两个 <code>nums</code> 数组 <strong>串联</strong> 形成。</p>\n\n<p>返回数组<em> </em><code>ans</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1]\n<strong>输出：</strong>[1,2,1,1,2,1]\n<strong>解释：</strong>数组 ans 按下述方式形成：\n- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]\n- ans = [1,2,1,1,2,1]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,2,1]\n<strong>输出：</strong>[1,3,2,1,1,3,2,1]\n<strong>解释：</strong>数组 ans 按下述方式形成：\n- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]\n- ans = [1,3,2,1,1,3,2,1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 <= n <= 1000</code></li>\n\t<li><code>1 <= nums[i] <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1930.长度为 3 的不同回文子序列",
        "hardRate": "MEDIUM",
        "passRate": "51.70%",
        "problemsUrl": "https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，返回 <code>s</code> 中 <strong>长度为 3 </strong>的<strong>不同回文子序列</strong> 的个数。</p>\n\n<p>即便存在多种方法来构建相同的子序列，但相同的子序列只计数一次。</p>\n\n<p><strong>回文</strong> 是正着读和反着读一样的字符串。</p>\n\n<p><strong>子序列</strong> 是由原字符串删除其中部分字符（也可以不删除）且不改变剩余字符之间相对顺序形成的一个新字符串。</p>\n\n<ul>\n\t<li>例如，<code>\"ace\"</code> 是 <code>\"<strong><em>a</em></strong>b<strong><em>c</em></strong>d<strong><em>e</em></strong>\"</code> 的一个子序列。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aabca\"\n<strong>输出：</strong>3\n<strong>解释：</strong>长度为 3 的 3 个回文子序列分别是：\n- \"aba\" (\"<strong><em>a</em></strong>a<strong><em>b</em></strong>c<strong><em>a</em></strong>\" 的子序列)\n- \"aaa\" (\"<strong><em>aa</em></strong>bc<strong><em>a</em></strong>\" 的子序列)\n- \"aca\" (\"<strong><em>a</em></strong>ab<strong><em>ca</em></strong>\" 的子序列)\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"adc\"\n<strong>输出：</strong>0\n<strong>解释：</strong>\"adc\" 不存在长度为 3 的回文子序列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"bbcbaba\"\n<strong>输出：</strong>4\n<strong>解释：</strong>长度为 3 的 4 个回文子序列分别是：\n- \"bbb\" (\"<strong><em>bb</em></strong>c<strong><em>b</em></strong>aba\" 的子序列)\n- \"bcb\" (\"<strong><em>b</em></strong>b<strong><em>cb</em></strong>aba\" 的子序列)\n- \"bab\" (\"<strong><em>b</em></strong>bcb<strong><em>ab</em></strong>a\" 的子序列)\n- \"aba\" (\"bbcb<strong><em>aba</em></strong>\" 的子序列)\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 <= s.length <= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1931.用三种不同颜色为网格涂色",
        "hardRate": "HARD",
        "passRate": "59.36%",
        "problemsUrl": "https://leetcode.cn/problems/painting-a-grid-with-three-different-colors/",
        "solutionsUrl": "https://leetcode.cn/problems/painting-a-grid-with-three-different-colors/solution",
        "problemsDesc": "<p>给你两个整数 <code>m</code> 和 <code>n</code> 。构造一个 <code>m x n</code> 的网格，其中每个单元格最开始是白色。请你用 <strong>红、绿、蓝</strong> 三种颜色为每个单元格涂色。所有单元格都需要被涂色。</p>\n\n<p>涂色方案需要满足：<strong>不存在相邻两个单元格颜色相同的情况</strong> 。返回网格涂色的方法数。因为答案可能非常大， 返回 <strong>对 </strong><code>10<sup>9</sup> + 7</code><strong> 取余</strong> 的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/22/colorthegrid.png\" style=\"width: 200px; height: 50px;\" />\n<pre>\n<strong>输入：</strong>m = 1, n = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>如上图所示，存在三种可能的涂色方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/22/copy-of-colorthegrid.png\" style=\"width: 321px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>m = 1, n = 2\n<strong>输出：</strong>6\n<strong>解释：</strong>如上图所示，存在六种可能的涂色方案。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 5, n = 5\n<strong>输出：</strong>580986\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= m <= 5</code></li>\n\t<li><code>1 <= n <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1932.合并多棵二叉搜索树",
        "hardRate": "HARD",
        "passRate": "33.33%",
        "problemsUrl": "https://leetcode.cn/problems/merge-bsts-to-create-single-bst/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-bsts-to-create-single-bst/solution",
        "problemsDesc": "<p>给你 <code>n</code> 个 <strong>二叉搜索树的根节点</strong> ，存储在数组 <code>trees</code> 中（<strong>下标从 0 开始</strong>），对应 <code>n</code> 棵不同的二叉搜索树。<code>trees</code> 中的每棵二叉搜索树 <strong>最多有 3 个节点</strong> ，且不存在值相同的两个根节点。在一步操作中，将会完成下述步骤：</p>\n\n<ul>\n\t<li>选择两个 <strong>不同的</strong> 下标 <code>i</code> 和 <code>j</code> ，要求满足在&nbsp;<code>trees[i]</code> 中的某个 <strong>叶节点</strong> 的值等于&nbsp;<code>trees[j]</code> 的 <strong>根节点的值</strong> 。</li>\n\t<li>用&nbsp;<code>trees[j]</code> 替换 <code>trees[i]</code> 中的那个叶节点。</li>\n\t<li>从 <code>trees</code> 中移除 <code>trees[j]</code> 。</li>\n</ul>\n\n<p>如果在执行 <code>n - 1</code> 次操作后，能形成一棵有效的二叉搜索树，则返回结果二叉树的 <strong>根节点</strong> ；如果无法构造一棵有效的二叉搜索树<em>，</em>返回<em> </em><code>null</code> 。</p>\n\n<p>二叉搜索树是一种二叉树，且树中每个节点均满足下述属性：</p>\n\n<ul>\n\t<li>任意节点的左子树中的值都 <strong>严格小于</strong>&nbsp;此节点的值。</li>\n\t<li>任意节点的右子树中的值都 <strong>严格大于</strong>&nbsp;此节点的值。</li>\n</ul>\n\n<p>叶节点是不含子节点的节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/08/d1.png\" />\n<pre>\n<strong>输入：</strong>trees = [[2,1],[3,2,5],[5,4]]\n<strong>输出：</strong>[3,2,5,1,null,4]\n<strong>解释：</strong>\n第一步操作中，选出 i=1 和 j=0 ，并将 trees[0] 合并到 trees[1] 中。\n删除 trees[0] ，trees = [[3,2,5,1],[5,4]] 。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/24/diagram.png\" />\n在第二步操作中，选出 i=0 和 j=1 ，将 trees[1] 合并到 trees[0] 中。\n删除 trees[1] ，trees = [[3,2,5,1,null,4]] 。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/24/diagram-2.png\" />\n结果树如上图所示，为一棵有效的二叉搜索树，所以返回该树的根节点。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/08/d2.png\" />\n<pre>\n<strong>输入：</strong>trees = [[5,3,8],[3,2,6]]\n<strong>输出：</strong>[]\n<strong>解释：</strong>\n选出 i=0 和 j=1 ，然后将 trees[1] 合并到 trees[0] 中。\n删除 trees[1] ，trees = [[5,3,8,2,6]] 。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/24/diagram-3.png\" />\n结果树如上图所示。仅能执行一次有效的操作，但结果树不是一棵有效的二叉搜索树，所以返回 null 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/08/d3.png\" />\n<pre>\n<strong>输入：</strong>trees = [[5,4],[3]]\n<strong>输出：</strong>[]\n<strong>解释：</strong>无法执行任何操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == trees.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li>每棵树中节点数目在范围 <code>[1, 3]</code> 内。</li>\n\t<li>输入数据的每个节点可能有子节点但不存在子节点的子节点</li>\n\t<li><code>trees</code> 中不存在两棵树根节点值相同的情况。</li>\n\t<li>输入中的所有树都是 <strong>有效的二叉树搜索树</strong> 。</li>\n\t<li><code>1 &lt;= TreeNode.val &lt;= 5 * 10<sup>4</sup></code>.</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1933.判断字符串是否可分解为值均等的子串",
        "hardRate": "EASY",
        "passRate": "49.35%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-string-is-decomposable-into-value-equal-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-string-is-decomposable-into-value-equal-substrings/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1934.确认率",
        "hardRate": "MEDIUM",
        "passRate": "67.38%",
        "problemsUrl": "https://leetcode.cn/problems/confirmation-rate/",
        "solutionsUrl": "https://leetcode.cn/problems/confirmation-rate/solution",
        "problemsDesc": "<p>表: <code>Signups</code></p>\n\n<pre>\n+----------------+----------+\n| Column Name    | Type     |\n+----------------+----------+\n| user_id        | int      |\n| time_stamp     | datetime |\n+----------------+----------+\nUser_id是该表的主键。\n每一行都包含ID为user_id的用户的注册时间信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>表: <code>Confirmations</code></p>\n\n<pre>\n+----------------+----------+\n| Column Name    | Type     |\n+----------------+----------+\n| user_id        | int      |\n| time_stamp     | datetime |\n| action         | ENUM     |\n+----------------+----------+\n(user_id, time_stamp)是该表的主键。\nuser_id是一个引用到注册表的外键。\naction是类型为('confirmed'， 'timeout')的ENUM\n该表的每一行都表示ID为user_id的用户在time_stamp请求了一条确认消息，该确认消息要么被确认('confirmed')，要么被过期('timeout')。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>用户的 <strong>确认率</strong>&nbsp;是 <code>'confirmed'</code>&nbsp;消息的数量除以请求的确认消息的总数。没有请求任何确认消息的用户的确认率为&nbsp;<code>0</code> 。确认率四舍五入到 <strong>小数点后两位</strong> 。</p>\n\n<p>编写一个SQL查询来查找每个用户的 确认率 。<br />\n<br />\n以 任意顺序&nbsp;返回结果表。<br />\n<br />\n查询结果格式如下所示。<br />\n<br />\n<strong>示例1:</strong></p>\n\n<pre>\n<b>输入：</b>\nSignups 表:\n+---------+---------------------+\n| user_id | time_stamp          |\n+---------+---------------------+\n| 3       | 2020-03-21 10:16:13 |\n| 7       | 2020-01-04 13:57:59 |\n| 2       | 2020-07-29 23:09:44 |\n| 6       | 2020-12-09 10:39:37 |\n+---------+---------------------+\nConfirmations 表:\n+---------+---------------------+-----------+\n| user_id | time_stamp          | action    |\n+---------+---------------------+-----------+\n| 3       | 2021-01-06 03:30:46 | timeout   |\n| 3       | 2021-07-14 14:00:00 | timeout   |\n| 7       | 2021-06-12 11:57:29 | confirmed |\n| 7       | 2021-06-13 12:58:28 | confirmed |\n| 7       | 2021-06-14 13:59:27 | confirmed |\n| 2       | 2021-01-22 00:00:00 | confirmed |\n| 2       | 2021-02-28 23:59:59 | timeout   |\n+---------+---------------------+-----------+\n<strong>输出:</strong> \n+---------+-------------------+\n| user_id | confirmation_rate |\n+---------+-------------------+\n| 6       | 0.00              |\n| 3       | 0.00              |\n| 7       | 1.00              |\n| 2       | 0.50              |\n+---------+-------------------+\n<strong>解释:\n</strong>用户 6 没有请求任何确认消息。确认率为 0。\n用户 3 进行了 2 次请求，都超时了。确认率为 0。\n用户 7 提出了 3 个请求，所有请求都得到了确认。确认率为 1。\n用户 2 做了 2 个请求，其中一个被确认，另一个超时。确认率为 1 / 2 = 0.5。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1935.可以输入的最大单词数",
        "hardRate": "EASY",
        "passRate": "70.79%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-words-you-can-type/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-words-you-can-type/solution",
        "problemsDesc": "<p>键盘出现了一些故障，有些字母键无法正常工作。而键盘上所有其他键都能够正常工作。</p>\n\n<p>给你一个由若干单词组成的字符串 <code>text</code> ，单词间由单个空格组成（不含前导和尾随空格）；另有一个字符串 <code>brokenLetters</code> ，由所有已损坏的不同字母键组成，返回你可以使用此键盘完全输入的 <code>text</code> 中单词的数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>text = \"hello world\", brokenLetters = \"ad\"\n<strong>输出：</strong>1\n<strong>解释：</strong>无法输入 \"world\" ，因为字母键 'd' 已损坏。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>text = \"leet code\", brokenLetters = \"lt\"\n<strong>输出：</strong>1\n<strong>解释：</strong>无法输入 \"leet\" ，因为字母键 'l' 和 't' 已损坏。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>text = \"leet code\", brokenLetters = \"e\"\n<strong>输出：</strong>0\n<strong>解释：</strong>无法输入任何单词，因为字母键 'e' 已损坏。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= brokenLetters.length &lt;= 26</code></li>\n\t<li><code>text</code> 由若干用单个空格分隔的单词组成，且不含任何前导和尾随空格</li>\n\t<li>每个单词仅由小写英文字母组成</li>\n\t<li><code>brokenLetters</code> 由 <strong>互不相同</strong> 的小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1936.新增的最少台阶数",
        "hardRate": "MEDIUM",
        "passRate": "46.24%",
        "problemsUrl": "https://leetcode.cn/problems/add-minimum-number-of-rungs/",
        "solutionsUrl": "https://leetcode.cn/problems/add-minimum-number-of-rungs/solution",
        "problemsDesc": "<p>给你一个 <strong>严格递增</strong> 的整数数组 <code>rungs</code> ，用于表示梯子上每一台阶的 <strong>高度</strong> 。当前你正站在高度为 <code>0</code> 的地板上，并打算爬到最后一个台阶。</p>\n\n<p>另给你一个整数 <code>dist</code> 。每次移动中，你可以到达下一个距离你当前位置（地板或台阶）<strong>不超过</strong> <code>dist</code> 高度的台阶。当然，你也可以在任何正 <strong>整数</strong> 高度处插入尚不存在的新台阶。</p>\n\n<p>返回爬到最后一阶时必须添加到梯子上的 <strong>最少</strong> 台阶数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rungs = [1,3,5,10], dist = 2\n<strong>输出：</strong>2\n<strong>解释：\n</strong>现在无法到达最后一阶。\n在高度为 7 和 8 的位置增设新的台阶，以爬上梯子。 \n梯子在高度为 [1,3,5,<strong><em>7</em></strong>,<strong><em>8</em></strong>,10] 的位置上有台阶。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rungs = [3,6,8,10], dist = 3\n<strong>输出：</strong>0\n<strong>解释：</strong>\n这个梯子无需增设新台阶也可以爬上去。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>rungs = [3,4,6,7], dist = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>\n现在无法从地板到达梯子的第一阶。 \n在高度为 1 的位置增设新的台阶，以爬上梯子。 \n梯子在高度为 [<strong><em>1</em></strong>,3,4,6,7] 的位置上有台阶。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>rungs = [5], dist = 10\n<strong>输出：</strong>0\n<strong>解释：</strong>这个梯子无需增设新台阶也可以爬上去。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= rungs.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= rungs[i] <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= dist <= 10<sup>9</sup></code></li>\n\t<li><code>rungs</code> <strong>严格递增</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1937.扣分后的最大得分",
        "hardRate": "MEDIUM",
        "passRate": "28.93%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-points-with-cost/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-points-with-cost/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的整数矩阵 <code>points</code> （下标从 <strong>0</strong> 开始）。一开始你的得分为 <code>0</code> ，你想最大化从矩阵中得到的分数。</p>\n\n<p>你的得分方式为：<strong>每一行</strong> 中选取一个格子，选中坐标为 <code>(r, c)</code> 的格子会给你的总得分 <strong>增加</strong> <code>points[r][c]</code> 。</p>\n\n<p>然而，相邻行之间被选中的格子如果隔得太远，你会失去一些得分。对于相邻行 <code>r</code> 和 <code>r + 1</code> （其中 <code>0 <= r < m - 1</code>），选中坐标为 <code>(r, c<sub>1</sub>)</code> 和 <code>(r + 1, c<sub>2</sub>)</code> 的格子，你的总得分 <b>减少</b> <code>abs(c<sub>1</sub> - c<sub>2</sub>)</code> 。</p>\n\n<p>请你返回你能得到的 <strong>最大</strong> 得分。</p>\n\n<p><code>abs(x)</code> 定义为：</p>\n\n<ul>\n\t<li>如果 <code>x >= 0</code> ，那么值为 <code>x</code> 。</li>\n\t<li>如果 <code>x < 0</code> ，那么值为 <code>-x</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-40-26-diagram-drawio-diagrams-net.png\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<b>输入：</b>points = [[1,2,3],[1,5,1],[3,1,1]]\n<b>输出：</b>9\n<strong>解释：</strong>\n蓝色格子是最优方案选中的格子，坐标分别为 (0, 2)，(1, 1) 和 (2, 0) 。\n你的总得分增加 3 + 5 + 3 = 11 。\n但是你的总得分需要扣除 abs(2 - 1) + abs(1 - 0) = 2 。\n你的最终得分为 11 - 2 = 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-42-14-diagram-drawio-diagrams-net.png\" style=\"width: 200px; height: 299px;\" />\n<pre>\n<b>输入：</b>points = [[1,5],[2,3],[4,2]]\n<b>输出：</b>11\n<strong>解释：</strong>\n蓝色格子是最优方案选中的格子，坐标分别为 (0, 1)，(1, 1) 和 (2, 0) 。\n你的总得分增加 5 + 3 + 4 = 12 。\n但是你的总得分需要扣除 abs(1 - 1) + abs(1 - 0) = 1 。\n你的最终得分为 12 - 1 = 11 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == points.length</code></li>\n\t<li><code>n == points[r].length</code></li>\n\t<li><code>1 <= m, n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= m * n <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= points[r][c] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1938.查询最大基因差",
        "hardRate": "HARD",
        "passRate": "40.25%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-genetic-difference-query/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-genetic-difference-query/solution",
        "problemsDesc": "<p>给你一棵 <code>n</code> 个节点的有根树，节点编号从 <code>0</code> 到 <code>n - 1</code> 。每个节点的编号表示这个节点的 <strong>独一无二的基因值</strong> （也就是说节点 <code>x</code> 的基因值为 <code>x</code>）。两个基因值的 <strong>基因差</strong> 是两者的 <strong>异或和</strong> 。给你整数数组 <code>parents</code> ，其中 <code>parents[i]</code> 是节点 <code>i</code> 的父节点。如果节点 <code>x</code> 是树的 <strong>根</strong> ，那么 <code>parents[x] == -1</code> 。</p>\n\n<p>给你查询数组 <code>queries</code> ，其中 <code>queries[i] = [node<sub>i</sub>, val<sub>i</sub>]</code> 。对于查询 <code>i</code> ，请你找到 <code>val<sub>i</sub></code> 和 <code>p<sub>i</sub></code> 的 <strong>最大基因差</strong> ，其中 <code>p<sub>i</sub></code> 是节点 <code>node<sub>i</sub></code> 到根之间的任意节点（包含 <code>node<sub>i</sub></code> 和根节点）。更正式的，你想要最大化 <code>val<sub>i</sub> XOR p<sub>i</sub></code><sub> </sub>。</p>\n\n<p>请你返回数组<em> </em><code>ans</code> ，其中 <code>ans[i]</code> 是第 <code>i</code> 个查询的答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/29/c1.png\" style=\"width: 118px; height: 163px;\">\n<pre><b>输入：</b>parents = [-1,0,1,1], queries = [[0,2],[3,2],[2,5]]\n<b>输出：</b>[2,3,7]\n<strong>解释：</strong>查询数组处理如下：\n- [0,2]：最大基因差的对应节点为 0 ，基因差为 2 XOR 0 = 2 。\n- [3,2]：最大基因差的对应节点为 1 ，基因差为 2 XOR 1 = 3 。\n- [2,5]：最大基因差的对应节点为 2 ，基因差为 5 XOR 2 = 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/29/c2.png\" style=\"width: 256px; height: 221px;\">\n<pre><b>输入：</b>parents = [3,7,-1,2,0,7,0,2], queries = [[4,6],[1,15],[0,5]]\n<b>输出：</b>[6,14,7]\n<strong>解释：</strong>查询数组处理如下：\n- [4,6]：最大基因差的对应节点为 0 ，基因差为 6 XOR 0 = 6 。\n- [1,15]：最大基因差的对应节点为 1 ，基因差为 15 XOR 1 = 14 。\n- [0,5]：最大基因差的对应节点为 2 ，基因差为 5 XOR 2 = 7 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= parents.length &lt;= 10<sup>5</sup></code></li>\n\t<li>对于每个 <strong>不是</strong> 根节点的 <code>i</code> ，有 <code>0 &lt;= parents[i] &lt;= parents.length - 1</code> 。</li>\n\t<li><code>parents[root] == -1</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= node<sub>i</sub> &lt;= parents.length - 1</code></li>\n\t<li><code>0 &lt;= val<sub>i</sub> &lt;= 2 * 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1939.主动请求确认消息的用户",
        "hardRate": "EASY",
        "passRate": "59.77%",
        "problemsUrl": "https://leetcode.cn/problems/users-that-actively-request-confirmation-messages/",
        "solutionsUrl": "https://leetcode.cn/problems/users-that-actively-request-confirmation-messages/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1940.排序数组之间的最长公共子序列",
        "hardRate": "MEDIUM",
        "passRate": "73.88%",
        "problemsUrl": "https://leetcode.cn/problems/longest-common-subsequence-between-sorted-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-common-subsequence-between-sorted-arrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1941.检查是否所有字符出现次数相同",
        "hardRate": "EASY",
        "passRate": "73.53%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-all-characters-have-equal-number-of-occurrences/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-all-characters-have-equal-number-of-occurrences/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，如果 <code>s</code> 是一个 <strong>好</strong> 字符串，请你返回 <code>true</code> ，否则请返回 <code>false</code> 。</p>\n\n<p>如果 <code>s</code> 中出现过的 <strong>所有</strong> 字符的出现次数 <strong>相同</strong> ，那么我们称字符串 <code>s</code> 是 <strong>好</strong> 字符串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"abacbc\"\n<b>输出：</b>true\n<b>解释：</b>s 中出现过的字符为 'a'，'b' 和 'c' 。s 中所有字符均出现 2 次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"aaabb\"\n<b>输出：</b>false\n<b>解释：</b>s 中出现过的字符为 'a' 和 'b' 。\n'a' 出现了 3 次，'b' 出现了 2 次，两者出现次数不同。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1942.最小未被占据椅子的编号",
        "hardRate": "MEDIUM",
        "passRate": "41.95%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-the-smallest-unoccupied-chair/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-the-smallest-unoccupied-chair/solution",
        "problemsDesc": "<p>有 <code>n</code> 个朋友在举办一个派对，这些朋友从 <code>0</code> 到 <code>n - 1</code> 编号。派对里有 <strong>无数</strong> 张椅子，编号为 <code>0</code> 到 <code>infinity</code> 。当一个朋友到达派对时，他会占据 <strong>编号最小</strong> 且未被占据的椅子。</p>\n\n<ul>\n\t<li>比方说，当一个朋友到达时，如果椅子 <code>0</code> ，<code>1</code> 和 <code>5</code> 被占据了，那么他会占据 <code>2</code> 号椅子。</li>\n</ul>\n\n<p>当一个朋友离开派对时，他的椅子会立刻变成未占据状态。如果同一时刻有另一个朋友到达，可以立即占据这张椅子。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>times</code> ，其中 <code>times[i] = [arrival<sub>i</sub>, leaving<sub>i</sub>]</code> 表示第 <code>i</code> 个朋友到达和离开的时刻，同时给你一个整数 <code>targetFriend</code> 。所有到达时间 <strong>互不相同</strong> 。</p>\n\n<p>请你返回编号为 <code>targetFriend</code> 的朋友占据的 <strong>椅子编号</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>times = [[1,4],[2,3],[4,6]], targetFriend = 1\n<b>输出：</b>1\n<b>解释：</b>\n- 朋友 0 时刻 1 到达，占据椅子 0 。\n- 朋友 1 时刻 2 到达，占据椅子 1 。\n- 朋友 1 时刻 3 离开，椅子 1 变成未占据。\n- 朋友 0 时刻 4 离开，椅子 0 变成未占据。\n- 朋友 2 时刻 4 到达，占据椅子 0 。\n朋友 1 占据椅子 1 ，所以返回 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>times = [[3,10],[1,5],[2,6]], targetFriend = 0\n<b>输出：</b>2\n<b>解释：</b>\n- 朋友 1 时刻 1 到达，占据椅子 0 。\n- 朋友 2 时刻 2 到达，占据椅子 1 。\n- 朋友 0 时刻 3 到达，占据椅子 2 。\n- 朋友 1 时刻 5 离开，椅子 0 变成未占据。\n- 朋友 2 时刻 6 离开，椅子 1 变成未占据。\n- 朋友 0 时刻 10 离开，椅子 2 变成未占据。\n朋友 0 占据椅子 2 ，所以返回 2 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == times.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>times[i].length == 2</code></li>\n\t<li><code>1 &lt;= arrival<sub>i</sub> &lt; leaving<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= targetFriend &lt;= n - 1</code></li>\n\t<li>每个 <code>arrival<sub>i</sub></code> 时刻 <strong>互不相同</strong> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1943.描述绘画结果",
        "hardRate": "MEDIUM",
        "passRate": "43.91%",
        "problemsUrl": "https://leetcode.cn/problems/describe-the-painting/",
        "solutionsUrl": "https://leetcode.cn/problems/describe-the-painting/solution",
        "problemsDesc": "<p>给你一个细长的画，用数轴表示。这幅画由若干有重叠的线段表示，每个线段有 <strong>独一无二</strong>&nbsp;的颜色。给你二维整数数组&nbsp;<code>segments</code>&nbsp;，其中&nbsp;<code>segments[i] = [start<sub>i</sub>, end<sub>i</sub>, color<sub>i</sub>]</code>&nbsp;表示线段为&nbsp;<strong>半开区间</strong>&nbsp;<code>[start<sub>i</sub>, end<sub>i</sub>)</code> 且颜色为&nbsp;<code>color<sub>i</sub></code>&nbsp;。</p>\n\n<p>线段间重叠部分的颜色会被 <strong>混合</strong>&nbsp;。如果有两种或者更多颜色混合时，它们会形成一种新的颜色，用一个 <strong>集合</strong>&nbsp;表示这个混合颜色。</p>\n\n<ul>\n\t<li>比方说，如果颜色&nbsp;<code>2</code>&nbsp;，<code>4</code>&nbsp;和&nbsp;<code>6</code>&nbsp;被混合，那么结果颜色为&nbsp;<code>{2,4,6}</code>&nbsp;。</li>\n</ul>\n\n<p>为了简化题目，你不需要输出整个集合，只需要用集合中所有元素的 <strong>和</strong>&nbsp;来表示颜色集合。</p>\n\n<p>你想要用 <strong>最少数目</strong>&nbsp;不重叠 <strong>半开区间</strong>&nbsp;来 <b>表示</b>&nbsp;这幅混合颜色的画。这些线段可以用二维数组&nbsp;<code>painting</code>&nbsp;表示，其中 <code>painting[j] = [left<sub>j</sub>, right<sub>j</sub>, mix<sub>j</sub>]</code>&nbsp;表示一个&nbsp;<strong>半开区间</strong><code>[left<sub>j</sub>, right<sub>j</sub>)</code>&nbsp;的颜色 <strong>和</strong>&nbsp;为&nbsp;<code>mix<sub>j</sub></code>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，这幅画由&nbsp;<code>segments = [[1,4,5],[1,7,7]]</code>&nbsp;组成，那么它可以表示为&nbsp;<code>painting = [[1,4,12],[4,7,7]]</code>&nbsp;，因为：\n\n\t<ul>\n\t\t<li><code>[1,4)</code>&nbsp;由颜色&nbsp;<code>{5,7}</code>&nbsp;组成（和为&nbsp;<code>12</code>），分别来自第一个线段和第二个线段。</li>\n\t\t<li><code>[4,7)</code>&nbsp;由颜色 <code>{7}</code>&nbsp;组成，来自第二个线段。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回二维数组&nbsp;<code>painting</code>&nbsp;，它表示最终绘画的结果（<strong>没有</strong>&nbsp;被涂色的部分不出现在结果中）。你可以按 <strong>任意顺序</strong> 返回最终数组的结果。</p>\n\n<p><strong>半开区间&nbsp;</strong><code>[a, b)</code>&nbsp;是数轴上点&nbsp;<code>a</code> 和点&nbsp;<code>b</code>&nbsp;之间的部分，<strong>包含 </strong>点&nbsp;<code>a</code>&nbsp;且 <strong>不包含</strong>&nbsp;点&nbsp;<code>b</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/18/1.png\" style=\"width: 529px; height: 241px;\" />\n<pre>\n<b>输入：</b>segments = [[1,4,5],[4,7,7],[1,7,9]]\n<b>输出：</b>[[1,4,14],[4,7,16]]\n<strong>解释：</strong>绘画结果可以表示为：\n- [1,4) 颜色为 {5,9} （和为 14），分别来自第一和第二个线段。\n- [4,7) 颜色为 {7,9} （和为 16），分别来自第二和第三个线段。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/18/2.png\" style=\"width: 532px; height: 219px;\" />\n<pre>\n<b>输入：</b>segments = [[1,7,9],[6,8,15],[8,10,7]]\n<b>输出：</b>[[1,6,9],[6,7,24],[7,8,15],[8,10,7]]\n<b>解释：</b>绘画结果可以以表示为：\n- [1,6) 颜色为 9 ，来自第一个线段。\n- [6,7) 颜色为 {9,15} （和为 24），来自第一和第二个线段。\n- [7,8) 颜色为 15 ，来自第二个线段。\n- [8,10) 颜色为 7 ，来自第三个线段。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/04/c1.png\" style=\"width: 529px; height: 289px;\" />\n<pre>\n<b>输入：</b>segments = [[1,4,5],[1,4,7],[4,7,1],[4,7,11]]\n<b>输出：</b>[[1,4,12],[4,7,12]]\n<strong>解释：</strong>绘画结果可以表示为：\n- [1,4) 颜色为 {5,7} （和为 12），分别来自第一和第二个线段。\n- [4,7) 颜色为 {1,11} （和为 12），分别来自第三和第四个线段。\n注意，只返回一个单独的线段 [1,7) 是不正确的，因为混合颜色的集合不相同。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= segments.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>segments[i].length == 3</code></li>\n\t<li><code>1 &lt;= start<sub>i</sub> &lt; end<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= color<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li>每种颜色&nbsp;<code>color<sub>i</sub></code>&nbsp;互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1944.队列中可以看到的人数",
        "hardRate": "HARD",
        "passRate": "63.30%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-visible-people-in-a-queue/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-visible-people-in-a-queue/solution",
        "problemsDesc": "<p>有&nbsp;<code>n</code>&nbsp;个人排成一个队列，<strong>从左到右</strong>&nbsp;编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。给你以一个整数数组&nbsp;<code>heights</code>&nbsp;，每个整数 <strong>互不相同</strong>，<code>heights[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个人的高度。</p>\n\n<p>一个人能 <strong>看到</strong> 他右边另一个人的条件是这两人之间的所有人都比他们两人 <strong>矮</strong>&nbsp;。更正式的，第&nbsp;<code>i</code>&nbsp;个人能看到第&nbsp;<code>j</code>&nbsp;个人的条件是&nbsp;<code>i &lt; j</code>&nbsp;且&nbsp;<code>min(heights[i], heights[j]) &gt; max(heights[i+1], heights[i+2], ..., heights[j-1])</code>&nbsp;。</p>\n\n<p>请你返回一个长度为 <code>n</code>&nbsp;的数组<em>&nbsp;</em><code>answer</code><em>&nbsp;</em>，其中<em>&nbsp;</em><code>answer[i]</code><em>&nbsp;</em>是第&nbsp;<code>i</code>&nbsp;个人在他右侧队列中能&nbsp;<strong>看到</strong>&nbsp;的&nbsp;<strong>人数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/29/queue-plane.jpg\" style=\"width: 600px; height: 247px;\" /></p>\n\n<pre>\n<b>输入：</b>heights = [10,6,8,5,11,9]\n<b>输出：</b>[3,1,2,1,1,0]\n<strong>解释：</strong>\n第 0 个人能看到编号为 1 ，2 和 4 的人。\n第 1 个人能看到编号为 2 的人。\n第 2 个人能看到编号为 3 和 4 的人。\n第 3 个人能看到编号为 4 的人。\n第 4 个人能看到编号为 5 的人。\n第 5 个人谁也看不到因为他右边没人。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>heights = [5,1,2,3,10]\n<b>输出：</b>[4,1,1,1,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == heights.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= heights[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>heights</code>&nbsp;中所有数 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1945.字符串转化后的各位数字之和",
        "hardRate": "EASY",
        "passRate": "70.41%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-digits-of-string-after-convert/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-digits-of-string-after-convert/solution",
        "problemsDesc": "<p>给你一个由小写字母组成的字符串 <code>s</code> ，以及一个整数 <code>k</code> 。</p>\n\n<p>首先，用字母在字母表中的位置替换该字母，将 <code>s</code> <strong>转化</strong> 为一个整数（也就是，<code>'a'</code> 用 <code>1</code> 替换，<code>'b'</code> 用 <code>2</code> 替换，... <code>'z'</code> 用 <code>26</code> 替换）。接着，将整数 <strong>转换</strong> 为其 <strong>各位数字之和</strong> 。共重复 <strong>转换</strong> 操作 <strong><code>k</code> 次</strong> 。</p>\n\n<p>例如，如果 <code>s = \"zbax\"</code> 且 <code>k = 2</code> ，那么执行下述步骤后得到的结果是整数 <code>8</code> ：</p>\n\n<ul>\n\t<li><strong>转化：</strong><code>\"zbax\" ➝ \"(26)(2)(1)(24)\" ➝ \"262124\" ➝ 262124</code></li>\n\t<li><strong>转换 #1</strong>：<code>262124&nbsp;➝ 2 + 6 + 2 + 1 + 2 + 4&nbsp;➝ 17</code></li>\n\t<li><strong>转换 #2</strong>：<code>17 ➝ 1 + 7 ➝ 8</code></li>\n</ul>\n\n<p>返回执行上述操作后得到的结果整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"iiii\", k = 1\n<strong>输出：</strong>36\n<strong>解释：</strong>操作如下：\n- 转化：\"iiii\" ➝ \"(9)(9)(9)(9)\" ➝ \"9999\" ➝ 9999\n- 转换 #1：9999 ➝ 9 + 9 + 9 + 9 ➝ 36\n因此，结果整数为 36 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"leetcode\", k = 2\n<strong>输出：</strong>6\n<strong>解释：</strong>操作如下：\n- 转化：\"leetcode\" ➝ \"(12)(5)(5)(20)(3)(15)(4)(5)\" ➝ \"12552031545\" ➝ 12552031545\n- 转换 #1：12552031545 ➝ 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 ➝ 33\n- 转换 #2：33 ➝ 3 + 3 ➝ 6\n因此，结果整数为 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= k &lt;= 10</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1946.子字符串突变后可能得到的最大整数",
        "hardRate": "MEDIUM",
        "passRate": "32.25%",
        "problemsUrl": "https://leetcode.cn/problems/largest-number-after-mutating-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-number-after-mutating-substring/solution",
        "problemsDesc": "<p>给你一个字符串 <code>num</code> ，该字符串表示一个大整数。另给你一个长度为 <code>10</code> 且 <strong>下标从 0&nbsp; 开始</strong> 的整数数组 <code>change</code> ，该数组将 <code>0-9</code> 中的每个数字映射到另一个数字。更规范的说法是，数字 <code>d</code> 映射为数字 <code>change[d]</code> 。</p>\n\n<p>你可以选择 <strong>突变</strong>&nbsp; <code>num</code> 的任一子字符串。<strong>突变</strong> 子字符串意味着将每位数字 <code>num[i]</code> 替换为该数字在 <code>change</code> 中的映射（也就是说，将 <code>num[i]</code> 替换为 <code>change[num[i]]</code>）。</p>\n\n<p>请你找出在对 <code>num</code> 的任一子字符串执行突变操作（也可以不执行）后，可能得到的 <strong>最大整数</strong> ，并用字符串表示返回。</p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = \"<strong><em>1</em></strong>32\", change = [9,8,5,0,3,6,4,2,6,8]\n<strong>输出：</strong>\"<strong><em>8</em></strong>32\"\n<strong>解释：</strong>替换子字符串 \"1\"：\n- 1 映射为 change[1] = 8 。\n因此 \"<strong><em>1</em></strong>32\" 变为 \"<strong><em>8</em></strong>32\" 。\n\"832\" 是可以构造的最大整数，所以返回它的字符串表示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = \"<strong><em>021</em></strong>\", change = [9,4,3,5,7,2,1,9,0,6]\n<strong>输出：</strong>\"<strong><em>934</em></strong>\"\n<strong>解释：</strong>替换子字符串 \"021\"：\n- 0 映射为 change[0] = 9 。\n- 2 映射为 change[2] = 3 。\n- 1 映射为 change[1] = 4 。\n因此，\"<strong><em>021</em></strong>\" 变为 \"<strong><em>934</em></strong>\" 。\n\"934\" 是可以构造的最大整数，所以返回它的字符串表示。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = \"5\", change = [1,4,7,5,3,2,5,6,9,4]\n<strong>输出：</strong>\"5\"\n<strong>解释：</strong>\"5\" 已经是可以构造的最大整数，所以返回它的字符串表示。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>num</code> 仅由数字 <code>0-9</code> 组成</li>\n\t<li><code>change.length == 10</code></li>\n\t<li><code>0 &lt;= change[d] &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1947.最大兼容性评分和",
        "hardRate": "MEDIUM",
        "passRate": "57.93%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-compatibility-score-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-compatibility-score-sum/solution",
        "problemsDesc": "<p>有一份由 <code>n</code> 个问题组成的调查问卷，每个问题的答案要么是 <code>0</code>（no，否），要么是 <code>1</code>（yes，是）。</p>\n\n<p>这份调查问卷被分发给 <code>m</code> 名学生和 <code>m</code> 名导师，学生和导师的编号都是从 <code>0</code> 到 <code>m - 1</code> 。学生的答案用一个二维整数数组 <code>students</code> 表示，其中 <code>students[i]</code> 是一个整数数组，包含第 <code>i</code> 名学生对调查问卷给出的答案（<strong>下标从 0 开始</strong>）。导师的答案用一个二维整数数组 <code>mentors</code> 表示，其中 <code>mentors[j]</code> 是一个整数数组，包含第 <code>j</code> 名导师对调查问卷给出的答案（<strong>下标从 0 开始</strong>）。</p>\n\n<p>每个学生都会被分配给 <strong>一名</strong> 导师，而每位导师也会分配到 <strong>一名</strong> 学生。配对的学生与导师之间的兼容性评分等于学生和导师答案相同的次数。</p>\n\n<ul>\n\t<li>例如，学生答案为<code>[1, <strong><em>0</em></strong>, <strong><em>1</em></strong>]</code> 而导师答案为 <code>[0, <strong><em>0</em></strong>, <strong><em>1</em></strong>]</code> ，那么他们的兼容性评分为 2 ，因为只有第二个和第三个答案相同。</li>\n</ul>\n\n<p>请你找出最优的学生与导师的配对方案，以 <strong>最大程度上</strong> 提高 <strong>兼容性评分和</strong> 。</p>\n\n<p>给你 <code>students</code> 和 <code>mentors</code> ，返回可以得到的<em> </em><strong>最大兼容性评分和</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>students = [[1,1,0],[1,0,1],[0,0,1]], mentors = [[1,0,0],[0,0,1],[1,1,0]]\n<strong>输出：</strong>8\n<strong>解释：</strong>按下述方式分配学生和导师：\n- 学生 0 分配给导师 2 ，兼容性评分为 3 。\n- 学生 1 分配给导师 0 ，兼容性评分为 2 。\n- 学生 2 分配给导师 1 ，兼容性评分为 3 。\n最大兼容性评分和为 3 + 2 + 3 = 8 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>students = [[0,0],[0,0],[0,0]], mentors = [[1,1],[1,1],[1,1]]\n<strong>输出：</strong>0\n<strong>解释：</strong>任意学生与导师配对的兼容性评分都是 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == students.length == mentors.length</code></li>\n\t<li><code>n == students[i].length == mentors[j].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 8</code></li>\n\t<li><code>students[i][k]</code> 为 <code>0</code> 或 <code>1</code></li>\n\t<li><code>mentors[j][k]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1948.删除系统中的重复文件夹",
        "hardRate": "HARD",
        "passRate": "54.50%",
        "problemsUrl": "https://leetcode.cn/problems/delete-duplicate-folders-in-system/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-duplicate-folders-in-system/solution",
        "problemsDesc": "<p>由于一个漏洞，文件系统中存在许多重复文件夹。给你一个二维数组 <code>paths</code>，其中 <code>paths[i]</code> 是一个表示文件系统中第 <code>i</code> 个文件夹的绝对路径的数组。</p>\n\n<ul>\n\t<li>例如，<code>[\"one\", \"two\", \"three\"]</code> 表示路径 <code>\"/one/two/three\"</code> 。</li>\n</ul>\n\n<p>如果两个文件夹（不需要在同一层级）包含 <strong>非空且</strong><b>相同的&nbsp;</b>子文件夹&nbsp;<strong>集合</strong> 并具有相同的子文件夹结构，则认为这两个文件夹是相同文件夹。相同文件夹的根层级 <strong>不</strong> 需要相同。如果存在两个（或两个以上）<strong>相同</strong> 文件夹，则需要将这些文件夹和所有它们的子文件夹 <strong>标记</strong> 为待删除。</p>\n\n<ul>\n\t<li>例如，下面文件结构中的文件夹 <code>\"/a\"</code> 和 <code>\"/b\"</code> 相同。它们（以及它们的子文件夹）应该被 <strong>全部</strong> 标记为待删除：\n\n\t<ul>\n\t\t<li><code>/a</code></li>\n\t\t<li><code>/a/x</code></li>\n\t\t<li><code>/a/x/y</code></li>\n\t\t<li><code>/a/z</code></li>\n\t\t<li><code>/b</code></li>\n\t\t<li><code>/b/x</code></li>\n\t\t<li><code>/b/x/y</code></li>\n\t\t<li><code>/b/z</code></li>\n\t</ul>\n\t</li>\n\t<li>然而，如果文件结构中还包含路径 <code>\"/b/w\"</code> ，那么文件夹 <code>\"/a\"</code> 和 <code>\"/b\"</code> 就不相同。注意，即便添加了新的文件夹 <code>\"/b/w\"</code> ，仍然认为 <code>\"/a/x\"</code> 和 <code>\"/b/x\"</code> 相同。</li>\n</ul>\n\n<p>一旦所有的相同文件夹和它们的子文件夹都被标记为待删除，文件系统将会 <strong>删除</strong> 所有上述文件夹。文件系统只会执行一次删除操作。执行完这一次删除操作后，不会删除新出现的相同文件夹。</p>\n\n<p>返回二维数组<em> </em><code>ans</code> ，该数组包含删除所有标记文件夹之后剩余文件夹的路径。路径可以按 <strong>任意顺序</strong> 返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder1.jpg\" style=\"width: 200px; height: 218px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\"],[\"c\"],[\"d\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"a\"]]\n<strong>输出：</strong>[[\"d\"],[\"d\",\"a\"]]\n<strong>解释：</strong>文件结构如上所示。\n文件夹 \"/a\" 和 \"/c\"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 \"b\" 的空文件夹。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder2.jpg\" style=\"width: 200px; height: 355px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\"],[\"c\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"a\",\"b\",\"x\"],[\"a\",\"b\",\"x\",\"y\"],[\"w\"],[\"w\",\"y\"]]\n<strong>输出：</strong>[[\"c\"],[\"c\",\"b\"],[\"a\"],[\"a\",\"b\"]]\n<strong>解释：</strong>文件结构如上所示。\n文件夹 \"/a/b/x\" 和 \"/w\"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 \"y\" 的空文件夹。\n注意，文件夹 \"/a\" 和 \"/c\" 在删除后变为相同文件夹，但这两个文件夹不会被删除，因为删除只会进行一次，且它们没有在删除前被标记。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder3.jpg\" style=\"width: 200px; height: 201px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\",\"b\"],[\"c\",\"d\"],[\"c\"],[\"a\"]]\n<strong>输出：</strong>[[\"c\"],[\"c\",\"d\"],[\"a\"],[\"a\",\"b\"]]\n<strong>解释：</strong>文件系统中所有文件夹互不相同。\n注意，返回的数组可以按不同顺序返回文件夹路径，因为题目对顺序没有要求。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder4_.jpg\" style=\"width: 300px; height: 290px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\"],[\"a\",\"x\"],[\"a\",\"x\",\"y\"],[\"a\",\"z\"],[\"b\"],[\"b\",\"x\"],[\"b\",\"x\",\"y\"],[\"b\",\"z\"]]\n<strong>输出：</strong>[]\n<strong>解释：</strong>文件结构如上所示。\n文件夹 \"/a/x\" 和 \"/b/x\"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 \"y\" 的空文件夹。\n文件夹 \"/a\" 和 \"/b\"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含一个名为 \"z\" 的空文件夹以及上面提到的文件夹 \"x\" 。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder5_.jpg\" style=\"width: 300px; height: 282px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\"],[\"a\",\"x\"],[\"a\",\"x\",\"y\"],[\"a\",\"z\"],[\"b\"],[\"b\",\"x\"],[\"b\",\"x\",\"y\"],[\"b\",\"z\"],[\"b\",\"w\"]]\n<strong>输出：</strong>[[\"b\"],[\"b\",\"w\"],[\"b\",\"z\"],[\"a\"],[\"a\",\"z\"]]\n<strong>解释：</strong>本例与上例的结构基本相同，除了新增 \"/b/w\" 文件夹。\n文件夹 \"/a/x\" 和 \"/b/x\" 仍然会被标记，但 \"/a\" 和 \"/b\" 不再被标记，因为 \"/b\" 中有名为 \"w\" 的空文件夹而 \"/a\" 没有。\n注意，\"/a/z\" 和 \"/b/z\" 不会被标记，因为相同子文件夹的集合必须是非空集合，但这两个文件夹都是空的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= paths.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= paths[i].length &lt;= 500</code></li>\n\t<li><code>1 &lt;= paths[i][j].length &lt;= 10</code></li>\n\t<li><code>1 &lt;= sum(paths[i][j].length) &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>path[i][j]</code> 由小写英文字母组成</li>\n\t<li>不会存在两个路径都指向同一个文件夹的情况</li>\n\t<li>对于不在根层级的任意文件夹，其父文件夹也会包含在输入中</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1949.坚定的友谊",
        "hardRate": "MEDIUM",
        "passRate": "52.23%",
        "problemsUrl": "https://leetcode.cn/problems/strong-friendship/",
        "solutionsUrl": "https://leetcode.cn/problems/strong-friendship/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1950.所有子数组最小值中的最大值",
        "hardRate": "MEDIUM",
        "passRate": "50.86%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-of-minimum-values-in-all-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-of-minimum-values-in-all-subarrays/solution",
        "problemsDesc": null,
        "isPlus": true
    }
]