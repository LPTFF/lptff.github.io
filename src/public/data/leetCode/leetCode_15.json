[
    {
        "problemsName": " 2101.引爆最多的炸弹",
        "hardRate": "MEDIUM",
        "passRate": "39.62%",
        "problemsUrl": "https://leetcode.cn/problems/detonate-the-maximum-bombs/",
        "solutionsUrl": "https://leetcode.cn/problems/detonate-the-maximum-bombs/solution",
        "problemsDesc": "<p>给你一个炸弹列表。一个炸弹的 <strong>爆炸范围</strong>&nbsp;定义为以炸弹为圆心的一个圆。</p>\n\n<p>炸弹用一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>bombs</code>&nbsp;表示，其中&nbsp;<code>bombs[i] = [x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub>]</code>&nbsp;。<code>x<sub>i</sub></code> 和&nbsp;<code>y<sub>i</sub></code>&nbsp;表示第 <code>i</code>&nbsp;个炸弹的 X 和 Y 坐标，<code>r<sub>i</sub></code>&nbsp;表示爆炸范围的 <strong>半径</strong>&nbsp;。</p>\n\n<p>你需要选择引爆 <strong>一个&nbsp;</strong>炸弹。当这个炸弹被引爆时，<strong>所有</strong> 在它爆炸范围内的炸弹都会被引爆，这些炸弹会进一步将它们爆炸范围内的其他炸弹引爆。</p>\n\n<p>给你数组&nbsp;<code>bombs</code>&nbsp;，请你返回在引爆&nbsp;<strong>一个</strong>&nbsp;炸弹的前提下，<strong>最多</strong>&nbsp;能引爆的炸弹数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-3.png\" style=\"width: 300px; height: 300px;\"></p>\n\n<pre><b>输入：</b>bombs = [[2,1,3],[6,1,4]]\n<b>输出：</b>2\n<strong>解释：</strong>\n上图展示了 2 个炸弹的位置和爆炸范围。\n如果我们引爆左边的炸弹，右边的炸弹不会被影响。\n但如果我们引爆右边的炸弹，两个炸弹都会爆炸。\n所以最多能引爆的炸弹数目是 max(1, 2) = 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-2.png\" style=\"width: 300px; height: 300px;\"></p>\n\n<pre><b>输入：</b>bombs = [[1,1,5],[10,10,5]]\n<b>输出：</b>1\n<strong>解释：\n</strong>引爆任意一个炸弹都不会引爆另一个炸弹。所以最多能引爆的炸弹数目为 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/07/desmos-eg1.png\" style=\"width: 300px; height: 300px;\"></p>\n\n<pre><b>输入：</b>bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]\n<b>输出：</b>5\n<strong>解释：</strong>\n最佳引爆炸弹为炸弹 0 ，因为：\n- 炸弹 0 引爆炸弹 1 和 2 。红色圆表示炸弹 0 的爆炸范围。\n- 炸弹 2 引爆炸弹 3 。蓝色圆表示炸弹 2 的爆炸范围。\n- 炸弹 3 引爆炸弹 4 。绿色圆表示炸弹 3 的爆炸范围。\n所以总共有 5 个炸弹被引爆。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= bombs.length&nbsp;&lt;= 100</code></li>\n\t<li><code>bombs[i].length == 3</code></li>\n\t<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2102.序列顺序查询",
        "hardRate": "HARD",
        "passRate": "55.76%",
        "problemsUrl": "https://leetcode.cn/problems/sequentially-ordinal-rank-tracker/",
        "solutionsUrl": "https://leetcode.cn/problems/sequentially-ordinal-rank-tracker/solution",
        "problemsDesc": "<p>一个观光景点由它的名字&nbsp;<code>name</code> 和景点评分&nbsp;<code>score</code>&nbsp;组成，其中&nbsp;<code>name</code>&nbsp;是所有观光景点中&nbsp;<strong>唯一</strong>&nbsp;的字符串，<code>score</code>&nbsp;是一个整数。景点按照最好到最坏排序。景点评分 <strong>越高</strong>&nbsp;，这个景点越好。如果有两个景点的评分一样，那么 <strong>字典序较小</strong>&nbsp;的景点更好。</p>\n\n<p>你需要搭建一个系统，查询景点的排名。初始时系统里没有任何景点。这个系统支持：</p>\n\n<ul>\n\t<li><strong>添加</strong> 景点，每次添加 <strong>一个</strong> 景点。</li>\n\t<li><strong>查询 </strong>已经添加景点中第&nbsp;<code>i</code>&nbsp;<strong>好</strong>&nbsp;的景点，其中&nbsp;<code>i</code>&nbsp;是系统目前位置查询的次数（包括当前这一次）。\n\t<ul>\n\t\t<li>比方说，如果系统正在进行第 <code>4</code>&nbsp;次查询，那么需要返回所有已经添加景点中第 <code>4</code>&nbsp;好的。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>注意，测试数据保证&nbsp;<strong>任意查询时刻</strong>&nbsp;，查询次数都 <strong>不超过</strong>&nbsp;系统中景点的数目。</p>\n\n<p>请你实现&nbsp;<code>SORTracker</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>SORTracker()</code>&nbsp;初始化系统。</li>\n\t<li><code>void add(string name, int score)</code>&nbsp;向系统中添加一个名为&nbsp;<code>name</code> 评分为&nbsp;<code>score</code>&nbsp;的景点。</li>\n\t<li><code>string get()</code>&nbsp;查询第 <code>i</code>&nbsp;好的景点，其中 <code>i</code>&nbsp;是目前系统查询的次数（包括当前这次查询）。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"SORTracker\", \"add\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"get\"]\n[[], [\"bradford\", 2], [\"branford\", 3], [], [\"alps\", 2], [], [\"orland\", 2], [], [\"orlando\", 3], [], [\"alpine\", 2], [], []]\n<strong>输出：</strong>\n[null, null, null, \"branford\", null, \"alps\", null, \"bradford\", null, \"bradford\", null, \"bradford\", \"orland\"]\n\n<strong>解释：</strong>\nSORTracker tracker = new SORTracker(); // 初始化系统\ntracker.add(\"bradford\", 2); // 添加 name=\"bradford\" 且 score=2 的景点。\ntracker.add(\"branford\", 3); // 添加 name=\"branford\" 且 score=3 的景点。\ntracker.get();              // 从好带坏的景点为：branford ，bradford 。\n                            // 注意到 branford 比 bradford 好，因为它的 <strong>评分更高</strong> (3 &gt; 2) 。\n                            // 这是第 1 次调用 get() ，所以返回最好的景点：\"branford\" 。\ntracker.add(\"alps\", 2);     // 添加 name=\"alps\" 且 score=2 的景点。\ntracker.get();              // 从好到坏的景点为：branford, alps, bradford 。\n                            // 注意 alps 比 bradford 好，虽然它们评分相同，都为 2 。\n                            // 这是因为 \"alps\" <strong>字典序</strong>&nbsp;比 \"bradford\" 小。\n                            // 返回第 2 好的地点 \"alps\" ，因为当前为第 2 次调用 get() 。\ntracker.add(\"orland\", 2);   // 添加 name=\"orland\" 且 score=2 的景点。\ntracker.get();              // 从好到坏的景点为：branford, alps, bradford, orland 。\n                            // 返回 \"bradford\" ，因为当前为第 3 次调用 get() 。\ntracker.add(\"orlando\", 3);  // 添加 name=\"orlando\" 且 score=3 的景点。\ntracker.get();              // 从好到坏的景点为：branford, orlando, alps, bradford, orland 。\n                            // 返回 \"bradford\".\ntracker.add(\"alpine\", 2);   // 添加 name=\"alpine\" 且 score=2 的景点。\ntracker.get();              // 从好到坏的景点为：branford, orlando, alpine, alps, bradford, orland 。\n                            // 返回 \"bradford\" 。\ntracker.get();              // 从好到坏的景点为：branford, orlando, alpine, alps, bradford, orland 。\n                            // 返回 \"orland\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>name</code>&nbsp;只包含小写英文字母，且每个景点名字互不相同。</li>\n\t<li><code>1 &lt;= name.length &lt;= 10</code></li>\n\t<li><code>1 &lt;= score &lt;= 10<sup>5</sup></code></li>\n\t<li>任意时刻，调用&nbsp;<code>get</code>&nbsp;的次数都不超过调用&nbsp;<code>add</code>&nbsp;的次数。</li>\n\t<li><strong>总共</strong>&nbsp;调用&nbsp;<code>add</code> 和&nbsp;<code>get</code>&nbsp;不超过&nbsp;<code>4 * 10<sup>4</sup></code>&nbsp;</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2103.环和杆",
        "hardRate": "EASY",
        "passRate": "79.62%",
        "problemsUrl": "https://leetcode.cn/problems/rings-and-rods/",
        "solutionsUrl": "https://leetcode.cn/problems/rings-and-rods/solution",
        "problemsDesc": "<p>总计有 <code>n</code> 个环，环的颜色可以是红、绿、蓝中的一种。这些环分布穿在 10 根编号为 <code>0</code> 到 <code>9</code> 的杆上。</p>\n\n<p>给你一个长度为 <code>2n</code> 的字符串 <code>rings</code> ，表示这 <code>n</code> 个环在杆上的分布。<code>rings</code> 中每两个字符形成一个 <strong>颜色位置对</strong> ，用于描述每个环：</p>\n\n<ul>\n\t<li>第 <code>i</code> 对中的 <strong>第一个</strong> 字符表示第 <code>i</code> 个环的 <strong>颜色</strong>（<code>'R'</code>、<code>'G'</code>、<code>'B'</code>）。</li>\n\t<li>第 <code>i</code> 对中的 <strong>第二个</strong> 字符表示第 <code>i</code> 个环的 <strong>位置</strong>，也就是位于哪根杆上（<code>'0'</code> 到 <code>'9'</code>）。</li>\n</ul>\n\n<p>例如，<code>\"R3G2B1\"</code> 表示：共有 <code>n == 3</code> 个环，红色的环在编号为 3 的杆上，绿色的环在编号为 2 的杆上，蓝色的环在编号为 1 的杆上。</p>\n\n<p>找出所有集齐 <strong>全部三种颜色</strong> 环的杆，并返回这种杆的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/23/ex1final.png\" style=\"width: 258px; height: 130px;\">\n<pre><strong>输入：</strong>rings = \"B0B6G0R6R0R6G9\"\n<strong>输出：</strong>1\n<strong>解释：</strong>\n- 编号 0 的杆上有 3 个环，集齐全部颜色：红、绿、蓝。\n- 编号 6 的杆上有 3 个环，但只有红、蓝两种颜色。\n- 编号 9 的杆上只有 1 个绿色环。\n因此，集齐全部三种颜色环的杆的数目为 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/23/ex2final.png\" style=\"width: 266px; height: 130px;\">\n<pre><strong>输入：</strong>rings = \"B0R0G0R9R0B0G0\"\n<strong>输出：</strong>1\n<strong>解释：</strong>\n- 编号 0 的杆上有 6 个环，集齐全部颜色：红、绿、蓝。\n- 编号 9 的杆上只有 1 个红色环。\n因此，集齐全部三种颜色环的杆的数目为 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>rings = \"G4\"\n<strong>输出：</strong>0\n<strong>解释：</strong>\n只给了一个环，因此，不存在集齐全部三种颜色环的杆。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rings.length == 2 * n</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li>如 <code>i</code> 是 <strong>偶数</strong> ，则&nbsp;<code>rings[i]</code> 的值可以取 <code>'R'</code>、<code>'G'</code> 或 <code>'B'</code>（下标从 <strong>0</strong> 开始计数）</li>\n\t<li>如 <code>i</code> 是 <strong>奇数</strong> ，则&nbsp;<code>rings[i]</code> 的值可以取 <code>'0'</code> 到 <code>'9'</code> 中的一个数字（下标从 <strong>0</strong> 开始计数）</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2104.子数组范围和",
        "hardRate": "MEDIUM",
        "passRate": "62.89%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-subarray-ranges/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-subarray-ranges/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。<code>nums</code> 中，子数组的 <strong>范围</strong> 是子数组中最大元素和最小元素的差值。</p>\n\n<p>返回 <code>nums</code> 中 <strong>所有</strong> 子数组范围的 <strong>和</strong> <em>。</em></p>\n\n<p>子数组是数组中一个连续 <strong>非空</strong> 的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>4\n<strong>解释：</strong>nums 的 6 个子数组如下所示：\n[1]，范围 = 最大 - 最小 = 1 - 1 = 0 \n[2]，范围 = 2 - 2 = 0\n[3]，范围 = 3 - 3 = 0\n[1,2]，范围 = 2 - 1 = 1\n[2,3]，范围 = 3 - 2 = 1\n[1,2,3]，范围 = 3 - 1 = 2\n所有范围的和是 0 + 0 + 0 + 1 + 1 + 2 = 4</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,3]\n<strong>输出：</strong>4\n<strong>解释：</strong>nums 的 6 个子数组如下所示：\n[1]，范围 = 最大 - 最小 = 1 - 1 = 0\n[3]，范围 = 3 - 3 = 0\n[3]，范围 = 3 - 3 = 0\n[1,3]，范围 = 3 - 1 = 2\n[3,3]，范围 = 3 - 3 = 0\n[1,3,3]，范围 = 3 - 1 = 2\n所有范围的和是 0 + 0 + 0 + 2 + 0 + 2 = 4\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,-2,-3,4,1]\n<strong>输出：</strong>59\n<strong>解释：</strong>nums 中所有子数组范围的和是 59\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以设计一种时间复杂度为 <code>O(n)</code> 的解决方案吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2105.给植物浇水 II",
        "hardRate": "MEDIUM",
        "passRate": "52.98%",
        "problemsUrl": "https://leetcode.cn/problems/watering-plants-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/watering-plants-ii/solution",
        "problemsDesc": "<p>Alice 和 Bob 打算给花园里的 <code>n</code> 株植物浇水。植物排成一行，从左到右进行标记，编号从 <code>0</code> 到 <code>n - 1</code> 。其中，第 <code>i</code> 株植物的位置是 <code>x = i</code> 。</p>\n\n<p>每一株植物都需要浇特定量的水。Alice 和 Bob 每人有一个水罐，<strong>最初是满的 </strong>。他们按下面描述的方式完成浇水：</p>\n\n<ul>\n\t<li>&nbsp;Alice 按 <strong>从左到右</strong> 的顺序给植物浇水，从植物 <code>0</code> 开始。Bob 按 <strong>从右到左</strong> 的顺序给植物浇水，从植物 <code>n - 1</code> 开始。他们 <strong>同时</strong> 给植物浇水。</li>\n\t<li>如果没有足够的水 <strong>完全</strong> 浇灌下一株植物，他 / 她会立即重新灌满浇水罐。</li>\n\t<li>不管植物需要多少水，浇水所耗费的时间都是一样的。</li>\n\t<li><strong>不能</strong> 提前重新灌满水罐。</li>\n\t<li>每株植物都可以由 Alice 或者 Bob 来浇水。</li>\n\t<li>如果 Alice 和 Bob 到达同一株植物，那么当前水罐中水更多的人会给这株植物浇水。如果他俩水量相同，那么 Alice 会给这株植物浇水。</li>\n</ul>\n\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>plants</code> ，数组由 <code>n</code> 个整数组成。其中，<code>plants[i]</code> 为第 <code>i</code> 株植物需要的水量。另有两个整数 <code>capacityA</code> 和&nbsp;<code>capacityB</code> 分别表示 Alice 和 Bob 水罐的容量。返回两人浇灌所有植物过程中重新灌满水罐的 <strong>次数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>plants = [2,2,3,3], capacityA = 5, capacityB = 5\n<strong>输出：</strong>1\n<strong>解释：</strong>\n- 最初，Alice 和 Bob 的水罐中各有 5 单元水。\n- Alice 给植物 0 浇水，Bob 给植物 3 浇水。\n- Alice 和 Bob 现在分别剩下 3 单元和 2 单元水。\n- Alice 有足够的水给植物 1 ，所以她直接浇水。Bob 的水不够给植物 2 ，所以他先重新装满水，再浇水。\n所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 + 0 + 1 + 0 = 1 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>plants = [2,2,3,3], capacityA = 3, capacityB = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>\n- 最初，Alice 的水罐中有 3 单元水，Bob 的水罐中有 4 单元水。\n- Alice 给植物 0 浇水，Bob 给植物 3 浇水。\n- Alice 和 Bob 现在都只有 1 单元水，并分别需要给植物 1 和植物 2 浇水。\n- 由于他们的水量均不足以浇水，所以他们重新灌满水罐再进行浇水。\n所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 + 1 + 1 + 0 = 2 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>plants = [5], capacityA = 10, capacityB = 8\n<strong>输出：</strong>0\n<strong>解释：</strong>\n- 只有一株植物\n- Alice 的水罐有 10 单元水，Bob 的水罐有 8 单元水。因此 Alice 的水罐中水更多，她会给这株植物浇水。\n所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == plants.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= plants[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>max(plants[i]) &lt;= capacityA, capacityB &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2106.摘水果",
        "hardRate": "HARD",
        "passRate": "45.10%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/solution",
        "problemsDesc": "<p>在一个无限的 x 坐标轴上，有许多水果分布在其中某些位置。给你一个二维整数数组 <code>fruits</code> ，其中 <code>fruits[i] = [position<sub>i</sub>, amount<sub>i</sub>]</code> 表示共有 <code>amount<sub>i</sub></code> 个水果放置在 <code>position<sub>i</sub></code> 上。<code>fruits</code> 已经按 <code>position<sub>i</sub></code> <strong>升序排列</strong> ，每个 <code>position<sub>i</sub></code> <strong>互不相同</strong> 。</p>\n\n<p>另给你两个整数 <code>startPos</code> 和 <code>k</code> 。最初，你位于 <code>startPos</code> 。从任何位置，你可以选择 <strong>向左或者向右</strong> 走。在 x 轴上每移动 <strong>一个单位</strong> ，就记作 <strong>一步</strong> 。你总共可以走 <strong>最多</strong> <code>k</code> 步。你每达到一个位置，都会摘掉全部的水果，水果也将从该位置消失（不会再生）。</p>\n\n<p>返回你可以摘到水果的 <strong>最大总数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/21/1.png\" style=\"width: 472px; height: 115px;\">\n<pre><strong>输入：</strong>fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4\n<strong>输出：</strong>9\n<strong>解释：</strong>\n最佳路线为：\n- 向右移动到位置 6 ，摘到 3 个水果\n- 向右移动到位置 8 ，摘到 6 个水果\n移动 3 步，共摘到 3 + 6 = 9 个水果\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/21/2.png\" style=\"width: 512px; height: 129px;\">\n<pre><strong>输入：</strong>fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4\n<strong>输出：</strong>14\n<strong>解释：</strong>\n可以移动最多 k = 4 步，所以无法到达位置 0 和位置 10 。\n最佳路线为：\n- 在初始位置 5 ，摘到 7 个水果\n- 向左移动到位置 4 ，摘到 1 个水果\n- 向右移动到位置 6 ，摘到 2 个水果\n- 向右移动到位置 7 ，摘到 4 个水果\n移动 1 + 3 = 4 步，共摘到 7 + 1 + 2 + 4 = 14 个水果\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/21/3.png\" style=\"width: 476px; height: 100px;\">\n<pre><strong>输入：</strong>fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2\n<strong>输出：</strong>0\n<strong>解释：</strong>\n最多可以移动 k = 2 步，无法到达任一有水果的地方\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= fruits.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>fruits[i].length == 2</code></li>\n\t<li><code>0 &lt;= startPos, position<sub>i</sub> &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li>对于任意 <code>i &gt; 0</code> ，<code>position<sub>i-1</sub> &lt; position<sub>i</sub></code> 均成立（下标从 <strong>0</strong> 开始计数）</li>\n\t<li><code>1 &lt;= amount<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 2 * 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2107.分享 K 个糖果后独特口味的数量",
        "hardRate": "MEDIUM",
        "passRate": "38.97%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-unique-flavors-after-sharing-k-candies/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-unique-flavors-after-sharing-k-candies/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2108.找出数组中的第一个回文字符串",
        "hardRate": "EASY",
        "passRate": "77.53%",
        "problemsUrl": "https://leetcode.cn/problems/find-first-palindromic-string-in-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-first-palindromic-string-in-the-array/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>words</code> ，找出并返回数组中的 <strong>第一个回文字符串</strong> 。如果不存在满足要求的字符串，返回一个 <strong>空字符串</strong><em> </em><code>\"\"</code> 。</p>\n\n<p><strong>回文字符串</strong> 的定义为：如果一个字符串正着读和反着读一样，那么该字符串就是一个 <strong>回文字符串</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]\n<strong>输出：</strong>\"ada\"\n<strong>解释：</strong>第一个回文字符串是 \"ada\" 。\n注意，\"racecar\" 也是回文字符串，但它不是第一个。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"notapalindrome\",\"racecar\"]\n<strong>输出：</strong>\"racecar\"\n<strong>解释：</strong>第一个也是唯一一个回文字符串是 \"racecar\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"def\",\"ghi\"]\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>不存在回文字符串，所以返回一个空字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><code>words[i]</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2109.向字符串添加空格",
        "hardRate": "MEDIUM",
        "passRate": "61.55%",
        "problemsUrl": "https://leetcode.cn/problems/adding-spaces-to-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/adding-spaces-to-a-string/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，以及一个下标从 <strong>0</strong> 开始的整数数组 <code>spaces</code> 。</p>\n\n<p>数组 <code>spaces</code> 描述原字符串中需要添加空格的下标。每个空格都应该插入到给定索引处的字符值 <strong>之前</strong> 。</p>\n\n<ul>\n\t<li>例如，<code>s = \"EnjoyYourCoffee\"</code> 且 <code>spaces = [5, 9]</code> ，那么我们需要在 <code>'Y'</code> 和 <code>'C'</code> 之前添加空格，这两个字符分别位于下标 <code>5</code> 和下标 <code>9</code> 。因此，最终得到 <code>\"Enjoy <em><strong>Y</strong></em>our <em><strong>C</strong></em>offee\"</code> 。</li>\n</ul>\n\n<p>请你添加空格，并返回修改后的字符串<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"LeetcodeHelpsMeLearn\", spaces = [8,13,15]\n<strong>输出：</strong>\"Leetcode Helps Me Learn\"\n<strong>解释：</strong>\n下标 8、13 和 15 对应 \"Leetcode<em><strong>H</strong></em>elps<em><strong>M</strong></em>e<em><strong>L</strong></em>earn\" 中加粗斜体字符。\n接着在这些字符前添加空格。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"icodeinpython\", spaces = [1,5,7,9]\n<strong>输出：</strong>\"i code in py thon\"\n<strong>解释：</strong>\n下标 1、5、7 和 9 对应 \"i<em><strong>c</strong></em>ode<em><strong>i</strong></em>n<em><strong>p</strong></em>y<em><strong>t</strong></em>hon\" 中加粗斜体字符。\n接着在这些字符前添加空格。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"spacing\", spaces = [0,1,2,3,4,5,6]\n<strong>输出：</strong>\" s p a c i n g\"\n<strong>解释：</strong>\n字符串的第一个字符前可以添加空格。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> 仅由大小写英文字母组成</li>\n\t<li><code>1 &lt;= spaces.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= spaces[i] &lt;= s.length - 1</code></li>\n\t<li><code>spaces</code> 中的所有值 <strong>严格递增</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2110.股票平滑下跌阶段的数目",
        "hardRate": "MEDIUM",
        "passRate": "52.80%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-smooth-descent-periods-of-a-stock/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-smooth-descent-periods-of-a-stock/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>prices</code>&nbsp;，表示一支股票的历史每日股价，其中&nbsp;<code>prices[i]</code>&nbsp;是这支股票第&nbsp;<code>i</code>&nbsp;天的价格。</p>\n\n<p>一个 <strong>平滑下降的阶段</strong>&nbsp;定义为：对于&nbsp;<strong>连续一天或者多天</strong>&nbsp;，每日股价都比 <strong>前一日股价恰好少 </strong><code>1</code>&nbsp;，这个阶段第一天的股价没有限制。</p>\n\n<p>请你返回 <strong>平滑下降阶段</strong>&nbsp;的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>prices = [3,2,1,4]\n<b>输出：</b>7\n<b>解释：</b>总共有 7 个平滑下降阶段：\n[3], [2], [1], [4], [3,2], [2,1] 和 [3,2,1]\n注意，仅一天按照定义也是平滑下降阶段。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>prices = [8,6,7,7]\n<b>输出：</b>4\n<b>解释：</b>总共有 4 个连续平滑下降阶段：[8], [6], [7] 和 [7]\n由于 8 - 6 ≠ 1 ，所以 [8,6] 不是平滑下降阶段。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>prices = [1]\n<b>输出：</b>1\n<b>解释：</b>总共有 1 个平滑下降阶段：[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= prices[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2111.使数组 K 递增的最少操作次数",
        "hardRate": "HARD",
        "passRate": "35.01%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-array-k-increasing/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-array-k-increasing/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始包含 <code>n</code>&nbsp;个正整数的数组&nbsp;<code>arr</code>&nbsp;，和一个正整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>如果对于每个满足&nbsp;<code>k &lt;= i &lt;= n-1</code>&nbsp;的下标&nbsp;<code>i</code>&nbsp;，都有&nbsp;<code>arr[i-k] &lt;= arr[i]</code>&nbsp;，那么我们称&nbsp;<code>arr</code>&nbsp;是 <strong>K</strong>&nbsp;<strong>递增</strong> 的。</p>\n\n<ul>\n\t<li>比方说，<code>arr = [4, 1, 5, 2, 6, 2]</code>&nbsp;对于&nbsp;<code>k = 2</code>&nbsp;是 K 递增的，因为：\n\n\t<ul>\n\t\t<li><code>arr[0] &lt;= arr[2] (4 &lt;= 5)</code></li>\n\t\t<li><code>arr[1] &lt;= arr[3] (1 &lt;= 2)</code></li>\n\t\t<li><code>arr[2] &lt;= arr[4] (5 &lt;= 6)</code></li>\n\t\t<li><code>arr[3] &lt;= arr[5] (2 &lt;= 2)</code></li>\n\t</ul>\n\t</li>\n\t<li>但是，相同的数组&nbsp;<code>arr</code>&nbsp;对于&nbsp;<code>k = 1</code>&nbsp;不是 K 递增的（因为&nbsp;<code>arr[0] &gt; arr[1]</code>），对于&nbsp;<code>k = 3</code>&nbsp;也不是 K 递增的（因为&nbsp;<code>arr[0] &gt; arr[3]</code>&nbsp;）。</li>\n</ul>\n\n<p>每一次 <strong>操作</strong>&nbsp;中，你可以选择一个下标&nbsp;<code>i</code> 并将&nbsp;<code>arr[i]</code> <strong>改成任意&nbsp;</strong>正整数。</p>\n\n<p>请你返回对于给定的 <code>k</code>&nbsp;，使数组变成 K 递增的 <strong>最少操作次数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>arr = [5,4,3,2,1], k = 1\n<b>输出：</b>4\n<strong>解释：\n</strong>对于 k = 1 ，数组最终必须变成非递减的。\n可行的 K 递增结果数组为 [5,<em><strong>6</strong></em>,<em><strong>7</strong></em>,<em><strong>8</strong></em>,<em><strong>9</strong></em>]，[<em><strong>1</strong></em>,<em><strong>1</strong></em>,<em><strong>1</strong></em>,<em><strong>1</strong></em>,1]，[<em><strong>2</strong></em>,<em><strong>2</strong></em>,3,<em><strong>4</strong></em>,<em><strong>4</strong></em>] 。它们都需要 4 次操作。\n次优解是将数组变成比方说 [<em><strong>6</strong></em>,<em><strong>7</strong></em>,<em><strong>8</strong></em>,<em><strong>9</strong></em>,<em><strong>10</strong></em>] ，因为需要 5 次操作。\n显然我们无法使用少于 4 次操作将数组变成 K 递增的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>arr = [4,1,5,2,6,2], k = 2\n<b>输出：</b>0\n<strong>解释：</strong>\n这是题目描述中的例子。\n对于每个满足 2 &lt;= i &lt;= 5 的下标 i ，有 arr[i-2] &lt;=<b> </b>arr[i] 。\n由于给定数组已经是 K 递增的，我们不需要进行任何操作。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [4,1,5,2,6,2], k = 3\n<b>输出：</b>2\n<strong>解释：</strong>\n下标 3 和 5 是仅有的 3 &lt;= i &lt;= 5 且不满足 arr[i-3] &lt;= arr[i] 的下标。\n将数组变成 K 递增的方法之一是将 arr[3] 变为 4 ，且将 arr[5] 变成 5 。\n数组变为 [4,1,5,<em><strong>4</strong></em>,6,<em><strong>5</strong></em>] 。\n可能有其他方法将数组变为 K 递增的，但没有任何一种方法需要的操作次数小于 2 次。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i], k &lt;= arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2112.最繁忙的机场",
        "hardRate": "MEDIUM",
        "passRate": "68.38%",
        "problemsUrl": "https://leetcode.cn/problems/the-airport-with-the-most-traffic/",
        "solutionsUrl": "https://leetcode.cn/problems/the-airport-with-the-most-traffic/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2113.查询删除和添加元素后的数组",
        "hardRate": "MEDIUM",
        "passRate": "61.64%",
        "problemsUrl": "https://leetcode.cn/problems/elements-in-array-after-removing-and-replacing-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/elements-in-array-after-removing-and-replacing-elements/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2114.句子中的最多单词数",
        "hardRate": "EASY",
        "passRate": "84.96%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-words-found-in-sentences/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-words-found-in-sentences/solution",
        "problemsDesc": "<p>一个 <strong>句子</strong>&nbsp;由一些 <strong>单词</strong>&nbsp;以及它们之间的单个空格组成，句子的开头和结尾不会有多余空格。</p>\n\n<p>给你一个字符串数组&nbsp;<code>sentences</code>&nbsp;，其中&nbsp;<code>sentences[i]</code>&nbsp;表示单个 <strong>句子</strong>&nbsp;。</p>\n\n<p>请你返回单个句子里 <strong>单词的最多数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>sentences = [\"alice and bob love leetcode\", \"i think so too\", <em><strong>\"this is great thanks very much\"</strong></em>]\n<b>输出：</b>6\n<b>解释：</b>\n- 第一个句子 \"alice and bob love leetcode\" 总共有 5 个单词。\n- 第二个句子 \"i think so too\" 总共有 4 个单词。\n- 第三个句子 \"this is great thanks very much\" 总共有 6 个单词。\n所以，单个句子中有最多单词数的是第三个句子，总共有 6 个单词。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>sentences = [\"please wait\", <em><strong>\"continue to fight\"</strong></em>, <em><strong>\"continue to win\"</strong></em>]\n<b>输出：</b>3\n<b>解释：</b>可能有多个句子有相同单词数。\n这个例子中，第二个句子和第三个句子（加粗斜体）有相同数目的单词数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentences.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= sentences[i].length &lt;= 100</code></li>\n\t<li><code>sentences[i]</code>&nbsp;只包含小写英文字母和&nbsp;<code>' '</code>&nbsp;。</li>\n\t<li><code>sentences[i]</code>&nbsp;的开头和结尾都没有空格。</li>\n\t<li><code>sentences[i]</code>&nbsp;中所有单词由单个空格隔开。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2115.从给定原材料中找到所有可以做出的菜",
        "hardRate": "MEDIUM",
        "passRate": "42.47%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-possible-recipes-from-given-supplies/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-possible-recipes-from-given-supplies/solution",
        "problemsDesc": "<p>你有 <code>n</code>&nbsp;道不同菜的信息。给你一个字符串数组&nbsp;<code>recipes</code>&nbsp;和一个二维字符串数组&nbsp;<code>ingredients</code>&nbsp;。第&nbsp;<code>i</code>&nbsp;道菜的名字为&nbsp;<code>recipes[i]</code>&nbsp;，如果你有它&nbsp;<strong>所有</strong>&nbsp;的原材料&nbsp;<code>ingredients[i]</code>&nbsp;，那么你可以&nbsp;<strong>做出</strong>&nbsp;这道菜。一道菜的原材料可能是&nbsp;<strong>另一道</strong>&nbsp;菜，也就是说&nbsp;<code>ingredients[i]</code>&nbsp;可能包含&nbsp;<code>recipes</code>&nbsp;中另一个字符串。</p>\n\n<p>同时给你一个字符串数组&nbsp;<code>supplies</code>&nbsp;，它包含你初始时拥有的所有原材料，每一种原材料你都有无限多。</p>\n\n<p>请你返回你可以做出的所有菜。你可以以 <strong>任意顺序</strong>&nbsp;返回它们。</p>\n\n<p>注意两道菜在它们的原材料中可能互相包含。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\n<b>输出：</b>[\"bread\"]\n<strong>解释：</strong>\n我们可以做出 \"bread\" ，因为我们有原材料 \"yeast\" 和 \"flour\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\n<b>输出：</b>[\"bread\",\"sandwich\"]\n<strong>解释：</strong>\n我们可以做出 \"bread\" ，因为我们有原材料 \"yeast\" 和 \"flour\" 。\n我们可以做出 \"sandwich\" ，因为我们有原材料 \"meat\" 且可以做出原材料 \"bread\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\n<b>输出：</b>[\"bread\",\"sandwich\",\"burger\"]\n<strong>解释：</strong>\n我们可以做出 \"bread\" ，因为我们有原材料 \"yeast\" 和 \"flour\" 。\n我们可以做出 \"sandwich\" ，因为我们有原材料 \"meat\" 且可以做出原材料 \"bread\" 。\n我们可以做出 \"burger\" ，因为我们有原材料 \"meat\" 且可以做出原材料 \"bread\" 和 \"sandwich\" 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\"]\n<b>输出：</b>[]\n<strong>解释：</strong>\n我们没法做出任何菜，因为我们只有原材料 \"yeast\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == recipes.length == ingredients.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= ingredients[i].length, supplies.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= recipes[i].length, ingredients[i][j].length, supplies[k].length &lt;= 10</code></li>\n\t<li><code>recipes[i], ingredients[i][j]</code>&nbsp;和&nbsp;<code>supplies[k]</code>&nbsp;只包含小写英文字母。</li>\n\t<li>所有&nbsp;<code>recipes</code> 和&nbsp;<code>supplies</code>&nbsp;中的值互不相同。</li>\n\t<li><code>ingredients[i]</code>&nbsp;中的字符串互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2116.判断一个括号字符串是否有效",
        "hardRate": "MEDIUM",
        "passRate": "32.02%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-a-parentheses-string-can-be-valid/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-a-parentheses-string-can-be-valid/solution",
        "problemsDesc": "<p>一个括号字符串是只由&nbsp;<code>'('</code> 和&nbsp;<code>')'</code>&nbsp;组成的&nbsp;<strong>非空</strong>&nbsp;字符串。如果一个字符串满足下面 <b>任意</b>&nbsp;一个条件，那么它就是有效的：</p>\n\n<ul>\n\t<li>字符串为&nbsp;<code>()</code>.</li>\n\t<li>它可以表示为 <code>AB</code><span style=\"\">（</span><code>A</code>&nbsp;与&nbsp;<code>B</code>&nbsp;连接），其中<code>A</code> 和&nbsp;<code>B</code>&nbsp;都是有效括号字符串。</li>\n\t<li>它可以表示为&nbsp;<code>(A)</code>&nbsp;，其中&nbsp;<code>A</code>&nbsp;是一个有效括号字符串。</li>\n</ul>\n\n<p>给你一个括号字符串&nbsp;<code>s</code>&nbsp;和一个字符串&nbsp;<code>locked</code>&nbsp;，两者长度都为&nbsp;<code>n</code>&nbsp;。<code>locked</code>&nbsp;是一个二进制字符串，只包含&nbsp;<code>'0'</code>&nbsp;和&nbsp;<code>'1'</code>&nbsp;。对于&nbsp;<code>locked</code>&nbsp;中&nbsp;<strong>每一个</strong>&nbsp;下标&nbsp;<code>i</code> ：</p>\n\n<ul>\n\t<li>如果&nbsp;<code>locked[i]</code>&nbsp;是&nbsp;<code>'1'</code>&nbsp;，你 <strong>不能</strong>&nbsp;改变&nbsp;<code>s[i]</code>&nbsp;。</li>\n\t<li>如果&nbsp;<code>locked[i]</code>&nbsp;是&nbsp;<code>'0'</code>&nbsp;，你&nbsp;<strong>可以</strong>&nbsp;将&nbsp;<code>s[i]</code>&nbsp;变为&nbsp;<code>'('</code>&nbsp;或者&nbsp;<code>')'</code>&nbsp;。</li>\n</ul>\n\n<p>如果你可以将 <code>s</code>&nbsp;变为有效括号字符串，请你返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/06/eg1.png\" style=\"width: 311px; height: 101px;\" /></p>\n\n<pre>\n<b>输入：</b>s = \"))()))\", locked = \"010100\"\n<b>输出：</b>true\n<b>解释：</b>locked[1] == '1' 和 locked[3] == '1' ，所以我们无法改变 s[1] 或者 s[3] 。\n我们可以将 s[0] 和 s[4] 变为 '(' ，不改变 s[2] 和 s[5] ，使 s 变为有效字符串。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"()()\", locked = \"0000\"\n<b>输出：</b>true\n<b>解释：</b>我们不需要做任何改变，因为 s 已经是有效字符串了。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \")\", locked = \"0\"\n<b>输出：</b>false\n<b>解释：</b>locked 允许改变 s[0] 。\n但无论将 s[0] 变为 '(' 或者 ')' 都无法使 s 变为有效字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == s.length == locked.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code>&nbsp;要么是&nbsp;<code>'('</code>&nbsp;要么是&nbsp;<code>')'</code>&nbsp;。</li>\n\t<li><code>locked[i]</code> 要么是&nbsp;<code>'0'</code>&nbsp;要么是&nbsp;<code>'1'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2117.一个区间内所有数乘积的缩写",
        "hardRate": "HARD",
        "passRate": "30.72%",
        "problemsUrl": "https://leetcode.cn/problems/abbreviating-the-product-of-a-range/",
        "solutionsUrl": "https://leetcode.cn/problems/abbreviating-the-product-of-a-range/solution",
        "problemsDesc": "<p>给你两个正整数&nbsp;<code>left</code>&nbsp;和&nbsp;<code>right</code>&nbsp;，满足&nbsp;<code>left &lt;= right</code>&nbsp;。请你计算&nbsp;<strong>闭区间</strong>&nbsp;<code>[left, right]</code>&nbsp;中所有整数的&nbsp;<strong>乘积</strong>&nbsp;。</p>\n\n<p>由于乘积可能非常大，你需要将它按照以下步骤 <strong>缩写</strong>&nbsp;：</p>\n\n<ol>\n\t<li>统计乘积中&nbsp;<strong>后缀</strong> 0 的数目，并 <strong>移除</strong> 这些 0 ，将这个数目记为&nbsp;<code>C</code>&nbsp;。\n\n\t<ul>\n\t\t<li>比方说，<code>1000</code>&nbsp;中有 <code>3</code> 个后缀 0&nbsp;，<code>546</code>&nbsp;中没有后缀 0 。</li>\n\t</ul>\n\t</li>\n\t<li>将乘积中剩余数字的位数记为&nbsp;<code>d</code>&nbsp;。如果&nbsp;<code>d &gt; 10</code>&nbsp;，那么将乘积表示为&nbsp;<code>&lt;pre&gt;...&lt;suf&gt;</code>&nbsp;的形式，其中&nbsp;<code>&lt;pre&gt;</code>&nbsp;表示乘积最 <strong>开始</strong>&nbsp;的 <code>5</code>&nbsp;个数位，<code>&lt;suf&gt;</code>&nbsp;表示删除后缀 0 <strong>之后</strong>&nbsp;结尾的 <code>5</code>&nbsp;个数位。如果&nbsp;<code>d &lt;= 10</code>&nbsp;，我们不对它做修改。\n\t<ul>\n\t\t<li>比方说，我们将&nbsp;<code>1234567654321</code>&nbsp;表示为&nbsp;<code>12345...54321</code>&nbsp;，但是&nbsp;<code>1234567</code>&nbsp;仍然表示为&nbsp;<code>1234567</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n\t<li>最后，将乘积表示为 <strong>字符串</strong>&nbsp;<code>\"&lt;pre&gt;...&lt;suf&gt;eC\"</code>&nbsp;。\n\t<ul>\n\t\t<li>比方说，<code>12345678987600000</code>&nbsp;被表示为&nbsp;<code>\"12345...89876e5\"</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n</ol>\n\n<p>请你返回一个字符串，表示 <strong>闭区间</strong>&nbsp;<code>[left, right]</code>&nbsp;中所有整数&nbsp;<strong>乘积</strong>&nbsp;的&nbsp;<strong>缩写</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>left = 1, right = 4\n<b>输出：</b>\"24e0\"\n<strong>解释：</strong>\n乘积为 1 × 2 × 3 × 4 = 24 。\n由于没有后缀 0 ，所以 24 保持不变，缩写的结尾为 \"e0\" 。\n因为乘积的结果是 2 位数，小于 10 ，所欲我们不进一步将它缩写。\n所以，最终将乘积表示为 \"24e0\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>left = 2, right = 11\n<strong>输出：</strong>\"399168e2\"\n<strong>解释：</strong>乘积为 39916800 。\n有 2 个后缀 0 ，删除后得到 399168 。缩写的结尾为 \"e2\" 。 \n删除后缀 0 后是 6 位数，不需要进一步缩写。 \n所以，最终将乘积表示为 \"399168e2\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>left = 371, right = 375\n<strong>输出：</strong>\"7219856259e3\"\n<strong>解释：</strong>乘积为 7219856259000 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= left &lt;= right &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2118.建立方程",
        "hardRate": "HARD",
        "passRate": "54.54%",
        "problemsUrl": "https://leetcode.cn/problems/build-the-equation/",
        "solutionsUrl": "https://leetcode.cn/problems/build-the-equation/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2119.反转两次的数字",
        "hardRate": "EASY",
        "passRate": "73.67%",
        "problemsUrl": "https://leetcode.cn/problems/a-number-after-a-double-reversal/",
        "solutionsUrl": "https://leetcode.cn/problems/a-number-after-a-double-reversal/solution",
        "problemsDesc": "<p><strong>反转</strong> 一个整数意味着倒置它的所有位。</p>\n\n<ul>\n\t<li>例如，反转 <code>2021</code> 得到 <code>1202</code> 。反转 <code>12300</code> 得到 <code>321</code> ，<strong>不保留前导零</strong> 。</li>\n</ul>\n\n<p>给你一个整数 <code>num</code> ，<strong>反转</strong> <code>num</code> 得到 <code>reversed1</code> ，<strong>接着反转</strong> <code>reversed1</code> 得到 <code>reversed2</code> 。如果 <code>reversed2</code> 等于 <code>num</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 526\n<strong>输出：</strong>true\n<strong>解释：</strong>反转 num 得到 625 ，接着反转 625 得到 526 ，等于 num 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 1800\n<strong>输出：</strong>false\n<strong>解释：</strong>反转 num 得到 81 ，接着反转 81 得到 18 ，不等于 num 。 </pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = 0\n<strong>输出：</strong>true\n<strong>解释：</strong>反转 num 得到 0 ，接着反转 0 得到 0 ，等于 num 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2120.执行所有后缀指令",
        "hardRate": "MEDIUM",
        "passRate": "82.51%",
        "problemsUrl": "https://leetcode.cn/problems/execution-of-all-suffix-instructions-staying-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/execution-of-all-suffix-instructions-staying-in-a-grid/solution",
        "problemsDesc": "<p>现有一个 <code>n x n</code> 大小的网格，左上角单元格坐标 <code>(0, 0)</code> ，右下角单元格坐标 <code>(n - 1, n - 1)</code> 。给你整数 <code>n</code> 和一个整数数组 <code>startPos</code> ，其中 <code>startPos = [start<sub>row</sub>, start<sub>col</sub>]</code> 表示机器人最开始在坐标为 <code>(start<sub>row</sub>, start<sub>col</sub>)</code> 的单元格上。</p>\n\n<p>另给你一个长度为 <code>m</code> 、下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，其中 <code>s[i]</code> 是对机器人的第 <code>i</code> 条指令：<code>'L'</code>（向左移动），<code>'R'</code>（向右移动），<code>'U'</code>（向上移动）和 <code>'D'</code>（向下移动）。</p>\n\n<p>机器人可以从 <code>s</code> 中的任一第 <code>i</code> 条指令开始执行。它将会逐条执行指令直到 <code>s</code> 的末尾，但在满足下述条件之一时，机器人将会停止：</p>\n\n<ul>\n\t<li>下一条指令将会导致机器人移动到网格外。</li>\n\t<li>没有指令可以执行。</li>\n</ul>\n\n<p>返回一个长度为 <code>m</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是机器人从第 <code>i</code>&nbsp;条指令 <strong>开始</strong>&nbsp;，可以执行的 <strong>指令数目</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/09/1.png\" style=\"width: 145px; height: 142px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 3, startPos = [0,1], s = \"RRDDLU\"\n<strong>输出：</strong>[1,5,4,3,1,0]\n<strong>解释：</strong>机器人从 startPos 出发，并从第 i 条指令开始执行：\n- 0: \"<em><strong>R</strong></em>RDDLU\" 在移动到网格外之前，只能执行一条 \"R\" 指令。\n- 1:  \"<em><strong>RDDLU</strong></em>\" 可以执行全部五条指令，机器人仍在网格内，最终到达 (0, 0) 。\n- 2:   \"<em><strong>DDLU</strong></em>\" 可以执行全部四条指令，机器人仍在网格内，最终到达 (0, 0) 。\n- 3:    \"<em><strong>DLU</strong></em>\" 可以执行全部三条指令，机器人仍在网格内，最终到达 (0, 0) 。\n- 4:     \"<em><strong>L</strong></em>U\" 在移动到网格外之前，只能执行一条 \"L\" 指令。\n- 5:      \"U\" 如果向上移动，将会移动到网格外。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/09/2.png\" style=\"width: 106px; height: 103px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 2, startPos = [1,1], s = \"LURD\"\n<strong>输出：</strong>[4,1,0,0]\n<strong>解释：</strong>\n- 0: \"<em><strong>LURD</strong></em>\"\n- 1:  \"<em><strong>U</strong></em>RD\"\n- 2:   \"RD\"\n- 3:    \"D\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/09/3.png\" style=\"width: 67px; height: 64px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 1, startPos = [0,0], s = \"LRUD\"\n<strong>输出：</strong>[0,0,0,0]\n<strong>解释：</strong>无论机器人从哪条指令开始执行，都会移动到网格外。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == s.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 500</code></li>\n\t<li><code>startPos.length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>row</sub>, start<sub>col</sub> &lt; n</code></li>\n\t<li><code>s</code> 由 <code>'L'</code>、<code>'R'</code>、<code>'U'</code> 和 <code>'D'</code> 组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2121.相同元素的间隔之和",
        "hardRate": "MEDIUM",
        "passRate": "38.65%",
        "problemsUrl": "https://leetcode.cn/problems/intervals-between-identical-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/intervals-between-identical-elements/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、由 <code>n</code> 个整数组成的数组 <code>arr</code> 。</p>\n\n<p><code>arr</code> 中两个元素的 <strong>间隔</strong> 定义为它们下标之间的 <strong>绝对差</strong> 。更正式地，<code>arr[i]</code> 和 <code>arr[j]</code> 之间的间隔是 <code>|i - j|</code> 。</p>\n\n<p>返回一个长度为 <code>n</code> 的数组&nbsp;<code>intervals</code> ，其中 <code>intervals[i]</code> 是<em> </em><code>arr[i]</code><em> </em>和<em> </em><code>arr</code><em> </em>中每个相同元素（与 <code>arr[i]</code> 的值相同）的 <strong>间隔之和</strong> <em>。</em></p>\n\n<p><strong>注意：</strong><code>|x|</code> 是 <code>x</code> 的绝对值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,1,3,1,2,3,3]\n<strong>输出：</strong>[4,2,7,2,4,4,5]\n<strong>解释：</strong>\n- 下标 0 ：另一个 2 在下标 4 ，|0 - 4| = 4\n- 下标 1 ：另一个 1 在下标 3 ，|1 - 3| = 2\n- 下标 2 ：另两个 3 在下标 5 和 6 ，|2 - 5| + |2 - 6| = 7\n- 下标 3 ：另一个 1 在下标 1 ，|3 - 1| = 2\n- 下标 4 ：另一个 2 在下标 0 ，|4 - 0| = 4\n- 下标 5 ：另两个 3 在下标 2 和 6 ，|5 - 2| + |5 - 6| = 4\n- 下标 6 ：另两个 3 在下标 2 和 5 ，|6 - 2| + |6 - 5| = 5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [10,5,10,10]\n<strong>输出：</strong>[5,0,3,4]\n<strong>解释：</strong>\n- 下标 0 ：另两个 10 在下标 2 和 3 ，|0 - 2| + |0 - 3| = 5\n- 下标 1 ：只有这一个 5 在数组中，所以到相同元素的间隔之和是 0\n- 下标 2 ：另两个 10 在下标 0 和 3 ，|2 - 0| + |2 - 3| = 3\n- 下标 3 ：另两个 10 在下标 0 和 2 ，|3 - 0| + |3 - 2| = 4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == arr.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2122.还原原数组",
        "hardRate": "HARD",
        "passRate": "42.07%",
        "problemsUrl": "https://leetcode.cn/problems/recover-the-original-array/",
        "solutionsUrl": "https://leetcode.cn/problems/recover-the-original-array/solution",
        "problemsDesc": "<p>Alice 有一个下标从 <strong>0</strong> 开始的数组 <code>arr</code> ，由 <code>n</code> 个正整数组成。她会选择一个任意的 <strong>正整数 </strong><code>k</code> 并按下述方式创建两个下标从 <strong>0</strong> 开始的新整数数组 <code>lower</code> 和 <code>higher</code> ：</p>\n\n<ol>\n\t<li>对每个满足 <code>0 &lt;= i &lt; n</code> 的下标 <code>i</code> ，<code>lower[i] = arr[i] - k</code></li>\n\t<li>对每个满足 <code>0 &lt;= i &lt; n</code> 的下标 <code>i</code> ，<code>higher[i] = arr[i] + k</code></li>\n</ol>\n\n<p>不幸地是，Alice 丢失了全部三个数组。但是，她记住了在数组 <code>lower</code> 和 <code>higher</code> 中出现的整数，但不知道每个整数属于哪个数组。请你帮助 Alice 还原原数组。</p>\n\n<p>给你一个由 2n 个整数组成的整数数组 <code>nums</code> ，其中 <strong>恰好</strong> <code>n</code> 个整数出现在 <code>lower</code> ，剩下的出现在 <code>higher</code> ，还原并返回 <strong>原数组</strong> <code>arr</code> 。如果出现答案不唯一的情况，返回 <strong>任一</strong> 有效数组。</p>\n\n<p><strong>注意：</strong>生成的测试用例保证存在 <strong>至少一个</strong> 有效数组 <code>arr</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,10,6,4,8,12]\n<strong>输出：</strong>[3,7,11]\n<strong>解释：</strong>\n如果 arr = [3,7,11] 且 k = 1 ，那么 lower = [2,6,10] 且 higher = [4,8,12] 。\n组合 lower 和 higher 得到 [2,6,10,4,8,12] ，这是 nums 的一个排列。\n另一个有效的数组是 arr = [5,7,9] 且 k = 3 。在这种情况下，lower = [2,4,6] 且 higher = [8,10,12] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,3,3]\n<strong>输出：</strong>[2,2]\n<strong>解释：</strong>\n如果 arr = [2,2] 且 k = 1 ，那么 lower = [1,1] 且 higher = [3,3] 。\n组合 lower 和 higher 得到 [1,1,3,3] ，这是 nums 的一个排列。\n注意，数组不能是 [1,3] ，因为在这种情况下，获得 [1,1,3,3] 唯一可行的方案是 k = 0 。\n这种方案是无效的，k 必须是一个正整数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,435]\n<strong>输出：</strong>[220]\n<strong>解释：</strong>\n唯一可行的组合是 arr = [220] 且 k = 215 。在这种情况下，lower = [5] 且 higher = [435] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 * n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>生成的测试用例保证存在 <strong>至少一个</strong> 有效数组 <code>arr</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2123.使矩阵中的 1 互不相邻的最小操作数",
        "hardRate": "HARD",
        "passRate": "52.98%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-remove-adjacent-ones-in-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-remove-adjacent-ones-in-matrix/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2124.检查是否所有 A 都在 B 之前",
        "hardRate": "EASY",
        "passRate": "69.17%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-all-as-appears-before-all-bs/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-all-as-appears-before-all-bs/solution",
        "problemsDesc": "<p>给你一个 <strong>仅</strong> 由字符 <code>'a'</code> 和 <code>'b'</code> 组成的字符串&nbsp; <code>s</code> 。如果字符串中 <strong>每个</strong> <em> </em><code>'a'</code> 都出现在 <strong>每个</strong><em> </em><code>'b'</code><em> </em>之前，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"aaabbb\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\n'a' 位于下标 0、1 和 2 ；而 'b' 位于下标 3、4 和 5 。\n因此，每个 'a' 都出现在每个 'b' 之前，所以返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abab\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\n存在一个 'a' 位于下标 2 ，而一个 'b' 位于下标 1 。\n因此，不能满足每个 'a' 都出现在每个 'b' 之前，所以返回 false 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = \"bbb\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\n不存在 'a' ，因此可以视作每个 'a' 都出现在每个 'b' 之前，所以返回 true 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s[i]</code> 为 <code>'a'</code> 或 <code>'b'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2125.银行中的激光束数量",
        "hardRate": "MEDIUM",
        "passRate": "83.12%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-laser-beams-in-a-bank/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-laser-beams-in-a-bank/solution",
        "problemsDesc": "<p>银行内部的防盗安全装置已经激活。给你一个下标从 <strong>0</strong> 开始的二进制字符串数组 <code>bank</code> ，表示银行的平面图，这是一个大小为 <code>m x n</code> 的二维矩阵。 <code>bank[i]</code> 表示第 <code>i</code> 行的设备分布，由若干 <code>'0'</code> 和若干 <code>'1'</code> 组成。<code>'0'</code> 表示单元格是空的，而 <code>'1'</code> 表示单元格有一个安全设备。</p>\n\n<p>对任意两个安全设备而言，<strong>如果</strong><strong>同时</strong> 满足下面两个条件，则二者之间存在 <strong>一个</strong> 激光束：</p>\n\n<ul>\n\t<li>两个设备位于两个 <strong>不同行</strong> ：<code>r<sub>1</sub></code> 和 <code>r<sub>2</sub></code> ，其中 <code>r<sub>1</sub> &lt; r<sub>2</sub></code> 。</li>\n\t<li>满足&nbsp;<code>r<sub>1</sub> &lt; i &lt; r<sub>2</sub></code>&nbsp;的 <strong>所有&nbsp;</strong>行&nbsp;<code>i</code>&nbsp;，都&nbsp;<strong>没有安全设备</strong> 。</li>\n</ul>\n\n<p>激光束是独立的，也就是说，一个激光束既不会干扰另一个激光束，也不会与另一个激光束合并成一束。</p>\n\n<p>返回银行中激光束的总数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/24/laser1.jpg\" style=\"width: 400px; height: 368px;\" /></p>\n\n<pre>\n<strong>输入：</strong>bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\n<strong>输出：</strong>8\n<strong>解释：</strong>在下面每组设备对之间，存在一条激光束。总共是 8 条激光束：\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\n注意，第 0 行和第 3 行上的设备之间不存在激光束。\n这是因为第 2 行存在安全设备，这不满足第 2 个条件。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/24/laser2.jpg\" style=\"width: 244px; height: 325px;\" /></p>\n\n<pre>\n<strong>输入：</strong>bank = [\"000\",\"111\",\"000\"]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在两个位于不同行的设备\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == bank.length</code></li>\n\t<li><code>n == bank[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>bank[i][j]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2126.摧毁小行星",
        "hardRate": "MEDIUM",
        "passRate": "48.85%",
        "problemsUrl": "https://leetcode.cn/problems/destroying-asteroids/",
        "solutionsUrl": "https://leetcode.cn/problems/destroying-asteroids/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>mass</code>&nbsp;，它表示一颗行星的初始质量。再给你一个整数数组&nbsp;<code>asteroids</code>&nbsp;，其中&nbsp;<code>asteroids[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;颗小行星的质量。</p>\n\n<p>你可以按 <strong>任意顺序</strong>&nbsp;重新安排小行星的顺序，然后让行星跟它们发生碰撞。如果行星碰撞时的质量 <strong>大于等于</strong>&nbsp;小行星的质量，那么小行星被 <strong>摧毁</strong>&nbsp;，并且行星会 <strong>获得</strong>&nbsp;这颗小行星的质量。否则，行星将被摧毁。</p>\n\n<p>如果所有小行星 <strong>都</strong>&nbsp;能被摧毁，请返回 <code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>mass = 10, asteroids = [3,9,19,5,21]\n<b>输出：</b>true\n<b>解释：</b>一种安排小行星的方式为 [9,19,5,3,21] ：\n- 行星与质量为 9 的小行星碰撞。新的行星质量为：10 + 9 = 19\n- 行星与质量为 19 的小行星碰撞。新的行星质量为：19 + 19 = 38\n- 行星与质量为 5 的小行星碰撞。新的行星质量为：38 + 5 = 43\n- 行星与质量为 3 的小行星碰撞。新的行星质量为：43 + 3 = 46\n- 行星与质量为 21 的小行星碰撞。新的行星质量为：46 + 21 = 67\n所有小行星都被摧毁。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>mass = 5, asteroids = [4,9,23,4]\n<b>输出：</b>false\n<b>解释：</b>\n行星无论如何没法获得足够质量去摧毁质量为 23 的小行星。\n行星把别的小行星摧毁后，质量为 5 + 4 + 9 + 4 = 22 。\n它比 23 小，所以无法摧毁最后一颗小行星。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= mass &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= asteroids.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= asteroids[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2127.参加会议的最多员工数",
        "hardRate": "HARD",
        "passRate": "34.17%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/solution",
        "problemsDesc": "<p>一个公司准备组织一场会议，邀请名单上有&nbsp;<code>n</code>&nbsp;位员工。公司准备了一张 <strong>圆形</strong>&nbsp;的桌子，可以坐下 <strong>任意数目</strong>&nbsp;的员工。</p>\n\n<p>员工编号为 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;。每位员工都有一位 <strong>喜欢</strong>&nbsp;的员工，每位员工&nbsp;<strong>当且仅当</strong>&nbsp;他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工 <strong>不会</strong>&nbsp;是他自己。</p>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>favorite</code>&nbsp;，其中&nbsp;<code>favorite[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;位员工喜欢的员工。请你返回参加会议的&nbsp;<strong>最多员工数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/14/ex1.png\" style=\"width: 236px; height: 195px;\"></p>\n\n<pre><b>输入：</b>favorite = [2,2,1,2]\n<b>输出：</b>3\n<strong>解释：</strong>\n上图展示了公司邀请员工 0，1 和 2 参加会议以及他们在圆桌上的座位。\n没办法邀请所有员工参与会议，因为员工 2 没办法同时坐在 0，1 和 3 员工的旁边。\n注意，公司也可以邀请员工 1，2 和 3 参加会议。\n所以最多参加会议的员工数目为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>favorite = [1,2,0]\n<b>输出：</b>3\n<b>解释：</b>\n每个员工都至少是另一个员工喜欢的员工。所以公司邀请他们所有人参加会议的前提是所有人都参加了会议。\n座位安排同图 1 所示：\n- 员工 0 坐在员工 2 和 1 之间。\n- 员工 1 坐在员工 0 和 2 之间。\n- 员工 2 坐在员工 1 和 0 之间。\n参与会议的最多员工数目为 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/14/ex2.png\" style=\"width: 219px; height: 220px;\"></p>\n\n<pre><b>输入：</b>favorite = [3,0,1,4,1]\n<b>输出：</b>4\n<b>解释：</b>\n上图展示了公司可以邀请员工 0，1，3 和 4 参加会议以及他们在圆桌上的座位。\n员工 2 无法参加，因为他喜欢的员工 0 旁边的座位已经被占领了。\n所以公司只能不邀请员工 2 。\n参加会议的最多员工数目为 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == favorite.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= favorite[i] &lt;=&nbsp;n - 1</code></li>\n\t<li><code>favorite[i] != i</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2128.通过翻转行或列来去除所有的 1",
        "hardRate": "MEDIUM",
        "passRate": "75.53%",
        "problemsUrl": "https://leetcode.cn/problems/remove-all-ones-with-row-and-column-flips/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-all-ones-with-row-and-column-flips/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2129.将标题首字母大写",
        "hardRate": "EASY",
        "passRate": "60.67%",
        "problemsUrl": "https://leetcode.cn/problems/capitalize-the-title/",
        "solutionsUrl": "https://leetcode.cn/problems/capitalize-the-title/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>title</code>&nbsp;，它由单个空格连接一个或多个单词组成，每个单词都只包含英文字母。请你按以下规则将每个单词的首字母 <strong>大写</strong>&nbsp;：</p>\n\n<ul>\n\t<li>如果单词的长度为&nbsp;<code>1</code>&nbsp;或者&nbsp;<code>2</code>&nbsp;，所有字母变成小写。</li>\n\t<li>否则，将单词首字母大写，剩余字母变成小写。</li>\n</ul>\n\n<p>请你返回 <strong>大写后</strong>&nbsp;的<em>&nbsp;</em><code>title</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre><b>输入：</b>title = \"capiTalIze tHe titLe\"\n<b>输出：</b>\"Capitalize The Title\"\n<strong>解释：</strong>\n由于所有单词的长度都至少为 3 ，将每个单词首字母大写，剩余字母变为小写。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>title = \"First leTTeR of EACH Word\"\n<b>输出：</b>\"First Letter of Each Word\"\n<strong>解释：</strong>\n单词 \"of\" 长度为 2 ，所以它保持完全小写。\n其他单词长度都至少为 3 ，所以其他单词首字母大写，剩余字母小写。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>title = \"i lOve leetcode\"\n<b>输出：</b>\"i Love Leetcode\"\n<strong>解释：</strong>\n单词 \"i\" 长度为 1 ，所以它保留小写。\n其他单词长度都至少为 3 ，所以其他单词首字母大写，剩余字母小写。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= title.length &lt;= 100</code></li>\n\t<li><code>title</code>&nbsp;由单个空格隔开的单词组成，且不含有任何前导或后缀空格。</li>\n\t<li>每个单词由大写和小写英文字母组成，且都是 <strong>非空</strong>&nbsp;的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2130.链表最大孪生和",
        "hardRate": "MEDIUM",
        "passRate": "80.16%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-twin-sum-of-a-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-twin-sum-of-a-linked-list/solution",
        "problemsDesc": "<p>在一个大小为&nbsp;<code>n</code>&nbsp;且 <code>n</code>&nbsp;为&nbsp;<strong>偶数</strong> 的链表中，对于&nbsp;<code>0 &lt;= i &lt;= (n / 2) - 1</code>&nbsp;的 <code>i</code>&nbsp;，第&nbsp;<code>i</code>&nbsp;个节点（下标从 <strong>0</strong>&nbsp;开始）的孪生节点为第&nbsp;<code>(n-1-i)</code>&nbsp;个节点 。</p>\n\n<ul>\n\t<li>比方说，<code>n = 4</code>&nbsp;那么节点&nbsp;<code>0</code>&nbsp;是节点 <code>3</code>&nbsp;的孪生节点，节点 <code>1</code>&nbsp;是节点 <code>2</code>&nbsp;的孪生节点。这是长度为 <code><span style=\"\">n = 4</span></code>&nbsp;的链表中所有的孪生节点。</li>\n</ul>\n\n<p><strong>孪生和</strong>&nbsp;定义为一个节点和它孪生节点两者值之和。</p>\n\n<p>给你一个长度为偶数的链表的头节点&nbsp;<code>head</code>&nbsp;，请你返回链表的 <strong>最大孪生和</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/03/eg1drawio.png\" style=\"width: 250px; height: 70px;\"></p>\n\n<pre><b>输入：</b>head = [5,4,2,1]\n<b>输出：</b>6\n<strong>解释：</strong>\n节点 0 和节点 1 分别是节点 3 和 2 的孪生节点。孪生和都为 6 。\n链表中没有其他孪生节点。\n所以，链表的最大孪生和是 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/03/eg2drawio.png\" style=\"width: 250px; height: 70px;\"></p>\n\n<pre><b>输入：</b>head = [4,2,2,3]\n<b>输出：</b>7\n<strong>解释：</strong>\n链表中的孪生节点为：\n- 节点 0 是节点 3 的孪生节点，孪生和为 4 + 3 = 7 。\n- 节点 1 是节点 2 的孪生节点，孪生和为 2 + 2 = 4 。\n所以，最大孪生和为 max(7, 4) = 7 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/03/eg3drawio.png\" style=\"width: 200px; height: 88px;\"></p>\n\n<pre><b>输入：</b>head = [1,100000]\n<b>输出：</b>100001\n<strong>解释：</strong>\n链表中只有一对孪生节点，孪生和为 1 + 100000 = 100001 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表的节点数目是&nbsp;<code>[2, 10<sup>5</sup>]</code>&nbsp;中的&nbsp;<strong>偶数</strong>&nbsp;。</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2131.连接两字母单词得到的最长回文串",
        "hardRate": "MEDIUM",
        "passRate": "42.94%",
        "problemsUrl": "https://leetcode.cn/problems/longest-palindrome-by-concatenating-two-letter-words/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-palindrome-by-concatenating-two-letter-words/solution",
        "problemsDesc": "<p>给你一个字符串数组&nbsp;<code>words</code>&nbsp;。<code>words</code>&nbsp;中每个元素都是一个包含 <strong>两个</strong>&nbsp;小写英文字母的单词。</p>\n\n<p>请你从 <code>words</code>&nbsp;中选择一些元素并按 <b>任意顺序</b>&nbsp;连接它们，并得到一个 <strong>尽可能长的回文串</strong>&nbsp;。每个元素 <strong>至多</strong>&nbsp;只能使用一次。</p>\n\n<p>请你返回你能得到的最长回文串的 <strong>长度</strong>&nbsp;。如果没办法得到任何一个回文串，请你返回 <code>0</code>&nbsp;。</p>\n\n<p><strong>回文串</strong>&nbsp;指的是从前往后和从后往前读一样的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>words = [\"lc\",\"cl\",\"gg\"]\n<b>输出：</b>6\n<b>解释：</b>一个最长的回文串为 \"lc\" + \"gg\" + \"cl\" = \"lcggcl\" ，长度为 6 。\n\"clgglc\" 是另一个可以得到的最长回文串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>words = [\"ab\",\"ty\",\"yt\",\"lc\",\"cl\",\"ab\"]\n<b>输出：</b>8\n<strong>解释：</strong>最长回文串是 \"ty\" + \"lc\" + \"cl\" + \"yt\" = \"tylcclyt\" ，长度为 8 。\n\"lcyttycl\" 是另一个可以得到的最长回文串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>words = [\"cc\",\"ll\",\"xx\"]\n<b>输出：</b>2\n<b>解释：</b>最长回文串是 \"cc\" ，长度为 2 。\n\"ll\" 是另一个可以得到的最长回文串。\"xx\" 也是。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>words[i].length == 2</code></li>\n\t<li><code>words[i]</code>&nbsp;仅包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2132.用邮票贴满网格图",
        "hardRate": "HARD",
        "passRate": "30.78%",
        "problemsUrl": "https://leetcode.cn/problems/stamping-the-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/stamping-the-grid/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的二进制矩阵&nbsp;<code>grid</code>&nbsp;，每个格子要么为&nbsp;<code>0</code>&nbsp;（空）要么为&nbsp;<code>1</code>&nbsp;（被占据）。</p>\n\n<p>给你邮票的尺寸为&nbsp;<code>stampHeight x stampWidth</code>&nbsp;。我们想将邮票贴进二进制矩阵中，且满足以下&nbsp;<strong>限制</strong>&nbsp;和&nbsp;<strong>要求</strong>&nbsp;：</p>\n\n<ol>\n\t<li>覆盖所有 <strong>空</strong>&nbsp;格子。</li>\n\t<li>不覆盖任何 <strong>被占据&nbsp;</strong>的格子。</li>\n\t<li>我们可以放入任意数目的邮票。</li>\n\t<li>邮票可以相互有 <strong>重叠</strong>&nbsp;部分。</li>\n\t<li>邮票不允许 <strong>旋转</strong>&nbsp;。</li>\n\t<li>邮票必须完全在矩阵 <strong>内</strong>&nbsp;。</li>\n</ol>\n\n<p>如果在满足上述要求的前提下，可以放入邮票，请返回&nbsp;<code>true</code>&nbsp;，否则返回<i>&nbsp;</i><code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/03/ex1.png\" style=\"width: 180px; height: 237px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3\n<b>输出：</b>true\n<b>解释：</b>我们放入两个有重叠部分的邮票（图中标号为 1 和 2），它们能覆盖所有与空格子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/03/ex2.png\" style=\"width: 170px; height: 179px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 \n<b>输出：</b>false \n<b>解释：</b>没办法放入邮票覆盖所有的空格子，且邮票不超出网格图以外。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[r].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>grid[r][c]</code> 要么是&nbsp;<code>0</code>&nbsp;，要么是&nbsp;<code>1</code> 。</li>\n\t<li><code>1 &lt;= stampHeight, stampWidth &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2133.检查是否每一行每一列都包含全部整数",
        "hardRate": "EASY",
        "passRate": "55.64%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-every-row-and-column-contains-all-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-every-row-and-column-contains-all-numbers/solution",
        "problemsDesc": "<p>对一个大小为 <code>n x n</code> 的矩阵而言，如果其每一行和每一列都包含从 <code>1</code> 到 <code>n</code> 的 <strong>全部</strong> 整数（含 <code>1</code> 和 <code>n</code>），则认为该矩阵是一个 <strong>有效</strong> 矩阵。</p>\n\n<p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>matrix</code> ，请你判断矩阵是否为一个有效矩阵：如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/21/example1drawio.png\" style=\"width: 250px; height: 251px;\" /></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3],[3,1,2],[2,3,1]]\n<strong>输出：</strong>true\n<strong>解释：</strong>在此例中，n = 3 ，每一行和每一列都包含数字 1、2、3 。\n因此，返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/21/example2drawio.png\" style=\"width: 250px; height: 251px;\" /></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,1,1],[1,2,3],[1,2,3]]\n<strong>输出：</strong>false\n<strong>解释：</strong>在此例中，n = 3 ，但第一行和第一列不包含数字 2 和 3 。\n因此，返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == matrix.length == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= matrix[i][j] &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2134.最少交换次数来组合所有的 1 II",
        "hardRate": "MEDIUM",
        "passRate": "48.85%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together-ii/solution",
        "problemsDesc": "<p><strong>交换</strong> 定义为选中一个数组中的两个 <strong>互不相同</strong> 的位置并交换二者的值。</p>\n\n<p><strong>环形</strong> 数组是一个数组，可以认为 <strong>第一个</strong> 元素和 <strong>最后一个</strong> 元素 <strong>相邻</strong> 。</p>\n\n<p>给你一个 <strong>二进制环形</strong> 数组 <code>nums</code> ，返回在 <strong>任意位置</strong> 将数组中的所有 <code>1</code> 聚集在一起需要的最少交换次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,0,1,1,0,0]\n<strong>输出：</strong>1\n<strong>解释：</strong>这里列出一些能够将所有 1 聚集在一起的方案：\n[0,<strong><em>0</em></strong>,<em><strong>1</strong></em>,1,1,0,0] 交换 1 次。\n[0,1,<em><strong>1</strong></em>,1,<em><strong>0</strong></em>,0,0] 交换 1 次。\n[1,1,0,0,0,0,1] 交换 2 次（利用数组的环形特性）。\n无法在交换 0 次的情况下将数组中的所有 1 聚集在一起。\n因此，需要的最少交换次数为 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,1,1,0,0,1,1,0]\n<strong>输出：</strong>2\n<strong>解释：</strong>这里列出一些能够将所有 1 聚集在一起的方案：\n[1,1,1,0,0,0,0,1,1] 交换 2 次（利用数组的环形特性）。\n[1,1,1,1,1,0,0,0,0] 交换 2 次。\n无法在交换 0 次或 1 次的情况下将数组中的所有 1 聚集在一起。\n因此，需要的最少交换次数为 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,0,0,1]\n<strong>输出：</strong>0\n<strong>解释：</strong>得益于数组的环形特性，所有的 1 已经聚集在一起。\n因此，需要的最少交换次数为 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> 为 <code>0</code> 或者 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2135.统计追加字母可以获得的单词数",
        "hardRate": "MEDIUM",
        "passRate": "36.16%",
        "problemsUrl": "https://leetcode.cn/problems/count-words-obtained-after-adding-a-letter/",
        "solutionsUrl": "https://leetcode.cn/problems/count-words-obtained-after-adding-a-letter/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong> 开始的字符串数组 <code>startWords</code> 和 <code>targetWords</code> 。每个字符串都仅由 <strong>小写英文字母</strong> 组成。</p>\n\n<p>对于 <code>targetWords</code> 中的每个字符串，检查是否能够从 <code>startWords</code> 中选出一个字符串，执行一次 <strong>转换操作</strong>&nbsp;，得到的结果与当前&nbsp;<code>targetWords</code> 字符串相等。</p>\n\n<p><strong>转换操作</strong> 如下面两步所述：</p>\n\n<ol>\n\t<li><strong>追加</strong> 任何 <strong>不存在</strong> 于当前字符串的任一小写字母到当前字符串的末尾。\n\n\t<ul>\n\t\t<li>例如，如果字符串为 <code>\"abc\"</code> ，那么字母 <code>'d'</code>、<code>'e'</code> 或 <code>'y'</code> 都可以加到该字符串末尾，但 <code>'a'</code> 就不行。如果追加的是 <code>'d'</code> ，那么结果字符串为 <code>\"abcd\"</code> 。</li>\n\t</ul>\n\t</li>\n\t<li><strong>重排</strong> 新字符串中的字母，可以按 <strong>任意</strong> 顺序重新排布字母。\n\t<ul>\n\t\t<li>例如，<code>\"abcd\"</code> 可以重排为 <code>\"acbd\"</code>、<code>\"bacd\"</code>、<code>\"cbda\"</code>，以此类推。注意，它也可以重排为 <code>\"abcd\"</code> 自身。</li>\n\t</ul>\n\t</li>\n</ol>\n\n<p>找出 <code>targetWords</code> 中有多少字符串能够由&nbsp;<code>startWords</code> 中的 <strong>任一</strong> 字符串执行上述转换操作获得。返回<em> </em><code>targetWords</code><em> </em>中这类 <strong>字符串的数目</strong> 。</p>\n\n<p><strong>注意：</strong>你仅能验证 <code>targetWords</code> 中的字符串是否可以由 <code>startWords</code> 中的某个字符串经执行操作获得。<code>startWords</code>&nbsp; 中的字符串在这一过程中 <strong>不</strong> 发生实际变更。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>startWords = [\"ant\",\"act\",\"tack\"], targetWords = [\"tack\",\"act\",\"acti\"]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n- 为了形成 targetWords[0] = \"tack\" ，可以选用 startWords[1] = \"act\" ，追加字母 'k' ，并重排 \"actk\" 为 \"tack\" 。\n- startWords 中不存在可以用于获得 targetWords[1] = \"act\" 的字符串。\n  注意 \"act\" 确实存在于 startWords ，但是 <strong>必须</strong> 在重排前给这个字符串追加一个字母。\n- 为了形成 targetWords[2] = \"acti\" ，可以选用 startWords[1] = \"act\" ，追加字母 'i' ，并重排 \"acti\" 为 \"acti\" 自身。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>startWords = [\"ab\",\"a\"], targetWords = [\"abc\",\"abcd\"]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n- 为了形成 targetWords[0] = \"abc\" ，可以选用 startWords[0] = \"ab\" ，追加字母 'c' ，并重排为 \"abc\" 。\n- startWords 中不存在可以用于获得 targetWords[1] = \"abcd\" 的字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= startWords.length, targetWords.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= startWords[i].length, targetWords[j].length &lt;= 26</code></li>\n\t<li><code>startWords</code> 和 <code>targetWords</code> 中的每个字符串都仅由小写英文字母组成</li>\n\t<li>在 <code>startWords</code> 或 <code>targetWords</code> 的任一字符串中，每个字母至多出现一次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2136.全部开花的最早一天",
        "hardRate": "HARD",
        "passRate": "66.12%",
        "problemsUrl": "https://leetcode.cn/problems/earliest-possible-day-of-full-bloom/",
        "solutionsUrl": "https://leetcode.cn/problems/earliest-possible-day-of-full-bloom/solution",
        "problemsDesc": "<p>你有 <code>n</code> 枚花的种子。每枚种子必须先种下，才能开始生长、开花。播种需要时间，种子的生长也是如此。给你两个下标从 <strong>0</strong> 开始的整数数组 <code>plantTime</code> 和 <code>growTime</code> ，每个数组的长度都是 <code>n</code> ：</p>\n\n<ul>\n\t<li><code>plantTime[i]</code> 是 <strong>播种</strong> 第 <code>i</code> 枚种子所需的 <strong>完整天数</strong> 。每天，你只能为播种某一枚种子而劳作。<strong>无须</strong> 连续几天都在种同一枚种子，但是种子播种必须在你工作的天数达到 <code>plantTime[i]</code> 之后才算完成。</li>\n\t<li><code>growTime[i]</code> 是第 <code>i</code> 枚种子完全种下后生长所需的 <strong>完整天数 </strong>。在它生长的最后一天 <strong>之后</strong> ，将会开花并且永远 <strong>绽放</strong> 。</li>\n</ul>\n\n<p>从第 <code>0</code> 开始，你可以按 <strong>任意</strong> 顺序播种种子。</p>\n\n<p>返回所有种子都开花的 <strong>最早</strong> 一天是第几天。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/21/1.png\" style=\"width: 453px; height: 149px;\">\n<pre><strong>输入：</strong>plantTime = [1,4,3], growTime = [2,3,1]\n<strong>输出：</strong>9\n<strong>解释：</strong>灰色的花盆表示播种的日子，彩色的花盆表示生长的日子，花朵表示开花的日子。\n一种最优方案是：\n第 0 天，播种第 0 枚种子，种子生长 2 整天。并在第 3 天开花。\n第 1、2、3、4 天，播种第 1 枚种子。种子生长 3 整天，并在第 8 天开花。\n第 5、6、7 天，播种第 2 枚种子。种子生长 1 整天，并在第 9 天开花。\n因此，在第 9 天，所有种子都开花。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/21/2.png\" style=\"width: 454px; height: 184px;\">\n<pre><strong>输入：</strong>plantTime = [1,2,3,2], growTime = [2,1,2,1]\n<strong>输出：</strong>9\n<strong>解释：</strong>灰色的花盆表示播种的日子，彩色的花盆表示生长的日子，花朵表示开花的日子。 \n一种最优方案是：\n第 1 天，播种第 0 枚种子，种子生长 2 整天。并在第 4 天开花。\n第 0、3 天，播种第 1 枚种子。种子生长 1 整天，并在第 5 天开花。\n第 2、4、5 天，播种第 2 枚种子。种子生长 2 整天，并在第 8 天开花。\n第 6、7 天，播种第 3 枚种子。种子生长 1 整天，并在第 9 天开花。\n因此，在第 9 天，所有种子都开花。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>plantTime = [1], growTime = [1]\n<strong>输出：</strong>2\n<strong>解释：</strong>第 0 天，播种第 0 枚种子。种子需要生长 1 整天，然后在第 2 天开花。\n因此，在第 2 天，所有种子都开花。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == plantTime.length == growTime.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= plantTime[i], growTime[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2137.通过倒水操作让所有的水桶所含水量相等",
        "hardRate": "MEDIUM",
        "passRate": "64.72%",
        "problemsUrl": "https://leetcode.cn/problems/pour-water-between-buckets-to-make-water-levels-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/pour-water-between-buckets-to-make-water-levels-equal/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2138.将字符串拆分为若干长度为 k 的组",
        "hardRate": "EASY",
        "passRate": "66.38%",
        "problemsUrl": "https://leetcode.cn/problems/divide-a-string-into-groups-of-size-k/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-a-string-into-groups-of-size-k/solution",
        "problemsDesc": "<p>字符串 <code>s</code> 可以按下述步骤划分为若干长度为 <code>k</code> 的组：</p>\n\n<ul>\n\t<li>第一组由字符串中的前 <code>k</code> 个字符组成，第二组由接下来的 <code>k</code> 个字符串组成，依此类推。每个字符都能够成为 <strong>某一个</strong> 组的一部分。</li>\n\t<li>对于最后一组，如果字符串剩下的字符 <strong>不足</strong> <code>k</code> 个，需使用字符 <code>fill</code> 来补全这一组字符。</li>\n</ul>\n\n<p>注意，在去除最后一个组的填充字符 <code>fill</code>（如果存在的话）并按顺序连接所有的组后，所得到的字符串应该是 <code>s</code> 。</p>\n\n<p>给你一个字符串 <code>s</code> ，以及每组的长度 <code>k</code> 和一个用于填充的字符 <code>fill</code> ，按上述步骤处理之后，返回一个字符串数组，该数组表示 <code>s</code> 分组后 <strong>每个组的组成情况</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abcdefghi\", k = 3, fill = \"x\"\n<strong>输出：</strong>[\"abc\",\"def\",\"ghi\"]\n<strong>解释：</strong>\n前 3 个字符是 \"abc\" ，形成第一组。\n接下来 3 个字符是 \"def\" ，形成第二组。\n最后 3 个字符是 \"ghi\" ，形成第三组。\n由于所有组都可以由字符串中的字符完全填充，所以不需要使用填充字符。\n因此，形成 3 组，分别是 \"abc\"、\"def\" 和 \"ghi\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abcdefghij\", k = 3, fill = \"x\"\n<strong>输出：</strong>[\"abc\",\"def\",\"ghi\",\"jxx\"]\n<strong>解释：</strong>\n与前一个例子类似，形成前三组 \"abc\"、\"def\" 和 \"ghi\" 。\n对于最后一组，字符串中仅剩下字符 'j' 可以用。为了补全这一组，使用填充字符 'x' 两次。\n因此，形成 4 组，分别是 \"abc\"、\"def\"、\"ghi\" 和 \"jxx\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n\t<li><code>fill</code> 是一个小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2139.得到目标值的最少行动次数",
        "hardRate": "MEDIUM",
        "passRate": "51.51%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-moves-to-reach-target-score/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-moves-to-reach-target-score/solution",
        "problemsDesc": "<p>你正在玩一个整数游戏。从整数 <code>1</code> 开始，期望得到整数 <code>target</code> 。</p>\n\n<p>在一次行动中，你可以做下述两种操作之一：</p>\n\n<ul>\n\t<li><strong>递增</strong>，将当前整数的值加 1（即， <code>x = x + 1</code>）。</li>\n\t<li><strong>加倍</strong>，使当前整数的值翻倍（即，<code>x = 2 * x</code>）。</li>\n</ul>\n\n<p>在整个游戏过程中，你可以使用 <strong>递增</strong> 操作 <strong>任意</strong> 次数。但是只能使用 <strong>加倍</strong> 操作 <strong>至多</strong> <code>maxDoubles</code> 次。</p>\n\n<p>给你两个整数 <code>target</code> 和 <code>maxDoubles</code> ，返回从 1 开始得到<em> </em><code>target</code><em> </em>需要的最少行动次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>target = 5, maxDoubles = 0\n<strong>输出：</strong>4\n<strong>解释：</strong>一直递增 1 直到得到 target 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>target = 19, maxDoubles = 2\n<strong>输出：</strong>7\n<strong>解释：</strong>最初，x = 1 。\n递增 3 次，x = 4 。\n加倍 1 次，x = 8 。\n递增 1 次，x = 9 。\n加倍 1 次，x = 18 。\n递增 1 次，x = 19 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>target = 10, maxDoubles = 4\n<strong>输出：</strong>4\n<strong>解释：</strong>\n最初，x = 1 。 \n递增 1 次，x = 2 。 \n加倍 1 次，x = 4 。 \n递增 1 次，x = 5 。 \n加倍 1 次，x = 10 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= maxDoubles &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2140.解决智力问题",
        "hardRate": "MEDIUM",
        "passRate": "44.03%",
        "problemsUrl": "https://leetcode.cn/problems/solving-questions-with-brainpower/",
        "solutionsUrl": "https://leetcode.cn/problems/solving-questions-with-brainpower/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>questions</code>&nbsp;，其中&nbsp;<code>questions[i] = [points<sub>i</sub>, brainpower<sub>i</sub>]</code>&nbsp;。</p>\n\n<p>这个数组表示一场考试里的一系列题目，你需要 <strong>按顺序</strong>&nbsp;（也就是从问题 <code>0</code><strong>&nbsp;</strong>开始依次解决），针对每个问题选择 <strong>解决</strong>&nbsp;或者 <strong>跳过</strong>&nbsp;操作。解决问题 <code>i</code>&nbsp;将让你 <b>获得</b>&nbsp;&nbsp;<code>points<sub>i</sub></code>&nbsp;的分数，但是你将 <strong>无法</strong>&nbsp;解决接下来的&nbsp;<code>brainpower<sub>i</sub></code>&nbsp;个问题（即只能跳过接下来的 <code>brainpower<sub>i</sub></code><sub>&nbsp;</sub>个问题）。如果你跳过问题&nbsp;<code>i</code>&nbsp;，你可以对下一个问题决定使用哪种操作。</p>\n\n<ul>\n\t<li>比方说，给你&nbsp;<code>questions = [[3, 2], [4, 3], [4, 4], [2, 5]]</code>&nbsp;：\n\n\t<ul>\n\t\t<li>如果问题&nbsp;<code>0</code>&nbsp;被解决了， 那么你可以获得&nbsp;<code>3</code>&nbsp;分，但你不能解决问题&nbsp;<code>1</code> 和&nbsp;<code>2</code>&nbsp;。</li>\n\t\t<li>如果你跳过问题&nbsp;<code>0</code>&nbsp;，且解决问题&nbsp;<code>1</code>&nbsp;，你将获得 <code>4</code> 分但是不能解决问题&nbsp;<code>2</code> 和&nbsp;<code>3</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回这场考试里你能获得的 <strong>最高</strong>&nbsp;分数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>questions = [[3,2],[4,3],[4,4],[2,5]]\n<b>输出：</b>5\n<b>解释：</b>解决问题 0 和 3 得到最高分。\n- 解决问题 0 ：获得 3 分，但接下来 2 个问题都不能解决。\n- 不能解决问题 1 和 2\n- 解决问题 3 ：获得 2 分\n总得分为：3 + 2 = 5 。没有别的办法获得 5 分或者多于 5 分。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]\n<b>输出：</b>7\n<b>解释：</b>解决问题 1 和 4 得到最高分。\n- 跳过问题 0\n- 解决问题 1 ：获得 2 分，但接下来 2 个问题都不能解决。\n- 不能解决问题 2 和 3\n- 解决问题 4 ：获得 5 分\n总得分为：2 + 5 = 7 。没有别的办法获得 7 分或者多于 7 分。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= questions.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>questions[i].length == 2</code></li>\n\t<li><code>1 &lt;= points<sub>i</sub>, brainpower<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2141.同时运行 N 台电脑的最长时间",
        "hardRate": "HARD",
        "passRate": "40.62%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-running-time-of-n-computers/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-running-time-of-n-computers/solution",
        "problemsDesc": "<p>你有&nbsp;<code>n</code>&nbsp;台电脑。给你整数&nbsp;<code>n</code>&nbsp;和一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>batteries</code>&nbsp;，其中第&nbsp;<code>i</code>&nbsp;个电池可以让一台电脑 <strong>运行&nbsp;</strong><code>batteries[i]</code>&nbsp;分钟。你想使用这些电池让&nbsp;<strong>全部</strong>&nbsp;<code>n</code>&nbsp;台电脑 <b>同时</b>&nbsp;运行。</p>\n\n<p>一开始，你可以给每台电脑连接 <strong>至多一个电池</strong>&nbsp;。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 <strong>任意次</strong>&nbsp;。新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。</p>\n\n<p>注意，你不能给电池充电。</p>\n\n<p>请你返回你可以让 <code>n</code>&nbsp;台电脑同时运行的 <strong>最长</strong>&nbsp;分钟数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/01/06/example1-fit.png\" style=\"width: 762px; height: 150px;\"></p>\n\n<pre><b>输入：</b>n = 2, batteries = [3,3,3]\n<b>输出：</b>4\n<b>解释：</b>\n一开始，将第一台电脑与电池 0 连接，第二台电脑与电池 1 连接。\n2 分钟后，将第二台电脑与电池 1 断开连接，并连接电池 2 。注意，电池 0 还可以供电 1 分钟。\n在第 3 分钟结尾，你需要将第一台电脑与电池 0 断开连接，然后连接电池 1 。\n在第 4 分钟结尾，电池 1 也被耗尽，第一台电脑无法继续运行。\n我们最多能同时让两台电脑同时运行 4 分钟，所以我们返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/01/06/example2.png\" style=\"width: 629px; height: 150px;\"></p>\n\n<pre><b>输入：</b>n = 2, batteries = [1,1,1,1]\n<b>输出：</b>2\n<b>解释：</b>\n一开始，将第一台电脑与电池 0 连接，第二台电脑与电池 2 连接。\n一分钟后，电池 0 和电池 2 同时耗尽，所以你需要将它们断开连接，并将电池 1 和第一台电脑连接，电池 3 和第二台电脑连接。\n1 分钟后，电池 1 和电池 3 也耗尽了，所以两台电脑都无法继续运行。\n我们最多能让两台电脑同时运行 2 分钟，所以我们返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= batteries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= batteries[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2142.每辆车的乘客人数 I",
        "hardRate": "MEDIUM",
        "passRate": "46.66%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-passengers-in-each-bus-i/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-passengers-in-each-bus-i/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2143.在两个数组的区间中选取数字",
        "hardRate": "HARD",
        "passRate": "57.14%",
        "problemsUrl": "https://leetcode.cn/problems/choose-numbers-from-two-arrays-in-range/",
        "solutionsUrl": "https://leetcode.cn/problems/choose-numbers-from-two-arrays-in-range/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2144.打折购买糖果的最小开销",
        "hardRate": "EASY",
        "passRate": "66.97%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-of-buying-candies-with-discount/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-of-buying-candies-with-discount/solution",
        "problemsDesc": "<p>一家商店正在打折销售糖果。每购买 <strong>两个</strong>&nbsp;糖果，商店会 <strong>免费</strong>&nbsp;送一个糖果。</p>\n\n<p>免费送的糖果唯一的限制是：它的价格需要小于等于购买的两个糖果价格的 <strong>较小值</strong>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，总共有 <code>4</code>&nbsp;个糖果，价格分别为&nbsp;<code>1</code>&nbsp;，<code>2</code>&nbsp;，<code>3</code>&nbsp;和&nbsp;<code>4</code>&nbsp;，一位顾客买了价格为&nbsp;<code>2</code> 和&nbsp;<code>3</code>&nbsp;的糖果，那么他可以免费获得价格为 <code>1</code>&nbsp;的糖果，但不能获得价格为&nbsp;<code>4</code>&nbsp;的糖果。</li>\n</ul>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>cost</code>&nbsp;，其中&nbsp;<code>cost[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个糖果的价格，请你返回获得 <strong>所有</strong>&nbsp;糖果的 <strong>最小</strong>&nbsp;总开销。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>cost = [1,2,3]\n<b>输出：</b>5\n<b>解释：</b>我们购买价格为 2 和 3 的糖果，然后免费获得价格为 1 的糖果。\n总开销为 2 + 3 = 5 。这是开销最小的 <strong>唯一</strong>&nbsp;方案。\n注意，我们不能购买价格为 1 和 3 的糖果，并免费获得价格为 2 的糖果。\n这是因为免费糖果的价格必须小于等于购买的 2 个糖果价格的较小值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>cost = [6,5,7,9,2,2]\n<b>输出：</b>23\n<b>解释：</b>最小总开销购买糖果方案为：\n- 购买价格为 9 和 7 的糖果\n- 免费获得价格为 6 的糖果\n- 购买价格为 5 和 2 的糖果\n- 免费获得价格为 2 的最后一个糖果\n因此，最小总开销为 9 + 7 + 5 + 2 = 23 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>cost = [5,5]\n<b>输出：</b>10\n<b>解释：</b>由于只有 2 个糖果，我们需要将它们都购买，而且没有免费糖果。\n所以总最小开销为 5 + 5 = 10 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= cost.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= cost[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2145.统计隐藏数组数目",
        "hardRate": "MEDIUM",
        "passRate": "35.88%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-hidden-sequences/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-hidden-sequences/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始且长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>differences</code>&nbsp;，它表示一个长度为&nbsp;<code>n + 1</code>&nbsp;的&nbsp;<strong>隐藏</strong>&nbsp;数组&nbsp;<strong>相邻</strong>&nbsp;元素之间的&nbsp;<strong>差值</strong>&nbsp;。更正式的表述为：我们将隐藏数组记作&nbsp;<code>hidden</code>&nbsp;，那么&nbsp;<code>differences[i] = hidden[i + 1] - hidden[i]</code>&nbsp;。</p>\n\n<p>同时给你两个整数&nbsp;<code>lower</code> 和&nbsp;<code>upper</code>&nbsp;，它们表示隐藏数组中所有数字的值都在 <strong>闭</strong>&nbsp;区间&nbsp;<code>[lower, upper]</code>&nbsp;之间。</p>\n\n<ul>\n\t<li>比方说，<code>differences = [1, -3, 4]</code>&nbsp;，<code>lower = 1</code>&nbsp;，<code>upper = 6</code>&nbsp;，那么隐藏数组是一个长度为 <code>4</code>&nbsp;且所有值都在&nbsp;<code>1</code>&nbsp;和&nbsp;<code>6</code>&nbsp;（包含两者）之间的数组。\n\n\t<ul>\n\t\t<li><code>[3, 4, 1, 5]</code> 和&nbsp;<code>[4, 5, 2, 6]</code>&nbsp;都是符合要求的隐藏数组。</li>\n\t\t<li><code>[5, 6, 3, 7]</code>&nbsp;不符合要求，因为它包含大于 <code>6</code>&nbsp;的元素。</li>\n\t\t<li><code>[1, 2, 3, 4]</code>&nbsp;不符合要求，因为相邻元素的差值不符合给定数据。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回 <strong>符合</strong>&nbsp;要求的隐藏数组的数目。如果没有符合要求的隐藏数组，请返回 <code>0</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>differences = [1,-3,4], lower = 1, upper = 6\n<b>输出：</b>2\n<b>解释：</b>符合要求的隐藏数组为：\n- [3, 4, 1, 5]\n- [4, 5, 2, 6]\n所以返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>differences = [3,-4,5,1,-2], lower = -4, upper = 5\n<b>输出：</b>4\n<b>解释：</b>符合要求的隐藏数组为：\n- [-3, 0, -4, 1, 2, 0]\n- [-2, 1, -3, 2, 3, 1]\n- [-1, 2, -2, 3, 4, 2]\n- [0, 3, -1, 4, 5, 3]\n所以返回 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>differences = [4,-7,2], lower = 3, upper = 6\n<b>输出：</b>0\n<b>解释：</b>没有符合要求的隐藏数组，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == differences.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= differences[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= lower &lt;= upper &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2146.价格范围内最高排名的 K 样物品",
        "hardRate": "MEDIUM",
        "passRate": "40.19%",
        "problemsUrl": "https://leetcode.cn/problems/k-highest-ranked-items-within-a-price-range/",
        "solutionsUrl": "https://leetcode.cn/problems/k-highest-ranked-items-within-a-price-range/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>grid</code>&nbsp;，它的大小为&nbsp;<code>m x n</code>&nbsp;，表示一个商店中物品的分布图。数组中的整数含义为：</p>\n\n<ul>\n\t<li><code>0</code>&nbsp;表示无法穿越的一堵墙。</li>\n\t<li><code>1</code>&nbsp;表示可以自由通过的一个空格子。</li>\n\t<li>所有其他正整数表示该格子内的一样物品的价格。你可以自由经过这些格子。</li>\n</ul>\n\n<p>从一个格子走到上下左右相邻格子花费&nbsp;<code>1</code>&nbsp;步。</p>\n\n<p>同时给你一个整数数组&nbsp;<code>pricing</code> 和&nbsp;<code>start</code>&nbsp;，其中&nbsp;<code>pricing = [low, high]</code> 且&nbsp;<code>start = [row, col]</code>&nbsp;，表示你开始位置为&nbsp;<code>(row, col)</code>&nbsp;，同时你只对物品价格在<strong>&nbsp;闭区间</strong>&nbsp;<code>[low, high]</code>&nbsp;之内的物品感兴趣。同时给你一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>你想知道给定范围 <strong>内</strong>&nbsp;且 <strong>排名最高</strong>&nbsp;的 <code>k</code>&nbsp;件物品的 <strong>位置</strong>&nbsp;。排名按照优先级从高到低的以下规则制定：</p>\n\n<ol>\n\t<li>距离：定义为从&nbsp;<code>start</code>&nbsp;到一件物品的最短路径需要的步数（<strong>较近</strong>&nbsp;距离的排名更高）。</li>\n\t<li>价格：<strong>较低</strong>&nbsp;价格的物品有更高优先级，但只考虑在给定范围之内的价格。</li>\n\t<li>行坐标：<strong>较小</strong>&nbsp;行坐标的有更高优先级。</li>\n\t<li>列坐标：<strong>较小</strong>&nbsp;列坐标的有更高优先级。</li>\n</ol>\n\n<p>请你返回给定价格内排名最高的 <code>k</code>&nbsp;件物品的坐标，将它们按照排名排序后返回。如果给定价格内少于 <code>k</code>&nbsp;件物品，那么请将它们的坐标&nbsp;<strong>全部</strong>&nbsp;返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/16/example1drawio.png\" style=\"width: 200px; height: 151px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,2,0,1],[1,3,0,1],[0,2,5,1]], pricing = [2,5], start = [0,0], k = 3\n<b>输出：</b>[[0,1],[1,1],[2,1]]\n<b>解释：</b>起点为 (0,0) 。\n价格范围为 [2,5] ，我们可以选择的物品坐标为 (0,1)，(1,1)，(2,1) 和 (2,2) 。\n这些物品的排名为：\n- (0,1) 距离为 1\n- (1,1) 距离为 2\n- (2,1) 距离为 3\n- (2,2) 距离为 4\n所以，给定价格范围内排名最高的 3 件物品的坐标为 (0,1)，(1,1) 和 (2,1) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/16/example2drawio1.png\" style=\"width: 200px; height: 151px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,2,0,1],[1,3,3,1],[0,2,5,1]], pricing = [2,3], start = [2,3], k = 2\n<b>输出：</b>[[2,1],[1,2]]\n<b>解释：</b>起点为 (2,3) 。\n价格范围为 [2,3] ，我们可以选择的物品坐标为 (0,1)，(1,1)，(1,2) 和 (2,1) 。\n这些物品的排名为： \n- (2,1) 距离为 2 ，价格为 2\n- (1,2) 距离为 2 ，价格为 3\n- (1,1) 距离为 3\n- (0,1) 距离为 4\n所以，给定价格范围内排名最高的 2 件物品的坐标为 (2,1) 和 (1,2) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/30/example3.png\" style=\"width: 149px; height: 150px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,1,1],[0,0,1],[2,3,4]], pricing = [2,3], start = [0,0], k = 3\n<b>输出：</b>[[2,1],[2,0]]\n<b>解释：</b>起点为 (0,0) 。\n价格范围为 [2,3] ，我们可以选择的物品坐标为 (2,0) 和 (2,1) 。\n这些物品的排名为：\n- (2,1) 距离为 5\n- (2,0) 距离为 6\n所以，给定价格范围内排名最高的 2 件物品的坐标为 (2,1) 和 (2,0) 。\n注意，k = 3 但给定价格范围内只有 2 件物品。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pricing.length == 2</code></li>\n\t<li><code>2 &lt;= low &lt;= high &lt;= 10<sup>5</sup></code></li>\n\t<li><code>start.length == 2</code></li>\n\t<li><code>0 &lt;= row &lt;= m - 1</code></li>\n\t<li><code>0 &lt;= col &lt;= n - 1</code></li>\n\t<li><code>grid[row][col] &gt; 0</code></li>\n\t<li><code>1 &lt;= k &lt;= m * n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2147.分隔长廊的方案数",
        "hardRate": "HARD",
        "passRate": "41.53%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-divide-a-long-corridor/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-divide-a-long-corridor/solution",
        "problemsDesc": "<p>在一个图书馆的长廊里，有一些座位和装饰植物排成一列。给你一个下标从 <strong>0</strong>&nbsp;开始，长度为 <code>n</code>&nbsp;的字符串&nbsp;<code>corridor</code>&nbsp;，它包含字母&nbsp;<code>'S'</code> 和&nbsp;<code>'P'</code>&nbsp;，其中每个&nbsp;<code>'S'</code>&nbsp;表示一个座位，每个&nbsp;<code>'P'</code>&nbsp;表示一株植物。</p>\n\n<p>在下标 <code>0</code>&nbsp;的左边和下标 <code>n - 1</code>&nbsp;的右边 <strong>已经</strong>&nbsp;分别各放了一个屏风。你还需要额外放置一些屏风。每一个位置&nbsp;<code>i - 1</code> 和&nbsp;<code>i</code>&nbsp;之间（<code>1 &lt;= i &lt;= n - 1</code>），至多能放一个屏风。</p>\n\n<p>请你将走廊用屏风划分为若干段，且每一段内都 <strong>恰好有两个座位</strong>&nbsp;，而每一段内植物的数目没有要求。可能有多种划分方案，如果两个方案中有任何一个屏风的位置不同，那么它们被视为 <strong>不同</strong> 方案。</p>\n\n<p>请你返回划分走廊的方案数。由于答案可能很大，请你返回它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;的结果。如果没有任何方案，请返回&nbsp;<code>0</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/04/1.png\" style=\"width: 410px; height: 199px;\"></p>\n\n<pre><b>输入：</b>corridor = \"SSPPSPS\"\n<b>输出：</b>3\n<b>解释：</b>总共有 3 种不同分隔走廊的方案。\n上图中黑色的竖线表示已经放置好的屏风。\n上图每种方案中，每一段都恰好有 <strong>两个</strong>&nbsp;座位。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/04/2.png\" style=\"width: 357px; height: 68px;\"></p>\n\n<pre><b>输入：</b>corridor = \"PPSPSP\"\n<b>输出：</b>1\n<b>解释：</b>只有 1 种分隔走廊的方案，就是不放置任何屏风。\n放置任何的屏风都会导致有一段无法恰好有 2 个座位。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/12/3.png\" style=\"width: 115px; height: 68px;\"></p>\n\n<pre><b>输入：</b>corridor = \"S\"\n<b>输出：</b>0\n<b>解释：</b>没有任何方案，因为总是有一段无法恰好有 2 个座位。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == corridor.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>corridor[i]</code>&nbsp;要么是&nbsp;<code>'S'</code>&nbsp;，要么是&nbsp;<code>'P'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2148.元素计数",
        "hardRate": "EASY",
        "passRate": "57.77%",
        "problemsUrl": "https://leetcode.cn/problems/count-elements-with-strictly-smaller-and-greater-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/count-elements-with-strictly-smaller-and-greater-elements/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，统计并返回在 <code>nums</code> 中同时至少具有一个严格较小元素和一个严格较大元素的元素数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [11,7,2,15]\n<strong>输出：</strong>2\n<strong>解释：</strong>元素 7 ：严格较小元素是元素 2 ，严格较大元素是元素 11 。\n元素 11 ：严格较小元素是元素 7 ，严格较大元素是元素 15 。\n总计有 2 个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-3,3,3,90]\n<strong>输出：</strong>2\n<strong>解释：</strong>元素 3 ：严格较小元素是元素 -3 ，严格较大元素是元素 90 。\n由于有两个元素的值为 3 ，总计有 2 个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2149.按符号重排数组",
        "hardRate": "MEDIUM",
        "passRate": "79.75%",
        "problemsUrl": "https://leetcode.cn/problems/rearrange-array-elements-by-sign/",
        "solutionsUrl": "https://leetcode.cn/problems/rearrange-array-elements-by-sign/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，数组长度为 <strong>偶数</strong> ，由数目相等的正整数和负整数组成。</p>\n\n<p>你需要 <strong>重排</strong> <code>nums</code> 中的元素，使修改后的数组满足下述条件：</p>\n\n<ol>\n\t<li>任意&nbsp;<strong>连续</strong> 的两个整数 <strong>符号相反</strong></li>\n\t<li>对于符号相同的所有整数，<strong>保留</strong> 它们在 <code>nums</code> 中的 <strong>顺序</strong> 。</li>\n\t<li>重排后数组以正整数开头。</li>\n</ol>\n\n<p>重排元素满足上述条件后，返回修改后的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,1,-2,-5,2,-4]\n<strong>输出：</strong>[3,-2,1,-5,2,-4]\n<strong>解释：</strong>\nnums 中的正整数是 [3,1,2] ，负整数是 [-2,-5,-4] 。\n重排的唯一可行方案是 [3,-2,1,-5,2,-4]，能满足所有条件。\n像 [1,-2,2,-5,3,-4]、[3,1,2,-2,-5,-4]、[-2,3,-5,1,-4,2] 这样的其他方案是不正确的，因为不满足一个或者多个条件。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,1]\n<strong>输出：</strong>[1,-1]\n<strong>解释：</strong>\n1 是 nums 中唯一一个正整数，-1 是 nums 中唯一一个负整数。\n所以 nums 重排为 [1,-1] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>nums.length</code> 是 <strong>偶数</strong></li>\n\t<li><code>1 &lt;= |nums[i]| &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums</code> 由 <strong>相等</strong> 数量的正整数和负整数组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2150.找出数组中的所有孤独数字",
        "hardRate": "MEDIUM",
        "passRate": "59.57%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-lonely-numbers-in-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-lonely-numbers-in-the-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。如果数字 <code>x</code> 在数组中仅出现 <strong>一次</strong> ，且没有 <strong>相邻</strong> 数字（即，<code>x + 1</code> 和 <code>x - 1</code>）出现在数组中，则认为数字 <code>x</code> 是 <strong>孤独数字</strong> 。</p>\n\n<p>返回<em> </em><code>nums</code> 中的 <strong>所有</strong> 孤独数字。你可以按 <strong>任何顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [10,6,5,8]\n<strong>输出：</strong>[10,8]\n<strong>解释：</strong>\n- 10 是一个孤独数字，因为它只出现一次，并且 9 和 11 没有在 nums 中出现。\n- 8 是一个孤独数字，因为它只出现一次，并且 7 和 9 没有在 nums 中出现。\n- 5 不是一个孤独数字，因为 6 出现在 nums 中，反之亦然。\n因此，nums 中的孤独数字是 [10, 8] 。\n注意，也可以返回 [8, 10] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3,5,3]\n<strong>输出：</strong>[1,5]\n<strong>解释：</strong>\n- 1 是一个孤独数字，因为它只出现一次，并且 0 和 2 没有在 nums 中出现。\n- 5 是一个孤独数字，因为它只出现一次，并且 4 和 6 没有在 nums 中出现。\n- 3 不是一个孤独数字，因为它出现两次。\n因此，nums 中的孤独数字是 [1, 5] 。\n注意，也可以返回 [5, 1] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2151.基于陈述统计最多好人数",
        "hardRate": "HARD",
        "passRate": "50.37%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-good-people-based-on-statements/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-good-people-based-on-statements/solution",
        "problemsDesc": "<p>游戏中存在两种角色：</p>\n\n<ul>\n\t<li><strong>好人</strong>：该角色只说真话。</li>\n\t<li><strong>坏人</strong>：该角色可能说真话，也可能说假话。</li>\n</ul>\n\n<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>statements</code> ，大小为 <code>n x n</code> ，表示 <code>n</code> 个玩家对彼此角色的陈述。具体来说，<code>statements[i][j]</code> 可以是下述值之一：</p>\n\n<ul>\n\t<li><code>0</code> 表示 <code>i</code> 的陈述认为 <code>j</code> 是 <strong>坏人</strong> 。</li>\n\t<li><code>1</code> 表示 <code>i</code> 的陈述认为 <code>j</code> 是 <strong>好人</strong> 。</li>\n\t<li><code>2</code> 表示 <code>i</code> 没有对 <code>j</code> 作出陈述。</li>\n</ul>\n\n<p>另外，玩家不会对自己进行陈述。形式上，对所有&nbsp;<code>0 &lt;= i &lt; n</code> ，都有 <code>statements[i][i] = 2</code> 。</p>\n\n<p>根据这 <code>n</code> 个玩家的陈述，返回可以认为是 <strong>好人</strong> 的 <strong>最大</strong> 数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/01/15/logic1.jpg\" style=\"width: 600px; height: 262px;\">\n<pre><strong>输入：</strong>statements = [[2,1,2],[1,2,2],[2,0,2]]\n<strong>输出：</strong>2\n<strong>解释：</strong>每个人都做一条陈述。\n- 0 认为 1 是好人。\n- 1 认为 0 是好人。\n- 2 认为 1 是坏人。\n以 2 为突破点。\n- 假设 2 是一个好人：\n    - 基于 2 的陈述，1 是坏人。\n    - 那么可以确认 1 是坏人，2 是好人。\n    - 基于 1 的陈述，由于 1 是坏人，那么他在陈述时可能：\n        - 说真话。在这种情况下会出现矛盾，所以假设无效。\n        - 说假话。在这种情况下，0 也是坏人并且在陈述时说假话。\n    - <strong>在认为 2 是好人的情况下，这组玩家中只有一个好人。</strong>\n- 假设 2 是一个坏人：\n    - 基于 2 的陈述，由于 2 是坏人，那么他在陈述时可能：\n        - 说真话。在这种情况下，0 和 1 都是坏人。\n            - <strong>在认为 2 是坏人但说真话的情况下，这组玩家中没有一个好人。</strong>\n        - 说假话。在这种情况下，1 是好人。\n            - 由于 1 是好人，0 也是好人。\n            - <strong>在认为 2 是坏人且说假话的情况下，这组玩家中有两个好人。</strong>\n在最佳情况下，至多有两个好人，所以返回 2 。\n注意，能得到此结论的方法不止一种。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/01/15/logic2.jpg\" style=\"width: 600px; height: 262px;\">\n<pre><strong>输入：</strong>statements = [[2,0],[0,2]]\n<strong>输出：</strong>1\n<strong>解释：</strong>每个人都做一条陈述。\n- 0 认为 1 是坏人。\n- 1 认为 0 是坏人。\n以 0 为突破点。\n- 假设 0 是一个好人：\n    - 基于与 0 的陈述，1 是坏人并说假话。\n    - <strong>在认为 0 是好人的情况下，这组玩家中只有一个好人。</strong>\n- 假设 0 是一个坏人：\n    - 基于 0 的陈述，由于 0 是坏人，那么他在陈述时可能：\n        - 说真话。在这种情况下，0 和 1 都是坏人。\n            - <strong>在认为 0 是坏人但说真话的情况下，这组玩家中没有一个好人。</strong>\n        - 说假话。在这种情况下，1 是好人。\n            - <strong>在认为 0 是坏人且说假话的情况下，这组玩家中只有一个好人。</strong>\n在最佳情况下，至多有一个好人，所以返回 1 。 \n注意，能得到此结论的方法不止一种。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == statements.length == statements[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 15</code></li>\n\t<li><code>statements[i][j]</code> 的值为 <code>0</code>、<code>1</code> 或 <code>2</code></li>\n\t<li><code>statements[i][i] == 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2152.穿过所有点的所需最少直线数量",
        "hardRate": "MEDIUM",
        "passRate": "52.82%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-lines-to-cover-points/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-lines-to-cover-points/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2153.每辆车的乘客人数 II",
        "hardRate": "HARD",
        "passRate": "44.71%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-passengers-in-each-bus-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-passengers-in-each-bus-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2154.将找到的值乘以 2",
        "hardRate": "EASY",
        "passRate": "73.40%",
        "problemsUrl": "https://leetcode.cn/problems/keep-multiplying-found-values-by-two/",
        "solutionsUrl": "https://leetcode.cn/problems/keep-multiplying-found-values-by-two/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，另给你一个整数 <code>original</code> ，这是需要在 <code>nums</code> 中搜索的第一个数字。</p>\n\n<p>接下来，你需要按下述步骤操作：</p>\n\n<ol>\n\t<li>如果在 <code>nums</code> 中找到 <code>original</code> ，将 <code>original</code>&nbsp;<strong>乘以</strong> 2 ，得到新 <code>original</code>（即，令 <code>original = 2 * original</code>）。</li>\n\t<li>否则，停止这一过程。</li>\n\t<li>只要能在数组中找到新 <code>original</code> ，就对新 <code>original</code> 继续 <strong>重复</strong> 这一过程<strong>。</strong></li>\n</ol>\n\n<p>返回<em> </em><code>original</code> 的 <strong>最终</strong> 值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,3,6,1,12], original = 3\n<strong>输出：</strong>24\n<strong>解释：</strong> \n- 3 能在 nums 中找到。3 * 2 = 6 。\n- 6 能在 nums 中找到。6 * 2 = 12 。\n- 12 能在 nums 中找到。12 * 2 = 24 。\n- 24 不能在 nums 中找到。因此，返回 24 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,7,9], original = 4\n<strong>输出：</strong>4\n<strong>解释：</strong>\n- 4 不能在 nums 中找到。因此，返回 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i], original &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2155.分组得分最高的所有下标",
        "hardRate": "MEDIUM",
        "passRate": "64.61%",
        "problemsUrl": "https://leetcode.cn/problems/all-divisions-with-the-highest-score-of-a-binary-array/",
        "solutionsUrl": "https://leetcode.cn/problems/all-divisions-with-the-highest-score-of-a-binary-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的二进制数组 <code>nums</code> ，数组长度为 <code>n</code> 。<code>nums</code> 可以按下标 <code>i</code>（ <code>0 &lt;= i &lt;= n</code> ）拆分成两个数组（可能为空）：<code>nums<sub>left</sub></code> 和 <code>nums<sub>right</sub></code> 。</p>\n\n<ul>\n\t<li><code>nums<sub>left</sub></code> 包含 <code>nums</code> 中从下标 <code>0</code> 到 <code>i - 1</code> 的所有元素<strong>（包括 </strong><code>0</code><strong> 和 </strong><code>i - 1</code><strong> ）</strong>，而 <code>nums<sub>right</sub></code> 包含 <code>nums</code> 中从下标 <code>i</code> 到 <code>n - 1</code> 的所有元素<strong>（包括 </strong><code>i</code><strong> 和 </strong><code>n - 1</code><strong> ）。</strong></li>\n\t<li>如果 <code>i == 0</code> ，<code>nums<sub>left</sub></code> 为 <strong>空</strong> ，而 <code>nums<sub>right</sub></code> 将包含 <code>nums</code> 中的所有元素。</li>\n\t<li>如果 <code>i == n</code> ，<code>nums<sub>left</sub></code> 将包含 <code>nums</code> 中的所有元素，而 <code>nums<sub>right</sub></code> 为 <strong>空</strong> 。</li>\n</ul>\n\n<p>下标 <code>i</code><strong> </strong>的<strong> 分组得分</strong> 为 <code>nums<sub>left</sub></code> 中 <code>0</code> 的个数和 <code>nums<sub>right</sub></code> 中 <code>1</code> 的个数之<strong> 和</strong> 。</p>\n\n<p>返回 <strong>分组得分 最高</strong> 的 <strong>所有不同下标</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,0,1,0]\n<strong>输出：</strong>[2,4]\n<strong>解释：</strong>按下标分组\n- 0 ：nums<sub>left</sub> 为 [] 。nums<sub>right</sub> 为 [0,0,<em><strong>1</strong></em>,0] 。得分为 0 + 1 = 1 。\n- 1 ：nums<sub>left</sub> 为 [<em><strong>0</strong></em>] 。nums<sub>right</sub> 为 [0,<em><strong>1</strong></em>,0] 。得分为 1 + 1 = 2 。\n- 2 ：nums<sub>left</sub> 为 [<em><strong>0</strong></em>,<em><strong>0</strong></em>] 。nums<sub>right</sub> 为 [<em><strong>1</strong></em>,0] 。得分为 2 + 1 = 3 。\n- 3 ：nums<sub>left</sub> 为 [<em><strong>0</strong></em>,<em><strong>0</strong></em>,1] 。nums<sub>right</sub> 为 [0] 。得分为 2 + 0 = 2 。\n- 4 ：nums<sub>left</sub> 为 [<em><strong>0</strong></em>,<em><strong>0</strong></em>,1,<em><strong>0</strong></em>] 。nums<sub>right</sub> 为 [] 。得分为 3 + 0 = 3 。\n下标 2 和 4 都可以得到最高的分组得分 3 。\n注意，答案 [4,2] 也被视为正确答案。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,0,0]\n<strong>输出：</strong>[3]\n<strong>解释：</strong>按下标分组\n- 0 ：nums<sub>left</sub> 为 [] 。nums<sub>right</sub> 为 [0,0,0] 。得分为 0 + 0 = 0 。\n- 1 ：nums<sub>left</sub> 为 [<em><strong>0</strong></em>] 。nums<sub>right</sub> 为 [0,0] 。得分为 1 + 0 = 1 。\n- 2 ：nums<sub>left</sub> 为 [<em><strong>0</strong></em>,<em><strong>0</strong></em>] 。nums<sub>right</sub> 为 [0] 。得分为 2 + 0 = 2 。\n- 3 ：nums<sub>left</sub> 为 [<em><strong>0</strong></em>,<em><strong>0</strong></em>,<em><strong>0</strong></em>] 。nums<sub>right</sub> 为 [] 。得分为 3 + 0 = 3 。\n只有下标 3 可以得到最高的分组得分 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1]\n<strong>输出：</strong>[0]\n<strong>解释：</strong>按下标分组\n- 0 ：nums<sub>left</sub> 为 [] 。nums<sub>right</sub> 为 [<em><strong>1</strong></em>,<em><strong>1</strong></em>] 。得分为 0 + 2 = 2 。\n- 1 ：nums<sub>left</sub> 为 [1] 。nums<sub>right</sub> 为 [<em><strong>1</strong></em>] 。得分为 0 + 1 = 1 。\n- 2 ：nums<sub>left</sub> 为 [1,1] 。nums<sub>right</sub> 为 [] 。得分为 0 + 0 = 0 。\n只有下标 0 可以得到最高的分组得分 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2156.查找给定哈希值的子串",
        "hardRate": "HARD",
        "passRate": "25.27%",
        "problemsUrl": "https://leetcode.cn/problems/find-substring-with-given-hash-value/",
        "solutionsUrl": "https://leetcode.cn/problems/find-substring-with-given-hash-value/solution",
        "problemsDesc": "<p>给定整数 <code>p</code>&nbsp;和 <code>m</code>&nbsp;，一个长度为 <code>k</code>&nbsp;且下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>s</code>&nbsp;的哈希值按照如下函数计算：</p>\n\n<ul>\n\t<li><code>hash(s, p, m) = (val(s[0]) * p<sup>0</sup> + val(s[1]) * p<sup>1</sup> + ... + val(s[k-1]) * p<sup>k-1</sup>) mod m</code>.</li>\n</ul>\n\n<p>其中&nbsp;<code>val(s[i])</code>&nbsp;表示&nbsp;<code>s[i]</code>&nbsp;在字母表中的下标，从&nbsp;<code>val('a') = 1</code> 到&nbsp;<code>val('z') = 26</code>&nbsp;。</p>\n\n<p>给你一个字符串&nbsp;<code>s</code>&nbsp;和整数&nbsp;<code>power</code>，<code>modulo</code>，<code>k</code>&nbsp;和&nbsp;<code>hashValue</code>&nbsp;。请你返回 <code>s</code>&nbsp;中 <strong>第一个</strong> 长度为 <code>k</code>&nbsp;的 <strong>子串</strong>&nbsp;<code>sub</code>&nbsp;，满足<em>&nbsp;</em><code>hash(sub, power, modulo) == hashValue</code>&nbsp;。</p>\n\n<p>测试数据保证一定 <strong>存在</strong>&nbsp;至少一个这样的子串。</p>\n\n<p><strong>子串</strong> 定义为一个字符串中连续非空字符组成的序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"leetcode\", power = 7, modulo = 20, k = 2, hashValue = 0\n<strong>输出：</strong>\"ee\"\n<strong>解释：</strong>\"ee\" 的哈希值为 hash(\"ee\", 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0 。\n\"ee\" 是长度为 2 的第一个哈希值为 0 的子串，所以我们返回 \"ee\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"fbxzaad\", power = 31, modulo = 100, k = 3, hashValue = 32\n<b>输出：</b>\"fbx\"\n<b>解释：</b>\"fbx\" 的哈希值为 hash(\"fbx\", 31, 100) = (6 * 1 + 2 * 31 + 24 * 31<sup>2</sup>) mod 100 = 23132 mod 100 = 32 。\n\"bxz\" 的哈希值为 hash(\"bxz\", 31, 100) = (2 * 1 + 24 * 31 + 26 * 31<sup>2</sup>) mod 100 = 25732 mod 100 = 32 。\n\"fbx\" 是长度为 3 的第一个哈希值为 32 的子串，所以我们返回 \"fbx\" 。\n注意，\"bxz\" 的哈希值也为 32 ，但是它在字符串中比 \"fbx\" 更晚出现。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= s.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= power, modulo &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= hashValue &lt; modulo</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n\t<li>测试数据保证一定 <strong>存在</strong>&nbsp;满足条件的子串。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2157.字符串分组",
        "hardRate": "HARD",
        "passRate": "31.34%",
        "problemsUrl": "https://leetcode.cn/problems/groups-of-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/groups-of-strings/solution",
        "problemsDesc": "<p>给你一个下标从&nbsp;<strong>0&nbsp;</strong>开始的字符串数组&nbsp;<code>words</code>&nbsp;。每个字符串都只包含 <strong>小写英文字母</strong>&nbsp;。<code>words</code>&nbsp;中任意一个子串中，每个字母都至多只出现一次。</p>\n\n<p>如果通过以下操作之一，我们可以从 <code>s1</code>&nbsp;的字母集合得到 <code>s2</code>&nbsp;的字母集合，那么我们称这两个字符串为 <strong>关联的</strong>&nbsp;：</p>\n\n<ul>\n\t<li>往&nbsp;<code>s1</code>&nbsp;的字母集合中添加一个字母。</li>\n\t<li>从&nbsp;<code>s1</code>&nbsp;的字母集合中删去一个字母。</li>\n\t<li>将 <code>s1</code>&nbsp;中的一个字母替换成另外任意一个字母（也可以替换为这个字母本身）。</li>\n</ul>\n\n<p>数组&nbsp;<code>words</code>&nbsp;可以分为一个或者多个无交集的 <strong>组</strong>&nbsp;。如果一个字符串与另一个字符串关联，那么它们应当属于同一个组。</p>\n\n<p>注意，你需要确保分好组后，一个组内的任一字符串与其他组的字符串都不关联。可以证明在这个条件下，分组方案是唯一的。</p>\n\n<p>请你返回一个长度为 <code>2</code>&nbsp;的数组&nbsp;<code>ans</code>&nbsp;：</p>\n\n<ul>\n\t<li><code>ans[0]</code>&nbsp;是&nbsp;<code>words</code>&nbsp;分组后的&nbsp;<strong>总组数</strong>&nbsp;。</li>\n\t<li><code>ans[1]</code>&nbsp;是字符串数目最多的组所包含的字符串数目。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"a\",\"b\",\"ab\",\"cde\"]\n<b>输出：</b>[2,3]\n<b>解释：</b>\n- words[0] 可以得到 words[1] （将 'a' 替换为 'b'）和 words[2] （添加 'b'）。所以 words[0] 与 words[1] 和 words[2] 关联。\n- words[1] 可以得到 words[0] （将 'b' 替换为 'a'）和 words[2] （添加 'a'）。所以 words[1] 与 words[0] 和 words[2] 关联。\n- words[2] 可以得到 words[0] （删去 'b'）和 words[1] （删去 'a'）。所以 words[2] 与 words[0] 和 words[1] 关联。\n- words[3] 与 words 中其他字符串都不关联。\n所以，words 可以分成 2 个组 [\"a\",\"b\",\"ab\"] 和 [\"cde\"] 。最大的组大小为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"a\",\"ab\",\"abc\"]\n<b>输出：</b>[1,3]\n<strong>解释：</strong>\n- words[0] 与 words[1] 关联。\n- words[1] 与 words[0] 和 words[2] 关联。\n- words[2] 与 words[1] 关联。\n由于所有字符串与其他字符串都关联，所以它们全部在同一个组内。\n所以最大的组大小为 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 26</code></li>\n\t<li><code>words[i]</code>&nbsp;只包含小写英文字母。</li>\n\t<li><code>words[i]</code> 中每个字母最多只出现一次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2158.每天绘制新区域的数量",
        "hardRate": "HARD",
        "passRate": "55.78%",
        "problemsUrl": "https://leetcode.cn/problems/amount-of-new-area-painted-each-day/",
        "solutionsUrl": "https://leetcode.cn/problems/amount-of-new-area-painted-each-day/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2159.分别排序两列",
        "hardRate": "MEDIUM",
        "passRate": "61.24%",
        "problemsUrl": "https://leetcode.cn/problems/order-two-columns-independently/",
        "solutionsUrl": "https://leetcode.cn/problems/order-two-columns-independently/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2160.拆分数位后四位数字的最小和",
        "hardRate": "EASY",
        "passRate": "84.25%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-sum-of-four-digit-number-after-splitting-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-sum-of-four-digit-number-after-splitting-digits/solution",
        "problemsDesc": "<p>给你一个四位&nbsp;<strong>正</strong>&nbsp;整数&nbsp;<code>num</code>&nbsp;。请你使用 <code>num</code>&nbsp;中的 <strong>数位</strong> ，将&nbsp;<code>num</code>&nbsp;拆成两个新的整数&nbsp;<code>new1</code>&nbsp;和&nbsp;<code>new2</code>&nbsp;。<code>new1</code> 和&nbsp;<code>new2</code>&nbsp;中可以有&nbsp;<strong>前导 0</strong>&nbsp;，且&nbsp;<code>num</code>&nbsp;中 <strong>所有</strong>&nbsp;数位都必须使用。</p>\n\n<ul>\n\t<li>比方说，给你&nbsp;<code>num = 2932</code>&nbsp;，你拥有的数位包括：两个&nbsp;<code>2</code>&nbsp;，一个&nbsp;<code>9</code>&nbsp;和一个&nbsp;<code>3</code>&nbsp;。一些可能的&nbsp;<code>[new1, new2]</code>&nbsp;数对为&nbsp;<code>[22, 93]</code>，<code>[23, 92]</code>，<code>[223, 9]</code> 和&nbsp;<code>[2, 329]</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回可以得到的&nbsp;<code>new1</code>&nbsp;和 <code>new2</code>&nbsp;的 <strong>最小</strong>&nbsp;和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>num = 2932\n<b>输出：</b>52\n<b>解释：</b>可行的 [new1, new2] 数对为 [29, 23] ，[223, 9] 等等。\n最小和为数对 [29, 23] 的和：29 + 23 = 52 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>num = 4009\n<b>输出：</b>13\n<b>解释：</b>可行的 [new1, new2] 数对为 [0, 49] ，[490, 0] 等等。\n最小和为数对 [4, 9] 的和：4 + 9 = 13 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1000 &lt;= num &lt;= 9999</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2161.根据给定数字划分数组",
        "hardRate": "MEDIUM",
        "passRate": "82.41%",
        "problemsUrl": "https://leetcode.cn/problems/partition-array-according-to-given-pivot/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-array-according-to-given-pivot/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>pivot</code>&nbsp;。请你将&nbsp;<code>nums</code>&nbsp;重新排列，使得以下条件均成立：</p>\n\n<ul>\n\t<li>所有小于&nbsp;<code>pivot</code>&nbsp;的元素都出现在所有大于&nbsp;<code>pivot</code>&nbsp;的元素&nbsp;<strong>之前</strong>&nbsp;。</li>\n\t<li>所有等于&nbsp;<code>pivot</code>&nbsp;的元素都出现在小于和大于 <code>pivot</code>&nbsp;的元素 <strong>中间</strong>&nbsp;。</li>\n\t<li>小于 <code>pivot</code>&nbsp;的元素之间和大于 <code>pivot</code>&nbsp;的元素之间的 <strong>相对顺序</strong>&nbsp;不发生改变。\n\t<ul>\n\t\t<li>更正式的，考虑每一对&nbsp;<code>p<sub>i</sub></code>，<code>p<sub>j</sub></code>&nbsp;，<code>p<sub>i</sub></code>&nbsp;是初始时位置 <code>i</code>&nbsp;元素的新位置，<code>p<sub>j</sub></code>&nbsp;是初始时位置&nbsp;<code>j</code>&nbsp;元素的新位置。对于小于&nbsp;<code>pivot</code>&nbsp;的元素，如果&nbsp;<code>i &lt; j</code>&nbsp;且&nbsp;<code>nums[i] &lt; pivot</code> 和&nbsp;<code>nums[j] &lt; pivot</code>&nbsp;都成立，那么&nbsp;<code>p<sub>i</sub> &lt; p<sub>j</sub></code>&nbsp;也成立。类似的，对于大于&nbsp;<code>pivot</code>&nbsp;的元素，如果&nbsp;<code>i &lt; j</code> 且&nbsp;<code>nums[i] &gt; pivot</code> 和&nbsp;<code>nums[j] &gt; pivot</code>&nbsp;都成立，那么&nbsp;<code>p<sub>i</sub> &lt; p<sub>j</sub></code>&nbsp;。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回重新排列 <code>nums</code>&nbsp;数组后的结果数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [9,12,5,10,14,3,10], pivot = 10\n<b>输出：</b>[9,5,3,10,10,12,14]\n<b>解释：</b>\n元素 9 ，5 和 3 小于 pivot ，所以它们在数组的最左边。\n元素 12 和 14 大于 pivot ，所以它们在数组的最右边。\n小于 pivot 的元素的相对位置和大于 pivot 的元素的相对位置分别为 [9, 5, 3] 和 [12, 14] ，它们在结果数组中的相对顺序需要保留。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [-3,4,3,2], pivot = 2\n<b>输出：</b>[-3,2,4,3]\n<b>解释：</b>\n元素 -3 小于 pivot ，所以在数组的最左边。\n元素 4 和 3 大于 pivot ，所以它们在数组的最右边。\n小于 pivot 的元素的相对位置和大于 pivot 的元素的相对位置分别为 [-3] 和 [4, 3] ，它们在结果数组中的相对顺序需要保留。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>6</sup> &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>pivot</code>&nbsp;等于&nbsp;<code>nums</code>&nbsp;中的一个元素。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2162.设置时间的最少代价",
        "hardRate": "MEDIUM",
        "passRate": "34.34%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-set-cooking-time/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-set-cooking-time/solution",
        "problemsDesc": "<p>常见的微波炉可以设置加热时间，且加热时间满足以下条件：</p>\n\n<ul>\n\t<li>至少为 <code>1</code>&nbsp;秒钟。</li>\n\t<li>至多为&nbsp;<code>99</code>&nbsp;分&nbsp;<code>99</code>&nbsp;秒。</li>\n</ul>\n\n<p>你可以 <strong>最多</strong>&nbsp;输入&nbsp;<strong>4 个数字</strong>&nbsp;来设置加热时间。如果你输入的位数不足 4 位，微波炉会自动加 <strong>前缀</strong>&nbsp;<strong>0</strong>&nbsp;来补足 4 位。微波炉会将设置好的四位数中，<strong>前</strong>&nbsp;两位当作分钟数，<strong>后</strong>&nbsp;两位当作秒数。它们所表示的总时间就是加热时间。比方说：</p>\n\n<ul>\n\t<li>你输入&nbsp;<code>9</code> <code>5</code> <code>4</code>&nbsp;（三个数字），被自动补足为&nbsp;<code>0954</code>&nbsp;，并表示&nbsp;<code>9</code>&nbsp;分&nbsp;<code>54</code>&nbsp;秒。</li>\n\t<li>你输入&nbsp;<code>0</code> <code>0</code> <code>0</code> <code>8</code>&nbsp;（四个数字），表示&nbsp;<code>0</code>&nbsp;分&nbsp;<code>8</code>&nbsp;秒。</li>\n\t<li>你输入&nbsp;<code>8</code> <code>0</code> <code>9</code> <code>0</code>&nbsp;，表示&nbsp;<code>80</code>&nbsp;分&nbsp;<code>90</code>&nbsp;秒。</li>\n\t<li>你输入&nbsp;<code>8</code> <code>1</code> <code>3</code> <code>0</code>&nbsp;，表示&nbsp;<code>81</code>&nbsp;分&nbsp;<code>30</code>&nbsp;秒。</li>\n</ul>\n\n<p>给你整数&nbsp;<code>startAt</code>&nbsp;，<code>moveCost</code>&nbsp;，<code>pushCost</code>&nbsp;和&nbsp;<code>targetSeconds</code>&nbsp;。<strong>一开始</strong>，你的手指在数字&nbsp;<code>startAt</code>&nbsp;处。将手指移到<strong>&nbsp;任何其他数字</strong>&nbsp;，需要花费&nbsp;<code>moveCost</code>&nbsp;的单位代价。<strong>每</strong>&nbsp;输入你手指所在位置的数字一次，需要花费&nbsp;<code>pushCost</code>&nbsp;的单位代价。</p>\n\n<p>要设置&nbsp;<code>targetSeconds</code>&nbsp;秒的加热时间，可能会有多种设置方法。你想要知道这些方法中，总代价最小为多少。</p>\n\n<p>请你能返回设置&nbsp;<code>targetSeconds</code>&nbsp;秒钟加热时间需要花费的最少代价。</p>\n\n<p>请记住，虽然微波炉的秒数最多可以设置到 <code>99</code>&nbsp;秒，但一分钟等于&nbsp;<code>60</code>&nbsp;秒。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/30/1.png\" style=\"width: 506px; height: 210px;\"></p>\n\n<pre><b>输入：</b>startAt = 1, moveCost = 2, pushCost = 1, targetSeconds = 600\n<b>输出：</b>6\n<b>解释：</b>以下为设置加热时间的所有方法。\n- 1 0 0 0 ，表示 10 分 0 秒。\n&nbsp; 手指一开始就在数字 1 处，输入 1 （代价为 1），移到 0 处（代价为 2），输入 0（代价为 1），输入 0（代价为 1），输入 0（代价为 1）。\n&nbsp; 总代价为：1 + 2 + 1 + 1 + 1 = 6 。这是所有方案中的最小代价。\n- 0 9 6 0，表示 9 分 60 秒。它也表示 600 秒。\n&nbsp; 手指移到 0 处（代价为 2），输入 0 （代价为 1），移到 9 处（代价为 2），输入 9（代价为 1），移到 6 处（代价为 2），输入 6（代价为 1），移到 0 处（代价为 2），输入 0（代价为 1）。\n&nbsp; 总代价为：2 + 1 + 2 + 1 + 2 + 1 + 2 + 1 = 12 。\n- 9 6 0，微波炉自动补全为 0960 ，表示 9 分 60 秒。\n&nbsp; 手指移到 9 处（代价为 2），输入 9 （代价为 1），移到 6 处（代价为 2），输入 6（代价为 1），移到 0 处（代价为 2），输入 0（代价为 1）。\n&nbsp; 总代价为：2 + 1 + 2 + 1 + 2 + 1 = 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/30/2.png\" style=\"width: 505px; height: 73px;\"></p>\n\n<pre><b>输入：</b>startAt = 0, moveCost = 1, pushCost = 2, targetSeconds = 76\n<b>输出：</b>6\n<b>解释：</b>最优方案为输入两个数字 7 6，表示 76 秒。\n手指移到 7 处（代价为 1），输入 7 （代价为 2），移到 6 处（代价为 1），输入 6（代价为 2）。总代价为：1 + 2 + 1 + 2 = 6\n其他可行方案为 0076 ，076 ，0116 和 116 ，但是它们的代价都比 6 大。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= startAt &lt;= 9</code></li>\n\t<li><code>1 &lt;= moveCost, pushCost &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= targetSeconds &lt;= 6039</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2163.删除元素后和的最小差值",
        "hardRate": "HARD",
        "passRate": "49.18%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-difference-in-sums-after-removal-of-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-difference-in-sums-after-removal-of-elements/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，它包含&nbsp;<code>3 * n</code>&nbsp;个元素。</p>\n\n<p>你可以从 <code>nums</code>&nbsp;中删除 <strong>恰好</strong>&nbsp;<code>n</code>&nbsp;个元素，剩下的 <code>2 * n</code>&nbsp;个元素将会被分成两个 <strong>相同大小</strong>&nbsp;的部分。</p>\n\n<ul>\n\t<li>前面&nbsp;<code>n</code>&nbsp;个元素属于第一部分，它们的和记为&nbsp;<code>sum<sub>first</sub></code>&nbsp;。</li>\n\t<li>后面&nbsp;<code>n</code>&nbsp;个元素属于第二部分，它们的和记为&nbsp;<code>sum<sub>second</sub></code>&nbsp;。</li>\n</ul>\n\n<p>两部分和的 <strong>差值</strong>&nbsp;记为&nbsp;<code>sum<sub>first</sub> - sum<sub>second</sub></code>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，<code>sum<sub>first</sub> = 3</code> 且&nbsp;<code>sum<sub>second</sub> = 2</code>&nbsp;，它们的差值为&nbsp;<code>1</code>&nbsp;。</li>\n\t<li>再比方，<code>sum<sub>first</sub> = 2</code> 且&nbsp;<code>sum<sub>second</sub> = 3</code>&nbsp;，它们的差值为&nbsp;<code>-1</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回删除 <code>n</code>&nbsp;个元素之后，剩下两部分和的 <strong>差值的最小值</strong>&nbsp;是多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [3,1,2]\n<b>输出：</b>-1\n<b>解释：</b>nums 有 3 个元素，所以 n = 1 。\n所以我们需要从 nums 中删除 1 个元素，并将剩下的元素分成两部分。\n- 如果我们删除 nums[0] = 3 ，数组变为 [1,2] 。两部分和的差值为 1 - 2 = -1 。\n- 如果我们删除 nums[1] = 1 ，数组变为 [3,2] 。两部分和的差值为 3 - 2 = 1 。\n- 如果我们删除 nums[2] = 2 ，数组变为 [3,1] 。两部分和的差值为 3 - 1 = 2 。\n两部分和的最小差值为 min(-1,1,2) = -1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [7,9,5,8,1,3]\n<b>输出：</b>1\n<b>解释：</b>n = 2 。所以我们需要删除 2 个元素，并将剩下元素分为 2 部分。\n如果我们删除元素 nums[2] = 5 和 nums[3] = 8 ，剩下元素为 [7,9,1,3] 。和的差值为 (7+9) - (1+3) = 12 。\n为了得到最小差值，我们应该删除 nums[1] = 9 和 nums[4] = 1 ，剩下的元素为 [7,5,8,3] 。和的差值为 (7+5) - (8+3) = 1 。\n观察可知，最优答案为 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length == 3 * n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2164.对奇偶下标分别排序",
        "hardRate": "EASY",
        "passRate": "68.48%",
        "problemsUrl": "https://leetcode.cn/problems/sort-even-and-odd-indices-independently/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-even-and-odd-indices-independently/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。根据下述规则重排 <code>nums</code> 中的值：</p>\n\n<ol>\n\t<li>按 <strong>非递增</strong> 顺序排列 <code>nums</code> <strong>奇数下标</strong> 上的所有值。\n\n\t<ul>\n\t\t<li>举个例子，如果排序前 <code>nums = [4,<em><strong>1</strong></em>,2,<em><strong>3</strong></em>]</code> ，对奇数下标的值排序后变为 <code>[4,<em><strong>3</strong></em>,2,<em><strong>1</strong></em>]</code> 。奇数下标 <code>1</code> 和 <code>3</code> 的值按照非递增顺序重排。</li>\n\t</ul>\n\t</li>\n\t<li>按 <strong>非递减</strong> 顺序排列 <code>nums</code> <strong>偶数下标</strong> 上的所有值。\n\t<ul>\n\t\t<li>举个例子，如果排序前 <code>nums = [<em><strong>4</strong></em>,1,<em><strong>2</strong></em>,3]</code> ，对偶数下标的值排序后变为 <code>[<em><strong>2</strong></em>,1,<em><strong>4</strong></em>,3]</code> 。偶数下标 <code>0</code> 和 <code>2</code> 的值按照非递减顺序重排。</li>\n\t</ul>\n\t</li>\n</ol>\n\n<p>返回重排 <code>nums</code> 的值之后形成的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,1,2,3]\n<strong>输出：</strong>[2,3,4,1]\n<strong>解释：</strong>\n首先，按非递增顺序重排奇数下标（1 和 3）的值。\n所以，nums 从 [4,<em><strong>1</strong></em>,2,<em><strong>3</strong></em>] 变为 [4,<em><strong>3</strong></em>,2,<em><strong>1</strong></em>] 。\n然后，按非递减顺序重排偶数下标（0 和 2）的值。\n所以，nums 从 [<em><strong>4</strong></em>,1,<em><strong>2</strong></em>,3] 变为 [<em><strong>2</strong></em>,3,<em><strong>4</strong></em>,1] 。\n因此，重排之后形成的数组是 [2,3,4,1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1]\n<strong>输出：</strong>[2,1]\n<strong>解释：</strong>\n由于只有一个奇数下标和一个偶数下标，所以不会发生重排。\n形成的结果数组是 [2,1] ，和初始数组一样。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2165.重排数字的最小值",
        "hardRate": "MEDIUM",
        "passRate": "55.12%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-value-of-the-rearranged-number/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-value-of-the-rearranged-number/solution",
        "problemsDesc": "<p>给你一个整数 <code>num</code> 。<strong>重排</strong> <code>num</code> 中的各位数字，使其值 <strong>最小化</strong> 且不含 <strong>任何</strong> 前导零。</p>\n\n<p>返回不含前导零且值最小的重排数字。</p>\n\n<p>注意，重排各位数字后，<code>num</code> 的符号不会改变。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 310\n<strong>输出：</strong>103\n<strong>解释：</strong>310 中各位数字的可行排列有：013、031、103、130、301、310 。\n不含任何前导零且值最小的重排数字是 103 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = -7605\n<strong>输出：</strong>-7650\n<strong>解释：</strong>-7605 中各位数字的部分可行排列为：-7650、-6705、-5076、-0567。\n不含任何前导零且值最小的重排数字是 -7650 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-10<sup>15</sup> &lt;= num &lt;= 10<sup>15</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2166.设计位集",
        "hardRate": "MEDIUM",
        "passRate": "30.74%",
        "problemsUrl": "https://leetcode.cn/problems/design-bitset/",
        "solutionsUrl": "https://leetcode.cn/problems/design-bitset/solution",
        "problemsDesc": "<p><strong>位集 Bitset</strong> 是一种能以紧凑形式存储位的数据结构。</p>\n\n<p>请你实现 <code>Bitset</code> 类。</p>\n\n<ul>\n\t<li><code>Bitset(int size)</code> 用 <code>size</code> 个位初始化 Bitset ，所有位都是 <code>0</code> 。</li>\n\t<li><code>void fix(int idx)</code> 将下标为 <code>idx</code> 的位上的值更新为 <code>1</code> 。如果值已经是 <code>1</code> ，则不会发生任何改变。</li>\n\t<li><code>void unfix(int idx)</code> 将下标为 <code>idx</code> 的位上的值更新为 <code>0</code> 。如果值已经是 <code>0</code> ，则不会发生任何改变。</li>\n\t<li><code>void flip()</code> 翻转 Bitset 中每一位上的值。换句话说，所有值为 <code>0</code> 的位将会变成 <code>1</code> ，反之亦然。</li>\n\t<li><code>boolean all()</code> 检查&nbsp;Bitset 中 <strong>每一位</strong> 的值是否都是 <code>1</code> 。如果满足此条件，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n\t<li><code>boolean one()</code> 检查&nbsp;Bitset 中 是否&nbsp;<strong>至少一位</strong> 的值是 <code>1</code> 。如果满足此条件，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n\t<li><code>int count()</code> 返回 Bitset 中值为 1 的位的 <strong>总数</strong> 。</li>\n\t<li><code>String toString()</code> 返回 Bitset 的当前组成情况。注意，在结果字符串中，第 <code>i</code> 个下标处的字符应该与 Bitset 中的第 <code>i</code> 位一致。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"Bitset\", \"fix\", \"fix\", \"flip\", \"all\", \"unfix\", \"flip\", \"one\", \"unfix\", \"count\", \"toString\"]\n[[5], [3], [1], [], [], [0], [], [], [0], [], []]\n<strong>输出</strong>\n[null, null, null, null, false, null, null, true, null, 2, \"01010\"]\n\n<strong>解释</strong>\nBitset bs = new Bitset(5); // bitset = \"00000\".\nbs.fix(3);     // 将 idx = 3 处的值更新为 1 ，此时 bitset = \"00010\" 。\nbs.fix(1);     // 将 idx = 1 处的值更新为 1 ，此时 bitset = \"01010\" 。\nbs.flip();     // 翻转每一位上的值，此时 bitset = \"10101\" 。\nbs.all();      // 返回 False ，bitset 中的值不全为 1 。\nbs.unfix(0);   // 将 idx = 0 处的值更新为 0 ，此时 bitset = \"00101\" 。\nbs.flip();     // 翻转每一位上的值，此时 bitset = \"11010\" 。\nbs.one();      // 返回 True ，至少存在一位的值为 1 。\nbs.unfix(0);   // 将 idx = 0 处的值更新为 0 ，此时 bitset = \"01010\" 。\nbs.count();    // 返回 2 ，当前有 2 位的值为 1 。\nbs.toString(); // 返回 \"01010\" ，即 bitset 的当前组成情况。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= size &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= idx &lt;= size - 1</code></li>\n\t<li>至多调用&nbsp;<code>fix</code>、<code>unfix</code>、<code>flip</code>、<code>all</code>、<code>one</code>、<code>count</code> 和 <code>toString</code> 方法 <strong>总共</strong> <code>10<sup>5</sup></code> 次</li>\n\t<li>至少调用 <code>all</code>、<code>one</code>、<code>count</code> 或 <code>toString</code> 方法一次</li>\n\t<li>至多调用&nbsp;<code>toString</code> 方法 <code>5</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2167.移除所有载有违禁货物车厢所需的最少时间",
        "hardRate": "HARD",
        "passRate": "49.26%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的二进制字符串 <code>s</code> ，表示一个列车车厢序列。<code>s[i] = '0'</code> 表示第 <code>i</code> 节车厢 <strong>不</strong> 含违禁货物，而 <code>s[i] = '1'</code> 表示第 <code>i</code> 节车厢含违禁货物。</p>\n\n<p>作为列车长，你需要清理掉所有载有违禁货物的车厢。你可以不限次数执行下述三种操作中的任意一个：</p>\n\n<ol>\n\t<li>从列车 <strong>左</strong> 端移除一节车厢（即移除 <code>s[0]</code>），用去 1 单位时间。</li>\n\t<li>从列车 <strong>右</strong> 端移除一节车厢（即移除 <code>s[s.length - 1]</code>），用去 1 单位时间。</li>\n\t<li>从列车车厢序列的 <strong>任意位置</strong> 移除一节车厢，用去 2 单位时间。</li>\n</ol>\n\n<p>返回移除所有载有违禁货物车厢所需要的 <strong>最少</strong> 单位时间数。</p>\n\n<p>注意，空的列车车厢序列视为没有车厢含违禁货物。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"<em><strong>11</strong></em>00<em><strong>1</strong></em>0<em><strong>1</strong></em>\"\n<strong>输出：</strong>5\n<strong>解释：</strong>\n一种从序列中移除所有载有违禁货物的车厢的方法是：\n- 从左端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。\n- 从右端移除一节车厢 1 次。所用时间是 1 。\n- 移除序列中间位置载有违禁货物的车厢。所用时间是 2 。\n总时间是 2 + 1 + 2 = 5 。\n\n一种替代方法是：\n- 从左端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。\n- 从右端移除一节车厢 3 次。所用时间是 3 * 1 = 3 。\n总时间也是 2 + 3 = 5 。\n\n5 是移除所有载有违禁货物的车厢所需要的最少单位时间数。\n没有其他方法能够用更少的时间移除这些车厢。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"00<em><strong>1</strong></em>0\"\n<strong>输出：</strong>2\n<strong>解释：</strong>\n一种从序列中移除所有载有违禁货物的车厢的方法是：\n- 从左端移除一节车厢 3 次。所用时间是 3 * 1 = 3 。\n总时间是 3.\n\n另一种从序列中移除所有载有违禁货物的车厢的方法是：\n- 移除序列中间位置载有违禁货物的车厢。所用时间是 2 。\n总时间是 2.\n\n另一种从序列中移除所有载有违禁货物的车厢的方法是：\n- 从右端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。\n总时间是 2.\n\n2 是移除所有载有违禁货物的车厢所需要的最少单位时间数。\n没有其他方法能够用更少的时间移除这些车厢。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2168.每个数字的频率都相同的独特子字符串的数量",
        "hardRate": "MEDIUM",
        "passRate": "63.24%",
        "problemsUrl": "https://leetcode.cn/problems/unique-substrings-with-equal-digit-frequency/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-substrings-with-equal-digit-frequency/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2169.得到 0 的操作数",
        "hardRate": "EASY",
        "passRate": "73.38%",
        "problemsUrl": "https://leetcode.cn/problems/count-operations-to-obtain-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/count-operations-to-obtain-zero/solution",
        "problemsDesc": "<p>给你两个 <strong>非负</strong> 整数 <code>num1</code> 和 <code>num2</code> 。</p>\n\n<p>每一步 <strong>操作</strong>&nbsp;中，如果 <code>num1 &gt;= num2</code> ，你必须用 <code>num1</code> 减 <code>num2</code> ；否则，你必须用 <code>num2</code> 减 <code>num1</code> 。</p>\n\n<ul>\n\t<li>例如，<code>num1 = 5</code> 且 <code>num2 = 4</code> ，应该用&nbsp;<code>num1</code> 减 <code>num2</code> ，因此，得到 <code>num1 = 1</code> 和 <code>num2 = 4</code> 。然而，如果 <code>num1 = 4</code>且 <code>num2 = 5</code> ，一步操作后，得到 <code>num1 = 4</code> 和 <code>num2 = 1</code> 。</li>\n</ul>\n\n<p>返回使 <code>num1 = 0</code> 或 <code>num2 = 0</code> 的 <strong>操作数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = 2, num2 = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>\n- 操作 1 ：num1 = 2 ，num2 = 3 。由于 num1 &lt; num2 ，num2 减 num1 得到 num1 = 2 ，num2 = 3 - 2 = 1 。\n- 操作 2 ：num1 = 2 ，num2 = 1 。由于 num1 &gt; num2 ，num1 减 num2 。\n- 操作 3 ：num1 = 1 ，num2 = 1 。由于 num1 == num2 ，num1 减 num2 。\n此时 num1 = 0 ，num2 = 1 。由于 num1 == 0 ，不需要再执行任何操作。\n所以总操作数是 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = 10, num2 = 10\n<strong>输出：</strong>1\n<strong>解释：</strong>\n- 操作 1 ：num1 = 10 ，num2 = 10 。由于 num1 == num2 ，num1 减 num2 得到 num1 = 10 - 10 = 0 。\n此时 num1 = 0 ，num2 = 10 。由于 num1 == 0 ，不需要再执行任何操作。\n所以总操作数是 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num1, num2 &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2170.使数组变成交替数组的最少操作数",
        "hardRate": "MEDIUM",
        "passRate": "31.20%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-array-alternating/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-array-alternating/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，该数组由 <code>n</code> 个正整数组成。</p>\n\n<p>如果满足下述条件，则数组 <code>nums</code> 是一个 <strong>交替数组</strong> ：</p>\n\n<ul>\n\t<li><code>nums[i - 2] == nums[i]</code> ，其中 <code>2 &lt;= i &lt;= n - 1</code> 。</li>\n\t<li><code>nums[i - 1] != nums[i]</code> ，其中 <code>1 &lt;= i &lt;= n - 1</code> 。</li>\n</ul>\n\n<p>在一步 <strong>操作</strong> 中，你可以选择下标 <code>i</code> 并将 <code>nums[i]</code> <strong>更改</strong> 为 <strong>任一</strong> 正整数。</p>\n\n<p>返回使数组变成交替数组的 <strong>最少操作数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,1,3,2,4,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n使数组变成交替数组的方法之一是将该数组转换为 [3,1,3,<em><strong>1</strong></em>,<em><strong>3</strong></em>,<em><strong>1</strong></em>] 。\n在这种情况下，操作数为 3 。\n可以证明，操作数少于 3 的情况下，无法使数组变成交替数组。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2,2,2]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n使数组变成交替数组的方法之一是将该数组转换为 [1,2,<em><strong>1</strong></em>,2,<em><strong>1</strong></em>].\n在这种情况下，操作数为 2 。\n注意，数组不能转换成 [<em><strong>2</strong></em>,2,2,2,2] 。因为在这种情况下，nums[0] == nums[1]，不满足交替数组的条件。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2171.拿出最少数目的魔法豆",
        "hardRate": "MEDIUM",
        "passRate": "40.48%",
        "problemsUrl": "https://leetcode.cn/problems/removing-minimum-number-of-magic-beans/",
        "solutionsUrl": "https://leetcode.cn/problems/removing-minimum-number-of-magic-beans/solution",
        "problemsDesc": "<p>给你一个 <strong>正</strong>&nbsp;整数数组&nbsp;<code>beans</code>&nbsp;，其中每个整数表示一个袋子里装的魔法豆的数目。</p>\n\n<p>请你从每个袋子中&nbsp;<strong>拿出</strong>&nbsp;一些豆子（也可以<strong>&nbsp;不拿出</strong>），使得剩下的 <strong>非空</strong> 袋子中（即 <strong>至少</strong>&nbsp;还有 <strong>一颗</strong>&nbsp;魔法豆的袋子）魔法豆的数目&nbsp;<strong>相等</strong>&nbsp;。一旦魔法豆从袋子中取出，你不能将它放到任何其他的袋子中。</p>\n\n<p>请你返回你需要拿出魔法豆的 <strong>最少数目</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>beans = [4,<em><strong>1</strong></em>,6,5]\n<b>输出：</b>4\n<b>解释：</b>\n- 我们从有 1 个魔法豆的袋子中拿出 1 颗魔法豆。\n  剩下袋子中魔法豆的数目为：[4,<em><b>0</b></em>,6,5]\n- 然后我们从有 6 个魔法豆的袋子中拿出 2 个魔法豆。\n  剩下袋子中魔法豆的数目为：[4,0,<em><strong>4</strong></em>,5]\n- 然后我们从有 5 个魔法豆的袋子中拿出 1 个魔法豆。\n  剩下袋子中魔法豆的数目为：[4,0,4,<em><b>4</b></em>]\n总共拿出了 1 + 2 + 1 = 4 个魔法豆，剩下非空袋子中魔法豆的数目相等。\n没有比取出 4 个魔法豆更少的方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>beans = [<em><strong>2</strong></em>,10,<em><strong>3</strong></em>,<em><strong>2</strong></em>]\n<b>输出：</b>7\n<strong>解释：</strong>\n- 我们从有 2 个魔法豆的其中一个袋子中拿出 2 个魔法豆。\n  剩下袋子中魔法豆的数目为：[<em><strong>0</strong></em>,10,3,2]\n- 然后我们从另一个有 2 个魔法豆的袋子中拿出 2 个魔法豆。\n  剩下袋子中魔法豆的数目为：[0,10,3,<em><strong>0</strong></em>]\n- 然后我们从有 3 个魔法豆的袋子中拿出 3 个魔法豆。\n  剩下袋子中魔法豆的数目为：[0,10,<em><strong>0</strong></em>,0]\n总共拿出了 2 + 2 + 3 = 7 个魔法豆，剩下非空袋子中魔法豆的数目相等。\n没有比取出 7 个魔法豆更少的方案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= beans.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= beans[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2172.数组的最大与和",
        "hardRate": "HARD",
        "passRate": "50.86%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-and-sum-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-and-sum-of-array/solution",
        "problemsDesc": "<p>给你一个长度为&nbsp;<code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>numSlots</code>&nbsp;，满足<code>2 * numSlots &gt;= n</code>&nbsp;。总共有&nbsp;<code>numSlots</code>&nbsp;个篮子，编号为&nbsp;<code>1</code>&nbsp;到&nbsp;<code>numSlots</code>&nbsp;。</p>\n\n<p>你需要把所有&nbsp;<code>n</code>&nbsp;个整数分到这些篮子中，且每个篮子 <strong>至多</strong>&nbsp;有 2 个整数。一种分配方案的 <strong>与和</strong>&nbsp;定义为每个数与它所在篮子编号的 <strong>按位与运算</strong>&nbsp;结果之和。</p>\n\n<ul>\n\t<li>比方说，将数字&nbsp;<code>[1, 3]</code>&nbsp;放入篮子&nbsp;<strong><em><code>1</code></em></strong>&nbsp;中，<code>[4, 6]</code> 放入篮子&nbsp;<strong><em><code>2</code></em></strong>&nbsp;中，这个方案的与和为&nbsp;<code>(1 AND <strong><em>1</em></strong>) + (3 AND <strong><em>1</em></strong>) + (4 AND <em><strong>2</strong></em>) + (6 AND <em><strong>2</strong></em>) = 1 + 1 + 0 + 2 = 4</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回将 <code>nums</code>&nbsp;中所有数放入<em>&nbsp;</em><code>numSlots</code>&nbsp;个篮子中的最大与和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4,5,6], numSlots = 3\n<b>输出：</b>9\n<b>解释：</b>一个可行的方案是 [1, 4] 放入篮子 <em><strong>1</strong></em>&nbsp;中，[2, 6] 放入篮子 <strong><em>2</em></strong>&nbsp;中，[3, 5] 放入篮子 <strong><em>3</em></strong> 中。\n最大与和为 (1 AND <strong><em>1</em></strong>) + (4 AND <strong><em>1</em></strong>) + (2 AND <strong><em>2</em></strong>) + (6 AND <strong><em>2</em></strong>) + (3 AND <strong><em>3</em></strong>) + (5 AND <em><strong>3</strong></em>) = 1 + 0 + 2 + 2 + 3 + 1 = 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,3,10,4,7,1], numSlots = 9\n<b>输出：</b>24\n<b>解释：</b>一个可行的方案是 [1, 1] 放入篮子 <em><strong>1</strong></em> 中，[3] 放入篮子 <em><strong>3</strong></em> 中，[4] 放入篮子 <strong><em>4</em></strong> 中，[7] 放入篮子 <strong><em>7</em></strong> 中，[10] 放入篮子 <strong><em>9</em></strong>&nbsp;中。\n最大与和为 (1 AND <strong><em>1</em></strong>) + (1 AND <strong><em>1</em></strong>) + (3 AND <strong><em>3</em></strong>) + (4 AND <strong><em>4</em></strong>) + (7 AND <strong><em>7</em></strong>) + (10 AND <strong><em>9</em></strong>) = 1 + 1 + 3 + 4 + 7 + 8 = 24 。\n注意，篮子 2 ，5 ，6 和 8 是空的，这是允许的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= numSlots &lt;= 9</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * numSlots</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 15</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2173.最多连胜的次数",
        "hardRate": "HARD",
        "passRate": "56.67%",
        "problemsUrl": "https://leetcode.cn/problems/longest-winning-streak/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-winning-streak/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2174.通过翻转行或列来去除所有的 1 II",
        "hardRate": "MEDIUM",
        "passRate": "66.67%",
        "problemsUrl": "https://leetcode.cn/problems/remove-all-ones-with-row-and-column-flips-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-all-ones-with-row-and-column-flips-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2175.世界排名的变化",
        "hardRate": "MEDIUM",
        "passRate": "54.98%",
        "problemsUrl": "https://leetcode.cn/problems/the-change-in-global-rankings/",
        "solutionsUrl": "https://leetcode.cn/problems/the-change-in-global-rankings/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2176.统计数组中相等且可以被整除的数对",
        "hardRate": "EASY",
        "passRate": "78.79%",
        "problemsUrl": "https://leetcode.cn/problems/count-equal-and-divisible-pairs-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/count-equal-and-divisible-pairs-in-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;，请你返回满足&nbsp;<code>0 &lt;= i &lt; j &lt; n</code>&nbsp;，<code>nums[i] == nums[j]</code> 且&nbsp;<code>(i * j)</code>&nbsp;能被&nbsp;<code>k</code>&nbsp;整除的数对&nbsp;<code>(i, j)</code>&nbsp;的&nbsp;<strong>数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [3,1,2,2,2,1,3], k = 2\n<b>输出：</b>4\n<strong>解释：</strong>\n总共有 4 对数符合所有要求：\n- nums[0] == nums[6] 且 0 * 6 == 0 ，能被 2 整除。\n- nums[2] == nums[3] 且 2 * 3 == 6 ，能被 2 整除。\n- nums[2] == nums[4] 且 2 * 4 == 8 ，能被 2 整除。\n- nums[3] == nums[4] 且 3 * 4 == 12 ，能被 2 整除。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4], k = 1\n<b>输出：</b>0\n<b>解释：</b>由于数组中没有重复数值，所以没有数对 (i,j) 符合所有要求。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2177.找到和为给定整数的三个连续整数",
        "hardRate": "MEDIUM",
        "passRate": "69.98%",
        "problemsUrl": "https://leetcode.cn/problems/find-three-consecutive-integers-that-sum-to-a-given-number/",
        "solutionsUrl": "https://leetcode.cn/problems/find-three-consecutive-integers-that-sum-to-a-given-number/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>num</code>&nbsp;，请你返回三个连续的整数，它们的&nbsp;<strong>和</strong>&nbsp;为<em>&nbsp;</em><code>num</code>&nbsp;。如果&nbsp;<code>num</code>&nbsp;无法被表示成三个连续整数的和，请你返回一个 <strong>空</strong>&nbsp;数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>num = 33\n<b>输出：</b>[10,11,12]\n<b>解释：</b>33 可以表示为 10 + 11 + 12 = 33 。\n10, 11, 12 是 3 个连续整数，所以返回 [10, 11, 12] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>num = 4\n<b>输出：</b>[]\n<b>解释：</b>没有办法将 4 表示成 3 个连续整数的和。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 10<sup>15</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2178.拆分成最多数目的正偶数之和",
        "hardRate": "MEDIUM",
        "passRate": "64.27%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-split-of-positive-even-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-split-of-positive-even-integers/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>finalSum</code>&nbsp;。请你将它拆分成若干个&nbsp;<strong>互不相同</strong> 的正偶数之和，且拆分出来的正偶数数目&nbsp;<strong>最多</strong>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，给你&nbsp;<code>finalSum = 12</code>&nbsp;，那么这些拆分是&nbsp;<strong>符合要求</strong> 的（互不相同的正偶数且和为&nbsp;<code>finalSum</code>）：<code>(2 + 10)</code>&nbsp;，<code>(2 + 4 + 6)</code>&nbsp;和&nbsp;<code>(4 + 8)</code>&nbsp;。它们中，<code>(2 + 4 + 6)</code>&nbsp;包含最多数目的整数。注意&nbsp;<code>finalSum</code>&nbsp;不能拆分成&nbsp;<code>(2 + 2 + 4 + 4)</code>&nbsp;，因为拆分出来的整数必须互不相同。</li>\n</ul>\n\n<p>请你返回一个整数数组，表示将整数拆分成 <strong>最多</strong> 数目的正偶数数组。如果没有办法将&nbsp;<code>finalSum</code>&nbsp;进行拆分，请你返回一个&nbsp;<strong>空</strong>&nbsp;数组。你可以按 <b>任意</b>&nbsp;顺序返回这些整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>finalSum = 12\n<b>输出：</b>[2,4,6]\n<b>解释：</b>以下是一些符合要求的拆分：<code>(2 + 10)<span style=\"\">，</span></code><code>(2 + 4 + 6) </code>和 <code>(4 + 8) 。</code>\n(2 + 4 + 6) 为最多数目的整数，数目为 3 ，所以我们返回 [2,4,6] 。\n[2,6,4] ，[6,2,4] 等等也都是可行的解。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>finalSum = 7\n<b>输出：</b>[]\n<b>解释：</b>没有办法将 finalSum 进行拆分。\n所以返回空数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>finalSum = 28\n<b>输出：</b>[6,8,2,12]\n<b>解释：</b>以下是一些符合要求的拆分：<code>(2 + 26)<span style=\"\">，</span></code><code>(6 + 8 + 2 + 12)</code> 和 <code>(4 + 24) 。</code>\n<code>(6 + 8 + 2 + 12)</code> 有最多数目的整数，数目为 4 ，所以我们返回 [6,8,2,12] 。\n[10,2,4,12] ，[6,2,4,16] 等等也都是可行的解。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= finalSum &lt;= 10<sup>10</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2179.统计数组中好三元组数目",
        "hardRate": "HARD",
        "passRate": "37.31%",
        "problemsUrl": "https://leetcode.cn/problems/count-good-triplets-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/count-good-triplets-in-an-array/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始且长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>&nbsp;，两者都是&nbsp;<code>[0, 1, ..., n - 1]</code>&nbsp;的&nbsp;<strong>排列</strong>&nbsp;。</p>\n\n<p><strong>好三元组&nbsp;</strong>指的是&nbsp;<code>3</code>&nbsp;个&nbsp;<strong>互不相同</strong>&nbsp;的值，且它们在数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;中出现顺序保持一致。换句话说，如果我们将&nbsp;<code>pos1<sub>v</sub></code> 记为值&nbsp;<code>v</code>&nbsp;在&nbsp;<code>nums1</code>&nbsp;中出现的位置，<code>pos2<sub>v</sub></code>&nbsp;为值&nbsp;<code>v</code>&nbsp;在&nbsp;<code>nums2</code>&nbsp;中的位置，那么一个好三元组定义为&nbsp;<code>0 &lt;= x, y, z &lt;= n - 1</code>&nbsp;，且&nbsp;<code>pos1<sub>x</sub> &lt; pos1<sub>y</sub> &lt; pos1<sub>z</sub></code> 和&nbsp;<code>pos2<sub>x</sub> &lt; pos2<sub>y</sub> &lt; pos2<sub>z</sub></code>&nbsp;都成立的&nbsp;<code>(x, y, z)</code>&nbsp;。</p>\n\n<p>请你返回好三元组的 <strong>总数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [2,0,1,3], nums2 = [0,1,2,3]\n<b>输出：</b>1\n<b>解释：</b>\n总共有 4 个三元组 (x,y,z) 满足 pos1<sub>x</sub> &lt; pos1<sub>y</sub> &lt; pos1<sub>z&nbsp;</sub>，分别是 (2,0,1) ，(2,0,3) ，(2,1,3) 和 (0,1,3) 。\n这些三元组中，只有 (0,1,3) 满足 pos2<sub>x</sub> &lt; pos2<sub>y</sub> &lt; pos2<sub>z</sub>&nbsp;。所以只有 1 个好三元组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]\n<b>输出：</b>4\n<b>解释：</b>总共有 4 个好三元组 (4,0,3) ，(4,0,2) ，(4,1,3) 和 (4,1,2) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length == nums2.length</code></li>\n\t<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= n - 1</code></li>\n\t<li><code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>&nbsp;是&nbsp;<code>[0, 1, ..., n - 1]</code> 的排列。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2180.统计各位数字之和为偶数的整数个数",
        "hardRate": "EASY",
        "passRate": "67.96%",
        "problemsUrl": "https://leetcode.cn/problems/count-integers-with-even-digit-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/count-integers-with-even-digit-sum/solution",
        "problemsDesc": "<p>给你一个正整数 <code>num</code> ，请你统计并返回 <strong>小于或等于</strong> <code>num</code> 且各位数字之和为 <strong>偶数</strong> 的正整数的数目。</p>\n\n<p>正整数的 <strong>各位数字之和</strong> 是其所有位上的对应数字相加的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>\n只有 2 和 4 满足小于等于 4 且各位数字之和为偶数。    \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 30\n<strong>输出：</strong>14\n<strong>解释：</strong>\n只有 14 个整数满足小于等于 30 且各位数字之和为偶数，分别是： \n2、4、6、8、11、13、15、17、19、20、22、24、26 和 28 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2181.合并零之间的节点",
        "hardRate": "MEDIUM",
        "passRate": "84.71%",
        "problemsUrl": "https://leetcode.cn/problems/merge-nodes-in-between-zeros/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-nodes-in-between-zeros/solution",
        "problemsDesc": "<p>给你一个链表的头节点 <code>head</code> ，该链表包含由 <code>0</code> 分隔开的一连串整数。链表的 <strong>开端</strong> 和 <strong>末尾</strong> 的节点都满足 <code>Node.val == 0</code> 。</p>\n\n<p>对于每两个相邻的 <code>0</code> ，请你将它们之间的所有节点合并成一个节点，其值是所有已合并节点的值之和。然后将所有 <code>0</code> 移除，修改后的链表不应该含有任何 <code>0</code> 。</p>\n\n<p>&nbsp;返回修改后链表的头节点 <code>head</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：<br />\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/02/ex1-1.png\" style=\"width: 600px; height: 41px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>head = [0,3,1,0,4,5,2,0]\n<strong>输出：</strong>[4,11]\n<strong>解释：</strong>\n上图表示输入的链表。修改后的链表包含：\n- 标记为绿色的节点之和：3 + 1 = 4\n- 标记为红色的节点之和：4 + 5 + 2 = 11\n</pre>\n\n<p><strong>示例 2：<br />\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/02/ex2-1.png\" style=\"width: 600px; height: 41px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>head = [0,1,0,3,0,2,2,0]\n<strong>输出：</strong>[1,3,4]\n<strong>解释：</strong>\n上图表示输入的链表。修改后的链表包含：\n- 标记为绿色的节点之和：1 = 1\n- 标记为红色的节点之和：3 = 3\n- 标记为黄色的节点之和：2 + 2 = 4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>列表中的节点数目在范围 <code>[3, 2 * 10<sup>5</sup>]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n\t<li><strong>不</strong> 存在连续两个&nbsp;<code>Node.val == 0</code> 的节点</li>\n\t<li>链表的 <strong>开端</strong> 和 <strong>末尾</strong> 节点都满足 <code>Node.val == 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2182.构造限制重复的字符串",
        "hardRate": "MEDIUM",
        "passRate": "48.56%",
        "problemsUrl": "https://leetcode.cn/problems/construct-string-with-repeat-limit/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-string-with-repeat-limit/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和一个整数 <code>repeatLimit</code> ，用 <code>s</code> 中的字符构造一个新字符串 <code>repeatLimitedString</code> ，使任何字母 <strong>连续</strong> 出现的次数都不超过 <code>repeatLimit</code> 次。你不必使用 <code>s</code> 中的全部字符。</p>\n\n<p>返回 <strong>字典序最大的</strong><em> </em><code>repeatLimitedString</code> 。</p>\n\n<p>如果在字符串 <code>a</code> 和 <code>b</code> 不同的第一个位置，字符串 <code>a</code> 中的字母在字母表中出现时间比字符串 <code>b</code> 对应的字母晚，则认为字符串 <code>a</code> 比字符串 <code>b</code> <strong>字典序更大</strong> 。如果字符串中前 <code>min(a.length, b.length)</code> 个字符都相同，那么较长的字符串字典序更大。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"cczazcc\", repeatLimit = 3\n<strong>输出：</strong>\"zzcccac\"\n<strong>解释：</strong>使用 s 中的所有字符来构造 repeatLimitedString \"zzcccac\"。\n字母 'a' 连续出现至多 1 次。\n字母 'c' 连续出现至多 3 次。\n字母 'z' 连续出现至多 2 次。\n因此，没有字母连续出现超过 repeatLimit 次，字符串是一个有效的 repeatLimitedString 。\n该字符串是字典序最大的 repeatLimitedString ，所以返回 \"zzcccac\" 。\n注意，尽管 \"zzcccca\" 字典序更大，但字母 'c' 连续出现超过 3 次，所以它不是一个有效的 repeatLimitedString 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"aababab\", repeatLimit = 2\n<strong>输出：</strong>\"bbabaa\"\n<strong>解释：</strong>\n使用 s 中的一些字符来构造 repeatLimitedString \"bbabaa\"。 \n字母 'a' 连续出现至多 2 次。 \n字母 'b' 连续出现至多 2 次。 \n因此，没有字母连续出现超过 repeatLimit 次，字符串是一个有效的 repeatLimitedString 。 \n该字符串是字典序最大的 repeatLimitedString ，所以返回 \"bbabaa\" 。 \n注意，尽管 \"bbabaaa\" 字典序更大，但字母 'a' 连续出现超过 2 次，所以它不是一个有效的 repeatLimitedString 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= repeatLimit &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2183.统计可以被 K 整除的下标对数目",
        "hardRate": "HARD",
        "passRate": "28.22%",
        "problemsUrl": "https://leetcode.cn/problems/count-array-pairs-divisible-by-k/",
        "solutionsUrl": "https://leetcode.cn/problems/count-array-pairs-divisible-by-k/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>nums</code> 和一个整数 <code>k</code> ，返回满足下述条件的下标对 <code>(i, j)</code> 的数目：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt;= n - 1</code> 且</li>\n\t<li><code>nums[i] * nums[j]</code> 能被 <code>k</code> 整除。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,5], k = 2\n<strong>输出：</strong>7\n<strong>解释：</strong>\n共有 7 对下标的对应积可以被 2 整除：\n(0, 1)、(0, 3)、(1, 2)、(1, 3)、(1, 4)、(2, 3) 和 (3, 4)\n它们的积分别是 2、4、6、8、10、12 和 20 。\n其他下标对，例如 (0, 2) 和 (2, 4) 的乘积分别是 3 和 15 ，都无法被 2 整除。    \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4], k = 5\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在对应积可以被 5 整除的下标对。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2184.建造坚实的砖墙的方法数",
        "hardRate": "MEDIUM",
        "passRate": "55.27%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-build-sturdy-brick-wall/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-build-sturdy-brick-wall/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2185.统计包含给定前缀的字符串",
        "hardRate": "EASY",
        "passRate": "81.57%",
        "problemsUrl": "https://leetcode.cn/problems/counting-words-with-a-given-prefix/",
        "solutionsUrl": "https://leetcode.cn/problems/counting-words-with-a-given-prefix/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>words</code> 和一个字符串 <code>pref</code> 。</p>\n\n<p>返回 <code>words</code><em> </em>中以 <code>pref</code> 作为 <strong>前缀</strong> 的字符串的数目。</p>\n\n<p>字符串 <code>s</code> 的 <strong>前缀</strong> 就是&nbsp; <code>s</code> 的任一前导连续字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"pay\",\"<em><strong>at</strong></em>tention\",\"practice\",\"<em><strong>at</strong></em>tend\"], <code>pref </code>= \"at\"\n<strong>输出：</strong>2\n<strong>解释：</strong>以 \"at\" 作为前缀的字符串有两个，分别是：\"<em><strong>at</strong></em>tention\" 和 \"<em><strong>at</strong></em>tend\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"leetcode\",\"win\",\"loops\",\"success\"], <code>pref </code>= \"code\"\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在以 \"code\" 作为前缀的字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length, pref.length &lt;= 100</code></li>\n\t<li><code>words[i]</code> 和 <code>pref</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2186.使两字符串互为字母异位词的最少步骤数",
        "hardRate": "MEDIUM",
        "passRate": "72.66%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/solution",
        "problemsDesc": "<p>给你两个字符串 <code>s</code> 和 <code>t</code> 。在一步操作中，你可以给 <code>s</code> 或者 <code>t</code> 追加 <strong>任一字符</strong> 。</p>\n\n<p>返回使 <code>s</code> 和 <code>t</code> 互为 <strong>字母异位词</strong> 所需的最少步骤数<em>。</em></p>\n\n<p><strong>字母异位词 </strong>指字母相同但是顺序不同（或者相同）的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"<em><strong>lee</strong>t</em>co<em><strong>de</strong></em>\", t = \"co<em><strong>a</strong></em>t<em><strong>s</strong></em>\"\n<strong>输出：</strong>7\n<strong>解释：</strong>\n- 执行 2 步操作，将 \"as\" 追加到 s = \"leetcode\" 中，得到 s = \"leetcode<em><strong>as</strong></em>\" 。\n- 执行 5 步操作，将 \"leede\" 追加到 t = \"coats\" 中，得到 t = \"coats<em><strong>leede</strong></em>\" 。\n\"leetcodeas\" 和 \"coatsleede\" 互为字母异位词。\n总共用去 2 + 5 = 7 步。\n可以证明，无法用少于 7 步操作使这两个字符串互为字母异位词。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"night\", t = \"thing\"\n<strong>输出：</strong>0\n<strong>解释：</strong>给出的字符串已经互为字母异位词。因此，不需要任何进一步操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> 和 <code>t</code> 由小写英文字符组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2187.完成旅途的最少时间",
        "hardRate": "MEDIUM",
        "passRate": "28.44%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-complete-trips/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-complete-trips/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>time</code>&nbsp;，其中&nbsp;<code>time[i]</code>&nbsp;表示第 <code>i</code>&nbsp;辆公交车完成 <strong>一趟</strong><strong>旅途</strong>&nbsp;所需要花费的时间。</p>\n\n<p>每辆公交车可以 <strong>连续</strong> 完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以 <strong>立马开始</strong>&nbsp;下一趟旅途。每辆公交车 <strong>独立</strong>&nbsp;运行，也就是说可以同时有多辆公交车在运行且互不影响。</p>\n\n<p>给你一个整数&nbsp;<code>totalTrips</code>&nbsp;，表示所有公交车&nbsp;<strong>总共</strong>&nbsp;需要完成的旅途数目。请你返回完成 <strong>至少</strong>&nbsp;<code>totalTrips</code>&nbsp;趟旅途需要花费的 <strong>最少</strong>&nbsp;时间。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>time = [1,2,3], totalTrips = 5\n<b>输出：</b>3\n<strong>解释：</strong>\n- 时刻 t = 1 ，每辆公交车完成的旅途数分别为 [1,0,0] 。\n  已完成的总旅途数为 1 + 0 + 0 = 1 。\n- 时刻 t = 2 ，每辆公交车完成的旅途数分别为 [2,1,0] 。\n  已完成的总旅途数为 2 + 1 + 0 = 3 。\n- 时刻 t = 3 ，每辆公交车完成的旅途数分别为 [3,1,1] 。\n  已完成的总旅途数为 3 + 1 + 1 = 5 。\n所以总共完成至少 5 趟旅途的最少时间为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>time = [2], totalTrips = 1\n<b>输出：</b>2\n<strong>解释：</strong>\n只有一辆公交车，它将在时刻 t = 2 完成第一趟旅途。\n所以完成 1 趟旅途的最少时间为 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= time.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= time[i], totalTrips &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2188.完成比赛的最少时间",
        "hardRate": "HARD",
        "passRate": "44.34%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-finish-the-race/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-finish-the-race/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>tires</code>&nbsp;，其中&nbsp;<code>tires[i] = [f<sub>i</sub>, r<sub>i</sub>]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;种轮胎如果连续使用，第&nbsp;<code>x</code>&nbsp;圈需要耗时&nbsp;<code>f<sub>i</sub> * r<sub>i</sub><sup>(x-1)</sup></code>&nbsp;秒。</p>\n\n<ul>\n\t<li>比方说，如果&nbsp;<code>f<sub>i</sub> = 3</code>&nbsp;且&nbsp;<code>r<sub>i</sub> = 2</code>&nbsp;，且一直使用这种类型的同一条轮胎，那么该轮胎完成第&nbsp;<code>1</code>&nbsp;圈赛道耗时 <code>3</code>&nbsp;秒，完成第 <code>2</code>&nbsp;圈耗时&nbsp;<code>3 * 2 = 6</code>&nbsp;秒，完成第 <code>3</code>&nbsp;圈耗时&nbsp;<code>3 * 2<sup>2</sup> = 12</code>&nbsp;秒，依次类推。</li>\n</ul>\n\n<p>同时给你一个整数&nbsp;<code>changeTime</code>&nbsp;和一个整数&nbsp;<code>numLaps</code>&nbsp;。</p>\n\n<p>比赛总共包含&nbsp;<code>numLaps</code>&nbsp;圈，你可以选择 <strong>任意</strong>&nbsp;一种轮胎开始比赛。每一种轮胎都有 <strong>无数条</strong>&nbsp;。每一圈后，你可以选择耗费 <code>changeTime</code>&nbsp;秒 <strong>换成</strong>&nbsp;任意一种轮胎（也可以换成当前种类的新轮胎）。</p>\n\n<p>请你返回完成比赛需要耗费的 <strong>最少</strong>&nbsp;时间。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>tires = [[2,3],[3,4]], changeTime = 5, numLaps = 4\n<b>输出：</b>21\n<b>解释：</b>\n第 1 圈：使用轮胎 0 ，耗时 2 秒。\n第 2 圈：继续使用轮胎 0 ，耗时 2 * 3 = 6 秒。\n第 3 圈：耗费 5 秒换一条新的轮胎 0 ，然后耗时 2 秒完成这一圈。\n第 4 圈：继续使用轮胎 0 ，耗时 2 * 3 = 6 秒。\n总耗时 = 2 + 6 + 5 + 2 + 6 = 21 秒。\n完成比赛的最少时间为 21 秒。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>tires = [[1,10],[2,2],[3,4]], changeTime = 6, numLaps = 5\n<b>输出：</b>25\n<b>解释：</b>\n第 1 圈：使用轮胎 1 ，耗时 2 秒。\n第 2 圈：继续使用轮胎 1 ，耗时 2 * 2 = 4 秒。\n第 3 圈：耗时 6 秒换一条新的轮胎 1 ，然后耗时 2 秒完成这一圈。\n第 4 圈：继续使用轮胎 1 ，耗时 2 * 2 = 4 秒。\n第 5 圈：耗时 6 秒换成轮胎 0 ，然后耗时 1 秒完成这一圈。\n总耗时 = 2 + 4 + 6 + 2 + 4 + 6 + 1 = 25 秒。\n完成比赛的最少时间为 25 秒。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tires.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>tires[i].length == 2</code></li>\n\t<li><code>1 &lt;= f<sub>i</sub>, changeTime &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= r<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= numLaps &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2189.建造纸牌屋的方法数",
        "hardRate": "MEDIUM",
        "passRate": "64.87%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-build-house-of-cards/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-build-house-of-cards/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2190.数组中紧跟 key 之后出现最频繁的数字",
        "hardRate": "EASY",
        "passRate": "58.73%",
        "problemsUrl": "https://leetcode.cn/problems/most-frequent-number-following-key-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/most-frequent-number-following-key-in-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，同时给你一个整数&nbsp;<code>key</code>&nbsp;，它在&nbsp;<code>nums</code>&nbsp;出现过。</p>\n\n<p><strong>统计&nbsp;</strong>在 <code>nums</code>&nbsp;数组中紧跟着 <code>key</code>&nbsp;后面出现的不同整数&nbsp;<code>target</code>&nbsp;的出现次数。换言之，<code>target</code>&nbsp;的出现次数为满足以下条件的 <code>i</code>&nbsp;的数目：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt;= n - 2</code></li>\n\t<li><code>nums[i] == key</code>&nbsp;且</li>\n\t<li><code>nums[i + 1] == target</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回出现 <strong>最多</strong>&nbsp;次数的<em>&nbsp;</em><code>target</code>&nbsp;。测试数据保证出现次数最多的 <code>target</code>&nbsp;是唯一的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,100,200,1,100], key = 1\n<b>输出：</b>100\n<b>解释：</b>对于 target = 100 ，在下标 1 和 4 处出现过 2 次，且都紧跟着 key 。\n没有其他整数在 key 后面紧跟着出现，所以我们返回 100 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,2,2,2,3], key = 2\n<b>输出：</b>2\n<b>解释：</b>对于 target = 2 ，在下标 1 ，2 和 3 处出现过 3 次，且都紧跟着 key 。\n对于 target = 3 ，在下标 4 出出现过 1 次，且紧跟着 key 。\ntarget = 2 是紧跟着 key 之后出现次数最多的数字，所以我们返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>测试数据保证答案是唯一的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2191.将杂乱无章的数字排序",
        "hardRate": "MEDIUM",
        "passRate": "43.58%",
        "problemsUrl": "https://leetcode.cn/problems/sort-the-jumbled-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-the-jumbled-numbers/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>mapping</code>&nbsp;，它表示一个十进制数的映射规则，<code>mapping[i] = j</code>&nbsp;表示这个规则下将数位&nbsp;<code>i</code>&nbsp;映射为数位 <code>j</code>&nbsp;。</p>\n\n<p>一个整数 <strong>映射后的值</strong>&nbsp;为将原数字每一个数位 <code>i</code>&nbsp;（<code>0 &lt;= i &lt;= 9</code>）映射为&nbsp;<code>mapping[i]</code>&nbsp;。</p>\n\n<p>另外给你一个整数数组&nbsp;<code>nums</code>&nbsp;，请你将数组<em>&nbsp;</em><code>nums</code>&nbsp;中每个数按照它们映射后对应数字非递减顺序排序后返回。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>如果两个数字映射后对应的数字大小相同，则将它们按照输入中的 <strong>相对顺序</strong>&nbsp;排序。</li>\n\t<li><code>nums</code>&nbsp;中的元素只有在排序的时候需要按照映射后的值进行比较，返回的值应该是输入的元素本身。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>mapping = [8,9,4,0,2,1,3,5,7,6], nums = [991,338,38]\n<b>输出：</b>[338,38,991]\n<b>解释：</b>\n将数字 991 按照如下规则映射：\n1. mapping[9] = 6 ，所有数位 9 都会变成 6 。\n2. mapping[1] = 9 ，所有数位 1 都会变成 8 。\n所以，991 映射的值为 669 。\n338 映射为 007 ，去掉前导 0 后得到 7 。\n38 映射为 07 ，去掉前导 0 后得到 7 。\n由于 338 和 38 映射后的值相同，所以它们的前后顺序保留原数组中的相对位置关系，338 在 38 的前面。\n所以，排序后的数组为 [338,38,991] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>mapping = [0,1,2,3,4,5,6,7,8,9], nums = [789,456,123]\n<b>输出：</b>[123,456,789]\n<b>解释：</b>789 映射为 789 ，456 映射为 456 ，123 映射为 123 。所以排序后数组为 [123,456,789] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>mapping.length == 10</code></li>\n\t<li><code>0 &lt;= mapping[i] &lt;= 9</code></li>\n\t<li><code>mapping[i]</code>&nbsp;的值 <strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt; 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2192.有向无环图中一个节点的所有祖先",
        "hardRate": "MEDIUM",
        "passRate": "45.10%",
        "problemsUrl": "https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/solution",
        "problemsDesc": "<p>给你一个正整数&nbsp;<code>n</code>&nbsp;，它表示一个 <strong>有向无环图</strong>&nbsp;中节点的数目，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;（包括两者）。</p>\n\n<p>给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>]</code>&nbsp;表示图中一条从&nbsp;<code>from<sub>i</sub></code>&nbsp;到&nbsp;<code>to<sub>i</sub></code>&nbsp;的单向边。</p>\n\n<p>请你返回一个数组&nbsp;<code>answer</code>，其中<em>&nbsp;</em><code>answer[i]</code>是第&nbsp;<code>i</code>&nbsp;个节点的所有&nbsp;<strong>祖先</strong>&nbsp;，这些祖先节点&nbsp;<strong>升序</strong>&nbsp;排序。</p>\n\n<p>如果 <code>u</code>&nbsp;通过一系列边，能够到达 <code>v</code>&nbsp;，那么我们称节点 <code>u</code>&nbsp;是节点 <code>v</code>&nbsp;的 <strong>祖先</strong>&nbsp;节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/12/e1.png\" style=\"width: 322px; height: 265px;\"></p>\n\n<pre><b>输入：</b>n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]\n<b>输出：</b>[[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]\n<strong>解释：</strong>\n上图为输入所对应的图。\n- 节点 0 ，1 和 2 没有任何祖先。\n- 节点 3 有 2 个祖先 0 和 1 。\n- 节点 4 有 2 个祖先 0 和 2 。\n- 节点 5 有 3 个祖先 0 ，1 和 3 。\n- 节点 6 有 5 个祖先 0 ，1 ，2 ，3 和 4 。\n- 节点 7 有 4 个祖先 0 ，1 ，2 和 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/12/e2.png\" style=\"width: 343px; height: 299px;\"></p>\n\n<pre><b>输入：</b>n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n<b>输出：</b>[[],[0],[0,1],[0,1,2],[0,1,2,3]]\n<strong>解释：</strong>\n上图为输入所对应的图。\n- 节点 0 没有任何祖先。\n- 节点 1 有 1 个祖先 0 。\n- 节点 2 有 2 个祖先 0 和 1 。\n- 节点 3 有 3 个祖先 0 ，1 和 2 。\n- 节点 4 有 4 个祖先 0 ，1 ，2 和 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= edges.length &lt;= min(2000, n * (n - 1) / 2)</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>\n\t<li>图中不会有重边。</li>\n\t<li>图是 <strong>有向</strong> 且 <strong>无环</strong> 的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2193.得到回文串的最少操作次数",
        "hardRate": "HARD",
        "passRate": "49.19%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-moves-to-make-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-moves-to-make-palindrome/solution",
        "problemsDesc": "<p>给你一个只包含小写英文字母的字符串&nbsp;<code>s</code>&nbsp;。</p>\n\n<p>每一次 <strong>操作</strong>&nbsp;，你可以选择 <code>s</code>&nbsp;中两个 <strong>相邻</strong>&nbsp;的字符，并将它们交换。</p>\n\n<p>请你返回将 <code>s</code>&nbsp;变成回文串的 <strong>最少操作次数</strong>&nbsp;。</p>\n\n<p><strong>注意</strong>&nbsp;，输入数据会确保&nbsp;<code>s</code>&nbsp;一定能变成一个回文串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"aabb\"\n<b>输出：</b>2\n<strong>解释：</strong>\n我们可以将 s 变成 2 个回文串，\"abba\" 和 \"baab\" 。\n- 我们可以通过 2 次操作得到 \"abba\" ：\"a<em><strong>ab</strong></em>b\" -&gt; \"ab<em><strong>ab</strong></em>\" -&gt; \"abba\" 。\n- 我们可以通过 2 次操作得到 \"baab\" ：\"a<em><strong>ab</strong></em>b\" -&gt; \"<em><strong>ab</strong></em>ab\" -&gt; \"baab\" 。\n因此，得到回文串的最少总操作次数为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"letelt\"\n<b>输出：</b>2\n<strong>解释：</strong>\n通过 2 次操作从 s 能得到回文串 \"lettel\" 。\n其中一种方法是：\"lete<em><strong>lt</strong></em>\" -&gt; \"let<em><strong>et</strong></em>l\" -&gt; \"lettel\" 。\n其他回文串比方说 \"tleelt\" 也可以通过 2 次操作得到。\n可以证明少于 2 次操作，无法得到回文串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n\t<li><code>s</code>&nbsp;可以通过有限次操作得到一个回文串。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2194.Excel 表中某个范围内的单元格",
        "hardRate": "EASY",
        "passRate": "84.10%",
        "problemsUrl": "https://leetcode.cn/problems/cells-in-a-range-on-an-excel-sheet/",
        "solutionsUrl": "https://leetcode.cn/problems/cells-in-a-range-on-an-excel-sheet/solution",
        "problemsDesc": "<p>Excel 表中的一个单元格 <code>(r, c)</code> 会以字符串 <code>\"&lt;col&gt;&lt;row&gt;\"</code> 的形式进行表示，其中：</p>\n\n<ul>\n\t<li><code>&lt;col&gt;</code> 即单元格的列号 <code>c</code> 。用英文字母表中的 <strong>字母</strong> 标识。\n\n\t<ul>\n\t\t<li>例如，第 <code>1</code> 列用 <code>'A'</code> 表示，第 <code>2</code> 列用 <code>'B'</code> 表示，第 <code>3</code> 列用 <code>'C'</code> 表示，以此类推。</li>\n\t</ul>\n\t</li>\n\t<li><code>&lt;row&gt;</code> 即单元格的行号 <code>r</code> 。第 <code>r</code> 行就用 <strong>整数</strong> <code>r</code> 标识。</li>\n</ul>\n\n<p>给你一个格式为 <code>\"&lt;col1&gt;&lt;row1&gt;:&lt;col2&gt;&lt;row2&gt;\"</code> 的字符串 <code>s</code> ，其中 <code>&lt;col1&gt;</code> 表示 <code>c1</code> 列，<code>&lt;row1&gt;</code> 表示 <code>r1</code> 行，<code>&lt;col2&gt;</code> 表示 <code>c2</code> 列，<code>&lt;row2&gt;</code> 表示 <code>r2</code> 行，并满足 <code>r1 &lt;= r2</code> 且 <code>c1 &lt;= c2</code> 。</p>\n\n<p>找出所有满足&nbsp;<code>r1 &lt;= x &lt;= r2</code> 且 <code>c1 &lt;= y &lt;= c2</code> 的单元格，并以列表形式返回。单元格应该按前面描述的格式用 <strong>字符串</strong> 表示，并以 <strong>非递减</strong> 顺序排列（先按列排，再按行排）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/08/ex1drawio.png\" style=\"width: 250px; height: 160px;\" /></p>\n\n<pre>\n<strong>输入：</strong>s = \"K1:L2\"\n<strong>输出：</strong>[\"K1\",\"K2\",\"L1\",\"L2\"]\n<strong>解释：</strong>\n上图显示了列表中应该出现的单元格。\n红色箭头指示单元格的出现顺序。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/09/exam2drawio.png\" style=\"width: 500px; height: 50px;\" /></p>\n\n<pre>\n<strong>输入：</strong>s = \"A1:F1\"\n<strong>输出：</strong>[\"A1\",\"B1\",\"C1\",\"D1\",\"E1\",\"F1\"]\n<strong>解释：</strong>\n上图显示了列表中应该出现的单元格。 \n红色箭头指示单元格的出现顺序。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s.length == 5</code></li>\n\t<li><code>'A' &lt;= s[0] &lt;= s[3] &lt;= 'Z'</code></li>\n\t<li><code>'1' &lt;= s[1] &lt;= s[4] &lt;= '9'</code></li>\n\t<li><code>s</code> 由大写英文字母、数字、和 <code>':'</code> 组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2195.向数组中追加 K 个整数",
        "hardRate": "MEDIUM",
        "passRate": "24.04%",
        "problemsUrl": "https://leetcode.cn/problems/append-k-integers-with-minimal-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/append-k-integers-with-minimal-sum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。请你向 <code>nums</code> 中追加 <code>k</code> 个 <strong>未</strong> 出现在 <code>nums</code> 中的、<strong>互不相同</strong> 的 <strong>正</strong> 整数，并使结果数组的元素和 <strong>最小</strong> 。</p>\n\n<p>返回追加到 <code>nums</code> 中的 <code>k</code> 个整数之和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,4,25,10,25], k = 2\n<strong>输出：</strong>5\n<strong>解释：</strong>在该解法中，向数组中追加的两个互不相同且未出现的正整数是 2 和 3 。\nnums 最终元素和为 1 + 4 + 25 + 10 + 25 + 2 + 3 = 70 ，这是所有情况中的最小值。\n所以追加到数组中的两个整数之和是 2 + 3 = 5 ，所以返回 5 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,6], k = 6\n<strong>输出：</strong>25\n<strong>解释：</strong>在该解法中，向数组中追加的两个互不相同且未出现的正整数是 1 、2 、3 、4 、7 和 8 。\nnums 最终元素和为 5 + 6 + 1 + 2 + 3 + 4 + 7 + 8 = 36 ，这是所有情况中的最小值。\n所以追加到数组中的两个整数之和是 1 + 2 + 3 + 4 + 7 + 8 = 25 ，所以返回 25 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2196.根据描述创建二叉树",
        "hardRate": "MEDIUM",
        "passRate": "72.84%",
        "problemsUrl": "https://leetcode.cn/problems/create-binary-tree-from-descriptions/",
        "solutionsUrl": "https://leetcode.cn/problems/create-binary-tree-from-descriptions/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>descriptions</code> ，其中 <code>descriptions[i] = [parent<sub>i</sub>, child<sub>i</sub>, isLeft<sub>i</sub>]</code> 表示 <code>parent<sub>i</sub></code> 是 <code>child<sub>i</sub></code> 在 <strong>二叉树</strong> 中的 <strong>父节点</strong>，二叉树中各节点的值 <strong>互不相同</strong> 。此外：</p>\n\n<ul>\n\t<li>如果 <code>isLeft<sub>i</sub> == 1</code> ，那么 <code>child<sub>i</sub></code> 就是 <code>parent<sub>i</sub></code> 的左子节点。</li>\n\t<li>如果 <code>isLeft<sub>i</sub> == 0</code> ，那么 <code>child<sub>i</sub></code> 就是 <code>parent<sub>i</sub></code> 的右子节点。</li>\n</ul>\n\n<p>请你根据 <code>descriptions</code> 的描述来构造二叉树并返回其 <strong>根节点</strong> 。</p>\n\n<p>测试用例会保证可以构造出 <strong>有效</strong> 的二叉树。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/09/example1drawio.png\" style=\"width: 300px; height: 236px;\" /></p>\n\n<pre>\n<strong>输入：</strong>descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]\n<strong>输出：</strong>[50,20,80,15,17,19]\n<strong>解释：</strong>根节点是值为 50 的节点，因为它没有父节点。\n结果二叉树如上图所示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/09/example2drawio.png\" style=\"width: 131px; height: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>descriptions = [[1,2,1],[2,3,0],[3,4,1]]\n<strong>输出：</strong>[1,2,null,null,3,4]\n<strong>解释：</strong>根节点是值为 1 的节点，因为它没有父节点。 \n结果二叉树如上图所示。 </pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= descriptions.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>descriptions[i].length == 3</code></li>\n\t<li><code>1 &lt;= parent<sub>i</sub>, child<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= isLeft<sub>i</sub> &lt;= 1</code></li>\n\t<li><code>descriptions</code> 所描述的二叉树是一棵有效二叉树</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2197.替换数组中的非互质数",
        "hardRate": "HARD",
        "passRate": "34.67%",
        "problemsUrl": "https://leetcode.cn/problems/replace-non-coprime-numbers-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/replace-non-coprime-numbers-in-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。请你对数组执行下述操作：</p>\n\n<ol>\n\t<li>从 <code>nums</code> 中找出 <strong>任意</strong> 两个 <strong>相邻</strong> 的 <strong>非互质</strong> 数。</li>\n\t<li>如果不存在这样的数，<strong>终止</strong> 这一过程。</li>\n\t<li>否则，删除这两个数，并 <strong>替换</strong> 为它们的 <strong>最小公倍数</strong>（Least Common Multiple，LCM）。</li>\n\t<li>只要还能找出两个相邻的非互质数就继续 <strong>重复</strong> 这一过程。</li>\n</ol>\n\n<p>返回修改后得到的 <strong>最终</strong> 数组。可以证明的是，以 <strong>任意</strong> 顺序替换相邻的非互质数都可以得到相同的结果。</p>\n\n<p>生成的测试用例可以保证最终数组中的值 <strong>小于或者等于</strong> <code>10<sup>8</sup></code> 。</p>\n\n<p>两个数字 <code>x</code> 和 <code>y</code> 满足 <strong>非互质数</strong> 的条件是：<code>GCD(x, y) &gt; 1</code> ，其中 <code>GCD(x, y)</code> 是 <code>x</code> 和 <code>y</code> 的 <strong>最大公约数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [6,4,3,2,7,6,2]\n<strong>输出：</strong>[12,7,6]\n<strong>解释：</strong>\n- (6, 4) 是一组非互质数，且 LCM(6, 4) = 12 。得到 nums = [<em><strong>12</strong></em>,3,2,7,6,2] 。\n- (12, 3) 是一组非互质数，且 LCM(12, 3) = 12 。得到 nums = [<em><strong>12</strong></em>,2,7,6,2] 。\n- (12, 2) 是一组非互质数，且 LCM(12, 2) = 12 。得到 nums = [<em><strong>12</strong></em>,7,6,2] 。\n- (6, 2) 是一组非互质数，且 LCM(6, 2) = 6 。得到 nums = [12,7,<em><strong>6</strong></em>] 。\n现在，nums 中不存在相邻的非互质数。\n因此，修改后得到的最终数组是 [12,7,6] 。\n注意，存在其他方法可以获得相同的最终数组。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,1,1,3,3,3]\n<strong>输出：</strong>[2,1,1,3]\n<strong>解释：</strong>\n- (3, 3) 是一组非互质数，且 LCM(3, 3) = 3 。得到 nums = [2,2,1,1,<em><strong>3</strong></em>,3] 。\n- (3, 3) 是一组非互质数，且 LCM(3, 3) = 3 。得到 nums = [2,2,1,1,<em><strong>3</strong></em>] 。\n- (2, 2) 是一组非互质数，且 LCM(2, 2) = 2 。得到 nums = [<em><strong>2</strong></em>,1,1,3] 。\n现在，nums 中不存在相邻的非互质数。 \n因此，修改后得到的最终数组是 [2,1,1,3] 。 \n注意，存在其他方法可以获得相同的最终数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li>生成的测试用例可以保证最终数组中的值 <strong>小于或者等于</strong> <code>10<sup>8</sup></code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2198.单因数三元组",
        "hardRate": "MEDIUM",
        "passRate": "57.29%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-single-divisor-triplets/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-single-divisor-triplets/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2199.找到每篇文章的主题",
        "hardRate": "HARD",
        "passRate": "59.66%",
        "problemsUrl": "https://leetcode.cn/problems/finding-the-topic-of-each-post/",
        "solutionsUrl": "https://leetcode.cn/problems/finding-the-topic-of-each-post/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2200.找出数组中的所有 K 近邻下标",
        "hardRate": "EASY",
        "passRate": "53.74%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-k-distant-indices-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-k-distant-indices-in-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和两个整数 <code>key</code> 和 <code>k</code> 。<strong>K 近邻下标</strong> 是 <code>nums</code> 中的一个下标 <code>i</code> ，并满足至少存在一个下标 <code>j</code> 使得 <code>|i - j| &lt;= k</code> 且 <code>nums[j] == key</code> 。</p>\n\n<p>以列表形式返回按 <strong>递增顺序</strong> 排序的所有 K 近邻下标。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,9,1,3,9,5], key = 9, k = 1\n<strong>输出：</strong>[1,2,3,4,5,6]\n<strong>解释：</strong>因此，<code>nums[2] == key</code> 且 <code>nums[5] == key 。\n- 对下标 0 ，|0 - 2| &gt; k 且 |0 - 5| &gt; k ，所以不存在 j</code> 使得 <code>|0 - j| &lt;= k</code> 且 <code>nums[j] == key 。所以 0 不是一个 K 近邻下标。\n- 对下标 1 ，|1 - 2| &lt;= k 且 nums[2] == key ，所以 1 是一个 K 近邻下标。\n- 对下标 2 ，|2 - 2| &lt;= k 且 nums[2] == key ，所以 2 是一个 K 近邻下标。\n- 对下标 3 ，|3 - 2| &lt;= k 且 nums[2] == key ，所以 3 是一个 K 近邻下标。\n- 对下标 4 ，|4 - 5| &lt;= k 且 nums[5] == key ，所以 4 是一个 K 近邻下标。\n- 对下标 5 ，|5 - 5| &lt;= k 且 nums[5] == key ，所以 5 是一个 K 近邻下标。\n- 对下标 6 ，|6 - 5| &lt;= k 且 nums[5] == key ，所以 6 是一个 K 近邻下标。\n</code>因此，按递增顺序返回 [1,2,3,4,5,6] 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,2,2,2], key = 2, k = 2\n<strong>输出：</strong>[0,1,2,3,4]\n<strong>解释：</strong>对 nums 的所有下标 i ，总存在某个下标 j 使得 |i - j| &lt;= k 且 nums[j] == key ，所以每个下标都是一个 <code>K 近邻下标。</code> \n因此，返回 [0,1,2,3,4] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>key</code> 是数组 <code>nums</code> 中的一个整数</li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2201.统计可以提取的工件",
        "hardRate": "MEDIUM",
        "passRate": "49.42%",
        "problemsUrl": "https://leetcode.cn/problems/count-artifacts-that-can-be-extracted/",
        "solutionsUrl": "https://leetcode.cn/problems/count-artifacts-that-can-be-extracted/solution",
        "problemsDesc": "<p>存在一个 <code>n x n</code> 大小、下标从 <strong>0</strong> 开始的网格，网格中埋着一些工件。给你一个整数 <code>n</code> 和一个下标从 <strong>0</strong> 开始的二维整数数组 <code>artifacts</code> ，<code>artifacts</code> 描述了矩形工件的位置，其中 <code>artifacts[i] = [r1<sub>i</sub>, c1<sub>i</sub>, r2<sub>i</sub>, c2<sub>i</sub>]</code> 表示第 <code>i</code> 个工件在子网格中的填埋情况：</p>\n\n<ul>\n\t<li><code>(r1<sub>i</sub>, c1<sub>i</sub>)</code> 是第 <code>i</code> 个工件 <strong>左上</strong> 单元格的坐标，且</li>\n\t<li><code>(r2<sub>i</sub>, c2<sub>i</sub>)</code> 是第 <code>i</code> 个工件 <strong>右下</strong> 单元格的坐标。</li>\n</ul>\n\n<p>你将会挖掘网格中的一些单元格，并清除其中的填埋物。如果单元格中埋着工件的一部分，那么该工件这一部分将会裸露出来。如果一个工件的所有部分都都裸露出来，你就可以提取该工件。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>dig</code> ，其中 <code>dig[i] = [r<sub>i</sub>, c<sub>i</sub>]</code> 表示你将会挖掘单元格 <code>(r<sub>i</sub>, c<sub>i</sub>)</code> ，返回你可以提取的工件数目。</p>\n\n<p>生成的测试用例满足：</p>\n\n<ul>\n\t<li>不存在重叠的两个工件。</li>\n\t<li>每个工件最多只覆盖 <code>4</code> 个单元格。</li>\n\t<li><code>dig</code> 中的元素互不相同。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/16/untitled-diagram.jpg\" style=\"width: 216px; height: 216px;\">\n<pre><strong>输入：</strong>n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1]]\n<strong>输出：</strong>1\n<strong>解释：</strong> \n不同颜色表示不同的工件。挖掘的单元格用 'D' 在网格中进行标记。\n有 1 个工件可以提取，即红色工件。\n蓝色工件在单元格 (1,1) 的部分尚未裸露出来，所以无法提取该工件。\n因此，返回 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/16/untitled-diagram-1.jpg\" style=\"width: 216px; height: 216px;\">\n<pre><strong>输入：</strong>n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1],[1,1]]\n<strong>输出：</strong>2\n<strong>解释：</strong>红色工件和蓝色工件的所有部分都裸露出来（用 'D' 标记），都可以提取。因此，返回 2 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= artifacts.length, dig.length &lt;= min(n<sup>2</sup>, 10<sup>5</sup>)</code></li>\n\t<li><code>artifacts[i].length == 4</code></li>\n\t<li><code>dig[i].length == 2</code></li>\n\t<li><code>0 &lt;= r1<sub>i</sub>, c1<sub>i</sub>, r2<sub>i</sub>, c2<sub>i</sub>, r<sub>i</sub>, c<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>r1<sub>i</sub> &lt;= r2<sub>i</sub></code></li>\n\t<li><code>c1<sub>i</sub> &lt;= c2<sub>i</sub></code></li>\n\t<li>不存在重叠的两个工件</li>\n\t<li>每个工件 <strong>最多</strong> 只覆盖 <code>4</code> 个单元格</li>\n\t<li><code>dig</code> 中的元素互不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2202.K 次操作后最大化顶端元素",
        "hardRate": "MEDIUM",
        "passRate": "21.69%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-the-topmost-element-after-k-moves/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-the-topmost-element-after-k-moves/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，它表示一个 <strong>栈</strong> ，其中 <code>nums[0]</code>&nbsp;是栈顶的元素。</p>\n\n<p>每一次操作中，你可以执行以下操作 <strong>之一</strong>&nbsp;：</p>\n\n<ul>\n\t<li>如果栈非空，那么 <strong>删除</strong>&nbsp;栈顶端的元素。</li>\n\t<li>如果存在 1 个或者多个被删除的元素，你可以从它们中选择任何一个，<b>添加</b>&nbsp;回栈顶，这个元素成为新的栈顶元素。</li>\n</ul>\n\n<p>同时给你一个整数&nbsp;<code>k</code>&nbsp;，它表示你总共需要执行操作的次数。</p>\n\n<p>请你返回 <strong>恰好</strong>&nbsp;执行 <code>k</code>&nbsp;次操作以后，栈顶元素的 <strong>最大值</strong>&nbsp;。如果执行完 <code>k</code>&nbsp;次操作以后，栈一定为空，请你返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5,2,2,4,0,6], k = 4\n<b>输出：</b>5\n<strong>解释：</strong>\n4 次操作后，栈顶元素为 5 的方法之一为：\n- 第 1 次操作：删除栈顶元素 5 ，栈变为 [2,2,4,0,6] 。\n- 第 2 次操作：删除栈顶元素 2 ，栈变为 [2,4,0,6] 。\n- 第 3 次操作：删除栈顶元素 2 ，栈变为 [4,0,6] 。\n- 第 4 次操作：将 5 添加回栈顶，栈变为 [5,4,0,6] 。\n注意，这不是最后栈顶元素为 5 的唯一方式。但可以证明，4 次操作以后 5 是能得到的最大栈顶元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2], k = 1\n<b>输出：</b>-1\n<b>解释：</b>\n第 1 次操作中，我们唯一的选择是将栈顶元素弹出栈。\n由于 1 次操作后无法得到一个非空的栈，所以我们返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i], k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2203.得到要求路径的最小带权子图",
        "hardRate": "HARD",
        "passRate": "37.74%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-weighted-subgraph-with-the-required-paths/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-weighted-subgraph-with-the-required-paths/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;，它表示一个 <strong>带权有向</strong> 图的节点数，节点编号为&nbsp;<code>0</code> 到&nbsp;<code>n - 1</code>&nbsp;。</p>\n\n<p>同时给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>, weight<sub>i</sub>]</code>&nbsp;，表示从&nbsp;<code>from<sub>i</sub></code>&nbsp;到&nbsp;<code>to<sub>i</sub></code>&nbsp;有一条边权为&nbsp;<code>weight<sub>i</sub></code>&nbsp;的 <strong>有向</strong> 边。</p>\n\n<p>最后，给你三个 <strong>互不相同</strong>&nbsp;的整数&nbsp;<code>src1</code>&nbsp;，<code>src2</code>&nbsp;和&nbsp;<code>dest</code>&nbsp;，表示图中三个不同的点。</p>\n\n<p>请你从图中选出一个 <b>边权和最小</b>&nbsp;的子图，使得从 <code>src1</code>&nbsp;和 <code>src2</code>&nbsp;出发，在这个子图中，都 <strong>可以</strong>&nbsp;到达 <code>dest</code>&nbsp;。如果这样的子图不存在，请返回 <code>-1</code>&nbsp;。</p>\n\n<p><strong>子图</strong>&nbsp;中的点和边都应该属于原图的一部分。子图的边权和定义为它所包含的所有边的权值之和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/17/example1drawio.png\" style=\"width: 263px; height: 250px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5\n<b>输出：</b>9\n<strong>解释：</strong>\n上图为输入的图。\n蓝色边为最优子图之一。\n注意，子图 [[1,0,3],[0,5,6]] 也能得到最优解，但无法在满足所有限制的前提下，得到更优解。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/17/example2-1drawio.png\" style=\"width: 350px; height: 51px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2\n<b>输出：</b>-1\n<strong>解释：</strong>\n上图为输入的图。\n可以看到，不存在从节点 1 到节点 2 的路径，所以不存在任何子图满足所有限制。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub>, src1, src2, dest &lt;= n - 1</code></li>\n\t<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>\n\t<li><code>src1</code>&nbsp;，<code>src2</code>&nbsp;和&nbsp;<code>dest</code>&nbsp;两两不同。</li>\n\t<li><code>1 &lt;= weight[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2204.无向图中到环的距离",
        "hardRate": "HARD",
        "passRate": "75.62%",
        "problemsUrl": "https://leetcode.cn/problems/distance-to-a-cycle-in-undirected-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/distance-to-a-cycle-in-undirected-graph/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2205.有资格享受折扣的用户数量",
        "hardRate": "EASY",
        "passRate": "44.81%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-users-that-are-eligible-for-discount/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-users-that-are-eligible-for-discount/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2206.将数组划分成相等数对",
        "hardRate": "EASY",
        "passRate": "73.79%",
        "problemsUrl": "https://leetcode.cn/problems/divide-array-into-equal-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-array-into-equal-pairs/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;，它包含&nbsp;<code>2 * n</code>&nbsp;个整数。</p>\n\n<p>你需要将&nbsp;<code>nums</code> 划分成&nbsp;<code>n</code>&nbsp;个数对，满足：</p>\n\n<ul>\n\t<li>每个元素 <strong>只属于一个 </strong>数对。</li>\n\t<li>同一数对中的元素 <strong>相等</strong>&nbsp;。</li>\n</ul>\n\n<p>如果可以将 <code>nums</code>&nbsp;划分成 <code>n</code>&nbsp;个数对，请你返回 <code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,2,3,2,2,2]\n<b>输出：</b>true\n<b>解释：</b>\nnums<code>&nbsp;中总共有 6 个元素，所以它们应该被划分成</code> 6 / 2 = 3 个数对。\nnums 可以划分成 (2, 2) ，(3, 3) 和 (2, 2) ，满足所有要求。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4]\n<b>输出：</b>false\n<b>解释：</b>\n无法将 nums 划分成 4 / 2 = 2 个数对且满足所有要求。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length == 2 * n</code></li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 500</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2207.字符串中最多数目的子字符串",
        "hardRate": "MEDIUM",
        "passRate": "31.55%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-number-of-subsequences-in-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-number-of-subsequences-in-a-string/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>text</code>&nbsp;和另一个下标从 <strong>0</strong>&nbsp;开始且长度为 <code>2</code>&nbsp;的字符串&nbsp;<code>pattern</code>&nbsp;，两者都只包含小写英文字母。</p>\n\n<p>你可以在 <code>text</code>&nbsp;中任意位置插入 <strong>一个</strong> 字符，这个插入的字符必须是&nbsp;<code>pattern[0]</code>&nbsp;<b>或者</b>&nbsp;<code>pattern[1]</code>&nbsp;。注意，这个字符可以插入在 <code>text</code>&nbsp;开头或者结尾的位置。</p>\n\n<p>请你返回插入一个字符后，<code>text</code>&nbsp;中最多包含多少个等于 <code>pattern</code>&nbsp;的 <strong>子序列</strong>&nbsp;。</p>\n\n<p><strong>子序列</strong> 指的是将一个字符串删除若干个字符后（也可以不删除），剩余字符保持原本顺序得到的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>text = \"abdcdbc\", pattern = \"ac\"\n<b>输出：</b>4\n<strong>解释：</strong>\n如果我们在 text[1] 和 text[2] 之间添加 pattern[0] = 'a' ，那么我们得到 \"ab<em><strong>a</strong></em>dcdbc\" 。那么 \"ac\" 作为子序列出现 4 次。\n其他得到 4 个 \"ac\" 子序列的方案还有 \"<em><strong>a</strong></em>abdcdbc\" 和 \"abd<em><strong>a</strong></em>cdbc\" 。\n但是，\"abdc<em><strong>a</strong></em>dbc\" ，\"abd<em><strong>c</strong></em>cdbc\" 和 \"abdcdbc<em><strong>c</strong></em>\" 这些字符串虽然是可行的插入方案，但是只出现了 3 次 \"ac\" 子序列，所以不是最优解。\n可以证明插入一个字符后，无法得到超过 4 个 \"ac\" 子序列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>text = \"aabb\", pattern = \"ab\"\n<b>输出：</b>6\n<strong>解释：</strong>\n可以得到 6 个 \"ab\" 子序列的部分方案为 \"<em><strong>a</strong></em>aabb\" ，\"aa<em><strong>a</strong></em>bb\" 和 \"aab<em><strong>b</strong></em>b\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pattern.length == 2</code></li>\n\t<li><code>text</code> 和&nbsp;<code>pattern</code>&nbsp;都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2208.将数组和减半的最少操作次数",
        "hardRate": "MEDIUM",
        "passRate": "40.94%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-halve-array-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-halve-array-sum/solution",
        "problemsDesc": "<p>给你一个正整数数组&nbsp;<code>nums</code>&nbsp;。每一次操作中，你可以从&nbsp;<code>nums</code>&nbsp;中选择 <strong>任意</strong>&nbsp;一个数并将它减小到 <strong>恰好</strong>&nbsp;一半。（注意，在后续操作中你可以对减半过的数继续执行操作）</p>\n\n<p>请你返回将 <code>nums</code>&nbsp;数组和 <strong>至少</strong>&nbsp;减少一半的 <strong>最少</strong>&nbsp;操作数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [5,19,8,1]\n<b>输出：</b>3\n<b>解释：</b>初始 nums 的和为 5 + 19 + 8 + 1 = 33 。\n以下是将数组和减少至少一半的一种方法：\n选择数字 19 并减小为 9.5 。\n选择数字 9.5 并减小为 4.75 。\n选择数字 8 并减小为 4 。\n最终数组为 [5, 4.75, 4, 1] ，和为 5 + 4.75 + 4 + 1 = 14.75 。\nnums 的和减小了 33 - 14.75 = 18.25 ，减小的部分超过了初始数组和的一半，18.25 &gt;= 33/2 = 16.5 。\n我们需要 3 个操作实现题目要求，所以返回 3 。\n可以证明，无法通过少于 3 个操作使数组和减少至少一半。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [3,8,20]\n<b>输出：</b>3\n<strong>解释：</strong>初始 nums 的和为 3 + 8 + 20 = 31 。\n以下是将数组和减少至少一半的一种方法：\n选择数字 20 并减小为 10 。\n选择数字 10 并减小为 5 。\n选择数字 3 并减小为 1.5 。\n最终数组为 [1.5, 8, 5] ，和为 1.5 + 8 + 5 = 14.5 。\nnums 的和减小了 31 - 14.5 = 16.5 ，减小的部分超过了初始数组和的一半， 16.5 &gt;= 31/2 = 16.5 。\n我们需要 3 个操作实现题目要求，所以返回 3 。\n可以证明，无法通过少于 3 个操作使数组和减少至少一半。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2209.用地毯覆盖后的最少白色砖块",
        "hardRate": "HARD",
        "passRate": "39.14%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-white-tiles-after-covering-with-carpets/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-white-tiles-after-covering-with-carpets/solution",
        "problemsDesc": "<p>给你一个下标从<strong>&nbsp;0</strong>&nbsp;开始的 <strong>二进制</strong>&nbsp;字符串&nbsp;<code>floor</code>&nbsp;，它表示地板上砖块的颜色。</p>\n\n<ul>\n\t<li><code>floor[i] = '0'</code>&nbsp;表示地板上第&nbsp;<code>i</code>&nbsp;块砖块的颜色是 <strong>黑色</strong>&nbsp;。</li>\n\t<li><code>floor[i] = '1'</code>&nbsp;表示地板上第&nbsp;<code>i</code>&nbsp;块砖块的颜色是 <strong>白色</strong>&nbsp;。</li>\n</ul>\n\n<p>同时给你&nbsp;<code>numCarpets</code> 和&nbsp;<code>carpetLen</code>&nbsp;。你有&nbsp;<code>numCarpets</code>&nbsp;条&nbsp;<strong>黑色</strong>&nbsp;的地毯，每一条&nbsp;<strong>黑色</strong>&nbsp;的地毯长度都为&nbsp;<code>carpetLen</code>&nbsp;块砖块。请你使用这些地毯去覆盖砖块，使得未被覆盖的剩余 <strong>白色</strong>&nbsp;砖块的数目 <strong>最小</strong>&nbsp;。地毯相互之间可以覆盖。</p>\n\n<p>请你返回没被覆盖的白色砖块的 <strong>最少</strong>&nbsp;数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/10/ex1-1.png\" style=\"width: 400px; height: 73px;\"></p>\n\n<pre><b>输入：</b>floor = \"10110101\", numCarpets = 2, carpetLen = 2\n<b>输出：</b>2\n<b>解释：</b>\n上图展示了剩余 2 块白色砖块的方案。\n没有其他方案可以使未被覆盖的白色砖块少于 2 块。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/10/ex2.png\" style=\"width: 353px; height: 123px;\"></p>\n\n<pre><b>输入：</b>floor = \"11111\", numCarpets = 2, carpetLen = 3\n<b>输出：</b>0\n<b>解释：</b>\n上图展示了所有白色砖块都被覆盖的一种方案。\n注意，地毯相互之间可以覆盖。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= carpetLen &lt;= floor.length &lt;= 1000</code></li>\n\t<li><code>floor[i]</code> 要么是&nbsp;<code>'0'</code>&nbsp;，要么是&nbsp;<code>'1'</code>&nbsp;。</li>\n\t<li><code>1 &lt;= numCarpets &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2210.统计数组中峰和谷的数量",
        "hardRate": "EASY",
        "passRate": "58.65%",
        "problemsUrl": "https://leetcode.cn/problems/count-hills-and-valleys-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/count-hills-and-valleys-in-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。如果两侧距 <code>i</code> 最近的不相等邻居的值均小于 <code>nums[i]</code> ，则下标 <code>i</code> 是 <code>nums</code> 中，某个峰的一部分。类似地，如果两侧距 <code>i</code> 最近的不相等邻居的值均大于 <code>nums[i]</code> ，则下标 <code>i</code> 是 <code>nums</code> 中某个谷的一部分。对于相邻下标&nbsp;<code>i</code> 和 <code>j</code> ，如果&nbsp;<code>nums[i] == nums[j]</code> ， 则认为这两下标属于 <strong>同一个</strong> 峰或谷。</p>\n\n<p>注意，要使某个下标所做峰或谷的一部分，那么它左右两侧必须 <strong>都</strong> 存在不相等邻居。</p>\n\n<p>返回 <code>nums</code> 中峰和谷的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,4,1,1,6,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n在下标 0 ：由于 2 的左侧不存在不相等邻居，所以下标 0 既不是峰也不是谷。\n在下标 1 ：4 的最近不相等邻居是 2 和 1 。由于 4 &gt; 2 且 4 &gt; 1 ，下标 1 是一个峰。\n在下标 2 ：1 的最近不相等邻居是 4 和 6 。由于 1 &lt; 4 且 1 &lt; 6 ，下标 2 是一个谷。\n在下标 3 ：1 的最近不相等邻居是 4 和 6 。由于 1 &lt; 4 且 1 &lt; 6 ，下标 3 符合谷的定义，但需要注意它和下标 2 是同一个谷的一部分。\n在下标 4 ：6 的最近不相等邻居是 1 和 5 。由于 6 &gt; 1 且 6 &gt; 5 ，下标 4 是一个峰。\n在下标 5 ：由于 5 的右侧不存在不相等邻居，所以下标 5 既不是峰也不是谷。\n共有 3 个峰和谷，所以返回 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [6,6,5,5,4,1]\n<strong>输出：</strong>0\n<strong>解释：</strong>\n在下标 0 ：由于 6 的左侧不存在不相等邻居，所以下标 0 既不是峰也不是谷。\n在下标 1 ：由于 6 的左侧不存在不相等邻居，所以下标 1 既不是峰也不是谷。\n在下标 2 ：5 的最近不相等邻居是 6 和 4 。由于 5 &lt; 6 且 5 &gt; 4 ，下标 2 既不是峰也不是谷。\n在下标 3 ：5 的最近不相等邻居是 6 和 4 。由于 5 &lt; 6 且 5 &gt; 4 ，下标 3 既不是峰也不是谷。\n在下标 4 ：4 的最近不相等邻居是 5 和 1 。由于 4 &lt; 5 且 4 &gt; 1 ，下标 4 既不是峰也不是谷。\n在下标 5 ：由于 1 的右侧不存在不相等邻居，所以下标 5 既不是峰也不是谷。\n共有 0 个峰和谷，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2211.统计道路上的碰撞次数",
        "hardRate": "MEDIUM",
        "passRate": "41.08%",
        "problemsUrl": "https://leetcode.cn/problems/count-collisions-on-a-road/",
        "solutionsUrl": "https://leetcode.cn/problems/count-collisions-on-a-road/solution",
        "problemsDesc": "<p>在一条无限长的公路上有 <code>n</code> 辆汽车正在行驶。汽车按从左到右的顺序按从 <code>0</code> 到 <code>n - 1</code> 编号，每辆车都在一个 <strong>独特的</strong> 位置。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>directions</code> ，长度为 <code>n</code> 。<code>directions[i]</code> 可以是 <code>'L'</code>、<code>'R'</code> 或 <code>'S'</code> 分别表示第 <code>i</code> 辆车是向 <strong>左</strong> 、向 <strong>右</strong> 或者 <strong>停留</strong> 在当前位置。每辆车移动时 <strong>速度相同</strong> 。</p>\n\n<p>碰撞次数可以按下述方式计算：</p>\n\n<ul>\n\t<li>当两辆移动方向&nbsp;<strong>相反</strong>&nbsp;的车相撞时，碰撞次数加 <code>2</code> 。</li>\n\t<li>当一辆移动的车和一辆静止的车相撞时，碰撞次数加 <code>1</code> 。</li>\n</ul>\n\n<p>碰撞发生后，涉及的车辆将无法继续移动并停留在碰撞位置。除此之外，汽车不能改变它们的状态或移动方向。</p>\n\n<p>返回在这条道路上发生的 <strong>碰撞总次数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>directions = \"RLRSLL\"\n<strong>输出：</strong>5\n<strong>解释：</strong>\n将会在道路上发生的碰撞列出如下：\n- 车 0 和车 1 会互相碰撞。由于它们按相反方向移动，碰撞数量变为 0 + 2 = 2 。\n- 车 2 和车 3 会互相碰撞。由于 3 是静止的，碰撞数量变为 2 + 1 = 3 。\n- 车 3 和车 4 会互相碰撞。由于 3 是静止的，碰撞数量变为 3 + 1 = 4 。\n- 车 4 和车 5 会互相碰撞。在车 4 和车 3 碰撞之后，车 4 会待在碰撞位置，接着和车 5 碰撞。碰撞数量变为 4 + 1 = 5 。\n因此，将会在道路上发生的碰撞总次数是 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>directions = \"LLRR\"\n<strong>输出：</strong>0\n<strong>解释：</strong>\n不存在会发生碰撞的车辆。因此，将会在道路上发生的碰撞总次数是 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= directions.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>directions[i]</code> 的值为 <code>'L'</code>、<code>'R'</code> 或 <code>'S'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2212.射箭比赛中的最大得分",
        "hardRate": "MEDIUM",
        "passRate": "47.85%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-points-in-an-archery-competition/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-points-in-an-archery-competition/solution",
        "problemsDesc": "<p>Alice 和 Bob 是一场射箭比赛中的对手。比赛规则如下：</p>\n\n<ol>\n\t<li>Alice 先射 <code>numArrows</code> 支箭，然后 Bob 也射 <code>numArrows</code> 支箭。</li>\n\t<li>分数按下述规则计算：\n\t<ol>\n\t\t<li>箭靶有若干整数计分区域，范围从 <code>0</code> 到 <code>11</code> （含 <code>0</code> 和 <code>11</code>）。</li>\n\t\t<li>箭靶上每个区域都对应一个得分 <code>k</code>（范围是 <code>0</code> 到 <code>11</code>），Alice 和 Bob 分别在得分 <code>k</code>&nbsp;区域射中&nbsp;<code>a<sub>k</sub></code> 和 <code>b<sub>k</sub></code> 支箭。如果 <code>a<sub>k</sub> &gt;= b<sub>k</sub></code> ，那么 Alice 得 <code>k</code> 分。如果 <code>a<sub>k</sub> &lt; b<sub>k</sub></code> ，则 Bob 得 <code>k</code> 分</li>\n\t\t<li>如果 <code>a<sub>k</sub> == b<sub>k</sub> == 0</code> ，那么无人得到 <code>k</code> 分。</li>\n\t</ol>\n\t</li>\n</ol>\n\n<ul>\n\t<li>\n\t<p>例如，Alice 和 Bob 都向计分为 <code>11</code> 的区域射 <code>2</code> 支箭，那么 Alice 得 <code>11</code> 分。如果 Alice 向计分为 <code>11</code> 的区域射 <code>0</code> 支箭，但 Bob 向同一个区域射 <code>2</code> 支箭，那么 Bob 得&nbsp;<code>11</code> 分。</p>\n\t</li>\n</ul>\n\n<p>给你整数 <code>numArrows</code> 和一个长度为 <code>12</code> 的整数数组 <code>aliceArrows</code> ，该数组表示 Alice 射中&nbsp;<code>0</code> 到 <code>11</code> 每个计分区域的箭数量。现在，Bob 想要尽可能 <strong>最大化</strong> 他所能获得的总分。</p>\n\n<p>返回数组 <code>bobArrows</code><em> </em>，该数组表示 Bob 射中&nbsp;<code>0</code> 到 <code>11</code> <strong>每个</strong> 计分区域的箭数量。且 <code>bobArrows</code> 的总和应当等于 <code>numArrows</code> 。</p>\n\n<p>如果存在多种方法都可以使 Bob 获得最大总分，返回其中 <strong>任意一种</strong> 即可。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1647744752-kQKrXw-image.png\" style=\"width: 600px; height: 120px;\" /></p>\n\n<pre>\n<strong>输入：</strong>numArrows = 9, aliceArrows = [1,1,0,1,0,0,2,1,0,1,2,0]\n<strong>输出：</strong>[0,0,0,0,1,1,0,0,1,2,3,1]\n<strong>解释：</strong>上表显示了比赛得分情况。\nBob 获得总分 4 + 5 + 8 + 9 + 10 + 11 = 47 。\n可以证明 Bob 无法获得比 47 更高的分数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1647744785-cMHzaC-image.png\" style=\"width: 600px; height: 117px;\" /></p>\n\n<pre>\n<strong>输入：</strong>numArrows = 3, aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]\n<strong>输出：</strong>[0,0,0,0,0,0,0,0,1,1,1,0]\n<strong>解释：</strong>上表显示了比赛得分情况。\nBob 获得总分 8 + 9 + 10 = 27 。\n可以证明 Bob 无法获得比 27 更高的分数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numArrows &lt;= 10<sup>5</sup></code></li>\n\t<li><code>aliceArrows.length == bobArrows.length == 12</code></li>\n\t<li><code>0 &lt;= aliceArrows[i], bobArrows[i] &lt;= numArrows</code></li>\n\t<li><code>sum(aliceArrows[i]) == numArrows</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2213.由单个字符重复的最长子字符串",
        "hardRate": "HARD",
        "passRate": "40.69%",
        "problemsUrl": "https://leetcode.cn/problems/longest-substring-of-one-repeating-character/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-substring-of-one-repeating-character/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> 。另给你一个下标从 <strong>0</strong> 开始、长度为 <code>k</code> 的字符串 <code>queryCharacters</code> ，一个下标从 <code>0</code> 开始、长度也是 <code>k</code> 的整数 <strong>下标</strong> 数组&nbsp;<code>queryIndices</code> ，这两个都用来描述 <code>k</code> 个查询。</p>\n\n<p>第 <code>i</code> 个查询会将 <code>s</code> 中位于下标 <code>queryIndices[i]</code> 的字符更新为 <code>queryCharacters[i]</code> 。</p>\n\n<p>返回一个长度为 <code>k</code> 的数组 <code>lengths</code> ，其中 <code>lengths[i]</code> 是在执行第 <code>i</code> 个查询 <strong>之后</strong> <code>s</code> 中仅由 <strong>单个字符重复</strong> 组成的 <strong>最长子字符串</strong> 的 <strong>长度</strong> <em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"babacc\", queryCharacters = \"bcb\", queryIndices = [1,3,3]\n<strong>输出：</strong>[3,3,4]\n<strong>解释：</strong>\n- 第 1 次查询更新后 s = \"<em>b<strong>b</strong>b</em>acc\" 。由单个字符重复组成的最长子字符串是 \"bbb\" ，长度为 3 。\n- 第 2 次查询更新后 s = \"bbb<em><strong>c</strong>cc</em>\" 。由单个字符重复组成的最长子字符串是 \"bbb\" 或 \"ccc\"，长度为 3 。\n- 第 3 次查询更新后 s = \"<em>bbb<strong>b</strong></em>cc\" 。由单个字符重复组成的最长子字符串是 \"bbbb\" ，长度为 4 。\n因此，返回 [3,3,4] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abyzz\", queryCharacters = \"aa\", queryIndices = [2,1]\n<strong>输出：</strong>[2,3]\n<strong>解释：</strong>\n- 第 1 次查询更新后 s = \"ab<strong>a</strong><em>zz</em>\" 。由单个字符重复组成的最长子字符串是 \"zz\" ，长度为 2 。\n- 第 2 次查询更新后 s = \"<em>a<strong>a</strong>a</em>zz\" 。由单个字符重复组成的最长子字符串是 \"aaa\" ，长度为 3 。\n因此，返回 [2,3] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n\t<li><code>k == queryCharacters.length == queryIndices.length</code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queryCharacters</code> 由小写英文字母组成</li>\n\t<li><code>0 &lt;= queryIndices[i] &lt; s.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2214.通关游戏所需的最低生命值",
        "hardRate": "MEDIUM",
        "passRate": "55.47%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-health-to-beat-game/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-health-to-beat-game/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2215.找出两数组的不同",
        "hardRate": "EASY",
        "passRate": "66.90%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-difference-of-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-difference-of-two-arrays/solution",
        "problemsDesc": "<p>给你两个下标从 <code>0</code> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，请你返回一个长度为 <code>2</code> 的列表 <code>answer</code> ，其中：</p>\n\n<ul>\n\t<li><code>answer[0]</code> 是 <code>nums1</code> 中所有<strong> 不 </strong>存在于 <code>nums2</code> 中的 <strong>不同</strong> 整数组成的列表。</li>\n\t<li><code>answer[1]</code> 是 <code>nums2</code> 中所有<strong> 不 </strong>存在于 <code>nums1</code> 中的 <strong>不同</strong> 整数组成的列表。</li>\n</ul>\n\n<p><strong>注意：</strong>列表中的整数可以按 <strong>任意</strong> 顺序返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2,3], nums2 = [2,4,6]\n<strong>输出：</strong>[[1,3],[4,6]]\n<strong>解释：\n</strong>对于 nums1 ，nums1[1] = 2 出现在 nums2 中下标 0 处，然而 nums1[0] = 1 和 nums1[2] = 3 没有出现在 nums2 中。因此，answer[0] = [1,3]。\n对于 nums2 ，nums2[0] = 2 出现在 nums1 中下标 1 处，然而 nums2[1] = 4 和 nums2[2] = 6 没有出现在 nums2 中。因此，answer[1] = [4,6]。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2,3,3], nums2 = [1,1,2,2]\n<strong>输出：</strong>[[3],[]]\n<strong>解释：\n</strong>对于 nums1 ，nums1[2] 和 nums1[3] 没有出现在 nums2 中。由于 nums1[2] == nums1[3] ，二者的值只需要在 answer[0] 中出现一次，故 answer[0] = [3]。\nnums2 中的每个整数都在 nums1 中出现，因此，answer[1] = [] 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2216.美化数组的最少删除数",
        "hardRate": "MEDIUM",
        "passRate": "48.62%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-array-beautiful/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-array-beautiful/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，如果满足下述条件，则认为数组 <code>nums</code> 是一个 <strong>美丽数组</strong> ：</p>\n\n<ul>\n\t<li><code>nums.length</code> 为偶数</li>\n\t<li>对所有满足 <code>i % 2 == 0</code> 的下标 <code>i</code> ，<code>nums[i] != nums[i + 1]</code> 均成立</li>\n</ul>\n\n<p>注意，空数组同样认为是美丽数组。</p>\n\n<p>你可以从 <code>nums</code> 中删除任意数量的元素。当你删除一个元素时，被删除元素右侧的所有元素将会向左移动一个单位以填补空缺，而左侧的元素将会保持 <strong>不变</strong> 。</p>\n\n<p>返回使 <code>nums</code> 变为美丽数组所需删除的 <strong>最少</strong> 元素数目<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,2,3,5]\n<strong>输出：</strong>1\n<strong>解释：</strong>可以删除 <code>nums[0]</code> 或 <code>nums[1]</code> ，这样得到的 <code>nums</code> = [1,2,3,5] 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 1 个元素。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,2,2,3,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>可以删除 <code>nums[0]</code> 和 <code>nums[5]</code> ，这样得到的 nums = [1,2,2,3] 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 2 个元素。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2217.找到指定长度的回文数",
        "hardRate": "MEDIUM",
        "passRate": "33.69%",
        "problemsUrl": "https://leetcode.cn/problems/find-palindrome-with-fixed-length/",
        "solutionsUrl": "https://leetcode.cn/problems/find-palindrome-with-fixed-length/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>queries</code>&nbsp;和一个 <strong>正</strong>&nbsp;整数&nbsp;<code>intLength</code>&nbsp;，请你返回一个数组&nbsp;<code>answer</code>&nbsp;，其中&nbsp;<code>answer[i]</code> 是长度为&nbsp;<code>intLength</code>&nbsp;的&nbsp;<strong>正回文数</strong> 中第<em>&nbsp;</em><code>queries[i]</code>&nbsp;小的数字，如果不存在这样的回文数，则为 <code>-1</code>&nbsp;。</p>\n\n<p><strong>回文数</strong> 指的是从前往后和从后往前读一模一样的数字。回文数不能有前导 0 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>queries = [1,2,3,4,5,90], intLength = 3\n<b>输出：</b>[101,111,121,131,141,999]\n<strong>解释：</strong>\n长度为 3 的最小回文数依次是：\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, ...\n第 90 个长度为 3 的回文数是 999 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>queries = [2,4,6], intLength = 4\n<b>输出：</b>[1111,1331,1551]\n<strong>解释：</strong>\n长度为 4 的前 6 个回文数是：\n1001, 1111, 1221, 1331, 1441 和 1551 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= queries.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= queries[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= intLength&nbsp;&lt;= 15</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2218.从栈中取出 K 个硬币的最大面值和",
        "hardRate": "HARD",
        "passRate": "55.28%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-value-of-k-coins-from-piles/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-value-of-k-coins-from-piles/solution",
        "problemsDesc": "<p>一张桌子上总共有 <code>n</code>&nbsp;个硬币 <b>栈</b>&nbsp;。每个栈有 <strong>正整数</strong>&nbsp;个带面值的硬币。</p>\n\n<p>每一次操作中，你可以从任意一个栈的 <strong>顶部</strong>&nbsp;取出 1 个硬币，从栈中移除它，并放入你的钱包里。</p>\n\n<p>给你一个列表&nbsp;<code>piles</code>&nbsp;，其中&nbsp;<code>piles[i]</code>&nbsp;是一个整数数组，分别表示第 <code>i</code>&nbsp;个栈里 <strong>从顶到底</strong>&nbsp;的硬币面值。同时给你一个正整数&nbsp;<code>k</code>&nbsp;，请你返回在&nbsp;<strong>恰好</strong>&nbsp;进行&nbsp;<code>k</code>&nbsp;次操作的前提下，你钱包里硬币面值之和&nbsp;<strong>最大为多少</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/09/e1.png\" style=\"width: 600px; height: 243px;\" /></p>\n\n<pre>\n<b>输入：</b>piles = [[1,100,3],[7,8,9]], k = 2\n<b>输出：</b>101\n<strong>解释：</strong>\n上图展示了几种选择 k 个硬币的不同方法。\n我们可以得到的最大面值为 101 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7\n<b>输出：</b>706\n<strong>解释：\n</strong>如果我们所有硬币都从最后一个栈中取，可以得到最大面值和。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == piles.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= piles[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= sum(piles[i].length) &lt;= 2000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2219.数组的最大总分",
        "hardRate": "MEDIUM",
        "passRate": "64.13%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-score-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-score-of-array/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2220.转换数字的最少位翻转次数",
        "hardRate": "EASY",
        "passRate": "82.58%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-bit-flips-to-convert-number/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-bit-flips-to-convert-number/solution",
        "problemsDesc": "<p>一次 <strong>位翻转</strong>&nbsp;定义为将数字&nbsp;<code>x</code>&nbsp;二进制中的一个位进行 <strong>翻转</strong>&nbsp;操作，即将&nbsp;<code>0</code>&nbsp;变成&nbsp;<code>1</code>&nbsp;，或者将&nbsp;<code>1</code>&nbsp;变成&nbsp;<code>0</code>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，<code>x = 7</code>&nbsp;，二进制表示为&nbsp;<code>111</code>&nbsp;，我们可以选择任意一个位（包含没有显示的前导 0 ）并进行翻转。比方说我们可以翻转最右边一位得到&nbsp;<code>110</code>&nbsp;，或者翻转右边起第二位得到&nbsp;<code>101</code>&nbsp;，或者翻转右边起第五位（这一位是前导 0 ）得到&nbsp;<code>10111</code>&nbsp;等等。</li>\n</ul>\n\n<p>给你两个整数&nbsp;<code>start</code> 和&nbsp;<code>goal</code>&nbsp;，请你返回将&nbsp;<code>start</code>&nbsp;转变成&nbsp;<code>goal</code>&nbsp;的&nbsp;<strong>最少位翻转</strong>&nbsp;次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>start = 10, goal = 7\n<b>输出：</b>3\n<b>解释：</b>10 和 7 的二进制表示分别为 1010 和 0111 。我们可以通过 3 步将 10 转变成 7 ：\n- 翻转右边起第一位得到：101<strong><em>0</em></strong> -&gt; 101<strong><em>1 。</em></strong>\n- 翻转右边起第三位：1<strong><em>0</em></strong>11 -&gt; 1<strong><em>1</em></strong>11 。\n- 翻转右边起第四位：<strong><em>1</em></strong>111 -&gt; <strong><em>0</em></strong>111 。\n我们无法在 3 步内将 10 转变成 7 。所以我们返回 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>start = 3, goal = 4\n<b>输出：</b>3\n<b>解释：</b>3 和 4 的二进制表示分别为 011 和 100 。我们可以通过 3 步将 3 转变成 4 ：\n- 翻转右边起第一位：01<strong><em>1</em></strong> -&gt; 01<em><strong>0 </strong></em>。\n- 翻转右边起第二位：0<strong><em>1</em></strong>0 -&gt; 0<strong><em>0</em></strong>0 。\n- 翻转右边起第三位：<strong><em>0</em></strong>00 -&gt; <strong><em>1</em></strong>00 。\n我们无法在 3 步内将 3 变成 4 。所以我们返回 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= start, goal &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2221.数组的三角和",
        "hardRate": "MEDIUM",
        "passRate": "79.70%",
        "problemsUrl": "https://leetcode.cn/problems/find-triangular-sum-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-triangular-sum-of-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，其中&nbsp;<code>nums[i]</code>&nbsp;是 <code>0</code>&nbsp;到 <code>9</code>&nbsp;之间（两者都包含）的一个数字。</p>\n\n<p><code>nums</code>&nbsp;的 <strong>三角和</strong>&nbsp;是执行以下操作以后最后剩下元素的值：</p>\n\n<ol>\n\t<li><code>nums</code>&nbsp;初始包含&nbsp;<code>n</code>&nbsp;个元素。如果&nbsp;<code>n == 1</code>&nbsp;，<strong>终止</strong>&nbsp;操作。否则，<strong>创建</strong>&nbsp;一个新的下标从&nbsp;<strong>0</strong>&nbsp;开始的长度为 <code>n - 1</code>&nbsp;的整数数组&nbsp;<code>newNums</code>&nbsp;。</li>\n\t<li>对于满足&nbsp;<code>0 &lt;= i &lt;&nbsp;n - 1</code>&nbsp;的下标&nbsp;<code>i</code>&nbsp;，<code>newNums[i]</code> <strong>赋值</strong>&nbsp;为&nbsp;<code>(nums[i] + nums[i+1]) % 10</code>&nbsp;，<code>%</code>&nbsp;表示取余运算。</li>\n\t<li>将&nbsp;<code>newNums</code>&nbsp;<strong>替换</strong> 数组&nbsp;<code>nums</code>&nbsp;。</li>\n\t<li>从步骤 1 开始&nbsp;<strong>重复</strong>&nbsp;整个过程。</li>\n</ol>\n\n<p>请你返回&nbsp;<code>nums</code>&nbsp;的三角和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/22/ex1drawio.png\" style=\"width: 250px; height: 250px;\" /></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4,5]\n<b>输出：</b>8\n<strong>解释：</strong>\n上图展示了得到数组三角和的过程。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5]\n<b>输出：</b>5\n<b>解释：</b>\n由于 nums 中只有一个元素，数组的三角和为这个元素自己。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2222.选择建筑的方案数",
        "hardRate": "MEDIUM",
        "passRate": "49.94%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-select-buildings/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-select-buildings/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二进制字符串&nbsp;<code>s</code>&nbsp;，它表示一条街沿途的建筑类型，其中：</p>\n\n<ul>\n\t<li><code>s[i] = '0'</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;栋建筑是一栋办公楼，</li>\n\t<li><code>s[i] = '1'</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;栋建筑是一间餐厅。</li>\n</ul>\n\n<p>作为市政厅的官员，你需要随机<strong>&nbsp;选择</strong>&nbsp;3 栋建筑。然而，为了确保多样性，选出来的 3 栋建筑 <strong>相邻</strong>&nbsp;的两栋不能是同一类型。</p>\n\n<ul>\n\t<li>比方说，给你&nbsp;<code>s = \"0<em><strong>0</strong></em>1<em><strong>1</strong></em>0<em><strong>1</strong></em>\"</code>&nbsp;，我们不能选择第&nbsp;<code>1</code>&nbsp;，<code>3</code>&nbsp;和&nbsp;<code>5</code>&nbsp;栋建筑，因为得到的子序列是&nbsp;<code>\"0<em><strong>11</strong></em>\"</code>&nbsp;，有相邻两栋建筑是同一类型，所以 <strong>不合</strong>&nbsp;题意。</li>\n</ul>\n\n<p>请你返回可以选择 3 栋建筑的 <strong>有效方案数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"001101\"\n<b>输出：</b>6\n<b>解释：</b>\n以下下标集合是合法的：\n- [0,2,4] ，从 \"<em><strong>0</strong></em>0<em><strong>1</strong></em>1<em><strong>0</strong></em>1\" 得到 \"010\"\n- [0,3,4] ，从 \"<em><strong>0</strong></em>01<em><strong>10</strong></em>1\" 得到 \"010\"\n- [1,2,4] ，从 \"0<em><strong>01</strong></em>1<em><strong>0</strong></em>1\" 得到 \"010\"\n- [1,3,4] ，从 \"0<em><strong>0</strong></em>1<em><strong>10</strong></em>1\" 得到 \"010\"\n- [2,4,5] ，从 \"00<em><strong>1</strong></em>1<em><strong>01</strong></em>\" 得到 \"101\"\n- [3,4,5] ，从 \"001<em><strong>101</strong></em>\" 得到 \"101\"\n没有别的合法选择，所以总共有 6 种方法。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"11100\"\n<b>输出：</b>0\n<b>解释：</b>没有任何符合题意的选择。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code>&nbsp;要么是&nbsp;<code>'0'</code>&nbsp;，要么是&nbsp;<code>'1'</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2223.构造字符串的总得分和",
        "hardRate": "HARD",
        "passRate": "38.37%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-scores-of-built-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-scores-of-built-strings/solution",
        "problemsDesc": "<p>你需要从空字符串开始&nbsp;<strong>构造</strong> 一个长度为 <code>n</code>&nbsp;的字符串 <code>s</code>&nbsp;，构造的过程为每次给当前字符串 <strong>前面</strong>&nbsp;添加 <strong>一个</strong> 字符。构造过程中得到的所有字符串编号为 <code>1</code>&nbsp;到 <code>n</code>&nbsp;，其中长度为 <code>i</code>&nbsp;的字符串编号为 <code>s<sub>i</sub></code>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，<code>s = \"abaca\"</code>&nbsp;，<code>s<sub>1</sub> == \"a\"</code>&nbsp;，<code>s<sub>2</sub> == \"ca\"</code>&nbsp;，<code>s<sub>3</sub> == \"aca\"</code>&nbsp;依次类推。</li>\n</ul>\n\n<p><code>s<sub>i</sub></code>&nbsp;的 <strong>得分</strong>&nbsp;为&nbsp;<code>s<sub>i</sub></code> 和&nbsp;<code>s<sub>n</sub></code>&nbsp;的 <strong>最长公共前缀</strong> 的长度（注意&nbsp;<code>s == s<sub>n</sub></code>&nbsp;）。</p>\n\n<p>给你最终的字符串&nbsp;<code>s</code>&nbsp;，请你返回每一个<em>&nbsp;</em><code>s<sub>i</sub></code>&nbsp;的&nbsp;<strong>得分之和</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"babab\"\n<b>输出：</b>9\n<b>解释：</b>\ns<sub>1</sub> == \"b\" ，最长公共前缀是 \"b\" ，得分为 1 。\ns<sub>2</sub> == \"ab\" ，没有公共前缀，得分为 0 。\ns<sub>3</sub> == \"bab\" ，最长公共前缀为 \"bab\" ，得分为 3 。\ns<sub>4</sub> == \"abab\" ，没有公共前缀，得分为 0 。\ns<sub>5</sub> == \"babab\" ，最长公共前缀为 \"babab\" ，得分为 5 。\n得分和为 1 + 0 + 3 + 0 + 5 = 9 ，所以我们返回 9 。</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"azbazbzaz\"\n<b>输出：</b>14\n<b>解释：</b>\ns<sub>2</sub> == \"az\" ，最长公共前缀为 \"az\" ，得分为 2 。\ns<sub>6</sub> == \"azbzaz\" ，最长公共前缀为 \"azb\" ，得分为 3 。\ns<sub>9</sub> == \"azbazbzaz\" ，最长公共前缀为 \"azbazbzaz\" ，得分为 9 。\n其他 s<sub>i</sub> 得分均为 0 。\n得分和为 2 + 3 + 9 = 14 ，所以我们返回 14 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2224.转化时间需要的最少操作数",
        "hardRate": "EASY",
        "passRate": "69.43%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-convert-time/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-convert-time/solution",
        "problemsDesc": "<p>给你两个字符串 <code>current</code> 和 <code>correct</code> ，表示两个 <strong>24 小时制时间</strong> 。</p>\n\n<p><strong>24 小时制时间</strong> 按 <code>\"HH:MM\"</code> 进行格式化，其中 <code>HH</code> 在 <code>00</code> 和 <code>23</code> 之间，而 <code>MM</code> 在 <code>00</code> 和 <code>59</code> 之间。最早的 24 小时制时间为 <code>00:00</code> ，最晚的是 <code>23:59</code> 。</p>\n\n<p>在一步操作中，你可以将 <code>current</code> 这个时间增加 <code>1</code>、<code>5</code>、<code>15</code> 或 <code>60</code> 分钟。你可以执行这一操作 <strong>任意</strong> 次数。</p>\n\n<p>返回将&nbsp;<code>current</code><em> </em>转化为<em> </em><code>correct</code> 需要的 <strong>最少操作数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>current = \"02:30\", correct = \"04:35\"\n<strong>输出：</strong>3\n<strong>解释：\n</strong>可以按下述 3 步操作将 current 转换为 correct ：\n- 为 current 加 60 分钟，current 变为 \"03:30\" 。\n- 为 current 加 60 分钟，current 变为 \"04:30\" 。 \n- 为 current 加 5 分钟，current 变为 \"04:35\" 。\n可以证明，无法用少于 3 步操作将 current 转化为 correct 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>current = \"11:00\", correct = \"11:01\"\n<strong>输出：</strong>1\n<strong>解释：</strong>只需要为 current 加一分钟，所以最小操作数是 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>current</code> 和 <code>correct</code> 都符合 <code>\"HH:MM\"</code> 格式</li>\n\t<li><code>current &lt;= correct</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2225.找出输掉零场或一场比赛的玩家",
        "hardRate": "MEDIUM",
        "passRate": "63.01%",
        "problemsUrl": "https://leetcode.cn/problems/find-players-with-zero-or-one-losses/",
        "solutionsUrl": "https://leetcode.cn/problems/find-players-with-zero-or-one-losses/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>matches</code> 其中 <code>matches[i] = [winner<sub>i</sub>, loser<sub>i</sub>]</code> 表示在一场比赛中 <code>winner<sub>i</sub></code> 击败了 <code>loser<sub>i</sub></code> 。</p>\n\n<p>返回一个长度为 2 的列表<em> </em><code>answer</code> ：</p>\n\n<ul>\n\t<li><code>answer[0]</code> 是所有 <strong>没有</strong> 输掉任何比赛的玩家列表。</li>\n\t<li><code>answer[1]</code> 是所有恰好输掉 <strong>一场</strong> 比赛的玩家列表。</li>\n</ul>\n\n<p>两个列表中的值都应该按 <strong>递增</strong> 顺序返回。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>只考虑那些参与 <strong>至少一场</strong> 比赛的玩家。</li>\n\t<li>生成的测试用例保证 <strong>不存在</strong> 两场比赛结果 <strong>相同</strong> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]\n<strong>输出：</strong>[[1,2,10],[4,5,7,8]]\n<strong>解释：</strong>\n玩家 1、2 和 10 都没有输掉任何比赛。\n玩家 4、5、7 和 8 每个都输掉一场比赛。\n玩家 3、6 和 9 每个都输掉两场比赛。\n因此，answer[0] = [1,2,10] 和 answer[1] = [4,5,7,8] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>matches = [[2,3],[1,3],[5,4],[6,4]]\n<strong>输出：</strong>[[1,2,5,6],[]]\n<strong>解释：</strong>\n玩家 1、2、5 和 6 都没有输掉任何比赛。\n玩家 3 和 4 每个都输掉两场比赛。\n因此，answer[0] = [1,2,5,6] 和 answer[1] = [] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= matches.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>matches[i].length == 2</code></li>\n\t<li><code>1 &lt;= winner<sub>i</sub>, loser<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>winner<sub>i</sub> != loser<sub>i</sub></code></li>\n\t<li>所有 <code>matches[i]</code> <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2226.每个小孩最多能分到多少糖果",
        "hardRate": "MEDIUM",
        "passRate": "34.23%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/solution",
        "problemsDesc": "<p>给你一个 <strong>下标从 0 开始</strong> 的整数数组 <code>candies</code> 。数组中的每个元素表示大小为 <code>candies[i]</code> 的一堆糖果。你可以将每堆糖果分成任意数量的 <strong>子堆</strong> ，但 <strong>无法</strong> 再将两堆合并到一起。</p>\n\n<p>另给你一个整数 <code>k</code> 。你需要将这些糖果分配给 <code>k</code> 个小孩，使每个小孩分到 <strong>相同</strong> 数量的糖果。每个小孩可以拿走 <strong>至多一堆</strong> 糖果，有些糖果可能会不被分配。</p>\n\n<p>返回每个小孩可以拿走的 <strong>最大糖果数目</strong><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>candies = [5,8,6], k = 3\n<strong>输出：</strong>5\n<strong>解释：</strong>可以将 candies[1] 分成大小分别为 5 和 3 的两堆，然后把 candies[2] 分成大小分别为 5 和 1 的两堆。现在就有五堆大小分别为 5、5、3、5 和 1 的糖果。可以把 3 堆大小为 5 的糖果分给 3 个小孩。可以证明无法让每个小孩得到超过 5 颗糖果。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>candies = [2,5], k = 11\n<strong>输出：</strong>0\n<strong>解释：</strong>总共有 11 个小孩，但只有 7 颗糖果，但如果要分配糖果的话，必须保证每个小孩至少能得到 1 颗糖果。因此，最后每个小孩都没有得到糖果，答案是 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= candies.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= candies[i] &lt;= 10<sup>7</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>12</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2227.加密解密字符串",
        "hardRate": "HARD",
        "passRate": "39.54%",
        "problemsUrl": "https://leetcode.cn/problems/encrypt-and-decrypt-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/encrypt-and-decrypt-strings/solution",
        "problemsDesc": "<p>给你一个字符数组 <code>keys</code> ，由若干 <strong>互不相同</strong> 的字符组成。还有一个字符串数组 <code>values</code> ，内含若干长度为 2 的字符串。另给你一个字符串数组 <code>dictionary</code> ，包含解密后所有允许的原字符串。请你设计并实现一个支持加密及解密下标从 <strong>0</strong> 开始字符串的数据结构。</p>\n\n<p>字符串 <strong>加密</strong> 按下述步骤进行：</p>\n\n<ol>\n\t<li>对字符串中的每个字符 <code>c</code> ，先从 <code>keys</code> 中找出满足 <code>keys[i] == c</code> 的下标 <code>i</code> 。</li>\n\t<li>在字符串中，用&nbsp;<code>values[i]</code> 替换字符 <code>c</code> 。</li>\n</ol>\n\n<p>字符串 <strong>解密</strong> 按下述步骤进行：</p>\n\n<ol>\n\t<li>将字符串每相邻 2 个字符划分为一个子字符串，对于每个子字符串 <code>s</code> ，找出满足 <code>values[i] == s</code> 的一个下标 <code>i</code> 。如果存在多个有效的 <code>i</code> ，从中选择 <strong>任意</strong> 一个。这意味着一个字符串解密可能得到多个解密字符串。</li>\n\t<li>在字符串中，用 <code>keys[i]</code> 替换 <code>s</code> 。</li>\n</ol>\n\n<p>实现 <code>Encrypter</code> 类：</p>\n\n<ul>\n\t<li><code>Encrypter(char[] keys, String[] values, String[] dictionary)</code> 用 <code>keys</code>、<code>values</code> 和 <code>dictionary</code> 初始化 <code>Encrypter</code> 类。</li>\n\t<li><code>String encrypt(String word1)</code> 按上述加密过程完成对 <code>word1</code> 的加密，并返回加密后的字符串。</li>\n\t<li><code>int decrypt(String word2)</code> 统计并返回可以由 <code>word2</code> 解密得到且出现在 <code>dictionary</code> 中的字符串数目。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"Encrypter\", \"encrypt\", \"decrypt\"]\n[[['a', 'b', 'c', 'd'], [\"ei\", \"zf\", \"ei\", \"am\"], [\"abcd\", \"acbd\", \"adbc\", \"badc\", \"dacb\", \"cadb\", \"cbda\", \"abad\"]], [\"abcd\"], [\"eizfeiam\"]]\n<strong>输出：</strong>\n[null, \"eizfeiam\", 2]\n\n<strong>解释：</strong>\nEncrypter encrypter = new Encrypter([['a', 'b', 'c', 'd'], [\"ei\", \"zf\", \"ei\", \"am\"], [\"abcd\", \"acbd\", \"adbc\", \"badc\", \"dacb\", \"cadb\", \"cbda\", \"abad\"]);\nencrypter.encrypt(\"abcd\"); // 返回 \"eizfeiam\"。 \n&nbsp;                          // 'a' 映射为 \"ei\"，'b' 映射为 \"zf\"，'c' 映射为 \"ei\"，'d' 映射为 \"am\"。\nencrypter.decrypt(\"eizfeiam\"); // return 2. \n                              // \"ei\" 可以映射为 'a' 或 'c'，\"zf\" 映射为 'b'，\"am\" 映射为 'd'。 \n                              // 因此，解密后可以得到的字符串是 \"abad\"，\"cbad\"，\"abcd\" 和 \"cbcd\"。 \n                              // 其中 2 个字符串，\"abad\" 和 \"abcd\"，在 dictionary 中出现，所以答案是 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= keys.length == values.length &lt;= 26</code></li>\n\t<li><code>values[i].length == 2</code></li>\n\t<li><code>1 &lt;= dictionary.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= dictionary[i].length &lt;= 100</code></li>\n\t<li>所有 <code>keys[i]</code> 和 <code>dictionary[i]</code> <strong>互不相同</strong></li>\n\t<li><code>1 &lt;= word1.length &lt;= 2000</code></li>\n\t<li><code>1 &lt;= word2.length &lt;= 200</code></li>\n\t<li>所有 <code>word1[i]</code> 都出现在 <code>keys</code> 中</li>\n\t<li><code>word2.length</code> 是偶数</li>\n\t<li><code>keys</code>、<code>values[i]</code>、<code>dictionary[i]</code>、<code>word1</code> 和 <code>word2</code> 只含小写英文字母</li>\n\t<li>至多调用 <code>encrypt</code> 和 <code>decrypt</code> <strong>总计</strong> <code>200</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2228.7 天内两次购买的用户",
        "hardRate": "MEDIUM",
        "passRate": "47.35%",
        "problemsUrl": "https://leetcode.cn/problems/users-with-two-purchases-within-seven-days/",
        "solutionsUrl": "https://leetcode.cn/problems/users-with-two-purchases-within-seven-days/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2229.检查数组是否连贯",
        "hardRate": "EASY",
        "passRate": "69.89%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-an-array-is-consecutive/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-an-array-is-consecutive/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2230.查找可享受优惠的用户",
        "hardRate": "EASY",
        "passRate": "49.59%",
        "problemsUrl": "https://leetcode.cn/problems/the-users-that-are-eligible-for-discount/",
        "solutionsUrl": "https://leetcode.cn/problems/the-users-that-are-eligible-for-discount/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2231.按奇偶性交换后的最大数字",
        "hardRate": "EASY",
        "passRate": "64.27%",
        "problemsUrl": "https://leetcode.cn/problems/largest-number-after-digit-swaps-by-parity/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-number-after-digit-swaps-by-parity/solution",
        "problemsDesc": "<p>给你一个正整数 <code>num</code> 。你可以交换 <code>num</code> 中 <strong>奇偶性</strong> 相同的任意两位数字（即，都是奇数或者偶数）。</p>\n\n<p>返回交换 <strong>任意</strong> 次之后 <code>num</code> 的 <strong>最大</strong> 可能值<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 1234\n<strong>输出：</strong>3412\n<strong>解释：</strong>交换数字 3 和数字 1 ，结果得到 3214 。\n交换数字 2 和数字 4 ，结果得到 3412 。\n注意，可能存在其他交换序列，但是可以证明 3412 是最大可能值。\n注意，不能交换数字 4 和数字 1 ，因为它们奇偶性不同。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 65875\n<strong>输出：</strong>87655\n<strong>解释：</strong>交换数字 8 和数字 6 ，结果得到 85675 。\n交换数字 5 和数字 7 ，结果得到 87655 。\n注意，可能存在其他交换序列，但是可以证明 87655 是最大可能值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2232.向表达式添加括号后的最小结果",
        "hardRate": "MEDIUM",
        "passRate": "61.25%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-result-by-adding-parentheses-to-expression/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-result-by-adding-parentheses-to-expression/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>expression</code> ，格式为 <code>\"&lt;num1&gt;+&lt;num2&gt;\"</code> ，其中 <code>&lt;num1&gt;</code> 和 <code>&lt;num2&gt;</code> 表示正整数。</p>\n\n<p>请你向 <code>expression</code> 中添加一对括号，使得在添加之后， <code>expression</code> 仍然是一个有效的数学表达式，并且计算后可以得到 <strong>最小</strong> 可能值。左括号 <strong>必须</strong> 添加在 <code>'+'</code> 的左侧，而右括号必须添加在 <code>'+'</code> 的右侧。</p>\n\n<p>返回添加一对括号后形成的表达式&nbsp;<code>expression</code> ，且满足<em> </em><code>expression</code><em> </em>计算得到 <strong>最小</strong> 可能值<em>。</em>如果存在多个答案都能产生相同结果，返回任意一个答案。</p>\n\n<p>生成的输入满足：<code>expression</code> 的原始值和添加满足要求的任一对括号之后 <code>expression</code> 的值，都符合 32-bit 带符号整数范围。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>expression = \"247+38\"\n<strong>输出：</strong>\"2(47+38)\"\n<strong>解释：</strong>表达式计算得到 2 * (47 + 38) = 2 * 85 = 170 。\n注意 \"2(4)7+38\" 不是有效的结果，因为右括号必须添加在 <code>'+' 的右侧。</code>\n可以证明 170 是最小可能值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>expression = \"12+34\"\n<strong>输出：</strong>\"1(2+3)4\"\n<strong>解释：</strong>表达式计算得到 1 * (2 + 3) * 4 = 1 * 5 * 4 = 20 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>expression = \"999+999\"\n<strong>输出：</strong>\"(999+999)\"\n<strong>解释：</strong>表达式计算得到 999 + 999 = 1998 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= expression.length &lt;= 10</code></li>\n\t<li><code>expression</code> 仅由数字 <code>'1'</code> 到 <code>'9'</code> 和 <code>'+'</code> 组成</li>\n\t<li><code>expression</code> 由数字开始和结束</li>\n\t<li><code>expression</code> 恰好仅含有一个 <code>'+'</code>.</li>\n\t<li><code>expression</code> 的原始值和添加满足要求的任一对括号之后 <code>expression</code> 的值，都符合 32-bit 带符号整数范围</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2233.K 次增加后的最大乘积",
        "hardRate": "MEDIUM",
        "passRate": "36.69%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-product-after-k-increments/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-product-after-k-increments/solution",
        "problemsDesc": "<p>给你一个非负整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。每次操作，你可以选择&nbsp;<code>nums</code>&nbsp;中 <strong>任一</strong>&nbsp;元素并将它 <strong>增加</strong>&nbsp;<code>1</code>&nbsp;。</p>\n\n<p>请你返回 <strong>至多</strong>&nbsp;<code>k</code>&nbsp;次操作后，能得到的<em>&nbsp;</em><code>nums</code>的&nbsp;<strong>最大乘积</strong>&nbsp;。由于答案可能很大，请你将答案对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;取余后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [0,4], k = 5\n<b>输出：</b>20\n<b>解释：</b>将第一个数增加 5 次。\n得到 nums = [5, 4] ，乘积为 5 * 4 = 20 。\n可以证明 20 是能得到的最大乘积，所以我们返回 20 。\n存在其他增加 nums 的方法，也能得到最大乘积。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [6,3,3,2], k = 2\n<b>输出：</b>216\n<b>解释：</b>将第二个数增加 1 次，将第四个数增加 1 次。\n得到 nums = [6, 4, 3, 3] ，乘积为 6 * 4 * 3 * 3 = 216 。\n可以证明 216 是能得到的最大乘积，所以我们返回 216 。\n存在其他增加 nums 的方法，也能得到最大乘积。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2234.花园的最大总美丽值",
        "hardRate": "HARD",
        "passRate": "27.90%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-total-beauty-of-the-gardens/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-total-beauty-of-the-gardens/solution",
        "problemsDesc": "<p>Alice 是&nbsp;<code>n</code>&nbsp;个花园的园丁，她想通过种花，最大化她所有花园的总美丽值。</p>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始大小为 <code>n</code>&nbsp;的整数数组&nbsp;<code>flowers</code>&nbsp;，其中&nbsp;<code>flowers[i]</code>&nbsp;是第 <code>i</code>&nbsp;个花园里已经种的花的数目。已经种了的花 <strong>不能</strong>&nbsp;移走。同时给你&nbsp;<code>newFlowers</code>&nbsp;，表示 Alice 额外可以种花的&nbsp;<strong>最大数目</strong>&nbsp;。同时给你的还有整数&nbsp;<code>target</code>&nbsp;，<code>full</code>&nbsp;和&nbsp;<code>partial</code>&nbsp;。</p>\n\n<p>如果一个花园有 <strong>至少</strong>&nbsp;<code>target</code>&nbsp;朵花，那么这个花园称为 <strong>完善的</strong>&nbsp;，花园的 <strong>总美丽值</strong>&nbsp;为以下分数之 <strong>和</strong> ：</p>\n\n<ul>\n\t<li><b>完善</b> 花园数目乘以&nbsp;<code>full</code>.</li>\n\t<li>剩余 <strong>不完善</strong>&nbsp;花园里，花的 <strong>最少数目</strong>&nbsp;乘以&nbsp;<code>partial</code>&nbsp;。如果没有不完善花园，那么这一部分的值为&nbsp;<code>0</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回 Alice 种最多 <code>newFlowers</code>&nbsp;朵花以后，能得到的<strong>&nbsp;最大</strong>&nbsp;总美丽值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>flowers = [1,3,1,1], newFlowers = 7, target = 6, full = 12, partial = 1\n<b>输出：</b>14\n<b>解释：</b>Alice 可以按以下方案种花\n- 在第 0 个花园种 2 朵花\n- 在第 1 个花园种 3 朵花\n- 在第 2 个花园种 1 朵花\n- 在第 3 个花园种 1 朵花\n花园里花的数目为 [3,6,2,2] 。总共种了 2 + 3 + 1 + 1 = 7 朵花。\n只有 1 个花园是完善的。\n不完善花园里花的最少数目是 2 。\n所以总美丽值为 1 * 12 + 2 * 1 = 12 + 2 = 14 。\n没有其他方案可以让花园总美丽值超过 14 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>flowers = [2,4,5,3], newFlowers = 10, target = 5, full = 2, partial = 6\n<b>输出：</b>30\n<b>解释：</b>Alice 可以按以下方案种花\n- 在第 0 个花园种 3 朵花\n- 在第 1 个花园种 0 朵花\n- 在第 2 个花园种 0 朵花\n- 在第 3 个花园种 2 朵花\n花园里花的数目为 [5,4,5,5] 。总共种了 3 + 0 + 0 + 2 = 5 朵花。\n有 3 个花园是完善的。\n不完善花园里花的最少数目为 4 。\n所以总美丽值为 3 * 2 + 4 * 6 = 6 + 24 = 30 。\n没有其他方案可以让花园总美丽值超过 30 。\n注意，Alice可以让所有花园都变成完善的，但这样她的总美丽值反而更小。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= flowers.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= flowers[i], target &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= newFlowers &lt;= 10<sup>10</sup></code></li>\n\t<li><code>1 &lt;= full, partial &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2235.两整数相加",
        "hardRate": "EASY",
        "passRate": "84.27%",
        "problemsUrl": "https://leetcode.cn/problems/add-two-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/add-two-integers/solution",
        "problemsDesc": "给你两个整数&nbsp;<code>num1</code> 和 <code>num2</code>，返回这两个整数的和。\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = 12, num2 = 5\n<strong>输出：</strong>17\n<strong>解释：</strong>num1 是 12，num2 是 5 ，它们的和是 12 + 5 = 17 ，因此返回 17 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = -10, num2 = 4\n<strong>输出：</strong>-6\n<strong>解释：</strong>num1 + num2 = -6 ，因此返回 -6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-100 &lt;= num1, num2 &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2236.判断根结点是否等于子结点之和",
        "hardRate": "EASY",
        "passRate": "85.60%",
        "problemsUrl": "https://leetcode.cn/problems/root-equals-sum-of-children/",
        "solutionsUrl": "https://leetcode.cn/problems/root-equals-sum-of-children/solution",
        "problemsDesc": "<p>给你一个 <strong>二叉树 </strong>的根结点&nbsp;<code>root</code>，该二叉树由恰好&nbsp;<code>3</code>&nbsp;个结点组成：根结点、左子结点和右子结点。</p>\n\n<p>如果根结点值等于两个子结点值之和，返回&nbsp;<code>true</code>&nbsp;，否则返回<em>&nbsp;</em><code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/08/graph3drawio.png\" style=\"width: 281px; height: 199px;\" />\n<pre>\n<strong>输入：</strong>root = [10,4,6]\n<strong>输出：</strong>true\n<strong>解释：</strong>根结点、左子结点和右子结点的值分别是 10 、4 和 6 。\n由于 10 等于 4 + 6 ，因此返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/08/graph3drawio-1.png\" style=\"width: 281px; height: 199px;\" />\n<pre>\n<strong>输入：</strong>root = [5,3,1]\n<strong>输出：</strong>false\n<strong>解释：</strong>根结点、左子结点和右子结点的值分别是 5 、3 和 1 。\n由于 5 不等于 3 + 1 ，因此返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树只包含根结点、左子结点和右子结点</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2237.计算街道上满足所需亮度的位置数量",
        "hardRate": "MEDIUM",
        "passRate": "74.29%",
        "problemsUrl": "https://leetcode.cn/problems/count-positions-on-street-with-required-brightness/",
        "solutionsUrl": "https://leetcode.cn/problems/count-positions-on-street-with-required-brightness/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2238.司机成为乘客的次数",
        "hardRate": "MEDIUM",
        "passRate": "70.03%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-times-a-driver-was-a-passenger/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-times-a-driver-was-a-passenger/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2239.找到最接近 0 的数字",
        "hardRate": "EASY",
        "passRate": "53.52%",
        "problemsUrl": "https://leetcode.cn/problems/find-closest-number-to-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/find-closest-number-to-zero/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;，请你返回 <code>nums</code>&nbsp;中最 <strong>接近</strong>&nbsp;<code>0</code>&nbsp;的数字。如果有多个答案，请你返回它们中的 <strong>最大值</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [-4,-2,1,4,8]\n<b>输出：</b>1\n<strong>解释：</strong>\n-4 到 0 的距离为 |-4| = 4 。\n-2 到 0 的距离为 |-2| = 2 。\n1 到 0 的距离为 |1| = 1 。\n4 到 0 的距离为 |4| = 4 。\n8 到 0 的距离为 |8| = 8 。\n所以，数组中距离 0 最近的数字为 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,-1,1]\n<b>输出：</b>1\n<b>解释：</b>1 和 -1 都是距离 0 最近的数字，所以返回较大值 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2240.买钢笔和铅笔的方案数",
        "hardRate": "MEDIUM",
        "passRate": "57.47%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-buy-pens-and-pencils/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-buy-pens-and-pencils/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>total</code>&nbsp;，表示你拥有的总钱数。同时给你两个整数&nbsp;<code>cost1</code> 和&nbsp;<code>cost2</code>&nbsp;，分别表示一支钢笔和一支铅笔的价格。你可以花费你部分或者全部的钱，去买任意数目的两种笔。</p>\n\n<p>请你返回购买钢笔和铅笔的&nbsp;<strong>不同方案数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>total = 20, cost1 = 10, cost2 = 5\n<b>输出：</b>9\n<b>解释：</b>一支钢笔的价格为 10 ，一支铅笔的价格为 5 。\n- 如果你买 0 支钢笔，那么你可以买 0 ，1 ，2 ，3 或者 4 支铅笔。\n- 如果你买 1 支钢笔，那么你可以买 0 ，1 或者 2 支铅笔。\n- 如果你买 2 支钢笔，那么你没法买任何铅笔。\n所以买钢笔和铅笔的总方案数为 5 + 3 + 1 = 9 种。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>total = 5, cost1 = 10, cost2 = 10\n<b>输出：</b>1\n<b>解释：</b>钢笔和铅笔的价格都为 10 ，都比拥有的钱数多，所以你没法购买任何文具。所以只有 1 种方案：买 0 支钢笔和 0 支铅笔。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= total, cost1, cost2 &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2241.设计一个 ATM 机器",
        "hardRate": "MEDIUM",
        "passRate": "36.27%",
        "problemsUrl": "https://leetcode.cn/problems/design-an-atm-machine/",
        "solutionsUrl": "https://leetcode.cn/problems/design-an-atm-machine/solution",
        "problemsDesc": "<p>一个 ATM 机器，存有&nbsp;<code>5</code>&nbsp;种面值的钞票：<code>20</code>&nbsp;，<code>50</code>&nbsp;，<code>100</code>&nbsp;，<code>200</code>&nbsp;和&nbsp;<code>500</code>&nbsp;美元。初始时，ATM 机是空的。用户可以用它存或者取任意数目的钱。</p>\n\n<p>取款时，机器会优先取 <b>较大</b>&nbsp;数额的钱。</p>\n\n<ul>\n\t<li>比方说，你想取&nbsp;<code>$300</code>&nbsp;，并且机器里有&nbsp;<code>2</code>&nbsp;张 <code>$50</code>&nbsp;的钞票，<code>1</code>&nbsp;张&nbsp;<code>$100</code>&nbsp;的钞票和<code>1</code>&nbsp;张&nbsp;<code>$200</code>&nbsp;的钞票，那么机器会取出&nbsp;<code>$100</code> 和&nbsp;<code>$200</code>&nbsp;的钞票。</li>\n\t<li>但是，如果你想取&nbsp;<code>$600</code>&nbsp;，机器里有&nbsp;<code>3</code>&nbsp;张&nbsp;<code>$200</code>&nbsp;的钞票和<code>1</code>&nbsp;张&nbsp;<code>$500</code>&nbsp;的钞票，那么取款请求会被拒绝，因为机器会先取出&nbsp;<code>$500</code>&nbsp;的钞票，然后无法取出剩余的&nbsp;<code>$100</code>&nbsp;。注意，因为有&nbsp;<code>$500</code>&nbsp;钞票的存在，机器&nbsp;<strong>不能</strong>&nbsp;取&nbsp;<code>$200</code>&nbsp;的钞票。</li>\n</ul>\n\n<p>请你实现 ATM 类：</p>\n\n<ul>\n\t<li><code>ATM()</code>&nbsp;初始化 ATM 对象。</li>\n\t<li><code>void deposit(int[] banknotesCount)</code>&nbsp;分别存入&nbsp;<code>$20</code>&nbsp;，<code>$50</code>，<code>$100</code>，<code>$200</code>&nbsp;和&nbsp;<code>$500</code>&nbsp;钞票的数目。</li>\n\t<li><code>int[] withdraw(int amount)</code>&nbsp;返回一个长度为&nbsp;<code>5</code>&nbsp;的数组，分别表示&nbsp;<code>$20</code>&nbsp;，<code>$50</code>，<code>$100</code>&nbsp;，<code>$200</code>&nbsp;和&nbsp;<code>$500</code>&nbsp;钞票的数目，并且更新 ATM 机里取款后钞票的剩余数量。如果无法取出指定数额的钱，请返回&nbsp;<code>[-1]</code>&nbsp;（这种情况下 <strong>不</strong>&nbsp;取出任何钞票）。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"ATM\", \"deposit\", \"withdraw\", \"deposit\", \"withdraw\", \"withdraw\"]\n[[], [[0,0,1,2,1]], [600], [[0,1,0,1,1]], [600], [550]]\n<strong>输出：</strong>\n[null, null, [0,0,1,0,1], null, [-1], [0,1,0,0,1]]\n\n<strong>解释：</strong>\nATM atm = new ATM();\natm.deposit([0,0,1,2,1]); // 存入 1 张 $100 ，2 张 $200 和 1 张 $500 的钞票。\natm.withdraw(600);        // 返回 [0,0,1,0,1] 。机器返回 1 张 $100 和 1 张 $500 的钞票。机器里剩余钞票的数量为 [0,0,0,2,0] 。\natm.deposit([0,1,0,1,1]); // 存入 1 张 $50 ，1 张 $200 和 1 张 $500 的钞票。\n                          // 机器中剩余钞票数量为 [0,1,0,3,1] 。\natm.withdraw(600);        // 返回 [-1] 。机器会尝试取出 $500 的钞票，然后无法得到剩余的 $100 ，所以取款请求会被拒绝。\n                          // 由于请求被拒绝，机器中钞票的数量不会发生改变。\natm.withdraw(550);        // 返回 [0,1,0,0,1] ，机器会返回 1 张 $50 的钞票和 1 张 $500 的钞票。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>banknotesCount.length == 5</code></li>\n\t<li><code>0 &lt;= banknotesCount[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= amount &lt;= 10<sup>9</sup></code></li>\n\t<li><strong>总共</strong>&nbsp;最多有&nbsp;<code>5000</code>&nbsp;次&nbsp;<code>withdraw</code> 和&nbsp;<code>deposit</code>&nbsp;的调用。</li>\n\t<li><span style=\"\">函数 </span><code>withdraw</code> 和&nbsp;<code>deposit</code>&nbsp;至少各有 <strong>一次&nbsp;</strong>调用。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2242.节点序列的最大得分",
        "hardRate": "HARD",
        "passRate": "34.05%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-of-a-node-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-of-a-node-sequence/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>n</code>&nbsp;个节点的&nbsp;<strong>无向图</strong>&nbsp;，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。</p>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>scores</code>&nbsp;，其中&nbsp;<code>scores[i]</code>&nbsp;是第 <code>i</code>&nbsp;个节点的分数。同时给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;，表示节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条&nbsp;<strong>无向</strong>&nbsp;边。</p>\n\n<p>一个合法的节点序列如果满足以下条件，我们称它是 <strong>合法的</strong>&nbsp;：</p>\n\n<ul>\n\t<li>序列中每&nbsp;<b>相邻</b>&nbsp;节点之间有边相连。</li>\n\t<li>序列中没有节点出现超过一次。</li>\n</ul>\n\n<p>节点序列的分数定义为序列中节点分数之 <strong>和</strong> 。</p>\n\n<p>请你返回一个长度为 <code>4</code>&nbsp;的合法节点序列的最大分数。如果不存在这样的序列，请你返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/15/ex1new3.png\" style=\"width: 290px; height: 215px;\" /></p>\n\n<pre>\n<b>输入：</b>scores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]\n<b>输出：</b>24\n<b>解释：</b>上图为输入的图，节点序列为 [0,1,2,3] 。\n节点序列的分数为 5 + 2 + 9 + 8 = 24 。\n观察可知，没有其他节点序列得分和超过 24 。\n注意节点序列 [3,1,2,0] 和 [1,0,2,3] 也是合法的，且分数为 24 。\n序列 [0,3,2,4] 不是合法的，因为没有边连接节点 0 和 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/17/ex2.png\" style=\"width: 333px; height: 151px;\" /></p>\n\n<pre>\n<b>输入：</b>scores = [9,20,6,4,11,12], edges = [[0,3],[5,3],[2,4],[1,3]]\n<b>输出：</b>-1\n<b>解释：</b>上图为输入的图。\n没有长度为 4 的合法序列，所以我们返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == scores.length</code></li>\n\t<li><code>4 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= scores[i] &lt;= 10<sup>8</sup></code></li>\n\t<li><code>0 &lt;= edges.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>不会有重边。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2243.计算字符串的数字和",
        "hardRate": "EASY",
        "passRate": "63.53%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-digit-sum-of-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-digit-sum-of-a-string/solution",
        "problemsDesc": "<p>给你一个由若干数字（<code>0</code> - <code>9</code>）组成的字符串 <code>s</code> ，和一个整数。</p>\n\n<p>如果 <code>s</code> 的长度大于 <code>k</code> ，则可以执行一轮操作。在一轮操作中，需要完成以下工作：</p>\n\n<ol>\n\t<li>将 <code>s</code> <strong>拆分 </strong>成长度为 <code>k</code> 的若干 <strong>连续数字组</strong> ，使得前 <code>k</code> 个字符都分在第一组，接下来的 <code>k</code> 个字符都分在第二组，依此类推。<strong>注意</strong>，最后一个数字组的长度可以小于 <code>k</code> 。</li>\n\t<li>用表示每个数字组中所有数字之和的字符串来 <strong>替换</strong> 对应的数字组。例如，<code>\"346\"</code> 会替换为 <code>\"13\"</code> ，因为 <code>3 + 4 + 6 = 13</code> 。</li>\n\t<li><strong>合并</strong> 所有组以形成一个新字符串。如果新字符串的长度大于 <code>k</code> 则重复第一步。</li>\n</ol>\n\n<p>返回在完成所有轮操作后的 <code>s</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"11111222223\", k = 3\n<strong>输出：</strong>\"135\"\n<strong>解释：</strong>\n- 第一轮，将 s 分成：\"111\"、\"112\"、\"222\" 和 \"23\" 。\n  接着，计算每一组的数字和：1 + 1 + 1 = 3、1 + 1 + 2 = 4、2 + 2 + 2 = 6 和 2 + 3 = 5 。 \n&nbsp; 这样，s 在第一轮之后变成 \"3\" + \"4\" + \"6\" + \"5\" = \"3465\" 。\n- 第二轮，将 s 分成：\"346\" 和 \"5\" 。\n&nbsp; 接着，计算每一组的数字和：3 + 4 + 6 = 13 、5 = 5 。\n&nbsp; 这样，s 在第二轮之后变成 \"13\" + \"5\" = \"135\" 。 \n现在，s.length &lt;= k ，所以返回 \"135\" 作为答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"00000000\", k = 3\n<strong>输出：</strong>\"000\"\n<strong>解释：</strong>\n将 \"000\", \"000\", and \"00\".\n接着，计算每一组的数字和：0 + 0 + 0 = 0 、0 + 0 + 0 = 0 和 0 + 0 = 0 。 \ns 变为 \"0\" + \"0\" + \"0\" = \"000\" ，其长度等于 k ，所以返回 \"000\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>2 &lt;= k &lt;= 100</code></li>\n\t<li><code>s</code> 仅由数字（<code>0</code> - <code>9</code>）组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2244.完成所有任务需要的最少轮数",
        "hardRate": "MEDIUM",
        "passRate": "57.16%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-rounds-to-complete-all-tasks/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-rounds-to-complete-all-tasks/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>tasks</code> ，其中 <code>tasks[i]</code> 表示任务的难度级别。在每一轮中，你可以完成 2 个或者 3 个 <strong>相同难度级别</strong> 的任务。</p>\n\n<p>返回完成所有任务需要的 <strong>最少</strong> 轮数，如果无法完成所有任务，返回<em> </em><code>-1</code><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>tasks = [2,2,3,3,2,4,4,4,4,4]\n<strong>输出：</strong>4\n<strong>解释：</strong>要想完成所有任务，一个可能的计划是：\n- 第一轮，完成难度级别为 2 的 3 个任务。 \n- 第二轮，完成难度级别为 3 的 2 个任务。 \n- 第三轮，完成难度级别为 4 的 3 个任务。 \n- 第四轮，完成难度级别为 4 的 2 个任务。 \n可以证明，无法在少于 4 轮的情况下完成所有任务，所以答案为 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>tasks = [2,3,3]\n<strong>输出：</strong>-1\n<strong>解释：</strong>难度级别为 2 的任务只有 1 个，但每一轮执行中，只能选择完成 2 个或者 3 个相同难度级别的任务。因此，无法完成所有任务，答案为 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tasks.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= tasks[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2245.转角路径的乘积中最多能有几个尾随零",
        "hardRate": "MEDIUM",
        "passRate": "36.12%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-trailing-zeros-in-a-cornered-path/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-trailing-zeros-in-a-cornered-path/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>grid</code> ，大小为 <code>m x n</code>，其中每个单元格都含一个正整数。</p>\n\n<p><strong>转角路径</strong> 定义为：包含至多一个弯的一组相邻单元。具体而言，路径应该完全 <strong>向水平方向</strong> 或者 <strong>向竖直方向</strong> 移动过弯（如果存在弯），而不能访问之前访问过的单元格。在过弯之后，路径应当完全朝 <strong>另一个</strong> 方向行进：如果之前是向水平方向，那么就应该变为向竖直方向；反之亦然。当然，同样不能访问之前已经访问过的单元格。</p>\n\n<p>一条路径的 <strong>乘积</strong> 定义为：路径上所有值的乘积。</p>\n\n<p>请你从 <code>grid</code> 中找出一条乘积中尾随零数目最多的转角路径，并返回该路径中尾随零的数目。</p>\n\n<p>注意：</p>\n\n<ul>\n\t<li><strong>水平</strong> 移动是指向左或右移动。</li>\n\t<li><strong>竖直 </strong>移动是指向上或下移动。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/23/ex1new2.jpg\" style=\"width: 577px; height: 190px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]\n<strong>输出：</strong>3\n<strong>解释：</strong>左侧的图展示了一条有效的转角路径。\n其乘积为 15 * 20 * 6 * 1 * 10 = 18000 ，共计 3 个尾随零。\n可以证明在这条转角路径的乘积中尾随零数目最多。\n\n中间的图不是一条有效的转角路径，因为它有不止一个弯。\n右侧的图也不是一条有效的转角路径，因为它需要重复访问已经访问过的单元格。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/25/ex2.jpg\" style=\"width: 150px; height: 157px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[4,3,2],[7,6,1],[8,8,8]]\n<strong>输出：</strong>0\n<strong>解释：</strong>网格如上图所示。\n不存在乘积含尾随零的转角路径。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2246.相邻字符不同的最长路径",
        "hardRate": "HARD",
        "passRate": "47.06%",
        "problemsUrl": "https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/solution",
        "problemsDesc": "<p>给你一棵 <strong>树</strong>（即一个连通、无向、无环图），根节点是节点 <code>0</code> ，这棵树由编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个节点组成。用下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的数组 <code>parent</code> 来表示这棵树，其中 <code>parent[i]</code> 是节点 <code>i</code> 的父节点，由于节点 <code>0</code> 是根节点，所以 <code>parent[0] == -1</code> 。</p>\n\n<p>另给你一个字符串 <code>s</code> ，长度也是 <code>n</code> ，其中 <code>s[i]</code> 表示分配给节点 <code>i</code> 的字符。</p>\n\n<p>请你找出路径上任意一对相邻节点都没有分配到相同字符的 <strong>最长路径</strong> ，并返回该路径的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/25/testingdrawio.png\" style=\"width: 201px; height: 241px;\" /></p>\n\n<pre>\n<strong>输入：</strong>parent = [-1,0,0,1,1,2], s = \"abacbe\"\n<strong>输出：</strong>3\n<strong>解释：</strong>任意一对相邻节点字符都不同的最长路径是：0 -&gt; 1 -&gt; 3 。该路径的长度是 3 ，所以返回 3 。\n可以证明不存在满足上述条件且比 3 更长的路径。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/25/graph2drawio.png\" style=\"width: 201px; height: 221px;\" /></p>\n\n<pre>\n<strong>输入：</strong>parent = [-1,0,0,0], s = \"aabc\"\n<strong>输出：</strong>3\n<strong>解释：</strong>任意一对相邻节点字符都不同的最长路径是：2 -&gt; 0 -&gt; 3 。该路径的长度为 3 ，所以返回 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == parent.length == s.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li>对所有 <code>i &gt;= 1</code> ，<code>0 &lt;= parent[i] &lt;= n - 1</code> 均成立</li>\n\t<li><code>parent[0] == -1</code></li>\n\t<li><code>parent</code> 表示一棵有效的树</li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2247.K 条高速公路的最大旅行费用",
        "hardRate": "HARD",
        "passRate": "56.51%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-cost-of-trip-with-k-highways/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-cost-of-trip-with-k-highways/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2248.多个数组求交集",
        "hardRate": "EASY",
        "passRate": "67.13%",
        "problemsUrl": "https://leetcode.cn/problems/intersection-of-multiple-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/intersection-of-multiple-arrays/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 是由 <strong>不同</strong> 正整数组成的一个非空数组，按 <strong>升序排列</strong> 返回一个数组，数组中的每个元素在 <code>nums</code>&nbsp;<strong>所有数组</strong> 中都出现过。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[<em><strong>3</strong></em>,1,2,<em><strong>4</strong></em>,5],[1,2,<em><strong>3</strong></em>,<em><strong>4</strong></em>],[<em><strong>3</strong></em>,<em><strong>4</strong></em>,5,6]]\n<strong>输出：</strong>[3,4]\n<strong>解释：</strong>\nnums[0] = [<em><strong>3</strong></em>,1,2,<em><strong>4</strong></em>,5]，nums[1] = [1,2,<em><strong>3</strong></em>,<em><strong>4</strong></em>]，nums[2] = [<em><strong>3</strong></em>,<em><strong>4</strong></em>,5,6]，在 nums 中每个数组中都出现的数字是 3 和 4 ，所以返回 [3,4] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[1,2,3],[4,5,6]]\n<strong>输出：</strong>[]\n<strong>解释：</strong>\n不存在同时出现在 nums[0] 和 nums[1] 的整数，所以返回一个空列表 [] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= sum(nums[i].length) &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i][j] &lt;= 1000</code></li>\n\t<li><code>nums[i]</code> 中的所有值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2249.统计圆内格点数目",
        "hardRate": "MEDIUM",
        "passRate": "53.33%",
        "problemsUrl": "https://leetcode.cn/problems/count-lattice-points-inside-a-circle/",
        "solutionsUrl": "https://leetcode.cn/problems/count-lattice-points-inside-a-circle/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>circles</code> ，其中 <code>circles[i] = [x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub>]</code> 表示网格上圆心为 <code>(x<sub>i</sub>, y<sub>i</sub>)</code> 且半径为 <code>r<sub>i</sub></code> 的第 <code>i</code> 个圆，返回出现在<strong> 至少一个 </strong>圆内的 <strong>格点数目</strong> 。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><strong>格点</strong> 是指整数坐标对应的点。</li>\n\t<li><strong>圆周上的点</strong> 也被视为出现在圆内的点。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/exa-11.png\" style=\"width: 300px; height: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>circles = [[2,2,1]]\n<strong>输出：</strong>5\n<strong>解释：</strong>\n给定的圆如上图所示。\n出现在圆内的格点为 (1, 2)、(2, 1)、(2, 2)、(2, 3) 和 (3, 2)，在图中用绿色标识。\n像 (1, 1) 和 (1, 3) 这样用红色标识的点，并未出现在圆内。\n因此，出现在至少一个圆内的格点数目是 5 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/exa-22.png\" style=\"width: 300px; height: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>circles = [[2,2,2],[3,4,1]]\n<strong>输出：</strong>16\n<strong>解释：</strong>\n给定的圆如上图所示。\n共有 16 个格点出现在至少一个圆内。\n其中部分点的坐标是 (0, 2)、(2, 0)、(2, 4)、(3, 2) 和 (4, 4) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= circles.length &lt;= 200</code></li>\n\t<li><code>circles[i].length == 3</code></li>\n\t<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 100</code></li>\n\t<li><code>1 &lt;= r<sub>i</sub> &lt;= min(x<sub>i</sub>, y<sub>i</sub>)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2250.统计包含每个点的矩形数目",
        "hardRate": "MEDIUM",
        "passRate": "34.90%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-rectangles-containing-each-point/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-rectangles-containing-each-point/solution",
        "problemsDesc": "<p>给你一个二维整数数组&nbsp;<code>rectangles</code>&nbsp;，其中&nbsp;<code>rectangles[i] = [l<sub>i</sub>, h<sub>i</sub>]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个矩形长为&nbsp;<code>l<sub>i</sub></code>&nbsp;高为&nbsp;<code>h<sub>i</sub></code>&nbsp;。给你一个二维整数数组&nbsp;<code>points</code>&nbsp;，其中&nbsp;<code>points[j] = [x<sub>j</sub>, y<sub>j</sub>]</code>&nbsp;是坐标为&nbsp;<code>(x<sub>j</sub>, y<sub>j</sub>)</code>&nbsp;的一个点。</p>\n\n<p>第&nbsp;<code>i</code>&nbsp;个矩形的 <strong>左下角</strong>&nbsp;在&nbsp;<code>(0, 0)</code>&nbsp;处，<strong>右上角</strong>&nbsp;在&nbsp;<code>(l<sub>i</sub>, h<sub>i</sub>)</code>&nbsp;。</p>\n\n<p>请你返回一个整数数组<em>&nbsp;</em><code>count</code>&nbsp;，长度为&nbsp;<code>points.length</code>，其中<em>&nbsp;</em><code>count[j]</code>是 <strong>包含</strong> 第<em>&nbsp;</em><code>j</code>&nbsp;个点的矩形数目。</p>\n\n<p>如果&nbsp;<code>0 &lt;= x<sub>j</sub> &lt;= l<sub>i</sub></code> 且&nbsp;<code>0 &lt;= y<sub>j</sub> &lt;= h<sub>i</sub></code>&nbsp;，那么我们说第&nbsp;<code>i</code>&nbsp;个矩形包含第&nbsp;<code>j</code>&nbsp;个点。如果一个点刚好在矩形的 <strong>边上</strong>&nbsp;，这个点也被视为被矩形包含。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/example1.png\" style=\"width: 300px; height: 509px;\"></p>\n\n<pre><b>输入：</b>rectangles = [[1,2],[2,3],[2,5]], points = [[2,1],[1,4]]\n<b>输出：</b>[2,1]\n<b>解释：</b>\n第一个矩形不包含任何点。\n第二个矩形只包含一个点 (2, 1) 。\n第三个矩形包含点 (2, 1) 和 (1, 4) 。\n包含点 (2, 1) 的矩形数目为 2 。\n包含点 (1, 4) 的矩形数目为 1 。\n所以，我们返回 [2, 1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/example2.png\" style=\"width: 300px; height: 312px;\"></p>\n\n<pre><b>输入：</b>rectangles = [[1,1],[2,2],[3,3]], points = [[1,3],[1,1]]\n<b>输出：</b>[1,3]\n<strong>解释：\n</strong>第一个矩形只包含点 (1, 1) 。\n第二个矩形只包含点 (1, 1) 。\n第三个矩形包含点 (1, 3) 和 (1, 1) 。\n包含点 (1, 3) 的矩形数目为 1 。\n包含点 (1, 1) 的矩形数目为 3 。\n所以，我们返回 [1, 3] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rectangles.length, points.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>rectangles[i].length == points[j].length == 2</code></li>\n\t<li><code>1 &lt;= l<sub>i</sub>, x<sub>j</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= h<sub>i</sub>, y<sub>j</sub> &lt;= 100</code></li>\n\t<li>所有&nbsp;<code>rectangles</code>&nbsp;<strong>互不相同</strong>&nbsp;。</li>\n\t<li>所有&nbsp;<code>points</code> <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    }
]