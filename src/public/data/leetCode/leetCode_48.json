[
    {
        "problemsName": " 2351.第一个出现两次的字母",
        "hardRate": "EASY",
        "passRate": "84.74%",
        "problemsUrl": "https://leetcode.cn/problems/first-letter-to-appear-twice/",
        "solutionsUrl": "https://leetcode.cn/problems/first-letter-to-appear-twice/solution",
        "problemsDesc": "<p>给你一个由小写英文字母组成的字符串 <code>s</code> ，请你找出并返回第一个出现 <strong>两次</strong> 的字母。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>如果 <code>a</code> 的 <strong>第二次</strong> 出现比 <code>b</code> 的 <strong>第二次</strong> 出现在字符串中的位置更靠前，则认为字母 <code>a</code> 在字母 <code>b</code> 之前出现两次。</li>\n\t<li><code>s</code> 包含至少一个出现两次的字母。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abccbaacz\"\n<strong>输出：</strong>\"c\"\n<strong>解释：</strong>\n字母 'a' 在下标 0 、5 和 6 处出现。\n字母 'b' 在下标 1 和 4 处出现。\n字母 'c' 在下标 2 、3 和 7 处出现。\n字母 'z' 在下标 8 处出现。\n字母 'c' 是第一个出现两次的字母，因为在所有字母中，'c' 第二次出现的下标是最小的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abcdd\"\n<strong>输出：</strong>\"d\"\n<strong>解释：</strong>\n只有字母 'd' 出现两次，所以返回 'd' 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n\t<li><code>s</code> 包含至少一个重复字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2352.相等行列对",
        "hardRate": "MEDIUM",
        "passRate": "73.90%",
        "problemsUrl": "https://leetcode.cn/problems/equal-row-and-column-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/equal-row-and-column-pairs/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>n x n</code> 的整数矩阵 <code>grid</code> ，返回满足 <code>R<sub>i</sub></code><em> </em>行和<em> </em><code>C<sub>j</sub></code><em> </em>列相等的行列对<em> </em><code>(R<sub>i</sub>, C<sub>j</sub>)</code><em> </em>的数目<em>。</em></p>\n\n<p>如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/01/ex1.jpg\" style=\"width: 150px; height: 153px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[3,2,1],[1,7,6],[2,7,7]]\n<strong>输出：</strong>1\n<strong>解释：</strong>存在一对相等行列对：\n- (第 2 行，第 1 列)：[2,7,7]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/01/ex2.jpg\" style=\"width: 200px; height: 209px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]\n<strong>输出：</strong>3\n<strong>解释：</strong>存在三对相等行列对：\n- (第 0 行，第 0 列)：[3,1,2,2]\n- (第 2 行, 第 2 列)：[2,4,2,2]\n- (第 3 行, 第 2 列)：[2,4,2,2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2353.设计食物评分系统",
        "hardRate": "MEDIUM",
        "passRate": "30.73%",
        "problemsUrl": "https://leetcode.cn/problems/design-a-food-rating-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-a-food-rating-system/solution",
        "problemsDesc": "<p>设计一个支持下述操作的食物评分系统：</p>\n\n<ul>\n\t<li><strong>修改</strong> 系统中列出的某种食物的评分。</li>\n\t<li>返回系统中某一类烹饪方式下评分最高的食物。</li>\n</ul>\n\n<p>实现 <code>FoodRatings</code> 类：</p>\n\n<ul>\n\t<li><code>FoodRatings(String[] foods, String[] cuisines, int[] ratings)</code> 初始化系统。食物由 <code>foods</code>、<code>cuisines</code> 和 <code>ratings</code> 描述，长度均为 <code>n</code> 。\n\n\t<ul>\n\t\t<li><code>foods[i]</code> 是第 <code>i</code> 种食物的名字。</li>\n\t\t<li><code>cuisines[i]</code> 是第 <code>i</code> 种食物的烹饪方式。</li>\n\t\t<li><code>ratings[i]</code> 是第 <code>i</code> 种食物的最初评分。</li>\n\t</ul>\n\t</li>\n\t<li><code>void changeRating(String food, int newRating)</code> 修改名字为 <code>food</code> 的食物的评分。</li>\n\t<li><code>String highestRated(String cuisine)</code> 返回指定烹饪方式 <code>cuisine</code> 下评分最高的食物的名字。如果存在并列，返回 <strong>字典序较小</strong> 的名字。</li>\n</ul>\n\n<p>注意，字符串 <code>x</code> 的字典序比字符串 <code>y</code> 更小的前提是：<code>x</code> 在字典中出现的位置在 <code>y</code> 之前，也就是说，要么 <code>x</code> 是 <code>y</code> 的前缀，或者在满足&nbsp;<code>x[i] != y[i]</code> 的第一个位置 <code>i</code> 处，<code>x[i]</code> 在字母表中出现的位置在 <code>y[i]</code> 之前。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入</strong>\n[\"FoodRatings\", \"highestRated\", \"highestRated\", \"changeRating\", \"highestRated\", \"changeRating\", \"highestRated\"]\n[[[\"kimchi\", \"miso\", \"sushi\", \"moussaka\", \"ramen\", \"bulgogi\"], [\"korean\", \"japanese\", \"japanese\", \"greek\", \"japanese\", \"korean\"], [9, 12, 8, 15, 14, 7]], [\"korean\"], [\"japanese\"], [\"sushi\", 16], [\"japanese\"], [\"ramen\", 16], [\"japanese\"]]\n<strong>输出</strong>\n[null, \"kimchi\", \"ramen\", null, \"sushi\", null, \"ramen\"]\n\n<strong>解释</strong>\nFoodRatings foodRatings = new FoodRatings([\"kimchi\", \"miso\", \"sushi\", \"moussaka\", \"ramen\", \"bulgogi\"], [\"korean\", \"japanese\", \"japanese\", \"greek\", \"japanese\", \"korean\"], [9, 12, 8, 15, 14, 7]);\nfoodRatings.highestRated(\"korean\"); // 返回 \"kimchi\"\n                                    // \"kimchi\" 是分数最高的韩式料理，评分为 9 。\nfoodRatings.highestRated(\"japanese\"); // 返回 \"ramen\"\n                                      // \"ramen\" 是分数最高的日式料理，评分为 14 。\nfoodRatings.changeRating(\"sushi\", 16); // \"sushi\" 现在评分变更为 16 。\nfoodRatings.highestRated(\"japanese\"); // 返回 \"sushi\"\n                                      // \"sushi\" 是分数最高的日式料理，评分为 16 。\nfoodRatings.changeRating(\"ramen\", 16); // \"ramen\" 现在评分变更为 16 。\nfoodRatings.highestRated(\"japanese\"); // 返回 \"ramen\"\n                                      // \"sushi\" 和 \"ramen\" 的评分都是 16 。\n                                      // 但是，\"ramen\" 的字典序比 \"sushi\" 更小。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>n == foods.length == cuisines.length == ratings.length</code></li>\n\t<li><code>1 &lt;= foods[i].length, cuisines[i].length &lt;= 10</code></li>\n\t<li><code>foods[i]</code>、<code>cuisines[i]</code> 由小写英文字母组成</li>\n\t<li><code>1 &lt;= ratings[i] &lt;= 10<sup>8</sup></code></li>\n\t<li><code>foods</code> 中的所有字符串 <strong>互不相同</strong></li>\n\t<li>在对&nbsp;<code>changeRating</code> 的所有调用中，<code>food</code> 是系统中食物的名字。</li>\n\t<li>在对&nbsp;<code>highestRated</code> 的所有调用中，<code>cuisine</code> 是系统中 <strong>至少一种</strong> 食物的烹饪方式。</li>\n\t<li>最多调用 <code>changeRating</code> 和 <code>highestRated</code> <strong>总计</strong> <code>2 * 10<sup>4</sup></code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2354.优质数对的数目",
        "hardRate": "HARD",
        "passRate": "44.61%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-excellent-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-excellent-pairs/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的正整数数组 <code>nums</code> 和一个正整数 <code>k</code> 。</p>\n\n<p>如果满足下述条件，则数对 <code>(num1, num2)</code> 是 <strong>优质数对</strong> ：</p>\n\n<ul>\n\t<li><code>num1</code> 和 <code>num2</code> <strong>都</strong> 在数组 <code>nums</code> 中存在。</li>\n\t<li><code>num1 OR num2</code> 和 <code>num1 AND num2</code> 的二进制表示中值为 <strong>1</strong> 的位数之和大于等于 <code>k</code> ，其中 <code>OR</code> 是按位 <strong>或</strong> 操作，而 <code>AND</code> 是按位 <strong>与</strong> 操作。</li>\n</ul>\n\n<p>返回 <strong>不同</strong> 优质数对的数目。</p>\n\n<p>如果&nbsp;<code>a != c</code> 或者 <code>b != d</code> ，则认为 <code>(a, b)</code> 和 <code>(c, d)</code> 是不同的两个数对。例如，<code>(1, 2)</code> 和 <code>(2, 1)</code> 不同。</p>\n\n<p><strong>注意：</strong>如果 <code>num1</code> 在数组中至少出现 <strong>一次</strong> ，则满足 <code>num1 == num2</code> 的数对 <code>(num1, num2)</code> 也可以是优质数对。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,1], k = 3\n<strong>输出：</strong>5\n<strong>解释：</strong>有如下几个优质数对：\n- (3, 3)：(3 AND 3) 和 (3 OR 3) 的二进制表示都等于 (11) 。值为 1 的位数和等于 2 + 2 = 4 ，大于等于 k = 3 。\n- (2, 3) 和 (3, 2)： (2 AND 3) 的二进制表示等于 (10) ，(2 OR 3) 的二进制表示等于 (11) 。值为 1 的位数和等于 1 + 2 = 3 。\n- (1, 3) 和 (3, 1)： (1 AND 3) 的二进制表示等于 (01) ，(1 OR 3) 的二进制表示等于 (11) 。值为 1 的位数和等于 1 + 2 = 3 。\n所以优质数对的数目是 5 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,1,1], k = 10\n<strong>输出：</strong>0\n<strong>解释：</strong>该数组中不存在优质数对。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 60</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2355.你能拿走的最大图书数量",
        "hardRate": "HARD",
        "passRate": "58.99%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-books-you-can-take/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-books-you-can-take/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2356.每位教师所教授的科目种类的数量",
        "hardRate": "EASY",
        "passRate": "81.19%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-unique-subjects-taught-by-each-teacher/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-unique-subjects-taught-by-each-teacher/solution",
        "problemsDesc": "<p>表: <code>Teacher</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| teacher_id  | int  |\n| subject_id  | int  |\n| dept_id     | int  |\n+-------------+------+\n(subject_id, dept_id) 是该表的主键。\n该表中的每一行都表示带有 teacher_id 的教师在系 dept_id 中教授科目 subject_id。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一个 SQL 来查询每位老师在大学里教授的科目种类的数量。</p>\n\n<p data-group=\"1-1\">以 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式示例如下。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nTeacher 表:\n+------------+------------+---------+\n| teacher_id | subject_id | dept_id |\n+------------+------------+---------+\n| 1          | 2          | 3       |\n| 1          | 2          | 4       |\n| 1          | 3          | 3       |\n| 2          | 1          | 1       |\n| 2          | 2          | 1       |\n| 2          | 3          | 1       |\n| 2          | 4          | 1       |\n+------------+------------+---------+\n<strong>输出:</strong>  \n+------------+-----+\n| teacher_id | cnt |\n+------------+-----+\n| 1          | 2   |\n| 2          | 4   |\n+------------+-----+\n<strong>解释:</strong> \n教师 1:\n  - 他在 3、4 系教科目 2。\n  - 他在 3 系教科目 3。\n教师 2:\n  - 他在 1 系教科目 1。\n  - 他在 1 系教科目 2。\n  - 他在 1 系教科目 3。\n  - 他在 1 系教科目 4。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2357.使数组中所有元素都等于零",
        "hardRate": "EASY",
        "passRate": "75.87%",
        "problemsUrl": "https://leetcode.cn/problems/make-array-zero-by-subtracting-equal-amounts/",
        "solutionsUrl": "https://leetcode.cn/problems/make-array-zero-by-subtracting-equal-amounts/solution",
        "problemsDesc": "<p>给你一个非负整数数组 <code>nums</code> 。在一步操作中，你必须：</p>\n\n<ul>\n\t<li>选出一个正整数 <code>x</code> ，<code>x</code> 需要小于或等于 <code>nums</code> 中 <strong>最小</strong> 的 <strong>非零</strong> 元素。</li>\n\t<li><code>nums</code> 中的每个正整数都减去 <code>x</code>。</li>\n</ul>\n\n<p>返回使 <code>nums</code> 中所有元素都等于<em> </em><code>0</code> 需要的 <strong>最少</strong> 操作数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5,0,3,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n第一步操作：选出 x = 1 ，之后 nums = [0,4,0,2,4] 。\n第二步操作：选出 x = 2 ，之后 nums = [0,2,0,0,2] 。\n第三步操作：选出 x = 2 ，之后 nums = [0,0,0,0,0] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>0\n<strong>解释：</strong>nums 中的每个元素都已经是 0 ，所以不需要执行任何操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2358.分组的最大数量",
        "hardRate": "MEDIUM",
        "passRate": "64.31%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-groups-entering-a-competition/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-groups-entering-a-competition/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>grades</code> ，表示大学中一些学生的成绩。你打算将 <strong>所有</strong> 学生分为一些 <strong>有序</strong> 的非空分组，其中分组间的顺序满足以下全部条件：</p>\n\n<ul>\n\t<li>第 <code>i</code> 个分组中的学生总成绩 <strong>小于</strong> 第 <code>(i + 1)</code> 个分组中的学生总成绩，对所有组均成立（除了最后一组）。</li>\n\t<li>第 <code>i</code> 个分组中的学生总数 <strong>小于</strong> 第 <code>(i + 1)</code> 个分组中的学生总数，对所有组均成立（除了最后一组）。</li>\n</ul>\n\n<p>返回可以形成的 <strong>最大</strong> 组数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>grades = [10,6,12,7,3,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>下面是形成 3 个分组的一种可行方法：\n- 第 1 个分组的学生成绩为 grades = [12] ，总成绩：12 ，学生数：1\n- 第 2 个分组的学生成绩为 grades = [6,7] ，总成绩：6 + 7 = 13 ，学生数：2\n- 第 3 个分组的学生成绩为 grades = [10,3,5] ，总成绩：10 + 3 + 5 = 18 ，学生数：3 \n可以证明无法形成超过 3 个分组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>grades = [8,8]\n<strong>输出：</strong>1\n<strong>解释：</strong>只能形成 1 个分组，因为如果要形成 2 个分组的话，会导致每个分组中的学生数目相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= grades.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= grades[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2359.找到离给定两个节点最近的节点",
        "hardRate": "MEDIUM",
        "passRate": "30.31%",
        "problemsUrl": "https://leetcode.cn/problems/find-closest-node-to-given-two-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/find-closest-node-to-given-two-nodes/solution",
        "problemsDesc": "<p>给你一个 <code>n</code>&nbsp;个节点的 <strong>有向图</strong>&nbsp;，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，每个节点 <strong>至多</strong>&nbsp;有一条出边。</p>\n\n<p>有向图用大小为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>edges</code>&nbsp;表示，表示节点&nbsp;<code>i</code>&nbsp;有一条有向边指向&nbsp;<code>edges[i]</code>&nbsp;。如果节点&nbsp;<code>i</code>&nbsp;没有出边，那么&nbsp;<code>edges[i] == -1</code>&nbsp;。</p>\n\n<p>同时给你两个节点&nbsp;<code>node1</code> 和&nbsp;<code>node2</code>&nbsp;。</p>\n\n<p>请你返回一个从 <code>node1</code>&nbsp;和 <code>node2</code>&nbsp;都能到达节点的编号，使节点 <code>node1</code>&nbsp;和节点 <code>node2</code>&nbsp;到这个节点的距离 <b>较大值最小化</b>。如果有多个答案，请返回 <strong>最小</strong>&nbsp;的节点编号。如果答案不存在，返回 <code>-1</code>&nbsp;。</p>\n\n<p>注意&nbsp;<code>edges</code>&nbsp;可能包含环。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-2.png\" style=\"width: 321px; height: 161px;\"></p>\n\n<pre><b>输入：</b>edges = [2,2,3,-1], node1 = 0, node2 = 1\n<b>输出：</b>2\n<b>解释：</b>从节点 0 到节点 2 的距离为 1 ，从节点 1 到节点 2 的距离为 1 。\n两个距离的较大值为 1 。我们无法得到一个比 1 更小的较大值，所以我们返回节点 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-4.png\" style=\"width: 195px; height: 161px;\"></p>\n\n<pre><b>输入：</b>edges = [1,2,-1], node1 = 0, node2 = 2\n<b>输出：</b>2\n<b>解释：</b>节点 0 到节点 2 的距离为 2 ，节点 2 到它自己的距离为 0 。\n两个距离的较大值为 2 。我们无法得到一个比 2 更小的较大值，所以我们返回节点 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-1 &lt;= edges[i] &lt; n</code></li>\n\t<li><code>edges[i] != i</code></li>\n\t<li><code>0 &lt;= node1, node2 &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2360.图中的最长环",
        "hardRate": "HARD",
        "passRate": "38.08%",
        "problemsUrl": "https://leetcode.cn/problems/longest-cycle-in-a-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-cycle-in-a-graph/solution",
        "problemsDesc": "<p>给你一个 <code>n</code>&nbsp;个节点的 <b>有向图</b>&nbsp;，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，其中每个节点&nbsp;<strong>至多</strong>&nbsp;有一条出边。</p>\n\n<p>图用一个大小为 <code>n</code>&nbsp;下标从<strong>&nbsp;0</strong>&nbsp;开始的数组&nbsp;<code>edges</code>&nbsp;表示，节点 <code>i</code>&nbsp;到节点&nbsp;<code>edges[i]</code>&nbsp;之间有一条有向边。如果节点&nbsp;<code>i</code>&nbsp;没有出边，那么&nbsp;<code>edges[i] == -1</code>&nbsp;。</p>\n\n<p>请你返回图中的 <strong>最长</strong>&nbsp;环，如果没有任何环，请返回 <code>-1</code>&nbsp;。</p>\n\n<p>一个环指的是起点和终点是 <strong>同一个</strong>&nbsp;节点的路径。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/08/graph4drawio-5.png\" style=\"width: 335px; height: 191px;\" /></p>\n\n<pre>\n<b>输入：</b>edges = [3,3,4,2,3]\n<b>输出去：</b>3\n<b>解释：</b>图中的最长环是：2 -&gt; 4 -&gt; 3 -&gt; 2 。\n这个环的长度为 3 ，所以返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-1.png\" style=\"width: 171px; height: 161px;\" /></p>\n\n<pre>\n<b>输入：</b>edges = [2,-1,3,1]\n<b>输出：</b>-1\n<b>解释：</b>图中没有任何环。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-1 &lt;= edges[i] &lt; n</code></li>\n\t<li><code>edges[i] != i</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2361.乘坐火车路线的最少费用",
        "hardRate": "HARD",
        "passRate": "78.21%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-costs-using-the-train-line/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-costs-using-the-train-line/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2362.生成发票",
        "hardRate": "HARD",
        "passRate": "73.11%",
        "problemsUrl": "https://leetcode.cn/problems/generate-the-invoice/",
        "solutionsUrl": "https://leetcode.cn/problems/generate-the-invoice/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2363.合并相似的物品",
        "hardRate": "EASY",
        "passRate": "78.18%",
        "problemsUrl": "https://leetcode.cn/problems/merge-similar-items/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-similar-items/solution",
        "problemsDesc": "<p>给你两个二维整数数组&nbsp;<code>items1</code> 和&nbsp;<code>items2</code>&nbsp;，表示两个物品集合。每个数组&nbsp;<code>items</code>&nbsp;有以下特质：</p>\n\n<ul>\n\t<li><code>items[i] = [value<sub>i</sub>, weight<sub>i</sub>]</code> 其中&nbsp;<code>value<sub>i</sub></code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;件物品的&nbsp;<strong>价值</strong>&nbsp;，<code>weight<sub>i</sub></code>&nbsp;表示第 <code>i</code>&nbsp;件物品的 <strong>重量</strong>&nbsp;。</li>\n\t<li><code>items</code>&nbsp;中每件物品的价值都是 <strong>唯一的</strong>&nbsp;。</li>\n</ul>\n\n<p>请你返回一个二维数组&nbsp;<code>ret</code>，其中&nbsp;<code>ret[i] = [value<sub>i</sub>, weight<sub>i</sub>]</code>，&nbsp;<code>weight<sub>i</sub></code>&nbsp;是所有价值为&nbsp;<code>value<sub>i</sub></code><sub>&nbsp;</sub>物品的&nbsp;<strong>重量之和</strong>&nbsp;。</p>\n\n<p><strong>注意：</strong><code>ret</code>&nbsp;应该按价值 <strong>升序</strong>&nbsp;排序后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]]\n<b>输出：</b>[[1,6],[3,9],[4,5]]\n<b>解释：</b>\nvalue = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 5 ，总重量为 1 + 5 = 6 。\nvalue = 3 的物品再 items1 中 weight = 8 ，在 items2 中 weight = 1 ，总重量为 8 + 1 = 9 。\nvalue = 4 的物品在 items1 中 weight = 5 ，总重量为 5 。\n所以，我们返回 [[1,6],[3,9],[4,5]] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]]\n<b>输出：</b>[[1,4],[2,4],[3,4]]\n<b>解释：</b>\nvalue = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 3 ，总重量为 1 + 3 = 4 。\nvalue = 2 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 1 ，总重量为 3 + 1 = 4 。\nvalue = 3 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。\n所以，我们返回 [[1,4],[2,4],[3,4]] 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]]\n<b>输出：</b>[[1,7],[2,4],[7,1]]\n<strong>解释：\n</strong>value = 1 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 4 ，总重量为 3 + 4 = 7 。\nvalue = 2 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。\nvalue = 7 的物品在 items2 中 weight = 1 ，总重量为 1 。\n所以，我们返回 [[1,7],[2,4],[7,1]] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= items1.length, items2.length &lt;= 1000</code></li>\n\t<li><code>items1[i].length == items2[i].length == 2</code></li>\n\t<li><code>1 &lt;= value<sub>i</sub>, weight<sub>i</sub> &lt;= 1000</code></li>\n\t<li><code>items1</code>&nbsp;中每个 <code>value<sub>i</sub></code>&nbsp;都是 <b>唯一的</b>&nbsp;。</li>\n\t<li><code>items2</code>&nbsp;中每个 <code>value<sub>i</sub></code>&nbsp;都是 <b>唯一的</b>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2364.统计坏数对的数目",
        "hardRate": "MEDIUM",
        "passRate": "42.28%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-bad-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-bad-pairs/solution",
        "problemsDesc": "<p>给你一个下标从<strong>&nbsp;0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。如果 <code>i &lt; j</code>&nbsp;且&nbsp;<code>j - i != nums[j] - nums[i]</code>&nbsp;，那么我们称&nbsp;<code>(i, j)</code>&nbsp;是一个 <strong>坏</strong><strong>数对</strong>&nbsp;。</p>\n\n<p>请你返回 <code>nums</code>&nbsp;中 <strong>坏数对</strong>&nbsp;的总数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [4,1,3,3]\n<b>输出：</b>5\n<b>解释：</b>数对 (0, 1) 是坏数对，因为 1 - 0 != 1 - 4 。\n数对 (0, 2) 是坏数对，因为 2 - 0 != 3 - 4, 2 != -1 。\n数对 (0, 3) 是坏数对，因为 3 - 0 != 3 - 4, 3 != -1 。\n数对 (1, 2) 是坏数对，因为 2 - 1 != 3 - 1, 1 != 2 。\n数对 (2, 3) 是坏数对，因为 3 - 2 != 3 - 3, 1 != 0 。\n总共有 5 个坏数对，所以我们返回 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4,5]\n<b>输出：</b>0\n<strong>解释：</strong>没有坏数对。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2365.任务调度器 II",
        "hardRate": "MEDIUM",
        "passRate": "48.04%",
        "problemsUrl": "https://leetcode.cn/problems/task-scheduler-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/task-scheduler-ii/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的正整数数组&nbsp;<code>tasks</code>&nbsp;，表示需要 <strong>按顺序</strong>&nbsp;完成的任务，其中&nbsp;<code>tasks[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;件任务的 <strong>类型</strong>&nbsp;。</p>\n\n<p>同时给你一个正整数&nbsp;<code>space</code>&nbsp;，表示一个任务完成&nbsp;<strong>后</strong>&nbsp;，另一个&nbsp;<strong>相同</strong>&nbsp;类型任务完成前需要间隔的&nbsp;<strong>最少</strong>&nbsp;天数。</p>\n\n<p>在所有任务完成前的每一天，你都必须进行以下两种操作中的一种：</p>\n\n<ul>\n\t<li>完成&nbsp;<code>tasks</code>&nbsp;中的下一个任务</li>\n\t<li>休息一天</li>\n</ul>\n\n<p>请你返回完成所有任务所需的 <strong>最少</strong>&nbsp;天数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>tasks = [1,2,1,2,3,1], space = 3\n<b>输出：</b>9\n<strong>解释：</strong>\n9 天完成所有任务的一种方法是：\n第 1 天：完成任务 0 。\n第 2 天：完成任务 1 。\n第 3 天：休息。\n第 4 天：休息。\n第 5 天：完成任务 2 。\n第 6 天：完成任务 3 。\n第 7 天：休息。\n第 8 天：完成任务 4 。\n第 9 天：完成任务 5 。\n可以证明无法少于 9 天完成所有任务。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>tasks = [5,8,8,5], space = 2\n<b>输出：</b>6\n<strong>解释：</strong>\n6 天完成所有任务的一种方法是：\n第 1 天：完成任务 0 。\n第 2 天：完成任务 1 。\n第 3 天：休息。\n第 4 天：休息。\n第 5 天：完成任务 2 。\n第 6 天：完成任务 3 。\n可以证明无法少于 6 天完成所有任务。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tasks.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= tasks[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= space &lt;= tasks.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2366.将数组排序的最少替换次数",
        "hardRate": "HARD",
        "passRate": "42.76%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-replacements-to-sort-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-replacements-to-sort-the-array/solution",
        "problemsDesc": "<p>给你一个下表从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。每次操作中，你可以将数组中任何一个元素替换为&nbsp;<strong>任意两个</strong>&nbsp;和为该元素的数字。</p>\n\n<ul>\n\t<li>比方说，<code>nums = [5,6,7]</code>&nbsp;。一次操作中，我们可以将&nbsp;<code>nums[1]</code> 替换成&nbsp;<code>2</code> 和&nbsp;<code>4</code>&nbsp;，将&nbsp;<code>nums</code>&nbsp;转变成&nbsp;<code>[5,2,4,7]</code>&nbsp;。</li>\n</ul>\n\n<p>请你执行上述操作，将数组变成元素按 <strong>非递减</strong> 顺序排列的数组，并返回所需的最少操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,9,3]\n<b>输出：</b>2\n<b>解释：</b>以下是将数组变成非递减顺序的步骤：\n- [3,9,3] ，将9 变成 3 和 6 ，得到数组 [3,3,6,3] \n- [3,3,6,3] ，将 6 变成 3 和 3 ，得到数组 [3,3,3,3,3] \n总共需要 2 步将数组变成非递减有序，所以我们返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4,5]\n<b>输出：</b>0\n<b>解释：</b>数组已经是非递减顺序，所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2367.算术三元组的数目",
        "hardRate": "EASY",
        "passRate": "83.38%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-arithmetic-triplets/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-arithmetic-triplets/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、<strong>严格递增</strong> 的整数数组 <code>nums</code> 和一个正整数 <code>diff</code> 。如果满足下述全部条件，则三元组 <code>(i, j, k)</code> 就是一个 <strong>算术三元组</strong> ：</p>\n\n<ul>\n\t<li><code>i &lt; j &lt; k</code> ，</li>\n\t<li><code>nums[j] - nums[i] == diff</code> 且</li>\n\t<li><code>nums[k] - nums[j] == diff</code></li>\n</ul>\n\n<p>返回不同 <strong>算术三元组</strong> 的数目<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,4,6,7,10], diff = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>\n(1, 2, 4) 是算术三元组：7 - 4 == 3 且 4 - 1 == 3 。\n(2, 4, 5) 是算术三元组：10 - 7 == 3 且 7 - 4 == 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,5,6,7,8,9], diff = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>\n(0, 2, 4) 是算术三元组：8 - 6 == 2 且 6 - 4 == 2 。\n(1, 3, 5) 是算术三元组：9 - 7 == 2 且 7 - 5 == 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 200</code></li>\n\t<li><code>1 &lt;= diff &lt;= 50</code></li>\n\t<li><code>nums</code> <strong>严格</strong> 递增</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2368.受限条件下可到达节点的数目",
        "hardRate": "MEDIUM",
        "passRate": "46.13%",
        "problemsUrl": "https://leetcode.cn/problems/reachable-nodes-with-restrictions/",
        "solutionsUrl": "https://leetcode.cn/problems/reachable-nodes-with-restrictions/solution",
        "problemsDesc": "<p>现有一棵由 <code>n</code> 个节点组成的无向树，节点编号从 <code>0</code> 到 <code>n - 1</code> ，共有 <code>n - 1</code> 条边。</p>\n\n<p>给你一个二维整数数组 <code>edges</code> ，长度为 <code>n - 1</code> ，其中 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示树中节点 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间存在一条边。另给你一个整数数组 <code>restricted</code> 表示 <strong>受限</strong> 节点。</p>\n\n<p>在不访问受限节点的前提下，返回你可以从节点<em> </em><code>0</code><em> </em>到达的 <strong>最多</strong> 节点数目<em>。</em></p>\n\n<p>注意，节点 <code>0</code> <strong>不</strong> 会标记为受限节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/15/ex1drawio.png\" style=\"width: 402px; height: 322px;\">\n<pre><strong>输入：</strong>n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>上图所示正是这棵树。\n在不访问受限节点的前提下，只有节点 [0,1,2,3] 可以从节点 0 到达。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/15/ex2drawio.png\" style=\"width: 412px; height: 312px;\">\n<pre><strong>输入：</strong>n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>上图所示正是这棵树。\n在不访问受限节点的前提下，只有节点 [0,5,6] 可以从节点 0 到达。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>edges</code> 表示一棵有效的树</li>\n\t<li><code>1 &lt;= restricted.length &lt; n</code></li>\n\t<li><code>1 &lt;= restricted[i] &lt; n</code></li>\n\t<li><code>restricted</code> 中的所有值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2369.检查数组是否存在有效划分",
        "hardRate": "MEDIUM",
        "passRate": "38.51%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，你必须将数组划分为一个或多个 <strong>连续</strong> 子数组。</p>\n\n<p>如果获得的这些子数组中每个都能满足下述条件<strong> 之一</strong> ，则可以称其为数组的一种 <strong>有效</strong> 划分：</p>\n\n<ol>\n\t<li>子数组 <strong>恰</strong> 由 <code>2</code> 个相等元素组成，例如，子数组 <code>[2,2]</code> 。</li>\n\t<li>子数组 <strong>恰</strong> 由 <code>3</code> 个相等元素组成，例如，子数组 <code>[4,4,4]</code> 。</li>\n\t<li>子数组 <strong>恰</strong> 由 <code>3</code> 个连续递增元素组成，并且相邻元素之间的差值为 <code>1</code> 。例如，子数组 <code>[3,4,5]</code> ，但是子数组 <code>[1,3,5]</code> 不符合要求。</li>\n</ol>\n\n<p>如果数组 <strong>至少</strong> 存在一种有效划分，返回 <code>true</code><em> </em>，否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,4,4,5,6]\n<strong>输出：</strong>true\n<strong>解释：</strong>数组可以划分成子数组 [4,4] 和 [4,5,6] 。\n这是一种有效划分，所以返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,2]\n<strong>输出：</strong>false\n<strong>解释：</strong>该数组不存在有效划分。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2370.最长理想子序列",
        "hardRate": "MEDIUM",
        "passRate": "43.16%",
        "problemsUrl": "https://leetcode.cn/problems/longest-ideal-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-ideal-subsequence/solution",
        "problemsDesc": "<p>给你一个由小写字母组成的字符串 <code>s</code> ，和一个整数 <code>k</code> 。如果满足下述条件，则可以将字符串 <code>t</code> 视作是 <strong>理想字符串</strong> ：</p>\n\n<ul>\n\t<li><code>t</code> 是字符串 <code>s</code> 的一个子序列。</li>\n\t<li><code>t</code> 中每两个 <strong>相邻</strong> 字母在字母表中位次的绝对差值小于或等于 <code>k</code> 。</li>\n</ul>\n\n<p>返回 <strong>最长</strong> 理想字符串的长度。</p>\n\n<p>字符串的子序列同样是一个字符串，并且子序列还满足：可以经由其他字符串删除某些字符（也可以不删除）但不改变剩余字符的顺序得到。</p>\n\n<p><strong>注意：</strong>字母表顺序不会循环。例如，<code>'a'</code> 和 <code>'z'</code> 在字母表中位次的绝对差值是 <code>25</code> ，而不是 <code>1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"acfgbd\", k = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>最长理想字符串是 \"acbd\" 。该字符串长度为 4 ，所以返回 4 。\n注意 \"acfgbd\" 不是理想字符串，因为 'c' 和 'f' 的字母表位次差值为 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\", k = 3\n<strong>输出：</strong>4\n<strong>解释：</strong>最长理想字符串是 \"abcd\" ，该字符串长度为 4 ，所以返回 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 25</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2371.最小化网格中的最大值",
        "hardRate": "HARD",
        "passRate": "74.28%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-maximum-value-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-maximum-value-in-a-grid/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2372.计算每个销售人员的影响力",
        "hardRate": "MEDIUM",
        "passRate": "78.02%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-the-influence-of-each-salesperson/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-the-influence-of-each-salesperson/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2373.矩阵中的局部最大值",
        "hardRate": "EASY",
        "passRate": "85.15%",
        "problemsUrl": "https://leetcode.cn/problems/largest-local-values-in-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-local-values-in-a-matrix/solution",
        "problemsDesc": "<p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>grid</code> 。</p>\n\n<p>生成一个大小为&nbsp;<code>(n - 2) x (n - 2)</code> 的整数矩阵&nbsp; <code>maxLocal</code> ，并满足：</p>\n\n<ul>\n\t<li><code>maxLocal[i][j]</code> 等于 <code>grid</code> 中以 <code>i + 1</code> 行和 <code>j + 1</code> 列为中心的 <code>3 x 3</code> 矩阵中的 <strong>最大值</strong> 。</li>\n</ul>\n\n<p>换句话说，我们希望找出 <code>grid</code> 中每个&nbsp;<code>3 x 3</code> 矩阵中的最大值。</p>\n\n<p>返回生成的矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/21/ex1.png\" style=\"width: 371px; height: 210px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]\n<strong>输出：</strong>[[9,9],[8,6]]\n<strong>解释：</strong>原矩阵和生成的矩阵如上图所示。\n注意，生成的矩阵中，每个值都对应 grid 中一个相接的 3 x 3 矩阵的最大值。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/02/ex2new2.png\" style=\"width: 436px; height: 240px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]\n<strong>输出：</strong>[[2,2,2],[2,2,2],[2,2,2]]\n<strong>解释：</strong>注意，2 包含在 grid 中每个 3 x 3 的矩阵中。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>3 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2374.边积分最高的节点",
        "hardRate": "MEDIUM",
        "passRate": "42.34%",
        "problemsUrl": "https://leetcode.cn/problems/node-with-highest-edge-score/",
        "solutionsUrl": "https://leetcode.cn/problems/node-with-highest-edge-score/solution",
        "problemsDesc": "<p>给你一个有向图，图中有 <code>n</code> 个节点，节点编号从 <code>0</code> 到 <code>n - 1</code> ，其中每个节点都 <strong>恰有一条</strong> 出边。</p>\n\n<p>图由一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>edges</code> 表示，其中 <code>edges[i]</code> 表示存在一条从节点 <code>i</code> 到节点 <code>edges[i]</code> 的 <strong>有向</strong> 边。</p>\n\n<p>节点 <code>i</code> 的 <strong>边积分</strong> 定义为：所有存在一条指向节点 <code>i</code> 的边的节点的 <strong>编号</strong> 总和。</p>\n\n<p>返回 <strong>边积分</strong> 最高的节点。如果多个节点的 <strong>边积分</strong> 相同，返回编号 <strong>最小</strong> 的那个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/06/20/image-20220620195403-1.png\" style=\"width: 450px; height: 260px;\">\n<pre><strong>输入：</strong>edges = [1,0,0,0,0,7,7,5]\n<strong>输出：</strong>7\n<strong>解释：</strong>\n- 节点 1、2、3 和 4 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 + 3 + 4 = 10 。\n- 节点 0 有一条指向节点 1 的边，节点 1 的边积分等于 0 。\n- 节点 7 有一条指向节点 5 的边，节点 5 的边积分等于 7 。\n- 节点 5 和 6 都有指向节点 7 的边，节点 7 的边积分等于 5 + 6 = 11 。\n节点 7 的边积分最高，所以返回 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/06/20/image-20220620200212-3.png\" style=\"width: 150px; height: 155px;\">\n<pre><strong>输入：</strong>edges = [2,0,0,2]\n<strong>输出：</strong>0\n<strong>解释：\n</strong>- 节点 1 和 2 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 = 3 。\n- 节点 0 和 3 都有指向节点 2 的边，节点 2 的边积分等于 0 + 3 = 3 。\n节点 0 和 2 的边积分都是 3 。由于节点 0 的编号更小，返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= edges[i] &lt; n</code></li>\n\t<li><code>edges[i] != i</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2375.根据模式串构造最小数字",
        "hardRate": "MEDIUM",
        "passRate": "70.03%",
        "problemsUrl": "https://leetcode.cn/problems/construct-smallest-number-from-di-string/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-smallest-number-from-di-string/solution",
        "problemsDesc": "<p>给你下标从 <strong>0</strong> 开始、长度为 <code>n</code>&nbsp;的字符串&nbsp;<code>pattern</code>&nbsp;，它包含两种字符，<code>'I'</code>&nbsp;表示 <strong>上升</strong>&nbsp;，<code>'D'</code>&nbsp;表示 <strong>下降</strong>&nbsp;。</p>\n\n<p>你需要构造一个下标从 <strong>0</strong>&nbsp;开始长度为&nbsp;<code>n + 1</code>&nbsp;的字符串，且它要满足以下条件：</p>\n\n<ul>\n\t<li><code>num</code>&nbsp;包含数字&nbsp;<code>'1'</code>&nbsp;到&nbsp;<code>'9'</code>&nbsp;，其中每个数字&nbsp;<strong>至多</strong>&nbsp;使用一次。</li>\n\t<li>如果&nbsp;<code>pattern[i] == 'I'</code>&nbsp;，那么&nbsp;<code>num[i] &lt; num[i + 1]</code>&nbsp;。</li>\n\t<li>如果&nbsp;<code>pattern[i] == 'D'</code>&nbsp;，那么&nbsp;<code>num[i] &gt; num[i + 1]</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回满足上述条件字典序 <strong>最小</strong>&nbsp;的字符串<em>&nbsp;</em><code>num</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>pattern = \"IIIDIDDD\"\n<b>输出：</b>\"123549876\"\n<strong>解释：\n</strong>下标 0 ，1 ，2 和 4 处，我们需要使 num[i] &lt; num[i+1] 。\n下标 3 ，5 ，6 和 7 处，我们需要使 num[i] &gt; num[i+1] 。\n一些可能的 num 的值为 \"245639871\" ，\"135749862\" 和 \"123849765\" 。\n\"123549876\" 是满足条件最小的数字。\n注意，\"123414321\" 不是可行解因为数字 '1' 使用次数超过 1 次。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>pattern = \"DDD\"\n<b>输出：</b>\"4321\"\n<strong>解释：</strong>\n一些可能的 num 的值为 \"9876\" ，\"7321\" 和 \"8742\" 。\n\"4321\" 是满足条件最小的数字。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pattern.length &lt;= 8</code></li>\n\t<li><code>pattern</code>&nbsp;只包含字符&nbsp;<code>'I'</code> 和&nbsp;<code>'D'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2376.统计特殊整数",
        "hardRate": "HARD",
        "passRate": "51.75%",
        "problemsUrl": "https://leetcode.cn/problems/count-special-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/count-special-integers/solution",
        "problemsDesc": "<p>如果一个正整数每一个数位都是 <strong>互不相同</strong>&nbsp;的，我们称它是 <strong>特殊整数</strong> 。</p>\n\n<p>给你一个 <strong>正</strong>&nbsp;整数&nbsp;<code>n</code>&nbsp;，请你返回区间<em>&nbsp;</em><code>[1, n]</code>&nbsp;之间特殊整数的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 20\n<b>输出：</b>19\n<b>解释：</b>1 到 20 之间所有整数除了 11 以外都是特殊整数。所以总共有 19 个特殊整数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5\n<b>输出：</b>5\n<b>解释：</b>1 到 5 所有整数都是特殊整数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 135\n<b>输出：</b>110\n<b>解释：</b>从 1 到 135 总共有 110 个整数是特殊整数。\n不特殊的部分数字为：22 ，114 和 131 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2377.整理奥运表",
        "hardRate": "EASY",
        "passRate": "80.12%",
        "problemsUrl": "https://leetcode.cn/problems/sort-the-olympic-table/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-the-olympic-table/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2378.选择边来最大化树的得分",
        "hardRate": "MEDIUM",
        "passRate": "69.76%",
        "problemsUrl": "https://leetcode.cn/problems/choose-edges-to-maximize-score-in-a-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/choose-edges-to-maximize-score-in-a-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2379.得到 K 个黑块的最少涂色次数",
        "hardRate": "EASY",
        "passRate": "61.77%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>blocks</code>&nbsp;，<code>blocks[i]</code>&nbsp;要么是&nbsp;<code>'W'</code>&nbsp;要么是&nbsp;<code>'B'</code>&nbsp;，表示第&nbsp;<code>i</code>&nbsp;块的颜色。字符&nbsp;<code>'W'</code> 和&nbsp;<code>'B'</code>&nbsp;分别表示白色和黑色。</p>\n\n<p>给你一个整数&nbsp;<code>k</code>&nbsp;，表示想要&nbsp;<strong>连续</strong>&nbsp;黑色块的数目。</p>\n\n<p>每一次操作中，你可以选择一个白色块将它 <strong>涂成</strong>&nbsp;黑色块。</p>\n\n<p>请你返回至少出现 <strong>一次</strong>&nbsp;连续 <code>k</code>&nbsp;个黑色块的 <strong>最少</strong>&nbsp;操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>blocks = \"WBBWWBBWBW\", k = 7\n<b>输出：</b>3\n<strong>解释：</strong>\n一种得到 7 个连续黑色块的方法是把第 0 ，3 和 4 个块涂成黑色。\n得到 blocks = \"BBBBBBBWBW\" 。\n可以证明无法用少于 3 次操作得到 7 个连续的黑块。\n所以我们返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>blocks = \"WBWBBBW\", k = 2\n<b>输出：</b>0\n<strong>解释：</strong>\n不需要任何操作，因为已经有 2 个连续的黑块。\n所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>n == blocks.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>blocks[i]</code>&nbsp;要么是&nbsp;<code>'W'</code>&nbsp;，要么是&nbsp;<code>'B'</code> 。</li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2380.二进制字符串重新安排顺序需要的时间",
        "hardRate": "MEDIUM",
        "passRate": "56.17%",
        "problemsUrl": "https://leetcode.cn/problems/time-needed-to-rearrange-a-binary-string/",
        "solutionsUrl": "https://leetcode.cn/problems/time-needed-to-rearrange-a-binary-string/solution",
        "problemsDesc": "<p>给你一个二进制字符串&nbsp;<code>s</code>&nbsp;。在一秒之中，<strong>所有</strong>&nbsp;子字符串&nbsp;<code>\"01\"</code> <strong>同时</strong>&nbsp;被替换成&nbsp;<code>\"10\"</code>&nbsp;。这个过程持续进行到没有&nbsp;<code>\"01\"</code>&nbsp;存在。</p>\n\n<p>请你返回完成这个过程所需要的秒数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"0110101\"\n<b>输出：</b>4\n<b>解释：</b>\n一秒后，s 变成 \"1011010\" 。\n再过 1 秒后，s 变成 \"1101100\" 。\n第三秒过后，s 变成 \"1110100\" 。\n第四秒后，s 变成 \"1111000\" 。\n此时没有 \"01\" 存在，整个过程花费 4 秒。\n所以我们返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"11100\"\n<b>输出：</b>0\n<strong>解释：</strong>\ns 中没有 \"01\" 存在，整个过程花费 0 秒。\n所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i]</code>&nbsp;要么是&nbsp;<code>'0'</code>&nbsp;，要么是&nbsp;<code>'1'</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<p>你能以 O(n) 的时间复杂度解决这个问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2381.字母移位 II",
        "hardRate": "MEDIUM",
        "passRate": "36.93%",
        "problemsUrl": "https://leetcode.cn/problems/shifting-letters-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/shifting-letters-ii/solution",
        "problemsDesc": "<p>给你一个小写英文字母组成的字符串&nbsp;<code>s</code>&nbsp;和一个二维整数数组&nbsp;<code>shifts</code>&nbsp;，其中&nbsp;<code>shifts[i] = [start<sub>i</sub>, end<sub>i</sub>, direction<sub>i</sub>]</code>&nbsp;。对于每个&nbsp;<code>i</code>&nbsp;，将&nbsp;<code>s</code>&nbsp;中从下标&nbsp;<code>start<sub>i</sub></code>&nbsp;到下标&nbsp;<code>end<sub>i</sub></code>&nbsp;（两者都包含）所有字符都进行移位运算，如果&nbsp;<code>direction<sub>i</sub> = 1</code>&nbsp;将字符向后移位，如果&nbsp;<code>direction<sub>i</sub> = 0</code>&nbsp;将字符向前移位。</p>\n\n<p>将一个字符 <strong>向后</strong>&nbsp;移位的意思是将这个字符用字母表中 <strong>下一个</strong>&nbsp;字母替换（字母表视为环绕的，所以&nbsp;<code>'z'</code>&nbsp;变成&nbsp;<code>'a'</code>）。类似的，将一个字符 <strong>向前</strong>&nbsp;移位的意思是将这个字符用字母表中 <strong>前一个</strong>&nbsp;字母替换（字母表是环绕的，所以&nbsp;<code>'a'</code>&nbsp;变成&nbsp;<code>'z'</code>&nbsp;）。</p>\n\n<p>请你返回对 <code>s</code>&nbsp;进行所有移位操作以后得到的最终字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"abc\", shifts = [[0,1,0],[1,2,1],[0,2,1]]\n<b>输出：</b>\"ace\"\n<b>解释：</b>首先，将下标从 0 到 1 的字母向前移位，得到 s = \"zac\" 。\n然后，将下标从 1 到 2 的字母向后移位，得到 s = \"zbd\" 。\n最后，将下标从 0 到 2 的字符向后移位，得到 s = \"ace\" 。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><b>输入：</b>s = \"dztz\", shifts = [[0,0,0],[1,1,1]]\n<b>输出：</b>\"catz\"\n<b>解释：</b>首先，将下标从 0 到 0 的字母向前移位，得到 s = \"cztz\" 。\n最后，将下标从 1 到 1 的字符向后移位，得到 s = \"catz\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, shifts.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>shifts[i].length == 3</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt; s.length</code></li>\n\t<li><code>0 &lt;= direction<sub>i</sub> &lt;= 1</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2382.删除操作后的最大子段和",
        "hardRate": "HARD",
        "passRate": "56.25%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-segment-sum-after-removals/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-segment-sum-after-removals/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code> 和&nbsp;<code>removeQueries</code>&nbsp;，两者长度都为&nbsp;<code>n</code>&nbsp;。对于第&nbsp;<code>i</code>&nbsp;个查询，<code>nums</code>&nbsp;中位于下标&nbsp;<code>removeQueries[i]</code>&nbsp;处的元素被删除，将 <code>nums</code>&nbsp;分割成更小的子段。</p>\n\n<p>一个 <strong>子段</strong>&nbsp;是 <code>nums</code>&nbsp;中连续 <strong>正</strong>&nbsp;整数形成的序列。<strong>子段和</strong>&nbsp;是子段中所有元素的和。</p>\n\n<p>请你返回一个长度为 <code>n</code>&nbsp;的整数数组<em>&nbsp;</em><code>answer</code>&nbsp;，其中<em>&nbsp;</em><code>answer[i]</code>是第&nbsp;<code>i</code>&nbsp;次删除操作以后的&nbsp;<strong>最大</strong>&nbsp;子段和。</p>\n\n<p><strong>注意：</strong>一个下标至多只会被删除一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]\n<b>输出：</b>[14,7,2,2,0]\n<b>解释：</b>用 0 表示被删除的元素，答案如下所示：\n查询 1 ：删除第 0 个元素，nums 变成 [0,2,5,6,1] ，最大子段和为子段 [2,5,6,1] 的和 14 。\n查询 2 ：删除第 3 个元素，nums 变成 [0,2,5,0,1] ，最大子段和为子段 [2,5] 的和 7 。\n查询 3 ：删除第 2 个元素，nums 变成 [0,2,0,0,1] ，最大子段和为子段 [2] 的和 2 。\n查询 4 ：删除第 4 个元素，nums 变成 [0,2,0,0,0] ，最大子段和为子段 [2] 的和 2 。\n查询 5 ：删除第 1 个元素，nums 变成 [0,0,0,0,0] ，最大子段和为 0 ，因为没有任何子段存在。\n所以，我们返回 [14,7,2,2,0] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [3,2,11,1], removeQueries = [3,2,1,0]\n<b>输出：</b>[16,5,3,0]\n<b>解释：</b>用 0 表示被删除的元素，答案如下所示：\n查询 1 ：删除第 3 个元素，nums 变成 [3,2,11,0] ，最大子段和为子段 [3,2,11] 的和 16 。\n查询 2 ：删除第 2 个元素，nums 变成 [3,2,0,0] ，最大子段和为子段 [3,2] 的和 5 。\n查询 3 ：删除第 1 个元素，nums 变成 [3,0,0,0] ，最大子段和为子段 [3] 的和 3 。\n查询 5 ：删除第 0 个元素，nums 变成 [0,0,0,0] ，最大子段和为 0 ，因为没有任何子段存在。\n所以，我们返回 [16,5,3,0] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length == removeQueries.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= removeQueries[i] &lt; n</code></li>\n\t<li><code>removeQueries</code>&nbsp;中所有数字 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2383.赢得比赛需要的最少训练时长",
        "hardRate": "EASY",
        "passRate": "47.19%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition/solution",
        "problemsDesc": "<p>你正在参加一场比赛，给你两个 <strong>正</strong> 整数 <code>initialEnergy</code> 和 <code>initialExperience</code> 分别表示你的初始精力和初始经验。</p>\n\n<p>另给你两个下标从 <strong>0</strong> 开始的整数数组 <code>energy</code> 和 <code>experience</code>，长度均为 <code>n</code> 。</p>\n\n<p>你将会 <strong>依次</strong> 对上 <code>n</code> 个对手。第 <code>i</code> 个对手的精力和经验分别用 <code>energy[i]</code> 和 <code>experience[i]</code> 表示。当你对上对手时，需要在经验和精力上都 <strong>严格</strong> 超过对手才能击败他们，然后在可能的情况下继续对上下一个对手。</p>\n\n<p>击败第 <code>i</code> 个对手会使你的经验 <strong>增加</strong> <code>experience[i]</code>，但会将你的精力 <strong>减少</strong>&nbsp; <code>energy[i]</code> 。</p>\n\n<p>在开始比赛前，你可以训练几个小时。每训练一个小时，你可以选择将增加经验增加 1 <strong>或者</strong> 将精力增加 1 。</p>\n\n<p>返回击败全部 <code>n</code> 个对手需要训练的 <strong>最少</strong> 小时数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]\n<strong>输出：</strong>8\n<strong>解释：</strong>在 6 小时训练后，你可以将精力提高到 11 ，并且再训练 2 个小时将经验提高到 5 。\n按以下顺序与对手比赛：\n- 你的精力与经验都超过第 0 个对手，所以获胜。\n  精力变为：11 - 1 = 10 ，经验变为：5 + 2 = 7 。\n- 你的精力与经验都超过第 1 个对手，所以获胜。\n  精力变为：10 - 4 = 6 ，经验变为：7 + 6 = 13 。\n- 你的精力与经验都超过第 2 个对手，所以获胜。\n  精力变为：6 - 3 = 3 ，经验变为：13 + 3 = 16 。\n- 你的精力与经验都超过第 3 个对手，所以获胜。\n  精力变为：3 - 2 = 1 ，经验变为：16 + 1 = 17 。\n在比赛前进行了 8 小时训练，所以返回 8 。\n可以证明不存在更小的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>initialEnergy = 2, initialExperience = 4, energy = [1], experience = [3]\n<strong>输出：</strong>0\n<strong>解释：</strong>你不需要额外的精力和经验就可以赢得比赛，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == energy.length == experience.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= initialEnergy, initialExperience, energy[i], experience[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2384.最大回文数字",
        "hardRate": "MEDIUM",
        "passRate": "31.08%",
        "problemsUrl": "https://leetcode.cn/problems/largest-palindromic-number/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-palindromic-number/solution",
        "problemsDesc": "<p>给你一个仅由数字（<code>0 - 9</code>）组成的字符串 <code>num</code> 。</p>\n\n<p>请你找出能够使用 <code>num</code> 中数字形成的 <strong>最大回文</strong> 整数，并以字符串形式返回。该整数不含 <strong>前导零</strong> 。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>你 <strong>无需</strong> 使用 <code>num</code> 中的所有数字，但你必须使用 <strong>至少</strong> 一个数字。</li>\n\t<li>数字可以重新排序。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"444947137\"\n<strong>输出：</strong>\"7449447\"\n<strong>解释：</strong>\n从 \"<em><strong>44494</strong></em><em><strong>7</strong></em>13<em><strong>7</strong></em>\" 中选用数字 \"4449477\"，可以形成回文整数 \"7449447\" 。\n可以证明 \"7449447\" 是能够形成的最大回文整数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"00009\"\n<strong>输出：</strong>\"9\"\n<strong>解释：</strong>\n可以证明 \"9\" 能够形成的最大回文整数。\n注意返回的整数不应含前导零。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>num</code> 由数字（<code>0 - 9</code>）组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2385.感染二叉树需要的总时间",
        "hardRate": "MEDIUM",
        "passRate": "46.10%",
        "problemsUrl": "https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/",
        "solutionsUrl": "https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点 <code>root</code> ，二叉树中节点的值 <strong>互不相同</strong> 。另给你一个整数 <code>start</code> 。在第 <code>0</code> 分钟，<strong>感染</strong> 将会从值为 <code>start</code> 的节点开始爆发。</p>\n\n<p>每分钟，如果节点满足以下全部条件，就会被感染：</p>\n\n<ul>\n\t<li>节点此前还没有感染。</li>\n\t<li>节点与一个已感染节点相邻。</li>\n</ul>\n\n<p>返回感染整棵树需要的分钟数<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/25/image-20220625231744-1.png\" style=\"width: 400px; height: 306px;\">\n<pre><strong>输入：</strong>root = [1,5,3,null,4,10,6,9,2], start = 3\n<strong>输出：</strong>4\n<strong>解释：</strong>节点按以下过程被感染：\n- 第 0 分钟：节点 3\n- 第 1 分钟：节点 1、10、6\n- 第 2 分钟：节点5\n- 第 3 分钟：节点 4\n- 第 4 分钟：节点 9 和 2\n感染整棵树需要 4 分钟，所以返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/25/image-20220625231812-2.png\" style=\"width: 75px; height: 66px;\">\n<pre><strong>输入：</strong>root = [1], start = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>第 0 分钟，树中唯一一个节点处于感染状态，返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li>每个节点的值 <strong>互不相同</strong></li>\n\t<li>树中必定存在值为 <code>start</code> 的节点</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2386.找出数组的第 K 大和",
        "hardRate": "HARD",
        "passRate": "42.26%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-k-sum-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-k-sum-of-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个 <strong>正</strong> 整数 <code>k</code> 。你可以选择数组的任一 <strong>子序列</strong> 并且对其全部元素求和。</p>\n\n<p>数组的 <strong>第 k 大和</strong> 定义为：可以获得的第 <code>k</code> 个 <strong>最大</strong> 子序列和（子序列和允许出现重复）</p>\n\n<p>返回数组的 <strong>第 k 大和</strong> 。</p>\n\n<p>子序列是一个可以由其他数组删除某些或不删除元素排生而来的数组，且派生过程不改变剩余元素的顺序。</p>\n\n<p><strong>注意：</strong>空子序列的和视作 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,4,-2], k = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>所有可能获得的子序列和列出如下，按递减顺序排列：\n- 6、4、4、2、<strong><em>2</em></strong>、0、0、-2\n数组的第 5 大和是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,-2,3,4,-10,12], k = 16\n<strong>输出：</strong>10\n<strong>解释：</strong>数组的第 16 大和是 10 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= min(2000, 2<sup>n</sup>)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2387.行排序矩阵的中位数",
        "hardRate": "MEDIUM",
        "passRate": "76.22%",
        "problemsUrl": "https://leetcode.cn/problems/median-of-a-row-wise-sorted-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/median-of-a-row-wise-sorted-matrix/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2388.将表中的空值更改为前一个值",
        "hardRate": "MEDIUM",
        "passRate": "68.04%",
        "problemsUrl": "https://leetcode.cn/problems/change-null-values-in-a-table-to-the-previous-value/",
        "solutionsUrl": "https://leetcode.cn/problems/change-null-values-in-a-table-to-the-previous-value/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2389.和有限的最长子序列",
        "hardRate": "EASY",
        "passRate": "70.93%",
        "problemsUrl": "https://leetcode.cn/problems/longest-subsequence-with-limited-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-subsequence-with-limited-sum/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的整数数组 <code>nums</code> ，和一个长度为 <code>m</code> 的整数数组 <code>queries</code> 。</p>\n\n<p>返回一个长度为 <code>m</code> 的数组<em> </em><code>answer</code><em> </em>，其中<em> </em><code>answer[i]</code><em> </em>是 <code>nums</code> 中<span style=\"\"> </span>元素之和小于等于 <code>queries[i]</code> 的 <strong>子序列</strong> 的 <strong>最大</strong> 长度<span style=\"\">&nbsp;</span><span style=\"\"> </span>。</p>\n\n<p><strong>子序列</strong> 是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,5,2,1], queries = [3,10,21]\n<strong>输出：</strong>[2,3,4]\n<strong>解释：</strong>queries 对应的 answer 如下：\n- 子序列 [2,1] 的和小于或等于 3 。可以证明满足题目要求的子序列的最大长度是 2 ，所以 answer[0] = 2 。\n- 子序列 [4,5,1] 的和小于或等于 10 。可以证明满足题目要求的子序列的最大长度是 3 ，所以 answer[1] = 3 。\n- 子序列 [4,5,2,1] 的和小于或等于 21 。可以证明满足题目要求的子序列的最大长度是 4 ，所以 answer[2] = 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,4,5], queries = [1]\n<strong>输出：</strong>[0]\n<strong>解释：</strong>空子序列是唯一一个满足元素和小于或等于 1 的子序列，所以 answer[0] = 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>m == queries.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i], queries[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2390.从字符串中移除星号",
        "hardRate": "MEDIUM",
        "passRate": "69.52%",
        "problemsUrl": "https://leetcode.cn/problems/removing-stars-from-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/removing-stars-from-a-string/solution",
        "problemsDesc": "<p>给你一个包含若干星号 <code>*</code> 的字符串 <code>s</code> 。</p>\n\n<p>在一步操作中，你可以：</p>\n\n<ul>\n\t<li>选中 <code>s</code> 中的一个星号。</li>\n\t<li>移除星号 <strong>左侧</strong> 最近的那个 <strong>非星号</strong> 字符，并移除该星号自身。</li>\n</ul>\n\n<p>返回移除 <strong>所有</strong> 星号之后的字符串<strong>。</strong></p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>生成的输入保证总是可以执行题面中描述的操作。</li>\n\t<li>可以证明结果字符串是唯一的。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"leet**cod*e\"\n<strong>输出：</strong>\"lecoe\"\n<strong>解释：</strong>从左到右执行移除操作：\n- 距离第 1 个星号最近的字符是 \"lee<em><strong>t</strong></em>**cod*e\" 中的 't' ，s 变为 \"lee*cod*e\" 。\n- 距离第 2 个星号最近的字符是 \"le<em><strong>e</strong></em>*cod*e\" 中的 'e' ，s 变为 \"lecod*e\" 。\n- 距离第 3 个星号最近的字符是 \"leco<em><strong>d</strong></em>*e\" 中的 'd' ，s 变为 \"lecoe\" 。\n不存在其他星号，返回 \"lecoe\" 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"erase*****\"\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>整个字符串都会被移除，所以返回空字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写英文字母和星号 <code>*</code> 组成</li>\n\t<li><code>s</code> 可以执行上述操作</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2391.收集垃圾的最少总时间",
        "hardRate": "MEDIUM",
        "passRate": "85.66%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-amount-of-time-to-collect-garbage/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-amount-of-time-to-collect-garbage/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串数组&nbsp;<code>garbage</code>&nbsp;，其中&nbsp;<code>garbage[i]</code>&nbsp;表示第 <code>i</code>&nbsp;个房子的垃圾集合。<code>garbage[i]</code>&nbsp;只包含字符&nbsp;<code>'M'</code>&nbsp;，<code>'P'</code> 和&nbsp;<code>'G'</code>&nbsp;，但可能包含多个相同字符，每个字符分别表示一单位的金属、纸和玻璃。垃圾车收拾 <strong>一</strong>&nbsp;单位的任何一种垃圾都需要花费&nbsp;<code>1</code>&nbsp;分钟。</p>\n\n<p>同时给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>travel</code>&nbsp;，其中&nbsp;<code>travel[i]</code>&nbsp;是垃圾车从房子 <code>i</code>&nbsp;行驶到房子 <code>i + 1</code>&nbsp;需要的分钟数。</p>\n\n<p>城市里总共有三辆垃圾车，分别收拾三种垃圾。每辆垃圾车都从房子 <code>0</code>&nbsp;出发，<strong>按顺序</strong>&nbsp;到达每一栋房子。但它们 <strong>不是必须</strong>&nbsp;到达所有的房子。</p>\n\n<p>任何时刻只有 <strong>一辆</strong>&nbsp;垃圾车处在使用状态。当一辆垃圾车在行驶或者收拾垃圾的时候，另外两辆车 <strong>不能</strong>&nbsp;做任何事情。</p>\n\n<p>请你返回收拾完所有垃圾需要花费的 <strong>最少</strong>&nbsp;总分钟数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>garbage = [\"G\",\"P\",\"GP\",\"GG\"], travel = [2,4,3]\n<b>输出：</b>21\n<strong>解释：</strong>\n收拾纸的垃圾车：\n1. 从房子 0 行驶到房子 1\n2. 收拾房子 1 的纸垃圾\n3. 从房子 1 行驶到房子 2\n4. 收拾房子 2 的纸垃圾\n收拾纸的垃圾车总共花费 8 分钟收拾完所有的纸垃圾。\n收拾玻璃的垃圾车：\n1. 收拾房子 0 的玻璃垃圾\n2. 从房子 0 行驶到房子 1\n3. 从房子 1 行驶到房子 2\n4. 收拾房子 2 的玻璃垃圾\n5. 从房子 2 行驶到房子 3\n6. 收拾房子 3 的玻璃垃圾\n收拾玻璃的垃圾车总共花费 13 分钟收拾完所有的玻璃垃圾。\n由于没有金属垃圾，收拾金属的垃圾车不需要花费任何时间。\n所以总共花费 8 + 13 = 21 分钟收拾完所有垃圾。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>garbage = [\"MMM\",\"PGM\",\"GP\"], travel = [3,10]\n<b>输出：</b>37\n<strong>解释：</strong>\n收拾金属的垃圾车花费 7 分钟收拾完所有的金属垃圾。\n收拾纸的垃圾车花费 15 分钟收拾完所有的纸垃圾。\n收拾玻璃的垃圾车花费 15 分钟收拾完所有的玻璃垃圾。\n总共花费 7 + 15 + 15 = 37 分钟收拾完所有的垃圾。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= garbage.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>garbage[i]</code> 只包含字母&nbsp;<code>'M'</code>&nbsp;，<code>'P'</code>&nbsp;和&nbsp;<code>'G'</code>&nbsp;。</li>\n\t<li><code>1 &lt;= garbage[i].length &lt;= 10</code></li>\n\t<li><code>travel.length == garbage.length - 1</code></li>\n\t<li><code>1 &lt;= travel[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2392.给定条件下构造矩阵",
        "hardRate": "HARD",
        "passRate": "55.82%",
        "problemsUrl": "https://leetcode.cn/problems/build-a-matrix-with-conditions/",
        "solutionsUrl": "https://leetcode.cn/problems/build-a-matrix-with-conditions/solution",
        "problemsDesc": "<p>给你一个 <strong>正</strong>&nbsp;整数&nbsp;<code>k</code>&nbsp;，同时给你：</p>\n\n<ul>\n\t<li>一个大小为 <code>n</code>&nbsp;的二维整数数组&nbsp;<code>rowConditions</code>&nbsp;，其中&nbsp;<code>rowConditions[i] = [above<sub>i</sub>, below<sub>i</sub>]</code>&nbsp;和</li>\n\t<li>一个大小为 <code>m</code>&nbsp;的二维整数数组&nbsp;<code>colConditions</code>&nbsp;，其中&nbsp;<code>colConditions[i] = [left<sub>i</sub>, right<sub>i</sub>]</code>&nbsp;。</li>\n</ul>\n\n<p>两个数组里的整数都是&nbsp;<code>1</code>&nbsp;到&nbsp;<code>k</code>&nbsp;之间的数字。</p>\n\n<p>你需要构造一个&nbsp;<code>k x k</code>&nbsp;的矩阵，<code>1</code>&nbsp;到&nbsp;<code>k</code>&nbsp;每个数字需要&nbsp;<strong>恰好出现一次</strong>&nbsp;。剩余的数字都是<b>&nbsp;</b><code>0</code>&nbsp;。</p>\n\n<p>矩阵还需要满足以下条件：</p>\n\n<ul>\n\t<li>对于所有 <code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;之间的下标&nbsp;<code>i</code>&nbsp;，数字&nbsp;<code>above<sub>i</sub></code>&nbsp;所在的 <strong>行</strong>&nbsp;必须在数字&nbsp;<code>below<sub>i</sub></code>&nbsp;所在行的上面。</li>\n\t<li>对于所有 <code>0</code>&nbsp;到 <code>m - 1</code>&nbsp;之间的下标&nbsp;<code>i</code>&nbsp;，数字&nbsp;<code>left<sub>i</sub></code>&nbsp;所在的 <b>列</b>&nbsp;必须在数字&nbsp;<code>right<sub>i</sub></code>&nbsp;所在列的左边。</li>\n</ul>\n\n<p>返回满足上述要求的 <strong>任意</strong>&nbsp;矩阵。如果不存在答案，返回一个空的矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/06/gridosdrawio.png\" style=\"width: 211px; height: 211px;\"></p>\n\n<pre><b>输入：</b>k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]]\n<b>输出：</b>[[3,0,0],[0,0,1],[0,2,0]]\n<b>解释：</b>上图为一个符合所有条件的矩阵。\n行要求如下：\n- 数字 1 在第 <strong>1</strong> 行，数字 2 在第 <strong>2</strong>&nbsp;行，1 在 2 的上面。\n- 数字 3 在第 <strong>0</strong>&nbsp;行，数字 2 在第 <strong>2</strong>&nbsp;行，3 在 2 的上面。\n列要求如下：\n- 数字 2 在第 <strong>1</strong>&nbsp;列，数字 1 在第 <strong>2</strong>&nbsp;列，2 在 1 的左边。\n- 数字 3 在第 <strong>0</strong>&nbsp;列，数字 2 在第 <strong>1</strong>&nbsp;列，3 在 2 的左边。\n注意，可能有多种正确的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]]\n<b>输出：</b>[]\n<b>解释：</b>由前两个条件可以得到 3 在 1 的下面，但第三个条件是 3 在 1 的上面。\n没有符合条件的矩阵存在，所以我们返回空矩阵。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= k &lt;= 400</code></li>\n\t<li><code>1 &lt;= rowConditions.length, colConditions.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>rowConditions[i].length == colConditions[i].length == 2</code></li>\n\t<li><code>1 &lt;= above<sub>i</sub>, below<sub>i</sub>, left<sub>i</sub>, right<sub>i</sub> &lt;= k</code></li>\n\t<li><code>above<sub>i</sub> != below<sub>i</sub></code></li>\n\t<li><code>left<sub>i</sub> != right<sub>i</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2393.严格递增的子数组个数",
        "hardRate": "MEDIUM",
        "passRate": "78.60%",
        "problemsUrl": "https://leetcode.cn/problems/count-strictly-increasing-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/count-strictly-increasing-subarrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2394.开除员工",
        "hardRate": "MEDIUM",
        "passRate": "53.19%",
        "problemsUrl": "https://leetcode.cn/problems/employees-with-deductions/",
        "solutionsUrl": "https://leetcode.cn/problems/employees-with-deductions/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2395.和相等的子数组",
        "hardRate": "EASY",
        "passRate": "76.23%",
        "problemsUrl": "https://leetcode.cn/problems/find-subarrays-with-equal-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/find-subarrays-with-equal-sum/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，判断是否存在&nbsp;<strong>两个</strong>&nbsp;长度为&nbsp;<code>2</code>&nbsp;的子数组且它们的&nbsp;<strong>和</strong>&nbsp;相等。注意，这两个子数组起始位置的下标必须&nbsp;<strong>不相同</strong>&nbsp;。</p>\n\n<p>如果这样的子数组存在，请返回&nbsp;<code>true</code>，否则返回&nbsp;<code>false</code><em>&nbsp;</em>。</p>\n\n<p><strong>子数组</strong> 是一个数组中一段连续非空的元素组成的序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [4,2,4]\n<b>输出：</b>true\n<b>解释：</b>元素为 [4,2] 和 [2,4] 的子数组有相同的和 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4,5]\n<b>输出：</b>false\n<b>解释：</b>没有长度为 2 的两个子数组和相等。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [0,0,0]\n<b>输出：</b>true\n<b>解释：</b>子数组 [nums[0],nums[1]] 和 [nums[1],nums[2]] 的和相等，都为 0 。\n注意即使子数组的元素相同，这两个子数组也视为不相同的子数组，因为它们在原数组中的起始位置不同。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2396.严格回文的数字",
        "hardRate": "MEDIUM",
        "passRate": "87.90%",
        "problemsUrl": "https://leetcode.cn/problems/strictly-palindromic-number/",
        "solutionsUrl": "https://leetcode.cn/problems/strictly-palindromic-number/solution",
        "problemsDesc": "<p>如果一个整数 <code>n</code>&nbsp;在 <code>b</code>&nbsp;进制下（<code>b</code>&nbsp;为 <code>2</code>&nbsp;到 <code>n - 2</code>&nbsp;之间的所有整数）对应的字符串&nbsp;<strong>全部</strong>&nbsp;都是 <strong>回文的</strong>&nbsp;，那么我们称这个数&nbsp;<code>n</code>&nbsp;是 <strong>严格回文</strong>&nbsp;的。</p>\n\n<p>给你一个整数&nbsp;<code>n</code>&nbsp;，如果 <code>n</code>&nbsp;是 <strong>严格回文</strong>&nbsp;的，请返回&nbsp;<code>true</code> ，否则返回<em>&nbsp;</em><code>false</code>&nbsp;。</p>\n\n<p>如果一个字符串从前往后读和从后往前读完全相同，那么这个字符串是 <strong>回文的</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 9\n<b>输出：</b>false\n<b>解释：</b>在 2 进制下：9 = 1001 ，是回文的。\n在 3 进制下：9 = 100 ，不是回文的。\n所以，9 不是严格回文数字，我们返回 false 。\n注意在 4, 5, 6 和 7 进制下，n = 9 都不是回文的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 4\n<b>输出：</b>false\n<b>解释：</b>我们只考虑 2 进制：4 = 100 ，不是回文的。\n所以我们返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>4 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2397.被列覆盖的最多行数",
        "hardRate": "MEDIUM",
        "passRate": "55.00%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-rows-covered-by-columns/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-rows-covered-by-columns/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;二进制矩阵&nbsp;<code>mat</code>&nbsp;和一个整数&nbsp;<code>cols</code>&nbsp;，表示你需要选出的列数。</p>\n\n<p>如果一行中，所有的 <code>1</code> 都被你选中的列所覆盖，那么我们称这一行 <strong>被覆盖</strong>&nbsp;了。</p>\n\n<p>请你返回在选择 <code>cols</code>&nbsp;列的情况下，<strong>被覆盖</strong>&nbsp;的行数 <strong>最大</strong>&nbsp;为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/14/rowscovered.png\" style=\"width: 250px; height: 417px;\"></strong></p>\n\n<pre><b>输入：</b>mat = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], cols = 2\n<b>输出：</b>3\n<strong>解释：</strong>\n如上图所示，覆盖 3 行的一种可行办法是选择第 0 和第 2 列。\n可以看出，不存在大于 3 行被覆盖的方案，所以我们返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/14/rowscovered2.png\" style=\"width: 83px; height: 247px;\"></strong></p>\n\n<pre><b>输入：</b>mat = [[1],[0]], cols = 1\n<b>输出：</b>2\n<strong>解释：</strong>\n选择唯一的一列，两行都被覆盖了，原因是整个矩阵都被覆盖了。\n所以我们返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 12</code></li>\n\t<li><code>mat[i][j]</code>&nbsp;要么是&nbsp;<code>0</code>&nbsp;要么是&nbsp;<code>1</code>&nbsp;。</li>\n\t<li><code>1 &lt;= cols &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2398.预算内的最多机器人数目",
        "hardRate": "HARD",
        "passRate": "34.48%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-robots-within-budget/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-robots-within-budget/solution",
        "problemsDesc": "<p>你有&nbsp;<code>n</code>&nbsp;个机器人，给你两个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>chargeTimes</code> 和&nbsp;<code>runningCosts</code>&nbsp;，两者长度都为&nbsp;<code>n</code>&nbsp;。第&nbsp;<code>i</code>&nbsp;个机器人充电时间为&nbsp;<code>chargeTimes[i]</code>&nbsp;单位时间，花费&nbsp;<code>runningCosts[i]</code>&nbsp;单位时间运行。再给你一个整数&nbsp;<code>budget</code>&nbsp;。</p>\n\n<p>运行&nbsp;<code>k</code>&nbsp;个机器人 <strong>总开销</strong>&nbsp;是&nbsp;<code>max(chargeTimes) + k * sum(runningCosts)</code>&nbsp;，其中&nbsp;<code>max(chargeTimes)</code>&nbsp;是这&nbsp;<code>k</code>&nbsp;个机器人中最大充电时间，<code>sum(runningCosts)</code>&nbsp;是这 <code>k</code>&nbsp;个机器人的运行时间之和。</p>\n\n<p>请你返回在 <strong>不超过</strong>&nbsp;<code>budget</code>&nbsp;的前提下，你 <strong>最多</strong>&nbsp;可以 <strong>连续</strong>&nbsp;运行的机器人数目为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>chargeTimes = [3,6,1,3,4], runningCosts = [2,1,3,4,5], budget = 25\n<b>输出：</b>3\n<b>解释：</b>\n可以在 budget 以内运行所有单个机器人或者连续运行 2 个机器人。\n选择前 3 个机器人，可以得到答案最大值 3 。总开销是 max(3,6,1) + 3 * sum(2,1,3) = 6 + 3 * 6 = 24 ，小于 25 。\n可以看出无法在 budget 以内连续运行超过 3 个机器人，所以我们返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>chargeTimes = [11,12,19], runningCosts = [10,8,7], budget = 19\n<b>输出：</b>0\n<b>解释：</b>即使运行任何一个单个机器人，还是会超出 budget，所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>chargeTimes.length == runningCosts.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= chargeTimes[i], runningCosts[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= budget &lt;= 10<sup>15</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2399.检查相同字母间的距离",
        "hardRate": "EASY",
        "passRate": "75.23%",
        "problemsUrl": "https://leetcode.cn/problems/check-distances-between-same-letters/",
        "solutionsUrl": "https://leetcode.cn/problems/check-distances-between-same-letters/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，该字符串仅由小写英文字母组成，<code>s</code> 中的每个字母都 <strong>恰好</strong> 出现 <strong>两次</strong> 。另给你一个下标从 <strong>0</strong> 开始、长度为 <code>26</code> 的的整数数组 <code>distance</code> 。</p>\n\n<p>字母表中的每个字母按从 <code>0</code> 到 <code>25</code> 依次编号（即，<code>'a' -&gt; 0</code>, <code>'b' -&gt; 1</code>, <code>'c' -&gt; 2</code>, ... , <code>'z' -&gt; 25</code>）。</p>\n\n<p>在一个 <strong>匀整</strong> 字符串中，第 <code>i</code> 个字母的两次出现之间的字母数量是 <code>distance[i]</code> 。如果第 <code>i</code> 个字母没有在 <code>s</code> 中出现，那么 <code>distance[i]</code> 可以 <strong>忽略</strong> 。</p>\n\n<p>如果 <code>s</code> 是一个 <strong>匀整</strong> 字符串，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abaccb\", distance = [1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n<strong>输出：</strong>true\n<strong>解释：</strong>\n- 'a' 在下标 0 和下标 2 处出现，所以满足 distance[0] = 1 。\n- 'b' 在下标 1 和下标 5 处出现，所以满足 distance[1] = 3 。\n- 'c' 在下标 3 和下标 4 处出现，所以满足 distance[2] = 0 。\n注意 distance[3] = 5 ，但是由于 'd' 没有在 s 中出现，可以忽略。\n因为 s 是一个匀整字符串，返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"aa\", distance = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n<strong>输出：</strong>false\n<strong>解释：</strong>\n- 'a' 在下标 0 和 1 处出现，所以两次出现之间的字母数量为 0 。\n但是 distance[0] = 1 ，s 不是一个匀整字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 52</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n\t<li><code>s</code> 中的每个字母恰好出现两次</li>\n\t<li><code>distance.length == 26</code></li>\n\t<li><code>0 &lt;= distance[i] &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2400.恰好移动 k 步到达某一位置的方法数目",
        "hardRate": "MEDIUM",
        "passRate": "32.69%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/solution",
        "problemsDesc": "<p>给你两个 <strong>正</strong> 整数 <code>startPos</code> 和 <code>endPos</code> 。最初，你站在 <strong>无限</strong> 数轴上位置 <code>startPos</code> 处。在一步移动中，你可以向左或者向右移动一个位置。</p>\n\n<p>给你一个正整数 <code>k</code> ，返回从 <code>startPos</code> 出发、<strong>恰好</strong> 移动 <code>k</code> 步并到达 <code>endPos</code> 的 <strong>不同</strong> 方法数目。由于答案可能会很大，返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p>如果所执行移动的顺序不完全相同，则认为两种方法不同。</p>\n\n<p><strong>注意：</strong>数轴包含负整数<strong>。</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>startPos = 1, endPos = 2, k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>存在 3 种从 1 到 2 且恰好移动 3 步的方法：\n- 1 -&gt; 2 -&gt; 3 -&gt; 2.\n- 1 -&gt; 2 -&gt; 1 -&gt; 2.\n- 1 -&gt; 0 -&gt; 1 -&gt; 2.\n可以证明不存在其他方法，所以返回 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>startPos = 2, endPos = 5, k = 10\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在从 2 到 5 且恰好移动 10 步的方法。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= startPos, endPos, k &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    }
]