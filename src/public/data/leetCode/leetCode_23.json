[
    {
        "problemsName": " 1651.Hopper 公司查询 III",
        "hardRate": "HARD",
        "passRate": "63.99%",
        "problemsUrl": "https://leetcode.cn/problems/hopper-company-queries-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/hopper-company-queries-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1652.拆炸弹",
        "hardRate": "EASY",
        "passRate": "66.41%",
        "problemsUrl": "https://leetcode.cn/problems/defuse-the-bomb/",
        "solutionsUrl": "https://leetcode.cn/problems/defuse-the-bomb/solution",
        "problemsDesc": "<p>你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 <code>n</code> 的 <strong>循环</strong> 数组 <code>code</code> 以及一个密钥 <code>k</code> 。</p>\n\n<p>为了获得正确的密码，你需要替换掉每一个数字。所有数字会 <strong>同时</strong> 被替换。</p>\n\n<ul>\n\t<li>如果 <code>k > 0</code> ，将第 <code>i</code> 个数字用 <strong>接下来</strong> <code>k</code> 个数字之和替换。</li>\n\t<li>如果 <code>k < 0</code> ，将第 <code>i</code> 个数字用 <strong>之前</strong> <code>k</code> 个数字之和替换。</li>\n\t<li>如果 <code>k == 0</code> ，将第 <code>i</code> 个数字用 <code>0</code> 替换。</li>\n</ul>\n\n<p>由于 <code>code</code> 是循环的， <code>code[n-1]</code> 下一个元素是 <code>code[0]</code> ，且 <code>code[0]</code> 前一个元素是 <code>code[n-1]</code> 。</p>\n\n<p>给你 <strong>循环</strong> 数组 <code>code</code> 和整数密钥 <code>k</code> ，请你返回解密后的结果来拆除炸弹！</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>code = [5,7,1,4], k = 3\n<b>输出：</b>[12,10,16,13]\n<b>解释：</b>每个数字都被接下来 3 个数字之和替换。解密后的密码为 [7+1+4, 1+4+5, 4+5+7, 5+7+1]。注意到数组是循环连接的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>code = [1,2,3,4], k = 0\n<b>输出：</b>[0,0,0,0]\n<b>解释：</b>当 k 为 0 时，所有数字都被 0 替换。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>code = [2,4,9,3], k = -2\n<b>输出：</b>[12,5,6,13]\n<b>解释：</b>解密后的密码为 [3+9, 2+3, 4+2, 9+4] 。注意到数组是循环连接的。如果 k 是负数，那么和为 <strong>之前</strong> 的数字。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == code.length</code></li>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>1 <= code[i] <= 100</code></li>\n\t<li><code>-(n - 1) <= k <= n - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1653.使字符串平衡的最少删除次数",
        "hardRate": "MEDIUM",
        "passRate": "60.99%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-string-balanced/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-string-balanced/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，它仅包含字符&nbsp;<code>'a'</code> 和&nbsp;<code>'b'</code>​​​​ 。</p>\n\n<p>你可以删除&nbsp;<code>s</code>&nbsp;中任意数目的字符，使得&nbsp;<code>s</code> <strong>平衡</strong>&nbsp;。当不存在下标对&nbsp;<code>(i,j)</code>&nbsp;满足&nbsp;<code>i &lt; j</code> ，且&nbsp;<code>s[i] = 'b'</code> 的同时&nbsp;<code>s[j]= 'a'</code> ，此时认为 <code>s</code> 是 <strong>平衡 </strong>的。</p>\n\n<p>请你返回使 <code>s</code>&nbsp;<strong>平衡</strong>&nbsp;的 <strong>最少</strong>&nbsp;删除次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aababbab\"\n<b>输出：</b>2\n<b>解释：</b>你可以选择以下任意一种方案：\n下标从 0 开始，删除第 2 和第 6 个字符（\"aa<strong>b</strong>abb<strong>a</strong>b\" -&gt; \"aaabbb\"），\n下标从 0 开始，删除第 3 和第 6 个字符（\"aab<strong>a</strong>bb<strong>a</strong>b\" -&gt; \"aabbbb\"）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"bbaaaaabb\"\n<b>输出：</b>2\n<b>解释：</b>唯一的最优解是删除最前面两个字符。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code>&nbsp;要么是&nbsp;<code>'a'</code> 要么是&nbsp;<code>'b'</code>​<strong>&nbsp;</strong>。​</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1654.到家的最少跳跃次数",
        "hardRate": "MEDIUM",
        "passRate": "31.21%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-jumps-to-reach-home/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-jumps-to-reach-home/solution",
        "problemsDesc": "<p>有一只跳蚤的家在数轴上的位置 <code>x</code> 处。请你帮助它从位置 <code>0</code> 出发，到达它的家。</p>\n\n<p>跳蚤跳跃的规则如下：</p>\n\n<ul>\n\t<li>它可以 <strong>往前</strong> 跳恰好 <code>a</code> 个位置（即往右跳）。</li>\n\t<li>它可以 <strong>往后</strong> 跳恰好 <code>b</code> 个位置（即往左跳）。</li>\n\t<li>它不能 <strong>连续</strong> 往后跳 <code>2</code> 次。</li>\n\t<li>它不能跳到任何 <code>forbidden</code> 数组中的位置。</li>\n</ul>\n\n<p>跳蚤可以往前跳 <strong>超过</strong> 它的家的位置，但是它 <strong>不能跳到负整数</strong> 的位置。</p>\n\n<p>给你一个整数数组 <code>forbidden</code> ，其中 <code>forbidden[i]</code> 是跳蚤不能跳到的位置，同时给你整数 <code>a</code>， <code>b</code> 和 <code>x</code> ，请你返回跳蚤到家的最少跳跃次数。如果没有恰好到达 <code>x</code> 的可行方案，请你返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>forbidden = [14,4,18,1,15], a = 3, b = 15, x = 9\n<b>输出：</b>3\n<b>解释：</b>往前跳 3 次（0 -> 3 -> 6 -> 9），跳蚤就到家了。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11\n<b>输出：</b>-1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>forbidden = [1,6,2,14,5,17,4], a = 16, b = 9, x = 7\n<b>输出：</b>2\n<b>解释：</b>往前跳一次（0 -> 16），然后往回跳一次（16 -> 7），跳蚤就到家了。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= forbidden.length <= 1000</code></li>\n\t<li><code>1 <= a, b, forbidden[i] <= 2000</code></li>\n\t<li><code>0 <= x <= 2000</code></li>\n\t<li><code>forbidden</code> 中所有位置互不相同。</li>\n\t<li>位置 <code>x</code> 不在 <code>forbidden</code> 中。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1655.分配重复整数",
        "hardRate": "HARD",
        "passRate": "39.53%",
        "problemsUrl": "https://leetcode.cn/problems/distribute-repeating-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/distribute-repeating-integers/solution",
        "problemsDesc": "<p>给你一个长度为&nbsp;<code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;，这个数组中至多有&nbsp;<code>50</code>&nbsp;个不同的值。同时你有 <code>m</code>&nbsp;个顾客的订单 <code>quantity</code>&nbsp;，其中，整数&nbsp;<code>quantity[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;位顾客订单的数目。请你判断是否能将 <code>nums</code>&nbsp;中的整数分配给这些顾客，且满足：</p>\n\n<ul>\n\t<li>第&nbsp;<code>i</code>&nbsp;位顾客 <strong>恰好&nbsp;</strong>有&nbsp;<code>quantity[i]</code>&nbsp;个整数。</li>\n\t<li>第&nbsp;<code>i</code>&nbsp;位顾客拿到的整数都是 <strong>相同的</strong>&nbsp;。</li>\n\t<li>每位顾客都满足上述两个要求。</li>\n</ul>\n\n<p>如果你可以分配 <code>nums</code>&nbsp;中的整数满足上面的要求，那么请返回&nbsp;<code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4], quantity = [2]\n<b>输出：</b>false\n<strong>解释：</strong>第 0 位顾客没办法得到两个相同的整数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,3], quantity = [2]\n<b>输出：</b>true\n<b>解释：</b>第 0 位顾客得到 [3,3] 。整数 [1,2] 都没有被使用。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,1,2,2], quantity = [2,2]\n<b>输出：</b>true\n<b>解释：</b>第 0 位顾客得到 [1,1] ，第 1 位顾客得到 [2,2] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>m == quantity.length</code></li>\n\t<li><code>1 &lt;= m &lt;= 10</code></li>\n\t<li><code>1 &lt;= quantity[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums</code>&nbsp;中至多有&nbsp;<code>50</code>&nbsp;个不同的数字。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1656.设计有序流",
        "hardRate": "EASY",
        "passRate": "84.07%",
        "problemsUrl": "https://leetcode.cn/problems/design-an-ordered-stream/",
        "solutionsUrl": "https://leetcode.cn/problems/design-an-ordered-stream/solution",
        "problemsDesc": "<p>有 <code>n</code> 个 <code>(id, value)</code> 对，其中 <code>id</code> 是 <code>1</code> 到 <code>n</code> 之间的一个整数，<code>value</code> 是一个字符串。不存在 <code>id</code> 相同的两个 <code>(id, value)</code> 对。</p>\n\n<p>设计一个流，以 <strong>任意</strong> 顺序获取 <code>n</code> 个 <code>(id, value)</code> 对，并在多次调用时 <strong>按 <code>id</code> 递增的顺序</strong> 返回一些值。</p>\n\n<p>实现 <code>OrderedStream</code> 类：</p>\n\n<ul>\n\t<li><code>OrderedStream(int n)</code> 构造一个能接收 <code>n</code> 个值的流，并将当前指针 <code>ptr</code> 设为 <code>1</code> 。</li>\n\t<li><code>String[] insert(int id, String value)</code> 向流中存储新的 <code>(id, value)</code> 对。存储后：\n\t<ul>\n\t\t<li>如果流存储有 <code>id = ptr</code> 的 <code>(id, value)</code> 对，则找出从 <code>id = ptr</code> 开始的 <strong>最长 id 连续递增序列</strong> ，并 <strong>按顺序</strong> 返回与这些 id 关联的值的列表。然后，将 <code>ptr</code> 更新为最后那个  <code>id + 1</code> 。</li>\n\t\t<li>\n\t\t<p>否则，返回一个空列表。</p>\n\t\t</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/15/q1.gif\" style=\"width: 682px; height: 240px;\" /></strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"OrderedStream\", \"insert\", \"insert\", \"insert\", \"insert\", \"insert\"]\n[[5], [3, \"ccccc\"], [1, \"aaaaa\"], [2, \"bbbbb\"], [5, \"eeeee\"], [4, \"ddddd\"]]\n<strong>输出</strong>\n[null, [], [\"aaaaa\"], [\"bbbbb\", \"ccccc\"], [], [\"ddddd\", \"eeeee\"]]\n\n<strong>解释</strong>\nOrderedStream os= new OrderedStream(5);\nos.insert(3, \"ccccc\"); // 插入 (3, \"ccccc\")，返回 []\nos.insert(1, \"aaaaa\"); // 插入 (1, \"aaaaa\")，返回 [\"aaaaa\"]\nos.insert(2, \"bbbbb\"); // 插入 (2, \"bbbbb\")，返回 [\"bbbbb\", \"ccccc\"]\nos.insert(5, \"eeeee\"); // 插入 (5, \"eeeee\")，返回 []\nos.insert(4, \"ddddd\"); // 插入 (4, \"ddddd\")，返回 [\"ddddd\", \"eeeee\"]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 1000</code></li>\n\t<li><code>1 <= id <= n</code></li>\n\t<li><code>value.length == 5</code></li>\n\t<li><code>value</code> 仅由小写字母组成</li>\n\t<li>每次调用 <code>insert</code> 都会使用一个唯一的 <code>id</code></li>\n\t<li>恰好调用 <code>n</code> 次 <code>insert</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1657.确定两个字符串是否接近",
        "hardRate": "MEDIUM",
        "passRate": "47.05%",
        "problemsUrl": "https://leetcode.cn/problems/determine-if-two-strings-are-close/",
        "solutionsUrl": "https://leetcode.cn/problems/determine-if-two-strings-are-close/solution",
        "problemsDesc": "<p>如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串 <strong>接近</strong> ：</p>\n\n<ul>\n\t<li>操作 1：交换任意两个 <strong>现有</strong> 字符。\n\n\t<ul>\n\t\t<li>例如，<code>a<strong>b</strong>cd<strong>e</strong> -> a<strong>e</strong>cd<strong>b</strong></code></li>\n\t</ul>\n\t</li>\n\t<li>操作 2：将一个 <strong>现有</strong> 字符的每次出现转换为另一个 <strong>现有</strong> 字符，并对另一个字符执行相同的操作。\n\t<ul>\n\t\t<li>例如，<code><strong>aa</strong>c<strong>abb</strong> -> <strong>bb</strong>c<strong>baa</strong></code>（所有 <code>a</code> 转化为 <code>b</code> ，而所有的 <code>b</code> 转换为 <code>a</code> ）</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>你可以根据需要对任意一个字符串多次使用这两种操作。</p>\n\n<p>给你两个字符串，<code>word1</code> 和 <code>word2</code> 。如果<em> </em><code>word1</code><em> </em>和<em> </em><code>word2</code><em> </em><strong>接近 </strong>，就返回 <code>true</code> ；否则，返回<em> </em><code>false</code><em> </em>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"abc\", word2 = \"bca\"\n<strong>输出：</strong>true\n<strong>解释：</strong>2 次操作从 word1 获得 word2 。\n执行操作 1：\"a<strong>bc</strong>\" -> \"a<strong>cb</strong>\"\n执行操作 1：\"<strong>a</strong>c<strong>b</strong>\" -> \"<strong>b</strong>c<strong>a</strong>\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"a\", word2 = \"aa\"\n<strong>输出：</strong>false\n<strong>解释：</strong>不管执行多少次操作，都无法从 word1 得到 word2 ，反之亦然。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"cabbba\", word2 = \"abbccc\"\n<strong>输出：</strong>true\n<strong>解释：</strong>3 次操作从 word1 获得 word2 。\n执行操作 1：\"ca<strong>b</strong>bb<strong>a</strong>\" -> \"ca<strong>a</strong>bb<strong>b</strong>\"\n执行操作 2：<code>\"</code><strong>c</strong>aa<strong>bbb</strong>\" -> \"<strong>b</strong>aa<strong>ccc</strong>\"\n执行操作 2：\"<strong>baa</strong>ccc\" -> \"<strong>abb</strong>ccc\"\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"cabbba\", word2 = \"aabbss\"\n<strong>输出：</strong>false\n<strong>解释：</strong>不管执行多少次操作，都无法从 word1 得到 word2 ，反之亦然。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word1.length, word2.length <= 10<sup>5</sup></code></li>\n\t<li><code>word1</code> 和 <code>word2</code> 仅包含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1658.将 x 减到 0 的最小操作数",
        "hardRate": "MEDIUM",
        "passRate": "39.26%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>x</code> 。每一次操作时，你应当移除数组 <code>nums</code> 最左边或最右边的元素，然后从 <code>x</code> 中减去该元素的值。请注意，需要 <strong>修改</strong> 数组以供接下来的操作使用。</p>\n\n<p>如果可以将 <code>x</code> <strong>恰好</strong> 减到 <code>0</code> ，返回<strong> 最小操作数 </strong>；否则，返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,4,2,3], x = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>最佳解决方案是移除后两个元素，将 x 减到 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,6,7,8,9], x = 4\n<strong>输出：</strong>-1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,20,1,1,3], x = 10\n<strong>输出：</strong>5\n<strong>解释：</strong>最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= x <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1659.最大化网格幸福感",
        "hardRate": "HARD",
        "passRate": "64.79%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-grid-happiness/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-grid-happiness/solution",
        "problemsDesc": "<p>给你四个整数 <code>m</code>、<code>n</code>、<code>introvertsCount</code> 和 <code>extrovertsCount</code> 。有一个 <code>m x n</code> 网格，和两种类型的人：内向的人和外向的人。总共有 <code>introvertsCount</code> 个内向的人和 <code>extrovertsCount</code> 个外向的人。</p>\n\n<p>请你决定网格中应当居住多少人，并为每个人分配一个网格单元。 注意，<strong>不必</strong> 让所有人都生活在网格中。</p>\n\n<p>每个人的 <strong>幸福感</strong> 计算如下：</p>\n\n<ul>\n\t<li>内向的人 <strong>开始</strong> 时有 <code>120</code> 个幸福感，但每存在一个邻居（内向的或外向的）他都会 <strong>失去</strong>  <code>30</code> 个幸福感。</li>\n\t<li>外向的人 <strong>开始</strong> 时有 <code>40</code> 个幸福感，每存在一个邻居（内向的或外向的）他都会 <strong>得到</strong>  <code>20</code> 个幸福感。</li>\n</ul>\n\n<p>邻居是指居住在一个人所在单元的上、下、左、右四个直接相邻的单元中的其他人。</p>\n\n<p><strong>网格幸福感</strong> 是每个人幸福感的 <strong>总和</strong> 。 返回 <strong>最大可能的网格幸福感</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/15/grid_happiness.png\" style=\"width: 261px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2\n<strong>输出：</strong>240\n<strong>解释：</strong>假设网格坐标 (row, column) 从 1 开始编号。\n将内向的人放置在单元 (1,1) ，将外向的人放置在单元 (1,3) 和 (2,3) 。\n- 位于 (1,1) 的内向的人的幸福感：120（初始幸福感）- (0 * 30)（0 位邻居）= 120\n- 位于 (1,3) 的外向的人的幸福感：40（初始幸福感）+ (1 * 20)（1 位邻居）= 60\n- 位于 (2,3) 的外向的人的幸福感：40（初始幸福感）+ (1 * 20)（1 位邻居）= 60\n网格幸福感为：120 + 60 + 60 = 240\n上图展示该示例对应网格中每个人的幸福感。内向的人在浅绿色单元中，而外向的人在浅紫色单元中。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1\n<strong>输出：</strong>260\n<strong>解释：</strong>将内向的人放置在单元 (1,1) 和 (3,1) ，将外向的人放置在单元 (2,1) 。\n- 位于 (1,1) 的内向的人的幸福感：120（初始幸福感）- (1 * 30)（1 位邻居）= 90\n- 位于 (2,1) 的外向的人的幸福感：40（初始幸福感）+ (2 * 20)（2 位邻居）= 80\n- 位于 (3,1) 的内向的人的幸福感：120（初始幸福感）- (1 * 30)（1 位邻居）= 90\n网格幸福感为 90 + 80 + 90 = 260\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0\n<strong>输出：</strong>240\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= m, n <= 5</code></li>\n\t<li><code>0 <= introvertsCount, extrovertsCount <= min(m * n, 6)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1660.纠正二叉树",
        "hardRate": "MEDIUM",
        "passRate": "76.06%",
        "problemsUrl": "https://leetcode.cn/problems/correct-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/correct-a-binary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1661.每台机器的进程平均运行时间",
        "hardRate": "EASY",
        "passRate": "72.71%",
        "problemsUrl": "https://leetcode.cn/problems/average-time-of-process-per-machine/",
        "solutionsUrl": "https://leetcode.cn/problems/average-time-of-process-per-machine/solution",
        "problemsDesc": "<p>表: <code>Activity</code></p>\n\n<pre>\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| machine_id     | int     |\n| process_id     | int     |\n| activity_type  | enum    |\n| timestamp      | float   |\n+----------------+---------+\n该表展示了一家工厂网站的用户活动.\n(machine_id, process_id, activity_type) 是当前表的主键.\nmachine_id 是一台机器的ID号.\nprocess_id 是运行在各机器上的进程ID号.\nactivity_type 是枚举类型 ('start', 'end').\ntimestamp 是浮点类型,代表当前时间(以秒为单位).\n'start' 代表该进程在这台机器上的开始运行时间戳 , 'end' 代表该进程在这台机器上的终止运行时间戳.\n同一台机器，同一个进程都有一对开始时间戳和结束时间戳，而且开始时间戳永远在结束时间戳前面.</pre>\n\n<p>&nbsp;</p>\n\n<p>现在有一个工厂网站由几台机器运行，每台机器上运行着相同数量的进程. 请写出一条SQL计算每台机器各自完成一个进程任务的平均耗时.</p>\n\n<p>完成一个进程任务的时间指进程的<code>'end' 时间戳</code> 减去&nbsp;<code>'start' 时间戳</code>. 平均耗时通过计算每台机器上所有进程任务的总耗费时间除以机器上的总进程数量获得.</p>\n\n<p>结果表必须包含<code>machine_id（机器ID）</code> 和对应的&nbsp;<strong>average time（平均耗时）</strong>&nbsp;别名&nbsp;<code>processing_time</code>, 且<strong>四舍五入保留3位小数.</strong></p>\n\n<p>以 <strong>任意顺序</strong> 返回表。</p>\n\n<p>具体参考例子如下。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nActivity table:\n+------------+------------+---------------+-----------+\n| machine_id | process_id | activity_type | timestamp |\n+------------+------------+---------------+-----------+\n| 0          | 0          | start         | 0.712     |\n| 0          | 0          | end           | 1.520     |\n| 0          | 1          | start         | 3.140     |\n| 0          | 1          | end           | 4.120     |\n| 1          | 0          | start         | 0.550     |\n| 1          | 0          | end           | 1.550     |\n| 1          | 1          | start         | 0.430     |\n| 1          | 1          | end           | 1.420     |\n| 2          | 0          | start         | 4.100     |\n| 2          | 0          | end           | 4.512     |\n| 2          | 1          | start         | 2.500     |\n| 2          | 1          | end           | 5.000     |\n+------------+------------+---------------+-----------+\n<strong>输出：</strong>\n+------------+-----------------+\n| machine_id | processing_time |\n+------------+-----------------+\n| 0          | 0.894           |\n| 1          | 0.995           |\n| 2          | 1.456           |\n+------------+-----------------+\n<strong>解释：</strong>\n一共有3台机器,每台机器运行着两个进程.\n机器 0 的平均耗时: ((1.520 - 0.712) + (4.120 - 3.140)) / 2 = 0.894\n机器 1 的平均耗时: ((1.550 - 0.550) + (1.420 - 0.430)) / 2 = 0.995\n机器 2 的平均耗时: ((4.512 - 4.100) + (5.000 - 2.500)) / 2 = 1.456</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1662.检查两个字符串数组是否相等",
        "hardRate": "EASY",
        "passRate": "80.99%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-two-string-arrays-are-equivalent/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-two-string-arrays-are-equivalent/solution",
        "problemsDesc": "<p>给你两个字符串数组 <code>word1</code> 和 <code>word2</code> 。如果两个数组表示的字符串相同，返回<em> </em><code>true</code><em> </em>；否则，返回 <code>false</code><em> 。</em></p>\n\n<p><strong>数组表示的字符串</strong> 是由数组中的所有元素 <strong>按顺序</strong> 连接形成的字符串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\n<strong>输出：</strong>true\n<strong>解释：</strong>\nword1 表示的字符串为 \"ab\" + \"c\" -> \"abc\"\nword2 表示的字符串为 \"a\" + \"bc\" -> \"abc\"\n两个字符串相同，返回 true</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\n<strong>输出：</strong>true\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word1.length, word2.length <= 10<sup>3</sup></code></li>\n\t<li><code>1 <= word1[i].length, word2[i].length <= 10<sup>3</sup></code></li>\n\t<li><code>1 <= sum(word1[i].length), sum(word2[i].length) <= 10<sup>3</sup></code></li>\n\t<li><code>word1[i]</code> 和 <code>word2[i]</code> 由小写字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1663.具有给定数值的最小字符串",
        "hardRate": "MEDIUM",
        "passRate": "65.05%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-string-with-a-given-numeric-value/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-string-with-a-given-numeric-value/solution",
        "problemsDesc": "<p><strong>小写字符 </strong>的 <strong>数值</strong> 是它在字母表中的位置（从 <code>1</code> 开始），因此 <code>a</code> 的数值为 <code>1</code> ，<code>b</code> 的数值为 <code>2</code> ，<code>c</code> 的数值为 <code>3</code> ，以此类推。</p>\n\n<p>字符串由若干小写字符组成，<strong>字符串的数值</strong> 为各字符的数值之和。例如，字符串 <code>\"abe\"</code> 的数值等于 <code>1 + 2 + 5 = 8</code> 。</p>\n\n<p>给你两个整数 <code>n</code> 和 <code>k</code> 。返回 <strong>长度</strong> 等于 <code>n</code> 且 <strong>数值</strong> 等于 <code>k</code> 的 <strong>字典序最小</strong> 的字符串。</p>\n\n<p>注意，如果字符串 <code>x</code> 在字典排序中位于 <code>y</code> 之前，就认为 <code>x</code> 字典序比 <code>y</code> 小，有以下两种情况：</p>\n\n<ul>\n\t<li><code>x</code> 是 <code>y</code> 的一个前缀；</li>\n\t<li>如果 <code>i</code> 是 <code>x[i] != y[i]</code> 的第一个位置，且 <code>x[i]</code> 在字母表中的位置比 <code>y[i]</code> 靠前。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 27\n<strong>输出：</strong>\"aay\"\n<strong>解释：</strong>字符串的数值为 1 + 1 + 25 = 27，它是数值满足要求且长度等于 3 字典序最小的字符串。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, k = 73\n<strong>输出：</strong>\"aaszz\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>n <= k <= 26 * n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1664.生成平衡数组的方案数",
        "hardRate": "MEDIUM",
        "passRate": "66.51%",
        "problemsUrl": "https://leetcode.cn/problems/ways-to-make-a-fair-array/",
        "solutionsUrl": "https://leetcode.cn/problems/ways-to-make-a-fair-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。你需要选择 <strong>恰好</strong> 一个下标（下标从 <strong>0</strong> 开始）并删除对应的元素。请注意剩下元素的下标可能会因为删除操作而发生改变。</p>\n\n<p>比方说，如果 <code>nums = [6,1,7,4,1]</code> ，那么：</p>\n\n<ul>\n\t<li>选择删除下标 <code>1</code> ，剩下的数组为 <code>nums = [6,7,4,1]</code> 。</li>\n\t<li>选择删除下标 <code>2</code> ，剩下的数组为 <code>nums = [6,1,4,1]</code> 。</li>\n\t<li>选择删除下标 <code>4</code> ，剩下的数组为 <code>nums = [6,1,7,4]</code> 。</li>\n</ul>\n\n<p>如果一个数组满足奇数下标元素的和与偶数下标元素的和相等，该数组就是一个 <strong>平衡数组</strong> 。</p>\n\n<p>请你返回删除操作后，剩下的数组<em> </em><code>nums</code><em> </em>是 <strong>平衡数组</strong> 的 <strong>方案数</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,1,6,4]\n<b>输出：</b>1\n<strong>解释：</strong>\n删除下标 0 ：[1,6,4] -> 偶数元素下标为：1 + 4 = 5 。奇数元素下标为：6 。不平衡。\n删除下标 1 ：[2,6,4] -> 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：6 。平衡。\n删除下标 2 ：[2,1,4] -> 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：1 。不平衡。\n删除下标 3 ：[2,1,6] -> 偶数元素下标为：2 + 6 = 8 。奇数元素下标为：1 。不平衡。\n只有一种让剩余数组成为平衡数组的方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,1,1]\n<b>输出：</b>3\n<b>解释：</b>你可以删除任意元素，剩余数组都是平衡数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3]\n<b>输出：</b>0\n<b>解释：</b>不管删除哪个元素，剩下数组都不是平衡数组。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1665.完成所有任务的最少初始能量",
        "hardRate": "HARD",
        "passRate": "65.44%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-initial-energy-to-finish-tasks/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-initial-energy-to-finish-tasks/solution",
        "problemsDesc": "<p>给你一个任务数组 <code>tasks</code> ，其中 <code>tasks[i] = [actual<sub>i</sub>, minimum<sub>i</sub>]</code> ：</p>\n\n<ul>\n\t<li><code>actual<sub>i</sub></code> 是完成第 <code>i</code> 个任务 <strong>需要耗费</strong> 的实际能量。</li>\n\t<li><code>minimum<sub>i</sub></code> 是开始第 <code>i</code> 个任务前需要达到的最低能量。</li>\n</ul>\n\n<p>比方说，如果任务为 <code>[10, 12]</code> 且你当前的能量为 <code>11</code> ，那么你不能开始这个任务。如果你当前的能量为 <code>13</code> ，你可以完成这个任务，且完成它后剩余能量为 <code>3</code> 。</p>\n\n<p>你可以按照 <strong>任意顺序</strong> 完成任务。</p>\n\n<p>请你返回完成所有任务的 <strong>最少</strong> 初始能量。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>tasks = [[1,2],[2,4],[4,8]]\n<b>输出：</b>8\n<strong>解释：</strong>\n一开始有 8 能量，我们按照如下顺序完成任务：\n    - 完成第 3 个任务，剩余能量为 8 - 4 = 4 。\n    - 完成第 2 个任务，剩余能量为 4 - 2 = 2 。\n    - 完成第 1 个任务，剩余能量为 2 - 1 = 1 。\n注意到尽管我们有能量剩余，但是如果一开始只有 7 能量是不能完成所有任务的，因为我们无法开始第 3 个任务。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>tasks = [[1,3],[2,4],[10,11],[10,12],[8,9]]\n<b>输出：</b>32\n<strong>解释：</strong>\n一开始有 32 能量，我们按照如下顺序完成任务：\n    - 完成第 1 个任务，剩余能量为 32 - 1 = 31 。\n    - 完成第 2 个任务，剩余能量为 31 - 2 = 29 。\n    - 完成第 3 个任务，剩余能量为 29 - 10 = 19 。\n    - 完成第 4 个任务，剩余能量为 19 - 10 = 9 。\n    - 完成第 5 个任务，剩余能量为 9 - 8 = 1 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>tasks = [[1,7],[2,8],[3,9],[4,10],[5,11],[6,12]]\n<b>输出：</b>27\n<strong>解释：</strong>\n一开始有 27 能量，我们按照如下顺序完成任务：\n    - 完成第 5 个任务，剩余能量为 27 - 5 = 22 。\n    - 完成第 2 个任务，剩余能量为 22 - 2 = 20 。\n    - 完成第 3 个任务，剩余能量为 20 - 3 = 17 。\n    - 完成第 1 个任务，剩余能量为 17 - 1 = 16 。\n    - 完成第 4 个任务，剩余能量为 16 - 4 = 12 。\n    - 完成第 6 个任务，剩余能量为 12 - 6 = 6 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tasks.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= actual<sub>​i</sub> &lt;= minimum<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1666.改变二叉树的根节点",
        "hardRate": "MEDIUM",
        "passRate": "66.92%",
        "problemsUrl": "https://leetcode.cn/problems/change-the-root-of-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/change-the-root-of-a-binary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1667.修复表中的名字",
        "hardRate": "EASY",
        "passRate": "63.54%",
        "problemsUrl": "https://leetcode.cn/problems/fix-names-in-a-table/",
        "solutionsUrl": "https://leetcode.cn/problems/fix-names-in-a-table/solution",
        "problemsDesc": "<p>表： <code>Users</code></p>\n\n<pre>\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| user_id        | int     |\n| name           | varchar |\n+----------------+---------+\nuser_id 是该表的主键。\n该表包含用户的 ID 和名字。名字仅由小写和大写字符组成。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个 SQL 查询来修复名字，使得只有第一个字符是大写的，其余都是小写的。</p>\n\n<p>返回按 <code>user_id</code> 排序的结果表。</p>\n\n<p>查询结果格式示例如下。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nUsers table:\n+---------+-------+\n| user_id | name  |\n+---------+-------+\n| 1       | aLice |\n| 2       | bOB   |\n+---------+-------+\n<strong>输出：</strong>\n+---------+-------+\n| user_id | name  |\n+---------+-------+\n| 1       | Alice |\n| 2       | Bob   |\n+---------+-------+</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1668.最大重复子字符串",
        "hardRate": "EASY",
        "passRate": "47.00%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-repeating-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-repeating-substring/solution",
        "problemsDesc": "<p>给你一个字符串 <code>sequence</code> ，如果字符串 <code>word</code> 连续重复 <code>k</code> 次形成的字符串是 <code>sequence</code> 的一个子字符串，那么单词 <code>word</code> 的 <strong>重复值为 <code>k</code></strong><strong> </strong>。单词 <code>word</code> 的 <strong>最</strong><strong>大重复值</strong> 是单词 <code>word</code> 在 <code>sequence</code> 中最大的重复值。如果 <code>word</code> 不是 <code>sequence</code> 的子串，那么重复值 <code>k</code> 为 <code>0</code> 。</p>\n\n<p>给你一个字符串 <code>sequence</code> 和 <code>word</code> ，请你返回 <strong>最大重复值 <code>k</code> </strong>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>sequence = \"ababc\", word = \"ab\"\n<b>输出：</b>2\n<strong>解释：</strong>\"abab\" 是 \"<strong>abab</strong>c\" 的子字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>sequence = \"ababc\", word = \"ba\"\n<b>输出：</b>1\n<strong>解释：</strong>\"ba\" 是 \"a<strong>ba</strong>bc\" 的子字符串，但 \"baba\" 不是 \"ababc\" 的子字符串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>sequence = \"ababc\", word = \"ac\"\n<b>输出：</b>0\n<strong>解释：</strong>\"ac\" 不是 \"ababc\" 的子字符串。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= sequence.length <= 100</code></li>\n\t<li><code>1 <= word.length <= 100</code></li>\n\t<li><code>sequence</code> 和 <code>word</code> 都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1669.合并两个链表",
        "hardRate": "MEDIUM",
        "passRate": "77.28%",
        "problemsUrl": "https://leetcode.cn/problems/merge-in-between-linked-lists/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-in-between-linked-lists/solution",
        "problemsDesc": "<p>给你两个链表&nbsp;<code>list1</code> 和&nbsp;<code>list2</code>&nbsp;，它们包含的元素分别为&nbsp;<code>n</code> 个和&nbsp;<code>m</code> 个。</p>\n\n<p>请你将&nbsp;<code>list1</code>&nbsp;中下标从 <code>a</code> 到 <code>b</code> 的全部节点都删除，并将<code>list2</code>&nbsp;接在被删除节点的位置。</p>\n\n<p>下图中蓝色边和节点展示了操作后的结果：</p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/28/fig1.png\" style=\"height: 130px; width: 504px;\" />\n<p>请你返回结果链表的头指针。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/28/merge_linked_list_ex1.png\" style=\"width: 406px; height: 140px;\" /></p>\n\n<pre>\n<b>输入：</b>list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]\n<b>输出：</b>[0,1,2,1000000,1000001,1000002,5]\n<b>解释：</b>我们删除 list1 中下标为 3 和 4 的两个节点，并将 list2 接在该位置。上图中蓝色的边和节点为答案链表。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/28/merge_linked_list_ex2.png\" style=\"width: 463px; height: 140px;\" />\n<pre>\n<b>输入：</b>list1 = [0,1,2,3,4,5,6], a = 2, b = 5, list2 = [1000000,1000001,1000002,1000003,1000004]\n<b>输出：</b>[0,1,1000000,1000001,1000002,1000003,1000004,6]\n<b>解释：</b>上图中蓝色的边和节点为答案链表。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= list1.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= a &lt;= b &lt; list1.length - 1</code></li>\n\t<li><code>1 &lt;= list2.length &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1670.设计前中后队列",
        "hardRate": "MEDIUM",
        "passRate": "52.02%",
        "problemsUrl": "https://leetcode.cn/problems/design-front-middle-back-queue/",
        "solutionsUrl": "https://leetcode.cn/problems/design-front-middle-back-queue/solution",
        "problemsDesc": "<p>请你设计一个队列，支持在前，中，后三个位置的 <code>push</code> 和 <code>pop</code> 操作。</p>\n\n<p>请你完成 <code>FrontMiddleBack</code> 类：</p>\n\n<ul>\n\t<li><code>FrontMiddleBack()</code> 初始化队列。</li>\n\t<li><code>void pushFront(int val)</code> 将 <code>val</code> 添加到队列的 <strong>最前面</strong> 。</li>\n\t<li><code>void pushMiddle(int val)</code> 将 <code>val</code> 添加到队列的 <strong>正中间</strong> 。</li>\n\t<li><code>void pushBack(int val)</code> 将 <code>val</code> 添加到队里的 <strong>最后面</strong> 。</li>\n\t<li><code>int popFront()</code> 将 <strong>最前面</strong> 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 <code>-1</code> 。</li>\n\t<li><code>int popMiddle()</code> 将 <b>正中间</b> 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 <code>-1</code> 。</li>\n\t<li><code>int popBack()</code> 将 <strong>最后面</strong> 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 <code>-1</code> 。</li>\n</ul>\n\n<p>请注意当有 <strong>两个</strong> 中间位置的时候，选择靠前面的位置进行操作。比方说：</p>\n\n<ul>\n\t<li>将 <code>6</code> 添加到 <code>[1, 2, 3, 4, 5]</code> 的中间位置，结果数组为 <code>[1, 2, <strong>6</strong>, 3, 4, 5]</code> 。</li>\n\t<li>从 <code>[1, 2, <strong>3</strong>, 4, 5, 6]</code> 的中间位置弹出元素，返回 <code>3</code> ，数组变为 <code>[1, 2, 4, 5, 6]</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"FrontMiddleBackQueue\", \"pushFront\", \"pushBack\", \"pushMiddle\", \"pushMiddle\", \"popFront\", \"popMiddle\", \"popMiddle\", \"popBack\", \"popFront\"]\n[[], [1], [2], [3], [4], [], [], [], [], []]\n<strong>输出：</strong>\n[null, null, null, null, null, 1, 3, 4, 2, -1]\n\n<strong>解释：</strong>\nFrontMiddleBackQueue q = new FrontMiddleBackQueue();\nq.pushFront(1);   // [<strong>1</strong>]\nq.pushBack(2);    // [1, <strong>2</strong>]\nq.pushMiddle(3);  // [1, <strong>3</strong>, 2]\nq.pushMiddle(4);  // [1, <strong>4</strong>, 3, 2]\nq.popFront();     // 返回 1 -> [4, 3, 2]\nq.popMiddle();    // 返回 3 -> [4, 2]\nq.popMiddle();    // 返回 4 -> [2]\nq.popBack();      // 返回 2 -> []\nq.popFront();     // 返回 -1 -> [] （队列为空）\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= val <= 10<sup>9</sup></code></li>\n\t<li>最多调用 <code>1000</code> 次 <code>pushFront</code>， <code>pushMiddle</code>， <code>pushBack</code>， <code>popFront</code>， <code>popMiddle</code> 和 <code>popBack</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1671.得到山形数组的最少删除次数",
        "hardRate": "HARD",
        "passRate": "46.58%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array/solution",
        "problemsDesc": "<p>我们定义&nbsp;<code>arr</code>&nbsp;是 <b>山形数组</b>&nbsp;当且仅当它满足：</p>\n\n<ul>\n\t<li><code>arr.length &gt;= 3</code></li>\n\t<li>存在某个下标&nbsp;<code>i</code>&nbsp;（<strong>从 0 开始</strong>）&nbsp;满足&nbsp;<code>0 &lt; i &lt; arr.length - 1</code>&nbsp;且：\n\t<ul>\n\t\t<li><code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]</code></li>\n\t\t<li><code>arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>给你整数数组&nbsp;<code>nums</code>​ ，请你返回将 <code>nums</code>&nbsp;变成 <strong>山形状数组</strong>&nbsp;的​ <strong>最少</strong>&nbsp;删除次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,3,1]\n<b>输出：</b>0\n<b>解释：</b>数组本身就是山形数组，所以我们不需要删除任何元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,1,1,5,6,2,3,1]\n<b>输出：</b>3\n<b>解释：</b>一种方法是将下标为 0，1 和 5 的元素删除，剩余元素为 [1,5,6,3,1] ，是山形数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>题目保证&nbsp;<code>nums</code> 删除一些元素后一定能得到山形数组。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1672.最富有客户的资产总量",
        "hardRate": "EASY",
        "passRate": "83.70%",
        "problemsUrl": "https://leetcode.cn/problems/richest-customer-wealth/",
        "solutionsUrl": "https://leetcode.cn/problems/richest-customer-wealth/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的整数网格 <code>accounts</code> ，其中 <code>accounts[i][j]</code> 是第 <code>i​​​​​<sup>​​​​​​</sup>​</code> 位客户在第 <code>j</code> 家银行托管的资产数量。返回最富有客户所拥有的 <strong>资产总量</strong> 。</p>\n\n<p>客户的 <strong>资产总量</strong> 就是他们在各家银行托管的资产数量之和。最富有客户就是 <strong>资产总量</strong> 最大的客户。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>accounts = [[1,2,3],[3,2,1]]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n<code>第 1 位客户的资产总量 = 1 + 2 + 3 = 6\n第 2 位客户的资产总量 = 3 + 2 + 1 = 6\n</code>两位客户都是最富有的，资产总量都是 6 ，所以返回 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>accounts = [[1,5],[7,3],[3,5]]\n<strong>输出：</strong>10\n<strong>解释：</strong>\n<code>第 1 位客户的资产总量</code> = 6\n<code>第 2 位客户的资产总量</code> = 10 \n<code>第 3 位客户的资产总量</code> = 8\n第 2 位客户是最富有的，资产总量是 10</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>accounts = [[2,8,7],[7,1,3],[1,9,5]]\n<strong>输出：</strong>17\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == accounts.length</code></li>\n\t<li><code>n == accounts[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>1 &lt;= accounts[i][j] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1673.找出最具竞争力的子序列",
        "hardRate": "MEDIUM",
        "passRate": "39.55%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-most-competitive-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-most-competitive-subsequence/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个正整数 <code>k</code> ，返回长度为 <code>k</code> 且最具 <strong>竞争力</strong> 的<em> </em><code>nums</code> 子序列。</p>\n\n<p>数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。</p>\n\n<p>在子序列 <code>a</code> 和子序列 <code>b</code> 第一个不相同的位置上，如果 <code>a</code> 中的数字小于 <code>b</code> 中对应的数字，那么我们称子序列 <code>a</code> 比子序列 <code>b</code>（相同长度下）更具 <strong>竞争力</strong> 。 例如，<code>[1,3,4]</code> 比 <code>[1,3,5]</code> 更具竞争力，在第一个不相同的位置，也就是最后一个位置上， <code>4</code> 小于 <code>5</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,5,2,6], k = 2\n<strong>输出：</strong>[2,6]\n<strong>解释：</strong>在所有可能的子序列集合 {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 最具竞争力。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,4,3,3,5,4,9,6], k = 4\n<strong>输出：</strong>[2,3,3,4]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= nums[i] <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= k <= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1674.使数组互补的最少操作次数",
        "hardRate": "MEDIUM",
        "passRate": "41.88%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-moves-to-make-array-complementary/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-moves-to-make-array-complementary/solution",
        "problemsDesc": "<p>给你一个长度为<strong> 偶数</strong> <code>n</code> 的整数数组 <code>nums</code> 和一个整数 <code>limit</code> 。每一次操作，你可以将 <code>nums</code> 中的任何整数替换为 <code>1</code> 到 <code>limit</code> 之间的另一个整数。</p>\n\n<p>如果对于所有下标 <code>i</code>（<strong>下标从 </strong><code>0</code><strong> 开始</strong>），<code>nums[i] + nums[n - 1 - i]</code> 都等于同一个数，则数组 <code>nums</code> 是 <strong>互补的</strong> 。例如，数组 <code>[1,2,3,4]</code> 是互补的，因为对于所有下标 <code>i</code> ，<code>nums[i] + nums[n - 1 - i] = 5</code> 。</p>\n\n<p>返回使数组 <strong>互补</strong> 的 <strong>最少</strong> 操作次数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,4,3], limit = 4\n<strong>输出：</strong>1\n<strong>解释：</strong>经过 1 次操作，你可以将数组 nums 变成 [1,2,<strong>2</strong>,3]（加粗元素是变更的数字）：\nnums[0] + nums[3] = 1 + 3 = 4.\nnums[1] + nums[2] = 2 + 2 = 4.\nnums[2] + nums[1] = 2 + 2 = 4.\nnums[3] + nums[0] = 3 + 1 = 4.\n对于每个 i ，nums[i] + nums[n-1-i] = 4 ，所以 nums 是互补的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2,1], limit = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>经过 2 次操作，你可以将数组 nums 变成 [<strong>2</strong>,2,2,<strong>2</strong>] 。你不能将任何数字变更为 3 ，因为 3 > limit 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,2], limit = 2\n<strong>输出：</strong>0\n<strong>解释：</strong>nums 已经是互补的。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>2 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= limit <= 10<sup>5</sup></code></li>\n\t<li><code>n</code> 是偶数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1675.数组的最小偏移量",
        "hardRate": "HARD",
        "passRate": "45.57%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-deviation-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-deviation-in-array/solution",
        "problemsDesc": "<p>给你一个由 <code>n</code> 个正整数组成的数组 <code>nums</code> 。</p>\n\n<p>你可以对数组的任意元素执行任意次数的两类操作：</p>\n\n<ul>\n\t<li>如果元素是<strong> 偶数</strong> ，<strong>除以</strong> <code>2</code>\n\n\t<ul>\n\t\t<li>例如，如果数组是 <code>[1,2,3,4]</code> ，那么你可以对最后一个元素执行此操作，使其变成 <code>[1,2,3,<strong>2</strong>]</code></li>\n\t</ul>\n\t</li>\n\t<li>如果元素是 <strong>奇数</strong> ，<strong>乘上</strong> <code>2</code>\n\t<ul>\n\t\t<li>例如，如果数组是 <code>[1,2,3,4]</code> ，那么你可以对第一个元素执行此操作，使其变成 <code>[<strong>2</strong>,2,3,4]</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>数组的 <strong>偏移量</strong> 是数组中任意两个元素之间的 <strong>最大差值</strong> 。</p>\n\n<p>返回数组在执行某些操作之后可以拥有的 <strong>最小偏移量</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>1\n<strong>解释：</strong>你可以将数组转换为 [1,2,3,<strong>2</strong>]，然后转换成 [<strong>2</strong>,2,3,2]，偏移量是 3 - 2 = 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,1,5,20,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>两次操作后，你可以将数组转换为 [4,<strong>2</strong>,5,<strong>5</strong>,3]，偏移量是 5 - 2 = 3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,10,8]\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 5 * 10<sup><span style=\"font-size: 10.8333px;\">4</span></sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1676.二叉树的最近公共祖先 IV",
        "hardRate": "MEDIUM",
        "passRate": "79.91%",
        "problemsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iv/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1677.发票中的产品金额",
        "hardRate": "EASY",
        "passRate": "35.32%",
        "problemsUrl": "https://leetcode.cn/problems/products-worth-over-invoices/",
        "solutionsUrl": "https://leetcode.cn/problems/products-worth-over-invoices/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1678.设计 Goal 解析器",
        "hardRate": "EASY",
        "passRate": "86.10%",
        "problemsUrl": "https://leetcode.cn/problems/goal-parser-interpretation/",
        "solutionsUrl": "https://leetcode.cn/problems/goal-parser-interpretation/solution",
        "problemsDesc": "<p>请你设计一个可以解释字符串 <code>command</code> 的 <strong>Goal 解析器</strong> 。<code>command</code> 由 <code>\"G\"</code>、<code>\"()\"</code> 和/或 <code>\"(al)\"</code> 按某种顺序组成。Goal 解析器会将 <code>\"G\"</code> 解释为字符串 <code>\"G\"</code>、<code>\"()\"</code> 解释为字符串 <code>\"o\"</code> ，<code>\"(al)\"</code> 解释为字符串 <code>\"al\"</code> 。然后，按原顺序将经解释得到的字符串连接成一个字符串。</p>\n\n<p>给你字符串 <code>command</code> ，返回<em> </em><strong>Goal<em><strong> </strong></em>解析器 </strong>对<em> </em><code>command</code> 的解释结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>command = \"G()(al)\"\n<strong>输出：</strong>\"Goal\"\n<strong>解释：</strong>Goal 解析器解释命令的步骤如下所示：\nG -&gt; G\n() -&gt; o\n(al) -&gt; al\n最后连接得到的结果是 \"Goal\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>command = \"G()()()()(al)\"\n<strong>输出：</strong>\"Gooooal\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>command = \"(al)G(al)()()G\"\n<strong>输出：</strong>\"alGalooG\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= command.length &lt;= 100</code></li>\n\t<li><code>command</code> 由 <code>\"G\"</code>、<code>\"()\"</code> 和/或 <code>\"(al)\"</code> 按某种顺序组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1679.K 和数对的最大数目",
        "hardRate": "MEDIUM",
        "passRate": "54.11%",
        "problemsUrl": "https://leetcode.cn/problems/max-number-of-k-sum-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/max-number-of-k-sum-pairs/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>\n\n<p>每一步操作中，你需要从数组中选出和为 <code>k</code> 的两个整数，并将它们移出数组。</p>\n\n<p>返回你可以对数组执行的最大操作数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4], k = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>开始时 nums = [1,2,3,4]：\n- 移出 1 和 4 ，之后 nums = [2,3]\n- 移出 2 和 3 ，之后 nums = []\n不再有和为 5 的数对，因此最多执行 2 次操作。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,1,3,4,3], k = 6\n<strong>输出：</strong>1\n<strong>解释：</strong>开始时 nums = [3,1,3,4,3]：\n- 移出前两个 3 ，之后nums = [1,4,3]\n不再有和为 6 的数对，因此最多执行 1 次操作。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= k <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1680.连接连续二进制数字",
        "hardRate": "MEDIUM",
        "passRate": "49.97%",
        "problemsUrl": "https://leetcode.cn/problems/concatenation-of-consecutive-binary-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/concatenation-of-consecutive-binary-numbers/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，请你将 <code>1</code> 到 <code>n</code> 的二进制表示连接起来，并返回连接结果对应的 <strong>十进制</strong> 数字对 <code>10<sup>9</sup> + 7</code> 取余的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 1\n<b>输出：</b>1\n<strong>解释：</strong>二进制的 \"1\" 对应着十进制的 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 3\n<b>输出：</b>27\n<strong>解释：</strong>二进制下，1，2 和 3 分别对应 \"1\" ，\"10\" 和 \"11\" 。\n将它们依次连接，我们得到 \"11011\" ，对应着十进制的 27 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>n = 12\n<b>输出：</b>505379714\n<b>解释：</b>连接结果为 \"1101110010111011110001001101010111100\" 。\n对应的十进制数字为 118505380540 。\n对 10<sup>9</sup> + 7 取余后，结果为 505379714 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1681.最小不兼容性",
        "hardRate": "HARD",
        "passRate": "58.84%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-incompatibility/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-incompatibility/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>​​​ 和一个整数 <code>k</code> 。你需要将这个数组划分到 <code>k</code> 个相同大小的子集中，使得同一个子集里面没有两个相同的元素。</p>\n\n<p>一个子集的 <strong>不兼容性</strong> 是该子集里面最大值和最小值的差。</p>\n\n<p>请你返回将数组分成 <code>k</code> 个子集后，各子集 <strong>不兼容性 </strong>的<strong> 和</strong> 的 <strong>最小值</strong> ，如果无法分成分成 <code>k</code> 个子集，返回 <code>-1</code> 。</p>\n\n<p>子集的定义是数组中一些数字的集合，对数字顺序没有要求。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,1,4], k = 2\n<b>输出：</b>4\n<b>解释：</b>最优的分配是 [1,2] 和 [1,4] 。\n不兼容性和为 (2-1) + (4-1) = 4 。\n注意到 [1,1] 和 [2,4] 可以得到更小的和，但是第一个集合有 2 个相同的元素，所以不可行。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [6,3,8,1,3,1,2,2], k = 4\n<b>输出：</b>6\n<b>解释：</b>最优的子集分配为 [1,2]，[2,3]，[6,8] 和 [1,3] 。\n不兼容性和为 (2-1) + (3-2) + (8-6) + (3-1) = 6 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5,3,3,6,3,3], k = 3\n<b>输出：</b>-1\n<b>解释：</b>没办法将这些数字分配到 3 个子集且满足每个子集里没有相同数字。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= k <= nums.length <= 16</code></li>\n\t<li><code>nums.length</code> 能被 <code>k</code> 整除。</li>\n\t<li><code>1 <= nums[i] <= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1682.最长回文子序列 II",
        "hardRate": "MEDIUM",
        "passRate": "57.25%",
        "problemsUrl": "https://leetcode.cn/problems/longest-palindromic-subsequence-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-palindromic-subsequence-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1683.无效的推文",
        "hardRate": "EASY",
        "passRate": "87.12%",
        "problemsUrl": "https://leetcode.cn/problems/invalid-tweets/",
        "solutionsUrl": "https://leetcode.cn/problems/invalid-tweets/solution",
        "problemsDesc": "<p>表：<code>Tweets</code></p>\n\n<pre>+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| tweet_id       | int     |\n| content        | varchar |\n+----------------+---------+\ntweet_id 是这个表的主键。\n这个表包含某社交媒体 App 中所有的推文。</pre>\n\n<p> </p>\n\n<p>写一条 SQL 语句，查询所有无效推文的编号（ID）。当推文内容中的字符数<strong>严格大于</strong> <code>15</code> 时，该推文是无效的。</p>\n\n<p>以<strong>任意顺序</strong>返回结果表。</p>\n\n<p>查询结果格式如下示例所示：</p>\n\n<p> </p>\n\n<pre>Tweets 表：\n+----------+----------------------------------+\n| tweet_id | content                          |\n+----------+----------------------------------+\n| 1        | Vote for Biden                   |\n| 2        | Let us make America great again! |\n+----------+----------------------------------+\n\n结果表：\n+----------+\n| tweet_id |\n+----------+\n| 2        |\n+----------+\n推文 1 的长度 length = 14。该推文是有效的。\n推文 2 的长度 length = 32。该推文是无效的。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1684.统计一致字符串的数目",
        "hardRate": "EASY",
        "passRate": "85.19%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-consistent-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-consistent-strings/solution",
        "problemsDesc": "<p>给你一个由不同字符组成的字符串 <code>allowed</code> 和一个字符串数组 <code>words</code> 。如果一个字符串的每一个字符都在 <code>allowed</code> 中，就称这个字符串是 <strong>一致字符串 </strong>。</p>\n\n<p>请你返回 <code>words</code> 数组中 <strong>一致字符串</strong> 的数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>allowed = \"ab\", words = [\"ad\",\"bd\",\"aaab\",\"baa\",\"badab\"]\n<b>输出：</b>2\n<b>解释：</b>字符串 \"aaab\" 和 \"baa\" 都是一致字符串，因为它们只包含字符 'a' 和 'b' 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>allowed = \"abc\", words = [\"a\",\"b\",\"c\",\"ab\",\"ac\",\"bc\",\"abc\"]\n<b>输出：</b>7\n<b>解释：</b>所有字符串都是一致的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>allowed = \"cad\", words = [\"cc\",\"acd\",\"b\",\"ba\",\"bac\",\"bad\",\"ac\",\"d\"]\n<b>输出：</b>4\n<b>解释：</b>字符串 \"cc\"，\"acd\"，\"ac\" 和 \"d\" 是一致字符串。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= words.length <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= allowed.length <=<sup> </sup>26</code></li>\n\t<li><code>1 <= words[i].length <= 10</code></li>\n\t<li><code>allowed</code> 中的字符 <strong>互不相同</strong> 。</li>\n\t<li><code>words[i]</code> 和 <code>allowed</code> 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1685.有序数组中差绝对值之和",
        "hardRate": "MEDIUM",
        "passRate": "64.89%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-absolute-differences-in-a-sorted-array/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-absolute-differences-in-a-sorted-array/solution",
        "problemsDesc": "<p>给你一个 <strong>非递减 </strong>有序整数数组 <code>nums</code> 。</p>\n\n<p>请你建立并返回一个整数数组<em> </em><code>result</code>，它跟<em> </em><code>nums</code> 长度相同，且<code>result[i]</code> 等于<em> </em><code>nums[i]</code> 与数组中所有其他元素差的绝对值之和。</p>\n\n<p>换句话说， <code>result[i]</code> 等于 <code>sum(|nums[i]-nums[j]|)</code> ，其中 <code>0 <= j < nums.length</code> 且 <code>j != i</code> （下标从 0 开始）。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,3,5]\n<b>输出：</b>[4,3,5]\n<b>解释：</b>假设数组下标从 0 开始，那么\nresult[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4，\nresult[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3，\nresult[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,4,6,8,10]\n<b>输出：</b>[24,15,13,15,21]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= nums[i + 1] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1686.石子游戏 VI",
        "hardRate": "MEDIUM",
        "passRate": "50.21%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game-vi/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game-vi/solution",
        "problemsDesc": "<p>Alice 和 Bob 轮流玩一个游戏，Alice 先手。</p>\n\n<p>一堆石子里总共有 <code>n</code> 个石子，轮到某个玩家时，他可以 <strong>移出</strong> 一个石子并得到这个石子的价值。Alice 和 Bob 对石子价值有 <strong>不一样的的评判标准</strong> 。双方都知道对方的评判标准。</p>\n\n<p>给你两个长度为 <code>n</code> 的整数数组 <code>aliceValues</code> 和 <code>bobValues</code> 。<code>aliceValues[i]</code> 和 <code>bobValues[i]</code> 分别表示 Alice 和 Bob 认为第 <code>i</code> 个石子的价值。</p>\n\n<p>所有石子都被取完后，得分较高的人为胜者。如果两个玩家得分相同，那么为平局。两位玩家都会采用 <b>最优策略</b> 进行游戏。</p>\n\n<p>请你推断游戏的结果，用如下的方式表示：</p>\n\n<ul>\n\t<li>如果 Alice 赢，返回 <code>1</code> 。</li>\n\t<li>如果 Bob 赢，返回 <code>-1</code> 。</li>\n\t<li>如果游戏平局，返回 <code>0</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>aliceValues = [1,3], bobValues = [2,1]\n<b>输出：</b>1\n<strong>解释：</strong>\n如果 Alice 拿石子 1 （下标从 0开始），那么 Alice 可以得到 3 分。\nBob 只能选择石子 0 ，得到 2 分。\nAlice 获胜。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>aliceValues = [1,2], bobValues = [3,1]\n<b>输出：</b>0\n<strong>解释：</strong>\nAlice 拿石子 0 ， Bob 拿石子 1 ，他们得分都为 1 分。\n打平。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>aliceValues = [2,4,3], bobValues = [1,6,7]\n<b>输出：</b>-1\n<strong>解释：</strong>\n不管 Alice 怎么操作，Bob 都可以得到比 Alice 更高的得分。\n比方说，Alice 拿石子 1 ，Bob 拿石子 2 ， Alice 拿石子 0 ，Alice 会得到 6 分而 Bob 得分为 7 分。\nBob 会获胜。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == aliceValues.length == bobValues.length</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= aliceValues[i], bobValues[i] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1687.从仓库到码头运输箱子",
        "hardRate": "HARD",
        "passRate": "58.80%",
        "problemsUrl": "https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/",
        "solutionsUrl": "https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/solution",
        "problemsDesc": "<p>你有一辆货运卡车，你需要用这一辆车把一些箱子从仓库运送到码头。这辆卡车每次运输有&nbsp;<strong>箱子数目的限制</strong>&nbsp;和 <strong>总重量的限制</strong>&nbsp;。</p>\n\n<p>给你一个箱子数组&nbsp;<code>boxes</code>&nbsp;和三个整数 <code>portsCount</code>, <code>maxBoxes</code>&nbsp;和&nbsp;<code>maxWeight</code>&nbsp;，其中&nbsp;<code>boxes[i] = [ports<sub>​​i</sub>​, weight<sub>i</sub>]</code>&nbsp;。</p>\n\n<ul>\n\t<li><code>ports<sub>​​i</sub></code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个箱子需要送达的码头，&nbsp;<code>weights<sub>i</sub></code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个箱子的重量。</li>\n\t<li><code>portsCount</code>&nbsp;是码头的数目。</li>\n\t<li><code>maxBoxes</code> 和&nbsp;<code>maxWeight</code>&nbsp;分别是卡车每趟运输箱子数目和重量的限制。</li>\n</ul>\n\n<p>箱子需要按照 <strong>数组顺序</strong>&nbsp;运输，同时每次运输需要遵循以下步骤：</p>\n\n<ul>\n\t<li>卡车从&nbsp;<code>boxes</code>&nbsp;队列中按顺序取出若干个箱子，但不能违反&nbsp;<code>maxBoxes</code> 和&nbsp;<code>maxWeight</code>&nbsp;限制。</li>\n\t<li>对于在卡车上的箱子，我们需要 <strong>按顺序</strong>&nbsp;处理它们，卡车会通过 <strong>一趟行程</strong>&nbsp;将最前面的箱子送到目的地码头并卸货。如果卡车已经在对应的码头，那么不需要 <strong>额外行程</strong>&nbsp;，箱子也会立马被卸货。</li>\n\t<li>卡车上所有箱子都被卸货后，卡车需要 <strong>一趟行程</strong>&nbsp;回到仓库，从箱子队列里再取出一些箱子。</li>\n</ul>\n\n<p>卡车在将所有箱子运输并卸货后，最后必须回到仓库。</p>\n\n<p>请你返回将所有箱子送到相应码头的&nbsp;<b>最少行程</b>&nbsp;次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3\n<b>输出：</b>4\n<b>解释：</b>最优策略如下：\n- 卡车将所有箱子装上车，到达码头 1 ，然后去码头 2 ，然后再回到码头 1 ，最后回到仓库，总共需要 4 趟行程。\n所以总行程数为 4 。\n注意到第一个和第三个箱子不能同时被卸货，因为箱子需要按顺序处理（也就是第二个箱子需要先被送到码头 2 ，然后才能处理第三个箱子）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6\n<b>输出：</b>6\n<b>解释：</b>最优策略如下：\n- 卡车首先运输第一个箱子，到达码头 1 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第二、第三、第四个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第五个箱子，到达码头 2 ，回到仓库，总共 2 趟行程。\n总行程数为 2 + 2 + 2 = 6 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>boxes = [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], portsCount = 3, maxBoxes = 6, maxWeight = 7\n<b>输出：</b>6\n<b>解释：</b>最优策略如下：\n- 卡车运输第一和第二个箱子，到达码头 1 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第三和第四个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第五和第六个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。\n总行程数为 2 + 2 + 2 = 6 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>boxes = [[2,4],[2,5],[3,1],[3,2],[3,7],[3,1],[4,4],[1,3],[5,2]], portsCount = 5, maxBoxes = 5, maxWeight = 7\n<b>输出：</b>14\n<b>解释：</b>最优策略如下：\n- 卡车运输第一个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第二个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第三和第四个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第五个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第六和第七个箱子，到达码头 3 ，然后去码头 4 ，然后回到仓库，总共 3 趟行程。\n- 卡车运输第八和第九个箱子，到达码头 1 ，然后去码头 5 ，然后回到仓库，总共 3 趟行程。\n总行程数为 2 + 2 + 2 + 2 + 3 + 3 = 14 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= boxes.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= portsCount, maxBoxes, maxWeight &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= ports<sub>​​i</sub> &lt;= portsCount</code></li>\n\t<li><code>1 &lt;= weights<sub>i</sub> &lt;= maxWeight</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1688.比赛中的配对次数",
        "hardRate": "EASY",
        "passRate": "83.77%",
        "problemsUrl": "https://leetcode.cn/problems/count-of-matches-in-tournament/",
        "solutionsUrl": "https://leetcode.cn/problems/count-of-matches-in-tournament/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，表示比赛中的队伍数。比赛遵循一种独特的赛制：</p>\n\n<ul>\n\t<li>如果当前队伍数是 <strong>偶数</strong> ，那么每支队伍都会与另一支队伍配对。总共进行 <code>n / 2</code> 场比赛，且产生 <code>n / 2</code> 支队伍进入下一轮。</li>\n\t<li>如果当前队伍数为 <strong>奇数</strong> ，那么将会随机轮空并晋级一支队伍，其余的队伍配对。总共进行 <code>(n - 1) / 2</code> 场比赛，且产生 <code>(n - 1) / 2 + 1</code> 支队伍进入下一轮。</li>\n</ul>\n\n<p>返回在比赛中进行的配对次数，直到决出获胜队伍为止。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 7\n<strong>输出：</strong>6\n<strong>解释：</strong>比赛详情：\n- 第 1 轮：队伍数 = 7 ，配对次数 = 3 ，4 支队伍晋级。\n- 第 2 轮：队伍数 = 4 ，配对次数 = 2 ，2 支队伍晋级。\n- 第 3 轮：队伍数 = 2 ，配对次数 = 1 ，决出 1 支获胜队伍。\n总配对次数 = 3 + 2 + 1 = 6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 14\n<strong>输出：</strong>13\n<strong>解释：</strong>比赛详情：\n- 第 1 轮：队伍数 = 14 ，配对次数 = 7 ，7 支队伍晋级。\n- 第 2 轮：队伍数 = 7 ，配对次数 = 3 ，4 支队伍晋级。 \n- 第 3 轮：队伍数 = 4 ，配对次数 = 2 ，2 支队伍晋级。\n- 第 4 轮：队伍数 = 2 ，配对次数 = 1 ，决出 1 支获胜队伍。\n总配对次数 = 7 + 3 + 2 + 1 = 13\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1689.十-二进制数的最少数目",
        "hardRate": "MEDIUM",
        "passRate": "86.56%",
        "problemsUrl": "https://leetcode.cn/problems/partitioning-into-minimum-number-of-deci-binary-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution",
        "problemsDesc": "<p>如果一个十进制数字不含任何前导零，且每一位上的数字不是 <code>0</code> 就是 <code>1</code> ，那么该数字就是一个 <strong>十-二进制数</strong> 。例如，<code>101</code> 和 <code>1100</code> 都是 <strong>十-二进制数</strong>，而 <code>112</code> 和 <code>3001</code> 不是。</p>\n\n<p>给你一个表示十进制整数的字符串 <code>n</code> ，返回和为 <code>n</code> 的 <strong>十-二进制数 </strong>的最少数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = \"32\"\n<strong>输出：</strong>3\n<strong>解释：</strong>10 + 11 + 11 = 32\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = \"82734\"\n<strong>输出：</strong>8\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = \"27346209830709182346\"\n<strong>输出：</strong>9\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>n</code> 仅由数字组成</li>\n\t<li><code>n</code> 不含任何前导零并总是表示正整数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1690.石子游戏 VII",
        "hardRate": "MEDIUM",
        "passRate": "55.75%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game-vii/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game-vii/solution",
        "problemsDesc": "<p>石子游戏中，爱丽丝和鲍勃轮流进行自己的回合，<strong>爱丽丝先开始</strong> 。</p>\n\n<p>有 <code>n</code> 块石子排成一排。每个玩家的回合中，可以从行中 <strong>移除</strong> 最左边的石头或最右边的石头，并获得与该行中剩余石头值之 <strong>和</strong> 相等的得分。当没有石头可移除时，得分较高者获胜。</p>\n\n<p>鲍勃发现他总是输掉游戏（可怜的鲍勃，他总是输），所以他决定尽力 <strong>减小得分的差值</strong> 。爱丽丝的目标是最大限度地 <strong>扩大得分的差值</strong> 。</p>\n\n<p>给你一个整数数组 <code>stones</code> ，其中 <code>stones[i]</code> 表示 <strong>从左边开始</strong> 的第 <code>i</code> 个石头的值，如果爱丽丝和鲍勃都 <strong>发挥出最佳水平</strong> ，请返回他们 <strong>得分的差值</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [5,3,1,4,2]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n- 爱丽丝移除 2 ，得分 5 + 3 + 1 + 4 = 13 。游戏情况：爱丽丝 = 13 ，鲍勃 = 0 ，石子 = [5,3,1,4] 。\n- 鲍勃移除 5 ，得分 3 + 1 + 4 = 8 。游戏情况：爱丽丝 = 13 ，鲍勃 = 8 ，石子 = [3,1,4] 。\n- 爱丽丝移除 3 ，得分 1 + 4 = 5 。游戏情况：爱丽丝 = 18 ，鲍勃 = 8 ，石子 = [1,4] 。\n- 鲍勃移除 1 ，得分 4 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [4] 。\n- 爱丽丝移除 4 ，得分 0 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [] 。\n得分的差值 18 - 12 = 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [7,90,5,1,100,10,10,2]\n<strong>输出：</strong>122</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == stones.length</code></li>\n\t<li><code>2 <= n <= 1000</code></li>\n\t<li><code>1 <= stones[i] <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1691.堆叠长方体的最大高度",
        "hardRate": "HARD",
        "passRate": "65.01%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-height-by-stacking-cuboids/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-height-by-stacking-cuboids/solution",
        "problemsDesc": "<p>给你 <code>n</code> 个长方体 <code>cuboids</code> ，其中第 <code>i</code> 个长方体的长宽高表示为 <code>cuboids[i] = [width<sub>i</sub>, length<sub>i</sub>, height<sub>i</sub>]</code>（<strong>下标从 0 开始</strong>）。请你从 <code>cuboids</code> 选出一个 <strong>子集</strong> ，并将它们堆叠起来。</p>\n\n<p>如果 <code>width<sub>i</sub> <= width<sub>j</sub></code> 且 <code>length<sub>i</sub> <= length<sub>j</sub></code> 且 <code>height<sub>i</sub> <= height<sub>j</sub></code> ，你就可以将长方体 <code>i</code> 堆叠在长方体 <code>j</code> 上。你可以通过旋转把长方体的长宽高重新排列，以将它放在另一个长方体上。</p>\n\n<p>返回 <strong>堆叠长方体</strong> <code>cuboids</code> 可以得到的 <strong>最大高度</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/12/image.jpg\" style=\"width: 420px; height: 299px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>cuboids = [[50,45,20],[95,37,53],[45,23,12]]\n<strong>输出：</strong>190\n<strong>解释：</strong>\n第 1 个长方体放在底部，53x37 的一面朝下，高度为 95 。\n第 0 个长方体放在中间，45x20 的一面朝下，高度为 50 。\n第 2 个长方体放在上面，23x12 的一面朝下，高度为 45 。\n总高度是 95 + 50 + 45 = 190 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>cuboids = [[38,25,45],[76,35,3]]\n<strong>输出：</strong>76\n<strong>解释：</strong>\n无法将任何长方体放在另一个上面。\n选择第 1 个长方体然后旋转它，使 35x3 的一面朝下，其高度为 76 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]]\n<strong>输出：</strong>102\n<strong>解释：</strong>\n重新排列长方体后，可以看到所有长方体的尺寸都相同。\n你可以把 11x7 的一面朝下，这样它们的高度就是 17 。\n堆叠长方体的最大高度为 6 * 17 = 102 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == cuboids.length</code></li>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>1 <= width<sub>i</sub>, length<sub>i</sub>, height<sub>i</sub> <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1692.计算分配糖果的不同方式",
        "hardRate": "HARD",
        "passRate": "66.11%",
        "problemsUrl": "https://leetcode.cn/problems/count-ways-to-distribute-candies/",
        "solutionsUrl": "https://leetcode.cn/problems/count-ways-to-distribute-candies/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1693.每天的领导和合伙人",
        "hardRate": "EASY",
        "passRate": "81.91%",
        "problemsUrl": "https://leetcode.cn/problems/daily-leads-and-partners/",
        "solutionsUrl": "https://leetcode.cn/problems/daily-leads-and-partners/solution",
        "problemsDesc": "<p>表：<code>DailySales</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| date_id     | date    |\n| make_name   | varchar |\n| lead_id     | int     |\n| partner_id  | int     |\n+-------------+---------+\n该表没有主键。\n该表包含日期、产品的名称，以及售给的领导和合伙人的编号。\n名称只包含小写英文字母。</pre>\n\n<p>&nbsp;</p>\n\n<p>写一条 SQL 语句，使得对于每一个&nbsp;<code>date_id</code>&nbsp;和&nbsp;<code>make_name</code>，返回<strong>不同</strong>的&nbsp;<code>lead_id</code>&nbsp;以及<strong>不同</strong>的&nbsp;<code>partner_id</code>&nbsp;的数量。</p>\n\n<p>按 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式如下示例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nDailySales 表：\n+-----------+-----------+---------+------------+\n| date_id   | make_name | lead_id | partner_id |\n+-----------+-----------+---------+------------+\n| 2020-12-8 | toyota    | 0       | 1          |\n| 2020-12-8 | toyota    | 1       | 0          |\n| 2020-12-8 | toyota    | 1       | 2          |\n| 2020-12-7 | toyota    | 0       | 2          |\n| 2020-12-7 | toyota    | 0       | 1          |\n| 2020-12-8 | honda     | 1       | 2          |\n| 2020-12-8 | honda     | 2       | 1          |\n| 2020-12-7 | honda     | 0       | 1          |\n| 2020-12-7 | honda     | 1       | 2          |\n| 2020-12-7 | honda     | 2       | 1          |\n+-----------+-----------+---------+------------+\n<strong>输出：</strong>\n+-----------+-----------+--------------+-----------------+\n| date_id   | make_name | unique_leads | unique_partners |\n+-----------+-----------+--------------+-----------------+\n| 2020-12-8 | toyota    | 2            | 3               |\n| 2020-12-7 | toyota    | 1            | 2               |\n| 2020-12-8 | honda     | 2            | 2               |\n| 2020-12-7 | honda     | 3            | 2               |\n+-----------+-----------+--------------+-----------------+\n<strong>解释：</strong>\n在 2020-12-8，丰田（toyota）有领导者 = [0, 1] 和合伙人 = [0, 1, 2] ，同时本田（honda）有领导者 = [1, 2] 和合伙人 = [1, 2]。\n在 2020-12-7，丰田（toyota）有领导者 = [0] 和合伙人 = [1, 2] ，同时本田（honda）有领导者 = [0, 1, 2] 和合伙人 = [1, 2]。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1694.重新格式化电话号码",
        "hardRate": "EASY",
        "passRate": "66.10%",
        "problemsUrl": "https://leetcode.cn/problems/reformat-phone-number/",
        "solutionsUrl": "https://leetcode.cn/problems/reformat-phone-number/solution",
        "problemsDesc": "<p>给你一个字符串形式的电话号码 <code>number</code> 。<code>number</code> 由数字、空格 <code>' '</code>、和破折号 <code>'-'</code> 组成。</p>\n\n<p>请你按下述方式重新格式化电话号码。</p>\n\n<ul>\n\t<li>首先，<strong>删除</strong> 所有的空格和破折号。</li>\n\t<li>其次，将数组从左到右 <strong>每 3 个一组</strong> 分块，<strong>直到 </strong>剩下 4 个或更少数字。剩下的数字将按下述规定再分块：\n\t<ul>\n\t\t<li>2 个数字：单个含 2 个数字的块。</li>\n\t\t<li>3 个数字：单个含 3 个数字的块。</li>\n\t\t<li>4 个数字：两个分别含 2 个数字的块。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>最后用破折号将这些块连接起来。注意，重新格式化过程中 <strong>不应该</strong> 生成仅含 1 个数字的块，并且 <strong>最多</strong> 生成两个含 2 个数字的块。</p>\n\n<p>返回格式化后的电话号码。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>number = \"1-23-45 6\"\n<strong>输出：</strong>\"123-456\"\n<strong>解释：</strong>数字是 \"123456\"\n步骤 1：共有超过 4 个数字，所以先取 3 个数字分为一组。第 1 个块是 \"123\" 。\n步骤 2：剩下 3 个数字，将它们放入单个含 3 个数字的块。第 2 个块是 \"456\" 。\n连接这些块后得到 \"123-456\" 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>number = \"123 4-567\"\n<strong>输出：</strong>\"123-45-67\"\n<strong>解释：</strong>数字是 \"1234567\".\n步骤 1：共有超过 4 个数字，所以先取 3 个数字分为一组。第 1 个块是 \"123\" 。\n步骤 2：剩下 4 个数字，所以将它们分成两个含 2 个数字的块。这 2 块分别是 \"45\" 和 \"67\" 。\n连接这些块后得到 \"123-45-67\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>number = \"123 4-5678\"\n<strong>输出：</strong>\"123-456-78\"\n<strong>解释：</strong>数字是 \"12345678\" 。\n步骤 1：第 1 个块 \"123\" 。\n步骤 2：第 2 个块 \"456\" 。\n步骤 3：剩下 2 个数字，将它们放入单个含 2 个数字的块。第 3 个块是 \"78\" 。\n连接这些块后得到 \"123-456-78\" 。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>number = \"12\"\n<strong>输出：</strong>\"12\"\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>number = \"--17-5 229 35-39475 \"\n<strong>输出：</strong>\"175-229-353-94-75\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= number.length <= 100</code></li>\n\t<li><code>number</code> 由数字和字符 <code>'-'</code> 及 <code>' '</code> 组成。</li>\n\t<li><code>number</code> 中至少含 <strong>2</strong> 个数字。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1695.删除子数组的最大得分",
        "hardRate": "MEDIUM",
        "passRate": "51.98%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-erasure-value/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-erasure-value/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>nums</code> ，请你从中删除一个含有 <strong>若干不同元素</strong> 的子数组<strong>。</strong>删除子数组的 <strong>得分</strong> 就是子数组各元素之 <strong>和</strong> 。</p>\n\n<p>返回 <strong>只删除一个</strong> 子数组可获得的 <strong>最大得分</strong><em> 。</em></p>\n\n<p>如果数组 <code>b</code> 是数组 <code>a</code> 的一个连续子序列，即如果它等于 <code>a[l],a[l+1],...,a[r]</code> ，那么它就是 <code>a</code> 的一个子数组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,2,4,5,6]\n<strong>输出：</strong>17\n<strong>解释：</strong>最优子数组是 [2,4,5,6]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,2,1,2,5,2,1,2,5]\n<strong>输出：</strong>8\n<strong>解释：</strong>最优子数组是 [5,2,1] 或 [1,2,5]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1696.跳跃游戏 VI",
        "hardRate": "MEDIUM",
        "passRate": "40.23%",
        "problemsUrl": "https://leetcode.cn/problems/jump-game-vi/",
        "solutionsUrl": "https://leetcode.cn/problems/jump-game-vi/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>\n\n<p>一开始你在下标 <code>0</code> 处。每一步，你最多可以往前跳 <code>k</code> 步，但你不能跳出数组的边界。也就是说，你可以从下标 <code>i</code> 跳到 <code>[i + 1， min(n - 1, i + k)]</code> <strong>包含</strong> 两个端点的任意位置。</p>\n\n<p>你的目标是到达数组最后一个位置（下标为 <code>n - 1</code> ），你的 <strong>得分</strong> 为经过的所有数字之和。</p>\n\n<p>请你返回你能得到的 <strong>最大得分</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [<strong>1</strong>,<strong>-1</strong>,-2,<strong>4</strong>,-7,<strong>3</strong>], k = 2\n<b>输出：</b>7\n<b>解释：</b>你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<strong>10</strong>,-5,-2,<strong>4</strong>,0,<strong>3</strong>], k = 3\n<b>输出：</b>17\n<b>解释：</b>你可以选择子序列 [10,4,3] （上面加粗数字），和为 17 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,-5,-20,4,-1,3,-6,-3], k = 2\n<b>输出：</b>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li> <code>1 <= nums.length, k <= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1697.检查边长度限制的路径是否存在",
        "hardRate": "HARD",
        "passRate": "64.92%",
        "problemsUrl": "https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/",
        "solutionsUrl": "https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/solution",
        "problemsDesc": "<p>给你一个 <code>n</code> 个点组成的无向图边集 <code>edgeList</code> ，其中 <code>edgeList[i] = [u<sub>i</sub>, v<sub>i</sub>, dis<sub>i</sub>]</code> 表示点 <code>u<sub>i</sub></code> 和点 <code>v<sub>i</sub></code> 之间有一条长度为 <code>dis<sub>i</sub></code> 的边。请注意，两个点之间可能有 <strong>超过一条边 </strong>。</p>\n\n<p>给你一个查询数组<code>queries</code> ，其中 <code>queries[j] = [p<sub>j</sub>, q<sub>j</sub>, limit<sub>j</sub>]</code> ，你的任务是对于每个查询 <code>queries[j]</code> ，判断是否存在从 <code>p<sub>j</sub></code> 到 <code>q<sub>j</sub></code><sub> </sub>的路径，且这条路径上的每一条边都 <strong>严格小于</strong> <code>limit<sub>j</sub></code> 。</p>\n\n<p>请你返回一个 <b>布尔数组</b><em> </em><code>answer</code><em> </em>，其中<em> </em><code>answer.length == queries.length</code> ，当 <code>queries[j]</code> 的查询结果为 <code>true</code> 时， <code>answer</code> 第<em> </em><code>j</code> 个值为<em> </em><code>true</code><em> </em>，否则为 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/19/h.png\" style=\"width: 267px; height: 262px;\" />\n<pre>\n<b>输入：</b>n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]\n<b>输出：</b>[false,true]\n<b>解释：</b>上图为给定的输入数据。注意到 0 和 1 之间有两条重边，分别为 2 和 16 。\n对于第一个查询，0 和 1 之间没有小于 2 的边，所以我们返回 false 。\n对于第二个查询，有一条路径（0 -> 1 -> 2）两条边都小于 5 ，所以这个查询我们返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/19/q.png\" style=\"width: 390px; height: 358px;\" />\n<pre>\n<b>输入：</b>n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]\n<b>输出：</b>[true,false]\n<b>解释：</b>上图为给定数据。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= edgeList.length, queries.length <= 10<sup>5</sup></code></li>\n\t<li><code>edgeList[i].length == 3</code></li>\n\t<li><code>queries[j].length == 3</code></li>\n\t<li><code>0 <= u<sub>i</sub>, v<sub>i</sub>, p<sub>j</sub>, q<sub>j</sub> <= n - 1</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n\t<li><code>p<sub>j</sub> != q<sub>j</sub></code></li>\n\t<li><code>1 <= dis<sub>i</sub>, limit<sub>j</sub> <= 10<sup>9</sup></code></li>\n\t<li>两个点之间可能有 <strong>多条</strong> 边。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1698.字符串的不同子字符串个数",
        "hardRate": "MEDIUM",
        "passRate": "55.32%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-distinct-substrings-in-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-distinct-substrings-in-a-string/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1699.两人之间的通话次数",
        "hardRate": "MEDIUM",
        "passRate": "76.43%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-calls-between-two-persons/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-calls-between-two-persons/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1700.无法吃午餐的学生数量",
        "hardRate": "EASY",
        "passRate": "73.19%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/solution",
        "problemsDesc": "<p>学校的自助午餐提供圆形和方形的三明治，分别用数字 <code>0</code> 和 <code>1</code> 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。<br>\n餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 <strong>栈</strong> 里，每一轮：</p>\n\n<ul>\n\t<li>如果队列最前面的学生 <strong>喜欢</strong> 栈顶的三明治，那么会 <strong>拿走它</strong> 并离开队列。</li>\n\t<li>否则，这名学生会 <strong>放弃这个三明治</strong> 并回到队列的尾部。</li>\n</ul>\n\n<p>这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。</p>\n\n<p>给你两个整数数组 <code>students</code> 和 <code>sandwiches</code> ，其中 <code>sandwiches[i]</code> 是栈里面第 <code>i<sup>​​​​​​</sup></code> 个三明治的类型（<code>i = 0</code> 是栈的顶部）， <code>students[j]</code> 是初始队列里第 <code>j<sup>​​​​​​</sup></code> 名学生对三明治的喜好（<code>j = 0</code> 是队列的最开始位置）。请你返回无法吃午餐的学生数量。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>students = [1,1,0,0], sandwiches = [0,1,0,1]\n<b>输出：</b>0<strong> \n解释：</strong>\n- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [1,0,0,1]。\n- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [0,0,1,1]。\n- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [0,1,1]，三明治栈为 sandwiches = [1,0,1]。\n- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [1,1,0]。\n- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [1,0]，三明治栈为 sandwiches = [0,1]。\n- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [0,1]。\n- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [1]，三明治栈为 sandwiches = [1]。\n- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = []，三明治栈为 sandwiches = []。\n所以所有学生都有三明治吃。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]\n<b>输出：</b>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= students.length, sandwiches.length &lt;= 100</code></li>\n\t<li><code>students.length == sandwiches.length</code></li>\n\t<li><code>sandwiches[i]</code> 要么是 <code>0</code> ，要么是 <code>1</code> 。</li>\n\t<li><code>students[i]</code> 要么是 <code>0</code> ，要么是 <code>1</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1701.平均等待时间",
        "hardRate": "MEDIUM",
        "passRate": "60.56%",
        "problemsUrl": "https://leetcode.cn/problems/average-waiting-time/",
        "solutionsUrl": "https://leetcode.cn/problems/average-waiting-time/solution",
        "problemsDesc": "<p>有一个餐厅，只有一位厨师。你有一个顾客数组 <code>customers</code> ，其中 <code>customers[i] = [arrival<sub>i</sub>, time<sub>i</sub>]</code> ：</p>\n\n<ul>\n\t<li><code>arrival<sub>i</sub></code> 是第 <code>i</code> 位顾客到达的时间，到达时间按 <strong>非递减</strong> 顺序排列。</li>\n\t<li><code>time<sub>i</sub></code> 是给第 <code>i</code> 位顾客做菜需要的时间。</li>\n</ul>\n\n<p>当一位顾客到达时，他将他的订单给厨师，厨师一旦空闲的时候就开始做这位顾客的菜。每位顾客会一直等待到厨师完成他的订单。厨师同时只能做一个人的订单。厨师会严格按照 <strong>订单给他的顺序</strong> 做菜。</p>\n\n<p>请你返回所有顾客需要等待的 <strong>平均 </strong>时间。与标准答案误差在 <code>10<sup>-5</sup></code> 范围以内，都视为正确结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>customers = [[1,2],[2,5],[4,3]]\n<b>输出：</b>5.00000\n<strong>解释：\n</strong>1) 第一位顾客在时刻 1 到达，厨师拿到他的订单并在时刻 1 立马开始做菜，并在时刻 3 完成，第一位顾客等待时间为 3 - 1 = 2 。\n2) 第二位顾客在时刻 2 到达，厨师在时刻 3 开始为他做菜，并在时刻 8 完成，第二位顾客等待时间为 8 - 2 = 6 。\n3) 第三位顾客在时刻 4 到达，厨师在时刻 8 开始为他做菜，并在时刻 11 完成，第三位顾客等待时间为 11 - 4 = 7 。\n平均等待时间为 (2 + 6 + 7) / 3 = 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>customers = [[5,2],[5,4],[10,3],[20,1]]\n<b>输出：</b>3.25000\n<strong>解释：\n</strong>1) 第一位顾客在时刻 5 到达，厨师拿到他的订单并在时刻 5 立马开始做菜，并在时刻 7 完成，第一位顾客等待时间为 7 - 5 = 2 。\n2) 第二位顾客在时刻 5 到达，厨师在时刻 7 开始为他做菜，并在时刻 11 完成，第二位顾客等待时间为 11 - 5 = 6 。\n3) 第三位顾客在时刻 10 到达，厨师在时刻 11 开始为他做菜，并在时刻 14 完成，第三位顾客等待时间为 14 - 10 = 4 。\n4) 第四位顾客在时刻 20 到达，厨师拿到他的订单并在时刻 20 立马开始做菜，并在时刻 21 完成，第四位顾客等待时间为 21 - 20 = 1 。\n平均等待时间为 (2 + 6 + 4 + 1) / 4 = 3.25 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= customers.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= arrival<sub>i</sub>, time<sub>i</sub> <= 10<sup>4</sup></code></li>\n\t<li><code>arrival<sub>i </sub><= arrival<sub>i+1</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1702.修改后的最大二进制字符串",
        "hardRate": "MEDIUM",
        "passRate": "48.30%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-binary-string-after-change/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-binary-string-after-change/solution",
        "problemsDesc": "<p>给你一个二进制字符串 <code>binary</code> ，它仅有 <code>0</code> 或者 <code>1</code> 组成。你可以使用下面的操作任意次对它进行修改：</p>\n\n<ul>\n\t<li>操作 1 ：如果二进制串包含子字符串 <code>\"00\"</code> ，你可以用 <code>\"10\"</code> 将其替换。\n\n\t<ul>\n\t\t<li>比方说， <code>\"<strong>00</strong>010\" -> \"<strong>10</strong>010\"</code></li>\n\t</ul>\n\t</li>\n\t<li>操作 2 ：如果二进制串包含子字符串 <code>\"10\"</code> ，你可以用 <code>\"01\"</code> 将其替换。\n\t<ul>\n\t\t<li>比方说， <code>\"000<strong>10</strong>\" -> \"000<strong>01</strong>\"</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回执行上述操作任意次以后能得到的 <strong>最大二进制字符串</strong> 。如果二进制字符串 <code>x</code> 对应的十进制数字大于二进制字符串 <code>y</code> 对应的十进制数字，那么我们称二进制字符串<em> </em><code>x</code><em> </em>大于二进制字符串<em> </em><code>y</code><em> </em>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>binary = \"000110\"\n<b>输出：</b>\"111011\"\n<b>解释：</b>一个可行的转换为：\n\"0001<strong>10</strong>\" -> \"0001<strong>01</strong>\" \n\"<strong>00</strong>0101\" -> \"<strong>10</strong>0101\" \n\"1<strong>00</strong>101\" -> \"1<strong>10</strong>101\" \n\"110<strong>10</strong>1\" -> \"110<strong>01</strong>1\" \n\"11<strong>00</strong>11\" -> \"11<strong>10</strong>11\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>binary = \"01\"\n<b>输出：</b>\"01\"\n<b>解释：</b>\"01\" 没办法进行任何转换。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= binary.length <= 10<sup>5</sup></code></li>\n\t<li><code>binary</code> 仅包含 <code>'0'</code> 和 <code>'1'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1703.得到连续 K 个 1 的最少相邻交换次数",
        "hardRate": "HARD",
        "passRate": "56.55%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-adjacent-swaps-for-k-consecutive-ones/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-adjacent-swaps-for-k-consecutive-ones/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。 <code>nums</code> 仅包含 <code>0</code> 和 <code>1</code> 。每一次移动，你可以选择 <strong>相邻</strong> 两个数字并将它们交换。</p>\n\n<p>请你返回使 <code>nums</code> 中包含 <code>k</code> 个 <strong>连续 </strong><code>1</code> 的 <strong>最少</strong> 交换次数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,0,0,1,0,1], k = 2\n<b>输出：</b>1\n<b>解释：</b>在第一次操作时，nums 可以变成 [1,0,0,0,<strong>1</strong>,<strong>1</strong>] 得到连续两个 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,0,0,0,0,0,1,1], k = 3\n<b>输出：</b>5\n<b>解释：</b>通过 5 次操作，最左边的 1 可以移到右边直到 nums 变为 [0,0,0,0,0,<strong>1</strong>,<strong>1</strong>,<strong>1</strong>] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [1,1,0,1], k = 2\n<b>输出：</b>0\n<b>解释：</b>nums 已经有连续 2 个 1 了。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> 要么是 <code>0</code> ，要么是 <code>1</code> 。</li>\n\t<li><code>1 &lt;= k &lt;= sum(nums)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1704.判断字符串的两半是否相似",
        "hardRate": "EASY",
        "passRate": "78.32%",
        "problemsUrl": "https://leetcode.cn/problems/determine-if-string-halves-are-alike/",
        "solutionsUrl": "https://leetcode.cn/problems/determine-if-string-halves-are-alike/solution",
        "problemsDesc": "<p>给你一个偶数长度的字符串 <code>s</code> 。将其拆分成长度相同的两半，前一半为 <code>a</code> ，后一半为 <code>b</code> 。</p>\n\n<p>两个字符串 <strong>相似</strong> 的前提是它们都含有相同数目的元音（<code>'a'</code>，<code>'e'</code>，<code>'i'</code>，<code>'o'</code>，<code>'u'</code>，<code>'A'</code>，<code>'E'</code>，<code>'I'</code>，<code>'O'</code>，<code>'U'</code>）。注意，<code>s</code> 可能同时含有大写和小写字母。</p>\n\n<p>如果<em> </em><code>a</code><em> </em>和<em> </em><code>b</code> 相似，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"book\"\n<strong>输出：</strong>true\n<strong>解释：</strong>a = \"b<strong>o</strong>\" 且 b = \"<strong>o</strong>k\" 。a 中有 1 个元音，b 也有 1 个元音。所以，a 和 b 相似。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"textbook\"\n<strong>输出：</strong>false\n<strong>解释：</strong>a = \"t<strong>e</strong>xt\" 且 b = \"b<strong>oo</strong>k\" 。a 中有 1 个元音，b 中有 2 个元音。因此，a 和 b 不相似。\n注意，元音 o 在 b 中出现两次，记为 2 个。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s.length</code> 是偶数</li>\n\t<li><code>s</code> 由 <strong>大写和小写</strong> 字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1705.吃苹果的最大数目",
        "hardRate": "MEDIUM",
        "passRate": "45.44%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-eaten-apples/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-eaten-apples/solution",
        "problemsDesc": "<p>有一棵特殊的苹果树，一连 <code>n</code> 天，每天都可以长出若干个苹果。在第 <code>i</code> 天，树上会长出 <code>apples[i]</code> 个苹果，这些苹果将会在 <code>days[i]</code> 天后（也就是说，第 <code>i + days[i]</code> 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 <code>apples[i] == 0</code> 且 <code>days[i] == 0</code> 表示。</p>\n\n<p>你打算每天 <strong>最多</strong> 吃一个苹果来保证营养均衡。注意，你可以在这 <code>n</code> 天之后继续吃苹果。</p>\n\n<p>给你两个长度为 <code>n</code> 的整数数组 <code>days</code> 和 <code>apples</code> ，返回你可以吃掉的苹果的最大数目<em>。</em></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>apples = [1,2,3,5,2], days = [3,2,1,4,2]\n<strong>输出：</strong>7\n<strong>解释：</strong>你可以吃掉 7 个苹果：\n- 第一天，你吃掉第一天长出来的苹果。\n- 第二天，你吃掉一个第二天长出来的苹果。\n- 第三天，你吃掉一个第二天长出来的苹果。过了这一天，第三天长出来的苹果就已经腐烂了。\n- 第四天到第七天，你吃的都是第四天长出来的苹果。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2]\n<strong>输出：</strong>5\n<strong>解释：</strong>你可以吃掉 5 个苹果：\n- 第一天到第三天，你吃的都是第一天长出来的苹果。\n- 第四天和第五天不吃苹果。\n- 第六天和第七天，你吃的都是第六天长出来的苹果。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>apples.length == n</code></li>\n\t<li><code>days.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= apples[i], days[i] &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li>只有在 <code>apples[i] = 0</code> 时，<code>days[i] = 0</code> 才成立</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1706.球会落何处",
        "hardRate": "MEDIUM",
        "passRate": "69.04%",
        "problemsUrl": "https://leetcode.cn/problems/where-will-the-ball-fall/",
        "solutionsUrl": "https://leetcode.cn/problems/where-will-the-ball-fall/solution",
        "problemsDesc": "<p>用一个大小为 <code>m x n</code> 的二维网格 <code>grid</code> 表示一个箱子。你有 <code>n</code> 颗球。箱子的顶部和底部都是开着的。</p>\n\n<p>箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。</p>\n\n<ul>\n\t<li>将球导向右侧的挡板跨过左上角和右下角，在网格中用 <code>1</code> 表示。</li>\n\t<li>将球导向左侧的挡板跨过右上角和左下角，在网格中用 <code>-1</code> 表示。</li>\n</ul>\n\n<p>在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 \"V\" 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。</p>\n\n<p>返回一个大小为 <code>n</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是球放在顶部的第 <code>i</code> 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/26/ball.jpg\" style=\"width: 500px; height: 385px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]\n<strong>输出：</strong>[1,-1,-1,-1,-1]\n<strong>解释：</strong>示例如图：\nb0 球开始放在第 0 列上，最终从箱子底部第 1 列掉出。\nb1 球开始放在第 1 列上，会卡在第 2、3 列和第 1 行之间的 \"V\" 形里。\nb2 球开始放在第 2 列上，会卡在第 2、3 列和第 0 行之间的 \"V\" 形里。\nb3 球开始放在第 3 列上，会卡在第 2、3 列和第 0 行之间的 \"V\" 形里。\nb4 球开始放在第 4 列上，会卡在第 2、3 列和第 1 行之间的 \"V\" 形里。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[-1]]\n<strong>输出：</strong>[-1]\n<strong>解释：</strong>球被卡在箱子左侧边上。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]\n<strong>输出：</strong>[0,1,2,3,4,-1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 <= m, n <= 100</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>1</code> 或 <code>-1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1707.与数组中元素的最大异或值",
        "hardRate": "HARD",
        "passRate": "50.94%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-xor-with-an-element-from-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-xor-with-an-element-from-array/solution",
        "problemsDesc": "<p>给你一个由非负整数组成的数组 <code>nums</code> 。另有一个查询数组 <code>queries</code> ，其中 <code>queries[i] = [x<sub>i</sub>, m<sub>i</sub>]</code> 。</p>\n\n<p>第 <code>i</code> 个查询的答案是 <code>x<sub>i</sub></code> 和任何 <code>nums</code> 数组中不超过 <code>m<sub>i</sub></code> 的元素按位异或（<code>XOR</code>）得到的最大值。换句话说，答案是 <code>max(nums[j] XOR x<sub>i</sub>)</code> ，其中所有 <code>j</code> 均满足 <code>nums[j] &lt;= m<sub>i</sub></code> 。如果 <code>nums</code> 中的所有元素都大于 <code>m<sub>i</sub></code>，最终答案就是 <code>-1</code> 。</p>\n\n<p>返回一个整数数组<em> </em><code>answer</code><em> </em>作为查询的答案，其中<em> </em><code>answer.length == queries.length</code><em> </em>且<em> </em><code>answer[i]</code><em> </em>是第<em> </em><code>i</code><em> </em>个查询的答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]\n<strong>输出：</strong>[3,3,7]\n<strong>解释：</strong>\n1) 0 和 1 是仅有的两个不超过 1 的整数。0 XOR 3 = 3 而 1 XOR 3 = 2 。二者中的更大值是 3 。\n2) 1 XOR 2 = 3.\n3) 5 XOR 2 = 7.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]\n<strong>输出：</strong>[15,-1,5]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>0 &lt;= nums[j], x<sub>i</sub>, m<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1708.长度为 K 的最大子数组",
        "hardRate": "EASY",
        "passRate": "67.08%",
        "problemsUrl": "https://leetcode.cn/problems/largest-subarray-length-k/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-subarray-length-k/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1709.访问日期之间最大的空档期",
        "hardRate": "MEDIUM",
        "passRate": "69.04%",
        "problemsUrl": "https://leetcode.cn/problems/biggest-window-between-visits/",
        "solutionsUrl": "https://leetcode.cn/problems/biggest-window-between-visits/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1710.卡车上的最大单元数",
        "hardRate": "EASY",
        "passRate": "73.43%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-units-on-a-truck/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-units-on-a-truck/solution",
        "problemsDesc": "<p>请你将一些箱子装在 <strong>一辆卡车</strong> 上。给你一个二维数组 <code>boxTypes</code> ，其中 <code>boxTypes[i] = [numberOfBoxes<sub>i</sub>, numberOfUnitsPerBox<sub>i</sub>]</code> ：</p>\n\n<ul>\n\t<li><code>numberOfBoxes<sub>i</sub></code> 是类型 <code>i</code> 的箱子的数量。</li>\n\t<li><code>numberOfUnitsPerBox<sub>i</sub></code><sub> </sub>是类型 <code>i</code> 每个箱子可以装载的单元数量。</li>\n</ul>\n\n<p>整数 <code>truckSize</code> 表示卡车上可以装载 <strong>箱子</strong> 的 <strong>最大数量</strong> 。只要箱子数量不超过 <code>truckSize</code> ，你就可以选择任意箱子装到卡车上。</p>\n\n<p>返回卡车可以装载 <strong>单元</strong> 的 <strong>最大</strong> 总数<em>。</em></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4\n<strong>输出：</strong>8\n<strong>解释：</strong>箱子的情况如下：\n- 1 个第一类的箱子，里面含 3 个单元。\n- 2 个第二类的箱子，每个里面含 2 个单元。\n- 3 个第三类的箱子，每个里面含 1 个单元。\n可以选择第一类和第二类的所有箱子，以及第三类的一个箱子。\n单元总数 = (1 * 3) + (2 * 2) + (1 * 1) = 8</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10\n<strong>输出：</strong>91\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= boxTypes.length <= 1000</code></li>\n\t<li><code>1 <= numberOfBoxes<sub>i</sub>, numberOfUnitsPerBox<sub>i</sub> <= 1000</code></li>\n\t<li><code>1 <= truckSize <= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1711.大餐计数",
        "hardRate": "MEDIUM",
        "passRate": "35.97%",
        "problemsUrl": "https://leetcode.cn/problems/count-good-meals/",
        "solutionsUrl": "https://leetcode.cn/problems/count-good-meals/solution",
        "problemsDesc": "<p><strong>大餐</strong> 是指 <strong>恰好包含两道不同餐品</strong> 的一餐，其美味程度之和等于 2 的幂。</p>\n\n<p>你可以搭配 <strong>任意</strong> 两道餐品做一顿大餐。</p>\n\n<p>给你一个整数数组 <code>deliciousness</code> ，其中 <code>deliciousness[i]</code> 是第 <code>i<sup>​​​​​​</sup>​​​​</code>​​​​ 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 <strong>大餐</strong> 的数量。结果需要对 <code>10<sup>9</sup> + 7</code> 取余。</p>\n\n<p>注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>deliciousness = [1,3,5,7,9]\n<strong>输出：</strong>4\n<strong>解释：</strong>大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。\n它们各自的美味程度之和分别为 4 、8 、8 和 16 ，都是 2 的幂。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>deliciousness = [1,1,1,3,3,3,7]\n<strong>输出：</strong>15\n<strong>解释：</strong>大餐的美味程度组合为 3 种 (1,1) ，9 种 (1,3) ，和 3 种 (1,7) 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= deliciousness.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= deliciousness[i] <= 2<sup>20</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1712.将数组分成三个子数组的方案数",
        "hardRate": "MEDIUM",
        "passRate": "28.55%",
        "problemsUrl": "https://leetcode.cn/problems/ways-to-split-array-into-three-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/ways-to-split-array-into-three-subarrays/solution",
        "problemsDesc": "<p>我们称一个分割整数数组的方案是 <strong>好的</strong> ，当它满足：</p>\n\n<ul>\n\t<li>数组被分成三个 <strong>非空</strong> 连续子数组，从左至右分别命名为 <code>left</code> ， <code>mid</code> ， <code>right</code> 。</li>\n\t<li><code>left</code> 中元素和小于等于 <code>mid</code> 中元素和，<code>mid</code> 中元素和小于等于 <code>right</code> 中元素和。</li>\n</ul>\n\n<p>给你一个 <strong>非负</strong> 整数数组 <code>nums</code> ，请你返回 <strong>好的</strong> 分割 <code>nums</code> 方案数目。由于答案可能会很大，请你将结果对 <code>10<sup>9 </sup>+ 7</code> 取余后返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,1,1]\n<b>输出：</b>1\n<b>解释：</b>唯一一种好的分割方案是将 nums 分成 [1] [1] [1] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,2,2,5,0]\n<b>输出：</b>3\n<b>解释：</b>nums 总共有 3 种好的分割方案：\n[1] [2] [2,2,5,0]\n[1] [2,2] [2,5,0]\n[1,2] [2,2] [5,0]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,2,1]\n<b>输出：</b>0\n<b>解释：</b>没有好的分割方案。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1713.得到子序列的最少操作次数",
        "hardRate": "HARD",
        "passRate": "49.92%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-a-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-a-subsequence/solution",
        "problemsDesc": "<p>给你一个数组 <code>target</code> ，包含若干 <strong>互不相同</strong> 的整数，以及另一个整数数组 <code>arr</code> ，<code>arr</code> <strong>可能</strong> 包含重复元素。</p>\n\n<p>每一次操作中，你可以在 <code>arr</code> 的任意位置插入任一整数。比方说，如果 <code>arr = [1,4,1,2]</code> ，那么你可以在中间添加 <code>3</code> 得到 <code>[1,4,<strong>3</strong>,1,2]</code> 。你可以在数组最开始或最后面添加整数。</p>\n\n<p>请你返回 <strong>最少</strong> 操作次数，使得<em> </em><code>target</code><em> </em>成为 <code>arr</code> 的一个子序列。</p>\n\n<p>一个数组的 <strong>子序列</strong> 指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，<code>[2,7,4]</code> 是 <code>[4,<strong>2</strong>,3,<strong>7</strong>,2,1,<strong>4</strong>]</code> 的子序列（加粗元素），但 <code>[2,4,2]</code> 不是子序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>target = [5,1,3], <code>arr</code> = [9,4,2,3,4]\n<b>输出：</b>2\n<b>解释：</b>你可以添加 5 和 1 ，使得 arr 变为 [<strong>5</strong>,9,4,<strong>1</strong>,2,3,4] ，target 为 arr 的子序列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>target = [6,4,8,1,3,2], <code>arr</code> = [4,7,6,2,3,8,6,1]\n<b>输出：</b>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target.length, arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= target[i], arr[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>target</code> 不包含任何重复元素。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1714.数组中特殊等间距元素的和",
        "hardRate": "HARD",
        "passRate": "60.12%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-special-evenly-spaced-elements-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-special-evenly-spaced-elements-in-array/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1715.苹果和橘子的个数",
        "hardRate": "MEDIUM",
        "passRate": "71.80%",
        "problemsUrl": "https://leetcode.cn/problems/count-apples-and-oranges/",
        "solutionsUrl": "https://leetcode.cn/problems/count-apples-and-oranges/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1716.计算力扣银行的钱",
        "hardRate": "EASY",
        "passRate": "69.07%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-money-in-leetcode-bank/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-money-in-leetcode-bank/solution",
        "problemsDesc": "<p>Hercy 想要为购买第一辆车存钱。他 <strong>每天</strong> 都往力扣银行里存钱。</p>\n\n<p>最开始，他在周一的时候存入 <code>1</code> 块钱。从周二到周日，他每天都比前一天多存入 <code>1</code> 块钱。在接下来每一个周一，他都会比 <strong>前一个周一</strong> 多存入 <code>1</code> 块钱。<span style=\"\"> </span></p>\n\n<p>给你 <code>n</code> ，请你返回在第 <code>n</code> 天结束的时候他在力扣银行总共存了多少块钱。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 4\n<b>输出：</b>10\n<b>解释：</b>第 4 天后，总额为 1 + 2 + 3 + 4 = 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 10\n<b>输出：</b>37\n<b>解释：</b>第 10 天后，总额为 (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37 。注意到第二个星期一，Hercy 存入 2 块钱。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>n = 20\n<b>输出：</b>96\n<b>解释：</b>第 20 天后，总额为 (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1717.删除子字符串的最大得分",
        "hardRate": "MEDIUM",
        "passRate": "46.16%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-from-removing-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-from-removing-substrings/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和两个整数 <code>x</code> 和 <code>y</code> 。你可以执行下面两种操作任意次。</p>\n\n<ul>\n\t<li>删除子字符串 <code>\"ab\"</code> 并得到 <code>x</code> 分。\n\n\t<ul>\n\t\t<li>比方说，从 <code>\"c<strong>ab</strong>xbae\"</code> 删除 <code>ab</code> ，得到 <code>\"cxbae\"</code> 。</li>\n\t</ul>\n\t</li>\n\t<li>删除子字符串<code>\"ba\"</code> 并得到 <code>y</code> 分。\n\t<ul>\n\t\t<li>比方说，从 <code>\"cabx<strong>ba</strong>e\"</code> 删除 <code>ba</code> ，得到 <code>\"cabxe\"</code> 。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请返回对 <code>s</code> 字符串执行上面操作若干次能得到的最大得分。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"cdbcbbaaabab\", x = 4, y = 5\n<b>输出：</b>19\n<strong>解释：</strong>\n- 删除 \"cdbcbbaaa<strong>ba</strong>b\" 中加粗的 \"ba\" ，得到 s = \"cdbcbbaaab\" ，加 5 分。\n- 删除 \"cdbcbbaa<strong>ab</strong>\" 中加粗的 \"ab\" ，得到 s = \"cdbcbbaa\" ，加 4 分。\n- 删除 \"cdbcb<strong>ba</strong>a\" 中加粗的 \"ba\" ，得到 s = \"cdbcba\" ，加 5 分。\n- 删除 \"cdbc<strong>ba</strong>\" 中加粗的 \"ba\" ，得到 s = \"cdbc\" ，加 5 分。\n总得分为 5 + 4 + 5 + 5 = 19 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"aabbaaxybbaabb\", x = 5, y = 4\n<b>输出：</b>20\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= x, y &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1718.构建字典序最大的可行序列",
        "hardRate": "MEDIUM",
        "passRate": "50.89%",
        "problemsUrl": "https://leetcode.cn/problems/construct-the-lexicographically-largest-valid-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-the-lexicographically-largest-valid-sequence/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，请你找到满足下面条件的一个序列：</p>\n\n<ul>\n\t<li>整数 <code>1</code> 在序列中只出现一次。</li>\n\t<li><code>2</code> 到 <code>n</code> 之间每个整数都恰好出现两次。</li>\n\t<li>对于每个 <code>2</code> 到 <code>n</code> 之间的整数 <code>i</code> ，两个 <code>i</code> 之间出现的距离恰好为 <code>i</code> 。</li>\n</ul>\n\n<p>序列里面两个数 <code>a[i]</code> 和 <code>a[j]</code> 之间的 <strong>距离</strong> ，我们定义为它们下标绝对值之差 <code>|j - i|</code> 。</p>\n\n<p>请你返回满足上述条件中 <strong>字典序最大</strong> 的序列。题目保证在给定限制条件下，一定存在解。</p>\n\n<p>一个序列 <code>a</code> 被认为比序列 <code>b</code> （两者长度相同）字典序更大的条件是： <code>a</code> 和 <code>b</code> 中第一个不一样的数字处，<code>a</code> 序列的数字比 <code>b</code> 序列的数字大。比方说，<code>[0,1,9,0]</code> 比 <code>[0,1,5,6]</code> 字典序更大，因为第一个不同的位置是第三个数字，且 <code>9</code> 比 <code>5</code> 大。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 3\n<b>输出：</b>[3,1,2,3,2]\n<b>解释：</b>[2,3,2,1,3] 也是一个可行的序列，但是 [3,1,2,3,2] 是字典序最大的序列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 5\n<b>输出：</b>[5,3,1,4,3,5,2,4,2]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1719.重构一棵树的方案数",
        "hardRate": "HARD",
        "passRate": "69.03%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-reconstruct-a-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-reconstruct-a-tree/solution",
        "problemsDesc": "<p>给你一个数组 <code>pairs</code> ，其中 <code>pairs[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> ，并且满足：</p>\n\n<ul>\n\t<li><code>pairs</code> 中没有重复元素</li>\n\t<li><code>x<sub>i</sub> < y<sub>i</sub></code></li>\n</ul>\n\n<p>令 <code>ways</code> 为满足下面条件的有根树的方案数：</p>\n\n<ul>\n\t<li>树所包含的所有节点值都在 <code>pairs</code> 中。</li>\n\t<li>一个数对 <code>[x<sub>i</sub>, y<sub>i</sub>]</code> 出现在 <code>pairs</code> 中 <strong>当且仅当</strong><strong> </strong><code>x<sub>i</sub></code> 是 <code>y<sub>i</sub></code> 的祖先或者 <code>y<sub>i</sub></code> 是 <code>x<sub>i</sub></code><sub> </sub>的祖先。</li>\n\t<li><strong>注意：</strong>构造出来的树不一定是二叉树。</li>\n</ul>\n\n<p>两棵树被视为不同的方案当存在至少一个节点在两棵树中有不同的父节点。</p>\n\n<p>请你返回：</p>\n\n<ul>\n\t<li>如果 <code>ways == 0</code> ，返回 <code>0</code> 。</li>\n\t<li>如果 <code>ways == 1</code> ，返回 <code>1</code> 。</li>\n\t<li>如果 <code>ways > 1</code> ，返回 <code>2</code> 。</li>\n</ul>\n\n<p>一棵 <strong>有根树</strong> 指的是只有一个根节点的树，所有边都是从根往外的方向。</p>\n\n<p>我们称从根到一个节点路径上的任意一个节点（除去节点本身）都是该节点的 <strong>祖先</strong> 。根节点没有祖先。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/09/trees2.png\" style=\"width: 208px; height: 221px;\" />\n<pre>\n<b>输入：</b>pairs = [[1,2],[2,3]]\n<b>输出：</b>1\n<b>解释：</b>如上图所示，有且只有一个符合规定的有根树。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/09/tree.png\" style=\"width: 234px; height: 241px;\" />\n<pre>\n<b>输入：</b>pairs = [[1,2],[2,3],[1,3]]\n<b>输出：</b>2\n<b>解释：</b>有多个符合规定的有根树，其中三个如上图所示。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>pairs = [[1,2],[2,3],[2,4],[1,5]]\n<b>输出：</b>0\n<b>解释：</b>没有符合规定的有根树。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= pairs.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= x<sub>i </sub>< y<sub>i</sub> <= 500</code></li>\n\t<li><code>pairs</code> 中的元素互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1720.解码异或后的数组",
        "hardRate": "EASY",
        "passRate": "85.94%",
        "problemsUrl": "https://leetcode.cn/problems/decode-xored-array/",
        "solutionsUrl": "https://leetcode.cn/problems/decode-xored-array/solution",
        "problemsDesc": "<p><strong>未知</strong> 整数数组 <code>arr</code> 由 <code>n</code> 个非负整数组成。</p>\n\n<p>经编码后变为长度为 <code>n - 1</code> 的另一个整数数组 <code>encoded</code> ，其中 <code>encoded[i] = arr[i] XOR arr[i + 1]</code> 。例如，<code>arr = [1,0,2,1]</code> 经编码后得到 <code>encoded = [1,2,3]</code> 。</p>\n\n<p>给你编码后的数组 <code>encoded</code> 和原数组 <code>arr</code> 的第一个元素 <code>first</code>（<code>arr[0]</code>）。</p>\n\n<p>请解码返回原数组 <code>arr</code> 。可以证明答案存在并且是唯一的。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>encoded = [1,2,3], first = 1\n<strong>输出：</strong>[1,0,2,1]\n<strong>解释：</strong>若 arr = [1,0,2,1] ，那么 first = 1 且 encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>encoded = [6,2,7,3], first = 4\n<strong>输出：</strong>[4,2,0,7,4]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 10<sup>4</sup></code></li>\n\t<li><code>encoded.length == n - 1</code></li>\n\t<li><code>0 <= encoded[i] <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= first <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1721.交换链表中的节点",
        "hardRate": "MEDIUM",
        "passRate": "63.63%",
        "problemsUrl": "https://leetcode.cn/problems/swapping-nodes-in-a-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/swapping-nodes-in-a-linked-list/solution",
        "problemsDesc": "<p>给你链表的头节点 <code>head</code> 和一个整数 <code>k</code> 。</p>\n\n<p><strong>交换</strong> 链表正数第 <code>k</code> 个节点和倒数第 <code>k</code> 个节点的值后，返回链表的头节点（链表 <strong>从 1 开始索引</strong>）。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/10/linked1.jpg\" style=\"width: 722px; height: 202px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], k = 2\n<strong>输出：</strong>[1,4,3,2,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [7,9,6,6,7,8,3,0,9,5], k = 5\n<strong>输出：</strong>[7,9,6,6,8,7,3,0,9,5]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1], k = 1\n<strong>输出：</strong>[1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2], k = 1\n<strong>输出：</strong>[2,1]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,3], k = 2\n<strong>输出：</strong>[1,2,3]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目是 <code>n</code></li>\n\t<li><code>1 <= k <= n <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= Node.val <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1722.执行交换操作后的最小汉明距离",
        "hardRate": "MEDIUM",
        "passRate": "51.03%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-hamming-distance-after-swap-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-hamming-distance-after-swap-operations/solution",
        "problemsDesc": "<p>给你两个整数数组 <code>source</code> 和 <code>target</code> ，长度都是 <code>n</code> 。还有一个数组 <code>allowedSwaps</code> ，其中每个 <code>allowedSwaps[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示你可以交换数组 <code>source</code> 中下标为 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code>（<strong>下标从 0 开始</strong>）的两个元素。注意，你可以按 <strong>任意</strong> 顺序 <strong>多次</strong> 交换一对特定下标指向的元素。</p>\n\n<p>相同长度的两个数组 <code>source</code> 和 <code>target</code> 间的 <strong>汉明距离</strong> 是元素不同的下标数量。形式上，其值等于满足 <code>source[i] != target[i]</code> （<strong>下标从 0 开始</strong>）的下标 <code>i</code>（<code>0 &lt;= i &lt;= n-1</code>）的数量。</p>\n\n<p>在对数组 <code>source</code> 执行 <strong>任意</strong> 数量的交换操作后，返回 <code>source</code> 和 <code>target</code> 间的 <strong>最小汉明距离</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]]\n<strong>输出：</strong>1\n<strong>解释：</strong>source 可以按下述方式转换：\n- 交换下标 0 和 1 指向的元素：source = [<strong>2</strong>,<strong>1</strong>,3,4]\n- 交换下标 2 和 3 指向的元素：source = [2,1,<strong>4</strong>,<strong>3</strong>]\nsource 和 target 间的汉明距离是 1 ，二者有 1 处元素不同，在下标 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = []\n<strong>输出：</strong>2\n<strong>解释：</strong>不能对 source 执行交换操作。\nsource 和 target 间的汉明距离是 2 ，二者有 2 处元素不同，在下标 1 和下标 2 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>source = [5,1,2,4,3], target = [1,5,4,2,3], allowedSwaps = [[0,4],[4,2],[1,3],[1,4]]\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == source.length == target.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= source[i], target[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= allowedSwaps.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>allowedSwaps[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1723.完成所有工作的最短时间",
        "hardRate": "HARD",
        "passRate": "50.86%",
        "problemsUrl": "https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/",
        "solutionsUrl": "https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>jobs</code> ，其中 <code>jobs[i]</code> 是完成第 <code>i</code> 项工作要花费的时间。</p>\n\n<p>请你将这些工作分配给 <code>k</code> 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 <strong>工作时间</strong> 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 <strong>最大工作时间</strong> 得以 <strong>最小化</strong> 。</p>\n\n<p>返回分配方案中尽可能 <strong>最小</strong> 的 <strong>最大工作时间</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>jobs = [3,2,3], k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>给每位工人分配一项工作，最大工作时间是 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>jobs = [1,2,4,7,8], k = 2\n<strong>输出：</strong>11\n<strong>解释：</strong>按下述方式分配工作：\n1 号工人：1、2、8（工作时间 = 1 + 2 + 8 = 11）\n2 号工人：4、7（工作时间 = 4 + 7 = 11）\n最大工作时间是 11 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= k <= jobs.length <= 12</code></li>\n\t<li><code>1 <= jobs[i] <= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1724.检查边长度限制的路径是否存在 II",
        "hardRate": "HARD",
        "passRate": "58.40%",
        "problemsUrl": "https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1725.可以形成最大正方形的矩形数目",
        "hardRate": "EASY",
        "passRate": "82.80%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-rectangles-that-can-form-the-largest-square/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-rectangles-that-can-form-the-largest-square/solution",
        "problemsDesc": "<p>给你一个数组 <code>rectangles</code> ，其中 <code>rectangles[i] = [l<sub>i</sub>, w<sub>i</sub>]</code> 表示第 <code>i</code> 个矩形的长度为 <code>l<sub>i</sub></code> 、宽度为 <code>w<sub>i</sub></code> 。</p>\n\n<p>如果存在 <code>k</code> 同时满足 <code>k <= l<sub>i</sub></code> 和 <code>k <= w<sub>i</sub></code> ，就可以将第 <code>i</code> 个矩形切成边长为 <code>k</code> 的正方形。例如，矩形 <code>[4,6]</code> 可以切成边长最大为 <code>4</code> 的正方形。</p>\n\n<p>设 <code>maxLen</code> 为可以从矩形数组 <code>rectangles</code> 切分得到的 <strong>最大正方形</strong> 的边长。</p>\n\n<p>请你统计有多少个矩形能够切出边长为<em> </em><code>maxLen</code> 的正方形，并返回矩形 <strong>数目</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rectangles = [[5,8],[3,9],[5,12],[16,5]]\n<strong>输出：</strong>3\n<strong>解释：</strong>能从每个矩形中切出的最大正方形边长分别是 [5,3,5,5] 。\n最大正方形的边长为 5 ，可以由 3 个矩形切分得到。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rectangles = [[2,3],[3,7],[4,3],[3,7]]\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= rectangles.length <= 1000</code></li>\n\t<li><code>rectangles[i].length == 2</code></li>\n\t<li><code>1 <= l<sub>i</sub>, w<sub>i</sub> <= 10<sup>9</sup></code></li>\n\t<li><code>l<sub>i</sub> != w<sub>i</sub></code></li>\n</ul>\n",
        "isPlus": false
    }
]