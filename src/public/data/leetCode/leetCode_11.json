[
    {
        "problemsName": " 3001.合并排序链表",
        "hardRate": "HARD",
        "passRate": "63.99%",
        "problemsUrl": "https://leetcode.cn/problems/vvXgSW/",
        "solutionsUrl": "https://leetcode.cn/problems/vvXgSW/solution",
        "problemsDesc": "<p>给定一个链表数组，每个链表都已经按升序排列。</p>\n\n<p>请将所有链表合并到一个升序链表中，返回合并后的链表。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>lists = [[1,4,5],[1,3,4],[2,6]]\n<strong>输出：</strong>[1,1,2,3,4,4,5,6]\n<strong>解释：</strong>链表数组如下：\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\n将它们合并到一个有序链表中得到。\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>lists = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>lists = [[]]\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>k == lists.length</code></li>\n\t<li><code>0 &lt;= k &lt;= 10^4</code></li>\n\t<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>\n\t<li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li>\n\t<li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li>\n\t<li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 23&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/merge-k-sorted-lists/\">https://leetcode-cn.com/problems/merge-k-sorted-lists/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3002.所有子集",
        "hardRate": "MEDIUM",
        "passRate": "85.28%",
        "problemsUrl": "https://leetcode.cn/problems/TVdhkn/",
        "solutionsUrl": "https://leetcode.cn/problems/TVdhkn/solution",
        "problemsDesc": "<p>给定一个整数数组&nbsp;<code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>\n\n<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>[[],[0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n\t<li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 78&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/subsets/\">https://leetcode-cn.com/problems/subsets/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3003.含有 k 个元素的组合",
        "hardRate": "MEDIUM",
        "passRate": "83.25%",
        "problemsUrl": "https://leetcode.cn/problems/uUsW3B/",
        "solutionsUrl": "https://leetcode.cn/problems/uUsW3B/solution",
        "problemsDesc": "<p>给定两个整数 <code>n</code> 和 <code>k</code>，返回 <code>1 ... n</code> 中所有可能的 <code>k</code> 个数的组合。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;n = 4, k = 2\n<strong>输出:</strong>\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;n = 1, k = 1\n<strong>输出: </strong>[[1]]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 77&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/combinations/\">https://leetcode-cn.com/problems/combinations/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3004.允许重复选择元素的组合",
        "hardRate": "MEDIUM",
        "passRate": "80.73%",
        "problemsUrl": "https://leetcode.cn/problems/Ygoe9J/",
        "solutionsUrl": "https://leetcode.cn/problems/Ygoe9J/solution",
        "problemsDesc": "<p>给定一个<strong>无重复元素</strong>的正整数数组&nbsp;<code>candidates</code>&nbsp;和一个正整数&nbsp;<code>target</code>&nbsp;，找出&nbsp;<code>candidates</code>&nbsp;中所有可以使数字和为目标数&nbsp;<code>target</code>&nbsp;的唯一组合。</p>\n\n<p><code>candidates</code>&nbsp;中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是不同的。&nbsp;</p>\n\n<p>对于给定的输入，保证和为&nbsp;<code>target</code> 的唯一组合数少于 <code>150</code> 个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入: </strong>candidates = <code>[2,3,6,7], </code>target = <code>7</code>\n<strong>输出: </strong>[[7],[2,2,3]]\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入: </strong>candidates = [2,3,5]<code>, </code>target = 8\n<strong>输出: </strong>[[2,2,2,2],[2,3,3],[3,5]]</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入: </strong>candidates = <code>[2], </code>target = <span style=\"white-space: pre-wrap;\">1</span>\n<strong>输出: </strong>[]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入: </strong>candidates = <code>[1], </code>target = <code>1</code>\n<strong>输出: </strong>[[1]]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入: </strong>candidates = <code>[1], </code>target = <code>2</code>\n<strong>输出: </strong>[[1,1]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= candidates.length &lt;= 30</code></li>\n\t<li><code>1 &lt;= candidates[i] &lt;= 200</code></li>\n\t<li><code>candidate</code> 中的每个元素都是独一无二的。</li>\n\t<li><code>1 &lt;= target &lt;= 500</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 39&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/combination-sum/\">https://leetcode-cn.com/problems/combination-sum/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3005.含有重复元素集合的组合",
        "hardRate": "MEDIUM",
        "passRate": "65.93%",
        "problemsUrl": "https://leetcode.cn/problems/4sjJUc/",
        "solutionsUrl": "https://leetcode.cn/problems/4sjJUc/solution",
        "problemsDesc": "<p>给定一个可能有重复数字的整数数组&nbsp;<code>candidates</code>&nbsp;和一个目标数&nbsp;<code>target</code>&nbsp;，找出&nbsp;<code>candidates</code>&nbsp;中所有可以使数字和为&nbsp;<code>target</code>&nbsp;的组合。</p>\n\n<p><code>candidates</code>&nbsp;中的每个数字在每个组合中只能使用一次，解集不能包含重复的组合。&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> candidates =&nbsp;<code>[10,1,2,7,6,1,5]</code>, target =&nbsp;<code>8</code>,\n<strong>输出:</strong>\n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> candidates =&nbsp;[2,5,2,1,2], target =&nbsp;5,\n<strong>输出:</strong>\n[\n[1,2,2],\n[5]\n]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;candidates.length &lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;candidates[i] &lt;= 50</code></li>\n\t<li><code>1 &lt;= target &lt;= 30</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 40&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/combination-sum-ii/\">https://leetcode-cn.com/problems/combination-sum-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3006.没有重复元素集合的全排列",
        "hardRate": "MEDIUM",
        "passRate": "85.81%",
        "problemsUrl": "https://leetcode.cn/problems/VvJkup/",
        "solutionsUrl": "https://leetcode.cn/problems/VvJkup/solution",
        "problemsDesc": "<p>给定一个不含重复数字的整数数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。可以 <strong>按任意顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1]\n<strong>输出：</strong>[[0,1],[1,0]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1]\n<strong>输出：</strong>[[1]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 6</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n\t<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 46&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/permutations/\">https://leetcode-cn.com/problems/permutations/</a>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3007.含有重复元素集合的全排列 ",
        "hardRate": "MEDIUM",
        "passRate": "69.36%",
        "problemsUrl": "https://leetcode.cn/problems/7p8L0Z/",
        "solutionsUrl": "https://leetcode.cn/problems/7p8L0Z/solution",
        "problemsDesc": "<p>给定一个可包含重复数字的整数集合&nbsp;<code>nums</code> ，<strong>按任意顺序</strong> 返回它所有不重复的全排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,2]\n<strong>输出：</strong>\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 8</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 47&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/permutations-ii/\">https://leetcode-cn.com/problems/permutations-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3008.生成匹配的括号",
        "hardRate": "MEDIUM",
        "passRate": "84.96%",
        "problemsUrl": "https://leetcode.cn/problems/IDBivT/",
        "solutionsUrl": "https://leetcode.cn/problems/IDBivT/solution",
        "problemsDesc": "<p>正整数&nbsp;<code>n</code>&nbsp;代表生成括号的对数，请设计一个函数，用于能够生成所有可能的并且 <strong>有效的 </strong>括号组合。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>[&quot;()&quot;]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 22&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/generate-parentheses/\">https://leetcode-cn.com/problems/generate-parentheses/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3009.分割回文子字符串",
        "hardRate": "MEDIUM",
        "passRate": "75.65%",
        "problemsUrl": "https://leetcode.cn/problems/M99OJA/",
        "solutionsUrl": "https://leetcode.cn/problems/M99OJA/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code> ，请将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> ，返回 s 所有可能的分割方案。</p>\n\n<p><meta charset=\"UTF-8\" /><strong>回文串</strong>&nbsp;是正着读和反着读都一样的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s =<strong> </strong>&quot;google&quot;\n<strong>输出：</strong>[[&quot;g&quot;,&quot;o&quot;,&quot;o&quot;,&quot;g&quot;,&quot;l&quot;,&quot;e&quot;],[&quot;g&quot;,&quot;oo&quot;,&quot;g&quot;,&quot;l&quot;,&quot;e&quot;],[&quot;goog&quot;,&quot;l&quot;,&quot;e&quot;]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;aab&quot;\n<strong>输出：</strong>[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;a&quot;\n<strong>输出：</strong>[[&quot;a&quot;]]</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 16</code></li>\n\t<li><code>s </code>仅由小写英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 131&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/palindrome-partitioning/\">https://leetcode-cn.com/problems/palindrome-partitioning/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3010.复原 IP ",
        "hardRate": "MEDIUM",
        "passRate": "63.19%",
        "problemsUrl": "https://leetcode.cn/problems/0on3uN/",
        "solutionsUrl": "https://leetcode.cn/problems/0on3uN/solution",
        "problemsDesc": "<p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能从&nbsp;<code>s</code> 获得的 <strong>有效 IP 地址 </strong>。你可以按任何顺序返回答案。</p>\n\n<p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>&#39;.&#39;</code> 分隔。</p>\n\n<p>例如：&quot;0.1.2.201&quot; 和 &quot;192.168.1.1&quot; 是 <strong>有效</strong> IP 地址，但是 &quot;0.011.255.245&quot;、&quot;192.168.1.312&quot; 和 &quot;192.168@1.1&quot; 是 <strong>无效</strong> IP 地址。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;25525511135&quot;\n<strong>输出：</strong>[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;0000&quot;\n<strong>输出：</strong>[&quot;0.0.0.0&quot;]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;1111&quot;\n<strong>输出：</strong>[&quot;1.1.1.1&quot;]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;010010&quot;\n<strong>输出：</strong>[&quot;0.10.0.10&quot;,&quot;0.100.1.0&quot;]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;10203040&quot;\n<strong>输出：</strong>[&quot;10.20.30.40&quot;,&quot;102.0.30.40&quot;,&quot;10.203.0.40&quot;]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 3000</code></li>\n\t<li><code>s</code> 仅由数字组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 93&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/restore-ip-addresses/\">https://leetcode-cn.com/problems/restore-ip-addresses/</a>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3011.爬楼梯的最少成本",
        "hardRate": "EASY",
        "passRate": "72.35%",
        "problemsUrl": "https://leetcode.cn/problems/GzCJIP/",
        "solutionsUrl": "https://leetcode.cn/problems/GzCJIP/solution",
        "problemsDesc": "<p>数组的每个下标作为一个阶梯，第 <code>i</code> 个阶梯对应着一个非负数的体力花费值&nbsp;<code>cost[i]</code>（下标从 <code>0</code> 开始）。</p>\n\n<p>每当爬上一个阶梯都要花费对应的体力值，一旦支付了相应的体力值，就可以选择向上爬一个阶梯或者爬两个阶梯。</p>\n\n<p>请找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>cost = [10, 15, 20]\n<strong>输出：</strong>15\n<strong>解释：</strong>最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。\n</pre>\n\n<p><strong>&nbsp;示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\n<strong>输出：</strong>6\n<strong>解释：</strong>最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= cost.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= cost[i] &lt;= 999</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 746&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/min-cost-climbing-stairs/\">https://leetcode-cn.com/problems/min-cost-climbing-stairs/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3012.房屋偷盗",
        "hardRate": "MEDIUM",
        "passRate": "60.55%",
        "problemsUrl": "https://leetcode.cn/problems/Gu0c2T/",
        "solutionsUrl": "https://leetcode.cn/problems/Gu0c2T/solution",
        "problemsDesc": "<p>一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>\n\n<p>给定一个代表每个房屋存放金额的非负整数数组 <code>nums</code>&nbsp;，请计算<strong>&nbsp;不触动警报装置的情况下 </strong>，一夜之内能够偷窃到的最高金额。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums =<strong> </strong>[1,2,3,1]\n<strong>输出：</strong>4\n<strong>解释：</strong>偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n&nbsp;    偷窃到的最高金额 = 1 + 3 = 4 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums =<strong> </strong>[2,7,9,3,1]\n<strong>输出：</strong>12\n<strong>解释：</strong>偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n&nbsp;    偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 400</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 198&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/house-robber/\">https://leetcode-cn.com/problems/house-robber/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3013.环形房屋偷盗",
        "hardRate": "MEDIUM",
        "passRate": "48.85%",
        "problemsUrl": "https://leetcode.cn/problems/PzWKhm/",
        "solutionsUrl": "https://leetcode.cn/problems/PzWKhm/solution",
        "problemsDesc": "<p>一个专业的小偷，计划偷窃一个环形街道上沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>\n\n<p>给定一个代表每个房屋存放金额的非负整数数组 <code>nums</code> ，请计算&nbsp;<strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,2]\n<strong>输出：</strong>3\n<strong>解释：</strong>你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,1]\n<strong>输出：</strong>4\n<strong>解释：</strong>你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。\n&nbsp;    偷窃到的最高金额 = 1 + 3 = 4 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 213&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/house-robber-ii/\">https://leetcode-cn.com/problems/house-robber-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3014.粉刷房子",
        "hardRate": "MEDIUM",
        "passRate": "77.52%",
        "problemsUrl": "https://leetcode.cn/problems/JEj789/",
        "solutionsUrl": "https://leetcode.cn/problems/JEj789/solution",
        "problemsDesc": "<p>假如有一排房子，共 <code>n</code> 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。</p>\n\n<p>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个&nbsp;<code>n x 3</code><em>&nbsp;</em>的正整数矩阵 <code>costs</code> 来表示的。</p>\n\n<p>例如，<code>costs[0][0]</code> 表示第 0 号房子粉刷成红色的成本花费；<code>costs[1][2]</code>&nbsp;表示第 1 号房子粉刷成绿色的花费，以此类推。</p>\n\n<p>请计算出粉刷完所有房子最少的花费成本。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>costs = [[17,2,17],[16,16,5],[14,3,19]]\n<strong>输出: </strong>10\n<strong>解释: </strong>将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色<strong>。</strong>\n&nbsp;    最少花费: 2 + 5 + 3 = 10。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>costs = [[7,6,2]]\n<strong>输出: 2</strong>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>costs.length == n</code></li>\n\t<li><code>costs[i].length == 3</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= costs[i][j] &lt;= 20</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 256&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/paint-house/\">https://leetcode-cn.com/problems/paint-house/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3015.翻转字符",
        "hardRate": "MEDIUM",
        "passRate": "68.15%",
        "problemsUrl": "https://leetcode.cn/problems/cyJERH/",
        "solutionsUrl": "https://leetcode.cn/problems/cyJERH/solution",
        "problemsDesc": "<p>如果一个由&nbsp;<code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code>&nbsp;组成的字符串，是以一些 <code>&#39;0&#39;</code>（可能没有 <code>&#39;0&#39;</code>）后面跟着一些 <code>&#39;1&#39;</code>（也可能没有 <code>&#39;1&#39;</code>）的形式组成的，那么该字符串是&nbsp;<strong>单调递增&nbsp;</strong>的。</p>\n\n<p>我们给出一个由字符 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code>&nbsp;组成的字符串 <font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"caret-color: rgb(199, 37, 78); font-size: 12.600000381469727px; background-color: rgb(249, 242, 244);\">s</span></font>，我们可以将任何&nbsp;<code>&#39;0&#39;</code> 翻转为&nbsp;<code>&#39;1&#39;</code>&nbsp;或者将&nbsp;<code>&#39;1&#39;</code>&nbsp;翻转为&nbsp;<code>&#39;0&#39;</code>。</p>\n\n<p>返回使 <font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"caret-color: rgb(199, 37, 78); font-size: 12.600000381469727px; background-color: rgb(249, 242, 244);\">s</span></font>&nbsp;<strong>单调递增&nbsp;</strong>的最小翻转次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s =<strong> </strong>&quot;00110&quot;\n<strong>输出：</strong>1\n<strong>解释：</strong>我们翻转最后一位得到 00111.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s =<strong> </strong>&quot;010110&quot;\n<strong>输出：</strong>2\n<strong>解释：</strong>我们翻转得到 011111，或者是 000111。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s =<strong> </strong>&quot;00011000&quot;\n<strong>输出：</strong>2\n<strong>解释：</strong>我们翻转得到 00000000。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20000</code></li>\n\t<li><font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"caret-color: rgb(199, 37, 78); font-size: 12.600000381469727px; background-color: rgb(249, 242, 244);\">s</span></font> 中只包含字符&nbsp;<code>&#39;0&#39;</code>&nbsp;和&nbsp;<code>&#39;1&#39;</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 926&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/flip-string-to-monotone-increasing/\">https://leetcode-cn.com/problems/flip-string-to-monotone-increasing/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3016.最长斐波那契数列",
        "hardRate": "MEDIUM",
        "passRate": "58.37%",
        "problemsUrl": "https://leetcode.cn/problems/Q91FMA/",
        "solutionsUrl": "https://leetcode.cn/problems/Q91FMA/solution",
        "problemsDesc": "<p>如果序列&nbsp;<code>X_1, X_2, ..., X_n</code>&nbsp;满足下列条件，就说它是&nbsp;<em>斐波那契式&nbsp;</em>的：</p>\n\n<ul>\n\t<li><code>n &gt;= 3</code></li>\n\t<li>对于所有&nbsp;<code>i + 2 &lt;= n</code>，都有&nbsp;<code>X_i + X_{i+1} = X_{i+2}</code></li>\n</ul>\n\n<p>给定一个<strong>严格递增</strong>的正整数数组形成序列 <code>arr</code>&nbsp;，找到 <code>arr</code> 中最长的斐波那契式的子序列的长度。如果一个不存在，返回&nbsp;&nbsp;0 。</p>\n\n<p><em>（回想一下，子序列是从原序列&nbsp; <code>arr</code> 中派生出来的，它从 <code>arr</code> 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如，&nbsp;<code>[3, 5, 8]</code>&nbsp;是&nbsp;<code>[3, 4, 5, 6, 7, 8]</code>&nbsp;的一个子序列）</em></p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>arr =<strong> </strong>[1,2,3,4,5,6,7,8]\n<strong>输出: </strong>5\n<strong>解释: </strong>最长的斐波那契式子序列为 [1,2,3,5,8] 。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入: </strong>arr =<strong> </strong>[1,3,7,11,12,14,18]\n<strong>输出: </strong>3\n<strong>解释</strong>: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= arr.length &lt;= 1000</code></li>\n\t<li>\n\t<p><code>1 &lt;= arr[i] &lt; arr[i + 1] &lt;= 10^9</code></p>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 873&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/\">https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3017.最少回文分割",
        "hardRate": "HARD",
        "passRate": "57.68%",
        "problemsUrl": "https://leetcode.cn/problems/omKAoA/",
        "solutionsUrl": "https://leetcode.cn/problems/omKAoA/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code>，请将 <code>s</code> 分割成一些子串，使每个子串都是回文串。</p>\n\n<p>返回符合要求的 <strong>最少分割次数</strong> 。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;aab&quot;\n<strong>输出：</strong>1\n<strong>解释：</strong>只需一次分割就可将&nbsp;s<em> </em>分割成 [&quot;aa&quot;,&quot;b&quot;] 这样两个回文子串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;a&quot;\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;ab&quot;\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 132&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/palindrome-partitioning-ii/\">https://leetcode-cn.com/problems/palindrome-partitioning-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3018.最长公共子序列",
        "hardRate": "MEDIUM",
        "passRate": "65.55%",
        "problemsUrl": "https://leetcode.cn/problems/qJnOS7/",
        "solutionsUrl": "https://leetcode.cn/problems/qJnOS7/solution",
        "problemsDesc": "<p>给定两个字符串&nbsp;<code>text1</code> 和&nbsp;<code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>\n\n<p>一个字符串的&nbsp;<strong>子序列</strong><em>&nbsp;</em>是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>\n\n<ul>\n\t<li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li>\n</ul>\n\n<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; \n<strong>输出：</strong>3  \n<strong>解释：</strong>最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>text1 = &quot;abc&quot;, text2 = &quot;abc&quot;\n<strong>输出：</strong>3\n<strong>解释：</strong>最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>text1 = &quot;abc&quot;, text2 = &quot;def&quot;\n<strong>输出：</strong>0\n<strong>解释：</strong>两个字符串没有公共子序列，返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li>\n\t<li><code>text1</code> 和&nbsp;<code>text2</code> 仅由小写英文字符组成。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 1143&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/longest-common-subsequence/\">https://leetcode-cn.com/problems/longest-common-subsequence/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3019.字符串交织",
        "hardRate": "MEDIUM",
        "passRate": "48.04%",
        "problemsUrl": "https://leetcode.cn/problems/IY6buf/",
        "solutionsUrl": "https://leetcode.cn/problems/IY6buf/solution",
        "problemsDesc": "<p>给定三个字符串&nbsp;<code>s1</code>、<code>s2</code>、<code>s3</code>，请判断&nbsp;<code>s3</code>&nbsp;能不能由&nbsp;<code>s1</code>&nbsp;和&nbsp;<code>s2</code><em>&nbsp;</em><strong>交织（交错）</strong>&nbsp;组成。</p>\n\n<p>两个字符串 <code>s</code> 和 <code>t</code> <strong>交织</strong>&nbsp;的定义与过程如下，其中每个字符串都会被分割成若干 <strong>非空</strong> 子字符串：</p>\n\n<ul>\n\t<li><code>s = s<sub>1</sub> + s<sub>2</sub> + ... + s<sub>n</sub></code></li>\n\t<li><code>t = t<sub>1</sub> + t<sub>2</sub> + ... + t<sub>m</sub></code></li>\n\t<li><code>|n - m| &lt;= 1</code></li>\n\t<li><b>交织</b> 是 <code>s<sub>1</sub> + t<sub>1</sub> + s<sub>2</sub> + t<sub>2</sub> + s<sub>3</sub> + t<sub>3</sub> + ...</code> 或者 <code>t<sub>1</sub> + s<sub>1</sub> + t<sub>2</sub> + s<sub>2</sub> + t<sub>3</sub> + s<sub>3</sub> + ...</code></li>\n</ul>\n\n<p><strong>提示：</strong><code>a + b</code> 意味着字符串 <code>a</code> 和 <code>b</code> 连接。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg\" style=\"width: 561px; height: 203px;\" /></p>\n\n<pre>\n<strong>输入：</strong>s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = &quot;&quot;, s2 = &quot;&quot;, s3 = &quot;&quot;\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s1.length, s2.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= s3.length &lt;= 200</code></li>\n\t<li><code>s1</code>、<code>s2</code>、和 <code>s3</code> 都由小写英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 97&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/interleaving-string/\">https://leetcode-cn.com/problems/interleaving-string/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3020.子序列的数目",
        "hardRate": "HARD",
        "passRate": "55.31%",
        "problemsUrl": "https://leetcode.cn/problems/21dk04/",
        "solutionsUrl": "https://leetcode.cn/problems/21dk04/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code><strong> </strong>和一个字符串 <code>t</code> ，计算在 <code>s</code> 的子序列中 <code>t</code> 出现的个数。</p>\n\n<p>字符串的一个 <strong>子序列</strong> 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，<code>&quot;ACE&quot;</code>&nbsp;是&nbsp;<code>&quot;ABCDE&quot;</code>&nbsp;的一个子序列，而&nbsp;<code>&quot;AEC&quot;</code>&nbsp;不是）</p>\n\n<p>题目数据保证答案符合 32 位带符号整数范围。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;<code>\n<strong>输出</strong></code><strong>：</strong><code>3\n</code><strong>解释：</strong>\n如下图所示, 有 3 种可以从 s 中得到 <code>&quot;rabbit&quot; 的方案</code>。\n<code><strong><u>rabb</u></strong>b<strong><u>it</u></strong></code>\n<code><strong><u>ra</u></strong>b<strong><u>bbit</u></strong></code>\n<code><strong><u>rab</u></strong>b<strong><u>bit</u></strong></code></pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;babgbag&quot;, t = &quot;bag&quot;\n<code><strong>输出</strong></code><strong>：</strong><code>5\n</code><strong>解释：</strong>\n如下图所示, 有 5 种可以从 s 中得到 <code>&quot;bag&quot; 的方案</code>。 \n<code><strong><u>ba</u></strong>b<u><strong>g</strong></u>bag</code>\n<code><strong><u>ba</u></strong>bgba<strong><u>g</u></strong></code>\n<code><u><strong>b</strong></u>abgb<strong><u>ag</u></strong></code>\n<code>ba<u><strong>b</strong></u>gb<u><strong>ag</strong></u></code>\n<code>babg<strong><u>bag</u></strong></code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length, t.length &lt;= 1000</code></li>\n\t<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 115&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/distinct-subsequences/\">https://leetcode-cn.com/problems/distinct-subsequences/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3021.路径的数目",
        "hardRate": "MEDIUM",
        "passRate": "76.20%",
        "problemsUrl": "https://leetcode.cn/problems/2AoeFn/",
        "solutionsUrl": "https://leetcode.cn/problems/2AoeFn/solution",
        "problemsDesc": "<p>一个机器人位于一个 <code>m x n</code><em>&nbsp;</em>网格的左上角 （起始点在下图中标记为 &ldquo;Start&rdquo; ）。</p>\n\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 &ldquo;Finish&rdquo; ）。</p>\n\n<p>问总共有多少条不同的路径？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png\" /></p>\n\n<pre>\n<strong>输入：</strong>m = 3, n = 7\n<strong>输出：</strong>28</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 3, n = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -&gt; 向下 -&gt; 向下\n2. 向下 -&gt; 向下 -&gt; 向右\n3. 向下 -&gt; 向右 -&gt; 向下\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 7, n = 3\n<strong>输出：</strong>28\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 3, n = 3\n<strong>输出：</strong>6</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li>题目数据保证答案小于等于 <code>2 * 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 62&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/unique-paths/\">https://leetcode-cn.com/problems/unique-paths/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3022.最小路径之和",
        "hardRate": "MEDIUM",
        "passRate": "73.46%",
        "problemsUrl": "https://leetcode.cn/problems/0i0mDW/",
        "solutionsUrl": "https://leetcode.cn/problems/0i0mDW/solution",
        "problemsDesc": "<p>给定一个包含非负整数的 <code><em>m</em>&nbsp;x&nbsp;<em>n</em></code>&nbsp;网格&nbsp;<code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>\n\n<p><strong>说明：</strong>一个机器人每次只能向下或者向右移动一步。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg\" style=\"width: 242px; height: 242px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,3,1],[1,5,1],[4,2,1]]\n<strong>输出：</strong>7\n<strong>解释：</strong>因为路径 1&rarr;3&rarr;1&rarr;1&rarr;1 的总和最小。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,2,3],[4,5,6]]\n<strong>输出：</strong>12\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 64&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/minimum-path-sum/\">https://leetcode-cn.com/problems/minimum-path-sum/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3023.三角形中最小路径之和",
        "hardRate": "MEDIUM",
        "passRate": "74.37%",
        "problemsUrl": "https://leetcode.cn/problems/IlPe0q/",
        "solutionsUrl": "https://leetcode.cn/problems/IlPe0q/solution",
        "problemsDesc": "<p>给定一个三角形 <code>triangle</code> ，找出自顶向下的最小路径和。</p>\n\n<p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点 </strong>在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标 <code>i</code> 或 <code>i + 1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\n<strong>输出：</strong>11\n<strong>解释：</strong>如下面简图所示：\n   <strong>2</strong>\n  <strong>3</strong> 4\n 6 <strong>5</strong> 7\n4 <strong>1</strong> 8 3\n自顶向下的最小路径和为&nbsp;11（即，2&nbsp;+&nbsp;3&nbsp;+&nbsp;5&nbsp;+&nbsp;1&nbsp;= 11）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>triangle = [[-10]]\n<strong>输出：</strong>-10\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= triangle.length &lt;= 200</code></li>\n\t<li><code>triangle[0].length == 1</code></li>\n\t<li><code>triangle[i].length == triangle[i - 1].length + 1</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= triangle[i][j] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你可以只使用 <code>O(n)</code>&nbsp;的额外空间（<code>n</code> 为三角形的总行数）来解决这个问题吗？</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 120&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/triangle/\">https://leetcode-cn.com/problems/triangle/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3024.分割等和子集",
        "hardRate": "EASY",
        "passRate": "49.34%",
        "problemsUrl": "https://leetcode.cn/problems/NUPfPr/",
        "solutionsUrl": "https://leetcode.cn/problems/NUPfPr/solution",
        "problemsDesc": "<p>给定一个非空的正整数数组 <code>nums</code> ，请判断能否将这些数字分成元素和相等的两部分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5,11,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>nums<strong> </strong>可以分割成 [1, 5, 5] 和 [11] 。</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,5]\n<strong>输出：</strong>false\n<strong>解释：</strong>nums<strong> </strong>不可以分为和相等的两部分\n</pre>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 416&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/partition-equal-subset-sum/\">https://leetcode-cn.com/problems/partition-equal-subset-sum/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3025.加减的目标值",
        "hardRate": "MEDIUM",
        "passRate": "56.78%",
        "problemsUrl": "https://leetcode.cn/problems/YaVDxD/",
        "solutionsUrl": "https://leetcode.cn/problems/YaVDxD/solution",
        "problemsDesc": "<p>给定一个正整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>\n\n<p>向数组中的每个整数前添加&nbsp;<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>\n\n<ul>\n\t<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li>\n</ul>\n\n<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,1,1], target = 3\n<strong>输出：</strong>5\n<strong>解释：</strong>一共有 5 种方法让最终目标和为 3 。\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1], target = 1\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 20</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= target &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 494&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/target-sum/\">https://leetcode-cn.com/problems/target-sum/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3026.最少的硬币数目",
        "hardRate": "MEDIUM",
        "passRate": "50.96%",
        "problemsUrl": "https://leetcode.cn/problems/gaM7Ch/",
        "solutionsUrl": "https://leetcode.cn/problems/gaM7Ch/solution",
        "problemsDesc": "<p>给定不同面额的硬币 <code>coins</code> 和一个总金额 <code>amount</code>。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回&nbsp;<code>-1</code>。</p>\n\n<p>你可以认为每种硬币的数量是无限的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = <code>[1, 2, 5]</code>, amount = <code>11</code>\n<strong>输出：</strong><code>3</code> \n<strong>解释：</strong>11 = 5 + 5 + 1</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = <code>[2]</code>, amount = <code>3</code>\n<strong>输出：</strong>-1</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = [1], amount = 0\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = [1], amount = 1\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = [1], amount = 2\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= coins.length &lt;= 12</code></li>\n\t<li><code>1 &lt;= coins[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>0 &lt;= amount &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 322&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/coin-change/\">https://leetcode-cn.com/problems/coin-change/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3027.排列的数目",
        "hardRate": "MEDIUM",
        "passRate": "57.53%",
        "problemsUrl": "https://leetcode.cn/problems/D0F0SV/",
        "solutionsUrl": "https://leetcode.cn/problems/D0F0SV/solution",
        "problemsDesc": "<p>给定一个由 <strong>不同</strong>&nbsp;正整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。数组中的数字可以在一次排列中出现任意次，但是顺序不同的序列被视作不同的组合。</p>\n\n<p>题目数据保证答案符合 32 位整数范围。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3], target = 4\n<strong>输出：</strong>7\n<strong>解释：</strong>\n所有可能的组合为：\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n请注意，顺序不同的序列被视作不同的组合。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [9], target = 3\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li>\n\t<li><code>1 &lt;= target &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 377&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/combination-sum-iv/\">https://leetcode-cn.com/problems/combination-sum-iv/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3028.岛屿的最大面积",
        "hardRate": "MEDIUM",
        "passRate": "69.65%",
        "problemsUrl": "https://leetcode.cn/problems/ZL6zAn/",
        "solutionsUrl": "https://leetcode.cn/problems/ZL6zAn/solution",
        "problemsDesc": "<p>给定一个由&nbsp;<code>0</code> 和 <code>1</code> 组成的非空二维数组&nbsp;<code>grid</code>&nbsp;，用来表示海洋岛屿地图。</p>\n\n<p>一个&nbsp;<strong>岛屿</strong>&nbsp;是由一些相邻的&nbsp;<code>1</code>&nbsp;(代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在水平或者竖直方向上相邻。你可以假设&nbsp;<code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p>\n\n<p>找到给定的二维数组中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626667010-nSGPXz-image.png\" style=\"width: 452px; \" /></p>\n\n<pre>\n<strong>输入: </strong>grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\n<strong>输出: </strong>6\n<strong>解释: </strong>对于上面这个给定矩阵应返回&nbsp;<code>6</code>。注意答案不应该是 <code>11</code> ，因为岛屿只能包含水平或垂直的四个方向的 <code>1</code> 。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>grid = [[0,0,0,0,0,0,0,0]]\n<strong>输出: </strong>0</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>grid[i][j] is either 0 or 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 695&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/max-area-of-island/\">https://leetcode-cn.com/problems/max-area-of-island/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3029.二分图",
        "hardRate": "MEDIUM",
        "passRate": "55.28%",
        "problemsUrl": "https://leetcode.cn/problems/vEAB3K/",
        "solutionsUrl": "https://leetcode.cn/problems/vEAB3K/solution",
        "problemsDesc": "<p>存在一个 <strong>无向图</strong> ，图中有 <code>n</code> 个节点。其中每个节点都有一个介于 <code>0</code> 到 <code>n - 1</code> 之间的唯一编号。</p>\n\n<p>给定一个二维数组 <code>graph</code>&nbsp;，表示图，其中 <code>graph[u]</code> 是一个节点数组，由节点 <code>u</code> 的邻接节点组成。形式上，对于&nbsp;<code>graph[u]</code> 中的每个 <code>v</code> ，都存在一条位于节点 <code>u</code> 和节点 <code>v</code> 之间的无向边。该无向图同时具有以下属性：</p>\n\n<ul>\n\t<li>不存在自环（<code>graph[u]</code> 不包含 <code>u</code>）。</li>\n\t<li>不存在平行边（<code>graph[u]</code> 不包含重复值）。</li>\n\t<li>如果 <code>v</code> 在 <code>graph[u]</code> 内，那么 <code>u</code> 也应该在 <code>graph[v]</code> 内（该图是无向图）</li>\n\t<li>这个图可能不是连通图，也就是说两个节点 <code>u</code> 和 <code>v</code> 之间可能不存在一条连通彼此的路径。</li>\n</ul>\n\n<p><strong>二分图</strong> 定义：如果能将一个图的节点集合分割成两个独立的子集 <code>A</code> 和 <code>B</code> ，并使图中的每一条边的两个节点一个来自 <code>A</code> 集合，一个来自 <code>B</code> 集合，就将这个图称为 <strong>二分图</strong> 。</p>\n\n<p>如果图是二分图，返回 <code>true</code><em> </em>；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg\" style=\"width: 222px; height: 222px;\" /></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\n<strong>输出：</strong>false\n<strong>解释：</strong><code>不能将节点分割成两个独立的子集，</code>以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg\" style=\"width: 222px; height: 222px;\" /></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,3],[0,2],[1,3],[0,2]]\n<strong>输出：</strong>true\n<strong>解释：</strong><code>可以将节点分成两组: {0, 2} 和 {1, 3} 。</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>graph.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= graph[u].length &lt; n</code></li>\n\t<li><code>0 &lt;= graph[u][i] &lt;= n - 1</code></li>\n\t<li><code>graph[u]</code> 不会包含 <code>u</code></li>\n\t<li><code>graph[u]</code> 的所有值 <strong>互不相同</strong></li>\n\t<li>如果 <code>graph[u]</code> 包含 <code>v</code>，那么 <code>graph[v]</code> 也会包含 <code>u</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 785&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/is-graph-bipartite/\">https://leetcode-cn.com/problems/is-graph-bipartite/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3030.矩阵中的距离",
        "hardRate": "MEDIUM",
        "passRate": "51.06%",
        "problemsUrl": "https://leetcode.cn/problems/2bCMpM/",
        "solutionsUrl": "https://leetcode.cn/problems/2bCMpM/solution",
        "problemsDesc": "<p>给定一个由 <code>0</code> 和 <code>1</code> 组成的矩阵 <code>mat</code>&nbsp;，请输出一个大小相同的矩阵，其中每一个格子是 <code>mat</code> 中对应位置元素到最近的 <code>0</code> 的距离。</p>\n\n<p>两个相邻元素间的距离为 <code>1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626667201-NCWmuP-image.png\" style=\"width: 150px; \" /></p>\n\n<pre>\n<strong>输入：</strong>mat =<strong> </strong>[[0,0,0],[0,1,0],[0,0,0]]\n<strong>输出：</strong>[[0,0,0],[0,1,0],[0,0,0]]\n</pre>\n\n<p><b>示例 2：</b></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626667205-xFxIeK-image.png\" style=\"width: 150px; \" /></p>\n\n<pre>\n<b>输入：</b>mat =<b> </b>[[0,0,0],[0,1,0],[1,1,1]]\n<strong>输出：</strong>[[0,0,0],[0,1,0],[1,2,1]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>mat[i][j] is either 0 or 1.</code></li>\n\t<li><code>mat</code> 中至少有一个 <code>0&nbsp;</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 542&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/01-matrix/\">https://leetcode-cn.com/problems/01-matrix/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3031.单词演变",
        "hardRate": "HARD",
        "passRate": "59.51%",
        "problemsUrl": "https://leetcode.cn/problems/om3reC/",
        "solutionsUrl": "https://leetcode.cn/problems/om3reC/solution",
        "problemsDesc": "<p>在字典（单词列表）&nbsp;<code>wordList</code> 中，从单词 <code>beginWord</code><em>&nbsp;</em>和 <code>endWord</code> 的 <strong>转换序列 </strong>是一个按下述规格形成的序列：</p>\n\n<ul>\n\t<li>序列中第一个单词是 <code>beginWord</code> 。</li>\n\t<li>序列中最后一个单词是 <code>endWord</code> 。</li>\n\t<li>每次转换只能改变一个字母。</li>\n\t<li>转换过程中的中间单词必须是字典&nbsp;<code>wordList</code> 中的单词。</li>\n</ul>\n\n<p>给定两个长度相同但内容不同的单词<em> </em><code>beginWord</code><em>&nbsp;</em>和 <code>endWord</code> 和一个字典 <code>wordList</code> ，找到从&nbsp;<code>beginWord</code> 到&nbsp;<code>endWord</code> 的 <strong>最短转换序列</strong> 中的 <strong>单词数目</strong> 。如果不存在这样的转换序列，返回 0。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\n<strong>输出：</strong>5\n<strong>解释：</strong>一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]\n<strong>输出：</strong>0\n<strong>解释：</strong>endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= beginWord.length &lt;= 10</code></li>\n\t<li><code>endWord.length == beginWord.length</code></li>\n\t<li><code>1 &lt;= wordList.length &lt;= 5000</code></li>\n\t<li><code>wordList[i].length == beginWord.length</code></li>\n\t<li><code>beginWord</code>、<code>endWord</code> 和 <code>wordList[i]</code> 由小写英文字母组成</li>\n\t<li><code>beginWord != endWord</code></li>\n\t<li><code>wordList</code> 中的所有字符串 <strong>互不相同</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 127&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/word-ladder/\">https://leetcode-cn.com/problems/word-ladder/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3032.开密码锁",
        "hardRate": "MEDIUM",
        "passRate": "57.44%",
        "problemsUrl": "https://leetcode.cn/problems/zlDJc7/",
        "solutionsUrl": "https://leetcode.cn/problems/zlDJc7/solution",
        "problemsDesc": "<p>一个密码锁由 4&nbsp;个环形拨轮组成，每个拨轮都有 10 个数字： <code>&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;</code> 。每个拨轮可以自由旋转：例如把 <code>&#39;9&#39;</code> 变为&nbsp;<code>&#39;0&#39;</code>，<code>&#39;0&#39;</code> 变为 <code>&#39;9&#39;</code> 。每次旋转都只能旋转一个拨轮的一位数字。</p>\n\n<p>锁的初始数字为 <code>&#39;0000&#39;</code> ，一个代表四个拨轮的数字的字符串。</p>\n\n<p>列表 <code>deadends</code> 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p>\n\n<p>字符串 <code>target</code> 代表可以解锁的数字，请给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;\n<strong>输出：</strong>6\n<strong>解释：</strong>\n可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。\n注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> deadends = [&quot;8888&quot;], target = &quot;0009&quot;\n<strong>输出：</strong>1\n<strong>解释：</strong>\n把最后一位反向旋转一次即可 &quot;0000&quot; -&gt; &quot;0009&quot;。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target = &quot;8888&quot;\n<strong>输出：</strong>-1\n<strong>解释：\n</strong>无法旋转到目标数字且不被锁定。\n</pre>\n\n<p><strong>示例 4:</strong></p>\n\n<pre>\n<strong>输入:</strong> deadends = [&quot;0000&quot;], target = &quot;8888&quot;\n<strong>输出：</strong>-1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;deadends.length &lt;= 500</code></li>\n\t<li><code><font face=\"monospace\">deadends[i].length == 4</font></code></li>\n\t<li><code><font face=\"monospace\">target.length == 4</font></code></li>\n\t<li><code>target</code> <strong>不在</strong> <code>deadends</code> 之中</li>\n\t<li><code>target</code> 和 <code>deadends[i]</code> 仅由若干位数字组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 752&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/open-the-lock/\">https://leetcode-cn.com/problems/open-the-lock/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3033.所有路径",
        "hardRate": "MEDIUM",
        "passRate": "81.00%",
        "problemsUrl": "https://leetcode.cn/problems/bP4bmD/",
        "solutionsUrl": "https://leetcode.cn/problems/bP4bmD/solution",
        "problemsDesc": "<p>给定一个有&nbsp;<code>n</code>&nbsp;个节点的有向无环图，用二维数组&nbsp;<code>graph</code>&nbsp;表示，请找到所有从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n-1</code>&nbsp;的路径并输出（不要求按顺序）。</p>\n\n<p><code>graph</code>&nbsp;的第 <code>i</code> 个数组中的单元都表示有向图中 <code>i</code>&nbsp;号节点所能到达的下一些结点（译者注：有向图是有方向的，即规定了 a&rarr;b 你就不能从 b&rarr;a ），若为空，就是没有下一个节点了。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg\" style=\"height: 242px; width: 242px;\" /></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,2],[3],[3],[]]\n<strong>输出：</strong>[[0,1,3],[0,2,3]]\n<strong>解释：</strong>有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg\" style=\"height: 301px; width: 423px;\" /></p>\n\n<pre>\n<strong>输入：</strong>graph = [[4,3,1],[3,2,4],[3],[4],[]]\n<strong>输出：</strong>[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1],[]]\n<strong>输出：</strong>[[0,1]]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,2,3],[2],[3],[]]\n<strong>输出：</strong>[[0,1,2,3],[0,2,3],[0,3]]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,3],[2],[3],[]]\n<strong>输出：</strong>[[0,1,2,3],[0,3]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == graph.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 15</code></li>\n\t<li><code>0 &lt;= graph[i][j] &lt; n</code></li>\n\t<li><code>graph[i][j] != i</code>&nbsp;</li>\n\t<li>保证输入为有向无环图 <code>(GAD)</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 797&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/all-paths-from-source-to-target/\">https://leetcode-cn.com/problems/all-paths-from-source-to-target/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3034.计算除法",
        "hardRate": "MEDIUM",
        "passRate": "64.90%",
        "problemsUrl": "https://leetcode.cn/problems/vlzXQL/",
        "solutionsUrl": "https://leetcode.cn/problems/vlzXQL/solution",
        "problemsDesc": "<p>给定一个变量对数组 <code>equations</code> 和一个实数值数组 <code>values</code> 作为已知条件，其中 <code>equations[i] = [A<sub>i</sub>, B<sub>i</sub>]</code> 和 <code>values[i]</code> 共同表示等式 <code>A<sub>i</sub> / B<sub>i</sub> = values[i]</code> 。每个 <code>A<sub>i</sub></code> 或 <code>B<sub>i</sub></code> 是一个表示单个变量的字符串。</p>\n\n<p>另有一些以数组 <code>queries</code> 表示的问题，其中 <code>queries[j] = [C<sub>j</sub>, D<sub>j</sub>]</code> 表示第 <code>j</code> 个问题，请你根据已知条件找出 <code>C<sub>j</sub> / D<sub>j</sub> = ?</code> 的结果作为答案。</p>\n\n<p>返回 <strong>所有问题的答案</strong> 。如果存在某个无法确定的答案，则用 <code>-1.0</code> 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 <code>-1.0</code> 替代这个答案。</p>\n\n<p><strong>注意：</strong>输入总是有效的。可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]\n<strong>输出：</strong>[6.00000,0.50000,-1.00000,1.00000,-1.00000]\n<strong>解释：</strong>\n条件：<em>a / b = 2.0</em>, <em>b / c = 3.0</em>\n问题：<em>a / c = ?</em>, <em>b / a = ?</em>, <em>a / e = ?</em>, <em>a / a = ?</em>, <em>x / x = ?</em>\n结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]\n<strong>输出：</strong>[3.75000,0.40000,5.00000,0.20000]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]\n<strong>输出：</strong>[0.50000,2.00000,-1.00000,-1.00000]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= equations.length &lt;= 20</code></li>\n\t<li><code>equations[i].length == 2</code></li>\n\t<li><code>1 &lt;= A<sub>i</sub>.length, B<sub>i</sub>.length &lt;= 5</code></li>\n\t<li><code>values.length == equations.length</code></li>\n\t<li><code>0.0 &lt; values[i] &lt;= 20.0</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 20</code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>1 &lt;= C<sub>j</sub>.length, D<sub>j</sub>.length &lt;= 5</code></li>\n\t<li><code>A<sub>i</sub>, B<sub>i</sub>, C<sub>j</sub>, D<sub>j</sub></code> 由小写英文字母与数字组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 399&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/evaluate-division/\">https://leetcode-cn.com/problems/evaluate-division/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3035.最长递增路径",
        "hardRate": "HARD",
        "passRate": "57.93%",
        "problemsUrl": "https://leetcode.cn/problems/fpTFWP/",
        "solutionsUrl": "https://leetcode.cn/problems/fpTFWP/solution",
        "problemsDesc": "<p>给定一个&nbsp;<code>m x n</code> 整数矩阵&nbsp;<code>matrix</code> ，找出其中 <strong>最长递增路径</strong> 的长度。</p>\n\n<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 <strong>不能</strong> 在 <strong>对角线</strong> 方向上移动或移动到 <strong>边界外</strong>（即不允许环绕）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg\" style=\"width: 242px; height: 242px;\" /></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[9,9,4],[6,6,8],[2,1,1]]\n<strong>输出：</strong>4 \n<strong>解释：</strong>最长递增路径为&nbsp;<code>[1, 2, 6, 9]</code>。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg\" style=\"width: 253px; height: 253px;\" /></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[3,4,5],[3,2,6],[2,2,1]]\n<strong>输出：</strong>4 \n<strong>解释：</strong>最长递增路径是&nbsp;<code>[3, 4, 5, 6]</code>。注意不允许在对角线方向上移动。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1]]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= matrix[i][j] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 329&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/\">https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3036.课程顺序",
        "hardRate": "MEDIUM",
        "passRate": "56.74%",
        "problemsUrl": "https://leetcode.cn/problems/QA2IGt/",
        "solutionsUrl": "https://leetcode.cn/problems/QA2IGt/solution",
        "problemsDesc": "<p>现在总共有 <code>numCourses</code>&nbsp;门课需要选，记为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>numCourses-1</code>。</p>\n\n<p>给定一个数组&nbsp;<code>prerequisites</code> ，它的每一个元素&nbsp;<code>prerequisites[i]</code>&nbsp;表示两门课程之间的先修顺序。&nbsp;例如&nbsp;<code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示想要学习课程 <code>a<sub>i</sub></code>&nbsp;，需要先完成课程 <code>b<sub>i</sub></code>&nbsp;。</p>\n\n<p>请根据给出的总课程数 &nbsp;<code>numCourses</code> 和表示先修顺序的&nbsp;<code>prerequisites</code>&nbsp;得出一个可行的修课序列。</p>\n\n<p>可能会有多个正确的顺序，只要任意返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> numCourses = 2, prerequisites = [[1,0]] \n<strong>输出: </strong><code>[0,1]</code>\n<strong>解释:</strong>&nbsp;总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 <code>[0,1] 。</code></pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n<strong>输出: </strong><code>[0,1,2,3] or [0,2,1,3]</code>\n<strong>解释:</strong>&nbsp;总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。\n&nbsp;因此，一个正确的课程顺序是&nbsp;<code>[0,1,2,3]</code> 。另一个正确的排序是&nbsp;<code>[0,2,1,3]</code> 。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> numCourses = 1, prerequisites = [] \n<strong>输出: </strong><code>[0]</code>\n<strong>解释:</strong>&nbsp;总共 1 门课，直接修第一门课就可。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numCourses &lt;= 2000</code></li>\n\t<li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li>\n\t<li><code>prerequisites[i].length == 2</code></li>\n\t<li><code>0 &lt;= ai, bi &lt; numCourses</code></li>\n\t<li><code>ai != bi</code></li>\n\t<li><code>prerequisites</code>&nbsp;中不存在重复元素</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 210&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/course-schedule-ii/\">https://leetcode-cn.com/problems/course-schedule-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3037.外星文字典",
        "hardRate": "HARD",
        "passRate": "51.85%",
        "problemsUrl": "https://leetcode.cn/problems/Jf1JuT/",
        "solutionsUrl": "https://leetcode.cn/problems/Jf1JuT/solution",
        "problemsDesc": "<p>现有一种使用英语字母的外星文语言，这门语言的字母顺序与英语顺序不同。</p>\n\n<p>给定一个字符串列表 <code>words</code> ，作为这门语言的词典，<code>words</code> 中的字符串已经 <strong>按这门新语言的字母顺序进行了排序</strong> 。</p>\n\n<p>请你根据该词典还原出此语言中已知的字母顺序，并 <strong>按字母递增顺序</strong> 排列。若不存在合法字母顺序，返回 <code>&quot;&quot;</code> 。若存在多种可能的合法字母顺序，返回其中 <strong>任意一种</strong> 顺序即可。</p>\n\n<p>字符串 <code>s</code> <strong>字典顺序小于</strong> 字符串 <code>t</code> 有两种情况：</p>\n\n<ul>\n\t<li>在第一个不同字母处，如果 <code>s</code> 中的字母在这门外星语言的字母顺序中位于 <code>t</code> 中字母之前，那么&nbsp;<code>s</code> 的字典顺序小于 <code>t</code> 。</li>\n\t<li>如果前面 <code>min(s.length, t.length)</code> 字母都相同，那么 <code>s.length &lt; t.length</code> 时，<code>s</code> 的字典顺序也小于 <code>t</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [&quot;wrt&quot;,&quot;wrf&quot;,&quot;er&quot;,&quot;ett&quot;,&quot;rftt&quot;]\n<strong>输出：</strong>&quot;wertf&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [&quot;z&quot;,&quot;x&quot;]\n<strong>输出：</strong>&quot;zx&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [&quot;z&quot;,&quot;x&quot;,&quot;z&quot;]\n<strong>输出：</strong>&quot;&quot;\n<strong>解释：</strong>不存在合法字母顺序，因此返回 <code>&quot;&quot; 。</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><code>words[i]</code> 仅由小写英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 269&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/alien-dictionary/\">https://leetcode-cn.com/problems/alien-dictionary/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3038.重建序列",
        "hardRate": "MEDIUM",
        "passRate": "51.10%",
        "problemsUrl": "https://leetcode.cn/problems/ur2n8P/",
        "solutionsUrl": "https://leetcode.cn/problems/ur2n8P/solution",
        "problemsDesc": "<p>给定一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，其中 <code>nums</code> 是范围为 <code>[1，n]</code> 的整数的排列。还提供了一个 2D 整数数组&nbsp;<code>sequences</code>&nbsp;，其中&nbsp;<code>sequences[i]</code>&nbsp;是&nbsp;<code>nums</code>&nbsp;的子序列。<br />\n检查 <code>nums</code> 是否是唯一的最短&nbsp;<strong>超序列</strong> 。最短 <strong>超序列</strong> 是 <strong>长度最短</strong> 的序列，并且所有序列&nbsp;<code>sequences[i]</code>&nbsp;都是它的子序列。对于给定的数组&nbsp;<code>sequences</code>&nbsp;，可能存在多个有效的 <strong>超序列</strong> 。</p>\n\n<ul>\n\t<li>例如，对于&nbsp;<code>sequences = [[1,2],[1,3]]</code>&nbsp;，有两个最短的 <strong>超序列</strong> ，<code>[1,2,3]</code> 和 <code>[1,3,2]</code> 。</li>\n\t<li>而对于&nbsp;<code>sequences = [[1,2],[1,3],[1,2,3]]</code>&nbsp;，唯一可能的最短 <strong>超序列</strong> 是 <code>[1,2,3]</code> 。<code>[1,2,3,4]</code> 是可能的超序列，但不是最短的。</li>\n</ul>\n\n<p><em>如果 <code>nums</code> 是序列的唯一最短 <strong>超序列</strong> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。</em><br />\n<strong>子序列</strong> 是一个可以通过从另一个序列中删除一些元素或不删除任何元素，而不改变其余元素的顺序的序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3], sequences = [[1,2],[1,3]]\n<strong>输出：</strong>false\n<strong>解释：</strong>有两种可能的超序列：[1,2,3]和[1,3,2]。\n序列 [1,2] 是[<u><strong>1,2</strong></u>,3]和[<u><strong>1</strong></u>,3,<u><strong>2</strong></u>]的子序列。\n序列 [1,3] 是[<u><strong>1</strong></u>,2,<u><strong>3</strong></u>]和[<u><strong>1,3</strong></u>,2]的子序列。\n因为 nums 不是唯一最短的超序列，所以返回false。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3], sequences = [[1,2]]\n<strong>输出：</strong>false\n<strong>解释：</strong>最短可能的超序列为 [1,2]。\n序列 [1,2] 是它的子序列：[<u><strong>1,2</strong></u>]。\n因为 nums 不是最短的超序列，所以返回false。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3], sequences = [[1,2],[1,3],[2,3]]\n<strong>输出：</strong>true\n<strong>解释：</strong>最短可能的超序列为[1,2,3]。\n序列 [1,2] 是它的一个子序列：[<strong>1,2</strong>,3]。\n序列 [1,3] 是它的一个子序列：[<u><strong>1</strong></u>,2,<u><strong>3</strong></u>]。\n序列 [2,3] 是它的一个子序列：[1,<u><strong>2,3</strong></u>]。\n因为 nums 是唯一最短的超序列，所以返回true。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code>&nbsp;是&nbsp;<code>[1, n]</code>&nbsp;范围内所有整数的排列</li>\n\t<li><code>1 &lt;= sequences.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= sequences[i].length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= sum(sequences[i].length) &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= sequences[i][j] &lt;= n</code></li>\n\t<li><code>sequences</code>&nbsp;的所有数组都是 <strong>唯一 </strong>的</li>\n\t<li><code>sequences[i]</code>&nbsp;是&nbsp;<code>nums</code> 的一个子序列</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 444&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/sequence-reconstruction/\">https://leetcode-cn.com/problems/sequence-reconstruction/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3039.省份数量",
        "hardRate": "MEDIUM",
        "passRate": "67.43%",
        "problemsUrl": "https://leetcode.cn/problems/bLyHh0/",
        "solutionsUrl": "https://leetcode.cn/problems/bLyHh0/solution",
        "problemsDesc": "<div class=\"original__bRMd\">\n<p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p>\n\n<p><strong>省份</strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>\n\n<p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p>\n\n<p>返回矩阵中 <strong>省份</strong> 的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg\" />\n<pre>\n<strong>输入：</strong>isConnected = [[1,1,0],[1,1,0],[0,0,1]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg\" />\n<pre>\n<strong>输入：</strong>isConnected = [[1,0,0],[0,1,0],[0,0,1]]\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>n == isConnected.length</code></li>\n\t<li><code>n == isConnected[i].length</code></li>\n\t<li><code>isConnected[i][j]</code> 为 <code>1</code> 或 <code>0</code></li>\n\t<li><code>isConnected[i][i] == 1</code></li>\n\t<li><code>isConnected[i][j] == isConnected[j][i]</code></li>\n</ul>\n</div>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 547&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/number-of-provinces/\">https://leetcode-cn.com/problems/number-of-provinces/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3040.相似的字符串",
        "hardRate": "HARD",
        "passRate": "61.96%",
        "problemsUrl": "https://leetcode.cn/problems/H6lPxb/",
        "solutionsUrl": "https://leetcode.cn/problems/H6lPxb/solution",
        "problemsDesc": "<p>如果交换字符串&nbsp;<code>X</code> 中的两个不同位置的字母，使得它和字符串&nbsp;<code>Y</code> 相等，那么称 <code>X</code> 和 <code>Y</code> 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。</p>\n\n<p>例如，<code>&quot;tars&quot;</code> 和 <code>&quot;rats&quot;</code> 是相似的 (交换 <code>0</code> 与 <code>2</code> 的位置)；&nbsp;<code>&quot;rats&quot;</code> 和 <code>&quot;arts&quot;</code> 也是相似的，但是 <code>&quot;star&quot;</code> 不与 <code>&quot;tars&quot;</code>，<code>&quot;rats&quot;</code>，或 <code>&quot;arts&quot;</code> 相似。</p>\n\n<p>总之，它们通过相似性形成了两个关联组：<code>{&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;}</code> 和 <code>{&quot;star&quot;}</code>。注意，<code>&quot;tars&quot;</code> 和 <code>&quot;arts&quot;</code> 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。</p>\n\n<p>给定一个字符串列表 <code>strs</code>。列表中的每个字符串都是 <code>strs</code> 中其它所有字符串的一个&nbsp;<strong>字母异位词&nbsp;</strong>。请问 <code>strs</code> 中有多少个相似字符串组？</p>\n\n<p><strong>字母异位词（anagram）</strong>，一种把某个字符串的字母的位置（顺序）加以改换所形成的新词。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [&quot;omv&quot;,&quot;ovm&quot;]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= strs[i].length &lt;= 300</code></li>\n\t<li><code>strs[i]</code> 只包含小写字母。</li>\n\t<li><code>strs</code> 中的所有单词都具有相同的长度，且是彼此的字母异位词。</li>\n</ul>\n\n<p>&nbsp; &nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 839&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/similar-string-groups/\">https://leetcode-cn.com/problems/similar-string-groups/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3041.多余的边",
        "hardRate": "MEDIUM",
        "passRate": "69.34%",
        "problemsUrl": "https://leetcode.cn/problems/7LpjUW/",
        "solutionsUrl": "https://leetcode.cn/problems/7LpjUW/solution",
        "problemsDesc": "<p>树可以看成是一个连通且 <strong>无环&nbsp;</strong>的&nbsp;<strong>无向&nbsp;</strong>图。</p>\n\n<p>给定往一棵&nbsp;<code>n</code> 个节点 (节点值&nbsp;<code>1～n</code>) 的树中添加一条边后的图。添加的边的两个顶点包含在 <code>1</code> 到 <code>n</code>&nbsp;中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 <code>n</code> 的二维数组 <code>edges</code>&nbsp;，<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示图中在 <code>ai</code> 和 <code>bi</code> 之间存在一条边。</p>\n\n<p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 <code>n</code> 个节点的树。如果有多个答案，则返回数组&nbsp;<code>edges</code>&nbsp;中最后出现的边。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626676174-hOEVUL-image.png\" style=\"width: 152px; \" /></p>\n\n<pre>\n<strong>输入:</strong> edges = [[1,2],[1,3],[2,3]]\n<strong>输出:</strong> [2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626676179-kGxcmu-image.png\" style=\"width: 250px; \" /></p>\n\n<pre>\n<strong>输入:</strong> edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]\n<strong>输出:</strong> [1,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>3 &lt;= n &lt;= 1000</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 &lt;= ai&nbsp;&lt; bi&nbsp;&lt;= edges.length</code></li>\n\t<li><code>ai != bi</code></li>\n\t<li><code>edges</code> 中无重复元素</li>\n\t<li>给定的图是连通的&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 684&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/redundant-connection/\">https://leetcode-cn.com/problems/redundant-connection/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3042.最长连续序列",
        "hardRate": "MEDIUM",
        "passRate": "49.20%",
        "problemsUrl": "https://leetcode.cn/problems/WhsWhI/",
        "solutionsUrl": "https://leetcode.cn/problems/WhsWhI/solution",
        "problemsDesc": "<p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [100,4,200,1,3,2]\n<strong>输出：</strong>4\n<strong>解释：</strong>最长数字连续序列是 <code>[1, 2, 3, 4]。它的长度为 4。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,3,7,2,5,8,4,6,0,1]\n<strong>输出：</strong>9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>可以设计并实现时间复杂度为&nbsp;<code>O(n)</code><em> </em>的解决方案吗？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 128&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/longest-consecutive-sequence/\">https://leetcode-cn.com/problems/longest-consecutive-sequence/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3043.判定字符是否唯一",
        "hardRate": "EASY",
        "passRate": "71.01%",
        "problemsUrl": "https://leetcode.cn/problems/is-unique-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/is-unique-lcci/solution",
        "problemsDesc": "<p>实现一个算法，确定一个字符串 <code>s</code> 的所有字符是否全都不同。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>s</code> = \"leetcode\"\n<strong>输出:</strong> false \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>s</code> = \"abc\"\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= len(s) &lt;= 100 </code></li>\n\t<li><code>s[i]</code>仅包含小写字母</li>\n\t<li>如果你不使用额外的数据结构，会很加分。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3044.判定是否互为字符重排",
        "hardRate": "EASY",
        "passRate": "65.69%",
        "problemsUrl": "https://leetcode.cn/problems/check-permutation-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/check-permutation-lcci/solution",
        "problemsDesc": "<p>给定两个由小写字母组成的字符串 <code>s1</code> 和 <code>s2</code>，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>s1</code> = \"abc\", <code>s2</code> = \"bca\"\n<strong>输出:</strong> true \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>s1</code> = \"abc\", <code>s2</code> = \"bad\"\n<strong>输出:</strong> false\n</pre>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= len(s1) &lt;= 100 </code></li>\n\t<li><code>0 &lt;= len(s2) &lt;= 100 </code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3045.URL化",
        "hardRate": "EASY",
        "passRate": "57.39%",
        "problemsUrl": "https://leetcode.cn/problems/string-to-url-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/string-to-url-lcci/solution",
        "problemsDesc": "<p>URL化。编写一种方法，将字符串中的空格全部替换为<code>%20</code>。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用<code>Java</code>实现的话，请使用字符数组实现，以便直接在数组上操作。）</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>：\"Mr John Smith    \", 13\n<strong>输出</strong>：\"Mr%20John%20Smith\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入</strong>：\"               \", 5\n<strong>输出</strong>：\"%20%20%20%20%20\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>字符串长度在 [0, 500000] 范围内。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3046.回文排列",
        "hardRate": "EASY",
        "passRate": "53.72%",
        "problemsUrl": "https://leetcode.cn/problems/palindrome-permutation-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/palindrome-permutation-lcci/solution",
        "problemsDesc": "<p>给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。</p>\n\n<p>回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。</p>\n\n<p>回文串不一定是字典当中的单词。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例1：</strong></p>\n\n<pre><strong>输入：&quot;</strong>tactcoa&quot;\n<strong>输出：</strong>true（排列有&quot;tacocat&quot;、&quot;atcocta&quot;，等等）\n</pre>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3047.一次编辑",
        "hardRate": "MEDIUM",
        "passRate": "35.18%",
        "problemsUrl": "https://leetcode.cn/problems/one-away-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/one-away-lcci/solution",
        "problemsDesc": "<p>字符串有三种编辑操作:插入一个英文字符、删除一个英文字符或者替换一个英文字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nfirst = \"pale\"\nsecond = \"ple\"\n<strong>输出:</strong> True</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nfirst = \"pales\"\nsecond = \"pal\"\n<strong>输出:</strong> False\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3048.字符串压缩",
        "hardRate": "EASY",
        "passRate": "46.19%",
        "problemsUrl": "https://leetcode.cn/problems/compress-string-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/compress-string-lcci/solution",
        "problemsDesc": "<p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串<code>aabcccccaaa</code>会变为<code>a2b1c5a3</code>。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</p>\n\n<p> <strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>：\"aabcccccaaa\"\n<strong> 输出</strong>：\"a2b1c5a3\"\n</pre>\n\n<p> <strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>：\"abbccd\"\n<strong> 输出</strong>：\"abbccd\"\n<strong> 解释</strong>：\"abbccd\"压缩后为\"a1b2c2d1\"，比原字符串长度更长。\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n<li>字符串长度在[0, 50000]范围内。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3049.旋转矩阵",
        "hardRate": "MEDIUM",
        "passRate": "73.22%",
        "problemsUrl": "https://leetcode.cn/problems/rotate-matrix-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/rotate-matrix-lcci/solution",
        "problemsDesc": "<p>给你一幅由 <code>N × N</code> 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p>\n\n<p>不占用额外内存空间能否做到？</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n给定 <strong>matrix</strong> = \n[\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n],\n\n<strong>原地</strong>旋转输入矩阵，使其变为:\n[\n  [7,4,1],\n  [8,5,2],\n  [9,6,3]\n]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n给定 <strong>matrix</strong> =\n[\n  [ 5, 1, 9,11],\n  [ 2, 4, 8,10],\n  [13, 3, 6, 7],\n  [15,14,12,16]\n], \n\n<strong>原地</strong>旋转输入矩阵，使其变为:\n[\n  [15,13, 2, 5],\n  [14, 3, 4, 1],\n  [12, 6, 8, 9],\n  [16, 7,10,11]\n]\n</pre>\n\n<p><strong>注意</strong>：本题与主站 48 题相同：<a href=\"https://leetcode-cn.com/problems/rotate-image/\">https://leetcode-cn.com/problems/rotate-image/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3050.零矩阵",
        "hardRate": "MEDIUM",
        "passRate": "64.33%",
        "problemsUrl": "https://leetcode.cn/problems/zero-matrix-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/zero-matrix-lcci/solution",
        "problemsDesc": "<p>编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>\n[\n  [1,1,1],\n  [1,0,1],\n  [1,1,1]\n]\n<strong>输出：</strong>\n[\n  [1,0,1],\n  [0,0,0],\n  [1,0,1]\n]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>\n[\n  [0,1,2,0],\n  [3,4,5,2],\n  [1,3,1,5]\n]\n<strong>输出：</strong>\n[\n  [0,0,0,0],\n  [0,4,5,0],\n  [0,3,1,0]\n]\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3051.字符串轮转",
        "hardRate": "EASY",
        "passRate": "54.16%",
        "problemsUrl": "https://leetcode.cn/problems/string-rotation-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/string-rotation-lcci/solution",
        "problemsDesc": "<p>字符串轮转。给定两个字符串<code>s1</code>和<code>s2</code>，请编写代码检查<code>s2</code>是否为<code>s1</code>旋转而成（比如，<code>waterbottle</code>是<code>erbottlewat</code>旋转后的字符串）。</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre><strong> 输入</strong>：s1 = &quot;waterbottle&quot;, s2 = &quot;erbottlewat&quot;\n<strong> 输出</strong>：True\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre><strong> 输入</strong>：s1 = &quot;aa&quot;, s2 = &quot;aba&quot;\n<strong> 输出</strong>：False\n</pre>\n\n<ol>\n</ol>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>字符串长度在[0, 100000]范围内。</li>\n</ol>\n\n<p><strong>说明:</strong></p>\n\n<ol>\n\t<li>你能只调用一次检查子串的方法吗？</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3052.移除重复节点",
        "hardRate": "EASY",
        "passRate": "66.82%",
        "problemsUrl": "https://leetcode.cn/problems/remove-duplicate-node-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-duplicate-node-lcci/solution",
        "problemsDesc": "<p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>\n\n<p> <strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>：[1, 2, 3, 3, 2, 1]\n<strong> 输出</strong>：[1, 2, 3]\n</pre>\n\n<p> <strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>：[1, 1, 1, 1, 2]\n<strong> 输出</strong>：[1, 2]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n<li>链表长度在[0, 20000]范围内。</li>\n<li>链表元素在[0, 20000]范围内。</li>\n</ol>\n\n<p> <strong>进阶：</strong></p>\n\n<p>如果不得使用临时缓冲区，该怎么解决？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3053.返回倒数第 k 个节点",
        "hardRate": "EASY",
        "passRate": "78.09%",
        "problemsUrl": "https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/solution",
        "problemsDesc": "<p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p>\n\n<p><strong>注意：</strong>本题相对原题稍作改动</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5 和 <em>k</em> = 2\n<strong>输出： </strong>4</pre>\n\n<p><strong>说明：</strong></p>\n\n<p>给定的 <em>k</em>&nbsp;保证是有效的。</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3054.删除中间节点",
        "hardRate": "EASY",
        "passRate": "85.98%",
        "problemsUrl": "https://leetcode.cn/problems/delete-middle-node-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-middle-node-lcci/solution",
        "problemsDesc": "<p>若链表中的某个节点，既不是链表头节点，也不是链表尾节点，则称其为该链表的「中间节点」。</p>\n\n<p>假定已知链表的某一个中间节点，请实现一种算法，将该节点从链表中删除。</p>\n\n<p>例如，传入节点 <code>c</code>（位于单向链表 <code>a->b->c->d->e->f</code> 中），将其删除后，剩余链表为 <code>a->b->d->e->f</code></p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>节点 5 （位于单向链表 4->5->1->9 中）\n<strong>输出：</strong>不返回任何数据，从链表中删除传入的节点 5，使链表变为 4->1->9\n</pre>\n\n<p> </p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3055.分割链表",
        "hardRate": "MEDIUM",
        "passRate": "61.10%",
        "problemsUrl": "https://leetcode.cn/problems/partition-list-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-list-lcci/solution",
        "problemsDesc": "<p>给你一个链表的头节点 <code>head</code> 和一个特定值<em> </em><code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。</p>\n\n<p>你不需要&nbsp;<strong>保留</strong>&nbsp;每个分区中各节点的初始相对位置。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/partition.jpg\" style=\"width: 662px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>head = [1,4,3,2,5,2], x = 3\n<strong>输出</strong>：[1,2,2,4,3,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [2,1], x = 2\n<strong>输出</strong>：[1,2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目在范围 <code>[0, 200]</code> 内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>-200 &lt;= x &lt;= 200</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3056.链表求和",
        "hardRate": "MEDIUM",
        "passRate": "46.96%",
        "problemsUrl": "https://leetcode.cn/problems/sum-lists-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-lists-lcci/solution",
        "problemsDesc": "<p>给定两个用链表表示的整数，每个节点包含一个数位。</p>\n\n<p>这些数位是反向存放的，也就是个位排在链表首部。</p>\n\n<p>编写函数对这两个整数求和，并用链表形式返回结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>(7 -&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2)，即617 + 295\n<strong>输出：</strong>2 -&gt; 1 -&gt; 9，即912\n</pre>\n\n<p><strong>进阶：</strong>思考一下，假设这些数位是正向存放的，又该如何解决呢?</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>(6 -&gt; 1 -&gt; 7) + (2 -&gt; 9 -&gt; 5)，即617 + 295\n<strong>输出：</strong>9 -&gt; 1 -&gt; 2，即912\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3057.回文链表",
        "hardRate": "EASY",
        "passRate": "48.77%",
        "problemsUrl": "https://leetcode.cn/problems/palindrome-linked-list-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/palindrome-linked-list-lcci/solution",
        "problemsDesc": "<p>编写一个函数，检查输入的链表是否是回文的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入： </strong>1-&gt;2\n<strong>输出：</strong> false \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入： </strong>1-&gt;2-&gt;2-&gt;1\n<strong>输出：</strong> true \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong><br>\n你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3058.链表相交",
        "hardRate": "EASY",
        "passRate": "66.28%",
        "problemsUrl": "https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/solution",
        "problemsDesc": "<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p>\n\n<p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>\n\n<p><a href=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\" style=\"height: 130px; width: 400px;\" /></a></p>\n\n<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>\n\n<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png\" style=\"height: 130px; width: 400px;\" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n<strong>输出：</strong>Intersected at '8'\n<strong>解释：</strong>相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png\" style=\"height: 136px; width: 350px;\" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n<strong>输出：</strong>Intersected at '2'\n<strong>解释：</strong>相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png\" style=\"height: 126px; width: 200px;\" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n<strong>输出：</strong>null\n<strong>解释：</strong>从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>listA</code> 中节点数目为 <code>m</code></li>\n\t<li><code>listB</code> 中节点数目为 <code>n</code></li>\n\t<li><code>0 <= m, n <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= Node.val <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= skipA <= m</code></li>\n\t<li><code>0 <= skipB <= n</code></li>\n\t<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>\n\t<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3059.环路检测",
        "hardRate": "MEDIUM",
        "passRate": "55.12%",
        "problemsUrl": "https://leetcode.cn/problems/linked-list-cycle-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/linked-list-cycle-lcci/solution",
        "problemsDesc": "<p>给定一个链表，如果它是有环链表，实现一个算法返回环路的<code>开头节点</code>。若环不存在，请返回 <code>null</code>。</p>\n\n<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png\" style=\"height: 97px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [3,2,0,-4], pos = 1\n<strong>输出：</strong>tail connects to node index 1\n<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png\" style=\"height: 74px; width: 141px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2], pos = 0\n<strong>输出：</strong>tail connects to node index 0\n<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png\" style=\"height: 45px; width: 45px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1], pos = -1\n<strong>输出：</strong>no cycle\n<strong>解释：</strong>链表中没有环。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你是否可以不用额外空间解决此题？</li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3060.三合一",
        "hardRate": "EASY",
        "passRate": "53.56%",
        "problemsUrl": "https://leetcode.cn/problems/three-in-one-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/three-in-one-lcci/solution",
        "problemsDesc": "<p>三合一。描述如何只用一个数组来实现三个栈。</p>\n\n<p>你应该实现<code>push(stackNum, value)</code>、<code>pop(stackNum)</code>、<code>isEmpty(stackNum)</code>、<code>peek(stackNum)</code>方法。<code>stackNum</code>表示栈下标，<code>value</code>表示压入的值。</p>\n\n<p>构造函数会传入一个<code>stackSize</code>参数，代表每个栈的大小。</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>：\n[\"TripleInOne\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"isEmpty\"]\n[[1], [0, 1], [0, 2], [0], [0], [0], [0]]\n<strong> 输出</strong>：\n[null, null, null, 1, -1, -1, true]\n<strong>说明</strong>：当栈为空时`pop, peek`返回-1，当栈满时`push`不压入元素。\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>：\n[\"TripleInOne\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"peek\"]\n[[2], [0, 1], [0, 2], [0, 3], [0], [0], [0], [0]]\n<strong> 输出</strong>：\n[null, null, null, null, 2, 1, -1, -1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= stackNum &lt;= 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3061.栈的最小值",
        "hardRate": "EASY",
        "passRate": "62.07%",
        "problemsUrl": "https://leetcode.cn/problems/min-stack-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/min-stack-lcci/solution",
        "problemsDesc": "<p>请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。</p><br><p><strong>示例：</strong><pre>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   --> 返回 -3.<br>minStack.pop();<br>minStack.top();      --> 返回 0.<br>minStack.getMin();   --> 返回 -2.</pre></p>",
        "isPlus": false
    },
    {
        "problemsName": " 3062.堆盘子",
        "hardRate": "MEDIUM",
        "passRate": "38.51%",
        "problemsUrl": "https://leetcode.cn/problems/stack-of-plates-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/stack-of-plates-lcci/solution",
        "problemsDesc": "<p>堆盘子。设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构<code>SetOfStacks</code>，模拟这种行为。<code>SetOfStacks</code>应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，<code>SetOfStacks.push()</code>和<code>SetOfStacks.pop()</code>应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）。 进阶：实现一个<code>popAt(int index)</code>方法，根据指定的子栈，执行pop操作。</p>\n\n<p>当某个栈为空时，应当删除该栈。当栈中没有元素或不存在该栈时，<code>pop</code>，<code>popAt</code>&nbsp;应返回 -1.</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre><strong> 输入</strong>：\n[&quot;StackOfPlates&quot;, &quot;push&quot;, &quot;push&quot;, &quot;popAt&quot;, &quot;pop&quot;, &quot;pop&quot;]\n[[1], [1], [2], [1], [], []]\n<strong> 输出</strong>：\n[null, null, null, 2, 1, -1]\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre><strong> 输入</strong>：\n[&quot;StackOfPlates&quot;, &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;popAt&quot;, &quot;popAt&quot;, &quot;popAt&quot;]\n[[2], [1], [2], [3], [0], [0], [0]]\n<strong> 输出</strong>：\n[null, null, null, null, 2, 1, 3]\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3063.化栈为队",
        "hardRate": "EASY",
        "passRate": "71.82%",
        "problemsUrl": "https://leetcode.cn/problems/implement-queue-using-stacks-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/implement-queue-using-stacks-lcci/solution",
        "problemsDesc": "<p>实现一个MyQueue类，该类用两个栈来实现一个队列。</p><br><p><strong>示例：</strong><pre>MyQueue queue = new MyQueue();<br><br>queue.push(1);<br>queue.push(2);<br>queue.peek();  // 返回 1<br>queue.pop();   // 返回 1<br>queue.empty(); // 返回 false</pre></p><br><p><strong>说明：</strong><br><ul><li>你只能使用标准的栈操作 -- 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code> 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li></ul></p>",
        "isPlus": false
    },
    {
        "problemsName": " 3064.栈排序",
        "hardRate": "MEDIUM",
        "passRate": "53.59%",
        "problemsUrl": "https://leetcode.cn/problems/sort-of-stacks-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-of-stacks-lcci/solution",
        "problemsDesc": "<p>栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：<code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>isEmpty</code>。当栈为空时，<code>peek</code>&nbsp;返回 -1。</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre><strong> 输入</strong>：\n[&quot;SortedStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;peek&quot;]\n[[], [1], [2], [], [], []]\n<strong> 输出</strong>：\n[null,null,null,1,null,2]\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre><strong> 输入</strong>： \n[&quot;SortedStack&quot;, &quot;pop&quot;, &quot;pop&quot;, &quot;push&quot;, &quot;pop&quot;, &quot;isEmpty&quot;]\n[[], [], [], [1], [], []]\n<strong> 输出</strong>：\n[null,null,null,null,null,true]\n</pre>\n\n<p><strong>说明:</strong></p>\n\n<ol>\n\t<li>栈中的元素数目在[0, 5000]范围内。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3065.动物收容所",
        "hardRate": "EASY",
        "passRate": "58.33%",
        "problemsUrl": "https://leetcode.cn/problems/animal-shelter-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/animal-shelter-lcci/solution",
        "problemsDesc": "<p>动物收容所。有家动物收容所只收容狗与猫，且严格遵守&ldquo;先进先出&rdquo;的原则。在收养该收容所的动物时，收养人只能收养所有动物中&ldquo;最老&rdquo;（由其进入收容所的时间长短而定）的动物，或者可以挑选猫或狗（同时必须收养此类动物中&ldquo;最老&rdquo;的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如<code>enqueue</code>、<code>dequeueAny</code>、<code>dequeueDog</code>和<code>dequeueCat</code>。允许使用Java内置的LinkedList数据结构。</p>\n\n<p><code>enqueue</code>方法有一个<code>animal</code>参数，<code>animal[0]</code>代表动物编号，<code>animal[1]</code>代表动物种类，其中 0 代表猫，1 代表狗。</p>\n\n<p><code>dequeue*</code>方法返回一个列表<code>[动物编号, 动物种类]</code>，若没有可以收养的动物，则返回<code>[-1,-1]</code>。</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre><strong> 输入</strong>：\n[&quot;AnimalShelf&quot;, &quot;enqueue&quot;, &quot;enqueue&quot;, &quot;dequeueCat&quot;, &quot;dequeueDog&quot;, &quot;dequeueAny&quot;]\n[[], [[0, 0]], [[1, 0]], [], [], []]\n<strong> 输出</strong>：\n[null,null,null,[0,0],[-1,-1],[1,0]]\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre><strong> 输入</strong>：\n[&quot;AnimalShelf&quot;, &quot;enqueue&quot;, &quot;enqueue&quot;, &quot;enqueue&quot;, &quot;dequeueDog&quot;, &quot;dequeueCat&quot;, &quot;dequeueAny&quot;]\n[[], [[0, 0]], [[1, 0]], [[2, 1]], [], [], []]\n<strong> 输出</strong>：\n[null,null,null,null,[2,1],[0,0],[1,0]]\n</pre>\n\n<p><strong>说明:</strong></p>\n\n<ol>\n\t<li>收纳所的最大容量为20000</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3066.节点间通路",
        "hardRate": "MEDIUM",
        "passRate": "53.41%",
        "problemsUrl": "https://leetcode.cn/problems/route-between-nodes-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/route-between-nodes-lcci/solution",
        "problemsDesc": "<p>节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre><strong> 输入</strong>：n = 3, graph = [[0, 1], [0, 2], [1, 2], [1, 2]], start = 0, target = 2\n<strong> 输出</strong>：true\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre><strong> 输入</strong>：n = 5, graph = [[0, 1], [0, 2], [0, 4], [0, 4], [0, 1], [1, 3], [1, 4], [1, 3], [2, 3], [3, 4]], start = 0, target = 4\n<strong> 输出</strong> true\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>节点数量n在[0, 1e5]范围内。</li>\n\t<li>节点编号大于等于 0 小于 n。</li>\n\t<li>图中可能存在自环和平行边。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3067.最小高度树",
        "hardRate": "EASY",
        "passRate": "78.90%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-height-tree-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-height-tree-lcci/solution",
        "problemsDesc": "<p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。</p><strong>示例:</strong><pre>给定有序数组: [-10,-3,0,5,9],<br><br>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：<br><br>          0 <br>         / &#92 <br>       -3   9 <br>       /   / <br>     -10  5 <br></pre>",
        "isPlus": false
    },
    {
        "problemsName": " 3068.特定深度节点链表",
        "hardRate": "MEDIUM",
        "passRate": "80.72%",
        "problemsUrl": "https://leetcode.cn/problems/list-of-depth-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/list-of-depth-lcci/solution",
        "problemsDesc": "<p>给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 <code>D</code>，则会创建出 <code>D</code> 个链表）。返回一个包含所有深度的链表的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>[1,2,3,4,5,null,7,8]\n\n        1\n       /  \\ \n      2    3\n     / \\    \\ \n    4   5    7\n   /\n  8\n\n<strong>输出：</strong>[[1],[2,3],[4,5,7],[8]]\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3069.检查平衡性",
        "hardRate": "EASY",
        "passRate": "59.75%",
        "problemsUrl": "https://leetcode.cn/problems/check-balance-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/check-balance-lcci/solution",
        "problemsDesc": "<p>实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。</p><br><strong>示例 1:</strong><pre>给定二叉树 [3,9,20,null,null,15,7]<br>    3<br>   / &#92<br>  9  20<br>    /  &#92<br>   15   7<br>返回 true 。</pre><strong>示例 2:</strong><br><pre>给定二叉树 [1,2,2,3,3,null,null,4,4]<br>      1<br>     / &#92<br>    2   2<br>   / &#92<br>  3   3<br> / &#92<br>4   4<br>返回 false 。</pre>",
        "isPlus": false
    },
    {
        "problemsName": " 3070.合法二叉搜索树",
        "hardRate": "MEDIUM",
        "passRate": "35.70%",
        "problemsUrl": "https://leetcode.cn/problems/legal-binary-search-tree-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/legal-binary-search-tree-lcci/solution",
        "problemsDesc": "<p>实现一个函数，检查一棵二叉树是否为二叉搜索树。</p><strong>示例 1:</strong><pre><strong>输入:</strong><br>    2<br>   / &#92<br>  1   3<br><strong>输出:</strong> true<br></pre><strong>示例 2:</strong><pre><strong>输入:</strong><br>    5<br>   / &#92<br>  1   4<br>     / &#92<br>    3   6<br><strong>输出:</strong> false<br><strong>解释:</strong> 输入为: [5,1,4,null,null,3,6]。<br>     根节点的值为 5 ，但是其右子节点值为 4 。</pre>",
        "isPlus": false
    },
    {
        "problemsName": " 3071.后继者",
        "hardRate": "MEDIUM",
        "passRate": "62.55%",
        "problemsUrl": "https://leetcode.cn/problems/successor-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/successor-lcci/solution",
        "problemsDesc": "<p>设计一个算法，找出二叉搜索树中指定节点的&ldquo;下一个&rdquo;节点（也即中序后继）。</p>\n\n<p>如果指定节点没有对应的&ldquo;下一个&rdquo;节点，则返回<code>null</code>。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> root = <code>[2,1,3], p = 1\n\n  2\n / \\\n1   3\n</code>\n<strong>输出:</strong> 2</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> root = <code>[5,3,6,2,4,null,null,1], p = 6\n\n      5\n     / \\\n    3   6\n   / \\\n  2   4\n /   \n1\n</code>\n<strong>输出:</strong> null</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3072.首个共同祖先",
        "hardRate": "MEDIUM",
        "passRate": "71.58%",
        "problemsUrl": "https://leetcode.cn/problems/first-common-ancestor-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/first-common-ancestor-lcci/solution",
        "problemsDesc": "<p>设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。</p>\n\n<p>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]</p>\n\n<pre>    3\n   / \\\n  5   1\n / \\ / \\\n6  2 0  8\n  / \\\n 7   4\n</pre>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n<strong>输出:</strong> 3\n<strong>解释:</strong> 节点 5 和节点 1 的最近公共祖先是节点 3。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n<strong>输出:</strong> 5\n<strong>解释:</strong> 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</pre>\n\n<p><strong>说明:</strong></p>\n\n<pre>所有节点的值都是唯一的。\np、q 为不同节点且均存在于给定的二叉树中。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3073.二叉搜索树序列",
        "hardRate": "HARD",
        "passRate": "48.85%",
        "problemsUrl": "https://leetcode.cn/problems/bst-sequences-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/bst-sequences-lcci/solution",
        "problemsDesc": "<p>从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。</p>\n\n<p>给定一个由<strong>不同节点</strong>组成的二叉搜索树 <code>root</code>，输出所有可能生成此树的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>root = [2,1,3]\n<strong>输出: </strong>[[2,1,3],[2,3,1]]\n解释: 数组 [2,1,3]、[2,3,1] 均可以通过从左向右遍历元素插入树中形成以下二叉搜索树\n&nbsp;      2 \n&nbsp;     / \\ \n&nbsp;    1   3\n</pre>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<p><strong>示例</strong><strong>&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入: </strong>root = [4,1,null,null,3,2]\n<strong>输出: </strong>[[4,1,3,2]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉搜索树中的节点数在<meta charset=\"UTF-8\" />&nbsp;<code>[0, 1000]</code>&nbsp;的范围内</li>\n\t<li><code>1 &lt;= 节点值&nbsp;&lt;= 10^6</code></li>\n\t<li>\n\t<p>用例保证符合要求的数组数量不超过 <code>5000</code></p>\n\t</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3074.检查子树",
        "hardRate": "MEDIUM",
        "passRate": "67.43%",
        "problemsUrl": "https://leetcode.cn/problems/check-subtree-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/check-subtree-lcci/solution",
        "problemsDesc": "<p>检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断 T2 是否为 T1 的子树。</p>\n\n<p>如果 T1 有这么一个节点 n，其子树与 T2 一模一样，则 T2 为 T1 的子树，也就是说，从节点 n 处把树砍断，得到的树与 T2 完全相同。</p>\n\n<p><strong>注意：</strong>此题相对书上原题略有改动。</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>：t1 = [1, 2, 3], t2 = [2]\n<strong> 输出</strong>：true\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>：t1 = [1, null, 2, 4], t2 = [3, 2]\n<strong> 输出</strong>：false\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>树的节点数目范围为[0, 20000]。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3075.求和路径",
        "hardRate": "MEDIUM",
        "passRate": "48.99%",
        "problemsUrl": "https://leetcode.cn/problems/paths-with-sum-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/paths-with-sum-lcci/solution",
        "problemsDesc": "<p>给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。</p>\n\n<p><strong>示例:</strong><br>\n给定如下二叉树，以及目标和&nbsp;<code>sum = 22</code>，</p>\n\n<pre>              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\    / \\\n        7    2  5   1\n</pre>\n\n<p>返回:</p>\n\n<pre>3\n<strong>解释：</strong>和为 22&nbsp;的路径有：[5,4,11,2], [5,8,4,5], [4,11,7]</pre>\n\n<p>提示：</p>\n\n<ul>\n\t<li><code>节点总数 &lt;= 10000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3076.插入",
        "hardRate": "EASY",
        "passRate": "51.43%",
        "problemsUrl": "https://leetcode.cn/problems/insert-into-bits-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/insert-into-bits-lcci/solution",
        "problemsDesc": "<p>给定两个整型数字 <code>N</code> 与 <code>M</code>，以及表示比特位置的 <code>i</code> 与 <code>j</code>（<code>i <= j</code>，且从 0 位开始计算）。</p>\n\n<p>编写一种方法，使 <code>M</code> 对应的二进制数字插入 <code>N</code> 对应的二进制数字的第 <code>i ~ j</code> 位区域，不足之处用 <code>0</code> 补齐。具体插入过程如图所示。</p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1610104070-NuLVQi-05.01.gif\" style=\"width: 267px; height: 200px;\" /></p>\n\n<p>题目保证从 <code>i</code> 位到 <code>j</code> 位足以容纳 <code>M</code>， 例如： <code>M = 10011</code>，则 <code>i～j</code> 区域至少可容纳 5 位。</p>\n\n<p> </p>\n\n<p><strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>：N = 1024(10000000000), M = 19(10011), i = 2, j = 6\n<strong> 输出</strong>：N = 1100(10001001100)\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>： N = 0, M = 31(11111), i = 0, j = 4\n<strong> 输出</strong>：N = 31(11111)\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3077.二进制数转字符串",
        "hardRate": "MEDIUM",
        "passRate": "76.83%",
        "problemsUrl": "https://leetcode.cn/problems/binary-number-to-string-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-number-to-string-lcci/solution",
        "problemsDesc": "<p>二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字无法精确地用32位以内的二进制表示，则打印“ERROR”。</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>：0.625\n<strong> 输出</strong>：\"0.101\"\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>：0.1\n<strong> 输出</strong>：\"ERROR\"\n<strong> 提示</strong>：0.1无法被二进制准确表示\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>32位包括输出中的 <code>\"0.\"</code> 这两位。</li>\n\t<li>题目保证输入用例的小数位数最多只有 <code>6</code> 位</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3078.翻转数位",
        "hardRate": "EASY",
        "passRate": "37.63%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-bits-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-bits-lcci/solution",
        "problemsDesc": "<p>给定一个32位整数 <code>num</code>，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入:</strong> <code>num</code> = 1775(11011101111<sub>2</sub>)\n<strong>输出:</strong> 8\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入:</strong> <code>num</code> = 7(0111<sub>2</sub>)\n<strong>输出:</strong> 4\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3079.下一个数",
        "hardRate": "MEDIUM",
        "passRate": "35.61%",
        "problemsUrl": "https://leetcode.cn/problems/closed-number-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/closed-number-lcci/solution",
        "problemsDesc": "<p>下一个数。给定一个正整数，找出与其二进制表达式中1的个数相同且大小最接近的那两个数（一个略大，一个略小）。</p>\n\n<p> <strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>：num = 2（或者0b10）\n<strong> 输出</strong>：[4, 1] 或者（[0b100, 0b1]）\n</pre>\n\n<p> <strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>：num = 1\n<strong> 输出</strong>：[2, -1]\n</pre>\n\n<p> <strong>提示:</strong></p>\n\n<ol>\n<li><code>num</code>的范围在[1, 2147483647]之间；</li>\n<li>如果找不到前一个或者后一个满足条件的正数，那么输出 -1。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3080.整数转换",
        "hardRate": "EASY",
        "passRate": "51.62%",
        "problemsUrl": "https://leetcode.cn/problems/convert-integer-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-integer-lcci/solution",
        "problemsDesc": "<p>整数转换。编写一个函数，确定需要改变几个位才能将整数A转成整数B。</p>\n\n<p> <strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>：A = 29 （或者0b11101）, B = 15（或者0b01111）\n<strong> 输出</strong>：2\n</pre>\n\n<p> <strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>：A = 1，B = 2\n<strong> 输出</strong>：2\n</pre>\n\n<p> <strong>提示:</strong></p>\n\n<ol>\n<li>A，B范围在[-2147483648, 2147483647]之间</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3081.配对交换",
        "hardRate": "EASY",
        "passRate": "71.00%",
        "problemsUrl": "https://leetcode.cn/problems/exchange-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/exchange-lcci/solution",
        "problemsDesc": "<p>配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0与位1交换，位2与位3交换，以此类推）。</p>\n\n<p> <strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>：num = 2（或者0b10）\n<strong> 输出</strong> 1 (或者 0b01)\n</pre>\n\n<p> <strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>：num = 3\n<strong> 输出</strong>：3\n</pre>\n\n<p> <strong>提示:</strong></p>\n\n<ol>\n<li><code>num</code>的范围在[0, 2^30 - 1]之间，不会发生整数溢出。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3082.绘制直线",
        "hardRate": "MEDIUM",
        "passRate": "53.70%",
        "problemsUrl": "https://leetcode.cn/problems/draw-line-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/draw-line-lcci/solution",
        "problemsDesc": "<p>已知一个由像素点组成的单色屏幕，每行均有 <code>w</code> 个像素点，所有像素点初始为 <code>0</code>，左上角位置为 <code>(0,0)</code>。</p>\n\n<p>现将每行的像素点按照「每 <code>32</code> 个像素点」为一组存放在一个 <code>int</code> 中，再依次存入长度为 <code>length</code> 的一维数组中。</p>\n\n<p>我们将在屏幕上绘制一条从点 <code>(x1,y)</code> 到点 <code>(x2,y)</code> 的直线（即像素点修改为 <code>1</code>），请返回绘制过后的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>用例保证屏幕宽度 <code>w</code> 可被 32 整除（即一个 <code>int</code> 不会分布在两行上）</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>：length = 1, w = 32, x1 = 30, x2 = 31, y = 0\n<strong> 输出</strong>：[3]\n<strong> 解释</strong>：在第 0 行的第 30 位到第 31 位画一条直线，屏幕二进制形式表示为 [00000000000000000000000000000011]，因此返回 [3]\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>：length = 3, w = 96, x1 = 0, x2 = 95, y = 0\n<strong> 输出</strong>：[-1, -1, -1]\n<strong> 解释</strong>：由于二进制 <strong>11111111111111111111111111111111</strong> 的 int 类型代表 -1，因此返回 [-1,-1,-1]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= w &lt;= 3 * 10^5</code></li>\n\t<li><code>0 &lt;= x1 &lt;= x2 &lt; w</code></li>\n\t<li><code>0 &lt;= y &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3083.三步问题",
        "hardRate": "EASY",
        "passRate": "36.66%",
        "problemsUrl": "https://leetcode.cn/problems/three-steps-problem-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/three-steps-problem-lcci/solution",
        "problemsDesc": "<p>三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。</p>\n\n<p> <strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>：n = 3 \n<strong> 输出</strong>：4\n<strong> 说明</strong>: 有四种走法\n</pre>\n\n<p> <strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>：n = 5\n<strong> 输出</strong>：13\n</pre>\n\n<p> <strong>提示:</strong></p>\n\n<ol>\n<li>n范围在[1, 1000000]之间</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3084.迷路的机器人",
        "hardRate": "MEDIUM",
        "passRate": "36.17%",
        "problemsUrl": "https://leetcode.cn/problems/robot-in-a-grid-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/robot-in-a-grid-lcci/solution",
        "problemsDesc": "<p>设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。</p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png\" style=\"height: 183px; width: 400px;\"></p>\n\n<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>\n\n<p>返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。如果没有可行的路径，返回空数组。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:\n</strong>[\n&nbsp; [<strong>0</strong>,<strong>0</strong>,<strong>0</strong>],\n&nbsp; [0,1,<strong>0</strong>],\n&nbsp; [0,0,<strong>0</strong>]\n]\n<strong>输出:</strong> [[0,0],[0,1],[0,2],[1,2],[2,2]]\n<strong>解释: \n</strong>输入中标粗的位置即为输出表示的路径，即\n0行0列（左上角） -&gt; 0行1列 -&gt; 0行2列 -&gt; 1行2列 -&gt; 2行2列（右下角）</pre>\n\n<p><strong>说明：</strong><em>r</em>&nbsp;和 <em>c </em>的值均不超过 100。</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3085.魔术索引",
        "hardRate": "EASY",
        "passRate": "67.41%",
        "problemsUrl": "https://leetcode.cn/problems/magic-index-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/magic-index-lcci/solution",
        "problemsDesc": "<p>魔术索引。 在数组<code>A[0...n-1]</code>中，有所谓的魔术索引，满足条件<code>A[i] = i</code>。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre><strong> 输入</strong>：nums = [0, 2, 3, 4, 5]\n<strong> 输出</strong>：0\n<strong> 说明</strong>: 0下标的元素为0\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre><strong> 输入</strong>：nums = [1, 1, 1]\n<strong> 输出</strong>：1\n</pre>\n\n<p><strong>说明:</strong></p>\n\n<ol>\n\t<li>nums长度在[1, 1000000]之间</li>\n\t<li>此题为原书中的 Follow-up，即数组中可能包含重复元素的版本</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3086.幂集",
        "hardRate": "MEDIUM",
        "passRate": "82.10%",
        "problemsUrl": "https://leetcode.cn/problems/power-set-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/power-set-lcci/solution",
        "problemsDesc": "<p>幂集。编写一种方法，返回某集合的所有子集。集合中<strong>不包含重复的元素</strong>。</p>\n\n<p>说明：解集不能包含重复的子集。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong> 输入</strong>： nums = [1,2,3]\n<strong> 输出</strong>：\n[\n  [3],\n&nbsp; [1],\n&nbsp; [2],\n&nbsp; [1,2,3],\n&nbsp; [1,3],\n&nbsp; [2,3],\n&nbsp; [1,2],\n&nbsp; []\n]\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3087.递归乘法",
        "hardRate": "MEDIUM",
        "passRate": "65.63%",
        "problemsUrl": "https://leetcode.cn/problems/recursive-mulitply-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/recursive-mulitply-lcci/solution",
        "problemsDesc": "<p>递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。</p>\n\n<p> <strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>：A = 1, B = 10\n<strong> 输出</strong>：10\n</pre>\n\n<p> <strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>：A = 3, B = 4\n<strong> 输出</strong>：12\n</pre>\n\n<p> <strong>提示:</strong></p>\n\n<ol>\n<li>保证乘法范围不会溢出</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3088.汉诺塔问题",
        "hardRate": "EASY",
        "passRate": "64.82%",
        "problemsUrl": "https://leetcode.cn/problems/hanota-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/hanota-lcci/solution",
        "problemsDesc": "<p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>\n(1) 每次只能移动一个盘子;<br>\n(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>\n(3) 盘子只能叠在比它大的盘子上。</p>\n\n<p>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p>\n\n<p>你需要原地修改栈。</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre><strong> 输入</strong>：A = [2, 1, 0], B = [], C = []\n<strong> 输出</strong>：C = [2, 1, 0]\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre><strong> 输入</strong>：A = [1, 0], B = [], C = []\n<strong> 输出</strong>：C = [1, 0]\n</pre>\n\n<p><strong>提示:</strong></p>\n\n<ol>\n\t<li>A中盘子的数目不大于14个。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3089.无重复字符串的排列组合",
        "hardRate": "MEDIUM",
        "passRate": "80.97%",
        "problemsUrl": "https://leetcode.cn/problems/permutation-i-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/permutation-i-lcci/solution",
        "problemsDesc": "<p>无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。</p>\n\n<p> <strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>：S = \"qwe\"\n<strong> 输出</strong>：[\"qwe\", \"qew\", \"wqe\", \"weq\", \"ewq\", \"eqw\"]\n</pre>\n\n<p> <strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>：S = \"ab\"\n<strong> 输出</strong>：[\"ab\", \"ba\"]\n</pre>\n\n<p> <strong>提示:</strong></p>\n\n<ol>\n<li>字符都是英文字母。</li>\n<li>字符串长度在[1, 9]之间。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3090.有重复字符串的排列组合",
        "hardRate": "MEDIUM",
        "passRate": "69.76%",
        "problemsUrl": "https://leetcode.cn/problems/permutation-ii-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/permutation-ii-lcci/solution",
        "problemsDesc": "<p>有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre><strong> 输入</strong>：S = &quot;qqe&quot;\n<strong> 输出</strong>：[&quot;eqq&quot;,&quot;qeq&quot;,&quot;qqe&quot;]\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre><strong> 输入</strong>：S = &quot;ab&quot;\n<strong> 输出</strong>：[&quot;ab&quot;, &quot;ba&quot;]\n</pre>\n\n<p><strong>提示:</strong></p>\n\n<ol>\n\t<li>字符都是英文字母。</li>\n\t<li>字符串长度在[1, 9]之间。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3091.括号",
        "hardRate": "MEDIUM",
        "passRate": "82.16%",
        "problemsUrl": "https://leetcode.cn/problems/bracket-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/bracket-lcci/solution",
        "problemsDesc": "<p>括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。</p>\n\n<p>说明：解集不能包含重复的子集。</p>\n\n<p>例如，给出 n = 3，生成结果为：</p>\n\n<pre>\n[\n  \"((()))\",\n  \"(()())\",\n  \"(())()\",\n  \"()(())\",\n  \"()()()\"\n]\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3092.颜色填充",
        "hardRate": "EASY",
        "passRate": "55.75%",
        "problemsUrl": "https://leetcode.cn/problems/color-fill-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/color-fill-lcci/solution",
        "problemsDesc": "<p>编写函数，实现许多图片编辑软件都支持的「颜色填充」功能。</p>\n\n<p>待填充的图像用二维数组 <code>image</code> 表示，元素为初始颜色值。初始坐标点的行坐标为 <code>sr</code> 列坐标为 <code>sc</code>。需要填充的新颜色为 <code>newColor</code> 。</p>\n\n<p>「周围区域」是指颜色相同且在上、下、左、右四个方向上存在相连情况的若干元素。</p>\n\n<p>请用新颜色填充初始坐标点的周围区域，并返回填充后的图像。</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>：\nimage = [[1,1,1],[1,1,0],[1,0,1]] \nsr = 1, sc = 1, newColor = 2\n<strong>输出</strong>：[[2,2,2],[2,2,0],[2,0,1]]\n<strong>解释</strong>: \n初始坐标点位于图像的正中间，坐标 (sr,sc)=(1,1) 。\n初始坐标点周围区域上所有符合条件的像素点的颜色都被更改成 2 。\n注意，右下角的像素没有更改为 2 ，因为它不属于初始坐标点的周围区域。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>image</code> 和 <code>image[0]</code> 的长度均在范围 [1, 50] 内。</li>\n\t<li>初始坐标点 <code>(sr,sc)</code> 满足 <code>0 <= sr < image.length</code> 和 <code>0 <= sc < image[0].length</code> 。</li>\n\t<li><code>image[i][j]</code> 和 <code>newColor</code> 表示的颜色值在范围 <code>[0, 65535]</code> 内。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3093.硬币",
        "hardRate": "MEDIUM",
        "passRate": "49.71%",
        "problemsUrl": "https://leetcode.cn/problems/coin-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/coin-lcci/solution",
        "problemsDesc": "<p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p>\n\n<p> <strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>: n = 5\n<strong> 输出</strong>：2\n<strong> 解释</strong>: 有两种方式可以凑成总金额:\n5=5\n5=1+1+1+1+1\n</pre>\n\n<p> <strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>: n = 10\n<strong> 输出</strong>：4\n<strong> 解释</strong>: 有四种方式可以凑成总金额:\n10=10\n10=5+5\n10=5+1+1+1+1+1\n10=1+1+1+1+1+1+1+1+1+1\n</pre>\n\n<p> <strong>说明：</strong></p>\n\n<p>注意:</p>\n\n<p>你可以假设：</p>\n\n<ul>\n<li>0 &lt;= n (总金额) &lt;= 1000000</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3094.八皇后",
        "hardRate": "HARD",
        "passRate": "76.43%",
        "problemsUrl": "https://leetcode.cn/problems/eight-queens-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/eight-queens-lcci/solution",
        "problemsDesc": "<p>设计一种算法，打印 N 皇后在 N &times; N 棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。这里的&ldquo;对角线&rdquo;指的是所有的对角线，不只是平分整个棋盘的那两条对角线。</p>\n\n<p><strong>注意：</strong>本题相对原题做了扩展</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong> 输入</strong>：4\n<strong> 输出</strong>：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]\n<strong> 解释</strong>: 4 皇后问题存在如下两个不同的解法。\n[\n&nbsp;[&quot;.Q..&quot;, &nbsp;// 解法 1\n&nbsp; &quot;...Q&quot;,\n&nbsp; &quot;Q...&quot;,\n&nbsp; &quot;..Q.&quot;],\n\n&nbsp;[&quot;..Q.&quot;, &nbsp;// 解法 2\n&nbsp; &quot;Q...&quot;,\n&nbsp; &quot;...Q&quot;,\n&nbsp; &quot;.Q..&quot;]\n]\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3095.堆箱子",
        "hardRate": "HARD",
        "passRate": "51.27%",
        "problemsUrl": "https://leetcode.cn/problems/pile-box-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/pile-box-lcci/solution",
        "problemsDesc": "<p>堆箱子。给你一堆n个箱子，箱子宽 wi、深 di、高 hi。箱子不能翻转，将箱子堆起来时，下面箱子的宽度、高度和深度必须大于上面的箱子。实现一种方法，搭出最高的一堆箱子。箱堆的高度为每个箱子高度的总和。</p>\n\n<p>输入使用数组<code>[wi, di, hi]</code>表示每个箱子。</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre><strong> 输入</strong>：box = [[1, 1, 1], [2, 2, 2], [3, 3, 3]]\n<strong> 输出</strong>：6\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre><strong> 输入</strong>：box = [[1, 1, 1], [2, 3, 4], [2, 6, 7], [3, 4, 5]]\n<strong> 输出</strong>：10\n</pre>\n\n<p><strong>提示:</strong></p>\n\n<ol>\n\t<li>箱子的数目不大于3000个。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3096.布尔运算",
        "hardRate": "MEDIUM",
        "passRate": "52.44%",
        "problemsUrl": "https://leetcode.cn/problems/boolean-evaluation-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/boolean-evaluation-lcci/solution",
        "problemsDesc": "<p>给定一个布尔表达式和一个期望的布尔结果 result，布尔表达式由 <code>0</code> (false)、<code>1</code> (true)、<code>&amp;</code> (AND)、 <code>|</code> (OR) 和 <code>^</code> (XOR) 符号组成。实现一个函数，算出有几种可使该表达式得出 result 值的括号方法。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入: </strong>s = &quot;1^0|0|1&quot;, result = 0\n\n<strong>输出: </strong>2\n<strong>解释:</strong>&nbsp;两种可能的括号方法是\n1^(0|(0|1))\n1^((0|0)|1)\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入: </strong>s = &quot;0&amp;0&amp;0&amp;1^1|0&quot;, result = 1\n\n<strong>输出: </strong>10</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>运算符的数量不超过 19 个</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3097.合并排序的数组",
        "hardRate": "EASY",
        "passRate": "56.13%",
        "problemsUrl": "https://leetcode.cn/problems/sorted-merge-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/sorted-merge-lcci/solution",
        "problemsDesc": "<p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p>\n\n<p>初始化&nbsp;A 和 B 的元素数量分别为&nbsp;<em>m</em> 和 <em>n</em>。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong>\nA = [1,2,3,0,0,0], m = 3\nB = [2,5,6],       n = 3\n\n<strong>输出:</strong>&nbsp;[1,2,2,3,5,6]</pre>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li><code>A.length == n + m</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3098.变位词组",
        "hardRate": "MEDIUM",
        "passRate": "74.30%",
        "problemsUrl": "https://leetcode.cn/problems/group-anagrams-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/group-anagrams-lcci/solution",
        "problemsDesc": "<p>编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。</p>\n\n<p><strong>注意：</strong>本题相对原题稍作修改</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> <code>[&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</code>,\n<strong>输出:</strong>\n[\n  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],\n  [&quot;nat&quot;,&quot;tan&quot;],\n  [&quot;bat&quot;]\n]</pre>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>所有输入均为小写字母。</li>\n\t<li>不考虑答案输出的顺序。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3099.搜索旋转数组",
        "hardRate": "MEDIUM",
        "passRate": "38.47%",
        "problemsUrl": "https://leetcode.cn/problems/search-rotate-array-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/search-rotate-array-lcci/solution",
        "problemsDesc": "<p>搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre><strong> 输入</strong>: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5\n<strong> 输出</strong>: 8（元素5在该数组中的索引）\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre><strong> 输入</strong>：arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 11\n<strong> 输出</strong>：-1 （没有找到）\n</pre>\n\n<p><strong>提示:</strong></p>\n\n<ol>\n\t<li>arr 长度范围在[1, 1000000]之间</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3100.稀疏数组搜索",
        "hardRate": "EASY",
        "passRate": "56.85%",
        "problemsUrl": "https://leetcode.cn/problems/sparse-array-search-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/sparse-array-search-lcci/solution",
        "problemsDesc": "<p>稀疏数组搜索。有个排好序的字符串数组，其中散布着一些空字符串，编写一种方法，找出给定字符串的位置。</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre><strong> 输入</strong>: words = [&quot;at&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;ball&quot;, &quot;&quot;, &quot;&quot;, &quot;car&quot;, &quot;&quot;, &quot;&quot;,&quot;dad&quot;, &quot;&quot;, &quot;&quot;], s = &quot;ta&quot;\n<strong> 输出</strong>：-1\n<strong> 说明</strong>: 不存在返回-1。\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre><strong> 输入</strong>：words = [&quot;at&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;ball&quot;, &quot;&quot;, &quot;&quot;, &quot;car&quot;, &quot;&quot;, &quot;&quot;,&quot;dad&quot;, &quot;&quot;, &quot;&quot;], s = &quot;ball&quot;\n<strong> 输出</strong>：4\n</pre>\n\n<p><strong>提示:</strong></p>\n\n<ol>\n\t<li>words的长度在[1, 1000000]之间</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3101.排序矩阵查找",
        "hardRate": "MEDIUM",
        "passRate": "44.64%",
        "problemsUrl": "https://leetcode.cn/problems/sorted-matrix-search-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/sorted-matrix-search-lcci/solution",
        "problemsDesc": "<p>给定M&times;N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。</p>\n\n<p><strong>示例:</strong></p>\n\n<p>现有矩阵 matrix 如下：</p>\n\n<pre>[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n</pre>\n\n<p>给定 target&nbsp;=&nbsp;<code>5</code>，返回&nbsp;<code>true</code>。</p>\n\n<p>给定&nbsp;target&nbsp;=&nbsp;<code>20</code>，返回&nbsp;<code>false</code>。</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3102.数字流的秩",
        "hardRate": "MEDIUM",
        "passRate": "62.06%",
        "problemsUrl": "https://leetcode.cn/problems/rank-from-stream-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/rank-from-stream-lcci/solution",
        "problemsDesc": "<p>假设你正在读取一串整数。每隔一段时间，你希望能找出数字 x 的秩(小于或等于 x 的值的个数)。请实现数据结构和算法来支持这些操作，也就是说：</p>\n\n<p>实现 <code>track(int x)</code>&nbsp;方法，每读入一个数字都会调用该方法；</p>\n\n<p>实现 <code>getRankOfNumber(int x)</code> 方法，返回小于或等于 x 的值的个数。</p>\n\n<p><strong>注意：</strong>本题相对原题稍作改动</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong>\n[&quot;StreamRank&quot;, &quot;getRankOfNumber&quot;, &quot;track&quot;, &quot;getRankOfNumber&quot;]\n[[], [1], [0], [0]]\n<strong>输出:\n</strong>[null,0,null,1]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>x &lt;= 50000</code></li>\n\t<li><code>track</code>&nbsp;和&nbsp;<code>getRankOfNumber</code> 方法的调用次数均不超过 2000 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3103.峰与谷",
        "hardRate": "MEDIUM",
        "passRate": "65.86%",
        "problemsUrl": "https://leetcode.cn/problems/peaks-and-valleys-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/peaks-and-valleys-lcci/solution",
        "problemsDesc": "<p>在一个整数数组中，&ldquo;峰&rdquo;是大于或等于相邻整数的元素，相应地，&ldquo;谷&rdquo;是小于或等于相邻整数的元素。例如，在数组{5, 8, 4, 2, 3, 4, 6}中，{8, 6}是峰， {5, 2}是谷。现在给定一个整数数组，将该数组按峰与谷的交替顺序排序。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入: </strong>[5, 3, 1, 2, 3]\n<strong>输出:</strong>&nbsp;[5, 1, 3, 2, 3]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length &lt;= 10000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3104.交换数字",
        "hardRate": "MEDIUM",
        "passRate": "81.43%",
        "problemsUrl": "https://leetcode.cn/problems/swap-numbers-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/swap-numbers-lcci/solution",
        "problemsDesc": "<p>编写一个函数，不用临时变量，直接交换<code>numbers = [a, b]</code>中<code>a</code>与<code>b</code>的值。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入:</strong> numbers = [1,2]\n<strong>输出:</strong> [2,1]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>numbers.length == 2</code></li>\n\t<li><code>-2147483647 <= numbers[i] <= 2147483647</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3105.单词频率",
        "hardRate": "MEDIUM",
        "passRate": "76.94%",
        "problemsUrl": "https://leetcode.cn/problems/words-frequency-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/words-frequency-lcci/solution",
        "problemsDesc": "<p>设计一个方法，找出任意指定单词在一本书中的出现频率。</p>\n\n<p>你的实现应该支持如下操作：</p>\n\n<ul>\n\t<li><code>WordsFrequency(book)</code>构造函数，参数为字符串数组构成的一本书</li>\n\t<li><code>get(word)</code>查询指定单词在书中出现的频率</li>\n</ul>\n\n<p><strong>示例：</strong></p>\n\n<pre>WordsFrequency wordsFrequency = new WordsFrequency({&quot;i&quot;, &quot;have&quot;, &quot;an&quot;, &quot;apple&quot;, &quot;he&quot;, &quot;have&quot;, &quot;a&quot;, &quot;pen&quot;});\nwordsFrequency.get(&quot;you&quot;); //返回0，&quot;you&quot;没有出现过\nwordsFrequency.get(&quot;have&quot;); //返回2，&quot;have&quot;出现2次\nwordsFrequency.get(&quot;an&quot;); //返回1\nwordsFrequency.get(&quot;apple&quot;); //返回1\nwordsFrequency.get(&quot;pen&quot;); //返回1\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>book[i]</code>中只包含小写字母</li>\n\t<li><code>1 &lt;= book.length &lt;= 100000</code></li>\n\t<li><code>1 &lt;= book[i].length &lt;= 10</code></li>\n\t<li><code>get</code>函数的调用次数不会超过100000</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3106.交点",
        "hardRate": "HARD",
        "passRate": "43.86%",
        "problemsUrl": "https://leetcode.cn/problems/intersection-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/intersection-lcci/solution",
        "problemsDesc": "<p>给定两条线段（表示为起点<code>start = {X1, Y1}</code>和终点<code>end = {X2, Y2}</code>），如果它们有交点，请计算其交点，没有交点则返回空值。</p>\n\n<p>要求浮点型误差不超过<code>10^-6</code>。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>\nline1 = {0, 0}, {1, 0}\nline2 = {1, 1}, {0, -1}\n<strong>输出：</strong> {0.5, 0}\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>\nline1 = {0, 0}, {3, 3}\nline2 = {1, 1}, {2, 2}\n<strong>输出：</strong> {1, 1}\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>\nline1 = {0, 0}, {1, 1}\nline2 = {1, 0}, {2, 1}\n<strong>输出：</strong> {}，两条线段没有交点\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>坐标绝对值不会超过 2^7</li>\n\t<li>输入的坐标均是有效的二维坐标</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3107.井字游戏",
        "hardRate": "MEDIUM",
        "passRate": "46.89%",
        "problemsUrl": "https://leetcode.cn/problems/tic-tac-toe-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/tic-tac-toe-lcci/solution",
        "problemsDesc": "<p>设计一个算法，判断玩家是否赢了井字游戏。输入是一个 N x N 的数组棋盘，由字符&quot; &quot;，&quot;X&quot;和&quot;O&quot;组成，其中字符&quot; &quot;代表一个空位。</p>\n\n<p>以下是井字游戏的规则：</p>\n\n<ul>\n\t<li>玩家轮流将字符放入空位（&quot; &quot;）中。</li>\n\t<li>第一个玩家总是放字符&quot;O&quot;，且第二个玩家总是放字符&quot;X&quot;。</li>\n\t<li>&quot;X&quot;和&quot;O&quot;只允许放置在空位中，不允许对已放有字符的位置进行填充。</li>\n\t<li>当有N个相同（且非空）的字符填充任何行、列或对角线时，游戏结束，对应该字符的玩家获胜。</li>\n\t<li>当所有位置非空时，也算为游戏结束。</li>\n\t<li>如果游戏结束，玩家不允许再放置字符。</li>\n</ul>\n\n<p>如果游戏存在获胜者，就返回该游戏的获胜者使用的字符（&quot;X&quot;或&quot;O&quot;）；如果游戏以平局结束，则返回 &quot;Draw&quot;；如果仍会有行动（游戏未结束），则返回 &quot;Pending&quot;。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong> board = [&quot;O X&quot;,&quot; XO&quot;,&quot;X O&quot;]\n<strong>输出：</strong> &quot;X&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong> board = [&quot;OOX&quot;,&quot;XXO&quot;,&quot;OXO&quot;]\n<strong>输出：</strong> &quot;Draw&quot;\n<strong>解释：</strong> 没有玩家获胜且不存在空位\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong> board = [&quot;OOX&quot;,&quot;XXO&quot;,&quot;OX &quot;]\n<strong>输出：</strong> &quot;Pending&quot;\n<strong>解释：</strong> 没有玩家获胜且仍存在空位\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= board.length == board[i].length &lt;= 100</code></li>\n\t<li>输入一定遵循井字棋规则</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3108.阶乘尾数",
        "hardRate": "EASY",
        "passRate": "43.79%",
        "problemsUrl": "https://leetcode.cn/problems/factorial-zeros-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/factorial-zeros-lcci/solution",
        "problemsDesc": "<p>设计一个算法，算出 n 阶乘有多少个尾随零。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> 3\n<strong>输出:</strong> 0\n<strong>解释:</strong>&nbsp;3! = 6, 尾数中没有零。</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> 5\n<strong>输出:</strong> 1\n<strong>解释:</strong>&nbsp;5! = 120, 尾数中有 1 个零.</pre>\n\n<p><strong>说明: </strong>你算法的时间复杂度应为&nbsp;<em>O</em>(log&nbsp;<em>n</em>)<em>&nbsp;</em>。</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3109.最小差",
        "hardRate": "MEDIUM",
        "passRate": "42.72%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-difference-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-difference-lcci/solution",
        "problemsDesc": "<p>给定两个整数数组<code>a</code>和<code>b</code>，计算具有最小差绝对值的一对数值（每个数组中取一个值），并返回该对数值的差</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>{1, 3, 15, 11, 2}, {23, 127, 235, 19, 8}\n<strong>输出：</strong>3，即数值对(11, 8)\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= a.length, b.length <= 100000</code></li>\n\t<li><code>-2147483648 <= a[i], b[i] <= 2147483647</code></li>\n\t<li>正确结果在区间 <code>[0, 2147483647]</code> 内</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3110.最大数值",
        "hardRate": "EASY",
        "passRate": "73.98%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-lcci/solution",
        "problemsDesc": "<p>编写一个方法，找出两个数字<code>a</code>和<code>b</code>中最大的那一个。不得使用if-else或其他比较运算符。</p>\n<p><strong>示例：</strong></p>\n<pre><strong>输入：</strong> a = 1, b = 2\n<strong>输出：</strong> 2\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3111.整数的英语表示",
        "hardRate": "HARD",
        "passRate": "39.14%",
        "problemsUrl": "https://leetcode.cn/problems/english-int-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/english-int-lcci/solution",
        "problemsDesc": "<p>给定一个整数，打印该整数的英文描述。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> 123\n<strong>输出:</strong> \"One Hundred Twenty Three\"\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> 12345\n<strong>输出:</strong> \"Twelve Thousand Three Hundred Forty Five\"</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> 1234567\n<strong>输出:</strong> \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"</pre>\n\n<p><strong>示例 4:</strong></p>\n\n<pre>\n<strong>输入:</strong> 1234567891\n<strong>输出:</strong> \"One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One\"</pre>\n\n<p>注意：本题与 273 题相同：<a href=\"https://leetcode-cn.com/problems/integer-to-english-words/\">https://leetcode-cn.com/problems/integer-to-english-words/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3112.运算",
        "hardRate": "MEDIUM",
        "passRate": "56.23%",
        "problemsUrl": "https://leetcode.cn/problems/operations-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/operations-lcci/solution",
        "problemsDesc": "<p>请实现整数数字的乘法、减法和除法运算，运算结果均为整数数字，程序中只允许使用加法运算符和逻辑运算符，允许程序中出现正负常数，不允许使用位运算。</p>\n<p>你的实现应该支持如下操作：</p>\n<ul>\n<li><code>Operations()</code> 构造函数</li>\n<li><code>minus(a, b)</code> 减法，返回<code>a - b</code></li>\n<li><code>multiply(a, b)</code> 乘法，返回<code>a * b</code></li>\n<li><code>divide(a, b)</code> 除法，返回<code>a / b</code></li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre>Operations operations = new Operations();\noperations.minus(1, 2); //返回-1\noperations.multiply(3, 4); //返回12\noperations.divide(5, -2); //返回-2\n</pre>\n<p><strong>提示：</strong></p>\n<ul>\n<li>你可以假设函数输入一定是有效的，例如不会出现除法分母为0的情况</li>\n<li>单个用例的函数调用次数不会超过1000次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3113.生存人数",
        "hardRate": "MEDIUM",
        "passRate": "66.93%",
        "problemsUrl": "https://leetcode.cn/problems/living-people-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/living-people-lcci/solution",
        "problemsDesc": "<p>给定 N 个人的出生年份和死亡年份，第 <code>i</code> 个人的出生年份为 <code>birth[i]</code>，死亡年份为 <code>death[i]</code>，实现一个方法以计算生存人数最多的年份。</p>\n\n<p>你可以假设所有人都出生于 1900 年至 2000 年（含 1900 和 2000 ）之间。如果一个人在某一年的任意时期处于生存状态，那么他应该被纳入那一年的统计中。例如，生于 1908 年、死于 1909 年的人应当被列入 1908 年和 1909 年的计数。</p>\n\n<p>如果有多个年份生存人数相同且均为最大值，输出其中最小的年份。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nbirth = [1900, 1901, 1950]\ndeath = [1948, 1951, 2000]\n<strong>输出：</strong> 1901\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt; birth.length == death.length &lt;= 10000</code></li>\n\t<li><code>birth[i] &lt;= death[i]</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3114.跳水板",
        "hardRate": "EASY",
        "passRate": "43.87%",
        "problemsUrl": "https://leetcode.cn/problems/diving-board-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/diving-board-lcci/solution",
        "problemsDesc": "<p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为<code>shorter</code>，长度较长的木板长度为<code>longer</code>。你必须正好使用<code>k</code>块木板。编写一个方法，生成跳水板所有可能的长度。</p>\n\n<p>返回的长度需要从小到大排列。</p>\n\n<p><strong>示例 1</strong></p>\n\n<pre><code><strong>输入：</strong>\nshorter = 1\nlonger = 2\nk = 3\n<strong>输出：</strong> [3,4,5,6]\n<strong>解释：</strong>\n可以使用 3 次 shorter，得到结果 3；使用 2 次 shorter 和 1 次 longer，得到结果 4 。以此类推，得到最终结果。</code></pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>0 &lt; shorter &lt;= longer</li>\n\t<li>0 &lt;= k &lt;= 100000</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3115.平分正方形",
        "hardRate": "MEDIUM",
        "passRate": "43.63%",
        "problemsUrl": "https://leetcode.cn/problems/bisect-squares-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/bisect-squares-lcci/solution",
        "problemsDesc": "<p>给定两个正方形及一个二维平面。请找出将这两个正方形分割成两半的一条直线。假设正方形顶边和底边与 x 轴平行。</p>\n\n<p>每个正方形的数据<code>square</code>包含3个数值，正方形的左下顶点坐标<code>[X,Y] = [square[0],square[1]]</code>，以及正方形的边长<code>square[2]</code>。所求直线穿过两个正方形会形成4个交点，请返回4个交点形成线段的两端点坐标（两个端点即为4个交点中距离最远的2个点，这2个点所连成的线段一定会穿过另外2个交点）。2个端点坐标<code>[X<sub>1</sub>,Y<sub>1</sub>]</code>和<code>[X<sub>2</sub>,Y<sub>2</sub>]</code>的返回格式为<code>{X<sub>1</sub>,Y<sub>1</sub>,X<sub>2</sub>,Y<sub>2</sub>}</code>，要求若<code>X<sub>1</sub> != X<sub>2</sub></code>，需保证<code>X<sub>1</sub> &lt; X<sub>2</sub></code>，否则需保证<code>Y<sub>1</sub> &lt;= Y<sub>2</sub></code>。</p>\n\n<p>若同时有多条直线满足要求，则选择斜率最大的一条计算并返回（与Y轴平行的直线视为斜率无穷大）。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>\nsquare1 = {-1, -1, 2}\nsquare2 = {0, -1, 2}\n<strong>输出：</strong> {-1,0,2,0}\n<strong>解释：</strong> 直线 y = 0 能将两个正方形同时分为等面积的两部分，返回的两线段端点为[-1,0]和[2,0]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>square.length == 3</code></li>\n\t<li><code>square[2] &gt; 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3116.最佳直线",
        "hardRate": "MEDIUM",
        "passRate": "55.58%",
        "problemsUrl": "https://leetcode.cn/problems/best-line-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/best-line-lcci/solution",
        "problemsDesc": "<p>给定一个二维平面及平面上的 N 个点列表<code>Points</code>，其中第<code>i</code>个点的坐标为<code>Points[i]=[X<sub>i</sub>,Y<sub>i</sub>]</code>。请找出一条直线，其通过的点的数目最多。</p>\n<p>设穿过最多点的直线所穿过的全部点编号从小到大排序的列表为<code>S</code>，你仅需返回<code>[S[0],S[1]]</code>作为答案，若有多条直线穿过了相同数量的点，则选择<code>S[0]</code>值较小的直线返回，<code>S[0]</code>相同则选择<code>S[1]</code>值较小的直线返回。</p>\n<p><strong>示例：</strong></p>\n<pre><strong>输入：</strong> [[0,0],[1,1],[1,0],[2,0]]\n<strong>输出：</strong> [0,2]\n<strong>解释：</strong> 所求直线穿过的3个点的编号为[0,2,3]\n</pre>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>2 <= len(Points) <= 300</code></li>\n<li><code>len(Points[i]) = 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3117.珠玑妙算",
        "hardRate": "EASY",
        "passRate": "46.38%",
        "problemsUrl": "https://leetcode.cn/problems/master-mind-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/master-mind-lcci/solution",
        "problemsDesc": "<p>珠玑妙算游戏（the game of master mind）的玩法如下。</p>\n<p>计算机有4个槽，每个槽放一个球，颜色可能是红色（R）、黄色（Y）、绿色（G）或蓝色（B）。例如，计算机可能有RGGB 4种（槽1为红色，槽2、3为绿色，槽4为蓝色）。作为用户，你试图猜出颜色组合。打个比方，你可能会猜YRGB。要是猜对某个槽的颜色，则算一次“猜中”；要是只猜对颜色但槽位猜错了，则算一次“伪猜中”。注意，“猜中”不能算入“伪猜中”。</p>\n<p>给定一种颜色组合<code>solution</code>和一个猜测<code>guess</code>，编写一个方法，返回猜中和伪猜中的次数<code>answer</code>，其中<code>answer[0]</code>为猜中的次数，<code>answer[1]</code>为伪猜中的次数。</p>\n<p><strong>示例：</strong></p>\n<pre><strong>输入：</strong> solution=\"RGBY\",guess=\"GGRR\"\n<strong>输出：</strong> [1,1]\n<strong>解释：</strong> 猜中1次，伪猜中1次。\n</pre>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>len(solution) = len(guess) = 4</code></li>\n<li><code>solution</code>和<code>guess</code>仅包含<code>\"R\"</code>,<code>\"G\"</code>,<code>\"B\"</code>,<code>\"Y\"</code>这4种字符</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3118.部分排序",
        "hardRate": "MEDIUM",
        "passRate": "46.71%",
        "problemsUrl": "https://leetcode.cn/problems/sub-sort-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/sub-sort-lcci/solution",
        "problemsDesc": "<p>给定一个整数数组，编写一个函数，找出索引<code>m</code>和<code>n</code>，只要将索引区间<code>[m,n]</code>的元素排好序，整个数组就是有序的。注意：<code>n-m</code>尽量最小，也就是说，找出符合条件的最短序列。函数返回值为<code>[m,n]</code>，若不存在这样的<code>m</code>和<code>n</code>（例如整个数组是有序的），请返回<code>[-1,-1]</code>。</p>\n<p><strong>示例：</strong></p>\n<pre><strong>输入：</strong> [1,2,4,7,10,11,7,12,6,7,16,18,19]\n<strong>输出：</strong> [3,9]\n</pre>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 <= len(array) <= 1000000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3119.连续数列",
        "hardRate": "EASY",
        "passRate": "58.91%",
        "problemsUrl": "https://leetcode.cn/problems/contiguous-sequence-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/contiguous-sequence-lcci/solution",
        "problemsDesc": "<p>给定一个整数数组，找出总和最大的连续数列，并返回总和。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong> [-2,1,-3,4,-1,2,1,-5,4]\n<strong>输出：</strong> 6\n<strong>解释：</strong> 连续子数组 [4,-1,2,1] 的和最大，为 6。\n</pre>\n\n<p><strong>进阶：</strong></p>\n\n<p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3120.模式匹配",
        "hardRate": "MEDIUM",
        "passRate": "33.88%",
        "problemsUrl": "https://leetcode.cn/problems/pattern-matching-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/pattern-matching-lcci/solution",
        "problemsDesc": "<p>你有两个字符串，即<code>pattern</code>和<code>value</code>。 <code>pattern</code>字符串由字母<code>&quot;a&quot;</code>和<code>&quot;b&quot;</code>组成，用于描述字符串中的模式。例如，字符串<code>&quot;catcatgocatgo&quot;</code>匹配模式<code>&quot;aabab&quot;</code>（其中<code>&quot;cat&quot;</code>是<code>&quot;a&quot;</code>，<code>&quot;go&quot;</code>是<code>&quot;b&quot;</code>），该字符串也匹配像<code>&quot;a&quot;</code>、<code>&quot;ab&quot;</code>和<code>&quot;b&quot;</code>这样的模式。但需注意<code>&quot;a&quot;</code>和<code>&quot;b&quot;</code>不能同时表示相同的字符串。编写一个方法判断<code>value</code>字符串是否匹配<code>pattern</code>字符串。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong> pattern = &quot;abba&quot;, value = &quot;dogcatcatdog&quot;\n<strong>输出：</strong> true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong> pattern = &quot;abba&quot;, value = &quot;dogcatcatfish&quot;\n<strong>输出：</strong> false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong> pattern = &quot;aaaa&quot;, value = &quot;dogcatcatdog&quot;\n<strong>输出：</strong> false\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong> pattern = &quot;abba&quot;, value = &quot;dogdogdogdog&quot;\n<strong>输出：</strong> true\n<strong>解释：</strong> &quot;a&quot;=&quot;dogdog&quot;,b=&quot;&quot;，反之也符合规则\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= len(pattern) &lt;= 1000</code></li>\n\t<li><code>0 &lt;= len(value) &lt;= 1000</code></li>\n\t<li>你可以假设<code>pattern</code>只包含字母<code>&quot;a&quot;</code>和<code>&quot;b&quot;</code>，<code>value</code>仅包含小写字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3121.水域大小",
        "hardRate": "MEDIUM",
        "passRate": "66.24%",
        "problemsUrl": "https://leetcode.cn/problems/pond-sizes-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/pond-sizes-lcci/solution",
        "problemsDesc": "<p>你有一个用于表示一片土地的整数矩阵<code>land</code>，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。</p>\n<p><strong>示例：</strong></p>\n<pre><strong>输入：</strong>\n[\n  [0,2,1,0],\n  [0,1,0,1],\n  [1,1,0,1],\n  [0,1,0,1]\n]\n<strong>输出：</strong> [1,2,4]\n</pre>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 < len(land) <= 1000</code></li>\n<li><code>0 < len(land[i]) <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3122.T9键盘",
        "hardRate": "MEDIUM",
        "passRate": "71.19%",
        "problemsUrl": "https://leetcode.cn/problems/t9-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/t9-lcci/solution",
        "problemsDesc": "<p>在老式手机上，用户通过数字键盘输入，手机将提供与这些数字相匹配的单词列表。每个数字映射到0至4个字母。给定一个数字序列，实现一个算法来返回匹配单词的列表。你会得到一张含有有效单词的列表。映射如下图所示：</p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png\" style=\"width: 200px;\"></p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> num = &quot;8733&quot;, words = [&quot;tree&quot;, &quot;used&quot;]\n<strong>输出:</strong> [&quot;tree&quot;, &quot;used&quot;]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> num = &quot;2&quot;, words = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]\n<strong>输出:</strong> [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</pre>\n\n<p>提示：</p>\n\n<ul>\n\t<li><code>num.length &lt;= 1000</code></li>\n\t<li><code>words.length &lt;= 500</code></li>\n\t<li><code>words[i].length == num.length</code></li>\n\t<li><code>num</code>中不会出现 0, 1 这两个数字</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3123.交换和",
        "hardRate": "MEDIUM",
        "passRate": "47.64%",
        "problemsUrl": "https://leetcode.cn/problems/sum-swap-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-swap-lcci/solution",
        "problemsDesc": "<p>给定两个整数数组，请交换一对数值（每个数组中取一个数值），使得两个数组所有元素的和相等。</p>\n\n<p>返回一个数组，第一个元素是第一个数组中要交换的元素，第二个元素是第二个数组中要交换的元素。若有多个答案，返回任意一个均可。若无满足条件的数值，返回空数组。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> array1 = [4, 1, 2, 1, 1, 2], array2 = [3, 6, 3, 3]\n<strong>输出:</strong> [1, 3]\n</pre>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> array1 = <code>[1, 2, 3], array2 = [4, 5, 6]</code>\n<strong>输出: </strong>[]</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= array1.length, array2.length &lt;= 100000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3124.兰顿蚂蚁",
        "hardRate": "MEDIUM",
        "passRate": "57.85%",
        "problemsUrl": "https://leetcode.cn/problems/langtons-ant-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/langtons-ant-lcci/solution",
        "problemsDesc": "<p>一只蚂蚁坐在由白色和黑色方格构成的无限网格上。开始时，网格全白，蚂蚁面向右侧。每行走一步，蚂蚁执行以下操作。</p>\n\n<p>(1) 如果在白色方格上，则翻转方格的颜色，向右(顺时针)转 90 度，并向前移动一个单位。<br>\n(2) 如果在黑色方格上，则翻转方格的颜色，向左(逆时针方向)转 90 度，并向前移动一个单位。</p>\n\n<p>编写程序来模拟蚂蚁执行的前 K 个动作，并返回最终的网格。</p>\n\n<p>网格由数组表示，每个元素是一个字符串，代表网格中的一行，黑色方格由&nbsp;<code>&#39;X&#39;</code>&nbsp;表示，白色方格由&nbsp;<code>&#39;_&#39;</code>&nbsp;表示，蚂蚁所在的位置由&nbsp;<code>&#39;L&#39;</code>, <code>&#39;U&#39;</code>, <code>&#39;R&#39;</code>, <code>&#39;D&#39;</code>&nbsp;表示，分别表示蚂蚁&nbsp;左、上、右、下 的朝向。只需要返回能够包含蚂蚁走过的所有方格的最小矩形。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> 0\n<strong>输出: </strong>[&quot;R&quot;]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> 2\n<strong>输出:\n</strong>[\n&nbsp; &quot;_X&quot;,\n&nbsp; &quot;LX&quot;\n]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre><strong>输入:</strong> 5\n<strong>输出:\n</strong>[\n&nbsp; &quot;_U&quot;,\n&nbsp; &quot;X_&quot;,\n&nbsp; &quot;XX&quot;\n]\n</pre>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li><code>K &lt;= 100000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3125.数对和",
        "hardRate": "MEDIUM",
        "passRate": "48.26%",
        "problemsUrl": "https://leetcode.cn/problems/pairs-with-sum-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/pairs-with-sum-lcci/solution",
        "problemsDesc": "<p>设计一个算法，找出数组中两数之和为指定值的所有整数对。一个数只能属于一个数对。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [5,6,5], target = 11\n<strong>输出: </strong>[[5,6]]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [5,6,5,6], target = 11\n<strong>输出: </strong>[[5,6],[5,6]]</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length &lt;= 100000</code></li>\n\t<li><code>-10^5 &lt;= nums[i], target &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3126.LRU 缓存",
        "hardRate": "MEDIUM",
        "passRate": "55.48%",
        "problemsUrl": "https://leetcode.cn/problems/lru-cache-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/lru-cache-lcci/solution",
        "problemsDesc": "<p>设计和构建一个&ldquo;最近最少使用&rdquo;缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。</p>\n\n<p>它应该支持以下操作： 获取数据 <code>get</code> 和 写入数据 <code>put</code> 。</p>\n\n<p>获取数据 <code>get(key)</code> - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>\n写入数据 <code>put(key, value)</code> - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // 返回  1\ncache.put(3, 3);    // 该操作会使得密钥 2 作废\ncache.get(2);       // 返回 -1 (未找到)\ncache.put(4, 4);    // 该操作会使得密钥 1 作废\ncache.get(1);       // 返回 -1 (未找到)\ncache.get(3);       // 返回  3\ncache.get(4);       // 返回  4\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3127.计算器",
        "hardRate": "MEDIUM",
        "passRate": "39.76%",
        "problemsUrl": "https://leetcode.cn/problems/calculator-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/calculator-lcci/solution",
        "problemsDesc": "<p>给定一个包含正整数、加(+)、减(-)、乘(*)、除(/)的算数表达式(括号除外)，计算其结果。</p>\n\n<p>表达式仅包含非负整数，<code>+</code>， <code>-</code> ，<code>*</code>，<code>/</code> 四种运算符和空格&nbsp;<code>&nbsp;</code>。 整数除法仅保留整数部分。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入: </strong>&quot;3+2*2&quot;\n<strong>输出:</strong> 7\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> &quot; 3/2 &quot;\n<strong>输出:</strong> 1</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre><strong>输入:</strong> &quot; 3+5 / 2 &quot;\n<strong>输出:</strong> 5\n</pre>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>你可以假设所给定的表达式都是有效的。</li>\n\t<li>请<strong>不要</strong>使用内置的库函数 <code>eval</code>。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3128.不用加号的加法",
        "hardRate": "EASY",
        "passRate": "61.55%",
        "problemsUrl": "https://leetcode.cn/problems/add-without-plus-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/add-without-plus-lcci/solution",
        "problemsDesc": "<p>设计一个函数把两个数字相加。不得使用 + 或者其他算术运算符。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> a = 1, b = 1\n<strong>输出:</strong> 2</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>a</code>,&nbsp;<code>b</code>&nbsp;均可能是负数或 0</li>\n\t<li>结果不会溢出 32 位整数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3129.消失的数字",
        "hardRate": "EASY",
        "passRate": "59.41%",
        "problemsUrl": "https://leetcode.cn/problems/missing-number-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/missing-number-lcci/solution",
        "problemsDesc": "<p>数组<code>nums</code>包含从<code>0</code>到<code>n</code>的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？</p>\n\n<p><strong>注意：</strong>本题相对书上原题稍作改动</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[3,0,1]\n<strong>输出：</strong>2</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>[9,6,4,2,3,5,7,0,1]\n<strong>输出：</strong>8\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3130. 字母与数字",
        "hardRate": "MEDIUM",
        "passRate": "47.45%",
        "problemsUrl": "https://leetcode.cn/problems/find-longest-subarray-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/find-longest-subarray-lcci/solution",
        "problemsDesc": "<p>给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。</p>\n\n<p>返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>[\"A\",\"1\",\"B\",\"C\",\"D\",\"2\",\"3\",\"4\",\"E\",\"5\",\"F\",\"G\",\"6\",\"7\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\"]\n\n<strong>输出: </strong>[\"A\",\"1\",\"B\",\"C\",\"D\",\"2\",\"3\",\"4\",\"E\",\"5\",\"F\",\"G\",\"6\",\"7\"]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>[\"A\",\"A\"]\n\n<strong>输出: </strong>[]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>array.length <= 100000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3131.2出现的次数",
        "hardRate": "HARD",
        "passRate": "49.63%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-2s-in-range-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-2s-in-range-lcci/solution",
        "problemsDesc": "<p>编写一个方法，计算从 0 到 n (含 n) 中数字 2 出现的次数。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入: </strong>25\n<strong>输出: </strong>9\n<strong>解释: </strong>(2, 12, 20, 21, 22, 23, 24, 25)(注意 22 应该算作两次)</pre>\n\n<p>提示：</p>\n\n<ul>\n\t<li><code>n &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3132.婴儿名字",
        "hardRate": "MEDIUM",
        "passRate": "41.57%",
        "problemsUrl": "https://leetcode.cn/problems/baby-names-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/baby-names-lcci/solution",
        "problemsDesc": "<p>每年，政府都会公布一万个最常见的婴儿名字和它们出现的频率，也就是同名婴儿的数量。有些名字有多种拼法，例如，John 和 Jon 本质上是相同的名字，但被当成了两个名字公布出来。给定两个列表，一个是名字及对应的频率，另一个是本质相同的名字对。设计一个算法打印出每个真实名字的实际频率。注意，如果 John 和 Jon 是相同的，并且 Jon 和 Johnny 相同，则 John 与 Johnny 也相同，即它们有传递和对称性。</p>\n\n<p>在结果列表中，选择<strong> 字典序最小 </strong>的名字作为真实名字。</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>names = [\"John(15)\",\"Jon(12)\",\"Chris(13)\",\"Kris(4)\",\"Christopher(19)\"], synonyms = [\"(Jon,John)\",\"(John,Johnny)\",\"(Chris,Kris)\",\"(Chris,Christopher)\"]\n<strong>输出：</strong>[\"John(27)\",\"Chris(36)\"]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>names.length <= 100000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3133.马戏团人塔",
        "hardRate": "MEDIUM",
        "passRate": "28.51%",
        "problemsUrl": "https://leetcode.cn/problems/circus-tower-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/circus-tower-lcci/solution",
        "problemsDesc": "<p>有个马戏团正在设计叠罗汉的表演节目，一个人要站在另一人的肩膀上。出于实际和美观的考虑，在上面的人要比下面的人矮一点且轻一点。已知马戏团每个人的身高和体重，请编写代码计算叠罗汉最多能叠几个人。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>height = [65,70,56,75,60,68] weight = [100,150,90,190,95,110]\n<strong>输出：</strong>6\n<strong>解释：</strong>从上往下数，叠罗汉最多能叠 6 层：(56,90), (60,95), (65,100), (68,110), (70,150), (75,190)</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>height.length == weight.length <= 10000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3134.第 k 个数",
        "hardRate": "MEDIUM",
        "passRate": "56.11%",
        "problemsUrl": "https://leetcode.cn/problems/get-kth-magic-number-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/get-kth-magic-number-lcci/solution",
        "problemsDesc": "<p>有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入: </strong>k = 5\n\n<strong>输出: </strong>9\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3135.主要元素",
        "hardRate": "EASY",
        "passRate": "56.24%",
        "problemsUrl": "https://leetcode.cn/problems/find-majority-element-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/find-majority-element-lcci/solution",
        "problemsDesc": "<p>数组中占比超过一半的元素称之为主要元素。给你一个<strong> 整数 </strong>数组，找出其中的主要元素。若没有，返回 <code>-1</code> 。请设计时间复杂度为 <code>O(N)</code> 、空间复杂度为 <code>O(1)</code> 的解决方案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1,2,5,9,5,9,5,5,5]\n<strong>输出：</strong>5</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>[3,2]\n<strong>输出：</strong>-1</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>[2,2,1,1,1,2,2]\n<strong>输出：</strong>2</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3136.单词距离",
        "hardRate": "MEDIUM",
        "passRate": "73.08%",
        "problemsUrl": "https://leetcode.cn/problems/find-closest-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/find-closest-lcci/solution",
        "problemsDesc": "<p>有个内含单词的超大文本文件，给定任意两个<code>不同的</code>单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗?</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"I\",\"am\",\"a\",\"student\",\"from\",\"a\",\"university\",\"in\",\"a\",\"city\"], word1 = \"a\", word2 = \"student\"\n<strong>输出：</strong>1</pre>\n\n<p>提示：</p>\n\n<ul>\n\t<li><code>words.length &lt;= 100000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3137.BiNode",
        "hardRate": "EASY",
        "passRate": "63.90%",
        "problemsUrl": "https://leetcode.cn/problems/binode-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/binode-lcci/solution",
        "problemsDesc": "<p>二叉树数据结构<code>TreeNode</code>可用来表示单向链表（其中<code>left</code>置空，<code>right</code>为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。</p>\n\n<p>返回转换后的单向链表的头节点。</p>\n\n<p><strong>注意：</strong>本题相对原题稍作改动</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong> [4,2,5,1,3,null,6,0]\n<strong>输出：</strong> [0,null,1,null,2,null,3,null,4,null,5,null,6]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>节点数量不会超过 100000。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3138.恢复空格",
        "hardRate": "MEDIUM",
        "passRate": "55.42%",
        "problemsUrl": "https://leetcode.cn/problems/re-space-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/re-space-lcci/solution",
        "problemsDesc": "<p>哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子<code>&quot;I reset the computer. It still didn&rsquo;t boot!&quot;</code>已经变成了<code>&quot;iresetthecomputeritstilldidntboot&quot;</code>。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典<code>dictionary</code>，不过，有些词没在词典里。假设文章用<code>sentence</code>表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。</p>\n\n<p><strong>注意：</strong>本题相对原题稍作改动，只需返回未识别的字符数</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>\ndictionary = [&quot;looked&quot;,&quot;just&quot;,&quot;like&quot;,&quot;her&quot;,&quot;brother&quot;]\nsentence = &quot;jesslookedjustliketimherbrother&quot;\n<strong>输出：</strong> 7\n<strong>解释：</strong> 断句后为&quot;<strong>jess</strong> looked just like <strong>tim</strong> her brother&quot;，共7个未识别字符。\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= len(sentence) &lt;= 1000</code></li>\n\t<li><code>dictionary</code>中总字符数不超过 150000。</li>\n\t<li>你可以认为<code>dictionary</code>和<code>sentence</code>中只包含小写字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3139.最小K个数",
        "hardRate": "MEDIUM",
        "passRate": "58.89%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-k-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-k-lcci/solution",
        "problemsDesc": "<p>设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong> arr = [1,3,5,7,2,4,6,8], k = 4\n<strong>输出：</strong> [1,2,3,4]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= len(arr) &lt;= 100000</code></li>\n\t<li><code>0 &lt;= k &lt;= min(100000, len(arr))</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3140.最长单词",
        "hardRate": "MEDIUM",
        "passRate": "40.86%",
        "problemsUrl": "https://leetcode.cn/problems/longest-word-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-word-lcci/solution",
        "problemsDesc": "<p>给定一组单词<code>words</code>，编写一个程序，找出其中的最长单词，且该单词由这组单词中的其他单词组合而成。若有多个长度相同的结果，返回其中字典序最小的一项，若没有符合要求的单词则返回空字符串。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong> [&quot;cat&quot;,&quot;banana&quot;,&quot;dog&quot;,&quot;nana&quot;,&quot;walk&quot;,&quot;walker&quot;,&quot;dogwalker&quot;]\n<strong>输出：</strong> &quot;dogwalker&quot;\n<strong>解释：</strong> &quot;dogwalker&quot;可由&quot;dog&quot;和&quot;walker&quot;组成。\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= len(words) &lt;= 200</code></li>\n\t<li><code>1 &lt;= len(words[i]) &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3141.按摩师",
        "hardRate": "EASY",
        "passRate": "51.06%",
        "problemsUrl": "https://leetcode.cn/problems/the-masseuse-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/the-masseuse-lcci/solution",
        "problemsDesc": "<p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>\n\n<p><strong>注意：</strong>本题相对原题稍作改动</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong> [1,2,3,1]\n<strong>输出：</strong> 4\n<strong>解释：</strong> 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong> [2,7,9,3,1]\n<strong>输出：</strong> 12\n<strong>解释：</strong> 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong> [2,1,4,5,3,1,1,3]\n<strong>输出：</strong> 12\n<strong>解释：</strong> 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3142.多次搜索",
        "hardRate": "MEDIUM",
        "passRate": "44.74%",
        "problemsUrl": "https://leetcode.cn/problems/multi-search-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/multi-search-lcci/solution",
        "problemsDesc": "<p>给定一个较长字符串<code>big</code>和一个包含较短字符串的数组<code>smalls</code>，设计一个方法，根据<code>smalls</code>中的每一个较短字符串，对<code>big</code>进行搜索。输出<code>smalls</code>中的字符串在<code>big</code>里出现的所有位置<code>positions</code>，其中<code>positions[i]</code>为<code>smalls[i]</code>出现的所有位置。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>\nbig = &quot;mississippi&quot;\nsmalls = [&quot;is&quot;,&quot;ppi&quot;,&quot;hi&quot;,&quot;sis&quot;,&quot;i&quot;,&quot;ssippi&quot;]\n<strong>输出：</strong> [[1,4],[8],[],[3],[1,4,7,10],[5]]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= len(big) &lt;= 1000</code></li>\n\t<li><code>0 &lt;= len(smalls[i]) &lt;= 1000</code></li>\n\t<li><code>smalls</code>的总字符数不会超过 100000。</li>\n\t<li>你可以认为<code>smalls</code>中没有重复字符串。</li>\n\t<li>所有出现的字符均为英文小写字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3143.最短超串",
        "hardRate": "MEDIUM",
        "passRate": "44.34%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-supersequence-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-supersequence-lcci/solution",
        "problemsDesc": "<p>假设你有两个数组，一个长一个短，短的元素均不相同。找到长数组中包含短数组所有的元素的最短子数组，其出现顺序无关紧要。</p>\n\n<p>返回最短子数组的左端点和右端点，如有多个满足条件的子数组，返回左端点最小的一个。若不存在，返回空数组。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong>\nbig = <code>[7,5,9,0,2,1,3,<strong>5,7,9,1</strong>,1,5,8,8,9,7]\nsmall = [1,5,9]</code>\n<strong>输出: </strong>[7,10]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong>\nbig = <code>[1,2,3]\nsmall = [4]</code>\n<strong>输出: </strong>[]</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>big.length&nbsp;&lt;= 100000</code></li>\n\t<li><code>1 &lt;= small.length&nbsp;&lt;= 100000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3144.消失的两个数字",
        "hardRate": "HARD",
        "passRate": "60.57%",
        "problemsUrl": "https://leetcode.cn/problems/missing-two-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/missing-two-lcci/solution",
        "problemsDesc": "<p>给定一个数组，包含从 1 到 N 所有的整数，但其中缺了两个数字。你能在 O(N) 时间内只用 O(1) 的空间找到它们吗？</p>\n\n<p>以任意顺序返回这两个数字均可。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> <code>[1]</code>\n<strong>输出: </strong>[2,3]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> <code>[2,3]</code>\n<strong>输出: </strong>[1,4]</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length &lt;=&nbsp;30000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3145.连续中值",
        "hardRate": "HARD",
        "passRate": "58.37%",
        "problemsUrl": "https://leetcode.cn/problems/continuous-median-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/continuous-median-lcci/solution",
        "problemsDesc": "<p>随机产生数字并传递给一个方法。你能否完成这个方法，在每次产生新值时，寻找当前所有值的中间值（中位数）并保存。</p>\n\n<p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p>\n\n<p>例如，</p>\n\n<p>[2,3,4]&nbsp;的中位数是 3</p>\n\n<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>\n\n<p>设计一个支持以下两种操作的数据结构：</p>\n\n<ul>\n\t<li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li>\n\t<li>double findMedian() - 返回目前所有元素的中位数。</li>\n</ul>\n\n<p><strong>示例：</strong></p>\n\n<pre>addNum(1)\naddNum(2)\nfindMedian() -&gt; 1.5\naddNum(3) \nfindMedian() -&gt; 2\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3146.直方图的水量",
        "hardRate": "HARD",
        "passRate": "63.74%",
        "problemsUrl": "https://leetcode.cn/problems/volume-of-histogram-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/volume-of-histogram-lcci/solution",
        "problemsDesc": "<p>给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。</p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png\" style=\"height: 161px; width: 412px;\"></p>\n\n<p><small>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。&nbsp;<strong>感谢 Marcos</strong> 贡献此图。</small></p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> [0,1,0,2,1,0,1,3,2,1,2,1]\n<strong>输出:</strong> 6</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3147.单词转换",
        "hardRate": "MEDIUM",
        "passRate": "40.30%",
        "problemsUrl": "https://leetcode.cn/problems/word-transformer-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/word-transformer-lcci/solution",
        "problemsDesc": "<p>给定字典中的两个词，长度相等。写一个方法，把一个词转换成另一个词， 但是一次只能改变一个字符。每一步得到的新词都必须能在字典中找到。</p>\n\n<p>编写一个程序，返回一个可能的转换序列。如有多个可能的转换序列，你可以返回任何一个。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong>\nbeginWord = &quot;hit&quot;,\nendWord = &quot;cog&quot;,\nwordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\n\n<strong>输出:</strong>\n[&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong>\nbeginWord = &quot;hit&quot;\nendWord = &quot;cog&quot;\nwordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]\n\n<strong>输出: </strong>[]\n\n<strong>解释:</strong>&nbsp;<em>endWord</em> &quot;cog&quot; 不在字典中，所以不存在符合要求的转换序列。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3148.最大黑方阵",
        "hardRate": "MEDIUM",
        "passRate": "37.87%",
        "problemsUrl": "https://leetcode.cn/problems/max-black-square-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/max-black-square-lcci/solution",
        "problemsDesc": "<p>给定一个方阵，其中每个单元(像素)非黑即白。设计一个算法，找出 4 条边皆为黑色像素的最大子方阵。</p>\n\n<p>返回一个数组 <code>[r, c, size]</code> ，其中&nbsp;<code>r</code>,&nbsp;<code>c</code>&nbsp;分别代表子方阵左上角的行号和列号，<code>size</code> 是子方阵的边长。若有多个满足条件的子方阵，返回 <code>r</code> 最小的，若 <code>r</code> 相同，返回 <code>c</code> 最小的子方阵。若无满足条件的子方阵，返回空数组。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:\n</strong>[\n&nbsp;  [1,0,1],\n&nbsp;  [<strong>0,0</strong>,1],\n&nbsp;  [<strong>0,0</strong>,1]\n]\n<strong>输出: </strong>[1,0,2]\n<strong>解释: </strong>输入中 0 代表黑色，1 代表白色，标粗的元素即为满足条件的最大子方阵\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:\n</strong>[\n&nbsp;  [<strong>0</strong>,1,1],\n&nbsp;  [1,0,1],\n&nbsp;  [1,1,0]\n]\n<strong>输出: </strong>[0,0,1]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>matrix.length == matrix[0].length &lt;= 200</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3149.最大子矩阵",
        "hardRate": "HARD",
        "passRate": "53.61%",
        "problemsUrl": "https://leetcode.cn/problems/max-submatrix-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/max-submatrix-lcci/solution",
        "problemsDesc": "<p>给定一个正整数、负整数和 0 组成的 N &times; M&nbsp;矩阵，编写代码找出元素总和最大的子矩阵。</p>\n\n<p>返回一个数组 <code>[r1, c1, r2, c2]</code>，其中 <code>r1</code>, <code>c1</code> 分别代表子矩阵左上角的行号和列号，<code>r2</code>, <code>c2</code> 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。</p>\n\n<p><strong>注意：</strong>本题相对书上原题稍作改动</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：\n</strong><code>[\n&nbsp;  [-1,<strong>0</strong>],\n&nbsp;  [0,-1]\n]</code>\n<strong>输出：</strong>[0,1,0,1]\n<strong>解释：</strong>输入中标粗的元素即为输出所表示的矩阵</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= matrix.length, matrix[0].length &lt;= 200</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3150.单词矩阵",
        "hardRate": "HARD",
        "passRate": "50.85%",
        "problemsUrl": "https://leetcode.cn/problems/word-rectangle-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/word-rectangle-lcci/solution",
        "problemsDesc": "<p>给定一份单词的清单，设计一个算法，创建由字母组成的面积最大的矩形，其中每一行组成一个单词(自左向右)，每一列也组成一个单词(自上而下)。不要求这些单词在清单里连续出现，但要求所有行等长，所有列等高。</p>\n\n<p>如果有多个面积最大的矩形，输出任意一个均可。一个单词可以重复使用。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> <code>[&quot;this&quot;, &quot;real&quot;, &quot;hard&quot;, &quot;trh&quot;, &quot;hea&quot;, &quot;iar&quot;, &quot;sld&quot;]</code>\n<strong>输出:\n</strong><code>[\n&nbsp;  &quot;this&quot;,\n&nbsp;  &quot;real&quot;,\n&nbsp;  &quot;hard&quot;</code>\n]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> <code>[&quot;aa&quot;]</code>\n<strong>输出: </strong>[&quot;aa&quot;,&quot;aa&quot;]</pre>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li><code>words.length &lt;= 1000</code></li>\n\t<li><code>words[i].length &lt;= 100</code></li>\n\t<li>数据保证单词足够随机</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3151.稀疏相似度",
        "hardRate": "HARD",
        "passRate": "35.25%",
        "problemsUrl": "https://leetcode.cn/problems/sparse-similarity-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/sparse-similarity-lcci/solution",
        "problemsDesc": "<p>两个(具有不同单词的)文档的交集(intersection)中元素的个数除以并集(union)中元素的个数，就是这两个文档的相似度。例如，{1, 5, 3} 和 {1, 7, 2, 3} 的相似度是 0.4，其中，交集的元素有 2 个，并集的元素有 5 个。给定一系列的长篇文档，每个文档元素各不相同，并与一个 ID 相关联。它们的相似度非常&ldquo;稀疏&rdquo;，也就是说任选 2 个文档，相似度都很接近 0。请设计一个算法返回每对文档的 ID 及其相似度。只需输出相似度大于 0 的组合。请忽略空文档。为简单起见，可以假定每个文档由一个含有不同整数的数组表示。</p>\n\n<p>输入为一个二维数组 <code>docs</code>，<code>docs[i]</code>&nbsp;表示&nbsp;id 为 <code>i</code> 的文档。返回一个数组，其中每个元素是一个字符串，代表每对相似度大于 0 的文档，其格式为 <code>{id1},{id2}: {similarity}</code>，其中 <code>id1</code> 为两个文档中较小的 id，<code>similarity</code> 为相似度，精确到小数点后 4 位。以任意顺序返回数组均可。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> \n<code>[\n&nbsp; [14, 15, 100, 9, 3],\n&nbsp; [32, 1, 9, 3, 5],\n&nbsp; [15, 29, 2, 6, 8, 7],\n&nbsp; [7, 10]\n]</code>\n<strong>输出:</strong>\n[\n&nbsp; &quot;0,1: 0.2500&quot;,\n&nbsp; &quot;0,2: 0.1000&quot;,\n&nbsp; &quot;2,3: 0.1429&quot;\n]</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>docs.length &lt;= 500</code></li>\n\t<li><code>docs[i].length &lt;= 500</code></li>\n</ul>\n",
        "isPlus": false
    }
]