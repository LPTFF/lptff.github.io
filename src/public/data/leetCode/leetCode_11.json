[
    {
        "problemsName": " 1501.可以放心投资的国家",
        "hardRate": "MEDIUM",
        "passRate": "58.10%",
        "problemsUrl": "https://leetcode.cn/problems/countries-you-can-safely-invest-in/",
        "solutionsUrl": "https://leetcode.cn/problems/countries-you-can-safely-invest-in/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1502.判断能否形成等差数列",
        "hardRate": "EASY",
        "passRate": "69.37%",
        "problemsUrl": "https://leetcode.cn/problems/can-make-arithmetic-progression-from-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/can-make-arithmetic-progression-from-sequence/solution",
        "problemsDesc": "<p>给你一个数字数组 <code>arr</code> 。</p>\n\n<p>如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数列就称为 <strong>等差数列</strong> 。</p>\n\n<p>如果可以重新排列数组形成等差数列，请返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,5,1]\n<strong>输出：</strong>true\n<strong>解释：</strong>对数组重新排序得到 [1,3,5] 或者 [5,3,1] ，任意相邻两项的差分别为 2 或 -2 ，可以形成等差数列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,4]\n<strong>输出：</strong>false\n<strong>解释：</strong>无法通过重新排序得到等差数列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>-10^6 &lt;= arr[i] &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1503.所有蚂蚁掉下来前的最后一刻",
        "hardRate": "MEDIUM",
        "passRate": "53.78%",
        "problemsUrl": "https://leetcode.cn/problems/last-moment-before-all-ants-fall-out-of-a-plank/",
        "solutionsUrl": "https://leetcode.cn/problems/last-moment-before-all-ants-fall-out-of-a-plank/solution",
        "problemsDesc": "<p>有一块木板，长度为 <code>n</code> 个 <strong>单位</strong> 。一些蚂蚁在木板上移动，每只蚂蚁都以 <strong>每秒一个单位</strong> 的速度移动。其中，一部分蚂蚁向 <strong>左</strong> 移动，其他蚂蚁向 <strong>右</strong> 移动。</p>\n\n<p>当两只向 <strong>不同</strong> 方向移动的蚂蚁在某个点相遇时，它们会同时改变移动方向并继续移动。假设更改方向不会花费任何额外时间。</p>\n\n<p>而当蚂蚁在某一时刻 <code>t</code> 到达木板的一端时，它立即从木板上掉下来。</p>\n\n<p>给你一个整数 <code>n</code> 和两个整数数组 <code>left</code> 以及 <code>right</code> 。两个数组分别标识向左或者向右移动的蚂蚁在 <code>t = 0</code> 时的位置。请你返回最后一只蚂蚁从木板上掉下来的时刻。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/06/17/ants.jpg\" style=\"height: 610px; width: 450px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 4, left = [4,3], right = [0,1]\n<strong>输出：</strong>4\n<strong>解释：</strong>如上图所示：\n-下标 0 处的蚂蚁命名为 A 并向右移动。\n-下标 1 处的蚂蚁命名为 B 并向右移动。\n-下标 3 处的蚂蚁命名为 C 并向左移动。\n-下标 4 处的蚂蚁命名为 D 并向左移动。\n请注意，蚂蚁在木板上的最后时刻是 t = 4 秒，之后蚂蚁立即从木板上掉下来。（也就是说在 t = 4.0000000001 时，木板上没有蚂蚁）。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/06/17/ants2.jpg\" style=\"height: 101px; width: 639px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 7, left = [], right = [0,1,2,3,4,5,6,7]\n<strong>输出：</strong>7\n<strong>解释：</strong>所有蚂蚁都向右移动，下标为 0 的蚂蚁需要 7 秒才能从木板上掉落。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/06/17/ants3.jpg\" style=\"height: 100px; width: 639px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 7, left = [0,1,2,3,4,5,6,7], right = []\n<strong>输出：</strong>7\n<strong>解释：</strong>所有蚂蚁都向左移动，下标为 7 的蚂蚁需要 7 秒才能从木板上掉落。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^4</code></li>\n\t<li><code>0 &lt;= left.length &lt;= n + 1</code></li>\n\t<li><code>0 &lt;= left[i] &lt;= n</code></li>\n\t<li><code>0 &lt;= right.length &lt;= n + 1</code></li>\n\t<li><code>0 &lt;= right[i] &lt;= n</code></li>\n\t<li><code>1 &lt;= left.length + right.length &lt;= n + 1</code></li>\n\t<li><code>left</code> 和 <code>right</code> 中的所有值都是唯一的，并且每个值 <strong>只能出现在二者之一</strong> 中。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1504.统计全 1 子矩形",
        "hardRate": "MEDIUM",
        "passRate": "62.48%",
        "problemsUrl": "https://leetcode.cn/problems/count-submatrices-with-all-ones/",
        "solutionsUrl": "https://leetcode.cn/problems/count-submatrices-with-all-ones/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的二进制矩阵&nbsp;<code>mat</code>&nbsp;，请你返回有多少个&nbsp;<strong>子矩形</strong>&nbsp;的元素全部都是 1 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/27/ones1-grid.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1,0,1],[1,1,0],[1,1,0]]\n<strong>输出：</strong>13\n<strong>解释：\n</strong>有 <strong>6</strong>&nbsp;个 1x1 的矩形。\n有 <strong>2</strong> 个 1x2 的矩形。\n有 <strong>3</strong> 个 2x1 的矩形。\n有 <strong>1</strong> 个 2x2 的矩形。\n有 <strong>1</strong> 个 3x1 的矩形。\n矩形数目总共 = 6 + 2 + 3 + 1 + 1 = <strong>13</strong>&nbsp;。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/27/ones2-grid.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[0,1,1,0],[0,1,1,1],[1,1,1,0]]\n<strong>输出：</strong>24\n<strong>解释：</strong>\n有 <strong>8</strong> 个 1x1 的子矩形。\n有 <strong>5</strong> 个 1x2 的子矩形。\n有 <strong>2</strong> 个 1x3 的子矩形。\n有 <strong>4</strong> 个 2x1 的子矩形。\n有 <strong>2</strong> 个 2x2 的子矩形。\n有 <strong>2</strong> 个 3x1 的子矩形。\n有 <strong>1</strong> 个 3x2 的子矩形。\n矩形数目总共 = 8 + 5 + 2 + 4 + 2 + 2 + 1 = <strong>24</strong><strong> 。</strong>\n\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 150</code></li>\n\t<li><code>mat[i][j]</code>&nbsp;仅包含&nbsp;<code>0</code>&nbsp;或&nbsp;<code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1505.最多 K 次交换相邻数位后得到的最小整数",
        "hardRate": "HARD",
        "passRate": "39.87%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>num</code> 和一个整数&nbsp;<code>k</code> 。其中，<code>num</code> 表示一个很大的整数，字符串中的每个字符依次对应整数上的各个 <strong>数位</strong> 。</p>\n\n<p>你可以交换这个整数相邻数位的数字 <strong>最多</strong>&nbsp;<code>k</code>&nbsp;次。</p>\n\n<p>请你返回你能得到的最小整数，并以字符串形式返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/06/17/q4_1.jpg\" style=\"height:40px; width:500px\" /></p>\n\n<pre>\n<strong>输入：</strong>num = &quot;4321&quot;, k = 4\n<strong>输出：</strong>&quot;1342&quot;\n<strong>解释：</strong>4321 通过 4 次交换相邻数位得到最小整数的步骤如上图所示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = &quot;100&quot;, k = 1\n<strong>输出：</strong>&quot;010&quot;\n<strong>解释：</strong>输出可以包含前导 0 ，但输入保证不会有前导 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = &quot;36789&quot;, k = 1000\n<strong>输出：</strong>&quot;36789&quot;\n<strong>解释：</strong>不需要做任何交换。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = &quot;22&quot;, k = 22\n<strong>输出：</strong>&quot;22&quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = &quot;9438957234785635408&quot;, k = 23\n<strong>输出：</strong>&quot;0345989723478563548&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 30000</code></li>\n\t<li><code>num</code>&nbsp;只包含&nbsp;<strong>数字</strong>&nbsp;且不含有<strong>&nbsp;前导 0&nbsp;</strong>。</li>\n\t<li><code>1 &lt;= k &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1506.找到 N 叉树的根节点",
        "hardRate": "MEDIUM",
        "passRate": "81.32%",
        "problemsUrl": "https://leetcode.cn/problems/find-root-of-n-ary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/find-root-of-n-ary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1507.转变日期格式",
        "hardRate": "EASY",
        "passRate": "58.95%",
        "problemsUrl": "https://leetcode.cn/problems/reformat-date/",
        "solutionsUrl": "https://leetcode.cn/problems/reformat-date/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>date</code>&nbsp;，它的格式为&nbsp;<code>Day Month Year</code>&nbsp;，其中：</p>\n\n<ul>\n\t<li><code>Day</code>&nbsp;是集合&nbsp;<code>{&quot;1st&quot;, &quot;2nd&quot;, &quot;3rd&quot;, &quot;4th&quot;, ..., &quot;30th&quot;, &quot;31st&quot;}</code>&nbsp;中的一个元素。</li>\n\t<li><code>Month</code>&nbsp;是集合&nbsp;<code>{&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;}</code>&nbsp;中的一个元素。</li>\n\t<li><code>Year</code>&nbsp;的范围在 ​<code>[1900, 2100]</code>&nbsp;之间。</li>\n</ul>\n\n<p>请你将字符串转变为&nbsp;<code>YYYY-MM-DD</code>&nbsp;的格式，其中：</p>\n\n<ul>\n\t<li><code>YYYY</code>&nbsp;表示 4 位的年份。</li>\n\t<li><code>MM</code>&nbsp;表示 2 位的月份。</li>\n\t<li><code>DD</code>&nbsp;表示 2 位的天数。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>date = &quot;20th Oct 2052&quot;\n<strong>输出：</strong>&quot;2052-10-20&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>date = &quot;6th Jun 1933&quot;\n<strong>输出：</strong>&quot;1933-06-06&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>date = &quot;26th May 1960&quot;\n<strong>输出：</strong>&quot;1960-05-26&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给定日期保证是合法的，所以不需要处理异常输入。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1508.子数组和排序后的区间和",
        "hardRate": "MEDIUM",
        "passRate": "57.70%",
        "problemsUrl": "https://leetcode.cn/problems/range-sum-of-sorted-subarray-sums/",
        "solutionsUrl": "https://leetcode.cn/problems/range-sum-of-sorted-subarray-sums/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>nums</code>&nbsp;，它包含&nbsp;<code>n</code>&nbsp;个正整数。你需要计算所有非空连续子数组的和，并将它们按升序排序，得到一个新的包含&nbsp;<code>n * (n + 1) / 2</code>&nbsp;个数字的数组。</p>\n\n<p>请你返回在新数组中下标为<em>&nbsp;</em><code>left</code>&nbsp;到&nbsp;<code>right</code> <strong>（下标从 1 开始）</strong>的所有数字和（包括左右端点）。由于答案可能很大，请你将它对 10^9 + 7 取模后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4], n = 4, left = 1, right = 5\n<strong>输出：</strong>13 \n<strong>解释：</strong>所有的子数组和为 1, 3, 6, 10, 2, 5, 9, 3, 7, 4 。将它们升序排序后，我们得到新的数组 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。下标从 le = 1 到 ri = 5 的和为 1 + 2 + 3 + 3 + 4 = 13 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4], n = 4, left = 3, right = 4\n<strong>输出：</strong>6\n<strong>解释：</strong>给定数组与示例 1 一样，所以新数组为 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。下标从 le = 3 到 ri = 4 的和为 3 + 3 = 6 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4], n = 4, left = 1, right = 10\n<strong>输出：</strong>50\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^3</code></li>\n\t<li><code>nums.length == n</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= left &lt;= right&nbsp;&lt;= n * (n + 1) / 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1509.三次操作后最大值与最小值的最小差",
        "hardRate": "MEDIUM",
        "passRate": "55.46%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>每次操作你可以选择&nbsp;<code>nums</code>&nbsp;中的任意一个元素并将它改成 <strong>任意值</strong> 。</p>\n\n<p>在&nbsp;<strong>执行最多三次移动后&nbsp;</strong>，返回&nbsp;<code>nums</code>&nbsp;中最大值与最小值的最小差值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,3,2,4]\n<strong>输出：</strong>0\n<strong>解释：</strong>我们最多可以走 3 步。\n第一步，将 2 变为 3 。 nums 变成 [5,3,3,4] 。\n第二步，将 4 改为 3 。 nums 变成 [5,3,3,3] 。\n第三步，将 5 改为 3 。 nums 变成 [3,3,3,3] 。\n执行 3 次移动后，最小值和最大值之间的差值为 3 - 3 = 0 。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5,0,10,14]\n<strong>输出：</strong>1\n<strong>解释：</strong>我们最多可以走 3 步。\n第一步，将 5 改为 0 。 nums变成 [1,0,0,10,14] 。\n第二步，将 10 改为 0 。 nums变成 [1,0,0,0,14] 。\n第三步，将 14 改为 1 。 nums变成 [1,0,0,0,1] 。\n执行 3 步后，最小值和最大值之间的差值为 1 - 0 = 1 。\n可以看出，没有办法可以在 3 步内使差值变为0。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,100,20]\n<strong>输出：</strong>0\n<strong>解释：</strong>我们最多可以走 3 步。\n第一步，将 100 改为 7 。 nums 变成 [3,7,20] 。\n第二步，将 20 改为 7 。 nums 变成 [3,7,7] 。\n第三步，将 3 改为 7 。 nums 变成 [7,7,7] 。\n执行 3 步后，最小值和最大值之间的差值是 7 - 7 = 0。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1510.石子游戏 IV",
        "hardRate": "HARD",
        "passRate": "60.19%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game-iv/solution",
        "problemsDesc": "<p>Alice 和 Bob 两个人轮流玩一个游戏，Alice 先手。</p>\n\n<p>一开始，有 <code>n</code>&nbsp;个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 <strong>任意</strong>&nbsp;非零 <strong>平方数</strong>&nbsp;个石子。</p>\n\n<p>如果石子堆里没有石子了，则无法操作的玩家输掉游戏。</p>\n\n<p>给你正整数&nbsp;<code>n</code>&nbsp;，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回&nbsp;<code>True</code>&nbsp;，否则返回&nbsp;<code>False</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>true\n<strong>解释：</strong>Alice 拿走 1 个石子并赢得胜利，因为 Bob 无法进行任何操作。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>false\n<strong>解释：</strong>Alice 只能拿走 1 个石子，然后 Bob 拿走最后一个石子并赢得胜利（2 -&gt; 1 -&gt; 0）。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>true\n<strong>解释：</strong>n 已经是一个平方数，Alice 可以一次全拿掉 4 个石子并赢得胜利（4 -&gt; 0）。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 7\n<strong>输出：</strong>false\n<strong>解释：</strong>当 Bob 采取最优策略时，Alice 无法赢得比赛。\n如果 Alice 一开始拿走 4 个石子， Bob 会拿走 1 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 0）。\n如果 Alice 一开始拿走 1 个石子， Bob 会拿走 4 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -&gt; 6 -&gt; 2 -&gt; 1 -&gt; 0）。</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 17\n<strong>输出：</strong>false\n<strong>解释：</strong>如果 Bob 采取最优策略，Alice 无法赢得胜利。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1511.消费者下单频率",
        "hardRate": "EASY",
        "passRate": "68.74%",
        "problemsUrl": "https://leetcode.cn/problems/customer-order-frequency/",
        "solutionsUrl": "https://leetcode.cn/problems/customer-order-frequency/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1512.好数对的数目",
        "hardRate": "EASY",
        "passRate": "84.37%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-good-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-good-pairs/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。</p>\n\n<p>如果一组数字 <code>(i,j)</code> 满足 <code>nums[i]</code> == <code>nums[j]</code> 且 <code>i</code> &lt; <code>j</code> ，就可以认为这是一组 <strong>好数对</strong> 。</p>\n\n<p>返回好数对的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,1,1,3]\n<strong>输出：</strong>4\n<strong>解释：</strong>有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,1,1]\n<strong>输出：</strong>6\n<strong>解释：</strong>数组中的每组数字都是好数对</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1513.仅含 1 的子串数",
        "hardRate": "MEDIUM",
        "passRate": "39.56%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-substrings-with-only-1s/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-substrings-with-only-1s/solution",
        "problemsDesc": "<p>给你一个二进制字符串 <code>s</code>（仅由 &#39;0&#39; 和 &#39;1&#39; 组成的字符串）。</p>\n\n<p>返回所有字符都为 1 的子字符串的数目。</p>\n\n<p>由于答案可能很大，请你将它对 10^9 + 7 取模后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;0110111&quot;\n<strong>输出</strong>：9\n<strong>解释：</strong>共有 9 个子字符串仅由 &#39;1&#39; 组成\n&quot;1&quot; -&gt; 5 次\n&quot;11&quot; -&gt; 3 次\n&quot;111&quot; -&gt; 1 次</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;101&quot;\n<strong>输出：</strong>2\n<strong>解释：</strong>子字符串 &quot;1&quot; 在 s 中共出现 2 次\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;111111&quot;\n<strong>输出：</strong>21\n<strong>解释：</strong>每个子字符串都仅由 &#39;1&#39; 组成\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;000&quot;\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s[i] == &#39;0&#39;</code> 或 <code>s[i] == &#39;1&#39;</code></li>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1514.概率最大的路径",
        "hardRate": "MEDIUM",
        "passRate": "40.76%",
        "problemsUrl": "https://leetcode.cn/problems/path-with-maximum-probability/",
        "solutionsUrl": "https://leetcode.cn/problems/path-with-maximum-probability/solution",
        "problemsDesc": "<p>给你一个由 <code>n</code> 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 <code>edges[i] = [a, b]</code> 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 <code>succProb[i]</code> 。</p>\n\n<p>指定两个节点分别作为起点 <code>start</code> 和终点 <code>end</code> ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。</p>\n\n<p>如果不存在从 <code>start</code> 到 <code>end</code> 的路径，请 <strong>返回 0</strong> 。只要答案与标准答案的误差不超过 <strong>1e-5 </strong>，就会被视作正确答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex1.png\" style=\"height: 186px; width: 187px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2\n<strong>输出：</strong>0.25000\n<strong>解释：</strong>从起点到终点有两条路径，其中一条的成功概率为 0.2 ，而另一条为 0.5 * 0.5 = 0.25\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex2.png\" style=\"height: 186px; width: 189px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2\n<strong>输出：</strong>0.30000\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex3.png\" style=\"height: 191px; width: 215px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2\n<strong>输出：</strong>0.00000\n<strong>解释：</strong>节点 0 和 节点 2 之间不存在路径\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10^4</code></li>\n\t<li><code>0 &lt;= start, end &lt; n</code></li>\n\t<li><code>start != end</code></li>\n\t<li><code>0 &lt;= a, b &lt; n</code></li>\n\t<li><code>a != b</code></li>\n\t<li><code>0 &lt;= succProb.length == edges.length &lt;= 2*10^4</code></li>\n\t<li><code>0 &lt;= succProb[i] &lt;= 1</code></li>\n\t<li>每两个节点之间最多有一条边</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1515.服务中心的最佳位置",
        "hardRate": "HARD",
        "passRate": "35.27%",
        "problemsUrl": "https://leetcode.cn/problems/best-position-for-a-service-centre/",
        "solutionsUrl": "https://leetcode.cn/problems/best-position-for-a-service-centre/solution",
        "problemsDesc": "<p>一家快递公司希望在新城市建立新的服务中心。公司统计了该城市所有客户在二维地图上的坐标，并希望能够以此为依据为新的服务中心选址：使服务中心 <strong>到所有客户的欧几里得距离的总和最小</strong> 。</p>\n\n<p>给你一个数组 <code>positions</code> ，其中 <code>positions[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示第 <code>i</code> 个客户在二维地图上的位置，返回到所有客户的 <strong>欧几里得距离的最小总和 。</strong></p>\n\n<p>换句话说，请你为服务中心选址，该位置的坐标 <code>[x<sub>centre</sub>, y<sub>centre</sub>]</code> 需要使下面的公式取到最小值：</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/q4_edited.jpg\" /></p>\n\n<p>与真实值误差在 <code>10<sup>-5</sup></code>之内的答案将被视作正确答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/q4_e1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>positions = [[0,1],[1,0],[1,2],[2,1]]\n<strong>输出：</strong>4.00000\n<strong>解释：</strong>如图所示，你可以选 [x<sub>centre</sub>, y<sub>centre</sub>] = [1, 1] 作为新中心的位置，这样一来到每个客户的距离就都是 1，所有距离之和为 4 ，这也是可以找到的最小值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/q4_e3.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>positions = [[1,1],[3,3]]\n<strong>输出：</strong>2.82843\n<strong>解释：</strong>欧几里得距离可能的最小总和为 sqrt(2) + sqrt(2) = 2.82843\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= positions.length &lt;= 50</code></li>\n\t<li><code>positions[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1516.移动 N 叉树的子树",
        "hardRate": "HARD",
        "passRate": "55.87%",
        "problemsUrl": "https://leetcode.cn/problems/move-sub-tree-of-n-ary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/move-sub-tree-of-n-ary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1517.查找拥有有效邮箱的用户",
        "hardRate": "EASY",
        "passRate": "50.48%",
        "problemsUrl": "https://leetcode.cn/problems/find-users-with-valid-e-mails/",
        "solutionsUrl": "https://leetcode.cn/problems/find-users-with-valid-e-mails/solution",
        "problemsDesc": "<p>用户表：&nbsp;Users</p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| user_id       | int     |\n| name          | varchar |\n| mail          | varchar | \n+---------------+---------+\nuser_id （用户 ID）是该表的主键。\n这个表包含用户在某网站上注册的信息。有些邮箱是无效的。</pre>\n\n<p>&nbsp;</p>\n\n<p>写一条&nbsp;SQL 语句，查询拥有<strong>有效邮箱</strong>的用户。</p>\n\n<p>有效的邮箱包含符合下列条件的前缀名和域名：</p>\n\n<ul>\n\t<li><strong>前缀名</strong>是包含字母（大写或小写）、数字、下划线&nbsp;<code>&#39;_&#39;</code>、句点&nbsp;<code>&#39;.&#39;</code>&nbsp;和/或横杠&nbsp;<code>&#39;-&#39;</code>&nbsp;的字符串。前缀名<strong>必须</strong>以字母开头。</li>\n\t<li><strong>域名</strong>是&nbsp;<code>&#39;@leetcode.com&#39;</code>&nbsp;。</li>\n</ul>\n\n<p>按任意顺序返回结果表。</p>\n\n<p>&nbsp;</p>\n\n<p>查询格式如下所示：</p>\n\n<pre>\n<code>Users</code>\n+---------+-----------+-------------------------+\n| user_id | name      | mail                    |\n+---------+-----------+-------------------------+\n| 1       | Winston   | winston@leetcode.com    |\n| 2       | Jonathan  | jonathanisgreat         |\n| 3       | Annabelle | bella-@leetcode.com     |\n| 4       | Sally     | sally.come@leetcode.com |\n| 5       | Marwan    | quarz#2020@leetcode.com |\n| 6       | David     | david69@gmail.com       |\n| 7       | Shapiro   | .shapo@leetcode.com     |\n+---------+-----------+-------------------------+\n\n结果表：\n+---------+-----------+-------------------------+\n| user_id | name      | mail                    |\n+---------+-----------+-------------------------+\n| 1       | Winston   | winston@leetcode.com    |\n| 3       | Annabelle | bella-@leetcode.com     |\n| 4       | Sally     | sally.come@leetcode.com |\n+---------+-----------+-------------------------+\n2 号用户的邮箱没有域名。\n5 号用户的邮箱包含非法字符 #。\n6 号用户的邮箱的域名不是 leetcode。\n7 号用户的邮箱以句点（.）开头。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1518.换水问题",
        "hardRate": "EASY",
        "passRate": "69.57%",
        "problemsUrl": "https://leetcode.cn/problems/water-bottles/",
        "solutionsUrl": "https://leetcode.cn/problems/water-bottles/solution",
        "problemsDesc": "<p>超市正在促销，你可以用 <code>numExchange</code> 个空水瓶从超市兑换一瓶水。最开始，你一共购入了 <code>numBottles</code> 瓶水。</p>\n\n<p>如果喝掉了水瓶中的水，那么水瓶就会变成空的。</p>\n\n<p>给你两个整数 <code>numBottles</code> 和 <code>numExchange</code> ，返回你 <strong>最多</strong> 可以喝到多少瓶水。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/19/sample_1_1875.png\" style=\"height: 240px; width: 480px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>numBottles = 9, numExchange = 3\n<strong>输出：</strong>13\n<strong>解释：</strong>你可以用 <code>3</code> 个空瓶兑换 1 瓶水。\n所以最多能喝到 9 + 3 + 1 = 13 瓶水。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/19/sample_2_1875.png\" style=\"height: 240px; width: 790px;\" /></p>\n\n<pre>\n<strong>输入：</strong>numBottles = 15, numExchange = 4\n<strong>输出：</strong>19\n<strong>解释：</strong>你可以用 <code>4</code> 个空瓶兑换 1 瓶水。\n所以最多能喝到 15 + 3 + 1 = 19 瓶水。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numBottles &lt;= 100</code></li>\n\t<li><code>2 &lt;= numExchange &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1519.子树中标签相同的节点数",
        "hardRate": "MEDIUM",
        "passRate": "33.26%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/solution",
        "problemsDesc": "<p>给你一棵树（即，一个连通的无环无向图），这棵树由编号从 <code>0</code>&nbsp; 到 <code>n - 1</code> 的 n 个节点组成，且恰好有 <code>n - 1</code> 条 <code>edges</code> 。树的根节点为节点 <code>0</code> ，树上的每一个节点都有一个标签，也就是字符串 <code>labels</code> 中的一个小写字符（编号为 <code>i</code> 的 节点的标签就是 <code>labels[i]</code> ）</p>\n\n<p>边数组 <code>edges</code> 以 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 的形式给出，该格式表示节点 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间存在一条边。</p>\n\n<p>返回一个大小为 <em><code>n</code></em> 的数组，其中 <code>ans[i]</code> 表示第 <code>i</code> 个节点的子树中与节点 <code>i</code> 标签相同的节点数。</p>\n\n<p>树 <code>T</code> 中的子树是由 <code>T</code> 中的某个节点及其所有后代节点组成的树。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/19/q3e1.jpg\" style=\"height: 321px; width: 441px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = \"abaedcd\"\n<strong>输出：</strong>[2,1,1,1,1,1,1]\n<strong>解释：</strong>节点 0 的标签为 'a' ，以 'a' 为根节点的子树中，节点 2 的标签也是 'a' ，因此答案为 2 。注意树中的每个节点都是这棵子树的一部分。\n节点 1 的标签为 'b' ，节点 1 的子树包含节点 1、4 和 5，但是节点 4、5 的标签与节点 1 不同，故而答案为 1（即，该节点本身）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/19/q3e2.jpg\" style=\"height: 321px; width: 381px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 4, edges = [[0,1],[1,2],[0,3]], labels = \"bbbb\"\n<strong>输出：</strong>[4,2,1,1]\n<strong>解释：</strong>节点 2 的子树中只有节点 2 ，所以答案为 1 。\n节点 3 的子树中只有节点 3 ，所以答案为 1 。\n节点 1 的子树中包含节点 1 和 2 ，标签都是 'b' ，因此答案为 2 。\n节点 0 的子树中包含节点 0、1、2 和 3，标签都是 'b'，因此答案为 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/19/q3e3.jpg\" style=\"height: 321px; width: 381px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = \"aabab\"\n<strong>输出：</strong>[3,2,1,1,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>,&nbsp;b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> !=&nbsp;b<sub>i</sub></code></li>\n\t<li><code>labels.length == n</code></li>\n\t<li><code>labels</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1520.最多的不重叠子字符串",
        "hardRate": "HARD",
        "passRate": "35.70%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-non-overlapping-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-non-overlapping-substrings/solution",
        "problemsDesc": "<p>给你一个只包含小写字母的字符串&nbsp;<code>s</code>&nbsp;，你需要找到 <code>s</code>&nbsp;中最多数目的非空子字符串，满足如下条件：</p>\n\n<ol>\n\t<li>这些字符串之间互不重叠，也就是说对于任意两个子字符串&nbsp;<code>s[i..j]</code> 和&nbsp;<code>s[x..y]</code>&nbsp;，要么&nbsp;<code>j &lt; x</code>&nbsp;要么&nbsp;<code>i &gt; y</code>&nbsp;。</li>\n\t<li>如果一个子字符串包含字符&nbsp;<code>char</code> ，那么&nbsp;<code>s</code>&nbsp;中所有&nbsp;<code>char</code> 字符都应该在这个子字符串中。</li>\n</ol>\n\n<p>请你找到满足上述条件的最多子字符串数目。如果有多个解法有相同的子字符串数目，请返回这些子字符串总长度最小的一个解。可以证明最小总长度解是唯一的。</p>\n\n<p>请注意，你可以以 <strong>任意</strong>&nbsp;顺序返回最优解的子字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"adefaddaccc\"\n<strong>输出：</strong>[\"e\",\"f\",\"ccc\"]\n<strong>解释：</strong>下面为所有满足第二个条件的子字符串：\n[\n&nbsp; \"adefaddaccc\"\n&nbsp; \"adefadda\",\n&nbsp; \"ef\",\n&nbsp; \"e\",\n  \"f\",\n&nbsp; \"ccc\",\n]\n如果我们选择第一个字符串，那么我们无法再选择其他任何字符串，所以答案为 1 。如果我们选择 \"adefadda\" ，剩下子字符串中我们只可以选择 \"ccc\" ，它是唯一不重叠的子字符串，所以答案为 2 。同时我们可以发现，选择 \"ef\" 不是最优的，因为它可以被拆分成 2 个子字符串。所以最优解是选择 [\"e\",\"f\",\"ccc\"] ，答案为 3 。不存在别的相同数目子字符串解。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abbaccd\"\n<strong>输出：</strong>[\"d\",\"bb\",\"cc\"]\n<strong>解释：</strong>注意到解 [\"d\",\"abba\",\"cc\"] 答案也为 3 ，但它不是最优解，因为它的总长度更长。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1521.找到最接近目标值的函数值",
        "hardRate": "HARD",
        "passRate": "43.70%",
        "problemsUrl": "https://leetcode.cn/problems/find-a-value-of-a-mysterious-function-closest-to-target/",
        "solutionsUrl": "https://leetcode.cn/problems/find-a-value-of-a-mysterious-function-closest-to-target/solution",
        "problemsDesc": "<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/19/change.png\" style=\"height: 312px; width: 635px;\"></p>\n\n<p>Winston 构造了一个如上所示的函数&nbsp;<code>func</code>&nbsp;。他有一个整数数组&nbsp;<code>arr</code>&nbsp;和一个整数&nbsp;<code>target</code>&nbsp;，他想找到让&nbsp;<code>|func(arr, l, r) - target|</code>&nbsp;最小的 <code>l</code>&nbsp;和 <code>r</code>&nbsp;。</p>\n\n<p>请你返回&nbsp;<code>|func(arr, l, r) - target|</code>&nbsp;的最小值。</p>\n\n<p>请注意，&nbsp;<code>func</code> 的输入参数&nbsp;<code>l</code> 和&nbsp;<code>r</code>&nbsp;需要满足&nbsp;<code>0 &lt;= l, r &lt; arr.length</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [9,12,3,7,15], target = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>所有可能的 [l,r] 数对包括 [[0,0],[1,1],[2,2],[3,3],[4,4],[0,1],[1,2],[2,3],[3,4],[0,2],[1,3],[2,4],[0,3],[1,4],[0,4]]， Winston 得到的相应结果为 [9,12,3,7,15,8,0,3,7,0,0,3,0,0,0] 。最接近 5 的值是 7 和 3，所以最小差值为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1000000,1000000,1000000], target = 1\n<strong>输出：</strong>999999\n<strong>解释：</strong>Winston 输入函数的所有可能 [l,r] 数对得到的函数值都为 1000000 ，所以最小差值为 999999 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,4,8,16], target = 0\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10^6</code></li>\n\t<li><code>0 &lt;= target &lt;= 10^7</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1522.N 叉树的直径",
        "hardRate": "MEDIUM",
        "passRate": "71.48%",
        "problemsUrl": "https://leetcode.cn/problems/diameter-of-n-ary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/diameter-of-n-ary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1523.在区间范围内统计奇数数目",
        "hardRate": "EASY",
        "passRate": "49.24%",
        "problemsUrl": "https://leetcode.cn/problems/count-odd-numbers-in-an-interval-range/",
        "solutionsUrl": "https://leetcode.cn/problems/count-odd-numbers-in-an-interval-range/solution",
        "problemsDesc": "<p>给你两个非负整数&nbsp;<code>low</code> 和&nbsp;<code>high</code>&nbsp;。请你返回<em>&nbsp;</em><code>low</code><em> </em>和<em>&nbsp;</em><code>high</code><em>&nbsp;</em>之间（包括二者）奇数的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>low = 3, high = 7\n<strong>输出：</strong>3\n<strong>解释：</strong>3 到 7 之间奇数数字为 [3,5,7] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>low = 8, high = 10\n<strong>输出：</strong>1\n<strong>解释：</strong>8 到 10 之间奇数数字为 [9] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= low &lt;= high&nbsp;&lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1524.和为奇数的子数组数目",
        "hardRate": "MEDIUM",
        "passRate": "45.74%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-sub-arrays-with-odd-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-sub-arrays-with-odd-sum/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code>&nbsp;。请你返回和为 <strong>奇数</strong>&nbsp;的子数组数目。</p>\n\n<p>由于答案可能会很大，请你将结果对&nbsp;<code>10^9 + 7</code>&nbsp;取余后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,3,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>所有的子数组为 [[1],[1,3],[1,3,5],[3],[3,5],[5]] 。\n所有子数组的和为 [1,4,9,3,8,5].\n奇数和包括 [1,9,3,5] ，所以答案为 4 。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,4,6]\n<strong>输出：</strong>0\n<strong>解释：</strong>所有子数组为 [[2],[2,4],[2,4,6],[4],[4,6],[6]] 。\n所有子数组和为 [2,6,12,4,10,6] 。\n所有子数组和都是偶数，所以答案为 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,3,4,5,6,7]\n<strong>输出：</strong>16\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [100,100,99,99]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [7]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1525.字符串的好分割数目",
        "hardRate": "MEDIUM",
        "passRate": "66.05%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-good-ways-to-split-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-good-ways-to-split-a-string/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，一个分割被称为 「好分割」&nbsp;当它满足：将&nbsp;<code>s</code>&nbsp;分割成 2 个字符串&nbsp;<code>p</code> 和&nbsp;<code>q</code>&nbsp;，它们连接起来等于&nbsp;<code>s</code>&nbsp;且 <code>p</code>&nbsp;和 <code>q</code>&nbsp;中不同字符的数目相同。</p>\n\n<p>请你返回 <code>s</code>&nbsp;中好分割的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aacaba&quot;\n<strong>输出：</strong>2\n<strong>解释：</strong>总共有 5 种分割字符串 <code>&quot;aacaba&quot;</code> 的方法，其中 2 种是好分割。\n(&quot;a&quot;, &quot;acaba&quot;) 左边字符串和右边字符串分别包含 1 个和 3 个不同的字符。\n(&quot;aa&quot;, &quot;caba&quot;) 左边字符串和右边字符串分别包含 1 个和 3 个不同的字符。\n(&quot;aac&quot;, &quot;aba&quot;) 左边字符串和右边字符串分别包含 2 个和 2 个不同的字符。这是一个好分割。\n(&quot;aaca&quot;, &quot;ba&quot;) 左边字符串和右边字符串分别包含 2 个和 2 个不同的字符。这是一个好分割。\n(&quot;aacab&quot;, &quot;a&quot;) 左边字符串和右边字符串分别包含 3 个和 1 个不同的字符。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abcd&quot;\n<strong>输出：</strong>1\n<strong>解释：</strong>好分割为将字符串分割成 (&quot;ab&quot;, &quot;cd&quot;) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aaaaa&quot;\n<strong>输出：</strong>4\n<strong>解释：</strong>所有分割都是好分割。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;acbadbaada&quot;\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1526.形成目标数组的子数组最少增加次数",
        "hardRate": "HARD",
        "passRate": "64.96%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>target</code>&nbsp;和一个数组&nbsp;<code>initial</code>&nbsp;，<code>initial</code>&nbsp;数组与 <code>target</code>&nbsp; 数组有同样的维度，且一开始全部为 0 。</p>\n\n<p>请你返回从 <code>initial</code>&nbsp;得到&nbsp; <code>target</code>&nbsp;的最少操作次数，每次操作需遵循以下规则：</p>\n\n<ul>\n\t<li>在 <code>initial</code>&nbsp;中选择 <strong>任意</strong>&nbsp;子数组，并将子数组中每个元素增加 1 。</li>\n</ul>\n\n<p>答案保证在 32 位有符号整数以内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>target = [1,2,3,2,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>我们需要至少 3 次操作从 intial 数组得到 target 数组。\n[0,0,0,0,0] 将下标为 0 到 4&nbsp;的元素（包含二者）加 1 。\n[1,1,1,1,1] 将下标为 1 到 3 的元素（包含二者）加 1 。\n[1,2,2,2,1] 将下表为 2 的元素增加 1 。\n[1,2,3,2,1] 得到了目标数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>target = [3,1,1,2]\n<strong>输出：</strong>4\n<strong>解释：</strong>(initial)[0,0,0,0] -&gt; [1,1,1,1] -&gt; [1,1,1,2] -&gt; [2,1,1,2] -&gt; [3,1,1,2] (target) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>target = [3,1,5,4,2]\n<strong>输出：</strong>7\n<strong>解释：</strong>(initial)[0,0,0,0,0] -&gt; [1,1,1,1,1] -&gt; [2,1,1,1,1] -&gt; [3,1,1,1,1] \n                                  -&gt; [3,1,2,2,2] -&gt; [3,1,3,3,2] -&gt; [3,1,4,4,2] -&gt; [3,1,5,4,2] (target)。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>target = [1,1,1,1]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= target[i] &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1527.患某种疾病的患者",
        "hardRate": "EASY",
        "passRate": "46.68%",
        "problemsUrl": "https://leetcode.cn/problems/patients-with-a-condition/",
        "solutionsUrl": "https://leetcode.cn/problems/patients-with-a-condition/solution",
        "problemsDesc": "<p>患者信息表：&nbsp;<code>Patients</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| patient_id   | int     |\n| patient_name | varchar |\n| conditions   | varchar |\n+--------------+---------+\npatient_id （患者 ID）是该表的主键。\n'conditions' （疾病）包含 0 个或以上的疾病代码，以空格分隔。\n这个表包含医院中患者的信息。</pre>\n\n<p>&nbsp;</p>\n\n<p>写一条&nbsp;SQL 语句，查询患有 I 类糖尿病的患者&nbsp;ID （patient_id）、患者姓名（patient_name）以及其患有的所有疾病代码（conditions）。I 类糖尿病的代码总是包含前缀&nbsp;<code>DIAB1</code>&nbsp;。</p>\n\n<p>按 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式如下示例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<code><strong>输入：\n</strong>Patients表：</code>\n+------------+--------------+--------------+\n| patient_id | patient_name | conditions   |\n+------------+--------------+--------------+\n| 1          | Daniel      &nbsp;| YFEV COUGH   |\n| 2    &nbsp;     | Alice        |            &nbsp; |\n| 3    &nbsp;     | Bob         &nbsp;| DIAB100 MYOP&nbsp;|\n| 4 &nbsp;        | George      &nbsp;| ACNE DIAB100&nbsp;|\n| 5 &nbsp;        | Alain       &nbsp;| DIAB201     &nbsp;|\n+------------+--------------+--------------+\n<strong>输出：</strong>\n+------------+--------------+--------------+\n| patient_id | patient_name | conditions   |\n+------------+--------------+--------------+\n| 3    &nbsp;     | Bob         &nbsp;| DIAB100 MYOP&nbsp;|\n| 4 &nbsp;        | George   &nbsp;   | ACNE DIAB100&nbsp;| \n+------------+--------------+--------------+\n<strong>解释：</strong>Bob 和 George 都患有代码以 DIAB1 开头的疾病。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1528.重新排列字符串",
        "hardRate": "EASY",
        "passRate": "78.46%",
        "problemsUrl": "https://leetcode.cn/problems/shuffle-string/",
        "solutionsUrl": "https://leetcode.cn/problems/shuffle-string/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和一个 <strong>长度相同</strong> 的整数数组 <code>indices</code> 。</p>\n\n<p>请你重新排列字符串 <code>s</code> ，其中第 <code>i</code> 个字符需要移动到 <code>indices[i]</code> 指示的位置。</p>\n\n<p>返回重新排列后的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/26/q1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>s = \"codeleet\", <code>indices</code> = [4,5,6,7,0,2,1,3]\n<strong>输出：</strong>\"leetcode\"\n<strong>解释：</strong>如图所示，\"codeleet\" 重新排列后变为 \"leetcode\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\", <code>indices</code> = [0,1,2]\n<strong>输出：</strong>\"abc\"\n<strong>解释：</strong>重新排列后，每个字符都还留在原来的位置上。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s.length == indices.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>s</code> 仅包含小写英文字母</li>\n\t<li><code>0 &lt;= indices[i] &lt;&nbsp;n</code></li>\n\t<li><code>indices</code> 的所有的值都是 <strong>唯一</strong> 的</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1529.最少的后缀翻转次数",
        "hardRate": "MEDIUM",
        "passRate": "70.32%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-suffix-flips/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-suffix-flips/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 、下标从 <strong>0</strong> 开始的二进制字符串 <code>target</code> 。你自己有另一个长度为 <code>n</code> 的二进制字符串 <code>s</code> ，最初每一位上都是 0 。你想要让 <code>s</code> 和 <code>target</code> 相等。</p>\n\n<p>在一步操作，你可以选择下标 <code>i</code>（<code>0 &lt;= i &lt; n</code>）并翻转在 <strong>闭区间</strong> <code>[i, n - 1]</code> 内的所有位。翻转意味着 <code>'0'</code> 变为 <code>'1'</code> ，而 <code>'1'</code> 变为 <code>'0'</code> 。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>返回使<em> </em><code>s</code><em> </em>与<em> </em><code>target</code> 相等需要的最少翻转次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = \"10111\"\n<strong>输出：</strong>3\n<strong>解释：</strong>最初，s = \"00000\" 。\n选择下标 i = 2: \"00<em><strong>000</strong></em>\" -&gt; \"00<em><strong>111</strong></em>\"\n选择下标 i = 0: \"<em><strong>00111</strong></em>\" -&gt; \"<em><strong>11000</strong></em>\"\n选择下标 i = 1: \"1<em><strong>1000</strong></em>\" -&gt; \"1<em><strong>0111</strong></em>\"\n要达成目标，需要至少 3 次翻转。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = \"101\"\n<strong>输出：</strong>3\n<strong>解释：</strong>最初，s = \"000\" 。\n选择下标 i = 0: \"<em><strong>000</strong></em>\" -&gt; \"<em><strong>111</strong></em>\"\n选择下标 i = 1: \"1<em><strong>11</strong></em>\" -&gt; \"1<em><strong>00</strong></em>\"\n选择下标 i = 2: \"10<em><strong>0</strong></em>\" -&gt; \"10<em><strong>1</strong></em>\"\n要达成目标，需要至少 3 次翻转。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = \"00000\"\n<strong>输出：</strong>0\n<strong>解释：</strong>由于 s 已经等于目标，所以不需要任何操作\n</pre>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == target.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>target[i]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1530.好叶子节点对的数量",
        "hardRate": "MEDIUM",
        "passRate": "58.50%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-good-leaf-nodes-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-good-leaf-nodes-pairs/solution",
        "problemsDesc": "<p>给你二叉树的根节点 <code>root</code> 和一个整数 <code>distance</code> 。</p>\n\n<p>如果二叉树中两个 <strong>叶</strong> 节点之间的 <strong>最短路径长度</strong> 小于或者等于 <code>distance</code> ，那它们就可以构成一组 <strong>好叶子节点对</strong> 。</p>\n\n<p>返回树中 <strong>好叶子节点对的数量</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/26/e1.jpg\" style=\"height: 321px; width: 321px;\"></p>\n\n<pre><strong>输入：</strong>root = [1,2,3,null,4], distance = 3\n<strong>输出：</strong>1\n<strong>解释：</strong>树的叶节点是 3 和 4 ，它们之间的最短路径的长度是 3 。这是唯一的好叶子节点对。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/26/e2.jpg\" style=\"height: 321px; width: 441px;\"></p>\n\n<pre><strong>输入：</strong>root = [1,2,3,4,5,6,7], distance = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>好叶子节点对为 [4,5] 和 [6,7] ，最短路径长度都是 2 。但是叶子节点对 [4,6] 不满足要求，因为它们之间的最短路径长度为 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3\n<strong>输出：</strong>1\n<strong>解释：</strong>唯一的好叶子节点对是 [2,5] 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>root = [100], distance = 1\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>root = [1,1,1], distance = 2\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>tree</code> 的节点数在 <code>[1, 2^10]</code> 范围内。</li>\n\t<li>每个节点的值都在 <code>[1, 100]</code> 之间。</li>\n\t<li><code>1 &lt;= distance &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1531.压缩字符串 II",
        "hardRate": "HARD",
        "passRate": "38.09%",
        "problemsUrl": "https://leetcode.cn/problems/string-compression-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/string-compression-ii/solution",
        "problemsDesc": "<p><a href=\"https://baike.baidu.com/item/%E8%A1%8C%E7%A8%8B%E9%95%BF%E5%BA%A6%E7%BC%96%E7%A0%81/2931940?fr=aladdin\" target=\"_blank\">行程长度编码</a> 是一种常用的字符串压缩方法，它将连续的相同字符（重复 2 次或更多次）替换为字符和表示字符计数的数字（行程长度）。例如，用此方法压缩字符串 <code>&quot;aabccc&quot;</code> ，将 <code>&quot;aa&quot;</code> 替换为 <code>&quot;a2&quot;</code> ，<code>&quot;ccc&quot;</code> 替换为` <code>&quot;c3&quot;</code> 。因此压缩后的字符串变为 <code>&quot;a2bc3&quot;</code> 。</p>\n\n<p>注意，本问题中，压缩时没有在单个字符后附加计数 <code>&#39;1&#39;</code> 。</p>\n\n<p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> 。你需要从字符串 <code>s</code> 中删除最多 <code>k</code> 个字符，以使 <code>s</code> 的行程长度编码长度最小。</p>\n\n<p>请你返回删除最多 <code>k</code> 个字符后，<code>s</code> <strong>行程长度编码的最小长度</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aaabcccd&quot;, k = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>在不删除任何内容的情况下，压缩后的字符串是 &quot;a3bc3d&quot; ，长度为 6 。最优的方案是删除 &#39;b&#39; 和 &#39;d&#39;，这样一来，压缩后的字符串为 &quot;a3c3&quot; ，长度是 4 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aabbaa&quot;, k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>如果删去两个 &#39;b&#39; 字符，那么压缩后的字符串是长度为 2 的 &quot;a4&quot; 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aaaaaaaaaaa&quot;, k = 0\n<strong>输出：</strong>3\n<strong>解释：</strong>由于 k 等于 0 ，不能删去任何字符。压缩后的字符串是 &quot;a11&quot; ，长度为 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= k &lt;= s.length</code></li>\n\t<li><code>s</code> 仅包含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1532.最近的三笔订单",
        "hardRate": "MEDIUM",
        "passRate": "63.15%",
        "problemsUrl": "https://leetcode.cn/problems/the-most-recent-three-orders/",
        "solutionsUrl": "https://leetcode.cn/problems/the-most-recent-three-orders/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1533.找到最大整数的索引",
        "hardRate": "MEDIUM",
        "passRate": "58.77%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-index-of-the-large-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-index-of-the-large-integer/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1534.统计好三元组",
        "hardRate": "EASY",
        "passRate": "77.13%",
        "problemsUrl": "https://leetcode.cn/problems/count-good-triplets/",
        "solutionsUrl": "https://leetcode.cn/problems/count-good-triplets/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> ，以及 <code>a</code>、<code>b</code> 、<code>c</code> 三个整数。请你统计其中好三元组的数量。</p>\n\n<p>如果三元组 <code>(arr[i], arr[j], arr[k])</code> 满足下列全部条件，则认为它是一个 <strong>好三元组</strong> 。</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; k &lt;&nbsp;arr.length</code></li>\n\t<li><code>|arr[i] - arr[j]| &lt;= a</code></li>\n\t<li><code>|arr[j] - arr[k]| &lt;= b</code></li>\n\t<li><code>|arr[i] - arr[k]| &lt;= c</code></li>\n</ul>\n\n<p>其中 <code>|x|</code> 表示 <code>x</code> 的绝对值。</p>\n\n<p>返回 <strong>好三元组的数量</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3\n<strong>输出：</strong>4\n<strong>解释：</strong>一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,1,2,2,3], a = 0, b = 0, c = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在满足所有条件的三元组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= arr.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= a, b, c &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1535.找出数组游戏的赢家",
        "hardRate": "MEDIUM",
        "passRate": "46.17%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-winner-of-an-array-game/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-winner-of-an-array-game/solution",
        "problemsDesc": "<p>给你一个由 <strong>不同</strong> 整数组成的整数数组 <code>arr</code> 和一个整数 <code>k</code> 。</p>\n\n<p>每回合游戏都在数组的前两个元素（即 <code>arr[0]</code> 和 <code>arr[1]</code> ）之间进行。比较 <code>arr[0]</code> 与 <code>arr[1]</code> 的大小，较大的整数将会取得这一回合的胜利并保留在位置 <code>0</code> ，较小的整数移至数组的末尾。当一个整数赢得 <code>k</code> 个连续回合时，游戏结束，该整数就是比赛的 <strong>赢家</strong> 。</p>\n\n<p>返回赢得比赛的整数。</p>\n\n<p>题目数据 <strong>保证</strong> 游戏存在赢家。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,1,3,5,4,6,7], k = 2\n<strong>输出：</strong>5\n<strong>解释：</strong>一起看一下本场游戏每回合的情况：\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/30/q-example.png\" style=\"height: 90px; width: 400px;\">\n因此将进行 4 回合比赛，其中 5 是赢家，因为它连胜 2 回合。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,2,1], k = 10\n<strong>输出：</strong>3\n<strong>解释：</strong>3 将会在前 10 个回合中连续获胜。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,9,8,2,3,7,6,4,5], k = 7\n<strong>输出：</strong>9\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,11,22,33,44,55,66,77,88,99], k = 1000000000\n<strong>输出：</strong>99\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10^6</code></li>\n\t<li><code>arr</code> 所含的整数 <strong>各不相同</strong> 。</li>\n\t<li><code>1 &lt;= k &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1536.排布二进制网格的最少交换次数",
        "hardRate": "MEDIUM",
        "passRate": "46.31%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-swaps-to-arrange-a-binary-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-swaps-to-arrange-a-binary-grid/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>n&nbsp;x n</code>&nbsp;的二进制网格&nbsp;<code>grid</code>，每一次操作中，你可以选择网格的&nbsp;<strong>相邻两行</strong>&nbsp;进行交换。</p>\n\n<p>一个符合要求的网格需要满足主对角线以上的格子全部都是 <strong>0</strong>&nbsp;。</p>\n\n<p>请你返回使网格满足要求的最少操作次数，如果无法使网格符合要求，请你返回 <strong>-1</strong>&nbsp;。</p>\n\n<p>主对角线指的是从&nbsp;<code>(1, 1)</code>&nbsp;到&nbsp;<code>(n, n)</code>&nbsp;的这些格子。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/02/fw.jpg\" style=\"height: 141px; width: 750px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[0,0,1],[1,1,0],[1,0,0]]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/02/e2.jpg\" style=\"height: 270px; width: 270px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>所有行都是一样的，交换相邻行无法使网格符合要求。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/02/e3.jpg\" style=\"height: 210px; width: 210px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[1,0,0],[1,1,0],[1,1,1]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= n&nbsp;&lt;= 200</code></li>\n\t<li><code>grid[i][j]</code>&nbsp;要么是&nbsp;<code>0</code>&nbsp;要么是&nbsp;<code>1</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1537.最大得分",
        "hardRate": "HARD",
        "passRate": "40.13%",
        "problemsUrl": "https://leetcode.cn/problems/get-the-maximum-score/",
        "solutionsUrl": "https://leetcode.cn/problems/get-the-maximum-score/solution",
        "problemsDesc": "<p>你有两个 <strong>有序</strong>&nbsp;且数组内元素互不相同的数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;。</p>\n\n<p>一条&nbsp;<strong>合法路径</strong>&nbsp;定义如下：</p>\n\n<ul>\n\t<li>选择数组 nums1 或者 nums2 开始遍历（从下标 0 处开始）。</li>\n\t<li>从左到右遍历当前数组。</li>\n\t<li>如果你遇到了 <code>nums1</code>&nbsp;和 <code>nums2</code>&nbsp;中都存在的值，那么你可以切换路径到另一个数组对应数字处继续遍历（但在合法路径中重复数字只会被统计一次）。</li>\n</ul>\n\n<p>得分定义为合法路径中不同数字的和。</p>\n\n<p>请你返回所有可能合法路径中的最大得分。</p>\n\n<p>由于答案可能很大，请你将它对 10^9 + 7 取余后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/02/sample_1_1893.png\" style=\"height: 163px; width: 538px;\"></strong></p>\n\n<pre><strong>输入：</strong>nums1 = [2,4,5,8,10], nums2 = [4,6,8,9]\n<strong>输出：</strong>30\n<strong>解释：</strong>合法路径包括：\n[2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10],（从 nums1 开始遍历）\n[4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10]  （从 nums2 开始遍历）\n最大得分为上图中的绿色路径 <strong>[2,4,6,8,10]</strong>&nbsp;。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [1,3,5,7,9], nums2 = [3,5,100]\n<strong>输出：</strong>109\n<strong>解释：</strong>最大得分由路径 <strong>[1,3,5,100]</strong> 得到。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10]\n<strong>输出：</strong>40\n<strong>解释：</strong>nums1 和 nums2 之间无相同数字。\n最大得分由路径 <strong>[6,7,8,9,10]</strong> 得到。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [1,4,5,8,9,11,19], nums2 = [2,3,4,11,12]\n<strong>输出：</strong>61\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= nums2.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10^7</code></li>\n\t<li><code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;都是严格递增的数组。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1538.找出隐藏数组中出现次数最多的元素",
        "hardRate": "MEDIUM",
        "passRate": "57.61%",
        "problemsUrl": "https://leetcode.cn/problems/guess-the-majority-in-a-hidden-array/",
        "solutionsUrl": "https://leetcode.cn/problems/guess-the-majority-in-a-hidden-array/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1539.第 k 个缺失的正整数",
        "hardRate": "EASY",
        "passRate": "54.02%",
        "problemsUrl": "https://leetcode.cn/problems/kth-missing-positive-number/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-missing-positive-number/solution",
        "problemsDesc": "<p>给你一个 <strong>严格升序排列</strong>&nbsp;的正整数数组 <code>arr</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>请你找到这个数组里第&nbsp;<code>k</code>&nbsp;个缺失的正整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [2,3,4,7,11], k = 5\n<strong>输出：</strong>9\n<strong>解释：</strong>缺失的正整数包括 [1,5,6,8,9,10,12,13,...] 。第 5 个缺失的正整数为 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,4], k = 2\n<strong>输出：</strong>6\n<strong>解释：</strong>缺失的正整数包括 [5,6,7,...] 。第 2 个缺失的正整数为 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= k &lt;= 1000</code></li>\n\t<li>对于所有&nbsp;<code>1 &lt;= i &lt; j &lt;= arr.length</code>&nbsp;的 <code>i</code>&nbsp;和 <code>j</code> 满足&nbsp;<code>arr[i] &lt; arr[j]</code>&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<p>你可以设计一个时间复杂度小于 O(n) 的算法解决此问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1540.K 次操作转变字符串",
        "hardRate": "MEDIUM",
        "passRate": "33.42%",
        "problemsUrl": "https://leetcode.cn/problems/can-convert-string-in-k-moves/",
        "solutionsUrl": "https://leetcode.cn/problems/can-convert-string-in-k-moves/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>s</code>&nbsp;和&nbsp;<code>t</code>&nbsp;，你的目标是在 <code>k</code>&nbsp;次操作以内把字符串&nbsp;<code>s</code>&nbsp;转变成&nbsp;<code>t</code>&nbsp;。</p>\n\n<p>在第 <code>i</code>&nbsp;次操作时（<code>1 &lt;= i &lt;= k</code>），你可以选择进行如下操作：</p>\n\n<ul>\n\t<li>选择字符串 <code>s</code>&nbsp;中满足 <code>1 &lt;= j &lt;= s.length</code>&nbsp;且之前未被选过的任意下标 <code>j</code>&nbsp;（下标从 1 开始），并将此位置的字符切换 <code>i</code>&nbsp;次。</li>\n\t<li>不进行任何操作。</li>\n</ul>\n\n<p>切换 1 个字符的意思是用字母表中该字母的下一个字母替换它（字母表环状接起来，所以 <code>'z'</code>&nbsp;切换后会变成 <code>'a'</code>）。第 <code>i</code>&nbsp;次操作意味着该字符应切换&nbsp;<code>i</code>&nbsp;次</p>\n\n<p>请记住任意一个下标 <code>j</code>&nbsp;最多只能被操作&nbsp;1 次。</p>\n\n<p>如果在不超过 <code>k</code>&nbsp;次操作内可以把字符串 <code>s</code>&nbsp;转变成 <code>t</code>&nbsp;，那么请你返回&nbsp;<code>true</code>&nbsp;，否则请你返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"input\", t = \"ouput\", k = 9\n<strong>输出：</strong>true\n<strong>解释：</strong>第 6 次操作时，我们将 'i' 切换 6 次得到 'o' 。第 7 次操作时，我们将 'n' 切换 7 次得到 'u' 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\", t = \"bcd\", k = 10\n<strong>输出：</strong>false\n<strong>解释：</strong>我们需要将每个字符切换 1 次才能得到 t 。我们可以在第 1 次操作时将 'a' 切换成 'b' ，但另外 2 个字母在剩余操作中无法再转变为 t 中对应字母。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aab\", t = \"bbb\", k = 27\n<strong>输出：</strong>true\n<strong>解释：</strong>第 1 次操作时，我们将第一个 'a' 切换 1 次得到 'b' 。在第 27 次操作时，我们将第二个字母 'a' 切换 27 次得到 'b' 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= k &lt;= 10^9</code></li>\n\t<li><code>s</code>&nbsp;和&nbsp;<code>t</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1541.平衡括号字符串的最少插入次数",
        "hardRate": "MEDIUM",
        "passRate": "48.79%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/solution",
        "problemsDesc": "<p>给你一个括号字符串&nbsp;<code>s</code>&nbsp;，它只包含字符&nbsp;<code>&#39;(&#39;</code> 和&nbsp;<code>&#39;)&#39;</code>&nbsp;。一个括号字符串被称为平衡的当它满足：</p>\n\n<ul>\n\t<li>任何左括号&nbsp;<code>&#39;(&#39;</code>&nbsp;必须对应两个连续的右括号&nbsp;<code>&#39;))&#39;</code>&nbsp;。</li>\n\t<li>左括号&nbsp;<code>&#39;(&#39;</code>&nbsp;必须在对应的连续两个右括号&nbsp;<code>&#39;))&#39;</code>&nbsp;之前。</li>\n</ul>\n\n<p>比方说&nbsp;<code>&quot;())&quot;</code>，&nbsp;<code>&quot;())(())))&quot;</code> 和&nbsp;<code>&quot;(())())))&quot;</code>&nbsp;都是平衡的，&nbsp;<code>&quot;)()&quot;</code>，&nbsp;<code>&quot;()))&quot;</code> 和&nbsp;<code>&quot;(()))&quot;</code>&nbsp;都是不平衡的。</p>\n\n<p>你可以在任意位置插入字符 &#39;(&#39; 和 &#39;)&#39; 使字符串平衡。</p>\n\n<p>请你返回让 <code>s</code>&nbsp;平衡的最少插入次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;(()))&quot;\n<strong>输出：</strong>1\n<strong>解释：</strong>第二个左括号有与之匹配的两个右括号，但是第一个左括号只有一个右括号。我们需要在字符串结尾额外增加一个 &#39;)&#39; 使字符串变成平衡字符串 &quot;(())))&quot; 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;())&quot;\n<strong>输出：</strong>0\n<strong>解释：</strong>字符串已经平衡了。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;))())(&quot;\n<strong>输出：</strong>3\n<strong>解释：</strong>添加 &#39;(&#39; 去匹配最开头的 &#39;))&#39; ，然后添加 &#39;))&#39; 去匹配最后一个 &#39;(&#39; 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;((((((&quot;\n<strong>输出：</strong>12\n<strong>解释：</strong>添加 12 个 &#39;)&#39; 得到平衡字符串。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;)))))))&quot;\n<strong>输出：</strong>5\n<strong>解释：</strong>在字符串开头添加 4 个 &#39;(&#39; 并在结尾添加 1 个 &#39;)&#39; ，字符串变成平衡字符串 &quot;(((())))))))&quot; 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>s</code>&nbsp;只包含&nbsp;<code>&#39;(&#39;</code> 和&nbsp;<code>&#39;)&#39;</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1542.找出最长的超赞子字符串",
        "hardRate": "HARD",
        "passRate": "43.91%",
        "problemsUrl": "https://leetcode.cn/problems/find-longest-awesome-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/find-longest-awesome-substring/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 。请返回 <code>s</code> 中最长的 <strong>超赞子字符串</strong> 的长度。</p>\n\n<p>「超赞子字符串」需满足满足下述两个条件：</p>\n\n<ul>\n\t<li>该字符串是 <code>s</code> 的一个非空子字符串</li>\n\t<li>进行任意次数的字符交换后，该字符串可以变成一个回文字符串</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;3242415&quot;\n<strong>输出：</strong>5\n<strong>解释：</strong>&quot;24241&quot; 是最长的超赞子字符串，交换其中的字符后，可以得到回文 &quot;24142&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;12345678&quot;\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;213123&quot;\n<strong>输出：</strong>6\n<strong>解释：</strong>&quot;213123&quot; 是最长的超赞子字符串，交换其中的字符后，可以得到回文 &quot;231132&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;00&quot;\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>s</code> 仅由数字组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1543.产品名称格式修复",
        "hardRate": "EASY",
        "passRate": "55.39%",
        "problemsUrl": "https://leetcode.cn/problems/fix-product-name-format/",
        "solutionsUrl": "https://leetcode.cn/problems/fix-product-name-format/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1544.整理字符串",
        "hardRate": "EASY",
        "passRate": "55.98%",
        "problemsUrl": "https://leetcode.cn/problems/make-the-string-great/",
        "solutionsUrl": "https://leetcode.cn/problems/make-the-string-great/solution",
        "problemsDesc": "<p>给你一个由大小写英文字母组成的字符串 <code>s</code> 。</p>\n\n<p>一个整理好的字符串中，两个相邻字符 <code>s[i]</code> 和 <code>s[i+1]</code>，其中 <code>0<= i <= s.length-2</code> ，要满足如下条件:</p>\n\n<ul>\n\t<li>若 <code>s[i]</code> 是小写字符，则 <code>s[i+1]</code> 不可以是相同的大写字符。</li>\n\t<li>若 <code>s[i]</code> 是大写字符，则 <code>s[i+1]</code> 不可以是相同的小写字符。</li>\n</ul>\n\n<p>请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 <strong>两个相邻</strong> 字符并删除，直到字符串整理好为止。</p>\n\n<p>请返回整理好的 <strong>字符串</strong> 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。</p>\n\n<p><strong>注意：</strong>空字符串也属于整理好的字符串，尽管其中没有任何字符。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"leEeetcode\"\n<strong>输出：</strong>\"leetcode\"\n<strong>解释：</strong>无论你第一次选的是 i = 1 还是 i = 2，都会使 \"leEeetcode\" 缩减为 \"leetcode\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abBAcC\"\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>存在多种不同情况，但所有的情况都会导致相同的结果。例如：\n\"abBAcC\" --> \"aAcC\" --> \"cC\" --> \"\"\n\"abBAcC\" --> \"abBA\" --> \"aA\" --> \"\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"s\"\n<strong>输出：</strong>\"s\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 100</code></li>\n\t<li><code>s</code> 只包含小写和大写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1545.找出第 N 个二进制字符串中的第 K 位",
        "hardRate": "MEDIUM",
        "passRate": "59.00%",
        "problemsUrl": "https://leetcode.cn/problems/find-kth-bit-in-nth-binary-string/",
        "solutionsUrl": "https://leetcode.cn/problems/find-kth-bit-in-nth-binary-string/solution",
        "problemsDesc": "<p>给你两个正整数 <code>n</code> 和 <code>k</code>，二进制字符串  <code>S<sub>n</sub></code> 的形成规则如下：</p>\n\n<ul>\n\t<li><code>S<sub>1</sub> = \"0\"</code></li>\n\t<li>当 <code>i > 1</code> 时，<code>S<sub>i</sub> = S<sub>i-1</sub> + \"1\" + reverse(invert(S<sub>i-1</sub>))</code></li>\n</ul>\n\n<p>其中 <code>+</code> 表示串联操作，<code>reverse(x)</code> 返回反转 <code>x</code> 后得到的字符串，而 <code>invert(x)</code> 则会翻转 x 中的每一位（0 变为 1，而 1 变为 0）。</p>\n\n<p>例如，符合上述描述的序列的前 4 个字符串依次是：</p>\n\n<ul>\n\t<li><code>S<sub>1 </sub>= \"0\"</code></li>\n\t<li><code>S<sub>2 </sub>= \"0<strong>1</strong>1\"</code></li>\n\t<li><code>S<sub>3 </sub>= \"011<strong>1</strong>001\"</code></li>\n\t<li><code>S<sub>4</sub> = \"0111001<strong>1</strong>0110001\"</code></li>\n</ul>\n\n<p>请你返回  <code>S<sub>n</sub></code> 的 <strong>第 <code>k</code> 位字符</strong> ，题目数据保证 <code>k</code> 一定在 <code>S<sub>n</sub></code> 长度范围以内。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 1\n<strong>输出：</strong>\"0\"\n<strong>解释：</strong>S<sub>3</sub> 为 \"<strong>0</strong>111001\"，其第 1 位为 \"0\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, k = 11\n<strong>输出：</strong>\"1\"\n<strong>解释：</strong>S<sub>4</sub> 为 \"0111001101<strong>1</strong>0001\"，其第 11 位为 \"1\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, k = 1\n<strong>输出：</strong>\"0\"\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, k = 3\n<strong>输出：</strong>\"1\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 20</code></li>\n\t<li><code>1 <= k <= 2<sup>n</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1546.和为目标值且不重叠的非空子数组的最大数目",
        "hardRate": "MEDIUM",
        "passRate": "44.81%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>target</code>&nbsp;。</p>\n\n<p>请你返回&nbsp;<strong>非空不重叠</strong>&nbsp;子数组的最大数目，且每个子数组中数字和都为 <code>target</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,1,1,1], target = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>总共有 2 个不重叠子数组（加粗数字表示） [<strong>1,1</strong>,1,<strong>1,1</strong>] ，它们的和为目标值 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [-1,3,5,1,4,2,-9], target = 6\n<strong>输出：</strong>2\n<strong>解释：</strong>总共有 3 个子数组和为 6 。\n([5,1], [4,2], [3,5,1,4,2,-9]) 但只有前 2 个是不重叠的。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [-2,6,6,3,5,4,1,2,8], target = 10\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,0,0], target = 0\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;=&nbsp;10^5</code></li>\n\t<li><code>-10^4 &lt;= nums[i] &lt;=&nbsp;10^4</code></li>\n\t<li><code>0 &lt;= target &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1547.切棍子的最小成本",
        "hardRate": "HARD",
        "passRate": "56.63%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-cut-a-stick/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-cut-a-stick/solution",
        "problemsDesc": "<p>有一根长度为 <code>n</code> 个单位的木棍，棍上从 <code>0</code> 到 <code>n</code> 标记了若干位置。例如，长度为 <strong>6</strong> 的棍子可以标记如下：</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/09/statement.jpg\" style=\"height: 111px; width: 521px;\" /></p>\n\n<p>给你一个整数数组 <code>cuts</code> ，其中 <code>cuts[i]</code> 表示你需要将棍子切开的位置。</p>\n\n<p>你可以按顺序完成切割，也可以根据需要更改切割的顺序。</p>\n\n<p>每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是历次切割成本的总和。对棍子进行切割将会把一根木棍分成两根较小的木棍（这两根木棍的长度和就是切割前木棍的长度）。请参阅第一个示例以获得更直观的解释。</p>\n\n<p>返回切棍子的 <strong>最小总成本</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/09/e1.jpg\" style=\"height: 284px; width: 350px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 7, cuts = [1,3,4,5]\n<strong>输出：</strong>16\n<strong>解释：</strong>按 [1, 3, 4, 5] 的顺序切割的情况如下所示：\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/09/e11.jpg\" style=\"height: 284px; width: 350px;\" />\n第一次切割长度为 7 的棍子，成本为 7 。第二次切割长度为 6 的棍子（即第一次切割得到的第二根棍子），第三次切割为长度 4 的棍子，最后切割长度为 3 的棍子。总成本为 7 + 6 + 4 + 3 = 20 。\n而将切割顺序重新排列为 [3, 5, 1, 4] 后，总成本 = 16（如示例图中 7 + 4 + 3 + 2 = 16）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 9, cuts = [5,6,1,4,2]\n<strong>输出：</strong>22\n<strong>解释：</strong>如果按给定的顺序切割，则总成本为 25 。总成本 <= 25 的切割顺序很多，例如，[4, 6, 5, 2, 1] 的总成本 = 22，是所有可能方案中成本最小的。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 10^6</code></li>\n\t<li><code>1 <= cuts.length <= min(n - 1, 100)</code></li>\n\t<li><code>1 <= cuts[i] <= n - 1</code></li>\n\t<li><code>cuts</code> 数组中的所有整数都 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1548.图中最相似的路径",
        "hardRate": "HARD",
        "passRate": "68.02%",
        "problemsUrl": "https://leetcode.cn/problems/the-most-similar-path-in-a-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/the-most-similar-path-in-a-graph/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1549.每件商品的最新订单",
        "hardRate": "MEDIUM",
        "passRate": "67.71%",
        "problemsUrl": "https://leetcode.cn/problems/the-most-recent-orders-for-each-product/",
        "solutionsUrl": "https://leetcode.cn/problems/the-most-recent-orders-for-each-product/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1550.存在连续三个奇数的数组",
        "hardRate": "EASY",
        "passRate": "65.61%",
        "problemsUrl": "https://leetcode.cn/problems/three-consecutive-odds/",
        "solutionsUrl": "https://leetcode.cn/problems/three-consecutive-odds/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code>，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,6,4,1]\n<strong>输出：</strong>false\n<strong>解释：</strong>不存在连续三个元素都是奇数的情况。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,34,3,4,5,7,23,12]\n<strong>输出：</strong>true\n<strong>解释：</strong>存在连续三个元素都是奇数的情况，即 [5,7,23] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1551.使数组中所有元素相等的最小操作数",
        "hardRate": "MEDIUM",
        "passRate": "82.15%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-array-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-array-equal/solution",
        "problemsDesc": "<p>存在一个长度为 <code>n</code> 的数组 <code>arr</code> ，其中 <code>arr[i] = (2 * i) + 1</code> （ <code>0 &lt;= i &lt; n</code> ）。</p>\n\n<p>一次操作中，你可以选出两个下标，记作 <code>x</code> 和 <code>y</code> （ <code>0 &lt;= x, y &lt; n</code> ）并使 <code>arr[x]</code> 减去 <code>1</code> 、<code>arr[y]</code> 加上 <code>1</code> （即 <code>arr[x] -=1 </code>且 <code>arr[y] += 1</code> ）。最终的目标是使数组中的所有元素都 <strong>相等</strong> 。题目测试用例将会 <strong>保证</strong> ：在执行若干步操作后，数组中的所有元素最终可以全部相等。</p>\n\n<p>给你一个整数 <code>n</code>，即数组的长度。请你返回使数组 <code>arr</code> 中所有元素相等所需的 <strong>最小操作数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>arr = [1, 3, 5]\n第一次操作选出 x = 2 和 y = 0，使数组变为 [2, 3, 4]\n第二次操作继续选出 x = 2 和 y = 0，数组将会变成 [3, 3, 3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 6\n<strong>输出：</strong>9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1552.两球之间的磁力",
        "hardRate": "MEDIUM",
        "passRate": "56.85%",
        "problemsUrl": "https://leetcode.cn/problems/magnetic-force-between-two-balls/",
        "solutionsUrl": "https://leetcode.cn/problems/magnetic-force-between-two-balls/solution",
        "problemsDesc": "<p>在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有&nbsp;<code>n</code>&nbsp;个空的篮子，第&nbsp;<code>i</code>&nbsp;个篮子的位置在&nbsp;<code>position[i]</code>&nbsp;，Morty&nbsp;想把&nbsp;<code>m</code>&nbsp;个球放到这些篮子里，使得任意两球间&nbsp;<strong>最小磁力</strong>&nbsp;最大。</p>\n\n<p>已知两个球如果分别位于&nbsp;<code>x</code>&nbsp;和&nbsp;<code>y</code>&nbsp;，那么它们之间的磁力为&nbsp;<code>|x - y|</code>&nbsp;。</p>\n\n<p>给你一个整数数组&nbsp;<code>position</code>&nbsp;和一个整数&nbsp;<code>m</code>&nbsp;，请你返回最大化的最小磁力。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/16/q3v1.jpg\" style=\"height: 195px; width: 562px;\"></p>\n\n<pre><strong>输入：</strong>position = [1,2,3,4,7], m = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>将 3 个球分别放入位于 1，4 和 7 的三个篮子，两球间的磁力分别为 [3, 3, 6]。最小磁力为 3 。我们没办法让最小磁力大于 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>position = [5,4,3,2,1,1000000000], m = 2\n<strong>输出：</strong>999999999\n<strong>解释：</strong>我们使用位于 1 和 1000000000 的篮子时最小磁力最大。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == position.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= position[i] &lt;= 10^9</code></li>\n\t<li>所有&nbsp;<code>position</code>&nbsp;中的整数 <strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>2 &lt;= m &lt;= position.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1553.吃掉 N 个橘子的最少天数",
        "hardRate": "HARD",
        "passRate": "32.42%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-days-to-eat-n-oranges/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-days-to-eat-n-oranges/solution",
        "problemsDesc": "<p>厨房里总共有 <code>n</code>&nbsp;个橘子，你决定每一天选择如下方式之一吃这些橘子：</p>\n\n<ul>\n\t<li>吃掉一个橘子。</li>\n\t<li>如果剩余橘子数 <code>n</code>&nbsp;能被 2 整除，那么你可以吃掉 <code>n/2</code> 个橘子。</li>\n\t<li>如果剩余橘子数&nbsp;<code>n</code>&nbsp;能被 3 整除，那么你可以吃掉 <code>2*(n/3)</code> 个橘子。</li>\n</ul>\n\n<p>每天你只能从以上 3 种方案中选择一种方案。</p>\n\n<p>请你返回吃掉所有 <code>n</code>&nbsp;个橘子的最少天数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 10\n<strong>输出：</strong>4\n<strong>解释：</strong>你总共有 10 个橘子。\n第 1 天：吃 1 个橘子，剩余橘子数 10 - 1 = 9。\n第 2 天：吃 6 个橘子，剩余橘子数 9 - 2*(9/3) = 9 - 6 = 3。（9 可以被 3 整除）\n第 3 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。\n第 4 天：吃掉最后 1 个橘子，剩余橘子数 1 - 1 = 0。\n你需要至少 4 天吃掉 10 个橘子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 6\n<strong>输出：</strong>3\n<strong>解释：</strong>你总共有 6 个橘子。\n第 1 天：吃 3 个橘子，剩余橘子数 6 - 6/2 = 6 - 3 = 3。（6 可以被 2 整除）\n第 2 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。（3 可以被 3 整除）\n第 3 天：吃掉剩余 1 个橘子，剩余橘子数 1 - 1 = 0。\n你至少需要 3 天吃掉 6 个橘子。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 56\n<strong>输出：</strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2*10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1554.只有一个不同字符的字符串",
        "hardRate": "MEDIUM",
        "passRate": "49.96%",
        "problemsUrl": "https://leetcode.cn/problems/strings-differ-by-one-character/",
        "solutionsUrl": "https://leetcode.cn/problems/strings-differ-by-one-character/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1555.银行账户概要",
        "hardRate": "MEDIUM",
        "passRate": "44.97%",
        "problemsUrl": "https://leetcode.cn/problems/bank-account-summary/",
        "solutionsUrl": "https://leetcode.cn/problems/bank-account-summary/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1556.千位分隔数",
        "hardRate": "EASY",
        "passRate": "56.13%",
        "problemsUrl": "https://leetcode.cn/problems/thousand-separator/",
        "solutionsUrl": "https://leetcode.cn/problems/thousand-separator/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>，请你每隔三位添加点（即 &quot;.&quot; 符号）作为千位分隔符，并将结果以字符串格式返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 987\n<strong>输出：</strong>&quot;987&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 1234\n<strong>输出：</strong>&quot;1.234&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 123456789\n<strong>输出：</strong>&quot;123.456.789&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 0\n<strong>输出：</strong>&quot;0&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt; 2^31</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1557.可以到达所有点的最少点数目",
        "hardRate": "MEDIUM",
        "passRate": "81.55%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-vertices-to-reach-all-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-vertices-to-reach-all-nodes/solution",
        "problemsDesc": "<p>给你一个 <strong>有向无环图</strong>&nbsp;， <code>n</code>&nbsp;个节点编号为 <code>0</code>&nbsp;到 <code>n-1</code>&nbsp;，以及一个边数组 <code>edges</code>&nbsp;，其中 <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>]</code>&nbsp;表示一条从点&nbsp;&nbsp;<code>from<sub>i</sub></code>&nbsp;到点&nbsp;<code>to<sub>i</sub></code>&nbsp;的有向边。</p>\n\n<p>找到最小的点集使得从这些点出发能到达图中所有点。题目保证解存在且唯一。</p>\n\n<p>你可以以任意顺序返回这些节点编号。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5480e1.png\" style=\"height: 181px; width: 231px;\"></p>\n\n<pre><strong>输入：</strong>n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]\n<strong>输出：</strong>[0,3]\n<strong>解释：</strong>从单个节点出发无法到达所有节点。从 0 出发我们可以到达 [0,1,2,5] 。从 3 出发我们可以到达 [3,4,2,5] 。所以我们输出 [0,3] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5480e2.png\" style=\"height: 201px; width: 201px;\"></p>\n\n<pre><strong>输入：</strong>n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]]\n<strong>输出：</strong>[0,2,3]\n<strong>解释：</strong>注意到节点 0，3 和 2 无法从其他节点到达，所以我们必须将它们包含在结果点集中，这些点都能到达节点 1 和 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= min(10^5, n * (n - 1) / 2)</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= from<sub>i,</sub>&nbsp;to<sub>i</sub> &lt; n</code></li>\n\t<li>所有点对&nbsp;<code>(from<sub>i</sub>, to<sub>i</sub>)</code>&nbsp;互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1558.得到目标数组的最少函数调用次数",
        "hardRate": "MEDIUM",
        "passRate": "62.99%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-numbers-of-function-calls-to-make-target-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-numbers-of-function-calls-to-make-target-array/solution",
        "problemsDesc": "<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/10/sample_2_1887.png\" style=\"height:294px; width:573px\" /></p>\n\n<p>给你一个与 <code>nums</code>&nbsp;大小相同且初始值全为 0 的数组 <code>arr</code> ，请你调用以上函数得到整数数组 <code>nums</code>&nbsp;。</p>\n\n<p>请你返回将 <code>arr</code>&nbsp;变成 <code>nums</code>&nbsp;的最少函数调用次数。</p>\n\n<p>答案保证在 32 位有符号整数以内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5]\n<strong>输出：</strong>5\n<strong>解释：</strong>给第二个数加 1 ：[0, 0] 变成 [0, 1] （1 次操作）。\n将所有数字乘以 2 ：[0, 1] -&gt; [0, 2] -&gt; [0, 4] （2 次操作）。\n给两个数字都加 1 ：[0, 4] -&gt; [1, 4] -&gt; <strong>[1, 5]</strong> （2 次操作）。\n总操作次数为：1 + 2 + 2 = 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2]\n<strong>输出：</strong>3\n<strong>解释：</strong>给两个数字都加 1 ：[0, 0] -&gt; [0, 1] -&gt; [1, 1] （2 次操作）。\n将所有数字乘以 2 ： [1, 1] -&gt; <strong>[2, 2]</strong> （1 次操作）。\n总操作次数为： 2 + 1 = 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,2,5]\n<strong>输出：</strong>6\n<strong>解释：</strong>（初始）[0,0,0] -&gt; [1,0,0] -&gt; [1,0,1] -&gt; [2,0,2] -&gt; [2,1,2] -&gt; [4,2,4] -&gt; <strong>[4,2,5] </strong>（nums 数组）。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,2,4]\n<strong>输出：</strong>7\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,4,8,16]\n<strong>输出：</strong>8\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1559.二维网格图中探测环",
        "hardRate": "MEDIUM",
        "passRate": "40.61%",
        "problemsUrl": "https://leetcode.cn/problems/detect-cycles-in-2d-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/detect-cycles-in-2d-grid/solution",
        "problemsDesc": "<p>给你一个二维字符网格数组&nbsp;<code>grid</code>&nbsp;，大小为&nbsp;<code>m x n</code>&nbsp;，你需要检查&nbsp;<code>grid</code>&nbsp;中是否存在 <strong>相同值</strong> 形成的环。</p>\n\n<p>一个环是一条开始和结束于同一个格子的长度 <strong>大于等于 4</strong>&nbsp;的路径。对于一个给定的格子，你可以移动到它上、下、左、右四个方向相邻的格子之一，可以移动的前提是这两个格子有 <strong>相同的值&nbsp;</strong>。</p>\n\n<p>同时，你也不能回到上一次移动时所在的格子。比方说，环&nbsp;&nbsp;<code>(1, 1) -&gt; (1, 2) -&gt; (1, 1)</code>&nbsp;是不合法的，因为从 <code>(1, 2)</code>&nbsp;移动到 <code>(1, 1)</code> 回到了上一次移动时的格子。</p>\n\n<p>如果 <code>grid</code>&nbsp;中有相同值形成的环，请你返回 <code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e1.png\" style=\"height: 152px; width: 231px;\"></strong></p>\n\n<pre><strong>输入：</strong>grid = [[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]]\n<strong>输出：</strong>true\n<strong>解释：</strong>如下图所示，有 2 个用不同颜色标出来的环：\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e11.png\" style=\"height: 163px; width: 225px;\">\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e2.png\" style=\"height: 154px; width: 236px;\"></strong></p>\n\n<pre><strong>输入：</strong>grid = [[&quot;c&quot;,&quot;c&quot;,&quot;c&quot;,&quot;a&quot;],[&quot;c&quot;,&quot;d&quot;,&quot;c&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;c&quot;,&quot;e&quot;,&quot;c&quot;],[&quot;f&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]]\n<strong>输出：</strong>true\n<strong>解释：</strong>如下图所示，只有高亮所示的一个合法环：\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e22.png\" style=\"height: 157px; width: 229px;\">\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e3.png\" style=\"height: 120px; width: 183px;\"></strong></p>\n\n<pre><strong>输入：</strong>grid = [[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;z&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;b&quot;,&quot;a&quot;]]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m &lt;= 500</code></li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>grid</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1560.圆形赛道上经过次数最多的扇区",
        "hardRate": "EASY",
        "passRate": "57.46%",
        "problemsUrl": "https://leetcode.cn/problems/most-visited-sector-in-a-circular-track/",
        "solutionsUrl": "https://leetcode.cn/problems/most-visited-sector-in-a-circular-track/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> 和一个整数数组 <code>rounds</code> 。有一条圆形赛道由 <code>n</code> 个扇区组成，扇区编号从 <code>1</code> 到 <code>n</code> 。现将在这条赛道上举办一场马拉松比赛，该马拉松全程由 <code>m</code> 个阶段组成。其中，第 <code>i</code> 个阶段将会从扇区 <code>rounds[i - 1]</code> 开始，到扇区 <code>rounds[i]</code> 结束。举例来说，第 <code>1</code> 阶段从&nbsp;<code>rounds[0]</code>&nbsp;开始，到&nbsp;<code>rounds[1]</code>&nbsp;结束。</p>\n\n<p>请你以数组形式返回经过次数最多的那几个扇区，按扇区编号 <strong>升序</strong> 排列。</p>\n\n<p>注意，赛道按扇区编号升序逆时针形成一个圆（请参见第一个示例）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/3rd45e.jpg\" style=\"height: 341px; width: 433px;\"></p>\n\n<pre><strong>输入：</strong>n = 4, rounds = [1,3,1,2]\n<strong>输出：</strong>[1,2]\n<strong>解释：</strong>本场马拉松比赛从扇区 1 开始。经过各个扇区的次序如下所示：\n1 --&gt; 2 --&gt; 3（阶段 1 结束）--&gt; 4 --&gt; 1（阶段 2 结束）--&gt; 2（阶段 3 结束，即本场马拉松结束）\n其中，扇区 1 和 2 都经过了两次，它们是经过次数最多的两个扇区。扇区 3 和 4 都只经过了一次。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, rounds = [2,1,2,1,2,1,2,1,2]\n<strong>输出：</strong>[2]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 7, rounds = [1,3,5,7]\n<strong>输出：</strong>[1,2,3,4,5,6,7]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= m &lt;= 100</code></li>\n\t<li><code>rounds.length == m + 1</code></li>\n\t<li><code>1 &lt;= rounds[i] &lt;= n</code></li>\n\t<li><code>rounds[i] != rounds[i + 1]</code> ，其中 <code>0 &lt;= i &lt; m</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1561.你可以获得的最大硬币数目",
        "hardRate": "MEDIUM",
        "passRate": "77.71%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-coins-you-can-get/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-coins-you-can-get/solution",
        "problemsDesc": "<p>有 3n 堆数目不一的硬币，你和你的朋友们打算按以下方式分硬币：</p>\n\n<ul>\n\t<li>每一轮中，你将会选出 <strong>任意</strong> 3 堆硬币（不一定连续）。</li>\n\t<li>Alice 将会取走硬币数量最多的那一堆。</li>\n\t<li>你将会取走硬币数量第二多的那一堆。</li>\n\t<li>Bob 将会取走最后一堆。</li>\n\t<li>重复这个过程，直到没有更多硬币。</li>\n</ul>\n\n<p>给你一个整数数组 <code>piles</code> ，其中 <code>piles[i]</code> 是第 <code>i</code> 堆中硬币的数目。</p>\n\n<p>返回你可以获得的最大硬币数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>piles = [2,4,1,2,7,8]\n<strong>输出：</strong>9\n<strong>解释：</strong>选出 (2, 7, 8) ，Alice 取走 8 枚硬币的那堆，你取走 <strong>7</strong> 枚硬币的那堆，Bob 取走最后一堆。\n选出 (1, 2, 4) , Alice 取走 4 枚硬币的那堆，你取走 <strong>2</strong> 枚硬币的那堆，Bob 取走最后一堆。\n你可以获得的最大硬币数目：7 + 2 = 9.\n考虑另外一种情况，如果选出的是 (1, <strong>2</strong>, 8) 和 (2, <strong>4</strong>, 7) ，你就只能得到 2 + 4 = 6 枚硬币，这不是最优解。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>piles = [2,4,5]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>piles = [9,8,7,6,5,1,2,3,4]\n<strong>输出：</strong>18\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= piles.length &lt;= 10^5</code></li>\n\t<li><code>piles.length % 3 == 0</code></li>\n\t<li><code>1 &lt;= piles[i] &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1562.查找大小为 M 的最新分组",
        "hardRate": "MEDIUM",
        "passRate": "36.63%",
        "problemsUrl": "https://leetcode.cn/problems/find-latest-group-of-size-m/",
        "solutionsUrl": "https://leetcode.cn/problems/find-latest-group-of-size-m/solution",
        "problemsDesc": "<p>给你一个数组 <code>arr</code> ，该数组表示一个从 <code>1</code> 到 <code>n</code> 的数字排列。有一个长度为 <code>n</code> 的二进制字符串，该字符串上的所有位最初都设置为 <code>0</code> 。</p>\n\n<p>在从 <code>1</code> 到 <code>n</code> 的每个步骤 <code>i</code> 中（假设二进制字符串和 <code>arr</code> 都是从 <code>1</code> 开始索引的情况下），二进制字符串上位于位置 <code>arr[i]</code> 的位将会设为 <code>1</code> 。</p>\n\n<p>给你一个整数 <code>m</code> ，请你找出二进制字符串上存在长度为 <code>m</code> 的一组 <code>1</code> 的最后步骤。一组 <code>1</code> 是一个连续的、由 <code>1</code> 组成的子串，且左右两边不再有可以延伸的 <code>1</code> 。</p>\n\n<p>返回存在长度 <strong>恰好</strong> 为 <code>m</code> 的 <strong>一组 <code>1</code>&nbsp;</strong> 的最后步骤。如果不存在这样的步骤，请返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,5,1,2,4], m = 1\n<strong>输出：</strong>4\n<strong>解释：\n</strong>步骤 1：&quot;00<strong>1</strong>00&quot;，由 1 构成的组：[&quot;1&quot;]\n步骤 2：&quot;0010<strong>1</strong>&quot;，由 1 构成的组：[&quot;1&quot;, &quot;1&quot;]\n步骤 3：&quot;<strong>1</strong>0101&quot;，由 1 构成的组：[&quot;1&quot;, &quot;1&quot;, &quot;1&quot;]\n步骤 4：&quot;1<strong>1</strong>101&quot;，由 1 构成的组：[&quot;111&quot;, &quot;1&quot;]\n步骤 5：&quot;111<strong>1</strong>1&quot;，由 1 构成的组：[&quot;11111&quot;]\n存在长度为 1 的一组 1 的最后步骤是步骤 4 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,1,5,4,2], m = 2\n<strong>输出：</strong>-1\n<strong>解释：\n</strong>步骤 1：&quot;00<strong>1</strong>00&quot;，由 1 构成的组：[&quot;1&quot;]\n步骤 2：&quot;<strong>1</strong>0100&quot;，由 1 构成的组：[&quot;1&quot;, &quot;1&quot;]\n步骤 3：&quot;1010<strong>1</strong>&quot;，由 1 构成的组：[&quot;1&quot;, &quot;1&quot;, &quot;1&quot;]\n步骤 4：&quot;101<strong>1</strong>1&quot;，由 1 构成的组：[&quot;1&quot;, &quot;111&quot;]\n步骤 5：&quot;1<strong>1</strong>111&quot;，由 1 构成的组：[&quot;11111&quot;]\n不管是哪一步骤都无法形成长度为 2 的一组 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1], m = 1\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,1], m = 2\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == arr.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= n</code></li>\n\t<li><code>arr</code> 中的所有整数 <strong>互不相同</strong></li>\n\t<li><code>1 &lt;= m&nbsp;&lt;= arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1563.石子游戏 V",
        "hardRate": "HARD",
        "passRate": "39.68%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game-v/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game-v/solution",
        "problemsDesc": "<p>几块石子 <strong>排成一行</strong> ，每块石子都有一个关联值，关联值为整数，由数组 <code>stoneValue</code> 给出。</p>\n\n<p>游戏中的每一轮：Alice 会将这行石子分成两个 <strong>非空行</strong>（即，左侧行和右侧行）；Bob 负责计算每一行的值，即此行中所有石子的值的总和。Bob 会丢弃值最大的行，Alice 的得分为剩下那行的值（每轮累加）。如果两行的值相等，Bob 让 Alice 决定丢弃哪一行。下一轮从剩下的那一行开始。</p>\n\n<p>只 <strong>剩下一块石子</strong> 时，游戏结束。Alice 的分数最初为 <strong><code>0</code></strong> 。</p>\n\n<p>返回 <strong>Alice 能够获得的最大分数</strong><em> 。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>stoneValue = [6,2,3,4,5,5]\n<strong>输出：</strong>18\n<strong>解释：</strong>在第一轮中，Alice 将行划分为 [6，2，3]，[4，5，5] 。左行的值是 11 ，右行的值是 14 。Bob 丢弃了右行，Alice 的分数现在是 11 。\n在第二轮中，Alice 将行分成 [6]，[2，3] 。这一次 Bob 扔掉了左行，Alice 的分数变成了 16（11 + 5）。\n最后一轮 Alice 只能将行分成 [2]，[3] 。Bob 扔掉右行，Alice 的分数现在是 18（16 + 2）。游戏结束，因为这行只剩下一块石头了。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>stoneValue = [7,7,7,7,7,7,7]\n<strong>输出：</strong>28\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>stoneValue = [4]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= stoneValue.length &lt;= 500</code></li>\n\t<li><code>1 &lt;=&nbsp;stoneValue[i] &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1564.把箱子放进仓库里 I",
        "hardRate": "MEDIUM",
        "passRate": "57.90%",
        "problemsUrl": "https://leetcode.cn/problems/put-boxes-into-the-warehouse-i/",
        "solutionsUrl": "https://leetcode.cn/problems/put-boxes-into-the-warehouse-i/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1565.按月统计订单数与顾客数",
        "hardRate": "EASY",
        "passRate": "73.90%",
        "problemsUrl": "https://leetcode.cn/problems/unique-orders-and-customers-per-month/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-orders-and-customers-per-month/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1566.重复至少 K 次且长度为 M 的模式",
        "hardRate": "EASY",
        "passRate": "44.30%",
        "problemsUrl": "https://leetcode.cn/problems/detect-pattern-of-length-m-repeated-k-or-more-times/",
        "solutionsUrl": "https://leetcode.cn/problems/detect-pattern-of-length-m-repeated-k-or-more-times/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>arr</code>，请你找出一个长度为 <code>m</code> 且在数组中至少重复 <code>k</code> 次的模式。</p>\n\n<p><strong>模式</strong> 是由一个或多个值组成的子数组（连续的子序列），<strong>连续</strong> 重复多次但 <strong>不重叠</strong> 。 模式由其长度和重复次数定义。</p>\n\n<p>如果数组中存在至少重复 <code>k</code> 次且长度为 <code>m</code> 的模式，则返回 <code>true</code> ，否则返回&nbsp; <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,4,4,4,4], m = 1, k = 3\n<strong>输出：</strong>true\n<strong>解释：</strong>模式 <strong>(4)</strong> 的长度为 1 ，且连续重复 4 次。注意，模式可以重复 k 次或更多次，但不能少于 k 次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>模式 <strong>(1,2)</strong> 长度为 2 ，且连续重复 2 次。另一个符合题意的模式是 <strong>(2,1) </strong>，同样重复 2 次。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,1,2,1,3], m = 2, k = 3\n<strong>输出：</strong>false\n<strong>解释：</strong>模式 <strong>(1,2)</strong> 长度为 2 ，但是只连续重复 2 次。不存在长度为 2 且至少重复 3 次的模式。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,3,1,2], m = 2, k = 2\n<strong>输出：</strong>false\n<strong>解释：</strong>模式 <strong>(1,2)</strong> 出现 2 次但并不连续，所以不能算作连续重复 2 次。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,2,2,2], m = 2, k = 3\n<strong>输出：</strong>false\n<strong>解释：</strong>长度为 2 的模式只有 <strong>(2,2)</strong> ，但是只连续重复 2 次。注意，不能计算重叠的重复次数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= m&nbsp;&lt;= 100</code></li>\n\t<li><code>2 &lt;= k&nbsp;&lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1567.乘积为正数的最长子数组长度",
        "hardRate": "MEDIUM",
        "passRate": "42.65%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-length-of-subarray-with-positive-product/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-length-of-subarray-with-positive-product/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>&nbsp;，请你求出乘积为正数的最长子数组的长度。</p>\n\n<p>一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。</p>\n\n<p>请你返回乘积为正数的最长子数组长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp; 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,-2,-3,4]\n<strong>输出：</strong>4\n<strong>解释：</strong>数组本身乘积就是正数，值为 24 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,-2,-3,-4]\n<strong>输出：</strong>3\n<strong>解释：</strong>最长乘积为正数的子数组为 [1,-2,-3] ，乘积为 6 。\n注意，我们不能把 0 也包括到子数组中，因为这样乘积为 0 ，不是正数。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,-2,-3,0,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>乘积为正数的最长子数组是 [-1,-2] 或者 [-2,-3] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>-10^9 &lt;= nums[i]&nbsp;&lt;= 10^9</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1568.使陆地分离的最少天数",
        "hardRate": "HARD",
        "passRate": "45.00%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-days-to-disconnect-island/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-days-to-disconnect-island/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> ，由若干 <code>0</code> 和 <code>1</code> 组成的二维网格 <code>grid</code> ，其中 <code>1</code> 表示陆地， <code>0</code> 表示水。<strong>岛屿</strong> 由水平方向或竖直方向上相邻的 <code>1</code> （陆地）连接形成。</p>\n\n<p>如果 <strong>恰好只有一座岛屿 </strong>，则认为陆地是 <strong>连通的</strong> ；否则，陆地就是 <strong>分离的</strong> 。</p>\n\n<p>一天内，可以将 <strong>任何单个</strong> 陆地单元（<code>1</code>）更改为水单元（<code>0</code>）。</p>\n\n<p>返回使陆地分离的最少天数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/24/land1.jpg\" style=\"width: 500px; height: 169px;\" />\n<pre>\n<strong>输入：</strong>grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]\n<strong>输出：</strong>2\n<strong>解释：</strong>至少需要 2 天才能得到分离的陆地。\n将陆地 grid[1][1] 和 grid[0][2] 更改为水，得到两个分离的岛屿。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/24/land2.jpg\" style=\"width: 404px; height: 85px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,1]]\n<strong>输出：</strong>2\n<strong>解释：</strong>如果网格中都是水，也认为是分离的 ([[1,1]] -&gt; [[0,0]])，0 岛屿。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 30</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1569.将子数组重新排序得到同一个二叉搜索树的方案数",
        "hardRate": "HARD",
        "passRate": "49.20%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-reorder-array-to-get-same-bst/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-reorder-array-to-get-same-bst/solution",
        "problemsDesc": "<p>给你一个数组 <code>nums</code>&nbsp;表示 <code>1</code>&nbsp;到 <code>n</code>&nbsp;的一个排列。我们按照元素在 <code>nums</code>&nbsp;中的顺序依次插入一个初始为空的二叉搜索树（BST）。请你统计将 <code>nums</code>&nbsp;重新排序后，统计满足如下条件的方案数：重排后得到的二叉搜索树与 <code>nums</code>&nbsp;原本数字顺序得到的二叉搜索树相同。</p>\n\n<p>比方说，给你&nbsp;<code>nums = [2,1,3]</code>，我们得到一棵 2 为根，1 为左孩子，3 为右孩子的树。数组&nbsp;<code>[2,3,1]</code>&nbsp;也能得到相同的 BST，但&nbsp;<code>[3,2,1]</code>&nbsp;会得到一棵不同的&nbsp;BST 。</p>\n\n<p>请你返回重排 <code>nums</code>&nbsp;后，与原数组 <code>nums</code> 得到相同二叉搜索树的方案数。</p>\n\n<p>由于答案可能会很大，请将结果对<strong>&nbsp;</strong><code>10^9 + 7</code>&nbsp;取余数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/bb.png\" style=\"height: 101px; width: 121px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,3]\n<strong>输出：</strong>1\n<strong>解释：</strong>我们将 nums 重排， [2,3,1] 能得到相同的 BST 。没有其他得到相同 BST 的方案了。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/ex1.png\" style=\"height: 161px; width: 241px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,5,1,2]\n<strong>输出：</strong>5\n<strong>解释：</strong>下面 5 个数组会得到相同的 BST：\n[3,1,2,4,5]\n[3,1,4,2,5]\n[3,1,4,5,2]\n[3,4,1,2,5]\n[3,4,1,5,2]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/ex4.png\" style=\"height: 161px; width: 121px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>0\n<strong>解释：</strong>没有别的排列顺序能得到相同的 BST 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>\n\t<li><code>nums</code>&nbsp;中所有数 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1570.两个稀疏向量的点积",
        "hardRate": "MEDIUM",
        "passRate": "88.78%",
        "problemsUrl": "https://leetcode.cn/problems/dot-product-of-two-sparse-vectors/",
        "solutionsUrl": "https://leetcode.cn/problems/dot-product-of-two-sparse-vectors/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1571.仓库经理",
        "hardRate": "EASY",
        "passRate": "77.56%",
        "problemsUrl": "https://leetcode.cn/problems/warehouse-manager/",
        "solutionsUrl": "https://leetcode.cn/problems/warehouse-manager/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1572.矩阵对角线元素的和",
        "hardRate": "EASY",
        "passRate": "80.73%",
        "problemsUrl": "https://leetcode.cn/problems/matrix-diagonal-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/matrix-diagonal-sum/solution",
        "problemsDesc": "<p>给你一个正方形矩阵 <code>mat</code>，请你返回矩阵对角线元素的和。</p>\n\n<p>请你返回在矩阵主对角线上的元素和副对角线上且不在主对角线上元素的和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp; 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/14/sample_1911.png\" style=\"height:174px; width:336px\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[<strong>1</strong>,2,<strong>3</strong>],\n&nbsp;           [4,<strong>5</strong>,6],\n&nbsp;           [<strong>7</strong>,8,<strong>9</strong>]]\n<strong>输出：</strong>25\n<strong>解释：</strong>对角线的和为：1 + 5 + 9 + 3 + 7 = 25\n请注意，元素 mat[1][1] = 5 只会被计算一次。\n</pre>\n\n<p><strong>示例&nbsp; 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[<strong>1</strong>,1,1,<strong>1</strong>],\n&nbsp;           [1,<strong>1</strong>,<strong>1</strong>,1],\n&nbsp;           [1,<strong>1</strong>,<strong>1</strong>,1],\n&nbsp;           [<strong>1</strong>,1,1,<strong>1</strong>]]\n<strong>输出：</strong>8\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[<strong>5</strong>]]\n<strong>输出：</strong>5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == mat.length == mat[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= mat[i][j] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1573.分割字符串的方案数",
        "hardRate": "MEDIUM",
        "passRate": "31.21%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-split-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-split-a-string/solution",
        "problemsDesc": "<p>给你一个二进制串&nbsp;<code>s</code>&nbsp; （一个只包含 0 和 1 的字符串），我们可以将 <code>s</code>&nbsp;分割成 3 个 <strong>非空</strong>&nbsp;字符串 s1, s2, s3 （s1 + s2 + s3 = s）。</p>\n\n<p>请你返回分割&nbsp;<code>s</code>&nbsp;的方案数，满足 s1，s2 和 s3 中字符 &#39;1&#39; 的数目相同。</p>\n\n<p>由于答案可能很大，请将它对 10^9 + 7 取余后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;10101&quot;\n<strong>输出：</strong>4\n<strong>解释：</strong>总共有 4 种方法将 s 分割成含有 &#39;1&#39; 数目相同的三个子字符串。\n&quot;1|010|1&quot;\n&quot;1|01|01&quot;\n&quot;10|10|1&quot;\n&quot;10|1|01&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1001&quot;\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;0000&quot;\n<strong>输出：</strong>3\n<strong>解释：</strong>总共有 3 种分割 s 的方法。\n&quot;0|0|00&quot;\n&quot;0|00|0&quot;\n&quot;00|0|0&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;100100010100110&quot;\n<strong>输出：</strong>12\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s[i] == &#39;0&#39;</code>&nbsp;或者&nbsp;<code>s[i] == &#39;1&#39;</code></li>\n\t<li><code>3 &lt;= s.length &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1574.删除最短的子数组使剩余数组有序",
        "hardRate": "MEDIUM",
        "passRate": "43.20%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code>&nbsp;，请你删除一个子数组（可以为空），使得 <code>arr</code>&nbsp;中剩下的元素是 <strong>非递减</strong> 的。</p>\n\n<p>一个子数组指的是原数组中连续的一个子序列。</p>\n\n<p>请你返回满足题目要求的最短子数组的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,10,4,2,3,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>我们需要删除的最短子数组是 [10,4,2] ，长度为 3 。剩余元素形成非递减数组 [1,2,3,3,5] 。\n另一个正确的解为删除子数组 [3,10,4] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [5,4,3,2,1]\n<strong>输出：</strong>4\n<strong>解释：</strong>由于数组是严格递减的，我们只能保留一个元素。所以我们需要删除长度为 4 的子数组，要么删除 [5,4,3,2]，要么删除 [4,3,2,1]。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3]\n<strong>输出：</strong>0\n<strong>解释：</strong>数组已经是非递减的了，我们不需要删除任何元素。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1575.统计所有可行路径",
        "hardRate": "HARD",
        "passRate": "57.35%",
        "problemsUrl": "https://leetcode.cn/problems/count-all-possible-routes/",
        "solutionsUrl": "https://leetcode.cn/problems/count-all-possible-routes/solution",
        "problemsDesc": "<p>给你一个 <strong>互不相同</strong>&nbsp;的整数数组，其中&nbsp;<code>locations[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个城市的位置。同时给你&nbsp;<code>start</code>，<code>finish</code>&nbsp;和&nbsp;<code>fuel</code>&nbsp;分别表示出发城市、目的地城市和你初始拥有的汽油总量</p>\n\n<p>每一步中，如果你在城市 <code>i</code>&nbsp;，你可以选择任意一个城市 <code>j</code>&nbsp;，满足 &nbsp;<code>j != i</code>&nbsp;且&nbsp;<code>0 &lt;= j &lt; locations.length</code>&nbsp;，并移动到城市&nbsp;<code>j</code>&nbsp;。从城市&nbsp;<code>i</code>&nbsp;移动到&nbsp;<code>j</code>&nbsp;消耗的汽油量为&nbsp;<code>|locations[i] - locations[j]|</code>，<code>|x|</code>&nbsp;表示&nbsp;<code>x</code>&nbsp;的绝对值。</p>\n\n<p>请注意，&nbsp;<code>fuel</code>&nbsp;任何时刻都&nbsp;<strong>不能</strong>&nbsp;为负，且你&nbsp;<strong>可以</strong>&nbsp;经过任意城市超过一次（包括&nbsp;<code>start</code>&nbsp;和&nbsp;<code>finish</code>&nbsp;）。</p>\n\n<p>请你返回从<em>&nbsp;</em><code>start</code>&nbsp;到&nbsp;<code>finish</code>&nbsp;所有可能路径的数目。</p>\n\n<p>由于答案可能很大， 请将它对&nbsp;<code>10^9 + 7</code>&nbsp;取余后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5\n<strong>输出：</strong>4\n<strong>解释：</strong>以下为所有可能路径，每一条都用了 5 单位的汽油：\n1 -&gt; 3\n1 -&gt; 2 -&gt; 3\n1 -&gt; 4 -&gt; 3\n1 -&gt; 4 -&gt; 2 -&gt; 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>locations = [4,3,1], start = 1, finish = 0, fuel = 6\n<strong>输出：</strong>5\n<strong>解释：</strong>以下为所有可能的路径：\n1 -&gt; 0，使用汽油量为 fuel = 1\n1 -&gt; 2 -&gt; 0，使用汽油量为 fuel = 5\n1 -&gt; 2 -&gt; 1 -&gt; 0，使用汽油量为 fuel = 5\n1 -&gt; 0 -&gt; 1 -&gt; 0，使用汽油量为 fuel = 3\n1 -&gt; 0 -&gt; 1 -&gt; 0 -&gt; 1 -&gt; 0，使用汽油量为 fuel = 5\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>locations = [5,2,1], start = 0, finish = 2, fuel = 3\n<strong>输出：</strong>0\n<strong>解释：</strong>没有办法只用 3 单位的汽油从 0 到达 2 。因为最短路径需要 4 单位的汽油。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= locations.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= locations[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>所有&nbsp;<code>locations</code>&nbsp;中的整数 <strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>0 &lt;= start, finish &lt;&nbsp;locations.length</code></li>\n\t<li><code>1 &lt;= fuel &lt;= 200</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1576.替换所有的问号",
        "hardRate": "EASY",
        "passRate": "50.93%",
        "problemsUrl": "https://leetcode.cn/problems/replace-all-s-to-avoid-consecutive-repeating-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/replace-all-s-to-avoid-consecutive-repeating-characters/solution",
        "problemsDesc": "<p>给你一个仅包含小写英文字母和 <code>'?'</code> 字符的字符串 <code>s</code>，请你将所有的 <code>'?'</code> 转换为若干小写字母，使最终的字符串不包含任何 <strong>连续重复</strong> 的字符。</p>\n\n<p>注意：你 <strong>不能</strong> 修改非 <code>'?'</code> 字符。</p>\n\n<p>题目测试用例保证 <strong>除</strong> <code>'?'</code> 字符 <strong>之外</strong>，不存在连续重复的字符。</p>\n\n<p>在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"?zs\"\n<strong>输出：</strong>\"azs\"\n<strong>解释：</strong>该示例共有 25 种解决方案，从 \"azs\" 到 \"yzs\" 都是符合题目要求的。只有 \"z\" 是无效的修改，因为字符串 \"zzs\" 中有连续重复的两个 'z' 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ubv?w\"\n<strong>输出：</strong>\"ubvaw\"\n<strong>解释：</strong>该示例共有 24 种解决方案，只有替换成 \"v\" 和 \"w\" 不符合题目要求。因为 \"ubvvw\" 和 \"ubvww\" 都包含连续重复的字符。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>\n\t<p><code>1 &lt;= s.length&nbsp;&lt;= 100</code></p>\n\t</li>\n\t<li>\n\t<p><code>s</code> 仅包含小写英文字母和 <code>'?'</code> 字符</p>\n\t</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1577.数的平方等于两数乘积的方法数",
        "hardRate": "MEDIUM",
        "passRate": "34.62%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/solution",
        "problemsDesc": "<p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，请你返回根据以下规则形成的三元组的数目（类型 1 和类型 2 ）：</p>\n\n<ul>\n\t<li>类型 1：三元组 <code>(i, j, k)</code> ，如果 <code>nums1[i]<sup>2</sup>&nbsp;== nums2[j] * nums2[k]</code> 其中 <code>0 &lt;= i &lt; nums1.length</code> 且 <code>0 &lt;= j &lt; k &lt; nums2.length</code></li>\n\t<li>类型 2：三元组 <code>(i, j, k)</code> ，如果 <code>nums2[i]<sup>2</sup>&nbsp;== nums1[j] * nums1[k]</code> 其中 <code>0 &lt;= i &lt; nums2.length</code> 且 <code>0 &lt;= j &lt; k &lt; nums1.length</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [7,4], nums2 = [5,2,8,9]\n<strong>输出：</strong>1\n<strong>解释：</strong>类型 1：(1,1,2), nums1[1]^2 = nums2[1] * nums2[2] (4^2 = 2 * 8)</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [1,1], nums2 = [1,1,1]\n<strong>输出：</strong>9\n<strong>解释：</strong>所有三元组都符合题目要求，因为 1^2 = 1 * 1\n类型 1：(0,0,1), (0,0,2), (0,1,2), (1,0,1), (1,0,2), (1,1,2), nums1[i]^2 = nums2[j] * nums2[k]\n类型 2：(0,0,1), (1,0,1), (2,0,1), nums2[i]^2 = nums1[j] * nums1[k]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [7,7,8,3], nums2 = [1,2,9,7]\n<strong>输出：</strong>2\n<strong>解释：</strong>有两个符合题目要求的三元组\n类型 1：(3,0,2), nums1[3]^2 = nums2[0] * nums2[2]\n类型 2：(3,0,1), nums2[3]^2 = nums1[0] * nums1[1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [4,7,9,11,23], nums2 = [3,5,1024,12,18]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在符合题目要求的三元组\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1578.使绳子变成彩色的最短时间",
        "hardRate": "MEDIUM",
        "passRate": "59.65%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-make-rope-colorful/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-make-rope-colorful/solution",
        "problemsDesc": "<p>Alice 把 <code>n</code> 个气球排列在一根绳子上。给你一个下标从 <strong>0</strong> 开始的字符串 <code>colors</code> ，其中 <code>colors[i]</code> 是第 <code>i</code> 个气球的颜色。</p>\n\n<p>Alice 想要把绳子装扮成 <strong>彩色</strong> ，且她不希望两个连续的气球涂着相同的颜色，所以她喊来 Bob 帮忙。Bob 可以从绳子上移除一些气球使绳子变成 <strong>彩色</strong> 。给你一个下标从 <strong>0</strong> 开始的整数数组 <code>neededTime</code> ，其中 <code>neededTime[i]</code> 是 Bob 从绳子上移除第 <code>i</code> 个气球需要的时间（以秒为单位）。</p>\n\n<p>返回 Bob 使绳子变成 <strong>彩色</strong> 需要的 <strong>最少时间</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/13/ballon1.jpg\" style=\"width: 404px; height: 243px;\" />\n<pre>\n<strong>输入：</strong>colors = \"abaac\", neededTime = [1,2,3,4,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>在上图中，'a' 是蓝色，'b' 是红色且 'c' 是绿色。\nBob 可以移除下标 2 的蓝色气球。这将花费 3 秒。\n移除后，不存在两个连续的气球涂着相同的颜色。总时间 = 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/13/balloon2.jpg\" style=\"width: 244px; height: 243px;\" />\n<pre>\n<strong>输入：</strong>colors = \"abc\", neededTime = [1,2,3]\n<strong>输出：</strong>0\n<strong>解释：</strong>绳子已经是彩色的，Bob 不需要从绳子上移除任何气球。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/13/balloon3.jpg\" style=\"width: 404px; height: 243px;\" />\n<pre>\n<strong>输入：</strong>colors = \"aabaa\", neededTime = [1,2,3,4,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>Bob 会移除下标 0 和下标 4 处的气球。这两个气球各需要 1 秒来移除。\n移除后，不存在两个连续的气球涂着相同的颜色。总时间 = 1 + 1 = 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == colors.length == neededTime.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= neededTime[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>colors</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1579.保证图可完全遍历",
        "hardRate": "HARD",
        "passRate": "62.07%",
        "problemsUrl": "https://leetcode.cn/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/solution",
        "problemsDesc": "<p>Alice 和 Bob 共有一个无向图，其中包含 n 个节点和 3&nbsp; 种类型的边：</p>\n\n<ul>\n\t<li>类型 1：只能由 Alice 遍历。</li>\n\t<li>类型 2：只能由 Bob 遍历。</li>\n\t<li>类型 3：Alice 和 Bob 都可以遍历。</li>\n</ul>\n\n<p>给你一个数组 <code>edges</code> ，其中 <code>edges[i] = [type<sub>i</sub>, u<sub>i</sub>, v<sub>i</sub>]</code>&nbsp;表示节点 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code> 之间存在类型为 <code>type<sub>i</sub></code> 的双向边。请你在保证图仍能够被 Alice和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。</p>\n\n<p>返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/06/5510ex1.png\" style=\"height: 191px; width: 179px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]\n<strong>输出：</strong>2\n<strong>解释：</strong>如果删除<strong> </strong>[1,1,2] 和 [1,1,3] 这两条边，Alice 和 Bob 仍然可以完全遍历这个图。再删除任何其他的边都无法保证图可以完全遍历。所以可以删除的最大边数是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/06/5510ex2.png\" style=\"height: 190px; width: 178px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]\n<strong>输出：</strong>0\n<strong>解释：</strong>注意，删除任何一条边都会使 Alice 和 Bob 无法完全遍历这个图。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/06/5510ex3.png\" style=\"height: 190px; width: 178px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>在当前图中，Alice 无法从其他节点到达节点 4 。类似地，Bob 也不能达到节点 1 。因此，图无法完全遍历。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= min(10^5, 3 * n * (n-1) / 2)</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>1 &lt;= edges[i][0] &lt;= 3</code></li>\n\t<li><code>1 &lt;= edges[i][1] &lt; edges[i][2] &lt;= n</code></li>\n\t<li>所有元组 <code>(type<sub>i</sub>, u<sub>i</sub>, v<sub>i</sub>)</code> 互不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1580.把箱子放进仓库里 II",
        "hardRate": "MEDIUM",
        "passRate": "59.63%",
        "problemsUrl": "https://leetcode.cn/problems/put-boxes-into-the-warehouse-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/put-boxes-into-the-warehouse-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1581.进店却未进行过交易的顾客",
        "hardRate": "EASY",
        "passRate": "79.33%",
        "problemsUrl": "https://leetcode.cn/problems/customer-who-visited-but-did-not-make-any-transactions/",
        "solutionsUrl": "https://leetcode.cn/problems/customer-who-visited-but-did-not-make-any-transactions/solution",
        "problemsDesc": "<p>表：<code>Visits</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| visit_id    | int     |\n| customer_id | int     |\n+-------------+---------+\nvisit_id 是该表的主键。\n该表包含有关光临过购物中心的顾客的信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>表：<code>Transactions</code></p>\n\n<pre>\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| transaction_id | int     |\n| visit_id       | int     |\n| amount         | int     |\n+----------------+---------+\ntransaction_id 是此表的主键。\n此表包含 visit_id 期间进行的交易的信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>有一些顾客可能光顾了购物中心但没有进行交易。请你编写一个 SQL 查询，来查找这些顾客的 ID ，以及他们只光顾不交易的次数。</p>\n\n<p>返回以 <strong>任何顺序</strong> 排序的结果表。</p>\n\n<p>查询结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<code><strong>输入:</strong>\nVisits</code>\n+----------+-------------+\n| visit_id | customer_id |\n+----------+-------------+\n| 1        | 23          |\n| 2        | 9           |\n| 4        | 30          |\n| 5        | 54          |\n| 6        | 96          |\n| 7        | 54          |\n| 8        | 54          |\n+----------+-------------+\n<code>Transactions</code>\n+----------------+----------+--------+\n| transaction_id | visit_id | amount |\n+----------------+----------+--------+\n| 2              | 5        | 310    |\n| 3              | 5        | 300    |\n| 9              | 5        | 200    |\n| 12             | 1        | 910    |\n| 13             | 2        | 970    |\n+----------------+----------+--------+\n<b>输出:</b>\n+-------------+----------------+\n| customer_id | count_no_trans |\n+-------------+----------------+\n| 54          | 2              |\n| 30          | 1              |\n| 96          | 1              |\n+-------------+----------------+\n<b>解释:</b>\nID = 23 的顾客曾经逛过一次购物中心，并在 ID = 12 的访问期间进行了一笔交易。\nID = 9 的顾客曾经逛过一次购物中心，并在 ID = 13 的访问期间进行了一笔交易。\nID = 30 的顾客曾经去过购物中心，并且没有进行任何交易。\nID = 54 的顾客三度造访了购物中心。在 2 次访问中，他们没有进行任何交易，在 1 次访问中，他们进行了 3 次交易。\nID = 96 的顾客曾经去过购物中心，并且没有进行任何交易。\n如我们所见，ID 为 30 和 96 的顾客一次没有进行任何交易就去了购物中心。顾客 54 也两次访问了购物中心并且没有进行任何交易。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1582.二进制矩阵中的特殊位置",
        "hardRate": "EASY",
        "passRate": "69.48%",
        "problemsUrl": "https://leetcode.cn/problems/special-positions-in-a-binary-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/special-positions-in-a-binary-matrix/solution",
        "problemsDesc": "<p>给你一个大小为 <code>rows x cols</code> 的矩阵 <code>mat</code>，其中 <code>mat[i][j]</code> 是 <code>0</code> 或 <code>1</code>，请返回 <strong>矩阵&nbsp;<em><code>mat</code></em> 中特殊位置的数目</strong> 。</p>\n\n<p><strong>特殊位置</strong> 定义：如果 <code>mat[i][j] == 1</code> 并且第 <code>i</code> 行和第 <code>j</code> 列中的所有其他元素均为 <code>0</code>（行和列的下标均 <strong>从 0 开始</strong> ），则位置 <code>(i, j)</code> 被称为特殊位置。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[1,0,0],\n&nbsp;           [0,0,<strong>1</strong>],\n&nbsp;           [1,0,0]]\n<strong>输出：</strong>1\n<strong>解释：</strong>(1,2) 是一个特殊位置，因为 mat[1][2] == 1 且所处的行和列上所有其他元素都是 0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[<strong>1</strong>,0,0],\n&nbsp;           [0,<strong>1</strong>,0],\n&nbsp;           [0,0,<strong>1</strong>]]\n<strong>输出：</strong>3\n<strong>解释：</strong>(0,0), (1,1) 和 (2,2) 都是特殊位置\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[0,0,0,<strong>1</strong>],\n&nbsp;           [<strong>1</strong>,0,0,0],\n&nbsp;           [0,1,1,0],\n&nbsp;           [0,0,0,0]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[0,0,0,0,0],\n&nbsp;           [<strong>1</strong>,0,0,0,0],\n&nbsp;           [0,<strong>1</strong>,0,0,0],\n&nbsp;           [0,0,<strong>1</strong>,0,0],\n&nbsp;           [0,0,0,1,1]]\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rows == mat.length</code></li>\n\t<li><code>cols == mat[i].length</code></li>\n\t<li><code>1 &lt;= rows, cols &lt;= 100</code></li>\n\t<li><code>mat[i][j]</code> 是 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1583.统计不开心的朋友",
        "hardRate": "MEDIUM",
        "passRate": "67.92%",
        "problemsUrl": "https://leetcode.cn/problems/count-unhappy-friends/",
        "solutionsUrl": "https://leetcode.cn/problems/count-unhappy-friends/solution",
        "problemsDesc": "<p>给你一份 <code>n</code> 位朋友的亲近程度列表，其中 <code>n</code> 总是 <strong>偶数</strong> 。</p>\n\n<p>对每位朋友 <code>i</code>，<code>preferences[i]</code> 包含一份 <strong>按亲近程度从高</strong><strong>到低排列</strong> 的朋友列表。换句话说，排在列表前面的朋友与 <code>i</code> 的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以 <code>0</code> 到 <code>n-1</code> 之间的整数表示。</p>\n\n<p>所有的朋友被分成几对，配对情况以列表 <code>pairs</code> 给出，其中 <code>pairs[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示 <code>x<sub>i</sub></code> 与 <code>y<sub>i</sub></code> 配对，且 <code>y<sub>i</sub></code> 与 <code>x<sub>i</sub></code> 配对。</p>\n\n<p>但是，这样的配对情况可能会使其中部分朋友感到不开心。在 <code>x</code> 与 <code>y</code> 配对且 <code>u</code> 与 <code>v</code> 配对的情况下，如果同时满足下述两个条件，<code>x</code> 就会不开心：</p>\n\n<ul>\n\t<li><code>x</code> 与 <code>u</code> 的亲近程度胜过 <code>x</code> 与 <code>y</code>，且</li>\n\t<li><code>u</code> 与 <code>x</code> 的亲近程度胜过 <code>u</code> 与 <code>v</code></li>\n</ul>\n\n<p>返回 <strong>不开心的朋友的数目</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n朋友 1 不开心，因为：\n- <strong>1 与 0 </strong>配对，但 <strong>1 与 3</strong> 的亲近程度比 <strong>1 与 0</strong> 高，且\n- <strong>3 与 1</strong> 的亲近程度比 <strong>3 与 2</strong> 高。\n朋友 3 不开心，因为：\n- 3 与 2 配对，但 <strong>3 与 1</strong> 的亲近程度比 <strong>3 与 2</strong> 高，且\n- <strong>1 与 3</strong> 的亲近程度比 <strong>1 与 0</strong> 高。\n朋友 0 和 2 都是开心的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, preferences = [[1], [0]], pairs = [[1, 0]]\n<strong>输出：</strong>0\n<strong>解释：</strong>朋友 0 和 1 都开心。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]]\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 500</code></li>\n\t<li><code>n</code> 是偶数</li>\n\t<li><code>preferences.length&nbsp;== n</code></li>\n\t<li><code>preferences[i].length&nbsp;== n - 1</code></li>\n\t<li><code>0 &lt;= preferences[i][j] &lt;= n - 1</code></li>\n\t<li><code>preferences[i]</code> 不包含 <code>i</code></li>\n\t<li><code>preferences[i]</code> 中的所有值都是独一无二的</li>\n\t<li><code>pairs.length&nbsp;== n/2</code></li>\n\t<li><code>pairs[i].length&nbsp;== 2</code></li>\n\t<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= n - 1</code></li>\n\t<li>每位朋友都 <strong>恰好</strong> 被包含在一对中</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1584.连接所有点的最小费用",
        "hardRate": "MEDIUM",
        "passRate": "65.57%",
        "problemsUrl": "https://leetcode.cn/problems/min-cost-to-connect-all-points/",
        "solutionsUrl": "https://leetcode.cn/problems/min-cost-to-connect-all-points/solution",
        "problemsDesc": "<p>给你一个<code>points</code>&nbsp;数组，表示 2D 平面上的一些点，其中&nbsp;<code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;。</p>\n\n<p>连接点&nbsp;<code>[x<sub>i</sub>, y<sub>i</sub>]</code> 和点&nbsp;<code>[x<sub>j</sub>, y<sub>j</sub>]</code>&nbsp;的费用为它们之间的 <strong>曼哈顿距离</strong>&nbsp;：<code>|x<sub>i</sub> - x<sub>j</sub>| + |y<sub>i</sub> - y<sub>j</sub>|</code>&nbsp;，其中&nbsp;<code>|val|</code>&nbsp;表示&nbsp;<code>val</code>&nbsp;的绝对值。</p>\n\n<p>请你返回将所有点连接的最小总费用。只有任意两点之间 <strong>有且仅有</strong>&nbsp;一条简单路径时，才认为所有点都已连接。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/26/d.png\" style=\"height:268px; width:214px; background:#e5e5e5\" /></p>\n\n<pre>\n<strong>输入：</strong>points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\n<strong>输出：</strong>20\n<strong>解释：\n</strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/26/c.png\" style=\"height:268px; width:214px; background:#e5e5e5\" />\n我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。\n注意到任意两个点之间只有唯一一条路径互相到达。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[3,12],[-2,5],[-4,1]]\n<strong>输出：</strong>18\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[0,0],[1,1],[1,0],[-1,1]]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[-1000000,-1000000],[1000000,1000000]]\n<strong>输出：</strong>4000000\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[0,0]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= points.length &lt;= 1000</code></li>\n\t<li><code>-10<sup>6</sup>&nbsp;&lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n\t<li>所有点&nbsp;<code>(x<sub>i</sub>, y<sub>i</sub>)</code>&nbsp;两两不同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1585.检查字符串是否可以通过排序子字符串得到另一个字符串",
        "hardRate": "HARD",
        "passRate": "43.45%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-string-is-transformable-with-substring-sort-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-string-is-transformable-with-substring-sort-operations/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>s</code> 和&nbsp;<code>t</code>&nbsp;，请你通过若干次以下操作将字符串&nbsp;<code>s</code>&nbsp;转化成字符串&nbsp;<code>t</code>&nbsp;：</p>\n\n<ul>\n\t<li>选择 <code>s</code>&nbsp;中一个 <strong>非空</strong>&nbsp;子字符串并将它包含的字符就地 <strong>升序</strong>&nbsp;排序。</li>\n</ul>\n\n<p>比方说，对下划线所示的子字符串进行操作可以由&nbsp;<code>&quot;1<strong>4234</strong>&quot;</code>&nbsp;得到&nbsp;<code>&quot;1<strong>2344</strong>&quot;</code>&nbsp;。</p>\n\n<p>如果可以将字符串 <code>s</code>&nbsp;变成 <code>t</code>&nbsp;，返回 <code>true</code>&nbsp;。否则，返回 <code>false</code>&nbsp;。</p>\n\n<p>一个 <strong>子字符串</strong>&nbsp;定义为一个字符串中连续的若干字符。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;84532&quot;, t = &quot;34852&quot;\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以按以下操作将 s 转变为 t ：\n&quot;84<strong>53</strong>2&quot; （从下标 2 到下标 3）-&gt; &quot;84<strong>35</strong>2&quot;\n&quot;<strong>843</strong>52&quot; （从下标 0 到下标 2） -&gt; &quot;<strong>348</strong>52&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;34521&quot;, t = &quot;23415&quot;\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以按以下操作将 s 转变为 t ：\n&quot;<strong>3452</strong>1&quot; -&gt; &quot;<strong>2345</strong>1&quot;\n&quot;234<strong>51</strong>&quot; -&gt; &quot;234<strong>15</strong>&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;12345&quot;, t = &quot;12435&quot;\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;1&quot;, t = &quot;2&quot;\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s.length == t.length</code></li>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 和&nbsp;<code>t</code>&nbsp;都只包含数字字符，即&nbsp;<code>&#39;0&#39;</code>&nbsp;到&nbsp;<code>&#39;9&#39;</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1586.二叉搜索树迭代器 II",
        "hardRate": "MEDIUM",
        "passRate": "63.05%",
        "problemsUrl": "https://leetcode.cn/problems/binary-search-tree-iterator-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-search-tree-iterator-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1587.银行账户概要 II",
        "hardRate": "EASY",
        "passRate": "80.07%",
        "problemsUrl": "https://leetcode.cn/problems/bank-account-summary-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/bank-account-summary-ii/solution",
        "problemsDesc": "<p>表: <code>Users</code></p>\n\n<pre>+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| account      | int     |\n| name         | varchar |\n+--------------+---------+\naccount 是该表的主键.\n表中的每一行包含银行里中每一个用户的账号.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>表: <code>Transactions</code></p>\n\n<pre>+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| trans_id      | int     |\n| account       | int     |\n| amount        | int     |\n| transacted_on | date    |\n+---------------+---------+\ntrans_id 是该表主键.\n该表的每一行包含了所有账户的交易改变情况.\n如果用户收到了钱, 那么金额是正的; 如果用户转了钱, 那么金额是负的.\n所有账户的起始余额为 0.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一个 SQL,&nbsp;&nbsp;报告余额高于 10000 的所有用户的名字和余额.&nbsp;账户的余额等于包含该账户的所有交易的总和.</p>\n\n<p>返回结果表单没有顺序要求.</p>\n\n<p>查询结果格式如下例所示.</p>\n\n<p>&nbsp;</p>\n\n<pre><code>Users</code> table:\n+------------+--------------+\n| account    | name         |\n+------------+--------------+\n| 900001     | Alice        |\n| 900002     | Bob          |\n| 900003     | Charlie      |\n+------------+--------------+\n\n<code>Transactions</code> table:\n+------------+------------+------------+---------------+\n| trans_id   | account    | amount     | transacted_on |\n+------------+------------+------------+---------------+\n| 1          | 900001     | 7000       |  2020-08-01   |\n| 2          | 900001     | 7000       |  2020-09-01   |\n| 3          | 900001     | -3000      |  2020-09-02   |\n| 4          | 900002     | 1000       |  2020-09-12   |\n| 5          | 900003     | 6000       |  2020-08-07   |\n| 6          | 900003     | 6000       |  2020-09-07   |\n| 7          | 900003     | -4000      |  2020-09-11   |\n+------------+------------+------------+---------------+\n\nResult table:\n+------------+------------+\n| <code>name    </code>   | <code>balance  </code>  |\n+------------+------------+\n| Alice      | 11000      |\n+------------+------------+\nAlice 的余额为(7000 + 7000 - 3000) = 11000.\nBob 的余额为1000.\nCharlie 的余额为(6000 + 6000 - 4000) = 8000.\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1588.所有奇数长度子数组的和",
        "hardRate": "EASY",
        "passRate": "83.22%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-all-odd-length-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-all-odd-length-subarrays/solution",
        "problemsDesc": "<p>给你一个正整数数组&nbsp;<code>arr</code>&nbsp;，请你计算所有可能的奇数长度子数组的和。</p>\n\n<p><strong>子数组</strong> 定义为原数组中的一个连续子序列。</p>\n\n<p>请你返回 <code>arr</code>&nbsp;中 <strong>所有奇数长度子数组的和</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,4,2,5,3]\n<strong>输出：</strong>58\n<strong>解释：</strong>所有奇数长度子数组和它们的和为：\n[1] = 1\n[4] = 4\n[2] = 2\n[5] = 5\n[3] = 3\n[1,4,2] = 7\n[4,2,5] = 11\n[2,5,3] = 10\n[1,4,2,5,3] = 15\n我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2]\n<strong>输出：</strong>3\n<strong>解释：</strong>总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [10,11,12]\n<strong>输出：</strong>66\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<p>你可以设计一个 O(n) 时间复杂度的算法解决此问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1589.所有排列中的最大和",
        "hardRate": "MEDIUM",
        "passRate": "32.39%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-obtained-of-any-permutation/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-obtained-of-any-permutation/solution",
        "problemsDesc": "<p>有一个整数数组&nbsp;<code>nums</code>&nbsp;，和一个查询数组&nbsp;<code>requests</code>&nbsp;，其中&nbsp;<code>requests[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>&nbsp;。第&nbsp;<code>i</code>&nbsp;个查询求&nbsp;<code>nums[start<sub>i</sub>] + nums[start<sub>i</sub> + 1] + ... + nums[end<sub>i</sub> - 1] + nums[end<sub>i</sub>]</code>&nbsp;的结果&nbsp;，<code>start<sub>i</sub></code> 和&nbsp;<code>end<sub>i</sub></code>&nbsp;数组索引都是 <strong>从 0 开始</strong> 的。</p>\n\n<p>你可以任意排列 <code>nums</code>&nbsp;中的数字，请你返回所有查询结果之和的最大值。</p>\n\n<p>由于答案可能会很大，请你将它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,5], requests = [[1,3],[0,1]]\n<strong>输出：</strong>19\n<strong>解释：</strong>一个可行的 nums 排列为 [2,1,3,4,5]，并有如下结果：\nrequests[0] -&gt; nums[1] + nums[2] + nums[3] = 1 + 3 + 4 = 8\nrequests[1] -&gt; nums[0] + nums[1] = 2 + 1 = 3\n总和为：8 + 3 = 11。\n一个总和更大的排列为 [3,5,4,2,1]，并有如下结果：\nrequests[0] -&gt; nums[1] + nums[2] + nums[3] = 5 + 4 + 2 = 11\nrequests[1] -&gt; nums[0] + nums[1] = 3 + 5  = 8\n总和为： 11 + 8 = 19，这个方案是所有排列中查询之和最大的结果。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,5,6], requests = [[0,1]]\n<strong>输出：</strong>11\n<strong>解释：</strong>一个总和最大的排列为 [6,5,4,3,2,1] ，查询和为 [11]。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,5,10], requests = [[0,2],[1,3],[1,1]]\n<strong>输出：</strong>47\n<strong>解释：</strong>一个和最大的排列为 [4,10,5,3,2,1] ，查询结果分别为 [19,18,10]。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i]&nbsp;&lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= requests.length &lt;=&nbsp;10<sup>5</sup></code></li>\n\t<li><code>requests[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub>&nbsp;&lt;= end<sub>i</sub>&nbsp;&lt;&nbsp;n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1590.使数组和能被 P 整除",
        "hardRate": "MEDIUM",
        "passRate": "36.38%",
        "problemsUrl": "https://leetcode.cn/problems/make-sum-divisible-by-p/",
        "solutionsUrl": "https://leetcode.cn/problems/make-sum-divisible-by-p/solution",
        "problemsDesc": "<p>给你一个正整数数组&nbsp;<code>nums</code>，请你移除 <strong>最短</strong>&nbsp;子数组（可以为 <strong>空</strong>），使得剩余元素的 <strong>和</strong>&nbsp;能被 <code>p</code>&nbsp;整除。 <strong>不允许</strong>&nbsp;将整个数组都移除。</p>\n\n<p>请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 <code>-1</code>&nbsp;。</p>\n\n<p><strong>子数组</strong>&nbsp;定义为原数组中连续的一组元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,1,4,2], p = 6\n<strong>输出：</strong>1\n<strong>解释：</strong>nums 中元素和为 10，不能被 p 整除。我们可以移除子数组 [4] ，剩余元素的和为 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [6,3,5,2], p = 9\n<strong>输出：</strong>2\n<strong>解释：</strong>我们无法移除任何一个元素使得和被 9 整除，最优方案是移除子数组 [5,2] ，剩余元素为 [6,3]，和为 9 。\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3], p = 3\n<strong>输出：</strong>0\n<strong>解释：</strong>和恰好为 6 ，已经能被 3 整除了。所以我们不需要移除任何元素。\n</pre>\n\n<p><strong>示例&nbsp; 4：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3], p = 7\n<strong>输出：</strong>-1\n<strong>解释：</strong>没有任何方案使得移除子数组后剩余元素的和被 7 整除。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1000000000,1000000000,1000000000], p = 3\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= p &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1591.奇怪的打印机 II",
        "hardRate": "HARD",
        "passRate": "63.76%",
        "problemsUrl": "https://leetcode.cn/problems/strange-printer-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/strange-printer-ii/solution",
        "problemsDesc": "<p>给你一个奇怪的打印机，它有如下两个特殊的打印规则：</p>\n\n<ul>\n\t<li>每一次操作时，打印机会用同一种颜色打印一个矩形的形状，每次打印会覆盖矩形对应格子里原本的颜色。</li>\n\t<li>一旦矩形根据上面的规则使用了一种颜色，那么 <strong>相同的颜色不能再被使用&nbsp;</strong>。</li>\n</ul>\n\n<p>给你一个初始没有颜色的&nbsp;<code>m x n</code>&nbsp;的矩形&nbsp;<code>targetGrid</code>&nbsp;，其中&nbsp;<code>targetGrid[row][col]</code>&nbsp;是位置&nbsp;<code>(row, col)</code>&nbsp;的颜色。</p>\n\n<p>如果你能按照上述规则打印出矩形<em>&nbsp;</em><code>targetGrid</code>&nbsp;，请你返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/19/sample_1_1929.png\" style=\"height: 138px; width: 483px;\"></p>\n\n<pre><strong>输入：</strong>targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/19/sample_2_1929.png\" style=\"height: 290px; width: 483px;\"></p>\n\n<pre><strong>输入：</strong>targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>targetGrid = [[1,2,1],[2,1,2],[1,2,1]]\n<strong>输出：</strong>false\n<strong>解释：</strong>没有办法得到 targetGrid ，因为每一轮操作使用的颜色互不相同。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>targetGrid = [[1,1,1],[3,1,3]]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == targetGrid.length</code></li>\n\t<li><code>n == targetGrid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 60</code></li>\n\t<li><code>1 &lt;= targetGrid[row][col] &lt;= 60</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1592.重新排列单词间的空格",
        "hardRate": "EASY",
        "passRate": "46.71%",
        "problemsUrl": "https://leetcode.cn/problems/rearrange-spaces-between-words/",
        "solutionsUrl": "https://leetcode.cn/problems/rearrange-spaces-between-words/solution",
        "problemsDesc": "<p>给你一个字符串 <code>text</code> ，该字符串由若干被空格包围的单词组成。每个单词由一个或者多个小写英文字母组成，并且两个单词之间至少存在一个空格。题目测试用例保证 <code>text</code> <strong>至少包含一个单词</strong> 。</p>\n\n<p>请你重新排列空格，使每对相邻单词之间的空格数目都 <strong>相等</strong> ，并尽可能 <strong>最大化</strong> 该数目。如果不能重新平均分配所有空格，请 <strong>将多余的空格放置在字符串末尾</strong> ，这也意味着返回的字符串应当与原 <code>text</code> 字符串的长度相等。</p>\n\n<p>返回 <strong>重新排列空格后的字符串</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;  this   is  a sentence &quot;\n<strong>输出：</strong>&quot;this   is   a   sentence&quot;\n<strong>解释：</strong>总共有 9 个空格和 4 个单词。可以将 9 个空格平均分配到相邻单词之间，相邻单词间空格数为：9 / (4-1) = 3 个。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot; practice   makes   perfect&quot;\n<strong>输出：</strong>&quot;practice   makes   perfect &quot;\n<strong>解释：</strong>总共有 7 个空格和 3 个单词。7 / (3-1) = 3 个空格加上 1 个多余的空格。多余的空格需要放在字符串的末尾。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;hello   world&quot;\n<strong>输出：</strong>&quot;hello   world&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;  walks  udp package   into  bar a&quot;\n<strong>输出：</strong>&quot;walks  udp  package  into  bar  a &quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;a&quot;\n<strong>输出：</strong>&quot;a&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 100</code></li>\n\t<li><code>text</code> 由小写英文字母和 <code>&#39; &#39;</code> 组成</li>\n\t<li><code>text</code> 中至少包含一个单词</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1593.拆分字符串使唯一子字符串的数目最大",
        "hardRate": "MEDIUM",
        "passRate": "57.48%",
        "problemsUrl": "https://leetcode.cn/problems/split-a-string-into-the-max-number-of-unique-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/split-a-string-into-the-max-number-of-unique-substrings/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，请你拆分该字符串，并返回拆分后唯一子字符串的最大数目。</p>\n\n<p>字符串 <code>s</code> 拆分后可以得到若干 <strong>非空子字符串</strong> ，这些子字符串连接后应当能够还原为原字符串。但是拆分出来的每个子字符串都必须是 <strong>唯一的</strong> 。</p>\n\n<p>注意：<strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;ababccc&quot;\n<strong>输出：</strong>5\n<strong>解释：</strong>一种最大拆分方法为 [&#39;a&#39;, &#39;b&#39;, &#39;ab&#39;, &#39;c&#39;, &#39;cc&#39;] 。像 [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;cc&#39;] 这样拆分不满足题目要求，因为其中的 &#39;a&#39; 和 &#39;b&#39; 都出现了不止一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aba&quot;\n<strong>输出：</strong>2\n<strong>解释：</strong>一种最大拆分方法为 [&#39;a&#39;, &#39;ba&#39;] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aa&quot;\n<strong>输出：</strong>1\n<strong>解释：</strong>无法进一步拆分字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>\n\t<p><code>1 &lt;= s.length&nbsp;&lt;= 16</code></p>\n\t</li>\n\t<li>\n\t<p><code>s</code> 仅包含小写英文字母</p>\n\t</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1594.矩阵的最大非负积",
        "hardRate": "MEDIUM",
        "passRate": "33.78%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-non-negative-product-in-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-non-negative-product-in-a-matrix/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的矩阵 <code>grid</code> 。最初，你位于左上角 <code>(0, 0)</code> ，每一步，你可以在矩阵中 <strong>向右</strong> 或 <strong>向下</strong> 移动。</p>\n\n<p>在从左上角 <code>(0, 0)</code> 开始到右下角 <code>(m - 1, n - 1)</code> 结束的所有路径中，找出具有 <strong>最大非负积</strong> 的路径。路径的积是沿路径访问的单元格中所有整数的乘积。</p>\n\n<p>返回 <strong>最大非负积 </strong>对<strong><em> </em><code>10<sup>9</sup>&nbsp;+ 7</code></strong> <strong>取余</strong> 的结果。如果最大积为 <strong>负数</strong> ，则返回<em> </em><code>-1</code> 。</p>\n\n<p><strong>注意，</strong>取余是在得到最大积之后执行的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/23/product1.jpg\" style=\"width: 244px; height: 245px;\" />\n<pre>\n<strong>输入：</strong>grid = [[-1,-2,-3],[-2,-3,-3],[-3,-3,-2]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>从 (0, 0) 到 (2, 2) 的路径中无法得到非负积，所以返回 -1 。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/23/product2.jpg\" style=\"width: 244px; height: 245px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,-2,1],[1,-2,1],[3,-4,1]]\n<strong>输出：</strong>8\n<strong>解释：</strong>最大非负积对应的路径如图所示 (1 * 1 * -2 * -4 * 1 = 8)\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/23/product3.jpg\" style=\"width: 164px; height: 165px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,3],[0,-4]]\n<strong>输出：</strong>0\n<strong>解释：</strong>最大非负积对应的路径如图所示 (1 * 0 * -4 = 0)\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 15</code></li>\n\t<li><code>-4 &lt;= grid[i][j] &lt;= 4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1595.连通两组点的最小成本",
        "hardRate": "HARD",
        "passRate": "65.76%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-connect-two-groups-of-points/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-connect-two-groups-of-points/solution",
        "problemsDesc": "<p>给你两组点，其中第一组中有 <code>size<sub>1</sub></code> 个点，第二组中有 <code>size<sub>2</sub></code> 个点，且 <code>size<sub>1</sub> &gt;= size<sub>2</sub></code> 。</p>\n\n<p>任意两点间的连接成本 <code>cost</code> 由大小为 <code>size<sub>1</sub> x size<sub>2</sub></code> 矩阵给出，其中 <code>cost[i][j]</code> 是第一组中的点 <code>i</code> 和第二组中的点 <code>j</code> 的连接成本。<strong>如果两个组中的每个点都与另一组中的一个或多个点连接，则称这两组点是连通的。</strong>换言之，第一组中的每个点必须至少与第二组中的一个点连接，且第二组中的每个点必须至少与第一组中的一个点连接。</p>\n\n<p>返回连通两组点所需的最小成本。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/20/ex1.jpg\" style=\"height: 243px; width: 322px;\"></p>\n\n<pre><strong>输入：</strong>cost = [[15, 96], [36, 2]]\n<strong>输出：</strong>17\n<strong>解释：</strong>连通两组点的最佳方法是：\n1--A\n2--B\n总成本为 17 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/20/ex2.jpg\" style=\"height: 403px; width: 322px;\"></p>\n\n<pre><strong>输入：</strong>cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]]\n<strong>输出：</strong>4\n<strong>解释：</strong>连通两组点的最佳方法是：\n1--A\n2--B\n2--C\n3--A\n最小成本为 4 。\n请注意，虽然有多个点连接到第一组中的点 2 和第二组中的点 A ，但由于题目并不限制连接点的数目，所以只需要关心最低总成本。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]\n<strong>输出：</strong>10\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>size<sub>1</sub> == cost.length</code></li>\n\t<li><code>size<sub>2</sub> == cost[i].length</code></li>\n\t<li><code>1 &lt;= size<sub>1</sub>, size<sub>2</sub> &lt;= 12</code></li>\n\t<li><code>size<sub>1</sub> &gt;=&nbsp;size<sub>2</sub></code></li>\n\t<li><code>0 &lt;= cost[i][j] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1596.每位顾客最经常订购的商品",
        "hardRate": "MEDIUM",
        "passRate": "73.43%",
        "problemsUrl": "https://leetcode.cn/problems/the-most-frequently-ordered-products-for-each-customer/",
        "solutionsUrl": "https://leetcode.cn/problems/the-most-frequently-ordered-products-for-each-customer/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1597.根据中缀表达式构造二叉表达式树",
        "hardRate": "HARD",
        "passRate": "68.36%",
        "problemsUrl": "https://leetcode.cn/problems/build-binary-expression-tree-from-infix-expression/",
        "solutionsUrl": "https://leetcode.cn/problems/build-binary-expression-tree-from-infix-expression/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1598.文件夹操作日志搜集器",
        "hardRate": "EASY",
        "passRate": "69.53%",
        "problemsUrl": "https://leetcode.cn/problems/crawler-log-folder/",
        "solutionsUrl": "https://leetcode.cn/problems/crawler-log-folder/solution",
        "problemsDesc": "<p>每当用户执行变更文件夹操作时，LeetCode 文件系统都会保存一条日志记录。</p>\n\n<p>下面给出对变更操作的说明：</p>\n\n<ul>\n\t<li><code>&quot;../&quot;</code> ：移动到当前文件夹的父文件夹。如果已经在主文件夹下，则 <strong>继续停留在当前文件夹</strong> 。</li>\n\t<li><code>&quot;./&quot;</code> ：继续停留在当前文件夹<strong>。</strong></li>\n\t<li><code>&quot;x/&quot;</code> ：移动到名为 <code>x</code> 的子文件夹中。题目数据 <strong>保证总是存在文件夹 <code>x</code></strong> 。</li>\n</ul>\n\n<p>给你一个字符串列表 <code>logs</code> ，其中 <code>logs[i]</code> 是用户在 <code>i<sup>th</sup></code> 步执行的操作。</p>\n\n<p>文件系统启动时位于主文件夹，然后执行 <code>logs</code> 中的操作。</p>\n\n<p>执行完所有变更文件夹操作后，请你找出 <strong>返回主文件夹所需的最小步数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/26/sample_11_1957.png\" style=\"height: 151px; width: 775px;\"></p>\n\n<pre><strong>输入：</strong>logs = [&quot;d1/&quot;,&quot;d2/&quot;,&quot;../&quot;,&quot;d21/&quot;,&quot;./&quot;]\n<strong>输出：</strong>2\n<strong>解释：</strong>执行 &quot;../&quot; 操作变更文件夹 2 次，即可回到主文件夹\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/26/sample_22_1957.png\" style=\"height: 270px; width: 600px;\"></p>\n\n<pre><strong>输入：</strong>logs = [&quot;d1/&quot;,&quot;d2/&quot;,&quot;./&quot;,&quot;d3/&quot;,&quot;../&quot;,&quot;d31/&quot;]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>logs = [&quot;d1/&quot;,&quot;../&quot;,&quot;../&quot;,&quot;../&quot;]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= logs.length &lt;= 10<sup>3</sup></code></li>\n\t<li><code>2 &lt;= logs[i].length &lt;= 10</code></li>\n\t<li><code>logs[i]</code> 包含小写英文字母，数字，<code>&#39;.&#39;</code> 和 <code>&#39;/&#39;</code></li>\n\t<li><code>logs[i]</code> 符合语句中描述的格式</li>\n\t<li>文件夹名称由小写英文字母和数字组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1599.经营摩天轮的最大利润",
        "hardRate": "MEDIUM",
        "passRate": "51.47%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-profit-of-operating-a-centennial-wheel/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-profit-of-operating-a-centennial-wheel/solution",
        "problemsDesc": "<p>你正在经营一座摩天轮，该摩天轮共有 <strong>4 个座舱</strong> ，每个座舱<strong> 最多可以容纳 4 位游客</strong> 。你可以 <strong>逆时针</strong>&nbsp;轮转座舱，但每次轮转都需要支付一定的运行成本 <code>runningCost</code> 。摩天轮每次轮转都恰好转动 1 / 4 周。</p>\n\n<p>给你一个长度为 <code>n</code> 的数组 <code>customers</code> ， <code>customers[i]</code> 是在第 <code>i</code> 次轮转（下标从 0 开始）之前到达的新游客的数量。这也意味着你必须在新游客到来前轮转 <code>i</code> 次。每位游客在登上离地面最近的座舱前都会支付登舱成本 <code>boardingCost</code> ，一旦该座舱再次抵达地面，他们就会离开座舱结束游玩。</p>\n\n<p>你可以随时停下摩天轮，即便是 <strong>在服务所有游客之前</strong> 。如果你决定停止运营摩天轮，为了保证所有游客安全着陆，<strong>将免费进行</strong><strong>所有后续轮转</strong>&nbsp;。注意，如果有超过 4 位游客在等摩天轮，那么只有 4 位游客可以登上摩天轮，其余的需要等待 <strong>下一次轮转</strong> 。</p>\n\n<p>返回最大化利润所需执行的 <strong>最小轮转次数</strong> 。 如果不存在利润为正的方案，则返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/26/wheeldiagram12.png\" /></p>\n\n<pre>\n<strong>输入：</strong>customers = [8,3], boardingCost = 5, runningCost = 6\n<strong>输出：</strong>3\n<strong>解释：</strong>座舱上标注的数字是该座舱的当前游客数。\n1. 8 位游客抵达，4 位登舱，4 位等待下一舱，摩天轮轮转。当前利润为 4 * $5 - 1 * $6 = $14 。\n2. 3 位游客抵达，4 位在等待的游客登舱，其他 3 位等待，摩天轮轮转。当前利润为 8 * $5 - 2 * $6 = $28 。\n3. 最后 3 位游客登舱，摩天轮轮转。当前利润为 11 * $5 - 3 * $6 = $37 。\n轮转 3 次得到最大利润，最大利润为 $37 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>customers = [10,9,6], boardingCost = 6, runningCost = 4\n<strong>输出：</strong>7\n<strong>解释：</strong>\n1. 10 位游客抵达，4 位登舱，6 位等待下一舱，摩天轮轮转。当前利润为 4 * $6 - 1 * $4 = $20 。\n2. 9 位游客抵达，4 位登舱，11 位等待（2 位是先前就在等待的，9 位新加入等待的），摩天轮轮转。当前利润为 8 * $6 - 2 * $4 = $40 。\n3. 最后 6 位游客抵达，4 位登舱，13 位等待，摩天轮轮转。当前利润为 12 * $6 - 3 * $4 = $60 。\n4. 4 位登舱，9 位等待，摩天轮轮转。当前利润为 * $6 - 4 * $4 = $80 。\n5. 4 位登舱，5 位等待，摩天轮轮转。当前利润为 20 * $6 - 5 * $4 = $100 。\n6. 4 位登舱，1 位等待，摩天轮轮转。当前利润为 24 * $6 - 6 * $4 = $120 。\n7. 1 位登舱，摩天轮轮转。当前利润为 25 * $6 - 7 * $4 = $122 。\n轮转 7 次得到最大利润，最大利润为$122 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92\n<strong>输出：</strong>-1\n<strong>解释：</strong>\n1. 3 位游客抵达，3 位登舱，0 位等待，摩天轮轮转。当前利润为 3 * $1 - 1 * $92 = -$89 。\n2. 4 位游客抵达，4 位登舱，0 位等待，摩天轮轮转。当前利润为 is 7 * $1 - 2 * $92 = -$177 。\n3. 0 位游客抵达，0 位登舱，0 位等待，摩天轮轮转。当前利润为 7 * $1 - 3 * $92 = -$269 。\n4. 5 位游客抵达，4 位登舱，1 位等待，摩天轮轮转。当前利润为 12 * $1 - 4 * $92 = -$356 。\n5. 1 位游客抵达，2 位登舱，0 位等待，摩天轮轮转。当前利润为 13 * $1 - 5 * $92 = -$447 。\n利润永不为正，所以返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == customers.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= customers[i] &lt;= 50</code></li>\n\t<li><code>1 &lt;= boardingCost, runningCost &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1600.王位继承顺序",
        "hardRate": "MEDIUM",
        "passRate": "65.66%",
        "problemsUrl": "https://leetcode.cn/problems/throne-inheritance/",
        "solutionsUrl": "https://leetcode.cn/problems/throne-inheritance/solution",
        "problemsDesc": "<p>一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。</p>\n\n<p>这个王国有一个明确规定的王位继承顺序，第一继承人总是国王自己。我们定义递归函数&nbsp;<code>Successor(x, curOrder)</code>&nbsp;，给定一个人&nbsp;<code>x</code>&nbsp;和当前的继承顺序，该函数返回 <code>x</code>&nbsp;的下一继承人。</p>\n\n<pre>\nSuccessor(x, curOrder):\n    如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中：\n        如果 x 是国王，那么返回 null\n        否则，返回 Successor(x 的父亲, curOrder)\n    否则，返回 x 不在 curOrder 中最年长的孩子\n</pre>\n\n<p>比方说，假设王国由国王，他的孩子&nbsp;Alice 和 Bob （Alice 比 Bob&nbsp;年长）和 Alice 的孩子&nbsp;Jack 组成。</p>\n\n<ol>\n\t<li>一开始，&nbsp;<code>curOrder</code>&nbsp;为&nbsp;<code>[\"king\"]</code>.</li>\n\t<li>调用&nbsp;<code>Successor(king, curOrder)</code>&nbsp;，返回 Alice ，所以我们将 Alice 放入 <code>curOrder</code>&nbsp;中，得到&nbsp;<code>[\"king\", \"Alice\"]</code>&nbsp;。</li>\n\t<li>调用&nbsp;<code>Successor(Alice, curOrder)</code>&nbsp;，返回 Jack ，所以我们将 Jack 放入&nbsp;<code>curOrder</code>&nbsp;中，得到&nbsp;<code>[\"king\", \"Alice\", \"Jack\"]</code>&nbsp;。</li>\n\t<li>调用&nbsp;<code>Successor(Jack, curOrder)</code>&nbsp;，返回 Bob ，所以我们将 Bob 放入&nbsp;<code>curOrder</code>&nbsp;中，得到&nbsp;<code>[\"king\", \"Alice\", \"Jack\", \"Bob\"]</code>&nbsp;。</li>\n\t<li>调用&nbsp;<code>Successor(Bob, curOrder)</code>&nbsp;，返回&nbsp;<code>null</code>&nbsp;。最终得到继承顺序为&nbsp;<code>[\"king\", \"Alice\", \"Jack\", \"Bob\"]</code>&nbsp;。</li>\n</ol>\n\n<p>通过以上的函数，我们总是能得到一个唯一的继承顺序。</p>\n\n<p>请你实现&nbsp;<code>ThroneInheritance</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>ThroneInheritance(string kingName)</code> 初始化一个&nbsp;<code>ThroneInheritance</code>&nbsp;类的对象。国王的名字作为构造函数的参数传入。</li>\n\t<li><code>void birth(string parentName, string childName)</code>&nbsp;表示&nbsp;<code>parentName</code>&nbsp;新拥有了一个名为&nbsp;<code>childName</code>&nbsp;的孩子。</li>\n\t<li><code>void death(string name)</code>&nbsp;表示名为&nbsp;<code>name</code>&nbsp;的人死亡。一个人的死亡不会影响&nbsp;<code>Successor</code>&nbsp;函数，也不会影响当前的继承顺序。你可以只将这个人标记为死亡状态。</li>\n\t<li><code>string[] getInheritanceOrder()</code>&nbsp;返回 <strong>除去</strong>&nbsp;死亡人员的当前继承顺序列表。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"ThroneInheritance\", \"birth\", \"birth\", \"birth\", \"birth\", \"birth\", \"birth\", \"getInheritanceOrder\", \"death\", \"getInheritanceOrder\"]\n[[\"king\"], [\"king\", \"andy\"], [\"king\", \"bob\"], [\"king\", \"catherine\"], [\"andy\", \"matthew\"], [\"bob\", \"alex\"], [\"bob\", \"asha\"], [null], [\"bob\"], [null]]\n<strong>输出：</strong>\n[null, null, null, null, null, null, null, [\"king\", \"andy\", \"matthew\", \"bob\", \"alex\", \"asha\", \"catherine\"], null, [\"king\", \"andy\", \"matthew\", \"alex\", \"asha\", \"catherine\"]]\n\n<strong>解释：</strong>\nThroneInheritance t= new ThroneInheritance(\"king\"); // 继承顺序：<strong>king</strong>\nt.birth(\"king\", \"andy\"); // 继承顺序：king &gt; <strong>andy</strong>\nt.birth(\"king\", \"bob\"); // 继承顺序：king &gt; andy &gt; <strong>bob</strong>\nt.birth(\"king\", \"catherine\"); // 继承顺序：king &gt; andy &gt; bob &gt; <strong>catherine</strong>\nt.birth(\"andy\", \"matthew\"); // 继承顺序：king &gt; andy &gt; <strong>matthew</strong> &gt; bob &gt; catherine\nt.birth(\"bob\", \"alex\"); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; <strong>alex</strong> &gt; catherine\nt.birth(\"bob\", \"asha\"); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; alex &gt; <strong>asha</strong> &gt; catherine\nt.getInheritanceOrder(); // 返回 [\"king\", \"andy\", \"matthew\", \"bob\", \"alex\", \"asha\", \"catherine\"]\nt.death(\"bob\"); // 继承顺序：king &gt; andy &gt; matthew &gt; <strong>bob（已经去世）</strong>&gt; alex &gt; asha &gt; catherine\nt.getInheritanceOrder(); // 返回 [\"king\", \"andy\", \"matthew\", \"alex\", \"asha\", \"catherine\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= kingName.length, parentName.length, childName.length, name.length &lt;= 15</code></li>\n\t<li><code>kingName</code>，<code>parentName</code>，&nbsp;<code>childName</code>&nbsp;和&nbsp;<code>name</code>&nbsp;仅包含小写英文字母。</li>\n\t<li>所有的参数&nbsp;<code>childName</code> 和&nbsp;<code>kingName</code>&nbsp;<strong>互不相同</strong>。</li>\n\t<li>所有&nbsp;<code>death</code>&nbsp;函数中的死亡名字 <code>name</code>&nbsp;要么是国王，要么是已经出生了的人员名字。</li>\n\t<li>每次调用 <code>birth(parentName, childName)</code> 时，测试用例都保证 <code>parentName</code> 对应的人员是活着的。</li>\n\t<li>最多调用&nbsp;<code>10<sup>5</sup></code>&nbsp;次<code>birth</code> 和&nbsp;<code>death</code>&nbsp;。</li>\n\t<li>最多调用&nbsp;<code>10</code>&nbsp;次&nbsp;<code>getInheritanceOrder</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1601.最多可达成的换楼请求数目",
        "hardRate": "HARD",
        "passRate": "61.89%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-achievable-transfer-requests/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-achievable-transfer-requests/solution",
        "problemsDesc": "<p>我们有&nbsp;<code>n</code>&nbsp;栋楼，编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。每栋楼有若干员工。由于现在是换楼的季节，部分员工想要换一栋楼居住。</p>\n\n<p>给你一个数组 <code>requests</code>&nbsp;，其中&nbsp;<code>requests[i] = [from<sub>i</sub>, to<sub>i</sub>]</code>&nbsp;，表示一个员工请求从编号为&nbsp;<code>from<sub>i</sub></code>&nbsp;的楼搬到编号为&nbsp;<code>to<sub>i</sub></code><sub>&nbsp;</sub>的楼。</p>\n\n<p>一开始&nbsp;<strong>所有楼都是满的</strong>，所以从请求列表中选出的若干个请求是可行的需要满足 <strong>每栋楼员工净变化为 0&nbsp;</strong>。意思是每栋楼 <strong>离开</strong>&nbsp;的员工数目 <strong>等于</strong>&nbsp;该楼 <strong>搬入</strong>&nbsp;的员工数数目。比方说&nbsp;<code>n = 3</code>&nbsp;且两个员工要离开楼&nbsp;<code>0</code>&nbsp;，一个员工要离开楼&nbsp;<code>1</code>&nbsp;，一个员工要离开楼 <code>2</code>&nbsp;，如果该请求列表可行，应该要有两个员工搬入楼&nbsp;<code>0</code>&nbsp;，一个员工搬入楼&nbsp;<code>1</code>&nbsp;，一个员工搬入楼&nbsp;<code>2</code>&nbsp;。</p>\n\n<p>请你从原请求列表中选出若干个请求，使得它们是一个可行的请求列表，并返回所有可行列表中最大请求数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/26/move1.jpg\" style=\"height: 406px; width: 600px;\"></p>\n\n<pre><strong>输入：</strong>n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]\n<strong>输出：</strong>5\n<strong>解释：</strong>请求列表如下：\n从楼 0 离开的员工为 x 和 y ，且他们都想要搬到楼 1 。\n从楼 1 离开的员工为 a 和 b ，且他们分别想要搬到楼 2 和 0 。\n从楼 2 离开的员工为 z ，且他想要搬到楼 0 。\n从楼 3 离开的员工为 c ，且他想要搬到楼 4 。\n没有员工从楼 4 离开。\n我们可以让 x 和 b 交换他们的楼，以满足他们的请求。\n我们可以让 y，a 和 z 三人在三栋楼间交换位置，满足他们的要求。\n所以最多可以满足 5 个请求。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/26/move2.jpg\" style=\"height: 327px; width: 450px;\"></p>\n\n<pre><strong>输入：</strong>n = 3, requests = [[0,0],[1,2],[2,1]]\n<strong>输出：</strong>3\n<strong>解释：</strong>请求列表如下：\n从楼 0 离开的员工为 x ，且他想要回到原来的楼 0 。\n从楼 1 离开的员工为 y ，且他想要搬到楼 2 。\n从楼 2 离开的员工为 z ，且他想要搬到楼 1 。\n我们可以满足所有的请求。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>1 &lt;= requests.length &lt;= 16</code></li>\n\t<li><code>requests[i].length == 2</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1602.找到二叉树中最近的右侧节点",
        "hardRate": "MEDIUM",
        "passRate": "74.60%",
        "problemsUrl": "https://leetcode.cn/problems/find-nearest-right-node-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/find-nearest-right-node-in-binary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1603.设计停车系统",
        "hardRate": "EASY",
        "passRate": "83.77%",
        "problemsUrl": "https://leetcode.cn/problems/design-parking-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-parking-system/solution",
        "problemsDesc": "<p>请你给一个停车场设计一个停车系统。停车场总共有三种不同大小的车位：大，中和小，每种尺寸分别有固定数目的车位。</p>\n\n<p>请你实现 <code>ParkingSystem</code> 类：</p>\n\n<ul>\n\t<li><code>ParkingSystem(int big, int medium, int small)</code> 初始化 <code>ParkingSystem</code> 类，三个参数分别对应每种停车位的数目。</li>\n\t<li><code>bool addCar(int carType)</code> 检查是否有 <code>carType</code> 对应的停车位。 <code>carType</code> 有三种类型：大，中，小，分别用数字 <code>1</code>， <code>2</code> 和 <code>3</code> 表示。<strong>一辆车只能停在</strong> <strong> </strong><code>carType</code> 对应尺寸的停车位中。如果没有空车位，请返回 <code>false</code> ，否则将该车停入车位并返回 <code>true</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"ParkingSystem\", \"addCar\", \"addCar\", \"addCar\", \"addCar\"]\n[[1, 1, 0], [1], [2], [3], [1]]\n<strong>输出：</strong>\n[null, true, true, false, false]\n\n<strong>解释：</strong>\nParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);\nparkingSystem.addCar(1); // 返回 true ，因为有 1 个空的大车位\nparkingSystem.addCar(2); // 返回 true ，因为有 1 个空的中车位\nparkingSystem.addCar(3); // 返回 false ，因为没有空的小车位\nparkingSystem.addCar(1); // 返回 false ，因为没有空的大车位，唯一一个大车位已经被占据了\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= big, medium, small <= 1000</code></li>\n\t<li><code>carType</code> 取值为 <code>1</code>， <code>2</code> 或 <code>3</code></li>\n\t<li>最多会调用 <code>addCar</code> 函数 <code>1000</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1604.警告一小时内使用相同员工卡大于等于三次的人",
        "hardRate": "MEDIUM",
        "passRate": "50.38%",
        "problemsUrl": "https://leetcode.cn/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/",
        "solutionsUrl": "https://leetcode.cn/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/solution",
        "problemsDesc": "<p>力扣公司的员工都使用员工卡来开办公室的门。每当一个员工使用一次他的员工卡，安保系统会记录下员工的名字和使用时间。如果一个员工在一小时时间内使用员工卡的次数大于等于三次，这个系统会自动发布一个 <strong>警告</strong>&nbsp;。</p>\n\n<p>给你字符串数组&nbsp;<code>keyName</code>&nbsp;和&nbsp;<code>keyTime</code> ，其中&nbsp;<code>[keyName[i], keyTime[i]]</code>&nbsp;对应一个人的名字和他在&nbsp;<strong>某一天</strong> 内使用员工卡的时间。</p>\n\n<p>使用时间的格式是 <strong>24小时制</strong>&nbsp;，形如<strong>&nbsp;\"HH:MM\"</strong>&nbsp;，比方说&nbsp;<code>\"23:51\"</code> 和&nbsp;<code>\"09:49\"</code>&nbsp;。</p>\n\n<p>请你返回去重后的收到系统警告的员工名字，将它们按 <strong>字典序</strong><strong>升序&nbsp;</strong>排序后返回。</p>\n\n<p>请注意&nbsp;<code>\"10:00\"</code> - <code>\"11:00\"</code>&nbsp;视为一个小时时间范围内，而&nbsp;<code>\"22:51\"</code> - <code>\"23:52\"</code>&nbsp;不被视为一小时时间范围内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>keyName = [\"daniel\",\"daniel\",\"daniel\",\"luis\",\"luis\",\"luis\",\"luis\"], keyTime = [\"10:00\",\"10:40\",\"11:00\",\"09:00\",\"11:00\",\"13:00\",\"15:00\"]\n<strong>输出：</strong>[\"daniel\"]\n<strong>解释：</strong>\"daniel\" 在一小时内使用了 3 次员工卡（\"10:00\"，\"10:40\"，\"11:00\"）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>keyName = [\"alice\",\"alice\",\"alice\",\"bob\",\"bob\",\"bob\",\"bob\"], keyTime = [\"12:01\",\"12:00\",\"18:00\",\"21:00\",\"21:20\",\"21:30\",\"23:00\"]\n<strong>输出：</strong>[\"bob\"]\n<strong>解释：</strong>\"bob\" 在一小时内使用了 3 次员工卡（\"21:00\"，\"21:20\"，\"21:30\"）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= keyName.length, keyTime.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>keyName.length == keyTime.length</code></li>\n\t<li><code>keyTime</code> 格式为&nbsp;<strong>\"HH:MM\"&nbsp;</strong>。</li>\n\t<li>保证&nbsp;<code>[keyName[i], keyTime[i]]</code>&nbsp;形成的二元对&nbsp;<strong>互不相同&nbsp;</strong>。</li>\n\t<li><code>1 &lt;= keyName[i].length &lt;= 10</code></li>\n\t<li><code>keyName[i]</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1605.给定行和列的和求可行矩阵",
        "hardRate": "MEDIUM",
        "passRate": "80.86%",
        "problemsUrl": "https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/",
        "solutionsUrl": "https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/solution",
        "problemsDesc": "<p>给你两个非负整数数组&nbsp;<code>rowSum</code> 和&nbsp;<code>colSum</code>&nbsp;，其中&nbsp;<code>rowSum[i]</code>&nbsp;是二维矩阵中第 <code>i</code>&nbsp;行元素的和， <code>colSum[j]</code>&nbsp;是第 <code>j</code>&nbsp;列元素的和。换言之你不知道矩阵里的每个元素，但是你知道每一行和每一列的和。</p>\n\n<p>请找到大小为&nbsp;<code>rowSum.length x colSum.length</code>&nbsp;的任意 <strong>非负整数</strong>&nbsp;矩阵，且该矩阵满足&nbsp;<code>rowSum</code> 和&nbsp;<code>colSum</code>&nbsp;的要求。</p>\n\n<p>请你返回任意一个满足题目要求的二维矩阵，题目保证存在 <strong>至少一个</strong>&nbsp;可行矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rowSum = [3,8], colSum = [4,7]\n<strong>输出：</strong>[[3,0],\n      [1,7]]\n<strong>解释：</strong>\n第 0 行：3 + 0 = 3 == rowSum[0]\n第 1 行：1 + 7 = 8 == rowSum[1]\n第 0 列：3 + 1 = 4 == colSum[0]\n第 1 列：0 + 7 = 7 == colSum[1]\n行和列的和都满足题目要求，且所有矩阵元素都是非负的。\n另一个可行的矩阵为：[[1,2],\n                  [3,5]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rowSum = [5,7,10], colSum = [8,6,8]\n<strong>输出：</strong>[[0,5,0],\n      [6,1,0],\n      [2,0,8]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>rowSum = [14,9], colSum = [6,9,8]\n<strong>输出：</strong>[[0,9,5],\n      [6,0,3]]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>rowSum = [1,0], colSum = [1]\n<strong>输出：</strong>[[1],\n      [0]]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>rowSum = [0], colSum = [0]\n<strong>输出：</strong>[[0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rowSum.length, colSum.length &lt;= 500</code></li>\n\t<li><code>0 &lt;= rowSum[i], colSum[i] &lt;= 10<sup>8</sup></code></li>\n\t<li><code>sum(rowSum) == sum(colSum)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1606.找到处理最多请求的服务器",
        "hardRate": "HARD",
        "passRate": "48.42%",
        "problemsUrl": "https://leetcode.cn/problems/find-servers-that-handled-most-number-of-requests/",
        "solutionsUrl": "https://leetcode.cn/problems/find-servers-that-handled-most-number-of-requests/solution",
        "problemsDesc": "<p>你有 <code>k</code>&nbsp;个服务器，编号为 <code>0</code>&nbsp;到 <code>k-1</code>&nbsp;，它们可以同时处理多个请求组。每个服务器有无穷的计算能力但是 <strong>不能同时处理超过一个请求</strong>&nbsp;。请求分配到服务器的规则如下：</p>\n\n<ul>\n\t<li>第&nbsp;<code>i</code>&nbsp;（序号从 0 开始）个请求到达。</li>\n\t<li>如果所有服务器都已被占据，那么该请求被舍弃（完全不处理）。</li>\n\t<li>如果第&nbsp;<code>(i % k)</code>&nbsp;个服务器空闲，那么对应服务器会处理该请求。</li>\n\t<li>否则，将请求安排给下一个空闲的服务器（服务器构成一个环，必要的话可能从第 0 个服务器开始继续找下一个空闲的服务器）。比方说，如果第 <code>i</code>&nbsp;个服务器在忙，那么会查看第 <code>(i+1)</code>&nbsp;个服务器，第 <code>(i+2)</code>&nbsp;个服务器等等。</li>\n</ul>\n\n<p>给你一个 <strong>严格递增</strong>&nbsp;的正整数数组&nbsp;<code>arrival</code>&nbsp;，表示第&nbsp;<code>i</code>&nbsp;个任务的到达时间，和另一个数组&nbsp;<code>load</code>&nbsp;，其中&nbsp;<code>load[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个请求的工作量（也就是服务器完成它所需要的时间）。你的任务是找到 <strong>最繁忙的服务器</strong>&nbsp;。最繁忙定义为一个服务器处理的请求数是所有服务器里最多的。</p>\n\n<p>请你返回包含所有&nbsp;<strong>最繁忙服务器</strong>&nbsp;序号的列表，你可以以任意顺序返回这个列表。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/03/load-1.png\" style=\"height: 221px; width: 389px;\" /></p>\n\n<pre>\n<strong>输入：</strong>k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] \n<strong>输出：</strong>[1] \n<strong>解释：</strong>\n所有服务器一开始都是空闲的。\n前 3 个请求分别由前 3 台服务器依次处理。\n请求 3 进来的时候，服务器 0 被占据，所以它被安排到下一台空闲的服务器，也就是服务器 1 。\n请求 4 进来的时候，由于所有服务器都被占据，该请求被舍弃。\n服务器 0 和 2 分别都处理了一个请求，服务器 1 处理了两个请求。所以服务器 1 是最忙的服务器。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 3, arrival = [1,2,3,4], load = [1,2,1,2]\n<strong>输出：</strong>[0]\n<strong>解释：</strong>\n前 3 个请求分别被前 3 个服务器处理。\n请求 3 进来，由于服务器 0 空闲，它被服务器 0 处理。\n服务器 0 处理了两个请求，服务器 1 和 2 分别处理了一个请求。所以服务器 0 是最忙的服务器。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 3, arrival = [1,2,3], load = [10,12,11]\n<strong>输出：</strong>[0,1,2]\n<strong>解释：</strong>每个服务器分别处理了一个请求，所以它们都是最忙的服务器。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 3, arrival = [1,2,3,4,8,9,10], load = [5,2,10,3,1,2,2]\n<strong>输出：</strong>[1]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 1, arrival = [1], load = [1]\n<strong>输出：</strong>[0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arrival.length, load.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>arrival.length == load.length</code></li>\n\t<li><code>1 &lt;= arrival[i], load[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>arrival</code>&nbsp;保证 <strong>严格递增</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1607.没有卖出的卖家",
        "hardRate": "EASY",
        "passRate": "54.38%",
        "problemsUrl": "https://leetcode.cn/problems/sellers-with-no-sales/",
        "solutionsUrl": "https://leetcode.cn/problems/sellers-with-no-sales/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1608.特殊数组的特征值",
        "hardRate": "EASY",
        "passRate": "61.37%",
        "problemsUrl": "https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x/",
        "solutionsUrl": "https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x/solution",
        "problemsDesc": "<p>给你一个非负整数数组 <code>nums</code> 。如果存在一个数 <code>x</code> ，使得 <code>nums</code> 中恰好有 <code>x</code> 个元素 <strong>大于或者等于</strong> <code>x</code> ，那么就称 <code>nums</code> 是一个 <strong>特殊数组</strong> ，而 <code>x</code> 是该数组的 <strong>特征值</strong> 。</p>\n\n<p>注意： <code>x</code> <strong>不必</strong> 是 <code>nums</code> 的中的元素。</p>\n\n<p>如果数组 <code>nums</code> 是一个 <strong>特殊数组</strong> ，请返回它的特征值 <code>x</code> 。否则，返回<em> </em><code>-1</code> 。可以证明的是，如果 <code>nums</code> 是特殊数组，那么其特征值 <code>x</code> 是 <strong>唯一的</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,5]\n<strong>输出：</strong>2\n<strong>解释：</strong>有 2 个元素（3 和 5）大于或等于 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,0]\n<strong>输出：</strong>-1\n<strong>解释：</strong>没有满足题目要求的特殊数组，故而也不存在特征值 x 。\n如果 x = 0，应该有 0 个元素 &gt;= x，但实际有 2 个。\n如果 x = 1，应该有 1 个元素 &gt;= x，但实际有 0 个。\n如果 x = 2，应该有 2 个元素 &gt;= x，但实际有 0 个。\nx 不能取更大的值，因为 nums 中只有两个元素。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,4,3,0,4]\n<strong>输出：</strong>3\n<strong>解释：</strong>有 3 个元素大于或等于 3 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,6,7,7,0]\n<strong>输出：</strong>-1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1609.奇偶树",
        "hardRate": "MEDIUM",
        "passRate": "58.06%",
        "problemsUrl": "https://leetcode.cn/problems/even-odd-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/even-odd-tree/solution",
        "problemsDesc": "<p>如果一棵二叉树满足下述几个条件，则可以称为 <strong>奇偶树</strong> ：</p>\n\n<ul>\n\t<li>二叉树根节点所在层下标为 <code>0</code> ，根的子节点所在层下标为 <code>1</code> ，根的孙节点所在层下标为 <code>2</code> ，依此类推。</li>\n\t<li><strong>偶数下标</strong> 层上的所有节点的值都是 <strong>奇</strong> 整数，从左到右按顺序 <strong>严格递增</strong></li>\n\t<li><strong>奇数下标</strong> 层上的所有节点的值都是 <strong>偶</strong> 整数，从左到右按顺序 <strong>严格递减</strong></li>\n</ul>\n\n<p>给你二叉树的根节点，如果二叉树为 <strong>奇偶树 </strong>，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_1_1966.png\" style=\"height: 229px; width: 362px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,10,4,3,null,7,9,12,8,6,null,null,2]\n<strong>输出：</strong>true\n<strong>解释：</strong>每一层的节点值分别是：\n0 层：[1]\n1 层：[10,4]\n2 层：[3,7,9]\n3 层：[12,8,6,2]\n由于 0 层和 2 层上的节点值都是奇数且严格递增，而 1 层和 3 层上的节点值都是偶数且严格递减，因此这是一棵奇偶树。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_2_1966.png\" style=\"height: 167px; width: 363px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [5,4,2,3,3,7]\n<strong>输出：</strong>false\n<strong>解释：</strong>每一层的节点值分别是：\n0 层：[5]\n1 层：[4,2]\n2 层：[3,3,7]\n2 层上的节点值不满足严格递增的条件，所以这不是一棵奇偶树。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_1_333_1966.png\" style=\"height: 167px; width: 363px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,9,1,3,5,7]\n<strong>输出：</strong>false\n<strong>解释：</strong>1 层上的节点值应为偶数。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [11,8,6,1,3,9,11,30,20,18,16,12,10,4,2,17]\n<strong>输出：</strong>true\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 <= Node.val <= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1610.可见点的最大数目",
        "hardRate": "HARD",
        "passRate": "44.39%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-visible-points/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-visible-points/solution",
        "problemsDesc": "<p>给你一个点数组 <code>points</code> 和一个表示角度的整数 <code>angle</code> ，你的位置是 <code>location</code> ，其中 <code>location = [pos<sub>x</sub>, pos<sub>y</sub>]</code> 且 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 都表示 X-Y 平面上的整数坐标。</p>\n\n<p>最开始，你面向东方进行观测。你 <strong>不能</strong> 进行移动改变位置，但可以通过 <strong>自转</strong> 调整观测角度。换句话说，<code>pos<sub>x</sub></code> 和 <code>pos<sub>y</sub></code> 不能改变。你的视野范围的角度用 <code>angle</code> 表示， 这决定了你观测任意方向时可以多宽。设 <code>d</code> 为你逆时针自转旋转的度数，那么你的视野就是角度范围 <code>[d - angle/2, d + angle/2]</code> 所指示的那片区域。</p>\n\n<video autoplay=\"\" controls=\"\" height=\"360\" muted=\"\" style=\"max-width:100%;height:auto;\" width=\"750\"><source src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/angle.mp4\" type=\"video/mp4\" />Your browser does not support the video tag or this video format.</video>\n\n<p>对于每个点，如果由该点、你的位置以及从你的位置直接向东的方向形成的角度 <strong>位于你的视野中</strong> ，那么你就可以看到它。</p>\n\n<p>同一个坐标上可以有多个点。你所在的位置也可能存在一些点，但不管你的怎么旋转，总是可以看到这些点。同时，点不会阻碍你看到其他点。</p>\n\n<p>返回你能看到的点的最大数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/89a07e9b-00ab-4967-976a-c723b2aa8656.png\" style=\"height: 300px; width: 400px;\" /></p>\n\n<pre>\n<strong>输入：</strong>points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>阴影区域代表你的视野。在你的视野中，所有的点都清晰可见，尽管 [2,2] 和 [3,3]在同一条直线上，你仍然可以看到 [3,3] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[2,1],[2,2],[3,4],[1,1]], angle = 90, location = [1,1]\n<strong>输出：</strong>4\n<strong>解释：</strong>在你的视野中，所有的点都清晰可见，包括你所在位置的那个点。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/5010bfd3-86e6-465f-ac64-e9df941d2e49.png\" style=\"height: 348px; width: 690px;\" /></p>\n\n<pre>\n<strong>输入：</strong>points = [[1,0],[2,1]], angle = 13, location = [1,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>如图所示，你只能看到两点之一。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= points.length <= 10<sup>5</sup></code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>location.length == 2</code></li>\n\t<li><code>0 <= angle < 360</code></li>\n\t<li><code>0 <= pos<sub>x</sub>, pos<sub>y</sub>, x<sub>i</sub>, y<sub>i</sub> <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1611.使整数变为 0 的最少操作次数",
        "hardRate": "HARD",
        "passRate": "61.15%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-one-bit-operations-to-make-integers-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-one-bit-operations-to-make-integers-zero/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code>，你需要重复执行多次下述操作将其转换为 <code>0</code> ：</p>\n\n<ul>\n\t<li>翻转 <code>n</code> 的二进制表示中最右侧位（第 <code>0</code> 位）。</li>\n\t<li>如果第 <code>(i-1)</code> 位为 <code>1</code> 且从第 <code>(i-2)</code> 位到第 <code>0</code> 位都为 <code>0</code>，则翻转 <code>n</code> 的二进制表示中的第 <code>i</code> 位。</li>\n</ul>\n\n<p>返回将 <code>n</code> 转换为 <code>0</code> 的最小操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>3 的二进制表示为 \"11\"\n\"<strong>1</strong>1\" -&gt; \"<strong>0</strong>1\" ，执行的是第 2 种操作，因为第 0 位为 1 。\n\"0<strong>1</strong>\" -&gt; \"0<strong>0</strong>\" ，执行的是第 1 种操作。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6\n<strong>输出：</strong>4\n<strong>解释：</strong>6 的二进制表示为 \"110\".\n\"<strong>1</strong>10\" -&gt; \"<strong>0</strong>10\" ，执行的是第 2 种操作，因为第 1 位为 1 ，第 0 到 0 位为 0 。\n\"01<strong>0</strong>\" -&gt; \"01<strong>1</strong>\" ，执行的是第 1 种操作。\n\"0<strong>1</strong>1\" -&gt; \"0<strong>0</strong>1\" ，执行的是第 2 种操作，因为第 0 位为 1 。\n\"00<strong>1</strong>\" -&gt; \"00<strong>0</strong>\" ，执行的是第 1 种操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1612.检查两棵二叉表达式树是否等价",
        "hardRate": "MEDIUM",
        "passRate": "74.44%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-two-expression-trees-are-equivalent/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-two-expression-trees-are-equivalent/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1613.找到遗失的ID",
        "hardRate": "MEDIUM",
        "passRate": "72.94%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-missing-ids/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-missing-ids/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1614.括号的最大嵌套深度",
        "hardRate": "EASY",
        "passRate": "82.31%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-nesting-depth-of-the-parentheses/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-nesting-depth-of-the-parentheses/solution",
        "problemsDesc": "<p>如果字符串满足以下条件之一，则可以称之为 <strong>有效括号字符串</strong><strong>（valid parentheses string</strong>，可以简写为 <strong>VPS</strong>）：</p>\n\n<ul>\n\t<li>字符串是一个空字符串 <code>\"\"</code>，或者是一个不为 <code>\"(\"</code> 或 <code>\")\"</code> 的单字符。</li>\n\t<li>字符串可以写为 <code>AB</code>（<code>A</code> 与 <code>B</code>&nbsp;字符串连接），其中 <code>A</code> 和 <code>B</code> 都是 <strong>有效括号字符串</strong> 。</li>\n\t<li>字符串可以写为 <code>(A)</code>，其中 <code>A</code> 是一个 <strong>有效括号字符串</strong> 。</li>\n</ul>\n\n<p>类似地，可以定义任何有效括号字符串&nbsp;<code>S</code> 的 <strong>嵌套深度</strong> <code>depth(S)</code>：</p>\n\n<ul>\n\t<li><code>depth(\"\") = 0</code></li>\n\t<li><code>depth(C) = 0</code>，其中 <code>C</code> 是单个字符的字符串，且该字符不是 <code>\"(\"</code> 或者 <code>\")\"</code></li>\n\t<li><code>depth(A + B) = max(depth(A), depth(B))</code>，其中 <code>A</code> 和 <code>B</code> 都是 <strong>有效括号字符串</strong></li>\n\t<li><code>depth(\"(\" + A + \")\") = 1 + depth(A)</code>，其中 <code>A</code> 是一个 <strong>有效括号字符串</strong></li>\n</ul>\n\n<p>例如：<code>\"\"</code>、<code>\"()()\"</code>、<code>\"()(()())\"</code> 都是 <strong>有效括号字符串</strong>（嵌套深度分别为 0、1、2），而 <code>\")(\"</code> 、<code>\"(()\"</code> 都不是 <strong>有效括号字符串</strong> 。</p>\n\n<p>给你一个 <strong>有效括号字符串</strong> <code>s</code>，返回该字符串的<em> </em><code>s</code> <strong>嵌套深度</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(1+(2*3)+((<strong>8</strong>)/4))+1\"\n<strong>输出：</strong>3\n<strong>解释：</strong>数字 8 在嵌套的 3 层括号中。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(1)+((2))+(((<strong>3</strong>)))\"\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 由数字 <code>0-9</code> 和字符 <code>'+'</code>、<code>'-'</code>、<code>'*'</code>、<code>'/'</code>、<code>'('</code>、<code>')'</code> 组成</li>\n\t<li>题目数据保证括号表达式 <code>s</code> 是 <strong>有效的括号表达式</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1615.最大网络秩",
        "hardRate": "MEDIUM",
        "passRate": "60.14%",
        "problemsUrl": "https://leetcode.cn/problems/maximal-network-rank/",
        "solutionsUrl": "https://leetcode.cn/problems/maximal-network-rank/solution",
        "problemsDesc": "<p><code>n</code> 座城市和一些连接这些城市的道路 <code>roads</code> 共同组成一个基础设施网络。每个 <code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 都表示在城市 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间有一条双向道路。</p>\n\n<p>两座不同城市构成的 <strong>城市对</strong> 的 <strong>网络秩</strong> 定义为：与这两座城市 <strong>直接</strong> 相连的道路总数。如果存在一条道路直接连接这两座城市，则这条道路只计算 <strong>一次</strong> 。</p>\n\n<p>整个基础设施网络的 <strong>最大网络秩</strong> 是所有不同城市对中的 <strong>最大网络秩</strong> 。</p>\n\n<p>给你整数 <code>n</code> 和数组 <code>roads</code>，返回整个基础设施网络的 <strong>最大网络秩</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/11/ex1.png\" style=\"width: 292px; height: 172px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, roads = [[0,1],[0,3],[1,2],[1,3]]\n<strong>输出：</strong>4\n<strong>解释：</strong>城市 0 和 1 的网络秩是 4，因为共有 4 条道路与城市 0 或 1 相连。位于 0 和 1 之间的道路只计算一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/11/ex2.png\" style=\"width: 292px; height: 172px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]]\n<strong>输出：</strong>5\n<strong>解释：</strong>共有 5 条道路与城市 1 或 2 相连。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]]\n<strong>输出：</strong>5\n<strong>解释：</strong>2 和 5 的网络秩为 5，注意并非所有的城市都需要连接起来。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 100</code></li>\n\t<li><code>0 <= roads.length <= n * (n - 1) / 2</code></li>\n\t<li><code>roads[i].length == 2</code></li>\n\t<li><code>0 <= a<sub>i</sub>, b<sub>i</sub> <= n-1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>每对城市之间 <strong>最多只有一条</strong> 道路相连</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1616.分割两个字符串得到回文串",
        "hardRate": "MEDIUM",
        "passRate": "37.53%",
        "problemsUrl": "https://leetcode.cn/problems/split-two-strings-to-make-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/split-two-strings-to-make-palindrome/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>a</code> 和&nbsp;<code>b</code>&nbsp;，它们长度相同。请你选择一个下标，将两个字符串都在&nbsp;<strong>相同的下标 </strong>分割开。由&nbsp;<code>a</code>&nbsp;可以得到两个字符串：&nbsp;<code>a<sub>prefix</sub></code>&nbsp;和&nbsp;<code>a<sub>suffix</sub></code>&nbsp;，满足&nbsp;<code>a = a<sub>prefix</sub> + a<sub>suffix</sub></code><sub>&nbsp;</sub>，同理，由&nbsp;<code>b</code> 可以得到两个字符串&nbsp;<code>b<sub>prefix</sub></code> 和&nbsp;<code>b<sub>suffix</sub></code>&nbsp;，满足&nbsp;<code>b = b<sub>prefix</sub> + b<sub>suffix</sub></code>&nbsp;。请你判断&nbsp;<code>a<sub>prefix</sub> + b<sub>suffix</sub></code> 或者&nbsp;<code>b<sub>prefix</sub> + a<sub>suffix</sub></code>&nbsp;能否构成回文串。</p>\n\n<p>当你将一个字符串&nbsp;<code>s</code>&nbsp;分割成&nbsp;<code>s<sub>prefix</sub></code> 和&nbsp;<code>s<sub>suffix</sub></code>&nbsp;时，&nbsp;<code>s<sub>suffix</sub></code> 或者&nbsp;<code>s<sub>prefix</sub></code> 可以为空。比方说，&nbsp;<code>s = \"abc\"</code>&nbsp;那么&nbsp;<code>\"\" + \"abc\"</code>&nbsp;，&nbsp;<code>\"a\" + \"bc\"&nbsp;</code>，&nbsp;<code>\"ab\" + \"c\"</code>&nbsp;和&nbsp;<code>\"abc\" + \"\"</code>&nbsp;都是合法分割。</p>\n\n<p>如果 <strong>能构成回文字符串</strong> ，那么请返回&nbsp;<code>true</code>，否则返回<em>&nbsp;</em><code>false</code>&nbsp;。</p>\n\n<p><strong>注意</strong>，&nbsp;<code>x + y</code>&nbsp;表示连接字符串&nbsp;<code>x</code> 和&nbsp;<code>y</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>a = \"x\", b = \"y\"\n<b>输出：</b>true\n<b>解释：</b>如果 a 或者 b 是回文串，那么答案一定为 true ，因为你可以如下分割：\na<sub>prefix</sub> = \"\", a<sub>suffix</sub> = \"x\"\nb<sub>prefix</sub> = \"\", b<sub>suffix</sub> = \"y\"\n那么 a<sub>prefix</sub> + b<sub>suffix</sub> = \"\" + \"y\" = \"y\" 是回文串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = \"abdef\", b = \"fecab\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>a = \"ulacfd\", b = \"jizalu\"\n<b>输出：</b>true\n<b>解释：</b>在下标为 3 处分割：\na<sub>prefix</sub> = \"ula\", a<sub>suffix</sub> = \"cfd\"\nb<sub>prefix</sub> = \"jiz\", b<sub>suffix</sub> = \"alu\"\n那么 a<sub>prefix</sub> + b<sub>suffix</sub> = \"ula\" + \"alu\" = \"ulaalu\" 是回文串。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>a.length == b.length</code></li>\n\t<li><code>a</code> 和&nbsp;<code>b</code>&nbsp;都只包含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1617.统计子树中城市之间最大距离",
        "hardRate": "HARD",
        "passRate": "79.18%",
        "problemsUrl": "https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/",
        "solutionsUrl": "https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/solution",
        "problemsDesc": "<p>给你 <code>n</code> 个城市，编号为从 <code>1</code> 到 <code>n</code> 。同时给你一个大小为 <code>n-1</code> 的数组 <code>edges</code> ，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> 表示城市 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code><sub> </sub>之间有一条双向边。题目保证任意城市之间只有唯一的一条路径。换句话说，所有城市形成了一棵 <strong>树</strong> 。</p>\n\n<p>一棵 <strong>子树</strong> 是城市的一个子集，且子集中任意城市之间可以通过子集中的其他城市和边到达。两个子树被认为不一样的条件是至少有一个城市在其中一棵子树中存在，但在另一棵子树中不存在。</p>\n\n<p>对于 <code>d</code> 从 <code>1</code> 到 <code>n-1</code> ，请你找到城市间 <strong>最大距离</strong> 恰好为 <code>d</code> 的所有子树数目。</p>\n\n<p>请你返回一个大小为 <code>n-1</code> 的数组，其中第<em> </em><code>d</code><em> </em>个元素（<strong>下标从 1 开始</strong>）是城市间 <strong>最大距离</strong> 恰好等于 <code>d</code> 的子树数目。</p>\n\n<p><strong>请注意</strong>，两个城市间距离定义为它们之间需要经过的边的数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/11/p1.png\" style=\"width: 161px; height: 181px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>n = 4, edges = [[1,2],[2,3],[2,4]]\n<b>输出：</b>[3,4,0]\n<strong>解释：\n</strong>子树 {1,2}, {2,3} 和 {2,4} 最大距离都是 1 。\n子树 {1,2,3}, {1,2,4}, {2,3,4} 和 {1,2,3,4} 最大距离都为 2 。\n不存在城市间最大距离为 3 的子树。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 2, edges = [[1,2]]\n<b>输出：</b>[1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, edges = [[1,2],[2,3]]\n<b>输出：</b>[2,1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 15</code></li>\n\t<li><code>edges.length == n-1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 <= u<sub>i</sub>, v<sub>i</sub> <= n</code></li>\n\t<li>题目保证 <code>(u<sub>i</sub>, v<sub>i</sub>)</code> 所表示的边互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1618.找出适应屏幕的最大字号",
        "hardRate": "MEDIUM",
        "passRate": "62.47%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-font-to-fit-a-sentence-in-a-screen/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-font-to-fit-a-sentence-in-a-screen/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1619.删除某些元素后的数组均值",
        "hardRate": "EASY",
        "passRate": "71.73%",
        "problemsUrl": "https://leetcode.cn/problems/mean-of-array-after-removing-some-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/mean-of-array-after-removing-some-elements/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> ，请你删除最小 <code>5%</code> 的数字和最大 <code>5%</code> 的数字后，剩余数字的平均值。</p>\n\n<p>与 <strong>标准答案</strong> 误差在 <code>10<sup>-5</sup></code> 的结果都被视为正确结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n<b>输出：</b>2.00000\n<b>解释：</b>删除数组中最大和最小的元素后，所有元素都等于 2，所以平均值为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n<b>输出：</b>4.00000\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n<b>输出：</b>4.77778\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n<b>输出：</b>5.27778\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n<b>输出：</b>5.29167\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>20 <= arr.length <= 1000</code></li>\n\t<li><code>arr.length</code><b> </b>是 <code>20</code> 的<strong> 倍数</strong> </li>\n\t<li><code>0 <= arr[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1620.网络信号最好的坐标",
        "hardRate": "MEDIUM",
        "passRate": "46.05%",
        "problemsUrl": "https://leetcode.cn/problems/coordinate-with-maximum-network-quality/",
        "solutionsUrl": "https://leetcode.cn/problems/coordinate-with-maximum-network-quality/solution",
        "problemsDesc": "<p>给你一个数组 <code>towers</code>&nbsp;和一个整数 <code>radius</code> 。</p>\n\n<p>数组&nbsp; <code>towers</code>&nbsp; 中包含一些网络信号塔，其中&nbsp;<code>towers[i] = [x<sub>i</sub>, y<sub>i</sub>, q<sub>i</sub>]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个网络信号塔的坐标是&nbsp;<code>(x<sub>i</sub>, y<sub>i</sub>)</code>&nbsp;且信号强度参数为&nbsp;<code>q<sub>i</sub></code><sub>&nbsp;</sub>。所有坐标都是在&nbsp; X-Y 坐标系内的&nbsp;<strong>整数</strong>&nbsp;坐标。两个坐标之间的距离用 <strong>欧几里得距离</strong>&nbsp;计算。</p>\n\n<p>整数&nbsp;<code>radius</code>&nbsp;表示一个塔 <strong>能到达&nbsp;</strong>的 <strong>最远距离</strong>&nbsp;。如果一个坐标跟塔的距离在 <code>radius</code>&nbsp;以内，那么该塔的信号可以到达该坐标。在这个范围以外信号会很微弱，所以 <code>radius</code>&nbsp;以外的距离该塔是 <strong>不能到达的</strong>&nbsp;。</p>\n\n<p>如果第 <code>i</code>&nbsp;个塔能到达 <code>(x, y)</code>&nbsp;，那么该塔在此处的信号为&nbsp;<code>⌊q<sub>i</sub> / (1 + d)⌋</code>&nbsp;，其中&nbsp;<code>d</code>&nbsp;是塔跟此坐标的距离。一个坐标的 <b>信号强度</b> 是所有 <strong>能到达&nbsp;</strong>该坐标的塔的信号强度之和。</p>\n\n<p>请你返回数组 <code>[c<sub>x</sub>, c<sub>y</sub>]</code> ，表示 <strong>信号强度</strong> 最大的 <strong>整数</strong> 坐标点&nbsp;<code>(c<sub>x</sub>, c<sub>y</sub>)</code> 。如果有多个坐标网络信号一样大，请你返回字典序最小的 <strong>非负</strong> 坐标。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>坐标&nbsp;<code>(x1, y1)</code>&nbsp;字典序比另一个坐标&nbsp;<code>(x2, y2)</code> 小，需满足以下条件之一：\n\n\t<ul>\n\t\t<li>要么&nbsp;<code>x1 &lt; x2</code>&nbsp;，</li>\n\t\t<li>要么&nbsp;<code>x1 == x2</code> 且&nbsp;<code>y1 &lt; y2</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n\t<li><code>⌊val⌋</code>&nbsp;表示小于等于&nbsp;<code>val</code>&nbsp;的最大整数（向下取整函数）。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/17/untitled-diagram.png\" style=\"width: 176px; height: 176px;\" />\n<pre>\n<b>输入：</b>towers = [[1,2,5],[2,1,7],[3,1,9]], radius = 2\n<b>输出：</b>[2,1]\n<strong>解释：</strong>\n坐标 (2, 1) 信号强度之和为 13\n- 塔 (2, 1) 强度参数为 7 ，在该点强度为 ⌊7 / (1 + sqrt(0)⌋ = ⌊7⌋ = 7\n- 塔 (1, 2) 强度参数为 5 ，在该点强度为 ⌊5 / (1 + sqrt(2)⌋ = ⌊2.07⌋ = 2\n- 塔 (3, 1) 强度参数为 9 ，在该点强度为 ⌊9 / (1 + sqrt(1)⌋ = ⌊4.5⌋ = 4\n没有别的坐标有更大的信号强度。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>towers = [[23,11,21]], radius = 9\n<b>输出：</b>[23,11]\n<strong>解释：</strong>由于仅存在一座信号塔，所以塔的位置信号强度最大。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>towers = [[1,2,13],[2,1,7],[0,1,9]], radius = 2\n<b>输出：</b>[1,2]\n<strong>解释：</strong>坐标 (1, 2) 的信号强度最大。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= towers.length &lt;= 50</code></li>\n\t<li><code>towers[i].length == 3</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>, q<sub>i</sub> &lt;= 50</code></li>\n\t<li><code>1 &lt;= radius &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1621.大小为 K 的不重叠线段的数目",
        "hardRate": "MEDIUM",
        "passRate": "48.03%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-sets-of-k-non-overlapping-line-segments/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-sets-of-k-non-overlapping-line-segments/solution",
        "problemsDesc": "<p>给你一维空间的 <code>n</code> 个点，其中第 <code>i</code> 个点（编号从 <code>0</code> 到 <code>n-1</code>）位于 <code>x = i</code> 处，请你找到 <strong>恰好</strong> <code>k</code> <strong>个不重叠</strong> 线段且每个线段至少覆盖两个点的方案数。线段的两个端点必须都是 <strong>整数坐标</strong> 。这 <code>k</code> 个线段不需要全部覆盖全部 <code>n</code> 个点，且它们的端点 <strong>可以 </strong>重合。</p>\n\n<p>请你返回 <code>k</code> 个不重叠线段的方案数。由于答案可能很大，请将结果对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/17/ex1.png\" style=\"width: 179px; height: 222px;\" />\n<pre>\n<b>输入：</b>n = 4, k = 2\n<b>输出：</b>5\n<strong>解释：\n</strong>如图所示，两个线段分别用红色和蓝色标出。\n上图展示了 5 种不同的方案 {(0,2),(2,3)}，{(0,1),(1,3)}，{(0,1),(2,3)}，{(1,2),(2,3)}，{(0,1),(1,2)} 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, k = 1\n<b>输出：</b>3\n<strong>解释：</strong>总共有 3 种不同的方案 {(0,1)}, {(0,2)}, {(1,2)} 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 30, k = 7\n<b>输出：</b>796297179\n<strong>解释：</strong>画 7 条线段的总方案数为 3796297200 种。将这个数对 10<sup>9</sup> + 7 取余得到 796297179 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5, k = 3\n<b>输出：</b>7\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, k = 2\n<b>输出：</b>1</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 1000</code></li>\n\t<li><code>1 <= k <= n-1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1622.奇妙序列",
        "hardRate": "HARD",
        "passRate": "17.29%",
        "problemsUrl": "https://leetcode.cn/problems/fancy-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/fancy-sequence/solution",
        "problemsDesc": "<p>请你实现三个 API <code>append</code>，<code>addAll</code> 和 <code>multAll</code> 来实现奇妙序列。</p>\n\n<p>请实现 <code>Fancy</code> 类 ：</p>\n\n<ul>\n\t<li><code>Fancy()</code> 初始化一个空序列对象。</li>\n\t<li><code>void append(val)</code> 将整数 <code>val</code> 添加在序列末尾。</li>\n\t<li><code>void addAll(inc)</code> 将所有序列中的现有数值都增加 <code>inc</code> 。</li>\n\t<li><code>void multAll(m)</code> 将序列中的所有现有数值都乘以整数 <code>m</code> 。</li>\n\t<li><code>int getIndex(idx)</code> 得到下标为 <code>idx</code> 处的数值（下标从 0 开始），并将结果对 <code>10<sup>9</sup> + 7</code> 取余。如果下标大于等于序列的长度，请返回 <code>-1</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"Fancy\", \"append\", \"addAll\", \"append\", \"multAll\", \"getIndex\", \"addAll\", \"append\", \"multAll\", \"getIndex\", \"getIndex\", \"getIndex\"]\n[[], [2], [3], [7], [2], [0], [3], [10], [2], [0], [1], [2]]\n<strong>输出：</strong>\n[null, null, null, null, null, 10, null, null, null, 26, 34, 20]\n\n<strong>解释：</strong>\nFancy fancy = new Fancy();\nfancy.append(2);   // 奇妙序列：[2]\nfancy.addAll(3);   // 奇妙序列：[2+3] -> [5]\nfancy.append(7);   // 奇妙序列：[5, 7]\nfancy.multAll(2);  // 奇妙序列：[5*2, 7*2] -> [10, 14]\nfancy.getIndex(0); // 返回 10\nfancy.addAll(3);   // 奇妙序列：[10+3, 14+3] -> [13, 17]\nfancy.append(10);  // 奇妙序列：[13, 17, 10]\nfancy.multAll(2);  // 奇妙序列：[13*2, 17*2, 10*2] -> [26, 34, 20]\nfancy.getIndex(0); // 返回 26\nfancy.getIndex(1); // 返回 34\nfancy.getIndex(2); // 返回 20\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= val, inc, m <= 100</code></li>\n\t<li><code>0 <= idx <= 10<sup>5</sup></code></li>\n\t<li>总共最多会有 <code>10<sup>5</sup></code> 次对 <code>append</code>，<code>addAll</code>，<code>multAll</code> 和 <code>getIndex</code> 的调用。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1623.三人国家代表队",
        "hardRate": "EASY",
        "passRate": "78.47%",
        "problemsUrl": "https://leetcode.cn/problems/all-valid-triplets-that-can-represent-a-country/",
        "solutionsUrl": "https://leetcode.cn/problems/all-valid-triplets-that-can-represent-a-country/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1624.两个相同字符之间的最长子字符串",
        "hardRate": "EASY",
        "passRate": "64.43%",
        "problemsUrl": "https://leetcode.cn/problems/largest-substring-between-two-equal-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-substring-between-two-equal-characters/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code>，请你返回 <strong>两个相同字符之间的最长子字符串的长度</strong> <em>，</em>计算长度时不含这两个字符。如果不存在这样的子字符串，返回 <code>-1</code> 。</p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"aa\"\n<strong>输出：</strong>0\n<strong>解释：</strong>最优的子字符串是两个 'a' 之间的空子字符串。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abca\"\n<strong>输出：</strong>2\n<strong>解释：</strong>最优的子字符串是 \"bc\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = \"cbzxy\"\n<strong>输出：</strong>-1\n<strong>解释：</strong>s 中不存在出现出现两次的字符，所以返回 -1 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = \"cabbac\"\n<strong>输出：</strong>4\n<strong>解释：</strong>最优的子字符串是 \"abba\" ，其他的非最优解包括 \"bb\" 和 \"\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 300</code></li>\n\t<li><code>s</code> 只含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1625.执行操作后字典序最小的字符串",
        "hardRate": "MEDIUM",
        "passRate": "66.73%",
        "problemsUrl": "https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 以及两个整数 <code>a</code> 和 <code>b</code> 。其中，字符串 <code>s</code> 的长度为偶数，且仅由数字 <code>0</code> 到 <code>9</code> 组成。</p>\n\n<p>你可以在 <code>s</code> 上按任意顺序多次执行下面两个操作之一：</p>\n\n<ul>\n\t<li>累加：将  <code>a</code> 加到 <code>s</code> 中所有下标为奇数的元素上（<strong>下标从 0 开始</strong>）。数字一旦超过 <code>9</code> 就会变成 <code>0</code>，如此循环往复。例如，<code>s = \"3456\"</code> 且 <code>a = 5</code>，则执行此操作后 <code>s</code> 变成 <code>\"3951\"</code>。</li>\n\t<li>轮转：将 <code>s</code> 向右轮转 <code>b</code> 位。例如，<code>s = \"3456\"</code> 且 <code>b = 1</code>，则执行此操作后 <code>s</code> 变成 <code>\"6345\"</code>。</li>\n</ul>\n\n<p>请你返回在 <code>s</code> 上执行上述操作任意次后可以得到的 <strong>字典序最小</strong> 的字符串。</p>\n\n<p>如果两个字符串长度相同，那么字符串 <code>a</code> 字典序比字符串 <code>b</code> 小可以这样定义：在 <code>a</code> 和 <code>b</code> 出现不同的第一个位置上，字符串 <code>a</code> 中的字符出现在字母表中的时间早于 <code>b</code> 中的对应字符。例如，<code>\"0158”</code> 字典序比 <code>\"0190\"</code> 小，因为不同的第一个位置是在第三个字符，显然 <code>'5'</code> 出现在 <code>'9'</code> 之前。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"5525\", a = 9, b = 2\n<strong>输出：</strong>\"2050\"\n<strong>解释：</strong>执行操作如下：\n初态：\"5525\"\n轮转：\"2555\"\n累加：\"2454\"\n累加：\"2353\"\n轮转：\"5323\"\n累加：\"5222\"\n累加：\"5121\"\n轮转：\"2151\"\n累加：\"2050\"​​​​​​​​​​​​\n无法获得字典序小于 \"2050\" 的字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"74\", a = 5, b = 1\n<strong>输出：</strong>\"24\"\n<strong>解释：</strong>执行操作如下：\n初态：\"74\"\n轮转：\"47\"\n累加：\"42\"\n轮转：\"24\"​​​​​​​​​​​​\n无法获得字典序小于 \"24\" 的字符串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0011\", a = 4, b = 2\n<strong>输出：</strong>\"0011\"\n<strong>解释：</strong>无法获得字典序小于 \"0011\" 的字符串。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"43987654\", a = 7, b = 3\n<strong>输出：</strong>\"00553311\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= s.length <= 100</code></li>\n\t<li><code>s.length</code> 是偶数</li>\n\t<li><code>s</code> 仅由数字 <code>0</code> 到 <code>9</code> 组成</li>\n\t<li><code>1 <= a <= 9</code></li>\n\t<li><code>1 <= b <= s.length - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1626.无矛盾的最佳球队",
        "hardRate": "MEDIUM",
        "passRate": "53.71%",
        "problemsUrl": "https://leetcode.cn/problems/best-team-with-no-conflicts/",
        "solutionsUrl": "https://leetcode.cn/problems/best-team-with-no-conflicts/solution",
        "problemsDesc": "<p>假设你是球队的经理。对于即将到来的锦标赛，你想组合一支总体得分最高的球队。球队的得分是球队中所有球员的分数 <strong>总和</strong> 。</p>\n\n<p>然而，球队中的矛盾会限制球员的发挥，所以必须选出一支 <strong>没有矛盾</strong> 的球队。如果一名年龄较小球员的分数 <strong>严格大于</strong> 一名年龄较大的球员，则存在矛盾。同龄球员之间不会发生矛盾。</p>\n\n<p>给你两个列表 <code>scores</code> 和 <code>ages</code>，其中每组 <code>scores[i]</code> 和 <code>ages[i]</code> 表示第 <code>i</code> 名球员的分数和年龄。请你返回 <strong>所有可能的无矛盾球队中得分最高那支的分数</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>scores = [1,3,5,10,15], ages = [1,2,3,4,5]\n<strong>输出：</strong>34\n<strong>解释：</strong>你可以选中所有球员。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>scores = [4,5,6,5], ages = [2,1,2,1]\n<strong>输出：</strong>16\n<strong>解释：</strong>最佳的选择是后 3 名球员。注意，你可以选中多个同龄球员。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>scores = [1,2,3,5], ages = [8,9,10,1]\n<strong>输出：</strong>6\n<strong>解释：</strong>最佳的选择是前 3 名球员。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= scores.length, ages.length &lt;= 1000</code></li>\n\t<li><code>scores.length == ages.length</code></li>\n\t<li><code>1 &lt;= scores[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= ages[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1627.带阈值的图连通性",
        "hardRate": "HARD",
        "passRate": "42.23%",
        "problemsUrl": "https://leetcode.cn/problems/graph-connectivity-with-threshold/",
        "solutionsUrl": "https://leetcode.cn/problems/graph-connectivity-with-threshold/solution",
        "problemsDesc": "<p>有 <code>n</code> 座城市，编号从 <code>1</code> 到 <code>n</code> 。编号为 <code>x</code> 和 <code>y</code> 的两座城市直接连通的前提是： <code>x</code> 和 <code>y</code> 的公因数中，至少有一个 <strong>严格大于</strong> 某个阈值 <code>threshold</code> 。更正式地说，如果存在整数 <code>z</code> ，且满足以下所有条件，则编号 <code>x</code> 和 <code>y</code> 的城市之间有一条道路：</p>\n\n<ul>\n\t<li><code>x % z == 0</code></li>\n\t<li><code>y % z == 0</code></li>\n\t<li><code>z > threshold</code></li>\n</ul>\n\n<p>给你两个整数 <code>n</code> 和 <code>threshold</code> ，以及一个待查询数组，请你判断每个查询<code> queries[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 指向的城市 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 是否连通（即，它们之间是否存在一条路径）。</p>\n\n<p>返回数组 <code>answer</code> ，其中<code>answer.length == queries.length</code> 。如果第 <code>i</code> 个查询中指向的城市 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 连通，则 <code>answer[i]</code> 为 <code>true</code> ；如果不连通，则 <code>answer[i]</code> 为 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/18/ex1.jpg\" style=\"width: 382px; height: 181px;\" /></p>\n\n<p> </p>\n\n<pre>\n<strong>输入：</strong>n = 6, threshold = 2, queries = [[1,4],[2,5],[3,6]]\n<strong>输出：</strong>[false,false,true]\n<strong>解释：</strong>每个数的因数如下：\n1:   1\n2:   1, 2\n3:   1, <strong>3</strong>\n4:   1, 2, <strong>4</strong>\n5:   1, <strong>5</strong>\n6:   1, 2, <strong>3</strong>, <strong>6</strong>\n所有大于阈值的的因数已经加粗标识，只有城市 3 和 6 共享公约数 3 ，因此结果是： \n[1,4]   1 与 4 不连通\n[2,5]   2 与 5 不连通\n[3,6]   3 与 6 连通，存在路径 3--6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/18/tmp.jpg\" style=\"width: 532px; height: 302px;\" /></p>\n\n<p> </p>\n\n<pre>\n<strong>输入：</strong>n = 6, threshold = 0, queries = [[4,5],[3,4],[3,2],[2,6],[1,3]]\n<strong>输出：</strong>[true,true,true,true,true]\n<strong>解释：</strong>每个数的因数与上一个例子相同。但是，由于阈值为 0 ，所有的因数都大于阈值。因为所有的数字共享公因数 1 ，所以所有的城市都互相连通。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/16/ex3.jpg\" style=\"width: 282px; height: 282px;\" /></p>\n\n<p> </p>\n\n<pre>\n<strong>输入：</strong>n = 5, threshold = 1, queries = [[4,5],[4,5],[3,2],[2,3],[3,4]]\n<strong>输出：</strong>[false,false,false,false,false]\n<strong>解释：</strong>只有城市 2 和 4 共享的公约数 2 严格大于阈值 1 ，所以只有这两座城市是连通的。\n注意，同一对节点 [x, y] 可以有多个查询，并且查询 [x，y] 等同于查询 [y，x] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 10<sup>4</sup></code></li>\n\t<li><code>0 <= threshold <= n</code></li>\n\t<li><code>1 <= queries.length <= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>1 <= a<sub>i</sub>, b<sub>i</sub> <= cities</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1628.设计带解析函数的表达式树",
        "hardRate": "MEDIUM",
        "passRate": "82.41%",
        "problemsUrl": "https://leetcode.cn/problems/design-an-expression-tree-with-evaluate-function/",
        "solutionsUrl": "https://leetcode.cn/problems/design-an-expression-tree-with-evaluate-function/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1629.按键持续时间最长的键",
        "hardRate": "EASY",
        "passRate": "55.86%",
        "problemsUrl": "https://leetcode.cn/problems/slowest-key/",
        "solutionsUrl": "https://leetcode.cn/problems/slowest-key/solution",
        "problemsDesc": "<p>LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 <code>n</code> 个），每次一个。</p>\n\n<p>给你一个长度为 <code>n</code> 的字符串 <code>keysPressed</code> ，其中 <code>keysPressed[i]</code> 表示测试序列中第 <code>i</code> 个被按下的键。<code>releaseTimes</code> 是一个升序排列的列表，其中 <code>releaseTimes[i]</code> 表示松开第 <code>i</code> 个键的时间。字符串和数组的 <strong>下标都从 0 开始</strong> 。第 <code>0</code> 个键在时间为 <code>0</code> 时被按下，接下来每个键都 <strong>恰好</strong> 在前一个键松开时被按下。</p>\n\n<p>测试人员想要找出按键 <strong>持续时间最长</strong> 的键。第 <code>i</code><sup> </sup>次按键的持续时间为 <code>releaseTimes[i] - releaseTimes[i - 1]</code> ，第 <code>0</code> 次按键的持续时间为 <code>releaseTimes[0]</code> 。</p>\n\n<p>注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。</p>\n\n<p>请返回单次按键 <strong>持续时间最长</strong> 的键，如果有多个这样的键，则返回 <strong>按字母顺序排列最大</strong> 的那个键。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>releaseTimes = [9,29,49,50], keysPressed = \"cbcd\"\n<strong>输出：</strong>\"c\"\n<strong>解释：</strong>按键顺序和持续时间如下：\n按下 'c' ，持续时间 9（时间 0 按下，时间 9 松开）\n按下 'b' ，持续时间 29 - 9 = 20（松开上一个键的时间 9 按下，时间 29 松开）\n按下 'c' ，持续时间 49 - 29 = 20（松开上一个键的时间 29 按下，时间 49 松开）\n按下 'd' ，持续时间 50 - 49 = 1（松开上一个键的时间 49 按下，时间 50 松开）\n按键持续时间最长的键是 'b' 和 'c'（第二次按下时），持续时间都是 20\n'c' 按字母顺序排列比 'b' 大，所以答案是 'c'\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>releaseTimes = [12,23,36,46,62], keysPressed = \"spuda\"\n<strong>输出：</strong>\"a\"\n<strong>解释：</strong>按键顺序和持续时间如下：\n按下 's' ，持续时间 12\n按下 'p' ，持续时间 23 - 12 = 11\n按下 'u' ，持续时间 36 - 23 = 13\n按下 'd' ，持续时间 46 - 36 = 10\n按下 'a' ，持续时间 62 - 46 = 16\n按键持续时间最长的键是 'a' ，持续时间 16</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>releaseTimes.length == n</code></li>\n\t<li><code>keysPressed.length == n</code></li>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= releaseTimes[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>releaseTimes[i] &lt; releaseTimes[i+1]</code></li>\n\t<li><code>keysPressed</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1630.等差子数组",
        "hardRate": "MEDIUM",
        "passRate": "76.14%",
        "problemsUrl": "https://leetcode.cn/problems/arithmetic-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/arithmetic-subarrays/solution",
        "problemsDesc": "<p>如果一个数列由至少两个元素组成，且每两个连续元素之间的差值都相同，那么这个序列就是 <strong>等差数列</strong> 。更正式地，数列 <code>s</code> 是等差数列，只需要满足：对于每个有效的 <code>i</code> ， <code>s[i+1] - s[i] == s[1] - s[0]</code> 都成立。</p>\n\n<p>例如，下面这些都是 <strong>等差数列</strong> ：</p>\n\n<pre>1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9</pre>\n\n<p>下面的数列 <strong>不是等差数列</strong> ：</p>\n\n<pre>1, 1, 2, 5, 7</pre>\n\n<p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code>，和两个由 <code>m</code> 个整数组成的数组 <code>l</code> 和 <code>r</code>，后两个数组表示 <code>m</code> 组范围查询，其中第 <code>i</code> 个查询对应范围 <code>[l[i], r[i]]</code> 。所有数组的下标都是 <strong>从 0 开始</strong> 的。</p>\n\n<p>返回<em> </em><code>boolean</code> 元素构成的答案列表 <code>answer</code> 。如果子数组 <code>nums[l[i]], nums[l[i]+1], ... , nums[r[i]]</code> 可以 <strong>重新排列</strong> 形成 <strong>等差数列</strong> ，<code>answer[i]</code> 的值就是 <code>true</code>；否则<code>answer[i]</code> 的值就是 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = <code>[4,6,5,9,3,7]</code>, l = <code>[0,0,2]</code>, r = <code>[2,3,5]</code>\n<strong>输出：</strong><code>[true,false,true]</code>\n<strong>解释：</strong>\n第 0 个查询，对应子数组 [4,6,5] 。可以重新排列为等差数列 [6,5,4] 。\n第 1 个查询，对应子数组 [4,6,5,9] 。无法重新排列形成等差数列。\n第 2 个查询，对应子数组 <code>[5,9,3,7] 。</code>可以重新排列为等差数列 <code>[3,5,7,9] 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]\n<strong>输出：</strong>[false,true,false,false,true,true]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>m == l.length</code></li>\n\t<li><code>m == r.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= m &lt;= 500</code></li>\n\t<li><code>0 &lt;= l[i] &lt; r[i] &lt; n</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1631.最小体力消耗路径",
        "hardRate": "MEDIUM",
        "passRate": "50.94%",
        "problemsUrl": "https://leetcode.cn/problems/path-with-minimum-effort/",
        "solutionsUrl": "https://leetcode.cn/problems/path-with-minimum-effort/solution",
        "problemsDesc": "<p>你准备参加一场远足活动。给你一个二维 <code>rows x columns</code> 的地图 <code>heights</code> ，其中 <code>heights[row][col]</code> 表示格子 <code>(row, col)</code> 的高度。一开始你在最左上角的格子 <code>(0, 0)</code> ，且你希望去最右下角的格子 <code>(rows-1, columns-1)</code> （注意下标从 <strong>0</strong> 开始编号）。你每次可以往 <strong>上</strong>，<strong>下</strong>，<strong>左</strong>，<strong>右</strong> 四个方向之一移动，你想要找到耗费 <strong>体力</strong> 最小的一条路径。</p>\n\n<p>一条路径耗费的 <strong>体力值</strong> 是路径上相邻格子之间 <strong>高度差绝对值</strong> 的 <strong>最大值</strong> 决定的。</p>\n\n<p>请你返回从左上角走到右下角的最小<strong> 体力消耗值</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex1.png\" style=\"width: 300px; height: 300px;\" /></p>\n\n<pre>\n<b>输入：</b>heights = [[1,2,2],[3,8,2],[5,3,5]]\n<b>输出：</b>2\n<b>解释：</b>路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。\n这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex2.png\" style=\"width: 300px; height: 300px;\" /></p>\n\n<pre>\n<b>输入：</b>heights = [[1,2,3],[3,8,4],[5,3,5]]\n<b>输出：</b>1\n<b>解释：</b>路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex3.png\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<b>输入：</b>heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]\n<b>输出：</b>0\n<b>解释：</b>上图所示路径不需要消耗任何体力。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rows == heights.length</code></li>\n\t<li><code>columns == heights[i].length</code></li>\n\t<li><code>1 <= rows, columns <= 100</code></li>\n\t<li><code>1 <= heights[i][j] <= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1632.矩阵转换后的秩",
        "hardRate": "HARD",
        "passRate": "57.49%",
        "problemsUrl": "https://leetcode.cn/problems/rank-transform-of-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/rank-transform-of-a-matrix/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> ，请你返回一个新的矩阵<em> </em><code>answer</code> ，其中<em> </em><code>answer[row][col]</code> 是 <code>matrix[row][col]</code> 的秩。</p>\n\n<p>每个元素的 <b>秩</b> 是一个整数，表示这个元素相对于其他元素的大小关系，它按照如下规则计算：</p>\n\n<ul>\n\t<li>秩是从 1 开始的一个整数。</li>\n\t<li>如果两个元素 <code>p</code> 和 <code>q</code> 在 <strong>同一行</strong> 或者 <strong>同一列</strong> ，那么：\n\t<ul>\n\t\t<li>如果 <code>p < q</code> ，那么 <code>rank(p) < rank(q)</code></li>\n\t\t<li>如果 <code>p == q</code> ，那么 <code>rank(p) == rank(q)</code></li>\n\t\t<li>如果 <code>p > q</code> ，那么 <code>rank(p) > rank(q)</code></li>\n\t</ul>\n\t</li>\n\t<li><b>秩</b> 需要越 <strong>小</strong> 越好。</li>\n</ul>\n\n<p>题目保证按照上面规则 <code>answer</code> 数组是唯一的。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank1.jpg\" style=\"width: 442px; height: 162px;\" />\n<pre>\n<b>输入：</b>matrix = [[1,2],[3,4]]\n<b>输出：</b>[[1,2],[2,3]]\n<strong>解释：</strong>\nmatrix[0][0] 的秩为 1 ，因为它是所在行和列的最小整数。\nmatrix[0][1] 的秩为 2 ，因为 matrix[0][1] > matrix[0][0] 且 matrix[0][0] 的秩为 1 。\nmatrix[1][0] 的秩为 2 ，因为 matrix[1][0] > matrix[0][0] 且 matrix[0][0] 的秩为 1 。\nmatrix[1][1] 的秩为 3 ，因为 matrix[1][1] > matrix[0][1]， matrix[1][1] > matrix[1][0] 且 matrix[0][1] 和 matrix[1][0] 的秩都为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank2.jpg\" style=\"width: 442px; height: 162px;\" />\n<pre>\n<b>输入：</b>matrix = [[7,7],[7,7]]\n<b>输出：</b>[[1,1],[1,1]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank3.jpg\" style=\"width: 601px; height: 322px;\" />\n<pre>\n<b>输入：</b>matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]\n<b>输出：</b>[[4,2,3],[1,3,4],[5,1,6],[1,3,4]]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank4.jpg\" style=\"width: 601px; height: 242px;\" />\n<pre>\n<b>输入：</b>matrix = [[7,3,6],[1,4,5],[9,8,2]]\n<b>输出：</b>[[5,1,4],[1,2,3],[6,3,1]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 <= m, n <= 500</code></li>\n\t<li><code>-10<sup>9</sup> <= matrix[row][col] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1633.各赛事的用户注册率",
        "hardRate": "EASY",
        "passRate": "62.69%",
        "problemsUrl": "https://leetcode.cn/problems/percentage-of-users-attended-a-contest/",
        "solutionsUrl": "https://leetcode.cn/problems/percentage-of-users-attended-a-contest/solution",
        "problemsDesc": "<p>用户表：&nbsp;<code>Users</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| user_id     | int     |\n| user_name   | varchar |\n+-------------+---------+\nuser_id 是该表的主键。\n该表中的每行包括用户 ID 和用户名。</pre>\n\n<p>&nbsp;</p>\n\n<p>注册表：&nbsp;<code>Register</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| contest_id  | int     |\n| user_id     | int     |\n+-------------+---------+\n(contest_id, user_id) 是该表的主键。\n该表中的每行包含用户的 ID 和他们注册的赛事。</pre>\n\n<p>&nbsp;</p>\n\n<p>写一条 SQL 语句，查询各赛事的用户注册百分率，保留两位小数。</p>\n\n<p>返回的结果表按&nbsp;<code>percentage</code>&nbsp;的&nbsp;<strong>降序&nbsp;</strong>排序，若相同则按&nbsp;<code>contest_id</code>&nbsp;的&nbsp;<strong>升序&nbsp;</strong>排序。</p>\n\n<p>查询结果如下示例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<code><strong>输入：</strong>\nUsers</code> 表：\n+---------+-----------+\n| user_id | user_name |\n+---------+-----------+\n| 6       | Alice     |\n| 2       | Bob       |\n| 7       | Alex      |\n+---------+-----------+\n\n<code>Register</code> 表：\n+------------+---------+\n| contest_id | user_id |\n+------------+---------+\n| 215        | 6       |\n| 209        | 2       |\n| 208        | 2       |\n| 210        | 6       |\n| 208        | 6       |\n| 209        | 7       |\n| 209        | 6       |\n| 215        | 7       |\n| 208        | 7       |\n| 210        | 2       |\n| 207        | 2       |\n| 210        | 7       |\n+------------+---------+\n<strong>输出：</strong>\n+------------+------------+\n| contest_id | percentage |\n+------------+------------+\n| 208        | 100.0      |\n| 209        | 100.0      |\n| 210        | 100.0      |\n| 215        | 66.67      |\n| 207        | 33.33      |\n+------------+------------+\n<strong>解释：</strong>\n所有用户都注册了 208、209 和 210 赛事，因此这些赛事的注册率为 100% ，我们按 contest_id 的降序排序加入结果表中。\nAlice 和 Alex 注册了 215 赛事，注册率为 ((2/3) * 100) = 66.67%\nBob 注册了 207 赛事，注册率为 ((1/3) * 100) = 33.33%</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1634.求两个多项式链表的和",
        "hardRate": "MEDIUM",
        "passRate": "60.15%",
        "problemsUrl": "https://leetcode.cn/problems/add-two-polynomials-represented-as-linked-lists/",
        "solutionsUrl": "https://leetcode.cn/problems/add-two-polynomials-represented-as-linked-lists/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1635.Hopper 公司查询 I",
        "hardRate": "HARD",
        "passRate": "49.23%",
        "problemsUrl": "https://leetcode.cn/problems/hopper-company-queries-i/",
        "solutionsUrl": "https://leetcode.cn/problems/hopper-company-queries-i/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1636.按照频率将数组升序排序",
        "hardRate": "EASY",
        "passRate": "74.76%",
        "problemsUrl": "https://leetcode.cn/problems/sort-array-by-increasing-frequency/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-array-by-increasing-frequency/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，请你将数组按照每个值的频率 <strong>升序</strong> 排序。如果有多个值的频率相同，请你按照数值本身将它们 <strong>降序</strong> 排序。 </p>\n\n<p>请你返回排序后的数组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,1,2,2,2,3]\n<b>输出：</b>[3,1,1,2,2,2]\n<b>解释：</b>'3' 频率为 1，'1' 频率为 2，'2' 频率为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,3,1,3,2]\n<b>输出：</b>[1,3,3,2,2]\n<b>解释：</b>'2' 和 '3' 频率都为 2 ，所以它们之间按照数值本身降序排序。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [-1,1,-6,4,5,-6,1,4,1]\n<b>输出：</b>[5,-1,4,4,-6,-6,1,1,1]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1637.两点之间不包含任何点的最宽垂直区域",
        "hardRate": "MEDIUM",
        "passRate": "84.34%",
        "problemsUrl": "https://leetcode.cn/problems/widest-vertical-area-between-two-points-containing-no-points/",
        "solutionsUrl": "https://leetcode.cn/problems/widest-vertical-area-between-two-points-containing-no-points/solution",
        "problemsDesc": "<p>给你&nbsp;<code>n</code>&nbsp;个二维平面上的点 <code>points</code> ，其中&nbsp;<code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;，请你返回两点之间内部不包含任何点的&nbsp;<strong>最宽垂直区域</strong> 的宽度。</p>\n\n<p><strong>垂直区域</strong> 的定义是固定宽度，而 y 轴上无限延伸的一块区域（也就是高度为无穷大）。 <strong>最宽垂直区域</strong> 为宽度最大的一个垂直区域。</p>\n\n<p>请注意，垂直区域&nbsp;<strong>边上</strong>&nbsp;的点&nbsp;<strong>不在</strong>&nbsp;区域内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/31/points3.png\" style=\"width: 276px; height: 371px;\" />​\n<pre>\n<b>输入：</b>points = [[8,7],[9,9],[7,4],[9,7]]\n<b>输出：</b>1\n<b>解释：</b>红色区域和蓝色区域都是最优区域。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]\n<b>输出：</b>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == points.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1638.统计只差一个字符的子串数目",
        "hardRate": "MEDIUM",
        "passRate": "77.64%",
        "problemsUrl": "https://leetcode.cn/problems/count-substrings-that-differ-by-one-character/",
        "solutionsUrl": "https://leetcode.cn/problems/count-substrings-that-differ-by-one-character/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>s</code> 和&nbsp;<code>t</code>&nbsp;，请你找出 <code>s</code>&nbsp;中的非空子串的数目，这些子串满足替换 <strong>一个不同字符</strong>&nbsp;以后，是 <code>t</code>&nbsp;串的子串。换言之，请你找到 <code>s</code>&nbsp;和 <code>t</code>&nbsp;串中 <strong>恰好</strong>&nbsp;只有一个字符不同的子字符串对的数目。</p>\n\n<p>比方说，&nbsp;<code>\"<u>compute</u>r\"</code>&nbsp;and&nbsp;<code>\"<u>computa</u>tion\"&nbsp;</code>只有一个字符不同：&nbsp;<code>'e'</code>/<code>'a'</code>&nbsp;，所以这一对子字符串会给答案加 1 。</p>\n\n<p>请你返回满足上述条件的不同子字符串对数目。</p>\n\n<p>一个 <strong>子字符串</strong>&nbsp;是一个字符串中连续的字符。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aba\", t = \"baba\"\n<b>输出：</b>6\n<strong>解释：</strong>以下为只相差 1 个字符的 s 和 t 串的子字符串对：\n(\"<strong>a</strong>ba\", \"<strong>b</strong>aba\")\n(\"<strong>a</strong>ba\", \"ba<strong>b</strong>a\")\n(\"ab<strong>a</strong>\", \"<strong>b</strong>aba\")\n(\"ab<strong>a</strong>\", \"ba<strong>b</strong>a\")\n(\"a<strong>b</strong>a\", \"b<strong>a</strong>ba\")\n(\"a<strong>b</strong>a\", \"bab<strong>a</strong>\")\n加粗部分分别表示 s 和 t 串选出来的子字符串。\n</pre>\n<strong>示例 2：</strong>\n\n<pre>\n<b>输入：</b>s = \"ab\", t = \"bb\"\n<b>输出：</b>3\n<strong>解释：</strong>以下为只相差 1 个字符的 s 和 t 串的子字符串对：\n(\"<strong>a</strong>b\", \"<strong>b</strong>b\")\n(\"<strong>a</strong>b\", \"b<strong>b</strong>\")\n(\"<strong>ab</strong>\", \"<strong>bb</strong>\")\n加粗部分分别表示 s 和 t 串选出来的子字符串。\n</pre>\n<strong>示例 3：</strong>\n\n<pre>\n<b>输入：</b>s = \"a\", t = \"a\"\n<b>输出：</b>0\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"abe\", t = \"bbc\"\n<b>输出：</b>10\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 100</code></li>\n\t<li><code>s</code> 和&nbsp;<code>t</code>&nbsp;都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1639.通过给定词典构造目标字符串的方案数",
        "hardRate": "HARD",
        "passRate": "46.91%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solution",
        "problemsDesc": "<p>给你一个字符串列表 <code>words</code> 和一个目标字符串 <code>target</code> 。<code>words</code> 中所有字符串都 <strong>长度相同</strong>  。</p>\n\n<p>你的目标是使用给定的 <code>words</code> 字符串列表按照下述规则构造 <code>target</code> ：</p>\n\n<ul>\n\t<li>从左到右依次构造 <code>target</code> 的每一个字符。</li>\n\t<li>为了得到 <code>target</code> 第 <code>i</code> 个字符（下标从 <strong>0</strong> 开始），当 <code>target[i] = words[j][k]</code> 时，你可以使用 <code>words</code> 列表中第 <code>j</code> 个字符串的第 <code>k</code> 个字符。</li>\n\t<li>一旦你使用了 <code>words</code> 中第 <code>j</code> 个字符串的第 <code>k</code> 个字符，你不能再使用 <code>words</code> 字符串列表中任意单词的第 <code>x</code> 个字符（<code>x <= k</code>）。也就是说，所有单词下标小于等于 <code>k</code> 的字符都不能再被使用。</li>\n\t<li>请你重复此过程直到得到目标字符串 <code>target</code> 。</li>\n</ul>\n\n<p><strong>请注意</strong>， 在构造目标字符串的过程中，你可以按照上述规定使用 <code>words</code> 列表中 <strong>同一个字符串</strong> 的 <strong>多个字符</strong> 。</p>\n\n<p>请你返回使用 <code>words</code> 构造 <code>target</code> 的方案数。由于答案可能会很大，请对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后返回。</p>\n\n<p>（译者注：此题目求的是有多少个不同的 <code>k</code> 序列，详情请见示例。）</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"acca\",\"bbbb\",\"caca\"], target = \"aba\"\n<b>输出：</b>6\n<b>解释：</b>总共有 6 种方法构造目标串。\n\"aba\" -> 下标为 0 (\"<strong>a</strong>cca\")，下标为 1 (\"b<strong>b</strong>bb\")，下标为 3 (\"cac<strong>a</strong>\")\n\"aba\" -> 下标为 0 (\"<strong>a</strong>cca\")，下标为 2 (\"bb<strong>b</strong>b\")，下标为 3 (\"cac<strong>a</strong>\")\n\"aba\" -> 下标为 0 (\"<strong>a</strong>cca\")，下标为 1 (\"b<strong>b</strong>bb\")，下标为 3 (\"acc<strong>a</strong>\")\n\"aba\" -> 下标为 0 (\"<strong>a</strong>cca\")，下标为 2 (\"bb<strong>b</strong>b\")，下标为 3 (\"acc<strong>a</strong>\")\n\"aba\" -> 下标为 1 (\"c<strong>a</strong>ca\")，下标为 2 (\"bb<strong>b</strong>b\")，下标为 3 (\"acc<strong>a</strong>\")\n\"aba\" -> 下标为 1 (\"c<strong>a</strong>ca\")，下标为 2 (\"bb<strong>b</strong>b\")，下标为 3 (\"cac<strong>a</strong>\")\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"abba\",\"baab\"], target = \"bab\"\n<b>输出：</b>4\n<b>解释：</b>总共有 4 种不同形成 target 的方法。\n\"bab\" -> 下标为 0 (\"<strong>b</strong>aab\")，下标为 1 (\"b<strong>a</strong>ab\")，下标为 2 (\"ab<strong>b</strong>a\")\n\"bab\" -> 下标为 0 (\"<strong>b</strong>aab\")，下标为 1 (\"b<strong>a</strong>ab\")，下标为 3 (\"baa<strong>b</strong>\")\n\"bab\" -> 下标为 0 (\"<strong>b</strong>aab\")，下标为 2 (\"ba<strong>a</strong>b\")，下标为 3 (\"baa<strong>b</strong>\")\n\"bab\" -> 下标为 1 (\"a<strong>b</strong>ba\")，下标为 2 (\"ba<strong>a</strong>b\")，下标为 3 (\"baa<strong>b</strong>\")\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"abcd\"], target = \"abcd\"\n<b>输出：</b>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"abab\",\"baba\",\"abba\",\"baab\"], target = \"abba\"\n<b>输出：</b>16\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= words.length <= 1000</code></li>\n\t<li><code>1 <= words[i].length <= 1000</code></li>\n\t<li><code>words</code> 中所有单词长度相同。</li>\n\t<li><code>1 <= target.length <= 1000</code></li>\n\t<li><code>words[i]</code> 和 <code>target</code> 都仅包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1640.能否连接形成数组",
        "hardRate": "EASY",
        "passRate": "60.95%",
        "problemsUrl": "https://leetcode.cn/problems/check-array-formation-through-concatenation/",
        "solutionsUrl": "https://leetcode.cn/problems/check-array-formation-through-concatenation/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> ，数组中的每个整数 <strong>互不相同</strong> 。另有一个由整数数组构成的数组 <code>pieces</code>，其中的整数也 <strong>互不相同</strong> 。请你以 <strong>任意顺序</strong> 连接 <code>pieces</code> 中的数组以形成 <code>arr</code> 。但是，<strong>不允许</strong> 对每个数组 <code>pieces[i]</code> 中的整数重新排序。</p>\n\n<p>如果可以连接<em> </em><code>pieces</code> 中的数组形成 <code>arr</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [15,88], pieces = [[88],[15]]\n<strong>输出：</strong>true\n<strong>解释：</strong>依次连接 <code>[15]</code> 和 <code>[88]</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [49,18,16], pieces = [[16,18,49]]\n<strong>输出：</strong>false\n<strong>解释：</strong>即便数字相符，也不能重新排列 pieces[0]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [91,4,64,78], pieces = [[78],[4,64],[91]]\n<strong>输出：</strong>true\n<strong>解释：</strong>依次连接 <code>[91]</code>、<code>[4,64]</code> 和 <code>[78]</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pieces.length &lt;= arr.length &lt;= 100</code></li>\n\t<li><code>sum(pieces[i].length) == arr.length</code></li>\n\t<li><code>1 &lt;= pieces[i].length &lt;= arr.length</code></li>\n\t<li><code>1 &lt;= arr[i], pieces[i][j] &lt;= 100</code></li>\n\t<li><code>arr</code> 中的整数 <strong>互不相同</strong></li>\n\t<li><code>pieces</code> 中的整数 <strong>互不相同</strong>（也就是说，如果将 <code>pieces</code> 扁平化成一维数组，数组中的所有整数互不相同）</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1641.统计字典序元音字符串的数目",
        "hardRate": "MEDIUM",
        "passRate": "82.37%",
        "problemsUrl": "https://leetcode.cn/problems/count-sorted-vowel-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/count-sorted-vowel-strings/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code>，请返回长度为 <code>n</code> 、仅由元音 (<code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>) 组成且按 <strong>字典序排列</strong> 的字符串数量。</p>\n\n<p>字符串 <code>s</code> 按 <strong>字典序排列</strong> 需要满足：对于所有有效的 <code>i</code>，<code>s[i]</code> 在字母表中的位置总是与 <code>s[i+1]</code> 相同或在 <code>s[i+1]</code> 之前。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>5\n<strong>解释：</strong>仅由元音组成的 5 个字典序字符串为 <code>[\"a\",\"e\",\"i\",\"o\",\"u\"]</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>15\n<strong>解释：</strong>仅由元音组成的 15 个字典序字符串为\n[\"aa\",\"ae\",\"ai\",\"ao\",\"au\",\"ee\",\"ei\",\"eo\",\"eu\",\"ii\",\"io\",\"iu\",\"oo\",\"ou\",\"uu\"]\n注意，\"ea\" 不是符合题意的字符串，因为 'e' 在字母表中的位置比 'a' 靠后\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 33\n<strong>输出：</strong>66045\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 50</code> </li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1642.可以到达的最远建筑",
        "hardRate": "MEDIUM",
        "passRate": "45.32%",
        "problemsUrl": "https://leetcode.cn/problems/furthest-building-you-can-reach/",
        "solutionsUrl": "https://leetcode.cn/problems/furthest-building-you-can-reach/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>heights</code> ，表示建筑物的高度。另有一些砖块 <code>bricks</code> 和梯子 <code>ladders</code> 。</p>\n\n<p>你从建筑物 <code>0</code> 开始旅程，不断向后面的建筑物移动，期间可能会用到砖块或梯子。</p>\n\n<p>当从建筑物 <code>i</code> 移动到建筑物 <code>i+1</code>（下标<strong> 从 0 开始 </strong>）时：</p>\n\n<ul>\n\t<li>如果当前建筑物的高度 <strong>大于或等于</strong> 下一建筑物的高度，则不需要梯子或砖块</li>\n\t<li>如果当前建筑的高度 <strong>小于</strong> 下一个建筑的高度，您可以使用 <strong>一架梯子</strong> 或 <strong><code>(h[i+1] - h[i])</code> 个砖块</strong></li>\n</ul>\n如果以最佳方式使用给定的梯子和砖块，返回你可以到达的最远建筑物的下标（下标<strong> 从 0 开始 </strong>）。\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/31/q4.gif\" style=\"width: 562px; height: 561px;\" />\n<pre>\n<strong>输入：</strong>heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1\n<strong>输出：</strong>4\n<strong>解释：</strong>从建筑物 0 出发，你可以按此方案完成旅程：\n- 不使用砖块或梯子到达建筑物 1 ，因为 4 >= 2\n- 使用 5 个砖块到达建筑物 2 。你必须使用砖块或梯子，因为 2 < 7\n- 不使用砖块或梯子到达建筑物 3 ，因为 7 >= 6\n- 使用唯一的梯子到达建筑物 4 。你必须使用砖块或梯子，因为 6 < 9\n无法越过建筑物 4 ，因为没有更多砖块或梯子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2\n<strong>输出：</strong>7\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>heights = [14,3,19,3], bricks = 17, ladders = 0\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= heights.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= heights[i] <= 10<sup>6</sup></code></li>\n\t<li><code>0 <= bricks <= 10<sup>9</sup></code></li>\n\t<li><code>0 <= ladders <= heights.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1643.第 K 条最小指令",
        "hardRate": "HARD",
        "passRate": "48.06%",
        "problemsUrl": "https://leetcode.cn/problems/kth-smallest-instructions/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-smallest-instructions/solution",
        "problemsDesc": "<p>Bob 站在单元格 <code>(0, 0)</code> ，想要前往目的地 <code>destination</code> ：<code>(row, column)</code> 。他只能向 <strong>右</strong> 或向 <strong>下</strong> 走。你可以为 Bob 提供导航 <strong>指令</strong> 来帮助他到达目的地 <code>destination</code> 。</p>\n\n<p><strong>指令</strong> 用字符串表示，其中每个字符：</p>\n\n<ul>\n\t<li><code>'H'</code> ，意味着水平向右移动</li>\n\t<li><code>'V'</code> ，意味着竖直向下移动</li>\n</ul>\n\n<p>能够为 Bob 导航到目的地 <code>destination</code> 的指令可以有多种，例如，如果目的地 <code>destination</code> 是 <code>(2, 3)</code>，<code>\"HHHVV\"</code> 和 <code>\"HVHVH\"</code> 都是有效<strong> 指令</strong> 。</p>\n\n<ul>\n</ul>\n\n<p>然而，Bob 很挑剔。因为他的幸运数字是 <code>k</code>，他想要遵循 <strong>按字典序排列后的第 <code>k</code> 条最小指令 </strong>的导航前往目的地 <code>destination</code> 。<code>k</code>  的编号 <strong>从 1 开始</strong> 。</p>\n\n<p>给你一个整数数组 <code>destination</code> 和一个整数 <code>k</code> ，请你返回可以为<em> </em>Bob<em> </em>提供前往目的地 <code>destination</code> 导航的<strong> 按字典序排列后的第 <code>k</code> 条最小指令 </strong>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/01/ex1.png\" style=\"width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>destination = [2,3], k = 1\n<strong>输出：</strong>\"HHHVV\"\n<strong>解释：</strong>能前往 (2, 3) 的所有导航指令 <strong>按字典序排列后</strong> 如下所示：\n[\"HHHVV\", \"HHVHV\", \"HHVVH\", \"HVHHV\", \"HVHVH\", \"HVVHH\", \"VHHHV\", \"VHHVH\", \"VHVHH\", \"VVHHH\"].\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/01/ex2.png\" style=\"width: 300px; height: 229px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>destination = [2,3], k = 2\n<strong>输出：</strong>\"HHVHV\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/01/ex3.png\" style=\"width: 300px; height: 229px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>destination = [2,3], k = 3\n<strong>输出：</strong>\"HHVVH\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>destination.length == 2</code></li>\n\t<li><code>1 <= row, column <= 15</code></li>\n\t<li><code>1 <= k <= nCr(row + column, row)</code>，其中 <code>nCr(a, b)</code> 表示组合数，即从 <code>a</code> 个物品中选 <code>b</code> 个物品的不同方案数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1644.二叉树的最近公共祖先 II",
        "hardRate": "MEDIUM",
        "passRate": "56.13%",
        "problemsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1645.1645.Hopper 公司查询 II",
        "hardRate": "HARD",
        "passRate": "41.78%",
        "problemsUrl": "https://leetcode.cn/problems/hopper-company-queries-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/hopper-company-queries-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1646.获取生成数组中的最大值",
        "hardRate": "EASY",
        "passRate": "51.87%",
        "problemsUrl": "https://leetcode.cn/problems/get-maximum-in-generated-array/",
        "solutionsUrl": "https://leetcode.cn/problems/get-maximum-in-generated-array/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> 。按下述规则生成一个长度为 <code>n + 1</code> 的数组 <code>nums</code> ：</p>\n\n<ul>\n\t<li><code>nums[0] = 0</code></li>\n\t<li><code>nums[1] = 1</code></li>\n\t<li>当 <code>2 <= 2 * i <= n</code> 时，<code>nums[2 * i] = nums[i]</code></li>\n\t<li>当 <code>2 <= 2 * i + 1 <= n</code> 时，<code>nums[2 * i + 1] = nums[i] + nums[i + 1]</code></li>\n</ul>\n\n<p>返回生成数组 <code>nums</code> 中的 <strong>最大</strong> 值。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 7\n<strong>输出：</strong>3\n<strong>解释：</strong>根据规则：\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\n因此，nums = [0,1,1,2,1,3,2,3]，最大值 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>根据规则，nums[0]、nums[1] 和 nums[2] 之中的最大值是 1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>根据规则，nums[0]、nums[1]、nums[2] 和 nums[3] 之中的最大值是 2\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= n <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1647.字符频次唯一的最小删除次数",
        "hardRate": "MEDIUM",
        "passRate": "54.53%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-character-frequencies-unique/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-character-frequencies-unique/solution",
        "problemsDesc": "<p>如果字符串 <code>s</code> 中 <strong>不存在</strong> 两个不同字符 <strong>频次</strong> 相同的情况，就称 <code>s</code> 是 <strong>优质字符串</strong> 。</p>\n\n<p>给你一个字符串 <code>s</code>，返回使 <code>s</code> 成为 <strong>优质字符串</strong> 需要删除的 <strong>最小</strong> 字符数。</p>\n\n<p>字符串中字符的 <strong>频次</strong> 是该字符在字符串中的出现次数。例如，在字符串 <code>\"aab\"</code> 中，<code>'a'</code> 的频次是 <code>2</code>，而 <code>'b'</code> 的频次是 <code>1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aab\"\n<strong>输出：</strong>0\n<strong>解释：</strong><code>s</code> 已经是优质字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aaabbbcc\"\n<strong>输出：</strong>2\n<strong>解释：</strong>可以删除两个 'b' , 得到优质字符串 \"aaabcc\" 。\n另一种方式是删除一个 'b' 和一个 'c' ，得到优质字符串 \"aaabbc\" 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ceabaacb\"\n<strong>输出：</strong>2\n<strong>解释：</strong>可以删除两个 'c' 得到优质字符串 \"eabaab\" 。\n注意，只需要关注结果字符串中仍然存在的字符。（即，频次为 0 的字符会忽略不计。）\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 仅含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1648.销售价值减少的颜色球",
        "hardRate": "MEDIUM",
        "passRate": "31.57%",
        "problemsUrl": "https://leetcode.cn/problems/sell-diminishing-valued-colored-balls/",
        "solutionsUrl": "https://leetcode.cn/problems/sell-diminishing-valued-colored-balls/solution",
        "problemsDesc": "<p>你有一些球的库存 <code>inventory</code> ，里面包含着不同颜色的球。一个顾客想要 <strong>任意颜色</strong> 总数为 <code>orders</code> 的球。</p>\n\n<p>这位顾客有一种特殊的方式衡量球的价值：每个球的价值是目前剩下的 <strong>同色球</strong> 的数目。比方说还剩下 <code>6</code> 个黄球，那么顾客买第一个黄球的时候该黄球的价值为 <code>6</code> 。这笔交易以后，只剩下 <code>5</code> 个黄球了，所以下一个黄球的价值为 <code>5</code> （也就是球的价值随着顾客购买同色球是递减的）</p>\n\n<p>给你整数数组 <code>inventory</code> ，其中 <code>inventory[i]</code> 表示第 <code>i</code> 种颜色球一开始的数目。同时给你整数 <code>orders</code> ，表示顾客总共想买的球数目。你可以按照 <strong>任意顺序</strong> 卖球。</p>\n\n<p>请你返回卖了 <code>orders</code> 个球以后 <strong>最大</strong> 总价值之和。由于答案可能会很大，请你返回答案对 <code>10<sup>9</sup> + 7</code> <strong>取余数</strong> 的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/08/jj.gif\" style=\"width: 480px; height: 270px;\" />\n<pre>\n<b>输入：</b>inventory = [2,5], orders = 4\n<b>输出：</b>14\n<b>解释：</b>卖 1 个第一种颜色的球（价值为 2 )，卖 3 个第二种颜色的球（价值为 5 + 4 + 3）。\n最大总和为 2 + 5 + 4 + 3 = 14 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>inventory = [3,5], orders = 6\n<b>输出：</b>19\n<strong>解释：</strong>卖 2 个第一种颜色的球（价值为 3 + 2），卖 4 个第二种颜色的球（价值为 5 + 4 + 3 + 2）。\n最大总和为 3 + 2 + 5 + 4 + 3 + 2 = 19 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>inventory = [2,8,4,10,6], orders = 20\n<b>输出：</b>110\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>inventory = [1000000000], orders = 1000000000\n<b>输出：</b>21\n<strong>解释：</strong>卖 1000000000 次第一种颜色的球，总价值为 500000000500000000 。 500000000500000000 对 10<sup>9 </sup>+ 7 取余为 21 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= inventory.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= inventory[i] <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= orders <= min(sum(inventory[i]), 10<sup>9</sup>)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1649.通过指令创建有序数组",
        "hardRate": "HARD",
        "passRate": "49.31%",
        "problemsUrl": "https://leetcode.cn/problems/create-sorted-array-through-instructions/",
        "solutionsUrl": "https://leetcode.cn/problems/create-sorted-array-through-instructions/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>instructions</code> ，你需要根据 <code>instructions</code> 中的元素创建一个有序数组。一开始你有一个空的数组 <code>nums</code> ，你需要 <strong>从左到右</strong> 遍历 <code>instructions</code> 中的元素，将它们依次插入 <code>nums</code> 数组中。每一次插入操作的 <strong>代价</strong> 是以下两者的 <strong>较小值</strong> ：</p>\n\n<ul>\n\t<li><code>nums</code> 中 <strong>严格小于 </strong> <code>instructions[i]</code> 的数字数目。</li>\n\t<li><code>nums</code> 中 <strong>严格大于 </strong> <code>instructions[i]</code> 的数字数目。</li>\n</ul>\n\n<p>比方说，如果要将 <code>3</code> 插入到 <code>nums = [1,2,3,5]</code> ，那么插入操作的 <strong>代价</strong> 为 <code>min(2, 1)</code> (元素 <code>1</code> 和  <code>2</code> 小于 <code>3</code> ，元素 <code>5</code> 大于 <code>3</code> ），插入后 <code>nums</code> 变成 <code>[1,2,3,3,5]</code> 。</p>\n\n<p>请你返回将 <code>instructions</code> 中所有元素依次插入 <code>nums</code> 后的 <strong>总最小代价 </strong>。由于答案会很大，请将它对 <code>10<sup>9</sup> + 7</code> <b>取余</b> 后返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>instructions = [1,5,6,2]\n<b>输出：</b>1\n<b>解释：</b>一开始 nums = [] 。\n插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。\n插入 5 ，代价为 min(1, 0) = 0 ，现在 nums = [1,5] 。\n插入 6 ，代价为 min(2, 0) = 0 ，现在 nums = [1,5,6] 。\n插入 2 ，代价为 min(1, 2) = 1 ，现在 nums = [1,2,5,6] 。\n总代价为 0 + 0 + 0 + 1 = 1 。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><b>输入：</b>instructions = [1,2,3,6,5,4]\n<b>输出：</b>3\n<b>解释：</b>一开始 nums = [] 。\n插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。\n插入 2 ，代价为 min(1, 0) = 0 ，现在 nums = [1,2] 。\n插入 3 ，代价为 min(2, 0) = 0 ，现在 nums = [1,2,3] 。\n插入 6 ，代价为 min(3, 0) = 0 ，现在 nums = [1,2,3,6] 。\n插入 5 ，代价为 min(3, 1) = 1 ，现在 nums = [1,2,3,5,6] 。\n插入 4 ，代价为 min(3, 2) = 2 ，现在 nums = [1,2,3,4,5,6] 。\n总代价为 0 + 0 + 0 + 0 + 1 + 2 = 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>instructions = [1,3,3,3,2,4,2,1,2]\n<b>输出：</b>4\n<b>解释：</b>一开始 nums = [] 。\n插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。\n插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3] 。\n插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3,3] 。\n插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3,3,3] 。\n插入 2 ，代价为 min(1, 3) = 1 ，现在 nums = [1,2,3,3,3] 。\n插入 4 ，代价为 min(5, 0) = 0 ，现在 nums = [1,2,3,3,3,4] 。\n​​​​​插入 2 ，代价为 min(1, 4) = 1 ，现在 nums = [1,2,2,3,3,3,4] 。\n插入 1 ，代价为 min(0, 6) = 0 ，现在 nums = [1,1,2,2,3,3,3,4] 。\n插入 2 ，代价为 min(2, 4) = 2 ，现在 nums = [1,1,2,2,2,3,3,3,4] 。\n总代价为 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 2 = 4 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= instructions.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= instructions[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1650.二叉树的最近公共祖先 III",
        "hardRate": "MEDIUM",
        "passRate": "80.00%",
        "problemsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    }
]