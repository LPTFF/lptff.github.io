[
    {
        "problemsName": " 751.IP 到 CIDR",
        "hardRate": "MEDIUM",
        "passRate": "48.35%",
        "problemsUrl": "https://leetcode.cn/problems/ip-to-cidr/",
        "solutionsUrl": "https://leetcode.cn/problems/ip-to-cidr/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 752.打开转盘锁",
        "hardRate": "MEDIUM",
        "passRate": "52.71%",
        "problemsUrl": "https://leetcode.cn/problems/open-the-lock/",
        "solutionsUrl": "https://leetcode.cn/problems/open-the-lock/solution",
        "problemsDesc": "<p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： <code>'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'</code> 。每个拨轮可以自由旋转：例如把 <code>'9'</code> 变为&nbsp;<code>'0'</code>，<code>'0'</code> 变为 <code>'9'</code> 。每次旋转都只能旋转一个拨轮的一位数字。</p>\n\n<p>锁的初始数字为 <code>'0000'</code> ，一个代表四个拨轮的数字的字符串。</p>\n\n<p>列表 <code>deadends</code> 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p>\n\n<p>字符串 <code>target</code> 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"\n<strong>输出：</strong>6\n<strong>解释：</strong>\n可能的移动序列为 \"0000\" -&gt; \"1000\" -&gt; \"1100\" -&gt; \"1200\" -&gt; \"1201\" -&gt; \"1202\" -&gt; \"0202\"。\n注意 \"0000\" -&gt; \"0001\" -&gt; \"0002\" -&gt; \"0102\" -&gt; \"0202\" 这样的序列是不能解锁的，\n因为当拨动到 \"0102\" 时这个锁就会被锁定。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> deadends = [\"8888\"], target = \"0009\"\n<strong>输出：</strong>1\n<strong>解释：</strong>把最后一位反向旋转一次即可 \"0000\" -&gt; \"0009\"。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"\n<strong>输出：</strong>-1\n<strong>解释：</strong>无法旋转到目标数字且不被锁定。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;deadends.length &lt;= 500</code></li>\n\t<li><code><font face=\"monospace\">deadends[i].length == 4</font></code></li>\n\t<li><code><font face=\"monospace\">target.length == 4</font></code></li>\n\t<li><code>target</code> <strong>不在</strong> <code>deadends</code> 之中</li>\n\t<li><code>target</code> 和 <code>deadends[i]</code> 仅由若干位数字组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 753.破解保险箱",
        "hardRate": "HARD",
        "passRate": "74.87%",
        "problemsUrl": "https://leetcode.cn/problems/cracking-the-safe/",
        "solutionsUrl": "https://leetcode.cn/problems/cracking-the-safe/solution",
        "problemsDesc": "<p>有一个需要密码才能打开的保险箱。密码是&nbsp;<code>n</code> 位数, 密码的每一位都是范围&nbsp;<code>[0, k - 1]</code>&nbsp;中的一个数字。</p>\n\n<p>保险箱有一种特殊的密码校验方法，你可以随意输入密码序列，保险箱会自动记住 <strong>最后&nbsp;<code>n</code>&nbsp;位输入</strong> ，如果匹配，则能够打开保险箱。</p>\n\n<ul>\n\t<li>例如，正确的密码是 <code>\"345\"</code> ，并且你输入的是 <code>\"012345\"</code> ：\n\n\t<ul>\n\t\t<li>输入 <code>0</code> 之后，最后 <code>3</code> 位输入是 <code>\"0\"</code> ，不正确。</li>\n\t\t<li>输入 <code>1</code> 之后，最后 <code>3</code> 位输入是 <code>\"01\"</code> ，不正确。</li>\n\t\t<li>输入 <code>2</code> 之后，最后 <code>3</code> 位输入是 <code>\"012\"</code> ，不正确。</li>\n\t\t<li>输入 <code>3</code> 之后，最后 <code>3</code> 位输入是 <code>\"123\"</code> ，不正确。</li>\n\t\t<li>输入 <code>4</code> 之后，最后 <code>3</code> 位输入是 <code>\"234\"</code> ，不正确。</li>\n\t\t<li>输入 <code>5</code> 之后，最后 <code>3</code> 位输入是 <code>\"345\"</code> ，正确，打开保险箱。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>在只知道密码位数 <code>n</code> 和范围边界 <code>k</code> 的前提下，请你找出并返回确保在输入的 <strong>某个时刻</strong> 能够打开保险箱的任一 <strong>最短</strong> 密码序列 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, k = 2\n<strong>输出：</strong>\"10\"\n<strong>解释：</strong>密码只有 1 位，所以输入每一位就可以。\"01\" 也能够确保打开保险箱。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, k = 2\n<strong>输出：</strong>\"01100\"\n<strong>解释：</strong>对于每种可能的密码：\n- \"00\" 从第 4 位开始输入。\n- \"01\" 从第 1 位开始输入。\n- \"10\" 从第 3 位开始输入。\n- \"11\" 从第 2 位开始输入。\n因此 \"01100\" 可以确保打开保险箱。\"01100\"、\"10011\" 和 \"11001\" 也可以确保打开保险箱。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 4</code></li>\n\t<li><code>1 &lt;= k &lt;= 10</code></li>\n\t<li><code>1 &lt;= k<sup>n</sup> &lt;= 4096</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 754.到达终点数字",
        "hardRate": "MEDIUM",
        "passRate": "51.43%",
        "problemsUrl": "https://leetcode.cn/problems/reach-a-number/",
        "solutionsUrl": "https://leetcode.cn/problems/reach-a-number/solution",
        "problemsDesc": "<p>在一根无限长的数轴上，你站在<code>0</code>的位置。终点在<code>target</code>的位置。</p>\n\n<p>你可以做一些数量的移动 <code>numMoves</code> :</p>\n\n<ul>\n\t<li>每次你可以选择向左或向右移动。</li>\n\t<li>第 <code>i</code>&nbsp;次移动（从 &nbsp;<code>i == 1</code>&nbsp;开始，到&nbsp;<code>i == numMoves</code> ），在选择的方向上走 <code>i</code>&nbsp;步。</li>\n</ul>\n\n<p>给定整数&nbsp;<code>target</code> ，返回 <em>到达目标所需的 <strong>最小&nbsp;</strong>移动次数(即最小 <code>numMoves</code> )&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> target = 2\n<strong>输出:</strong> 3\n<strong>解释:</strong>\n第一次移动，从 0 到 1 。\n第二次移动，从 1 到 -1 。\n第三次移动，从 -1 到 2 。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> target = 3\n<strong>输出:</strong> 2\n<strong>解释:</strong>\n第一次移动，从 0 到 1 。\n第二次移动，从 1 到 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><code>target != 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 755.倒水",
        "hardRate": "MEDIUM",
        "passRate": "48.25%",
        "problemsUrl": "https://leetcode.cn/problems/pour-water/",
        "solutionsUrl": "https://leetcode.cn/problems/pour-water/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 756.金字塔转换矩阵",
        "hardRate": "MEDIUM",
        "passRate": "52.11%",
        "problemsUrl": "https://leetcode.cn/problems/pyramid-transition-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/pyramid-transition-matrix/solution",
        "problemsDesc": "<p>你正在把积木堆成金字塔。每个块都有一个颜色，用一个字母表示。每一行的块比它下面的行 <strong>少一个块</strong> ，并且居中。</p>\n\n<p>为了使金字塔美观，只有特定的 <strong>三角形图案</strong> 是允许的。一个三角形的图案由&nbsp;<strong>两个块</strong>&nbsp;和叠在上面的 <strong>单个块</strong> 组成。模式是以三个字母字符串的列表形式&nbsp;<code>allowed</code>&nbsp;给出的，其中模式的前两个字符分别表示左右底部块，第三个字符表示顶部块。</p>\n\n<ul>\n\t<li>例如，<code>\"ABC\"</code>&nbsp;表示一个三角形图案，其中一个 <code>“C”</code> 块堆叠在一个&nbsp;<code>'A'</code>&nbsp;块(左)和一个&nbsp;<code>'B'</code>&nbsp;块(右)之上。请注意，这与 <code>\"BAC\"</code>&nbsp;不同，<code>\"B\"</code>&nbsp;在左下角，<code>\"A\"</code>&nbsp;在右下角。</li>\n</ul>\n\n<p>你从底部的一排积木&nbsp;<code>bottom</code>&nbsp;开始，作为一个单一的字符串，你 <strong>必须</strong> 使用作为金字塔的底部。</p>\n\n<p>在给定&nbsp;<code>bottom</code>&nbsp;和&nbsp;<code>allowed</code>&nbsp;的情况下，如果你能一直构建到金字塔顶部，使金字塔中的 <strong>每个三角形图案</strong> 都是允许的，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/26/pyramid1-grid.jpg\" style=\"height: 232px; width: 600px;\" /></p>\n\n<pre>\n<strong>输入：</strong>bottom = \"BCD\", allowed = [\"BCC\",\"CDE\",\"CEA\",\"FFF\"]\n<strong>输出：</strong>true\n<strong>解释：</strong>允许的三角形模式显示在右边。\n从最底层(第3层)开始，我们可以在第2层构建“CE”，然后在第1层构建“E”。\n金字塔中有三种三角形图案，分别是“BCC”、“CDE”和“CEA”。都是允许的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/26/pyramid2-grid.jpg\" style=\"height: 359px; width: 600px;\" /></p>\n\n<pre>\n<strong>输入：</strong>bottom = \"AAAA\", allowed = [\"AAB\",\"AAC\",\"BCD\",\"BBE\",\"DEF\"]\n<strong>输出：</strong>false\n<strong>解释：</strong>允许的三角形模式显示在右边。\n从最底层(游戏邦注:即第4个关卡)开始，创造第3个关卡有多种方法，但如果尝试所有可能性，你便会在创造第1个关卡前陷入困境。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= bottom.length &lt;= 6</code></li>\n\t<li><code>0 &lt;= allowed.length &lt;= 216</code></li>\n\t<li><code>allowed[i].length == 3</code></li>\n\t<li>所有输入字符串中的字母来自集合&nbsp;<code>{'A', 'B', 'C', 'D', 'E', 'F', 'G'}</code>。</li>\n\t<li>&nbsp;<code>allowed</code>&nbsp;中所有值都是 <strong>唯一的</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 757.设置交集大小至少为2",
        "hardRate": "HARD",
        "passRate": "56.07%",
        "problemsUrl": "https://leetcode.cn/problems/set-intersection-size-at-least-two/",
        "solutionsUrl": "https://leetcode.cn/problems/set-intersection-size-at-least-two/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>intervals</code> ，其中 <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 表示从 <code>start<sub>i</sub></code> 到 <code>end<sub>i</sub></code> 的所有整数，包括 <code>start<sub>i</sub></code> 和 <code>end<sub>i</sub></code> 。</p>\n\n<p><strong>包含集合</strong> 是一个名为 <code>nums</code> 的数组，并满足 <code>intervals</code> 中的每个区间都 <strong>至少</strong> 有 <strong>两个</strong> 整数在 <code>nums</code> 中。</p>\n\n<ul>\n\t<li>例如，如果 <code>intervals = [[1,3], [3,7], [8,9]]</code> ，那么 <code>[1,2,4,7,8,9]</code> 和 <code>[2,3,4,8,9]</code> 都符合 <strong>包含集合</strong> 的定义。</li>\n</ul>\n\n<p>返回包含集合可能的最小大小。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,3],[3,7],[8,9]]\n<strong>输出：</strong>5\n<strong>解释：</strong>nums = [2, 3, 4, 8, 9].\n可以证明不存在元素数量为 4 的包含集合。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,3],[1,4],[2,5],[3,5]]\n<strong>输出：</strong>3\n<strong>解释：</strong>nums = [2, 3, 4].\n可以证明不存在元素数量为 2 的包含集合。 \n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,2],[2,3],[2,4],[4,5]]\n<strong>输出：</strong>5\n<strong>解释：</strong>nums = [1, 2, 3, 4, 5].\n可以证明不存在元素数量为 4 的包含集合。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 3000</code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt; end<sub>i</sub> &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 758.字符串中的加粗单词",
        "hardRate": "MEDIUM",
        "passRate": "48.32%",
        "problemsUrl": "https://leetcode.cn/problems/bold-words-in-string/",
        "solutionsUrl": "https://leetcode.cn/problems/bold-words-in-string/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 759.员工空闲时间",
        "hardRate": "HARD",
        "passRate": "70.52%",
        "problemsUrl": "https://leetcode.cn/problems/employee-free-time/",
        "solutionsUrl": "https://leetcode.cn/problems/employee-free-time/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 760.找出变位映射",
        "hardRate": "EASY",
        "passRate": "84.35%",
        "problemsUrl": "https://leetcode.cn/problems/find-anagram-mappings/",
        "solutionsUrl": "https://leetcode.cn/problems/find-anagram-mappings/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 761.特殊的二进制序列",
        "hardRate": "HARD",
        "passRate": "75.21%",
        "problemsUrl": "https://leetcode.cn/problems/special-binary-string/",
        "solutionsUrl": "https://leetcode.cn/problems/special-binary-string/solution",
        "problemsDesc": "<p>特殊的二进制序列是具有以下两个性质的二进制序列：</p>\n\n<ul>\n\t<li>0 的数量与 1 的数量相等。</li>\n\t<li>二进制序列的每一个前缀码中 1 的数量要大于等于 0 的数量。</li>\n</ul>\n\n<p>给定一个特殊的二进制序列&nbsp;<code>S</code>，以字符串形式表示。定义一个<em>操作 </em>为首先选择&nbsp;<code>S</code>&nbsp;的两个连续且非空的特殊的子串，然后将它们交换。（两个子串为连续的当且仅当第一个子串的最后一个字符恰好为第二个子串的第一个字符的前一个字符。)</p>\n\n<p>在任意次数的操作之后，交换后的字符串按照字典序排列的最大的结果是什么？</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> S = &quot;11011000&quot;\n<strong>输出:</strong> &quot;11100100&quot;\n<strong>解释:</strong>\n将子串 &quot;10&quot; （在S[1]出现） 和 &quot;1100&quot; （在S[3]出现）进行交换。\n这是在进行若干次操作后按字典序排列最大的结果。\n</pre>\n\n<p><strong>说明:</strong></p>\n\n<ol>\n\t<li><code>S</code>&nbsp;的长度不超过&nbsp;<code>50</code>。</li>\n\t<li><code>S</code>&nbsp;保证为一个满足上述定义的<em>特殊 </em>的二进制序列。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 762.二进制表示中质数个计算置位",
        "hardRate": "EASY",
        "passRate": "75.30%",
        "problemsUrl": "https://leetcode.cn/problems/prime-number-of-set-bits-in-binary-representation/",
        "solutionsUrl": "https://leetcode.cn/problems/prime-number-of-set-bits-in-binary-representation/solution",
        "problemsDesc": "<p>给你两个整数&nbsp;<code>left</code>&nbsp;和&nbsp;<code>right</code> ，在闭区间 <code>[left, right]</code>&nbsp;范围内，统计并返回 <strong>计算置位位数为质数</strong> 的整数个数。</p>\n\n<p><strong>计算置位位数</strong> 就是二进制表示中 <code>1</code> 的个数。</p>\n\n<ul>\n\t<li>例如， <code>21</code>&nbsp;的二进制表示&nbsp;<code>10101</code>&nbsp;有 <code>3</code> 个计算置位。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>left = 6, right = 10\n<strong>输出：</strong>4\n<strong>解释：</strong>\n6 -&gt; 110 (2 个计算置位，2 是质数)\n7 -&gt; 111 (3 个计算置位，3 是质数)\n9 -&gt; 1001 (2 个计算置位，2 是质数)\n10-&gt; 1010 (2 个计算置位，2 是质数)\n共计 4 个计算置位为质数的数字。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>left = 10, right = 15\n<strong>输出：</strong>5\n<strong>解释：</strong>\n10 -&gt; 1010 (2 个计算置位, 2 是质数)\n11 -&gt; 1011 (3 个计算置位, 3 是质数)\n12 -&gt; 1100 (2 个计算置位, 2 是质数)\n13 -&gt; 1101 (3 个计算置位, 3 是质数)\n14 -&gt; 1110 (3 个计算置位, 3 是质数)\n15 -&gt; 1111 (4 个计算置位, 4 不是质数)\n共计 5 个计算置位为质数的数字。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= left &lt;= right &lt;= 10<sup>6</sup></code></li>\n\t<li><code>0 &lt;= right - left &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 763.划分字母区间",
        "hardRate": "MEDIUM",
        "passRate": "76.78%",
        "problemsUrl": "https://leetcode.cn/problems/partition-labels/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-labels/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p>\n\n<p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code> 。</p>\n\n<p>返回一个表示每个字符串片段的长度的列表。</p>\n\n<p>&nbsp;</p>\n<strong class=\"example\">示例 1：</strong>\n\n<pre>\n<strong>输入：</strong>s = \"ababcbacadefegdehijhklij\"\n<strong>输出：</strong>[9,7,8]\n<strong>解释：</strong>\n划分结果为 \"ababcbaca\"、\"defegde\"、\"hijhklij\" 。\n每个字母最多出现在一个片段中。\n像 \"ababcbacadefegde\", \"hijhklij\" 这样的划分是错误的，因为划分的片段数较少。 </pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"eccbbbbdec\"\n<strong>输出：</strong>[10]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 764.最大加号标志",
        "hardRate": "MEDIUM",
        "passRate": "54.23%",
        "problemsUrl": "https://leetcode.cn/problems/largest-plus-sign/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-plus-sign/solution",
        "problemsDesc": "<p>在一个 <code>n x n</code> 的矩阵&nbsp;<code>grid</code>&nbsp;中，除了在数组&nbsp;<code>mines</code>&nbsp;中给出的元素为&nbsp;<code>0</code>，其他每个元素都为&nbsp;<code>1</code>。<code>mines[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>表示&nbsp;<code>grid[x<sub>i</sub>][y<sub>i</sub>] == 0</code></p>\n\n<p>返回 <em>&nbsp;</em><code>grid</code><em> 中包含&nbsp;<code>1</code>&nbsp;的最大的 <strong>轴对齐</strong> 加号标志的阶数</em> 。如果未找到加号标志，则返回 <code>0</code> 。</p>\n\n<p>一个&nbsp;<code>k</code>&nbsp;阶由&nbsp;<em><code>1</code></em>&nbsp;组成的 <strong>“轴对称”加号标志</strong> 具有中心网格&nbsp;<code>grid[r][c] == 1</code>&nbsp;，以及4个从中心向上、向下、向左、向右延伸，长度为&nbsp;<code>k-1</code>，由&nbsp;<code>1</code>&nbsp;组成的臂。注意，只有加号标志的所有网格要求为 <code>1</code> ，别的网格可能为 <code>0</code> 也可能为 <code>1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/13/plus1-grid.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> n = 5, mines = [[4, 2]]\n<strong>输出:</strong> 2\n<strong>解释: </strong>在上面的网格中，最大加号标志的阶只能是2。一个标志已在图中标出。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/13/plus2-grid.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> n = 1, mines = [[0, 0]]\n<strong>输出:</strong> 0\n<strong>解释: </strong>没有加号标志，返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= mines.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt; n</code></li>\n\t<li>每一对&nbsp;<code>(x<sub>i</sub>, y<sub>i</sub>)</code>&nbsp;都 <strong>不重复</strong>​​​​​​​</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 765.情侣牵手",
        "hardRate": "HARD",
        "passRate": "65.91%",
        "problemsUrl": "https://leetcode.cn/problems/couples-holding-hands/",
        "solutionsUrl": "https://leetcode.cn/problems/couples-holding-hands/solution",
        "problemsDesc": "<p><code>n</code> 对情侣坐在连续排列的 <code>2n</code>&nbsp;个座位上，想要牵到对方的手。</p>\n\n<p>人和座位由一个整数数组 <code>row</code> 表示，其中 <code>row[i]</code> 是坐在第 <code>i </code>个座位上的人的 <strong>ID</strong>。情侣们按顺序编号，第一对是&nbsp;<code>(0, 1)</code>，第二对是&nbsp;<code>(2, 3)</code>，以此类推，最后一对是&nbsp;<code>(2n-2, 2n-1)</code>。</p>\n\n<p>返回 <em>最少交换座位的次数，以便每对情侣可以并肩坐在一起</em>。 <i>每次</i>交换可选择任意两人，让他们站起来交换座位。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> row = [0,2,1,3]\n<strong>输出:</strong> 1\n<strong>解释:</strong> 只需要交换row[1]和row[2]的位置即可。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> row = [3,2,0,1]\n<strong>输出:</strong> 0\n<strong>解释:</strong> 无需交换座位，所有的情侣都已经可以手牵手了。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>2n == row.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 30</code></li>\n\t<li><code>n</code>&nbsp;是偶数</li>\n\t<li><code>0 &lt;= row[i] &lt; 2n</code></li>\n\t<li><code>row</code>&nbsp;中所有元素均<strong>无重复</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 766.托普利茨矩阵",
        "hardRate": "EASY",
        "passRate": "70.24%",
        "problemsUrl": "https://leetcode.cn/problems/toeplitz-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/toeplitz-matrix/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> 。如果这个矩阵是托普利茨矩阵，返回 <code>true</code> ；否则，返回<em> </em><code>false</code><em> 。</em></p>\n\n<p>如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是<em> </em><strong>托普利茨矩阵</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/ex1.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]\n<strong>输出：</strong>true\n<strong>解释：</strong>\n在上述矩阵中, 其对角线为: \n\"[9]\", \"[5, 5]\", \"[1, 1, 1]\", \"[2, 2, 2]\", \"[3, 3]\", \"[4]\"。 \n各条对角线上的所有元素均相同, 因此答案是 True 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/ex2.jpg\" style=\"width: 162px; height: 162px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,2],[2,2]]\n<strong>输出：</strong>false\n<strong>解释：</strong>\n对角线 \"[1, 2]\" 上的元素不同。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 <= m, n <= 20</code></li>\n\t<li><code>0 <= matrix[i][j] <= 99</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>如果矩阵存储在磁盘上，并且内存有限，以至于一次最多只能将矩阵的一行加载到内存中，该怎么办？</li>\n\t<li>如果矩阵太大，以至于一次只能将不完整的一行加载到内存中，该怎么办？</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 767.重构字符串",
        "hardRate": "MEDIUM",
        "passRate": "48.45%",
        "problemsUrl": "https://leetcode.cn/problems/reorganize-string/",
        "solutionsUrl": "https://leetcode.cn/problems/reorganize-string/solution",
        "problemsDesc": "<p>给定一个字符串&nbsp;<code>s</code>&nbsp;，检查是否能重新排布其中的字母，使得两相邻的字符不同。</p>\n\n<p>返回<em> <code>s</code>&nbsp;的任意可能的重新排列。若不可行，返回空字符串&nbsp;<code>\"\"</code></em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"aab\"\n<strong>输出:</strong> \"aba\"\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"aaab\"\n<strong>输出:</strong> \"\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>s</code> 只包含小写字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 768.最多能完成排序的块 II",
        "hardRate": "HARD",
        "passRate": "58.72%",
        "problemsUrl": "https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> 。</p>\n\n<p>将 <code>arr</code> 分割成若干 <strong>块</strong> ，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。</p>\n\n<p>返回能将数组分成的最多块数？</p>\n&nbsp;\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [5,4,3,2,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n将数组分成2块或者更多块，都无法得到所需的结果。 \n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 \n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [2,1,3,4,4]\n<strong>输出：</strong>4\n<strong>解释：</strong>\n可以把它分成两块，例如 [2, 1], [3, 4, 4]。 \n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 2000</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 769.最多能完成排序的块",
        "hardRate": "MEDIUM",
        "passRate": "59.24%",
        "problemsUrl": "https://leetcode.cn/problems/max-chunks-to-make-sorted/",
        "solutionsUrl": "https://leetcode.cn/problems/max-chunks-to-make-sorted/solution",
        "problemsDesc": "<p>给定一个长度为 <code>n</code> 的整数数组 <code>arr</code> ，它表示在 <code>[0, n - 1]</code> 范围内的整数的排列。</p>\n\n<p>我们将 <code>arr</code> 分割成若干 <strong>块</strong> (即分区)，并对每个块单独排序。将它们连接起来后，使得连接的结果和按升序排序后的原数组相同。</p>\n\n<p>返回数组能分成的最多块数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> arr = [4,3,2,1,0]\n<strong>输出:</strong> 1\n<strong>解释:</strong>\n将数组分成2块或者更多块，都无法得到所需的结果。\n例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> arr = [1,0,2,3,4]\n<strong>输出:</strong> 4\n<strong>解释:</strong>\n我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。\n然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。\n对每个块单独排序后，结果为 [0, 1], [2], [3], [4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>n == arr.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10</code></li>\n\t<li><code>0 &lt;= arr[i] &lt; n</code></li>\n\t<li><code>arr</code>&nbsp;中每个元素都 <strong>不同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 770.基本计算器 IV",
        "hardRate": "HARD",
        "passRate": "56.10%",
        "problemsUrl": "https://leetcode.cn/problems/basic-calculator-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/basic-calculator-iv/solution",
        "problemsDesc": "<p>给定一个表达式如&nbsp;<code>expression = \"e + 8 - a + 5\"</code>&nbsp;和一个求值映射，如&nbsp;<code>{\"e\": 1}</code>（给定的形式为&nbsp;<code>evalvars = [\"e\"]</code> 和&nbsp;<code>evalints = [1]</code>），返回表示简化表达式的标记列表，例如 <code>[\"-1*a\",\"14\"]</code></p>\n\n<ul>\n\t<li>表达式交替使用块和符号，每个块和符号之间有一个空格。</li>\n\t<li>块要么是括号中的表达式，要么是变量，要么是非负整数。</li>\n\t<li>变量是一个由小写字母组成的字符串（不包括数字）。请注意，变量可以是多个字母，并注意变量从不具有像&nbsp;<code>\"2x\"</code>&nbsp;或&nbsp;<code>\"-x\"</code>&nbsp;这样的前导系数或一元运算符&nbsp;。</li>\n</ul>\n\n<p>表达式按通常顺序进行求值：先是括号，然后求乘法，再计算加法和减法。</p>\n\n<ul>\n\t<li>例如，<code>expression = \"1 + 2 * 3\"</code>&nbsp;的答案是 <code>[\"7\"]</code>。</li>\n</ul>\n\n<p>输出格式如下：</p>\n\n<ul>\n\t<li>对于系数非零的每个自变量项，我们按字典排序的顺序将自变量写在一个项中。\n\t<ul>\n\t\t<li>例如，我们永远不会写像 <code>“b*a*c”</code> 这样的项，只写 <code>“a*b*c”</code>。</li>\n\t</ul>\n\t</li>\n\t<li>项的次数等于被乘的自变量的数目，并计算重复项。我们先写出答案的最大次数项，用字典顺序打破关系，此时忽略词的前导系数。\n\t<ul>\n\t\t<li>例如，<code>\"a*a*b*c\"</code> 的次数为 4。</li>\n\t</ul>\n\t</li>\n\t<li>项的前导系数直接放在左边，用星号将它与变量分隔开(如果存在的话)。前导系数 1 仍然要打印出来。</li>\n\t<li>格式良好的一个示例答案是&nbsp;<code>[\"-2*a*a*a\", \"3*a*a*b\", \"3*b*b\", \"4*a\", \"5*c\", \"-6\"]</code>&nbsp;。</li>\n\t<li>系数为 <code>0</code> 的项（包括常数项）不包括在内。\n\t<ul>\n\t\t<li>例如，<code>“0”</code> 的表达式输出为&nbsp;<code>[]</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p><strong>注意：</strong>你可以假设给定的表达式均有效。所有中间结果都在区间 <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code> 内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"e + 8 - a + 5\", evalvars = [\"e\"], evalints = [1]\n<strong>输出：</strong>[\"-1*a\",\"14\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"e - 8 + temperature - pressure\",\nevalvars = [\"e\", \"temperature\"], evalints = [1, 12]\n<strong>输出：</strong>[\"-1*pressure\",\"5\"]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"(e + 8) * (e - 8)\", evalvars = [], evalints = []\n<strong>输出：</strong>[\"1*e*e\",\"-64\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= expression.length &lt;= 250</code></li>\n\t<li><code>expression</code>&nbsp;由小写英文字母，数字&nbsp;<code>'+'</code>,&nbsp;<code>'-'</code>,&nbsp;<code>'*'</code>,&nbsp;<code>'('</code>,&nbsp;<code>')'</code>,&nbsp;<code>' '</code>&nbsp;组成</li>\n\t<li><code>expression</code>&nbsp;不包含任何前空格或后空格</li>\n\t<li><code>expression</code>&nbsp;中的所有符号都用一个空格隔开</li>\n\t<li><code>0 &lt;= evalvars.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= evalvars[i].length &lt;= 20</code></li>\n\t<li><code>evalvars[i]</code>&nbsp;由小写英文字母组成</li>\n\t<li><code>evalints.length == evalvars.length</code></li>\n\t<li><code>-100 &lt;= evalints[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 771.宝石与石头",
        "hardRate": "EASY",
        "passRate": "85.13%",
        "problemsUrl": "https://leetcode.cn/problems/jewels-and-stones/",
        "solutionsUrl": "https://leetcode.cn/problems/jewels-and-stones/solution",
        "problemsDesc": "<p>&nbsp;给你一个字符串 <code>jewels</code>&nbsp;代表石头中宝石的类型，另有一个字符串 <code>stones</code> 代表你拥有的石头。&nbsp;<code>stones</code>&nbsp;中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p>\n\n<p>字母区分大小写，因此 <code>\"a\"</code> 和 <code>\"A\"</code> 是不同类型的石头。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>jewels = \"aA\", stones = \"aAAbbbb\"\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>jewels = \"z\", stones = \"ZZ\"\n<strong>输出：</strong>0<strong>\n</strong></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;jewels.length, stones.length &lt;= 50</code></li>\n\t<li><code>jewels</code> 和 <code>stones</code> 仅由英文字母组成</li>\n\t<li><code>jewels</code> 中的所有字符都是 <strong>唯一的</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 772.基本计算器 III",
        "hardRate": "HARD",
        "passRate": "53.02%",
        "problemsUrl": "https://leetcode.cn/problems/basic-calculator-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/basic-calculator-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 773.滑动谜题",
        "hardRate": "HARD",
        "passRate": "70.18%",
        "problemsUrl": "https://leetcode.cn/problems/sliding-puzzle/",
        "solutionsUrl": "https://leetcode.cn/problems/sliding-puzzle/solution",
        "problemsDesc": "<p>在一个 <code>2 x 3</code> 的板上（<code>board</code>）有 5 块砖瓦，用数字 <code>1~5</code> 来表示, 以及一块空缺用&nbsp;<code>0</code>&nbsp;来表示。一次 <strong>移动</strong> 定义为选择&nbsp;<code>0</code>&nbsp;与一个相邻的数字（上下左右）进行交换.</p>\n\n<p>最终当板&nbsp;<code>board</code>&nbsp;的结果是&nbsp;<code>[[1,2,3],[4,5,0]]</code>&nbsp;谜板被解开。</p>\n\n<p>给出一个谜板的初始状态&nbsp;<code>board</code>&nbsp;，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/29/slide1-grid.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>board = [[1,2,3],[4,0,5]]\n<strong>输出：</strong>1\n<strong>解释：</strong>交换 0 和 5 ，1 步完成\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/29/slide2-grid.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>board = [[1,2,3],[5,4,0]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>没有办法完成谜板\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/29/slide3-grid.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>board = [[4,1,2],[5,0,3]]\n<strong>输出：</strong>5\n<strong>解释：</strong>\n最少完成谜板的最少移动次数是 5 ，\n一种移动路径:\n尚未移动: [[4,1,2],[5,0,3]]\n移动 1 次: [[4,1,2],[0,5,3]]\n移动 2 次: [[0,1,2],[4,5,3]]\n移动 3 次: [[1,0,2],[4,5,3]]\n移动 4 次: [[1,2,0],[4,5,3]]\n移动 5 次: [[1,2,3],[4,5,0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>board.length == 2</code></li>\n\t<li><code>board[i].length == 3</code></li>\n\t<li><code>0 &lt;= board[i][j] &lt;= 5</code></li>\n\t<li><code>board[i][j]</code>&nbsp;中每个值都 <strong>不同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 774.最小化去加油站的最大距离",
        "hardRate": "HARD",
        "passRate": "63.87%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-max-distance-to-gas-station/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-max-distance-to-gas-station/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 775.全局倒置与局部倒置",
        "hardRate": "MEDIUM",
        "passRate": "49.43%",
        "problemsUrl": "https://leetcode.cn/problems/global-and-local-inversions/",
        "solutionsUrl": "https://leetcode.cn/problems/global-and-local-inversions/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，表示由范围 <code>[0, n - 1]</code> 内所有整数组成的一个排列。</p>\n\n<p><strong>全局倒置</strong> 的数目等于满足下述条件不同下标对 <code>(i, j)</code> 的数目：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; n</code></li>\n\t<li><code>nums[i] &gt; nums[j]</code></li>\n</ul>\n\n<p><strong>局部倒置</strong> 的数目等于满足下述条件的下标 <code>i</code> 的数目：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; n - 1</code></li>\n\t<li><code>nums[i] &gt; nums[i + 1]</code></li>\n</ul>\n\n<p>当数组 <code>nums</code> 中 <strong>全局倒置</strong> 的数量等于 <strong>局部倒置</strong> 的数量时，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,0,2]\n<strong>输出：</strong>true\n<strong>解释：</strong>有 1 个全局倒置，和 1 个局部倒置。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,0]\n<strong>输出：</strong>false\n<strong>解释：</strong>有 2 个全局倒置，和 1 个局部倒置。\n</pre>\n&nbsp;\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt; n</code></li>\n\t<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>\n\t<li><code>nums</code> 是范围 <code>[0, n - 1]</code> 内所有数字组成的一个排列</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 776.拆分二叉搜索树",
        "hardRate": "MEDIUM",
        "passRate": "59.85%",
        "problemsUrl": "https://leetcode.cn/problems/split-bst/",
        "solutionsUrl": "https://leetcode.cn/problems/split-bst/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 777.在LR字符串中交换相邻字符",
        "hardRate": "MEDIUM",
        "passRate": "38.38%",
        "problemsUrl": "https://leetcode.cn/problems/swap-adjacent-in-lr-string/",
        "solutionsUrl": "https://leetcode.cn/problems/swap-adjacent-in-lr-string/solution",
        "problemsDesc": "<p>在一个由 <code>&#39;L&#39;</code> , <code>&#39;R&#39;</code> 和 <code>&#39;X&#39;</code> 三个字符组成的字符串（例如<code>&quot;RXXLRXRXL&quot;</code>）中进行移动操作。一次移动操作指用一个<code>&quot;LX&quot;</code>替换一个<code>&quot;XL&quot;</code>，或者用一个<code>&quot;XR&quot;</code>替换一个<code>&quot;RX&quot;</code>。现给定起始字符串<code>start</code>和结束字符串<code>end</code>，请编写代码，当且仅当存在一系列移动操作使得<code>start</code>可以转换成<code>end</code>时， 返回<code>True</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 :</strong></p>\n\n<pre><strong>输入:</strong> start = &quot;RXXLRXRXL&quot;, end = &quot;XRLXXRRLX&quot;\n<strong>输出:</strong> True\n<strong>解释:</strong>\n我们可以通过以下几步将start转换成end:\nRXXLRXRXL -&gt;\nXRXLRXRXL -&gt;\nXRLXRXRXL -&gt;\nXRLXXRRXL -&gt;\nXRLXXRRLX\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= len(start) = len(end) &lt;= 10000</code>。</li>\n\t<li><code>start</code>和<code>end</code>中的字符串仅限于<code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>和<code>&#39;X&#39;</code>。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 778.水位上升的泳池中游泳",
        "hardRate": "HARD",
        "passRate": "59.07%",
        "problemsUrl": "https://leetcode.cn/problems/swim-in-rising-water/",
        "solutionsUrl": "https://leetcode.cn/problems/swim-in-rising-water/solution",
        "problemsDesc": "<p>在一个 <code>n x n</code>&nbsp;的整数矩阵&nbsp;<code>grid</code> 中，每一个方格的值 <code>grid[i][j]</code> 表示位置 <code>(i, j)</code> 的平台高度。</p>\n\n<p>当开始下雨时，在时间为&nbsp;<code>t</code>&nbsp;时，水池中的水位为&nbsp;<code>t</code>&nbsp;。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。</p>\n\n<p>你从坐标方格的左上平台&nbsp;<code>(0，0)</code> 出发。返回 <em>你到达坐标方格的右下平台&nbsp;<code>(n-1, n-1)</code>&nbsp;所需的最少时间 。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/29/swim1-grid.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> grid = [[0,2],[1,3]]\n<strong>输出:</strong> 3\n<strong>解释:</strong>\n时间为0时，你位于坐标方格的位置为 <code>(0, 0)。</code>\n此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。\n等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/29/swim2-grid-1.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]\n<strong>输出:</strong> 16\n<strong>解释: </strong>最终的路线用加粗进行了标记。\n我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;&nbsp;n<sup>2</sup></code></li>\n\t<li><code>grid[i][j]</code>&nbsp;中每个值&nbsp;<strong>均无重复</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 779.第K个语法符号",
        "hardRate": "MEDIUM",
        "passRate": "49.74%",
        "problemsUrl": "https://leetcode.cn/problems/k-th-symbol-in-grammar/",
        "solutionsUrl": "https://leetcode.cn/problems/k-th-symbol-in-grammar/solution",
        "problemsDesc": "<p>我们构建了一个包含 <code>n</code> 行(&nbsp;<strong>索引从 1&nbsp; 开始&nbsp;</strong>)的表。首先在第一行我们写上一个 <code>0</code>。接下来的每一行，将前一行中的<code>0</code>替换为<code>01</code>，<code>1</code>替换为<code>10</code>。</p>\n\n<ul>\n\t<li>例如，对于 <code>n = 3</code> ，第 <code>1</code> 行是 <code>0</code> ，第 <code>2</code> 行是 <code>01</code> ，第3行是 <code>0110</code> 。</li>\n</ul>\n\n<p>给定行数&nbsp;<code>n</code>&nbsp;和序数 <code>k</code>，返回第 <code>n</code> 行中第 <code>k</code>&nbsp;个字符。（&nbsp;<code>k</code>&nbsp;<strong>从索引 1 开始</strong>）</p>\n\n<p><br />\n<strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 1, k = 1\n<strong>输出:</strong> 0\n<strong>解释: </strong>第一行：<u>0</u>\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 2, k = 1\n<strong>输出:</strong> 0\n<strong>解释:</strong> \n第一行: 0 \n第二行: <u>0</u>1\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 2, k = 2\n<strong>输出:</strong> 1\n<strong>解释:</strong>\n第一行: 0\n第二行: 0<u>1</u>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n\t<li><code>1 &lt;= k &lt;= 2<sup>n - 1</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 780.到达终点",
        "hardRate": "HARD",
        "passRate": "37.64%",
        "problemsUrl": "https://leetcode.cn/problems/reaching-points/",
        "solutionsUrl": "https://leetcode.cn/problems/reaching-points/solution",
        "problemsDesc": "<p>给定四个整数&nbsp;<code>sx</code>&nbsp;,&nbsp;<code>sy</code>&nbsp;，<code>tx</code>&nbsp;和&nbsp;<code>ty</code>，如果通过一系列的<strong>转换</strong>可以从起点&nbsp;<code>(sx, sy)</code>&nbsp;到达终点&nbsp;<code>(tx, ty)</code>，则返回 <code>true</code>，否则返回&nbsp;<code>false</code>。</p>\n\n<p>从点&nbsp;<code>(x, y)</code>&nbsp;可以<strong>转换</strong>到&nbsp;<code>(x, x+y)</code>&nbsp; 或者&nbsp;<code>(x+y, y)</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> sx = 1, sy = 1, tx = 3, ty = 5\n<strong>输出:</strong> true\n<strong>解释:\n</strong>可以通过以下一系列<strong>转换</strong>从起点转换到终点：\n(1, 1) -&gt; (1, 2)\n(1, 2) -&gt; (3, 2)\n(3, 2) -&gt; (3, 5)\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> sx = 1, sy = 1, tx = 2, ty = 2 \n<strong>输出:</strong> false\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> sx = 1, sy = 1, tx = 1, ty = 1 \n<strong>输出:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sx, sy, tx, ty &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 781.森林中的兔子",
        "hardRate": "MEDIUM",
        "passRate": "58.86%",
        "problemsUrl": "https://leetcode.cn/problems/rabbits-in-forest/",
        "solutionsUrl": "https://leetcode.cn/problems/rabbits-in-forest/solution",
        "problemsDesc": "<p>森林中有未知数量的兔子。提问其中若干只兔子<strong> \"还有多少只兔子与你（指被提问的兔子）颜色相同?\"</strong> ，将答案收集到一个整数数组 <code>answers</code> 中，其中 <code>answers[i]</code> 是第 <code>i</code> 只兔子的回答。</p>\n\n<p>给你数组 <code>answers</code> ，返回森林中兔子的最少数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>answers = [1,1,2]\n<strong>输出：</strong>5\n<strong>解释：</strong>\n两只回答了 \"1\" 的兔子可能有相同的颜色，设为红色。 \n之后回答了 \"2\" 的兔子不会是红色，否则他们的回答会相互矛盾。\n设回答了 \"2\" 的兔子为蓝色。 \n此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。 \n因此森林中兔子的最少数量是 5 只：3 只回答的和 2 只没有回答的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>answers = [10,10,10]\n<strong>输出：</strong>11\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= answers.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= answers[i] &lt; 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 782.变为棋盘",
        "hardRate": "HARD",
        "passRate": "59.64%",
        "problemsUrl": "https://leetcode.cn/problems/transform-to-chessboard/",
        "solutionsUrl": "https://leetcode.cn/problems/transform-to-chessboard/solution",
        "problemsDesc": "<p>一个&nbsp;<code>n x n</code>&nbsp;的二维网络&nbsp;<code>board</code>&nbsp;仅由&nbsp;<code>0</code>&nbsp;和&nbsp;<code>1</code>&nbsp;组成&nbsp;。每次移动，你能任意交换两列或是两行的位置。</p>\n\n<p>返回 <em>将这个矩阵变为<strong>&nbsp; “棋盘”&nbsp;&nbsp;</strong>所需的最小移动次数&nbsp;</em>。如果不存在可行的变换，输出 <code>-1</code>。</p>\n\n<p><strong>“棋盘”</strong> 是指任意一格的上下左右四个方向的值均与本身不同的矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/29/chessboard1-grid.jpg\" style=\"height: 145px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入:</strong> board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]\n<strong>输出:</strong> 2\n<strong>解释:</strong>一种可行的变换方式如下，从左到右：\n第一次移动交换了第一列和第二列。\n第二次移动交换了第二行和第三行。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/29/chessboard2-grid.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> board = [[0, 1], [1, 0]]\n<strong>输出:</strong> 0\n<strong>解释: </strong>注意左上角的格值为0时也是合法的棋盘，也是合法的棋盘.\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/29/chessboard3-grid.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> board = [[1, 0], [1, 0]]\n<strong>输出:</strong> -1\n<strong>解释: </strong>任意的变换都不能使这个输入变为合法的棋盘。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 30</code></li>\n\t<li><code>board[i][j]</code>&nbsp;将只包含&nbsp;<code>0</code>或&nbsp;<code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 783.二叉搜索树节点最小距离",
        "hardRate": "EASY",
        "passRate": "60.13%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-distance-between-bst-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-distance-between-bst-nodes/solution",
        "problemsDesc": "<p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p>\n\n<p>差值是一个正数，其数值等于两值之差的绝对值。</p>\n\n<p>&nbsp;</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg\" style=\"width: 292px; height: 301px;\" />\n<pre>\n<strong>输入：</strong>root = [4,2,6,1,3]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg\" style=\"width: 282px; height: 301px;\" />\n<pre>\n<strong>输入：</strong>root = [1,0,48,null,null,12,49]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目范围是 <code>[2, 100]</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与 530：<a href=\"https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/\">https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/</a> 相同</p>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 784.字母大小写全排列",
        "hardRate": "MEDIUM",
        "passRate": "72.57%",
        "problemsUrl": "https://leetcode.cn/problems/letter-case-permutation/",
        "solutionsUrl": "https://leetcode.cn/problems/letter-case-permutation/solution",
        "problemsDesc": "<p>给定一个字符串&nbsp;<code>s</code>&nbsp;，通过将字符串&nbsp;<code>s</code>&nbsp;中的每个字母转变大小写，我们可以获得一个新的字符串。</p>\n\n<p>返回 <em>所有可能得到的字符串集合</em> 。以 <strong>任意顺序</strong> 返回输出。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a1b2\"\n<strong>输出：</strong>[\"a1b2\", \"a1B2\", \"A1b2\", \"A1B2\"]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"3z4\"\n<strong>输出:</strong> [\"3z4\",\"3Z4\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 12</code></li>\n\t<li><code>s</code>&nbsp;由小写英文字母、大写英文字母和数字组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 785.判断二分图",
        "hardRate": "MEDIUM",
        "passRate": "54.67%",
        "problemsUrl": "https://leetcode.cn/problems/is-graph-bipartite/",
        "solutionsUrl": "https://leetcode.cn/problems/is-graph-bipartite/solution",
        "problemsDesc": "存在一个 <strong>无向图</strong> ，图中有 <code>n</code> 个节点。其中每个节点都有一个介于 <code>0</code> 到 <code>n - 1</code> 之间的唯一编号。给你一个二维数组 <code>graph</code> ，其中 <code>graph[u]</code> 是一个节点数组，由节点 <code>u</code> 的邻接节点组成。形式上，对于 <code>graph[u]</code> 中的每个 <code>v</code> ，都存在一条位于节点 <code>u</code> 和节点 <code>v</code> 之间的无向边。该无向图同时具有以下属性：\n<ul>\n\t<li>不存在自环（<code>graph[u]</code> 不包含 <code>u</code>）。</li>\n\t<li>不存在平行边（<code>graph[u]</code> 不包含重复值）。</li>\n\t<li>如果 <code>v</code> 在 <code>graph[u]</code> 内，那么 <code>u</code> 也应该在 <code>graph[v]</code> 内（该图是无向图）</li>\n\t<li>这个图可能不是连通图，也就是说两个节点 <code>u</code> 和 <code>v</code> 之间可能不存在一条连通彼此的路径。</li>\n</ul>\n\n<p><strong>二分图</strong> 定义：如果能将一个图的节点集合分割成两个独立的子集 <code>A</code> 和 <code>B</code> ，并使图中的每一条边的两个节点一个来自 <code>A</code> 集合，一个来自 <code>B</code> 集合，就将这个图称为 <strong>二分图</strong> 。</p>\n\n<p>如果图是二分图，返回 <code>true</code><em> </em>；否则，返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg\" style=\"width: 222px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\n<strong>输出：</strong>false\n<strong>解释：</strong><code>不能将节点分割成两个独立的子集，</code>以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg\" style=\"width: 222px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>graph = [[1,3],[0,2],[1,3],[0,2]]\n<strong>输出：</strong>true\n<strong>解释：</strong><code>可以将节点分成两组: {0, 2} 和 {1, 3} 。</code></pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>graph.length == n</code></li>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>0 <= graph[u].length < n</code></li>\n\t<li><code>0 <= graph[u][i] <= n - 1</code></li>\n\t<li><code>graph[u]</code> 不会包含 <code>u</code></li>\n\t<li><code>graph[u]</code> 的所有值 <strong>互不相同</strong></li>\n\t<li>如果 <code>graph[u]</code> 包含 <code>v</code>，那么 <code>graph[v]</code> 也会包含 <code>u</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 786.第 K 个最小的素数分数",
        "hardRate": "MEDIUM",
        "passRate": "67.59%",
        "problemsUrl": "https://leetcode.cn/problems/k-th-smallest-prime-fraction/",
        "solutionsUrl": "https://leetcode.cn/problems/k-th-smallest-prime-fraction/solution",
        "problemsDesc": "<p>给你一个按递增顺序排序的数组 <code>arr</code> 和一个整数 <code>k</code> 。数组 <code>arr</code> 由 <code>1</code> 和若干 <strong>素数</strong>&nbsp; 组成，且其中所有整数互不相同。</p>\n\n<p>对于每对满足 <code>0 &lt;= i &lt; j &lt; arr.length</code> 的 <code>i</code> 和 <code>j</code> ，可以得到分数 <code>arr[i] / arr[j]</code> 。</p>\n\n<p>那么第&nbsp;<code>k</code>&nbsp;个最小的分数是多少呢?&nbsp; 以长度为 <code>2</code> 的整数数组返回你的答案, 这里&nbsp;<code>answer[0] == arr[i]</code>&nbsp;且&nbsp;<code>answer[1] == arr[j]</code> 。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,5], k = 3\n<strong>输出：</strong>[2,5]\n<strong>解释：</strong>已构造好的分数,排序后如下所示: \n1/5, 1/3, 2/5, 1/2, 3/5, 2/3\n很明显第三个最小的分数是 2/5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,7], k = 1\n<strong>输出：</strong>[1,7]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>arr[0] == 1</code></li>\n\t<li><code>arr[i]</code> 是一个 <strong>素数</strong> ，<code>i &gt; 0</code></li>\n\t<li><code>arr</code> 中的所有数字 <strong>互不相同</strong> ，且按 <strong>严格递增</strong> 排序</li>\n\t<li><code>1 &lt;= k &lt;= arr.length * (arr.length - 1) / 2</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以设计并实现时间复杂度小于 <code>O(n<sup>2</sup>)</code> 的算法解决此问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 787.K 站中转内最便宜的航班",
        "hardRate": "MEDIUM",
        "passRate": "39.68%",
        "problemsUrl": "https://leetcode.cn/problems/cheapest-flights-within-k-stops/",
        "solutionsUrl": "https://leetcode.cn/problems/cheapest-flights-within-k-stops/solution",
        "problemsDesc": "<p>有 <code>n</code> 个城市通过一些航班连接。给你一个数组&nbsp;<code>flights</code> ，其中&nbsp;<code>flights[i] = [from<sub>i</sub>, to<sub>i</sub>, price<sub>i</sub>]</code> ，表示该航班都从城市 <code>from<sub>i</sub></code> 开始，以价格 <code>price<sub>i</sub></code> 抵达 <code>to<sub>i</sub></code>。</p>\n\n<p>现在给定所有的城市和航班，以及出发城市 <code>src</code> 和目的地 <code>dst</code>，你的任务是找到出一条最多经过 <code>k</code>&nbsp;站中转的路线，使得从 <code>src</code> 到 <code>dst</code> 的 <strong>价格最便宜</strong> ，并返回该价格。 如果不存在这样的路线，则输出 <code>-1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> \nn = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]\nsrc = 0, dst = 2, k = 1\n<strong>输出:</strong> 200\n<strong>解释:</strong> \n城市航班图如下\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png\" style=\"height: 180px; width: 246px;\" />\n\n从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> \nn = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]\nsrc = 0, dst = 2, k = 0\n<strong>输出:</strong> 500\n<strong>解释:</strong> \n城市航班图如下\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png\" style=\"height: 180px; width: 246px;\" />\n\n从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= flights.length &lt;= (n * (n - 1) / 2)</code></li>\n\t<li><code>flights[i].length == 3</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt; n</code></li>\n\t<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>\n\t<li><code>1 &lt;= price<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li>航班没有重复，且不存在自环</li>\n\t<li><code>0 &lt;= src, dst, k &lt; n</code></li>\n\t<li><code>src != dst</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 788.旋转数字",
        "hardRate": "MEDIUM",
        "passRate": "66.23%",
        "problemsUrl": "https://leetcode.cn/problems/rotated-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/rotated-digits/solution",
        "problemsDesc": "<p>我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。</p>\n\n<p>如果一个数的每位数字被旋转以后仍然还是一个数字，&nbsp;则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，2 和 5 互为镜像）；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。</p>\n\n<p>现在我们有一个正整数&nbsp;<code>N</code>, 计算从&nbsp;<code>1</code> 到&nbsp;<code>N</code> 中有多少个数&nbsp;X 是好数？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入:</strong> 10\n<strong>输出:</strong> 4\n<strong>解释:</strong> \n在[1, 10]中有四个好数： 2, 5, 6, 9。\n注意 1 和 10 不是好数, 因为他们在旋转之后不变。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>N&nbsp;的取值范围是&nbsp;<code>[1, 10000]</code>。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 789.逃脱阻碍者",
        "hardRate": "MEDIUM",
        "passRate": "68.49%",
        "problemsUrl": "https://leetcode.cn/problems/escape-the-ghosts/",
        "solutionsUrl": "https://leetcode.cn/problems/escape-the-ghosts/solution",
        "problemsDesc": "<p>你在进行一个简化版的吃豆人游戏。你从 <code>[0, 0]</code> 点开始出发，你的目的地是&nbsp;<code>target = [x<sub>target</sub>, y<sub>target</sub>]</code> 。地图上有一些阻碍者，以数组 <code>ghosts</code> 给出，第 <code>i</code> 个阻碍者从&nbsp;<code>ghosts[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;出发。所有输入均为 <strong>整数坐标</strong> 。</p>\n\n<p>每一回合，你和阻碍者们可以同时向东，西，南，北四个方向移动，每次可以移动到距离原位置 <strong>1 个单位</strong> 的新位置。当然，也可以选择 <strong>不动</strong> 。所有动作 <strong>同时</strong> 发生。</p>\n\n<p>如果你可以在任何阻碍者抓住你 <strong>之前</strong> 到达目的地（阻碍者可以采取任意行动方式），则被视为逃脱成功。如果你和阻碍者 <strong>同时</strong> 到达了一个位置（包括目的地）&nbsp;<strong>都不算</strong>&nbsp;是逃脱成功。</p>\n\n<p>如果不管阻碍者怎么移动都可以成功逃脱时，输出 <code>true</code> ；否则，输出 <code>false</code> 。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>ghosts = [[1,0],[0,3]], target = [0,1]\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以直接一步到达目的地 (0,1) ，在 (1, 0) 或者 (0, 3) 位置的阻碍者都不可能抓住你。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>ghosts = [[1,0]], target = [2,0]\n<strong>输出：</strong>false\n<strong>解释：</strong>你需要走到位于 (2, 0) 的目的地，但是在 (1, 0) 的阻碍者位于你和目的地之间。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>ghosts = [[2,0]], target = [1,0]\n<strong>输出：</strong>false\n<strong>解释：</strong>阻碍者可以和你同时达到目的地。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= ghosts.length &lt;= 100</code></li>\n\t<li><code>ghosts[i].length == 2</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li>同一位置可能有 <strong>多个阻碍者</strong> 。</li>\n\t<li><code>target.length == 2</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sub>target</sub>, y<sub>target</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 790.多米诺和托米诺平铺",
        "hardRate": "MEDIUM",
        "passRate": "55.66%",
        "problemsUrl": "https://leetcode.cn/problems/domino-and-tromino-tiling/",
        "solutionsUrl": "https://leetcode.cn/problems/domino-and-tromino-tiling/solution",
        "problemsDesc": "<p>有两种形状的瓷砖：一种是&nbsp;<code>2 x 1</code> 的多米诺形，另一种是形如&nbsp;\"L\" 的托米诺形。两种形状都可以旋转。</p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/15/lc-domino.jpg\" style=\"height: 195px; width: 362px;\" /></p>\n\n<p>给定整数 n ，返回可以平铺&nbsp;<code>2 x n</code> 的面板的方法的数量。<strong>返回对</strong>&nbsp;<code>10<sup>9</sup>&nbsp;+ 7</code>&nbsp;<strong>取模&nbsp;</strong>的值。</p>\n\n<p>平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/15/lc-domino1.jpg\" style=\"height: 226px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入:</strong> n = 3\n<strong>输出:</strong> 5\n<strong>解释:</strong> 五种不同的方法如上所示。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 1\n<strong>输出:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 791.自定义字符串排序",
        "hardRate": "MEDIUM",
        "passRate": "74.18%",
        "problemsUrl": "https://leetcode.cn/problems/custom-sort-string/",
        "solutionsUrl": "https://leetcode.cn/problems/custom-sort-string/solution",
        "problemsDesc": "<p>给定两个字符串 <code>order</code> 和 <code>s</code> 。<code>order</code> 的所有字母都是 <strong>唯一</strong> 的，并且以前按照一些自定义的顺序排序。</p>\n\n<p>对 <code>s</code> 的字符进行置换，使其与排序的&nbsp;<code>order</code>&nbsp;相匹配。更具体地说，如果在&nbsp;<code>order</code>&nbsp;中的字符 <code>x</code> 出现字符 <code>y</code> 之前，那么在排列后的字符串中， <code>x</code>&nbsp;也应该出现在 <code>y</code> 之前。</p>\n\n<p>返回 <em>满足这个性质的 <code>s</code> 的任意一种排列&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> order = \"cba\", s = \"abcd\"\n<strong>输出:</strong> \"cbad\"\n<strong>解释:</strong> \n“a”、“b”、“c”是按顺序出现的，所以“a”、“b”、“c”的顺序应该是“c”、“b”、“a”。\n因为“d”不是按顺序出现的，所以它可以在返回的字符串中的任何位置。“dcba”、“cdba”、“cbda”也是有效的输出。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> order = \"cbafg\", s = \"abcd\"\n<strong>输出:</strong> \"cbad\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= order.length &lt;= 26</code></li>\n\t<li><code>1 &lt;= s.length &lt;= 200</code></li>\n\t<li><code>order</code>&nbsp;和&nbsp;<code>s</code>&nbsp;由小写英文字母组成</li>\n\t<li><code>order</code>&nbsp;中的所有字符都 <strong>不同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 792.匹配子序列的单词数",
        "hardRate": "MEDIUM",
        "passRate": "51.02%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-matching-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-matching-subsequences/solution",
        "problemsDesc": "<p>给定字符串 <code>s</code>&nbsp;和字符串数组&nbsp;<code>words</code>, 返回&nbsp;&nbsp;<em><code>words[i]</code>&nbsp;中是<code>s</code>的子序列的单词个数</em>&nbsp;。</p>\n\n<p>字符串的 <strong>子序列</strong> 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。</p>\n\n<ul>\n\t<li>例如， <code>“ace”</code> 是 <code>“abcde”</code> 的子序列。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"abcde\", words = [\"a\",\"bb\",\"acd\",\"ace\"]\n<strong>输出:</strong> 3\n<strong>解释:</strong> 有三个是&nbsp;s 的子序列的单词: \"a\", \"acd\", \"ace\"。\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"dsahjpjauf\", words = [\"ahjpjau\",\"ja\",\"ahbwzgqnuk\",\"tnmlanowax\"]\n<strong>输出:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words.length &lt;= 5000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 50</code></li>\n\t<li><code>words[i]</code>和 <font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size: 12.6px; background-color: rgb(249, 242, 244);\">s</span></font>&nbsp;都只由小写字母组成。</li>\n</ul>\n<span style=\"display:block\"><span style=\"height:0px\"><span style=\"position:absolute\">​​​​</span></span></span>",
        "isPlus": false
    },
    {
        "problemsName": " 793.阶乘函数后 K 个零",
        "hardRate": "HARD",
        "passRate": "48.68%",
        "problemsUrl": "https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/",
        "solutionsUrl": "https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/solution",
        "problemsDesc": "<p>&nbsp;<code>f(x)</code>&nbsp;是&nbsp;<code>x!</code>&nbsp;末尾是 0 的数量。回想一下&nbsp;<code>x! = 1 * 2 * 3 * ... * x</code>，且 <code>0! = 1</code>&nbsp;。</p>\n\n<ul>\n\t<li>例如，&nbsp;<code>f(3) = 0</code>&nbsp;，因为 <code>3! = 6</code> 的末尾没有 0 ；而 <code>f(11) = 2</code>&nbsp;，因为 <code>11!= 39916800</code> 末端有 2 个 0 。</li>\n</ul>\n\n<p>给定&nbsp;<code>k</code>，找出返回能满足 <code>f(x) = k</code>&nbsp;的非负整数 <code>x</code>&nbsp;的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong><strong> </strong></p>\n\n<pre>\n<strong>输入：</strong>k = 0<strong>\n输出：</strong>5<strong>\n解释：</strong>0!, 1!, 2!, 3!, 和 4!&nbsp;均符合 k = 0 的条件。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 5\n<strong>输出：</strong>0\n<strong>解释：</strong>没有匹配到这样的 x!，符合 k = 5 的条件。</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> k = 3\n<strong>输出:</strong> 5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 794.有效的井字游戏",
        "hardRate": "MEDIUM",
        "passRate": "38.60%",
        "problemsUrl": "https://leetcode.cn/problems/valid-tic-tac-toe-state/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-tic-tac-toe-state/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>board</code> 表示井字游戏的棋盘。当且仅当在井字游戏过程中，棋盘有可能达到 <code>board</code> 所显示的状态时，才返回 <code>true</code> 。</p>\n\n<p>井字游戏的棋盘是一个 <code>3 x 3</code> 数组，由字符 <code>' '</code>，<code>'X'</code> 和 <code>'O'</code> 组成。字符 <code>' '</code> 代表一个空位。</p>\n\n<p>以下是井字游戏的规则：</p>\n\n<ul>\n\t<li>玩家轮流将字符放入空位（<code>' '</code>）中。</li>\n\t<li>玩家 1 总是放字符 <code>'X'</code> ，而玩家 2 总是放字符 <code>'O'</code> 。</li>\n\t<li><code>'X'</code> 和 <code>'O'</code> 只允许放置在空位中，不允许对已放有字符的位置进行填充。</li>\n\t<li>当有 3 个相同（且非空）的字符填充任何行、列或对角线时，游戏结束。</li>\n\t<li>当所有位置非空时，也算为游戏结束。</li>\n\t<li>如果游戏结束，玩家不允许再放置字符。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/15/tictactoe1-grid.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>输入：</strong>board = [\"O  \",\"   \",\"   \"]\n<strong>输出：</strong>false\n<strong>解释：</strong>玩家 1 总是放字符 \"X\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/15/tictactoe2-grid.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>输入：</strong>board = [\"XOX\",\" X \",\"   \"]\n<strong>输出：</strong>false\n<strong>解释：</strong>玩家应该轮流放字符。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/15/tictactoe4-grid.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>输入：</strong>board = [\"XOX\",\"O O\",\"XOX\"]\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>board.length == 3</code></li>\n\t<li><code>board[i].length == 3</code></li>\n\t<li><code>board[i][j]</code> 为 <code>'X'</code>、<code>'O'</code> 或 <code>' '</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 795.区间子数组个数",
        "hardRate": "MEDIUM",
        "passRate": "57.76%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和两个整数：<code>left</code> 及 <code>right</code> 。找出 <code>nums</code> 中连续、非空且其中最大元素在范围&nbsp;<code>[left, right]</code> 内的子数组，并返回满足条件的子数组的个数。</p>\n\n<p>生成的测试用例保证结果符合 <strong>32-bit</strong> 整数范围。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,4,3], left = 2, right = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>满足条件的三个子数组：[2], [2, 1], [3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,9,2,5,6], left = 2, right = 8\n<strong>输出：</strong>7\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= left &lt;= right &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 796.旋转字符串",
        "hardRate": "EASY",
        "passRate": "63.29%",
        "problemsUrl": "https://leetcode.cn/problems/rotate-string/",
        "solutionsUrl": "https://leetcode.cn/problems/rotate-string/solution",
        "problemsDesc": "<p>给定两个字符串, <code>s</code>&nbsp;和&nbsp;<code>goal</code>。如果在若干次旋转操作之后，<code>s</code>&nbsp;能变成&nbsp;<code>goal</code>&nbsp;，那么返回&nbsp;<code>true</code>&nbsp;。</p>\n\n<p><code>s</code>&nbsp;的 <strong>旋转操作</strong> 就是将&nbsp;<code>s</code> 最左边的字符移动到最右边。&nbsp;</p>\n\n<ul>\n\t<li>例如, 若&nbsp;<code>s = 'abcde'</code>，在旋转一次之后结果就是<code>'bcdea'</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"abcde\", goal = \"cdeab\"\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"abcde\", goal = \"abced\"\n<strong>输出:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, goal.length &lt;= 100</code></li>\n\t<li><code>s</code>&nbsp;和&nbsp;<code>goal</code>&nbsp;由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 797.所有可能的路径",
        "hardRate": "MEDIUM",
        "passRate": "78.88%",
        "problemsUrl": "https://leetcode.cn/problems/all-paths-from-source-to-target/",
        "solutionsUrl": "https://leetcode.cn/problems/all-paths-from-source-to-target/solution",
        "problemsDesc": "<p>给你一个有&nbsp;<code>n</code>&nbsp;个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code>&nbsp;到节点 <code>n-1</code>&nbsp;的路径并输出（<strong>不要求按特定顺序</strong>）</p>\n\n<p><meta charset=\"UTF-8\" />&nbsp;<code>graph[i]</code>&nbsp;是一个从节点 <code>i</code> 可以访问的所有节点的列表（即从节点 <code>i</code> 到节点&nbsp;<code>graph[i][j]</code>存在一条有向边）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,2],[3],[3],[]]\n<strong>输出：</strong>[[0,1,3],[0,2,3]]\n<strong>解释：</strong>有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>graph = [[4,3,1],[3,2,4],[3],[4],[]]\n<strong>输出：</strong>[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == graph.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 15</code></li>\n\t<li><code>0 &lt;= graph[i][j] &lt; n</code></li>\n\t<li><code>graph[i][j] != i</code>（即不存在自环）</li>\n\t<li><code>graph[i]</code> 中的所有元素 <strong>互不相同</strong></li>\n\t<li>保证输入为 <strong>有向无环图（DAG）</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 798.得分最高的最小轮调",
        "hardRate": "HARD",
        "passRate": "61.57%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-rotation-with-highest-score/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-rotation-with-highest-score/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>nums</code>，我们可以将它按一个非负整数 <code>k</code> 进行轮调，这样可以使数组变为&nbsp;<code>[nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]</code>&nbsp;的形式。此后，任何值小于或等于其索引的项都可以记作一分。</p>\n\n<ul>\n\t<li>例如，数组为&nbsp;<code>nums = [2,4,1,3,0]</code>，我们按&nbsp;<code>k = 2</code>&nbsp;进行轮调后，它将变成&nbsp;<code>[1,3,0,2,4]</code>。这将记为 <code>3</code> 分，因为 <code>1 &gt; 0</code> [不计分]、<code>3 &gt; 1</code> [不计分]、<code>0 &lt;= 2</code> [计 1 分]、<code>2 &lt;= 3</code> [计 1 分]，<code>4 &lt;= 4</code> [计 1 分]。</li>\n</ul>\n\n<p>在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调下标 <code>k</code> 。如果有多个答案，返回满足条件的最小的下标 <code>k</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,1,4,0]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n下面列出了每个 k 的得分：\nk = 0,  nums = [2,3,1,4,0],    score 2\nk = 1,  nums = [3,1,4,0,2],    score 3\nk = 2,  nums = [1,4,0,2,3],    score 3\nk = 3,  nums = [4,0,2,3,1],    score 4\nk = 4,  nums = [0,2,3,1,4],    score 3\n所以我们应当选择&nbsp;k = 3，得分最高。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,0,2,4]\n<strong>输出：</strong>0\n<strong>解释：</strong>\nnums 无论怎么变化总是有 3 分。\n所以我们将选择最小的 k，即 0。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt; nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 799.香槟塔",
        "hardRate": "MEDIUM",
        "passRate": "53.00%",
        "problemsUrl": "https://leetcode.cn/problems/champagne-tower/",
        "solutionsUrl": "https://leetcode.cn/problems/champagne-tower/solution",
        "problemsDesc": "<p>我们把玻璃杯摆成金字塔的形状，其中&nbsp;<strong>第一层</strong>&nbsp;有 <code>1</code> 个玻璃杯， <strong>第二层</strong>&nbsp;有 <code>2</code> 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。</p>\n\n<p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p>\n\n<p>例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。</p>\n\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/09/tower.png\" style=\"height: 241px; width: 350px;\" /></p>\n\n<p>现在当倾倒了非负整数杯香槟后，返回第 <code>i</code> 行 <code>j</code>&nbsp;个玻璃杯所盛放的香槟占玻璃杯容积的比例（ <code>i</code> 和 <code>j</code>&nbsp;都从0开始）。</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<strong>示例 1:</strong>\n<strong>输入:</strong> poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1\n<strong>输出:</strong> 0.00000\n<strong>解释:</strong> 我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。\n\n<strong>示例 2:</strong>\n<strong>输入:</strong> poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1\n<strong>输出:</strong> 0.50000\n<strong>解释:</strong> 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。\n</pre>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> poured = 100000009, query_row = 33, query_glass = 17\n<strong>输出:</strong> 1.00000\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;=&nbsp;poured &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= query_glass &lt;= query_row&nbsp;&lt; 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 800.相似 RGB 颜色",
        "hardRate": "EASY",
        "passRate": "70.26%",
        "problemsUrl": "https://leetcode.cn/problems/similar-rgb-color/",
        "solutionsUrl": "https://leetcode.cn/problems/similar-rgb-color/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 801.使序列递增的最小交换次数",
        "hardRate": "HARD",
        "passRate": "50.62%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/solution",
        "problemsDesc": "<p>我们有两个长度相等且不为空的整型数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>&nbsp;。在一次操作中，我们可以交换&nbsp;<code>nums1[i]</code>&nbsp;和&nbsp;<code>nums2[i]</code>的元素。</p>\n\n<ul>\n\t<li>例如，如果 <code>nums1 = [1,2,3,<u>8</u>]</code> ， <code>nums2 =[5,6,7,<u>4</u>]</code> ，你可以交换 <code>i = 3</code> 处的元素，得到 <code>nums1 =[1,2,3,4]</code> 和 <code>nums2 =[5,6,7,8]</code> 。</li>\n</ul>\n\n<p>返回 <em>使 <code>nums1</code> 和 <code>nums2</code> <strong>严格递增&nbsp;</strong>所需操作的最小次数</em> 。</p>\n\n<p>数组&nbsp;<code>arr</code>&nbsp;<strong>严格递增</strong> 且&nbsp;&nbsp;<code>arr[0] &lt; arr[1] &lt; arr[2] &lt; ... &lt; arr[arr.length - 1]</code>&nbsp;。</p>\n\n<p><b>注意：</b></p>\n\n<ul>\n\t<li>用例保证可以实现操作。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums1 = [1,3,5,4], nums2 = [1,2,3,7]\n<strong>输出:</strong> 1\n<strong>解释: </strong>\n交换 A[3] 和 B[3] 后，两个数组如下:\nA = [1, 3, 5, 7] ， B = [1, 2, 3, 4]\n两个数组均为严格递增的。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums1 = [0,3,5,8,9], nums2 = [2,1,4,6,9]\n<strong>输出:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums1.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums2.length == nums1.length</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 2 * 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 802.找到最终的安全状态",
        "hardRate": "MEDIUM",
        "passRate": "59.18%",
        "problemsUrl": "https://leetcode.cn/problems/find-eventual-safe-states/",
        "solutionsUrl": "https://leetcode.cn/problems/find-eventual-safe-states/solution",
        "problemsDesc": "<p>有一个有 <code>n</code> 个节点的有向图，节点按 <code>0</code> 到 <code>n - 1</code> 编号。图由一个 <strong>索引从 0 开始</strong> 的 2D 整数数组&nbsp;<code>graph</code>表示，&nbsp;<code>graph[i]</code>是与节点 <code>i</code> 相邻的节点的整数数组，这意味着从节点 <code>i</code> 到&nbsp;<code>graph[i]</code>中的每个节点都有一条边。</p>\n\n<p>如果一个节点没有连出的有向边，则该节点是 <strong>终端节点</strong> 。如果从该节点开始的所有可能路径都通向 <strong>终端节点</strong> ，则该节点为 <strong>安全节点</strong> 。</p>\n\n<p>返回一个由图中所有 <strong>安全节点</strong> 组成的数组作为答案。答案数组中的元素应当按 <strong>升序</strong> 排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"Illustration of graph\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png\" /></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,2],[2,3],[5],[0],[5],[],[]]\n<strong>输出：</strong>[2,4,5,6]\n<strong>解释：</strong>示意图如上。\n节点 5 和节点 6 是终端节点，因为它们都没有出边。\n从节点 2、4、5 和 6 开始的所有路径都指向节点 5 或 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\n<strong>输出：</strong>[4]\n<strong>解释:</strong>\n只有节点 4 是终端节点，从节点 4 开始的所有路径都通向节点 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == graph.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= graph[i].length &lt;= n</code></li>\n\t<li><code>0 &lt;= graph[i][j] &lt;= n - 1</code></li>\n\t<li><code>graph[i]</code> 按严格递增顺序排列。</li>\n\t<li>图中可能包含自环。</li>\n\t<li>图中边的数目在范围 <code>[1, 4 * 10<sup>4</sup>]</code> 内。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 803.打砖块",
        "hardRate": "HARD",
        "passRate": "47.04%",
        "problemsUrl": "https://leetcode.cn/problems/bricks-falling-when-hit/",
        "solutionsUrl": "https://leetcode.cn/problems/bricks-falling-when-hit/solution",
        "problemsDesc": "<p>有一个 <code>m x n</code> 的二元网格<meta charset=\"UTF-8\" />&nbsp;<code>grid</code>&nbsp;，其中 <code>1</code> 表示砖块，<code>0</code> 表示空白。砖块 <strong>稳定</strong>（不会掉落）的前提是：</p>\n\n<ul>\n\t<li>一块砖直接连接到网格的顶部，或者</li>\n\t<li>至少有一块相邻（4&nbsp;个方向之一）砖块<strong> 稳定 </strong>不会掉落时</li>\n</ul>\n\n<p>给你一个数组 <code>hits</code> ，这是需要依次消除砖块的位置。每当消除&nbsp;<code>hits[i] = (rowi, coli)</code> 位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而 <strong>掉落</strong> 。一旦砖块掉落，它会 <strong>立即</strong> 从网格&nbsp;<code>grid</code>&nbsp;中消失（即，它不会落在其他稳定的砖块上）。</p>\n\n<p>返回一个数组 <code>result</code> ，其中 <code>result[i]</code> 表示第 <code>i</code> 次消除操作对应掉落的砖块数目。</p>\n\n<p><strong>注意</strong>，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]\n<strong>输出：</strong>[2]\n<strong>解释：</strong>网格开始为：\n[[1,0,0,0]，\n [<strong>1</strong>,1,1,0]]\n消除 (1,0) 处加粗的砖块，得到网格：\n[[1,0,0,0]\n [0,<strong>1</strong>,<strong>1</strong>,0]]\n两个加粗的砖不再稳定，因为它们不再与顶部相连，也不再与另一个稳定的砖相邻，因此它们将掉落。得到网格：\n[[1,0,0,0],\n [0,0,0,0]]\n因此，结果为 [2] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]\n<strong>输出：</strong>[0,0]\n<strong>解释：</strong>网格开始为：\n[[1,0,0,0],\n [1,<strong>1</strong>,0,0]]\n消除 (1,1) 处加粗的砖块，得到网格：\n[[1,0,0,0],\n [1,0,0,0]]\n剩下的砖都很稳定，所以不会掉落。网格保持不变：\n[[1,0,0,0], \n [<strong>1</strong>,0,0,0]]\n接下来消除 (1,0) 处加粗的砖块，得到网格：\n[[1,0,0,0],\n [0,0,0,0]]\n剩下的砖块仍然是稳定的，所以不会有砖块掉落。\n因此，结果为 [0,0] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n\t<li><code>1 &lt;= hits.length &lt;= 4 * 10<sup>4</sup></code></li>\n\t<li><code>hits[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i&nbsp;</sub>&lt;= m - 1</code></li>\n\t<li><code>0 &lt;=&nbsp;y<sub>i</sub> &lt;= n - 1</code></li>\n\t<li>所有 <code>(x<sub>i</sub>, y<sub>i</sub>)</code> 互不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 804.唯一摩尔斯密码词",
        "hardRate": "EASY",
        "passRate": "82.19%",
        "problemsUrl": "https://leetcode.cn/problems/unique-morse-code-words/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-morse-code-words/solution",
        "problemsDesc": "<p>国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串，&nbsp;比如:</p>\n\n<ul>\n\t<li><code>'a'</code> 对应 <code>\".-\"</code> ，</li>\n\t<li><code>'b'</code> 对应 <code>\"-...\"</code> ，</li>\n\t<li><code>'c'</code> 对应 <code>\"-.-.\"</code> ，以此类推。</li>\n</ul>\n\n<p>为了方便，所有 <code>26</code> 个英文字母的摩尔斯密码表如下：</p>\n\n<pre>\n[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]</pre>\n\n<p>给你一个字符串数组 <code>words</code> ，每个单词可以写成每个字母对应摩尔斯密码的组合。</p>\n\n<ul>\n\t<li>例如，<code>\"cab\"</code> 可以写成 <code>\"-.-..--...\"</code> ，(即 <code>\"-.-.\"</code> + <code>\".-\"</code> + <code>\"-...\"</code> 字符串的结合)。我们将这样一个连接过程称作 <strong>单词翻译</strong> 。</li>\n</ul>\n\n<p>对<strong> </strong><code>words</code> 中所有单词进行单词翻译，返回不同 <strong>单词翻译</strong> 的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> words = [\"gin\", \"zen\", \"gig\", \"msg\"]\n<strong>输出:</strong> 2\n<strong>解释: </strong>\n各单词翻译如下:\n\"gin\" -&gt; \"--...-.\"\n\"zen\" -&gt; \"--...-.\"\n\"gig\" -&gt; \"--...--.\"\n\"msg\" -&gt; \"--...--.\"\n\n共有 2 种不同翻译, \"--...-.\" 和 \"--...--.\".\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"a\"]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 12</code></li>\n\t<li><code>words[i]</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 805.数组的均值分割",
        "hardRate": "HARD",
        "passRate": "42.95%",
        "problemsUrl": "https://leetcode.cn/problems/split-array-with-same-average/",
        "solutionsUrl": "https://leetcode.cn/problems/split-array-with-same-average/solution",
        "problemsDesc": "<p>给定你一个整数数组<meta charset=\"UTF-8\" />&nbsp;<code>nums</code></p>\n\n<p>我们要将<meta charset=\"UTF-8\" />&nbsp;<code>nums</code>&nbsp;数组中的每个元素移动到&nbsp;<code>A</code>&nbsp;数组 或者&nbsp;<code>B</code>&nbsp;数组中，使得&nbsp;<code>A</code>&nbsp;数组和<meta charset=\"UTF-8\" />&nbsp;<code>B</code>&nbsp;数组不为空，并且<meta charset=\"UTF-8\" />&nbsp;<code>average(A) == average(B)</code>&nbsp;。</p>\n\n<p>如果可以完成则返回<code>true</code>&nbsp;， 否则返回 <code>false</code>&nbsp;&nbsp;。</p>\n\n<p><strong>注意：</strong>对于数组<meta charset=\"UTF-8\" />&nbsp;<code>arr</code>&nbsp;, <meta charset=\"UTF-8\" />&nbsp;<code>average(arr)</code>&nbsp;是<meta charset=\"UTF-8\" />&nbsp;<code>arr</code>&nbsp;的所有元素的和除以<meta charset=\"UTF-8\" />&nbsp;<code>arr</code>&nbsp;长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,3,4,5,6,7,8]\n<strong>输出:</strong> true\n<strong>解释: </strong>我们可以将数组分割为 [1,4,5,8] 和 [2,3,6,7], 他们的平均值都是4.5。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [3,1]\n<strong>输出:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 30</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 806.写字符串需要的行数",
        "hardRate": "EASY",
        "passRate": "68.42%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-lines-to-write-string/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-lines-to-write-string/solution",
        "problemsDesc": "<p>我们要把给定的字符串 <code>S</code>&nbsp;从左到右写到每一行上，每一行的最大宽度为100个单位，如果我们在写某个字母的时候会使这行超过了100 个单位，那么我们应该把这个字母写到下一行。我们给定了一个数组&nbsp;<code>widths</code>&nbsp;，这个数组&nbsp;widths[0] 代表 &#39;a&#39; 需要的单位，&nbsp;widths[1] 代表 &#39;b&#39; 需要的单位，...，&nbsp;widths[25] 代表 &#39;z&#39; 需要的单位。</p>\n\n<p>现在回答两个问题：至少多少行能放下<code>S</code>，以及最后一行使用的宽度是多少个单位？将你的答案作为长度为2的整数列表返回。</p>\n\n<pre>\n<strong>示例 1:</strong>\n<strong>输入:</strong> \nwidths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]\nS = &quot;abcdefghijklmnopqrstuvwxyz&quot;\n<strong>输出:</strong> [3, 60]\n<strong>解释: \n</strong>所有的字符拥有相同的占用单位10。所以书写所有的26个字母，\n我们需要2个整行和占用60个单位的一行。\n</pre>\n\n<pre>\n<strong>示例 2:</strong>\n<strong>输入:</strong> \nwidths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]\nS = &quot;bbbcccdddaaa&quot;\n<strong>输出:</strong> [2, 4]\n<strong>解释: \n</strong>除去字母&#39;a&#39;所有的字符都是相同的单位10，并且字符串 &quot;bbbcccdddaa&quot; 将会覆盖 9 * 10 + 2 * 4 = 98 个单位.\n最后一个字母 &#39;a&#39; 将会被写到第二行，因为第一行只剩下2个单位了。\n所以，这个答案是2行，第二行有4个单位宽度。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>注:</strong></p>\n\n<ul>\n\t<li>字符串&nbsp;<code>S</code> 的长度在&nbsp;[1, 1000] 的范围。</li>\n\t<li><code>S</code> 只包含小写字母。</li>\n\t<li><code>widths</code> 是长度为&nbsp;<code>26</code>的数组。</li>\n\t<li><code>widths[i]</code>&nbsp;值的范围在&nbsp;<code>[2, 10]</code>。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 807.保持城市天际线",
        "hardRate": "MEDIUM",
        "passRate": "88.08%",
        "problemsUrl": "https://leetcode.cn/problems/max-increase-to-keep-city-skyline/",
        "solutionsUrl": "https://leetcode.cn/problems/max-increase-to-keep-city-skyline/solution",
        "problemsDesc": "<p>给你一座由 <code>n x n</code> 个街区组成的城市，每个街区都包含一座立方体建筑。给你一个下标从 <strong>0</strong> 开始的 <code>n x n</code> 整数矩阵 <code>grid</code> ，其中 <code>grid[r][c]</code> 表示坐落于 <code>r</code> 行 <code>c</code> 列的建筑物的 <strong>高度</strong> 。</p>\n\n<p>城市的 <strong>天际线</strong> 是从远处观察城市时，所有建筑物形成的外部轮廓。从东、南、西、北四个主要方向观测到的 <strong>天际线</strong> 可能不同。</p>\n\n<p>我们被允许为 <strong>任意数量的建筑物 </strong>的高度增加<strong> 任意增量（不同建筑物的增量可能不同）</strong> 。 高度为 <code>0</code> 的建筑物的高度也可以增加。然而，增加的建筑物高度 <strong>不能影响</strong> 从任何主要方向观察城市得到的 <strong>天际线</strong> 。</p>\n\n<p>在 <strong>不改变</strong> 从任何主要方向观测到的城市 <strong>天际线</strong> 的前提下，返回建筑物可以增加的 <strong>最大高度增量总和</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/21/807-ex1.png\" style=\"width: 700px; height: 603px;\" />\n<pre>\n<strong>输入：</strong>grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]\n<strong>输出：</strong>35\n<strong>解释：</strong>建筑物的高度如上图中心所示。\n用红色绘制从不同方向观看得到的天际线。\n在不影响天际线的情况下，增加建筑物的高度：\ngridNew = [ [8, 4, 8, 7],\n            [7, 4, 7, 7],\n            [9, 4, 8, 7],\n            [3, 3, 3, 3] ]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,0,0],[0,0,0],[0,0,0]]\n<strong>输出：</strong>0\n<strong>解释：</strong>增加任何建筑物的高度都会导致天际线的变化。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[r].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 50</code></li>\n\t<li><code>0 &lt;= grid[r][c] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 808.分汤",
        "hardRate": "MEDIUM",
        "passRate": "58.77%",
        "problemsUrl": "https://leetcode.cn/problems/soup-servings/",
        "solutionsUrl": "https://leetcode.cn/problems/soup-servings/solution",
        "problemsDesc": "<p>有&nbsp;<strong>A&nbsp;和&nbsp;B 两种类型&nbsp;</strong>的汤。一开始每种类型的汤有&nbsp;<code>n</code>&nbsp;毫升。有四种分配操作：</p>\n\n<ol>\n\t<li>提供 <code>100ml</code> 的 <strong>汤A</strong> 和 <code>0ml</code> 的 <strong>汤B</strong> 。</li>\n\t<li>提供 <code>75ml</code> 的 <strong>汤A</strong> 和 <code>25ml</code> 的 <strong>汤B</strong> 。</li>\n\t<li>提供 <code>50ml</code> 的 <strong>汤A</strong> 和 <code>50ml</code> 的 <strong>汤B</strong> 。</li>\n\t<li>提供 <code>25ml</code> 的 <strong>汤A</strong> 和 <code>75ml</code> 的 <strong>汤B</strong> 。</li>\n</ol>\n\n<p>当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为 <code>0.25</code> 的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。</p>\n\n<p><strong>注意&nbsp;</strong>不存在先分配 <code>100</code> ml <strong>汤B</strong> 的操作。</p>\n\n<p>需要返回的值：&nbsp;<strong>汤A&nbsp;</strong>先分配完的概率 +&nbsp;&nbsp;<strong>汤A和汤B&nbsp;</strong>同时分配完的概率 / 2。返回值在正确答案&nbsp;<code>10<sup>-5</sup></code>&nbsp;的范围内将被认为是正确的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 50\n<strong>输出:</strong> 0.62500\n<strong>解释:</strong>如果我们选择前两个操作<strong>，</strong>A 首先将变为空。\n对于第三个操作，A 和 B 会同时变为空。\n对于第四个操作，B 首先将变为空。<strong>\n</strong>所以 A 变为空的总概率加上 A 和 B 同时变为空的概率的一半是 0.25 *(1 + 1 + 0.5 + 0)= 0.625。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 100\n<strong>输出:</strong> 0.71875\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code>​​​​​​​</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 809.情感丰富的文字",
        "hardRate": "MEDIUM",
        "passRate": "48.95%",
        "problemsUrl": "https://leetcode.cn/problems/expressive-words/",
        "solutionsUrl": "https://leetcode.cn/problems/expressive-words/solution",
        "problemsDesc": "<p>有时候人们会用重复写一些字母来表示额外的感受，比如 <code>\"hello\" -&gt; \"heeellooo\"</code>, <code>\"hi\" -&gt; \"hiii\"</code>。我们将相邻字母都相同的一串字符定义为相同字母组，例如：\"h\", \"eee\", \"ll\", \"ooo\"。</p>\n\n<p>对于一个给定的字符串 S ，如果另一个单词能够通过将一些字母组扩张从而使其和 S 相同，我们将这个单词定义为可扩张的（stretchy）。扩张操作定义如下：选择一个字母组（包含字母&nbsp;<code>c</code>&nbsp;），然后往其中添加相同的字母&nbsp;<code>c</code>&nbsp;使其长度达到 3 或以上。</p>\n\n<p>例如，以&nbsp;\"hello\" 为例，我们可以对字母组&nbsp;\"o\" 扩张得到 \"hellooo\"，但是无法以同样的方法得到 \"helloo\" 因为字母组 \"oo\" 长度小于&nbsp;3。此外，我们可以进行另一种扩张 \"ll\" -&gt; \"lllll\" 以获得&nbsp;\"helllllooo\"。如果&nbsp;<code>s = \"helllllooo\"</code>，那么查询词&nbsp;\"hello\" 是可扩张的，因为可以对它执行这两种扩张操作使得&nbsp;<code>query = \"hello\" -&gt; \"hellooo\" -&gt;&nbsp;\"helllllooo\" = s</code>。</p>\n\n<p>输入一组查询单词，输出其中可扩张的单词数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong> \ns = \"heeellooo\"\nwords = [\"hello\", \"hi\", \"helo\"]\n<strong>输出：</strong>1\n<strong>解释</strong>：\n我们能通过扩张 \"hello\" 的 \"e\" 和 \"o\" 来得到 \"heeellooo\"。\n我们不能通过扩张 \"helo\" 来得到 \"heeellooo\" 因为 \"ll\" 的长度小于 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size: 12.6px; background-color: rgb(249, 242, 244);\">s</span></font> 和所有在&nbsp;<code>words</code>&nbsp;中的单词都只由小写字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 810.黑板异或游戏",
        "hardRate": "HARD",
        "passRate": "72.50%",
        "problemsUrl": "https://leetcode.cn/problems/chalkboard-xor-game/",
        "solutionsUrl": "https://leetcode.cn/problems/chalkboard-xor-game/solution",
        "problemsDesc": "<p>黑板上写着一个非负整数数组 <code>nums[i]</code> 。</p>\n\n<p>Alice 和 Bob 轮流从黑板上擦掉一个数字，Alice 先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 <code>0</code> 的话，当前玩家游戏失败。&nbsp;另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为&nbsp;<code>0</code>。</p>\n\n<p>并且，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 <code>0</code> ，这个玩家获胜。</p>\n\n<p>假设两个玩家每步都使用最优解，当且仅当 Alice 获胜时返回 <code>true</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,1,2]\n<strong>输出:</strong> false\n<strong>解释:</strong> \nAlice 有两个选择: 擦掉数字 1 或 2。\n如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 = 3。那么 Bob 可以擦掉任意数字，因为 Alice 会成为擦掉最后一个数字的人，她总是会输。\n如果 Alice 擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 = 0。Alice 仍然会输掉游戏。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [0,1]\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,3]\n<strong>输出:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt; 2<sup>16</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 811.子域名访问计数",
        "hardRate": "MEDIUM",
        "passRate": "76.66%",
        "problemsUrl": "https://leetcode.cn/problems/subdomain-visit-count/",
        "solutionsUrl": "https://leetcode.cn/problems/subdomain-visit-count/solution",
        "problemsDesc": "<p>网站域名 <code>\"discuss.leetcode.com\"</code> 由多个子域名组成。顶级域名为 <code>\"com\"</code> ，二级域名为 <code>\"leetcode.com\"</code> ，最低一级为 <code>\"discuss.leetcode.com\"</code> 。当访问域名 <code>\"discuss.leetcode.com\"</code> 时，同时也会隐式访问其父域名 <code>\"leetcode.com\" </code>以及 <code>\"com\"</code> 。</p>\n\n<p><strong>计数配对域名</strong> 是遵循 <code>\"rep d1.d2.d3\"</code> 或 <code>\"rep d1.d2\"</code> 格式的一个域名表示，其中 <code>rep</code> 表示访问域名的次数，<code>d1.d2.d3</code> 为域名本身。</p>\n\n<ul>\n\t<li>例如，<code>\"9001 discuss.leetcode.com\"</code> 就是一个 <strong>计数配对域名</strong> ，表示 <code>discuss.leetcode.com</code> 被访问了 <code>9001</code> 次。</li>\n</ul>\n\n<p>给你一个<strong> 计数配对域名 </strong>组成的数组 <code>cpdomains</code> ，解析得到输入中每个子域名对应的&nbsp;<strong>计数配对域名</strong> ，并以数组形式返回。可以按 <strong>任意顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>cpdomains = [\"9001 discuss.leetcode.com\"]\n<strong>输出：</strong>[\"9001 leetcode.com\",\"9001 discuss.leetcode.com\",\"9001 com\"]\n<strong>解释：</strong>例子中仅包含一个网站域名：\"discuss.leetcode.com\"。\n按照前文描述，子域名 \"leetcode.com\" 和 \"com\" 都会被访问，所以它们都被访问了 9001 次。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>cpdomains = [\"900 google.mail.com\", \"50 yahoo.com\", \"1 intel.mail.com\", \"5 wiki.org\"]\n<strong>输出：</strong>[\"901 mail.com\",\"50 yahoo.com\",\"900 google.mail.com\",\"5 wiki.org\",\"5 org\",\"1 intel.mail.com\",\"951 com\"]\n<strong>解释：</strong>按照前文描述，会访问 \"google.mail.com\" 900 次，\"yahoo.com\" 50 次，\"intel.mail.com\" 1 次，\"wiki.org\" 5 次。\n而对于父域名，会访问 \"mail.com\" 900 + 1 = 901 次，\"com\" 900 + 50 + 1 = 951 次，和 \"org\" 5 次。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= cpdomain.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= cpdomain[i].length &lt;= 100</code></li>\n\t<li><code>cpdomain[i]</code> 会遵循 <code>\"rep<sub>i</sub> d1<sub>i</sub>.d2<sub>i</sub>.d3<sub>i</sub>\"</code> 或 <code>\"rep<sub>i</sub> d1<sub>i</sub>.d2<sub>i</sub>\"</code> 格式</li>\n\t<li><code>rep<sub>i</sub></code> 是范围 <code>[1, 10<sup>4</sup>]</code> 内的一个整数</li>\n\t<li><code>d1<sub>i</sub></code>、<code>d2<sub>i</sub></code> 和 <code>d3<sub>i</sub></code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 812.最大三角形面积",
        "hardRate": "EASY",
        "passRate": "68.20%",
        "problemsUrl": "https://leetcode.cn/problems/largest-triangle-area/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-triangle-area/solution",
        "problemsDesc": "<p>给你一个由 <strong>X-Y</strong> 平面上的点组成的数组 <code>points</code> ，其中 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 。从其中取任意三个不同的点组成三角形，返回能组成的最大三角形的面积。与真实值误差在 <code>10<sup>-5</sup></code> 内的答案将会视为正确答案<strong>。</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/04/1027.png\" style=\"height: 369px; width: 450px;\" />\n<pre>\n<strong>输入：</strong>points = [[0,0],[0,1],[1,0],[0,2],[2,0]]\n<strong>输出：</strong>2.00000\n<strong>解释：</strong>输入中的 5 个点如上图所示，红色的三角形面积最大。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[1,0],[0,0],[0,1]]\n<strong>输出：</strong>0.50000\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= points.length &lt;= 50</code></li>\n\t<li><code>-50 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 50</code></li>\n\t<li>给出的所有点 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 813.最大平均值和的分组",
        "hardRate": "MEDIUM",
        "passRate": "61.68%",
        "problemsUrl": "https://leetcode.cn/problems/largest-sum-of-averages/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-sum-of-averages/solution",
        "problemsDesc": "<p>给定数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。我们将给定的数组&nbsp;<code>nums</code>&nbsp;分成 <strong>最多</strong>&nbsp;<code>k</code>&nbsp;个相邻的非空子数组 。&nbsp;<strong>分数</strong> 由每个子数组内的平均值的总和构成。</p>\n\n<p>注意我们必须使用 <code>nums</code> 数组中的每一个数进行分组，并且分数不一定需要是整数。</p>\n\n<p>返回我们所能得到的最大 <strong>分数</strong> 是多少。答案误差在&nbsp;<code>10<sup>-6</sup></code>&nbsp;内被视为是正确的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [9,1,2,3,9], k = 3\n<strong>输出:</strong> 20.00000\n<strong>解释:</strong> \nnums 的最优分组是[9], [1, 2, 3], [9]. 得到的分数是 9 + (1 + 2 + 3) / 3 + 9 = 20. \n我们也可以把 nums 分成[9, 1], [2], [3, 9]. \n这样的分组得到的分数为 5 + 2 + 6 = 13, 但不是最大值.\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,3,4,5,6,7], k = 4\n<strong>输出:</strong> 20.50000\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 814.二叉树剪枝",
        "hardRate": "MEDIUM",
        "passRate": "72.55%",
        "problemsUrl": "https://leetcode.cn/problems/binary-tree-pruning/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-tree-pruning/solution",
        "problemsDesc": "<p>给你二叉树的根结点&nbsp;<code>root</code>&nbsp;，此外树的每个结点的值要么是 <code>0</code> ，要么是 <code>1</code> 。</p>\n\n<p>返回移除了所有不包含 <code>1</code> 的子树的原二叉树。</p>\n\n<p>节点 <code>node</code> 的子树为 <code>node</code> 本身加上所有 <code>node</code> 的后代。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_2.png\" style=\"width: 500px; height: 140px;\" />\n<pre>\n<strong>输入：</strong>root = [1,null,0,0,1]\n<strong>输出：</strong>[1,null,0,null,1]\n<strong>解释：</strong>\n只有红色节点满足条件“所有不包含 1 的子树”。 右图为返回的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_1.png\" style=\"width: 500px; height: 115px;\" />\n<pre>\n<strong>输入：</strong>root = [1,0,1,0,0,0,1]\n<strong>输出：</strong>[1,null,1,null,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/05/1028.png\" style=\"width: 500px; height: 134px;\" />\n<pre>\n<strong>输入：</strong>root = [1,1,0,1,1,0,1,0]\n<strong>输出：</strong>[1,1,0,1,1,null,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 200]</code> 内</li>\n\t<li><code>Node.val</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 815.公交路线",
        "hardRate": "HARD",
        "passRate": "44.41%",
        "problemsUrl": "https://leetcode.cn/problems/bus-routes/",
        "solutionsUrl": "https://leetcode.cn/problems/bus-routes/solution",
        "problemsDesc": "<p>给你一个数组 <code>routes</code> ，表示一系列公交线路，其中每个 <code>routes[i]</code> 表示一条公交线路，第 <code>i</code> 辆公交车将会在上面循环行驶。</p>\n\n<ul>\n\t<li>例如，路线 <code>routes[0] = [1, 5, 7]</code> 表示第 <code>0</code> 辆公交车会一直按序列 <code>1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ...</code> 这样的车站路线行驶。</li>\n</ul>\n\n<p>现在从 <code>source</code> 车站出发（初始时不在公交车上），要前往 <code>target</code> 车站。 期间仅可乘坐公交车。</p>\n\n<p>求出 <strong>最少乘坐的公交车数量</strong> 。如果不可能到达终点车站，返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>routes = [[1,2,7],[3,6,7]], source = 1, target = 6\n<strong>输出：</strong>2\n<strong>解释：</strong>最优策略是先乘坐第一辆公交车到达车站 7 , 然后换乘第二辆公交车到车站 6 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12\n<strong>输出：</strong>-1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= routes.length <= 500</code>.</li>\n\t<li><code>1 <= routes[i].length <= 10<sup>5</sup></code></li>\n\t<li><code>routes[i]</code> 中的所有值 <strong>互不相同</strong></li>\n\t<li><code>sum(routes[i].length) <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= routes[i][j] < 10<sup>6</sup></code></li>\n\t<li><code>0 <= source, target < 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 816.模糊坐标",
        "hardRate": "MEDIUM",
        "passRate": "62.57%",
        "problemsUrl": "https://leetcode.cn/problems/ambiguous-coordinates/",
        "solutionsUrl": "https://leetcode.cn/problems/ambiguous-coordinates/solution",
        "problemsDesc": "<p>我们有一些二维坐标，如&nbsp;<code>&quot;(1, 3)&quot;</code>&nbsp;或&nbsp;<code>&quot;(2, 0.5)&quot;</code>，然后我们移除所有逗号，小数点和空格，得到一个字符串<code>S</code>。返回所有可能的原始字符串到一个列表中。</p>\n\n<p>原始的坐标表示法不会存在多余的零，所以不会出现类似于&quot;00&quot;, &quot;0.0&quot;, &quot;0.00&quot;, &quot;1.0&quot;, &quot;001&quot;, &quot;00.01&quot;或一些其他更小的数来表示坐标。此外，一个小数点前至少存在一个数，所以也不会出现&ldquo;.1&rdquo;形式的数字。</p>\n\n<p>最后返回的列表可以是任意顺序的。而且注意返回的两个数字中间（逗号之后）都有一个空格。</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<strong>示例 1:</strong>\n<strong>输入:</strong> &quot;(123)&quot;\n<strong>输出:</strong> [&quot;(1, 23)&quot;, &quot;(12, 3)&quot;, &quot;(1.2, 3)&quot;, &quot;(1, 2.3)&quot;]\n</pre>\n\n<pre>\n<strong>示例 2:</strong>\n<strong>输入:</strong> &quot;(00011)&quot;\n<strong>输出:</strong> &nbsp;[&quot;(0.001, 1)&quot;, &quot;(0, 0.011)&quot;]\n<strong>解释:</strong> \n0.0, 00, 0001 或 00.01 是不被允许的。\n</pre>\n\n<pre>\n<strong>示例 3:</strong>\n<strong>输入:</strong> &quot;(0123)&quot;\n<strong>输出:</strong> [&quot;(0, 123)&quot;, &quot;(0, 12.3)&quot;, &quot;(0, 1.23)&quot;, &quot;(0.1, 23)&quot;, &quot;(0.1, 2.3)&quot;, &quot;(0.12, 3)&quot;]\n</pre>\n\n<pre>\n<strong>示例 4:</strong>\n<strong>输入:</strong> &quot;(100)&quot;\n<strong>输出:</strong> [(10, 0)]\n<strong>解释:</strong> \n1.0 是不被允许的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示: </strong></p>\n\n<ul>\n\t<li><code>4 &lt;= S.length &lt;= 12</code>.</li>\n\t<li><code>S[0]</code> = &quot;(&quot;, <code>S[S.length - 1]</code> = &quot;)&quot;, 且字符串&nbsp;<code>S</code>&nbsp;中的其他元素都是数字。</li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 817.链表组件",
        "hardRate": "MEDIUM",
        "passRate": "61.38%",
        "problemsUrl": "https://leetcode.cn/problems/linked-list-components/",
        "solutionsUrl": "https://leetcode.cn/problems/linked-list-components/solution",
        "problemsDesc": "<p>给定链表头结点&nbsp;<code>head</code>，该链表上的每个结点都有一个 <strong>唯一的整型值</strong> 。同时给定列表&nbsp;<code>nums</code>，该列表是上述链表中整型值的一个子集。</p>\n\n<p>返回列表&nbsp;<code>nums</code>&nbsp;中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表&nbsp;<code>nums</code>&nbsp;中）构成的集合。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/22/lc-linkedlistcom1.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> head = [0,1,2,3], nums = [0,1,3]\n<strong>输出:</strong> 2\n<strong>解释:</strong> 链表中,0 和 1 是相连接的，且 nums 中不包含 2，所以 [0, 1] 是 nums 的一个组件，同理 [3] 也是一个组件，故返回 2。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong>&nbsp;</strong><img src=\"https://assets.leetcode.com/uploads/2021/07/22/lc-linkedlistcom2.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> head = [0,1,2,3,4], nums = [0,3,1,4]\n<strong>输出:</strong> 2\n<strong>解释:</strong> 链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点数为<code>n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= Node.val &lt; n</code></li>\n\t<li><code>Node.val</code>&nbsp;中所有值 <strong>不同</strong></li>\n\t<li><code>1 &lt;= nums.length &lt;= n</code></li>\n\t<li><code>0 &lt;= nums[i] &lt; n</code></li>\n\t<li><code>nums</code> 中所有值 <strong>不同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 818.赛车",
        "hardRate": "HARD",
        "passRate": "44.84%",
        "problemsUrl": "https://leetcode.cn/problems/race-car/",
        "solutionsUrl": "https://leetcode.cn/problems/race-car/solution",
        "problemsDesc": "你的赛车可以从位置 <code>0</code> 开始，并且速度为 <code>+1</code> ，在一条无限长的数轴上行驶。赛车也可以向负方向行驶。赛车可以按照由加速指令 <code>'A'</code> 和倒车指令 <code>'R'</code> 组成的指令序列自动行驶。\n<ul>\n\t<li>当收到指令 <code>'A'</code> 时，赛车这样行驶：\n\t<ul>\n\t\t<li><code>position += speed</code></li>\n\t\t<li><code>speed *= 2</code></li>\n\t</ul>\n\t</li>\n\t<li>当收到指令 <code>'R'</code> 时，赛车这样行驶：\n\t<ul>\n\t\t<li>如果速度为正数，那么<code>speed = -1</code></li>\n\t\t<li>否则 <code>speed = 1</code></li>\n\t</ul>\n\t当前所处位置不变。</li>\n</ul>\n\n<p>例如，在执行指令 <code>\"AAR\"</code> 后，赛车位置变化为 <code>0 --&gt; 1 --&gt; 3 --&gt; 3</code> ，速度变化为 <code>1 --&gt; 2 --&gt; 4 --&gt; -1</code> 。</p>\n\n<p>给你一个目标位置 <code>target</code> ，返回能到达目标位置的最短指令序列的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>\n最短指令序列是 \"AA\" 。\n位置变化 0 --&gt; 1 --&gt; 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 6\n<strong>输出：</strong>5\n<strong>解释：</strong>\n最短指令序列是 \"AAARA\" 。\n位置变化 0 --&gt; 1 --&gt; 3 --&gt; 7 --&gt; 7 --&gt; 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 819.最常见的单词",
        "hardRate": "EASY",
        "passRate": "45.61%",
        "problemsUrl": "https://leetcode.cn/problems/most-common-word/",
        "solutionsUrl": "https://leetcode.cn/problems/most-common-word/solution",
        "problemsDesc": "<p>给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不在禁用列表中的单词。</p>\n\n<p>题目保证至少有一个词不在禁用列表中，而且答案唯一。</p>\n\n<p>禁用列表中的单词用小写字母表示，不含标点符号。段落中的单词不区分大小写。答案都是小写字母。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入:</strong> \nparagraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;\nbanned = [&quot;hit&quot;]\n<strong>输出:</strong> &quot;ball&quot;\n<strong>解释:</strong> \n&quot;hit&quot; 出现了3次，但它是一个禁用的单词。\n&quot;ball&quot; 出现了2次 (同时没有其他单词出现2次)，所以它是段落里出现次数最多的，且不在禁用列表中的单词。 \n注意，所有这些单词在段落里不区分大小写，标点符号需要忽略（即使是紧挨着单词也忽略， 比如 &quot;ball,&quot;）， \n&quot;hit&quot;不是最终的答案，虽然它出现次数更多，但它在禁用单词列表中。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= 段落长度 &lt;= 1000</code></li>\n\t<li><code>0 &lt;= 禁用单词个数 &lt;= 100</code></li>\n\t<li><code>1 &lt;= 禁用单词长度 &lt;= 10</code></li>\n\t<li>答案是唯一的, 且都是小写字母&nbsp;(即使在 <code>paragraph</code> 里是大写的，即使是一些特定的名词，答案都是小写的。)</li>\n\t<li><code>paragraph</code>&nbsp;只包含字母、空格和下列标点符号<code>!?&#39;,;.</code></li>\n\t<li>不存在没有连字符或者带有连字符的单词。</li>\n\t<li>单词里只包含字母，不会出现省略号或者其他标点符号。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 820.单词的压缩编码",
        "hardRate": "MEDIUM",
        "passRate": "52.09%",
        "problemsUrl": "https://leetcode.cn/problems/short-encoding-of-words/",
        "solutionsUrl": "https://leetcode.cn/problems/short-encoding-of-words/solution",
        "problemsDesc": "<p>单词数组 <code>words</code> 的 <strong>有效编码</strong> 由任意助记字符串 <code>s</code> 和下标数组 <code>indices</code> 组成，且满足：</p>\n\n<ul>\n\t<li><code>words.length == indices.length</code></li>\n\t<li>助记字符串 <code>s</code> 以 <code>'#'</code> 字符结尾</li>\n\t<li>对于每个下标 <code>indices[i]</code> ，<code>s</code> 的一个从 <code>indices[i]</code> 开始、到下一个 <code>'#'</code> 字符结束（但不包括 <code>'#'</code>）的 <strong>子字符串</strong> 恰好与 <code>words[i]</code> 相等</li>\n</ul>\n\n<p>给你一个单词数组 <code>words</code> ，返回成功对 <code>words</code> 进行编码的最小助记字符串 <code>s</code> 的长度 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"time\", \"me\", \"bell\"]\n<strong>输出：</strong>10\n<strong>解释：</strong>一组有效编码为 s = <code>\"time#bell#\" 和 indices = [0, 2, 5</code>] 。\nwords[0] = \"time\" ，s 开始于 indices[0] = 0 到下一个 '#' 结束的子字符串，如加粗部分所示 \"<strong>time</strong>#bell#\"\nwords[1] = \"me\" ，s 开始于 indices[1] = 2 到下一个 '#' 结束的子字符串，如加粗部分所示 \"ti<strong>me</strong>#bell#\"\nwords[2] = \"bell\" ，s 开始于 indices[2] = 5 到下一个 '#' 结束的子字符串，如加粗部分所示 \"time#<strong>bell</strong>#\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"t\"]\n<strong>输出：</strong>2\n<strong>解释：</strong>一组有效编码为 s = \"t#\" 和 indices = [0] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= words.length <= 2000</code></li>\n\t<li><code>1 <= words[i].length <= 7</code></li>\n\t<li><code>words[i]</code> 仅由小写字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 821.字符的最短距离",
        "hardRate": "EASY",
        "passRate": "72.87%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-distance-to-a-character/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-distance-to-a-character/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和一个字符 <code>c</code> ，且 <code>c</code> 是 <code>s</code> 中出现过的字符。</p>\n\n<p>返回一个整数数组 <code>answer</code> ，其中 <code>answer.length == s.length</code> 且 <code>answer[i]</code> 是 <code>s</code> 中从下标 <code>i</code> 到离它 <strong>最近</strong> 的字符 <code>c</code> 的 <strong>距离</strong> 。</p>\n\n<p>两个下标&nbsp;<code>i</code> 和 <code>j</code> 之间的 <strong>距离</strong> 为 <code>abs(i - j)</code> ，其中 <code>abs</code> 是绝对值函数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"loveleetcode\", c = \"e\"\n<strong>输出：</strong>[3,2,1,0,1,0,0,1,2,2,1,0]\n<strong>解释：</strong>字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aaab\", c = \"b\"\n<strong>输出：</strong>[3,2,1,0]\n</pre>\n\n<p>&nbsp;</p>\n<strong>提示：</strong>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s[i]</code> 和 <code>c</code> 均为小写英文字母</li>\n\t<li>题目数据保证 <code>c</code> 在 <code>s</code> 中至少出现一次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 822.翻转卡片游戏",
        "hardRate": "MEDIUM",
        "passRate": "51.63%",
        "problemsUrl": "https://leetcode.cn/problems/card-flipping-game/",
        "solutionsUrl": "https://leetcode.cn/problems/card-flipping-game/solution",
        "problemsDesc": "<p>在桌子上有 <code>N</code> 张卡片，每张卡片的正面和背面都写着一个正数（正面与背面上的数有可能不一样）。</p>\n\n<p>我们可以先翻转任意张卡片，然后选择其中一张卡片。</p>\n\n<p>如果选中的那张卡片背面的数字 <code>X</code> 与任意一张卡片的正面的数字都不同，那么这个数字是我们想要的数字。</p>\n\n<p>哪个数是这些想要的数字中最小的数（找到这些数中的最小值）呢？如果没有一个数字符合要求的，输出 0。</p>\n\n<p>其中, <code>fronts[i]</code>&nbsp;和&nbsp;<code>backs[i]</code>&nbsp;分别代表第&nbsp;<code>i</code>&nbsp;张卡片的正面和背面的数字。</p>\n\n<p>如果我们通过翻转卡片来交换正面与背面上的数，那么当初在正面的数就变成背面的数，背面的数就变成正面的数。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>fronts = [1,2,4,4,7], backs = [1,3,4,1,3]\n<strong>输出：</strong><code>2</code>\n<strong>解释：</strong>假设我们翻转第二张卡片，那么在正面的数变成了 <code>[1,3,4,4,7]</code> ， 背面的数变成了 <code>[1,2,4,1,3]。</code>\n接着我们选择第二张卡片，因为现在该卡片的背面的数是 2，2 与任意卡片上正面的数都不同，所以 2 就是我们想要的数字。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= fronts.length == backs.length&nbsp;&lt;=&nbsp;1000</code></li>\n\t<li><code>1 &lt;=&nbsp;fronts[i]&nbsp;&lt;= 2000</code></li>\n\t<li><code>1 &lt;= backs[i]&nbsp;&lt;= 2000</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 823.带因子的二叉树",
        "hardRate": "MEDIUM",
        "passRate": "43.44%",
        "problemsUrl": "https://leetcode.cn/problems/binary-trees-with-factors/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-trees-with-factors/solution",
        "problemsDesc": "<p>给出一个含有不重复整数元素的数组 <code>arr</code> ，每个整数 <code>arr[i]</code> 均大于 1。</p>\n\n<p>用这些整数来构建二叉树，每个整数可以使用任意次数。其中：每个非叶结点的值应等于它的两个子结点的值的乘积。</p>\n\n<p>满足条件的二叉树一共有多少个？答案可能很大，返回<strong> 对 </strong><code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>arr = [2, 4]</code>\n<strong>输出:</strong> 3\n<strong>解释:</strong> 可以得到这些二叉树: <code>[2], [4], [4, 2, 2]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>arr = [2, 4, 5, 10]</code>\n<strong>输出:</strong> <code>7</code>\n<strong>解释:</strong> 可以得到这些二叉树: <code>[2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2]</code>.</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>2 &lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>arr</code> 中的所有值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 824.山羊拉丁文",
        "hardRate": "EASY",
        "passRate": "65.09%",
        "problemsUrl": "https://leetcode.cn/problems/goat-latin/",
        "solutionsUrl": "https://leetcode.cn/problems/goat-latin/solution",
        "problemsDesc": "<p>给你一个由若干单词组成的句子&nbsp;<code>sentence</code> ，单词间由空格分隔。每个单词仅由大写和小写英文字母组成。</p>\n\n<p>请你将句子转换为 <em>“</em>山羊拉丁文（<em>Goat Latin</em>）<em>”</em>（一种类似于 猪拉丁文&nbsp;- Pig Latin 的虚构语言）。山羊拉丁文的规则如下：</p>\n\n<ul>\n\t<li>如果单词以元音开头（<code>'a'</code>, <code>'e'</code>, <code>'i'</code>, <code>'o'</code>, <code>'u'</code>），在单词后添加<code>\"ma\"</code>。\n\n\t<ul>\n\t\t<li>例如，单词 <code>\"apple\"</code> 变为 <code>\"applema\"</code> 。</li>\n\t</ul>\n\t</li>\n\t<li>如果单词以辅音字母开头（即，非元音字母），移除第一个字符并将它放到末尾，之后再添加<code>\"ma\"</code>。\n\t<ul>\n\t\t<li>例如，单词 <code>\"goat\"</code> 变为 <code>\"oatgma\"</code> 。</li>\n\t</ul>\n\t</li>\n\t<li>根据单词在句子中的索引，在单词最后添加与索引相同数量的字母<code>'a'</code>，索引从 <code>1</code> 开始。\n\t<ul>\n\t\t<li>例如，在第一个单词后添加 <code>\"a\"</code> ，在第二个单词后添加 <code>\"aa\"</code> ，以此类推。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>返回将 <code>sentence</code> 转换为山羊拉丁文后的句子。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"I speak Goat Latin\"\n<strong>输出：</strong>\"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"The quick brown fox jumped over the lazy dog\"\n<strong>输出：</strong>\"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentence.length &lt;= 150</code></li>\n\t<li><code>sentence</code> 由英文字母和空格组成</li>\n\t<li><code>sentence</code> 不含前导或尾随空格</li>\n\t<li><code>sentence</code> 中的所有单词由单个空格分隔</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 825.适龄的朋友",
        "hardRate": "MEDIUM",
        "passRate": "45.39%",
        "problemsUrl": "https://leetcode.cn/problems/friends-of-appropriate-ages/",
        "solutionsUrl": "https://leetcode.cn/problems/friends-of-appropriate-ages/solution",
        "problemsDesc": "<p>在社交媒体网站上有 <code>n</code> 个用户。给你一个整数数组 <code>ages</code> ，其中 <code>ages[i]</code> 是第 <code>i</code> 个用户的年龄。</p>\n\n<p>如果下述任意一个条件为真，那么用户 <code>x</code> 将不会向用户 <code>y</code>（<code>x != y</code>）发送好友请求：</p>\n\n<ul>\n\t<li><code>ages[y] &lt;= 0.5 * ages[x] + 7</code></li>\n\t<li><code>ages[y] &gt; ages[x]</code></li>\n\t<li><code>ages[y] &gt; 100 &amp;&amp; ages[x] &lt; 100</code></li>\n</ul>\n\n<p>否则，<code>x</code> 将会向 <code>y</code> 发送一条好友请求。</p>\n\n<p>注意，如果 <code>x</code> 向 <code>y</code> 发送一条好友请求，<code>y</code> 不必也向 <code>x</code> 发送一条好友请求。另外，用户不会向自己发送好友请求。</p>\n\n<p>返回在该社交媒体网站上产生的好友请求总数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>ages = [16,16]\n<strong>输出：</strong>2\n<strong>解释：</strong>2 人互发好友请求。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>ages = [16,17,18]\n<strong>输出：</strong>2\n<strong>解释：</strong>产生的好友请求为 17 -&gt; 16 ，18 -&gt; 17 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>ages = [20,30,100,110,120]\n<strong>输出：</strong>3\n<strong>解释：</strong>产生的好友请求为 110 -&gt; 100 ，120 -&gt; 110 ，120 -&gt; 100 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == ages.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= ages[i] &lt;= 120</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 826.安排工作以达到最大收益",
        "hardRate": "MEDIUM",
        "passRate": "42.56%",
        "problemsUrl": "https://leetcode.cn/problems/most-profit-assigning-work/",
        "solutionsUrl": "https://leetcode.cn/problems/most-profit-assigning-work/solution",
        "problemsDesc": "<p>你有 <code>n</code>&nbsp;个工作和 <code>m</code> 个工人。给定三个数组：&nbsp;<code>difficulty</code>,&nbsp;<code>profit</code>&nbsp;和&nbsp;<code>worker</code>&nbsp;，其中:</p>\n\n<ul>\n\t<li><code>difficulty[i]</code>&nbsp;表示第 <code>i</code> 个工作的难度，<code>profit[i]</code> 表示第 <code>i</code> 个工作的收益。</li>\n\t<li><code>worker[i]</code> 是第 <code>i</code> 个工人的能力，即该工人只能完成难度小于等于 <code>worker[i]</code> 的工作。</li>\n</ul>\n\n<p>每个工人&nbsp;<strong>最多</strong> 只能安排 <strong>一个</strong> 工作，但是一个工作可以 <strong>完成多次</strong> 。</p>\n\n<ul>\n\t<li>举个例子，如果 3 个工人都尝试完成一份报酬为 <code>$1</code> 的同样工作，那么总收益为 <code>$3</code>&nbsp;。如果一个工人不能完成任何工作，他的收益为 <code>$0</code> 。</li>\n</ul>\n\n<p>返回 <em>在把工人分配到工作岗位后，我们所能获得的最大利润&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]\n<strong>输出: </strong>100 \n<strong>解释: </strong>工人被分配的工作难度是 [4,4,6,6] ，分别获得 [20,20,30,30] 的收益。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]\n<strong>输出:</strong> 0</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>n == difficulty.length</code></li>\n\t<li><code>n == profit.length</code></li>\n\t<li><code>m == worker.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= difficulty[i], profit[i], worker[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 827.最大人工岛",
        "hardRate": "HARD",
        "passRate": "47.05%",
        "problemsUrl": "https://leetcode.cn/problems/making-a-large-island/",
        "solutionsUrl": "https://leetcode.cn/problems/making-a-large-island/solution",
        "problemsDesc": "<p>给你一个大小为 <code>n x n</code> 二进制矩阵 <code>grid</code> 。<strong>最多</strong> 只能将一格 <code>0</code> 变成 <code>1</code> 。</p>\n\n<p>返回执行此操作后，<code>grid</code> 中最大的岛屿面积是多少？</p>\n\n<p><strong>岛屿</strong> 由一组上、下、左、右四个方向相连的 <code>1</code> 形成。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>grid = [[1, 0], [0, 1]]\n<strong>输出:</strong> 3\n<strong>解释:</strong> 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>grid =<strong> </strong>[[1, 1], [1, 0]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> 将一格0变成1，岛屿的面积扩大为 4。</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入: </strong>grid = [[1, 1], [1, 1]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> 没有0可以让我们变成1，面积依然为 4。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 <= n <= 500</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 828.统计子串中的唯一字符",
        "hardRate": "HARD",
        "passRate": "65.50%",
        "problemsUrl": "https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/",
        "solutionsUrl": "https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/solution",
        "problemsDesc": "<p>我们定义了一个函数 <code>countUniqueChars(s)</code> 来统计字符串 <code>s</code> 中的唯一字符，并返回唯一字符的个数。</p>\n\n<p>例如：<code>s = \"LEETCODE\"</code> ，则其中 <code>\"L\"</code>, <code>\"T\"</code>,<code>\"C\"</code>,<code>\"O\"</code>,<code>\"D\"</code> 都是唯一字符，因为它们只出现一次，所以 <code>countUniqueChars(s) = 5</code> 。</p>\n\n<p>本题将会给你一个字符串 <code>s</code> ，我们需要返回 <code>countUniqueChars(t)</code> 的总和，其中 <code>t</code> 是 <code>s</code> 的子字符串。输入用例保证返回值为&nbsp;32 位整数。</p>\n\n<p>注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 <code>s</code> 的所有子字符串中的唯一字符）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"ABC\"\n<strong>输出: </strong>10\n<strong>解释:</strong> 所有可能的子串为：\"A\",\"B\",\"C\",\"AB\",\"BC\" 和 \"ABC\"。\n     其中，每一个子串都由独特字符构成。\n     所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"ABA\"\n<strong>输出: </strong>8\n<strong>解释: </strong>除<code>了 countUniqueChars</code>(\"ABA\") = 1 之外，其余与示例 1 相同。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"LEETCODE\"\n<strong>输出：</strong>92\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>s</code> 只包含大写英文字符</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 829.连续整数求和",
        "hardRate": "HARD",
        "passRate": "46.26%",
        "problemsUrl": "https://leetcode.cn/problems/consecutive-numbers-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/consecutive-numbers-sum/solution",
        "problemsDesc": "<p>给定一个正整数 <code>n</code>，返回 <em>连续正整数满足所有数字之和为 <code>n</code>&nbsp;的组数</em> 。&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示</strong><strong>例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>n = 5\n<strong>输出: </strong>2\n<strong>解释: </strong>5 = 2 + 3，共有两组连续整数([5],[2,3])求和后为 5。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>n = 9\n<strong>输出: </strong>3\n<strong>解释: </strong>9 = 4 + 5 = 2 + 3 + 4</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入: </strong>n = 15\n<strong>输出: </strong>4\n<strong>解释: </strong>15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code>​​​​​​​</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 830.较大分组的位置",
        "hardRate": "EASY",
        "passRate": "54.10%",
        "problemsUrl": "https://leetcode.cn/problems/positions-of-large-groups/",
        "solutionsUrl": "https://leetcode.cn/problems/positions-of-large-groups/solution",
        "problemsDesc": "<p>在一个由小写字母构成的字符串 <code>s</code> 中，包含由一些连续的相同字符所构成的分组。</p>\n\n<p>例如，在字符串 <code>s = \"abbxxxxzyy\"</code> 中，就含有 <code>\"a\"</code>, <code>\"bb\"</code>, <code>\"xxxx\"</code>, <code>\"z\"</code> 和 <code>\"yy\"</code> 这样的一些分组。</p>\n\n<p>分组可以用区间 <code>[start, end]</code> 表示，其中 <code>start</code> 和 <code>end</code> 分别表示该分组的起始和终止位置的下标。上例中的 <code>\"xxxx\"</code> 分组用区间表示为 <code>[3,6]</code> 。</p>\n\n<p>我们称所有包含大于或等于三个连续字符的分组为 <strong>较大分组</strong> 。</p>\n\n<p>找到每一个 <strong>较大分组</strong> 的区间，<strong>按起始位置下标递增顺序排序后</strong>，返回结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abbxxxxzzy\"\n<strong>输出：</strong>[[3,6]]\n<strong>解释</strong><strong>：</strong><code>\"xxxx\" 是一个起始于 3 且终止于 6 的较大分组</code>。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\"\n<strong>输出：</strong>[]\n<strong>解释：</strong>\"a\",\"b\" 和 \"c\" 均不是符合要求的较大分组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcdddeeeeaabbbcd\"\n<strong>输出：</strong>[[3,5],[6,9],[12,14]]\n<strong>解释：</strong>较大分组为 \"ddd\", \"eeee\" 和 \"bbb\"</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aba\"\n<strong>输出：</strong>[]\n</pre>\n \n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 1000</code></li>\n\t<li><code>s</code> 仅含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 831.隐藏个人信息",
        "hardRate": "MEDIUM",
        "passRate": "53.78%",
        "problemsUrl": "https://leetcode.cn/problems/masking-personal-information/",
        "solutionsUrl": "https://leetcode.cn/problems/masking-personal-information/solution",
        "problemsDesc": "<p>给你一条个人信息字符串 <code>s</code> ，可能表示一个 <strong>邮箱地址</strong> ，也可能表示一串 <strong>电话号码</strong> 。返回按如下规则 <strong>隐藏</strong> 个人信息后的结果：</p>\n\n<p><em><strong>电子邮件地址：</strong></em></p>\n\n<p>一个电子邮件地址由以下部分组成：</p>\n\n<ul>\n\t<li>一个 <strong>名字</strong> ，由大小写英文字母组成，后面跟着</li>\n\t<li>一个 <code>'@'</code> 字符，后面跟着</li>\n\t<li>一个 <strong>域名</strong> ，由大小写英文字母和一个位于中间的 <code>'.'</code> 字符组成。<code>'.'</code> 不会是域名的第一个或者最后一个字符。</li>\n</ul>\n\n<p>要想隐藏电子邮件地址中的个人信息：</p>\n\n<ul>\n\t<li><strong>名字</strong> 和 <strong>域名</strong> 部分的大写英文字母应当转换成小写英文字母。</li>\n\t<li><strong>名字</strong> 中间的字母（即，除第一个和最后一个字母外）必须用 5 个 <code>\"*****\"</code> 替换。</li>\n</ul>\n\n<p><em><strong>电话号码：</strong></em></p>\n\n<p>一个电话号码应当按下述格式组成：</p>\n\n<ul>\n\t<li>电话号码可以由 10-13 位数字组成</li>\n\t<li>后 10 位构成 <strong>本地号码</strong></li>\n\t<li>前面剩下的 0-3 位，构成 <strong>国家代码</strong></li>\n\t<li>利用 <code>{'+', '-', '(', ')', ' '}</code> 这些 <strong>分隔字符</strong> 按某种形式对上述数字进行分隔</li>\n</ul>\n\n<p>要想隐藏电话号码中的个人信息：</p>\n\n<ul>\n\t<li>移除所有 <strong>分隔字符</strong></li>\n\t<li>隐藏个人信息后的电话号码应该遵从这种格式：\n\t<ul>\n\t\t<li><code>\"***-***-XXXX\"</code> 如果国家代码为 0 位数字</li>\n\t\t<li><code>\"+*-***-***-XXXX\"</code> 如果国家代码为 1 位数字</li>\n\t\t<li><code>\"+**-***-***-XXXX\"</code> 如果国家代码为 2 位数字</li>\n\t\t<li><code>\"+***-***-***-XXXX\"</code> 如果国家代码为 3 位数字</li>\n\t</ul>\n\t</li>\n\t<li><code>\"XXXX\"</code> 是最后 4 位 <strong>本地号码</strong></li>\n</ul>\n&nbsp;\n\n<div class=\"top-view__1vxA\">\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"LeetCode@LeetCode.com\"\n<strong>输出：</strong>\"l*****e@leetcode.com\"\n<strong>解释：</strong>s 是一个电子邮件地址。\n名字和域名都转换为小写，名字的中间用 5 个 * 替换。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"AB@qq.com\"\n<strong>输出：</strong>\"a*****b@qq.com\"\n<strong>解释：</strong>s 是一个电子邮件地址。\n名字和域名都转换为小写，名字的中间用 5 个 * 替换。\n注意，尽管 \"ab\" 只有两个字符，但中间仍然必须有 5 个 * 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1(234)567-890\"\n<strong>输出：</strong>\"***-***-7890\"\n<strong>解释：</strong>s 是一个电话号码。\n共计 10 位数字，所以本地号码为 10 位数字，国家代码为 0 位数字。\n因此，隐藏后的电话号码应该是 \"***-***-7890\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s</code> 是一个 <strong>有效</strong> 的电子邮件或者电话号码</li>\n\t<li>如果 <code>s</code> 是一个电子邮件：\n\t<ul>\n\t\t<li><code>8 &lt;= s.length &lt;= 40</code></li>\n\t\t<li><code>s</code> 是由大小写英文字母，恰好一个 <code>'@'</code> 字符，以及 <code>'.'</code> 字符组成</li>\n\t</ul>\n\t</li>\n\t<li>如果 <code>s</code> 是一个电话号码：\n\t<ul>\n\t\t<li><code>10 &lt;= s.length &lt;= 20</code></li>\n\t\t<li><code>s</code> 是由数字、空格、字符 <code>'('</code>、<code>')'</code>、<code>'-'</code> 和 <code>'+'</code> 组成</li>\n\t</ul>\n\t</li>\n</ul>\n</div>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 832.翻转图像",
        "hardRate": "EASY",
        "passRate": "79.47%",
        "problemsUrl": "https://leetcode.cn/problems/flipping-an-image/",
        "solutionsUrl": "https://leetcode.cn/problems/flipping-an-image/solution",
        "problemsDesc": "<p>给定一个<meta charset=\"UTF-8\" />&nbsp;<code>n x n</code>&nbsp;的二进制矩阵&nbsp;<code>image</code>&nbsp;，先 <strong>水平</strong> 翻转图像，然后&nbsp;<strong>反转&nbsp;</strong>图像并返回&nbsp;<em>结果</em>&nbsp;。</p>\n\n<p><strong>水平</strong>翻转图片就是将图片的每一行都进行翻转，即逆序。</p>\n\n<ul>\n\t<li>例如，水平翻转&nbsp;<code>[1,1,0]</code>&nbsp;的结果是&nbsp;<code>[0,1,1]</code>。</li>\n</ul>\n\n<p><strong>反转</strong>图片的意思是图片中的&nbsp;<code>0</code>&nbsp;全部被&nbsp;<code>1</code>&nbsp;替换，&nbsp;<code>1</code>&nbsp;全部被&nbsp;<code>0</code>&nbsp;替换。</p>\n\n<ul>\n\t<li>例如，反转&nbsp;<code>[0,1,1]</code>&nbsp;的结果是&nbsp;<code>[1,0,0]</code>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>image = [[1,1,0],[1,0,1],[0,0,0]]\n<strong>输出：</strong>[[1,0,0],[0,1,0],[1,1,1]]\n<strong>解释：</strong>首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；\n     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\n<strong>输出：</strong>[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n<strong>解释：</strong>首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；\n     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>n == image.length</code></li>\n\t<li><code>n == image[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>images[i][j]</code>&nbsp;==&nbsp;<code>0</code>&nbsp;或&nbsp;<code>1</code>.</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 833.字符串中的查找与替换",
        "hardRate": "MEDIUM",
        "passRate": "43.98%",
        "problemsUrl": "https://leetcode.cn/problems/find-and-replace-in-string/",
        "solutionsUrl": "https://leetcode.cn/problems/find-and-replace-in-string/solution",
        "problemsDesc": "<p>你会得到一个字符串 <code>s</code>&nbsp;(索引从 0 开始)，你必须对它执行 <code>k</code> 个替换操作。替换操作以三个长度均为 <code>k</code> 的并行数组给出：<code>indices</code>,&nbsp;<code>sources</code>,&nbsp;&nbsp;<code>targets</code>。</p>\n\n<p>要完成第 <code>i</code> 个替换操作:</p>\n\n<ol>\n\t<li>检查 <strong>子字符串</strong> &nbsp;<code>sources[i]</code>&nbsp;是否出现在 <strong>原字符串</strong> <code>s</code> 的索引&nbsp;<code>indices[i]</code>&nbsp;处。</li>\n\t<li>如果没有出现，&nbsp;<strong>什么也不做</strong>&nbsp;。</li>\n\t<li>如果出现，则用&nbsp;<code>targets[i]</code>&nbsp;<strong>替换</strong>&nbsp;该子字符串。</li>\n</ol>\n\n<p>例如，如果 <code>s = \"abcd\"</code>&nbsp;，&nbsp;<code>indices[i] = 0</code> ,&nbsp;<code>sources[i] = \"ab\"</code>， <code>targets[i] = \"eee\"</code> ，那么替换的结果将是 <code>\"<u>eee</u>cd\"</code> 。</p>\n\n<p>所有替换操作必须 <strong>同时</strong> 发生，这意味着替换操作不应该影响彼此的索引。测试用例保证元素间<strong>不会重叠 </strong>。</p>\n\n<ul>\n\t<li>例如，一个 <code>s = \"abc\"</code> ，&nbsp; <code>indices = [0,1]</code> ， <code>sources = [\"ab\"，\"bc\"]</code>&nbsp;的测试用例将不会生成，因为 <code>\"ab\"</code> 和 <code>\"bc\"</code> 替换重叠。</li>\n</ul>\n\n<p><em>在对 <code>s</code>&nbsp;执行所有替换操作后返回 <strong>结果字符串</strong> 。</em></p>\n\n<p><strong>子字符串</strong> 是字符串中连续的字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/12/833-ex1.png\" style=\"height: 251px; width: 411px;\" /></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\", indexes = [0,2], sources = [\"a\",\"cd\"], targets = [\"eee\",\"ffff\"]\n<strong>输出：</strong>\"eeebffff\"\n<strong>解释：\n</strong>\"a\" 从 s 中的索引 0 开始，所以它被替换为 \"eee\"。\n\"cd\" 从 s 中的索引 2 开始，所以它被替换为 \"ffff\"。\n</pre>\n\n<p><strong>示例 2：</strong><img src=\"https://assets.leetcode.com/uploads/2021/06/12/833-ex2-1.png\" style=\"height: 251px; width: 411px;\" /></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\", indexes = [0,2], sources = [\"ab\",\"ec\"], targets = [\"eee\",\"ffff\"]\n<strong>输出：</strong>\"eeecd\"\n<strong>解释：\n</strong>\"ab\" 从 s 中的索引 0 开始，所以它被替换为 \"eee\"。\n\"ec\" 没有从<strong>原始的</strong> S 中的索引 2 开始，所以它没有被替换。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>k == indices.length == sources.length == targets.length</code></li>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n\t<li><code>0 &lt;= indexes[i] &lt; s.length</code></li>\n\t<li><code>1 &lt;= sources[i].length, targets[i].length &lt;= 50</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n\t<li><code>sources[i]</code> 和 <code>targets[i]</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 834.树中距离之和",
        "hardRate": "HARD",
        "passRate": "54.43%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-distances-in-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-distances-in-tree/solution",
        "problemsDesc": "<p>给定一个无向、连通的树。树中有 <code>n</code> 个标记为 <code>0...n-1</code> 的节点以及 <code>n-1</code>&nbsp;条边&nbsp;。</p>\n\n<p>给定整数 <code>n</code> 和数组&nbsp;<code>edges</code>&nbsp;，&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>表示树中的节点&nbsp;<code>a<sub>i</sub></code>&nbsp;和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条边。</p>\n\n<p>返回长度为 <code>n</code> 的数组&nbsp;<code>answer</code>&nbsp;，其中&nbsp;<code>answer[i]</code>&nbsp;是树中第 <code>i</code> 个节点与所有其他节点之间的距离之和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-sumdist1.jpg\" /></p>\n\n<pre>\n<strong>输入: </strong>n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]\n<strong>输出: </strong>[8,12,6,10,10,10]\n<strong>解释: </strong>树如图所示。\n我们可以计算出 dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) \n也就是 1 + 1 + 2 + 2 + 2 = 8。 因此，answer[0] = 8，以此类推。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-sumdist2.jpg\" />\n<pre>\n<strong>输入:</strong> n = 1, edges = []\n<strong>输出:</strong> [0]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-sumdist3.jpg\" />\n<pre>\n<strong>输入:</strong> n = 2, edges = [[1,0]]\n<strong>输出:</strong> [1,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub>&nbsp;&lt; n</code></li>\n\t<li><code>a<sub>i</sub>&nbsp;!= b<sub>i</sub></code></li>\n\t<li>给定的输入保证为有效的树</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 835.图像重叠",
        "hardRate": "MEDIUM",
        "passRate": "58.28%",
        "problemsUrl": "https://leetcode.cn/problems/image-overlap/",
        "solutionsUrl": "https://leetcode.cn/problems/image-overlap/solution",
        "problemsDesc": "<p>给你两个图像 <code>img1</code> 和 <code>img2</code> ，两个图像的大小都是 <code>n x n</code> ，用大小相同的二进制正方形矩阵表示。二进制矩阵仅由若干 <code>0</code> 和若干 <code>1</code> 组成。</p>\n\n<p><strong>转换</strong> 其中一个图像，将所有的 <code>1</code> 向左，右，上，或下滑动任何数量的单位；然后把它放在另一个图像的上面。该转换的 <strong>重叠</strong> 是指两个图像 <strong>都</strong> 具有 <code>1</code> 的位置的数目。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>请注意，转换 <strong>不包括</strong> 向任何方向旋转。越过矩阵边界的 <code>1</code> 都将被清除。</p>\n\n<p>最大可能的重叠数量是多少？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/overlap1.jpg\" style=\"width: 450px; height: 231px;\" />\n<pre>\n<strong>输入：</strong>img1 = [[1,1,0],[0,1,0],[0,1,0]], img2 = [[0,0,0],[0,1,1],[0,0,1]]\n<strong>输出：</strong>3\n<strong>解释：</strong>将 img1 向右移动 1 个单位，再向下移动 1 个单位。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/overlap_step1.jpg\" style=\"width: 450px; height: 105px;\" />\n两个图像都具有 <code>1</code> 的位置的数目是 3（用红色标识）。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/overlap_step2.jpg\" style=\"width: 450px; height: 231px;\" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>img1 = [[1]], img2 = [[1]]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>img1 = [[0]], img2 = [[0]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == img1.length == img1[i].length</code></li>\n\t<li><code>n == img2.length == img2[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n\t<li><code>img1[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n\t<li><code>img2[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 836.矩形重叠",
        "hardRate": "EASY",
        "passRate": "49.03%",
        "problemsUrl": "https://leetcode.cn/problems/rectangle-overlap/",
        "solutionsUrl": "https://leetcode.cn/problems/rectangle-overlap/solution",
        "problemsDesc": "<p>矩形以列表 <code>[x1, y1, x2, y2]</code> 的形式表示，其中 <code>(x1, y1)</code> 为左下角的坐标，<code>(x2, y2)</code> 是右上角的坐标。矩形的上下边平行于 x 轴，左右边平行于 y 轴。</p>\n\n<p>如果相交的面积为 <strong>正</strong> ，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</p>\n\n<p>给出两个矩形 <code>rec1</code> 和 <code>rec2</code> 。如果它们重叠，返回 <code>true</code>；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rec1 = [0,0,2,2], rec2 = [1,1,3,3]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rec1 = [0,0,1,1], rec2 = [1,0,2,1]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>rec1 = [0,0,1,1], rec2 = [2,2,3,3]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rect1.length == 4</code></li>\n\t<li><code>rect2.length == 4</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= rec1[i], rec2[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>rec1</code> 和 <code>rec2</code> 表示一个面积不为零的有效矩形</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 837.新 21 点",
        "hardRate": "MEDIUM",
        "passRate": "39.73%",
        "problemsUrl": "https://leetcode.cn/problems/new-21-game/",
        "solutionsUrl": "https://leetcode.cn/problems/new-21-game/solution",
        "problemsDesc": "<p>爱丽丝参与一个大致基于纸牌游戏 <strong>“21点”</strong> 规则的游戏，描述如下：</p>\n\n<p>爱丽丝以 <code>0</code> 分开始，并在她的得分少于 <code>k</code> 分时抽取数字。 抽取时，她从 <code>[1, maxPts]</code> 的范围中随机获得一个整数作为分数进行累计，其中 <code>maxPts</code> 是一个整数。 每次抽取都是独立的，其结果具有相同的概率。</p>\n\n<p>当爱丽丝获得 <code>k</code> 分 <strong>或更多分</strong> 时，她就停止抽取数字。</p>\n\n<p>爱丽丝的分数不超过 <code>n</code> 的概率是多少？</p>\n\n<p>与实际答案误差不超过&nbsp;<code>10<sup>-5</sup></code> 的答案将被视为正确答案。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10, k = 1, maxPts = 10\n<strong>输出：</strong>1.00000\n<strong>解释：</strong>爱丽丝得到一张牌，然后停止。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6, k = 1, maxPts = 10\n<strong>输出：</strong>0.60000\n<strong>解释：</strong>爱丽丝得到一张牌，然后停止。 在 10 种可能性中的 6 种情况下，她的得分不超过 6 分。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 21, k = 17, maxPts = 10\n<strong>输出：</strong>0.73278\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= k &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= maxPts &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 838.推多米诺",
        "hardRate": "MEDIUM",
        "passRate": "55.66%",
        "problemsUrl": "https://leetcode.cn/problems/push-dominoes/",
        "solutionsUrl": "https://leetcode.cn/problems/push-dominoes/solution",
        "problemsDesc": "<p><code>n</code> 张多米诺骨牌排成一行，将每张多米诺骨牌垂直竖立。在开始时，同时把一些多米诺骨牌向左或向右推。</p>\n\n<p>每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。</p>\n\n<p>如果一张垂直竖立的多米诺骨牌的两侧同时有多米诺骨牌倒下时，由于受力平衡， 该骨牌仍然保持不变。</p>\n\n<p>就这个问题而言，我们会认为一张正在倒下的多米诺骨牌不会对其它正在倒下或已经倒下的多米诺骨牌施加额外的力。</p>\n\n<p>给你一个字符串 <code>dominoes</code> 表示这一行多米诺骨牌的初始状态，其中：</p>\n\n<ul>\n\t<li><code>dominoes[i] = 'L'</code>，表示第 <code>i</code> 张多米诺骨牌被推向左侧，</li>\n\t<li><code>dominoes[i] = 'R'</code>，表示第 <code>i</code> 张多米诺骨牌被推向右侧，</li>\n\t<li><code>dominoes[i] = '.'</code>，表示没有推动第 <code>i</code> 张多米诺骨牌。</li>\n</ul>\n\n<p>返回表示最终状态的字符串。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>dominoes = \"RR.L\"\n<strong>输出：</strong>\"RR.L\"\n<strong>解释：</strong>第一张多米诺骨牌没有给第二张施加额外的力。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/05/18/domino.png\" style=\"height: 196px; width: 512px;\" />\n<pre>\n<strong>输入：</strong>dominoes = \".L.R...LR..L..\"\n<strong>输出：</strong>\"LL.RR.LLRRLL..\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == dominoes.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>dominoes[i]</code> 为 <code>'L'</code>、<code>'R'</code> 或 <code>'.'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 839.相似字符串组",
        "hardRate": "HARD",
        "passRate": "58.86%",
        "problemsUrl": "https://leetcode.cn/problems/similar-string-groups/",
        "solutionsUrl": "https://leetcode.cn/problems/similar-string-groups/solution",
        "problemsDesc": "<p>如果交换字符串&nbsp;<code>X</code> 中的两个不同位置的字母，使得它和字符串&nbsp;<code>Y</code> 相等，那么称 <code>X</code> 和 <code>Y</code> 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。</p>\n\n<p>例如，<code>\"tars\"</code> 和 <code>\"rats\"</code> 是相似的 (交换 <code>0</code> 与 <code>2</code> 的位置)；&nbsp;<code>\"rats\"</code> 和 <code>\"arts\"</code> 也是相似的，但是 <code>\"star\"</code> 不与 <code>\"tars\"</code>，<code>\"rats\"</code>，或 <code>\"arts\"</code> 相似。</p>\n\n<p>总之，它们通过相似性形成了两个关联组：<code>{\"tars\", \"rats\", \"arts\"}</code> 和 <code>{\"star\"}</code>。注意，<code>\"tars\"</code> 和 <code>\"arts\"</code> 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。</p>\n\n<p>给你一个字符串列表 <code>strs</code>。列表中的每个字符串都是 <code>strs</code> 中其它所有字符串的一个字母异位词。请问 <code>strs</code> 中有多少个相似字符串组？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"tars\",\"rats\",\"arts\",\"star\"]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"omv\",\"ovm\"]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= strs[i].length &lt;= 300</code></li>\n\t<li><code>strs[i]</code> 只包含小写字母。</li>\n\t<li><code>strs</code> 中的所有单词都具有相同的长度，且是彼此的字母异位词。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 840.矩阵中的幻方",
        "hardRate": "MEDIUM",
        "passRate": "36.68%",
        "problemsUrl": "https://leetcode.cn/problems/magic-squares-in-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/magic-squares-in-grid/solution",
        "problemsDesc": "<p><code>3 x 3</code> 的幻方是一个填充有&nbsp;<strong>从 <code>1</code> 到 <code>9</code>&nbsp;</strong> 的不同数字的 <code>3 x 3</code> 矩阵，其中每行，每列以及两条对角线上的各数之和都相等。</p>\n\n<p>给定一个由整数组成的<code>row x col</code>&nbsp;的 <code>grid</code>，其中有多少个&nbsp;<code>3 × 3</code> 的 “幻方” 子矩阵？（每个子矩阵都是连续的）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/11/magic_main.jpg\" /></p>\n\n<pre>\n<strong>输入: </strong>grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]\n<strong>输出: </strong>1\n<strong>解释: </strong>\n下面的子矩阵是一个 3 x 3 的幻方：\n<img src=\"https://assets.leetcode.com/uploads/2020/09/11/magic_valid.jpg\" />\n而这一个不是：\n<img src=\"https://assets.leetcode.com/uploads/2020/09/11/magic_invalid.jpg\" />\n总的来说，在本示例所给定的矩阵中只有一个 3 x 3 的幻方子矩阵。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输出:</strong> grid = [[8]]\n<strong>输入:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>row == grid.length</code></li>\n\t<li><code>col == grid[i].length</code></li>\n\t<li><code>1 &lt;= row, col &lt;= 10</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 15</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 841.钥匙和房间",
        "hardRate": "MEDIUM",
        "passRate": "67.95%",
        "problemsUrl": "https://leetcode.cn/problems/keys-and-rooms/",
        "solutionsUrl": "https://leetcode.cn/problems/keys-and-rooms/solution",
        "problemsDesc": "<p>有 <code>n</code> 个房间，房间按从 <code>0</code> 到 <code>n - 1</code> 编号。最初，除 <code>0</code> 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。</p>\n\n<p>当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。</p>\n\n<p>给你一个数组 <code>rooms</code> 其中 <code>rooms[i]</code> 是你进入 <code>i</code> 号房间可以获得的钥匙集合。如果能进入 <strong>所有</strong> 房间返回 <code>true</code>，否则返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rooms = [[1],[2],[3],[]]\n<strong>输出：</strong>true\n<strong>解释：</strong>\n我们从 0 号房间开始，拿到钥匙 1。\n之后我们去 1 号房间，拿到钥匙 2。\n然后我们去 2 号房间，拿到钥匙 3。\n最后我们去了 3 号房间。\n由于我们能够进入每个房间，我们返回 true。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rooms = [[1,3],[3,0,1],[2],[0]]\n<strong>输出：</strong>false\n<strong>解释：</strong>我们不能进入 2 号房间。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == rooms.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= sum(rooms[i].length) &lt;= 3000</code></li>\n\t<li><code>0 &lt;= rooms[i][j] &lt; n</code></li>\n\t<li>所有 <code>rooms[i]</code> 的值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 842.将数组拆分成斐波那契序列",
        "hardRate": "MEDIUM",
        "passRate": "48.30%",
        "problemsUrl": "https://leetcode.cn/problems/split-array-into-fibonacci-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/split-array-into-fibonacci-sequence/solution",
        "problemsDesc": "<p>给定一个数字字符串 <code>num</code>，比如 <code>\"123456579\"</code>，我们可以将它分成「斐波那契式」的序列 <code>[123, 456, 579]</code>。</p>\n\n<p>形式上，<strong>斐波那契式&nbsp;</strong>序列是一个非负整数列表 <code>f</code>，且满足：</p>\n\n<ul>\n\t<li><code>0 &lt;= f[i] &lt; 2<sup>31</sup></code>&nbsp;，（也就是说，每个整数都符合 <strong>32 位</strong>&nbsp;有符号整数类型）</li>\n\t<li><code>f.length &gt;= 3</code></li>\n\t<li>对于所有的<code>0 &lt;= i &lt; f.length - 2</code>，都有 <code>f[i] + f[i + 1] = f[i + 2]</code></li>\n</ul>\n\n<p>另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 <code>0</code> 本身。</p>\n\n<p>返回从 <code>num</code> 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 <code>[]</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"1101111\"\n<strong>输出：</strong>[11,0,11,11]\n<strong>解释：</strong>输出[110,1,111]也可以。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>num = \"112358130\"\n<strong>输出: </strong>[]\n<strong>解释: </strong>无法拆分。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>\"0123\"\n<strong>输出：</strong>[]\n<strong>解释：</strong>每个块的数字不能以零开头，因此 \"01\"，\"2\"，\"3\" 不是有效答案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 200</code></li>\n\t<li><code>num</code>&nbsp;中只含有数字</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 843.猜猜这个单词",
        "hardRate": "HARD",
        "passRate": "36.67%",
        "problemsUrl": "https://leetcode.cn/problems/guess-the-word/",
        "solutionsUrl": "https://leetcode.cn/problems/guess-the-word/solution",
        "problemsDesc": "<p>给你一个由 <strong>不同</strong> 字符串组成的单词列表&nbsp;<code>words</code> ，其中 <code>words[i]</code>&nbsp;长度均为&nbsp;<code>6</code> 。<code>words</code> 中的一个单词将被选作秘密单词 <code>secret</code>&nbsp;。</p>\n\n<p>另给你一个辅助对象&nbsp;<code>Master</code> ，你可以调用&nbsp;<code>Master.guess(word)</code> 来猜单词，其中参数 <code>word</code> 长度为 6 且必须是 <code>words</code> 中的字符串。</p>\n\n<p><code>Master.guess(word)</code> 将会返回如下结果：</p>\n\n<ul>\n\t<li>如果 <code>word</code> 不是 <code>words</code> 中的字符串，返回 <code>-1</code> ，或者</li>\n\t<li>一个整数，表示你所猜测的单词 <code>word</code> 与 <strong>秘密单词</strong>&nbsp;<code>secret</code>&nbsp;的准确匹配（值和位置同时匹配）的数目。</li>\n</ul>\n\n<p>每组测试用例都会包含一个参数 <code>allowedGuesses</code> ，其中 <code>allowedGuesses</code> 是你可以调用 <code>Master.guess(word)</code> 的最大次数。</p>\n\n<p>对于每组测试用例，在不超过允许猜测的次数的前提下，你应该调用 <code>Master.guess</code> 来猜出秘密单词。最终，你将会得到以下结果：</p>\n\n<ul>\n\t<li>如果你调用 <code>Master.guess</code> 的次数大于 <code>allowedGuesses</code> 所限定的次数或者你没有用 <code>Master.guess</code> 猜到秘密单词，则得到 <strong><code>\"Either you took too many guesses, or you did not find the secret word.\"</code> 。</strong></li>\n\t<li>如果你调用 <code>Master.guess</code> 猜到秘密单词，且调用 <code>Master.guess</code> 的次数小于或等于 <code>allowedGuesses</code> ，则得到 <strong><code>\"You guessed the secret word correctly.\"</code> 。</strong></li>\n</ul>\n\n<p>生成的测试用例保证你可以利用某种合理的策略（而不是暴力）猜到秘密单词。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>secret = \"acckzz\", words = [\"acckzz\",\"ccbazz\",\"eiowzz\",\"abcczz\"], allowedGuesses = 10\n<strong>输出：</strong>You guessed the secret word correctly.\n<strong>解释：</strong>\nmaster.guess(\"aaaaaa\") 返回 -1 ，因为 \"aaaaaa\" 不在 words 中。\nmaster.guess(\"acckzz\") 返回 6 ，因为 \"acckzz\" 是秘密单词 secret ，共有 6 个字母匹配。\nmaster.guess(\"ccbazz\") 返回 3 ，因为 \"ccbazz\" 共有 3 个字母匹配。\nmaster.guess(\"eiowzz\") 返回 2 ，因为 \"eiowzz\" 共有 2 个字母匹配。\nmaster.guess(\"abcczz\") 返回 4 ，因为 \"abcczz\" 共有 4 个字母匹配。\n一共调用 5 次 master.guess ，其中一个为秘密单词，所以通过测试用例。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>secret = \"hamada\", words = [\"hamada\",\"khaled\"], allowedGuesses = 10\n<strong>输出：</strong>You guessed the secret word correctly.\n<strong>解释：</strong>共有 2 个单词，且其中一个为秘密单词，可以通过测试用例。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>words[i].length == 6</code></li>\n\t<li><code>words[i]</code> 仅由小写英文字母组成</li>\n\t<li><code>words</code> 中所有字符串 <strong>互不相同</strong></li>\n\t<li><code>secret</code> 存在于 <code>words</code> 中</li>\n\t<li><code>10 &lt;= allowedGuesses &lt;= 30</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 844.比较含退格的字符串",
        "hardRate": "EASY",
        "passRate": "47.88%",
        "problemsUrl": "https://leetcode.cn/problems/backspace-string-compare/",
        "solutionsUrl": "https://leetcode.cn/problems/backspace-string-compare/solution",
        "problemsDesc": "<p>给定 <code>s</code> 和 <code>t</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 <code>true</code> 。<code>#</code> 代表退格字符。</p>\n\n<p><strong>注意：</strong>如果对空文本输入退格字符，文本继续为空。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ab#c\", t = \"ad#c\"\n<strong>输出：</strong>true\n<strong>解释：</strong>s 和 t 都会变成 \"ac\"。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ab##\", t = \"c#d#\"\n<strong>输出：</strong>true\n<strong>解释：</strong>s 和 t 都会变成 \"\"。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a#c\", t = \"b\"\n<strong>输出：</strong>false\n<strong>解释：</strong>s 会变成 \"c\"，但 t 仍然是 \"b\"。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 200</code></li>\n\t<li><code>s</code> 和 <code>t</code> 只含有小写字母以及字符 <code>'#'</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你可以用 <code>O(n)</code> 的时间复杂度和 <code>O(1)</code> 的空间复杂度解决该问题吗？</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 845.数组中的最长山脉",
        "hardRate": "MEDIUM",
        "passRate": "42.29%",
        "problemsUrl": "https://leetcode.cn/problems/longest-mountain-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-mountain-in-array/solution",
        "problemsDesc": "<p>把符合下列属性的数组 <code>arr</code> 称为 <strong>山脉数组</strong> ：</p>\n\n<ul>\n\t<li><code>arr.length &gt;= 3</code></li>\n\t<li>存在下标 <code>i</code>（<code>0 &lt; i &lt; arr.length - 1</code>），满足\n\t<ul>\n\t\t<li><code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]</code></li>\n\t\t<li><code>arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>给出一个整数数组 <code>arr</code>，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [2,1,4,7,3,2,5]\n<strong>输出：</strong>5\n<strong>解释：</strong>最长的山脉子数组是 [1,4,7,3,2]，长度为 5。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [2,2,2]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在山脉子数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你可以仅用一趟扫描解决此问题吗？</li>\n\t<li>你可以用 <code>O(1)</code> 空间解决此问题吗？</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 846.一手顺子",
        "hardRate": "MEDIUM",
        "passRate": "57.24%",
        "problemsUrl": "https://leetcode.cn/problems/hand-of-straights/",
        "solutionsUrl": "https://leetcode.cn/problems/hand-of-straights/solution",
        "problemsDesc": "<p>Alice 手中有一把牌，她想要重新排列这些牌，分成若干组，使每一组的牌数都是 <code>groupSize</code> ，并且由 <code>groupSize</code> 张连续的牌组成。</p>\n\n<p>给你一个整数数组 <code>hand</code> 其中 <code>hand[i]</code> 是写在第 <code>i</code> 张牌上的<strong>数值</strong>。如果她可能重新排列这些牌，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>hand = [1,2,3,6,2,3,4,7,8], groupSize = 3\n<strong>输出：</strong>true\n<strong>解释：</strong>Alice 手中的牌可以被重新排列为 <code>[1,2,3]，[2,3,4]，[6,7,8]</code>。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>hand = [1,2,3,4,5], groupSize = 4\n<strong>输出：</strong>false\n<strong>解释：</strong>Alice 手中的牌无法被重新排列成几个大小为 4 的组。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= hand.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= hand[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= groupSize &lt;= hand.length</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>此题目与 1296 重复：<a href=\"https://leetcode-cn.com/problems/divide-array-in-sets-of-k-consecutive-numbers/\" target=\"_blank\">https://leetcode-cn.com/problems/divide-array-in-sets-of-k-consecutive-numbers/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 847.访问所有节点的最短路径",
        "hardRate": "HARD",
        "passRate": "67.57%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-path-visiting-all-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-path-visiting-all-nodes/solution",
        "problemsDesc": "<p>存在一个由 <code>n</code> 个节点组成的无向连通图，图中的节点按从 <code>0</code> 到 <code>n - 1</code> 编号。</p>\n\n<p>给你一个数组 <code>graph</code> 表示这个图。其中，<code>graph[i]</code> 是一个列表，由所有与节点 <code>i</code> 直接相连的节点组成。</p>\n\n<p>返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/12/shortest1-graph.jpg\" style=\"width: 222px; height: 183px;\" />\n<pre>\n<strong>输入：</strong>graph = [[1,2,3],[0],[0],[0]]\n<strong>输出：</strong>4\n<strong>解释：</strong>一种可能的路径为 [1,0,2,0,3]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/12/shortest2-graph.jpg\" style=\"width: 382px; height: 222px;\" /></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]\n<strong>输出：</strong>4\n<strong>解释：</strong>一种可能的路径为 [0,1,4,2,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == graph.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 12</code></li>\n\t<li><code>0 &lt;= graph[i].length &lt;&nbsp;n</code></li>\n\t<li><code>graph[i]</code> 不包含 <code>i</code></li>\n\t<li>如果 <code>graph[a]</code> 包含 <code>b</code> ，那么 <code>graph[b]</code> 也包含 <code>a</code></li>\n\t<li>输入的图总是连通图</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 848.字母移位",
        "hardRate": "MEDIUM",
        "passRate": "46.25%",
        "problemsUrl": "https://leetcode.cn/problems/shifting-letters/",
        "solutionsUrl": "https://leetcode.cn/problems/shifting-letters/solution",
        "problemsDesc": "<p>有一个由小写字母组成的字符串 <code>s</code>，和一个长度相同的整数数组 <code>shifts</code>。</p>\n\n<p>我们将字母表中的下一个字母称为原字母的 <em>移位</em>&nbsp;<code>shift()</code>&nbsp;（由于字母表是环绕的， <code>'z'</code>&nbsp;将会变成&nbsp;<code>'a'</code>）。</p>\n\n<ul>\n\t<li>例如，<code>shift('a') = 'b'<font color=\"#333333\"><font face=\"Helvetica Neue, Helvetica, Arial, sans-serif\"><span style=\"font-size:14px\"><span style=\"background-color:#ffffff\">,&nbsp;</span></span></font></font></code><code>shift('t') = 'u'</code>,&nbsp;以及&nbsp;<code>shift('z') = 'a'</code>。</li>\n</ul>\n\n<p>对于每个&nbsp;<code>shifts[i] = x</code>&nbsp;， 我们会将 <code>s</code>&nbsp;中的前&nbsp;<code>i + 1</code>&nbsp;个字母移位&nbsp;<code>x</code>&nbsp;次。</p>\n\n<p>返回 <em>将所有这些移位都应用到 <code>s</code> 后最终得到的字符串</em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\", shifts = [3,5,9]\n<strong>输出：</strong>\"rpl\"\n<strong>解释： </strong>\n我们以 \"abc\" 开始。\n将 S 中的第 1 个字母移位 3 次后，我们得到 \"dbc\"。\n再将 S 中的前 2 个字母移位 5 次后，我们得到 \"igc\"。\n最后将 S 中的这 3 个字母移位 9 次后，我们得到答案 \"rpl\"。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"aaa\", shifts = [1,2,3]\n<strong>输出:</strong> \"gfd\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;由小写英文字母组成</li>\n\t<li><code>shifts.length == s.length</code></li>\n\t<li><code>0 &lt;= shifts[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n<span style=\"display:block\"><span style=\"height:0px\"><span style=\"position:absolute\">​​​​​​</span></span></span>",
        "isPlus": false
    },
    {
        "problemsName": " 849.到最近的人的最大距离",
        "hardRate": "MEDIUM",
        "passRate": "44.18%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-distance-to-closest-person/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-distance-to-closest-person/solution",
        "problemsDesc": "<p>给你一个数组 <code>seats</code> 表示一排座位，其中 <code>seats[i] = 1</code> 代表有人坐在第 <code>i</code> 个座位上，<code>seats[i] = 0</code> 代表座位 <code>i</code> 上是空的（<strong>下标从 0 开始</strong>）。</p>\n\n<p>至少有一个空座位，且至少有一人已经坐在座位上。</p>\n\n<p>亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。</p>\n\n<p>返回他到离他最近的人的最大距离。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/10/distance.jpg\" style=\"width: 650px; height: 257px;\" />\n<pre>\n<strong>输入：</strong>seats = [1,0,0,0,1,0,1]\n<strong>输出：</strong>2\n<strong>解释：\n</strong>如果亚历克斯坐在第二个空位（seats[2]）上，他到离他最近的人的距离为 2 。\n如果亚历克斯坐在其它任何一个空位上，他到离他最近的人的距离为 1 。\n因此，他到离他最近的人的最大距离是 2 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>seats = [1,0,0,0]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n如果亚历克斯坐在最后一个座位上，他离最近的人有 3 个座位远。\n这是可能的最大距离，所以答案是 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>seats = [0,1]\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= seats.length <= 2 * 10<sup>4</sup></code></li>\n\t<li><code>seats[i]</code> 为 <code>0</code> 或 <code>1</code></li>\n\t<li>至少有一个 <strong>空座位</strong></li>\n\t<li>至少有一个 <strong>座位上有人</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 850.矩形面积 II",
        "hardRate": "HARD",
        "passRate": "62.92%",
        "problemsUrl": "https://leetcode.cn/problems/rectangle-area-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/rectangle-area-ii/solution",
        "problemsDesc": "<p>给你一个轴对齐的二维数组&nbsp;<code>rectangles</code>&nbsp;。 对于&nbsp;<code>rectangle[i] = [x1, y1, x2, y2]</code>，其中（x1，y1）是矩形&nbsp;<code>i</code>&nbsp;左下角的坐标，<meta charset=\"UTF-8\" />&nbsp;<code>(x<sub>i1</sub>, y<sub>i1</sub>)</code>&nbsp;是该矩形 <strong>左下角</strong> 的坐标，<meta charset=\"UTF-8\" />&nbsp;<code>(x<sub>i2</sub>, y<sub>i2</sub>)</code>&nbsp;是该矩形&nbsp;<strong>右上角</strong> 的坐标。</p>\n\n<p>计算平面中所有&nbsp;<code>rectangles</code>&nbsp;所覆盖的 <strong>总面积 </strong>。任何被两个或多个矩形覆盖的区域应只计算 <strong>一次</strong> 。</p>\n\n<p>返回<em> <strong>总面积</strong> </em>。因为答案可能太大，返回<meta charset=\"UTF-8\" />&nbsp;<code>10<sup>9</sup>&nbsp;+ 7</code> 的&nbsp;<strong>模</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/06/rectangle_area_ii_pic.png\" style=\"height: 360px; width: 480px;\" /></p>\n\n<pre>\n<strong>输入：</strong>rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]\n<strong>输出：</strong>6\n<strong>解释：</strong>如图所示，三个矩形覆盖了总面积为 6 的区域。\n从(1,1)到(2,2)，绿色矩形和红色矩形重叠。\n从(1,0)到(2,3)，三个矩形都重叠。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rectangles = [[0,0,1000000000,1000000000]]\n<strong>输出：</strong>49\n<strong>解释：</strong>答案是 10<sup>18</sup> 对 (10<sup>9</sup> + 7) 取模的结果， 即 49 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rectangles.length &lt;= 200</code></li>\n\t<li><code>rectanges[i].length = 4</code><meta charset=\"UTF-8\" /></li>\n\t<li><code>0 &lt;= x<sub>i1</sub>, y<sub>i1</sub>, x<sub>i2</sub>, y<sub>i2</sub>&nbsp;&lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 851.喧闹和富有",
        "hardRate": "MEDIUM",
        "passRate": "63.09%",
        "problemsUrl": "https://leetcode.cn/problems/loud-and-rich/",
        "solutionsUrl": "https://leetcode.cn/problems/loud-and-rich/solution",
        "problemsDesc": "<p>有一组 <code>n</code> 个人作为实验对象，从 <code>0</code> 到 <code>n - 1</code> 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为&nbsp;<code>x</code>&nbsp;的人简称为 \"person&nbsp;<code>x</code>&nbsp;\"。</p>\n\n<p>给你一个数组 <code>richer</code> ，其中 <code>richer[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示 person&nbsp;<code>a<sub>i</sub></code>&nbsp;比 person&nbsp;<code>b<sub>i</sub></code>&nbsp;更有钱。另给你一个整数数组 <code>quiet</code> ，其中&nbsp;<code>quiet[i]</code> 是 person <code>i</code> 的安静值。<code>richer</code> 中所给出的数据 <strong>逻辑自洽</strong>（也就是说，在 person <code>x</code> 比 person <code>y</code> 更有钱的同时，不会出现 person <code>y</code> 比 person <code>x</code> 更有钱的情况 ）。</p>\n\n<p>现在，返回一个整数数组 <code>answer</code> 作为答案，其中&nbsp;<code>answer[x] = y</code>&nbsp;的前提是，在所有拥有的钱肯定不少于&nbsp;person&nbsp;<code>x</code>&nbsp;的人中，person&nbsp;<code>y</code>&nbsp;是最安静的人（也就是安静值&nbsp;<code>quiet[y]</code>&nbsp;最小的人）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\n<strong>输出：</strong>[5,5,2,5,4,5,6,7]\n<strong>解释： </strong>\nanswer[0] = 5，\nperson 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。\n唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7，\n但是目前还不清楚他是否比 person 0 更有钱。\nanswer[7] = 7，\n在所有拥有的钱肯定不少于 person 7 的人中（这可能包括 person 3，4，5，6 以及 7），\n最安静（有较低安静值 quiet[x]）的人是 person 7。\n其他的答案也可以用类似的推理来解释。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>richer = [], quiet = [0]\n<strong>输出：</strong>[0]\n</pre>\n&nbsp;\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == quiet.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>0 &lt;= quiet[i] &lt; n</code></li>\n\t<li><code>quiet</code> 的所有值 <strong>互不相同</strong></li>\n\t<li><code>0 &lt;= richer.length &lt;= n * (n - 1) / 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i </sub>!= b<sub>i</sub></code></li>\n\t<li><code>richer</code> 中的所有数对 <strong>互不相同</strong></li>\n\t<li>对<strong> </strong><code>richer</code> 的观察在逻辑上是一致的</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 852.山脉数组的峰顶索引",
        "hardRate": "MEDIUM",
        "passRate": "68.64%",
        "problemsUrl": "https://leetcode.cn/problems/peak-index-in-a-mountain-array/",
        "solutionsUrl": "https://leetcode.cn/problems/peak-index-in-a-mountain-array/solution",
        "problemsDesc": "符合下列属性的数组 <code>arr</code> 称为 <strong>山脉数组</strong> ：\n<ul>\n\t<li><code>arr.length &gt;= 3</code></li>\n\t<li>存在 <code>i</code>（<code>0 &lt; i&nbsp;&lt; arr.length - 1</code>）使得：\n\t<ul>\n\t\t<li><code>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] </code></li>\n\t\t<li><code>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>给你由整数组成的山脉数组 <code>arr</code> ，返回满足 <code>arr[0] &lt; arr[1] &lt; ... arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code> 的下标 <code>i</code> 。</p>\n\n<p>你必须设计并实现时间复杂度为 <code>O(log(n))</code> 的解决方案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,1,0]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,2,1,0]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,10,5,2]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10<sup>6</sup></code></li>\n\t<li>题目数据保证 <code>arr</code> 是一个山脉数组</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 853.车队",
        "hardRate": "MEDIUM",
        "passRate": "41.40%",
        "problemsUrl": "https://leetcode.cn/problems/car-fleet/",
        "solutionsUrl": "https://leetcode.cn/problems/car-fleet/solution",
        "problemsDesc": "<p>在一条单行道上，有 <code>n</code> 辆车开往同一目的地。目的地是几英里以外的&nbsp;<code>target</code>&nbsp;。</p>\n\n<p>给定两个整数数组&nbsp;<code>position</code>&nbsp;和&nbsp;<code>speed</code>&nbsp;，长度都是 <code>n</code> ，其中&nbsp;<code>position[i]</code>&nbsp;是第 <code>i</code> 辆车的位置，&nbsp;<code>speed[i]</code>&nbsp;是第 <code>i</code> 辆车的速度(单位是英里/小时)。</p>\n\n<p>一辆车永远不会超过前面的另一辆车，但它可以追上去，并与前车 <strong>以相同的速度</strong> 紧接着行驶。此时，我们会忽略这两辆车之间的距离，也就是说，它们被假定处于相同的位置。</p>\n\n<p><strong>车队</strong><em>&nbsp;</em>是一些由行驶在相同位置、具有相同速度的车组成的非空集合。注意，一辆车也可以是一个车队。</p>\n\n<p>即便一辆车在目的地才赶上了一个车队，它们仍然会被视作是同一个车队。</p>\n\n<p>返回到达目的地的 <strong>车队数量</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n从 10 和 8 开始的车会组成一个车队，它们在 12 处相遇。\n从 0 处开始的车无法追上其它车，所以它自己就是一个车队。\n从 5 和 3 开始的车会组成一个车队，它们在 6 处相遇。\n请注意，在到达目的地之前没有其它车会遇到这些车队，所以答案是 3。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> target = 10, position = [3], speed = [3]\n<strong>输出:</strong> 1\n<strong>解释:</strong> 只有一辆车，因此只有一个车队。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> target = 100, position = [0,2,4], speed = [4,2,1]\n<strong>输出:</strong> 1\n<strong>解释:</strong>\n以0(速度4)和2(速度2)出发的车辆组成车队，在4点相遇。舰队以2的速度前进。\n然后，车队(速度2)和以4(速度1)出发的汽车组成一个车队，在6点相遇。舰队以1的速度前进，直到到达目标。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == position.length == speed.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt; target &lt;= 10<sup>6</sup></code></li>\n\t<li><code>0 &lt;= position[i] &lt; target</code></li>\n\t<li><code>position</code>&nbsp;中每个值都 <strong>不同</strong></li>\n\t<li><code>0 &lt; speed[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 854.相似度为 K 的字符串",
        "hardRate": "HARD",
        "passRate": "46.76%",
        "problemsUrl": "https://leetcode.cn/problems/k-similar-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/k-similar-strings/solution",
        "problemsDesc": "<p>对于某些非负整数 <code>k</code> ，如果交换 <code>s1</code> 中两个字母的位置恰好 <code>k</code> 次，能够使结果字符串等于 <code>s2</code> ，则认为字符串 <code>s1</code> 和 <code>s2</code> 的<strong> 相似度为 </strong><code>k</code><strong> </strong><strong>。</strong></p>\n\n<p>给你两个字母异位词 <code>s1</code> 和 <code>s2</code> ，返回 <code>s1</code> 和 <code>s2</code> 的相似度 <code>k</code><strong> </strong>的最小值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"ab\", s2 = \"ba\"\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"abc\", s2 = \"bca\"\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length &lt;= 20</code></li>\n\t<li><code>s2.length == s1.length</code></li>\n\t<li><code>s1</code>&nbsp;和&nbsp;<code>s2</code>&nbsp;&nbsp;只包含集合&nbsp;<code>{'a', 'b', 'c', 'd', 'e', 'f'}</code>&nbsp;中的小写字母</li>\n\t<li><code>s2</code> 是 <code>s1</code> 的一个字母异位词</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 855.考场就座",
        "hardRate": "MEDIUM",
        "passRate": "47.69%",
        "problemsUrl": "https://leetcode.cn/problems/exam-room/",
        "solutionsUrl": "https://leetcode.cn/problems/exam-room/solution",
        "problemsDesc": "<p>在考场里，一排有&nbsp;<code>N</code>&nbsp;个座位，分别编号为&nbsp;<code>0, 1, 2, ..., N-1</code>&nbsp;。</p>\n\n<p>当学生进入考场后，他必须坐在能够使他与离他最近的人之间的距离达到最大化的座位上。如果有多个这样的座位，他会坐在编号最小的座位上。(另外，如果考场里没有人，那么学生就坐在 0 号座位上。)</p>\n\n<p>返回&nbsp;<code>ExamRoom(int N)</code>&nbsp;类，它有两个公开的函数：其中，函数&nbsp;<code>ExamRoom.seat()</code>&nbsp;会返回一个&nbsp;<code>int</code>&nbsp;（整型数据），代表学生坐的位置；函数&nbsp;<code>ExamRoom.leave(int p)</code>&nbsp;代表坐在座位 <code>p</code> 上的学生现在离开了考场。每次调用&nbsp;<code>ExamRoom.leave(p)</code>&nbsp;时都保证有学生坐在座位&nbsp;<code>p</code>&nbsp;上。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>[&quot;ExamRoom&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;leave&quot;,&quot;seat&quot;], [[10],[],[],[],[],[4],[]]\n<strong>输出：</strong>[null,0,9,4,2,null,5]\n<strong>解释：</strong>\nExamRoom(10) -&gt; null\nseat() -&gt; 0，没有人在考场里，那么学生坐在 0 号座位上。\nseat() -&gt; 9，学生最后坐在 9 号座位上。\nseat() -&gt; 4，学生最后坐在 4 号座位上。\nseat() -&gt; 2，学生最后坐在 2 号座位上。\nleave(4) -&gt; null\nseat() -&gt; 5，学生最后坐在 5 号座位上。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= N &lt;= 10^9</code></li>\n\t<li>在所有的测试样例中&nbsp;<code>ExamRoom.seat()</code>&nbsp;和&nbsp;<code>ExamRoom.leave()</code>&nbsp;最多被调用&nbsp;<code>10^4</code>&nbsp;次。</li>\n\t<li>保证在调用&nbsp;<code>ExamRoom.leave(p)</code>&nbsp;时有学生正坐在座位 <code>p</code> 上。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 856.括号的分数",
        "hardRate": "MEDIUM",
        "passRate": "68.44%",
        "problemsUrl": "https://leetcode.cn/problems/score-of-parentheses/",
        "solutionsUrl": "https://leetcode.cn/problems/score-of-parentheses/solution",
        "problemsDesc": "<p>给定一个平衡括号字符串&nbsp;<code>S</code>，按下述规则计算该字符串的分数：</p>\n\n<ul>\n\t<li><code>()</code> 得 1 分。</li>\n\t<li><code>AB</code> 得&nbsp;<code>A + B</code>&nbsp;分，其中 A 和 B 是平衡括号字符串。</li>\n\t<li><code>(A)</code> 得&nbsp;<code>2 * A</code>&nbsp;分，其中 A 是平衡括号字符串。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入： </strong>&quot;()&quot;\n<strong>输出： </strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入： </strong>&quot;(())&quot;\n<strong>输出： </strong>2\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre><strong>输入： </strong>&quot;()()&quot;\n<strong>输出： </strong>2\n</pre>\n\n<p><strong>示例&nbsp;4：</strong></p>\n\n<pre><strong>输入： </strong>&quot;(()(()))&quot;\n<strong>输出： </strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>S</code>&nbsp;是平衡括号字符串，且只含有&nbsp;<code>(</code>&nbsp;和&nbsp;<code>)</code>&nbsp;。</li>\n\t<li><code>2 &lt;= S.length &lt;= 50</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 857.雇佣 K 名工人的最低成本",
        "hardRate": "HARD",
        "passRate": "63.58%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/solution",
        "problemsDesc": "<p>有 <code>n</code>&nbsp;名工人。&nbsp;给定两个数组&nbsp;<code>quality</code>&nbsp;和&nbsp;<code>wage</code>&nbsp;，其中，<code>quality[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;名工人的工作质量，其最低期望工资为&nbsp;<code>wage[i]</code>&nbsp;。</p>\n\n<p>现在我们想雇佣&nbsp;<code>k</code>&nbsp;名工人组成一个<em>工资组。</em>在雇佣&nbsp;一组 <code>k</code>&nbsp;名工人时，我们必须按照下述规则向他们支付工资：</p>\n\n<ol>\n\t<li>对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。</li>\n\t<li>工资组中的每名工人至少应当得到他们的最低期望工资。</li>\n</ol>\n\n<p>给定整数 <code>k</code> ，返回 <em>组成满足上述条件的付费群体所需的最小金额&nbsp;</em>。在实际答案的&nbsp;<code>10<sup>-5</sup></code>&nbsp;以内的答案将被接受。。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入： </strong>quality = [10,20,5], wage = [70,50,30], k = 2\n<strong>输出： </strong>105.00000\n<strong>解释：</strong> 我们向 0 号工人支付 70，向 2 号工人支付 35。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入： </strong>quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3\n<strong>输出： </strong>30.66667\n<strong>解释： </strong>我们向 0 号工人支付 4，向 2 号和 3 号分别支付 13.33333。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == quality.length == wage.length</code></li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= quality[i], wage[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 858.镜面反射",
        "hardRate": "MEDIUM",
        "passRate": "57.37%",
        "problemsUrl": "https://leetcode.cn/problems/mirror-reflection/",
        "solutionsUrl": "https://leetcode.cn/problems/mirror-reflection/solution",
        "problemsDesc": "<p>有一个特殊的正方形房间，每面墙上都有一面镜子。除西南角以外，每个角落都放有一个接受器，编号为&nbsp;<code>0</code>，&nbsp;<code>1</code>，以及&nbsp;<code>2</code>。</p>\n\n<p>正方形房间的墙壁长度为&nbsp;<code>p</code>，一束激光从西南角射出，首先会与东墙相遇，入射点到接收器 <code>0</code> 的距离为 <code>q</code> 。</p>\n\n<p>返回光线最先遇到的接收器的编号（保证光线最终会遇到一个接收器）。</p>\n&nbsp;\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/18/reflection.png\" style=\"width: 218px; height: 217px;\" />\n<pre>\n<strong>输入：</strong>p = 2, q = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>这条光线在第一次被反射回左边的墙时就遇到了接收器 2 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>p = 3, q = 1\n<strong>输入：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= q &lt;= p &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 859.亲密字符串",
        "hardRate": "EASY",
        "passRate": "34.51%",
        "problemsUrl": "https://leetcode.cn/problems/buddy-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/buddy-strings/solution",
        "problemsDesc": "<p>给你两个字符串 <code>s</code> 和 <code>goal</code> ，只要我们可以通过交换 <code>s</code> 中的两个字母得到与 <code>goal</code> 相等的结果，就返回&nbsp;<code>true</code>&nbsp;；否则返回 <code>false</code> 。</p>\n\n<p>交换字母的定义是：取两个下标 <code>i</code> 和 <code>j</code> （下标从 <code>0</code> 开始）且满足 <code>i != j</code> ，接着交换 <code>s[i]</code> 和 <code>s[j]</code> 处的字符。</p>\n\n<ul>\n\t<li>例如，在 <code>\"abcd\"</code> 中交换下标 <code>0</code> 和下标 <code>2</code> 的元素可以生成 <code>\"cbad\"</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ab\", goal = \"ba\"\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以交换 s[0] = 'a' 和 s[1] = 'b' 生成 \"ba\"，此时 s 和 goal 相等。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ab\", goal = \"ab\"\n<strong>输出：</strong>false\n<strong>解释：</strong>你只能交换 s[0] = 'a' 和 s[1] = 'b' 生成 \"ba\"，此时 s 和 goal 不相等。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aa\", goal = \"aa\"\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以交换 s[0] = 'a' 和 s[1] = 'a' 生成 \"aa\"，此时 s 和 goal 相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, goal.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> 和 <code>goal</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 860.柠檬水找零",
        "hardRate": "EASY",
        "passRate": "58.60%",
        "problemsUrl": "https://leetcode.cn/problems/lemonade-change/",
        "solutionsUrl": "https://leetcode.cn/problems/lemonade-change/solution",
        "problemsDesc": "<p>在柠檬水摊上，每一杯柠檬水的售价为&nbsp;<code>5</code>&nbsp;美元。顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p>\n\n<p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p>\n\n<p>注意，一开始你手头没有任何零钱。</p>\n\n<p>给你一个整数数组 <code>bills</code> ，其中 <code>bills[i]</code> 是第 <code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回&nbsp;<code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>bills = [5,5,5,10,20]\n<strong>输出：</strong>true\n<strong>解释：\n</strong>前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。\n第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。\n第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。\n由于所有客户都得到了正确的找零，所以我们输出 true。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>bills = [5,5,10,10,20]\n<strong>输出：</strong>false\n<strong>解释：</strong>\n前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。\n对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。\n对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。\n由于不是每位顾客都得到了正确的找零，所以答案是 false。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= bills.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>bills[i]</code>&nbsp;不是&nbsp;<code>5</code>&nbsp;就是&nbsp;<code>10</code>&nbsp;或是&nbsp;<code>20</code>&nbsp;</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 861.翻转矩阵后的得分",
        "hardRate": "MEDIUM",
        "passRate": "80.79%",
        "problemsUrl": "https://leetcode.cn/problems/score-after-flipping-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/score-after-flipping-matrix/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的二元矩阵 <code>grid</code> ，矩阵中每个元素的值为 <code>0</code> 或 <code>1</code> 。</p>\n\n<p>一次 <strong>移动</strong> 是指选择任一行或列，并转换该行或列中的每一个值：将所有 <code>0</code> 都更改为 <code>1</code>，将所有 <code>1</code> 都更改为 <code>0</code>。</p>\n\n<p>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的 <strong>得分</strong> 就是这些数字的总和。</p>\n\n<p>在执行任意次 <strong>移动</strong> 后（含 0 次），返回可能的最高分数。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-toogle1.jpg\" style=\"width: 500px; height: 299px;\" />\n<pre>\n<strong>输入：</strong>grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]\n<strong>输出：</strong>39\n<strong>解释：</strong>0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0]]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 20</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 862.和至少为 K 的最短子数组",
        "hardRate": "HARD",
        "passRate": "26.53%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，找出 <code>nums</code> 中和至少为 <code>k</code> 的 <strong>最短非空子数组</strong> ，并返回该子数组的长度。如果不存在这样的 <strong>子数组</strong> ，返回 <code>-1</code> 。</p>\n\n<p><strong>子数组</strong> 是数组中 <strong>连续</strong> 的一部分。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1], k = 1\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2], k = 4\n<strong>输出：</strong>-1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,-1,2], k = 3\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 863.二叉树中所有距离为 K 的结点",
        "hardRate": "MEDIUM",
        "passRate": "61.41%",
        "problemsUrl": "https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/solution",
        "problemsDesc": "<p>给定一个二叉树（具有根结点&nbsp;<code>root</code>），&nbsp;一个目标结点&nbsp;<code>target</code>&nbsp;，和一个整数值 <code>k</code> 。</p>\n\n<p>返回到目标结点 <code>target</code> 距离为 <code>k</code> 的所有结点的值的列表。 答案可以以 <strong>任何顺序</strong> 返回。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png\" style=\"height: 429px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2\n<strong>输出：</strong>[7,4,1]\n<strong>解释：</strong>所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> root = [1], target = 1, k = 3\n<strong>输出:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>节点数在&nbsp;<code>[1, 500]</code>&nbsp;范围内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 500</code></li>\n\t<li><code>Node.val</code>&nbsp;中所有值 <strong>不同</strong></li>\n\t<li>目标结点&nbsp;<code>target</code>&nbsp;是树上的结点。</li>\n\t<li><code>0 &lt;= k &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 864.获取所有钥匙的最短路径",
        "hardRate": "HARD",
        "passRate": "59.47%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-path-to-get-all-keys/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-path-to-get-all-keys/solution",
        "problemsDesc": "<p>给定一个二维网格&nbsp;<code>grid</code>&nbsp;，其中：</p>\n\n<ul>\n\t<li><font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">'.'</span></span></font></font> 代表一个空房间</li>\n\t<li><font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">'#'</span></span></font></font> 代表一堵墙</li>\n\t<li><font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">'@'</span></span></font></font>&nbsp;是起点</li>\n\t<li>小写字母代表钥匙</li>\n\t<li>大写字母代表锁</li>\n</ul>\n\n<p>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。</p>\n\n<p>假设 k&nbsp;为 钥匙/锁 的个数，且满足&nbsp;<code>1 &lt;= k&nbsp;&lt;= 6</code>，字母表中的前 <code>k</code>&nbsp;个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。</p>\n\n<p>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-keys2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [\"@.a.#\",\"###.#\",\"b.A.B\"]\n<strong>输出：</strong>8\n<strong>解释：</strong>目标是获得所有钥匙，而不是打开所有锁。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-key2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [\"@..aA\",\"..B#.\",\"....b\"]\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-keys3.jpg\" />\n<pre>\n<strong>输入:</strong> grid = [\"@Aa\"]\n<strong>输出:</strong> -1</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 30</code></li>\n\t<li><code>grid[i][j]</code>&nbsp;只含有&nbsp;<code>'.'</code>,&nbsp;<code>'#'</code>,&nbsp;<code>'@'</code>,&nbsp;<code>'a'-</code><code>'f</code><code>'</code>&nbsp;以及&nbsp;<code>'A'-'F'</code></li>\n\t<li>钥匙的数目范围是&nbsp;<code>[1, 6]</code>&nbsp;</li>\n\t<li>每个钥匙都对应一个 <strong>不同</strong> 的字母</li>\n\t<li>每个钥匙正好打开一个对应的锁</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 865.具有所有最深节点的最小子树",
        "hardRate": "MEDIUM",
        "passRate": "68.79%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/solution",
        "problemsDesc": "<p>给定一个根为&nbsp;<code>root</code>&nbsp;的二叉树，每个节点的深度是 <strong>该节点到根的最短距离</strong> 。</p>\n\n<p>返回包含原始树中所有 <strong>最深节点</strong> 的 <em>最小子树</em> 。</p>\n\n<p>如果一个节点在 <strong>整个树 </strong>的任意节点之间具有最大的深度，则该节点是 <strong>最深的</strong> 。</p>\n\n<p>一个节点的 <strong>子树</strong> 是该节点加上它的所有后代的集合。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png\" style=\"width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4]\n<strong>输出：</strong>[2,7,4]\n<strong>解释：</strong>\n我们返回值为 2 的节点，在图中用黄色标记。\n在图中用蓝色标记的是树的最深的节点。\n注意，节点 5、3 和 2 包含树中最深的节点，但节点 2 的子树最小，因此我们返回它。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[1]\n<strong>解释：</strong>根节点是树中最深的节点。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [0,1,3,null,2]\n<strong>输出：</strong>[2]\n<strong>解释：</strong>树中最深的节点为 2 ，有效子树为节点 2、1 和 0 的子树，但节点 2 的子树最小。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数量在<meta charset=\"UTF-8\" />&nbsp;<code>[1, 500]</code>&nbsp;范围内。</li>\n\t<li><code>0 &lt;= Node.val &lt;= 500</code></li>\n\t<li>每个节点的值都是 <strong>独一无二</strong> 的。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与力扣 1123 重复：<a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/\" target=\"_blank\">https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 866.回文素数",
        "hardRate": "MEDIUM",
        "passRate": "23.84%",
        "problemsUrl": "https://leetcode.cn/problems/prime-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/prime-palindrome/solution",
        "problemsDesc": "<p>求出大于或等于&nbsp;<code>N</code>&nbsp;的最小回文素数。</p>\n\n<p>回顾一下，如果一个数大于 1，且其因数只有 1 和它自身，那么这个数是<em>素数</em>。</p>\n\n<p>例如，2，3，5，7，11 以及&nbsp;13 是素数。</p>\n\n<p>回顾一下，如果一个数从左往右读与从右往左读是一样的，那么这个数是<em>回文数。</em></p>\n\n<p>例如，12321 是回文数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>6\n<strong>输出：</strong>7\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre><strong>输入：</strong>8\n<strong>输出：</strong>11\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre><strong>输入：</strong>13\n<strong>输出：</strong>101</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= N &lt;= 10^8</code></li>\n\t<li>答案肯定存在，且小于&nbsp;<code>2 * 10^8</code>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 867.转置矩阵",
        "hardRate": "EASY",
        "passRate": "66.76%",
        "problemsUrl": "https://leetcode.cn/problems/transpose-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/transpose-matrix/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>matrix</code>， 返回 <code>matrix</code> 的 <strong>转置矩阵</strong> 。</p>\n\n<p>矩阵的 <strong>转置</strong> 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/10/hint_transpose.png\" style=\"width: 600px; height: 197px;\" /></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>[[1,4,7],[2,5,8],[3,6,9]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3],[4,5,6]]\n<strong>输出：</strong>[[1,4],[2,5],[3,6]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 <= m, n <= 1000</code></li>\n\t<li><code>1 <= m * n <= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> <= matrix[i][j] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 868.二进制间距",
        "hardRate": "EASY",
        "passRate": "69.33%",
        "problemsUrl": "https://leetcode.cn/problems/binary-gap/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-gap/solution",
        "problemsDesc": "<p>给定一个正整数 <code>n</code>，找到并返回 <code>n</code> 的二进制表示中两个 <strong>相邻</strong> 1 之间的<strong> 最长距离 </strong>。如果不存在两个相邻的 1，返回 <code>0</code> 。</p>\n\n<p>如果只有 <code>0</code> 将两个 <code>1</code> 分隔开（可能不存在 <code>0</code> ），则认为这两个 1 彼此 <strong>相邻</strong> 。两个 <code>1</code> 之间的距离是它们的二进制表示中位置的绝对差。例如，<code>\"1001\"</code> 中的两个 <code>1</code> 的距离为 3 。</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 22\n<strong>输出：</strong>2\n<strong>解释：</strong>22 的二进制是 \"10110\" 。\n在 22 的二进制表示中，有三个 1，组成两对相邻的 1 。\n第一对相邻的 1 中，两个 1 之间的距离为 2 。\n第二对相邻的 1 中，两个 1 之间的距离为 1 。\n答案取两个距离之中最大的，也就是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 8\n<strong>输出：</strong>0\n<strong>解释：</strong>8 的二进制是 \"1000\" 。\n在 8 的二进制表示中没有相邻的两个 1，所以返回 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>5 的二进制是 \"101\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 869.重新排序得到 2 的幂",
        "hardRate": "MEDIUM",
        "passRate": "63.59%",
        "problemsUrl": "https://leetcode.cn/problems/reordered-power-of-2/",
        "solutionsUrl": "https://leetcode.cn/problems/reordered-power-of-2/solution",
        "problemsDesc": "<p>给定正整数&nbsp;<code>n</code>&nbsp;，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。</p>\n\n<p>如果我们可以通过上述方式得到&nbsp;2 的幂，返回 <code>true</code>；否则，返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 870.优势洗牌",
        "hardRate": "MEDIUM",
        "passRate": "50.43%",
        "problemsUrl": "https://leetcode.cn/problems/advantage-shuffle/",
        "solutionsUrl": "https://leetcode.cn/problems/advantage-shuffle/solution",
        "problemsDesc": "<p>给定两个长度相等的数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>，<code>nums1</code>&nbsp;相对于 <code>nums2</code> 的<em>优势</em>可以用满足&nbsp;<code>nums1[i] &gt; nums2[i]</code>&nbsp;的索引 <code>i</code>&nbsp;的数目来描述。</p>\n\n<p>返回 <font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\" size=\"1\"><span style=\"background-color: rgb(249, 242, 244);\">nums1</span></font>&nbsp;的<strong>任意</strong>排列，使其相对于 <code>nums2</code>&nbsp;的优势最大化。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [2,7,11,15], nums2 = [1,10,4,11]\n<strong>输出：</strong>[2,11,7,15]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [12,24,8,32], nums2 = [13,25,32,11]\n<strong>输出：</strong>[24,32,8,12]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums2.length == nums1.length</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 871.最低加油次数",
        "hardRate": "HARD",
        "passRate": "43.22%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-refueling-stops/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-refueling-stops/solution",
        "problemsDesc": "<p>汽车从起点出发驶向目的地，该目的地位于出发位置东面 <code>target</code>&nbsp;英里处。</p>\n\n<p>沿途有加油站，用数组&nbsp;<code>stations</code> 表示。其中 <code>stations[i] = [position<sub>i</sub>, fuel<sub>i</sub>]</code> 表示第 <code>i</code> 个加油站位于出发位置东面&nbsp;<code>position<sub>i</sub></code> 英里处，并且有&nbsp;<code>fuel<sub>i</sub></code>&nbsp;升汽油。</p>\n\n<p>假设汽车油箱的容量是无限的，其中最初有&nbsp;<code>startFuel</code>&nbsp;升燃料。它每行驶 1 英里就会用掉 1 升汽油。当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。</p>\n\n<p>为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 <code>-1</code> 。</p>\n\n<p>注意：如果汽车到达加油站时剩余燃料为 <code>0</code>，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 <code>0</code>，仍然认为它已经到达目的地。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 1, startFuel = 1, stations = []\n<strong>输出：</strong>0\n<strong>解释：</strong>可以在不加油的情况下到达目的地。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 100, startFuel = 1, stations = [[10,100]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>无法抵达目的地，甚至无法到达第一个加油站。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n出发时有 10 升燃料。\n开车来到距起点 10 英里处的加油站，消耗 10 升燃料。将汽油从 0 升加到 60 升。\n然后，从 10 英里处的加油站开到 60 英里处的加油站（消耗 50 升燃料），\n并将汽油从 10 升加到 50 升。然后开车抵达目的地。\n沿途在两个加油站停靠，所以返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target, startFuel &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= stations.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= position<sub>i</sub> &lt; position<sub>i+1</sub> &lt; target</code></li>\n\t<li><code>1 &lt;= fuel<sub>i</sub> &lt; 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 872.叶子相似的树",
        "hardRate": "EASY",
        "passRate": "64.99%",
        "problemsUrl": "https://leetcode.cn/problems/leaf-similar-trees/",
        "solutionsUrl": "https://leetcode.cn/problems/leaf-similar-trees/solution",
        "problemsDesc": "<p>请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个&nbsp;<strong>叶值序列 </strong>。</p>\n\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png\" style=\"height: 336px; width: 400px;\" /></p>\n\n<p>举个例子，如上图所示，给定一棵叶值序列为&nbsp;<code>(6, 7, 4, 9, 8)</code>&nbsp;的树。</p>\n\n<p>如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是&nbsp;<em>叶相似&nbsp;</em>的。</p>\n\n<p>如果给定的两个根结点分别为&nbsp;<code>root1</code> 和&nbsp;<code>root2</code>&nbsp;的树是叶相似的，则返回&nbsp;<code>true</code>；否则返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-1.jpg\" style=\"height: 237px; width: 600px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-2.jpg\" style=\"height: 110px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root1 = [1,2,3], root2 = [1,3,2]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给定的两棵树结点数在&nbsp;<code>[1, 200]</code> 范围内</li>\n\t<li>给定的两棵树上的值在&nbsp;<code>[0, 200]</code> 范围内</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 873.最长的斐波那契子序列的长度",
        "hardRate": "MEDIUM",
        "passRate": "56.25%",
        "problemsUrl": "https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/solution",
        "problemsDesc": "<p>如果序列 <code>X_1, X_2, ..., X_n</code> 满足下列条件，就说它是 <em>斐波那契式 </em>的：</p>\n\n<ul>\n\t<li><code>n >= 3</code></li>\n\t<li>对于所有 <code>i + 2 <= n</code>，都有 <code>X_i + X_{i+1} = X_{i+2}</code></li>\n</ul>\n\n<p>给定一个<strong>严格递增</strong>的正整数数组形成序列 arr ，找到 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.600000381469727px\"><span style=\"caret-color:#c7254e\"><span style=\"background-color:#f9f2f4\">arr</span></span></span></font></font> 中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。</p>\n\n<p><em>（回想一下，子序列是从原序列 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.600000381469727px\"><span style=\"caret-color:#c7254e\"><span style=\"background-color:#f9f2f4\">arr</span></span></span></font></font> 中派生出来的，它从 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.600000381469727px\"><span style=\"caret-color:#c7254e\"><span style=\"background-color:#f9f2f4\">arr</span></span></span></font></font> 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， <code>[3, 5, 8]</code> 是 <code>[3, 4, 5, 6, 7, 8]</code> 的一个子序列）</em></p>\n\n<p> </p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>arr =<strong> </strong>[1,2,3,4,5,6,7,8]\n<strong>输出: </strong>5\n<strong>解释: </strong>最长的斐波那契式子序列为 [1,2,3,5,8] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>arr =<strong> </strong>[1,3,7,11,12,14,18]\n<strong>输出: </strong>3\n<strong>解释</strong>: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 <= arr.length <= 1000</code></li>\n\t<li>\n\t<p><code>1 <= arr[i] < arr[i + 1] <= 10^9</code></p>\n\t</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 874.模拟行走机器人",
        "hardRate": "MEDIUM",
        "passRate": "43.10%",
        "problemsUrl": "https://leetcode.cn/problems/walking-robot-simulation/",
        "solutionsUrl": "https://leetcode.cn/problems/walking-robot-simulation/solution",
        "problemsDesc": "<p>机器人在一个无限大小的 XY 网格平面上行走，从点 <code>(0, 0)</code> 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 <code>commands</code> ：</p>\n\n<ul>\n\t<li><code>-2</code> ：向左转 <code>90</code> 度</li>\n\t<li><code>-1</code> ：向右转 <code>90</code> 度</li>\n\t<li><code>1 <= x <= 9</code> ：向前移动 <code>x</code> 个单位长度</li>\n</ul>\n\n<p>在网格上有一些格子被视为障碍物 <code>obstacles</code> 。第 <code>i</code> 个障碍物位于网格点  <code>obstacles[i] = (x<sub>i</sub>, y<sub>i</sub>)</code> 。</p>\n\n<p>机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续尝试进行该路线的其余部分。</p>\n\n<p>返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。（即，如果距离为 <code>5</code> ，则返回 <code>25</code> ）</p>\n\n<div class=\"d-google dictRoot saladict-panel isAnimate\">\n<div>\n<div class=\"MachineTrans-Text\">\n<div class=\"MachineTrans-Lines\">\n<div class=\"MachineTrans-Lines-collapse MachineTrans-lang-en\"> </div>\n</div>\n\n<div class=\"MachineTrans-Lines\">\n<p class=\"MachineTrans-lang-zh-CN\"><strong>注意：</strong></p>\n\n<ul>\n\t<li class=\"MachineTrans-lang-zh-CN\">北表示 <code>+Y</code> 方向。</li>\n\t<li class=\"MachineTrans-lang-zh-CN\">东表示 <code>+X</code> 方向。</li>\n\t<li class=\"MachineTrans-lang-zh-CN\">南表示 <code>-Y</code> 方向。</li>\n\t<li class=\"MachineTrans-lang-zh-CN\">西表示 <code>-X</code> 方向。</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>commands = [4,-1,3], obstacles = []\n<strong>输出：</strong>25\n<strong>解释：\n</strong>机器人开始位于 (0, 0)：\n1. 向北移动 4 个单位，到达 (0, 4)\n2. 右转\n3. 向东移动 3 个单位，到达 (3, 4)\n距离原点最远的是 (3, 4) ，距离为 3<sup>2</sup> + 4<sup>2</sup> = 25</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>commands = [4,-1,4,-2,4], obstacles = [[2,4]]\n<strong>输出：</strong>65\n<strong>解释</strong>：机器人开始位于 (0, 0)：\n1. 向北移动 4 个单位，到达 (0, 4)\n2. 右转\n3. 向东移动 1 个单位，然后被位于 (2, 4) 的障碍物阻挡，机器人停在 (1, 4)\n4. 左转\n5. 向北走 4 个单位，到达 (1, 8)\n距离原点最远的是 (1, 8) ，距离为 1<sup>2</sup> + 8<sup>2</sup> = 65</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= commands.length <= 10<sup>4</sup></code></li>\n\t<li><code>commands[i]</code> is one of the values in the list <code>[-2,-1,1,2,3,4,5,6,7,8,9]</code>.</li>\n\t<li><code>0 <= obstacles.length <= 10<sup>4</sup></code></li>\n\t<li><code>-3 * 10<sup>4</sup> <= x<sub>i</sub>, y<sub>i</sub> <= 3 * 10<sup>4</sup></code></li>\n\t<li>答案保证小于 <code>2<sup>31</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 875.爱吃香蕉的珂珂",
        "hardRate": "MEDIUM",
        "passRate": "49.46%",
        "problemsUrl": "https://leetcode.cn/problems/koko-eating-bananas/",
        "solutionsUrl": "https://leetcode.cn/problems/koko-eating-bananas/solution",
        "problemsDesc": "<p>珂珂喜欢吃香蕉。这里有 <code>n</code> 堆香蕉，第 <code>i</code> 堆中有&nbsp;<code>piles[i]</code>&nbsp;根香蕉。警卫已经离开了，将在 <code>h</code> 小时后回来。</p>\n\n<p>珂珂可以决定她吃香蕉的速度 <code>k</code> （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 <code>k</code> 根。如果这堆香蕉少于 <code>k</code> 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。&nbsp;&nbsp;</p>\n\n<p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p>\n\n<p>返回她可以在 <code>h</code> 小时内吃掉所有香蕉的最小速度 <code>k</code>（<code>k</code> 为整数）。</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [3,6,7,11], h = 8\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [30,11,23,4,20], h = 5\n<strong>输出：</strong>30\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [30,11,23,4,20], h = 6\n<strong>输出：</strong>23\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= piles.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>piles.length &lt;= h &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= piles[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 876.链表的中间结点",
        "hardRate": "EASY",
        "passRate": "70.21%",
        "problemsUrl": "https://leetcode.cn/problems/middle-of-the-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/middle-of-the-linked-list/solution",
        "problemsDesc": "<p>给你单链表的头结点 <code>head</code> ，请你找出并返回链表的中间结点。</p>\n\n<p>如果有两个中间结点，则返回第二个中间结点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg\" style=\"width: 544px; height: 65px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5]\n<strong>输出：</strong>[3,4,5]\n<strong>解释：</strong>链表只有一个中间结点，值为 3 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-midlist2.jpg\" style=\"width: 664px; height: 65px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5,6]\n<strong>输出：</strong>[4,5,6]\n<strong>解释：</strong>该链表有两个中间结点，值分别为 3 和 4 ，返回第二个结点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表的结点数范围是 <code>[1, 100]</code></li>\n\t<li><code>1 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 877.石子游戏",
        "hardRate": "MEDIUM",
        "passRate": "76.46%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game/solution",
        "problemsDesc": "<p>Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，<strong>排成一行</strong>；每堆都有 <strong>正</strong> 整数颗石子，数目为 <code>piles[i]</code>&nbsp;。</p>\n\n<p>游戏以谁手中的石子最多来决出胜负。石子的 <strong>总数</strong> 是 <strong>奇数</strong> ，所以没有平局。</p>\n\n<p>Alice 和 Bob 轮流进行，<strong>Alice 先开始</strong> 。 每回合，玩家从行的 <strong>开始</strong> 或 <strong>结束</strong> 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 <strong>石子最多</strong> 的玩家 <strong>获胜</strong> 。</p>\n\n<p>假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回&nbsp;<code>true</code>&nbsp;，当 Bob 赢得比赛时返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [5,3,4,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>\nAlice 先开始，只能拿前 5 颗或后 5 颗石子 。\n假设他取了前 5 颗，这一行就变成了 [3,4,5] 。\n如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。\n如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。\n这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [3,7,2,3]\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= piles.length &lt;= 500</code></li>\n\t<li><code>piles.length</code> 是 <strong>偶数</strong></li>\n\t<li><code>1 &lt;= piles[i] &lt;= 500</code></li>\n\t<li><code>sum(piles[i])</code>&nbsp;是 <strong>奇数</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 878.第 N 个神奇数字",
        "hardRate": "HARD",
        "passRate": "40.01%",
        "problemsUrl": "https://leetcode.cn/problems/nth-magical-number/",
        "solutionsUrl": "https://leetcode.cn/problems/nth-magical-number/solution",
        "problemsDesc": "<p>一个正整数如果能被 <code>a</code> 或 <code>b</code> 整除，那么它是神奇的。</p>\n\n<p>给定三个整数 <code>n</code> ,&nbsp;<code>a</code> , <code>b</code> ，返回第 <code>n</code> 个神奇的数字。因为答案可能很大，所以返回答案&nbsp;<strong>对&nbsp;</strong><code>10<sup>9</sup>&nbsp;+ 7</code> <strong>取模&nbsp;</strong>后的值。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, a = 2, b = 3\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, a = 2, b = 3\n<strong>输出：</strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n\t<li><code>2 &lt;= a, b &lt;= 4 * 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 879.盈利计划",
        "hardRate": "HARD",
        "passRate": "54.68%",
        "problemsUrl": "https://leetcode.cn/problems/profitable-schemes/",
        "solutionsUrl": "https://leetcode.cn/problems/profitable-schemes/solution",
        "problemsDesc": "<p>集团里有 <code>n</code> 名员工，他们可以完成各种各样的工作创造利润。</p>\n\n<p>第 <code>i</code> 种工作会产生 <code>profit[i]</code> 的利润，它要求 <code>group[i]</code> 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。</p>\n\n<p>工作的任何至少产生 <code>minProfit</code> 利润的子集称为 <strong>盈利计划</strong> 。并且工作的成员总数最多为 <code>n</code> 。</p>\n\n<p>有多少种计划可以选择？因为答案很大，所以<strong> 返回结果模 </strong><code>10^9 + 7</code><strong> 的值</strong>。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, minProfit = 3, group = [2,2], profit = [2,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。\n总的来说，有两种计划。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]\n<strong>输出：</strong>7\n<strong>解释：</strong>至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。\n有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。</pre>\n</div>\n</div>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>0 <= minProfit <= 100</code></li>\n\t<li><code>1 <= group.length <= 100</code></li>\n\t<li><code>1 <= group[i] <= 100</code></li>\n\t<li><code>profit.length == group.length</code></li>\n\t<li><code>0 <= profit[i] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 880.索引处的解码字符串",
        "hardRate": "MEDIUM",
        "passRate": "26.94%",
        "problemsUrl": "https://leetcode.cn/problems/decoded-string-at-index/",
        "solutionsUrl": "https://leetcode.cn/problems/decoded-string-at-index/solution",
        "problemsDesc": "<p>给定一个编码字符串 <code>S</code>。请你找出<em> </em><strong>解码字符串</strong> 并将其写入磁带。解码时，从编码字符串中<strong> 每次读取一个字符 </strong>，并采取以下步骤：</p>\n\n<ul>\n\t<li>如果所读的字符是字母，则将该字母写在磁带上。</li>\n\t<li>如果所读的字符是数字（例如 <code>d</code>），则整个当前磁带总共会被重复写&nbsp;<code>d-1</code> 次。</li>\n</ul>\n\n<p>现在，对于给定的编码字符串 <code>S</code> 和索引 <code>K</code>，查找并返回解码字符串中的第&nbsp;<code>K</code>&nbsp;个字母。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>S = &quot;leet2code3&quot;, K = 10\n<strong>输出：</strong>&quot;o&quot;\n<strong>解释：</strong>\n解码后的字符串为 &quot;leetleetcodeleetleetcodeleetleetcode&quot;。\n字符串中的第 10 个字母是 &quot;o&quot;。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>S = &quot;ha22&quot;, K = 5\n<strong>输出：</strong>&quot;h&quot;\n<strong>解释：</strong>\n解码后的字符串为 &quot;hahahaha&quot;。第 5 个字母是 &quot;h&quot;。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>S = &quot;a2345678999999999999999&quot;, K = 1\n<strong>输出：</strong>&quot;a&quot;\n<strong>解释：</strong>\n解码后的字符串为 &quot;a&quot; 重复 8301530446056247680 次。第 1 个字母是 &quot;a&quot;。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= S.length &lt;= 100</code></li>\n\t<li><code>S</code>&nbsp;只包含小写字母与数字 <code>2</code> 到 <code>9</code> 。</li>\n\t<li><code>S</code>&nbsp;以字母开头。</li>\n\t<li><code>1 &lt;= K &lt;= 10^9</code></li>\n\t<li>题目保证 <code>K</code> 小于或等于解码字符串的长度。</li>\n\t<li>解码后的字符串保证少于&nbsp;<code>2^63</code>&nbsp;个字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 881.救生艇",
        "hardRate": "MEDIUM",
        "passRate": "53.71%",
        "problemsUrl": "https://leetcode.cn/problems/boats-to-save-people/",
        "solutionsUrl": "https://leetcode.cn/problems/boats-to-save-people/solution",
        "problemsDesc": "<p>给定数组<meta charset=\"UTF-8\" />&nbsp;<code>people</code>&nbsp;。<code>people[i]</code>表示第 <code>i</code><sup>&nbsp;</sup>个人的体重&nbsp;，<strong>船的数量不限</strong>，每艘船可以承载的最大重量为&nbsp;<code>limit</code>。</p>\n\n<p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为&nbsp;<code>limit</code>。</p>\n\n<p>返回 <em>承载所有人所需的最小船数</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>people = [1,2], limit = 3\n<strong>输出：</strong>1\n<strong>解释：</strong>1 艘船载 (1, 2)\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>people = [3,2,2,1], limit = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>3 艘船分别载 (1, 2), (2) 和 (3)\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>people = [3,5,3,4], limit = 5\n<strong>输出：</strong>4\n<strong>解释：</strong>4 艘船分别载 (3), (3), (4), (5)</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= people.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= people[i] &lt;= limit &lt;= 3 * 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 882.细分图中的可到达节点",
        "hardRate": "HARD",
        "passRate": "63.94%",
        "problemsUrl": "https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/solution",
        "problemsDesc": "<p>给你一个无向图（<strong>原始图</strong>），图中有 <code>n</code> 个节点，编号从 <code>0</code> 到 <code>n - 1</code> 。你决定将图中的每条边 <strong>细分</strong> 为一条节点链，每条边之间的新节点数各不相同。</p>\n\n<p>图用由边组成的二维数组 <code>edges</code> 表示，其中&nbsp;<code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, cnt<sub>i</sub>]</code> 表示原始图中节点&nbsp;<code>u<sub>i</sub></code> 和&nbsp;<code>v<sub>i</sub></code> 之间存在一条边，<code>cnt<sub>i</sub></code> 是将边 <strong>细分</strong> 后的新节点总数。注意，<code>cnt<sub>i</sub> == 0</code> 表示边不可细分。</p>\n\n<p>要 <strong>细分</strong> 边 <code>[ui, vi]</code> ，需要将其替换为 <code>(cnt<sub>i</sub> + 1)</code> 条新边，和&nbsp;<code>cnt<sub>i</sub></code> 个新节点。新节点为 <code>x<sub>1</sub></code>, <code>x<sub>2</sub></code>, ..., <code>x<sub>cnt<sub>i</sub></sub></code> ，新边为 <code>[u<sub>i</sub>, x<sub>1</sub>]</code>, <code>[x<sub>1</sub>, x<sub>2</sub>]</code>, <code>[x<sub>2</sub>, x<sub>3</sub>]</code>, ..., <code>[x<sub>cnt<sub>i</sub>-1</sub>, x<sub>cnt<sub>i</sub></sub>]</code>, <code>[x<sub>cnt<sub>i</sub></sub>, v<sub>i</sub>]</code> 。</p>\n\n<p>现在得到一个&nbsp;<strong>新的细分图</strong> ，请你计算从节点 <code>0</code> 出发，可以到达多少个节点？如果节点间距离是 <code>maxMoves</code> 或更少，则视为 <strong>可以到达</strong> 。</p>\n\n<p>给你原始图和 <code>maxMoves</code> ，返回 <em>新的细分图中从节点 <code>0</code> 出发</em><strong><em> 可到达的节点数</em></strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/01/origfinal.png\" style=\"height: 247px; width: 600px;\" />\n<pre>\n<strong>输入：</strong>edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3\n<strong>输出：</strong>13\n<strong>解释：</strong>边的细分情况如上图所示。\n可以到达的节点已经用黄色标注出来。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4\n<strong>输出：</strong>23\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5\n<strong>输出：</strong>1\n<strong>解释：</strong>节点 0 与图的其余部分没有连通，所以只有节点 0 可以到达。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= edges.length &lt;= min(n * (n - 1) / 2, 10<sup>4</sup>)</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub> &lt; v<sub>i</sub> &lt; n</code></li>\n\t<li>图中 <strong>不存在平行边</strong></li>\n\t<li><code>0 &lt;= cnt<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= maxMoves &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= n &lt;= 3000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 883.三维形体投影面积",
        "hardRate": "EASY",
        "passRate": "76.36%",
        "problemsUrl": "https://leetcode.cn/problems/projection-area-of-3d-shapes/",
        "solutionsUrl": "https://leetcode.cn/problems/projection-area-of-3d-shapes/solution",
        "problemsDesc": "<p>在<meta charset=\"UTF-8\" />&nbsp;<code>n x n</code>&nbsp;的网格<meta charset=\"UTF-8\" />&nbsp;<code>grid</code>&nbsp;中，我们放置了一些与 x，y，z 三轴对齐的<meta charset=\"UTF-8\" />&nbsp;<code>1 x 1 x 1</code>&nbsp;立方体。</p>\n\n<p>每个值&nbsp;<code>v = grid[i][j]</code>&nbsp;表示 <code>v</code>&nbsp;个正方体叠放在单元格&nbsp;<code>(i, j)</code>&nbsp;上。</p>\n\n<p>现在，我们查看这些立方体在 <code>xy</code>&nbsp;、<code>yz</code>&nbsp;和 <code>zx</code>&nbsp;平面上的<em>投影</em>。</p>\n\n<p><strong>投影</strong>&nbsp;就像影子，将 <strong>三维</strong> 形体映射到一个 <strong>二维</strong> 平面上。从顶部、前面和侧面看立方体时，我们会看到“影子”。</p>\n\n<p>返回 <em>所有三个投影的总面积</em> 。</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<ul>\n</ul>\n\n<ul>\n</ul>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/02/shadow.png\" style=\"height: 214px; width: 800px;\" /></p>\n\n<pre>\n<strong>输入：</strong>[[1,2],[3,4]]\n<strong>输出：</strong>17\n<strong>解释：</strong>这里有该形体在三个轴对齐平面上的三个投影(“阴影部分”)。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[2]]\n<strong>输出：</strong>5\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>[[1,0],[0,2]]\n<strong>输出：</strong>8\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 884.两句话中的不常见单词",
        "hardRate": "EASY",
        "passRate": "71.24%",
        "problemsUrl": "https://leetcode.cn/problems/uncommon-words-from-two-sentences/",
        "solutionsUrl": "https://leetcode.cn/problems/uncommon-words-from-two-sentences/solution",
        "problemsDesc": "<p><strong>句子</strong> 是一串由空格分隔的单词。每个 <strong>单词</strong><em> </em>仅由小写字母组成。</p>\n\n<p>如果某个单词在其中一个句子中恰好出现一次，在另一个句子中却 <strong>没有出现</strong> ，那么这个单词就是 <strong>不常见的</strong><em> </em>。</p>\n\n<p>给你两个 <strong>句子</strong> <code>s1</code> 和 <code>s2</code> ，返回所有 <strong>不常用单词</strong> 的列表。返回列表中单词可以按 <strong>任意顺序</strong> 组织。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"this apple is sweet\", s2 = \"this apple is sour\"\n<strong>输出：</strong>[\"sweet\",\"sour\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"apple apple\", s2 = \"banana\"\n<strong>输出：</strong>[\"banana\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 200</code></li>\n\t<li><code>s1</code> 和 <code>s2</code> 由小写英文字母和空格组成</li>\n\t<li><code>s1</code> 和 <code>s2</code> 都不含前导或尾随空格</li>\n\t<li><code>s1</code> 和 <code>s2</code> 中的所有单词间均由单个空格分隔</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 885.螺旋矩阵 III",
        "hardRate": "MEDIUM",
        "passRate": "71.17%",
        "problemsUrl": "https://leetcode.cn/problems/spiral-matrix-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/spiral-matrix-iii/solution",
        "problemsDesc": "<p>在 <code>rows x cols</code> 的网格上，你从单元格 <code>(rStart, cStart)</code> 面朝东面开始。网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。</p>\n\n<p>你需要以顺时针按螺旋状行走，访问此网格中的每个位置。每当移动到网格的边界之外时，需要继续在网格之外行走（但稍后可能会返回到网格边界）。</p>\n\n<p>最终，我们到过网格的所有&nbsp;<code>rows x cols</code>&nbsp;个空间。</p>\n\n<p>按照访问顺序返回表示网格位置的坐标列表。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_1.png\" style=\"width: 174px; height: 99px;\" />\n<pre>\n<strong>输入：</strong>rows = 1, cols = 4, rStart = 0, cStart = 0\n<strong>输出：</strong>[[0,0],[0,1],[0,2],[0,3]]\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_2.png\" style=\"width: 202px; height: 142px;\" />\n<pre>\n<strong>输入：</strong>rows = 5, cols = 6, rStart = 1, cStart = 4\n<strong>输出：</strong>[[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rows, cols &lt;= 100</code></li>\n\t<li><code>0 &lt;= rStart &lt; rows</code></li>\n\t<li><code>0 &lt;= cStart &lt; cols</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 886.可能的二分法",
        "hardRate": "MEDIUM",
        "passRate": "52.10%",
        "problemsUrl": "https://leetcode.cn/problems/possible-bipartition/",
        "solutionsUrl": "https://leetcode.cn/problems/possible-bipartition/solution",
        "problemsDesc": "<p>给定一组&nbsp;<code>n</code>&nbsp;人（编号为&nbsp;<code>1, 2, ..., n</code>），&nbsp;我们想把每个人分进<strong>任意</strong>大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。</p>\n\n<p>给定整数 <code>n</code>&nbsp;和数组 <code>dislikes</code>&nbsp;，其中&nbsp;<code>dislikes[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;，表示不允许将编号为 <code>a<sub>i</sub></code>&nbsp;和&nbsp;&nbsp;<code>b<sub>i</sub></code>的人归入同一组。当可以用这种方法将所有人分进两组时，返回 <code>true</code>；否则返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, dislikes = [[1,2],[1,3],[2,4]]\n<strong>输出：</strong>true\n<strong>解释：</strong>group1 [1,4], group2 [2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, dislikes = [[1,2],[1,3],[2,3]]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2000</code></li>\n\t<li><code>0 &lt;= dislikes.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>dislikes[i].length == 2</code></li>\n\t<li><code>1 &lt;= dislikes[i][j] &lt;= n</code></li>\n\t<li><code>a<sub>i</sub>&nbsp;&lt; b<sub>i</sub></code></li>\n\t<li><code>dislikes</code>&nbsp;中每一组都 <strong>不同</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 887.鸡蛋掉落",
        "hardRate": "HARD",
        "passRate": "30.64%",
        "problemsUrl": "https://leetcode.cn/problems/super-egg-drop/",
        "solutionsUrl": "https://leetcode.cn/problems/super-egg-drop/solution",
        "problemsDesc": "<p>给你 <code>k</code> 枚相同的鸡蛋，并可以使用一栋从第 <code>1</code> 层到第 <code>n</code> 层共有 <code>n</code> 层楼的建筑。</p>\n\n<p>已知存在楼层 <code>f</code> ，满足 <code>0 <= f <= n</code> ，任何从<strong> 高于</strong> <code>f</code> 的楼层落下的鸡蛋都会碎，从 <code>f</code> 楼层或比它低的楼层落下的鸡蛋都不会破。</p>\n\n<p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 <code>x</code> 扔下（满足 <code>1 <= x <= n</code>）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 <strong>重复使用</strong> 这枚鸡蛋。</p>\n\n<p>请你计算并返回要确定 <code>f</code> <strong>确切的值</strong> 的 <strong>最小操作次数</strong> 是多少？</p>\n \n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 1, n = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>\n鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。 \n否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。 \n如果它没碎，那么肯定能得出 f = 2 。 \n因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 2, n = 6\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 3, n = 14\n<strong>输出：</strong>4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= k <= 100</code></li>\n\t<li><code>1 <= n <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 888.公平的糖果交换",
        "hardRate": "EASY",
        "passRate": "63.56%",
        "problemsUrl": "https://leetcode.cn/problems/fair-candy-swap/",
        "solutionsUrl": "https://leetcode.cn/problems/fair-candy-swap/solution",
        "problemsDesc": "<p>爱丽丝和鲍勃拥有不同总数量的糖果。给你两个数组 <code>aliceSizes</code> 和 <code>bobSizes</code> ，<code>aliceSizes[i]</code> 是爱丽丝拥有的第 <code>i</code> 盒糖果中的糖果数量，<code>bobSizes[j]</code> 是鲍勃拥有的第 <code>j</code> 盒糖果中的糖果数量。</p>\n\n<p>两人想要互相交换一盒糖果，这样在交换之后，他们就可以拥有相同总数量的糖果。一个人拥有的糖果总数量是他们每盒糖果数量的总和。</p>\n\n<p>返回一个整数数组 <code>answer</code>，其中 <code>answer[0]</code> 是爱丽丝必须交换的糖果盒中的糖果的数目，<code>answer[1]</code> 是鲍勃必须交换的糖果盒中的糖果的数目。如果存在多个答案，你可以返回其中 <strong>任何一个</strong> 。题目测试用例保证存在与输入对应的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>aliceSizes = [1,1], bobSizes = [2,2]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>aliceSizes = [1,2], bobSizes = [2,3]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>aliceSizes = [2], bobSizes = [1,3]\n<strong>输出：</strong>[2,3]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>aliceSizes = [1,2,5], bobSizes = [2,4]\n<strong>输出：</strong>[5,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= aliceSizes.length, bobSizes.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= aliceSizes[i], bobSizes[j] &lt;= 10<sup>5</sup></code></li>\n\t<li>爱丽丝和鲍勃的糖果总数量不同。</li>\n\t<li>题目数据保证对于给定的输入至少存在一个有效答案。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 889.根据前序和后序遍历构造二叉树",
        "hardRate": "MEDIUM",
        "passRate": "68.01%",
        "problemsUrl": "https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/solution",
        "problemsDesc": "<p>给定两个整数数组，<code>preorder</code>&nbsp;和 <code>postorder</code> ，其中 <code>preorder</code> 是一个具有 <strong>无重复</strong> 值的二叉树的前序遍历，<code>postorder</code> 是同一棵树的后序遍历，重构并返回二叉树。</p>\n\n<p>如果存在多个答案，您可以返回其中 <strong>任何</strong> 一个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/24/lc-prepost.jpg\" style=\"height: 265px; width: 304px;\" /></p>\n\n<pre>\n<strong>输入：</strong>preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\n<strong>输出：</strong>[1,2,3,4,5,6,7]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> preorder = [1], postorder = [1]\n<strong>输出:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= preorder.length &lt;= 30</code></li>\n\t<li><code>1 &lt;= preorder[i] &lt;= preorder.length</code></li>\n\t<li><code>preorder</code>&nbsp;中所有值都 <strong>不同</strong></li>\n\t<li><code>postorder.length == preorder.length</code></li>\n\t<li><code>1 &lt;= postorder[i] &lt;= postorder.length</code></li>\n\t<li><code>postorder</code>&nbsp;中所有值都 <strong>不同</strong></li>\n\t<li>保证 <code>preorder</code>&nbsp;和 <code>postorder</code>&nbsp;是同一棵二叉树的前序遍历和后序遍历</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 890.查找和替换模式",
        "hardRate": "MEDIUM",
        "passRate": "78.58%",
        "problemsUrl": "https://leetcode.cn/problems/find-and-replace-pattern/",
        "solutionsUrl": "https://leetcode.cn/problems/find-and-replace-pattern/solution",
        "problemsDesc": "<p>你有一个单词列表&nbsp;<code>words</code>&nbsp;和一个模式&nbsp;&nbsp;<code>pattern</code>，你想知道 <code>words</code> 中的哪些单词与模式匹配。</p>\n\n<p>如果存在字母的排列 <code>p</code>&nbsp;，使得将模式中的每个字母 <code>x</code> 替换为 <code>p(x)</code> 之后，我们就得到了所需的单词，那么单词与模式是匹配的。</p>\n\n<p><em>（回想一下，字母的排列是从字母到字母的双射：每个字母映射到另一个字母，没有两个字母映射到同一个字母。）</em></p>\n\n<p>返回 <code>words</code> 中与给定模式匹配的单词列表。</p>\n\n<p>你可以按任何顺序返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;], pattern = &quot;abb&quot;\n<strong>输出：</strong>[&quot;mee&quot;,&quot;aqq&quot;]\n<strong>解释：\n</strong>&quot;mee&quot; 与模式匹配，因为存在排列 {a -&gt; m, b -&gt; e, ...}。\n&quot;ccc&quot; 与模式不匹配，因为 {a -&gt; c, b -&gt; c, ...} 不是排列。\n因为 a 和 b 映射到同一个字母。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= pattern.length = words[i].length&nbsp;&lt;= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 891.子序列宽度之和",
        "hardRate": "HARD",
        "passRate": "46.53%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-subsequence-widths/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-subsequence-widths/solution",
        "problemsDesc": "<p>一个序列的 <strong>宽度</strong> 定义为该序列中最大元素和最小元素的差值。</p>\n\n<p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 的所有非空 <strong>子序列</strong> 的 <strong>宽度之和</strong> 。由于答案可能非常大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后的结果。</p>\n\n<p><strong>子序列</strong> 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，<code>[3,6,2,7]</code> 就是数组 <code>[0,3,1,6,2,2,7]</code> 的一个子序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,3]\n<strong>输出：</strong>6\n<strong>解释：</strong>子序列为 [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3] 。\n相应的宽度是 0, 0, 0, 1, 1, 2, 2 。\n宽度之和是 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 892.三维形体的表面积",
        "hardRate": "EASY",
        "passRate": "64.44%",
        "problemsUrl": "https://leetcode.cn/problems/surface-area-of-3d-shapes/",
        "solutionsUrl": "https://leetcode.cn/problems/surface-area-of-3d-shapes/solution",
        "problemsDesc": "<p>给你一个 <code>n * n</code> 的网格&nbsp;<code>grid</code> ，上面放置着一些&nbsp;<code>1 x 1 x 1</code>&nbsp;的正方体。每个值&nbsp;<code>v = grid[i][j]</code>&nbsp;表示&nbsp;<code>v</code>&nbsp;个正方体叠放在对应单元格&nbsp;<code>(i, j)</code>&nbsp;上。</p>\n\n<p>放置好正方体后，任何直接相邻的正方体都会互相粘在一起，形成一些不规则的三维形体。</p>\n\n<p>请你返回最终这些形体的总表面积。</p>\n\n<p><strong>注意：</strong>每个形体的底面也需要计入表面积中。</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/08/tmp-grid2.jpg\" style=\"height: 80px; width: 80px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,2],[3,4]]\n<strong>输出：</strong>34\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/08/tmp-grid4.jpg\" style=\"height: 100px; width: 100px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,1,1],[1,0,1],[1,1,1]]\n<strong>输出：</strong>32\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/08/tmp-grid5.jpg\" style=\"height: 100px; width: 100px;\" />\n<pre>\n<strong>输入：</strong>grid = [[2,2,2],[2,1,2],[2,2,2]]\n<strong>输出：</strong>46\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 893.特殊等价字符串组",
        "hardRate": "MEDIUM",
        "passRate": "73.00%",
        "problemsUrl": "https://leetcode.cn/problems/groups-of-special-equivalent-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/groups-of-special-equivalent-strings/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>words</code>。</p>\n\n<p>一步操作中，你可以交换字符串 <code>words[i]</code> 的任意两个偶数下标对应的字符或任意两个奇数下标对应的字符。</p>\n\n<p>对两个字符串&nbsp;<code>words[i]</code> 和 <code>words[j]</code> 而言，如果经过任意次数的操作，<code>words[i] == words[j]</code> ，那么这两个字符串是 <strong>特殊等价 </strong>的。</p>\n\n<ul>\n\t<li>例如，<code>words[i] = \"zzxy\"</code> 和 <code>words[j] = \"xyzz\"</code> 是一对 <strong>特殊等价</strong> 字符串，因为可以按 <code>\"zzxy\" -&gt; \"xzzy\" -&gt; \"xyzz\"</code> 的操作路径使&nbsp;<code>words[i] == words[j]</code> 。</li>\n</ul>\n\n<p>现在规定，<strong><code>words</code> </strong>的 <strong>一组特殊等价字符串 </strong>就是 <code>words</code> 的一个同时满足下述条件的非空子集：</p>\n\n<ul>\n\t<li>该组中的每一对字符串都是<strong> 特殊等价 </strong>的</li>\n\t<li>该组字符串已经涵盖了该类别中的所有特殊等价字符串，容量达到理论上的最大值（也就是说，如果一个字符串不在该组中，那么这个字符串就 <strong>不会</strong> 与该组内任何字符串特殊等价）</li>\n</ul>\n\n<p>返回 <code>words</code> 中 <strong>特殊等价字符串组</strong> 的数量。</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"abcd\",\"cdab\",\"cbad\",\"xyzz\",\"zzxy\",\"zzyx\"]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n其中一组为 [\"abcd\", \"cdab\", \"cbad\"]，因为它们是成对的特殊等价字符串，且没有其他字符串与这些字符串特殊等价。\n另外两组分别是 [\"xyzz\", \"zzxy\"] 和 [\"zzyx\"]。特别需要注意的是，\"zzxy\" 不与 \"zzyx\" 特殊等价。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\n<strong>输出：</strong>3\n<strong>解释：</strong>3 组 [\"abc\",\"cba\"]，[\"acb\",\"bca\"]，[\"bac\",\"cab\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 20</code></li>\n\t<li>所有 <code>words[i]</code>&nbsp;都只由小写字母组成。</li>\n\t<li>所有 <code>words[i]</code>&nbsp;都具有相同的长度。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 894.所有可能的真二叉树",
        "hardRate": "MEDIUM",
        "passRate": "77.63%",
        "problemsUrl": "https://leetcode.cn/problems/all-possible-full-binary-trees/",
        "solutionsUrl": "https://leetcode.cn/problems/all-possible-full-binary-trees/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，请你找出所有可能含 <code>n</code> 个节点的 <strong>真二叉树</strong> ，并以列表形式返回。答案中每棵树的每个节点都必须符合 <code>Node.val == 0</code> 。</p>\n\n<p>答案的每个元素都是一棵真二叉树的根节点。你可以按 <strong>任意顺序</strong> 返回最终的真二叉树列表<strong>。</strong></p>\n\n<p><strong>真二叉树</strong> 是一类二叉树，树中每个节点恰好有 <code>0</code> 或 <code>2</code> 个子节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png\" style=\"width: 700px; height: 400px;\" />\n<pre>\n<strong>输入：</strong>n = 7\n<strong>输出：</strong>[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>[[0,0,0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 895.最大频率栈",
        "hardRate": "HARD",
        "passRate": "64.36%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-frequency-stack/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-frequency-stack/solution",
        "problemsDesc": "<p>设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出<strong>出现频率</strong>最高的元素。</p>\n\n<p>实现 <code>FreqStack</code>&nbsp;类:</p>\n\n<ul>\n\t<li><meta charset=\"UTF-8\" /><code>FreqStack()</code>&nbsp;构造一个空的堆栈。</li>\n\t<li><meta charset=\"UTF-8\" /><code>void push(int val)</code>&nbsp;将一个整数&nbsp;<code>val</code>&nbsp;压入栈顶。</li>\n\t<li><meta charset=\"UTF-8\" /><code>int pop()</code>&nbsp;删除并返回堆栈中出现频率最高的元素。\n\t<ul>\n\t\t<li>如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"FreqStack\",\"push\",\"push\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"pop\",\"pop\",\"pop\"],\n[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]\n<strong>输出：</strong>[null,null,null,null,null,null,null,5,7,5,4]\n<strong>解释：</strong>\nFreqStack = new FreqStack();\nfreqStack.push (5);//堆栈为 [5]\nfreqStack.push (7);//堆栈是 [5,7]\nfreqStack.push (5);//堆栈是 [5,7,5]\nfreqStack.push (7);//堆栈是 [5,7,5,7]\nfreqStack.push (4);//堆栈是 [5,7,5,7,4]\nfreqStack.push (5);//堆栈是 [5,7,5,7,4,5]\nfreqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。\nfreqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。\nfreqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。\nfreqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= val &lt;= 10<sup>9</sup></code></li>\n\t<li><code>push</code>&nbsp;和 <code>pop</code>&nbsp;的操作数不大于 <code>2 * 10<sup>4</sup></code>。</li>\n\t<li>输入保证在调用&nbsp;<code>pop</code>&nbsp;之前堆栈中至少有一个元素。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 896.单调数列",
        "hardRate": "EASY",
        "passRate": "57.03%",
        "problemsUrl": "https://leetcode.cn/problems/monotonic-array/",
        "solutionsUrl": "https://leetcode.cn/problems/monotonic-array/solution",
        "problemsDesc": "<p>如果数组是单调递增或单调递减的，那么它是&nbsp;<strong>单调 </strong><em>的</em>。</p>\n\n<p>如果对于所有 <code>i &lt;= j</code>，<code>nums[i] &lt;= nums[j]</code>，那么数组 <code>nums</code> 是单调递增的。 如果对于所有 <code>i &lt;= j</code>，<code>nums[i]&gt; = nums[j]</code>，那么数组 <code>nums</code>&nbsp;是单调递减的。</p>\n\n<p>当给定的数组 <code>nums</code>&nbsp;是单调数组时返回 <code>true</code>，否则返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2,3]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [6,5,4,4]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,2]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 897.递增顺序搜索树",
        "hardRate": "EASY",
        "passRate": "74.01%",
        "problemsUrl": "https://leetcode.cn/problems/increasing-order-search-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/increasing-order-search-tree/solution",
        "problemsDesc": "<p>给你一棵二叉搜索树的<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;，请你 <strong>按中序遍历</strong> 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg\" style=\"height: 350px; width: 600px;\" />\n<pre>\n<strong>输入：</strong>root = [5,3,6,2,4,null,8,1,null,null,null,7,9]\n<strong>输出：</strong>[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/17/ex2.jpg\" style=\"height: 114px; width: 300px;\" />\n<pre>\n<strong>输入：</strong>root = [5,1,7]\n<strong>输出：</strong>[1,null,5,null,7]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数的取值范围是 <code>[1, 100]</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 898.子数组按位或操作",
        "hardRate": "MEDIUM",
        "passRate": "39.12%",
        "problemsUrl": "https://leetcode.cn/problems/bitwise-ors-of-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/bitwise-ors-of-subarrays/solution",
        "problemsDesc": "<p>我们有一个非负整数数组<meta charset=\"UTF-8\" />&nbsp;<code>arr</code>&nbsp;。</p>\n\n<p>对于每个（连续的）子数组<meta charset=\"UTF-8\" />&nbsp;<code>sub = [arr[i], arr[i + 1], ..., arr[j]]</code>&nbsp;（&nbsp;<code>i &lt;= j</code>），我们对<meta charset=\"UTF-8\" />&nbsp;<code>sub</code>&nbsp;中的每个元素进行按位或操作，获得结果<meta charset=\"UTF-8\" />&nbsp;<code>arr[i] | arr[i + 1] | ... | arr[j]</code>&nbsp;。</p>\n\n<p>返回可能结果的数量。 多次出现的结果在最终答案中仅计算一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n只有一个可能的结果 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,1,2]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n可能的子数组为 [1]，[1]，[2]，[1, 1]，[1, 2]，[1, 1, 2]。\n产生的结果为 1，1，2，1，3，3 。\n有三个唯一值，所以答案是 3 。\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,4]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n可能的结果是 1，2，3，4，6，以及 7 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i]&nbsp;&lt;= 10<sup>9</sup></code>​​​​​​​</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 899.有序队列",
        "hardRate": "HARD",
        "passRate": "64.08%",
        "problemsUrl": "https://leetcode.cn/problems/orderly-queue/",
        "solutionsUrl": "https://leetcode.cn/problems/orderly-queue/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>&nbsp;。你可以从 <code>s</code> 的前 <code>k</code> 个字母中选择一个，并把它加到字符串的末尾。</p>\n\n<p>返回 <em>在应用上述步骤的任意数量的移动后，字典上最小的字符串&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"cba\", k = 1\n<strong>输出：</strong>\"acb\"\n<strong>解释：</strong>\n在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “bac”。\n在第二步中，我们将第一个字符（“b”）移动到最后，获得最终结果 “acb”。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"baaca\", k = 3\n<strong>输出：</strong>\"aaabc\"\n<strong>解释：\n</strong>在第一步中，我们将第一个字符（“b”）移动到最后，获得字符串 “aacab”。\n在第二步中，我们将第三个字符（“c”）移动到最后，获得最终结果 “aaabc”。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k&nbsp;&lt;= S.length&nbsp;&lt;= 1000</code></li>\n\t<li><code>s</code>&nbsp;只由小写字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 900.RLE 迭代器",
        "hardRate": "MEDIUM",
        "passRate": "51.26%",
        "problemsUrl": "https://leetcode.cn/problems/rle-iterator/",
        "solutionsUrl": "https://leetcode.cn/problems/rle-iterator/solution",
        "problemsDesc": "<p>我们可以使用游程编码(即&nbsp;<strong>RLE&nbsp;</strong>)来编码一个整数序列。在偶数长度&nbsp;<code>encoding</code>&nbsp;( <strong>从 0 开始</strong> )的游程编码数组中，对于所有偶数 <code>i</code> ，<code>encoding[i]</code>&nbsp;告诉我们非负整数&nbsp;<code>encoding[i + 1]</code>&nbsp;在序列中重复的次数。</p>\n\n<ul>\n\t<li>例如，序列&nbsp;<code>arr = [8,8,8,5,5]</code>&nbsp;可以被编码为 <code>encoding =[3,8,2,5]</code> 。<code>encoding =[3,8,0,9,2,5]</code>&nbsp;和 <code>encoding =[2,8,1,8,2,5]</code> 也是&nbsp;<code>arr</code> 有效的 <strong>RLE</strong> 。</li>\n</ul>\n\n<p>给定一个游程长度的编码数组，设计一个迭代器来遍历它。</p>\n\n<p>实现 <code>RLEIterator</code> 类:</p>\n\n<ul>\n\t<li><code>RLEIterator(int[] encoded)</code>&nbsp;用编码后的数组初始化对象。</li>\n\t<li><code>int next(int n)</code> 以这种方式耗尽后 <code>n</code> 个元素并返回最后一个耗尽的元素。如果没有剩余的元素要耗尽，则返回 <code>-1</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：\n</strong>[\"RLEIterator\",\"next\",\"next\",\"next\",\"next\"]\n[[[3,8,0,9,2,5]],[2],[1],[1],[2]]\n<strong>输出：\n</strong>[null,8,8,5,-1]\n<strong>解释：</strong>\nRLEIterator rLEIterator = new RLEIterator([3, 8, 0, 9, 2, 5]); // 这映射到序列 [8,8,8,5,5]。\nrLEIterator.next(2); // 耗去序列的 2 个项，返回 8。现在剩下的序列是 [8, 5, 5]。\nrLEIterator.next(1); // 耗去序列的 1 个项，返回 8。现在剩下的序列是 [5, 5]。\nrLEIterator.next(1); // 耗去序列的 1 个项，返回 5。现在剩下的序列是 [5]。\nrLEIterator.next(2); // 耗去序列的 2 个项，返回 -1。 这是由于第一个被耗去的项是 5，\n但第二个项并不存在。由于最后一个要耗去的项不存在，我们返回 -1。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= encoding.length &lt;= 1000</code></li>\n\t<li><code>encoding.length</code>&nbsp;为偶</li>\n\t<li><code>0 &lt;= encoding[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n\t<li>每个测试用例调用<code>next </code>不高于&nbsp;<code>1000</code>&nbsp;次&nbsp;</li>\n</ul>\n",
        "isPlus": false
    }
]