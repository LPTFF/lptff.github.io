[
    {
        "problemsName": " 2501数组中最长的方波",
        "hardRate": "MEDIUM",
        "passRate": "41.28%",
        "problemsUrl": "https://leetcode.cn/problems/longest-square-streak-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-square-streak-in-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。如果 <code>nums</code> 的子序列满足下述条件，则认为该子序列是一个 <strong>方波</strong> ：</p>\n\n<ul>\n\t<li>子序列的长度至少为 <code>2</code> ，并且</li>\n\t<li>将子序列从小到大排序 <strong>之后</strong> ，除第一个元素外，每个元素都是前一个元素的 <strong>平方</strong> 。</li>\n</ul>\n\n<p>返回<em> </em><code>nums</code><em> </em>中 <strong>最长方波</strong> 的长度，如果不存在 <strong>方波</strong><em> </em>则返回<em> </em><code>-1</code> 。</p>\n\n<p><strong>子序列</strong> 也是一个数组，可以由另一个数组删除一些或不删除元素且不改变剩余元素的顺序得到。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1 ：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,3,6,16,8,2]\n<strong>输出：</strong>3\n<strong>解释：</strong>选出子序列 [4,16,2] 。排序后，得到 [2,4,16] 。\n- 4 = 2 * 2.\n- 16 = 4 * 4.\n因此，[4,16,2] 是一个方波.\n可以证明长度为 4 的子序列都不是方波。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,3,5,6,7]\n<strong>输出：</strong>-1\n<strong>解释：</strong>nums 不存在方波，所以返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2502设计内存分配器",
        "hardRate": "MEDIUM",
        "passRate": "52.17%",
        "problemsUrl": "https://leetcode.cn/problems/design-memory-allocator/",
        "solutionsUrl": "https://leetcode.cn/problems/design-memory-allocator/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，表示下标从 <strong>0</strong> 开始的内存数组的大小。所有内存单元开始都是空闲的。</p>\n\n<p>请你设计一个具备以下功能的内存分配器：</p>\n\n<ol>\n\t<li><strong>分配 </strong>一块大小为 <code>size</code> 的连续空闲内存单元并赋 id <code>mID</code> 。</li>\n\t<li><strong>释放</strong> 给定 id <code>mID</code> 对应的所有内存单元。</li>\n</ol>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>多个块可以被分配到同一个 <code>mID</code> 。</li>\n\t<li>你必须释放 <code>mID</code> 对应的所有内存单元，即便这些内存单元被分配在不同的块中。</li>\n</ul>\n\n<p>实现 <code>Allocator</code> 类：</p>\n\n<ul>\n\t<li><code>Allocator(int n)</code> 使用一个大小为 <code>n</code> 的内存数组初始化 <code>Allocator</code> 对象。</li>\n\t<li><code>int allocate(int size, int mID)</code> 找出大小为 <code>size</code> 个连续空闲内存单元且位于&nbsp; <strong>最左侧</strong> 的块，分配并赋 id <code>mID</code> 。返回块的第一个下标。如果不存在这样的块，返回 <code>-1</code> 。</li>\n\t<li><code>int free(int mID)</code> 释放 id <code>mID</code> 对应的所有内存单元。返回释放的内存单元数目。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入</strong>\n[\"Allocator\", \"allocate\", \"allocate\", \"allocate\", \"free\", \"allocate\", \"allocate\", \"allocate\", \"free\", \"allocate\", \"free\"]\n[[10], [1, 1], [1, 2], [1, 3], [2], [3, 4], [1, 1], [1, 1], [1], [10, 2], [7]]\n<strong>输出</strong>\n[null, 0, 1, 2, 1, 3, 1, 6, 3, -1, 0]\n\n<strong>解释</strong>\nAllocator loc = new Allocator(10); // 初始化一个大小为 10 的内存数组，所有内存单元都是空闲的。\nloc.allocate(1, 1); // 最左侧的块的第一个下标是 0 。内存数组变为 [<strong>1</strong>, , , , , , , , , ]。返回 0 。\nloc.allocate(1, 2); // 最左侧的块的第一个下标是 1 。内存数组变为 [1,<strong>2</strong>, , , , , , , , ]。返回 1 。\nloc.allocate(1, 3); // 最左侧的块的第一个下标是 2 。内存数组变为 [1,2,<strong>3</strong>, , , , , , , ]。返回 2 。\nloc.free(2); // 释放 mID 为 2 的所有内存单元。内存数组变为 [1, ,<strong>3</strong>, , , , , , , ] 。返回 1 ，因为只有 1 个 mID 为 2 的内存单元。\nloc.allocate(3, 4); // 最左侧的块的第一个下标是 3 。内存数组变为 [1, ,3,<strong>4</strong>,<strong>4</strong>,<strong>4</strong>, , , , ]。返回 3 。\nloc.allocate(1, 1); // 最左侧的块的第一个下标是 1 。内存数组变为 [1,<strong>1</strong>,3,4,4,4, , , , ]。返回 1 。\nloc.allocate(1, 1); // 最左侧的块的第一个下标是 6 。内存数组变为 [1,1,3,4,4,4,<strong>1</strong>, , , ]。返回 6 。\nloc.free(1); // 释放 mID 为 1 的所有内存单元。内存数组变为 [ , ,3,4,4,4,<strong> </strong>, , , ] 。返回 3 ，因为有 3 个 mID 为 1 的内存单元。\nloc.allocate(10, 2); // 无法找出长度为 10 个连续空闲内存单元的空闲块，所有返回 -1 。\nloc.free(7); // 释放 mID 为 7 的所有内存单元。内存数组保持原状，因为不存在 mID 为 7 的内存单元。返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n, size, mID &lt;= 1000</code></li>\n\t<li>最多调用 <code>allocate</code> 和 <code>free</code> 方法 <code>1000</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2503矩阵查询可获得的最大分数",
        "hardRate": "HARD",
        "passRate": "43.35%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-points-from-grid-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-points-from-grid-queries/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的整数矩阵 <code>grid</code> 和一个大小为 <code>k</code> 的数组 <code>queries</code> 。</p>\n\n<p>找出一个大小为 <code>k</code> 的数组 <code>answer</code> ，且满足对于每个整数 <code>queries[i]</code> ，你从矩阵 <strong>左上角</strong> 单元格开始，重复以下过程：</p>\n\n<ul>\n\t<li>如果 <code>queries[i]</code> <strong>严格</strong> 大于你当前所处位置单元格，如果该单元格是第一次访问，则获得 1 分，并且你可以移动到所有 <code>4</code> 个方向（上、下、左、右）上任一 <strong>相邻</strong> 单元格。</li>\n\t<li>否则，你不能获得任何分，并且结束这一过程。</li>\n</ul>\n\n<p>在过程结束后，<code>answer[i]</code> 是你可以获得的最大分数。注意，对于每个查询，你可以访问同一个单元格 <strong>多次</strong> 。</p>\n\n<p>返回结果数组 <code>answer</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/19/yetgriddrawio.png\" style=\"width: 571px; height: 151px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]\n<strong>输出：</strong>[5,8,1]\n<strong>解释：</strong>上图展示了每个查询中访问并获得分数的单元格。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/20/yetgriddrawio-2.png\" />\n<pre>\n<strong>输入：</strong>grid = [[5,2,1],[1,1,2]], queries = [3]\n<strong>输出：</strong>[0]\n<strong>解释：</strong>无法获得分数，因为左上角单元格的值大于等于 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>k == queries.length</code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= grid[i][j], queries[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2504把名字和职业联系起来",
        "hardRate": "EASY",
        "passRate": "76.18%",
        "problemsUrl": "https://leetcode.cn/problems/concatenate-the-name-and-the-profession/",
        "solutionsUrl": "https://leetcode.cn/problems/concatenate-the-name-and-the-profession/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2505所有子序列和的按位或",
        "hardRate": "MEDIUM",
        "passRate": "59.09%",
        "problemsUrl": "https://leetcode.cn/problems/bitwise-or-of-all-subsequence-sums/",
        "solutionsUrl": "https://leetcode.cn/problems/bitwise-or-of-all-subsequence-sums/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2506统计相似字符串对的数目",
        "hardRate": "EASY",
        "passRate": "78.29%",
        "problemsUrl": "https://leetcode.cn/problems/count-pairs-of-similar-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/count-pairs-of-similar-strings/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串数组 <code>words</code> 。</p>\n\n<p>如果两个字符串由相同的字符组成，则认为这两个字符串 <strong>相似</strong> 。</p>\n\n<ul>\n\t<li>例如，<code>\"abca\"</code> 和 <code>\"cba\"</code> 相似，因为它们都由字符 <code>'a'</code>、<code>'b'</code>、<code>'c'</code> 组成。</li>\n\t<li>然而，<code>\"abacba\"</code> 和 <code>\"bcfd\"</code> 不相似，因为它们不是相同字符组成的。</li>\n</ul>\n\n<p>请你找出满足字符串&nbsp;<code>words[i]</code><em> </em>和<em> </em><code>words[j]</code> 相似的下标对<em> </em><code>(i, j)</code><em> </em>，并返回下标对的数目，其中 <code>0 &lt;= i &lt; j &lt;= word.length - 1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"aba\",\"aabb\",\"abcd\",\"bac\",\"aabc\"]\n<strong>输出：</strong>2\n<strong>解释：</strong>共有 2 对满足条件：\n- i = 0 且 j = 1 ：words[0] 和 words[1] 只由字符 'a' 和 'b' 组成。 \n- i = 3 且 j = 4 ：words[3] 和 words[4] 只由字符 'a'、'b' 和 'c' 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"aabb\",\"ab\",\"ba\"]\n<strong>输出：</strong>3\n<strong>解释：</strong>共有 3 对满足条件：\n- i = 0 且 j = 1 ：words[0] 和 words[1] 只由字符 'a' 和 'b' 组成。 \n- i = 0 且 j = 2 ：words[0] 和 words[2] 只由字符 'a' 和 'b' 组成。 \n- i = 1 且 j = 2 ：words[1] 和 words[2] 只由字符 'a' 和 'b' 组成。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"nba\",\"cba\",\"dba\"]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在满足条件的下标对，返回 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><code>words[i]</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2507使用质因数之和替换后可以取到的最小值",
        "hardRate": "MEDIUM",
        "passRate": "49.96%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-value-after-replacing-with-sum-of-prime-factors/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-value-after-replacing-with-sum-of-prime-factors/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> 。</p>\n\n<p>请你将 <code>n</code> 的值替换为 <code>n</code> 的 <strong>质因数</strong> 之和，重复这一过程。</p>\n\n<ul>\n\t<li>注意，如果 <code>n</code> 能够被某个质因数多次整除，则在求和时，应当包含这个质因数同样次数。</li>\n</ul>\n\n<p>返回<em> </em><code>n</code><em> </em>可以取到的最小值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 15\n<strong>输出：</strong>5\n<strong>解释：</strong>最开始，n = 15 。\n15 = 3 * 5 ，所以 n 替换为 3 + 5 = 8 。\n8 = 2 * 2 * 2 ，所以 n 替换为 2 + 2 + 2 = 6 。\n6 = 2 * 3 ，所以 n 替换为 2 + 3 = 5 。\n5 是 n 可以取到的最小值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>最开始，n = 3 。\n3 是 n 可以取到的最小值。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2508添加边使所有节点度数都为偶数",
        "hardRate": "HARD",
        "passRate": "29.39%",
        "problemsUrl": "https://leetcode.cn/problems/add-edges-to-make-degrees-of-all-nodes-even/",
        "solutionsUrl": "https://leetcode.cn/problems/add-edges-to-make-degrees-of-all-nodes-even/solution",
        "problemsDesc": "<p>给你一个有 <code>n</code>&nbsp;个节点的 <strong>无向</strong>&nbsp;图，节点编号为&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;。再给你整数&nbsp;<code>n</code>&nbsp;和一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条边。图不一定连通。</p>\n\n<p>你可以给图中添加 <strong>至多</strong>&nbsp;两条额外的边（也可以一条边都不添加），使得图中没有重边也没有自环。</p>\n\n<p>如果添加额外的边后，可以使得图中所有点的度数都是偶数，返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>点的度数是连接一个点的边的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/26/agraphdrawio.png\" style=\"width: 500px; height: 190px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]\n<b>输出：</b>true\n<b>解释：</b>上图展示了添加一条边的合法方案。\n最终图中每个节点都连接偶数条边。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/26/aagraphdrawio.png\" style=\"width: 400px; height: 120px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 4, edges = [[1,2],[3,4]]\n<b>输出：</b>true\n<b>解释：</b>上图展示了添加两条边的合法方案。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/26/aaagraphdrawio.png\" style=\"width: 150px; height: 158px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 4, edges = [[1,2],[1,3],[1,4]]\n<b>输出：</b>false\n<b>解释：</b>无法添加至多 2 条边得到一个符合要求的图。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>图中不会有重边</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2509查询树中环的长度",
        "hardRate": "HARD",
        "passRate": "65.23%",
        "problemsUrl": "https://leetcode.cn/problems/cycle-length-queries-in-a-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/cycle-length-queries-in-a-tree/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;，表示你有一棵含有&nbsp;<code>2<sup>n</sup> - 1</code>&nbsp;个节点的 <strong>完全二叉树</strong>&nbsp;。根节点的编号是&nbsp;<code>1</code>&nbsp;，树中编号在<code>[1, 2<sup>n - 1</sup> - 1]</code>&nbsp;之间，编号为&nbsp;<code>val</code>&nbsp;的节点都有两个子节点，满足：</p>\n\n<ul>\n\t<li>左子节点的编号为&nbsp;<code>2 * val</code></li>\n\t<li>右子节点的编号为&nbsp;<code>2 * val + 1</code></li>\n</ul>\n\n<p>给你一个长度为 <code>m</code>&nbsp;的查询数组 <code>queries</code>&nbsp;，它是一个二维整数数组，其中&nbsp;<code>queries[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;。对于每个查询，求出以下问题的解：</p>\n\n<ol>\n\t<li>在节点编号为&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间添加一条边。</li>\n\t<li>求出图中环的长度。</li>\n\t<li>删除节点编号为&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间新添加的边。</li>\n</ol>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><strong>环</strong> 是开始和结束于同一节点的一条路径，路径中每条边都只会被访问一次。</li>\n\t<li>环的长度是环中边的数目。</li>\n\t<li>在树中添加额外的边后，两个点之间可能会有多条边。</li>\n</ul>\n\n<p>请你返回一个长度为 <code>m</code>&nbsp;的数组<em>&nbsp;</em><code>answer</code>&nbsp;，其中&nbsp;<code>answer[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个查询的结果<i>。</i></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/25/bexample1.png\" style=\"width: 647px; height: 128px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 3, queries = [[5,3],[4,7],[2,3]]\n<b>输出：</b>[4,5,3]\n<b>解释：</b>上图是一棵有 2<sup>3</sup> - 1 个节点的树。红色节点表示添加额外边后形成环的节点。\n- 在节点 3 和节点 5 之间添加边后，环为 [5,2,1,3] ，所以第一个查询的结果是 4 。删掉添加的边后处理下一个查询。\n- 在节点 4 和节点 7 之间添加边后，环为 [4,2,1,3,7] ，所以第二个查询的结果是 5 。删掉添加的边后处理下一个查询。\n- 在节点 2 和节点 3 之间添加边后，环为 [2,1,3] ，所以第三个查询的结果是 3 。删掉添加的边。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/25/aexample2.png\" style=\"width: 146px; height: 71px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 2, queries = [[1,2]]\n<b>输出：</b>[2]\n<b>解释：</b>上图是一棵有 2<sup>2</sup> - 1 个节点的树。红色节点表示添加额外边后形成环的节点。\n- 在节点 1 和节点 2 之间添加边后，环为 [2,1] ，所以第一个查询的结果是 2 。删掉添加的边。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 30</code></li>\n\t<li><code>m == queries.length</code></li>\n\t<li><code>1 &lt;= m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= 2<sup>n</sup> - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2510检查是否有路径经过相同数量的 0 和 1",
        "hardRate": "MEDIUM",
        "passRate": "68.65%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-there-is-a-path-with-equal-number-of-0s-and-1s/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-there-is-a-path-with-equal-number-of-0s-and-1s/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2511最多可以摧毁的敌人城堡数目",
        "hardRate": "EASY",
        "passRate": "49.63%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-enemy-forts-that-can-be-captured/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-enemy-forts-that-can-be-captured/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;，下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>forts</code>&nbsp;，表示一些城堡。<code>forts[i]</code> 可以是&nbsp;<code>-1</code>&nbsp;，<code>0</code>&nbsp;或者&nbsp;<code>1</code>&nbsp;，其中：</p>\n\n<ul>\n\t<li><code>-1</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个位置 <strong>没有</strong>&nbsp;城堡。</li>\n\t<li><code>0</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个位置有一个 <strong>敌人</strong>&nbsp;的城堡。</li>\n\t<li><code>1</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个位置有一个你控制的城堡。</li>\n</ul>\n\n<p>现在，你需要决定，将你的军队从某个你控制的城堡位置&nbsp;<code>i</code>&nbsp;移动到一个空的位置&nbsp;<code>j</code>&nbsp;，满足：</p>\n\n<ul>\n\t<li><code>0 &lt;= i, j &lt;= n - 1</code></li>\n\t<li>军队经过的位置 <strong>只有</strong>&nbsp;敌人的城堡。正式的，对于所有&nbsp;<code>min(i,j) &lt; k &lt; max(i,j)</code>&nbsp;的&nbsp;<code>k</code>&nbsp;，都满足&nbsp;<code>forts[k] == 0</code>&nbsp;。</li>\n</ul>\n\n<p>当军队移动时，所有途中经过的敌人城堡都会被 <strong>摧毁</strong> 。</p>\n\n<p>请你返回 <strong>最多</strong>&nbsp;可以摧毁的敌人城堡数目。如果 <strong>无法</strong>&nbsp;移动你的军队，或者没有你控制的城堡，请返回 <code>0</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>forts = [1,0,0,-1,0,0,0,0,1]\n<b>输出：</b>4\n<strong>解释：</strong>\n- 将军队从位置 0 移动到位置 3 ，摧毁 2 个敌人城堡，位置分别在 1 和 2 。\n- 将军队从位置 8 移动到位置 3 ，摧毁 4 个敌人城堡。\n4 是最多可以摧毁的敌人城堡数目，所以我们返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>forts = [0,0,1,-1]\n<b>输出：</b>0\n<b>解释：</b>由于无法摧毁敌人的城堡，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= forts.length &lt;= 1000</code></li>\n\t<li><code>-1 &lt;= forts[i] &lt;= 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2512奖励最顶尖的 K 名学生",
        "hardRate": "MEDIUM",
        "passRate": "46.13%",
        "problemsUrl": "https://leetcode.cn/problems/reward-top-k-students/",
        "solutionsUrl": "https://leetcode.cn/problems/reward-top-k-students/solution",
        "problemsDesc": "<p>给你两个字符串数组&nbsp;<code>positive_feedback</code> 和&nbsp;<code>negative_feedback</code>&nbsp;，分别包含表示正面的和负面的词汇。<strong>不会</strong>&nbsp;有单词同时是正面的和负面的。</p>\n\n<p>一开始，每位学生分数为&nbsp;<code>0</code>&nbsp;。每个正面的单词会给学生的分数 <strong>加&nbsp;</strong><code>3</code>&nbsp;分，每个负面的词会给学生的分数 <strong>减&nbsp;</strong>&nbsp;<code>1</code>&nbsp;分。</p>\n\n<p>给你&nbsp;<code>n</code>&nbsp;个学生的评语，用一个下标从 <strong>0</strong>&nbsp;开始的字符串数组&nbsp;<code>report</code>&nbsp;和一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>student_id</code>&nbsp;表示，其中&nbsp;<code>student_id[i]</code>&nbsp;表示这名学生的 ID ，这名学生的评语是&nbsp;<code>report[i]</code>&nbsp;。每名学生的 ID <strong>互不相同</strong>。</p>\n\n<p>给你一个整数&nbsp;<code>k</code>&nbsp;，请你返回按照得分&nbsp;<strong>从高到低</strong>&nbsp;最顶尖的<em>&nbsp;</em><code>k</code>&nbsp;名学生。如果有多名学生分数相同，ID 越小排名越前。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>positive_feedback = [\"smart\",\"brilliant\",\"studious\"], negative_feedback = [\"not\"], report = [\"this student is studious\",\"the student is smart\"], student_id = [1,2], k = 2\n<b>输出：</b>[1,2]\n<b>解释：</b>\n两名学生都有 1 个正面词汇，都得到 3 分，学生 1 的 ID 更小所以排名更前。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>positive_feedback = [\"smart\",\"brilliant\",\"studious\"], negative_feedback = [\"not\"], report = [\"this student is not studious\",\"the student is smart\"], student_id = [1,2], k = 2\n<b>输出：</b>[2,1]\n<b>解释：</b>\n- ID 为 1 的学生有 1 个正面词汇和 1 个负面词汇，所以得分为 3-1=2 分。\n- ID 为 2 的学生有 1 个正面词汇，得分为 3 分。\n学生 2 分数更高，所以返回 [2,1] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= positive_feedback.length, negative_feedback.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= positive_feedback[i].length, negative_feedback[j].length &lt;= 100</code></li>\n\t<li><code>positive_feedback[i]</code> 和&nbsp;<code>negative_feedback[j]</code>&nbsp;都只包含小写英文字母。</li>\n\t<li><code>positive_feedback</code> 和&nbsp;<code>negative_feedback</code>&nbsp;中不会有相同单词。</li>\n\t<li><code>n == report.length == student_id.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>report[i]</code>&nbsp;只包含小写英文字母和空格&nbsp;<code>' '</code>&nbsp;。</li>\n\t<li><code>report[i]</code>&nbsp;中连续单词之间有单个空格隔开。</li>\n\t<li><code>1 &lt;= report[i].length &lt;= 100</code></li>\n\t<li><code>1 &lt;= student_id[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>student_id[i]</code>&nbsp;的值 <strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2513最小化两个数组中的最大值",
        "hardRate": "MEDIUM",
        "passRate": "34.66%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-the-maximum-of-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-the-maximum-of-two-arrays/solution",
        "problemsDesc": "<p>给你两个数组&nbsp;<code>arr1</code> 和&nbsp;<code>arr2</code>&nbsp;，它们一开始都是空的。你需要往它们中添加正整数，使它们满足以下条件：</p>\n\n<ul>\n\t<li><code>arr1</code>&nbsp;包含&nbsp;<code>uniqueCnt1</code>&nbsp;个<strong>&nbsp;互不相同</strong>&nbsp;的正整数，每个整数都&nbsp;<strong>不能 </strong>被&nbsp;<code>divisor1</code>&nbsp;<strong>整除</strong>&nbsp;。</li>\n\t<li><code>arr2</code>&nbsp;包含&nbsp;<code>uniqueCnt2</code>&nbsp;个<strong>&nbsp;互不相同</strong>&nbsp;的正整数，每个整数都&nbsp;<strong>不能</strong>&nbsp;被&nbsp;<code>divisor2</code>&nbsp;<strong>整除</strong>&nbsp;。</li>\n\t<li><code>arr1</code> 和&nbsp;<code>arr2</code>&nbsp;中的元素&nbsp;<strong>互不相同</strong>&nbsp;。</li>\n</ul>\n\n<p>给你&nbsp;<code>divisor1</code>&nbsp;，<code>divisor2</code>&nbsp;，<code>uniqueCnt1</code>&nbsp;和&nbsp;<code>uniqueCnt2</code>&nbsp;，请你返回两个数组中&nbsp;<strong>最大元素</strong>&nbsp;的&nbsp;<strong>最小值</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>divisor1 = 2, divisor2 = 7, uniqueCnt1 = 1, uniqueCnt2 = 3\n<b>输出：</b>4\n<b>解释：</b>\n我们可以把前 4 个自然数划分到 arr1 和 arr2 中。\narr1 = [1] 和 arr2 = [2,3,4] 。\n可以看出两个数组都满足条件。\n最大值是 4 ，所以返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>divisor1 = 3, divisor2 = 5, uniqueCnt1 = 2, uniqueCnt2 = 1\n<b>输出：</b>3\n<b>解释：</b>\narr1 = [1,2] 和 arr2 = [3] 满足所有条件。\n最大值是 3 ，所以返回 3 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>divisor1 = 2, divisor2 = 4, uniqueCnt1 = 8, uniqueCnt2 = 2\n<b>输出：</b>15\n<b>解释：</b>\n最终数组为 arr1 = [1,3,5,7,9,11,13,15] 和 arr2 = [2,6] 。\n上述方案是满足所有条件的最优解。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= divisor1, divisor2 &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= uniqueCnt1, uniqueCnt2 &lt; 10<sup>9</sup></code></li>\n\t<li><code>2 &lt;= uniqueCnt1 + uniqueCnt2 &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2514统计同位异构字符串数目",
        "hardRate": "HARD",
        "passRate": "46.31%",
        "problemsUrl": "https://leetcode.cn/problems/count-anagrams/",
        "solutionsUrl": "https://leetcode.cn/problems/count-anagrams/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，它包含一个或者多个单词。单词之间用单个空格&nbsp;<code>' '</code>&nbsp;隔开。</p>\n\n<p>如果字符串 <code>t</code>&nbsp;中第 <code>i</code>&nbsp;个单词是 <code>s</code>&nbsp;中第 <code>i</code>&nbsp;个单词的一个&nbsp;<strong>排列</strong>&nbsp;，那么我们称字符串&nbsp;<code>t</code>&nbsp;是字符串&nbsp;<code>s</code>&nbsp;的同位异构字符串。</p>\n\n<ul>\n\t<li>比方说，<code>\"acb dfe\"</code>&nbsp;是&nbsp;<code>\"abc def\"</code>&nbsp;的同位异构字符串，但是&nbsp;<code>\"def cab\"</code>&nbsp;和&nbsp;<code>\"adc bef\"</code>&nbsp;不是。</li>\n</ul>\n\n<p>请你返回<em>&nbsp;</em><code>s</code>&nbsp;的同位异构字符串的数目，由于答案可能很大，请你将它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong> 后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"too hot\"\n<b>输出：</b>18\n<b>解释：</b>输入字符串的一些同位异构字符串为 \"too hot\" ，\"oot hot\" ，\"oto toh\" ，\"too toh\" 以及 \"too oht\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"aa\"\n<b>输出：</b>1\n<strong>解释：</strong>输入字符串只有一个同位异构字符串。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 只包含小写英文字母和空格&nbsp;<code>' '</code>&nbsp;。</li>\n\t<li>相邻单词之间由单个空格隔开。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2515到目标字符串的最短距离",
        "hardRate": "EASY",
        "passRate": "55.61%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-distance-to-target-string-in-a-circular-array/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-distance-to-target-string-in-a-circular-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的 <strong>环形</strong> 字符串数组 <code>words</code> 和一个字符串 <code>target</code> 。<strong>环形数组</strong> 意味着数组首尾相连。</p>\n\n<ul>\n\t<li>形式上， <code>words[i]</code> 的下一个元素是 <code>words[(i + 1) % n]</code> ，而 <code>words[i]</code> 的前一个元素是 <code>words[(i - 1 + n) % n]</code> ，其中 <code>n</code> 是 <code>words</code> 的长度。</li>\n</ul>\n\n<p>从 <code>startIndex</code> 开始，你一次可以用 <code>1</code> 步移动到下一个或者前一个单词。</p>\n\n<p>返回到达目标字符串 <code>target</code> 所需的最短距离。如果 <code>words</code> 中不存在字符串 <code>target</code> ，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"hello\",\"i\",\"am\",\"leetcode\",\"hello\"], target = \"hello\", startIndex = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>从下标 1 开始，可以经由以下步骤到达 \"hello\" ：\n- 向右移动 3 个单位，到达下标 4 。\n- 向左移动 2 个单位，到达下标 4 。\n- 向右移动 4 个单位，到达下标 0 。\n- 向左移动 1 个单位，到达下标 0 。\n到达 \"hello\" 的最短距离是 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"a\",\"b\",\"leetcode\"], target = \"leetcode\", startIndex = 0\n<strong>输出：</strong>1\n<strong>解释：</strong>从下标 0 开始，可以经由以下步骤到达 \"leetcode\" ：\n- 向右移动 2 个单位，到达下标 3 。\n- 向左移动 1 个单位，到达下标 3 。\n到达 \"leetcode\" 的最短距离是 1 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"i\",\"eat\",\"leetcode\"], target = \"ate\", startIndex = 0\n<strong>输出：</strong>-1\n<strong>解释：</strong>因为 words 中不存在字符串 \"ate\" ，所以返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><code>words[i]</code> 和 <code>target</code> 仅由小写英文字母组成</li>\n\t<li><code>0 &lt;= startIndex &lt; words.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2516每种字符至少取 K 个",
        "hardRate": "MEDIUM",
        "passRate": "37.31%",
        "problemsUrl": "https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/",
        "solutionsUrl": "https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/solution",
        "problemsDesc": "<p>给你一个由字符 <code>'a'</code>、<code>'b'</code>、<code>'c'</code> 组成的字符串 <code>s</code> 和一个非负整数 <code>k</code> 。每分钟，你可以选择取走 <code>s</code> <strong>最左侧</strong> 还是 <strong>最右侧</strong> 的那个字符。</p>\n\n<p>你必须取走每种字符 <strong>至少</strong> <code>k</code> 个，返回需要的 <strong>最少</strong> 分钟数；如果无法取到，则返回<em> </em><code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aabaaaacaabc\", k = 2\n<strong>输出：</strong>8\n<strong>解释：</strong>\n从 s 的左侧取三个字符，现在共取到两个字符 'a' 、一个字符 'b' 。\n从 s 的右侧取五个字符，现在共取到四个字符 'a' 、两个字符 'b' 和两个字符 'c' 。\n共需要 3 + 5 = 8 分钟。\n可以证明需要的最少分钟数是 8 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a\", k = 1\n<strong>输出：</strong>-1\n<strong>解释：</strong>无法取到一个字符 'b' 或者 'c'，所以返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 仅由字母 <code>'a'</code>、<code>'b'</code>、<code>'c'</code> 组成</li>\n\t<li><code>0 &lt;= k &lt;= s.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2517礼盒的最大甜蜜度",
        "hardRate": "MEDIUM",
        "passRate": "71.93%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>price</code> ，其中 <code>price[i]</code> 表示第 <code>i</code> 类糖果的价格，另给你一个正整数 <code>k</code> 。</p>\n\n<p>商店组合 <code>k</code> 类 <strong>不同</strong> 糖果打包成礼盒出售。礼盒的 <strong>甜蜜度</strong> 是礼盒中任意两种糖果 <strong>价格</strong> 绝对差的最小值。</p>\n\n<p>返回礼盒的 <strong>最大 </strong>甜蜜度<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>price = [13,5,1,8,21,2], k = 3\n<strong>输出：</strong>8\n<strong>解释：</strong>选出价格分别为 [13,5,21] 的三类糖果。\n礼盒的甜蜜度为 min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8 。\n可以证明能够取得的最大甜蜜度就是 8 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>price = [1,3,1], k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>选出价格分别为 [1,3] 的两类糖果。 \n礼盒的甜蜜度为 min(|1 - 3|) = min(2) = 2 。\n可以证明能够取得的最大甜蜜度就是 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>price = [7,7,7,7], k = 2\n<strong>输出：</strong>0\n<strong>解释：</strong>从现有的糖果中任选两类糖果，甜蜜度都会是 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= k &lt;= price.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= price[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2518好分区的数目",
        "hardRate": "HARD",
        "passRate": "42.63%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-great-partitions/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-great-partitions/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>\n\n<p><strong>分区</strong> 的定义是：将数组划分成两个有序的 <strong>组</strong> ，并满足每个元素 <strong>恰好</strong> 存在于 <strong>某一个</strong> 组中。如果分区中每个组的元素和都大于等于 <code>k</code> ，则认为分区是一个好分区。</p>\n\n<p>返回 <strong>不同</strong> 的好分区的数目。由于答案可能很大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后的结果。</p>\n\n<p>如果在两个分区中，存在某个元素 <code>nums[i]</code> 被分在不同的组中，则认为这两个分区不同。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4], k = 4\n<strong>输出：</strong>6\n<strong>解释：</strong>好分区的情况是 ([1,2,3], [4]), ([1,3], [2,4]), ([1,4], [2,3]), ([2,3], [1,4]), ([2,4], [1,3]) 和 ([4], [1,2,3]) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,3,3], k = 4\n<strong>输出：</strong>0\n<strong>解释：</strong>数组中不存在好分区。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [6,6], k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>可以将 nums[0] 放入第一个分区或第二个分区中。\n好分区的情况是 ([6], [6]) 和 ([6], [6]) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, k &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2519统计 K-Big 索引的数量",
        "hardRate": "HARD",
        "passRate": "74.89%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-k-big-indices/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-k-big-indices/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2520统计能整除数字的位数",
        "hardRate": "EASY",
        "passRate": "83.20%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-digits-that-divide-a-number/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-digits-that-divide-a-number/solution",
        "problemsDesc": "<p>给你一个整数 <code>num</code> ，返回 <code>num</code> 中能整除 <code>num</code> 的数位的数目。</p>\n\n<p>如果满足&nbsp;<code>nums % val == 0</code> ，则认为整数 <code>val</code> 可以整除 <code>nums</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 7\n<strong>输出：</strong>1\n<strong>解释：</strong>7 被自己整除，因此答案是 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 121\n<strong>输出：</strong>2\n<strong>解释：</strong>121 可以被 1 整除，但无法被 2 整除。由于 1 出现两次，所以返回 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = 1248\n<strong>输出：</strong>4\n<strong>解释：</strong>1248 可以被它每一位上的数字整除，因此答案是 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10<sup>9</sup></code></li>\n\t<li><code>num</code> 的数位中不含 <code>0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2521数组乘积中的不同质因数数目",
        "hardRate": "MEDIUM",
        "passRate": "62.66%",
        "problemsUrl": "https://leetcode.cn/problems/distinct-prime-factors-of-product-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/distinct-prime-factors-of-product-of-array/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>nums</code> ，对 <code>nums</code> 所有元素求积之后，找出并返回乘积中 <strong>不同质因数</strong> 的数目。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><strong>质数</strong> 是指大于 <code>1</code> 且仅能被 <code>1</code> 及自身整除的数字。</li>\n\t<li>如果 <code>val2 / val1</code> 是一个整数，则整数 <code>val1</code> 是另一个整数 <code>val2</code> 的一个因数。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,4,3,7,10,6]\n<strong>输出：</strong>4\n<strong>解释：</strong>\nnums 中所有元素的乘积是：2 * 4 * 3 * 7 * 10 * 6 = 10080 = 2<sup>5</sup> * 3<sup>2</sup> * 5 * 7 。\n共有 4 个不同的质因数，所以返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,4,8,16]\n<strong>输出：</strong>1\n<strong>解释：</strong>\nnums 中所有元素的乘积是：2 * 4 * 8 * 16 = 1024 = 2<sup>10</sup> 。\n共有 1 个不同的质因数，所以返回 1 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>2 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2522将字符串分割成值不超过 K 的子字符串",
        "hardRate": "MEDIUM",
        "passRate": "49.56%",
        "problemsUrl": "https://leetcode.cn/problems/partition-string-into-substrings-with-values-at-most-k/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-string-into-substrings-with-values-at-most-k/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，它每一位都是&nbsp;<code>1</code>&nbsp;到&nbsp;<code>9</code>&nbsp;之间的数字组成，同时给你一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>如果一个字符串 <code>s</code>&nbsp;的分割满足以下条件，我们称它是一个 <strong>好</strong>&nbsp;分割：</p>\n\n<ul>\n\t<li><code>s</code>&nbsp;中每个数位 <strong>恰好</strong>&nbsp;属于一个子字符串。</li>\n\t<li>每个子字符串的值都小于等于&nbsp;<code>k</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回 <code>s</code>&nbsp;所有的 <strong>好</strong>&nbsp;分割中，子字符串的&nbsp;<strong>最少</strong>&nbsp;数目。如果不存在 <code>s</code>&nbsp;的<strong>&nbsp;好</strong>&nbsp;分割，返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p><b>注意：</b></p>\n\n<ul>\n\t<li>一个字符串的 <strong>值</strong>&nbsp;是这个字符串对应的整数。比方说，<code>\"123\"</code>&nbsp;的值为&nbsp;<code>123</code>&nbsp;，<code>\"1\"</code>&nbsp;的值是&nbsp;<code>1</code>&nbsp;。</li>\n\t<li><strong>子字符串</strong>&nbsp;是字符串中一段连续的字符序列。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"165462\", k = 60\n<b>输出：</b>4\n<b>解释：</b>我们将字符串分割成子字符串 \"16\" ，\"54\" ，\"6\" 和 \"2\" 。每个子字符串的值都小于等于 k = 60 。\n不存在小于 4 个子字符串的好分割。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"238182\", k = 5\n<b>输出：</b>-1\n<strong>解释：</strong>这个字符串不存在好分割。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code>&nbsp;是&nbsp;<code>'1'</code>&nbsp;到&nbsp;<code>'9'</code>&nbsp;之间的数字。</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2523范围内最接近的两个质数",
        "hardRate": "MEDIUM",
        "passRate": "41.38%",
        "problemsUrl": "https://leetcode.cn/problems/closest-prime-numbers-in-range/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-prime-numbers-in-range/solution",
        "problemsDesc": "<p>给你两个正整数&nbsp;<code>left</code> 和&nbsp;<code>right</code>&nbsp;，请你找到两个整数&nbsp;<code>num1</code> 和&nbsp;<code>num2</code>&nbsp;，它们满足：</p>\n\n<ul>\n\t<li><code>left &lt;= nums1 &lt; nums2 &lt;= right&nbsp;</code>&nbsp;。</li>\n\t<li><code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;都是 <strong>质数</strong>&nbsp;。</li>\n\t<li><code>nums2 - nums1</code>&nbsp;是满足上述条件的质数对中的 <strong>最小值</strong>&nbsp;。</li>\n</ul>\n\n<p>请你返回正整数数组&nbsp;<code>ans = [nums1, nums2]</code>&nbsp;。如果有多个整数对满足上述条件，请你返回&nbsp;<code>nums1</code>&nbsp;最小的质数对。如果不存在符合题意的质数对，请你返回&nbsp;<code>[-1, -1]</code>&nbsp;。</p>\n\n<p>如果一个整数大于&nbsp;<code>1</code>&nbsp;，且只能被&nbsp;<code>1</code> 和它自己整除，那么它是一个质数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>left = 10, right = 19\n<b>输出：</b>[11,13]\n<b>解释：</b>10 到 19 之间的质数为 11 ，13 ，17 和 19 。\n质数对的最小差值是 2 ，[11,13] 和 [17,19] 都可以得到最小差值。\n由于 11 比 17 小，我们返回第一个质数对。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>left = 4, right = 6\n<b>输出：</b>[-1,-1]\n<b>解释：</b>给定范围内只有一个质数，所以题目条件无法被满足。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= left &lt;= right &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2524子数组的最大频率分数",
        "hardRate": "HARD",
        "passRate": "52.40%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-frequency-score-of-a-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-frequency-score-of-a-subarray/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2525根据规则将箱子分类",
        "hardRate": "EASY",
        "passRate": "47.53%",
        "problemsUrl": "https://leetcode.cn/problems/categorize-box-according-to-criteria/",
        "solutionsUrl": "https://leetcode.cn/problems/categorize-box-according-to-criteria/solution",
        "problemsDesc": "<p>给你四个整数&nbsp;<code>length</code>&nbsp;，<code>width</code>&nbsp;，<code>height</code>&nbsp;和&nbsp;<code>mass</code>&nbsp;，分别表示一个箱子的三个维度和质量，请你返回一个表示箱子 <strong>类别</strong> 的字符串。</p>\n\n<ul>\n\t<li>如果满足以下条件，那么箱子是&nbsp;<code>\"Bulky\"</code>&nbsp;的：\n\n\t<ul>\n\t\t<li>箱子 <strong>至少有一个</strong> 维度大于等于 <code>10<sup>4</sup></code>&nbsp;。</li>\n\t\t<li>或者箱子的 <strong>体积</strong> 大于等于&nbsp;<code>10<sup>9</sup></code>&nbsp;。</li>\n\t</ul>\n\t</li>\n\t<li>如果箱子的质量大于等于&nbsp;<code>100</code>&nbsp;，那么箱子是&nbsp;<code>\"Heavy\"</code>&nbsp;的。</li>\n\t<li>如果箱子同时是&nbsp;<code>\"Bulky\"</code> 和&nbsp;<code>\"Heavy\"</code>&nbsp;，那么返回类别为&nbsp;<code>\"Both\"</code>&nbsp;。</li>\n\t<li>如果箱子既不是&nbsp;<code>\"Bulky\"</code>&nbsp;，也不是&nbsp;<code>\"Heavy\"</code>&nbsp;，那么返回类别为&nbsp;<code>\"Neither\"</code>&nbsp;。</li>\n\t<li>如果箱子是&nbsp;<code>\"Bulky\"</code>&nbsp;但不是&nbsp;<code>\"Heavy\"</code>&nbsp;，那么返回类别为&nbsp;<code>\"Bulky\"</code>&nbsp;。</li>\n\t<li>如果箱子是&nbsp;<code>\"Heavy\"</code>&nbsp;但不是&nbsp;<code>\"Bulky\"</code>&nbsp;，那么返回类别为&nbsp;<code>\"Heavy\"</code>&nbsp;。</li>\n</ul>\n\n<p><strong>注意</strong>，箱子的体积等于箱子的长度、宽度和高度的乘积。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>length = 1000, width = 35, height = 700, mass = 300\n<b>输出：</b>\"Heavy\"\n<b>解释：</b>\n箱子没有任何维度大于等于 10<sup>4 </sup>。\n体积为 24500000 &lt;= 10<sup>9 </sup>。所以不能归类为 \"Bulky\" 。\n但是质量 &gt;= 100 ，所以箱子是 \"Heavy\" 的。\n由于箱子不是 \"Bulky\" 但是是 \"Heavy\" ，所以我们返回 \"Heavy\" 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>length = 200, width = 50, height = 800, mass = 50\n<b>输出：</b>\"Neither\"\n<b>解释：</b>\n箱子没有任何维度大于等于 10<sup>4</sup>&nbsp;。\n体积为 8 * 10<sup>6</sup> &lt;= 10<sup>9</sup>&nbsp;。所以不能归类为 \"Bulky\" 。\n质量小于 100 ，所以不能归类为 \"Heavy\" 。\n由于不属于上述两者任何一类，所以我们返回 \"Neither\" 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= length, width, height &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= mass &lt;= 10<sup>3</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2526找到数据流中的连续整数",
        "hardRate": "MEDIUM",
        "passRate": "54.09%",
        "problemsUrl": "https://leetcode.cn/problems/find-consecutive-integers-from-a-data-stream/",
        "solutionsUrl": "https://leetcode.cn/problems/find-consecutive-integers-from-a-data-stream/solution",
        "problemsDesc": "<p>给你一个整数数据流，请你实现一个数据结构，检查数据流中最后&nbsp;<code>k</code>&nbsp;个整数是否 <strong>等于</strong> 给定值&nbsp;<code>value</code>&nbsp;。</p>\n\n<p>请你实现&nbsp;<strong>DataStream</strong>&nbsp;类：</p>\n\n<ul>\n\t<li><code>DataStream(int value, int k)</code>&nbsp;用两个整数 <code>value</code>&nbsp;和 <code>k</code>&nbsp;初始化一个空的整数数据流。</li>\n\t<li><code>boolean consec(int num)</code>&nbsp;将&nbsp;<code>num</code>&nbsp;添加到整数数据流。如果后 <code>k</code>&nbsp;个整数都等于&nbsp;<code>value</code>&nbsp;，返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。如果少于&nbsp;<code>k</code>&nbsp;个整数，条件不满足，所以也返回&nbsp;<code>false</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"DataStream\", \"consec\", \"consec\", \"consec\", \"consec\"]\n[[4, 3], [4], [4], [4], [3]]\n<strong>输出：</strong>\n[null, false, false, true, false]\n\n<strong>解释：</strong>\nDataStream dataStream = new DataStream(4, 3); // value = 4, k = 3 \ndataStream.consec(4); // 数据流中只有 1 个整数，所以返回 False 。\ndataStream.consec(4); // 数据流中只有 2 个整数\n                      // 由于 2 小于 k ，返回 False 。\ndataStream.consec(4); // 数据流最后 3 个整数都等于 value， 所以返回 True 。\ndataStream.consec(3); // 最后 k 个整数分别是 [4,4,3] 。\n                      // 由于 3 不等于 value ，返回 False 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= value, num &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li>至多调用 <code>consec</code>&nbsp;次数为&nbsp;<code>10<sup>5</sup></code>&nbsp;次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2527查询数组 Xor 美丽值",
        "hardRate": "MEDIUM",
        "passRate": "70.33%",
        "problemsUrl": "https://leetcode.cn/problems/find-xor-beauty-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-xor-beauty-of-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>三个下标&nbsp;<code>i</code>&nbsp;，<code>j</code>&nbsp;和&nbsp;<code>k</code>&nbsp;的 <strong>有效值</strong>&nbsp;定义为&nbsp;<code>((nums[i] | nums[j]) &amp; nums[k])</code>&nbsp;。</p>\n\n<p>一个数组的 <strong>xor 美丽值</strong>&nbsp;是数组中所有满足&nbsp;<code>0 &lt;= i, j, k &lt; n</code>&nbsp;&nbsp;<strong>的三元组</strong>&nbsp;<code>(i, j, k)</code>&nbsp;的 <strong>有效值</strong>&nbsp;的异或结果。</p>\n\n<p>请你返回&nbsp;<code>nums</code>&nbsp;的 xor 美丽值。</p>\n\n<p><b>注意：</b></p>\n\n<ul>\n\t<li><code>val1 | val2</code>&nbsp;是&nbsp;<code>val1</code> 和&nbsp;<code>val2</code>&nbsp;的按位或。</li>\n\t<li><code>val1 &amp; val2</code>&nbsp;是&nbsp;<code>val1</code> 和&nbsp;<code>val2</code>&nbsp;的按位与。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,4]\n<b>输出：</b>5\n<b>解释：</b>\n三元组和它们对应的有效值如下：\n- (0,0,0) 有效值为 ((1 | 1) &amp; 1) = 1\n- (0,0,1) 有效值为 ((1 | 1) &amp; 4) = 0\n- (0,1,0) 有效值为 ((1 | 4) &amp; 1) = 1\n- (0,1,1) 有效值为 ((1 | 4) &amp; 4) = 4\n- (1,0,0) 有效值为 ((4 | 1) &amp; 1) = 1\n- (1,0,1) 有效值为 ((4 | 1) &amp; 4) = 4\n- (1,1,0) 有效值为 ((4 | 4) &amp; 1) = 0\n- (1,1,1) 有效值为 ((4 | 4) &amp; 4) = 4 \n数组的 xor 美丽值为所有有效值的按位异或 1 ^ 0 ^ 1 ^ 4 ^ 1 ^ 4 ^ 0 ^ 4 = 5 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [15,45,20,2,34,35,5,44,32,30]\n<b>输出：</b>34\n<code><span style=\"\"><b>解释：</b>数组的 xor 美丽值为</span> 34 。</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length&nbsp;&lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2528最大化城市的最小供电站数目",
        "hardRate": "HARD",
        "passRate": "40.58%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-the-minimum-powered-city/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-the-minimum-powered-city/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>stations</code>&nbsp;，其中&nbsp;<code>stations[i]</code>&nbsp;表示第 <code>i</code>&nbsp;座城市的供电站数目。</p>\n\n<p>每个供电站可以在一定 <strong>范围</strong>&nbsp;内给所有城市提供电力。换句话说，如果给定的范围是&nbsp;<code>r</code>&nbsp;，在城市&nbsp;<code>i</code>&nbsp;处的供电站可以给所有满足&nbsp;<code>|i - j| &lt;= r</code> 且&nbsp;<code>0 &lt;= i, j &lt;= n - 1</code>&nbsp;的城市&nbsp;<code>j</code>&nbsp;供电。</p>\n\n<ul>\n\t<li><code>|x|</code>&nbsp;表示 <code>x</code>&nbsp;的 <strong>绝对值</strong>&nbsp;。比方说，<code>|7 - 5| = 2</code>&nbsp;，<code>|3 - 10| = 7</code>&nbsp;。</li>\n</ul>\n\n<p>一座城市的 <strong>电量</strong>&nbsp;是所有能给它供电的供电站数目。</p>\n\n<p>政府批准了可以额外建造 <code>k</code>&nbsp;座供电站，你需要决定这些供电站分别应该建在哪里，这些供电站与已经存在的供电站有相同的供电范围。</p>\n\n<p>给你两个整数&nbsp;<code>r</code> 和&nbsp;<code>k</code>&nbsp;，如果以最优策略建造额外的发电站，返回所有城市中，最小供电站数目的最大值是多少。</p>\n\n<p>这 <code>k</code>&nbsp;座供电站可以建在多个城市。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>stations = [1,2,4,5,0], r = 1, k = 2\n<b>输出：</b>5\n<b>解释：</b>\n最优方案之一是把 2 座供电站都建在城市 1 。\n每座城市的供电站数目分别为 [1,4,4,5,0] 。\n- 城市 0 的供电站数目为 1 + 4 = 5 。\n- 城市 1 的供电站数目为 1 + 4 + 4 = 9 。\n- 城市 2 的供电站数目为 4 + 4 + 5 = 13 。\n- 城市 3 的供电站数目为 5 + 4 = 9 。\n- 城市 4 的供电站数目为 5 + 0 = 5 。\n供电站数目最少是 5 。\n无法得到更优解，所以我们返回 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>stations = [4,4,4,4], r = 0, k = 3\n<b>输出：</b>4\n<b>解释：</b>\n无论如何安排，总有一座城市的供电站数目是 4 ，所以最优解是 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == stations.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= stations[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= r&nbsp;&lt;= n - 1</code></li>\n\t<li><code>0 &lt;= k&nbsp;&lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2529正整数和负整数的最大计数",
        "hardRate": "EASY",
        "passRate": "76.24%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/solution",
        "problemsDesc": "<p>给你一个按 <strong>非递减顺序</strong> 排列的数组 <code>nums</code> ，返回正整数数目和负整数数目中的最大值。</p>\n\n<ul>\n\t<li>换句话讲，如果 <code>nums</code> 中正整数的数目是 <code>pos</code> ，而负整数的数目是 <code>neg</code> ，返回 <code>pos</code> 和 <code>neg</code>二者中的最大值。</li>\n</ul>\n\n<p><strong>注意：</strong><code>0</code> 既不是正整数也不是负整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-2,-1,-1,1,2,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>共有 3 个正整数和 3 个负整数。计数得到的最大值是 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-3,-2,-1,0,0,1,2]\n<strong>输出：</strong>3\n<strong>解释：</strong>共有 2 个正整数和 3 个负整数。计数得到的最大值是 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,20,66,1314]\n<strong>输出：</strong>4\n<strong>解释：</strong>共有 4 个正整数和 0 个负整数。计数得到的最大值是 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2000</code></li>\n\t<li><code>-2000 &lt;= nums[i] &lt;= 2000</code></li>\n\t<li><code>nums</code> 按 <strong>非递减顺序</strong> 排列。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以设计并实现时间复杂度为 <code>O(log(n))</code> 的算法解决此问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2530执行 K 次操作后的最大分数",
        "hardRate": "MEDIUM",
        "passRate": "44.95%",
        "problemsUrl": "https://leetcode.cn/problems/maximal-score-after-applying-k-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/maximal-score-after-applying-k-operations/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>k</code> 。你的 <strong>起始分数</strong> 为 <code>0</code> 。</p>\n\n<p>在一步 <strong>操作</strong> 中：</p>\n\n<ol>\n\t<li>选出一个满足 <code>0 &lt;= i &lt; nums.length</code> 的下标 <code>i</code> ，</li>\n\t<li>将你的 <strong>分数</strong> 增加 <code>nums[i]</code> ，并且</li>\n\t<li>将 <code>nums[i]</code> 替换为 <code>ceil(nums[i] / 3)</code> 。</li>\n</ol>\n\n<p>返回在 <strong>恰好</strong> 执行 <code>k</code> 次操作后，你可能获得的最大分数。</p>\n\n<p>向上取整函数 <code>ceil(val)</code> 的结果是大于或等于 <code>val</code> 的最小整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,10,10,10,10], k = 5\n<strong>输出：</strong>50\n<strong>解释：</strong>对数组中每个元素执行一次操作。最后分数是 10 + 10 + 10 + 10 + 10 = 50 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,10,3,3,3], k = 3\n<strong>输出：</strong>17\n<strong>解释：</strong>可以执行下述操作：\n第 1 步操作：选中 i = 1 ，nums 变为 [1,<em><strong>4</strong></em>,3,3,3] 。分数增加 10 。\n第 2 步操作：选中 i = 1 ，nums 变为 [1,<em><strong>2</strong></em>,3,3,3] 。分数增加 4 。\n第 3 步操作：选中 i = 2 ，nums 变为 [1,1,<em><strong>1</strong></em>,3,3] 。分数增加 3 。\n最后分数是 10 + 4 + 3 = 17 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2531使字符串总不同字符的数目相等",
        "hardRate": "MEDIUM",
        "passRate": "29.68%",
        "problemsUrl": "https://leetcode.cn/problems/make-number-of-distinct-characters-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/make-number-of-distinct-characters-equal/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong> 开始的字符串 <code>word1</code> 和 <code>word2</code> 。</p>\n\n<p>一次 <strong>移动</strong> 由以下两个步骤组成：</p>\n\n<ul>\n\t<li>选中两个下标&nbsp;<code>i</code> 和 <code>j</code> ，分别满足 <code>0 &lt;= i &lt; word1.length</code> 和 <code>0 &lt;= j &lt; word2.length</code> ，</li>\n\t<li>交换 <code>word1[i]</code> 和 <code>word2[j]</code> 。</li>\n</ul>\n\n<p>如果可以通过 <strong>恰好一次</strong> 移动，使 <code>word1</code> 和 <code>word2</code> 中不同字符的数目相等，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>word1 = \"ac\", word2 = \"b\"\n<strong>输出：</strong>false\n<strong>解释：</strong>交换任何一组下标都会导致第一个字符串中有 2 个不同的字符，而在第二个字符串中只有 1 个不同字符。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>word1 = \"abcc\", word2 = \"aab\"\n<strong>输出：</strong>true\n<strong>解释：</strong>交换第一个字符串的下标 2 和第二个字符串的下标 0 。之后得到 word1 = \"abac\" 和 word2 = \"cab\" ，各有 3 个不同字符。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>word1 = \"abcde\", word2 = \"fghij\"\n<strong>输出：</strong>true\n<strong>解释：</strong>无论交换哪一组下标，两个字符串中都会有 5 个不同字符。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word1.length, word2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>word1</code> 和 <code>word2</code> 仅由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2532过桥的时间",
        "hardRate": "HARD",
        "passRate": "51.71%",
        "problemsUrl": "https://leetcode.cn/problems/time-to-cross-a-bridge/",
        "solutionsUrl": "https://leetcode.cn/problems/time-to-cross-a-bridge/solution",
        "problemsDesc": "<p>共有 <code>k</code> 位工人计划将 <code>n</code> 个箱子从旧仓库移动到新仓库。给你两个整数 <code>n</code> 和 <code>k</code>，以及一个二维整数数组 <code>time</code> ，数组的大小为 <code>k x 4</code> ，其中 <code>time[i] = [leftToRight<sub>i</sub>, pickOld<sub>i</sub>, rightToLeft<sub>i</sub>, putNew<sub>i</sub>]</code> 。</p>\n\n<p>一条河将两座仓库分隔，只能通过一座桥通行。旧仓库位于河的右岸，新仓库在河的左岸。开始时，所有 <code>k</code> 位工人都在桥的左侧等待。为了移动这些箱子，第 <code>i</code> 位工人（下标从 <strong>0</strong> 开始）可以：</p>\n\n<ul>\n\t<li>从左岸（新仓库）跨过桥到右岸（旧仓库），用时 <code>leftToRight<sub>i</sub></code> 分钟。</li>\n\t<li>从旧仓库选择一个箱子，并返回到桥边，用时 <code>pickOld<sub>i</sub></code> 分钟。不同工人可以同时搬起所选的箱子。</li>\n\t<li>从右岸（旧仓库）跨过桥到左岸（新仓库），用时 <code>rightToLeft<sub>i</sub></code> 分钟。</li>\n\t<li>将箱子放入新仓库，并返回到桥边，用时 <code>putNew<sub>i</sub></code> 分钟。不同工人可以同时放下所选的箱子。</li>\n</ul>\n\n<p>如果满足下面任一条件，则认为工人 <code>i</code> 的 <strong>效率低于</strong> 工人 <code>j</code> ：</p>\n\n<ul>\n\t<li><code>leftToRight<sub>i</sub> + rightToLeft<sub>i</sub> &gt; leftToRight<sub>j</sub> + rightToLeft<sub>j</sub></code></li>\n\t<li><code>leftToRight<sub>i</sub> + rightToLeft<sub>i</sub> == leftToRight<sub>j</sub> + rightToLeft<sub>j</sub></code> 且 <code>i &gt; j</code></li>\n</ul>\n\n<p>工人通过桥时需要遵循以下规则：</p>\n\n<ul>\n\t<li>如果工人 <code>x</code> 到达桥边时，工人 <code>y</code> 正在过桥，那么工人 <code>x</code> 需要在桥边等待。</li>\n\t<li>如果没有正在过桥的工人，那么在桥右边等待的工人可以先过桥。如果同时有多个工人在右边等待，那么 <strong>效率最低</strong> 的工人会先过桥。</li>\n\t<li>如果没有正在过桥的工人，且桥右边也没有在等待的工人，同时旧仓库还剩下至少一个箱子需要搬运，此时在桥左边的工人可以过桥。如果同时有多个工人在左边等待，那么 <strong>效率最低</strong> 的工人会先过桥。</li>\n</ul>\n\n<p>所有 <code>n</code> 个盒子都需要放入新仓库，<span class=\"text-only\" data-eleid=\"8\" style=\"white-space: pre;\">请你返回最后一个搬运箱子的工人 </span><strong><span class=\"text-only\" data-eleid=\"9\" style=\"white-space: pre;\">到达河左岸</span></strong><span class=\"text-only\" data-eleid=\"10\" style=\"white-space: pre;\"> 的时间。</span></p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, k = 3, time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n从 0 到 1 ：工人 2 从左岸过桥到达右岸。\n从 1 到 2 ：工人 2 从旧仓库搬起一个箱子。\n从 2 到 6 ：工人 2 从右岸过桥到达左岸。\n从 6 到 7 ：工人 2 将箱子放入新仓库。\n整个过程在 7 分钟后结束。因为问题关注的是最后一个工人到达左岸的时间，所以返回 6 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 2, time = [[1,9,1,8],[10,10,10,10]]\n<strong>输出：</strong>50\n<strong>解释：</strong>\n从 0 到 10 ：工人 1 从左岸过桥到达右岸。\n从 10 到 20 ：工人 1 从旧仓库搬起一个箱子。\n从 10 到 11 ：工人 0 从左岸过桥到达右岸。\n从 11 到 20 ：工人 0 从旧仓库搬起一个箱子。\n从 20 到 30 ：工人 1 从右岸过桥到达左岸。\n从 30 到 40 ：工人 1 将箱子放入新仓库。\n从 30 到 31 ：工人 0 从右岸过桥到达左岸。\n从 31 到 39 ：工人 0 将箱子放入新仓库。\n从 39 到 40 ：工人 0 从左岸过桥到达右岸。\n从 40 到 49 ：工人 0 从旧仓库搬起一个箱子。\n从 49 到 50 ：工人 0 从右岸过桥到达左岸。\n从 50 到 58 ：工人 0 将箱子放入新仓库。\n整个过程在 58 分钟后结束。因为问题关注的是最后一个工人到达左岸的时间，所以返回 50 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n, k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>time.length == k</code></li>\n\t<li><code>time[i].length == 4</code></li>\n\t<li><code>1 &lt;= leftToRight<sub>i</sub>, pickOld<sub>i</sub>, rightToLeft<sub>i</sub>, putNew<sub>i</sub> &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2533好二进制字符串的数量",
        "hardRate": "MEDIUM",
        "passRate": "69.48%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-good-binary-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-good-binary-strings/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2534通过门的时间",
        "hardRate": "HARD",
        "passRate": "63.25%",
        "problemsUrl": "https://leetcode.cn/problems/time-taken-to-cross-the-door/",
        "solutionsUrl": "https://leetcode.cn/problems/time-taken-to-cross-the-door/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2535数组元素和与数字和的绝对差",
        "hardRate": "EASY",
        "passRate": "84.30%",
        "problemsUrl": "https://leetcode.cn/problems/difference-between-element-sum-and-digit-sum-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/difference-between-element-sum-and-digit-sum-of-an-array/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>nums</code> 。</p>\n\n<ul>\n\t<li><strong>元素和</strong> 是 <code>nums</code> 中的所有元素相加求和。</li>\n\t<li><strong>数字和</strong> 是&nbsp;<code>nums</code> 中每一个元素的每一数位（重复数位需多次求和）相加求和。</li>\n</ul>\n\n<p>返回 <strong>元素和</strong> 与 <strong>数字和</strong> 的绝对差。</p>\n\n<p><strong>注意：</strong>两个整数 <code>x</code> 和 <code>y</code> 的绝对差定义为 <code>|x - y|</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,15,6,3]\n<strong>输出：</strong>9\n<strong>解释：</strong>\nnums 的元素和是 1 + 15 + 6 + 3 = 25 。\nnums 的数字和是 1 + 1 + 5 + 6 + 3 = 16 。\n元素和与数字和的绝对差是 |25 - 16| = 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>0\n<strong>解释：</strong>\nnums 的元素和是 1 + 2 + 3 + 4 = 10 。\nnums 的数字和是 1 + 2 + 3 + 4 = 10 。\n元素和与数字和的绝对差是 |10 - 10| = 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 2000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2536子矩阵元素加 1",
        "hardRate": "MEDIUM",
        "passRate": "60.62%",
        "problemsUrl": "https://leetcode.cn/problems/increment-submatrices-by-one/",
        "solutionsUrl": "https://leetcode.cn/problems/increment-submatrices-by-one/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> ，表示最初有一个 <code>n x n</code> 、下标从 <strong>0</strong> 开始的整数矩阵 <code>mat</code> ，矩阵中填满了 0 。</p>\n\n<p>另给你一个二维整数数组 <code>query</code> 。针对每个查询 <code>query[i] = [row1<sub>i</sub>, col1<sub>i</sub>, row2<sub>i</sub>, col2<sub>i</sub>]</code> ，请你执行下述操作：</p>\n\n<ul>\n\t<li>找出 <strong>左上角</strong> 为 <code>(row1<sub>i</sub>, col1<sub>i</sub>)</code> 且 <strong>右下角</strong> 为 <code>(row2<sub>i</sub>, col2<sub>i</sub>)</code> 的子矩阵，将子矩阵中的 <strong>每个元素</strong> 加 <code>1</code> 。也就是给所有满足 <code>row1<sub>i</sub> &lt;= x &lt;= row2<sub>i</sub></code> 和 <code>col1<sub>i</sub> &lt;= y &lt;= col2<sub>i</sub></code> 的 <code>mat[x][y]</code> 加 <code>1</code> 。</li>\n</ul>\n\n<p>返回执行完所有操作后得到的矩阵 <code>mat</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/24/p2example11.png\" style=\"width: 531px; height: 121px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 3, queries = [[1,1,2,2],[0,0,1,1]]\n<strong>输出：</strong>[[1,1,0],[1,2,1],[0,1,1]]\n<strong>解释：</strong>上图所展示的分别是：初始矩阵、执行完第一个操作后的矩阵、执行完第二个操作后的矩阵。\n- 第一个操作：将左上角为 (1, 1) 且右下角为 (2, 2) 的子矩阵中的每个元素加 1 。 \n- 第二个操作：将左上角为 (0, 0) 且右下角为 (1, 1) 的子矩阵中的每个元素加 1 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/24/p2example22.png\" style=\"width: 261px; height: 82px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 2, queries = [[0,0,1,1]]\n<strong>输出：</strong>[[1,1],[1,1]]\n<strong>解释：</strong>上图所展示的分别是：初始矩阵、执行完第一个操作后的矩阵。 \n- 第一个操作：将矩阵中的每个元素加 1 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= row1<sub>i</sub> &lt;= row2<sub>i</sub> &lt; n</code></li>\n\t<li><code>0 &lt;= col1<sub>i</sub> &lt;= col2<sub>i</sub> &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2537统计好子数组的数目",
        "hardRate": "MEDIUM",
        "passRate": "48.72%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-good-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-good-subarrays/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>&nbsp;和一个整数 <code>k</code>&nbsp;，请你返回 <code>nums</code>&nbsp;中 <strong>好</strong>&nbsp;子数组的数目。</p>\n\n<p>一个子数组 <code>arr</code>&nbsp;如果有 <strong>至少</strong>&nbsp;<code>k</code>&nbsp;对下标 <code>(i, j)</code>&nbsp;满足 <code>i &lt; j</code>&nbsp;且 <code>arr[i] == arr[j]</code>&nbsp;，那么称它是一个 <strong>好</strong>&nbsp;子数组。</p>\n\n<p><strong>子数组</strong>&nbsp;是原数组中一段连续 <strong>非空</strong>&nbsp;的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,1,1,1,1], k = 10\n<b>输出：</b>1\n<b>解释：</b>唯一的好子数组是这个数组本身。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [3,1,4,3,2,2,4], k = 2\n<b>输出：</b>4\n<b>解释：</b>总共有 4 个不同的好子数组：\n- [3,1,4,3,2,2] 有 2 对。\n- [3,1,4,3,2,2,4] 有 3 对。\n- [1,4,3,2,2,4] 有 2 对。\n- [4,3,2,2,4] 有 2 对。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2538最大价值和与最小价值和的差值",
        "hardRate": "HARD",
        "passRate": "48.52%",
        "problemsUrl": "https://leetcode.cn/problems/difference-between-maximum-and-minimum-price-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/difference-between-maximum-and-minimum-price-sum/solution",
        "problemsDesc": "<p>给你一个 <code>n</code>&nbsp;个节点的无向无根图，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。给你一个整数&nbsp;<code>n</code>&nbsp;和一个长度为 <code>n - 1</code>&nbsp;的二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示树中节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条边。</p>\n\n<p>每个节点都有一个价值。给你一个整数数组&nbsp;<code>price</code>&nbsp;，其中&nbsp;<code>price[i]</code>&nbsp;是第 <code>i</code>&nbsp;个节点的价值。</p>\n\n<p>一条路径的 <strong>价值和</strong>&nbsp;是这条路径上所有节点的价值之和。</p>\n\n<p>你可以选择树中任意一个节点作为根节点&nbsp;<code>root</code>&nbsp;。选择 <code>root</code>&nbsp;为根的 <strong>开销</strong>&nbsp;是以 <code>root</code>&nbsp;为起点的所有路径中，<strong>价值和</strong>&nbsp;最大的一条路径与最小的一条路径的差值。</p>\n\n<p>请你返回所有节点作为根节点的选择中，<strong>最大</strong>&nbsp;的 <strong>开销</strong>&nbsp;为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/01/example14.png\" style=\"width: 556px; height: 231px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\n<b>输出：</b>24\n<b>解释：</b>上图展示了以节点 2 为根的树。左图（红色的节点）是最大价值和路径，右图（蓝色的节点）是最小价值和路径。\n- 第一条路径节点为 [2,1,3,4]：价值为 [7,8,6,10] ，价值和为 31 。\n- 第二条路径节点为 [2] ，价值为 [7] 。\n最大路径和与最小路径和的差值为 24 。24 是所有方案中的最大开销。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/24/p1_example2.png\" style=\"width: 352px; height: 184px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 3, edges = [[0,1],[1,2]], price = [1,1,1]\n<b>输出：</b>2\n<b>解释：</b>上图展示了以节点 0 为根的树。左图（红色的节点）是最大价值和路径，右图（蓝色的节点）是最小价值和路径。\n- 第一条路径包含节点 [0,1,2]：价值为 [1,1,1] ，价值和为 3 。\n- 第二条路径节点为 [0] ，价值为 [1] 。\n最大路径和与最小路径和的差值为 2 。2 是所有方案中的最大开销。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>edges</code> 表示一棵符合题面要求的树。</li>\n\t<li><code>price.length == n</code></li>\n\t<li><code>1 &lt;= price[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2539好子序列的个数",
        "hardRate": "MEDIUM",
        "passRate": "62.93%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-good-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-good-subsequences/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2540最小公共值",
        "hardRate": "EASY",
        "passRate": "60.43%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-common-value/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-common-value/solution",
        "problemsDesc": "<p>给你两个整数数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;，它们已经按非降序排序，请你返回两个数组的 <strong>最小公共整数</strong>&nbsp;。如果两个数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;没有公共整数，请你返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>如果一个整数在两个数组中都 <strong>至少出现一次</strong>&nbsp;，那么这个整数是数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;<strong>公共</strong>&nbsp;的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,2,3], nums2 = [2,4]\n<b>输出：</b>2\n<b>解释：</b>两个数组的最小公共元素是 2 ，所以我们返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,2,3,6], nums2 = [2,3,4,5]\n<b>输出：</b>2\n<b>解释：</b>两个数组中的公共元素是 2 和 3 ，2 是较小值，所以返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[j] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;都是 <strong>非降序</strong>&nbsp;的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2541使数组中所有元素相等的最小操作数 II",
        "hardRate": "MEDIUM",
        "passRate": "31.27%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-array-equal-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-array-equal-ii/solution",
        "problemsDesc": "<p>给你两个整数数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;，两个数组长度都是&nbsp;<code>n</code>&nbsp;，再给你一个整数&nbsp;<code>k</code>&nbsp;。你可以对数组&nbsp;<code>nums1</code>&nbsp;进行以下操作：</p>\n\n<ul>\n\t<li>选择两个下标&nbsp;<code>i</code> 和&nbsp;<code>j</code>&nbsp;，将&nbsp;<code>nums1[i]</code>&nbsp;增加&nbsp;<code>k</code>&nbsp;，将&nbsp;<code>nums1[j]</code>&nbsp;减少&nbsp;<code>k</code>&nbsp;。换言之，<code>nums1[i] = nums1[i] + k</code> 且&nbsp;<code>nums1[j] = nums1[j] - k</code>&nbsp;。</li>\n</ul>\n\n<p>如果对于所有满足&nbsp;<code>0 &lt;= i &lt; n</code>&nbsp;都有&nbsp;<code>num1[i] == nums2[i]</code>&nbsp;，那么我们称&nbsp;<code>nums1</code> <strong>等于</strong>&nbsp;<code>nums2</code>&nbsp;。</p>\n\n<p>请你返回使<em>&nbsp;</em><code>nums1</code><em> </em>等于<em>&nbsp;</em><code>nums2</code>&nbsp;的&nbsp;<strong>最少</strong>&nbsp;操作数。如果没办法让它们相等，请你返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [4,3,1,4], nums2 = [1,3,7,1], k = 3\n<b>输出：</b>2\n<b>解释：</b>我们可以通过 2 个操作将 nums1 变成 nums2 。\n第 1 个操作：i = 2 ，j = 0 。操作后得到 nums1 = [1,3,4,4] 。\n第 2 个操作：i = 2 ，j = 3 。操作后得到 nums1 = [1,3,7,1] 。\n无法用更少操作使两个数组相等。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [3,8,5,2], nums2 = [2,4,1,6], k = 1\n<b>输出：</b>-1\n<b>解释：</b>无法使两个数组相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length == nums2.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[j] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2542最大子序列的分数",
        "hardRate": "MEDIUM",
        "passRate": "51.38%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-subsequence-score/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-subsequence-score/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>&nbsp;，两者长度都是&nbsp;<code>n</code>&nbsp;，再给你一个正整数&nbsp;<code>k</code>&nbsp;。你必须从&nbsp;<code>nums1</code>&nbsp;中选一个长度为 <code>k</code>&nbsp;的 <strong>子序列</strong>&nbsp;对应的下标。</p>\n\n<p>对于选择的下标&nbsp;<code>i<sub>0</sub></code>&nbsp;，<code>i<sub>1</sub></code>&nbsp;，...，&nbsp;<code>i<sub>k - 1</sub></code>&nbsp;，你的&nbsp;<strong>分数</strong>&nbsp;定义如下：</p>\n\n<ul>\n\t<li><code>nums1</code>&nbsp;中下标对应元素求和，乘以&nbsp;<code>nums2</code>&nbsp;中下标对应元素的&nbsp;<strong>最小值</strong>&nbsp;。</li>\n\t<li>用公示表示：&nbsp;<code>(nums1[i<sub>0</sub>] + nums1[i<sub>1</sub>] +...+ nums1[i<sub>k - 1</sub>]) * min(nums2[i<sub>0</sub>] , nums2[i<sub>1</sub>], ... ,nums2[i<sub>k - 1</sub>])</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回 <strong>最大</strong>&nbsp;可能的分数。</p>\n\n<p>一个数组的 <strong>子序列</strong>&nbsp;下标是集合&nbsp;<code>{0, 1, ..., n-1}</code>&nbsp;中删除若干元素得到的剩余集合，也可以不删除任何元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3\n<b>输出：</b>12\n<b>解释：</b>\n四个可能的子序列分数为：\n- 选择下标 0 ，1 和 2 ，得到分数 (1+3+3) * min(2,1,3) = 7 。\n- 选择下标 0 ，1 和 3 ，得到分数 (1+3+2) * min(2,1,4) = 6 。\n- 选择下标 0 ，2 和 3 ，得到分数 (1+3+2) * min(2,3,4) = 12 。\n- 选择下标 1 ，2 和 3 ，得到分数 (3+3+2) * min(1,3,4) = 8 。\n所以最大分数为 12 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [4,2,3,1,1], nums2 = [7,5,10,9,6], k = 1\n<b>输出：</b>30\n<b>解释：</b>\n选择下标 2 最优：nums1[2] * nums2[2] = 3 * 10 = 30 是最大可能分数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length == nums2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2543判断一个点是否可以到达",
        "hardRate": "HARD",
        "passRate": "46.10%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-point-is-reachable/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-point-is-reachable/solution",
        "problemsDesc": "<p>给你一个无穷大的网格图。一开始你在&nbsp;<code>(1, 1)</code>&nbsp;，你需要通过有限步移动到达点&nbsp;<code>(targetX, targetY)</code>&nbsp;。</p>\n\n<p><b>每一步</b>&nbsp;，你可以从点&nbsp;<code>(x, y)</code>&nbsp;移动到以下点之一：</p>\n\n<ul>\n\t<li><code>(x, y - x)</code></li>\n\t<li><code>(x - y, y)</code></li>\n\t<li><code>(2 * x, y)</code></li>\n\t<li><code>(x, 2 * y)</code></li>\n</ul>\n\n<p>给你两个整数&nbsp;<code>targetX</code> 和&nbsp;<code>targetY</code>&nbsp;，分别表示你最后需要到达点的 X 和 Y 坐标。如果你可以从&nbsp;<code>(1, 1)</code>&nbsp;出发到达这个点，请你返回<code>true</code> ，否则返回<em>&nbsp;</em><code>false</code><em>&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>targetX = 6, targetY = 9\n<b>输出：</b>false\n<b>解释：</b>没法从 (1,1) 出发到达 (6,9) ，所以返回 false 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>targetX = 4, targetY = 7\n<b>输出：</b>true\n<b>解释：</b>你可以按照以下路径到达：(1,1) -&gt; (1,2) -&gt; (1,4) -&gt; (1,8) -&gt; (1,7) -&gt; (2,7) -&gt; (4,7) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= targetX, targetY&nbsp;&lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2544交替数字和",
        "hardRate": "EASY",
        "passRate": "79.82%",
        "problemsUrl": "https://leetcode.cn/problems/alternating-digit-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/alternating-digit-sum/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> 。<code>n</code> 中的每一位数字都会按下述规则分配一个符号：</p>\n\n<ul>\n\t<li><strong>最高有效位</strong> 上的数字分配到 <strong>正</strong> 号。</li>\n\t<li>剩余每位上数字的符号都与其相邻数字相反。</li>\n</ul>\n\n<p>返回所有数字及其对应符号的和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 521\n<strong>输出：</strong>4\n<strong>解释：</strong>(+5) + (-2) + (+1) = 4</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 111\n<strong>输出：</strong>1\n<strong>解释：</strong>(+1) + (-1) + (+1) = 1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 886996\n<strong>输出：</strong>0\n<strong>解释：</strong>(+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2545根据第 K 场考试的分数排序",
        "hardRate": "MEDIUM",
        "passRate": "86.50%",
        "problemsUrl": "https://leetcode.cn/problems/sort-the-students-by-their-kth-score/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-the-students-by-their-kth-score/solution",
        "problemsDesc": "<p>班里有 <code>m</code> 位学生，共计划组织 <code>n</code> 场考试。给你一个下标从 <strong>0</strong> 开始、大小为 <code>m x n</code> 的整数矩阵 <code>score</code> ，其中每一行对应一位学生，而 <code>score[i][j]</code> 表示第 <code>i</code> 位学生在第 <code>j</code> 场考试取得的分数。矩阵 <code>score</code> 包含的整数&nbsp;<strong>互不相同</strong>&nbsp;。</p>\n\n<p>另给你一个整数 <code>k</code> 。请你按第 <code>k</code> 场考试分数从高到低完成对这些学生（矩阵中的行）的排序。</p>\n\n<p>返回排序后的矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/30/example1.png\" style=\"width: 600px; height: 136px;\" /></p>\n\n<pre>\n<strong>输入：</strong>score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2\n<strong>输出：</strong>[[7,5,11,2],[10,6,9,1],[4,8,3,15]]\n<strong>解释：</strong>在上图中，S 表示学生，E 表示考试。\n- 下标为 1 的学生在第 2 场考试取得的分数为 11 ，这是考试的最高分，所以 TA 需要排在第一。\n- 下标为 0 的学生在第 2 场考试取得的分数为 9 ，这是考试的第二高分，所以 TA 需要排在第二。\n- 下标为 2 的学生在第 2 场考试取得的分数为 3 ，这是考试的最低分，所以 TA 需要排在第三。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/30/example2.png\" style=\"width: 486px; height: 121px;\" /></p>\n\n<pre>\n<strong>输入：</strong>score = [[3,4],[5,6]], k = 0\n<strong>输出：</strong>[[5,6],[3,4]]\n<strong>解释：</strong>在上图中，S 表示学生，E 表示考试。\n- 下标为 1 的学生在第 0 场考试取得的分数为 5 ，这是考试的最高分，所以 TA 需要排在第一。\n- 下标为 0 的学生在第 0 场考试取得的分数为 3 ，这是考试的最低分，所以 TA 需要排在第二。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == score.length</code></li>\n\t<li><code>n == score[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 250</code></li>\n\t<li><code>1 &lt;= score[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>score</code> 由 <strong>不同</strong> 的整数组成</li>\n\t<li><code>0 &lt;= k &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2546执行逐位运算使字符串相等",
        "hardRate": "MEDIUM",
        "passRate": "42.16%",
        "problemsUrl": "https://leetcode.cn/problems/apply-bitwise-operations-to-make-strings-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/apply-bitwise-operations-to-make-strings-equal/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong> 开始的 <strong>二元</strong> 字符串 <code>s</code> 和 <code>target</code> ，两个字符串的长度均为 <code>n</code> 。你可以对 <code>s</code> 执行下述操作 <strong>任意</strong> 次：</p>\n\n<ul>\n\t<li>选择两个 <strong>不同</strong> 的下标 <code>i</code> 和 <code>j</code> ，其中 <code>0 &lt;= i, j &lt; n</code> 。</li>\n\t<li>同时，将 <code>s[i]</code> 替换为 (<code>s[i]</code> <strong>OR</strong> <code>s[j]</code>) ，<code>s[j]</code> 替换为 (<code>s[i]</code> <strong>XOR</strong> <code>s[j]</code>) 。</li>\n</ul>\n\n<p>例如，如果 <code>s = \"0110\"</code> ，你可以选择 <code>i = 0</code> 和 <code>j = 2</code>，然后同时将 <code>s[0]</code> 替换为 (<code>s[0]</code> <strong>OR</strong> <code>s[2]</code> = <code>0</code> <strong>OR</strong> <code>1</code> = <code>1</code>)，并将 <code>s[2]</code> 替换为 (<code>s[0]</code> <strong>XOR</strong> <code>s[2]</code> = <code>0</code> <strong>XOR</strong> <code>1</code> = <code>1</code>)，最终得到 <code>s = \"1110\"</code> 。</p>\n\n<p>如果可以使 <code>s</code> 等于 <code>target</code> ，返回 <code>true</code> ，否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"1010\", target = \"0110\"\n<strong>输出：</strong>true\n<strong>解释：</strong>可以执行下述操作：\n- 选择 i = 2 和 j = 0 ，得到 s = \"<em><strong>0</strong></em>0<em><strong>1</strong></em>0\".\n- 选择 i = 2 和 j = 1 ，得到 s = \"0<em><strong>11</strong></em>0\".\n可以使 s 等于 target ，返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"11\", target = \"00\"\n<strong>输出：</strong>false\n<strong>解释：</strong>执行任意次操作都无法使 s 等于 target 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == s.length == target.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 和 <code>target</code> 仅由数字 <code>0</code> 和 <code>1</code> 组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2547拆分数组的最小代价",
        "hardRate": "HARD",
        "passRate": "56.56%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-split-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-split-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>\n\n<p>将数组拆分成一些非空子数组。拆分的 <strong>代价</strong> 是每个子数组中的 <strong>重要性</strong> 之和。</p>\n\n<p>令 <code>trimmed(subarray)</code> 作为子数组的一个特征，其中所有仅出现一次的数字将会被移除。</p>\n\n<ul>\n\t<li>例如，<code>trimmed([3,1,2,4,3,4]) = [3,4,3,4]</code> 。</li>\n</ul>\n\n<p>子数组的 <strong>重要性</strong> 定义为 <code>k + trimmed(subarray).length</code> 。</p>\n\n<ul>\n\t<li>例如，如果一个子数组是 <code>[1,2,3,3,3,4,4]</code> ，<code>trimmed([1,2,3,3,3,4,4]) = [3,3,3,4,4]</code> 。这个子数组的重要性就是 <code>k + 5</code> 。</li>\n</ul>\n\n<p>找出并返回拆分 <code>nums</code> 的所有可行方案中的最小代价。</p>\n\n<p><strong>子数组</strong> 是数组的一个连续 <strong>非空</strong> 元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,2,1,3,3], k = 2\n<strong>输出：</strong>8\n<strong>解释：</strong>将 nums 拆分成两个子数组：[1,2], [1,2,1,3,3]\n[1,2] 的重要性是 2 + (0) = 2 。\n[1,2,1,3,3] 的重要性是 2 + (2 + 2) = 6 。\n拆分的代价是 2 + 6 = 8 ，可以证明这是所有可行的拆分方案中的最小代价。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,2,1], k = 2\n<strong>输出：</strong>6\n<strong>解释：</strong>将 nums 拆分成两个子数组：[1,2], [1,2,1] 。\n[1,2] 的重要性是 2 + (0) = 2 。\n[1,2,1] 的重要性是 2 + (2) = 4 。\n拆分的代价是 2 + 4 = 6 ，可以证明这是所有可行的拆分方案中的最小代价。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,2,1], k = 5\n<strong>输出：</strong>10\n<strong>解释：</strong>将 nums 拆分成一个子数组：[1,2,1,2,1].\n[1,2,1,2,1] 的重要性是 5 + (3 + 2) = 10 。\n拆分的代价是 10 ，可以证明这是所有可行的拆分方案中的最小代价。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt; nums.length</code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2548填满背包的最大价格",
        "hardRate": "MEDIUM",
        "passRate": "58.29%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-price-to-fill-a-bag/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-price-to-fill-a-bag/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2549统计桌面上的不同数字",
        "hardRate": "EASY",
        "passRate": "62.78%",
        "problemsUrl": "https://leetcode.cn/problems/count-distinct-numbers-on-board/",
        "solutionsUrl": "https://leetcode.cn/problems/count-distinct-numbers-on-board/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> ，开始时，它放在桌面上。在 <code>10<sup>9</sup></code> 天内，每天都要执行下述步骤：</p>\n\n<ul>\n\t<li>对于出现在桌面上的每个数字 <code>x</code> ，找出符合 <code>1 &lt;= i &lt;= n</code> 且满足 <code>x % i == 1</code> 的所有数字 <code>i</code> 。</li>\n\t<li>然后，将这些数字放在桌面上。</li>\n</ul>\n\n<p>返回在 <code>10<sup>9</sup></code> 天之后，出现在桌面上的 <strong>不同</strong> 整数的数目。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>一旦数字放在桌面上，则会一直保留直到结束。</li>\n\t<li><code>%</code> 表示取余运算。例如，<code>14 % 3</code> 等于 <code>2</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>4\n<strong>解释：</strong>最开始，5 在桌面上。 \n第二天，2 和 4 也出现在桌面上，因为 5 % 2 == 1 且 5 % 4 == 1 。 \n再过一天 3 也出现在桌面上，因为 4 % 3 == 1 。 \n在十亿天结束时，桌面上的不同数字有 2 、3 、4 、5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3 \n<strong>输出：</strong>2\n<strong>解释：</strong> \n因为 3 % 2 == 1 ，2 也出现在桌面上。 \n在十亿天结束时，桌面上的不同数字只有两个：2 和 3 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2550猴子碰撞的方法数",
        "hardRate": "MEDIUM",
        "passRate": "28.99%",
        "problemsUrl": "https://leetcode.cn/problems/count-collisions-of-monkeys-on-a-polygon/",
        "solutionsUrl": "https://leetcode.cn/problems/count-collisions-of-monkeys-on-a-polygon/solution",
        "problemsDesc": "<p>现在有一个正凸多边形，其上共有 <code>n</code> 个顶点。顶点按顺时针方向从 <code>0</code> 到 <code>n - 1</code> 依次编号。每个顶点上 <strong>正好有一只猴子</strong> 。下图中是一个 6 个顶点的凸多边形。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/22/hexagon.jpg\" style=\"width: 300px; height: 293px;\" /></p>\n\n<p>每个猴子同时移动到相邻的顶点。顶点 <code>i</code> 的相邻顶点可以是：</p>\n\n<ul>\n\t<li>顺时针方向的顶点 <code>(i + 1) % n</code> ，或</li>\n\t<li>逆时针方向的顶点 <code>(i - 1 + n) % n</code> 。</li>\n</ul>\n\n<p>如果移动后至少有两只猴子停留在同一个顶点上或者相交在一条边上，则会发生 <strong>碰撞</strong> 。</p>\n\n<p>返回猴子至少发生 <strong>一次碰撞 </strong>的移动方法数。由于答案可能非常大，请返回对 <code>10<sup>9</sup>+7</code> 取余后的结果。</p>\n\n<p><strong>注意</strong>，每只猴子只能移动一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>6\n<strong>解释：</strong>共计 8 种移动方式。\n下面列出两种会发生碰撞的方式：\n- 猴子 1 顺时针移动；猴子 2 逆时针移动；猴子 3 顺时针移动。猴子 1 和猴子 2 碰撞。\n- 猴子 1 逆时针移动；猴子 2 逆时针移动；猴子 3 顺时针移动。猴子 1 和猴子 3 碰撞。\n可以证明，有 6 种让猴子碰撞的方法。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>14\n<strong>解释：</strong>可以证明，有 14 种让猴子碰撞的方法。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2551将珠子放入背包中",
        "hardRate": "HARD",
        "passRate": "56.47%",
        "problemsUrl": "https://leetcode.cn/problems/put-marbles-in-bags/",
        "solutionsUrl": "https://leetcode.cn/problems/put-marbles-in-bags/solution",
        "problemsDesc": "<p>你有&nbsp;<code>k</code>&nbsp;个背包。给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>weights</code>&nbsp;，其中&nbsp;<code>weights[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个珠子的重量。同时给你整数 <code>k</code>&nbsp;。</p>\n\n<p>请你按照如下规则将所有的珠子放进&nbsp;<code>k</code>&nbsp;个背包。</p>\n\n<ul>\n\t<li>没有背包是空的。</li>\n\t<li>如果第&nbsp;<code>i</code>&nbsp;个珠子和第&nbsp;<code>j</code>&nbsp;个珠子在同一个背包里，那么下标在&nbsp;<code>i</code>&nbsp;到&nbsp;<code>j</code>&nbsp;之间的所有珠子都必须在这同一个背包中。</li>\n\t<li>如果一个背包有下标从&nbsp;<code>i</code>&nbsp;到&nbsp;<code>j</code>&nbsp;的所有珠子，那么这个背包的价格是&nbsp;<code>weights[i] + weights[j]</code>&nbsp;。</li>\n</ul>\n\n<p>一个珠子分配方案的 <strong>分数</strong>&nbsp;是所有 <code>k</code>&nbsp;个背包的价格之和。</p>\n\n<p>请你返回所有分配方案中，<strong>最大分数</strong>&nbsp;与 <strong>最小分数</strong>&nbsp;的 <strong>差值</strong>&nbsp;为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>weights = [1,3,5,1], k = 2\n<b>输出：</b>4\n<b>解释：</b>\n分配方案 [1],[3,5,1] 得到最小得分 (1+1) + (3+1) = 6 。\n分配方案 [1,3],[5,1] 得到最大得分 (1+3) + (5+1) = 10 。\n所以差值为 10 - 6 = 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>weights = [1, 3], k = 2\n<b>输出：</b>0\n<b>解释：</b>唯一的分配方案为 [1],[3] 。\n最大最小得分相等，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= weights.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= weights[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2552统计上升四元组",
        "hardRate": "HARD",
        "passRate": "44.14%",
        "problemsUrl": "https://leetcode.cn/problems/count-increasing-quadruplets/",
        "solutionsUrl": "https://leetcode.cn/problems/count-increasing-quadruplets/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，它包含&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;的所有数字，请你返回上升四元组的数目。</p>\n\n<p>如果一个四元组&nbsp;<code>(i, j, k, l)</code>&nbsp;满足以下条件，我们称它是上升的：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; k &lt; l &lt; n</code>&nbsp;且</li>\n\t<li><code>nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l]</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,3,2,4,5]\n<b>输出：</b>2\n<b>解释：</b>\n- 当 i = 0 ，j = 1 ，k = 2 且 l = 3 时，有 nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l] 。\n- 当 i = 0 ，j = 1 ，k = 2 且 l = 4 时，有 nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l] 。\n没有其他的四元组，所以我们返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4]\n<b>输出：</b>0\n<b>解释：</b>只存在一个四元组 i = 0 ，j = 1 ，k = 2 ，l = 3 ，但是 nums[j] &lt; nums[k] ，所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>4 &lt;= nums.length &lt;= 4000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>\n\t<li><code>nums</code>&nbsp;中所有数字 <strong>互不相同</strong>&nbsp;，<code>nums</code>&nbsp;是一个排列。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2553分割数组中数字的数位",
        "hardRate": "EASY",
        "passRate": "82.55%",
        "problemsUrl": "https://leetcode.cn/problems/separate-the-digits-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/separate-the-digits-in-an-array/solution",
        "problemsDesc": "<p>给你一个正整数数组&nbsp;<code>nums</code>&nbsp;，请你返回一个数组<em>&nbsp;</em><code>answer</code> ，你需要将&nbsp;<code>nums</code>&nbsp;中每个整数进行数位分割后，按照&nbsp;<code>nums</code>&nbsp;中出现的&nbsp;<strong>相同顺序</strong>&nbsp;放入答案数组中。</p>\n\n<p>对一个整数进行数位分割，指的是将整数各个数位按原本出现的顺序排列成数组。</p>\n\n<ul>\n\t<li>比方说，整数&nbsp;<code>10921</code>&nbsp;，分割它的各个数位得到&nbsp;<code>[1,0,9,2,1]</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [13,25,83,77]\n<b>输出：</b>[1,3,2,5,8,3,7,7]\n<b>解释：</b>\n- 分割 13 得到 [1,3] 。\n- 分割 25 得到 [2,5] 。\n- 分割 83 得到 [8,3] 。\n- 分割 77 得到 [7,7] 。\nanswer = [1,3,2,5,8,3,7,7] 。answer 中的数字分割结果按照原数字在数组中的相同顺序排列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [7,1,3,9]\n<b>输出：</b>[7,1,3,9]\n<b>解释：</b>nums 中每个整数的分割是它自己。\nanswer = [7,1,3,9] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2554从一个范围内选择最多整数 I",
        "hardRate": "MEDIUM",
        "passRate": "58.23%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-integers-to-choose-from-a-range-i/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-integers-to-choose-from-a-range-i/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>banned</code>&nbsp;和两个整数&nbsp;<code>n</code> 和&nbsp;<code>maxSum</code>&nbsp;。你需要按照以下规则选择一些整数：</p>\n\n<ul>\n\t<li>被选择整数的范围是&nbsp;<code>[1, n]</code>&nbsp;。</li>\n\t<li>每个整数 <strong>至多</strong>&nbsp;选择 <strong>一次</strong>&nbsp;。</li>\n\t<li>被选择整数不能在数组&nbsp;<code>banned</code>&nbsp;中。</li>\n\t<li>被选择整数的和不超过&nbsp;<code>maxSum</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回按照上述规则 <strong>最多</strong>&nbsp;可以选择的整数数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>banned = [1,6,5], n = 5, maxSum = 6\n<b>输出：</b>2\n<b>解释：</b>你可以选择整数 2 和 4 。\n2 和 4 在范围 [1, 5] 内，且它们都不在 banned 中，它们的和是 6 ，没有超过 maxSum 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>banned = [1,2,3,4,5,6,7], n = 8, maxSum = 1\n<b>输出：</b>0\n<b>解释：</b>按照上述规则无法选择任何整数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>banned = [11], n = 7, maxSum = 50\n<b>输出：</b>7\n<b>解释：</b>你可以选择整数 1, 2, 3, 4, 5, 6 和 7 。\n它们都在范围 [1, 7] 中，且都没出现在 banned 中，它们的和是 28 ，没有超过 maxSum 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= banned.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= banned[i], n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= maxSum &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2555两个线段获得的最多奖品",
        "hardRate": "MEDIUM",
        "passRate": "39.89%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-win-from-two-segments/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-win-from-two-segments/solution",
        "problemsDesc": "<p>在 <strong>X轴</strong>&nbsp;上有一些奖品。给你一个整数数组&nbsp;<code>prizePositions</code>&nbsp;，它按照 <strong>非递减</strong>&nbsp;顺序排列，其中&nbsp;<code>prizePositions[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;件奖品的位置。数轴上一个位置可能会有多件奖品。再给你一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>你可以选择两个端点为整数的线段。每个线段的长度都必须是 <code>k</code>&nbsp;。你可以获得位置在任一线段上的所有奖品（包括线段的两个端点）。注意，两个线段可能会有相交。</p>\n\n<ul>\n\t<li>比方说&nbsp;<code>k = 2</code>&nbsp;，你可以选择线段&nbsp;<code>[1, 3]</code> 和&nbsp;<code>[2, 4]</code>&nbsp;，你可以获得满足&nbsp;<code>1 &lt;= prizePositions[i] &lt;= 3</code> 或者&nbsp;<code>2 &lt;= prizePositions[i] &lt;= 4</code>&nbsp;的所有奖品 i 。</li>\n</ul>\n\n<p>请你返回在选择两个最优线段的前提下，可以获得的 <strong>最多</strong>&nbsp;奖品数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>prizePositions = [1,1,2,2,3,3,5], k = 2\n<b>输出：</b>7\n<b>解释：</b>这个例子中，你可以选择线段 [1, 3] 和 [3, 5] ，获得 7 个奖品。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>prizePositions = [1,2,3,4], k = 0\n<b>输出：</b>2\n<b>解释：</b>这个例子中，一个选择是选择线段 <code>[3, 3]</code> 和 <code>[4, 4] ，获得 2 个奖品。</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prizePositions.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= prizePositions[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>9</sup> </code></li>\n\t<li><code>prizePositions</code>&nbsp;有序非递减。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2556二进制矩阵中翻转最多一次使路径不连通",
        "hardRate": "MEDIUM",
        "passRate": "30.24%",
        "problemsUrl": "https://leetcode.cn/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/",
        "solutionsUrl": "https://leetcode.cn/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;<strong>二进制</strong> 矩阵&nbsp;<code>grid</code>&nbsp;。你可以从一个格子&nbsp;<code>(row, col)</code>&nbsp;移动到格子&nbsp;<code>(row + 1, col)</code>&nbsp;或者&nbsp;<code>(row, col + 1)</code>&nbsp;，前提是前往的格子值为 <code>1</code>&nbsp;。如果从&nbsp;<code>(0, 0)</code>&nbsp;到&nbsp;<code>(m - 1, n - 1)</code>&nbsp;没有任何路径，我们称该矩阵是&nbsp;<strong>不连通</strong>&nbsp;的。</p>\n\n<p>你可以翻转 <strong>最多一个</strong>&nbsp;格子的值（也可以不翻转）。你 <strong>不能翻转</strong>&nbsp;格子&nbsp;<code>(0, 0)</code> 和&nbsp;<code>(m - 1, n - 1)</code>&nbsp;。</p>\n\n<p>如果可以使矩阵不连通，请你返回&nbsp;<code>true</code>&nbsp;，否则返回<em>&nbsp;</em><code>false</code><em>&nbsp;</em>。</p>\n\n<p><strong>注意</strong>&nbsp;，翻转一个格子的值，可以使它的值从&nbsp;<code>0</code>&nbsp;变&nbsp;<code>1</code>&nbsp;，或从&nbsp;<code>1</code>&nbsp;变&nbsp;<code>0</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/07/yetgrid2drawio.png\" style=\"width: 441px; height: 151px;\" /></p>\n\n<pre>\n<b>输入：</b>grid = [[1,1,1],[1,0,0],[1,1,1]]\n<strong>输出：</strong>true\n<b>解释：</b>按照上图所示我们翻转蓝色格子里的值，翻转后从 (0, 0) 到 (2, 2) 没有路径。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/07/yetgrid3drawio.png\" /></p>\n\n<pre>\n<b>输入：</b>grid = [[1,1,1],[1,0,1],[1,1,1]]\n<b>输出：</b>false\n<b>解释：</b>无法翻转至多一个格子，使 (0, 0) 到 (2, 2) 没有路径。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>grid[0][0] == grid[m - 1][n - 1] == 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2557从一个范围内选择最多整数 II",
        "hardRate": "MEDIUM",
        "passRate": "43.22%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-integers-to-choose-from-a-range-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-integers-to-choose-from-a-range-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2558从数量最多的堆取走礼物",
        "hardRate": "EASY",
        "passRate": "68.09%",
        "problemsUrl": "https://leetcode.cn/problems/take-gifts-from-the-richest-pile/",
        "solutionsUrl": "https://leetcode.cn/problems/take-gifts-from-the-richest-pile/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>gifts</code> ，表示各堆礼物的数量。每一秒，你需要执行以下操作：</p>\n\n<ul>\n\t<li>选择礼物数量最多的那一堆。</li>\n\t<li>如果不止一堆都符合礼物数量最多，从中选择任一堆即可。</li>\n\t<li>选中的那一堆留下平方根数量的礼物（向下取整），取走其他的礼物。</li>\n</ul>\n\n<p>返回在 <code>k</code> 秒后剩下的礼物数量<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>gifts = [25,64,9,4,100], k = 4\n<strong>输出：</strong>29\n<strong>解释：</strong> \n按下述方式取走礼物：\n- 在第一秒，选中最后一堆，剩下 10 个礼物。\n- 接着第二秒选中第二堆礼物，剩下 8 个礼物。\n- 然后选中第一堆礼物，剩下 5 个礼物。\n- 最后，再次选中最后一堆礼物，剩下 3 个礼物。\n最后剩下的礼物数量分别是 [5,8,9,4,3] ，所以，剩下礼物的总数量是 29 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>gifts = [1,1,1,1], k = 4\n<strong>输出：</strong>4\n<strong>解释：</strong>\n在本例中，不管选中哪一堆礼物，都必须剩下 1 个礼物。 \n也就是说，你无法获取任一堆中的礼物。 \n所以，剩下礼物的总数量是 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= gifts.length &lt;= 10<sup>3</sup></code></li>\n\t<li><code>1 &lt;= gifts[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>3</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2559统计范围内的元音字符串数",
        "hardRate": "MEDIUM",
        "passRate": "64.31%",
        "problemsUrl": "https://leetcode.cn/problems/count-vowel-strings-in-ranges/",
        "solutionsUrl": "https://leetcode.cn/problems/count-vowel-strings-in-ranges/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串数组 <code>words</code> 以及一个二维整数数组 <code>queries</code> 。</p>\n\n<p>每个查询 <code>queries[i] = [l<sub>i</sub>, r<sub>i</sub>]</code> 会要求我们统计在 <code>words</code> 中下标在 <code>l<sub>i</sub></code> 到 <code>r<sub>i</sub></code> 范围内（<strong>包含</strong> 这两个值）并且以元音开头和结尾的字符串的数目。</p>\n\n<p>返回一个整数数组，其中数组的第 <code>i</code> 个元素对应第 <code>i</code> 个查询的答案。</p>\n\n<p><strong>注意：</strong>元音字母是 <code>'a'</code>、<code>'e'</code>、<code>'i'</code>、<code>'o'</code> 和 <code>'u'</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"aba\",\"bcb\",\"ece\",\"aa\",\"e\"], queries = [[0,2],[1,4],[1,1]]\n<strong>输出：</strong>[2,3,0]\n<strong>解释：</strong>以元音开头和结尾的字符串是 \"aba\"、\"ece\"、\"aa\" 和 \"e\" 。\n查询 [0,2] 结果为 2（字符串 \"aba\" 和 \"ece\"）。\n查询 [1,4] 结果为 3（字符串 \"ece\"、\"aa\"、\"e\"）。\n查询 [1,1] 结果为 0 。\n返回结果 [2,3,0] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"a\",\"e\",\"i\"], queries = [[0,2],[0,1],[2,2]]\n<strong>输出：</strong>[3,2,1]\n<strong>解释：</strong>每个字符串都满足这一条件，所以返回 [3,2,1] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 40</code></li>\n\t<li><code>words[i]</code> 仅由小写英文字母组成</li>\n\t<li><code>sum(words[i].length) &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= queries[j][0] &lt;= queries[j][1] &lt;&nbsp;words.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2560打家劫舍 IV",
        "hardRate": "MEDIUM",
        "passRate": "49.74%",
        "problemsUrl": "https://leetcode.cn/problems/house-robber-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/house-robber-iv/solution",
        "problemsDesc": "<p>沿街有一排连续的房屋。每间房屋内都藏有一定的现金。现在有一位小偷计划从这些房屋中窃取现金。</p>\n\n<p>由于相邻的房屋装有相互连通的防盗系统，所以小偷 <strong>不会窃取相邻的房屋</strong> 。</p>\n\n<p>小偷的 <strong>窃取能力</strong> 定义为他在窃取过程中能从单间房屋中窃取的 <strong>最大金额</strong> 。</p>\n\n<p>给你一个整数数组 <code>nums</code> 表示每间房屋存放的现金金额。形式上，从左起第 <code>i</code> 间房屋中放有 <code>nums[i]</code> 美元。</p>\n\n<p>另给你一个整数&nbsp;<code>k</code> ，表示窃贼将会窃取的 <strong>最少</strong> 房屋数。小偷总能窃取至少 <code>k</code> 间房屋。</p>\n\n<p>返回小偷的 <strong>最小</strong> 窃取能力。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,5,9], k = 2\n<strong>输出：</strong>5\n<strong>解释：</strong>\n小偷窃取至少 2 间房屋，共有 3 种方式：\n- 窃取下标 0 和 2 处的房屋，窃取能力为 max(nums[0], nums[2]) = 5 。\n- 窃取下标 0 和 3 处的房屋，窃取能力为 max(nums[0], nums[3]) = 9 。\n- 窃取下标 1 和 3 处的房屋，窃取能力为 max(nums[1], nums[3]) = 9 。\n因此，返回 min(5, 9, 9) = 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,7,9,3,1], k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>共有 7 种窃取方式。窃取能力最小的情况所对应的方式是窃取下标 0 和 4 处的房屋。返回 max(nums[0], nums[4]) = 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= (nums.length + 1)/2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2561重排水果",
        "hardRate": "HARD",
        "passRate": "36.53%",
        "problemsUrl": "https://leetcode.cn/problems/rearranging-fruits/",
        "solutionsUrl": "https://leetcode.cn/problems/rearranging-fruits/solution",
        "problemsDesc": "<p>你有两个果篮，每个果篮中有 <code>n</code> 个水果。给你两个下标从 <strong>0</strong> 开始的整数数组 <code>basket1</code> 和 <code>basket2</code> ，用以表示两个果篮中每个水果的成本。</p>\n\n<p>你希望两个果篮相等。为此，可以根据需要多次执行下述操作：</p>\n\n<ul>\n\t<li>选中两个下标 <code>i</code> 和 <code>j</code> ，并交换 <code>basket1</code> 中的第 <code>i</code> 个水果和 <code>basket2</code> 中的第 <code>j</code> 个水果。</li>\n\t<li>交换的成本是 <code>min(basket1<sub>i</sub>,basket2<sub>j</sub>)</code> 。</li>\n</ul>\n\n<p>根据果篮中水果的成本进行排序，如果排序后结果完全相同，则认为两个果篮相等。</p>\n\n<p>返回使两个果篮相等的最小交换成本，如果无法使两个果篮相等，则返回<em> </em><code>-1</code><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>basket1 = [4,2,2,2], basket2 = [1,4,1,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>交换 basket1 中下标为 1 的水果和 basket2 中下标为 0 的水果，交换的成本为 1 。此时，basket1 = [4,1,2,2] 且 basket2 = [2,4,1,2] 。重排两个数组，发现二者相等。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>basket1 = [2,3,4,1], basket2 = [3,2,5,1]\n<strong>输出：</strong>-1\n<strong>解释：</strong>可以证明无法使两个果篮相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>basket1.length == bakste2.length</code></li>\n\t<li><code>1 &lt;= basket1.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= basket1<sub>i</sub>,basket2<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2562找出数组的串联值",
        "hardRate": "EASY",
        "passRate": "73.23%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-array-concatenation-value/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-array-concatenation-value/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组&nbsp;<code>nums</code> 。</p>\n\n<p>现定义两个数字的 <strong>串联</strong>&nbsp;是由这两个数值串联起来形成的新数字。</p>\n\n<ul>\n\t<li>例如，<code>15</code><span style=\"\">&nbsp;和&nbsp;</span><code>49</code>&nbsp;的串联是&nbsp;<code>1549</code> 。</li>\n</ul>\n\n<p><code>nums</code>&nbsp;的 <strong>串联值</strong>&nbsp;最初等于 <code>0</code> 。执行下述操作直到&nbsp;<code>nums</code>&nbsp;变为空：</p>\n\n<ul>\n\t<li>如果&nbsp;<code>nums</code>&nbsp;中存在不止一个数字，分别选中 <code>nums</code> 中的第一个元素和最后一个元素，将二者串联得到的值加到&nbsp;<code>nums</code>&nbsp;的 <strong>串联值</strong> 上，然后从&nbsp;<code>nums</code>&nbsp;中删除第一个和最后一个元素。</li>\n\t<li>如果仅存在一个元素，则将该元素的值加到&nbsp;<code>nums</code> 的串联值上，然后删除这个元素。</li>\n</ul>\n\n<p>返回执行完所有操作后<em>&nbsp;</em><code>nums</code> 的串联值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [7,52,2,4]\n<b>输出：</b>596\n<b>解释：</b>在执行任一步操作前，nums 为 [7,52,2,4] ，串联值为 0 。\n - 在第一步操作中：\n我们选中第一个元素 7 和最后一个元素 4 。\n二者的串联是 74 ，将其加到串联值上，所以串联值等于 74 。\n接着我们从 nums 中移除这两个元素，所以 nums 变为 [52,2] 。\n - 在第二步操作中： \n我们选中第一个元素 52 和最后一个元素 2 。 \n二者的串联是 522 ，将其加到串联值上，所以串联值等于 596 。\n接着我们从 nums 中移除这两个元素，所以 nums 变为空。\n由于串联值等于 596 ，所以答案就是 596 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5,14,13,8,12]\n<b>输出：</b>673\n<b>解释：</b>在执行任一步操作前，nums 为 [5,14,13,8,12] ，串联值为 0 。 \n- 在第一步操作中： \n我们选中第一个元素 5 和最后一个元素 12 。 \n二者的串联是 512 ，将其加到串联值上，所以串联值等于 512 。 \n接着我们从 nums 中移除这两个元素，所以 nums 变为 [14,13,8] 。\n- 在第二步操作中：\n我们选中第一个元素 14 和最后一个元素 8 。\n二者的串联是 148 ，将其加到串联值上，所以串联值等于 660 。\n接着我们从 nums 中移除这两个元素，所以 nums 变为 [13] 。 \n- 在第三步操作中：\nnums 只有一个元素，所以我们选中 13 并将其加到串联值上，所以串联值等于 673 。\n接着我们从 nums 中移除这个元素，所以 nums 变为空。 \n由于串联值等于 673 ，所以答案就是 673 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2563统计公平数对的数目",
        "hardRate": "MEDIUM",
        "passRate": "33.66%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-fair-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-fair-pairs/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组&nbsp;<code>nums</code>&nbsp;，和两个整数&nbsp;<code>lower</code> 和&nbsp;<code>upper</code> ，返回 <strong>公平数对的数目</strong> 。</p>\n\n<p>如果&nbsp;<code>(i, j)</code>&nbsp;数对满足以下情况，则认为它是一个 <strong>公平数对</strong>&nbsp;：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; n</code>，且</li>\n\t<li><code>lower &lt;= nums[i] + nums[j] &lt;= upper</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre>\n<b>输入：</b>nums = [0,1,7,4,4,5], lower = 3, upper = 6\n<b>输出：</b>6\n<b>解释：</b>共计 6 个公平数对：(0,3)、(0,4)、(0,5)、(1,3)、(1,4) 和 (1,5) 。\n</pre>\n\n<p><b>示例 2：</b></p>\n\n<pre>\n<b>输入：</b>nums = [1,7,9,2,5], lower = 11, upper = 11\n<b>输出：</b>1\n<b>解释：</b>只有单个公平数对：(2,3) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums.length == n</code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= lower &lt;= upper &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2564子字符串异或查询",
        "hardRate": "MEDIUM",
        "passRate": "36.37%",
        "problemsUrl": "https://leetcode.cn/problems/substring-xor-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/substring-xor-queries/solution",
        "problemsDesc": "<p>给你一个 <strong>二进制字符串</strong>&nbsp;<code>s</code>&nbsp;和一个整数数组&nbsp;<code>queries</code>&nbsp;，其中&nbsp;<code>queries[i] = [first<sub>i</sub>, second<sub>i</sub>]</code>&nbsp;。</p>\n\n<p>对于第&nbsp;<code>i</code>&nbsp;个查询，找到 <code>s</code>&nbsp;的 <strong>最短子字符串</strong>&nbsp;，它对应的 <strong>十进制</strong>值&nbsp;<code>val</code>&nbsp;与&nbsp;<code>first<sub>i</sub></code>&nbsp;<b>按位异或</b>&nbsp;得到&nbsp;<code>second<sub>i</sub></code>&nbsp;，换言之，<code>val ^ first<sub>i</sub> == second<sub>i</sub></code>&nbsp;。</p>\n\n<p>第&nbsp;<code>i</code>&nbsp;个查询的答案是子字符串&nbsp;<code>[left<sub>i</sub>, right<sub>i</sub>]</code> 的两个端点（下标从&nbsp;<strong>0</strong>&nbsp;开始），如果不存在这样的子字符串，则答案为&nbsp;<code>[-1, -1]</code>&nbsp;。如果有多个答案，请你选择&nbsp;<code>left<sub>i</sub></code>&nbsp;最小的一个。</p>\n\n<p>请你返回一个数组&nbsp;<code>ans</code>&nbsp;，其中&nbsp;<code>ans[i] = [left<sub>i</sub>, right<sub>i</sub>]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个查询的答案。</p>\n\n<p><strong>子字符串</strong>&nbsp;是一个字符串中一段连续非空的字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"101101\", queries = [[0,5],[1,2]]\n<b>输出：</b>[[0,2],[2,3]]\n<b>解释：</b>第一个查询，端点为 <code>[0,2]</code> 的子字符串为 <strong>\"101\"</strong> ，对应十进制数字 <strong><code>5 ，且</code></strong> <strong><code>5 ^ 0 = 5</code></strong>&nbsp;，所以第一个查询的答案为 <code>[0,2]。第二个查询中，</code>端点为 <code>[2,3] 的子字符串为 </code><strong>\"11\" ，对应十进制数字</strong> <strong>3</strong>&nbsp;，且 <strong>3<code> ^ 1 = 2</code></strong><code>&nbsp;。所以第二个查询的答案为</code> <code>[2,3]</code> 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"0101\", queries = [[12,8]]\n<b>输出：</b>[[-1,-1]]\n<b>解释：</b>这个例子中，没有符合查询的答案，所以返回 <code>[-1,-1] 。</code>\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"1\", queries = [[4,5]]\n<b>输出：</b>[[0,0]]\n<b>解释：</b>这个例子中，端点为 <code>[0,0]</code> 的子字符串对应的十进制值为 <strong><code>1</code></strong><code>&nbsp;，且</code> <strong><code>1 ^ 4 = 5</code></strong><code>&nbsp;。所以答案为</code> <code>[0,0] 。</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s[i]</code>&nbsp;要么是&nbsp;<code>'0'</code>&nbsp;，要么是&nbsp;<code>'1'</code>&nbsp;。</li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= first<sub>i</sub>, second<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2565最少得分子序列",
        "hardRate": "HARD",
        "passRate": "35.90%",
        "problemsUrl": "https://leetcode.cn/problems/subsequence-with-the-minimum-score/",
        "solutionsUrl": "https://leetcode.cn/problems/subsequence-with-the-minimum-score/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>s</code> 和&nbsp;<code>t</code>&nbsp;。</p>\n\n<p>你可以从字符串 <code>t</code>&nbsp;中删除任意数目的字符。</p>\n\n<p>如果没有从字符串&nbsp;<code>t</code>&nbsp;中删除字符，那么得分为&nbsp;<code>0</code>&nbsp;，否则：</p>\n\n<ul>\n\t<li>令&nbsp;<code>left</code>&nbsp;为删除字符中的最小下标。</li>\n\t<li>令&nbsp;<code>right</code>&nbsp;为删除字符中的最大下标。</li>\n</ul>\n\n<p>字符串的得分为&nbsp;<code>right - left + 1</code>&nbsp;。</p>\n\n<p>请你返回使<em>&nbsp;</em><code>t</code><em> </em>成为<em>&nbsp;</em><code>s</code>&nbsp;子序列的最小得分。</p>\n\n<p>一个字符串的 <strong>子序列</strong>&nbsp;是从原字符串中删除一些字符后（也可以一个也不删除），剩余字符不改变顺序得到的字符串。（比方说&nbsp;<code>\"ace\"</code> 是&nbsp;<code>\"<strong><em>a</em></strong>b<strong><em>c</em></strong>d<strong><em>e</em></strong>\"</code>&nbsp;的子序列，但是&nbsp;<code>\"aec\"</code>&nbsp;不是）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"abacaba\", t = \"bzaa\"\n<b>输出：</b>1\n<b>解释：</b>这个例子中，我们删除下标 1 处的字符 \"z\" （下标从 0 开始）。\n字符串 t 变为 \"baa\" ，它是字符串 \"abacaba\" 的子序列，得分为 1 - 1 + 1 = 1 。\n1 是能得到的最小得分。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"cde\", t = \"xyz\"\n<b>输出：</b>3\n<b>解释：</b>这个例子中，我们将下标为 0， 1 和 2 处的字符 \"x\" ，\"y\" 和 \"z\" 删除（下标从 0 开始）。\n字符串变成 \"\" ，它是字符串 \"cde\" 的子序列，得分为 2 - 0 + 1 = 3 。\n3 是能得到的最小得分。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 和&nbsp;<code>t</code>&nbsp;都只包含小写英文字母。</li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2566替换一个数字后的最大差值",
        "hardRate": "EASY",
        "passRate": "63.65%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-difference-by-remapping-a-digit/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-difference-by-remapping-a-digit/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>num</code>&nbsp;。你知道 Danny Mittal 会偷偷将 <code>0</code>&nbsp;到 <code>9</code>&nbsp;中的一个数字 <strong>替换</strong> 成另一个数字。</p>\n\n<p>请你返回将 <code>num</code>&nbsp;中&nbsp;<strong>恰好一个</strong>&nbsp;数字进行替换后，得到的最大值和最小值的差为多少。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>当 Danny 将一个数字 <code>d1</code> 替换成另一个数字 <code>d2</code> 时，Danny 需要将&nbsp;<code>nums</code>&nbsp;中所有 <code>d1</code>&nbsp;都替换成&nbsp;<code>d2</code>&nbsp;。</li>\n\t<li>Danny 可以将一个数字替换成它自己，也就是说&nbsp;<code>num</code>&nbsp;可以不变。</li>\n\t<li>Danny 可以将数字分别替换成两个不同的数字分别得到最大值和最小值。</li>\n\t<li>替换后得到的数字可以包含前导 0 。</li>\n\t<li>Danny Mittal 获得周赛 326 前 10 名，让我们恭喜他。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>num = 11891\n<b>输出：</b>99009\n<b>解释：</b>\n为了得到最大值，我们将数字 1 替换成数字 9 ，得到 99899 。\n为了得到最小值，我们将数字 1 替换成数字 0 ，得到 890 。\n两个数字的差值为 99009 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>num = 90\n<b>输出：</b>99\n<strong>解释：</strong>\n可以得到的最大值是 99（将 0 替换成 9），最小值是 0（将 9 替换成 0）。\n所以我们得到 99 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2567修改两个元素的最小分数",
        "hardRate": "MEDIUM",
        "passRate": "51.86%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-score-by-changing-two-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-score-by-changing-two-elements/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<ul>\n\t<li><code>nums</code> 的 <strong>最小</strong>&nbsp;得分是满足 <code>0 &lt;= i &lt; j &lt; nums.length</code>&nbsp;的&nbsp;<code>|nums[i]&nbsp;- nums[j]|</code>&nbsp;的最小值。</li>\n\t<li><code>nums</code>的 <strong>最大 </strong>得分是满足 <code>0 &lt;= i &lt; j &lt; nums.length</code>&nbsp;的&nbsp;<code>|nums[i]&nbsp;- nums[j]|</code>&nbsp;的最大值。</li>\n\t<li><code>nums</code>&nbsp;的分数是 <strong>最大</strong>&nbsp;得分与 <strong>最小</strong>&nbsp;得分的和。</li>\n</ul>\n\n<p>我们的目标是最小化&nbsp;<code>nums</code>&nbsp;的分数。你 <strong>最多</strong> 可以修改&nbsp;<code>nums</code>&nbsp;中&nbsp;<strong>2</strong>&nbsp;个元素的值。</p>\n\n<p>请你返回修改&nbsp;<code>nums</code>&nbsp;中&nbsp;<strong>至多两个</strong>&nbsp;元素的值后，可以得到的 <strong>最小分数</strong>&nbsp;。</p>\n\n<p><code>|x|</code>&nbsp;表示 <code>x</code>&nbsp;的绝对值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,4,3]\n<b>输出：</b>0\n<b>解释：</b>将 nums[1] 和 nums[2] 的值改为 1 ，nums 变为 [1,1,1] 。<code>|nums[i] - nums[j]|</code> 的值永远为 0 ，所以我们返回 0 + 0 = 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,4,7,8,5]\n<b>输出：</b>3\n<b>解释：\n</b>将 nums[0] 和 nums[1] 的值变为 6 ，nums 变为 [6,6,7,8,5] 。\n最小得分是 i = 0 且 j = 1 时得到的 |<code>nums[i] - nums[j]</code>| = |6 - 6| = 0 。\n最大得分是 i = 3 且 j = 4 时得到的 |<code>nums[i] - nums[j]</code>| = |8 - 5| = 3 。\n最大得分与最小得分之和为 3 。这是最优答案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2568最小无法得到的或值",
        "hardRate": "MEDIUM",
        "passRate": "59.91%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-impossible-or/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-impossible-or/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>如果存在一些整数满足&nbsp;<code>0 &lt;= index<sub>1</sub> &lt; index<sub>2</sub> &lt; ... &lt; index<sub>k</sub> &lt; nums.length</code>&nbsp;，得到&nbsp;<code>nums[index<sub>1</sub>] | nums[index<sub>2</sub>] | ... | nums[index<sub>k</sub>] = x</code>&nbsp;，那么我们说&nbsp;<code>x</code>&nbsp;是&nbsp;<strong>可表达的</strong>&nbsp;。换言之，如果一个整数能由&nbsp;<code>nums</code>&nbsp;的某个子序列的或运算得到，那么它就是可表达的。</p>\n\n<p>请你返回 <code>nums</code>&nbsp;不可表达的 <strong>最小非零整数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,1]\n<b>输出：</b>4\n<b>解释：</b>1 和 2 已经在数组中，因为 nums[0] | nums[1] = 2 | 1 = 3 ，所以 3 是可表达的。由于 4 是不可表达的，所以我们返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [5,3,2]\n<b>输出：</b>1\n<b>解释：</b>1 是最小不可表达的数字。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2569更新数组后处理求和查询",
        "hardRate": "HARD",
        "passRate": "39.89%",
        "problemsUrl": "https://leetcode.cn/problems/handling-sum-queries-after-update/",
        "solutionsUrl": "https://leetcode.cn/problems/handling-sum-queries-after-update/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;，和一个二维数组&nbsp;<code>queries</code>&nbsp;表示一些操作。总共有 3 种类型的操作：</p>\n\n<ol>\n\t<li>操作类型 1 为&nbsp;<code>queries[i]&nbsp;= [1, l, r]</code>&nbsp;。你需要将 <code>nums1</code>&nbsp;从下标&nbsp;<code>l</code>&nbsp;到下标 <code>r</code>&nbsp;的所有 <code>0</code>&nbsp;反转成 <code>1</code>&nbsp;或将 <code>1</code>&nbsp;反转成 <code>0</code>&nbsp;。<code>l</code>&nbsp;和 <code>r</code>&nbsp;下标都从 <strong>0</strong>&nbsp;开始。</li>\n\t<li>操作类型 2 为&nbsp;<code>queries[i]&nbsp;= [2, p, 0]</code>&nbsp;。对于&nbsp;<code>0 &lt;= i &lt; n</code>&nbsp;中的所有下标，令&nbsp;<code>nums2[i] =&nbsp;nums2[i]&nbsp;+ nums1[i]&nbsp;* p</code>&nbsp;。</li>\n\t<li>操作类型 3 为&nbsp;<code>queries[i]&nbsp;= [3, 0, 0]</code>&nbsp;。求&nbsp;<code>nums2</code>&nbsp;中所有元素的和。</li>\n</ol>\n\n<p>请你返回一个数组，包含所有第三种操作类型的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums1 = [1,0,1], nums2 = [0,0,0], queries = [[1,1,1],[2,1,0],[3,0,0]]\n<b>输出：</b>[3]\n<strong>解释：</strong>第一个操作后 nums1 变为 [1,1,1] 。第二个操作后，nums2 变成 [1,1,1] ，所以第三个操作的答案为 3 。所以返回 [3] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums1 = [1], nums2 = [5], queries = [[2,0,0],[3,0,0]]\n<b>输出：</b>[5]\n<b>解释：</b>第一个操作后，nums2 保持不变为 [5] ，所以第二个操作的答案是 5 。所以返回 [5] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length,nums2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums1.length = nums2.length</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length = 3</code></li>\n\t<li><code>0 &lt;= l &lt;= r &lt;= nums1.length - 1</code></li>\n\t<li><code>0 &lt;= p &lt;= 10<sup>6</sup></code></li>\n\t<li><code>0 &lt;= nums1[i] &lt;= 1</code></li>\n\t<li><code>0 &lt;= nums2[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2570合并两个二维数组 - 求和法",
        "hardRate": "EASY",
        "passRate": "69.56%",
        "problemsUrl": "https://leetcode.cn/problems/merge-two-2d-arrays-by-summing-values/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-two-2d-arrays-by-summing-values/solution",
        "problemsDesc": "<p>给你两个 <strong>二维</strong> 整数数组 <code>nums1</code> 和 <code>nums2.</code></p>\n\n<ul>\n\t<li><code>nums1[i] = [id<sub>i</sub>, val<sub>i</sub>]</code> 表示编号为 <code>id<sub>i</sub></code> 的数字对应的值等于 <code>val<sub>i</sub></code> 。</li>\n\t<li><code>nums2[i] = [id<sub>i</sub>, val<sub>i</sub>]</code>&nbsp;表示编号为 <code>id<sub>i</sub></code> 的数字对应的值等于 <code>val<sub>i</sub></code> 。</li>\n</ul>\n\n<p>每个数组都包含 <strong>互不相同</strong> 的 id ，并按 id 以 <strong>递增</strong> 顺序排列。</p>\n\n<p>请你将两个数组合并为一个按 id 以递增顺序排列的数组，并符合下述条件：</p>\n\n<ul>\n\t<li>只有在两个数组中至少出现过一次的 id 才能包含在结果数组内。</li>\n\t<li>每个 id 在结果数组中 <strong>只能出现一次</strong> ，并且其对应的值等于两个数组中该 id 所对应的值求和。如果某个数组中不存在该 id ，则认为其对应的值等于 <code>0</code> 。</li>\n</ul>\n\n<p>返回结果数组。返回的数组需要按 id 以递增顺序排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]]\n<strong>输出：</strong>[[1,6],[2,3],[3,2],[4,6]]\n<strong>解释：</strong>结果数组中包含以下元素：\n- id = 1 ，对应的值等于 2 + 4 = 6 。\n- id = 2 ，对应的值等于 3 。\n- id = 3 ，对应的值等于 2 。\n- id = 4 ，对应的值等于5 + 1 = 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]]\n<strong>输出：</strong>[[1,3],[2,4],[3,6],[4,3],[5,5]]\n<strong>解释：</strong>不存在共同 id ，在结果数组中只需要包含每个 id 和其对应的值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 200</code></li>\n\t<li><code>nums1[i].length == nums2[j].length == 2</code></li>\n\t<li><code>1 &lt;= id<sub>i</sub>, val<sub>i</sub> &lt;= 1000</code></li>\n\t<li>数组中的 id 互不相同</li>\n\t<li>数据均按 id 以严格递增顺序排列</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2571将整数减少到零需要的最少操作数",
        "hardRate": "MEDIUM",
        "passRate": "53.99%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-reduce-an-integer-to-0/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-reduce-an-integer-to-0/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> ，你可以执行下述操作 <strong>任意</strong> 次：</p>\n\n<ul>\n\t<li><code>n</code> 加上或减去 <code>2</code> 的某个 <strong>幂</strong></li>\n</ul>\n\n<p>返回使 <code>n</code> 等于 <code>0</code> 需要执行的 <strong>最少</strong> 操作数。</p>\n\n<p>如果 <code>x == 2<sup>i</sup></code> 且其中 <code>i &gt;= 0</code> ，则数字 <code>x</code> 是 <code>2</code> 的幂。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 39\n<strong>输出：</strong>3\n<strong>解释：</strong>我们可以执行下述操作：\n- n 加上 2<sup>0</sup> = 1 ，得到 n = 40 。\n- n 减去 2<sup>3</sup> = 8 ，得到 n = 32 。\n- n 减去 2<sup>5</sup> = 32 ，得到 n = 0 。\n可以证明使 n 等于 0 需要执行的最少操作数是 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 54\n<strong>输出：</strong>3\n<strong>解释：</strong>我们可以执行下述操作：\n- n 加上 2<sup>1</sup> = 2 ，得到 n = 56 。\n- n 加上 2<sup>3</sup> = 8 ，得到 n = 64 。\n- n 减去 2<sup>6</sup> = 64 ，得到 n = 0 。\n使 n 等于 0 需要执行的最少操作数是 3 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2572无平方子集计数",
        "hardRate": "MEDIUM",
        "passRate": "29.82%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-square-free-subsets/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-square-free-subsets/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>nums</code> 。</p>\n\n<p>如果数组 <code>nums</code> 的子集中的元素乘积是一个 <strong>无平方因子数</strong> ，则认为该子集是一个 <strong>无平方</strong> 子集。</p>\n\n<p><strong>无平方因子数</strong> 是无法被除 <code>1</code> 之外任何平方数整除的数字。</p>\n\n<p>返回数组 <code>nums</code> 中 <strong>无平方</strong> 且 <strong>非空</strong> 的子集数目。因为答案可能很大，返回对 <code>10<sup>9</sup> + 7</code> 取余的结果。</p>\n\n<p><code>nums</code> 的 <strong>非空子集</strong> 是可以由删除 <code>nums</code> 中一些元素（可以不删除，但不能全部删除）得到的一个数组。如果构成两个子集时选择删除的下标不同，则认为这两个子集不同。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,4,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>示例中有 3 个无平方子集：\n- 由第 0 个元素 [3] 组成的子集。其元素的乘积是 3 ，这是一个无平方因子数。\n- 由第 3 个元素 [5] 组成的子集。其元素的乘积是 5 ，这是一个无平方因子数。\n- 由第 0 个和第 3 个元素 [3,5] 组成的子集。其元素的乘积是 15 ，这是一个无平方因子数。\n可以证明给定数组中不存在超过 3 个无平方子集。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1]\n<strong>输出：</strong>1\n<strong>解释：</strong>示例中有 1 个无平方子集：\n- 由第 0 个元素 [1] 组成的子集。其元素的乘积是 1 ，这是一个无平方因子数。\n可以证明给定数组中不存在超过 1 个无平方子集。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length&nbsp;&lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 30</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2573找出对应 LCP 矩阵的字符串",
        "hardRate": "HARD",
        "passRate": "35.41%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-string-with-lcp/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-string-with-lcp/solution",
        "problemsDesc": "<p>对任一由 <code>n</code> 个小写英文字母组成的字符串 <code>word</code> ，我们可以定义一个 <code>n x n</code> 的矩阵，并满足：</p>\n\n<ul>\n\t<li><code>lcp[i][j]</code> 等于子字符串&nbsp;<code>word[i,...,n-1]</code> 和 <code>word[j,...,n-1]</code> 之间的最长公共前缀的长度。</li>\n</ul>\n\n<p>给你一个 <code>n x n</code> 的矩阵 <code>lcp</code> 。返回与 <code>lcp</code> 对应的、按字典序最小的字符串&nbsp;<code>word</code> 。如果不存在这样的字符串，则返回空字符串。</p>\n\n<p>对于长度相同的两个字符串 <code>a</code> 和 <code>b</code> ，如果在 <code>a</code> 和 <code>b</code> 不同的第一个位置，字符串 <code>a</code> 的字母在字母表中出现的顺序先于 <code>b</code> 中的对应字母，则认为字符串 <code>a</code> 按字典序比字符串 <code>b</code> 小。例如，<code>\"aabd\"</code> 在字典上小于 <code>\"aaca\"</code> ，因为二者不同的第一位置是第三个字母，而&nbsp;<code>'b'</code> 先于 <code>'c'</code> 出现。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\n<strong>输出：</strong>\"abab\"\n<strong>解释：</strong>lcp 对应由两个交替字母组成的任意 4 字母字符串，字典序最小的是 \"abab\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\n<strong>输出：</strong>\"aaaa\"\n<strong>解释：</strong>lcp 对应只有一个不同字母的任意 4 字母字符串，字典序最小的是 \"aaaa\" 。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>lcp[3][3] 无法等于 3 ，因为 word[3,...,3] 仅由单个字母组成；因此，不存在答案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n ==&nbsp;</code><code>lcp.length == </code><code>lcp[i].length</code>&nbsp;<code>&lt;= 1000</code></li>\n\t<li><code><font face=\"monospace\">0 &lt;= lcp[i][j] &lt;= n</font></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2574左右元素和的差值",
        "hardRate": "EASY",
        "passRate": "84.97%",
        "problemsUrl": "https://leetcode.cn/problems/left-and-right-sum-differences/",
        "solutionsUrl": "https://leetcode.cn/problems/left-and-right-sum-differences/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，请你找出一个下标从 <strong>0</strong> 开始的整数数组 <code>answer</code> ，其中：</p>\n\n<ul>\n\t<li><code>answer.length == nums.length</code></li>\n\t<li><code>answer[i] = |leftSum[i] - rightSum[i]|</code></li>\n</ul>\n\n<p>其中：</p>\n\n<ul>\n\t<li><code>leftSum[i]</code> 是数组 <code>nums</code> 中下标 <code>i</code> 左侧元素之和。如果不存在对应的元素，<code>leftSum[i] = 0</code> 。</li>\n\t<li><code>rightSum[i]</code> 是数组 <code>nums</code> 中下标 <code>i</code> 右侧元素之和。如果不存在对应的元素，<code>rightSum[i] = 0</code> 。</li>\n</ul>\n\n<p>返回数组 <code>answer</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [10,4,8,3]\n<strong>输出：</strong>[15,1,11,22]\n<strong>解释：</strong>数组 leftSum 为 [0,10,14,22] 且数组 rightSum 为 [15,11,3,0] 。\n数组 answer 为 [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] = [15,1,11,22] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1]\n<strong>输出：</strong>[0]\n<strong>解释：</strong>数组 leftSum 为 [0] 且数组 rightSum 为 [0] 。\n数组 answer 为 [|0 - 0|] = [0] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2575找出字符串的可整除数组",
        "hardRate": "MEDIUM",
        "passRate": "32.84%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>word</code> ，长度为 <code>n</code> ，由从 <code>0</code> 到 <code>9</code> 的数字组成。另给你一个正整数 <code>m</code> 。</p>\n\n<p><code>word</code> 的 <strong>可整除数组</strong> <code>div</code>&nbsp; 是一个长度为 <code>n</code> 的整数数组，并满足：</p>\n\n<ul>\n\t<li>如果 <code>word[0,...,i]</code> 所表示的 <strong>数值</strong> 能被 <code>m</code> 整除，<code>div[i] = 1</code></li>\n\t<li>否则，<code>div[i] = 0</code></li>\n</ul>\n\n<p>返回<em> </em><code>word</code> 的可整除数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"998244353\", m = 3\n<strong>输出：</strong>[1,1,0,0,0,1,1,0,0]\n<strong>解释：</strong>仅有 4 个前缀可以被 3 整除：\"9\"、\"99\"、\"998244\" 和 \"9982443\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"1010\", m = 10\n<strong>输出：</strong>[0,1,0,1]\n<strong>解释：</strong>仅有 2 个前缀可以被 10 整除：\"10\" 和 \"1010\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>word.length == n</code></li>\n\t<li><code>word</code> 由数字 <code>0</code> 到 <code>9</code> 组成</li>\n\t<li><code>1 &lt;= m &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2576求出最多标记下标",
        "hardRate": "MEDIUM",
        "passRate": "36.89%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>一开始，所有下标都没有被标记。你可以执行以下操作任意次：</p>\n\n<ul>\n\t<li>选择两个 <strong>互不相同且未标记</strong>&nbsp;的下标&nbsp;<code>i</code> 和&nbsp;<code>j</code>&nbsp;，满足&nbsp;<code>2 * nums[i] &lt;= nums[j]</code>&nbsp;，标记下标&nbsp;<code>i</code> 和&nbsp;<code>j</code>&nbsp;。</li>\n</ul>\n\n<p>请你执行上述操作任意次，返回<em>&nbsp;</em><code>nums</code>&nbsp;中最多可以标记的下标数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,5,2,4]\n<b>输出：</b>2\n<strong>解释：</strong>第一次操作中，选择 i = 2 和 j = 1 ，操作可以执行的原因是 2 * nums[2] &lt;= nums[1] ，标记下标 2 和 1 。\n没有其他更多可执行的操作，所以答案为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [9,2,5,4]\n<b>输出：</b>4\n<strong>解释：</strong>第一次操作中，选择 i = 3 和 j = 0 ，操作可以执行的原因是 2 * nums[3] &lt;= nums[0] ，标记下标 3 和 0 。\n第二次操作中，选择 i = 1 和 j = 2 ，操作可以执行的原因是 2 * nums[1] &lt;= nums[2] ，标记下标 1 和 2 。\n没有其他更多可执行的操作，所以答案为 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [7,6,8]\n<b>输出：</b>0\n<strong>解释：</strong>没有任何可以执行的操作，所以答案为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2577在网格图中访问一个格子的最少时间",
        "hardRate": "HARD",
        "passRate": "39.47%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的矩阵&nbsp;<code>grid</code>&nbsp;，每个元素都为 <strong>非负</strong>&nbsp;整数，其中&nbsp;<code>grid[row][col]</code>&nbsp;表示可以访问格子&nbsp;<code>(row, col)</code>&nbsp;的&nbsp;<strong>最早</strong>&nbsp;时间。也就是说当你访问格子&nbsp;<code>(row, col)</code>&nbsp;时，最少已经经过的时间为&nbsp;<code>grid[row][col]</code>&nbsp;。</p>\n\n<p>你从 <strong>最左上角</strong>&nbsp;出发，出发时刻为 <code>0</code>&nbsp;，你必须一直移动到上下左右相邻四个格子中的 <strong>任意</strong>&nbsp;一个格子（即不能停留在格子上）。每次移动都需要花费 1 单位时间。</p>\n\n<p>请你返回 <strong>最早</strong>&nbsp;到达右下角格子的时间，如果你无法到达右下角的格子，请你返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-8.png\" /></p>\n\n<pre>\n<b>输入：</b>grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]\n<b>输出：</b>7\n<b>解释：</b>一条可行的路径为：\n- 时刻 t = 0 ，我们在格子 (0,0) 。\n- 时刻 t = 1 ，我们移动到格子 (0,1) ，可以移动的原因是 grid[0][1] &lt;= 1 。\n- 时刻 t = 2 ，我们移动到格子 (1,1) ，可以移动的原因是 grid[1][1] &lt;= 2 。\n- 时刻 t = 3 ，我们移动到格子 (1,2) ，可以移动的原因是 grid[1][2] &lt;= 3 。\n- 时刻 t = 4 ，我们移动到格子 (1,1) ，可以移动的原因是 grid[1][1] &lt;= 4 。\n- 时刻 t = 5 ，我们移动到格子 (1,2) ，可以移动的原因是 grid[1][2] &lt;= 5 。\n- 时刻 t = 6 ，我们移动到格子 (1,3) ，可以移动的原因是 grid[1][3] &lt;= 6 。\n- 时刻 t = 7 ，我们移动到格子 (2,3) ，可以移动的原因是 grid[2][3] &lt;= 7 。\n最终到达时刻为 7 。这是最早可以到达的时间。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-9.png\" style=\"width: 151px; height: 151px;\" /></p>\n\n<pre>\n<b>输入：</b>grid = [[0,2,4],[3,2,1],[1,0,4]]\n<b>输出：</b>-1\n<b>解释：</b>没法从左上角按题目规定走到右下角。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>grid[0][0] == 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2578最小和分割",
        "hardRate": "EASY",
        "passRate": "76.38%",
        "problemsUrl": "https://leetcode.cn/problems/split-with-minimum-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/split-with-minimum-sum/solution",
        "problemsDesc": "<p>给你一个正整数&nbsp;<code>num</code>&nbsp;，请你将它分割成两个非负整数&nbsp;<code>num1</code> 和&nbsp;<code>num2</code>&nbsp;，满足：</p>\n\n<ul>\n\t<li><code>num1</code> 和&nbsp;<code>num2</code>&nbsp;直接连起来，得到&nbsp;<code>num</code>&nbsp;各数位的一个排列。\n\n\t<ul>\n\t\t<li>换句话说，<code>num1</code> 和&nbsp;<code>num2</code>&nbsp;中所有数字出现的次数之和等于&nbsp;<code>num</code>&nbsp;中所有数字出现的次数。</li>\n\t</ul>\n\t</li>\n\t<li><code>num1</code> 和&nbsp;<code>num2</code>&nbsp;可以包含前导 0 。</li>\n</ul>\n\n<p>请你返回&nbsp;<code>num1</code> 和 <code>num2</code>&nbsp;可以得到的和的 <strong>最小</strong> 值。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><code>num</code>&nbsp;保证没有前导 0 。</li>\n\t<li><code>num1</code> 和&nbsp;<code>num2</code>&nbsp;中数位顺序可以与&nbsp;<code>num</code>&nbsp;中数位顺序不同。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>num = 4325\n<b>输出：</b>59\n<b>解释：</b>我们可以将 4325 分割成 <code>num1 </code>= 24 和 num2<code> = </code>35 ，和为 59 ，59 是最小和。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>num = 687\n<b>输出：</b>75\n<b>解释：</b>我们可以将 687 分割成 <code>num1</code> = 68 和 <code>num2 </code>= 7 ，和为最优值 75 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>10 &lt;= num &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2579统计染色格子数",
        "hardRate": "MEDIUM",
        "passRate": "66.40%",
        "problemsUrl": "https://leetcode.cn/problems/count-total-number-of-colored-cells/",
        "solutionsUrl": "https://leetcode.cn/problems/count-total-number-of-colored-cells/solution",
        "problemsDesc": "<p>有一个无穷大的二维网格图，一开始所有格子都未染色。给你一个正整数&nbsp;<code>n</code>&nbsp;，表示你需要执行以下步骤&nbsp;<code>n</code>&nbsp;分钟：</p>\n\n<ul>\n\t<li>第一分钟，将 <strong>任一</strong> 格子染成蓝色。</li>\n\t<li>之后的每一分钟，将与蓝色格子相邻的 <strong>所有</strong> 未染色格子染成蓝色。</li>\n</ul>\n\n<p>下图分别是 1、2、3 分钟后的网格图。</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/10/example-copy-2.png\" style=\"width: 500px; height: 279px;\">\n<p>请你返回 <code>n</code>&nbsp;分钟之后 <strong>被染色的格子&nbsp;</strong>数目。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre><b>输入：</b>n = 1\n<b>输出：</b>1\n<b>解释：</b>1 分钟后，只有 1 个蓝色的格子，所以返回 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 2\n<b>输出：</b>5\n<b>解释：</b>2 分钟后，有 4 个在边缘的蓝色格子和 1 个在中间的蓝色格子，所以返回 5 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2580统计将重叠区间合并成组的方案数",
        "hardRate": "MEDIUM",
        "passRate": "35.48%",
        "problemsUrl": "https://leetcode.cn/problems/count-ways-to-group-overlapping-ranges/",
        "solutionsUrl": "https://leetcode.cn/problems/count-ways-to-group-overlapping-ranges/solution",
        "problemsDesc": "<p>给你一个二维整数数组&nbsp;<code>ranges</code>&nbsp;，其中&nbsp;<code>ranges[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>&nbsp;表示&nbsp;<code>start<sub>i</sub></code>&nbsp;到&nbsp;<code>end<sub>i</sub></code>&nbsp;之间（包括二者）的所有整数都包含在第&nbsp;<code>i</code>&nbsp;个区间中。</p>\n\n<p>你需要将&nbsp;<code>ranges</code>&nbsp;分成 <strong>两个</strong>&nbsp;组（可以为空），满足：</p>\n\n<ul>\n\t<li>每个区间只属于一个组。</li>\n\t<li>两个有 <strong>交集</strong>&nbsp;的区间必须在 <strong>同一个&nbsp;</strong>组内。</li>\n</ul>\n\n<p>如果两个区间有至少 <strong>一个</strong>&nbsp;公共整数，那么这两个区间是 <b>有交集</b>&nbsp;的。</p>\n\n<ul>\n\t<li>比方说，区间&nbsp;<code>[1, 3]</code> 和&nbsp;<code>[2, 5]</code>&nbsp;有交集，因为&nbsp;<code>2</code>&nbsp;和&nbsp;<code>3</code>&nbsp;在两个区间中都被包含。</li>\n</ul>\n\n<p>请你返回将 <code>ranges</code>&nbsp;划分成两个组的 <strong>总方案数</strong>&nbsp;。由于答案可能很大，将它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>ranges = [[6,10],[5,15]]\n<b>输出：</b>2\n<b>解释：</b>\n两个区间有交集，所以它们必须在同一个组内。\n所以有两种方案：\n- 将两个区间都放在第 1 个组中。\n- 将两个区间都放在第 2 个组中。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>ranges = [[1,3],[10,20],[2,5],[4,8]]\n<b>输出：</b>4\n<b>解释：</b>\n区间 [1,3] 和 [2,5] 有交集，所以它们必须在同一个组中。\n同理，区间 [2,5] 和 [4,8] 也有交集，所以它们也必须在同一个组中。\n所以总共有 4 种分组方案：\n- 所有区间都在第 1 组。\n- 所有区间都在第 2 组。\n- 区间 [1,3] ，[2,5] 和 [4,8] 在第 1 个组中，[10,20] 在第 2 个组中。\n- 区间 [1,3] ，[2,5] 和 [4,8] 在第 2 个组中，[10,20] 在第 1 个组中。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= ranges.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>ranges[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2581统计可能的树根数目",
        "hardRate": "HARD",
        "passRate": "57.75%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-possible-root-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-possible-root-nodes/solution",
        "problemsDesc": "<p>Alice 有一棵 <code>n</code> 个节点的树，节点编号为 <code>0</code> 到 <code>n - 1</code> 。树用一个长度为 <code>n - 1</code> 的二维整数数组 <code>edges</code> 表示，其中 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> ，表示树中节点 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间有一条边。</p>\n\n<p>Alice 想要 Bob 找到这棵树的根。她允许 Bob 对这棵树进行若干次 <strong>猜测</strong> 。每一次猜测，Bob 做如下事情：</p>\n\n<ul>\n\t<li>选择两个 <strong>不相等</strong>&nbsp;的整数&nbsp;<code>u</code> 和&nbsp;<code>v</code>&nbsp;，且树中必须存在边&nbsp;<code>[u, v]</code>&nbsp;。</li>\n\t<li>Bob 猜测树中&nbsp;<code>u</code>&nbsp;是&nbsp;<code>v</code>&nbsp;的 <strong>父节点</strong>&nbsp;。</li>\n</ul>\n\n<p>Bob 的猜测用二维整数数组&nbsp;<code>guesses</code> 表示，其中&nbsp;<code>guesses[j] = [u<sub>j</sub>, v<sub>j</sub>]</code>&nbsp;表示 Bob 猜&nbsp;<code>u<sub>j</sub></code> 是&nbsp;<code>v<sub>j</sub></code>&nbsp;的父节点。</p>\n\n<p>Alice 非常懒，她不想逐个回答&nbsp;Bob 的猜测，只告诉 Bob 这些猜测里面 <strong>至少</strong>&nbsp;有&nbsp;<code>k</code>&nbsp;个猜测的结果为&nbsp;<code>true</code>&nbsp;。</p>\n\n<p>给你二维整数数组 <code>edges</code>&nbsp;，Bob 的所有猜测和整数&nbsp;<code>k</code>&nbsp;，请你返回可能成为树根的&nbsp;<strong>节点数目</strong>&nbsp;。如果没有这样的树，则返回 <code>0</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/19/ex-1.png\" style=\"width: 727px; height: 250px;\" /></p>\n\n<pre>\n<b>输入：</b>edges = [[0,1],[1,2],[1,3],[4,2]], guesses = [[1,3],[0,1],[1,0],[2,4]], k = 3\n<b>输出：</b>3\n<b>解释：</b>\n根为节点 0 ，正确的猜测为 [1,3], [0,1], [2,4]\n根为节点 1 ，正确的猜测为 [1,3], [1,0], [2,4]\n根为节点 2 ，正确的猜测为 [1,3], [1,0], [2,4]\n根为节点 3 ，正确的猜测为 [1,0], [2,4]\n根为节点 4 ，正确的猜测为 [1,3], [1,0]\n节点 0 ，1 或 2 为根时，可以得到 3 个正确的猜测。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/19/ex-2.png\" style=\"width: 600px; height: 303px;\" /></p>\n\n<pre>\n<b>输入：</b>edges = [[0,1],[1,2],[2,3],[3,4]], guesses = [[1,0],[3,4],[2,1],[3,2]], k = 1\n<b>输出：</b>5\n<b>解释：</b>\n根为节点 0 ，正确的猜测为 [3,4]\n根为节点 1 ，正确的猜测为 [1,0], [3,4]\n根为节点 2 ，正确的猜测为 [1,0], [2,1], [3,4]\n根为节点 3 ，正确的猜测为 [1,0], [2,1], [3,2], [3,4]\n根为节点 4 ，正确的猜测为 [1,0], [2,1], [3,2]\n任何节点为根，都至少有 1 个正确的猜测。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= guesses.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub>, u<sub>j</sub>, v<sub>j</sub> &lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>u<sub>j</sub> != v<sub>j</sub></code></li>\n\t<li><code>edges</code>&nbsp;表示一棵有效的树。</li>\n\t<li><code>guesses[j]</code>&nbsp;是树中的一条边。</li>\n\t<li><code>guesses</code>&nbsp;是唯一的。</li>\n\t<li><code>0 &lt;= k &lt;= guesses.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2582递枕头",
        "hardRate": "EASY",
        "passRate": "55.91%",
        "problemsUrl": "https://leetcode.cn/problems/pass-the-pillow/",
        "solutionsUrl": "https://leetcode.cn/problems/pass-the-pillow/solution",
        "problemsDesc": "<p><code>n</code> 个人站成一排，按从 <code>1</code> 到 <code>n</code> 编号。</p>\n\n<p>最初，排在队首的第一个人拿着一个枕头。每秒钟，拿着枕头的人会将枕头传递给队伍中的下一个人。一旦枕头到达队首或队尾，传递方向就会改变，队伍会继续沿相反方向传递枕头。</p>\n\n<ul>\n\t<li>例如，当枕头到达第 <code>n</code> 个人时，TA 会将枕头传递给第 <code>n - 1</code> 个人，然后传递给第 <code>n - 2</code> 个人，依此类推。</li>\n</ul>\n\n<p>给你两个正整数 <code>n</code> 和 <code>time</code> ，返回 <code>time</code> 秒后拿着枕头的人的编号。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, time = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>队伍中枕头的传递情况为：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 3 -&gt; 2 。\n5 秒后，枕头传递到第 2 个人手中。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, time = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>队伍中枕头的传递情况为：1 -&gt; 2 -&gt; 3 。\n2 秒后，枕头传递到第 3 个人手中。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= time &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2583二叉树中的第 K 大层和",
        "hardRate": "MEDIUM",
        "passRate": "43.95%",
        "problemsUrl": "https://leetcode.cn/problems/kth-largest-sum-in-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-largest-sum-in-a-binary-tree/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点 <code>root</code> 和一个正整数 <code>k</code> 。</p>\n\n<p>树中的 <strong>层和</strong> 是指 <strong>同一层</strong> 上节点值的总和。</p>\n\n<p>返回树中第 <code>k</code> 大的层和（不一定不同）。如果树少于 <code>k</code> 层，则返回 <code>-1</code> 。</p>\n\n<p><strong>注意</strong>，如果两个节点与根节点的距离相同，则认为它们在同一层。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/14/binaryytreeedrawio-2.png\" style=\"width: 301px; height: 284px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,8,9,2,1,3,7,4,6], k = 2\n<strong>输出：</strong>13\n<strong>解释：</strong>树中每一层的层和分别是：\n- Level 1: 5\n- Level 2: 8 + 9 = 17\n- Level 3: 2 + 1 + 3 + 7 = 13\n- Level 4: 4 + 6 = 10\n第 2 大的层和等于 13 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/14/treedrawio-3.png\" style=\"width: 181px; height: 181px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,null,3], k = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>最大的层和是 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数为 <code>n</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2584分割数组使乘积互质",
        "hardRate": "HARD",
        "passRate": "25.40%",
        "problemsUrl": "https://leetcode.cn/problems/split-the-array-to-make-coprime-products/",
        "solutionsUrl": "https://leetcode.cn/problems/split-the-array-to-make-coprime-products/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，下标从 <strong>0</strong> 开始。</p>\n\n<p>如果在下标 <code>i</code> 处 <strong>分割</strong> 数组，其中 <code>0 &lt;= i &lt;= n - 2</code> ，使前 <code>i + 1</code> 个元素的乘积和剩余元素的乘积互质，则认为该分割 <strong>有效</strong> 。</p>\n\n<ul>\n\t<li>例如，如果 <code>nums = [2, 3, 3]</code> ，那么在下标 <code>i = 0</code> 处的分割有效，因为 <code>2</code> 和 <code>9</code> 互质，而在下标 <code>i = 1</code> 处的分割无效，因为 <code>6</code> 和 <code>3</code> 不互质。在下标 <code>i = 2</code> 处的分割也无效，因为 <code>i == n - 1</code> 。</li>\n</ul>\n\n<p>返回可以有效分割数组的最小下标 <code>i</code> ，如果不存在有效分割，则返回 <code>-1</code> 。</p>\n\n<p>当且仅当 <code>gcd(val1, val2) == 1</code> 成立时，<code>val1</code> 和 <code>val2</code> 这两个值才是互质的，其中 <code>gcd(val1, val2)</code> 表示 <code>val1</code> 和 <code>val2</code> 的最大公约数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/14/second.PNG\" style=\"width: 450px; height: 211px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,7,8,15,3,5]\n<strong>输出：</strong>2\n<strong>解释：</strong>上表展示了每个下标 i 处的前 i + 1 个元素的乘积、剩余元素的乘积和它们的最大公约数的值。\n唯一一个有效分割位于下标 2 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/14/capture.PNG\" style=\"width: 450px; height: 215px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,7,15,8,3,5]\n<strong>输出：</strong>-1\n<strong>解释：</strong>上表展示了每个下标 i 处的前 i + 1 个元素的乘积、剩余元素的乘积和它们的最大公约数的值。\n不存在有效分割。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2585获得分数的方法数",
        "hardRate": "HARD",
        "passRate": "64.48%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-earn-points/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-earn-points/solution",
        "problemsDesc": "<p>考试中有 <code>n</code> 种类型的题目。给你一个整数 <code>target</code> 和一个下标从 <strong>0</strong> 开始的二维整数数组 <code>types</code> ，其中 <code>types[i] = [count<sub>i</sub>, marks<sub>i</sub>] </code>表示第 <code>i</code> 种类型的题目有 <code>count<sub>i</sub></code> 道，每道题目对应 <code>marks<sub>i</sub></code> 分。</p>\n\n<p>返回你在考试中恰好得到 <code>target</code> 分的方法数。由于答案可能很大，结果需要对 <code>10<sup>9</sup> +7</code> 取余。</p>\n\n<p><strong>注意</strong>，同类型题目无法区分。</p>\n\n<ul>\n\t<li>比如说，如果有 <code>3</code> 道同类型题目，那么解答第 <code>1</code> 和第 <code>2</code> 道题目与解答第 <code>1</code> 和第 <code>3</code> 道题目或者第 <code>2</code> 和第 <code>3</code> 道题目是相同的。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>target = 6, types = [[6,1],[3,2],[2,3]]\n<strong>输出：</strong>7\n<strong>解释：</strong>要获得 6 分，你可以选择以下七种方法之一：\n- 解决 6 道第 0 种类型的题目：1 + 1 + 1 + 1 + 1 + 1 = 6\n- 解决 4 道第 0 种类型的题目和 1 道第 1 种类型的题目：1 + 1 + 1 + 1 + 2 = 6\n- 解决 2 道第 0 种类型的题目和 2 道第 1 种类型的题目：1 + 1 + 2 + 2 = 6\n- 解决 3 道第 0 种类型的题目和 1 道第 2 种类型的题目：1 + 1 + 1 + 3 = 6\n- 解决 1 道第 0 种类型的题目、1 道第 1 种类型的题目和 1 道第 2 种类型的题目：1 + 2 + 3 = 6\n- 解决 3 道第 1 种类型的题目：2 + 2 + 2 = 6\n- 解决 2 道第 2 种类型的题目：3 + 3 = 6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>target = 5, types = [[50,1],[50,2],[50,5]]\n<strong>输出：</strong>4\n<strong>解释：</strong>要获得 5 分，你可以选择以下四种方法之一：\n- 解决 5 道第 0 种类型的题目：1 + 1 + 1 + 1 + 1 = 5\n- 解决 3 道第 0 种类型的题目和 1 道第 1 种类型的题目：1 + 1 + 1 + 2 = 5\n- 解决 1 道第 0 种类型的题目和 2 道第 1 种类型的题目：1 + 2 + 2 = 5\n- 解决 1 道第 2 种类型的题目：5\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>target = 18, types = [[6,1],[3,2],[2,3]]\n<strong>输出：</strong>1\n<strong>解释：</strong>只有回答所有题目才能获得 18 分。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target &lt;= 1000</code></li>\n\t<li><code>n == types.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>types[i].length == 2</code></li>\n\t<li><code>1 &lt;= count<sub>i</sub>, marks<sub>i</sub> &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2586统计范围内的元音字符串数",
        "hardRate": "EASY",
        "passRate": "81.49%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-vowel-strings-in-range/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-vowel-strings-in-range/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串数组 <code>words</code> 和两个整数：<code>left</code> 和 <code>right</code> 。</p>\n\n<p>如果字符串以元音字母开头并以元音字母结尾，那么该字符串就是一个 <strong>元音字符串</strong> ，其中元音字母是 <code>'a'</code>、<code>'e'</code>、<code>'i'</code>、<code>'o'</code>、<code>'u'</code> 。</p>\n\n<p>返回<em> </em><code>words[i]</code> 是元音字符串的数目，其中<em> </em><code>i</code> 在闭区间 <code>[left, right]</code> 内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"are\",\"amy\",\"u\"], left = 0, right = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>\n- \"are\" 是一个元音字符串，因为它以 'a' 开头并以 'e' 结尾。\n- \"amy\" 不是元音字符串，因为它没有以元音字母结尾。\n- \"u\" 是一个元音字符串，因为它以 'u' 开头并以 'u' 结尾。\n在上述范围中的元音字符串数目为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"hey\",\"aeo\",\"mu\",\"ooo\",\"artro\"], left = 1, right = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>\n- \"aeo\" 是一个元音字符串，因为它以 'a' 开头并以 'o' 结尾。\n- \"mu\" 不是元音字符串，因为它没有以元音字母开头。\n- \"ooo\" 是一个元音字符串，因为它以 'o' 开头并以 'o' 结尾。\n- \"artro\" 是一个元音字符串，因为它以 'a' 开头并以 'o' 结尾。\n在上述范围中的元音字符串数目为 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>words[i]</code> 仅由小写英文字母组成</li>\n\t<li><code>0 &lt;= left &lt;= right &lt; words.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2587重排数组以得到最大前缀分数",
        "hardRate": "MEDIUM",
        "passRate": "40.61%",
        "problemsUrl": "https://leetcode.cn/problems/rearrange-array-to-maximize-prefix-score/",
        "solutionsUrl": "https://leetcode.cn/problems/rearrange-array-to-maximize-prefix-score/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。你可以将 <code>nums</code> 中的元素按 <strong>任意顺序</strong> 重排（包括给定顺序）。</p>\n\n<p>令 <code>prefix</code> 为一个数组，它包含了 <code>nums</code> 重新排列后的前缀和。换句话说，<code>prefix[i]</code> 是 <code>nums</code> 重新排列后下标从 <code>0</code> 到 <code>i</code> 的元素之和。<code>nums</code> 的 <strong>分数</strong> 是 <code>prefix</code> 数组中正整数的个数。</p>\n\n<p>返回可以得到的最大分数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,-1,0,1,-3,3,-3]\n<strong>输出：</strong>6\n<strong>解释：</strong>数组重排为 nums = [2,3,1,-1,-3,0,-3] 。\nprefix = [2,5,6,5,2,2,-1] ，分数为 6 。\n可以证明 6 是能够得到的最大分数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [-2,-3,0]\n<strong>输出：</strong>0\n<strong>解释：</strong>不管怎么重排数组得到的分数都是 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>6</sup> &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2588统计美丽子数组数目",
        "hardRate": "MEDIUM",
        "passRate": "41.98%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组<code>nums</code>&nbsp;。每次操作中，你可以：</p>\n\n<ul>\n\t<li>选择两个满足&nbsp;<code>0 &lt;= i, j &lt; nums.length</code>&nbsp;的不同下标&nbsp;<code>i</code>&nbsp;和&nbsp;<code>j</code>&nbsp;。</li>\n\t<li>选择一个非负整数&nbsp;<code>k</code>&nbsp;，满足 <code>nums[i]</code>&nbsp;和 <code>nums[j]</code>&nbsp;在二进制下的第 <code>k</code>&nbsp;位（下标编号从 <strong>0</strong>&nbsp;开始）是 <code>1</code>&nbsp;。</li>\n\t<li>将 <code>nums[i]</code>&nbsp;和 <code>nums[j]</code>&nbsp;都减去&nbsp;<code>2<sup>k</sup></code>&nbsp;。</li>\n</ul>\n\n<p>如果一个子数组内执行上述操作若干次后，该子数组可以变成一个全为 <code>0</code>&nbsp;的数组，那么我们称它是一个 <strong>美丽</strong>&nbsp;的子数组。</p>\n\n<p>请你返回数组 <code>nums</code>&nbsp;中 <strong>美丽子数组</strong>&nbsp;的数目。</p>\n\n<p>子数组是一个数组中一段连续 <strong>非空</strong>&nbsp;的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [4,3,1,2,4]\n<b>输出：</b>2\n<b>解释：</b>nums 中有 2 个美丽子数组：[4,<em><strong>3,1,2</strong></em>,4] 和 [<em><strong>4,3,1,2,4</strong></em>] 。\n- 按照下述步骤，我们可以将子数组 [3,1,2] 中所有元素变成 0 ：\n  - 选择 [<em><strong>3</strong></em>, 1, <em><strong>2</strong></em>] 和 k = 1 。将 2 个数字都减去 2<sup>1</sup> ，子数组变成 [1, 1, 0] 。\n  - 选择 [<em><strong>1</strong></em>, <em><strong>1</strong></em>, 0] 和 k = 0 。将 2 个数字都减去 2<sup>0</sup> ，子数组变成 [0, 0, 0] 。\n- 按照下述步骤，我们可以将子数组 [4,3,1,2,4] 中所有元素变成 0 ：\n  - 选择 [<em><strong>4</strong></em>, 3, 1, 2, <em><strong>4</strong></em>] 和 k = 2 。将 2 个数字都减去 2<sup>2</sup> ，子数组变成 [0, 3, 1, 2, 0] 。\n  - 选择 [0, <em><strong>3</strong></em>, <em><strong>1</strong></em>, 2, 0] 和 k = 0 。将 2 个数字都减去 2<sup>0</sup> ，子数组变成 [0, 2, 0, 2, 0] 。\n  - 选择 [0, <em><strong>2</strong></em>, 0, <em><strong>2</strong></em>, 0] 和 k = 1 。将 2 个数字都减去 2<sup>1</sup> ，子数组变成 [0, 0, 0, 0, 0] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,10,4]\n<b>输出：</b>0\n<b>解释：</b>nums 中没有任何美丽子数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2589完成所有任务的最少时间",
        "hardRate": "HARD",
        "passRate": "42.67%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/solution",
        "problemsDesc": "<p>你有一台电脑，它可以 <strong>同时</strong>&nbsp;运行无数个任务。给你一个二维整数数组&nbsp;<code>tasks</code>&nbsp;，其中&nbsp;<code>tasks[i] = [start<sub>i</sub>, end<sub>i</sub>, duration<sub>i</sub>]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个任务需要在 <strong>闭区间</strong>&nbsp;时间段&nbsp;<code>[start<sub>i</sub>, end<sub>i</sub>]</code>&nbsp;内运行&nbsp;<code>duration<sub>i</sub></code>&nbsp;个整数时间点（但不需要连续）。</p>\n\n<p>当电脑需要运行任务时，你可以打开电脑，如果空闲时，你可以将电脑关闭。</p>\n\n<p>请你返回完成所有任务的情况下，电脑最少需要运行多少秒。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>tasks = [[2,3,1],[4,5,1],[1,5,2]]\n<b>输出：</b>2\n<b>解释：</b>\n- 第一个任务在闭区间 [2, 2] 运行。\n- 第二个任务在闭区间 [5, 5] 运行。\n- 第三个任务在闭区间 [2, 2] 和 [5, 5] 运行。\n电脑总共运行 2 个整数时间点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>tasks = [[1,3,2],[2,5,3],[5,6,2]]\n<b>输出：</b>4\n<b>解释：</b>\n- 第一个任务在闭区间 [2, 3] 运行\n- 第二个任务在闭区间 [2, 3] 和 [5, 5] 运行。\n- 第三个任务在闭区间 [5, 6] 运行。\n电脑总共运行 4 个整数时间点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tasks.length &lt;= 2000</code></li>\n\t<li><code>tasks[i].length == 3</code></li>\n\t<li><code>1 &lt;= start<sub>i</sub>, end<sub>i</sub> &lt;= 2000</code></li>\n\t<li><code>1 &lt;= duration<sub>i</sub> &lt;= end<sub>i</sub> - start<sub>i</sub> + 1 </code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2590设计一个待办事项清单",
        "hardRate": "MEDIUM",
        "passRate": "55.78%",
        "problemsUrl": "https://leetcode.cn/problems/design-a-todo-list/",
        "solutionsUrl": "https://leetcode.cn/problems/design-a-todo-list/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2591将钱分给最多的儿童",
        "hardRate": "EASY",
        "passRate": "20.76%",
        "problemsUrl": "https://leetcode.cn/problems/distribute-money-to-maximum-children/",
        "solutionsUrl": "https://leetcode.cn/problems/distribute-money-to-maximum-children/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>money</code>&nbsp;，表示你总共有的钱数（单位为美元）和另一个整数&nbsp;<code>children</code>&nbsp;，表示你要将钱分配给多少个儿童。</p>\n\n<p>你需要按照如下规则分配：</p>\n\n<ul>\n\t<li>所有的钱都必须被分配。</li>\n\t<li>每个儿童至少获得&nbsp;<code>1</code>&nbsp;美元。</li>\n\t<li>没有人获得 <code>4</code>&nbsp;美元。</li>\n</ul>\n\n<p>请你按照上述规则分配金钱，并返回 <strong>最多</strong>&nbsp;有多少个儿童获得 <strong>恰好</strong><em>&nbsp;</em><code>8</code>&nbsp;美元。如果没有任何分配方案，返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>money = 20, children = 3\n<b>输出：</b>1\n<b>解释：</b>\n最多获得 8 美元的儿童数为 1 。一种分配方案为：\n- 给第一个儿童分配 8 美元。\n- 给第二个儿童分配 9 美元。\n- 给第三个儿童分配 3 美元。\n没有分配方案能让获得 8 美元的儿童数超过 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>money = 16, children = 2\n<b>输出：</b>2\n<b>解释：</b>每个儿童都可以获得 8 美元。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= money &lt;= 200</code></li>\n\t<li><code>2 &lt;= children &lt;= 30</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2592最大化数组的伟大值",
        "hardRate": "MEDIUM",
        "passRate": "57.68%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-greatness-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-greatness-of-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 0 开始的整数数组&nbsp;<code>nums</code>&nbsp;。你需要将&nbsp;<code>nums</code>&nbsp;重新排列成一个新的数组&nbsp;<code>perm</code>&nbsp;。</p>\n\n<p>定义 <code>nums</code>&nbsp;的 <strong>伟大值</strong>&nbsp;为满足&nbsp;<code>0 &lt;= i &lt; nums.length</code>&nbsp;且&nbsp;<code>perm[i] &gt; nums[i]</code>&nbsp;的下标数目。</p>\n\n<p>请你返回重新排列 <code>nums</code>&nbsp;后的 <strong>最大</strong>&nbsp;伟大值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,3,5,2,1,3,1]\n<b>输出：</b>4\n<b>解释：</b>一个最优安排方案为 perm = [2,5,1,3,3,1,1] 。\n在下标为 0, 1, 3 和 4 处，都有 perm[i] &gt; nums[i] 。因此我们返回 4 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4]\n<b>输出：</b>3\n<b>解释：</b>最优排列为 [2,3,4,1] 。\n在下标为 0, 1 和 2 处，都有 perm[i] &gt; nums[i] 。因此我们返回 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2593标记所有元素后数组的分数",
        "hardRate": "MEDIUM",
        "passRate": "52.05%",
        "problemsUrl": "https://leetcode.cn/problems/find-score-of-an-array-after-marking-all-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/find-score-of-an-array-after-marking-all-elements/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>nums</code>&nbsp;，它包含若干正整数。</p>\n\n<p>一开始分数&nbsp;<code>score = 0</code>&nbsp;，请你按照下面算法求出最后分数：</p>\n\n<ul>\n\t<li>从数组中选择最小且没有被标记的整数。如果有相等元素，选择下标最小的一个。</li>\n\t<li>将选中的整数加到&nbsp;<code>score</code>&nbsp;中。</li>\n\t<li>标记 <strong>被选中元素</strong>，如果有相邻元素，则同时标记&nbsp;<strong>与它相邻的两个元素</strong>&nbsp;。</li>\n\t<li>重复此过程直到数组中所有元素都被标记。</li>\n</ul>\n\n<p>请你返回执行上述算法后最后的分数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,1,3,4,5,2]\n<b>输出：</b>7\n<b>解释：</b>我们按照如下步骤标记元素：\n- 1 是最小未标记元素，所以标记它和相邻两个元素：[<em><strong>2</strong></em>,<em><strong>1</strong></em>,<em><strong>3</strong></em>,4,5,2] 。\n- 2 是最小未标记元素，所以标记它和左边相邻元素：[<em><strong>2</strong></em>,<em><strong>1</strong></em>,<em><strong>3</strong></em>,4,<em><strong>5</strong></em>,<em><strong>2</strong></em>] 。\n- 4 是仅剩唯一未标记的元素，所以我们标记它：[<em><strong>2</strong></em>,<em><strong>1</strong></em>,<em><strong>3</strong></em>,<em><strong>4</strong></em>,<em><strong>5</strong></em>,<em><strong>2</strong></em>] 。\n总得分为 1 + 2 + 4 = 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,3,5,1,3,2]\n<b>输出：</b>5\n<b>解释：</b>我们按照如下步骤标记元素：\n- 1 是最小未标记元素，所以标记它和相邻两个元素：[2,3,<em><strong>5</strong></em>,<em><strong>1</strong></em>,<em><strong>3</strong></em>,2] 。\n- 2 是最小未标记元素，由于有两个 2 ，我们选择最左边的一个 2 ，也就是下标为 0 处的 2 ，以及它右边相邻的元素：[<em><strong>2</strong></em>,<em><strong>3</strong></em>,<em><strong>5</strong></em>,<em><strong>1</strong></em>,<em><strong>3</strong></em>,2] 。\n- 2 是仅剩唯一未标记的元素，所以我们标记它：[<em><strong>2</strong></em>,<em><strong>3</strong></em>,<em><strong>5</strong></em>,<em><strong>1</strong></em>,<em><strong>3</strong></em>,<em><strong>2</strong></em>] 。\n总得分为 1 + 2 + 2 = 5 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2594修车的最少时间",
        "hardRate": "MEDIUM",
        "passRate": "45.48%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-repair-cars/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-repair-cars/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>ranks</code>&nbsp;，表示一些机械工的 <strong>能力值</strong>&nbsp;。<code>ranks<sub>i</sub></code> 是第 <code>i</code> 位机械工的能力值。能力值为&nbsp;<code>r</code>&nbsp;的机械工可以在&nbsp;<code>r * n<sup>2</sup></code>&nbsp;分钟内修好&nbsp;<code>n</code>&nbsp;辆车。</p>\n\n<p>同时给你一个整数&nbsp;<code>cars</code>&nbsp;，表示总共需要修理的汽车数目。</p>\n\n<p>请你返回修理所有汽车&nbsp;<strong>最少</strong>&nbsp;需要多少时间。</p>\n\n<p><strong>注意：</strong>所有机械工可以同时修理汽车。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>ranks = [4,2,3,1], cars = 10\n<b>输出：</b>16\n<b>解释：</b>\n- 第一位机械工修 2 辆车，需要 4 * 2 * 2 = 16 分钟。\n- 第二位机械工修 2 辆车，需要 2 * 2 * 2 = 8 分钟。\n- 第三位机械工修 2 辆车，需要 3 * 2 * 2 = 12 分钟。\n- 第四位机械工修 4 辆车，需要 1 * 4 * 4 = 16 分钟。\n16 分钟是修理完所有车需要的最少时间。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>ranks = [5,1,8], cars = 6\n<b>输出：</b>16\n<b>解释：</b>\n- 第一位机械工修 1 辆车，需要 5 * 1 * 1 = 5 分钟。\n- 第二位机械工修 4 辆车，需要 1 * 4 * 4 = 16 分钟。\n- 第三位机械工修 1 辆车，需要 8 * 1 * 1 = 8 分钟。\n16 分钟时修理完所有车需要的最少时间。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= ranks.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= ranks[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= cars &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2595奇偶位数",
        "hardRate": "EASY",
        "passRate": "72.77%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-even-and-odd-bits/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-even-and-odd-bits/solution",
        "problemsDesc": "<p>给你一个 <strong>正</strong> 整数 <code>n</code> 。</p>\n\n<p>用 <code>even</code> 表示在 <code>n</code> 的二进制形式（下标从 <strong>0</strong> 开始）中值为 <code>1</code> 的偶数下标的个数。</p>\n\n<p>用 <code>odd</code> 表示在 <code>n</code> 的二进制形式（下标从 <strong>0</strong> 开始）中值为 <code>1</code> 的奇数下标的个数。</p>\n\n<p>返回整数数组<em> </em><code>answer</code><em> </em>，其中<em> </em><code>answer = [even, odd]</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 17\n<strong>输出：</strong>[2,0]\n<strong>解释：</strong>17 的二进制形式是 10001 。 \n下标 0 和 下标 4 对应的值为 1 。 \n共有 2 个偶数下标，0 个奇数下标。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>[0,1]\n<strong>解释：</strong>2 的二进制形式是 10 。 \n下标 1 对应的值为 1 。 \n共有 0 个偶数下标，1 个奇数下标。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2596检查骑士巡视方案",
        "hardRate": "MEDIUM",
        "passRate": "52.47%",
        "problemsUrl": "https://leetcode.cn/problems/check-knight-tour-configuration/",
        "solutionsUrl": "https://leetcode.cn/problems/check-knight-tour-configuration/solution",
        "problemsDesc": "<p>骑士在一张 <code>n x n</code> 的棋盘上巡视。在有效的巡视方案中，骑士会从棋盘的 <strong>左上角</strong> 出发，并且访问棋盘上的每个格子 <strong>恰好一次</strong> 。</p>\n\n<p>给你一个 <code>n x n</code> 的整数矩阵 <code>grid</code> ，由范围 <code>[0, n * n - 1]</code> 内的不同整数组成，其中 <code>grid[row][col]</code> 表示单元格 <code>(row, col)</code> 是骑士访问的第 <code>grid[row][col]</code> 个单元格。骑士的行动是从下标 <strong>0</strong> 开始的。</p>\n\n<p>如果 <code>grid</code> 表示了骑士的有效巡视方案，返回 <code>true</code>；否则返回 <code>false</code>。</p>\n\n<p><strong>注意</strong>，骑士行动时可以垂直移动两个格子且水平移动一个格子，或水平移动两个格子且垂直移动一个格子。下图展示了骑士从某个格子出发可能的八种行动路线。<br>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/10/12/knight.png\" style=\"width: 300px; height: 300px;\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/28/yetgriddrawio-5.png\" style=\"width: 251px; height: 251px;\">\n<pre><strong>输入：</strong>grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\n<strong>输出：</strong>true\n<strong>解释：</strong>grid 如上图所示，可以证明这是一个有效的巡视方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/28/yetgriddrawio-6.png\" style=\"width: 151px; height: 151px;\">\n<pre><strong>输入：</strong>grid = [[0,3,6],[5,8,1],[2,7,4]]\n<strong>输出：</strong>false\n<strong>解释：</strong>grid 如上图所示，考虑到骑士第 7 次行动后的位置，第 8 次行动是无效的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>3 &lt;= n &lt;= 7</code></li>\n\t<li><code>0 &lt;= grid[row][col] &lt; n * n</code></li>\n\t<li><code>grid</code> 中的所有整数 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2597美丽子集的数目",
        "hardRate": "MEDIUM",
        "passRate": "34.67%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-beautiful-subsets/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-beautiful-subsets/solution",
        "problemsDesc": "<p>给你一个由正整数组成的数组 <code>nums</code> 和一个 <strong>正</strong> 整数 <code>k</code> 。</p>\n\n<p>如果 <code>nums</code> 的子集中，任意两个整数的绝对差均不等于 <code>k</code> ，则认为该子数组是一个 <strong>美丽</strong> 子集。</p>\n\n<p>返回数组 <code>nums</code> 中 <strong>非空</strong> 且 <strong>美丽</strong> 的子集数目。</p>\n\n<p><code>nums</code> 的子集定义为：可以经由 <code>nums</code> 删除某些元素（也可能不删除）得到的一个数组。只有在删除元素时选择的索引不同的情况下，两个子集才会被视作是不同的子集。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,4,6], k = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>数组 nums 中的美丽子集有：[2], [4], [6], [2, 6] 。\n可以证明数组 [2,4,6] 中只存在 4 个美丽子集。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1], k = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>数组 nums 中的美丽数组有：[1] 。\n可以证明数组 [1] 中只存在 1 个美丽子集。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2598执行操作后的最大 MEX",
        "hardRate": "MEDIUM",
        "passRate": "39.12%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-missing-non-negative-integer-after-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-missing-non-negative-integer-after-operations/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>value</code> 。</p>\n\n<p>在一步操作中，你可以对 <code>nums</code> 中的任一元素加上或减去 <code>value</code> 。</p>\n\n<ul>\n\t<li>例如，如果 <code>nums = [1,2,3]</code> 且 <code>value = 2</code> ，你可以选择 <code>nums[0]</code> 减去 <code>value</code> ，得到 <code>nums = [-1,2,3]</code> 。</li>\n</ul>\n\n<p>数组的 MEX (minimum excluded) 是指其中数组中缺失的最小非负整数。</p>\n\n<ul>\n\t<li>例如，<code>[-1,2,3]</code> 的 MEX 是 <code>0</code> ，而 <code>[1,0,3]</code> 的 MEX 是 <code>2</code> 。</li>\n</ul>\n\n<p>返回在执行上述操作 <strong>任意次</strong> 后，<code>nums</code><em> </em>的最大 MEX <em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,-10,7,13,6,8], value = 5\n<strong>输出：</strong>4\n<strong>解释：</strong>执行下述操作可以得到这一结果：\n- nums[1] 加上 value 两次，nums = [1,<em><strong>0</strong></em>,7,13,6,8]\n- nums[2] 减去 value 一次，nums = [1,0,<em><strong>2</strong></em>,13,6,8]\n- nums[3] 减去 value 两次，nums = [1,0,2,<em><strong>3</strong></em>,6,8]\nnums 的 MEX 是 4 。可以证明 4 是可以取到的最大 MEX 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,-10,7,13,6,8], value = 7\n<strong>输出：</strong>2\n<strong>解释：</strong>执行下述操作可以得到这一结果：\n- nums[2] 减去 value 一次，nums = [1,-10,<em><strong>0</strong></em>,13,6,8]\nnums 的 MEX 是 2 。可以证明 2 是可以取到的最大 MEX 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, value &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2599使前缀和数组非负",
        "hardRate": "MEDIUM",
        "passRate": "55.38%",
        "problemsUrl": "https://leetcode.cn/problems/make-the-prefix-sum-non-negative/",
        "solutionsUrl": "https://leetcode.cn/problems/make-the-prefix-sum-non-negative/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2600K 件物品的最大和",
        "hardRate": "EASY",
        "passRate": "65.86%",
        "problemsUrl": "https://leetcode.cn/problems/k-items-with-the-maximum-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/k-items-with-the-maximum-sum/solution",
        "problemsDesc": "<p>袋子中装有一些物品，每个物品上都标记着数字 <code>1</code> 、<code>0</code> 或 <code>-1</code> 。</p>\n\n<p>给你四个非负整数 <code>numOnes</code> 、<code>numZeros</code> 、<code>numNegOnes</code> 和 <code>k</code> 。</p>\n\n<p>袋子最初包含：</p>\n\n<ul>\n\t<li><code>numOnes</code> 件标记为 <code>1</code> 的物品。</li>\n\t<li><code>numZeroes</code> 件标记为 <code>0</code> 的物品。</li>\n\t<li><code>numNegOnes</code> 件标记为 <code>-1</code> 的物品。</li>\n</ul>\n\n<p>现计划从这些物品中恰好选出 <code>k</code> 件物品。返回所有可行方案中，物品上所标记数字之和的最大值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>numOnes = 3, numZeros = 2, numNegOnes = 0, k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>袋子中的物品分别标记为 {1, 1, 1, 0, 0} 。取 2 件标记为 1 的物品，得到的数字之和为 2 。\n可以证明 2 是所有可行方案中的最大值。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>numOnes = 3, numZeros = 2, numNegOnes = 0, k = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>袋子中的物品分别标记为 {1, 1, 1, 0, 0} 。取 3 件标记为 1 的物品，1 件标记为 0 的物品，得到的数字之和为 3 。\n可以证明 3 是所有可行方案中的最大值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= numOnes, numZeros, numNegOnes &lt;= 50</code></li>\n\t<li><code>0 &lt;= k &lt;= numOnes + numZeros + numNegOnes</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2601质数减法运算",
        "hardRate": "MEDIUM",
        "passRate": "38.60%",
        "problemsUrl": "https://leetcode.cn/problems/prime-subtraction-operation/",
        "solutionsUrl": "https://leetcode.cn/problems/prime-subtraction-operation/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，数组长度为 <code>n</code> 。</p>\n\n<p>你可以执行无限次下述运算：</p>\n\n<ul>\n\t<li>选择一个之前未选过的下标 <code>i</code> ，并选择一个 <strong>严格小于</strong> <code>nums[i]</code> 的质数 <code>p</code> ，从 <code>nums[i]</code> 中减去 <code>p</code> 。</li>\n</ul>\n\n<p>如果你能通过上述运算使得 <code>nums</code> 成为严格递增数组，则返回 <code>true</code> ；否则返回 <code>false</code> 。</p>\n\n<p><strong>严格递增数组</strong> 中的每个元素都严格大于其前面的元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,9,6,10]\n<strong>输出：</strong>true\n<strong>解释：</strong>\n在第一次运算中：选择 i = 0 和 p = 3 ，然后从 nums[0] 减去 3 ，nums 变为 [1,9,6,10] 。\n在第二次运算中：选择 i = 1 和 p = 7 ，然后从 nums[1] 减去 7 ，nums 变为 [1,2,6,10] 。\n第二次运算后，nums 按严格递增顺序排序，因此答案为 true 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [6,8,11,12]\n<strong>输出：</strong>true\n<strong>解释：</strong>nums 从一开始就按严格递增顺序排序，因此不需要执行任何运算。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,8,3]\n<strong>输出：</strong>false\n<strong>解释：</strong>可以证明，执行运算无法使 nums 按严格递增顺序排序，因此答案是 false 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>nums.length == n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2602使数组元素全部相等的最少操作次数",
        "hardRate": "MEDIUM",
        "passRate": "33.47%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solution",
        "problemsDesc": "<p>给你一个正整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>同时给你一个长度为 <code>m</code>&nbsp;的整数数组&nbsp;<code>queries</code>&nbsp;。第 <code>i</code>&nbsp;个查询中，你需要将 <code>nums</code>&nbsp;中所有元素变成&nbsp;<code>queries[i]</code>&nbsp;。你可以执行以下操作&nbsp;<strong>任意</strong>&nbsp;次：</p>\n\n<ul>\n\t<li>将数组里一个元素&nbsp;<strong>增大</strong>&nbsp;或者&nbsp;<strong>减小</strong>&nbsp;<code>1</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回一个长度为 <code>m</code>&nbsp;的数组<em>&nbsp;</em><code>answer</code>&nbsp;，其中<em>&nbsp;</em><code>answer[i]</code>是将&nbsp;<code>nums</code>&nbsp;中所有元素变成&nbsp;<code>queries[i]</code>&nbsp;的&nbsp;<strong>最少</strong>&nbsp;操作次数。</p>\n\n<p><strong>注意</strong>，每次查询后，数组变回最开始的值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [3,1,6,8], queries = [1,5]\n<b>输出：</b>[14,10]\n<b>解释：</b>第一个查询，我们可以执行以下操作：\n- 将 nums[0] 减小 2 次，nums = [1,1,6,8] 。\n- 将 nums[2] 减小 5 次，nums = [1,1,1,8] 。\n- 将 nums[3] 减小 7 次，nums = [1,1,1,1] 。\n第一个查询的总操作次数为 2 + 5 + 7 = 14 。\n第二个查询，我们可以执行以下操作：\n- 将 nums[0] 增大 2 次，nums = [5,1,6,8] 。\n- 将 nums[1] 增大 4 次，nums = [5,5,6,8] 。\n- 将 nums[2] 减小 1 次，nums = [5,5,5,8] 。\n- 将 nums[3] 减小 3 次，nums = [5,5,5,5] 。\n第二个查询的总操作次数为 2 + 4 + 1 + 3 = 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,9,6,3], queries = [10]\n<b>输出：</b>[20]\n<b>解释：</b>我们可以将数组中所有元素都增大到 10 ，总操作次数为 8 + 1 + 4 + 7 = 20 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>m == queries.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], queries[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2603收集树中金币",
        "hardRate": "HARD",
        "passRate": "43.59%",
        "problemsUrl": "https://leetcode.cn/problems/collect-coins-in-a-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/collect-coins-in-a-tree/solution",
        "problemsDesc": "<p>给你一个 <code>n</code>&nbsp;个节点的无向无根树，节点编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。给你整数&nbsp;<code>n</code>&nbsp;和一个长度为 <code>n - 1</code>&nbsp;的二维整数数组 <code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示树中节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条边。再给你一个长度为 <code>n</code>&nbsp;的数组&nbsp;<code>coins</code>&nbsp;，其中&nbsp;<code>coins[i]</code> 可能为&nbsp;<code>0</code>&nbsp;也可能为&nbsp;<code>1</code>&nbsp;，<code>1</code>&nbsp;表示节点 <code>i</code>&nbsp;处有一个金币。</p>\n\n<p>一开始，你需要选择树中任意一个节点出发。你可以执行下述操作任意次：</p>\n\n<ul>\n\t<li>收集距离当前节点距离为 <code>2</code>&nbsp;以内的所有金币，或者</li>\n\t<li>移动到树中一个相邻节点。</li>\n</ul>\n\n<p>你需要收集树中所有的金币，并且回到出发节点，请你返回最少经过的边数。</p>\n\n<p>如果你多次经过一条边，每一次经过都会给答案加一。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/01/graph-2.png\" style=\"width: 522px; height: 522px;\"></p>\n\n<pre><b>输入：</b>coins = [1,0,0,0,0,1], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]\n<b>输出：</b>2\n<b>解释：</b>从节点 2 出发，收集节点 0 处的金币，移动到节点 3 ，收集节点 5 处的金币，然后移动回节点 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/02/graph-4.png\" style=\"width: 522px; height: 522px;\"></p>\n\n<pre><b>输入：</b>coins = [0,0,0,1,1,0,0,1], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]]\n<b>输出：</b>2\n<b>解释：</b>从节点 0 出发，收集节点 4 和 3 处的金币，移动到节点 2 处，收集节点 7 处的金币，移动回节点 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == coins.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= coins[i] &lt;= 1</code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>edges</code>&nbsp;表示一棵合法的树。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2604吃掉所有谷子的最短时间",
        "hardRate": "HARD",
        "passRate": "36.96%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-eat-all-grains/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-eat-all-grains/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2605从两个数字数组里生成最小数字",
        "hardRate": "EASY",
        "passRate": "62.98%",
        "problemsUrl": "https://leetcode.cn/problems/form-smallest-number-from-two-digit-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/form-smallest-number-from-two-digit-arrays/solution",
        "problemsDesc": "给你两个只包含 1 到 9 之间数字的数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;，每个数组中的元素 <strong>互不相同</strong>&nbsp;，请你返回 <strong>最小</strong> 的数字，两个数组都 <strong>至少</strong> 包含这个数字的某个数位。\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [4,1,3], nums2 = [5,7]\n<b>输出：</b>15\n<b>解释：</b>数字 15 的数位 1 在 nums1 中出现，数位 5 在 nums2 中出现。15 是我们能得到的最小数字。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [3,5,2,6], nums2 = [3,1,7]\n<b>输出：</b>3\n<b>解释：</b>数字 3 的数位 3 在两个数组中都出现了。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 9</code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 9</code></li>\n\t<li>每个数组中，元素 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2606找到最大开销的子字符串",
        "hardRate": "MEDIUM",
        "passRate": "53.47%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-substring-with-maximum-cost/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-substring-with-maximum-cost/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，一个字符&nbsp;<strong>互不相同</strong>&nbsp;的字符串&nbsp;<code>chars</code>&nbsp;和一个长度与 <code>chars</code>&nbsp;相同的整数数组&nbsp;<code>vals</code>&nbsp;。</p>\n\n<p><strong>子字符串的开销</strong>&nbsp;是一个子字符串中所有字符对应价值之和。空字符串的开销是 <code>0</code>&nbsp;。</p>\n\n<p><strong>字符的价值</strong>&nbsp;定义如下：</p>\n\n<ul>\n\t<li>如果字符不在字符串&nbsp;<code>chars</code>&nbsp;中，那么它的价值是它在字母表中的位置（下标从 <strong>1</strong>&nbsp;开始）。\n\n\t<ul>\n\t\t<li>比方说，<code>'a'</code>&nbsp;的价值为&nbsp;<code>1</code>&nbsp;，<code>'b'</code>&nbsp;的价值为&nbsp;<code>2</code>&nbsp;，以此类推，<code>'z'</code>&nbsp;的价值为&nbsp;<code>26</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n\t<li>否则，如果这个字符在 <code>chars</code>&nbsp;中的位置为 <code>i</code>&nbsp;，那么它的价值就是&nbsp;<code>vals[i]</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回字符串 <code>s</code>&nbsp;的所有子字符串中的最大开销。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"adaa\", chars = \"d\", vals = [-1000]\n<b>输出：</b>2\n<b>解释：</b>字符 \"a\" 和 \"d\" 的价值分别为 1 和 -1000 。\n最大开销子字符串是 \"aa\" ，它的开销为 1 + 1 = 2 。\n2 是最大开销。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"abc\", chars = \"abc\", vals = [-1,-1,-1]\n<b>输出：</b>0\n<b>解释：</b>字符 \"a\" ，\"b\" 和 \"c\" 的价值分别为 -1 ，-1 和 -1 。\n最大开销子字符串是 \"\" ，它的开销为 0 。\n0 是最大开销。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n\t<li><code>1 &lt;= chars.length &lt;= 26</code></li>\n\t<li><code>chars</code>&nbsp;只包含小写英文字母，且 <strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>vals.length == chars.length</code></li>\n\t<li><code>-1000 &lt;= vals[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2607使子数组元素和相等",
        "hardRate": "MEDIUM",
        "passRate": "38.67%",
        "problemsUrl": "https://leetcode.cn/problems/make-k-subarray-sums-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/make-k-subarray-sums-equal/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>arr</code> 和一个整数 <code>k</code> 。数组 <code>arr</code> 是一个循环数组。换句话说，数组中的最后一个元素的下一个元素是数组中的第一个元素，数组中第一个元素的前一个元素是数组中的最后一个元素。</p>\n\n<p>你可以执行下述运算任意次：</p>\n\n<ul>\n\t<li>选中 <code>arr</code> 中任意一个元素，并使其值加上 <code>1</code> 或减去 <code>1</code> 。</li>\n</ul>\n\n<p>执行运算使每个长度为 <code>k</code> 的 <strong>子数组</strong> 的元素总和都相等，返回所需要的最少运算次数。</p>\n\n<p><strong>子数组</strong> 是数组的一个连续部分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,4,1,3], k = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>在下标为 1 的元素那里执行一次运算，使其等于 3 。\n执行运算后，数组变为 [1,3,1,3] 。\n- 0 处起始的子数组为 [1, 3] ，元素总和为 4 \n- 1 处起始的子数组为 [3, 1] ，元素总和为 4 \n- 2 处起始的子数组为 [1, 3] ，元素总和为 4 \n- 3 处起始的子数组为 [3, 1] ，元素总和为 4 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,5,5,7], k = 3\n<strong>输出：</strong>5\n<strong>解释：</strong>在下标为 0 的元素那里执行三次运算，使其等于 5 。在下标为 3 的元素那里执行两次运算，使其等于 5 。\n执行运算后，数组变为 [5,5,5,5] 。\n- 0 处起始的子数组为 [5, 5, 5] ，元素总和为 15\n- 1 处起始的子数组为 [5, 5, 5] ，元素总和为 15\n- 2 处起始的子数组为 [5, 5, 5] ，元素总和为 15\n- 3 处起始的子数组为 [5, 5, 5] ，元素总和为 15\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2608图中的最短环",
        "hardRate": "HARD",
        "passRate": "40.75%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-cycle-in-a-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-cycle-in-a-graph/solution",
        "problemsDesc": "<p>现有一个含 <code>n</code> 个顶点的 <strong>双向</strong> 图，每个顶点按从 <code>0</code> 到 <code>n - 1</code> 标记。图中的边由二维整数数组 <code>edges</code> 表示，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> 表示顶点 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code> 之间存在一条边。每对顶点最多通过一条边连接，并且不存在与自身相连的顶点。</p>\n\n<p>返回图中 <strong>最短</strong> 环的长度。如果不存在环，则返回 <code>-1</code> 。</p>\n\n<p><strong>环</strong> 是指以同一节点开始和结束，并且路径中的每条边仅使用一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/04/cropped.png\" style=\"width: 387px; height: 331px;\">\n<pre><strong>输入：</strong>n = 7, edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]\n<strong>输出：</strong>3\n<strong>解释：</strong>长度最小的循环是：0 -&gt; 1 -&gt; 2 -&gt; 0 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/04/croppedagin.png\" style=\"width: 307px; height: 307px;\">\n<pre><strong>输入：</strong>n = 4, edges = [[0,1],[0,2]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>图中不存在循环\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= 1000</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n\t<li>不存在重复的边</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2609最长平衡子字符串",
        "hardRate": "EASY",
        "passRate": "49.18%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-longest-balanced-substring-of-a-binary-string/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-longest-balanced-substring-of-a-binary-string/solution",
        "problemsDesc": "<p>给你一个仅由 <code>0</code> 和 <code>1</code> 组成的二进制字符串 <code>s</code> 。<span style=\"\">&nbsp;</span><span style=\"\">&nbsp;</span></p>\n\n<p>如果子字符串中 <strong>所有的<span style=\"\"> </span></strong><code><span style=\"\">0</span></code><strong><span style=\"\"> </span>都在 </strong><code>1</code><strong> 之前</strong> 且其中 <code>0</code> 的数量等于 <code>1</code> 的数量，则认为 <code>s</code> 的这个子字符串是平衡子字符串。请注意，空子字符串也视作平衡子字符串。<span style=\"\">&nbsp;</span></p>\n\n<p>返回&nbsp;<span style=\"\"> </span><code>s</code> 中最长的平衡子字符串长度。</p>\n\n<p>子字符串是字符串中的一个连续字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"01000111\"\n<strong>输出：</strong>6\n<strong>解释：</strong>最长的平衡子字符串是 \"000111\" ，长度为 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"00111\"\n<strong>输出：</strong>4\n<strong>解释：</strong>最长的平衡子字符串是 \"0011\" ，长度为 <span style=\"\">&nbsp;</span>4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"111\"\n<strong>输出：</strong>0\n<strong>解释：</strong>除了空子字符串之外不存在其他平衡子字符串，所以答案为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 50</code></li>\n\t<li><code>'0' &lt;= s[i] &lt;= '1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2610转换二维数组",
        "hardRate": "MEDIUM",
        "passRate": "85.12%",
        "problemsUrl": "https://leetcode.cn/problems/convert-an-array-into-a-2d-array-with-conditions/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-an-array-into-a-2d-array-with-conditions/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。请你创建一个满足以下条件的二维数组：</p>\n\n<ul>\n\t<li>二维数组应该 <strong>只</strong> 包含数组 <code>nums</code> 中的元素。</li>\n\t<li>二维数组中的每一行都包含 <strong>不同</strong> 的整数。</li>\n\t<li>二维数组的行数应尽可能 <strong>少</strong> 。</li>\n</ul>\n\n<p>返回结果数组。如果存在多种答案，则返回其中任何一种。</p>\n\n<p>请注意，二维数组的每一行上可以存在不同数量的元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3,4,1,2,3,1]\n<strong>输出：</strong>[[1,3,4,2],[1,3],[1]]\n<strong>解释：</strong>根据题目要求可以创建包含以下几行元素的二维数组：\n- 1,3,4,2\n- 1,3\n- 1\nnums 中的所有元素都有用到，并且每一行都由不同的整数组成，所以这是一个符合题目要求的答案。\n可以证明无法创建少于三行且符合题目要求的二维数组。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>[[4,3,2,1]]\n<strong>解释：</strong>nums 中的所有元素都不同，所以我们可以将其全部保存在二维数组中的第一行。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2611老鼠和奶酪",
        "hardRate": "MEDIUM",
        "passRate": "58.65%",
        "problemsUrl": "https://leetcode.cn/problems/mice-and-cheese/",
        "solutionsUrl": "https://leetcode.cn/problems/mice-and-cheese/solution",
        "problemsDesc": "<p>有两只老鼠和&nbsp;<code>n</code>&nbsp;块不同类型的奶酪，每块奶酪都只能被其中一只老鼠吃掉。</p>\n\n<p>下标为 <code>i</code>&nbsp;处的奶酪被吃掉的得分为：</p>\n\n<ul>\n\t<li>如果第一只老鼠吃掉，则得分为&nbsp;<code>reward1[i]</code>&nbsp;。</li>\n\t<li>如果第二只老鼠吃掉，则得分为&nbsp;<code>reward2[i]</code>&nbsp;。</li>\n</ul>\n\n<p>给你一个正整数数组&nbsp;<code>reward1</code>&nbsp;，一个正整数数组&nbsp;<code>reward2</code>&nbsp;，和一个非负整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>请你返回第一只老鼠恰好吃掉 <code>k</code>&nbsp;块奶酪的情况下，<strong>最大</strong>&nbsp;得分为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2\n<b>输出：</b>15\n<b>解释：</b>这个例子中，第一只老鼠吃掉第 2&nbsp;和 3 块奶酪（下标从 0 开始），第二只老鼠吃掉第 0 和 1 块奶酪。\n总得分为 4 + 4 + 3 + 4 = 15 。\n15 是最高得分。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>reward1 = [1,1], reward2 = [1,1], k = 2\n<b>输出：</b>2\n<b>解释：</b>这个例子中，第一只老鼠吃掉第 0 和 1 块奶酪（下标从 0 开始），第二只老鼠不吃任何奶酪。\n总得分为 1 + 1 = 2 。\n2 是最高得分。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == reward1.length == reward2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= reward1[i],&nbsp;reward2[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2612最少翻转操作数",
        "hardRate": "HARD",
        "passRate": "20.78%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-reverse-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-reverse-operations/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;和一个在范围 <code>[0, n - 1]</code>&nbsp;以内的整数&nbsp;<code>p</code>&nbsp;，它们表示一个长度为 <code>n</code> 且下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>arr</code>&nbsp;，数组中除了下标为&nbsp;<code>p</code>&nbsp;处是 <code>1</code>&nbsp;以外，其他所有数都是 <code>0</code>&nbsp;。</p>\n\n<p>同时给你一个整数数组&nbsp;<code>banned</code>&nbsp;，它包含数组中的一些位置。<code>banned</code>&nbsp;中第&nbsp;<strong>i</strong>&nbsp;个位置表示&nbsp;<code>arr[banned[i]] = 0</code>&nbsp;，题目保证&nbsp;<code>banned[i] != p</code>&nbsp;。</p>\n\n<p>你可以对 <code>arr</code>&nbsp;进行 <strong>若干次</strong>&nbsp;操作。一次操作中，你选择大小为 <code>k</code>&nbsp;的一个 <strong>子数组</strong>&nbsp;，并将它 <b>翻转</b>&nbsp;。在任何一次翻转操作后，你都需要确保 <code>arr</code>&nbsp;中唯一的 <code>1</code>&nbsp;不会到达任何 <code>banned</code>&nbsp;中的位置。换句话说，<code>arr[banned[i]]</code>&nbsp;始终&nbsp;<strong>保持</strong>&nbsp;<code>0</code>&nbsp;。</p>\n\n<p>请你返回一个数组&nbsp;<code>ans</code>&nbsp;，对于<em>&nbsp;</em><code>[0, n - 1]</code>&nbsp;之间的任意下标&nbsp;<code>i</code>&nbsp;，<code>ans[i]</code>&nbsp;是将&nbsp;<code>1</code>&nbsp;放到位置&nbsp;<code>i</code>&nbsp;处的&nbsp;<strong>最少</strong>&nbsp;翻转操作次数，如果无法放到位置&nbsp;<code>i</code>&nbsp;处，此数为&nbsp;<code>-1</code>&nbsp;。</p>\n\n<ul>\n\t<li><strong>子数组</strong>&nbsp;指的是一个数组里一段连续 <strong>非空</strong>&nbsp;的元素序列。</li>\n\t<li>对于所有的 <code>i</code>&nbsp;，<code>ans[i]</code>&nbsp;相互之间独立计算。</li>\n\t<li>将一个数组中的元素 <strong>翻转</strong> 指的是将数组中的值变成 <strong>相反顺序</strong>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 4, p = 0, banned = [1,2], k = 4\n<b>输出：</b>[0,-1,-1,1]\n<b>解释：</b><code>k = 4，所以只有一种可行的翻转操作，就是将整个数组翻转。一开始 </code>1<strong> </strong>在位置 0 处，所以将它翻转到位置 0 处需要的操作数为 0 。\n我们不能将 1 翻转到 banned 中的位置，所以位置 1 和 2 处的答案都是 -1 。\n通过一次翻转操作，可以将 1 放到位置 3 处，所以位置 3 的答案是 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5, p = 0, banned = [2,4], k = 3\n<b>输出：</b>[0,-1,-1,-1,-1]\n<b>解释：</b>这个例子中 1 一开始在位置 0 处，所以此下标的答案为 0 。\n翻转的子数组长度为 k = 3 ，1 此时在位置 0 处，所以我们可以翻转子数组 [0, 2]，但翻转后的下标 2 在 banned 中，所以不能执行此操作。\n由于 1 没法离开位置 0 ，所以其他位置的答案都是 -1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 4, p = 2, banned = [0,1,3], k = 1\n<b>输出：</b>[-1,-1,0,-1]\n<b>解释：</b>这个例子中，我们只能对长度为 1 的子数组执行翻转操作，所以 1 无法离开初始位置。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= p &lt;= n - 1</code></li>\n\t<li><code>0 &lt;= banned.length &lt;= n - 1</code></li>\n\t<li><code>0 &lt;= banned[i] &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= k &lt;= n&nbsp;</code></li>\n\t<li><code>banned[i] != p</code></li>\n\t<li><code>banned</code>&nbsp;中的值 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2613美数对",
        "hardRate": "HARD",
        "passRate": "48.18%",
        "problemsUrl": "https://leetcode.cn/problems/beautiful-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/beautiful-pairs/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2614对角线上的质数",
        "hardRate": "EASY",
        "passRate": "32.90%",
        "problemsUrl": "https://leetcode.cn/problems/prime-in-diagonal/",
        "solutionsUrl": "https://leetcode.cn/problems/prime-in-diagonal/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>nums</code> 。</p>\n\n<p>返回位于 <code>nums</code> 至少一条 <strong>对角线</strong> 上的最大 <strong>质数</strong> 。如果任一对角线上均不存在质数，返回<em> 0 。</em></p>\n\n<p>注意：</p>\n\n<ul>\n\t<li>如果某个整数大于 <code>1</code> ，且不存在除 <code>1</code> 和自身之外的正整数因子，则认为该整数是一个质数。</li>\n\t<li>如果存在整数 <code>i</code> ，使得&nbsp;<code>nums[i][i] = val</code> 或者&nbsp;<code>nums[i][nums.length - i - 1]= val</code> ，则认为整数 <code>val</code> 位于 <code>nums</code> 的一条对角线上。</li>\n</ul>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/06/screenshot-2023-03-06-at-45648-pm.png\" style=\"width: 181px; height: 121px;\" /></p>\n\n<p>在上图中，一条对角线是 <strong>[1,5,9]</strong> ，而另一条对角线是<strong> [3,5,7]</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[1,2,3],[5,6,7],[9,10,11]]\n<strong>输出：</strong>11\n<strong>解释：</strong>数字 1、3、6、9 和 11 是所有 \"位于至少一条对角线上\" 的数字。由于 11 是最大的质数，故返回 11 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[1,2,3],[5,17,7],[9,11,10]]\n<strong>输出：</strong>17\n<strong>解释：</strong>数字 1、3、9、10 和 17 是所有满足\"位于至少一条对角线上\"的数字。由于 17 是最大的质数，故返回 17 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 300</code></li>\n\t<li><code>nums.length == nums<sub>i</sub>.length</code></li>\n\t<li><code>1 &lt;= nums<span style=\"\">[i][j]</span>&nbsp;&lt;= 4*10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2615等值距离和",
        "hardRate": "MEDIUM",
        "passRate": "35.47%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-distances/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-distances/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。现有一个长度等于 <code>nums.length</code> 的数组 <code>arr</code> 。对于满足 <code>nums[j] == nums[i]</code> 且 <code>j != i</code> 的所有 <code>j</code> ，<code>arr[i]</code> 等于所有 <code>|i - j|</code> 之和。如果不存在这样的 <code>j</code> ，则令 <code>arr[i]</code> 等于 <code>0</code> 。</p>\n\n<p>返回数组<em> </em><code>arr</code><em> 。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,1,1,2]\n<strong>输出：</strong>[5,0,3,4,0]\n<strong>解释：</strong>\ni = 0 ，nums[0] == nums[2] 且 nums[0] == nums[3] 。因此，arr[0] = |0 - 2| + |0 - 3| = 5 。 \ni = 1 ，arr[1] = 0 因为不存在值等于 3 的其他下标。\ni = 2 ，nums[2] == nums[0] 且 nums[2] == nums[3] 。因此，arr[2] = |2 - 0| + |2 - 3| = 3 。\ni = 3 ，nums[3] == nums[0] 且 nums[3] == nums[2] 。因此，arr[3] = |3 - 0| + |3 - 2| = 4 。 \ni = 4 ，arr[4] = 0 因为不存在值等于 2 的其他下标。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,5,3]\n<strong>输出：</strong>[0,0,0]\n<strong>解释：</strong>因为 nums 中的元素互不相同，对于所有 i ，都有 arr[i] = 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2616最小化数对的最大差值",
        "hardRate": "MEDIUM",
        "passRate": "38.93%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>p</code>&nbsp;。请你从&nbsp;<code>nums</code>&nbsp;中找到&nbsp;<code>p</code> 个下标对，每个下标对对应数值取差值，你需要使得这 <code>p</code> 个差值的&nbsp;<strong>最大值</strong>&nbsp;<strong>最小</strong>。同时，你需要确保每个下标在这&nbsp;<code>p</code>&nbsp;个下标对中最多出现一次。</p>\n\n<p>对于一个下标对&nbsp;<code>i</code>&nbsp;和&nbsp;<code>j</code>&nbsp;，这一对的差值为&nbsp;<code>|nums[i] - nums[j]|</code>&nbsp;，其中&nbsp;<code>|x|</code>&nbsp;表示 <code>x</code>&nbsp;的 <strong>绝对值</strong>&nbsp;。</p>\n\n<p>请你返回 <code>p</code>&nbsp;个下标对对应数值 <strong>最大差值</strong>&nbsp;的 <strong>最小值</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [10,1,2,7,1,3], p = 2\n<b>输出：</b>1\n<b>解释：</b>第一个下标对选择 1 和 4 ，第二个下标对选择 2 和 5 。\n最大差值为 max(|nums[1] - nums[4]|, |nums[2] - nums[5]|) = max(0, 1) = 1 。所以我们返回 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [4,2,1,2], p = 1\n<b>输出：</b>0\n<b>解释：</b>选择下标 1 和 3 构成下标对。差值为 |2 - 2| = 0 ，这是最大差值的最小值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= p &lt;= (nums.length)/2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2617网格图中最少访问的格子数",
        "hardRate": "HARD",
        "passRate": "32.55%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;整数矩阵&nbsp;<code>grid</code>&nbsp;。你一开始的位置在&nbsp;<strong>左上角</strong>&nbsp;格子&nbsp;<code>(0, 0)</code>&nbsp;。</p>\n\n<p>当你在格子&nbsp;<code>(i, j)</code>&nbsp;的时候，你可以移动到以下格子之一：</p>\n\n<ul>\n\t<li>满足 <code>j &lt; k &lt;= grid[i][j] + j</code>&nbsp;的格子&nbsp;<code>(i, k)</code>&nbsp;（向右移动），或者</li>\n\t<li>满足 <code>i &lt; k &lt;= grid[i][j] + i</code>&nbsp;的格子&nbsp;<code>(k, j)</code>&nbsp;（向下移动）。</li>\n</ul>\n\n<p>请你返回到达 <strong>右下角</strong>&nbsp;格子&nbsp;<code>(m - 1, n - 1)</code>&nbsp;需要经过的最少移动格子数，如果无法到达右下角格子，请你返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/25/ex1.png\" style=\"width: 271px; height: 171px;\"></p>\n\n<pre><b>输入：</b>grid = [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]]\n<b>输出：</b>4\n<b>解释：</b>上图展示了到达右下角格子经过的 4 个格子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/25/ex2.png\" style=\"width: 271px; height: 171px;\"></p>\n\n<pre><b>输入：</b>grid = [[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]]\n<b>输出：</b>3\n<strong>解释：</strong>上图展示了到达右下角格子经过的 3 个格子。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/26/ex3.png\" style=\"width: 181px; height: 81px;\"></p>\n\n<pre><b>输入：</b>grid = [[2,1,0],[1,0,0]]\n<b>输出：</b>-1\n<b>解释：</b>无法到达右下角格子。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt; m * n</code></li>\n\t<li><code>grid[m - 1][n - 1] == 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2618检查是否是类的对象实例",
        "hardRate": "MEDIUM",
        "passRate": "33.96%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-object-instance-of-class/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-object-instance-of-class/solution",
        "problemsDesc": "<p>请你编写一个函数，检查给定的值是否是给定类或超类的实例。</p>\n\n<p>可以传递给函数的数据类型没有限制。例如，值或类可能是&nbsp; <code>undefined</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>func = () =&gt; checkIfInstance(new Date(), Date)\n<b>输出：</b>true\n<strong>解释：</strong>根据定义，Date 构造函数返回的对象是 Date 的一个实例。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>func = () =&gt; { class Animal {}; class Dog extends Animal {}; return checkIfInstance(new Dog(), Animal); }\n<b>输出：</b>true\n<strong>解释：</strong>\nclass Animal {};\nclass Dog extends Animal {};\ncheckIfInstanceOf(new Dog(), Animal); // true\n\nDog 是 Animal 的子类。因此，Dog 对象同时是 Dog 和 Animal 的实例。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>func = () =&gt; checkIfInstance(Date, Date)\n<b>输出：</b>false\n<strong>解释：</strong>日期的构造函数在逻辑上不能是其自身的实例。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>func = () =&gt; checkIfInstance(5, Number)\n<b>输出：</b>true\n<strong>解释：</strong>5 是一个 Number。注意，\"instanceof\" 关键字将返回 false。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2619数组原型对象的最后一个元素",
        "hardRate": "EASY",
        "passRate": "72.02%",
        "problemsUrl": "https://leetcode.cn/problems/array-prototype-last/",
        "solutionsUrl": "https://leetcode.cn/problems/array-prototype-last/solution",
        "problemsDesc": "<p>请你编写一段代码实现一个数组方法，使任何数组都可以调用 <code>array.last()</code> 方法，这个方法将返回数组最后一个元素。如果数组中没有元素，则返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>你可以假设数组是 <code>JSON.parse</code> 的输出结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1 ：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [null, {}, 3]\n<b>输出：</b>3\n<b>解释</b>：调用 nums.last() 后返回最后一个元素： 3。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre>\n<b>输入：</b>nums = []\n<b>输出：</b>-1\n<strong>解释：</strong>因为此数组没有元素，所以应该返回 -1。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>0 &lt;= arr.length &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2620计数器",
        "hardRate": "EASY",
        "passRate": "81.88%",
        "problemsUrl": "https://leetcode.cn/problems/counter/",
        "solutionsUrl": "https://leetcode.cn/problems/counter/solution",
        "problemsDesc": "<p>请你编写并返回一个&nbsp;<strong>计数器&nbsp;</strong>函数，它接收一个整型参数 n 。这个&nbsp;<strong>计数器&nbsp;</strong>函数最初返回 n，每次调用它时返回前一个值加 1 的值 ( <code>n</code> ,&nbsp; <code>n + 1</code> ,&nbsp; <code>n + 2</code> ，等等)。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>\nn = 10 \n[\"call\",\"call\",\"call\"]\n<b>输出：</b>[10,11,12]\n<strong>解释：\n</strong>counter() = 10 // 第一次调用 counter()，返回 n。\ncounter() = 11 // 返回上次调用的值加 1。\ncounter() = 12 // 返回上次调用的值加 1。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>\nn = -2\n[\"call\",\"call\",\"call\",\"call\",\"call\"]\n<b>输出：</b>[-2,-1,0,1,2]\n<b>解释：</b>counter() 最初返回 -2。然后在每个后续调用后增加 1。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-1000<sup>&nbsp;</sup>&lt;= n &lt;= 1000</code></li>\n\t<li><code>最多对 counter() 进行 1000 次调用</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2621睡眠函数",
        "hardRate": "EASY",
        "passRate": "84.24%",
        "problemsUrl": "https://leetcode.cn/problems/sleep/",
        "solutionsUrl": "https://leetcode.cn/problems/sleep/solution",
        "problemsDesc": "<p>请你编写一个异步函数，它接收一个正整数参数 <code>millis</code>&nbsp;，并休眠这么多毫秒。要求此函数可以解析任何值。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre>\n<b>输入：</b>millis = 100\n<b>输出：</b>100\n<b>解释：</b>\n在 100ms 后此异步函数执行完时返回一个 Promise 对象\nlet t = Date.now();\nsleep(100).then(() =&gt; {\n  console.log(Date.now() - t); // 100\n});\n</pre>\n\n<p><b>示例 2：</b></p>\n\n<pre>\n<b>输入：</b>millis = 200\n<b>输出：</b>200\n<b>解释：</b>在 200ms 后函数执行完时返回一个 Promise 对象\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>1 &lt;= millis &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2622有时间限制的缓存",
        "hardRate": "MEDIUM",
        "passRate": "55.05%",
        "problemsUrl": "https://leetcode.cn/problems/cache-with-time-limit/",
        "solutionsUrl": "https://leetcode.cn/problems/cache-with-time-limit/solution",
        "problemsDesc": "<p>编写一个类，它允许获取和设置键-值对，并且每个键都有一个&nbsp;<strong>过期时间</strong>&nbsp;。</p>\n\n<p>该类有三个公共方法：</p>\n\n<p><code>set(key, value, duration)</code>&nbsp;：接收参数为整型键 <code>key</code> 、整型值 <code>value</code> 和以毫秒为单位的持续时间 <code>duration</code> 。一旦 <code>duration</code>&nbsp;到期后，这个键就无法访问。如果相同的未过期键已经存在，该方法将返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。如果该键已经存在，则它的值和持续时间都应该被覆盖。</p>\n\n<p><code>get(key)</code>&nbsp;：如果存在一个未过期的键，它应该返回这个键相关的值。否则返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p><code>count()</code>&nbsp;：返回未过期键的总数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong> \n[\"TimeLimitedCache\", \"set\", \"get\", \"count\", \"get\"]\n[[], [1, 42, 100], [1], [], [1]]\n[0, 0, 50, 50, 150]\n<strong>输出：</strong> [null, false, 42, 1, -1]\n<strong>解释：</strong>\n在 t=0 时，缓存被构造。\n在 t=0 时，添加一个键值对 (1: 42) ，过期时间为 100ms 。因为该值不存在，因此返回false。\n在 t=50 时，请求 key=1 并返回值 42。\n在 t=50 时，调用 count() ，缓存中有一个未过期的键。\n在 t=100 时，key=1 到期。\n在 t=150 时，调用 get(1) ，返回 -1，因为缓存是空的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"TimeLimitedCache\", \"set\", \"set\", \"get\", \"get\", \"get\", \"count\"]\n[[], [1, 42, 50], [1, 50, 100], [1], [1], [1], []]\n[0, 0, 40, 50, 120, 200, 250]\n<strong>输出：</strong> [null, false, true, 50, 50, -1]\n<strong>解释：</strong>\n在 t=0 时，缓存被构造。\n在 t=0 时，添加一个键值对 (1: 42) ，过期时间为 50ms。因为该值不存在，因此返回false。\n当 t=40 时，添加一个键值对 (1: 50) ，过期时间为 100ms。因为一个未过期的键已经存在，返回 true 并覆盖这个键的旧值。\n在 t=50 时，调用 get(1) ，返回 50。\n在 t=120 时，调用 get(1) ，返回 50。\n在 t=140 时，key=1 过期。\n在 t=200 时，调用 get(1) ，但缓存为空，因此返回 -1。\n在 t=250 时，count() 返回0 ，因为缓存是空的，没有未过期的键。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= key &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= value &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= duration &lt;= 1000</code></li>\n\t<li><code>方法调用总数不会超过100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2623记忆函数",
        "hardRate": "MEDIUM",
        "passRate": "60.38%",
        "problemsUrl": "https://leetcode.cn/problems/memoize/",
        "solutionsUrl": "https://leetcode.cn/problems/memoize/solution",
        "problemsDesc": "<p>请你编写一个函数，它接收另一个函数作为输入，并返回该函数的 <strong>记忆化</strong> 后的结果。</p>\n\n<p><strong>记忆函数</strong> 是一个对于相同的输入永远不会被调用两次的函数。相反，它将返回一个缓存值。</p>\n\n<p>你可以假设有 <strong>3</strong> 个可能的输入函数：<code>sum</code> 、<code>fib</code> 和 <code>factorial</code> 。</p>\n\n<ul>\n\t<li>&nbsp;<code>sum</code> 接收两个整型参数 <code>a</code> 和 <code>b</code> ，并返回 <code>a + b</code> 。</li>\n\t<li>&nbsp;<code>fib</code> 接收一个整型参数&nbsp;<code>n</code> ，如果 <code>n &lt;= 1</code> 则返回 <code>1</code>，否则返回 <code>fib (n - 1) + fib (n - 2)</code>。</li>\n\t<li>&nbsp;<code>factorial</code> 接收一个整型参数 <code>n</code> ，如果 <code>n &lt;= 1</code> 则返回&nbsp;&nbsp;<code>1</code>&nbsp;，否则返回 <code>factorial(n - 1) * n</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n\"sum\"\n[\"call\",\"call\",\"getCallCount\",\"call\",\"getCallCount\"]\n[[2,2],[2,2],[],[1,2],[]]\n<strong>输出：</strong>\n[4,4,1,3,2]\n\n<strong>解释：</strong>\nconst sum = (a, b) =&gt; a + b;\nconst memoizedSum = memoize(sum);\nmemoizedSum (2, 2);// 返回 4。sum() 被调用，因为之前没有使用参数 (2, 2) 调用过。\nmemoizedSum (2, 2);// 返回 4。没有调用 sum()，因为前面有相同的输入。\n//总调用数： 1\nmemoizedSum(1、2);// 返回 3。sum() 被调用，因为之前没有使用参数 (1, 2) 调用过。\n//总调用数： 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：\n</strong>\"factorial\"\n[\"call\",\"call\",\"call\",\"getCallCount\",\"call\",\"getCallCount\"]\n[[2],[3],[2],[],[3],[]]\n<strong>输出：</strong>\n[2,6,2,2,6,2]\n\n<strong>解释：</strong>\nconst factorial = (n) =&gt; (n &lt;= 1) ? 1 : (n * factorial(n - 1));\nconst memoFactorial = memoize(factorial);\nmemoFactorial(2); // 返回 2。\nmemoFactorial(3); // 返回 6。\nmemoFactorial(2); // 返回 2。 没有调用 factorial()，因为前面有相同的输入。\n// 总调用数：2\nmemoFactorial(3); // 返回 6。 没有调用 factorial()，因为前面有相同的输入。\n// 总调用数：2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：\n</strong>\"fib\"\n[\"call\",\"getCallCount\"]\n[[5],[]]\n<strong>输出：</strong>\n[8,1]\n\n<strong>解释：\n</strong>fib(5) = 8\n// 总调用数：1\n\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= a, b &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= n &lt;= 10</code></li>\n\t<li><code>at most 10<sup>5</sup>&nbsp;function calls</code></li>\n\t<li><code>at most 10<sup>5</sup>&nbsp;attempts to access callCount</code></li>\n\t<li><code>input function is sum, fib, or factorial</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2624蜗牛排序",
        "hardRate": "MEDIUM",
        "passRate": "65.17%",
        "problemsUrl": "https://leetcode.cn/problems/snail-traversal/",
        "solutionsUrl": "https://leetcode.cn/problems/snail-traversal/solution",
        "problemsDesc": "<p>请你编写一段代码为所有数组实现&nbsp;&nbsp;<code>snail(rowsCount，colsCount)</code> 方法，该方法将 1D 数组转换为以蜗牛排序的模式的 2D 数组。无效的输入值应该输出一个空数组。当 <code>rowsCount * colsCount&nbsp;!==</code><code>nums.length</code>&nbsp;时。这个输入被认为是无效的。</p>\n\n<p>蜗牛排序从左上角的单元格开始，从当前数组的第一个值开始。然后，它从上到下遍历第一列，接着移动到右边的下一列，并从下到上遍历它。将这种模式持续下去，每列交替变换遍历方向，直到覆盖整个数组。例如，当给定输入数组&nbsp;&nbsp;<code>[19, 10, 3, 7, 9, 8, 5, 2, 1, 17, 16, 14, 12, 18, 6, 13, 11, 20, 4, 15]</code> ，当 <code>rowsCount = 5</code>&nbsp;且&nbsp;<code>colsCount = 4</code> 时，需要输出矩阵如下图所示。注意，矩阵沿箭头方向对应于原数组中数字的顺序</p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"Traversal Diagram\" src=\"https://assets.leetcode.com/uploads/2023/04/10/screen-shot-2023-04-10-at-100006-pm.png\" style=\"width: 275px; height: 343px;\" /></p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre>\n<b>输入：</b>\nnums = [19, 10, 3, 7, 9, 8, 5, 2, 1, 17, 16, 14, 12, 18, 6, 13, 11, 20, 4, 15]\nrowsCount = 5\ncolsCount = 4\n<b>输出：</b>\n[\n [19,17,16,15],\n&nbsp;[10,1,14,4],\n&nbsp;[3,2,12,20],\n&nbsp;[7,5,18,11],\n&nbsp;[9,8,6,13]\n]\n</pre>\n\n<p><b>示例 2：</b></p>\n\n<pre>\n<b>输入：</b>\nnums = [1,2,3,4]\nrowsCount = 1\ncolsCount = 4\n<b>输出：</b>[[1, 2, 3, 4]]\n</pre>\n\n<p><b>示例 3：</b></p>\n\n<pre>\n<b>输入：</b>\nnums = [1,3]\nrowsCount = 2\ncolsCount = 2\n<b>输出：</b>[]\n<strong>Explanation:</strong> 2 * 2 = 4, 且原数组 [1,3] 的长度为 2; 所以，输入是无效的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 250</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= rowsCount &lt;= 250</code></li>\n\t<li><code>1 &lt;= colsCount &lt;= 250</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2625扁平化嵌套数组",
        "hardRate": "MEDIUM",
        "passRate": "50.64%",
        "problemsUrl": "https://leetcode.cn/problems/flatten-deeply-nested-array/",
        "solutionsUrl": "https://leetcode.cn/problems/flatten-deeply-nested-array/solution",
        "problemsDesc": "<p>请你编写一个函数，它接收一个&nbsp;<strong>多维数组&nbsp;</strong><code>arr</code> 和它的深度 <code>n</code> ，并返回该数组的&nbsp;<strong>扁平化&nbsp;</strong>后的结果。</p>\n\n<p><strong>多维数组&nbsp;</strong>是一种包含整数或其他&nbsp;<strong>多维数组&nbsp;</strong>的递归数据结构。</p>\n\n<p>数组 <strong>扁平化</strong> 是对数组的一种操作，定义是将原数组部分或全部子数组删除，并替换为该子数组中的实际元素。只有当嵌套的数组深度大于 <code>n</code> 时，才应该执行扁平化操作。第一层数组中元素的深度被认为是 0。</p>\n\n<p>请在没有使用内置方法&nbsp;<code>Array.flat</code> 的前提下解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\narr = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]\nn = 0\n<strong>输出</strong>\n[1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]\n\n<strong>解释</strong>\n传递深度 n=0 的多维数组将始终得到原始数组。这是因为 子数组(0) 的最小可能的深度不小于 n=0 。因此，任何子数组都不应该被平面化。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入</strong>\narr = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]\nn = 1\n<strong>输出</strong>\n[1, 2, 3, 4, 5, 6, 7, 8, [9, 10, 11], 12, 13, 14, 15]\n\n<strong>解释</strong>\n以 4 、7 和 13 开头的子数组都被扁平化了，这是因为它们的深度为 0 ， 而 0 小于 1 。然而 [9,10,11] 其深度为 1 ，所以未被扁平化。</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入</strong>\narr = [[1, 2, 3], [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]\nn = 2\n<strong>输出</strong>\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n\n<strong>解释</strong>\n所有子数组的最大深度都为 1 。因此，它们都被扁平化了。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= arr 的元素个数&nbsp;&lt;=&nbsp;10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= arr 的子数组个数&nbsp;&lt;=&nbsp;10<sup>5</sup></code></li>\n\t<li><code>maxDepth &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= each number &lt;= 1000</code></li>\n\t<li><code><font face=\"monospace\">0 &lt;= n &lt;= 1000</font></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2626数组归约运算",
        "hardRate": "EASY",
        "passRate": "77.40%",
        "problemsUrl": "https://leetcode.cn/problems/array-reduce-transformation/",
        "solutionsUrl": "https://leetcode.cn/problems/array-reduce-transformation/solution",
        "problemsDesc": "<p>请你编写一个函数，它的参数为一个整数数组&nbsp;<code>nums</code>&nbsp;、一个计算函数&nbsp;<code>fn</code>&nbsp;和初始值&nbsp;<font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">init&nbsp;</span></span></font></font>。返回一个数组&nbsp;<strong>归约后 </strong>的值。</p>\n\n<p>你可以定义一个数组&nbsp;<strong>归约后 </strong>的值，然后应用以下操作： <code>val = fn(init, nums[0])</code>&nbsp;， <code>val = fn(val, nums[1])</code>&nbsp;， <code>val = fn(val, nums[2])</code>&nbsp;，<code>...</code>&nbsp;直到数组中的每个元素都被处理完毕。返回 <code>val</code> 的最终值。</p>\n\n<p>如果数组的长度为 0，它应该返回 <code>init</code>&nbsp;的值。</p>\n\n<p>请你在不使用内置数组方法的&nbsp;<code>Array.reduce</code>&nbsp;前提下解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nnums = [1,2,3,4]\nfn = function sum(accum, curr) { return accum + curr; }\ninit = 0\n<strong>输出：</strong>10\n<strong>解释：</strong>\n初始值为 init=0 。\n(0) + nums[0] = 1\n(1) + nums[1] = 3\n(3) + nums[2] = 6\n(6) + nums[3] = 10\nVal 最终值为 10。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong> \nnums = [1,2,3,4]\nfn = function sum(accum, curr) { return accum + curr * curr; }\ninit = 100\n<strong>输出：</strong>130\n<strong>解释：</strong>\n初始值为 init=0 。\n(100) + nums[0]^2 = 101\n(101) + nums[1]^2 = 105\n(105) + nums[2]^2 = 114\n(114) + nums[3]^2 = 130\nVal 最终值为 130。\n</pre>\n\n<p><strong class=\"example\">示例3:</strong></p>\n\n<pre>\n<strong>输入：</strong> \nnums = []\nfn = function sum(accum, curr) { return 0; }\ninit = 25\n<strong>输出：</strong>25\n<b>解释：</b>这是一个空数组，所以返回 init 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= init &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2627函数防抖",
        "hardRate": "MEDIUM",
        "passRate": "77.08%",
        "problemsUrl": "https://leetcode.cn/problems/debounce/",
        "solutionsUrl": "https://leetcode.cn/problems/debounce/solution",
        "problemsDesc": "<p>请你编写一个函数，接收参数为另一个函数和一个以毫秒为单位的时间 <code>t</code> ，并返回该函数的&nbsp;<b>函数防抖&nbsp;</b>后的结果。</p>\n\n<p><b>函数防抖 </b>方法是一个函数，它的执行被延迟了 <code>t</code> 毫秒，如果在这个时间窗口内再次调用它，它的执行将被取消。你编写的防抖函数也应该接收传递的参数。</p>\n\n<p>例如，假设 <code>t = 50ms</code> ，函数分别在 <code>30ms</code> 、 <code>60ms</code> 和 <code>100ms</code> 时调用。前两个函数调用将被取消，第三个函数调用将在 <code>150ms</code> 执行。如果改为 <code>t = 35ms</code> ，则第一个调用将被取消，第二个调用将在 <code>95ms</code> 执行，第三个调用将在 <code>135ms</code> 执行。</p>\n\n<p><img alt=\"Debounce Schematic\" src=\"https://assets.leetcode.com/uploads/2023/04/08/screen-shot-2023-04-08-at-11048-pm.png\" style=\"width: 800px; height: 242px;\" /></p>\n\n<p>上图展示了了防抖函数是如何转换事件的。其中，每个矩形表示 100ms，反弹时间为 400ms。每种颜色代表一组不同的输入。</p>\n\n<p>请在不使用 lodash 的 <code>_.debounce()</code> 函数的前提下解决该问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>\nt = 50\ncalls = [\n&nbsp; {\"t\": 50, inputs: [1]},\n&nbsp; {\"t\": 75, inputs: [2]}\n]\n<b>输出：</b>[{\"t\": 125, inputs: [2]}]\n<strong>解释：</strong>\nlet start = Date.now();\nfunction log(...inputs) { \n&nbsp; console.log([Date.now() - start, inputs ])\n}\nconst dlog = debounce(log, 50);\nsetTimeout(() =&gt; dlog(1), 50);\nsetTimeout(() =&gt; dlog(2), 75);\n\n第一次调用被第二次调用取消，因为第二次调用发生在 100ms 之前\n第二次调用延迟 50ms，在 125ms 执行。输入为 (2)。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>\nt = 20\ncalls = [\n&nbsp; {\"t\": 50, inputs: [1]},\n&nbsp; {\"t\": 100, inputs: [2]}\n]\n<b>输出：</b>[{\"t\": 70, inputs: [1]}, {\"t\": 120, inputs: [2]}]\n<strong>解释：</strong>\n第一次调用延迟到 70ms。输入为 (1)。\n第二次调用延迟到 120ms。输入为 (2)。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>\nt = 150\ncalls = [\n&nbsp; {\"t\": 50, inputs: [1, 2]},\n&nbsp; {\"t\": 300, inputs: [3, 4]},\n&nbsp; {\"t\": 300, inputs: [5, 6]}\n]\n<b>输出：</b>[{\"t\": 200, inputs: [1,2]}, {\"t\": 450, inputs: [5, 6]}]\n<strong>解释：</strong>\n第一次调用延迟了 150ms，运行时间为 200ms。输入为 (1, 2)。\n第二次调用被第三次调用取消\n第三次调用延迟了 150ms，运行时间为 450ms。输入为 (5, 6)。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= t &lt;= 1000</code></li>\n\t<li><code>1 &lt;= calls.length &lt;= 10</code></li>\n\t<li><code>0 &lt;= calls[i].t &lt;= 1000</code></li>\n\t<li><code>0 &lt;= calls[i].inputs.length &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2628完全相等的 JSON 字符串",
        "hardRate": "MEDIUM",
        "passRate": "32.28%",
        "problemsUrl": "https://leetcode.cn/problems/json-deep-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/json-deep-equal/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2629复合函数",
        "hardRate": "EASY",
        "passRate": "81.73%",
        "problemsUrl": "https://leetcode.cn/problems/function-composition/",
        "solutionsUrl": "https://leetcode.cn/problems/function-composition/solution",
        "problemsDesc": "<p>请你编写一个函数，它接收一个函数数组 <code>[f<sub>1</sub>, f<sub>2</sub>, f<sub>3</sub>，…， f<sub>n</sub>]</code> ，并返回一个新的函数 <code>fn</code>&nbsp;，它是函数数组的 <strong>复合函数</strong> 。</p>\n\n<p><code>[f(x)， g(x)， h(x)]</code> 的 <strong>复合函数</strong> 为 <code>fn(x) = f(g(h(x)))</code>&nbsp;。</p>\n\n<p>一个空函数列表的 <strong>复合函数</strong> 是 <strong>恒等函数</strong> <code>f(x) = x</code> 。</p>\n\n<p>你可以假设数组中的每个函数接受一个整型参数作为输入，并返回一个整型作为输出。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>functions = [x =&gt; x + 1, x =&gt; x * x, x =&gt; 2 * x], x = 4\n<b>输出：</b>65\n<strong>解释：</strong>\n从右向左计算......\nStarting with x = 4.\n2 * (4) = 8\n(8) * (8) = 64\n(64) + 1 = 65\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输出：</b>functions = [x =&gt; 10 * x, x =&gt; 10 * x, x =&gt; 10 * x], x = 1\n<b>输入：</b>1000\n<strong>解释：</strong>\n从右向左计算......\n10 * (1) = 10\n10 * (10) = 100\n10 * (100) = 1000\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>functions = [], x = 42\n<b>输出：</b>42\n<strong>解释：</strong>\n空函数列表的复合函数就是恒等函数</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code><font face=\"monospace\">-1000 &lt;= x &lt;= 1000</font></code></li>\n\t<li><code><font face=\"monospace\">0 &lt;= functions.length &lt;= 1000</font></code></li>\n\t<li><font face=\"monospace\"><code>所有函数都接受并返回一个整型</code></font></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2630记忆函数 II",
        "hardRate": "HARD",
        "passRate": "42.11%",
        "problemsUrl": "https://leetcode.cn/problems/memoize-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/memoize-ii/solution",
        "problemsDesc": "<p>现给定一个函数 <code>fn</code> ，返回该函数的一个 <strong>记忆化</strong> 版本。</p>\n\n<p>一个 <strong>记忆化</strong> 的函数是一个函数，它不会被相同的输入调用两次。而是会返回一个缓存的值。</p>\n\n<p>函数 <code>fn</code> 可以是任何函数，对它所接受的值类型没有任何限制。如果两个输入值在 JavaScript 中使用 <code>===</code>&nbsp;运算符比较时相等，则它们被视为相同。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong> \ngetInputs = () =&gt; [[2,2],[2,2],[1,2]]\nfn = function (a, b) { return a + b; }\n<b>输出：</b>[{\"val\":4,\"calls\":1},{\"val\":4,\"calls\":1},{\"val\":3,\"calls\":2}]\n<strong>解释：</strong>\nconst inputs = getInputs();\nconst memoized = memoize(fn);\nfor (const arr of inputs) {\n  memoized(...arr);\n}\n\n对于参数为 (2, 2) 的输入: 2 + 2 = 4，需要调用 fn() 。\n对于参数为 (2, 2) 的输入: 2 + 2 = 4，这些输入之前已经出现过，因此不需要再次调用 fn()。\n对于参数为 (1, 2) 的输入: 1 + 2 = 3，需要再次调用 fn()，总共调用了 2 次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>\ngetInputs = () =&gt; [[{},{}],[{},{}],[{},{}]] \nfn = function (a, b) { return a + b; }\n<b>输出：</b>[{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":2},{\"val\":{},\"calls\":3}]\n<strong>解释：</strong>\n将两个空对象合并总是会得到一个空对象。尽管看起来应该缓存命中并只调用一次 <code>fn()</code>，但是这些空对象彼此之间都不是 <code>===</code> 相等的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong> \ngetInputs = () =&gt; { const o = {}; return [[o,o],[o,o],[o,o]]; }\nfn = function (a, b) { return ({...a, ...b}); }\n<b>输出：</b>[{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":1}]\n<strong>解释：</strong>\n将两个空对象合并总是会得到一个空对象。因为传入的每个对象都是相同的，所以第二个和第三个函数调用都会命中缓存。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= inputs.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= inputs.flat().length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>inputs[i][j] != NaN</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2631分组",
        "hardRate": "MEDIUM",
        "passRate": "79.84%",
        "problemsUrl": "https://leetcode.cn/problems/group-by/",
        "solutionsUrl": "https://leetcode.cn/problems/group-by/solution",
        "problemsDesc": "<p>请你编写一段可应用于所有数组的代码，使任何数组调用 <code>array. groupBy(fn)</code> 方法时，它返回对该数组 <strong>分组后</strong> 的结果。</p>\n\n<p>数组 <strong>分组</strong> 是一个对象，其中的每个键都是 <code>fn(arr[i])</code> 的输出的一个数组，该数组中含有原数组中具有该键的所有项。</p>\n\n<p>提供的回调函数 <code>fn</code> 将接受数组中的项并返回一个字符串类型的键。</p>\n\n<p>每个值列表的顺序应该与元素在数组中出现的顺序相同。任何顺序的键都是可以接受的。</p>\n\n<p>请在不使用 lodash 的&nbsp;<code>_.groupBy</code> 函数的前提下解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>\narray = [\n&nbsp; {\"id\":\"1\"},\n&nbsp; {\"id\":\"1\"},\n&nbsp; {\"id\":\"2\"}\n], \nfn = function (item) { \n&nbsp; return item.id; \n}\n<b>输出：</b>\n{ \n&nbsp; \"1\": [{\"id\": \"1\"}, {\"id\": \"1\"}], &nbsp; \n&nbsp; \"2\": [{\"id\": \"2\"}] \n}\n<strong>解释：</strong>\n输出来自函数 array.groupBy(fn)。\n分组选择方法是从数组中的每个项中获取 \"id\" 。\n有两个 \"id\" 为 1 的对象。所以将这两个对象都放在第一个数组中。\n有一个 \"id\" 为 2 的对象。所以该对象被放到第二个数组中。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>\narray = [\n&nbsp; [1, 2, 3],\n&nbsp; [1, 3, 5],\n&nbsp; [1, 5, 9]\n]\nfn = function (list) { \n&nbsp; return String(list[0]); \n}\n<b>输出：</b>\n{ \n&nbsp; \"1\": [[1, 2, 3], [1, 3, 5], [1, 5, 9]] \n}\n<strong>解释：</strong>\n数组可以是任何类型的。在本例中，分组选择方法是将键定义为数组中的第一个元素。\n所有数组的第一个元素都是1，所以它们被组合在一起。\n{\n  \"1\": [[1, 2, 3], [1, 3, 5], [1, 5, 9]]\n}\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输出：</b>\narray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nfn = function (n) { \n&nbsp; return String(n &gt; 5);\n}\n<strong>输入：</strong>\n{\n&nbsp; \"true\": [6, 7, 8, 9, 10],\n&nbsp; \"false\": [1, 2, 3, 4, 5]\n}\n<strong>解释：</strong>\n分组选择方法是根据每个数字是否大于 5 来分割数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= array.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>fn 返回一个字符串</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2632柯里化",
        "hardRate": "MEDIUM",
        "passRate": "81.58%",
        "problemsUrl": "https://leetcode.cn/problems/curry/",
        "solutionsUrl": "https://leetcode.cn/problems/curry/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2633将对象转换为 JSON 字符串",
        "hardRate": "MEDIUM",
        "passRate": "57.66%",
        "problemsUrl": "https://leetcode.cn/problems/convert-object-to-json-string/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-object-to-json-string/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2634过滤数组中的元素",
        "hardRate": "EASY",
        "passRate": "70.04%",
        "problemsUrl": "https://leetcode.cn/problems/filter-elements-from-array/",
        "solutionsUrl": "https://leetcode.cn/problems/filter-elements-from-array/solution",
        "problemsDesc": "<p>给定一个整数数组&nbsp;<code>arr</code> 和一个过滤函数 <code>fn</code>，并返回一个过滤后的数组 <code>filteredArr</code> 。</p>\n\n<p><code>fn</code> 函数接受一个或两个参数：</p>\n\n<ul>\n\t<li><code>arr[i]</code> - <code>arr</code> 中的数字</li>\n\t<li><code>i</code> - <code>arr[i]</code> 的索引</li>\n</ul>\n\n<p><code>filteredArr</code> 应该只包含使表达式 <code>fn(arr[i], i)</code> 的值为 <strong>真值</strong> 的 <code>arr</code> 中的元素。<strong>真值</strong> 是指 <code>Boolean(value)</code>&nbsp;返回参数为&nbsp;<code>true</code> 的值。</p>\n\n<p>请在不使用内置的 Array.filter 方法的情况下解决该问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,10,20,30], fn = function greaterThan10(n) { return n &gt; 10; }\n<b>输出：</b> [20,30]\n<b>解释：</b>\nconst newArray = filter(arr, fn); // [20, 30]\n过滤函数过滤掉不大于 10 的值</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [1,2,3], fn = function firstIndex(n, i) { return i === 0; }\n<b>输出：</b>[1]\n<strong>解释：</strong>\n过滤函数 fn 也可以接受每个元素的索引\n在这种情况下，过滤函数删除索引不为 0 的元素\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [-2,-1,0,1,2], fn = function plusOne(n) { return n + 1 }\n<b>输出：</b>[-2,0,1,2]\n<strong>解释：</strong>\n像 0 这样的假值应被过滤掉\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code><font face=\"monospace\">-10<sup>9</sup>&nbsp;&lt;= arr[i] &lt;= 10<sup>9</sup></font></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2635转换数组中的每个元素",
        "hardRate": "EASY",
        "passRate": "74.00%",
        "problemsUrl": "https://leetcode.cn/problems/apply-transform-over-each-element-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/apply-transform-over-each-element-in-array/solution",
        "problemsDesc": "<p>编写一个函数，这个函数接收一个整数数组&nbsp;<code>arr</code> 和一个映射函数&nbsp; <code>fn</code>&nbsp;，通过该映射函数返回一个新的数组。</p>\n\n<p>返回数组的创建语句应为 <code>returnedArray[i] = fn(arr[i], i)</code>&nbsp;。</p>\n\n<p>请你在不使用内置方法&nbsp;<code>Array.map</code>&nbsp;的前提下解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3], fn = function plusone(n) { return n + 1; }\n<strong>输出：</strong>[2,3,4]\n<strong>解释： </strong>\nconst newArray = map(arr, plusone); // [2,3,4]\n此映射函数返回值是将数组中每个元素的值加 1。\n</pre>\n\n<p><strong class=\"example\">示例</strong><strong class=\"example\"> 2:</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3], fn = function plusI(n, i) { return n + i; }\n<strong>输出：</strong>[1,3,5]\n<strong>解释：</strong>此映射函数返回值根据输入数组索引增加每个值。\n</pre>\n\n<p><strong class=\"example\">示例&nbsp;3:</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [10,20,30], fn = function constant() { return 42; }\n<strong>输出：</strong>[42,42,42]\n<strong>解释：</strong>此映射函数返回值恒为 42。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code><font face=\"monospace\">-10<sup>9</sup>&nbsp;&lt;= arr[i] &lt;= 10<sup>9</sup></font></code></li>\n\t<li><font face=\"monospace\"><code>fn 返回一个数</code></font></li>\n</ul>\n<span style=\"display:block\"><span style=\"height:0px\"><span style=\"position:absolute\">​​​​​​</span></span></span>",
        "isPlus": false
    },
    {
        "problemsName": " 2636Promise 对象池",
        "hardRate": "MEDIUM",
        "passRate": "62.04%",
        "problemsUrl": "https://leetcode.cn/problems/promise-pool/",
        "solutionsUrl": "https://leetcode.cn/problems/promise-pool/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2637有时间限制的 Promise 对象",
        "hardRate": "EASY",
        "passRate": "61.81%",
        "problemsUrl": "https://leetcode.cn/problems/promise-time-limit/",
        "solutionsUrl": "https://leetcode.cn/problems/promise-time-limit/solution",
        "problemsDesc": "<p>请你编写一个函数，它接受一个异步函数 <code>fn</code>&nbsp;和一个以毫秒为单位的时间 <code>t</code>。它应根据限时函数返回一个有 <strong>限时</strong> 效果的函数。函数 <code>fn</code> 接受提供给 <strong>限时</strong> 函数的参数。</p>\n\n<p><strong>限时</strong> 函数应遵循以下规则：</p>\n\n<ul>\n\t<li>如果 <code>fn</code> 在 <code>t</code> 毫秒的时间限制内完成，<strong>限时</strong> 函数应返回结果。</li>\n\t<li>如果 <code>fn</code> 的执行超过时间限制，<strong>限时&nbsp;</strong>函数应拒绝并返回字符串 <code>\"Time Limit Exceeded\"</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre>\n<b>输入：</b>\nfn = async (n) =&gt; { \n&nbsp; await new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp; return n * n; \n}\ninputs = [5]\nt = 50\n<b>输出：</b>{\"rejected\":\"Time Limit Exceeded\",\"time\":50}\n<b>解释：</b>\nconst limited = timeLimit(fn, t)\nconst start = performance.now()\nlet result;\ntry {\n&nbsp; &nbsp;const res = await limited(...inputs)\n&nbsp; &nbsp;result = {\"resolved\": res, \"time\": Math.floor(performance.now() - start)};\n} catch (err) {\n&nbsp;  result = {\"rejected\": err, \"time\": Math.floor(performance.now() - start)};\n}\nconsole.log(result) // 输出结果\n<b>\n</b>提供的函数设置在 100ms 后执行完成，但是设置的超时时间为 50ms，所以在 t=50ms 时拒绝因为达到了超时时间。\n</pre>\n\n<p><b>示例 2：</b></p>\n\n<pre>\n<b>输入：</b>\nfn = async (n) =&gt; { \n&nbsp; await new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp; return n * n; \n}\ninputs = [5]\nt = 150\n<b>输出：</b>{\"resolved\":25,\"time\":100}\n<b>解释：</b>\n在 t=100ms 时执行 5*5=25 ，没有达到超时时间。\n</pre>\n\n<p><b>示例 3：</b></p>\n\n<pre>\n<b>输入：</b>\nfn = async (a, b) =&gt; { \n&nbsp; await new Promise(res =&gt; setTimeout(res, 120)); \n&nbsp; return a + b; \n}\ninputs = [5,10]\nt = 150\n<b>输出：</b>{\"resolved\":15,\"time\":120}\n<b>解释：\n</b>在 t=120ms 时执行 5+10=15，没有达到超时时间。\n</pre>\n\n<p><b>示例 4：</b></p>\n\n<pre>\n<b>输入：</b>\nfn = async () =&gt; { \n&nbsp; throw \"Error\";\n}\ninputs = []\nt = 1000\n<b>输出：</b>{\"rejected\":\"Error\",\"time\":0}\n<b>解释：</b>\n此函数始终丢出 Error</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>0 &lt;= inputs.length &lt;= 10</code></li>\n\t<li><code>0 &lt;= t &lt;= 1000</code></li>\n\t<li><code>fn 返回一个 Promise 对象</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2638统计 K-Free 子集的总数",
        "hardRate": "MEDIUM",
        "passRate": "59.26%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-k-free-subsets/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-k-free-subsets/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2639查询网格图中每一列的宽度",
        "hardRate": "EASY",
        "passRate": "76.38%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-width-of-columns-of-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-width-of-columns-of-a-grid/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;整数矩阵&nbsp;<code>grid</code>&nbsp;。矩阵中某一列的宽度是这一列数字的最大 <strong>字符串长度</strong>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，如果&nbsp;<code>grid = [[-10], [3], [12]]</code>&nbsp;，那么唯一一列的宽度是&nbsp;<code>3</code>&nbsp;，因为&nbsp;<code>-10</code>&nbsp;的字符串长度为&nbsp;<code>3</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回一个大小为 <code>n</code>&nbsp;的整数数组&nbsp;<code>ans</code>&nbsp;，其中&nbsp;<code>ans[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;列的宽度。</p>\n\n<p>一个有 <code>len</code>&nbsp;个数位的整数 <code>x</code>&nbsp;，如果是非负数，那么&nbsp;<strong>字符串</strong><strong>长度</strong>&nbsp;为&nbsp;<code>len</code>&nbsp;，否则为&nbsp;<code>len + 1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>grid = [[1],[22],[333]]\n<b>输出：</b>[3]\n<b>解释：</b>第 0 列中，333 字符串长度为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>grid = [[-15,1,3],[15,7,12],[5,6,-2]]\n<b>输出：</b>[3,1,2]\n<b>解释：</b>\n第 0 列中，只有 -15 字符串长度为 3 。\n第 1 列中，所有整数的字符串长度都是 1 。\n第 2 列中，12 和 -2 的字符串长度都为 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100 </code></li>\n\t<li><code>-10<sup>9</sup> &lt;= grid[r][c] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2640一个数组所有前缀的分数",
        "hardRate": "MEDIUM",
        "passRate": "79.58%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-score-of-all-prefixes-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-score-of-all-prefixes-of-an-array/solution",
        "problemsDesc": "<p>定义一个数组 <code>arr</code>&nbsp;的 <strong>转换数组</strong>&nbsp;<code>conver</code>&nbsp;为：</p>\n\n<ul>\n\t<li><code>conver[i] = arr[i] + max(arr[0..i])</code>，其中&nbsp;<code>max(arr[0..i])</code>&nbsp;是满足 <code>0 &lt;= j &lt;= i</code>&nbsp;的所有&nbsp;<code>arr[j]</code>&nbsp;中的最大值。</li>\n</ul>\n\n<p>定义一个数组 <code>arr</code>&nbsp;的 <strong>分数</strong>&nbsp;为 <code>arr</code>&nbsp;转换数组中所有元素的和。</p>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;，请你返回一个长度为 <code>n</code>&nbsp;的数组<em>&nbsp;</em><code>ans</code>&nbsp;，其中&nbsp;<code>ans[i]</code>是前缀&nbsp;<code>nums[0..i]</code>&nbsp;的分数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,3,7,5,10]\n<b>输出：</b>[4,10,24,36,56]\n<b>解释：</b>\n对于前缀 [2] ，转换数组为 [4] ，所以分数为 4 。\n对于前缀 [2, 3] ，转换数组为 [4, 6] ，所以分数为 10 。\n对于前缀 [2, 3, 7] ，转换数组为 [4, 6, 14] ，所以分数为 24 。\n对于前缀 [2, 3, 7, 5] ，转换数组为 [4, 6, 14, 12] ，所以分数为 36 。\n对于前缀 [2, 3, 7, 5, 10] ，转换数组为 [4, 6, 14, 12, 20] ，所以分数为 56 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,1,2,4,8,16]\n<b>输出：</b>[2,4,8,16,32,64]\n<b>解释：</b>\n对于前缀 [1] ，转换数组为 [2] ，所以分数为 2 。\n对于前缀 [1, 1]，转换数组为 [2, 2] ，所以分数为 4 。\n对于前缀 [1, 1, 2]，转换数组为 [2, 2, 4] ，所以分数为 8 。\n对于前缀 [1, 1, 2, 4]，转换数组为 [2, 2, 4, 8] ，所以分数为 16 。\n对于前缀 [1, 1, 2, 4, 8]，转换数组为 [2, 2, 4, 8, 16] ，所以分数为 32 。\n对于前缀 [1, 1, 2, 4, 8, 16]，转换数组为 [2, 2, 4, 8, 16, 32] ，所以分数为 64 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2641二叉树的堂兄弟节点 II",
        "hardRate": "MEDIUM",
        "passRate": "70.20%",
        "problemsUrl": "https://leetcode.cn/problems/cousins-in-binary-tree-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/cousins-in-binary-tree-ii/solution",
        "problemsDesc": "<p>给你一棵二叉树的根&nbsp;<code>root</code>&nbsp;，请你将每个节点的值替换成该节点的所有 <strong>堂兄弟节点值的和&nbsp;</strong>。</p>\n\n<p>如果两个节点在树中有相同的深度且它们的父节点不同，那么它们互为 <strong>堂兄弟</strong>&nbsp;。</p>\n\n<p>请你返回修改值之后，树的根<em>&nbsp;</em><code>root</code><em>&nbsp;</em>。</p>\n\n<p><strong>注意</strong>，一个节点的深度指的是从树根节点到这个节点经过的边数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/11/example11.png\" style=\"width: 571px; height: 151px;\" /></p>\n\n<pre>\n<b>输入：</b>root = [5,4,9,1,10,null,7]\n<b>输出：</b>[0,0,0,7,7,null,11]\n<b>解释：</b>上图展示了初始的二叉树和修改每个节点的值之后的二叉树。\n- 值为 5 的节点没有堂兄弟，所以值修改为 0 。\n- 值为 4 的节点没有堂兄弟，所以值修改为 0 。\n- 值为 9 的节点没有堂兄弟，所以值修改为 0 。\n- 值为 1 的节点有一个堂兄弟，值为 7 ，所以值修改为 7 。\n- 值为 10 的节点有一个堂兄弟，值为 7 ，所以值修改为 7 。\n- 值为 7 的节点有两个堂兄弟，值分别为 1 和 10 ，所以值修改为 11 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/11/diagram33.png\" style=\"width: 481px; height: 91px;\" /></p>\n\n<pre>\n<b>输入：</b>root = [3,1,2]\n<b>输出：</b>[0,0,0]\n<b>解释：</b>上图展示了初始的二叉树和修改每个节点的值之后的二叉树。\n- 值为 3 的节点没有堂兄弟，所以值修改为 0 。\n- 值为 1 的节点没有堂兄弟，所以值修改为 0 。\n- 值为 2 的节点没有堂兄弟，所以值修改为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目的范围是&nbsp;<code>[1, 10<sup>5</sup>]</code> 。</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2642设计可以求最短路径的图类",
        "hardRate": "HARD",
        "passRate": "55.58%",
        "problemsUrl": "https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/",
        "solutionsUrl": "https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/solution",
        "problemsDesc": "<p>给你一个有&nbsp;<code>n</code>&nbsp;个节点的&nbsp;<strong>有向带权</strong>&nbsp;图，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。图中的初始边用数组&nbsp;<code>edges</code>&nbsp;表示，其中&nbsp;<code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>, edgeCost<sub>i</sub>]</code>&nbsp;表示从&nbsp;<code>from<sub>i</sub></code>&nbsp;到&nbsp;<code>to<sub>i</sub></code>&nbsp;有一条代价为&nbsp;<code>edgeCost<sub>i</sub></code>&nbsp;的边。</p>\n\n<p>请你实现一个&nbsp;<code>Graph</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>Graph(int n, int[][] edges)</code>&nbsp;初始化图有&nbsp;<code>n</code>&nbsp;个节点，并输入初始边。</li>\n\t<li><code>addEdge(int[] edge)</code>&nbsp;向边集中添加一条边，其中<strong>&nbsp;</strong><code>edge = [from, to, edgeCost]</code>&nbsp;。数据保证添加这条边之前对应的两个节点之间没有有向边。</li>\n\t<li><code>int shortestPath(int node1, int node2)</code>&nbsp;返回从节点&nbsp;<code>node1</code>&nbsp;到&nbsp;<code>node2</code>&nbsp;的路径<strong>&nbsp;最小</strong>&nbsp;代价。如果路径不存在，返回&nbsp;<code>-1</code>&nbsp;。一条路径的代价是路径中所有边代价之和。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/11/graph3drawio-2.png\" style=\"width: 621px; height: 191px;\"></p>\n\n<pre><strong>输入：</strong>\n[\"Graph\", \"shortestPath\", \"shortestPath\", \"addEdge\", \"shortestPath\"]\n[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]\n<b>输出：</b>\n[null, 6, -1, null, 6]\n\n<strong>解释：</strong>\nGraph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);\ng.shortestPath(3, 2); // 返回 6 。从 3 到 2 的最短路径如第一幅图所示：3 -&gt; 0 -&gt; 1 -&gt; 2 ，总代价为 3 + 2 + 1 = 6 。\ng.shortestPath(0, 3); // 返回 -1 。没有从 0 到 3 的路径。\ng.addEdge([1, 3, 4]); // 添加一条节点 1 到节点 3 的边，得到第二幅图。\ng.shortestPath(0, 3); // 返回 6 。从 0 到 3 的最短路径为 0 -&gt; 1 -&gt; 3 ，总代价为 2 + 4 = 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= edges.length &lt;= n * (n - 1)</code></li>\n\t<li><code>edges[i].length == edge.length == 3</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub>, from, to, node1, node2 &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= edgeCost<sub>i</sub>, edgeCost &lt;= 10<sup>6</sup></code></li>\n\t<li>图中任何时候都不会有重边和自环。</li>\n\t<li>调用 <code>addEdge</code>&nbsp;至多&nbsp;<code>100</code>&nbsp;次。</li>\n\t<li>调用 <code>shortestPath</code>&nbsp;至多&nbsp;<code>100</code>&nbsp;次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2643一最多的行",
        "hardRate": "EASY",
        "passRate": "80.22%",
        "problemsUrl": "https://leetcode.cn/problems/row-with-maximum-ones/",
        "solutionsUrl": "https://leetcode.cn/problems/row-with-maximum-ones/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>mat</code> ，请你找出包含最多 <strong>1</strong> 的行的下标（从 <strong>0</strong> 开始）以及这一行中 <strong>1</strong> 的数目。</p>\n\n<p>如果有多行包含最多的 1 ，只需要选择 <strong>行下标最小</strong> 的那一行。</p>\n\n<p>返回一个由行下标和该行中 1 的数量组成的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[0,1],[1,0]]\n<strong>输出：</strong>[0,1]\n<strong>解释：</strong>两行中 1 的数量相同。所以返回下标最小的行，下标为 0 。该行 1 的数量为 1 。所以，答案为 [0,1] 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[0,0,0],[0,1,1]]\n<strong>输出：</strong>[1,2]\n<strong>解释：</strong>下标为 1 的行中 1 的数量最多<code>。</code>该行 1 的数量<code>为 2 。所以，答案为</code> [1,2] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[0,0],[1,1],[0,0]]\n<strong>输出：</strong>[1,2]\n<strong>解释：</strong>下标为 1 的行中 1 的数量最多。该行 1 的数量<code>为 2 。所以，答案为</code> [1,2] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code>&nbsp;</li>\n\t<li><code>n == mat[i].length</code>&nbsp;</li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code>&nbsp;</li>\n\t<li><code>mat[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2644找出可整除性得分最大的整数",
        "hardRate": "EASY",
        "passRate": "50.15%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-maximum-divisibility-score/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-maximum-divisibility-score/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和 <code>divisors</code> 。</p>\n\n<p><code>divisors[i]</code> 的 <strong>可整除性得分</strong> 等于满足 <code>nums[j]</code> 能被 <code>divisors[i]</code> 整除的下标 <code>j</code> 的数量。</p>\n\n<p>返回 <strong>可整除性得分</strong> 最大的整数 <code>divisors[i]</code> 。如果有多个整数具有最大得分，则返回数值最小的一个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,7,9,3,9], divisors = [5,2,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>divisors 中每个元素的可整除性得分为：\ndivisors[0] 的可整除性得分为 0 ，因为 nums 中没有任何数字能被 5 整除。\ndivisors[1] 的可整除性得分为 1 ，因为 nums[0] 能被 2 整除。 \ndivisors[2] 的可整除性得分为 3 ，因为 nums[2]、nums[3] 和 nums[4] 都能被 3 整除。 \n因此，返回 divisors[2] ，它的可整除性得分最大。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [20,14,21,10], divisors = [5,7,5]\n<strong>输出：</strong>5\n<strong>解释：</strong>divisors 中每个元素的可整除性得分为：\ndivisors[0] 的可整除性得分为 2 ，因为 nums[0] 和 nums[3] 都能被 5 整除。\ndivisors[1] 的可整除性得分为 2 ，因为 nums[1] 和 nums[2] 都能被 7 整除。\ndivisors[2] 的可整除性得分为 2 ，因为 nums[0] 和 nums[3] 都能被5整除。 \n由于 divisors[0]、divisors[1] 和 divisors[2] 的可整除性得分都是最大的，因此，我们返回数值最小的一个，即 divisors[2] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [12], divisors = [10,16]\n<strong>输出：</strong>10\n<strong>解释：</strong>divisors 中每个元素的可整除性得分为：\ndivisors[0] 的可整除性得分为 0 ，因为 nums 中没有任何数字能被 10 整除。\ndivisors[1] 的可整除性得分为 0 ，因为 nums 中没有任何数字能被 16 整除。 \n由于 divisors[0] 和 divisors[1] 的可整除性得分都是最大的，因此，我们返回数值最小的一个，即 divisors[0] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, divisors.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i], divisors[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2645构造有效字符串的最少插入数",
        "hardRate": "MEDIUM",
        "passRate": "56.51%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-additions-to-make-valid-string/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-additions-to-make-valid-string/solution",
        "problemsDesc": "<p>给你一个字符串 <code>word</code> ，你可以向其中任何位置插入 \"a\"、\"b\" 或 \"c\" 任意次，返回使 <code>word</code> <strong>有效</strong> 需要插入的最少字母数。</p>\n\n<p>如果字符串可以由 \"abc\" 串联多次得到，则认为该字符串 <strong>有效</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>word = \"b\"\n<strong>输出：</strong>2\n<strong>解释：</strong>在 \"b\" 之前插入 \"a\" ，在 \"b\" 之后插入 \"c\" 可以得到有效字符串 \"<strong>a</strong>b<strong>c</strong>\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>word = \"aaa\"\n<strong>输出：</strong>6\n<strong>解释：</strong>在每个 \"a\" 之后依次插入 \"b\" 和 \"c\" 可以得到有效字符串 \"a<strong>bc</strong>a<strong>bc</strong>a<strong>bc</strong>\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>word = \"abc\"\n<strong>输出：</strong>0\n<strong>解释：</strong>word 已经是有效字符串，不需要进行修改。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 50</code></li>\n\t<li><code>word</code> 仅由字母 \"a\"、\"b\" 和 \"c\" 组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2646最小化旅行的价格总和",
        "hardRate": "HARD",
        "passRate": "49.86%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/solution",
        "problemsDesc": "<p>现有一棵无向、无根的树，树中有 <code>n</code> 个节点，按从 <code>0</code> 到 <code>n - 1</code> 编号。给你一个整数 <code>n</code> 和一个长度为 <code>n - 1</code> 的二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示树中节点 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间存在一条边。</p>\n\n<p>每个节点都关联一个价格。给你一个整数数组 <code>price</code> ，其中 <code>price[i]</code> 是第 <code>i</code> 个节点的价格。</p>\n\n<p>给定路径的 <strong>价格总和</strong> 是该路径上所有节点的价格之和。</p>\n\n<p>另给你一个二维整数数组 <code>trips</code> ，其中 <code>trips[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 表示您从节点 <code>start<sub>i</sub></code> 开始第 <code>i</code> 次旅行，并通过任何你喜欢的路径前往节点 <code>end<sub>i</sub></code> 。</p>\n\n<p>在执行第一次旅行之前，你可以选择一些 <strong>非相邻节点</strong> 并将价格减半。</p>\n\n<p>返回执行所有旅行的最小价格总和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/16/diagram2.png\" style=\"width: 541px; height: 181px;\">\n<pre><strong>输入：</strong>n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]\n<strong>输出：</strong>23\n<strong>解释：\n</strong>上图表示将节点 2 视为根之后的树结构。第一个图表示初始树，第二个图表示选择节点 0 、2 和 3 并使其价格减半后的树。\n第 1 次旅行，选择路径 [0,1,3] 。路径的价格总和为 1 + 2 + 3 = 6 。\n第 2 次旅行，选择路径 [2,1] 。路径的价格总和为 2 + 5 = 7 。\n第 3 次旅行，选择路径 [2,1,3] 。路径的价格总和为 5 + 2 + 3 = 10 。\n所有旅行的价格总和为 6 + 7 + 10 = 23 。可以证明，23 是可以实现的最小答案。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/16/diagram3.png\" style=\"width: 456px; height: 111px;\">\n<pre><strong>输入：</strong>n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n上图表示将节点 0 视为根之后的树结构。第一个图表示初始树，第二个图表示选择节点 0 并使其价格减半后的树。 \n第 1 次旅行，选择路径 [0] 。路径的价格总和为 1 。 \n所有旅行的价格总和为 1 。可以证明，1 是可以实现的最小答案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>edges</code> 表示一棵有效的树</li>\n\t<li><code>price.length == n</code></li>\n\t<li><code>price[i]</code> 是一个偶数</li>\n\t<li><code>1 &lt;= price[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= trips.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub>, end<sub>i</sub>&nbsp;&lt;= n - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2647把三角形染成红色",
        "hardRate": "HARD",
        "passRate": "68.63%",
        "problemsUrl": "https://leetcode.cn/problems/color-the-triangle-red/",
        "solutionsUrl": "https://leetcode.cn/problems/color-the-triangle-red/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2648生成斐波那契数列",
        "hardRate": "EASY",
        "passRate": "83.50%",
        "problemsUrl": "https://leetcode.cn/problems/generate-fibonacci-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/generate-fibonacci-sequence/solution",
        "problemsDesc": "<p>请你编写一个生成器函数，并返回一个可以生成 <strong>斐波那契数列</strong> 的生成器对象。</p>\n\n<p><strong>斐波那契数列</strong> 的递推公式为 <code>X<sub>n</sub>&nbsp;= X<sub>n-1</sub>&nbsp;+ X<sub>n-2</sub></code> 。</p>\n\n<p>这个数列的前几个数字是 <code>0, 1, 1, 2, 3, 5, 8, 13</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>callCount = 5\n<b>输出：</b>[0,1,1,2,3]\n<strong>解释：</strong>\nconst gen = fibGenerator();\ngen.next().value; // 0\ngen.next().value; // 1\ngen.next().value; // 1\ngen.next().value; // 2\ngen.next().value; // 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>callCount = 0\n<strong>输出：</strong>[]\n<b>解释：</b>gen.next() 永远不会被调用，所以什么也不会输出\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= callCount &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2649嵌套数组生成器",
        "hardRate": "MEDIUM",
        "passRate": "77.53%",
        "problemsUrl": "https://leetcode.cn/problems/nested-array-generator/",
        "solutionsUrl": "https://leetcode.cn/problems/nested-array-generator/solution",
        "problemsDesc": "<p>现给定一个整数的 <strong>多维数组</strong> ，请你返回一个生成器对象，按照&nbsp;<strong>中序遍历</strong> 的顺序逐个生成整数。</p>\n\n<p><strong>多维数组</strong> 是一个递归数据结构，包含整数和其他 <strong>多维数组</strong>。</p>\n\n<p><strong>中序遍历</strong> 是从左到右遍历每个数组，在遇到任何整数时生成它，遇到任何数组时递归应用 <strong>中序遍历</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [[[6]],[1,3],[]]\n<b>输出：</b>[6,1,3]\n<strong>解释：</strong>\nconst generator = inorderTraversal(arr);\ngenerator.next().value; // 6\ngenerator.next().value; // 1\ngenerator.next().value; // 3\ngenerator.next().done; // true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>arr = []\n<b>输出：</b>[]\n<b>解释：</b>输入的多维数组没有任何参数，所以生成器不需要生成任何值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= arr.flat().length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= arr.flat()[i]&nbsp;&lt;= 10<sup>5</sup></code></li>\n\t<li><code>maxNestingDepth &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2650设计可取消函数",
        "hardRate": "HARD",
        "passRate": "49.86%",
        "problemsUrl": "https://leetcode.cn/problems/design-cancellable-function/",
        "solutionsUrl": "https://leetcode.cn/problems/design-cancellable-function/solution",
        "problemsDesc": "<p>有时候你会有一个长时间运行的任务，并且你可能希望在它完成之前取消它。为了实现这个目标，请你编写一个名为 <code>cancellable</code> 的函数，它接收一个生成器对象，并返回一个包含两个值的数组：一个 <strong>取消函数</strong> 和一个 <strong>promise</strong> 对象。</p>\n\n<p>你可以假设生成器函数只会生成 promise 对象。你的函数负责将 promise 对象解析的值传回生成器。如果 promise 被拒绝，你的函数应将该错误抛回给生成器。</p>\n\n<p>如果在生成器完成之前调用了取消回调函数，则你的函数应该将错误抛回给生成器。该错误应该是字符串 <code>\"Cancelled\"</code>（而不是一个 <code>Error</code> 对象）。如果错误被捕获，则返回的 promise 应该解析为下一个生成或返回的值。否则，promise 应该被拒绝并抛出该错误。不应执行任何其他代码。</p>\n\n<p>当生成器完成时，您的函数返回的 promise 应该解析为生成器返回的值。但是，如果生成器抛出错误，则返回的 promise 应该拒绝并抛出该错误。</p>\n\n<p>下面是您的代码应如何使用的示例：</p>\n\n<pre>\nfunction* tasks() {\n  const val = yield new Promise(resolve =&gt; resolve(2 + 2));\n  yield new Promise(resolve =&gt; setTimeout(resolve, 100));\n  return val + 1; // calculation shouldn't be done.\n}\nconst [cancel, promise] = cancellable(tasks());\nsetTimeout(cancel, 50);\npromise.catch(console.log); // logs \"Cancelled\" at t=50ms\n</pre>\n\n<p>如果相反， <code>cancel()</code> 没有被调用或者在 <code>t=100ms</code> 之后才被调用，那么 Promise 应被解析为 <code>5</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>\ngeneratorFunction = function*() { \n&nbsp; return 42; \n}\ncancelledAt = 100\n<b>输出：</b>{\"resolved\": 42}\n<strong>解释：</strong>\nconst generator = generatorFunction();\nconst [cancel, promise] = cancellable(generator);\nsetTimeout(cancel, 100);\npromise.then(console.log); // 在 t=0ms 解析为 42\n\n该生成器立即生成 42 并完成。因此，返回的 promise 立即解析为 42。请注意，取消已经完成的生成器没有任何作用。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>\ngeneratorFunction = function*() { \n&nbsp; const msg = yield new Promise(res =&gt; res(\"Hello\")); \n&nbsp; throw `Error: ${msg}`; \n}\ncancelledAt = null\n<b>输出：</b>{\"rejected\": \"Error: Hello\"}\n<strong>解释：</strong>\n一个 Promise 被生成。该函数通过等待 promise 解析并将解析后的值传回生成器来处理它。然后抛出一个错误，这会导致 promise 被同样抛出的错误拒绝。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>\ngeneratorFunction = function*() { \n&nbsp; yield new Promise(res =&gt; setTimeout(res, 200)); \n&nbsp; return \"Success\"; \n}\ncancelledAt = 100\n<b>输出：</b>{\"rejected\": \"Cancelled\"}\n<strong>解释：</strong>\n当函数等待被生成的 promise 解析时，cancel() 被调用。这会导致一个错误消息被发送回生成器。由于这个错误没有被捕获，返回的 promise 会因为这个错误而被拒绝。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>\ngeneratorFunction = function*() { \n&nbsp; let result = 0; \n&nbsp; yield new Promise(res =&gt; setTimeout(res, 100));\n&nbsp; result += yield new Promise(res =&gt; res(1)); \n&nbsp; yield new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp; result += yield new Promise(res =&gt; res(1)); \n&nbsp; return result;\n}\ncancelledAt = null\n<b>输出：</b>{\"resolved\": 2}\n<strong>解释：</strong>\n生成器生成了 4 个 promise 。其中两个 promise 的值被添加到结果中。200ms 后，生成器以值 2 完成，该值被返回的 promise 解析。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<b>输入：</b>\ngeneratorFunction = function*() { \n&nbsp; let result = 0; \n&nbsp; try { \n&nbsp;   yield new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp;   result += yield new Promise(res =&gt; res(1)); \n&nbsp;   yield new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp;   result += yield new Promise(res =&gt; res(1)); \n&nbsp; } catch(e) { \n&nbsp;   return result; \n&nbsp; } \n&nbsp; return result; \n}\ncancelledAt = 150\n<b>输出：</b>{\"resolved\": 1}\n<strong>解释：</strong>\n前两个生成的 promise 解析并导致结果递增。然而，在 t=150ms 时，生成器被取消了。发送给生成器的错误被捕获，结果被返回并最终由返回的 promise 解析。\n</pre>\n\n<p><strong>示例 6：</strong></p>\n\n<pre>\n<b>输入：</b>\ngeneratorFunction = function*() { \n&nbsp; try { \n&nbsp;   yield new Promise((resolve, reject) =&gt; reject(\"Promise Rejected\")); \n&nbsp; } catch(e) { \n&nbsp;   let a = yield new Promise(resolve =&gt; resolve(2));\n    let b = yield new Promise(resolve =&gt; resolve(2)); \n&nbsp;   return a + b; \n&nbsp; }; \n}\ncancelledAt = null\n<b>输出：</b>{\"resolved\": 4}\n<strong>解释：</strong>\n第一个生成的 promise 立即被拒绝。该错误被捕获。因为生成器没有被取消，执行继续像往常一样。最终解析为 2 + 2 = 4。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>cancelledAt == null or 0 &lt;= cancelledAt &lt;= 1000</code></li>\n\t<li><code>generatorFunction 返回一个生成器对象</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2651计算列车到站时间",
        "hardRate": "EASY",
        "passRate": "86.77%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-delayed-arrival-time/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-delayed-arrival-time/solution",
        "problemsDesc": "<p>给你一个正整数 <code>arrivalTime</code> 表示列车正点到站的时间（单位：小时），另给你一个正整数 <code>delayedTime</code> 表示列车延误的小时数。</p>\n\n<p>返回列车实际到站的时间。</p>\n\n<p>注意，该问题中的时间采用 24 小时制。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arrivalTime = 15, delayedTime = 5 \n<strong>输出：</strong>20 \n<strong>解释：</strong>列车正点到站时间是 15:00 ，延误 5 小时，所以列车实际到站的时间是 15 + 5 = 20（20:00）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arrivalTime = 13, delayedTime = 11\n<strong>输出：</strong>0\n<strong>解释：</strong>列车正点到站时间是 13:00 ，延误 11 小时，所以列车实际到站的时间是 13 + 11 = 24（在 24 小时制中表示为 00:00 ，所以返回 0）。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arrivaltime &lt;&nbsp;24</code></li>\n\t<li><code>1 &lt;= delayedTime &lt;= 24</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2652倍数求和",
        "hardRate": "EASY",
        "passRate": "83.58%",
        "problemsUrl": "https://leetcode.cn/problems/sum-multiples/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-multiples/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> ，请你计算在 <code>[1，n]</code> 范围内能被 <code>3</code>、<code>5</code>、<code>7</code> 整除的所有整数之和。</p>\n\n<p>返回一个整数，用于表示给定范围内所有满足约束条件的数字之和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 7\n<strong>输出：</strong>21\n<strong>解释：</strong>在 <code>[1, 7]</code> 范围内能被 3、<code>5、</code><code>7 整除的所有整数分别是</code><code> 3、5、6、7</code> 。数字之和为 <code>21</code> 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 10\n<strong>输出：</strong>40\n<strong>解释：</strong>在 <code>[1, 10]</code> 范围内能被 3、<code>5、</code><code>7 整除的所有整数分别是</code><code> 3、5、6、7、9、10</code> 。数字之和为 <code>40</code> 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 9\n<strong>输出：</strong>30\n<strong>解释：</strong>在 <code>[1, 9]</code> 范围内能被 3、<code>5、</code><code>7 整除的所有整数分别是</code><code> 3、5、6、7、9</code> 。数字之和为 <code>30</code> 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>3</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2653滑动子数组的美丽值",
        "hardRate": "MEDIUM",
        "passRate": "34.99%",
        "problemsUrl": "https://leetcode.cn/problems/sliding-subarray-beauty/",
        "solutionsUrl": "https://leetcode.cn/problems/sliding-subarray-beauty/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;，请你求出每个长度为&nbsp;<code>k</code>&nbsp;的子数组的 <b>美丽值</b>&nbsp;。</p>\n\n<p>一个子数组的 <strong>美丽值</strong>&nbsp;定义为：如果子数组中第 <code>x</code>&nbsp;<strong>小整数</strong>&nbsp;是 <strong>负数</strong>&nbsp;，那么美丽值为第 <code>x</code>&nbsp;小的数，否则美丽值为 <code>0</code>&nbsp;。</p>\n\n<p>请你返回一个包含<em>&nbsp;</em><code>n - k + 1</code>&nbsp;个整数的数组，<strong>依次</strong>&nbsp;表示数组中从第一个下标开始，每个长度为&nbsp;<code>k</code>&nbsp;的子数组的<strong>&nbsp;美丽值</strong>&nbsp;。</p>\n\n<ul>\n\t<li>\n\t<p>子数组指的是数组中一段连续 <strong>非空</strong>&nbsp;的元素序列。</p>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,-1,-3,-2,3], k = 3, x = 2\n<b>输出：</b>[-1,-2,-2]\n<b>解释：</b>总共有 3 个 k = 3 的子数组。\n第一个子数组是 <code>[1, -1, -3]</code> ，第二小的数是负数 -1 。\n第二个子数组是 <code>[-1, -3, -2]</code> ，第二小的数是负数 -2 。\n第三个子数组是 <code>[-3, -2, 3]&nbsp;，第二小的数是负数 -2 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [-1,-2,-3,-4,-5], k = 2, x = 2\n<b>输出：</b>[-1,-2,-3,-4]\n<b>解释：</b>总共有 4 个 k = 2 的子数组。\n<code>[-1, -2] 中第二小的数是负数 -1 。</code>\n<code>[-2, -3] 中第二小的数是负数 -2 。</code>\n<code>[-3, -4] 中第二小的数是负数 -3 。</code>\n<code>[-4, -5] 中第二小的数是负数 -4 。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [-3,1,2,-3,0,-3], k = 2, x = 1\n<b>输出：</b>[-3,0,-3,-3,-3]\n<b>解释：</b>总共有 5 个 k = 2 的子数组。\n<code>[-3, 1] 中最小的数是负数 -3 。</code>\n<code>[1, 2] 中最小的数不是负数，所以美丽值为 0 。</code>\n<code>[2, -3] 中最小的数是负数 -3 。</code>\n<code>[-3, 0] 中最小的数是负数 -3 。</code>\n<code>[0, -3] 中最小的数是负数 -3 。</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length&nbsp;</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n\t<li><code>1 &lt;= x &lt;= k&nbsp;</code></li>\n\t<li><code>-50&nbsp;&lt;= nums[i] &lt;= 50&nbsp;</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2654使数组所有元素变成 1 的最少操作次数",
        "hardRate": "MEDIUM",
        "passRate": "40.17%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的 <strong>正</strong>&nbsp;整数数组&nbsp;<code>nums</code>&nbsp;。你可以对数组执行以下操作 <strong>任意</strong>&nbsp;次：</p>\n\n<ul>\n\t<li>选择一个满足&nbsp;<code>0 &lt;= i &lt; n - 1</code>&nbsp;的下标 <code>i</code>&nbsp;，将&nbsp;<code>nums[i]</code> 或者&nbsp;<code>nums[i+1]</code>&nbsp;两者之一替换成它们的最大公约数。</li>\n</ul>\n\n<p>请你返回使数组 <code>nums</code>&nbsp;中所有元素都等于 <code>1</code>&nbsp;的 <strong>最少</strong>&nbsp;操作次数。如果无法让数组全部变成 <code>1</code>&nbsp;，请你返回 <code>-1</code>&nbsp;。</p>\n\n<p>两个正整数的最大公约数指的是能整除这两个数的最大正整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,6,3,4]\n<b>输出：</b>4\n<b>解释：</b>我们可以执行以下操作：\n- 选择下标 i = 2 ，将 nums[2] 替换为 gcd(3,4) = 1 ，得到 nums = [2,6,1,4] 。\n- 选择下标 i = 1 ，将 nums[1] 替换为 gcd(6,1) = 1 ，得到 nums = [2,1,1,4] 。\n- 选择下标 i = 0 ，将 nums[0] 替换为 gcd(2,1) = 1 ，得到 nums = [1,1,1,4] 。\n- 选择下标 i = 2 ，将 nums[3] 替换为 gcd(1,4) = 1 ，得到 nums = [1,1,1,1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,10,6,14]\n<b>输出：</b>-1\n<b>解释：</b>无法将所有元素都变成 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2655寻找最大长度的未覆盖区间",
        "hardRate": "MEDIUM",
        "passRate": "60.80%",
        "problemsUrl": "https://leetcode.cn/problems/find-maximal-uncovered-ranges/",
        "solutionsUrl": "https://leetcode.cn/problems/find-maximal-uncovered-ranges/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2656K 个元素的最大和",
        "hardRate": "EASY",
        "passRate": "84.13%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-with-exactly-k-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-with-exactly-k-elements/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code> 和一个整数&nbsp;<code>k</code>&nbsp;。你需要执行以下操作<strong>&nbsp;恰好</strong> <code>k</code>&nbsp;次，最大化你的得分：</p>\n\n<ol>\n\t<li>从 <code>nums</code>&nbsp;中选择一个元素&nbsp;<code>m</code>&nbsp;。</li>\n\t<li>将选中的元素&nbsp;<code>m</code>&nbsp;从数组中删除。</li>\n\t<li>将新元素&nbsp;<code>m + 1</code>&nbsp;添加到数组中。</li>\n\t<li>你的得分增加&nbsp;<code>m</code>&nbsp;。</li>\n</ol>\n\n<p>请你返回执行以上操作恰好 <code>k</code>&nbsp;次后的最大得分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4,5], k = 3\n<b>输出：</b>18\n<b>解释：</b>我们需要从 nums 中恰好选择 3 个元素并最大化得分。\n第一次选择 5 。和为 5 ，nums = [1,2,3,4,6] 。\n第二次选择 6 。和为 6 ，nums = [1,2,3,4,7] 。\n第三次选择 7 。和为 5 + 6 + 7 = 18 ，nums = [1,2,3,4,8] 。\n所以我们返回 18 。\n18 是可以得到的最大答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5,5,5], k = 2\n<b>输出：</b>11\n<b>解释：</b>我们需要从 nums 中恰好选择 2 个元素并最大化得分。\n第一次选择 5 。和为 5 ，nums = [5,5,6] 。\n第二次选择 6 。和为 6 ，nums = [5,5,7] 。\n所以我们返回 11 。\n11 是可以得到的最大答案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2657找到两个数组的前缀公共数组",
        "hardRate": "MEDIUM",
        "passRate": "83.31%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-prefix-common-array-of-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-prefix-common-array-of-two-arrays/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数排列&nbsp;<code>A</code> 和&nbsp;<code>B</code>&nbsp;。</p>\n\n<p><code>A</code>&nbsp;和&nbsp;<code>B</code>&nbsp;的 <strong>前缀公共数组</strong>&nbsp;定义为数组&nbsp;<code>C</code>&nbsp;，其中&nbsp;<code>C[i]</code>&nbsp;是数组&nbsp;<code>A</code> 和&nbsp;<code>B</code>&nbsp;到下标为&nbsp;<code>i</code>&nbsp;之前公共元素的数目。</p>\n\n<p>请你返回 <code>A</code>&nbsp;和 <code>B</code>&nbsp;的 <strong>前缀公共数组</strong>&nbsp;。</p>\n\n<p>如果一个长度为 <code>n</code>&nbsp;的数组包含 <code>1</code>&nbsp;到 <code>n</code>&nbsp;的元素恰好一次，我们称这个数组是一个长度为 <code>n</code>&nbsp;的 <strong>排列</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>A = [1,3,2,4], B = [3,1,2,4]\n<b>输出：</b>[0,2,3,4]\n<b>解释：</b>i = 0：没有公共元素，所以 C[0] = 0 。\ni = 1：1 和 3 是两个数组的前缀公共元素，所以 C[1] = 2 。\ni = 2：1，2 和 3 是两个数组的前缀公共元素，所以 C[2] = 3 。\ni = 3：1，2，3 和 4 是两个数组的前缀公共元素，所以 C[3] = 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>A = [2,3,1], B = [3,1,2]\n<b>输出：</b>[0,1,3]\n<b>解释：</b>i = 0：没有公共元素，所以 C[0] = 0 。\ni = 1：只有 3 是公共元素，所以 C[1] = 1 。\ni = 2：1，2 和 3 是两个数组的前缀公共元素，所以 C[2] = 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= A.length == B.length == n &lt;= 50</code></li>\n\t<li><code>1 &lt;= A[i], B[i] &lt;= n</code></li>\n\t<li>题目保证&nbsp;<code>A</code>&nbsp;和&nbsp;<code>B</code>&nbsp;两个数组都是&nbsp;<code>n</code>&nbsp;个元素的排列。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2658网格图中鱼的最大数目",
        "hardRate": "MEDIUM",
        "passRate": "60.54%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-fish-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-fish-in-a-grid/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始大小为 <code>m x n</code>&nbsp;的二维整数数组&nbsp;<code>grid</code>&nbsp;，其中下标在&nbsp;<code>(r, c)</code>&nbsp;处的整数表示：</p>\n\n<ul>\n\t<li>如果&nbsp;<code>grid[r][c] = 0</code>&nbsp;，那么它是一块 <strong>陆地</strong>&nbsp;。</li>\n\t<li>如果&nbsp;<code>grid[r][c] &gt; 0</code>&nbsp;，那么它是一块&nbsp;<strong>水域</strong>&nbsp;，且包含&nbsp;<code>grid[r][c]</code>&nbsp;条鱼。</li>\n</ul>\n\n<p>一位渔夫可以从任意 <strong>水域</strong>&nbsp;格子&nbsp;<code>(r, c)</code>&nbsp;出发，然后执行以下操作任意次：</p>\n\n<ul>\n\t<li>捕捞格子&nbsp;<code>(r, c)</code>&nbsp;处所有的鱼，或者</li>\n\t<li>移动到相邻的 <strong>水域</strong>&nbsp;格子。</li>\n</ul>\n\n<p>请你返回渔夫最优策略下，&nbsp;<strong>最多</strong>&nbsp;可以捕捞多少条鱼。如果没有水域格子，请你返回 <code>0</code>&nbsp;。</p>\n\n<p>格子&nbsp;<code>(r, c)</code>&nbsp;<strong>相邻</strong>&nbsp;的格子为&nbsp;<code>(r, c + 1)</code>&nbsp;，<code>(r, c - 1)</code>&nbsp;，<code>(r + 1, c)</code> 和&nbsp;<code>(r - 1, c)</code>&nbsp;，前提是相邻格子在网格图内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/29/example.png\" style=\"width: 241px; height: 161px;\"></p>\n\n<pre><b>输入：</b>grid = [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]\n<b>输出：</b>7\n<b>解释：</b>渔夫可以从格子 <code>(1,3)</code> 出发，捕捞 3 条鱼，然后移动到格子 <code>(2,3)</code>&nbsp;，捕捞 4 条鱼。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/29/example2.png\"></p>\n\n<pre><b>输入：</b>grid = [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]\n<b>输出：</b>1\n<b>解释：</b>渔夫可以从格子 (0,0) 或者 (3,3) ，捕捞 1 条鱼。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2659将数组清空",
        "hardRate": "HARD",
        "passRate": "38.52%",
        "problemsUrl": "https://leetcode.cn/problems/make-array-empty/",
        "solutionsUrl": "https://leetcode.cn/problems/make-array-empty/solution",
        "problemsDesc": "<p>给你一个包含若干 <strong>互不相同</strong>&nbsp;整数的数组&nbsp;<code>nums</code>&nbsp;，你需要执行以下操作 <strong>直到</strong><strong>数组为空</strong>&nbsp;：</p>\n\n<ul>\n\t<li>如果数组中第一个元素是当前数组中的 <strong>最小值</strong>&nbsp;，则删除它。</li>\n\t<li>否则，将第一个元素移动到数组的 <strong>末尾</strong>&nbsp;。</li>\n</ul>\n\n<p>请你返回需要多少个操作使<em>&nbsp;</em><code>nums</code><em>&nbsp;</em>为空。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,4,-1]\n<b>输出：</b>5\n</pre>\n\n<table style=\"border: 2px solid black; border-collapse: collapse;\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Operation</th>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Array</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">1</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[4, -1, 3]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">2</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[-1, 3, 4]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">3</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[3, 4]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">4</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[4]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">5</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[]</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,4,3]\n<b>输出：</b>5\n</pre>\n\n<table style=\"border: 2px solid black; border-collapse: collapse;\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Operation</th>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Array</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">1</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[2, 4, 3]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">2</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[4, 3]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">3</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[3, 4]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">4</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[4]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">5</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[]</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3]\n<b>输出：</b>3\n</pre>\n\n<table style=\"border: 2px solid black; border-collapse: collapse;\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Operation</th>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Array</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">1</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[2, 3]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">2</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[3]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">3</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[]</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9&nbsp;</sup>&lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums</code>&nbsp;中的元素 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2660保龄球游戏的获胜者",
        "hardRate": "EASY",
        "passRate": "33.52%",
        "problemsUrl": "https://leetcode.cn/problems/determine-the-winner-of-a-bowling-game/",
        "solutionsUrl": "https://leetcode.cn/problems/determine-the-winner-of-a-bowling-game/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong> 开始的整数数组 <code>player1</code> 和 <code>player2</code> ，分别表示玩家 1 和玩家 2 击中的瓶数。</p>\n\n<p>保龄球比赛由 <code>n</code> 轮组成，每轮的瓶数恰好为 <code>10</code> 。</p>\n\n<p>假设玩家在第 <code>i</code> 轮中击中&nbsp;<code>x<sub>i</sub></code> 个瓶子。玩家第 <code>i</code> 轮的价值为：</p>\n\n<ul>\n\t<li>如果玩家在该轮的前两轮的任何一轮中击中了 <code>10</code> 个瓶子，则为 <code>2x<sub>i</sub></code> 。</li>\n\t<li>否则，为&nbsp;<code>x<sub>i</sub></code> 。</li>\n</ul>\n\n<p>玩家的得分是其 <code>n</code> 轮价值的总和。</p>\n\n<p>返回</p>\n\n<ul>\n\t<li>如果玩家 1 的得分高于玩家 2 的得分，则为 <code>1</code> ；</li>\n\t<li>如果玩家 2 的得分高于玩家 1 的得分，则为 <code>2</code> ；</li>\n\t<li>如果平局，则为 <code>0</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>player1 = [4,10,7,9], player2 = [6,5,2,3]\n<strong>输出：</strong>1\n<strong>解释：</strong>player1 的得分是 4 + 10 + 2*7 + 2*9 = 46 。\nplayer2 的得分是 6 + 5 + 2 + 3 = 16 。\nplayer1 的得分高于 player2 的得分，所以 play1 在比赛中获胜，答案为 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>player1 = [3,5,7,6], player2 = [8,10,10,2]\n<strong>输出：</strong>2\n<strong>解释：</strong>player1 的得分是 3 + 5 + 7 + 6 = 21 。\nplayer2 的得分是 8 + 10 + 2*10 + 2*2 = 42 。\nplayer2 的得分高于 player1 的得分，所以 play2 在比赛中获胜，答案为 2 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>player1 = [2,3], player2 = [4,1]\n<strong>输出：</strong>0\n<strong>解释：</strong>player1 的得分是 2 + 3 = 5 。\nplayer2 的得分是 4 + 1 = 5 。\nplayer1 的得分等于 player2 的得分，所以这一场比赛平局，答案为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == player1.length == player2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= player1[i], player2[i] &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2661找出叠涂元素",
        "hardRate": "MEDIUM",
        "passRate": "51.16%",
        "problemsUrl": "https://leetcode.cn/problems/first-completely-painted-row-or-column/",
        "solutionsUrl": "https://leetcode.cn/problems/first-completely-painted-row-or-column/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>arr</code> 和一个 <code>m x n</code> 的整数 <strong>矩阵</strong> <code>mat</code> 。<code>arr</code> 和 <code>mat</code> 都包含范围 <code>[1，m * n]</code> 内的 <strong>所有</strong> 整数。</p>\n\n<p>从下标 <code>0</code> 开始遍历 <code>arr</code> 中的每个下标 <code>i</code> ，并将包含整数 <code>arr[i]</code> 的 <code>mat</code> 单元格涂色。</p>\n\n<p>请你找出 <code>arr</code> 中在 <code>mat</code> 的某一行或某一列上都被涂色且下标最小的元素，并返回其下标 <code>i</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"image explanation for example 1\" src=\"https://assets.leetcode.com/uploads/2023/01/18/grid1.jpg\" style=\"width: 321px; height: 81px;\" />\n<pre>\n<strong>输入：</strong>arr = [1,3,4,2], mat = [[1,4],[2,3]]\n<strong>输出：</strong>2\n<strong>解释：</strong>遍历如上图所示，arr[2] 在矩阵中的第一行或第二列上都被涂色。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"image explanation for example 2\" src=\"https://assets.leetcode.com/uploads/2023/01/18/grid2.jpg\" style=\"width: 601px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]]\n<strong>输出：</strong>3\n<strong>解释：</strong>遍历如上图所示，arr[3] 在矩阵中的第二列上都被涂色。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n = mat[i].length</code></li>\n\t<li><code>arr.length == m * n</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i], mat[r][c] &lt;= m * n</code></li>\n\t<li><code>arr</code> 中的所有整数 <strong>互不相同</strong></li>\n\t<li><code>mat</code> 中的所有整数 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2662前往目标的最小代价",
        "hardRate": "MEDIUM",
        "passRate": "36.37%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-of-a-path-with-special-roads/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-of-a-path-with-special-roads/solution",
        "problemsDesc": "<p>给你一个数组 <code>start</code> ，其中 <code>start = [startX, startY]</code> 表示你的初始位置位于二维空间上的 <code>(startX, startY)</code> 。另给你一个数组 <code>target</code> ，其中 <code>target = [targetX, targetY]</code> 表示你的目标位置 <code>(targetX, targetY)</code> 。</p>\n\n<p>从位置 <code>(x1, y1)</code> 到空间中任一其他位置 <code>(x2, y2)</code> 的代价是 <code>|x2 - x1| + |y2 - y1|</code> 。</p>\n\n<p>给你一个二维数组 <code>specialRoads</code> ，表示空间中存在的一些特殊路径。其中 <code>specialRoads[i] = [x1<sub>i</sub>, y1<sub>i</sub>, x2<sub>i</sub>, y2<sub>i</sub>, cost<sub>i</sub>]</code> 表示第 <code>i</code> 条特殊路径可以从 <code>(x1<sub>i</sub>, y1<sub>i</sub>)</code> 到 <code>(x2<sub>i</sub>, y2<sub>i</sub>)</code> ，但成本等于 <code>cost<sub>i</sub></code> 。你可以使用每条特殊路径任意次数。</p>\n\n<p>返回从 <code>(startX, startY)</code> 到 <code>(targetX, targetY)</code> 所需的最小代价。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>start = [1,1], target = [4,5], specialRoads = [[1,2,3,3,2],[3,4,4,5,1]]\n<strong>输出：</strong>5\n<strong>解释：</strong>从 (1,1) 到 (4,5) 的最优路径如下：\n- (1,1) -&gt; (1,2) ，移动的代价是 |1 - 1| + |2 - 1| = 1 。\n- (1,2) -&gt; (3,3) ，移动使用第一条特殊路径，代价是 2 。\n- (3,3) -&gt; (3,4) ，移动的代价是 |3 - 3| + |4 - 3| = 1.\n- (3,4) -&gt; (4,5) ，移动使用第二条特殊路径，代价是 1 。\n总代价是 1 + 2 + 1 + 1 = 5 。\n可以证明无法以小于 5 的代价完成从 (1,1) 到 (4,5) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>start = [3,2], target = [5,7], specialRoads = [[3,2,3,4,4],[3,3,5,5,5],[3,4,5,6,6]]\n<strong>输出：</strong>7\n<strong>解释：</strong>最优路径是不使用任何特殊路径，直接以 |5 - 3| + |7 - 2| = 7 的代价从初始位置到达目标位置。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>start.length == target.length == 2</code></li>\n\t<li><code>1 &lt;= startX &lt;= targetX &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= startY &lt;= targetY &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= specialRoads.length &lt;= 200</code></li>\n\t<li><code>specialRoads[i].length == 5</code></li>\n\t<li><code>startX &lt;= x1<sub>i</sub>, x2<sub>i</sub> &lt;= targetX</code></li>\n\t<li><code>startY &lt;= y1<sub>i</sub>, y2<sub>i</sub> &lt;= targetY</code></li>\n\t<li><code>1 &lt;= cost<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2663字典序最小的美丽字符串",
        "hardRate": "HARD",
        "passRate": "45.72%",
        "problemsUrl": "https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/",
        "solutionsUrl": "https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/solution",
        "problemsDesc": "<p>如果一个字符串满足以下条件，则称其为 <strong>美丽字符串</strong> ：</p>\n\n<ul>\n\t<li>它由英语小写字母表的前 <code>k</code> 个字母组成。</li>\n\t<li>它不包含任何长度为 <code>2</code> 或更长的回文子字符串。</li>\n</ul>\n\n<p>给你一个长度为 <code>n</code> 的美丽字符串 <code>s</code> 和一个正整数 <code>k</code> 。</p>\n\n<p>请你找出并返回一个长度为 <code>n</code> 的美丽字符串，该字符串还满足：在字典序大于 <code>s</code> 的所有美丽字符串中字典序最小。如果不存在这样的字符串，则返回一个空字符串。</p>\n\n<p>对于长度相同的两个字符串 <code>a</code> 和 <code>b</code> ，如果字符串 <code>a</code> 在与字符串 <code>b</code> 不同的第一个位置上的字符字典序更大，则字符串 <code>a</code> 的字典序大于字符串 <code>b</code> 。</p>\n\n<ul>\n\t<li>例如，<code>\"abcd\"</code> 的字典序比 <code>\"abcc\"</code> 更大，因为在不同的第一个位置（第四个字符）上 <code>d</code> 的字典序大于 <code>c</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcz\", k = 26\n<strong>输出：</strong>\"abda\"\n<strong>解释：</strong>字符串 \"abda\" 既是美丽字符串，又满足字典序大于 \"abcz\" 。\n可以证明不存在字符串同时满足字典序大于 \"abcz\"、美丽字符串、字典序小于 \"abda\" 这三个条件。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"dc\", k = 4\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>可以证明，不存在既是美丽字符串，又字典序大于 \"dc\" 的字符串。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>4 &lt;= k &lt;= 26</code></li>\n\t<li><code>s</code> 是一个美丽字符串</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2664巡逻的骑士",
        "hardRate": "MEDIUM",
        "passRate": "64.22%",
        "problemsUrl": "https://leetcode.cn/problems/the-knights-tour/",
        "solutionsUrl": "https://leetcode.cn/problems/the-knights-tour/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2665计数器 II",
        "hardRate": "EASY",
        "passRate": "62.30%",
        "problemsUrl": "https://leetcode.cn/problems/counter-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/counter-ii/solution",
        "problemsDesc": "<p>请你写一个函数&nbsp;<code>createCounter</code>. 这个函数接收一个初始的整数值 <code>init</code>&nbsp;&nbsp;并返回一个包含三个函数的对象。</p>\n\n<p>这三个函数是：</p>\n\n<ul>\n\t<li><code>increment()</code>&nbsp;将当前值加 1 并返回。</li>\n\t<li><code>decrement()</code>&nbsp;将当前值减 1 并返回。</li>\n\t<li><code>reset()</code>&nbsp;将当前值设置为 <code>init</code> 并返回。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>init = 5, calls = [\"increment\",\"reset\",\"decrement\"]\n<b>输出：</b>[6,5,4]\n<strong>解释：</strong>\nconst counter = createCounter(5);\ncounter.increment(); // 6\ncounter.reset(); // 5\ncounter.decrement(); // 4\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>init = 0, calls = [\"increment\",\"increment\",\"decrement\",\"reset\",\"reset\"]\n<b>输出：</b>[1,2,1,0,0]\n<strong>解释：</strong>\nconst counter = createCounter(0);\ncounter.increment(); // 1\ncounter.increment(); // 2\ncounter.decrement(); // 1\ncounter.reset(); // 0\ncounter.reset(); // 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-1000 &lt;= init &lt;= 1000</code></li>\n\t<li><code>总调用次数不会超过&nbsp;1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2666只允许一次函数调用",
        "hardRate": "EASY",
        "passRate": "81.77%",
        "problemsUrl": "https://leetcode.cn/problems/allow-one-function-call/",
        "solutionsUrl": "https://leetcode.cn/problems/allow-one-function-call/solution",
        "problemsDesc": "<p>给定一个函数 <code>fn</code> ，它返回一个新的函数，返回的函数与原始函数完全相同，只不过它确保 <code>fn</code> 最多被调用一次。</p>\n\n<ul>\n\t<li>第一次调用返回的函数时，它应该返回与 <code>fn</code> 相同的结果。</li>\n\t<li>第一次后的每次调用，它应该返回 <code>undefined</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre>\n<b>输入：</b>fn = (a,b,c) =&gt; (a + b + c), calls = [[1,2,3],[2,3,6]]\n<b>输出：</b>[{\"calls\":1,\"value\":6}]\n<strong>解释：</strong>\nconst onceFn = once(fn);\nonceFn(1, 2, 3); // 6\nonceFn(2, 3, 6); // undefined, fn 没有被调用\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>fn = (a,b,c) =&gt; (a * b * c), calls = [[5,7,4],[2,3,6],[4,6,8]]\n<b>输出：</b>[{\"calls\":1,\"value\":140}]\n<strong>解释：</strong>\nconst onceFn = once(fn);\nonceFn(5, 7, 4); // 140\nonceFn(2, 3, 6); // undefined, fn 没有被调用\nonceFn(4, 6, 8); // undefined, fn 没有被调用\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= calls.length &lt;= 10</code></li>\n\t<li><code>1 &lt;= calls[i].length &lt;= 100</code></li>\n\t<li><code>2 &lt;= JSON.stringify(calls).length &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2667创建 Hello World 函数",
        "hardRate": "EASY",
        "passRate": "86.60%",
        "problemsUrl": "https://leetcode.cn/problems/create-hello-world-function/",
        "solutionsUrl": "https://leetcode.cn/problems/create-hello-world-function/solution",
        "problemsDesc": "请你编写一个名为 <code>createHelloWorld</code> 的函数。它应该返回一个新的函数，该函数总是返回 <code>\"Hello World\"</code>&nbsp;。\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>args = []\n<b>输出：</b>\"Hello World\"\n<strong>解释：</strong>\nconst f = createHelloWorld();\nf(); // \"Hello World\"\n\ncreateHelloWorld 返回的函数应始终返回 \"Hello World\"。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>args = [{},null,42]\n<b>输出：</b>\"Hello World\"\n<strong>解释：</strong>\nconst f = createHelloWorld();\nf({}, null, 42); // \"Hello World\"\n\n可以传递任何参数给函数，但它应始终返回 \"Hello World\"。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= args.length &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2668查询员工当前薪水",
        "hardRate": "EASY",
        "passRate": "67.92%",
        "problemsUrl": "https://leetcode.cn/problems/find-latest-salaries/",
        "solutionsUrl": "https://leetcode.cn/problems/find-latest-salaries/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2669统计 Spotify 排行榜上艺术家出现次数",
        "hardRate": "EASY",
        "passRate": "72.36%",
        "problemsUrl": "https://leetcode.cn/problems/count-artist-occurrences-on-spotify-ranking-list/",
        "solutionsUrl": "https://leetcode.cn/problems/count-artist-occurrences-on-spotify-ranking-list/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2670找出不同元素数目差数组",
        "hardRate": "EASY",
        "passRate": "75.70%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-distinct-difference-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-distinct-difference-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，数组长度为 <code>n</code> 。</p>\n\n<p><code>nums</code> 的 <strong>不同元素数目差</strong> 数组可以用一个长度为 <code>n</code> 的数组 <code>diff</code> 表示，其中 <code>diff[i]</code> 等于前缀 <code>nums[0, ..., i]</code> 中不同元素的数目 <strong>减去</strong> 后缀 <code>nums[i + 1, ..., n - 1]</code> 中不同元素的数目。</p>\n\n<p>返回<em> </em><code>nums</code> 的 <strong>不同元素数目差</strong> 数组。</p>\n\n<p>注意 <code>nums[i, ..., j]</code> 表示 <code>nums</code> 的一个从下标 <code>i</code> 开始到下标 <code>j</code> 结束的子数组（包含下标 <code>i</code> 和 <code>j</code> 对应元素）。特别需要说明的是，如果 <code>i &gt; j</code> ，则 <code>nums[i, ..., j]</code> 表示一个空子数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4,5]\n<strong>输出：</strong>[-3,-1,1,3,5]\n<strong>解释：\n</strong>对于 i = 0，前缀中有 1 个不同的元素，而在后缀中有 4 个不同的元素。因此，diff[0] = 1 - 4 = -3 。\n对于 i = 1，前缀中有 2 个不同的元素，而在后缀中有 3 个不同的元素。因此，diff[1] = 2 - 3 = -1 。\n对于 i = 2，前缀中有 3 个不同的元素，而在后缀中有 2 个不同的元素。因此，diff[2] = 3 - 2 = 1 。\n对于 i = 3，前缀中有 4 个不同的元素，而在后缀中有 1 个不同的元素。因此，diff[3] = 4 - 1 = 3 。\n对于 i = 4，前缀中有 5 个不同的元素，而在后缀中有 0 个不同的元素。因此，diff[4] = 5 - 0 = 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,3,4,2]\n<strong>输出：</strong>[-2,-1,0,2,3]\n<strong>解释：</strong>\n对于 i = 0，前缀中有 1 个不同的元素，而在后缀中有 3 个不同的元素。因此，diff[0] = 1 - 3 = -2 。\n对于 i = 1，前缀中有 2 个不同的元素，而在后缀中有 3 个不同的元素。因此，diff[1] = 2 - 3 = -1 。\n对于 i = 2，前缀中有 2 个不同的元素，而在后缀中有 2 个不同的元素。因此，diff[2] = 2 - 2 = 0 。\n对于 i = 3，前缀中有 3 个不同的元素，而在后缀中有 1 个不同的元素。因此，diff[3] = 3 - 1 = 2 。\n对于 i = 4，前缀中有 3 个不同的元素，而在后缀中有 0 个不同的元素。因此，diff[4] = 3 - 0 = 3 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == nums.length&nbsp;&lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2671频率跟踪器",
        "hardRate": "MEDIUM",
        "passRate": "32.48%",
        "problemsUrl": "https://leetcode.cn/problems/frequency-tracker/",
        "solutionsUrl": "https://leetcode.cn/problems/frequency-tracker/solution",
        "problemsDesc": "<p>请你设计并实现一个能够对其中的值进行跟踪的数据结构，并支持对频率相关查询进行应答。</p>\n\n<p>实现 <code>FrequencyTracker</code> 类：</p>\n\n<ul>\n\t<li><code>FrequencyTracker()</code>：使用一个空数组初始化 <code>FrequencyTracker</code> 对象。</li>\n\t<li><code>void add(int number)</code>：添加一个 <code>number</code> 到数据结构中。</li>\n\t<li><code>void deleteOne(int number)</code>：从数据结构中删除一个 <code>number</code> 。数据结构 <strong>可能不包含</strong> <code>number</code> ，在这种情况下不删除任何内容。</li>\n\t<li><code>bool hasFrequency(int frequency)</code>: 如果数据结构中存在出现 <code>frequency</code> 次的数字，则返回 <code>true</code>，否则返回 <code>false</code>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"FrequencyTracker\", \"add\", \"add\", \"hasFrequency\"]\n[[], [3], [3], [2]]\n<strong>输出</strong>\n[null, null, null, true]\n\n<strong>解释</strong>\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.add(3); // 数据结构现在包含 [3]\nfrequencyTracker.add(3); // 数据结构现在包含 [3, 3]\nfrequencyTracker.hasFrequency(2); // 返回 true ，因为 3 出现 2 次\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"FrequencyTracker\", \"add\", \"deleteOne\", \"hasFrequency\"]\n[[], [1], [1], [1]]\n<strong>输出</strong>\n[null, null, null, false]\n\n<strong>解释</strong>\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.add(1); // 数据结构现在包含 [1]\nfrequencyTracker.deleteOne(1); // 数据结构现在为空 []\nfrequencyTracker.hasFrequency(1); // 返回 false ，因为数据结构为空\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"FrequencyTracker\", \"hasFrequency\", \"add\", \"hasFrequency\"]\n[[], [2], [3], [1]]\n<strong>输出</strong>\n[null, false, null, true]\n\n<strong>解释</strong>\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.hasFrequency(2); // 返回 false ，因为数据结构为空\nfrequencyTracker.add(3); // 数据结构现在包含 [3]\nfrequencyTracker.hasFrequency(1); // 返回 true ，因为 3 出现 1 次\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= number &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= frequency &lt;= 10<sup>5</sup></code></li>\n\t<li>最多调用 <code>add</code>、<code>deleteOne</code> 和 <code>hasFrequency</code> <strong>共计</strong> <code>2 *&nbsp;10<sup>5</sup></code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2672有相同颜色的相邻元素数目",
        "hardRate": "MEDIUM",
        "passRate": "58.34%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-adjacent-elements-with-the-same-color/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-adjacent-elements-with-the-same-color/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始、长度为 <code>n</code>&nbsp;的数组&nbsp;<code>nums</code>&nbsp;。一开始，所有元素都是 <strong>未染色</strong>&nbsp;（值为 <code>0</code>&nbsp;）的。</p>\n\n<p>给你一个二维整数数组&nbsp;<code>queries</code>&nbsp;，其中&nbsp;<code>queries[i] = [index<sub>i</sub>, color<sub>i</sub>]</code>&nbsp;。</p>\n\n<p>对于每个操作，你需要将数组 <code>nums</code>&nbsp;中下标为&nbsp;<code>index<sub>i</sub></code>&nbsp;的格子染色为&nbsp;<code>color<sub>i</sub></code>&nbsp;。</p>\n\n<p>请你返回一个长度与 <code>queries</code>&nbsp;相等的数组<em>&nbsp;</em><code>answer</code><em>&nbsp;</em>，其中<em>&nbsp;</em><code>answer[i]</code>是前 <code>i</code>&nbsp;个操作&nbsp;<strong>之后</strong>&nbsp;，相邻元素颜色相同的数目。</p>\n\n<p>更正式的，<code>answer[i]</code>&nbsp;是执行完前 <code>i</code>&nbsp;个操作后，<code>0 &lt;= j &lt; n - 1</code>&nbsp;的下标 <code>j</code>&nbsp;中，满足&nbsp;<code>nums[j] == nums[j + 1]</code> 且&nbsp;<code>nums[j] != 0</code>&nbsp;的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 4, queries = [[0,2],[1,2],[3,1],[1,1],[2,1]]\n<b>输出：</b>[0,1,1,0,2]\n<b>解释：</b>一开始数组 nums = [0,0,0,0] ，0 表示数组中还没染色的元素。\n- 第 1 个操作后，nums = [2,0,0,0] 。相邻元素颜色相同的数目为 0 。\n- 第 2 个操作后，nums = [2,2,0,0] 。相邻元素颜色相同的数目为 1 。\n- 第 3 个操作后，nums = [2,2,0,1] 。相邻元素颜色相同的数目为 1 。\n- 第 4 个操作后，nums = [2,1,0,1] 。相邻元素颜色相同的数目为 0 。\n- 第 5 个操作后，nums = [2,1,1,1] 。相邻元素颜色相同的数目为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 1, queries = [[0,100000]]\n<b>输出：</b>[0]\n<b>解释：</b>一开始数组 nums = [0] ，0 表示数组中还没染色的元素。\n- 第 1 个操作后，nums = [100000] 。相邻元素颜色相同的数目为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length&nbsp;== 2</code></li>\n\t<li><code>0 &lt;= index<sub>i</sub>&nbsp;&lt;= n - 1</code></li>\n\t<li><code>1 &lt;=&nbsp; color<sub>i</sub>&nbsp;&lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2673使二叉树所有路径值相等的最小代价",
        "hardRate": "MEDIUM",
        "passRate": "66.25%",
        "problemsUrl": "https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;表示一棵 <b>满二叉树</b>&nbsp;里面节点的数目，节点编号从 <code>1</code>&nbsp;到 <code>n</code>&nbsp;。根节点编号为 <code>1</code>&nbsp;，树中每个非叶子节点&nbsp;<code>i</code>&nbsp;都有两个孩子，分别是左孩子&nbsp;<code>2 * i</code>&nbsp;和右孩子&nbsp;<code>2 * i + 1</code>&nbsp;。</p>\n\n<p>树中每个节点都有一个值，用下标从<b>&nbsp;0</b>&nbsp;开始、长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>cost</code>&nbsp;表示，其中&nbsp;<code>cost[i]</code>&nbsp;是第&nbsp;<code>i + 1</code>&nbsp;个节点的值。每次操作，你可以将树中&nbsp;<strong>任意</strong>&nbsp;节点的值&nbsp;<strong>增加</strong>&nbsp;<code>1</code>&nbsp;。你可以执行操作 <strong>任意</strong> 次。</p>\n\n<p>你的目标是让根到每一个 <strong>叶子结点</strong>&nbsp;的路径值相等。请你返回 <strong>最少</strong>&nbsp;需要执行增加操作多少次。</p>\n\n<p><b>注意：</b></p>\n\n<ul>\n\t<li><strong>满二叉树</strong>&nbsp;指的是一棵树，它满足树中除了叶子节点外每个节点都恰好有 2 个节点，且所有叶子节点距离根节点距离相同。</li>\n\t<li><strong>路径值</strong> 指的是路径上所有节点的值之和。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/04/binaryytreeedrawio-4.png\" /></p>\n\n<pre>\n<b>输入：</b>n = 7, cost = [1,5,2,2,3,3,1]\n<b>输出：</b>6\n<b>解释：</b>我们执行以下的增加操作：\n- 将节点 4 的值增加一次。\n- 将节点 3 的值增加三次。\n- 将节点 7 的值增加两次。\n从根到叶子的每一条路径值都为 9 。\n总共增加次数为 1 + 3 + 2 = 6 。\n这是最小的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/04/binaryytreee2drawio.png\" style=\"width: 205px; height: 151px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 3, cost = [5,3,3]\n<b>输出：</b>0\n<b>解释：</b>两条路径已经有相等的路径值，所以不需要执行任何增加操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>n + 1</code> 是&nbsp;<code>2</code>&nbsp;的幂</li>\n\t<li><code>cost.length == n</code></li>\n\t<li><code>1 &lt;= cost[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2674拆分循环链表",
        "hardRate": "MEDIUM",
        "passRate": "82.65%",
        "problemsUrl": "https://leetcode.cn/problems/split-a-circular-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/split-a-circular-linked-list/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2675将对象数组转换为矩阵",
        "hardRate": "MEDIUM",
        "passRate": "61.15%",
        "problemsUrl": "https://leetcode.cn/problems/array-of-objects-to-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/array-of-objects-to-matrix/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2676节流",
        "hardRate": "MEDIUM",
        "passRate": "43.71%",
        "problemsUrl": "https://leetcode.cn/problems/throttle/",
        "solutionsUrl": "https://leetcode.cn/problems/throttle/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2677分块数组",
        "hardRate": "EASY",
        "passRate": "72.18%",
        "problemsUrl": "https://leetcode.cn/problems/chunk-array/",
        "solutionsUrl": "https://leetcode.cn/problems/chunk-array/solution",
        "problemsDesc": "<p>给定一个数组&nbsp;<code>arr</code>&nbsp;和一个块大小&nbsp;<code>size</code>&nbsp;，返回一个 <strong>分块</strong>&nbsp;的数组。<strong>分块</strong>&nbsp;的数组包含了&nbsp;<code>arr</code>&nbsp;中的原始元素，但是每个子数组的长度都是&nbsp;<code>size</code>&nbsp;。如果&nbsp;<code>arr.length</code>&nbsp;不能被&nbsp;<code>size</code>&nbsp;整除，那么最后一个子数组的长度可能小于&nbsp;<code>size</code>&nbsp;。</p>\n\n<p>你可以假设该数组是&nbsp;<code>JSON.parse</code>&nbsp;的输出结果。换句话说，它是有效的JSON。</p>\n\n<p>请你在不使用 lodash 的函数&nbsp;<code>_.chunk</code>&nbsp;的情况下解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [1,2,3,4,5], size = 1\n<b>输出：</b>[[1],[2],[3],[4],[5]]\n<b>解释：</b>数组 <code>arr </code>被分割成了每个只有一个元素的子数组。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [1,9,6,3,2], size = 3\n<b>输出：</b>[[1,9,6],[3,2]]\n<b>解释：</b>数组 <code>arr </code>被分割成了每个有三个元素的子数组。然而，第二个子数组只有两个元素。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [8,5,3,2,6], size = 6\n<b>输出：</b>[[8,5,3,2,6]]\n<b>解释：</b><code>size </code>大于 <code>arr.length </code>，因此所有元素都在第一个子数组中。\n</pre>\n\n<p><strong class=\"example\">示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [], size = 1\n<b>输出：</b>[]\n<b>解释：</b>没有元素需要分块，因此返回一个空数组。</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>arr is a valid JSON array</code></li>\n\t<li><code>2 &lt;= JSON.stringify(arr).length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= size &lt;= arr.length + 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2678老人的数目",
        "hardRate": "EASY",
        "passRate": "83.43%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-senior-citizens/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-senior-citizens/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>details</code>&nbsp;。<code>details</code>&nbsp;中每个元素都是一位乘客的信息，信息用长度为 <code>15</code>&nbsp;的字符串表示，表示方式如下：</p>\n\n<ul>\n\t<li>前十个字符是乘客的手机号码。</li>\n\t<li>接下来的一个字符是乘客的性别。</li>\n\t<li>接下来两个字符是乘客的年龄。</li>\n\t<li>最后两个字符是乘客的座位号。</li>\n</ul>\n\n<p>请你返回乘客中年龄 <strong>严格大于 60 岁</strong>&nbsp;的人数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>details = [\"7868190130M7522\",\"5303914400F9211\",\"9273338290F4010\"]\n<b>输出：</b>2\n<b>解释：</b>下标为 0 ，1 和 2 的乘客年龄分别为 75 ，92 和 40 。所以有 2 人年龄大于 60 岁。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>details = [\"1313579440F2036\",\"2921522980M5644\"]\n<b>输出：</b>0\n<b>解释：</b>没有乘客的年龄大于 60 岁。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= details.length &lt;= 100</code></li>\n\t<li><code>details[i].length == 15</code></li>\n\t<li><code>details[i]</code>&nbsp;中的数字只包含&nbsp;<code>'0'</code>&nbsp;到&nbsp;<code>'9'</code>&nbsp;。</li>\n\t<li><code>details[i][10]</code>&nbsp;是 <code>'M'</code>&nbsp;，<code>'F'</code>&nbsp;或者&nbsp;<code>'O'</code>&nbsp;之一。</li>\n\t<li>所有乘客的手机号码和座位号互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2679矩阵中的和",
        "hardRate": "MEDIUM",
        "passRate": "78.58%",
        "problemsUrl": "https://leetcode.cn/problems/sum-in-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-in-a-matrix/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>nums</code>&nbsp;。一开始你的分数为&nbsp;<code>0</code>&nbsp;。你需要执行以下操作直到矩阵变为空：</p>\n\n<ol>\n\t<li>矩阵中每一行选取最大的一个数，并删除它。如果一行中有多个最大的数，选择任意一个并删除。</li>\n\t<li>在步骤 1 删除的所有数字中找到最大的一个数字，将它添加到你的 <strong>分数</strong>&nbsp;中。</li>\n</ol>\n\n<p>请你返回最后的 <strong>分数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [[7,2,1],[6,4,2],[6,5,3],[3,2,1]]\n<b>输出：</b>15\n<b>解释：</b>第一步操作中，我们删除 7 ，6 ，6 和 3 ，将分数增加 7 。下一步操作中，删除 2 ，4 ，5 和 2 ，将分数增加 5 。最后删除 1 ，2 ，3 和 1 ，将分数增加 3 。所以总得分为 7 + 5 + 3 = 15 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [[1]]\n<b>输出：</b>1\n<b>解释：</b>我们删除 1 并将分数增加 1 ，所以返回 1 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= nums[i].length &lt;= 500</code></li>\n\t<li><code>0 &lt;= nums[i][j] &lt;= 10<sup>3</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2680最大或值",
        "hardRate": "MEDIUM",
        "passRate": "42.63%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-or/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-or/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code> 。每一次操作中，你可以选择一个数并将它乘&nbsp;<code>2</code>&nbsp;。</p>\n\n<p>你最多可以进行 <code>k</code>&nbsp;次操作，请你返回<em>&nbsp;</em><code>nums[0] | nums[1] | ... | nums[n - 1]</code>&nbsp;的最大值。</p>\n\n<p><code>a | b</code>&nbsp;表示两个整数 <code>a</code>&nbsp;和 <code>b</code>&nbsp;的 <strong>按位或</strong>&nbsp;运算。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [12,9], k = 1\n<b>输出：</b>30\n<b>解释：</b>如果我们对下标为 1 的元素进行操作，新的数组为 [12,18] 。此时得到最优答案为 12 和 18 的按位或运算的结果，也就是 30 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [8,1,2], k = 2\n<b>输出：</b>35\n<b>解释：</b>如果我们对下标 0 处的元素进行操作，得到新数组 [32,1,2] 。此时得到最优答案为 32|1|2 = 35 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 15</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2681英雄的力量",
        "hardRate": "HARD",
        "passRate": "35.97%",
        "problemsUrl": "https://leetcode.cn/problems/power-of-heroes/",
        "solutionsUrl": "https://leetcode.cn/problems/power-of-heroes/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，它表示英雄的能力值。如果我们选出一部分英雄，这组英雄的 <strong>力量</strong>&nbsp;定义为：</p>\n\n<ul>\n\t<li><code>i<sub>0</sub></code>&nbsp;，<code>i<sub>1</sub></code>&nbsp;，<span style=\"\">... </span><code><span style=\"\">i<sub>k</sub></span></code><span style=\"\">&nbsp;</span>表示这组英雄在数组中的下标。那么这组英雄的力量为&nbsp;<code><font face=\"monospace\">max(nums[</font>i<sub>0</sub><font face=\"monospace\">],nums[</font>i<sub>1</sub><font face=\"monospace\">] ... nums[</font><span style=\"font-size:10.8333px\">i<sub>k</sub></span><font face=\"monospace\">])<sup>2</sup> * min(nums[</font>i<sub>0</sub><font face=\"monospace\">],nums[</font>i<sub>1</sub><font face=\"monospace\">] ... nums[</font><span style=\"font-size:10.8333px\">i<sub>k</sub></span><font face=\"monospace\">])</font></code> 。</li>\n</ul>\n\n<p>请你返回所有可能的 <strong>非空</strong> 英雄组的 <strong>力量</strong> 之和。由于答案可能非常大，请你将结果对&nbsp;<code>10<sup>9 </sup>+ 7</code>&nbsp;<strong>取余。</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,1,4]\n<b>输出：</b>141\n<b>解释：</b>\n第 1&nbsp;组：[2] 的力量为 2<sup>2</sup>&nbsp;* 2 = 8 。\n第 2&nbsp;组：[1] 的力量为 1<sup>2</sup> * 1 = 1 。\n第 3&nbsp;组：[4] 的力量为 4<sup>2</sup> * 4 = 64 。\n第 4&nbsp;组：[2,1] 的力量为 2<sup>2</sup> * 1 = 4 。\n第 5 组：[2,4] 的力量为 4<sup>2</sup> * 2 = 32 。\n第 6&nbsp;组：[1,4] 的力量为 4<sup>2</sup> * 1 = 16 。\n第​ ​​​​​​7&nbsp;组：[2,1,4] 的力量为 4<sup>2</sup>​​​​​​​ * 1 = 16 。\n所有英雄组的力量之和为 8 + 1 + 64 + 4 + 32 + 16 + 16 = 141 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,1,1]\n<b>输出：</b>7\n<b>解释：</b>总共有 7 个英雄组，每一组的力量都是 1 。所以所有英雄组的力量之和为 7 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2682找出转圈游戏输家",
        "hardRate": "EASY",
        "passRate": "54.14%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-losers-of-the-circular-game/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-losers-of-the-circular-game/solution",
        "problemsDesc": "<p><code>n</code> 个朋友在玩游戏。这些朋友坐成一个圈，按 <strong>顺时针方向</strong> 从 <code>1</code> 到 <code>n</code> 编号。从第 <code>i</code> 个朋友的位置开始顺时针移动 <code>1</code> 步会到达第 <code>(i + 1)</code> 个朋友的位置（<code>1 &lt;= i &lt; n</code>），而从第 <code>n</code> 个朋友的位置开始顺时针移动 <code>1</code> 步会回到第 <code>1</code> 个朋友的位置。</p>\n\n<p>游戏规则如下：</p>\n\n<p>第 <code>1</code> 个朋友接球。</p>\n\n<ul>\n\t<li>接着，第 <code>1</code> 个朋友将球传给距离他顺时针方向 <code>k</code> 步的朋友。</li>\n\t<li>然后，接球的朋友应该把球传给距离他顺时针方向 <code>2 * k</code> 步的朋友。</li>\n\t<li>接着，接球的朋友应该把球传给距离他顺时针方向 <code>3 * k</code> 步的朋友，以此类推。</li>\n</ul>\n\n<p>换句话说，在第 <code>i</code> 轮中持有球的那位朋友需要将球传递给距离他顺时针方向 <code>i * k</code> 步的朋友。</p>\n\n<p>当某个朋友第 2 次接到球时，游戏结束。</p>\n\n<p>在整场游戏中没有接到过球的朋友是 <strong>输家</strong> 。</p>\n\n<p>给你参与游戏的朋友数量 <code>n</code> 和一个整数 <code>k</code> ，请按升序排列返回包含所有输家编号的数组 <code>answer</code> 作为答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, k = 2\n<strong>输出：</strong>[4,5]\n<strong>解释：</strong>以下为游戏进行情况：\n1）第 1 个朋友接球，第 <code>1</code> 个朋友将球传给距离他顺时针方向 2 步的玩家 —— 第 3 个朋友。\n2）第 3 个朋友将球传给距离他顺时针方向 4 步的玩家 —— 第 2 个朋友。\n3）第 2 个朋友将球传给距离他顺时针方向 6 步的玩家 —— 第 3 个朋友。\n4）第 3 个朋友接到两次球，游戏结束。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, k = 4\n<strong>输出：</strong>[2,3,4]\n<strong>解释：</strong>以下为游戏进行情况：\n1）第 1 个朋友接球，第 <code>1</code> 个朋友将球传给距离他顺时针方向 4 步的玩家 —— 第 1 个朋友。\n2）第 1 个朋友接到两次球，游戏结束。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2683相邻值的按位异或",
        "hardRate": "MEDIUM",
        "passRate": "69.06%",
        "problemsUrl": "https://leetcode.cn/problems/neighboring-bitwise-xor/",
        "solutionsUrl": "https://leetcode.cn/problems/neighboring-bitwise-xor/solution",
        "problemsDesc": "<p>下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的数组 <code>derived</code> 是由同样长度为 <code>n</code> 的原始 <strong>二进制数组</strong> <code>original</code> 通过计算相邻值的 <strong>按位异或（⊕）</strong>派生而来。</p>\n\n<p>特别地，对于范围&nbsp;<code>[0, n - 1]</code> 内的每个下标 <code>i</code> ：</p>\n\n<ul>\n\t<li>如果 <code>i = n - 1</code> ，那么 <code>derived[i] = original[i] ⊕ original[0]</code></li>\n\t<li>否则 <code>derived[i] = original[i] ⊕ original[i + 1]</code></li>\n</ul>\n\n<p>给你一个数组 <code>derived</code> ，请判断是否存在一个能够派生得到 <code>derived</code> 的 <strong>有效原始二进制数组</strong> <code>original</code> 。</p>\n\n<p>如果存在满足要求的原始二进制数组，返回 <em><strong>true</strong> </em>；否则，返回<em> <strong>false</strong> </em>。</p>\n\n<ul>\n\t<li>二进制数组是仅由 <strong>0</strong> 和 <strong>1</strong> 组成的数组。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>derived = [1,1,0]\n<strong>输出：</strong>true\n<strong>解释：</strong>能够派生得到 [1,1,0] 的有效原始二进制数组是 [0,1,0] ：\nderived[0] = original[0] ⊕ original[1] = 0 ⊕ 1 = 1 \nderived[1] = original[1] ⊕ original[2] = 1 ⊕ 0 = 1\nderived[2] = original[2] ⊕ original[0] = 0 ⊕ 0 = 0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>derived = [1,1]\n<strong>输出：</strong>true\n<strong>解释：</strong>能够派生得到 [1,1] 的有效原始二进制数组是 [0,1] ：\nderived[0] = original[0] ⊕ original[1] = 1\nderived[1] = original[1] ⊕ original[0] = 1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>derived = [1,0]\n<strong>输出：</strong>false\n<strong>解释：</strong>不存在能够派生得到 [1,0] 的有效原始二进制数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == derived.length</code></li>\n\t<li><code>1 &lt;= n&nbsp;&lt;= 10<sup>5</sup></code></li>\n\t<li><code>derived</code> 中的值不是 <strong>0</strong> 就是 <strong>1</strong> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2684矩阵中移动的最大次数",
        "hardRate": "MEDIUM",
        "passRate": "40.85%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-moves-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-moves-in-a-grid/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>m x n</code> 的矩阵 <code>grid</code> ，矩阵由若干 <strong>正</strong> 整数组成。</p>\n\n<p>你可以从矩阵第一列中的 <strong>任一</strong> 单元格出发，按以下方式遍历&nbsp;<code>grid</code> ：</p>\n\n<ul>\n\t<li>从单元格 <code>(row, col)</code> 可以移动到&nbsp;<code>(row - 1, col + 1)</code>、<code>(row, col + 1)</code> 和 <code>(row + 1, col + 1)</code> 三个单元格中任一满足值 <strong>严格</strong> 大于当前单元格的单元格。</li>\n</ul>\n\n<p>返回你在矩阵中能够 <strong>移动</strong> 的 <strong>最大</strong> 次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/11/yetgriddrawio-10.png\" style=\"width: 201px; height: 201px;\">\n<pre><strong>输入：</strong>grid = [[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]]\n<strong>输出：</strong>3\n<strong>解释：</strong>可以从单元格 (0, 0) 开始并且按下面的路径移动：\n- (0, 0) -&gt; (0, 1).\n- (0, 1) -&gt; (1, 2).\n- (1, 2) -&gt; (2, 3).\n可以证明这是能够移动的最大次数。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/12/yetgrid4drawio.png\">\n<strong>输入：</strong>grid = [[3,2,4],[2,1,9],[1,1,7]]\n<strong>输出：</strong>0\n<strong>解释：</strong>从第一列的任一单元格开始都无法移动。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2685统计完全连通分量的数量",
        "hardRate": "MEDIUM",
        "passRate": "67.30%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-complete-components/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-complete-components/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> 。现有一个包含 <code>n</code> 个顶点的 <strong>无向</strong> 图，顶点按从 <code>0</code> 到 <code>n - 1</code> 编号。给你一个二维整数数组 <code>edges</code> 其中 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示顶点 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间存在一条 <strong>无向</strong> 边。</p>\n\n<p>返回图中 <strong>完全连通分量</strong> 的数量。</p>\n\n<p>如果在子图中任意两个顶点之间都存在路径，并且子图中没有任何一个顶点与子图外部的顶点共享边，则称其为 <strong>连通分量</strong> 。</p>\n\n<p>如果连通分量中每对节点之间都存在一条边，则称其为 <strong>完全连通分量</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/11/screenshot-from-2023-04-11-23-31-23.png\" style=\"width: 671px; height: 270px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6, edges = [[0,1],[0,2],[1,2],[3,4]]\n<strong>输出：</strong>3\n<strong>解释：</strong>如上图所示，可以看到此图所有分量都是完全连通分量。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/11/screenshot-from-2023-04-11-23-32-00.png\" style=\"width: 671px; height: 270px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6, edges = [[0,1],[0,2],[1,2],[3,4],[3,5]]\n<strong>输出：</strong>1\n<strong>解释：</strong>包含节点 0、1 和 2 的分量是完全连通分量，因为每对节点之间都存在一条边。\n包含节点 3 、4 和 5 的分量不是完全连通分量，因为节点 4 和 5 之间不存在边。\n因此，在图中完全连接分量的数量是 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>0 &lt;= edges.length &lt;= n * (n - 1) / 2</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>不存在重复的边</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2686即时食物配送 III",
        "hardRate": "MEDIUM",
        "passRate": "67.37%",
        "problemsUrl": "https://leetcode.cn/problems/immediate-food-delivery-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/immediate-food-delivery-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2687自行车的最后使用时间",
        "hardRate": "EASY",
        "passRate": "85.92%",
        "problemsUrl": "https://leetcode.cn/problems/bikes-last-time-used/",
        "solutionsUrl": "https://leetcode.cn/problems/bikes-last-time-used/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2688查找活跃用户",
        "hardRate": "MEDIUM",
        "passRate": "45.07%",
        "problemsUrl": "https://leetcode.cn/problems/find-active-users/",
        "solutionsUrl": "https://leetcode.cn/problems/find-active-users/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2689从 Rope 树中提取第 K 个字符",
        "hardRate": "EASY",
        "passRate": "78.76%",
        "problemsUrl": "https://leetcode.cn/problems/extract-kth-character-from-the-rope-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/extract-kth-character-from-the-rope-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2690无穷方法对象",
        "hardRate": "EASY",
        "passRate": "93.98%",
        "problemsUrl": "https://leetcode.cn/problems/infinite-method-object/",
        "solutionsUrl": "https://leetcode.cn/problems/infinite-method-object/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2691不可变辅助工具",
        "hardRate": "HARD",
        "passRate": "25.20%",
        "problemsUrl": "https://leetcode.cn/problems/immutability-helper/",
        "solutionsUrl": "https://leetcode.cn/problems/immutability-helper/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2692使对象不可变",
        "hardRate": "MEDIUM",
        "passRate": "49.52%",
        "problemsUrl": "https://leetcode.cn/problems/make-object-immutable/",
        "solutionsUrl": "https://leetcode.cn/problems/make-object-immutable/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2693使用自定义上下文调用函数",
        "hardRate": "MEDIUM",
        "passRate": "72.97%",
        "problemsUrl": "https://leetcode.cn/problems/call-function-with-custom-context/",
        "solutionsUrl": "https://leetcode.cn/problems/call-function-with-custom-context/solution",
        "problemsDesc": "<p>增强所有函数，使其具有&nbsp;<code>callPolyfill</code>&nbsp;方法。该方法接受一个对象&nbsp;<code>obj</code>&nbsp;作为第一个参数，以及任意数量的附加参数。<code>obj</code>&nbsp;成为函数的&nbsp;<code>this</code>&nbsp;上下文。附加参数将传递给该函数（即&nbsp;<code>callPolyfill</code>&nbsp;方法所属的函数）。</p>\n\n<p>例如，如果有以下函数：</p>\n\n<pre>\nfunction tax(price, taxRate) {\n  const totalCost = price * (1 + taxRate);\n&nbsp; console.log(`The cost of ${this.item} is ${totalCost}`);\n}\n</pre>\n\n<p>调用&nbsp;<code>tax(10, 0.1)</code>&nbsp;将输出&nbsp;<code>\"The cost of undefined is 11\"</code>&nbsp;。这是因为&nbsp;<code>this</code>&nbsp;上下文未定义。</p>\n\n<p>然而，调用&nbsp;<code>tax.callPolyfill({item: \"salad\"}, 10, 0.1)</code>&nbsp;将输出&nbsp;<code>\"The cost of salad is 11\"</code>&nbsp;。<code>this</code>&nbsp;上下文被正确设置，函数输出了适当的结果。</p>\n\n<p>请在不使用内置的&nbsp;<code>Function.call</code>&nbsp;方法的情况下解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nfn = function add(b) {\n  return this.a + b;\n}\nargs = [{\"a\": 5}, 7]\n<b>输出：</b>12\n<strong>解释：</strong>\nfn.callPolyfill({\"a\": 5}, 7); // 12\n<code>callPolyfill </code>将 \"this\" 上下文设置为 <code>{\"a\": 5} </code>，并将 7 作为参数传递。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>\nfn = function tax(price, taxRate) { \n&nbsp;return `The cost of the ${this.item} is ${price * taxRate}`; \n}\nargs = [{\"item\": \"burger\"}, 10, 1,1]\n<b>输出：</b>\"The cost of the burger is 11\"\n<b>解释：</b><code>callPolyfill </code>将 \"this\" 上下文设置为 <code>{\"item\": \"burger\"} </code>，并将 10 和 1.1 作为附加参数传递。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul style=\"list-style-type:square;\">\n\t<li><code><font face=\"monospace\">typeof args[0] == 'object' and args[0] != null</font></code></li>\n\t<li><code>1 &lt;= args.length &lt;= 100</code></li>\n\t<li><code>2 &lt;= JSON.stringify(args[0]).length &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2694事件发射器",
        "hardRate": "MEDIUM",
        "passRate": "60.57%",
        "problemsUrl": "https://leetcode.cn/problems/event-emitter/",
        "solutionsUrl": "https://leetcode.cn/problems/event-emitter/solution",
        "problemsDesc": "<p>设计一个 <code>EventEmitter</code> 类。这个接口与 Node.js 或 DOM 的 Event Target 接口相似，但有一些差异。<code>EventEmitter</code> 应该允许订阅事件和触发事件。</p>\n\n<p>你的 <code>EventEmitter</code> 类应该有以下两个方法：</p>\n\n<ul>\n\t<li><strong>subscribe</strong> - 这个方法接收两个参数：一个作为字符串的事件名和一个回调函数。当事件被触发时，这个回调函数将被调用。 一个事件应该能够有多个监听器。当触发带有多个回调函数的事件时，应按照订阅的顺序依次调用每个回调函数。应返回一个结果数组。你可以假设传递给 <code>subscribe</code> 的回调函数都不是引用相同的。 <code>subscribe</code> 方法还应返回一个对象，其中包含一个 <code>unsubscribe</code> 方法，使用户可以取消订阅。当调用 <code>unsubscribe</code> 方法时，回调函数应该从订阅列表中删除，并返回 undefined。</li>\n\t<li><strong>emit</strong> - 这个方法接收两个参数：一个作为字符串的事件名和一个可选的参数数组，这些参数将传递给回调函数。如果没有订阅给定事件的回调函数，则返回一个空数组。否则，按照它们被订阅的顺序返回所有回调函数调用的结果数组。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>actions = [\"EventEmitter\", \"emit\", \"subscribe\", \"subscribe\", \"emit\"], values = [[], [\"firstEvent\", \"function cb1() { return 5; }\"],  [\"firstEvent\", \"function cb1() { return 5; }\"], [\"firstEvent\"]]\n<b>输出：</b>[[],[\"emitted\",[]],[\"subscribed\"],[\"subscribed\"],[\"emitted\",[5,6]]]\n<b>解释：</b>\nconst emitter = new EventEmitter();\nemitter.emit(\"firstEvent\"); // [], 还没有订阅任何回调函数\nemitter.subscribe(\"firstEvent\", function cb1() { return 5; });\nemitter.subscribe(\"firstEvent\", function cb2() { return 6; });\nemitter.emit(\"firstEvent\"); // [5, 6], 返回 cb1 和 cb2 的输出\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>actions = [\"EventEmitter\", \"subscribe\", \"emit\", \"emit\"], values = [[], [\"firstEvent\", \"function cb1(...args) { return args.join(','); }\"], [\"firstEvent\", [1,2,3]], [\"firstEvent\", [3,4,6]]]\n<b>输出：</b>[[],[\"subscribed\"],[\"emitted\",[\"1,2,3\"]],[\"emitted\",[\"3,4,6\"]]]\n<strong>解释：</strong>注意 emit 方法应该能够接受一个可选的参数数组。\n\nconst emitter = new EventEmitter();\nemitter.subscribe(\"firstEvent, function cb1(...args) { return args.join(','); });\nemitter.emit(\"firstEvent\", [1, 2, 3]); // [\"1,2,3\"]\nemitter.emit(\"firstEvent\", [3, 4, 6]); // [\"3,4,6\"]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>actions = [\"EventEmitter\", \"subscribe\", \"emit\", \"unsubscribe\", \"emit\"], values = [[], [\"firstEvent\", \"(...args) =&gt; args.join(',')\"], [\"firstEvent\", [1,2,3]], [0], [\"firstEvent\", [4,5,6]]]\n<b>输出：</b>[[],[\"subscribed\"],[\"emitted\",[\"1,2,3\"]],[\"unsubscribed\",0],[\"emitted\",[]]]\n<b>解释：</b>\nconst emitter = new EventEmitter();\nconst sub = emitter.subscribe(\"firstEvent\", (...args) =&gt; args.join(','));\nemitter.emit(\"firstEvent\", [1, 2, 3]); // [\"1,2,3\"]\nsub.unsubscribe(); // undefined\nemitter.emit(\"firstEvent\", [4, 5, 6]); // [], 没有订阅者\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>actions = [\"EventEmitter\", \"subscribe\", \"subscribe\", \"unsubscribe\", \"emit\"], values = [[], [\"firstEvent\", \"x =&gt; x + 1\"], [\"firstEvent\", \"x =&gt; x + 2\"], [0], [\"firstEvent\", [5]]]\n<b>输出：</b>[[],[\"subscribed\"],[\"emitted\",[\"1,2,3\"]],[\"unsubscribed\",0],[\"emitted\",[7]]]\n<b>解释：</b>\nconst emitter = new EventEmitter();\nconst sub1 = emitter.subscribe(\"firstEvent\", x =&gt; x + 1);\nconst sub2 = emitter.subscribe(\"firstEvent\", x =&gt; x + 2);\nsub1.unsubscribe(); // undefined\nemitter.emit(\"firstEvent\", [5]); // [7]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= actions.length &lt;= 10</code></li>\n\t<li><code>values.length === actions.length</code></li>\n\t<li>所有测试用例都是有效的。例如，你不需要处理取消一个不存在的订阅的情况。</li>\n\t<li>只有 4 种不同的操作：<code>EventEmitter</code>、<code>emit</code>、<code>subscribe</code> 和 <code>unsubscribe</code>&nbsp;。 <code>EventEmitter</code> 操作没有参数。</li>\n\t<li><code>emit</code> 操作接收 1 或 2 个参数。第一个参数是要触发的事件名，第二个参数传递给回调函数。</li>\n\t<li><code>subscribe</code> 操作接收 2 个参数，第一个是事件名，第二个是回调函数。</li>\n\t<li><code>unsubscribe</code> 操作接收一个参数，即之前进行订阅的顺序（从 0 开始）。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2695包装数组",
        "hardRate": "EASY",
        "passRate": "72.30%",
        "problemsUrl": "https://leetcode.cn/problems/array-wrapper/",
        "solutionsUrl": "https://leetcode.cn/problems/array-wrapper/solution",
        "problemsDesc": "<p>创建一个名为 <code>ArrayWrapper</code> 的类，它在其构造函数中接受一个整数数组作为参数。该类应具有以下两个特性：</p>\n\n<ul>\n\t<li>当使用 <code>+</code> 运算符将两个该类的实例相加时，结果值为两个数组中所有元素的总和。</li>\n\t<li>当在实例上调用 <code>String()</code> 函数时，它将返回一个由逗号分隔的括在方括号中的字符串。例如，<code>[1,2,3]</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [[1,2],[3,4]], operation = \"Add\"\n<b>输出：</b>10\n<b>解释：</b>\nconst obj1 = new ArrayWrapper([1,2]);\nconst obj2 = new ArrayWrapper([3,4]);\nobj1 + obj2; // 10\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [[23,98,42,70]], operation = \"String\"\n<b>输出：</b>\"[23,98,42,70]\"\n<strong>解释：</strong>\nconst obj = new ArrayWrapper([23,98,42,70]);\nString(obj); // \"[23,98,42,70]\"\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [[],[]], operation = \"Add\"\n<b>输出：</b>0\n<strong>解释：</strong>\nconst obj1 = new ArrayWrapper([]);\nconst obj2 = new ArrayWrapper([]);\nobj1 + obj2; // 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i]&nbsp;&lt;= 1000</code></li>\n\t<li><code>注意：nums 是传递给构造函数的数组。</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2696删除子串后的字符串最小长度",
        "hardRate": "EASY",
        "passRate": "72.44%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-string-length-after-removing-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-string-length-after-removing-substrings/solution",
        "problemsDesc": "<p>给你一个仅由 <strong>大写</strong> 英文字符组成的字符串 <code>s</code> 。</p>\n\n<p>你可以对此字符串执行一些操作，在每一步操作中，你可以从 <code>s</code> 中删除 <strong>任一个</strong> <code>\"AB\"</code> 或 <code>\"CD\"</code> 子字符串。</p>\n\n<p>通过执行操作，删除所有&nbsp;<code>\"AB\"</code> 和 <code>\"CD\"</code> 子串，返回可获得的最终字符串的 <strong>最小</strong> 可能长度。</p>\n\n<p><strong>注意</strong>，删除子串后，重新连接出的字符串可能会产生新的&nbsp;<code>\"AB\"</code> 或 <code>\"CD\"</code> 子串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ABFCACDB\"\n<strong>输出：</strong>2\n<strong>解释：</strong>你可以执行下述操作：\n- 从 \"<em><strong>AB</strong></em>FCACDB\" 中删除子串 \"AB\"，得到 s = \"FCACDB\" 。\n- 从 \"FCA<em><strong>CD</strong></em>B\" 中删除子串 \"CD\"，得到 s = \"FCAB\" 。\n- 从 \"FC<strong><em>AB</em></strong>\" 中删除子串 \"AB\"，得到 s = \"FC\" 。\n最终字符串的长度为 2 。\n可以证明 2 是可获得的最小长度。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ACBBD\"\n<strong>输出：</strong>5\n<strong>解释：</strong>无法执行操作，字符串长度不变。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 仅由大写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2697字典序最小回文串",
        "hardRate": "EASY",
        "passRate": "82.95%",
        "problemsUrl": "https://leetcode.cn/problems/lexicographically-smallest-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/lexicographically-smallest-palindrome/solution",
        "problemsDesc": "<p>给你一个由 <strong>小写英文字母</strong> 组成的字符串 <code>s</code> ，你可以对其执行一些操作。在一步操作中，你可以用其他小写英文字母 <strong>替换</strong>&nbsp; <code>s</code> 中的一个字符。</p>\n\n<p>请你执行 <strong>尽可能少的操作</strong> ，使 <code>s</code> 变成一个 <strong>回文串</strong> 。如果执行 <strong>最少</strong> 操作次数的方案不止一种，则只需选取 <strong>字典序最小</strong> 的方案。</p>\n\n<p>对于两个长度相同的字符串 <code>a</code> 和 <code>b</code> ，在 <code>a</code> 和 <code>b</code> 出现不同的第一个位置，如果该位置上 <code>a</code> 中对应字母比 <code>b</code> 中对应字母在字母表中出现顺序更早，则认为 <code>a</code> 的字典序比 <code>b</code> 的字典序要小。</p>\n\n<p>返回最终的回文字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"egcfe\"\n<strong>输出：</strong>\"efcfe\"\n<strong>解释：</strong>将 \"egcfe\" 变成回文字符串的最小操作次数为 1 ，修改 1 次得到的字典序最小回文字符串是 \"efcfe\"，只需将 'g' 改为 'f' 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\"\n<strong>输出：</strong>\"abba\"\n<strong>解释：</strong>将 \"abcd\" 变成回文字符串的最小操作次数为 2 ，修改 2 次得到的字典序最小回文字符串是 \"abba\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"seven\"\n<strong>输出：</strong>\"neven\"\n<strong>解释：</strong>将 \"seven\" 变成回文字符串的最小操作次数为 1 ，修改 1 次得到的字典序最小回文字符串是 \"neven\" 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2698求一个整数的惩罚数",
        "hardRate": "MEDIUM",
        "passRate": "66.92%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/solution",
        "problemsDesc": "<p>给你一个正整数&nbsp;<code>n</code>&nbsp;，请你返回&nbsp;<code>n</code>&nbsp;的&nbsp;<strong>惩罚数</strong>&nbsp;。</p>\n\n<p><code>n</code>&nbsp;的 <strong>惩罚数</strong>&nbsp;定义为所有满足以下条件 <code>i</code>&nbsp;的数的平方和：</p>\n\n<ul>\n\t<li><code>1 &lt;= i &lt;= n</code></li>\n\t<li><code>i * i</code> 的十进制表示的字符串可以分割成若干连续子字符串，且这些子字符串对应的整数值之和等于 <code>i</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 10\n<b>输出：</b>182\n<b>解释：</b>总共有 3 个整数 i 满足要求：\n- 1 ，因为 1 * 1 = 1\n- 9 ，因为 9 * 9 = 81 ，且 81 可以分割成 8 + 1 。\n- 10 ，因为 10 * 10 = 100 ，且 100 可以分割成 10 + 0 。\n因此，10 的惩罚数为 1 + 81 + 100 = 182\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 37\n<b>输出：</b>1478\n<b>解释：</b>总共有 4 个整数 i 满足要求：\n- 1 ，因为 1 * 1 = 1\n- 9 ，因为 9 * 9 = 81 ，且 81 可以分割成 8 + 1 。\n- 10 ，因为 10 * 10 = 100 ，且 100 可以分割成 10 + 0 。\n- 36 ，因为 36 * 36 = 1296 ，且 1296 可以分割成 1 + 29 + 6 。\n因此，37 的惩罚数为 1 + 81 + 100 + 1296 = 1478\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2699修改图中的边权",
        "hardRate": "HARD",
        "passRate": "52.56%",
        "problemsUrl": "https://leetcode.cn/problems/modify-graph-edge-weights/",
        "solutionsUrl": "https://leetcode.cn/problems/modify-graph-edge-weights/solution",
        "problemsDesc": "<p>给你一个 <code>n</code>&nbsp;个节点的 <strong>无向带权连通</strong>&nbsp;图，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，再给你一个整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>, w<sub>i</sub>]</code>&nbsp;表示节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条边权为&nbsp;<code>w<sub>i</sub></code>&nbsp;的边。</p>\n\n<p>部分边的边权为&nbsp;<code>-1</code>（<code>w<sub>i</sub> = -1</code>），其他边的边权都为 <strong>正</strong>&nbsp;数（<code>w<sub>i</sub> &gt; 0</code>）。</p>\n\n<p>你需要将所有边权为 <code>-1</code>&nbsp;的边都修改为范围&nbsp;<code>[1, 2 * 10<sup>9</sup>]</code>&nbsp;中的 <strong>正整数</strong>&nbsp;，使得从节点&nbsp;<code>source</code>&nbsp;到节点&nbsp;<code>destination</code>&nbsp;的 <strong>最短距离</strong>&nbsp;为整数&nbsp;<code>target</code>&nbsp;。如果有 <strong>多种</strong>&nbsp;修改方案可以使&nbsp;<code>source</code> 和&nbsp;<code>destination</code>&nbsp;之间的最短距离等于&nbsp;<code>target</code>&nbsp;，你可以返回任意一种方案。</p>\n\n<p>如果存在使 <code>source</code>&nbsp;到 <code>destination</code>&nbsp;最短距离为 <code>target</code>&nbsp;的方案，请你按任意顺序返回包含所有边的数组（包括未修改边权的边）。如果不存在这样的方案，请你返回一个 <strong>空数组</strong>&nbsp;。</p>\n\n<p><strong>注意：</strong>你不能修改一开始边权为正数的边。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/18/graph.png\" style=\"width: 300px; height: 300px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>n = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5\n<b>输出：</b>[[4,1,1],[2,0,1],[0,3,3],[4,3,1]]\n<b>解释：</b>上图展示了一个满足题意的修改方案，从 0 到 1 的最短距离为 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/18/graph-2.png\" style=\"width: 300px; height: 300px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>n = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6\n<b>输出：</b>[]\n<b>解释：</b>上图是一开始的图。没有办法通过修改边权为 -1 的边，使得 0 到 2 的最短距离等于 6 ，所以返回一个空数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/19/graph-3.png\" style=\"width: 300px; height: 300px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>n = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6\n<b>输出：</b>[[1,0,4],[1,2,3],[2,3,5],[0,3,1]]\n<b>解释：</b>上图展示了一个满足题意的修改方案，从 0 到 2 的最短距离为 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= n * (n - 1) / 2</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i&nbsp;</sub>&lt;&nbsp;n</code></li>\n\t<li><code>w<sub>i</sub>&nbsp;= -1</code> 或者 <code>1 &lt;= w<sub>i&nbsp;</sub>&lt;= 10<sup><span style=\"\">7</span></sup></code></li>\n\t<li><code>a<sub>i&nbsp;</sub>!=&nbsp;b<sub>i</sub></code></li>\n\t<li><code>0 &lt;= source, destination &lt; n</code></li>\n\t<li><code>source != destination</code></li>\n\t<li><code>1 &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li>输入的图是连通图，且没有自环和重边。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2700两个对象之间的差异",
        "hardRate": "MEDIUM",
        "passRate": "58.85%",
        "problemsUrl": "https://leetcode.cn/problems/differences-between-two-objects/",
        "solutionsUrl": "https://leetcode.cn/problems/differences-between-two-objects/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2701连续递增交易",
        "hardRate": "HARD",
        "passRate": "32.09%",
        "problemsUrl": "https://leetcode.cn/problems/consecutive-transactions-with-increasing-amounts/",
        "solutionsUrl": "https://leetcode.cn/problems/consecutive-transactions-with-increasing-amounts/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2702使数字变为非正数的最小操作次数",
        "hardRate": "HARD",
        "passRate": "48.39%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-numbers-non-positive/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-numbers-non-positive/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2703返回传递的参数的长度",
        "hardRate": "EASY",
        "passRate": "94.18%",
        "problemsUrl": "https://leetcode.cn/problems/return-length-of-arguments-passed/",
        "solutionsUrl": "https://leetcode.cn/problems/return-length-of-arguments-passed/solution",
        "problemsDesc": "请你编写一个函数 <code>argumentsLength</code>，返回传递给该函数的参数数量。\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>argsArr = [5]\n<b>输出：</b>1\n<strong>解释：</strong>\nargumentsLength(5); // 1\n\n只传递了一个值给函数，因此它应返回 1。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>argsArr = [{}, null, \"3\"]\n<b>输出：</b>3\n<b>解释：</b>\nargumentsLength({}, null, \"3\"); // 3\n\n传递了三个值给函数，因此它应返回 3。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>argsArr 是一个有效的 JSON 数组</code></li>\n\t<li><code>0 &lt;= argsArr.length &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2704相等还是不相等",
        "hardRate": "EASY",
        "passRate": "50.66%",
        "problemsUrl": "https://leetcode.cn/problems/to-be-or-not-to-be/",
        "solutionsUrl": "https://leetcode.cn/problems/to-be-or-not-to-be/solution",
        "problemsDesc": "<p>请你编写一个名为 <code>expect</code> 的函数，用于帮助开发人员测试他们的代码。它应该接受任何值 <code>val</code> 并返回一个包含以下两个函数的对象。</p>\n\n<ul>\n\t<li><code>toBe(val)</code> 接受另一个值并在两个值相等（ <code>===</code> ）时返回 <code>true</code> 。如果它们不相等，则应抛出错误 <code>\"Not Equal\"</code> 。</li>\n\t<li><code>notToBe(val)</code> 接受另一个值并在两个值不相等（ <code>!==</code> ）时返回 <code>true</code> 。如果它们相等，则应抛出错误 <code>\"Equal\"</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>func = () =&gt; expect(5).toBe(5)\n<b>输出：</b>{\"value\": true}\n<b>解释：</b>5 === 5 因此该表达式返回 true。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>func = () =&gt; expect(5).toBe(null)\n<b>输出：</b>{\"error\": \"Not Equal\"}\n<b>解释：</b>5 !== null 因此抛出错误 \"Not Equal\".\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>func = () =&gt; expect(5).notToBe(null)\n<b>输出：</b>{\"value\": true}\n<b>解释：</b>5 !== null 因此该表达式返回 true.\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2705精简对象",
        "hardRate": "MEDIUM",
        "passRate": "61.03%",
        "problemsUrl": "https://leetcode.cn/problems/compact-object/",
        "solutionsUrl": "https://leetcode.cn/problems/compact-object/solution",
        "problemsDesc": "<p>现给定一个对象或数组 <code>obj</code>，返回一个 <strong>精简对象</strong> 。<strong>精简对象</strong> 与原始对象相同，只是将包含 <strong>假</strong> 值的键移除。该操作适用于对象及其嵌套对象。数组被视为索引作为键的对象。当 <code>Boolean(value)</code> 返回 <code>false</code> 时，值被视为 <strong>假</strong> 值。</p>\n\n<p>你可以假设 <code>obj</code> 是 <code>JSON.parse</code> 的输出结果。换句话说，它是有效的 JSON。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>obj = [null, 0, false, 1]\n<b>输出：</b>[1]\n<b>解释：</b>数组中的所有假值已被移除。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>obj = {\"a\": null, \"b\": [false, 1]}\n<b>输出：</b>{\"b\": [1]}\n<b>解释：</b>obj[\"a\"] 和 obj[\"b\"][0] 包含假值，因此被移除。</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>obj = [null, 0, 5, [0], [false, 16]]\n<b>输出：</b>[5, [], [16]]\n<b>解释：</b>obj[0], obj[1], obj[3][0], 和 obj[4][0] 包含假值，因此被移除。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>obj 是一个有效的 JSON 对象</code></li>\n\t<li><code>2 &lt;= JSON.stringify(obj).length &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2706购买两块巧克力",
        "hardRate": "EASY",
        "passRate": "79.53%",
        "problemsUrl": "https://leetcode.cn/problems/buy-two-chocolates/",
        "solutionsUrl": "https://leetcode.cn/problems/buy-two-chocolates/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>prices</code>&nbsp;，它表示一个商店里若干巧克力的价格。同时给你一个整数&nbsp;<code>money</code>&nbsp;，表示你一开始拥有的钱数。</p>\n\n<p>你必须购买 <strong>恰好&nbsp;</strong>两块巧克力，而且剩余的钱数必须是 <strong>非负数</strong>&nbsp;。同时你想最小化购买两块巧克力的总花费。</p>\n\n<p>请你返回在购买两块巧克力后，最多能剩下多少钱。如果购买任意两块巧克力都超过了你拥有的钱，请你返回 <code>money</code>&nbsp;。注意剩余钱数必须是非负数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>prices = [1,2,2], money = 3\n<b>输出：</b>0\n<b>解释：</b>分别购买价格为 1 和 2 的巧克力。你剩下 3 - 3 = 0 块钱。所以我们返回 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>prices = [3,2,3], money = 3\n<b>输出：</b>3\n<b>解释：</b>购买任意 2 块巧克力都会超过你拥有的钱数，所以我们返回 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= prices.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= prices[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= money &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2707字符串中的额外字符",
        "hardRate": "MEDIUM",
        "passRate": "41.98%",
        "problemsUrl": "https://leetcode.cn/problems/extra-characters-in-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/extra-characters-in-a-string/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>s</code>&nbsp;和一个单词字典&nbsp;<code>dictionary</code>&nbsp;。你需要将&nbsp;<code>s</code>&nbsp;分割成若干个 <strong>互不重叠</strong>&nbsp;的子字符串，每个子字符串都在&nbsp;<code>dictionary</code>&nbsp;中出现过。<code>s</code>&nbsp;中可能会有一些&nbsp;<strong>额外的字符</strong>&nbsp;不在任何子字符串中。</p>\n\n<p>请你采取最优策略分割 <code>s</code>&nbsp;，使剩下的字符 <strong>最少</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"leetscode\", dictionary = [\"leet\",\"code\",\"leetcode\"]\n<b>输出：</b>1\n<b>解释：</b>将 s 分成两个子字符串：下标从 0 到 3 的 \"leet\" 和下标从 5 到 8 的 \"code\" 。只有 1 个字符没有使用（下标为 4），所以我们返回 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"sayhelloworld\", dictionary = [\"hello\",\"world\"]\n<b>输出：</b>3\n<b>解释：</b>将 s 分成两个子字符串：下标从 3 到 7 的 \"hello\" 和下标从 8 到 12 的 \"world\" 。下标为 0 ，1 和 2 的字符没有使用，所以我们返回 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= dictionary.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= dictionary[i].length &lt;= 50</code></li>\n\t<li><code>dictionary[i]</code>&nbsp;和&nbsp;<code>s</code>&nbsp;只包含小写英文字母。</li>\n\t<li><code>dictionary</code>&nbsp;中的单词互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2708一个小组的最大实力值",
        "hardRate": "MEDIUM",
        "passRate": "30.21%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-strength-of-a-group/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-strength-of-a-group/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，它表示一个班级中所有学生在一次考试中的成绩。老师想选出一部分同学组成一个 <strong>非空</strong>&nbsp;小组，且这个小组的 <strong>实力值</strong>&nbsp;最大，如果这个小组里的学生下标为&nbsp;<code>i<sub>0</sub></code>, <code>i<sub>1</sub></code>, <code>i<sub>2</sub></code>, ... , <code>i<sub>k</sub></code>&nbsp;，那么这个小组的实力值定义为&nbsp;<code>nums[i<sub>0</sub>] * nums[i<sub>1</sub>] * nums[i<sub>2</sub>] * ... * nums[i<sub>k</sub>​]</code>&nbsp;。</p>\n\n<p>请你返回老师创建的小组能得到的最大实力值为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [3,-1,-5,2,5,-9]\n<strong>输出：</strong>1350\n<b>解释：</b>一种构成最大实力值小组的方案是选择下标为 [0,2,3,4,5] 的学生。实力值为 3 * (-5) * 2 * 5 * (-9) = 1350 ，这是可以得到的最大实力值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [-4,-5,-4]\n<b>输出：</b>20\n<b>解释：</b>选择下标为 [0, 1] 的学生。得到的实力值为 20 。我们没法得到更大的实力值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 13</code></li>\n\t<li><code>-9 &lt;= nums[i] &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2709最大公约数遍历",
        "hardRate": "HARD",
        "passRate": "24.16%",
        "problemsUrl": "https://leetcode.cn/problems/greatest-common-divisor-traversal/",
        "solutionsUrl": "https://leetcode.cn/problems/greatest-common-divisor-traversal/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，你可以在一些下标之间遍历。对于两个下标&nbsp;<code>i</code>&nbsp;和&nbsp;<code>j</code>（<code>i != j</code>），当且仅当&nbsp;<code>gcd(nums[i], nums[j]) &gt; 1</code>&nbsp;时，我们可以在两个下标之间通行，其中&nbsp;<code>gcd</code>&nbsp;是两个数的 <strong>最大公约数</strong>&nbsp;。</p>\n\n<p>你需要判断 <code>nums</code>&nbsp;数组中&nbsp;<strong>任意&nbsp;</strong>两个满足 <code>i &lt; j</code>&nbsp;的下标&nbsp;<code>i</code>&nbsp;和&nbsp;<code>j</code> ，是否存在若干次通行可以从 <code>i</code>&nbsp;遍历到 <code>j</code>&nbsp;。</p>\n\n<p>如果任意满足条件的下标对都可以遍历，那么返回 <code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,3,6]\n<b>输出：</b>true\n<b>解释：</b>这个例子中，总共有 3 个下标对：(0, 1) ，(0, 2) 和 (1, 2) 。\n从下标 0 到下标 1 ，我们可以遍历 0 -&gt; 2 -&gt; 1 ，我们可以从下标 0 到 2 是因为 gcd(nums[0], nums[2]) = gcd(2, 6) = 2 &gt; 1 ，从下标 2 到 1 是因为 gcd(nums[2], nums[1]) = gcd(6, 3) = 3 &gt; 1 。\n从下标 0 到下标 2 ，我们可以直接遍历，因为 gcd(nums[0], nums[2]) = gcd(2, 6) = 2 &gt; 1 。同理，我们也可以从下标 1 到 2 因为 gcd(nums[1], nums[2]) = gcd(3, 6) = 3 &gt; 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,9,5]\n<b>输出：</b>false\n<b>解释：</b>我们没法从下标 0 到 2 ，所以返回 false 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [4,3,12,8]\n<b>输出：</b>true\n<b>解释：</b>总共有 6 个下标对：(0, 1) ，(0, 2) ，(0, 3) ，(1, 2) ，(1, 3) 和 (2, 3) 。所有下标对之间都存在可行的遍历，所以返回 true 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2710移除字符串中的尾随零",
        "hardRate": "EASY",
        "passRate": "83.38%",
        "problemsUrl": "https://leetcode.cn/problems/remove-trailing-zeros-from-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-trailing-zeros-from-a-string/solution",
        "problemsDesc": "<p>给你一个用字符串表示的正整数 <code>num</code> ，请你以字符串形式返回不含尾随零的整数<em> </em><code>num</code><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = \"51230100\"\n<strong>输出：</strong>\"512301\"\n<strong>解释：</strong>整数 \"51230100\" 有 2 个尾随零，移除并返回整数 \"512301\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = \"123\"\n<strong>输出：</strong>\"123\"\n<strong>解释：</strong>整数 \"123\" 不含尾随零，返回整数 \"123\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 1000</code></li>\n\t<li><code>num</code> 仅由数字 <code>0</code> 到 <code>9</code> 组成</li>\n\t<li><code>num</code> 不含前导零</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2711对角线上不同值的数量差",
        "hardRate": "MEDIUM",
        "passRate": "72.10%",
        "problemsUrl": "https://leetcode.cn/problems/difference-of-number-of-distinct-values-on-diagonals/",
        "solutionsUrl": "https://leetcode.cn/problems/difference-of-number-of-distinct-values-on-diagonals/solution",
        "problemsDesc": "<p>给你一个下标从 <code>0</code> 开始、大小为 <code>m x n</code> 的二维矩阵 <code>grid</code> ，请你求解大小同样为 <code>m x n</code> 的答案矩阵 <code>answer</code> 。</p>\n\n<p>矩阵 <code>answer</code> 中每个单元格 <code>(r, c)</code> 的值可以按下述方式进行计算：</p>\n\n<ul>\n\t<li>令 <code>topLeft[r][c]</code> 为矩阵 <code>grid</code> 中单元格 <code>(r, c)</code> 左上角对角线上 <strong>不同值</strong> 的数量。</li>\n\t<li>令 <code>bottomRight[r][c]</code> 为矩阵 <code>grid</code> 中单元格 <code>(r, c)</code> 右下角对角线上 <strong>不同值</strong> 的数量。</li>\n</ul>\n\n<p>然后 <code>answer[r][c] = |topLeft[r][c] - bottomRight[r][c]|</code> 。</p>\n\n<p>返回矩阵 <code>answer</code> 。</p>\n\n<p><strong>矩阵对角线</strong> 是从最顶行或最左列的某个单元格开始，向右下方向走到矩阵末尾的对角线。</p>\n\n<p>如果单元格 <code>(r1, c1)</code> 和单元格 <code>(r, c) </code>属于同一条对角线且 <code>r1 &lt; r</code> ，则单元格 <code>(r1, c1)</code> 属于单元格 <code>(r, c)</code> 的左上对角线。类似地，可以定义右下对角线。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/19/ex2.png\" style=\"width: 786px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,2,3],[3,1,5],[3,2,1]]\n<strong>输出：</strong>[[1,1,0],[1,0,1],[0,1,1]]\n<strong>解释：</strong>第 1 个图表示最初的矩阵 grid 。&nbsp;\n第 2 个图表示对单元格 (0,0) 计算，其中蓝色单元格是位于右下对角线的单元格。\n第 3 个图表示对单元格 (1,2) 计算，其中红色单元格是位于左上对角线的单元格。\n第 4 个图表示对单元格 (1,1) 计算，其中蓝色单元格是位于右下对角线的单元格，红色单元格是位于左上对角线的单元格。\n- 单元格 (0,0) 的右下对角线包含 [1,1] ，而左上对角线包含 [] 。对应答案是 |1 - 0| = 1 。\n- 单元格 (1,2) 的右下对角线包含 [] ，而左上对角线包含 [2] 。对应答案是 |0 - 1| = 1 。\n- 单元格 (1,1) 的右下对角线包含 [1] ，而左上对角线包含 [1] 。对应答案是 |1 - 1| = 0 。\n其他单元格的对应答案也可以按照这样的流程进行计算。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1]]\n<strong>输出：</strong>[[0]]\n<strong>解释：</strong>- 单元格 (0,0) 的右下对角线包含 [] ，左上对角线包含 [] 。对应答案是 |0 - 0| = 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n, grid[i][j] &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2712使所有字符相等的最小成本",
        "hardRate": "MEDIUM",
        "passRate": "56.28%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-make-all-characters-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-make-all-characters-equal/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的二进制字符串 <code>s</code> ，你可以对其执行两种操作：</p>\n\n<ul>\n\t<li>选中一个下标 <code>i</code> 并且反转从下标 <code>0</code> 到下标 <code>i</code>（包括下标 <code>0</code> 和下标 <code>i</code> ）的所有字符，成本为 <code>i + 1</code> 。</li>\n\t<li>选中一个下标 <code>i</code> 并且反转从下标 <code>i</code> 到下标 <code>n - 1</code>（包括下标 <code>i</code> 和下标 <code>n - 1</code> ）的所有字符，成本为 <code>n - i</code> 。</li>\n</ul>\n\n<p>返回使字符串内所有字符 <strong>相等</strong> 需要的 <strong>最小成本</strong> 。</p>\n\n<p><strong>反转</strong> 字符意味着：如果原来的值是 '0' ，则反转后值变为 '1' ，反之亦然。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0011\"\n<strong>输出：</strong>2\n<strong>解释：</strong>执行第二种操作，选中下标 <code>i = 2</code> ，可以得到 <code>s = \"0000\" ，成本为 2</code> 。可以证明 2 是使所有字符相等的最小成本。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"010101\"\n<strong>输出：</strong>9\n<strong>解释：</strong>执行第一种操作，选中下标 i = 2 ，可以得到 s = \"101101\" ，成本为 3 。\n执行第一种操作，选中下标 i = 1 ，可以得到 s = \"011101\" ，成本为 2 。\n执行第一种操作，选中下标 i = 0 ，可以得到 s = \"111101\" ，成本为 1 。\n执行第二种操作，选中下标 i = 4 ，可以得到 s = \"111110\" ，成本为 2 。\n执行第一种操作，选中下标 i = 5 ，可以得到 s = \"111111\" ，成本为 1 。\n使所有字符相等的总成本等于 9 。可以证明 9 是使所有字符相等的最小成本。 </pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length == n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2713矩阵中严格递增的单元格数",
        "hardRate": "HARD",
        "passRate": "35.21%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>1</strong> 开始、大小为 <code>m x n</code> 的整数矩阵 <code>mat</code>，你可以选择任一单元格作为 <strong>起始单元格</strong> 。</p>\n\n<p>从起始单元格出发，你可以移动到 <strong>同一行或同一列</strong> 中的任何其他单元格，但前提是目标单元格的值<strong> 严格大于 </strong>当前单元格的值。</p>\n\n<p>你可以多次重复这一过程，从一个单元格移动到另一个单元格，直到无法再进行任何移动。</p>\n\n<p>请你找出从某个单元开始访问矩阵所能访问的 <strong>单元格的最大数量</strong> 。</p>\n\n<p>返回一个表示可访问单元格最大数量的整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/23/diag1drawio.png\" style=\"width: 200px; height: 176px;\"></strong></p>\n\n<pre><strong>输入：</strong>mat = [[3,1],[3,4]]\n<strong>输出：</strong>2\n<strong>解释：</strong>上图展示了从第 1 行、第 2 列的单元格开始，可以访问 2 个单元格。可以证明，无论从哪个单元格开始，最多只能访问 2 个单元格，因此答案是 2 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/23/diag3drawio.png\" style=\"width: 200px; height: 176px;\"></strong></p>\n\n<pre><strong>输入：</strong>mat = [[1,1],[1,1]]\n<strong>输出：</strong>1\n<strong>解释：</strong>由于目标单元格必须严格大于当前单元格，在本示例中只能访问 1 个单元格。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/23/diag4drawio.png\" style=\"width: 350px; height: 250px;\"></strong></p>\n\n<pre><strong>输入：</strong>mat = [[3,1,6],[-9,5,7]]\n<strong>输出：</strong>4\n<strong>解释：</strong>上图展示了从第 2 行、第 1 列的单元格开始，可以访问 4 个单元格。可以证明，无论从哪个单元格开始，最多只能访问 4 个单元格，因此答案是 4 。  \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length&nbsp;</code></li>\n\t<li><code>n == mat[i].length&nbsp;</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= mat[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2714找到最短路径的 K 次跨越",
        "hardRate": "HARD",
        "passRate": "72.22%",
        "problemsUrl": "https://leetcode.cn/problems/find-shortest-path-with-k-hops/",
        "solutionsUrl": "https://leetcode.cn/problems/find-shortest-path-with-k-hops/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2715执行可取消的延迟函数",
        "hardRate": "EASY",
        "passRate": "79.61%",
        "problemsUrl": "https://leetcode.cn/problems/execute-cancellable-function-with-delay/",
        "solutionsUrl": "https://leetcode.cn/problems/execute-cancellable-function-with-delay/solution",
        "problemsDesc": "<p>现给定一个函数 <code>fn</code>&nbsp;，一个参数数组 <code>args</code> 和一个以毫秒为单位的超时时间 <code>t</code> ，返回一个取消函数 <code>cancelFn</code> 。</p>\n\n<p>在经过 <code>t</code> 毫秒的延迟后，<strong>除非</strong> 先调用 <code>cancelFn</code> ，否则&nbsp;<code>fn</code> 应该以 <code>args</code> 作为参数被调用。并且在这种情况下，<code>fn</code> 不应该被调用。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1:</strong></p>\n\n<pre>\n<b>输入：</b>fn = (x) =&gt; x * 5, args = [2], t = 20, cancelTime = 50\n<b>输出：</b>[{\"time\": 20, \"returned\": 10}]\n<b>解释：</b>\nconst cancel = cancellable(fn, [2], 20); // // 在 t=20ms 时调用 fn(2)\nsetTimeout(cancel, 50);\n\ncancelTime（50ms）在延迟时间（20ms）之后，所以 fn(2) 应该在 t=20ms 时调用。fn 的返回值是 10。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>fn = (x) =&gt; x**2, args = [2], t = 100, cancelTime = 50\n<b>输出：</b>[]\n<b>解释：</b>fn(2) 从未被调用，因为 cancelTime（50ms）在延迟时间（100ms）之前。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>fn = (x1, x2) =&gt; x1 * x2, args = [2,4], t = 30, cancelTime = 100\n<b>输出：</b>[{\"time\": 30, \"returned\": 8}]\n<b>解释：</b>fn(2) 从未被调用，因为 cancelTime（50ms）在延迟时间（100ms）之前。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>fn 是一个函数</code></li>\n\t<li><code>args 是一个有效的 JSON 数组</code></li>\n\t<li><code>1 &lt;= args.length &lt;= 10</code></li>\n\t<li><code><font face=\"monospace\">20 &lt;= t &lt;= 1000</font></code></li>\n\t<li><code><font face=\"monospace\">10 &lt;= cancelT &lt;= 1000</font></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2716最小化字符串长度",
        "hardRate": "EASY",
        "passRate": "72.30%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-string-length/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-string-length/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，重复执行下述操作 <strong>任意</strong> 次：</p>\n\n<ul>\n\t<li>在字符串中选出一个下标 <code>i</code> ，并使 <code>c</code> 为字符串下标 <code>i</code> 处的字符。并在 <code>i</code> <strong>左侧</strong>（如果有）和 <strong>右侧</strong>（如果有）各 <strong>删除 </strong>一个距离 <code>i</code> <strong>最近</strong> 的字符 <code>c</code> 。</li>\n</ul>\n\n<p>请你通过执行上述操作任意次，使 <code>s</code> 的长度 <strong>最小化</strong> 。</p>\n\n<p>返回一个表示 <strong>最小化</strong> 字符串的长度的整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aaabc\"\n<strong>输出：</strong>3\n<strong>解释：</strong>在这个示例中，s 等于 \"aaabc\" 。我们可以选择位于下标 1 处的字符 'a' 开始。接着删除下标 1 左侧最近的那个 'a'（位于下标 0）以及下标 1 右侧最近的那个 'a'（位于下标 2）。执行操作后，字符串变为 \"abc\" 。继续对字符串执行任何操作都不会改变其长度。因此，最小化字符串的长度是 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"cbbd\"\n<strong>输出：</strong>3\n<strong>解释：</strong>我们可以选择位于下标 1 处的字符 'b' 开始。下标 1 左侧不存在字符 'b' ，但右侧存在一个字符 'b'（位于下标 2），所以会删除位于下标 2 的字符 'b' 。执行操作后，字符串变为 \"cbd\" 。继续对字符串执行任何操作都不会改变其长度。因此，最小化字符串的长度是 3 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"dddaaa\"\n<strong>输出：</strong>2\n<strong>解释：</strong>我们可以选择位于下标 1 处的字符 'd' 开始。接着删除下标 1 左侧最近的那个 'd'（位于下标 0）以及下标 1 右侧最近的那个 'd'（位于下标 2）。执行操作后，字符串变为 \"daaa\" 。继续对新字符串执行操作，可以选择位于下标 2 的字符 'a' 。接着删除下标 2 左侧最近的那个 'a'（位于下标 1）以及下标 2 右侧最近的那个 'a'（位于下标 3）。执行操作后，字符串变为 \"da\" 。继续对字符串执行任何操作都不会改变其长度。因此，最小化字符串的长度是 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2717半有序排列",
        "hardRate": "EASY",
        "passRate": "72.86%",
        "problemsUrl": "https://leetcode.cn/problems/semi-ordered-permutation/",
        "solutionsUrl": "https://leetcode.cn/problems/semi-ordered-permutation/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数排列 <code>nums</code> 。</p>\n\n<p>如果排列的第一个数字等于 <code>1</code> 且最后一个数字等于 <code>n</code> ，则称其为 <strong>半有序排列</strong> 。你可以执行多次下述操作，直到将 <code>nums</code> 变成一个 <strong>半有序排列</strong> ：</p>\n\n<ul>\n\t<li>选择 <code>nums</code> 中相邻的两个元素，然后交换它们。</li>\n</ul>\n\n<p>返回使 <code>nums</code> 变成 <strong>半有序排列</strong> 所需的最小操作次数。</p>\n\n<p><strong>排列</strong> 是一个长度为 <code>n</code> 的整数序列，其中包含从 <code>1</code> 到 <code>n</code> 的每个数字恰好一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,4,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>可以依次执行下述操作得到半有序排列：\n1 - 交换下标 0 和下标 1 对应元素。排列变为 [1,2,4,3] 。\n2 - 交换下标 2 和下标 3 对应元素。排列变为 [1,2,3,4] 。\n可以证明，要让 nums 成为半有序排列，不存在执行操作少于 2 次的方案。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,4,1,3]\n<strong>输出：</strong>3\n<strong>解释：\n</strong>可以依次执行下述操作得到半有序排列：\n1 - 交换下标 1 和下标 2 对应元素。排列变为 [2,1,4,3] 。\n2 - 交换下标 0 和下标 1 对应元素。排列变为 [1,2,4,3] 。\n3 - 交换下标 2 和下标 3 对应元素。排列变为 [1,2,3,4] 。\n可以证明，要让 nums 成为半有序排列，不存在执行操作少于 3 次的方案。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,4,2,5]\n<strong>输出：</strong>0\n<strong>解释：</strong>这个排列已经是一个半有序排列，无需执行任何操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length == n &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i]&nbsp;&lt;= 50</code></li>\n\t<li><code>nums</code> 是一个 <strong>排列</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2718查询后矩阵的和",
        "hardRate": "MEDIUM",
        "passRate": "33.01%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-matrix-after-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-matrix-after-queries/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;和一个下标从 <strong>0</strong>&nbsp;开始的 <strong>二维数组</strong>&nbsp;<code>queries</code>&nbsp;，其中&nbsp;<code>queries[i] = [type<sub>i</sub>, index<sub>i</sub>, val<sub>i</sub>]</code>&nbsp;。</p>\n\n<p>一开始，给你一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>n x n</code>&nbsp;矩阵，所有元素均为 <code>0</code>&nbsp;。每一个查询，你需要执行以下操作之一：</p>\n\n<ul>\n\t<li>如果&nbsp;<code>type<sub>i</sub> == 0</code>&nbsp;，将第&nbsp;<code>index<sub>i</sub></code>&nbsp;行的元素全部修改为&nbsp;<code>val<sub>i</sub></code>&nbsp;，覆盖任何之前的值。</li>\n\t<li>如果&nbsp;<code>type<sub>i</sub> == 1</code>&nbsp;，将第&nbsp;<code>index<sub>i</sub></code>&nbsp;列的元素全部修改为 <code>val<sub>i</sub></code>&nbsp;，覆盖任何之前的值。</li>\n</ul>\n\n<p>请你执行完所有查询以后，返回矩阵中所有整数的和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/05/11/exm1.png\" style=\"width: 681px; height: 161px;\"></p>\n\n<pre><b>输入：</b>n = 3, queries = [[0,0,1],[1,2,2],[0,2,3],[1,0,4]]\n<b>输出：</b>23\n<b>解释：</b>上图展示了每个查询以后矩阵的值。所有操作执行完以后，矩阵元素之和为 23 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/05/11/exm2.png\" style=\"width: 681px; height: 331px;\"></p>\n\n<pre><b>输入：</b>n = 3, queries = [[0,0,4],[0,1,2],[1,0,1],[0,2,3],[1,2,1]]\n<b>输出：</b>17\n<b>解释：</b>上图展示了每一个查询操作之后的矩阵。所有操作执行完以后，矩阵元素之和为 17 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>queries[i].length == 3</code></li>\n\t<li><code>0 &lt;= type<sub>i</sub> &lt;= 1</code></li>\n\t<li><code>0 &lt;= index<sub>i</sub>&nbsp;&lt; n</code></li>\n\t<li><code>0 &lt;= val<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2719统计整数数目",
        "hardRate": "HARD",
        "passRate": "47.25%",
        "problemsUrl": "https://leetcode.cn/problems/count-of-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/count-of-integers/solution",
        "problemsDesc": "<p>给你两个数字字符串&nbsp;<code>num1</code>&nbsp;和&nbsp;<code>num2</code>&nbsp;，以及两个整数&nbsp;<code>max_sum</code> 和&nbsp;<code>min_sum</code>&nbsp;。如果一个整数&nbsp;<code>x</code>&nbsp;满足以下条件，我们称它是一个好整数：</p>\n\n<ul>\n\t<li><code>num1 &lt;= x &lt;= num2</code></li>\n\t<li><code>min_sum &lt;= digit_sum(x) &lt;= max_sum</code>.</li>\n</ul>\n\n<p>请你返回好整数的数目。答案可能很大，请返回答案对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;取余后的结果。</p>\n\n<p>注意，<code>digit_sum(x)</code>&nbsp;表示&nbsp;<code>x</code>&nbsp;各位数字之和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>num1 = \"1\", num2 = \"12\", min_num = 1, max_num = 8\n<b>输出：</b>11\n<b>解释：</b>总共有 11 个整数的数位和在 1 到 8 之间，分别是 1,2,3,4,5,6,7,8,10,11 和 12 。所以我们返回 11 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>num1 = \"1\", num2 = \"5\", min_num = 1, max_num = 5\n<b>输出：</b>5\n<b>解释：</b>数位和在 1 到 5 之间的 5 个整数分别为 1,2,3,4 和 5 。所以我们返回 5 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num1 &lt;= num2 &lt;= 10<sup>22</sup></code></li>\n\t<li><code>1 &lt;= min_sum &lt;= max_sum &lt;= 400</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2720受欢迎度百分比",
        "hardRate": "HARD",
        "passRate": "61.36%",
        "problemsUrl": "https://leetcode.cn/problems/popularity-percentage/",
        "solutionsUrl": "https://leetcode.cn/problems/popularity-percentage/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2721并行执行异步函数",
        "hardRate": "MEDIUM",
        "passRate": "56.98%",
        "problemsUrl": "https://leetcode.cn/problems/execute-asynchronous-functions-in-parallel/",
        "solutionsUrl": "https://leetcode.cn/problems/execute-asynchronous-functions-in-parallel/solution",
        "problemsDesc": "<p>给定一个异步函数数组 <code>functions</code>，返回一个新的 promise 对象&nbsp;<code>promise</code>。数组中的每个函数都不接受参数并返回一个 promise。</p>\n\n<p><code>promise</code> resolve 条件：</p>\n\n<ul>\n\t<li>当所有从 <code>functions</code> 返回的 promise 都成功解析时。<code>promise</code> 的解析值应该是一个按照它们在 <code>functions</code> 中的顺序排列的 promise 的解析值数组。</li>\n</ul>\n\n<p><code>promise</code>&nbsp;reject 条件：</p>\n\n<ul>\n\t<li>当任何从 <code>functions</code> 返回的 promise 被拒绝时。<code>promise</code> 也会被拒绝，并返回第一个拒绝的原因。</li>\n</ul>\n\n<p>请在不使用内置的 <code>Promise.all</code> 函数的情况下解决。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>functions = [\n&nbsp; () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(5), 200))\n]\n<b>输出：</b>{\"t\": 200, \"resolved\": [5]}\n<b>解释：</b>\npromiseAll(functions).then(console.log); // [5]\n\n单个函数在 200 毫秒后以值 5 成功解析。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>functions = [\n    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(1), 200)), \n    () =&gt; new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(\"Error\"), 100))\n]\n<b>输出：</b>{\"t\": 100, \"rejected\": \"Error\"}\n<b>解释：</b>由于其中一个 promise 被拒绝，返回的 promise 也在同一时间被拒绝并返回相同的错误。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>functions = [\n    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(4), 50)), \n    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(10), 150)), \n    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(16), 100))\n]\n<b>输出：</b>{\"t\": 150, \"resolved\": [4, 10, 16]}\n<b>解释：</b>所有的 promise 都成功执行。当最后一个 promise 被解析时，返回的 promise 也被解析了。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>functions&nbsp;is an array of functions that returns promises</code></li>\n\t<li><code>1 &lt;= functions.length &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2722根据 ID 合并两个数组",
        "hardRate": "MEDIUM",
        "passRate": "48.61%",
        "problemsUrl": "https://leetcode.cn/problems/join-two-arrays-by-id/",
        "solutionsUrl": "https://leetcode.cn/problems/join-two-arrays-by-id/solution",
        "problemsDesc": "<p>现给定两个数组 <code>arr1</code> 和 <code>arr2</code> ，返回一个新的数组 <code>joinedArray</code> 。两个输入数组中的每个对象都包含一个 <code>id</code> 字段。<code>joinedArray</code> 是一个通过 <code>id</code> 将 <code>arr1</code> 和 <code>arr2</code> 连接而成的数组。<code>joinedArray</code> 的长度应为唯一值 <code>id</code> 的长度。返回的数组应按 <code>id</code> <strong>升序</strong> 排序。</p>\n\n<p>如果一个 <code>id</code> 存在于一个数组中但不存在于另一个数组中，则该对象应包含在结果数组中且不进行修改。</p>\n\n<p>如果两个对象共享一个 <code>id</code> ，则它们的属性应进行合并：</p>\n\n<ul>\n\t<li>如果一个键只存在于一个对象中，则该键值对应该包含在对象中。</li>\n\t<li>如果一个键在两个对象中都包含，则 <code>arr2</code> 中的值应覆盖 <code>arr1</code> 中的值。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>\narr1 = [\n&nbsp;   {\"id\": 1, \"x\": 1},\n&nbsp;   {\"id\": 2, \"x\": 9}\n], \narr2 = [\n    {\"id\": 3, \"x\": 5}\n]\n<b>输出：</b>\n[\n&nbsp;   {\"id\": 1, \"x\": 1},\n&nbsp;   {\"id\": 2, \"x\": 9},\n    {\"id\": 3, \"x\": 5}\n]\n<b>解释：</b>没有共同的 id，因此将 arr1 与 arr2 简单地连接起来。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>\narr1 = [\n    {\"id\": 1, \"x\": 2, \"y\": 3},\n    {\"id\": 2, \"x\": 3, \"y\": 6}\n], \narr2 = [\n    {\"id\": 2, \"x\": 10, \"y\": 20},\n    {\"id\": 3, \"x\": 0, \"y\": 0}\n]\n<b>输出：</b>\n[\n    {\"id\": 1, \"x\": 2, \"y\": 3},\n    {\"id\": 2, \"x\": 10, \"y\": 20},\n&nbsp;   {\"id\": 3, \"x\": 0, \"y\": 0}\n]\n<b>解释：</b>id 为 1 和 id 为 3 的对象在结果数组中保持不变。id 为 2 的两个对象合并在一起。arr2 中的键覆盖 arr1 中的值。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>\narr1 = [\n    {\"id\": 1, \"b\": {\"b\": 94},\"v\": [4, 3], \"y\": 48}\n]\narr2 = [\n    {\"id\": 1, \"b\": {\"c\": 84}, \"v\": [1, 3]}\n]\n<strong>输出：</strong> [\n    {\"id\": 1, \"b\": {\"c\": 84}, \"v\": [1, 3], \"y\": 48}\n]\n<b>解释：</b>具有 id 为 1 的对象合并在一起。对于键 \"b\" 和 \"v\" ，使用 arr2 中的值。由于键 \"y\" 只存在于 arr1 中，因此取 arr1 的值。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>arr1 和 arr2 都是有效的 JSON 数组</code></li>\n\t<li><code>在 arr1 和 arr2 中都有唯一的键值 id</code></li>\n\t<li><code>2 &lt;= JSON.stringify(arr1).length &lt;= 10<sup>6</sup></code></li>\n\t<li><code>2 &lt;= JSON.stringify(arr2).length &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2723添加两个 Promise 对象",
        "hardRate": "EASY",
        "passRate": "86.70%",
        "problemsUrl": "https://leetcode.cn/problems/add-two-promises/",
        "solutionsUrl": "https://leetcode.cn/problems/add-two-promises/solution",
        "problemsDesc": "给定两个 promise 对象&nbsp;<code>promise1</code> 和 <code>promise2</code>，返回一个新的 promise。<code>promise1</code> 和 <code>promise2</code> 都会被解析为一个数字。返回的 Promise 应该解析为这两个数字的和。\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>\npromise1 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(2), 20)), \npromise2 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(5), 60))\n<b>输出：</b>7\n<b>解释：</b>两个输入的 Promise 分别解析为值 2 和 5。返回的 Promise 应该解析为 2 + 5 = 7。返回的 Promise 解析的时间不作为判断条件。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>\npromise1 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(10), 50)), \npromise2 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(-12), 30))\n<b>输出：</b>-2\n<b>解释：</b>两个输入的 Promise 分别解析为值 10 和 -12。返回的 Promise 应该解析为 10 + -12 = -2。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>promise1 和 promise2 都是被解析为一个数字的 promise 对象</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2724排序方式",
        "hardRate": "EASY",
        "passRate": "80.47%",
        "problemsUrl": "https://leetcode.cn/problems/sort-by/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-by/solution",
        "problemsDesc": "<p>给定一个数组 <code>arr</code> 和一个函数 <code>fn</code>，返回一个排序后的数组 <code>sortedArr</code>。你可以假设 <code>fn</code> 只返回数字，并且这些数字决定了 <code>sortedArr</code> 的排序顺序。<code>sortedArr</code> 必须按照 <code>fn</code> 的输出值&nbsp;<strong>升序</strong> 排序。</p>\n\n<p>你可以假设对于给定的数组，<code>fn</code> 不会返回重复的数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [5, 4, 1, 2, 3], fn = (x) =&gt; x\n<b>输出：</b>[1, 2, 3, 4, 5]\n<b>解释：</b>fn 只是返回传入的数字，因此数组按升序排序。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [{\"x\": 1}, {\"x\": 0}, {\"x\": -1}], fn = (d) =&gt; d.x\n<b>输出：</b>[{\"x\": -1}, {\"x\": 0}, {\"x\": 1}]\n<b>解释：</b>fn 返回 \"x\" 键的值，因此数组根据该值排序。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [[3, 4], [5, 2], [10, 1]], fn = (x) =&gt; x[1]\n<b>输出：</b>[[10, 1], [5, 2], [3, 4]]\n<b>解释：</b>数组按照索引为 1 处的数字升序排序。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>arr 是一个有效的 JSON 数组</code></li>\n\t<li><code>fn 是一个函数，返回一个数字</code></li>\n\t<li><code>1 &lt;=&nbsp;arr.length &lt;= 5 * 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2725间隔取消",
        "hardRate": "EASY",
        "passRate": "73.42%",
        "problemsUrl": "https://leetcode.cn/problems/interval-cancellation/",
        "solutionsUrl": "https://leetcode.cn/problems/interval-cancellation/solution",
        "problemsDesc": "现给定一个函数 <code>fn</code>，一个参数数组 <code>args</code> 和一个时间间隔 <code>t</code>，返回一个取消函数 <code>cancelFn</code>。函数 <code>fn</code> 应该立即使用 <code>args</code> 调用，并且在每个 <code>t</code> 毫秒内再次调用，直到调用 <code>cancelFn</code>。\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>fn = (x) =&gt; x * 2, args = [4], t = 20, cancelT = 110\n<b>输出：</b>\n[\n   {\"time\": 0, \"returned\": 8},\n   {\"time\": 20, \"returned\": 8},\n   {\"time\": 40, \"returned\": 8},\n   {\"time\": 60, \"returned\": 8},\n   {\"time\": 80, \"returned\": 8},\n   {\"time\": 100, \"returned\": 8}\n]\n<strong>解释：</strong> 每隔 20ms，调用 fn(4)。直到 t=110ms，然后取消。\nconst cancel = cancellable(x =&gt; x * 2, [4], 20);\nsetTimeout(cancel, 110);\n第一次调用 fn 是在 0ms。fn(4) 返回 8。\n第二次调用 fn 是在 20ms。fn(4) 返回 8。\n第三次调用 fn 是在 40ms。fn(4) 返回 8。\n第四次调用 fn 是在&nbsp;60ms。fn(4) 返回 8。\n第五次调用 fn 是在 80ms。fn(4) 返回 8。\n第六次调用 fn 是在 100ms。fn(4) 返回 8。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>fn = (x1, x2) =&gt; (x1 * x2), args = [2, 5], t = 25, cancelT = 140\n<strong>输出：</strong> \n[\n   {\"time\": 0, \"returned\": 10},\n   {\"time\": 25, \"returned\": 10},\n   {\"time\": 50, \"returned\": 10},\n   {\"time\": 75, \"returned\": 10},\n   {\"time\": 100, \"returned\": 10},\n   {\"time\": 125, \"returned\": 10}\n]\n<strong>解释：</strong>每隔 25ms，调用 fn(2, 5)。直到 t=140ms，然后取消。\n第一次调用 fn 是在 0ms\n第二次调用 fn 是在 25ms\n第三次调用 fn 是在 50ms\n第四次调用 fn 是在&nbsp;75ms\n第五次调用 fn 是在 100ms\n第六次调用 fn 是在 125ms\n在 140ms 取消\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>fn = (x1, x2, x3) =&gt; (x1 + x2 + x3), args = [5, 1, 3], t = 50, cancelT = 180\n<b>输出：</b>\n[\n   {\"time\": 0, \"returned\": 9},\n   {\"time\": 50, \"returned\": 9},\n   {\"time\": 100, \"returned\": 9},\n   {\"time\": 150, \"returned\": 9}\n]\n<b>解释：</b>每隔 50ms，调用 fn(5, 1, 3)。直到 t=180ms，然后取消。\n第一次调用 fn 是在 0ms\n第二次调用 fn 是在 50ms\n第三次调用 fn 是在 100ms\n第四次调用 fn 是在&nbsp;150ms\n在 180ms 取消\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>fn 是一个函数</code></li>\n\t<li><code>args 是一个有效的 JSON 数组</code></li>\n\t<li><code>1 &lt;= args.length &lt;= 10</code></li>\n\t<li><code><font face=\"monospace\">20 &lt;= t &lt;= 1000</font></code></li>\n\t<li><code><font face=\"monospace\">10 &lt;= cancelT &lt;= 1000</font></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2726使用方法链的计算器",
        "hardRate": "EASY",
        "passRate": "59.95%",
        "problemsUrl": "https://leetcode.cn/problems/calculator-with-method-chaining/",
        "solutionsUrl": "https://leetcode.cn/problems/calculator-with-method-chaining/solution",
        "problemsDesc": "<p>设计一个类 <code>Calculator</code> 。该类应提供加法、减法、乘法、除法和乘方等数学运算功能。同时，它还应支持连续操作的方法链式调用。<code>Calculator</code> 类的构造函数应接受一个数字作为 <code>result</code> 的初始值。</p>\n\n<p>你的 <code>Calculator</code> 类应包含以下方法：</p>\n\n<ul>\n\t<li><code>add</code> - 将给定的数字 <code>value</code> 与 <code>result</code> 相加，并返回更新后的 <code>Calculator</code> 对象。</li>\n\t<li><code>subtract</code> - 从 <code>result</code> 中减去给定的数字 <code>value</code>&nbsp;，并返回更新后的 <code>Calculator</code> 对象。</li>\n\t<li><code>multiply</code> - 将 <code>result</code> 乘以给定的数字 <code>value</code> ，并返回更新后的&nbsp;<code>Calculator</code> 对象。</li>\n\t<li><code>divide</code> - 将 <code>result</code> 除以给定的数字 <code>value</code> ，并返回更新后的&nbsp;<code>Calculator</code> 对象。如果传入的值为 <code>0</code> ，则抛出错误 <code>\"Division by zero is not allowed\"</code> 。</li>\n\t<li><code>power</code> - 将 <code>result</code> 的值乘以给定的数字 <code>value</code> ，并返回更新后的&nbsp;<code>Calculator</code> 对象。</li>\n\t<li><code>getResult</code> - 返回 <code>result</code> 的值。</li>\n</ul>\n\n<p>结果与实际结果相差在 <code>10<sup>-5</sup></code><sup>&nbsp;</sup>范围内的解被认为是正确的。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre>\n<b>输入：</b>actions = [\"Calculator\", \"add\", \"subtract\", \"getResult\"], values = [10, 5, 7]\n<b>输出：</b>8\n<b>解释：</b>\nnew Calculator(10).add(5).subtract(7).getResult() // 10 + 5 - 7 = 8\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>actions = [\"Calculator\", \"multiply\", \"power\", \"getResult\"], values = [2, 5, 2]\n<b>输出：</b>100\n<b>解释：</b>\nnew Calculator(2).multiply(5).power(2).getResult() // (2 * 5) ^ 2 = 100\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>actions = [\"Calculator\", \"divide\", \"getResult\"], values = [20, 0]\n<b>输出：</b>\"Division by zero is not allowed\"\n<b>解释：</b>\nnew Calculator(20).divide(0).getResult() // 20 / 0 \n\n由于不能除以零，因此应抛出错误。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= actions.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= values.length &lt;= 2 * 10<sup>4</sup></code><code>&nbsp;- 1</code></li>\n\t<li><code>actions[i] 是 \"Calculator\", \"add\", \"subtract\", \"multiply\", \"divide\", \"power\", 和 \"getResult\" 其中的元素</code></li>\n\t<li><code><font face=\"monospace\">最后一个操作总是&nbsp;\"getResult\"</font></code></li>\n\t<li><code><font face=\"monospace\">values </font>是一个数字的 JSON 数组</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2727判断对象是否为空",
        "hardRate": "EASY",
        "passRate": "72.10%",
        "problemsUrl": "https://leetcode.cn/problems/is-object-empty/",
        "solutionsUrl": "https://leetcode.cn/problems/is-object-empty/solution",
        "problemsDesc": "<p>给定一个对象或数组，判断它是否为空。</p>\n\n<ul>\n\t<li>一个空对象不包含任何键值对。</li>\n\t<li>一个空数组不包含任何元素。</li>\n</ul>\n\n<p>你可以假设对象或数组是通过 <code>JSON.parse</code> 解析得到的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>obj = {\"x\": 5, \"y\": 42}\n<b>输出：</b>false\n<b>解释：</b>The object has 2 key-value pairs so it is not empty.\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>obj = {}\n<b>输出：</b>true\n<b>解释：</b>The object doesn't have any key-value pairs so it is empty.\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>obj = [null, false, 0]\n<b>输出：</b>false\n<b>解释：</b>The array has 3 elements so it is not empty.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>&nbsp;<code>2 &lt;= JSON.stringify(obj).length &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>你可以在 O(1) 时间复杂度内解决这个问题吗？</strong>",
        "isPlus": false
    },
    {
        "problemsName": " 2728计算一个环形街道上的房屋数量",
        "hardRate": "EASY",
        "passRate": "90.00%",
        "problemsUrl": "https://leetcode.cn/problems/count-houses-in-a-circular-street/",
        "solutionsUrl": "https://leetcode.cn/problems/count-houses-in-a-circular-street/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2729判断一个数是否迷人",
        "hardRate": "EASY",
        "passRate": "62.45%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-the-number-is-fascinating/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-the-number-is-fascinating/solution",
        "problemsDesc": "<p>给你一个三位数整数 <code>n</code>&nbsp;。</p>\n\n<p>如果经过以下修改得到的数字 <strong>恰好</strong>&nbsp;包含数字 <code>1</code>&nbsp;到 <code>9</code>&nbsp;各一次且不包含任何 <code>0</code>&nbsp;，那么我们称数字 <code>n</code>&nbsp;是 <strong>迷人的</strong>&nbsp;：</p>\n\n<ul>\n\t<li>将&nbsp;<code>n</code>&nbsp;与数字&nbsp;<code>2 * n</code> 和&nbsp;<code>3 * n</code>&nbsp;<strong>连接</strong>&nbsp;。</li>\n</ul>\n\n<p>如果 <code>n</code>&nbsp;是迷人的，返回&nbsp;<code>true</code>，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p><strong>连接</strong>&nbsp;两个数字表示把它们首尾相接连在一起。比方说&nbsp;<code>121</code> 和&nbsp;<code>371</code>&nbsp;连接得到&nbsp;<code>121371</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 192\n<b>输出：</b>true\n<b>解释：</b>我们将数字 n = 192 ，2 * n = 384 和 3 * n = 576 连接，得到 192384576 。这个数字包含 1 到 9 恰好各一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 100\n<b>输出：</b>false\n<b>解释：</b>我们将数字 n = 100 ，2 * n = 200 和 3 * n = 300 连接，得到 100200300 。这个数字不符合上述条件。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>100 &lt;= n &lt;= 999</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2730找到最长的半重复子字符串",
        "hardRate": "MEDIUM",
        "passRate": "45.65%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-longest-semi-repetitive-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-longest-semi-repetitive-substring/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>s</code>&nbsp;，这个字符串只包含&nbsp;<code>0</code>&nbsp;到&nbsp;<code>9</code>&nbsp;的数字字符。</p>\n\n<p>如果一个字符串&nbsp;<code>t</code>&nbsp;中至多有一对相邻字符是相等的，那么称这个字符串 <code>t</code> 是 <strong>半重复的</strong>&nbsp;。例如，<code>0010</code> 、<code>002020</code> 、<code>0123</code> 、<code>2002</code> 和 <code>54944</code> 是半重复字符串，而 <code>00101022</code> 和 <code>1101234883</code> 不是。</p>\n\n<p>请你返回 <code>s</code>&nbsp;中最长 <strong>半重复</strong>&nbsp;子字符串的长度。</p>\n\n<p>一个 <strong>子字符串</strong>&nbsp;是一个字符串中一段连续 <strong>非空</strong>&nbsp;的字符。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"52233\"\n<b>输出：</b>4\n<b>解释：</b>最长半重复子字符串是 \"5223\" ，子字符串从 i = 0 开始，在 j = 3 处结束。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"5494\"\n<b>输出：</b>4\n<b>解释：</b>s 就是一个半重复字符串，所以答案为 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"1111111\"\n<b>输出：</b>2\n<b>解释：</b>最长半重复子字符串是 \"11\" ，子字符串从 i = 0 开始，在 j = 1 处结束。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 50</code></li>\n\t<li><code>'0' &lt;= s[i] &lt;= '9'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2731移动机器人",
        "hardRate": "MEDIUM",
        "passRate": "33.78%",
        "problemsUrl": "https://leetcode.cn/problems/movement-of-robots/",
        "solutionsUrl": "https://leetcode.cn/problems/movement-of-robots/solution",
        "problemsDesc": "<p>有一些机器人分布在一条无限长的数轴上，他们初始坐标用一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;表示。当你给机器人下达命令时，它们以每秒钟一单位的速度开始移动。</p>\n\n<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，每个字符按顺序分别表示每个机器人移动的方向。<code>'L'</code>&nbsp;表示机器人往左或者数轴的负方向移动，<code>'R'</code>&nbsp;表示机器人往右或者数轴的正方向移动。</p>\n\n<p>当两个机器人相撞时，它们开始沿着原本相反的方向移动。</p>\n\n<p>请你返回指令重复执行 <code>d</code>&nbsp;秒后，所有机器人之间两两距离之和。由于答案可能很大，请你将答案对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;取余后返回。</p>\n\n<p><b>注意：</b></p>\n\n<ul>\n\t<li>对于坐标在&nbsp;<code>i</code> 和&nbsp;<code>j</code>&nbsp;的两个机器人，<code>(i,j)</code>&nbsp;和&nbsp;<code>(j,i)</code>&nbsp;视为相同的坐标对。也就是说，机器人视为无差别的。</li>\n\t<li>当机器人相撞时，它们 <strong>立即改变</strong>&nbsp;它们的前进时间，这个过程不消耗任何时间。</li>\n\t<li>\n\t<p>当两个机器人在同一时刻占据相同的位置时，就会相撞。</p>\n\n\t<ul>\n\t\t<li>\n\t\t<p>例如，如果一个机器人位于位置 0 并往右移动，另一个机器人位于位置 2 并往左移动，下一秒，它们都将占据位置 1，并改变方向。再下一秒钟后，第一个机器人位于位置 0 并往左移动，而另一个机器人位于位置 2 并往右移动。</p>\n\t\t</li>\n\t\t<li>\n\t\t<p>例如，如果一个机器人位于位置 0 并往右移动，另一个机器人位于位置 1 并往左移动，下一秒，第一个机器人位于位置 0 并往左行驶，而另一个机器人位于位置 1 并往右移动。</p>\n\t\t</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [-2,0,2], s = \"RLL\", d = 3\n<b>输出：</b>8\n<b>解释：</b>\n1 秒后，机器人的位置为 [-1,-1,1] 。现在下标为 0 的机器人开始往左移动，下标为 1 的机器人开始往右移动。\n2 秒后，机器人的位置为 [-2,0,0] 。现在下标为 1 的机器人开始往左移动，下标为 2 的机器人开始往右移动。\n3 秒后，机器人的位置为 [-3,-1,1] 。\n下标为 0 和 1 的机器人之间距离为 abs(-3 - (-1)) = 2 。\n下标为 0 和 2 的机器人之间的距离为 abs(-3 - 1) = 4 。\n下标为 1 和 2 的机器人之间的距离为 abs(-1 - 1) = 2 。\n所有机器人对之间的总距离为 2 + 4 + 2 = 8 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,0], s = \"RL\", d = 2\n<b>输出：</b>5\n<b>解释：</b>\n1 秒后，机器人的位置为 [2,-1] 。\n2 秒后，机器人的位置为 [3,-2] 。\n两个机器人的距离为 abs(-2 - 3) = 5 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-2 * 10<sup>9</sup>&nbsp;&lt;= nums[i] &lt;= 2 * 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= d &lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums.length == s.length&nbsp;</code></li>\n\t<li><code>s</code>&nbsp;只包含&nbsp;<code>'L'</code> 和 <code>'R'</code>&nbsp;。</li>\n\t<li><code>nums[i]</code>&nbsp;互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2732找到矩阵中的好子集",
        "hardRate": "HARD",
        "passRate": "56.38%",
        "problemsUrl": "https://leetcode.cn/problems/find-a-good-subset-of-the-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/find-a-good-subset-of-the-matrix/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始大小为&nbsp;<code>m x n</code>&nbsp;的二进制矩阵&nbsp;<code>grid</code>&nbsp;。</p>\n\n<p>从原矩阵中选出若干行构成一个行的 <strong>非空&nbsp;</strong>子集，如果子集中任何一列的和至多为子集大小的一半，那么我们称这个子集是 <strong>好子集</strong>。</p>\n\n<p>更正式的，如果选出来的行子集大小（即行的数量）为 k，那么每一列的和至多为&nbsp;<code>floor(k / 2)</code>&nbsp;。</p>\n\n<p>请你返回一个整数数组，它包含好子集的行下标，请你将子集中的元素&nbsp;<b>升序</b>&nbsp;返回。</p>\n\n<p>如果有多个好子集，你可以返回任意一个。如果没有好子集，请你返回一个空数组。</p>\n\n<p>一个矩阵 <code>grid</code>&nbsp;的行 <strong>子集</strong> ，是删除 <code>grid</code>&nbsp;中某些（也可能不删除）行后，剩余行构成的元素集合。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>grid = [[0,1,1,0],[0,0,0,1],[1,1,1,1]]\n<b>输出：</b>[0,1]\n<b>解释：</b>我们可以选择第 0 和第 1 行构成一个好子集。\n选出来的子集大小为 2 。\n- 第 0&nbsp;列的和为 0 + 0 = 0 ，小于等于子集大小的一半。\n- 第 1&nbsp;列的和为 1 + 0 = 1 ，小于等于子集大小的一半。\n- 第 2&nbsp;列的和为 1 + 0 = 1 ，小于等于子集大小的一半。\n- 第 3&nbsp;列的和为 0 + 1 = 1 ，小于等于子集大小的一半。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>grid = [[0]]\n<b>输出：</b>[0]\n<strong>解释：</strong>我们可以选择第 0 行构成一个好子集。\n选出来的子集大小为 1 。\n- 第 0 列的和为 0 ，小于等于子集大小的一半。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>grid = [[1,1,1],[1,1,1]]\n<b>输出：</b>[]\n<b>解释：</b>没有办法得到一个好子集。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= n &lt;= 5</code></li>\n\t<li><code>grid[i][j]</code>&nbsp;要么是&nbsp;<code>0</code>&nbsp;，要么是&nbsp;<code>1</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2733既不是最小值也不是最大值",
        "hardRate": "EASY",
        "passRate": "80.17%",
        "problemsUrl": "https://leetcode.cn/problems/neither-minimum-nor-maximum/",
        "solutionsUrl": "https://leetcode.cn/problems/neither-minimum-nor-maximum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，数组由 <strong>不同正整数</strong> 组成，请你找出并返回数组中 <strong>任一</strong> 既不是 <strong>最小值</strong> 也不是 <strong>最大值</strong> 的数字，如果不存在这样的数字，返回 <strong><code>-1</code></strong> 。</p>\n\n<p>返回所选整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,2,1,4]\n<strong>输出：</strong>2\n<strong>解释：</strong>在这个示例中，最小值是 1 ，最大值是 4 。因此，2 或 3 都是有效答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2]\n<strong>输出：</strong>-1\n<strong>解释：</strong>由于不存在既不是最大值也不是最小值的数字，我们无法选出满足题目给定条件的数字。因此，不存在答案，返回 -1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,1,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>2 既不是最小值，也不是最大值，这个示例只有这一个有效答案。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>nums</code> 中的所有数字互不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2734执行子串操作后的字典序最小字符串",
        "hardRate": "MEDIUM",
        "passRate": "32.91%",
        "problemsUrl": "https://leetcode.cn/problems/lexicographically-smallest-string-after-substring-operation/",
        "solutionsUrl": "https://leetcode.cn/problems/lexicographically-smallest-string-after-substring-operation/solution",
        "problemsDesc": "<p>给你一个仅由小写英文字母组成的字符串 <code>s</code> 。在一步操作中，你可以完成以下行为：</p>\n\n<ul>\n\t<li>选则 <code>s</code> 的任一非空子字符串，可能是整个字符串，接着将字符串中的每一个字符替换为英文字母表中的前一个字符。例如，'b' 用 'a' 替换，'a' 用 'z' 替换。</li>\n</ul>\n\n<p>返回执行上述操作 <strong>恰好一次</strong> 后可以获得的 <strong>字典序最小</strong> 的字符串。</p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>\n现有长度相同的两个字符串 <code>x</code> 和 字符串 <code>y</code> ，在满足&nbsp;<code>x[i] != y[i]</code> 的第一个位置 <code>i</code> 上，如果&nbsp; <code>x[i]</code> 在字母表中先于 <code>y[i]</code> 出现，则认为字符串 <code>x</code> 比字符串 <code>y</code> <strong>字典序更小</strong> 。\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"cbabc\"\n<strong>输出：</strong>\"baabc\"\n<strong>解释：</strong>我们选择从下标 0 开始、到下标 1 结束的子字符串执行操作。 \n可以证明最终得到的字符串是字典序最小的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"acbbc\"\n<strong>输出：</strong>\"abaab\"\n<strong>解释：</strong>我们选择从下标 1 开始、到下标 4 结束的子字符串执行操作。\n可以证明最终得到的字符串是字典序最小的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = \"leetcode\"\n<strong>输出：</strong>\"kddsbncd\"\n<strong>解释：</strong>我们选择整个字符串执行操作。\n可以证明最终得到的字符串是字典序最小的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2735收集巧克力",
        "hardRate": "MEDIUM",
        "passRate": "43.19%",
        "problemsUrl": "https://leetcode.cn/problems/collecting-chocolates/",
        "solutionsUrl": "https://leetcode.cn/problems/collecting-chocolates/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 、下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，表示收集不同巧克力的成本。每个巧克力都对应一个不同的类型，最初，位于下标 <code>i</code> 的巧克力就对应第 <code>i</code> 个类型。</p>\n\n<p>在一步操作中，你可以用成本 <code>x</code> 执行下述行为：</p>\n\n<ul>\n\t<li>同时修改所有巧克力的类型，将巧克力的类型&nbsp;<code>i<sup>th</sup></code>&nbsp;修改为类型&nbsp;<code>((i + 1) mod n)<sup>th</sup></code>。</li>\n</ul>\n\n<p>假设你可以执行任意次操作，请返回收集所有类型巧克力所需的最小成本。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [20,1,15], x = 5\n<strong>输出：</strong>13\n<strong>解释：</strong>最开始，巧克力的类型分别是 [0,1,2] 。我们可以用成本 1 购买第 1 个类型的巧克力。\n接着，我们用成本 5 执行一次操作，巧克力的类型变更为 [1,2,0] 。我们可以用成本 1 购买第 2 个类型的巧克力。\n然后，我们用成本 5 执行一次操作，巧克力的类型变更为 [2,0,1] 。我们可以用成本 1 购买第 0 个类型的巧克力。\n因此，收集所有类型的巧克力需要的总成本是 (1 + 5 + 1 + 5 + 1) = 13 。可以证明这是一种最优方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3], x = 4\n<strong>输出：</strong>6\n<strong>解释：</strong>我们将会按最初的成本收集全部三个类型的巧克力，而不需执行任何操作。因此，收集所有类型的巧克力需要的总成本是 1 + 2 + 3 = 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= x &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2736最大和查询",
        "hardRate": "HARD",
        "passRate": "38.30%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-queries/solution",
        "problemsDesc": "<p>给你两个长度为 <code>n</code> 、下标从 <strong>0</strong> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，另给你一个下标从 <strong>1</strong> 开始的二维数组 <code>queries</code> ，其中 <code>queries[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 。</p>\n\n<p>对于第 <code>i</code> 个查询，在所有满足 <code>nums1[j] &gt;= x<sub>i</sub></code> 且 <code>nums2[j] &gt;= y<sub>i</sub></code> 的下标 <code>j</code> <code>(0 &lt;= j &lt; n)</code> 中，找出 <code>nums1[j] + nums2[j]</code> 的 <strong>最大值</strong> ，如果不存在满足条件的 <code>j</code> 则返回 <strong>-1</strong> 。</p>\n\n<p>返回数组<em> </em><code>answer</code><em> ，</em>其中<em> </em><code>answer[i]</code><em> </em>是第 <code>i</code> 个查询的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [4,3,1,2], nums2 = [2,4,9,5], queries = [[4,1],[1,3],[2,5]]\n<strong>输出：</strong>[6,10,7]\n<strong>解释：</strong>\n对于第 1 个查询：<code>x<sub>i</sub> = 4</code>&nbsp;且&nbsp;<code>y<sub>i</sub> = 1</code> ，可以选择下标&nbsp;<code>j = 0</code>&nbsp;，此时 <code>nums1[j] &gt;= 4</code>&nbsp;且&nbsp;<code>nums2[j] &gt;= 1</code> 。<code>nums1[j] + nums2[j]</code>&nbsp;等于 6 ，可以证明 6 是可以获得的最大值。\n对于第 2 个查询：<code>x<sub>i</sub> = 1</code>&nbsp;且&nbsp;<code>y<sub>i</sub> = 3</code> ，可以选择下标&nbsp;<code>j = 2</code>&nbsp;，此时 <code>nums1[j] &gt;= 1</code>&nbsp;且&nbsp;<code>nums2[j] &gt;= 3</code> 。<code>nums1[j] + nums2[j]</code>&nbsp;等于 10 ，可以证明 10 是可以获得的最大值。\n对于第 3 个查询：<code>x<sub>i</sub> = 2</code>&nbsp;且&nbsp;<code>y<sub>i</sub> = 5</code> ，可以选择下标&nbsp;<code>j = 3</code>&nbsp;，此时 <code>nums1[j] &gt;= 2</code>&nbsp;且&nbsp;<code>nums2[j] &gt;= 5</code> 。<code>nums1[j] + nums2[j]</code>&nbsp;等于 7 ，可以证明 7 是可以获得的最大值。\n因此，我们返回&nbsp;<code>[6,10,7]</code> 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [3,2,5], nums2 = [2,3,4], queries = [[4,4],[3,2],[1,1]]\n<strong>输出：</strong>[9,9,9]\n<strong>解释：</strong>对于这个示例，我们可以选择下标&nbsp;<code>j = 2</code>&nbsp;，该下标可以满足每个查询的限制。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [2,1], nums2 = [2,3], queries = [[3,3]]\n<strong>输出：</strong>[-1]\n<strong>解释：</strong>示例中的查询 <code>x<sub>i</sub></code> = 3 且 <code>y<sub>i</sub></code> = 3 。对于每个下标 j ，都只满足 nums1[j] &lt; <code>x<sub>i</sub></code> 或者 nums2[j] &lt; <code>y<sub>i</sub></code> 。因此，不存在答案。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums1.length == nums2.length</code>&nbsp;</li>\n\t<li><code>n ==&nbsp;nums1.length&nbsp;</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup>&nbsp;</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length ==&nbsp;2</code></li>\n\t<li><code>x<sub>i</sub>&nbsp;== queries[i][1]</code></li>\n\t<li><code>y<sub>i</sub> == queries[i][2]</code></li>\n\t<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2737找到最近的标记节点",
        "hardRate": "MEDIUM",
        "passRate": "47.32%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-closest-marked-node/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-closest-marked-node/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2738统计文本中单词的出现次数",
        "hardRate": "MEDIUM",
        "passRate": "30.47%",
        "problemsUrl": "https://leetcode.cn/problems/count-occurrences-in-text/",
        "solutionsUrl": "https://leetcode.cn/problems/count-occurrences-in-text/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2739总行驶距离",
        "hardRate": "EASY",
        "passRate": "52.92%",
        "problemsUrl": "https://leetcode.cn/problems/total-distance-traveled/",
        "solutionsUrl": "https://leetcode.cn/problems/total-distance-traveled/solution",
        "problemsDesc": "<p>卡车有两个油箱。给你两个整数，<code>mainTank</code> 表示主油箱中的燃料（以升为单位），<code>additionalTank</code> 表示副油箱中的燃料（以升为单位）。</p>\n\n<p>该卡车每耗费 <code>1</code> 升燃料都可以行驶 <code>10</code> km。每当主油箱使用了 <code>5</code> 升燃料时，如果副油箱至少有 <code>1</code> 升燃料，则会将 <code>1</code> 升燃料从副油箱转移到主油箱。</p>\n\n<p>返回卡车可以行驶的最大距离。</p>\n\n<p>注意：从副油箱向主油箱注入燃料不是连续行为。这一事件会在每消耗 <code>5</code> 升燃料时突然且立即发生。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>mainTank = 5, additionalTank = 10\n<strong>输出：</strong>60\n<strong>解释：</strong>\n在用掉 5 升燃料后，主油箱中燃料还剩下 (5 - 5 + 1) = 1 升，行驶距离为 50km 。\n在用掉剩下的 1 升燃料后，没有新的燃料注入到主油箱中，主油箱变为空。\n总行驶距离为 60km 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>mainTank = 1, additionalTank = 2\n<strong>输出：</strong>10\n<strong>解释：</strong>\n在用掉 1 升燃料后，主油箱变为空。\n总行驶距离为 10km 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= mainTank, additionalTank &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2740找出分区值",
        "hardRate": "MEDIUM",
        "passRate": "74.27%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-value-of-the-partition/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-value-of-the-partition/solution",
        "problemsDesc": "<p>给你一个 <strong>正</strong> 整数数组 <code>nums</code> 。</p>\n\n<p>将 <code>nums</code> 分成两个数组：<code>nums1</code> 和 <code>nums2</code> ，并满足下述条件：</p>\n\n<ul>\n\t<li>数组 <code>nums</code> 中的每个元素都属于数组 <code>nums1</code> 或数组 <code>nums2</code> 。</li>\n\t<li>两个数组都 <strong>非空</strong> 。</li>\n\t<li>分区值 <strong>最小</strong> 。</li>\n</ul>\n\n<p>分区值的计算方法是 <code>|max(nums1) - min(nums2)|</code> 。</p>\n\n<p>其中，<code>max(nums1)</code> 表示数组 <code>nums1</code> 中的最大元素，<code>min(nums2)</code> 表示数组 <code>nums2</code> 中的最小元素。</p>\n\n<p>返回表示分区值的整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3,2,4]\n<strong>输出：</strong>1\n<strong>解释：</strong>可以将数组 nums 分成 nums1 = [1,2] 和 nums2 = [3,4] 。\n- 数组 nums1 的最大值等于 2 。\n- 数组 nums2 的最小值等于 3 。\n分区值等于 |2 - 3| = 1 。\n可以证明 1 是所有分区方案的最小值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [100,1,10]\n<strong>输出：</strong>9\n<strong>解释：</strong>可以将数组 nums 分成 nums1 = [10] 和 nums2 = [100,1] 。 \n- 数组 nums1 的最大值等于 10 。 \n- 数组 nums2 的最小值等于 1 。 \n分区值等于 |10 - 1| = 9 。 \n可以证明 9 是所有分区方案的最小值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2741特别的排列",
        "hardRate": "MEDIUM",
        "passRate": "35.44%",
        "problemsUrl": "https://leetcode.cn/problems/special-permutations/",
        "solutionsUrl": "https://leetcode.cn/problems/special-permutations/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，它包含 <code>n</code>&nbsp;个 <strong>互不相同</strong>&nbsp;的正整数。如果&nbsp;<code>nums</code>&nbsp;的一个排列满足以下条件，我们称它是一个特别的排列：</p>\n\n<ul>\n\t<li>对于&nbsp;<code>0 &lt;= i &lt; n - 1</code>&nbsp;的下标 <code>i</code>&nbsp;，要么&nbsp;<code>nums[i] % nums[i+1] == 0</code>&nbsp;，要么&nbsp;<code>nums[i+1] % nums[i] == 0</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回特别排列的总数目，由于答案可能很大，请将它对<strong>&nbsp;</strong><code>10<sup>9&nbsp;</sup>+ 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,3,6]\n<b>输出：</b>2\n<b>解释：</b>[3,6,2] 和 [2,6,3] 是 nums 两个特别的排列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,4,3]\n<b>输出：</b>2\n<b>解释：</b>[3,1,4] 和 [4,1,3] 是 nums 两个特别的排列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 14</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2742给墙壁刷油漆",
        "hardRate": "HARD",
        "passRate": "34.62%",
        "problemsUrl": "https://leetcode.cn/problems/painting-the-walls/",
        "solutionsUrl": "https://leetcode.cn/problems/painting-the-walls/solution",
        "problemsDesc": "<p>给你两个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>cost</code> 和&nbsp;<code>time</code>&nbsp;，分别表示给&nbsp;<code>n</code>&nbsp;堵不同的墙刷油漆需要的开销和时间。你有两名油漆匠：</p>\n\n<ul>\n\t<li>一位需要 <strong>付费</strong>&nbsp;的油漆匠，刷第&nbsp;<code>i</code>&nbsp;堵墙需要花费&nbsp;<code>time[i]</code>&nbsp;单位的时间，开销为&nbsp;<code>cost[i]</code>&nbsp;单位的钱。</li>\n\t<li>一位 <strong>免费</strong>&nbsp;的油漆匠，刷 <strong>任意</strong>&nbsp;一堵墙的时间为&nbsp;<code>1</code>&nbsp;单位，开销为&nbsp;<code>0</code>&nbsp;。但是必须在付费油漆匠&nbsp;<strong>工作</strong>&nbsp;时，免费油漆匠才会工作。</li>\n</ul>\n\n<p>请你返回刷完 <code>n</code>&nbsp;堵墙最少开销为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>cost = [1,2,3,2], time = [1,2,3,2]\n<b>输出：</b>3\n<strong>解释：</strong>下标为 0 和 1 的墙由付费油漆匠来刷，需要 3 单位时间。同时，免费油漆匠刷下标为 2 和 3 的墙，需要 2 单位时间，开销为 0 。总开销为 1 + 2 = 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>cost = [2,3,4,2], time = [1,1,1,1]\n<b>输出：</b>4\n<b>解释：</b>下标为 0 和 3 的墙由付费油漆匠来刷，需要 2 单位时间。同时，免费油漆匠刷下标为 1 和 2 的墙，需要 2 单位时间，开销为 0 。总开销为 2 + 2 = 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= cost.length &lt;= 500</code></li>\n\t<li><code>cost.length == time.length</code></li>\n\t<li><code>1 &lt;= cost[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= time[i] &lt;= 500</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2743计算没有重复字符的子字符串数量",
        "hardRate": "MEDIUM",
        "passRate": "79.22%",
        "problemsUrl": "https://leetcode.cn/problems/count-substrings-without-repeating-character/",
        "solutionsUrl": "https://leetcode.cn/problems/count-substrings-without-repeating-character/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2744最大字符串配对数目",
        "hardRate": "EASY",
        "passRate": "85.61%",
        "problemsUrl": "https://leetcode.cn/problems/find-maximum-number-of-string-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/find-maximum-number-of-string-pairs/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>words</code>&nbsp;，数组中包含 <strong>互不相同</strong>&nbsp;的字符串。</p>\n\n<p>如果字符串&nbsp;<code>words[i]</code>&nbsp;与字符串 <code>words[j]</code>&nbsp;满足以下条件，我们称它们可以匹配：</p>\n\n<ul>\n\t<li>字符串&nbsp;<code>words[i]</code>&nbsp;等于&nbsp;<code>words[j]</code>&nbsp;的反转字符串。</li>\n\t<li><code>0 &lt;= i &lt; j &lt; words.length</code></li>\n</ul>\n\n<p>请你返回数组 <code>words</code>&nbsp;中的&nbsp;<strong>最大</strong>&nbsp;匹配数目。</p>\n\n<p>注意，每个字符串最多匹配一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"cd\",\"ac\",\"dc\",\"ca\",\"zz\"]\n<b>输出：</b>2\n<strong>解释：</strong>在此示例中，我们可以通过以下方式匹配 2 对字符串：\n- 我们将第 0 个字符串与第 2 个字符串匹配，因为 word[0] 的反转字符串是 \"dc\" 并且等于 words[2]。\n- 我们将第 1 个字符串与第 3 个字符串匹配，因为 word[1] 的反转字符串是 \"ca\" 并且等于 words[3]。\n可以证明最多匹配数目是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"ab\",\"ba\",\"cc\"]\n<b>输出：</b>1\n<b>解释：</b>在此示例中，我们可以通过以下方式匹配 1 对字符串：\n- 我们将第 0 个字符串与第 1 个字符串匹配，因为 words[1] 的反转字符串 \"ab\" 与 words[0] 相等。\n可以证明最多匹配数目是 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"aa\",\"ab\"]\n<b>输出：</b>0\n<strong>解释：</strong>这个例子中，无法匹配任何字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 50</code></li>\n\t<li><code>words[i].length == 2</code></li>\n\t<li><code>words</code>&nbsp;包含的字符串互不相同。</li>\n\t<li><code>words[i]</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2745构造最长的新字符串",
        "hardRate": "MEDIUM",
        "passRate": "56.70%",
        "problemsUrl": "https://leetcode.cn/problems/construct-the-longest-new-string/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-the-longest-new-string/solution",
        "problemsDesc": "<p>给你三个整数&nbsp;<code>x</code>&nbsp;，<code>y</code>&nbsp;和&nbsp;<code>z</code>&nbsp;。</p>\n\n<p>这三个整数表示你有&nbsp;<code>x</code>&nbsp;个&nbsp;<code>\"AA\"</code>&nbsp;字符串，<code>y</code>&nbsp;个&nbsp;<code>\"BB\"</code>&nbsp;字符串，和&nbsp;<code>z</code>&nbsp;个&nbsp;<code>\"AB\"</code>&nbsp;字符串。你需要选择这些字符串中的部分字符串（可以全部选择也可以一个都不选择），将它们按顺序连接得到一个新的字符串。新字符串不能包含子字符串&nbsp;<code>\"AAA\"</code>&nbsp;或者&nbsp;<code>\"BBB\"</code>&nbsp;。</p>\n\n<p>请你返回新字符串的最大可能长度。</p>\n\n<p><strong>子字符串</strong>&nbsp;是一个字符串中一段连续 <strong>非空</strong>&nbsp;的字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>x = 2, y = 5, z = 1\n<b>输出：</b>12\n<strong>解释： </strong>我们可以按顺序连接 \"BB\" ，\"AA\" ，\"BB\" ，\"AA\" ，\"BB\" 和 \"AB\" ，得到新字符串 \"BBAABBAABBAB\" 。\n字符串长度为 12 ，无法得到一个更长的符合题目要求的字符串。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>x = 3, y = 2, z = 2\n<b>输出：</b>14\n<b>解释：</b>我们可以按顺序连接 \"AB\" ，\"AB\" ，\"AA\" ，\"BB\" ，\"AA\" ，\"BB\" 和 \"AA\" ，得到新字符串 \"ABABAABBAABBAA\" 。\n字符串长度为 14 ，无法得到一个更长的符合题目要求的字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= x, y, z &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2746字符串连接删减字母",
        "hardRate": "MEDIUM",
        "passRate": "38.58%",
        "problemsUrl": "https://leetcode.cn/problems/decremental-string-concatenation/",
        "solutionsUrl": "https://leetcode.cn/problems/decremental-string-concatenation/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>words</code>&nbsp;，它包含 <code>n</code>&nbsp;个字符串。</p>\n\n<p>定义 <strong>连接</strong>&nbsp;操作&nbsp;<code>join(x, y)</code>&nbsp;表示将字符串&nbsp;<code>x</code> 和&nbsp;<code>y</code>&nbsp;连在一起，得到&nbsp;<code>xy</code>&nbsp;。如果&nbsp;<code>x</code>&nbsp;的最后一个字符与&nbsp;<code>y</code>&nbsp;的第一个字符相等，连接后两个字符中的一个会被&nbsp;<strong>删除</strong>&nbsp;。</p>\n\n<p>比方说&nbsp;<code>join(\"ab\", \"ba\") = \"aba\"</code>&nbsp;，&nbsp;<code>join(\"ab\", \"cde\") = \"abcde\"</code>&nbsp;。</p>\n\n<p>你需要执行&nbsp;<code>n - 1</code>&nbsp;次&nbsp;<strong>连接</strong>&nbsp;操作。令&nbsp;<code>str<sub>0</sub> = words[0]</code>&nbsp;，从&nbsp;<code>i = 1</code> 直到&nbsp;<code>i = n - 1</code>&nbsp;，对于第&nbsp;<code>i</code>&nbsp;个操作，你可以执行以下操作之一：</p>\n\n<ul>\n\t<li>令&nbsp;<code>str<sub>i</sub> = join(str<sub>i - 1</sub>, words[i])</code></li>\n\t<li>令&nbsp;<code>str<sub>i</sub> = join(words[i], str<sub>i - 1</sub>)</code></li>\n</ul>\n\n<p>你的任务是使&nbsp;<code>str<sub>n - 1</sub></code>&nbsp;的长度<strong>&nbsp;最小&nbsp;</strong>。</p>\n\n<p>请你返回一个整数，表示&nbsp;<code>str<sub>n - 1</sub></code>&nbsp;的最小长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"aa\",\"ab\",\"bc\"]\n<b>输出：</b>4\n<strong>解释：</strong>这个例子中，我们按以下顺序执行连接操作，得到 <code>str<sub>2</sub></code> 的最小长度：\n<code>str<sub>0</sub> = \"aa\"</code>\n<code>str<sub>1</sub> = join(str<sub>0</sub>, \"ab\") = \"aab\"\n</code><code>str<sub>2</sub> = join(str<sub>1</sub>, \"bc\") = \"aabc\"</code> \n<code>str<sub>2</sub></code> 的最小长度为 4 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"ab\",\"b\"]\n<b>输出：</b>2\n<b>解释：</b>这个例子中，str<sub>0</sub> = \"ab\"，可以得到两个不同的 str<sub>1</sub>：\njoin(str<sub>0</sub>, \"b\") = \"ab\" 或者 join(\"b\", str<sub>0</sub>) = \"bab\" 。\n第一个字符串 \"ab\" 的长度最短，所以答案为 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"aaa\",\"c\",\"aba\"]\n<b>输出：</b>6\n<b>解释：</b>这个例子中，我们按以下顺序执行连接操作，得到 <code>str<sub>2</sub>&nbsp;的最小长度：</code>\n<code>str<sub>0</sub> = \"</code>aaa\"\n<code>str<sub>1</sub> = join(str<sub>0</sub>, \"c\") = \"aaac\"</code>\n<code>str<sub>2</sub> = join(\"aba\", str<sub>1</sub>) = \"abaaac\"</code>\n<code>str<sub>2</sub></code> 的最小长度为 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 50</code></li>\n\t<li><code>words[i]</code>&nbsp;中只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2747统计没有收到请求的服务器数目",
        "hardRate": "MEDIUM",
        "passRate": "37.55%",
        "problemsUrl": "https://leetcode.cn/problems/count-zero-request-servers/",
        "solutionsUrl": "https://leetcode.cn/problems/count-zero-request-servers/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;，表示服务器的总数目，再给你一个下标从 <strong>0</strong>&nbsp;开始的 <strong>二维</strong>&nbsp;整数数组&nbsp;<code>logs</code>&nbsp;，其中&nbsp;<code>logs[i] = [server_id, time]</code>&nbsp;表示 id 为&nbsp;<code>server_id</code>&nbsp;的服务器在&nbsp;<code>time</code>&nbsp;时收到了一个请求。</p>\n\n<p>同时给你一个整数&nbsp;<code>x</code>&nbsp;和一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>queries</code>&nbsp; 。</p>\n\n<p>请你返回一个长度等于&nbsp;<code>queries.length</code>&nbsp;的数组&nbsp;<code>arr</code>&nbsp;，其中&nbsp;<code>arr[i]</code>&nbsp;表示在时间区间&nbsp;<code>[queries[i] - x, queries[i]]</code>&nbsp;内没有收到请求的服务器数目。</p>\n\n<p>注意时间区间是个闭区间。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, logs = [[1,3],[2,6],[1,5]], x = 5, queries = [10,11]\n<b>输出：</b>[1,2]\n<b>解释：</b>\n对于 queries[0]：id 为 1 和 2 的服务器在区间 [5, 10] 内收到了请求，所以只有服务器 3 没有收到请求。\n对于 queries[1]：id 为 2 的服务器在区间 [6,11] 内收到了请求，所以 id 为 1 和 3 的服务器在这个时间段内没有收到请求。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, logs = [[2,4],[2,1],[1,2],[3,1]], x = 2, queries = [3,4]\n<b>输出：</b>[0,1]\n<b>解释：</b>\n对于 queries[0]：区间 [1, 3] 内所有服务器都收到了请求。\n对于 queries[1]：只有 id 为 3 的服务器在区间 [2,4] 内没有收到请求。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= logs.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>logs[i].length == 2</code></li>\n\t<li><code>1 &lt;= logs[i][0] &lt;= n</code></li>\n\t<li><code>1 &lt;= logs[i][1] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= x &lt;= 10<sup>5</sup></code></li>\n\t<li><code>x &lt;&nbsp;queries[i]&nbsp;&lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2748美丽下标对的数目",
        "hardRate": "EASY",
        "passRate": "56.44%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-beautiful-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-beautiful-pairs/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。如果下标对 <code>i</code>、<code>j</code> 满足 <code>0 ≤ i &lt; j &lt; nums.length</code> ，如果&nbsp;<code>nums[i]</code> 的 <strong>第一个数字</strong> 和 <code>nums[j]</code> 的 <strong>最后一个数字</strong> <strong>互质</strong> ，则认为 <code>nums[i]</code> 和 <code>nums[j]</code> 是一组 <strong>美丽下标对</strong> 。</p>\n\n<p>返回 <code>nums</code> 中 <strong>美丽下标对</strong> 的总数目。</p>\n\n<p>对于两个整数 <code>x</code> 和 <code>y</code> ，如果不存在大于 1 的整数可以整除它们，则认为 <code>x</code> 和 <code>y</code> <strong>互质</strong> 。换而言之，如果 <code>gcd(x, y) == 1</code> ，则认为 <code>x</code> 和 <code>y</code> 互质，其中 <code>gcd(x, y)</code> 是 <code>x</code> 和 <code>k</code> <strong>最大公因数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,5,1,4]\n<strong>输出：</strong>5\n<strong>解释：</strong>nums 中共有 5 组美丽下标对：\ni = 0 和 j = 1 ：nums[0] 的第一个数字是 2 ，nums[1] 的最后一个数字是 5 。2 和 5 互质，因此 gcd(2,5) == 1 。\ni = 0 和 j = 2 ：nums[0] 的第一个数字是 2 ，nums[1] 的最后一个数字是 1 。2 和 5 互质，因此 gcd(2,1) == 1 。\ni = 1 和 j = 2 ：nums[0] 的第一个数字是 5 ，nums[1] 的最后一个数字是 1 。2 和 5 互质，因此 gcd(5,1) == 1 。\ni = 1 和 j = 3 ：nums[0] 的第一个数字是 5 ，nums[1] 的最后一个数字是 4 。2 和 5 互质，因此 gcd(5,4) == 1 。\ni = 2 和 j = 3 ：nums[0] 的第一个数字是 1 ，nums[1] 的最后一个数字是 4 。2 和 5 互质，因此 gcd(1,4) == 1 。\n因此，返回 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [11,21,12]\n<strong>输出：</strong>2\n<strong>解释：</strong>共有 2 组美丽下标对：\ni = 0 和 j = 1 ：nums[0] 的第一个数字是 1 ，nums[1] 的最后一个数字是 1 。gcd(1,1) == 1 。\ni = 0 和 j = 2 ：nums[0] 的第一个数字是 1 ，nums[1] 的最后一个数字是 2 。gcd(1,2) == 1 。\n因此，返回 2 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 9999</code></li>\n\t<li><code>nums[i] % 10 != 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2749得到整数零需要执行的最少操作数",
        "hardRate": "MEDIUM",
        "passRate": "31.15%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-integer-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-integer-zero/solution",
        "problemsDesc": "<p>给你两个整数：<code>num1</code> 和 <code>num2</code> 。</p>\n\n<p>在一步操作中，你需要从范围&nbsp;<code>[0, 60]</code> 中选出一个整数 <code>i</code> ，并从 <code>num1</code> 减去 <code>2<sup>i</sup> + num2</code> 。</p>\n\n<p>请你计算，要想使 <code>num1</code> 等于 <code>0</code> 需要执行的最少操作数，并以整数形式返回。</p>\n\n<p>如果无法使 <code>num1</code> 等于 <code>0</code> ，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = 3, num2 = -2\n<strong>输出：</strong>3\n<strong>解释：</strong>可以执行下述步骤使 3 等于 0 ：\n- 选择 i = 2 ，并从 3 减去 2<sup>2</sup> + (-2) ，num1 = 3 - (4 + (-2)) = 1 。\n- 选择 i = 2 ，并从 1 减去 2<sup>2</sup> + (-2) ，num1 = 1 - (4 + (-2)) = -1 。\n- 选择 i = 0 ，并从 -1 减去 2<sup>0</sup>&nbsp;+ (-2) ，num1 = (-1) - (1 + (-2)) = 0 。\n可以证明 3 是需要执行的最少操作数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = 5, num2 = 7\n<strong>输出：</strong>-1\n<strong>解释：</strong>可以证明，执行操作无法使 5 等于 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num1 &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= num2 &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2750将数组划分成若干好子数组的方式",
        "hardRate": "MEDIUM",
        "passRate": "38.34%",
        "problemsUrl": "https://leetcode.cn/problems/ways-to-split-array-into-good-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/ways-to-split-array-into-good-subarrays/solution",
        "problemsDesc": "<p>给你一个二元数组 <code>nums</code> 。</p>\n\n<p>如果数组中的某个子数组 <strong>恰好</strong> 只存在 <strong>一</strong> 个值为 <code>1</code> 的元素，则认为该子数组是一个 <strong>好子数组</strong> 。</p>\n\n<p>请你统计将数组 <code>nums</code> 划分成若干 <strong>好子数组</strong> 的方法数，并以整数形式返回。由于数字可能很大，返回其对 <code>10<sup>9</sup> + 7</code> <strong>取余 </strong>之后的结果。</p>\n\n<p>子数组是数组中的一个连续 <strong>非空</strong> 元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,0,0,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>存在 3 种可以将 nums 划分成若干好子数组的方式：\n- [0,1] [0,0,1]\n- [0,1,0] [0,1]\n- [0,1,0,0] [1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,0]\n<strong>输出：</strong>1\n<strong>解释：</strong>存在 1 种可以将 nums 划分成若干好子数组的方式：\n- [0,1,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2751机器人碰撞",
        "hardRate": "HARD",
        "passRate": "48.64%",
        "problemsUrl": "https://leetcode.cn/problems/robot-collisions/",
        "solutionsUrl": "https://leetcode.cn/problems/robot-collisions/solution",
        "problemsDesc": "<p>现有 <code>n</code> 个机器人，编号从 <strong>1</strong> 开始，每个机器人包含在路线上的位置、健康度和移动方向。</p>\n\n<p>给你下标从 <strong>0</strong> 开始的两个整数数组 <code>positions</code>、<code>healths</code> 和一个字符串 <code>directions</code>（<code>directions[i]</code> 为 <strong>'L'</strong> 表示 <strong>向左</strong> 或 <strong>'R'</strong> 表示 <strong>向右</strong>）。 <code>positions</code> 中的所有整数 <strong>互不相同</strong> 。</p>\n\n<p>所有机器人以 <strong>相同速度</strong> <strong>同时</strong> 沿给定方向在路线上移动。如果两个机器人移动到相同位置，则会发生 <strong>碰撞</strong> 。</p>\n\n<p>如果两个机器人发生碰撞，则将 <strong>健康度较低</strong> 的机器人从路线中 <strong>移除</strong> ，并且另一个机器人的健康度 <strong>减少 1</strong> 。幸存下来的机器人将会继续沿着与之前 <strong>相同</strong> 的方向前进。如果两个机器人的健康度相同，则将二者都从路线中移除。</p>\n\n<p>请你确定全部碰撞后幸存下的所有机器人的 <strong>健康度</strong> ，并按照原来机器人编号的顺序排列。即机器人 1 （如果幸存）的最终健康度，机器人 2 （如果幸存）的最终健康度等。 如果不存在幸存的机器人，则返回空数组。</p>\n\n<p>在不再发生任何碰撞后，请你以数组形式，返回所有剩余机器人的健康度（按机器人输入中的编号顺序）。</p>\n\n<p><strong>注意：</strong>位置&nbsp; <code>positions</code> 可能是乱序的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img height=\"169\" src=\"https://assets.leetcode.com/uploads/2023/05/15/image-20230516011718-12.png\" width=\"808\" /></p>\n\n<pre>\n<strong>输入：</strong>positions = [5,4,3,2,1], healths = [2,17,9,15,10], directions = \"RRRRR\"\n<strong>输出：</strong>[2,17,9,15,10]\n<strong>解释：</strong>在本例中不存在碰撞，因为所有机器人向同一方向移动。所以，从第一个机器人开始依序返回健康度，[2, 17, 9, 15, 10] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img height=\"176\" src=\"https://assets.leetcode.com/uploads/2023/05/15/image-20230516004433-7.png\" width=\"717\" /></p>\n\n<pre>\n<strong>输入：</strong>positions = [3,5,2,6], healths = [10,10,15,12], directions = \"RLRL\"\n<strong>输出：</strong>[14]\n<strong>解释：</strong>本例中发生 2 次碰撞。首先，机器人 1 和机器人 2 将会碰撞，因为二者健康度相同，二者都将被从路线中移除。接下来，机器人 3 和机器人 4 将会发生碰撞，由于机器人 4 的健康度更小，则它会被移除，而机器人 3 的健康度变为 15 - 1 = 14 。仅剩机器人 3 ，所以返回 [14] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img height=\"172\" src=\"https://assets.leetcode.com/uploads/2023/05/15/image-20230516005114-9.png\" width=\"732\" /></p>\n\n<pre>\n<strong>输入：</strong>positions = [1,2,5,6], healths = [10,10,11,11], directions = \"RLRL\"\n<strong>输出：</strong>[]\n<strong>解释：</strong>机器人 1 和机器人 2 将会碰撞，因为二者健康度相同，二者都将被从路线中移除。机器人 3 和机器人 4 将会碰撞，因为二者健康度相同，二者都将被从路线中移除。所以返回空数组 [] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= positions.length == healths.length == directions.length == n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= positions[i], healths[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>directions[i] == 'L'</code> 或 <code>directions[i] == 'R'</code></li>\n\t<li><code>positions</code> 中的所有值互不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2752在连续天数上进行了最多交易次数的顾客",
        "hardRate": "HARD",
        "passRate": "56.67%",
        "problemsUrl": "https://leetcode.cn/problems/customers-with-maximum-number-of-transactions-on-consecutive-days/",
        "solutionsUrl": "https://leetcode.cn/problems/customers-with-maximum-number-of-transactions-on-consecutive-days/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2753计算一个环形街道上的房屋数量 II",
        "hardRate": "HARD",
        "passRate": "72.73%",
        "problemsUrl": "https://leetcode.cn/problems/count-houses-in-a-circular-street-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/count-houses-in-a-circular-street-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2754将函数绑定到上下文",
        "hardRate": "MEDIUM",
        "passRate": "90.00%",
        "problemsUrl": "https://leetcode.cn/problems/bind-function-to-context/",
        "solutionsUrl": "https://leetcode.cn/problems/bind-function-to-context/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2755深度合并两个对象",
        "hardRate": "MEDIUM",
        "passRate": "60.00%",
        "problemsUrl": "https://leetcode.cn/problems/deep-merge-of-two-objects/",
        "solutionsUrl": "https://leetcode.cn/problems/deep-merge-of-two-objects/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2756批处理查询",
        "hardRate": "HARD",
        "passRate": "61.54%",
        "problemsUrl": "https://leetcode.cn/problems/query-batching/",
        "solutionsUrl": "https://leetcode.cn/problems/query-batching/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2757生成循环数组的值",
        "hardRate": "MEDIUM",
        "passRate": "69.23%",
        "problemsUrl": "https://leetcode.cn/problems/generate-circular-array-values/",
        "solutionsUrl": "https://leetcode.cn/problems/generate-circular-array-values/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2758下一天",
        "hardRate": "EASY",
        "passRate": "82.61%",
        "problemsUrl": "https://leetcode.cn/problems/next-day/",
        "solutionsUrl": "https://leetcode.cn/problems/next-day/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2759将 JSON 字符串转换为对象",
        "hardRate": "HARD",
        "passRate": "60.00%",
        "problemsUrl": "https://leetcode.cn/problems/convert-json-string-to-object/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-json-string-to-object/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2760最长奇偶子数组",
        "hardRate": "EASY",
        "passRate": "37.19%",
        "problemsUrl": "https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>threshold</code> 。</p>\n\n<p>请你从 <code>nums</code> 的子数组中找出以下标 <code>l</code> 开头、下标 <code>r</code> 结尾 <code>(0 &lt;= l &lt;= r &lt; nums.length)</code> 且满足以下条件的 <strong>最长子数组</strong> ：</p>\n\n<ul>\n\t<li><code>nums[l] % 2 == 0</code></li>\n\t<li>对于范围&nbsp;<code>[l, r - 1]</code> 内的所有下标 <code>i</code> ，<code>nums[i] % 2 != nums[i + 1] % 2</code></li>\n\t<li>对于范围&nbsp;<code>[l, r]</code> 内的所有下标 <code>i</code> ，<code>nums[i] &lt;= threshold</code></li>\n</ul>\n\n<p>以整数形式返回满足题目要求的最长子数组的长度。</p>\n\n<p><strong>注意：子数组</strong> 是数组中的一个连续非空元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,2,5,4], threshold = 5\n<strong>输出：</strong>3\n<strong>解释：</strong>在这个示例中，我们选择从 l = 1 开始、到 r = 3 结束的子数组 =&gt; [2,5,4] ，满足上述条件。\n因此，答案就是这个子数组的长度 3 。可以证明 3 是满足题目要求的最大长度。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2], threshold = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>\n在这个示例中，我们选择从 l = 1 开始、到 r = 1 结束的子数组 =&gt; [2] 。\n该子数组满足上述全部条件。可以证明 1 是满足题目要求的最大长度。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,3,4,5], threshold = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>\n在这个示例中，我们选择从 l = 0 开始、到 r = 2 结束的子数组 =&gt; [2,3,4] 。 \n该子数组满足上述全部条件。\n因此，答案就是这个子数组的长度 3 。可以证明 3 是满足题目要求的最大长度。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100 </code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100 </code></li>\n\t<li><code>1 &lt;= threshold &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2761和等于目标值的质数对",
        "hardRate": "MEDIUM",
        "passRate": "32.87%",
        "problemsUrl": "https://leetcode.cn/problems/prime-pairs-with-target-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/prime-pairs-with-target-sum/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> 。如果两个整数 <code>x</code> 和 <code>y</code> 满足下述条件，则认为二者形成一个质数对：</p>\n\n<ul>\n\t<li><code>1 &lt;= x &lt;= y &lt;= n</code></li>\n\t<li><code>x + y == n</code></li>\n\t<li><code>x</code> 和 <code>y</code> 都是质数</li>\n</ul>\n\n<p>请你以二维有序列表的形式返回符合题目要求的所有 <code>[x<sub>i</sub>, y<sub>i</sub>]</code> ，列表需要按 <code>x<sub>i</sub></code> 的 <strong>非递减顺序</strong> 排序。如果不存在符合要求的质数对，则返回一个空数组。</p>\n\n<p><strong>注意：</strong>质数是大于 <code>1</code> 的自然数，并且只有两个因子，即它本身和 <code>1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 10\n<strong>输出：</strong>[[3,7],[5,5]]\n<strong>解释：</strong>在这个例子中，存在满足条件的两个质数对。 \n这两个质数对分别是 [3,7] 和 [5,5]，按照题面描述中的方式排序后返回。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>[]\n<strong>解释：</strong>可以证明不存在和为 2 的质数对，所以返回一个空数组。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2762不间断子数组",
        "hardRate": "MEDIUM",
        "passRate": "44.28%",
        "problemsUrl": "https://leetcode.cn/problems/continuous-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/continuous-subarrays/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。<code>nums</code>&nbsp;的一个子数组如果满足以下条件，那么它是 <strong>不间断</strong> 的：</p>\n\n<ul>\n\t<li><code>i</code>，<code>i + 1</code>&nbsp;，...，<code>j</code><sub> </sub>&nbsp;表示子数组中的下标。对于所有满足&nbsp;<code>i &lt;= i<sub>1</sub>, i<sub>2</sub> &lt;= j</code>&nbsp;的下标对，都有 <code>0 &lt;= |nums[i<sub>1</sub>] - nums[i<sub>2</sub>]| &lt;= 2</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回 <strong>不间断</strong> 子数组的总数目。</p>\n\n<p>子数组是一个数组中一段连续 <strong>非空</strong>&nbsp;的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5,4,2,4]\n<strong>输出：</strong>8\n<b>解释：</b>\n大小为 1 的不间断子数组：[5], [4], [2], [4] 。\n大小为 2 的不间断子数组：[5,4], [4,2], [2,4] 。\n大小为 3 的不间断子数组：[4,2,4] 。\n没有大小为 4 的不间断子数组。\n不间断子数组的总数目为 4 + 3 + 1 = 8 。\n除了这些以外，没有别的不间断子数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3]\n<b>输出：</b>6\n<b>解释：</b>\n大小为 1 的不间断子数组：[1], [2], [3] 。\n大小为 2 的不间断子数组：[1,2], [2,3] 。\n大小为 3 的不间断子数组：[1,2,3] 。\n不间断子数组的总数目为 3 + 2 + 1 = 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2763所有子数组中不平衡数字之和",
        "hardRate": "HARD",
        "passRate": "61.10%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-imbalance-numbers-of-all-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-imbalance-numbers-of-all-subarrays/solution",
        "problemsDesc": "<p>一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的整数数组 <code>arr</code>&nbsp;的 <strong>不平衡数字</strong>&nbsp;定义为，在&nbsp;<code>sarr = sorted(arr)</code>&nbsp;数组中，满足以下条件的下标数目：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; n - 1</code>&nbsp;，和</li>\n\t<li><code>sarr[i+1] - sarr[i] &gt; 1</code></li>\n</ul>\n\n<p>这里，<code>sorted(arr)</code>&nbsp;表示将数组 <code>arr</code>&nbsp;排序后得到的数组。</p>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，请你返回它所有&nbsp;<strong>子数组</strong>&nbsp;的&nbsp;<strong>不平衡数字</strong>&nbsp;之和。</p>\n\n<p>子数组指的是一个数组中连续一段 <strong>非空</strong>&nbsp;的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,3,1,4]\n<b>输出：</b>3\n<b>解释：</b>总共有 3 个子数组有非 0 不平衡数字：\n- 子数组 [3, 1] ，不平衡数字为 1 。\n- 子数组 [3, 1, 4] ，不平衡数字为 1 。\n- 子数组 [1, 4] ，不平衡数字为 1 。\n其他所有子数组的不平衡数字都是 0 ，所以所有子数组的不平衡数字之和为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,3,3,3,5]\n<b>输出：</b>8\n<b>解释：</b>总共有 7 个子数组有非 0 不平衡数字：\n- 子数组 [1, 3] ，不平衡数字为 1 。\n- 子数组 [1, 3, 3] ，不平衡数字为 1 。\n- 子数组 [1, 3, 3, 3] ，不平衡数字为 1 。\n- 子数组 [1, 3, 3, 3, 5] ，不平衡数字为 2 。\n- 子数组 [3, 3, 3, 5] ，不平衡数字为 1 。\n- 子数组 [3, 3, 5] ，不平衡数字为 1 。\n- 子数组 [3, 5] ，不平衡数字为 1 。\n其他所有子数组的不平衡数字都是 0 ，所以所有子数组的不平衡数字之和为 8 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2764猜数字",
        "hardRate": "EASY",
        "passRate": "84.66%",
        "problemsUrl": "https://leetcode.cn/problems/guess-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/guess-numbers/solution",
        "problemsDesc": "<p>小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？</p>\n\n<p>输入的<code>guess</code>数组为 小A 每次的猜测，<code>answer</code>数组为 小B 每次的选择。<code>guess</code>和<code>answer</code>的长度都等于3。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>guess = [1,2,3], answer = [1,2,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>小A 每次都猜对了。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>guess = [2,2,3], answer = [3,2,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>小A 只猜对了第二次。</pre>\n\n<p> </p>\n\n<p><strong>限制：</strong></p>\n\n<ol>\n\t<li><code>guess</code> 的长度 = 3</li>\n\t<li><code>answer</code> 的长度 = 3</li>\n\t<li><code>guess</code> 的元素取值为 <code>{1, 2, 3}</code> 之一。</li>\n\t<li><code>answer</code> 的元素取值为 <code>{1, 2, 3}</code> 之一。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2765分式化简",
        "hardRate": "EASY",
        "passRate": "70.22%",
        "problemsUrl": "https://leetcode.cn/problems/deep-dark-fraction/",
        "solutionsUrl": "https://leetcode.cn/problems/deep-dark-fraction/solution",
        "problemsDesc": "<p>有一个同学在学习分式。他需要将一个连分数化成最简分数，你能帮助他吗？</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/09/fraction_example_1.jpg\" style=\"height: 195px; width: 480px;\" /></p>\n\n<p>连分数是形如上图的分式。在本题中，所有系数都是大于等于0的整数。</p>\n\n<p> </p>\n\n<p>输入的<code>cont</code>代表连分数的系数（<code>cont[0]</code>代表上图的<code>a<sub>0</sub></code>，以此类推）。返回一个长度为2的数组<code>[n, m]</code>，使得连分数的值等于<code>n / m</code>，且<code>n, m</code>最大公约数为1。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>cont = [3, 2, 0, 2]\n<strong>输出：</strong>[13, 4]\n<strong>解释：</strong>原连分数等价于3 + (1 / (2 + (1 / (0 + 1 / 2))))。注意[26, 8], [-13, -4]都不是正确答案。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>cont = [0, 0, 3]\n<strong>输出：</strong>[3, 1]\n<strong>解释：</strong>如果答案是整数，令分母为1即可。</pre>\n\n<p> </p>\n\n<p><strong>限制：</strong></p>\n\n<ol>\n\t<li><code>cont[i] >= 0</code></li>\n\t<li><code>1 <= cont的长度 <= 10</code></li>\n\t<li><code>cont</code>最后一个元素不等于0</li>\n\t<li>答案的<code>n, m</code>的取值都能被32位int整型存下（即不超过<code>2 ^ 31 - 1</code>）。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2766机器人大冒险",
        "hardRate": "MEDIUM",
        "passRate": "23.22%",
        "problemsUrl": "https://leetcode.cn/problems/programmable-robot/",
        "solutionsUrl": "https://leetcode.cn/problems/programmable-robot/solution",
        "problemsDesc": "<p>力扣团队买了一个可编程机器人，机器人初始位置在原点<code>(0, 0)</code>。小伙伴事先给机器人输入一串指令<code>command</code>，机器人就会<strong>无限循环</strong>这条指令的步骤进行移动。指令有两种：</p>\n\n<ol>\n\t<li><code>U</code>: 向<code>y</code>轴正方向移动一格</li>\n\t<li><code>R</code>: 向<code>x</code>轴正方向移动一格。</li>\n</ol>\n\n<p>不幸的是，在 xy 平面上还有一些障碍物，他们的坐标用<code>obstacles</code>表示。机器人一旦碰到障碍物就会被<strong>损毁</strong>。</p>\n\n<p>给定终点坐标<code>(x, y)</code>，返回机器人能否<strong>完好</strong>地到达终点。如果能，返回<code>true</code>；否则返回<code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>command = &quot;URR&quot;, obstacles = [], x = 3, y = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>U(0, 1) -&gt; R(1, 1) -&gt; R(2, 1) -&gt; U(2, 2) -&gt; R(3, 2)。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>command = &quot;URR&quot;, obstacles = [[2, 2]], x = 3, y = 2\n<strong>输出：</strong>false\n<strong>解释：</strong>机器人在到达终点前会碰到(2, 2)的障碍物。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>command = &quot;URR&quot;, obstacles = [[4, 2]], x = 3, y = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>到达终点后，再碰到障碍物也不影响返回结果。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<ol>\n\t<li><code>2 &lt;= command的长度 &lt;= 1000</code></li>\n\t<li><code>command</code>由<code>U，R</code>构成，且至少有一个<code>U</code>，至少有一个<code>R</code></li>\n\t<li><code>0 &lt;= x &lt;= 1e9, 0 &lt;= y &lt;= 1e9</code></li>\n\t<li><code>0 &lt;= obstacles的长度 &lt;= 1000</code></li>\n\t<li><code>obstacles[i]</code>不为原点或者终点</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2767覆盖",
        "hardRate": "HARD",
        "passRate": "41.15%",
        "problemsUrl": "https://leetcode.cn/problems/broken-board-dominoes/",
        "solutionsUrl": "https://leetcode.cn/problems/broken-board-dominoes/solution",
        "problemsDesc": "<p>你有一块棋盘，棋盘上有一些格子已经坏掉了。你还有无穷块大小为<code>1 * 2</code>的多米诺骨牌，你想把这些骨牌<strong>不重叠</strong>地覆盖在<strong>完好</strong>的格子上，请找出你最多能在棋盘上放多少块骨牌？这些骨牌可以横着或者竖着放。</p>\n\n<p>&nbsp;</p>\n\n<p>输入：<code>n, m</code>代表棋盘的大小；<code>broken</code>是一个<code>b * 2</code>的二维数组，其中每个元素代表棋盘上每一个坏掉的格子的位置。</p>\n\n<p>输出：一个整数，代表最多能在棋盘上放的骨牌数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, m = 3, broken = [[1, 0], [1, 1]]\n<strong>输出：</strong>2\n<strong>解释：</strong>我们最多可以放两块骨牌：[[0, 0], [0, 1]]以及[[0, 2], [1, 2]]。（见下图）</pre>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/09/domino_example_1.jpg\" style=\"height: 204px; width: 304px;\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 3, m = 3, broken = []\n<strong>输出：</strong>4\n<strong>解释：</strong>下图是其中一种可行的摆放方式\n</pre>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/09/domino_example_2.jpg\" style=\"height: 304px; width: 304px;\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= n &lt;= 8</code></li>\n\t<li><code>1 &lt;= m &lt;= 8</code></li>\n\t<li><code>0 &lt;= b &lt;= n * m</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2768发 LeetCoin",
        "hardRate": "HARD",
        "passRate": "22.37%",
        "problemsUrl": "https://leetcode.cn/problems/coin-bonus/",
        "solutionsUrl": "https://leetcode.cn/problems/coin-bonus/solution",
        "problemsDesc": "<p>力扣决定给一个刷题团队发<code>LeetCoin</code>作为奖励。同时，为了监控给大家发了多少<code>LeetCoin</code>，力扣有时候也会进行查询。</p>\n\n<p>&nbsp;</p>\n\n<p>该刷题团队的管理模式可以用一棵树表示：</p>\n\n<ol>\n\t<li>团队只有一个负责人，编号为1。除了该负责人外，每个人有且仅有一个领导（负责人没有领导）；</li>\n\t<li>不存在循环管理的情况，如A管理B，B管理C，C管理A。</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p>力扣想进行的操作有以下三种：</p>\n\n<ol>\n\t<li>给团队的一个成员（也可以是负责人）发一定数量的<code>LeetCoin</code>；</li>\n\t<li>给团队的一个成员（也可以是负责人），以及他/她管理的所有人（即他/她的下属、他/她下属的下属，&hellip;&hellip;），发一定数量的<code>LeetCoin</code>；</li>\n\t<li>查询某一个成员（也可以是负责人），以及他/她管理的所有人被发到的<code>LeetCoin</code>之和。</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>输入：</strong></p>\n\n<ol>\n\t<li><code>N</code>表示团队成员的个数（编号为1～N，负责人为1）；</li>\n\t<li><code>leadership</code>是大小为<code>(N&nbsp;- 1) * 2</code>的二维数组，其中每个元素<code>[a, b]</code>代表<code>b</code>是<code>a</code>的下属；</li>\n\t<li><code>operations</code>是一个长度为<code>Q</code>的二维数组，代表以时间排序的操作，格式如下：\n\t<ol>\n\t\t<li><code>operations[i][0] = 1</code>: 代表第一种操作，<code>operations[i][1]</code>代表成员的编号，<code>operations[i][2]</code>代表<code>LeetCoin</code>的数量；</li>\n\t\t<li><code>operations[i][0] = 2</code>: 代表第二种操作，<code>operations[i][1]</code>代表成员的编号，<code>operations[i][2]</code>代表<code>LeetCoin</code>的数量；</li>\n\t\t<li><code>operations[i][0] = 3</code>: 代表第三种操作，<code>operations[i][1]</code>代表成员的编号；</li>\n\t</ol>\n\t</li>\n</ol>\n\n<p><strong>输出：</strong></p>\n\n<p>返回一个数组，数组里是每次<strong>查询</strong>的返回值（发<code>LeetCoin</code>的操作不需要任何返回值）。由于发的<code>LeetCoin</code>很多，请把每次查询的结果模<code>1e9+7 (1000000007)</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>N = 6, leadership = [[1, 2], [1, 6], [2, 3], [2, 5], [1, 4]], operations = [[1, 1, 500], [2, 2, 50], [3, 1], [2, 6, 15], [3, 1]]\n<strong>输出：</strong>[650, 665]\n<strong>解释：</strong>团队的管理关系见下图。\n第一次查询时，每个成员得到的LeetCoin的数量分别为（按编号顺序）：500, 50, 50, 0, 50, 0;\n第二次查询时，每个成员得到的LeetCoin的数量分别为（按编号顺序）：500, 50, 50, 0, 50, 15.\n</pre>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/09/coin_example_1.jpg\" style=\"height: 344px; width: 300px;\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= N &lt;= 50000</code></li>\n\t<li><code>1 &lt;= Q &lt;= 50000</code></li>\n\t<li><code>operations[i][0] != 3 时，1 &lt;= operations[i][2]&nbsp;&lt;= 5000</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2769拿硬币",
        "hardRate": "EASY",
        "passRate": "83.87%",
        "problemsUrl": "https://leetcode.cn/problems/na-ying-bi/",
        "solutionsUrl": "https://leetcode.cn/problems/na-ying-bi/solution",
        "problemsDesc": "<p>桌上有 <code>n</code> 堆力扣币，每堆的数量保存在数组 <code>coins</code> 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<blockquote>\n<p>输入：<code>[4,2,1]</code></p>\n\n<p>输出：<code>4</code></p>\n\n<p>解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。</p>\n</blockquote>\n\n<p><strong>示例 2：</strong></p>\n\n<blockquote>\n<p>输入：<code>[2,3,10]</code></p>\n\n<p>输出：<code>8</code></p>\n</blockquote>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 4</code></li>\n\t<li><code>1 &lt;= coins[i] &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2770传递信息",
        "hardRate": "EASY",
        "passRate": "75.52%",
        "problemsUrl": "https://leetcode.cn/problems/chuan-di-xin-xi/",
        "solutionsUrl": "https://leetcode.cn/problems/chuan-di-xin-xi/solution",
        "problemsDesc": "<p>小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：</p>\n\n<ol>\n\t<li>有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0</li>\n\t<li>每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。</li>\n\t<li>每轮信息必须需要传递给另一个人，且信息可重复经过同一个人</li>\n</ol>\n\n<p>给定总玩家数 <code>n</code>，以及按 <code>[玩家编号,对应可传递玩家编号]</code> 关系组成的二维数组 <code>relation</code>。返回信息从小 A (编号 0 ) 经过 <code>k</code> 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<blockquote>\n<p>输入：<code>n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3</code></p>\n\n<p>输出：<code>3</code></p>\n\n<p>解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4。</p>\n</blockquote>\n\n<p><strong>示例 2：</strong></p>\n\n<blockquote>\n<p>输入：<code>n = 3, relation = [[0,2],[2,1]], k = 2</code></p>\n\n<p>输出：<code>0</code></p>\n\n<p>解释：信息不能从小 A 处经过 2 轮传递到编号 2</p>\n</blockquote>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10</code></li>\n\t<li><code>1 &lt;= k &lt;= 5</code></li>\n\t<li><code>1 &lt;= relation.length &lt;= 90, 且 relation[i].length == 2</code></li>\n\t<li><code>0 &lt;= relation[i][0],relation[i][1] &lt; n 且 relation[i][0] != relation[i][1]</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2771剧情触发时间",
        "hardRate": "MEDIUM",
        "passRate": "32.89%",
        "problemsUrl": "https://leetcode.cn/problems/ju-qing-hong-fa-shi-jian/",
        "solutionsUrl": "https://leetcode.cn/problems/ju-qing-hong-fa-shi-jian/solution",
        "problemsDesc": "<p>在战略游戏中，玩家往往需要发展自己的势力来触发各种新的剧情。一个势力的主要属性有三种，分别是文明等级（<code>C</code>），资源储备（<code>R</code>）以及人口数量（<code>H</code>）。在游戏开始时（第 0 天），三种属性的值均为 0。</p>\n\n<p>随着游戏进程的进行，每一天玩家的三种属性都会对应<strong>增加</strong>，我们用一个二维数组 <code>increase</code> 来表示每天的增加情况。这个二维数组的每个元素是一个长度为 3 的一维数组，例如 <code>[[1,2,1],[3,4,2]]</code> 表示第一天三种属性分别增加 <code>1,2,1</code> 而第二天分别增加 <code>3,4,2</code>。</p>\n\n<p>所有剧情的触发条件也用一个二维数组 <code>requirements</code> 表示。这个二维数组的每个元素是一个长度为 3 的一维数组，对于某个剧情的触发条件 <code>c[i], r[i], h[i]</code>，如果当前 <code>C &gt;= c[i]</code> 且 <code>R &gt;= r[i]</code> 且 <code>H &gt;= h[i]</code> ，则剧情会被触发。</p>\n\n<p>根据所给信息，请计算每个剧情的触发时间，并以一个数组返回。如果某个剧情不会被触发，则该剧情对应的触发时间为 -1 。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<blockquote>\n<p>输入： <code>increase = [[2,8,4],[2,5,0],[10,9,8]]</code> <code>requirements = [[2,11,3],[15,10,7],[9,17,12],[8,1,14]]</code></p>\n\n<p>输出: <code>[2,-1,3,-1]</code></p>\n\n<p>解释：</p>\n\n<p>初始时，C = 0，R = 0，H = 0</p>\n\n<p>第 1 天，C = 2，R = 8，H = 4</p>\n\n<p>第 2 天，C = 4，R = 13，H = 4，此时触发剧情 0</p>\n\n<p>第 3 天，C = 14，R = 22，H = 12，此时触发剧情 2</p>\n\n<p>剧情 1 和 3 无法触发。</p>\n</blockquote>\n\n<p><strong>示例 2：</strong></p>\n\n<blockquote>\n<p>输入： <code>increase = [[0,4,5],[4,8,8],[8,6,1],[10,10,0]]</code> <code>requirements = [[12,11,16],[20,2,6],[9,2,6],[10,18,3],[8,14,9]]</code></p>\n\n<p>输出: <code>[-1,4,3,3,3]</code></p>\n</blockquote>\n\n<p><strong>示例 3：</strong></p>\n\n<blockquote>\n<p>输入： <code>increase = [[1,1,1]]</code> <code>requirements = [[0,0,0]]</code></p>\n\n<p>输出: <code>[0]</code></p>\n</blockquote>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= increase.length &lt;= 10000</code></li>\n\t<li><code>1 &lt;= requirements.length &lt;= 100000</code></li>\n\t<li><code>0 &lt;= increase[i] &lt;= 10</code></li>\n\t<li><code>0 &lt;= requirements[i] &lt;= 100000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2772最小跳跃次数",
        "hardRate": "HARD",
        "passRate": "31.87%",
        "problemsUrl": "https://leetcode.cn/problems/zui-xiao-tiao-yue-ci-shu/",
        "solutionsUrl": "https://leetcode.cn/problems/zui-xiao-tiao-yue-ci-shu/solution",
        "problemsDesc": "<p>为了给刷题的同学一些奖励，力扣团队引入了一个弹簧游戏机。游戏机由 <code>N</code> 个特殊弹簧排成一排，编号为 <code>0</code> 到 <code>N-1</code>。初始有一个小球在编号 <code>0</code> 的弹簧处。若小球在编号为 <code>i</code> 的弹簧处，通过按动弹簧，可以选择把小球向右弹射&nbsp;<code>jump[i]</code> 的距离，或者向左弹射到任意左侧弹簧的位置。也就是说，在编号为 <code>i</code> 弹簧处按动弹簧，小球可以弹向 <code>0</code> 到 <code>i-1</code> 中任意弹簧或者 <code>i+jump[i]</code> 的弹簧（若 <code>i+jump[i]&gt;=N</code> ，则表示小球弹出了机器）。小球位于编号 0 处的弹簧时不能再向左弹。</p>\n\n<p>为了获得奖励，你需要将小球弹出机器。请求出最少需要按动多少次弹簧，可以将小球从编号 <code>0</code> 弹簧弹出整个机器，即向右越过编号 <code>N-1</code> 的弹簧。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<blockquote>\n<p>输入：<code>jump = [2, 5, 1, 1, 1, 1]</code></p>\n\n<p>输出：<code>3</code></p>\n\n<p>解释：小 Z 最少需要按动 3 次弹簧，小球依次到达的顺序为 0 -&gt; 2 -&gt; 1 -&gt; 6，最终小球弹出了机器。</p>\n</blockquote>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= jump.length &lt;= 10^6</code></li>\n\t<li><code>1 &lt;= jump[i] &lt;= 10000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2773二叉树任务调度",
        "hardRate": "HARD",
        "passRate": "61.62%",
        "problemsUrl": "https://leetcode.cn/problems/er-cha-shu-ren-wu-diao-du/",
        "solutionsUrl": "https://leetcode.cn/problems/er-cha-shu-ren-wu-diao-du/solution",
        "problemsDesc": "<p>任务调度优化是计算机性能优化的关键任务之一。在任务众多时，不同的调度策略可能会得到不同的总体执行时间，因此寻求一个最优的调度方案是非常有必要的。</p>\n\n<p>通常任务之间是存在依赖关系的，即对于某个任务，你需要先<strong>完成</strong>他的前导任务（如果非空），才能开始执行该任务。<strong>我们保证任务的依赖关系是一棵二叉树，</strong>其中 <code>root</code> 为根任务，<code>root.left</code> 和 <code>root.right</code> 为他的两个前导任务（可能为空），<code>root.val</code> 为其自身的执行时间。</p>\n\n<p>在一个 CPU 核执行某个任务时，我们可以在任何时刻暂停当前任务的执行，并保留当前执行进度。在下次继续执行该任务时，会从之前停留的进度开始继续执行。暂停的时间可以不是整数。</p>\n\n<p>现在，系统有<strong>两个</strong> CPU 核，即我们可以同时执行两个任务，但是同一个任务不能同时在两个核上执行。给定这颗任务树，请求出所有任务执行完毕的最小时间。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<blockquote>\n<p><img alt=\"image.png\" src=\"https://pic.leetcode-cn.com/3522fbf8ce4ebb20b79019124eb9870109fdfe97fe9da99f6c20c07ceb1c60b3-image.png\" /></p>\n\n<p>输入：root = [47, 74, 31]</p>\n\n<p>输出：121</p>\n\n<p>解释：根节点的左右节点可以并行执行31分钟，剩下的43+47分钟只能串行执行，因此总体执行时间是121分钟。</p>\n</blockquote>\n\n<p><strong>示例 2：</strong></p>\n\n<blockquote>\n<p><img alt=\"image.png\" src=\"https://pic.leetcode-cn.com/13accf172ee4a660d241e25901595d55b759380b090890a17e6e7bd51a143e3f-image.png\" /></p>\n\n<p>输入：root = [15, 21, null, 24, null, 27, 26]</p>\n\n<p>输出：87</p>\n</blockquote>\n\n<p><strong>示例 3：</strong></p>\n\n<blockquote>\n<p><img alt=\"image.png\" src=\"https://pic.leetcode-cn.com/bef743a12591aafb9047dd95d335b8083dfa66e8fdedc63f50fd406b4a9d163a-image.png\" /></p>\n\n<p>输入：root = [1,3,2,null,null,4,4]</p>\n\n<p>输出：7.5</p>\n</blockquote>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= 节点数量 &lt;= 1000</code></li>\n\t<li><code>1 &lt;= 单节点执行时间 &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2774期望个数统计",
        "hardRate": "EASY",
        "passRate": "72.58%",
        "problemsUrl": "https://leetcode.cn/problems/qi-wang-ge-shu-tong-ji/",
        "solutionsUrl": "https://leetcode.cn/problems/qi-wang-ge-shu-tong-ji/solution",
        "problemsDesc": "<p>某互联网公司一年一度的春招开始了，一共有 <code>n</code> 名面试者入选。每名面试者都会提交一份简历，公司会根据提供的简历资料产生一个预估的能力值，数值越大代表越有可能通过面试。</p>\n\n<p>小 A 和小 B 负责审核面试者，他们均有所有面试者的简历，并且将各自根据面试者能力值从大到小的顺序浏览。由于简历事先被打乱过，能力值相同的简历的出现顺序是从它们的全排列中<strong>等可能</strong>地取一个。现在给定 <code>n</code> 名面试者的能力值 <code>scores</code>，设 <code>X</code> 代表小 A 和小 B 的浏览顺序中出现在同一位置的简历数，求 <code>X</code> 的期望。</p>\n\n<p>提示：离散的非负随机变量的期望计算公式为 <img alt=\"1\" src=\"http://latex.codecogs.com/svg.latex?E%28X%29%3D%5Csum_%7Bk%3D1%7D%5E%7B%5Cinfty%7D%20k%20%5CPr%28X%20%3D%20k%29\" />。在本题中，由于 <code>X</code> 的取值为 0 到 <code>n</code> 之间，期望计算公式可以是 <img alt=\"2\" src=\"http://latex.codecogs.com/svg.latex?E%28X%29%3D%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%20k%20%5CPr%28X%20%3D%20k%29\" />。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<blockquote>\n<p>输入：<code>scores = [1,2,3]</code></p>\n\n<p>输出：<code>3</code></p>\n\n<p>解释：由于面试者能力值互不相同，小 A 和小 B 的浏览顺序一定是相同的。<code>X</code>的期望是 3 。</p>\n</blockquote>\n\n<p><strong>示例 2：</strong></p>\n\n<blockquote>\n<p>输入：<code>scores = [1,1]</code></p>\n\n<p>输出：<code>1</code></p>\n\n<p>解释：设两位面试者的编号为 0, 1。由于他们的能力值都是 1，小 A 和小 B 的浏览顺序都为从全排列 <code>[[0,1],[1,0]]</code> 中等可能地取一个。如果小 A 和小 B 的浏览顺序都是 <code>[0,1]</code> 或者 <code>[1,0]</code> ，那么出现在同一位置的简历数为 2 ，否则是 0 。所以 <code>X</code> 的期望是 (2+0+2+0) * 1/4 = 1</p>\n</blockquote>\n\n<p><strong>示例 3：</strong></p>\n\n<blockquote>\n<p>输入：<code>scores = [1,1,2]</code></p>\n\n<p>输出：<code>2</code></p>\n</blockquote>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= scores.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= scores[i] &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2775小张刷题计划",
        "hardRate": "MEDIUM",
        "passRate": "43.86%",
        "problemsUrl": "https://leetcode.cn/problems/xiao-zhang-shua-ti-ji-hua/",
        "solutionsUrl": "https://leetcode.cn/problems/xiao-zhang-shua-ti-ji-hua/solution",
        "problemsDesc": "<p>为了提高自己的代码能力，小张制定了 <code>LeetCode</code> 刷题计划，他选中了 <code>LeetCode</code> 题库中的 <code>n</code> 道题，编号从 <code>0</code> 到 <code>n-1</code>，并计划在 <code>m</code> 天内<strong>按照题目编号顺序</strong>刷完所有的题目（注意，小张不能用多天完成同一题）。</p>\n\n<p>在小张刷题计划中，小张需要用 <code>time[i]</code> 的时间完成编号 <code>i</code> 的题目。此外，小张还可以使用场外求助功能，通过询问他的好朋友小杨题目的解法，可以省去该题的做题时间。为了防止&ldquo;小张刷题计划&rdquo;变成&ldquo;小杨刷题计划&rdquo;，小张每天最多使用一次求助。</p>\n\n<p>我们定义 <code>m</code> 天中做题时间最多的一天耗时为 <code>T</code>（小杨完成的题目不计入做题总时间）。请你帮小张求出最小的 <code>T</code>是多少。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<blockquote>\n<p>输入：<code>time = [1,2,3,3], m = 2</code></p>\n\n<p>输出：<code>3</code></p>\n\n<p>解释：第一天小张完成前三题，其中第三题找小杨帮忙；第二天完成第四题，并且找小杨帮忙。这样做题时间最多的一天花费了 3 的时间，并且这个值是最小的。</p>\n</blockquote>\n\n<p><strong>示例 2：</strong></p>\n\n<blockquote>\n<p>输入：<code>time = [999,999,999], m = 4</code></p>\n\n<p>输出：<code>0</code></p>\n\n<p>解释：在前三天中，小张每天求助小杨一次，这样他可以在三天内完成所有的题目并不花任何时间。</p>\n</blockquote>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= time.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= time[i] &lt;= 10000</code></li>\n\t<li><code>1 &lt;= m &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2776寻宝",
        "hardRate": "HARD",
        "passRate": "59.62%",
        "problemsUrl": "https://leetcode.cn/problems/xun-bao/",
        "solutionsUrl": "https://leetcode.cn/problems/xun-bao/solution",
        "problemsDesc": "<p>我们得到了一副藏宝图，藏宝图显示，在一个迷宫中存在着未被世人发现的宝藏。</p>\n\n<p>迷宫是一个二维矩阵，用一个字符串数组表示。它标识了唯一的入口（用 &#39;S&#39; 表示），和唯一的宝藏地点（用 &#39;T&#39; 表示）。但是，宝藏被一些隐蔽的机关保护了起来。在地图上有若干个机关点（用 &#39;M&#39; 表示），<strong>只有所有机关均被触发，才可以拿到宝藏。</strong></p>\n\n<p>要保持机关的触发，需要把一个重石放在上面。迷宫中有若干个石堆（用 &#39;O&#39; 表示），每个石堆都有<strong>无限</strong>个足够触发机关的重石。但是由于石头太重，我们一次只能搬<strong>一个</strong>石头到指定地点。</p>\n\n<p>迷宫中同样有一些墙壁（用 &#39;#&#39; 表示），我们不能走入墙壁。剩余的都是可随意通行的点（用 &#39;.&#39; 表示）。石堆、机关、起点和终点（无论是否能拿到宝藏）也是可以通行的。</p>\n\n<p>我们每步可以选择向上/向下/向左/向右移动一格，并且不能移出迷宫。搬起石头和放下石头不算步数。那么，从起点开始，我们最少需要多少步才能最后拿到宝藏呢？如果无法拿到宝藏，返回 -1 。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<blockquote>\n<p>输入： [&quot;S#O&quot;, &quot;M..&quot;, &quot;M.T&quot;]</p>\n\n<p>输出：16</p>\n\n<p>解释：最优路线为： S-&gt;O, cost = 4, 去搬石头 O-&gt;第二行的M, cost = 3, M机关触发 第二行的M-&gt;O, cost = 3, 我们需要继续回去 O 搬石头。 O-&gt;第三行的M, cost = 4, 此时所有机关均触发 第三行的M-&gt;T, cost = 2，去T点拿宝藏。 总步数为16。 <img alt=\"图片.gif\" src=\"https://pic.leetcode-cn.com/6bfff669ad65d494cdc237bcedfec10a2b1ac2f2593c2bf97e9aecb41dc8a08b-%E5%9B%BE%E7%89%87.gif\" /></p>\n</blockquote>\n\n<p><strong>示例 2：</strong></p>\n\n<blockquote>\n<p>输入： [&quot;S#O&quot;, &quot;M.#&quot;, &quot;M.T&quot;]</p>\n\n<p>输出：-1</p>\n\n<p>解释：我们无法搬到石头触发机关</p>\n</blockquote>\n\n<p><strong>示例 3：</strong></p>\n\n<blockquote>\n<p>输入： [&quot;S#O&quot;, &quot;M.T&quot;, &quot;M..&quot;]</p>\n\n<p>输出：17</p>\n\n<p>解释：注意终点也是可以通行的。</p>\n</blockquote>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= maze.length&nbsp;&lt;= 100</code></li>\n\t<li><code>1 &lt;= maze[i].length&nbsp;&lt;= 100</code></li>\n\t<li><code>maze[i].length == maze[j].length</code></li>\n\t<li>S 和 T 有且只有一个</li>\n\t<li>0 &lt;= M的数量 &lt;= 16</li>\n\t<li>0 &lt;= O的数量 &lt;= 40，题目保证当迷宫中存在 M 时，一定存在至少一个 O 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2777切分数组",
        "hardRate": "HARD",
        "passRate": "24.10%",
        "problemsUrl": "https://leetcode.cn/problems/qie-fen-shu-zu/",
        "solutionsUrl": "https://leetcode.cn/problems/qie-fen-shu-zu/solution",
        "problemsDesc": "<p>给定一个整数数组 <code>nums</code> ，小李想将 <code>nums</code> 切割成若干个非空子数组，使得每个子数组最左边的数和最右边的数的最大公约数大于 1 。为了减少他的工作量，请求出最少可以切成多少个子数组。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<blockquote>\n<p>输入：<code>nums = [2,3,3,2,3,3]</code></p>\n\n<p>输出：<code>2</code></p>\n\n<p>解释：最优切割为 [2,3,3,2] 和 [3,3] 。第一个子数组头尾数字的最大公约数为 2 ，第二个子数组头尾数字的最大公约数为 3 。</p>\n</blockquote>\n\n<p><strong>示例 2：</strong></p>\n\n<blockquote>\n<p>输入：<code>nums = [2,3,5,7]</code></p>\n\n<p>输出：<code>4</code></p>\n\n<p>解释：只有一种可行的切割：[2], [3], [5], [7]</p>\n</blockquote>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>2 &lt;= nums[i] &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2778游乐园的迷宫",
        "hardRate": "HARD",
        "passRate": "62.72%",
        "problemsUrl": "https://leetcode.cn/problems/you-le-yuan-de-mi-gong/",
        "solutionsUrl": "https://leetcode.cn/problems/you-le-yuan-de-mi-gong/solution",
        "problemsDesc": "<p>小王来到了游乐园，她玩的第一个项目是模拟推销员。有一个二维平面地图，其中散布着 <code>N</code> 个推销点，编号 <code>0</code> 到 <code>N-1</code>，不存在三点共线的情况。每两点之间有一条直线相连。游戏没有规定起点和终点，但限定了每次转角的方向。首先，小王需要先选择两个点分别作为起点和终点，然后从起点开始访问剩余 <code>N-2</code> 个点恰好一次并回到终点。访问的顺序需要满足一串给定的长度为 <code>N-2</code> 由 <code>L</code> 和 <code>R</code> 组成的字符串 <code>direction</code>，表示从起点出发之后在每个顶点上转角的方向。根据这个提示，小王希望你能够帮她找到一个可行的遍历顺序，输出顺序下标（若有多个方案，输出任意一种）。可以证明这样的遍历顺序一定是存在的。</p>\n\n<p><img alt=\"Screenshot 2020-03-20 at 17.04.58.png\" src=\"https://pic.leetcode-cn.com/595b60797d4a461287864a8cd05bba1d3b8760104ff83f43b902fd68477be9c3-Screenshot%202020-03-20%20at%2017.04.58.png\" style=\"max-height:500px\" /></p>\n\n<p>（上图：A-&gt;B-&gt;C 右转； 下图：D-&gt;E-&gt;F 左转）</p>\n\n<p><strong>示例 1：</strong></p>\n\n<blockquote>\n<p>输入：<code>points = [[1,1],[1,4],[3,2],[2,1]], direction = \"LL\"</code></p>\n\n<p>输入：<code>[0,2,1,3]</code></p>\n\n<p>解释：[0,2,1,3] 是符合\"LL\"的方案之一。在 [0,2,1,3] 方案中，0-&gt;2-&gt;1 是左转方向， 2-&gt;1-&gt;3 也是左转方向 <img alt=\"图片.gif\" src=\"https://pic.leetcode-cn.com/c01c1efc423b916267c2a3a170266c925c368d62afa047c267cc1020970e55d9-%E5%9B%BE%E7%89%87.gif\" style=\"max-height:300px\" /></p>\n</blockquote>\n\n<p><strong>示例 2：</strong></p>\n\n<blockquote>\n<p>输入：<code>points = [[1,3],[2,4],[3,3],[2,1]], direction = \"LR\"</code></p>\n\n<p>输入：<code>[0,3,1,2]</code></p>\n\n<p>解释：[0,3,1,2] 是符合\"LR\"的方案之一。在 [0,3,1,2] 方案中，0-&gt;3-&gt;1 是左转方向， 3-&gt;1-&gt;2 是右转方向</p>\n</blockquote>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= points.length &lt;= 1000 且 points[i].length == 2</code></li>\n\t<li><code>1 &lt;= points[i][0],points[i][1] &lt;= 10000</code></li>\n\t<li><code>direction.length == points.length - 2</code></li>\n\t<li><code>direction 只包含 \"L\",\"R\"</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2779游乐园的游览计划",
        "hardRate": "HARD",
        "passRate": "34.85%",
        "problemsUrl": "https://leetcode.cn/problems/you-le-yuan-de-you-lan-ji-hua/",
        "solutionsUrl": "https://leetcode.cn/problems/you-le-yuan-de-you-lan-ji-hua/solution",
        "problemsDesc": "<p>又到了一年一度的春游时间，小吴计划去游乐场游玩 1 天，游乐场总共有 <code>N</code> 个游乐项目，编号从 <code>0</code> 到 <code>N-1</code>。小吴给每个游乐项目定义了一个非负整数值 <code>value[i]</code> 表示自己的喜爱值。两个游乐项目之间会有双向路径相连，整个游乐场总共有 <code>M</code> 条双向路径，保存在二维数组&nbsp;<code>edges</code>中。 小吴计划选择一个游乐项目 <code>A</code> 作为这一天游玩的重点项目。上午小吴准备游玩重点项目 <code>A</code> 以及与项目 <code>A</code> 相邻的两个项目 <code>B</code>、<code>C</code> （项目<code>A</code>、<code>B</code>与<code>C</code>要求是不同的项目，且项目<code>B</code>与项目<code>C</code>要求相邻），并返回 <code>A</code> ，即存在一条 <code>A-B-C-A</code> 的路径。 下午，小吴决定再游玩重点项目 <code>A</code>以及与<code>A</code>相邻的两个项目 <code>B&#39;</code>、<code>C&#39;</code>，（项目<code>A</code>、<code>B&#39;</code>与<code>C&#39;</code>要求是不同的项目，且项目<code>B&#39;</code>与项目<code>C&#39;</code>要求相邻），并返回 <code>A</code> ，即存在一条 <code>A-B&#39;-C&#39;-A</code> 的路径。下午游玩项目 <code>B&#39;</code>、<code>C&#39;</code> 可与上午游玩项目<code>B</code>、<code>C</code>存在重复项目。 小吴希望提前安排好游玩路径，使得喜爱值之和最大。请你返回满足游玩路径选取条件的最大喜爱值之和，如果没有这样的路径，返回 <code>0</code>。 注意：一天中重复游玩同一个项目并不能重复增加喜爱值了。例如：上下午游玩路径分别是 <code>A-B-C-A</code>与<code>A-C-D-A</code> 那么只能获得 <code>value[A] + value[B] + value[C] + value[D]</code> 的总和。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<blockquote>\n<p>输入：<code>edges = [[0,1],[1,2],[0,2]], value = [1,2,3]</code></p>\n\n<p>输出：<code>6</code></p>\n\n<p>解释：喜爱值之和最高的方案之一是 0-&gt;1-&gt;2-&gt;0 与 0-&gt;2-&gt;1-&gt;0 。重复游玩同一点不重复计入喜爱值，返回1+2+3=6</p>\n</blockquote>\n\n<p><strong>示例 2：</strong></p>\n\n<blockquote>\n<p>输入：<code>edges = [[0,2],[2,1]], value = [1,2,5]</code></p>\n\n<p>输出：<code>0</code></p>\n\n<p>解释：无满足要求的游玩路径，返回 0</p>\n</blockquote>\n\n<p><strong>示例 3：</strong></p>\n\n<blockquote>\n<p>输入：<code>edges = [[0,1],[0,2],[0,3],[0,4],[0,5],[1,3],[2,4],[2,5],[3,4],[3,5],[4,5]], value = [7,8,6,8,9,7]</code></p>\n\n<p>输出：<code>39</code></p>\n\n<p>解释：喜爱值之和最高的方案之一是 3-&gt;0-&gt;1-&gt;3 与 3-&gt;4-&gt;5-&gt;3 。喜爱值最高为 7+8+8+9+7=39</p>\n</blockquote>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= value.length &lt;= 10000</code></li>\n\t<li><code>1 &lt;=&nbsp;edges.length &lt;= 10000</code></li>\n\t<li><code>0 &lt;= edges[i][0],edges[i][1] &lt;&nbsp;value.length</code></li>\n\t<li><code>0 &lt;= value[i] &lt;= 10000</code></li>\n\t<li><code>edges中没有重复的边</code></li>\n\t<li><code>edges[i][0] != edges[i][1]</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2780速算机器人",
        "hardRate": "EASY",
        "passRate": "80.21%",
        "problemsUrl": "https://leetcode.cn/problems/nGK0Fy/",
        "solutionsUrl": "https://leetcode.cn/problems/nGK0Fy/solution",
        "problemsDesc": "小扣在秋日市集发现了一款速算机器人。店家对机器人说出两个数字（记作 `x` 和 `y`），请小扣说出计算指令：\r\n- `\"A\"` 运算：使 `x = 2 * x + y`；\r\n- `\"B\"` 运算：使 `y = 2 * y + x`。\r\n\r\n在本次游戏中，店家说出的数字为 `x = 1` 和 `y = 0`，小扣说出的计算指令记作仅由大写字母 `A`、`B` 组成的字符串 `s`，字符串中字符的顺序表示计算顺序，请返回最终 `x` 与 `y` 的和为多少。\r\n\r\n**示例 1：**\r\n>输入：`s = \"AB\"`\r\n> \r\n>输出：`4`\r\n> \r\n>解释：\r\n>经过一次 A 运算后，x = 2, y = 0。\r\n>再经过一次 B 运算，x = 2, y = 2。\r\n>最终 x 与 y 之和为 4。\r\n\r\n**提示：**\r\n- `0 <= s.length <= 10`\r\n- `s` 由 `'A'` 和 `'B'` 组成\r\n\r\n\r\n",
        "isPlus": false
    },
    {
        "problemsName": " 2781早餐组合",
        "hardRate": "EASY",
        "passRate": "30.25%",
        "problemsUrl": "https://leetcode.cn/problems/2vYnGI/",
        "solutionsUrl": "https://leetcode.cn/problems/2vYnGI/solution",
        "problemsDesc": "小扣在秋日市集选择了一家早餐摊位，一维整型数组 `staple` 中记录了每种主食的价格，一维整型数组 `drinks` 中记录了每种饮料的价格。小扣的计划选择一份主食和一款饮料，且花费不超过 `x` 元。请返回小扣共有多少种购买方案。\r\n\r\n注意：答案需要以 `1e9 + 7 (1000000007)` 为底取模，如：计算初始结果为：`1000000008`，请返回 `1`\r\n\r\n**示例 1：**\r\n>输入：`staple = [10,20,5], drinks = [5,5,2], x = 15`\r\n>\r\n>输出：`6`\r\n>\r\n>解释：小扣有 6 种购买方案，所选主食与所选饮料在数组中对应的下标分别是：\r\n>第 1 种方案：staple[0] + drinks[0] = 10 + 5 = 15；\r\n>第 2 种方案：staple[0] + drinks[1] = 10 + 5 = 15；\r\n>第 3 种方案：staple[0] + drinks[2] = 10 + 2 = 12；\r\n>第 4 种方案：staple[2] + drinks[0] = 5 + 5 = 10；\r\n>第 5 种方案：staple[2] + drinks[1] = 5 + 5 = 10；\r\n>第 6 种方案：staple[2] + drinks[2] = 5 + 2 = 7。\r\n\r\n**示例 2：**\r\n>输入：`staple = [2,1,1], drinks = [8,9,5,1], x = 9`\r\n>\r\n>输出：`8`\r\n>\r\n>解释：小扣有 8 种购买方案，所选主食与所选饮料在数组中对应的下标分别是：\r\n>第 1 种方案：staple[0] + drinks[2] = 2 + 5 = 7；\r\n>第 2 种方案：staple[0] + drinks[3] = 2 + 1 = 3；\r\n>第 3 种方案：staple[1] + drinks[0] = 1 + 8 = 9；\r\n>第 4 种方案：staple[1] + drinks[2] = 1 + 5 = 6；\r\n>第 5 种方案：staple[1] + drinks[3] = 1 + 1 = 2；\r\n>第 6 种方案：staple[2] + drinks[0] = 1 + 8 = 9；\r\n>第 7 种方案：staple[2] + drinks[2] = 1 + 5 = 6；\r\n>第 8 种方案：staple[2] + drinks[3] = 1 + 1 = 2；\r\n\r\n**提示：**\r\n+ `1 <= staple.length <= 10^5`\r\n+ `1 <= drinks.length <= 10^5`\r\n+ `1 <= staple[i],drinks[i] <= 10^5`\r\n+ `1 <= x <= 2*10^5`",
        "isPlus": false
    },
    {
        "problemsName": " 2782秋叶收藏集",
        "hardRate": "MEDIUM",
        "passRate": "51.83%",
        "problemsUrl": "https://leetcode.cn/problems/UlBDOe/",
        "solutionsUrl": "https://leetcode.cn/problems/UlBDOe/solution",
        "problemsDesc": "小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 `leaves`， 字符串 `leaves` 仅包含小写字符 `r` 和 `y`， 其中字符 `r` 表示一片红叶，字符 `y` 表示一片黄叶。\r\n出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。\r\n\r\n**示例 1：**\r\n>输入：`leaves = \"rrryyyrryyyrr\"`\r\n>\r\n>输出：`2`\r\n>\r\n>解释：调整两次，将中间的两片红叶替换成黄叶，得到 \"rrryyyyyyyyrr\"\r\n\r\n**示例 2：**\r\n>输入：`leaves = \"ryr\"`\r\n>\r\n>输出：`0`\r\n>\r\n>解释：已符合要求，不需要额外操作\r\n\r\n**提示：**\r\n- `3 <= leaves.length <= 10^5`\r\n- `leaves` 中只包含字符 `'r'` 和字符 `'y'`",
        "isPlus": false
    },
    {
        "problemsName": " 2783快速公交",
        "hardRate": "HARD",
        "passRate": "35.96%",
        "problemsUrl": "https://leetcode.cn/problems/meChtZ/",
        "solutionsUrl": "https://leetcode.cn/problems/meChtZ/solution",
        "problemsDesc": "小扣打算去秋日市集，由于游客较多，小扣的移动速度受到了人流影响：\r\n- 小扣从 `x` 号站点移动至 `x + 1` 号站点需要花费的时间为 `inc`；\r\n- 小扣从 `x` 号站点移动至 `x - 1` 号站点需要花费的时间为 `dec`。\r\n\r\n现有 `m` 辆公交车，编号为 `0` 到 `m-1`。小扣也可以通过搭乘编号为 `i` 的公交车，从 `x` 号站点移动至 `jump[i]*x` 号站点，耗时仅为 `cost[i]`。小扣可以搭乘任意编号的公交车且搭乘公交次数不限。\r\n\r\n假定小扣起始站点记作 `0`，秋日市集站点记作 `target`，请返回小扣抵达秋日市集最少需要花费多少时间。由于数字较大，最终答案需要对 1000000007 (1e9 + 7) 取模。\r\n\r\n注意：小扣可在移动过程中到达编号大于 `target` 的站点。\r\n\r\n**示例 1：**\r\n>输入：`target = 31, inc =  5, dec = 3, jump = [6], cost = [10]`\r\n>\r\n>输出：`33`\r\n>\r\n>解释：\r\n>小扣步行至 1 号站点，花费时间为 5；\r\n>小扣从 1 号站台搭乘 0 号公交至 6 * 1 = 6 站台，花费时间为 10；\r\n>小扣从 6 号站台步行至 5 号站台，花费时间为 3；\r\n>小扣从 5 号站台搭乘 0 号公交至 6 * 5 = 30 站台，花费时间为 10；\r\n>小扣从 30 号站台步行至 31 号站台，花费时间为 5；\r\n>最终小扣花费总时间为 33。\r\n\r\n\r\n**示例 2：**\r\n>输入：`target = 612, inc =  4, dec = 5, jump = [3,6,8,11,5,10,4], cost = [4,7,6,3,7,6,4]`\r\n>\r\n>输出：`26`\r\n>\r\n>解释：\r\n>小扣步行至 1 号站点，花费时间为 4；\r\n>小扣从 1 号站台搭乘 0 号公交至 3 * 1 = 3 站台，花费时间为 4；\r\n>小扣从 3 号站台搭乘 3 号公交至 11 * 3 = 33 站台，花费时间为 3；\r\n>小扣从 33 号站台步行至 34 站台，花费时间为 4；\r\n>小扣从 34 号站台搭乘 0 号公交至 3 * 34 = 102 站台，花费时间为 4；\r\n>小扣从 102 号站台搭乘 1 号公交至 6 * 102 = 612 站台，花费时间为 7； \r\n>最终小扣花费总时间为 26。\r\n\r\n\r\n**提示：**\r\n- `1 <= target <= 10^9`\r\n- `1 <= jump.length, cost.length <= 10`\r\n- `2 <= jump[i] <= 10^6`\r\n- `1 <= inc, dec, cost[i] <= 10^6`",
        "isPlus": false
    },
    {
        "problemsName": " 2784追逐游戏",
        "hardRate": "HARD",
        "passRate": "38.50%",
        "problemsUrl": "https://leetcode.cn/problems/Za25hA/",
        "solutionsUrl": "https://leetcode.cn/problems/Za25hA/solution",
        "problemsDesc": "秋游中的小力和小扣设计了一个追逐游戏。他们选了秋日市集景区中的 N 个景点，景点编号为 1~N。此外，他们还选择了 N 条小路，满足任意两个景点之间都可以通过小路互相到达，且不存在两条连接景点相同的小路。整个游戏场景可视作一个无向连通图，记作二维数组 `edges`，数组中以 `[a,b]` 形式表示景点 a 与景点 b 之间有一条小路连通。\r\n\r\n小力和小扣只能沿景点间的小路移动。小力的目标是在最快时间内追到小扣，小扣的目标是尽可能延后被小力追到的时间。游戏开始前，两人分别站在两个不同的景点 `startA` 和 `startB`。每一回合，小力先行动，小扣观察到小力的行动后再行动。小力和小扣在每回合可选择以下行动之一：\r\n- 移动至相邻景点\r\n- 留在原地\r\n\r\n如果小力追到小扣（即两人于某一时刻出现在同一位置），则游戏结束。若小力可以追到小扣，请返回最少需要多少回合；若小力无法追到小扣，请返回 -1。\r\n\r\n注意：小力和小扣一定会采取最优移动策略。\r\n\r\n**示例 1：**\r\n>输入：`edges = [[1,2],[2,3],[3,4],[4,1],[2,5],[5,6]], startA = 3, startB = 5`\r\n>\r\n>输出：`3`\r\n>\r\n>解释：\r\n>![image.png](https://pic.leetcode-cn.com/1597991318-goeHHr-image.png){:height=\"250px\"}\r\n>\r\n>第一回合，小力移动至 2 号点，小扣观察到小力的行动后移动至 6 号点；\r\n>第二回合，小力移动至 5 号点，小扣无法移动，留在原地；\r\n>第三回合，小力移动至 6 号点，小力追到小扣。返回 3。\r\n\r\n\r\n**示例 2：**\r\n>输入：`edges = [[1,2],[2,3],[3,4],[4,1]], startA = 1, startB = 3`\r\n>\r\n>输出：`-1`\r\n>\r\n>解释：\r\n>![image.png](https://pic.leetcode-cn.com/1597991157-QfeakF-image.png){:height=\"250px\"}\r\n>\r\n>小力如果不动，则小扣也不动；否则小扣移动到小力的对角线位置。这样小力无法追到小扣。\r\n\r\n**提示：**\r\n- `edges` 的长度等于图中节点个数\r\n- `3 <= edges.length <= 10^5`\r\n- `1 <= edges[i][0], edges[i][1] <= edges.length 且 edges[i][0] != edges[i][1]`\r\n- `1 <= startA, startB <= edges.length 且 startA != startB`\r\n\r\n",
        "isPlus": false
    },
    {
        "problemsName": " 2785黑白方格画",
        "hardRate": "EASY",
        "passRate": "34.97%",
        "problemsUrl": "https://leetcode.cn/problems/ccw6C7/",
        "solutionsUrl": "https://leetcode.cn/problems/ccw6C7/solution",
        "problemsDesc": "小扣注意到秋日市集上有一个创作黑白方格画的摊位。摊主给每个顾客提供一个固定在墙上的白色画板，画板不能转动。画板上有 `n * n` 的网格。绘画规则为，小扣可以选择任意多行以及任意多列的格子涂成黑色（选择的整行、整列均需涂成黑色），所选行数、列数均可为 0。\n\n小扣希望最终的成品上需要有 `k` 个黑色格子，请返回小扣共有多少种涂色方案。\n\n注意：两个方案中任意一个相同位置的格子颜色不同，就视为不同的方案。\n\n**示例 1：**\n>输入：`n = 2, k = 2`\n>\n>输出：`4`\n> \n>解释：一共有四种不同的方案：\n>第一种方案：涂第一列；\n>第二种方案：涂第二列；\n>第三种方案：涂第一行；\n>第四种方案：涂第二行。\n\n**示例 2：**\n>输入：`n = 2, k = 1`\n> \n>输出：`0`\n> \n>解释：不可行，因为第一次涂色至少会涂两个黑格。\n\n**示例 3：**\n>输入：`n = 2, k = 4`\n> \n>输出：`1`\n>\n>解释：共有 2*2=4 个格子，仅有一种涂色方案。\n\n**限制：**\n- `1 <= n <= 6`\n- `0 <= k <= n * n`\n\n\n",
        "isPlus": false
    },
    {
        "problemsName": " 2786魔术排列",
        "hardRate": "MEDIUM",
        "passRate": "37.11%",
        "problemsUrl": "https://leetcode.cn/problems/er94lq/",
        "solutionsUrl": "https://leetcode.cn/problems/er94lq/solution",
        "problemsDesc": "秋日市集上，魔术师邀请小扣与他互动。魔术师的道具为分别写有数字 `1~N` 的 `N` 张卡牌，然后请小扣思考一个 `N` 张卡牌的排列 `target`。\n\n魔术师的目标是找到一个数字 k（k >= 1），使得初始排列顺序为 `1~N` 的卡牌经过特殊的洗牌方式最终变成小扣所想的排列 `target`，特殊的洗牌方式为：\n- 第一步，魔术师将当前位于 **偶数位置** 的卡牌（下标自 1 开始），保持 **当前排列顺序** 放在位于 **奇数位置** 的卡牌之前。例如：将当前排列 [1,2,3,4,5] 位于偶数位置的 [2,4] 置于奇数位置的 [1,3,5] 前，排列变为 [2,4,1,3,5]；\n- 第二步，若当前卡牌数量小于等于 `k`，则魔术师按排列顺序取走全部卡牌；若当前卡牌数量大于 `k`，则取走前 `k` 张卡牌，剩余卡牌继续重复这两个步骤，直至所有卡牌全部被取走；\n\n卡牌按照魔术师取走顺序构成的新排列为「魔术取数排列」，请返回是否存在这个数字 k 使得「魔术取数排列」恰好就是 `target`，从而让小扣感到大吃一惊。\n\n**示例 1：**\n>输入：`target = [2,4,3,1,5]`\n>\n>输出：`true`\n>\n>解释：排列 target 长度为 5，初始排列为：1,2,3,4,5。我们选择 k = 2：\n>第一次：将当前排列 [1,2,3,4,5] 位于偶数位置的 [2,4] 置于奇数位置的 [1,3,5] 前，排列变为 [2,4,1,3,5]。取走前 2 张卡牌 2,4，剩余 [1,3,5]；\n>第二次：将当前排列 [1,3,5] 位于偶数位置的 [3] 置于奇数位置的 [1,5] 前，排列变为 [3,1,5]。取走前 2 张 3,1，剩余 [5]；\n>第三次：当前排列为 [5]，全部取出。\n>最后，数字按照取出顺序构成的「魔术取数排列」2,4,3,1,5 恰好为 target。\n\n**示例 2：**\n>输入：`target = [5,4,3,2,1]`\n>\n>输出：`false`\n>\n>解释：无法找到一个数字 k 可以使「魔术取数排列」恰好为 target。\n\n\n**提示：**\n- `1 <= target.length = N <= 5000`\n- 题目保证 `target` 是 `1~N` 的一个排列。",
        "isPlus": false
    },
    {
        "problemsName": " 2787数字游戏",
        "hardRate": "HARD",
        "passRate": "32.47%",
        "problemsUrl": "https://leetcode.cn/problems/5TxKeK/",
        "solutionsUrl": "https://leetcode.cn/problems/5TxKeK/solution",
        "problemsDesc": "小扣在秋日市集入口处发现了一个数字游戏。主办方共有 `N` 个计数器，计数器编号为 `0 ~ N-1`。每个计数器上分别显示了一个数字，小扣按计数器编号升序将所显示的数字记于数组 `nums`。每个计数器上有两个按钮，分别可以实现将显示数字加一或减一。小扣每一次操作可以选择一个计数器，按下加一或减一按钮。\n\n主办方请小扣回答出一个长度为 `N` 的数组，第 `i` 个元素(0 <= i < N)表示将 `0~i` 号计数器 **初始** 所示数字操作成满足所有条件 `nums[a]+1 == nums[a+1],(0 <= a < i)` 的最小操作数。回答正确方可进入秋日市集。\n\n由于答案可能很大，请将每个最小操作数对 `1,000,000,007` 取余。\n\n\n**示例 1：**\n>输入：`nums = [3,4,5,1,6,7]`\n>\n>输出：`[0,0,0,5,6,7]`\n>\n>解释：\n>i = 0，[3] 无需操作\n>i = 1，[3,4] 无需操作；\n>i = 2，[3,4,5] 无需操作；\n>i = 3，将 [3,4,5,1] 操作成 [3,4,5,6], 最少 5 次操作；\n>i = 4，将 [3,4,5,1,6] 操作成 [3,4,5,6,7], 最少 6 次操作；\n>i = 5，将 [3,4,5,1,6,7] 操作成 [3,4,5,6,7,8]，最少 7 次操作；\n>返回 [0,0,0,5,6,7]。\n\n\n**示例 2：**\n>输入：`nums = [1,2,3,4,5]`\n>\n>输出：`[0,0,0,0,0]`\n>\n>解释：对于任意计数器编号 i 都无需操作。\n\n**示例 3：**\n>输入：`nums = [1,1,1,2,3,4]`\n>\n>输出：`[0,1,2,3,3,3]`\n>\n>解释：\n>i = 0，无需操作；\n>i = 1，将 [1,1] 操作成 [1,2] 或 [0,1] 最少 1 次操作；\n>i = 2，将 [1,1,1] 操作成 [1,2,3] 或 [0,1,2]，最少 2 次操作；\n>i = 3，将 [1,1,1,2] 操作成 [1,2,3,4] 或 [0,1,2,3]，最少 3 次操作；\n>i = 4，将 [1,1,1,2,3] 操作成 [-1,0,1,2,3]，最少 3 次操作；\n>i = 5，将 [1,1,1,2,3,4] 操作成 [-1,0,1,2,3,4]，最少 3 次操作；\n>返回 [0,1,2,3,3,3]。\n\n\n**提示：**\n- `1 <= nums.length <= 10^5`\n- `1 <= nums[i] <= 10^3`\n\n",
        "isPlus": false
    },
    {
        "problemsName": " 2788古董键盘",
        "hardRate": "HARD",
        "passRate": "37.55%",
        "problemsUrl": "https://leetcode.cn/problems/Uh984O/",
        "solutionsUrl": "https://leetcode.cn/problems/Uh984O/solution",
        "problemsDesc": "小扣在秋日市集购买了一个古董键盘。由于古董键盘年久失修，键盘上只有 26 个字母 **a~z** 可以按下，且每个字母最多仅能被按 `k` 次。\n\n小扣随机按了 `n` 次按键，请返回小扣总共有可能按出多少种内容。由于数字较大，最终答案需要对 1000000007 (1e9 + 7) 取模。\n\n\n**示例 1：**\n>输入：`k = 1, n = 1`\n> \n>输出：`26`\n> \n>解释：由于只能按一次按键，所有可能的字符串为 \"a\", \"b\", ... \"z\" \n\n**示例 2：**\n>输入：`k = 1, n = 2`\n> \n>输出：`650`\n> \n>解释：由于只能按两次按键，且每个键最多只能按一次，所有可能的字符串（按字典序排序）为 \"ab\", \"ac\", ... \"zy\" \n\n**提示：**\n- `1 <= k <= 5`\n- `1 <= n <= 26*k`\n \n\n",
        "isPlus": false
    },
    {
        "problemsName": " 2789导航装置",
        "hardRate": "HARD",
        "passRate": "37.61%",
        "problemsUrl": "https://leetcode.cn/problems/hSRGyL/",
        "solutionsUrl": "https://leetcode.cn/problems/hSRGyL/solution",
        "problemsDesc": "小扣参加的秋日市集景区共有 $N$ 个景点，景点编号为 $1$~$N$。景点内设有 $N-1$ 条双向道路，使所有景点形成了一个二叉树结构，根结点记为 `root`，景点编号即为节点值。\r\n\r\n由于秋日市集景区的结构特殊，游客很容易迷路，主办方决定在景区的若干个景点设置导航装置，按照所在景点编号升序排列后定义装置编号为 1 ~ M。导航装置向游客发送数据，数据内容为列表 `[游客与装置 1 的相对距离,游客与装置 2 的相对距离,...,游客与装置 M 的相对距离]`。由于游客根据导航装置发送的信息来确认位置，因此主办方需保证游客在每个景点接收的数据信息皆不相同。请返回主办方最少需要设置多少个导航装置。\r\n\r\n**示例 1：**\r\n>输入：`root = [1,2,null,3,4]`\r\n>\r\n>输出：`2`\r\n>\r\n>解释：在景点 1、3 或景点 1、4 或景点 3、4 设置导航装置。\r\n>\r\n>![image.png](https://pic.leetcode-cn.com/1597996812-tqrgwu-image.png){:height=\"250px\"}\r\n\r\n\r\n\r\n**示例 2：**\r\n>输入：`root = [1,2,3,4]`\r\n>\r\n>输出：`1`\r\n>\r\n>解释：在景点 3、4 设置导航装置皆可。\r\n>\r\n>![image.png](https://pic.leetcode-cn.com/1597996826-EUQRyz-image.png){:height=\"200px\"}\r\n\r\n\r\n\r\n**提示：**\r\n- `2 <= N <= 50000`\r\n- 二叉树的非空节点值为 `1~N` 的一个排列。\r\n",
        "isPlus": false
    },
    {
        "problemsName": " 2790黑盒光线反射",
        "hardRate": "HARD",
        "passRate": "34.24%",
        "problemsUrl": "https://leetcode.cn/problems/IQvJ9i/",
        "solutionsUrl": "https://leetcode.cn/problems/IQvJ9i/solution",
        "problemsDesc": "秋日市集上有个奇怪的黑盒，黑盒的主视图为 n\\*m 的矩形。从黑盒的主视图来看，黑盒的上面和下面各均匀分布有 m 个小孔，黑盒的左面和右面各均匀分布有 n 个小孔。黑盒左上角小孔序号为 0，按顺时针编号，总共有 2*(m+n) 个小孔。每个小孔均可以打开或者关闭，初始时，所有小孔均处于关闭状态。每个小孔上的盖子均为镜面材质。例如一个 2\\*3 的黑盒主视图与其小孔分布如图所示:\n\n![image.png](https://pic.leetcode-cn.com/1598951281-ZCBrif-image.png){:height=\"200px\"}\n\n店长告诉小扣，这里是「几何学的快问快答」，店长可能有两种操作：\n\n- `open(int index, int direction)` - 若小孔处于关闭状态，则打开小孔，照入光线；否则直接照入光线；\n- `close(int index)` - 关闭处于打开状态小孔，店长保证不会关闭已处于关闭状态的小孔；\n\n其中：\n- `index`： 表示小孔序号\n- `direction`：`1` 表示光线沿 $y=x$ 方向，`-1` 表示光线沿 $y=-x$ 方向。\n\n![image.png](https://pic.leetcode-cn.com/1599620810-HdOlMi-image.png){:height=\"200px\"}\n\n\n当光线照至边界时：若边界上的小孔为开启状态，则光线会射出；否则，光线会在小孔之间进行反射。特别地：\n1. 若光线射向未打开的拐角（黑盒顶点），则光线会原路反射回去；\n2. 光线自拐角处的小孔照入时，只有一种入射方向（如自序号为 0 的小孔照入方向只能为 `-1`）\n\n![image.png](https://pic.leetcode-cn.com/1598953840-DLiAsf-image.png){:height=\"200px\"}\n\n请帮助小扣判断并返回店长每次照入的光线从几号小孔射出。\n\n\n**示例 1：**\n>输入：\n>`[\"BlackBox\",\"open\",\"open\",\"open\",\"close\",\"open\"]`\n>`[[2,3],[6,-1],[4,-1],[0,-1],[6],[0,-1]]`\n>\n>输出：`[null,6,4,6,null,4]`\n>\n>解释：\n>BlackBox b = BlackBox(2,3); // 新建一个 2x3 的黑盒\n>b.open(6,-1) // 打开 6 号小孔，并沿 y=-x 方向照入光线，光线至 0 号小孔反射，从 6 号小孔射出\n>b.open(4,-1) // 打开 4 号小孔，并沿 y=-x 方向照入光线，光线轨迹为 4-2-8-2-4，从 4 号小孔射出\n>b.open(0,-1) // 打开 0 号小孔，并沿 y=-x 方向照入光线，由于 6 号小孔为开启状态，光线从 6 号小孔射出\n>b.close(6) // 关闭 6 号小孔\n>b.shoot(0,-1) // 从 0 号小孔沿 y=-x 方向照入光线，由于 6 号小孔为关闭状态，4 号小孔为开启状态，光线轨迹为 0-6-4，从 4 号小孔射出\n\n**示例 2：**\n>输入：\n>`[\"BlackBox\",\"open\",\"open\",\"open\",\"open\",\"close\",\"open\",\"close\",\"open\"]`\n>`[[3,3],[1,-1],[5,1],[11,-1],[11,1],[1],[11,1],[5],[11,-1]]`\n>\n>输出：`[null,1,1,5,1,null,5,null,11]`\n>\n>解释：\n>\n>![image.png](https://pic.leetcode-cn.com/1599204202-yGDMVk-image.png){:height=\"300px\"}\n>\n>BlackBox b = BlackBox(3,3); // 新建一个 3x3 的黑盒\n>b.open(1,-1) // 打开 1 号小孔，并沿 y=-x 方向照入光线，光线轨迹为 1-5-7-11-1，从 1 号小孔射出\n>b.open(5,1) // 打开 5 号小孔，并沿 y=x 方向照入光线，光线轨迹为 5-7-11-1，从 1 号小孔射出\n>b.open(11,-1) // 打开 11 号小孔，并沿逆 y=-x 方向照入光线，光线轨迹为 11-7-5，从 5 号小孔射出\n>b.open(11,1) // 从 11 号小孔沿 y=x 方向照入光线，光线轨迹为 11-1，从 1 号小孔射出\n>b.close(1) // 关闭 1 号小孔\n>b.open(11,1) // 从 11 号小孔沿 y=x 方向照入光线，光线轨迹为 11-1-5，从 5 号小孔射出\n>b.close(5) // 关闭 5 号小孔\n>b.open(11,-1) // 从 11 号小孔沿 y=-x 方向照入光线，光线轨迹为 11-1-5-7-11，从 11 号小孔射出\n\n\n\n**提示：**\n- `1 <= n, m <= 10000`\n- `1 <= 操作次数 <= 10000`\n- `direction` 仅为 `1` 或 `-1`\n- `0 <= index < 2*(m+n)`\n",
        "isPlus": false
    },
    {
        "problemsName": " 2791采购方案",
        "hardRate": "EASY",
        "passRate": "31.84%",
        "problemsUrl": "https://leetcode.cn/problems/4xy4Wx/",
        "solutionsUrl": "https://leetcode.cn/problems/4xy4Wx/solution",
        "problemsDesc": "小力将 N 个零件的报价存于数组 `nums`。小力预算为 `target`，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。\n\n注意：答案需要以 `1e9 + 7 (1000000007)` 为底取模，如：计算初始结果为：`1000000008`，请返回 `1`\n\n\n**示例 1：**\n>输入：`nums = [2,5,3,5], target = 6`\n>\n>输出：`1`\n>\n>解释：预算内仅能购买 nums[0] 与 nums[2]。\n\n**示例 2：**\n>输入：`nums = [2,2,1,9], target = 10`\n>\n>输出：`4`\n>\n>解释：符合预算的采购方案如下：\n>nums[0] + nums[1] = 4\n>nums[0] + nums[2] = 3\n>nums[1] + nums[2] = 3\n>nums[2] + nums[3] = 10\n\n**提示：**\n- `2 <= nums.length <= 10^5`\n- `1 <= nums[i], target <= 10^5`\n",
        "isPlus": false
    },
    {
        "problemsName": " 2792乐团站位",
        "hardRate": "MEDIUM",
        "passRate": "21.17%",
        "problemsUrl": "https://leetcode.cn/problems/SNJvJP/",
        "solutionsUrl": "https://leetcode.cn/problems/SNJvJP/solution",
        "problemsDesc": "某乐团的演出场地可视作 `num * num` 的二维矩阵 `grid`（左上角坐标为 `[0,0]`)，每个位置站有一位成员。乐团共有 `9` 种乐器，乐器编号为 `1~9`，每位成员持有 `1` 个乐器。\n\n为保证声乐混合效果，成员站位规则为：自 `grid` 左上角开始顺时针螺旋形向内循环以 `1，2，...，9` 循环重复排列。例如当 num = `5` 时，站位如图所示\n\n![image.png](https://pic.leetcode-cn.com/1616125411-WOblWH-image.png)\n\n\n请返回位于场地坐标 [`Xpos`,`Ypos`] 的成员所持乐器编号。\n\n**示例 1：**\n>输入：`num = 3, Xpos = 0, Ypos = 2`\n>\n>输出：`3`\n>\n>解释：\n![image.png](https://pic.leetcode-cn.com/1616125437-WUOwsu-image.png)\n\n\n**示例 2：**\n>输入：`num = 4, Xpos = 1, Ypos = 2`\n>\n>输出：`5`\n>\n>解释：\n![image.png](https://pic.leetcode-cn.com/1616125453-IIDpxg-image.png)\n\n\n**提示：**\n- `1 <= num <= 10^9`\n- `0 <= Xpos, Ypos < num`",
        "isPlus": false
    },
    {
        "problemsName": " 2793魔塔游戏",
        "hardRate": "MEDIUM",
        "passRate": "37.68%",
        "problemsUrl": "https://leetcode.cn/problems/p0NxJO/",
        "solutionsUrl": "https://leetcode.cn/problems/p0NxJO/solution",
        "problemsDesc": "小扣当前位于魔塔游戏第一层，共有 `N` 个房间，编号为 `0 ~ N-1`。每个房间的补血道具/怪物对于血量影响记于数组 `nums`，其中正数表示道具补血数值，即血量增加对应数值；负数表示怪物造成伤害值，即血量减少对应数值；`0` 表示房间对血量无影响。\n\n**小扣初始血量为 1，且无上限**。假定小扣原计划按房间编号升序访问所有房间补血/打怪，**为保证血量始终为正值**，小扣需对房间访问顺序进行调整，**每次仅能将一个怪物房间（负数的房间）调整至访问顺序末尾**。请返回小扣最少需要调整几次，才能顺利访问所有房间。若调整顺序也无法访问完全部房间，请返回 -1。\n\n\n**示例 1：**\n>输入：`nums = [100,100,100,-250,-60,-140,-50,-50,100,150]`\n>\n>输出：`1`\n>\n>解释：初始血量为 1。至少需要将 nums[3] 调整至访问顺序末尾以满足要求。\n\n**示例 2：**\n>输入：`nums = [-200,-300,400,0]`\n>\n>输出：`-1`\n>\n>解释：调整访问顺序也无法完成全部房间的访问。\n\n**提示：**\n- `1 <= nums.length <= 10^5`\n- `-10^5 <= nums[i] <= 10^5`",
        "isPlus": false
    },
    {
        "problemsName": " 2794变换的迷宫",
        "hardRate": "HARD",
        "passRate": "29.34%",
        "problemsUrl": "https://leetcode.cn/problems/Db3wC1/",
        "solutionsUrl": "https://leetcode.cn/problems/Db3wC1/solution",
        "problemsDesc": "某解密游戏中，有一个 N\\*M 的迷宫，迷宫地形会随时间变化而改变，迷宫出口一直位于 `(n-1,m-1)` 位置。迷宫变化规律记录于 `maze` 中，`maze[i]` 表示 `i` 时刻迷宫的地形状态，`\".\"` 表示可通行空地，`\"#\"` 表示陷阱。\n\n地形图初始状态记作 `maze[0]`，此时小力位于起点 `(0,0)`。此后每一时刻可选择往上、下、左、右其一方向走一步，或者停留在原地。\n\n小力背包有以下两个魔法卷轴（卷轴使用一次后消失）：\n+ 临时消除术：将指定位置在下一个时刻变为空地；\n+ 永久消除术：将指定位置永久变为空地。\n\n请判断在迷宫变化结束前（含最后时刻），小力能否在不经过任意陷阱的情况下到达迷宫出口呢？\n\n**注意： 输入数据保证起点和终点在所有时刻均为空地。**\n\n**示例 1：**\n>输入：`maze = [[\".#.\",\"#..\"],[\"...\",\".#.\"],[\".##\",\".#.\"],[\"..#\",\".#.\"]]`\n>\n>输出：`true`\n>\n>解释：\n![maze.gif](https://pic.leetcode-cn.com/1615892239-SCIjyf-maze.gif)\n\n\n**示例 2：**\n>输入：`maze = [[\".#.\",\"...\"],[\"...\",\"...\"]]`\n>\n>输出：`false`\n>\n>解释：由于时间不够，小力无法到达终点逃出迷宫。\n\n**示例 3：**\n>输入：`maze = [[\"...\",\"...\",\"...\"],[\".##\",\"###\",\"##.\"],[\".##\",\"###\",\"##.\"],[\".##\",\"###\",\"##.\"],[\".##\",\"###\",\"##.\"],[\".##\",\"###\",\"##.\"],[\".##\",\"###\",\"##.\"]]`\n>\n>输出：`false`\n>\n>解释：由于道路不通，小力无法到达终点逃出迷宫。\n\n**提示：**\n- `1 <= maze.length <= 100`\n- `1 <= maze[i].length, maze[i][j].length <= 50`\n- `maze[i][j]` 仅包含 `\".\"`、`\"#\"`",
        "isPlus": false
    },
    {
        "problemsName": " 2795批量处理任务",
        "hardRate": "HARD",
        "passRate": "42.58%",
        "problemsUrl": "https://leetcode.cn/problems/t3fKg1/",
        "solutionsUrl": "https://leetcode.cn/problems/t3fKg1/solution",
        "problemsDesc": "某实验室计算机待处理任务以 `[start,end,period]` 格式记于二维数组 `tasks`，表示完成该任务的时间范围为起始时间 `start` 至结束时间 `end` 之间，需要计算机投入 `period` 的时长，注意：\n1. `period` 可为不连续时间\n2. 首尾时间均包含在内\n\n处于开机状态的计算机可同时处理任意多个任务，请返回电脑最少开机多久，可处理完所有任务。\n\n**示例 1：**\n>输入：`tasks = [[1,3,2],[2,5,3],[5,6,2]]`\n>\n>输出：`4`\n>\n>解释：\n>tasks[0] 选择时间点 2、3；\n>tasks[1] 选择时间点 2、3、5；\n>tasks[2] 选择时间点 5、6；\n>因此计算机仅需在时间点 2、3、5、6 四个时刻保持开机即可完成任务。\n\n**示例 2：**\n>输入：`tasks = [[2,3,1],[5,5,1],[5,6,2]]`\n>\n>输出：`3`\n>\n>解释：\n>tasks[0] 选择时间点 2 或 3；\n>tasks[1] 选择时间点 5；\n>tasks[2] 选择时间点 5、6；\n>因此计算机仅需在时间点 2、5、6 或 3、5、6 三个时刻保持开机即可完成任务。\n\n**提示：**\n- `2 <= tasks.length <= 10^5`\n- `tasks[i].length == 3`\n- `0 <= tasks[i][0] <= tasks[i][1] <= 10^9`\n- `1 <= tasks[i][2] <= tasks[i][1]-tasks[i][0] + 1`",
        "isPlus": false
    },
    {
        "problemsName": " 2796蓄水",
        "hardRate": "EASY",
        "passRate": "34.85%",
        "problemsUrl": "https://leetcode.cn/problems/o8SXZn/",
        "solutionsUrl": "https://leetcode.cn/problems/o8SXZn/solution",
        "problemsDesc": "给定 N 个无限容量且初始均空的水缸，每个水缸配有一个水桶用来打水，第 `i` 个水缸配备的水桶容量记作 `bucket[i]`。小扣有以下两种操作：\n-  升级水桶：选择任意一个水桶，使其容量增加为 `bucket[i]+1`\n-  蓄水：将全部水桶接满水，倒入各自对应的水缸\n\n每个水缸对应最低蓄水量记作 `vat[i]`，返回小扣至少需要多少次操作可以完成所有水缸蓄水要求。\n\n注意：实际蓄水量 **达到或超过** 最低蓄水量，即完成蓄水要求。\n\n**示例 1：**\n>输入：`bucket = [1,3], vat = [6,8]`\n>\n>输出：`4`\n>\n>解释：\n>第 1 次操作升级 bucket[0]；\n>第 2 ~ 4 次操作均选择蓄水，即可完成蓄水要求。\n![vat1.gif](https://pic.leetcode-cn.com/1616122992-RkDxoL-vat1.gif)\n\n\n\n**示例 2：**\n>输入：`bucket = [9,0,1], vat = [0,2,2]`\n>\n>输出：`3`\n>\n>解释：\n>第 1 次操作均选择升级 bucket[1]\n>第 2~3 次操作选择蓄水，即可完成蓄水要求。\n\n**提示：**\n- `1 <= bucket.length == vat.length <= 100`\n- `0 <= bucket[i], vat[i] <= 10^4`\n",
        "isPlus": false
    },
    {
        "problemsName": " 2797二叉树染色",
        "hardRate": "MEDIUM",
        "passRate": "56.10%",
        "problemsUrl": "https://leetcode.cn/problems/er-cha-shu-ran-se-UGC/",
        "solutionsUrl": "https://leetcode.cn/problems/er-cha-shu-ran-se-UGC/solution",
        "problemsDesc": "小扣有一个根结点为 `root` 的二叉树模型，初始所有结点均为白色，可以用蓝色染料给模型结点染色，模型的每个结点有一个 `val` 价值。小扣出于美观考虑，希望最后二叉树上每个蓝色相连部分的结点个数不能超过 `k` 个，求所有染成蓝色的结点价值总和最大是多少？\n\n\n**示例 1：**\n> 输入：`root = [5,2,3,4], k = 2`\n>\n> 输出：`12`\n>\n> 解释：`结点 5、3、4 染成蓝色，获得最大的价值 5+3+4=12`\n![image.png](https://pic.leetcode-cn.com/1616126267-BqaCRj-image.png)\n\n\n**示例 2：**\n> 输入：`root = [4,1,3,9,null,null,2], k = 2`\n>\n> 输出：`16`\n>\n> 解释：结点 4、3、9 染成蓝色，获得最大的价值 4+3+9=16\n![image.png](https://pic.leetcode-cn.com/1616126301-gJbhba-image.png)\n\n\n\n**提示：**\n+ `1 <= k <= 10`\n+ `1 <= val <= 10000`\n+ `1 <= 结点数量 <= 10000`\n    ",
        "isPlus": false
    },
    {
        "problemsName": " 2798电动车游城市",
        "hardRate": "HARD",
        "passRate": "48.26%",
        "problemsUrl": "https://leetcode.cn/problems/DFPeFJ/",
        "solutionsUrl": "https://leetcode.cn/problems/DFPeFJ/solution",
        "problemsDesc": "小明的电动车电量充满时可行驶距离为 `cnt`，每行驶 1 单位距离消耗 1 单位电量，且花费 1 单位时间。小明想选择电动车作为代步工具。地图上共有 N 个景点，景点编号为 0 ~ N-1。他将地图信息以 `[城市 A 编号,城市 B 编号,两城市间距离]` 格式整理在在二维数组 `paths`，表示城市 A、B 间存在双向通路。初始状态，电动车电量为 0。每个城市都设有充电桩，`charge[i]` 表示第 i 个城市每充 1 单位电量需要花费的单位时间。请返回小明最少需要花费多少单位时间从起点城市 `start` 抵达终点城市 `end`。\n\n\n**示例 1：**\n>输入：`paths = [[1,3,3],[3,2,1],[2,1,3],[0,1,4],[3,0,5]], cnt = 6, start = 1, end = 0, charge = [2,10,4,1]`\n>\n>输出：`43`\n>\n>解释：最佳路线为：1->3->0。\n>在城市 1 仅充 3 单位电至城市 3，然后在城市 3 充 5 单位电，行驶至城市 5。\n>充电用时共 3\\*10 + 5\\*1= 35\n>行驶用时 3 + 5 = 8，此时总用时最短 43。\n![image.png](https://pic.leetcode-cn.com/1616125304-mzVxIV-image.png)\n\n\n\n\n**示例 2：**\n>输入：`paths = [[0,4,2],[4,3,5],[3,0,5],[0,1,5],[3,2,4],[1,2,8]], cnt = 8, start = 0, end = 2, charge = [4,1,1,3,2]`\n>\n>输出：`38`\n>\n>解释：最佳路线为：0->4->3->2。\n>城市 0 充电 2 单位，行驶至城市 4 充电 8 单位，行驶至城市 3 充电 1 单位，最终行驶至城市 2。\n>充电用时 4\\*2+2\\*8+3\\*1 = 27\n>行驶用时 2+5+4 = 11，总用时最短 38。\n\n**提示：**\n- `1 <= paths.length <= 200`\n- `paths[i].length == 3`\n- `2 <= charge.length == n <= 100`\n- `0 <= path[i][0],path[i][1],start,end < n`\n- `1 <= cnt <= 100`\n- `1 <= path[i][2] <= cnt`\n- `1 <= charge[i] <= 100`\n- 题目保证所有城市相互可以到达",
        "isPlus": false
    },
    {
        "problemsName": " 2799最多牌组数",
        "hardRate": "HARD",
        "passRate": "34.61%",
        "problemsUrl": "https://leetcode.cn/problems/Up5XYM/",
        "solutionsUrl": "https://leetcode.cn/problems/Up5XYM/solution",
        "problemsDesc": "麻将的游戏规则中，共有两种方式凑成「一组牌」：\n- 顺子：三张牌面数字连续的麻将，例如 [4,5,6]\n- 刻子：三张牌面数字相同的麻将，例如 [10,10,10]\n\n给定若干数字作为麻将牌的数值（记作一维数组 `tiles`），请返回所给 `tiles` 最多可组成的牌组数。\n\n注意：凑成牌组时，每张牌仅能使用一次。\n\n**示例 1：**\n>输入：`tiles = [2,2,2,3,4]`\n>\n>输出：`1`\n>\n>解释：最多可以组合出 [2,2,2] 或者 [2,3,4] 其中一组牌。\n\n**示例 2：**\n>输入：`tiles = [2,2,2,3,4,1,3]`\n>\n>输出：`2`\n>\n>解释：最多可以组合出 [1,2,3] 与 [2,3,4] 两组牌。\n\n**提示：**\n- `1 <= tiles.length <= 10^5`\n- `1 <= tiles[i] <= 10^9`",
        "isPlus": false
    },
    {
        "problemsName": " 2800最小矩形面积",
        "hardRate": "HARD",
        "passRate": "24.89%",
        "problemsUrl": "https://leetcode.cn/problems/zui-xiao-ju-xing-mian-ji/",
        "solutionsUrl": "https://leetcode.cn/problems/zui-xiao-ju-xing-mian-ji/solution",
        "problemsDesc": "二维平面上有 $N$ 条直线，形式为 `y = kx + b`，其中 `k`、`b`为整数 且 `k > 0`。所有直线以 `[k,b]` 的形式存于二维数组 `lines` 中，不存在重合的两条直线。两两直线之间可能存在一个交点，最多会有 $C_N^2$ 个交点。我们用一个平行于坐标轴的矩形覆盖所有的交点，请问这个矩形最小面积是多少。若直线之间无交点、仅有一个交点或所有交点均在同一条平行坐标轴的直线上，则返回0。\n\n注意：返回结果是浮点数，与标准答案 **绝对误差或相对误差** 在 10^-4 以内的结果都被视为正确结果\n\n\n**示例 1：**\n> 输入：`lines = [[2,3],[3,0],[4,1]]`\n>\n> 输出：`48.00000`\n>\n> 解释：三条直线的三个交点为 (3, 9) (1, 5) 和 (-1, -3)。最小覆盖矩形左下角为 (-1, -3) 右上角为 (3,9)，面积为 48\n\n\n**示例 2：**\n> 输入：`lines = [[1,1],[2,3]]`\n>\n> 输出：`0.00000`\n>\n> 解释：仅有一个交点 (-2，-1）\n\n\n**限制：**\n+ `1 <= lines.length <= 10^5 且 lines[i].length == 2`\n+ `1 <= lines[0] <= 10000`\n+ `-10000 <= lines[1] <= 10000`\n+ `与标准答案绝对误差或相对误差在 10^-4 以内的结果都被视为正确结果`",
        "isPlus": false
    },
    {
        "problemsName": " 2801守卫城堡",
        "hardRate": "HARD",
        "passRate": "56.23%",
        "problemsUrl": "https://leetcode.cn/problems/7rLGCR/",
        "solutionsUrl": "https://leetcode.cn/problems/7rLGCR/solution",
        "problemsDesc": "城堡守卫游戏的胜利条件为使恶魔无法从出生点到达城堡。游戏地图可视作 `2*N` 的方格图，记作字符串数组 `grid`，其中：\n- `\".\"` 表示恶魔可随意通行的平地；\n- `\"#\"` 表示恶魔不可通过的障碍物，玩家可通过在 **平地** 上设置障碍物，即将  `\".\"` 变为 `\"#\"` 以阻挡恶魔前进；\n- `\"S\"` 表示恶魔出生点，将有大量的恶魔该点生成，恶魔可向上/向下/向左/向右移动，且无法移动至地图外；\n- `\"P\"` 表示瞬移点，移动到 `\"P\"` 点的恶魔可被传送至任意一个 `\"P\"` 点，也可选择不传送；\n- `\"C\"` 表示城堡。\n\n然而在游戏中用于建造障碍物的金钱是有限的，请返回玩家最少需要放置几个障碍物才能获得胜利。若无论怎样放置障碍物均无法获胜，请返回 `-1`。\n\n**注意：**\n- 地图上可能有一个或多个出生点\n- 地图上有且只有一个城堡\n\n**示例 1**\n>输入：`grid = [\"S.C.P#P.\", \".....#.S\"]`\n>\n>输出：`3`\n>\n>解释：至少需要放置三个障碍物\n![image.png](https://pic.leetcode-cn.com/1614828255-uuNdNJ-image.png)\n\n\n**示例 2：**\n>输入：`grid = [\"SP#P..P#PC#.S\", \"..#P..P####.#\"]`\n>\n>输出：`-1`\n>\n>解释：无论怎样修筑障碍物，均无法阻挡最左侧出生的恶魔到达城堡位置\n![image.png](https://pic.leetcode-cn.com/1614828208-oFlpVs-image.png)\n\n**示例 3：**\n>输入：`grid = [\"SP#.C.#PS\", \"P.#...#.P\"]`\n>\n>输出：`0`\n>\n>解释：无需放置障碍物即可获得胜利\n![image.png](https://pic.leetcode-cn.com/1614828242-oveClu-image.png)\n\n**示例 4：**\n>输入：`grid = [\"CP.#.P.\", \"...S..S\"]`\n>\n>输出：`4`\n>\n>解释：至少需要放置 4 个障碍物，示意图为放置方法之一\n![image.png](https://pic.leetcode-cn.com/1614828218-sIAYkb-image.png)\n\n\n**提示：**\n- `grid.length == 2`\n- `2 <= grid[0].length == grid[1].length <= 10^4`\n- `grid[i][j]` 仅包含字符 `\".\"`、`\"#\"`、`\"C\"`、`\"P\"`、`\"S\"`\n",
        "isPlus": false
    },
    {
        "problemsName": " 2802无人机方阵",
        "hardRate": "EASY",
        "passRate": "55.54%",
        "problemsUrl": "https://leetcode.cn/problems/0jQkd0/",
        "solutionsUrl": "https://leetcode.cn/problems/0jQkd0/solution",
        "problemsDesc": "在 「力扣挑战赛」 开幕式的压轴节目 「无人机方阵」中，每一架无人机展示一种灯光颜色。 无人机方阵通过两种操作进行颜色图案变换：\n- 调整无人机的位置布局\n- 切换无人机展示的灯光颜色\n\n\n给定两个大小均为 `N*M` 的二维数组 `source` 和 `target` 表示无人机方阵表演的两种颜色图案，由于无人机切换灯光颜色的耗能很大，请返回从 `source` 到 `target` 最少需要多少架无人机切换灯光颜色。\n\n\n**注意：** 调整无人机的位置布局时无人机的位置可以随意变动。\n\n\n**示例 1：**\n> 输入：`source = [[1,3],[5,4]], target = [[3,1],[6,5]]`\n>\n> 输出：`1`\n>\n> 解释：\n> 最佳方案为\n将 `[0,1]` 处的无人机移动至 `[0,0]` 处；\n将 `[0,0]` 处的无人机移动至 `[0,1]` 处；\n将 `[1,0]` 处的无人机移动至 `[1,1]` 处；\n将 `[1,1]` 处的无人机移动至 `[1,0]` 处，其灯光颜色切换为颜色编号为 `6` 的灯光；\n因此从`source` 到 `target` 所需要的最少灯光切换次数为 1。\n>![8819ccdd664e91c78cde3bba3c701986.gif](https://pic.leetcode-cn.com/1628823765-uCDaux-8819ccdd664e91c78cde3bba3c701986.gif){:height=300px}\n\n\n\n\n\n**示例 2：**\n> 输入：`source = [[1,2,3],[3,4,5]], target = [[1,3,5],[2,3,4]]`\n>\n> 输出：`0`\n> 解释：\n> 仅需调整无人机的位置布局，便可完成图案切换。因此不需要无人机切换颜色\n\n\n**提示：**\n`n == source.length == target.length`\n`m == source[i].length == target[i].length`\n`1 <= n, m <=100`\n`1 <= source[i][j], target[i][j] <=10^4`\n\n\n\n",
        "isPlus": false
    },
    {
        "problemsName": " 2803心算挑战",
        "hardRate": "EASY",
        "passRate": "31.15%",
        "problemsUrl": "https://leetcode.cn/problems/uOAnQW/",
        "solutionsUrl": "https://leetcode.cn/problems/uOAnQW/solution",
        "problemsDesc": "「力扣挑战赛」心算项目的挑战比赛中，要求选手从 `N` 张卡牌中选出 `cnt` 张卡牌，若这 `cnt` 张卡牌数字总和为偶数，则选手成绩「有效」且得分为 `cnt` 张卡牌数字总和。\n给定数组 `cards` 和 `cnt`，其中 `cards[i]` 表示第 `i` 张卡牌上的数字。 请帮参赛选手计算最大的有效得分。若不存在获取有效得分的卡牌方案，则返回 0。\n\n**示例 1：**\n>输入：`cards = [1,2,8,9], cnt = 3`\n>\n>输出：`18`\n>\n>解释：选择数字为 1、8、9 的这三张卡牌，此时可获得最大的有效得分 1+8+9=18。\n\n**示例 2：**\n>输入：`cards = [3,3,1], cnt = 1`\n>\n>输出：`0`\n>\n>解释：不存在获取有效得分的卡牌方案。\n\n**提示：**\n- `1 <= cnt <= cards.length <= 10^5`\n- `1 <= cards[i] <= 1000`\n\n\n",
        "isPlus": false
    },
    {
        "problemsName": " 2804黑白翻转棋",
        "hardRate": "MEDIUM",
        "passRate": "68.32%",
        "problemsUrl": "https://leetcode.cn/problems/fHi6rV/",
        "solutionsUrl": "https://leetcode.cn/problems/fHi6rV/solution",
        "problemsDesc": "在 `n*m` 大小的棋盘中，有黑白两种棋子，黑棋记作字母 `\"X\"`, 白棋记作字母 `\"O\"`，空余位置记作 `\".\"`。当落下的棋子与其他相同颜色的棋子在行、列或对角线完全包围（中间不存在空白位置）另一种颜色的棋子，则可以翻转这些棋子的颜色。\n\n\n\n![1.gif](https://pic.leetcode-cn.com/1630396029-eTgzpN-6da662e67368466a96d203f67bb6e793.gif){:height=170px}![2.gif](https://pic.leetcode-cn.com/1630396240-nMvdcc-8e4261afe9f60e05a4f740694b439b6b.gif){:height=170px}![3.gif](https://pic.leetcode-cn.com/1630396291-kEtzLL-6fcb682daeecb5c3f56eb88b23c81d33.gif){:height=170px}\n\n「力扣挑战赛」黑白翻转棋项目中，将提供给选手一个未形成可翻转棋子的棋盘残局，其状态记作 `chessboard`。若下一步可放置一枚黑棋，请问选手最多能翻转多少枚白棋。\n\n**注意：**\n- 若翻转白棋成黑棋后，棋盘上仍存在可以翻转的白棋，将可以 **继续** 翻转白棋\n- 输入数据保证初始棋盘状态无可以翻转的棋子且存在空余位置\n\n**示例 1：**\n> 输入：`chessboard = [\"....X.\",\"....X.\",\"XOOO..\",\"......\",\"......\"]`\n> \n> 输出：`3`\n> \n> 解释：\n> 可以选择下在 `[2,4]` 处，能够翻转白方三枚棋子。\n\n**示例 2：**\n> 输入：`chessboard = [\".X.\",\".O.\",\"XO.\"]`\n> \n> 输出：`2`\n> \n> 解释：\n> 可以选择下在 `[2,2]` 处，能够翻转白方两枚棋子。\n![2126c1d21b1b9a9924c639d449cc6e65.gif](https://pic.leetcode-cn.com/1626683255-OBtBud-2126c1d21b1b9a9924c639d449cc6e65.gif)\n\n**示例 3：**\n> 输入：`chessboard = [\".......\",\".......\",\".......\",\"X......\",\".O.....\",\"..O....\",\"....OOX\"]`\n> \n> 输出：`4`\n> \n> 解释：\n> 可以选择下在 `[6,3]` 处，能够翻转白方四枚棋子。\n![803f2f04098b6174397d6c696f54d709.gif](https://pic.leetcode-cn.com/1630393770-Puyked-803f2f04098b6174397d6c696f54d709.gif)\n\n\n\n**提示：**\n- `1 <= chessboard.length, chessboard[i].length <= 8`\n- `chessboard[i]` 仅包含 `\".\"、\"O\"` 和 `\"X\"`",
        "isPlus": false
    },
    {
        "problemsName": " 2805玩具套圈",
        "hardRate": "HARD",
        "passRate": "28.56%",
        "problemsUrl": "https://leetcode.cn/problems/vFjcfV/",
        "solutionsUrl": "https://leetcode.cn/problems/vFjcfV/solution",
        "problemsDesc": "「力扣挑战赛」场地外，小力组织了一个套玩具的游戏。所有的玩具摆在平地上，`toys[i]` 以 `[xi,yi,ri]` 的形式记录了第 `i` 个玩具的坐标 `(xi,yi)` 和半径 `ri`。小扣试玩了一下，他扔了若干个半径均为 `r` 的圈，`circles[j]` 记录了第 `j` 个圈的坐标 `(xj,yj)`。套圈的规则如下：\n- 若一个玩具被某个圈完整覆盖了（即玩具的任意部分均在圈内或者圈上），则该玩具被套中。\n- 若一个玩具被多个圈同时套中，最终仅计算为套中一个玩具\n\n请帮助小扣计算，他成功套中了多少玩具。\n\n**注意：**\n- 输入数据保证任意两个玩具的圆心不会重合，但玩具之间可能存在重叠。\n\n\n**示例 1：**\n\n> 输入：`toys = [[3,3,1],[3,2,1]], circles = [[4,3]], r = 2`\n>\n> 输出：`1`\n> \n> 解释： 如图所示，仅套中一个玩具\n![image.png](https://pic.leetcode-cn.com/1629194140-ydKiGF-image.png)\n\n\n**示例 2：**\n\n> 输入：`toys = [[1,3,2],[4,3,1],[7,1,2]], circles = [[1,0],[3,3]], r = 4`\n>\n> 输出：`2`\n> \n> 解释： 如图所示，套中两个玩具\n![image.png](https://pic.leetcode-cn.com/1629194157-RiOAuy-image.png){:width=\"400px\"}\n\n\n\n**提示：** \n- `1 <= toys.length <= 10^4`\n- `0 <= toys[i][0], toys[i][1] <= 10^9`\n- `1 <= circles.length <= 10^4`\n- `0 <= circles[i][0], circles[i][1] <= 10^9`\n- `1 <= toys[i][2], r <= 10`\n",
        "isPlus": false
    },
    {
        "problemsName": " 2806十字路口的交通",
        "hardRate": "HARD",
        "passRate": "51.62%",
        "problemsUrl": "https://leetcode.cn/problems/Y1VbOX/",
        "solutionsUrl": "https://leetcode.cn/problems/Y1VbOX/solution",
        "problemsDesc": "前往「力扣挑战赛」场馆的道路上，有一个拥堵的十字路口，该十字路口由两条双向两车道的路交叉构成。由于信号灯故障，交警需要手动指挥拥堵车辆。假定路口没有新的来车且一辆车从一个车道驶入另一个车道所需的时间恰好为一秒钟，长度为 4 的一维字符串数组 `directions` 中按照 **东、南、西、北** 顺序记录了四个方向从最靠近路口到最远离路口的车辆计划开往的方向。其中：\n- `\"E\"` 表示向东行驶；\n- `\"S\"` 表示向南行驶；\n- `\"W\"` 表示向西行驶；\n- `\"N\"` 表示向北行驶。\n\n交警每秒钟只能指挥各个车道距离路口最近的一辆车，且每次指挥需要满足如下规则：\n- 同一秒钟内，一个方向的车道只允许驶出一辆车；\n- 同一秒钟内，一个方向的车道只允许驶入一辆车；\n- 同一秒钟内，车辆的行驶路线不可相交。\n\n请返回最少需要几秒钟，该十字路口等候的车辆才能全部走完。\n\n各个车道驶出的车辆可能的行驶路线如图所示：\n\n\n![图片.png](https://pic.leetcode-cn.com/1630393755-gyPeMM-%E5%9B%BE%E7%89%87.png){:height=\"350px\"}\n\n**注意：**\n- 测试数据保证不会出现掉头行驶指令，即某一方向的行驶车辆计划开往的方向不会是当前车辆所在的车道的方向;\n- 表示堵塞车辆行驶方向的字符串仅用大写字母 `\"E\"`，`\"N\"`，`\"W\"`，`\"S\"` 表示。\n\n**示例 1：**\n>输入：`directions = [\"W\",\"N\",\"ES\",\"W\"]`\n>\n>输出：`2`\n>\n>解释：\n>第 1 秒：东西方向排在最前的车先行，剩余车辆状态 `[\"\",\"N\",\"S\",\"W\"]`；\n>第 2 秒：南、西、北方向的车行驶，路口无等待车辆；\n>因此最少需要 2 秒，返回 2。\n\n**示例 2：**\n>输入：`directions = [\"NS\",\"WE\",\"SE\",\"EW\"]`\n>\n>输出：`3`\n>\n>解释：\n>第 1 秒：四个方向排在最前的车均可驶出；\n>第 2 秒：东南方向的车驶出，剩余车辆状态 `[\"\",\"\",\"E\",\"W\"]`；\n>第 3 秒：西北方向的车驶出。\n\n\n**提示：**\n- `directions.length = 4`\n- `0 <= directions[i].length <= 20`\n",
        "isPlus": false
    },
    {
        "problemsName": " 2807开幕式焰火",
        "hardRate": "EASY",
        "passRate": "78.63%",
        "problemsUrl": "https://leetcode.cn/problems/sZ59z6/",
        "solutionsUrl": "https://leetcode.cn/problems/sZ59z6/solution",
        "problemsDesc": "「力扣挑战赛」开幕式开始了，空中绽放了一颗二叉树形的巨型焰火。\n给定一棵二叉树 `root` 代表焰火，节点值表示巨型焰火这一位置的颜色种类。请帮小扣计算巨型焰火有多少种不同的颜色。\n\n\n**示例 1：**\n>输入：`root = [1,3,2,1,null,2]`\n>\n>输出：`3`\n>\n>解释：焰火中有 3 个不同的颜色，值分别为 1、2、3\n\n**示例 2：**\n>输入：`root = [3,3,3]`\n>\n>输出：`1`\n>\n>解释：焰火中仅出现 1 个颜色，值为 3\n\n**提示：**\n- `1 <= 节点个数 <= 1000`\n- `1 <= Node.val <= 1000`\n\n\n",
        "isPlus": false
    },
    {
        "problemsName": " 2808自行车炫技赛场",
        "hardRate": "MEDIUM",
        "passRate": "29.66%",
        "problemsUrl": "https://leetcode.cn/problems/kplEvH/",
        "solutionsUrl": "https://leetcode.cn/problems/kplEvH/solution",
        "problemsDesc": "「力扣挑战赛」中 `N*M` 大小的自行车炫技赛场的场地由一片连绵起伏的上下坡组成，场地的高度值记录于二维数组 `terrain` 中，场地的减速值记录于二维数组 `obstacle` 中。\n- 若选手骑着自行车从高度为 `h1` 且减速值为 `o1` 的位置到高度为 `h2` 且减速值为 `o2` 的相邻位置（上下左右四个方向），速度变化值为 `h1-h2-o2`（负值减速，正值增速）。\n\n选手初始位于坐标 `position` 处且初始速度为 1，请问选手可以刚好到其他哪些位置时速度依旧为 1。请以二维数组形式返回这些位置。若有多个位置则按行坐标升序排列，若有多个位置行坐标相同则按列坐标升序排列。\n\n**注意：** 骑行过程中速度不能为零或负值\n\n**示例 1：**\n> 输入\b：`position = [0,0], terrain = [[0,0],[0,0]], obstacle = [[0,0],[0,0]]`\n> \n> 输出：`[[0,1],[1,0],[1,1]]`\n> \n> 解释：\n> 由于当前场地属于平地，根据上面的规则，选手从`[0,0]`的位置出发都能刚好在其他处的位置速度为 1。\n\n**示例 2：**\n> 输入\b：`position = [1,1], terrain = [[5,0],[0,6]], obstacle = [[0,6],[7,0]]`\n> \n> 输出：`[[0,1]]`\n> \n> 解释：\n> 选手从 `[1,1]` 处的位置出发，到 `[0,1]` 处的位置时恰好速度为 1。\n\n\n**提示：**\n- `n == terrain.length == obstacle.length`\n- `m == terrain[i].length == obstacle[i].length`\n- `1 <= n <= 100`\n- `1 <= m <= 100`\n- `0 <= terrain[i][j], obstacle[i][j] <= 100`\n- `position.length == 2`\n- `0 <= position[0] < n`\n- `0 <= position[1] < m`",
        "isPlus": false
    },
    {
        "problemsName": " 2809志愿者调配",
        "hardRate": "MEDIUM",
        "passRate": "49.17%",
        "problemsUrl": "https://leetcode.cn/problems/05ZEDJ/",
        "solutionsUrl": "https://leetcode.cn/problems/05ZEDJ/solution",
        "problemsDesc": "「力扣挑战赛」有 `n` 个比赛场馆（场馆编号从 `0` 开始），场馆之间的通道分布情况记录于二维数组 `edges` 中，`edges[i]= [x, y]` 表示第 `i` 条通道连接场馆 `x` 和场馆 `y`(即两个场馆相邻)。初始每个场馆中都有一定人数的志愿者（不同场馆人数可能不同），后续 `m` 天每天均会根据赛事热度进行志愿者人数调配。调配方案分为如下三种：\n1. 将编号为 `idx` 的场馆内的志愿者人数减半；\n2. 将编号为 `idx` 的场馆相邻的场馆的志愿者人数都加上编号为 `idx` 的场馆的志愿者人数；\n3. 将编号为 `idx` 的场馆相邻的场馆的志愿者人数都减去编号为 `idx` 的场馆的志愿者人数。\n\n所有的调配信息记录于数组 `plans` 中，`plans[i] = [num,idx]` 表示第 `i` 天对编号 `idx` 的场馆执行了第 `num` 种调配方案。\n在比赛结束后对调配方案进行复盘时，不慎将第 `0` 个场馆的**最终**志愿者人数丢失，只保留了**初始**所有场馆的志愿者总人数 `totalNum` ，以及记录了第 `1 ~ n-1` 个场馆的**最终**志愿者人数的一维数组 `finalCnt`。请你根据现有的信息求出初始每个场馆的志愿者人数，并按场馆编号顺序返回志愿者人数列表。\n\n**注意：**\n- 测试数据保证当某场馆进行第一种调配时，该场馆的志愿者人数一定为偶数；\n- 测试数据保证当某场馆进行第三种调配时，该场馆的相邻场馆志愿者人数不为负数；\n- 测试数据保证比赛开始时每个场馆的志愿者人数都不超过 `10^9`；\n- 测试数据保证给定的场馆间的道路分布情况中不会出现自环、重边的情况。\n\n\n**示例 1：**\n>![image.png](https://pic.leetcode-cn.com/1630061228-gnZsOz-image.png)\n> 输入：\n>`finalCnt = [1,16], totalNum = 21, edges = [[0,1],[1,2]], plans = [[2,1],[1,0],[3,0]]`\n>\n> 输出：`[5,7,9]`\n>\n> 解释：\n> ![image.png](https://pic.leetcode-cn.com/1630061300-WuVkeF-image.png){:height=200}\n\n\n**示例 2 ：**\n> 输入：\n>`finalCnt = [4,13,4,3,8], totalNum = 54, edges = [[0,3],[1,3],[4,3],[2,3],[2,5]], plans = [[1,1],[3,3],[2,5],[1,0]]`\n>\n> 输出：`[10,16,9,4,7,8]`\n\n\n\n**提示：**\n- `2 <= n <= 5*10^4`\n- `1 <= edges.length <= min((n * (n - 1)) / 2, 5*10^4)`\n- `0 <= edges[i][0], edges[i][1] < n`\n- `1 <= plans.length <= 10`\n- `1 <= plans[i][0] <=3`\n- `0 <= plans[i][1] < n`\n- `finalCnt.length = n-1`\n- `0 <= finalCnt[i] < 10^9`\n- `0 <= totalNum < 5*10^13`\n",
        "isPlus": false
    },
    {
        "problemsName": " 2810入场安检",
        "hardRate": "HARD",
        "passRate": "44.99%",
        "problemsUrl": "https://leetcode.cn/problems/oPs9Bm/",
        "solutionsUrl": "https://leetcode.cn/problems/oPs9Bm/solution",
        "problemsDesc": "「力扣挑战赛」 的入场仪式马上就要开始了，由于安保工作的需要，设置了可容纳人数总和为 `M` 的 `N` 个安检室，`capacities[i]` 记录第 `i` 个安检室可容纳人数。安检室拥有两种类型：\n- 先进先出：在安检室中的所有观众中，最早进入安检室的观众最先离开\n- 后进先出：在安检室中的所有观众中，最晚进入安检室的观众最先离开\n\n![c24754f1a5ff56989340ba5004dc5eda.gif](https://pic.leetcode-cn.com/1628843202-cdFPSt-c24754f1a5ff56989340ba5004dc5eda.gif)\n\n\n\n恰好 `M+1` 位入场的观众（编号从 0 开始）需要排队**依次**入场安检， 入场安检的规则如下：\n- 观众需要先进入编号 `0` 的安检室\n- 当观众将进入编号 `i` 的安检室时（`0 <= i < N`)，\n    - 若安检室未到达可容纳人数上限，该观众可直接进入；\n    - 若安检室已到达可容纳人数上限，在该观众进入安检室之前需根据当前安检室类型选择一位观众离开后才能进入；\n- 当观众离开编号 `i` 的安检室时 （`0 <= i < N-1`)，将进入编号 `i+1` 的安检室接受安检。\n\n若可以任意设定每个安检室的类型，请问有多少种设定安检室类型的方案可以使得编号 `k` 的观众第一个通过最后一个安检室入场。\n\n\n**注意：** \n- 观众不可主动离开安检室，只有当安检室容纳人数达到上限，且又有新观众需要进入时，才可根据安检室的类型选择一位观众离开；\n- 由于方案数可能过大，请将答案对 `1000000007` 取模后返回。\n\n\n**示例 1：**\n> 输入：`capacities = [2,2,3], k = 2`\n>\n> 输出：`2`\n> 解释：\n> 存在两种设定的 `2` 种方案：\n> - 方案 1：将编号为 `0` 、`1` 的实验室设置为 **后进先出** 的类型，编号为 `2` 的实验室设置为 **先进先出** 的类型；\n> - 方案 2：将编号为 `0` 、`1` 的实验室设置为 **先进先出** 的类型，编号为 `2` 的实验室设置为 **后进先出** 的类型。\n>\n> 以下是方案 1 的示意图：\n>![c60e38199a225ad62f13b954872edf9b.gif](https://pic.leetcode-cn.com/1628841618-bFKsnt-c60e38199a225ad62f13b954872edf9b.gif)\n\n\n\n**示例 2：**\n> 输入：`capacities = [3,3], k = 3`\n>\n> 输出：`0`\n\n**示例 3：**\n> 输入：`capacities = [4,3,2,2], k = 6`\n>\n> 输出：`2`\n\n**提示:**\n+ `1 <= capacities.length <= 200`\n+ `1 <= capacities[i] <= 200`\n+ `0 <= k <= sum(capacities)`\n",
        "isPlus": false
    },
    {
        "problemsName": " 2811无限棋局",
        "hardRate": "HARD",
        "passRate": "27.34%",
        "problemsUrl": "https://leetcode.cn/problems/fsa7oZ/",
        "solutionsUrl": "https://leetcode.cn/problems/fsa7oZ/solution",
        "problemsDesc": "小力正在通过残局练习来备战「力扣挑战赛」中的「五子棋」项目，他想请你能帮他预测当前残局的输赢情况。棋盘中的棋子分布信息记录于二维数组 `pieces` 中，其中 `pieces[i] = [x,y,color]` 表示第 `i` 枚棋子的横坐标为 `x`，纵坐标为 `y`，棋子颜色为 `color`(`0` 表示黑棋，`1` 表示白棋)。假如黑棋先行，并且黑棋和白棋都按最优策略落子，请你求出当前棋局在三步（按 **黑、白、黑** 的落子顺序）之内的输赢情况（三步之内先构成同行、列或对角线连续同颜色的至少 5 颗即为获胜）：\n- 黑棋胜, 请返回 `\"Black\"`\n- 白棋胜, 请返回 `\"White\"`\n- 仍无胜者, 请返回 `\"None\"`\n\n**注意：** \n- 和传统的五子棋项目不同，「力扣挑战赛」中的「五子棋」项目 **不存在边界限制**，即可在 **任意位置** 落子；\n- 黑棋和白棋均按 3 步内的输赢情况进行最优策略的选择\n- 测试数据保证所给棋局目前无胜者；\n- 测试数据保证不会存在坐标一样的棋子。\n\n**示例 1：**\n> 输入：\n> `pieces = [[0,0,1],[1,1,1],[2,2,0]]`\n>\n> 输出：`\"None\"`\n>\n> 解释：无论黑、白棋以何种方式落子，三步以内都不会产生胜者。\n\n**示例 2：**\n> 输入：\n> `pieces = [[1,2,1],[1,4,1],[1,5,1],[2,1,0],[2,3,0],[2,4,0],[3,2,1],[3,4,0],[4,2,1],[5,2,1]]`\n>\n> 输出：`\"Black\"`\n>\n> 解释：三步之内黑棋必胜，以下是一种可能的落子情况：\n>![902b87df29998b1c181146c8fdb3a4b6.gif](https://pic.leetcode-cn.com/1629800639-KabOfY-902b87df29998b1c181146c8fdb3a4b6.gif){:width=\"300px\"}\n\n\n\n**提示：**\n- `0 <= pieces.length <= 1000`\n- `pieces[i].length = 3`\n- `-10^9 <= pieces[i][0], pieces[i][1] <=10^9` \n- `0 <= pieces[i][2] <=1`\n",
        "isPlus": false
    },
    {
        "problemsName": " 2812环形闯关游戏",
        "hardRate": "HARD",
        "passRate": "35.50%",
        "problemsUrl": "https://leetcode.cn/problems/K8GULz/",
        "solutionsUrl": "https://leetcode.cn/problems/K8GULz/solution",
        "problemsDesc": "「力扣挑战赛」中有一个由 `N` 个关卡组成的**环形**闯关游戏，关卡编号为 `0`~`N-1`，编号 `0` 的关卡和编号 `N-1` 的关卡相邻。每个关卡均有积分要求，`challenge[i]` 表示挑战编号 `i` 的关卡最少需要拥有的积分。\n![图片.png](https://pic.leetcode-cn.com/1630392170-ucncVS-%E5%9B%BE%E7%89%87.png){:width=\"240px\"}\n\n\n小扣想要挑战关卡，闯关具体规则如下：\n\n- 初始小扣可以指定其中一个关卡为「开启」状态，其余关卡将处于「未开启」状态。\n- 小扣可以挑战处于「开启」状态且**满足最少积分要求**的关卡，若小扣挑战该关卡前积分为 `score`，挑战结束后，积分将增长为 `score|challenge[i]`（即位运算中的 `\"OR\"` 运算）\n- 在挑战某个关卡后，该关卡两侧相邻的关卡将会开启（若之前未开启）\n\n请帮助小扣进行计算，初始最少需要多少积分，可以挑战 **环形闯关游戏** 的所有关卡。\n\n**示例1：**\n\n> 输入：`challenge = [5,4,6,2,7]`\n>\n> 输出：`4`\n> \n> 解释： 初始选择编号 3 的关卡开启，积分为 4\n>挑战编号 3 的关卡，积分变为 $4 | 2 = 6$，开启 2、4 处的关卡\n>挑战编号 2 的关卡，积分变为 $6 | 6 = 6$，开启 1 处的关卡\n>挑战编号 1 的关卡，积分变为 $6 | 4 = 6$，开启 0 处的关卡\n>挑战编号 0 的关卡，积分变为 $6 | 5 = 7$\n>挑战编号 4 的关卡，顺利完成全部的关卡\n\n\n**示例2：**\n\n> 输入：`challenge = [12,7,11,3,9]`\n>\n> 输出：`8`\n>\n> 解释： 初始选择编号 3 的关卡开启，积分为 8\n>挑战编号 3 的关卡，积分变为 $8 | 3 = 11$，开启 2、4 处的关卡\n>挑战编号 2 的关卡，积分变为 $11 | 11 = 11$，开启 1 处的关卡\n>挑战编号 4 的关卡，积分变为 $11 | 9 = 11$，开启 0 处的关卡\n>挑战编号 1 的关卡，积分变为 $11 | 7 = 15$\n>挑战编号 0 的关卡，顺利完成全部的关卡\n\n**示例3：**\n\n> 输入：`challenge = [1,1,1]`\n>\n> 输出：`1`\n\n**提示：** \n- `1 <= challenge.length <= 5*10^4`\n- `1 <= challenge[i] <= 10^14`",
        "isPlus": false
    },
    {
        "problemsName": " 2813宝石补给",
        "hardRate": "EASY",
        "passRate": "68.42%",
        "problemsUrl": "https://leetcode.cn/problems/WHnhjV/",
        "solutionsUrl": "https://leetcode.cn/problems/WHnhjV/solution",
        "problemsDesc": "欢迎各位勇者来到力扣新手村，在开始试炼之前，请各位勇者先进行「宝石补给」。\n\n每位勇者初始都拥有一些能量宝石， `gem[i]` 表示第 `i` 位勇者的宝石数量。现在这些勇者们进行了一系列的赠送，`operations[j] = [x, y]` 表示在第 `j` 次的赠送中 第 `x` 位勇者将自己一半的宝石（需向下取整）赠送给第 `y` 位勇者。\n\n在完成所有的赠送后，请找到拥有**最多**宝石的勇者和拥有**最少**宝石的勇者，并返回他们二者的宝石数量**之差**。\n\n**注意：**\n- 赠送将按顺序逐步进行。\n\n**示例 1：**\n>输入：`gem = [3,1,2], operations = [[0,2],[2,1],[2,0]]`\n>\n>输出：`2`\n>\n>解释：\n>第 1 次操作，勇者 `0` 将一半的宝石赠送给勇者 `2`， `gem = [2,1,3]`\n>第 2 次操作，勇者 `2` 将一半的宝石赠送给勇者 `1`， `gem = [2,2,2]`\n>第 3 次操作，勇者 `2` 将一半的宝石赠送给勇者 `0`， `gem = [3,2,1]`\n>返回 3 - 1 = 2\n\n**示例 2：**\n>输入：`gem = [100,0,50,100], operations = [[0,2],[0,1],[3,0],[3,0]]`\n>\n>输出：`75`\n>\n>解释：\n>第 1 次操作，勇者 `0` 将一半的宝石赠送给勇者 `2`， `gem = [50,0,100,100]`\n>第 2 次操作，勇者 `0` 将一半的宝石赠送给勇者 `1`， `gem = [25,25,100,100]`\n>第 3 次操作，勇者 `3` 将一半的宝石赠送给勇者 `0`， `gem = [75,25,100,50]`\n>第 4 次操作，勇者 `3` 将一半的宝石赠送给勇者 `0`， `gem = [100,25,100,25]`\n>返回 100 - 25 = 75\n\n**示例 3：**\n>输入：`gem = [0,0,0,0], operations = [[1,2],[3,1],[1,2]]`\n>\n>输出：`0`\n\n**提示：**\n- `2 <= gem.length <= 10^3`\n- `0 <= gem[i] <= 10^3`\n- `0 <= operations.length <= 10^4`\n- `operations[i].length == 2`\n- `0 <= operations[i][0], operations[i][1] < gem.length`",
        "isPlus": false
    },
    {
        "problemsName": " 2814烹饪料理",
        "hardRate": "EASY",
        "passRate": "48.13%",
        "problemsUrl": "https://leetcode.cn/problems/UEcfPD/",
        "solutionsUrl": "https://leetcode.cn/problems/UEcfPD/solution",
        "problemsDesc": "欢迎各位勇者来到力扣城，城内设有烹饪锅供勇者制作料理，为自己恢复状态。\n\n勇者背包内共有编号为 `0 ~ 4` 的五种食材，其中 `materials[j]` 表示第 `j` 种食材的数量。通过这些食材可以制作若干料理，`cookbooks[i][j]` 表示制作第 `i` 种料理需要第 `j` 种食材的数量，而 `attribute[i] = [x,y]` 表示第 `i` 道料理的美味度 `x` 和饱腹感 `y`。\n\n在饱腹感不小于 `limit` 的情况下，请返回勇者可获得的最大美味度。如果无法满足饱腹感要求，则返回 `-1`。\n\n**注意：**\n- 每种料理只能制作一次。\n\n\n**示例 1：**\n>输入：`materials = [3,2,4,1,2]`\n>`cookbooks = [[1,1,0,1,2],[2,1,4,0,0],[3,2,4,1,0]]`\n>`attribute = [[3,2],[2,4],[7,6]]`\n>`limit = 5`\n>\n>输出：`7`\n>\n>解释：\n>食材数量可以满足以下两种方案：\n>方案一：制作料理 0 和料理 1，可获得饱腹感 2+4、美味度 3+2\n>方案二：仅制作料理 2， 可饱腹感为 6、美味度为 7\n>因此在满足饱腹感的要求下，可获得最高美味度 7\n\n**示例 2：**\n>输入：`materials = [10,10,10,10,10]`\n>`cookbooks = [[1,1,1,1,1],[3,3,3,3,3],[10,10,10,10,10]]`\n>`attribute = [[5,5],[6,6],[10,10]]`\n>`limit = 1`\n>\n>输出：`11`\n>\n>解释：通过制作料理 0 和 1，可满足饱腹感，并获得最高美味度 11\n\n**提示：**\n+ `materials.length == 5`\n+ `1 <= cookbooks.length == attribute.length <= 8`\n+ `cookbooks[i].length == 5`\n+ `attribute[i].length == 2`\n+ `0 <= materials[i], cookbooks[i][j], attribute[i][j] <= 20`\n+ `1 <= limit <= 100`\n",
        "isPlus": false
    },
    {
        "problemsName": " 2815二叉搜索树染色",
        "hardRate": "MEDIUM",
        "passRate": "28.66%",
        "problemsUrl": "https://leetcode.cn/problems/QO5KpG/",
        "solutionsUrl": "https://leetcode.cn/problems/QO5KpG/solution",
        "problemsDesc": "欢迎各位勇者来到力扣城，本次试炼主题为「二叉搜索树染色」。\n\n每位勇士面前设有一个**二叉搜索树**的模型，模型的根节点为 `root`，树上的各个节点值均不重复。初始时，所有节点均为蓝色。现在按顺序对这棵二叉树进行若干次操作， `ops[i] = [type, x, y]` 表示第 `i` 次操作为：\n+ `type` 等于 0 时，将节点值范围在 `[x, y]` 的节点均染蓝\n+ `type` 等于 1 时，将节点值范围在 `[x, y]` 的节点均染红\n\n请返回完成所有染色后，该二叉树中红色节点的数量。\n\n\n**注意：**\n+ 题目保证对于每个操作的 `x`、`y` 值定出现在二叉搜索树节点中\n\n**示例 1：**\n>输入：`root = [1,null,2,null,3,null,4,null,5], ops = [[1,2,4],[1,1,3],[0,3,5]]`\n>\n>输出：`2`\n>\n>解释：\n>第 0 次操作，将值为 2、3、4 的节点染红；\n>第 1 次操作，将值为 1、2、3 的节点染红；\n>第 2 次操作，将值为 3、4、5 的节点染蓝；\n>因此，最终值为 1、2 的节点为红色节点，返回数量 2\n![image.png](https://pic.leetcode-cn.com/1649833948-arSlXd-image.png){:width=230px}\n\n\n**示例 2：**\n>输入：`root = [4,2,7,1,null,5,null,null,null,null,6]` \n>`ops = [[0,2,2],[1,1,5],[0,4,5],[1,5,7]]`\n>\n>输出：`5`\n>\n>解释：\n>第 0 次操作，将值为 2 的节点染蓝；\n>第 1 次操作，将值为 1、2、4、5 的节点染红；\n>第 2 次操作，将值为 4、5 的节点染蓝；\n>第 3 次操作，将值为 5、6、7 的节点染红；\n>因此，最终值为 1、2、5、6、7 的节点为红色节点，返回数量 5\n![image.png](https://pic.leetcode-cn.com/1649833763-BljEbP-image.png){:width=230px}\n\n**提示：**\n+ `1 <= 二叉树节点数量 <= 10^5`\n+ `1 <= ops.length <= 10^5`\n+ `ops[i].length == 3`\n+ `ops[i][0]` 仅为 `0` or `1`\n+ `0 <= ops[i][1] <= ops[i][2] <= 10^9`\n+ `0 <= 节点值 <= 10^9`\n",
        "isPlus": false
    },
    {
        "problemsName": " 2816守护太空城",
        "hardRate": "HARD",
        "passRate": "44.69%",
        "problemsUrl": "https://leetcode.cn/problems/EJvmW4/",
        "solutionsUrl": "https://leetcode.cn/problems/EJvmW4/solution",
        "problemsDesc": "各位勇者请注意，力扣太空城发布陨石雨红色预警。\n\n太空城中的一些舱室将要受到陨石雨的冲击，这些舱室按照编号 `0 ~ N` 的顺序依次排列。为了阻挡陨石损毁舱室，太空城可以使用能量展开防护屏障，具体消耗如下：\n\n- 选择一个舱室开启屏障，能量消耗为 `2` \n- 选择相邻两个舱室开启联合屏障，能量消耗为 `3`\n- 对于已开启的**一个**屏障，**多维持一时刻**，能量消耗为 `1`\n\n已知陨石雨的影响范围和到达时刻，`time[i]` 和 `position[i]` 分别表示该陨石的到达时刻和冲击位置。请返回太空舱能够守护所有舱室所需要的最少能量。\n\n**注意：** \n- 同一时间，一个舱室不能被多个屏障覆盖\n- 陨石雨仅在到达时刻对冲击位置处的舱室有影响\n\n\n**示例 1：**\n>输入：`time = [1,2,1], position = [6,3,3]`\n>\n>输出：`5`\n>\n>解释：\n> 时刻 1，分别开启编号 3、6 舱室的屏障，能量消耗 2*2 = 4\n> 时刻 2，维持编号 3 舱室的屏障，能量消耗 1\n> 因此，最少需要能量 5\n\n**示例 2：**\n>输入：`time = [1,1,1,2,2,3,5], position = [1,2,3,1,2,1,3]`\n>\n>输出：`9`\n>\n>解释：\n> 时刻 1，开启编号 1、2 舱室的联合屏障，能量消耗 3\n> 时刻 1，开启编号 3 舱室的屏障，能量消耗 2\n> 时刻 2，维持编号 1、2 舱室的联合屏障，能量消耗 1\n> 时刻 3，维持编号 1、2 舱室的联合屏障，能量消耗 1\n> 时刻 5，重新开启编号 3 舱室的联合屏障，能量消耗 2\n> 因此，最少需要能量 9\n\n**提示：**\n+ `1 <= time.length == position.length <= 500`\n+ `1 <= time[i] <= 5`\n+ `0 <= position[i] <= 100`\n",
        "isPlus": false
    },
    {
        "problemsName": " 2817夺回据点",
        "hardRate": "HARD",
        "passRate": "40.91%",
        "problemsUrl": "https://leetcode.cn/problems/s5kipK/",
        "solutionsUrl": "https://leetcode.cn/problems/s5kipK/solution",
        "problemsDesc": "欢迎各位勇者来到力扣城，本次试炼主题为「夺回据点」。\n\n魔物了占领若干据点，这些据点被若干条道路相连接，`roads[i] = [x, y]` 表示编号 `x`、`y` 的两个据点通过一条道路连接。\n\n现在勇者要将按照以下原则将这些据点逐一夺回：\n\n- 在开始的时候，勇者可以花费资源先夺回一些据点，初始夺回第 `j` 个据点所需消耗的资源数量为 `cost[j]` \n\n- 接下来，勇者在不消耗资源情况下，每次可以夺回**一个**和「已夺回据点」相连接的魔物据点，并对其进行夺回\n\n> 注：为了防止魔物暴动，勇者在每一次夺回据点后（包括花费资源夺回据点后），需要保证剩余的所有魔物据点之间是相连通的（不经过「已夺回据点」）。\n\n请返回勇者夺回所有据点需要消耗的最少资源数量。\n\n**注意：**\n- 输入保证初始所有据点都是连通的，且不存在重边和自环\n\n**示例 1：**\n>输入：\n>`cost = [1,2,3,4,5,6]`\n>`roads = [[0,1],[0,2],[1,3],[2,3],[1,2],[2,4],[2,5]]`\n>\n>输出：`6`\n>\n>解释：\n>勇者消耗资源 `6` 夺回据点 `0` 和 `4`，魔物据点 `1、2、3、5` 相连通；\n>第一次夺回据点 `1`，魔物据点 `2、3、5` 相连通；\n>第二次夺回据点 `3`，魔物据点 `2、5` 相连通；\n>第三次夺回据点 `2`，剩余魔物据点 `5`；\n>第四次夺回据点 `5`，无剩余魔物据点；\n>因此最少需要消耗资源为 `6`，可占领所有据点。\n![image.png](https://pic.leetcode-cn.com/1648706944-KJstUN-image.png){:height=170px}\n\n\n**示例 2：**\n>输入：\n>`cost = [3,2,1,4]`\n>`roads = [[0,2],[2,3],[3,1]]`\n>\n>输出：`2`\n>\n>解释：\n>勇者消耗资源 `2` 夺回据点 `1`，魔物据点 `0、2、3` 相连通；\n>第一次夺回据点 `3`，魔物据点 `2、0` 相连通；\n>第二次夺回据点 `2`，剩余魔物据点 `0`；\n>第三次夺回据点 `0`，无剩余魔物据点；\n>因此最少需要消耗资源为 `2`，可占领所有据点。\n![image.png](https://pic.leetcode-cn.com/1648707186-LJRwzU-image.png){:height=60px}\n\n\n**提示：**\n- `1 <= roads.length, cost.length <= 10^5`\n- `0 <= roads[i][0], roads[i][1] < cost.length`\n- `1 <= cost[i] <= 10^9`\n",
        "isPlus": false
    },
    {
        "problemsName": " 2818采集果实",
        "hardRate": "EASY",
        "passRate": "73.63%",
        "problemsUrl": "https://leetcode.cn/problems/PTXy4P/",
        "solutionsUrl": "https://leetcode.cn/problems/PTXy4P/solution",
        "problemsDesc": "欢迎各位勇者来到力扣新手村，本次训练内容为「采集果实」。\n\n在新手村中，各位勇者需要采集一些果实来制作药剂。`time[i]` 表示勇者每次采集 `1～limit` 颗第 `i` 种类型的果实需要的时间（即每次最多可以采集 `limit` 颗果实）。\n\n当前勇者需要完成「采集若干批果实」的任务， `fruits[j] = [type, num]` 表示第 `j` 批需要采集 `num` 颗 `type` 类型的果实。采集规则如下：\n- 按 `fruits` 给定的顺序**依次**采集每一批次\n- 采集完当前批次的果实才能开始采集下一批次\n- 勇者完成当前批次的采集后将**清空背包**（即多余的果实将清空）\n\n请计算并返回勇者完成采集任务最少需要的时间。\n\n\n**示例 1：**\n>输入：`time = [2,3,2], fruits = [[0,2],[1,4],[2,1]], limit = 3`\n>\n>输出：`10`\n>\n>解释：\n>由于单次最多采集 3 颗\n>第 0 批需要采集 2 颗第 0 类型果实，需要采集 1 次，耗时为 2\\*1=2\n>第 1 批需要采集 4 颗第 1 类型果实，需要采集 2 次，耗时为 3\\*2=6\n>第 2 批需要采集 1 颗第 2 类型果实，需要采集 1 次，耗时为 2\\*1=2\n>返回总耗时 2+6+2=10\n\n**示例 2：**\n>输入：`time = [1], fruits = [[0,3],[0,5]], limit = 2`\n>\n>输出：`5`\n>\n>解释：\n>由于单次最多采集 2 颗\n>第 0 批需要采集 3 颗第 0 类型果实，需要采集 2 次，耗时为 1\\*2=2\n>第 1 批需要采集 5 颗第 0 类型果实，需要采集 3 次，耗时为 1\\*3=3\n>需按照顺序依次采集，返回 2+3=5\n\n**提示：**\n- `1 <= time.length <= 100`\n- `1 <= time[i] <= 100`\n- `1 <= fruits.length <= 10^3`\n- `0 <= fruits[i][0] < time.length`\n- `1 <= fruits[i][1] < 10^3`\n- `1 <= limit <= 100`",
        "isPlus": false
    },
    {
        "problemsName": " 2819信物传送",
        "hardRate": "MEDIUM",
        "passRate": "43.69%",
        "problemsUrl": "https://leetcode.cn/problems/6UEx57/",
        "solutionsUrl": "https://leetcode.cn/problems/6UEx57/solution",
        "problemsDesc": "欢迎各位勇者来到力扣城，本次试炼主题为「信物传送」。\n\n本次试炼场地设有若干传送带，`matrix[i][j]` 表示第 `i` 行 `j` 列的传送带运作方向，`\"^\",\"v\",\"<\",\">\"` 这四种符号分别表示 **上、下、左、右** 四个方向。信物会随传送带的方向移动。勇者**每一次**施法操作，可**临时**变更一处传送带的方向，在物品经过后传送带恢复原方向。\n![lcp (2).gif](https://pic.leetcode-cn.com/1649835246-vfupSL-lcp%20\\(2\\).gif){:width=300px}\n\n通关信物初始位于坐标 `start`处，勇者需要将其移动到坐标 `end` 处，请返回勇者施法操作的最少次数。\n\n\n\n**注意：**\n- `start` 和 `end` 的格式均为 `[i,j]`\n\n**示例 1:**\n> 输入：`matrix = [\">>v\",\"v^<\",\"<><\"], start = [0,1], end = [2,0]`\n>\n> 输出：`1`\n>\n> 解释：\n> 如上图所示\n> 当信物移动到 `[1,1]` 时，勇者施法一次将 `[1,1]` 的传送方向 `^` 从变更为 `<`\n> 从而信物移动到 `[1,0]`，后续到达 `end` 位置\n> 因此勇者最少需要施法操作 1 次\n\n**示例 2:**\n> 输入：`matrix = [\">>v\",\">>v\",\"^<<\"], start = [0,0], end = [1,1]`\n>\n> 输出：`0`\n>\n> 解释：勇者无需施法，信物将自动传送至 `end` 位置\n\n**示例 3:**\n> 输入：`matrix = [\">^^>\",\"<^v>\",\"^v^<\"], start = [0,0], end = [1,3]`\n>\n> 输出：`3`\n\n**提示：**\n- `matrix` 中仅包含 `'^'、'v'、'<'、'>'`\n- `0 < matrix.length <= 100`\n- `0 < matrix[i].length <= 100`\n- `0 <= start[0],end[0] < matrix.length`\n- `0 <= start[1],end[1] < matrix[i].length`\n\n",
        "isPlus": false
    },
    {
        "problemsName": " 2820打地鼠",
        "hardRate": "HARD",
        "passRate": "27.23%",
        "problemsUrl": "https://leetcode.cn/problems/ZbAuEH/",
        "solutionsUrl": "https://leetcode.cn/problems/ZbAuEH/solution",
        "problemsDesc": "欢迎各位勇者来到力扣城，本次试炼主题为「打地鼠」。\n![middle_img_v2_d5d09656-0616-4a80-845e-ece461c5ba9g.png](https://pic.leetcode-cn.com/1650273183-nZIijm-middle_img_v2_d5d09656-0616-4a80-845e-ece461c5ba9g.png){:height=\"200px\"}\n勇者面前有一个大小为 `3*3` 的打地鼠游戏机，地鼠将随机出现在各个位置，`moles[i] = [t,x,y]` 表示在第 `t` 秒会有地鼠出现在 `(x,y)` 位置上，并于第 `t+1` 秒该地鼠消失。\n\n勇者有一把可敲打地鼠的锤子，初始时刻（即第 `0` 秒）锤子位于正中间的格子 `(1,1)`，锤子的使用规则如下：\n- 锤子每经过 `1` 秒可以往上、下、左、右中的一个方向移动一格，也可以不移动\n- 锤子只可敲击所在格子的地鼠，**敲击不耗时**\n\n请返回勇者**最多**能够敲击多少只地鼠。\n\n**注意：** \n- 输入用例保证在相同时间相同位置最多仅有一只地鼠\n\n\n**示例 1：**\n>输入： `moles = [[1,1,0],[2,0,1],[4,2,2]]`\n>\n>输出： `2`\n>\n>解释：\n>第 0 秒，锤子位于 (1,1)\n>第 1 秒，锤子移动至 (1,0) 并敲击地鼠\n>第 2 秒，锤子移动至 (2,0)\n>第 3 秒，锤子移动至 (2,1)\n>第 4 秒，锤子移动至 (2,2) 并敲击地鼠\n>因此勇者最多可敲击 2 只地鼠\n\n\n**示例 2：**\n>输入：`moles = [[2,0,2],[5,2,0],[4,1,0],[1,2,1],[3,0,2]]`\n>\n>输出：`3`\n>\n>解释：\n>第 0 秒，锤子位于 (1,1)\n>第 1 秒，锤子移动至 (2,1) 并敲击地鼠\n>第 2 秒，锤子移动至 (1,1)\n>第 3 秒，锤子移动至 (1,0)\n>第 4 秒，锤子在 (1,0) 不移动并敲击地鼠\n>第 5 秒，锤子移动至 (2,0) 并敲击地鼠\n>因此勇者最多可敲击 3 只地鼠\n\n\n**示例 3：**\n>输入：`moles = [[0,1,0],[0,0,1]]`\n>\n>输出：`0`\n>\n>解释：\n>第 0 秒，锤子初始位于 (1,1)，此时并不能敲击 (1,0)、(0,1) 位置处的地鼠\n\n\n**提示：**\n+ `1 <= moles.length <= 10^5`\n+ `moles[i].length == 3`\n+ `0 <= moles[i][0] <= 10^9`\n+ `0 <= moles[i][1], moles[i][2] < 3`\n",
        "isPlus": false
    },
    {
        "problemsName": " 2821积木拼接",
        "hardRate": "HARD",
        "passRate": "35.36%",
        "problemsUrl": "https://leetcode.cn/problems/De4qBB/",
        "solutionsUrl": "https://leetcode.cn/problems/De4qBB/solution",
        "problemsDesc": "欢迎各位勇者来到力扣城，本次试炼主题为「积木拼接」。\n勇者面前有 `6` 片积木（厚度均为 1），每片积木的形状记录于二维字符串数组 `shapes` 中，`shapes[i]` 表示第 `i` 片积木，其中 `1` 表示积木对应位置无空缺，`0` 表示积木对应位置有空缺。\n例如 `[\"010\",\"111\",\"010\"]` 对应积木形状为\n![image.png](https://pic.leetcode-cn.com/1616125620-nXMCxX-image.png)\n\n拼接积木的规则如下：\n- 积木片可以旋转、翻面\n- 积木片边缘必须完全吻合才能拼接在一起\n- **每片积木片 `shapes[i]` 的中心点在拼接时必须处于正方体对应面的中心点**\n\n例如 `3*3`、`4*4` 的积木片的中心点如图所示（红色点）：\n![middle_img_v2_c2d91eb5-9beb-4c06-9726-f7dae149d86g.png](https://pic.leetcode-cn.com/1650509082-wObiEp-middle_img_v2_c2d91eb5-9beb-4c06-9726-f7dae149d86g.png){:height=\"150px\"}\n\n\n请返回这 6 片积木能否拼接成一个**严丝合缝的正方体**且每片积木正好对应正方体的一个面。\n\n**注意：**\n- 输入确保每片积木均无空心情况（即输入数据保证对于大小 `N*N` 的 `shapes[i]`，内部的 `(N-2)*(N-2)` 的区域必然均为 1）\n- 输入确保每片积木的所有 `1` 位置均连通\n\n**示例 1：**\n>输入：`shapes = [[\"000\",\"110\",\"000\"],[\"110\",\"011\",\"000\"],[\"110\",\"011\",\"110\"],[\"000\",\"010\",\"111\"],[\"011\",\"111\",\"011\"],[\"011\",\"010\",\"000\"]]`\n>\n>输出：`true`\n>\n>解释：\n![cube.gif](https://pic.leetcode-cn.com/1616125823-hkXAeN-cube.gif)\n\n**示例 2：**\n>输入：`shapes = [[\"101\",\"111\",\"000\"],[\"000\",\"010\",\"111\"],[\"010\",\"011\",\"000\"],[\"010\",\"111\",\"010\"],[\"101\",\"111\",\"010\"],[\"000\",\"010\",\"011\"]]`\n>\n>输出：`false`\n>\n>解释： \n>由于每片积木片的中心点在拼接时必须处于正方体对应面的中心点，积木片 `[\"010\",\"011\",\"000\"]` 不能作为 `[\"100\",\"110\",\"000\"]` 使用，因此无法构成正方体\n\n\n**提示：**\n- `shapes.length == 6`\n- `shapes[i].length == shapes[j].length`\n- `shapes[i].length == shapes[i][j].length`\n- `3 <= shapes[i].length <= 10`\n\n\n\n\n\n",
        "isPlus": false
    },
    {
        "problemsName": " 2822搭桥过河",
        "hardRate": "HARD",
        "passRate": "36.06%",
        "problemsUrl": "https://leetcode.cn/problems/NfY1m5/",
        "solutionsUrl": "https://leetcode.cn/problems/NfY1m5/solution",
        "problemsDesc": "欢迎各位勇者来到力扣城，本次试炼主题为「搭桥过河」。\n\n勇者面前有一段长度为 `num` 的河流，河流可以划分为若干河道。每条河道上恰有一块浮木，`wood[i]` 记录了第 `i` 条河道上的浮木初始的覆盖范围。\n\n- 当且仅当浮木与相邻河道的浮木覆盖范围有重叠时，勇者才可以在两条浮木间移动\n- 勇者 **仅能在岸上** 通过花费一点「自然之力」，使任意一条浮木沿着河流移动一个单位距离\n\n请问勇者跨越这条河流，最少需要花费多少「自然之力」。\n\n\n**示例 1：**\n> 输入： `num = 10, wood = [[1,2],[4,7],[8,9]]`\n> 输出： `3`\n> 解释：如下图所示，\n> 将 [1,2] 浮木移动至 [3,4]，花费 2「自然之力」，\n> 将 [8,9] 浮木移动至 [7,8]，花费 1「自然之力」，\n> 此时勇者可以顺着 [3,4]->[4,7]->[7,8] 跨越河流，\n> 因此，勇者最少需要花费 3 点「自然之力」跨越这条河流\n![wood (2).gif](https://pic.leetcode-cn.com/1648196478-ophADL-wood%20\\(2\\).gif){:width=650px}\n\n\n**示例 2：**\n> 输入： `num = 10, wood = [[1,5],[1,1],[10,10],[6,7],[7,8]]`\n> 输出： `10`\n> 解释：\n> 将 [1,5] 浮木移动至 [2,6]，花费 1「自然之力」，\n> 将 [1,1] 浮木移动至 [6,6]，花费 5「自然之力」，\n> 将 [10,10] 浮木移动至 [6,6]，花费 4「自然之力」，\n> 此时勇者可以顺着 [2,6]->[6,6]->[6,6]->[6,7]->[7,8] 跨越河流，\n> 因此，勇者最少需要花费 10 点「自然之力」跨越这条河流\n\n\n**示例 3：**\n> 输入： `num = 5, wood = [[1,2],[2,4]]`\n> 输出： `0`\n> 解释：勇者不需要移动浮木，仍可以跨越这条河流\n\n**提示:**\n- `1 <= num <= 10^9`\n- `1 <= wood.length <= 10^5`\n- `wood[i].length == 2`\n- `1 <= wood[i][0] <= wood[i][1] <= num`\n\n",
        "isPlus": false
    },
    {
        "problemsName": " 2823力扣泡泡龙",
        "hardRate": "HARD",
        "passRate": "20.05%",
        "problemsUrl": "https://leetcode.cn/problems/WInSav/",
        "solutionsUrl": "https://leetcode.cn/problems/WInSav/solution",
        "problemsDesc": "欢迎各位勇者来到力扣城，本次试炼主题为「力扣泡泡龙」。\n\n游戏初始状态的泡泡形如二叉树 `root`，每个节点值对应了该泡泡的分值。勇者最多可以击破一个节点泡泡，要求满足：\n- 被击破的节点泡泡 **至多** 只有一个子节点泡泡\n- 当被击破的节点泡泡有子节点泡泡时，则子节点泡泡将取代被击破泡泡的位置\n    > 注：即整棵子树泡泡上移\n\n请问在击破一个节点泡泡操作或无击破操作后，二叉泡泡树的最大「层和」是多少。\n\n**注意：**\n- 「层和」为同一高度的所有节点的分值之和\n\n**示例 1：**\n> 输入：`root = [6,0,3,null,8]`\n>\n> 输出：`11`\n>\n> 解释：勇者的最佳方案如图所示\n>![image.png](https://pic.leetcode-cn.com/1648180809-XSWPLu-image.png){:height=\"100px\"}\n\n\n\n**示例 2：**\n> 输入：`root = [5,6,2,4,null,null,1,3,5]`\n>\n> 输出：`9`\n>\n> 解释：勇者击破 6 节点，此时「层和」最大为 3+5+1 = 9\n>![image.png](https://pic.leetcode-cn.com/1648180769-TLpYop-image.png){:height=\"200px\"}\n\n\n\n**示例 3：**\n> 输入：`root = [-5,1,7]`\n>\n> 输出：`8`\n>\n> 解释：勇者不击破节点，「层和」最大为 1+7 = 8\n\n\n**提示**：\n- `2 <= 树中节点个数 <= 10^5`\n- `-10000 <= 树中节点的值 <= 10000`\n",
        "isPlus": false
    },
    {
        "problemsName": " 2824气温变化趋势",
        "hardRate": "EASY",
        "passRate": "61.37%",
        "problemsUrl": "https://leetcode.cn/problems/6CE719/",
        "solutionsUrl": "https://leetcode.cn/problems/6CE719/solution",
        "problemsDesc": "力扣城计划在两地设立「力扣嘉年华」的分会场，气象小组正在分析两地区的气温变化趋势，对于第 `i ~ (i+1)` 天的气温变化趋势，将根据以下规则判断：\n- 若第 `i+1` 天的气温 **高于** 第 `i` 天，为 **上升** 趋势\n- 若第 `i+1` 天的气温 **等于** 第 `i` 天，为 **平稳** 趋势\n- 若第 `i+1` 天的气温 **低于** 第 `i` 天，为 **下降** 趋势\n\n已知 `temperatureA[i]` 和 `temperatureB[i]` 分别表示第 `i` 天两地区的气温。\n组委会希望找到一段天数尽可能多，且两地气温变化趋势相同的时间举办嘉年华活动。请分析并返回两地气温变化趋势**相同的最大连续天数**。\n> 即最大的 `n`，使得第 `i~i+n` 天之间，两地气温变化趋势相同\n\n**示例 1：**\n>输入：\n>`temperatureA = [21,18,18,18,31]`\n>`temperatureB = [34,32,16,16,17]`\n>\n>输出：`2`\n>\n>解释：如下表所示， 第 `2～4` 天两地气温变化趋势相同，且持续时间最长，因此返回 `4-2=2`\n![image.png](https://pic.leetcode-cn.com/1663902654-hlrSvs-image.png){:width=1000px}\n\n\n**示例 2：**\n>输入：\n>`temperatureA = [5,10,16,-6,15,11,3]`\n>`temperatureB = [16,22,23,23,25,3,-16]`\n>\n>输出：`3`\n\n**提示：**\n- `2 <= temperatureA.length == temperatureB.length <= 1000`\n- `-20 <= temperatureA[i], temperatureB[i] <= 40`\n",
        "isPlus": false
    },
    {
        "problemsName": " 2825交通枢纽",
        "hardRate": "MEDIUM",
        "passRate": "62.48%",
        "problemsUrl": "https://leetcode.cn/problems/D9PW8w/",
        "solutionsUrl": "https://leetcode.cn/problems/D9PW8w/solution",
        "problemsDesc": "为了缓解「力扣嘉年华」期间的人流压力，组委会在活动期间开设了一些交通专线。`path[i] = [a, b]` 表示有一条从地点 `a`通往地点 `b` 的 **单向** 交通专线。\n若存在一个地点，满足以下要求，我们则称之为 **交通枢纽**：\n- 所有地点（除自身外）均有一条 **单向** 专线 **直接** 通往该地点；\n- 该地点不存在任何 **通往其他地点** 的单向专线。\n\n请返回交通专线的 **交通枢纽**。若不存在，则返回 `-1`。\n\n**注意：**\n- 对于任意一个地点，至少被一条专线连通。\n\n**示例 1：**\n>输入：`path = [[0,1],[0,3],[1,3],[2,0],[2,3]]`\n>\n>输出：`3`\n>\n>解释：如下图所示：\n> 地点 `0,1,2` 各有一条通往地点 `3` 的交通专线，\n> 且地点 `3` 不存在任何**通往其他地点**的交通专线。\n>![image.png](https://pic.leetcode-cn.com/1663902572-yOlUCr-image.png){:width=200px}\n\n\n**示例 2：**\n>输入：`path = [[0,3],[1,0],[1,3],[2,0],[3,0],[3,2]]`\n>\n>输出：`-1`\n>\n>解释：如下图所示：不存在满足 **交通枢纽** 的地点。\n>![image.png](https://pic.leetcode-cn.com/1663902595-McsEkY-image.png){:width=200px}\n\n**提示：**\n- `1 <= path.length <= 1000`\n- `0 <= path[i][0], path[i][1] <= 1000`\n- `path[i][0]` 与 `path[i][1]` 不相等",
        "isPlus": false
    },
    {
        "problemsName": " 2826弹珠游戏",
        "hardRate": "MEDIUM",
        "passRate": "26.54%",
        "problemsUrl": "https://leetcode.cn/problems/EXvqDp/",
        "solutionsUrl": "https://leetcode.cn/problems/EXvqDp/solution",
        "problemsDesc": "欢迎各位来到「力扣嘉年华」，接下来将为各位介绍在活动中广受好评的弹珠游戏。\n\n`N*M` 大小的弹珠盘的初始状态信息记录于一维字符串型数组 `plate` 中，数组中的每个元素为仅由 `\"O\"`、`\"W\"`、`\"E\"`、`\".\"` 组成的字符串。其中：\n- `\"O\"` 表示弹珠洞（弹珠到达后会落入洞中，并停止前进）；\n- `\"W\"` 表示逆时针转向器（弹珠经过时方向将逆时针旋转 90 度）；\n- `\"E\"` 表示顺时针转向器（弹珠经过时方向将顺时针旋转 90 度）；\n- `\".\"` 表示空白区域（弹珠可通行）。\n\n游戏规则要求仅能在边缘位置的 **空白区域** 处（弹珠盘的四角除外）沿 **与边缘垂直** 的方向打入弹珠，并且打入后的每颗弹珠最多能 **前进** `num` 步。请返回符合上述要求且可以使弹珠最终入洞的所有打入位置。你可以 **按任意顺序** 返回答案。\n\n**注意：**\n- 若弹珠已到达弹珠盘边缘并且仍沿着出界方向继续前进，则将直接出界。\n\n**示例 1：**\n> 输入\b：\n>`num = 4`\n>`plate = [\"..E.\",\".EOW\",\"..W.\"]`\n> \n> 输出：`[[2,1]]`\n> \n> 解释：\n> 在 `[2,1]` 处打入弹珠，弹珠前进 1 步后遇到转向器，前进方向顺时针旋转 90 度，再前进 1 步进入洞中。\n![b054955158a99167b8d51da0e22a54da.gif](https://pic.leetcode-cn.com/1630392649-BoQncz-b054955158a99167b8d51da0e22a54da.gif){:width=\"300px\"}\n\n**示例 2：**\n> 输入\b：\n>`num = 5`\n>`plate = [\".....\",\"..E..\",\".WO..\",\".....\"]`\n> \n> 输出：`[[0,1],[1,0],[2,4],[3,2]]`\n> \n> 解释：\n> 在 `[0,1]` 处打入弹珠，弹珠前进 2 步，遇到转向器后前进方向逆时针旋转 90 度，再前进 1 步进入洞中。\n> 在 `[1,0]` 处打入弹珠，弹珠前进 2 步，遇到转向器后前进方向顺时针旋转 90 度，再前进 1 步进入洞中。\n> 在 `[2,4]` 处打入弹珠，弹珠前进 2 步后进入洞中。\n> 在 `[3,2]` 处打入弹珠，弹珠前进 1 步后进入洞中。\n![b44e9963239ae368badf3d00b7563087.gif](https://pic.leetcode-cn.com/1630392625-rckbdy-b44e9963239ae368badf3d00b7563087.gif){:width=\"350px\"}\n\n\n**示例 3：**\n> 输入\b：\n>`num = 3`\n>`plate = [\".....\",\"....O\",\"....O\",\".....\"]`\n> \n> 输出：`[]`\n> \n> 解释：\n> 由于弹珠被击中后只能前进 3 步，且不能在弹珠洞和弹珠盘四角打入弹珠，故不存在能让弹珠入洞的打入位置。\n\n\n**提示：**\n- `1 <= num <= 10^6`\n- `1 <= plate.length, plate[i].length <= 1000`\n- `plate[i][j]` 仅包含 `\"O\"`、`\"W\"`、`\"E\"`、`\".\"` ",
        "isPlus": false
    },
    {
        "problemsName": " 2827二叉树灯饰",
        "hardRate": "MEDIUM",
        "passRate": "35.73%",
        "problemsUrl": "https://leetcode.cn/problems/U7WvvU/",
        "solutionsUrl": "https://leetcode.cn/problems/U7WvvU/solution",
        "problemsDesc": "「力扣嘉年华」的中心广场放置了一个巨型的二叉树形状的装饰树。每个节点上均有一盏灯和三个开关。节点值为 `0` 表示灯处于「关闭」状态，节点值为 `1` 表示灯处于「开启」状态。每个节点上的三个开关各自功能如下：\n- 开关 `1`：切换当前节点的灯的状态；\n- 开关 `2`：切换 **以当前节点为根** 的子树中，所有节点上的灯的状态，；\n- 开关 `3`：切换 **当前节点及其左右子节点**（若存在的话） 上的灯的状态；\n\n给定该装饰的初始状态 `root`，请返回最少需要操作多少次开关，可以关闭所有节点的灯。\n\n**示例 1：**\n>输入：`root = [1,1,0,null,null,null,1]`\n>\n>输出：`2`\n>\n>解释：以下是最佳的方案之一，如图所示\n![b71b95bf405e3b223e00b2820a062ba4.gif](https://pic.leetcode-cn.com/1629357030-GSbzpY-b71b95bf405e3b223e00b2820a062ba4.gif){:width=\"300px\"}\n\n**示例 2：**\n>输入：`root = [1,1,1,1,null,null,1]`\n>\n>输出：`1`\n>\n>解释：以下是最佳的方案，如图所示\n![a4091b6448a0089b4d9e8f0390ff9ac6.gif](https://pic.leetcode-cn.com/1629356950-HZsKZC-a4091b6448a0089b4d9e8f0390ff9ac6.gif){:width=\"300px\"}\n\n**示例 3：**\n>输入：`root = [0,null,0]`\n>\n>输出：`0`\n>\n>解释：无需操作开关，当前所有节点上的灯均已关闭\n\n**提示：**\n- `1 <= 节点个数 <= 10^5`\n- `0 <= Node.val <= 1`",
        "isPlus": false
    },
    {
        "problemsName": " 2828舒适的湿度",
        "hardRate": "HARD",
        "passRate": "45.64%",
        "problemsUrl": "https://leetcode.cn/problems/3aqs1c/",
        "solutionsUrl": "https://leetcode.cn/problems/3aqs1c/solution",
        "problemsDesc": "力扣嘉年华为了确保更舒适的游览环境条件，在会场的各处设置了湿度调节装置，这些调节装置受控于总控室中的一台控制器。\n控制器中已经预设了一些调节指令，整数数组`operate[i]` 表示第 `i` 条指令增加空气湿度的大小。现在你可以将任意数量的指令修改为降低湿度（变化的数值不变），以确保湿度尽可能的适宜：\n- 控制器会选择 **一段连续的指令** ，从而进行湿度调节的操作；\n- 这段指令最终对湿度影响的绝对值，即为当前操作的「不适宜度」\n- 在控制器所有可能的操作中，**最大** 的「不适宜度」即为「整体不适宜度」\n\n请返回在所有修改指令的方案中，可以得到的 **最小** 「整体不适宜度」。\n\n**示例 1：**\n> 输入：`operate = [5,3,7]`\n>\n> 输出：`8`\n>\n> 解释：对于方案 `2` 的 `[5,3,-7]`\n>操作指令 `[5],[3],[-7]` 的「不适宜度」分别为 `5,3,7`\n>操作指令 `[5,3],[3,-7]` 的「不适宜度」分别为 `8,4`\n>操作指令 `[5,3,-7]` 的「不适宜度」为 `1`，\n>因此对于方案 `[5,3,-7]`的「整体不适宜度」为 `8`，其余方案的「整体不适宜度」均不小于 `8`，如下表所示：\n![image.png](https://pic.leetcode-cn.com/1663902759-dgDCxn-image.png){:width=650px}\n\n**示例 2：**\n> 输入：`operate = [20,10]`\n>\n> 输出：`20`\n\n**提示：**\n- `1 <= operate.length <= 1000`\n- `1 <= operate[i] <= 1000`",
        "isPlus": false
    },
    {
        "problemsName": " 2829最小展台数量",
        "hardRate": "EASY",
        "passRate": "77.58%",
        "problemsUrl": "https://leetcode.cn/problems/600YaG/",
        "solutionsUrl": "https://leetcode.cn/problems/600YaG/solution",
        "problemsDesc": "力扣嘉年华将举办一系列展览活动，后勤部将负责为每场展览提供所需要的展台。\n已知后勤部得到了一份需求清单，记录了近期展览所需要的展台类型， `demand[i][j]` 表示第 `i` 天展览时第 `j` 个展台的类型。\n在满足每一天展台需求的基础上，请返回后勤部需要准备的 **最小** 展台数量。\n\n**注意：**\n- 同一展台在不同天中可以重复使用。\n\n**示例 1：**\n>输入：`demand = [\"acd\",\"bed\",\"accd\"]`\n>\n>输出：`6`\n>\n>解释：\n>第 `0` 天需要展台 `a、c、d`；\n>第 `1` 天需要展台 `b、e、d`；\n>第 `2` 天需要展台 `a、c、c、d`；\n>因此，后勤部准备 `abccde` 的展台，可以满足每天的展览需求;\n\n**示例 2：**\n>输入：`demand = [\"abc\",\"ab\",\"ac\",\"b\"]`\n>\n>输出：`3`\n\n\n**提示：**\n- `1 <= demand.length,demand[i].length <= 100`\n- `demand[i][j]` 仅为小写字母",
        "isPlus": false
    },
    {
        "problemsName": " 2830装饰树",
        "hardRate": "MEDIUM",
        "passRate": "87.77%",
        "problemsUrl": "https://leetcode.cn/problems/KnLfVT/",
        "solutionsUrl": "https://leetcode.cn/problems/KnLfVT/solution",
        "problemsDesc": "力扣嘉年华上的 DIY 手工展位准备了一棵缩小版的 **二叉** 装饰树 `root` 和灯饰，你需要将灯饰逐一插入装饰树中，要求如下：\n\n- 完成装饰的二叉树根结点与 `root` 的根结点值相同\n- 若一个节点拥有父节点，则在该节点和他的父节点之间插入一个灯饰（即插入一个值为 `-1` 的节点）。具体地：\n    - 在一个 父节点 x 与其左子节点 y 之间添加 -1 节点， 节点 -1、节点 y 为各自父节点的左子节点，\n    - 在一个 父节点 x 与其右子节点 y 之间添加 -1 节点， 节点 -1、节点 y 为各自父节点的右子节点，\n    \n现给定二叉树的根节点 `root` ，请返回完成装饰后的树的根节点。\n**示例 1：**\n>输入：\n>`root = [7,5,6]`\n>\n>输出：`[7,-1,-1,5,null,null,6]`\n>\n>解释：如下图所示，\n>![image.png](https://pic.leetcode-cn.com/1663575757-yRLGaq-image.png){:width=400px}\n\n**示例 2：**\n>输入：\n>`root = [3,1,7,3,8,null,4]`\n>\n>输出：`[3,-1,-1,1,null,null,7,-1,-1,null,-1,3,null,null,8,null,4]`\n>\n>解释：如下图所示\n![image.png](https://pic.leetcode-cn.com/1663577920-sjrAYH-image.png){:width=500px}\n\n**提示：**\n>`0 <= root.Val <= 1000`\n>`root` 节点数量范围为 `[1, 10^5]`",
        "isPlus": false
    },
    {
        "problemsName": " 2831美观的花束",
        "hardRate": "MEDIUM",
        "passRate": "50.78%",
        "problemsUrl": "https://leetcode.cn/problems/1GxJYY/",
        "solutionsUrl": "https://leetcode.cn/problems/1GxJYY/solution",
        "problemsDesc": "力扣嘉年华的花店中从左至右摆放了一排鲜花，记录于整型一维矩阵 `flowers` 中每个数字表示该位置所种鲜花的品种编号。你可以选择一段区间的鲜花做成插花，且不能丢弃。\n在你选择的插花中，如果每一品种的鲜花数量都不超过 `cnt` 朵，那么我们认为这束插花是 「美观的」。\n> - 例如：`[5,5,5,6,6]` 中品种为 `5` 的花有 `3` 朵， 品种为 `6` 的花有 `2` 朵，**每一品种** 的数量均不超过 `3`\n\n请返回在这一排鲜花中，共有多少种可选择的区间，使得插花是「美观的」。\n\n**注意：**\n- 答案需要以 `1e9 + 7 (1000000007)` 为底取模，如：计算初始结果为：`1000000008`，请返回 `1`\n\n**示例 1：**\n>输入：`flowers = [1,2,3,2], cnt = 1`\n>\n>输出：`8`\n>\n>解释：相同的鲜花不超过 `1` 朵，共有 `8` 种花束是美观的；\n>长度为 `1` 的区间 `[1]、[2]、[3]、[2]` 均满足条件，共 `4` 种可选择区间\n>长度为 `2` 的区间 `[1,2]、[2,3]、[3,2]` 均满足条件，共 `3` 种可选择区间\n>长度为 `3` 的区间 `[1,2,3]` 满足条件，共 `1` 种可选择区间。\n>区间 `[2,3,2],[1,2,3,2]` 都包含了 `2` 朵鲜花 `2` ，不满足条件。\n>返回总数 `4+3+1 = 8`\n\n**示例 2：**\n>输入：`flowers = [5,3,3,3], cnt = 2`\n>\n>输出：`8`\n\n**提示：**\n- `1 <= flowers.length <= 10^5`\n- `1 <= flowers[i] <= 10^5`\n- `1 <= cnt <= 10^5`",
        "isPlus": false
    },
    {
        "problemsName": " 2832Hello LeetCode!",
        "hardRate": "HARD",
        "passRate": "33.96%",
        "problemsUrl": "https://leetcode.cn/problems/rMeRt2/",
        "solutionsUrl": "https://leetcode.cn/problems/rMeRt2/solution",
        "problemsDesc": "力扣嘉年华同样准备了纪念品展位，参观者只需要集齐 `helloleetcode` 的 `13` 张字母卡片即可获得力扣纪念章。\n\n在展位上有一些由字母卡片拼成的单词，`words[i][j]` 表示第 `i` 个单词的第 `j` 个字母。\n\n你可以从这些单词中取出一些卡片，但每次拿取卡片都需要消耗游戏代币，规则如下：\n\n- 从一个单词中取一个字母所需要的代币数量，为该字母左边和右边字母数量之积\n\n- 可以从一个单词中多次取字母，每个字母仅可被取一次\n\n> 例如：从 `example` 中取出字母 `a`，需要消耗代币 `2*4=8`，字母取出后单词变为 `exmple`；\n再从中取出字母 `m`，需要消耗代币 `2*3=6`，字母取出后单词变为 `exple`；\n\n请返回取得 `helloleetcode` 这些字母需要消耗代币的 **最少** 数量。如果无法取得，返回 `-1`。\n\n**注意：**\n- 取出字母的顺序没有要求\n- 取出的所有字母恰好可以拼成 `helloleetcode` \n\n**示例 1：**\n>输入：`words = [\"hold\",\"engineer\",\"cost\",\"level\"]`\n>\n>输出：`5`\n>\n>解释：最优方法为：\n>从 `hold` 依次取出 `h`、`o`、`l`、`d`， 代价均为 `0`\n>从 `engineer` 依次取出第 `1` 个 `e` 与最后一个 `e`， 代价为 `0` 和 `5*1=5`\n>从 `cost` 取出 `c`、`o`、`t`， 代价均为 `0`\n>从 `level` 依次取出 `l`、`l`、`e`、`e`， 代价均为 `0`\n>所有字母恰好可以拼成 `helloleetcode`，因此最小的代价为 `5`\n\n**示例 2：**\n>输入：`words = [\"hello\",\"leetcode\"]`\n>\n>输出：`0`\n\n**提示：**\n+ `n == words.length`\n+ `m == words[i].length`\n+ `1 <= n <= 24`\n+ `1 <= m <= 8`\n+ `words[i][j]` 仅为小写字母",
        "isPlus": false
    },
    {
        "problemsName": " 2833沙地治理",
        "hardRate": "HARD",
        "passRate": "27.84%",
        "problemsUrl": "https://leetcode.cn/problems/XxZZjK/",
        "solutionsUrl": "https://leetcode.cn/problems/XxZZjK/solution",
        "problemsDesc": "在力扣城的沙漠分会场展示了一种沙柳树，这种沙柳树能够将沙地转化为坚实的绿地。\n展示的区域为正三角形，这片区域可以拆分为若干个子区域，每个子区域都是边长为 `1` 的小三角形，其中第 `i` 行有 `2i - 1` 个小三角形。\n\n初始情况下，区域中的所有位置都为沙地，你需要指定一些子区域种植沙柳树成为绿地，以达到转化整片区域为绿地的最终目的，规则如下：\n- 若两个子区域共用一条边，则视为相邻；\n>如下图所示，(1,1)和(2,2)相邻，(3,2)和(3,3)相邻；(2,2)和(3,3)不相邻，因为它们没有共用边。\n- 若至少有两片绿地与同一片沙地相邻，则这片沙地也会转化为绿地\n- 转化为绿地的区域会影响其相邻的沙地\n![image.png](https://pic.leetcode-cn.com/1662692397-VlvErS-image.png)\n\n现要将一片边长为 `size` 的沙地全部转化为绿地，请找到任意一种初始指定 **最少** 数量子区域种植沙柳的方案，并返回所有初始种植沙柳树的绿地坐标。\n\n**示例 1：**\n>输入：`size = 3`\n>输出：`[[1,1],[2,1],[2,3],[3,1],[3,5]]`\n>解释：如下图所示，一种方案为：\n>指定所示的 5 个子区域为绿地。\n>相邻至少两片绿地的 (2,2)，(3,2) 和 (3,4) 演变为绿地。\n>相邻两片绿地的 (3,3) 演变为绿地。\n![image.png](https://pic.leetcode-cn.com/1662692503-ncjywh-image.png){:width=500px}\n\n\n**示例 2：**\n>输入：`size = 2`\n>输出：`[[1,1],[2,1],[2,3]]`\n>解释：如下图所示：\n>指定所示的 3 个子区域为绿地。\n>相邻三片绿地的 (2,2) 演变为绿地。\n![image.png](https://pic.leetcode-cn.com/1662692507-mgFXRj-image.png){:width=276px}\n\n\n\n**提示：**\n- `1 <= size <= 1000`",
        "isPlus": false
    },
    {
        "problemsName": " 2834集水器",
        "hardRate": "HARD",
        "passRate": "55.45%",
        "problemsUrl": "https://leetcode.cn/problems/kskhHQ/",
        "solutionsUrl": "https://leetcode.cn/problems/kskhHQ/solution",
        "problemsDesc": "字符串数组 `shape` 描述了一个二维平面中的矩阵形式的集水器，`shape[i][j]` 表示集水器的第 `i` 行 `j` 列为：\n- `'l'`表示向左倾斜的隔板（即从左上到右下）；\n- `'r'`表示向右倾斜的隔板（即从左下到右上）；\n- `'.'` 表示此位置没有隔板\n![image.png](https://pic.leetcode-cn.com/1664424667-wMnPja-image.png){:width=200px}\n\n已知当隔板构成存储容器可以存水，每个方格代表的蓄水量为 `2`。集水器初始浸泡在水中，除内部密闭空间外，所有位置均被水填满。\n现将其从水中竖直向上取出，请返回集水器最终的蓄水量。\n\n**注意：**\n- 隔板具有良好的透气性，因此空气可以穿过隔板，但水无法穿过\n\n**示例 1：**\n> 输入：\n> `shape = [\"....rl\",\"l.lr.r\",\".l..r.\",\"..lr..\"]`\n>\n> 输出：`18`\n>\n> 解释：如下图所示，由于空气会穿过隔板，因此红框区域没有水\n![image.png](https://pic.leetcode-cn.com/1664436239-eyYxeP-image.png){:width=\"280px\"}\n\n\n**示例 2：**\n> 输入：\n> `shape = [\".rlrlrlrl\",\"ll..rl..r\",\".llrrllrr\",\"..lr..lr.\"]`\n> 输出：`18`\n>\n> 解释：如图所示。由于红框右侧未闭合，因此多余的水会从该处流走。\n![image.png](https://pic.leetcode-cn.com/1664436082-SibVMv-image.png){:width=\"400px\"}\n\n\n**示例 3：**\n> 输入：\n> `shape = [\"rlrr\",\"llrl\",\"llr.\"]`\n> 输出：`6`\n>\n> 解释：如图所示。\n![image.png](https://pic.leetcode-cn.com/1664424855-dwpUHO-image.png){:width=\"230px\"}\n\n\n\n\n**示例 4：**\n> 输入：\n> `shape = [\"...rl...\",\"..r..l..\",\".r.rl.l.\",\"r.r..l.l\",\"l.l..rl.\",\".l.lr.r.\",\"..l..r..\",\"...lr...\"]`\n>\n> 输出：`30`\n>\n> 解释：如下图所示。由于中间为内部密闭空间，无法蓄水。\n![image.png](https://pic.leetcode-cn.com/1664424894-mClEXh-image.png){:width=\"350px\"}\n\n\n**提示**：\n- `1 <= shape.length <= 50`\n- `1 <= shape[i].length <= 50`\n- `shape[i][j]` 仅为 `'l'`、`'r'` 或 `'.'`\n",
        "isPlus": false
    },
    {
        "problemsName": " 2835补给马车",
        "hardRate": "EASY",
        "passRate": "69.65%",
        "problemsUrl": "https://leetcode.cn/problems/hqCnmP/",
        "solutionsUrl": "https://leetcode.cn/problems/hqCnmP/solution",
        "problemsDesc": "远征队即将开启未知的冒险之旅，不过在此之前，将对补给车队进行最后的检查。`supplies[i]` 表示编号为 `i` 的补给马车装载的物资数量。\n考虑到车队过长容易被野兽偷袭，他们决定将车队的长度变为原来的一半（向下取整），计划为：\n- 找出车队中 **物资之和最小** 两辆 **相邻** 马车，将它们车辆的物资整合为一辆。若存在多组物资之和相同的马车，则取编号最小的两辆马车进行整合；\n- 重复上述操作直到车队长度符合要求。\n\n请返回车队长度符合要求后，物资的分布情况。\n\n**示例 1：**\n>输入：`supplies = [7,3,6,1,8]`\n>\n>输出：`[10,15]`\n>\n>解释：\n> 第 1 次合并，符合条件的两辆马车为 6,1，合并后的车队为 [7,3,7,8]；\n> 第 2 次合并，符合条件的两辆马车为 (7,3) 和 (3,7)，取编号最小的 (7,3)，合并后的车队为 [10,7,8]；\n> 第 3 次合并，符合条件的两辆马车为 7,8，合并后的车队为 [10,15]；\n>返回 `[10,15]`\n\n**示例 2：**\n>输入：`supplies = [1,3,1,5]`\n>\n>输出：`[5,5]`\n\n**解释：**\n- `2 <= supplies.length <= 1000`\n- `1 <= supplies[i] <= 1000`",
        "isPlus": false
    },
    {
        "problemsName": " 2836探险营地",
        "hardRate": "MEDIUM",
        "passRate": "45.70%",
        "problemsUrl": "https://leetcode.cn/problems/0Zeoeg/",
        "solutionsUrl": "https://leetcode.cn/problems/0Zeoeg/solution",
        "problemsDesc": "探险家小扣的行动轨迹，都将保存在记录仪中。`expeditions[i]` 表示小扣第 `i` 次探险记录，用一个字符串数组表示。其中的每个「营地」由大小写字母组成，通过子串 `->` 连接。\n> 例：\"Leet->code->Campsite\"，表示到访了 \"Leet\"、\"code\"、\"Campsite\" 三个营地。\n\n`expeditions[0]` 包含了初始小扣已知的所有营地；对于之后的第 `i` 次探险(即 `expeditions[i]` 且 i > 0)，如果记录中包含了之前均没出现的营地，则表示小扣 **新发现** 的营地。\n\n请你找出小扣发现新营地最多且索引最小的那次探险，并返回对应的记录索引。如果所有探险记录都没有发现新的营地，返回 `-1`\n\n**注意：**\n- 大小写不同的营地视为不同的营地；\n- 营地的名称长度均大于 `0`。\n\n**示例 1：**\n>输入：`expeditions = [\"leet->code\",\"leet->code->Campsite->Leet\",\"leet->code->leet->courier\"]`\n>\n>输出：`1`\n>\n>解释：\n>初始已知的所有营地为 \"leet\" 和 \"code\"\n>第 1 次，到访了 \"leet\"、\"code\"、\"Campsite\"、\"Leet\"，新发现营地 2 处：\"Campsite\"、\"Leet\"\n>第 2 次，到访了 \"leet\"、\"code\"、\"courier\"，新发现营地 1 处：\"courier\"\n>第 1 次探险发现的新营地数量最多，因此返回 `1`\n\n**示例 2：**\n>输入：`expeditions = [\"Alice->Dex\",\"\",\"Dex\"]`\n>\n>输出：`-1`\n>\n>解释：\n>初始已知的所有营地为 \"Alice\" 和 \"Dex\"\n>第 1 次，未到访任何营地；\n>第 2 次，到访了 \"Dex\"，未新发现营地；\n>因为两次探险均未发现新的营地，返回 `-1`\n\n**示例 3：**\n>输入：`expeditions = [\"\",\"Gryffindor->Slytherin->Gryffindor\",\"Hogwarts->Hufflepuff->Ravenclaw\"]`\n>\n>输出：`2`\n>\n>解释：\n>初始未发现任何营地；\n>第 1 次，到访 \"Gryffindor\"、\"Slytherin\" 营地，其中重复到访 \"Gryffindor\" 两次，\n>因此新发现营地为 2 处：\"Gryffindor\"、\"Slytherin\"\n>第 2 次，到访 \"Hogwarts\"、\"Hufflepuff\"、\"Ravenclaw\" 营地；\n>新发现营地 3 处：\"Hogwarts\"、\"Hufflepuff\"、\"Ravenclaw\"；\n>第 2 次探险发现的新营地数量最多，因此返回 `2`\n\n**提示：**\n- `1 <= expeditions.length <= 1000`\n- `0 <= expeditions[i].length <= 1000`\n- 探险记录中只包含大小写字母和子串\"->\"",
        "isPlus": false
    },
    {
        "problemsName": " 2837最强祝福力场",
        "hardRate": "MEDIUM",
        "passRate": "28.99%",
        "problemsUrl": "https://leetcode.cn/problems/xepqZ5/",
        "solutionsUrl": "https://leetcode.cn/problems/xepqZ5/solution",
        "problemsDesc": "小扣在探索丛林的过程中，无意间发现了传说中“落寞的黄金之都”。而在这片建筑废墟的地带中，小扣使用探测仪监测到了存在某种带有「祝福」效果的力场。\n经过不断的勘测记录，小扣将所有力场的分布都记录了下来。`forceField[i] = [x,y,side]` 表示第 `i` 片力场将覆盖以坐标 `(x,y)` 为中心，边长为 `side` 的正方形区域。\n\n若任意一点的 **力场强度** 等于覆盖该点的力场数量，请求出在这片地带中 **力场强度** 最强处的 **力场强度**。\n\n**注意：** \n- 力场范围的边缘同样被力场覆盖。\n\n**示例 1：**\n>输入：\n>`forceField = [[0,0,1],[1,0,1]]`\n>\n>输出：`2`\n>\n>解释：如图所示，（0.5, 0) 处力场强度最强为 2， （0.5，-0.5）处力场强度同样是 2。\n![image.png](https://pic.leetcode.cn/1681805536-zGfghe-image.png){:width=400px}\n\n\n**示例 2：**\n>输入：\n>`forceField = [[4,4,6],[7,5,3],[1,6,2],[5,6,3]]`\n>\n>输出：`3`\n>\n>解释：如下图所示，\n>`forceField[0]、forceField[1]、forceField[3]` 重叠的区域力场强度最大，返回 `3`\n![image.png](https://pic.leetcode.cn/1681805437-HQkyZS-image.png){:width=500px}\n\n\n\n**提示：**\n- `1 <= forceField.length <= 100`\n- `forceField[i].length == 3`\n- `0 <= forceField[i][0], forceField[i][1] <= 10^9`\n- `1 <= forceField[i][2] <= 10^9`",
        "isPlus": false
    },
    {
        "problemsName": " 2838传送卷轴",
        "hardRate": "HARD",
        "passRate": "36.26%",
        "problemsUrl": "https://leetcode.cn/problems/rdmXM7/",
        "solutionsUrl": "https://leetcode.cn/problems/rdmXM7/solution",
        "problemsDesc": "随着不断的深入，小扣来到了守护者之森寻找的魔法水晶。首先，他必须先通过守护者的考验。\n\n考验的区域是一个正方形的迷宫，`maze[i][j]` 表示在迷宫 `i` 行 `j` 列的地形：\n- 若为 `.` ，表示可以到达的空地；\n- 若为 `#` ，表示不可到达的墙壁；\n- 若为 `S` ，表示小扣的初始位置；\n- 若为 `T` ，表示魔法水晶的位置。\n\n小扣每次可以向 上、下、左、右 相邻的位置移动一格。而守护者拥有一份「传送魔法卷轴」，使用规则如下：\n- 魔法需要在小扣位于 **空地** 时才能释放，发动后卷轴消失；；\n- 发动后，小扣会被传送到水平或者竖直的镜像位置，且目标位置不得为墙壁(如下图所示)；\n![image.png](https://pic.leetcode.cn/1681789509-wTekFu-image.png){:width=400px}\n\n在使用卷轴后，小扣将被「附加负面效果」，因此小扣需要尽可能缩短传送后到达魔法水晶的距离。而守护者的目标是阻止小扣到达魔法水晶的位置；如果无法阻止，则尽可能 **增加** 小扣传送后到达魔法水晶的距离。\n假设小扣和守护者都按最优策略行事，返回小扣需要在 「附加负面效果」的情况下 **最少** 移动多少次才能到达魔法水晶。如果无法到达，返回 `-1`。\n\n**注意：**\n- 守护者可以不使用卷轴；\n- 传送后的镜像位置可能与原位置相同。\n\n**示例 1：**\n>输入：`maze = [\".....\",\"##S..\",\"...#.\",\"T.#..\",\"###..\"]`\n>\n>输出：`7`\n>\n>解释：如下图所示：\n>守护者释放魔法的两个最佳的位置为 [2,0] 或 [3,1]：\n>若小扣经过 [2,0]，守护者在该位置释放魔法，\n>小扣被传送至 [2,4] 处且加上负面效果，此时小扣还需要移动 7 次才能到达魔法水晶；\n>若小扣经过 [3,1]，守护者在该位置释放魔法，\n>小扣被传送至 [3,3] 处且加上负面效果，此时小扣还需要移动 9 次才能到达魔法水晶；\n>因此小扣负面效果下最少需要移动 7 次才能到达魔法水晶。\n![image.png](https://pic.leetcode.cn/1681714676-gksEMT-image.png){:width=300px}\n\n\n**示例 2：**\n>输入：`maze = [\".#..\",\"..##\",\".#S.\",\".#.T\"]`\n>\n>输出：`-1`\n>\n>解释：如下图所示。\n>若小扣向下移动至 [3,2]，守护者使其传送至 [0,2]，小扣将无法到达魔法水晶；\n>若小扣向右移动至 [2,3]，守护者使其传送至 [2,0]，小扣将无法到达魔法水晶；\n![image.png](https://pic.leetcode.cn/1681714693-LsxKAh-image.png){:width=300px}\n\n\n**示例 3：**\n>输入：`maze = [\"S###.\",\"..###\",\"#..##\",\"##..#\",\"###.T\"]`\n>\n>输出：`5`\n>\n>解释：如下图所示：\n>守护者需要小扣在空地才能释放，因此初始无法将其从 [0,0] 传送至 [0,4];\n>当小扣移动至 [2,1] 时，释放卷轴将其传送至水平方向的镜像位置 [2,1]（为原位置）\n>而后小扣需要移动 5 次到达魔法水晶\n![image.png](https://pic.leetcode.cn/1681800985-KrSdru-image.png){:width=300px}\n\n**提示：**\n- `4 <= maze.length == maze[i].length <= 200`\n- `maze[i][j]` 仅包含 `\".\"`、`\"#\"`、`\"S\"`、`\"T\"`",
        "isPlus": false
    },
    {
        "problemsName": " 2839魔法棋盘",
        "hardRate": "HARD",
        "passRate": "36.93%",
        "problemsUrl": "https://leetcode.cn/problems/1ybDKD/",
        "solutionsUrl": "https://leetcode.cn/problems/1ybDKD/solution",
        "problemsDesc": "在大小为 `n * m` 的棋盘中，有两种不同的棋子：黑色，红色。当两颗颜色不同的棋子同时满足以下两种情况时，将会产生魔法共鸣：\n- 两颗异色棋子在同一行或者同一列\n- 两颗异色棋子之间恰好只有一颗棋子\n    > 注：异色棋子之间可以有空位\n\n由于棋盘上被施加了魔法禁制，棋盘上的部分格子变成问号。`chessboard[i][j]` 表示棋盘第 `i` 行 `j` 列的状态：\n- 若为 `.` ，表示当前格子确定为空\n- 若为 `B` ，表示当前格子确定为 黑棋\n- 若为 `R` ，表示当前格子确定为 红棋\n- 若为 `?` ，表示当前格子待定\n\n现在，探险家小扣的任务是确定所有问号位置的状态（留空/放黑棋/放红棋），使最终的棋盘上，任意两颗棋子间都 **无法** 产生共鸣。请返回可以满足上述条件的放置方案数量。\n\n**示例1：**\n> 输入：`n = 3, m = 3, chessboard = [\"..R\",\"..B\",\"?R?\"]`\n>\n> 输出：`5`\n>\n> 解释：给定的棋盘如图：\n>![image.png](https://pic.leetcode.cn/1681714583-unbRox-image.png){:height=150px}\n> 所有符合题意的最终局面如图：\n>![image.png](https://pic.leetcode.cn/1681714596-beaOHK-image.png){:height=150px}\n\n**示例2：**\n> 输入：`n = 3, m = 3, chessboard = [\"?R?\",\"B?B\",\"?R?\"]`\n>\n> 输出：`105`\n\n**提示：**\n- `n == chessboard.length`\n- `m == chessboard[i].length`\n- `1 <= n*m <= 30`\n- `chessboard` 中仅包含 `\".\"、\"B\"、\"R\"、\"?\"`",
        "isPlus": false
    },
    {
        "problemsName": " 2840符文储备",
        "hardRate": "EASY",
        "passRate": "71.98%",
        "problemsUrl": "https://leetcode.cn/problems/W2ZX4X/",
        "solutionsUrl": "https://leetcode.cn/problems/W2ZX4X/solution",
        "problemsDesc": "远征队在出发前需要携带一些「符文」，作为后续的冒险储备。`runes[i]` 表示第 `i` 枚符文的魔力值。\n\n他们将从中选取若干符文进行携带，并对这些符文进行重新排列，以确保任意相邻的两块符文之间的魔力值相差不超过 `1`。\n\n请返回他们能够携带的符文 **最大数量**。\n\n**示例 1：**\n>输入：`runes = [1,3,5,4,1,7]`\n>\n>输出：`3`\n>\n>解释：最佳的选择方案为[3,5,4]\n>将其排列为 [3,4,5] 后，任意相邻的两块符文魔力值均不超过 `1`，携带数量为 `3`\n>其他满足条件的方案为 [1,1] 和 [7]，数量均小于 3。\n>因此返回可携带的最大数量 `3`。\n\n**示例 2：**\n>输入：`runes = [1,1,3,3,2,4]`\n>\n>输出：`6`\n>\n>解释：排列为 [1,1,2,3,3,4]，可携带所有的符文\n\n**提示：**\n- `1 <= runes.length <= 10^4`\n- `0 <= runes[i] <= 10^4`\n",
        "isPlus": false
    },
    {
        "problemsName": " 2841城墙防线",
        "hardRate": "MEDIUM",
        "passRate": "45.36%",
        "problemsUrl": "https://leetcode.cn/problems/Nsibyl/",
        "solutionsUrl": "https://leetcode.cn/problems/Nsibyl/solution",
        "problemsDesc": "在探险营地间，小扣意外发现了一片城墙遗迹，在探索期间，却不巧遇到迁徙中的兽群向他迎面冲来。情急之下小扣吹响了他的苍蓝笛，随着笛声响起，遗迹中的城墙逐渐发生了横向膨胀。\n已知 `rampart[i] = [x,y]` 表示第 `i` 段城墙的初始所在区间。当城墙发生膨胀时，将遵循以下规则：\n- 所有的城墙会同时膨胀相等的长度；\n- 每个城墙可以向左、向右或向两个方向膨胀。\n\n小扣为了确保自身的安全，需要在所有城墙均无重叠的情况下，让城墙尽可能的膨胀。请返回城墙可以膨胀的 **最大值** 。\n\n**注意：**\n- 初始情况下，所有城墙均不重叠，且 `rampart` 中的元素升序排列；\n- 两侧的城墙可以向外无限膨胀。\n\n**示例 1：**\n>输入：`rampart = [[0,3],[4,5],[7,9]]`\n>\n>输出：`3`\n>\n>解释：如下图所示：\n>`rampart[0]` 向左侧膨胀 3 个单位；\n>`rampart[2]` 向右侧膨胀 3 个单位；\n>`rampart[1]` 向左侧膨胀 1 个单位，向右膨胀 2 个单位。\n>不存在膨胀更多的方案，返回 3。\n![image.png](https://pic.leetcode.cn/1681717918-tWywrp-image.png){:width=750px}\n\n**示例 2：**\n>输入：`rampart = [[1,2],[5,8],[11,15],[18,25]]`\n>\n>输出：`4`\n\n**提示：**\n- `3 <= rampart.length <= 10^4`\n- `rampart[i].length == 2`\n- `0 <= rampart[i][0] < rampart[i][1] <= rampart[i+1][0] <= 10^8`",
        "isPlus": false
    },
    {
        "problemsName": " 2842提取咒文",
        "hardRate": "MEDIUM",
        "passRate": "27.55%",
        "problemsUrl": "https://leetcode.cn/problems/kjpLFZ/",
        "solutionsUrl": "https://leetcode.cn/problems/kjpLFZ/solution",
        "problemsDesc": "随着兽群逐渐远去，一座大升降机缓缓的从地下升到了远征队面前。借由这台升降机，他们将能够到达地底的永恒至森。\n在升降机的操作台上，是一个由魔法符号组成的矩阵，为了便于辨识，我们用小写字母来表示。 `matrix[i][j]` 表示矩阵第 `i` 行 `j` 列的字母。该矩阵上有一个提取装置，可以对所在位置的字母提取。\n提取装置初始位于矩阵的左上角 `[0,0]`，可以通过每次操作移动到上、下、左、右相邻的 1 格位置中。提取装置每次移动或每次提取均记为一次操作。\n\n远征队需要按照顺序，从矩阵中逐一取出字母以组成 `mantra`，才能够成功的启动升降机。请返回他们 **最少** 需要消耗的操作次数。如果无法完成提取，返回 `-1`。\n\n**注意：**\n- 提取装置可对同一位置的字母重复提取，每次提取一个\n- 提取字母时，需按词语顺序依次提取\n\n**示例 1：**\n>输入：`matrix = [\"sd\",\"ep\"], mantra = \"speed\"`\n>\n>输出：`10`\n>\n>解释：如下图所示\n![矩阵 (2).gif](https://pic.leetcode-cn.com/1646288670-OTlvAl-%E7%9F%A9%E9%98%B5%20\\(2\\).gif)\n\n**示例 2：**\n>输入：`matrix = [\"abc\",\"daf\",\"geg\"]， mantra = \"sad\"`\n>\n>输出：`-1`\n>\n>解释：矩阵中不存在 `s` ，无法提取词语\n\n**提示：**\n- `0 < matrix.length, matrix[i].length <= 100`\n- `0 < mantra.length <= 100`\n- `matrix 和 mantra` 仅由小写字母组成",
        "isPlus": false
    },
    {
        "problemsName": " 2843生物进化录",
        "hardRate": "HARD",
        "passRate": "50.09%",
        "problemsUrl": "https://leetcode.cn/problems/qoQAMX/",
        "solutionsUrl": "https://leetcode.cn/problems/qoQAMX/solution",
        "problemsDesc": "在永恒之森中，存在着一本生物进化录，以 **一个树形结构** 记载了所有生物的演化过程。经过观察并整理了各节点间的关系，`parents[i]` 表示编号 `i` 节点的父节点编号(根节点的父节点为 `-1`)。\n\n为了探索和记录其中的演化规律，队伍中的炼金术师提出了一种方法，可以以字符串的形式将其复刻下来，规则如下：\n- 初始只有一个根节点，表示演化的起点，依次记录 `01` 字符串中的字符，\n- 如果记录 `0`，则在当前节点下添加一个子节点，并将指针指向新添加的子节点；\n- 如果记录 `1`，则将指针回退到当前节点的父节点处。\n\n现在需要应用上述的记录方法，复刻下它的演化过程。请返回能够复刻演化过程的字符串中， **字典序最小** 的 `01` 字符串。\n\n**注意：**\n- 节点指针最终可以停在任何节点上，不一定要回到根节点。\n\n**示例 1：**\n> 输入：`parents = [-1,0,0,2]`\n>\n> 输出：`\"00110\"`\n>\n>解释：树结构如下图所示，共存在 2 种记录方案：\n>第 1 种方案为：0(记录编号 1 的节点) -> 1(回退至节点 0) -> 0(记录编号 2 的节点) -> 0((记录编号 3 的节点))\n>第 2 种方案为：0(记录编号 2 的节点) -> 0(记录编号 3 的节点) -> 1(回退至节点 2) -> 1(回退至节点 0) -> 0(记录编号 1 的节点)\n>返回字典序更小的 `\"00110\"`\n![image.png](https://pic.leetcode.cn/1682319485-cRVudI-image.png){:width=120px}![进化 (3).gif](https://pic.leetcode.cn/1682412701-waHdnm-%E8%BF%9B%E5%8C%96%20\\(3\\).gif){:width=320px}\n\n\n\n**示例 2：**\n> 输入：`parents = [-1,0,0,1,2,2]`\n>\n> 输出：`\"00101100\"`\n\n**提示：**\n\n- `1 <= parents.length <= 10^4`\n- `-1 <= parents[i] < i` (即父节点编号小于子节点)",
        "isPlus": false
    },
    {
        "problemsName": " 2844与非的谜题",
        "hardRate": "HARD",
        "passRate": "47.69%",
        "problemsUrl": "https://leetcode.cn/problems/ryfUiz/",
        "solutionsUrl": "https://leetcode.cn/problems/ryfUiz/solution",
        "problemsDesc": "在永恒之森中，封存着有关万灵之树线索的卷轴，只要探险队通过最后的考验，便可以获取前往万灵之树的线索。\n\n探险队需要从一段不断变化的谜题数组中找到最终的密码，初始的谜题为长度为 `n` 的数组 `arr`（下标从 0 开始），数组中的数字代表了 `k` 位二进制数。\n破解谜题的过程中，需要使用 `与非（NAND）` 运算方式，`operations[i] = [type,x,y]` 表示第 `i` 次进行的谜题操作信息：\n- 若 `type = 0`，表示修改操作，将谜题数组中下标 `x` 的数字变化为 `y`；\n- 若 `type = 1`，表示运算操作，将数字 `y` 进行 `x*n` 次「与非」操作，第 `i` 次与非操作为 `y = y NAND arr[i%n]`；\n    > 运算操作结果即：`y NAND arr[0%n] NAND arr[1%n] NAND arr[2%n] ... NAND arr[(x*n-1)%n]`\n\n最后，将所有运算操作的结果按顺序逐一进行 `异或（XOR）`运算，从而得到最终解开封印的密码。请返回最终解开封印的密码。\n\n**注意:**\n- 「与非」（NAND）的操作为：先进行 `与` 操作，后进行 `非` 操作。\n    > 例如：两个三位二进制数`2`和`3`，其与非结果为 `NOT ((010) AND (011)) = (101) = 5`\n\n**示例 1：**\n> 输入: \n> `k = 3`\n> `arr = [1,2]`\n> `operations = [[1,2,3],[0,0,3],[1,2,2]]`\n>\n> 输出: `2`\n>\n> 解释：\n> 初始的谜题数组为 [1,2]，二进制位数为 3，\n> 第 0 次进行运算操作，将数字 3(011) 进行 2\\*2 次「与非」运算，\n> 运算操作结果为 `3 NAND 1 NAND 2 NAND 1 NAND 2 = 5`\n> 第 1 次进行修改操作，谜题数组的第 `0` 个数字变化为 `3`，谜题变成 `[3,2]`\n> 第 2 次进行运算操作，将数字 2(010) 进行 2\\*2 次「与非」运算，\n> 运算操作结果为 `2 NAND 3 NAND 2 NAND 3 NAND 2 = 7`\n> 所有运算操作结果进行「异或」运算为 `5 XOR 7 = 2`\n> 因此得到的最终密码为 `2`。\n\n**示例 2：**\n> 输入:\n> `k = 4`\n> `arr = [4,6,4,7,10,9,11]`\n> `operations = [[1,5,7],[1,7,14],[0,6,7],[1,6,5]]`\n> 输出: `9`\n> 解释: \n> 初始的谜题数组为 [4,6,4,7,10,9,11],\n> 第 0 次进行运算操作，运算操作结果为 5；\n> 第 1 次进行运算操作，运算操作结果为 5；\n> 第 2 次进行修改操作，修改后谜题数组为 [4, 6, 4, 7, 10, 9, 7]；\n> 第 3 次进行运算操作，运算操作结果为 9；\n> 所有运算操作结果进行「异或」运算为 `5 XOR 5 XOR 9 = 9`；\n> 因此得到的最终密码为 `9`。\n\n**提示:**\n- `1 <= arr.length, operations.length <= 10^4`\n- `1 <= k <= 30`\n- `0 <= arr[i] < 2^k`\n- 若 `type = 0`，`0 <= x < arr.length` 且 `0 <= y < 2^k`\n- 若 `type = 1`，`1 <= x < 10^9` 且 `0 <= y < 2^k`\n- 保证存在 `type = 1` 的操作\n",
        "isPlus": false
    },
    {
        "problemsName": " 2845万灵之树",
        "hardRate": "HARD",
        "passRate": "14.00%",
        "problemsUrl": "https://leetcode.cn/problems/cnHoX6/",
        "solutionsUrl": "https://leetcode.cn/problems/cnHoX6/solution",
        "problemsDesc": "探险家小扣终于来到了万灵之树前，挑战最后的谜题。\n已知小扣拥有足够数量的链接节点和 `n` 颗幻境宝石，`gem[i]` 表示第 `i` 颗宝石的数值。现在小扣需要使用这些链接节点和宝石组合成一颗二叉树，其组装规则为：\n- 链接节点将作为二叉树中的非叶子节点，且每个链接节点必须拥有 `2` 个子节点；\n- 幻境宝石将作为二叉树中的叶子节点，所有的幻境宝石都必须被使用。\n\n能量首先进入根节点，而后将按如下规则进行移动和记录：\n- 若能量首次到达该节点时：\n    - 记录数字 `1`；\n    - 若该节点为叶节点，将额外记录该叶节点的数值；\n- 若存在未到达的子节点，则选取未到达的一个子节点（优先选取左子节点）进入；\n- 若无子节点或所有子节点均到达过，此时记录 `9`，并回到当前节点的父节点（若存在）。\n\n如果最终记下的数依序连接成一个整数 `num`，满足 $num \\mod~p=target$，则视为解开谜题。\n请问有多少种二叉树的组装方案，可以使得最终记录下的数字可以解开谜题\n\n**注意：**\n- 两棵结构不同的二叉树，作为不同的组装方案\n- 两棵结构相同的二叉树且存在某个相同位置处的宝石编号不同，也作为不同的组装方案\n- 可能存在数值相同的两颗宝石\n\n**示例 1：**\n> 输入：`gem = [2,3]`\n> `p = 100000007`\n> `target = 11391299`\n>\n> 输出：`1`\n>\n> 解释：\n> 包含 `2` 个叶节点的结构只有一种。\n> 假设 B、C 节点的值分别为 3、2，对应 target 为 11391299，如下图所示。\n> 11391299 % 100000007 = 11391299，满足条件;\n> 假设 B、C 节点的值分别为 2、3，对应 target 为 11291399;\n> 11291399 % 100000007 = 11291399，不满足条件；\n> 因此只存在 1 种方案，返回 1\n![万灵 (1).gif](https://pic.leetcode.cn/1682397079-evMssw-%E4%B8%87%E7%81%B5%20\\(1\\).gif){:height=300px}\n\n\n**示例 2：**\n> 输入：`gem = [3,21,3]`\n> `p = 7`\n> `target = 5`\n>\n> 输出：`4`\n>\n> 解释：\n包含 `3` 个叶节点树结构有两种，列举如下：\n满足条件的组合有四种情况：\n> 当结构为下图（1）时：叶子节点的值为 [3,3,21] 或 [3,3,21]，得到的整数为 `11139139912199`。\n> 当结构为下图（2）时：叶子节点的值为 [21,3,3] 或 [21,3,3]，得到的整数为 `11219113913999`。\n![image.png](https://pic.leetcode.cn/1682322894-vfqJIV-image.png){:width=500px}\n\n\n**提示：**\n- `1 <= gem.length <= 9`\n- `0 <= gem[i] <= 10^9`\n- `1 <= p <= 10^9`，保证 $p$ 为素数。\n- `0 <= target < p`\n- 存在 2 组 `gem.length == 9` 的用例",
        "isPlus": false
    },
    {
        "problemsName": " 2846下载插件",
        "hardRate": "EASY",
        "passRate": "53.81%",
        "problemsUrl": "https://leetcode.cn/problems/Ju9Xwi/",
        "solutionsUrl": "https://leetcode.cn/problems/Ju9Xwi/solution",
        "problemsDesc": "小扣打算给自己的 **VS code** 安装使用插件，初始状态下带宽每分钟可以完成 `1` 个插件的下载。假定每分钟选择以下两种策略之一:\r\n- 使用当前带宽下载插件\r\n- 将带宽加倍（下载插件数量随之加倍）\r\n\r\n请返回小扣完成下载 `n` 个插件最少需要多少分钟。\r\n\r\n注意：实际的下载的插件数量可以超过 `n` 个\r\n\r\n\r\n**示例 1：**\r\n>输入：`n = 2`\r\n>\r\n>输出：`2`\r\n>\r\n>解释：\r\n> 以下两个方案，都能实现 2 分钟内下载 2 个插件\r\n>- 方案一：第一分钟带宽加倍，带宽可每分钟下载 2 个插件；第二分钟下载 2 个插件\r\n>- 方案二：第一分钟下载 1 个插件，第二分钟下载 1 个插件\r\n\r\n**示例 2：**\r\n>输入：`n = 4`\r\n>\r\n>输出：`3`\r\n>\r\n>解释：\r\n> 最少需要 3 分钟可完成 4 个插件的下载，以下是其中一种方案:\r\n> 第一分钟带宽加倍，带宽可每分钟下载 2 个插件;\r\n> 第二分钟下载 2 个插件;\r\n> 第三分钟下载 2 个插件。\r\n\r\n\r\n\r\n**提示：**\r\n- `1 <= n <= 10^5`\r\n",
        "isPlus": false
    },
    {
        "problemsName": " 2847完成一半题目",
        "hardRate": "EASY",
        "passRate": "64.44%",
        "problemsUrl": "https://leetcode.cn/problems/WqXACV/",
        "solutionsUrl": "https://leetcode.cn/problems/WqXACV/solution",
        "problemsDesc": "有 `N` 位扣友参加了微软与力扣举办了「以扣会友」线下活动。主办方提供了 `2*N` 道题目，整型数组 `questions` 中每个数字对应了每道题目所涉及的知识点类型。\r\n若每位扣友选择不同的一题，请返回被选的 `N` 道题目至少包含多少种知识点类型。\r\n\r\n\r\n**示例 1：**\r\n>输入：`questions = [2,1,6,2]`\r\n>\r\n>输出：`1`\r\n>\r\n>解释：有 2 位扣友在 4 道题目中选择 2 题。\r\n> 可选择完成知识点类型为 2 的题目时，此时仅一种知识点类型\r\n> 因此至少包含 1 种知识点类型。\r\n\r\n**示例 2：**\r\n>输入：`questions = [1,5,1,3,4,5,2,5,3,3,8,6]`\r\n>\r\n>输出：`2`\r\n>\r\n>解释：有 6 位扣友在 12 道题目中选择题目，需要选择 6 题。\r\n> 选择完成知识点类型为 3、5 的题目，因此至少包含 2 种知识点类型。\r\n\r\n\r\n\r\n**提示：**\r\n- `questions.length == 2*n`\r\n- `2 <= questions.length <= 10^5`\r\n- `1 <= questions[i] <= 1000`",
        "isPlus": false
    },
    {
        "problemsName": " 2848主题空间",
        "hardRate": "MEDIUM",
        "passRate": "41.29%",
        "problemsUrl": "https://leetcode.cn/problems/YesdPw/",
        "solutionsUrl": "https://leetcode.cn/problems/YesdPw/solution",
        "problemsDesc": "「以扣会友」线下活动所在场地由若干主题空间与走廊组成，场地的地图记作由一维字符串型数组 `grid`，字符串中仅包含 `\"0\"～\"5\"` 这 6 个字符。地图上每一个字符代表面积为 1 的区域，其中 `\"0\"` 表示走廊，其他字符表示主题空间。相同且连续（连续指上、下、左、右四个方向连接）的字符组成同一个主题空间。\n\n假如整个 `grid` 区域的外侧均为走廊。请问，不与走廊直接相邻的主题空间的最大面积是多少？如果不存在这样的空间请返回 `0`。\n\n**示例 1:**\n>输入：`grid = [\"110\",\"231\",\"221\"]`\n>\n>输出：`1`\n>\n>解释：4 个主题空间中，只有 1 个不与走廊相邻，面积为 1。\n>![image.png](https://pic.leetcode-cn.com/1613708145-rscctN-image.png)\n\n\n**示例 2:**\n>输入：`grid = [\"11111100000\",\"21243101111\",\"21224101221\",\"11111101111\"]`\n>\n>输出：`3`\n>\n>解释：8 个主题空间中，有 5 个不与走廊相邻，面积分别为 3、1、1、1、2，最大面积为 3。\n>![image.png](https://pic.leetcode-cn.com/1613707985-KJyiXJ-image.png)\n\n\n**提示：**\n- `1 <= grid.length <= 500`\n- `1 <= grid[i].length <= 500`\n- `grid[i][j]` 仅可能是 `\"0\"～\"5\"`\n\n",
        "isPlus": false
    },
    {
        "problemsName": " 2849数组中重复的数字",
        "hardRate": "EASY",
        "passRate": "67.05%",
        "problemsUrl": "https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution",
        "problemsDesc": "<p>找出数组中重复的数字。</p>\n\n<p><br>\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>\n[2, 3, 1, 0, 2, 5, 3]\n<strong>输出：</strong>2 或 3 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>2 &lt;= n &lt;= 100000</code></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2850二维数组中的查找",
        "hardRate": "MEDIUM",
        "passRate": "39.54%",
        "problemsUrl": "https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution",
        "problemsDesc": "<p>在一个 n * m 的二维数组中，每一行都按照从左到右&nbsp;<strong>非递减&nbsp;</strong>的顺序排序，每一列都按照从上到下&nbsp;<strong>非递减&nbsp;</strong>的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例:</strong></p>\n\n<p>现有矩阵 matrix 如下：</p>\n\n<pre>\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n</pre>\n\n<p>给定 target&nbsp;=&nbsp;<code>5</code>，返回&nbsp;<code>true</code>。</p>\n\n<p>给定&nbsp;target&nbsp;=&nbsp;<code>20</code>，返回&nbsp;<code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 &lt;= n &lt;= 1000</code></p>\n\n<p><code>0 &lt;= m &lt;= 1000</code></p>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与主站 240 题相同：<a href=\"https://leetcode-cn.com/problems/search-a-2d-matrix-ii/\">https://leetcode-cn.com/problems/search-a-2d-matrix-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2851替换空格",
        "hardRate": "EASY",
        "passRate": "75.19%",
        "problemsUrl": "https://leetcode.cn/problems/ti-huan-kong-ge-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/ti-huan-kong-ge-lcof/solution",
        "problemsDesc": "<p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成&quot;%20&quot;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;We are happy.&quot;\n<strong>输出：</strong>&quot;We%20are%20happy.&quot;</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 &lt;= s 的长度 &lt;= 10000</code></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2852从尾到头打印链表",
        "hardRate": "EASY",
        "passRate": "74.41%",
        "problemsUrl": "https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/solution",
        "problemsDesc": "<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>head = [1,3,2]\n<strong>输出：</strong>[2,3,1]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 &lt;= 链表长度 &lt;= 10000</code></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2853重建二叉树",
        "hardRate": "MEDIUM",
        "passRate": "70.26%",
        "problemsUrl": "https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/solution",
        "problemsDesc": "<p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p>\n\n<p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree.jpg\" />\n<pre>\n<strong>Input:</strong> preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n<strong>Output:</strong> [3,9,20,null,null,15,7]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> preorder = [-1], inorder = [-1]\n<strong>Output:</strong> [-1]\n</pre>\n\n<p> </p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 <= 节点个数 <= 5000</code></p>\n\n<p> </p>\n\n<p><strong>注意</strong>：本题与主站 105 题重复：<a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2854用两个栈实现队列",
        "hardRate": "EASY",
        "passRate": "70.35%",
        "problemsUrl": "https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution",
        "problemsDesc": "<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code>&nbsp;操作返回 -1 )</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\",\"deleteHead\"]\n[[],[3],[],[],[]]\n<strong>输出：</strong>[null,null,3,-1,-1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"CQueue\",\"deleteHead\",\"appendTail\",\"appendTail\",\"deleteHead\",\"deleteHead\"]\n[[],[],[5],[2],[],[]]\n<strong>输出：</strong>[null,-1,null,null,5,2]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= values &lt;= 10000</code></li>\n\t<li>最多会对<code>&nbsp;appendTail、deleteHead </code>进行<code>&nbsp;10000</code>&nbsp;次调用</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2855斐波那契数列",
        "hardRate": "EASY",
        "passRate": "35.93%",
        "problemsUrl": "https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/solution",
        "problemsDesc": "<p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p>\n\n<pre>\nF(0) = 0,   F(1) = 1\nF(N) = F(N - 1) + F(N - 2), 其中 N > 1.</pre>\n\n<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>\n\n<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>5\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= n <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2856青蛙跳台阶问题",
        "hardRate": "EASY",
        "passRate": "45.73%",
        "problemsUrl": "https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/solution",
        "problemsDesc": "<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code>&nbsp;级的台阶总共有多少种跳法。</p>\n\n<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 7\n<strong>输出：</strong>21\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 0\n<strong>输出：</strong>1</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 100</code></li>\n</ul>\n\n<p>注意：本题与主站 70 题相同：<a href=\"https://leetcode-cn.com/problems/climbing-stairs/\">https://leetcode-cn.com/problems/climbing-stairs/</a></p>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2857旋转数组的最小数字",
        "hardRate": "EASY",
        "passRate": "49.47%",
        "problemsUrl": "https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution",
        "problemsDesc": "<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p>\n\n<p>给你一个可能存在&nbsp;<strong>重复</strong>&nbsp;元素值的数组&nbsp;<code>numbers</code>&nbsp;，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的<strong>最小元素</strong>。例如，数组&nbsp;<code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一次旋转，该数组的最小值为 1。&nbsp;&nbsp;</p>\n\n<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 旋转一次 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong><code>numbers = </code>[3,4,5,1,2]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong><code>numbers = </code>[2,2,2,0,1]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == numbers.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>-5000 &lt;= numbers[i] &lt;= 5000</code></li>\n\t<li><code>numbers</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li>\n</ul>\n\n<p>注意：本题与主站 154 题相同：<a href=\"https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/\">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2858矩阵中的路径",
        "hardRate": "MEDIUM",
        "passRate": "45.67%",
        "problemsUrl": "https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/solution",
        "problemsDesc": "<p>给定一个&nbsp;<code>m x n</code> 二维字符网格&nbsp;<code>board</code> 和一个字符串单词&nbsp;<code>word</code> 。如果&nbsp;<code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>\n\n<p>&nbsp;</p>\n\n<p>例如，在下面的 3×4 的矩阵中包含单词 \"ABCCED\"（单词中的字母已标出）。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word2.jpg\" style=\"width: 322px; height: 242px;\" /></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = [[\"a\",\"b\"],[\"c\",\"d\"]], word = \"abcd\"\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n = board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 6</code></li>\n\t<li><code>1 &lt;= word.length &lt;= 15</code></li>\n\t<li><code>board </code>和<code> word </code>仅由大小写英文字母组成</li>\n</ul>\n\n<p><strong>注意：</strong>本题与主站 79 题相同：<a href=\"https://leetcode-cn.com/problems/word-search/\">https://leetcode-cn.com/problems/word-search/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2859机器人的运动范围",
        "hardRate": "MEDIUM",
        "passRate": "53.64%",
        "problemsUrl": "https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution",
        "problemsDesc": "<p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0] </code>的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>m = 2, n = 3, k = 1\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>m = 3, n = 1, k = 0\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n,m &lt;= 100</code></li>\n\t<li><code>0 &lt;= k&nbsp;&lt;= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2860剪绳子",
        "hardRate": "MEDIUM",
        "passRate": "57.44%",
        "problemsUrl": "https://leetcode.cn/problems/jian-sheng-zi-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/jian-sheng-zi-lcof/solution",
        "problemsDesc": "<p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m-1]</code> 。请问 <code>k[0]*k[1]*...*k[m-1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入: </strong>2\n<strong>输出: </strong>1\n<strong>解释: </strong>2 = 1 + 1, 1 &times; 1 = 1</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入: </strong>10\n<strong>输出: </strong>36\n<strong>解释: </strong>10 = 3 + 3 + 4, 3 &times;&nbsp;3 &times;&nbsp;4 = 36</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 58</code></li>\n</ul>\n\n<p>注意：本题与主站 343 题相同：<a href=\"https://leetcode-cn.com/problems/integer-break/\">https://leetcode-cn.com/problems/integer-break/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2861剪绳子 II",
        "hardRate": "MEDIUM",
        "passRate": "31.41%",
        "problemsUrl": "https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/solution",
        "problemsDesc": "<p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code>&nbsp;段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m - 1]</code> 。请问 <code>k[0]*k[1]*...*k[m - 1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>\n\n<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入: </strong>2\n<strong>输出: </strong>1\n<strong>解释: </strong>2 = 1 + 1, 1 &times; 1 = 1</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入: </strong>10\n<strong>输出: </strong>36\n<strong>解释: </strong>10 = 3 + 3 + 4, 3 &times;&nbsp;3 &times;&nbsp;4 = 36</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n</ul>\n\n<p>注意：本题与主站 343 题相同：<a href=\"https://leetcode-cn.com/problems/integer-break/\">https://leetcode-cn.com/problems/integer-break/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2862二进制中1的个数",
        "hardRate": "EASY",
        "passRate": "75.68%",
        "problemsUrl": "https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/solution",
        "problemsDesc": "<p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 <a href=\"http://en.wikipedia.org/wiki/Hamming_weight\" target=\"_blank\">汉明重量</a>).）。</p>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>\n\t<li>在 Java 中，编译器使用 <a href=\"https://baike.baidu.com/item/二进制补码/5295284\">二进制补码</a> 记法来表示有符号整数。因此，在上面的 <strong>示例 3 </strong>中，输入表示有符号整数 <code>-3</code>。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 11 (控制台输入 00000000000000000000000000001011)\n<strong>输出：</strong>3\n<strong>解释：</strong>输入的二进制串 <code><strong>00000000000000000000000000001011</strong> 中，共有三位为 '1'。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 128 (控制台输入 00000000000000000000000010000000)\n<strong>输出：</strong>1\n<strong>解释：</strong>输入的二进制串 <strong>00000000000000000000000010000000</strong> 中，共有一位为 '1'。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）\n<strong>输出：</strong>31\n<strong>解释：</strong>输入的二进制串 <strong>11111111111111111111111111111101</strong> 中，共有 31 位为 '1'。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</li>\n</ul>\n\n<p> </p>\n\n<p>注意：本题与主站 191 题相同：<a href=\"https://leetcode-cn.com/problems/number-of-1-bits/\">https://leetcode-cn.com/problems/number-of-1-bits/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2863数值的整数次方",
        "hardRate": "MEDIUM",
        "passRate": "34.84%",
        "problemsUrl": "https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution",
        "problemsDesc": "<p>实现&nbsp;<a href=\"https://www.cplusplus.com/reference/valarray/pow/\">pow(<em>x</em>,&nbsp;<em>n</em>)</a>&nbsp;，即计算 x 的 n 次幂函数（即，x<sup>n</sup>）。不得使用库函数，同时不需要考虑大数问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 2.00000, n = 10\n<strong>输出：</strong>1024.00000\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 2.10000, n = 3\n<strong>输出：</strong>9.26100</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 2.00000, n = -2\n<strong>输出：</strong>0.25000\n<strong>解释：</strong>2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-100.0 &lt; x &lt; 100.0</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup>-1</code></li>\n\t<li><code>n</code>&nbsp;是一个整数</li>\n\t<li>要么 <code>x</code> 不为零，要么 <code>n &gt; 0</code> 。</li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sup>n</sup> &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 50 题相同：<a href=\"https://leetcode-cn.com/problems/powx-n/\">https://leetcode-cn.com/problems/powx-n/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2864打印从1到最大的n位数",
        "hardRate": "EASY",
        "passRate": "77.69%",
        "problemsUrl": "https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solution",
        "problemsDesc": "<p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> n = 1\n<strong>输出:</strong> [1,2,3,4,5,6,7,8,9]\n</pre>\n\n<p>&nbsp;</p>\n\n<p>说明：</p>\n\n<ul>\n\t<li>用返回一个整数列表来代替打印</li>\n\t<li>n 为正整数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2865删除链表的节点",
        "hardRate": "EASY",
        "passRate": "59.94%",
        "problemsUrl": "https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/solution",
        "problemsDesc": "<p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>\n\n<p>返回删除后的链表的头节点。</p>\n\n<p><strong>注意：</strong>此题对比原题有改动</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> head = [4,5,1,9], val = 5\n<strong>输出:</strong> [4,1,9]\n<strong>解释: </strong>给定你链表中值为&nbsp;5&nbsp;的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> head = [4,5,1,9], val = 1\n<strong>输出:</strong> [4,5,9]\n<strong>解释: </strong>给定你链表中值为&nbsp;1&nbsp;的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>题目保证链表中节点的值互不相同</li>\n\t<li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2866正则表达式匹配",
        "hardRate": "HARD",
        "passRate": "38.46%",
        "problemsUrl": "https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution",
        "problemsDesc": "<p>请实现一个函数用来匹配包含<code>&#39;. &#39;</code>和<code>&#39;*&#39;</code>的正则表达式。模式中的字符<code>&#39;.&#39;</code>表示任意一个字符，而<code>&#39;*&#39;</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>&quot;aaa&quot;</code>与模式<code>&quot;a.a&quot;</code>和<code>&quot;ab*ac*a&quot;</code>匹配，但与<code>&quot;aa.a&quot;</code>和<code>&quot;ab*a&quot;</code>均不匹配。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong>\ns = &quot;aa&quot;\np = &quot;a&quot;\n<strong>输出:</strong> false\n<strong>解释:</strong> &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong>\ns = &quot;aa&quot;\np = &quot;a*&quot;\n<strong>输出:</strong> true\n<strong>解释:</strong>&nbsp;因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。\n</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre><strong>输入:</strong>\ns = &quot;ab&quot;\np = &quot;.*&quot;\n<strong>输出:</strong> true\n<strong>解释:</strong>&nbsp;&quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。\n</pre>\n\n<p><strong>示例 4:</strong></p>\n\n<pre><strong>输入:</strong>\ns = &quot;aab&quot;\np = &quot;c*a*b&quot;\n<strong>输出:</strong> true\n<strong>解释:</strong>&nbsp;因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。\n</pre>\n\n<p><strong>示例 5:</strong></p>\n\n<pre><strong>输入:</strong>\ns = &quot;mississippi&quot;\np = &quot;mis*is*p*.&quot;\n<strong>输出:</strong> false</pre>\n\n<ul>\n\t<li><code>s</code>&nbsp;可能为空，且只包含从&nbsp;<code>a-z</code>&nbsp;的小写字母。</li>\n\t<li><code>p</code>&nbsp;可能为空，且只包含从&nbsp;<code>a-z</code>&nbsp;的小写字母以及字符&nbsp;<code>.</code>&nbsp;和&nbsp;<code>*</code>，无连续的 <code>&#39;*&#39;</code>。</li>\n</ul>\n\n<p>注意：本题与主站 10&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/regular-expression-matching/\">https://leetcode-cn.com/problems/regular-expression-matching/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2867表示数值的字符串",
        "hardRate": "MEDIUM",
        "passRate": "25.11%",
        "problemsUrl": "https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution",
        "problemsDesc": "<p>请实现一个函数用来判断字符串是否表示<strong>数值</strong>（包括整数和小数）。</p>\n\n<p><strong>数值</strong>（按顺序）可以分成以下几个部分：</p>\n\n<ol>\n\t<li>若干空格</li>\n\t<li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li>\n\t<li>（可选）一个 <code>'e'</code> 或 <code>'E'</code> ，后面跟着一个 <strong>整数</strong></li>\n\t<li>若干空格</li>\n</ol>\n\n<p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p>\n\n<ol>\n\t<li>（可选）一个符号字符（<code>'+'</code> 或 <code>'-'</code>）</li>\n\t<li>下述格式之一：\n\t<ol>\n\t\t<li>至少一位数字，后面跟着一个点 <code>'.'</code></li>\n\t\t<li>至少一位数字，后面跟着一个点 <code>'.'</code> ，后面再跟着至少一位数字</li>\n\t\t<li>一个点 <code>'.'</code> ，后面跟着至少一位数字</li>\n\t</ol>\n\t</li>\n</ol>\n\n<p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p>\n\n<ol>\n\t<li>（可选）一个符号字符（<code>'+'</code> 或 <code>'-'</code>）</li>\n\t<li>至少一位数字</li>\n</ol>\n\n<p>部分<strong>数值</strong>列举如下：</p>\n\n<ul>\n\t<li><code>[\"+100\", \"5e2\", \"-123\", \"3.1416\", \"-1E-16\", \"0123\"]</code></li>\n</ul>\n\n<p>部分<strong>非数值</strong>列举如下：</p>\n\n<ul>\n\t<li><code>[\"12e\", \"1a3.14\", \"1.2.3\", \"+-5\", \"12e+5.4\"]</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"e\"\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \".\"\n<strong>输出：</strong>false</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"    .1  \"\n<strong>输出：</strong>true\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 20</code></li>\n\t<li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>'+'</code> ，减号 <code>'-'</code> ，空格 <code>' '</code> 或者点 <code>'.'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2868调整数组顺序使奇数位于偶数前面",
        "hardRate": "EASY",
        "passRate": "65.03%",
        "problemsUrl": "https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/solution",
        "problemsDesc": "<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums =&nbsp;[1,2,3,4]\n<strong>输出：</strong>[1,3,2,4] \n<strong>注：</strong>[3,1,2,4] 也是正确的答案之一。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>0 &lt;= nums.length &lt;= 50000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10000</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2869链表中倒数第k个节点",
        "hardRate": "EASY",
        "passRate": "80.15%",
        "problemsUrl": "https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/solution",
        "problemsDesc": "<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>\n\n<p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点。</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n给定一个链表: <strong>1->2->3->4->5</strong>, 和 <em>k </em><strong>= 2</strong>.\n\n返回链表 4<strong>->5</strong>.</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2870反转链表",
        "hardRate": "EASY",
        "passRate": "74.22%",
        "problemsUrl": "https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/solution",
        "problemsDesc": "<p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL\n<strong>输出:</strong> 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 &lt;= 节点个数 &lt;= 5000</code></p>\n\n<p>&nbsp;</p>\n\n<p><strong>注意</strong>：本题与主站 206 题相同：<a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\">https://leetcode-cn.com/problems/reverse-linked-list/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2871合并两个排序的链表",
        "hardRate": "EASY",
        "passRate": "72.21%",
        "problemsUrl": "https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/solution",
        "problemsDesc": "<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>\n\n<p><strong>示例1：</strong></p>\n\n<pre><strong>输入：</strong>1-&gt;2-&gt;4, 1-&gt;3-&gt;4\n<strong>输出：</strong>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</pre>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 &lt;= 链表长度 &lt;= 1000</code></p>\n\n<p>注意：本题与主站 21 题相同：<a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/\">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2872树的子结构",
        "hardRate": "MEDIUM",
        "passRate": "46.41%",
        "problemsUrl": "https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solution",
        "problemsDesc": "<p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>\n\n<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>\n\n<p>例如:<br>\n给定的树 A:</p>\n\n<p><code>&nbsp; &nbsp; &nbsp;3<br>\n&nbsp; &nbsp; / \\<br>\n&nbsp; &nbsp;4 &nbsp; 5<br>\n&nbsp; / \\<br>\n&nbsp;1 &nbsp; 2</code><br>\n给定的树 B：</p>\n\n<p><code>&nbsp; &nbsp;4&nbsp;<br>\n&nbsp; /<br>\n&nbsp;1</code><br>\n返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>A = [1,2,3], B = [3,1]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>A = [3,4,5,1,2], B = [4,1]\n<strong>输出：</strong>true</pre>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 &lt;= 节点个数 &lt;= 10000</code></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2873二叉树的镜像",
        "hardRate": "EASY",
        "passRate": "79.63%",
        "problemsUrl": "https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/solution",
        "problemsDesc": "<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>\n\n<p>例如输入：</p>\n\n<p><code>&nbsp; &nbsp; &nbsp;4<br>\n&nbsp; &nbsp;/ &nbsp; \\<br>\n&nbsp; 2 &nbsp; &nbsp; 7<br>\n&nbsp;/ \\ &nbsp; / \\<br>\n1 &nbsp; 3 6 &nbsp; 9</code><br>\n镜像输出：</p>\n\n<p><code>&nbsp; &nbsp; &nbsp;4<br>\n&nbsp; &nbsp;/ &nbsp; \\<br>\n&nbsp; 7 &nbsp; &nbsp; 2<br>\n&nbsp;/ \\ &nbsp; / \\<br>\n9 &nbsp; 6 3&nbsp; &nbsp;1</code></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>root = [4,2,7,1,3,6,9]\n<strong>输出：</strong>[4,7,2,9,6,3,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 &lt;= 节点个数 &lt;= 1000</code></p>\n\n<p>注意：本题与主站 226 题相同：<a href=\"https://leetcode-cn.com/problems/invert-binary-tree/\">https://leetcode-cn.com/problems/invert-binary-tree/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2874对称的二叉树",
        "hardRate": "EASY",
        "passRate": "57.63%",
        "problemsUrl": "https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/solution",
        "problemsDesc": "<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>\n\n<p>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p>\n\n<p><code>&nbsp; &nbsp; 1<br>\n&nbsp; &nbsp;/ \\<br>\n&nbsp; 2 &nbsp; 2<br>\n&nbsp;/ \\ / \\<br>\n3 &nbsp;4 4 &nbsp;3</code><br>\n但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p>\n\n<p><code>&nbsp; &nbsp; 1<br>\n&nbsp; &nbsp;/ \\<br>\n&nbsp; 2 &nbsp; 2<br>\n&nbsp; &nbsp;\\ &nbsp; \\<br>\n&nbsp; &nbsp;3 &nbsp; &nbsp;3</code></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>root = [1,2,2,3,4,4,3]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>root = [1,2,2,null,3,null,3]\n<strong>输出：</strong>false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 &lt;= 节点个数 &lt;= 1000</code></p>\n\n<p>注意：本题与主站 101 题相同：<a href=\"https://leetcode-cn.com/problems/symmetric-tree/\">https://leetcode-cn.com/problems/symmetric-tree/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2875顺时针打印矩阵",
        "hardRate": "EASY",
        "passRate": "43.03%",
        "problemsUrl": "https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution",
        "problemsDesc": "<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>[1,2,3,6,9,8,7,4,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>matrix =&nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n<strong>输出：</strong>[1,2,3,4,8,12,11,10,9,5,6,7]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= matrix.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= matrix[i].length&nbsp;&lt;= 100</code></li>\n</ul>\n\n<p>注意：本题与主站 54 题相同：<a href=\"https://leetcode-cn.com/problems/spiral-matrix/\">https://leetcode-cn.com/problems/spiral-matrix/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2876包含min函数的栈",
        "hardRate": "EASY",
        "passRate": "55.34%",
        "problemsUrl": "https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/solution",
        "problemsDesc": "<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>MinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.min();   --&gt; 返回 -3.\nminStack.pop();\nminStack.top();      --&gt; 返回 0.\nminStack.min();   --&gt; 返回 -2.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>各函数的调用总次数不超过 20000 次</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 155 题相同：<a href=\"https://leetcode-cn.com/problems/min-stack/\">https://leetcode-cn.com/problems/min-stack/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2877栈的压入、弹出序列",
        "hardRate": "MEDIUM",
        "passRate": "61.04%",
        "problemsUrl": "https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/solution",
        "problemsDesc": "<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\n<strong>输出：</strong>true\n<strong>解释：</strong>我们可以按以下顺序执行：\npush(1), push(2), push(3), push(4), pop() -&gt; 4,\npush(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\n<strong>输出：</strong>false\n<strong>解释：</strong>1 不能在 2 之前弹出。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>0 &lt;= pushed.length == popped.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= pushed[i], popped[i] &lt; 1000</code></li>\n\t<li><code>pushed</code>&nbsp;是&nbsp;<code>popped</code>&nbsp;的排列。</li>\n</ol>\n\n<p>注意：本题与主站 946 题相同：<a href=\"https://leetcode-cn.com/problems/validate-stack-sequences/\">https://leetcode-cn.com/problems/validate-stack-sequences/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2878从上到下打印二叉树",
        "hardRate": "MEDIUM",
        "passRate": "63.14%",
        "problemsUrl": "https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/solution",
        "problemsDesc": "<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>\n\n<p>&nbsp;</p>\n\n<p>例如:<br>\n给定二叉树:&nbsp;<code>[3,9,20,null,null,15,7]</code>,</p>\n\n<pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</pre>\n\n<p>返回：</p>\n\n<pre>[3,9,20,15,7]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>节点总数 &lt;= 1000</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2879从上到下打印二叉树 II",
        "hardRate": "EASY",
        "passRate": "68.85%",
        "problemsUrl": "https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/solution",
        "problemsDesc": "<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>\n\n<p>&nbsp;</p>\n\n<p>例如:<br>\n给定二叉树:&nbsp;<code>[3,9,20,null,null,15,7]</code>,</p>\n\n<pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</pre>\n\n<p>返回其层次遍历结果：</p>\n\n<pre>[\n  [3],\n  [9,20],\n  [15,7]\n]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>节点总数 &lt;= 1000</code></li>\n</ol>\n\n<p>注意：本题与主站 102 题相同：<a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal/\">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2880从上到下打印二叉树 III",
        "hardRate": "MEDIUM",
        "passRate": "58.20%",
        "problemsUrl": "https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/solution",
        "problemsDesc": "<p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>\n\n<p>&nbsp;</p>\n\n<p>例如:<br>\n给定二叉树:&nbsp;<code>[3,9,20,null,null,15,7]</code>,</p>\n\n<pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</pre>\n\n<p>返回其层次遍历结果：</p>\n\n<pre>[\n  [3],\n  [20,9],\n  [15,7]\n]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>节点总数 &lt;= 1000</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2881二叉搜索树的后序遍历序列",
        "hardRate": "MEDIUM",
        "passRate": "56.89%",
        "problemsUrl": "https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution",
        "problemsDesc": "<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回&nbsp;<code>true</code>，否则返回&nbsp;<code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>\n\n<p>&nbsp;</p>\n\n<p>参考以下这颗二叉搜索树：</p>\n\n<pre>     5\n    / \\\n   2   6\n  / \\\n 1   3</pre>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入: </strong>[1,6,3,2,5]\n<strong>输出: </strong>false</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入: </strong>[1,3,2,6,5]\n<strong>输出: </strong>true</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>数组长度 &lt;= 1000</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2882二叉树中和为某一值的路径",
        "hardRate": "MEDIUM",
        "passRate": "59.04%",
        "problemsUrl": "https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/solution",
        "problemsDesc": "<p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>\n\n<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n<strong>输出：</strong>[[5,4,11,2],[5,8,4,5]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3], targetSum = 5\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2], targetSum = 0\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点总数在范围 <code>[0, 5000]</code> 内</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>\n</ul>\n\n<p>注意：本题与主站 113&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/path-sum-ii/\">https://leetcode-cn.com/problems/path-sum-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2883复杂链表的复制",
        "hardRate": "MEDIUM",
        "passRate": "71.54%",
        "problemsUrl": "https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution",
        "problemsDesc": "<p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png\"></p>\n\n<pre><strong>输入：</strong>head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n<strong>输出：</strong>[[7,null],[13,0],[11,4],[10,2],[1,0]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png\"></p>\n\n<pre><strong>输入：</strong>head = [[1,1],[2,1]]\n<strong>输出：</strong>[[1,1],[2,1]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png\"></strong></p>\n\n<pre><strong>输入：</strong>head = [[3,null],[3,0],[3,null]]\n<strong>输出：</strong>[[3,null],[3,0],[3,null]]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>head = []\n<strong>输出：</strong>[]\n<strong>解释：</strong>给定的链表为空（空指针），因此返回 null。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-10000 &lt;= Node.val &lt;= 10000</code></li>\n\t<li><code>Node.random</code>&nbsp;为空（null）或指向链表中的节点。</li>\n\t<li>节点数目不超过 1000 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与主站 138 题相同：<a href=\"https://leetcode-cn.com/problems/copy-list-with-random-pointer/\">https://leetcode-cn.com/problems/copy-list-with-random-pointer/</a></p>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2884二叉搜索树与双向链表",
        "hardRate": "MEDIUM",
        "passRate": "64.88%",
        "problemsUrl": "https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution",
        "problemsDesc": "<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>\n\n<p>&nbsp;</p>\n\n<p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p>\n\n<p>&nbsp;</p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png\"></p>\n\n<p>&nbsp;</p>\n\n<p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p>\n\n<p>下图展示了上面的二叉搜索树转化成的链表。&ldquo;head&rdquo; 表示指向链表中有最小元素的节点。</p>\n\n<p>&nbsp;</p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png\"></p>\n\n<p>&nbsp;</p>\n\n<p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与主站 426 题相同：<a href=\"https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/\">https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/</a></p>\n\n<p><strong>注意：</strong>此题对比原题有改动。</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2885序列化二叉树",
        "hardRate": "HARD",
        "passRate": "57.45%",
        "problemsUrl": "https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/solution",
        "problemsDesc": "<p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>\n\n<p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>\n\n<p><strong>提示：</strong>输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅&nbsp;<a href=\"https://support.leetcode-cn.com/hc/kb/article/1567641/\">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg\" style=\"width: 442px; height: 324px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,null,null,4,5]\n<strong>输出：</strong>[1,2,3,null,null,4,5]\n</pre>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 297 题相同：<a href=\"https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/\">https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2886字符串的排列",
        "hardRate": "MEDIUM",
        "passRate": "57.55%",
        "problemsUrl": "https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/solution",
        "problemsDesc": "<p>输入一个字符串，打印出该字符串中字符的所有排列。</p>\n\n<p>&nbsp;</p>\n\n<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abc&quot;\n<strong>输出：[</strong>&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;<strong>]</strong>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>1 &lt;= s 的长度 &lt;= 8</code></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2887数组中出现次数超过一半的数字",
        "hardRate": "EASY",
        "passRate": "70.03%",
        "problemsUrl": "https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/solution",
        "problemsDesc": "<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>\n\n<p>&nbsp;</p>\n\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> [1, 2, 3, 2, 2, 2, 5, 4, 2]\n<strong>输出:</strong> 2</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>1 &lt;= 数组长度 &lt;= 50000</code></p>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 169 题相同：<a href=\"https://leetcode-cn.com/problems/majority-element/\">https://leetcode-cn.com/problems/majority-element/</a></p>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2888最小的k个数",
        "hardRate": "EASY",
        "passRate": "57.67%",
        "problemsUrl": "https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/solution",
        "problemsDesc": "<p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,2,1], k = 2\n<strong>输出：</strong>[1,2] 或者 [2,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [0,1,2,1], k = 1\n<strong>输出：</strong>[0]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= k &lt;= arr.length &lt;= 10000</code></li>\n\t<li><code>0 &lt;= arr[i]&nbsp;&lt;= 10000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2889数据流中的中位数",
        "hardRate": "HARD",
        "passRate": "58.29%",
        "problemsUrl": "https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/solution",
        "problemsDesc": "<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>\n\n<p>例如，</p>\n\n<p>[2,3,4]&nbsp;的中位数是 3</p>\n\n<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>\n\n<p>设计一个支持以下两种操作的数据结构：</p>\n\n<ul>\n\t<li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li>\n\t<li>double findMedian() - 返回目前所有元素的中位数。</li>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：\n</strong>[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]\n[[],[1],[2],[],[3],[]]\n<strong>输出：</strong>[null,null,null,1.50000,null,2.00000]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：\n</strong>[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]\n[[],[2],[],[3],[]]\n<strong>输出：</strong>[null,null,2.00000,null,2.50000]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li>最多会对&nbsp;<code>addNum、findMedian</code> 进行&nbsp;<code>50000</code>&nbsp;次调用。</li>\n</ul>\n\n<p>注意：本题与主站 295 题相同：<a href=\"https://leetcode-cn.com/problems/find-median-from-data-stream/\">https://leetcode-cn.com/problems/find-median-from-data-stream/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2890连续子数组的最大和",
        "hardRate": "EASY",
        "passRate": "60.36%",
        "problemsUrl": "https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution",
        "problemsDesc": "<p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>\n\n<p>要求时间复杂度为O(n)。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre><strong>输入:</strong> nums = [-2,1,-3,4,-1,2,1,-5,4]\n<strong>输出:</strong> 6\n<strong>解释:</strong>&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;arr.length &lt;= 10^5</code></li>\n\t<li><code>-100 &lt;= arr[i] &lt;= 100</code></li>\n</ul>\n\n<p>注意：本题与主站 53 题相同：<a href=\"https://leetcode-cn.com/problems/maximum-subarray/\">https://leetcode-cn.com/problems/maximum-subarray/</a></p>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 28911～n 整数中 1 出现的次数",
        "hardRate": "HARD",
        "passRate": "50.51%",
        "problemsUrl": "https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution",
        "problemsDesc": "<p>输入一个整数 <code>n</code> ，求1～n这n个整数的十进制表示中1出现的次数。</p>\n\n<p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 12\n<strong>输出：</strong>5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 13\n<strong>输出：</strong>6</pre>\n\n<p> </p>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>1 <= n < 2^31</code></li>\n</ul>\n\n<p>注意：本题与主站 233 题相同：<a href=\"https://leetcode-cn.com/problems/number-of-digit-one/\">https://leetcode-cn.com/problems/number-of-digit-one/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2892数字序列中某一位的数字",
        "hardRate": "MEDIUM",
        "passRate": "43.07%",
        "problemsUrl": "https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution",
        "problemsDesc": "<p>数字以0123456789101112131415&hellip;的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p>\n\n<p>请写一个函数，求任意第n位对应的数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 3\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 11\n<strong>输出：</strong>0</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;&nbsp;2^31</code></li>\n</ul>\n\n<p>注意：本题与主站 400 题相同：<a href=\"https://leetcode-cn.com/problems/nth-digit/\">https://leetcode-cn.com/problems/nth-digit/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2893把数组排成最小的数",
        "hardRate": "MEDIUM",
        "passRate": "55.03%",
        "problemsUrl": "https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/solution",
        "problemsDesc": "<p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> <code>[10,2]</code>\n<strong>输出:</strong> &quot;<code>102&quot;</code></pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> <code>[3,30,34,5,9]</code>\n<strong>输出:</strong> &quot;<code>3033459&quot;</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>0 &lt; nums.length &lt;= 100</code></li>\n</ul>\n\n<p><strong>说明: </strong></p>\n\n<ul>\n\t<li>输出结果可能非常大，所以你需要返回一个字符串而不是整数</li>\n\t<li>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2894把数字翻译成字符串",
        "hardRate": "MEDIUM",
        "passRate": "51.30%",
        "problemsUrl": "https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/solution",
        "problemsDesc": "<p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 &ldquo;a&rdquo; ，1 翻译成 &ldquo;b&rdquo;，&hellip;&hellip;，11 翻译成 &ldquo;l&rdquo;，&hellip;&hellip;，25 翻译成 &ldquo;z&rdquo;。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> 12258\n<strong>输出:</strong> <code>5\n</code><strong>解释:</strong> 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt; 2<sup>31</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2895礼物的最大价值",
        "hardRate": "MEDIUM",
        "passRate": "69.36%",
        "problemsUrl": "https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/solution",
        "problemsDesc": "<p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> \n<code>[\n&nbsp; [1,3,1],\n&nbsp; [1,5,1],\n&nbsp; [4,2,1]\n]</code>\n<strong>输出:</strong> <code>12\n</code><strong>解释:</strong> 路径 1&rarr;3&rarr;5&rarr;2&rarr;1 可以拿到最多价值的礼物</pre>\n\n<p>&nbsp;</p>\n\n<p>提示：</p>\n\n<ul>\n\t<li><code>0 &lt; grid.length &lt;= 200</code></li>\n\t<li><code>0 &lt; grid[0].length &lt;= 200</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2896最长不含重复字符的子字符串",
        "hardRate": "MEDIUM",
        "passRate": "46.10%",
        "problemsUrl": "https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution",
        "problemsDesc": "<p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入: </strong>&quot;abcabcbb&quot;\n<strong>输出: </strong>3 \n<strong>解释:</strong> 因为无重复字符的最长子串是 <code>&quot;abc&quot;，所以其</code>长度为 3。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入: </strong>&quot;bbbbb&quot;\n<strong>输出: </strong>1\n<strong>解释: </strong>因为无重复字符的最长子串是 <code>&quot;b&quot;</code>，所以其长度为 1。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre><strong>输入: </strong>&quot;pwwkew&quot;\n<strong>输出: </strong>3\n<strong>解释: </strong>因为无重复字符的最长子串是&nbsp;<code>&quot;wke&quot;</code>，所以其长度为 3。\n&nbsp;    请注意，你的答案必须是 <strong>子串 </strong>的长度，<code>&quot;pwke&quot;</code>&nbsp;是一个<em>子序列，</em>不是子串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>提示：</p>\n\n<ul>\n\t<li><code>s.length &lt;= 40000</code></li>\n</ul>\n\n<p>注意：本题与主站 3 题相同：<a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2897丑数",
        "hardRate": "MEDIUM",
        "passRate": "64.68%",
        "problemsUrl": "https://leetcode.cn/problems/chou-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/chou-shu-lcof/solution",
        "problemsDesc": "<p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> n = 10\n<strong>输出:</strong> 12\n<strong>解释: </strong><code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> 是前 10 个丑数。</pre>\n\n<p><strong>说明:&nbsp;</strong>&nbsp;</p>\n\n<ol>\n\t<li><code>1</code>&nbsp;是丑数。</li>\n\t<li><code>n</code>&nbsp;<strong>不超过</strong>1690。</li>\n</ol>\n\n<p>注意：本题与主站 264 题相同：<a href=\"https://leetcode-cn.com/problems/ugly-number-ii/\">https://leetcode-cn.com/problems/ugly-number-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2898第一个只出现一次的字符",
        "hardRate": "EASY",
        "passRate": "61.92%",
        "problemsUrl": "https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/solution",
        "problemsDesc": "<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n输入：s = \"abaccdeff\"\n输出：'b'\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n输入：s = \"\" \n输出：' '\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 &lt;= s 的长度 &lt;= 50000</code></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2899数组中的逆序对",
        "hardRate": "HARD",
        "passRate": "49.54%",
        "problemsUrl": "https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution",
        "problemsDesc": "<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入</strong>: [7,5,6,4]\n<strong>输出</strong>: 5</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 &lt;= 数组长度 &lt;= 50000</code></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2900两个链表的第一个公共节点",
        "hardRate": "EASY",
        "passRate": "65.65%",
        "problemsUrl": "https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/solution",
        "problemsDesc": "<p>输入两个链表，找出它们的第一个公共节点。</p>\n\n<p>如下面的两个链表<strong>：</strong></p>\n\n<p><a href=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\" style=\"height: 130px; width: 400px;\"></a></p>\n\n<p>在节点 c1 开始相交。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png\" style=\"height: 130px; width: 400px;\"></a></p>\n\n<pre><strong>输入：</strong>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n<strong>输出：</strong>Reference of the node with value = 8\n<strong>输入解释：</strong>相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png\" style=\"height: 136px; width: 350px;\"></a></p>\n\n<pre><strong>输入：</strong>intersectVal&nbsp;= 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n<strong>输出：</strong>Reference of the node with value = 2\n<strong>输入解释：</strong>相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png\" style=\"height: 126px; width: 200px;\"></a></p>\n\n<pre><strong>输入：</strong>intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n<strong>输出：</strong>null\n<strong>输入解释：</strong>从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n<strong>解释：</strong>这两个链表不相交，因此返回 null。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>如果两个链表没有交点，返回 <code>null</code>.</li>\n\t<li>在返回结果后，两个链表仍须保持原有的结构。</li>\n\t<li>可假定整个链表结构中没有循环。</li>\n\t<li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li>\n\t<li>本题与主站 160 题相同：<a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2901在排序数组中查找数字 I",
        "hardRate": "EASY",
        "passRate": "52.76%",
        "problemsUrl": "https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution",
        "problemsDesc": "<p>统计一个数字在排序数组中出现的次数。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [<code>5,7,7,8,8,10]</code>, target = 8\n<strong>输出:</strong> 2</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [<code>5,7,7,8,8,10]</code>, target = 6\n<strong>输出:</strong> 0</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code></li>\n\t<li><code>nums</code> 是一个非递减数组</li>\n\t<li><code>-10<sup>9</sup> <= target <= 10<sup>9</sup></code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>注意：</strong>本题与主站 34 题相同（仅返回值不同）：<a href=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/\">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 29020～n-1中缺失的数字",
        "hardRate": "EASY",
        "passRate": "44.84%",
        "problemsUrl": "https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/solution",
        "problemsDesc": "<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> [0,1,3]\n<strong>输出:</strong> 2\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> [0,1,2,3,4,5,6,7,9]\n<strong>输出:</strong> 8</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>1 &lt;= 数组长度 &lt;= 10000</code></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2903二叉搜索树的第k大节点",
        "hardRate": "EASY",
        "passRate": "76.45%",
        "problemsUrl": "https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/solution",
        "problemsDesc": "<p>给定一棵二叉搜索树，请找出其中第 <code>k</code> 大的节点的值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> root = [3,1,4,null,2], k = 1\n   3\n  / \\\n 1   4\n  \\\n&nbsp;  2\n<strong>输出:</strong> 4</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> root = [5,3,6,2,4,null,null,1], k = 3\n       5\n      / \\\n     3   6\n    / \\\n   2   4\n  /\n 1\n<strong>输出:</strong> 4</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li>1 ≤ k ≤ 二叉搜索树元素个数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2904二叉树的深度",
        "hardRate": "EASY",
        "passRate": "79.48%",
        "problemsUrl": "https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/solution",
        "problemsDesc": "<p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>\n\n<p>例如：</p>\n\n<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>\n\n<pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7</pre>\n\n<p>返回它的最大深度&nbsp;3 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>节点总数 &lt;= 10000</code></li>\n</ol>\n\n<p>注意：本题与主站 104&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2905平衡二叉树",
        "hardRate": "EASY",
        "passRate": "59.66%",
        "problemsUrl": "https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/solution",
        "problemsDesc": "<p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p>\n\n<pre>\n    3\n   / \\\n  9  20\n    /  \\\n   15   7</pre>\n\n<p>返回 <code>true</code> 。<br />\n<br />\n<strong>示例 2:</strong></p>\n\n<p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p>\n\n<pre>\n       1\n      / \\\n     2   2\n    / \\\n   3   3\n  / \\\n 4   4\n</pre>\n\n<p>返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>0 <= 树的结点个数 <= 10000</code></li>\n</ul>\n\n<p>注意：本题与主站 110 题相同：<a href=\"https://leetcode-cn.com/problems/balanced-binary-tree/\">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p>\n\n<p> </p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2906数组中数字出现的次数",
        "hardRate": "MEDIUM",
        "passRate": "68.83%",
        "problemsUrl": "https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution",
        "problemsDesc": "<p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,1,4,6]\n<strong>输出：</strong>[1,6] 或 [6,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,10,4,1,4,3,3]\n<strong>输出：</strong>[2,10] 或 [10,2]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2907数组中数字出现的次数 II",
        "hardRate": "MEDIUM",
        "passRate": "80.66%",
        "problemsUrl": "https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solution",
        "problemsDesc": "<p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,4,3,3]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [9,1,7,9,7,9,7]\n<strong>输出：</strong>1</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt; 2^31</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2908和为s的两个数字",
        "hardRate": "EASY",
        "passRate": "67.96%",
        "problemsUrl": "https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/solution",
        "problemsDesc": "<p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,7,11,15], target = 9\n<strong>输出：</strong>[2,7] 或者 [7,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [10,26,30,31,47,60], target = 40\n<strong>输出：</strong>[10,30] 或者 [30,10]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= nums[i]&nbsp;&lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2909和为s的连续正数序列",
        "hardRate": "EASY",
        "passRate": "71.27%",
        "problemsUrl": "https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution",
        "problemsDesc": "<p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</p>\n\n<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>target = 9\n<strong>输出：</strong>[[2,3,4],[4,5]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>target = 15\n<strong>输出：</strong>[[1,2,3,4,5],[4,5,6],[7,8]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target &lt;= 10^5</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2910翻转单词顺序",
        "hardRate": "EASY",
        "passRate": "44.73%",
        "problemsUrl": "https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/solution",
        "problemsDesc": "<p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串&quot;I am a student. &quot;，则输出&quot;student. a am I&quot;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入:</strong> &quot;<code>the sky is blue</code>&quot;\n<strong>输出:&nbsp;</strong>&quot;<code>blue is sky the</code>&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入:</strong> &quot; &nbsp;hello world! &nbsp;&quot;\n<strong>输出:&nbsp;</strong>&quot;world! hello&quot;\n<strong>解释: </strong>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入:</strong> &quot;a good &nbsp; example&quot;\n<strong>输出:&nbsp;</strong>&quot;example good a&quot;\n<strong>解释: </strong>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>无空格字符构成一个单词。</li>\n\t<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>\n\t<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li>\n</ul>\n\n<p><strong>注意：</strong>本题与主站 151 题相同：<a href=\"https://leetcode-cn.com/problems/reverse-words-in-a-string/\">https://leetcode-cn.com/problems/reverse-words-in-a-string/</a></p>\n\n<p><strong>注意：</strong>此题对比原题有改动</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2911左旋转字符串",
        "hardRate": "EASY",
        "passRate": "85.75%",
        "problemsUrl": "https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/solution",
        "problemsDesc": "<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入:</strong> s = &quot;abcdefg&quot;, k = 2\n<strong>输出:&nbsp;</strong>&quot;cdefgab&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入:</strong> s = &quot;lrloseumgh&quot;, k = 6\n<strong>输出:&nbsp;</strong>&quot;umghlrlose&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt; s.length &lt;= 10000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2912滑动窗口的最大值",
        "hardRate": "HARD",
        "passRate": "45.01%",
        "problemsUrl": "https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solution",
        "problemsDesc": "<p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>\n<strong>输入:</strong> <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>, 和 <em>k</em> = 3\n<strong>输出: </strong><code>[3,3,5,5,6,7] \n<strong>解释: \n</strong></code>\n  滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<p>你可以假设 <em>k </em>总是有效的，在输入数组&nbsp;<strong>不为空&nbsp;</strong>的情况下，<code>1 ≤ k ≤&nbsp;nums.length</code>。</p>\n\n<p>注意：本题与主站 239 题相同：<a href=\"https://leetcode-cn.com/problems/sliding-window-maximum/\">https://leetcode-cn.com/problems/sliding-window-maximum/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2913队列的最大值",
        "hardRate": "MEDIUM",
        "passRate": "48.00%",
        "problemsUrl": "https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/solution",
        "problemsDesc": "<p>请定义一个队列并实现函数 <code>max_value</code> 得到队列里的最大值，要求函数<code>max_value</code>、<code>push_back</code> 和 <code>pop_front</code> 的<strong>均摊</strong>时间复杂度都是O(1)。</p>\n\n<p>若队列为空，<code>pop_front</code> 和 <code>max_value</code>&nbsp;需要返回 -1</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入:</strong> \n[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]\n[[],[1],[2],[],[],[]]\n<strong>输出:&nbsp;</strong>[null,null,null,2,1,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入:</strong> \n[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]\n[[],[],[]]\n<strong>输出:&nbsp;</strong>[null,-1,-1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= push_back,pop_front,max_value的总操作数&nbsp;&lt;= 10000</code></li>\n\t<li><code>1 &lt;= value &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2914n个骰子的点数",
        "hardRate": "MEDIUM",
        "passRate": "57.40%",
        "problemsUrl": "https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/solution",
        "problemsDesc": "<p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>\n\n<p>&nbsp;</p>\n\n<p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> 1\n<strong>输出:</strong> [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> 2\n<strong>输出:</strong> [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>1 &lt;= n &lt;= 11</code></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2915扑克牌中的顺子",
        "hardRate": "EASY",
        "passRate": "45.36%",
        "problemsUrl": "https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/solution",
        "problemsDesc": "<p>从<strong>若干副扑克牌</strong>中随机抽 <code>5</code> 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> [1,2,3,4,5]\n<strong>输出:</strong> True</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> [0,0,1,2,5]\n<strong>输出:</strong> True</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p>数组长度为 5&nbsp;</p>\n\n<p>数组的数取值为 [0, 13] .</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2916圆圈中最后剩下的数字",
        "hardRate": "EASY",
        "passRate": "65.48%",
        "problemsUrl": "https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution",
        "problemsDesc": "<p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p>\n\n<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 5, m = 3\n<strong>输出: </strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 10, m = 17\n<strong>输出: </strong>2\n</pre>\n\n<p> </p>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 10^5</code></li>\n\t<li><code>1 <= m <= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2917股票的最大利润",
        "hardRate": "MEDIUM",
        "passRate": "62.95%",
        "problemsUrl": "https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/solution",
        "problemsDesc": "<p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> [7,1,5,3,6,4]\n<strong>输出:</strong> 5\n<strong>解释: </strong>在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> [7,6,4,3,1]\n<strong>输出:</strong> 0\n<strong>解释: </strong>在这种情况下, 没有交易完成, 所以最大利润为 0。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 &lt;= 数组长度 &lt;= 10^5</code></p>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与主站 121 题相同：<a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/\">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2918求1+2+…+n",
        "hardRate": "MEDIUM",
        "passRate": "85.93%",
        "problemsUrl": "https://leetcode.cn/problems/qiu-12n-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/qiu-12n-lcof/solution",
        "problemsDesc": "<p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入:</strong> n = 3\n<strong>输出:&nbsp;</strong>6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入:</strong> n = 9\n<strong>输出:&nbsp;</strong>45\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n&nbsp;&lt;= 10000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2919不用加减乘除做加法",
        "hardRate": "EASY",
        "passRate": "59.58%",
        "problemsUrl": "https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution",
        "problemsDesc": "<p>写一个函数，求两个整数之和，要求在函数体内不得使用 &ldquo;+&rdquo;、&ldquo;-&rdquo;、&ldquo;*&rdquo;、&ldquo;/&rdquo; 四则运算符号。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> a = 1, b = 1\n<strong>输出:</strong> 2</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>a</code>,&nbsp;<code>b</code>&nbsp;均可能是负数或 0</li>\n\t<li>结果不会溢出 32 位整数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2920构建乘积数组",
        "hardRate": "MEDIUM",
        "passRate": "58.62%",
        "problemsUrl": "https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/solution",
        "problemsDesc": "<p>给定一个数组 <code>A[0,1,…,n-1]</code>，请构建一个数组 <code>B[0,1,…,n-1]</code>，其中 <code>B[i]</code> 的值是数组 <code>A</code> 中除了下标 <code>i</code> 以外的元素的积, 即 <code>B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]</code>。不能使用除法。</p>\n\n<p> </p>\n\n<p><strong>示例:</strong></p>\n\n<pre>\n<strong>输入:</strong> [1,2,3,4,5]\n<strong>输出:</strong> [120,60,40,30,24]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>所有元素乘积之和不会溢出 32 位整数</li>\n\t<li><code>a.length <= 100000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2921把字符串转换成整数",
        "hardRate": "MEDIUM",
        "passRate": "28.52%",
        "problemsUrl": "https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/solution",
        "problemsDesc": "<p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p>\n\n<p>&nbsp;</p>\n\n<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>\n\n<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>\n\n<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>\n\n<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>\n\n<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>\n\n<p><strong>说明：</strong></p>\n\n<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为&nbsp;[&minus;2<sup>31</sup>,&nbsp; 2<sup>31&nbsp;</sup>&minus; 1]。如果数值超过这个范围，请返回 &nbsp;INT_MAX (2<sup>31&nbsp;</sup>&minus; 1) 或&nbsp;INT_MIN (&minus;2<sup>31</sup>) 。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:</strong> &quot;42&quot;\n<strong>输出:</strong> 42\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> &quot;   -42&quot;\n<strong>输出:</strong> -42\n<strong>解释: </strong>第一个非空白字符为 &#39;-&#39;, 它是一个负号。\n&nbsp;    我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。\n</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre><strong>输入:</strong> &quot;4193 with words&quot;\n<strong>输出:</strong> 4193\n<strong>解释:</strong> 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。\n</pre>\n\n<p><strong>示例&nbsp;4:</strong></p>\n\n<pre><strong>输入:</strong> &quot;words and 987&quot;\n<strong>输出:</strong> 0\n<strong>解释:</strong> 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。\n     因此无法执行有效的转换。</pre>\n\n<p><strong>示例&nbsp;5:</strong></p>\n\n<pre><strong>输入:</strong> &quot;-91283472332&quot;\n<strong>输出:</strong> -2147483648\n<strong>解释:</strong> 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 \n&nbsp;    因此返回 INT_MIN (&minus;2<sup>31</sup>) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 8 题相同：<a href=\"https://leetcode-cn.com/problems/string-to-integer-atoi/\">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2922二叉搜索树的最近公共祖先",
        "hardRate": "EASY",
        "passRate": "69.29%",
        "problemsUrl": "https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution",
        "problemsDesc": "<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>\n\n<p><a href=\"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin\" target=\"_blank\">百度百科</a>中最近公共祖先的定义为：&ldquo;对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。&rdquo;</p>\n\n<p>例如，给定如下二叉搜索树:&nbsp; root =&nbsp;[6,2,8,0,4,7,9,null,null,3,5]</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n<strong>输出:</strong> 6 \n<strong>解释: </strong>节点 <code>2 </code>和节点 <code>8 </code>的最近公共祖先是 <code>6。</code>\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n<strong>输出:</strong> 2\n<strong>解释: </strong>节点 <code>2</code> 和节点 <code>4</code> 的最近公共祖先是 <code>2</code>, 因为根据定义最近公共祖先节点可以为节点本身。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li>所有节点的值都是唯一的。</li>\n\t<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>\n</ul>\n\n<p>注意：本题与主站 235 题相同：<a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/\">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2923二叉树的最近公共祖先",
        "hardRate": "EASY",
        "passRate": "70.32%",
        "problemsUrl": "https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution",
        "problemsDesc": "<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>\n\n<p><a href=\"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin\" target=\"_blank\">百度百科</a>中最近公共祖先的定义为：&ldquo;对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。&rdquo;</p>\n\n<p>例如，给定如下二叉树:&nbsp; root =&nbsp;[3,5,1,6,2,0,8,null,null,7,4]</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n<strong>输出:</strong> 3\n<strong>解释: </strong>节点 <code>5 </code>和节点 <code>1 </code>的最近公共祖先是节点 <code>3。</code>\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n<strong>输出:</strong> 5\n<strong>解释: </strong>节点 <code>5 </code>和节点 <code>4 </code>的最近公共祖先是节点 <code>5。</code>因为根据定义最近公共祖先节点可以为节点本身。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li>所有节点的值都是唯一的。</li>\n\t<li>p、q 为不同节点且均存在于给定的二叉树中。</li>\n</ul>\n\n<p>注意：本题与主站 236 题相同：<a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/\">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2924整数除法",
        "hardRate": "EASY",
        "passRate": "21.05%",
        "problemsUrl": "https://leetcode.cn/problems/xoh6Oh/",
        "solutionsUrl": "https://leetcode.cn/problems/xoh6Oh/solution",
        "problemsDesc": "<p>给定两个整数 <code>a</code> 和 <code>b</code> ，求它们的除法的商 <code>a/b</code> ，要求不得使用乘号 <code>&#39;*&#39;</code>、除号 <code>&#39;/&#39;</code> 以及求余符号 <code>&#39;%&#39;</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>整数除法的结果应当截去（<code>truncate</code>）其小数部分，例如：<code>truncate(8.345) = 8</code>&nbsp;以及&nbsp;<code>truncate(-2.7335) = -2</code></li>\n\t<li>假设我们的环境只能存储 32 位有符号整数，其数值范围是 <code>[&minus;2<sup>31</sup>,&nbsp;2<sup>31</sup>&minus;1]</code>。本题中，如果除法结果溢出，则返回 <code>2<sup>31&nbsp;</sup>&minus; 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 15, b = 2\n<strong>输出：</strong>7\n<strong><span style=\"white-space: pre-wrap;\">解释：</span></strong>15/2 = truncate(7.5) = 7\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 7, b = -3\n<strong>输出：</strong><span style=\"white-space: pre-wrap;\">-2</span>\n<strong><span style=\"white-space: pre-wrap;\">解释：</span></strong>7/-3 = truncate(-2.33333..) = -2</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 0, b = 1\n<strong>输出：</strong><span style=\"white-space: pre-wrap;\">0</span></pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 1, b = 1\n<strong>输出：</strong><span style=\"white-space: pre-wrap;\">1</span></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= a, b &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n\t<li><code>b != 0</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 29&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/divide-two-integers/\">https://leetcode-cn.com/problems/divide-two-integers/</a></p>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2925二进制加法",
        "hardRate": "EASY",
        "passRate": "53.80%",
        "problemsUrl": "https://leetcode.cn/problems/JFETK5/",
        "solutionsUrl": "https://leetcode.cn/problems/JFETK5/solution",
        "problemsDesc": "<p>给定两个 01 字符串&nbsp;<code>a</code>&nbsp;和&nbsp;<code>b</code>&nbsp;，请计算它们的和，并以二进制字符串的形式输出。</p>\n\n<p>输入为 <strong>非空 </strong>字符串且只包含数字&nbsp;<code>1</code>&nbsp;和&nbsp;<code>0</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> a = &quot;11&quot;, b = &quot;10&quot;\n<strong>输出:</strong> &quot;101&quot;</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> a = &quot;1010&quot;, b = &quot;1011&quot;\n<strong>输出:</strong> &quot;10101&quot;</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每个字符串仅由字符 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code> 组成。</li>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 10^4</code></li>\n\t<li>字符串如果不是 <code>&quot;0&quot;</code> ，就都不含前导零。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 67&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/add-binary/\">https://leetcode-cn.com/problems/add-binary/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2926前 n 个数字二进制中 1 的个数",
        "hardRate": "EASY",
        "passRate": "78.18%",
        "problemsUrl": "https://leetcode.cn/problems/w3tCBm/",
        "solutionsUrl": "https://leetcode.cn/problems/w3tCBm/solution",
        "problemsDesc": "<p>给定一个非负整数 <code>n</code><b>&nbsp;</b>，请计算 <code>0</code> 到 <code>n</code> 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>n =<strong> </strong>2\n<strong>输出: </strong>[0,1,1]\n<strong>解释: \n</strong>0 --&gt; 0\n1 --&gt; 1\n2 --&gt; 10\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入: </strong>n =<strong> </strong>5\n<strong>输出: </strong><code>[0,1,1,2,1,2]\n</code><span style=\"white-space: pre-wrap;\"><strong>解释:</strong>\n</span>0 --&gt; 0\n1 --&gt; 1\n2 --&gt; 10\n3 --&gt; 11\n4 --&gt; 100\n5 --&gt; 101\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>说明 :</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶:</strong></p>\n\n<ul>\n\t<li>给出时间复杂度为&nbsp;<code>O(n*sizeof(integer))</code><strong>&nbsp;</strong>的解答非常容易。但你可以在线性时间&nbsp;<code>O(n)</code><strong>&nbsp;</strong>内用一趟扫描做到吗？</li>\n\t<li>要求算法的空间复杂度为&nbsp;<code>O(n)</code>&nbsp;。</li>\n\t<li>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的&nbsp;<code>__builtin_popcount</code><strong>&nbsp;</strong>）来执行此操作。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 338&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/counting-bits/\">https://leetcode-cn.com/problems/counting-bits/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2927只出现一次的数字 ",
        "hardRate": "MEDIUM",
        "passRate": "70.81%",
        "problemsUrl": "https://leetcode.cn/problems/WGki4K/",
        "solutionsUrl": "https://leetcode.cn/problems/WGki4K/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次 。</strong>请你找出并返回那个只出现了一次的元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,3,2]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,0,1,0,1,100]\n<strong>输出：</strong>100\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>nums</code> 中，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 137&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/single-number-ii/\">https://leetcode-cn.com/problems/single-number-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2928单词长度的最大乘积",
        "hardRate": "MEDIUM",
        "passRate": "71.17%",
        "problemsUrl": "https://leetcode.cn/problems/aseY1I/",
        "solutionsUrl": "https://leetcode.cn/problems/aseY1I/solution",
        "problemsDesc": "<p>给定一个字符串数组&nbsp;<code>words</code>，请计算当两个字符串 <code>words[i]</code> 和 <code>words[j]</code> 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> words = <code>[&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;fxyz&quot;,&quot;abcdef&quot;]</code>\n<strong>输出: </strong><code>16 \n<strong>解释:</strong> 这两个单词为<strong> </strong></code><code>&quot;abcw&quot;, &quot;fxyz&quot;</code>。它们不包含相同字符，且长度的乘积最大。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> words = <code>[&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;bcd&quot;,&quot;abcd&quot;]</code>\n<strong>输出: </strong><code>4 \n<strong>解释: </strong></code>这两个单词为 <code>&quot;ab&quot;, &quot;cd&quot;</code>。</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> words = <code>[&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]</code>\n<strong>输出: </strong><code>0 \n<strong>解释: </strong>不存在这样的两个单词。</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 1000</code></li>\n\t<li><code>words[i]</code>&nbsp;仅包含小写字母</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 318&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/maximum-product-of-word-lengths/\">https://leetcode-cn.com/problems/maximum-product-of-word-lengths/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2929排序数组中两个数字之和",
        "hardRate": "EASY",
        "passRate": "67.34%",
        "problemsUrl": "https://leetcode.cn/problems/kLl5u1/",
        "solutionsUrl": "https://leetcode.cn/problems/kLl5u1/solution",
        "problemsDesc": "<p>给定一个已按照<strong><em> </em>升序排列&nbsp; </strong>的整数数组&nbsp;<code>numbers</code> ，请你从数组中找出两个数满足相加之和等于目标数&nbsp;<code>target</code> 。</p>\n\n<p>函数应该以长度为 <code>2</code> 的整数数组的形式返回这两个数的下标值<em>。</em><code>numbers</code> 的下标 <strong>从 0&nbsp;开始计数</strong> ，所以答案数组应当满足 <code>0&nbsp;&lt;= answer[0] &lt; answer[1] &lt;&nbsp;numbers.length</code>&nbsp;。</p>\n\n<p>假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>numbers = [1,2,4,6,10], target = 8\n<strong>输出：</strong>[1,3]\n<strong>解释：</strong>2 与 6 之和等于目标数 8 。因此 index1 = 1, index2 = 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>numbers = [2,3,4], target = 6\n<strong>输出：</strong>[0,2]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>numbers = [-1,0], target = -1\n<strong>输出：</strong>[0,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= numbers.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>\n\t<li><code>numbers</code> 按 <strong>非递减顺序</strong> 排列</li>\n\t<li><code>-1000 &lt;= target &lt;= 1000</code></li>\n\t<li>仅存在一个有效答案</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 167 题相似（下标起点不同）：<a href=\"https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/\">https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2930数组中和为 0 的三个数",
        "hardRate": "MEDIUM",
        "passRate": "43.61%",
        "problemsUrl": "https://leetcode.cn/problems/1fGaJU/",
        "solutionsUrl": "https://leetcode.cn/problems/1fGaJU/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p>\n\n<p>你返回所有和为 <code>0</code> 且不重复的三元组。</p>\n\n<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,0,1,2,-1,-4]\n<strong>输出：</strong>[[-1,-1,2],[-1,0,1]]\n<strong>解释：</strong>\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,1]\n<strong>输出：</strong>[]\n<strong>解释：</strong>唯一可能的三元组和不为 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,0,0]\n<strong>输出：</strong>[[0,0,0]]\n<strong>解释：</strong>唯一可能的三元组和为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 3000</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n&nbsp;\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 15&nbsp;题相同：<a href=\"https://leetcode.cn/problems/3sum/\">leetcode.cn/problems/3sum/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2931和大于等于 target 的最短子数组",
        "hardRate": "MEDIUM",
        "passRate": "49.83%",
        "problemsUrl": "https://leetcode.cn/problems/2VG8Kg/",
        "solutionsUrl": "https://leetcode.cn/problems/2VG8Kg/solution",
        "problemsDesc": "<p>给定一个含有&nbsp;<code>n</code><strong>&nbsp;</strong>个正整数的数组和一个正整数 <code>target</code><strong> 。</strong></p>\n\n<p>找出该数组中满足其和<strong> </strong><code>&ge; target</code><strong> </strong>的长度最小的 <strong>连续子数组</strong>&nbsp;<code>[nums<sub>l</sub>, nums<sub>l+1</sub>, ..., nums<sub>r-1</sub>, nums<sub>r</sub>]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 7, nums = [2,3,1,2,4,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>子数组&nbsp;<code>[4,3]</code>&nbsp;是该条件下的长度最小的子数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 4, nums = [1,4,4]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 11, nums = [1,1,1,1,1,1,1,1]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p>提示：</p>\n\n<ul>\n\t<li><code>1 &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>进阶：</p>\n\n<ul>\n\t<li>如果你已经实现<em> </em><code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 209&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/minimum-size-subarray-sum/\">https://leetcode-cn.com/problems/minimum-size-subarray-sum/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2932乘积小于 K 的子数组",
        "hardRate": "MEDIUM",
        "passRate": "53.15%",
        "problemsUrl": "https://leetcode.cn/problems/ZVAVXX/",
        "solutionsUrl": "https://leetcode.cn/problems/ZVAVXX/solution",
        "problemsDesc": "<p>给定一个正整数数组&nbsp;<code>nums</code>和整数 <code>k</code>&nbsp;，请找出该数组内乘积小于&nbsp;<code>k</code>&nbsp;的连续的子数组的个数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [10,5,2,6], k = 100\n<strong>输出:</strong> 8\n<strong>解释:</strong> 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。\n需要注意的是 [10,5,2] 并不是乘积小于100的子数组。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,3], k = 0\n<strong>输出:</strong> 0</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:&nbsp;</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>6</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 713&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/subarray-product-less-than-k/\">https://leetcode-cn.com/problems/subarray-product-less-than-k/</a>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2933和为 k 的子数组",
        "hardRate": "MEDIUM",
        "passRate": "42.99%",
        "problemsUrl": "https://leetcode.cn/problems/QTMn0o/",
        "solutionsUrl": "https://leetcode.cn/problems/QTMn0o/solution",
        "problemsDesc": "<p>给定一个整数数组和一个整数&nbsp;<code>k</code><strong> ，</strong>请找到该数组中和为&nbsp;<code>k</code><strong>&nbsp;</strong>的连续子数组的个数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong>nums = [1,1,1], k = 2\n<strong>输出:</strong> 2\n<strong>解释:</strong> 此题 [1,1] 与 [1,1] 为两种不同的情况\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong>nums = [1,2,3], k = 3\n<strong>输出:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>\n\t<p><code>-10<sup>7</sup>&nbsp;&lt;= k &lt;= 10<sup>7</sup></code></p>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 560&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/subarray-sum-equals-k/\">https://leetcode-cn.com/problems/subarray-sum-equals-k/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 29340 和 1 个数相同的子数组",
        "hardRate": "MEDIUM",
        "passRate": "54.88%",
        "problemsUrl": "https://leetcode.cn/problems/A1NYOS/",
        "solutionsUrl": "https://leetcode.cn/problems/A1NYOS/solution",
        "problemsDesc": "<p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [0,1]\n<strong>输出:</strong> 2\n<strong>说明:</strong> [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [0,1,0]\n<strong>输出:</strong> 2\n<strong>说明:</strong> [0, 1] (或 [1, 0]) 是具有相同数量 0 和 1 的最长连续子数组。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 525&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/contiguous-array/\">https://leetcode-cn.com/problems/contiguous-array/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2935左右两边子数组的和相等",
        "hardRate": "EASY",
        "passRate": "67.05%",
        "problemsUrl": "https://leetcode.cn/problems/tvdfij/",
        "solutionsUrl": "https://leetcode.cn/problems/tvdfij/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code> ，请计算数组的 <strong>中心下标 </strong>。</p>\n\n<p>数组<strong> 中心下标</strong><strong> </strong>是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p>\n\n<p>如果中心下标位于数组最左端，那么左侧数之和视为 <code>0</code> ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p>\n\n<p>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,7,3,6,5,6]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n中心下标是 3 。\n左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，\n右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1, 2, 3]\n<strong>输出：</strong>-1\n<strong>解释：</strong>\n数组中不存在满足此条件的中心下标。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2, 1, -1]\n<strong>输出：</strong>0\n<strong>解释：</strong>\n中心下标是 0 。\n左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），\n右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 724&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/find-pivot-index/\">https://leetcode-cn.com/problems/find-pivot-index/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2936二维子矩阵的和",
        "hardRate": "MEDIUM",
        "passRate": "68.93%",
        "problemsUrl": "https://leetcode.cn/problems/O4NDxx/",
        "solutionsUrl": "https://leetcode.cn/problems/O4NDxx/solution",
        "problemsDesc": "<p><big><small>给定一个二维矩阵 <code>matrix</code>，</small></big>以下类型的多个请求：</p>\n\n<ul>\n\t<li><big><small>计算其子矩形范围内元素的总和，该子矩阵的左上角为 <code>(row1,&nbsp;col1)</code> ，右下角为 <code>(row2,&nbsp;col2)</code> 。</small></big></li>\n</ul>\n\n<p>实现 <code>NumMatrix</code> 类：</p>\n\n<ul>\n\t<li><code>NumMatrix(int[][] matrix)</code>&nbsp;给定整数矩阵 <code>matrix</code> 进行初始化</li>\n\t<li><code>int sumRegion(int row1, int col1, int row2, int col2)</code>&nbsp;返回<big><small>左上角</small></big><big><small> <code>(row1,&nbsp;col1)</code>&nbsp;、右下角&nbsp;<code>(row2,&nbsp;col2)</code></small></big>&nbsp;的子矩阵的元素总和。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://pic.leetcode-cn.com/1626332422-wUpUHT-image.png\" style=\"width: 200px;\" /></p>\n\n<pre>\n<strong>输入:</strong> \n[&quot;NumMatrix&quot;,&quot;sumRegion&quot;,&quot;sumRegion&quot;,&quot;sumRegion&quot;]\n[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]\n<strong>输出:</strong> \n[null, 8, 11, 12]\n\n<strong>解释:</strong>\nNumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]]);\nnumMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和)\nnumMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和)\nnumMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和)\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m,&nbsp;n &lt;=&nbsp;200</code><meta charset=\"UTF-8\" /></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= matrix[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= row1 &lt;= row2 &lt; m</code></li>\n\t<li><code>0 &lt;= col1 &lt;= col2 &lt; n</code></li>\n\t<li><meta charset=\"UTF-8\" />最多调用 <code>10<sup>4</sup></code> 次&nbsp;<code>sumRegion</code> 方法</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 304&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/range-sum-query-2d-immutable/\">https://leetcode-cn.com/problems/range-sum-query-2d-immutable/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2937字符串中的变位词",
        "hardRate": "MEDIUM",
        "passRate": "51.48%",
        "problemsUrl": "https://leetcode.cn/problems/MPnaiL/",
        "solutionsUrl": "https://leetcode.cn/problems/MPnaiL/solution",
        "problemsDesc": "<p>给定两个字符串&nbsp;<code>s1</code>&nbsp;和&nbsp;<code>s2</code>，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code><strong>&nbsp;</strong>的某个变位词。</p>\n\n<p>换句话说，第一个字符串的排列之一是第二个字符串的 <strong>子串</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;\n<strong>输出: </strong>True\n<strong>解释:</strong> s2 包含 s1 的排列之一 (&quot;ba&quot;).\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;\n<strong>输出:</strong> False\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s1</code> 和 <code>s2</code> 仅包含小写字母</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 567&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/permutation-in-string/\">https://leetcode-cn.com/problems/permutation-in-string/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2938字符串中的所有变位词",
        "hardRate": "MEDIUM",
        "passRate": "61.74%",
        "problemsUrl": "https://leetcode.cn/problems/VabMRr/",
        "solutionsUrl": "https://leetcode.cn/problems/VabMRr/solution",
        "problemsDesc": "<p>给定两个字符串&nbsp;<code>s</code>&nbsp;和<b>&nbsp;</b><code>p</code>，找到&nbsp;<code>s</code><strong>&nbsp;</strong>中所有 <code>p</code> 的&nbsp;<strong>变位词&nbsp;</strong>的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>\n\n<p><strong>变位词 </strong>指字母相同，但排列不同的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入: </strong>s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;\n<strong>输出: </strong>[0,6]\n<strong>解释:</strong>\n起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的变位词。\n起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的变位词。\n</pre>\n\n<p><strong>&nbsp;示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>s = &quot;abab&quot;, p = &quot;ab&quot;\n<strong>输出: </strong>[0,1,2]\n<strong>解释:</strong>\n起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的变位词。\n起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的变位词。\n起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的变位词。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, p.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>s</code>&nbsp;和 <code>p</code> 仅包含小写字母</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 438&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/\" style=\"background-color: rgb(255, 255, 255);\">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2939不含重复字符的最长子字符串",
        "hardRate": "MEDIUM",
        "passRate": "47.58%",
        "problemsUrl": "https://leetcode.cn/problems/wtcaE1/",
        "solutionsUrl": "https://leetcode.cn/problems/wtcaE1/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的&nbsp;<strong>最长连续子字符串&nbsp;</strong>的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = &quot;abcabcbb&quot;\n<strong>输出: </strong>3 \n<strong>解释:</strong> 因为无重复字符的最长子字符串是 <code>&quot;abc&quot;，所以其</code>长度为 3。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = &quot;bbbbb&quot;\n<strong>输出: </strong>1\n<strong>解释: </strong>因为无重复字符的最长子字符串是 <code>&quot;b&quot;</code>，所以其长度为 1。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = &quot;pwwkew&quot;\n<strong>输出: </strong>3\n<strong>解释: </strong>因为无重复字符的最长子串是&nbsp;<code>&quot;wke&quot;</code>，所以其长度为 3。\n&nbsp;    请注意，你的答案必须是 <strong>子串 </strong>的长度，<code>&quot;pwke&quot;</code>&nbsp;是一个<em>子序列，</em>不是子串。\n</pre>\n\n<p><strong>示例 4:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = &quot;&quot;\n<strong>输出: </strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code>&nbsp;由英文字母、数字、符号和空格组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 3&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2940含有所有字符的最短字符串",
        "hardRate": "HARD",
        "passRate": "50.87%",
        "problemsUrl": "https://leetcode.cn/problems/M1oyTv/",
        "solutionsUrl": "https://leetcode.cn/problems/M1oyTv/solution",
        "problemsDesc": "<p>给定两个字符串 <code>s</code> 和&nbsp;<code>t</code> 。返回 <code>s</code> 中包含&nbsp;<code>t</code>&nbsp;的所有字符的最短子字符串。如果 <code>s</code> 中不存在符合条件的子字符串，则返回空字符串 <code>&quot;&quot;</code> 。</p>\n\n<p>如果 <code>s</code> 中存在多个符合条件的子字符串，返回任意一个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>注意： </strong>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;\n<strong>输出：</strong>&quot;BANC&quot; \n<strong>解释：</strong>最短子字符串 &quot;BANC&quot; 包含了字符串 t 的所有字符 &#39;A&#39;、&#39;B&#39;、&#39;C&#39;</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;a&quot;, t = &quot;a&quot;\n<strong>输出：</strong>&quot;a&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;a&quot;, t = &quot;aa&quot;\n<strong>输出：</strong>&quot;&quot;\n<strong>解释：</strong>t 中两个字符 &#39;a&#39; 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能设计一个在 <code>o(n)</code> 时间内解决此问题的算法吗？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 76&nbsp;题相似（本题答案不唯一）：<a href=\"https://leetcode-cn.com/problems/minimum-window-substring/\">https://leetcode-cn.com/problems/minimum-window-substring/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2941有效的回文",
        "hardRate": "EASY",
        "passRate": "51.56%",
        "problemsUrl": "https://leetcode.cn/problems/XltzEq/",
        "solutionsUrl": "https://leetcode.cn/problems/XltzEq/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code> ，验证 <code>s</code>&nbsp;是否是&nbsp;<strong>回文串&nbsp;</strong>，只考虑字母和数字字符，可以忽略字母的大小写。</p>\n\n<p>本题中，将空字符串定义为有效的&nbsp;<strong>回文串&nbsp;</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>s =<strong> </strong>&quot;A man, a plan, a canal: Panama&quot;\n<strong>输出:</strong> true\n<strong>解释：</strong>&quot;amanaplanacanalpanama&quot; 是回文串</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = &quot;race a car&quot;\n<strong>输出:</strong> false\n解释：&quot;raceacar&quot; 不是回文串</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li>字符串 <code>s</code> 由 ASCII 字符组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 125&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/valid-palindrome/\">https://leetcode-cn.com/problems/valid-palindrome/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2942最多删除一个字符得到回文",
        "hardRate": "EASY",
        "passRate": "45.64%",
        "problemsUrl": "https://leetcode.cn/problems/RQku0D/",
        "solutionsUrl": "https://leetcode.cn/problems/RQku0D/solution",
        "problemsDesc": "<p>给定一个非空字符串&nbsp;<code>s</code>，请判断如果&nbsp;<strong>最多 </strong>从字符串中删除一个字符能否得到一个回文字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = &quot;aba&quot;\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = &quot;abca&quot;\n<strong>输出:</strong> true\n<strong>解释:</strong> 可以删除 &quot;c&quot; 字符 或者 &quot;b&quot; 字符\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = &quot;abc&quot;\n<strong>输出:</strong> false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 680&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/valid-palindrome-ii/\">https://leetcode-cn.com/problems/valid-palindrome-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2943回文子字符串的个数",
        "hardRate": "MEDIUM",
        "passRate": "71.74%",
        "problemsUrl": "https://leetcode.cn/problems/a7VOhD/",
        "solutionsUrl": "https://leetcode.cn/problems/a7VOhD/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code> ，请计算这个字符串中有多少个回文子字符串。</p>\n\n<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\"\n<strong>输出：</strong>3\n<strong>解释：</strong>三个回文子串: \"a\", \"b\", \"c\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s =<strong> </strong>\"aaa\"\n<strong>输出：</strong>6\n<strong>解释：</strong>6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\"</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 647 题相同：<a href=\"https://leetcode-cn.com/problems/palindromic-substrings/\">https://leetcode-cn.com/problems/palindromic-substrings/</a>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2944删除链表的倒数第 n 个结点",
        "hardRate": "MEDIUM",
        "passRate": "54.16%",
        "problemsUrl": "https://leetcode.cn/problems/SLwz0R/",
        "solutionsUrl": "https://leetcode.cn/problems/SLwz0R/solution",
        "problemsDesc": "<p>给定一个链表，删除链表的倒数第&nbsp;<code>n</code><em>&nbsp;</em>个结点，并且返回链表的头结点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg\" style=\"width: 542px; height: 222px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], n = 2\n<strong>输出：</strong>[1,2,3,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1], n = 1\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2], n = 1\n<strong>输出：</strong>[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中结点的数目为 <code>sz</code></li>\n\t<li><code>1 &lt;= sz &lt;= 30</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>1 &lt;= n &lt;= sz</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>能尝试使用一趟扫描实现吗？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 19&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2945链表中环的入口节点",
        "hardRate": "MEDIUM",
        "passRate": "55.82%",
        "problemsUrl": "https://leetcode.cn/problems/c32eOV/",
        "solutionsUrl": "https://leetcode.cn/problems/c32eOV/solution",
        "problemsDesc": "<p>给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 <code>next</code> 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回&nbsp;<code>null</code>。</p>\n\n<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意，<code>pos</code> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</strong></p>\n\n<p><strong>说明：</strong>不允许修改给定的链表。</p>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png\" style=\"height: 97px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [3,2,0,-4], pos = 1\n<strong>输出：</strong>返回索引为 1 的链表节点\n<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png\" style=\"height: 74px; width: 141px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2], pos = 0\n<strong>输出：</strong>返回索引为 0 的链表节点\n<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png\" style=\"height: 45px; width: 45px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1], pos = -1\n<strong>输出：</strong>返回 null\n<strong>解释：</strong>链表中没有环。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目范围在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>是否可以使用 <code>O(1)</code> 空间解决此题？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 142&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/\">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2946两个链表的第一个重合节点",
        "hardRate": "EASY",
        "passRate": "70.05%",
        "problemsUrl": "https://leetcode.cn/problems/3u1WK4/",
        "solutionsUrl": "https://leetcode.cn/problems/3u1WK4/solution",
        "problemsDesc": "<p>给定两个单链表的头节点&nbsp;<code>headA</code> 和 <code>headB</code> ，请找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p>\n\n<p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>\n\n<p><a href=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\" style=\"height: 130px; width: 400px;\" /></a></p>\n\n<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>\n\n<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png\" style=\"height: 130px; width: 400px;\" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n<strong>输出：</strong>Intersected at &#39;8&#39;\n<strong>解释：</strong>相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png\" style=\"height: 136px; width: 350px;\" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal&nbsp;= 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n<strong>输出：</strong>Intersected at &#39;2&#39;\n<strong>解释：</strong>相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png\" style=\"height: 126px; width: 200px;\" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n<strong>输出：</strong>null\n<strong>解释：</strong>从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>listA</code> 中节点数目为 <code>m</code></li>\n\t<li><code>listB</code> 中节点数目为 <code>n</code></li>\n\t<li><code>0 &lt;= m, n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= skipA &lt;= m</code></li>\n\t<li><code>0 &lt;= skipB &lt;= n</code></li>\n\t<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>\n\t<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 160&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2947反转链表",
        "hardRate": "EASY",
        "passRate": "75.37%",
        "problemsUrl": "https://leetcode.cn/problems/UHnkqh/",
        "solutionsUrl": "https://leetcode.cn/problems/UHnkqh/solution",
        "problemsDesc": "<p>给定单链表的头节点 <code>head</code> ，请反转链表，并返回反转后的链表的头节点。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg\" style=\"width: 302px; \" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5]\n<strong>输出：</strong>[5,4,3,2,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg\" style=\"width: 102px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2]\n<strong>输出：</strong>[2,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = []\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>\n\t<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 206&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\">https://leetcode-cn.com/problems/reverse-linked-list/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2948链表中的两数相加",
        "hardRate": "MEDIUM",
        "passRate": "58.31%",
        "problemsUrl": "https://leetcode.cn/problems/lMSNwu/",
        "solutionsUrl": "https://leetcode.cn/problems/lMSNwu/solution",
        "problemsDesc": "<p>给定两个 <strong>非空链表</strong> <code>l1</code>和 <code>l2</code>&nbsp;来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>\n\n<p>可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例1：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626420025-fZfzMX-image.png\" style=\"width: 302px; \" /></p>\n\n<pre>\n<strong>输入：</strong>l1 = [7,2,4,3], l2 = [5,6,4]\n<strong>输出：</strong>[7,8,0,7]\n</pre>\n\n<p><strong>示例2：</strong></p>\n\n<pre>\n<strong>输入：</strong>l1 = [2,4,3], l2 = [5,6,4]\n<strong>输出：</strong>[8,0,7]\n</pre>\n\n<p><strong>示例3：</strong></p>\n\n<pre>\n<strong>输入：</strong>l1 = [0], l2 = [0]\n<strong>输出：</strong>[0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表的长度范围为<code> [1, 100]</code></li>\n\t<li><code>0 &lt;= node.val &lt;= 9</code></li>\n\t<li>输入数据保证链表代表的数字无前导 0</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转。</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 445&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/add-two-numbers-ii/\">https://leetcode-cn.com/problems/add-two-numbers-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2949重排链表",
        "hardRate": "MEDIUM",
        "passRate": "66.50%",
        "problemsUrl": "https://leetcode.cn/problems/LGjMqU/",
        "solutionsUrl": "https://leetcode.cn/problems/LGjMqU/solution",
        "problemsDesc": "<p>给定一个单链表 <code>L</code><em> </em>的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p>\n\n<p><code>&nbsp;L<sub>0&nbsp;</sub>&rarr; L<sub>1&nbsp;</sub>&rarr; &hellip; &rarr; L<sub>n-1&nbsp;</sub>&rarr; L<sub>n&nbsp;</sub></code><br />\n请将其重新排列后变为：</p>\n\n<p><code>L<sub>0&nbsp;</sub>&rarr;&nbsp;L<sub>n&nbsp;</sub>&rarr;&nbsp;L<sub>1&nbsp;</sub>&rarr;&nbsp;L<sub>n-1&nbsp;</sub>&rarr;&nbsp;L<sub>2&nbsp;</sub>&rarr;&nbsp;L<sub>n-2&nbsp;</sub>&rarr; &hellip;</code></p>\n\n<p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png\" style=\"width: 240px; \" /></p>\n\n<pre>\n<strong>输入: </strong>head = [1,2,3,4]\n<strong>输出: </strong>[1,4,2,3]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626420320-YUiulT-image.png\" style=\"width: 320px; \" /></p>\n\n<pre>\n<strong>输入: </strong>head = [1,2,3,4,5]\n<strong>输出: </strong>[1,5,2,4,3]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表的长度范围为 <code>[1, 5 * 10<sup>4</sup>]</code></li>\n\t<li><code>1 &lt;= node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 143&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/reorder-list/\">https://leetcode-cn.com/problems/reorder-list/</a>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2950回文链表",
        "hardRate": "EASY",
        "passRate": "61.06%",
        "problemsUrl": "https://leetcode.cn/problems/aMhZSa/",
        "solutionsUrl": "https://leetcode.cn/problems/aMhZSa/solution",
        "problemsDesc": "<p>给定一个链表的 <strong>头节点&nbsp;</strong><code>head</code><strong>&nbsp;，</strong>请判断其是否为回文链表。</p>\n\n<p>如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626421737-LjXceN-image.png\" /></strong></p>\n\n<pre>\n<strong>输入:</strong> head = [1,2,3,3,2,1]\n<strong>输出:</strong> true</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626422231-wgvnWh-image.png\" style=\"width: 138px; height: 62px;\" /></strong></p>\n\n<pre>\n<strong>输入:</strong> head = [1,2]\n<strong>输出:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表 L 的长度范围为 <code>[1, 10<sup><span style=\"font-size: 9.449999809265137px;\">5</span></sup>]</code></li>\n\t<li><code>0&nbsp;&lt;= node.val &lt;= 9</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>能否用&nbsp;O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 234&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/palindrome-linked-list/\">https://leetcode-cn.com/problems/palindrome-linked-list/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2951展平多级双向链表",
        "hardRate": "MEDIUM",
        "passRate": "60.01%",
        "problemsUrl": "https://leetcode.cn/problems/Qv1Da2/",
        "solutionsUrl": "https://leetcode.cn/problems/Qv1Da2/solution",
        "problemsDesc": "<p>多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p>\n\n<p>给定位于列表第一级的头节点，请扁平化列表，即将这样的多级双向链表展平成普通的双向链表，使所有结点出现在单级双链表中。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]\n<strong>输出：</strong>[1,2,3,7,8,11,12,9,10,4,5,6]\n<strong>解释：\n</strong>\n输入的多级列表如下图所示：\n\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlist.png\" style=\"height: 363px; width: 640px;\" />\n\n扁平化后的链表如下图：\n\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlistflattened.png\" style=\"height: 80px; width: 1100px;\" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,null,3]\n<strong>输出：</strong>[1,3,2]\n<strong>解释：\n\n</strong>输入的多级列表如下图所示：\n\n  1---2---NULL\n  |\n  3---NULL\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = []\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>如何表示测试用例中的多级链表？</strong></p>\n\n<p>以 <strong>示例 1</strong> 为例：</p>\n\n<pre>\n 1---2---3---4---5---6--NULL\n         |\n         7---8---9---10--NULL\n             |\n             11--12--NULL</pre>\n\n<p>序列化其中的每一级之后：</p>\n\n<pre>\n[1,2,3,4,5,6,null]\n[7,8,9,10,null]\n[11,12,null]\n</pre>\n\n<p>为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。</p>\n\n<pre>\n[1,2,3,4,5,6,null]\n[null,null,7,8,9,10,null]\n[null,11,12,null]\n</pre>\n\n<p>合并所有序列化结果，并去除末尾的 null 。</p>\n\n<pre>\n[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>节点数目不超过 <code>1000</code></li>\n\t<li><code>1 &lt;= Node.val &lt;= 10^5</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 430&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/\">https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2952排序的循环链表",
        "hardRate": "MEDIUM",
        "passRate": "33.30%",
        "problemsUrl": "https://leetcode.cn/problems/4ueAj6/",
        "solutionsUrl": "https://leetcode.cn/problems/4ueAj6/solution",
        "problemsDesc": "<p>给定<strong>循环单调非递减列表</strong>中的一个点，写一个函数向这个列表中插入一个新元素&nbsp;<code>insertVal</code> ，使这个列表仍然是循环升序的。</p>\n\n<p>给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针。</p>\n\n<p>如果有多个满足条件的插入位置，可以选择任意一个位置插入新的值，插入后整个列表仍然保持有序。</p>\n\n<p>如果列表为空（给定的节点是 <code>null</code>），需要创建一个循环有序列表并返回这个节点。否则。请返回原先给定的节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/19/example_1_before_65p.jpg\" style=\"height: 149px; width: 250px;\" /><br />\n&nbsp;</p>\n\n<pre>\n<strong>输入：</strong>head = [3,4,1], insertVal = 2\n<strong>输出：</strong>[3,4,1,2]\n<strong>解释：</strong>在上图中，有一个包含三个元素的循环有序列表，你获得值为 3 的节点的指针，我们需要向表中插入元素 2 。新插入的节点应该在 1 和 3 之间，插入之后，整个列表如上图所示，最后返回节点 3 。\n\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/19/example_1_after_65p.jpg\" style=\"height: 149px; width: 250px;\" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [], insertVal = 1\n<strong>输出：</strong>[1]\n<strong>解释：</strong>列表为空（给定的节点是 <code>null</code>），创建一个循环有序列表并返回这个节点。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1], insertVal = 0\n<strong>输出：</strong>[1,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= Number of Nodes &lt;= 5 * 10^4</code></li>\n\t<li><code><font face=\"monospace\">-10^6 &lt;= Node.val &lt;= 10^6</font></code></li>\n\t<li><code>-10^6 &lt;=&nbsp;insertVal &lt;= 10^6</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 708&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/insert-into-a-sorted-circular-linked-list/\">https://leetcode-cn.com/problems/insert-into-a-sorted-circular-linked-list/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2953插入、删除和随机访问都是 O(1) 的容器",
        "hardRate": "MEDIUM",
        "passRate": "53.79%",
        "problemsUrl": "https://leetcode.cn/problems/FortPu/",
        "solutionsUrl": "https://leetcode.cn/problems/FortPu/solution",
        "problemsDesc": "<p>设计一个支持在<em>平均&nbsp;</em>时间复杂度 <strong>O(1)</strong>&nbsp;下，执行以下操作的数据结构：</p>\n\n<ul>\n\t<li><code>insert(val)</code>：当元素 <code>val</code> 不存在时返回 <code>true</code>&nbsp;，并向集合中插入该项，否则返回 <code>false</code> 。</li>\n\t<li><code>remove(val)</code>：当元素 <code>val</code> 存在时返回 <code>true</code>&nbsp;，并从集合中移除该项，否则返回 <code>false</code>&nbsp;。</li>\n\t<li><code>getRandom</code>：随机返回现有集合中的一项。每个元素应该有&nbsp;<strong>相同的概率&nbsp;</strong>被返回。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 :</strong></p>\n\n<pre>\n<strong>输入: </strong>inputs = [&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]\n[[], [1], [2], [2], [], [1], [2], []]\n<strong>输出: </strong>[null, true, false, true, 2, true, false, 2]\n<strong>解释:\n</strong>RandomizedSet randomSet = new RandomizedSet();  // 初始化一个空的集合\nrandomSet.insert(1); // 向集合中插入 1 ， 返回 true 表示 1 被成功地插入\n\nrandomSet.remove(2); // 返回 false，表示集合中不存在 2 \n\nrandomSet.insert(2); // 向集合中插入 2 返回 true ，集合现在包含 [1,2] \n\nrandomSet.getRandom(); // getRandom 应随机返回 1 或 2 \n  \nrandomSet.remove(1); // 从集合中移除 1 返回 true 。集合现在包含 [2] \n\nrandomSet.insert(2); // 2 已在集合中，所以返回 false \n\nrandomSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= val &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n\t<li>最多进行<code> 2 * 10<sup>5</sup></code> 次&nbsp;<code>insert</code> ， <code>remove</code> 和 <code>getRandom</code> 方法调用</li>\n\t<li>当调用&nbsp;<code>getRandom</code> 方法时，集合中至少有一个元素</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 380&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/insert-delete-getrandom-o1/\">https://leetcode-cn.com/problems/insert-delete-getrandom-o1/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2954最近最少使用缓存",
        "hardRate": "MEDIUM",
        "passRate": "55.59%",
        "problemsUrl": "https://leetcode.cn/problems/OrIXps/",
        "solutionsUrl": "https://leetcode.cn/problems/OrIXps/solution",
        "problemsDesc": "<div class=\"title__3Vvk\">\n<p>运用所掌握的数据结构，设计和实现一个&nbsp; <a href=\"https://baike.baidu.com/item/LRU\" target=\"_blank\">LRU (Least Recently Used，最近最少使用) 缓存机制</a> 。</p>\n\n<p>实现 <code>LRUCache</code> 类：</p>\n\n<ul>\n\t<li><code>LRUCache(int capacity)</code> 以正整数作为容量&nbsp;<code>capacity</code> 初始化 LRU 缓存</li>\n\t<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>\n\t<li><code>void put(int key, int value)</code>&nbsp;如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n<strong>输出</strong>\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n<strong>解释</strong>\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // 缓存是 {1=1}\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\nlRUCache.get(1);    // 返回 1\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\nlRUCache.get(2);    // 返回 -1 (未找到)\nlRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\nlRUCache.get(1);    // 返回 -1 (未找到)\nlRUCache.get(3);    // 返回 3\nlRUCache.get(4);    // 返回 4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= capacity &lt;= 3000</code></li>\n\t<li><code>0 &lt;= key &lt;= 10000</code></li>\n\t<li><code>0 &lt;= value &lt;= 10<sup>5</sup></code></li>\n\t<li>最多调用 <code>2 * 10<sup>5</sup></code> 次 <code>get</code> 和 <code>put</code></li>\n</ul>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶</strong>：是否可以在&nbsp;<code>O(1)</code> 时间复杂度内完成这两种操作？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 146&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/lru-cache/\">https://leetcode-cn.com/problems/lru-cache/</a>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2955有效的变位词",
        "hardRate": "EASY",
        "passRate": "59.76%",
        "problemsUrl": "https://leetcode.cn/problems/dKk3P7/",
        "solutionsUrl": "https://leetcode.cn/problems/dKk3P7/solution",
        "problemsDesc": "<p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断它们是不是一组变位词（字母异位词）。</p>\n\n<p><strong>注意：</strong>若&nbsp;<code><em>s</em></code> 和 <code><em>t</em></code><em>&nbsp;</em>中每个字符出现的次数都相同且<strong>字符顺序不完全相同</strong>，则称&nbsp;<code><em>s</em></code> 和 <code><em>t</em></code><em>&nbsp;</em>互为变位词（字母异位词）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = &quot;anagram&quot;, t = &quot;nagaram&quot;\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = &quot;rat&quot;, t = &quot;car&quot;\n<strong>输出: </strong>false</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = &quot;a&quot;, t = &quot;a&quot;\n<strong>输出: </strong>false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code>&nbsp;and&nbsp;<code>t</code>&nbsp;仅包含小写字母</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶:&nbsp;</strong>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 242&nbsp;题相似（字母异位词定义不同）：<a href=\"https://leetcode-cn.com/problems/valid-anagram/\">https://leetcode-cn.com/problems/valid-anagram/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2956变位词组",
        "hardRate": "MEDIUM",
        "passRate": "74.68%",
        "problemsUrl": "https://leetcode.cn/problems/sfvd7V/",
        "solutionsUrl": "https://leetcode.cn/problems/sfvd7V/solution",
        "problemsDesc": "<p>给定一个字符串数组 <code>strs</code> ，将&nbsp;<strong>变位词&nbsp;</strong>组合在一起。 可以按任意顺序返回结果列表。</p>\n\n<p><strong>注意：</strong>若两个字符串中每个字符出现的次数都相同，则称它们互为变位词。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> strs = <code>[&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</code>\n<strong>输出: </strong>[[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> strs = <code>[&quot;&quot;]</code>\n<strong>输出: </strong>[[&quot;&quot;]]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> strs = <code>[&quot;a&quot;]</code>\n<strong>输出: </strong>[[&quot;a&quot;]]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>\n\t<li><code>strs[i]</code>&nbsp;仅包含小写字母</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 49&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/group-anagrams/\">https://leetcode-cn.com/problems/group-anagrams/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2957外星语言是否排序",
        "hardRate": "EASY",
        "passRate": "55.77%",
        "problemsUrl": "https://leetcode.cn/problems/lwyVBB/",
        "solutionsUrl": "https://leetcode.cn/problems/lwyVBB/solution",
        "problemsDesc": "<p>某种外星语也使用英文小写字母，但可能顺序 <code>order</code> 不同。字母表的顺序（<code>order</code>）是一些小写字母的排列。</p>\n\n<p>给定一组用外星语书写的单词 <code>words</code>，以及其字母表的顺序 <code>order</code>，只有当给定的单词在这种外星语中按字典序排列时，返回 <code>true</code>；否则，返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot;\n<strong>输出：</strong>true\n<strong>解释：</strong>在该语言的字母表中，&#39;h&#39; 位于 &#39;l&#39; 之前，所以单词序列是按字典序排列的。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order = &quot;worldabcefghijkmnpqstuvxyz&quot;\n<strong>输出：</strong>false\n<strong>解释：</strong>在该语言的字母表中，&#39;d&#39; 位于 &#39;l&#39; 之后，那么 words[0] &gt; words[1]，因此单词序列不是按字典序排列的。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [&quot;apple&quot;,&quot;app&quot;], order = &quot;abcdefghijklmnopqrstuvwxyz&quot;\n<strong>输出：</strong>false\n<strong>解释：</strong>当前三个字符 &quot;app&quot; 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 &quot;apple&quot; &gt; &quot;app&quot;，因为 &#39;l&#39; &gt; &#39;&empty;&#39;，其中 &#39;&empty;&#39; 是空白字符，定义为比任何其他字符都小（<a href=\"https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E5%BA%8F\" target=\"_blank\">更多信息</a>）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 20</code></li>\n\t<li><code>order.length == 26</code></li>\n\t<li>在&nbsp;<code>words[i]</code>&nbsp;和&nbsp;<code>order</code>&nbsp;中的所有字符都是英文小写字母。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 953&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/verifying-an-alien-dictionary/\">https://leetcode-cn.com/problems/verifying-an-alien-dictionary/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2958最小时间差",
        "hardRate": "MEDIUM",
        "passRate": "66.05%",
        "problemsUrl": "https://leetcode.cn/problems/569nqc/",
        "solutionsUrl": "https://leetcode.cn/problems/569nqc/solution",
        "problemsDesc": "<p>给定一个 24 小时制（小时:分钟 <strong>&quot;HH:MM&quot;</strong>）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>timePoints = [&quot;23:59&quot;,&quot;00:00&quot;]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>timePoints = [&quot;00:00&quot;,&quot;23:59&quot;,&quot;00:00&quot;]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= timePoints &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>timePoints[i]</code> 格式为 <strong>&quot;HH:MM&quot;</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 539&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/minimum-time-difference/\">https://leetcode-cn.com/problems/minimum-time-difference/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2959后缀表达式",
        "hardRate": "MEDIUM",
        "passRate": "55.48%",
        "problemsUrl": "https://leetcode.cn/problems/8Zf90G/",
        "solutionsUrl": "https://leetcode.cn/problems/8Zf90G/solution",
        "problemsDesc": "<p>根据<a href=\"https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437\" target=\"_blank\"> 逆波兰表示法</a>，求该后缀表达式的计算结果。</p>\n\n<p>有效的算符包括&nbsp;<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>&nbsp;。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>整数除法只保留整数部分。</li>\n\t<li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]\n<strong>输出：</strong>9\n<strong>解释：</strong>该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]\n<strong>输出：</strong>6\n<strong>解释：</strong>该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre>\n<strong>输入：</strong>tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]\n<strong>输出：</strong>22\n<strong>解释：</strong>\n该算式转化为常见的中缀算术表达式为：\n  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tokens.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>tokens[i]</code> 要么是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），要么是一个在范围 <code>[-200, 200]</code> 内的整数</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>逆波兰表达式：</strong></p>\n\n<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>\n\n<ul>\n\t<li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li>\n\t<li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li>\n</ul>\n\n<p>逆波兰表达式主要有以下两个优点：</p>\n\n<ul>\n\t<li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li>\n\t<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 150&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/\">https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2960小行星碰撞",
        "hardRate": "MEDIUM",
        "passRate": "44.84%",
        "problemsUrl": "https://leetcode.cn/problems/XagZNi/",
        "solutionsUrl": "https://leetcode.cn/problems/XagZNi/solution",
        "problemsDesc": "<p>给定一个整数数组 <code>asteroids</code>，表示在同一行的小行星。</p>\n\n<p>对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。</p>\n\n<p>找出碰撞后剩下的所有小行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>asteroids = [5,10,-5]\n<strong>输出：</strong>[5,10]\n<b>解释：</b>10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>asteroids = [8,-8]\n<strong>输出：</strong>[]\n<b>解释：</b>8 和 -8 碰撞后，两者都发生爆炸。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>asteroids = [10,2,-5]\n<strong>输出：</strong>[10]\n<b>解释：</b>2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下 10 。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>asteroids = [-2,-1,1,2]\n<strong>输出：</strong>[-2,-1,1,2]\n<b>解释</b><strong>：</strong>-2 和 -1 向左移动，而 1 和 2 向右移动。 由于移动方向相同的行星不会发生碰撞，所以最终没有行星发生碰撞。 </pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= asteroids.length&nbsp;&lt;= 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= asteroids[i] &lt;= 1000</code></li>\n\t<li><code>asteroids[i] != 0</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 735&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/asteroid-collision/\">https://leetcode-cn.com/problems/asteroid-collision/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2961每日温度",
        "hardRate": "MEDIUM",
        "passRate": "76.23%",
        "problemsUrl": "https://leetcode.cn/problems/iIQa4I/",
        "solutionsUrl": "https://leetcode.cn/problems/iIQa4I/solution",
        "problemsDesc": "<p>请根据每日 <code>气温</code> 列表 <code>temperatures</code>&nbsp;，重新生成一个列表，要求其对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用&nbsp;<code>0</code> 来代替。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>temperatures</code> = [73,74,75,71,69,72,76,73]\n<strong>输出:</strong>&nbsp;[1,1,4,2,1,1,0,0]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> temperatures = [30,40,50,60]\n<strong>输出:</strong>&nbsp;[1,1,1,0]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> temperatures = [30,60,90]\n<strong>输出: </strong>[1,1,0]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;temperatures.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>30 &lt;=&nbsp;temperatures[i]&nbsp;&lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 739&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/daily-temperatures/\">https://leetcode-cn.com/problems/daily-temperatures/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2962直方图最大矩形面积",
        "hardRate": "HARD",
        "passRate": "50.70%",
        "problemsUrl": "https://leetcode.cn/problems/0ynMMM/",
        "solutionsUrl": "https://leetcode.cn/problems/0ynMMM/solution",
        "problemsDesc": "<p>给定非负整数数组 <code>heights</code>&nbsp;，数组中的数字用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 <code>1</code> 。</p>\n\n<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>heights = [2,1,5,6,2,3]\n<strong>输出：</strong>10\n<strong>解释：</strong>最大的矩形为图中红色区域，面积为 10\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong> heights = [2,4]\n<b>输出：</b> 4</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= heights.length &lt;=10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= heights[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 84&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/\">https://leetcode-cn.com/problems/largest-rectangle-in-histogram/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2963矩阵中最大的矩形",
        "hardRate": "HARD",
        "passRate": "58.22%",
        "problemsUrl": "https://leetcode.cn/problems/PLYXKQ/",
        "solutionsUrl": "https://leetcode.cn/problems/PLYXKQ/solution",
        "problemsDesc": "<p>给定一个由&nbsp;<code>0</code> 和 <code>1</code>&nbsp;组成的矩阵 <code>matrix</code>&nbsp;，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p>\n\n<p><strong>注意：</strong>此题 <code>matrix</code>&nbsp;输入格式为一维 <code>01</code> 字符串数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg\" style=\"width: 402px; height: 322px;\" /></p>\n\n<pre>\n<strong>输入：</strong>matrix = [\"10100\",\"10111\",\"11111\",\"10010\"]\n<strong>输出：</strong>6\n<strong>解释：</strong>最大矩形如上图所示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = []\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [\"0\"]\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [\"1\"]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [\"00\"]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rows == matrix.length</code></li>\n\t<li><code>cols == matrix[0].length</code></li>\n\t<li><code>0 &lt;= row, cols &lt;= 200</code></li>\n\t<li><code>matrix[i][j]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 85 题相同（输入参数格式不同）：&nbsp;<a href=\"https://leetcode-cn.com/problems/maximal-rectangle/\">https://leetcode-cn.com/problems/maximal-rectangle/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2964滑动窗口的平均值",
        "hardRate": "EASY",
        "passRate": "77.82%",
        "problemsUrl": "https://leetcode.cn/problems/qIsx9U/",
        "solutionsUrl": "https://leetcode.cn/problems/qIsx9U/solution",
        "problemsDesc": "<p>给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算滑动窗口里所有数字的平均值。</p>\n\n<p>实现 <code>MovingAverage</code> 类：</p>\n\n<ul>\n\t<li><code>MovingAverage(int size)</code> 用窗口大小 <code>size</code> 初始化对象。</li>\n\t<li><code>double next(int val)</code>&nbsp;成员函数 <code>next</code>&nbsp;每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后 <code>size</code> 个值的移动平均值，即滑动窗口里所有数字的平均值。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\ninputs = [&quot;MovingAverage&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;]\ninputs = [[3], [1], [10], [3], [5]]\n<strong>输出：</strong>\n[null, 1.0, 5.5, 4.66667, 6.0]\n\n<strong>解释：</strong>\nMovingAverage movingAverage = new MovingAverage(3);\nmovingAverage.next(1); // 返回 1.0 = 1 / 1\nmovingAverage.next(10); // 返回 5.5 = (1 + 10) / 2\nmovingAverage.next(3); // 返回 4.66667 = (1 + 10 + 3) / 3\nmovingAverage.next(5); // 返回 6.0 = (10 + 3 + 5) / 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= size &lt;= 1000</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= val &lt;= 10<sup>5</sup></code></li>\n\t<li>最多调用 <code>next</code> 方法 <code>10<sup>4</sup></code> 次</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 346&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/moving-average-from-data-stream/\">https://leetcode-cn.com/problems/moving-average-from-data-stream/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2965最近请求次数",
        "hardRate": "EASY",
        "passRate": "82.05%",
        "problemsUrl": "https://leetcode.cn/problems/H8086Q/",
        "solutionsUrl": "https://leetcode.cn/problems/H8086Q/solution",
        "problemsDesc": "<p>写一个&nbsp;<code>RecentCounter</code>&nbsp;类来计算特定时间范围内最近的请求。</p>\n\n<p>请实现 <code>RecentCounter</code> 类：</p>\n\n<ul>\n\t<li><code>RecentCounter()</code> 初始化计数器，请求数为 0 。</li>\n\t<li><code>int ping(int t)</code> 在时间 <code>t</code> 添加一个新请求，其中 <code>t</code> 表示以毫秒为单位的某个时间，并返回过去 <code>3000</code> 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 <code>[t-3000, t]</code> 内发生的请求数。</li>\n</ul>\n\n<p><strong>保证</strong> 每次对 <code>ping</code> 的调用都使用比之前更大的 <code>t</code> 值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\ninputs = [&quot;RecentCounter&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;]\ninputs = [[], [1], [100], [3001], [3002]]\n<strong>输出：</strong>\n[null, 1, 2, 3, 3]\n\n<strong>解释：</strong>\nRecentCounter recentCounter = new RecentCounter();\nrecentCounter.ping(1);     // requests = [<strong>1</strong>]，范围是 [-2999,1]，返回 1\nrecentCounter.ping(100);   // requests = [<strong>1</strong>, <strong>100</strong>]，范围是 [-2900,100]，返回 2\nrecentCounter.ping(3001);  // requests = [<strong>1</strong>, <strong>100</strong>, <strong>3001</strong>]，范围是 [1,3001]，返回 3\nrecentCounter.ping(3002);  // requests = [1, <strong>100</strong>, <strong>3001</strong>, <strong>3002</strong>]，范围是 [2,3002]，返回 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= t &lt;= 10<sup>9</sup></code></li>\n\t<li>保证每次对 <code>ping</code> 调用所使用的 <code>t</code> 值都 <strong>严格递增</strong></li>\n\t<li>至多调用 <code>ping</code> 方法 <code>10<sup>4</sup></code> 次</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 933&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/number-of-recent-calls/\">https://leetcode-cn.com/problems/number-of-recent-calls/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2966往完全二叉树添加节点",
        "hardRate": "MEDIUM",
        "passRate": "62.38%",
        "problemsUrl": "https://leetcode.cn/problems/NaqhDT/",
        "solutionsUrl": "https://leetcode.cn/problems/NaqhDT/solution",
        "problemsDesc": "<p>完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大，第 <code>n</code> 层有 <code>2<sup>n-1</sup></code>&nbsp;个节点）的，并且所有的节点都尽可能地集中在左侧。</p>\n\n<p>设计一个用完全二叉树初始化的数据结构&nbsp;<code>CBTInserter</code>，它支持以下几种操作：</p>\n\n<ul>\n\t<li><code>CBTInserter(TreeNode root)</code>&nbsp;使用根节点为&nbsp;<code>root</code>&nbsp;的给定树初始化该数据结构；</li>\n\t<li><code>CBTInserter.insert(int v)</code>&nbsp; 向树中插入一个新节点，节点类型为 <code>TreeNode</code>，值为 <code>v</code> 。使树保持完全二叉树的状态，<strong>并返回插入的新节点的父节点的值</strong>；</li>\n\t<li><code>CBTInserter.get_root()</code> 将返回树的根节点。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>inputs = [&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;get_root&quot;], inputs = [[[1]],[2],[]]\n<strong>输出：</strong>[null,1,[1,2]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>inputs = [&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;insert&quot;,&quot;get_root&quot;], inputs = [[[1,2,3,4,5,6]],[7],[8],[]]\n<strong>输出：</strong>[null,3,4,[1,2,3,4,5,6,7,8]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>最初给定的树是完全二叉树，且包含&nbsp;<code>1</code>&nbsp;到&nbsp;<code>1000</code>&nbsp;个节点。</li>\n\t<li>每个测试用例最多调用&nbsp;<code>CBTInserter.insert</code>&nbsp; 操作&nbsp;<code>10000</code>&nbsp;次。</li>\n\t<li>给定节点或插入节点的每个值都在&nbsp;<code>0</code>&nbsp;到&nbsp;<code>5000</code>&nbsp;之间。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 919&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/complete-binary-tree-inserter/\">https://leetcode-cn.com/problems/complete-binary-tree-inserter/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2967二叉树每层的最大值",
        "hardRate": "MEDIUM",
        "passRate": "64.12%",
        "problemsUrl": "https://leetcode.cn/problems/hPov7L/",
        "solutionsUrl": "https://leetcode.cn/problems/hPov7L/solution",
        "problemsDesc": "<p>给定一棵二叉树的根节点&nbsp;<code>root</code> ，请找出该二叉树中每一层的最大值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例1：</strong></p>\n\n<pre>\n<strong>输入: </strong>root = [1,3,2,5,3,null,9]\n<strong>输出: </strong>[1,3,9]\n<strong>解释:</strong>\n          1\n         / \\\n        3   2\n       / \\   \\  \n      5   3   9 \n</pre>\n\n<p><strong>示例2：</strong></p>\n\n<pre>\n<strong>输入: </strong>root = [1,2,3]\n<strong>输出: </strong>[1,3]\n<strong>解释:</strong>\n          1\n         / \\\n        2   3\n</pre>\n\n<p><strong>示例3：</strong></p>\n\n<pre>\n<strong>输入: </strong>root = [1]\n<strong>输出: </strong>[1]\n</pre>\n\n<p><strong>示例4：</strong></p>\n\n<pre>\n<strong>输入: </strong>root = [1,null,2]\n<strong>输出: </strong>[1,2]\n<strong>解释:</strong>      \n&nbsp;          1 \n&nbsp;           \\\n&nbsp;            2     \n</pre>\n\n<p><strong>示例5：</strong></p>\n\n<pre>\n<strong>输入: </strong>root = []\n<strong>输出: </strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[0,10<sup>4</sup>]</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>-2<sup>31</sup>&nbsp;&lt;= Node.val &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 515&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/\">https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2968二叉树最底层最左边的值",
        "hardRate": "MEDIUM",
        "passRate": "79.21%",
        "problemsUrl": "https://leetcode.cn/problems/LwUNpT/",
        "solutionsUrl": "https://leetcode.cn/problems/LwUNpT/solution",
        "problemsDesc": "<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的&nbsp;<strong>最底层&nbsp;最左边&nbsp;</strong>节点的值。</p>\n\n<p>假设二叉树中至少有一个节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg\" style=\"width: 182px; \" /></p>\n\n<pre>\n<strong>输入: </strong>root = [2,1,3]\n<strong>输出: </strong>1\n</pre>\n\n<p><strong>示例 2: </strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg\" style=\"width: 242px; \" /><strong> </strong></p>\n\n<pre>\n<strong>输入: </strong>[1,2,3,4,null,5,6,null,null,7]\n<strong>输出: </strong>7\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[1,10<sup>4</sup>]</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>-2<sup>31</sup>&nbsp;&lt;= Node.val &lt;= 2<sup>31</sup>&nbsp;- 1</code>&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 513&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/find-bottom-left-tree-value/\">https://leetcode-cn.com/problems/find-bottom-left-tree-value/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2969二叉树的右侧视图",
        "hardRate": "MEDIUM",
        "passRate": "70.63%",
        "problemsUrl": "https://leetcode.cn/problems/WNC0Lk/",
        "solutionsUrl": "https://leetcode.cn/problems/WNC0Lk/solution",
        "problemsDesc": "<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/02/14/tree.jpg\" style=\"width: 270px; \" /></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;[1,2,3,null,5,null,4]\n<strong>输出:</strong>&nbsp;[1,3,4]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;[1,null,3]\n<strong>输出:</strong>&nbsp;[1,3]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;[]\n<strong>输出:</strong>&nbsp;[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[0,100]</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>-100&nbsp;&lt;= Node.val &lt;= 100</code>&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 199&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/binary-tree-right-side-view/\">https://leetcode-cn.com/problems/binary-tree-right-side-view/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2970二叉树剪枝",
        "hardRate": "MEDIUM",
        "passRate": "68.48%",
        "problemsUrl": "https://leetcode.cn/problems/pOCWxh/",
        "solutionsUrl": "https://leetcode.cn/problems/pOCWxh/solution",
        "problemsDesc": "<p>给定一个二叉树 <strong>根节点</strong>&nbsp;<code>root</code>&nbsp;，树的每个节点的值要么是 <code>0</code>，要么是 <code>1</code>。请剪除该二叉树中所有节点的值为 <code>0</code> 的子树。</p>\n\n<p>节点 <code>node</code> 的子树为&nbsp;<code>node</code> 本身，以及所有 <code>node</code>&nbsp;的后代。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> [1,null,0,0,1]\n<strong>输出: </strong>[1,null,0,null,1] \n<strong>解释:</strong> \n只有红色节点满足条件&ldquo;所有不包含 1 的子树&rdquo;。\n右图为返回的答案。\n\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_2.png\" style=\"width:450px\" />\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> [1,0,1,0,0,0,1]\n<strong>输出: </strong>[1,null,1,null,1]\n<strong>解释:</strong> \n\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_1.png\" style=\"width:450px\" />\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> [1,1,0,1,1,0,1,0]\n<strong>输出: </strong>[1,1,0,1,1,null,1]\n<strong>解释:</strong> \n\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/05/1028.png\" style=\"width:450px\" />\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[1,200]</code></li>\n\t<li>二叉树节点的值只会是 <code>0</code> 或 <code>1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 814&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/binary-tree-pruning/\">https://leetcode-cn.com/problems/binary-tree-pruning/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2971序列化与反序列化二叉树",
        "hardRate": "HARD",
        "passRate": "66.98%",
        "problemsUrl": "https://leetcode.cn/problems/h54YBf/",
        "solutionsUrl": "https://leetcode.cn/problems/h54YBf/solution",
        "problemsDesc": "<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>\n\n<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg\" style=\"width: 442px; height: 324px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,null,null,4,5]\n<strong>输出：</strong>[1,2,3,null,null,4,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅&nbsp;<a href=\"/faq/#binary-tree\">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，也可以采用其他的方法解决这个问题。</li>\n\t<li>树中结点数在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 297&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/\">https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/</a>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2972从根节点到叶节点的路径数字之和",
        "hardRate": "MEDIUM",
        "passRate": "73.80%",
        "problemsUrl": "https://leetcode.cn/problems/3Etpl5/",
        "solutionsUrl": "https://leetcode.cn/problems/3Etpl5/solution",
        "problemsDesc": "<p>给定一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>每条从根节点到叶节点的路径都代表一个数字：</p>\n\n<ul>\n\t<li>例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code> 。</li>\n</ul>\n\n<p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p>\n\n<p><strong>叶节点</strong> 是指没有子节点的节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg\" style=\"width: 212px; height: 182px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3]\n<strong>输出：</strong>25\n<strong>解释：</strong>\n从根到叶子节点路径 <code>1-&gt;2</code> 代表数字 <code>12</code>\n从根到叶子节点路径 <code>1-&gt;3</code> 代表数字 <code>13</code>\n因此，数字总和 = 12 + 13 = <code>25</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg\" style=\"width: 292px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>root = [4,9,0,5,1]\n<strong>输出：</strong>1026\n<strong>解释：</strong>\n从根到叶子节点路径 <code>4-&gt;9-&gt;5</code> 代表数字 495\n从根到叶子节点路径 <code>4-&gt;9-&gt;1</code> 代表数字 491\n从根到叶子节点路径 <code>4-&gt;0</code> 代表数字 40\n因此，数字总和 = 495 + 491 + 40 = <code>1026</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 1000]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n\t<li>树的深度不超过 <code>10</code></li>\n</ul>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 129&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/\">https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2973向下的路径节点之和",
        "hardRate": "MEDIUM",
        "passRate": "51.09%",
        "problemsUrl": "https://leetcode.cn/problems/6eUYwP/",
        "solutionsUrl": "https://leetcode.cn/problems/6eUYwP/solution",
        "problemsDesc": "<p>给定一个二叉树的根节点 <code>root</code>&nbsp;，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p>\n\n<p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg\" style=\"width: 452px; \" /></p>\n\n<pre>\n<strong>输入：</strong>root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\n<strong>输出：</strong>3\n<strong>解释：</strong>和等于 8 的路径有 3 条，如图所示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[0,1000]</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>-10<sup><span style=\"font-size: 9.449999809265137px;\">9</span></sup>&nbsp;&lt;= Node.val &lt;= 10<sup><span style=\"font-size: 9.449999809265137px;\">9</span></sup></code>&nbsp;</li>\n\t<li><code>-1000&nbsp;&lt;= targetSum&nbsp;&lt;= 1000</code>&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 437&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/path-sum-iii/\">https://leetcode-cn.com/problems/path-sum-iii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2974节点之和最大的路径",
        "hardRate": "HARD",
        "passRate": "49.19%",
        "problemsUrl": "https://leetcode.cn/problems/jC7MId/",
        "solutionsUrl": "https://leetcode.cn/problems/jC7MId/solution",
        "problemsDesc": "<p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径<strong> 至少包含一个 </strong>节点，且不一定经过根节点。</p>\n\n<p><strong>路径和</strong> 是路径中各节点值的总和。</p>\n\n<p>给定一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong>，即所有路径上节点值之和的最大值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg\" style=\"width: 322px; height: 182px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3]\n<strong>输出：</strong>6\n<strong>解释：</strong>最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [-10,9,20,null,null,15,7]\n<strong>输出：</strong>42\n<strong>解释：</strong>最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目范围是 <code>[1, 3 * 10<sup>4</sup>]</code></li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 124&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/\">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2975展平二叉搜索树",
        "hardRate": "EASY",
        "passRate": "73.65%",
        "problemsUrl": "https://leetcode.cn/problems/NYBBNL/",
        "solutionsUrl": "https://leetcode.cn/problems/NYBBNL/solution",
        "problemsDesc": "<p>给你一棵二叉搜索树，请&nbsp;<strong>按中序遍历</strong> 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg\" style=\"width: 600px; height: 350px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,3,6,2,4,null,8,1,null,null,null,7,9]\n<strong>输出：</strong>[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/17/ex2.jpg\" style=\"width: 300px; height: 114px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,1,7]\n<strong>输出：</strong>[1,null,5,null,7]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数的取值范围是 <code>[1, 100]</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 897&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/increasing-order-search-tree/\">https://leetcode-cn.com/problems/increasing-order-search-tree/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2976二叉搜索树中的中序后继",
        "hardRate": "MEDIUM",
        "passRate": "63.26%",
        "problemsUrl": "https://leetcode.cn/problems/P5rCT8/",
        "solutionsUrl": "https://leetcode.cn/problems/P5rCT8/solution",
        "problemsDesc": "<p>给定一棵二叉搜索树和其中的一个节点 <code>p</code> ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 <code>null</code> 。</p>\n\n<p>节点&nbsp;<code>p</code>&nbsp;的后继是值比&nbsp;<code>p.val</code>&nbsp;大的节点中键值最小的节点，即按中序遍历的顺序节点 <code>p</code> 的下一个节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/23/285_example_1.PNG\" style=\"height: 117px; width: 122px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [2,1,3], p = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>这里 1 的中序后继是 2。请注意 p 和返回值都应是 TreeNode 类型。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/23/285_example_2.PNG\" style=\"height: 229px; width: 246px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,3,6,2,4,null,null,1], p = 6\n<strong>输出：</strong>null\n<strong>解释：</strong>因为给出的节点没有中序后继，所以答案就返回 <code>null 了。</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 10<sup>4</sup>]</code> 内。</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li>树中各节点的值均保证唯一。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 285&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/inorder-successor-in-bst/\">https://leetcode-cn.com/problems/inorder-successor-in-bst/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2977所有大于等于节点的值之和",
        "hardRate": "MEDIUM",
        "passRate": "85.61%",
        "problemsUrl": "https://leetcode.cn/problems/w6cpku/",
        "solutionsUrl": "https://leetcode.cn/problems/w6cpku/solution",
        "problemsDesc": "<p><span style=\"font-size:10.5pt\"><span style=\"font-family:Calibri\"><span style=\"font-size:10.5000pt\"><span style=\"font-family:宋体\"><font face=\"宋体\">给定一个二叉搜索树，请将它的每个</font></span></span></span></span>节点<span style=\"font-size:10.5pt\"><span style=\"font-family:Calibri\"><span style=\"font-size:10.5000pt\"><span style=\"font-family:宋体\"><font face=\"宋体\">的值替换成树中大于或者等于该</font></span></span></span></span>节点<span style=\"font-size:10.5pt\"><span style=\"font-family:Calibri\"><span style=\"font-size:10.5000pt\"><span style=\"font-family:宋体\"><font face=\"宋体\">值的所有</font></span></span></span></span>节点<span style=\"font-size:10.5pt\"><span style=\"font-family:Calibri\"><span style=\"font-size:10.5000pt\"><span style=\"font-family:宋体\"><font face=\"宋体\">值之和。</font></span></span></span></span></p>\n\n<p style=\"margin:0pt 0pt 0.0001pt; text-align:justify\">&nbsp;</p>\n\n<p>提醒一下，二叉搜索树满足下列约束条件：</p>\n\n<ul>\n\t<li>节点的左子树仅包含键<strong> 小于 </strong>节点键的节点。</li>\n\t<li>节点的右子树仅包含键<strong> 大于</strong> 节点键的节点。</li>\n\t<li>左右子树也必须是二叉搜索树。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png\" style=\"height: 364px; width: 534px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root<strong> </strong>=<strong> </strong>[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n<strong>输出：</strong>[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [0,null,1]\n<strong>输出：</strong>[1,null,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,0,2]\n<strong>输出：</strong>[3,3,2]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [3,2,4,1]\n<strong>输出：</strong>[7,9,4,10]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数介于 <code>0</code>&nbsp;和 <code>10<sup>4</sup></code><sup>&nbsp;</sup>之间。</li>\n\t<li>每个节点的值介于 <code>-10<sup>4</sup></code>&nbsp;和&nbsp;<code>10<sup>4</sup></code>&nbsp;之间。</li>\n\t<li>树中的所有值 <strong>互不相同</strong> 。</li>\n\t<li>给定的树为二叉搜索树。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：</p>\n\n<ul>\n\t<li>本题与主站 538&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/convert-bst-to-greater-tree/\">https://leetcode-cn.com/problems/convert-bst-to-greater-tree/</a></li>\n\t<li>本题与主站 1038&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/\">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2978二叉搜索树迭代器",
        "hardRate": "MEDIUM",
        "passRate": "85.25%",
        "problemsUrl": "https://leetcode.cn/problems/kTOapQ/",
        "solutionsUrl": "https://leetcode.cn/problems/kTOapQ/solution",
        "problemsDesc": "<p>实现一个二叉搜索树迭代器类<code>BSTIterator</code> ，表示一个按中序遍历二叉搜索树（BST）的迭代器：</p>\n\n<div class=\"original__bRMd\">\n<div>\n<ul>\n\t<li><code>BSTIterator(TreeNode root)</code> 初始化 <code>BSTIterator</code> 类的一个对象。BST 的根节点 <code>root</code> 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。</li>\n\t<li><code>boolean hasNext()</code> 如果向指针右侧遍历存在数字，则返回 <code>true</code> ；否则返回 <code>false</code> 。</li>\n\t<li><code>int next()</code>将指针向右移动，然后返回指针处的数字。</li>\n</ul>\n\n<p>注意，指针初始化为一个不存在于 BST 中的数字，所以对 <code>next()</code> 的首次调用将返回 BST 中的最小元素。</p>\n</div>\n</div>\n\n<p>可以假设&nbsp;<code>next()</code>&nbsp;调用总是有效的，也就是说，当调用 <code>next()</code>&nbsp;时，BST 的中序遍历中至少存在一个下一个数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png\" style=\"width: 189px; height: 178px;\" /></p>\n\n<pre>\n<strong>输入</strong>\ninputs = [&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]\ninputs = [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n<strong>输出</strong>\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\n<strong>解释</strong>\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // 返回 3\nbSTIterator.next();    // 返回 7\nbSTIterator.hasNext(); // 返回 True\nbSTIterator.next();    // 返回 9\nbSTIterator.hasNext(); // 返回 True\nbSTIterator.next();    // 返回 15\nbSTIterator.hasNext(); // 返回 True\nbSTIterator.next();    // 返回 20\nbSTIterator.hasNext(); // 返回 False\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>\n\t<li>最多调用 <code>10<sup>5</sup></code> 次 <code>hasNext</code> 和 <code>next</code> 操作</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你可以设计一个满足下述条件的解决方案吗？<code>next()</code> 和 <code>hasNext()</code> 操作均摊时间复杂度为 <code>O(1)</code> ，并使用 <code>O(h)</code> 内存。其中 <code>h</code> 是树的高度。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 173&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/binary-search-tree-iterator/\">https://leetcode-cn.com/problems/binary-search-tree-iterator/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2979二叉搜索树中两个节点之和",
        "hardRate": "EASY",
        "passRate": "73.35%",
        "problemsUrl": "https://leetcode.cn/problems/opLdQZ/",
        "solutionsUrl": "https://leetcode.cn/problems/opLdQZ/solution",
        "problemsDesc": "<p>给定一个二叉搜索树的 <strong>根节点</strong> <code>root</code>&nbsp;和一个整数 <code>k</code> , 请判断该二叉搜索树中是否存在两个节点它们的值之和等于 <code>k</code> 。假设二叉搜索树中节点的值均唯一。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>root =<strong> </strong>[8,6,10,5,7,9,11], k = 12\n<strong>输出: </strong>true\n<strong>解释: </strong>节点 5 和节点 7 之和等于 12\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>root =<strong> </strong>[8,6,10,5,7,9,11], k = 22\n<strong>输出: </strong>false\n<strong>解释: </strong>不存在两个节点值之和为 22 的节点\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是&nbsp;&nbsp;<code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li><code>root</code>&nbsp;为二叉搜索树</li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 653 题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/\">https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2980值和下标之差都在给定的范围内",
        "hardRate": "MEDIUM",
        "passRate": "35.03%",
        "problemsUrl": "https://leetcode.cn/problems/7WqeDu/",
        "solutionsUrl": "https://leetcode.cn/problems/7WqeDu/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和两个整数&nbsp;<code>k</code> 和 <code>t</code> 。请你判断是否存在 <b>两个不同下标</b> <code>i</code> 和 <code>j</code>，使得&nbsp;<code>abs(nums[i] - nums[j]) &lt;= t</code> ，同时又满足 <code>abs(i - j) &lt;= k</code><em> </em>。</p>\n\n<p>如果存在则返回 <code>true</code>，不存在返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,1], k<em> </em>= 3, t = 0\n<strong>输出：</strong>true</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,0,1,1], k<em> </em>=<em> </em>1, t = 2\n<strong>输出：</strong>true</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5,9,1,5,9], k = 2, t = 3\n<strong>输出：</strong>false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= t &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 220&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/contains-duplicate-iii/\">https://leetcode-cn.com/problems/contains-duplicate-iii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2981日程表",
        "hardRate": "MEDIUM",
        "passRate": "61.26%",
        "problemsUrl": "https://leetcode.cn/problems/fi9suh/",
        "solutionsUrl": "https://leetcode.cn/problems/fi9suh/solution",
        "problemsDesc": "<p>请实现一个 <code>MyCalendar</code> 类来存放你的日程安排。如果要添加的时间内没有其他安排，则可以存储这个新的日程安排。</p>\n\n<p><code>MyCalendar</code> 有一个 <code>book(int start, int end)</code>方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 <code>[start, end)</code>, 实数&nbsp;<code>x</code> 的范围为， &nbsp;<code>start &lt;= x &lt; end</code>。</p>\n\n<p>当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生重复预订。</p>\n\n<p>每次调用 <code>MyCalendar.book</code>方法时，如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 <code>true</code>。否则，返回 <code>false</code>&nbsp;并且不要将该日程安排添加到日历中。</p>\n\n<p>请按照以下步骤调用 <code>MyCalendar</code> 类: <code>MyCalendar cal = new MyCalendar();</code> <code>MyCalendar.book(start, end)</code></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>\n<strong>输入:\n</strong>[&quot;MyCalendar&quot;,&quot;book&quot;,&quot;book&quot;,&quot;book&quot;]\n[[],[10,20],[15,25],[20,30]]\n<strong>输出:</strong> [null,true,false,true]\n<strong>解释:</strong> \nMyCalendar myCalendar = new MyCalendar();\nMyCalendar.book(10, 20); // returns true \nMyCalendar.book(15, 25); // returns false ，第二个日程安排不能添加到日历中，因为时间 15 已经被第一个日程安排预定了\nMyCalendar.book(20, 30); // returns true ，第三个日程安排可以添加到日历中，因为第一个日程安排并不包含时间 20 \n</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每个测试用例，调用&nbsp;<code>MyCalendar.book</code>&nbsp;函数最多不超过&nbsp;<code>1000</code>次。</li>\n\t<li><code>0 &lt;= start &lt; end &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 729&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/my-calendar-i/\">https://leetcode-cn.com/problems/my-calendar-i/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2982数据流的第 K 大数值",
        "hardRate": "EASY",
        "passRate": "62.76%",
        "problemsUrl": "https://leetcode.cn/problems/jBjn9C/",
        "solutionsUrl": "https://leetcode.cn/problems/jBjn9C/solution",
        "problemsDesc": "<p>设计一个找到数据流中第 <code>k</code> 大元素的类（class）。注意是排序后的第 <code>k</code> 大元素，不是第 <code>k</code> 个不同的元素。</p>\n\n<p>请实现 <code>KthLargest</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>KthLargest(int k, int[] nums)</code> 使用整数 <code>k</code> 和整数流 <code>nums</code> 初始化对象。</li>\n\t<li><code>int add(int val)</code> 将 <code>val</code> 插入数据流 <code>nums</code> 后，返回当前数据流中第 <code>k</code> 大的元素。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\n<strong>输出：</strong>\n[null, 4, 5, 5, 8, 8]\n\n<strong>解释：</strong>\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= val &lt;= 10<sup>4</sup></code></li>\n\t<li>最多调用 <code>add</code> 方法 <code>10<sup>4</sup></code> 次</li>\n\t<li>题目数据保证，在查找第 <code>k</code> 大元素时，数组中至少有 <code>k</code> 个元素</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 703&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/\">https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2983出现频率最高的 k 个数字",
        "hardRate": "MEDIUM",
        "passRate": "68.79%",
        "problemsUrl": "https://leetcode.cn/problems/g5c51o/",
        "solutionsUrl": "https://leetcode.cn/problems/g5c51o/solution",
        "problemsDesc": "<p>给定一个整数数组 <code>nums</code> 和一个整数 <code>k</code>&nbsp;，请返回其中出现频率前 <code>k</code> 高的元素。可以按 <strong>任意顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>nums = [1,1,1,2,2,3], k = 2\n<strong>输出: </strong>[1,2]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>nums = [1], k = 1\n<strong>输出: </strong>[1]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li>\n\t<li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code><em>&nbsp;</em>是数组大小。</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 347&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/top-k-frequent-elements/\">https://leetcode-cn.com/problems/top-k-frequent-elements/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2984和最小的 k 个数对",
        "hardRate": "MEDIUM",
        "passRate": "53.47%",
        "problemsUrl": "https://leetcode.cn/problems/qn8gGX/",
        "solutionsUrl": "https://leetcode.cn/problems/qn8gGX/solution",
        "problemsDesc": "<p>给定两个以升序排列的整数数组 <code>nums1</code> 和<strong> </strong><code>nums2</code><strong>&nbsp;</strong>,&nbsp;以及一个整数 <code>k</code><strong>&nbsp;</strong>。</p>\n\n<p>定义一对值&nbsp;<code>(u,v)</code>，其中第一个元素来自&nbsp;<code>nums1</code>，第二个元素来自 <code>nums2</code><strong>&nbsp;</strong>。</p>\n\n<p>请找到和最小的 <code>k</code>&nbsp;个数对&nbsp;<code>(u<sub>1</sub>,v<sub>1</sub>)</code>, <code>&nbsp;(u<sub>2</sub>,v<sub>2</sub>)</code> &nbsp;... &nbsp;<code>(u<sub>k</sub>,v<sub>k</sub>)</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums1 = [1,7,11], nums2 = [2,4,6], k = 3\n<strong>输出:</strong> [1,2],[1,4],[1,6]\n<strong>解释: </strong>返回序列中的前 3 对数：\n    [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>nums1 = [1,1,2], nums2 = [1,2,3], k = 2\n<strong>输出: </strong>[1,1],[1,1]\n<strong>解释: </strong>返回序列中的前 2 对数：\n&nbsp;    [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入: </strong>nums1 = [1,2], nums2 = [3], k = 3 \n<strong>输出:</strong> [1,3],[2,3]\n<strong>解释: </strong>也可能序列中所有的数对都被返回:[1,3],[2,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums1</code>, <code>nums2</code> 均为升序排列</li>\n\t<li><code>1 &lt;= k &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 373&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/\">https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2985实现前缀树",
        "hardRate": "MEDIUM",
        "passRate": "75.61%",
        "problemsUrl": "https://leetcode.cn/problems/QC3q1f/",
        "solutionsUrl": "https://leetcode.cn/problems/QC3q1f/solution",
        "problemsDesc": "<p><strong><a href=\"https://baike.baidu.com/item/字典树/9825209?fr=aladdin\" target=\"_blank\">Trie</a></strong>（发音类似 &quot;try&quot;）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>\n\n<p>请你实现 Trie 类：</p>\n\n<ul>\n\t<li><code>Trie()</code> 初始化前缀树对象。</li>\n\t<li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li>\n\t<li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li>\n\t<li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串&nbsp;<code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\ninputs = [&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]\ninputs = [[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]\n<strong>输出</strong>\n[null, null, true, false, true, null, true]\n\n<strong>解释</strong>\nTrie trie = new Trie();\ntrie.insert(&quot;apple&quot;);\ntrie.search(&quot;apple&quot;);   // 返回 True\ntrie.search(&quot;app&quot;);     // 返回 False\ntrie.startsWith(&quot;app&quot;); // 返回 True\ntrie.insert(&quot;app&quot;);\ntrie.search(&quot;app&quot;);     // 返回 True\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li>\n\t<li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li>\n\t<li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数 <strong>总计</strong> 不超过 <code>3 * 10<sup>4</sup></code> 次</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 208 题相同：<a href=\"https://leetcode-cn.com/problems/implement-trie-prefix-tree/\">https://leetcode-cn.com/problems/implement-trie-prefix-tree/</a>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2986替换单词",
        "hardRate": "MEDIUM",
        "passRate": "71.04%",
        "problemsUrl": "https://leetcode.cn/problems/UhWRSj/",
        "solutionsUrl": "https://leetcode.cn/problems/UhWRSj/solution",
        "problemsDesc": "<p>在英语中，有一个叫做&nbsp;<code>词根(root)</code> 的概念，它可以跟着其他一些词组成另一个较长的单词&mdash;&mdash;我们称这个词为&nbsp;<code>继承词(successor)</code>。例如，词根<code>an</code>，跟随着单词&nbsp;<code>other</code>(其他)，可以形成新的单词&nbsp;<code>another</code>(另一个)。</p>\n\n<p>现在，给定一个由许多词根组成的词典和一个句子，需要将句子中的所有<code>继承词</code>用<code>词根</code>替换掉。如果<code>继承词</code>有许多可以形成它的<code>词根</code>，则用最短的词根替换它。</p>\n\n<p>需要输出替换之后的句子。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>dictionary = [&quot;cat&quot;,&quot;bat&quot;,&quot;rat&quot;], sentence = &quot;the cattle was rattled by the battery&quot;\n<strong>输出：</strong>&quot;the cat was rat by the bat&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>dictionary = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], sentence = &quot;aadsfasf absbs bbab cadsfafs&quot;\n<strong>输出：</strong>&quot;a a b c&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>dictionary = [&quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;, &quot;aaaa&quot;], sentence = &quot;a aa a aaaa aaa aaa aaa aaaaaa bbb baba ababa&quot;\n<strong>输出：</strong>&quot;a a a a a a a a bbb baba a&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>dictionary = [&quot;catt&quot;,&quot;cat&quot;,&quot;bat&quot;,&quot;rat&quot;], sentence = &quot;the cattle was rattled by the battery&quot;\n<strong>输出：</strong>&quot;the cat was rat by the bat&quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>dictionary = [&quot;ac&quot;,&quot;ab&quot;], sentence = &quot;it is abnormal that this solution is accepted&quot;\n<strong>输出：</strong>&quot;it is ab that this solution is ac&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= dictionary.length&nbsp;&lt;= 1000</code></li>\n\t<li><code>1 &lt;= dictionary[i].length &lt;= 100</code></li>\n\t<li><code>dictionary[i]</code>&nbsp;仅由小写字母组成。</li>\n\t<li><code>1 &lt;= sentence.length &lt;= 10^6</code></li>\n\t<li><code>sentence</code>&nbsp;仅由小写字母和空格组成。</li>\n\t<li><code>sentence</code> 中单词的总量在范围 <code>[1, 1000]</code> 内。</li>\n\t<li><code>sentence</code> 中每个单词的长度在范围 <code>[1, 1000]</code> 内。</li>\n\t<li><code>sentence</code> 中单词之间由一个空格隔开。</li>\n\t<li><code>sentence</code>&nbsp;没有前导或尾随空格。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 648&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/replace-words/\">https://leetcode-cn.com/problems/replace-words/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2987神奇的字典",
        "hardRate": "MEDIUM",
        "passRate": "61.09%",
        "problemsUrl": "https://leetcode.cn/problems/US1pGT/",
        "solutionsUrl": "https://leetcode.cn/problems/US1pGT/solution",
        "problemsDesc": "<p>设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 <strong>互不相同</strong> 。 如果给出一个单词，请判定能否只将这个单词中<strong>一个</strong>字母换成另一个字母，使得所形成的新单词存在于已构建的神奇字典中。</p>\n\n<p>实现 <code>MagicDictionary</code> 类：</p>\n\n<ul>\n\t<li><code>MagicDictionary()</code> 初始化对象</li>\n\t<li><code>void buildDict(String[]&nbsp;dictionary)</code> 使用字符串数组&nbsp;<code>dictionary</code> 设定该数据结构，<code>dictionary</code> 中的字符串互不相同</li>\n\t<li><code>bool search(String searchWord)</code> 给定一个字符串 <code>searchWord</code> ，判定能否只将字符串中<strong> 一个 </strong>字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<div class=\"top-view__1vxA\">\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\ninputs = [&quot;MagicDictionary&quot;, &quot;buildDict&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;]\ninputs = [[], [[&quot;hello&quot;, &quot;leetcode&quot;]], [&quot;hello&quot;], [&quot;hhllo&quot;], [&quot;hell&quot;], [&quot;leetcoded&quot;]]\n<strong>输出</strong>\n[null, null, false, true, false, false]\n\n<strong>解释</strong>\nMagicDictionary magicDictionary = new MagicDictionary();\nmagicDictionary.buildDict([&quot;hello&quot;, &quot;leetcode&quot;]);\nmagicDictionary.search(&quot;hello&quot;); // 返回 False\nmagicDictionary.search(&quot;hhllo&quot;); // 将第二个 &#39;h&#39; 替换为 &#39;e&#39; 可以匹配 &quot;hello&quot; ，所以返回 True\nmagicDictionary.search(&quot;hell&quot;); // 返回 False\nmagicDictionary.search(&quot;leetcoded&quot;); // 返回 False\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;dictionary.length &lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;dictionary[i].length &lt;= 100</code></li>\n\t<li><code>dictionary[i]</code> 仅由小写英文字母组成</li>\n\t<li><code>dictionary</code> 中的所有字符串 <strong>互不相同</strong></li>\n\t<li><code>1 &lt;=&nbsp;searchWord.length &lt;= 100</code></li>\n\t<li><code>searchWord</code> 仅由小写英文字母组成</li>\n\t<li><code>buildDict</code> 仅在 <code>search</code> 之前调用一次</li>\n\t<li>最多调用 <code>100</code> 次 <code>search</code></li>\n</ul>\n</div>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 676&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/implement-magic-dictionary/\">https://leetcode-cn.com/problems/implement-magic-dictionary/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2988最短的单词编码",
        "hardRate": "MEDIUM",
        "passRate": "63.24%",
        "problemsUrl": "https://leetcode.cn/problems/iSwD2y/",
        "solutionsUrl": "https://leetcode.cn/problems/iSwD2y/solution",
        "problemsDesc": "<p>单词数组&nbsp;<code>words</code> 的 <strong>有效编码</strong> 由任意助记字符串 <code>s</code> 和下标数组 <code>indices</code> 组成，且满足：</p>\n\n<ul>\n\t<li><code>words.length == indices.length</code></li>\n\t<li>助记字符串 <code>s</code> 以 <code>&#39;#&#39;</code> 字符结尾</li>\n\t<li>对于每个下标 <code>indices[i]</code> ，<code>s</code> 的一个从 <code>indices[i]</code> 开始、到下一个 <code>&#39;#&#39;</code> 字符结束（但不包括 <code>&#39;#&#39;</code>）的 <strong>子字符串</strong> 恰好与 <code>words[i]</code> 相等</li>\n</ul>\n\n<p>给定一个单词数组&nbsp;<code>words</code> ，返回成功对 <code>words</code> 进行编码的最小助记字符串 <code>s</code> 的长度 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]\n<strong>输出：</strong>10\n<strong>解释：</strong>一组有效编码为 s = <code>&quot;time#bell#&quot; 和 indices = [0, 2, 5</code>] 。\nwords[0] = &quot;time&quot; ，s 开始于 indices[0] = 0 到下一个 &#39;#&#39; 结束的子字符串，如加粗部分所示 &quot;<strong>time</strong>#bell#&quot;\nwords[1] = &quot;me&quot; ，s 开始于 indices[1] = 2 到下一个 &#39;#&#39; 结束的子字符串，如加粗部分所示 &quot;ti<strong>me</strong>#bell#&quot;\nwords[2] = &quot;bell&quot; ，s 开始于 indices[2] = 5 到下一个 &#39;#&#39; 结束的子字符串，如加粗部分所示 &quot;time#<strong>bell</strong>#&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [&quot;t&quot;]\n<strong>输出：</strong>2\n<strong>解释：</strong>一组有效编码为 s = &quot;t#&quot; 和 indices = [0] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 2000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 7</code></li>\n\t<li><code>words[i]</code> 仅由小写字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 820&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/short-encoding-of-words/\">https://leetcode-cn.com/problems/short-encoding-of-words/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2989单词之和",
        "hardRate": "MEDIUM",
        "passRate": "64.41%",
        "problemsUrl": "https://leetcode.cn/problems/z1R5dt/",
        "solutionsUrl": "https://leetcode.cn/problems/z1R5dt/solution",
        "problemsDesc": "<p>实现一个 <code>MapSum</code> 类，支持两个方法，<code>insert</code>&nbsp;和&nbsp;<code>sum</code>：</p>\n\n<ul>\n\t<li><code>MapSum()</code> 初始化 <code>MapSum</code> 对象</li>\n\t<li><code>void insert(String key, int val)</code> 插入 <code>key-val</code> 键值对，字符串表示键 <code>key</code> ，整数表示值 <code>val</code> 。如果键 <code>key</code> 已经存在，那么原来的键值对将被替代成新的键值对。</li>\n\t<li><code>int sum(string prefix)</code> 返回所有以该前缀 <code>prefix</code> 开头的键 <code>key</code> 的值的总和。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\ninputs = [&quot;MapSum&quot;, &quot;insert&quot;, &quot;sum&quot;, &quot;insert&quot;, &quot;sum&quot;]\ninputs = [[], [&quot;apple&quot;, 3], [&quot;ap&quot;], [&quot;app&quot;, 2], [&quot;ap&quot;]]\n<strong>输出：</strong>\n[null, null, 3, null, 5]\n\n<strong>解释：</strong>\nMapSum mapSum = new MapSum();\nmapSum.insert(&quot;apple&quot;, 3);  \nmapSum.sum(&quot;ap&quot;);           // return 3 (<u>ap</u>ple = 3)\nmapSum.insert(&quot;app&quot;, 2);    \nmapSum.sum(&quot;ap&quot;);           // return 5 (<u>ap</u>ple + <u>ap</u>p = 3 + 2 = 5)\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= key.length, prefix.length &lt;= 50</code></li>\n\t<li><code>key</code> 和 <code>prefix</code> 仅由小写英文字母组成</li>\n\t<li><code>1 &lt;= val &lt;= 1000</code></li>\n\t<li>最多调用 <code>50</code> 次 <code>insert</code> 和 <code>sum</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 677&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/map-sum-pairs/\">https://leetcode-cn.com/problems/map-sum-pairs/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2990最大的异或",
        "hardRate": "MEDIUM",
        "passRate": "65.72%",
        "problemsUrl": "https://leetcode.cn/problems/ms70jA/",
        "solutionsUrl": "https://leetcode.cn/problems/ms70jA/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，返回<em> </em><code>nums[i] XOR nums[j]</code> 的最大运算结果，其中 <code>0 ≤ i ≤ j &lt; n</code> 。</p>\n\n<p>&nbsp;</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,10,5,25,2,8]\n<strong>输出：</strong>28\n<strong>解释：</strong>最大运算结果是 5 XOR 25 = 28.</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [14,70,53,83,49,91,36,80,92,51,66,70]\n<strong>输出：</strong>127\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 421&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/\">https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2991查找插入位置",
        "hardRate": "EASY",
        "passRate": "49.11%",
        "problemsUrl": "https://leetcode.cn/problems/N6YdxV/",
        "solutionsUrl": "https://leetcode.cn/problems/N6YdxV/solution",
        "problemsDesc": "<p>给定一个排序的整数数组 <code>nums</code>&nbsp;和一个整数目标值<code> target</code> ，请在数组中找到&nbsp;<code>target&nbsp;</code>，并返回其下标。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>\n\n<p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,3,5,6], target = 5\n<strong>输出:</strong> 2\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,3,5,6], target = 2\n<strong>输出:</strong> 1\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,3,5,6], target = 7\n<strong>输出:</strong> 4\n</pre>\n\n<p><strong>示例 4:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,3,5,6], target = 0\n<strong>输出:</strong> 0\n</pre>\n\n<p><strong>示例 5:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1], target = 0\n<strong>输出:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> 为<strong>无重复元素</strong>的<strong>升序</strong>排列数组</li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 35&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/search-insert-position/\">https://leetcode-cn.com/problems/search-insert-position/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2992山峰数组的顶部",
        "hardRate": "EASY",
        "passRate": "70.63%",
        "problemsUrl": "https://leetcode.cn/problems/B1IidL/",
        "solutionsUrl": "https://leetcode.cn/problems/B1IidL/solution",
        "problemsDesc": "<p>符合下列属性的数组 <code>arr</code> 称为 <strong>山峰数组</strong>（<strong>山脉数组）</strong> ：</p>\n\n<ul>\n\t<li><code>arr.length &gt;= 3</code></li>\n\t<li>存在 <code>i</code>（<code>0 &lt; i&nbsp;&lt; arr.length - 1</code>）使得：\n\t<ul>\n\t\t<li><code>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] </code></li>\n\t\t<li><code>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>给定由整数组成的山峰数组 <code>arr</code> ，返回任何满足 <code>arr[0] &lt; arr[1] &lt; ... arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code> 的下标 <code>i</code>&nbsp;，即山峰顶部。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,1,0]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,3,5,4,2]\n<strong>输出：2</strong>\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,10,5,2]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [3,4,5,1]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [24,69,100,99,79,78,67,36,26,19]\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10<sup>6</sup></code></li>\n\t<li>题目数据保证 <code>arr</code> 是一个山脉数组</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>很容易想到时间复杂度 <code>O(n)</code> 的解决方案，你可以设计一个 <code>O(log(n))</code> 的解决方案吗？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 852&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/\">https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2993排序数组中只出现一次的数字",
        "hardRate": "MEDIUM",
        "passRate": "61.33%",
        "problemsUrl": "https://leetcode.cn/problems/skFtm2/",
        "solutionsUrl": "https://leetcode.cn/problems/skFtm2/solution",
        "problemsDesc": "<p>给定一个只包含整数的有序数组 <code>nums</code>&nbsp;，每个元素都会出现两次，唯有一个数只会出现一次，请找出这个唯一的数字。</p>\n\n<p>你设计的解决方案必须满足 <code>O(log n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,1,2,3,3,4,4,8,8]\n<strong>输出:</strong> 2\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums =  [3,3,7,7,10,11,11]\n<strong>输出:</strong> 10\n</pre>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i]&nbsp;&lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 540&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/single-element-in-a-sorted-array/\">https://leetcode-cn.com/problems/single-element-in-a-sorted-array/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2994按权重生成随机数",
        "hardRate": "MEDIUM",
        "passRate": "49.79%",
        "problemsUrl": "https://leetcode.cn/problems/cuyjEf/",
        "solutionsUrl": "https://leetcode.cn/problems/cuyjEf/solution",
        "problemsDesc": "<p>给定一个正整数数组&nbsp;<code>w</code> ，其中&nbsp;<code>w[i]</code>&nbsp;代表下标 <code>i</code>&nbsp;的权重（下标从 <code>0</code> 开始），请写一个函数&nbsp;<code>pickIndex</code>&nbsp;，它可以随机地获取下标 <code>i</code>，选取下标 <code>i</code>&nbsp;的概率与&nbsp;<code>w[i]</code>&nbsp;成正比。</p>\n\n<ol>\n</ol>\n\n<p>例如，对于 <code>w = [1, 3]</code>，挑选下标 <code>0</code> 的概率为 <code>1 / (1 + 3)&nbsp;= 0.25</code> （即，25%），而选取下标 <code>1</code> 的概率为 <code>3 / (1 + 3)&nbsp;= 0.75</code>（即，75%）。</p>\n\n<p>也就是说，选取下标 <code>i</code> 的概率为 <code>w[i] / sum(w)</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\ninputs = [&quot;Solution&quot;,&quot;pickIndex&quot;]\ninputs = [[[1]],[]]\n<strong>输出：</strong>\n[null,0]\n<strong>解释：</strong>\nSolution solution = new Solution([1]);\nsolution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>\ninputs = [&quot;Solution&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;]\ninputs = [[[1,3]],[],[],[],[],[]]\n<strong>输出：</strong>\n[null,1,1,1,1,0]\n<strong>解释：</strong>\nSolution solution = new Solution([1, 3]);\nsolution.pickIndex(); // 返回 1，返回下标 1，返回该下标概率为 3/4 。\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 0，返回下标 0，返回该下标概率为 1/4 。\n\n由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的:\n[null,1,1,1,1,0]\n[null,1,1,1,1,1]\n[null,1,1,1,0,0]\n[null,1,1,1,0,1]\n[null,1,0,1,0,0]\n......\n诸若此类。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= w.length &lt;= 10000</code></li>\n\t<li><code>1 &lt;= w[i] &lt;= 10^5</code></li>\n\t<li><code>pickIndex</code>&nbsp;将被调用不超过&nbsp;<code>10000</code>&nbsp;次</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 528&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/random-pick-with-weight/\">https://leetcode-cn.com/problems/random-pick-with-weight/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2995求平方根",
        "hardRate": "EASY",
        "passRate": "43.25%",
        "problemsUrl": "https://leetcode.cn/problems/jJ0w9p/",
        "solutionsUrl": "https://leetcode.cn/problems/jJ0w9p/solution",
        "problemsDesc": "<p>给定一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的平方根，即实现&nbsp;<code>int sqrt(int x)</code>&nbsp;函数。</p>\n\n<p>正数的平方根有两个，只输出其中的正数平方根。</p>\n\n<p>如果平方根不是整数，输出只保留整数的部分，小数部分将被舍去。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> x = 4\n<strong>输出:</strong> 2\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> x = 8\n<strong>输出:</strong> 2\n<strong>解释:</strong> 8 的平方根是 2.82842...，由于小数部分将被舍去，所以返回 2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><meta charset=\"UTF-8\" /><code>0 &lt;= x &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 69&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/sqrtx/\">https://leetcode-cn.com/problems/sqrtx/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2996狒狒吃香蕉",
        "hardRate": "MEDIUM",
        "passRate": "53.26%",
        "problemsUrl": "https://leetcode.cn/problems/nZZqjQ/",
        "solutionsUrl": "https://leetcode.cn/problems/nZZqjQ/solution",
        "problemsDesc": "<p>狒狒喜欢吃香蕉。这里有 <code>n</code> 堆香蕉，第 <code>i</code> 堆中有&nbsp;<code>piles[i]</code>&nbsp;根香蕉。警卫已经离开了，将在 <code>h</code> 小时后回来。</p>\n\n<p>狒狒可以决定她吃香蕉的速度 <code>k</code> （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 <code>k</code> 根。如果这堆香蕉少于 <code>k</code> 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉，下一个小时才会开始吃另一堆的香蕉。&nbsp;&nbsp;</p>\n\n<p>狒狒喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p>\n\n<p>返回她可以在 <code>h</code> 小时内吃掉所有香蕉的最小速度 <code>k</code>（<code>k</code> 为整数）。</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [3,6,7,11], h = 8\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [30,11,23,4,20], h = 5\n<strong>输出：</strong>30\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [30,11,23,4,20], h = 6\n<strong>输出：</strong>23\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= piles.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>piles.length &lt;= h &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= piles[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" /><strong>注意：</strong>本题与主站 875&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/koko-eating-bananas/\">https://leetcode-cn.com/problems/koko-eating-bananas/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2997合并区间",
        "hardRate": "MEDIUM",
        "passRate": "56.57%",
        "problemsUrl": "https://leetcode.cn/problems/SsGoHC/",
        "solutionsUrl": "https://leetcode.cn/problems/SsGoHC/solution",
        "problemsDesc": "<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,3],[2,6],[8,10],[15,18]]\n<strong>输出：</strong>[[1,6],[8,10],[15,18]]\n<strong>解释：</strong>区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,4],[4,5]]\n<strong>输出：</strong>[[1,5]]\n<strong>解释：</strong>区间 [1,4] 和 [4,5] 可被视为重叠区间。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 56&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/merge-intervals/\">https://leetcode-cn.com/problems/merge-intervals/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2998数组相对排序",
        "hardRate": "EASY",
        "passRate": "70.17%",
        "problemsUrl": "https://leetcode.cn/problems/0H97ZC/",
        "solutionsUrl": "https://leetcode.cn/problems/0H97ZC/solution",
        "problemsDesc": "<p>给定两个数组，<code>arr1</code> 和&nbsp;<code>arr2</code>，</p>\n\n<ul>\n\t<li><code>arr2</code>&nbsp;中的元素各不相同</li>\n\t<li><code>arr2</code> 中的每个元素都出现在&nbsp;<code>arr1</code>&nbsp;中</li>\n</ul>\n\n<p>对 <code>arr1</code>&nbsp;中的元素进行排序，使 <code>arr1</code> 中项的相对顺序和&nbsp;<code>arr2</code>&nbsp;中的相对顺序相同。未在&nbsp;<code>arr2</code>&nbsp;中出现过的元素需要按照升序放在&nbsp;<code>arr1</code>&nbsp;的末尾。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]\n<strong>输出：</strong>[2,2,2,1,4,3,3,9,6,7,19]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr1.length, arr2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= arr1[i], arr2[i] &lt;= 1000</code></li>\n\t<li><code>arr2</code>&nbsp;中的元素&nbsp;<code>arr2[i]</code>&nbsp;各不相同</li>\n\t<li><code>arr2</code> 中的每个元素&nbsp;<code>arr2[i]</code>&nbsp;都出现在&nbsp;<code>arr1</code>&nbsp;中</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 1122&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/relative-sort-array/\">https://leetcode-cn.com/problems/relative-sort-array/</a>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2999数组中的第 k 大的数字",
        "hardRate": "MEDIUM",
        "passRate": "67.13%",
        "problemsUrl": "https://leetcode.cn/problems/xx4gT2/",
        "solutionsUrl": "https://leetcode.cn/problems/xx4gT2/solution",
        "problemsDesc": "<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code><strong>k</strong></code> 个最大的元素。</p>\n\n<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>[3,2,1,5,6,4] 和</code> k = 2\n<strong>输出:</strong> 5\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>[3,2,3,1,2,4,5,5,6] 和</code> k = 4\n<strong>输出:</strong> 4</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示： </strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 215&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/\">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3000链表排序",
        "hardRate": "MEDIUM",
        "passRate": "62.91%",
        "problemsUrl": "https://leetcode.cn/problems/7WHec2/",
        "solutionsUrl": "https://leetcode.cn/problems/7WHec2/solution",
        "problemsDesc": "<p>给定链表的头结点&nbsp;<code>head</code>&nbsp;，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg\" style=\"width: 302px; \" /></p>\n\n<pre>\n<b>输入：</b>head = [4,2,1,3]\n<b>输出：</b>[1,2,3,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg\" style=\"width: 402px; \" /></p>\n\n<pre>\n<b>输入：</b>head = [-1,5,3,4,0]\n<b>输出：</b>[-1,0,3,4,5]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>head = []\n<b>输出：</b>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li>链表中节点的数目在范围&nbsp;<code>[0, 5 * 10<sup>4</sup>]</code>&nbsp;内</li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>进阶：</b>你可以在&nbsp;<code>O(n&nbsp;log&nbsp;n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 148&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/sort-list/\">https://leetcode-cn.com/problems/sort-list/</a></p>\n",
        "isPlus": false
    }
]