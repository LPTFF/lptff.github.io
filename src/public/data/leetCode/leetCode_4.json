[
    {
        "problemsName": " 226.翻转二叉树",
        "hardRate": "EASY",
        "passRate": "79.54%",
        "problemsUrl": "https://leetcode.cn/problems/invert-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/invert-binary-tree/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg\" style=\"height: 165px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [4,2,7,1,3,6,9]\n<strong>输出：</strong>[4,7,2,9,6,3,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg\" style=\"width: 500px; height: 120px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [2,1,3]\n<strong>输出：</strong>[2,3,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目范围在 <code>[0, 100]</code> 内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 227.基本计算器 II",
        "hardRate": "MEDIUM",
        "passRate": "44.46%",
        "problemsUrl": "https://leetcode.cn/problems/basic-calculator-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/basic-calculator-ii/solution",
        "problemsDesc": "<p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>\n\n<p>整数除法仅保留整数部分。</p>\n\n<p>你可以假设给定的表达式总是有效的。所有中间结果将在&nbsp;<code>[-2<sup>31</sup>, 2<sup>31</sup>&nbsp;- 1]</code> 的范围内。</p>\n\n<p><strong>注意：</strong>不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"3+2*2\"\n<strong>输出：</strong>7\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \" 3/2 \"\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \" 3+5 / 2 \"\n<strong>输出：</strong>5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由整数和算符 <code>('+', '-', '*', '/')</code> 组成，中间由一些空格隔开</li>\n\t<li><code>s</code> 表示一个 <strong>有效表达式</strong></li>\n\t<li>表达式中的所有整数都是非负整数，且在范围 <code>[0, 2<sup>31</sup> - 1]</code> 内</li>\n\t<li>题目数据保证答案是一个 <strong>32-bit 整数</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 228.汇总区间",
        "hardRate": "EASY",
        "passRate": "54.55%",
        "problemsUrl": "https://leetcode.cn/problems/summary-ranges/",
        "solutionsUrl": "https://leetcode.cn/problems/summary-ranges/solution",
        "problemsDesc": "<p>给定一个 &nbsp;<strong>无重复元素</strong> 的&nbsp;<strong>有序</strong> 整数数组 <code>nums</code> 。</p>\n\n<p>返回 <em><strong>恰好覆盖数组中所有数字</strong> 的 <strong>最小有序</strong> 区间范围列表&nbsp;</em>。也就是说，<code>nums</code> 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 <code>nums</code> 的数字 <code>x</code> 。</p>\n\n<p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p>\n\n<ul>\n\t<li><code>\"a-&gt;b\"</code> ，如果 <code>a != b</code></li>\n\t<li><code>\"a\"</code> ，如果 <code>a == b</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,2,4,5,7]\n<strong>输出：</strong>[\"0-&gt;2\",\"4-&gt;5\",\"7\"]\n<strong>解释：</strong>区间范围是：\n[0,2] --&gt; \"0-&gt;2\"\n[4,5] --&gt; \"4-&gt;5\"\n[7,7] --&gt; \"7\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,2,3,4,6,8,9]\n<strong>输出：</strong>[\"0\",\"2-&gt;4\",\"6\",\"8-&gt;9\"]\n<strong>解释：</strong>区间范围是：\n[0,0] --&gt; \"0\"\n[2,4] --&gt; \"2-&gt;4\"\n[6,6] --&gt; \"6\"\n[8,9] --&gt; \"8-&gt;9\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 20</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>nums</code> 中的所有值都 <strong>互不相同</strong></li>\n\t<li><code>nums</code> 按升序排列</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 229.多数元素 II",
        "hardRate": "MEDIUM",
        "passRate": "54.00%",
        "problemsUrl": "https://leetcode.cn/problems/majority-element-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/majority-element-ii/solution",
        "problemsDesc": "<p>给定一个大小为&nbsp;<em>n&nbsp;</em>的整数数组，找出其中所有出现超过&nbsp;<code>⌊ n/3 ⌋</code>&nbsp;次的元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,3]\n<strong>输出：</strong>[3]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1]\n<strong>输出：</strong>[1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2]\n<strong>输出：</strong>[1,2]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 230.二叉搜索树中第K小的元素",
        "hardRate": "MEDIUM",
        "passRate": "76.04%",
        "problemsUrl": "https://leetcode.cn/problems/kth-smallest-element-in-a-bst/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-smallest-element-in-a-bst/solution",
        "problemsDesc": "<p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code><strong> </strong>个最小元素（从 1 开始计数）。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg\" style=\"width: 212px; height: 301px;\" />\n<pre>\n<strong>输入：</strong>root = [3,1,4,null,2], k = 1\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg\" style=\"width: 382px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>root = [5,3,6,2,4,null,null,1], k = 3\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数为 <code>n</code> 。</li>\n\t<li><code>1 <= k <= n <= 10<sup>4</sup></code></li>\n\t<li><code>0 <= Node.val <= 10<sup>4</sup></code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 <code>k</code> 小的值，你将如何优化算法？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 231.2 的幂",
        "hardRate": "EASY",
        "passRate": "50.08%",
        "problemsUrl": "https://leetcode.cn/problems/power-of-two/",
        "solutionsUrl": "https://leetcode.cn/problems/power-of-two/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code>，请你判断该整数是否是 2 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>如果存在一个整数 <code>x</code> 使得 <code>n == 2<sup>x</sup></code> ，则认为 <code>n</code> 是 2 的幂次方。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>true\n<strong>解释：</strong>2<sup>0</sup> = 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 16\n<strong>输出：</strong>true\n<strong>解释：</strong>2<sup>4</sup> = 16\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> <= n <= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你能够不使用循环/递归解决此问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 232.用栈实现队列",
        "hardRate": "EASY",
        "passRate": "68.30%",
        "problemsUrl": "https://leetcode.cn/problems/implement-queue-using-stacks/",
        "solutionsUrl": "https://leetcode.cn/problems/implement-queue-using-stacks/solution",
        "problemsDesc": "<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p>\n\n<p>实现 <code>MyQueue</code> 类：</p>\n\n<ul>\n\t<li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li>\n\t<li><code>int pop()</code> 从队列的开头移除并返回元素</li>\n\t<li><code>int peek()</code> 返回队列开头的元素</li>\n\t<li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li>\n</ul>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有&nbsp;<code>push to top</code>,&nbsp;<code>peek/pop from top</code>,&nbsp;<code>size</code>, 和&nbsp;<code>is empty</code>&nbsp;操作是合法的。</li>\n\t<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n<strong>输出：</strong>\n[null, null, null, 1, 1, false]\n\n<strong>解释：</strong>\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n</pre>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= x &lt;= 9</code></li>\n\t<li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li>\n\t<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 233.数字 1 的个数",
        "hardRate": "HARD",
        "passRate": "49.07%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-digit-one/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-digit-one/solution",
        "problemsDesc": "<p>给定一个整数 <code>n</code>，计算所有小于等于 <code>n</code> 的非负整数中数字 <code>1</code> 出现的个数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 13\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 0\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 234.回文链表",
        "hardRate": "EASY",
        "passRate": "53.30%",
        "problemsUrl": "https://leetcode.cn/problems/palindrome-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/palindrome-linked-list/solution",
        "problemsDesc": "<p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg\" style=\"width: 422px; height: 62px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,2,1]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg\" style=\"width: 182px; height: 62px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点数目在范围<code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能否用&nbsp;<code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 235.二叉搜索树的最近公共祖先",
        "hardRate": "MEDIUM",
        "passRate": "68.37%",
        "problemsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/solution",
        "problemsDesc": "<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>\n\n<p><a href=\"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin\" target=\"_blank\">百度百科</a>中最近公共祖先的定义为：&ldquo;对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。&rdquo;</p>\n\n<p>例如，给定如下二叉搜索树:&nbsp; root =&nbsp;[6,2,8,0,4,7,9,null,null,3,5]</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png\" style=\"height: 190px; width: 200px;\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n<strong>输出:</strong> 6 \n<strong>解释: </strong>节点 <code>2 </code>和节点 <code>8 </code>的最近公共祖先是 <code>6。</code>\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n<strong>输出:</strong> 2\n<strong>解释: </strong>节点 <code>2</code> 和节点 <code>4</code> 的最近公共祖先是 <code>2</code>, 因为根据定义最近公共祖先节点可以为节点本身。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li>所有节点的值都是唯一的。</li>\n\t<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 236.二叉树的最近公共祖先",
        "hardRate": "MEDIUM",
        "passRate": "69.73%",
        "problemsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solution",
        "problemsDesc": "<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>\n\n<p><a href=\"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin\" target=\"_blank\">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>节点 <code>5 </code>和节点 <code>1 </code>的最近公共祖先是节点 <code>3 。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n<strong>输出：</strong>5\n<strong>解释：</strong>节点 <code>5 </code>和节点 <code>4 </code>的最近公共祖先是节点 <code>5 。</code>因为根据定义最近公共祖先节点可以为节点本身。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2], p = 1, q = 2\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[2, 10<sup>5</sup>]</code> 内。</li>\n\t<li><code>-10<sup>9</sup> <= Node.val <= 10<sup>9</sup></code></li>\n\t<li>所有 <code>Node.val</code> <code>互不相同</code> 。</li>\n\t<li><code>p != q</code></li>\n\t<li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 237.删除链表中的节点",
        "hardRate": "MEDIUM",
        "passRate": "86.11%",
        "problemsUrl": "https://leetcode.cn/problems/delete-node-in-a-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-node-in-a-linked-list/solution",
        "problemsDesc": "<p>有一个单链表的&nbsp;<code>head</code>，我们想删除它其中的一个节点&nbsp;<code>node</code>。</p>\n\n<p>给你一个需要删除的节点&nbsp;<code>node</code>&nbsp;。你将&nbsp;<strong>无法访问</strong>&nbsp;第一个节点&nbsp;&nbsp;<code>head</code>。</p>\n\n<p>链表的所有值都是 <b>唯一的</b>，并且保证给定的节点&nbsp;<code>node</code>&nbsp;不是链表中的最后一个节点。</p>\n\n<p>删除给定的节点。注意，删除节点并不是指从内存中删除它。这里的意思是：</p>\n\n<ul>\n\t<li>给定节点的值不应该存在于链表中。</li>\n\t<li>链表中的节点数应该减少 1。</li>\n\t<li><code>node</code>&nbsp;前面的所有值顺序相同。</li>\n\t<li><code>node</code>&nbsp;后面的所有值顺序相同。</li>\n</ul>\n\n<p><strong>自定义测试：</strong></p>\n\n<ul>\n\t<li>对于输入，你应该提供整个链表&nbsp;<code>head</code>&nbsp;和要给出的节点&nbsp;<code>node</code>。<code>node</code>&nbsp;不应该是链表的最后一个节点，而应该是链表中的一个实际节点。</li>\n\t<li>我们将构建链表，并将节点传递给你的函数。</li>\n\t<li>输出将是调用你函数后的整个链表。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node1.jpg\" style=\"height: 286px; width: 400px;\" />\n<pre>\n<strong>输入：</strong>head = [4,5,1,9], node = 5\n<strong>输出：</strong>[4,1,9]\n<strong>解释：</strong>指定链表中值为&nbsp;5&nbsp;的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node2.jpg\" style=\"height: 315px; width: 400px;\" />\n<pre>\n<strong>输入：</strong>head = [4,5,1,9], node = 1\n<strong>输出：</strong>[4,5,9]\n<strong>解释：</strong>指定链表中值为&nbsp;1&nbsp;的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目范围是 <code>[2, 1000]</code></li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li>链表中每个节点的值都是 <strong>唯一</strong> 的</li>\n\t<li>需要删除的节点 <code>node</code> 是 <strong>链表中的节点</strong> ，且 <strong>不是末尾节点</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 238.除自身以外数组的乘积",
        "hardRate": "MEDIUM",
        "passRate": "74.85%",
        "problemsUrl": "https://leetcode.cn/problems/product-of-array-except-self/",
        "solutionsUrl": "https://leetcode.cn/problems/product-of-array-except-self/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>，返回 <em>数组&nbsp;<code>answer</code>&nbsp;，其中&nbsp;<code>answer[i]</code>&nbsp;等于&nbsp;<code>nums</code>&nbsp;中除&nbsp;<code>nums[i]</code>&nbsp;之外其余各元素的乘积</em>&nbsp;。</p>\n\n<p>题目数据 <strong>保证</strong> 数组&nbsp;<code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在&nbsp; <strong>32 位</strong> 整数范围内。</p>\n\n<p>请<strong>不要使用除法，</strong>且在&nbsp;<code>O(<em>n</em>)</code> 时间复杂度内完成此题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = <code>[1,2,3,4]</code>\n<strong>输出:</strong> <code>[24,12,8,6]</code>\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [-1,1,0,-3,3]\n<strong>输出:</strong> [0,0,9,0,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-30 &lt;= nums[i] &lt;= 30</code></li>\n\t<li><strong>保证</strong> 数组&nbsp;<code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在&nbsp; <strong>32 位</strong> 整数范围内</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以在 <code>O(1)</code>&nbsp;的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组<strong>不被视为</strong>额外空间。）</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 239.滑动窗口最大值",
        "hardRate": "HARD",
        "passRate": "49.64%",
        "problemsUrl": "https://leetcode.cn/problems/sliding-window-maximum/",
        "solutionsUrl": "https://leetcode.cn/problems/sliding-window-maximum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>，有一个大小为&nbsp;<code>k</code><em>&nbsp;</em>的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code>&nbsp;个数字。滑动窗口每次只向右移动一位。</p>\n\n<p>返回 <em>滑动窗口中的最大值 </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,3,-1,-3,5,3,6,7], k = 3\n<b>输出：</b>[3,3,5,5,6,7]\n<b>解释：</b>\n滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       <strong>3</strong>\n 1 [3  -1  -3] 5  3  6  7       <strong>3</strong>\n 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong>\n 1  3  -1 [-3  5  3] 6  7       <strong>5</strong>\n 1  3  -1  -3 [5  3  6] 7       <strong>6</strong>\n 1  3  -1  -3  5 [3  6  7]      <strong>7</strong>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1], k = 1\n<b>输出：</b>[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 240.搜索二维矩阵 II",
        "hardRate": "MEDIUM",
        "passRate": "52.83%",
        "problemsUrl": "https://leetcode.cn/problems/search-a-2d-matrix-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/search-a-2d-matrix-ii/solution",
        "problemsDesc": "<p>编写一个高效的算法来搜索&nbsp;<code><em>m</em>&nbsp;x&nbsp;<em>n</em></code>&nbsp;矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>\n\n<ul>\n\t<li>每行的元素从左到右升序排列。</li>\n\t<li>每列的元素从上到下升序排列。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg\" />\n<pre>\n<b>输入：</b>matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n<b>输出：</b>true\n</pre>\n\n<p><b>示例 2：</b></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg\" />\n<pre>\n<b>输入：</b>matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n<b>输出：</b>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 300</code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= matrix[i][j] &lt;= 10<sup>9</sup></code></li>\n\t<li>每行的所有元素从左到右升序排列</li>\n\t<li>每列的所有元素从上到下升序排列</li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= target &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 241.为运算表达式设计优先级",
        "hardRate": "MEDIUM",
        "passRate": "75.59%",
        "problemsUrl": "https://leetcode.cn/problems/different-ways-to-add-parentheses/",
        "solutionsUrl": "https://leetcode.cn/problems/different-ways-to-add-parentheses/solution",
        "problemsDesc": "<p>给你一个由数字和运算符组成的字符串&nbsp;<code>expression</code> ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 <strong>按任意顺序</strong> 返回答案。</p>\n\n<p>生成的测试用例满足其对应输出值符合 32 位整数范围，不同结果的数量不超过 <code>10<sup>4</sup></code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"2-1-1\"\n<strong>输出：</strong>[0,2]\n<strong>解释：</strong>\n((2-1)-1) = 0 \n(2-(1-1)) = 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"2*3-4*5\"\n<strong>输出：</strong>[-34,-14,-10,-10,10]\n<strong>解释：</strong>\n(2*(3-(4*5))) = -34 \n((2*3)-(4*5)) = -14 \n((2*(3-4))*5) = -10 \n(2*((3-4)*5)) = -10 \n(((2*3)-4)*5) = 10\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= expression.length &lt;= 20</code></li>\n\t<li><code>expression</code> 由数字和算符 <code>'+'</code>、<code>'-'</code> 和 <code>'*'</code> 组成。</li>\n\t<li>输入表达式中的所有整数值在范围 <code>[0, 99]</code>&nbsp;</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 242.有效的字母异位词",
        "hardRate": "EASY",
        "passRate": "65.84%",
        "problemsUrl": "https://leetcode.cn/problems/valid-anagram/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-anagram/solution",
        "problemsDesc": "<p>给定两个字符串 <code><em>s</em></code> 和 <code><em>t</em></code> ，编写一个函数来判断 <code><em>t</em></code> 是否是 <code><em>s</em></code> 的字母异位词。</p>\n\n<p><strong>注意：</strong>若 <code><em>s</em></code> 和 <code><em>t</em></code><em> </em>中每个字符出现的次数都相同，则称 <code><em>s</em></code> 和 <code><em>t</em></code><em> </em>互为字母异位词。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> <em>s</em> = \"anagram\", <em>t</em> = \"nagaram\"\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> <em>s</em> = \"rat\", <em>t</em> = \"car\"\n<strong>输出: </strong>false</pre>\n\n<p> </p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length, t.length <= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> 和 <code>t</code> 仅包含小写字母</li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶: </strong>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 243.最短单词距离",
        "hardRate": "EASY",
        "passRate": "66.84%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-word-distance/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-word-distance/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 244.最短单词距离 II",
        "hardRate": "MEDIUM",
        "passRate": "59.69%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-word-distance-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-word-distance-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 245.最短单词距离 III",
        "hardRate": "MEDIUM",
        "passRate": "57.22%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-word-distance-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-word-distance-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 246.中心对称数",
        "hardRate": "EASY",
        "passRate": "47.46%",
        "problemsUrl": "https://leetcode.cn/problems/strobogrammatic-number/",
        "solutionsUrl": "https://leetcode.cn/problems/strobogrammatic-number/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 247.中心对称数 II",
        "hardRate": "MEDIUM",
        "passRate": "54.43%",
        "problemsUrl": "https://leetcode.cn/problems/strobogrammatic-number-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/strobogrammatic-number-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 248.中心对称数 III",
        "hardRate": "HARD",
        "passRate": "49.12%",
        "problemsUrl": "https://leetcode.cn/problems/strobogrammatic-number-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/strobogrammatic-number-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 249.移位字符串分组",
        "hardRate": "MEDIUM",
        "passRate": "64.91%",
        "problemsUrl": "https://leetcode.cn/problems/group-shifted-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/group-shifted-strings/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 250.统计同值子树",
        "hardRate": "MEDIUM",
        "passRate": "63.54%",
        "problemsUrl": "https://leetcode.cn/problems/count-univalue-subtrees/",
        "solutionsUrl": "https://leetcode.cn/problems/count-univalue-subtrees/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 251.展开二维向量",
        "hardRate": "MEDIUM",
        "passRate": "54.89%",
        "problemsUrl": "https://leetcode.cn/problems/flatten-2d-vector/",
        "solutionsUrl": "https://leetcode.cn/problems/flatten-2d-vector/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 252.会议室",
        "hardRate": "EASY",
        "passRate": "57.80%",
        "problemsUrl": "https://leetcode.cn/problems/meeting-rooms/",
        "solutionsUrl": "https://leetcode.cn/problems/meeting-rooms/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 253.会议室 II",
        "hardRate": "MEDIUM",
        "passRate": "52.21%",
        "problemsUrl": "https://leetcode.cn/problems/meeting-rooms-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/meeting-rooms-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 254.因子的组合",
        "hardRate": "MEDIUM",
        "passRate": "56.95%",
        "problemsUrl": "https://leetcode.cn/problems/factor-combinations/",
        "solutionsUrl": "https://leetcode.cn/problems/factor-combinations/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 255.验证前序遍历序列二叉搜索树",
        "hardRate": "MEDIUM",
        "passRate": "49.56%",
        "problemsUrl": "https://leetcode.cn/problems/verify-preorder-sequence-in-binary-search-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/verify-preorder-sequence-in-binary-search-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 256.粉刷房子",
        "hardRate": "MEDIUM",
        "passRate": "69.82%",
        "problemsUrl": "https://leetcode.cn/problems/paint-house/",
        "solutionsUrl": "https://leetcode.cn/problems/paint-house/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 257.二叉树的所有路径",
        "hardRate": "EASY",
        "passRate": "70.69%",
        "problemsUrl": "https://leetcode.cn/problems/binary-tree-paths/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-tree-paths/solution",
        "problemsDesc": "<p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>\n\n<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg\" style=\"width: 207px; height: 293px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,null,5]\n<strong>输出：</strong>[\"1-&gt;2-&gt;5\",\"1-&gt;3\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[\"1\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 100]</code> 内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 258.各位相加",
        "hardRate": "EASY",
        "passRate": "71.04%",
        "problemsUrl": "https://leetcode.cn/problems/add-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/add-digits/solution",
        "problemsDesc": "<p>给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> num =<strong> </strong><code>38</code>\n<strong>输出:</strong> 2 \n<strong>解释: </strong>各位相加的过程为<strong>：\n</strong>38 --&gt; 3 + 8 --&gt; 11\n11 --&gt; 1 + 1 --&gt; 2\n由于&nbsp;<code>2</code> 是一位数，所以返回 2。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> num =<strong> </strong>0\n<strong>输出:</strong> 0</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以不使用循环或者递归，在 <code>O(1)</code> 时间复杂度内解决这个问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 259.较小的三数之和",
        "hardRate": "MEDIUM",
        "passRate": "55.05%",
        "problemsUrl": "https://leetcode.cn/problems/3sum-smaller/",
        "solutionsUrl": "https://leetcode.cn/problems/3sum-smaller/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 260.只出现一次的数字 III",
        "hardRate": "MEDIUM",
        "passRate": "71.99%",
        "problemsUrl": "https://leetcode.cn/problems/single-number-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/single-number-iii/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>\n\n<p>你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,3,2,5]\n<strong>输出：</strong>[3,5]\n<strong>解释：</strong>[5, 3] 也是有效的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,0]\n<strong>输出：</strong>[-1,0]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1]\n<strong>输出：</strong>[1,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>除两个只出现一次的整数外，<code>nums</code> 中的其他数字都出现两次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 261.以图判树",
        "hardRate": "MEDIUM",
        "passRate": "51.05%",
        "problemsUrl": "https://leetcode.cn/problems/graph-valid-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/graph-valid-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 262.行程和用户",
        "hardRate": "HARD",
        "passRate": "41.58%",
        "problemsUrl": "https://leetcode.cn/problems/trips-and-users/",
        "solutionsUrl": "https://leetcode.cn/problems/trips-and-users/solution",
        "problemsDesc": "表：<code>Trips</code>\n<div class=\"original__bRMd\">\n<div>\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| id          | int      |\n| client_id   | int      |\n| driver_id   | int      |\n| city_id     | int      |\n| status      | enum     |\n| request_at  | date     |     \n+-------------+----------+\nid 是这张表的主键。\n这张表中存所有出租车的行程信息。每段行程有唯一 id ，其中 client_id 和 driver_id 是 Users 表中 users_id 的外键。\nstatus 是一个表示行程状态的枚举类型，枚举成员为(‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>表：<code>Users</code></p>\n</div>\n</div>\n\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| users_id    | int      |\n| banned      | enum     |\n| role        | enum     |\n+-------------+----------+\nusers_id 是这张表的主键。\n这张表中存所有用户，每个用户都有一个唯一的 users_id ，role 是一个表示用户身份的枚举类型，枚举成员为 (‘client’, ‘driver’, ‘partner’) 。\nbanned 是一个表示用户是否被禁止的枚举类型，枚举成员为 (‘Yes’, ‘No’) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>取消率</strong> 的计算方式如下：(被司机或乘客取消的非禁止用户生成的订单数量) / (非禁止用户生成的订单总数)。</p>\n\n<p>写一段 SQL 语句查出&nbsp;<code>\"2013-10-01\"</code><strong>&nbsp;</strong>至&nbsp;<code>\"2013-10-03\"</code><strong>&nbsp;</strong>期间非禁止用户（<strong>乘客和司机都必须未被禁止</strong>）的取消率。非禁止用户即 banned 为 No 的用户，禁止用户即 banned 为 Yes 的用户。</p>\n\n<p>返回结果表中的数据可以按任意顺序组织。其中取消率 <code>Cancellation Rate</code> 需要四舍五入保留 <strong>两位小数</strong> 。</p>\n\n<p>查询结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong> \nTrips 表：\n+----+-----------+-----------+---------+---------------------+------------+\n| id | client_id | driver_id | city_id | status              | request_at |\n+----+-----------+-----------+---------+---------------------+------------+\n| 1  | 1         | 10        | 1       | completed           | 2013-10-01 |\n| 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 |\n| 3  | 3         | 12        | 6       | completed           | 2013-10-01 |\n| 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 |\n| 5  | 1         | 10        | 1       | completed           | 2013-10-02 |\n| 6  | 2         | 11        | 6       | completed           | 2013-10-02 |\n| 7  | 3         | 12        | 6       | completed           | 2013-10-02 |\n| 8  | 2         | 12        | 12      | completed           | 2013-10-03 |\n| 9  | 3         | 10        | 12      | completed           | 2013-10-03 |\n| 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |\n+----+-----------+-----------+---------+---------------------+------------+\n\nUsers 表：\n+----------+--------+--------+\n| users_id | banned | role   |\n+----------+--------+--------+\n| 1        | No     | client |\n| 2        | Yes    | client |\n| 3        | No     | client |\n| 4        | No     | client |\n| 10       | No     | driver |\n| 11       | No     | driver |\n| 12       | No     | driver |\n| 13       | No     | driver |\n+----------+--------+--------+\n<strong>输出：</strong>\n+------------+-------------------+\n| Day        | Cancellation Rate |\n+------------+-------------------+\n| 2013-10-01 | 0.33              |\n| 2013-10-02 | 0.00              |\n| 2013-10-03 | 0.50              |\n+------------+-------------------+\n<strong>解释：</strong>\n2013-10-01：\n  - 共有 4 条请求，其中 2 条取消。\n  - 然而，id=2 的请求是由禁止用户（user_id=2）发出的，所以计算时应当忽略它。\n  - 因此，总共有 3 条非禁止请求参与计算，其中 1 条取消。\n  - 取消率为 (1 / 3) = 0.33\n2013-10-02：\n  - 共有 3 条请求，其中 0 条取消。\n  - 然而，id=6 的请求是由禁止用户发出的，所以计算时应当忽略它。\n  - 因此，总共有 2 条非禁止请求参与计算，其中 0 条取消。\n  - 取消率为 (0 / 2) = 0.00\n2013-10-03：\n  - 共有 3 条请求，其中 1 条取消。\n  - 然而，id=8 的请求是由禁止用户发出的，所以计算时应当忽略它。\n  - 因此，总共有 2 条非禁止请求参与计算，其中 1 条取消。\n  - 取消率为 (1 / 2) = 0.50\n</pre>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 263.丑数",
        "hardRate": "EASY",
        "passRate": "50.55%",
        "problemsUrl": "https://leetcode.cn/problems/ugly-number/",
        "solutionsUrl": "https://leetcode.cn/problems/ugly-number/solution",
        "problemsDesc": "<p><strong>丑数 </strong>就是只包含质因数&nbsp;<code>2</code>、<code>3</code> 和 <code>5</code>&nbsp;的正整数。</p>\n\n<p>给你一个整数 <code>n</code> ，请你判断 <code>n</code> 是否为 <strong>丑数</strong> 。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6\n<strong>输出：</strong>true\n<strong>解释：</strong>6 = 2 × 3</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>true\n<strong>解释：</strong>1 没有质因数，因此它的全部质因数是 {2, 3, 5} 的空集。习惯上将其视作第一个丑数。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 14\n<strong>输出：</strong>false\n<strong>解释：</strong>14 不是丑数，因为它包含了另外一个质因数&nbsp;<code>7 </code>。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 264.丑数 II",
        "hardRate": "MEDIUM",
        "passRate": "58.61%",
        "problemsUrl": "https://leetcode.cn/problems/ugly-number-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/ugly-number-ii/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，请你找出并返回第 <code>n</code> 个 <strong>丑数</strong> 。</p>\n\n<p><strong>丑数 </strong>就是只包含质因数 <code>2</code>、<code>3</code> 和/或 <code>5</code> 的正整数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10\n<strong>输出：</strong>12\n<strong>解释：</strong>[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>1 通常被视为丑数。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 1690</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 265.粉刷房子 II",
        "hardRate": "HARD",
        "passRate": "63.50%",
        "problemsUrl": "https://leetcode.cn/problems/paint-house-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/paint-house-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 266.回文排列",
        "hardRate": "EASY",
        "passRate": "70.17%",
        "problemsUrl": "https://leetcode.cn/problems/palindrome-permutation/",
        "solutionsUrl": "https://leetcode.cn/problems/palindrome-permutation/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 267.回文排列 II",
        "hardRate": "MEDIUM",
        "passRate": "47.00%",
        "problemsUrl": "https://leetcode.cn/problems/palindrome-permutation-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/palindrome-permutation-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 268.丢失的数字",
        "hardRate": "EASY",
        "passRate": "66.34%",
        "problemsUrl": "https://leetcode.cn/problems/missing-number/",
        "solutionsUrl": "https://leetcode.cn/problems/missing-number/solution",
        "problemsDesc": "<p>给定一个包含 <code>[0, n]</code>&nbsp;中&nbsp;<code>n</code>&nbsp;个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,0,1]\n<strong>输出：</strong>2\n<b>解释：</b>n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1]\n<strong>输出：</strong>2\n<b>解释：</b>n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [9,6,4,2,3,5,7,0,1]\n<strong>输出：</strong>8\n<b>解释：</b>n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>1\n<b>解释：</b>n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= n</code></li>\n\t<li><code>nums</code> 中的所有数字都 <strong>独一无二</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 269.火星词典",
        "hardRate": "HARD",
        "passRate": "36.59%",
        "problemsUrl": "https://leetcode.cn/problems/alien-dictionary/",
        "solutionsUrl": "https://leetcode.cn/problems/alien-dictionary/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 270.最接近的二叉搜索树值",
        "hardRate": "EASY",
        "passRate": "56.80%",
        "problemsUrl": "https://leetcode.cn/problems/closest-binary-search-tree-value/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-binary-search-tree-value/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 271.字符串的编码与解码",
        "hardRate": "MEDIUM",
        "passRate": "57.77%",
        "problemsUrl": "https://leetcode.cn/problems/encode-and-decode-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/encode-and-decode-strings/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 272.最接近的二叉搜索树值 II",
        "hardRate": "HARD",
        "passRate": "66.09%",
        "problemsUrl": "https://leetcode.cn/problems/closest-binary-search-tree-value-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-binary-search-tree-value-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 273.整数转换英文表示",
        "hardRate": "HARD",
        "passRate": "36.49%",
        "problemsUrl": "https://leetcode.cn/problems/integer-to-english-words/",
        "solutionsUrl": "https://leetcode.cn/problems/integer-to-english-words/solution",
        "problemsDesc": "<p>将非负整数 <code>num</code> 转换为其对应的英文表示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 123\n<strong>输出：</strong>\"One Hundred Twenty Three\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 12345\n<strong>输出：</strong>\"Twelve Thousand Three Hundred Forty Five\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 1234567\n<strong>输出：</strong>\"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 274.H 指数",
        "hardRate": "MEDIUM",
        "passRate": "44.49%",
        "problemsUrl": "https://leetcode.cn/problems/h-index/",
        "solutionsUrl": "https://leetcode.cn/problems/h-index/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>citations</code> ，其中 <code>citations[i]</code> 表示研究者的第 <code>i</code> 篇论文被引用的次数。计算并返回该研究者的 <strong><code>h</code><em>&nbsp;</em>指数</strong>。</p>\n\n<p>根据维基百科上&nbsp;<a href=\"https://baike.baidu.com/item/h-index/3991452?fr=aladdin\" target=\"_blank\">h 指数的定义</a>：<code>h</code> 代表“高引用次数” ，一名科研人员的 <code>h</code><strong> 指数 </strong>是指他（她）至少发表了 <code>h</code> 篇论文，并且每篇论文<strong> 至少</strong> 被引用 <code>h</code> 次。如果 <code>h</code><em> </em>有多种可能的值，<strong><code>h</code> 指数 </strong>是其中最大的那个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong><code>citations = [3,0,6,1,5]</code>\n<strong>输出：</strong>3 \n<strong>解释：</strong>给定数组表示研究者总共有 <code>5</code> 篇论文，每篇论文相应的被引用了 <code>3, 0, 6, 1, 5</code> 次。\n&nbsp;    由于研究者有 <code>3 </code>篇论文每篇 <strong>至少 </strong>被引用了 <code>3</code> 次，其余两篇论文每篇被引用 <strong>不多于</strong> <code>3</code> 次，所以她的 <em>h </em>指数是 <code>3</code>。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>citations = [1,3,1]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == citations.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>0 &lt;= citations[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 275.H 指数 II",
        "hardRate": "MEDIUM",
        "passRate": "45.15%",
        "problemsUrl": "https://leetcode.cn/problems/h-index-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/h-index-ii/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>citations</code> ，其中 <code>citations[i]</code> 表示研究者的第 <code>i</code> 篇论文被引用的次数，<code>citations</code> 已经按照&nbsp;<strong>升序排列&nbsp;</strong>。计算并返回该研究者的 h<strong><em>&nbsp;</em></strong>指数。</p>\n\n<p><a href=\"https://baike.baidu.com/item/h-index/3991452?fr=aladdin\" target=\"_blank\">h 指数的定义</a>：h 代表“高引用次数”（high citations），一名科研人员的 <code>h</code> 指数是指他（她）的 （<code>n</code> 篇论文中）<strong>总共</strong>有 <code>h</code> 篇论文分别被引用了<strong>至少</strong> <code>h</code> 次。</p>\n\n<p>请你设计并实现对数时间复杂度的算法解决此问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入<code>：</code></strong><code>citations = [0,1,3,5,6]</code>\n<strong>输出：</strong>3 \n<strong>解释：</strong>给定数组表示研究者总共有 <code>5</code> 篇论文，每篇论文相应的被引用了 0<code>, 1, 3, 5, 6</code> 次。\n&nbsp;    由于研究者有 <code>3 </code>篇论文每篇<strong> 至少 </strong>被引用了 <code>3</code> 次，其余两篇论文每篇被引用<strong> 不多于</strong> <code>3</code> 次，所以她的<em> h </em>指数是 <code>3</code> 。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>citations = [1,2,100]\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == citations.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= citations[i] &lt;= 1000</code></li>\n\t<li><code>citations</code> 按 <strong>升序排列</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 276.栅栏涂色",
        "hardRate": "MEDIUM",
        "passRate": "53.53%",
        "problemsUrl": "https://leetcode.cn/problems/paint-fence/",
        "solutionsUrl": "https://leetcode.cn/problems/paint-fence/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 277.搜寻名人",
        "hardRate": "MEDIUM",
        "passRate": "57.83%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-celebrity/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-celebrity/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 278.第一个错误的版本",
        "hardRate": "EASY",
        "passRate": "45.34%",
        "problemsUrl": "https://leetcode.cn/problems/first-bad-version/",
        "solutionsUrl": "https://leetcode.cn/problems/first-bad-version/solution",
        "problemsDesc": "<p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>\n\n<p>假设你有 <code>n</code> 个版本 <code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。</p>\n\n<p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 <code>version</code> 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>\n \n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, bad = 4\n<strong>输出：</strong>4\n<strong>解释：</strong>\n<code>调用 isBadVersion(3) -> false \n调用 isBadVersion(5) -> true \n调用 isBadVersion(4) -> true</code>\n<code>所以，4 是第一个错误的版本。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, bad = 1\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= bad <= n <= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 279.完全平方数",
        "hardRate": "MEDIUM",
        "passRate": "66.19%",
        "problemsUrl": "https://leetcode.cn/problems/perfect-squares/",
        "solutionsUrl": "https://leetcode.cn/problems/perfect-squares/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p>\n\n<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = <code>12</code>\n<strong>输出：</strong>3 \n<strong>解释：</strong><code>12 = 4 + 4 + 4</code></pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = <code>13</code>\n<strong>输出：</strong>2\n<strong>解释：</strong><code>13 = 4 + 9</code></pre>\n&nbsp;\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 280.摆动排序",
        "hardRate": "MEDIUM",
        "passRate": "68.85%",
        "problemsUrl": "https://leetcode.cn/problems/wiggle-sort/",
        "solutionsUrl": "https://leetcode.cn/problems/wiggle-sort/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 281.锯齿迭代器",
        "hardRate": "MEDIUM",
        "passRate": "76.84%",
        "problemsUrl": "https://leetcode.cn/problems/zigzag-iterator/",
        "solutionsUrl": "https://leetcode.cn/problems/zigzag-iterator/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 282.给表达式添加运算符",
        "hardRate": "HARD",
        "passRate": "46.87%",
        "problemsUrl": "https://leetcode.cn/problems/expression-add-operators/",
        "solutionsUrl": "https://leetcode.cn/problems/expression-add-operators/solution",
        "problemsDesc": "<p>给定一个仅包含数字&nbsp;<code>0-9</code>&nbsp;的字符串 <code>num</code> 和一个目标值整数 <code>target</code> ，在 <code>num</code> 的数字之间添加 <strong>二元 </strong>运算符（不是一元）<code>+</code>、<code>-</code>&nbsp;或&nbsp;<code>*</code>&nbsp;，返回 <strong>所有</strong> 能够得到 <code>target </code>的表达式。</p>\n\n<p>注意，返回表达式中的操作数 <strong>不应该</strong> 包含前导零。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>num = </code>\"123\", target = 6\n<strong>输出: </strong>[\"1+2+3\", \"1*2*3\"] \n<strong>解释: </strong>“1*2*3” 和 “1+2+3” 的值都是6。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>num = </code>\"232\", target = 8\n<strong>输出: </strong>[\"2*3+2\", \"2+3*2\"]\n<strong>解释:</strong> “2*3+2” 和 “2+3*2” 的值都是8。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>num = </code>\"3456237490\", target = 9191\n<strong>输出: </strong>[]\n<strong>解释: </strong>表达式 “3456237490” 无法得到 9191 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 10</code></li>\n\t<li><code>num</code> 仅含数字</li>\n\t<li><code>-2<sup>31</sup> &lt;= target &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 283.移动零",
        "hardRate": "EASY",
        "passRate": "63.79%",
        "problemsUrl": "https://leetcode.cn/problems/move-zeroes/",
        "solutionsUrl": "https://leetcode.cn/problems/move-zeroes/solution",
        "problemsDesc": "<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>\n\n<p><strong>请注意</strong>&nbsp;，必须在不复制数组的情况下原地对数组进行操作。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = <code>[0,1,0,3,12]</code>\n<strong>输出:</strong> <code>[1,3,12,0,0]</code>\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = <code>[0]</code>\n<strong>输出:</strong> <code>[0]</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示</strong>:</p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= nums[i] &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>进阶：</b>你能尽量减少完成的操作次数吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 284.顶端迭代器",
        "hardRate": "MEDIUM",
        "passRate": "76.55%",
        "problemsUrl": "https://leetcode.cn/problems/peeking-iterator/",
        "solutionsUrl": "https://leetcode.cn/problems/peeking-iterator/solution",
        "problemsDesc": "<p>请你在设计一个迭代器，在集成现有迭代器拥有的&nbsp;<code>hasNext</code> 和 <code>next</code> 操作的基础上，还额外支持 <code>peek</code> 操作。</p>\n\n<p>实现 <code>PeekingIterator</code> 类：</p>\n\n<ul>\n\t<li><code>PeekingIterator(Iterator&lt;int&gt; nums)</code> 使用指定整数迭代器&nbsp;<code>nums</code> 初始化迭代器。</li>\n\t<li><code>int next()</code> 返回数组中的下一个元素，并将指针移动到下个元素处。</li>\n\t<li><code>bool hasNext()</code> 如果数组中存在下一个元素，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n\t<li><code>int peek()</code> 返回数组中的下一个元素，但 <strong>不</strong> 移动指针。</li>\n</ul>\n\n<p><strong>注意：</strong>每种语言可能有不同的构造函数和迭代器&nbsp;<code>Iterator</code>，但均支持 <code>int next()</code> 和 <code>boolean hasNext()</code> 函数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"PeekingIterator\", \"next\", \"peek\", \"next\", \"next\", \"hasNext\"]\n[[[1, 2, 3]], [], [], [], [], []]\n<strong>输出：</strong>\n[null, 1, 2, 2, 3, false]\n\n<strong>解释：</strong>\nPeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [<u><strong>1</strong></u>,2,3]\npeekingIterator.next();    // 返回 1 ，指针移动到下一个元素 [1,<u><strong>2</strong></u>,3]\npeekingIterator.peek();    // 返回 2 ，指针未发生移动 [1,<u><strong>2</strong></u>,3]\npeekingIterator.next();    // 返回 2 ，指针移动到下一个元素 [1,2,<u><strong>3</strong></u>]\npeekingIterator.next();    // 返回 3 ，指针移动到下一个元素 [1,2,3]\npeekingIterator.hasNext(); // 返回 False\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>对 <code>next</code> 和 <code>peek</code> 的调用均有效</li>\n\t<li><code>next</code>、<code>hasNext</code> 和 <code>peek </code>最多调用&nbsp; <code>1000</code> 次</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你将如何拓展你的设计？使之变得通用化，从而适应所有的类型，而不只是整数型？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 285.二叉搜索树中的中序后继",
        "hardRate": "MEDIUM",
        "passRate": "64.44%",
        "problemsUrl": "https://leetcode.cn/problems/inorder-successor-in-bst/",
        "solutionsUrl": "https://leetcode.cn/problems/inorder-successor-in-bst/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 286.墙与门",
        "hardRate": "MEDIUM",
        "passRate": "54.91%",
        "problemsUrl": "https://leetcode.cn/problems/walls-and-gates/",
        "solutionsUrl": "https://leetcode.cn/problems/walls-and-gates/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 287.寻找重复数",
        "hardRate": "MEDIUM",
        "passRate": "64.23%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-duplicate-number/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-duplicate-number/solution",
        "problemsDesc": "<p>给定一个包含&nbsp;<code>n + 1</code> 个整数的数组&nbsp;<code>nums</code> ，其数字都在&nbsp;<code>[1, n]</code>&nbsp;范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p>\n\n<p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回&nbsp;<strong>这个重复的数</strong> 。</p>\n\n<p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,4,2,2]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,1,3,4,2]\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums.length == n + 1</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= n</code></li>\n\t<li><code>nums</code> 中 <strong>只有一个整数</strong> 出现 <strong>两次或多次</strong> ，其余整数均只出现 <strong>一次</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>进阶：</b></p>\n\n<ul>\n\t<li>如何证明 <code>nums</code> 中至少存在一个重复的数字?</li>\n\t<li>你可以设计一个线性级时间复杂度 <code>O(n)</code> 的解决方案吗？</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 288.单词的唯一缩写",
        "hardRate": "MEDIUM",
        "passRate": "49.28%",
        "problemsUrl": "https://leetcode.cn/problems/unique-word-abbreviation/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-word-abbreviation/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 289.生命游戏",
        "hardRate": "MEDIUM",
        "passRate": "75.77%",
        "problemsUrl": "https://leetcode.cn/problems/game-of-life/",
        "solutionsUrl": "https://leetcode.cn/problems/game-of-life/solution",
        "problemsDesc": "<p>根据&nbsp;<a href=\"https://baike.baidu.com/item/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/2926434?fr=aladdin\" target=\"_blank\">百度百科</a>&nbsp;，&nbsp;<strong>生命游戏</strong>&nbsp;，简称为 <strong>生命</strong> ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</p>\n\n<p>给定一个包含 <code>m × n</code>&nbsp;个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： <code>1</code> 即为 <strong>活细胞</strong> （live），或 <code>0</code> 即为 <strong>死细胞</strong> （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p>\n\n<ol>\n\t<li>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</li>\n\t<li>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</li>\n\t<li>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</li>\n\t<li>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</li>\n</ol>\n\n<p>下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 <code>m x n</code> 网格面板 <code>board</code> 的当前状态，返回下一个状态。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/26/grid1.jpg\" />\n<pre>\n<strong>输入：</strong>board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\n<strong>输出：</strong>[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/26/grid2.jpg\" />\n<pre>\n<strong>输入：</strong>board = [[1,1],[1,0]]\n<strong>输出：</strong>[[1,1],[1,1]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 25</code></li>\n\t<li><code>board[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。</li>\n\t<li>本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 290.单词规律",
        "hardRate": "EASY",
        "passRate": "44.62%",
        "problemsUrl": "https://leetcode.cn/problems/word-pattern/",
        "solutionsUrl": "https://leetcode.cn/problems/word-pattern/solution",
        "problemsDesc": "<p>给定一种规律 <code>pattern</code>&nbsp;和一个字符串&nbsp;<code>s</code>&nbsp;，判断 <code>s</code>&nbsp;是否遵循相同的规律。</p>\n\n<p>这里的&nbsp;<strong>遵循&nbsp;</strong>指完全匹配，例如，&nbsp;<code>pattern</code>&nbsp;里的每个字母和字符串&nbsp;<code>s</code><strong>&nbsp;</strong>中的每个非空单词之间存在着双向连接的对应规律。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre>\n<strong>输入:</strong> pattern = <code>\"abba\"</code>, s = <code>\"dog cat cat dog\"</code>\n<strong>输出:</strong> true</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong>pattern = <code>\"abba\"</code>, s = <code>\"dog cat cat fish\"</code>\n<strong>输出:</strong> false</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> pattern = <code>\"aaaa\"</code>, s = <code>\"dog cat cat dog\"</code>\n<strong>输出:</strong> false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pattern.length &lt;= 300</code></li>\n\t<li><code>pattern</code>&nbsp;只包含小写英文字母</li>\n\t<li><code>1 &lt;= s.length &lt;= 3000</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母和&nbsp;<code>' '</code></li>\n\t<li><code>s</code>&nbsp;<strong>不包含</strong> 任何前导或尾随对空格</li>\n\t<li><code>s</code>&nbsp;中每个单词都被 <strong>单个空格 </strong>分隔</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 291.单词规律 II",
        "hardRate": "MEDIUM",
        "passRate": "51.87%",
        "problemsUrl": "https://leetcode.cn/problems/word-pattern-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/word-pattern-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 292.Nim 游戏",
        "hardRate": "EASY",
        "passRate": "70.43%",
        "problemsUrl": "https://leetcode.cn/problems/nim-game/",
        "solutionsUrl": "https://leetcode.cn/problems/nim-game/solution",
        "problemsDesc": "<p>你和你的朋友，两个人一起玩&nbsp;<a href=\"https://baike.baidu.com/item/Nim游戏/6737105\" target=\"_blank\">Nim 游戏</a>：</p>\n\n<ul>\n\t<li>桌子上有一堆石头。</li>\n\t<li>你们轮流进行自己的回合，&nbsp;<strong>你作为先手&nbsp;</strong>。</li>\n\t<li>每一回合，轮到的人拿掉&nbsp;1 - 3 块石头。</li>\n\t<li>拿掉最后一块石头的人就是获胜者。</li>\n</ul>\n\n<p>假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 <code>n</code> 的情况下赢得游戏。如果可以赢，返回 <code>true</code>；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong><code>n = 4</code>\n<strong>输出：</strong>false \n<strong>解释：</strong>以下是可能的结果:\n1. 移除1颗石头。你的朋友移走了3块石头，包括最后一块。你的朋友赢了。\n2. 移除2个石子。你的朋友移走2块石头，包括最后一块。你的朋友赢了。\n3.你移走3颗石子。你的朋友移走了最后一块石头。你的朋友赢了。\n在所有结果中，你的朋友是赢家。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 293.翻转游戏",
        "hardRate": "EASY",
        "passRate": "72.71%",
        "problemsUrl": "https://leetcode.cn/problems/flip-game/",
        "solutionsUrl": "https://leetcode.cn/problems/flip-game/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 294.翻转游戏 II",
        "hardRate": "MEDIUM",
        "passRate": "59.52%",
        "problemsUrl": "https://leetcode.cn/problems/flip-game-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/flip-game-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 295.数据流的中位数",
        "hardRate": "HARD",
        "passRate": "53.43%",
        "problemsUrl": "https://leetcode.cn/problems/find-median-from-data-stream/",
        "solutionsUrl": "https://leetcode.cn/problems/find-median-from-data-stream/solution",
        "problemsDesc": "<p><strong>中位数</strong>是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p>\n\n<ul>\n\t<li>例如 <code>arr = [2,3,4]</code>&nbsp;的中位数是 <code>3</code>&nbsp;。</li>\n\t<li>例如&nbsp;<code>arr = [2,3]</code> 的中位数是 <code>(2 + 3) / 2 = 2.5</code> 。</li>\n</ul>\n\n<p>实现 MedianFinder 类:</p>\n\n<ul>\n\t<li>\n\t<p><code>MedianFinder() </code>初始化 <code>MedianFinder</code>&nbsp;对象。</p>\n\t</li>\n\t<li>\n\t<p><code>void addNum(int num)</code> 将数据流中的整数 <code>num</code> 添加到数据结构中。</p>\n\t</li>\n\t<li>\n\t<p><code>double findMedian()</code> 返回到目前为止所有元素的中位数。与实际答案相差&nbsp;<code>10<sup>-5</sup></code>&nbsp;以内的答案将被接受。</p>\n\t</li>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\n[[], [1], [2], [], [3], []]\n<strong>输出</strong>\n[null, null, null, 1.5, null, 2.0]\n\n<strong>解释</strong>\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.addNum(2);    // arr = [1, 2]\nmedianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)\nmedianFinder.addNum(3);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0</pre>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= num &lt;= 10<sup>5</sup></code></li>\n\t<li>在调用 <code>findMedian</code>&nbsp;之前，数据结构中至少有一个元素</li>\n\t<li>最多&nbsp;<code>5 * 10<sup>4</sup></code>&nbsp;次调用&nbsp;<code>addNum</code>&nbsp;和&nbsp;<code>findMedian</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 296.最佳的碰头地点",
        "hardRate": "HARD",
        "passRate": "61.11%",
        "problemsUrl": "https://leetcode.cn/problems/best-meeting-point/",
        "solutionsUrl": "https://leetcode.cn/problems/best-meeting-point/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 297.二叉树的序列化与反序列化",
        "hardRate": "HARD",
        "passRate": "58.88%",
        "problemsUrl": "https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/solution",
        "problemsDesc": "<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>\n\n<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>\n\n<p><strong>提示: </strong>输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 <a href=\"/faq/#binary-tree\">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg\" style=\"width: 442px; height: 324px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,null,null,4,5]\n<strong>输出：</strong>[1,2,3,null,null,4,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中结点数在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-1000 <= Node.val <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 298.二叉树最长连续序列",
        "hardRate": "MEDIUM",
        "passRate": "59.89%",
        "problemsUrl": "https://leetcode.cn/problems/binary-tree-longest-consecutive-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-tree-longest-consecutive-sequence/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 299.猜数字游戏",
        "hardRate": "MEDIUM",
        "passRate": "57.41%",
        "problemsUrl": "https://leetcode.cn/problems/bulls-and-cows/",
        "solutionsUrl": "https://leetcode.cn/problems/bulls-and-cows/solution",
        "problemsDesc": "<p>你在和朋友一起玩 <a href=\"https://baike.baidu.com/item/%E7%8C%9C%E6%95%B0%E5%AD%97/83200?fromtitle=Bulls+and+Cows&amp;fromid=12003488&amp;fr=aladdin\" target=\"_blank\">猜数字（Bulls and Cows）</a>游戏，该游戏规则如下：</p>\n\n<p>写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示：</p>\n\n<ul>\n\t<li>猜测数字中有多少位属于数字和确切位置都猜对了（称为 \"Bulls\"，公牛），</li>\n\t<li>有多少位属于数字猜对了但是位置不对（称为 \"Cows\"，奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。</li>\n</ul>\n\n<p>给你一个秘密数字&nbsp;<code>secret</code> 和朋友猜测的数字&nbsp;<code>guess</code> ，请你返回对朋友这次猜测的提示。</p>\n\n<p>提示的格式为 <code>\"xAyB\"</code> ，<code>x</code> 是公牛个数， <code>y</code> 是奶牛个数，<code>A</code> 表示公牛，<code>B</code>&nbsp;表示奶牛。</p>\n\n<p>请注意秘密数字和朋友猜测的数字都可能含有重复数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>secret = \"1807\", guess = \"7810\"\n<strong>输出：</strong>\"1A3B\"\n<strong>解释：</strong>数字和位置都对（公牛）用 '|' 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。\n\"1807\"\n  |\n\"<em><strong>7</strong></em>8<em><strong>10</strong></em>\"</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>secret = \"1123\", guess = \"0111\"\n<strong>输出：</strong>\"1A1B\"\n<strong>解释：</strong>数字和位置都对（公牛）用 '|' 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。\n\"1123\"        \"1123\"\n  |      or     |\n\"01<em><strong>1</strong></em>1\"        \"011<em><strong>1</strong></em>\"\n注意，两个不匹配的 1 中，只有一个会算作奶牛（数字猜对位置不对）。通过重新排列非公牛数字，其中仅有一个 1 可以成为公牛数字。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= secret.length, guess.length &lt;= 1000</code></li>\n\t<li><code>secret.length == guess.length</code></li>\n\t<li><code>secret</code> 和 <code>guess</code> 仅由数字组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 300.最长递增子序列",
        "hardRate": "MEDIUM",
        "passRate": "54.81%",
        "problemsUrl": "https://leetcode.cn/problems/longest-increasing-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-increasing-subsequence/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>\n\n<p><strong>子序列&nbsp;</strong>是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,9,2,5,3,7,101,18]\n<strong>输出：</strong>4\n<strong>解释：</strong>最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,0,3,2,3]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [7,7,7,7,7,7,7]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2500</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>进阶：</b></p>\n\n<ul>\n\t<li>你能将算法的时间复杂度降低到&nbsp;<code>O(n log(n))</code> 吗?</li>\n</ul>\n",
        "isPlus": false
    }
]