[
    {
        "problemsName": " 451.根据字符出现频率排序",
        "hardRate": "MEDIUM",
        "passRate": "71.99%",
        "problemsUrl": "https://leetcode.cn/problems/sort-characters-by-frequency/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-characters-by-frequency/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code> ，根据字符出现的 <strong>频率</strong> 对其进行 <strong>降序排序</strong> 。一个字符出现的 <strong>频率</strong> 是它出现在字符串中的次数。</p>\n\n<p>返回 <em>已排序的字符串&nbsp;</em>。如果有多个答案，返回其中任何一个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"tree\"\n<strong>输出: </strong>\"eert\"\n<strong>解释: </strong>'e'出现两次，'r'和't'都只出现一次。\n因此'e'必须出现在'r'和't'之前。此外，\"eetr\"也是一个有效的答案。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"cccaaa\"\n<strong>输出: </strong>\"cccaaa\"\n<strong>解释: </strong>'c'和'a'都出现三次。此外，\"aaaccc\"也是有效的答案。\n注意\"cacaca\"是不正确的，因为相同的字母必须放在一起。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"Aabb\"\n<strong>输出: </strong>\"bbAa\"\n<strong>解释: </strong>此外，\"bbaA\"也是一个有效的答案，但\"Aabb\"是不正确的。\n注意'A'和'a'被认为是两种不同的字符。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;由大小写英文字母和数字组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 452.用最少数量的箭引爆气球",
        "hardRate": "MEDIUM",
        "passRate": "50.67%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/solution",
        "problemsDesc": "<p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组&nbsp;<code>points</code>&nbsp;，其中<code>points[i] = [x<sub>start</sub>, x<sub>end</sub>]</code>&nbsp;表示水平直径在&nbsp;<code>x<sub>start</sub></code>&nbsp;和&nbsp;<code>x<sub>end</sub></code>之间的气球。你不知道气球的确切 y 坐标。</p>\n\n<p>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong> 地射出。在坐标 <code>x</code> 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>x</code><sub><code>start</code>，</sub><code>x</code><sub><code>end</code>，</sub> 且满足 &nbsp;<code>x<sub>start</sub>&nbsp;≤ x ≤ x</code><sub><code>end</code>，</sub>则该气球会被 <strong>引爆</strong>&nbsp;<sub>。</sub>可以射出的弓箭的数量 <strong>没有限制</strong> 。 弓箭一旦被射出之后，可以无限地前进。</p>\n\n<p>给你一个数组 <code>points</code> ，<em>返回引爆所有气球所必须射出的 <strong>最小</strong> 弓箭数&nbsp;</em>。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[10,16],[2,8],[1,6],[7,12]]\n<strong>输出：</strong>2\n<strong>解释：</strong>气球可以用2支箭来爆破:\n-在x = 6处射出箭，击破气球[2,8]和[1,6]。\n-在x = 11处发射箭，击破气球[10,16]和[7,12]。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[1,2],[3,4],[5,6],[7,8]]\n<strong>输出：</strong>4\n<strong>解释：</strong>每个气球需要射出一支箭，总共需要4支箭。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[1,2],[2,3],[3,4],[4,5]]\n<strong>输出：</strong>2\n解释：气球可以用2支箭来爆破:\n- 在x = 2处发射箭，击破气球[1,2]和[2,3]。\n- 在x = 4处射出箭，击破气球[3,4]和[4,5]。</pre>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= points.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= x<sub>start</sub>&nbsp;&lt; x<sub>end</sub>&nbsp;&lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 453.最小操作次数使数组元素相等",
        "hardRate": "MEDIUM",
        "passRate": "61.38%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-moves-to-equal-array-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-moves-to-equal-array-elements/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的整数数组，每次操作将会使 <code>n - 1</code> 个元素增加 <code>1</code> 。返回让数组所有元素相等的最小操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n只需要3次操作（注意每次操作会增加两个元素的值）：\n[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>答案保证符合 <strong>32-bit</strong> 整数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 454.四数相加 II",
        "hardRate": "MEDIUM",
        "passRate": "64.18%",
        "problemsUrl": "https://leetcode.cn/problems/4sum-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/4sum-ii/solution",
        "problemsDesc": "<p>给你四个整数数组 <code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和 <code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组 <code>(i, j, k, l)</code> 能满足：</p>\n\n<ul>\n\t<li><code>0 &lt;= i, j, k, l &lt; n</code></li>\n\t<li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n两个元组如下：\n1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp; <strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length</code></li>\n\t<li><code>n == nums2.length</code></li>\n\t<li><code>n == nums3.length</code></li>\n\t<li><code>n == nums4.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>-2<sup>28</sup> &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 2<sup>28</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 455.分发饼干",
        "hardRate": "EASY",
        "passRate": "56.39%",
        "problemsUrl": "https://leetcode.cn/problems/assign-cookies/",
        "solutionsUrl": "https://leetcode.cn/problems/assign-cookies/solution",
        "problemsDesc": "<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>\n\n<p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code><sub>，</sub>这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code><sub> </sub>。如果 <code>s[j] >= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>\n \n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> g = [1,2,3], s = [1,1]\n<strong>输出:</strong> 1\n<strong>解释:</strong> \n你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。\n虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。\n所以你应该输出1。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> g = [1,2], s = [1,2,3]\n<strong>输出:</strong> 2\n<strong>解释:</strong> \n你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。\n你拥有的饼干数量和尺寸都足以让所有孩子满足。\n所以你应该输出2.\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= g.length <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 <= s.length <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= g[i], s[j] <= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 456.132 模式",
        "hardRate": "MEDIUM",
        "passRate": "36.40%",
        "problemsUrl": "https://leetcode.cn/problems/132-pattern/",
        "solutionsUrl": "https://leetcode.cn/problems/132-pattern/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，数组中共有 <code>n</code> 个整数。<strong>132 模式的子序列</strong> 由三个整数 <code>nums[i]</code>、<code>nums[j]</code> 和 <code>nums[k]</code> 组成，并同时满足：<code>i < j < k</code> 和 <code>nums[i] < nums[k] < nums[j]</code> 。</p>\n\n<p>如果 <code>nums</code> 中存在 <strong>132 模式的子序列</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>false\n<strong>解释：</strong>序列中不存在 132 模式的子序列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,1,4,2]\n<strong>输出：</strong>true\n<strong>解释：</strong>序列中有 1 个 132 模式的子序列： [1, 4, 2] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,3,2,0]\n<strong>输出：</strong>true\n<strong>解释：</strong>序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 <= n <= 2 * 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 457.环形数组是否存在循环",
        "hardRate": "MEDIUM",
        "passRate": "43.34%",
        "problemsUrl": "https://leetcode.cn/problems/circular-array-loop/",
        "solutionsUrl": "https://leetcode.cn/problems/circular-array-loop/solution",
        "problemsDesc": "<p>存在一个不含 <code>0</code> 的<strong> 环形 </strong>数组&nbsp;<code>nums</code> ，每个 <code>nums[i]</code> 都表示位于下标 <code>i</code> 的角色应该向前或向后移动的下标个数：</p>\n\n<ul>\n\t<li>如果 <code>nums[i]</code> 是正数，<strong>向前</strong>（下标递增方向）移动 <code>|nums[i]|</code> 步</li>\n\t<li>如果&nbsp;<code>nums[i]</code> 是负数，<strong>向后</strong>（下标递减方向）移动 <code>|nums[i]|</code> 步</li>\n</ul>\n\n<p>因为数组是 <strong>环形</strong> 的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。</p>\n\n<p>数组中的 <strong>循环</strong> 由长度为 <code>k</code> 的下标序列 <code>seq</code> 标识：</p>\n\n<ul>\n\t<li>遵循上述移动规则将导致一组重复下标序列 <code>seq[0] -&gt; seq[1] -&gt; ... -&gt; seq[k - 1] -&gt; seq[0] -&gt; ...</code></li>\n\t<li>所有 <code>nums[seq[j]]</code> 应当不是 <strong>全正</strong> 就是 <strong>全负</strong></li>\n\t<li><code>k &gt; 1</code></li>\n</ul>\n\n<p>如果 <code>nums</code> 中存在循环，返回 <code>true</code> ；否则，返回<em> </em><code>false</code><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,-1,1,2,2]\n<strong>输出：</strong>true\n<strong>解释：</strong>存在循环，按下标 0 -&gt; 2 -&gt; 3 -&gt; 0 。循环长度为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,2]\n<strong>输出：</strong>false\n<strong>解释：</strong>按下标 1 -&gt; 1 -&gt; 1 ... 的运动无法构成循环，因为循环的长度为 1 。根据定义，循环的长度必须大于 1 。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-2,1,-1,-2,-2]\n<strong>输出：</strong>false\n<strong>解释：</strong>按下标 1 -&gt; 2 -&gt; 1 -&gt; ... 的运动无法构成循环，因为 nums[1] 是正数，而 nums[2] 是负数。\n所有 nums[seq[j]] 应当不是全正就是全负。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>nums[i] != 0</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能设计一个时间复杂度为 <code>O(n)</code> 且额外空间复杂度为 <code>O(1)</code> 的算法吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 458.可怜的小猪",
        "hardRate": "HARD",
        "passRate": "67.64%",
        "problemsUrl": "https://leetcode.cn/problems/poor-pigs/",
        "solutionsUrl": "https://leetcode.cn/problems/poor-pigs/solution",
        "problemsDesc": "<p>有<code> buckets</code> 桶液体，其中 <strong>正好有一桶</strong>&nbsp;含有毒药，其余装的都是水。它们从外观看起来都一样。为了弄清楚哪只水桶含有毒药，你可以喂一些猪喝，通过观察猪是否会死进行判断。不幸的是，你只有&nbsp;<code>minutesToTest</code> 分钟时间来确定哪桶液体是有毒的。</p>\n\n<p>喂猪的规则如下：</p>\n\n<ol>\n\t<li>选择若干活猪进行喂养</li>\n\t<li>可以允许小猪同时饮用任意数量的桶中的水，并且该过程不需要时间。</li>\n\t<li>小猪喝完水后，必须有 <code>minutesToDie</code> 分钟的冷却时间。在这段时间里，你只能观察，而不允许继续喂猪。</li>\n\t<li>过了 <code>minutesToDie</code> 分钟后，所有喝到毒药的猪都会死去，其他所有猪都会活下来。</li>\n\t<li>重复这一过程，直到时间用完。</li>\n</ol>\n\n<p>给你桶的数目 <code>buckets</code> ，<code>minutesToDie</code> 和 <code>minutesToTest</code> ，返回&nbsp;<em>在规定时间内判断哪个桶有毒所需的 <strong>最小</strong> 猪数</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>buckets = 1000, minutesToDie = 15, minutesToTest = 60\n<strong>输出：</strong>5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>buckets = 4, minutesToDie = 15, minutesToTest = 15\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>buckets = 4, minutesToDie = 15, minutesToTest = 30\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= buckets &lt;= 1000</code></li>\n\t<li><code>1 &lt;=&nbsp;minutesToDie &lt;=&nbsp;minutesToTest &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 459.重复的子字符串",
        "hardRate": "EASY",
        "passRate": "51.24%",
        "problemsUrl": "https://leetcode.cn/problems/repeated-substring-pattern/",
        "solutionsUrl": "https://leetcode.cn/problems/repeated-substring-pattern/solution",
        "problemsDesc": "<p>给定一个非空的字符串<meta charset=\"UTF-8\" />&nbsp;<code>s</code>&nbsp;，检查是否可以通过由它的一个子串重复多次构成。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"abab\"\n<strong>输出:</strong> true\n<strong>解释:</strong> 可由子串 \"ab\" 重复两次构成。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"aba\"\n<strong>输出:</strong> false\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"abcabcabcabc\"\n<strong>输出:</strong> true\n<strong>解释:</strong> 可由子串 \"abc\" 重复四次构成。 (或子串 \"abcabc\" 重复两次构成。)\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code>&nbsp;由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 460.LFU 缓存",
        "hardRate": "HARD",
        "passRate": "44.83%",
        "problemsUrl": "https://leetcode.cn/problems/lfu-cache/",
        "solutionsUrl": "https://leetcode.cn/problems/lfu-cache/solution",
        "problemsDesc": "<p>请你为 <a href=\"https://baike.baidu.com/item/%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95\">最不经常使用（LFU）</a>缓存算法设计并实现数据结构。</p>\n\n<p>实现 <code>LFUCache</code> 类：</p>\n\n<ul>\n\t<li><code>LFUCache(int capacity)</code> - 用数据结构的容量&nbsp;<code>capacity</code> 初始化对象</li>\n\t<li><code>int get(int key)</code>&nbsp;- 如果键&nbsp;<code>key</code> 存在于缓存中，则获取键的值，否则返回 <code>-1</code> 。</li>\n\t<li><code>void put(int key, int value)</code>&nbsp;- 如果键&nbsp;<code>key</code> 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量&nbsp;<code>capacity</code> 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最近最久未使用</strong> 的键。</li>\n</ul>\n\n<p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 <strong>使用计数器</strong> 。使用计数最小的键是最久未使用的键。</p>\n\n<p>当一个键首次插入到缓存中时，它的使用计数器被设置为 <code>1</code> (由于 put 操作)。对缓存中的键执行 <code>get</code> 或 <code>put</code> 操作，使用计数器的值将会递增。</p>\n\n<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]\n<strong>输出：</strong>\n[null, null, null, 1, null, -1, 3, null, -1, 3, 4]\n\n<strong>解释：</strong>\n// cnt(x) = 键 x 的使用计数\n// cache=[] 将显示最后一次使用的顺序（最左边的元素是最近的）\nLFUCache lfu = new LFUCache(2);\nlfu.put(1, 1);   // cache=[1,_], cnt(1)=1\nlfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1\nlfu.get(1);      // 返回 1\n                 // cache=[1,2], cnt(2)=1, cnt(1)=2\nlfu.put(3, 3);   // 去除键 2 ，因为 cnt(2)=1 ，使用计数最小\n                 // cache=[3,1], cnt(3)=1, cnt(1)=2\nlfu.get(2);      // 返回 -1（未找到）\nlfu.get(3);      // 返回 3\n                 // cache=[3,1], cnt(3)=2, cnt(1)=2\nlfu.put(4, 4);   // 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用\n                 // cache=[4,3], cnt(4)=1, cnt(3)=2\nlfu.get(1);      // 返回 -1（未找到）\nlfu.get(3);      // 返回 3\n                 // cache=[3,4], cnt(4)=1, cnt(3)=3\nlfu.get(4);      // 返回 4\n                 // cache=[3,4], cnt(4)=2, cnt(3)=3</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= capacity&nbsp;&lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= key &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= value &lt;= 10<sup>9</sup></code></li>\n\t<li>最多调用 <code>2 * 10<sup>5</sup></code> 次 <code>get</code> 和 <code>put</code> 方法</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 461.汉明距离",
        "hardRate": "EASY",
        "passRate": "81.87%",
        "problemsUrl": "https://leetcode.cn/problems/hamming-distance/",
        "solutionsUrl": "https://leetcode.cn/problems/hamming-distance/solution",
        "problemsDesc": "<p>两个整数之间的 <a href=\"https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB\">汉明距离</a> 指的是这两个数字对应二进制位不同的位置的数目。</p>\n\n<p>给你两个整数 <code>x</code> 和 <code>y</code>，计算并返回它们之间的汉明距离。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 1, y = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>\n1   (0 0 0 1)\n4   (0 1 0 0)\n       ↑   ↑\n上面的箭头指出了对应二进制位不同的位置。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 3, y = 1\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= x, y <= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 462.最小操作次数使数组元素相等 II",
        "hardRate": "MEDIUM",
        "passRate": "62.35%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，返回使所有数组元素相等需要的最小操作数。</p>\n\n<p>在一次操作中，你可以使数组中的一个元素加 <code>1</code> 或者减 <code>1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n只需要两次操作（每次操作指南使一个元素加 1 或减 1）：\n[<strong><em>1</em></strong>,2,3]  =&gt;  [2,2,<strong><em>3</em></strong>]  =&gt;  [2,2,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,10,2,9]\n<strong>输出：</strong>16\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 463.岛屿的周长",
        "hardRate": "EASY",
        "passRate": "69.98%",
        "problemsUrl": "https://leetcode.cn/problems/island-perimeter/",
        "solutionsUrl": "https://leetcode.cn/problems/island-perimeter/solution",
        "problemsDesc": "<p>给定一个 <code>row x col</code> 的二维网格地图 <code>grid</code> ，其中：<code>grid[i][j] = 1</code> 表示陆地， <code>grid[i][j] = 0</code> 表示水域。</p>\n\n<p>网格中的格子 <strong>水平和垂直</strong> 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p>\n\n<p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/island.png\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\n<strong>输出：</strong>16\n<strong>解释：</strong>它的周长是上面图片中的 16 个黄色的边</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1]]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,0]]\n<strong>输出：</strong>4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>row == grid.length</code></li>\n\t<li><code>col == grid[i].length</code></li>\n\t<li><code>1 <= row, col <= 100</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 464.我能赢吗",
        "hardRate": "MEDIUM",
        "passRate": "41.14%",
        "problemsUrl": "https://leetcode.cn/problems/can-i-win/",
        "solutionsUrl": "https://leetcode.cn/problems/can-i-win/solution",
        "problemsDesc": "<p>在 \"100 game\" 这个游戏中，两名玩家轮流选择从 <code>1</code> 到 <code>10</code> 的任意整数，累计整数和，先使得累计整数和 <strong>达到或超过</strong>&nbsp; 100 的玩家，即为胜者。</p>\n\n<p>如果我们将游戏规则改为 “玩家 <strong>不能</strong> 重复使用整数” 呢？</p>\n\n<p>例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &gt;= 100。</p>\n\n<p>给定两个整数&nbsp;<code>maxChoosableInteger</code>&nbsp;（整数池中可选择的最大数）和&nbsp;<code>desiredTotal</code>（累计和），若先出手的玩家能稳赢则返回 <code>true</code>&nbsp;，否则返回 <code>false</code> 。假设两位玩家游戏时都表现 <strong>最佳</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>maxChoosableInteger = 10, desiredTotal = 11\n<strong>输出：</strong>false\n<strong>解释：\n</strong>无论第一个玩家选择哪个整数，他都会失败。\n第一个玩家可以选择从 1 到 10 的整数。\n如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。\n第二个玩家可以通过选择整数 10（那么累积和为 11 &gt;= desiredTotal），从而取得胜利.\n同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<b>输入：</b>maxChoosableInteger = 10, desiredTotal = 0\n<b>输出：</b>true\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入：</strong>maxChoosableInteger = 10, desiredTotal = 1\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= maxChoosableInteger &lt;= 20</code></li>\n\t<li><code>0 &lt;= desiredTotal &lt;= 300</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 465.最优账单平衡",
        "hardRate": "HARD",
        "passRate": "54.49%",
        "problemsUrl": "https://leetcode.cn/problems/optimal-account-balancing/",
        "solutionsUrl": "https://leetcode.cn/problems/optimal-account-balancing/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 466.统计重复个数",
        "hardRate": "HARD",
        "passRate": "37.59%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-repetitions/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-repetitions/solution",
        "problemsDesc": "<p>定义 <code>str = [s, n]</code> 表示 <code>str</code> 由 <code>n</code> 个字符串 <code>s</code> 连接构成。</p>\n\n<ul>\n\t<li>例如，<code>str == [\"abc\", 3] ==\"abcabcabc\"</code> 。</li>\n</ul>\n\n<p>如果可以从 <code>s2</code><sub> </sub>中删除某些字符使其变为 <code>s1</code>，则称字符串 <code>s1</code><sub> </sub>可以从字符串 <code>s2</code> 获得。</p>\n\n<ul>\n\t<li>例如，根据定义，<code>s1 = \"abc\"</code> 可以从 <code>s2 = \"ab<em><strong>dbe</strong></em>c\"</code> 获得，仅需要删除加粗且用斜体标识的字符。</li>\n</ul>\n\n<p>现在给你两个字符串 <code>s1</code> 和 <code>s2</code> 和两个整数 <code>n1</code> 和 <code>n2</code> 。由此构造得到两个字符串，其中 <code>str1 = [s1, n1]</code>、<code>str2 = [s2, n2]</code> 。</p>\n\n<p>请你找出一个最大整数 <code>m</code> ，以满足 <code>str = [str2, m]</code> 可以从 <code>str1</code> 获得。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s1.length, s2.length <= 100</code></li>\n\t<li><code>s1</code> 和 <code>s2</code> 由小写英文字母组成</li>\n\t<li><code>1 <= n1, n2 <= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 467.环绕字符串中唯一的子字符串",
        "hardRate": "MEDIUM",
        "passRate": "51.67%",
        "problemsUrl": "https://leetcode.cn/problems/unique-substrings-in-wraparound-string/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-substrings-in-wraparound-string/solution",
        "problemsDesc": "<p>定义字符串&nbsp;<code>base</code>&nbsp;为一个&nbsp;<code>\"abcdefghijklmnopqrstuvwxyz\"</code>&nbsp;无限环绕的字符串，所以&nbsp;<code>base</code>&nbsp;看起来是这样的：</p>\n\n<ul>\n\t<li><code>\"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\"</code>.</li>\n</ul>\n\n<p>给你一个字符串&nbsp;<code>s</code> ，请你统计并返回&nbsp;<code>s</code>&nbsp;中有多少&nbsp;<strong>不同</strong><strong>非空子串</strong>&nbsp;也在&nbsp;<code>base</code>&nbsp;中出现。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a\"\n<strong>输出：</strong>1\n<strong>解释：</strong>字符串 s 的子字符串 \"a\" 在 base 中出现。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"cac\"\n<strong>输出：</strong>2\n<strong>解释：</strong>字符串 s 有两个子字符串 (\"a\", \"c\") 在 base 中出现。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"zab\"\n<strong>输出：</strong>6\n<strong>解释：</strong>字符串 s 有六个子字符串 (\"z\", \"a\", \"b\", \"za\", \"ab\", and \"zab\") 在 base 中出现。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size: 12.6px; background-color: rgb(249, 242, 244);\">s</span></font> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 468.验证IP地址",
        "hardRate": "MEDIUM",
        "passRate": "28.14%",
        "problemsUrl": "https://leetcode.cn/problems/validate-ip-address/",
        "solutionsUrl": "https://leetcode.cn/problems/validate-ip-address/solution",
        "problemsDesc": "<p>给定一个字符串&nbsp;<code>queryIP</code>。如果是有效的 IPv4 地址，返回 <code>\"IPv4\"</code> ；如果是有效的 IPv6 地址，返回 <code>\"IPv6\"</code> ；如果不是上述类型的 IP 地址，返回 <code>\"Neither\"</code> 。</p>\n\n<p><strong>有效的IPv4地址</strong> 是 <code>“x1.x2.x3.x4”</code> 形式的IP地址。 其中&nbsp;<code>0 &lt;= x<sub>i</sub>&nbsp;&lt;= 255</code>&nbsp;且&nbsp;<code>x<sub>i</sub></code>&nbsp;<strong>不能包含</strong> 前导零。例如:&nbsp;<code>“192.168.1.1”</code>&nbsp;、 <code>“192.168.1.0”</code> 为有效IPv4地址， <code>“192.168.01.1”</code> 为无效IPv4地址; <code>“192.168.1.00”</code> 、 <code>“192.168@1.1”</code> 为无效IPv4地址。</p>\n\n<p><strong>一个有效的IPv6地址&nbsp;</strong>是一个格式为<code>“x1:x2:x3:x4:x5:x6:x7:x8”</code> 的IP地址，其中:</p>\n\n<ul>\n\t<li><code>1 &lt;= x<sub>i</sub>.length &lt;= 4</code></li>\n\t<li><code>x<sub>i</sub></code>&nbsp;是一个 <strong>十六进制字符串</strong> ，可以包含数字、小写英文字母( <code>'a'</code> 到 <code>'f'</code> )和大写英文字母( <code>'A'</code> 到 <code>'F'</code> )。</li>\n\t<li>在&nbsp;<code>x<sub>i</sub></code>&nbsp;中允许前导零。</li>\n</ul>\n\n<p>例如 <code>\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\"</code> 和 <code>\"2001:db8:85a3:0:0:8A2E:0370:7334\"</code> 是有效的 IPv6 地址，而 <code>\"2001:0db8:85a3::8A2E:037j:7334\"</code> 和 <code>\"02001:0db8:85a3:0000:0000:8a2e:0370:7334\"</code> 是无效的 IPv6 地址。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>queryIP = \"172.16.254.1\"\n<strong>输出：</strong>\"IPv4\"\n<strong>解释：</strong>有效的 IPv4 地址，返回 \"IPv4\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>queryIP = \"2001:0db8:85a3:0:0:8A2E:0370:7334\"\n<strong>输出：</strong>\"IPv6\"\n<strong>解释：</strong>有效的 IPv6 地址，返回 \"IPv6\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>queryIP = \"256.256.256.256\"\n<strong>输出：</strong>\"Neither\"\n<strong>解释：</strong>既不是 IPv4 地址，又不是 IPv6 地址\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>queryIP</code> 仅由英文字母，数字，字符 <code>'.'</code> 和 <code>':'</code> 组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 469.凸多边形",
        "hardRate": "MEDIUM",
        "passRate": "42.98%",
        "problemsUrl": "https://leetcode.cn/problems/convex-polygon/",
        "solutionsUrl": "https://leetcode.cn/problems/convex-polygon/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 470.用 Rand7() 实现 Rand10()",
        "hardRate": "MEDIUM",
        "passRate": "55.20%",
        "problemsUrl": "https://leetcode.cn/problems/implement-rand10-using-rand7/",
        "solutionsUrl": "https://leetcode.cn/problems/implement-rand10-using-rand7/solution",
        "problemsDesc": "<p>给定方法&nbsp;<code>rand7</code>&nbsp;可生成 <code>[1,7]</code> 范围内的均匀随机整数，试写一个方法&nbsp;<code>rand10</code>&nbsp;生成 <code>[1,10]</code> 范围内的均匀随机整数。</p>\n\n<p>你只能调用&nbsp;<code>rand7()</code>&nbsp;且不能调用其他方法。请不要使用系统的&nbsp;<code>Math.random()</code>&nbsp;方法。</p>\n\n<ol>\n</ol>\n\n<p>每个测试用例将有一个内部参数 <code>n</code>，即你实现的函数 <code>rand10()</code> 在测试时将被调用的次数。请注意，这不是传递给 <code>rand10()</code> 的参数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>1\n<strong>输出: </strong>[2]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>2\n<strong>输出: </strong>[2,8]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入: </strong>3\n<strong>输出: </strong>[3,8,10]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶:</strong></p>\n\n<ul>\n\t<li><code>rand7()</code>调用次数的&nbsp;<a href=\"https://en.wikipedia.org/wiki/Expected_value\" target=\"_blank\">期望值</a>&nbsp;是多少&nbsp;?</li>\n\t<li>你能否尽量少调用 <code>rand7()</code> ?</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 471.编码最短长度的字符串",
        "hardRate": "HARD",
        "passRate": "59.59%",
        "problemsUrl": "https://leetcode.cn/problems/encode-string-with-shortest-length/",
        "solutionsUrl": "https://leetcode.cn/problems/encode-string-with-shortest-length/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 472.连接词",
        "hardRate": "HARD",
        "passRate": "52.06%",
        "problemsUrl": "https://leetcode.cn/problems/concatenated-words/",
        "solutionsUrl": "https://leetcode.cn/problems/concatenated-words/solution",
        "problemsDesc": "<p>给你一个 <strong>不含重复 </strong>单词的字符串数组 <code>words</code> ，请你找出并返回 <code>words</code> 中的所有 <strong>连接词</strong> 。</p>\n\n<p><strong>连接词</strong> 定义为：一个完全由给定数组中的至少两个较短单词（不一定是不同的两个单词）组成的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\n<strong>输出：</strong>[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]\n<strong>解释：</strong>\"catsdogcats\" 由 \"cats\", \"dog\" 和 \"cats\" 组成; \n     \"dogcatsdog\" 由 \"dog\", \"cats\" 和 \"dog\" 组成; \n     \"ratcatdogcat\" 由 \"rat\", \"cat\", \"dog\" 和 \"cat\" 组成。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"cat\",\"dog\",\"catdog\"]\n<strong>输出：</strong>[\"catdog\"]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li><code>words[i]</code>&nbsp;仅由小写英文字母组成。</li>\n\t<li>&nbsp;<code>words</code>&nbsp;中的所有字符串都是 <strong>唯一</strong> 的。</li>\n\t<li><code>1 &lt;= sum(words[i].length) &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 473.火柴拼正方形",
        "hardRate": "MEDIUM",
        "passRate": "46.67%",
        "problemsUrl": "https://leetcode.cn/problems/matchsticks-to-square/",
        "solutionsUrl": "https://leetcode.cn/problems/matchsticks-to-square/solution",
        "problemsDesc": "<p>你将得到一个整数数组 <code>matchsticks</code> ，其中 <code>matchsticks[i]</code> 是第 <code>i</code>&nbsp;个火柴棒的长度。你要用 <strong>所有的火柴棍</strong>&nbsp;拼成一个正方形。你 <strong>不能折断</strong> 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 <strong>使用一次</strong> 。</p>\n\n<p>如果你能使这个正方形，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/09/matchsticks1-grid.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> matchsticks = [1,1,2,2,2]\n<strong>输出:</strong> true\n<strong>解释:</strong> 能拼成一个边长为2的正方形，每边两根火柴。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> matchsticks = [3,3,3,3,4]\n<strong>输出:</strong> false\n<strong>解释:</strong> 不能用所有火柴拼成一个正方形。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= matchsticks.length &lt;= 15</code></li>\n\t<li><code>1 &lt;= matchsticks[i] &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 474.一和零",
        "hardRate": "MEDIUM",
        "passRate": "65.22%",
        "problemsUrl": "https://leetcode.cn/problems/ones-and-zeroes/",
        "solutionsUrl": "https://leetcode.cn/problems/ones-and-zeroes/solution",
        "problemsDesc": "<p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p>\n\n<div class=\"MachineTrans-Lines\">\n<p class=\"MachineTrans-lang-zh-CN\">请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p>\n\n<p class=\"MachineTrans-lang-zh-CN\">如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"10\", \"0001\", \"111001\", \"1\", \"0\"], m = 5, n = 3\n<strong>输出：</strong>4\n<strong>解释：</strong>最多有 5 个 0 和 3 个 1 的最大子集是 {\"10\",\"0001\",\"1\",\"0\"} ，因此答案是 4 。\n其他满足题意但较小的子集包括 {\"0001\",\"1\"} 和 {\"10\",\"1\",\"0\"} 。{\"111001\"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"10\", \"0\", \"1\"], m = 1, n = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>最大的子集是 {\"0\", \"1\"} ，所以答案是 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 600</code></li>\n\t<li><code>1 &lt;= strs[i].length &lt;= 100</code></li>\n\t<li><code>strs[i]</code>&nbsp;仅由&nbsp;<code>'0'</code> 和&nbsp;<code>'1'</code> 组成</li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 475.供暖器",
        "hardRate": "MEDIUM",
        "passRate": "41.03%",
        "problemsUrl": "https://leetcode.cn/problems/heaters/",
        "solutionsUrl": "https://leetcode.cn/problems/heaters/solution",
        "problemsDesc": "<p>冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。</p>\n\n<p>在加热器的加热半径范围内的每个房屋都可以获得供暖。</p>\n\n<p>现在，给出位于一条水平线上的房屋 <code>houses</code> 和供暖器 <code>heaters</code> 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。</p>\n\n<p><strong>说明</strong>：所有供暖器都遵循你的半径标准，加热的半径也一样。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> houses = [1,2,3], heaters = [2]\n<strong>输出:</strong> 1\n<strong>解释:</strong> 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> houses = [1,2,3,4], heaters = [1,4]\n<strong>输出:</strong> 1\n<strong>解释:</strong> 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>houses = [1,5], heaters = [2]\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= houses.length, heaters.length <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= houses[i], heaters[i] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 476.数字的补数",
        "hardRate": "EASY",
        "passRate": "69.64%",
        "problemsUrl": "https://leetcode.cn/problems/number-complement/",
        "solutionsUrl": "https://leetcode.cn/problems/number-complement/solution",
        "problemsDesc": "<p>对整数的二进制表示取反（<code>0</code> 变 <code>1</code> ，<code>1</code> 变 <code>0</code>）后，再转换为十进制表示，可以得到这个整数的补数。</p>\n\n<ul>\n\t<li>例如，整数 <code>5</code> 的二进制表示是 <code>\"101\"</code> ，取反后得到 <code>\"010\"</code> ，再转回十进制表示得到补数 <code>2</code> 。</li>\n</ul>\n\n<p>给你一个整数 <code>num</code> ，输出它的补数。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt; 2<sup>31</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与 1009 <a href=\"https://leetcode-cn.com/problems/complement-of-base-10-integer/\">https://leetcode-cn.com/problems/complement-of-base-10-integer/</a> 相同</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 477.汉明距离总和",
        "hardRate": "MEDIUM",
        "passRate": "60.62%",
        "problemsUrl": "https://leetcode.cn/problems/total-hamming-distance/",
        "solutionsUrl": "https://leetcode.cn/problems/total-hamming-distance/solution",
        "problemsDesc": "<p>两个整数的&nbsp;<a href=\"https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/475174?fr=aladdin\">汉明距离</a> 指的是这两个数字的二进制数对应位不同的数量。</p>\n\n<p>给你一个整数数组 <code>nums</code>，请你计算并返回 <code>nums</code> 中任意两个数之间 <strong>汉明距离的总和</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,14,2]\n<strong>输出：</strong>6\n<strong>解释：</strong>在二进制表示中，4 表示为 0100 ，14 表示为 1110 ，2表示为 0010 。（这样表示是为了体现后四位之间关系）\n所以答案为：\nHammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,14,4]\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>给定输入的对应答案符合 <strong>32-bit</strong> 整数范围</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 478.在圆内随机生成点",
        "hardRate": "MEDIUM",
        "passRate": "48.26%",
        "problemsUrl": "https://leetcode.cn/problems/generate-random-point-in-a-circle/",
        "solutionsUrl": "https://leetcode.cn/problems/generate-random-point-in-a-circle/solution",
        "problemsDesc": "<p>给定圆的半径和圆心的位置，实现函数 <code>randPoint</code> ，在圆中产生均匀随机点。</p>\n\n<p>实现&nbsp;<code>Solution</code>&nbsp;类:</p>\n\n<ul>\n\t<li><code>Solution(double radius, double x_center, double y_center)</code>&nbsp;用圆的半径&nbsp;<code>radius</code>&nbsp;和圆心的位置<code> (x_center, y_center)</code> 初始化对象</li>\n\t<li><code>randPoint()</code>&nbsp;返回圆内的一个随机点。圆周上的一点被认为在圆内。答案作为数组返回 <code>[x, y]</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: \n</strong>[\"Solution\",\"randPoint\",\"randPoint\",\"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]\n<strong>输出: </strong>[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]\n<strong>解释:</strong>\nSolution solution = new Solution(1.0, 0.0, 0.0);\nsolution.randPoint ();//返回[-0.02493，-0.38077]\nsolution.randPoint ();//返回[0.82314,0.38945]\nsolution.randPoint ();//返回[0.36572,0.17248]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;&nbsp;radius &lt;= 10<sup>8</sup></code></li>\n\t<li><code>-10<sup>7</sup>&nbsp;&lt;= x_center, y_center &lt;= 10<sup>7</sup></code></li>\n\t<li><code>randPoint</code> 最多被调用&nbsp;<code>3 * 10<sup>4</sup></code>&nbsp;次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 479.最大回文数乘积",
        "hardRate": "HARD",
        "passRate": "62.51%",
        "problemsUrl": "https://leetcode.cn/problems/largest-palindrome-product/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-palindrome-product/solution",
        "problemsDesc": "<p>给定一个整数 n ，返回 <em>可表示为两个 <code>n</code>&nbsp;位整数乘积的 <strong>最大回文整数</strong></em> 。因为答案可能非常大，所以返回它对 <code>1337</code> <strong>取余</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<b>输入：</b>n = 2\n<b>输出：</b>987\n<strong>解释：</strong>99 x 91 = 9009, 9009 % 1337 = 987\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入：</strong> n = 1\n<strong>输出：</strong> 9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 480.滑动窗口中位数",
        "hardRate": "HARD",
        "passRate": "43.93%",
        "problemsUrl": "https://leetcode.cn/problems/sliding-window-median/",
        "solutionsUrl": "https://leetcode.cn/problems/sliding-window-median/solution",
        "problemsDesc": "<p>中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。</p>\n\n<p>例如：</p>\n\n<ul>\n\t<li><code>[2,3,4]</code>，中位数是 <code>3</code></li>\n\t<li><code>[2,3]</code>，中位数是 <code>(2 + 3) / 2 = 2.5</code></li>\n</ul>\n\n<p>给你一个数组 <em>nums</em>，有一个长度为 <em>k</em> 的窗口从最左端滑动到最右端。窗口中有 <em>k</em> 个数，每次窗口向右移动 <em>1</em> 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<p>给出 <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>，以及 <em>k</em> = 3。</p>\n\n<pre>\n窗口位置                      中位数\n---------------               -----\n[1  3  -1] -3  5  3  6  7       1\n 1 [3  -1  -3] 5  3  6  7      -1\n 1  3 [-1  -3  5] 3  6  7      -1\n 1  3  -1 [-3  5  3] 6  7       3\n 1  3  -1  -3 [5  3  6] 7       5\n 1  3  -1  -3  5 [3  6  7]      6\n</pre>\n\n<p> 因此，返回该滑动窗口的中位数数组 <code>[1,-1,-1,3,5,6]</code>。</p>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>你可以假设 <code>k</code> 始终有效，即：<code>k</code> 始终小于等于输入的非空数组的元素个数。</li>\n\t<li>与真实值误差在 <code>10 ^ -5</code> 以内的答案将被视作正确答案。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 481.神奇字符串",
        "hardRate": "MEDIUM",
        "passRate": "64.18%",
        "problemsUrl": "https://leetcode.cn/problems/magical-string/",
        "solutionsUrl": "https://leetcode.cn/problems/magical-string/solution",
        "problemsDesc": "<p>神奇字符串 <code>s</code> 仅由 <code>'1'</code> 和 <code>'2'</code> 组成，并需要遵守下面的规则：</p>\n\n<ul>\n\t<li>神奇字符串 s 的神奇之处在于，串联字符串中 <code>'1'</code> 和 <code>'2'</code> 的连续出现次数可以生成该字符串。</li>\n</ul>\n\n<p><code>s</code> 的前几个元素是 <code>s = \"1221121221221121122……\"</code> 。如果将 <code>s</code> 中连续的若干 <code>1</code> 和 <code>2</code> 进行分组，可以得到 <code>\"1 22 11 2 1 22 1 22 11 2 11 22 ......\"</code> 。每组中 <code>1</code> 或者 <code>2</code> 的出现次数分别是 <code>\"1 2 2 1 1 2 1 2 2 1 2 2 ......\"</code> 。上面的出现次数正是 <code>s</code> 自身。</p>\n\n<p>给你一个整数 <code>n</code> ，返回在神奇字符串 <code>s</code> 的前 <code>n</code> 个数字中 <code>1</code> 的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6\n<strong>输出：</strong>3\n<strong>解释：</strong>神奇字符串 s 的前 6 个元素是 “<code>122112</code>”，它包含三个 1，因此返回 3 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 482.密钥格式化",
        "hardRate": "EASY",
        "passRate": "46.73%",
        "problemsUrl": "https://leetcode.cn/problems/license-key-formatting/",
        "solutionsUrl": "https://leetcode.cn/problems/license-key-formatting/solution",
        "problemsDesc": "<p>给定一个许可密钥字符串 <code>s</code>，仅由字母、数字字符和破折号组成。字符串由 <code>n</code> 个破折号分成 <code>n + 1</code> 组。你也会得到一个整数 <code>k</code> 。</p>\n\n<p>我们想要重新格式化字符串&nbsp;<code>s</code>，使每一组包含 <code>k</code> 个字符，除了第一组，它可以比 <code>k</code> 短，但仍然必须包含至少一个字符。此外，两组之间必须插入破折号，并且应该将所有小写字母转换为大写字母。</p>\n\n<p>返回 <em>重新格式化的许可密钥</em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>S = \"5F3Z-2e-9-w\", k = 4\n<strong>输出：</strong>\"5F3Z-2E9W\"\n<strong>解释：</strong>字符串 S 被分成了两个部分，每部分 4 个字符；\n&nbsp;    注意，两个额外的破折号需要删掉。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>S = \"2-5g-3-J\", k = 2\n<strong>输出：</strong>\"2-5G-3J\"\n<strong>解释：</strong>字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含字母、数字和破折号&nbsp;<code>'-'</code>.</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 483.最小好进制",
        "hardRate": "HARD",
        "passRate": "59.12%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-good-base/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-good-base/solution",
        "problemsDesc": "<p>以字符串的形式给出 <code>n</code>&nbsp;, 以字符串的形式返回<em> <code>n</code> 的最小 <strong>好进制</strong> </em>&nbsp;。</p>\n\n<p>如果 <code>n</code> 的 &nbsp;<code>k(k&gt;=2)</code>&nbsp;进制数的所有数位全为1，则称&nbsp;<code>k(k&gt;=2)</code>&nbsp;是 <code>n</code> 的一个&nbsp;<strong>好进制&nbsp;</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = \"13\"\n<strong>输出：</strong>\"3\"\n<strong>解释：</strong>13 的 3 进制是 111。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = \"4681\"\n<strong>输出：</strong>\"8\"\n<strong>解释：</strong>4681 的 8 进制是 11111。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = \"1000000000000000000\"\n<strong>输出：</strong>\"999999999999999999\"\n<strong>解释：</strong>1000000000000000000 的 999999999999999999 进制是 11。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n</code> 的取值范围是&nbsp;<code>[3, 10<sup>18</sup>]</code></li>\n\t<li><code>n</code> 没有前导 0</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 484.寻找排列",
        "hardRate": "MEDIUM",
        "passRate": "59.68%",
        "problemsUrl": "https://leetcode.cn/problems/find-permutation/",
        "solutionsUrl": "https://leetcode.cn/problems/find-permutation/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 485.最大连续 1 的个数",
        "hardRate": "EASY",
        "passRate": "61.13%",
        "problemsUrl": "https://leetcode.cn/problems/max-consecutive-ones/",
        "solutionsUrl": "https://leetcode.cn/problems/max-consecutive-ones/solution",
        "problemsDesc": "<p>给定一个二进制数组 <code>nums</code> ， 计算其中最大连续 <code>1</code> 的个数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,0,1,1,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3.\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,0,1,1,0,1]\n<b>输出：</b>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code>&nbsp;不是&nbsp;<code>0</code>&nbsp;就是&nbsp;<code>1</code>.</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 486.预测赢家",
        "hardRate": "MEDIUM",
        "passRate": "59.48%",
        "problemsUrl": "https://leetcode.cn/problems/predict-the-winner/",
        "solutionsUrl": "https://leetcode.cn/problems/predict-the-winner/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。</p>\n\n<p>玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 <code>0</code> 。每一回合，玩家从数组的任意一端取一个数字（即，<code>nums[0]</code> 或 <code>nums[nums.length - 1]</code>），取到的数字将会从数组中移除（数组长度减 <code>1</code> ）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。</p>\n\n<p>如果玩家 1 能成为赢家，返回 <code>true</code> 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 <code>true</code> 。你可以假设每个玩家的玩法都会使他的分数最大化。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5,2]\n<strong>输出：</strong>false\n<strong>解释：</strong>一开始，玩家 1 可以从 1 和 2 中进行选择。\n如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。 \n所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。\n因此，玩家 1 永远不会成为赢家，返回 false 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5,233,7]\n<strong>输出：</strong>true\n<strong>解释：</strong>玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。\n最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 true，表示玩家 1 可以成为赢家。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 20</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 487.最大连续1的个数 II",
        "hardRate": "MEDIUM",
        "passRate": "57.53%",
        "problemsUrl": "https://leetcode.cn/problems/max-consecutive-ones-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/max-consecutive-ones-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 488.祖玛游戏",
        "hardRate": "HARD",
        "passRate": "48.55%",
        "problemsUrl": "https://leetcode.cn/problems/zuma-game/",
        "solutionsUrl": "https://leetcode.cn/problems/zuma-game/solution",
        "problemsDesc": "<p>你正在参与祖玛游戏的一个变种。</p>\n\n<p>在这个祖玛游戏变体中，桌面上有 <strong>一排</strong> 彩球，每个球的颜色可能是：红色 <code>'R'</code>、黄色 <code>'Y'</code>、蓝色 <code>'B'</code>、绿色 <code>'G'</code> 或白色 <code>'W'</code> 。你的手中也有一些彩球。</p>\n\n<p>你的目标是 <strong>清空</strong> 桌面上所有的球。每一回合：</p>\n\n<ul>\n\t<li>从你手上的彩球中选出 <strong>任意一颗</strong> ，然后将其插入桌面上那一排球中：两球之间或这一排球的任一端。</li>\n\t<li>接着，如果有出现 <strong>三个或者三个以上</strong> 且 <strong>颜色相同</strong> 的球相连的话，就把它们移除掉。\n\t<ul>\n\t\t<li>如果这种移除操作同样导致出现三个或者三个以上且颜色相同的球相连，则可以继续移除这些球，直到不再满足移除条件。</li>\n\t</ul>\n\t</li>\n\t<li>如果桌面上所有球都被移除，则认为你赢得本场游戏。</li>\n\t<li>重复这个过程，直到你赢了游戏或者手中没有更多的球。</li>\n</ul>\n\n<p>给你一个字符串 <code>board</code> ，表示桌面上最开始的那排球。另给你一个字符串 <code>hand</code> ，表示手里的彩球。请你按上述操作步骤移除掉桌上所有球，计算并返回所需的 <strong>最少</strong> 球数。如果不能移除桌上所有的球，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = \"WRRBBW\", hand = \"RB\"\n<strong>输出：</strong>-1\n<strong>解释：</strong>无法移除桌面上的所有球。可以得到的最好局面是：\n- 插入一个 'R' ，使桌面变为 WRR<em><strong>R</strong></em>BBW 。W<em><strong>RRR</strong></em>BBW -&gt; WBBW\n- 插入一个 'B' ，使桌面变为 WBB<em><strong>B</strong></em>W 。W<em><strong>BBB</strong></em>W -&gt; WW\n桌面上还剩着球，没有其他球可以插入。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = \"WWRRBBWW\", hand = \"WRBRW\"\n<strong>输出：</strong>2\n<strong>解释：</strong>要想清空桌面上的球，可以按下述步骤：\n- 插入一个 'R' ，使桌面变为 WWRR<strong><em>R</em></strong>BBWW 。WW<em><strong>RRR</strong></em>BBWW -&gt; WWBBWW\n- 插入一个 'B' ，使桌面变为 WWBB<em><strong>B</strong></em>WW 。WW<em><strong>BBB</strong></em>WW -&gt; <em><strong>WWWW</strong></em> -&gt; empty\n只需从手中出 2 个球就可以清空桌面。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = \"G\", hand = \"GGGGG\"\n<strong>输出：</strong>2\n<strong>解释：</strong>要想清空桌面上的球，可以按下述步骤：\n- 插入一个 'G' ，使桌面变为 G<em><strong>G</strong></em> 。\n- 插入一个 'G' ，使桌面变为 GG<em><strong>G</strong></em> 。<em><strong>GGG</strong></em> -&gt; empty\n只需从手中出 2 个球就可以清空桌面。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = \"RBYYBBRRB\", hand = \"YRBGB\"\n<strong>输出：</strong>3\n<strong>解释：</strong>要想清空桌面上的球，可以按下述步骤：\n- 插入一个 'Y' ，使桌面变为 RBYY<em><strong>Y</strong></em>BBRRB 。RB<em><strong>YYY</strong></em>BBRRB -&gt; R<em><strong>BBB</strong></em>RRB -&gt; <em><strong>RRR</strong></em>B -&gt; B\n- 插入一个 'B' ，使桌面变为 B<em><strong>B</strong></em> 。\n- 插入一个 'B' ，使桌面变为 BB<em><strong>B</strong></em> 。<em><strong>BBB</strong></em> -&gt; empty\n只需从手中出 3 个球就可以清空桌面。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= board.length &lt;= 16</code></li>\n\t<li><code>1 &lt;= hand.length &lt;= 5</code></li>\n\t<li><code>board</code> 和 <code>hand</code> 由字符 <code>'R'</code>、<code>'Y'</code>、<code>'B'</code>、<code>'G'</code> 和 <code>'W'</code> 组成</li>\n\t<li>桌面上一开始的球中，不会有三个及三个以上颜色相同且连着的球</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 489.扫地机器人",
        "hardRate": "HARD",
        "passRate": "74.82%",
        "problemsUrl": "https://leetcode.cn/problems/robot-room-cleaner/",
        "solutionsUrl": "https://leetcode.cn/problems/robot-room-cleaner/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 490.迷宫",
        "hardRate": "MEDIUM",
        "passRate": "50.28%",
        "problemsUrl": "https://leetcode.cn/problems/the-maze/",
        "solutionsUrl": "https://leetcode.cn/problems/the-maze/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 491.递增子序列",
        "hardRate": "MEDIUM",
        "passRate": "52.02%",
        "problemsUrl": "https://leetcode.cn/problems/non-decreasing-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/non-decreasing-subsequences/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，找出并返回所有该数组中不同的递增子序列，递增子序列中 <strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。</p>\n\n<p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,6,7,7]\n<strong>输出：</strong>[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,4,3,2,1]\n<strong>输出：</strong>[[4,4]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 15</code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 492.构造矩形",
        "hardRate": "EASY",
        "passRate": "61.23%",
        "problemsUrl": "https://leetcode.cn/problems/construct-the-rectangle/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-the-rectangle/solution",
        "problemsDesc": "<p>作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 所以，现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求：</p>\n\n<ol>\n\t<li>你设计的矩形页面必须等于给定的目标面积。</li>\n\t<li>宽度 <code>W</code>&nbsp;不应大于长度 <code>L</code> ，换言之，要求 <code>L &gt;= W </code>。</li>\n\t<li>长度 <code>L</code> 和宽度 <code>W</code>&nbsp;之间的差距应当尽可能小。</li>\n</ol>\n\n<p>返回一个&nbsp;<em>数组</em>&nbsp;<code>[L, W]</code>，其中 <em><code>L</code> 和 <code>W</code> 是你按照顺序设计的网页的长度和宽度</em>。<br />\n&nbsp;</p>\n\n<p><strong>示例1：</strong></p>\n\n<pre>\n<strong>输入:</strong> 4\n<strong>输出:</strong> [2, 2]\n<strong>解释:</strong> 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。\n但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求. 所以输出长度 L 为 2， 宽度 W 为 2。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> area = 37\n<strong>输出:</strong> [37,1]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> area = 122122\n<strong>输出:</strong> [427,286]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= area &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 493.翻转对",
        "hardRate": "HARD",
        "passRate": "36.53%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-pairs/solution",
        "problemsDesc": "<p>给定一个数组&nbsp;<code>nums</code>&nbsp;，如果&nbsp;<code>i &lt; j</code>&nbsp;且&nbsp;<code>nums[i] &gt; 2*nums[j]</code>&nbsp;我们就将&nbsp;<code>(i, j)</code>&nbsp;称作一个<strong><em>重要翻转对</em></strong>。</p>\n\n<p>你需要返回给定数组中的重要翻转对的数量。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入</strong>: [1,3,2,3,1]\n<strong>输出</strong>: 2\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入</strong>: [2,4,3,5,1]\n<strong>输出</strong>: 3\n</pre>\n\n<p><strong>注意:</strong></p>\n\n<ol>\n\t<li>给定数组的长度不会超过<code>50000</code>。</li>\n\t<li>输入数组中的所有数字都在32位整数的表示范围内。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 494.目标和",
        "hardRate": "MEDIUM",
        "passRate": "48.64%",
        "problemsUrl": "https://leetcode.cn/problems/target-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/target-sum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>\n\n<p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>\n\n<ul>\n\t<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code> ，然后串联起来得到表达式 <code>\"+2-1\"</code> 。</li>\n</ul>\n\n<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,1,1], target = 3\n<strong>输出：</strong>5\n<strong>解释：</strong>一共有 5 种方法让最终目标和为 3 。\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1], target = 1\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 20</code></li>\n\t<li><code>0 <= nums[i] <= 1000</code></li>\n\t<li><code>0 <= sum(nums[i]) <= 1000</code></li>\n\t<li><code>-1000 <= target <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 495.提莫攻击",
        "hardRate": "EASY",
        "passRate": "59.39%",
        "problemsUrl": "https://leetcode.cn/problems/teemo-attacking/",
        "solutionsUrl": "https://leetcode.cn/problems/teemo-attacking/solution",
        "problemsDesc": "<p>在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄。他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。</p>\n\n<p>当提莫攻击艾希，艾希的中毒状态正好持续&nbsp;<code>duration</code> 秒。</p>\n\n<p>正式地讲，提莫在 <code>t</code> 发起攻击意味着艾希在时间区间 <code>[t, t + duration - 1]</code>（含 <code>t</code> 和 <code>t + duration - 1</code>）处于中毒状态。如果提莫在中毒影响结束 <strong>前</strong> 再次攻击，中毒状态计时器将会 <strong>重置</strong> ，在新的攻击之后，中毒影响将会在 <code>duration</code> 秒后结束。</p>\n\n<p>给你一个 <strong>非递减</strong> 的整数数组 <code>timeSeries</code> ，其中 <code>timeSeries[i]</code> 表示提莫在 <code>timeSeries[i]</code> 秒时对艾希发起攻击，以及一个表示中毒持续时间的整数 <code>duration</code> 。</p>\n\n<p>返回艾希处于中毒状态的 <strong>总</strong> 秒数。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>timeSeries = [1,4], duration = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>提莫攻击对艾希的影响如下：\n- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。\n- 第 4 秒，提莫再次攻击艾希，艾希中毒状态又持续 2 秒，即第 4 秒和第 5 秒。\n艾希在第 1、2、4、5 秒处于中毒状态，所以总中毒秒数是 4 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>timeSeries = [1,2], duration = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>提莫攻击对艾希的影响如下：\n- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。\n- 第 2 秒，提莫再次攻击艾希，并重置中毒计时器，艾希中毒状态需要持续 2 秒，即第 2 秒和第 3 秒。\n艾希在第 1、2、3 秒处于中毒状态，所以总中毒秒数是 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= timeSeries.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= timeSeries[i], duration &lt;= 10<sup>7</sup></code></li>\n\t<li><code>timeSeries</code> 按 <strong>非递减</strong> 顺序排列</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 496.下一个更大元素 I",
        "hardRate": "EASY",
        "passRate": "71.77%",
        "problemsUrl": "https://leetcode.cn/problems/next-greater-element-i/",
        "solutionsUrl": "https://leetcode.cn/problems/next-greater-element-i/solution",
        "problemsDesc": "<p><code>nums1</code>&nbsp;中数字&nbsp;<code>x</code>&nbsp;的 <strong>下一个更大元素</strong> 是指&nbsp;<code>x</code>&nbsp;在&nbsp;<code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比&nbsp;<code>x</code><strong>&nbsp;</strong>大的元素。</p>\n\n<p>给你两个<strong> 没有重复元素</strong> 的数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code> ，下标从 <strong>0</strong> 开始计数，其中<code>nums1</code>&nbsp;是&nbsp;<code>nums2</code>&nbsp;的子集。</p>\n\n<p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p>\n\n<p>返回一个长度为&nbsp;<code>nums1.length</code> 的数组<em> </em><code>ans</code><em> </em>作为答案，满足<em> </em><code>ans[i]</code><em> </em>是如上所述的 <strong>下一个更大元素</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [4,1,2], nums2 = [1,3,4,2].\n<strong>输出：</strong>[-1,3,-1]\n<strong>解释：</strong>nums1 中每个值的下一个更大元素如下所述：\n- 4 ，用加粗斜体标识，nums2 = [1,3,<strong>4</strong>,2]。不存在下一个更大元素，所以答案是 -1 。\n- 1 ，用加粗斜体标识，nums2 = [<em><strong>1</strong></em>,3,4,2]。下一个更大元素是 3 。\n- 2 ，用加粗斜体标识，nums2 = [1,3,4,<em><strong>2</strong></em>]。不存在下一个更大元素，所以答案是 -1 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [2,4], nums2 = [1,2,3,4].\n<strong>输出：</strong>[3,-1]\n<strong>解释：</strong>nums1 中每个值的下一个更大元素如下所述：\n- 2 ，用加粗斜体标识，nums2 = [1,<em><strong>2</strong></em>,3,4]。下一个更大元素是 3 。\n- 4 ，用加粗斜体标识，nums2 = [1,2,3,<em><strong>4</strong></em>]。不存在下一个更大元素，所以答案是 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li>\n\t<li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(nums1.length + nums2.length)</code> 的解决方案吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 497.非重叠矩形中的随机点",
        "hardRate": "MEDIUM",
        "passRate": "41.83%",
        "problemsUrl": "https://leetcode.cn/problems/random-point-in-non-overlapping-rectangles/",
        "solutionsUrl": "https://leetcode.cn/problems/random-point-in-non-overlapping-rectangles/solution",
        "problemsDesc": "<p>给定一个由非重叠的轴对齐矩形的数组 <code>rects</code> ，其中 <code>rects[i] = [ai, bi, xi, yi]</code> 表示 <code>(ai, bi)</code> 是第 <code>i</code> 个矩形的左下角点，<code>(xi, yi)</code> 是第 <code>i</code> 个矩形的右上角点。设计一个算法来随机挑选一个被某一矩形覆盖的整数点。矩形周长上的点也算做是被矩形覆盖。所有满足要求的点必须等概率被返回。</p>\n\n<p>在给定的矩形覆盖的空间内的任何整数点都有可能被返回。</p>\n\n<p><strong>请注意&nbsp;</strong>，整数点是具有整数坐标的点。</p>\n\n<p>实现&nbsp;<code>Solution</code>&nbsp;类:</p>\n\n<ul>\n\t<li><code>Solution(int[][] rects)</code>&nbsp;用给定的矩形数组&nbsp;<code>rects</code> 初始化对象。</li>\n\t<li><code>int[] pick()</code>&nbsp;返回一个随机的整数点 <code>[u, v]</code> 在给定的矩形所覆盖的空间内。</li>\n</ul>\n\n<ol>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/24/lc-pickrandomrec.jpg\" style=\"height: 539px; width: 419px;\" /></p>\n\n<pre>\n<strong>输入: \n</strong>[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[[[-2, -2, 1, 1], [2, 2, 4, 6]]], [], [], [], [], []]\n<strong>输出: \n</strong>[null, [1, -2], [1, -1], [-1, -2], [-2, -2], [0, 0]]\n\n<strong>解释：</strong>\nSolution solution = new Solution([[-2, -2, 1, 1], [2, 2, 4, 6]]);\nsolution.pick(); // 返回 [1, -2]\nsolution.pick(); // 返回 [1, -1]\nsolution.pick(); // 返回 [-1, -2]\nsolution.pick(); // 返回 [-2, -2]\nsolution.pick(); // 返回 [0, 0]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rects.length &lt;= 100</code></li>\n\t<li><code>rects[i].length == 4</code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= a<sub>i</sub>&nbsp;&lt; x<sub>i</sub>&nbsp;&lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= b<sub>i</sub>&nbsp;&lt; y<sub>i</sub>&nbsp;&lt;= 10<sup>9</sup></code></li>\n\t<li><code>x<sub>i</sub>&nbsp;- a<sub>i</sub>&nbsp;&lt;= 2000</code></li>\n\t<li><code>y<sub>i</sub>&nbsp;- b<sub>i</sub>&nbsp;&lt;= 2000</code></li>\n\t<li>所有的矩形不重叠。</li>\n\t<li><code>pick</code> 最多被调用&nbsp;<code>10<sup>4</sup></code>&nbsp;次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 498.对角线遍历",
        "hardRate": "MEDIUM",
        "passRate": "55.87%",
        "problemsUrl": "https://leetcode.cn/problems/diagonal-traverse/",
        "solutionsUrl": "https://leetcode.cn/problems/diagonal-traverse/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的矩阵 <code>mat</code> ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg\" style=\"width: 334px; height: 334px;\" />\n<pre>\n<strong>输入：</strong>mat = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>[1,2,4,7,5,3,6,8,9]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1,2],[3,4]]\n<strong>输出：</strong>[1,2,3,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= mat[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 499.迷宫 III",
        "hardRate": "HARD",
        "passRate": "43.18%",
        "problemsUrl": "https://leetcode.cn/problems/the-maze-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/the-maze-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 500.键盘行",
        "hardRate": "EASY",
        "passRate": "74.04%",
        "problemsUrl": "https://leetcode.cn/problems/keyboard-row/",
        "solutionsUrl": "https://leetcode.cn/problems/keyboard-row/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>words</code> ，只返回可以使用在 <strong>美式键盘</strong> 同一行的字母打印出来的单词。键盘如下图所示。</p>\n\n<p><strong>美式键盘</strong> 中：</p>\n\n<ul>\n\t<li>第一行由字符 <code>\"qwertyuiop\"</code> 组成。</li>\n\t<li>第二行由字符 <code>\"asdfghjkl\"</code> 组成。</li>\n\t<li>第三行由字符 <code>\"zxcvbnm\"</code> 组成。</li>\n</ul>\n\n<p><img alt=\"American keyboard\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/keyboard.png\" style=\"width: 100%; max-width: 600px\" /></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"Hello\",\"Alaska\",\"Dad\",\"Peace\"]\n<strong>输出：</strong>[\"Alaska\",\"Dad\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"omk\"]\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"adsdf\",\"sfd\"]\n<strong>输出：</strong>[\"adsdf\",\"sfd\"]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= words.length <= 20</code></li>\n\t<li><code>1 <= words[i].length <= 100</code></li>\n\t<li><code>words[i]</code> 由英文字母（小写和大写字母）组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 501.二叉搜索树中的众数",
        "hardRate": "EASY",
        "passRate": "54.66%",
        "problemsUrl": "https://leetcode.cn/problems/find-mode-in-binary-search-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution",
        "problemsDesc": "<p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code> ，找出并返回 BST 中的所有 <a href=\"https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796\" target=\"_blank\">众数</a>（即，出现频率最高的元素）。</p>\n\n<p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p>\n\n<p>假定 BST 满足如下定义：</p>\n\n<ul>\n\t<li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li>\n\t<li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li>\n\t<li>左子树和右子树都是二叉搜索树</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg\" style=\"width: 142px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>root = [1,null,2,2]\n<strong>输出：</strong>[2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [0]\n<strong>输出：</strong>[0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 502.IPO",
        "hardRate": "HARD",
        "passRate": "44.87%",
        "problemsUrl": "https://leetcode.cn/problems/ipo/",
        "solutionsUrl": "https://leetcode.cn/problems/ipo/solution",
        "problemsDesc": "<p>假设 力扣（LeetCode）即将开始 <strong>IPO</strong> 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 <code>k</code> 个不同的项目。帮助 力扣 设计完成最多 <code>k</code> 个不同项目后得到最大总资本的方式。</p>\n\n<p>给你 <code>n</code> 个项目。对于每个项目 <code>i</code><strong> </strong>，它都有一个纯利润 <code>profits[i]</code> ，和启动该项目需要的最小资本 <code>capital[i]</code> 。</p>\n\n<p>最初，你的资本为 <code>w</code> 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。</p>\n\n<p>总而言之，从给定项目中选择 <strong>最多</strong> <code>k</code> 个不同项目的列表，以 <strong>最大化最终资本</strong> ，并输出最终可获得的最多资本。</p>\n\n<p>答案保证在 32 位有符号整数范围内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\n<strong>输出：</strong>4\n<strong>解释：\n</strong>由于你的初始资本为 0，你仅可以从 0 号项目开始。\n在完成后，你将获得 1 的利润，你的总资本将变为 1。\n此时你可以选择开始 1 号或 2 号项目。\n由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。\n因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]\n<strong>输出：</strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= w &lt;= 10<sup>9</sup></code></li>\n\t<li><code>n == profits.length</code></li>\n\t<li><code>n == capital.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= profits[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= capital[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 503.下一个更大元素 II",
        "hardRate": "MEDIUM",
        "passRate": "66.87%",
        "problemsUrl": "https://leetcode.cn/problems/next-greater-element-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/next-greater-element-ii/solution",
        "problemsDesc": "<p>给定一个循环数组&nbsp;<code>nums</code>&nbsp;（&nbsp;<code>nums[nums.length - 1]</code>&nbsp;的下一个元素是&nbsp;<code>nums[0]</code>&nbsp;），返回&nbsp;<em><code>nums</code>&nbsp;中每个元素的 <strong>下一个更大元素</strong></em> 。</p>\n\n<p>数字 <code>x</code>&nbsp;的 <strong>下一个更大的元素</strong> 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,1]\n<strong>输出:</strong> [2,-1,2]\n<strong>解释:</strong> 第一个 1 的下一个更大的数是 2；\n数字 2 找不到下一个更大的数； \n第二个 1 的下一个最大的数需要循环搜索，结果也是 2。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,3,4,3]\n<strong>输出:</strong> [2,3,4,-1,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 504.七进制数",
        "hardRate": "EASY",
        "passRate": "51.75%",
        "problemsUrl": "https://leetcode.cn/problems/base-7/",
        "solutionsUrl": "https://leetcode.cn/problems/base-7/solution",
        "problemsDesc": "<p>给定一个整数 <code>num</code>，将其转化为 <strong>7 进制</strong>，并以字符串形式输出。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> num = 100\n<strong>输出:</strong> \"202\"\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> num = -7\n<strong>输出:</strong> \"-10\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-10<sup>7</sup>&nbsp;&lt;= num &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 505.迷宫 II",
        "hardRate": "MEDIUM",
        "passRate": "51.56%",
        "problemsUrl": "https://leetcode.cn/problems/the-maze-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/the-maze-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 506.相对名次",
        "hardRate": "EASY",
        "passRate": "65.06%",
        "problemsUrl": "https://leetcode.cn/problems/relative-ranks/",
        "solutionsUrl": "https://leetcode.cn/problems/relative-ranks/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的整数数组 <code>score</code> ，其中 <code>score[i]</code> 是第 <code>i</code> 位运动员在比赛中的得分。所有得分都 <strong>互不相同</strong> 。</p>\n\n<p>运动员将根据得分 <strong>决定名次</strong> ，其中名次第 <code>1</code> 的运动员得分最高，名次第 <code>2</code> 的运动员得分第 <code>2</code> 高，依此类推。运动员的名次决定了他们的获奖情况：</p>\n\n<ul>\n\t<li>名次第 <code>1</code> 的运动员获金牌 <code>\"Gold Medal\"</code> 。</li>\n\t<li>名次第 <code>2</code> 的运动员获银牌 <code>\"Silver Medal\"</code> 。</li>\n\t<li>名次第 <code>3</code> 的运动员获铜牌 <code>\"Bronze Medal\"</code> 。</li>\n\t<li>从名次第 <code>4</code> 到第 <code>n</code> 的运动员，只能获得他们的名次编号（即，名次第 <code>x</code> 的运动员获得编号 <code>\"x\"</code>）。</li>\n</ul>\n\n<p>使用长度为 <code>n</code> 的数组 <code>answer</code> 返回获奖，其中 <code>answer[i]</code> 是第 <code>i</code> 位运动员的获奖情况。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>score = [5,4,3,2,1]\n<strong>输出：</strong>[\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\n<strong>解释：</strong>名次为 [1<sup>st</sup>, 2<sup>nd</sup>, 3<sup>rd</sup>, 4<sup>th</sup>, 5<sup>th</sup>] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>score = [10,3,8,9,4]\n<strong>输出：</strong>[\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\n<strong>解释：</strong>名次为 [1<sup>st</sup>, 5<sup>th</sup>, 3<sup>rd</sup>, 2<sup>nd</sup>, 4<sup>th</sup>] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == score.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= score[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>score</code> 中的所有值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 507.完美数",
        "hardRate": "EASY",
        "passRate": "49.11%",
        "problemsUrl": "https://leetcode.cn/problems/perfect-number/",
        "solutionsUrl": "https://leetcode.cn/problems/perfect-number/solution",
        "problemsDesc": "<p>对于一个&nbsp;<strong>正整数</strong>，如果它和除了它自身以外的所有 <strong>正因子</strong> 之和相等，我们称它为 <strong>「完美数」</strong>。</p>\n\n<p>给定一个&nbsp;<strong>整数&nbsp;</strong><code>n</code>，&nbsp;如果是完美数，返回 <code>true</code>；否则返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 28\n<strong>输出：</strong>true\n<strong>解释：</strong>28 = 1 + 2 + 4 + 7 + 14\n1, 2, 4, 7, 和 14 是 28 的所有正因子。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 7\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 508.出现次数最多的子树元素和",
        "hardRate": "MEDIUM",
        "passRate": "75.52%",
        "problemsUrl": "https://leetcode.cn/problems/most-frequent-subtree-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/most-frequent-subtree-sum/solution",
        "problemsDesc": "<p>给你一个二叉树的根结点&nbsp;<code>root</code>&nbsp;，请返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。</p>\n\n<p>一个结点的&nbsp;<strong>「子树元素和」</strong>&nbsp;定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/24/freq1-tree.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> root = [5,2,-3]\n<strong>输出:</strong> [2,-3,4]\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/24/freq2-tree.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> root = [5,2,-5]\n<b>输出:</b> [2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>节点数在&nbsp;<code>[1, 10<sup>4</sup>]</code>&nbsp;范围内</li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 509.斐波那契数",
        "hardRate": "EASY",
        "passRate": "66.16%",
        "problemsUrl": "https://leetcode.cn/problems/fibonacci-number/",
        "solutionsUrl": "https://leetcode.cn/problems/fibonacci-number/solution",
        "problemsDesc": "<p><strong>斐波那契数</strong>&nbsp;（通常用&nbsp;<code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由&nbsp;<code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>\n\n<pre>\nF(0) = 0，F(1)&nbsp;= 1\nF(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1\n</pre>\n\n<p>给定&nbsp;<code>n</code> ，请计算 <code>F(n)</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>F(2) = F(1) + F(0) = 1 + 0 = 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>F(3) = F(2) + F(1) = 1 + 1 = 2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>F(4) = F(3) + F(2) = 2 + 1 = 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 30</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 510.二叉搜索树中的中序后继 II",
        "hardRate": "MEDIUM",
        "passRate": "60.41%",
        "problemsUrl": "https://leetcode.cn/problems/inorder-successor-in-bst-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/inorder-successor-in-bst-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 511.游戏玩法分析 I",
        "hardRate": "EASY",
        "passRate": "70.69%",
        "problemsUrl": "https://leetcode.cn/problems/game-play-analysis-i/",
        "solutionsUrl": "https://leetcode.cn/problems/game-play-analysis-i/solution",
        "problemsDesc": "<p>活动表&nbsp;<code>Activity</code>：</p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| player_id    | int     |\n| device_id    | int     |\n| event_date   | date    |\n| games_played | int     |\n+--------------+---------+\n表的主键是 (player_id, event_date)。\n这张表展示了一些游戏玩家在游戏平台上的行为活动。\n每行数据记录了一名玩家在退出平台之前，当天使用同一台设备登录平台后打开的游戏的数目（可能是 0 个）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一条 SQL&nbsp;查询语句获取每位玩家 <strong>第一次登陆平台的日期</strong>。</p>\n\n<p>查询结果的格式如下所示：</p>\n\n<pre>\nActivity 表：\n+-----------+-----------+------------+--------------+\n| player_id | device_id | event_date | games_played |\n+-----------+-----------+------------+--------------+\n| 1         | 2         | 2016-03-01 | 5            |\n| 1         | 2         | 2016-05-02 | 6            |\n| 2         | 3         | 2017-06-25 | 1            |\n| 3         | 1         | 2016-03-02 | 0            |\n| 3         | 4         | 2018-07-03 | 5            |\n+-----------+-----------+------------+--------------+\n\nResult 表：\n+-----------+-------------+\n| player_id | first_login |\n+-----------+-------------+\n| 1         | 2016-03-01  |\n| 2         | 2017-06-25  |\n| 3         | 2016-03-02  |\n+-----------+-------------+\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 512.游戏玩法分析 II",
        "hardRate": "EASY",
        "passRate": "54.20%",
        "problemsUrl": "https://leetcode.cn/problems/game-play-analysis-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/game-play-analysis-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 513.找树左下角的值",
        "hardRate": "MEDIUM",
        "passRate": "73.48%",
        "problemsUrl": "https://leetcode.cn/problems/find-bottom-left-tree-value/",
        "solutionsUrl": "https://leetcode.cn/problems/find-bottom-left-tree-value/solution",
        "problemsDesc": "<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边 </strong>节点的值。</p>\n\n<p>假设二叉树中至少有一个节点。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg\" style=\"width: 182px; \" /></p>\n\n<pre>\n<strong>输入: </strong>root = [2,1,3]\n<strong>输出: </strong>1\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg\" style=\"width: 242px; \" /><strong> </strong></p>\n\n<pre>\n<strong>输入: </strong>[1,2,3,4,null,5,6,null,null,7]\n<strong>输出: </strong>7\n</pre>\n\n<p> </p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[1,10<sup>4</sup>]</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>-2<sup>31</sup> <= Node.val <= 2<sup>31</sup> - 1</code> </li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 514.自由之路",
        "hardRate": "HARD",
        "passRate": "51.49%",
        "problemsUrl": "https://leetcode.cn/problems/freedom-trail/",
        "solutionsUrl": "https://leetcode.cn/problems/freedom-trail/solution",
        "problemsDesc": "<p>电子游戏“辐射4”中，任务 <strong>“通向自由”</strong> 要求玩家到达名为 “<strong>Freedom Trail Ring”</strong> 的金属表盘，并使用表盘拼写特定关键词才能开门。</p>\n\n<p>给定一个字符串&nbsp;<code>ring</code>&nbsp;，表示刻在外环上的编码；给定另一个字符串&nbsp;<code>key</code>&nbsp;，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的<strong>最少</strong>步数。</p>\n\n<p>最初，<strong>ring&nbsp;</strong>的第一个字符与 <code>12:00</code> 方向对齐。您需要顺时针或逆时针旋转 <code>ring</code> 以使&nbsp;<strong>key&nbsp;</strong>的一个字符在 <code>12:00</code> 方向对齐，然后按下中心按钮，以此逐个拼写完&nbsp;<strong><code>key</code>&nbsp;</strong>中的所有字符。</p>\n\n<p>旋转&nbsp;<code>ring</code><strong>&nbsp;</strong>拼出 key 字符&nbsp;<code>key[i]</code><strong>&nbsp;</strong>的阶段中：</p>\n\n<ol>\n\t<li>您可以将&nbsp;<strong>ring&nbsp;</strong>顺时针或逆时针旋转&nbsp;<strong>一个位置&nbsp;</strong>，计为1步。旋转的最终目的是将字符串&nbsp;<strong><code>ring</code>&nbsp;</strong>的一个字符与 <code>12:00</code> 方向对齐，并且这个字符必须等于字符&nbsp;<strong><code>key[i]</code> 。</strong></li>\n\t<li>如果字符&nbsp;<strong><code>key[i]</code>&nbsp;</strong>已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作&nbsp;<strong>1 步</strong>。按完之后，您可以开始拼写&nbsp;<strong>key&nbsp;</strong>的下一个字符（下一阶段）, 直至完成所有拼写。</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/22/ring.jpg\" style=\"height: 450px; width: 450px;\" /></p>\n\n<center>&nbsp;</center>\n\n<pre>\n<strong>输入:</strong> ring = \"godding\", key = \"gd\"\n<strong>输出:</strong> 4\n<strong>解释:</strong>\n 对于 key 的第一个字符 'g'，已经在正确的位置, 我们只需要1步来拼写这个字符。 \n 对于 key 的第二个字符 'd'，我们需要逆时针旋转 ring \"godding\" 2步使它变成 \"ddinggo\"。\n 当然, 我们还需要1步进行拼写。\n 因此最终的输出是 4。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> ring = \"godding\", key = \"godding\"\n<strong>输出:</strong> 13\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= ring.length, key.length &lt;= 100</code></li>\n\t<li><code>ring</code>&nbsp;和&nbsp;<code>key</code>&nbsp;只包含小写英文字母</li>\n\t<li><strong>保证</strong> 字符串&nbsp;<code>key</code>&nbsp;一定可以由字符串 &nbsp;<code>ring</code>&nbsp;旋转拼出</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 515.在每个树行中找最大值",
        "hardRate": "MEDIUM",
        "passRate": "66.41%",
        "problemsUrl": "https://leetcode.cn/problems/find-largest-value-in-each-tree-row/",
        "solutionsUrl": "https://leetcode.cn/problems/find-largest-value-in-each-tree-row/solution",
        "problemsDesc": "<p>给定一棵二叉树的根节点&nbsp;<code>root</code> ，请找出该二叉树中每一层的最大值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/21/largest_e1.jpg\" style=\"height: 172px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入: </strong>root = [1,3,2,5,3,null,9]\n<strong>输出: </strong>[1,3,9]\n</pre>\n\n<p><strong>示例2：</strong></p>\n\n<pre>\n<strong>输入: </strong>root = [1,2,3]\n<strong>输出: </strong>[1,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[0,10<sup>4</sup>]</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>-2<sup>31</sup>&nbsp;&lt;= Node.val &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 516.最长回文子序列",
        "hardRate": "MEDIUM",
        "passRate": "67.16%",
        "problemsUrl": "https://leetcode.cn/problems/longest-palindromic-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-palindromic-subsequence/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p>\n\n<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"bbbab\"\n<strong>输出：</strong>4\n<strong>解释：</strong>一个可能的最长回文子序列为 \"bbbb\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"cbbd\"\n<strong>输出：</strong>2\n<strong>解释：</strong>一个可能的最长回文子序列为 \"bb\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 1000</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 517.超级洗衣机",
        "hardRate": "HARD",
        "passRate": "51.09%",
        "problemsUrl": "https://leetcode.cn/problems/super-washing-machines/",
        "solutionsUrl": "https://leetcode.cn/problems/super-washing-machines/solution",
        "problemsDesc": "<p>假设有 <code>n</code><strong>&nbsp;</strong>台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。</p>\n\n<p>在每一步操作中，你可以选择任意 <code>m</code> (<code>1 &lt;= m &lt;= n</code>) 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。</p>\n\n<p>给定一个整数数组&nbsp;<code>machines</code> 代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的 <strong>最少的操作步数 </strong>。如果不能使每台洗衣机中衣物的数量相等，则返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>machines = [1,0,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n第一步:    1     0 &lt;-- 5    =&gt;    1     1     4\n第二步:    1 &lt;-- 1 &lt;-- 4    =&gt;    2     1     3    \n第三步:    2     1 &lt;-- 3    =&gt;    2     2     2   \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>machines = [0,3,0]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n第一步:    0 &lt;-- 3     0    =&gt;    1     2     0    \n第二步:    1     2 --&gt; 0    =&gt;    1     1     1     \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>machines = [0,2,0]\n<strong>输出：</strong>-1\n<strong>解释：</strong>\n不可能让所有三个洗衣机同时剩下相同数量的衣物。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == machines.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= machines[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 518.零钱兑换 II",
        "hardRate": "MEDIUM",
        "passRate": "70.55%",
        "problemsUrl": "https://leetcode.cn/problems/coin-change-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/coin-change-ii/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p>\n\n<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p>\n\n<p>假设每一种面额的硬币有无限个。 </p>\n\n<p>题目数据保证结果符合 32 位带符号整数。</p>\n\n<p> </p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>amount = 5, coins = [1, 2, 5]\n<strong>输出：</strong>4\n<strong>解释：</strong>有四种方式可以凑成总金额：\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>amount = 3, coins = [2]\n<strong>输出：</strong>0\n<strong>解释：</strong>只用面额 2 的硬币不能凑成总金额 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>amount = 10, coins = [10] \n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= coins.length <= 300</code></li>\n\t<li><code>1 <= coins[i] <= 5000</code></li>\n\t<li><code>coins</code> 中的所有值 <strong>互不相同</strong></li>\n\t<li><code>0 <= amount <= 5000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 519.随机翻转矩阵",
        "hardRate": "MEDIUM",
        "passRate": "46.23%",
        "problemsUrl": "https://leetcode.cn/problems/random-flip-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/random-flip-matrix/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的二元矩阵 <code>matrix</code> ，且所有值被初始化为 <code>0</code> 。请你设计一个算法，随机选取一个满足&nbsp;<code>matrix[i][j] == 0</code> 的下标&nbsp;<code>(i, j)</code> ，并将它的值变为 <code>1</code> 。所有满足 <code>matrix[i][j] == 0</code> 的下标 <code>(i, j)</code> 被选取的概率应当均等。</p>\n\n<p>尽量最少调用内置的随机函数，并且优化时间和空间复杂度。</p>\n\n<p>实现 <code>Solution</code> 类：</p>\n\n<ul>\n\t<li><code>Solution(int m, int n)</code> 使用二元矩阵的大小 <code>m</code> 和 <code>n</code> 初始化该对象</li>\n\t<li><code>int[] flip()</code> 返回一个满足&nbsp;<code>matrix[i][j] == 0</code> 的随机下标 <code>[i, j]</code> ，并将其对应格子中的值变为 <code>1</code></li>\n\t<li><code>void reset()</code> 将矩阵中所有的值重置为 <code>0</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"]\n[[3, 1], [], [], [], [], []]\n<strong>输出</strong>\n[null, [1, 0], [2, 0], [0, 0], null, [2, 0]]\n\n<strong>解释</strong>\nSolution solution = new Solution(3, 1);\nsolution.flip();  // 返回 [1, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同\nsolution.flip();  // 返回 [2, 0]，因为 [1,0] 已经返回过了，此时返回 [2,0] 和 [0,0] 的概率应当相同\nsolution.flip();  // 返回 [0, 0]，根据前面已经返回过的下标，此时只能返回 [0,0]\nsolution.reset(); // 所有值都重置为 0 ，并可以再次选择下标返回\nsolution.flip();  // 返回 [2, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>4</sup></code></li>\n\t<li>每次调用<code>flip</code> 时，矩阵中至少存在一个值为 0 的格子。</li>\n\t<li>最多调用 <code>1000</code> 次 <code>flip</code> 和 <code>reset</code> 方法。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 520.检测大写字母",
        "hardRate": "EASY",
        "passRate": "56.77%",
        "problemsUrl": "https://leetcode.cn/problems/detect-capital/",
        "solutionsUrl": "https://leetcode.cn/problems/detect-capital/solution",
        "problemsDesc": "<p>我们定义，在以下情况时，单词的大写用法是正确的：</p>\n\n<ul>\n\t<li>全部字母都是大写，比如 <code>\"USA\"</code> 。</li>\n\t<li>单词中所有字母都不是大写，比如 <code>\"leetcode\"</code> 。</li>\n\t<li>如果单词不只含有一个字母，只有首字母大写，&nbsp;比如&nbsp;<code>\"Google\"</code> 。</li>\n</ul>\n\n<p>给你一个字符串 <code>word</code> 。如果大写用法正确，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"USA\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"FlaG\"\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 100</code></li>\n\t<li><code>word</code> 由小写和大写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 521.最长特殊序列 Ⅰ",
        "hardRate": "EASY",
        "passRate": "73.66%",
        "problemsUrl": "https://leetcode.cn/problems/longest-uncommon-subsequence-i/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-uncommon-subsequence-i/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>a</code>&nbsp;和&nbsp;<code>b</code>，请返回 <em>这两个字符串中 <strong>最长的特殊序列</strong>&nbsp;</em> 的长度。如果不存在，则返回 <code>-1</code>&nbsp;。</p>\n\n<p><strong>「最长特殊序列」</strong>&nbsp;定义如下：该序列为&nbsp;<strong>某字符串独有的最长子序列（即不能是其他字符串的子序列）</strong>&nbsp;。</p>\n\n<p>字符串&nbsp;<code>s</code>&nbsp;的子序列是在从&nbsp;<code>s</code>&nbsp;中删除任意数量的字符后可以获得的字符串。</p>\n\n<ul>\n\t<li>例如，<code>\"abc\"</code> 是 <code>\"aebdc\"</code> 的子序列，因为删除 <code>\"a<em><strong>e</strong></em>b<strong><em>d</em></strong>c\"</code> 中斜体加粗的字符可以得到 <code>\"abc\"</code> 。 <code>\"aebdc\"</code> 的子序列还包括 <code>\"aebdc\"</code> 、 <code>\"aeb\"</code> 和 <code>\"\"</code> (空字符串)。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> a = \"aba\", b = \"cdc\"\n<strong>输出:</strong> 3\n<strong>解释:</strong> 最长特殊序列可为 \"aba\" (或 \"cdc\")，两者均为自身的子序列且不是对方的子序列。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = \"aaa\", b = \"bbb\"\n<strong>输出：</strong>3\n<strong>解释:</strong> 最长特殊序列是 \"aaa\" 和 \"bbb\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = \"aaa\", b = \"aaa\"\n<strong>输出：</strong>-1\n<strong>解释:</strong> 字符串 a 的每个子序列也是字符串 b 的每个子序列。同样，字符串 b 的每个子序列也是字符串 a 的子序列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 100</code></li>\n\t<li><code>a</code>&nbsp;和&nbsp;<code>b</code>&nbsp;由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 522.最长特殊序列 II",
        "hardRate": "MEDIUM",
        "passRate": "48.79%",
        "problemsUrl": "https://leetcode.cn/problems/longest-uncommon-subsequence-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-uncommon-subsequence-ii/solution",
        "problemsDesc": "<p>给定字符串列表&nbsp;<code>strs</code> ，返回其中 <strong>最长的特殊序列</strong>&nbsp;的长度。如果最长特殊序列不存在，返回 <code>-1</code> 。</p>\n\n<p><strong>特殊序列</strong> 定义如下：该序列为某字符串 <strong>独有的子序列（即不能是其他字符串的子序列）</strong>。</p>\n\n<p>&nbsp;<code>s</code>&nbsp;的&nbsp;<strong>子序列</strong>可以通过删去字符串&nbsp;<code>s</code>&nbsp;中的某些字符实现。</p>\n\n<ul>\n\t<li>例如，<code>\"abc\"</code>&nbsp;是 <code>\"aebdc\"</code>&nbsp;的子序列，因为您可以删除<code>\"a<u>e</u>b<u>d</u>c\"</code>中的下划线字符来得到 <code>\"abc\"</code>&nbsp;。<code>\"aebdc\"</code>的子序列还包括<code>\"aebdc\"</code>、 <code>\"aeb\"</code>&nbsp;和 <font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size: 12.6px; background-color: rgb(249, 242, 244);\">\"\"</span></font>&nbsp;(空字符串)。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> strs = [\"aba\",\"cdc\",\"eae\"]\n<strong>输出:</strong> 3\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> strs = [\"aaa\",\"aaa\",\"aa\"]\n<strong>输出:</strong> -1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= strs.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= strs[i].length &lt;= 10</code></li>\n\t<li><code>strs[i]</code>&nbsp;只包含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 523.连续的子数组和",
        "hardRate": "MEDIUM",
        "passRate": "28.53%",
        "problemsUrl": "https://leetcode.cn/problems/continuous-subarray-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/continuous-subarray-sum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：</p>\n\n<ul>\n\t<li>子数组大小 <strong>至少为 2</strong> ，且</li>\n\t<li>子数组元素总和为 <code>k</code> 的倍数。</li>\n</ul>\n\n<p>如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>如果存在一个整数 <code>n</code> ，令整数 <code>x</code> 符合 <code>x = n * k</code> ，则称 <code>x</code> 是 <code>k</code> 的一个倍数。<code>0</code> 始终视为 <code>k</code> 的一个倍数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [23<u>,2,4</u>,6,7], k = 6\n<strong>输出：</strong>true\n<strong>解释：</strong>[2,4] 是一个大小为 2 的子数组，并且和为 6 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<u>23,2,6,4,7</u>], k = 6\n<strong>输出：</strong>true\n<strong>解释：</strong>[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 \n42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [23,2,6,4,7], k = 13\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= nums[i] <= 10<sup>9</sup></code></li>\n\t<li><code>0 <= sum(nums[i]) <= 2<sup>31</sup> - 1</code></li>\n\t<li><code>1 <= k <= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 524.通过删除字母匹配到字典里最长单词",
        "hardRate": "MEDIUM",
        "passRate": "50.04%",
        "problemsUrl": "https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和一个字符串数组 <code>dictionary</code> ，找出并返回&nbsp;<code>dictionary</code> 中最长的字符串，该字符串可以通过删除 <code>s</code> 中的某些字符得到。</p>\n\n<p>如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abpcplea\", dictionary = [\"ale\",\"apple\",\"monkey\",\"plea\"]\n<strong>输出：</strong>\"apple\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abpcplea\", dictionary = [\"a\",\"b\",\"c\"]\n<strong>输出：</strong>\"a\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= dictionary.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= dictionary[i].length &lt;= 1000</code></li>\n\t<li><code>s</code> 和 <code>dictionary[i]</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 525.连续数组",
        "hardRate": "MEDIUM",
        "passRate": "54.66%",
        "problemsUrl": "https://leetcode.cn/problems/contiguous-array/",
        "solutionsUrl": "https://leetcode.cn/problems/contiguous-array/solution",
        "problemsDesc": "<p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [0,1]\n<strong>输出:</strong> 2\n<strong>说明:</strong> [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [0,1,0]\n<strong>输出:</strong> 2\n<strong>说明:</strong> [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 526.优美的排列",
        "hardRate": "MEDIUM",
        "passRate": "73.23%",
        "problemsUrl": "https://leetcode.cn/problems/beautiful-arrangement/",
        "solutionsUrl": "https://leetcode.cn/problems/beautiful-arrangement/solution",
        "problemsDesc": "<p>假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 <code>perm</code>（<strong>下标从 1 开始</strong>），只要满足下述条件 <strong>之一</strong> ，该数组就是一个 <strong>优美的排列</strong> ：</p>\n\n<ul>\n\t<li><code>perm[i]</code> 能够被 <code>i</code> 整除</li>\n\t<li><code>i</code> 能够被 <code>perm[i]</code> 整除</li>\n</ul>\n\n<p>给你一个整数 <code>n</code> ，返回可以构造的 <strong>优美排列 </strong>的 <strong>数量</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>2\n<b>解释：</b>\n第 1 个优美的排列是 [1,2]：\n    - perm[1] = 1 能被 i = 1 整除\n    - perm[2] = 2 能被 i = 2 整除\n第 2 个优美的排列是 [2,1]:\n    - perm[1] = 2 能被 i = 1 整除\n    - i = 2 能被 perm[2] = 1 整除\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 15</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 527.单词缩写",
        "hardRate": "HARD",
        "passRate": "60.12%",
        "problemsUrl": "https://leetcode.cn/problems/word-abbreviation/",
        "solutionsUrl": "https://leetcode.cn/problems/word-abbreviation/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 528.按权重随机选择",
        "hardRate": "MEDIUM",
        "passRate": "48.40%",
        "problemsUrl": "https://leetcode.cn/problems/random-pick-with-weight/",
        "solutionsUrl": "https://leetcode.cn/problems/random-pick-with-weight/solution",
        "problemsDesc": "<p>给你一个 <strong>下标从 0 开始</strong> 的正整数数组&nbsp;<code>w</code> ，其中&nbsp;<code>w[i]</code> 代表第 <code>i</code> 个下标的权重。</p>\n\n<p>请你实现一个函数&nbsp;<code>pickIndex</code>&nbsp;，它可以 <strong>随机地</strong> 从范围 <code>[0, w.length - 1]</code> 内（含 <code>0</code> 和 <code>w.length - 1</code>）选出并返回一个下标。选取下标 <code>i</code>&nbsp;的 <strong>概率</strong> 为 <code>w[i] / sum(w)</code> 。</p>\n\n<ol>\n</ol>\n\n<ul>\n\t<li>例如，对于 <code>w = [1, 3]</code>，挑选下标 <code>0</code> 的概率为 <code>1 / (1 + 3)&nbsp;= 0.25</code> （即，25%），而选取下标 <code>1</code> 的概率为 <code>3 / (1 + 3)&nbsp;= 0.75</code>（即，<code>75%</code>）。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"Solution\",\"pickIndex\"]\n[[[1]],[]]\n<strong>输出：</strong>\n[null,0]\n<strong>解释：</strong>\nSolution solution = new Solution([1]);\nsolution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"]\n[[[1,3]],[],[],[],[],[]]\n<strong>输出：</strong>\n[null,1,1,1,1,0]\n<strong>解释：</strong>\nSolution solution = new Solution([1, 3]);\nsolution.pickIndex(); // 返回 1，返回下标 1，返回该下标概率为 3/4 。\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 0，返回下标 0，返回该下标概率为 1/4 。\n\n由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的:\n[null,1,1,1,1,0]\n[null,1,1,1,1,1]\n[null,1,1,1,0,0]\n[null,1,1,1,0,1]\n[null,1,0,1,0,0]\n......\n诸若此类。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= w.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= w[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pickIndex</code>&nbsp;将被调用不超过 <code>10<sup>4</sup></code>&nbsp;次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 529.扫雷游戏",
        "hardRate": "MEDIUM",
        "passRate": "63.94%",
        "problemsUrl": "https://leetcode.cn/problems/minesweeper/",
        "solutionsUrl": "https://leetcode.cn/problems/minesweeper/solution",
        "problemsDesc": "<p>让我们一起来玩扫雷游戏！</p>\n\n<p>给你一个大小为 <code>m x n</code> 二维字符矩阵&nbsp;<code>board</code> ，表示扫雷游戏的盘面，其中：</p>\n\n<ul>\n\t<li><code>'M'</code>&nbsp;代表一个 <strong>未挖出的</strong> 地雷，</li>\n\t<li><code>'E'</code>&nbsp;代表一个<strong> 未挖出的 </strong>空方块，</li>\n\t<li><code>'B'</code><strong>&nbsp;</strong>代表没有相邻（上，下，左，右，和所有4个对角线）地雷的<strong> 已挖出的 </strong>空白方块，</li>\n\t<li><strong>数字</strong>（<code>'1'</code> 到 <code>'8'</code>）表示有多少地雷与这块<strong> 已挖出的</strong> 方块相邻，</li>\n\t<li><code>'X'</code>&nbsp;则表示一个<strong> 已挖出的</strong> 地雷。</li>\n</ul>\n\n<p>给你一个整数数组 <code>click</code> ，其中 <code>click = [click<sub>r</sub>, click<sub>c</sub>]</code> 表示在所有<strong> 未挖出的 </strong>方块（<code>'M'</code> 或者 <code>'E'</code>）中的下一个点击位置（<code>click<sub>r</sub></code> 是行下标，<code>click<sub>c</sub></code> 是列下标）。</p>\n\n<p>根据以下规则，返回相应位置被点击后对应的盘面：</p>\n\n<ol>\n\t<li>如果一个地雷（<code>'M'</code>）被挖出，游戏就结束了- 把它改为&nbsp;<code>'X'</code> 。</li>\n\t<li>如果一个<strong> 没有相邻地雷 </strong>的空方块（<code>'E'</code>）被挖出，修改它为（<code>'B'</code>），并且所有和其相邻的<strong> 未挖出 </strong>方块都应该被递归地揭露。</li>\n\t<li>如果一个<strong> 至少与一个地雷相邻</strong> 的空方块（<code>'E'</code>）被挖出，修改它为数字（<code>'1'</code> 到 <code>'8'</code> ），表示相邻地雷的数量。</li>\n\t<li>如果在此次点击中，若无更多方块可被揭露，则返回盘面。</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/12/minesweeper_example_1.png\" style=\"width: 500px; max-width: 400px; height: 269px;\" />\n<pre>\n<strong>输入：</strong>board = [[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"M\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"]], click = [3,0]\n<strong>输出：</strong>[[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/12/minesweeper_example_2.png\" style=\"width: 500px; max-width: 400px; height: 275px;\" />\n<pre>\n<strong>输入：</strong>board = [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]], click = [1,2]\n<strong>输出：</strong>[[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"X\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>board[i][j]</code> 为 <code>'M'</code>、<code>'E'</code>、<code>'B'</code> 或数字 <code>'1'</code> 到 <code>'8'</code> 中的一个</li>\n\t<li><code>click.length == 2</code></li>\n\t<li><code>0 &lt;= click<sub>r</sub> &lt; m</code></li>\n\t<li><code>0 &lt;= click<sub>c</sub> &lt; n</code></li>\n\t<li><code>board[click<sub>r</sub>][click<sub>c</sub>]</code> 为 <code>'M'</code> 或 <code>'E'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 530.二叉搜索树的最小绝对差",
        "hardRate": "EASY",
        "passRate": "63.42%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-absolute-difference-in-bst/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-absolute-difference-in-bst/solution",
        "problemsDesc": "<p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p>\n\n<p>差值是一个正数，其数值等于两值之差的绝对值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg\" style=\"width: 292px; height: 301px;\" />\n<pre>\n<strong>输入：</strong>root = [4,2,6,1,3]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg\" style=\"width: 282px; height: 301px;\" />\n<pre>\n<strong>输入：</strong>root = [1,0,48,null,null,12,49]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目范围是 <code>[2, 10<sup>4</sup>]</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与 783 <a href=\"https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/\">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/</a> 相同</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 531.孤独像素 I",
        "hardRate": "MEDIUM",
        "passRate": "64.19%",
        "problemsUrl": "https://leetcode.cn/problems/lonely-pixel-i/",
        "solutionsUrl": "https://leetcode.cn/problems/lonely-pixel-i/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 532.数组中的 k-diff 数对",
        "hardRate": "MEDIUM",
        "passRate": "45.60%",
        "problemsUrl": "https://leetcode.cn/problems/k-diff-pairs-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/k-diff-pairs-in-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code> 和一个整数&nbsp;<code>k</code>，请你在数组中找出<strong> 不同的&nbsp;</strong>k-diff 数对，并返回不同的 <strong>k-diff 数对</strong> 的数目。</p>\n\n<p><strong>k-diff</strong>&nbsp;数对定义为一个整数对 <code>(nums[i], nums[j])</code><strong> </strong>，并满足下述全部条件：</p>\n\n<ul>\n\t<li><code>0 &lt;= i, j &lt; nums.length</code></li>\n\t<li><code>i != j</code></li>\n\t<li><code>nums[i] - nums[j] == k</code></li>\n</ul>\n\n<p><strong>注意</strong>，<code>|val|</code> 表示 <code>val</code> 的绝对值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3, 1, 4, 1, 5], k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。\n尽管数组中有两个 1 ，但我们只应返回不同的数对的数量。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1, 2, 3, 4, 5], k = 1\n<strong>输出：</strong>4\n<strong>解释：</strong>数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1, 3, 1, 5, 4], k = 0\n<strong>输出：</strong>1\n<strong>解释：</strong>数组中只有一个 0-diff 数对，(1, 1) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>7</sup> &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 533.孤独像素 II",
        "hardRate": "MEDIUM",
        "passRate": "52.63%",
        "problemsUrl": "https://leetcode.cn/problems/lonely-pixel-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/lonely-pixel-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 534.游戏玩法分析 III",
        "hardRate": "MEDIUM",
        "passRate": "68.99%",
        "problemsUrl": "https://leetcode.cn/problems/game-play-analysis-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/game-play-analysis-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 535.TinyURL 的加密与解密",
        "hardRate": "MEDIUM",
        "passRate": "87.56%",
        "problemsUrl": "https://leetcode.cn/problems/encode-and-decode-tinyurl/",
        "solutionsUrl": "https://leetcode.cn/problems/encode-and-decode-tinyurl/solution",
        "problemsDesc": "<p>TinyURL 是一种 URL 简化服务， 比如：当你输入一个 URL&nbsp;<code>https://leetcode.com/problems/design-tinyurl</code>&nbsp;时，它将返回一个简化的URL&nbsp;<code>http://tinyurl.com/4e9iAk</code> 。请你设计一个类来加密与解密 TinyURL 。</p>\n\n<p>加密和解密算法如何设计和运作是没有限制的，你只需要保证一个 URL 可以被加密成一个 TinyURL ，并且这个 TinyURL 可以用解密方法恢复成原本的 URL 。</p>\n\n<p>实现 <code>Solution</code> 类：</p>\n\n<div class=\"original__bRMd\">\n<div>\n<ul>\n\t<li><code>Solution()</code> 初始化 TinyURL 系统对象。</li>\n\t<li><code>String encode(String longUrl)</code> 返回 <code>longUrl</code> 对应的 TinyURL 。</li>\n\t<li><code>String decode(String shortUrl)</code> 返回 <code>shortUrl</code> 原本的 URL 。题目数据保证给定的 <code>shortUrl</code> 是由同一个系统对象加密的。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>url = \"https://leetcode.com/problems/design-tinyurl\"\n<strong>输出：</strong>\"https://leetcode.com/problems/design-tinyurl\"\n\n<strong>解释：</strong>\nSolution obj = new Solution();\nstring tiny = obj.encode(url); // 返回加密后得到的 TinyURL 。\nstring ans = obj.decode(tiny); // 返回解密后得到的原本的 URL 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= url.length &lt;= 10<sup>4</sup></code></li>\n\t<li>题目数据保证 <code>url</code> 是一个有效的 URL</li>\n</ul>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 536.从字符串生成二叉树",
        "hardRate": "MEDIUM",
        "passRate": "55.21%",
        "problemsUrl": "https://leetcode.cn/problems/construct-binary-tree-from-string/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-binary-tree-from-string/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 537.复数乘法",
        "hardRate": "MEDIUM",
        "passRate": "74.56%",
        "problemsUrl": "https://leetcode.cn/problems/complex-number-multiplication/",
        "solutionsUrl": "https://leetcode.cn/problems/complex-number-multiplication/solution",
        "problemsDesc": "<p><a href=\"https://baike.baidu.com/item/%E5%A4%8D%E6%95%B0/254365?fr=aladdin\" target=\"_blank\">复数</a> 可以用字符串表示，遵循 <code>\"<strong>实部</strong>+<strong>虚部</strong>i\"</code> 的形式，并满足下述条件：</p>\n\n<ul>\n\t<li><code>实部</code> 是一个整数，取值范围是 <code>[-100, 100]</code></li>\n\t<li><code>虚部</code> 也是一个整数，取值范围是 <code>[-100, 100]</code></li>\n\t<li><code>i<sup>2</sup> == -1</code></li>\n</ul>\n\n<p>给你两个字符串表示的复数 <code>num1</code> 和 <code>num2</code> ，请你遵循复数表示形式，返回表示它们乘积的字符串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = \"1+1i\", num2 = \"1+1i\"\n<strong>输出：</strong>\"0+2i\"\n<strong>解释：</strong>(1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i ，你需要将它转换为 0+2i 的形式。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = \"1+-1i\", num2 = \"1+-1i\"\n<strong>输出：</strong>\"0+-2i\"\n<strong>解释：</strong>(1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i ，你需要将它转换为 0+-2i 的形式。 \n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>num1</code> 和 <code>num2</code> 都是有效的复数表示。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 538.把二叉搜索树转换为累加树",
        "hardRate": "MEDIUM",
        "passRate": "76.62%",
        "problemsUrl": "https://leetcode.cn/problems/convert-bst-to-greater-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-bst-to-greater-tree/solution",
        "problemsDesc": "<p>给出二叉<strong> 搜索 </strong>树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code>&nbsp;的新值等于原树中大于或等于&nbsp;<code>node.val</code>&nbsp;的值之和。</p>\n\n<p>提醒一下，二叉搜索树满足下列约束条件：</p>\n\n<ul>\n\t<li>节点的左子树仅包含键<strong> 小于 </strong>节点键的节点。</li>\n\t<li>节点的右子树仅包含键<strong> 大于</strong> 节点键的节点。</li>\n\t<li>左右子树也必须是二叉搜索树。</li>\n</ul>\n\n<p><strong>注意：</strong>本题和 1038:&nbsp;<a href=\"https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/\">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png\" style=\"height: 364px; width: 534px;\"></strong></p>\n\n<pre><strong>输入：</strong>[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n<strong>输出：</strong>[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>root = [0,null,1]\n<strong>输出：</strong>[1,null,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>root = [1,0,2]\n<strong>输出：</strong>[3,3,2]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>root = [3,2,4,1]\n<strong>输出：</strong>[7,9,4,10]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数介于 <code>0</code>&nbsp;和 <code>10<sup>4</sup></code><sup>&nbsp;</sup>之间。</li>\n\t<li>每个节点的值介于 <code>-10<sup>4</sup></code>&nbsp;和&nbsp;<code>10<sup>4</sup></code>&nbsp;之间。</li>\n\t<li>树中的所有值 <strong>互不相同</strong> 。</li>\n\t<li>给定的树为二叉搜索树。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 539.最小时间差",
        "hardRate": "MEDIUM",
        "passRate": "65.94%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-difference/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-difference/solution",
        "problemsDesc": "<p>给定一个 24 小时制（小时:分钟 <strong>\"HH:MM\"</strong>）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>timePoints = [\"23:59\",\"00:00\"]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>timePoints = [\"00:00\",\"23:59\",\"00:00\"]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= timePoints.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>timePoints[i]</code> 格式为 <strong>\"HH:MM\"</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 540.有序数组中的单一元素",
        "hardRate": "MEDIUM",
        "passRate": "60.49%",
        "problemsUrl": "https://leetcode.cn/problems/single-element-in-a-sorted-array/",
        "solutionsUrl": "https://leetcode.cn/problems/single-element-in-a-sorted-array/solution",
        "problemsDesc": "<p>给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。</p>\n\n<p>请你找出并返回只出现一次的那个数。</p>\n\n<p>你设计的解决方案必须满足 <code>O(log n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,1,2,3,3,4,4,8,8]\n<strong>输出:</strong> 2\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums =  [3,3,7,7,10,11,11]\n<strong>输出:</strong> 10\n</pre>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i]&nbsp;&lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 541.反转字符串 II",
        "hardRate": "EASY",
        "passRate": "57.98%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-string-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-string-ii/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p>\n\n<ul>\n\t<li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li>\n\t<li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcdefg\", k = 2\n<strong>输出：</strong>\"bacdfeg\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\", k = 2\n<strong>输出：</strong>\"bacd\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> 仅由小写英文组成</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 542.01 矩阵",
        "hardRate": "MEDIUM",
        "passRate": "46.60%",
        "problemsUrl": "https://leetcode.cn/problems/01-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/01-matrix/solution",
        "problemsDesc": "<p>给定一个由 <code>0</code> 和 <code>1</code> 组成的矩阵 <code>mat</code> ，请输出一个大小相同的矩阵，其中每一个格子是 <code>mat</code> 中对应位置元素到最近的 <code>0</code> 的距离。</p>\n\n<p>两个相邻元素间的距离为 <code>1</code> 。</p>\n\n<p> </p>\n\n<p><b>示例 1：</b></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626667201-NCWmuP-image.png\" style=\"width: 150px; \" /></p>\n\n<pre>\n<strong>输入：</strong>mat =<strong> </strong>[[0,0,0],[0,1,0],[0,0,0]]\n<strong>输出：</strong>[[0,0,0],[0,1,0],[0,0,0]]\n</pre>\n\n<p><b>示例 2：</b></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626667205-xFxIeK-image.png\" style=\"width: 150px; \" /></p>\n\n<pre>\n<b>输入：</b>mat =<b> </b>[[0,0,0],[0,1,0],[1,1,1]]\n<strong>输出：</strong>[[0,0,0],[0,1,0],[1,2,1]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 <= m, n <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= m * n <= 10<sup>4</sup></code></li>\n\t<li><code>mat[i][j] is either 0 or 1.</code></li>\n\t<li><code>mat</code> 中至少有一个 <code>0 </code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 543.二叉树的直径",
        "hardRate": "EASY",
        "passRate": "58.60%",
        "problemsUrl": "https://leetcode.cn/problems/diameter-of-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/diameter-of-binary-tree/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。</p>\n\n<p>二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。</p>\n\n<p>两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg\" style=\"width: 292px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[1, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 544.输出比赛匹配对",
        "hardRate": "MEDIUM",
        "passRate": "72.26%",
        "problemsUrl": "https://leetcode.cn/problems/output-contest-matches/",
        "solutionsUrl": "https://leetcode.cn/problems/output-contest-matches/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 545.二叉树的边界",
        "hardRate": "MEDIUM",
        "passRate": "44.85%",
        "problemsUrl": "https://leetcode.cn/problems/boundary-of-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/boundary-of-binary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 546.移除盒子",
        "hardRate": "HARD",
        "passRate": "60.82%",
        "problemsUrl": "https://leetcode.cn/problems/remove-boxes/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-boxes/solution",
        "problemsDesc": "<p>给出一些不同颜色的盒子<meta charset=\"UTF-8\" />&nbsp;<code>boxes</code>&nbsp;，盒子的颜色由不同的正数表示。</p>\n\n<p>你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 <code>k</code> 个盒子（<code>k&nbsp;&gt;= 1</code>），这样一轮之后你将得到 <code>k * k</code> 个积分。</p>\n\n<p>返回 <em>你能获得的最大积分和</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>boxes = [1,3,2,2,2,3,4,3,1]\n<strong>输出：</strong>23\n<strong>解释：</strong>\n[1, 3, 2, 2, 2, 3, 4, 3, 1] \n----&gt; [1, 3, 3, 4, 3, 1] (3*3=9 分) \n----&gt; [1, 3, 3, 3, 1] (1*1=1 分) \n----&gt; [1, 1] (3*3=9 分) \n----&gt; [] (2*2=4 分)\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>boxes = [1,1,1]\n<strong>输出：</strong>9\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>boxes = [1]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= boxes.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= boxes[i]&nbsp;&lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 547.省份数量",
        "hardRate": "MEDIUM",
        "passRate": "62.22%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-provinces/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-provinces/solution",
        "problemsDesc": "<div class=\"original__bRMd\">\n<div>\n<p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p>\n\n<p><strong>省份</strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>\n\n<p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p>\n\n<p>返回矩阵中 <strong>省份</strong> 的数量。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg\" style=\"width: 222px; height: 142px;\" />\n<pre>\n<strong>输入：</strong>isConnected = [[1,1,0],[1,1,0],[0,0,1]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg\" style=\"width: 222px; height: 142px;\" />\n<pre>\n<strong>输入：</strong>isConnected = [[1,0,0],[0,1,0],[0,0,1]]\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 200</code></li>\n\t<li><code>n == isConnected.length</code></li>\n\t<li><code>n == isConnected[i].length</code></li>\n\t<li><code>isConnected[i][j]</code> 为 <code>1</code> 或 <code>0</code></li>\n\t<li><code>isConnected[i][i] == 1</code></li>\n\t<li><code>isConnected[i][j] == isConnected[j][i]</code></li>\n</ul>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 548.将数组分割成和相等的子数组",
        "hardRate": "HARD",
        "passRate": "39.07%",
        "problemsUrl": "https://leetcode.cn/problems/split-array-with-equal-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/split-array-with-equal-sum/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 549.二叉树中最长的连续序列",
        "hardRate": "MEDIUM",
        "passRate": "50.24%",
        "problemsUrl": "https://leetcode.cn/problems/binary-tree-longest-consecutive-sequence-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-tree-longest-consecutive-sequence-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 550.游戏玩法分析 IV",
        "hardRate": "MEDIUM",
        "passRate": "43.65%",
        "problemsUrl": "https://leetcode.cn/problems/game-play-analysis-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/game-play-analysis-iv/solution",
        "problemsDesc": "<p>Table:&nbsp;<code>Activity</code></p>\n\n<pre>+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| player_id    | int     |\n| device_id    | int     |\n| event_date   | date    |\n| games_played | int     |\n+--------------+---------+\n（player_id，event_date）是此表的主键。\n这张表显示了某些游戏的玩家的活动情况。\n每一行是一个玩家的记录，他在某一天使用某个设备注销之前登录并玩了很多游戏（可能是 0）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个 SQL 查询，报告在首次登录的第二天再次登录的玩家的比率，四舍五入到小数点后两位。换句话说，您需要计算从首次登录日期开始至少连续两天登录的玩家的数量，然后除以玩家总数。</p>\n\n<p>查询结果格式如下所示：</p>\n\n<pre>Activity table:\n+-----------+-----------+------------+--------------+\n| player_id | device_id | event_date | games_played |\n+-----------+-----------+------------+--------------+\n| 1         | 2         | 2016-03-01 | 5            |\n| 1         | 2         | 2016-03-02 | 6            |\n| 2         | 3         | 2017-06-25 | 1            |\n| 3         | 1         | 2016-03-02 | 0            |\n| 3         | 4         | 2018-07-03 | 5            |\n+-----------+-----------+------------+--------------+\n\nResult table:\n+-----------+\n| fraction  |\n+-----------+\n| 0.33      |\n+-----------+\n只有 ID 为 1 的玩家在第一天登录后才重新登录，所以答案是 1/3 = 0.33\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 551.学生出勤记录 I",
        "hardRate": "EASY",
        "passRate": "56.73%",
        "problemsUrl": "https://leetcode.cn/problems/student-attendance-record-i/",
        "solutionsUrl": "https://leetcode.cn/problems/student-attendance-record-i/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：</p>\n\n<ul>\n\t<li><code>'A'</code>：Absent，缺勤</li>\n\t<li><code>'L'</code>：Late，迟到</li>\n\t<li><code>'P'</code>：Present，到场</li>\n</ul>\n\n<p>如果学生能够 <strong>同时</strong> 满足下面两个条件，则可以获得出勤奖励：</p>\n\n<ul>\n\t<li>按 <strong>总出勤</strong> 计，学生缺勤（<code>'A'</code>）<strong>严格</strong> 少于两天。</li>\n\t<li>学生 <strong>不会</strong> 存在 <strong>连续</strong> 3 天或 <strong>连续</strong> 3 天以上的迟到（<code>'L'</code>）记录。</li>\n</ul>\n\n<p>如果学生可以获得出勤奖励，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"PPALLP\"\n<strong>输出：</strong>true\n<strong>解释：</strong>学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"PPALLL\"\n<strong>输出：</strong>false\n<strong>解释：</strong>学生最后三天连续迟到，所以不满足出勤奖励的条件。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i]</code> 为 <code>'A'</code>、<code>'L'</code> 或 <code>'P'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 552.学生出勤记录 II",
        "hardRate": "HARD",
        "passRate": "57.78%",
        "problemsUrl": "https://leetcode.cn/problems/student-attendance-record-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/student-attendance-record-ii/solution",
        "problemsDesc": "可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：\n<ul>\n\t<li><code>'A'</code>：Absent，缺勤</li>\n\t<li><code>'L'</code>：Late，迟到</li>\n\t<li><code>'P'</code>：Present，到场</li>\n</ul>\n\n<p>如果学生能够 <strong>同时</strong> 满足下面两个条件，则可以获得出勤奖励：</p>\n\n<ul>\n\t<li>按 <strong>总出勤</strong> 计，学生缺勤（<code>'A'</code>）<strong>严格</strong> 少于两天。</li>\n\t<li>学生 <strong>不会</strong> 存在 <strong>连续</strong> 3 天或 <strong>连续</strong> 3 天以上的迟到（<code>'L'</code>）记录。</li>\n</ul>\n\n<p>给你一个整数 <code>n</code> ，表示出勤记录的长度（次数）。请你返回记录长度为 <code>n</code> 时，可能获得出勤奖励的记录情况 <strong>数量</strong> 。答案可能很大，所以返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>8\n<strong>解释：\n</strong>有 8 种长度为 2 的记录将被视为可奖励：\n\"PP\" , \"AP\", \"PA\", \"LP\", \"PL\", \"AL\", \"LA\", \"LL\" \n只有\"AA\"不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10101\n<strong>输出：</strong>183236316\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 553.最优除法",
        "hardRate": "MEDIUM",
        "passRate": "64.76%",
        "problemsUrl": "https://leetcode.cn/problems/optimal-division/",
        "solutionsUrl": "https://leetcode.cn/problems/optimal-division/solution",
        "problemsDesc": "<p>给定一正整数数组<strong> </strong><code>nums</code><strong>，</strong><code>nums</code> 中的相邻整数将进行浮点除法。例如，&nbsp;[2,3,4] -&gt; 2 / 3 / 4 。</p>\n\n<ul>\n\t<li>例如，<code>nums = [2,3,4]</code>，我们将求表达式的值&nbsp;<code>\"2/3/4\"</code>。</li>\n</ul>\n\n<p>但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，以便计算后的表达式的值为最大值。</p>\n\n<p>以字符串格式返回具有最大值的对应表达式。</p>\n\n<p><strong>注意：</strong>你的表达式不应该包含多余的括号。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> [1000,100,10,2]\n<strong>输出:</strong> \"1000/(100/10/2)\"\n<strong>解释: </strong>1000/(100/10/2) = 1000/((100/10)/2) = 200\n但是，以下加粗的括号 \"1000/(<strong>(</strong>100/10<strong>)</strong>/2)\" 是冗余的，\n因为他们并不影响操作的优先级，所以你需要返回 \"1000/(100/10/2)\"。\n\n其他用例:\n1000/(100/10)/2 = 50\n1000/(100/(10/2)) = 50\n1000/100/10/2 = 0.5\n1000/100/(10/2) = 2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [2,3,4]\n<strong>输出:</strong> \"2/(3/4)\"\n<strong>解释:</strong> (2/(3/4)) = 8/3 = 2.667\n可以看出，在尝试了所有的可能性之后，我们无法得到一个结果大于 2.667 的表达式。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10</code></li>\n\t<li><code>2 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>对于给定的输入只有一种最优除法。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 554.砖墙",
        "hardRate": "MEDIUM",
        "passRate": "51.50%",
        "problemsUrl": "https://leetcode.cn/problems/brick-wall/",
        "solutionsUrl": "https://leetcode.cn/problems/brick-wall/solution",
        "problemsDesc": "<p>你的面前有一堵矩形的、由 <code>n</code> 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和相等。</p>\n\n<p>你现在要画一条 <strong>自顶向下 </strong>的、穿过 <strong>最少 </strong>砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。<strong>你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。</strong></p>\n\n<p>给你一个二维数组 <code>wall</code> ，该数组包含这堵墙的相关信息。其中，<code>wall[i]</code> 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 <strong>穿过的砖块数量最少</strong> ，并且返回 <strong>穿过的砖块数量</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/24/cutwall-grid.jpg\" style=\"width: 493px; height: 577px;\" />\n<pre>\n<strong>输入：</strong>wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>wall = [[1],[1],[1]]\n<strong>输出：</strong>3\n</pre>\n \n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == wall.length</code></li>\n\t<li><code>1 <= n <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= wall[i].length <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= sum(wall[i].length) <= 2 * 10<sup>4</sup></code></li>\n\t<li>对于每一行 <code>i</code> ，<code>sum(wall[i])</code> 是相同的</li>\n\t<li><code>1 <= wall[i][j] <= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 555.分割连接字符串",
        "hardRate": "MEDIUM",
        "passRate": "37.65%",
        "problemsUrl": "https://leetcode.cn/problems/split-concatenated-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/split-concatenated-strings/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 556.下一个更大元素 III",
        "hardRate": "MEDIUM",
        "passRate": "36.88%",
        "problemsUrl": "https://leetcode.cn/problems/next-greater-element-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/next-greater-element-iii/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> ，请你找出符合条件的最小整数，其由重新排列 <code>n</code><strong> </strong>中存在的每位数字组成，并且其值大于 <code>n</code> 。如果不存在这样的正整数，则返回 <code>-1</code> 。</p>\n\n<p><strong>注意</strong> ，返回的整数应当是一个 <strong>32 位整数</strong> ，如果存在满足题意的答案，但不是 <strong>32 位整数</strong> ，同样返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 12\n<strong>输出：</strong>21\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 21\n<strong>输出：</strong>-1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 557.反转字符串中的单词 III",
        "hardRate": "EASY",
        "passRate": "73.76%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-words-in-a-string-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-words-in-a-string-iii/solution",
        "problemsDesc": "<p>给定一个字符串<meta charset=\"UTF-8\" />&nbsp;<code>s</code>&nbsp;，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"Let's take LeetCode contest\"\n<strong>输出：</strong>\"s'teL ekat edoCteeL tsetnoc\"\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入：</strong> s = \"God Ding\"\n<strong>输出：</strong>\"doG gniD\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong><strong><strong><strong>提示：</strong></strong></strong></strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><meta charset=\"UTF-8\" /><code>s</code>&nbsp;包含可打印的 <strong>ASCII</strong> 字符。</li>\n\t<li><meta charset=\"UTF-8\" /><code>s</code>&nbsp;不包含任何开头或结尾空格。</li>\n\t<li><meta charset=\"UTF-8\" /><code>s</code>&nbsp;里 <strong>至少</strong> 有一个词。</li>\n\t<li><meta charset=\"UTF-8\" /><code>s</code>&nbsp;中的所有单词都用一个空格隔开。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 558.四叉树交集",
        "hardRate": "MEDIUM",
        "passRate": "62.77%",
        "problemsUrl": "https://leetcode.cn/problems/logical-or-of-two-binary-grids-represented-as-quad-trees/",
        "solutionsUrl": "https://leetcode.cn/problems/logical-or-of-two-binary-grids-represented-as-quad-trees/solution",
        "problemsDesc": "<p>二进制矩阵中的所有元素不是 <strong>0</strong> 就是 <strong>1 </strong>。</p>\n\n<p>给你两个四叉树，<code>quadTree1</code> 和 <code>quadTree2</code>。其中 <code>quadTree1</code> 表示一个 <code>n * n</code> 二进制矩阵，而 <code>quadTree2</code> 表示另一个 <code>n * n</code> 二进制矩阵。</p>\n\n<p>请你返回一个表示 <code>n * n</code> 二进制矩阵的四叉树，它是 <code>quadTree1</code> 和 <code>quadTree2</code> 所表示的两个二进制矩阵进行 <strong>按位逻辑或运算</strong> 的结果。</p>\n\n<p>注意，当 <code>isLeaf</code> 为 <strong>False </strong>时，你可以把 <strong>True</strong> 或者 <strong>False</strong> 赋值给节点，两种值都会被判题机制 <strong>接受</strong> 。</p>\n\n<p>四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：</p>\n\n<ul>\n\t<li><code>val</code>：储存叶子结点所代表的区域的值。1 对应 <strong>True</strong>，0 对应 <strong>False</strong>；</li>\n\t<li><code>isLeaf</code>: 当这个节点是一个叶子结点时为 <strong>True</strong>，如果它有 4 个子节点则为 <strong>False</strong> 。</li>\n</ul>\n\n<pre>\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}</pre>\n\n<p>我们可以按以下步骤为二维区域构建四叉树：</p>\n\n<ol>\n\t<li>如果当前网格的值相同（即，全为 <code>0</code> 或者全为 <code>1</code>），将 <code>isLeaf</code> 设为 True ，将 <code>val</code> 设为网格相应的值，并将四个子节点都设为 Null 然后停止。</li>\n\t<li>如果当前网格的值不同，将 <code>isLeaf</code> 设为 False， 将 <code>val</code> 设为任意值，然后如下图所示，将当前网格划分为四个子网格。</li>\n\t<li>使用适当的子网格递归每个子节点。</li>\n</ol>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/11/new_top.png\" style=\"height: 181px; width: 777px;\" /></p>\n\n<p>如果你想了解更多关于四叉树的内容，可以参考 <a href=\"https://en.wikipedia.org/wiki/Quadtree\">wiki</a> 。</p>\n\n<p><strong>四叉树格式：</strong></p>\n\n<p>输出为使用层序遍历后四叉树的序列化形式，其中 <code>null</code> 表示路径终止符，其下面不存在节点。</p>\n\n<p>它与二叉树的序列化非常相似。唯一的区别是节点以列表形式表示 <code>[isLeaf, val]</code> 。</p>\n\n<p>如果 <code>isLeaf</code> 或者 <code>val</code> 的值为 True ，则表示它在列表 <code>[isLeaf, val]</code> 中的值为 <strong>1</strong> ；如果 <code>isLeaf</code> 或者 <code>val</code> 的值为 False ，则表示值为 <strong>0 </strong>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/11/qt1.png\" style=\"height: 196px; width: 550px;\" /> <img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/11/qt2.png\" style=\"height: 278px; width: 550px;\" /></p>\n\n<pre>\n<strong>输入：</strong>quadTree1 = [[0,1],[1,1],[1,1],[1,0],[1,0]]\n, quadTree2 = [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\n<strong>输出：</strong>[[0,0],[1,1],[1,1],[1,1],[1,0]]\n<strong>解释：</strong>quadTree1 和 quadTree2 如上所示。由四叉树所表示的二进制矩阵也已经给出。\n如果我们对这两个矩阵进行按位逻辑或运算，则可以得到下面的二进制矩阵，由一个作为结果的四叉树表示。\n注意，我们展示的二进制矩阵仅仅是为了更好地说明题意，你无需构造二进制矩阵来获得结果四叉树。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/11/qtr.png\" style=\"height: 222px; width: 777px;\" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>quadTree1 = [[1,0]]\n, quadTree2 = [[1,0]]\n<strong>输出：</strong>[[1,0]]\n<strong>解释：</strong>两个数所表示的矩阵大小都为 1*1，值全为 0 \n结果矩阵大小为 1*1，值全为 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>quadTree1 = [[0,0],[1,0],[1,0],[1,1],[1,1]]\n, quadTree2 = [[0,0],[1,1],[1,1],[1,0],[1,1]]\n<strong>输出：</strong>[[1,1]]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>quadTree1 = [[0,0],[1,1],[1,0],[1,1],[1,1]]\n, quadTree2 = [[0,0],[1,1],[0,1],[1,1],[1,1],null,null,null,null,[1,1],[1,0],[1,0],[1,1]]\n<strong>输出：</strong>[[0,0],[1,1],[0,1],[1,1],[1,1],null,null,null,null,[1,1],[1,0],[1,0],[1,1]]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>quadTree1 = [[0,1],[1,0],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\n, quadTree2 = [[0,1],[0,1],[1,0],[1,1],[1,0],[1,0],[1,0],[1,1],[1,1]]\n<strong>输出：</strong>[[0,0],[0,1],[0,1],[1,1],[1,0],[1,0],[1,0],[1,1],[1,1],[1,0],[1,0],[1,1],[1,1]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>quadTree1</code> 和 <code>quadTree2</code> 都是符合题目要求的四叉树，每个都代表一个 <code>n * n</code> 的矩阵。</li>\n\t<li><code>n == 2^x</code> ，其中 <code>0 <= x <= 9</code>.</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 559.N 叉树的最大深度",
        "hardRate": "EASY",
        "passRate": "74.99%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/solution",
        "problemsDesc": "<p>给定一个 N 叉树，找到其最大深度。</p>\n\n<p class=\"MachineTrans-lang-zh-CN\">最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p>\n\n<p class=\"MachineTrans-lang-zh-CN\">N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p>\n\n<p class=\"MachineTrans-lang-zh-CN\"> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 100%; max-width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,null,3,2,4,null,5,6]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"width: 296px; height: 241px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>输出：</strong>5\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树的深度不会超过 <code>1000</code> 。</li>\n\t<li>树的节点数目位于 <code>[0, 10<sup>4</sup>]</code> 之间。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 560.和为 K 的子数组",
        "hardRate": "MEDIUM",
        "passRate": "45.01%",
        "problemsUrl": "https://leetcode.cn/problems/subarray-sum-equals-k/",
        "solutionsUrl": "https://leetcode.cn/problems/subarray-sum-equals-k/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数&nbsp;<code>k</code> ，请你统计并返回 <em>该数组中和为&nbsp;<code>k</code><strong>&nbsp;</strong>的连续子数组的个数&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1], k = 2\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3], k = 3\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>-10<sup>7</sup> &lt;= k &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 561.数组拆分",
        "hardRate": "EASY",
        "passRate": "78.52%",
        "problemsUrl": "https://leetcode.cn/problems/array-partition/",
        "solutionsUrl": "https://leetcode.cn/problems/array-partition/solution",
        "problemsDesc": "<p>给定长度为&nbsp;<code>2n</code><strong>&nbsp;</strong>的整数数组 <code>nums</code> ，你的任务是将这些数分成&nbsp;<code>n</code><strong> </strong>对, 例如 <code>(a<sub>1</sub>, b<sub>1</sub>), (a<sub>2</sub>, b<sub>2</sub>), ..., (a<sub>n</sub>, b<sub>n</sub>)</code> ，使得从 <code>1</code> 到&nbsp;<code>n</code> 的 <code>min(a<sub>i</sub>, b<sub>i</sub>)</code> 总和最大。</p>\n\n<p>返回该 <strong>最大总和</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,4,3,2]\n<strong>输出：</strong>4\n<strong>解释：</strong>所有可能的分法（忽略元素顺序）为：\n1. (1, 4), (2, 3) -&gt; min(1, 4) + min(2, 3) = 1 + 2 = 3\n2. (1, 3), (2, 4) -&gt; min(1, 3) + min(2, 4) = 1 + 2 = 3\n3. (1, 2), (3, 4) -&gt; min(1, 2) + min(3, 4) = 1 + 3 = 4\n所以最大总和为 4</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [6,2,6,5,1,2]\n<strong>输出：</strong>9\n<strong>解释：</strong>最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums.length == 2 * n</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 562.矩阵中最长的连续1线段",
        "hardRate": "MEDIUM",
        "passRate": "49.69%",
        "problemsUrl": "https://leetcode.cn/problems/longest-line-of-consecutive-one-in-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-line-of-consecutive-one-in-matrix/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 563.二叉树的坡度",
        "hardRate": "EASY",
        "passRate": "65.90%",
        "problemsUrl": "https://leetcode.cn/problems/binary-tree-tilt/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-tree-tilt/solution",
        "problemsDesc": "<p>给你一个二叉树的根节点 <code>root</code> ，计算并返回 <strong>整个树 </strong>的坡度 。</p>\n\n<p>一个树的<strong> 节点的坡度 </strong>定义即为，该节点左子树的节点之和和右子树节点之和的 <strong>差的绝对值 </strong>。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。</p>\n\n<p><strong>整个树</strong> 的坡度就是其所有节点的坡度之和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt1.jpg\" style=\"width: 712px; height: 182px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n节点 2 的坡度：|0-0| = 0（没有子节点）\n节点 3 的坡度：|0-0| = 0（没有子节点）\n节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）\n坡度总和：0 + 0 + 1 = 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt2.jpg\" style=\"width: 800px; height: 203px;\" />\n<pre>\n<strong>输入：</strong>root = [4,2,9,3,5,null,7]\n<strong>输出：</strong>15\n<strong>解释：</strong>\n节点 3 的坡度：|0-0| = 0（没有子节点）\n节点 5 的坡度：|0-0| = 0（没有子节点）\n节点 7 的坡度：|0-0| = 0（没有子节点）\n节点 2 的坡度：|3-5| = 2（左子树就是左子节点，所以和是 3 ；右子树就是右子节点，所以和是 5 ）\n节点 9 的坡度：|0-7| = 7（没有左子树，所以和是 0 ；右子树正好是右子节点，所以和是 7 ）\n节点 4 的坡度：|(3+5+2)-(9+7)| = |10-16| = 6（左子树值为 3、5 和 2 ，和是 10 ；右子树值为 9 和 7 ，和是 16 ）\n坡度总和：0 + 0 + 0 + 2 + 7 + 6 = 15\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt3.jpg\" style=\"width: 800px; height: 293px;\" />\n<pre>\n<strong>输入：</strong>root = [21,7,14,1,1,2,2,3,3]\n<strong>输出：</strong>9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目的范围在 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 564.寻找最近的回文数",
        "hardRate": "HARD",
        "passRate": "30.41%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-closest-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-closest-palindrome/solution",
        "problemsDesc": "<p>给定一个表示整数的字符串&nbsp;<code>n</code> ，返回与它最近的回文整数（不包括自身）。如果不止一个，返回较小的那个。</p>\n\n<p>“最近的”定义为两个整数<strong>差的绝对值</strong>最小。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = \"123\"\n<strong>输出:</strong> \"121\"\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = \"1\"\n<strong>输出:</strong> \"0\"\n<strong>解释:</strong> 0 和 2是最近的回文，但我们返回最小的，也就是 0。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n.length &lt;= 18</code></li>\n\t<li><code>n</code>&nbsp;只由数字组成</li>\n\t<li><code>n</code>&nbsp;不含前导 0</li>\n\t<li><code>n</code>&nbsp;代表在&nbsp;<code>[1, 10<sup>18</sup>&nbsp;- 1]</code> 范围内的整数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 565.数组嵌套",
        "hardRate": "MEDIUM",
        "passRate": "62.38%",
        "problemsUrl": "https://leetcode.cn/problems/array-nesting/",
        "solutionsUrl": "https://leetcode.cn/problems/array-nesting/solution",
        "problemsDesc": "<p>索引从<code>0</code>开始长度为<code>N</code>的数组<code>A</code>，包含<code>0</code>到<code>N - 1</code>的所有整数。找到最大的集合<code>S</code>并返回其大小，其中 <code>S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }</code>且遵守以下的规则。</p>\n\n<p>假设选择索引为<code>i</code>的元素<code>A[i]</code>为<code>S</code>的第一个元素，<code>S</code>的下一个元素应该是<code>A[A[i]]</code>，之后是<code>A[A[A[i]]]...</code> 以此类推，不断添加直到<code>S</code>出现重复的元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> A = [5,4,0,3,1,6,2]\n<strong>输出:</strong> 4\n<strong>解释:</strong> \nA[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.\n\n其中一种最长的 S[K]:\nS[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt; nums.length</code></li>\n\t<li><code>A</code>中不含有重复的元素。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 566.重塑矩阵",
        "hardRate": "EASY",
        "passRate": "64.80%",
        "problemsUrl": "https://leetcode.cn/problems/reshape-the-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/reshape-the-matrix/solution",
        "problemsDesc": "<p>在 MATLAB 中，有一个非常有用的函数 <code>reshape</code> ，它可以将一个&nbsp;<code>m x n</code> 矩阵重塑为另一个大小不同（<code>r x c</code>）的新矩阵，但保留其原始数据。</p>\n\n<p>给你一个由二维数组 <code>mat</code> 表示的&nbsp;<code>m x n</code> 矩阵，以及两个正整数 <code>r</code> 和 <code>c</code> ，分别表示想要的重构的矩阵的行数和列数。</p>\n\n<p>重构后的矩阵需要将原始矩阵的所有元素以相同的<strong> 行遍历顺序 </strong>填充。</p>\n\n<p>如果具有给定参数的 <code>reshape</code> 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/24/reshape1-grid.jpg\" style=\"width: 613px; height: 173px;\" />\n<pre>\n<strong>输入：</strong>mat = [[1,2],[3,4]], r = 1, c = 4\n<strong>输出：</strong>[[1,2,3,4]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg\" style=\"width: 453px; height: 173px;\" />\n<pre>\n<strong>输入：</strong>mat = [[1,2],[3,4]], r = 2, c = 4\n<strong>输出：</strong>[[1,2],[3,4]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>-1000 &lt;= mat[i][j] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= r, c &lt;= 300</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 567.字符串的排列",
        "hardRate": "MEDIUM",
        "passRate": "44.49%",
        "problemsUrl": "https://leetcode.cn/problems/permutation-in-string/",
        "solutionsUrl": "https://leetcode.cn/problems/permutation-in-string/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>s1</code>&nbsp;和&nbsp;<code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code><strong>&nbsp;</strong>的排列。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 <strong>子串</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"ab\" s2 = \"eidbaooo\"\n<strong>输出：</strong>true\n<strong>解释：</strong>s2 包含 s1 的排列之一 (\"ba\").\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1= \"ab\" s2 = \"eidboaoo\"\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s1</code> 和 <code>s2</code> 仅包含小写字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 568.最大休假天数",
        "hardRate": "HARD",
        "passRate": "53.84%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-vacation-days/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-vacation-days/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 569.员工薪水中位数",
        "hardRate": "HARD",
        "passRate": "57.40%",
        "problemsUrl": "https://leetcode.cn/problems/median-employee-salary/",
        "solutionsUrl": "https://leetcode.cn/problems/median-employee-salary/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 570.至少有5名直接下属的经理",
        "hardRate": "MEDIUM",
        "passRate": "64.87%",
        "problemsUrl": "https://leetcode.cn/problems/managers-with-at-least-5-direct-reports/",
        "solutionsUrl": "https://leetcode.cn/problems/managers-with-at-least-5-direct-reports/solution",
        "problemsDesc": "<p>表:&nbsp;<code>Employee</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n| department  | varchar |\n| managerId   | int     |\n+-------------+---------+\nId是该表的主键列。\n该表的每一行都表示雇员的名字、他们的部门和他们的经理的id。\n如果managerId为空，则该员工没有经理。\n没有员工会成为自己的管理者。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个SQL查询，查询<strong>至少有5名直接下属</strong>的经理<strong> </strong>。</p>\n\n<p>以 <strong>任意顺序 </strong>返回结果表。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nEmployee 表:\n+-----+-------+------------+-----------+\n| id  | name  | department | managerId |\n+-----+-------+------------+-----------+\n| 101 | John  | A          | None      |\n| 102 | Dan   | A          | 101       |\n| 103 | James | A          | 101       |\n| 104 | Amy   | A          | 101       |\n| 105 | Anne  | A          | 101       |\n| 106 | Ron   | B          | 101       |\n+-----+-------+------------+-----------+\n<strong>输出:</strong> \n+------+\n| name |\n+------+\n| John |\n+------+</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 571.给定数字的频率查询中位数",
        "hardRate": "HARD",
        "passRate": "47.07%",
        "problemsUrl": "https://leetcode.cn/problems/find-median-given-frequency-of-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/find-median-given-frequency-of-numbers/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 572.另一棵树的子树",
        "hardRate": "EASY",
        "passRate": "47.48%",
        "problemsUrl": "https://leetcode.cn/problems/subtree-of-another-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/subtree-of-another-tree/solution",
        "problemsDesc": "<div class=\"original__bRMd\">\n<div>\n<p>给你两棵二叉树 <code>root</code> 和 <code>subRoot</code> 。检验 <code>root</code> 中是否包含和 <code>subRoot</code> 具有相同结构和节点值的子树。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>二叉树 <code>tree</code> 的一棵子树包括 <code>tree</code> 的某个节点和这个节点的所有后代节点。<code>tree</code> 也可以看做它自身的一棵子树。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg\" style=\"width: 532px; height: 400px;\" />\n<pre>\n<strong>输入：</strong>root = [3,4,5,1,2], subRoot = [4,1,2]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/28/subtree2-tree.jpg\" style=\"width: 502px; height: 458px;\" />\n<pre>\n<strong>输入：</strong>root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>root</code> 树上的节点数量范围是 <code>[1, 2000]</code></li>\n\t<li><code>subRoot</code> 树上的节点数量范围是 <code>[1, 1000]</code></li>\n\t<li><code>-10<sup>4</sup> <= root.val <= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= subRoot.val <= 10<sup>4</sup></code></li>\n</ul>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 573.松鼠模拟",
        "hardRate": "MEDIUM",
        "passRate": "65.44%",
        "problemsUrl": "https://leetcode.cn/problems/squirrel-simulation/",
        "solutionsUrl": "https://leetcode.cn/problems/squirrel-simulation/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 574.当选者",
        "hardRate": "MEDIUM",
        "passRate": "66.36%",
        "problemsUrl": "https://leetcode.cn/problems/winning-candidate/",
        "solutionsUrl": "https://leetcode.cn/problems/winning-candidate/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 575.分糖果",
        "hardRate": "EASY",
        "passRate": "70.45%",
        "problemsUrl": "https://leetcode.cn/problems/distribute-candies/",
        "solutionsUrl": "https://leetcode.cn/problems/distribute-candies/solution",
        "problemsDesc": "<p>Alice 有 <code>n</code> 枚糖，其中第 <code>i</code> 枚糖的类型为 <code>candyType[i]</code> 。Alice 注意到她的体重正在增长，所以前去拜访了一位医生。</p>\n\n<p>医生建议 Alice 要少摄入糖分，只吃掉她所有糖的 <code>n / 2</code> 即可（<code>n</code> 是一个偶数）。Alice 非常喜欢这些糖，她想要在遵循医生建议的情况下，尽可能吃到最多不同种类的糖。</p>\n\n<p>给你一个长度为 <code>n</code> 的整数数组 <code>candyType</code> ，返回： Alice <em>在仅吃掉 <code>n / 2</code> 枚糖的情况下，可以吃到糖的 <strong>最多</strong> 种类数</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>candyType = [1,1,2,2,3,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>Alice 只能吃 6 / 2 = 3 枚糖，由于只有 3 种糖，她可以每种吃一枚。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>candyType = [1,1,2,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>Alice 只能吃 4 / 2 = 2 枚糖，不管她选择吃的种类是 [1,2]、[1,3] 还是 [2,3]，她只能吃到两种不同类的糖。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>candyType = [6,6,6,6]\n<strong>输出：</strong>1\n<strong>解释：</strong>Alice 只能吃 4 / 2 = 2 枚糖，尽管她能吃 2 枚，但只能吃到 1 种糖。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == candyType.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>n</code> 是一个偶数</li>\n\t<li><code>-10<sup>5</sup> &lt;= candyType[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 576.出界的路径数",
        "hardRate": "MEDIUM",
        "passRate": "47.00%",
        "problemsUrl": "https://leetcode.cn/problems/out-of-boundary-paths/",
        "solutionsUrl": "https://leetcode.cn/problems/out-of-boundary-paths/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的网格和一个球。球的起始坐标为 <code>[startRow, startColumn]</code> 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 <strong>最多</strong> 可以移动 <code>maxMove</code> 次球。</p>\n\n<p>给你五个整数 <code>m</code>、<code>n</code>、<code>maxMove</code>、<code>startRow</code> 以及 <code>startColumn</code> ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_1.png\" style=\"width: 500px; height: 296px;\" />\n<pre>\n<strong>输入：</strong>m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_2.png\" style=\"width: 500px; height: 293px;\" />\n<pre>\n<strong>输入：</strong>m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1\n<strong>输出：</strong>12\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>0 &lt;= maxMove &lt;= 50</code></li>\n\t<li><code>0 &lt;= startRow &lt; m</code></li>\n\t<li><code>0 &lt;= startColumn &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 577.员工奖金",
        "hardRate": "EASY",
        "passRate": "69.23%",
        "problemsUrl": "https://leetcode.cn/problems/employee-bonus/",
        "solutionsUrl": "https://leetcode.cn/problems/employee-bonus/solution",
        "problemsDesc": "<p>选出所有 bonus &lt; 1000 的员工的 name 及其 bonus。</p>\n\n<p><code>Employee</code> 表单</p>\n\n<pre>+-------+--------+-----------+--------+\n| empId |  name  | supervisor| salary |\n+-------+--------+-----------+--------+\n|   1   | John   |  3        | 1000   |\n|   2   | Dan    |  3        | 2000   |\n|   3   | Brad   |  null     | 4000   |\n|   4   | Thomas |  3        | 4000   |\n+-------+--------+-----------+--------+\nempId 是这张表单的主关键字\n</pre>\n\n<p><code>Bonus</code> 表单</p>\n\n<pre>+-------+-------+\n| empId | bonus |\n+-------+-------+\n| 2     | 500   |\n| 4     | 2000  |\n+-------+-------+\nempId 是这张表单的主关键字\n</pre>\n\n<p>输出示例：</p>\n\n<pre>+-------+-------+\n| name  | bonus |\n+-------+-------+\n| John  | null  |\n| Dan   | 500   |\n| Brad  | null  |\n+-------+-------+\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 578.查询回答率最高的问题",
        "hardRate": "MEDIUM",
        "passRate": "42.31%",
        "problemsUrl": "https://leetcode.cn/problems/get-highest-answer-rate-question/",
        "solutionsUrl": "https://leetcode.cn/problems/get-highest-answer-rate-question/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 579.查询员工的累计薪水",
        "hardRate": "HARD",
        "passRate": "44.18%",
        "problemsUrl": "https://leetcode.cn/problems/find-cumulative-salary-of-an-employee/",
        "solutionsUrl": "https://leetcode.cn/problems/find-cumulative-salary-of-an-employee/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 580.统计各专业学生人数",
        "hardRate": "MEDIUM",
        "passRate": "53.62%",
        "problemsUrl": "https://leetcode.cn/problems/count-student-number-in-departments/",
        "solutionsUrl": "https://leetcode.cn/problems/count-student-number-in-departments/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 581.最短无序连续子数组",
        "hardRate": "MEDIUM",
        "passRate": "41.79%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，你需要找出一个 <strong>连续子数组</strong> ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>\n\n<p>请你找出符合题意的 <strong>最短</strong> 子数组，并输出它的长度。</p>\n\n<p> </p>\n\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,6,4,8,10,9,15]\n<strong>输出：</strong>5\n<strong>解释：</strong>你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1]\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>5</sup> <= nums[i] <= 10<sup>5</sup></code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(n)</code> 的解决方案吗？</p>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 582.杀掉进程",
        "hardRate": "MEDIUM",
        "passRate": "45.93%",
        "problemsUrl": "https://leetcode.cn/problems/kill-process/",
        "solutionsUrl": "https://leetcode.cn/problems/kill-process/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 583.两个字符串的删除操作",
        "hardRate": "MEDIUM",
        "passRate": "66.65%",
        "problemsUrl": "https://leetcode.cn/problems/delete-operation-for-two-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-operation-for-two-strings/solution",
        "problemsDesc": "<p>给定两个单词&nbsp;<code>word1</code>&nbsp;和<meta charset=\"UTF-8\" />&nbsp;<code>word2</code>&nbsp;，返回使得<meta charset=\"UTF-8\" />&nbsp;<code>word1</code>&nbsp;和&nbsp;<meta charset=\"UTF-8\" />&nbsp;<code>word2</code><em>&nbsp;</em><strong>相同</strong>所需的<strong>最小步数</strong>。</p>\n\n<p><strong>每步&nbsp;</strong>可以删除任意一个字符串中的一个字符。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> word1 = \"sea\", word2 = \"eat\"\n<strong>输出:</strong> 2\n<strong>解释:</strong> 第一步将 \"sea\" 变为 \"ea\" ，第二步将 \"eat \"变为 \"ea\"\n</pre>\n\n<p><strong>示例 &nbsp;2:</strong></p>\n\n<pre>\n<b>输入：</b>word1 = \"leetcode\", word2 = \"etco\"\n<b>输出：</b>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>1 &lt;= word1.length, word2.length &lt;= 500</code></li>\n\t<li><code>word1</code>&nbsp;和&nbsp;<code>word2</code>&nbsp;只包含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 584.寻找用户推荐人",
        "hardRate": "EASY",
        "passRate": "65.40%",
        "problemsUrl": "https://leetcode.cn/problems/find-customer-referee/",
        "solutionsUrl": "https://leetcode.cn/problems/find-customer-referee/solution",
        "problemsDesc": "<p>给定表 <code>customer</code> ，里面保存了所有客户信息和他们的推荐人。</p>\n\n<pre>\n+------+------+-----------+\n| id   | name | referee_id|\n+------+------+-----------+\n|    1 | Will |      NULL |\n|    2 | Jane |      NULL |\n|    3 | Alex |         2 |\n|    4 | Bill |      NULL |\n|    5 | Zack |         1 |\n|    6 | Mark |         2 |\n+------+------+-----------+\n</pre>\n\n<p>写一个查询语句，返回一个客户列表，列表中客户的推荐人的编号都 <strong>不是 </strong>2。</p>\n\n<p>对于上面的示例数据，结果为：</p>\n\n<pre>\n+------+\n| name |\n+------+\n| Will |\n| Jane |\n| Bill |\n| Zack |\n+------+\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 585.2016年的投资",
        "hardRate": "MEDIUM",
        "passRate": "47.63%",
        "problemsUrl": "https://leetcode.cn/problems/investments-in-2016/",
        "solutionsUrl": "https://leetcode.cn/problems/investments-in-2016/solution",
        "problemsDesc": "<p><code>Insurance</code> 表：</p>\n\n<div class=\"original__bRMd\">\n<div>\n<pre>\n+-------------+-------+\n| Column Name | Type  |\n+-------------+-------+\n| pid         | int   |\n| tiv_2015    | float |\n| tiv_2016    | float |\n| lat         | float |\n| lon         | float |\n+-------------+-------+\npid 是这张表的主键。\n表中的每一行都包含一条保险信息，其中：\npid 是投保人的投保编号。\ntiv_2015 是该投保人在 2015 年的总投保金额，tiv_2016 是该投保人在 2016 年的总投保金额。\nlat 是投保人所在城市的纬度。题目数据确保 lat 不为空。\nlon 是投保人所在城市的经度。题目数据确保 lon 不为空。</pre>\n\n<p>&nbsp;</p>\n\n<p>请你编写一个 SQL 查询，报告 2016 年 (<code>tiv_2016</code>) 所有满足下述条件的投保人的投保金额之和：</p>\n\n<ul>\n\t<li>他在 2015 年的投保额&nbsp;(<code>tiv_2015</code>) 至少跟一个其他投保人在 2015 年的投保额相同。</li>\n\t<li>他所在的城市必须与其他投保人都不同（也就是说&nbsp;(<code>lat, lon</code>) 不能跟其他任何一个投保人完全相同）。</li>\n</ul>\n\n<p><code>tiv_2016</code> 四舍五入的 <strong>两位小数</strong> 。</p>\n\n<p>查询结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nInsurance 表：\n+-----+----------+----------+-----+-----+\n| pid | tiv_2015 | tiv_2016 | lat | lon |\n+-----+----------+----------+-----+-----+\n| 1   | 10       | 5        | 10  | 10  |\n| 2   | 20       | 20       | 20  | 20  |\n| 3   | 10       | 30       | 20  | 20  |\n| 4   | 10       | 40       | 40  | 40  |\n+-----+----------+----------+-----+-----+\n<strong>输出：</strong>\n+----------+\n| tiv_2016 |\n+----------+\n| 45.00    |\n+----------+\n<strong>解释：\n</strong>表中的第一条记录和最后一条记录都满足两个条件。\ntiv_2015 值为 10 与第三条和第四条记录相同，且其位置是唯一的。\n第二条记录不符合任何一个条件。其 tiv_2015 与其他投保人不同，并且位置与第三条记录相同，这也导致了第三条记录不符合题目要求。\n因此，结果是第一条记录和最后一条记录的 tiv_2016 之和，即 45 。</pre>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 586.订单最多的客户",
        "hardRate": "EASY",
        "passRate": "69.44%",
        "problemsUrl": "https://leetcode.cn/problems/customer-placing-the-largest-number-of-orders/",
        "solutionsUrl": "https://leetcode.cn/problems/customer-placing-the-largest-number-of-orders/solution",
        "problemsDesc": "<p>表:&nbsp;<code>Orders</code></p>\n\n<pre>\n+-----------------+----------+\n| Column Name     | Type     |\n+-----------------+----------+\n| order_number    | int      |\n| customer_number | int      |\n+-----------------+----------+\nOrder_number是该表的主键。\n此表包含关于订单ID和客户ID的信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个SQL查询，为下了 <strong>最多订单</strong> 的客户查找 <code>customer_number</code> 。</p>\n\n<p>测试用例生成后， <strong>恰好有一个客户</strong> 比任何其他客户下了更多的订单。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nOrders 表:\n+--------------+-----------------+\n| order_number | customer_number |\n+--------------+-----------------+\n| 1            | 1               |\n| 2            | 2               |\n| 3            | 3               |\n| 4            | 3               |\n+--------------+-----------------+\n<strong>输出:</strong> \n+-----------------+\n| customer_number |\n+-----------------+\n| 3               |\n+-----------------+\n<strong>解释:</strong> \ncustomer_number 为 '3' 的顾客有两个订单，比顾客 '1' 或者 '2' 都要多，因为他们只有一个订单。\n所以结果是该顾客的 customer_number ，也就是 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong> 如果有多位顾客订单数并列最多，你能找到他们所有的 <code>customer_number</code> 吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 587.安装栅栏",
        "hardRate": "HARD",
        "passRate": "60.84%",
        "problemsUrl": "https://leetcode.cn/problems/erect-the-fence/",
        "solutionsUrl": "https://leetcode.cn/problems/erect-the-fence/solution",
        "problemsDesc": "<p>给定一个数组 <code>trees</code>，其中 <code>trees[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示树在花园中的位置。</p>\n\n<p>你被要求用最短长度的绳子把整个花园围起来，因为绳子很贵。只有把&nbsp;<strong>所有的树都围起来</strong>，花园才围得很好。</p>\n\n<p>返回<em>恰好位于围栏周边的树木的坐标</em>。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/24/erect2-plane.jpg\" style=\"width: 400px;\" /></p>\n\n<pre>\n<strong>输入:</strong> points = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\n<strong>输出:</strong> [[1,1],[2,0],[3,3],[2,4],[4,2]]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/24/erect1-plane.jpg\" style=\"height: 393px; width: 400px;\" /></p>\n\n<pre>\n<strong>输入:</strong> points = [[1,2],[2,2],[4,2]]\n<strong>输出:</strong> [[4,2],[2,2],[1,2]]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>注意:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= points.length &lt;= 3000</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= 100</code></li>\n\t<li>\n\t<p data-group=\"1-1\">所有给定的点都是&nbsp;<strong>唯一&nbsp;</strong>的。</p>\n\t</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 588.设计内存文件系统",
        "hardRate": "HARD",
        "passRate": "43.48%",
        "problemsUrl": "https://leetcode.cn/problems/design-in-memory-file-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-in-memory-file-system/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 589.N 叉树的前序遍历",
        "hardRate": "EASY",
        "passRate": "76.55%",
        "problemsUrl": "https://leetcode.cn/problems/n-ary-tree-preorder-traversal/",
        "solutionsUrl": "https://leetcode.cn/problems/n-ary-tree-preorder-traversal/solution",
        "problemsDesc": "<p>给定一个 n&nbsp;叉树的根节点 <meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;，返回 <em>其节点值的<strong> 前序遍历</strong></em> 。</p>\n\n<p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p>\n\n<p><br />\n<strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"height: 193px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,null,3,2,4,null,5,6]\n<strong>输出：</strong>[1,3,5,6,2,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"height: 272px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>输出：</strong>[1,2,3,6,7,11,14,4,8,12,5,9,13,10]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>节点总数在范围<meta charset=\"UTF-8\" />&nbsp;<code>[0, 10<sup>4</sup>]</code>内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>n 叉树的高度小于或等于 <code>1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>递归法很简单，你可以使用迭代法完成此题吗?</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 590.N 叉树的后序遍历",
        "hardRate": "EASY",
        "passRate": "78.68%",
        "problemsUrl": "https://leetcode.cn/problems/n-ary-tree-postorder-traversal/",
        "solutionsUrl": "https://leetcode.cn/problems/n-ary-tree-postorder-traversal/solution",
        "problemsDesc": "<p>给定一个 n&nbsp;叉树的根节点<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;，返回 <em>其节点值的<strong> 后序遍历</strong></em> 。</p>\n\n<p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"height: 193px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,null,3,2,4,null,5,6]\n<strong>输出：</strong>[5,6,3,2,4,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"height: 269px; width: 296px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>输出：</strong>[2,6,14,11,7,3,12,8,4,13,9,10,5,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>节点总数在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>n 叉树的高度小于或等于 <code>1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>递归法很简单，你可以使用迭代法完成此题吗?</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 591.标签验证器",
        "hardRate": "HARD",
        "passRate": "52.06%",
        "problemsUrl": "https://leetcode.cn/problems/tag-validator/",
        "solutionsUrl": "https://leetcode.cn/problems/tag-validator/solution",
        "problemsDesc": "<p>给定一个表示代码片段的字符串，你需要实现一个验证器来解析这段代码，并返回它是否合法。合法的代码片段需要遵守以下的所有规则：</p>\n\n<ol>\n\t<li>代码必须被<strong>合法的闭合标签</strong>包围。否则，代码是无效的。</li>\n\t<li><strong>闭合标签</strong>（不一定合法）要严格符合格式：<code>&lt;TAG_NAME&gt;TAG_CONTENT&lt;/TAG_NAME&gt;</code>。其中，<code>&lt;TAG_NAME&gt;</code>是起始标签，<code>&lt;/TAG_NAME&gt;</code>是结束标签。起始和结束标签中的 TAG_NAME 应当相同。当且仅当&nbsp;TAG_NAME 和 TAG_CONTENT 都是合法的，闭合标签才是<strong>合法的</strong>。</li>\n\t<li><strong>合法的</strong>&nbsp;<code>TAG_NAME</code>&nbsp;仅含有<strong>大写字母</strong>，长度在范围 [1,9] 之间。否则，该&nbsp;<code>TAG_NAME</code>&nbsp;是<strong>不合法的</strong>。</li>\n\t<li><strong>合法的</strong>&nbsp;<code>TAG_CONTENT</code>&nbsp;可以包含其他<strong>合法的闭合标签</strong>，<strong>cdata</strong>&nbsp;（请参考规则7）和任意字符（注意参考规则1）<strong>除了</strong>不匹配的<code>&lt;</code>、不匹配的起始和结束标签、不匹配的或带有不合法 TAG_NAME 的闭合标签。否则，<code>TAG_CONTENT</code>&nbsp;是<strong>不合法的</strong>。</li>\n\t<li>一个起始标签，如果没有具有相同&nbsp;TAG_NAME 的结束标签与之匹配，是不合法的。反之亦然。不过，你也需要考虑标签嵌套的问题。</li>\n\t<li>一个<code>&lt;</code>，如果你找不到一个后续的<code>&gt;</code>与之匹配，是不合法的。并且当你找到一个<code>&lt;</code>或<code>&lt;/</code>时，所有直到下一个<code>&gt;</code>的前的字符，都应当被解析为&nbsp;TAG_NAME（不一定合法）。</li>\n\t<li>cdata 有如下格式：<code>&lt;![CDATA[CDATA_CONTENT]]&gt;</code>。<code>CDATA_CONTENT</code>&nbsp;的范围被定义成&nbsp;<code>&lt;![CDATA[</code>&nbsp;和<strong>后续的第一个</strong>&nbsp;<code>]]&gt;</code>之间的字符。</li>\n\t<li><code>CDATA_CONTENT</code>&nbsp;可以包含<strong>任意字符</strong>。cdata 的功能是阻止验证器解析<code>CDATA_CONTENT</code>，所以即使其中有一些字符可以被解析为标签（无论合法还是不合法），也应该将它们视为<strong>常规字符</strong>。</li>\n</ol>\n\n<p><strong>合法代码的例子:</strong></p>\n\n<pre>\n<strong>输入:</strong> &quot;&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt;]]&gt;&lt;/DIV&gt;&quot;\n\n<strong>输出:</strong> True\n\n<strong>解释:</strong> \n\n代码被包含在了闭合的标签内： &lt;DIV&gt; 和 &lt;/DIV&gt; 。\n\nTAG_NAME 是合法的，TAG_CONTENT 包含了一些字符和 cdata 。 \n\n即使 CDATA_CONTENT 含有不匹配的起始标签和不合法的 TAG_NAME，它应该被视为普通的文本，而不是标签。\n\n所以 TAG_CONTENT 是合法的，因此代码是合法的。最终返回True。\n\n\n<strong>输入:</strong> &quot;&lt;DIV&gt;&gt;&gt;  ![cdata[]] &lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&gt;]&lt;/DIV&gt;&quot;\n\n<strong>输出:</strong> True\n\n<strong>解释:</strong>\n\n我们首先将代码分割为： start_tag|tag_content|end_tag 。\n\nstart_tag -&gt; <strong>&quot;&lt;DIV&gt;&quot;</strong>\n\nend_tag -&gt; <strong>&quot;&lt;/DIV&gt;&quot;</strong>\n\ntag_content 也可被分割为： text1|cdata|text2 。\n\ntext1 -&gt; <strong>&quot;&gt;&gt;  ![cdata[]] &quot;</strong>\n\ncdata -&gt; <strong>&quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;&quot;</strong> ，其中 CDATA_CONTENT 为 <strong>&quot;&lt;div&gt;]&gt;&quot;</strong>\n\ntext2 -&gt; <strong>&quot;]]&gt;&gt;]&quot;</strong>\n\n\nstart_tag <strong>不</strong>是 <strong>&quot;&lt;DIV&gt;&gt;&gt;&quot;</strong> 的原因参照规则 6 。\ncdata <strong>不</strong>是 <strong>&quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&quot;</strong> 的原因参照规则 7 。\n</pre>\n\n<p><strong>不合法代码的例子:</strong></p>\n\n<pre>\n<strong>输入:</strong> &quot;&lt;A&gt;  &lt;B&gt; &lt;/A&gt;   &lt;/B&gt;&quot;\n<strong>输出:</strong> False\n<strong>解释:</strong> 不合法。如果 &quot;&lt;A&gt;&quot; 是闭合的，那么 &quot;&lt;B&gt;&quot; 一定是不匹配的，反之亦然。\n\n<strong>输入:</strong> &quot;&lt;DIV&gt;  div tag is not closed  &lt;DIV&gt;&quot;\n<strong>输出:</strong> False\n\n<strong>输入:</strong> &quot;&lt;DIV&gt;  unmatched &lt;  &lt;/DIV&gt;&quot;\n<strong>输出:</strong> False\n\n<strong>输入:</strong> &quot;&lt;DIV&gt; closed tags with invalid tag name  &lt;b&gt;123&lt;/b&gt; &lt;/DIV&gt;&quot;\n<strong>输出:</strong> False\n\n<strong>输入:</strong> &quot;&lt;DIV&gt; unmatched tags with invalid tag name  &lt;/1234567890&gt; and &lt;CDATA[[]]&gt;  &lt;/DIV&gt;&quot;\n<strong>输出:</strong> False\n\n<strong>输入:</strong> &quot;&lt;DIV&gt;  unmatched start tag &lt;B&gt;  and unmatched end tag &lt;/C&gt;  &lt;/DIV&gt;&quot;\n<strong>输出:</strong> False\n</pre>\n\n<p><strong>注意:</strong></p>\n\n<ol>\n\t<li>为简明起见，你可以假设输入的代码（包括提到的<strong>任意字符</strong>）只包含<code>数字</code>, <font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"background-color:#f9f2f4; font-size:12.6px\">字母</span></font>, <code>&#39;&lt;&#39;</code>,<code>&#39;&gt;&#39;</code>,<code>&#39;/&#39;</code>,<code>&#39;!&#39;</code>,<code>&#39;[&#39;</code>,<code>&#39;]&#39;</code>和<code>&#39; &#39;</code>。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 592.分数加减运算",
        "hardRate": "MEDIUM",
        "passRate": "59.76%",
        "problemsUrl": "https://leetcode.cn/problems/fraction-addition-and-subtraction/",
        "solutionsUrl": "https://leetcode.cn/problems/fraction-addition-and-subtraction/solution",
        "problemsDesc": "<p>给定一个表示分数加减运算的字符串&nbsp;<code>expression</code>&nbsp;，你需要返回一个字符串形式的计算结果。&nbsp;</p>\n\n<p>这个结果应该是不可约分的分数，即<a href=\"https://baike.baidu.com/item/%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0\" target=\"_blank\">最简分数</a>。&nbsp;如果最终结果是一个整数，例如&nbsp;<code>2</code>，你需要将它转换成分数形式，其分母为&nbsp;<code>1</code>。所以在上述例子中, <code>2</code>&nbsp;应该被转换为&nbsp;<code>2/1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;<code>expression</code>&nbsp;= \"-1/2+1/2\"\n<strong>输出:</strong> \"0/1\"\n</pre>\n\n<p><strong>&nbsp;示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;<code>expression</code>&nbsp;= \"-1/2+1/2+1/3\"\n<strong>输出:</strong> \"1/3\"\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;<code>expression</code>&nbsp;= \"1/3-1/2\"\n<strong>输出:</strong> \"-1/6\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>输入和输出字符串只包含&nbsp;<code>'0'</code> 到&nbsp;<code>'9'</code>&nbsp;的数字，以及&nbsp;<code>'/'</code>, <code>'+'</code> 和&nbsp;<code>'-'</code>。&nbsp;</li>\n\t<li>输入和输出分数格式均为&nbsp;<code>±分子/分母</code>。如果输入的第一个分数或者输出的分数是正数，则&nbsp;<code>'+'</code>&nbsp;会被省略掉。</li>\n\t<li>输入只包含合法的<strong>最简分数</strong>，每个分数的<strong>分子</strong>与<strong>分母</strong>的范围是&nbsp;&nbsp;[1,10]。&nbsp;如果分母是1，意味着这个分数实际上是一个整数。</li>\n\t<li>输入的分数个数范围是 [1,10]。</li>\n\t<li><strong>最终结果</strong>的分子与分母保证是 32 位整数范围内的有效整数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 593.有效的正方形",
        "hardRate": "MEDIUM",
        "passRate": "47.11%",
        "problemsUrl": "https://leetcode.cn/problems/valid-square/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-square/solution",
        "problemsDesc": "<p>给定2D空间中四个点的坐标&nbsp;<code>p1</code>,&nbsp;<code>p2</code>,&nbsp;<code>p3</code>&nbsp;和&nbsp;<code>p4</code>，如果这四个点构成一个正方形，则返回 <code>true</code> 。</p>\n\n<p>点的坐标&nbsp;<code>p<sub>i</sub></code> 表示为 <code>[xi, yi]</code> 。 <code>输入没有任何顺序</code> 。</p>\n\n<p>一个 <strong>有效的正方形</strong> 有四条等边和四个等角(90度角)。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]\n<strong>输出:</strong> True\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入：</strong>p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]\n<b>输出：</b>false\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<b>输入：</b>p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]\n<b>输出：</b>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>p1.length == p2.length == p3.length == p4.length == 2</code></li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 594.最长和谐子序列",
        "hardRate": "EASY",
        "passRate": "56.12%",
        "problemsUrl": "https://leetcode.cn/problems/longest-harmonious-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-harmonious-subsequence/solution",
        "problemsDesc": "<p>和谐数组是指一个数组里元素的最大值和最小值之间的差别 <strong>正好是 <code>1</code></strong> 。</p>\n\n<p>现在，给你一个整数数组 <code>nums</code> ，请你在所有可能的子序列中找到最长的和谐子序列的长度。</p>\n\n<p>数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,2,2,5,2,3,7]\n<strong>输出：</strong>5\n<strong>解释：</strong>最长的和谐子序列是 [3,2,2,2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,1]\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 2 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 595.大的国家",
        "hardRate": "EASY",
        "passRate": "66.81%",
        "problemsUrl": "https://leetcode.cn/problems/big-countries/",
        "solutionsUrl": "https://leetcode.cn/problems/big-countries/solution",
        "problemsDesc": "<p><code>World</code> 表：</p>\n\n<div class=\"top-view__1vxA\">\n<div class=\"original__bRMd\">\n<div>\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| name        | varchar |\n| continent   | varchar |\n| area        | int     |\n| population  | int     |\n| gdp         | bigint  |\n+-------------+---------+\nname 是这张表的主键。\n这张表的每一行提供：国家名称、所属大陆、面积、人口和 GDP 值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>如果一个国家满足下述两个条件之一，则认为该国是 <strong>大国</strong> ：</p>\n\n<ul>\n\t<li>面积至少为 300 万平方公里（即，<code>3000000 km<sup>2</sup></code>），或者</li>\n\t<li>人口至少为 2500 万（即 <code>25000000</code>）</li>\n</ul>\n\n<p>编写一个 SQL 查询以报告 <strong>大国</strong> 的国家名称、人口和面积。</p>\n\n<p>按 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nWorld 表：\n+-------------+-----------+---------+------------+--------------+\n| name        | continent | area    | population | gdp          |\n+-------------+-----------+---------+------------+--------------+\n| Afghanistan | Asia      | 652230  | 25500100   | 20343000000  |\n| Albania     | Europe    | 28748   | 2831741    | 12960000000  |\n| Algeria     | Africa    | 2381741 | 37100000   | 188681000000 |\n| Andorra     | Europe    | 468     | 78115      | 3712000000   |\n| Angola      | Africa    | 1246700 | 20609294   | 100990000000 |\n+-------------+-----------+---------+------------+--------------+\n<strong>输出：</strong>\n+-------------+------------+---------+\n| name        | population | area    |\n+-------------+------------+---------+\n| Afghanistan | 25500100   | 652230  |\n| Algeria     | 37100000   | 2381741 |\n+-------------+------------+---------+\n</pre>\n</div>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 596.超过5名学生的课",
        "hardRate": "EASY",
        "passRate": "50.82%",
        "problemsUrl": "https://leetcode.cn/problems/classes-more-than-5-students/",
        "solutionsUrl": "https://leetcode.cn/problems/classes-more-than-5-students/solution",
        "problemsDesc": "<p>表:&nbsp;<code>Courses</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| student     | varchar |\n| class       | varchar |\n+-------------+---------+\n(student, class)是该表的主键列。\n该表的每一行表示学生的名字和他们注册的班级。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个SQL查询来报告 <strong>至少有5个学生</strong> 的所有班级。</p>\n\n<p>以 <strong>任意顺序 </strong>返回结果表。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nCourses table:\n+---------+----------+\n| student | class    |\n+---------+----------+\n| A       | Math     |\n| B       | English  |\n| C       | Math     |\n| D       | Biology  |\n| E       | Math     |\n| F       | Computer |\n| G       | Math     |\n| H       | Math     |\n| I       | Math     |\n+---------+----------+\n<strong>输出:</strong> \n+---------+ \n| class &nbsp; | \n+---------+ \n| Math &nbsp; &nbsp;| \n+---------+\n<strong>解释: </strong>\n-数学课有6个学生，所以我们包括它。\n-英语课有1名学生，所以我们不包括它。\n-生物课有1名学生，所以我们不包括它。\n-计算机课有1个学生，所以我们不包括它。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 597.好友申请 I：总体通过率",
        "hardRate": "EASY",
        "passRate": "43.21%",
        "problemsUrl": "https://leetcode.cn/problems/friend-requests-i-overall-acceptance-rate/",
        "solutionsUrl": "https://leetcode.cn/problems/friend-requests-i-overall-acceptance-rate/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 598.范围求和 II",
        "hardRate": "EASY",
        "passRate": "57.75%",
        "problemsUrl": "https://leetcode.cn/problems/range-addition-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/range-addition-ii/solution",
        "problemsDesc": "<p>给你一个 <code>m x&nbsp;n</code> 的矩阵&nbsp;<code>M</code><strong>&nbsp;</strong>，初始化时所有的 <code>0</code> 和一个操作数组 <code>op</code> ，其中 <code>ops[i] = [ai, bi]</code> 意味着当所有的 <code>0 &lt;= x &lt; ai</code> 和 <code>0 &lt;= y &lt; bi</code> 时， <code>M[x][y]</code> 应该加 1。</p>\n\n<p>在&nbsp;<em>执行完所有操作后</em>&nbsp;，计算并返回&nbsp;<em>矩阵中最大整数的个数</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/02/ex1.jpg\" style=\"height: 176px; width: 750px;\" /></p>\n\n<pre>\n<strong>输入:</strong> m = 3, n = 3，ops = [[2,2],[3,3]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]\n<strong>输出:</strong> 4\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> m = 3, n = 3, ops = []\n<strong>输出:</strong> 9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 4 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= ops.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>ops[i].length == 2</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>&nbsp;&lt;= m</code></li>\n\t<li><code>1 &lt;= b<sub>i</sub>&nbsp;&lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 599.两个列表的最小索引总和",
        "hardRate": "EASY",
        "passRate": "56.67%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-index-sum-of-two-lists/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-index-sum-of-two-lists/solution",
        "problemsDesc": "<p>假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。</p>\n\n<p>你需要帮助他们用<strong>最少的索引和</strong>找出他们<strong>共同喜爱的餐厅</strong>。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>list1 = [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]，list2 = [\"Piatti\", \"The Grill at Torrey Pines\", \"Hungry Hunter Steakhouse\", \"Shogun\"]\n<strong>输出:</strong> [\"Shogun\"]\n<strong>解释:</strong> 他们唯一共同喜爱的餐厅是“Shogun”。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong>list1 = [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]，list2 = [\"KFC\", \"Shogun\", \"Burger King\"]\n<strong>输出:</strong> [\"Shogun\"]\n<strong>解释:</strong> 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= list1.length, list2.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= list1[i].length, list2[i].length &lt;= 30</code>&nbsp;</li>\n\t<li><code>list1[i]</code> 和 <code>list2[i]</code> 由空格<meta charset=\"UTF-8\" />&nbsp;<code>' '</code>&nbsp;和英文字母组成。</li>\n\t<li><code>list1</code> 的所有字符串都是 <strong>唯一</strong> 的。</li>\n\t<li><code>list2</code> 中的所有字符串都是 <strong>唯一</strong> 的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 600.不含连续1的非负整数",
        "hardRate": "HARD",
        "passRate": "49.52%",
        "problemsUrl": "https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/",
        "solutionsUrl": "https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/solution",
        "problemsDesc": "<p>给定一个正整数 <code>n</code> ，请你统计在&nbsp;<code>[0, n]</code> 范围的非负整数中，有多少个整数的二进制表示中不存在 <strong>连续的 1 </strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 5\n<strong>输出:</strong> 5\n<strong>解释:</strong> \n下面列出范围在 [0, 5] 的非负整数与其对应的二进制表示：\n0 : 0\n1 : 1\n2 : 10\n3 : 11\n4 : 100\n5 : 101\n其中，只有整数 3 违反规则（有两个连续的 1 ），其他 5 个满足规则。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 1\n<strong>输出:</strong> 2\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 2\n<strong>输出:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    }
]