[
    {
        "problemsName": " 1501可以放心投资的国家",
        "hardRate": "MEDIUM",
        "passRate": "58.46%",
        "problemsUrl": "https://leetcode.cn/problems/countries-you-can-safely-invest-in/",
        "solutionsUrl": "https://leetcode.cn/problems/countries-you-can-safely-invest-in/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1502判断能否形成等差数列",
        "hardRate": "EASY",
        "passRate": "69.42%",
        "problemsUrl": "https://leetcode.cn/problems/can-make-arithmetic-progression-from-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/can-make-arithmetic-progression-from-sequence/solution",
        "problemsDesc": "<p>给你一个数字数组 <code>arr</code> 。</p>\n\n<p>如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数列就称为 <strong>等差数列</strong> 。</p>\n\n<p>如果可以重新排列数组形成等差数列，请返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,5,1]\n<strong>输出：</strong>true\n<strong>解释：</strong>对数组重新排序得到 [1,3,5] 或者 [5,3,1] ，任意相邻两项的差分别为 2 或 -2 ，可以形成等差数列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,4]\n<strong>输出：</strong>false\n<strong>解释：</strong>无法通过重新排序得到等差数列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>-10^6 &lt;= arr[i] &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1503所有蚂蚁掉下来前的最后一刻",
        "hardRate": "MEDIUM",
        "passRate": "53.75%",
        "problemsUrl": "https://leetcode.cn/problems/last-moment-before-all-ants-fall-out-of-a-plank/",
        "solutionsUrl": "https://leetcode.cn/problems/last-moment-before-all-ants-fall-out-of-a-plank/solution",
        "problemsDesc": "<p>有一块木板，长度为 <code>n</code> 个 <strong>单位</strong> 。一些蚂蚁在木板上移动，每只蚂蚁都以 <strong>每秒一个单位</strong> 的速度移动。其中，一部分蚂蚁向 <strong>左</strong> 移动，其他蚂蚁向 <strong>右</strong> 移动。</p>\n\n<p>当两只向 <strong>不同</strong> 方向移动的蚂蚁在某个点相遇时，它们会同时改变移动方向并继续移动。假设更改方向不会花费任何额外时间。</p>\n\n<p>而当蚂蚁在某一时刻 <code>t</code> 到达木板的一端时，它立即从木板上掉下来。</p>\n\n<p>给你一个整数 <code>n</code> 和两个整数数组 <code>left</code> 以及 <code>right</code> 。两个数组分别标识向左或者向右移动的蚂蚁在 <code>t = 0</code> 时的位置。请你返回最后一只蚂蚁从木板上掉下来的时刻。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/06/17/ants.jpg\" style=\"height: 610px; width: 450px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 4, left = [4,3], right = [0,1]\n<strong>输出：</strong>4\n<strong>解释：</strong>如上图所示：\n-下标 0 处的蚂蚁命名为 A 并向右移动。\n-下标 1 处的蚂蚁命名为 B 并向右移动。\n-下标 3 处的蚂蚁命名为 C 并向左移动。\n-下标 4 处的蚂蚁命名为 D 并向左移动。\n请注意，蚂蚁在木板上的最后时刻是 t = 4 秒，之后蚂蚁立即从木板上掉下来。（也就是说在 t = 4.0000000001 时，木板上没有蚂蚁）。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/06/17/ants2.jpg\" style=\"height: 101px; width: 639px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 7, left = [], right = [0,1,2,3,4,5,6,7]\n<strong>输出：</strong>7\n<strong>解释：</strong>所有蚂蚁都向右移动，下标为 0 的蚂蚁需要 7 秒才能从木板上掉落。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/06/17/ants3.jpg\" style=\"height: 100px; width: 639px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 7, left = [0,1,2,3,4,5,6,7], right = []\n<strong>输出：</strong>7\n<strong>解释：</strong>所有蚂蚁都向左移动，下标为 7 的蚂蚁需要 7 秒才能从木板上掉落。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^4</code></li>\n\t<li><code>0 &lt;= left.length &lt;= n + 1</code></li>\n\t<li><code>0 &lt;= left[i] &lt;= n</code></li>\n\t<li><code>0 &lt;= right.length &lt;= n + 1</code></li>\n\t<li><code>0 &lt;= right[i] &lt;= n</code></li>\n\t<li><code>1 &lt;= left.length + right.length &lt;= n + 1</code></li>\n\t<li><code>left</code> 和 <code>right</code> 中的所有值都是唯一的，并且每个值 <strong>只能出现在二者之一</strong> 中。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1504统计全 1 子矩形",
        "hardRate": "MEDIUM",
        "passRate": "62.45%",
        "problemsUrl": "https://leetcode.cn/problems/count-submatrices-with-all-ones/",
        "solutionsUrl": "https://leetcode.cn/problems/count-submatrices-with-all-ones/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的二进制矩阵&nbsp;<code>mat</code>&nbsp;，请你返回有多少个&nbsp;<strong>子矩形</strong>&nbsp;的元素全部都是 1 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/27/ones1-grid.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1,0,1],[1,1,0],[1,1,0]]\n<strong>输出：</strong>13\n<strong>解释：\n</strong>有 <strong>6</strong>&nbsp;个 1x1 的矩形。\n有 <strong>2</strong> 个 1x2 的矩形。\n有 <strong>3</strong> 个 2x1 的矩形。\n有 <strong>1</strong> 个 2x2 的矩形。\n有 <strong>1</strong> 个 3x1 的矩形。\n矩形数目总共 = 6 + 2 + 3 + 1 + 1 = <strong>13</strong>&nbsp;。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/27/ones2-grid.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[0,1,1,0],[0,1,1,1],[1,1,1,0]]\n<strong>输出：</strong>24\n<strong>解释：</strong>\n有 <strong>8</strong> 个 1x1 的子矩形。\n有 <strong>5</strong> 个 1x2 的子矩形。\n有 <strong>2</strong> 个 1x3 的子矩形。\n有 <strong>4</strong> 个 2x1 的子矩形。\n有 <strong>2</strong> 个 2x2 的子矩形。\n有 <strong>2</strong> 个 3x1 的子矩形。\n有 <strong>1</strong> 个 3x2 的子矩形。\n矩形数目总共 = 8 + 5 + 2 + 4 + 2 + 2 + 1 = <strong>24</strong><strong> 。</strong>\n\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 150</code></li>\n\t<li><code>mat[i][j]</code>&nbsp;仅包含&nbsp;<code>0</code>&nbsp;或&nbsp;<code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1505最多 K 次交换相邻数位后得到的最小整数",
        "hardRate": "HARD",
        "passRate": "39.86%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>num</code> 和一个整数&nbsp;<code>k</code> 。其中，<code>num</code> 表示一个很大的整数，字符串中的每个字符依次对应整数上的各个 <strong>数位</strong> 。</p>\n\n<p>你可以交换这个整数相邻数位的数字 <strong>最多</strong>&nbsp;<code>k</code>&nbsp;次。</p>\n\n<p>请你返回你能得到的最小整数，并以字符串形式返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/06/17/q4_1.jpg\" style=\"height:40px; width:500px\" /></p>\n\n<pre>\n<strong>输入：</strong>num = &quot;4321&quot;, k = 4\n<strong>输出：</strong>&quot;1342&quot;\n<strong>解释：</strong>4321 通过 4 次交换相邻数位得到最小整数的步骤如上图所示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = &quot;100&quot;, k = 1\n<strong>输出：</strong>&quot;010&quot;\n<strong>解释：</strong>输出可以包含前导 0 ，但输入保证不会有前导 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = &quot;36789&quot;, k = 1000\n<strong>输出：</strong>&quot;36789&quot;\n<strong>解释：</strong>不需要做任何交换。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = &quot;22&quot;, k = 22\n<strong>输出：</strong>&quot;22&quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = &quot;9438957234785635408&quot;, k = 23\n<strong>输出：</strong>&quot;0345989723478563548&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 30000</code></li>\n\t<li><code>num</code>&nbsp;只包含&nbsp;<strong>数字</strong>&nbsp;且不含有<strong>&nbsp;前导 0&nbsp;</strong>。</li>\n\t<li><code>1 &lt;= k &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1506找到 N 叉树的根节点",
        "hardRate": "MEDIUM",
        "passRate": "81.42%",
        "problemsUrl": "https://leetcode.cn/problems/find-root-of-n-ary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/find-root-of-n-ary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1507转变日期格式",
        "hardRate": "EASY",
        "passRate": "58.92%",
        "problemsUrl": "https://leetcode.cn/problems/reformat-date/",
        "solutionsUrl": "https://leetcode.cn/problems/reformat-date/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>date</code>&nbsp;，它的格式为&nbsp;<code>Day Month Year</code>&nbsp;，其中：</p>\n\n<ul>\n\t<li><code>Day</code>&nbsp;是集合&nbsp;<code>{&quot;1st&quot;, &quot;2nd&quot;, &quot;3rd&quot;, &quot;4th&quot;, ..., &quot;30th&quot;, &quot;31st&quot;}</code>&nbsp;中的一个元素。</li>\n\t<li><code>Month</code>&nbsp;是集合&nbsp;<code>{&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;}</code>&nbsp;中的一个元素。</li>\n\t<li><code>Year</code>&nbsp;的范围在 ​<code>[1900, 2100]</code>&nbsp;之间。</li>\n</ul>\n\n<p>请你将字符串转变为&nbsp;<code>YYYY-MM-DD</code>&nbsp;的格式，其中：</p>\n\n<ul>\n\t<li><code>YYYY</code>&nbsp;表示 4 位的年份。</li>\n\t<li><code>MM</code>&nbsp;表示 2 位的月份。</li>\n\t<li><code>DD</code>&nbsp;表示 2 位的天数。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>date = &quot;20th Oct 2052&quot;\n<strong>输出：</strong>&quot;2052-10-20&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>date = &quot;6th Jun 1933&quot;\n<strong>输出：</strong>&quot;1933-06-06&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>date = &quot;26th May 1960&quot;\n<strong>输出：</strong>&quot;1960-05-26&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给定日期保证是合法的，所以不需要处理异常输入。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1508子数组和排序后的区间和",
        "hardRate": "MEDIUM",
        "passRate": "57.74%",
        "problemsUrl": "https://leetcode.cn/problems/range-sum-of-sorted-subarray-sums/",
        "solutionsUrl": "https://leetcode.cn/problems/range-sum-of-sorted-subarray-sums/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>nums</code>&nbsp;，它包含&nbsp;<code>n</code>&nbsp;个正整数。你需要计算所有非空连续子数组的和，并将它们按升序排序，得到一个新的包含&nbsp;<code>n * (n + 1) / 2</code>&nbsp;个数字的数组。</p>\n\n<p>请你返回在新数组中下标为<em>&nbsp;</em><code>left</code>&nbsp;到&nbsp;<code>right</code> <strong>（下标从 1 开始）</strong>的所有数字和（包括左右端点）。由于答案可能很大，请你将它对 10^9 + 7 取模后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4], n = 4, left = 1, right = 5\n<strong>输出：</strong>13 \n<strong>解释：</strong>所有的子数组和为 1, 3, 6, 10, 2, 5, 9, 3, 7, 4 。将它们升序排序后，我们得到新的数组 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。下标从 le = 1 到 ri = 5 的和为 1 + 2 + 3 + 3 + 4 = 13 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4], n = 4, left = 3, right = 4\n<strong>输出：</strong>6\n<strong>解释：</strong>给定数组与示例 1 一样，所以新数组为 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。下标从 le = 3 到 ri = 4 的和为 3 + 3 = 6 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4], n = 4, left = 1, right = 10\n<strong>输出：</strong>50\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^3</code></li>\n\t<li><code>nums.length == n</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= left &lt;= right&nbsp;&lt;= n * (n + 1) / 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1509三次操作后最大值与最小值的最小差",
        "hardRate": "MEDIUM",
        "passRate": "55.48%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>每次操作你可以选择&nbsp;<code>nums</code>&nbsp;中的任意一个元素并将它改成 <strong>任意值</strong> 。</p>\n\n<p>在&nbsp;<strong>执行最多三次移动后&nbsp;</strong>，返回&nbsp;<code>nums</code>&nbsp;中最大值与最小值的最小差值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,3,2,4]\n<strong>输出：</strong>0\n<strong>解释：</strong>我们最多可以走 3 步。\n第一步，将 2 变为 3 。 nums 变成 [5,3,3,4] 。\n第二步，将 4 改为 3 。 nums 变成 [5,3,3,3] 。\n第三步，将 5 改为 3 。 nums 变成 [3,3,3,3] 。\n执行 3 次移动后，最小值和最大值之间的差值为 3 - 3 = 0 。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5,0,10,14]\n<strong>输出：</strong>1\n<strong>解释：</strong>我们最多可以走 3 步。\n第一步，将 5 改为 0 。 nums变成 [1,0,0,10,14] 。\n第二步，将 10 改为 0 。 nums变成 [1,0,0,0,14] 。\n第三步，将 14 改为 1 。 nums变成 [1,0,0,0,1] 。\n执行 3 步后，最小值和最大值之间的差值为 1 - 0 = 1 。\n可以看出，没有办法可以在 3 步内使差值变为0。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,100,20]\n<strong>输出：</strong>0\n<strong>解释：</strong>我们最多可以走 3 步。\n第一步，将 100 改为 7 。 nums 变成 [3,7,20] 。\n第二步，将 20 改为 7 。 nums 变成 [3,7,7] 。\n第三步，将 3 改为 7 。 nums 变成 [7,7,7] 。\n执行 3 步后，最小值和最大值之间的差值是 7 - 7 = 0。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1510石子游戏 IV",
        "hardRate": "HARD",
        "passRate": "60.20%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game-iv/solution",
        "problemsDesc": "<p>Alice 和 Bob 两个人轮流玩一个游戏，Alice 先手。</p>\n\n<p>一开始，有 <code>n</code>&nbsp;个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 <strong>任意</strong>&nbsp;非零 <strong>平方数</strong>&nbsp;个石子。</p>\n\n<p>如果石子堆里没有石子了，则无法操作的玩家输掉游戏。</p>\n\n<p>给你正整数&nbsp;<code>n</code>&nbsp;，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回&nbsp;<code>True</code>&nbsp;，否则返回&nbsp;<code>False</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>true\n<strong>解释：</strong>Alice 拿走 1 个石子并赢得胜利，因为 Bob 无法进行任何操作。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>false\n<strong>解释：</strong>Alice 只能拿走 1 个石子，然后 Bob 拿走最后一个石子并赢得胜利（2 -&gt; 1 -&gt; 0）。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>true\n<strong>解释：</strong>n 已经是一个平方数，Alice 可以一次全拿掉 4 个石子并赢得胜利（4 -&gt; 0）。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 7\n<strong>输出：</strong>false\n<strong>解释：</strong>当 Bob 采取最优策略时，Alice 无法赢得比赛。\n如果 Alice 一开始拿走 4 个石子， Bob 会拿走 1 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 0）。\n如果 Alice 一开始拿走 1 个石子， Bob 会拿走 4 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -&gt; 6 -&gt; 2 -&gt; 1 -&gt; 0）。</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 17\n<strong>输出：</strong>false\n<strong>解释：</strong>如果 Bob 采取最优策略，Alice 无法赢得胜利。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1511消费者下单频率",
        "hardRate": "EASY",
        "passRate": "68.77%",
        "problemsUrl": "https://leetcode.cn/problems/customer-order-frequency/",
        "solutionsUrl": "https://leetcode.cn/problems/customer-order-frequency/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1512好数对的数目",
        "hardRate": "EASY",
        "passRate": "84.41%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-good-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-good-pairs/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。</p>\n\n<p>如果一组数字 <code>(i,j)</code> 满足 <code>nums[i]</code> == <code>nums[j]</code> 且 <code>i</code> &lt; <code>j</code> ，就可以认为这是一组 <strong>好数对</strong> 。</p>\n\n<p>返回好数对的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,1,1,3]\n<strong>输出：</strong>4\n<strong>解释：</strong>有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,1,1]\n<strong>输出：</strong>6\n<strong>解释：</strong>数组中的每组数字都是好数对</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1513仅含 1 的子串数",
        "hardRate": "MEDIUM",
        "passRate": "39.54%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-substrings-with-only-1s/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-substrings-with-only-1s/solution",
        "problemsDesc": "<p>给你一个二进制字符串 <code>s</code>（仅由 &#39;0&#39; 和 &#39;1&#39; 组成的字符串）。</p>\n\n<p>返回所有字符都为 1 的子字符串的数目。</p>\n\n<p>由于答案可能很大，请你将它对 10^9 + 7 取模后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;0110111&quot;\n<strong>输出</strong>：9\n<strong>解释：</strong>共有 9 个子字符串仅由 &#39;1&#39; 组成\n&quot;1&quot; -&gt; 5 次\n&quot;11&quot; -&gt; 3 次\n&quot;111&quot; -&gt; 1 次</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;101&quot;\n<strong>输出：</strong>2\n<strong>解释：</strong>子字符串 &quot;1&quot; 在 s 中共出现 2 次\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;111111&quot;\n<strong>输出：</strong>21\n<strong>解释：</strong>每个子字符串都仅由 &#39;1&#39; 组成\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;000&quot;\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s[i] == &#39;0&#39;</code> 或 <code>s[i] == &#39;1&#39;</code></li>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1514概率最大的路径",
        "hardRate": "MEDIUM",
        "passRate": "40.73%",
        "problemsUrl": "https://leetcode.cn/problems/path-with-maximum-probability/",
        "solutionsUrl": "https://leetcode.cn/problems/path-with-maximum-probability/solution",
        "problemsDesc": "<p>给你一个由 <code>n</code> 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 <code>edges[i] = [a, b]</code> 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 <code>succProb[i]</code> 。</p>\n\n<p>指定两个节点分别作为起点 <code>start</code> 和终点 <code>end</code> ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。</p>\n\n<p>如果不存在从 <code>start</code> 到 <code>end</code> 的路径，请 <strong>返回 0</strong> 。只要答案与标准答案的误差不超过 <strong>1e-5 </strong>，就会被视作正确答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex1.png\" style=\"height: 186px; width: 187px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2\n<strong>输出：</strong>0.25000\n<strong>解释：</strong>从起点到终点有两条路径，其中一条的成功概率为 0.2 ，而另一条为 0.5 * 0.5 = 0.25\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex2.png\" style=\"height: 186px; width: 189px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2\n<strong>输出：</strong>0.30000\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex3.png\" style=\"height: 191px; width: 215px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2\n<strong>输出：</strong>0.00000\n<strong>解释：</strong>节点 0 和 节点 2 之间不存在路径\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10^4</code></li>\n\t<li><code>0 &lt;= start, end &lt; n</code></li>\n\t<li><code>start != end</code></li>\n\t<li><code>0 &lt;= a, b &lt; n</code></li>\n\t<li><code>a != b</code></li>\n\t<li><code>0 &lt;= succProb.length == edges.length &lt;= 2*10^4</code></li>\n\t<li><code>0 &lt;= succProb[i] &lt;= 1</code></li>\n\t<li>每两个节点之间最多有一条边</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1515服务中心的最佳位置",
        "hardRate": "HARD",
        "passRate": "35.24%",
        "problemsUrl": "https://leetcode.cn/problems/best-position-for-a-service-centre/",
        "solutionsUrl": "https://leetcode.cn/problems/best-position-for-a-service-centre/solution",
        "problemsDesc": "<p>一家快递公司希望在新城市建立新的服务中心。公司统计了该城市所有客户在二维地图上的坐标，并希望能够以此为依据为新的服务中心选址：使服务中心 <strong>到所有客户的欧几里得距离的总和最小</strong> 。</p>\n\n<p>给你一个数组 <code>positions</code> ，其中 <code>positions[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示第 <code>i</code> 个客户在二维地图上的位置，返回到所有客户的 <strong>欧几里得距离的最小总和 。</strong></p>\n\n<p>换句话说，请你为服务中心选址，该位置的坐标 <code>[x<sub>centre</sub>, y<sub>centre</sub>]</code> 需要使下面的公式取到最小值：</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/q4_edited.jpg\" /></p>\n\n<p>与真实值误差在 <code>10<sup>-5</sup></code>之内的答案将被视作正确答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/q4_e1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>positions = [[0,1],[1,0],[1,2],[2,1]]\n<strong>输出：</strong>4.00000\n<strong>解释：</strong>如图所示，你可以选 [x<sub>centre</sub>, y<sub>centre</sub>] = [1, 1] 作为新中心的位置，这样一来到每个客户的距离就都是 1，所有距离之和为 4 ，这也是可以找到的最小值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/q4_e3.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>positions = [[1,1],[3,3]]\n<strong>输出：</strong>2.82843\n<strong>解释：</strong>欧几里得距离可能的最小总和为 sqrt(2) + sqrt(2) = 2.82843\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= positions.length &lt;= 50</code></li>\n\t<li><code>positions[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1516移动 N 叉树的子树",
        "hardRate": "HARD",
        "passRate": "55.87%",
        "problemsUrl": "https://leetcode.cn/problems/move-sub-tree-of-n-ary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/move-sub-tree-of-n-ary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1517查找拥有有效邮箱的用户",
        "hardRate": "EASY",
        "passRate": "50.43%",
        "problemsUrl": "https://leetcode.cn/problems/find-users-with-valid-e-mails/",
        "solutionsUrl": "https://leetcode.cn/problems/find-users-with-valid-e-mails/solution",
        "problemsDesc": "<p>用户表：&nbsp;Users</p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| user_id       | int     |\n| name          | varchar |\n| mail          | varchar | \n+---------------+---------+\nuser_id （用户 ID）是该表的主键。\n这个表包含用户在某网站上注册的信息。有些邮箱是无效的。</pre>\n\n<p>&nbsp;</p>\n\n<p>写一条&nbsp;SQL 语句，查询拥有<strong>有效邮箱</strong>的用户。</p>\n\n<p>有效的邮箱包含符合下列条件的前缀名和域名：</p>\n\n<ul>\n\t<li><strong>前缀名</strong>是包含字母（大写或小写）、数字、下划线&nbsp;<code>&#39;_&#39;</code>、句点&nbsp;<code>&#39;.&#39;</code>&nbsp;和/或横杠&nbsp;<code>&#39;-&#39;</code>&nbsp;的字符串。前缀名<strong>必须</strong>以字母开头。</li>\n\t<li><strong>域名</strong>是&nbsp;<code>&#39;@leetcode.com&#39;</code>&nbsp;。</li>\n</ul>\n\n<p>按任意顺序返回结果表。</p>\n\n<p>&nbsp;</p>\n\n<p>查询格式如下所示：</p>\n\n<pre>\n<code>Users</code>\n+---------+-----------+-------------------------+\n| user_id | name      | mail                    |\n+---------+-----------+-------------------------+\n| 1       | Winston   | winston@leetcode.com    |\n| 2       | Jonathan  | jonathanisgreat         |\n| 3       | Annabelle | bella-@leetcode.com     |\n| 4       | Sally     | sally.come@leetcode.com |\n| 5       | Marwan    | quarz#2020@leetcode.com |\n| 6       | David     | david69@gmail.com       |\n| 7       | Shapiro   | .shapo@leetcode.com     |\n+---------+-----------+-------------------------+\n\n结果表：\n+---------+-----------+-------------------------+\n| user_id | name      | mail                    |\n+---------+-----------+-------------------------+\n| 1       | Winston   | winston@leetcode.com    |\n| 3       | Annabelle | bella-@leetcode.com     |\n| 4       | Sally     | sally.come@leetcode.com |\n+---------+-----------+-------------------------+\n2 号用户的邮箱没有域名。\n5 号用户的邮箱包含非法字符 #。\n6 号用户的邮箱的域名不是 leetcode。\n7 号用户的邮箱以句点（.）开头。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1518换水问题",
        "hardRate": "EASY",
        "passRate": "69.56%",
        "problemsUrl": "https://leetcode.cn/problems/water-bottles/",
        "solutionsUrl": "https://leetcode.cn/problems/water-bottles/solution",
        "problemsDesc": "<p>超市正在促销，你可以用 <code>numExchange</code> 个空水瓶从超市兑换一瓶水。最开始，你一共购入了 <code>numBottles</code> 瓶水。</p>\n\n<p>如果喝掉了水瓶中的水，那么水瓶就会变成空的。</p>\n\n<p>给你两个整数 <code>numBottles</code> 和 <code>numExchange</code> ，返回你 <strong>最多</strong> 可以喝到多少瓶水。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/19/sample_1_1875.png\" style=\"height: 240px; width: 480px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>numBottles = 9, numExchange = 3\n<strong>输出：</strong>13\n<strong>解释：</strong>你可以用 <code>3</code> 个空瓶兑换 1 瓶水。\n所以最多能喝到 9 + 3 + 1 = 13 瓶水。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/19/sample_2_1875.png\" style=\"height: 240px; width: 790px;\" /></p>\n\n<pre>\n<strong>输入：</strong>numBottles = 15, numExchange = 4\n<strong>输出：</strong>19\n<strong>解释：</strong>你可以用 <code>4</code> 个空瓶兑换 1 瓶水。\n所以最多能喝到 15 + 3 + 1 = 19 瓶水。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numBottles &lt;= 100</code></li>\n\t<li><code>2 &lt;= numExchange &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1519子树中标签相同的节点数",
        "hardRate": "MEDIUM",
        "passRate": "33.23%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/solution",
        "problemsDesc": "<p>给你一棵树（即，一个连通的无环无向图），这棵树由编号从 <code>0</code>&nbsp; 到 <code>n - 1</code> 的 n 个节点组成，且恰好有 <code>n - 1</code> 条 <code>edges</code> 。树的根节点为节点 <code>0</code> ，树上的每一个节点都有一个标签，也就是字符串 <code>labels</code> 中的一个小写字符（编号为 <code>i</code> 的 节点的标签就是 <code>labels[i]</code> ）</p>\n\n<p>边数组 <code>edges</code> 以 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 的形式给出，该格式表示节点 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间存在一条边。</p>\n\n<p>返回一个大小为 <em><code>n</code></em> 的数组，其中 <code>ans[i]</code> 表示第 <code>i</code> 个节点的子树中与节点 <code>i</code> 标签相同的节点数。</p>\n\n<p>树 <code>T</code> 中的子树是由 <code>T</code> 中的某个节点及其所有后代节点组成的树。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/19/q3e1.jpg\" style=\"height: 321px; width: 441px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = \"abaedcd\"\n<strong>输出：</strong>[2,1,1,1,1,1,1]\n<strong>解释：</strong>节点 0 的标签为 'a' ，以 'a' 为根节点的子树中，节点 2 的标签也是 'a' ，因此答案为 2 。注意树中的每个节点都是这棵子树的一部分。\n节点 1 的标签为 'b' ，节点 1 的子树包含节点 1、4 和 5，但是节点 4、5 的标签与节点 1 不同，故而答案为 1（即，该节点本身）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/19/q3e2.jpg\" style=\"height: 321px; width: 381px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 4, edges = [[0,1],[1,2],[0,3]], labels = \"bbbb\"\n<strong>输出：</strong>[4,2,1,1]\n<strong>解释：</strong>节点 2 的子树中只有节点 2 ，所以答案为 1 。\n节点 3 的子树中只有节点 3 ，所以答案为 1 。\n节点 1 的子树中包含节点 1 和 2 ，标签都是 'b' ，因此答案为 2 。\n节点 0 的子树中包含节点 0、1、2 和 3，标签都是 'b'，因此答案为 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/19/q3e3.jpg\" style=\"height: 321px; width: 381px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = \"aabab\"\n<strong>输出：</strong>[3,2,1,1,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>,&nbsp;b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> !=&nbsp;b<sub>i</sub></code></li>\n\t<li><code>labels.length == n</code></li>\n\t<li><code>labels</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1520最多的不重叠子字符串",
        "hardRate": "HARD",
        "passRate": "35.65%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-non-overlapping-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-non-overlapping-substrings/solution",
        "problemsDesc": "<p>给你一个只包含小写字母的字符串&nbsp;<code>s</code>&nbsp;，你需要找到 <code>s</code>&nbsp;中最多数目的非空子字符串，满足如下条件：</p>\n\n<ol>\n\t<li>这些字符串之间互不重叠，也就是说对于任意两个子字符串&nbsp;<code>s[i..j]</code> 和&nbsp;<code>s[x..y]</code>&nbsp;，要么&nbsp;<code>j &lt; x</code>&nbsp;要么&nbsp;<code>i &gt; y</code>&nbsp;。</li>\n\t<li>如果一个子字符串包含字符&nbsp;<code>char</code> ，那么&nbsp;<code>s</code>&nbsp;中所有&nbsp;<code>char</code> 字符都应该在这个子字符串中。</li>\n</ol>\n\n<p>请你找到满足上述条件的最多子字符串数目。如果有多个解法有相同的子字符串数目，请返回这些子字符串总长度最小的一个解。可以证明最小总长度解是唯一的。</p>\n\n<p>请注意，你可以以 <strong>任意</strong>&nbsp;顺序返回最优解的子字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"adefaddaccc\"\n<strong>输出：</strong>[\"e\",\"f\",\"ccc\"]\n<strong>解释：</strong>下面为所有满足第二个条件的子字符串：\n[\n&nbsp; \"adefaddaccc\"\n&nbsp; \"adefadda\",\n&nbsp; \"ef\",\n&nbsp; \"e\",\n  \"f\",\n&nbsp; \"ccc\",\n]\n如果我们选择第一个字符串，那么我们无法再选择其他任何字符串，所以答案为 1 。如果我们选择 \"adefadda\" ，剩下子字符串中我们只可以选择 \"ccc\" ，它是唯一不重叠的子字符串，所以答案为 2 。同时我们可以发现，选择 \"ef\" 不是最优的，因为它可以被拆分成 2 个子字符串。所以最优解是选择 [\"e\",\"f\",\"ccc\"] ，答案为 3 。不存在别的相同数目子字符串解。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abbaccd\"\n<strong>输出：</strong>[\"d\",\"bb\",\"cc\"]\n<strong>解释：</strong>注意到解 [\"d\",\"abba\",\"cc\"] 答案也为 3 ，但它不是最优解，因为它的总长度更长。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1521找到最接近目标值的函数值",
        "hardRate": "HARD",
        "passRate": "43.65%",
        "problemsUrl": "https://leetcode.cn/problems/find-a-value-of-a-mysterious-function-closest-to-target/",
        "solutionsUrl": "https://leetcode.cn/problems/find-a-value-of-a-mysterious-function-closest-to-target/solution",
        "problemsDesc": "<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/19/change.png\" style=\"height: 312px; width: 635px;\"></p>\n\n<p>Winston 构造了一个如上所示的函数&nbsp;<code>func</code>&nbsp;。他有一个整数数组&nbsp;<code>arr</code>&nbsp;和一个整数&nbsp;<code>target</code>&nbsp;，他想找到让&nbsp;<code>|func(arr, l, r) - target|</code>&nbsp;最小的 <code>l</code>&nbsp;和 <code>r</code>&nbsp;。</p>\n\n<p>请你返回&nbsp;<code>|func(arr, l, r) - target|</code>&nbsp;的最小值。</p>\n\n<p>请注意，&nbsp;<code>func</code> 的输入参数&nbsp;<code>l</code> 和&nbsp;<code>r</code>&nbsp;需要满足&nbsp;<code>0 &lt;= l, r &lt; arr.length</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [9,12,3,7,15], target = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>所有可能的 [l,r] 数对包括 [[0,0],[1,1],[2,2],[3,3],[4,4],[0,1],[1,2],[2,3],[3,4],[0,2],[1,3],[2,4],[0,3],[1,4],[0,4]]， Winston 得到的相应结果为 [9,12,3,7,15,8,0,3,7,0,0,3,0,0,0] 。最接近 5 的值是 7 和 3，所以最小差值为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1000000,1000000,1000000], target = 1\n<strong>输出：</strong>999999\n<strong>解释：</strong>Winston 输入函数的所有可能 [l,r] 数对得到的函数值都为 1000000 ，所以最小差值为 999999 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,4,8,16], target = 0\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10^6</code></li>\n\t<li><code>0 &lt;= target &lt;= 10^7</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1522N 叉树的直径",
        "hardRate": "MEDIUM",
        "passRate": "71.49%",
        "problemsUrl": "https://leetcode.cn/problems/diameter-of-n-ary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/diameter-of-n-ary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1523在区间范围内统计奇数数目",
        "hardRate": "EASY",
        "passRate": "49.23%",
        "problemsUrl": "https://leetcode.cn/problems/count-odd-numbers-in-an-interval-range/",
        "solutionsUrl": "https://leetcode.cn/problems/count-odd-numbers-in-an-interval-range/solution",
        "problemsDesc": "<p>给你两个非负整数&nbsp;<code>low</code> 和&nbsp;<code>high</code>&nbsp;。请你返回<em>&nbsp;</em><code>low</code><em> </em>和<em>&nbsp;</em><code>high</code><em>&nbsp;</em>之间（包括二者）奇数的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>low = 3, high = 7\n<strong>输出：</strong>3\n<strong>解释：</strong>3 到 7 之间奇数数字为 [3,5,7] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>low = 8, high = 10\n<strong>输出：</strong>1\n<strong>解释：</strong>8 到 10 之间奇数数字为 [9] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= low &lt;= high&nbsp;&lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1524和为奇数的子数组数目",
        "hardRate": "MEDIUM",
        "passRate": "45.75%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-sub-arrays-with-odd-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-sub-arrays-with-odd-sum/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code>&nbsp;。请你返回和为 <strong>奇数</strong>&nbsp;的子数组数目。</p>\n\n<p>由于答案可能会很大，请你将结果对&nbsp;<code>10^9 + 7</code>&nbsp;取余后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,3,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>所有的子数组为 [[1],[1,3],[1,3,5],[3],[3,5],[5]] 。\n所有子数组的和为 [1,4,9,3,8,5].\n奇数和包括 [1,9,3,5] ，所以答案为 4 。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,4,6]\n<strong>输出：</strong>0\n<strong>解释：</strong>所有子数组为 [[2],[2,4],[2,4,6],[4],[4,6],[6]] 。\n所有子数组和为 [2,6,12,4,10,6] 。\n所有子数组和都是偶数，所以答案为 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,3,4,5,6,7]\n<strong>输出：</strong>16\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [100,100,99,99]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [7]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1525字符串的好分割数目",
        "hardRate": "MEDIUM",
        "passRate": "66.02%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-good-ways-to-split-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-good-ways-to-split-a-string/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，一个分割被称为 「好分割」&nbsp;当它满足：将&nbsp;<code>s</code>&nbsp;分割成 2 个字符串&nbsp;<code>p</code> 和&nbsp;<code>q</code>&nbsp;，它们连接起来等于&nbsp;<code>s</code>&nbsp;且 <code>p</code>&nbsp;和 <code>q</code>&nbsp;中不同字符的数目相同。</p>\n\n<p>请你返回 <code>s</code>&nbsp;中好分割的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aacaba&quot;\n<strong>输出：</strong>2\n<strong>解释：</strong>总共有 5 种分割字符串 <code>&quot;aacaba&quot;</code> 的方法，其中 2 种是好分割。\n(&quot;a&quot;, &quot;acaba&quot;) 左边字符串和右边字符串分别包含 1 个和 3 个不同的字符。\n(&quot;aa&quot;, &quot;caba&quot;) 左边字符串和右边字符串分别包含 1 个和 3 个不同的字符。\n(&quot;aac&quot;, &quot;aba&quot;) 左边字符串和右边字符串分别包含 2 个和 2 个不同的字符。这是一个好分割。\n(&quot;aaca&quot;, &quot;ba&quot;) 左边字符串和右边字符串分别包含 2 个和 2 个不同的字符。这是一个好分割。\n(&quot;aacab&quot;, &quot;a&quot;) 左边字符串和右边字符串分别包含 3 个和 1 个不同的字符。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abcd&quot;\n<strong>输出：</strong>1\n<strong>解释：</strong>好分割为将字符串分割成 (&quot;ab&quot;, &quot;cd&quot;) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aaaaa&quot;\n<strong>输出：</strong>4\n<strong>解释：</strong>所有分割都是好分割。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;acbadbaada&quot;\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1526形成目标数组的子数组最少增加次数",
        "hardRate": "HARD",
        "passRate": "64.99%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>target</code>&nbsp;和一个数组&nbsp;<code>initial</code>&nbsp;，<code>initial</code>&nbsp;数组与 <code>target</code>&nbsp; 数组有同样的维度，且一开始全部为 0 。</p>\n\n<p>请你返回从 <code>initial</code>&nbsp;得到&nbsp; <code>target</code>&nbsp;的最少操作次数，每次操作需遵循以下规则：</p>\n\n<ul>\n\t<li>在 <code>initial</code>&nbsp;中选择 <strong>任意</strong>&nbsp;子数组，并将子数组中每个元素增加 1 。</li>\n</ul>\n\n<p>答案保证在 32 位有符号整数以内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>target = [1,2,3,2,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>我们需要至少 3 次操作从 intial 数组得到 target 数组。\n[0,0,0,0,0] 将下标为 0 到 4&nbsp;的元素（包含二者）加 1 。\n[1,1,1,1,1] 将下标为 1 到 3 的元素（包含二者）加 1 。\n[1,2,2,2,1] 将下表为 2 的元素增加 1 。\n[1,2,3,2,1] 得到了目标数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>target = [3,1,1,2]\n<strong>输出：</strong>4\n<strong>解释：</strong>(initial)[0,0,0,0] -&gt; [1,1,1,1] -&gt; [1,1,1,2] -&gt; [2,1,1,2] -&gt; [3,1,1,2] (target) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>target = [3,1,5,4,2]\n<strong>输出：</strong>7\n<strong>解释：</strong>(initial)[0,0,0,0,0] -&gt; [1,1,1,1,1] -&gt; [2,1,1,1,1] -&gt; [3,1,1,1,1] \n                                  -&gt; [3,1,2,2,2] -&gt; [3,1,3,3,2] -&gt; [3,1,4,4,2] -&gt; [3,1,5,4,2] (target)。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>target = [1,1,1,1]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= target[i] &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1527患某种疾病的患者",
        "hardRate": "EASY",
        "passRate": "46.68%",
        "problemsUrl": "https://leetcode.cn/problems/patients-with-a-condition/",
        "solutionsUrl": "https://leetcode.cn/problems/patients-with-a-condition/solution",
        "problemsDesc": "<p>患者信息表：&nbsp;<code>Patients</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| patient_id   | int     |\n| patient_name | varchar |\n| conditions   | varchar |\n+--------------+---------+\npatient_id （患者 ID）是该表的主键。\n'conditions' （疾病）包含 0 个或以上的疾病代码，以空格分隔。\n这个表包含医院中患者的信息。</pre>\n\n<p>&nbsp;</p>\n\n<p>写一条&nbsp;SQL 语句，查询患有 I 类糖尿病的患者&nbsp;ID （patient_id）、患者姓名（patient_name）以及其患有的所有疾病代码（conditions）。I 类糖尿病的代码总是包含前缀&nbsp;<code>DIAB1</code>&nbsp;。</p>\n\n<p>按 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式如下示例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<code><strong>输入：\n</strong>Patients表：</code>\n+------------+--------------+--------------+\n| patient_id | patient_name | conditions   |\n+------------+--------------+--------------+\n| 1          | Daniel      &nbsp;| YFEV COUGH   |\n| 2    &nbsp;     | Alice        |            &nbsp; |\n| 3    &nbsp;     | Bob         &nbsp;| DIAB100 MYOP&nbsp;|\n| 4 &nbsp;        | George      &nbsp;| ACNE DIAB100&nbsp;|\n| 5 &nbsp;        | Alain       &nbsp;| DIAB201     &nbsp;|\n+------------+--------------+--------------+\n<strong>输出：</strong>\n+------------+--------------+--------------+\n| patient_id | patient_name | conditions   |\n+------------+--------------+--------------+\n| 3    &nbsp;     | Bob         &nbsp;| DIAB100 MYOP&nbsp;|\n| 4 &nbsp;        | George   &nbsp;   | ACNE DIAB100&nbsp;| \n+------------+--------------+--------------+\n<strong>解释：</strong>Bob 和 George 都患有代码以 DIAB1 开头的疾病。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1528重新排列字符串",
        "hardRate": "EASY",
        "passRate": "78.45%",
        "problemsUrl": "https://leetcode.cn/problems/shuffle-string/",
        "solutionsUrl": "https://leetcode.cn/problems/shuffle-string/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和一个 <strong>长度相同</strong> 的整数数组 <code>indices</code> 。</p>\n\n<p>请你重新排列字符串 <code>s</code> ，其中第 <code>i</code> 个字符需要移动到 <code>indices[i]</code> 指示的位置。</p>\n\n<p>返回重新排列后的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/26/q1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>s = \"codeleet\", <code>indices</code> = [4,5,6,7,0,2,1,3]\n<strong>输出：</strong>\"leetcode\"\n<strong>解释：</strong>如图所示，\"codeleet\" 重新排列后变为 \"leetcode\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\", <code>indices</code> = [0,1,2]\n<strong>输出：</strong>\"abc\"\n<strong>解释：</strong>重新排列后，每个字符都还留在原来的位置上。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s.length == indices.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>s</code> 仅包含小写英文字母</li>\n\t<li><code>0 &lt;= indices[i] &lt;&nbsp;n</code></li>\n\t<li><code>indices</code> 的所有的值都是 <strong>唯一</strong> 的</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1529最少的后缀翻转次数",
        "hardRate": "MEDIUM",
        "passRate": "70.29%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-suffix-flips/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-suffix-flips/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 、下标从 <strong>0</strong> 开始的二进制字符串 <code>target</code> 。你自己有另一个长度为 <code>n</code> 的二进制字符串 <code>s</code> ，最初每一位上都是 0 。你想要让 <code>s</code> 和 <code>target</code> 相等。</p>\n\n<p>在一步操作，你可以选择下标 <code>i</code>（<code>0 &lt;= i &lt; n</code>）并翻转在 <strong>闭区间</strong> <code>[i, n - 1]</code> 内的所有位。翻转意味着 <code>'0'</code> 变为 <code>'1'</code> ，而 <code>'1'</code> 变为 <code>'0'</code> 。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>返回使<em> </em><code>s</code><em> </em>与<em> </em><code>target</code> 相等需要的最少翻转次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = \"10111\"\n<strong>输出：</strong>3\n<strong>解释：</strong>最初，s = \"00000\" 。\n选择下标 i = 2: \"00<em><strong>000</strong></em>\" -&gt; \"00<em><strong>111</strong></em>\"\n选择下标 i = 0: \"<em><strong>00111</strong></em>\" -&gt; \"<em><strong>11000</strong></em>\"\n选择下标 i = 1: \"1<em><strong>1000</strong></em>\" -&gt; \"1<em><strong>0111</strong></em>\"\n要达成目标，需要至少 3 次翻转。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = \"101\"\n<strong>输出：</strong>3\n<strong>解释：</strong>最初，s = \"000\" 。\n选择下标 i = 0: \"<em><strong>000</strong></em>\" -&gt; \"<em><strong>111</strong></em>\"\n选择下标 i = 1: \"1<em><strong>11</strong></em>\" -&gt; \"1<em><strong>00</strong></em>\"\n选择下标 i = 2: \"10<em><strong>0</strong></em>\" -&gt; \"10<em><strong>1</strong></em>\"\n要达成目标，需要至少 3 次翻转。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = \"00000\"\n<strong>输出：</strong>0\n<strong>解释：</strong>由于 s 已经等于目标，所以不需要任何操作\n</pre>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == target.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>target[i]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1530好叶子节点对的数量",
        "hardRate": "MEDIUM",
        "passRate": "58.52%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-good-leaf-nodes-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-good-leaf-nodes-pairs/solution",
        "problemsDesc": "<p>给你二叉树的根节点 <code>root</code> 和一个整数 <code>distance</code> 。</p>\n\n<p>如果二叉树中两个 <strong>叶</strong> 节点之间的 <strong>最短路径长度</strong> 小于或者等于 <code>distance</code> ，那它们就可以构成一组 <strong>好叶子节点对</strong> 。</p>\n\n<p>返回树中 <strong>好叶子节点对的数量</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/26/e1.jpg\" style=\"height: 321px; width: 321px;\"></p>\n\n<pre><strong>输入：</strong>root = [1,2,3,null,4], distance = 3\n<strong>输出：</strong>1\n<strong>解释：</strong>树的叶节点是 3 和 4 ，它们之间的最短路径的长度是 3 。这是唯一的好叶子节点对。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/26/e2.jpg\" style=\"height: 321px; width: 441px;\"></p>\n\n<pre><strong>输入：</strong>root = [1,2,3,4,5,6,7], distance = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>好叶子节点对为 [4,5] 和 [6,7] ，最短路径长度都是 2 。但是叶子节点对 [4,6] 不满足要求，因为它们之间的最短路径长度为 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3\n<strong>输出：</strong>1\n<strong>解释：</strong>唯一的好叶子节点对是 [2,5] 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>root = [100], distance = 1\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>root = [1,1,1], distance = 2\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>tree</code> 的节点数在 <code>[1, 2^10]</code> 范围内。</li>\n\t<li>每个节点的值都在 <code>[1, 100]</code> 之间。</li>\n\t<li><code>1 &lt;= distance &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1531压缩字符串 II",
        "hardRate": "HARD",
        "passRate": "38.05%",
        "problemsUrl": "https://leetcode.cn/problems/string-compression-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/string-compression-ii/solution",
        "problemsDesc": "<p><a href=\"https://baike.baidu.com/item/%E8%A1%8C%E7%A8%8B%E9%95%BF%E5%BA%A6%E7%BC%96%E7%A0%81/2931940?fr=aladdin\" target=\"_blank\">行程长度编码</a> 是一种常用的字符串压缩方法，它将连续的相同字符（重复 2 次或更多次）替换为字符和表示字符计数的数字（行程长度）。例如，用此方法压缩字符串 <code>&quot;aabccc&quot;</code> ，将 <code>&quot;aa&quot;</code> 替换为 <code>&quot;a2&quot;</code> ，<code>&quot;ccc&quot;</code> 替换为` <code>&quot;c3&quot;</code> 。因此压缩后的字符串变为 <code>&quot;a2bc3&quot;</code> 。</p>\n\n<p>注意，本问题中，压缩时没有在单个字符后附加计数 <code>&#39;1&#39;</code> 。</p>\n\n<p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> 。你需要从字符串 <code>s</code> 中删除最多 <code>k</code> 个字符，以使 <code>s</code> 的行程长度编码长度最小。</p>\n\n<p>请你返回删除最多 <code>k</code> 个字符后，<code>s</code> <strong>行程长度编码的最小长度</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aaabcccd&quot;, k = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>在不删除任何内容的情况下，压缩后的字符串是 &quot;a3bc3d&quot; ，长度为 6 。最优的方案是删除 &#39;b&#39; 和 &#39;d&#39;，这样一来，压缩后的字符串为 &quot;a3c3&quot; ，长度是 4 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aabbaa&quot;, k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>如果删去两个 &#39;b&#39; 字符，那么压缩后的字符串是长度为 2 的 &quot;a4&quot; 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aaaaaaaaaaa&quot;, k = 0\n<strong>输出：</strong>3\n<strong>解释：</strong>由于 k 等于 0 ，不能删去任何字符。压缩后的字符串是 &quot;a11&quot; ，长度为 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= k &lt;= s.length</code></li>\n\t<li><code>s</code> 仅包含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1532最近的三笔订单",
        "hardRate": "MEDIUM",
        "passRate": "63.02%",
        "problemsUrl": "https://leetcode.cn/problems/the-most-recent-three-orders/",
        "solutionsUrl": "https://leetcode.cn/problems/the-most-recent-three-orders/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1533找到最大整数的索引",
        "hardRate": "MEDIUM",
        "passRate": "58.75%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-index-of-the-large-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-index-of-the-large-integer/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1534统计好三元组",
        "hardRate": "EASY",
        "passRate": "77.27%",
        "problemsUrl": "https://leetcode.cn/problems/count-good-triplets/",
        "solutionsUrl": "https://leetcode.cn/problems/count-good-triplets/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> ，以及 <code>a</code>、<code>b</code> 、<code>c</code> 三个整数。请你统计其中好三元组的数量。</p>\n\n<p>如果三元组 <code>(arr[i], arr[j], arr[k])</code> 满足下列全部条件，则认为它是一个 <strong>好三元组</strong> 。</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; k &lt;&nbsp;arr.length</code></li>\n\t<li><code>|arr[i] - arr[j]| &lt;= a</code></li>\n\t<li><code>|arr[j] - arr[k]| &lt;= b</code></li>\n\t<li><code>|arr[i] - arr[k]| &lt;= c</code></li>\n</ul>\n\n<p>其中 <code>|x|</code> 表示 <code>x</code> 的绝对值。</p>\n\n<p>返回 <strong>好三元组的数量</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3\n<strong>输出：</strong>4\n<strong>解释：</strong>一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,1,2,2,3], a = 0, b = 0, c = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在满足所有条件的三元组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= arr.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= a, b, c &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1535找出数组游戏的赢家",
        "hardRate": "MEDIUM",
        "passRate": "46.17%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-winner-of-an-array-game/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-winner-of-an-array-game/solution",
        "problemsDesc": "<p>给你一个由 <strong>不同</strong> 整数组成的整数数组 <code>arr</code> 和一个整数 <code>k</code> 。</p>\n\n<p>每回合游戏都在数组的前两个元素（即 <code>arr[0]</code> 和 <code>arr[1]</code> ）之间进行。比较 <code>arr[0]</code> 与 <code>arr[1]</code> 的大小，较大的整数将会取得这一回合的胜利并保留在位置 <code>0</code> ，较小的整数移至数组的末尾。当一个整数赢得 <code>k</code> 个连续回合时，游戏结束，该整数就是比赛的 <strong>赢家</strong> 。</p>\n\n<p>返回赢得比赛的整数。</p>\n\n<p>题目数据 <strong>保证</strong> 游戏存在赢家。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,1,3,5,4,6,7], k = 2\n<strong>输出：</strong>5\n<strong>解释：</strong>一起看一下本场游戏每回合的情况：\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/30/q-example.png\" style=\"height: 90px; width: 400px;\">\n因此将进行 4 回合比赛，其中 5 是赢家，因为它连胜 2 回合。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,2,1], k = 10\n<strong>输出：</strong>3\n<strong>解释：</strong>3 将会在前 10 个回合中连续获胜。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,9,8,2,3,7,6,4,5], k = 7\n<strong>输出：</strong>9\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,11,22,33,44,55,66,77,88,99], k = 1000000000\n<strong>输出：</strong>99\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10^6</code></li>\n\t<li><code>arr</code> 所含的整数 <strong>各不相同</strong> 。</li>\n\t<li><code>1 &lt;= k &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1536排布二进制网格的最少交换次数",
        "hardRate": "MEDIUM",
        "passRate": "46.27%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-swaps-to-arrange-a-binary-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-swaps-to-arrange-a-binary-grid/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>n&nbsp;x n</code>&nbsp;的二进制网格&nbsp;<code>grid</code>，每一次操作中，你可以选择网格的&nbsp;<strong>相邻两行</strong>&nbsp;进行交换。</p>\n\n<p>一个符合要求的网格需要满足主对角线以上的格子全部都是 <strong>0</strong>&nbsp;。</p>\n\n<p>请你返回使网格满足要求的最少操作次数，如果无法使网格符合要求，请你返回 <strong>-1</strong>&nbsp;。</p>\n\n<p>主对角线指的是从&nbsp;<code>(1, 1)</code>&nbsp;到&nbsp;<code>(n, n)</code>&nbsp;的这些格子。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/02/fw.jpg\" style=\"height: 141px; width: 750px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[0,0,1],[1,1,0],[1,0,0]]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/02/e2.jpg\" style=\"height: 270px; width: 270px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>所有行都是一样的，交换相邻行无法使网格符合要求。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/02/e3.jpg\" style=\"height: 210px; width: 210px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[1,0,0],[1,1,0],[1,1,1]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= n&nbsp;&lt;= 200</code></li>\n\t<li><code>grid[i][j]</code>&nbsp;要么是&nbsp;<code>0</code>&nbsp;要么是&nbsp;<code>1</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1537最大得分",
        "hardRate": "HARD",
        "passRate": "40.09%",
        "problemsUrl": "https://leetcode.cn/problems/get-the-maximum-score/",
        "solutionsUrl": "https://leetcode.cn/problems/get-the-maximum-score/solution",
        "problemsDesc": "<p>你有两个 <strong>有序</strong>&nbsp;且数组内元素互不相同的数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;。</p>\n\n<p>一条&nbsp;<strong>合法路径</strong>&nbsp;定义如下：</p>\n\n<ul>\n\t<li>选择数组 nums1 或者 nums2 开始遍历（从下标 0 处开始）。</li>\n\t<li>从左到右遍历当前数组。</li>\n\t<li>如果你遇到了 <code>nums1</code>&nbsp;和 <code>nums2</code>&nbsp;中都存在的值，那么你可以切换路径到另一个数组对应数字处继续遍历（但在合法路径中重复数字只会被统计一次）。</li>\n</ul>\n\n<p>得分定义为合法路径中不同数字的和。</p>\n\n<p>请你返回所有可能合法路径中的最大得分。</p>\n\n<p>由于答案可能很大，请你将它对 10^9 + 7 取余后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/02/sample_1_1893.png\" style=\"height: 163px; width: 538px;\"></strong></p>\n\n<pre><strong>输入：</strong>nums1 = [2,4,5,8,10], nums2 = [4,6,8,9]\n<strong>输出：</strong>30\n<strong>解释：</strong>合法路径包括：\n[2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10],（从 nums1 开始遍历）\n[4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10]  （从 nums2 开始遍历）\n最大得分为上图中的绿色路径 <strong>[2,4,6,8,10]</strong>&nbsp;。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [1,3,5,7,9], nums2 = [3,5,100]\n<strong>输出：</strong>109\n<strong>解释：</strong>最大得分由路径 <strong>[1,3,5,100]</strong> 得到。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10]\n<strong>输出：</strong>40\n<strong>解释：</strong>nums1 和 nums2 之间无相同数字。\n最大得分由路径 <strong>[6,7,8,9,10]</strong> 得到。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [1,4,5,8,9,11,19], nums2 = [2,3,4,11,12]\n<strong>输出：</strong>61\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= nums2.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10^7</code></li>\n\t<li><code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;都是严格递增的数组。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1538找出隐藏数组中出现次数最多的元素",
        "hardRate": "MEDIUM",
        "passRate": "56.90%",
        "problemsUrl": "https://leetcode.cn/problems/guess-the-majority-in-a-hidden-array/",
        "solutionsUrl": "https://leetcode.cn/problems/guess-the-majority-in-a-hidden-array/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1539第 k 个缺失的正整数",
        "hardRate": "EASY",
        "passRate": "54.03%",
        "problemsUrl": "https://leetcode.cn/problems/kth-missing-positive-number/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-missing-positive-number/solution",
        "problemsDesc": "<p>给你一个 <strong>严格升序排列</strong>&nbsp;的正整数数组 <code>arr</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>请你找到这个数组里第&nbsp;<code>k</code>&nbsp;个缺失的正整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [2,3,4,7,11], k = 5\n<strong>输出：</strong>9\n<strong>解释：</strong>缺失的正整数包括 [1,5,6,8,9,10,12,13,...] 。第 5 个缺失的正整数为 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,4], k = 2\n<strong>输出：</strong>6\n<strong>解释：</strong>缺失的正整数包括 [5,6,7,...] 。第 2 个缺失的正整数为 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= k &lt;= 1000</code></li>\n\t<li>对于所有&nbsp;<code>1 &lt;= i &lt; j &lt;= arr.length</code>&nbsp;的 <code>i</code>&nbsp;和 <code>j</code> 满足&nbsp;<code>arr[i] &lt; arr[j]</code>&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<p>你可以设计一个时间复杂度小于 O(n) 的算法解决此问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1540K 次操作转变字符串",
        "hardRate": "MEDIUM",
        "passRate": "33.45%",
        "problemsUrl": "https://leetcode.cn/problems/can-convert-string-in-k-moves/",
        "solutionsUrl": "https://leetcode.cn/problems/can-convert-string-in-k-moves/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>s</code>&nbsp;和&nbsp;<code>t</code>&nbsp;，你的目标是在 <code>k</code>&nbsp;次操作以内把字符串&nbsp;<code>s</code>&nbsp;转变成&nbsp;<code>t</code>&nbsp;。</p>\n\n<p>在第 <code>i</code>&nbsp;次操作时（<code>1 &lt;= i &lt;= k</code>），你可以选择进行如下操作：</p>\n\n<ul>\n\t<li>选择字符串 <code>s</code>&nbsp;中满足 <code>1 &lt;= j &lt;= s.length</code>&nbsp;且之前未被选过的任意下标 <code>j</code>&nbsp;（下标从 1 开始），并将此位置的字符切换 <code>i</code>&nbsp;次。</li>\n\t<li>不进行任何操作。</li>\n</ul>\n\n<p>切换 1 个字符的意思是用字母表中该字母的下一个字母替换它（字母表环状接起来，所以 <code>'z'</code>&nbsp;切换后会变成 <code>'a'</code>）。第 <code>i</code>&nbsp;次操作意味着该字符应切换&nbsp;<code>i</code>&nbsp;次</p>\n\n<p>请记住任意一个下标 <code>j</code>&nbsp;最多只能被操作&nbsp;1 次。</p>\n\n<p>如果在不超过 <code>k</code>&nbsp;次操作内可以把字符串 <code>s</code>&nbsp;转变成 <code>t</code>&nbsp;，那么请你返回&nbsp;<code>true</code>&nbsp;，否则请你返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"input\", t = \"ouput\", k = 9\n<strong>输出：</strong>true\n<strong>解释：</strong>第 6 次操作时，我们将 'i' 切换 6 次得到 'o' 。第 7 次操作时，我们将 'n' 切换 7 次得到 'u' 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\", t = \"bcd\", k = 10\n<strong>输出：</strong>false\n<strong>解释：</strong>我们需要将每个字符切换 1 次才能得到 t 。我们可以在第 1 次操作时将 'a' 切换成 'b' ，但另外 2 个字母在剩余操作中无法再转变为 t 中对应字母。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aab\", t = \"bbb\", k = 27\n<strong>输出：</strong>true\n<strong>解释：</strong>第 1 次操作时，我们将第一个 'a' 切换 1 次得到 'b' 。在第 27 次操作时，我们将第二个字母 'a' 切换 27 次得到 'b' 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= k &lt;= 10^9</code></li>\n\t<li><code>s</code>&nbsp;和&nbsp;<code>t</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1541平衡括号字符串的最少插入次数",
        "hardRate": "MEDIUM",
        "passRate": "48.79%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/solution",
        "problemsDesc": "<p>给你一个括号字符串&nbsp;<code>s</code>&nbsp;，它只包含字符&nbsp;<code>&#39;(&#39;</code> 和&nbsp;<code>&#39;)&#39;</code>&nbsp;。一个括号字符串被称为平衡的当它满足：</p>\n\n<ul>\n\t<li>任何左括号&nbsp;<code>&#39;(&#39;</code>&nbsp;必须对应两个连续的右括号&nbsp;<code>&#39;))&#39;</code>&nbsp;。</li>\n\t<li>左括号&nbsp;<code>&#39;(&#39;</code>&nbsp;必须在对应的连续两个右括号&nbsp;<code>&#39;))&#39;</code>&nbsp;之前。</li>\n</ul>\n\n<p>比方说&nbsp;<code>&quot;())&quot;</code>，&nbsp;<code>&quot;())(())))&quot;</code> 和&nbsp;<code>&quot;(())())))&quot;</code>&nbsp;都是平衡的，&nbsp;<code>&quot;)()&quot;</code>，&nbsp;<code>&quot;()))&quot;</code> 和&nbsp;<code>&quot;(()))&quot;</code>&nbsp;都是不平衡的。</p>\n\n<p>你可以在任意位置插入字符 &#39;(&#39; 和 &#39;)&#39; 使字符串平衡。</p>\n\n<p>请你返回让 <code>s</code>&nbsp;平衡的最少插入次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;(()))&quot;\n<strong>输出：</strong>1\n<strong>解释：</strong>第二个左括号有与之匹配的两个右括号，但是第一个左括号只有一个右括号。我们需要在字符串结尾额外增加一个 &#39;)&#39; 使字符串变成平衡字符串 &quot;(())))&quot; 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;())&quot;\n<strong>输出：</strong>0\n<strong>解释：</strong>字符串已经平衡了。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;))())(&quot;\n<strong>输出：</strong>3\n<strong>解释：</strong>添加 &#39;(&#39; 去匹配最开头的 &#39;))&#39; ，然后添加 &#39;))&#39; 去匹配最后一个 &#39;(&#39; 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;((((((&quot;\n<strong>输出：</strong>12\n<strong>解释：</strong>添加 12 个 &#39;)&#39; 得到平衡字符串。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;)))))))&quot;\n<strong>输出：</strong>5\n<strong>解释：</strong>在字符串开头添加 4 个 &#39;(&#39; 并在结尾添加 1 个 &#39;)&#39; ，字符串变成平衡字符串 &quot;(((())))))))&quot; 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>s</code>&nbsp;只包含&nbsp;<code>&#39;(&#39;</code> 和&nbsp;<code>&#39;)&#39;</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1542找出最长的超赞子字符串",
        "hardRate": "HARD",
        "passRate": "43.90%",
        "problemsUrl": "https://leetcode.cn/problems/find-longest-awesome-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/find-longest-awesome-substring/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 。请返回 <code>s</code> 中最长的 <strong>超赞子字符串</strong> 的长度。</p>\n\n<p>「超赞子字符串」需满足满足下述两个条件：</p>\n\n<ul>\n\t<li>该字符串是 <code>s</code> 的一个非空子字符串</li>\n\t<li>进行任意次数的字符交换后，该字符串可以变成一个回文字符串</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;3242415&quot;\n<strong>输出：</strong>5\n<strong>解释：</strong>&quot;24241&quot; 是最长的超赞子字符串，交换其中的字符后，可以得到回文 &quot;24142&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;12345678&quot;\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;213123&quot;\n<strong>输出：</strong>6\n<strong>解释：</strong>&quot;213123&quot; 是最长的超赞子字符串，交换其中的字符后，可以得到回文 &quot;231132&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;00&quot;\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>s</code> 仅由数字组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1543产品名称格式修复",
        "hardRate": "EASY",
        "passRate": "55.34%",
        "problemsUrl": "https://leetcode.cn/problems/fix-product-name-format/",
        "solutionsUrl": "https://leetcode.cn/problems/fix-product-name-format/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1544整理字符串",
        "hardRate": "EASY",
        "passRate": "55.96%",
        "problemsUrl": "https://leetcode.cn/problems/make-the-string-great/",
        "solutionsUrl": "https://leetcode.cn/problems/make-the-string-great/solution",
        "problemsDesc": "<p>给你一个由大小写英文字母组成的字符串 <code>s</code> 。</p>\n\n<p>一个整理好的字符串中，两个相邻字符 <code>s[i]</code> 和 <code>s[i+1]</code>，其中 <code>0<= i <= s.length-2</code> ，要满足如下条件:</p>\n\n<ul>\n\t<li>若 <code>s[i]</code> 是小写字符，则 <code>s[i+1]</code> 不可以是相同的大写字符。</li>\n\t<li>若 <code>s[i]</code> 是大写字符，则 <code>s[i+1]</code> 不可以是相同的小写字符。</li>\n</ul>\n\n<p>请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 <strong>两个相邻</strong> 字符并删除，直到字符串整理好为止。</p>\n\n<p>请返回整理好的 <strong>字符串</strong> 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。</p>\n\n<p><strong>注意：</strong>空字符串也属于整理好的字符串，尽管其中没有任何字符。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"leEeetcode\"\n<strong>输出：</strong>\"leetcode\"\n<strong>解释：</strong>无论你第一次选的是 i = 1 还是 i = 2，都会使 \"leEeetcode\" 缩减为 \"leetcode\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abBAcC\"\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>存在多种不同情况，但所有的情况都会导致相同的结果。例如：\n\"abBAcC\" --> \"aAcC\" --> \"cC\" --> \"\"\n\"abBAcC\" --> \"abBA\" --> \"aA\" --> \"\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"s\"\n<strong>输出：</strong>\"s\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 100</code></li>\n\t<li><code>s</code> 只包含小写和大写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1545找出第 N 个二进制字符串中的第 K 位",
        "hardRate": "MEDIUM",
        "passRate": "59.00%",
        "problemsUrl": "https://leetcode.cn/problems/find-kth-bit-in-nth-binary-string/",
        "solutionsUrl": "https://leetcode.cn/problems/find-kth-bit-in-nth-binary-string/solution",
        "problemsDesc": "<p>给你两个正整数 <code>n</code> 和 <code>k</code>，二进制字符串  <code>S<sub>n</sub></code> 的形成规则如下：</p>\n\n<ul>\n\t<li><code>S<sub>1</sub> = \"0\"</code></li>\n\t<li>当 <code>i > 1</code> 时，<code>S<sub>i</sub> = S<sub>i-1</sub> + \"1\" + reverse(invert(S<sub>i-1</sub>))</code></li>\n</ul>\n\n<p>其中 <code>+</code> 表示串联操作，<code>reverse(x)</code> 返回反转 <code>x</code> 后得到的字符串，而 <code>invert(x)</code> 则会翻转 x 中的每一位（0 变为 1，而 1 变为 0）。</p>\n\n<p>例如，符合上述描述的序列的前 4 个字符串依次是：</p>\n\n<ul>\n\t<li><code>S<sub>1 </sub>= \"0\"</code></li>\n\t<li><code>S<sub>2 </sub>= \"0<strong>1</strong>1\"</code></li>\n\t<li><code>S<sub>3 </sub>= \"011<strong>1</strong>001\"</code></li>\n\t<li><code>S<sub>4</sub> = \"0111001<strong>1</strong>0110001\"</code></li>\n</ul>\n\n<p>请你返回  <code>S<sub>n</sub></code> 的 <strong>第 <code>k</code> 位字符</strong> ，题目数据保证 <code>k</code> 一定在 <code>S<sub>n</sub></code> 长度范围以内。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 1\n<strong>输出：</strong>\"0\"\n<strong>解释：</strong>S<sub>3</sub> 为 \"<strong>0</strong>111001\"，其第 1 位为 \"0\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, k = 11\n<strong>输出：</strong>\"1\"\n<strong>解释：</strong>S<sub>4</sub> 为 \"0111001101<strong>1</strong>0001\"，其第 11 位为 \"1\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, k = 1\n<strong>输出：</strong>\"0\"\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, k = 3\n<strong>输出：</strong>\"1\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 20</code></li>\n\t<li><code>1 <= k <= 2<sup>n</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1546和为目标值且不重叠的非空子数组的最大数目",
        "hardRate": "MEDIUM",
        "passRate": "44.80%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>target</code>&nbsp;。</p>\n\n<p>请你返回&nbsp;<strong>非空不重叠</strong>&nbsp;子数组的最大数目，且每个子数组中数字和都为 <code>target</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,1,1,1], target = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>总共有 2 个不重叠子数组（加粗数字表示） [<strong>1,1</strong>,1,<strong>1,1</strong>] ，它们的和为目标值 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [-1,3,5,1,4,2,-9], target = 6\n<strong>输出：</strong>2\n<strong>解释：</strong>总共有 3 个子数组和为 6 。\n([5,1], [4,2], [3,5,1,4,2,-9]) 但只有前 2 个是不重叠的。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [-2,6,6,3,5,4,1,2,8], target = 10\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,0,0], target = 0\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;=&nbsp;10^5</code></li>\n\t<li><code>-10^4 &lt;= nums[i] &lt;=&nbsp;10^4</code></li>\n\t<li><code>0 &lt;= target &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1547切棍子的最小成本",
        "hardRate": "HARD",
        "passRate": "56.62%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-cut-a-stick/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-cut-a-stick/solution",
        "problemsDesc": "<p>有一根长度为 <code>n</code> 个单位的木棍，棍上从 <code>0</code> 到 <code>n</code> 标记了若干位置。例如，长度为 <strong>6</strong> 的棍子可以标记如下：</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/09/statement.jpg\" style=\"height: 111px; width: 521px;\" /></p>\n\n<p>给你一个整数数组 <code>cuts</code> ，其中 <code>cuts[i]</code> 表示你需要将棍子切开的位置。</p>\n\n<p>你可以按顺序完成切割，也可以根据需要更改切割的顺序。</p>\n\n<p>每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是历次切割成本的总和。对棍子进行切割将会把一根木棍分成两根较小的木棍（这两根木棍的长度和就是切割前木棍的长度）。请参阅第一个示例以获得更直观的解释。</p>\n\n<p>返回切棍子的 <strong>最小总成本</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/09/e1.jpg\" style=\"height: 284px; width: 350px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 7, cuts = [1,3,4,5]\n<strong>输出：</strong>16\n<strong>解释：</strong>按 [1, 3, 4, 5] 的顺序切割的情况如下所示：\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/09/e11.jpg\" style=\"height: 284px; width: 350px;\" />\n第一次切割长度为 7 的棍子，成本为 7 。第二次切割长度为 6 的棍子（即第一次切割得到的第二根棍子），第三次切割为长度 4 的棍子，最后切割长度为 3 的棍子。总成本为 7 + 6 + 4 + 3 = 20 。\n而将切割顺序重新排列为 [3, 5, 1, 4] 后，总成本 = 16（如示例图中 7 + 4 + 3 + 2 = 16）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 9, cuts = [5,6,1,4,2]\n<strong>输出：</strong>22\n<strong>解释：</strong>如果按给定的顺序切割，则总成本为 25 。总成本 <= 25 的切割顺序很多，例如，[4, 6, 5, 2, 1] 的总成本 = 22，是所有可能方案中成本最小的。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 10^6</code></li>\n\t<li><code>1 <= cuts.length <= min(n - 1, 100)</code></li>\n\t<li><code>1 <= cuts[i] <= n - 1</code></li>\n\t<li><code>cuts</code> 数组中的所有整数都 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1548图中最相似的路径",
        "hardRate": "HARD",
        "passRate": "67.98%",
        "problemsUrl": "https://leetcode.cn/problems/the-most-similar-path-in-a-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/the-most-similar-path-in-a-graph/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1549每件商品的最新订单",
        "hardRate": "MEDIUM",
        "passRate": "67.68%",
        "problemsUrl": "https://leetcode.cn/problems/the-most-recent-orders-for-each-product/",
        "solutionsUrl": "https://leetcode.cn/problems/the-most-recent-orders-for-each-product/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1550存在连续三个奇数的数组",
        "hardRate": "EASY",
        "passRate": "65.59%",
        "problemsUrl": "https://leetcode.cn/problems/three-consecutive-odds/",
        "solutionsUrl": "https://leetcode.cn/problems/three-consecutive-odds/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code>，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,6,4,1]\n<strong>输出：</strong>false\n<strong>解释：</strong>不存在连续三个元素都是奇数的情况。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,34,3,4,5,7,23,12]\n<strong>输出：</strong>true\n<strong>解释：</strong>存在连续三个元素都是奇数的情况，即 [5,7,23] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1551使数组中所有元素相等的最小操作数",
        "hardRate": "MEDIUM",
        "passRate": "82.14%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-array-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-array-equal/solution",
        "problemsDesc": "<p>存在一个长度为 <code>n</code> 的数组 <code>arr</code> ，其中 <code>arr[i] = (2 * i) + 1</code> （ <code>0 &lt;= i &lt; n</code> ）。</p>\n\n<p>一次操作中，你可以选出两个下标，记作 <code>x</code> 和 <code>y</code> （ <code>0 &lt;= x, y &lt; n</code> ）并使 <code>arr[x]</code> 减去 <code>1</code> 、<code>arr[y]</code> 加上 <code>1</code> （即 <code>arr[x] -=1 </code>且 <code>arr[y] += 1</code> ）。最终的目标是使数组中的所有元素都 <strong>相等</strong> 。题目测试用例将会 <strong>保证</strong> ：在执行若干步操作后，数组中的所有元素最终可以全部相等。</p>\n\n<p>给你一个整数 <code>n</code>，即数组的长度。请你返回使数组 <code>arr</code> 中所有元素相等所需的 <strong>最小操作数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>arr = [1, 3, 5]\n第一次操作选出 x = 2 和 y = 0，使数组变为 [2, 3, 4]\n第二次操作继续选出 x = 2 和 y = 0，数组将会变成 [3, 3, 3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 6\n<strong>输出：</strong>9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1552两球之间的磁力",
        "hardRate": "MEDIUM",
        "passRate": "56.84%",
        "problemsUrl": "https://leetcode.cn/problems/magnetic-force-between-two-balls/",
        "solutionsUrl": "https://leetcode.cn/problems/magnetic-force-between-two-balls/solution",
        "problemsDesc": "<p>在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有&nbsp;<code>n</code>&nbsp;个空的篮子，第&nbsp;<code>i</code>&nbsp;个篮子的位置在&nbsp;<code>position[i]</code>&nbsp;，Morty&nbsp;想把&nbsp;<code>m</code>&nbsp;个球放到这些篮子里，使得任意两球间&nbsp;<strong>最小磁力</strong>&nbsp;最大。</p>\n\n<p>已知两个球如果分别位于&nbsp;<code>x</code>&nbsp;和&nbsp;<code>y</code>&nbsp;，那么它们之间的磁力为&nbsp;<code>|x - y|</code>&nbsp;。</p>\n\n<p>给你一个整数数组&nbsp;<code>position</code>&nbsp;和一个整数&nbsp;<code>m</code>&nbsp;，请你返回最大化的最小磁力。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/16/q3v1.jpg\" style=\"height: 195px; width: 562px;\"></p>\n\n<pre><strong>输入：</strong>position = [1,2,3,4,7], m = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>将 3 个球分别放入位于 1，4 和 7 的三个篮子，两球间的磁力分别为 [3, 3, 6]。最小磁力为 3 。我们没办法让最小磁力大于 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>position = [5,4,3,2,1,1000000000], m = 2\n<strong>输出：</strong>999999999\n<strong>解释：</strong>我们使用位于 1 和 1000000000 的篮子时最小磁力最大。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == position.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= position[i] &lt;= 10^9</code></li>\n\t<li>所有&nbsp;<code>position</code>&nbsp;中的整数 <strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>2 &lt;= m &lt;= position.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1553吃掉 N 个橘子的最少天数",
        "hardRate": "HARD",
        "passRate": "32.43%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-days-to-eat-n-oranges/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-days-to-eat-n-oranges/solution",
        "problemsDesc": "<p>厨房里总共有 <code>n</code>&nbsp;个橘子，你决定每一天选择如下方式之一吃这些橘子：</p>\n\n<ul>\n\t<li>吃掉一个橘子。</li>\n\t<li>如果剩余橘子数 <code>n</code>&nbsp;能被 2 整除，那么你可以吃掉 <code>n/2</code> 个橘子。</li>\n\t<li>如果剩余橘子数&nbsp;<code>n</code>&nbsp;能被 3 整除，那么你可以吃掉 <code>2*(n/3)</code> 个橘子。</li>\n</ul>\n\n<p>每天你只能从以上 3 种方案中选择一种方案。</p>\n\n<p>请你返回吃掉所有 <code>n</code>&nbsp;个橘子的最少天数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 10\n<strong>输出：</strong>4\n<strong>解释：</strong>你总共有 10 个橘子。\n第 1 天：吃 1 个橘子，剩余橘子数 10 - 1 = 9。\n第 2 天：吃 6 个橘子，剩余橘子数 9 - 2*(9/3) = 9 - 6 = 3。（9 可以被 3 整除）\n第 3 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。\n第 4 天：吃掉最后 1 个橘子，剩余橘子数 1 - 1 = 0。\n你需要至少 4 天吃掉 10 个橘子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 6\n<strong>输出：</strong>3\n<strong>解释：</strong>你总共有 6 个橘子。\n第 1 天：吃 3 个橘子，剩余橘子数 6 - 6/2 = 6 - 3 = 3。（6 可以被 2 整除）\n第 2 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。（3 可以被 3 整除）\n第 3 天：吃掉剩余 1 个橘子，剩余橘子数 1 - 1 = 0。\n你至少需要 3 天吃掉 6 个橘子。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 56\n<strong>输出：</strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2*10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1554只有一个不同字符的字符串",
        "hardRate": "MEDIUM",
        "passRate": "49.92%",
        "problemsUrl": "https://leetcode.cn/problems/strings-differ-by-one-character/",
        "solutionsUrl": "https://leetcode.cn/problems/strings-differ-by-one-character/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1555银行账户概要",
        "hardRate": "MEDIUM",
        "passRate": "44.92%",
        "problemsUrl": "https://leetcode.cn/problems/bank-account-summary/",
        "solutionsUrl": "https://leetcode.cn/problems/bank-account-summary/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1556千位分隔数",
        "hardRate": "EASY",
        "passRate": "56.14%",
        "problemsUrl": "https://leetcode.cn/problems/thousand-separator/",
        "solutionsUrl": "https://leetcode.cn/problems/thousand-separator/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>，请你每隔三位添加点（即 &quot;.&quot; 符号）作为千位分隔符，并将结果以字符串格式返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 987\n<strong>输出：</strong>&quot;987&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 1234\n<strong>输出：</strong>&quot;1.234&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 123456789\n<strong>输出：</strong>&quot;123.456.789&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 0\n<strong>输出：</strong>&quot;0&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt; 2^31</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1557可以到达所有点的最少点数目",
        "hardRate": "MEDIUM",
        "passRate": "81.51%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-vertices-to-reach-all-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-vertices-to-reach-all-nodes/solution",
        "problemsDesc": "<p>给你一个 <strong>有向无环图</strong>&nbsp;， <code>n</code>&nbsp;个节点编号为 <code>0</code>&nbsp;到 <code>n-1</code>&nbsp;，以及一个边数组 <code>edges</code>&nbsp;，其中 <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>]</code>&nbsp;表示一条从点&nbsp;&nbsp;<code>from<sub>i</sub></code>&nbsp;到点&nbsp;<code>to<sub>i</sub></code>&nbsp;的有向边。</p>\n\n<p>找到最小的点集使得从这些点出发能到达图中所有点。题目保证解存在且唯一。</p>\n\n<p>你可以以任意顺序返回这些节点编号。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5480e1.png\" style=\"height: 181px; width: 231px;\"></p>\n\n<pre><strong>输入：</strong>n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]\n<strong>输出：</strong>[0,3]\n<strong>解释：</strong>从单个节点出发无法到达所有节点。从 0 出发我们可以到达 [0,1,2,5] 。从 3 出发我们可以到达 [3,4,2,5] 。所以我们输出 [0,3] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5480e2.png\" style=\"height: 201px; width: 201px;\"></p>\n\n<pre><strong>输入：</strong>n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]]\n<strong>输出：</strong>[0,2,3]\n<strong>解释：</strong>注意到节点 0，3 和 2 无法从其他节点到达，所以我们必须将它们包含在结果点集中，这些点都能到达节点 1 和 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= min(10^5, n * (n - 1) / 2)</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= from<sub>i,</sub>&nbsp;to<sub>i</sub> &lt; n</code></li>\n\t<li>所有点对&nbsp;<code>(from<sub>i</sub>, to<sub>i</sub>)</code>&nbsp;互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1558得到目标数组的最少函数调用次数",
        "hardRate": "MEDIUM",
        "passRate": "62.97%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-numbers-of-function-calls-to-make-target-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-numbers-of-function-calls-to-make-target-array/solution",
        "problemsDesc": "<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/10/sample_2_1887.png\" style=\"height:294px; width:573px\" /></p>\n\n<p>给你一个与 <code>nums</code>&nbsp;大小相同且初始值全为 0 的数组 <code>arr</code> ，请你调用以上函数得到整数数组 <code>nums</code>&nbsp;。</p>\n\n<p>请你返回将 <code>arr</code>&nbsp;变成 <code>nums</code>&nbsp;的最少函数调用次数。</p>\n\n<p>答案保证在 32 位有符号整数以内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5]\n<strong>输出：</strong>5\n<strong>解释：</strong>给第二个数加 1 ：[0, 0] 变成 [0, 1] （1 次操作）。\n将所有数字乘以 2 ：[0, 1] -&gt; [0, 2] -&gt; [0, 4] （2 次操作）。\n给两个数字都加 1 ：[0, 4] -&gt; [1, 4] -&gt; <strong>[1, 5]</strong> （2 次操作）。\n总操作次数为：1 + 2 + 2 = 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2]\n<strong>输出：</strong>3\n<strong>解释：</strong>给两个数字都加 1 ：[0, 0] -&gt; [0, 1] -&gt; [1, 1] （2 次操作）。\n将所有数字乘以 2 ： [1, 1] -&gt; <strong>[2, 2]</strong> （1 次操作）。\n总操作次数为： 2 + 1 = 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,2,5]\n<strong>输出：</strong>6\n<strong>解释：</strong>（初始）[0,0,0] -&gt; [1,0,0] -&gt; [1,0,1] -&gt; [2,0,2] -&gt; [2,1,2] -&gt; [4,2,4] -&gt; <strong>[4,2,5] </strong>（nums 数组）。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,2,4]\n<strong>输出：</strong>7\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,4,8,16]\n<strong>输出：</strong>8\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1559二维网格图中探测环",
        "hardRate": "MEDIUM",
        "passRate": "40.61%",
        "problemsUrl": "https://leetcode.cn/problems/detect-cycles-in-2d-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/detect-cycles-in-2d-grid/solution",
        "problemsDesc": "<p>给你一个二维字符网格数组&nbsp;<code>grid</code>&nbsp;，大小为&nbsp;<code>m x n</code>&nbsp;，你需要检查&nbsp;<code>grid</code>&nbsp;中是否存在 <strong>相同值</strong> 形成的环。</p>\n\n<p>一个环是一条开始和结束于同一个格子的长度 <strong>大于等于 4</strong>&nbsp;的路径。对于一个给定的格子，你可以移动到它上、下、左、右四个方向相邻的格子之一，可以移动的前提是这两个格子有 <strong>相同的值&nbsp;</strong>。</p>\n\n<p>同时，你也不能回到上一次移动时所在的格子。比方说，环&nbsp;&nbsp;<code>(1, 1) -&gt; (1, 2) -&gt; (1, 1)</code>&nbsp;是不合法的，因为从 <code>(1, 2)</code>&nbsp;移动到 <code>(1, 1)</code> 回到了上一次移动时的格子。</p>\n\n<p>如果 <code>grid</code>&nbsp;中有相同值形成的环，请你返回 <code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e1.png\" style=\"height: 152px; width: 231px;\"></strong></p>\n\n<pre><strong>输入：</strong>grid = [[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]]\n<strong>输出：</strong>true\n<strong>解释：</strong>如下图所示，有 2 个用不同颜色标出来的环：\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e11.png\" style=\"height: 163px; width: 225px;\">\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e2.png\" style=\"height: 154px; width: 236px;\"></strong></p>\n\n<pre><strong>输入：</strong>grid = [[&quot;c&quot;,&quot;c&quot;,&quot;c&quot;,&quot;a&quot;],[&quot;c&quot;,&quot;d&quot;,&quot;c&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;c&quot;,&quot;e&quot;,&quot;c&quot;],[&quot;f&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]]\n<strong>输出：</strong>true\n<strong>解释：</strong>如下图所示，只有高亮所示的一个合法环：\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e22.png\" style=\"height: 157px; width: 229px;\">\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e3.png\" style=\"height: 120px; width: 183px;\"></strong></p>\n\n<pre><strong>输入：</strong>grid = [[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;z&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;b&quot;,&quot;a&quot;]]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m &lt;= 500</code></li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>grid</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1560圆形赛道上经过次数最多的扇区",
        "hardRate": "EASY",
        "passRate": "57.44%",
        "problemsUrl": "https://leetcode.cn/problems/most-visited-sector-in-a-circular-track/",
        "solutionsUrl": "https://leetcode.cn/problems/most-visited-sector-in-a-circular-track/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> 和一个整数数组 <code>rounds</code> 。有一条圆形赛道由 <code>n</code> 个扇区组成，扇区编号从 <code>1</code> 到 <code>n</code> 。现将在这条赛道上举办一场马拉松比赛，该马拉松全程由 <code>m</code> 个阶段组成。其中，第 <code>i</code> 个阶段将会从扇区 <code>rounds[i - 1]</code> 开始，到扇区 <code>rounds[i]</code> 结束。举例来说，第 <code>1</code> 阶段从&nbsp;<code>rounds[0]</code>&nbsp;开始，到&nbsp;<code>rounds[1]</code>&nbsp;结束。</p>\n\n<p>请你以数组形式返回经过次数最多的那几个扇区，按扇区编号 <strong>升序</strong> 排列。</p>\n\n<p>注意，赛道按扇区编号升序逆时针形成一个圆（请参见第一个示例）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/3rd45e.jpg\" style=\"height: 341px; width: 433px;\"></p>\n\n<pre><strong>输入：</strong>n = 4, rounds = [1,3,1,2]\n<strong>输出：</strong>[1,2]\n<strong>解释：</strong>本场马拉松比赛从扇区 1 开始。经过各个扇区的次序如下所示：\n1 --&gt; 2 --&gt; 3（阶段 1 结束）--&gt; 4 --&gt; 1（阶段 2 结束）--&gt; 2（阶段 3 结束，即本场马拉松结束）\n其中，扇区 1 和 2 都经过了两次，它们是经过次数最多的两个扇区。扇区 3 和 4 都只经过了一次。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, rounds = [2,1,2,1,2,1,2,1,2]\n<strong>输出：</strong>[2]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 7, rounds = [1,3,5,7]\n<strong>输出：</strong>[1,2,3,4,5,6,7]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= m &lt;= 100</code></li>\n\t<li><code>rounds.length == m + 1</code></li>\n\t<li><code>1 &lt;= rounds[i] &lt;= n</code></li>\n\t<li><code>rounds[i] != rounds[i + 1]</code> ，其中 <code>0 &lt;= i &lt; m</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1561你可以获得的最大硬币数目",
        "hardRate": "MEDIUM",
        "passRate": "77.76%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-coins-you-can-get/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-coins-you-can-get/solution",
        "problemsDesc": "<p>有 3n 堆数目不一的硬币，你和你的朋友们打算按以下方式分硬币：</p>\n\n<ul>\n\t<li>每一轮中，你将会选出 <strong>任意</strong> 3 堆硬币（不一定连续）。</li>\n\t<li>Alice 将会取走硬币数量最多的那一堆。</li>\n\t<li>你将会取走硬币数量第二多的那一堆。</li>\n\t<li>Bob 将会取走最后一堆。</li>\n\t<li>重复这个过程，直到没有更多硬币。</li>\n</ul>\n\n<p>给你一个整数数组 <code>piles</code> ，其中 <code>piles[i]</code> 是第 <code>i</code> 堆中硬币的数目。</p>\n\n<p>返回你可以获得的最大硬币数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>piles = [2,4,1,2,7,8]\n<strong>输出：</strong>9\n<strong>解释：</strong>选出 (2, 7, 8) ，Alice 取走 8 枚硬币的那堆，你取走 <strong>7</strong> 枚硬币的那堆，Bob 取走最后一堆。\n选出 (1, 2, 4) , Alice 取走 4 枚硬币的那堆，你取走 <strong>2</strong> 枚硬币的那堆，Bob 取走最后一堆。\n你可以获得的最大硬币数目：7 + 2 = 9.\n考虑另外一种情况，如果选出的是 (1, <strong>2</strong>, 8) 和 (2, <strong>4</strong>, 7) ，你就只能得到 2 + 4 = 6 枚硬币，这不是最优解。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>piles = [2,4,5]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>piles = [9,8,7,6,5,1,2,3,4]\n<strong>输出：</strong>18\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= piles.length &lt;= 10^5</code></li>\n\t<li><code>piles.length % 3 == 0</code></li>\n\t<li><code>1 &lt;= piles[i] &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1562查找大小为 M 的最新分组",
        "hardRate": "MEDIUM",
        "passRate": "36.58%",
        "problemsUrl": "https://leetcode.cn/problems/find-latest-group-of-size-m/",
        "solutionsUrl": "https://leetcode.cn/problems/find-latest-group-of-size-m/solution",
        "problemsDesc": "<p>给你一个数组 <code>arr</code> ，该数组表示一个从 <code>1</code> 到 <code>n</code> 的数字排列。有一个长度为 <code>n</code> 的二进制字符串，该字符串上的所有位最初都设置为 <code>0</code> 。</p>\n\n<p>在从 <code>1</code> 到 <code>n</code> 的每个步骤 <code>i</code> 中（假设二进制字符串和 <code>arr</code> 都是从 <code>1</code> 开始索引的情况下），二进制字符串上位于位置 <code>arr[i]</code> 的位将会设为 <code>1</code> 。</p>\n\n<p>给你一个整数 <code>m</code> ，请你找出二进制字符串上存在长度为 <code>m</code> 的一组 <code>1</code> 的最后步骤。一组 <code>1</code> 是一个连续的、由 <code>1</code> 组成的子串，且左右两边不再有可以延伸的 <code>1</code> 。</p>\n\n<p>返回存在长度 <strong>恰好</strong> 为 <code>m</code> 的 <strong>一组 <code>1</code>&nbsp;</strong> 的最后步骤。如果不存在这样的步骤，请返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,5,1,2,4], m = 1\n<strong>输出：</strong>4\n<strong>解释：\n</strong>步骤 1：&quot;00<strong>1</strong>00&quot;，由 1 构成的组：[&quot;1&quot;]\n步骤 2：&quot;0010<strong>1</strong>&quot;，由 1 构成的组：[&quot;1&quot;, &quot;1&quot;]\n步骤 3：&quot;<strong>1</strong>0101&quot;，由 1 构成的组：[&quot;1&quot;, &quot;1&quot;, &quot;1&quot;]\n步骤 4：&quot;1<strong>1</strong>101&quot;，由 1 构成的组：[&quot;111&quot;, &quot;1&quot;]\n步骤 5：&quot;111<strong>1</strong>1&quot;，由 1 构成的组：[&quot;11111&quot;]\n存在长度为 1 的一组 1 的最后步骤是步骤 4 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,1,5,4,2], m = 2\n<strong>输出：</strong>-1\n<strong>解释：\n</strong>步骤 1：&quot;00<strong>1</strong>00&quot;，由 1 构成的组：[&quot;1&quot;]\n步骤 2：&quot;<strong>1</strong>0100&quot;，由 1 构成的组：[&quot;1&quot;, &quot;1&quot;]\n步骤 3：&quot;1010<strong>1</strong>&quot;，由 1 构成的组：[&quot;1&quot;, &quot;1&quot;, &quot;1&quot;]\n步骤 4：&quot;101<strong>1</strong>1&quot;，由 1 构成的组：[&quot;1&quot;, &quot;111&quot;]\n步骤 5：&quot;1<strong>1</strong>111&quot;，由 1 构成的组：[&quot;11111&quot;]\n不管是哪一步骤都无法形成长度为 2 的一组 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1], m = 1\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,1], m = 2\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == arr.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= n</code></li>\n\t<li><code>arr</code> 中的所有整数 <strong>互不相同</strong></li>\n\t<li><code>1 &lt;= m&nbsp;&lt;= arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1563石子游戏 V",
        "hardRate": "HARD",
        "passRate": "39.67%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game-v/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game-v/solution",
        "problemsDesc": "<p>几块石子 <strong>排成一行</strong> ，每块石子都有一个关联值，关联值为整数，由数组 <code>stoneValue</code> 给出。</p>\n\n<p>游戏中的每一轮：Alice 会将这行石子分成两个 <strong>非空行</strong>（即，左侧行和右侧行）；Bob 负责计算每一行的值，即此行中所有石子的值的总和。Bob 会丢弃值最大的行，Alice 的得分为剩下那行的值（每轮累加）。如果两行的值相等，Bob 让 Alice 决定丢弃哪一行。下一轮从剩下的那一行开始。</p>\n\n<p>只 <strong>剩下一块石子</strong> 时，游戏结束。Alice 的分数最初为 <strong><code>0</code></strong> 。</p>\n\n<p>返回 <strong>Alice 能够获得的最大分数</strong><em> 。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>stoneValue = [6,2,3,4,5,5]\n<strong>输出：</strong>18\n<strong>解释：</strong>在第一轮中，Alice 将行划分为 [6，2，3]，[4，5，5] 。左行的值是 11 ，右行的值是 14 。Bob 丢弃了右行，Alice 的分数现在是 11 。\n在第二轮中，Alice 将行分成 [6]，[2，3] 。这一次 Bob 扔掉了左行，Alice 的分数变成了 16（11 + 5）。\n最后一轮 Alice 只能将行分成 [2]，[3] 。Bob 扔掉右行，Alice 的分数现在是 18（16 + 2）。游戏结束，因为这行只剩下一块石头了。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>stoneValue = [7,7,7,7,7,7,7]\n<strong>输出：</strong>28\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>stoneValue = [4]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= stoneValue.length &lt;= 500</code></li>\n\t<li><code>1 &lt;=&nbsp;stoneValue[i] &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1564把箱子放进仓库里 I",
        "hardRate": "MEDIUM",
        "passRate": "57.88%",
        "problemsUrl": "https://leetcode.cn/problems/put-boxes-into-the-warehouse-i/",
        "solutionsUrl": "https://leetcode.cn/problems/put-boxes-into-the-warehouse-i/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1565按月统计订单数与顾客数",
        "hardRate": "EASY",
        "passRate": "73.85%",
        "problemsUrl": "https://leetcode.cn/problems/unique-orders-and-customers-per-month/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-orders-and-customers-per-month/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1566重复至少 K 次且长度为 M 的模式",
        "hardRate": "EASY",
        "passRate": "44.25%",
        "problemsUrl": "https://leetcode.cn/problems/detect-pattern-of-length-m-repeated-k-or-more-times/",
        "solutionsUrl": "https://leetcode.cn/problems/detect-pattern-of-length-m-repeated-k-or-more-times/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>arr</code>，请你找出一个长度为 <code>m</code> 且在数组中至少重复 <code>k</code> 次的模式。</p>\n\n<p><strong>模式</strong> 是由一个或多个值组成的子数组（连续的子序列），<strong>连续</strong> 重复多次但 <strong>不重叠</strong> 。 模式由其长度和重复次数定义。</p>\n\n<p>如果数组中存在至少重复 <code>k</code> 次且长度为 <code>m</code> 的模式，则返回 <code>true</code> ，否则返回&nbsp; <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,4,4,4,4], m = 1, k = 3\n<strong>输出：</strong>true\n<strong>解释：</strong>模式 <strong>(4)</strong> 的长度为 1 ，且连续重复 4 次。注意，模式可以重复 k 次或更多次，但不能少于 k 次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>模式 <strong>(1,2)</strong> 长度为 2 ，且连续重复 2 次。另一个符合题意的模式是 <strong>(2,1) </strong>，同样重复 2 次。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,1,2,1,3], m = 2, k = 3\n<strong>输出：</strong>false\n<strong>解释：</strong>模式 <strong>(1,2)</strong> 长度为 2 ，但是只连续重复 2 次。不存在长度为 2 且至少重复 3 次的模式。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,3,1,2], m = 2, k = 2\n<strong>输出：</strong>false\n<strong>解释：</strong>模式 <strong>(1,2)</strong> 出现 2 次但并不连续，所以不能算作连续重复 2 次。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,2,2,2], m = 2, k = 3\n<strong>输出：</strong>false\n<strong>解释：</strong>长度为 2 的模式只有 <strong>(2,2)</strong> ，但是只连续重复 2 次。注意，不能计算重叠的重复次数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= m&nbsp;&lt;= 100</code></li>\n\t<li><code>2 &lt;= k&nbsp;&lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1567乘积为正数的最长子数组长度",
        "hardRate": "MEDIUM",
        "passRate": "42.65%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-length-of-subarray-with-positive-product/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-length-of-subarray-with-positive-product/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>&nbsp;，请你求出乘积为正数的最长子数组的长度。</p>\n\n<p>一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。</p>\n\n<p>请你返回乘积为正数的最长子数组长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp; 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,-2,-3,4]\n<strong>输出：</strong>4\n<strong>解释：</strong>数组本身乘积就是正数，值为 24 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,-2,-3,-4]\n<strong>输出：</strong>3\n<strong>解释：</strong>最长乘积为正数的子数组为 [1,-2,-3] ，乘积为 6 。\n注意，我们不能把 0 也包括到子数组中，因为这样乘积为 0 ，不是正数。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,-2,-3,0,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>乘积为正数的最长子数组是 [-1,-2] 或者 [-2,-3] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>-10^9 &lt;= nums[i]&nbsp;&lt;= 10^9</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1568使陆地分离的最少天数",
        "hardRate": "HARD",
        "passRate": "45.01%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-days-to-disconnect-island/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-days-to-disconnect-island/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> ，由若干 <code>0</code> 和 <code>1</code> 组成的二维网格 <code>grid</code> ，其中 <code>1</code> 表示陆地， <code>0</code> 表示水。<strong>岛屿</strong> 由水平方向或竖直方向上相邻的 <code>1</code> （陆地）连接形成。</p>\n\n<p>如果 <strong>恰好只有一座岛屿 </strong>，则认为陆地是 <strong>连通的</strong> ；否则，陆地就是 <strong>分离的</strong> 。</p>\n\n<p>一天内，可以将 <strong>任何单个</strong> 陆地单元（<code>1</code>）更改为水单元（<code>0</code>）。</p>\n\n<p>返回使陆地分离的最少天数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/24/land1.jpg\" style=\"width: 500px; height: 169px;\" />\n<pre>\n<strong>输入：</strong>grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]\n<strong>输出：</strong>2\n<strong>解释：</strong>至少需要 2 天才能得到分离的陆地。\n将陆地 grid[1][1] 和 grid[0][2] 更改为水，得到两个分离的岛屿。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/24/land2.jpg\" style=\"width: 404px; height: 85px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,1]]\n<strong>输出：</strong>2\n<strong>解释：</strong>如果网格中都是水，也认为是分离的 ([[1,1]] -&gt; [[0,0]])，0 岛屿。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 30</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1569将子数组重新排序得到同一个二叉搜索树的方案数",
        "hardRate": "HARD",
        "passRate": "49.12%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-reorder-array-to-get-same-bst/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-reorder-array-to-get-same-bst/solution",
        "problemsDesc": "<p>给你一个数组 <code>nums</code>&nbsp;表示 <code>1</code>&nbsp;到 <code>n</code>&nbsp;的一个排列。我们按照元素在 <code>nums</code>&nbsp;中的顺序依次插入一个初始为空的二叉搜索树（BST）。请你统计将 <code>nums</code>&nbsp;重新排序后，统计满足如下条件的方案数：重排后得到的二叉搜索树与 <code>nums</code>&nbsp;原本数字顺序得到的二叉搜索树相同。</p>\n\n<p>比方说，给你&nbsp;<code>nums = [2,1,3]</code>，我们得到一棵 2 为根，1 为左孩子，3 为右孩子的树。数组&nbsp;<code>[2,3,1]</code>&nbsp;也能得到相同的 BST，但&nbsp;<code>[3,2,1]</code>&nbsp;会得到一棵不同的&nbsp;BST 。</p>\n\n<p>请你返回重排 <code>nums</code>&nbsp;后，与原数组 <code>nums</code> 得到相同二叉搜索树的方案数。</p>\n\n<p>由于答案可能会很大，请将结果对<strong>&nbsp;</strong><code>10^9 + 7</code>&nbsp;取余数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/bb.png\" style=\"height: 101px; width: 121px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,3]\n<strong>输出：</strong>1\n<strong>解释：</strong>我们将 nums 重排， [2,3,1] 能得到相同的 BST 。没有其他得到相同 BST 的方案了。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/ex1.png\" style=\"height: 161px; width: 241px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,5,1,2]\n<strong>输出：</strong>5\n<strong>解释：</strong>下面 5 个数组会得到相同的 BST：\n[3,1,2,4,5]\n[3,1,4,2,5]\n[3,1,4,5,2]\n[3,4,1,2,5]\n[3,4,1,5,2]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/ex4.png\" style=\"height: 161px; width: 121px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>0\n<strong>解释：</strong>没有别的排列顺序能得到相同的 BST 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>\n\t<li><code>nums</code>&nbsp;中所有数 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1570两个稀疏向量的点积",
        "hardRate": "MEDIUM",
        "passRate": "88.81%",
        "problemsUrl": "https://leetcode.cn/problems/dot-product-of-two-sparse-vectors/",
        "solutionsUrl": "https://leetcode.cn/problems/dot-product-of-two-sparse-vectors/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1571仓库经理",
        "hardRate": "EASY",
        "passRate": "77.58%",
        "problemsUrl": "https://leetcode.cn/problems/warehouse-manager/",
        "solutionsUrl": "https://leetcode.cn/problems/warehouse-manager/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1572矩阵对角线元素的和",
        "hardRate": "EASY",
        "passRate": "80.72%",
        "problemsUrl": "https://leetcode.cn/problems/matrix-diagonal-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/matrix-diagonal-sum/solution",
        "problemsDesc": "<p>给你一个正方形矩阵 <code>mat</code>，请你返回矩阵对角线元素的和。</p>\n\n<p>请你返回在矩阵主对角线上的元素和副对角线上且不在主对角线上元素的和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp; 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/14/sample_1911.png\" style=\"height:174px; width:336px\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[<strong>1</strong>,2,<strong>3</strong>],\n&nbsp;           [4,<strong>5</strong>,6],\n&nbsp;           [<strong>7</strong>,8,<strong>9</strong>]]\n<strong>输出：</strong>25\n<strong>解释：</strong>对角线的和为：1 + 5 + 9 + 3 + 7 = 25\n请注意，元素 mat[1][1] = 5 只会被计算一次。\n</pre>\n\n<p><strong>示例&nbsp; 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[<strong>1</strong>,1,1,<strong>1</strong>],\n&nbsp;           [1,<strong>1</strong>,<strong>1</strong>,1],\n&nbsp;           [1,<strong>1</strong>,<strong>1</strong>,1],\n&nbsp;           [<strong>1</strong>,1,1,<strong>1</strong>]]\n<strong>输出：</strong>8\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[<strong>5</strong>]]\n<strong>输出：</strong>5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == mat.length == mat[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= mat[i][j] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1573分割字符串的方案数",
        "hardRate": "MEDIUM",
        "passRate": "31.20%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-split-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-split-a-string/solution",
        "problemsDesc": "<p>给你一个二进制串&nbsp;<code>s</code>&nbsp; （一个只包含 0 和 1 的字符串），我们可以将 <code>s</code>&nbsp;分割成 3 个 <strong>非空</strong>&nbsp;字符串 s1, s2, s3 （s1 + s2 + s3 = s）。</p>\n\n<p>请你返回分割&nbsp;<code>s</code>&nbsp;的方案数，满足 s1，s2 和 s3 中字符 &#39;1&#39; 的数目相同。</p>\n\n<p>由于答案可能很大，请将它对 10^9 + 7 取余后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;10101&quot;\n<strong>输出：</strong>4\n<strong>解释：</strong>总共有 4 种方法将 s 分割成含有 &#39;1&#39; 数目相同的三个子字符串。\n&quot;1|010|1&quot;\n&quot;1|01|01&quot;\n&quot;10|10|1&quot;\n&quot;10|1|01&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1001&quot;\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;0000&quot;\n<strong>输出：</strong>3\n<strong>解释：</strong>总共有 3 种分割 s 的方法。\n&quot;0|0|00&quot;\n&quot;0|00|0&quot;\n&quot;00|0|0&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;100100010100110&quot;\n<strong>输出：</strong>12\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s[i] == &#39;0&#39;</code>&nbsp;或者&nbsp;<code>s[i] == &#39;1&#39;</code></li>\n\t<li><code>3 &lt;= s.length &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1574删除最短的子数组使剩余数组有序",
        "hardRate": "MEDIUM",
        "passRate": "43.21%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code>&nbsp;，请你删除一个子数组（可以为空），使得 <code>arr</code>&nbsp;中剩下的元素是 <strong>非递减</strong> 的。</p>\n\n<p>一个子数组指的是原数组中连续的一个子序列。</p>\n\n<p>请你返回满足题目要求的最短子数组的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,10,4,2,3,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>我们需要删除的最短子数组是 [10,4,2] ，长度为 3 。剩余元素形成非递减数组 [1,2,3,3,5] 。\n另一个正确的解为删除子数组 [3,10,4] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [5,4,3,2,1]\n<strong>输出：</strong>4\n<strong>解释：</strong>由于数组是严格递减的，我们只能保留一个元素。所以我们需要删除长度为 4 的子数组，要么删除 [5,4,3,2]，要么删除 [4,3,2,1]。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3]\n<strong>输出：</strong>0\n<strong>解释：</strong>数组已经是非递减的了，我们不需要删除任何元素。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1575统计所有可行路径",
        "hardRate": "HARD",
        "passRate": "57.48%",
        "problemsUrl": "https://leetcode.cn/problems/count-all-possible-routes/",
        "solutionsUrl": "https://leetcode.cn/problems/count-all-possible-routes/solution",
        "problemsDesc": "<p>给你一个 <strong>互不相同</strong>&nbsp;的整数数组，其中&nbsp;<code>locations[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个城市的位置。同时给你&nbsp;<code>start</code>，<code>finish</code>&nbsp;和&nbsp;<code>fuel</code>&nbsp;分别表示出发城市、目的地城市和你初始拥有的汽油总量</p>\n\n<p>每一步中，如果你在城市 <code>i</code>&nbsp;，你可以选择任意一个城市 <code>j</code>&nbsp;，满足 &nbsp;<code>j != i</code>&nbsp;且&nbsp;<code>0 &lt;= j &lt; locations.length</code>&nbsp;，并移动到城市&nbsp;<code>j</code>&nbsp;。从城市&nbsp;<code>i</code>&nbsp;移动到&nbsp;<code>j</code>&nbsp;消耗的汽油量为&nbsp;<code>|locations[i] - locations[j]|</code>，<code>|x|</code>&nbsp;表示&nbsp;<code>x</code>&nbsp;的绝对值。</p>\n\n<p>请注意，&nbsp;<code>fuel</code>&nbsp;任何时刻都&nbsp;<strong>不能</strong>&nbsp;为负，且你&nbsp;<strong>可以</strong>&nbsp;经过任意城市超过一次（包括&nbsp;<code>start</code>&nbsp;和&nbsp;<code>finish</code>&nbsp;）。</p>\n\n<p>请你返回从<em>&nbsp;</em><code>start</code>&nbsp;到&nbsp;<code>finish</code>&nbsp;所有可能路径的数目。</p>\n\n<p>由于答案可能很大， 请将它对&nbsp;<code>10^9 + 7</code>&nbsp;取余后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5\n<strong>输出：</strong>4\n<strong>解释：</strong>以下为所有可能路径，每一条都用了 5 单位的汽油：\n1 -&gt; 3\n1 -&gt; 2 -&gt; 3\n1 -&gt; 4 -&gt; 3\n1 -&gt; 4 -&gt; 2 -&gt; 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>locations = [4,3,1], start = 1, finish = 0, fuel = 6\n<strong>输出：</strong>5\n<strong>解释：</strong>以下为所有可能的路径：\n1 -&gt; 0，使用汽油量为 fuel = 1\n1 -&gt; 2 -&gt; 0，使用汽油量为 fuel = 5\n1 -&gt; 2 -&gt; 1 -&gt; 0，使用汽油量为 fuel = 5\n1 -&gt; 0 -&gt; 1 -&gt; 0，使用汽油量为 fuel = 3\n1 -&gt; 0 -&gt; 1 -&gt; 0 -&gt; 1 -&gt; 0，使用汽油量为 fuel = 5\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>locations = [5,2,1], start = 0, finish = 2, fuel = 3\n<strong>输出：</strong>0\n<strong>解释：</strong>没有办法只用 3 单位的汽油从 0 到达 2 。因为最短路径需要 4 单位的汽油。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= locations.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= locations[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>所有&nbsp;<code>locations</code>&nbsp;中的整数 <strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>0 &lt;= start, finish &lt;&nbsp;locations.length</code></li>\n\t<li><code>1 &lt;= fuel &lt;= 200</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1576替换所有的问号",
        "hardRate": "EASY",
        "passRate": "50.94%",
        "problemsUrl": "https://leetcode.cn/problems/replace-all-s-to-avoid-consecutive-repeating-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/replace-all-s-to-avoid-consecutive-repeating-characters/solution",
        "problemsDesc": "<p>给你一个仅包含小写英文字母和 <code>'?'</code> 字符的字符串 <code>s</code>，请你将所有的 <code>'?'</code> 转换为若干小写字母，使最终的字符串不包含任何 <strong>连续重复</strong> 的字符。</p>\n\n<p>注意：你 <strong>不能</strong> 修改非 <code>'?'</code> 字符。</p>\n\n<p>题目测试用例保证 <strong>除</strong> <code>'?'</code> 字符 <strong>之外</strong>，不存在连续重复的字符。</p>\n\n<p>在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"?zs\"\n<strong>输出：</strong>\"azs\"\n<strong>解释：</strong>该示例共有 25 种解决方案，从 \"azs\" 到 \"yzs\" 都是符合题目要求的。只有 \"z\" 是无效的修改，因为字符串 \"zzs\" 中有连续重复的两个 'z' 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ubv?w\"\n<strong>输出：</strong>\"ubvaw\"\n<strong>解释：</strong>该示例共有 24 种解决方案，只有替换成 \"v\" 和 \"w\" 不符合题目要求。因为 \"ubvvw\" 和 \"ubvww\" 都包含连续重复的字符。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>\n\t<p><code>1 &lt;= s.length&nbsp;&lt;= 100</code></p>\n\t</li>\n\t<li>\n\t<p><code>s</code> 仅包含小写英文字母和 <code>'?'</code> 字符</p>\n\t</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1577数的平方等于两数乘积的方法数",
        "hardRate": "MEDIUM",
        "passRate": "34.62%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/solution",
        "problemsDesc": "<p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，请你返回根据以下规则形成的三元组的数目（类型 1 和类型 2 ）：</p>\n\n<ul>\n\t<li>类型 1：三元组 <code>(i, j, k)</code> ，如果 <code>nums1[i]<sup>2</sup>&nbsp;== nums2[j] * nums2[k]</code> 其中 <code>0 &lt;= i &lt; nums1.length</code> 且 <code>0 &lt;= j &lt; k &lt; nums2.length</code></li>\n\t<li>类型 2：三元组 <code>(i, j, k)</code> ，如果 <code>nums2[i]<sup>2</sup>&nbsp;== nums1[j] * nums1[k]</code> 其中 <code>0 &lt;= i &lt; nums2.length</code> 且 <code>0 &lt;= j &lt; k &lt; nums1.length</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [7,4], nums2 = [5,2,8,9]\n<strong>输出：</strong>1\n<strong>解释：</strong>类型 1：(1,1,2), nums1[1]^2 = nums2[1] * nums2[2] (4^2 = 2 * 8)</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [1,1], nums2 = [1,1,1]\n<strong>输出：</strong>9\n<strong>解释：</strong>所有三元组都符合题目要求，因为 1^2 = 1 * 1\n类型 1：(0,0,1), (0,0,2), (0,1,2), (1,0,1), (1,0,2), (1,1,2), nums1[i]^2 = nums2[j] * nums2[k]\n类型 2：(0,0,1), (1,0,1), (2,0,1), nums2[i]^2 = nums1[j] * nums1[k]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [7,7,8,3], nums2 = [1,2,9,7]\n<strong>输出：</strong>2\n<strong>解释：</strong>有两个符合题目要求的三元组\n类型 1：(3,0,2), nums1[3]^2 = nums2[0] * nums2[2]\n类型 2：(3,0,1), nums2[3]^2 = nums1[0] * nums1[1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [4,7,9,11,23], nums2 = [3,5,1024,12,18]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在符合题目要求的三元组\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1578使绳子变成彩色的最短时间",
        "hardRate": "MEDIUM",
        "passRate": "59.66%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-make-rope-colorful/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-make-rope-colorful/solution",
        "problemsDesc": "<p>Alice 把 <code>n</code> 个气球排列在一根绳子上。给你一个下标从 <strong>0</strong> 开始的字符串 <code>colors</code> ，其中 <code>colors[i]</code> 是第 <code>i</code> 个气球的颜色。</p>\n\n<p>Alice 想要把绳子装扮成 <strong>彩色</strong> ，且她不希望两个连续的气球涂着相同的颜色，所以她喊来 Bob 帮忙。Bob 可以从绳子上移除一些气球使绳子变成 <strong>彩色</strong> 。给你一个下标从 <strong>0</strong> 开始的整数数组 <code>neededTime</code> ，其中 <code>neededTime[i]</code> 是 Bob 从绳子上移除第 <code>i</code> 个气球需要的时间（以秒为单位）。</p>\n\n<p>返回 Bob 使绳子变成 <strong>彩色</strong> 需要的 <strong>最少时间</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/13/ballon1.jpg\" style=\"width: 404px; height: 243px;\" />\n<pre>\n<strong>输入：</strong>colors = \"abaac\", neededTime = [1,2,3,4,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>在上图中，'a' 是蓝色，'b' 是红色且 'c' 是绿色。\nBob 可以移除下标 2 的蓝色气球。这将花费 3 秒。\n移除后，不存在两个连续的气球涂着相同的颜色。总时间 = 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/13/balloon2.jpg\" style=\"width: 244px; height: 243px;\" />\n<pre>\n<strong>输入：</strong>colors = \"abc\", neededTime = [1,2,3]\n<strong>输出：</strong>0\n<strong>解释：</strong>绳子已经是彩色的，Bob 不需要从绳子上移除任何气球。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/13/balloon3.jpg\" style=\"width: 404px; height: 243px;\" />\n<pre>\n<strong>输入：</strong>colors = \"aabaa\", neededTime = [1,2,3,4,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>Bob 会移除下标 0 和下标 4 处的气球。这两个气球各需要 1 秒来移除。\n移除后，不存在两个连续的气球涂着相同的颜色。总时间 = 1 + 1 = 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == colors.length == neededTime.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= neededTime[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>colors</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1579保证图可完全遍历",
        "hardRate": "HARD",
        "passRate": "62.07%",
        "problemsUrl": "https://leetcode.cn/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/solution",
        "problemsDesc": "<p>Alice 和 Bob 共有一个无向图，其中包含 n 个节点和 3&nbsp; 种类型的边：</p>\n\n<ul>\n\t<li>类型 1：只能由 Alice 遍历。</li>\n\t<li>类型 2：只能由 Bob 遍历。</li>\n\t<li>类型 3：Alice 和 Bob 都可以遍历。</li>\n</ul>\n\n<p>给你一个数组 <code>edges</code> ，其中 <code>edges[i] = [type<sub>i</sub>, u<sub>i</sub>, v<sub>i</sub>]</code>&nbsp;表示节点 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code> 之间存在类型为 <code>type<sub>i</sub></code> 的双向边。请你在保证图仍能够被 Alice和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。</p>\n\n<p>返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/06/5510ex1.png\" style=\"height: 191px; width: 179px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]\n<strong>输出：</strong>2\n<strong>解释：</strong>如果删除<strong> </strong>[1,1,2] 和 [1,1,3] 这两条边，Alice 和 Bob 仍然可以完全遍历这个图。再删除任何其他的边都无法保证图可以完全遍历。所以可以删除的最大边数是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/06/5510ex2.png\" style=\"height: 190px; width: 178px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]\n<strong>输出：</strong>0\n<strong>解释：</strong>注意，删除任何一条边都会使 Alice 和 Bob 无法完全遍历这个图。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/06/5510ex3.png\" style=\"height: 190px; width: 178px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>在当前图中，Alice 无法从其他节点到达节点 4 。类似地，Bob 也不能达到节点 1 。因此，图无法完全遍历。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= min(10^5, 3 * n * (n-1) / 2)</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>1 &lt;= edges[i][0] &lt;= 3</code></li>\n\t<li><code>1 &lt;= edges[i][1] &lt; edges[i][2] &lt;= n</code></li>\n\t<li>所有元组 <code>(type<sub>i</sub>, u<sub>i</sub>, v<sub>i</sub>)</code> 互不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1580把箱子放进仓库里 II",
        "hardRate": "MEDIUM",
        "passRate": "59.61%",
        "problemsUrl": "https://leetcode.cn/problems/put-boxes-into-the-warehouse-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/put-boxes-into-the-warehouse-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1581进店却未进行过交易的顾客",
        "hardRate": "EASY",
        "passRate": "79.46%",
        "problemsUrl": "https://leetcode.cn/problems/customer-who-visited-but-did-not-make-any-transactions/",
        "solutionsUrl": "https://leetcode.cn/problems/customer-who-visited-but-did-not-make-any-transactions/solution",
        "problemsDesc": "<p>表：<code>Visits</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| visit_id    | int     |\n| customer_id | int     |\n+-------------+---------+\nvisit_id 是该表的主键。\n该表包含有关光临过购物中心的顾客的信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>表：<code>Transactions</code></p>\n\n<pre>\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| transaction_id | int     |\n| visit_id       | int     |\n| amount         | int     |\n+----------------+---------+\ntransaction_id 是此表的主键。\n此表包含 visit_id 期间进行的交易的信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>有一些顾客可能光顾了购物中心但没有进行交易。请你编写一个 SQL 查询，来查找这些顾客的 ID ，以及他们只光顾不交易的次数。</p>\n\n<p>返回以 <strong>任何顺序</strong> 排序的结果表。</p>\n\n<p>查询结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<code><strong>输入:</strong>\nVisits</code>\n+----------+-------------+\n| visit_id | customer_id |\n+----------+-------------+\n| 1        | 23          |\n| 2        | 9           |\n| 4        | 30          |\n| 5        | 54          |\n| 6        | 96          |\n| 7        | 54          |\n| 8        | 54          |\n+----------+-------------+\n<code>Transactions</code>\n+----------------+----------+--------+\n| transaction_id | visit_id | amount |\n+----------------+----------+--------+\n| 2              | 5        | 310    |\n| 3              | 5        | 300    |\n| 9              | 5        | 200    |\n| 12             | 1        | 910    |\n| 13             | 2        | 970    |\n+----------------+----------+--------+\n<b>输出:</b>\n+-------------+----------------+\n| customer_id | count_no_trans |\n+-------------+----------------+\n| 54          | 2              |\n| 30          | 1              |\n| 96          | 1              |\n+-------------+----------------+\n<b>解释:</b>\nID = 23 的顾客曾经逛过一次购物中心，并在 ID = 12 的访问期间进行了一笔交易。\nID = 9 的顾客曾经逛过一次购物中心，并在 ID = 13 的访问期间进行了一笔交易。\nID = 30 的顾客曾经去过购物中心，并且没有进行任何交易。\nID = 54 的顾客三度造访了购物中心。在 2 次访问中，他们没有进行任何交易，在 1 次访问中，他们进行了 3 次交易。\nID = 96 的顾客曾经去过购物中心，并且没有进行任何交易。\n如我们所见，ID 为 30 和 96 的顾客一次没有进行任何交易就去了购物中心。顾客 54 也两次访问了购物中心并且没有进行任何交易。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1582二进制矩阵中的特殊位置",
        "hardRate": "EASY",
        "passRate": "69.47%",
        "problemsUrl": "https://leetcode.cn/problems/special-positions-in-a-binary-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/special-positions-in-a-binary-matrix/solution",
        "problemsDesc": "<p>给你一个大小为 <code>rows x cols</code> 的矩阵 <code>mat</code>，其中 <code>mat[i][j]</code> 是 <code>0</code> 或 <code>1</code>，请返回 <strong>矩阵&nbsp;<em><code>mat</code></em> 中特殊位置的数目</strong> 。</p>\n\n<p><strong>特殊位置</strong> 定义：如果 <code>mat[i][j] == 1</code> 并且第 <code>i</code> 行和第 <code>j</code> 列中的所有其他元素均为 <code>0</code>（行和列的下标均 <strong>从 0 开始</strong> ），则位置 <code>(i, j)</code> 被称为特殊位置。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[1,0,0],\n&nbsp;           [0,0,<strong>1</strong>],\n&nbsp;           [1,0,0]]\n<strong>输出：</strong>1\n<strong>解释：</strong>(1,2) 是一个特殊位置，因为 mat[1][2] == 1 且所处的行和列上所有其他元素都是 0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[<strong>1</strong>,0,0],\n&nbsp;           [0,<strong>1</strong>,0],\n&nbsp;           [0,0,<strong>1</strong>]]\n<strong>输出：</strong>3\n<strong>解释：</strong>(0,0), (1,1) 和 (2,2) 都是特殊位置\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[0,0,0,<strong>1</strong>],\n&nbsp;           [<strong>1</strong>,0,0,0],\n&nbsp;           [0,1,1,0],\n&nbsp;           [0,0,0,0]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[0,0,0,0,0],\n&nbsp;           [<strong>1</strong>,0,0,0,0],\n&nbsp;           [0,<strong>1</strong>,0,0,0],\n&nbsp;           [0,0,<strong>1</strong>,0,0],\n&nbsp;           [0,0,0,1,1]]\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rows == mat.length</code></li>\n\t<li><code>cols == mat[i].length</code></li>\n\t<li><code>1 &lt;= rows, cols &lt;= 100</code></li>\n\t<li><code>mat[i][j]</code> 是 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1583统计不开心的朋友",
        "hardRate": "MEDIUM",
        "passRate": "67.91%",
        "problemsUrl": "https://leetcode.cn/problems/count-unhappy-friends/",
        "solutionsUrl": "https://leetcode.cn/problems/count-unhappy-friends/solution",
        "problemsDesc": "<p>给你一份 <code>n</code> 位朋友的亲近程度列表，其中 <code>n</code> 总是 <strong>偶数</strong> 。</p>\n\n<p>对每位朋友 <code>i</code>，<code>preferences[i]</code> 包含一份 <strong>按亲近程度从高</strong><strong>到低排列</strong> 的朋友列表。换句话说，排在列表前面的朋友与 <code>i</code> 的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以 <code>0</code> 到 <code>n-1</code> 之间的整数表示。</p>\n\n<p>所有的朋友被分成几对，配对情况以列表 <code>pairs</code> 给出，其中 <code>pairs[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示 <code>x<sub>i</sub></code> 与 <code>y<sub>i</sub></code> 配对，且 <code>y<sub>i</sub></code> 与 <code>x<sub>i</sub></code> 配对。</p>\n\n<p>但是，这样的配对情况可能会使其中部分朋友感到不开心。在 <code>x</code> 与 <code>y</code> 配对且 <code>u</code> 与 <code>v</code> 配对的情况下，如果同时满足下述两个条件，<code>x</code> 就会不开心：</p>\n\n<ul>\n\t<li><code>x</code> 与 <code>u</code> 的亲近程度胜过 <code>x</code> 与 <code>y</code>，且</li>\n\t<li><code>u</code> 与 <code>x</code> 的亲近程度胜过 <code>u</code> 与 <code>v</code></li>\n</ul>\n\n<p>返回 <strong>不开心的朋友的数目</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n朋友 1 不开心，因为：\n- <strong>1 与 0 </strong>配对，但 <strong>1 与 3</strong> 的亲近程度比 <strong>1 与 0</strong> 高，且\n- <strong>3 与 1</strong> 的亲近程度比 <strong>3 与 2</strong> 高。\n朋友 3 不开心，因为：\n- 3 与 2 配对，但 <strong>3 与 1</strong> 的亲近程度比 <strong>3 与 2</strong> 高，且\n- <strong>1 与 3</strong> 的亲近程度比 <strong>1 与 0</strong> 高。\n朋友 0 和 2 都是开心的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, preferences = [[1], [0]], pairs = [[1, 0]]\n<strong>输出：</strong>0\n<strong>解释：</strong>朋友 0 和 1 都开心。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]]\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 500</code></li>\n\t<li><code>n</code> 是偶数</li>\n\t<li><code>preferences.length&nbsp;== n</code></li>\n\t<li><code>preferences[i].length&nbsp;== n - 1</code></li>\n\t<li><code>0 &lt;= preferences[i][j] &lt;= n - 1</code></li>\n\t<li><code>preferences[i]</code> 不包含 <code>i</code></li>\n\t<li><code>preferences[i]</code> 中的所有值都是独一无二的</li>\n\t<li><code>pairs.length&nbsp;== n/2</code></li>\n\t<li><code>pairs[i].length&nbsp;== 2</code></li>\n\t<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= n - 1</code></li>\n\t<li>每位朋友都 <strong>恰好</strong> 被包含在一对中</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1584连接所有点的最小费用",
        "hardRate": "MEDIUM",
        "passRate": "65.67%",
        "problemsUrl": "https://leetcode.cn/problems/min-cost-to-connect-all-points/",
        "solutionsUrl": "https://leetcode.cn/problems/min-cost-to-connect-all-points/solution",
        "problemsDesc": "<p>给你一个<code>points</code>&nbsp;数组，表示 2D 平面上的一些点，其中&nbsp;<code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;。</p>\n\n<p>连接点&nbsp;<code>[x<sub>i</sub>, y<sub>i</sub>]</code> 和点&nbsp;<code>[x<sub>j</sub>, y<sub>j</sub>]</code>&nbsp;的费用为它们之间的 <strong>曼哈顿距离</strong>&nbsp;：<code>|x<sub>i</sub> - x<sub>j</sub>| + |y<sub>i</sub> - y<sub>j</sub>|</code>&nbsp;，其中&nbsp;<code>|val|</code>&nbsp;表示&nbsp;<code>val</code>&nbsp;的绝对值。</p>\n\n<p>请你返回将所有点连接的最小总费用。只有任意两点之间 <strong>有且仅有</strong>&nbsp;一条简单路径时，才认为所有点都已连接。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/26/d.png\" style=\"height:268px; width:214px; background:#e5e5e5\" /></p>\n\n<pre>\n<strong>输入：</strong>points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\n<strong>输出：</strong>20\n<strong>解释：\n</strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/26/c.png\" style=\"height:268px; width:214px; background:#e5e5e5\" />\n我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。\n注意到任意两个点之间只有唯一一条路径互相到达。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[3,12],[-2,5],[-4,1]]\n<strong>输出：</strong>18\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[0,0],[1,1],[1,0],[-1,1]]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[-1000000,-1000000],[1000000,1000000]]\n<strong>输出：</strong>4000000\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[0,0]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= points.length &lt;= 1000</code></li>\n\t<li><code>-10<sup>6</sup>&nbsp;&lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n\t<li>所有点&nbsp;<code>(x<sub>i</sub>, y<sub>i</sub>)</code>&nbsp;两两不同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1585检查字符串是否可以通过排序子字符串得到另一个字符串",
        "hardRate": "HARD",
        "passRate": "43.50%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-string-is-transformable-with-substring-sort-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-string-is-transformable-with-substring-sort-operations/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>s</code> 和&nbsp;<code>t</code>&nbsp;，请你通过若干次以下操作将字符串&nbsp;<code>s</code>&nbsp;转化成字符串&nbsp;<code>t</code>&nbsp;：</p>\n\n<ul>\n\t<li>选择 <code>s</code>&nbsp;中一个 <strong>非空</strong>&nbsp;子字符串并将它包含的字符就地 <strong>升序</strong>&nbsp;排序。</li>\n</ul>\n\n<p>比方说，对下划线所示的子字符串进行操作可以由&nbsp;<code>&quot;1<strong>4234</strong>&quot;</code>&nbsp;得到&nbsp;<code>&quot;1<strong>2344</strong>&quot;</code>&nbsp;。</p>\n\n<p>如果可以将字符串 <code>s</code>&nbsp;变成 <code>t</code>&nbsp;，返回 <code>true</code>&nbsp;。否则，返回 <code>false</code>&nbsp;。</p>\n\n<p>一个 <strong>子字符串</strong>&nbsp;定义为一个字符串中连续的若干字符。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;84532&quot;, t = &quot;34852&quot;\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以按以下操作将 s 转变为 t ：\n&quot;84<strong>53</strong>2&quot; （从下标 2 到下标 3）-&gt; &quot;84<strong>35</strong>2&quot;\n&quot;<strong>843</strong>52&quot; （从下标 0 到下标 2） -&gt; &quot;<strong>348</strong>52&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;34521&quot;, t = &quot;23415&quot;\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以按以下操作将 s 转变为 t ：\n&quot;<strong>3452</strong>1&quot; -&gt; &quot;<strong>2345</strong>1&quot;\n&quot;234<strong>51</strong>&quot; -&gt; &quot;234<strong>15</strong>&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;12345&quot;, t = &quot;12435&quot;\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;1&quot;, t = &quot;2&quot;\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s.length == t.length</code></li>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 和&nbsp;<code>t</code>&nbsp;都只包含数字字符，即&nbsp;<code>&#39;0&#39;</code>&nbsp;到&nbsp;<code>&#39;9&#39;</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1586二叉搜索树迭代器 II",
        "hardRate": "MEDIUM",
        "passRate": "63.03%",
        "problemsUrl": "https://leetcode.cn/problems/binary-search-tree-iterator-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-search-tree-iterator-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1587银行账户概要 II",
        "hardRate": "EASY",
        "passRate": "80.10%",
        "problemsUrl": "https://leetcode.cn/problems/bank-account-summary-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/bank-account-summary-ii/solution",
        "problemsDesc": "<p>表: <code>Users</code></p>\n\n<pre>+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| account      | int     |\n| name         | varchar |\n+--------------+---------+\naccount 是该表的主键.\n表中的每一行包含银行里中每一个用户的账号.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>表: <code>Transactions</code></p>\n\n<pre>+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| trans_id      | int     |\n| account       | int     |\n| amount        | int     |\n| transacted_on | date    |\n+---------------+---------+\ntrans_id 是该表主键.\n该表的每一行包含了所有账户的交易改变情况.\n如果用户收到了钱, 那么金额是正的; 如果用户转了钱, 那么金额是负的.\n所有账户的起始余额为 0.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一个 SQL,&nbsp;&nbsp;报告余额高于 10000 的所有用户的名字和余额.&nbsp;账户的余额等于包含该账户的所有交易的总和.</p>\n\n<p>返回结果表单没有顺序要求.</p>\n\n<p>查询结果格式如下例所示.</p>\n\n<p>&nbsp;</p>\n\n<pre><code>Users</code> table:\n+------------+--------------+\n| account    | name         |\n+------------+--------------+\n| 900001     | Alice        |\n| 900002     | Bob          |\n| 900003     | Charlie      |\n+------------+--------------+\n\n<code>Transactions</code> table:\n+------------+------------+------------+---------------+\n| trans_id   | account    | amount     | transacted_on |\n+------------+------------+------------+---------------+\n| 1          | 900001     | 7000       |  2020-08-01   |\n| 2          | 900001     | 7000       |  2020-09-01   |\n| 3          | 900001     | -3000      |  2020-09-02   |\n| 4          | 900002     | 1000       |  2020-09-12   |\n| 5          | 900003     | 6000       |  2020-08-07   |\n| 6          | 900003     | 6000       |  2020-09-07   |\n| 7          | 900003     | -4000      |  2020-09-11   |\n+------------+------------+------------+---------------+\n\nResult table:\n+------------+------------+\n| <code>name    </code>   | <code>balance  </code>  |\n+------------+------------+\n| Alice      | 11000      |\n+------------+------------+\nAlice 的余额为(7000 + 7000 - 3000) = 11000.\nBob 的余额为1000.\nCharlie 的余额为(6000 + 6000 - 4000) = 8000.\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1588所有奇数长度子数组的和",
        "hardRate": "EASY",
        "passRate": "83.22%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-all-odd-length-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-all-odd-length-subarrays/solution",
        "problemsDesc": "<p>给你一个正整数数组&nbsp;<code>arr</code>&nbsp;，请你计算所有可能的奇数长度子数组的和。</p>\n\n<p><strong>子数组</strong> 定义为原数组中的一个连续子序列。</p>\n\n<p>请你返回 <code>arr</code>&nbsp;中 <strong>所有奇数长度子数组的和</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,4,2,5,3]\n<strong>输出：</strong>58\n<strong>解释：</strong>所有奇数长度子数组和它们的和为：\n[1] = 1\n[4] = 4\n[2] = 2\n[5] = 5\n[3] = 3\n[1,4,2] = 7\n[4,2,5] = 11\n[2,5,3] = 10\n[1,4,2,5,3] = 15\n我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2]\n<strong>输出：</strong>3\n<strong>解释：</strong>总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [10,11,12]\n<strong>输出：</strong>66\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<p>你可以设计一个 O(n) 时间复杂度的算法解决此问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1589所有排列中的最大和",
        "hardRate": "MEDIUM",
        "passRate": "32.39%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-obtained-of-any-permutation/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-obtained-of-any-permutation/solution",
        "problemsDesc": "<p>有一个整数数组&nbsp;<code>nums</code>&nbsp;，和一个查询数组&nbsp;<code>requests</code>&nbsp;，其中&nbsp;<code>requests[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>&nbsp;。第&nbsp;<code>i</code>&nbsp;个查询求&nbsp;<code>nums[start<sub>i</sub>] + nums[start<sub>i</sub> + 1] + ... + nums[end<sub>i</sub> - 1] + nums[end<sub>i</sub>]</code>&nbsp;的结果&nbsp;，<code>start<sub>i</sub></code> 和&nbsp;<code>end<sub>i</sub></code>&nbsp;数组索引都是 <strong>从 0 开始</strong> 的。</p>\n\n<p>你可以任意排列 <code>nums</code>&nbsp;中的数字，请你返回所有查询结果之和的最大值。</p>\n\n<p>由于答案可能会很大，请你将它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,5], requests = [[1,3],[0,1]]\n<strong>输出：</strong>19\n<strong>解释：</strong>一个可行的 nums 排列为 [2,1,3,4,5]，并有如下结果：\nrequests[0] -&gt; nums[1] + nums[2] + nums[3] = 1 + 3 + 4 = 8\nrequests[1] -&gt; nums[0] + nums[1] = 2 + 1 = 3\n总和为：8 + 3 = 11。\n一个总和更大的排列为 [3,5,4,2,1]，并有如下结果：\nrequests[0] -&gt; nums[1] + nums[2] + nums[3] = 5 + 4 + 2 = 11\nrequests[1] -&gt; nums[0] + nums[1] = 3 + 5  = 8\n总和为： 11 + 8 = 19，这个方案是所有排列中查询之和最大的结果。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,5,6], requests = [[0,1]]\n<strong>输出：</strong>11\n<strong>解释：</strong>一个总和最大的排列为 [6,5,4,3,2,1] ，查询和为 [11]。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,5,10], requests = [[0,2],[1,3],[1,1]]\n<strong>输出：</strong>47\n<strong>解释：</strong>一个和最大的排列为 [4,10,5,3,2,1] ，查询结果分别为 [19,18,10]。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i]&nbsp;&lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= requests.length &lt;=&nbsp;10<sup>5</sup></code></li>\n\t<li><code>requests[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub>&nbsp;&lt;= end<sub>i</sub>&nbsp;&lt;&nbsp;n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1590使数组和能被 P 整除",
        "hardRate": "MEDIUM",
        "passRate": "36.39%",
        "problemsUrl": "https://leetcode.cn/problems/make-sum-divisible-by-p/",
        "solutionsUrl": "https://leetcode.cn/problems/make-sum-divisible-by-p/solution",
        "problemsDesc": "<p>给你一个正整数数组&nbsp;<code>nums</code>，请你移除 <strong>最短</strong>&nbsp;子数组（可以为 <strong>空</strong>），使得剩余元素的 <strong>和</strong>&nbsp;能被 <code>p</code>&nbsp;整除。 <strong>不允许</strong>&nbsp;将整个数组都移除。</p>\n\n<p>请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 <code>-1</code>&nbsp;。</p>\n\n<p><strong>子数组</strong>&nbsp;定义为原数组中连续的一组元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,1,4,2], p = 6\n<strong>输出：</strong>1\n<strong>解释：</strong>nums 中元素和为 10，不能被 p 整除。我们可以移除子数组 [4] ，剩余元素的和为 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [6,3,5,2], p = 9\n<strong>输出：</strong>2\n<strong>解释：</strong>我们无法移除任何一个元素使得和被 9 整除，最优方案是移除子数组 [5,2] ，剩余元素为 [6,3]，和为 9 。\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3], p = 3\n<strong>输出：</strong>0\n<strong>解释：</strong>和恰好为 6 ，已经能被 3 整除了。所以我们不需要移除任何元素。\n</pre>\n\n<p><strong>示例&nbsp; 4：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3], p = 7\n<strong>输出：</strong>-1\n<strong>解释：</strong>没有任何方案使得移除子数组后剩余元素的和被 7 整除。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1000000000,1000000000,1000000000], p = 3\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= p &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1591奇怪的打印机 II",
        "hardRate": "HARD",
        "passRate": "63.75%",
        "problemsUrl": "https://leetcode.cn/problems/strange-printer-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/strange-printer-ii/solution",
        "problemsDesc": "<p>给你一个奇怪的打印机，它有如下两个特殊的打印规则：</p>\n\n<ul>\n\t<li>每一次操作时，打印机会用同一种颜色打印一个矩形的形状，每次打印会覆盖矩形对应格子里原本的颜色。</li>\n\t<li>一旦矩形根据上面的规则使用了一种颜色，那么 <strong>相同的颜色不能再被使用&nbsp;</strong>。</li>\n</ul>\n\n<p>给你一个初始没有颜色的&nbsp;<code>m x n</code>&nbsp;的矩形&nbsp;<code>targetGrid</code>&nbsp;，其中&nbsp;<code>targetGrid[row][col]</code>&nbsp;是位置&nbsp;<code>(row, col)</code>&nbsp;的颜色。</p>\n\n<p>如果你能按照上述规则打印出矩形<em>&nbsp;</em><code>targetGrid</code>&nbsp;，请你返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/19/sample_1_1929.png\" style=\"height: 138px; width: 483px;\"></p>\n\n<pre><strong>输入：</strong>targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/19/sample_2_1929.png\" style=\"height: 290px; width: 483px;\"></p>\n\n<pre><strong>输入：</strong>targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>targetGrid = [[1,2,1],[2,1,2],[1,2,1]]\n<strong>输出：</strong>false\n<strong>解释：</strong>没有办法得到 targetGrid ，因为每一轮操作使用的颜色互不相同。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>targetGrid = [[1,1,1],[3,1,3]]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == targetGrid.length</code></li>\n\t<li><code>n == targetGrid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 60</code></li>\n\t<li><code>1 &lt;= targetGrid[row][col] &lt;= 60</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1592重新排列单词间的空格",
        "hardRate": "EASY",
        "passRate": "46.73%",
        "problemsUrl": "https://leetcode.cn/problems/rearrange-spaces-between-words/",
        "solutionsUrl": "https://leetcode.cn/problems/rearrange-spaces-between-words/solution",
        "problemsDesc": "<p>给你一个字符串 <code>text</code> ，该字符串由若干被空格包围的单词组成。每个单词由一个或者多个小写英文字母组成，并且两个单词之间至少存在一个空格。题目测试用例保证 <code>text</code> <strong>至少包含一个单词</strong> 。</p>\n\n<p>请你重新排列空格，使每对相邻单词之间的空格数目都 <strong>相等</strong> ，并尽可能 <strong>最大化</strong> 该数目。如果不能重新平均分配所有空格，请 <strong>将多余的空格放置在字符串末尾</strong> ，这也意味着返回的字符串应当与原 <code>text</code> 字符串的长度相等。</p>\n\n<p>返回 <strong>重新排列空格后的字符串</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;  this   is  a sentence &quot;\n<strong>输出：</strong>&quot;this   is   a   sentence&quot;\n<strong>解释：</strong>总共有 9 个空格和 4 个单词。可以将 9 个空格平均分配到相邻单词之间，相邻单词间空格数为：9 / (4-1) = 3 个。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot; practice   makes   perfect&quot;\n<strong>输出：</strong>&quot;practice   makes   perfect &quot;\n<strong>解释：</strong>总共有 7 个空格和 3 个单词。7 / (3-1) = 3 个空格加上 1 个多余的空格。多余的空格需要放在字符串的末尾。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;hello   world&quot;\n<strong>输出：</strong>&quot;hello   world&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;  walks  udp package   into  bar a&quot;\n<strong>输出：</strong>&quot;walks  udp  package  into  bar  a &quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;a&quot;\n<strong>输出：</strong>&quot;a&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 100</code></li>\n\t<li><code>text</code> 由小写英文字母和 <code>&#39; &#39;</code> 组成</li>\n\t<li><code>text</code> 中至少包含一个单词</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1593拆分字符串使唯一子字符串的数目最大",
        "hardRate": "MEDIUM",
        "passRate": "57.45%",
        "problemsUrl": "https://leetcode.cn/problems/split-a-string-into-the-max-number-of-unique-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/split-a-string-into-the-max-number-of-unique-substrings/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，请你拆分该字符串，并返回拆分后唯一子字符串的最大数目。</p>\n\n<p>字符串 <code>s</code> 拆分后可以得到若干 <strong>非空子字符串</strong> ，这些子字符串连接后应当能够还原为原字符串。但是拆分出来的每个子字符串都必须是 <strong>唯一的</strong> 。</p>\n\n<p>注意：<strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;ababccc&quot;\n<strong>输出：</strong>5\n<strong>解释：</strong>一种最大拆分方法为 [&#39;a&#39;, &#39;b&#39;, &#39;ab&#39;, &#39;c&#39;, &#39;cc&#39;] 。像 [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;cc&#39;] 这样拆分不满足题目要求，因为其中的 &#39;a&#39; 和 &#39;b&#39; 都出现了不止一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aba&quot;\n<strong>输出：</strong>2\n<strong>解释：</strong>一种最大拆分方法为 [&#39;a&#39;, &#39;ba&#39;] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aa&quot;\n<strong>输出：</strong>1\n<strong>解释：</strong>无法进一步拆分字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>\n\t<p><code>1 &lt;= s.length&nbsp;&lt;= 16</code></p>\n\t</li>\n\t<li>\n\t<p><code>s</code> 仅包含小写英文字母</p>\n\t</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1594矩阵的最大非负积",
        "hardRate": "MEDIUM",
        "passRate": "33.75%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-non-negative-product-in-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-non-negative-product-in-a-matrix/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的矩阵 <code>grid</code> 。最初，你位于左上角 <code>(0, 0)</code> ，每一步，你可以在矩阵中 <strong>向右</strong> 或 <strong>向下</strong> 移动。</p>\n\n<p>在从左上角 <code>(0, 0)</code> 开始到右下角 <code>(m - 1, n - 1)</code> 结束的所有路径中，找出具有 <strong>最大非负积</strong> 的路径。路径的积是沿路径访问的单元格中所有整数的乘积。</p>\n\n<p>返回 <strong>最大非负积 </strong>对<strong><em> </em><code>10<sup>9</sup>&nbsp;+ 7</code></strong> <strong>取余</strong> 的结果。如果最大积为 <strong>负数</strong> ，则返回<em> </em><code>-1</code> 。</p>\n\n<p><strong>注意，</strong>取余是在得到最大积之后执行的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/23/product1.jpg\" style=\"width: 244px; height: 245px;\" />\n<pre>\n<strong>输入：</strong>grid = [[-1,-2,-3],[-2,-3,-3],[-3,-3,-2]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>从 (0, 0) 到 (2, 2) 的路径中无法得到非负积，所以返回 -1 。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/23/product2.jpg\" style=\"width: 244px; height: 245px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,-2,1],[1,-2,1],[3,-4,1]]\n<strong>输出：</strong>8\n<strong>解释：</strong>最大非负积对应的路径如图所示 (1 * 1 * -2 * -4 * 1 = 8)\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/23/product3.jpg\" style=\"width: 164px; height: 165px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,3],[0,-4]]\n<strong>输出：</strong>0\n<strong>解释：</strong>最大非负积对应的路径如图所示 (1 * 0 * -4 = 0)\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 15</code></li>\n\t<li><code>-4 &lt;= grid[i][j] &lt;= 4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1595连通两组点的最小成本",
        "hardRate": "HARD",
        "passRate": "65.75%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-connect-two-groups-of-points/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-connect-two-groups-of-points/solution",
        "problemsDesc": "<p>给你两组点，其中第一组中有 <code>size<sub>1</sub></code> 个点，第二组中有 <code>size<sub>2</sub></code> 个点，且 <code>size<sub>1</sub> &gt;= size<sub>2</sub></code> 。</p>\n\n<p>任意两点间的连接成本 <code>cost</code> 由大小为 <code>size<sub>1</sub> x size<sub>2</sub></code> 矩阵给出，其中 <code>cost[i][j]</code> 是第一组中的点 <code>i</code> 和第二组中的点 <code>j</code> 的连接成本。<strong>如果两个组中的每个点都与另一组中的一个或多个点连接，则称这两组点是连通的。</strong>换言之，第一组中的每个点必须至少与第二组中的一个点连接，且第二组中的每个点必须至少与第一组中的一个点连接。</p>\n\n<p>返回连通两组点所需的最小成本。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/20/ex1.jpg\" style=\"height: 243px; width: 322px;\"></p>\n\n<pre><strong>输入：</strong>cost = [[15, 96], [36, 2]]\n<strong>输出：</strong>17\n<strong>解释：</strong>连通两组点的最佳方法是：\n1--A\n2--B\n总成本为 17 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/20/ex2.jpg\" style=\"height: 403px; width: 322px;\"></p>\n\n<pre><strong>输入：</strong>cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]]\n<strong>输出：</strong>4\n<strong>解释：</strong>连通两组点的最佳方法是：\n1--A\n2--B\n2--C\n3--A\n最小成本为 4 。\n请注意，虽然有多个点连接到第一组中的点 2 和第二组中的点 A ，但由于题目并不限制连接点的数目，所以只需要关心最低总成本。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]\n<strong>输出：</strong>10\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>size<sub>1</sub> == cost.length</code></li>\n\t<li><code>size<sub>2</sub> == cost[i].length</code></li>\n\t<li><code>1 &lt;= size<sub>1</sub>, size<sub>2</sub> &lt;= 12</code></li>\n\t<li><code>size<sub>1</sub> &gt;=&nbsp;size<sub>2</sub></code></li>\n\t<li><code>0 &lt;= cost[i][j] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1596每位顾客最经常订购的商品",
        "hardRate": "MEDIUM",
        "passRate": "73.31%",
        "problemsUrl": "https://leetcode.cn/problems/the-most-frequently-ordered-products-for-each-customer/",
        "solutionsUrl": "https://leetcode.cn/problems/the-most-frequently-ordered-products-for-each-customer/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1597根据中缀表达式构造二叉表达式树",
        "hardRate": "HARD",
        "passRate": "68.36%",
        "problemsUrl": "https://leetcode.cn/problems/build-binary-expression-tree-from-infix-expression/",
        "solutionsUrl": "https://leetcode.cn/problems/build-binary-expression-tree-from-infix-expression/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1598文件夹操作日志搜集器",
        "hardRate": "EASY",
        "passRate": "69.53%",
        "problemsUrl": "https://leetcode.cn/problems/crawler-log-folder/",
        "solutionsUrl": "https://leetcode.cn/problems/crawler-log-folder/solution",
        "problemsDesc": "<p>每当用户执行变更文件夹操作时，LeetCode 文件系统都会保存一条日志记录。</p>\n\n<p>下面给出对变更操作的说明：</p>\n\n<ul>\n\t<li><code>&quot;../&quot;</code> ：移动到当前文件夹的父文件夹。如果已经在主文件夹下，则 <strong>继续停留在当前文件夹</strong> 。</li>\n\t<li><code>&quot;./&quot;</code> ：继续停留在当前文件夹<strong>。</strong></li>\n\t<li><code>&quot;x/&quot;</code> ：移动到名为 <code>x</code> 的子文件夹中。题目数据 <strong>保证总是存在文件夹 <code>x</code></strong> 。</li>\n</ul>\n\n<p>给你一个字符串列表 <code>logs</code> ，其中 <code>logs[i]</code> 是用户在 <code>i<sup>th</sup></code> 步执行的操作。</p>\n\n<p>文件系统启动时位于主文件夹，然后执行 <code>logs</code> 中的操作。</p>\n\n<p>执行完所有变更文件夹操作后，请你找出 <strong>返回主文件夹所需的最小步数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/26/sample_11_1957.png\" style=\"height: 151px; width: 775px;\"></p>\n\n<pre><strong>输入：</strong>logs = [&quot;d1/&quot;,&quot;d2/&quot;,&quot;../&quot;,&quot;d21/&quot;,&quot;./&quot;]\n<strong>输出：</strong>2\n<strong>解释：</strong>执行 &quot;../&quot; 操作变更文件夹 2 次，即可回到主文件夹\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/26/sample_22_1957.png\" style=\"height: 270px; width: 600px;\"></p>\n\n<pre><strong>输入：</strong>logs = [&quot;d1/&quot;,&quot;d2/&quot;,&quot;./&quot;,&quot;d3/&quot;,&quot;../&quot;,&quot;d31/&quot;]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>logs = [&quot;d1/&quot;,&quot;../&quot;,&quot;../&quot;,&quot;../&quot;]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= logs.length &lt;= 10<sup>3</sup></code></li>\n\t<li><code>2 &lt;= logs[i].length &lt;= 10</code></li>\n\t<li><code>logs[i]</code> 包含小写英文字母，数字，<code>&#39;.&#39;</code> 和 <code>&#39;/&#39;</code></li>\n\t<li><code>logs[i]</code> 符合语句中描述的格式</li>\n\t<li>文件夹名称由小写英文字母和数字组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1599经营摩天轮的最大利润",
        "hardRate": "MEDIUM",
        "passRate": "51.48%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-profit-of-operating-a-centennial-wheel/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-profit-of-operating-a-centennial-wheel/solution",
        "problemsDesc": "<p>你正在经营一座摩天轮，该摩天轮共有 <strong>4 个座舱</strong> ，每个座舱<strong> 最多可以容纳 4 位游客</strong> 。你可以 <strong>逆时针</strong>&nbsp;轮转座舱，但每次轮转都需要支付一定的运行成本 <code>runningCost</code> 。摩天轮每次轮转都恰好转动 1 / 4 周。</p>\n\n<p>给你一个长度为 <code>n</code> 的数组 <code>customers</code> ， <code>customers[i]</code> 是在第 <code>i</code> 次轮转（下标从 0 开始）之前到达的新游客的数量。这也意味着你必须在新游客到来前轮转 <code>i</code> 次。每位游客在登上离地面最近的座舱前都会支付登舱成本 <code>boardingCost</code> ，一旦该座舱再次抵达地面，他们就会离开座舱结束游玩。</p>\n\n<p>你可以随时停下摩天轮，即便是 <strong>在服务所有游客之前</strong> 。如果你决定停止运营摩天轮，为了保证所有游客安全着陆，<strong>将免费进行</strong><strong>所有后续轮转</strong>&nbsp;。注意，如果有超过 4 位游客在等摩天轮，那么只有 4 位游客可以登上摩天轮，其余的需要等待 <strong>下一次轮转</strong> 。</p>\n\n<p>返回最大化利润所需执行的 <strong>最小轮转次数</strong> 。 如果不存在利润为正的方案，则返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/26/wheeldiagram12.png\" /></p>\n\n<pre>\n<strong>输入：</strong>customers = [8,3], boardingCost = 5, runningCost = 6\n<strong>输出：</strong>3\n<strong>解释：</strong>座舱上标注的数字是该座舱的当前游客数。\n1. 8 位游客抵达，4 位登舱，4 位等待下一舱，摩天轮轮转。当前利润为 4 * $5 - 1 * $6 = $14 。\n2. 3 位游客抵达，4 位在等待的游客登舱，其他 3 位等待，摩天轮轮转。当前利润为 8 * $5 - 2 * $6 = $28 。\n3. 最后 3 位游客登舱，摩天轮轮转。当前利润为 11 * $5 - 3 * $6 = $37 。\n轮转 3 次得到最大利润，最大利润为 $37 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>customers = [10,9,6], boardingCost = 6, runningCost = 4\n<strong>输出：</strong>7\n<strong>解释：</strong>\n1. 10 位游客抵达，4 位登舱，6 位等待下一舱，摩天轮轮转。当前利润为 4 * $6 - 1 * $4 = $20 。\n2. 9 位游客抵达，4 位登舱，11 位等待（2 位是先前就在等待的，9 位新加入等待的），摩天轮轮转。当前利润为 8 * $6 - 2 * $4 = $40 。\n3. 最后 6 位游客抵达，4 位登舱，13 位等待，摩天轮轮转。当前利润为 12 * $6 - 3 * $4 = $60 。\n4. 4 位登舱，9 位等待，摩天轮轮转。当前利润为 * $6 - 4 * $4 = $80 。\n5. 4 位登舱，5 位等待，摩天轮轮转。当前利润为 20 * $6 - 5 * $4 = $100 。\n6. 4 位登舱，1 位等待，摩天轮轮转。当前利润为 24 * $6 - 6 * $4 = $120 。\n7. 1 位登舱，摩天轮轮转。当前利润为 25 * $6 - 7 * $4 = $122 。\n轮转 7 次得到最大利润，最大利润为$122 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92\n<strong>输出：</strong>-1\n<strong>解释：</strong>\n1. 3 位游客抵达，3 位登舱，0 位等待，摩天轮轮转。当前利润为 3 * $1 - 1 * $92 = -$89 。\n2. 4 位游客抵达，4 位登舱，0 位等待，摩天轮轮转。当前利润为 is 7 * $1 - 2 * $92 = -$177 。\n3. 0 位游客抵达，0 位登舱，0 位等待，摩天轮轮转。当前利润为 7 * $1 - 3 * $92 = -$269 。\n4. 5 位游客抵达，4 位登舱，1 位等待，摩天轮轮转。当前利润为 12 * $1 - 4 * $92 = -$356 。\n5. 1 位游客抵达，2 位登舱，0 位等待，摩天轮轮转。当前利润为 13 * $1 - 5 * $92 = -$447 。\n利润永不为正，所以返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == customers.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= customers[i] &lt;= 50</code></li>\n\t<li><code>1 &lt;= boardingCost, runningCost &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1600王位继承顺序",
        "hardRate": "MEDIUM",
        "passRate": "65.65%",
        "problemsUrl": "https://leetcode.cn/problems/throne-inheritance/",
        "solutionsUrl": "https://leetcode.cn/problems/throne-inheritance/solution",
        "problemsDesc": "<p>一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。</p>\n\n<p>这个王国有一个明确规定的王位继承顺序，第一继承人总是国王自己。我们定义递归函数&nbsp;<code>Successor(x, curOrder)</code>&nbsp;，给定一个人&nbsp;<code>x</code>&nbsp;和当前的继承顺序，该函数返回 <code>x</code>&nbsp;的下一继承人。</p>\n\n<pre>\nSuccessor(x, curOrder):\n    如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中：\n        如果 x 是国王，那么返回 null\n        否则，返回 Successor(x 的父亲, curOrder)\n    否则，返回 x 不在 curOrder 中最年长的孩子\n</pre>\n\n<p>比方说，假设王国由国王，他的孩子&nbsp;Alice 和 Bob （Alice 比 Bob&nbsp;年长）和 Alice 的孩子&nbsp;Jack 组成。</p>\n\n<ol>\n\t<li>一开始，&nbsp;<code>curOrder</code>&nbsp;为&nbsp;<code>[\"king\"]</code>.</li>\n\t<li>调用&nbsp;<code>Successor(king, curOrder)</code>&nbsp;，返回 Alice ，所以我们将 Alice 放入 <code>curOrder</code>&nbsp;中，得到&nbsp;<code>[\"king\", \"Alice\"]</code>&nbsp;。</li>\n\t<li>调用&nbsp;<code>Successor(Alice, curOrder)</code>&nbsp;，返回 Jack ，所以我们将 Jack 放入&nbsp;<code>curOrder</code>&nbsp;中，得到&nbsp;<code>[\"king\", \"Alice\", \"Jack\"]</code>&nbsp;。</li>\n\t<li>调用&nbsp;<code>Successor(Jack, curOrder)</code>&nbsp;，返回 Bob ，所以我们将 Bob 放入&nbsp;<code>curOrder</code>&nbsp;中，得到&nbsp;<code>[\"king\", \"Alice\", \"Jack\", \"Bob\"]</code>&nbsp;。</li>\n\t<li>调用&nbsp;<code>Successor(Bob, curOrder)</code>&nbsp;，返回&nbsp;<code>null</code>&nbsp;。最终得到继承顺序为&nbsp;<code>[\"king\", \"Alice\", \"Jack\", \"Bob\"]</code>&nbsp;。</li>\n</ol>\n\n<p>通过以上的函数，我们总是能得到一个唯一的继承顺序。</p>\n\n<p>请你实现&nbsp;<code>ThroneInheritance</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>ThroneInheritance(string kingName)</code> 初始化一个&nbsp;<code>ThroneInheritance</code>&nbsp;类的对象。国王的名字作为构造函数的参数传入。</li>\n\t<li><code>void birth(string parentName, string childName)</code>&nbsp;表示&nbsp;<code>parentName</code>&nbsp;新拥有了一个名为&nbsp;<code>childName</code>&nbsp;的孩子。</li>\n\t<li><code>void death(string name)</code>&nbsp;表示名为&nbsp;<code>name</code>&nbsp;的人死亡。一个人的死亡不会影响&nbsp;<code>Successor</code>&nbsp;函数，也不会影响当前的继承顺序。你可以只将这个人标记为死亡状态。</li>\n\t<li><code>string[] getInheritanceOrder()</code>&nbsp;返回 <strong>除去</strong>&nbsp;死亡人员的当前继承顺序列表。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"ThroneInheritance\", \"birth\", \"birth\", \"birth\", \"birth\", \"birth\", \"birth\", \"getInheritanceOrder\", \"death\", \"getInheritanceOrder\"]\n[[\"king\"], [\"king\", \"andy\"], [\"king\", \"bob\"], [\"king\", \"catherine\"], [\"andy\", \"matthew\"], [\"bob\", \"alex\"], [\"bob\", \"asha\"], [null], [\"bob\"], [null]]\n<strong>输出：</strong>\n[null, null, null, null, null, null, null, [\"king\", \"andy\", \"matthew\", \"bob\", \"alex\", \"asha\", \"catherine\"], null, [\"king\", \"andy\", \"matthew\", \"alex\", \"asha\", \"catherine\"]]\n\n<strong>解释：</strong>\nThroneInheritance t= new ThroneInheritance(\"king\"); // 继承顺序：<strong>king</strong>\nt.birth(\"king\", \"andy\"); // 继承顺序：king &gt; <strong>andy</strong>\nt.birth(\"king\", \"bob\"); // 继承顺序：king &gt; andy &gt; <strong>bob</strong>\nt.birth(\"king\", \"catherine\"); // 继承顺序：king &gt; andy &gt; bob &gt; <strong>catherine</strong>\nt.birth(\"andy\", \"matthew\"); // 继承顺序：king &gt; andy &gt; <strong>matthew</strong> &gt; bob &gt; catherine\nt.birth(\"bob\", \"alex\"); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; <strong>alex</strong> &gt; catherine\nt.birth(\"bob\", \"asha\"); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; alex &gt; <strong>asha</strong> &gt; catherine\nt.getInheritanceOrder(); // 返回 [\"king\", \"andy\", \"matthew\", \"bob\", \"alex\", \"asha\", \"catherine\"]\nt.death(\"bob\"); // 继承顺序：king &gt; andy &gt; matthew &gt; <strong>bob（已经去世）</strong>&gt; alex &gt; asha &gt; catherine\nt.getInheritanceOrder(); // 返回 [\"king\", \"andy\", \"matthew\", \"alex\", \"asha\", \"catherine\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= kingName.length, parentName.length, childName.length, name.length &lt;= 15</code></li>\n\t<li><code>kingName</code>，<code>parentName</code>，&nbsp;<code>childName</code>&nbsp;和&nbsp;<code>name</code>&nbsp;仅包含小写英文字母。</li>\n\t<li>所有的参数&nbsp;<code>childName</code> 和&nbsp;<code>kingName</code>&nbsp;<strong>互不相同</strong>。</li>\n\t<li>所有&nbsp;<code>death</code>&nbsp;函数中的死亡名字 <code>name</code>&nbsp;要么是国王，要么是已经出生了的人员名字。</li>\n\t<li>每次调用 <code>birth(parentName, childName)</code> 时，测试用例都保证 <code>parentName</code> 对应的人员是活着的。</li>\n\t<li>最多调用&nbsp;<code>10<sup>5</sup></code>&nbsp;次<code>birth</code> 和&nbsp;<code>death</code>&nbsp;。</li>\n\t<li>最多调用&nbsp;<code>10</code>&nbsp;次&nbsp;<code>getInheritanceOrder</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1601最多可达成的换楼请求数目",
        "hardRate": "HARD",
        "passRate": "61.91%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-achievable-transfer-requests/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-achievable-transfer-requests/solution",
        "problemsDesc": "<p>我们有&nbsp;<code>n</code>&nbsp;栋楼，编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。每栋楼有若干员工。由于现在是换楼的季节，部分员工想要换一栋楼居住。</p>\n\n<p>给你一个数组 <code>requests</code>&nbsp;，其中&nbsp;<code>requests[i] = [from<sub>i</sub>, to<sub>i</sub>]</code>&nbsp;，表示一个员工请求从编号为&nbsp;<code>from<sub>i</sub></code>&nbsp;的楼搬到编号为&nbsp;<code>to<sub>i</sub></code><sub>&nbsp;</sub>的楼。</p>\n\n<p>一开始&nbsp;<strong>所有楼都是满的</strong>，所以从请求列表中选出的若干个请求是可行的需要满足 <strong>每栋楼员工净变化为 0&nbsp;</strong>。意思是每栋楼 <strong>离开</strong>&nbsp;的员工数目 <strong>等于</strong>&nbsp;该楼 <strong>搬入</strong>&nbsp;的员工数数目。比方说&nbsp;<code>n = 3</code>&nbsp;且两个员工要离开楼&nbsp;<code>0</code>&nbsp;，一个员工要离开楼&nbsp;<code>1</code>&nbsp;，一个员工要离开楼 <code>2</code>&nbsp;，如果该请求列表可行，应该要有两个员工搬入楼&nbsp;<code>0</code>&nbsp;，一个员工搬入楼&nbsp;<code>1</code>&nbsp;，一个员工搬入楼&nbsp;<code>2</code>&nbsp;。</p>\n\n<p>请你从原请求列表中选出若干个请求，使得它们是一个可行的请求列表，并返回所有可行列表中最大请求数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/26/move1.jpg\" style=\"height: 406px; width: 600px;\"></p>\n\n<pre><strong>输入：</strong>n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]\n<strong>输出：</strong>5\n<strong>解释：</strong>请求列表如下：\n从楼 0 离开的员工为 x 和 y ，且他们都想要搬到楼 1 。\n从楼 1 离开的员工为 a 和 b ，且他们分别想要搬到楼 2 和 0 。\n从楼 2 离开的员工为 z ，且他想要搬到楼 0 。\n从楼 3 离开的员工为 c ，且他想要搬到楼 4 。\n没有员工从楼 4 离开。\n我们可以让 x 和 b 交换他们的楼，以满足他们的请求。\n我们可以让 y，a 和 z 三人在三栋楼间交换位置，满足他们的要求。\n所以最多可以满足 5 个请求。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/26/move2.jpg\" style=\"height: 327px; width: 450px;\"></p>\n\n<pre><strong>输入：</strong>n = 3, requests = [[0,0],[1,2],[2,1]]\n<strong>输出：</strong>3\n<strong>解释：</strong>请求列表如下：\n从楼 0 离开的员工为 x ，且他想要回到原来的楼 0 。\n从楼 1 离开的员工为 y ，且他想要搬到楼 2 。\n从楼 2 离开的员工为 z ，且他想要搬到楼 1 。\n我们可以满足所有的请求。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>1 &lt;= requests.length &lt;= 16</code></li>\n\t<li><code>requests[i].length == 2</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1602找到二叉树中最近的右侧节点",
        "hardRate": "MEDIUM",
        "passRate": "74.58%",
        "problemsUrl": "https://leetcode.cn/problems/find-nearest-right-node-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/find-nearest-right-node-in-binary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1603设计停车系统",
        "hardRate": "EASY",
        "passRate": "83.77%",
        "problemsUrl": "https://leetcode.cn/problems/design-parking-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-parking-system/solution",
        "problemsDesc": "<p>请你给一个停车场设计一个停车系统。停车场总共有三种不同大小的车位：大，中和小，每种尺寸分别有固定数目的车位。</p>\n\n<p>请你实现 <code>ParkingSystem</code> 类：</p>\n\n<ul>\n\t<li><code>ParkingSystem(int big, int medium, int small)</code> 初始化 <code>ParkingSystem</code> 类，三个参数分别对应每种停车位的数目。</li>\n\t<li><code>bool addCar(int carType)</code> 检查是否有 <code>carType</code> 对应的停车位。 <code>carType</code> 有三种类型：大，中，小，分别用数字 <code>1</code>， <code>2</code> 和 <code>3</code> 表示。<strong>一辆车只能停在</strong> <strong> </strong><code>carType</code> 对应尺寸的停车位中。如果没有空车位，请返回 <code>false</code> ，否则将该车停入车位并返回 <code>true</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"ParkingSystem\", \"addCar\", \"addCar\", \"addCar\", \"addCar\"]\n[[1, 1, 0], [1], [2], [3], [1]]\n<strong>输出：</strong>\n[null, true, true, false, false]\n\n<strong>解释：</strong>\nParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);\nparkingSystem.addCar(1); // 返回 true ，因为有 1 个空的大车位\nparkingSystem.addCar(2); // 返回 true ，因为有 1 个空的中车位\nparkingSystem.addCar(3); // 返回 false ，因为没有空的小车位\nparkingSystem.addCar(1); // 返回 false ，因为没有空的大车位，唯一一个大车位已经被占据了\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= big, medium, small <= 1000</code></li>\n\t<li><code>carType</code> 取值为 <code>1</code>， <code>2</code> 或 <code>3</code></li>\n\t<li>最多会调用 <code>addCar</code> 函数 <code>1000</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1604警告一小时内使用相同员工卡大于等于三次的人",
        "hardRate": "MEDIUM",
        "passRate": "50.38%",
        "problemsUrl": "https://leetcode.cn/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/",
        "solutionsUrl": "https://leetcode.cn/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/solution",
        "problemsDesc": "<p>力扣公司的员工都使用员工卡来开办公室的门。每当一个员工使用一次他的员工卡，安保系统会记录下员工的名字和使用时间。如果一个员工在一小时时间内使用员工卡的次数大于等于三次，这个系统会自动发布一个 <strong>警告</strong>&nbsp;。</p>\n\n<p>给你字符串数组&nbsp;<code>keyName</code>&nbsp;和&nbsp;<code>keyTime</code> ，其中&nbsp;<code>[keyName[i], keyTime[i]]</code>&nbsp;对应一个人的名字和他在&nbsp;<strong>某一天</strong> 内使用员工卡的时间。</p>\n\n<p>使用时间的格式是 <strong>24小时制</strong>&nbsp;，形如<strong>&nbsp;\"HH:MM\"</strong>&nbsp;，比方说&nbsp;<code>\"23:51\"</code> 和&nbsp;<code>\"09:49\"</code>&nbsp;。</p>\n\n<p>请你返回去重后的收到系统警告的员工名字，将它们按 <strong>字典序</strong><strong>升序&nbsp;</strong>排序后返回。</p>\n\n<p>请注意&nbsp;<code>\"10:00\"</code> - <code>\"11:00\"</code>&nbsp;视为一个小时时间范围内，而&nbsp;<code>\"22:51\"</code> - <code>\"23:52\"</code>&nbsp;不被视为一小时时间范围内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>keyName = [\"daniel\",\"daniel\",\"daniel\",\"luis\",\"luis\",\"luis\",\"luis\"], keyTime = [\"10:00\",\"10:40\",\"11:00\",\"09:00\",\"11:00\",\"13:00\",\"15:00\"]\n<strong>输出：</strong>[\"daniel\"]\n<strong>解释：</strong>\"daniel\" 在一小时内使用了 3 次员工卡（\"10:00\"，\"10:40\"，\"11:00\"）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>keyName = [\"alice\",\"alice\",\"alice\",\"bob\",\"bob\",\"bob\",\"bob\"], keyTime = [\"12:01\",\"12:00\",\"18:00\",\"21:00\",\"21:20\",\"21:30\",\"23:00\"]\n<strong>输出：</strong>[\"bob\"]\n<strong>解释：</strong>\"bob\" 在一小时内使用了 3 次员工卡（\"21:00\"，\"21:20\"，\"21:30\"）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= keyName.length, keyTime.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>keyName.length == keyTime.length</code></li>\n\t<li><code>keyTime</code> 格式为&nbsp;<strong>\"HH:MM\"&nbsp;</strong>。</li>\n\t<li>保证&nbsp;<code>[keyName[i], keyTime[i]]</code>&nbsp;形成的二元对&nbsp;<strong>互不相同&nbsp;</strong>。</li>\n\t<li><code>1 &lt;= keyName[i].length &lt;= 10</code></li>\n\t<li><code>keyName[i]</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1605给定行和列的和求可行矩阵",
        "hardRate": "MEDIUM",
        "passRate": "80.87%",
        "problemsUrl": "https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/",
        "solutionsUrl": "https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/solution",
        "problemsDesc": "<p>给你两个非负整数数组&nbsp;<code>rowSum</code> 和&nbsp;<code>colSum</code>&nbsp;，其中&nbsp;<code>rowSum[i]</code>&nbsp;是二维矩阵中第 <code>i</code>&nbsp;行元素的和， <code>colSum[j]</code>&nbsp;是第 <code>j</code>&nbsp;列元素的和。换言之你不知道矩阵里的每个元素，但是你知道每一行和每一列的和。</p>\n\n<p>请找到大小为&nbsp;<code>rowSum.length x colSum.length</code>&nbsp;的任意 <strong>非负整数</strong>&nbsp;矩阵，且该矩阵满足&nbsp;<code>rowSum</code> 和&nbsp;<code>colSum</code>&nbsp;的要求。</p>\n\n<p>请你返回任意一个满足题目要求的二维矩阵，题目保证存在 <strong>至少一个</strong>&nbsp;可行矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rowSum = [3,8], colSum = [4,7]\n<strong>输出：</strong>[[3,0],\n      [1,7]]\n<strong>解释：</strong>\n第 0 行：3 + 0 = 3 == rowSum[0]\n第 1 行：1 + 7 = 8 == rowSum[1]\n第 0 列：3 + 1 = 4 == colSum[0]\n第 1 列：0 + 7 = 7 == colSum[1]\n行和列的和都满足题目要求，且所有矩阵元素都是非负的。\n另一个可行的矩阵为：[[1,2],\n                  [3,5]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rowSum = [5,7,10], colSum = [8,6,8]\n<strong>输出：</strong>[[0,5,0],\n      [6,1,0],\n      [2,0,8]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>rowSum = [14,9], colSum = [6,9,8]\n<strong>输出：</strong>[[0,9,5],\n      [6,0,3]]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>rowSum = [1,0], colSum = [1]\n<strong>输出：</strong>[[1],\n      [0]]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>rowSum = [0], colSum = [0]\n<strong>输出：</strong>[[0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rowSum.length, colSum.length &lt;= 500</code></li>\n\t<li><code>0 &lt;= rowSum[i], colSum[i] &lt;= 10<sup>8</sup></code></li>\n\t<li><code>sum(rowSum) == sum(colSum)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1606找到处理最多请求的服务器",
        "hardRate": "HARD",
        "passRate": "48.43%",
        "problemsUrl": "https://leetcode.cn/problems/find-servers-that-handled-most-number-of-requests/",
        "solutionsUrl": "https://leetcode.cn/problems/find-servers-that-handled-most-number-of-requests/solution",
        "problemsDesc": "<p>你有 <code>k</code>&nbsp;个服务器，编号为 <code>0</code>&nbsp;到 <code>k-1</code>&nbsp;，它们可以同时处理多个请求组。每个服务器有无穷的计算能力但是 <strong>不能同时处理超过一个请求</strong>&nbsp;。请求分配到服务器的规则如下：</p>\n\n<ul>\n\t<li>第&nbsp;<code>i</code>&nbsp;（序号从 0 开始）个请求到达。</li>\n\t<li>如果所有服务器都已被占据，那么该请求被舍弃（完全不处理）。</li>\n\t<li>如果第&nbsp;<code>(i % k)</code>&nbsp;个服务器空闲，那么对应服务器会处理该请求。</li>\n\t<li>否则，将请求安排给下一个空闲的服务器（服务器构成一个环，必要的话可能从第 0 个服务器开始继续找下一个空闲的服务器）。比方说，如果第 <code>i</code>&nbsp;个服务器在忙，那么会查看第 <code>(i+1)</code>&nbsp;个服务器，第 <code>(i+2)</code>&nbsp;个服务器等等。</li>\n</ul>\n\n<p>给你一个 <strong>严格递增</strong>&nbsp;的正整数数组&nbsp;<code>arrival</code>&nbsp;，表示第&nbsp;<code>i</code>&nbsp;个任务的到达时间，和另一个数组&nbsp;<code>load</code>&nbsp;，其中&nbsp;<code>load[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个请求的工作量（也就是服务器完成它所需要的时间）。你的任务是找到 <strong>最繁忙的服务器</strong>&nbsp;。最繁忙定义为一个服务器处理的请求数是所有服务器里最多的。</p>\n\n<p>请你返回包含所有&nbsp;<strong>最繁忙服务器</strong>&nbsp;序号的列表，你可以以任意顺序返回这个列表。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/03/load-1.png\" style=\"height: 221px; width: 389px;\" /></p>\n\n<pre>\n<strong>输入：</strong>k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] \n<strong>输出：</strong>[1] \n<strong>解释：</strong>\n所有服务器一开始都是空闲的。\n前 3 个请求分别由前 3 台服务器依次处理。\n请求 3 进来的时候，服务器 0 被占据，所以它被安排到下一台空闲的服务器，也就是服务器 1 。\n请求 4 进来的时候，由于所有服务器都被占据，该请求被舍弃。\n服务器 0 和 2 分别都处理了一个请求，服务器 1 处理了两个请求。所以服务器 1 是最忙的服务器。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 3, arrival = [1,2,3,4], load = [1,2,1,2]\n<strong>输出：</strong>[0]\n<strong>解释：</strong>\n前 3 个请求分别被前 3 个服务器处理。\n请求 3 进来，由于服务器 0 空闲，它被服务器 0 处理。\n服务器 0 处理了两个请求，服务器 1 和 2 分别处理了一个请求。所以服务器 0 是最忙的服务器。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 3, arrival = [1,2,3], load = [10,12,11]\n<strong>输出：</strong>[0,1,2]\n<strong>解释：</strong>每个服务器分别处理了一个请求，所以它们都是最忙的服务器。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 3, arrival = [1,2,3,4,8,9,10], load = [5,2,10,3,1,2,2]\n<strong>输出：</strong>[1]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 1, arrival = [1], load = [1]\n<strong>输出：</strong>[0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arrival.length, load.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>arrival.length == load.length</code></li>\n\t<li><code>1 &lt;= arrival[i], load[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>arrival</code>&nbsp;保证 <strong>严格递增</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1607没有卖出的卖家",
        "hardRate": "EASY",
        "passRate": "54.35%",
        "problemsUrl": "https://leetcode.cn/problems/sellers-with-no-sales/",
        "solutionsUrl": "https://leetcode.cn/problems/sellers-with-no-sales/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1608特殊数组的特征值",
        "hardRate": "EASY",
        "passRate": "61.39%",
        "problemsUrl": "https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x/",
        "solutionsUrl": "https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x/solution",
        "problemsDesc": "<p>给你一个非负整数数组 <code>nums</code> 。如果存在一个数 <code>x</code> ，使得 <code>nums</code> 中恰好有 <code>x</code> 个元素 <strong>大于或者等于</strong> <code>x</code> ，那么就称 <code>nums</code> 是一个 <strong>特殊数组</strong> ，而 <code>x</code> 是该数组的 <strong>特征值</strong> 。</p>\n\n<p>注意： <code>x</code> <strong>不必</strong> 是 <code>nums</code> 的中的元素。</p>\n\n<p>如果数组 <code>nums</code> 是一个 <strong>特殊数组</strong> ，请返回它的特征值 <code>x</code> 。否则，返回<em> </em><code>-1</code> 。可以证明的是，如果 <code>nums</code> 是特殊数组，那么其特征值 <code>x</code> 是 <strong>唯一的</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,5]\n<strong>输出：</strong>2\n<strong>解释：</strong>有 2 个元素（3 和 5）大于或等于 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,0]\n<strong>输出：</strong>-1\n<strong>解释：</strong>没有满足题目要求的特殊数组，故而也不存在特征值 x 。\n如果 x = 0，应该有 0 个元素 &gt;= x，但实际有 2 个。\n如果 x = 1，应该有 1 个元素 &gt;= x，但实际有 0 个。\n如果 x = 2，应该有 2 个元素 &gt;= x，但实际有 0 个。\nx 不能取更大的值，因为 nums 中只有两个元素。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,4,3,0,4]\n<strong>输出：</strong>3\n<strong>解释：</strong>有 3 个元素大于或等于 3 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,6,7,7,0]\n<strong>输出：</strong>-1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1609奇偶树",
        "hardRate": "MEDIUM",
        "passRate": "58.07%",
        "problemsUrl": "https://leetcode.cn/problems/even-odd-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/even-odd-tree/solution",
        "problemsDesc": "<p>如果一棵二叉树满足下述几个条件，则可以称为 <strong>奇偶树</strong> ：</p>\n\n<ul>\n\t<li>二叉树根节点所在层下标为 <code>0</code> ，根的子节点所在层下标为 <code>1</code> ，根的孙节点所在层下标为 <code>2</code> ，依此类推。</li>\n\t<li><strong>偶数下标</strong> 层上的所有节点的值都是 <strong>奇</strong> 整数，从左到右按顺序 <strong>严格递增</strong></li>\n\t<li><strong>奇数下标</strong> 层上的所有节点的值都是 <strong>偶</strong> 整数，从左到右按顺序 <strong>严格递减</strong></li>\n</ul>\n\n<p>给你二叉树的根节点，如果二叉树为 <strong>奇偶树 </strong>，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_1_1966.png\" style=\"height: 229px; width: 362px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,10,4,3,null,7,9,12,8,6,null,null,2]\n<strong>输出：</strong>true\n<strong>解释：</strong>每一层的节点值分别是：\n0 层：[1]\n1 层：[10,4]\n2 层：[3,7,9]\n3 层：[12,8,6,2]\n由于 0 层和 2 层上的节点值都是奇数且严格递增，而 1 层和 3 层上的节点值都是偶数且严格递减，因此这是一棵奇偶树。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_2_1966.png\" style=\"height: 167px; width: 363px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [5,4,2,3,3,7]\n<strong>输出：</strong>false\n<strong>解释：</strong>每一层的节点值分别是：\n0 层：[5]\n1 层：[4,2]\n2 层：[3,3,7]\n2 层上的节点值不满足严格递增的条件，所以这不是一棵奇偶树。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_1_333_1966.png\" style=\"height: 167px; width: 363px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,9,1,3,5,7]\n<strong>输出：</strong>false\n<strong>解释：</strong>1 层上的节点值应为偶数。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [11,8,6,1,3,9,11,30,20,18,16,12,10,4,2,17]\n<strong>输出：</strong>true\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 <= Node.val <= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1610可见点的最大数目",
        "hardRate": "HARD",
        "passRate": "44.39%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-visible-points/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-visible-points/solution",
        "problemsDesc": "<p>给你一个点数组 <code>points</code> 和一个表示角度的整数 <code>angle</code> ，你的位置是 <code>location</code> ，其中 <code>location = [pos<sub>x</sub>, pos<sub>y</sub>]</code> 且 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 都表示 X-Y 平面上的整数坐标。</p>\n\n<p>最开始，你面向东方进行观测。你 <strong>不能</strong> 进行移动改变位置，但可以通过 <strong>自转</strong> 调整观测角度。换句话说，<code>pos<sub>x</sub></code> 和 <code>pos<sub>y</sub></code> 不能改变。你的视野范围的角度用 <code>angle</code> 表示， 这决定了你观测任意方向时可以多宽。设 <code>d</code> 为你逆时针自转旋转的度数，那么你的视野就是角度范围 <code>[d - angle/2, d + angle/2]</code> 所指示的那片区域。</p>\n\n<video autoplay=\"\" controls=\"\" height=\"360\" muted=\"\" style=\"max-width:100%;height:auto;\" width=\"750\"><source src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/angle.mp4\" type=\"video/mp4\" />Your browser does not support the video tag or this video format.</video>\n\n<p>对于每个点，如果由该点、你的位置以及从你的位置直接向东的方向形成的角度 <strong>位于你的视野中</strong> ，那么你就可以看到它。</p>\n\n<p>同一个坐标上可以有多个点。你所在的位置也可能存在一些点，但不管你的怎么旋转，总是可以看到这些点。同时，点不会阻碍你看到其他点。</p>\n\n<p>返回你能看到的点的最大数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/89a07e9b-00ab-4967-976a-c723b2aa8656.png\" style=\"height: 300px; width: 400px;\" /></p>\n\n<pre>\n<strong>输入：</strong>points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>阴影区域代表你的视野。在你的视野中，所有的点都清晰可见，尽管 [2,2] 和 [3,3]在同一条直线上，你仍然可以看到 [3,3] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[2,1],[2,2],[3,4],[1,1]], angle = 90, location = [1,1]\n<strong>输出：</strong>4\n<strong>解释：</strong>在你的视野中，所有的点都清晰可见，包括你所在位置的那个点。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/5010bfd3-86e6-465f-ac64-e9df941d2e49.png\" style=\"height: 348px; width: 690px;\" /></p>\n\n<pre>\n<strong>输入：</strong>points = [[1,0],[2,1]], angle = 13, location = [1,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>如图所示，你只能看到两点之一。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= points.length <= 10<sup>5</sup></code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>location.length == 2</code></li>\n\t<li><code>0 <= angle < 360</code></li>\n\t<li><code>0 <= pos<sub>x</sub>, pos<sub>y</sub>, x<sub>i</sub>, y<sub>i</sub> <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1611使整数变为 0 的最少操作次数",
        "hardRate": "HARD",
        "passRate": "61.12%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-one-bit-operations-to-make-integers-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-one-bit-operations-to-make-integers-zero/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code>，你需要重复执行多次下述操作将其转换为 <code>0</code> ：</p>\n\n<ul>\n\t<li>翻转 <code>n</code> 的二进制表示中最右侧位（第 <code>0</code> 位）。</li>\n\t<li>如果第 <code>(i-1)</code> 位为 <code>1</code> 且从第 <code>(i-2)</code> 位到第 <code>0</code> 位都为 <code>0</code>，则翻转 <code>n</code> 的二进制表示中的第 <code>i</code> 位。</li>\n</ul>\n\n<p>返回将 <code>n</code> 转换为 <code>0</code> 的最小操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>3 的二进制表示为 \"11\"\n\"<strong>1</strong>1\" -&gt; \"<strong>0</strong>1\" ，执行的是第 2 种操作，因为第 0 位为 1 。\n\"0<strong>1</strong>\" -&gt; \"0<strong>0</strong>\" ，执行的是第 1 种操作。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6\n<strong>输出：</strong>4\n<strong>解释：</strong>6 的二进制表示为 \"110\".\n\"<strong>1</strong>10\" -&gt; \"<strong>0</strong>10\" ，执行的是第 2 种操作，因为第 1 位为 1 ，第 0 到 0 位为 0 。\n\"01<strong>0</strong>\" -&gt; \"01<strong>1</strong>\" ，执行的是第 1 种操作。\n\"0<strong>1</strong>1\" -&gt; \"0<strong>0</strong>1\" ，执行的是第 2 种操作，因为第 0 位为 1 。\n\"00<strong>1</strong>\" -&gt; \"00<strong>0</strong>\" ，执行的是第 1 种操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1612检查两棵二叉表达式树是否等价",
        "hardRate": "MEDIUM",
        "passRate": "74.33%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-two-expression-trees-are-equivalent/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-two-expression-trees-are-equivalent/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1613找到遗失的ID",
        "hardRate": "MEDIUM",
        "passRate": "72.79%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-missing-ids/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-missing-ids/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1614括号的最大嵌套深度",
        "hardRate": "EASY",
        "passRate": "82.36%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-nesting-depth-of-the-parentheses/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-nesting-depth-of-the-parentheses/solution",
        "problemsDesc": "<p>如果字符串满足以下条件之一，则可以称之为 <strong>有效括号字符串</strong><strong>（valid parentheses string</strong>，可以简写为 <strong>VPS</strong>）：</p>\n\n<ul>\n\t<li>字符串是一个空字符串 <code>\"\"</code>，或者是一个不为 <code>\"(\"</code> 或 <code>\")\"</code> 的单字符。</li>\n\t<li>字符串可以写为 <code>AB</code>（<code>A</code> 与 <code>B</code>&nbsp;字符串连接），其中 <code>A</code> 和 <code>B</code> 都是 <strong>有效括号字符串</strong> 。</li>\n\t<li>字符串可以写为 <code>(A)</code>，其中 <code>A</code> 是一个 <strong>有效括号字符串</strong> 。</li>\n</ul>\n\n<p>类似地，可以定义任何有效括号字符串&nbsp;<code>S</code> 的 <strong>嵌套深度</strong> <code>depth(S)</code>：</p>\n\n<ul>\n\t<li><code>depth(\"\") = 0</code></li>\n\t<li><code>depth(C) = 0</code>，其中 <code>C</code> 是单个字符的字符串，且该字符不是 <code>\"(\"</code> 或者 <code>\")\"</code></li>\n\t<li><code>depth(A + B) = max(depth(A), depth(B))</code>，其中 <code>A</code> 和 <code>B</code> 都是 <strong>有效括号字符串</strong></li>\n\t<li><code>depth(\"(\" + A + \")\") = 1 + depth(A)</code>，其中 <code>A</code> 是一个 <strong>有效括号字符串</strong></li>\n</ul>\n\n<p>例如：<code>\"\"</code>、<code>\"()()\"</code>、<code>\"()(()())\"</code> 都是 <strong>有效括号字符串</strong>（嵌套深度分别为 0、1、2），而 <code>\")(\"</code> 、<code>\"(()\"</code> 都不是 <strong>有效括号字符串</strong> 。</p>\n\n<p>给你一个 <strong>有效括号字符串</strong> <code>s</code>，返回该字符串的<em> </em><code>s</code> <strong>嵌套深度</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(1+(2*3)+((<strong>8</strong>)/4))+1\"\n<strong>输出：</strong>3\n<strong>解释：</strong>数字 8 在嵌套的 3 层括号中。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(1)+((2))+(((<strong>3</strong>)))\"\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 由数字 <code>0-9</code> 和字符 <code>'+'</code>、<code>'-'</code>、<code>'*'</code>、<code>'/'</code>、<code>'('</code>、<code>')'</code> 组成</li>\n\t<li>题目数据保证括号表达式 <code>s</code> 是 <strong>有效的括号表达式</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1615最大网络秩",
        "hardRate": "MEDIUM",
        "passRate": "60.13%",
        "problemsUrl": "https://leetcode.cn/problems/maximal-network-rank/",
        "solutionsUrl": "https://leetcode.cn/problems/maximal-network-rank/solution",
        "problemsDesc": "<p><code>n</code> 座城市和一些连接这些城市的道路 <code>roads</code> 共同组成一个基础设施网络。每个 <code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 都表示在城市 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间有一条双向道路。</p>\n\n<p>两座不同城市构成的 <strong>城市对</strong> 的 <strong>网络秩</strong> 定义为：与这两座城市 <strong>直接</strong> 相连的道路总数。如果存在一条道路直接连接这两座城市，则这条道路只计算 <strong>一次</strong> 。</p>\n\n<p>整个基础设施网络的 <strong>最大网络秩</strong> 是所有不同城市对中的 <strong>最大网络秩</strong> 。</p>\n\n<p>给你整数 <code>n</code> 和数组 <code>roads</code>，返回整个基础设施网络的 <strong>最大网络秩</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/11/ex1.png\" style=\"width: 292px; height: 172px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, roads = [[0,1],[0,3],[1,2],[1,3]]\n<strong>输出：</strong>4\n<strong>解释：</strong>城市 0 和 1 的网络秩是 4，因为共有 4 条道路与城市 0 或 1 相连。位于 0 和 1 之间的道路只计算一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/11/ex2.png\" style=\"width: 292px; height: 172px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]]\n<strong>输出：</strong>5\n<strong>解释：</strong>共有 5 条道路与城市 1 或 2 相连。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]]\n<strong>输出：</strong>5\n<strong>解释：</strong>2 和 5 的网络秩为 5，注意并非所有的城市都需要连接起来。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 100</code></li>\n\t<li><code>0 <= roads.length <= n * (n - 1) / 2</code></li>\n\t<li><code>roads[i].length == 2</code></li>\n\t<li><code>0 <= a<sub>i</sub>, b<sub>i</sub> <= n-1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>每对城市之间 <strong>最多只有一条</strong> 道路相连</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1616分割两个字符串得到回文串",
        "hardRate": "MEDIUM",
        "passRate": "37.56%",
        "problemsUrl": "https://leetcode.cn/problems/split-two-strings-to-make-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/split-two-strings-to-make-palindrome/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>a</code> 和&nbsp;<code>b</code>&nbsp;，它们长度相同。请你选择一个下标，将两个字符串都在&nbsp;<strong>相同的下标 </strong>分割开。由&nbsp;<code>a</code>&nbsp;可以得到两个字符串：&nbsp;<code>a<sub>prefix</sub></code>&nbsp;和&nbsp;<code>a<sub>suffix</sub></code>&nbsp;，满足&nbsp;<code>a = a<sub>prefix</sub> + a<sub>suffix</sub></code><sub>&nbsp;</sub>，同理，由&nbsp;<code>b</code> 可以得到两个字符串&nbsp;<code>b<sub>prefix</sub></code> 和&nbsp;<code>b<sub>suffix</sub></code>&nbsp;，满足&nbsp;<code>b = b<sub>prefix</sub> + b<sub>suffix</sub></code>&nbsp;。请你判断&nbsp;<code>a<sub>prefix</sub> + b<sub>suffix</sub></code> 或者&nbsp;<code>b<sub>prefix</sub> + a<sub>suffix</sub></code>&nbsp;能否构成回文串。</p>\n\n<p>当你将一个字符串&nbsp;<code>s</code>&nbsp;分割成&nbsp;<code>s<sub>prefix</sub></code> 和&nbsp;<code>s<sub>suffix</sub></code>&nbsp;时，&nbsp;<code>s<sub>suffix</sub></code> 或者&nbsp;<code>s<sub>prefix</sub></code> 可以为空。比方说，&nbsp;<code>s = \"abc\"</code>&nbsp;那么&nbsp;<code>\"\" + \"abc\"</code>&nbsp;，&nbsp;<code>\"a\" + \"bc\"&nbsp;</code>，&nbsp;<code>\"ab\" + \"c\"</code>&nbsp;和&nbsp;<code>\"abc\" + \"\"</code>&nbsp;都是合法分割。</p>\n\n<p>如果 <strong>能构成回文字符串</strong> ，那么请返回&nbsp;<code>true</code>，否则返回<em>&nbsp;</em><code>false</code>&nbsp;。</p>\n\n<p><strong>注意</strong>，&nbsp;<code>x + y</code>&nbsp;表示连接字符串&nbsp;<code>x</code> 和&nbsp;<code>y</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>a = \"x\", b = \"y\"\n<b>输出：</b>true\n<b>解释：</b>如果 a 或者 b 是回文串，那么答案一定为 true ，因为你可以如下分割：\na<sub>prefix</sub> = \"\", a<sub>suffix</sub> = \"x\"\nb<sub>prefix</sub> = \"\", b<sub>suffix</sub> = \"y\"\n那么 a<sub>prefix</sub> + b<sub>suffix</sub> = \"\" + \"y\" = \"y\" 是回文串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = \"abdef\", b = \"fecab\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>a = \"ulacfd\", b = \"jizalu\"\n<b>输出：</b>true\n<b>解释：</b>在下标为 3 处分割：\na<sub>prefix</sub> = \"ula\", a<sub>suffix</sub> = \"cfd\"\nb<sub>prefix</sub> = \"jiz\", b<sub>suffix</sub> = \"alu\"\n那么 a<sub>prefix</sub> + b<sub>suffix</sub> = \"ula\" + \"alu\" = \"ulaalu\" 是回文串。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>a.length == b.length</code></li>\n\t<li><code>a</code> 和&nbsp;<code>b</code>&nbsp;都只包含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1617统计子树中城市之间最大距离",
        "hardRate": "HARD",
        "passRate": "79.17%",
        "problemsUrl": "https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/",
        "solutionsUrl": "https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/solution",
        "problemsDesc": "<p>给你 <code>n</code> 个城市，编号为从 <code>1</code> 到 <code>n</code> 。同时给你一个大小为 <code>n-1</code> 的数组 <code>edges</code> ，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> 表示城市 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code><sub> </sub>之间有一条双向边。题目保证任意城市之间只有唯一的一条路径。换句话说，所有城市形成了一棵 <strong>树</strong> 。</p>\n\n<p>一棵 <strong>子树</strong> 是城市的一个子集，且子集中任意城市之间可以通过子集中的其他城市和边到达。两个子树被认为不一样的条件是至少有一个城市在其中一棵子树中存在，但在另一棵子树中不存在。</p>\n\n<p>对于 <code>d</code> 从 <code>1</code> 到 <code>n-1</code> ，请你找到城市间 <strong>最大距离</strong> 恰好为 <code>d</code> 的所有子树数目。</p>\n\n<p>请你返回一个大小为 <code>n-1</code> 的数组，其中第<em> </em><code>d</code><em> </em>个元素（<strong>下标从 1 开始</strong>）是城市间 <strong>最大距离</strong> 恰好等于 <code>d</code> 的子树数目。</p>\n\n<p><strong>请注意</strong>，两个城市间距离定义为它们之间需要经过的边的数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/11/p1.png\" style=\"width: 161px; height: 181px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>n = 4, edges = [[1,2],[2,3],[2,4]]\n<b>输出：</b>[3,4,0]\n<strong>解释：\n</strong>子树 {1,2}, {2,3} 和 {2,4} 最大距离都是 1 。\n子树 {1,2,3}, {1,2,4}, {2,3,4} 和 {1,2,3,4} 最大距离都为 2 。\n不存在城市间最大距离为 3 的子树。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 2, edges = [[1,2]]\n<b>输出：</b>[1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, edges = [[1,2],[2,3]]\n<b>输出：</b>[2,1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 15</code></li>\n\t<li><code>edges.length == n-1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 <= u<sub>i</sub>, v<sub>i</sub> <= n</code></li>\n\t<li>题目保证 <code>(u<sub>i</sub>, v<sub>i</sub>)</code> 所表示的边互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1618找出适应屏幕的最大字号",
        "hardRate": "MEDIUM",
        "passRate": "62.46%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-font-to-fit-a-sentence-in-a-screen/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-font-to-fit-a-sentence-in-a-screen/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1619删除某些元素后的数组均值",
        "hardRate": "EASY",
        "passRate": "71.77%",
        "problemsUrl": "https://leetcode.cn/problems/mean-of-array-after-removing-some-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/mean-of-array-after-removing-some-elements/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> ，请你删除最小 <code>5%</code> 的数字和最大 <code>5%</code> 的数字后，剩余数字的平均值。</p>\n\n<p>与 <strong>标准答案</strong> 误差在 <code>10<sup>-5</sup></code> 的结果都被视为正确结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n<b>输出：</b>2.00000\n<b>解释：</b>删除数组中最大和最小的元素后，所有元素都等于 2，所以平均值为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n<b>输出：</b>4.00000\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n<b>输出：</b>4.77778\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n<b>输出：</b>5.27778\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n<b>输出：</b>5.29167\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>20 <= arr.length <= 1000</code></li>\n\t<li><code>arr.length</code><b> </b>是 <code>20</code> 的<strong> 倍数</strong> </li>\n\t<li><code>0 <= arr[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1620网络信号最好的坐标",
        "hardRate": "MEDIUM",
        "passRate": "46.06%",
        "problemsUrl": "https://leetcode.cn/problems/coordinate-with-maximum-network-quality/",
        "solutionsUrl": "https://leetcode.cn/problems/coordinate-with-maximum-network-quality/solution",
        "problemsDesc": "<p>给你一个数组 <code>towers</code>&nbsp;和一个整数 <code>radius</code> 。</p>\n\n<p>数组&nbsp; <code>towers</code>&nbsp; 中包含一些网络信号塔，其中&nbsp;<code>towers[i] = [x<sub>i</sub>, y<sub>i</sub>, q<sub>i</sub>]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个网络信号塔的坐标是&nbsp;<code>(x<sub>i</sub>, y<sub>i</sub>)</code>&nbsp;且信号强度参数为&nbsp;<code>q<sub>i</sub></code><sub>&nbsp;</sub>。所有坐标都是在&nbsp; X-Y 坐标系内的&nbsp;<strong>整数</strong>&nbsp;坐标。两个坐标之间的距离用 <strong>欧几里得距离</strong>&nbsp;计算。</p>\n\n<p>整数&nbsp;<code>radius</code>&nbsp;表示一个塔 <strong>能到达&nbsp;</strong>的 <strong>最远距离</strong>&nbsp;。如果一个坐标跟塔的距离在 <code>radius</code>&nbsp;以内，那么该塔的信号可以到达该坐标。在这个范围以外信号会很微弱，所以 <code>radius</code>&nbsp;以外的距离该塔是 <strong>不能到达的</strong>&nbsp;。</p>\n\n<p>如果第 <code>i</code>&nbsp;个塔能到达 <code>(x, y)</code>&nbsp;，那么该塔在此处的信号为&nbsp;<code>⌊q<sub>i</sub> / (1 + d)⌋</code>&nbsp;，其中&nbsp;<code>d</code>&nbsp;是塔跟此坐标的距离。一个坐标的 <b>信号强度</b> 是所有 <strong>能到达&nbsp;</strong>该坐标的塔的信号强度之和。</p>\n\n<p>请你返回数组 <code>[c<sub>x</sub>, c<sub>y</sub>]</code> ，表示 <strong>信号强度</strong> 最大的 <strong>整数</strong> 坐标点&nbsp;<code>(c<sub>x</sub>, c<sub>y</sub>)</code> 。如果有多个坐标网络信号一样大，请你返回字典序最小的 <strong>非负</strong> 坐标。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>坐标&nbsp;<code>(x1, y1)</code>&nbsp;字典序比另一个坐标&nbsp;<code>(x2, y2)</code> 小，需满足以下条件之一：\n\n\t<ul>\n\t\t<li>要么&nbsp;<code>x1 &lt; x2</code>&nbsp;，</li>\n\t\t<li>要么&nbsp;<code>x1 == x2</code> 且&nbsp;<code>y1 &lt; y2</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n\t<li><code>⌊val⌋</code>&nbsp;表示小于等于&nbsp;<code>val</code>&nbsp;的最大整数（向下取整函数）。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/17/untitled-diagram.png\" style=\"width: 176px; height: 176px;\" />\n<pre>\n<b>输入：</b>towers = [[1,2,5],[2,1,7],[3,1,9]], radius = 2\n<b>输出：</b>[2,1]\n<strong>解释：</strong>\n坐标 (2, 1) 信号强度之和为 13\n- 塔 (2, 1) 强度参数为 7 ，在该点强度为 ⌊7 / (1 + sqrt(0)⌋ = ⌊7⌋ = 7\n- 塔 (1, 2) 强度参数为 5 ，在该点强度为 ⌊5 / (1 + sqrt(2)⌋ = ⌊2.07⌋ = 2\n- 塔 (3, 1) 强度参数为 9 ，在该点强度为 ⌊9 / (1 + sqrt(1)⌋ = ⌊4.5⌋ = 4\n没有别的坐标有更大的信号强度。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>towers = [[23,11,21]], radius = 9\n<b>输出：</b>[23,11]\n<strong>解释：</strong>由于仅存在一座信号塔，所以塔的位置信号强度最大。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>towers = [[1,2,13],[2,1,7],[0,1,9]], radius = 2\n<b>输出：</b>[1,2]\n<strong>解释：</strong>坐标 (1, 2) 的信号强度最大。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= towers.length &lt;= 50</code></li>\n\t<li><code>towers[i].length == 3</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>, q<sub>i</sub> &lt;= 50</code></li>\n\t<li><code>1 &lt;= radius &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1621大小为 K 的不重叠线段的数目",
        "hardRate": "MEDIUM",
        "passRate": "48.03%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-sets-of-k-non-overlapping-line-segments/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-sets-of-k-non-overlapping-line-segments/solution",
        "problemsDesc": "<p>给你一维空间的 <code>n</code> 个点，其中第 <code>i</code> 个点（编号从 <code>0</code> 到 <code>n-1</code>）位于 <code>x = i</code> 处，请你找到 <strong>恰好</strong> <code>k</code> <strong>个不重叠</strong> 线段且每个线段至少覆盖两个点的方案数。线段的两个端点必须都是 <strong>整数坐标</strong> 。这 <code>k</code> 个线段不需要全部覆盖全部 <code>n</code> 个点，且它们的端点 <strong>可以 </strong>重合。</p>\n\n<p>请你返回 <code>k</code> 个不重叠线段的方案数。由于答案可能很大，请将结果对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/17/ex1.png\" style=\"width: 179px; height: 222px;\" />\n<pre>\n<b>输入：</b>n = 4, k = 2\n<b>输出：</b>5\n<strong>解释：\n</strong>如图所示，两个线段分别用红色和蓝色标出。\n上图展示了 5 种不同的方案 {(0,2),(2,3)}，{(0,1),(1,3)}，{(0,1),(2,3)}，{(1,2),(2,3)}，{(0,1),(1,2)} 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, k = 1\n<b>输出：</b>3\n<strong>解释：</strong>总共有 3 种不同的方案 {(0,1)}, {(0,2)}, {(1,2)} 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 30, k = 7\n<b>输出：</b>796297179\n<strong>解释：</strong>画 7 条线段的总方案数为 3796297200 种。将这个数对 10<sup>9</sup> + 7 取余得到 796297179 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5, k = 3\n<b>输出：</b>7\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, k = 2\n<b>输出：</b>1</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 1000</code></li>\n\t<li><code>1 <= k <= n-1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1622奇妙序列",
        "hardRate": "HARD",
        "passRate": "17.28%",
        "problemsUrl": "https://leetcode.cn/problems/fancy-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/fancy-sequence/solution",
        "problemsDesc": "<p>请你实现三个 API <code>append</code>，<code>addAll</code> 和 <code>multAll</code> 来实现奇妙序列。</p>\n\n<p>请实现 <code>Fancy</code> 类 ：</p>\n\n<ul>\n\t<li><code>Fancy()</code> 初始化一个空序列对象。</li>\n\t<li><code>void append(val)</code> 将整数 <code>val</code> 添加在序列末尾。</li>\n\t<li><code>void addAll(inc)</code> 将所有序列中的现有数值都增加 <code>inc</code> 。</li>\n\t<li><code>void multAll(m)</code> 将序列中的所有现有数值都乘以整数 <code>m</code> 。</li>\n\t<li><code>int getIndex(idx)</code> 得到下标为 <code>idx</code> 处的数值（下标从 0 开始），并将结果对 <code>10<sup>9</sup> + 7</code> 取余。如果下标大于等于序列的长度，请返回 <code>-1</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"Fancy\", \"append\", \"addAll\", \"append\", \"multAll\", \"getIndex\", \"addAll\", \"append\", \"multAll\", \"getIndex\", \"getIndex\", \"getIndex\"]\n[[], [2], [3], [7], [2], [0], [3], [10], [2], [0], [1], [2]]\n<strong>输出：</strong>\n[null, null, null, null, null, 10, null, null, null, 26, 34, 20]\n\n<strong>解释：</strong>\nFancy fancy = new Fancy();\nfancy.append(2);   // 奇妙序列：[2]\nfancy.addAll(3);   // 奇妙序列：[2+3] -> [5]\nfancy.append(7);   // 奇妙序列：[5, 7]\nfancy.multAll(2);  // 奇妙序列：[5*2, 7*2] -> [10, 14]\nfancy.getIndex(0); // 返回 10\nfancy.addAll(3);   // 奇妙序列：[10+3, 14+3] -> [13, 17]\nfancy.append(10);  // 奇妙序列：[13, 17, 10]\nfancy.multAll(2);  // 奇妙序列：[13*2, 17*2, 10*2] -> [26, 34, 20]\nfancy.getIndex(0); // 返回 26\nfancy.getIndex(1); // 返回 34\nfancy.getIndex(2); // 返回 20\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= val, inc, m <= 100</code></li>\n\t<li><code>0 <= idx <= 10<sup>5</sup></code></li>\n\t<li>总共最多会有 <code>10<sup>5</sup></code> 次对 <code>append</code>，<code>addAll</code>，<code>multAll</code> 和 <code>getIndex</code> 的调用。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1623三人国家代表队",
        "hardRate": "EASY",
        "passRate": "78.45%",
        "problemsUrl": "https://leetcode.cn/problems/all-valid-triplets-that-can-represent-a-country/",
        "solutionsUrl": "https://leetcode.cn/problems/all-valid-triplets-that-can-represent-a-country/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1624两个相同字符之间的最长子字符串",
        "hardRate": "EASY",
        "passRate": "64.41%",
        "problemsUrl": "https://leetcode.cn/problems/largest-substring-between-two-equal-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-substring-between-two-equal-characters/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code>，请你返回 <strong>两个相同字符之间的最长子字符串的长度</strong> <em>，</em>计算长度时不含这两个字符。如果不存在这样的子字符串，返回 <code>-1</code> 。</p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"aa\"\n<strong>输出：</strong>0\n<strong>解释：</strong>最优的子字符串是两个 'a' 之间的空子字符串。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abca\"\n<strong>输出：</strong>2\n<strong>解释：</strong>最优的子字符串是 \"bc\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = \"cbzxy\"\n<strong>输出：</strong>-1\n<strong>解释：</strong>s 中不存在出现出现两次的字符，所以返回 -1 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = \"cabbac\"\n<strong>输出：</strong>4\n<strong>解释：</strong>最优的子字符串是 \"abba\" ，其他的非最优解包括 \"bb\" 和 \"\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 300</code></li>\n\t<li><code>s</code> 只含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1625执行操作后字典序最小的字符串",
        "hardRate": "MEDIUM",
        "passRate": "66.73%",
        "problemsUrl": "https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 以及两个整数 <code>a</code> 和 <code>b</code> 。其中，字符串 <code>s</code> 的长度为偶数，且仅由数字 <code>0</code> 到 <code>9</code> 组成。</p>\n\n<p>你可以在 <code>s</code> 上按任意顺序多次执行下面两个操作之一：</p>\n\n<ul>\n\t<li>累加：将  <code>a</code> 加到 <code>s</code> 中所有下标为奇数的元素上（<strong>下标从 0 开始</strong>）。数字一旦超过 <code>9</code> 就会变成 <code>0</code>，如此循环往复。例如，<code>s = \"3456\"</code> 且 <code>a = 5</code>，则执行此操作后 <code>s</code> 变成 <code>\"3951\"</code>。</li>\n\t<li>轮转：将 <code>s</code> 向右轮转 <code>b</code> 位。例如，<code>s = \"3456\"</code> 且 <code>b = 1</code>，则执行此操作后 <code>s</code> 变成 <code>\"6345\"</code>。</li>\n</ul>\n\n<p>请你返回在 <code>s</code> 上执行上述操作任意次后可以得到的 <strong>字典序最小</strong> 的字符串。</p>\n\n<p>如果两个字符串长度相同，那么字符串 <code>a</code> 字典序比字符串 <code>b</code> 小可以这样定义：在 <code>a</code> 和 <code>b</code> 出现不同的第一个位置上，字符串 <code>a</code> 中的字符出现在字母表中的时间早于 <code>b</code> 中的对应字符。例如，<code>\"0158”</code> 字典序比 <code>\"0190\"</code> 小，因为不同的第一个位置是在第三个字符，显然 <code>'5'</code> 出现在 <code>'9'</code> 之前。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"5525\", a = 9, b = 2\n<strong>输出：</strong>\"2050\"\n<strong>解释：</strong>执行操作如下：\n初态：\"5525\"\n轮转：\"2555\"\n累加：\"2454\"\n累加：\"2353\"\n轮转：\"5323\"\n累加：\"5222\"\n累加：\"5121\"\n轮转：\"2151\"\n累加：\"2050\"​​​​​​​​​​​​\n无法获得字典序小于 \"2050\" 的字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"74\", a = 5, b = 1\n<strong>输出：</strong>\"24\"\n<strong>解释：</strong>执行操作如下：\n初态：\"74\"\n轮转：\"47\"\n累加：\"42\"\n轮转：\"24\"​​​​​​​​​​​​\n无法获得字典序小于 \"24\" 的字符串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0011\", a = 4, b = 2\n<strong>输出：</strong>\"0011\"\n<strong>解释：</strong>无法获得字典序小于 \"0011\" 的字符串。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"43987654\", a = 7, b = 3\n<strong>输出：</strong>\"00553311\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= s.length <= 100</code></li>\n\t<li><code>s.length</code> 是偶数</li>\n\t<li><code>s</code> 仅由数字 <code>0</code> 到 <code>9</code> 组成</li>\n\t<li><code>1 <= a <= 9</code></li>\n\t<li><code>1 <= b <= s.length - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1626无矛盾的最佳球队",
        "hardRate": "MEDIUM",
        "passRate": "53.69%",
        "problemsUrl": "https://leetcode.cn/problems/best-team-with-no-conflicts/",
        "solutionsUrl": "https://leetcode.cn/problems/best-team-with-no-conflicts/solution",
        "problemsDesc": "<p>假设你是球队的经理。对于即将到来的锦标赛，你想组合一支总体得分最高的球队。球队的得分是球队中所有球员的分数 <strong>总和</strong> 。</p>\n\n<p>然而，球队中的矛盾会限制球员的发挥，所以必须选出一支 <strong>没有矛盾</strong> 的球队。如果一名年龄较小球员的分数 <strong>严格大于</strong> 一名年龄较大的球员，则存在矛盾。同龄球员之间不会发生矛盾。</p>\n\n<p>给你两个列表 <code>scores</code> 和 <code>ages</code>，其中每组 <code>scores[i]</code> 和 <code>ages[i]</code> 表示第 <code>i</code> 名球员的分数和年龄。请你返回 <strong>所有可能的无矛盾球队中得分最高那支的分数</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>scores = [1,3,5,10,15], ages = [1,2,3,4,5]\n<strong>输出：</strong>34\n<strong>解释：</strong>你可以选中所有球员。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>scores = [4,5,6,5], ages = [2,1,2,1]\n<strong>输出：</strong>16\n<strong>解释：</strong>最佳的选择是后 3 名球员。注意，你可以选中多个同龄球员。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>scores = [1,2,3,5], ages = [8,9,10,1]\n<strong>输出：</strong>6\n<strong>解释：</strong>最佳的选择是前 3 名球员。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= scores.length, ages.length &lt;= 1000</code></li>\n\t<li><code>scores.length == ages.length</code></li>\n\t<li><code>1 &lt;= scores[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= ages[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1627带阈值的图连通性",
        "hardRate": "HARD",
        "passRate": "42.22%",
        "problemsUrl": "https://leetcode.cn/problems/graph-connectivity-with-threshold/",
        "solutionsUrl": "https://leetcode.cn/problems/graph-connectivity-with-threshold/solution",
        "problemsDesc": "<p>有 <code>n</code> 座城市，编号从 <code>1</code> 到 <code>n</code> 。编号为 <code>x</code> 和 <code>y</code> 的两座城市直接连通的前提是： <code>x</code> 和 <code>y</code> 的公因数中，至少有一个 <strong>严格大于</strong> 某个阈值 <code>threshold</code> 。更正式地说，如果存在整数 <code>z</code> ，且满足以下所有条件，则编号 <code>x</code> 和 <code>y</code> 的城市之间有一条道路：</p>\n\n<ul>\n\t<li><code>x % z == 0</code></li>\n\t<li><code>y % z == 0</code></li>\n\t<li><code>z > threshold</code></li>\n</ul>\n\n<p>给你两个整数 <code>n</code> 和 <code>threshold</code> ，以及一个待查询数组，请你判断每个查询<code> queries[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 指向的城市 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 是否连通（即，它们之间是否存在一条路径）。</p>\n\n<p>返回数组 <code>answer</code> ，其中<code>answer.length == queries.length</code> 。如果第 <code>i</code> 个查询中指向的城市 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 连通，则 <code>answer[i]</code> 为 <code>true</code> ；如果不连通，则 <code>answer[i]</code> 为 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/18/ex1.jpg\" style=\"width: 382px; height: 181px;\" /></p>\n\n<p> </p>\n\n<pre>\n<strong>输入：</strong>n = 6, threshold = 2, queries = [[1,4],[2,5],[3,6]]\n<strong>输出：</strong>[false,false,true]\n<strong>解释：</strong>每个数的因数如下：\n1:   1\n2:   1, 2\n3:   1, <strong>3</strong>\n4:   1, 2, <strong>4</strong>\n5:   1, <strong>5</strong>\n6:   1, 2, <strong>3</strong>, <strong>6</strong>\n所有大于阈值的的因数已经加粗标识，只有城市 3 和 6 共享公约数 3 ，因此结果是： \n[1,4]   1 与 4 不连通\n[2,5]   2 与 5 不连通\n[3,6]   3 与 6 连通，存在路径 3--6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/18/tmp.jpg\" style=\"width: 532px; height: 302px;\" /></p>\n\n<p> </p>\n\n<pre>\n<strong>输入：</strong>n = 6, threshold = 0, queries = [[4,5],[3,4],[3,2],[2,6],[1,3]]\n<strong>输出：</strong>[true,true,true,true,true]\n<strong>解释：</strong>每个数的因数与上一个例子相同。但是，由于阈值为 0 ，所有的因数都大于阈值。因为所有的数字共享公因数 1 ，所以所有的城市都互相连通。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/16/ex3.jpg\" style=\"width: 282px; height: 282px;\" /></p>\n\n<p> </p>\n\n<pre>\n<strong>输入：</strong>n = 5, threshold = 1, queries = [[4,5],[4,5],[3,2],[2,3],[3,4]]\n<strong>输出：</strong>[false,false,false,false,false]\n<strong>解释：</strong>只有城市 2 和 4 共享的公约数 2 严格大于阈值 1 ，所以只有这两座城市是连通的。\n注意，同一对节点 [x, y] 可以有多个查询，并且查询 [x，y] 等同于查询 [y，x] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 10<sup>4</sup></code></li>\n\t<li><code>0 <= threshold <= n</code></li>\n\t<li><code>1 <= queries.length <= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>1 <= a<sub>i</sub>, b<sub>i</sub> <= cities</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1628设计带解析函数的表达式树",
        "hardRate": "MEDIUM",
        "passRate": "82.41%",
        "problemsUrl": "https://leetcode.cn/problems/design-an-expression-tree-with-evaluate-function/",
        "solutionsUrl": "https://leetcode.cn/problems/design-an-expression-tree-with-evaluate-function/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1629按键持续时间最长的键",
        "hardRate": "EASY",
        "passRate": "55.85%",
        "problemsUrl": "https://leetcode.cn/problems/slowest-key/",
        "solutionsUrl": "https://leetcode.cn/problems/slowest-key/solution",
        "problemsDesc": "<p>LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 <code>n</code> 个），每次一个。</p>\n\n<p>给你一个长度为 <code>n</code> 的字符串 <code>keysPressed</code> ，其中 <code>keysPressed[i]</code> 表示测试序列中第 <code>i</code> 个被按下的键。<code>releaseTimes</code> 是一个升序排列的列表，其中 <code>releaseTimes[i]</code> 表示松开第 <code>i</code> 个键的时间。字符串和数组的 <strong>下标都从 0 开始</strong> 。第 <code>0</code> 个键在时间为 <code>0</code> 时被按下，接下来每个键都 <strong>恰好</strong> 在前一个键松开时被按下。</p>\n\n<p>测试人员想要找出按键 <strong>持续时间最长</strong> 的键。第 <code>i</code><sup> </sup>次按键的持续时间为 <code>releaseTimes[i] - releaseTimes[i - 1]</code> ，第 <code>0</code> 次按键的持续时间为 <code>releaseTimes[0]</code> 。</p>\n\n<p>注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。</p>\n\n<p>请返回单次按键 <strong>持续时间最长</strong> 的键，如果有多个这样的键，则返回 <strong>按字母顺序排列最大</strong> 的那个键。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>releaseTimes = [9,29,49,50], keysPressed = \"cbcd\"\n<strong>输出：</strong>\"c\"\n<strong>解释：</strong>按键顺序和持续时间如下：\n按下 'c' ，持续时间 9（时间 0 按下，时间 9 松开）\n按下 'b' ，持续时间 29 - 9 = 20（松开上一个键的时间 9 按下，时间 29 松开）\n按下 'c' ，持续时间 49 - 29 = 20（松开上一个键的时间 29 按下，时间 49 松开）\n按下 'd' ，持续时间 50 - 49 = 1（松开上一个键的时间 49 按下，时间 50 松开）\n按键持续时间最长的键是 'b' 和 'c'（第二次按下时），持续时间都是 20\n'c' 按字母顺序排列比 'b' 大，所以答案是 'c'\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>releaseTimes = [12,23,36,46,62], keysPressed = \"spuda\"\n<strong>输出：</strong>\"a\"\n<strong>解释：</strong>按键顺序和持续时间如下：\n按下 's' ，持续时间 12\n按下 'p' ，持续时间 23 - 12 = 11\n按下 'u' ，持续时间 36 - 23 = 13\n按下 'd' ，持续时间 46 - 36 = 10\n按下 'a' ，持续时间 62 - 46 = 16\n按键持续时间最长的键是 'a' ，持续时间 16</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>releaseTimes.length == n</code></li>\n\t<li><code>keysPressed.length == n</code></li>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= releaseTimes[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>releaseTimes[i] &lt; releaseTimes[i+1]</code></li>\n\t<li><code>keysPressed</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1630等差子数组",
        "hardRate": "MEDIUM",
        "passRate": "76.13%",
        "problemsUrl": "https://leetcode.cn/problems/arithmetic-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/arithmetic-subarrays/solution",
        "problemsDesc": "<p>如果一个数列由至少两个元素组成，且每两个连续元素之间的差值都相同，那么这个序列就是 <strong>等差数列</strong> 。更正式地，数列 <code>s</code> 是等差数列，只需要满足：对于每个有效的 <code>i</code> ， <code>s[i+1] - s[i] == s[1] - s[0]</code> 都成立。</p>\n\n<p>例如，下面这些都是 <strong>等差数列</strong> ：</p>\n\n<pre>1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9</pre>\n\n<p>下面的数列 <strong>不是等差数列</strong> ：</p>\n\n<pre>1, 1, 2, 5, 7</pre>\n\n<p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code>，和两个由 <code>m</code> 个整数组成的数组 <code>l</code> 和 <code>r</code>，后两个数组表示 <code>m</code> 组范围查询，其中第 <code>i</code> 个查询对应范围 <code>[l[i], r[i]]</code> 。所有数组的下标都是 <strong>从 0 开始</strong> 的。</p>\n\n<p>返回<em> </em><code>boolean</code> 元素构成的答案列表 <code>answer</code> 。如果子数组 <code>nums[l[i]], nums[l[i]+1], ... , nums[r[i]]</code> 可以 <strong>重新排列</strong> 形成 <strong>等差数列</strong> ，<code>answer[i]</code> 的值就是 <code>true</code>；否则<code>answer[i]</code> 的值就是 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = <code>[4,6,5,9,3,7]</code>, l = <code>[0,0,2]</code>, r = <code>[2,3,5]</code>\n<strong>输出：</strong><code>[true,false,true]</code>\n<strong>解释：</strong>\n第 0 个查询，对应子数组 [4,6,5] 。可以重新排列为等差数列 [6,5,4] 。\n第 1 个查询，对应子数组 [4,6,5,9] 。无法重新排列形成等差数列。\n第 2 个查询，对应子数组 <code>[5,9,3,7] 。</code>可以重新排列为等差数列 <code>[3,5,7,9] 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]\n<strong>输出：</strong>[false,true,false,false,true,true]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>m == l.length</code></li>\n\t<li><code>m == r.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= m &lt;= 500</code></li>\n\t<li><code>0 &lt;= l[i] &lt; r[i] &lt; n</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1631最小体力消耗路径",
        "hardRate": "MEDIUM",
        "passRate": "50.94%",
        "problemsUrl": "https://leetcode.cn/problems/path-with-minimum-effort/",
        "solutionsUrl": "https://leetcode.cn/problems/path-with-minimum-effort/solution",
        "problemsDesc": "<p>你准备参加一场远足活动。给你一个二维 <code>rows x columns</code> 的地图 <code>heights</code> ，其中 <code>heights[row][col]</code> 表示格子 <code>(row, col)</code> 的高度。一开始你在最左上角的格子 <code>(0, 0)</code> ，且你希望去最右下角的格子 <code>(rows-1, columns-1)</code> （注意下标从 <strong>0</strong> 开始编号）。你每次可以往 <strong>上</strong>，<strong>下</strong>，<strong>左</strong>，<strong>右</strong> 四个方向之一移动，你想要找到耗费 <strong>体力</strong> 最小的一条路径。</p>\n\n<p>一条路径耗费的 <strong>体力值</strong> 是路径上相邻格子之间 <strong>高度差绝对值</strong> 的 <strong>最大值</strong> 决定的。</p>\n\n<p>请你返回从左上角走到右下角的最小<strong> 体力消耗值</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex1.png\" style=\"width: 300px; height: 300px;\" /></p>\n\n<pre>\n<b>输入：</b>heights = [[1,2,2],[3,8,2],[5,3,5]]\n<b>输出：</b>2\n<b>解释：</b>路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。\n这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex2.png\" style=\"width: 300px; height: 300px;\" /></p>\n\n<pre>\n<b>输入：</b>heights = [[1,2,3],[3,8,4],[5,3,5]]\n<b>输出：</b>1\n<b>解释：</b>路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex3.png\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<b>输入：</b>heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]\n<b>输出：</b>0\n<b>解释：</b>上图所示路径不需要消耗任何体力。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rows == heights.length</code></li>\n\t<li><code>columns == heights[i].length</code></li>\n\t<li><code>1 <= rows, columns <= 100</code></li>\n\t<li><code>1 <= heights[i][j] <= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1632矩阵转换后的秩",
        "hardRate": "HARD",
        "passRate": "57.47%",
        "problemsUrl": "https://leetcode.cn/problems/rank-transform-of-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/rank-transform-of-a-matrix/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> ，请你返回一个新的矩阵<em> </em><code>answer</code> ，其中<em> </em><code>answer[row][col]</code> 是 <code>matrix[row][col]</code> 的秩。</p>\n\n<p>每个元素的 <b>秩</b> 是一个整数，表示这个元素相对于其他元素的大小关系，它按照如下规则计算：</p>\n\n<ul>\n\t<li>秩是从 1 开始的一个整数。</li>\n\t<li>如果两个元素 <code>p</code> 和 <code>q</code> 在 <strong>同一行</strong> 或者 <strong>同一列</strong> ，那么：\n\t<ul>\n\t\t<li>如果 <code>p < q</code> ，那么 <code>rank(p) < rank(q)</code></li>\n\t\t<li>如果 <code>p == q</code> ，那么 <code>rank(p) == rank(q)</code></li>\n\t\t<li>如果 <code>p > q</code> ，那么 <code>rank(p) > rank(q)</code></li>\n\t</ul>\n\t</li>\n\t<li><b>秩</b> 需要越 <strong>小</strong> 越好。</li>\n</ul>\n\n<p>题目保证按照上面规则 <code>answer</code> 数组是唯一的。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank1.jpg\" style=\"width: 442px; height: 162px;\" />\n<pre>\n<b>输入：</b>matrix = [[1,2],[3,4]]\n<b>输出：</b>[[1,2],[2,3]]\n<strong>解释：</strong>\nmatrix[0][0] 的秩为 1 ，因为它是所在行和列的最小整数。\nmatrix[0][1] 的秩为 2 ，因为 matrix[0][1] > matrix[0][0] 且 matrix[0][0] 的秩为 1 。\nmatrix[1][0] 的秩为 2 ，因为 matrix[1][0] > matrix[0][0] 且 matrix[0][0] 的秩为 1 。\nmatrix[1][1] 的秩为 3 ，因为 matrix[1][1] > matrix[0][1]， matrix[1][1] > matrix[1][0] 且 matrix[0][1] 和 matrix[1][0] 的秩都为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank2.jpg\" style=\"width: 442px; height: 162px;\" />\n<pre>\n<b>输入：</b>matrix = [[7,7],[7,7]]\n<b>输出：</b>[[1,1],[1,1]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank3.jpg\" style=\"width: 601px; height: 322px;\" />\n<pre>\n<b>输入：</b>matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]\n<b>输出：</b>[[4,2,3],[1,3,4],[5,1,6],[1,3,4]]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank4.jpg\" style=\"width: 601px; height: 242px;\" />\n<pre>\n<b>输入：</b>matrix = [[7,3,6],[1,4,5],[9,8,2]]\n<b>输出：</b>[[5,1,4],[1,2,3],[6,3,1]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 <= m, n <= 500</code></li>\n\t<li><code>-10<sup>9</sup> <= matrix[row][col] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1633各赛事的用户注册率",
        "hardRate": "EASY",
        "passRate": "62.57%",
        "problemsUrl": "https://leetcode.cn/problems/percentage-of-users-attended-a-contest/",
        "solutionsUrl": "https://leetcode.cn/problems/percentage-of-users-attended-a-contest/solution",
        "problemsDesc": "<p>用户表：&nbsp;<code>Users</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| user_id     | int     |\n| user_name   | varchar |\n+-------------+---------+\nuser_id 是该表的主键。\n该表中的每行包括用户 ID 和用户名。</pre>\n\n<p>&nbsp;</p>\n\n<p>注册表：&nbsp;<code>Register</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| contest_id  | int     |\n| user_id     | int     |\n+-------------+---------+\n(contest_id, user_id) 是该表的主键。\n该表中的每行包含用户的 ID 和他们注册的赛事。</pre>\n\n<p>&nbsp;</p>\n\n<p>写一条 SQL 语句，查询各赛事的用户注册百分率，保留两位小数。</p>\n\n<p>返回的结果表按&nbsp;<code>percentage</code>&nbsp;的&nbsp;<strong>降序&nbsp;</strong>排序，若相同则按&nbsp;<code>contest_id</code>&nbsp;的&nbsp;<strong>升序&nbsp;</strong>排序。</p>\n\n<p>查询结果如下示例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<code><strong>输入：</strong>\nUsers</code> 表：\n+---------+-----------+\n| user_id | user_name |\n+---------+-----------+\n| 6       | Alice     |\n| 2       | Bob       |\n| 7       | Alex      |\n+---------+-----------+\n\n<code>Register</code> 表：\n+------------+---------+\n| contest_id | user_id |\n+------------+---------+\n| 215        | 6       |\n| 209        | 2       |\n| 208        | 2       |\n| 210        | 6       |\n| 208        | 6       |\n| 209        | 7       |\n| 209        | 6       |\n| 215        | 7       |\n| 208        | 7       |\n| 210        | 2       |\n| 207        | 2       |\n| 210        | 7       |\n+------------+---------+\n<strong>输出：</strong>\n+------------+------------+\n| contest_id | percentage |\n+------------+------------+\n| 208        | 100.0      |\n| 209        | 100.0      |\n| 210        | 100.0      |\n| 215        | 66.67      |\n| 207        | 33.33      |\n+------------+------------+\n<strong>解释：</strong>\n所有用户都注册了 208、209 和 210 赛事，因此这些赛事的注册率为 100% ，我们按 contest_id 的降序排序加入结果表中。\nAlice 和 Alex 注册了 215 赛事，注册率为 ((2/3) * 100) = 66.67%\nBob 注册了 207 赛事，注册率为 ((1/3) * 100) = 33.33%</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1634求两个多项式链表的和",
        "hardRate": "MEDIUM",
        "passRate": "60.13%",
        "problemsUrl": "https://leetcode.cn/problems/add-two-polynomials-represented-as-linked-lists/",
        "solutionsUrl": "https://leetcode.cn/problems/add-two-polynomials-represented-as-linked-lists/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1635Hopper 公司查询 I",
        "hardRate": "HARD",
        "passRate": "49.13%",
        "problemsUrl": "https://leetcode.cn/problems/hopper-company-queries-i/",
        "solutionsUrl": "https://leetcode.cn/problems/hopper-company-queries-i/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1636按照频率将数组升序排序",
        "hardRate": "EASY",
        "passRate": "74.75%",
        "problemsUrl": "https://leetcode.cn/problems/sort-array-by-increasing-frequency/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-array-by-increasing-frequency/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，请你将数组按照每个值的频率 <strong>升序</strong> 排序。如果有多个值的频率相同，请你按照数值本身将它们 <strong>降序</strong> 排序。 </p>\n\n<p>请你返回排序后的数组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,1,2,2,2,3]\n<b>输出：</b>[3,1,1,2,2,2]\n<b>解释：</b>'3' 频率为 1，'1' 频率为 2，'2' 频率为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,3,1,3,2]\n<b>输出：</b>[1,3,3,2,2]\n<b>解释：</b>'2' 和 '3' 频率都为 2 ，所以它们之间按照数值本身降序排序。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [-1,1,-6,4,5,-6,1,4,1]\n<b>输出：</b>[5,-1,4,4,-6,-6,1,1,1]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1637两点之间不包含任何点的最宽垂直区域",
        "hardRate": "MEDIUM",
        "passRate": "84.34%",
        "problemsUrl": "https://leetcode.cn/problems/widest-vertical-area-between-two-points-containing-no-points/",
        "solutionsUrl": "https://leetcode.cn/problems/widest-vertical-area-between-two-points-containing-no-points/solution",
        "problemsDesc": "<p>给你&nbsp;<code>n</code>&nbsp;个二维平面上的点 <code>points</code> ，其中&nbsp;<code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;，请你返回两点之间内部不包含任何点的&nbsp;<strong>最宽垂直区域</strong> 的宽度。</p>\n\n<p><strong>垂直区域</strong> 的定义是固定宽度，而 y 轴上无限延伸的一块区域（也就是高度为无穷大）。 <strong>最宽垂直区域</strong> 为宽度最大的一个垂直区域。</p>\n\n<p>请注意，垂直区域&nbsp;<strong>边上</strong>&nbsp;的点&nbsp;<strong>不在</strong>&nbsp;区域内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/31/points3.png\" style=\"width: 276px; height: 371px;\" />​\n<pre>\n<b>输入：</b>points = [[8,7],[9,9],[7,4],[9,7]]\n<b>输出：</b>1\n<b>解释：</b>红色区域和蓝色区域都是最优区域。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]\n<b>输出：</b>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == points.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1638统计只差一个字符的子串数目",
        "hardRate": "MEDIUM",
        "passRate": "77.64%",
        "problemsUrl": "https://leetcode.cn/problems/count-substrings-that-differ-by-one-character/",
        "solutionsUrl": "https://leetcode.cn/problems/count-substrings-that-differ-by-one-character/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>s</code> 和&nbsp;<code>t</code>&nbsp;，请你找出 <code>s</code>&nbsp;中的非空子串的数目，这些子串满足替换 <strong>一个不同字符</strong>&nbsp;以后，是 <code>t</code>&nbsp;串的子串。换言之，请你找到 <code>s</code>&nbsp;和 <code>t</code>&nbsp;串中 <strong>恰好</strong>&nbsp;只有一个字符不同的子字符串对的数目。</p>\n\n<p>比方说，&nbsp;<code>\"<u>compute</u>r\"</code>&nbsp;and&nbsp;<code>\"<u>computa</u>tion\"&nbsp;</code>只有一个字符不同：&nbsp;<code>'e'</code>/<code>'a'</code>&nbsp;，所以这一对子字符串会给答案加 1 。</p>\n\n<p>请你返回满足上述条件的不同子字符串对数目。</p>\n\n<p>一个 <strong>子字符串</strong>&nbsp;是一个字符串中连续的字符。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aba\", t = \"baba\"\n<b>输出：</b>6\n<strong>解释：</strong>以下为只相差 1 个字符的 s 和 t 串的子字符串对：\n(\"<strong>a</strong>ba\", \"<strong>b</strong>aba\")\n(\"<strong>a</strong>ba\", \"ba<strong>b</strong>a\")\n(\"ab<strong>a</strong>\", \"<strong>b</strong>aba\")\n(\"ab<strong>a</strong>\", \"ba<strong>b</strong>a\")\n(\"a<strong>b</strong>a\", \"b<strong>a</strong>ba\")\n(\"a<strong>b</strong>a\", \"bab<strong>a</strong>\")\n加粗部分分别表示 s 和 t 串选出来的子字符串。\n</pre>\n<strong>示例 2：</strong>\n\n<pre>\n<b>输入：</b>s = \"ab\", t = \"bb\"\n<b>输出：</b>3\n<strong>解释：</strong>以下为只相差 1 个字符的 s 和 t 串的子字符串对：\n(\"<strong>a</strong>b\", \"<strong>b</strong>b\")\n(\"<strong>a</strong>b\", \"b<strong>b</strong>\")\n(\"<strong>ab</strong>\", \"<strong>bb</strong>\")\n加粗部分分别表示 s 和 t 串选出来的子字符串。\n</pre>\n<strong>示例 3：</strong>\n\n<pre>\n<b>输入：</b>s = \"a\", t = \"a\"\n<b>输出：</b>0\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"abe\", t = \"bbc\"\n<b>输出：</b>10\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 100</code></li>\n\t<li><code>s</code> 和&nbsp;<code>t</code>&nbsp;都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1639通过给定词典构造目标字符串的方案数",
        "hardRate": "HARD",
        "passRate": "46.88%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solution",
        "problemsDesc": "<p>给你一个字符串列表 <code>words</code> 和一个目标字符串 <code>target</code> 。<code>words</code> 中所有字符串都 <strong>长度相同</strong>  。</p>\n\n<p>你的目标是使用给定的 <code>words</code> 字符串列表按照下述规则构造 <code>target</code> ：</p>\n\n<ul>\n\t<li>从左到右依次构造 <code>target</code> 的每一个字符。</li>\n\t<li>为了得到 <code>target</code> 第 <code>i</code> 个字符（下标从 <strong>0</strong> 开始），当 <code>target[i] = words[j][k]</code> 时，你可以使用 <code>words</code> 列表中第 <code>j</code> 个字符串的第 <code>k</code> 个字符。</li>\n\t<li>一旦你使用了 <code>words</code> 中第 <code>j</code> 个字符串的第 <code>k</code> 个字符，你不能再使用 <code>words</code> 字符串列表中任意单词的第 <code>x</code> 个字符（<code>x <= k</code>）。也就是说，所有单词下标小于等于 <code>k</code> 的字符都不能再被使用。</li>\n\t<li>请你重复此过程直到得到目标字符串 <code>target</code> 。</li>\n</ul>\n\n<p><strong>请注意</strong>， 在构造目标字符串的过程中，你可以按照上述规定使用 <code>words</code> 列表中 <strong>同一个字符串</strong> 的 <strong>多个字符</strong> 。</p>\n\n<p>请你返回使用 <code>words</code> 构造 <code>target</code> 的方案数。由于答案可能会很大，请对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后返回。</p>\n\n<p>（译者注：此题目求的是有多少个不同的 <code>k</code> 序列，详情请见示例。）</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"acca\",\"bbbb\",\"caca\"], target = \"aba\"\n<b>输出：</b>6\n<b>解释：</b>总共有 6 种方法构造目标串。\n\"aba\" -> 下标为 0 (\"<strong>a</strong>cca\")，下标为 1 (\"b<strong>b</strong>bb\")，下标为 3 (\"cac<strong>a</strong>\")\n\"aba\" -> 下标为 0 (\"<strong>a</strong>cca\")，下标为 2 (\"bb<strong>b</strong>b\")，下标为 3 (\"cac<strong>a</strong>\")\n\"aba\" -> 下标为 0 (\"<strong>a</strong>cca\")，下标为 1 (\"b<strong>b</strong>bb\")，下标为 3 (\"acc<strong>a</strong>\")\n\"aba\" -> 下标为 0 (\"<strong>a</strong>cca\")，下标为 2 (\"bb<strong>b</strong>b\")，下标为 3 (\"acc<strong>a</strong>\")\n\"aba\" -> 下标为 1 (\"c<strong>a</strong>ca\")，下标为 2 (\"bb<strong>b</strong>b\")，下标为 3 (\"acc<strong>a</strong>\")\n\"aba\" -> 下标为 1 (\"c<strong>a</strong>ca\")，下标为 2 (\"bb<strong>b</strong>b\")，下标为 3 (\"cac<strong>a</strong>\")\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"abba\",\"baab\"], target = \"bab\"\n<b>输出：</b>4\n<b>解释：</b>总共有 4 种不同形成 target 的方法。\n\"bab\" -> 下标为 0 (\"<strong>b</strong>aab\")，下标为 1 (\"b<strong>a</strong>ab\")，下标为 2 (\"ab<strong>b</strong>a\")\n\"bab\" -> 下标为 0 (\"<strong>b</strong>aab\")，下标为 1 (\"b<strong>a</strong>ab\")，下标为 3 (\"baa<strong>b</strong>\")\n\"bab\" -> 下标为 0 (\"<strong>b</strong>aab\")，下标为 2 (\"ba<strong>a</strong>b\")，下标为 3 (\"baa<strong>b</strong>\")\n\"bab\" -> 下标为 1 (\"a<strong>b</strong>ba\")，下标为 2 (\"ba<strong>a</strong>b\")，下标为 3 (\"baa<strong>b</strong>\")\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"abcd\"], target = \"abcd\"\n<b>输出：</b>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"abab\",\"baba\",\"abba\",\"baab\"], target = \"abba\"\n<b>输出：</b>16\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= words.length <= 1000</code></li>\n\t<li><code>1 <= words[i].length <= 1000</code></li>\n\t<li><code>words</code> 中所有单词长度相同。</li>\n\t<li><code>1 <= target.length <= 1000</code></li>\n\t<li><code>words[i]</code> 和 <code>target</code> 都仅包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1640能否连接形成数组",
        "hardRate": "EASY",
        "passRate": "60.94%",
        "problemsUrl": "https://leetcode.cn/problems/check-array-formation-through-concatenation/",
        "solutionsUrl": "https://leetcode.cn/problems/check-array-formation-through-concatenation/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> ，数组中的每个整数 <strong>互不相同</strong> 。另有一个由整数数组构成的数组 <code>pieces</code>，其中的整数也 <strong>互不相同</strong> 。请你以 <strong>任意顺序</strong> 连接 <code>pieces</code> 中的数组以形成 <code>arr</code> 。但是，<strong>不允许</strong> 对每个数组 <code>pieces[i]</code> 中的整数重新排序。</p>\n\n<p>如果可以连接<em> </em><code>pieces</code> 中的数组形成 <code>arr</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [15,88], pieces = [[88],[15]]\n<strong>输出：</strong>true\n<strong>解释：</strong>依次连接 <code>[15]</code> 和 <code>[88]</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [49,18,16], pieces = [[16,18,49]]\n<strong>输出：</strong>false\n<strong>解释：</strong>即便数字相符，也不能重新排列 pieces[0]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [91,4,64,78], pieces = [[78],[4,64],[91]]\n<strong>输出：</strong>true\n<strong>解释：</strong>依次连接 <code>[91]</code>、<code>[4,64]</code> 和 <code>[78]</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pieces.length &lt;= arr.length &lt;= 100</code></li>\n\t<li><code>sum(pieces[i].length) == arr.length</code></li>\n\t<li><code>1 &lt;= pieces[i].length &lt;= arr.length</code></li>\n\t<li><code>1 &lt;= arr[i], pieces[i][j] &lt;= 100</code></li>\n\t<li><code>arr</code> 中的整数 <strong>互不相同</strong></li>\n\t<li><code>pieces</code> 中的整数 <strong>互不相同</strong>（也就是说，如果将 <code>pieces</code> 扁平化成一维数组，数组中的所有整数互不相同）</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1641统计字典序元音字符串的数目",
        "hardRate": "MEDIUM",
        "passRate": "82.41%",
        "problemsUrl": "https://leetcode.cn/problems/count-sorted-vowel-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/count-sorted-vowel-strings/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code>，请返回长度为 <code>n</code> 、仅由元音 (<code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>) 组成且按 <strong>字典序排列</strong> 的字符串数量。</p>\n\n<p>字符串 <code>s</code> 按 <strong>字典序排列</strong> 需要满足：对于所有有效的 <code>i</code>，<code>s[i]</code> 在字母表中的位置总是与 <code>s[i+1]</code> 相同或在 <code>s[i+1]</code> 之前。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>5\n<strong>解释：</strong>仅由元音组成的 5 个字典序字符串为 <code>[\"a\",\"e\",\"i\",\"o\",\"u\"]</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>15\n<strong>解释：</strong>仅由元音组成的 15 个字典序字符串为\n[\"aa\",\"ae\",\"ai\",\"ao\",\"au\",\"ee\",\"ei\",\"eo\",\"eu\",\"ii\",\"io\",\"iu\",\"oo\",\"ou\",\"uu\"]\n注意，\"ea\" 不是符合题意的字符串，因为 'e' 在字母表中的位置比 'a' 靠后\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 33\n<strong>输出：</strong>66045\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 50</code> </li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1642可以到达的最远建筑",
        "hardRate": "MEDIUM",
        "passRate": "45.33%",
        "problemsUrl": "https://leetcode.cn/problems/furthest-building-you-can-reach/",
        "solutionsUrl": "https://leetcode.cn/problems/furthest-building-you-can-reach/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>heights</code> ，表示建筑物的高度。另有一些砖块 <code>bricks</code> 和梯子 <code>ladders</code> 。</p>\n\n<p>你从建筑物 <code>0</code> 开始旅程，不断向后面的建筑物移动，期间可能会用到砖块或梯子。</p>\n\n<p>当从建筑物 <code>i</code> 移动到建筑物 <code>i+1</code>（下标<strong> 从 0 开始 </strong>）时：</p>\n\n<ul>\n\t<li>如果当前建筑物的高度 <strong>大于或等于</strong> 下一建筑物的高度，则不需要梯子或砖块</li>\n\t<li>如果当前建筑的高度 <strong>小于</strong> 下一个建筑的高度，您可以使用 <strong>一架梯子</strong> 或 <strong><code>(h[i+1] - h[i])</code> 个砖块</strong></li>\n</ul>\n如果以最佳方式使用给定的梯子和砖块，返回你可以到达的最远建筑物的下标（下标<strong> 从 0 开始 </strong>）。\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/31/q4.gif\" style=\"width: 562px; height: 561px;\" />\n<pre>\n<strong>输入：</strong>heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1\n<strong>输出：</strong>4\n<strong>解释：</strong>从建筑物 0 出发，你可以按此方案完成旅程：\n- 不使用砖块或梯子到达建筑物 1 ，因为 4 >= 2\n- 使用 5 个砖块到达建筑物 2 。你必须使用砖块或梯子，因为 2 < 7\n- 不使用砖块或梯子到达建筑物 3 ，因为 7 >= 6\n- 使用唯一的梯子到达建筑物 4 。你必须使用砖块或梯子，因为 6 < 9\n无法越过建筑物 4 ，因为没有更多砖块或梯子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2\n<strong>输出：</strong>7\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>heights = [14,3,19,3], bricks = 17, ladders = 0\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= heights.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= heights[i] <= 10<sup>6</sup></code></li>\n\t<li><code>0 <= bricks <= 10<sup>9</sup></code></li>\n\t<li><code>0 <= ladders <= heights.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1643第 K 条最小指令",
        "hardRate": "HARD",
        "passRate": "48.06%",
        "problemsUrl": "https://leetcode.cn/problems/kth-smallest-instructions/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-smallest-instructions/solution",
        "problemsDesc": "<p>Bob 站在单元格 <code>(0, 0)</code> ，想要前往目的地 <code>destination</code> ：<code>(row, column)</code> 。他只能向 <strong>右</strong> 或向 <strong>下</strong> 走。你可以为 Bob 提供导航 <strong>指令</strong> 来帮助他到达目的地 <code>destination</code> 。</p>\n\n<p><strong>指令</strong> 用字符串表示，其中每个字符：</p>\n\n<ul>\n\t<li><code>'H'</code> ，意味着水平向右移动</li>\n\t<li><code>'V'</code> ，意味着竖直向下移动</li>\n</ul>\n\n<p>能够为 Bob 导航到目的地 <code>destination</code> 的指令可以有多种，例如，如果目的地 <code>destination</code> 是 <code>(2, 3)</code>，<code>\"HHHVV\"</code> 和 <code>\"HVHVH\"</code> 都是有效<strong> 指令</strong> 。</p>\n\n<ul>\n</ul>\n\n<p>然而，Bob 很挑剔。因为他的幸运数字是 <code>k</code>，他想要遵循 <strong>按字典序排列后的第 <code>k</code> 条最小指令 </strong>的导航前往目的地 <code>destination</code> 。<code>k</code>  的编号 <strong>从 1 开始</strong> 。</p>\n\n<p>给你一个整数数组 <code>destination</code> 和一个整数 <code>k</code> ，请你返回可以为<em> </em>Bob<em> </em>提供前往目的地 <code>destination</code> 导航的<strong> 按字典序排列后的第 <code>k</code> 条最小指令 </strong>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/01/ex1.png\" style=\"width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>destination = [2,3], k = 1\n<strong>输出：</strong>\"HHHVV\"\n<strong>解释：</strong>能前往 (2, 3) 的所有导航指令 <strong>按字典序排列后</strong> 如下所示：\n[\"HHHVV\", \"HHVHV\", \"HHVVH\", \"HVHHV\", \"HVHVH\", \"HVVHH\", \"VHHHV\", \"VHHVH\", \"VHVHH\", \"VVHHH\"].\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/01/ex2.png\" style=\"width: 300px; height: 229px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>destination = [2,3], k = 2\n<strong>输出：</strong>\"HHVHV\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/01/ex3.png\" style=\"width: 300px; height: 229px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>destination = [2,3], k = 3\n<strong>输出：</strong>\"HHVVH\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>destination.length == 2</code></li>\n\t<li><code>1 <= row, column <= 15</code></li>\n\t<li><code>1 <= k <= nCr(row + column, row)</code>，其中 <code>nCr(a, b)</code> 表示组合数，即从 <code>a</code> 个物品中选 <code>b</code> 个物品的不同方案数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1644二叉树的最近公共祖先 II",
        "hardRate": "MEDIUM",
        "passRate": "56.08%",
        "problemsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 16451645.Hopper 公司查询 II",
        "hardRate": "HARD",
        "passRate": "41.72%",
        "problemsUrl": "https://leetcode.cn/problems/hopper-company-queries-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/hopper-company-queries-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1646获取生成数组中的最大值",
        "hardRate": "EASY",
        "passRate": "51.90%",
        "problemsUrl": "https://leetcode.cn/problems/get-maximum-in-generated-array/",
        "solutionsUrl": "https://leetcode.cn/problems/get-maximum-in-generated-array/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> 。按下述规则生成一个长度为 <code>n + 1</code> 的数组 <code>nums</code> ：</p>\n\n<ul>\n\t<li><code>nums[0] = 0</code></li>\n\t<li><code>nums[1] = 1</code></li>\n\t<li>当 <code>2 <= 2 * i <= n</code> 时，<code>nums[2 * i] = nums[i]</code></li>\n\t<li>当 <code>2 <= 2 * i + 1 <= n</code> 时，<code>nums[2 * i + 1] = nums[i] + nums[i + 1]</code></li>\n</ul>\n\n<p>返回生成数组 <code>nums</code> 中的 <strong>最大</strong> 值。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 7\n<strong>输出：</strong>3\n<strong>解释：</strong>根据规则：\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\n因此，nums = [0,1,1,2,1,3,2,3]，最大值 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>根据规则，nums[0]、nums[1] 和 nums[2] 之中的最大值是 1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>根据规则，nums[0]、nums[1]、nums[2] 和 nums[3] 之中的最大值是 2\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= n <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1647字符频次唯一的最小删除次数",
        "hardRate": "MEDIUM",
        "passRate": "54.50%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-character-frequencies-unique/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-character-frequencies-unique/solution",
        "problemsDesc": "<p>如果字符串 <code>s</code> 中 <strong>不存在</strong> 两个不同字符 <strong>频次</strong> 相同的情况，就称 <code>s</code> 是 <strong>优质字符串</strong> 。</p>\n\n<p>给你一个字符串 <code>s</code>，返回使 <code>s</code> 成为 <strong>优质字符串</strong> 需要删除的 <strong>最小</strong> 字符数。</p>\n\n<p>字符串中字符的 <strong>频次</strong> 是该字符在字符串中的出现次数。例如，在字符串 <code>\"aab\"</code> 中，<code>'a'</code> 的频次是 <code>2</code>，而 <code>'b'</code> 的频次是 <code>1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aab\"\n<strong>输出：</strong>0\n<strong>解释：</strong><code>s</code> 已经是优质字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aaabbbcc\"\n<strong>输出：</strong>2\n<strong>解释：</strong>可以删除两个 'b' , 得到优质字符串 \"aaabcc\" 。\n另一种方式是删除一个 'b' 和一个 'c' ，得到优质字符串 \"aaabbc\" 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ceabaacb\"\n<strong>输出：</strong>2\n<strong>解释：</strong>可以删除两个 'c' 得到优质字符串 \"eabaab\" 。\n注意，只需要关注结果字符串中仍然存在的字符。（即，频次为 0 的字符会忽略不计。）\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 仅含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1648销售价值减少的颜色球",
        "hardRate": "MEDIUM",
        "passRate": "31.57%",
        "problemsUrl": "https://leetcode.cn/problems/sell-diminishing-valued-colored-balls/",
        "solutionsUrl": "https://leetcode.cn/problems/sell-diminishing-valued-colored-balls/solution",
        "problemsDesc": "<p>你有一些球的库存 <code>inventory</code> ，里面包含着不同颜色的球。一个顾客想要 <strong>任意颜色</strong> 总数为 <code>orders</code> 的球。</p>\n\n<p>这位顾客有一种特殊的方式衡量球的价值：每个球的价值是目前剩下的 <strong>同色球</strong> 的数目。比方说还剩下 <code>6</code> 个黄球，那么顾客买第一个黄球的时候该黄球的价值为 <code>6</code> 。这笔交易以后，只剩下 <code>5</code> 个黄球了，所以下一个黄球的价值为 <code>5</code> （也就是球的价值随着顾客购买同色球是递减的）</p>\n\n<p>给你整数数组 <code>inventory</code> ，其中 <code>inventory[i]</code> 表示第 <code>i</code> 种颜色球一开始的数目。同时给你整数 <code>orders</code> ，表示顾客总共想买的球数目。你可以按照 <strong>任意顺序</strong> 卖球。</p>\n\n<p>请你返回卖了 <code>orders</code> 个球以后 <strong>最大</strong> 总价值之和。由于答案可能会很大，请你返回答案对 <code>10<sup>9</sup> + 7</code> <strong>取余数</strong> 的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/08/jj.gif\" style=\"width: 480px; height: 270px;\" />\n<pre>\n<b>输入：</b>inventory = [2,5], orders = 4\n<b>输出：</b>14\n<b>解释：</b>卖 1 个第一种颜色的球（价值为 2 )，卖 3 个第二种颜色的球（价值为 5 + 4 + 3）。\n最大总和为 2 + 5 + 4 + 3 = 14 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>inventory = [3,5], orders = 6\n<b>输出：</b>19\n<strong>解释：</strong>卖 2 个第一种颜色的球（价值为 3 + 2），卖 4 个第二种颜色的球（价值为 5 + 4 + 3 + 2）。\n最大总和为 3 + 2 + 5 + 4 + 3 + 2 = 19 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>inventory = [2,8,4,10,6], orders = 20\n<b>输出：</b>110\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>inventory = [1000000000], orders = 1000000000\n<b>输出：</b>21\n<strong>解释：</strong>卖 1000000000 次第一种颜色的球，总价值为 500000000500000000 。 500000000500000000 对 10<sup>9 </sup>+ 7 取余为 21 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= inventory.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= inventory[i] <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= orders <= min(sum(inventory[i]), 10<sup>9</sup>)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1649通过指令创建有序数组",
        "hardRate": "HARD",
        "passRate": "49.27%",
        "problemsUrl": "https://leetcode.cn/problems/create-sorted-array-through-instructions/",
        "solutionsUrl": "https://leetcode.cn/problems/create-sorted-array-through-instructions/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>instructions</code> ，你需要根据 <code>instructions</code> 中的元素创建一个有序数组。一开始你有一个空的数组 <code>nums</code> ，你需要 <strong>从左到右</strong> 遍历 <code>instructions</code> 中的元素，将它们依次插入 <code>nums</code> 数组中。每一次插入操作的 <strong>代价</strong> 是以下两者的 <strong>较小值</strong> ：</p>\n\n<ul>\n\t<li><code>nums</code> 中 <strong>严格小于 </strong> <code>instructions[i]</code> 的数字数目。</li>\n\t<li><code>nums</code> 中 <strong>严格大于 </strong> <code>instructions[i]</code> 的数字数目。</li>\n</ul>\n\n<p>比方说，如果要将 <code>3</code> 插入到 <code>nums = [1,2,3,5]</code> ，那么插入操作的 <strong>代价</strong> 为 <code>min(2, 1)</code> (元素 <code>1</code> 和  <code>2</code> 小于 <code>3</code> ，元素 <code>5</code> 大于 <code>3</code> ），插入后 <code>nums</code> 变成 <code>[1,2,3,3,5]</code> 。</p>\n\n<p>请你返回将 <code>instructions</code> 中所有元素依次插入 <code>nums</code> 后的 <strong>总最小代价 </strong>。由于答案会很大，请将它对 <code>10<sup>9</sup> + 7</code> <b>取余</b> 后返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>instructions = [1,5,6,2]\n<b>输出：</b>1\n<b>解释：</b>一开始 nums = [] 。\n插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。\n插入 5 ，代价为 min(1, 0) = 0 ，现在 nums = [1,5] 。\n插入 6 ，代价为 min(2, 0) = 0 ，现在 nums = [1,5,6] 。\n插入 2 ，代价为 min(1, 2) = 1 ，现在 nums = [1,2,5,6] 。\n总代价为 0 + 0 + 0 + 1 = 1 。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><b>输入：</b>instructions = [1,2,3,6,5,4]\n<b>输出：</b>3\n<b>解释：</b>一开始 nums = [] 。\n插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。\n插入 2 ，代价为 min(1, 0) = 0 ，现在 nums = [1,2] 。\n插入 3 ，代价为 min(2, 0) = 0 ，现在 nums = [1,2,3] 。\n插入 6 ，代价为 min(3, 0) = 0 ，现在 nums = [1,2,3,6] 。\n插入 5 ，代价为 min(3, 1) = 1 ，现在 nums = [1,2,3,5,6] 。\n插入 4 ，代价为 min(3, 2) = 2 ，现在 nums = [1,2,3,4,5,6] 。\n总代价为 0 + 0 + 0 + 0 + 1 + 2 = 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>instructions = [1,3,3,3,2,4,2,1,2]\n<b>输出：</b>4\n<b>解释：</b>一开始 nums = [] 。\n插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。\n插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3] 。\n插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3,3] 。\n插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3,3,3] 。\n插入 2 ，代价为 min(1, 3) = 1 ，现在 nums = [1,2,3,3,3] 。\n插入 4 ，代价为 min(5, 0) = 0 ，现在 nums = [1,2,3,3,3,4] 。\n​​​​​插入 2 ，代价为 min(1, 4) = 1 ，现在 nums = [1,2,2,3,3,3,4] 。\n插入 1 ，代价为 min(0, 6) = 0 ，现在 nums = [1,1,2,2,3,3,3,4] 。\n插入 2 ，代价为 min(2, 4) = 2 ，现在 nums = [1,1,2,2,2,3,3,3,4] 。\n总代价为 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 2 = 4 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= instructions.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= instructions[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1650二叉树的最近公共祖先 III",
        "hardRate": "MEDIUM",
        "passRate": "79.99%",
        "problemsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1651Hopper 公司查询 III",
        "hardRate": "HARD",
        "passRate": "64.00%",
        "problemsUrl": "https://leetcode.cn/problems/hopper-company-queries-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/hopper-company-queries-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1652拆炸弹",
        "hardRate": "EASY",
        "passRate": "66.42%",
        "problemsUrl": "https://leetcode.cn/problems/defuse-the-bomb/",
        "solutionsUrl": "https://leetcode.cn/problems/defuse-the-bomb/solution",
        "problemsDesc": "<p>你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 <code>n</code> 的 <strong>循环</strong> 数组 <code>code</code> 以及一个密钥 <code>k</code> 。</p>\n\n<p>为了获得正确的密码，你需要替换掉每一个数字。所有数字会 <strong>同时</strong> 被替换。</p>\n\n<ul>\n\t<li>如果 <code>k > 0</code> ，将第 <code>i</code> 个数字用 <strong>接下来</strong> <code>k</code> 个数字之和替换。</li>\n\t<li>如果 <code>k < 0</code> ，将第 <code>i</code> 个数字用 <strong>之前</strong> <code>k</code> 个数字之和替换。</li>\n\t<li>如果 <code>k == 0</code> ，将第 <code>i</code> 个数字用 <code>0</code> 替换。</li>\n</ul>\n\n<p>由于 <code>code</code> 是循环的， <code>code[n-1]</code> 下一个元素是 <code>code[0]</code> ，且 <code>code[0]</code> 前一个元素是 <code>code[n-1]</code> 。</p>\n\n<p>给你 <strong>循环</strong> 数组 <code>code</code> 和整数密钥 <code>k</code> ，请你返回解密后的结果来拆除炸弹！</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>code = [5,7,1,4], k = 3\n<b>输出：</b>[12,10,16,13]\n<b>解释：</b>每个数字都被接下来 3 个数字之和替换。解密后的密码为 [7+1+4, 1+4+5, 4+5+7, 5+7+1]。注意到数组是循环连接的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>code = [1,2,3,4], k = 0\n<b>输出：</b>[0,0,0,0]\n<b>解释：</b>当 k 为 0 时，所有数字都被 0 替换。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>code = [2,4,9,3], k = -2\n<b>输出：</b>[12,5,6,13]\n<b>解释：</b>解密后的密码为 [3+9, 2+3, 4+2, 9+4] 。注意到数组是循环连接的。如果 k 是负数，那么和为 <strong>之前</strong> 的数字。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == code.length</code></li>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>1 <= code[i] <= 100</code></li>\n\t<li><code>-(n - 1) <= k <= n - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1653使字符串平衡的最少删除次数",
        "hardRate": "MEDIUM",
        "passRate": "60.98%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-string-balanced/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-string-balanced/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，它仅包含字符&nbsp;<code>'a'</code> 和&nbsp;<code>'b'</code>​​​​ 。</p>\n\n<p>你可以删除&nbsp;<code>s</code>&nbsp;中任意数目的字符，使得&nbsp;<code>s</code> <strong>平衡</strong>&nbsp;。当不存在下标对&nbsp;<code>(i,j)</code>&nbsp;满足&nbsp;<code>i &lt; j</code> ，且&nbsp;<code>s[i] = 'b'</code> 的同时&nbsp;<code>s[j]= 'a'</code> ，此时认为 <code>s</code> 是 <strong>平衡 </strong>的。</p>\n\n<p>请你返回使 <code>s</code>&nbsp;<strong>平衡</strong>&nbsp;的 <strong>最少</strong>&nbsp;删除次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aababbab\"\n<b>输出：</b>2\n<b>解释：</b>你可以选择以下任意一种方案：\n下标从 0 开始，删除第 2 和第 6 个字符（\"aa<strong>b</strong>abb<strong>a</strong>b\" -&gt; \"aaabbb\"），\n下标从 0 开始，删除第 3 和第 6 个字符（\"aab<strong>a</strong>bb<strong>a</strong>b\" -&gt; \"aabbbb\"）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"bbaaaaabb\"\n<b>输出：</b>2\n<b>解释：</b>唯一的最优解是删除最前面两个字符。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code>&nbsp;要么是&nbsp;<code>'a'</code> 要么是&nbsp;<code>'b'</code>​<strong>&nbsp;</strong>。​</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1654到家的最少跳跃次数",
        "hardRate": "MEDIUM",
        "passRate": "31.18%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-jumps-to-reach-home/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-jumps-to-reach-home/solution",
        "problemsDesc": "<p>有一只跳蚤的家在数轴上的位置 <code>x</code> 处。请你帮助它从位置 <code>0</code> 出发，到达它的家。</p>\n\n<p>跳蚤跳跃的规则如下：</p>\n\n<ul>\n\t<li>它可以 <strong>往前</strong> 跳恰好 <code>a</code> 个位置（即往右跳）。</li>\n\t<li>它可以 <strong>往后</strong> 跳恰好 <code>b</code> 个位置（即往左跳）。</li>\n\t<li>它不能 <strong>连续</strong> 往后跳 <code>2</code> 次。</li>\n\t<li>它不能跳到任何 <code>forbidden</code> 数组中的位置。</li>\n</ul>\n\n<p>跳蚤可以往前跳 <strong>超过</strong> 它的家的位置，但是它 <strong>不能跳到负整数</strong> 的位置。</p>\n\n<p>给你一个整数数组 <code>forbidden</code> ，其中 <code>forbidden[i]</code> 是跳蚤不能跳到的位置，同时给你整数 <code>a</code>， <code>b</code> 和 <code>x</code> ，请你返回跳蚤到家的最少跳跃次数。如果没有恰好到达 <code>x</code> 的可行方案，请你返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>forbidden = [14,4,18,1,15], a = 3, b = 15, x = 9\n<b>输出：</b>3\n<b>解释：</b>往前跳 3 次（0 -> 3 -> 6 -> 9），跳蚤就到家了。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>forbidden = [8,3,16,6,12,20], a = 15, b = 13, x = 11\n<b>输出：</b>-1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>forbidden = [1,6,2,14,5,17,4], a = 16, b = 9, x = 7\n<b>输出：</b>2\n<b>解释：</b>往前跳一次（0 -> 16），然后往回跳一次（16 -> 7），跳蚤就到家了。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= forbidden.length <= 1000</code></li>\n\t<li><code>1 <= a, b, forbidden[i] <= 2000</code></li>\n\t<li><code>0 <= x <= 2000</code></li>\n\t<li><code>forbidden</code> 中所有位置互不相同。</li>\n\t<li>位置 <code>x</code> 不在 <code>forbidden</code> 中。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1655分配重复整数",
        "hardRate": "HARD",
        "passRate": "39.46%",
        "problemsUrl": "https://leetcode.cn/problems/distribute-repeating-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/distribute-repeating-integers/solution",
        "problemsDesc": "<p>给你一个长度为&nbsp;<code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;，这个数组中至多有&nbsp;<code>50</code>&nbsp;个不同的值。同时你有 <code>m</code>&nbsp;个顾客的订单 <code>quantity</code>&nbsp;，其中，整数&nbsp;<code>quantity[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;位顾客订单的数目。请你判断是否能将 <code>nums</code>&nbsp;中的整数分配给这些顾客，且满足：</p>\n\n<ul>\n\t<li>第&nbsp;<code>i</code>&nbsp;位顾客 <strong>恰好&nbsp;</strong>有&nbsp;<code>quantity[i]</code>&nbsp;个整数。</li>\n\t<li>第&nbsp;<code>i</code>&nbsp;位顾客拿到的整数都是 <strong>相同的</strong>&nbsp;。</li>\n\t<li>每位顾客都满足上述两个要求。</li>\n</ul>\n\n<p>如果你可以分配 <code>nums</code>&nbsp;中的整数满足上面的要求，那么请返回&nbsp;<code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4], quantity = [2]\n<b>输出：</b>false\n<strong>解释：</strong>第 0 位顾客没办法得到两个相同的整数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,3], quantity = [2]\n<b>输出：</b>true\n<b>解释：</b>第 0 位顾客得到 [3,3] 。整数 [1,2] 都没有被使用。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,1,2,2], quantity = [2,2]\n<b>输出：</b>true\n<b>解释：</b>第 0 位顾客得到 [1,1] ，第 1 位顾客得到 [2,2] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>m == quantity.length</code></li>\n\t<li><code>1 &lt;= m &lt;= 10</code></li>\n\t<li><code>1 &lt;= quantity[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums</code>&nbsp;中至多有&nbsp;<code>50</code>&nbsp;个不同的数字。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1656设计有序流",
        "hardRate": "EASY",
        "passRate": "84.07%",
        "problemsUrl": "https://leetcode.cn/problems/design-an-ordered-stream/",
        "solutionsUrl": "https://leetcode.cn/problems/design-an-ordered-stream/solution",
        "problemsDesc": "<p>有 <code>n</code> 个 <code>(id, value)</code> 对，其中 <code>id</code> 是 <code>1</code> 到 <code>n</code> 之间的一个整数，<code>value</code> 是一个字符串。不存在 <code>id</code> 相同的两个 <code>(id, value)</code> 对。</p>\n\n<p>设计一个流，以 <strong>任意</strong> 顺序获取 <code>n</code> 个 <code>(id, value)</code> 对，并在多次调用时 <strong>按 <code>id</code> 递增的顺序</strong> 返回一些值。</p>\n\n<p>实现 <code>OrderedStream</code> 类：</p>\n\n<ul>\n\t<li><code>OrderedStream(int n)</code> 构造一个能接收 <code>n</code> 个值的流，并将当前指针 <code>ptr</code> 设为 <code>1</code> 。</li>\n\t<li><code>String[] insert(int id, String value)</code> 向流中存储新的 <code>(id, value)</code> 对。存储后：\n\t<ul>\n\t\t<li>如果流存储有 <code>id = ptr</code> 的 <code>(id, value)</code> 对，则找出从 <code>id = ptr</code> 开始的 <strong>最长 id 连续递增序列</strong> ，并 <strong>按顺序</strong> 返回与这些 id 关联的值的列表。然后，将 <code>ptr</code> 更新为最后那个  <code>id + 1</code> 。</li>\n\t\t<li>\n\t\t<p>否则，返回一个空列表。</p>\n\t\t</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/15/q1.gif\" style=\"width: 682px; height: 240px;\" /></strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"OrderedStream\", \"insert\", \"insert\", \"insert\", \"insert\", \"insert\"]\n[[5], [3, \"ccccc\"], [1, \"aaaaa\"], [2, \"bbbbb\"], [5, \"eeeee\"], [4, \"ddddd\"]]\n<strong>输出</strong>\n[null, [], [\"aaaaa\"], [\"bbbbb\", \"ccccc\"], [], [\"ddddd\", \"eeeee\"]]\n\n<strong>解释</strong>\nOrderedStream os= new OrderedStream(5);\nos.insert(3, \"ccccc\"); // 插入 (3, \"ccccc\")，返回 []\nos.insert(1, \"aaaaa\"); // 插入 (1, \"aaaaa\")，返回 [\"aaaaa\"]\nos.insert(2, \"bbbbb\"); // 插入 (2, \"bbbbb\")，返回 [\"bbbbb\", \"ccccc\"]\nos.insert(5, \"eeeee\"); // 插入 (5, \"eeeee\")，返回 []\nos.insert(4, \"ddddd\"); // 插入 (4, \"ddddd\")，返回 [\"ddddd\", \"eeeee\"]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 1000</code></li>\n\t<li><code>1 <= id <= n</code></li>\n\t<li><code>value.length == 5</code></li>\n\t<li><code>value</code> 仅由小写字母组成</li>\n\t<li>每次调用 <code>insert</code> 都会使用一个唯一的 <code>id</code></li>\n\t<li>恰好调用 <code>n</code> 次 <code>insert</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1657确定两个字符串是否接近",
        "hardRate": "MEDIUM",
        "passRate": "47.11%",
        "problemsUrl": "https://leetcode.cn/problems/determine-if-two-strings-are-close/",
        "solutionsUrl": "https://leetcode.cn/problems/determine-if-two-strings-are-close/solution",
        "problemsDesc": "<p>如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串 <strong>接近</strong> ：</p>\n\n<ul>\n\t<li>操作 1：交换任意两个 <strong>现有</strong> 字符。\n\n\t<ul>\n\t\t<li>例如，<code>a<strong>b</strong>cd<strong>e</strong> -> a<strong>e</strong>cd<strong>b</strong></code></li>\n\t</ul>\n\t</li>\n\t<li>操作 2：将一个 <strong>现有</strong> 字符的每次出现转换为另一个 <strong>现有</strong> 字符，并对另一个字符执行相同的操作。\n\t<ul>\n\t\t<li>例如，<code><strong>aa</strong>c<strong>abb</strong> -> <strong>bb</strong>c<strong>baa</strong></code>（所有 <code>a</code> 转化为 <code>b</code> ，而所有的 <code>b</code> 转换为 <code>a</code> ）</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>你可以根据需要对任意一个字符串多次使用这两种操作。</p>\n\n<p>给你两个字符串，<code>word1</code> 和 <code>word2</code> 。如果<em> </em><code>word1</code><em> </em>和<em> </em><code>word2</code><em> </em><strong>接近 </strong>，就返回 <code>true</code> ；否则，返回<em> </em><code>false</code><em> </em>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"abc\", word2 = \"bca\"\n<strong>输出：</strong>true\n<strong>解释：</strong>2 次操作从 word1 获得 word2 。\n执行操作 1：\"a<strong>bc</strong>\" -> \"a<strong>cb</strong>\"\n执行操作 1：\"<strong>a</strong>c<strong>b</strong>\" -> \"<strong>b</strong>c<strong>a</strong>\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"a\", word2 = \"aa\"\n<strong>输出：</strong>false\n<strong>解释：</strong>不管执行多少次操作，都无法从 word1 得到 word2 ，反之亦然。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"cabbba\", word2 = \"abbccc\"\n<strong>输出：</strong>true\n<strong>解释：</strong>3 次操作从 word1 获得 word2 。\n执行操作 1：\"ca<strong>b</strong>bb<strong>a</strong>\" -> \"ca<strong>a</strong>bb<strong>b</strong>\"\n执行操作 2：<code>\"</code><strong>c</strong>aa<strong>bbb</strong>\" -> \"<strong>b</strong>aa<strong>ccc</strong>\"\n执行操作 2：\"<strong>baa</strong>ccc\" -> \"<strong>abb</strong>ccc\"\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"cabbba\", word2 = \"aabbss\"\n<strong>输出：</strong>false\n<strong>解释：</strong>不管执行多少次操作，都无法从 word1 得到 word2 ，反之亦然。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word1.length, word2.length <= 10<sup>5</sup></code></li>\n\t<li><code>word1</code> 和 <code>word2</code> 仅包含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1658将 x 减到 0 的最小操作数",
        "hardRate": "MEDIUM",
        "passRate": "39.26%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>x</code> 。每一次操作时，你应当移除数组 <code>nums</code> 最左边或最右边的元素，然后从 <code>x</code> 中减去该元素的值。请注意，需要 <strong>修改</strong> 数组以供接下来的操作使用。</p>\n\n<p>如果可以将 <code>x</code> <strong>恰好</strong> 减到 <code>0</code> ，返回<strong> 最小操作数 </strong>；否则，返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,4,2,3], x = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>最佳解决方案是移除后两个元素，将 x 减到 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,6,7,8,9], x = 4\n<strong>输出：</strong>-1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,20,1,1,3], x = 10\n<strong>输出：</strong>5\n<strong>解释：</strong>最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= x <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1659最大化网格幸福感",
        "hardRate": "HARD",
        "passRate": "64.77%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-grid-happiness/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-grid-happiness/solution",
        "problemsDesc": "<p>给你四个整数 <code>m</code>、<code>n</code>、<code>introvertsCount</code> 和 <code>extrovertsCount</code> 。有一个 <code>m x n</code> 网格，和两种类型的人：内向的人和外向的人。总共有 <code>introvertsCount</code> 个内向的人和 <code>extrovertsCount</code> 个外向的人。</p>\n\n<p>请你决定网格中应当居住多少人，并为每个人分配一个网格单元。 注意，<strong>不必</strong> 让所有人都生活在网格中。</p>\n\n<p>每个人的 <strong>幸福感</strong> 计算如下：</p>\n\n<ul>\n\t<li>内向的人 <strong>开始</strong> 时有 <code>120</code> 个幸福感，但每存在一个邻居（内向的或外向的）他都会 <strong>失去</strong>  <code>30</code> 个幸福感。</li>\n\t<li>外向的人 <strong>开始</strong> 时有 <code>40</code> 个幸福感，每存在一个邻居（内向的或外向的）他都会 <strong>得到</strong>  <code>20</code> 个幸福感。</li>\n</ul>\n\n<p>邻居是指居住在一个人所在单元的上、下、左、右四个直接相邻的单元中的其他人。</p>\n\n<p><strong>网格幸福感</strong> 是每个人幸福感的 <strong>总和</strong> 。 返回 <strong>最大可能的网格幸福感</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/15/grid_happiness.png\" style=\"width: 261px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2\n<strong>输出：</strong>240\n<strong>解释：</strong>假设网格坐标 (row, column) 从 1 开始编号。\n将内向的人放置在单元 (1,1) ，将外向的人放置在单元 (1,3) 和 (2,3) 。\n- 位于 (1,1) 的内向的人的幸福感：120（初始幸福感）- (0 * 30)（0 位邻居）= 120\n- 位于 (1,3) 的外向的人的幸福感：40（初始幸福感）+ (1 * 20)（1 位邻居）= 60\n- 位于 (2,3) 的外向的人的幸福感：40（初始幸福感）+ (1 * 20)（1 位邻居）= 60\n网格幸福感为：120 + 60 + 60 = 240\n上图展示该示例对应网格中每个人的幸福感。内向的人在浅绿色单元中，而外向的人在浅紫色单元中。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1\n<strong>输出：</strong>260\n<strong>解释：</strong>将内向的人放置在单元 (1,1) 和 (3,1) ，将外向的人放置在单元 (2,1) 。\n- 位于 (1,1) 的内向的人的幸福感：120（初始幸福感）- (1 * 30)（1 位邻居）= 90\n- 位于 (2,1) 的外向的人的幸福感：40（初始幸福感）+ (2 * 20)（2 位邻居）= 80\n- 位于 (3,1) 的内向的人的幸福感：120（初始幸福感）- (1 * 30)（1 位邻居）= 90\n网格幸福感为 90 + 80 + 90 = 260\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0\n<strong>输出：</strong>240\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= m, n <= 5</code></li>\n\t<li><code>0 <= introvertsCount, extrovertsCount <= min(m * n, 6)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1660纠正二叉树",
        "hardRate": "MEDIUM",
        "passRate": "76.14%",
        "problemsUrl": "https://leetcode.cn/problems/correct-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/correct-a-binary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1661每台机器的进程平均运行时间",
        "hardRate": "EASY",
        "passRate": "72.60%",
        "problemsUrl": "https://leetcode.cn/problems/average-time-of-process-per-machine/",
        "solutionsUrl": "https://leetcode.cn/problems/average-time-of-process-per-machine/solution",
        "problemsDesc": "<p>表: <code>Activity</code></p>\n\n<pre>\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| machine_id     | int     |\n| process_id     | int     |\n| activity_type  | enum    |\n| timestamp      | float   |\n+----------------+---------+\n该表展示了一家工厂网站的用户活动.\n(machine_id, process_id, activity_type) 是当前表的主键.\nmachine_id 是一台机器的ID号.\nprocess_id 是运行在各机器上的进程ID号.\nactivity_type 是枚举类型 ('start', 'end').\ntimestamp 是浮点类型,代表当前时间(以秒为单位).\n'start' 代表该进程在这台机器上的开始运行时间戳 , 'end' 代表该进程在这台机器上的终止运行时间戳.\n同一台机器，同一个进程都有一对开始时间戳和结束时间戳，而且开始时间戳永远在结束时间戳前面.</pre>\n\n<p>&nbsp;</p>\n\n<p>现在有一个工厂网站由几台机器运行，每台机器上运行着相同数量的进程. 请写出一条SQL计算每台机器各自完成一个进程任务的平均耗时.</p>\n\n<p>完成一个进程任务的时间指进程的<code>'end' 时间戳</code> 减去&nbsp;<code>'start' 时间戳</code>. 平均耗时通过计算每台机器上所有进程任务的总耗费时间除以机器上的总进程数量获得.</p>\n\n<p>结果表必须包含<code>machine_id（机器ID）</code> 和对应的&nbsp;<strong>average time（平均耗时）</strong>&nbsp;别名&nbsp;<code>processing_time</code>, 且<strong>四舍五入保留3位小数.</strong></p>\n\n<p>以 <strong>任意顺序</strong> 返回表。</p>\n\n<p>具体参考例子如下。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nActivity table:\n+------------+------------+---------------+-----------+\n| machine_id | process_id | activity_type | timestamp |\n+------------+------------+---------------+-----------+\n| 0          | 0          | start         | 0.712     |\n| 0          | 0          | end           | 1.520     |\n| 0          | 1          | start         | 3.140     |\n| 0          | 1          | end           | 4.120     |\n| 1          | 0          | start         | 0.550     |\n| 1          | 0          | end           | 1.550     |\n| 1          | 1          | start         | 0.430     |\n| 1          | 1          | end           | 1.420     |\n| 2          | 0          | start         | 4.100     |\n| 2          | 0          | end           | 4.512     |\n| 2          | 1          | start         | 2.500     |\n| 2          | 1          | end           | 5.000     |\n+------------+------------+---------------+-----------+\n<strong>输出：</strong>\n+------------+-----------------+\n| machine_id | processing_time |\n+------------+-----------------+\n| 0          | 0.894           |\n| 1          | 0.995           |\n| 2          | 1.456           |\n+------------+-----------------+\n<strong>解释：</strong>\n一共有3台机器,每台机器运行着两个进程.\n机器 0 的平均耗时: ((1.520 - 0.712) + (4.120 - 3.140)) / 2 = 0.894\n机器 1 的平均耗时: ((1.550 - 0.550) + (1.420 - 0.430)) / 2 = 0.995\n机器 2 的平均耗时: ((4.512 - 4.100) + (5.000 - 2.500)) / 2 = 1.456</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1662检查两个字符串数组是否相等",
        "hardRate": "EASY",
        "passRate": "80.99%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-two-string-arrays-are-equivalent/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-two-string-arrays-are-equivalent/solution",
        "problemsDesc": "<p>给你两个字符串数组 <code>word1</code> 和 <code>word2</code> 。如果两个数组表示的字符串相同，返回<em> </em><code>true</code><em> </em>；否则，返回 <code>false</code><em> 。</em></p>\n\n<p><strong>数组表示的字符串</strong> 是由数组中的所有元素 <strong>按顺序</strong> 连接形成的字符串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\n<strong>输出：</strong>true\n<strong>解释：</strong>\nword1 表示的字符串为 \"ab\" + \"c\" -> \"abc\"\nword2 表示的字符串为 \"a\" + \"bc\" -> \"abc\"\n两个字符串相同，返回 true</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\n<strong>输出：</strong>true\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word1.length, word2.length <= 10<sup>3</sup></code></li>\n\t<li><code>1 <= word1[i].length, word2[i].length <= 10<sup>3</sup></code></li>\n\t<li><code>1 <= sum(word1[i].length), sum(word2[i].length) <= 10<sup>3</sup></code></li>\n\t<li><code>word1[i]</code> 和 <code>word2[i]</code> 由小写字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1663具有给定数值的最小字符串",
        "hardRate": "MEDIUM",
        "passRate": "65.06%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-string-with-a-given-numeric-value/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-string-with-a-given-numeric-value/solution",
        "problemsDesc": "<p><strong>小写字符 </strong>的 <strong>数值</strong> 是它在字母表中的位置（从 <code>1</code> 开始），因此 <code>a</code> 的数值为 <code>1</code> ，<code>b</code> 的数值为 <code>2</code> ，<code>c</code> 的数值为 <code>3</code> ，以此类推。</p>\n\n<p>字符串由若干小写字符组成，<strong>字符串的数值</strong> 为各字符的数值之和。例如，字符串 <code>\"abe\"</code> 的数值等于 <code>1 + 2 + 5 = 8</code> 。</p>\n\n<p>给你两个整数 <code>n</code> 和 <code>k</code> 。返回 <strong>长度</strong> 等于 <code>n</code> 且 <strong>数值</strong> 等于 <code>k</code> 的 <strong>字典序最小</strong> 的字符串。</p>\n\n<p>注意，如果字符串 <code>x</code> 在字典排序中位于 <code>y</code> 之前，就认为 <code>x</code> 字典序比 <code>y</code> 小，有以下两种情况：</p>\n\n<ul>\n\t<li><code>x</code> 是 <code>y</code> 的一个前缀；</li>\n\t<li>如果 <code>i</code> 是 <code>x[i] != y[i]</code> 的第一个位置，且 <code>x[i]</code> 在字母表中的位置比 <code>y[i]</code> 靠前。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 27\n<strong>输出：</strong>\"aay\"\n<strong>解释：</strong>字符串的数值为 1 + 1 + 25 = 27，它是数值满足要求且长度等于 3 字典序最小的字符串。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, k = 73\n<strong>输出：</strong>\"aaszz\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>n <= k <= 26 * n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1664生成平衡数组的方案数",
        "hardRate": "MEDIUM",
        "passRate": "66.50%",
        "problemsUrl": "https://leetcode.cn/problems/ways-to-make-a-fair-array/",
        "solutionsUrl": "https://leetcode.cn/problems/ways-to-make-a-fair-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。你需要选择 <strong>恰好</strong> 一个下标（下标从 <strong>0</strong> 开始）并删除对应的元素。请注意剩下元素的下标可能会因为删除操作而发生改变。</p>\n\n<p>比方说，如果 <code>nums = [6,1,7,4,1]</code> ，那么：</p>\n\n<ul>\n\t<li>选择删除下标 <code>1</code> ，剩下的数组为 <code>nums = [6,7,4,1]</code> 。</li>\n\t<li>选择删除下标 <code>2</code> ，剩下的数组为 <code>nums = [6,1,4,1]</code> 。</li>\n\t<li>选择删除下标 <code>4</code> ，剩下的数组为 <code>nums = [6,1,7,4]</code> 。</li>\n</ul>\n\n<p>如果一个数组满足奇数下标元素的和与偶数下标元素的和相等，该数组就是一个 <strong>平衡数组</strong> 。</p>\n\n<p>请你返回删除操作后，剩下的数组<em> </em><code>nums</code><em> </em>是 <strong>平衡数组</strong> 的 <strong>方案数</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,1,6,4]\n<b>输出：</b>1\n<strong>解释：</strong>\n删除下标 0 ：[1,6,4] -> 偶数元素下标为：1 + 4 = 5 。奇数元素下标为：6 。不平衡。\n删除下标 1 ：[2,6,4] -> 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：6 。平衡。\n删除下标 2 ：[2,1,4] -> 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：1 。不平衡。\n删除下标 3 ：[2,1,6] -> 偶数元素下标为：2 + 6 = 8 。奇数元素下标为：1 。不平衡。\n只有一种让剩余数组成为平衡数组的方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,1,1]\n<b>输出：</b>3\n<b>解释：</b>你可以删除任意元素，剩余数组都是平衡数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3]\n<b>输出：</b>0\n<b>解释：</b>不管删除哪个元素，剩下数组都不是平衡数组。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1665完成所有任务的最少初始能量",
        "hardRate": "HARD",
        "passRate": "65.43%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-initial-energy-to-finish-tasks/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-initial-energy-to-finish-tasks/solution",
        "problemsDesc": "<p>给你一个任务数组 <code>tasks</code> ，其中 <code>tasks[i] = [actual<sub>i</sub>, minimum<sub>i</sub>]</code> ：</p>\n\n<ul>\n\t<li><code>actual<sub>i</sub></code> 是完成第 <code>i</code> 个任务 <strong>需要耗费</strong> 的实际能量。</li>\n\t<li><code>minimum<sub>i</sub></code> 是开始第 <code>i</code> 个任务前需要达到的最低能量。</li>\n</ul>\n\n<p>比方说，如果任务为 <code>[10, 12]</code> 且你当前的能量为 <code>11</code> ，那么你不能开始这个任务。如果你当前的能量为 <code>13</code> ，你可以完成这个任务，且完成它后剩余能量为 <code>3</code> 。</p>\n\n<p>你可以按照 <strong>任意顺序</strong> 完成任务。</p>\n\n<p>请你返回完成所有任务的 <strong>最少</strong> 初始能量。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>tasks = [[1,2],[2,4],[4,8]]\n<b>输出：</b>8\n<strong>解释：</strong>\n一开始有 8 能量，我们按照如下顺序完成任务：\n    - 完成第 3 个任务，剩余能量为 8 - 4 = 4 。\n    - 完成第 2 个任务，剩余能量为 4 - 2 = 2 。\n    - 完成第 1 个任务，剩余能量为 2 - 1 = 1 。\n注意到尽管我们有能量剩余，但是如果一开始只有 7 能量是不能完成所有任务的，因为我们无法开始第 3 个任务。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>tasks = [[1,3],[2,4],[10,11],[10,12],[8,9]]\n<b>输出：</b>32\n<strong>解释：</strong>\n一开始有 32 能量，我们按照如下顺序完成任务：\n    - 完成第 1 个任务，剩余能量为 32 - 1 = 31 。\n    - 完成第 2 个任务，剩余能量为 31 - 2 = 29 。\n    - 完成第 3 个任务，剩余能量为 29 - 10 = 19 。\n    - 完成第 4 个任务，剩余能量为 19 - 10 = 9 。\n    - 完成第 5 个任务，剩余能量为 9 - 8 = 1 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>tasks = [[1,7],[2,8],[3,9],[4,10],[5,11],[6,12]]\n<b>输出：</b>27\n<strong>解释：</strong>\n一开始有 27 能量，我们按照如下顺序完成任务：\n    - 完成第 5 个任务，剩余能量为 27 - 5 = 22 。\n    - 完成第 2 个任务，剩余能量为 22 - 2 = 20 。\n    - 完成第 3 个任务，剩余能量为 20 - 3 = 17 。\n    - 完成第 1 个任务，剩余能量为 17 - 1 = 16 。\n    - 完成第 4 个任务，剩余能量为 16 - 4 = 12 。\n    - 完成第 6 个任务，剩余能量为 12 - 6 = 6 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tasks.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= actual<sub>​i</sub> &lt;= minimum<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1666改变二叉树的根节点",
        "hardRate": "MEDIUM",
        "passRate": "66.84%",
        "problemsUrl": "https://leetcode.cn/problems/change-the-root-of-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/change-the-root-of-a-binary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1667修复表中的名字",
        "hardRate": "EASY",
        "passRate": "63.55%",
        "problemsUrl": "https://leetcode.cn/problems/fix-names-in-a-table/",
        "solutionsUrl": "https://leetcode.cn/problems/fix-names-in-a-table/solution",
        "problemsDesc": "<p>表： <code>Users</code></p>\n\n<pre>\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| user_id        | int     |\n| name           | varchar |\n+----------------+---------+\nuser_id 是该表的主键。\n该表包含用户的 ID 和名字。名字仅由小写和大写字符组成。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个 SQL 查询来修复名字，使得只有第一个字符是大写的，其余都是小写的。</p>\n\n<p>返回按 <code>user_id</code> 排序的结果表。</p>\n\n<p>查询结果格式示例如下。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nUsers table:\n+---------+-------+\n| user_id | name  |\n+---------+-------+\n| 1       | aLice |\n| 2       | bOB   |\n+---------+-------+\n<strong>输出：</strong>\n+---------+-------+\n| user_id | name  |\n+---------+-------+\n| 1       | Alice |\n| 2       | Bob   |\n+---------+-------+</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1668最大重复子字符串",
        "hardRate": "EASY",
        "passRate": "47.01%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-repeating-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-repeating-substring/solution",
        "problemsDesc": "<p>给你一个字符串 <code>sequence</code> ，如果字符串 <code>word</code> 连续重复 <code>k</code> 次形成的字符串是 <code>sequence</code> 的一个子字符串，那么单词 <code>word</code> 的 <strong>重复值为 <code>k</code></strong><strong> </strong>。单词 <code>word</code> 的 <strong>最</strong><strong>大重复值</strong> 是单词 <code>word</code> 在 <code>sequence</code> 中最大的重复值。如果 <code>word</code> 不是 <code>sequence</code> 的子串，那么重复值 <code>k</code> 为 <code>0</code> 。</p>\n\n<p>给你一个字符串 <code>sequence</code> 和 <code>word</code> ，请你返回 <strong>最大重复值 <code>k</code> </strong>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>sequence = \"ababc\", word = \"ab\"\n<b>输出：</b>2\n<strong>解释：</strong>\"abab\" 是 \"<strong>abab</strong>c\" 的子字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>sequence = \"ababc\", word = \"ba\"\n<b>输出：</b>1\n<strong>解释：</strong>\"ba\" 是 \"a<strong>ba</strong>bc\" 的子字符串，但 \"baba\" 不是 \"ababc\" 的子字符串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>sequence = \"ababc\", word = \"ac\"\n<b>输出：</b>0\n<strong>解释：</strong>\"ac\" 不是 \"ababc\" 的子字符串。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= sequence.length <= 100</code></li>\n\t<li><code>1 <= word.length <= 100</code></li>\n\t<li><code>sequence</code> 和 <code>word</code> 都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1669合并两个链表",
        "hardRate": "MEDIUM",
        "passRate": "77.30%",
        "problemsUrl": "https://leetcode.cn/problems/merge-in-between-linked-lists/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-in-between-linked-lists/solution",
        "problemsDesc": "<p>给你两个链表&nbsp;<code>list1</code> 和&nbsp;<code>list2</code>&nbsp;，它们包含的元素分别为&nbsp;<code>n</code> 个和&nbsp;<code>m</code> 个。</p>\n\n<p>请你将&nbsp;<code>list1</code>&nbsp;中下标从 <code>a</code> 到 <code>b</code> 的全部节点都删除，并将<code>list2</code>&nbsp;接在被删除节点的位置。</p>\n\n<p>下图中蓝色边和节点展示了操作后的结果：</p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/28/fig1.png\" style=\"height: 130px; width: 504px;\" />\n<p>请你返回结果链表的头指针。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/28/merge_linked_list_ex1.png\" style=\"width: 406px; height: 140px;\" /></p>\n\n<pre>\n<b>输入：</b>list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]\n<b>输出：</b>[0,1,2,1000000,1000001,1000002,5]\n<b>解释：</b>我们删除 list1 中下标为 3 和 4 的两个节点，并将 list2 接在该位置。上图中蓝色的边和节点为答案链表。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/28/merge_linked_list_ex2.png\" style=\"width: 463px; height: 140px;\" />\n<pre>\n<b>输入：</b>list1 = [0,1,2,3,4,5,6], a = 2, b = 5, list2 = [1000000,1000001,1000002,1000003,1000004]\n<b>输出：</b>[0,1,1000000,1000001,1000002,1000003,1000004,6]\n<b>解释：</b>上图中蓝色的边和节点为答案链表。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= list1.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= a &lt;= b &lt; list1.length - 1</code></li>\n\t<li><code>1 &lt;= list2.length &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1670设计前中后队列",
        "hardRate": "MEDIUM",
        "passRate": "51.99%",
        "problemsUrl": "https://leetcode.cn/problems/design-front-middle-back-queue/",
        "solutionsUrl": "https://leetcode.cn/problems/design-front-middle-back-queue/solution",
        "problemsDesc": "<p>请你设计一个队列，支持在前，中，后三个位置的 <code>push</code> 和 <code>pop</code> 操作。</p>\n\n<p>请你完成 <code>FrontMiddleBack</code> 类：</p>\n\n<ul>\n\t<li><code>FrontMiddleBack()</code> 初始化队列。</li>\n\t<li><code>void pushFront(int val)</code> 将 <code>val</code> 添加到队列的 <strong>最前面</strong> 。</li>\n\t<li><code>void pushMiddle(int val)</code> 将 <code>val</code> 添加到队列的 <strong>正中间</strong> 。</li>\n\t<li><code>void pushBack(int val)</code> 将 <code>val</code> 添加到队里的 <strong>最后面</strong> 。</li>\n\t<li><code>int popFront()</code> 将 <strong>最前面</strong> 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 <code>-1</code> 。</li>\n\t<li><code>int popMiddle()</code> 将 <b>正中间</b> 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 <code>-1</code> 。</li>\n\t<li><code>int popBack()</code> 将 <strong>最后面</strong> 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 <code>-1</code> 。</li>\n</ul>\n\n<p>请注意当有 <strong>两个</strong> 中间位置的时候，选择靠前面的位置进行操作。比方说：</p>\n\n<ul>\n\t<li>将 <code>6</code> 添加到 <code>[1, 2, 3, 4, 5]</code> 的中间位置，结果数组为 <code>[1, 2, <strong>6</strong>, 3, 4, 5]</code> 。</li>\n\t<li>从 <code>[1, 2, <strong>3</strong>, 4, 5, 6]</code> 的中间位置弹出元素，返回 <code>3</code> ，数组变为 <code>[1, 2, 4, 5, 6]</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"FrontMiddleBackQueue\", \"pushFront\", \"pushBack\", \"pushMiddle\", \"pushMiddle\", \"popFront\", \"popMiddle\", \"popMiddle\", \"popBack\", \"popFront\"]\n[[], [1], [2], [3], [4], [], [], [], [], []]\n<strong>输出：</strong>\n[null, null, null, null, null, 1, 3, 4, 2, -1]\n\n<strong>解释：</strong>\nFrontMiddleBackQueue q = new FrontMiddleBackQueue();\nq.pushFront(1);   // [<strong>1</strong>]\nq.pushBack(2);    // [1, <strong>2</strong>]\nq.pushMiddle(3);  // [1, <strong>3</strong>, 2]\nq.pushMiddle(4);  // [1, <strong>4</strong>, 3, 2]\nq.popFront();     // 返回 1 -> [4, 3, 2]\nq.popMiddle();    // 返回 3 -> [4, 2]\nq.popMiddle();    // 返回 4 -> [2]\nq.popBack();      // 返回 2 -> []\nq.popFront();     // 返回 -1 -> [] （队列为空）\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= val <= 10<sup>9</sup></code></li>\n\t<li>最多调用 <code>1000</code> 次 <code>pushFront</code>， <code>pushMiddle</code>， <code>pushBack</code>， <code>popFront</code>， <code>popMiddle</code> 和 <code>popBack</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1671得到山形数组的最少删除次数",
        "hardRate": "HARD",
        "passRate": "46.69%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array/solution",
        "problemsDesc": "<p>我们定义&nbsp;<code>arr</code>&nbsp;是 <b>山形数组</b>&nbsp;当且仅当它满足：</p>\n\n<ul>\n\t<li><code>arr.length &gt;= 3</code></li>\n\t<li>存在某个下标&nbsp;<code>i</code>&nbsp;（<strong>从 0 开始</strong>）&nbsp;满足&nbsp;<code>0 &lt; i &lt; arr.length - 1</code>&nbsp;且：\n\t<ul>\n\t\t<li><code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]</code></li>\n\t\t<li><code>arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>给你整数数组&nbsp;<code>nums</code>​ ，请你返回将 <code>nums</code>&nbsp;变成 <strong>山形状数组</strong>&nbsp;的​ <strong>最少</strong>&nbsp;删除次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,3,1]\n<b>输出：</b>0\n<b>解释：</b>数组本身就是山形数组，所以我们不需要删除任何元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,1,1,5,6,2,3,1]\n<b>输出：</b>3\n<b>解释：</b>一种方法是将下标为 0，1 和 5 的元素删除，剩余元素为 [1,5,6,3,1] ，是山形数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>题目保证&nbsp;<code>nums</code> 删除一些元素后一定能得到山形数组。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1672最富有客户的资产总量",
        "hardRate": "EASY",
        "passRate": "83.70%",
        "problemsUrl": "https://leetcode.cn/problems/richest-customer-wealth/",
        "solutionsUrl": "https://leetcode.cn/problems/richest-customer-wealth/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的整数网格 <code>accounts</code> ，其中 <code>accounts[i][j]</code> 是第 <code>i​​​​​<sup>​​​​​​</sup>​</code> 位客户在第 <code>j</code> 家银行托管的资产数量。返回最富有客户所拥有的 <strong>资产总量</strong> 。</p>\n\n<p>客户的 <strong>资产总量</strong> 就是他们在各家银行托管的资产数量之和。最富有客户就是 <strong>资产总量</strong> 最大的客户。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>accounts = [[1,2,3],[3,2,1]]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n<code>第 1 位客户的资产总量 = 1 + 2 + 3 = 6\n第 2 位客户的资产总量 = 3 + 2 + 1 = 6\n</code>两位客户都是最富有的，资产总量都是 6 ，所以返回 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>accounts = [[1,5],[7,3],[3,5]]\n<strong>输出：</strong>10\n<strong>解释：</strong>\n<code>第 1 位客户的资产总量</code> = 6\n<code>第 2 位客户的资产总量</code> = 10 \n<code>第 3 位客户的资产总量</code> = 8\n第 2 位客户是最富有的，资产总量是 10</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>accounts = [[2,8,7],[7,1,3],[1,9,5]]\n<strong>输出：</strong>17\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == accounts.length</code></li>\n\t<li><code>n == accounts[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>1 &lt;= accounts[i][j] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1673找出最具竞争力的子序列",
        "hardRate": "MEDIUM",
        "passRate": "39.54%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-most-competitive-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-most-competitive-subsequence/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个正整数 <code>k</code> ，返回长度为 <code>k</code> 且最具 <strong>竞争力</strong> 的<em> </em><code>nums</code> 子序列。</p>\n\n<p>数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。</p>\n\n<p>在子序列 <code>a</code> 和子序列 <code>b</code> 第一个不相同的位置上，如果 <code>a</code> 中的数字小于 <code>b</code> 中对应的数字，那么我们称子序列 <code>a</code> 比子序列 <code>b</code>（相同长度下）更具 <strong>竞争力</strong> 。 例如，<code>[1,3,4]</code> 比 <code>[1,3,5]</code> 更具竞争力，在第一个不相同的位置，也就是最后一个位置上， <code>4</code> 小于 <code>5</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,5,2,6], k = 2\n<strong>输出：</strong>[2,6]\n<strong>解释：</strong>在所有可能的子序列集合 {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 最具竞争力。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,4,3,3,5,4,9,6], k = 4\n<strong>输出：</strong>[2,3,3,4]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= nums[i] <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= k <= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1674使数组互补的最少操作次数",
        "hardRate": "MEDIUM",
        "passRate": "41.86%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-moves-to-make-array-complementary/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-moves-to-make-array-complementary/solution",
        "problemsDesc": "<p>给你一个长度为<strong> 偶数</strong> <code>n</code> 的整数数组 <code>nums</code> 和一个整数 <code>limit</code> 。每一次操作，你可以将 <code>nums</code> 中的任何整数替换为 <code>1</code> 到 <code>limit</code> 之间的另一个整数。</p>\n\n<p>如果对于所有下标 <code>i</code>（<strong>下标从 </strong><code>0</code><strong> 开始</strong>），<code>nums[i] + nums[n - 1 - i]</code> 都等于同一个数，则数组 <code>nums</code> 是 <strong>互补的</strong> 。例如，数组 <code>[1,2,3,4]</code> 是互补的，因为对于所有下标 <code>i</code> ，<code>nums[i] + nums[n - 1 - i] = 5</code> 。</p>\n\n<p>返回使数组 <strong>互补</strong> 的 <strong>最少</strong> 操作次数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,4,3], limit = 4\n<strong>输出：</strong>1\n<strong>解释：</strong>经过 1 次操作，你可以将数组 nums 变成 [1,2,<strong>2</strong>,3]（加粗元素是变更的数字）：\nnums[0] + nums[3] = 1 + 3 = 4.\nnums[1] + nums[2] = 2 + 2 = 4.\nnums[2] + nums[1] = 2 + 2 = 4.\nnums[3] + nums[0] = 3 + 1 = 4.\n对于每个 i ，nums[i] + nums[n-1-i] = 4 ，所以 nums 是互补的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2,1], limit = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>经过 2 次操作，你可以将数组 nums 变成 [<strong>2</strong>,2,2,<strong>2</strong>] 。你不能将任何数字变更为 3 ，因为 3 > limit 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,2], limit = 2\n<strong>输出：</strong>0\n<strong>解释：</strong>nums 已经是互补的。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>2 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= limit <= 10<sup>5</sup></code></li>\n\t<li><code>n</code> 是偶数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1675数组的最小偏移量",
        "hardRate": "HARD",
        "passRate": "45.60%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-deviation-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-deviation-in-array/solution",
        "problemsDesc": "<p>给你一个由 <code>n</code> 个正整数组成的数组 <code>nums</code> 。</p>\n\n<p>你可以对数组的任意元素执行任意次数的两类操作：</p>\n\n<ul>\n\t<li>如果元素是<strong> 偶数</strong> ，<strong>除以</strong> <code>2</code>\n\n\t<ul>\n\t\t<li>例如，如果数组是 <code>[1,2,3,4]</code> ，那么你可以对最后一个元素执行此操作，使其变成 <code>[1,2,3,<strong>2</strong>]</code></li>\n\t</ul>\n\t</li>\n\t<li>如果元素是 <strong>奇数</strong> ，<strong>乘上</strong> <code>2</code>\n\t<ul>\n\t\t<li>例如，如果数组是 <code>[1,2,3,4]</code> ，那么你可以对第一个元素执行此操作，使其变成 <code>[<strong>2</strong>,2,3,4]</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>数组的 <strong>偏移量</strong> 是数组中任意两个元素之间的 <strong>最大差值</strong> 。</p>\n\n<p>返回数组在执行某些操作之后可以拥有的 <strong>最小偏移量</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>1\n<strong>解释：</strong>你可以将数组转换为 [1,2,3,<strong>2</strong>]，然后转换成 [<strong>2</strong>,2,3,2]，偏移量是 3 - 2 = 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,1,5,20,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>两次操作后，你可以将数组转换为 [4,<strong>2</strong>,5,<strong>5</strong>,3]，偏移量是 5 - 2 = 3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,10,8]\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 5 * 10<sup><span style=\"font-size: 10.8333px;\">4</span></sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1676二叉树的最近公共祖先 IV",
        "hardRate": "MEDIUM",
        "passRate": "79.99%",
        "problemsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iv/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1677发票中的产品金额",
        "hardRate": "EASY",
        "passRate": "35.33%",
        "problemsUrl": "https://leetcode.cn/problems/products-worth-over-invoices/",
        "solutionsUrl": "https://leetcode.cn/problems/products-worth-over-invoices/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1678设计 Goal 解析器",
        "hardRate": "EASY",
        "passRate": "86.13%",
        "problemsUrl": "https://leetcode.cn/problems/goal-parser-interpretation/",
        "solutionsUrl": "https://leetcode.cn/problems/goal-parser-interpretation/solution",
        "problemsDesc": "<p>请你设计一个可以解释字符串 <code>command</code> 的 <strong>Goal 解析器</strong> 。<code>command</code> 由 <code>\"G\"</code>、<code>\"()\"</code> 和/或 <code>\"(al)\"</code> 按某种顺序组成。Goal 解析器会将 <code>\"G\"</code> 解释为字符串 <code>\"G\"</code>、<code>\"()\"</code> 解释为字符串 <code>\"o\"</code> ，<code>\"(al)\"</code> 解释为字符串 <code>\"al\"</code> 。然后，按原顺序将经解释得到的字符串连接成一个字符串。</p>\n\n<p>给你字符串 <code>command</code> ，返回<em> </em><strong>Goal<em><strong> </strong></em>解析器 </strong>对<em> </em><code>command</code> 的解释结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>command = \"G()(al)\"\n<strong>输出：</strong>\"Goal\"\n<strong>解释：</strong>Goal 解析器解释命令的步骤如下所示：\nG -&gt; G\n() -&gt; o\n(al) -&gt; al\n最后连接得到的结果是 \"Goal\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>command = \"G()()()()(al)\"\n<strong>输出：</strong>\"Gooooal\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>command = \"(al)G(al)()()G\"\n<strong>输出：</strong>\"alGalooG\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= command.length &lt;= 100</code></li>\n\t<li><code>command</code> 由 <code>\"G\"</code>、<code>\"()\"</code> 和/或 <code>\"(al)\"</code> 按某种顺序组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1679K 和数对的最大数目",
        "hardRate": "MEDIUM",
        "passRate": "54.06%",
        "problemsUrl": "https://leetcode.cn/problems/max-number-of-k-sum-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/max-number-of-k-sum-pairs/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>\n\n<p>每一步操作中，你需要从数组中选出和为 <code>k</code> 的两个整数，并将它们移出数组。</p>\n\n<p>返回你可以对数组执行的最大操作数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4], k = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>开始时 nums = [1,2,3,4]：\n- 移出 1 和 4 ，之后 nums = [2,3]\n- 移出 2 和 3 ，之后 nums = []\n不再有和为 5 的数对，因此最多执行 2 次操作。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,1,3,4,3], k = 6\n<strong>输出：</strong>1\n<strong>解释：</strong>开始时 nums = [3,1,3,4,3]：\n- 移出前两个 3 ，之后nums = [1,4,3]\n不再有和为 6 的数对，因此最多执行 1 次操作。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= k <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1680连接连续二进制数字",
        "hardRate": "MEDIUM",
        "passRate": "49.91%",
        "problemsUrl": "https://leetcode.cn/problems/concatenation-of-consecutive-binary-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/concatenation-of-consecutive-binary-numbers/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，请你将 <code>1</code> 到 <code>n</code> 的二进制表示连接起来，并返回连接结果对应的 <strong>十进制</strong> 数字对 <code>10<sup>9</sup> + 7</code> 取余的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 1\n<b>输出：</b>1\n<strong>解释：</strong>二进制的 \"1\" 对应着十进制的 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 3\n<b>输出：</b>27\n<strong>解释：</strong>二进制下，1，2 和 3 分别对应 \"1\" ，\"10\" 和 \"11\" 。\n将它们依次连接，我们得到 \"11011\" ，对应着十进制的 27 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>n = 12\n<b>输出：</b>505379714\n<b>解释：</b>连接结果为 \"1101110010111011110001001101010111100\" 。\n对应的十进制数字为 118505380540 。\n对 10<sup>9</sup> + 7 取余后，结果为 505379714 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1681最小不兼容性",
        "hardRate": "HARD",
        "passRate": "59.01%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-incompatibility/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-incompatibility/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>​​​ 和一个整数 <code>k</code> 。你需要将这个数组划分到 <code>k</code> 个相同大小的子集中，使得同一个子集里面没有两个相同的元素。</p>\n\n<p>一个子集的 <strong>不兼容性</strong> 是该子集里面最大值和最小值的差。</p>\n\n<p>请你返回将数组分成 <code>k</code> 个子集后，各子集 <strong>不兼容性 </strong>的<strong> 和</strong> 的 <strong>最小值</strong> ，如果无法分成分成 <code>k</code> 个子集，返回 <code>-1</code> 。</p>\n\n<p>子集的定义是数组中一些数字的集合，对数字顺序没有要求。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,1,4], k = 2\n<b>输出：</b>4\n<b>解释：</b>最优的分配是 [1,2] 和 [1,4] 。\n不兼容性和为 (2-1) + (4-1) = 4 。\n注意到 [1,1] 和 [2,4] 可以得到更小的和，但是第一个集合有 2 个相同的元素，所以不可行。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [6,3,8,1,3,1,2,2], k = 4\n<b>输出：</b>6\n<b>解释：</b>最优的子集分配为 [1,2]，[2,3]，[6,8] 和 [1,3] 。\n不兼容性和为 (2-1) + (3-2) + (8-6) + (3-1) = 6 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5,3,3,6,3,3], k = 3\n<b>输出：</b>-1\n<b>解释：</b>没办法将这些数字分配到 3 个子集且满足每个子集里没有相同数字。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= k <= nums.length <= 16</code></li>\n\t<li><code>nums.length</code> 能被 <code>k</code> 整除。</li>\n\t<li><code>1 <= nums[i] <= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1682最长回文子序列 II",
        "hardRate": "MEDIUM",
        "passRate": "57.23%",
        "problemsUrl": "https://leetcode.cn/problems/longest-palindromic-subsequence-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-palindromic-subsequence-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1683无效的推文",
        "hardRate": "EASY",
        "passRate": "87.38%",
        "problemsUrl": "https://leetcode.cn/problems/invalid-tweets/",
        "solutionsUrl": "https://leetcode.cn/problems/invalid-tweets/solution",
        "problemsDesc": "<p>表：<code>Tweets</code></p>\n\n<pre>+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| tweet_id       | int     |\n| content        | varchar |\n+----------------+---------+\ntweet_id 是这个表的主键。\n这个表包含某社交媒体 App 中所有的推文。</pre>\n\n<p> </p>\n\n<p>写一条 SQL 语句，查询所有无效推文的编号（ID）。当推文内容中的字符数<strong>严格大于</strong> <code>15</code> 时，该推文是无效的。</p>\n\n<p>以<strong>任意顺序</strong>返回结果表。</p>\n\n<p>查询结果格式如下示例所示：</p>\n\n<p> </p>\n\n<pre>Tweets 表：\n+----------+----------------------------------+\n| tweet_id | content                          |\n+----------+----------------------------------+\n| 1        | Vote for Biden                   |\n| 2        | Let us make America great again! |\n+----------+----------------------------------+\n\n结果表：\n+----------+\n| tweet_id |\n+----------+\n| 2        |\n+----------+\n推文 1 的长度 length = 14。该推文是有效的。\n推文 2 的长度 length = 32。该推文是无效的。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1684统计一致字符串的数目",
        "hardRate": "EASY",
        "passRate": "85.20%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-consistent-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-consistent-strings/solution",
        "problemsDesc": "<p>给你一个由不同字符组成的字符串 <code>allowed</code> 和一个字符串数组 <code>words</code> 。如果一个字符串的每一个字符都在 <code>allowed</code> 中，就称这个字符串是 <strong>一致字符串 </strong>。</p>\n\n<p>请你返回 <code>words</code> 数组中 <strong>一致字符串</strong> 的数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>allowed = \"ab\", words = [\"ad\",\"bd\",\"aaab\",\"baa\",\"badab\"]\n<b>输出：</b>2\n<b>解释：</b>字符串 \"aaab\" 和 \"baa\" 都是一致字符串，因为它们只包含字符 'a' 和 'b' 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>allowed = \"abc\", words = [\"a\",\"b\",\"c\",\"ab\",\"ac\",\"bc\",\"abc\"]\n<b>输出：</b>7\n<b>解释：</b>所有字符串都是一致的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>allowed = \"cad\", words = [\"cc\",\"acd\",\"b\",\"ba\",\"bac\",\"bad\",\"ac\",\"d\"]\n<b>输出：</b>4\n<b>解释：</b>字符串 \"cc\"，\"acd\"，\"ac\" 和 \"d\" 是一致字符串。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= words.length <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= allowed.length <=<sup> </sup>26</code></li>\n\t<li><code>1 <= words[i].length <= 10</code></li>\n\t<li><code>allowed</code> 中的字符 <strong>互不相同</strong> 。</li>\n\t<li><code>words[i]</code> 和 <code>allowed</code> 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1685有序数组中差绝对值之和",
        "hardRate": "MEDIUM",
        "passRate": "64.90%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-absolute-differences-in-a-sorted-array/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-absolute-differences-in-a-sorted-array/solution",
        "problemsDesc": "<p>给你一个 <strong>非递减 </strong>有序整数数组 <code>nums</code> 。</p>\n\n<p>请你建立并返回一个整数数组<em> </em><code>result</code>，它跟<em> </em><code>nums</code> 长度相同，且<code>result[i]</code> 等于<em> </em><code>nums[i]</code> 与数组中所有其他元素差的绝对值之和。</p>\n\n<p>换句话说， <code>result[i]</code> 等于 <code>sum(|nums[i]-nums[j]|)</code> ，其中 <code>0 <= j < nums.length</code> 且 <code>j != i</code> （下标从 0 开始）。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,3,5]\n<b>输出：</b>[4,3,5]\n<b>解释：</b>假设数组下标从 0 开始，那么\nresult[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4，\nresult[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3，\nresult[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,4,6,8,10]\n<b>输出：</b>[24,15,13,15,21]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= nums[i + 1] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1686石子游戏 VI",
        "hardRate": "MEDIUM",
        "passRate": "50.15%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game-vi/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game-vi/solution",
        "problemsDesc": "<p>Alice 和 Bob 轮流玩一个游戏，Alice 先手。</p>\n\n<p>一堆石子里总共有 <code>n</code> 个石子，轮到某个玩家时，他可以 <strong>移出</strong> 一个石子并得到这个石子的价值。Alice 和 Bob 对石子价值有 <strong>不一样的的评判标准</strong> 。双方都知道对方的评判标准。</p>\n\n<p>给你两个长度为 <code>n</code> 的整数数组 <code>aliceValues</code> 和 <code>bobValues</code> 。<code>aliceValues[i]</code> 和 <code>bobValues[i]</code> 分别表示 Alice 和 Bob 认为第 <code>i</code> 个石子的价值。</p>\n\n<p>所有石子都被取完后，得分较高的人为胜者。如果两个玩家得分相同，那么为平局。两位玩家都会采用 <b>最优策略</b> 进行游戏。</p>\n\n<p>请你推断游戏的结果，用如下的方式表示：</p>\n\n<ul>\n\t<li>如果 Alice 赢，返回 <code>1</code> 。</li>\n\t<li>如果 Bob 赢，返回 <code>-1</code> 。</li>\n\t<li>如果游戏平局，返回 <code>0</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>aliceValues = [1,3], bobValues = [2,1]\n<b>输出：</b>1\n<strong>解释：</strong>\n如果 Alice 拿石子 1 （下标从 0开始），那么 Alice 可以得到 3 分。\nBob 只能选择石子 0 ，得到 2 分。\nAlice 获胜。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>aliceValues = [1,2], bobValues = [3,1]\n<b>输出：</b>0\n<strong>解释：</strong>\nAlice 拿石子 0 ， Bob 拿石子 1 ，他们得分都为 1 分。\n打平。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>aliceValues = [2,4,3], bobValues = [1,6,7]\n<b>输出：</b>-1\n<strong>解释：</strong>\n不管 Alice 怎么操作，Bob 都可以得到比 Alice 更高的得分。\n比方说，Alice 拿石子 1 ，Bob 拿石子 2 ， Alice 拿石子 0 ，Alice 会得到 6 分而 Bob 得分为 7 分。\nBob 会获胜。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == aliceValues.length == bobValues.length</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= aliceValues[i], bobValues[i] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1687从仓库到码头运输箱子",
        "hardRate": "HARD",
        "passRate": "58.81%",
        "problemsUrl": "https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/",
        "solutionsUrl": "https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/solution",
        "problemsDesc": "<p>你有一辆货运卡车，你需要用这一辆车把一些箱子从仓库运送到码头。这辆卡车每次运输有&nbsp;<strong>箱子数目的限制</strong>&nbsp;和 <strong>总重量的限制</strong>&nbsp;。</p>\n\n<p>给你一个箱子数组&nbsp;<code>boxes</code>&nbsp;和三个整数 <code>portsCount</code>, <code>maxBoxes</code>&nbsp;和&nbsp;<code>maxWeight</code>&nbsp;，其中&nbsp;<code>boxes[i] = [ports<sub>​​i</sub>​, weight<sub>i</sub>]</code>&nbsp;。</p>\n\n<ul>\n\t<li><code>ports<sub>​​i</sub></code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个箱子需要送达的码头，&nbsp;<code>weights<sub>i</sub></code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个箱子的重量。</li>\n\t<li><code>portsCount</code>&nbsp;是码头的数目。</li>\n\t<li><code>maxBoxes</code> 和&nbsp;<code>maxWeight</code>&nbsp;分别是卡车每趟运输箱子数目和重量的限制。</li>\n</ul>\n\n<p>箱子需要按照 <strong>数组顺序</strong>&nbsp;运输，同时每次运输需要遵循以下步骤：</p>\n\n<ul>\n\t<li>卡车从&nbsp;<code>boxes</code>&nbsp;队列中按顺序取出若干个箱子，但不能违反&nbsp;<code>maxBoxes</code> 和&nbsp;<code>maxWeight</code>&nbsp;限制。</li>\n\t<li>对于在卡车上的箱子，我们需要 <strong>按顺序</strong>&nbsp;处理它们，卡车会通过 <strong>一趟行程</strong>&nbsp;将最前面的箱子送到目的地码头并卸货。如果卡车已经在对应的码头，那么不需要 <strong>额外行程</strong>&nbsp;，箱子也会立马被卸货。</li>\n\t<li>卡车上所有箱子都被卸货后，卡车需要 <strong>一趟行程</strong>&nbsp;回到仓库，从箱子队列里再取出一些箱子。</li>\n</ul>\n\n<p>卡车在将所有箱子运输并卸货后，最后必须回到仓库。</p>\n\n<p>请你返回将所有箱子送到相应码头的&nbsp;<b>最少行程</b>&nbsp;次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3\n<b>输出：</b>4\n<b>解释：</b>最优策略如下：\n- 卡车将所有箱子装上车，到达码头 1 ，然后去码头 2 ，然后再回到码头 1 ，最后回到仓库，总共需要 4 趟行程。\n所以总行程数为 4 。\n注意到第一个和第三个箱子不能同时被卸货，因为箱子需要按顺序处理（也就是第二个箱子需要先被送到码头 2 ，然后才能处理第三个箱子）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6\n<b>输出：</b>6\n<b>解释：</b>最优策略如下：\n- 卡车首先运输第一个箱子，到达码头 1 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第二、第三、第四个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第五个箱子，到达码头 2 ，回到仓库，总共 2 趟行程。\n总行程数为 2 + 2 + 2 = 6 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>boxes = [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], portsCount = 3, maxBoxes = 6, maxWeight = 7\n<b>输出：</b>6\n<b>解释：</b>最优策略如下：\n- 卡车运输第一和第二个箱子，到达码头 1 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第三和第四个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第五和第六个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。\n总行程数为 2 + 2 + 2 = 6 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>boxes = [[2,4],[2,5],[3,1],[3,2],[3,7],[3,1],[4,4],[1,3],[5,2]], portsCount = 5, maxBoxes = 5, maxWeight = 7\n<b>输出：</b>14\n<b>解释：</b>最优策略如下：\n- 卡车运输第一个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第二个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第三和第四个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第五个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。\n- 卡车运输第六和第七个箱子，到达码头 3 ，然后去码头 4 ，然后回到仓库，总共 3 趟行程。\n- 卡车运输第八和第九个箱子，到达码头 1 ，然后去码头 5 ，然后回到仓库，总共 3 趟行程。\n总行程数为 2 + 2 + 2 + 2 + 3 + 3 = 14 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= boxes.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= portsCount, maxBoxes, maxWeight &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= ports<sub>​​i</sub> &lt;= portsCount</code></li>\n\t<li><code>1 &lt;= weights<sub>i</sub> &lt;= maxWeight</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1688比赛中的配对次数",
        "hardRate": "EASY",
        "passRate": "83.77%",
        "problemsUrl": "https://leetcode.cn/problems/count-of-matches-in-tournament/",
        "solutionsUrl": "https://leetcode.cn/problems/count-of-matches-in-tournament/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，表示比赛中的队伍数。比赛遵循一种独特的赛制：</p>\n\n<ul>\n\t<li>如果当前队伍数是 <strong>偶数</strong> ，那么每支队伍都会与另一支队伍配对。总共进行 <code>n / 2</code> 场比赛，且产生 <code>n / 2</code> 支队伍进入下一轮。</li>\n\t<li>如果当前队伍数为 <strong>奇数</strong> ，那么将会随机轮空并晋级一支队伍，其余的队伍配对。总共进行 <code>(n - 1) / 2</code> 场比赛，且产生 <code>(n - 1) / 2 + 1</code> 支队伍进入下一轮。</li>\n</ul>\n\n<p>返回在比赛中进行的配对次数，直到决出获胜队伍为止。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 7\n<strong>输出：</strong>6\n<strong>解释：</strong>比赛详情：\n- 第 1 轮：队伍数 = 7 ，配对次数 = 3 ，4 支队伍晋级。\n- 第 2 轮：队伍数 = 4 ，配对次数 = 2 ，2 支队伍晋级。\n- 第 3 轮：队伍数 = 2 ，配对次数 = 1 ，决出 1 支获胜队伍。\n总配对次数 = 3 + 2 + 1 = 6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 14\n<strong>输出：</strong>13\n<strong>解释：</strong>比赛详情：\n- 第 1 轮：队伍数 = 14 ，配对次数 = 7 ，7 支队伍晋级。\n- 第 2 轮：队伍数 = 7 ，配对次数 = 3 ，4 支队伍晋级。 \n- 第 3 轮：队伍数 = 4 ，配对次数 = 2 ，2 支队伍晋级。\n- 第 4 轮：队伍数 = 2 ，配对次数 = 1 ，决出 1 支获胜队伍。\n总配对次数 = 7 + 3 + 2 + 1 = 13\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1689十-二进制数的最少数目",
        "hardRate": "MEDIUM",
        "passRate": "86.62%",
        "problemsUrl": "https://leetcode.cn/problems/partitioning-into-minimum-number-of-deci-binary-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution",
        "problemsDesc": "<p>如果一个十进制数字不含任何前导零，且每一位上的数字不是 <code>0</code> 就是 <code>1</code> ，那么该数字就是一个 <strong>十-二进制数</strong> 。例如，<code>101</code> 和 <code>1100</code> 都是 <strong>十-二进制数</strong>，而 <code>112</code> 和 <code>3001</code> 不是。</p>\n\n<p>给你一个表示十进制整数的字符串 <code>n</code> ，返回和为 <code>n</code> 的 <strong>十-二进制数 </strong>的最少数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = \"32\"\n<strong>输出：</strong>3\n<strong>解释：</strong>10 + 11 + 11 = 32\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = \"82734\"\n<strong>输出：</strong>8\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = \"27346209830709182346\"\n<strong>输出：</strong>9\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>n</code> 仅由数字组成</li>\n\t<li><code>n</code> 不含任何前导零并总是表示正整数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1690石子游戏 VII",
        "hardRate": "MEDIUM",
        "passRate": "55.72%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game-vii/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game-vii/solution",
        "problemsDesc": "<p>石子游戏中，爱丽丝和鲍勃轮流进行自己的回合，<strong>爱丽丝先开始</strong> 。</p>\n\n<p>有 <code>n</code> 块石子排成一排。每个玩家的回合中，可以从行中 <strong>移除</strong> 最左边的石头或最右边的石头，并获得与该行中剩余石头值之 <strong>和</strong> 相等的得分。当没有石头可移除时，得分较高者获胜。</p>\n\n<p>鲍勃发现他总是输掉游戏（可怜的鲍勃，他总是输），所以他决定尽力 <strong>减小得分的差值</strong> 。爱丽丝的目标是最大限度地 <strong>扩大得分的差值</strong> 。</p>\n\n<p>给你一个整数数组 <code>stones</code> ，其中 <code>stones[i]</code> 表示 <strong>从左边开始</strong> 的第 <code>i</code> 个石头的值，如果爱丽丝和鲍勃都 <strong>发挥出最佳水平</strong> ，请返回他们 <strong>得分的差值</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [5,3,1,4,2]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n- 爱丽丝移除 2 ，得分 5 + 3 + 1 + 4 = 13 。游戏情况：爱丽丝 = 13 ，鲍勃 = 0 ，石子 = [5,3,1,4] 。\n- 鲍勃移除 5 ，得分 3 + 1 + 4 = 8 。游戏情况：爱丽丝 = 13 ，鲍勃 = 8 ，石子 = [3,1,4] 。\n- 爱丽丝移除 3 ，得分 1 + 4 = 5 。游戏情况：爱丽丝 = 18 ，鲍勃 = 8 ，石子 = [1,4] 。\n- 鲍勃移除 1 ，得分 4 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [4] 。\n- 爱丽丝移除 4 ，得分 0 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [] 。\n得分的差值 18 - 12 = 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [7,90,5,1,100,10,10,2]\n<strong>输出：</strong>122</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == stones.length</code></li>\n\t<li><code>2 <= n <= 1000</code></li>\n\t<li><code>1 <= stones[i] <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1691堆叠长方体的最大高度",
        "hardRate": "HARD",
        "passRate": "65.02%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-height-by-stacking-cuboids/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-height-by-stacking-cuboids/solution",
        "problemsDesc": "<p>给你 <code>n</code> 个长方体 <code>cuboids</code> ，其中第 <code>i</code> 个长方体的长宽高表示为 <code>cuboids[i] = [width<sub>i</sub>, length<sub>i</sub>, height<sub>i</sub>]</code>（<strong>下标从 0 开始</strong>）。请你从 <code>cuboids</code> 选出一个 <strong>子集</strong> ，并将它们堆叠起来。</p>\n\n<p>如果 <code>width<sub>i</sub> <= width<sub>j</sub></code> 且 <code>length<sub>i</sub> <= length<sub>j</sub></code> 且 <code>height<sub>i</sub> <= height<sub>j</sub></code> ，你就可以将长方体 <code>i</code> 堆叠在长方体 <code>j</code> 上。你可以通过旋转把长方体的长宽高重新排列，以将它放在另一个长方体上。</p>\n\n<p>返回 <strong>堆叠长方体</strong> <code>cuboids</code> 可以得到的 <strong>最大高度</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/12/image.jpg\" style=\"width: 420px; height: 299px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>cuboids = [[50,45,20],[95,37,53],[45,23,12]]\n<strong>输出：</strong>190\n<strong>解释：</strong>\n第 1 个长方体放在底部，53x37 的一面朝下，高度为 95 。\n第 0 个长方体放在中间，45x20 的一面朝下，高度为 50 。\n第 2 个长方体放在上面，23x12 的一面朝下，高度为 45 。\n总高度是 95 + 50 + 45 = 190 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>cuboids = [[38,25,45],[76,35,3]]\n<strong>输出：</strong>76\n<strong>解释：</strong>\n无法将任何长方体放在另一个上面。\n选择第 1 个长方体然后旋转它，使 35x3 的一面朝下，其高度为 76 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]]\n<strong>输出：</strong>102\n<strong>解释：</strong>\n重新排列长方体后，可以看到所有长方体的尺寸都相同。\n你可以把 11x7 的一面朝下，这样它们的高度就是 17 。\n堆叠长方体的最大高度为 6 * 17 = 102 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == cuboids.length</code></li>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>1 <= width<sub>i</sub>, length<sub>i</sub>, height<sub>i</sub> <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1692计算分配糖果的不同方式",
        "hardRate": "HARD",
        "passRate": "66.14%",
        "problemsUrl": "https://leetcode.cn/problems/count-ways-to-distribute-candies/",
        "solutionsUrl": "https://leetcode.cn/problems/count-ways-to-distribute-candies/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1693每天的领导和合伙人",
        "hardRate": "EASY",
        "passRate": "81.93%",
        "problemsUrl": "https://leetcode.cn/problems/daily-leads-and-partners/",
        "solutionsUrl": "https://leetcode.cn/problems/daily-leads-and-partners/solution",
        "problemsDesc": "<p>表：<code>DailySales</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| date_id     | date    |\n| make_name   | varchar |\n| lead_id     | int     |\n| partner_id  | int     |\n+-------------+---------+\n该表没有主键。\n该表包含日期、产品的名称，以及售给的领导和合伙人的编号。\n名称只包含小写英文字母。</pre>\n\n<p>&nbsp;</p>\n\n<p>写一条 SQL 语句，使得对于每一个&nbsp;<code>date_id</code>&nbsp;和&nbsp;<code>make_name</code>，返回<strong>不同</strong>的&nbsp;<code>lead_id</code>&nbsp;以及<strong>不同</strong>的&nbsp;<code>partner_id</code>&nbsp;的数量。</p>\n\n<p>按 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式如下示例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nDailySales 表：\n+-----------+-----------+---------+------------+\n| date_id   | make_name | lead_id | partner_id |\n+-----------+-----------+---------+------------+\n| 2020-12-8 | toyota    | 0       | 1          |\n| 2020-12-8 | toyota    | 1       | 0          |\n| 2020-12-8 | toyota    | 1       | 2          |\n| 2020-12-7 | toyota    | 0       | 2          |\n| 2020-12-7 | toyota    | 0       | 1          |\n| 2020-12-8 | honda     | 1       | 2          |\n| 2020-12-8 | honda     | 2       | 1          |\n| 2020-12-7 | honda     | 0       | 1          |\n| 2020-12-7 | honda     | 1       | 2          |\n| 2020-12-7 | honda     | 2       | 1          |\n+-----------+-----------+---------+------------+\n<strong>输出：</strong>\n+-----------+-----------+--------------+-----------------+\n| date_id   | make_name | unique_leads | unique_partners |\n+-----------+-----------+--------------+-----------------+\n| 2020-12-8 | toyota    | 2            | 3               |\n| 2020-12-7 | toyota    | 1            | 2               |\n| 2020-12-8 | honda     | 2            | 2               |\n| 2020-12-7 | honda     | 3            | 2               |\n+-----------+-----------+--------------+-----------------+\n<strong>解释：</strong>\n在 2020-12-8，丰田（toyota）有领导者 = [0, 1] 和合伙人 = [0, 1, 2] ，同时本田（honda）有领导者 = [1, 2] 和合伙人 = [1, 2]。\n在 2020-12-7，丰田（toyota）有领导者 = [0] 和合伙人 = [1, 2] ，同时本田（honda）有领导者 = [0, 1, 2] 和合伙人 = [1, 2]。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1694重新格式化电话号码",
        "hardRate": "EASY",
        "passRate": "66.09%",
        "problemsUrl": "https://leetcode.cn/problems/reformat-phone-number/",
        "solutionsUrl": "https://leetcode.cn/problems/reformat-phone-number/solution",
        "problemsDesc": "<p>给你一个字符串形式的电话号码 <code>number</code> 。<code>number</code> 由数字、空格 <code>' '</code>、和破折号 <code>'-'</code> 组成。</p>\n\n<p>请你按下述方式重新格式化电话号码。</p>\n\n<ul>\n\t<li>首先，<strong>删除</strong> 所有的空格和破折号。</li>\n\t<li>其次，将数组从左到右 <strong>每 3 个一组</strong> 分块，<strong>直到 </strong>剩下 4 个或更少数字。剩下的数字将按下述规定再分块：\n\t<ul>\n\t\t<li>2 个数字：单个含 2 个数字的块。</li>\n\t\t<li>3 个数字：单个含 3 个数字的块。</li>\n\t\t<li>4 个数字：两个分别含 2 个数字的块。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>最后用破折号将这些块连接起来。注意，重新格式化过程中 <strong>不应该</strong> 生成仅含 1 个数字的块，并且 <strong>最多</strong> 生成两个含 2 个数字的块。</p>\n\n<p>返回格式化后的电话号码。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>number = \"1-23-45 6\"\n<strong>输出：</strong>\"123-456\"\n<strong>解释：</strong>数字是 \"123456\"\n步骤 1：共有超过 4 个数字，所以先取 3 个数字分为一组。第 1 个块是 \"123\" 。\n步骤 2：剩下 3 个数字，将它们放入单个含 3 个数字的块。第 2 个块是 \"456\" 。\n连接这些块后得到 \"123-456\" 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>number = \"123 4-567\"\n<strong>输出：</strong>\"123-45-67\"\n<strong>解释：</strong>数字是 \"1234567\".\n步骤 1：共有超过 4 个数字，所以先取 3 个数字分为一组。第 1 个块是 \"123\" 。\n步骤 2：剩下 4 个数字，所以将它们分成两个含 2 个数字的块。这 2 块分别是 \"45\" 和 \"67\" 。\n连接这些块后得到 \"123-45-67\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>number = \"123 4-5678\"\n<strong>输出：</strong>\"123-456-78\"\n<strong>解释：</strong>数字是 \"12345678\" 。\n步骤 1：第 1 个块 \"123\" 。\n步骤 2：第 2 个块 \"456\" 。\n步骤 3：剩下 2 个数字，将它们放入单个含 2 个数字的块。第 3 个块是 \"78\" 。\n连接这些块后得到 \"123-456-78\" 。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>number = \"12\"\n<strong>输出：</strong>\"12\"\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>number = \"--17-5 229 35-39475 \"\n<strong>输出：</strong>\"175-229-353-94-75\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= number.length <= 100</code></li>\n\t<li><code>number</code> 由数字和字符 <code>'-'</code> 及 <code>' '</code> 组成。</li>\n\t<li><code>number</code> 中至少含 <strong>2</strong> 个数字。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1695删除子数组的最大得分",
        "hardRate": "MEDIUM",
        "passRate": "51.91%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-erasure-value/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-erasure-value/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>nums</code> ，请你从中删除一个含有 <strong>若干不同元素</strong> 的子数组<strong>。</strong>删除子数组的 <strong>得分</strong> 就是子数组各元素之 <strong>和</strong> 。</p>\n\n<p>返回 <strong>只删除一个</strong> 子数组可获得的 <strong>最大得分</strong><em> 。</em></p>\n\n<p>如果数组 <code>b</code> 是数组 <code>a</code> 的一个连续子序列，即如果它等于 <code>a[l],a[l+1],...,a[r]</code> ，那么它就是 <code>a</code> 的一个子数组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,2,4,5,6]\n<strong>输出：</strong>17\n<strong>解释：</strong>最优子数组是 [2,4,5,6]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,2,1,2,5,2,1,2,5]\n<strong>输出：</strong>8\n<strong>解释：</strong>最优子数组是 [5,2,1] 或 [1,2,5]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1696跳跃游戏 VI",
        "hardRate": "MEDIUM",
        "passRate": "40.24%",
        "problemsUrl": "https://leetcode.cn/problems/jump-game-vi/",
        "solutionsUrl": "https://leetcode.cn/problems/jump-game-vi/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>\n\n<p>一开始你在下标 <code>0</code> 处。每一步，你最多可以往前跳 <code>k</code> 步，但你不能跳出数组的边界。也就是说，你可以从下标 <code>i</code> 跳到 <code>[i + 1， min(n - 1, i + k)]</code> <strong>包含</strong> 两个端点的任意位置。</p>\n\n<p>你的目标是到达数组最后一个位置（下标为 <code>n - 1</code> ），你的 <strong>得分</strong> 为经过的所有数字之和。</p>\n\n<p>请你返回你能得到的 <strong>最大得分</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [<strong>1</strong>,<strong>-1</strong>,-2,<strong>4</strong>,-7,<strong>3</strong>], k = 2\n<b>输出：</b>7\n<b>解释：</b>你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<strong>10</strong>,-5,-2,<strong>4</strong>,0,<strong>3</strong>], k = 3\n<b>输出：</b>17\n<b>解释：</b>你可以选择子序列 [10,4,3] （上面加粗数字），和为 17 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,-5,-20,4,-1,3,-6,-3], k = 2\n<b>输出：</b>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li> <code>1 <= nums.length, k <= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1697检查边长度限制的路径是否存在",
        "hardRate": "HARD",
        "passRate": "64.93%",
        "problemsUrl": "https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/",
        "solutionsUrl": "https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/solution",
        "problemsDesc": "<p>给你一个 <code>n</code> 个点组成的无向图边集 <code>edgeList</code> ，其中 <code>edgeList[i] = [u<sub>i</sub>, v<sub>i</sub>, dis<sub>i</sub>]</code> 表示点 <code>u<sub>i</sub></code> 和点 <code>v<sub>i</sub></code> 之间有一条长度为 <code>dis<sub>i</sub></code> 的边。请注意，两个点之间可能有 <strong>超过一条边 </strong>。</p>\n\n<p>给你一个查询数组<code>queries</code> ，其中 <code>queries[j] = [p<sub>j</sub>, q<sub>j</sub>, limit<sub>j</sub>]</code> ，你的任务是对于每个查询 <code>queries[j]</code> ，判断是否存在从 <code>p<sub>j</sub></code> 到 <code>q<sub>j</sub></code><sub> </sub>的路径，且这条路径上的每一条边都 <strong>严格小于</strong> <code>limit<sub>j</sub></code> 。</p>\n\n<p>请你返回一个 <b>布尔数组</b><em> </em><code>answer</code><em> </em>，其中<em> </em><code>answer.length == queries.length</code> ，当 <code>queries[j]</code> 的查询结果为 <code>true</code> 时， <code>answer</code> 第<em> </em><code>j</code> 个值为<em> </em><code>true</code><em> </em>，否则为 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/19/h.png\" style=\"width: 267px; height: 262px;\" />\n<pre>\n<b>输入：</b>n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]\n<b>输出：</b>[false,true]\n<b>解释：</b>上图为给定的输入数据。注意到 0 和 1 之间有两条重边，分别为 2 和 16 。\n对于第一个查询，0 和 1 之间没有小于 2 的边，所以我们返回 false 。\n对于第二个查询，有一条路径（0 -> 1 -> 2）两条边都小于 5 ，所以这个查询我们返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/19/q.png\" style=\"width: 390px; height: 358px;\" />\n<pre>\n<b>输入：</b>n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]\n<b>输出：</b>[true,false]\n<b>解释：</b>上图为给定数据。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= edgeList.length, queries.length <= 10<sup>5</sup></code></li>\n\t<li><code>edgeList[i].length == 3</code></li>\n\t<li><code>queries[j].length == 3</code></li>\n\t<li><code>0 <= u<sub>i</sub>, v<sub>i</sub>, p<sub>j</sub>, q<sub>j</sub> <= n - 1</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n\t<li><code>p<sub>j</sub> != q<sub>j</sub></code></li>\n\t<li><code>1 <= dis<sub>i</sub>, limit<sub>j</sub> <= 10<sup>9</sup></code></li>\n\t<li>两个点之间可能有 <strong>多条</strong> 边。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1698字符串的不同子字符串个数",
        "hardRate": "MEDIUM",
        "passRate": "55.23%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-distinct-substrings-in-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-distinct-substrings-in-a-string/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1699两人之间的通话次数",
        "hardRate": "MEDIUM",
        "passRate": "76.40%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-calls-between-two-persons/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-calls-between-two-persons/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1700无法吃午餐的学生数量",
        "hardRate": "EASY",
        "passRate": "73.19%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/solution",
        "problemsDesc": "<p>学校的自助午餐提供圆形和方形的三明治，分别用数字 <code>0</code> 和 <code>1</code> 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。<br>\n餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 <strong>栈</strong> 里，每一轮：</p>\n\n<ul>\n\t<li>如果队列最前面的学生 <strong>喜欢</strong> 栈顶的三明治，那么会 <strong>拿走它</strong> 并离开队列。</li>\n\t<li>否则，这名学生会 <strong>放弃这个三明治</strong> 并回到队列的尾部。</li>\n</ul>\n\n<p>这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。</p>\n\n<p>给你两个整数数组 <code>students</code> 和 <code>sandwiches</code> ，其中 <code>sandwiches[i]</code> 是栈里面第 <code>i<sup>​​​​​​</sup></code> 个三明治的类型（<code>i = 0</code> 是栈的顶部）， <code>students[j]</code> 是初始队列里第 <code>j<sup>​​​​​​</sup></code> 名学生对三明治的喜好（<code>j = 0</code> 是队列的最开始位置）。请你返回无法吃午餐的学生数量。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>students = [1,1,0,0], sandwiches = [0,1,0,1]\n<b>输出：</b>0<strong> \n解释：</strong>\n- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [1,0,0,1]。\n- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [0,0,1,1]。\n- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [0,1,1]，三明治栈为 sandwiches = [1,0,1]。\n- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [1,1,0]。\n- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [1,0]，三明治栈为 sandwiches = [0,1]。\n- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [0,1]。\n- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [1]，三明治栈为 sandwiches = [1]。\n- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = []，三明治栈为 sandwiches = []。\n所以所有学生都有三明治吃。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]\n<b>输出：</b>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= students.length, sandwiches.length &lt;= 100</code></li>\n\t<li><code>students.length == sandwiches.length</code></li>\n\t<li><code>sandwiches[i]</code> 要么是 <code>0</code> ，要么是 <code>1</code> 。</li>\n\t<li><code>students[i]</code> 要么是 <code>0</code> ，要么是 <code>1</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1701平均等待时间",
        "hardRate": "MEDIUM",
        "passRate": "60.50%",
        "problemsUrl": "https://leetcode.cn/problems/average-waiting-time/",
        "solutionsUrl": "https://leetcode.cn/problems/average-waiting-time/solution",
        "problemsDesc": "<p>有一个餐厅，只有一位厨师。你有一个顾客数组 <code>customers</code> ，其中 <code>customers[i] = [arrival<sub>i</sub>, time<sub>i</sub>]</code> ：</p>\n\n<ul>\n\t<li><code>arrival<sub>i</sub></code> 是第 <code>i</code> 位顾客到达的时间，到达时间按 <strong>非递减</strong> 顺序排列。</li>\n\t<li><code>time<sub>i</sub></code> 是给第 <code>i</code> 位顾客做菜需要的时间。</li>\n</ul>\n\n<p>当一位顾客到达时，他将他的订单给厨师，厨师一旦空闲的时候就开始做这位顾客的菜。每位顾客会一直等待到厨师完成他的订单。厨师同时只能做一个人的订单。厨师会严格按照 <strong>订单给他的顺序</strong> 做菜。</p>\n\n<p>请你返回所有顾客需要等待的 <strong>平均 </strong>时间。与标准答案误差在 <code>10<sup>-5</sup></code> 范围以内，都视为正确结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>customers = [[1,2],[2,5],[4,3]]\n<b>输出：</b>5.00000\n<strong>解释：\n</strong>1) 第一位顾客在时刻 1 到达，厨师拿到他的订单并在时刻 1 立马开始做菜，并在时刻 3 完成，第一位顾客等待时间为 3 - 1 = 2 。\n2) 第二位顾客在时刻 2 到达，厨师在时刻 3 开始为他做菜，并在时刻 8 完成，第二位顾客等待时间为 8 - 2 = 6 。\n3) 第三位顾客在时刻 4 到达，厨师在时刻 8 开始为他做菜，并在时刻 11 完成，第三位顾客等待时间为 11 - 4 = 7 。\n平均等待时间为 (2 + 6 + 7) / 3 = 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>customers = [[5,2],[5,4],[10,3],[20,1]]\n<b>输出：</b>3.25000\n<strong>解释：\n</strong>1) 第一位顾客在时刻 5 到达，厨师拿到他的订单并在时刻 5 立马开始做菜，并在时刻 7 完成，第一位顾客等待时间为 7 - 5 = 2 。\n2) 第二位顾客在时刻 5 到达，厨师在时刻 7 开始为他做菜，并在时刻 11 完成，第二位顾客等待时间为 11 - 5 = 6 。\n3) 第三位顾客在时刻 10 到达，厨师在时刻 11 开始为他做菜，并在时刻 14 完成，第三位顾客等待时间为 14 - 10 = 4 。\n4) 第四位顾客在时刻 20 到达，厨师拿到他的订单并在时刻 20 立马开始做菜，并在时刻 21 完成，第四位顾客等待时间为 21 - 20 = 1 。\n平均等待时间为 (2 + 6 + 4 + 1) / 4 = 3.25 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= customers.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= arrival<sub>i</sub>, time<sub>i</sub> <= 10<sup>4</sup></code></li>\n\t<li><code>arrival<sub>i </sub><= arrival<sub>i+1</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1702修改后的最大二进制字符串",
        "hardRate": "MEDIUM",
        "passRate": "48.26%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-binary-string-after-change/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-binary-string-after-change/solution",
        "problemsDesc": "<p>给你一个二进制字符串 <code>binary</code> ，它仅有 <code>0</code> 或者 <code>1</code> 组成。你可以使用下面的操作任意次对它进行修改：</p>\n\n<ul>\n\t<li>操作 1 ：如果二进制串包含子字符串 <code>\"00\"</code> ，你可以用 <code>\"10\"</code> 将其替换。\n\n\t<ul>\n\t\t<li>比方说， <code>\"<strong>00</strong>010\" -> \"<strong>10</strong>010\"</code></li>\n\t</ul>\n\t</li>\n\t<li>操作 2 ：如果二进制串包含子字符串 <code>\"10\"</code> ，你可以用 <code>\"01\"</code> 将其替换。\n\t<ul>\n\t\t<li>比方说， <code>\"000<strong>10</strong>\" -> \"000<strong>01</strong>\"</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回执行上述操作任意次以后能得到的 <strong>最大二进制字符串</strong> 。如果二进制字符串 <code>x</code> 对应的十进制数字大于二进制字符串 <code>y</code> 对应的十进制数字，那么我们称二进制字符串<em> </em><code>x</code><em> </em>大于二进制字符串<em> </em><code>y</code><em> </em>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>binary = \"000110\"\n<b>输出：</b>\"111011\"\n<b>解释：</b>一个可行的转换为：\n\"0001<strong>10</strong>\" -> \"0001<strong>01</strong>\" \n\"<strong>00</strong>0101\" -> \"<strong>10</strong>0101\" \n\"1<strong>00</strong>101\" -> \"1<strong>10</strong>101\" \n\"110<strong>10</strong>1\" -> \"110<strong>01</strong>1\" \n\"11<strong>00</strong>11\" -> \"11<strong>10</strong>11\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>binary = \"01\"\n<b>输出：</b>\"01\"\n<b>解释：</b>\"01\" 没办法进行任何转换。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= binary.length <= 10<sup>5</sup></code></li>\n\t<li><code>binary</code> 仅包含 <code>'0'</code> 和 <code>'1'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1703得到连续 K 个 1 的最少相邻交换次数",
        "hardRate": "HARD",
        "passRate": "56.56%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-adjacent-swaps-for-k-consecutive-ones/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-adjacent-swaps-for-k-consecutive-ones/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。 <code>nums</code> 仅包含 <code>0</code> 和 <code>1</code> 。每一次移动，你可以选择 <strong>相邻</strong> 两个数字并将它们交换。</p>\n\n<p>请你返回使 <code>nums</code> 中包含 <code>k</code> 个 <strong>连续 </strong><code>1</code> 的 <strong>最少</strong> 交换次数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,0,0,1,0,1], k = 2\n<b>输出：</b>1\n<b>解释：</b>在第一次操作时，nums 可以变成 [1,0,0,0,<strong>1</strong>,<strong>1</strong>] 得到连续两个 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,0,0,0,0,0,1,1], k = 3\n<b>输出：</b>5\n<b>解释：</b>通过 5 次操作，最左边的 1 可以移到右边直到 nums 变为 [0,0,0,0,0,<strong>1</strong>,<strong>1</strong>,<strong>1</strong>] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [1,1,0,1], k = 2\n<b>输出：</b>0\n<b>解释：</b>nums 已经有连续 2 个 1 了。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> 要么是 <code>0</code> ，要么是 <code>1</code> 。</li>\n\t<li><code>1 &lt;= k &lt;= sum(nums)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1704判断字符串的两半是否相似",
        "hardRate": "EASY",
        "passRate": "78.37%",
        "problemsUrl": "https://leetcode.cn/problems/determine-if-string-halves-are-alike/",
        "solutionsUrl": "https://leetcode.cn/problems/determine-if-string-halves-are-alike/solution",
        "problemsDesc": "<p>给你一个偶数长度的字符串 <code>s</code> 。将其拆分成长度相同的两半，前一半为 <code>a</code> ，后一半为 <code>b</code> 。</p>\n\n<p>两个字符串 <strong>相似</strong> 的前提是它们都含有相同数目的元音（<code>'a'</code>，<code>'e'</code>，<code>'i'</code>，<code>'o'</code>，<code>'u'</code>，<code>'A'</code>，<code>'E'</code>，<code>'I'</code>，<code>'O'</code>，<code>'U'</code>）。注意，<code>s</code> 可能同时含有大写和小写字母。</p>\n\n<p>如果<em> </em><code>a</code><em> </em>和<em> </em><code>b</code> 相似，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"book\"\n<strong>输出：</strong>true\n<strong>解释：</strong>a = \"b<strong>o</strong>\" 且 b = \"<strong>o</strong>k\" 。a 中有 1 个元音，b 也有 1 个元音。所以，a 和 b 相似。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"textbook\"\n<strong>输出：</strong>false\n<strong>解释：</strong>a = \"t<strong>e</strong>xt\" 且 b = \"b<strong>oo</strong>k\" 。a 中有 1 个元音，b 中有 2 个元音。因此，a 和 b 不相似。\n注意，元音 o 在 b 中出现两次，记为 2 个。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s.length</code> 是偶数</li>\n\t<li><code>s</code> 由 <strong>大写和小写</strong> 字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1705吃苹果的最大数目",
        "hardRate": "MEDIUM",
        "passRate": "45.44%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-eaten-apples/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-eaten-apples/solution",
        "problemsDesc": "<p>有一棵特殊的苹果树，一连 <code>n</code> 天，每天都可以长出若干个苹果。在第 <code>i</code> 天，树上会长出 <code>apples[i]</code> 个苹果，这些苹果将会在 <code>days[i]</code> 天后（也就是说，第 <code>i + days[i]</code> 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 <code>apples[i] == 0</code> 且 <code>days[i] == 0</code> 表示。</p>\n\n<p>你打算每天 <strong>最多</strong> 吃一个苹果来保证营养均衡。注意，你可以在这 <code>n</code> 天之后继续吃苹果。</p>\n\n<p>给你两个长度为 <code>n</code> 的整数数组 <code>days</code> 和 <code>apples</code> ，返回你可以吃掉的苹果的最大数目<em>。</em></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>apples = [1,2,3,5,2], days = [3,2,1,4,2]\n<strong>输出：</strong>7\n<strong>解释：</strong>你可以吃掉 7 个苹果：\n- 第一天，你吃掉第一天长出来的苹果。\n- 第二天，你吃掉一个第二天长出来的苹果。\n- 第三天，你吃掉一个第二天长出来的苹果。过了这一天，第三天长出来的苹果就已经腐烂了。\n- 第四天到第七天，你吃的都是第四天长出来的苹果。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2]\n<strong>输出：</strong>5\n<strong>解释：</strong>你可以吃掉 5 个苹果：\n- 第一天到第三天，你吃的都是第一天长出来的苹果。\n- 第四天和第五天不吃苹果。\n- 第六天和第七天，你吃的都是第六天长出来的苹果。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>apples.length == n</code></li>\n\t<li><code>days.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= apples[i], days[i] &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li>只有在 <code>apples[i] = 0</code> 时，<code>days[i] = 0</code> 才成立</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1706球会落何处",
        "hardRate": "MEDIUM",
        "passRate": "69.05%",
        "problemsUrl": "https://leetcode.cn/problems/where-will-the-ball-fall/",
        "solutionsUrl": "https://leetcode.cn/problems/where-will-the-ball-fall/solution",
        "problemsDesc": "<p>用一个大小为 <code>m x n</code> 的二维网格 <code>grid</code> 表示一个箱子。你有 <code>n</code> 颗球。箱子的顶部和底部都是开着的。</p>\n\n<p>箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。</p>\n\n<ul>\n\t<li>将球导向右侧的挡板跨过左上角和右下角，在网格中用 <code>1</code> 表示。</li>\n\t<li>将球导向左侧的挡板跨过右上角和左下角，在网格中用 <code>-1</code> 表示。</li>\n</ul>\n\n<p>在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 \"V\" 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。</p>\n\n<p>返回一个大小为 <code>n</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是球放在顶部的第 <code>i</code> 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/26/ball.jpg\" style=\"width: 500px; height: 385px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]\n<strong>输出：</strong>[1,-1,-1,-1,-1]\n<strong>解释：</strong>示例如图：\nb0 球开始放在第 0 列上，最终从箱子底部第 1 列掉出。\nb1 球开始放在第 1 列上，会卡在第 2、3 列和第 1 行之间的 \"V\" 形里。\nb2 球开始放在第 2 列上，会卡在第 2、3 列和第 0 行之间的 \"V\" 形里。\nb3 球开始放在第 3 列上，会卡在第 2、3 列和第 0 行之间的 \"V\" 形里。\nb4 球开始放在第 4 列上，会卡在第 2、3 列和第 1 行之间的 \"V\" 形里。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[-1]]\n<strong>输出：</strong>[-1]\n<strong>解释：</strong>球被卡在箱子左侧边上。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]\n<strong>输出：</strong>[0,1,2,3,4,-1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 <= m, n <= 100</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>1</code> 或 <code>-1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1707与数组中元素的最大异或值",
        "hardRate": "HARD",
        "passRate": "50.94%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-xor-with-an-element-from-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-xor-with-an-element-from-array/solution",
        "problemsDesc": "<p>给你一个由非负整数组成的数组 <code>nums</code> 。另有一个查询数组 <code>queries</code> ，其中 <code>queries[i] = [x<sub>i</sub>, m<sub>i</sub>]</code> 。</p>\n\n<p>第 <code>i</code> 个查询的答案是 <code>x<sub>i</sub></code> 和任何 <code>nums</code> 数组中不超过 <code>m<sub>i</sub></code> 的元素按位异或（<code>XOR</code>）得到的最大值。换句话说，答案是 <code>max(nums[j] XOR x<sub>i</sub>)</code> ，其中所有 <code>j</code> 均满足 <code>nums[j] &lt;= m<sub>i</sub></code> 。如果 <code>nums</code> 中的所有元素都大于 <code>m<sub>i</sub></code>，最终答案就是 <code>-1</code> 。</p>\n\n<p>返回一个整数数组<em> </em><code>answer</code><em> </em>作为查询的答案，其中<em> </em><code>answer.length == queries.length</code><em> </em>且<em> </em><code>answer[i]</code><em> </em>是第<em> </em><code>i</code><em> </em>个查询的答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]\n<strong>输出：</strong>[3,3,7]\n<strong>解释：</strong>\n1) 0 和 1 是仅有的两个不超过 1 的整数。0 XOR 3 = 3 而 1 XOR 3 = 2 。二者中的更大值是 3 。\n2) 1 XOR 2 = 3.\n3) 5 XOR 2 = 7.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]\n<strong>输出：</strong>[15,-1,5]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>0 &lt;= nums[j], x<sub>i</sub>, m<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1708长度为 K 的最大子数组",
        "hardRate": "EASY",
        "passRate": "66.96%",
        "problemsUrl": "https://leetcode.cn/problems/largest-subarray-length-k/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-subarray-length-k/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1709访问日期之间最大的空档期",
        "hardRate": "MEDIUM",
        "passRate": "68.97%",
        "problemsUrl": "https://leetcode.cn/problems/biggest-window-between-visits/",
        "solutionsUrl": "https://leetcode.cn/problems/biggest-window-between-visits/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1710卡车上的最大单元数",
        "hardRate": "EASY",
        "passRate": "73.45%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-units-on-a-truck/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-units-on-a-truck/solution",
        "problemsDesc": "<p>请你将一些箱子装在 <strong>一辆卡车</strong> 上。给你一个二维数组 <code>boxTypes</code> ，其中 <code>boxTypes[i] = [numberOfBoxes<sub>i</sub>, numberOfUnitsPerBox<sub>i</sub>]</code> ：</p>\n\n<ul>\n\t<li><code>numberOfBoxes<sub>i</sub></code> 是类型 <code>i</code> 的箱子的数量。</li>\n\t<li><code>numberOfUnitsPerBox<sub>i</sub></code><sub> </sub>是类型 <code>i</code> 每个箱子可以装载的单元数量。</li>\n</ul>\n\n<p>整数 <code>truckSize</code> 表示卡车上可以装载 <strong>箱子</strong> 的 <strong>最大数量</strong> 。只要箱子数量不超过 <code>truckSize</code> ，你就可以选择任意箱子装到卡车上。</p>\n\n<p>返回卡车可以装载 <strong>单元</strong> 的 <strong>最大</strong> 总数<em>。</em></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4\n<strong>输出：</strong>8\n<strong>解释：</strong>箱子的情况如下：\n- 1 个第一类的箱子，里面含 3 个单元。\n- 2 个第二类的箱子，每个里面含 2 个单元。\n- 3 个第三类的箱子，每个里面含 1 个单元。\n可以选择第一类和第二类的所有箱子，以及第三类的一个箱子。\n单元总数 = (1 * 3) + (2 * 2) + (1 * 1) = 8</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10\n<strong>输出：</strong>91\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= boxTypes.length <= 1000</code></li>\n\t<li><code>1 <= numberOfBoxes<sub>i</sub>, numberOfUnitsPerBox<sub>i</sub> <= 1000</code></li>\n\t<li><code>1 <= truckSize <= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1711大餐计数",
        "hardRate": "MEDIUM",
        "passRate": "35.97%",
        "problemsUrl": "https://leetcode.cn/problems/count-good-meals/",
        "solutionsUrl": "https://leetcode.cn/problems/count-good-meals/solution",
        "problemsDesc": "<p><strong>大餐</strong> 是指 <strong>恰好包含两道不同餐品</strong> 的一餐，其美味程度之和等于 2 的幂。</p>\n\n<p>你可以搭配 <strong>任意</strong> 两道餐品做一顿大餐。</p>\n\n<p>给你一个整数数组 <code>deliciousness</code> ，其中 <code>deliciousness[i]</code> 是第 <code>i<sup>​​​​​​</sup>​​​​</code>​​​​ 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 <strong>大餐</strong> 的数量。结果需要对 <code>10<sup>9</sup> + 7</code> 取余。</p>\n\n<p>注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>deliciousness = [1,3,5,7,9]\n<strong>输出：</strong>4\n<strong>解释：</strong>大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。\n它们各自的美味程度之和分别为 4 、8 、8 和 16 ，都是 2 的幂。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>deliciousness = [1,1,1,3,3,3,7]\n<strong>输出：</strong>15\n<strong>解释：</strong>大餐的美味程度组合为 3 种 (1,1) ，9 种 (1,3) ，和 3 种 (1,7) 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= deliciousness.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= deliciousness[i] <= 2<sup>20</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1712将数组分成三个子数组的方案数",
        "hardRate": "MEDIUM",
        "passRate": "28.55%",
        "problemsUrl": "https://leetcode.cn/problems/ways-to-split-array-into-three-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/ways-to-split-array-into-three-subarrays/solution",
        "problemsDesc": "<p>我们称一个分割整数数组的方案是 <strong>好的</strong> ，当它满足：</p>\n\n<ul>\n\t<li>数组被分成三个 <strong>非空</strong> 连续子数组，从左至右分别命名为 <code>left</code> ， <code>mid</code> ， <code>right</code> 。</li>\n\t<li><code>left</code> 中元素和小于等于 <code>mid</code> 中元素和，<code>mid</code> 中元素和小于等于 <code>right</code> 中元素和。</li>\n</ul>\n\n<p>给你一个 <strong>非负</strong> 整数数组 <code>nums</code> ，请你返回 <strong>好的</strong> 分割 <code>nums</code> 方案数目。由于答案可能会很大，请你将结果对 <code>10<sup>9 </sup>+ 7</code> 取余后返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,1,1]\n<b>输出：</b>1\n<b>解释：</b>唯一一种好的分割方案是将 nums 分成 [1] [1] [1] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,2,2,5,0]\n<b>输出：</b>3\n<b>解释：</b>nums 总共有 3 种好的分割方案：\n[1] [2] [2,2,5,0]\n[1] [2,2] [2,5,0]\n[1,2] [2,2] [5,0]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,2,1]\n<b>输出：</b>0\n<b>解释：</b>没有好的分割方案。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1713得到子序列的最少操作次数",
        "hardRate": "HARD",
        "passRate": "49.93%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-a-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-a-subsequence/solution",
        "problemsDesc": "<p>给你一个数组 <code>target</code> ，包含若干 <strong>互不相同</strong> 的整数，以及另一个整数数组 <code>arr</code> ，<code>arr</code> <strong>可能</strong> 包含重复元素。</p>\n\n<p>每一次操作中，你可以在 <code>arr</code> 的任意位置插入任一整数。比方说，如果 <code>arr = [1,4,1,2]</code> ，那么你可以在中间添加 <code>3</code> 得到 <code>[1,4,<strong>3</strong>,1,2]</code> 。你可以在数组最开始或最后面添加整数。</p>\n\n<p>请你返回 <strong>最少</strong> 操作次数，使得<em> </em><code>target</code><em> </em>成为 <code>arr</code> 的一个子序列。</p>\n\n<p>一个数组的 <strong>子序列</strong> 指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，<code>[2,7,4]</code> 是 <code>[4,<strong>2</strong>,3,<strong>7</strong>,2,1,<strong>4</strong>]</code> 的子序列（加粗元素），但 <code>[2,4,2]</code> 不是子序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>target = [5,1,3], <code>arr</code> = [9,4,2,3,4]\n<b>输出：</b>2\n<b>解释：</b>你可以添加 5 和 1 ，使得 arr 变为 [<strong>5</strong>,9,4,<strong>1</strong>,2,3,4] ，target 为 arr 的子序列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>target = [6,4,8,1,3,2], <code>arr</code> = [4,7,6,2,3,8,6,1]\n<b>输出：</b>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target.length, arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= target[i], arr[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>target</code> 不包含任何重复元素。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1714数组中特殊等间距元素的和",
        "hardRate": "HARD",
        "passRate": "59.62%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-special-evenly-spaced-elements-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-special-evenly-spaced-elements-in-array/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1715苹果和橘子的个数",
        "hardRate": "MEDIUM",
        "passRate": "71.80%",
        "problemsUrl": "https://leetcode.cn/problems/count-apples-and-oranges/",
        "solutionsUrl": "https://leetcode.cn/problems/count-apples-and-oranges/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1716计算力扣银行的钱",
        "hardRate": "EASY",
        "passRate": "69.07%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-money-in-leetcode-bank/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-money-in-leetcode-bank/solution",
        "problemsDesc": "<p>Hercy 想要为购买第一辆车存钱。他 <strong>每天</strong> 都往力扣银行里存钱。</p>\n\n<p>最开始，他在周一的时候存入 <code>1</code> 块钱。从周二到周日，他每天都比前一天多存入 <code>1</code> 块钱。在接下来每一个周一，他都会比 <strong>前一个周一</strong> 多存入 <code>1</code> 块钱。<span style=\"\"> </span></p>\n\n<p>给你 <code>n</code> ，请你返回在第 <code>n</code> 天结束的时候他在力扣银行总共存了多少块钱。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 4\n<b>输出：</b>10\n<b>解释：</b>第 4 天后，总额为 1 + 2 + 3 + 4 = 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 10\n<b>输出：</b>37\n<b>解释：</b>第 10 天后，总额为 (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37 。注意到第二个星期一，Hercy 存入 2 块钱。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>n = 20\n<b>输出：</b>96\n<b>解释：</b>第 20 天后，总额为 (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1717删除子字符串的最大得分",
        "hardRate": "MEDIUM",
        "passRate": "46.12%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-from-removing-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-from-removing-substrings/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和两个整数 <code>x</code> 和 <code>y</code> 。你可以执行下面两种操作任意次。</p>\n\n<ul>\n\t<li>删除子字符串 <code>\"ab\"</code> 并得到 <code>x</code> 分。\n\n\t<ul>\n\t\t<li>比方说，从 <code>\"c<strong>ab</strong>xbae\"</code> 删除 <code>ab</code> ，得到 <code>\"cxbae\"</code> 。</li>\n\t</ul>\n\t</li>\n\t<li>删除子字符串<code>\"ba\"</code> 并得到 <code>y</code> 分。\n\t<ul>\n\t\t<li>比方说，从 <code>\"cabx<strong>ba</strong>e\"</code> 删除 <code>ba</code> ，得到 <code>\"cabxe\"</code> 。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请返回对 <code>s</code> 字符串执行上面操作若干次能得到的最大得分。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"cdbcbbaaabab\", x = 4, y = 5\n<b>输出：</b>19\n<strong>解释：</strong>\n- 删除 \"cdbcbbaaa<strong>ba</strong>b\" 中加粗的 \"ba\" ，得到 s = \"cdbcbbaaab\" ，加 5 分。\n- 删除 \"cdbcbbaa<strong>ab</strong>\" 中加粗的 \"ab\" ，得到 s = \"cdbcbbaa\" ，加 4 分。\n- 删除 \"cdbcb<strong>ba</strong>a\" 中加粗的 \"ba\" ，得到 s = \"cdbcba\" ，加 5 分。\n- 删除 \"cdbc<strong>ba</strong>\" 中加粗的 \"ba\" ，得到 s = \"cdbc\" ，加 5 分。\n总得分为 5 + 4 + 5 + 5 = 19 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"aabbaaxybbaabb\", x = 5, y = 4\n<b>输出：</b>20\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= x, y &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1718构建字典序最大的可行序列",
        "hardRate": "MEDIUM",
        "passRate": "50.91%",
        "problemsUrl": "https://leetcode.cn/problems/construct-the-lexicographically-largest-valid-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-the-lexicographically-largest-valid-sequence/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，请你找到满足下面条件的一个序列：</p>\n\n<ul>\n\t<li>整数 <code>1</code> 在序列中只出现一次。</li>\n\t<li><code>2</code> 到 <code>n</code> 之间每个整数都恰好出现两次。</li>\n\t<li>对于每个 <code>2</code> 到 <code>n</code> 之间的整数 <code>i</code> ，两个 <code>i</code> 之间出现的距离恰好为 <code>i</code> 。</li>\n</ul>\n\n<p>序列里面两个数 <code>a[i]</code> 和 <code>a[j]</code> 之间的 <strong>距离</strong> ，我们定义为它们下标绝对值之差 <code>|j - i|</code> 。</p>\n\n<p>请你返回满足上述条件中 <strong>字典序最大</strong> 的序列。题目保证在给定限制条件下，一定存在解。</p>\n\n<p>一个序列 <code>a</code> 被认为比序列 <code>b</code> （两者长度相同）字典序更大的条件是： <code>a</code> 和 <code>b</code> 中第一个不一样的数字处，<code>a</code> 序列的数字比 <code>b</code> 序列的数字大。比方说，<code>[0,1,9,0]</code> 比 <code>[0,1,5,6]</code> 字典序更大，因为第一个不同的位置是第三个数字，且 <code>9</code> 比 <code>5</code> 大。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 3\n<b>输出：</b>[3,1,2,3,2]\n<b>解释：</b>[2,3,2,1,3] 也是一个可行的序列，但是 [3,1,2,3,2] 是字典序最大的序列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 5\n<b>输出：</b>[5,3,1,4,3,5,2,4,2]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1719重构一棵树的方案数",
        "hardRate": "HARD",
        "passRate": "69.04%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-reconstruct-a-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-reconstruct-a-tree/solution",
        "problemsDesc": "<p>给你一个数组 <code>pairs</code> ，其中 <code>pairs[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> ，并且满足：</p>\n\n<ul>\n\t<li><code>pairs</code> 中没有重复元素</li>\n\t<li><code>x<sub>i</sub> < y<sub>i</sub></code></li>\n</ul>\n\n<p>令 <code>ways</code> 为满足下面条件的有根树的方案数：</p>\n\n<ul>\n\t<li>树所包含的所有节点值都在 <code>pairs</code> 中。</li>\n\t<li>一个数对 <code>[x<sub>i</sub>, y<sub>i</sub>]</code> 出现在 <code>pairs</code> 中 <strong>当且仅当</strong><strong> </strong><code>x<sub>i</sub></code> 是 <code>y<sub>i</sub></code> 的祖先或者 <code>y<sub>i</sub></code> 是 <code>x<sub>i</sub></code><sub> </sub>的祖先。</li>\n\t<li><strong>注意：</strong>构造出来的树不一定是二叉树。</li>\n</ul>\n\n<p>两棵树被视为不同的方案当存在至少一个节点在两棵树中有不同的父节点。</p>\n\n<p>请你返回：</p>\n\n<ul>\n\t<li>如果 <code>ways == 0</code> ，返回 <code>0</code> 。</li>\n\t<li>如果 <code>ways == 1</code> ，返回 <code>1</code> 。</li>\n\t<li>如果 <code>ways > 1</code> ，返回 <code>2</code> 。</li>\n</ul>\n\n<p>一棵 <strong>有根树</strong> 指的是只有一个根节点的树，所有边都是从根往外的方向。</p>\n\n<p>我们称从根到一个节点路径上的任意一个节点（除去节点本身）都是该节点的 <strong>祖先</strong> 。根节点没有祖先。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/09/trees2.png\" style=\"width: 208px; height: 221px;\" />\n<pre>\n<b>输入：</b>pairs = [[1,2],[2,3]]\n<b>输出：</b>1\n<b>解释：</b>如上图所示，有且只有一个符合规定的有根树。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/09/tree.png\" style=\"width: 234px; height: 241px;\" />\n<pre>\n<b>输入：</b>pairs = [[1,2],[2,3],[1,3]]\n<b>输出：</b>2\n<b>解释：</b>有多个符合规定的有根树，其中三个如上图所示。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>pairs = [[1,2],[2,3],[2,4],[1,5]]\n<b>输出：</b>0\n<b>解释：</b>没有符合规定的有根树。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= pairs.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= x<sub>i </sub>< y<sub>i</sub> <= 500</code></li>\n\t<li><code>pairs</code> 中的元素互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1720解码异或后的数组",
        "hardRate": "EASY",
        "passRate": "85.94%",
        "problemsUrl": "https://leetcode.cn/problems/decode-xored-array/",
        "solutionsUrl": "https://leetcode.cn/problems/decode-xored-array/solution",
        "problemsDesc": "<p><strong>未知</strong> 整数数组 <code>arr</code> 由 <code>n</code> 个非负整数组成。</p>\n\n<p>经编码后变为长度为 <code>n - 1</code> 的另一个整数数组 <code>encoded</code> ，其中 <code>encoded[i] = arr[i] XOR arr[i + 1]</code> 。例如，<code>arr = [1,0,2,1]</code> 经编码后得到 <code>encoded = [1,2,3]</code> 。</p>\n\n<p>给你编码后的数组 <code>encoded</code> 和原数组 <code>arr</code> 的第一个元素 <code>first</code>（<code>arr[0]</code>）。</p>\n\n<p>请解码返回原数组 <code>arr</code> 。可以证明答案存在并且是唯一的。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>encoded = [1,2,3], first = 1\n<strong>输出：</strong>[1,0,2,1]\n<strong>解释：</strong>若 arr = [1,0,2,1] ，那么 first = 1 且 encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>encoded = [6,2,7,3], first = 4\n<strong>输出：</strong>[4,2,0,7,4]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 10<sup>4</sup></code></li>\n\t<li><code>encoded.length == n - 1</code></li>\n\t<li><code>0 <= encoded[i] <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= first <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1721交换链表中的节点",
        "hardRate": "MEDIUM",
        "passRate": "63.66%",
        "problemsUrl": "https://leetcode.cn/problems/swapping-nodes-in-a-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/swapping-nodes-in-a-linked-list/solution",
        "problemsDesc": "<p>给你链表的头节点 <code>head</code> 和一个整数 <code>k</code> 。</p>\n\n<p><strong>交换</strong> 链表正数第 <code>k</code> 个节点和倒数第 <code>k</code> 个节点的值后，返回链表的头节点（链表 <strong>从 1 开始索引</strong>）。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/10/linked1.jpg\" style=\"width: 722px; height: 202px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], k = 2\n<strong>输出：</strong>[1,4,3,2,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [7,9,6,6,7,8,3,0,9,5], k = 5\n<strong>输出：</strong>[7,9,6,6,8,7,3,0,9,5]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1], k = 1\n<strong>输出：</strong>[1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2], k = 1\n<strong>输出：</strong>[2,1]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,3], k = 2\n<strong>输出：</strong>[1,2,3]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目是 <code>n</code></li>\n\t<li><code>1 <= k <= n <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= Node.val <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1722执行交换操作后的最小汉明距离",
        "hardRate": "MEDIUM",
        "passRate": "51.04%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-hamming-distance-after-swap-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-hamming-distance-after-swap-operations/solution",
        "problemsDesc": "<p>给你两个整数数组 <code>source</code> 和 <code>target</code> ，长度都是 <code>n</code> 。还有一个数组 <code>allowedSwaps</code> ，其中每个 <code>allowedSwaps[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示你可以交换数组 <code>source</code> 中下标为 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code>（<strong>下标从 0 开始</strong>）的两个元素。注意，你可以按 <strong>任意</strong> 顺序 <strong>多次</strong> 交换一对特定下标指向的元素。</p>\n\n<p>相同长度的两个数组 <code>source</code> 和 <code>target</code> 间的 <strong>汉明距离</strong> 是元素不同的下标数量。形式上，其值等于满足 <code>source[i] != target[i]</code> （<strong>下标从 0 开始</strong>）的下标 <code>i</code>（<code>0 &lt;= i &lt;= n-1</code>）的数量。</p>\n\n<p>在对数组 <code>source</code> 执行 <strong>任意</strong> 数量的交换操作后，返回 <code>source</code> 和 <code>target</code> 间的 <strong>最小汉明距离</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]]\n<strong>输出：</strong>1\n<strong>解释：</strong>source 可以按下述方式转换：\n- 交换下标 0 和 1 指向的元素：source = [<strong>2</strong>,<strong>1</strong>,3,4]\n- 交换下标 2 和 3 指向的元素：source = [2,1,<strong>4</strong>,<strong>3</strong>]\nsource 和 target 间的汉明距离是 1 ，二者有 1 处元素不同，在下标 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = []\n<strong>输出：</strong>2\n<strong>解释：</strong>不能对 source 执行交换操作。\nsource 和 target 间的汉明距离是 2 ，二者有 2 处元素不同，在下标 1 和下标 2 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>source = [5,1,2,4,3], target = [1,5,4,2,3], allowedSwaps = [[0,4],[4,2],[1,3],[1,4]]\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == source.length == target.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= source[i], target[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= allowedSwaps.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>allowedSwaps[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1723完成所有工作的最短时间",
        "hardRate": "HARD",
        "passRate": "50.85%",
        "problemsUrl": "https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/",
        "solutionsUrl": "https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>jobs</code> ，其中 <code>jobs[i]</code> 是完成第 <code>i</code> 项工作要花费的时间。</p>\n\n<p>请你将这些工作分配给 <code>k</code> 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 <strong>工作时间</strong> 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 <strong>最大工作时间</strong> 得以 <strong>最小化</strong> 。</p>\n\n<p>返回分配方案中尽可能 <strong>最小</strong> 的 <strong>最大工作时间</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>jobs = [3,2,3], k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>给每位工人分配一项工作，最大工作时间是 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>jobs = [1,2,4,7,8], k = 2\n<strong>输出：</strong>11\n<strong>解释：</strong>按下述方式分配工作：\n1 号工人：1、2、8（工作时间 = 1 + 2 + 8 = 11）\n2 号工人：4、7（工作时间 = 4 + 7 = 11）\n最大工作时间是 11 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= k <= jobs.length <= 12</code></li>\n\t<li><code>1 <= jobs[i] <= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1724检查边长度限制的路径是否存在 II",
        "hardRate": "HARD",
        "passRate": "58.55%",
        "problemsUrl": "https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1725可以形成最大正方形的矩形数目",
        "hardRate": "EASY",
        "passRate": "82.81%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-rectangles-that-can-form-the-largest-square/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-rectangles-that-can-form-the-largest-square/solution",
        "problemsDesc": "<p>给你一个数组 <code>rectangles</code> ，其中 <code>rectangles[i] = [l<sub>i</sub>, w<sub>i</sub>]</code> 表示第 <code>i</code> 个矩形的长度为 <code>l<sub>i</sub></code> 、宽度为 <code>w<sub>i</sub></code> 。</p>\n\n<p>如果存在 <code>k</code> 同时满足 <code>k <= l<sub>i</sub></code> 和 <code>k <= w<sub>i</sub></code> ，就可以将第 <code>i</code> 个矩形切成边长为 <code>k</code> 的正方形。例如，矩形 <code>[4,6]</code> 可以切成边长最大为 <code>4</code> 的正方形。</p>\n\n<p>设 <code>maxLen</code> 为可以从矩形数组 <code>rectangles</code> 切分得到的 <strong>最大正方形</strong> 的边长。</p>\n\n<p>请你统计有多少个矩形能够切出边长为<em> </em><code>maxLen</code> 的正方形，并返回矩形 <strong>数目</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rectangles = [[5,8],[3,9],[5,12],[16,5]]\n<strong>输出：</strong>3\n<strong>解释：</strong>能从每个矩形中切出的最大正方形边长分别是 [5,3,5,5] 。\n最大正方形的边长为 5 ，可以由 3 个矩形切分得到。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rectangles = [[2,3],[3,7],[4,3],[3,7]]\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= rectangles.length <= 1000</code></li>\n\t<li><code>rectangles[i].length == 2</code></li>\n\t<li><code>1 <= l<sub>i</sub>, w<sub>i</sub> <= 10<sup>9</sup></code></li>\n\t<li><code>l<sub>i</sub> != w<sub>i</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1726同积元组",
        "hardRate": "MEDIUM",
        "passRate": "52.21%",
        "problemsUrl": "https://leetcode.cn/problems/tuple-with-same-product/",
        "solutionsUrl": "https://leetcode.cn/problems/tuple-with-same-product/solution",
        "problemsDesc": "<p>给你一个由 <strong>不同</strong> 正整数组成的数组 <code>nums</code> ，请你返回满足&nbsp;<code>a * b = c * d</code> 的元组<em> </em><code>(a, b, c, d)</code><em> </em>的数量。其中 <code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> 都是 <code>nums</code> 中的元素，且 <code>a != b != c != d</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,4,6]\n<strong>输出：</strong>8\n<strong>解释：</strong>存在 8 个满足题意的元组：\n(2,6,3,4) , (2,6,4,3) , (6,2,3,4) , (6,2,4,3)\n(3,4,2,6) , (4,3,2,6) , (3,4,6,2) , (4,3,6,2)\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,4,5,10]\n<strong>输出：</strong>16\n<strong>解释：</strong>存在 16 个满足题意的元组：\n(1,10,2,5) , (1,10,5,2) , (10,1,2,5) , (10,1,5,2)\n(2,5,1,10) , (2,5,10,1) , (5,2,1,10) , (5,2,10,1)\n(2,10,4,5) , (2,10,5,4) , (10,2,4,5) , (10,2,4,5)\n(4,5,2,10) , (4,5,10,2) , (5,4,2,10) , (5,4,10,2)\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1727重新排列后的最大子矩阵",
        "hardRate": "MEDIUM",
        "passRate": "59.21%",
        "problemsUrl": "https://leetcode.cn/problems/largest-submatrix-with-rearrangements/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-submatrix-with-rearrangements/solution",
        "problemsDesc": "<p>给你一个二进制矩阵 <code>matrix</code> ，它的大小为 <code>m x n</code> ，你可以将 <code>matrix</code> 中的 <strong>列</strong> 按任意顺序重新排列。</p>\n\n<p>请你返回最优方案下将 <code>matrix</code> 重新排列后，全是 <code>1</code> 的子矩阵面积。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/17/screenshot-2020-12-30-at-40536-pm.png\" style=\"width: 300px; height: 144px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>matrix = [[0,0,1],[1,1,1],[1,0,1]]\n<b>输出：</b>4\n<b>解释：</b>你可以按照上图方式重新排列矩阵的每一列。\n最大的全 1 子矩阵是上图中加粗的部分，面积为 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/17/screenshot-2020-12-30-at-40852-pm.png\" style=\"width: 500px; height: 62px;\" /></p>\n\n<pre>\n<b>输入：</b>matrix = [[1,0,1,0,1]]\n<b>输出：</b>3\n<b>解释：</b>你可以按照上图方式重新排列矩阵的每一列。\n最大的全 1 子矩阵是上图中加粗的部分，面积为 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>matrix = [[1,1,0],[1,0,1]]\n<b>输出：</b>2\n<b>解释：</b>由于你只能整列整列重新排布，所以没有比面积为 2 更大的全 1 子矩形。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>matrix = [[0,0],[0,0]]\n<b>输出：</b>0\n<b>解释：</b>由于矩阵中没有 1 ，没有任何全 1 的子矩阵，所以面积为 0 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 <= m * n <= 10<sup>5</sup></code></li>\n\t<li><code>matrix[i][j]</code> 要么是 <code>0</code> ，要么是 <code>1</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1728猫和老鼠 II",
        "hardRate": "HARD",
        "passRate": "64.11%",
        "problemsUrl": "https://leetcode.cn/problems/cat-and-mouse-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/cat-and-mouse-ii/solution",
        "problemsDesc": "<p>一只猫和一只老鼠在玩一个叫做猫和老鼠的游戏。</p>\n\n<p>它们所处的环境设定是一个 <code>rows x cols</code> 的方格 <code>grid</code> ，其中每个格子可能是一堵墙、一块地板、一位玩家（猫或者老鼠）或者食物。</p>\n\n<ul>\n\t<li>玩家由字符 <code>'C'</code> （代表猫）和 <code>'M'</code> （代表老鼠）表示。</li>\n\t<li>地板由字符 <code>'.'</code> 表示，玩家可以通过这个格子。</li>\n\t<li>墙用字符 <code>'#'</code> 表示，玩家不能通过这个格子。</li>\n\t<li>食物用字符 <code>'F'</code> 表示，玩家可以通过这个格子。</li>\n\t<li>字符 <code>'C'</code> ， <code>'M'</code> 和 <code>'F'</code> 在 <code>grid</code> 中都只会出现一次。</li>\n</ul>\n\n<p>猫和老鼠按照如下规则移动：</p>\n\n<ul>\n\t<li>老鼠 <strong>先移动</strong> ，然后两名玩家轮流移动。</li>\n\t<li>每一次操作时，猫和老鼠可以跳到上下左右四个方向之一的格子，他们不能跳过墙也不能跳出 <code>grid</code> 。</li>\n\t<li><code>catJump</code> 和 <code>mouseJump</code> 是猫和老鼠分别跳一次能到达的最远距离，它们也可以跳小于最大距离的长度。</li>\n\t<li>它们可以停留在原地。</li>\n\t<li>老鼠可以跳跃过猫的位置。</li>\n</ul>\n\n<p>游戏有 4 种方式会结束：</p>\n\n<ul>\n\t<li>如果猫跟老鼠处在相同的位置，那么猫获胜。</li>\n\t<li>如果猫先到达食物，那么猫获胜。</li>\n\t<li>如果老鼠先到达食物，那么老鼠获胜。</li>\n\t<li>如果老鼠不能在 1000 次操作以内到达食物，那么猫获胜。</li>\n</ul>\n\n<p>给你 <code>rows x cols</code> 的矩阵 <code>grid</code> 和两个整数 <code>catJump</code> 和 <code>mouseJump</code> ，双方都采取最优策略，如果老鼠获胜，那么请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/17/sample_111_1955.png\" style=\"width: 580px; height: 239px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>grid = [\"####F\",\"#C...\",\"M....\"], catJump = 1, mouseJump = 2\n<b>输出：</b>true\n<b>解释：</b>猫无法抓到老鼠，也没法比老鼠先到达食物。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/17/sample_2_1955.png\" style=\"width: 580px; height: 175px;\" /></p>\n\n<pre>\n<b>输入：</b>grid = [\"M.C...F\"], catJump = 1, mouseJump = 4\n<b>输出：</b>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>grid = [\"M.C...F\"], catJump = 1, mouseJump = 3\n<b>输出：</b>false\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>grid = [\"C...#\",\"...#F\",\"....#\",\"M....\"], catJump = 2, mouseJump = 5\n<b>输出：</b>false\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<b>输入：</b>grid = [\".M...\",\"..#..\",\"#..#.\",\"C#.#.\",\"...#F\"], catJump = 3, mouseJump = 1\n<b>输出：</b>true\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rows == grid.length</code></li>\n\t<li><code>cols = grid[i].length</code></li>\n\t<li><code>1 <= rows, cols <= 8</code></li>\n\t<li><code>grid[i][j]</code> 只包含字符 <code>'C'</code> ，<code>'M'</code> ，<code>'F'</code> ，<code>'.'</code> 和 <code>'#'</code> 。</li>\n\t<li><code>grid</code> 中只包含一个 <code>'C'</code> ，<code>'M'</code> 和 <code>'F'</code> 。</li>\n\t<li><code>1 <= catJump, mouseJump <= 8</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1729求关注者的数量",
        "hardRate": "EASY",
        "passRate": "61.52%",
        "problemsUrl": "https://leetcode.cn/problems/find-followers-count/",
        "solutionsUrl": "https://leetcode.cn/problems/find-followers-count/solution",
        "problemsDesc": "<p>表：&nbsp;<code>Followers</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| user_id     | int  |\n| follower_id | int  |\n+-------------+------+\n(user_id, follower_id) 是这个表的主键。\n该表包含一个关注关系中关注者和用户的编号，其中关注者关注用户。</pre>\n\n<p>&nbsp;</p>\n\n<p>写出 SQL 语句，对于每一个用户，返回该用户的关注者数量。</p>\n\n<p>按&nbsp;<code>user_id</code>&nbsp;的顺序返回结果表。</p>\n\n<p>查询结果的格式如下示例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nFollowers 表：\n+---------+-------------+\n| user_id | follower_id |\n+---------+-------------+\n| 0       | 1           |\n| 1       | 0           |\n| 2       | 0           |\n| 2       | 1           |\n+---------+-------------+\n<strong>输出：</strong>\n+---------+----------------+\n| user_id | followers_count|\n+---------+----------------+\n| 0       | 1              |\n| 1       | 1              |\n| 2       | 2              |\n+---------+----------------+\n<strong>解释：</strong>\n0 的关注者有 {1}\n1 的关注者有 {0}\n2 的关注者有 {0,1}</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1730获取食物的最短路径",
        "hardRate": "MEDIUM",
        "passRate": "52.74%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-path-to-get-food/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-path-to-get-food/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1731每位经理的下属员工数量",
        "hardRate": "EASY",
        "passRate": "46.98%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-employees-which-report-to-each-employee/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-employees-which-report-to-each-employee/solution",
        "problemsDesc": "<p>Table: <code>Employees</code></p>\n\n<pre>+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| employee_id | int      |\n| name        | varchar  |\n| reports_to  | int      |\n| age         | int      |\n+-------------+----------+\nemployee_id 是这个表的主键.\n该表包含员工以及需要听取他们汇报的上级经理的ID的信息。 有些员工不需要向任何人汇报（reports_to 为空）。\n</pre>\n\n<p> </p>\n\n<p>对于此问题，我们将至少有一个其他员工需要向他汇报的员工，视为一个经理。</p>\n\n<p>编写SQL查询需要听取汇报的所有经理的ID、名称、直接向该经理汇报的员工人数，以及这些员工的平均年龄，其中该平均年龄需要四舍五入到最接近的整数。</p>\n\n<p>返回的结果集需要按照 <code>employee_id </code>进行排序。</p>\n\n<p>查询结果的格式如下：</p>\n\n<p> </p>\n\n<pre>Employees table:\n+-------------+---------+------------+-----+\n| employee_id | name    | reports_to | age |\n+-------------+---------+------------+-----+\n| 9           | Hercy   | null       | 43  |\n| 6           | Alice   | 9          | 41  |\n| 4           | Bob     | 9          | 36  |\n| 2           | Winston | null       | 37  |\n+-------------+---------+------------+-----+\n\nResult table:\n+-------------+-------+---------------+-------------+\n| employee_id | name  | reports_count | average_age |\n+-------------+-------+---------------+-------------+\n| 9           | Hercy | 2             | 39          |\n+-------------+-------+---------------+-------------+\nHercy 有两个需要向他汇报的员工, 他们是 Alice and Bob. 他们的平均年龄是 (41+36)/2 = 38.5, 四舍五入的结果是 39.\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1732找到最高海拔",
        "hardRate": "EASY",
        "passRate": "81.27%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-highest-altitude/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-highest-altitude/solution",
        "problemsDesc": "<p>有一个自行车手打算进行一场公路骑行，这条路线总共由 <code>n + 1</code> 个不同海拔的点组成。自行车手从海拔为 <code>0</code> 的点 <code>0</code> 开始骑行。</p>\n\n<p>给你一个长度为 <code>n</code> 的整数数组 <code>gain</code> ，其中 <code>gain[i]</code> 是点 <code>i</code> 和点 <code>i + 1</code> 的 <strong>净海拔高度差</strong>（<code>0 <= i < n</code>）。请你返回 <strong>最高点的海拔</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>gain = [-5,1,5,0,-7]\n<b>输出：</b>1\n<b>解释：</b>海拔高度依次为 [0,-5,-4,1,1,-6] 。最高海拔为 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>gain = [-4,-3,-2,-1,4,3,2]\n<b>输出：</b>0\n<b>解释：</b>海拔高度依次为 [0,-4,-7,-9,-10,-6,-3,-1] 。最高海拔为 0 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == gain.length</code></li>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>-100 <= gain[i] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1733需要教语言的最少人数",
        "hardRate": "MEDIUM",
        "passRate": "48.58%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-people-to-teach/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-people-to-teach/solution",
        "problemsDesc": "<p>在一个由 <code>m</code> 个用户组成的社交网络里，我们获取到一些用户之间的好友关系。两个用户之间可以相互沟通的条件是他们都掌握同一门语言。</p>\n\n<p>给你一个整数 <code>n</code> ，数组 <code>languages</code> 和数组 <code>friendships</code> ，它们的含义如下：</p>\n\n<ul>\n\t<li>总共有 <code>n</code> 种语言，编号从 <code>1</code> 到 <code>n</code> 。</li>\n\t<li><code>languages[i]</code> 是第 <code>i</code> 位用户掌握的语言集合。</li>\n\t<li><code>friendships[i] = [u<sub>​​​​​​i</sub>​​​, v<sub>​​​​​​i</sub>]</code> 表示 <code>u<sup>​​​​​</sup><sub>​​​​​​i</sub></code>​​​​​ 和 <code>v<sub>i</sub></code> 为好友关系。</li>\n</ul>\n\n<p>你可以选择 <strong>一门</strong> 语言并教会一些用户，使得所有好友之间都可以相互沟通。请返回你 <strong>最少</strong> 需要教会多少名用户。</p>\n请注意，好友关系没有传递性，也就是说如果 <code>x</code> 和 <code>y</code> 是好友，且 <code>y</code> 和 <code>z</code> 是好友， <code>x</code> 和 <code>z</code> 不一定是好友。\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 2, languages = [[1],[2],[1,2]], friendships = [[1,2],[1,3],[2,3]]\n<b>输出：</b>1\n<b>解释：</b>你可以选择教用户 1 第二门语言，也可以选择教用户 2 第一门语言。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, languages = [[2],[1,3],[1,2],[3]], friendships = [[1,4],[1,2],[3,4],[2,3]]\n<b>输出：</b>2\n<b>解释：</b>教用户 1 和用户 3 第三门语言，需要教 2 名用户。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 500</code></li>\n\t<li><code>languages.length == m</code></li>\n\t<li><code>1 <= m <= 500</code></li>\n\t<li><code>1 <= languages[i].length <= n</code></li>\n\t<li><code>1 <= languages[i][j] <= n</code></li>\n\t<li><code>1 <= u<sub>​​​​​​i</sub> < v<sub>​​​​​​i</sub> <= languages.length</code></li>\n\t<li><code>1 <= friendships.length <= 500</code></li>\n\t<li>所有的好友关系 <code>(u<sub>​​​​​i, </sub>v<sub>​​​​​​i</sub>)</code> 都是唯一的。</li>\n\t<li><code>languages[i]</code> 中包含的值互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1734解码异或后的排列",
        "hardRate": "MEDIUM",
        "passRate": "72.44%",
        "problemsUrl": "https://leetcode.cn/problems/decode-xored-permutation/",
        "solutionsUrl": "https://leetcode.cn/problems/decode-xored-permutation/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>perm</code> ，它是前 <code>n</code> 个正整数的排列，且 <code>n</code> 是个 <strong>奇数</strong> 。</p>\n\n<p>它被加密成另一个长度为 <code>n - 1</code> 的整数数组 <code>encoded</code> ，满足 <code>encoded[i] = perm[i] XOR perm[i + 1]</code> 。比方说，如果 <code>perm = [1,3,2]</code> ，那么 <code>encoded = [2,1]</code> 。</p>\n\n<p>给你 <code>encoded</code> 数组，请你返回原始数组 <code>perm</code> 。题目保证答案存在且唯一。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>encoded = [3,1]\n<b>输出：</b>[1,2,3]\n<b>解释：</b>如果 perm = [1,2,3] ，那么 encoded = [1 XOR 2,2 XOR 3] = [3,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>encoded = [6,5,4,6]\n<b>输出：</b>[2,4,1,5,3]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt; 10<sup>5</sup></code></li>\n\t<li><code>n</code> 是奇数。</li>\n\t<li><code>encoded.length == n - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1735生成乘积数组的方案数",
        "hardRate": "HARD",
        "passRate": "52.24%",
        "problemsUrl": "https://leetcode.cn/problems/count-ways-to-make-array-with-product/",
        "solutionsUrl": "https://leetcode.cn/problems/count-ways-to-make-array-with-product/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>queries</code> ，其中 <code>queries[i] = [n<sub>i</sub>, k<sub>i</sub>]</code> 。第 <code>i</code> 个查询 <code>queries[i]</code> 要求构造长度为 <code>n<sub>i</sub></code> 、每个元素都是正整数的数组，且满足所有元素的乘积为 <code>k<sub>i</sub></code><sub> </sub>，请你找出有多少种可行的方案。由于答案可能会很大，方案数需要对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 。</p>\n\n<p>请你返回一个整数数组<em> </em><code>answer</code>，满足<em> </em><code>answer.length == queries.length</code> ，其中<em> </em><code>answer[i]</code>是第<em> </em><code>i</code> 个查询的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>queries = [[2,6],[5,1],[73,660]]\n<b>输出：</b>[4,1,50734910]\n<b>解释：</b>每个查询之间彼此独立。\n[2,6]：总共有 4 种方案得到长度为 2 且乘积为 6 的数组：[1,6]，[2,3]，[3,2]，[6,1]。\n[5,1]：总共有 1 种方案得到长度为 5 且乘积为 1 的数组：[1,1,1,1,1]。\n[73,660]：总共有 1050734917 种方案得到长度为 73 且乘积为 660 的数组。1050734917 对 10<sup>9</sup> + 7 取余得到 50734910 。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre>\n<b>输入：</b>queries = [[1,1],[2,2],[3,3],[4,4],[5,5]]\n<b>输出：</b>[1,2,3,10,5]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= queries.length <= 10<sup>4</sup> </code></li>\n\t<li><code>1 <= n<sub>i</sub>, k<sub>i</sub> <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1736替换隐藏数字得到的最晚时间",
        "hardRate": "EASY",
        "passRate": "44.46%",
        "problemsUrl": "https://leetcode.cn/problems/latest-time-by-replacing-hidden-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/latest-time-by-replacing-hidden-digits/solution",
        "problemsDesc": "<p>给你一个字符串 <code>time</code> ，格式为 <code> hh:mm</code>（小时：分钟），其中某几位数字被隐藏（用 <code>?</code> 表示）。</p>\n\n<p>有效的时间为 <code>00:00</code> 到 <code>23:59</code> 之间的所有时间，包括 <code>00:00</code> 和 <code>23:59</code> 。</p>\n\n<p>替换 <code>time</code> 中隐藏的数字，返回你可以得到的最晚有效时间。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>time = \"2?:?0\"\n<strong>输出：</strong>\"23:50\"\n<strong>解释：</strong>以数字 '2' 开头的最晚一小时是 23 ，以 '0' 结尾的最晚一分钟是 50 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>time = \"0?:3?\"\n<strong>输出：</strong>\"09:39\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>time = \"1?:22\"\n<strong>输出：</strong>\"19:22\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>time</code> 的格式为 <code>hh:mm</code></li>\n\t<li>题目数据保证你可以由输入的字符串生成有效的时间</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1737满足三条件之一需改变的最少字符数",
        "hardRate": "MEDIUM",
        "passRate": "35.79%",
        "problemsUrl": "https://leetcode.cn/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/",
        "solutionsUrl": "https://leetcode.cn/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/solution",
        "problemsDesc": "<p>给你两个字符串 <code>a</code> 和 <code>b</code> ，二者均由小写字母组成。一步操作中，你可以将 <code>a</code> 或 <code>b</code> 中的 <strong>任一字符</strong> 改变为 <strong>任一小写字母</strong> 。</p>\n\n<p>操作的最终目标是满足下列三个条件 <strong>之一</strong> ：</p>\n\n<ul>\n\t<li><code>a</code> 中的 <strong>每个字母</strong> 在字母表中 <strong>严格小于</strong> <code>b</code> 中的 <strong>每个字母</strong> 。</li>\n\t<li><code>b</code> 中的 <strong>每个字母</strong> 在字母表中 <strong>严格小于</strong> <code>a</code> 中的 <strong>每个字母</strong> 。</li>\n\t<li><code>a</code> 和 <code>b</code> <strong>都</strong> 由 <strong>同一个</strong> 字母组成。</li>\n</ul>\n\n<p>返回达成目标所需的 <strong>最少</strong> 操作数<em>。</em></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>a = \"aba\", b = \"caa\"\n<strong>输出：</strong>2\n<strong>解释：</strong>满足每个条件的最佳方案分别是：\n1) 将 b 变为 \"ccc\"，2 次操作，满足 a 中的每个字母都小于 b 中的每个字母；\n2) 将 a 变为 \"bbb\" 并将 b 变为 \"aaa\"，3 次操作，满足 b 中的每个字母都小于 a 中的每个字母；\n3) 将 a 变为 \"aaa\" 并将 b 变为 \"aaa\"，2 次操作，满足 a 和 b 由同一个字母组成。\n最佳的方案只需要 2 次操作（满足条件 1 或者条件 3）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>a = \"dabadd\", b = \"cda\"\n<strong>输出：</strong>3\n<strong>解释：</strong>满足条件 1 的最佳方案是将 b 变为 \"eee\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>a</code> 和 <code>b</code> 只由小写字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1738找出第 K 大的异或坐标值",
        "hardRate": "MEDIUM",
        "passRate": "65.12%",
        "problemsUrl": "https://leetcode.cn/problems/find-kth-largest-xor-coordinate-value/",
        "solutionsUrl": "https://leetcode.cn/problems/find-kth-largest-xor-coordinate-value/solution",
        "problemsDesc": "<p>给你一个二维矩阵 <code>matrix</code> 和一个整数 <code>k</code> ，矩阵大小为 <code>m x n</code> 由非负整数组成。</p>\n\n<p>矩阵中坐标 <code>(a, b)</code> 的 <strong>值</strong> 可由对所有满足 <code>0 &lt;= i &lt;= a &lt; m</code> 且 <code>0 &lt;= j &lt;= b &lt; n</code> 的元素 <code>matrix[i][j]</code>（<strong>下标从 0 开始计数</strong>）执行异或运算得到。</p>\n\n<p>请你找出 <code>matrix</code> 的所有坐标中第 <code>k</code> 大的值（<strong><code>k</code> 的值从 1 开始计数</strong>）。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>matrix = [[5,2],[1,6]], k = 1\n<strong>输出：</strong>7\n<strong>解释：</strong>坐标 (0,1) 的值是 5 XOR 2 = 7 ，为最大的值。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>matrix = [[5,2],[1,6]], k = 2\n<strong>输出：</strong>5\n<strong>解释：</strong>坐标 (0,0) 的值是 5 = 5 ，为第 2 大的值。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>matrix = [[5,2],[1,6]], k = 3\n<strong>输出：</strong>4\n<strong>解释：</strong>坐标 (1,0) 的值是 5 XOR 1 = 4 ，为第 3 大的值。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>matrix = [[5,2],[1,6]], k = 4\n<strong>输出：</strong>0\n<strong>解释：</strong>坐标 (1,1) 的值是 5 XOR 2 XOR 1 XOR 6 = 0 ，为第 4 大的值。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= matrix[i][j] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= m * n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1739放置盒子",
        "hardRate": "HARD",
        "passRate": "64.36%",
        "problemsUrl": "https://leetcode.cn/problems/building-boxes/",
        "solutionsUrl": "https://leetcode.cn/problems/building-boxes/solution",
        "problemsDesc": "<p>有一个立方体房间，其长度、宽度和高度都等于 <code>n</code> 个单位。请你在房间里放置 <code>n</code> 个盒子，每个盒子都是一个单位边长的立方体。放置规则如下：</p>\n\n<ul>\n\t<li>你可以把盒子放在地板上的任何地方。</li>\n\t<li>如果盒子 <code>x</code> 需要放置在盒子 <code>y</code> 的顶部，那么盒子 <code>y</code> 竖直的四个侧面都 <strong>必须</strong> 与另一个盒子或墙相邻。</li>\n</ul>\n\n<p>给你一个整数 <code>n</code> ，返回接触地面的盒子的 <strong>最少</strong> 可能数量<em>。</em></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/24/3-boxes.png\" style=\"width: 135px; height: 143px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>上图是 3 个盒子的摆放位置。\n这些盒子放在房间的一角，对应左侧位置。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/24/4-boxes.png\" style=\"width: 135px; height: 179px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>上图是 3 个盒子的摆放位置。\n这些盒子放在房间的一角，对应左侧位置。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/24/10-boxes.png\" style=\"width: 271px; height: 257px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 10\n<strong>输出：</strong>6\n<strong>解释：</strong>上图是 10 个盒子的摆放位置。\n这些盒子放在房间的一角，对应后方位置。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1740找到二叉树中的距离",
        "hardRate": "MEDIUM",
        "passRate": "67.01%",
        "problemsUrl": "https://leetcode.cn/problems/find-distance-in-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/find-distance-in-a-binary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1741查找每个员工花费的总时间",
        "hardRate": "EASY",
        "passRate": "84.56%",
        "problemsUrl": "https://leetcode.cn/problems/find-total-time-spent-by-each-employee/",
        "solutionsUrl": "https://leetcode.cn/problems/find-total-time-spent-by-each-employee/solution",
        "problemsDesc": "<p>表: <code>Employees</code></p>\n\n<pre>+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| emp_id      | int  |\n| event_day   | date |\n| in_time     | int  |\n| out_time    | int  |\n+-------------+------+\n(emp_id, event_day, in_time) 是这个表的主键。\n该表显示了员工在办公室的出入情况。\nevent_day 是此事件发生的日期，in_time 是员工进入办公室的时间，而 out_time 是他们离开办公室的时间。\nin_time 和 out_time 的取值在1到1440之间。\n题目保证同一天没有两个事件在时间上是相交的，并且保证 in_time 小于 out_time。\n</pre>\n\n<p> </p>\n\n<p>编写一个SQL查询以计算每位员工每天在办公室花费的总时间（以分钟为单位）。 请注意，在一天之内，同一员工是可以多次进入和离开办公室的。 在办公室里一次进出所花费的时间为out_time 减去 in_time。</p>\n\n<p>返回结果表单的顺序无要求。<br>\n查询结果的格式如下：</p>\n\n<pre>Employees table:\n+--------+------------+---------+----------+\n| emp_id | event_day  | in_time | out_time |\n+--------+------------+---------+----------+\n| 1      | 2020-11-28 | 4       | 32       |\n| 1      | 2020-11-28 | 55      | 200      |\n| 1      | 2020-12-03 | 1       | 42       |\n| 2      | 2020-11-28 | 3       | 33       |\n| 2      | 2020-12-09 | 47      | 74       |\n+--------+------------+---------+----------+\nResult table:\n+------------+--------+------------+\n| day        | emp_id | total_time |\n+------------+--------+------------+\n| 2020-11-28 | 1      | 173        |\n| 2020-11-28 | 2      | 30         |\n| 2020-12-03 | 1      | 41         |\n| 2020-12-09 | 2      | 27         |\n+------------+--------+------------+\n雇员 1 有三次进出: 有两次发生在 2020-11-28 花费的时间为 (32 - 4) + (200 - 55) = 173, 有一次发生在 2020-12-03 花费的时间为 (42 - 1) = 41。\n雇员 2 有两次进出: 有一次发生在 2020-11-28 花费的时间为 (33 - 3) = 30,  有一次发生在 2020-12-09 花费的时间为 (74 - 47) = 27。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1742盒子中小球的最大数量",
        "hardRate": "EASY",
        "passRate": "75.78%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-balls-in-a-box/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-balls-in-a-box/solution",
        "problemsDesc": "<p>你在一家生产小球的玩具厂工作，有 <code>n</code> 个小球，编号从 <code>lowLimit</code> 开始，到 <code>highLimit</code> 结束（包括 <code>lowLimit</code> 和 <code>highLimit</code> ，即 <code>n == highLimit - lowLimit + 1</code>）。另有无限数量的盒子，编号从 <code>1</code> 到 <code>infinity</code> 。</p>\n\n<p>你的工作是将每个小球放入盒子中，其中盒子的编号应当等于小球编号上每位数字的和。例如，编号 <code>321</code> 的小球应当放入编号 <code>3 + 2 + 1 = 6</code> 的盒子，而编号 <code>10</code> 的小球应当放入编号 <code>1 + 0 = 1</code> 的盒子。</p>\n\n<p>给你两个整数 <code>lowLimit</code> 和 <code>highLimit</code> ，返回放有最多小球的盒子中的小球数量<em>。</em>如果有多个盒子都满足放有最多小球，只需返回其中任一盒子的小球数量。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>lowLimit = 1, highLimit = 10\n<strong>输出：</strong>2\n<strong>解释：</strong>\n盒子编号：1 2 3 4 5 6 7 8 9 10 11 ...\n小球数量：2 1 1 1 1 1 1 1 1 0  0  ...\n编号 1 的盒子放有最多小球，小球数量为 2 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>lowLimit = 5, highLimit = 15\n<strong>输出：</strong>2\n<strong>解释：</strong>\n盒子编号：1 2 3 4 5 6 7 8 9 10 11 ...\n小球数量：1 1 1 1 2 2 1 1 1 0  0  ...\n编号 5 和 6 的盒子放有最多小球，每个盒子中的小球数量都是 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>lowLimit = 19, highLimit = 28\n<strong>输出：</strong>2\n<strong>解释：</strong>\n盒子编号：1 2 3 4 5 6 7 8 9 10 11 12 ...\n小球数量：0 1 1 1 1 1 1 1 1 2  0  0  ...\n编号 10 的盒子放有最多小球，小球数量为 2 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= lowLimit <= highLimit <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1743从相邻元素对还原数组",
        "hardRate": "MEDIUM",
        "passRate": "69.58%",
        "problemsUrl": "https://leetcode.cn/problems/restore-the-array-from-adjacent-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/restore-the-array-from-adjacent-pairs/solution",
        "problemsDesc": "<p>存在一个由 <code>n</code> 个不同元素组成的整数数组 <code>nums</code> ，但你已经记不清具体内容。好在你还记得 <code>nums</code> 中的每一对相邻元素。</p>\n\n<p>给你一个二维整数数组 <code>adjacentPairs</code> ，大小为 <code>n - 1</code> ，其中每个 <code>adjacentPairs[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> 表示元素 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code> 在 <code>nums</code> 中相邻。</p>\n\n<p>题目数据保证所有由元素 <code>nums[i]</code> 和 <code>nums[i+1]</code> 组成的相邻元素对都存在于 <code>adjacentPairs</code> 中，存在形式可能是 <code>[nums[i], nums[i+1]]</code> ，也可能是 <code>[nums[i+1], nums[i]]</code> 。这些相邻元素对可以 <strong>按任意顺序</strong> 出现。</p>\n\n<p>返回 <strong>原始数组</strong><em> </em><code>nums</code><em> </em>。如果存在多种解答，返回 <strong>其中任意一个</strong> 即可。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>adjacentPairs = [[2,1],[3,4],[3,2]]\n<strong>输出：</strong>[1,2,3,4]\n<strong>解释：</strong>数组的所有相邻元素对都在 adjacentPairs 中。\n特别要注意的是，adjacentPairs[i] 只表示两个元素相邻，并不保证其 左-右 顺序。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>adjacentPairs = [[4,-2],[1,4],[-3,1]]\n<strong>输出：</strong>[-2,4,1,-3]\n<strong>解释：</strong>数组中可能存在负数。\n另一种解答是 [-3,1,4,-2] ，也会被视作正确答案。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>adjacentPairs = [[100000,-100000]]\n<strong>输出：</strong>[100000,-100000]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length == n</code></li>\n\t<li><code>adjacentPairs.length == n - 1</code></li>\n\t<li><code>adjacentPairs[i].length == 2</code></li>\n\t<li><code>2 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> <= nums[i], u<sub>i</sub>, v<sub>i</sub> <= 10<sup>5</sup></code></li>\n\t<li>题目数据保证存在一些以 <code>adjacentPairs</code> 作为元素对的数组 <code>nums</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1744你能在你最喜欢的那天吃到你最喜欢的糖果吗？",
        "hardRate": "MEDIUM",
        "passRate": "36.37%",
        "problemsUrl": "https://leetcode.cn/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/",
        "solutionsUrl": "https://leetcode.cn/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的正整数数组 <code>candiesCount</code> ，其中 <code>candiesCount[i]</code> 表示你拥有的第 <code>i</code> 类糖果的数目。同时给你一个二维数组 <code>queries</code> ，其中 <code>queries[i] = [favoriteType<sub>i</sub>, favoriteDay<sub>i</sub>, dailyCap<sub>i</sub>]</code> 。</p>\n\n<p>你按照如下规则进行一场游戏：</p>\n\n<ul>\n\t<li>你从第 <code><strong>0</strong></code><strong> </strong>天开始吃糖果。</li>\n\t<li>你在吃完 <strong>所有</strong> 第 <code>i - 1</code> 类糖果之前，<strong>不能</strong> 吃任何一颗第 <code>i</code> 类糖果。</li>\n\t<li>在吃完所有糖果之前，你必须每天 <strong>至少</strong> 吃 <strong>一颗</strong> 糖果。</li>\n</ul>\n\n<p>请你构建一个布尔型数组 <code>answer</code> ，用以给出 <code>queries</code> 中每一项的对应答案。此数组满足：</p>\n\n<ul>\n\t<li><code>answer.length == queries.length</code> 。<code>answer[i]</code> 是 <code>queries[i]</code> 的答案。</li>\n\t<li><code>answer[i]</code> 为 <code>true</code> 的条件是：在每天吃 <strong>不超过</strong> <code>dailyCap<sub>i</sub></code><sub> </sub>颗糖果的前提下，你可以在第 <code>favoriteDay<sub>i</sub></code> 天吃到第 <code>favoriteType<sub>i</sub></code> 类糖果；否则 <code>answer[i]</code> 为 <code>false</code> 。</li>\n</ul>\n\n<p>注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。</p>\n\n<p>请你返回得到的数组<em> </em><code>answer</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]\n<b>输出：</b>[true,false,true]\n<strong>提示：</strong>\n1- 在第 0 天吃 2 颗糖果(类型 0），第 1 天吃 2 颗糖果（类型 0），第 2 天你可以吃到类型 0 的糖果。\n2- 每天你最多吃 4 颗糖果。即使第 0 天吃 4 颗糖果（类型 0），第 1 天吃 4 颗糖果（类型 0 和类型 1），你也没办法在第 2 天吃到类型 4 的糖果。换言之，你没法在每天吃 4 颗糖果的限制下在第 2 天吃到第 4 类糖果。\n3- 如果你每天吃 1 颗糖果，你可以在第 13 天吃到类型 2 的糖果。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]\n<b>输出：</b>[false,true,true,false,false]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= candiesCount.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= candiesCount[i] <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= queries.length <= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length == 3</code></li>\n\t<li><code>0 <= favoriteType<sub>i</sub> < candiesCount.length</code></li>\n\t<li><code>0 <= favoriteDay<sub>i</sub> <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= dailyCap<sub>i</sub> <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1745回文串分割 IV",
        "hardRate": "HARD",
        "passRate": "50.55%",
        "problemsUrl": "https://leetcode.cn/problems/palindrome-partitioning-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/palindrome-partitioning-iv/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，如果可以将它分割成三个 <strong>非空</strong> 回文子字符串，那么返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p>当一个字符串正着读和反着读是一模一样的，就称其为 <strong>回文字符串</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"abcbdd\"\n<b>输出：</b>true\n<strong>解释：</strong>\"abcbdd\" = \"a\" + \"bcb\" + \"dd\"，三个子字符串都是回文的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"bcbddxy\"\n<b>输出：</b>false\n<strong>解释：</strong>s 没办法被分割成 3 个回文子字符串。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 <= s.length <= 2000</code></li>\n\t<li><code>s</code>​​​​​​ 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1746经过一次操作后的最大子数组和",
        "hardRate": "MEDIUM",
        "passRate": "60.64%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-subarray-sum-after-one-operation/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-subarray-sum-after-one-operation/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1747应该被禁止的 Leetflex 账户",
        "hardRate": "MEDIUM",
        "passRate": "65.58%",
        "problemsUrl": "https://leetcode.cn/problems/leetflex-banned-accounts/",
        "solutionsUrl": "https://leetcode.cn/problems/leetflex-banned-accounts/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1748唯一元素的和",
        "hardRate": "EASY",
        "passRate": "76.81%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-unique-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-unique-elements/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。数组中唯一元素是那些只出现 <strong>恰好一次</strong> 的元素。</p>\n\n<p>请你返回 <code>nums</code> 中唯一元素的 <strong>和</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,2]\n<b>输出：</b>4\n<b>解释：</b>唯一元素为 [1,3] ，和为 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,1,1,1,1]\n<b>输出：</b>0\n<b>解释：</b>没有唯一元素，和为 0 。\n</pre>\n\n<p><strong>示例 3 ：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4,5]\n<b>输出：</b>15\n<b>解释：</b>唯一元素为 [1,2,3,4,5] ，和为 15 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1749任意子数组和的绝对值的最大值",
        "hardRate": "MEDIUM",
        "passRate": "54.51%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-absolute-sum-of-any-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-absolute-sum-of-any-subarray/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。一个子数组 <code>[nums<sub>l</sub>, nums<sub>l+1</sub>, ..., nums<sub>r-1</sub>, nums<sub>r</sub>]</code> 的 <strong>和的绝对值</strong> 为 <code>abs(nums<sub>l</sub> + nums<sub>l+1</sub> + ... + nums<sub>r-1</sub> + nums<sub>r</sub>)</code> 。</p>\n\n<p>请你找出 <code>nums</code> 中 <strong>和的绝对值</strong> 最大的任意子数组（<b>可能为空</b>），并返回该 <strong>最大值</strong> 。</p>\n\n<p><code>abs(x)</code> 定义如下：</p>\n\n<ul>\n\t<li>如果 <code>x</code> 是负整数，那么 <code>abs(x) = -x</code> 。</li>\n\t<li>如果 <code>x</code> 是非负整数，那么 <code>abs(x) = x</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,-3,2,3,-4]\n<b>输出：</b>5\n<b>解释：</b>子数组 [2,3] 和的绝对值最大，为 abs(2+3) = abs(5) = 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,-5,1,-4,3,-2]\n<b>输出：</b>8\n<b>解释：</b>子数组 [-5,1,-4] 和的绝对值最大，为 abs(-5+1-4) = abs(-8) = 8 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1750删除字符串两端相同字符后的最短长度",
        "hardRate": "MEDIUM",
        "passRate": "50.64%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-length-of-string-after-deleting-similar-ends/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-length-of-string-after-deleting-similar-ends/solution",
        "problemsDesc": "<p>给你一个只包含字符 <code>'a'</code>，<code>'b'</code> 和 <code>'c'</code> 的字符串 <code>s</code> ，你可以执行下面这个操作（5 个步骤）任意次：</p>\n\n<ol>\n\t<li>选择字符串 <code>s</code> 一个 <strong>非空</strong> 的前缀，这个前缀的所有字符都相同。</li>\n\t<li>选择字符串 <code>s</code> 一个 <strong>非空</strong> 的后缀，这个后缀的所有字符都相同。</li>\n\t<li>前缀和后缀在字符串中任意位置都不能有交集。</li>\n\t<li>前缀和后缀包含的所有字符都要相同。</li>\n\t<li>同时删除前缀和后缀。</li>\n</ol>\n\n<p>请你返回对字符串 <code>s</code> 执行上面操作任意次以后（可能 0 次），能得到的 <strong>最短长度</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"ca\"\n<b>输出：</b>2\n<strong>解释：</strong>你没法删除任何一个字符，所以字符串长度仍然保持不变。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"cabaabac\"\n<b>输出：</b>0\n<b>解释：</b>最优操作序列为：\n- 选择前缀 \"c\" 和后缀 \"c\" 并删除它们，得到 s = \"abaaba\" 。\n- 选择前缀 \"a\" 和后缀 \"a\" 并删除它们，得到 s = \"baab\" 。\n- 选择前缀 \"b\" 和后缀 \"b\" 并删除它们，得到 s = \"aa\" 。\n- 选择前缀 \"a\" 和后缀 \"a\" 并删除它们，得到 s = \"\" 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aabccabba\"\n<b>输出：</b>3\n<b>解释：</b>最优操作序列为：\n- 选择前缀 \"aa\" 和后缀 \"a\" 并删除它们，得到 s = \"bccabb\" 。\n- 选择前缀 \"b\" 和后缀 \"bb\" 并删除它们，得到 s = \"cca\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 只包含字符 <code>'a'</code>，<code>'b'</code> 和 <code>'c'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1751最多可以参加的会议数目 II",
        "hardRate": "HARD",
        "passRate": "54.20%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended-ii/solution",
        "problemsDesc": "<p>给你一个 <code>events</code> 数组，其中 <code>events[i] = [startDay<sub>i</sub>, endDay<sub>i</sub>, value<sub>i</sub>]</code> ，表示第 <code>i</code> 个会议在 <code>startDay<sub>i</sub></code><sub> </sub>天开始，第 <code>endDay<sub>i</sub></code> 天结束，如果你参加这个会议，你能得到价值 <code>value<sub>i</sub></code> 。同时给你一个整数 <code>k</code> 表示你能参加的最多会议数目。</p>\n\n<p>你同一时间只能参加一个会议。如果你选择参加某个会议，那么你必须 <strong>完整</strong> 地参加完这个会议。会议结束日期是包含在会议内的，也就是说你不能同时参加一个开始日期与另一个结束日期相同的两个会议。</p>\n\n<p>请你返回能得到的会议价值 <strong>最大和</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/06/screenshot-2021-01-11-at-60048-pm.png\" style=\"width: 400px; height: 103px;\" /></p>\n\n<pre>\n<b>输入：</b>events = [[1,2,4],[3,4,3],[2,3,1]], k = 2\n<b>输出：</b>7\n<strong>解释：</strong>选择绿色的活动会议 0 和 1，得到总价值和为 4 + 3 = 7 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/06/screenshot-2021-01-11-at-60150-pm.png\" style=\"width: 400px; height: 103px;\" /></p>\n\n<pre>\n<b>输入：</b>events = [[1,2,4],[3,4,3],[2,3,10]], k = 2\n<b>输出：</b>10\n<b>解释：</b>参加会议 2 ，得到价值和为 10 。\n你没法再参加别的会议了，因为跟会议 2 有重叠。你 <strong>不</strong> 需要参加满 k 个会议。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/06/screenshot-2021-01-11-at-60703-pm.png\" style=\"width: 400px; height: 126px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3\n<b>输出：</b>9\n<b>解释：</b>尽管会议互不重叠，你只能参加 3 个会议，所以选择价值最大的 3 个会议。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= k <= events.length</code></li>\n\t<li><code>1 <= k * events.length <= 10<sup>6</sup></code></li>\n\t<li><code>1 <= startDay<sub>i</sub> <= endDay<sub>i</sub> <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= value<sub>i</sub> <= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1752检查数组是否经排序和轮转得到",
        "hardRate": "EASY",
        "passRate": "58.07%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-array-is-sorted-and-rotated/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-array-is-sorted-and-rotated/solution",
        "problemsDesc": "<p>给你一个数组 <code>nums</code> 。<code>nums</code> 的源数组中，所有元素与 <code>nums</code> 相同，但按非递减顺序排列。</p>\n\n<p>如果&nbsp;<code>nums</code> 能够由源数组轮转若干位置（包括 0 个位置）得到，则返回 <code>true</code><em> </em>；否则，返回 <code>false</code> 。</p>\n\n<p>源数组中可能存在 <strong>重复项</strong> 。</p>\n\n<p><strong>注意：</strong>我们称数组 <code>A</code> 在轮转 <code>x</code> 个位置后得到长度相同的数组 <code>B</code> ，当它们满足 <code>A[i] == B[(i+x) % A.length]</code> ，其中 <code>%</code> 为取余运算。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,5,1,2]\n<strong>输出：</strong>true\n<strong>解释：</strong>[1,2,3,4,5] 为有序的源数组。\n可以轮转 x = 3 个位置，使新数组从值为 3 的元素开始：[3,4,5,1,2] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,3,4]\n<strong>输出：</strong>false\n<strong>解释：</strong>源数组无法经轮转得到 nums 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>true\n<strong>解释：</strong>[1,2,3] 为有序的源数组。\n可以轮转 x = 0 个位置（即不轮转）得到 nums 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1753移除石子的最大得分",
        "hardRate": "MEDIUM",
        "passRate": "70.66%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-from-removing-stones/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-from-removing-stones/solution",
        "problemsDesc": "<p>你正在玩一个单人游戏，面前放置着大小分别为 <code>a</code>​​​​​​、<code>b</code> 和 <code>c</code>​​​​​​ 的 <strong>三堆</strong> 石子。</p>\n\n<p>每回合你都要从两个 <strong>不同的非空堆</strong> 中取出一颗石子，并在得分上加 <code>1</code> 分。当存在 <strong>两个或更多</strong> 的空堆时，游戏停止。</p>\n\n<p>给你三个整数 <code>a</code> 、<code>b</code> 和 <code>c</code> ，返回可以得到的 <strong>最大分数</strong> 。</p>\n \n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 2, b = 4, c = 6\n<strong>输出：</strong>6\n<strong>解释：</strong>石子起始状态是 (2, 4, 6) ，最优的一组操作是：\n- 从第一和第三堆取，石子状态现在是 (1, 4, 5)\n- 从第一和第三堆取，石子状态现在是 (0, 4, 4)\n- 从第二和第三堆取，石子状态现在是 (0, 3, 3)\n- 从第二和第三堆取，石子状态现在是 (0, 2, 2)\n- 从第二和第三堆取，石子状态现在是 (0, 1, 1)\n- 从第二和第三堆取，石子状态现在是 (0, 0, 0)\n总分：6 分 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 4, b = 4, c = 6\n<strong>输出：</strong>7\n<strong>解释：</strong>石子起始状态是 (4, 4, 6) ，最优的一组操作是：\n- 从第一和第二堆取，石子状态现在是 (3, 3, 6)\n- 从第一和第三堆取，石子状态现在是 (2, 3, 5)\n- 从第一和第三堆取，石子状态现在是 (1, 3, 4)\n- 从第一和第三堆取，石子状态现在是 (0, 3, 3)\n- 从第二和第三堆取，石子状态现在是 (0, 2, 2)\n- 从第二和第三堆取，石子状态现在是 (0, 1, 1)\n- 从第二和第三堆取，石子状态现在是 (0, 0, 0)\n总分：7 分 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 1, b = 8, c = 8\n<strong>输出：</strong>8\n<strong>解释：</strong>最优的一组操作是连续从第二和第三堆取 8 回合，直到将它们取空。\n注意，由于第二和第三堆已经空了，游戏结束，不能继续从第一堆中取石子。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= a, b, c <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1754构造字典序最大的合并字符串",
        "hardRate": "MEDIUM",
        "passRate": "56.28%",
        "problemsUrl": "https://leetcode.cn/problems/largest-merge-of-two-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-merge-of-two-strings/solution",
        "problemsDesc": "<p>给你两个字符串 <code>word1</code> 和 <code>word2</code> 。你需要按下述方式构造一个新字符串 <code>merge</code> ：如果 <code>word1</code> 或 <code>word2</code> 非空，选择 <strong>下面选项之一</strong> 继续操作：</p>\n\n<ul>\n\t<li>如果 <code>word1</code> 非空，将 <code>word1</code> 中的第一个字符附加到 <code>merge</code> 的末尾，并将其从 <code>word1</code> 中移除。\n\n\t<ul>\n\t\t<li>例如，<code>word1 = \"abc\" </code>且 <code>merge = \"dv\"</code> ，在执行此选项操作之后，<code>word1 = \"bc\"</code> ，同时 <code>merge = \"dva\"</code> 。</li>\n\t</ul>\n\t</li>\n\t<li>如果 <code>word2</code> 非空，将 <code>word2</code> 中的第一个字符附加到 <code>merge</code> 的末尾，并将其从 <code>word2</code> 中移除。\n\t<ul>\n\t\t<li>例如，<code>word2 = \"abc\" </code>且 <code>merge = \"\"</code> ，在执行此选项操作之后，<code>word2 = \"bc\"</code> ，同时 <code>merge = \"a\"</code> 。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>返回你可以构造的字典序 <strong>最大</strong> 的合并字符串<em> </em><code>merge</code><em> 。</em></p>\n\n<p>长度相同的两个字符串 <code>a</code> 和 <code>b</code> 比较字典序大小，如果在 <code>a</code> 和 <code>b</code> 出现不同的第一个位置，<code>a</code> 中字符在字母表中的出现顺序位于 <code>b</code> 中相应字符之后，就认为字符串 <code>a</code> 按字典序比字符串 <code>b</code> 更大。例如，<code>\"abcd\"</code> 按字典序比 <code>\"abcc\"</code> 更大，因为两个字符串出现不同的第一个位置是第四个字符，而 <code>d</code> 在字母表中的出现顺序位于 <code>c</code> 之后。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"cabaa\", word2 = \"bcaaa\"\n<strong>输出：</strong>\"cbcabaaaaa\"\n<strong>解释：</strong>构造字典序最大的合并字符串，可行的一种方法如下所示：\n- 从 word1 中取第一个字符：merge = \"c\"，word1 = \"abaa\"，word2 = \"bcaaa\"\n- 从 word2 中取第一个字符：merge = \"cb\"，word1 = \"abaa\"，word2 = \"caaa\"\n- 从 word2 中取第一个字符：merge = \"cbc\"，word1 = \"abaa\"，word2 = \"aaa\"\n- 从 word1 中取第一个字符：merge = \"cbca\"，word1 = \"baa\"，word2 = \"aaa\"\n- 从 word1 中取第一个字符：merge = \"cbcab\"，word1 = \"aa\"，word2 = \"aaa\"\n- 将 word1 和 word2 中剩下的 5 个 a 附加到 merge 的末尾。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"abcabc\", word2 = \"abdcaba\"\n<strong>输出：</strong>\"abdcabcabcaba\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word1.length, word2.length <= 3000</code></li>\n\t<li><code>word1</code> 和 <code>word2</code> 仅由小写英文组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1755最接近目标值的子序列和",
        "hardRate": "HARD",
        "passRate": "45.08%",
        "problemsUrl": "https://leetcode.cn/problems/closest-subsequence-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-subsequence-sum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个目标值 <code>goal</code> 。</p>\n\n<p>你需要从 <code>nums</code> 中选出一个子序列，使子序列元素总和最接近 <code>goal</code> 。也就是说，如果子序列元素和为 <code>sum</code> ，你需要 <strong>最小化绝对差</strong> <code>abs(sum - goal)</code> 。</p>\n\n<p>返回 <code>abs(sum - goal)</code> 可能的 <strong>最小值</strong> 。</p>\n\n<p>注意，数组的子序列是通过移除原始数组中的某些元素（可能全部或无）而形成的数组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,-7,3,5], goal = 6\n<strong>输出：</strong>0\n<strong>解释：</strong>选择整个数组作为选出的子序列，元素和为 6 。\n子序列和与目标值相等，所以绝对差为 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [7,-9,15,-2], goal = -5\n<strong>输出：</strong>1\n<strong>解释：</strong>选出子序列 [7,-9,-2] ，元素和为 -4 。\n绝对差为 abs(-4 - (-5)) = abs(1) = 1 ，是可能的最小值。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3], goal = -7\n<strong>输出：</strong>7\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 40</code></li>\n\t<li><code>-10<sup>7</sup> &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= goal &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1756设计最近使用（MRU）队列",
        "hardRate": "MEDIUM",
        "passRate": "82.34%",
        "problemsUrl": "https://leetcode.cn/problems/design-most-recently-used-queue/",
        "solutionsUrl": "https://leetcode.cn/problems/design-most-recently-used-queue/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1757可回收且低脂的产品",
        "hardRate": "EASY",
        "passRate": "87.63%",
        "problemsUrl": "https://leetcode.cn/problems/recyclable-and-low-fat-products/",
        "solutionsUrl": "https://leetcode.cn/problems/recyclable-and-low-fat-products/solution",
        "problemsDesc": "<p>表：<code>Products</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| product_id  | int     |\n| low_fats    | enum    |\n| recyclable  | enum    |\n+-------------+---------+\nproduct_id 是这个表的主键。\nlow_fats 是枚举类型，取值为以下两种 ('Y', 'N')，其中 'Y' 表示该产品是低脂产品，'N' 表示不是低脂产品。\nrecyclable 是枚举类型，取值为以下两种 ('Y', 'N')，其中 'Y' 表示该产品可回收，而 'N' 表示不可回收。</pre>\n\n<p> </p>\n\n<p>写出 SQL 语句，查找既是低脂又是可回收的产品编号。</p>\n\n<p>返回结果 <strong>无顺序要求</strong> 。</p>\n\n<p>查询结果格式如下例所示：</p>\n\n<pre>\nProducts 表：\n+-------------+----------+------------+\n| product_id  | low_fats | recyclable |\n+-------------+----------+------------+\n| 0           | Y        | N          |\n| 1           | Y        | Y          |\n| 2           | N        | Y          |\n| 3           | Y        | Y          |\n| 4           | N        | N          |\n+-------------+----------+------------+\nResult 表：\n+-------------+\n| product_id  |\n+-------------+\n| 1           |\n| 3           |\n+-------------+\n只有产品 id 为 1 和 3 的产品，既是低脂又是可回收的产品。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1758生成交替二进制字符串的最少操作数",
        "hardRate": "EASY",
        "passRate": "69.72%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-changes-to-make-alternating-binary-string/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-changes-to-make-alternating-binary-string/solution",
        "problemsDesc": "<p>给你一个仅由字符 <code>'0'</code> 和 <code>'1'</code> 组成的字符串 <code>s</code> 。一步操作中，你可以将任一 <code>'0'</code> 变成 <code>'1'</code> ，或者将 <code>'1'</code> 变成 <code>'0'</code> 。</p>\n\n<p><strong>交替字符串</strong> 定义为：如果字符串中不存在相邻两个字符相等的情况，那么该字符串就是交替字符串。例如，字符串 <code>\"010\"</code> 是交替字符串，而字符串 <code>\"0100\"</code> 不是。</p>\n\n<p>返回使 <code>s</code> 变成 <strong>交替字符串</strong> 所需的 <strong>最少</strong> 操作数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"0100\"\n<strong>输出：</strong>1\n<strong>解释：</strong>如果将最后一个字符变为 '1' ，s 就变成 \"0101\" ，即符合交替字符串定义。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"10\"\n<strong>输出：</strong>0\n<strong>解释：</strong>s 已经是交替字符串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = \"1111\"\n<strong>输出：</strong>2\n<strong>解释：</strong>需要 2 步操作得到 \"0101\" 或 \"1010\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s[i]</code> 是 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1759统计同质子字符串的数目",
        "hardRate": "MEDIUM",
        "passRate": "51.09%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-homogenous-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-homogenous-substrings/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，返回<em> </em><code>s</code><em> </em>中 <strong>同质子字符串</strong> 的数目。由于答案可能很大，只需返回对 <code>10<sup>9</sup> + 7</code> <strong>取余 </strong>后的结果。</p>\n\n<p><strong>同质字符串</strong> 的定义为：如果一个字符串中的所有字符都相同，那么该字符串就是同质字符串。</p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abbcccaa\"\n<strong>输出：</strong>13\n<strong>解释：</strong>同质子字符串如下所列：\n\"a\"   出现 3 次。\n\"aa\"  出现 1 次。\n\"b\"   出现 2 次。\n\"bb\"  出现 1 次。\n\"c\"   出现 3 次。\n\"cc\"  出现 2 次。\n\"ccc\" 出现 1 次。\n3 + 1 + 2 + 1 + 3 + 2 + 1 = 13</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"xy\"\n<strong>输出：</strong>2\n<strong>解释：</strong>同质子字符串是 \"x\" 和 \"y\" 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"zzzzz\"\n<strong>输出：</strong>15\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写字符串组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1760袋子里最少数目的球",
        "hardRate": "MEDIUM",
        "passRate": "64.12%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 表示第 <code>i</code> 个袋子里球的数目。同时给你一个整数 <code>maxOperations</code> 。</p>\n\n<p>你可以进行如下操作至多 <code>maxOperations</code> 次：</p>\n\n<ul>\n\t<li>选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 <strong>正整数</strong> 个球。\n\n\t<ul>\n\t\t<li>比方说，一个袋子里有 <code>5</code> 个球，你可以把它们分到两个新袋子里，分别有 <code>1</code> 个和 <code>4</code> 个球，或者分别有 <code>2</code> 个和 <code>3</code> 个球。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>你的开销是单个袋子里球数目的 <strong>最大值</strong> ，你想要 <strong>最小化</strong> 开销。</p>\n\n<p>请你返回进行上述操作后的最小开销。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [9], maxOperations = 2\n<b>输出：</b>3\n<b>解释：</b>\n- 将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[<strong>9</strong>] -> [6,3] 。\n- 将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[<strong>6</strong>,3] -> [3,3,3] 。\n装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,4,8,2], maxOperations = 4\n<b>输出：</b>2\n<strong>解释：</strong>\n- 将装有 8 个球的袋子分成装有 4 个和 4 个球的袋子。[2,4,<strong>8</strong>,2] -> [2,4,4,4,2] 。\n- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,<strong>4</strong>,4,4,2] -> [2,2,2,4,4,2] 。\n- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,<strong>4</strong>,4,2] -> [2,2,2,2,2,4,2] 。\n- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,2,2,<strong>4</strong>,2] -> [2,2,2,2,2,2,2,2] 。\n装有最多球的袋子里装有 2 个球，所以开销为 2 并返回 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [7,17], maxOperations = 2\n<b>输出：</b>7\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= maxOperations, nums[i] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1761一个图中连通三元组的最小度数",
        "hardRate": "HARD",
        "passRate": "46.10%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph/solution",
        "problemsDesc": "<p>给你一个无向图，整数 <code>n</code> 表示图中节点的数目，<code>edges</code> 数组表示图中的边，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> ，表示 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code><sub> </sub>之间有一条无向边。</p>\n\n<p>一个 <strong>连通三元组</strong> 指的是 <strong>三个</strong> 节点组成的集合且这三个点之间 <strong>两两</strong> 有边。</p>\n\n<p><strong>连通三元组的度数</strong> 是所有满足此条件的边的数目：一个顶点在这个三元组内，而另一个顶点不在这个三元组内。</p>\n\n<p>请你返回所有连通三元组中度数的 <strong>最小值</strong> ，如果图中没有连通三元组，那么返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/14/trios1.png\" style=\"width: 388px; height: 164px;\" />\n<pre>\n<b>输入：</b>n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]\n<b>输出：</b>3\n<b>解释：</b>只有一个三元组 [1,2,3] 。构成度数的边在上图中已被加粗。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/14/trios2.png\" style=\"width: 388px; height: 164px;\" />\n<pre>\n<b>输入：</b>n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]\n<b>输出：</b>0\n<b>解释：</b>有 3 个三元组：\n1) [1,4,3]，度数为 0 。\n2) [2,5,6]，度数为 2 。\n3) [5,6,7]，度数为 2 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 400</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 <= edges.length <= n * (n-1) / 2</code></li>\n\t<li><code>1 <= u<sub>i</sub>, v<sub>i</sub> <= n</code></li>\n\t<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>\n\t<li>图中没有重复的边。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1762能看到海景的建筑物",
        "hardRate": "MEDIUM",
        "passRate": "71.46%",
        "problemsUrl": "https://leetcode.cn/problems/buildings-with-an-ocean-view/",
        "solutionsUrl": "https://leetcode.cn/problems/buildings-with-an-ocean-view/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1763最长的美好子字符串",
        "hardRate": "EASY",
        "passRate": "67.26%",
        "problemsUrl": "https://leetcode.cn/problems/longest-nice-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-nice-substring/solution",
        "problemsDesc": "<p>当一个字符串 <code>s</code> 包含的每一种字母的大写和小写形式 <strong>同时</strong> 出现在 <code>s</code> 中，就称这个字符串 <code>s</code> 是 <strong>美好</strong> 字符串。比方说，<code>\"abABB\"</code> 是美好字符串，因为 <code>'A'</code> 和 <code>'a'</code> 同时出现了，且 <code>'B'</code> 和 <code>'b'</code> 也同时出现了。然而，<code>\"abA\"</code> 不是美好字符串因为 <code>'b'</code> 出现了，而 <code>'B'</code> 没有出现。</p>\n\n<p>给你一个字符串 <code>s</code> ，请你返回 <code>s</code> 最长的 <strong>美好子字符串</strong> 。如果有多个答案，请你返回 <strong>最早</strong> 出现的一个。如果不存在美好子字符串，请你返回一个空字符串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"YazaAay\"\n<b>输出：</b>\"aAa\"\n<strong>解释：</strong>\"aAa\" 是一个美好字符串，因为这个子串中仅含一种字母，其小写形式 'a' 和大写形式 'A' 也同时出现了。\n\"aAa\" 是最长的美好子字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"Bb\"\n<b>输出：</b>\"Bb\"\n<b>解释：</b>\"Bb\" 是美好字符串，因为 'B' 和 'b' 都出现了。整个字符串也是原字符串的子字符串。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"c\"\n<b>输出：</b>\"\"\n<b>解释：</b>没有美好子字符串。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"dDzeE\"\n<b>输出：</b>\"dD\"\n<strong>解释：</strong>\"dD\" 和 \"eE\" 都是最长美好子字符串。\n由于有多个美好子字符串，返回 \"dD\" ，因为它出现得最早。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 100</code></li>\n\t<li><code>s</code> 只包含大写和小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1764通过连接另一个数组的子数组得到一个数组",
        "hardRate": "MEDIUM",
        "passRate": "55.73%",
        "problemsUrl": "https://leetcode.cn/problems/form-array-by-concatenating-subarrays-of-another-array/",
        "solutionsUrl": "https://leetcode.cn/problems/form-array-by-concatenating-subarrays-of-another-array/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的二维整数数组 <code>groups</code> ，同时给你一个整数数组 <code>nums</code> 。</p>\n\n<p>你是否可以从 <code>nums</code> 中选出 <code>n</code> 个 <strong>不相交</strong> 的子数组，使得第 <code>i</code> 个子数组与 <code>groups[i]</code> （下标从 <strong>0</strong> 开始）完全相同，且如果 <code>i > 0</code> ，那么第 <code>(i-1)</code> 个子数组在 <code>nums</code> 中出现的位置在第 <code>i</code> 个子数组前面。（也就是说，这些子数组在 <code>nums</code> 中出现的顺序需要与 <code>groups</code> 顺序相同）</p>\n\n<p>如果你可以找出这样的 <code>n</code> 个子数组，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p>如果不存在下标为 <code>k</code> 的元素 <code>nums[k]</code> 属于不止一个子数组，就称这些子数组是 <strong>不相交</strong> 的。子数组指的是原数组中连续元素组成的一个序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>groups = [[1,-1,-1],[3,-2,0]], nums = [1,-1,0,1,-1,-1,3,-2,0]\n<b>输出：</b>true\n<b>解释：</b>你可以分别在 nums 中选出第 0 个子数组 [1,-1,0,<strong>1,</strong><strong>-1,</strong><strong>-1</strong>,3,-2,0] 和第 1 个子数组 [1,-1,0,1,-1,-1,<strong>3,</strong><strong>-2,0</strong>] 。\n这两个子数组是不相交的，因为它们没有任何共同的元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>groups = [[10,-2],[1,2,3,4]], nums = [1,2,3,4,10,-2]\n<b>输出：</b>false\n<strong>解释：</strong>选择子数组 [<strong>1,2,3,4</strong>,10,-2] 和 [1,2,3,4,<strong>10,-2</strong>] 是不正确的，因为它们出现的顺序与 groups 中顺序不同。\n[10,-2] 必须出现在 [1,2,3,4] 之前。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>groups = [[1,2,3],[3,4]], nums = [7,7,1,2,3,4,7,7]\n<b>输出：</b>false\n<strong>解释：</strong>选择子数组 [7,7,<strong>1,2,3</strong>,4,7,7] 和 [7,7,1,2,<strong>3,4</strong>,7,7] 是不正确的，因为它们不是不相交子数组。\n它们有一个共同的元素 nums[4] （下标从 0 开始）。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>groups.length == n</code></li>\n\t<li><code>1 <= n <= 10<sup>3</sup></code></li>\n\t<li><code>1 <= groups[i].length, sum(groups[i].length) <= 10<sup><span style=\"\">3</span></sup></code></li>\n\t<li><code>1 <= nums.length <= 10<sup>3</sup></code></li>\n\t<li><code>-10<sup>7</sup> <= groups[i][j], nums[k] <= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1765地图中的最高点",
        "hardRate": "MEDIUM",
        "passRate": "66.38%",
        "problemsUrl": "https://leetcode.cn/problems/map-of-highest-peak/",
        "solutionsUrl": "https://leetcode.cn/problems/map-of-highest-peak/solution",
        "problemsDesc": "<p>给你一个大小为&nbsp;<code>m x n</code>&nbsp;的整数矩阵&nbsp;<code>isWater</code>&nbsp;，它代表了一个由 <strong>陆地</strong>&nbsp;和 <strong>水域</strong>&nbsp;单元格组成的地图。</p>\n\n<ul>\n\t<li>如果&nbsp;<code>isWater[i][j] == 0</code>&nbsp;，格子&nbsp;<code>(i, j)</code>&nbsp;是一个 <strong>陆地</strong>&nbsp;格子。</li>\n\t<li>如果&nbsp;<code>isWater[i][j] == 1</code>&nbsp;，格子&nbsp;<code>(i, j)</code>&nbsp;是一个 <strong>水域</strong>&nbsp;格子。</li>\n</ul>\n\n<p>你需要按照如下规则给每个单元格安排高度：</p>\n\n<ul>\n\t<li>每个格子的高度都必须是非负的。</li>\n\t<li>如果一个格子是 <strong>水域</strong>&nbsp;，那么它的高度必须为 <code>0</code>&nbsp;。</li>\n\t<li>任意相邻的格子高度差 <strong>至多</strong>&nbsp;为 <code>1</code>&nbsp;。当两个格子在正东、南、西、北方向上相互紧挨着，就称它们为相邻的格子。（也就是说它们有一条公共边）</li>\n</ul>\n\n<p>找到一种安排高度的方案，使得矩阵中的最高高度值&nbsp;<strong>最大</strong>&nbsp;。</p>\n\n<p>请你返回一个大小为&nbsp;<code>m x n</code>&nbsp;的整数矩阵 <code>height</code>&nbsp;，其中 <code>height[i][j]</code>&nbsp;是格子 <code>(i, j)</code>&nbsp;的高度。如果有多种解法，请返回&nbsp;<strong>任意一个</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-82045-am.png\" style=\"width: 220px; height: 219px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>isWater = [[0,1],[0,0]]\n<b>输出：</b>[[1,0],[2,1]]\n<b>解释：</b>上图展示了给各个格子安排的高度。\n蓝色格子是水域格，绿色格子是陆地格。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-82050-am.png\" style=\"width: 300px; height: 296px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>isWater = [[0,0,1],[1,0,0],[0,0,0]]\n<b>输出：</b>[[1,1,0],[0,1,1],[1,2,2]]\n<b>解释：</b>所有安排方案中，最高可行高度为 2 。\n任意安排方案中，只要最高高度为 2 且符合上述规则的，都为可行方案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == isWater.length</code></li>\n\t<li><code>n == isWater[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>isWater[i][j]</code>&nbsp;要么是&nbsp;<code>0</code>&nbsp;，要么是&nbsp;<code>1</code>&nbsp;。</li>\n\t<li>至少有 <strong>1</strong>&nbsp;个水域格子。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1766互质树",
        "hardRate": "HARD",
        "passRate": "40.26%",
        "problemsUrl": "https://leetcode.cn/problems/tree-of-coprimes/",
        "solutionsUrl": "https://leetcode.cn/problems/tree-of-coprimes/solution",
        "problemsDesc": "<p>给你一个 <code>n</code> 个节点的树（也就是一个无环连通无向图），节点编号从 <code>0</code> 到 <code>n - 1</code> ，且恰好有 <code>n - 1</code> 条边，每个节点有一个值。树的 <strong>根节点</strong> 为 0 号点。</p>\n\n<p>给你一个整数数组 <code>nums</code> 和一个二维数组 <code>edges</code> 来表示这棵树。<code>nums[i]</code> 表示第 <code>i</code> 个点的值，<code>edges[j] = [u<sub>j</sub>, v<sub>j</sub>]</code> 表示节点 <code>u<sub>j</sub></code> 和节点 <code>v<sub>j</sub></code> 在树中有一条边。</p>\n\n<p>当 <code>gcd(x, y) == 1</code> ，我们称两个数 <code>x</code> 和 <code>y</code> 是 <strong>互质的</strong> ，其中 <code>gcd(x, y)</code> 是 <code>x</code> 和 <code>y</code> 的 <strong>最大公约数</strong> 。</p>\n\n<p>从节点 <code>i</code> 到 <strong>根</strong> 最短路径上的点都是节点 <code>i</code> 的祖先节点。一个节点 <strong>不是</strong> 它自己的祖先节点。</p>\n\n<p>请你返回一个大小为 <code>n</code> 的数组 <code>ans</code> ，其中<em> </em><code>ans[i]</code>是离节点 <code>i</code> 最近的祖先节点且满足<em> </em><code>nums[i]</code> 和<em> </em><code>nums[ans[i]]</code> 是 <strong>互质的</strong> ，如果不存在这样的祖先节点，<code>ans[i]</code> 为 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/20/untitled-diagram.png\" style=\"width: 191px; height: 281px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,3,3,2], edges = [[0,1],[1,2],[1,3]]\n<b>输出：</b>[-1,0,0,1]\n<b>解释：</b>上图中，每个节点的值在括号中表示。\n- 节点 0 没有互质祖先。\n- 节点 1 只有一个祖先节点 0 。它们的值是互质的（gcd(2,3) == 1）。\n- 节点 2 有两个祖先节点，分别是节点 1 和节点 0 。节点 1 的值与它的值不是互质的（gcd(3,3) == 3）但节点 0 的值是互质的(gcd(2,3) == 1)，所以节点 0 是最近的符合要求的祖先节点。\n- 节点 3 有两个祖先节点，分别是节点 1 和节点 0 。它与节点 1 互质（gcd(3,2) == 1），所以节点 1 是离它最近的符合要求的祖先节点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/20/untitled-diagram1.png\" style=\"width: 441px; height: 291px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,6,10,2,3,6,15], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]\n<b>输出：</b>[-1,0,-1,0,0,0,-1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length == n</code></li>\n\t<li><code>1 <= nums[i] <= 50</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[j].length == 2</code></li>\n\t<li><code>0 <= u<sub>j</sub>, v<sub>j</sub> < n</code></li>\n\t<li><code>u<sub>j</sub> != v<sub>j</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1767寻找没有被执行的任务对",
        "hardRate": "HARD",
        "passRate": "80.22%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-subtasks-that-did-not-execute/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-subtasks-that-did-not-execute/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1768交替合并字符串",
        "hardRate": "EASY",
        "passRate": "76.32%",
        "problemsUrl": "https://leetcode.cn/problems/merge-strings-alternately/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-strings-alternately/solution",
        "problemsDesc": "<p>给你两个字符串 <code>word1</code> 和 <code>word2</code> 。请你从 <code>word1</code> 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。</p>\n\n<p>返回 <strong>合并后的字符串</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"abc\", word2 = \"pqr\"\n<strong>输出：</strong>\"apbqcr\"\n<strong>解释：</strong>字符串合并情况如下所示：\nword1：  a   b   c\nword2：    p   q   r\n合并后：  a p b q c r\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"ab\", word2 = \"pqrs\"\n<strong>输出：</strong>\"apbqrs\"\n<strong>解释：</strong>注意，word2 比 word1 长，\"rs\" 需要追加到合并后字符串的末尾。\nword1：  a   b \nword2：    p   q   r   s\n合并后：  a p b q   r   s\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"abcd\", word2 = \"pq\"\n<strong>输出：</strong>\"apbqcd\"\n<strong>解释：</strong>注意，word1 比 word2 长，\"cd\" 需要追加到合并后字符串的末尾。\nword1：  a   b   c   d\nword2：    p   q \n合并后：  a p b q c   d\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word1.length, word2.length <= 100</code></li>\n\t<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1769移动所有球到每个盒子所需的最小操作数",
        "hardRate": "MEDIUM",
        "passRate": "87.89%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/solution",
        "problemsDesc": "<p>有 <code>n</code> 个盒子。给你一个长度为 <code>n</code> 的二进制字符串 <code>boxes</code> ，其中 <code>boxes[i]</code> 的值为 <code>'0'</code> 表示第 <code>i</code> 个盒子是 <strong>空</strong> 的，而 <code>boxes[i]</code> 的值为 <code>'1'</code> 表示盒子里有 <strong>一个</strong> 小球。</p>\n\n<p>在一步操作中，你可以将 <strong>一个</strong> 小球从某个盒子移动到一个与之相邻的盒子中。第 <code>i</code> 个盒子和第 <code>j</code> 个盒子相邻需满足 <code>abs(i - j) == 1</code> 。注意，操作执行后，某些盒子中可能会存在不止一个小球。</p>\n\n<p>返回一个长度为 <code>n</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是将所有小球移动到第 <code>i</code> 个盒子所需的 <strong>最小</strong> 操作数。</p>\n\n<p>每个 <code>answer[i]</code> 都需要根据盒子的 <strong>初始状态</strong> 进行计算。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>boxes = \"110\"\n<strong>输出：</strong>[1,1,3]\n<strong>解释：</strong>每个盒子对应的最小操作数如下：\n1) 第 1 个盒子：将一个小球从第 2 个盒子移动到第 1 个盒子，需要 1 步操作。\n2) 第 2 个盒子：将一个小球从第 1 个盒子移动到第 2 个盒子，需要 1 步操作。\n3) 第 3 个盒子：将一个小球从第 1 个盒子移动到第 3 个盒子，需要 2 步操作。将一个小球从第 2 个盒子移动到第 3 个盒子，需要 1 步操作。共计 3 步操作。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>boxes = \"001011\"\n<strong>输出：</strong>[11,8,5,4,3,4]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == boxes.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2000</code></li>\n\t<li><code>boxes[i]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1770执行乘法运算的最大分数",
        "hardRate": "HARD",
        "passRate": "39.63%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-from-performing-multiplication-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-from-performing-multiplication-operations/solution",
        "problemsDesc": "<p>给你两个长度分别 <code>n</code> 和 <code>m</code> 的整数数组 <code>nums</code> 和 <code>multipliers</code><strong> </strong>，其中 <code>n &gt;= m</code> ，数组下标 <strong>从 1 开始</strong> 计数。</p>\n\n<p>初始时，你的分数为 <code>0</code> 。你需要执行恰好 <code>m</code> 步操作。在第 <code>i</code> 步操作（<strong>从 1 开始</strong> 计数）中，需要：</p>\n\n<ul>\n\t<li>选择数组 <code>nums</code> <strong>开头处或者末尾处</strong> 的整数 <code>x</code> 。</li>\n\t<li>你获得 <code>multipliers[i] * x</code> 分，并累加到你的分数中。</li>\n\t<li>将 <code>x</code> 从数组 <code>nums</code> 中移除。</li>\n</ul>\n\n<p>在执行<em> </em><code>m</code> 步操作后，返回 <strong>最大</strong> 分数<em>。</em></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3], multipliers = [3,2,1]\n<strong>输出：</strong>14\n<strong>解释：</strong>一种最优解决方案如下：\n- 选择末尾处的整数 3 ，[1,2,<strong>3</strong>] ，得 3 * 3 = 9 分，累加到分数中。\n- 选择末尾处的整数 2 ，[1,<strong>2</strong>] ，得 2 * 2 = 4 分，累加到分数中。\n- 选择末尾处的整数 1 ，[<strong>1</strong>] ，得 1 * 1 = 1 分，累加到分数中。\n总分数为 9 + 4 + 1 = 14 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]\n<strong>输出：</strong>102\n<strong>解释：</strong>一种最优解决方案如下：\n- 选择开头处的整数 -5 ，[<strong>-5</strong>,-3,-3,-2,7,1] ，得 -5 * -10 = 50 分，累加到分数中。\n- 选择开头处的整数 -3 ，[<strong>-3</strong>,-3,-2,7,1] ，得 -3 * -5 = 15 分，累加到分数中。\n- 选择开头处的整数 -3 ，[<strong>-3</strong>,-2,7,1] ，得 -3 * 3 = -9 分，累加到分数中。\n- 选择末尾处的整数 1 ，[-2,7,<strong>1</strong>] ，得 1 * 4 = 4 分，累加到分数中。\n- 选择末尾处的整数 7 ，[-2,<strong>7</strong>] ，得 7 * 6 = 42 分，累加到分数中。\n总分数为 50 + 15 - 9 + 4 + 42 = 102 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>m == multipliers.length</code></li>\n\t<li><code>1 &lt;= m &lt;= 10<sup>3</sup></code></li>\n\t<li><code>m &lt;= n &lt;= 10<sup>5</sup></code><code> </code></li>\n\t<li><code>-1000 &lt;= nums[i], multipliers[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1771由子序列构造的最长回文串的长度",
        "hardRate": "HARD",
        "passRate": "38.42%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-palindrome-length-from-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-palindrome-length-from-subsequences/solution",
        "problemsDesc": "<p>给你两个字符串 <code>word1</code> 和 <code>word2</code> ，请你按下述方法构造一个字符串：</p>\n\n<ul>\n\t<li>从 <code>word1</code> 中选出某个 <strong>非空</strong> 子序列 <code>subsequence1</code> 。</li>\n\t<li>从 <code>word2</code> 中选出某个 <strong>非空</strong> 子序列 <code>subsequence2</code> 。</li>\n\t<li>连接两个子序列 <code>subsequence1 + subsequence2</code> ，得到字符串。</li>\n</ul>\n\n<p>返回可按上述方法构造的最长 <strong>回文串</strong> 的 <strong>长度</strong> 。如果无法构造回文串，返回 <code>0</code> 。</p>\n\n<p>字符串 <code>s</code> 的一个 <strong>子序列</strong> 是通过从 <code>s</code> 中删除一些（也可能不删除）字符而不更改其余字符的顺序生成的字符串。</p>\n\n<p><strong>回文串</strong> 是正着读和反着读结果一致的字符串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>word1 = \"cacb\", word2 = \"cbba\"\n<strong>输出：</strong>5\n<strong>解释：</strong>从 word1 中选出 \"ab\" ，从 word2 中选出 \"cba\" ，得到回文串 \"abcba\" 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>word1 = \"ab\", word2 = \"ab\"\n<strong>输出：</strong>3\n<strong>解释：</strong>从 word1 中选出 \"ab\" ，从 word2 中选出 \"a\" ，得到回文串 \"aba\" 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>word1 = \"aa\", word2 = \"bb\"\n<strong>输出：</strong>0\n<strong>解释：</strong>无法按题面所述方法构造回文串，所以返回 0 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word1.length, word2.length &lt;= 1000</code></li>\n\t<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1772按受欢迎程度排列功能",
        "hardRate": "MEDIUM",
        "passRate": "47.22%",
        "problemsUrl": "https://leetcode.cn/problems/sort-features-by-popularity/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-features-by-popularity/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1773统计匹配检索规则的物品数量",
        "hardRate": "EASY",
        "passRate": "86.50%",
        "problemsUrl": "https://leetcode.cn/problems/count-items-matching-a-rule/",
        "solutionsUrl": "https://leetcode.cn/problems/count-items-matching-a-rule/solution",
        "problemsDesc": "<p>给你一个数组 <code>items</code> ，其中 <code>items[i] = [type<sub>i</sub>, color<sub>i</sub>, name<sub>i</sub>]</code> ，描述第 <code>i</code> 件物品的类型、颜色以及名称。</p>\n\n<p>另给你一条由两个字符串 <code>ruleKey</code> 和 <code>ruleValue</code> 表示的检索规则。</p>\n\n<p>如果第 <code>i</code> 件物品能满足下述条件之一，则认为该物品与给定的检索规则 <strong>匹配</strong> ：</p>\n\n<ul>\n\t<li><code>ruleKey == \"type\"</code> 且 <code>ruleValue == type<sub>i</sub></code> 。</li>\n\t<li><code>ruleKey == \"color\"</code> 且 <code>ruleValue == color<sub>i</sub></code> 。</li>\n\t<li><code>ruleKey == \"name\"</code> 且 <code>ruleValue == name<sub>i</sub></code> 。</li>\n</ul>\n\n<p>统计并返回 <strong>匹配检索规则的物品数量</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"color\", ruleValue = \"silver\"\n<strong>输出：</strong>1\n<strong>解释：</strong>只有一件物品匹配检索规则，这件物品是 [\"computer\",\"silver\",\"lenovo\"] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"type\", ruleValue = \"phone\"\n<strong>输出：</strong>2\n<strong>解释：</strong>只有两件物品匹配检索规则，这两件物品分别是 [\"phone\",\"blue\",\"pixel\"] 和 [\"phone\",\"gold\",\"iphone\"] 。注意，[\"computer\",\"silver\",\"phone\"] 未匹配检索规则。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= items.length <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= type<sub>i</sub>.length, color<sub>i</sub>.length, name<sub>i</sub>.length, ruleValue.length <= 10</code></li>\n\t<li><code>ruleKey</code> 等于 <code>\"type\"</code>、<code>\"color\"</code> 或 <code>\"name\"</code></li>\n\t<li>所有字符串仅由小写字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1774最接近目标价格的甜点成本",
        "hardRate": "MEDIUM",
        "passRate": "57.51%",
        "problemsUrl": "https://leetcode.cn/problems/closest-dessert-cost/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-dessert-cost/solution",
        "problemsDesc": "<p>你打算做甜点，现在需要购买配料。目前共有 <code>n</code> 种冰激凌基料和 <code>m</code> 种配料可供选购。而制作甜点需要遵循以下几条规则：</p>\n\n<ul>\n\t<li>必须选择 <strong>一种</strong> 冰激凌基料。</li>\n\t<li>可以添加 <strong>一种或多种</strong> 配料，也可以不添加任何配料。</li>\n\t<li>每种类型的配料 <strong>最多两份</strong> 。</li>\n</ul>\n\n<p>给你以下三个输入：</p>\n\n<ul>\n\t<li><code>baseCosts</code> ，一个长度为 <code>n</code> 的整数数组，其中每个 <code>baseCosts[i]</code> 表示第 <code>i</code> 种冰激凌基料的价格。</li>\n\t<li><code>toppingCosts</code>，一个长度为 <code>m</code> 的整数数组，其中每个 <code>toppingCosts[i]</code> 表示 <strong>一份</strong> 第 <code>i</code> 种冰激凌配料的价格。</li>\n\t<li><code>target</code> ，一个整数，表示你制作甜点的目标价格。</li>\n</ul>\n\n<p>你希望自己做的甜点总成本尽可能接近目标价格 <code>target</code> 。</p>\n\n<p>返回最接近<em> </em><code>target</code> 的甜点成本。如果有多种方案，返回 <strong>成本相对较低</strong> 的一种。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>baseCosts = [1,7], toppingCosts = [3,4], target = 10\n<strong>输出：</strong>10\n<strong>解释：</strong>考虑下面的方案组合（所有下标均从 0 开始）：\n- 选择 1 号基料：成本 7\n- 选择 1 份 0 号配料：成本 1 x 3 = 3\n- 选择 0 份 1 号配料：成本 0 x 4 = 0\n总成本：7 + 3 + 0 = 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\n<strong>输出：</strong>17\n<strong>解释：</strong>考虑下面的方案组合（所有下标均从 0 开始）：\n- 选择 1 号基料：成本 3\n- 选择 1 份 0 号配料：成本 1 x 4 = 4\n- 选择 2 份 1 号配料：成本 2 x 5 = 10\n- 选择 0 份 2 号配料：成本 0 x 100 = 0\n总成本：3 + 4 + 10 + 0 = 17 。不存在总成本为 18 的甜点制作方案。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>baseCosts = [3,10], toppingCosts = [2,5], target = 9\n<strong>输出：</strong>8\n<strong>解释：</strong>可以制作总成本为 8 和 10 的甜点。返回 8 ，因为这是成本更低的方案。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>baseCosts = [10], toppingCosts = [1], target = 1\n<strong>输出：</strong>10\n<strong>解释：</strong>注意，你可以选择不添加任何配料，但你必须选择一种基料。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == baseCosts.length</code></li>\n\t<li><code>m == toppingCosts.length</code></li>\n\t<li><code>1 <= n, m <= 10</code></li>\n\t<li><code>1 <= baseCosts[i], toppingCosts[i] <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= target <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1775通过最少操作次数使数组的和相等",
        "hardRate": "MEDIUM",
        "passRate": "56.43%",
        "problemsUrl": "https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/solution",
        "problemsDesc": "<p>给你两个长度可能不等的整数数组 <code>nums1</code> 和 <code>nums2</code> 。两个数组中的所有值都在 <code>1</code> 到 <code>6</code> 之间（包含 <code>1</code> 和 <code>6</code>）。</p>\n\n<p>每次操作中，你可以选择 <strong>任意</strong> 数组中的任意一个整数，将它变成 <code>1</code> 到 <code>6</code> 之间 <strong>任意</strong> 的值（包含 <code>1</code> 和 <code><span style=\"\">6</span></code>）。</p>\n\n<p>请你返回使 <code>nums1</code> 中所有数的和与 <code>nums2</code> 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2]\n<b>输出：</b>3\n<b>解释：</b>你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。\n- 将 nums2[0] 变为 6 。 nums1 = [1,2,3,4,5,6], nums2 = [<strong>6</strong>,1,2,2,2,2] 。\n- 将 nums1[5] 变为 1 。 nums1 = [1,2,3,4,5,<strong>1</strong>], nums2 = [6,1,2,2,2,2] 。\n- 将 nums1[2] 变为 2 。 nums1 = [1,2,<strong>2</strong>,4,5,1], nums2 = [6,1,2,2,2,2] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,1,1,1,1,1,1], nums2 = [6]\n<b>输出：</b>-1\n<b>解释：</b>没有办法减少 nums1 的和或者增加 nums2 的和使二者相等。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums1 = [6,6], nums2 = [1]\n<b>输出：</b>3\n<b>解释：</b>你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。\n- 将 nums1[0] 变为 2 。 nums1 = [<strong>2</strong>,6], nums2 = [1] 。\n- 将 nums1[1] 变为 2 。 nums1 = [2,<strong>2</strong>], nums2 = [1] 。\n- 将 nums2[0] 变为 4 。 nums1 = [2,2], nums2 = [<strong>4</strong>] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1776车队 II",
        "hardRate": "HARD",
        "passRate": "48.56%",
        "problemsUrl": "https://leetcode.cn/problems/car-fleet-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/car-fleet-ii/solution",
        "problemsDesc": "<p>在一条单车道上有 <code>n</code> 辆车，它们朝着同样的方向行驶。给你一个长度为 <code>n</code> 的数组 <code>cars</code> ，其中 <code>cars[i] = [position<sub>i</sub>, speed<sub>i</sub>]</code> ，它表示：</p>\n\n<ul>\n\t<li><code>position<sub>i</sub></code> 是第 <code>i</code> 辆车和道路起点之间的距离（单位：米）。题目保证 <code>position<sub>i</sub> < position<sub>i+1</sub></code><sub> </sub>。</li>\n\t<li><code>speed<sub>i</sub></code> 是第 <code>i</code> 辆车的初始速度（单位：米/秒）。</li>\n</ul>\n\n<p>简单起见，所有车子可以视为在数轴上移动的点。当两辆车占据同一个位置时，我们称它们相遇了。一旦两辆车相遇，它们会合并成一个车队，这个车队里的车有着同样的位置和相同的速度，速度为这个车队里 <strong>最慢</strong> 一辆车的速度。</p>\n\n<p>请你返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 <code>i</code> 辆车与下一辆车相遇的时间（单位：秒），如果这辆车不会与下一辆车相遇，则 <code>answer[i]</code> 为 <code>-1</code> 。答案精度误差需在 <code>10<sup>-5</sup></code> 以内。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>cars = [[1,2],[2,1],[4,3],[7,2]]\n<b>输出：</b>[1.00000,-1.00000,3.00000,-1.00000]\n<b>解释：</b>经过恰好 1 秒以后，第一辆车会与第二辆车相遇，并形成一个 1 m/s 的车队。经过恰好 3 秒以后，第三辆车会与第四辆车相遇，并形成一个 2 m/s 的车队。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>cars = [[3,4],[5,4],[6,3],[9,1]]\n<b>输出：</b>[2.00000,1.00000,1.50000,-1.00000]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= cars.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= position<sub>i</sub>, speed<sub>i</sub> <= 10<sup>6</sup></code></li>\n\t<li><code>position<sub>i</sub> < position<sub>i+1</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1777每家商店的产品价格",
        "hardRate": "EASY",
        "passRate": "78.36%",
        "problemsUrl": "https://leetcode.cn/problems/products-price-for-each-store/",
        "solutionsUrl": "https://leetcode.cn/problems/products-price-for-each-store/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1778未知网格中的最短路径",
        "hardRate": "MEDIUM",
        "passRate": "48.12%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-path-in-a-hidden-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-path-in-a-hidden-grid/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1779找到最近的有相同 X 或 Y 坐标的点",
        "hardRate": "EASY",
        "passRate": "68.98%",
        "problemsUrl": "https://leetcode.cn/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate/",
        "solutionsUrl": "https://leetcode.cn/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate/solution",
        "problemsDesc": "<p>给你两个整数&nbsp;<code>x</code> 和&nbsp;<code>y</code>&nbsp;，表示你在一个笛卡尔坐标系下的&nbsp;<code>(x, y)</code>&nbsp;处。同时，在同一个坐标系下给你一个数组&nbsp;<code>points</code>&nbsp;，其中&nbsp;<code>points[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示在&nbsp;<code>(a<sub>i</sub>, b<sub>i</sub>)</code>&nbsp;处有一个点。当一个点与你所在的位置有相同的 <code>x</code> 坐标或者相同的 <code>y</code> 坐标时，我们称这个点是 <b>有效的</b>&nbsp;。</p>\n\n<p>请返回距离你当前位置&nbsp;<strong>曼哈顿距离</strong>&nbsp;最近的&nbsp;<strong>有效</strong>&nbsp;点的下标（下标从 <strong>0</strong> 开始）。如果有多个最近的有效点，请返回下标&nbsp;<strong>最小</strong>&nbsp;的一个。如果没有有效点，请返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>两个点 <code>(x<sub>1</sub>, y<sub>1</sub>)</code>&nbsp;和 <code>(x<sub>2</sub>, y<sub>2</sub>)</code>&nbsp;之间的 <strong>曼哈顿距离</strong>&nbsp;为&nbsp;<code>abs(x<sub>1</sub> - x<sub>2</sub>) + abs(y<sub>1</sub> - y<sub>2</sub>)</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]]\n<b>输出：</b>2\n<b>解释：</b>所有点中，[3,1]，[2,4] 和 [4,4] 是有效点。有效点中，[2,4] 和 [4,4] 距离你当前位置的曼哈顿距离最小，都为 1 。[2,4] 的下标最小，所以返回 2 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>x = 3, y = 4, points = [[3,4]]\n<b>输出：</b>0\n<b>提示：</b>答案可以与你当前所在位置坐标相同。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>x = 3, y = 4, points = [[2,3]]\n<b>输出：</b>-1\n<b>解释：</b>没有 有效点。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= points.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>1 &lt;= x, y, a<sub>i</sub>, b<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1780判断一个数字是否可以表示成三的幂的和",
        "hardRate": "MEDIUM",
        "passRate": "74.83%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-number-is-a-sum-of-powers-of-three/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-number-is-a-sum-of-powers-of-three/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，如果你可以将 <code>n</code> 表示成若干个不同的三的幂之和，请你返回 <code>true</code> ，否则请返回 <code>false</code> 。</p>\n\n<p>对于一个整数 <code>y</code> ，如果存在整数 <code>x</code> 满足 <code>y == 3<sup>x</sup></code> ，我们称这个整数 <code>y</code> 是三的幂。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 12\n<b>输出：</b>true\n<b>解释：</b>12 = 3<sup>1</sup> + 3<sup>2</sup>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 91\n<b>输出：</b>true\n<b>解释：</b>91 = 3<sup>0</sup> + 3<sup>2</sup> + 3<sup>4</sup>\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>n = 21\n<b>输出：</b>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1781所有子字符串美丽值之和",
        "hardRate": "MEDIUM",
        "passRate": "66.51%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-beauty-of-all-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-beauty-of-all-substrings/solution",
        "problemsDesc": "<p>一个字符串的 <strong>美丽值</strong> 定义为：出现频率最高字符与出现频率最低字符的出现次数之差。</p>\n\n<ul>\n\t<li>比方说，<code>\"abaacc\"</code> 的美丽值为 <code>3 - 1 = 2</code> 。</li>\n</ul>\n\n<p>给你一个字符串 <code>s</code> ，请你返回它所有子字符串的 <strong>美丽值</strong> 之和。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aabcb\"\n<b>输出：</b>5\n<strong>解释：</strong>美丽值不为零的字符串包括 [\"aab\",\"aabc\",\"aabcb\",\"abcb\",\"bcb\"] ，每一个字符串的美丽值都为 1 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aabcbaa\"\n<b>输出：</b>17\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <=<sup> </sup>500</code></li>\n\t<li><code>s</code> 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1782统计点对的数目",
        "hardRate": "HARD",
        "passRate": "35.75%",
        "problemsUrl": "https://leetcode.cn/problems/count-pairs-of-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/count-pairs-of-nodes/solution",
        "problemsDesc": "<p>给你一个无向图，无向图由整数 <code>n</code>  ，表示图中节点的数目，和 <code>edges</code> 组成，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> 表示 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code><sub> </sub>之间有一条无向边。同时给你一个代表查询的整数数组 <code>queries</code> 。</p>\n\n<p>第 <code>j</code> 个查询的答案是满足如下条件的点对 <code>(a, b)</code> 的数目：</p>\n\n<ul>\n\t<li><code>a < b</code></li>\n\t<li><code>cnt</code> 是与 <code>a</code> <strong>或者 </strong><code>b</code> 相连的边的数目，且 <code>cnt</code> <strong>严格大于 </strong><code>queries[j]</code> 。</li>\n</ul>\n\n<p>请你返回一个数组 <code>answers</code> ，其中 <code>answers.length == queries.length</code> 且 <code>answers[j]</code> 是第 <code>j</code> 个查询的答案。</p>\n\n<p>请注意，图中可能会有 <strong>重复边</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://pic.leetcode-cn.com/1614828447-GMnLVg-image.png\" style=\"width: 310px; height: 278px;\" />\n<pre>\n<b>输入：</b>n = 4, edges = [[1,2],[2,4],[1,3],[2,3],[2,1]], queries = [2,3]\n<b>输出：</b>[6,5]\n<b>解释：</b>每个点对中，与至少一个点相连的边的数目如上图所示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5, edges = [[1,5],[1,5],[3,4],[2,5],[1,3],[5,1],[2,3],[2,5]], queries = [1,2,3,4,5]\n<b>输出：</b>[10,10,9,8,6]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= edges.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= u<sub>i</sub>, v<sub>i</sub> <= n</code></li>\n\t<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>\n\t<li><code>1 <= queries.length <= 20</code></li>\n\t<li><code>0 <= queries[j] < edges.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1783大满贯数量",
        "hardRate": "MEDIUM",
        "passRate": "80.54%",
        "problemsUrl": "https://leetcode.cn/problems/grand-slam-titles/",
        "solutionsUrl": "https://leetcode.cn/problems/grand-slam-titles/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1784检查二进制字符串字段",
        "hardRate": "EASY",
        "passRate": "59.47%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-binary-string-has-at-most-one-segment-of-ones/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-binary-string-has-at-most-one-segment-of-ones/solution",
        "problemsDesc": "<p>给你一个二进制字符串 <code>s</code> ，该字符串 <strong>不含前导零</strong> 。</p>\n\n<p>如果 <code>s</code> 包含 <strong>零个或一个由连续的 <code>'1'</code> 组成的字段</strong> ，返回 <code>true</code>​​​ 。否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1001\"\n<strong>输出：</strong>false\n<strong>解释：</strong>由连续若干个&nbsp;<code>'1'</code> 组成的字段数量为 2，返回 false\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"110\"\n<strong>输出：</strong>true</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s[i]</code>​​​​ 为 <code>'0'</code> 或 <code>'1'</code></li>\n\t<li><code>s[0]</code> 为 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1785构成特定和需要添加的最少元素",
        "hardRate": "MEDIUM",
        "passRate": "43.55%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-elements-to-add-to-form-a-given-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-elements-to-add-to-form-a-given-sum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，和两个整数 <code>limit</code> 与 <code>goal</code> 。数组 <code>nums</code> 有一条重要属性：<code>abs(nums[i]) <= limit</code> 。</p>\n\n<p>返回使数组元素总和等于 <code>goal</code> 所需要向数组中添加的 <strong>最少元素数量</strong> ，添加元素 <strong>不应改变</strong> 数组中 <code>abs(nums[i]) <= limit</code> 这一属性。</p>\n\n<p>注意，如果 <code>x >= 0</code> ，那么 <code>abs(x)</code> 等于 <code>x</code> ；否则，等于 <code>-x</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,-1,1], limit = 3, goal = -4\n<strong>输出：</strong>2\n<strong>解释：</strong>可以将 -2 和 -3 添加到数组中，数组的元素总和变为 1 - 1 + 1 - 2 - 3 = -4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,-10,9,1], limit = 100, goal = 0\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= limit <= 10<sup>6</sup></code></li>\n\t<li><code>-limit <= nums[i] <= limit</code></li>\n\t<li><code>-10<sup>9</sup> <= goal <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1786从第一个节点出发到最后一个节点的受限路径数",
        "hardRate": "MEDIUM",
        "passRate": "36.39%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-restricted-paths-from-first-to-last-node/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-restricted-paths-from-first-to-last-node/solution",
        "problemsDesc": "<p>现有一个加权无向连通图。给你一个正整数 <code>n</code> ，表示图中有 <code>n</code> 个节点，并按从 <code>1</code> 到 <code>n</code> 给节点编号；另给你一个数组 <code>edges</code> ，其中每个 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, weight<sub>i</sub>]</code> 表示存在一条位于节点 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code> 之间的边，这条边的权重为 <code>weight<sub>i</sub></code> 。</p>\n\n<p>从节点 <code>start</code> 出发到节点 <code>end</code> 的路径是一个形如 <code>[z<sub>0</sub>, z<sub>1</sub>,<sub> </sub>z<sub>2</sub>, ..., z<sub>k</sub>]</code> 的节点序列，满足 <code>z<sub>0 </sub>= start</code> 、<code>z<sub>k</sub> = end</code> 且在所有符合 <code>0 <= i <= k-1</code> 的节点 <code>z<sub>i</sub></code> 和 <code>z<sub>i+1</sub></code> 之间存在一条边。</p>\n\n<p>路径的距离定义为这条路径上所有边的权重总和。用 <code>distanceToLastNode(x)</code> 表示节点 <code>n</code> 和 <code>x</code> 之间路径的最短距离。<strong>受限路径</strong> 为满足 <code>distanceToLastNode(z<sub>i</sub>) > distanceToLastNode(z<sub>i+1</sub>)</code> 的一条路径，其中 <code>0 <= i <= k-1</code> 。</p>\n\n<p>返回从节点 <code>1</code> 出发到节点 <code>n</code> 的 <strong>受限路径数</strong> 。由于数字可能很大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/07/restricted_paths_ex1.png\" style=\"width: 351px; height: 341px;\" />\n<pre>\n<strong>输入：</strong>n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]]\n<strong>输出：</strong>3\n<strong>解释：</strong>每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。三条受限路径分别是：\n1) 1 --> 2 --> 5\n2) 1 --> 2 --> 3 --> 5\n3) 1 --> 3 --> 5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/07/restricted_paths_ex22.png\" style=\"width: 356px; height: 401px;\" />\n<pre>\n<strong>输入：</strong>n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]]\n<strong>输出：</strong>1\n<strong>解释：</strong>每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。唯一一条受限路径是：1 --> 3 --> 7 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 2 * 10<sup>4</sup></code></li>\n\t<li><code>n - 1 <= edges.length <= 4 * 10<sup>4</sup></code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>1 <= u<sub>i</sub>, v<sub>i</sub> <= n</code></li>\n\t<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>\n\t<li><code>1 <= weight<sub>i</sub> <= 10<sup>5</sup></code></li>\n\t<li>任意两个节点之间至多存在一条边</li>\n\t<li>任意两个节点之间至少存在一条路径</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1787使所有区间的异或结果为零",
        "hardRate": "HARD",
        "passRate": "64.31%",
        "problemsUrl": "https://leetcode.cn/problems/make-the-xor-of-all-segments-equal-to-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/make-the-xor-of-all-segments-equal-to-zero/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>​​​ 和一个整数 <code>k</code>​​​​​ 。区间 <code>[left, right]</code>（<code>left <= right</code>）的 <strong>异或结果</strong> 是对下标位于 <code>left</code> 和 <code>right</code>（包括 <code>left</code> 和 <code>right</code> ）之间所有元素进行 <code>XOR</code> 运算的结果：<code>nums[left] XOR nums[left+1] XOR ... XOR nums[right]</code> 。</p>\n\n<p>返回数组中 <strong>要更改的最小元素数</strong> ，以使所有长度为 <code>k</code> 的区间异或结果等于零。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,0,3,0], k = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>将数组 [<strong>1</strong>,<strong>2</strong>,0,<strong>3</strong>,0] 修改为 [<strong>0</strong>,<strong>0</strong>,0,<strong>0</strong>,0]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,5,2,1,7,3,4,7], k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>将数组 [3,4,<strong>5</strong>,<strong>2</strong>,<strong>1</strong>,7,3,4,7] 修改为 [3,4,<strong>7</strong>,<strong>3</strong>,<strong>4</strong>,7,3,4,7]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,4,1,2,5,1,2,6], k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>将数组[1,2,<strong>4,</strong>1,2,<strong>5</strong>,1,2,<strong>6</strong>] 修改为 [1,2,<strong>3</strong>,1,2,<strong>3</strong>,1,2,<strong>3</strong>]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= k <= nums.length <= 2000</code></li>\n\t<li><code>​​​​​​0 <= nums[i] < 2<sup>10</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1788最大化花园的美观度",
        "hardRate": "HARD",
        "passRate": "65.45%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-the-beauty-of-the-garden/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-the-beauty-of-the-garden/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1789员工的直属部门",
        "hardRate": "EASY",
        "passRate": "71.85%",
        "problemsUrl": "https://leetcode.cn/problems/primary-department-for-each-employee/",
        "solutionsUrl": "https://leetcode.cn/problems/primary-department-for-each-employee/solution",
        "problemsDesc": "<p>Table: <code>Employee</code></p>\n\n<pre>+---------------+---------+\n| Column Name   |  Type   |\n+---------------+---------+\n| employee_id   | int     |\n| department_id | int     |\n| primary_flag  | varchar |\n+---------------+---------+\n这张表的主键为 employee_id, department_id\nemployee_id 是员工的ID\ndepartment_id 是部门的ID，表示员工与该部门有关系\nprimary_flag 是一个枚举类型，值分别为('Y', 'N'). 如果值为'Y',表示该部门是员工的直属部门。 如果值是'N',则否\n</pre>\n\n<p> </p>\n\n<p>一个员工可以属于多个部门。</p>\n\n<p>当一个员工加入<strong>超过一个部门</strong>的时候，他需要决定哪个部门是他的直属部门。</p>\n\n<p>请注意，当员工只加入一个部门的时候，那这个部门将默认为他的直属部门，虽然表记录的值为<code>'N'</code>.</p>\n\n<p>请编写一段SQL，查出员工所属的直属部门。</p>\n\n<p>返回结果没有顺序要求。</p>\n\n<p> </p>\n\n<p>示例：</p>\n\n<pre>Employee table:\n+-------------+---------------+--------------+\n| employee_id | department_id | primary_flag |\n+-------------+---------------+--------------+\n| 1           | 1             | N            |\n| 2           | 1             | Y            |\n| 2           | 2             | N            |\n| 3           | 3             | N            |\n| 4           | 2             | N            |\n| 4           | 3             | Y            |\n| 4           | 4             | N            |\n+-------------+---------------+--------------+\n\nResult table:\n+-------------+---------------+\n| employee_id | department_id |\n+-------------+---------------+\n| 1           | 1             |\n| 2           | 1             |\n| 3           | 3             |\n| 4           | 3             |\n+-------------+---------------+\n- 员工1的直属部门是1\n- 员工2的直属部门是1\n- 员工3的直属部门是3\n- 员工4的直属部门是3</pre>\n\n<p> </p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1790仅执行一次字符串交换能否使两个字符串相等",
        "hardRate": "EASY",
        "passRate": "52.52%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-one-string-swap-can-make-strings-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-one-string-swap-can-make-strings-equal/solution",
        "problemsDesc": "<p>给你长度相等的两个字符串 <code>s1</code> 和 <code>s2</code> 。一次<strong> 字符串交换 </strong>操作的步骤如下：选出某个字符串中的两个下标（不必不同），并交换这两个下标所对应的字符。</p>\n\n<p>如果对 <strong>其中一个字符串</strong> 执行 <strong>最多一次字符串交换</strong> 就可以使两个字符串相等，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"bank\", s2 = \"kanb\"\n<strong>输出：</strong>true\n<strong>解释：</strong>例如，交换 s2 中的第一个和最后一个字符可以得到 \"bank\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"attack\", s2 = \"defend\"\n<strong>输出：</strong>false\n<strong>解释：</strong>一次字符串交换无法使两个字符串相等\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"kelb\", s2 = \"kelb\"\n<strong>输出：</strong>true\n<strong>解释：</strong>两个字符串已经相等，所以不需要进行字符串交换\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"abcd\", s2 = \"dcba\"\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 100</code></li>\n\t<li><code>s1.length == s2.length</code></li>\n\t<li><code>s1</code> 和 <code>s2</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1791找出星型图的中心节点",
        "hardRate": "EASY",
        "passRate": "83.07%",
        "problemsUrl": "https://leetcode.cn/problems/find-center-of-star-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/find-center-of-star-graph/solution",
        "problemsDesc": "<p>有一个无向的 <strong>星型</strong> 图，由 <code>n</code> 个编号从 <code>1</code> 到 <code>n</code> 的节点组成。星型图有一个 <strong>中心</strong> 节点，并且恰有 <code>n - 1</code> 条边将中心节点与其他每个节点连接起来。</p>\n\n<p>给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> 表示在节点 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code> 之间存在一条边。请你找出并返回 <code>edges</code> 所表示星型图的中心节点。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/14/star_graph.png\" style=\"width: 331px; height: 321px;\" />\n<pre>\n<strong>输入：</strong>edges = [[1,2],[2,3],[4,2]]\n<strong>输出：</strong>2\n<strong>解释：</strong>如上图所示，节点 2 与其他每个节点都相连，所以节点 2 是中心节点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>edges = [[1,2],[5,1],[1,3],[1,4]]\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 <= u<sub>i,</sub> v<sub>i</sub> <= n</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n\t<li>题目数据给出的 <code>edges</code> 表示一个有效的星型图</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1792最大平均通过率",
        "hardRate": "MEDIUM",
        "passRate": "58.83%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-average-pass-ratio/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-average-pass-ratio/solution",
        "problemsDesc": "<p>一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 <code>classes</code> ，其中 <code>classes[i] = [pass<sub>i</sub>, total<sub>i</sub>]</code> ，表示你提前知道了第 <code>i</code> 个班级总共有 <code>total<sub>i</sub></code> 个学生，其中只有 <code>pass<sub>i</sub></code> 个学生可以通过考试。</p>\n\n<p>给你一个整数 <code>extraStudents</code> ，表示额外有 <code>extraStudents</code> 个聪明的学生，他们 <strong>一定</strong> 能通过任何班级的期末考。你需要给这 <code>extraStudents</code> 个学生每人都安排一个班级，使得 <strong>所有</strong> 班级的 <strong>平均</strong> 通过率 <strong>最大</strong> 。</p>\n\n<p>一个班级的 <strong>通过率</strong> 等于这个班级通过考试的学生人数除以这个班级的总人数。<strong>平均通过率</strong> 是所有班级的通过率之和除以班级数目。</p>\n\n<p>请你返回在安排这 <code><span style=\"\">extraStudents</span></code> 个学生去对应班级后的 <strong>最大</strong> 平均通过率。与标准答案误差范围在 <code>10<sup>-5</sup></code> 以内的结果都会视为正确结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>classes = [[1,2],[3,5],[2,2]], <code>extraStudents</code> = 2\n<b>输出：</b>0.78333\n<b>解释：</b>你可以将额外的两个学生都安排到第一个班级，平均通过率为 (3/4 + 3/5 + 2/2) / 3 = 0.78333 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>classes = [[2,4],[3,9],[4,5],[2,10]], <code>extraStudents</code> = 4\n<strong>输出：</strong>0.53485\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= classes.length <= 10<sup>5</sup></code></li>\n\t<li><code>classes[i].length == 2</code></li>\n\t<li><code>1 <= pass<sub>i</sub> <= total<sub>i</sub> <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= extraStudents <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1793好子数组的最大分数",
        "hardRate": "HARD",
        "passRate": "45.51%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-of-a-good-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-of-a-good-subarray/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> <strong>（下标从 0 开始）</strong>和一个整数 <code>k</code> 。</p>\n\n<p>一个子数组 <code>(i, j)</code> 的 <strong>分数</strong> 定义为 <code>min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)</code> 。一个 <strong>好</strong> 子数组的两个端点下标需要满足 <code>i &lt;= k &lt;= j</code> 。</p>\n\n<p>请你返回 <strong>好</strong> 子数组的最大可能 <strong>分数</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,4,3,7,4,5], k = 3\n<b>输出：</b>15\n<b>解释：</b>最优子数组的左右端点下标是 (1, 5) ，分数为 min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [5,5,4,5,4,1,1,1], k = 0\n<b>输出：</b>20\n<b>解释：</b>最优子数组的左右端点下标是 (0, 4) ，分数为 min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= k &lt; nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1794统计距离最小的子串对个数",
        "hardRate": "MEDIUM",
        "passRate": "55.28%",
        "problemsUrl": "https://leetcode.cn/problems/count-pairs-of-equal-substrings-with-minimum-difference/",
        "solutionsUrl": "https://leetcode.cn/problems/count-pairs-of-equal-substrings-with-minimum-difference/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1795每个产品在不同商店的价格",
        "hardRate": "EASY",
        "passRate": "78.20%",
        "problemsUrl": "https://leetcode.cn/problems/rearrange-products-table/",
        "solutionsUrl": "https://leetcode.cn/problems/rearrange-products-table/solution",
        "problemsDesc": "<p>表：<code>Products</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| product_id  | int     |\n| store1      | int     |\n| store2      | int     |\n| store3      | int     |\n+-------------+---------+\n这张表的主键是product_id（产品Id）。\n每行存储了这一产品在不同商店store1, store2, store3的价格。\n如果这一产品在商店里没有出售，则值将为null。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>请你重构 <code>Products</code> 表，查询每个产品在不同商店的价格，使得输出的格式变为<code>(product_id, store, price)</code> 。如果这一产品在商店里没有出售，则不输出这一行。</p>\n\n<p>输出结果表中的 <strong>顺序不作要求</strong> 。</p>\n\n<p>查询输出格式请参考下面示例。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nProducts table:\n+------------+--------+--------+--------+\n| product_id | store1 | store2 | store3 |\n+------------+--------+--------+--------+\n| 0          | 95     | 100    | 105    |\n| 1          | 70     | null   | 80     |\n+------------+--------+--------+--------+\n<strong>输出：</strong>\n+------------+--------+-------+\n| product_id | store  | price |\n+------------+--------+-------+\n| 0          | store1 | 95    |\n| 0          | store2 | 100   |\n| 0          | store3 | 105   |\n| 1          | store1 | 70    |\n| 1          | store3 | 80    |\n+------------+--------+-------+\n<strong>解释：</strong>\n产品0在store1，store2,store3的价格分别为95,100,105。\n产品1在store1，store3的价格分别为70,80。在store2无法买到。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1796字符串中第二大的数字",
        "hardRate": "EASY",
        "passRate": "54.88%",
        "problemsUrl": "https://leetcode.cn/problems/second-largest-digit-in-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/second-largest-digit-in-a-string/solution",
        "problemsDesc": "<p>给你一个混合字符串 <code>s</code> ，请你返回 <code>s</code> 中 <strong>第二大 </strong>的数字，如果不存在第二大的数字，请你返回 <code>-1</code> 。</p>\n\n<p><strong>混合字符串 </strong>由小写英文字母和数字组成。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"dfa12321afd\"\n<b>输出：</b>2\n<b>解释：</b>出现在 s 中的数字包括 [1, 2, 3] 。第二大的数字是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"abc1111\"\n<b>输出：</b>-1\n<b>解释：</b>出现在 s 中的数字只包含 [1] 。没有第二大的数字。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 500</code></li>\n\t<li><code>s</code> 只包含小写英文字母和（或）数字。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1797设计一个验证系统",
        "hardRate": "MEDIUM",
        "passRate": "64.94%",
        "problemsUrl": "https://leetcode.cn/problems/design-authentication-manager/",
        "solutionsUrl": "https://leetcode.cn/problems/design-authentication-manager/solution",
        "problemsDesc": "<p>你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在 <code>currentTime</code> 时刻之后 <code>timeToLive</code> 秒过期。如果验证码被更新了，那么它会在 <code>currentTime</code> （可能与之前的 <code>currentTime</code> 不同）时刻延长 <code>timeToLive</code> 秒。</p>\n\n<p>请你实现 <code>AuthenticationManager</code> 类：</p>\n\n<ul>\n\t<li><code>AuthenticationManager(int timeToLive)</code> 构造 <code>AuthenticationManager</code> 并设置 <code>timeToLive</code> 参数。</li>\n\t<li><code>generate(string tokenId, int currentTime)</code> 给定 <code>tokenId</code> ，在当前时间 <code>currentTime</code> 生成一个新的验证码。</li>\n\t<li><code>renew(string tokenId, int currentTime)</code> 将给定 <code>tokenId</code> 且 <strong>未过期</strong> 的验证码在 <code>currentTime</code> 时刻更新。如果给定 <code>tokenId</code> 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。</li>\n\t<li><code>countUnexpiredTokens(int currentTime)</code> 请返回在给定 <code>currentTime</code> 时刻，<strong>未过期</strong> 的验证码数目。</li>\n</ul>\n\n<p>如果一个验证码在时刻 <code>t</code> 过期，且另一个操作恰好在时刻 <code>t</code> 发生（<code>renew</code> 或者 <code>countUnexpiredTokens</code> 操作），过期事件 <strong>优先于</strong> 其他操作。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/25/copy-of-pc68_q2.png\" style=\"width: 500px; height: 287px;\" />\n<pre>\n<strong>输入：</strong>\n[\"AuthenticationManager\", \"<code>renew</code>\", \"generate\", \"<code>countUnexpiredTokens</code>\", \"generate\", \"<code>renew</code>\", \"<code>renew</code>\", \"<code>countUnexpiredTokens</code>\"]\n[[5], [\"aaa\", 1], [\"aaa\", 2], [6], [\"bbb\", 7], [\"aaa\", 8], [\"bbb\", 10], [15]]\n<strong>输出：</strong>\n[null, null, null, 1, null, null, null, 0]\n\n<strong>解释：</strong>\nAuthenticationManager authenticationManager = new AuthenticationManager(5); // 构造 AuthenticationManager ，设置 <code>timeToLive</code> = 5 秒。\nauthenticationManager.<code>renew</code>(\"aaa\", 1); // 时刻 1 时，没有验证码的 tokenId 为 \"aaa\" ，没有验证码被更新。\nauthenticationManager.generate(\"aaa\", 2); // 时刻 2 时，生成一个 tokenId 为 \"aaa\" 的新验证码。\nauthenticationManager.<code>countUnexpiredTokens</code>(6); // 时刻 6 时，只有 tokenId 为 \"aaa\" 的验证码未过期，所以返回 1 。\nauthenticationManager.generate(\"bbb\", 7); // 时刻 7 时，生成一个 tokenId 为 \"bbb\" 的新验证码。\nauthenticationManager.<code>renew</code>(\"aaa\", 8); // tokenId 为 \"aaa\" 的验证码在时刻 7 过期，且 8 >= 7 ，所以时刻 8 的renew 操作被忽略，没有验证码被更新。\nauthenticationManager.<code>renew</code>(\"bbb\", 10); // tokenId 为 \"bbb\" 的验证码在时刻 10 没有过期，所以 renew 操作会执行，该 token 将在时刻 15 过期。\nauthenticationManager.<code>countUnexpiredTokens</code>(15); // tokenId 为 \"bbb\" 的验证码在时刻 15 过期，tokenId 为 \"aaa\" 的验证码在时刻 7 过期，所有验证码均已过期，所以返回 0 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= timeToLive <= 10<sup>8</sup></code></li>\n\t<li><code>1 <= currentTime <= 10<sup>8</sup></code></li>\n\t<li><code>1 <= tokenId.length <= 5</code></li>\n\t<li><code>tokenId</code> 只包含小写英文字母。</li>\n\t<li>所有 <code>generate</code> 函数的调用都会包含独一无二的 <code>tokenId</code> 值。</li>\n\t<li>所有函数调用中，<code>currentTime</code> 的值 <strong>严格递增</strong> 。</li>\n\t<li>所有函数的调用次数总共不超过 <code>2000</code> 次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1798你能构造出连续值的最大数目",
        "hardRate": "MEDIUM",
        "passRate": "70.97%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-consecutive-values-you-can-make/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-consecutive-values-you-can-make/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的整数数组 <code>coins</code> ，它代表你拥有的 <code>n</code> 个硬币。第 <code>i</code> 个硬币的值为 <code>coins[i]</code> 。如果你从这些硬币中选出一部分硬币，它们的和为 <code>x</code> ，那么称，你可以 <strong>构造</strong> 出 <code>x</code> 。</p>\n\n<p>请返回从 <code>0</code> 开始（<strong>包括</strong> <code>0</code> ），你最多能 <strong>构造</strong> 出多少个连续整数。</p>\n\n<p>你可能有多个相同值的硬币。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>coins = [1,3]\n<b>输出：</b>2\n<strong>解释：</strong>你可以得到以下这些值：\n- 0：什么都不取 []\n- 1：取 [1]\n从 0 开始，你可以构造出 2 个连续整数。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>coins = [1,1,1,4]\n<b>输出：</b>8\n<strong>解释：</strong>你可以得到以下这些值：\n- 0：什么都不取 []\n- 1：取 [1]\n- 2：取 [1,1]\n- 3：取 [1,1,1]\n- 4：取 [4]\n- 5：取 [4,1]\n- 6：取 [4,1,1]\n- 7：取 [4,1,1,1]\n从 0 开始，你可以构造出 8 个连续整数。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,4,10,3,1]\n<b>输出：</b>20</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>coins.length == n</code></li>\n\t<li><code>1 <= n <= 4 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= coins[i] <= 4 * 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1799N 次操作后的最大分数和",
        "hardRate": "HARD",
        "passRate": "65.69%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-score-after-n-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-score-after-n-operations/solution",
        "problemsDesc": "<p>给你 <code>nums</code> ，它是一个大小为 <code>2 * n</code> 的正整数数组。你必须对这个数组执行 <code>n</code> 次操作。</p>\n\n<p>在第 <code>i</code> 次操作时（操作编号从 <strong>1</strong> 开始），你需要：</p>\n\n<ul>\n\t<li>选择两个元素 <code>x</code> 和 <code>y</code> 。</li>\n\t<li>获得分数 <code>i * gcd(x, y)</code> 。</li>\n\t<li>将 <code>x</code> 和 <code>y</code> 从 <code>nums</code> 中删除。</li>\n</ul>\n\n<p>请你返回 <code>n</code> 次操作后你能获得的分数和最大为多少。</p>\n\n<p>函数 <code>gcd(x, y)</code> 是 <code>x</code> 和 <code>y</code> 的最大公约数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2]\n<b>输出：</b>1\n<b>解释：</b>最优操作是：\n(1 * gcd(1, 2)) = 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [3,4,6,8]\n<b>输出：</b>11\n<b>解释：</b>最优操作是：\n(1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4,5,6]\n<b>输出：</b>14\n<b>解释：</b>最优操作是：\n(1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 7</code></li>\n\t<li><code>nums.length == 2 * n</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1800最大升序子数组和",
        "hardRate": "EASY",
        "passRate": "68.71%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-ascending-subarray-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-ascending-subarray-sum/solution",
        "problemsDesc": "<p>给你一个正整数组成的数组 <code>nums</code> ，返回 <code>nums</code> 中一个 <strong>升序 </strong>子数组的最大可能元素和。</p>\n\n<p>子数组是数组中的一个连续数字序列。</p>\n\n<p>已知子数组 <code>[nums<sub>l</sub>, nums<sub>l+1</sub>, ..., nums<sub>r-1</sub>, nums<sub>r</sub>]</code> ，若对所有 <code>i</code>（<code>l <= i < r</code>），<code>nums<sub>i </sub> < nums<sub>i+1</sub></code> 都成立，则称这一子数组为 <strong>升序</strong> 子数组。注意，大小为 <code>1</code> 的子数组也视作 <strong>升序</strong> 子数组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,20,30,5,10,50]\n<strong>输出：</strong>65\n<strong>解释：</strong>[5,10,50] 是元素和最大的升序子数组，最大元素和为 65 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,20,30,40,50]\n<strong>输出：</strong>150\n<strong>解释：</strong>[10,20,30,40,50] 是元素和最大的升序子数组，最大元素和为 150 。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [12,17,15,13,10,11,12]\n<strong>输出：</strong>33\n<strong>解释：</strong>[10,11,12] 是元素和最大的升序子数组，最大元素和为 33 。 \n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [100,10,1]\n<strong>输出：</strong>100\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 100</code></li>\n\t<li><code>1 <= nums[i] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1801积压订单中的订单总数",
        "hardRate": "MEDIUM",
        "passRate": "53.23%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-orders-in-the-backlog/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-orders-in-the-backlog/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>orders</code> ，其中每个 <code>orders[i] = [price<sub>i</sub>, amount<sub>i</sub>, orderType<sub>i</sub>]</code> 表示有 <code>amount<sub>i</sub></code><sub> </sub>笔类型为 <code>orderType<sub>i</sub></code> 、价格为 <code>price<sub>i</sub></code> 的订单。</p>\n\n<p>订单类型 <code>orderType<sub>i</sub></code> 可以分为两种：</p>\n\n<ul>\n\t<li><code>0</code> 表示这是一批采购订单 <code>buy</code></li>\n\t<li><code>1</code> 表示这是一批销售订单 <code>sell</code></li>\n</ul>\n\n<p>注意，<code>orders[i]</code> 表示一批共计 <code>amount<sub>i</sub></code> 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 <code>i</code> ，由 <code>orders[i]</code> 表示的所有订单提交时间均早于 <code>orders[i+1]</code> 表示的所有订单。</p>\n\n<p>存在由未执行订单组成的 <strong>积压订单</strong> 。积压订单最初是空的。提交订单时，会发生以下情况：</p>\n\n<ul>\n\t<li>如果该订单是一笔采购订单 <code>buy</code> ，则可以查看积压订单中价格 <strong>最低</strong> 的销售订单 <code>sell</code> 。如果该销售订单 <code>sell</code> 的价格 <strong>低于或等于</strong> 当前采购订单 <code>buy</code> 的价格，则匹配并执行这两笔订单，并将销售订单 <code>sell</code> 从积压订单中删除。否则，采购订单 <code>buy</code> 将会添加到积压订单中。</li>\n\t<li>反之亦然，如果该订单是一笔销售订单 <code>sell</code> ，则可以查看积压订单中价格 <strong>最高</strong> 的采购订单 <code>buy</code> 。如果该采购订单 <code>buy</code> 的价格 <strong>高于或等于</strong> 当前销售订单 <code>sell</code> 的价格，则匹配并执行这两笔订单，并将采购订单 <code>buy</code> 从积压订单中删除。否则，销售订单 <code>sell</code> 将会添加到积压订单中。</li>\n</ul>\n\n<p>输入所有订单后，返回积压订单中的 <strong>订单总数</strong> 。由于数字可能很大，所以需要返回对 <code>10<sup>9</sup> + 7</code> 取余的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/21/ex1.png\" style=\"width: 450px; height: 479px;\" />\n<pre>\n<strong>输入：</strong>orders = [[10,5,0],[15,2,1],[25,1,1],[30,4,0]]\n<strong>输出：</strong>6\n<strong>解释：</strong>输入订单后会发生下述情况：\n- 提交 5 笔采购订单，价格为 10 。没有销售订单，所以这 5 笔订单添加到积压订单中。\n- 提交 2 笔销售订单，价格为 15 。没有采购订单的价格大于或等于 15 ，所以这 2 笔订单添加到积压订单中。\n- 提交 1 笔销售订单，价格为 25 。没有采购订单的价格大于或等于 25 ，所以这 1 笔订单添加到积压订单中。\n- 提交 4 笔采购订单，价格为 30 。前 2 笔采购订单与价格最低（价格为 15）的 2 笔销售订单匹配，从积压订单中删除这 2 笔销售订单。第 3 笔采购订单与价格最低的 1 笔销售订单匹配，销售订单价格为 25 ，从积压订单中删除这 1 笔销售订单。积压订单中不存在更多销售订单，所以第 4 笔采购订单需要添加到积压订单中。\n最终，积压订单中有 5 笔价格为 10 的采购订单，和 1 笔价格为 30 的采购订单。所以积压订单中的订单总数为 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/21/ex2.png\" style=\"width: 450px; height: 584px;\" />\n<pre>\n<strong>输入：</strong>orders = [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]]\n<strong>输出：</strong>999999984\n<strong>解释：</strong>输入订单后会发生下述情况：\n- 提交 10<sup>9</sup> 笔销售订单，价格为 7 。没有采购订单，所以这 10<sup>9</sup> 笔订单添加到积压订单中。\n- 提交 3 笔采购订单，价格为 15 。这些采购订单与价格最低（价格为 7 ）的 3 笔销售订单匹配，从积压订单中删除这 3 笔销售订单。\n- 提交 999999995 笔采购订单，价格为 5 。销售订单的最低价为 7 ，所以这 999999995 笔订单添加到积压订单中。\n- 提交 1 笔销售订单，价格为 5 。这笔销售订单与价格最高（价格为 5 ）的 1 笔采购订单匹配，从积压订单中删除这 1 笔采购订单。\n最终，积压订单中有 (1000000000-3) 笔价格为 7 的销售订单，和 (999999995-1) 笔价格为 5 的采购订单。所以积压订单中的订单总数为 1999999991 ，等于 999999984 % (10<sup>9</sup> + 7) 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= orders.length <= 10<sup>5</sup></code></li>\n\t<li><code>orders[i].length == 3</code></li>\n\t<li><code>1 <= price<sub>i</sub>, amount<sub>i</sub> <= 10<sup>9</sup></code></li>\n\t<li><code>orderType<sub>i</sub></code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1802有界数组中指定下标处的最大值",
        "hardRate": "MEDIUM",
        "passRate": "38.07%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-value-at-a-given-index-in-a-bounded-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-value-at-a-given-index-in-a-bounded-array/solution",
        "problemsDesc": "<p>给你三个正整数 <code>n</code>、<code>index</code> 和 <code>maxSum</code> 。你需要构造一个同时满足下述所有条件的数组 <code>nums</code>（下标 <strong>从 0 开始</strong> 计数）：</p>\n\n<ul>\n\t<li><code>nums.length == n</code></li>\n\t<li><code>nums[i]</code> 是 <strong>正整数</strong> ，其中 <code>0 &lt;= i &lt; n</code></li>\n\t<li><code>abs(nums[i] - nums[i+1]) &lt;= 1</code> ，其中 <code>0 &lt;= i &lt; n-1</code></li>\n\t<li><code>nums</code> 中所有元素之和不超过 <code>maxSum</code></li>\n\t<li><code>nums[index]</code> 的值被 <strong>最大化</strong></li>\n</ul>\n\n<p>返回你所构造的数组中的 <code>nums[index]</code> 。</p>\n\n<p>注意：<code>abs(x)</code> 等于 <code>x</code> 的前提是 <code>x &gt;= 0</code> ；否则，<code>abs(x)</code> 等于 <code>-x</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 4, index = 2,  maxSum = 6\n<strong>输出：</strong>2\n<strong>解释：</strong>数组 [1,1,<strong>2</strong>,1] 和 [1,2,<strong>2</strong>,1] 满足所有条件。不存在其他在指定下标处具有更大值的有效数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 6, index = 1,  maxSum = 10\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= maxSum &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= index &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1803统计异或值在范围内的数对有多少",
        "hardRate": "HARD",
        "passRate": "56.32%",
        "problemsUrl": "https://leetcode.cn/problems/count-pairs-with-xor-in-a-range/",
        "solutionsUrl": "https://leetcode.cn/problems/count-pairs-with-xor-in-a-range/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> （下标 <strong>从 0 开始</strong> 计数）以及两个整数：<code>low</code> 和 <code>high</code> ，请返回 <strong>漂亮数对</strong> 的数目。</p>\n\n<p><strong>漂亮数对</strong> 是一个形如 <code>(i, j)</code> 的数对，其中 <code>0 &lt;= i &lt; j &lt; nums.length</code> 且 <code>low &lt;= (nums[i] XOR nums[j]) &lt;= high</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,4,2,7], low = 2, high = 6\n<strong>输出：</strong>6\n<strong>解释：</strong>所有漂亮数对 (i, j) 列出如下：\n    - (0, 1): nums[0] XOR nums[1] = 5 \n    - (0, 2): nums[0] XOR nums[2] = 3\n    - (0, 3): nums[0] XOR nums[3] = 6\n    - (1, 2): nums[1] XOR nums[2] = 6\n    - (1, 3): nums[1] XOR nums[3] = 3\n    - (2, 3): nums[2] XOR nums[3] = 5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [9,8,4,2,1], low = 5, high = 14\n<strong>输出：</strong>8\n<strong>解释：</strong>所有漂亮数对 (i, j) 列出如下：\n​​​​​    - (0, 2): nums[0] XOR nums[2] = 13\n    - (0, 3): nums[0] XOR nums[3] = 11\n    - (0, 4): nums[0] XOR nums[4] = 8\n    - (1, 2): nums[1] XOR nums[2] = 12\n    - (1, 3): nums[1] XOR nums[3] = 10\n    - (1, 4): nums[1] XOR nums[4] = 9\n    - (2, 3): nums[2] XOR nums[3] = 6\n    - (2, 4): nums[2] XOR nums[4] = 5</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= low &lt;= high &lt;= 2 * 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1804实现 Trie （前缀树） II",
        "hardRate": "MEDIUM",
        "passRate": "57.16%",
        "problemsUrl": "https://leetcode.cn/problems/implement-trie-ii-prefix-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/implement-trie-ii-prefix-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1805字符串中不同整数的数目",
        "hardRate": "EASY",
        "passRate": "43.18%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-different-integers-in-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-different-integers-in-a-string/solution",
        "problemsDesc": "<p>给你一个字符串 <code>word</code> ，该字符串由数字和小写英文字母组成。</p>\n\n<p>请你用空格替换每个不是数字的字符。例如，<code>\"a123bc34d8ef34\"</code> 将会变成 <code>\" 123  34 8  34\"</code> 。注意，剩下的这些整数为（相邻彼此至少有一个空格隔开）：<code>\"123\"</code>、<code>\"34\"</code>、<code>\"8\"</code> 和 <code>\"34\"</code> 。</p>\n\n<p>返回对 <code>word</code> 完成替换后形成的 <strong>不同</strong> 整数的数目。</p>\n\n<p>只有当两个整数的 <strong>不含前导零</strong> 的十进制表示不同， 才认为这两个整数也不同。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"a<strong>123</strong>bc<strong>34</strong>d<strong>8</strong>ef<strong>34</strong>\"\n<strong>输出：</strong>3\n<strong>解释：</strong>不同的整数有 \"123\"、\"34\" 和 \"8\" 。注意，\"34\" 只计数一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"leet<strong>1234</strong>code<strong>234</strong>\"\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"a<strong>1</strong>b<strong>01</strong>c<strong>001</strong>\"\n<strong>输出：</strong>1\n<strong>解释：</strong>\"1\"、\"01\" 和 \"001\" 视为同一个整数的十进制表示，因为在比较十进制值时会忽略前导零的存在。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word.length <= 1000</code></li>\n\t<li><code>word</code> 由数字和小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1806还原排列的最少操作步数",
        "hardRate": "MEDIUM",
        "passRate": "76.70%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/solution",
        "problemsDesc": "<p>给你一个偶数 <code>n</code>​​​​​​ ，已知存在一个长度为 <code>n</code> 的排列 <code>perm</code> ，其中 <code>perm[i] == i</code>​（下标 <strong>从 0 开始</strong> 计数）。</p>\n\n<p>一步操作中，你将创建一个新数组 <code>arr</code> ，对于每个 <code>i</code> ：</p>\n\n<ul>\n\t<li>如果 <code>i % 2 == 0</code> ，那么 <code>arr[i] = perm[i / 2]</code></li>\n\t<li>如果 <code>i % 2 == 1</code> ，那么 <code>arr[i] = perm[n / 2 + (i - 1) / 2]</code></li>\n</ul>\n\n<p>然后将 <code>arr</code>​​ 赋值​​给 <code>perm</code> 。</p>\n\n<p>要想使 <code>perm</code> 回到排列初始值，至少需要执行多少步操作？返回最小的 <strong>非零</strong> 操作步数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>最初，perm = [0,1]\n第 1 步操作后，perm = [0,1]\n所以，仅需执行 1 步操作</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>最初，perm = [0,1,2,3]\n第 1 步操作后，perm = [0,2,1,3]\n第 2 步操作后，perm = [0,1,2,3]\n所以，仅需执行 2 步操作</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6\n<strong>输出：</strong>4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 1000</code></li>\n\t<li><code>n</code>​​​​​​ 是一个偶数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1807替换字符串中的括号内容",
        "hardRate": "MEDIUM",
        "passRate": "67.50%",
        "problemsUrl": "https://leetcode.cn/problems/evaluate-the-bracket-pairs-of-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/evaluate-the-bracket-pairs-of-a-string/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，它包含一些括号对，每个括号中包含一个 <strong>非空</strong>&nbsp;的键。</p>\n\n<ul>\n\t<li>比方说，字符串&nbsp;<code>\"(name)is(age)yearsold\"</code>&nbsp;中，有&nbsp;<strong>两个</strong>&nbsp;括号对，分别包含键&nbsp;<code>\"name\"</code> 和&nbsp;<code>\"age\"</code>&nbsp;。</li>\n</ul>\n\n<p>你知道许多键对应的值，这些关系由二维字符串数组&nbsp;<code>knowledge</code>&nbsp;表示，其中&nbsp;<code>knowledge[i] = [key<sub>i</sub>, value<sub>i</sub>]</code>&nbsp;，表示键&nbsp;<code>key<sub>i</sub></code>&nbsp;对应的值为&nbsp;<code>value<sub>i</sub></code><sub>&nbsp;</sub>。</p>\n\n<p>你需要替换 <strong>所有</strong>&nbsp;的括号对。当你替换一个括号对，且它包含的键为&nbsp;<code>key<sub>i</sub></code>&nbsp;时，你需要：</p>\n\n<ul>\n\t<li>将&nbsp;<code>key<sub>i</sub></code>&nbsp;和括号用对应的值&nbsp;<code>value<sub>i</sub></code>&nbsp;替换。</li>\n\t<li>如果从 <code>knowledge</code>&nbsp;中无法得知某个键对应的值，你需要将&nbsp;<code>key<sub>i</sub></code>&nbsp;和括号用问号&nbsp;<code>\"?\"</code>&nbsp;替换（不需要引号）。</li>\n</ul>\n\n<p><code>knowledge</code>&nbsp;中每个键最多只会出现一次。<code>s</code>&nbsp;中不会有嵌套的括号。</p>\n\n<p>请你返回替换 <strong>所有</strong>&nbsp;括号对后的结果字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"(name)is(age)yearsold\", knowledge = [[\"name\",\"bob\"],[\"age\",\"two\"]]\n<b>输出：</b>\"bobistwoyearsold\"\n<strong>解释：</strong>\n键 \"name\" 对应的值为 \"bob\" ，所以将 \"(name)\" 替换为 \"bob\" 。\n键 \"age\" 对应的值为 \"two\" ，所以将 \"(age)\" 替换为 \"two\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"hi(name)\", knowledge = [[\"a\",\"b\"]]\n<b>输出：</b>\"hi?\"\n<b>解释：</b>由于不知道键 \"name\" 对应的值，所以用 \"?\" 替换 \"(name)\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"(a)(a)(a)aaa\", knowledge = [[\"a\",\"yes\"]]\n<b>输出：</b>\"yesyesyesaaa\"\n<b>解释：</b>相同的键在 s 中可能会出现多次。\n键 \"a\" 对应的值为 \"yes\" ，所以将所有的 \"(a)\" 替换为 \"yes\" 。\n注意，不在括号里的 \"a\" 不需要被替换。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= knowledge.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>knowledge[i].length == 2</code></li>\n\t<li><code>1 &lt;= key<sub>i</sub>.length, value<sub>i</sub>.length &lt;= 10</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母和圆括号&nbsp;<code>'('</code>&nbsp;和&nbsp;<code>')'</code>&nbsp;。</li>\n\t<li><code>s</code>&nbsp;中每一个左圆括号&nbsp;<code>'('</code>&nbsp;都有对应的右圆括号&nbsp;<code>')'</code>&nbsp;。</li>\n\t<li><code>s</code>&nbsp;中每对括号内的键都不会为空。</li>\n\t<li><code>s</code>&nbsp;中不会有嵌套括号对。</li>\n\t<li><code>key<sub>i</sub></code>&nbsp;和&nbsp;<code>value<sub>i</sub></code>&nbsp;只包含小写英文字母。</li>\n\t<li><code>knowledge</code>&nbsp;中的&nbsp;<code>key<sub>i</sub></code>&nbsp;不会重复。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1808好因子的最大数目",
        "hardRate": "HARD",
        "passRate": "28.63%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-number-of-nice-divisors/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-number-of-nice-divisors/solution",
        "problemsDesc": "<p>给你一个正整数 <code>primeFactors</code> 。你需要构造一个正整数 <code>n</code> ，它满足以下条件：</p>\n\n<ul>\n\t<li><code>n</code> 质因数（质因数需要考虑重复的情况）的数目 <strong>不超过 </strong><code>primeFactors</code> 个。</li>\n\t<li><code>n</code> 好因子的数目最大化。如果 <code>n</code> 的一个因子可以被 <code>n</code> 的每一个质因数整除，我们称这个因子是 <strong>好因子</strong> 。比方说，如果 <code>n = 12</code> ，那么它的质因数为 <code>[2,2,3]</code> ，那么 <code>6</code> 和 <code>12</code> 是好因子，但 <code>3</code> 和 <code>4</code> 不是。</li>\n</ul>\n\n<p>请你返回 <code>n</code> 的好因子的数目。由于答案可能会很大，请返回答案对 <code>10<sup>9</sup> + 7</code> <b>取余</b> 的结果。</p>\n\n<p>请注意，一个质数的定义是大于 <code>1</code> ，且不能被分解为两个小于该数的自然数相乘。一个数 <code>n</code> 的质因子是将 <code>n</code> 分解为若干个质因子，且它们的乘积为 <code>n</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>primeFactors = 5\n<strong>输出：</strong>6\n<b>解释：</b>200 是一个可行的 n 。\n它有 5 个质因子：[2,2,2,5,5] ，且有 6 个好因子：[10,20,40,50,100,200] 。\n不存在别的 n 有至多 5 个质因子，且同时有更多的好因子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>primeFactors = 8\n<b>输出：</b>18\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= primeFactors <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1809没有广告的剧集",
        "hardRate": "EASY",
        "passRate": "60.95%",
        "problemsUrl": "https://leetcode.cn/problems/ad-free-sessions/",
        "solutionsUrl": "https://leetcode.cn/problems/ad-free-sessions/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1810隐藏网格下的最小消耗路径",
        "hardRate": "MEDIUM",
        "passRate": "62.76%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-path-cost-in-a-hidden-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-path-cost-in-a-hidden-grid/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1811寻找面试候选人",
        "hardRate": "MEDIUM",
        "passRate": "63.75%",
        "problemsUrl": "https://leetcode.cn/problems/find-interview-candidates/",
        "solutionsUrl": "https://leetcode.cn/problems/find-interview-candidates/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1812判断国际象棋棋盘中一个格子的颜色",
        "hardRate": "EASY",
        "passRate": "81.79%",
        "problemsUrl": "https://leetcode.cn/problems/determine-color-of-a-chessboard-square/",
        "solutionsUrl": "https://leetcode.cn/problems/determine-color-of-a-chessboard-square/solution",
        "problemsDesc": "<p>给你一个坐标 <code>coordinates</code> ，它是一个字符串，表示国际象棋棋盘中一个格子的坐标。下图是国际象棋棋盘示意图。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/03/chessboard.png\" style=\"width: 400px; height: 396px;\" /></p>\n\n<p>如果所给格子的颜色是白色，请你返回 <code>true</code>，如果是黑色，请返回 <code>false</code> 。</p>\n\n<p>给定坐标一定代表国际象棋棋盘上一个存在的格子。坐标第一个字符是字母，第二个字符是数字。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>coordinates = \"a1\"\n<b>输出：</b>false\n<b>解释：</b>如上图棋盘所示，\"a1\" 坐标的格子是黑色的，所以返回 false 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>coordinates = \"h3\"\n<b>输出：</b>true\n<b>解释：</b>如上图棋盘所示，\"h3\" 坐标的格子是白色的，所以返回 true 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>coordinates = \"c7\"\n<b>输出：</b>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>coordinates.length == 2</code></li>\n\t<li><code>'a' <= coordinates[0] <= 'h'</code></li>\n\t<li><code>'1' <= coordinates[1] <= '8'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1813句子相似性 III",
        "hardRate": "MEDIUM",
        "passRate": "41.62%",
        "problemsUrl": "https://leetcode.cn/problems/sentence-similarity-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/sentence-similarity-iii/solution",
        "problemsDesc": "<p>一个句子是由一些单词与它们之间的单个空格组成，且句子的开头和结尾没有多余空格。比方说，<code>\"Hello World\"</code> ，<code>\"HELLO\"</code> ，<code>\"hello world hello world\"</code> 都是句子。每个单词都 <strong>只</strong> 包含大写和小写英文字母。</p>\n\n<p>如果两个句子 <code>sentence1</code> 和 <code>sentence2</code> ，可以通过往其中一个句子插入一个任意的句子（<strong>可以是空句子</strong>）而得到另一个句子，那么我们称这两个句子是 <strong>相似的</strong> 。比方说，<code>sentence1 = \"Hello my name is Jane\"</code> 且 <code>sentence2 = \"Hello Jane\"</code> ，我们可以往 <code>sentence2</code> 中 <code>\"Hello\"</code> 和 <code>\"Jane\"</code> 之间插入 <code>\"my name is\"</code> 得到 <code>sentence1</code> 。</p>\n\n<p>给你两个句子 <code>sentence1</code> 和 <code>sentence2</code> ，如果<em> </em><code>sentence1</code> 和<em> </em><code>sentence2</code> 是相似的，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>sentence1 = \"My name is Haley\", sentence2 = \"My Haley\"\n<b>输出：</b>true\n<b>解释：</b>可以往 sentence2 中 \"My\" 和 \"Haley\" 之间插入 \"name is\" ，得到 sentence1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>sentence1 = \"of\", sentence2 = \"A lot of words\"\n<b>输出：</b>false\n<strong>解释：</strong>没法往这两个句子中的一个句子只插入一个句子就得到另一个句子。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>sentence1 = \"Eating right now\", sentence2 = \"Eating\"\n<b>输出：</b>true\n<b>解释：</b>可以往 sentence2 的结尾插入 \"right now\" 得到 sentence1 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>sentence1 = \"Luky\", sentence2 = \"Lucccky\"\n<b>输出：</b>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentence1.length, sentence2.length &lt;= 100</code></li>\n\t<li><code>sentence1</code> 和 <code>sentence2</code> 都只包含大小写英文字母和空格。</li>\n\t<li><code>sentence1</code> 和 <code>sentence2</code> 中的单词都只由单个空格隔开。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1814统计一个数组中好对子的数目",
        "hardRate": "MEDIUM",
        "passRate": "47.13%",
        "problemsUrl": "https://leetcode.cn/problems/count-nice-pairs-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/count-nice-pairs-in-an-array/solution",
        "problemsDesc": "<p>给你一个数组 <code>nums</code> ，数组中只包含非负整数。定义 <code>rev(x)</code> 的值为将整数 <code>x</code> 各个数字位反转得到的结果。比方说 <code>rev(123) = 321</code> ， <code>rev(120) = 21</code> 。我们称满足下面条件的下标对 <code>(i, j)</code> 是 <strong>好的</strong> ：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; nums.length</code></li>\n\t<li><code>nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])</code></li>\n</ul>\n\n<p>请你返回好下标对的数目。由于结果可能会很大，请将结果对 <code>10<sup>9</sup> + 7</code> <b>取余</b> 后返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [42,11,1,97]\n<b>输出：</b>2\n<b>解释：</b>两个坐标对为：\n - (0,3)：42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121 。\n - (1,2)：11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [13,10,35,24,76]\n<b>输出：</b>4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1815得到新鲜甜甜圈的最多组数",
        "hardRate": "HARD",
        "passRate": "53.42%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-groups-getting-fresh-donuts/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-groups-getting-fresh-donuts/solution",
        "problemsDesc": "<p>有一个甜甜圈商店，每批次都烤 <code>batchSize</code> 个甜甜圈。这个店铺有个规则，就是在烤一批新的甜甜圈时，之前 <strong>所有</strong> 甜甜圈都必须已经全部销售完毕。给你一个整数 <code>batchSize</code> 和一个整数数组 <code>groups</code> ，数组中的每个整数都代表一批前来购买甜甜圈的顾客，其中 <code>groups[i]</code> 表示这一批顾客的人数。每一位顾客都恰好只要一个甜甜圈。</p>\n\n<p>当有一批顾客来到商店时，他们所有人都必须在下一批顾客来之前购买完甜甜圈。如果一批顾客中第一位顾客得到的甜甜圈不是上一组剩下的，那么这一组人都会很开心。</p>\n\n<p>你可以随意安排每批顾客到来的顺序。请你返回在此前提下，<strong>最多</strong> 有多少组人会感到开心。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>batchSize = 3, groups = [1,2,3,4,5,6]\n<b>输出：</b>4\n<b>解释：</b>你可以将这些批次的顾客顺序安排为 [6,2,4,5,1,3] 。那么第 1，2，4，6 组都会感到开心。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>batchSize = 4, groups = [1,3,2,5,2,2,1,6]\n<b>输出：</b>4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= batchSize <= 9</code></li>\n\t<li><code>1 <= groups.length <= 30</code></li>\n\t<li><code>1 <= groups[i] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1816截断句子",
        "hardRate": "EASY",
        "passRate": "72.41%",
        "problemsUrl": "https://leetcode.cn/problems/truncate-sentence/",
        "solutionsUrl": "https://leetcode.cn/problems/truncate-sentence/solution",
        "problemsDesc": "<p><strong>句子</strong> 是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。</p>\n\n<ul>\n\t<li>例如，<code>\"Hello World\"</code>、<code>\"HELLO\"</code> 和 <code>\"hello world hello world\"</code> 都是句子。</li>\n</ul>\n\n<p>给你一个句子 <code>s</code>​​​​​​ 和一个整数 <code>k</code>​​​​​​ ，请你将 <code>s</code>​​ <strong>截断</strong> ​，​​​使截断后的句子仅含 <strong>前</strong> <code>k</code>​​​​​​ 个单词。返回 <strong>截断</strong> <code>s</code>​​​​<em>​​ </em>后得到的句子<em>。</em></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"Hello how are you Contestant\", k = 4\n<strong>输出：</strong>\"Hello how are you\"\n<strong>解释：</strong>\ns 中的单词为 [\"Hello\", \"how\" \"are\", \"you\", \"Contestant\"]\n前 4 个单词为 [\"Hello\", \"how\", \"are\", \"you\"]\n因此，应当返回 \"Hello how are you\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"What is the solution to this problem\", k = 4\n<strong>输出：</strong>\"What is the solution\"\n<strong>解释：</strong>\ns 中的单词为 [\"What\", \"is\" \"the\", \"solution\", \"to\", \"this\", \"problem\"]\n前 4 个单词为 [\"What\", \"is\", \"the\", \"solution\"]\n因此，应当返回 \"What is the solution\"</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = \"chopper is not a tanuki\", k = 5\n<strong>输出：</strong>\"chopper is not a tanuki\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>k</code> 的取值范围是 <code>[1,  s 中单词的数目]</code></li>\n\t<li><code>s</code> 仅由大小写英文字母和空格组成</li>\n\t<li><code>s</code> 中的单词之间由单个空格隔开</li>\n\t<li>不存在前导或尾随空格</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1817查找用户活跃分钟数",
        "hardRate": "MEDIUM",
        "passRate": "79.40%",
        "problemsUrl": "https://leetcode.cn/problems/finding-the-users-active-minutes/",
        "solutionsUrl": "https://leetcode.cn/problems/finding-the-users-active-minutes/solution",
        "problemsDesc": "<p>给你用户在 LeetCode 的操作日志，和一个整数 <code>k</code> 。日志用一个二维整数数组 <code>logs</code> 表示，其中每个 <code>logs[i] = [ID<sub>i</sub>, time<sub>i</sub>]</code> 表示 ID 为 <code>ID<sub>i</sub></code> 的用户在 <code>time<sub>i</sub></code> 分钟时执行了某个操作。</p>\n\n<p><strong>多个用户 </strong>可以同时执行操作，单个用户可以在同一分钟内执行 <strong>多个操作</strong> 。</p>\n\n<p>指定用户的<strong> 用户活跃分钟数（user active minutes，UAM）</strong> 定义为用户对 LeetCode 执行操作的 <strong>唯一分钟数</strong> 。 即使一分钟内执行多个操作，也只能按一分钟计数。</p>\n\n<p>请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 <code>k</code> 且 <strong>下标从 1 开始计数</strong> 的数组 <code>answer</code> ，对于每个 <code>j</code>（<code>1 <= j <= k</code>），<code>answer[j]</code> 表示 <strong>用户活跃分钟数</strong> 等于 <code>j</code> 的用户数。</p>\n\n<p>返回上面描述的答案数组<i> </i><code>answer</code><i> </i>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5\n<strong>输出：</strong>[0,2,0,0,0]\n<strong>解释：</strong>\nID=0 的用户执行操作的分钟分别是：5 、2 和 5 。因此，该用户的用户活跃分钟数为 2（分钟 5 只计数一次）\nID=1 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 2\n2 个用户的用户活跃分钟数都是 2 ，answer[2] 为 2 ，其余 answer[j] 的值都是 0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>logs = [[1,1],[2,2],[2,3]], k = 4\n<strong>输出：</strong>[1,1,0,0]\n<strong>解释：</strong>\nID=1 的用户仅在分钟 1 执行单个操作。因此，该用户的用户活跃分钟数为 1\nID=2 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 2\n1 个用户的用户活跃分钟数是 1 ，1 个用户的用户活跃分钟数是 2 \n因此，answer[1] = 1 ，answer[2] = 1 ，其余的值都是 0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= logs.length <= 10<sup>4</sup></code></li>\n\t<li><code>0 <= ID<sub>i</sub> <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= time<sub>i</sub> <= 10<sup>5</sup></code></li>\n\t<li><code>k</code> 的取值范围是 <code>[用户的最大用户活跃分钟数, 10<sup>5</sup>]</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1818绝对差值和",
        "hardRate": "MEDIUM",
        "passRate": "37.58%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-absolute-sum-difference/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-absolute-sum-difference/solution",
        "problemsDesc": "<p>给你两个正整数数组 <code>nums1</code> 和 <code>nums2</code> ，数组的长度都是 <code>n</code> 。</p>\n\n<p>数组 <code>nums1</code> 和 <code>nums2</code> 的 <strong>绝对差值和</strong> 定义为所有 <code>|nums1[i] - nums2[i]|</code>（<code>0 <= i < n</code>）的 <strong>总和</strong>（<strong>下标从 0 开始</strong>）。</p>\n\n<p>你可以选用 <code>nums1</code> 中的 <strong>任意一个</strong> 元素来替换 <code>nums1</code> 中的 <strong>至多</strong> 一个元素，以 <strong>最小化</strong> 绝对差值和。</p>\n\n<p>在替换数组 <code>nums1</code> 中最多一个元素 <strong>之后</strong> ，返回最小绝对差值和。因为答案可能很大，所以需要对 <code>10<sup>9</sup> + 7</code> <strong>取余 </strong>后返回。</p>\n\n<p><code>|x|</code> 定义为：</p>\n\n<ul>\n\t<li>如果 <code>x >= 0</code> ，值为 <code>x</code> ，或者</li>\n\t<li>如果 <code>x <= 0</code> ，值为 <code>-x</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,7,5], nums2 = [2,3,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>有两种可能的最优方案：\n- 将第二个元素替换为第一个元素：[1,<strong>7</strong>,5] => [1,<strong>1</strong>,5] ，或者\n- 将第二个元素替换为第三个元素：[1,<strong>7</strong>,5] => [1,<strong>5</strong>,5]\n两种方案的绝对差值和都是 <code>|1-2| + (|1-3| 或者 |5-3|) + |5-5| = </code>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]\n<strong>输出：</strong>0\n<strong>解释：</strong>nums1 和 nums2 相等，所以不用替换元素。绝对差值和为 0\n</pre>\n\n<p><strong>示例 3</strong><strong>：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]\n<strong>输出：</strong>20\n<strong>解释：</strong>将第一个元素替换为第二个元素：[<strong>1</strong>,10,4,4,2,7] => [<strong>10</strong>,10,4,4,2,7]\n绝对差值和为 <code>|10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20</code>\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length</code></li>\n\t<li><code>n == nums2.length</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums1[i], nums2[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1819序列中不同最大公约数的数目",
        "hardRate": "HARD",
        "passRate": "63.34%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-different-subsequences-gcds/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-different-subsequences-gcds/solution",
        "problemsDesc": "<p>给你一个由正整数组成的数组 <code>nums</code> 。</p>\n\n<p>数字序列的 <strong>最大公约数</strong> 定义为序列中所有整数的共有约数中的最大整数。</p>\n\n<ul>\n\t<li>例如，序列 <code>[4,6,16]</code> 的最大公约数是 <code>2</code> 。</li>\n</ul>\n\n<p>数组的一个 <strong>子序列</strong> 本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。</p>\n\n<ul>\n\t<li>例如，<code>[2,5,10]</code> 是 <code>[1,2,1,<strong>2</strong>,4,1,<strong>5</strong>,<strong>10</strong>]</code> 的一个子序列。</li>\n</ul>\n\n<p>计算并返回 <code>nums</code> 的所有 <strong>非空</strong> 子序列中 <strong>不同</strong> 最大公约数的 <strong>数目</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/03/image-1.png\" />\n<pre>\n<strong>输入：</strong>nums = [6,10,3]\n<strong>输出：</strong>5\n<strong>解释：</strong>上图显示了所有的非空子序列与各自的最大公约数。\n不同的最大公约数为 6 、10 、3 、2 和 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,15,40,5,6]\n<strong>输出：</strong>7\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 2 * 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1820最多邀请的个数",
        "hardRate": "MEDIUM",
        "passRate": "47.60%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-accepted-invitations/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-accepted-invitations/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1821寻找今年具有正收入的客户",
        "hardRate": "EASY",
        "passRate": "88.40%",
        "problemsUrl": "https://leetcode.cn/problems/find-customers-with-positive-revenue-this-year/",
        "solutionsUrl": "https://leetcode.cn/problems/find-customers-with-positive-revenue-this-year/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1822数组元素积的符号",
        "hardRate": "EASY",
        "passRate": "71.72%",
        "problemsUrl": "https://leetcode.cn/problems/sign-of-the-product-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/sign-of-the-product-of-an-array/solution",
        "problemsDesc": "<p>已知函数 <code>signFunc(x)</code> 将会根据 <code>x</code> 的正负返回特定值：</p>\n\n<ul>\n\t<li>如果 <code>x</code> 是正数，返回 <code>1</code> 。</li>\n\t<li>如果 <code>x</code> 是负数，返回 <code>-1</code> 。</li>\n\t<li>如果 <code>x</code> 是等于 <code>0</code> ，返回 <code>0</code> 。</li>\n</ul>\n\n<p>给你一个整数数组 <code>nums</code> 。令 <code>product</code> 为数组 <code>nums</code> 中所有元素值的乘积。</p>\n\n<p>返回 <code>signFunc(product)</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,-2,-3,-4,3,2,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>数组中所有值的乘积是 144 ，且 signFunc(144) = 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5,0,2,-3]\n<strong>输出：</strong>0\n<strong>解释：</strong>数组中所有值的乘积是 0 ，且 signFunc(0) = 0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,1,-1,1,-1]\n<strong>输出：</strong>-1\n<strong>解释：</strong>数组中所有值的乘积是 -1 ，且 signFunc(-1) = -1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 1000</code></li>\n\t<li><code>-100 <= nums[i] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1823找出游戏的获胜者",
        "hardRate": "MEDIUM",
        "passRate": "78.51%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-winner-of-the-circular-game/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-winner-of-the-circular-game/solution",
        "problemsDesc": "<p>共有 <code>n</code> 名小伙伴一起做游戏。小伙伴们围成一圈，按 <strong>顺时针顺序</strong> 从 <code>1</code> 到 <code>n</code> 编号。确切地说，从第 <code>i</code> 名小伙伴顺时针移动一位会到达第 <code>(i+1)</code> 名小伙伴的位置，其中 <code>1 &lt;= i &lt; n</code> ，从第 <code>n</code> 名小伙伴顺时针移动一位会回到第 <code>1</code> 名小伙伴的位置。</p>\n\n<p>游戏遵循如下规则：</p>\n\n<ol>\n\t<li>从第 <code>1</code> 名小伙伴所在位置 <strong>开始</strong> 。</li>\n\t<li>沿着顺时针方向数 <code>k</code> 名小伙伴，计数时需要 <strong>包含</strong> 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。</li>\n\t<li>你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。</li>\n\t<li>如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 <strong>顺时针下一位</strong> 小伙伴 <strong>开始</strong>，回到步骤 <code>2</code> 继续执行。</li>\n\t<li>否则，圈子中最后一名小伙伴赢得游戏。</li>\n</ol>\n\n<p>给你参与游戏的小伙伴总数 <code>n</code> ，和一个整数 <code>k</code> ，返回游戏的获胜者。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/ic234-q2-ex11.png\" style=\"width: 500px; height: 345px;\" />\n<pre>\n<strong>输入：</strong>n = 5, k = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>游戏运行步骤如下：\n1) 从小伙伴 1 开始。\n2) 顺时针数 2 名小伙伴，也就是小伙伴 1 和 2 。\n3) 小伙伴 2 离开圈子。下一次从小伙伴 3 开始。\n4) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 4 。\n5) 小伙伴 4 离开圈子。下一次从小伙伴 5 开始。\n6) 顺时针数 2 名小伙伴，也就是小伙伴 5 和 1 。\n7) 小伙伴 1 离开圈子。下一次从小伙伴 3 开始。\n8) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 5 。\n9) 小伙伴 5 离开圈子。只剩下小伙伴 3 。所以小伙伴 3 是游戏的获胜者。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6, k = 5\n<strong>输出：</strong>1\n<strong>解释：</strong>小伙伴离开圈子的顺序：5、4、6、2、3 。小伙伴 1 是游戏的获胜者。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 500</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能否使用线性时间复杂度和常数空间复杂度解决此问题？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1824最少侧跳次数",
        "hardRate": "MEDIUM",
        "passRate": "68.37%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-sideway-jumps/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-sideway-jumps/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的 <strong>3 跑道道路</strong> ，它总共包含 <code>n + 1</code> 个 <strong>点</strong> ，编号为 <code>0</code> 到 <code>n</code> 。一只青蛙从 <code>0</code> 号点第二条跑道 <strong>出发</strong> ，它想要跳到点 <code>n</code> 处。然而道路上可能有一些障碍。</p>\n\n<p>给你一个长度为 <code>n + 1</code> 的数组 <code>obstacles</code> ，其中 <code>obstacles[i]</code> （<b>取值范围从 0 到 3</b>）表示在点 <code>i</code> 处的 <code>obstacles[i]</code> 跑道上有一个障碍。如果 <code>obstacles[i] == 0</code> ，那么点 <code>i</code> 处没有障碍。任何一个点的三条跑道中 <strong>最多有一个</strong> 障碍。</p>\n\n<ul>\n\t<li>比方说，如果 <code>obstacles[2] == 1</code> ，那么说明在点 2 处跑道 1 有障碍。</li>\n</ul>\n\n<p>这只青蛙从点 <code>i</code> 跳到点 <code>i + 1</code> 且跑道不变的前提是点 <code>i + 1</code> 的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在 <strong>同一个</strong> 点处 <strong>侧跳</strong> 到 <strong>另外一条</strong> 跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。</p>\n\n<ul>\n\t<li>比方说，这只青蛙可以从点 3 处的跑道 3 跳到点 3 处的跑道 1 。</li>\n</ul>\n\n<p>这只青蛙从点 0 处跑道 <code>2</code> 出发，并想到达点 <code>n</code> 处的 <strong>任一跑道</strong> ，请你返回 <strong>最少侧跳次数</strong> 。</p>\n\n<p><strong>注意</strong>：点 <code>0</code> 处和点 <code>n</code> 处的任一跑道都不会有障碍。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex1.png\" style=\"width: 500px; height: 244px;\" />\n<pre>\n<b>输入：</b>obstacles = [0,1,2,3,0]\n<b>输出：</b>2 \n<b>解释：</b>最优方案如上图箭头所示。总共有 2 次侧跳（红色箭头）。\n注意，这只青蛙只有当侧跳时才可以跳过障碍（如上图点 2 处所示）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex2.png\" style=\"width: 500px; height: 196px;\" />\n<pre>\n<b>输入：</b>obstacles = [0,1,1,3,3,0]\n<b>输出：</b>0\n<b>解释：</b>跑道 2 没有任何障碍，所以不需要任何侧跳。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex3.png\" style=\"width: 500px; height: 196px;\" />\n<pre>\n<b>输入：</b>obstacles = [0,2,1,0,3,0]\n<b>输出：</b>2\n<b>解释：</b>最优方案如上图所示。总共有 2 次侧跳。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>obstacles.length == n + 1</code></li>\n\t<li><code>1 <= n <= 5 * 10<sup>5</sup></code></li>\n\t<li><code>0 <= obstacles[i] <= 3</code></li>\n\t<li><code>obstacles[0] == obstacles[n] == 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1825求出 MK 平均值",
        "hardRate": "HARD",
        "passRate": "43.44%",
        "problemsUrl": "https://leetcode.cn/problems/finding-mk-average/",
        "solutionsUrl": "https://leetcode.cn/problems/finding-mk-average/solution",
        "problemsDesc": "<p>给你两个整数&nbsp;<code>m</code>&nbsp;和&nbsp;<code>k</code>&nbsp;，以及数据流形式的若干整数。你需要实现一个数据结构，计算这个数据流的 <b>MK 平均值</b>&nbsp;。</p>\n\n<p><strong>MK 平均值</strong>&nbsp;按照如下步骤计算：</p>\n\n<ol>\n\t<li>如果数据流中的整数少于 <code>m</code>&nbsp;个，<strong>MK 平均值</strong>&nbsp;为 <code>-1</code>&nbsp;，否则将数据流中最后 <code>m</code>&nbsp;个元素拷贝到一个独立的容器中。</li>\n\t<li>从这个容器中删除最小的 <code>k</code>&nbsp;个数和最大的 <code>k</code>&nbsp;个数。</li>\n\t<li>计算剩余元素的平均值，并 <strong>向下取整到最近的整数</strong>&nbsp;。</li>\n</ol>\n\n<p>请你实现&nbsp;<code>MKAverage</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>MKAverage(int m, int k)</code>&nbsp;用一个空的数据流和两个整数 <code>m</code>&nbsp;和 <code>k</code>&nbsp;初始化&nbsp;<strong>MKAverage</strong>&nbsp;对象。</li>\n\t<li><code>void addElement(int num)</code>&nbsp;往数据流中插入一个新的元素&nbsp;<code>num</code>&nbsp;。</li>\n\t<li><code>int calculateMKAverage()</code>&nbsp;对当前的数据流计算并返回 <strong>MK 平均数</strong>&nbsp;，结果需 <strong>向下取整到最近的整数</strong> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"MKAverage\", \"addElement\", \"addElement\", \"calculateMKAverage\", \"addElement\", \"calculateMKAverage\", \"addElement\", \"addElement\", \"addElement\", \"calculateMKAverage\"]\n[[3, 1], [3], [1], [], [10], [], [5], [5], [5], []]\n<strong>输出：</strong>\n[null, null, null, -1, null, 3, null, null, null, 5]\n\n<strong>解释：</strong>\nMKAverage obj = new MKAverage(3, 1); \nobj.addElement(3);        // 当前元素为 [3]\nobj.addElement(1);        // 当前元素为 [3,1]\nobj.calculateMKAverage(); // 返回 -1 ，因为 m = 3 ，但数据流中只有 2 个元素\nobj.addElement(10);       // 当前元素为 [3,1,10]\nobj.calculateMKAverage(); // 最后 3 个元素为 [3,1,10]\n                          // 删除最小以及最大的 1 个元素后，容器为 [3]\n                          // [3] 的平均值等于 3/1 = 3 ，故返回 3\nobj.addElement(5);        // 当前元素为 [3,1,10,5]\nobj.addElement(5);        // 当前元素为 [3,1,10,5,5]\nobj.addElement(5);        // 当前元素为 [3,1,10,5,5,5]\nobj.calculateMKAverage(); // 最后 3 个元素为 [5,5,5]\n                          // 删除最小以及最大的 1 个元素后，容器为 [5]\n                          // [5] 的平均值等于 5/1 = 5 ，故返回 5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k*2 &lt; m</code></li>\n\t<li><code>1 &lt;= num &lt;= 10<sup>5</sup></code></li>\n\t<li><code>addElement</code> 与&nbsp;<code>calculateMKAverage</code>&nbsp;总操作次数不超过 <code>10<sup>5</sup></code> 次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1826有缺陷的传感器",
        "hardRate": "EASY",
        "passRate": "41.74%",
        "problemsUrl": "https://leetcode.cn/problems/faulty-sensor/",
        "solutionsUrl": "https://leetcode.cn/problems/faulty-sensor/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1827最少操作使数组递增",
        "hardRate": "EASY",
        "passRate": "81.37%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-array-increasing/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-array-increasing/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> （<strong>下标从 0 开始</strong>）。每一次操作中，你可以选择数组中一个元素，并将它增加 <code>1</code> 。</p>\n\n<ul>\n\t<li>比方说，如果 <code>nums = [1,2,3]</code> ，你可以选择增加 <code>nums[1]</code> 得到 <code>nums = [1,<b>3</b>,3]</code> 。</li>\n</ul>\n\n<p>请你返回使 <code>nums</code> <strong>严格递增</strong> 的 <strong>最少</strong> 操作次数。</p>\n\n<p>我们称数组 <code>nums</code> 是 <strong>严格递增的</strong> ，当它满足对于所有的 <code>0 &lt;= i &lt; nums.length - 1</code> 都有 <code>nums[i] &lt; nums[i+1]</code> 。一个长度为 <code>1</code> 的数组是严格递增的一种特殊情况。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,1,1]\n<b>输出：</b>3\n<b>解释：</b>你可以进行如下操作：\n1) 增加 nums[2] ，数组变为 [1,1,<strong>2</strong>] 。\n2) 增加 nums[1] ，数组变为 [1,<strong>2</strong>,2] 。\n3) 增加 nums[2] ，数组变为 [1,2,<strong>3</strong>] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,5,2,4,1]\n<b>输出：</b>14\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [8]\n<b>输出：</b>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1828统计一个圆中点的数目",
        "hardRate": "MEDIUM",
        "passRate": "88.50%",
        "problemsUrl": "https://leetcode.cn/problems/queries-on-number-of-points-inside-a-circle/",
        "solutionsUrl": "https://leetcode.cn/problems/queries-on-number-of-points-inside-a-circle/solution",
        "problemsDesc": "<p>给你一个数组 <code>points</code> ，其中 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> ，表示第 <code>i</code> 个点在二维平面上的坐标。多个点可能会有 <strong>相同</strong> 的坐标。</p>\n\n<p>同时给你一个数组 <code>queries</code> ，其中 <code>queries[j] = [x<sub>j</sub>, y<sub>j</sub>, r<sub>j</sub>]</code> ，表示一个圆心在 <code>(x<sub>j</sub>, y<sub>j</sub>)</code> 且半径为 <code>r<sub>j</sub></code><sub> </sub>的圆。</p>\n\n<p>对于每一个查询 <code>queries[j]</code> ，计算在第 <code>j</code> 个圆 <strong>内</strong> 点的数目。如果一个点在圆的 <strong>边界上</strong> ，我们同样认为它在圆 <strong>内</strong> 。</p>\n\n<p>请你返回一个数组<em> </em><code>answer</code> ，其中<em> </em><code>answer[j]</code>是第 <code>j</code> 个查询的答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/chrome_2021-03-25_22-34-16.png\" style=\"width: 500px; height: 418px;\">\n<pre><b>输入：</b>points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]]\n<b>输出：</b>[3,2,2]\n<b>解释：</b>所有的点和圆如上图所示。\nqueries[0] 是绿色的圆，queries[1] 是红色的圆，queries[2] 是蓝色的圆。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/chrome_2021-03-25_22-42-07.png\" style=\"width: 500px; height: 390px;\">\n<pre><b>输入：</b>points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]\n<b>输出：</b>[2,3,2,4]\n<b>解释：</b>所有的点和圆如上图所示。\nqueries[0] 是绿色的圆，queries[1] 是红色的圆，queries[2] 是蓝色的圆，queries[3] 是紫色的圆。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= points.length &lt;= 500</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>​​​​​​i</sub>, y<sub>​​​​​​i</sub> &lt;= 500</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 500</code></li>\n\t<li><code>queries[j].length == 3</code></li>\n\t<li><code>0 &lt;= x<sub>j</sub>, y<sub>j</sub> &lt;= 500</code></li>\n\t<li><code>1 &lt;= r<sub>j</sub> &lt;= 500</code></li>\n\t<li>所有的坐标都是整数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1829每个查询的最大异或值",
        "hardRate": "MEDIUM",
        "passRate": "72.16%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-xor-for-each-query/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-xor-for-each-query/solution",
        "problemsDesc": "<p>给你一个 <strong>有序</strong> 数组 <code>nums</code> ，它由 <code>n</code> 个非负整数组成，同时给你一个整数 <code>maximumBit</code> 。你需要执行以下查询 <code>n</code> 次：</p>\n\n<ol>\n\t<li>找到一个非负整数 <code>k < 2<sup>maximumBit</sup></code> ，使得 <code>nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k</code> 的结果 <strong>最大化</strong> 。<code>k</code> 是第 <code>i</code> 个查询的答案。</li>\n\t<li>从当前数组 <code>nums</code> 删除 <strong>最后</strong> 一个元素。</li>\n</ol>\n\n<p>请你返回一个数组 <code>answer</code> ，其中<em> </em><code>answer[i]</code>是第 <code>i</code> 个查询的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [0,1,1,3], maximumBit = 2\n<b>输出：</b>[0,3,2,3]\n<b>解释：</b>查询的答案如下：\n第一个查询：nums = [0,1,1,3]，k = 0，因为 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3 。\n第二个查询：nums = [0,1,1]，k = 3，因为 0 XOR 1 XOR 1 XOR 3 = 3 。\n第三个查询：nums = [0,1]，k = 2，因为 0 XOR 1 XOR 2 = 3 。\n第四个查询：nums = [0]，k = 3，因为 0 XOR 3 = 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,3,4,7], maximumBit = 3\n<b>输出：</b>[5,2,6,5]\n<b>解释：</b>查询的答案如下：\n第一个查询：nums = [2,3,4,7]，k = 5，因为 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7。\n第二个查询：nums = [2,3,4]，k = 2，因为 2 XOR 3 XOR 4 XOR 2 = 7 。\n第三个查询：nums = [2,3]，k = 6，因为 2 XOR 3 XOR 6 = 7 。\n第四个查询：nums = [2]，k = 5，因为 2 XOR 5 = 7 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [0,1,2,2,5,7], maximumBit = 3\n<b>输出：</b>[4,3,6,4,6,7]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length == n</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= maximumBit <= 20</code></li>\n\t<li><code>0 <= nums[i] < 2<sup>maximumBit</sup></code></li>\n\t<li><code>nums</code>​​​ 中的数字已经按 <strong>升序</strong> 排好序。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1830使字符串有序的最少操作次数",
        "hardRate": "HARD",
        "passRate": "53.11%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-make-string-sorted/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-make-string-sorted/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> （<strong>下标从 0 开始</strong>）。你需要对 <code>s</code> 执行以下操作直到它变为一个有序字符串：</p>\n\n<ol>\n\t<li>找到 <strong>最大下标</strong> <code>i</code> ，使得 <code>1 &lt;= i &lt; s.length</code> 且 <code>s[i] &lt; s[i - 1]</code> 。</li>\n\t<li>找到 <strong>最大下标</strong> <code>j</code> ，使得 <code>i &lt;= j &lt; s.length</code> 且对于所有在闭区间 <code>[i, j]</code> 之间的 <code>k</code> 都有 <code>s[k] &lt; s[i - 1]</code> 。</li>\n\t<li>交换下标为 <code>i - 1</code>​​​​ 和 <code>j</code>​​​​ 处的两个字符。</li>\n\t<li>将下标 <code>i</code> 开始的字符串后缀反转。</li>\n</ol>\n\n<p>请你返回将字符串变成有序的最少操作次数。由于答案可能会很大，请返回它对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"cba\"\n<b>输出：</b>5\n<b>解释：</b>模拟过程如下所示：\n操作 1：i=2，j=2。交换 s[1] 和 s[2] 得到 s=\"cab\" ，然后反转下标从 2 开始的后缀字符串，得到 s=\"cab\" 。\n操作 2：i=1，j=2。交换 s[0] 和 s[2] 得到 s=\"bac\" ，然后反转下标从 1 开始的后缀字符串，得到 s=\"bca\" 。\n操作 3：i=2，j=2。交换 s[1] 和 s[2] 得到 s=\"bac\" ，然后反转下标从 2 开始的后缀字符串，得到 s=\"bac\" 。\n操作 4：i=1，j=1。交换 s[0] 和 s[1] 得到 s=\"abc\" ，然后反转下标从 1 开始的后缀字符串，得到 s=\"acb\" 。\n操作 5：i=2，j=2。交换 s[1] 和 s[2] 得到 s=\"abc\" ，然后反转下标从 2 开始的后缀字符串，得到 s=\"abc\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"aabaa\"\n<b>输出：</b>2\n<b>解释：</b>模拟过程如下所示：\n操作 1：i=3，j=4。交换 s[2] 和 s[4] 得到 s=\"aaaab\" ，然后反转下标从 3 开始的后缀字符串，得到 s=\"aaaba\" 。\n操作 2：i=4，j=4。交换 s[3] 和 s[4] 得到 s=\"aaaab\" ，然后反转下标从 4 开始的后缀字符串，得到 s=\"aaaab\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>s = \"cdbea\"\n<b>输出：</b>63</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>s = \"leetcodeleetcodeleetcode\"\n<b>输出：</b>982157772\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3000</code></li>\n\t<li><code>s</code>​ 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1831每天的最大交易",
        "hardRate": "MEDIUM",
        "passRate": "78.10%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-transaction-each-day/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-transaction-each-day/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1832判断句子是否为全字母句",
        "hardRate": "EASY",
        "passRate": "84.84%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-the-sentence-is-pangram/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-the-sentence-is-pangram/solution",
        "problemsDesc": "<p><strong>全字母句</strong> 指包含英语字母表中每个字母至少一次的句子。</p>\n\n<p>给你一个仅由小写英文字母组成的字符串 <code>sentence</code> ，请你判断 <code>sentence</code> 是否为 <strong>全字母句</strong> 。</p>\n\n<p>如果是，返回<em> </em><code>true</code> ；否则，返回<em> </em><code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"thequickbrownfoxjumpsoverthelazydog\"\n<strong>输出：</strong>true\n<strong>解释：</strong><code>sentence</code> 包含英语字母表中每个字母至少一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"leetcode\"\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= sentence.length <= 1000</code></li>\n\t<li><code>sentence</code> 由小写英语字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1833雪糕的最大数量",
        "hardRate": "MEDIUM",
        "passRate": "68.07%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-ice-cream-bars/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-ice-cream-bars/solution",
        "problemsDesc": "<p>夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。</p>\n\n<p>商店中新到 <code>n</code> 支雪糕，用长度为 <code>n</code> 的数组 <code>costs</code> 表示雪糕的定价，其中 <code>costs[i]</code> 表示第 <code>i</code> 支雪糕的现金价格。Tony 一共有 <code>coins</code> 现金可以用于消费，他想要买尽可能多的雪糕。</p>\n\n<p><strong>注意：</strong>Tony 可以按任意顺序购买雪糕。</p>\n\n<p>给你价格数组 <code>costs</code> 和现金量 <code>coins</code> ，请你计算并返回 Tony 用 <code>coins</code> 现金能够买到的雪糕的 <strong>最大数量</strong> 。</p>\n\n<p>你必须使用计数排序解决此问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>costs = [1,3,2,4,1], coins = 7\n<strong>输出：</strong>4\n<strong>解释：</strong>Tony 可以买下标为 0、1、2、4 的雪糕，总价为 1 + 3 + 2 + 1 = 7\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>costs = [10,6,8,7,7,8], coins = 5\n<strong>输出：</strong>0\n<strong>解释：</strong>Tony 没有足够的钱买任何一支雪糕。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>costs = [1,6,3,1,2,5], coins = 20\n<strong>输出：</strong>6\n<strong>解释：</strong>Tony 可以买下所有的雪糕，总价为 1 + 6 + 3 + 1 + 2 + 5 = 18 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>costs.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= costs[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= coins &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1834单线程 CPU",
        "hardRate": "MEDIUM",
        "passRate": "37.87%",
        "problemsUrl": "https://leetcode.cn/problems/single-threaded-cpu/",
        "solutionsUrl": "https://leetcode.cn/problems/single-threaded-cpu/solution",
        "problemsDesc": "<p>给你一个二维数组 <code>tasks</code> ，用于表示 <code>n</code>​​​​​​ 项从 <code>0</code> 到 <code>n - 1</code> 编号的任务。其中 <code>tasks[i] = [enqueueTime<sub>i</sub>, processingTime<sub>i</sub>]</code> 意味着第 <code>i<sup>​​​​​​</sup></code>​​​​ 项任务将会于 <code>enqueueTime<sub>i</sub></code> 时进入任务队列，需要 <code>processingTime<sub>i</sub></code><sub> </sub>的时长完成执行。</p>\n\n<p>现有一个单线程 CPU ，同一时间只能执行 <strong>最多一项</strong> 任务，该 CPU 将会按照下述方式运行：</p>\n\n<ul>\n\t<li>如果 CPU 空闲，且任务队列中没有需要执行的任务，则 CPU 保持空闲状态。</li>\n\t<li>如果 CPU 空闲，但任务队列中有需要执行的任务，则 CPU 将会选择 <strong>执行时间最短</strong> 的任务开始执行。如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。</li>\n\t<li>一旦某项任务开始执行，CPU 在 <strong>执行完整个任务</strong> 前都不会停止。</li>\n\t<li>CPU 可以在完成一项任务后，立即开始执行一项新任务。</li>\n</ul>\n\n<p>返回<em> </em>CPU<em> </em>处理任务的顺序。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>tasks = [[1,2],[2,4],[3,2],[4,1]]\n<strong>输出：</strong>[0,2,3,1]\n<strong>解释：</strong>事件按下述流程运行： \n- time = 1 ，任务 0 进入任务队列，可执行任务项 = {0}\n- 同样在 time = 1 ，空闲状态的 CPU 开始执行任务 0 ，可执行任务项 = {}\n- time = 2 ，任务 1 进入任务队列，可执行任务项 = {1}\n- time = 3 ，任务 2 进入任务队列，可执行任务项 = {1, 2}\n- 同样在 time = 3 ，CPU 完成任务 0 并开始执行队列中用时最短的任务 2 ，可执行任务项 = {1}\n- time = 4 ，任务 3 进入任务队列，可执行任务项 = {1, 3}\n- time = 5 ，CPU 完成任务 2 并开始执行队列中用时最短的任务 3 ，可执行任务项 = {1}\n- time = 6 ，CPU 完成任务 3 并开始执行任务 1 ，可执行任务项 = {}\n- time = 10 ，CPU 完成任务 1 并进入空闲状态\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]]\n<strong>输出：</strong>[4,3,2,0,1]\n<strong>解释：</strong>事件按下述流程运行： \n- time = 7 ，所有任务同时进入任务队列，可执行任务项  = {0,1,2,3,4}\n- 同样在 time = 7 ，空闲状态的 CPU 开始执行任务 4 ，可执行任务项 = {0,1,2,3}\n- time = 9 ，CPU 完成任务 4 并开始执行任务 3 ，可执行任务项 = {0,1,2}\n- time = 13 ，CPU 完成任务 3 并开始执行任务 2 ，可执行任务项 = {0,1}\n- time = 18 ，CPU 完成任务 2 并开始执行任务 0 ，可执行任务项 = {1}\n- time = 28 ，CPU 完成任务 0 并开始执行任务 1 ，可执行任务项 = {}\n- time = 40 ，CPU 完成任务 1 并进入空闲状态</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>tasks.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= enqueueTime<sub>i</sub>, processingTime<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1835所有数对按位与结果的异或和",
        "hardRate": "HARD",
        "passRate": "55.96%",
        "problemsUrl": "https://leetcode.cn/problems/find-xor-sum-of-all-pairs-bitwise-and/",
        "solutionsUrl": "https://leetcode.cn/problems/find-xor-sum-of-all-pairs-bitwise-and/solution",
        "problemsDesc": "<p>列表的 <strong>异或和</strong>（<strong>XOR sum</strong>）指对所有元素进行按位 <code>XOR</code> 运算的结果。如果列表中仅有一个元素，那么其 <strong>异或和</strong> 就等于该元素。</p>\n\n<ul>\n\t<li>例如，<code>[1,2,3,4]</code> 的 <strong>异或和</strong> 等于 <code>1 XOR 2 XOR 3 XOR 4 = 4</code> ，而 <code>[3]</code> 的 <strong>异或和</strong> 等于 <code>3</code> 。</li>\n</ul>\n\n<p>给你两个下标 <strong>从 0 开始</strong> 计数的数组 <code>arr1</code> 和 <code>arr2</code> ，两数组均由非负整数组成。</p>\n\n<p>根据每个 <code>(i, j)</code> 数对，构造一个由 <code>arr1[i] AND arr2[j]</code>（按位 <code>AND</code> 运算）结果组成的列表。其中 <code>0 &lt;= i &lt; arr1.length</code> 且 <code>0 &lt;= j &lt; arr2.length</code> 。</p>\n\n<p>返回上述列表的 <strong>异或和</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr1 = [1,2,3], arr2 = [6,5]\n<strong>输出：</strong>0\n<strong>解释：</strong>列表 = [1 AND 6, 1 AND 5, 2 AND 6, 2 AND 5, 3 AND 6, 3 AND 5] = [0,1,2,0,2,1] ，\n异或和 = 0 XOR 1 XOR 2 XOR 0 XOR 2 XOR 1 = 0 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr1 = [12], arr2 = [4]\n<strong>输出：</strong>4\n<strong>解释：</strong>列表 = [12 AND 4] = [4] ，异或和 = 4 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr1.length, arr2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= arr1[i], arr2[j] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1836从未排序的链表中移除重复元素",
        "hardRate": "MEDIUM",
        "passRate": "73.12%",
        "problemsUrl": "https://leetcode.cn/problems/remove-duplicates-from-an-unsorted-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-duplicates-from-an-unsorted-linked-list/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1837K 进制表示下的各位数字总和",
        "hardRate": "EASY",
        "passRate": "79.32%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-digits-in-base-k/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-digits-in-base-k/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code>（<code>10</code> 进制）和一个基数 <code>k</code> ，请你将 <code>n</code> 从 <code>10</code> 进制表示转换为 <code>k</code> 进制表示，计算并返回转换后各位数字的 <strong>总和</strong> 。</p>\n\n<p>转换后，各位数字应当视作是 <code>10</code> 进制数字，且它们的总和也应当按 <code>10</code> 进制表示返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 34, k = 6\n<strong>输出：</strong>9\n<strong>解释：</strong>34 (10 进制) 在 6 进制下表示为 54 。5 + 4 = 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10, k = 10\n<strong>输出：</strong>1\n<strong>解释：</strong>n 本身就是 10 进制。 1 + 0 = 1 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>2 <= k <= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1838最高频元素的频数",
        "hardRate": "MEDIUM",
        "passRate": "43.05%",
        "problemsUrl": "https://leetcode.cn/problems/frequency-of-the-most-frequent-element/",
        "solutionsUrl": "https://leetcode.cn/problems/frequency-of-the-most-frequent-element/solution",
        "problemsDesc": "<p>元素的 <strong>频数</strong> 是该元素在一个数组中出现的次数。</p>\n\n<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。在一步操作中，你可以选择 <code>nums</code> 的一个下标，并将该下标对应元素的值增加 <code>1</code> 。</p>\n\n<p>执行最多 <code>k</code> 次操作后，返回数组中最高频元素的 <strong>最大可能频数</strong> <em>。</em></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,4], k = 5\n<strong>输出：</strong>3<strong>\n解释：</strong>对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums = [4,4,4] 。\n4 是数组中最高频元素，频数是 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,4,8,13], k = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>存在多种最优解决方案：\n- 对第一个元素执行 3 次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。\n- 对第二个元素执行 4 次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。\n- 对第三个元素执行 5 次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,9,6], k = 2\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= k <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1839所有元音按顺序排布的最长子字符串",
        "hardRate": "MEDIUM",
        "passRate": "49.13%",
        "problemsUrl": "https://leetcode.cn/problems/longest-substring-of-all-vowels-in-order/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-substring-of-all-vowels-in-order/solution",
        "problemsDesc": "<p>当一个字符串满足如下条件时，我们称它是 <b>美丽的</b> ：</p>\n\n<ul>\n\t<li>所有 5 个英文元音字母（<code>'a'</code> ，<code>'e'</code> ，<code>'i'</code> ，<code>'o'</code> ，<code>'u'</code>）都必须 <strong>至少</strong> 出现一次。</li>\n\t<li>这些元音字母的顺序都必须按照 <strong>字典序</strong> 升序排布（也就是说所有的 <code>'a'</code> 都在 <code>'e'</code> 前面，所有的 <code>'e'</code> 都在 <code>'i'</code> 前面，以此类推）</li>\n</ul>\n\n<p>比方说，字符串 <code>\"aeiou\"</code> 和 <code>\"aaaaaaeiiiioou\"</code> 都是 <strong>美丽的</strong> ，但是 <code>\"uaeio\"</code> ，<code>\"aeoiu\"</code> 和 <code>\"aaaeeeooo\"</code> <strong>不是美丽的</strong> 。</p>\n\n<p>给你一个只包含英文元音字母的字符串 <code>word</code> ，请你返回 <code>word</code> 中 <strong>最长美丽子字符串的长度</strong> 。如果不存在这样的子字符串，请返回 <code>0</code> 。</p>\n\n<p><strong>子字符串</strong> 是字符串中一个连续的字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>word = \"aeiaaio<strong>aaaaeiiiiouuu</strong>ooaauuaeiu\"\n<b>输出：</b>13\n<b>解释：</b>最长子字符串是 \"aaaaeiiiiouuu\" ，长度为 13 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>word = \"aeeeiiiioooauuu<strong>aeiou</strong>\"\n<b>输出：</b>5\n<b>解释：</b>最长子字符串是 \"aeiou\" ，长度为 5 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>word = \"a\"\n<b>输出：</b>0\n<b>解释：</b>没有美丽子字符串，所以返回 0 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word.length <= 5 * 10<sup>5</sup></code></li>\n\t<li><code>word</code> 只包含字符 <code>'a'</code>，<code>'e'</code>，<code>'i'</code>，<code>'o'</code> 和 <code>'u'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1840最高建筑高度",
        "hardRate": "HARD",
        "passRate": "39.46%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-building-height/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-building-height/solution",
        "problemsDesc": "<p>在一座城市里，你需要建 <code>n</code> 栋新的建筑。这些新的建筑会从 <code>1</code> 到 <code>n</code> 编号排成一列。</p>\n\n<p>这座城市对这些新建筑有一些规定：</p>\n\n<ul>\n\t<li>每栋建筑的高度必须是一个非负整数。</li>\n\t<li>第一栋建筑的高度 <strong>必须</strong> 是 <code>0</code> 。</li>\n\t<li>任意两栋相邻建筑的高度差 <strong>不能超过</strong>  <code>1</code> 。</li>\n</ul>\n\n<p>除此以外，某些建筑还有额外的最高高度限制。这些限制会以二维整数数组 <code>restrictions</code> 的形式给出，其中 <code>restrictions[i] = [id<sub>i</sub>, maxHeight<sub>i</sub>]</code> ，表示建筑 <code>id<sub>i</sub></code> 的高度 <strong>不能超过</strong> <code>maxHeight<sub>i</sub></code> 。</p>\n\n<p>题目保证每栋建筑在 <code>restrictions</code> 中<strong> 至多出现一次</strong> ，同时建筑 <code>1</code> <strong>不会</strong> 出现在 <code>restrictions</code> 中。</p>\n\n<p>请你返回 <strong>最高</strong> 建筑能达到的 <strong>最高高度</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/25/ic236-q4-ex1-1.png\" style=\"width: 400px; height: 253px;\" />\n<pre>\n<b>输入：</b>n = 5, restrictions = [[2,1],[4,1]]\n<b>输出：</b>2\n<b>解释：</b>上图中的绿色区域为每栋建筑被允许的最高高度。\n我们可以使建筑高度分别为 [0,1,2,1,2] ，最高建筑的高度为 2 。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/25/ic236-q4-ex2.png\" style=\"width: 500px; height: 269px;\" />\n<pre>\n<b>输入：</b>n = 6, restrictions = []\n<b>输出：</b>5\n<b>解释：</b>上图中的绿色区域为每栋建筑被允许的最高高度。\n我们可以使建筑高度分别为 [0,1,2,3,4,5] ，最高建筑的高度为 5 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/25/ic236-q4-ex3.png\" style=\"width: 500px; height: 187px;\" />\n<pre>\n<b>输入：</b>n = 10, restrictions = [[5,3],[2,5],[7,4],[10,3]]\n<b>输出：</b>5\n<b>解释：</b>上图中的绿色区域为每栋建筑被允许的最高高度。\n我们可以使建筑高度分别为 [0,1,2,3,3,4,4,5,4,3] ，最高建筑的高度为 5 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 10<sup>9</sup></code></li>\n\t<li><code>0 <= restrictions.length <= min(n - 1, 10<sup>5</sup>)</code></li>\n\t<li><code>2 <= id<sub>i</sub> <= n</code></li>\n\t<li><code>id<sub>i</sub></code> 是 <strong>唯一的</strong> 。</li>\n\t<li><code>0 <= maxHeight<sub>i</sub> <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1841联赛信息统计",
        "hardRate": "MEDIUM",
        "passRate": "52.71%",
        "problemsUrl": "https://leetcode.cn/problems/league-statistics/",
        "solutionsUrl": "https://leetcode.cn/problems/league-statistics/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1842下个由相同数字构成的回文串",
        "hardRate": "HARD",
        "passRate": "55.71%",
        "problemsUrl": "https://leetcode.cn/problems/next-palindrome-using-same-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/next-palindrome-using-same-digits/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1843可疑银行账户",
        "hardRate": "MEDIUM",
        "passRate": "43.73%",
        "problemsUrl": "https://leetcode.cn/problems/suspicious-bank-accounts/",
        "solutionsUrl": "https://leetcode.cn/problems/suspicious-bank-accounts/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1844将所有数字用字符替换",
        "hardRate": "EASY",
        "passRate": "78.63%",
        "problemsUrl": "https://leetcode.cn/problems/replace-all-digits-with-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/replace-all-digits-with-characters/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，它的 <strong>偶数</strong> 下标处为小写英文字母，<strong>奇数</strong> 下标处为数字。</p>\n\n<p>定义一个函数 <code>shift(c, x)</code> ，其中 <code>c</code> 是一个字符且 <code>x</code> 是一个数字，函数返回字母表中 <code>c</code> 后面第 <code>x</code> 个字符。</p>\n\n<ul>\n\t<li>比方说，<code>shift('a', 5) = 'f'</code> 和 <code>shift('x', 0) = 'x'</code> 。</li>\n</ul>\n\n<p>对于每个 <strong>奇数</strong> 下标 <code>i</code> ，你需要将数字 <code>s[i]</code> 用 <code>shift(s[i-1], s[i])</code> 替换。</p>\n\n<p>请你替换所有数字以后，将字符串 <code>s</code> 返回。题目 <strong>保证</strong><em> </em><code>shift(s[i-1], s[i])</code> 不会超过 <code>'z'</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"a1c1e1\"\n<b>输出：</b>\"abcdef\"\n<strong>解释：</strong>数字被替换结果如下：\n- s[1] -&gt; shift('a',1) = 'b'\n- s[3] -&gt; shift('c',1) = 'd'\n- s[5] -&gt; shift('e',1) = 'f'</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"a1b2c3d4e\"\n<b>输出：</b>\"abbdcfdhe\"\n<strong>解释：</strong>数字被替换结果如下：\n- s[1] -&gt; shift('a',1) = 'b'\n- s[3] -&gt; shift('b',2) = 'd'\n- s[5] -&gt; shift('c',3) = 'f'\n- s[7] -&gt; shift('d',4) = 'h'</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 只包含小写英文字母和数字。</li>\n\t<li>对所有 <strong>奇数</strong> 下标处的 <code>i</code> ，满足 <code>shift(s[i-1], s[i]) &lt;= 'z'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1845座位预约管理系统",
        "hardRate": "MEDIUM",
        "passRate": "48.12%",
        "problemsUrl": "https://leetcode.cn/problems/seat-reservation-manager/",
        "solutionsUrl": "https://leetcode.cn/problems/seat-reservation-manager/solution",
        "problemsDesc": "<p>请你设计一个管理 <code>n</code> 个座位预约的系统，座位编号从 <code>1</code> 到 <code>n</code> 。</p>\n\n<p>请你实现 <code>SeatManager</code> 类：</p>\n\n<ul>\n\t<li><code>SeatManager(int n)</code> 初始化一个 <code>SeatManager</code> 对象，它管理从 <code>1</code> 到 <code>n</code> 编号的 <code>n</code> 个座位。所有座位初始都是可预约的。</li>\n\t<li><code>int reserve()</code> 返回可以预约座位的 <strong>最小编号</strong> ，此座位变为不可预约。</li>\n\t<li><code>void unreserve(int seatNumber)</code> 将给定编号 <code>seatNumber</code> 对应的座位变成可以预约。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>\n[\"SeatManager\", \"reserve\", \"reserve\", \"unreserve\", \"reserve\", \"reserve\", \"reserve\", \"reserve\", \"unreserve\"]\n[[5], [], [], [2], [], [], [], [], [5]]\n<strong>输出：</strong>\n[null, 1, 2, null, 2, 3, 4, 5, null]\n\n<strong>解释：</strong>\nSeatManager seatManager = new SeatManager(5); // 初始化 SeatManager ，有 5 个座位。\nseatManager.reserve();    // 所有座位都可以预约，所以返回最小编号的座位，也就是 1 。\nseatManager.reserve();    // 可以预约的座位为 [2,3,4,5] ，返回最小编号的座位，也就是 2 。\nseatManager.unreserve(2); // 将座位 2 变为可以预约，现在可预约的座位为 [2,3,4,5] 。\nseatManager.reserve();    // 可以预约的座位为 [2,3,4,5] ，返回最小编号的座位，也就是 2 。\nseatManager.reserve();    // 可以预约的座位为 [3,4,5] ，返回最小编号的座位，也就是 3 。\nseatManager.reserve();    // 可以预约的座位为 [4,5] ，返回最小编号的座位，也就是 4 。\nseatManager.reserve();    // 唯一可以预约的是座位 5 ，所以返回 5 。\nseatManager.unreserve(5); // 将座位 5 变为可以预约，现在可预约的座位为 [5] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= seatNumber &lt;= n</code></li>\n\t<li>每一次对 <code>reserve</code> 的调用，题目保证至少存在一个可以预约的座位。</li>\n\t<li>每一次对 <code>unreserve</code> 的调用，题目保证 <code>seatNumber</code> 在调用函数前都是被预约状态。</li>\n\t<li>对 <code>reserve</code> 和 <code>unreserve</code> 的调用 <strong>总共</strong> 不超过 <code>10<sup>5</sup></code> 次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1846减小和重新排列数组后的最大元素",
        "hardRate": "MEDIUM",
        "passRate": "63.05%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-element-after-decreasing-and-rearranging/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-element-after-decreasing-and-rearranging/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>arr</code> 。请你对 <code>arr</code> 执行一些操作（也可以不进行任何操作），使得数组满足以下条件：</p>\n\n<ul>\n\t<li><code>arr</code> 中 <strong>第一个</strong> 元素必须为 <code>1</code> 。</li>\n\t<li>任意相邻两个元素的差的绝对值 <strong>小于等于</strong> <code>1</code> ，也就是说，对于任意的 <code>1 <= i < arr.length</code> （<strong>数组下标从 0 开始</strong>），都满足 <code>abs(arr[i] - arr[i - 1]) <= 1</code> 。<code>abs(x)</code> 为 <code>x</code> 的绝对值。</li>\n</ul>\n\n<p>你可以执行以下 2 种操作任意次：</p>\n\n<ul>\n\t<li><strong>减小</strong> <code>arr</code> 中任意元素的值，使其变为一个 <strong>更小的正整数</strong> 。</li>\n\t<li><strong>重新排列</strong> <code>arr</code> 中的元素，你可以以任意顺序重新排列。</li>\n</ul>\n\n<p>请你返回执行以上操作后，在满足前文所述的条件下，<code>arr</code> 中可能的 <strong>最大值</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [2,2,1,2,1]\n<b>输出：</b>2\n<b>解释：</b>\n我们可以重新排列 arr 得到 <code>[1,2,2,2,1] ，该数组满足所有条件。</code>\narr 中最大元素为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [100,1,1000]\n<b>输出：</b>3\n<b>解释：</b>\n一个可行的方案如下：\n1. 重新排列 <code>arr</code> 得到 <code>[1,100,1000] 。</code>\n2. 将第二个元素减小为 2 。\n3. 将第三个元素减小为 3 。\n现在 <code>arr = [1,2,3] ，满足所有条件。</code>\narr 中最大元素为 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [1,2,3,4,5]\n<b>输出：</b>5\n<b>解释：</b>数组已经满足所有条件，最大元素为 5 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= arr.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= arr[i] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1847最近的房间",
        "hardRate": "HARD",
        "passRate": "39.92%",
        "problemsUrl": "https://leetcode.cn/problems/closest-room/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-room/solution",
        "problemsDesc": "<p>一个酒店里有 <code>n</code> 个房间，这些房间用二维整数数组 <code>rooms</code> 表示，其中 <code>rooms[i] = [roomId<sub>i</sub>, size<sub>i</sub>]</code> 表示有一个房间号为 <code>roomId<sub>i</sub></code> 的房间且它的面积为 <code>size<sub>i</sub></code> 。每一个房间号 <code>roomId<sub>i</sub></code> 保证是 <strong>独一无二</strong> 的。</p>\n\n<p>同时给你 <code>k</code> 个查询，用二维数组 <code>queries</code> 表示，其中 <code>queries[j] = [preferred<sub>j</sub>, minSize<sub>j</sub>]</code> 。第 <code>j</code> 个查询的答案是满足如下条件的房间 <code>id</code> ：</p>\n\n<ul>\n\t<li>房间的面积 <b>至少</b> 为 <code>minSize<sub>j</sub></code> ，且</li>\n\t<li><code>abs(id - preferred<sub>j</sub>)</code> 的值 <strong>最小</strong> ，其中 <code>abs(x)</code> 是 <code>x</code> 的绝对值。</li>\n</ul>\n\n<p>如果差的绝对值有 <strong>相等</strong> 的，选择 <strong>最小</strong> 的 <code>id</code> 。如果 <strong>没有满足条件的房间</strong> ，答案为 <code>-1</code> 。</p>\n\n<p>请你返回长度为 <code>k</code> 的数组 <code>answer</code> ，其中<em> </em><code>answer[j]</code> 为第 <code>j</code> 个查询的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>rooms = [[2,2],[1,2],[3,2]], queries = [[3,1],[3,3],[5,2]]\n<b>输出：</b>[3,-1,3]\n<strong>解释：</strong>查询的答案如下：\n查询 [3,1] ：房间 3 的面积为 2 ，大于等于 1 ，且号码是最接近 3 的，为 abs(3 - 3) = 0 ，所以答案为 3 。\n查询 [3,3] ：没有房间的面积至少为 3 ，所以答案为 -1 。\n查询 [5,2] ：房间 3 的面积为 2 ，大于等于 2 ，且号码是最接近 5 的，为 abs(3 - 5) = 2 ，所以答案为 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>rooms = [[1,4],[2,3],[3,5],[4,1],[5,2]], queries = [[2,3],[2,4],[2,5]]\n<b>输出：</b>[2,1,3]\n<strong>解释：</strong>查询的答案如下：\n查询 [2,3] ：房间 2 的面积为 3 ，大于等于 3 ，且号码是最接近的，为 abs(2 - 2) = 0 ，所以答案为 2 。\n查询 [2,4] ：房间 1 和 3 的面积都至少为 4 ，答案为 1 因为它房间编号更小。\n查询 [2,5] ：房间 3 是唯一面积大于等于 5 的，所以答案为 3 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == rooms.length</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>k == queries.length</code></li>\n\t<li><code>1 <= k <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= roomId<sub>i</sub>, preferred<sub>j</sub> <= 10<sup>7</sup></code></li>\n\t<li><code>1 <= size<sub>i</sub>, minSize<sub>j</sub> <= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1848到目标元素的最小距离",
        "hardRate": "EASY",
        "passRate": "66.17%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-distance-to-the-target-element/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-distance-to-the-target-element/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> （下标 <strong>从 0 开始</strong> 计数）以及两个整数 <code>target</code> 和 <code>start</code> ，请你找出一个下标 <code>i</code> ，满足 <code>nums[i] == target</code> 且 <code>abs(i - start)</code> <strong>最小化</strong> 。注意：<code>abs(x)</code> 表示 <code>x</code> 的绝对值。</p>\n\n<p>返回 <code>abs(i - start)</code> 。</p>\n\n<p>题目数据保证 <code>target</code> 存在于 <code>nums</code> 中。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4,5], target = 5, start = 3\n<strong>输出：</strong>1\n<strong>解释：</strong>nums[4] = 5 是唯一一个等于 target 的值，所以答案是 abs(4 - 3) = 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1], target = 1, start = 0\n<strong>输出：</strong>0\n<strong>解释：</strong>nums[0] = 1 是唯一一个等于 target 的值，所以答案是 abs(0 - 0) = 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0\n<strong>输出：</strong>0\n<strong>解释：</strong>nums 中的每个值都是 1 ，但 nums[0] 使 abs(i - start) 的结果得以最小化，所以答案是 abs(0 - 0) = 0 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 1000</code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>4</sup></code></li>\n\t<li><code>0 <= start < nums.length</code></li>\n\t<li><code>target</code> 存在于 <code>nums</code> 中</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1849将字符串拆分为递减的连续值",
        "hardRate": "MEDIUM",
        "passRate": "33.22%",
        "problemsUrl": "https://leetcode.cn/problems/splitting-a-string-into-descending-consecutive-values/",
        "solutionsUrl": "https://leetcode.cn/problems/splitting-a-string-into-descending-consecutive-values/solution",
        "problemsDesc": "<p>给你一个仅由数字组成的字符串 <code>s</code> 。</p>\n\n<p>请你判断能否将 <code>s</code> 拆分成两个或者多个 <strong>非空子字符串</strong> ，使子字符串的 <strong>数值</strong> 按 <strong>降序</strong> 排列，且每两个 <strong>相邻子字符串</strong> 的数值之 <strong>差 </strong>等于 <code>1</code> 。</p>\n\n<ul>\n\t<li>例如，字符串 <code>s = \"0090089\"</code> 可以拆分成 <code>[\"0090\", \"089\"]</code> ，数值为 <code>[90,89]</code> 。这些数值满足按降序排列，且相邻值相差 <code>1</code> ，这种拆分方法可行。</li>\n\t<li>另一个例子中，字符串 <code>s = \"001\"</code> 可以拆分成 <code>[\"0\", \"01\"]</code>、<code>[\"00\", \"1\"]</code> 或 <code>[\"0\", \"0\", \"1\"]</code> 。然而，所有这些拆分方法都不可行，因为对应数值分别是 <code>[0,1]</code>、<code>[0,1]</code> 和 <code>[0,0,1]</code> ，都不满足按降序排列的要求。</li>\n</ul>\n\n<p>如果可以按要求拆分 <code>s</code> ，返回 <code>true</code> ；否则，返回 <code>false</code><em> </em>。</p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1234\"\n<strong>输出：</strong>false\n<strong>解释：</strong>不存在拆分 s 的可行方法。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"050043\"\n<strong>输出：</strong>true\n<strong>解释：</strong>s 可以拆分为 [\"05\", \"004\", \"3\"] ，对应数值为 [5,4,3] 。\n满足按降序排列，且相邻值相差 <code>1</code> 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"9080701\"\n<strong>输出：</strong>false\n<strong>解释：</strong>不存在拆分 s 的可行方法。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"10009998\"\n<strong>输出：</strong>true\n<strong>解释：</strong>s 可以拆分为 [\"100\", \"099\", \"98\"] ，对应数值为 [100,99,98] 。\n满足按降序排列，且相邻值相差 <code>1</code> 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 20</code></li>\n\t<li><code>s</code> 仅由数字组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1850邻位交换的最小次数",
        "hardRate": "MEDIUM",
        "passRate": "62.77%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/solution",
        "problemsDesc": "<p>给你一个表示大整数的字符串 <code>num</code> ，和一个整数 <code>k</code> 。</p>\n\n<p>如果某个整数是 <code>num</code> 中各位数字的一个 <strong>排列</strong> 且它的 <strong>值大于</strong> <code>num</code> ，则称这个整数为 <strong>妙数</strong> 。可能存在很多妙数，但是只需要关注 <strong>值最小</strong> 的那些。</p>\n\n<ul>\n\t<li>例如，<code>num = \"5489355142\"</code> ：\n\n\t<ul>\n\t\t<li>第 1 个最小妙数是 <code>\"5489355214\"</code></li>\n\t\t<li>第 2 个最小妙数是 <code>\"5489355241\"</code></li>\n\t\t<li>第 3 个最小妙数是 <code>\"5489355412\"</code></li>\n\t\t<li>第 4 个最小妙数是 <code>\"5489355421\"</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>返回要得到第 <code>k</code> 个 <strong>最小妙数</strong> 需要对 <code>num</code> 执行的 <strong>相邻位数字交换的最小次数</strong> 。</p>\n\n<p>测试用例是按存在第 <code>k</code> 个最小妙数而生成的。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = \"5489355142\", k = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>第 4 个最小妙数是 \"5489355421\" ，要想得到这个数字：\n- 交换下标 7 和下标 8 对应的位：\"5489355<strong>14</strong>2\" -&gt; \"5489355<strong>41</strong>2\"\n- 交换下标 8 和下标 9 对应的位：\"54893554<strong>12</strong>\" -&gt; \"54893554<strong>21</strong>\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = \"11112\", k = 4\n<strong>输出：</strong>4\n<strong>解释：</strong>第 4 个最小妙数是 \"21111\" ，要想得到这个数字：\n- 交换下标 3 和下标 4 对应的位：\"111<strong>12</strong>\" -&gt; \"111<strong>21</strong>\"\n- 交换下标 2 和下标 3 对应的位：\"11<strong>12</strong>1\" -&gt; \"11<strong>21</strong>1\"\n- 交换下标 1 和下标 2 对应的位：\"1<strong>12</strong>11\" -&gt; \"1<strong>21</strong>11\"\n- 交换下标 0 和下标 1 对应的位：\"<strong>12</strong>111\" -&gt; \"<strong>21</strong>111\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = \"00123\", k = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>第 1 个最小妙数是 \"00132\" ，要想得到这个数字：\n- 交换下标 3 和下标 4 对应的位：\"001<strong>23</strong>\" -&gt; \"001<strong>32</strong>\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= num.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= k &lt;= 1000</code></li>\n\t<li><code>num</code> 仅由数字组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1851包含每个查询的最小区间",
        "hardRate": "HARD",
        "passRate": "44.07%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-interval-to-include-each-query/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-interval-to-include-each-query/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>intervals</code> ，其中 <code>intervals[i] = [left<sub>i</sub>, right<sub>i</sub>]</code> 表示第 <code>i</code> 个区间开始于 <code>left<sub>i</sub></code> 、结束于 <code>right<sub>i</sub></code>（包含两侧取值，<strong>闭区间</strong>）。区间的 <strong>长度</strong> 定义为区间中包含的整数数目，更正式地表达是 <code>right<sub>i</sub> - left<sub>i</sub> + 1</code> 。</p>\n\n<p>再给你一个整数数组 <code>queries</code> 。第 <code>j</code> 个查询的答案是满足 <code>left<sub>i</sub> <= queries[j] <= right<sub>i</sub></code> 的 <strong>长度最小区间 <code>i</code> 的长度</strong> 。如果不存在这样的区间，那么答案是 <code>-1</code> 。</p>\n\n<p>以数组形式返回对应查询的所有答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]\n<strong>输出：</strong>[3,3,1,4]\n<strong>解释：</strong>查询处理如下：\n- Query = 2 ：区间 [2,4] 是包含 2 的最小区间，答案为 4 - 2 + 1 = 3 。\n- Query = 3 ：区间 [2,4] 是包含 3 的最小区间，答案为 4 - 2 + 1 = 3 。\n- Query = 4 ：区间 [4,4] 是包含 4 的最小区间，答案为 4 - 4 + 1 = 1 。\n- Query = 5 ：区间 [3,6] 是包含 5 的最小区间，答案为 6 - 3 + 1 = 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]\n<strong>输出：</strong>[2,-1,4,6]\n<strong>解释：</strong>查询处理如下：\n- Query = 2 ：区间 [2,3] 是包含 2 的最小区间，答案为 3 - 2 + 1 = 2 。\n- Query = 19：不存在包含 19 的区间，答案为 -1 。\n- Query = 5 ：区间 [2,5] 是包含 5 的最小区间，答案为 5 - 2 + 1 = 4 。\n- Query = 22：区间 [20,25] 是包含 22 的最小区间，答案为 25 - 20 + 1 = 6 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= intervals.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= queries.length <= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>1 <= left<sub>i</sub> <= right<sub>i</sub> <= 10<sup>7</sup></code></li>\n\t<li><code>1 <= queries[j] <= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1852每个子数组的数字种类数",
        "hardRate": "MEDIUM",
        "passRate": "59.49%",
        "problemsUrl": "https://leetcode.cn/problems/distinct-numbers-in-each-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/distinct-numbers-in-each-subarray/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1853转换日期格式",
        "hardRate": "EASY",
        "passRate": "62.84%",
        "problemsUrl": "https://leetcode.cn/problems/convert-date-format/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-date-format/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1854人口最多的年份",
        "hardRate": "EASY",
        "passRate": "72.34%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-population-year/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-population-year/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>logs</code> ，其中每个 <code>logs[i] = [birth<sub>i</sub>, death<sub>i</sub>]</code> 表示第 <code>i</code> 个人的出生和死亡年份。</p>\n\n<p>年份 <code>x</code> 的 <strong>人口</strong> 定义为这一年期间活着的人的数目。第 <code>i</code> 个人被计入年份 <code>x</code> 的人口需要满足：<code>x</code> 在闭区间 <code>[birth<sub>i</sub>, death<sub>i</sub> - 1]</code> 内。注意，人不应当计入他们死亡当年的人口中。</p>\n\n<p>返回 <strong>人口最多</strong> 且 <strong>最早</strong> 的年份。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>logs = [[1993,1999],[2000,2010]]\n<strong>输出：</strong>1993\n<strong>解释：</strong>人口最多为 1 ，而 1993 是人口为 1 的最早年份。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>logs = [[1950,1961],[1960,1971],[1970,1981]]\n<strong>输出：</strong>1960\n<strong>解释：</strong> \n人口最多为 2 ，分别出现在 1960 和 1970 。\n其中最早年份是 1960 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= logs.length &lt;= 100</code></li>\n\t<li><code>1950 &lt;= birth<sub>i</sub> &lt; death<sub>i</sub> &lt;= 2050</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1855下标对中的最大距离",
        "hardRate": "MEDIUM",
        "passRate": "59.43%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-distance-between-a-pair-of-values/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-distance-between-a-pair-of-values/solution",
        "problemsDesc": "<p>给你两个 <strong>非递增</strong> 的整数数组 <code>nums1</code>​​​​​​ 和 <code>nums2</code>​​​​​​ ，数组下标均 <strong>从 0 开始</strong> 计数。</p>\n\n<p>下标对 <code>(i, j)</code> 中 <code>0 &lt;= i &lt; nums1.length</code> 且 <code>0 &lt;= j &lt; nums2.length</code> 。如果该下标对同时满足 <code>i &lt;= j</code> 且 <code>nums1[i] &lt;= nums2[j]</code> ，则称之为 <strong>有效</strong> 下标对，该下标对的 <strong>距离</strong> 为 <code>j - i</code>​​ 。​​</p>\n\n<p>返回所有 <strong>有效</strong> 下标对<em> </em><code>(i, j)</code><em> </em>中的 <strong>最大距离</strong> 。如果不存在有效下标对，返回 <code>0</code> 。</p>\n\n<p>一个数组 <code>arr</code> ，如果每个 <code>1 &lt;= i &lt; arr.length</code> 均有 <code>arr[i-1] &gt;= arr[i]</code> 成立，那么该数组是一个 <strong>非递增</strong> 数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [55,30,5,4,2], nums2 = [100,20,10,10,5]\n<strong>输出：</strong>2\n<strong>解释：</strong>有效下标对是 (0,0), (2,2), (2,3), (2,4), (3,3), (3,4) 和 (4,4) 。\n最大距离是 2 ，对应下标对 (2,4) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [2,2,2], nums2 = [10,10,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>有效下标对是 (0,0), (0,1) 和 (1,1) 。\n最大距离是 1 ，对应下标对 (0,1) 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [30,29,19,5], nums2 = [25,25,25,25,25]\n<strong>输出：</strong>2\n<strong>解释：</strong>有效下标对是 (2,2), (2,3), (2,4), (3,3) 和 (3,4) 。\n最大距离是 2 ，对应下标对 (2,4) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums1</code> 和 <code>nums2</code> 都是 <strong>非递增</strong> 数组</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1856子数组最小乘积的最大值",
        "hardRate": "MEDIUM",
        "passRate": "37.44%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-subarray-min-product/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-subarray-min-product/solution",
        "problemsDesc": "<p>一个数组的 <strong>最小乘积</strong> 定义为这个数组中 <strong>最小值</strong> <strong>乘以 </strong>数组的 <strong>和</strong> 。</p>\n\n<ul>\n\t<li>比方说，数组 <code>[3,2,5]</code> （最小值是 <code>2</code>）的最小乘积为 <code>2 * (3+2+5) = 2 * 10 = 20</code> 。</li>\n</ul>\n\n<p>给你一个正整数数组 <code>nums</code> ，请你返回 <code>nums</code> 任意 <strong>非空子数组</strong> 的<strong>最小乘积</strong> 的 <strong>最大值</strong> 。由于答案可能很大，请你返回答案对  <code>10<sup>9</sup> + 7</code> <strong>取余 </strong>的结果。</p>\n\n<p>请注意，最小乘积的最大值考虑的是取余操作 <strong>之前</strong> 的结果。题目保证最小乘积的最大值在 <strong>不取余</strong> 的情况下可以用 <strong>64 位有符号整数</strong> 保存。</p>\n\n<p><strong>子数组</strong> 定义为一个数组的 <strong>连续</strong> 部分。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,<strong>2,3,2</strong>]\n<b>输出：</b>14\n<b>解释：</b>最小乘积的最大值由子数组 [2,3,2] （最小值是 2）得到。\n2 * (2+3+2) = 2 * 7 = 14 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,<strong>3,3</strong>,1,2]\n<b>输出：</b>18\n<b>解释：</b>最小乘积的最大值由子数组 [3,3] （最小值是 3）得到。\n3 * (3+3) = 3 * 6 = 18 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,1,<strong>5,6,4</strong>,2]\n<b>输出：</b>60\n<b>解释：</b>最小乘积的最大值由子数组 [5,6,4] （最小值是 4）得到。\n4 * (5+6+4) = 4 * 15 = 60 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1857有向图中最大颜色值",
        "hardRate": "HARD",
        "passRate": "49.03%",
        "problemsUrl": "https://leetcode.cn/problems/largest-color-value-in-a-directed-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-color-value-in-a-directed-graph/solution",
        "problemsDesc": "<p>给你一个 <strong>有向图</strong> ，它含有 <code>n</code> 个节点和 <code>m</code> 条边。节点编号从 <code>0</code> 到 <code>n - 1</code> 。</p>\n\n<p>给你一个字符串 <code>colors</code> ，其中 <code>colors[i]</code> 是小写英文字母，表示图中第 <code>i</code> 个节点的 <b>颜色</b> （下标从 <strong>0</strong> 开始）。同时给你一个二维数组 <code>edges</code> ，其中 <code>edges[j] = [a<sub>j</sub>, b<sub>j</sub>]</code> 表示从节点 <code>a<sub>j</sub></code> 到节点 <code>b<sub>j</sub></code><sub> </sub>有一条 <strong>有向边</strong> 。</p>\n\n<p>图中一条有效 <strong>路径</strong> 是一个点序列 <code>x<sub>1</sub> -&gt; x<sub>2</sub> -&gt; x<sub>3</sub> -&gt; ... -&gt; x<sub>k</sub></code> ，对于所有 <code>1 &lt;= i &lt; k</code> ，从 <code>x<sub>i</sub></code> 到 <code>x<sub>i+1</sub></code> 在图中有一条有向边。路径的 <strong>颜色值</strong> 是路径中 <strong>出现次数最多</strong> 颜色的节点数目。</p>\n\n<p>请你返回给定图中有效路径里面的 <strong>最大颜色值</strong><strong> 。</strong>如果图中含有环，请返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/21/leet1.png\" style=\"width: 400px; height: 182px;\"></p>\n\n<pre><b>输入：</b>colors = \"abaca\", edges = [[0,1],[0,2],[2,3],[3,4]]\n<b>输出：</b>3\n<b>解释：</b>路径 0 -&gt; 2 -&gt; 3 -&gt; 4 含有 3 个颜色为 <code>\"a\" 的节点（上图中的红色节点）。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/21/leet2.png\" style=\"width: 85px; height: 85px;\"></p>\n\n<pre><b>输入：</b>colors = \"a\", edges = [[0,0]]\n<b>输出：</b>-1\n<b>解释：</b>从 0 到 0 有一个环。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == colors.length</code></li>\n\t<li><code>m == edges.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>colors</code> 只含有小写英文字母。</li>\n\t<li><code>0 &lt;= a<sub>j</sub>, b<sub>j</sub> &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1858包含所有前缀的最长单词",
        "hardRate": "MEDIUM",
        "passRate": "66.05%",
        "problemsUrl": "https://leetcode.cn/problems/longest-word-with-all-prefixes/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-word-with-all-prefixes/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1859将句子排序",
        "hardRate": "EASY",
        "passRate": "72.85%",
        "problemsUrl": "https://leetcode.cn/problems/sorting-the-sentence/",
        "solutionsUrl": "https://leetcode.cn/problems/sorting-the-sentence/solution",
        "problemsDesc": "<p>一个 <strong>句子</strong> 指的是一个序列的单词用单个空格连接起来，且开头和结尾没有任何空格。每个单词都只包含小写或大写英文字母。</p>\n\n<p>我们可以给一个句子添加 <strong>从 1 开始的单词位置索引 </strong>，并且将句子中所有单词 <strong>打乱顺序</strong> 。</p>\n\n<ul>\n\t<li>比方说，句子 <code>\"This is a sentence\"</code> 可以被打乱顺序得到 <code>\"sentence4 a3 is2 This1\"</code> 或者 <code>\"is2 sentence4 This1 a3\"</code> 。</li>\n</ul>\n\n<p>给你一个 <strong>打乱顺序</strong> 的句子 <code>s</code> ，它包含的单词不超过 <code>9</code> 个，请你重新构造并得到原本顺序的句子。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"is2 sentence4 This1 a3\"\n<b>输出：</b>\"This is a sentence\"\n<b>解释：</b>将 s 中的单词按照初始位置排序，得到 \"This1 is2 a3 sentence4\" ，然后删除数字。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"Myself2 Me1 I4 and3\"\n<b>输出：</b>\"Me Myself and I\"\n<b>解释：</b>将 s 中的单词按照初始位置排序，得到 \"Me1 Myself2 and3 I4\" ，然后删除数字。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= s.length <= 200</code></li>\n\t<li><code>s</code> 只包含小写和大写英文字母、空格以及从 <code>1</code> 到 <code>9</code> 的数字。</li>\n\t<li><code>s</code> 中单词数目为 <code>1</code> 到 <code>9</code> 个。</li>\n\t<li><code>s</code> 中的单词由单个空格分隔。</li>\n\t<li><code>s</code> 不包含任何前导或者后缀空格。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1860增长的内存泄露",
        "hardRate": "MEDIUM",
        "passRate": "76.01%",
        "problemsUrl": "https://leetcode.cn/problems/incremental-memory-leak/",
        "solutionsUrl": "https://leetcode.cn/problems/incremental-memory-leak/solution",
        "problemsDesc": "<p>给你两个整数 <code>memory1</code> 和 <code>memory2</code> 分别表示两个内存条剩余可用内存的位数。现在有一个程序每秒递增的速度消耗着内存。</p>\n\n<p>在第 <code>i</code> 秒（秒数从 1 开始），有 <code>i</code> 位内存被分配到 <strong>剩余内存较多</strong> 的内存条（如果两者一样多，则分配到第一个内存条）。如果两者剩余内存都不足 <code>i</code> 位，那么程序将 <b>意外退出</b> 。</p>\n\n<p>请你返回一个数组，包含<em> </em><code>[crashTime, memory1<sub>crash</sub>, memory2<sub>crash</sub>]</code> ，其中 <code>crashTime</code>是程序意外退出的时间（单位为秒），<em> </em><code>memory1<sub>crash</sub></code><em> </em>和<em> </em><code>memory2<sub>crash</sub></code><em> </em>分别是两个内存条最后剩余内存的位数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>memory1 = 2, memory2 = 2\n<b>输出：</b>[3,1,0]\n<b>解释：</b>内存分配如下：\n- 第 1 秒，内存条 1 被占用 1 位内存。内存条 1 现在有 1 位剩余可用内存。\n- 第 2 秒，内存条 2 被占用 2 位内存。内存条 2 现在有 0 位剩余可用内存。\n- 第 3 秒，程序意外退出，两个内存条分别有 1 位和 0 位剩余可用内存。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>memory1 = 8, memory2 = 11\n<b>输出：</b>[6,0,4]\n<b>解释：</b>内存分配如下：\n- 第 1 秒，内存条 2 被占用 1 位内存，内存条 2 现在有 10 位剩余可用内存。\n- 第 2 秒，内存条 2 被占用 2 位内存，内存条 2 现在有 8 位剩余可用内存。\n- 第 3 秒，内存条 1 被占用 3 位内存，内存条 1 现在有 5 位剩余可用内存。\n- 第 4 秒，内存条 2 被占用 4 位内存，内存条 2 现在有 4 位剩余可用内存。\n- 第 5 秒，内存条 1 被占用 5 位内存，内存条 1 现在有 0 位剩余可用内存。\n- 第 6 秒，程序意外退出，两个内存条分别有 0 位和 4 位剩余可用内存。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= memory1, memory2 &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1861旋转盒子",
        "hardRate": "MEDIUM",
        "passRate": "63.40%",
        "problemsUrl": "https://leetcode.cn/problems/rotating-the-box/",
        "solutionsUrl": "https://leetcode.cn/problems/rotating-the-box/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的字符矩阵 <code>box</code> ，它表示一个箱子的侧视图。箱子的每一个格子可能为：</p>\n\n<ul>\n\t<li><code>'#'</code> 表示石头</li>\n\t<li><code>'*'</code> 表示固定的障碍物</li>\n\t<li><code>'.'</code> 表示空位置</li>\n</ul>\n\n<p>这个箱子被 <strong>顺时针旋转 90 度</strong> ，由于重力原因，部分石头的位置会发生改变。每个石头会垂直掉落，直到它遇到障碍物，另一个石头或者箱子的底部。重力 <strong>不会</strong> 影响障碍物的位置，同时箱子旋转不会产生<strong>惯性</strong> ，也就是说石头的水平位置不会发生改变。</p>\n\n<p>题目保证初始时 <code>box</code> 中的石头要么在一个障碍物上，要么在另一个石头上，要么在箱子的底部。</p>\n\n<p>请你返回一个<em> </em><code>n x m</code>的矩阵，表示按照上述旋转后，箱子内的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcodewithstones.png\" style=\"width: 300px; height: 150px;\"></p>\n\n<pre><b>输入：</b>box = [[\"#\",\".\",\"#\"]]\n<b>输出：</b>[[\".\"],\n      [\"#\"],\n      [\"#\"]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcode2withstones.png\" style=\"width: 375px; height: 195px;\"></p>\n\n<pre><b>输入：</b>box = [[\"#\",\".\",\"*\",\".\"],\n            [\"#\",\"#\",\"*\",\".\"]]\n<b>输出：</b>[[\"#\",\".\"],\n      [\"#\",\"#\"],\n      [\"*\",\"*\"],\n      [\".\",\".\"]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcode3withstone.png\" style=\"width: 400px; height: 218px;\"></p>\n\n<pre><b>输入：</b>box = [[\"#\",\"#\",\"*\",\".\",\"*\",\".\"],\n            [\"#\",\"#\",\"#\",\"*\",\".\",\".\"],\n            [\"#\",\"#\",\"#\",\".\",\"#\",\".\"]]\n<b>输出：</b>[[\".\",\"#\",\"#\"],\n      [\".\",\"#\",\"#\"],\n      [\"#\",\"#\",\"*\"],\n      [\"#\",\"*\",\".\"],\n      [\"#\",\".\",\"*\"],\n      [\"#\",\".\",\".\"]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == box.length</code></li>\n\t<li><code>n == box[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>box[i][j]</code> 只可能是 <code>'#'</code> ，<code>'*'</code> 或者 <code>'.'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1862向下取整数对和",
        "hardRate": "HARD",
        "passRate": "34.66%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-floored-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-floored-pairs/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，请你返回所有下标对 <code>0 &lt;= i, j &lt; nums.length</code> 的 <code>floor(nums[i] / nums[j])</code> 结果之和。由于答案可能会很大，请你返回答案对<code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p>函数 <code>floor()</code> 返回输入数字的整数部分。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,5,9]\n<b>输出：</b>10\n<strong>解释：</strong>\nfloor(2 / 5) = floor(2 / 9) = floor(5 / 9) = 0\nfloor(2 / 2) = floor(5 / 5) = floor(9 / 9) = 1\nfloor(5 / 2) = 2\nfloor(9 / 2) = 4\nfloor(9 / 5) = 1\n我们计算每一个数对商向下取整的结果并求和得到 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [7,7,7,7,7,7,7]\n<b>输出：</b>49\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1863找出所有子集的异或总和再求和",
        "hardRate": "EASY",
        "passRate": "84.01%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-all-subset-xor-totals/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-all-subset-xor-totals/solution",
        "problemsDesc": "<p>一个数组的<strong> 异或总和</strong> 定义为数组中所有元素按位 <code>XOR</code> 的结果；如果数组为 <strong>空</strong> ，则异或总和为 <code>0</code> 。</p>\n\n<ul>\n\t<li>例如，数组 <code>[2,5,6]</code> 的 <strong>异或总和</strong> 为 <code>2 XOR 5 XOR 6 = 1</code> 。</li>\n</ul>\n\n<p>给你一个数组 <code>nums</code> ，请你求出 <code>nums</code> 中每个 <strong>子集</strong> 的 <strong>异或总和</strong> ，计算并返回这些值相加之 <strong>和</strong> 。</p>\n\n<p><strong>注意：</strong>在本题中，元素 <strong>相同</strong> 的不同子集应 <strong>多次</strong> 计数。</p>\n\n<p>数组 <code>a</code> 是数组 <code>b</code> 的一个 <strong>子集</strong> 的前提条件是：从 <code>b</code> 删除几个（也可能不删除）元素能够得到 <code>a</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3]\n<strong>输出：</strong>6\n<strong>解释：</strong>[1,3] 共有 4 个子集：\n- 空子集的异或总和是 0 。\n- [1] 的异或总和为 1 。\n- [3] 的异或总和为 3 。\n- [1,3] 的异或总和为 1 XOR 3 = 2 。\n0 + 1 + 3 + 2 = 6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,1,6]\n<strong>输出：</strong>28\n<strong>解释：</strong>[5,1,6] 共有 8 个子集：\n- 空子集的异或总和是 0 。\n- [5] 的异或总和为 5 。\n- [1] 的异或总和为 1 。\n- [6] 的异或总和为 6 。\n- [5,1] 的异或总和为 5 XOR 1 = 4 。\n- [5,6] 的异或总和为 5 XOR 6 = 3 。\n- [1,6] 的异或总和为 1 XOR 6 = 7 。\n- [5,1,6] 的异或总和为 5 XOR 1 XOR 6 = 2 。\n0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,4,5,6,7,8]\n<strong>输出：</strong>480\n<strong>解释：</strong>每个子集的全部异或总和值之和为 480 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 12</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1864构成交替字符串需要的最小交换次数",
        "hardRate": "MEDIUM",
        "passRate": "40.84%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating/solution",
        "problemsDesc": "<p>给你一个二进制字符串 <code>s</code> ，现需要将其转化为一个 <strong>交替字符串</strong> 。请你计算并返回转化所需的 <strong>最小</strong> 字符交换次数，如果无法完成转化，返回<em> </em><code>-1</code><em> </em>。</p>\n\n<p><strong>交替字符串</strong> 是指：相邻字符之间不存在相等情况的字符串。例如，字符串 <code>\"010\"</code> 和 <code>\"1010\"</code> 属于交替字符串，但 <code>\"0100\"</code> 不是。</p>\n\n<p>任意两个字符都可以进行交换，<strong>不必相邻</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"111000\"\n<strong>输出：</strong>1\n<strong>解释：</strong>交换位置 1 和 4：\"1<em><strong>1</strong></em>10<em><strong>0</strong></em>0\" -> \"1<em><strong>0</strong></em>10<em><strong>1</strong></em>0\" ，字符串变为交替字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"010\"\n<strong>输出：</strong>0\n<strong>解释：</strong>字符串已经是交替字符串了，不需要交换。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1110\"\n<strong>输出：</strong>-1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 1000</code></li>\n\t<li><code>s[i]</code> 的值为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1865找出和为指定值的下标对",
        "hardRate": "MEDIUM",
        "passRate": "50.83%",
        "problemsUrl": "https://leetcode.cn/problems/finding-pairs-with-a-certain-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/finding-pairs-with-a-certain-sum/solution",
        "problemsDesc": "<p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，请你实现一个支持下述两类查询的数据结构：</p>\n\n<ol>\n\t<li><strong>累加</strong> ，将一个正整数加到 <code>nums2</code> 中指定下标对应元素上。</li>\n\t<li><strong>计数 </strong>，统计满足 <code>nums1[i] + nums2[j]</code> 等于指定值的下标对 <code>(i, j)</code> 数目（<code>0 <= i < nums1.length</code> 且 <code>0 <= j < nums2.length</code>）。</li>\n</ol>\n\n<p>实现 <code>FindSumPairs</code> 类：</p>\n\n<ul>\n\t<li><code>FindSumPairs(int[] nums1, int[] nums2)</code> 使用整数数组 <code>nums1</code> 和 <code>nums2</code> 初始化 <code>FindSumPairs</code> 对象。</li>\n\t<li><code>void add(int index, int val)</code> 将 <code>val</code> 加到 <code>nums2[index]</code> 上，即，执行 <code>nums2[index] += val</code> 。</li>\n\t<li><code>int count(int tot)</code> 返回满足 <code>nums1[i] + nums2[j] == tot</code> 的下标对 <code>(i, j)</code> 数目。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"FindSumPairs\", \"count\", \"add\", \"count\", \"count\", \"add\", \"add\", \"count\"]\n[[[1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]], [7], [3, 2], [8], [4], [0, 1], [1, 1], [7]]\n<strong>输出：</strong>\n[null, 8, null, 2, 1, null, null, 11]\n\n<strong>解释：</strong>\nFindSumPairs findSumPairs = new FindSumPairs([1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]);\nfindSumPairs.count(7);  // 返回 8 ; 下标对 (2,2), (3,2), (4,2), (2,4), (3,4), (4,4) 满足 2 + 5 = 7 ，下标对 (5,1), (5,5) 满足 3 + 4 = 7\nfindSumPairs.add(3, 2); // 此时 nums2 = [1,4,5,<em><strong>4</strong></em><code>,5,4</code>]\nfindSumPairs.count(8);  // 返回 2 ；下标对 (5,2), (5,4) 满足 3 + 5 = 8\nfindSumPairs.count(4);  // 返回 1 ；下标对 (5,0) 满足 3 + 1 = 4\nfindSumPairs.add(0, 1); // 此时 nums2 = [<em><strong><code>2</code></strong></em>,4,5,4<code>,5,4</code>]\nfindSumPairs.add(1, 1); // 此时 nums2 = [<code>2</code>,<em><strong>5</strong></em>,5,4<code>,5,4</code>]\nfindSumPairs.count(7);  // 返回 11 ；下标对 (2,1), (2,2), (2,4), (3,1), (3,2), (3,4), (4,1), (4,2), (4,4) 满足 2 + 5 = 7 ，下标对 (5,3), (5,5) 满足 3 + 4 = 7\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums1.length <= 1000</code></li>\n\t<li><code>1 <= nums2.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums1[i] <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= nums2[i] <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= index < nums2.length</code></li>\n\t<li><code>1 <= val <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= tot <= 10<sup>9</sup></code></li>\n\t<li>最多调用 <code>add</code> 和 <code>count</code> 函数各 <code>1000</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1866恰有 K 根木棍可以看到的排列数目",
        "hardRate": "HARD",
        "passRate": "61.88%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/solution",
        "problemsDesc": "<p>有 <code>n</code> 根长度互不相同的木棍，长度为从 <code>1</code> 到 <code>n</code> 的整数。请你将这些木棍排成一排，并满足从左侧 <strong>可以看到</strong> <strong>恰好</strong> <code>k</code> 根木棍。从左侧 <strong>可以看到</strong> 木棍的前提是这个木棍的 <strong>左侧</strong> 不存在比它 <strong>更长的</strong> 木棍。</p>\n\n<ul>\n\t<li>例如，如果木棍排列为 <code>[<em><strong>1</strong></em>,<em><strong>3</strong></em>,2,<em><strong>5</strong></em>,4]</code> ，那么从左侧可以看到的就是长度分别为 <code>1</code>、<code>3</code> 、<code>5</code> 的木棍。</li>\n</ul>\n\n<p>给你 <code>n</code> 和 <code>k</code> ，返回符合题目要求的排列 <strong>数目</strong> 。由于答案可能很大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余 </strong>的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 3, k = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>[<strong><em>1</em></strong>,<strong><em>3</em></strong>,2], [<em><strong>2</strong></em>,<em><strong>3</strong></em>,1] 和 [<em><strong>2</strong></em>,1,<em><strong>3</strong></em>] 是仅有的能满足恰好 2 根木棍可以看到的排列。\n可以看到的木棍已经用粗体+斜体标识。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 5, k = 5\n<strong>输出：</strong>1\n<strong>解释：</strong>[<em><strong>1</strong></em>,<em><strong>2</strong></em>,<em><strong>3</strong></em>,<em><strong>4</strong></em>,<em><strong>5</strong></em>] 是唯一一种能满足全部 5 根木棍可以看到的排列。\n可以看到的木棍已经用粗体+斜体标识。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 20, k = 11\n<strong>输出：</strong>647427950\n<strong>解释：</strong>总共有 647427950 (mod 10<sup>9 </sup>+ 7) 种能满足恰好有 11 根木棍可以看到的排列。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1867最大数量高于平均水平的订单",
        "hardRate": "MEDIUM",
        "passRate": "68.04%",
        "problemsUrl": "https://leetcode.cn/problems/orders-with-maximum-quantity-above-average/",
        "solutionsUrl": "https://leetcode.cn/problems/orders-with-maximum-quantity-above-average/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1868两个行程编码数组的积",
        "hardRate": "MEDIUM",
        "passRate": "48.79%",
        "problemsUrl": "https://leetcode.cn/problems/product-of-two-run-length-encoded-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/product-of-two-run-length-encoded-arrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1869哪种连续子字符串更长",
        "hardRate": "EASY",
        "passRate": "70.61%",
        "problemsUrl": "https://leetcode.cn/problems/longer-contiguous-segments-of-ones-than-zeros/",
        "solutionsUrl": "https://leetcode.cn/problems/longer-contiguous-segments-of-ones-than-zeros/solution",
        "problemsDesc": "<p>给你一个二进制字符串 <code>s</code> 。如果字符串中由 <code>1</code> 组成的 <strong>最长</strong> 连续子字符串 <strong>严格长于</strong> 由 <code>0</code> 组成的 <strong>最长</strong> 连续子字符串，返回 <code>true</code> ；否则，返回 <code>false</code><em> </em>。</p>\n\n<ul>\n\t<li>例如，<code>s = \"<strong>11</strong>01<strong>000</strong>10\"</code> 中，由 <code>1</code> 组成的最长连续子字符串的长度是 <code>2</code> ，由 <code>0</code> 组成的最长连续子字符串的长度是 <code>3</code> 。</li>\n</ul>\n\n<p>注意，如果字符串中不存在 <code>0</code> ，此时认为由 <code>0</code> 组成的最长连续子字符串的长度是 <code>0</code> 。字符串中不存在 <code>1</code> 的情况也适用此规则。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1101\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\n由 <code>1</code> 组成的最长连续子字符串的长度是 2：\"<strong>11</strong>01\"\n由 <code>0</code> 组成的最长连续子字符串的长度是 1：\"11<strong>0</strong>1\"\n由 1 组成的子字符串更长，故返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"111000\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\n由 <code>1</code> 组成的最长连续子字符串的长度是 3：\"<strong>111</strong>000\"\n由<code> 0</code> 组成的最长连续子字符串的长度是 3：\"111<strong>000</strong>\"\n由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"110100010\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\n由 <code>1</code> 组成的最长连续子字符串的长度是 2：\"<strong>11</strong>0100010\"\n由 <code>0</code> 组成的最长连续子字符串的长度是 3：\"1101<strong>000</strong>10\"\n由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 100</code></li>\n\t<li><code>s[i]</code> 不是 <code>'0'</code> 就是 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1870准时到达的列车最小时速",
        "hardRate": "MEDIUM",
        "passRate": "42.13%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/solution",
        "problemsDesc": "<p>给你一个浮点数 <code>hour</code> ，表示你到达办公室可用的总通勤时间。要到达办公室，你必须按给定次序乘坐 <code>n</code> 趟列车。另给你一个长度为 <code>n</code> 的整数数组 <code>dist</code> ，其中 <code>dist[i]</code> 表示第 <code>i</code> 趟列车的行驶距离（单位是千米）。</p>\n\n<p>每趟列车均只能在整点发车，所以你可能需要在两趟列车之间等待一段时间。</p>\n\n<ul>\n\t<li>例如，第 <code>1</code> 趟列车需要 <code>1.5</code> 小时，那你必须再等待 <code>0.5</code> 小时，搭乘在第 2 小时发车的第 <code>2</code> 趟列车。</li>\n</ul>\n\n<p>返回能满足你准时到达办公室所要求全部列车的<strong> 最小正整数 </strong>时速（单位：千米每小时），如果无法准时到达，则返回 <code>-1</code> 。</p>\n\n<p>生成的测试用例保证答案不超过 <code>10<sup>7</sup></code> ，且 <code>hour</code> 的 <strong>小数点后最多存在两位数字</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [1,3,2], hour = 6\n<strong>输出：</strong>1\n<strong>解释：</strong>速度为 1 时：\n- 第 1 趟列车运行需要 1/1 = 1 小时。\n- 由于是在整数时间到达，可以立即换乘在第 1 小时发车的列车。第 2 趟列车运行需要 3/1 = 3 小时。\n- 由于是在整数时间到达，可以立即换乘在第 4 小时发车的列车。第 3 趟列车运行需要 2/1 = 2 小时。\n- 你将会恰好在第 6 小时到达。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [1,3,2], hour = 2.7\n<strong>输出：</strong>3\n<strong>解释：</strong>速度为 3 时：\n- 第 1 趟列车运行需要 1/3 = 0.33333 小时。\n- 由于不是在整数时间到达，故需要等待至第 1 小时才能搭乘列车。第 2 趟列车运行需要 3/3 = 1 小时。\n- 由于是在整数时间到达，可以立即换乘在第 2 小时发车的列车。第 3 趟列车运行需要 2/3 = 0.66667 小时。\n- 你将会在第 2.66667 小时到达。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [1,3,2], hour = 1.9\n<strong>输出：</strong>-1\n<strong>解释：</strong>不可能准时到达，因为第 3 趟列车最早是在第 2 小时发车。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == dist.length</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= dist[i] <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= hour <= 10<sup>9</sup></code></li>\n\t<li><code>hours</code> 中，小数点后最多存在两位数字</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1871跳跃游戏 VII",
        "hardRate": "MEDIUM",
        "passRate": "28.31%",
        "problemsUrl": "https://leetcode.cn/problems/jump-game-vii/",
        "solutionsUrl": "https://leetcode.cn/problems/jump-game-vii/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0 </strong>开始的二进制字符串 <code>s</code> 和两个整数 <code>minJump</code> 和 <code>maxJump</code> 。一开始，你在下标 <code>0</code> 处，且该位置的值一定为 <code>'0'</code> 。当同时满足如下条件时，你可以从下标 <code>i</code> 移动到下标 <code>j</code> 处：</p>\n\n<ul>\n\t<li><code>i + minJump <= j <= min(i + maxJump, s.length - 1)</code> 且</li>\n\t<li><code>s[j] == '0'</code>.</li>\n</ul>\n\n<p>如果你可以到达 <code>s</code> 的下标<i> </i><code>s.length - 1</code> 处，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"<strong>0</strong>11<strong>0</strong>1<strong>0</strong>\", minJump = 2, maxJump = 3\n<b>输出：</b>true\n<strong>解释：</strong>\n第一步，从下标 0 移动到下标 3 。\n第二步，从下标 3 移动到下标 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"01101110\", minJump = 2, maxJump = 3\n<b>输出：</b>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= s.length <= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 要么是 <code>'0'</code> ，要么是 <code>'1'</code></li>\n\t<li><code>s[0] == '0'</code></li>\n\t<li><code>1 <= minJump <= maxJump < s.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1872石子游戏 VIII",
        "hardRate": "HARD",
        "passRate": "61.25%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game-viii/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game-viii/solution",
        "problemsDesc": "<p>Alice 和 Bob 玩一个游戏，两人轮流操作， <strong>Alice 先手</strong> 。</p>\n\n<p>总共有 <code>n</code> 个石子排成一行。轮到某个玩家的回合时，如果石子的数目 <strong>大于 1</strong> ，他将执行以下操作：</p>\n\n<ol>\n\t<li>选择一个整数 <code>x &gt; 1</code> ，并且 <strong>移除</strong> 最左边的 <code>x</code> 个石子。</li>\n\t<li>将<strong> 移除</strong> 的石子价值之 <strong>和</strong> 累加到该玩家的分数中。</li>\n\t<li>将一个 <strong>新的石子</strong> 放在最左边，且新石子的值为被移除石子值之和。</li>\n</ol>\n\n<p>当只剩下 <strong>一个</strong> 石子时，游戏结束。</p>\n\n<p>Alice 和 Bob 的 <strong>分数之差</strong> 为 <code>(Alice 的分数 - Bob 的分数)</code> 。 Alice 的目标是<strong> 最大化</strong> 分数差，Bob 的目标是 <strong>最小化</strong> 分数差。</p>\n\n<p>给你一个长度为 <code>n</code> 的整数数组 <code>stones</code> ，其中 <code>stones[i]</code> 是 <strong>从左边起</strong> 第 <code>i</code> 个石子的价值。请你返回在双方都采用 <strong>最优</strong> 策略的情况下，Alice 和 Bob 的 <strong>分数之差</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>stones = [-1,2,-3,4,-5]\n<b>输出：</b>5\n<strong>解释：</strong>\n- Alice 移除最左边的 4 个石子，得分增加 (-1) + 2 + (-3) + 4 = 2 ，并且将一个价值为 2 的石子放在最左边。stones = [2,-5] 。\n- Bob 移除最左边的 2 个石子，得分增加 2 + (-5) = -3 ，并且将一个价值为 -3 的石子放在最左边。stones = [-3] 。\n两者分数之差为 2 - (-3) = 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>stones = [7,-6,5,10,5,-2,-6]\n<b>输出：</b>13\n<b>解释：</b>\n- Alice 移除所有石子，得分增加 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 ，并且将一个价值为 13 的石子放在最左边。stones = [13] 。\n两者分数之差为 13 - 0 = 13 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>stones = [-10,-12]\n<b>输出：</b>-22\n<strong>解释：</strong>\n- Alice 只有一种操作，就是移除所有石子。得分增加 (-10) + (-12) = -22 ，并且将一个价值为 -22 的石子放在最左边。stones = [-22] 。\n两者分数之差为 (-22) - 0 = -22 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == stones.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= stones[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1873计算特殊奖金",
        "hardRate": "EASY",
        "passRate": "62.73%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-special-bonus/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-special-bonus/solution",
        "problemsDesc": "<p>表: <code>Employees</code></p>\n\n<pre>\n+-------------+---------+\n| 列名        | 类型     |\n+-------------+---------+\n| employee_id | int     |\n| name        | varchar |\n| salary      | int     |\n+-------------+---------+\nemployee_id 是这个表的主键。\n此表的每一行给出了雇员id ，名字和薪水。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写出一个SQL 查询语句，计算每个雇员的奖金。如果一个雇员的id是奇数并且他的名字不是以'M'开头，那么他的奖金是他工资的100%，否则奖金为0。</p>\n\n<p>Return the result table ordered by <code>employee_id</code>.</p>\n\n<p>返回的结果集请按照<code>employee_id</code>排序。</p>\n\n<p>查询结果格式如下面的例子所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nEmployees 表:\n+-------------+---------+--------+\n| employee_id | name    | salary |\n+-------------+---------+--------+\n| 2           | Meir    | 3000   |\n| 3           | Michael | 3800   |\n| 7           | Addilyn | 7400   |\n| 8           | Juan    | 6100   |\n| 9           | Kannon  | 7700   |\n+-------------+---------+--------+\n<strong>输出：</strong>\n+-------------+-------+\n| employee_id | bonus |\n+-------------+-------+\n| 2           | 0     |\n| 3           | 0     |\n| 7           | 7400  |\n| 8           | 0     |\n| 9           | 7700  |\n+-------------+-------+\n<strong>解释：</strong>\n因为雇员id是偶数，所以雇员id 是2和8的两个雇员得到的奖金是0。\n雇员id为3的因为他的名字以'M'开头，所以，奖金是0。\n其他的雇员得到了百分之百的奖金。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1874两个数组的最小乘积和",
        "hardRate": "MEDIUM",
        "passRate": "86.57%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-product-sum-of-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-product-sum-of-two-arrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1875将工资相同的雇员分组",
        "hardRate": "MEDIUM",
        "passRate": "64.45%",
        "problemsUrl": "https://leetcode.cn/problems/group-employees-of-the-same-salary/",
        "solutionsUrl": "https://leetcode.cn/problems/group-employees-of-the-same-salary/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1876长度为三且各字符不同的子字符串",
        "hardRate": "EASY",
        "passRate": "70.47%",
        "problemsUrl": "https://leetcode.cn/problems/substrings-of-size-three-with-distinct-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/substrings-of-size-three-with-distinct-characters/solution",
        "problemsDesc": "<p>如果一个字符串不含有任何重复字符，我们称这个字符串为 <strong>好</strong> 字符串。</p>\n\n<p>给你一个字符串 <code>s</code> ，请你返回 <code>s</code> 中长度为 <strong>3</strong> 的 <strong>好子字符串</strong> 的数量。</p>\n\n<p>注意，如果相同的好子字符串出现多次，每一次都应该被记入答案之中。</p>\n\n<p><strong>子字符串</strong> 是一个字符串中连续的字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"xyzzaz\"\n<b>输出：</b>1\n<b>解释：</b>总共有 4 个长度为 3 的子字符串：\"xyz\"，\"yzz\"，\"zza\" 和 \"zaz\" 。\n唯一的长度为 3 的好子字符串是 \"xyz\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aababcabc\"\n<b>输出：</b>4\n<b>解释：</b>总共有 7 个长度为 3 的子字符串：\"aab\"，\"aba\"，\"bab\"，\"abc\"，\"bca\"，\"cab\" 和 \"abc\" 。\n好子字符串包括 \"abc\"，\"bca\"，\"cab\" 和 \"abc\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 100</code></li>\n\t<li><code>s</code>​​​​​​ 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1877数组中最大数对和的最小值",
        "hardRate": "MEDIUM",
        "passRate": "81.15%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-maximum-pair-sum-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-maximum-pair-sum-in-array/solution",
        "problemsDesc": "<p>一个数对 <code>(a,b)</code> 的 <strong>数对和</strong> 等于 <code>a + b</code> 。<strong>最大数对和</strong> 是一个数对数组中最大的 <strong>数对和</strong> 。</p>\n\n<ul>\n\t<li>比方说，如果我们有数对 <code>(1,5)</code> ，<code>(2,3)</code> 和 <code>(4,4)</code>，<strong>最大数对和</strong> 为 <code>max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8</code> 。</li>\n</ul>\n\n<p>给你一个长度为 <strong>偶数</strong> <code>n</code> 的数组 <code>nums</code> ，请你将 <code>nums</code> 中的元素分成 <code>n / 2</code> 个数对，使得：</p>\n\n<ul>\n\t<li><code>nums</code> 中每个元素 <strong>恰好</strong> 在 <strong>一个</strong> 数对中，且</li>\n\t<li><strong>最大数对和</strong> 的值 <strong>最小</strong> 。</li>\n</ul>\n\n<p>请你在最优数对划分的方案下，返回最小的 <strong>最大数对和</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [3,5,2,3]\n<b>输出：</b>7\n<b>解释：</b>数组中的元素可以分为数对 (3,3) 和 (5,2) 。\n最大数对和为 max(3+3, 5+2) = max(6, 7) = 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [3,5,4,2,4,6]\n<b>输出：</b>8\n<b>解释：</b>数组中的元素可以分为数对 (3,5)，(4,4) 和 (6,2) 。\n最大数对和为 max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>n</code> 是 <strong>偶数</strong> 。</li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1878矩阵中最大的三个菱形和",
        "hardRate": "MEDIUM",
        "passRate": "45.50%",
        "problemsUrl": "https://leetcode.cn/problems/get-biggest-three-rhombus-sums-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/get-biggest-three-rhombus-sums-in-a-grid/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的整数矩阵 <code>grid</code> 。</p>\n\n<p><strong>菱形和</strong> 指的是 <code>grid</code> 中一个正菱形 <strong>边界</strong> 上的元素之和。本题中的菱形必须为正方形旋转45度，且四个角都在一个格子当中。下图是四个可行的菱形，每个菱形和应该包含的格子都用了相应颜色标注在图中。</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-desc-2.png\" style=\"width: 385px; height: 385px;\" />\n<p> </p>\n\n<p>注意，菱形可以是一个面积为 0 的区域，如上图中右下角的紫色菱形所示。</p>\n\n<p>请你按照 <strong>降序</strong> 返回 <code>grid</code> 中三个最大的 <strong>互不相同的菱形和</strong> 。如果不同的和少于三个，则将它们全部返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-ex1.png\" style=\"width: 360px; height: 361px;\" />\n<pre>\n<b>输入：</b>grid = [[3,4,5,1,3],[3,3,4,2,3],[20,30,200,40,10],[1,5,5,4,1],[4,3,2,2,5]]\n<b>输出：</b>[228,216,211]\n<b>解释：</b>最大的三个菱形和如上图所示。\n- 蓝色：20 + 3 + 200 + 5 = 228\n- 红色：200 + 2 + 10 + 4 = 216\n- 绿色：5 + 200 + 4 + 2 = 211\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-ex2.png\" style=\"width: 217px; height: 217px;\" />\n<pre>\n<b>输入：</b>grid = [[1,2,3],[4,5,6],[7,8,9]]\n<b>输出：</b>[20,9,8]\n<b>解释：</b>最大的三个菱形和如上图所示。\n- 蓝色：4 + 2 + 6 + 8 = 20\n- 红色：9 （右下角红色的面积为 0 的菱形）\n- 绿色：8 （下方中央面积为 0 的菱形）\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>grid = [[7,7,7]]\n<b>输出：</b>[7]\n<b>解释：</b>所有三个可能的菱形和都相同，所以返回 [7] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 <= m, n <= 100</code></li>\n\t<li><code>1 <= grid[i][j] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1879两个数组最小的异或值之和",
        "hardRate": "HARD",
        "passRate": "49.99%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-xor-sum-of-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-xor-sum-of-two-arrays/solution",
        "problemsDesc": "<p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，它们长度都为 <code>n</code> 。</p>\n\n<p>两个数组的 <strong>异或值之和</strong> 为 <code>(nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1])</code> （<strong>下标从 0 开始</strong>）。</p>\n\n<ul>\n\t<li>比方说，<code>[1,2,3]</code> 和 <code>[3,2,1]</code> 的 <strong>异或值之和</strong> 等于 <code>(1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4</code> 。</li>\n</ul>\n\n<p>请你将 <code>nums2</code> 中的元素重新排列，使得 <strong>异或值之和</strong> <strong>最小</strong> 。</p>\n\n<p>请你返回重新排列之后的 <strong>异或值之和</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,2], nums2 = [2,3]\n<b>输出：</b>2\n<b>解释：</b>将 <code>nums2</code> 重新排列得到 <code>[3,2] 。</code>\n异或值之和为 (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,0,3], nums2 = [5,3,4]\n<b>输出：</b>8\n<b>解释：</b>将 <code>nums2 重新排列得到</code> <code>[5,4,3] 。</code>\n异或值之和为 (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length</code></li>\n\t<li><code>n == nums2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 14</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1880检查某单词是否等于两单词之和",
        "hardRate": "EASY",
        "passRate": "76.29%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-word-equals-summation-of-two-words/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-word-equals-summation-of-two-words/solution",
        "problemsDesc": "<p>字母的 <strong>字母值</strong> 取决于字母在字母表中的位置，<strong>从 0 开始</strong> 计数。即，<code>'a' -&gt; 0</code>、<code>'b' -&gt; 1</code>、<code>'c' -&gt; 2</code>，以此类推。</p>\n\n<p>对某个由小写字母组成的字符串 <code>s</code> 而言，其 <strong>数值</strong> 就等于将 <code>s</code> 中每个字母的 <strong>字母值</strong> 按顺序 <strong>连接</strong> 并 <strong>转换</strong> 成对应整数。</p>\n\n<ul>\n\t<li>例如，<code>s = \"acb\"</code> ，依次连接每个字母的字母值可以得到 <code>\"021\"</code> ，转换为整数得到 <code>21</code> 。</li>\n</ul>\n\n<p>给你三个字符串 <code>firstWord</code>、<code>secondWord</code> 和 <code>targetWord</code> ，每个字符串都由从 <code>'a'</code> 到 <code>'j'</code> （<strong>含 </strong><code>'a'</code> 和 <code>'j'</code><strong> </strong>）的小写英文字母组成。</p>\n\n<p>如果 <code>firstWord</code><em> </em>和<em> </em><code>secondWord</code> 的 <strong>数值之和</strong> 等于<em> </em><code>targetWord</code><em> </em>的数值，返回 <code>true</code> ；否则，返回<em> </em><code>false</code><em> </em>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>firstWord = \"acb\", secondWord = \"cba\", targetWord = \"cdb\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\nfirstWord 的数值为 \"acb\" -&gt; \"021\" -&gt; 21\nsecondWord 的数值为 \"cba\" -&gt; \"210\" -&gt; 210\ntargetWord 的数值为 \"cdb\" -&gt; \"231\" -&gt; 231\n由于 21 + 210 == 231 ，返回 true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aab\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\nfirstWord 的数值为 \"aaa\" -&gt; \"000\" -&gt; 0\nsecondWord 的数值为 \"a\" -&gt; \"0\" -&gt; 0\ntargetWord 的数值为 \"aab\" -&gt; \"001\" -&gt; 1\n由于 0 + 0 != 1 ，返回 false</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aaaa\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\nfirstWord 的数值为 \"aaa\" -&gt; \"000\" -&gt; 0\nsecondWord 的数值为 \"a\" -&gt; \"0\" -&gt; 0\ntargetWord 的数值为 \"aaaa\" -&gt; \"0000\" -&gt; 0\n由于 0 + 0 == 0 ，返回 true\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= firstWord.length, </code><code>secondWord.length, </code><code>targetWord.length &lt;= 8</code></li>\n\t<li><code>firstWord</code>、<code>secondWord</code> 和 <code>targetWord</code> 仅由从 <code>'a'</code> 到 <code>'j'</code> （<strong>含 </strong><code>'a'</code> 和 <code>'j'</code><strong> </strong>）的小写英文字母组成<strong>。</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1881插入后的最大值",
        "hardRate": "MEDIUM",
        "passRate": "37.76%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-value-after-insertion/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-value-after-insertion/solution",
        "problemsDesc": "<p>给你一个非常大的整数 <code>n</code> 和一个整数数字 <code>x</code> ，大整数 <code>n</code> 用一个字符串表示。<code>n</code> 中每一位数字和数字 <code>x</code> 都处于闭区间 <code>[1, 9]</code> 中，且 <code>n</code> 可能表示一个 <strong>负数</strong> 。</p>\n\n<p>你打算通过在 <code>n</code> 的十进制表示的任意位置插入 <code>x</code> 来 <strong>最大化</strong> <code>n</code> 的 <strong>数值</strong> ​​​​​​。但 <strong>不能</strong> 在负号的左边插入 <code>x</code> 。</p>\n\n<ul>\n\t<li>例如，如果 <code>n = 73</code> 且 <code>x = 6</code> ，那么最佳方案是将 <code>6</code> 插入 <code>7</code> 和 <code>3</code> 之间，使 <code>n = 763</code> 。</li>\n\t<li>如果 <code>n = -55</code> 且 <code>x = 2</code> ，那么最佳方案是将 <code>2</code> 插在第一个 <code>5</code> 之前，使 <code>n = -255</code> 。</li>\n</ul>\n\n<p>返回插入操作后，用字符串表示的 <code>n</code> 的最大值。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = \"99\", x = 9\n<strong>输出：</strong>\"999\"\n<strong>解释：</strong>不管在哪里插入 9 ，结果都是相同的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = \"-13\", x = 2\n<strong>输出：</strong>\"-123\"\n<strong>解释：</strong>向 n 中插入 x 可以得到 -213、-123 或者 -132 ，三者中最大的是 -123 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= x <= 9</code></li>\n\t<li><code>n</code>​​​ 中每一位的数字都在闭区间 <code>[1, 9]</code> 中。</li>\n\t<li><code>n</code> 代表一个有效的整数。</li>\n\t<li>当 <code>n</code> 表示负数时，将会以字符 <code>'-'</code> 开始。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1882使用服务器处理任务",
        "hardRate": "MEDIUM",
        "passRate": "30.79%",
        "problemsUrl": "https://leetcode.cn/problems/process-tasks-using-servers/",
        "solutionsUrl": "https://leetcode.cn/problems/process-tasks-using-servers/solution",
        "problemsDesc": "<p>给你两个 <strong>下标从 0 开始</strong> 的整数数组 <code>servers</code> 和 <code>tasks</code> ，长度分别为 <code>n</code>​​​​​​ 和 <code>m</code>​​​​​​ 。<code>servers[i]</code> 是第 <code>i<sup>​​​​​​</sup></code>​​​​ 台服务器的 <strong>权重</strong> ，而 <code>tasks[j]</code> 是处理第 <code>j<sup>​​​​​​</sup></code> 项任务 <strong>所需要的时间</strong>（单位：秒）。</p>\n\n<p>你正在运行一个仿真系统，在处理完所有任务后，该系统将会关闭。每台服务器只能同时处理一项任务。第 <code>0</code> 项任务在第 <code>0</code> 秒可以开始处理，相应地，第 <code>j</code> 项任务在第 <code>j</code> 秒可以开始处理。处理第 <code>j</code> 项任务时，你需要为它分配一台 <strong>权重最小</strong> 的空闲服务器。如果存在多台相同权重的空闲服务器，请选择 <strong>下标最小</strong> 的服务器。如果一台空闲服务器在第 <code>t</code> 秒分配到第 <code>j</code> 项任务，那么在 <code>t + tasks[j]</code> 时它将恢复空闲状态。</p>\n\n<p>如果没有空闲服务器，则必须等待，直到出现一台空闲服务器，并 <strong>尽可能早</strong> 地处理剩余任务。 如果有多项任务等待分配，则按照 <strong>下标递增</strong> 的顺序完成分配。</p>\n\n<p>如果同一时刻存在多台空闲服务器，可以同时将多项任务分别分配给它们。</p>\n\n<p>构建长度为 <code>m</code> 的答案数组 <code>ans</code> ，其中 <code>ans[j]</code> 是第 <code>j</code> 项任务分配的服务器的下标。</p>\n\n<p>返回答案数组<em> </em><code>ans</code>​​​​ 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>servers = [3,3,2], tasks = [1,2,3,2,1,2]\n<strong>输出：</strong>[2,2,0,2,1,2]\n<strong>解释：</strong>事件按时间顺序如下：\n- 0 秒时，第 0 项任务加入到任务队列，使用第 2 台服务器处理到 1 秒。\n- 1 秒时，第 2 台服务器空闲，第 1 项任务加入到任务队列，使用第 2 台服务器处理到 3 秒。\n- 2 秒时，第 2 项任务加入到任务队列，使用第 0 台服务器处理到 5 秒。\n- 3 秒时，第 2 台服务器空闲，第 3 项任务加入到任务队列，使用第 2 台服务器处理到 5 秒。\n- 4 秒时，第 4 项任务加入到任务队列，使用第 1 台服务器处理到 5 秒。\n- 5 秒时，所有服务器都空闲，第 5 项任务加入到任务队列，使用第 2 台服务器处理到 7 秒。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>servers = [5,1,4,3,2], tasks = [2,1,2,4,5,2,1]\n<strong>输出：</strong>[1,4,1,4,1,3,2]\n<strong>解释：</strong>事件按时间顺序如下：\n- 0 秒时，第 0 项任务加入到任务队列，使用第 1 台服务器处理到 2 秒。\n- 1 秒时，第 1 项任务加入到任务队列，使用第 4 台服务器处理到 2 秒。\n- 2 秒时，第 1 台和第 4 台服务器空闲，第 2 项任务加入到任务队列，使用第 1 台服务器处理到 4 秒。\n- 3 秒时，第 3 项任务加入到任务队列，使用第 4 台服务器处理到 7 秒。\n- 4 秒时，第 1 台服务器空闲，第 4 项任务加入到任务队列，使用第 1 台服务器处理到 9 秒。\n- 5 秒时，第 5 项任务加入到任务队列，使用第 3 台服务器处理到 7 秒。\n- 6 秒时，第 6 项任务加入到任务队列，使用第 2 台服务器处理到 7 秒。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>servers.length == n</code></li>\n\t<li><code>tasks.length == m</code></li>\n\t<li><code>1 <= n, m <= 2 * 10<sup>5</sup></code></li>\n\t<li><code>1 <= servers[i], tasks[j] <= 2 * 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1883准时抵达会议现场的最小跳过休息次数",
        "hardRate": "HARD",
        "passRate": "40.22%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-skips-to-arrive-at-meeting-on-time/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-skips-to-arrive-at-meeting-on-time/solution",
        "problemsDesc": "<p>给你一个整数 <code>hoursBefore</code> ，表示你要前往会议所剩下的可用小时数。要想成功抵达会议现场，你必须途经 <code>n</code> 条道路。道路的长度用一个长度为 <code>n</code> 的整数数组 <code>dist</code> 表示，其中 <code>dist[i]</code> 表示第 <code>i</code> 条道路的长度（单位：<strong>千米</strong>）。另给你一个整数 <code>speed</code> ，表示你在道路上前进的速度（单位：<strong>千米每小时</strong>）。</p>\n\n<p>当你通过第 <code>i</code> 条路之后，就必须休息并等待，直到 <strong>下一个整数小时</strong> 才能开始继续通过下一条道路。注意：你不需要在通过最后一条道路后休息，因为那时你已经抵达会议现场。</p>\n\n<ul>\n\t<li>例如，如果你通过一条道路用去 <code>1.4</code> 小时，那你必须停下来等待，到 <code>2</code> 小时才可以继续通过下一条道路。如果通过一条道路恰好用去 <code>2</code> 小时，就无需等待，可以直接继续。</li>\n</ul>\n\n<p>然而，为了能准时到达，你可以选择 <strong>跳过</strong> 一些路的休息时间，这意味着你不必等待下一个整数小时。注意，这意味着与不跳过任何休息时间相比，你可能在不同时刻到达接下来的道路。</p>\n\n<ul>\n\t<li>例如，假设通过第 <code>1</code> 条道路用去 <code>1.4</code> 小时，且通过第 <code>2</code> 条道路用去 <code>0.6</code> 小时。跳过第 <code>1</code> 条道路的休息时间意味着你将会在恰好 <code>2</code> 小时完成通过第 <code>2</code> 条道路，且你能够立即开始通过第 <code>3</code> 条道路。</li>\n</ul>\n\n<p>返回准时抵达会议现场所需要的 <strong>最小跳过次数</strong> ，如果 <strong>无法准时参会</strong> ，返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [1,3,2], speed = 4, hoursBefore = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>\n不跳过任何休息时间，你将用 (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 小时才能抵达会议现场。\n可以跳过第 1 次休息时间，共用 ((1/4 + <strong>0</strong>) + (3/4 + 0)) + (2/4) = 1.5 小时抵达会议现场。\n注意，第 2 次休息时间缩短为 0 ，由于跳过第 1 次休息时间，你是在整数小时处完成通过第 2 条道路。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [7,3,5,5], speed = 2, hoursBefore = 10\n<strong>输出：</strong>2\n<strong>解释：</strong>\n不跳过任何休息时间，你将用 (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 小时才能抵达会议现场。\n可以跳过第 1 次和第 3 次休息时间，共用 ((7/2 + <strong>0</strong>) + (3/2 + 0)) + ((5/2 + <strong>0</strong>) + (5/2)) = 10 小时抵达会议现场。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [7,3,5,5], speed = 1, hoursBefore = 10\n<strong>输出：</strong>-1\n<strong>解释：</strong>即使跳过所有的休息时间，也无法准时参加会议。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == dist.length</code></li>\n\t<li><code>1 <= n <= 1000</code></li>\n\t<li><code>1 <= dist[i] <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= speed <= 10<sup>6</sup></code></li>\n\t<li><code>1 <= hoursBefore <= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1884鸡蛋掉落-两枚鸡蛋",
        "hardRate": "MEDIUM",
        "passRate": "70.44%",
        "problemsUrl": "https://leetcode.cn/problems/egg-drop-with-2-eggs-and-n-floors/",
        "solutionsUrl": "https://leetcode.cn/problems/egg-drop-with-2-eggs-and-n-floors/solution",
        "problemsDesc": "<p>给你 <strong>2&nbsp;枚相同 </strong>的鸡蛋，和一栋从第 <code>1</code>&nbsp;层到第 <code>n</code> 层共有 <code>n</code> 层楼的建筑。</p>\n\n<p>已知存在楼层 <code>f</code> ，满足&nbsp;<code>0 &lt;= f &lt;= n</code> ，任何从 <strong>高于 </strong><code>f</code> 的楼层落下的鸡蛋都<strong> 会碎 </strong>，从 <strong><code>f</code> 楼层或比它低 </strong>的楼层落下的鸡蛋都 <strong>不会碎 </strong>。</p>\n\n<p>每次操作，你可以取一枚<strong> 没有碎</strong> 的鸡蛋并把它从任一楼层 <code>x</code> 扔下（满足&nbsp;<code>1 &lt;= x &lt;= n</code>）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中<strong> 重复使用 </strong>这枚鸡蛋。</p>\n\n<p>请你计算并返回要确定 <code>f</code> <strong>确切的值 </strong>的 <strong>最小操作次数</strong> 是多少？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>我们可以将第一枚鸡蛋从 1 楼扔下，然后将第二枚从 2 楼扔下。\n如果第一枚鸡蛋碎了，可知 f = 0；\n如果第二枚鸡蛋碎了，但第一枚没碎，可知 f = 1；\n否则，当两个鸡蛋都没碎时，可知 f = 2。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 100\n<strong>输出：</strong>14\n<strong>解释：\n</strong>一种最优的策略是：\n- 将第一枚鸡蛋从 9 楼扔下。如果碎了，那么 f 在 0 和 8 之间。将第二枚从 1 楼扔下，然后每扔一次上一层楼，在 8 次内找到 f 。总操作次数 = 1 + 8 = 9 。\n- 如果第一枚鸡蛋没有碎，那么再把第一枚鸡蛋从 22 层扔下。如果碎了，那么 f 在 9 和 21 之间。将第二枚鸡蛋从 10 楼扔下，然后每扔一次上一层楼，在 12 次内找到 f 。总操作次数 = 2 + 12 = 14 。\n- 如果第一枚鸡蛋没有再次碎掉，则按照类似的方法从 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99 和 100 楼分别扔下第一枚鸡蛋。\n不管结果如何，最多需要扔 14 次来确定 f 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1885统计数对",
        "hardRate": "MEDIUM",
        "passRate": "59.03%",
        "problemsUrl": "https://leetcode.cn/problems/count-pairs-in-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/count-pairs-in-two-arrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1886判断矩阵经轮转后是否一致",
        "hardRate": "EASY",
        "passRate": "59.39%",
        "problemsUrl": "https://leetcode.cn/problems/determine-whether-matrix-can-be-obtained-by-rotation/",
        "solutionsUrl": "https://leetcode.cn/problems/determine-whether-matrix-can-be-obtained-by-rotation/solution",
        "problemsDesc": "<p>给你两个大小为 <code>n x n</code> 的二进制矩阵 <code>mat</code> 和 <code>target</code> 。现<strong> 以 90 度顺时针轮转 </strong>矩阵 <code>mat</code> 中的元素 <strong>若干次</strong> ，如果能够使 <code>mat</code> 与 <code>target</code> 一致，返回 <code>true</code> ；否则，返回<em> </em><code>false</code><em> 。</em></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/20/grid3.png\" style=\"width: 301px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>mat = [[0,1],[1,0]], target = [[1,0],[0,1]]\n<strong>输出：</strong>true\n<strong>解释：</strong>顺时针轮转 90 度一次可以使 mat 和 target 一致。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/20/grid4.png\" style=\"width: 301px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>mat = [[0,1],[1,1]], target = [[1,0],[0,1]]\n<strong>输出：</strong>false\n<strong>解释：</strong>无法通过轮转矩阵中的元素使 equal 与 target 一致。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/26/grid4.png\" style=\"width: 661px; height: 184px;\" />\n<pre>\n<strong>输入：</strong>mat = [[0,0,0],[0,1,0],[1,1,1]], target = [[1,1,1],[0,1,0],[0,0,0]]\n<strong>输出：</strong>true\n<strong>解释：</strong>顺时针轮转 90 度两次可以使 mat 和 target 一致。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == mat.length == target.length</code></li>\n\t<li><code>n == mat[i].length == target[i].length</code></li>\n\t<li><code>1 <= n <= 10</code></li>\n\t<li><code>mat[i][j]</code> 和 <code>target[i][j]</code> 不是 <code>0</code> 就是 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1887使数组元素相等的减少操作次数",
        "hardRate": "MEDIUM",
        "passRate": "65.50%",
        "problemsUrl": "https://leetcode.cn/problems/reduction-operations-to-make-the-array-elements-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/reduction-operations-to-make-the-array-elements-equal/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，你的目标是令 <code>nums</code> 中的所有元素相等。完成一次减少操作需要遵照下面的几个步骤：</p>\n\n<ol>\n\t<li>找出 <code>nums</code> 中的 <strong>最大</strong> 值。记这个值为 <code>largest</code> 并取其下标 <code>i</code> （<strong>下标从 0 开始计数</strong>）。如果有多个元素都是最大值，则取最小的 <code>i</code> 。</li>\n\t<li>找出 <code>nums</code> 中的 <strong>下一个最大</strong> 值，这个值 <strong>严格小于</strong> <code>largest</code> ，记为 <code>nextLargest</code> 。</li>\n\t<li>将 <code>nums[i]</code> 减少到 <code>nextLargest</code> 。</li>\n</ol>\n\n<p>返回使<em> </em><code>nums</code><em> </em>中的所有元素相等的操作次数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,1,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>需要 3 次操作使 nums 中的所有元素相等：\n1. largest = 5 下标为 0 。nextLargest = 3 。将 nums[0] 减少到 3 。nums = [<strong>3</strong>,1,3] 。\n2. largest = 3 下标为 0 。nextLargest = 1 。将 nums[0] 减少到 1 。nums = [<strong>1</strong>,1,3] 。\n3. largest = 3 下标为 2 。nextLargest = 1 。将 nums[2] 减少到 1 。nums = [<strong>1</strong>,1,<strong>1</strong>] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1]\n<strong>输出：</strong>0\n<strong>解释：</strong>nums 中的所有元素已经是相等的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,2,2,3]\n<strong>输出：</strong>4\n<strong>解释：</strong>需要 4 次操作使 nums 中的所有元素相等：\n1. largest = 3 下标为 4 。nextLargest = 2 。将 nums[4] 减少到 2 。nums = [1,1,2,2,<strong>2</strong>] 。\n2. largest = 2 下标为 2 。nextLargest = 1 。将 nums[2] 减少到 1 。nums = [1,1,<strong>1</strong>,2,2] 。 \n3. largest = 2 下标为 3 。nextLargest = 1 。将 nums[3] 减少到 1 。nums = [1,1,1,<strong>1</strong>,2] 。 \n4. largest = 2 下标为 4 。nextLargest = 1 。将 nums[4] 减少到 1 。nums = [1,1,1,1,<strong>1</strong>] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= nums[i] <= 5 * 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1888使二进制字符串字符交替的最少反转次数",
        "hardRate": "MEDIUM",
        "passRate": "36.52%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/solution",
        "problemsDesc": "<p>给你一个二进制字符串 <code>s</code> 。你可以按任意顺序执行以下两种操作任意次：</p>\n\n<ul>\n\t<li><strong>类型 1 ：删除</strong> 字符串 <code>s</code> 的第一个字符并将它 <strong>添加</strong> 到字符串结尾。</li>\n\t<li><strong>类型 2 ：选择 </strong>字符串 <code>s</code> 中任意一个字符并将该字符 <strong>反转 </strong>，也就是如果值为 <code>'0'</code> ，则反转得到 <code>'1'</code> ，反之亦然。</li>\n</ul>\n\n<p>请你返回使 <code>s</code> 变成 <strong>交替</strong> 字符串的前提下， <strong>类型 2 </strong>的 <strong>最少</strong> 操作次数 。</p>\n\n<p>我们称一个字符串是 <strong>交替</strong> 的，需要满足任意相邻字符都不同。</p>\n\n<ul>\n\t<li>比方说，字符串 <code>\"010\"</code> 和 <code>\"1010\"</code> 都是交替的，但是字符串 <code>\"0100\"</code> 不是。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"111000\"\n<b>输出：</b>2\n<b>解释：</b>执行第一种操作两次，得到 s = \"100011\" 。\n然后对第三个和第六个字符执行第二种操作，得到 s = \"10<strong>1</strong>01<strong>0</strong>\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"010\"\n<b>输出：</b>0\n<strong>解释：</strong>字符串已经是交替的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>s = \"1110\"\n<b>输出：</b>1\n<b>解释：</b>对第二个字符执行第二种操作，得到 s = \"1<strong>0</strong>10\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 要么是 <code>'0'</code> ，要么是 <code>'1'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1889装包裹的最小浪费空间",
        "hardRate": "HARD",
        "passRate": "29.56%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-space-wasted-from-packaging/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-space-wasted-from-packaging/solution",
        "problemsDesc": "<p>给你 <code>n</code> 个包裹，你需要把它们装在箱子里，<strong>每个箱子装一个包裹</strong>。总共有 <code>m</code> 个供应商提供 <strong>不同尺寸</strong> 的箱子（每个规格都有无数个箱子）。如果一个包裹的尺寸 <strong>小于等于</strong> 一个箱子的尺寸，那么这个包裹就可以放入这个箱子之中。</p>\n\n<p>包裹的尺寸用一个整数数组 <code>packages</code> 表示，其中 <code>packages[i]</code> 是第 <code>i</code> 个包裹的尺寸。供应商用二维数组 <code>boxes</code> 表示，其中 <code>boxes[j]</code> 是第 <code>j</code> 个供应商提供的所有箱子尺寸的数组。</p>\n\n<p>你想要选择 <strong>一个供应商</strong> 并只使用该供应商提供的箱子，使得 <strong>总浪费空间最小</strong> 。对于每个装了包裹的箱子，我们定义 <strong>浪费的</strong> 空间等于 <code>箱子的尺寸 - 包裹的尺寸</code> 。<strong>总浪费空间</strong> 为 <strong>所有</strong> 箱子中浪费空间的总和。</p>\n\n<ul>\n\t<li>比方说，如果你想要用尺寸数组为 <code>[4,8]</code> 的箱子装下尺寸为 <code>[2,3,5]</code> 的包裹，你可以将尺寸为 <code>2</code> 和 <code>3</code> 的两个包裹装入两个尺寸为 <code>4</code> 的箱子中，同时把尺寸为 <code>5</code> 的包裹装入尺寸为 <code>8</code> 的箱子中。总浪费空间为 <code>(4-2) + (4-3) + (8-5) = 6</code> 。</li>\n</ul>\n\n<p>请你选择 <strong>最优</strong> 箱子供应商，使得 <strong>总浪费空间最小</strong> 。如果 <strong>无法</strong> 将所有包裹放入箱子中，请你返回 <code>-1</code> 。由于答案可能会 <strong>很大</strong> ，请返回它对<strong> </strong><code>10<sup>9</sup> + 7</code> <b>取余</b> 的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>packages = [2,3,5], boxes = [[4,8],[2,8]]\n<b>输出：</b>6\n<b>解释：</b>选择第一个供应商最优，用两个尺寸为 4 的箱子和一个尺寸为 8 的箱子。\n总浪费空间为 (4-2) + (4-3) + (8-5) = 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>packages = [2,3,5], boxes = [[1,4],[2,3],[3,4]]\n<b>输出：</b>-1\n<b>解释：</b>没有箱子能装下尺寸为 5 的包裹。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>packages = [3,5,8,10,11,12], boxes = [[12],[11,9],[10,5,14]]\n<b>输出：</b>9\n<b>解释：</b>选择第三个供应商最优，用两个尺寸为 5 的箱子，两个尺寸为 10 的箱子和两个尺寸为 14 的箱子。\n总浪费空间为 (5-3) + (5-5) + (10-8) + (10-10) + (14-11) + (14-12) = 9 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == packages.length</code></li>\n\t<li><code>m == boxes.length</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= m <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= packages[i] <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= boxes[j].length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= boxes[j][k] <= 10<sup>5</sup></code></li>\n\t<li><code>sum(boxes[j].length) <= 10<sup>5</sup></code></li>\n\t<li><code>boxes[j]</code> 中的元素 <strong>互不相同</strong> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 18902020年最后一次登录",
        "hardRate": "EASY",
        "passRate": "70.01%",
        "problemsUrl": "https://leetcode.cn/problems/the-latest-login-in-2020/",
        "solutionsUrl": "https://leetcode.cn/problems/the-latest-login-in-2020/solution",
        "problemsDesc": "<p>表: <code>Logins</code></p>\n\n<pre>\n+----------------+----------+\n| 列名           | 类型      |\n+----------------+----------+\n| user_id        | int      |\n| time_stamp     | datetime |\n+----------------+----------+\n(user_id, time_stamp) 是这个表的主键。\n每一行包含的信息是user_id 这个用户的登录时间。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个 SQL 查询，该查询可以获取在 <code>2020</code> 年登录过的所有用户的本年度 <strong>最后一次 </strong>登录时间。结果集 <strong>不</strong> 包含 <code>2020</code> 年没有登录过的用户。</p>\n\n<p>返回的结果集可以按 <strong>任意顺序 </strong>排列。</p>\n\n<p>查询结果格式如下例。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nLogins 表:\n+---------+---------------------+\n| user_id | time_stamp          |\n+---------+---------------------+\n| 6       | 2020-06-30 15:06:07 |\n| 6       | 2021-04-21 14:06:06 |\n| 6       | 2019-03-07 00:18:15 |\n| 8       | 2020-02-01 05:10:53 |\n| 8       | 2020-12-30 00:46:50 |\n| 2       | 2020-01-16 02:49:50 |\n| 2       | 2019-08-25 07:59:08 |\n| 14      | 2019-07-14 09:00:00 |\n| 14      | 2021-01-06 11:59:59 |\n+---------+---------------------+\n<strong>输出：</strong>\n+---------+---------------------+\n| user_id | last_stamp          |\n+---------+---------------------+\n| 6       | 2020-06-30 15:06:07 |\n| 8       | 2020-12-30 00:46:50 |\n| 2       | 2020-01-16 02:49:50 |\n+---------+---------------------+\n<strong>解释：</strong>\n6号用户登录了3次，但是在2020年仅有一次，所以结果集应包含此次登录。\n8号用户在2020年登录了2次，一次在2月，一次在12月，所以，结果集应该包含12月的这次登录。\n2号用户登录了2次，但是在2020年仅有一次，所以结果集应包含此次登录。\n14号用户在2020年没有登录，所以结果集不应包含。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1891割绳子",
        "hardRate": "MEDIUM",
        "passRate": "42.15%",
        "problemsUrl": "https://leetcode.cn/problems/cutting-ribbons/",
        "solutionsUrl": "https://leetcode.cn/problems/cutting-ribbons/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1892页面推荐Ⅱ",
        "hardRate": "HARD",
        "passRate": "37.61%",
        "problemsUrl": "https://leetcode.cn/problems/page-recommendations-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/page-recommendations-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1893检查是否区域内所有整数都被覆盖",
        "hardRate": "EASY",
        "passRate": "58.87%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-all-the-integers-in-a-range-are-covered/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-all-the-integers-in-a-range-are-covered/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>ranges</code> 和两个整数 <code>left</code> 和 <code>right</code> 。每个 <code>ranges[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 表示一个从 <code>start<sub>i</sub></code> 到 <code>end<sub>i</sub></code> 的 <strong>闭区间</strong> 。</p>\n\n<p>如果闭区间 <code>[left, right]</code> 内每个整数都被 <code>ranges</code> 中 <strong>至少一个</strong> 区间覆盖，那么请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p>已知区间 <code>ranges[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> ，如果整数 <code>x</code> 满足 <code>start<sub>i</sub> <= x <= end<sub>i</sub></code> ，那么我们称整数<code>x</code> 被覆盖了。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5\n<b>输出：</b>true\n<b>解释：</b>2 到 5 的每个整数都被覆盖了：\n- 2 被第一个区间覆盖。\n- 3 和 4 被第二个区间覆盖。\n- 5 被第三个区间覆盖。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>ranges = [[1,10],[10,20]], left = 21, right = 21\n<b>输出：</b>false\n<b>解释：</b>21 没有被任何一个区间覆盖。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= ranges.length <= 50</code></li>\n\t<li><code>1 <= start<sub>i</sub> <= end<sub>i</sub> <= 50</code></li>\n\t<li><code>1 <= left <= right <= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1894找到需要补充粉笔的学生编号",
        "hardRate": "MEDIUM",
        "passRate": "45.84%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-student-that-will-replace-the-chalk/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-student-that-will-replace-the-chalk/solution",
        "problemsDesc": "<p>一个班级里有&nbsp;<code>n</code>&nbsp;个学生，编号为 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;。每个学生会依次回答问题，编号为 <code>0</code>&nbsp;的学生先回答，然后是编号为 <code>1</code>&nbsp;的学生，以此类推，直到编号为 <code>n - 1</code>&nbsp;的学生，然后老师会重复这个过程，重新从编号为 <code>0</code>&nbsp;的学生开始回答问题。</p>\n\n<p>给你一个长度为 <code>n</code>&nbsp;且下标从 <code>0</code>&nbsp;开始的整数数组&nbsp;<code>chalk</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。一开始粉笔盒里总共有&nbsp;<code>k</code>&nbsp;支粉笔。当编号为&nbsp;<code>i</code>&nbsp;的学生回答问题时，他会消耗 <code>chalk[i]</code>&nbsp;支粉笔。如果剩余粉笔数量 <strong>严格小于</strong>&nbsp;<code>chalk[i]</code>&nbsp;，那么学生 <code>i</code>&nbsp;需要 <strong>补充</strong>&nbsp;粉笔。</p>\n\n<p>请你返回需要 <strong>补充</strong>&nbsp;粉笔的学生 <strong>编号</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>chalk = [5,1,5], k = 22\n<b>输出：</b>0\n<strong>解释：</strong>学生消耗粉笔情况如下：\n- 编号为 0 的学生使用 5 支粉笔，然后 k = 17 。\n- 编号为 1 的学生使用 1 支粉笔，然后 k = 16 。\n- 编号为 2 的学生使用 5 支粉笔，然后 k = 11 。\n- 编号为 0 的学生使用 5 支粉笔，然后 k = 6 。\n- 编号为 1 的学生使用 1 支粉笔，然后 k = 5 。\n- 编号为 2 的学生使用 5 支粉笔，然后 k = 0 。\n编号为 0 的学生没有足够的粉笔，所以他需要补充粉笔。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>chalk = [3,4,1,2], k = 25\n<b>输出：</b>1\n<b>解释：</b>学生消耗粉笔情况如下：\n- 编号为 0 的学生使用 3 支粉笔，然后 k = 22 。\n- 编号为 1 的学生使用 4 支粉笔，然后 k = 18 。\n- 编号为 2 的学生使用 1 支粉笔，然后 k = 17 。\n- 编号为 3 的学生使用 2 支粉笔，然后 k = 15 。\n- 编号为 0 的学生使用 3 支粉笔，然后 k = 12 。\n- 编号为 1 的学生使用 4 支粉笔，然后 k = 8 。\n- 编号为 2 的学生使用 1 支粉笔，然后 k = 7 。\n- 编号为 3 的学生使用 2 支粉笔，然后 k = 5 。\n- 编号为 0 的学生使用 3 支粉笔，然后 k = 2 。\n编号为 1 的学生没有足够的粉笔，所以他需要补充粉笔。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>chalk.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= chalk[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1895最大的幻方",
        "hardRate": "MEDIUM",
        "passRate": "56.28%",
        "problemsUrl": "https://leetcode.cn/problems/largest-magic-square/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-magic-square/solution",
        "problemsDesc": "<p>一个 <code>k x k</code> 的<strong> 幻方</strong> 指的是一个 <code>k x k</code> 填满整数的方格阵，且每一行、每一列以及两条对角线的和 <strong>全部</strong><strong>相等</strong> 。幻方中的整数 <strong>不需要互不相同</strong> 。显然，每个 <code>1 x 1</code> 的方格都是一个幻方。</p>\n\n<p>给你一个 <code>m x n</code> 的整数矩阵 <code>grid</code> ，请你返回矩阵中 <strong>最大幻方</strong> 的 <strong>尺寸</strong> （即边长 <code>k</code>）。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/29/magicsquare-grid.jpg\" style=\"width: 413px; height: 335px;\">\n<pre><b>输入：</b>grid = [[7,1,4,5,6],[2,5,1,6,4],[1,5,4,3,2],[1,2,7,3,4]]\n<b>输出：</b>3\n<b>解释：</b>最大幻方尺寸为 3 。\n每一行，每一列以及两条对角线的和都等于 12 。\n- 每一行的和：5+1+6 = 5+4+3 = 2+7+3 = 12\n- 每一列的和：5+5+2 = 1+4+7 = 6+3+3 = 12\n- 对角线的和：5+4+3 = 6+4+2 = 12\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/29/magicsquare2-grid.jpg\" style=\"width: 333px; height: 255px;\">\n<pre><b>输入：</b>grid = [[5,1,3,1],[9,3,3,1],[1,3,3,8]]\n<b>输出：</b>2\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1896反转表达式值的最少操作次数",
        "hardRate": "HARD",
        "passRate": "51.50%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-change-the-final-value-of-expression/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-change-the-final-value-of-expression/solution",
        "problemsDesc": "<p>给你一个 <strong>有效的</strong> 布尔表达式，用字符串 <code>expression</code> 表示。这个字符串包含字符 <code>'1'</code>，<code>'0'</code>，<code>'&amp;'</code>（按位 <strong>与</strong> 运算），<code>'|'</code>（按位 <strong>或</strong> 运算），<code>'('</code> 和 <code>')'</code> 。</p>\n\n<ul>\n\t<li>比方说，<code>\"()1|1\"</code> 和 <code>\"(1)&amp;()\"</code> <strong>不是有效</strong> 布尔表达式。而 <code>\"1\"</code>， <code>\"(((1))|(0))\"</code> 和 <code>\"1|(0&amp;(1))\"</code> 是 <strong>有效</strong> 布尔表达式。</li>\n</ul>\n\n<p>你的目标是将布尔表达式的 <strong>值</strong> <strong>反转 </strong>（也就是将 <code>0</code> 变为 <code>1</code> ，或者将 <code>1</code> 变为 <code>0</code>），请你返回达成目标需要的 <strong>最少操作</strong> 次数。</p>\n\n<ul>\n\t<li>比方说，如果表达式 <code>expression = \"1|1|(0&amp;0)&amp;1\"</code> ，它的 <strong>值</strong> 为 <code>1|1|(0&amp;0)&amp;1 = 1|1|0&amp;1 = 1|0&amp;1 = 1&amp;1 = 1</code> 。我们想要执行操作将 <strong>新的</strong> 表达式的值变成 <code>0</code> 。</li>\n</ul>\n\n<p>可执行的 <strong>操作</strong> 如下：</p>\n\n<ul>\n\t<li>将一个 <code>'1'</code> 变成一个 <code>'0'</code> 。</li>\n\t<li>将一个 <code>'0'</code> 变成一个 <code>'1'</code> 。</li>\n\t<li>将一个 <code>'&amp;'</code> 变成一个 <code>'|'</code> 。</li>\n\t<li>将一个 <code>'|'</code> 变成一个 <code>'&amp;'</code> 。</li>\n</ul>\n\n<p><strong>注意：</strong><code>'&amp;'</code> 的 <strong>运算优先级</strong> 与 <code>'|'</code> <strong>相同</strong> 。计算表达式时，括号优先级 <strong>最高</strong> ，然后按照 <strong>从左到右</strong> 的顺序运算。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>expression = \"1&amp;(0|1)\"\n<b>输出：</b>1\n<b>解释：</b>我们可以将 \"1&amp;(0<strong>|</strong>1)\" 变成 \"1&amp;(0<strong>&amp;</strong>1)\" ，执行的操作为将一个 '|' 变成一个 '&amp;' ，执行了 1 次操作。\n新表达式的值为 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>expression = \"(0&amp;0)&amp;(0&amp;0&amp;0)\"\n<b>输出：</b>3\n<b>解释：</b>我们可以将 \"(0<strong>&amp;0</strong>)<strong>&amp;</strong>(0&amp;0&amp;0)\" 变成 \"(0<strong>|1</strong>)<strong>|</strong>(0&amp;0&amp;0)\" ，执行了 3 次操作。\n新表达式的值为 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>expression = \"(0|(1|0&amp;1))\"\n<b>输出：</b>1\n<b>解释：</b>我们可以将 \"(0|(<strong>1</strong>|0&amp;1))\" 变成 \"(0|(<strong>0</strong>|0&amp;1))\" ，执行了 1 次操作。\n新表达式的值为 0 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= expression.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>expression</code> 只包含 <code>'1'</code>，<code>'0'</code>，<code>'&amp;'</code>，<code>'|'</code>，<code>'('</code> 和 <code>')'</code></li>\n\t<li>所有括号都有与之匹配的对应括号。</li>\n\t<li>不会有空的括号（也就是说 <code>\"()\"</code> 不是 <code>expression</code> 的子字符串）。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1897重新分配字符使所有字符串都相等",
        "hardRate": "EASY",
        "passRate": "55.24%",
        "problemsUrl": "https://leetcode.cn/problems/redistribute-characters-to-make-all-strings-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/redistribute-characters-to-make-all-strings-equal/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>words</code>（下标 <strong>从 0 开始</strong> 计数）。</p>\n\n<p>在一步操作中，需先选出两个 <strong>不同</strong> 下标 <code>i</code> 和 <code>j</code>，其中 <code>words[i]</code> 是一个非空字符串，接着将 <code>words[i]</code> 中的 <strong>任一</strong> 字符移动到 <code>words[j]</code> 中的 <strong>任一</strong> 位置上。</p>\n\n<p>如果执行任意步操作可以使 <code>words</code> 中的每个字符串都相等，返回 <code>true</code><em> </em>；否则，返回<em> </em><code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"abc\",\"aabc\",\"bc\"]\n<strong>输出：</strong>true\n<strong>解释：</strong>将 <code>words[1] 中的第一个</code> 'a' 移动到<code> words[2] 的最前面。\n使 </code><code>words[1]</code> = \"abc\" 且 words[2] = \"abc\" 。\n所有字符串都等于 \"abc\" ，所以返回 <code>true</code> 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"ab\",\"a\"]\n<strong>输出：</strong>false\n<strong>解释：</strong>执行操作无法使所有字符串都相等。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><code>words[i]</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1898可移除字符的最大数目",
        "hardRate": "MEDIUM",
        "passRate": "38.05%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-removable-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-removable-characters/solution",
        "problemsDesc": "<p>给你两个字符串 <code>s</code> 和 <code>p</code> ，其中 <code>p</code> 是 <code>s</code> 的一个 <strong>子序列</strong> 。同时，给你一个元素 <strong>互不相同</strong> 且下标 <strong>从 0 开始</strong> 计数的整数数组 <code>removable</code> ，该数组是 <code>s</code> 中下标的一个子集（<code>s</code> 的下标也 <strong>从 0 开始</strong> 计数）。</p>\n\n<p>请你找出一个整数 <code>k</code>（<code>0 <= k <= removable.length</code>），选出 <code>removable</code> 中的 <strong>前</strong> <code>k</code> 个下标，然后从 <code>s</code> 中移除这些下标对应的 <code>k</code> 个字符。整数 <code>k</code> 需满足：在执行完上述步骤后， <code>p</code> 仍然是 <code>s</code> 的一个 <strong>子序列</strong> 。更正式的解释是，对于每个 <code>0 <= i < k</code> ，先标记出位于 <code>s[removable[i]]</code> 的字符，接着移除所有标记过的字符，然后检查 <code>p</code> 是否仍然是 <code>s</code> 的一个子序列。</p>\n\n<p>返回你可以找出的 <strong>最大</strong><em> </em><code>k</code><em> </em>，满足在移除字符后<em> </em><code>p</code><em> </em>仍然是 <code>s</code> 的一个子序列。</p>\n\n<p>字符串的一个 <strong>子序列</strong> 是一个由原字符串生成的新字符串，生成过程中可能会移除原字符串中的一些字符（也可能不移除）但不改变剩余字符之间的相对顺序。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcacb\", p = \"ab\", removable = [3,1,0]\n<strong>输出：</strong>2\n<strong>解释：</strong>在移除下标 3 和 1 对应的字符后，\"a<strong>b</strong>c<strong>a</strong>cb\" 变成 \"accb\" 。\n\"ab\" 是 \"<strong>a</strong>cc<strong>b</strong>\" 的一个子序列。\n如果移除下标 3、1 和 0 对应的字符后，\"<strong>ab</strong>c<strong>a</strong>cb\" 变成 \"ccb\" ，那么 \"ab\" 就不再是 s 的一个子序列。\n因此，最大的 k 是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcbddddd\", p = \"abcd\", removable = [3,2,1,4,5,6]\n<strong>输出：</strong>1\n<strong>解释：</strong>在移除下标 3 对应的字符后，\"abc<strong>b</strong>ddddd\" 变成 \"abcddddd\" 。\n\"abcd\" 是 \"<strong>abcd</strong>dddd\" 的一个子序列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcab\", p = \"abc\", removable = [0,1,2,3,4]\n<strong>输出：</strong>0\n<strong>解释：</strong>如果移除数组 removable 的第一个下标，\"abc\" 就不再是 s 的一个子序列。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= p.length <= s.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= removable.length < s.length</code></li>\n\t<li><code>0 <= removable[i] < s.length</code></li>\n\t<li><code>p</code> 是 <code>s</code> 的一个 <strong>子字符串</strong></li>\n\t<li><code>s</code> 和 <code>p</code> 都由小写英文字母组成</li>\n\t<li><code>removable</code> 中的元素 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1899合并若干三元组以形成目标三元组",
        "hardRate": "MEDIUM",
        "passRate": "65.32%",
        "problemsUrl": "https://leetcode.cn/problems/merge-triplets-to-form-target-triplet/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-triplets-to-form-target-triplet/solution",
        "problemsDesc": "<p><strong>三元组</strong> 是一个由三个整数组成的数组。给你一个二维整数数组 <code>triplets</code> ，其中 <code>triplets[i] = [a<sub>i</sub>, b<sub>i</sub>, c<sub>i</sub>]</code> 表示第 <code>i</code> 个 <strong>三元组</strong> 。同时，给你一个整数数组 <code>target = [x, y, z]</code> ，表示你想要得到的 <strong>三元组</strong> 。</p>\n\n<p>为了得到 <code>target</code> ，你需要对 <code>triplets</code> 执行下面的操作 <strong>任意次</strong>（可能 <strong>零</strong> 次）：</p>\n\n<ul>\n\t<li>选出两个下标（下标 <strong>从 0 开始</strong> 计数）<code>i</code> 和 <code>j</code>（<code>i != j</code>），并 <strong>更新</strong> <code>triplets[j]</code> 为 <code>[max(a<sub>i</sub>, a<sub>j</sub>), max(b<sub>i</sub>, b<sub>j</sub>), max(c<sub>i</sub>, c<sub>j</sub>)]</code> 。\n\n\t<ul>\n\t\t<li>例如，<code>triplets[i] = [2, 5, 3]</code> 且 <code>triplets[j] = [1, 7, 5]</code>，<code>triplets[j]</code> 将会更新为 <code>[max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5]</code> 。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>如果通过以上操作我们可以使得目标 <strong>三元组</strong> <code>target</code> 成为 <code>triplets</code> 的一个 <strong>元素</strong> ，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>执行下述操作：\n- 选择第一个和最后一个三元组 [<strong>[2,5,3]</strong>,[1,8,4],<strong>[1,7,5]</strong>] 。更新最后一个三元组为 [max(2,1), max(5,7), max(3,5)] = [2,7,5] 。triplets = [[2,5,3],[1,8,4],<strong>[2,7,5]</strong>]\n目标三元组 [2,7,5] 现在是 triplets 的一个元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>triplets = [[1,3,4],[2,5,8]], target = [2,5,8]\n<strong>输出：</strong>true\n<strong>解释：</strong>目标三元组 [2,5,8] 已经是 triplets 的一个元素。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], target = [5,5,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>执行下述操作：\n- 选择第一个和第三个三元组 [<strong>[2,5,3]</strong>,[2,3,4],<strong>[1,2,5]</strong>,[5,2,3]] 。更新第三个三元组为 [max(2,1), max(5,2), max(3,5)] = [2,5,5] 。triplets = [[2,5,3],[2,3,4],<strong>[2,5,5]</strong>,[5,2,3]] 。\n- 选择第三个和第四个三元组 [[2,5,3],[2,3,4],<strong>[2,5,5]</strong>,<strong>[5,2,3]</strong>] 。更新第四个三元组为 [max(2,5), max(5,2), max(5,3)] = [5,5,5] 。triplets = [[2,5,3],[2,3,4],[2,5,5],<strong>[5,5,5]</strong>] 。\n目标三元组 [5,5,5] 现在是 triplets 的一个元素。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>triplets = [[3,4,5],[4,5,6]], target = [3,2,5]\n<strong>输出：</strong>false\n<strong>解释：</strong>无法得到 [3,2,5] ，因为 triplets 不含 2 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= triplets.length <= 10<sup>5</sup></code></li>\n\t<li><code>triplets[i].length == target.length == 3</code></li>\n\t<li><code>1 <= a<sub>i</sub>, b<sub>i</sub>, c<sub>i</sub>, x, y, z <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1900最佳运动员的比拼回合",
        "hardRate": "HARD",
        "passRate": "45.87%",
        "problemsUrl": "https://leetcode.cn/problems/the-earliest-and-latest-rounds-where-players-compete/",
        "solutionsUrl": "https://leetcode.cn/problems/the-earliest-and-latest-rounds-where-players-compete/solution",
        "problemsDesc": "<p><code>n</code> 名运动员参与一场锦标赛，所有运动员站成一排，并根据 <strong>最开始的</strong> 站位从 <code>1</code> 到 <code>n</code> 编号（运动员 <code>1</code> 是这一排中的第一个运动员，运动员 <code>2</code> 是第二个运动员，依此类推）。</p>\n\n<p>锦标赛由多个回合组成（从回合 <code>1</code> 开始）。每一回合中，这一排从前往后数的第 <code>i</code> 名运动员需要与从后往前数的第 <code>i</code> 名运动员比拼，获胜者将会进入下一回合。如果当前回合中运动员数目为奇数，那么中间那位运动员将轮空晋级下一回合。</p>\n\n<ul>\n\t<li>例如，当前回合中，运动员 <code>1, 2, 4, 6, 7</code> 站成一排\n\n\t<ul>\n\t\t<li>运动员 <code>1</code> 需要和运动员 <code>7</code> 比拼</li>\n\t\t<li>运动员 <code>2</code> 需要和运动员 <code>6</code> 比拼</li>\n\t\t<li>运动员 <code>4</code> 轮空晋级下一回合</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>每回合结束后，获胜者将会基于最开始分配给他们的原始顺序（升序）重新排成一排。</p>\n\n<p>编号为 <code>firstPlayer</code> 和 <code>secondPlayer</code> 的运动员是本场锦标赛中的最佳运动员。在他们开始比拼之前，完全可以战胜任何其他运动员。而任意两个其他运动员进行比拼时，其中任意一个都有获胜的可能，因此你可以 <strong>裁定</strong> 谁是这一回合的获胜者。</p>\n\n<p>给你三个整数 <code>n</code>、<code>firstPlayer</code> 和 <code>secondPlayer</code> 。返回一个由两个值组成的整数数组，分别表示两位最佳运动员在本场锦标赛中比拼的 <strong>最早</strong> 回合数和 <strong>最晚</strong> 回合数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 11, firstPlayer = 2, secondPlayer = 4\n<strong>输出：</strong>[3,4]\n<strong>解释：</strong>\n一种能够产生最早回合数的情景是：\n回合 1：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n回合 2：2, 3, 4, 5, 6, 11\n回合 3：2, 3, 4\n一种能够产生最晚回合数的情景是：\n回合 1：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n回合 2：1, 2, 3, 4, 5, 6\n回合 3：1, 2, 4\n回合 4：2, 4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 5, firstPlayer = 1, secondPlayer = 5\n<strong>输出：</strong>[1,1]\n<strong>解释：</strong>两名最佳运动员 1 和 5 将会在回合 1 进行比拼。\n不存在使他们在其他回合进行比拼的可能。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 28</code></li>\n\t<li><code>1 &lt;= firstPlayer &lt; secondPlayer &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1901寻找峰值 II",
        "hardRate": "MEDIUM",
        "passRate": "58.93%",
        "problemsUrl": "https://leetcode.cn/problems/find-a-peak-element-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/find-a-peak-element-ii/solution",
        "problemsDesc": "<p>一个 2D 网格中的 <strong>峰值</strong><strong> </strong>是指那些 <strong>严格大于 </strong>其相邻格子(上、下、左、右)的元素。</p>\n\n<p>给你一个<strong> 从 0 开始编号 </strong>的 <code>m x n</code> 矩阵 <code>mat</code> ，其中任意两个相邻格子的值都<strong> 不相同</strong> 。找出 <strong>任意一个 峰值</strong> <code>mat[i][j]</code> 并 <strong>返回其位置 </strong><code>[i,j]</code> 。</p>\n\n<p>你可以假设整个矩阵周边环绕着一圈值为 <code>-1</code> 的格子。</p>\n\n<p>要求必须写出时间复杂度为 <code>O(m log(n))</code> 或 <code>O(n log(m))</code> 的算法</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/08/1.png\" style=\"width: 206px; height: 209px;\" /></p>\n\n<pre>\n<strong>输入:</strong> mat = [[1,4],[3,2]]\n<strong>输出:</strong> [0,1]\n<strong>解释:</strong>&nbsp;3 和 4 都是峰值，所以[1,0]和[0,1]都是可接受的答案。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/07/3.png\" style=\"width: 254px; height: 257px;\" /></strong></p>\n\n<pre>\n<strong>输入:</strong> mat = [[10,20,15],[21,30,14],[7,16,32]]\n<strong>输出:</strong> [1,1]\n<strong>解释:</strong>&nbsp;30 和 32 都是峰值，所以[1,1]和[2,2]都是可接受的答案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>1 &lt;= mat[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li>任意两个相邻元素均不相等.</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1902给定二叉搜索树的插入顺序求深度",
        "hardRate": "MEDIUM",
        "passRate": "50.93%",
        "problemsUrl": "https://leetcode.cn/problems/depth-of-bst-given-insertion-order/",
        "solutionsUrl": "https://leetcode.cn/problems/depth-of-bst-given-insertion-order/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1903字符串中的最大奇数",
        "hardRate": "EASY",
        "passRate": "60.47%",
        "problemsUrl": "https://leetcode.cn/problems/largest-odd-number-in-string/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-odd-number-in-string/solution",
        "problemsDesc": "<p>给你一个字符串 <code>num</code> ，表示一个大整数。请你在字符串 <code>num</code> 的所有 <strong>非空子字符串</strong> 中找出 <strong>值最大的奇数</strong> ，并以字符串形式返回。如果不存在奇数，则返回一个空字符串<em> </em><code>\"\"</code><em> </em>。</p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续的字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"52\"\n<strong>输出：</strong>\"5\"\n<strong>解释：</strong>非空子字符串仅有 \"5\"、\"2\" 和 \"52\" 。\"5\" 是其中唯一的奇数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"4206\"\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>在 \"4206\" 中不存在奇数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"35427\"\n<strong>输出：</strong>\"35427\"\n<strong>解释：</strong>\"35427\" 本身就是一个奇数。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= num.length <= 10<sup>5</sup></code></li>\n\t<li><code>num</code> 仅由数字组成且不含前导零</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1904你完成的完整对局数",
        "hardRate": "MEDIUM",
        "passRate": "31.38%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-full-rounds-you-have-played/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-full-rounds-you-have-played/solution",
        "problemsDesc": "<p>一款新的在线电子游戏在近期发布，在该电子游戏中，以 <strong>刻钟</strong> 为周期规划若干时长为 <strong>15 分钟</strong> 的游戏对局。这意味着，在 <code>HH:00</code>、<code>HH:15</code>、<code>HH:30</code> 和 <code>HH:45</code> ，将会开始一个新的对局，其中 <code>HH</code> 用一个从 <code>00</code> 到 <code>23</code> 的整数表示。游戏中使用 <strong>24 小时制的时钟</strong> ，所以一天中最早的时间是 <code>00:00</code> ，最晚的时间是 <code>23:59</code> 。</p>\n\n<p>给你两个字符串 <code>startTime</code> 和 <code>finishTime</code> ，均符合 <code>\"HH:MM\"</code> 格式，分别表示你 <strong>进入</strong> 和 <strong>退出</strong> 游戏的确切时间，请计算在整个游戏会话期间，你完成的 <strong>完整对局的对局数</strong> 。</p>\n\n<ul>\n\t<li>例如，如果 <code>startTime = \"05:20\"</code> 且 <code>finishTime = \"05:59\"</code> ，这意味着你仅仅完成从 <code>05:30</code> 到 <code>05:45</code> 这一个完整对局。而你没有完成从 <code>05:15</code> 到 <code>05:30</code> 的完整对局，因为你是在对局开始后进入的游戏；同时，你也没有完成从 <code>05:45</code> 到 <code>06:00</code> 的完整对局，因为你是在对局结束前退出的游戏。</li>\n</ul>\n\n<p>如果 <code>finishTime</code> <strong>早于</strong> <code>startTime</code> ，这表示你玩了个通宵（也就是从 <code>startTime</code> 到午夜，再从午夜到 <code>finishTime</code>）。</p>\n\n<p>假设你是从 <code>startTime</code> 进入游戏，并在 <code>finishTime</code> 退出游戏，请计算并返回你完成的 <strong>完整对局的对局数</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>startTime = \"12:01\", finishTime = \"12:44\"\n<strong>输出：</strong>1\n<strong>解释：</strong>你完成了从 12:15 到 12:30 的一个完整对局。\n你没有完成从 12:00 到 12:15 的完整对局，因为你是在对局开始后的 12:01 进入的游戏。\n你没有完成从 12:30 到 12:45 的完整对局，因为你是在对局结束前的 12:44 退出的游戏。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>startTime = \"20:00\", finishTime = \"06:00\"\n<strong>输出：</strong>40\n<strong>解释：</strong>你完成了从 20:00 到 00:00 的 16 个完整的对局，以及从 00:00 到 06:00 的 24 个完整的对局。\n16 + 24 = 40\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>startTime = \"00:00\", finishTime = \"23:59\"\n<strong>输出：</strong>95\n<strong>解释：</strong>除最后一个小时你只完成了 3 个完整对局外，其余每个小时均完成了 4 场完整对局。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>startTime</code> 和 <code>finishTime</code> 的格式为 <code>HH:MM</code></li>\n\t<li><code>00 <= HH <= 23</code></li>\n\t<li><code>00 <= MM <= 59</code></li>\n\t<li><code>startTime</code> 和 <code>finishTime</code> 不相等</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1905统计子岛屿",
        "hardRate": "MEDIUM",
        "passRate": "67.14%",
        "problemsUrl": "https://leetcode.cn/problems/count-sub-islands/",
        "solutionsUrl": "https://leetcode.cn/problems/count-sub-islands/solution",
        "problemsDesc": "<p>给你两个 <code>m x n</code> 的二进制矩阵 <code>grid1</code> 和 <code>grid2</code> ，它们只包含 <code>0</code> （表示水域）和 <code>1</code> （表示陆地）。一个 <strong>岛屿</strong> 是由 <strong>四个方向</strong> （水平或者竖直）上相邻的 <code>1</code> 组成的区域。任何矩阵以外的区域都视为水域。</p>\n\n<p>如果 <code>grid2</code> 的一个岛屿，被 <code>grid1</code> 的一个岛屿 <strong>完全</strong> 包含，也就是说 <code>grid2</code> 中该岛屿的每一个格子都被 <code>grid1</code> 中同一个岛屿完全包含，那么我们称 <code>grid2</code> 中的这个岛屿为 <strong>子岛屿</strong> 。</p>\n\n<p>请你返回 <code>grid2</code> 中 <strong>子岛屿</strong> 的 <strong>数目</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/10/test1.png\" style=\"width: 493px; height: 205px;\">\n<pre><b>输入：</b>grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]\n<b>输出：</b>3\n<strong>解释：</strong>如上图所示，左边为 grid1 ，右边为 grid2 。\ngrid2 中标红的 1 区域是子岛屿，总共有 3 个子岛屿。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/03/testcasex2.png\" style=\"width: 491px; height: 201px;\">\n<pre><b>输入：</b>grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\n<b>输出：</b>2 \n<strong>解释：</strong>如上图所示，左边为 grid1 ，右边为 grid2 。\ngrid2 中标红的 1 区域是子岛屿，总共有 2 个子岛屿。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid1.length == grid2.length</code></li>\n\t<li><code>n == grid1[i].length == grid2[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>grid1[i][j]</code> 和 <code>grid2[i][j]</code> 都要么是 <code>0</code> 要么是 <code>1</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1906查询差绝对值的最小值",
        "hardRate": "MEDIUM",
        "passRate": "44.97%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-absolute-difference-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-absolute-difference-queries/solution",
        "problemsDesc": "<p>一个数组 <code>a</code> 的 <strong>差绝对值的最小值</strong> 定义为：<code>0 <= i < j < a.length</code> 且 <code>a[i] != a[j]</code> 的<strong> </strong><code><span style=\"\">|a[i] - a[j]|</span></code> 的 <strong>最小值</strong>。如果 <code>a</code> 中所有元素都 <strong>相同</strong> ，那么差绝对值的最小值为 <code>-1</code> 。</p>\n\n<ul>\n\t<li>比方说，数组 <code>[5,<strong>2</strong>,<strong>3</strong>,7,2]</code> 差绝对值的最小值是 <code>|2 - 3| = 1</code> 。注意答案不为 <code>0</code> ，因为 <code>a[i]</code> 和 <code>a[j]</code> 必须不相等。</li>\n</ul>\n\n<p>给你一个整数数组 <code>nums</code> 和查询数组 <code>queries</code> ，其中 <code>queries[i] = [l<sub>i</sub>, r<sub>i</sub>]</code> 。对于每个查询 <code>i</code> ，计算 <strong>子数组</strong> <code>nums[l<sub>i</sub>...r<sub>i</sub>]</code> 中 <strong>差绝对值的最小值</strong> ，子数组 <code>nums[l<sub>i</sub>...r<sub>i</sub>]</code> 包含 <code>nums</code> 数组（下标从 <strong>0</strong> 开始）中下标在 <code>l<sub>i</sub></code> 和 <code>r<sub>i</sub></code> 之间的所有元素（包含 <code>l<sub>i</sub></code> 和 <code>r<sub>i</sub></code> 在内）。</p>\n\n<p>请你返回 <code>ans</code> <strong>数组</strong>，其中 <code>ans[i]</code> 是第 <code>i</code> 个查询的答案。</p>\n\n<p><strong>子数组</strong> 是一个数组中连续的一段元素。</p>\n\n<p><code>|x|</code> 的值定义为：</p>\n\n<ul>\n\t<li>如果 <code>x >= 0</code> ，那么值为 <code>x</code> 。</li>\n\t<li>如果 <code>x < 0</code> ，那么值为 <code>-x</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,3,4,8], queries = [[0,1],[1,2],[2,3],[0,3]]\n<b>输出：</b>[2,1,4,1]\n<b>解释：</b>查询结果如下：\n- queries[0] = [0,1]：子数组是 [<strong>1</strong>,<strong>3</strong>] ，差绝对值的最小值为 |1-3| = 2 。\n- queries[1] = [1,2]：子数组是 [<strong>3</strong>,<strong>4</strong>] ，差绝对值的最小值为 |3-4| = 1 。\n- queries[2] = [2,3]：子数组是 [<strong>4</strong>,<strong>8</strong>] ，差绝对值的最小值为 |4-8| = 4 。\n- queries[3] = [0,3]：子数组是 [1,<strong>3</strong>,<strong>4</strong>,8] ，差的绝对值的最小值为 |3-4| = 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [4,5,2,2,7,10], queries = [[2,3],[0,2],[0,5],[3,5]]\n<b>输出：</b>[-1,1,1,3]\n<strong>解释：</strong>查询结果如下：\n- queries[0] = [2,3]：子数组是 [2,2] ，差绝对值的最小值为 -1 ，因为所有元素相等。\n- queries[1] = [0,2]：子数组是 [<strong>4</strong>,<strong>5</strong>,2] ，差绝对值的最小值为 |4-5| = 1 。\n- queries[2] = [0,5]：子数组是 [<strong>4</strong>,<strong>5</strong>,2,2,7,10] ，差绝对值的最小值为 |4-5| = 1 。\n- queries[3] = [3,5]：子数组是 [2,<strong>7</strong>,<strong>10</strong>] ，差绝对值的最小值为 |7-10| = 3 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 100</code></li>\n\t<li><code>1 <= queries.length <= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 <= l<sub>i</sub> < r<sub>i</sub> < nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1907按分类统计薪水",
        "hardRate": "MEDIUM",
        "passRate": "63.45%",
        "problemsUrl": "https://leetcode.cn/problems/count-salary-categories/",
        "solutionsUrl": "https://leetcode.cn/problems/count-salary-categories/solution",
        "problemsDesc": "<p>表: <code>Accounts</code></p>\n\n<pre>\n+-------------+------+\n| 列名        | 类型  |\n+-------------+------+\n| account_id  | int  |\n| income      | int  |\n+-------------+------+\naccount_id&nbsp;是这个表的主键。\n每一行都包含一个银行帐户的月收入的信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写出一个&nbsp;SQL&nbsp;查询，来报告每个工资类别的银行账户数量。&nbsp;工资类别如下：</p>\n\n<ul>\n\t<li><code>\"Low Salary\"</code>：所有工资 <strong>严格低于</strong> <code>20000</code> 美元。</li>\n\t<li><code>\"Average Salary\"</code>： <strong>包含</strong> 范围内的所有工资&nbsp;<code>[$20000,&nbsp;$50000]</code> 。</li>\n\t<li>\n\t<p><code>\"High Salary\"</code>：所有工资 <strong>严格大于</strong> <code>50000</code> 美元。</p>\n\t</li>\n</ul>\n\n<p>结果表 <strong>必须</strong> 包含所有三个类别。&nbsp;如果某个类别中没有帐户，则报告&nbsp;<code>0</code> 。</p>\n\n<p>按 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式如下示例。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>\nAccounts 表:\n+------------+--------+\n| account_id | income |\n+------------+--------+\n| 3          | 108939 |\n| 2          | 12747  |\n| 8          | 87709  |\n| 6          | 91796  |\n+------------+--------+\n<strong>输出：</strong>\n+----------------+----------------+\n| category       | accounts_count |\n+----------------+----------------+\n| Low Salary     | 1              |\n| Average Salary | 0              |\n| High Salary    | 3              |\n+----------------+----------------+\n<strong>解释：</strong>\n低薪: 数量为 2.\n中等薪水: 没有.\n高薪: 有三个账户，他们是 3, 6和 8.</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1908Nim 游戏 II",
        "hardRate": "MEDIUM",
        "passRate": "62.41%",
        "problemsUrl": "https://leetcode.cn/problems/game-of-nim/",
        "solutionsUrl": "https://leetcode.cn/problems/game-of-nim/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1909删除一个元素使数组严格递增",
        "hardRate": "EASY",
        "passRate": "29.97%",
        "problemsUrl": "https://leetcode.cn/problems/remove-one-element-to-make-the-array-strictly-increasing/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-one-element-to-make-the-array-strictly-increasing/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，如果 <strong>恰好</strong> 删除 <strong>一个</strong> 元素后，数组 <strong>严格递增</strong> ，那么请你返回 <code>true</code> ，否则返回 <code>false</code> 。如果数组本身已经是严格递增的，请你也返回 <code>true</code> 。</p>\n\n<p>数组 <code>nums</code> 是 <strong>严格递增</strong> 的定义为：对于任意下标的 <code>1 &lt;= i &lt; nums.length</code> 都满足 <code>nums[i - 1] &lt; nums[i]</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,<strong>10</strong>,5,7]\n<b>输出：</b>true\n<b>解释：</b>从 nums 中删除下标 2 处的 10 ，得到 [1,2,5,7] 。\n[1,2,5,7] 是严格递增的，所以返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,3,1,2]\n<b>输出：</b>false\n<b>解释：</b>\n[3,1,2] 是删除下标 0 处元素后得到的结果。\n[2,1,2] 是删除下标 1 处元素后得到的结果。\n[2,3,2] 是删除下标 2 处元素后得到的结果。\n[2,3,1] 是删除下标 3 处元素后得到的结果。\n没有任何结果数组是严格递增的，所以返回 false 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [1,1,1]\n<b>输出：</b>false\n<b>解释：</b>删除任意元素后的结果都是 [1,1] 。\n[1,1] 不是严格递增的，所以返回 false 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3]\n<b>输出：</b>true\n<b>解释：</b>[1,2,3] 已经是严格递增的，所以返回 true 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1910删除一个字符串中所有出现的给定子字符串",
        "hardRate": "MEDIUM",
        "passRate": "66.47%",
        "problemsUrl": "https://leetcode.cn/problems/remove-all-occurrences-of-a-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-all-occurrences-of-a-substring/solution",
        "problemsDesc": "<p>给你两个字符串 <code>s</code> 和 <code>part</code> ，请你对 <code>s</code> 反复执行以下操作直到 <b>所有</b> 子字符串 <code>part</code> 都被删除：</p>\n\n<ul>\n\t<li>找到 <code>s</code> 中 <strong>最左边</strong> 的子字符串 <code>part</code> ，并将它从 <code>s</code> 中删除。</li>\n</ul>\n\n<p>请你返回从 <code>s</code> 中删除所有 <code>part</code> 子字符串以后得到的剩余字符串。</p>\n\n<p>一个 <strong>子字符串</strong> 是一个字符串中连续的字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"daabcbaabcbc\", part = \"abc\"\n<b>输出：</b>\"dab\"\n<b>解释：</b>以下操作按顺序执行：\n- s = \"da<strong>abc</strong>baabcbc\" ，删除下标从 2 开始的 \"abc\" ，得到 s = \"dabaabcbc\" 。\n- s = \"daba<strong>abc</strong>bc\" ，删除下标从 4 开始的 \"abc\" ，得到 s = \"dababc\" 。\n- s = \"dab<strong>abc</strong>\" ，删除下标从 3 开始的 \"abc\" ，得到 s = \"dab\" 。\n此时 s 中不再含有子字符串 \"abc\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"axxxxyyyyb\", part = \"xy\"\n<b>输出：</b>\"ab\"\n<b>解释：</b>以下操作按顺序执行：\n- s = \"axxx<strong>xy</strong>yyyb\" ，删除下标从 4 开始的 \"xy\" ，得到 s = \"axxxyyyb\" 。\n- s = \"axx<strong>xy</strong>yyb\" ，删除下标从 3 开始的 \"xy\" ，得到 s = \"axxyyb\" 。\n- s = \"ax<strong>xy</strong>yb\" ，删除下标从 2 开始的 \"xy\" ，得到 s = \"axyb\" 。\n- s = \"a<strong>xy</strong>b\" ，删除下标从 1 开始的 \"xy\" ，得到 s = \"ab\" 。\n此时 s 中不再含有子字符串 \"xy\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= part.length &lt;= 1000</code></li>\n\t<li><code>s</code>​​​​​​ 和 <code>part</code> 只包小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1911最大子序列交替和",
        "hardRate": "MEDIUM",
        "passRate": "59.17%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-alternating-subsequence-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-alternating-subsequence-sum/solution",
        "problemsDesc": "<p>一个下标从 <strong>0</strong> 开始的数组的 <strong>交替和</strong> 定义为 <strong>偶数</strong> 下标处元素之 <strong>和</strong> 减去 <strong>奇数</strong> 下标处元素之 <strong>和</strong> 。</p>\n\n<ul>\n\t<li>比方说，数组 <code>[4,2,5,3]</code> 的交替和为 <code>(4 + 5) - (2 + 3) = 4</code> 。</li>\n</ul>\n\n<p>给你一个数组 <code>nums</code> ，请你返回 <code>nums</code> 中任意子序列的 <strong>最大交替和</strong> （子序列的下标 <strong>重新</strong> 从 0 开始编号）。</p>\n\n<ul>\n</ul>\n\n<p>一个数组的 <strong>子序列</strong> 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。比方说，<code>[2,7,4]</code> 是 <code>[4,<strong>2</strong>,3,<strong>7</strong>,2,1,<strong>4</strong>]</code> 的一个子序列（加粗元素），但是 <code>[2,4,2]</code> 不是。</p>\n\n<p> </p>\n\n<p><b>示例 1：</b></p>\n\n<pre><b>输入：</b>nums = [<strong>4</strong>,<strong>2</strong>,<strong>5</strong>,3]\n<b>输出：</b>7\n<b>解释：</b>最优子序列为 [4,2,5] ，交替和为 (4 + 5) - 2 = 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [5,6,7,<strong>8</strong>]\n<b>输出：</b>8\n<b>解释：</b>最优子序列为 [8] ，交替和为 8 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [<strong>6</strong>,2,<strong>1</strong>,2,4,<strong>5</strong>]\n<b>输出：</b>10\n<b>解释：</b>最优子序列为 [6,1,5] ，交替和为 (6 + 5) - 1 = 10 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1912设计电影租借系统",
        "hardRate": "HARD",
        "passRate": "24.10%",
        "problemsUrl": "https://leetcode.cn/problems/design-movie-rental-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-movie-rental-system/solution",
        "problemsDesc": "<p>你有一个电影租借公司和 <code>n</code> 个电影商店。你想要实现一个电影租借系统，它支持查询、预订和返还电影的操作。同时系统还能生成一份当前被借出电影的报告。</p>\n\n<p>所有电影用二维整数数组 <code>entries</code> 表示，其中 <code>entries[i] = [shop<sub>i</sub>, movie<sub>i</sub>, price<sub>i</sub>]</code> 表示商店 <code>shop<sub>i</sub></code> 有一份电影 <code>movie<sub>i</sub></code> 的拷贝，租借价格为 <code>price<sub>i</sub></code> 。每个商店有 <strong>至多一份</strong> 编号为 <code>movie<sub>i</sub></code> 的电影拷贝。</p>\n\n<p>系统需要支持以下操作：</p>\n\n<ul>\n\t<li><strong>Search：</strong>找到拥有指定电影且 <strong>未借出</strong> 的商店中 <strong>最便宜的 5 个</strong> 。商店需要按照 <strong>价格</strong> 升序排序，如果价格相同，则 <code>shop<sub>i</sub></code> <strong>较小</strong> 的商店排在前面。如果查询结果少于 5 个商店，则将它们全部返回。如果查询结果没有任何商店，则返回空列表。</li>\n\t<li><strong>Rent：</strong>从指定商店借出指定电影，题目保证指定电影在指定商店 <strong>未借出</strong> 。</li>\n\t<li><strong>Drop：</strong>在指定商店返还 <strong>之前已借出</strong> 的指定电影。</li>\n\t<li><strong>Report：</strong>返回 <strong>最便宜的 5 部已借出电影</strong> （可能有重复的电影 ID），将结果用二维列表 <code>res</code> 返回，其中 <code>res[j] = [shop<sub>j</sub>, movie<sub>j</sub>]</code> 表示第 <code>j</code> 便宜的已借出电影是从商店 <code>shop<sub>j</sub></code> 借出的电影 <code>movie<sub>j</sub></code> 。<code>res</code> 中的电影需要按 <strong>价格</strong> 升序排序；如果价格相同，则<strong> </strong><code>shop<sub>j</sub></code> <strong>较小</strong> 的排在前面；如果仍然相同，则 <code>movie<sub>j</sub></code> <strong>较小 </strong>的排在前面。如果当前借出的电影小于 5 部，则将它们全部返回。如果当前没有借出电影，则返回一个空的列表。</li>\n</ul>\n\n<p>请你实现 <code>MovieRentingSystem</code> 类：</p>\n\n<ul>\n\t<li><code>MovieRentingSystem(int n, int[][] entries)</code> 将 <code>MovieRentingSystem</code> 对象用 <code>n</code> 个商店和 <code>entries</code> 表示的电影列表初始化。</li>\n\t<li><code>List&lt;Integer&gt; search(int movie)</code> 如上所述，返回 <strong>未借出</strong> 指定 <code>movie</code> 的商店列表。</li>\n\t<li><code>void rent(int shop, int movie)</code> 从指定商店 <code>shop</code> 借出指定电影 <code>movie</code> 。</li>\n\t<li><code>void drop(int shop, int movie)</code> 在指定商店 <code>shop</code> 返还之前借出的电影 <code>movie</code> 。</li>\n\t<li><code>List&lt;List&lt;Integer&gt;&gt; report()</code> 如上所述，返回最便宜的 <strong>已借出</strong> 电影列表。</li>\n</ul>\n\n<p><strong>注意：</strong>测试数据保证 <code>rent</code> 操作中指定商店拥有 <strong>未借出 </strong>的指定电影，且 <code>drop</code> 操作指定的商店 <strong>之前已借出</strong> 指定电影。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"MovieRentingSystem\", \"search\", \"rent\", \"rent\", \"report\", \"drop\", \"search\"]\n[[3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]], [1], [0, 1], [1, 2], [], [1, 2], [2]]\n<strong>输出：</strong>\n[null, [1, 0, 2], null, null, [[0, 1], [1, 2]], null, [0, 1]]\n\n<strong>解释：</strong>\nMovieRentingSystem movieRentingSystem = new MovieRentingSystem(3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]);\nmovieRentingSystem.search(1);  // 返回 [1, 0, 2] ，商店 1，0 和 2 有未借出的 ID 为 1 的电影。商店 1 最便宜，商店 0 和 2 价格相同，所以按商店编号排序。\nmovieRentingSystem.rent(0, 1); // 从商店 0 借出电影 1 。现在商店 0 未借出电影编号为 [2,3] 。\nmovieRentingSystem.rent(1, 2); // 从商店 1 借出电影 2 。现在商店 1 未借出的电影编号为 [1] 。\nmovieRentingSystem.report();   // 返回 [[0, 1], [1, 2]] 。商店 0 借出的电影 1 最便宜，然后是商店 1 借出的电影 2 。\nmovieRentingSystem.drop(1, 2); // 在商店 1 返还电影 2 。现在商店 1 未借出的电影编号为 [1,2] 。\nmovieRentingSystem.search(2);  // 返回 [0, 1] 。商店 0 和 1 有未借出的 ID 为 2 的电影。商店 0 最便宜，然后是商店 1 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 3 * 10<sup>5</sup></code></li>\n\t<li><code>1 <= entries.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= shop<sub>i</sub> < n</code></li>\n\t<li><code>1 <= movie<sub>i</sub>, price<sub>i</sub> <= 10<sup>4</sup></code></li>\n\t<li>每个商店 <strong>至多</strong> 有一份电影 <code>movie<sub>i</sub></code> 的拷贝。</li>\n\t<li><code>search</code>，<code>rent</code>，<code>drop</code> 和 <code>report</code> 的调用 <strong>总共</strong> 不超过 <code>10<sup>5</sup></code> 次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1913两个数对之间的最大乘积差",
        "hardRate": "EASY",
        "passRate": "81.43%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-product-difference-between-two-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-product-difference-between-two-pairs/solution",
        "problemsDesc": "<p>两个数对 <code>(a, b)</code> 和 <code>(c, d)</code> 之间的 <strong>乘积差</strong> 定义为 <code>(a * b) - (c * d)</code> 。</p>\n\n<ul>\n\t<li>例如，<code>(5, 6)</code> 和 <code>(2, 7)</code> 之间的乘积差是 <code>(5 * 6) - (2 * 7) = 16</code> 。</li>\n</ul>\n\n<p>给你一个整数数组 <code>nums</code> ，选出四个 <strong>不同的</strong> 下标 <code>w</code>、<code>x</code>、<code>y</code> 和 <code>z</code> ，使数对 <code>(nums[w], nums[x])</code> 和 <code>(nums[y], nums[z])</code> 之间的 <strong>乘积差</strong> 取到 <strong>最大值</strong> 。</p>\n\n<p>返回以这种方式取得的乘积差中的 <strong>最大值</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,6,2,7,4]\n<strong>输出：</strong>34\n<strong>解释：</strong>可以选出下标为 1 和 3 的元素构成第一个数对 (6, 7) 以及下标 2 和 4 构成第二个数对 (2, 4)\n乘积差是 (6 * 7) - (2 * 4) = 34\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,2,5,9,7,4,8]\n<strong>输出：</strong>64\n<strong>解释：</strong>可以选出下标为 3 和 6 的元素构成第一个数对 (9, 8) 以及下标 1 和 5 构成第二个数对 (2, 4)\n乘积差是 (9 * 8) - (2 * 4) = 64\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>4 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1914循环轮转矩阵",
        "hardRate": "MEDIUM",
        "passRate": "46.54%",
        "problemsUrl": "https://leetcode.cn/problems/cyclically-rotating-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/cyclically-rotating-a-grid/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的整数矩阵 <code>grid</code>​​​ ，其中 <code>m</code> 和 <code>n</code> 都是 <strong>偶数</strong> ；另给你一个整数 <code>k</code> 。</p>\n\n<p>矩阵由若干层组成，如下图所示，每种颜色代表一层：</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/10/ringofgrid.png\" style=\"width: 231px; height: 258px;\"></p>\n\n<p>矩阵的循环轮转是通过分别循环轮转矩阵中的每一层完成的。在对某一层进行一次循环旋转操作时，层中的每一个元素将会取代其 <strong>逆时针 </strong>方向的相邻元素。轮转示例如下：</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/22/explanation_grid.jpg\" style=\"width: 500px; height: 268px;\">\n<p>返回执行 <code>k</code> 次循环轮转操作后的矩阵。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/19/rod2.png\" style=\"width: 421px; height: 191px;\">\n<pre><strong>输入：</strong>grid = [[40,10],[30,20]], k = 1\n<strong>输出：</strong>[[10,20],[40,30]]\n<strong>解释：</strong>上图展示了矩阵在执行循环轮转操作时每一步的状态。</pre>\n\n<p><strong>示例 2：</strong></p>\n<strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/10/ringofgrid5.png\" style=\"width: 231px; height: 262px;\"></strong> <strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/10/ringofgrid6.png\" style=\"width: 231px; height: 262px;\"></strong> <strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/10/ringofgrid7.png\" style=\"width: 231px; height: 262px;\"></strong>\n\n<pre><strong>输入：</strong>grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2\n<strong>输出：</strong>[[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]]\n<strong>解释：</strong>上图展示了矩阵在执行循环轮转操作时每一步的状态。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>m</code> 和 <code>n</code> 都是 <strong>偶数</strong></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;=<sup> </sup>5000</code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1915最美子字符串的数目",
        "hardRate": "MEDIUM",
        "passRate": "44.67%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-wonderful-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-wonderful-substrings/solution",
        "problemsDesc": "<p>如果某个字符串中 <strong>至多一个</strong> 字母出现 <strong>奇数</strong> 次，则称其为 <strong>最美</strong> 字符串。</p>\n\n<ul>\n\t<li>例如，<code>\"ccjjc\"</code> 和 <code>\"abab\"</code> 都是最美字符串，但 <code>\"ab\"</code> 不是。</li>\n</ul>\n\n<p>给你一个字符串 <code>word</code> ，该字符串由前十个小写英文字母组成（<code>'a'</code> 到 <code>'j'</code>）。请你返回 <code>word</code> 中 <strong>最美非空子字符串</strong> 的数目<em>。</em>如果同样的子字符串在<em> </em><code>word</code> 中出现多次，那么应当对 <strong>每次出现</strong> 分别计数<em>。</em></p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"aba\"\n<strong>输出：</strong>4\n<strong>解释：</strong>4 个最美子字符串如下所示：\n- \"<strong>a</strong>ba\" -> \"a\"\n- \"a<strong>b</strong>a\" -> \"b\"\n- \"ab<strong>a</strong>\" -> \"a\"\n- \"<strong>aba</strong>\" -> \"aba\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"aabb\"\n<strong>输出：</strong>9\n<strong>解释：</strong>9 个最美子字符串如下所示：\n- \"<strong>a</strong>abb\" -> \"a\"\n- \"<strong>aa</strong>bb\" -> \"aa\"\n- \"<strong>aab</strong>b\" -> \"aab\"\n- \"<strong>aabb</strong>\" -> \"aabb\"\n- \"a<strong>a</strong>bb\" -> \"a\"\n- \"a<strong>abb</strong>\" -> \"abb\"\n- \"aa<strong>b</strong>b\" -> \"b\"\n- \"aa<strong>bb</strong>\" -> \"bb\"\n- \"aab<strong>b</strong>\" -> \"b\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"he\"\n<strong>输出：</strong>2\n<strong>解释：</strong>2 个最美子字符串如下所示：\n- \"<b>h</b>e\" -> \"h\"\n- \"h<strong>e</strong>\" -> \"e\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word.length <= 10<sup>5</sup></code></li>\n\t<li><code>word</code> 由从 <code>'a'</code> 到 <code>'j'</code> 的小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1916统计为蚁群构筑房间的不同顺序",
        "hardRate": "HARD",
        "passRate": "55.60%",
        "problemsUrl": "https://leetcode.cn/problems/count-ways-to-build-rooms-in-an-ant-colony/",
        "solutionsUrl": "https://leetcode.cn/problems/count-ways-to-build-rooms-in-an-ant-colony/solution",
        "problemsDesc": "<p>你是一只蚂蚁，负责为蚁群构筑 <code>n</code> 间编号从 <code>0</code> 到 <code>n-1</code> 的新房间。给你一个 <strong>下标从 0 开始</strong> 且长度为 <code>n</code> 的整数数组&nbsp;<code>prevRoom</code> 作为扩建计划。其中，<code>prevRoom[i]</code> 表示在构筑房间 <code>i</code> 之前，你必须先构筑房间 <code>prevRoom[i]</code> ，并且这两个房间必须 <strong>直接</strong> 相连。房间 <code>0</code> 已经构筑完成，所以 <code>prevRoom[0] = -1</code> 。扩建计划中还有一条硬性要求，在完成所有房间的构筑之后，从房间 <code>0</code> 可以访问到每个房间。</p>\n\n<p>你一次只能构筑 <strong>一个</strong> 房间。你可以在 <strong>已经构筑好的</strong> 房间之间自由穿行，只要这些房间是 <strong>相连的</strong> 。如果房间&nbsp;<code>prevRoom[i]</code> 已经构筑完成，那么你就可以构筑房间 <code>i</code>。</p>\n\n<p>返回你构筑所有房间的 <strong>不同顺序的数目</strong> 。由于答案可能很大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/19/d1.JPG\" style=\"width: 200px; height: 212px;\" />\n<pre>\n<strong>输入：</strong><code>prevRoom</code> = [-1,0,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>仅有一种方案可以完成所有房间的构筑：0 → 1 → 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/19/d2.JPG\" style=\"width: 200px; height: 239px;\" /></strong>\n\n<pre>\n<strong>输入：</strong><code>prevRoom</code> = [-1,0,0,1,2]\n<strong>输出：</strong>6\n<strong>解释：\n</strong>有 6 种不同顺序：\n0 → 1 → 3 → 2 → 4\n0 → 2 → 4 → 1 → 3\n0 → 1 → 2 → 3 → 4\n0 → 1 → 2 → 4 → 3\n0 → 2 → 1 → 3 → 4\n0 → 2 → 1 → 4 → 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == prevRoom.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>prevRoom[0] == -1</code></li>\n\t<li>对于所有的&nbsp;<code>1 &lt;= i &lt; n</code>&nbsp;，都有&nbsp;<code>0 &lt;= prevRoom[i] &lt; n</code></li>\n\t<li>题目保证所有房间都构筑完成后，从房间 <code>0</code> 可以访问到每个房间</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1917Leetcodify 好友推荐",
        "hardRate": "HARD",
        "passRate": "31.57%",
        "problemsUrl": "https://leetcode.cn/problems/leetcodify-friends-recommendations/",
        "solutionsUrl": "https://leetcode.cn/problems/leetcodify-friends-recommendations/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1918第 K 小的子数组和·",
        "hardRate": "MEDIUM",
        "passRate": "48.04%",
        "problemsUrl": "https://leetcode.cn/problems/kth-smallest-subarray-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-smallest-subarray-sum/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1919兴趣相同的朋友",
        "hardRate": "HARD",
        "passRate": "43.33%",
        "problemsUrl": "https://leetcode.cn/problems/leetcodify-similar-friends/",
        "solutionsUrl": "https://leetcode.cn/problems/leetcodify-similar-friends/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1920基于排列构建数组",
        "hardRate": "EASY",
        "passRate": "86.62%",
        "problemsUrl": "https://leetcode.cn/problems/build-array-from-permutation/",
        "solutionsUrl": "https://leetcode.cn/problems/build-array-from-permutation/solution",
        "problemsDesc": "<p>给你一个 <strong>从 0 开始的排列</strong> <code>nums</code>（<strong>下标也从 0 开始</strong>）。请你构建一个 <strong>同样长度</strong> 的数组 <code>ans</code> ，其中，对于每个 <code>i</code>（<code>0 &lt;= i &lt; nums.length</code>），都满足 <code>ans[i] = nums[nums[i]]</code> 。返回构建好的数组 <code>ans</code> 。</p>\n\n<p><strong>从 0 开始的排列</strong> <code>nums</code> 是一个由 <code>0</code> 到 <code>nums.length - 1</code>（<code>0</code> 和 <code>nums.length - 1</code> 也包含在内）的不同整数组成的数组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,2,1,5,3,4]\n<strong>输出：</strong>[0,1,2,4,5,3]<strong>\n解释：</strong>数组 ans 构建如下：\nans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n    = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]]\n    = [0,1,2,4,5,3]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,0,1,2,3,4]\n<strong>输出：</strong>[4,5,0,1,2,3]\n<strong>解释：</strong>数组 ans 构建如下：\nans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n    = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]]\n    = [4,5,0,1,2,3]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt; nums.length</code></li>\n\t<li><code>nums</code> 中的元素 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1921消灭怪物的最大数量",
        "hardRate": "MEDIUM",
        "passRate": "36.99%",
        "problemsUrl": "https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/",
        "solutionsUrl": "https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/solution",
        "problemsDesc": "<p>你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。给你一个 <strong>下标从 0 开始</strong> 且长度为 <code>n</code> 的整数数组 <code>dist</code> ，其中 <code>dist[i]</code> 是第 <code>i</code> 个怪物与城市的 <strong>初始距离</strong>（单位：米）。</p>\n\n<p>怪物以 <strong>恒定</strong> 的速度走向城市。给你一个长度为 <code>n</code> 的整数数组 <code>speed</code> 表示每个怪物的速度，其中 <code>speed[i]</code> 是第 <code>i</code> 个怪物的速度（单位：米/分）。</p>\n\n<p>怪物从 <strong>第 0 分钟</strong> 时开始移动。你有一把武器，并可以 <strong>选择</strong> 在每一分钟的开始时使用，包括第 0 分钟。但是你无法在一分钟的中间使用武器。这种武器威力惊人，一次可以消灭任一还活着的怪物。</p>\n\n<p>一旦任一怪物到达城市，你就输掉了这场游戏。如果某个怪物 <strong>恰</strong> 在某一分钟开始时到达城市，这会被视为<strong> 输掉</strong> 游戏，在你可以使用武器之前，游戏就会结束。</p>\n\n<p>返回在你输掉游戏前可以消灭的怪物的 <strong>最大</strong> 数量。如果你可以在所有怪物到达城市前将它们全部消灭，返回  <code>n</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [1,3,4], speed = [1,1,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n第 0 分钟开始时，怪物的距离是 [1,3,4]，你消灭了第一个怪物。\n第 1 分钟开始时，怪物的距离是 [X,2,3]，你没有消灭任何怪物。\n第 2 分钟开始时，怪物的距离是 [X,1,2]，你消灭了第二个怪物。\n第 3 分钟开始时，怪物的距离是 [X,X,1]，你消灭了第三个怪物。\n所有 3 个怪物都可以被消灭。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [1,1,2,3], speed = [1,1,1,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n第 0 分钟开始时，怪物的距离是 [1,1,2,3]，你消灭了第一个怪物。\n第 1 分钟开始时，怪物的距离是 [X,0,1,2]，你输掉了游戏。\n你只能消灭 1 个怪物。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [3,2,4], speed = [5,3,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n第 0 分钟开始时，怪物的距离是 [3,2,4]，你消灭了第一个怪物。\n第 1 分钟开始时，怪物的距离是 [X,0,2]，你输掉了游戏。 \n你只能消灭 1 个怪物。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == dist.length == speed.length</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= dist[i], speed[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1922统计好数字的数目",
        "hardRate": "MEDIUM",
        "passRate": "36.20%",
        "problemsUrl": "https://leetcode.cn/problems/count-good-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/count-good-numbers/solution",
        "problemsDesc": "<p>我们称一个数字字符串是 <strong>好数字</strong> 当它满足（下标从 <strong>0</strong> 开始）<strong>偶数</strong> 下标处的数字为 <strong>偶数</strong> 且 <strong>奇数</strong> 下标处的数字为 <strong>质数</strong> （<code>2</code>，<code>3</code>，<code>5</code> 或 <code>7</code>）。</p>\n\n<ul>\n\t<li>比方说，<code>\"2582\"</code> 是好数字，因为偶数下标处的数字（<code>2</code> 和 <code>8</code>）是偶数且奇数下标处的数字（<code>5</code> 和 <code>2</code>）为质数。但 <code>\"3245\"</code> <strong>不是</strong> 好数字，因为 <code>3</code> 在偶数下标处但不是偶数。</li>\n</ul>\n\n<p>给你一个整数 <code>n</code> ，请你返回长度为 <code>n</code> 且为好数字的数字字符串 <strong>总数</strong> 。由于答案可能会很大，请你将它对<strong> </strong><code>10<sup>9</sup> + 7</code> <strong>取余后返回</strong> 。</p>\n\n<p>一个 <strong>数字字符串</strong> 是每一位都由 <code>0</code> 到 <code>9</code> 组成的字符串，且可能包含前导 0 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 1\n<b>输出：</b>5\n<b>解释：</b>长度为 1 的好数字包括 \"0\"，\"2\"，\"4\"，\"6\"，\"8\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 4\n<b>输出：</b>400\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 50\n<b>输出：</b>564908303\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 10<sup>15</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1923最长公共子路径",
        "hardRate": "HARD",
        "passRate": "26.84%",
        "problemsUrl": "https://leetcode.cn/problems/longest-common-subpath/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-common-subpath/solution",
        "problemsDesc": "<p>一个国家由 <code>n</code> 个编号为 <code>0</code> 到 <code>n - 1</code> 的城市组成。在这个国家里，<strong>每两个</strong> 城市之间都有一条道路连接。</p>\n\n<p>总共有 <code>m</code> 个编号为 <code>0</code> 到 <code>m - 1</code> 的朋友想在这个国家旅游。他们每一个人的路径都会包含一些城市。每条路径都由一个整数数组表示，每个整数数组表示一个朋友按顺序访问过的城市序列。同一个城市在一条路径中可能 <strong>重复</strong> 出现，但同一个城市在一条路径中不会连续出现。</p>\n\n<p>给你一个整数 <code>n</code> 和二维数组 <code>paths</code> ，其中 <code>paths[i]</code> 是一个整数数组，表示第 <code>i</code> 个朋友走过的路径，请你返回 <strong>每一个</strong> 朋友都走过的 <strong>最长公共子路径</strong> 的长度，如果不存在公共子路径，请你返回 <code>0</code> 。</p>\n\n<p>一个 <strong>子路径</strong> 指的是一条路径中连续的城市序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5, paths = [[0,1,<strong>2,3</strong>,4],\n                     [<strong>2,3</strong>,4],\n                     [4,0,1,<strong>2,3</strong>]]\n<b>输出：</b>2\n<b>解释：</b>最长公共子路径为 [2,3] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, paths = [[0],[1],[2]]\n<b>输出：</b>0\n<b>解释：</b>三条路径没有公共子路径。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5, paths = [[<strong>0</strong>,1,2,3,4],\n                     [4,3,2,1,<strong>0</strong>]]\n<b>输出：</b>1\n<b>解释：</b>最长公共子路径为 [0]，[1]，[2]，[3] 和 [4] 。它们长度都为 1 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>m == paths.length</code></li>\n\t<li><code>2 <= m <= 10<sup>5</sup></code></li>\n\t<li><code>sum(paths[i].length) <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= paths[i][j] < n</code></li>\n\t<li><code>paths[i]</code> 中同一个城市不会连续重复出现。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1924安装栅栏 II",
        "hardRate": "HARD",
        "passRate": "46.40%",
        "problemsUrl": "https://leetcode.cn/problems/erect-the-fence-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/erect-the-fence-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1925统计平方和三元组的数目",
        "hardRate": "EASY",
        "passRate": "69.53%",
        "problemsUrl": "https://leetcode.cn/problems/count-square-sum-triples/",
        "solutionsUrl": "https://leetcode.cn/problems/count-square-sum-triples/solution",
        "problemsDesc": "<p>一个 <strong>平方和三元组</strong> <code>(a,b,c)</code> 指的是满足 <code>a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup></code> 的 <strong>整数 </strong>三元组 <code>a</code>，<code>b</code> 和 <code>c</code> 。</p>\n\n<p>给你一个整数 <code>n</code> ，请你返回满足<em> </em><code>1 &lt;= a, b, c &lt;= n</code> 的 <strong>平方和三元组</strong> 的数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 5\n<b>输出：</b>2\n<b>解释：</b>平方和三元组为 (3,4,5) 和 (4,3,5) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 10\n<b>输出：</b>4\n<b>解释：</b>平方和三元组为 (3,4,5)，(4,3,5)，(6,8,10) 和 (8,6,10) 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 250</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1926迷宫中离入口最近的出口",
        "hardRate": "MEDIUM",
        "passRate": "39.51%",
        "problemsUrl": "https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/",
        "solutionsUrl": "https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的迷宫矩阵 <code>maze</code> （<strong>下标从 0 开始</strong>），矩阵中有空格子（用 <code>'.'</code> 表示）和墙（用 <code>'+'</code> 表示）。同时给你迷宫的入口 <code>entrance</code> ，用 <code>entrance = [entrance<sub>row</sub>, entrance<sub>col</sub>]</code> 表示你一开始所在格子的行和列。</p>\n\n<p>每一步操作，你可以往 <strong>上</strong>，<strong>下</strong>，<strong>左</strong> 或者 <strong>右</strong> 移动一个格子。你不能进入墙所在的格子，你也不能离开迷宫。你的目标是找到离 <code>entrance</code> <strong>最近</strong> 的出口。<strong>出口</strong> 的含义是 <code>maze</code> <strong>边界</strong> 上的 <strong>空格子</strong>。<code>entrance</code> 格子 <strong>不算</strong> 出口。</p>\n\n<p>请你返回从 <code>entrance</code> 到最近出口的最短路径的 <strong>步数</strong> ，如果不存在这样的路径，请你返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/nearest1-grid.jpg\" style=\"width: 333px; height: 253px;\">\n<pre><b>输入：</b>maze = [[\"+\",\"+\",\".\",\"+\"],[\".\",\".\",\".\",\"+\"],[\"+\",\"+\",\"+\",\".\"]], entrance = [1,2]\n<b>输出：</b>1\n<b>解释：</b>总共有 3 个出口，分别位于 (1,0)，(0,2) 和 (2,3) 。\n一开始，你在入口格子 (1,2) 处。\n- 你可以往左移动 2 步到达 (1,0) 。\n- 你可以往上移动 1 步到达 (0,2) 。\n从入口处没法到达 (2,3) 。\n所以，最近的出口是 (0,2) ，距离为 1 步。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/nearesr2-grid.jpg\" style=\"width: 253px; height: 253px;\">\n<pre><b>输入：</b>maze = [[\"+\",\"+\",\"+\"],[\".\",\".\",\".\"],[\"+\",\"+\",\"+\"]], entrance = [1,0]\n<b>输出：</b>2\n<b>解释：</b>迷宫中只有 1 个出口，在 (1,2) 处。\n(1,0) 不算出口，因为它是入口格子。\n初始时，你在入口与格子 (1,0) 处。\n- 你可以往右移动 2 步到达 (1,2) 处。\n所以，最近的出口为 (1,2) ，距离为 2 步。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/nearest3-grid.jpg\" style=\"width: 173px; height: 93px;\">\n<pre><b>输入：</b>maze = [[\".\",\"+\"]], entrance = [0,0]\n<b>输出：</b>-1\n<b>解释：</b>这个迷宫中没有出口。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>maze.length == m</code></li>\n\t<li><code>maze[i].length == n</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>maze[i][j]</code> 要么是 <code>'.'</code> ，要么是 <code>'+'</code> 。</li>\n\t<li><code>entrance.length == 2</code></li>\n\t<li><code>0 &lt;= entrance<sub>row</sub> &lt; m</code></li>\n\t<li><code>0 &lt;= entrance<sub>col</sub> &lt; n</code></li>\n\t<li><code>entrance</code> 一定是空格子。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1927求和游戏",
        "hardRate": "MEDIUM",
        "passRate": "43.51%",
        "problemsUrl": "https://leetcode.cn/problems/sum-game/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-game/solution",
        "problemsDesc": "<p>Alice 和 Bob 玩一个游戏，两人轮流行动，<strong>Alice 先手</strong> 。</p>\n\n<p>给你一个 <strong>偶数长度</strong> 的字符串 <code>num</code> ，每一个字符为数字字符或者 <code>'?'</code> 。每一次操作中，如果 <code>num</code> 中至少有一个 <code>'?'</code> ，那么玩家可以执行以下操作：</p>\n\n<ol>\n\t<li>选择一个下标 <code>i</code> 满足 <code>num[i] == '?'</code> 。</li>\n\t<li>将 <code>num[i]</code> 用 <code>'0'</code> 到 <code>'9'</code> 之间的一个数字字符替代。</li>\n</ol>\n\n<p>当 <code>num</code> 中没有<span style=\"\"> </span><code>'?'</code> 时，游戏结束。</p>\n\n<p>Bob 获胜的条件是 <code>num</code> 中前一半数字的和 <strong>等于</strong> 后一半数字的和。Alice 获胜的条件是前一半的和与后一半的和 <strong>不相等</strong> 。</p>\n\n<ul>\n\t<li>比方说，游戏结束时 <code>num = \"243801\"</code> ，那么 Bob 获胜，因为 <code>2+4+3 = 8+0+1</code> 。如果游戏结束时 <code>num = \"243803\"</code> ，那么 Alice 获胜，因为 <code>2+4+3 != 8+0+3</code> 。</li>\n</ul>\n\n<p>在 Alice 和 Bob 都采取 <strong>最优</strong> 策略的前提下，如果 Alice 获胜，请返回 <code>true</code> ，如果 Bob 获胜，请返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>num = \"5023\"\n<b>输出：</b>false\n<b>解释：</b>num 中没有 '?' ，没法进行任何操作。\n前一半的和等于后一半的和：5 + 0 = 2 + 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>num = \"25??\"\n<b>输出：</b>true\n<strong>解释：</strong>Alice 可以将两个 '?' 中的一个替换为 '9' ，Bob 无论如何都无法使前一半的和等于后一半的和。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>num = \"?3295???\"\n<b>输出：</b>false\n<b>解释：</b>Bob 总是能赢。一种可能的结果是：\n- Alice 将第一个 '?' 用 '9' 替换。num = \"93295???\" 。\n- Bob 将后面一半中的一个 '?' 替换为 '9' 。num = \"932959??\" 。\n- Alice 将后面一半中的一个 '?' 替换为 '2' 。num = \"9329592?\" 。\n- Bob 将后面一半中最后一个 '?' 替换为 '7' 。num = \"93295927\" 。\nBob 获胜，因为 9 + 3 + 2 + 9 = 5 + 9 + 2 + 7 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= num.length <= 10<sup>5</sup></code></li>\n\t<li><code>num.length</code> 是 <strong>偶数</strong> 。</li>\n\t<li><code>num</code> 只包含数字字符和 <code>'?'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1928规定时间内到达终点的最小花费",
        "hardRate": "HARD",
        "passRate": "45.80%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/solution",
        "problemsDesc": "<p>一个国家有 <code>n</code> 个城市，城市编号为 <code>0</code> 到 <code>n - 1</code> ，题目保证 <strong>所有城市</strong> 都由双向道路 <b>连接在一起</b> 。道路由二维整数数组 <code>edges</code> 表示，其中 <code>edges[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>]</code> 表示城市 <code>x<sub>i</sub></code> 和 <code>y<sub>i</sub></code> 之间有一条双向道路，耗费时间为 <code>time<sub>i</sub></code> 分钟。两个城市之间可能会有多条耗费时间不同的道路，但是不会有道路两头连接着同一座城市。</p>\n\n<p>每次经过一个城市时，你需要付通行费。通行费用一个长度为 <code>n</code> 且下标从 <strong>0</strong> 开始的整数数组 <code>passingFees</code> 表示，其中 <code>passingFees[j]</code> 是你经过城市 <code>j</code> 需要支付的费用。</p>\n\n<p>一开始，你在城市 <code>0</code> ，你想要在 <code>maxTime</code> <strong>分钟以内</strong> （包含 <code>maxTime</code> 分钟）到达城市 <code>n - 1</code> 。旅行的 <strong>费用</strong> 为你经过的所有城市 <strong>通行费之和</strong> （<strong>包括</strong> 起点和终点城市的通行费）。</p>\n\n<p>给你 <code>maxTime</code>，<code>edges</code> 和 <code>passingFees</code> ，请你返回完成旅行的 <strong>最小费用</strong> ，如果无法在 <code>maxTime</code> 分钟以内完成旅行，请你返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/leetgraph1-1.png\" style=\"width: 371px; height: 171px;\" /></p>\n\n<pre>\n<b>输入：</b>maxTime = 30, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n<b>输出：</b>11\n<b>解释：</b>最优路径为 0 -> 1 -> 2 -> 5 ，总共需要耗费 30 分钟，需要支付 11 的通行费。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/copy-of-leetgraph1-1.png\" style=\"width: 371px; height: 171px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>maxTime = 29, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n<b>输出：</b>48\n<b>解释：</b>最优路径为 0 -> 3 -> 4 -> 5 ，总共需要耗费 26 分钟，需要支付 48 的通行费。\n你不能选择路径 0 -> 1 -> 2 -> 5 ，因为这条路径耗费的时间太长。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>maxTime = 25, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n<b>输出：</b>-1\n<b>解释：</b>无法在 25 分钟以内从城市 0 到达城市 5 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= maxTime <= 1000</code></li>\n\t<li><code>n == passingFees.length</code></li>\n\t<li><code>2 <= n <= 1000</code></li>\n\t<li><code>n - 1 <= edges.length <= 1000</code></li>\n\t<li><code>0 <= x<sub>i</sub>, y<sub>i</sub> <= n - 1</code></li>\n\t<li><code>1 <= time<sub>i</sub> <= 1000</code></li>\n\t<li><code>1 <= passingFees[j] <= 1000</code> </li>\n\t<li>图中两个节点之间可能有多条路径。</li>\n\t<li>图中不含有自环。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1929数组串联",
        "hardRate": "EASY",
        "passRate": "86.14%",
        "problemsUrl": "https://leetcode.cn/problems/concatenation-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/concatenation-of-array/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 。请你构建一个长度为 <code>2n</code> 的答案数组 <code>ans</code> ，数组下标<strong> 从 0 开始计数 </strong>，对于所有 <code>0 <= i < n</code> 的 <code>i</code> ，满足下述所有要求：</p>\n\n<ul>\n\t<li><code>ans[i] == nums[i]</code></li>\n\t<li><code>ans[i + n] == nums[i]</code></li>\n</ul>\n\n<p>具体而言，<code>ans</code> 由两个 <code>nums</code> 数组 <strong>串联</strong> 形成。</p>\n\n<p>返回数组<em> </em><code>ans</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1]\n<strong>输出：</strong>[1,2,1,1,2,1]\n<strong>解释：</strong>数组 ans 按下述方式形成：\n- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]\n- ans = [1,2,1,1,2,1]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,2,1]\n<strong>输出：</strong>[1,3,2,1,1,3,2,1]\n<strong>解释：</strong>数组 ans 按下述方式形成：\n- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]\n- ans = [1,3,2,1,1,3,2,1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 <= n <= 1000</code></li>\n\t<li><code>1 <= nums[i] <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1930长度为 3 的不同回文子序列",
        "hardRate": "MEDIUM",
        "passRate": "51.62%",
        "problemsUrl": "https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，返回 <code>s</code> 中 <strong>长度为 3 </strong>的<strong>不同回文子序列</strong> 的个数。</p>\n\n<p>即便存在多种方法来构建相同的子序列，但相同的子序列只计数一次。</p>\n\n<p><strong>回文</strong> 是正着读和反着读一样的字符串。</p>\n\n<p><strong>子序列</strong> 是由原字符串删除其中部分字符（也可以不删除）且不改变剩余字符之间相对顺序形成的一个新字符串。</p>\n\n<ul>\n\t<li>例如，<code>\"ace\"</code> 是 <code>\"<strong><em>a</em></strong>b<strong><em>c</em></strong>d<strong><em>e</em></strong>\"</code> 的一个子序列。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aabca\"\n<strong>输出：</strong>3\n<strong>解释：</strong>长度为 3 的 3 个回文子序列分别是：\n- \"aba\" (\"<strong><em>a</em></strong>a<strong><em>b</em></strong>c<strong><em>a</em></strong>\" 的子序列)\n- \"aaa\" (\"<strong><em>aa</em></strong>bc<strong><em>a</em></strong>\" 的子序列)\n- \"aca\" (\"<strong><em>a</em></strong>ab<strong><em>ca</em></strong>\" 的子序列)\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"adc\"\n<strong>输出：</strong>0\n<strong>解释：</strong>\"adc\" 不存在长度为 3 的回文子序列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"bbcbaba\"\n<strong>输出：</strong>4\n<strong>解释：</strong>长度为 3 的 4 个回文子序列分别是：\n- \"bbb\" (\"<strong><em>bb</em></strong>c<strong><em>b</em></strong>aba\" 的子序列)\n- \"bcb\" (\"<strong><em>b</em></strong>b<strong><em>cb</em></strong>aba\" 的子序列)\n- \"bab\" (\"<strong><em>b</em></strong>bcb<strong><em>ab</em></strong>a\" 的子序列)\n- \"aba\" (\"bbcb<strong><em>aba</em></strong>\" 的子序列)\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 <= s.length <= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1931用三种不同颜色为网格涂色",
        "hardRate": "HARD",
        "passRate": "59.32%",
        "problemsUrl": "https://leetcode.cn/problems/painting-a-grid-with-three-different-colors/",
        "solutionsUrl": "https://leetcode.cn/problems/painting-a-grid-with-three-different-colors/solution",
        "problemsDesc": "<p>给你两个整数 <code>m</code> 和 <code>n</code> 。构造一个 <code>m x n</code> 的网格，其中每个单元格最开始是白色。请你用 <strong>红、绿、蓝</strong> 三种颜色为每个单元格涂色。所有单元格都需要被涂色。</p>\n\n<p>涂色方案需要满足：<strong>不存在相邻两个单元格颜色相同的情况</strong> 。返回网格涂色的方法数。因为答案可能非常大， 返回 <strong>对 </strong><code>10<sup>9</sup> + 7</code><strong> 取余</strong> 的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/22/colorthegrid.png\" style=\"width: 200px; height: 50px;\" />\n<pre>\n<strong>输入：</strong>m = 1, n = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>如上图所示，存在三种可能的涂色方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/22/copy-of-colorthegrid.png\" style=\"width: 321px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>m = 1, n = 2\n<strong>输出：</strong>6\n<strong>解释：</strong>如上图所示，存在六种可能的涂色方案。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 5, n = 5\n<strong>输出：</strong>580986\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= m <= 5</code></li>\n\t<li><code>1 <= n <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1932合并多棵二叉搜索树",
        "hardRate": "HARD",
        "passRate": "33.28%",
        "problemsUrl": "https://leetcode.cn/problems/merge-bsts-to-create-single-bst/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-bsts-to-create-single-bst/solution",
        "problemsDesc": "<p>给你 <code>n</code> 个 <strong>二叉搜索树的根节点</strong> ，存储在数组 <code>trees</code> 中（<strong>下标从 0 开始</strong>），对应 <code>n</code> 棵不同的二叉搜索树。<code>trees</code> 中的每棵二叉搜索树 <strong>最多有 3 个节点</strong> ，且不存在值相同的两个根节点。在一步操作中，将会完成下述步骤：</p>\n\n<ul>\n\t<li>选择两个 <strong>不同的</strong> 下标 <code>i</code> 和 <code>j</code> ，要求满足在&nbsp;<code>trees[i]</code> 中的某个 <strong>叶节点</strong> 的值等于&nbsp;<code>trees[j]</code> 的 <strong>根节点的值</strong> 。</li>\n\t<li>用&nbsp;<code>trees[j]</code> 替换 <code>trees[i]</code> 中的那个叶节点。</li>\n\t<li>从 <code>trees</code> 中移除 <code>trees[j]</code> 。</li>\n</ul>\n\n<p>如果在执行 <code>n - 1</code> 次操作后，能形成一棵有效的二叉搜索树，则返回结果二叉树的 <strong>根节点</strong> ；如果无法构造一棵有效的二叉搜索树<em>，</em>返回<em> </em><code>null</code> 。</p>\n\n<p>二叉搜索树是一种二叉树，且树中每个节点均满足下述属性：</p>\n\n<ul>\n\t<li>任意节点的左子树中的值都 <strong>严格小于</strong>&nbsp;此节点的值。</li>\n\t<li>任意节点的右子树中的值都 <strong>严格大于</strong>&nbsp;此节点的值。</li>\n</ul>\n\n<p>叶节点是不含子节点的节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/08/d1.png\" />\n<pre>\n<strong>输入：</strong>trees = [[2,1],[3,2,5],[5,4]]\n<strong>输出：</strong>[3,2,5,1,null,4]\n<strong>解释：</strong>\n第一步操作中，选出 i=1 和 j=0 ，并将 trees[0] 合并到 trees[1] 中。\n删除 trees[0] ，trees = [[3,2,5,1],[5,4]] 。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/24/diagram.png\" />\n在第二步操作中，选出 i=0 和 j=1 ，将 trees[1] 合并到 trees[0] 中。\n删除 trees[1] ，trees = [[3,2,5,1,null,4]] 。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/24/diagram-2.png\" />\n结果树如上图所示，为一棵有效的二叉搜索树，所以返回该树的根节点。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/08/d2.png\" />\n<pre>\n<strong>输入：</strong>trees = [[5,3,8],[3,2,6]]\n<strong>输出：</strong>[]\n<strong>解释：</strong>\n选出 i=0 和 j=1 ，然后将 trees[1] 合并到 trees[0] 中。\n删除 trees[1] ，trees = [[5,3,8,2,6]] 。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/24/diagram-3.png\" />\n结果树如上图所示。仅能执行一次有效的操作，但结果树不是一棵有效的二叉搜索树，所以返回 null 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/08/d3.png\" />\n<pre>\n<strong>输入：</strong>trees = [[5,4],[3]]\n<strong>输出：</strong>[]\n<strong>解释：</strong>无法执行任何操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == trees.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li>每棵树中节点数目在范围 <code>[1, 3]</code> 内。</li>\n\t<li>输入数据的每个节点可能有子节点但不存在子节点的子节点</li>\n\t<li><code>trees</code> 中不存在两棵树根节点值相同的情况。</li>\n\t<li>输入中的所有树都是 <strong>有效的二叉树搜索树</strong> 。</li>\n\t<li><code>1 &lt;= TreeNode.val &lt;= 5 * 10<sup>4</sup></code>.</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1933判断字符串是否可分解为值均等的子串",
        "hardRate": "EASY",
        "passRate": "49.31%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-string-is-decomposable-into-value-equal-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-string-is-decomposable-into-value-equal-substrings/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1934确认率",
        "hardRate": "MEDIUM",
        "passRate": "67.29%",
        "problemsUrl": "https://leetcode.cn/problems/confirmation-rate/",
        "solutionsUrl": "https://leetcode.cn/problems/confirmation-rate/solution",
        "problemsDesc": "<p>表: <code>Signups</code></p>\n\n<pre>\n+----------------+----------+\n| Column Name    | Type     |\n+----------------+----------+\n| user_id        | int      |\n| time_stamp     | datetime |\n+----------------+----------+\nUser_id是该表的主键。\n每一行都包含ID为user_id的用户的注册时间信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>表: <code>Confirmations</code></p>\n\n<pre>\n+----------------+----------+\n| Column Name    | Type     |\n+----------------+----------+\n| user_id        | int      |\n| time_stamp     | datetime |\n| action         | ENUM     |\n+----------------+----------+\n(user_id, time_stamp)是该表的主键。\nuser_id是一个引用到注册表的外键。\naction是类型为('confirmed'， 'timeout')的ENUM\n该表的每一行都表示ID为user_id的用户在time_stamp请求了一条确认消息，该确认消息要么被确认('confirmed')，要么被过期('timeout')。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>用户的 <strong>确认率</strong>&nbsp;是 <code>'confirmed'</code>&nbsp;消息的数量除以请求的确认消息的总数。没有请求任何确认消息的用户的确认率为&nbsp;<code>0</code> 。确认率四舍五入到 <strong>小数点后两位</strong> 。</p>\n\n<p>编写一个SQL查询来查找每个用户的 确认率 。<br />\n<br />\n以 任意顺序&nbsp;返回结果表。<br />\n<br />\n查询结果格式如下所示。<br />\n<br />\n<strong>示例1:</strong></p>\n\n<pre>\n<b>输入：</b>\nSignups 表:\n+---------+---------------------+\n| user_id | time_stamp          |\n+---------+---------------------+\n| 3       | 2020-03-21 10:16:13 |\n| 7       | 2020-01-04 13:57:59 |\n| 2       | 2020-07-29 23:09:44 |\n| 6       | 2020-12-09 10:39:37 |\n+---------+---------------------+\nConfirmations 表:\n+---------+---------------------+-----------+\n| user_id | time_stamp          | action    |\n+---------+---------------------+-----------+\n| 3       | 2021-01-06 03:30:46 | timeout   |\n| 3       | 2021-07-14 14:00:00 | timeout   |\n| 7       | 2021-06-12 11:57:29 | confirmed |\n| 7       | 2021-06-13 12:58:28 | confirmed |\n| 7       | 2021-06-14 13:59:27 | confirmed |\n| 2       | 2021-01-22 00:00:00 | confirmed |\n| 2       | 2021-02-28 23:59:59 | timeout   |\n+---------+---------------------+-----------+\n<strong>输出:</strong> \n+---------+-------------------+\n| user_id | confirmation_rate |\n+---------+-------------------+\n| 6       | 0.00              |\n| 3       | 0.00              |\n| 7       | 1.00              |\n| 2       | 0.50              |\n+---------+-------------------+\n<strong>解释:\n</strong>用户 6 没有请求任何确认消息。确认率为 0。\n用户 3 进行了 2 次请求，都超时了。确认率为 0。\n用户 7 提出了 3 个请求，所有请求都得到了确认。确认率为 1。\n用户 2 做了 2 个请求，其中一个被确认，另一个超时。确认率为 1 / 2 = 0.5。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1935可以输入的最大单词数",
        "hardRate": "EASY",
        "passRate": "70.85%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-words-you-can-type/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-words-you-can-type/solution",
        "problemsDesc": "<p>键盘出现了一些故障，有些字母键无法正常工作。而键盘上所有其他键都能够正常工作。</p>\n\n<p>给你一个由若干单词组成的字符串 <code>text</code> ，单词间由单个空格组成（不含前导和尾随空格）；另有一个字符串 <code>brokenLetters</code> ，由所有已损坏的不同字母键组成，返回你可以使用此键盘完全输入的 <code>text</code> 中单词的数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>text = \"hello world\", brokenLetters = \"ad\"\n<strong>输出：</strong>1\n<strong>解释：</strong>无法输入 \"world\" ，因为字母键 'd' 已损坏。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>text = \"leet code\", brokenLetters = \"lt\"\n<strong>输出：</strong>1\n<strong>解释：</strong>无法输入 \"leet\" ，因为字母键 'l' 和 't' 已损坏。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>text = \"leet code\", brokenLetters = \"e\"\n<strong>输出：</strong>0\n<strong>解释：</strong>无法输入任何单词，因为字母键 'e' 已损坏。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= brokenLetters.length &lt;= 26</code></li>\n\t<li><code>text</code> 由若干用单个空格分隔的单词组成，且不含任何前导和尾随空格</li>\n\t<li>每个单词仅由小写英文字母组成</li>\n\t<li><code>brokenLetters</code> 由 <strong>互不相同</strong> 的小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1936新增的最少台阶数",
        "hardRate": "MEDIUM",
        "passRate": "46.24%",
        "problemsUrl": "https://leetcode.cn/problems/add-minimum-number-of-rungs/",
        "solutionsUrl": "https://leetcode.cn/problems/add-minimum-number-of-rungs/solution",
        "problemsDesc": "<p>给你一个 <strong>严格递增</strong> 的整数数组 <code>rungs</code> ，用于表示梯子上每一台阶的 <strong>高度</strong> 。当前你正站在高度为 <code>0</code> 的地板上，并打算爬到最后一个台阶。</p>\n\n<p>另给你一个整数 <code>dist</code> 。每次移动中，你可以到达下一个距离你当前位置（地板或台阶）<strong>不超过</strong> <code>dist</code> 高度的台阶。当然，你也可以在任何正 <strong>整数</strong> 高度处插入尚不存在的新台阶。</p>\n\n<p>返回爬到最后一阶时必须添加到梯子上的 <strong>最少</strong> 台阶数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rungs = [1,3,5,10], dist = 2\n<strong>输出：</strong>2\n<strong>解释：\n</strong>现在无法到达最后一阶。\n在高度为 7 和 8 的位置增设新的台阶，以爬上梯子。 \n梯子在高度为 [1,3,5,<strong><em>7</em></strong>,<strong><em>8</em></strong>,10] 的位置上有台阶。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rungs = [3,6,8,10], dist = 3\n<strong>输出：</strong>0\n<strong>解释：</strong>\n这个梯子无需增设新台阶也可以爬上去。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>rungs = [3,4,6,7], dist = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>\n现在无法从地板到达梯子的第一阶。 \n在高度为 1 的位置增设新的台阶，以爬上梯子。 \n梯子在高度为 [<strong><em>1</em></strong>,3,4,6,7] 的位置上有台阶。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>rungs = [5], dist = 10\n<strong>输出：</strong>0\n<strong>解释：</strong>这个梯子无需增设新台阶也可以爬上去。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= rungs.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= rungs[i] <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= dist <= 10<sup>9</sup></code></li>\n\t<li><code>rungs</code> <strong>严格递增</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1937扣分后的最大得分",
        "hardRate": "MEDIUM",
        "passRate": "28.91%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-points-with-cost/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-points-with-cost/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的整数矩阵 <code>points</code> （下标从 <strong>0</strong> 开始）。一开始你的得分为 <code>0</code> ，你想最大化从矩阵中得到的分数。</p>\n\n<p>你的得分方式为：<strong>每一行</strong> 中选取一个格子，选中坐标为 <code>(r, c)</code> 的格子会给你的总得分 <strong>增加</strong> <code>points[r][c]</code> 。</p>\n\n<p>然而，相邻行之间被选中的格子如果隔得太远，你会失去一些得分。对于相邻行 <code>r</code> 和 <code>r + 1</code> （其中 <code>0 <= r < m - 1</code>），选中坐标为 <code>(r, c<sub>1</sub>)</code> 和 <code>(r + 1, c<sub>2</sub>)</code> 的格子，你的总得分 <b>减少</b> <code>abs(c<sub>1</sub> - c<sub>2</sub>)</code> 。</p>\n\n<p>请你返回你能得到的 <strong>最大</strong> 得分。</p>\n\n<p><code>abs(x)</code> 定义为：</p>\n\n<ul>\n\t<li>如果 <code>x >= 0</code> ，那么值为 <code>x</code> 。</li>\n\t<li>如果 <code>x < 0</code> ，那么值为 <code>-x</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-40-26-diagram-drawio-diagrams-net.png\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<b>输入：</b>points = [[1,2,3],[1,5,1],[3,1,1]]\n<b>输出：</b>9\n<strong>解释：</strong>\n蓝色格子是最优方案选中的格子，坐标分别为 (0, 2)，(1, 1) 和 (2, 0) 。\n你的总得分增加 3 + 5 + 3 = 11 。\n但是你的总得分需要扣除 abs(2 - 1) + abs(1 - 0) = 2 。\n你的最终得分为 11 - 2 = 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-42-14-diagram-drawio-diagrams-net.png\" style=\"width: 200px; height: 299px;\" />\n<pre>\n<b>输入：</b>points = [[1,5],[2,3],[4,2]]\n<b>输出：</b>11\n<strong>解释：</strong>\n蓝色格子是最优方案选中的格子，坐标分别为 (0, 1)，(1, 1) 和 (2, 0) 。\n你的总得分增加 5 + 3 + 4 = 12 。\n但是你的总得分需要扣除 abs(1 - 1) + abs(1 - 0) = 1 。\n你的最终得分为 12 - 1 = 11 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == points.length</code></li>\n\t<li><code>n == points[r].length</code></li>\n\t<li><code>1 <= m, n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= m * n <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= points[r][c] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1938查询最大基因差",
        "hardRate": "HARD",
        "passRate": "40.19%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-genetic-difference-query/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-genetic-difference-query/solution",
        "problemsDesc": "<p>给你一棵 <code>n</code> 个节点的有根树，节点编号从 <code>0</code> 到 <code>n - 1</code> 。每个节点的编号表示这个节点的 <strong>独一无二的基因值</strong> （也就是说节点 <code>x</code> 的基因值为 <code>x</code>）。两个基因值的 <strong>基因差</strong> 是两者的 <strong>异或和</strong> 。给你整数数组 <code>parents</code> ，其中 <code>parents[i]</code> 是节点 <code>i</code> 的父节点。如果节点 <code>x</code> 是树的 <strong>根</strong> ，那么 <code>parents[x] == -1</code> 。</p>\n\n<p>给你查询数组 <code>queries</code> ，其中 <code>queries[i] = [node<sub>i</sub>, val<sub>i</sub>]</code> 。对于查询 <code>i</code> ，请你找到 <code>val<sub>i</sub></code> 和 <code>p<sub>i</sub></code> 的 <strong>最大基因差</strong> ，其中 <code>p<sub>i</sub></code> 是节点 <code>node<sub>i</sub></code> 到根之间的任意节点（包含 <code>node<sub>i</sub></code> 和根节点）。更正式的，你想要最大化 <code>val<sub>i</sub> XOR p<sub>i</sub></code><sub> </sub>。</p>\n\n<p>请你返回数组<em> </em><code>ans</code> ，其中 <code>ans[i]</code> 是第 <code>i</code> 个查询的答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/29/c1.png\" style=\"width: 118px; height: 163px;\">\n<pre><b>输入：</b>parents = [-1,0,1,1], queries = [[0,2],[3,2],[2,5]]\n<b>输出：</b>[2,3,7]\n<strong>解释：</strong>查询数组处理如下：\n- [0,2]：最大基因差的对应节点为 0 ，基因差为 2 XOR 0 = 2 。\n- [3,2]：最大基因差的对应节点为 1 ，基因差为 2 XOR 1 = 3 。\n- [2,5]：最大基因差的对应节点为 2 ，基因差为 5 XOR 2 = 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/29/c2.png\" style=\"width: 256px; height: 221px;\">\n<pre><b>输入：</b>parents = [3,7,-1,2,0,7,0,2], queries = [[4,6],[1,15],[0,5]]\n<b>输出：</b>[6,14,7]\n<strong>解释：</strong>查询数组处理如下：\n- [4,6]：最大基因差的对应节点为 0 ，基因差为 6 XOR 0 = 6 。\n- [1,15]：最大基因差的对应节点为 1 ，基因差为 15 XOR 1 = 14 。\n- [0,5]：最大基因差的对应节点为 2 ，基因差为 5 XOR 2 = 7 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= parents.length &lt;= 10<sup>5</sup></code></li>\n\t<li>对于每个 <strong>不是</strong> 根节点的 <code>i</code> ，有 <code>0 &lt;= parents[i] &lt;= parents.length - 1</code> 。</li>\n\t<li><code>parents[root] == -1</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= node<sub>i</sub> &lt;= parents.length - 1</code></li>\n\t<li><code>0 &lt;= val<sub>i</sub> &lt;= 2 * 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1939主动请求确认消息的用户",
        "hardRate": "EASY",
        "passRate": "59.70%",
        "problemsUrl": "https://leetcode.cn/problems/users-that-actively-request-confirmation-messages/",
        "solutionsUrl": "https://leetcode.cn/problems/users-that-actively-request-confirmation-messages/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1940排序数组之间的最长公共子序列",
        "hardRate": "MEDIUM",
        "passRate": "73.92%",
        "problemsUrl": "https://leetcode.cn/problems/longest-common-subsequence-between-sorted-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-common-subsequence-between-sorted-arrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1941检查是否所有字符出现次数相同",
        "hardRate": "EASY",
        "passRate": "73.56%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-all-characters-have-equal-number-of-occurrences/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-all-characters-have-equal-number-of-occurrences/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，如果 <code>s</code> 是一个 <strong>好</strong> 字符串，请你返回 <code>true</code> ，否则请返回 <code>false</code> 。</p>\n\n<p>如果 <code>s</code> 中出现过的 <strong>所有</strong> 字符的出现次数 <strong>相同</strong> ，那么我们称字符串 <code>s</code> 是 <strong>好</strong> 字符串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"abacbc\"\n<b>输出：</b>true\n<b>解释：</b>s 中出现过的字符为 'a'，'b' 和 'c' 。s 中所有字符均出现 2 次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"aaabb\"\n<b>输出：</b>false\n<b>解释：</b>s 中出现过的字符为 'a' 和 'b' 。\n'a' 出现了 3 次，'b' 出现了 2 次，两者出现次数不同。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1942最小未被占据椅子的编号",
        "hardRate": "MEDIUM",
        "passRate": "41.92%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-the-smallest-unoccupied-chair/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-the-smallest-unoccupied-chair/solution",
        "problemsDesc": "<p>有 <code>n</code> 个朋友在举办一个派对，这些朋友从 <code>0</code> 到 <code>n - 1</code> 编号。派对里有 <strong>无数</strong> 张椅子，编号为 <code>0</code> 到 <code>infinity</code> 。当一个朋友到达派对时，他会占据 <strong>编号最小</strong> 且未被占据的椅子。</p>\n\n<ul>\n\t<li>比方说，当一个朋友到达时，如果椅子 <code>0</code> ，<code>1</code> 和 <code>5</code> 被占据了，那么他会占据 <code>2</code> 号椅子。</li>\n</ul>\n\n<p>当一个朋友离开派对时，他的椅子会立刻变成未占据状态。如果同一时刻有另一个朋友到达，可以立即占据这张椅子。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>times</code> ，其中 <code>times[i] = [arrival<sub>i</sub>, leaving<sub>i</sub>]</code> 表示第 <code>i</code> 个朋友到达和离开的时刻，同时给你一个整数 <code>targetFriend</code> 。所有到达时间 <strong>互不相同</strong> 。</p>\n\n<p>请你返回编号为 <code>targetFriend</code> 的朋友占据的 <strong>椅子编号</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>times = [[1,4],[2,3],[4,6]], targetFriend = 1\n<b>输出：</b>1\n<b>解释：</b>\n- 朋友 0 时刻 1 到达，占据椅子 0 。\n- 朋友 1 时刻 2 到达，占据椅子 1 。\n- 朋友 1 时刻 3 离开，椅子 1 变成未占据。\n- 朋友 0 时刻 4 离开，椅子 0 变成未占据。\n- 朋友 2 时刻 4 到达，占据椅子 0 。\n朋友 1 占据椅子 1 ，所以返回 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>times = [[3,10],[1,5],[2,6]], targetFriend = 0\n<b>输出：</b>2\n<b>解释：</b>\n- 朋友 1 时刻 1 到达，占据椅子 0 。\n- 朋友 2 时刻 2 到达，占据椅子 1 。\n- 朋友 0 时刻 3 到达，占据椅子 2 。\n- 朋友 1 时刻 5 离开，椅子 0 变成未占据。\n- 朋友 2 时刻 6 离开，椅子 1 变成未占据。\n- 朋友 0 时刻 10 离开，椅子 2 变成未占据。\n朋友 0 占据椅子 2 ，所以返回 2 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == times.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>times[i].length == 2</code></li>\n\t<li><code>1 &lt;= arrival<sub>i</sub> &lt; leaving<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= targetFriend &lt;= n - 1</code></li>\n\t<li>每个 <code>arrival<sub>i</sub></code> 时刻 <strong>互不相同</strong> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1943描述绘画结果",
        "hardRate": "MEDIUM",
        "passRate": "43.86%",
        "problemsUrl": "https://leetcode.cn/problems/describe-the-painting/",
        "solutionsUrl": "https://leetcode.cn/problems/describe-the-painting/solution",
        "problemsDesc": "<p>给你一个细长的画，用数轴表示。这幅画由若干有重叠的线段表示，每个线段有 <strong>独一无二</strong>&nbsp;的颜色。给你二维整数数组&nbsp;<code>segments</code>&nbsp;，其中&nbsp;<code>segments[i] = [start<sub>i</sub>, end<sub>i</sub>, color<sub>i</sub>]</code>&nbsp;表示线段为&nbsp;<strong>半开区间</strong>&nbsp;<code>[start<sub>i</sub>, end<sub>i</sub>)</code> 且颜色为&nbsp;<code>color<sub>i</sub></code>&nbsp;。</p>\n\n<p>线段间重叠部分的颜色会被 <strong>混合</strong>&nbsp;。如果有两种或者更多颜色混合时，它们会形成一种新的颜色，用一个 <strong>集合</strong>&nbsp;表示这个混合颜色。</p>\n\n<ul>\n\t<li>比方说，如果颜色&nbsp;<code>2</code>&nbsp;，<code>4</code>&nbsp;和&nbsp;<code>6</code>&nbsp;被混合，那么结果颜色为&nbsp;<code>{2,4,6}</code>&nbsp;。</li>\n</ul>\n\n<p>为了简化题目，你不需要输出整个集合，只需要用集合中所有元素的 <strong>和</strong>&nbsp;来表示颜色集合。</p>\n\n<p>你想要用 <strong>最少数目</strong>&nbsp;不重叠 <strong>半开区间</strong>&nbsp;来 <b>表示</b>&nbsp;这幅混合颜色的画。这些线段可以用二维数组&nbsp;<code>painting</code>&nbsp;表示，其中 <code>painting[j] = [left<sub>j</sub>, right<sub>j</sub>, mix<sub>j</sub>]</code>&nbsp;表示一个&nbsp;<strong>半开区间</strong><code>[left<sub>j</sub>, right<sub>j</sub>)</code>&nbsp;的颜色 <strong>和</strong>&nbsp;为&nbsp;<code>mix<sub>j</sub></code>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，这幅画由&nbsp;<code>segments = [[1,4,5],[1,7,7]]</code>&nbsp;组成，那么它可以表示为&nbsp;<code>painting = [[1,4,12],[4,7,7]]</code>&nbsp;，因为：\n\n\t<ul>\n\t\t<li><code>[1,4)</code>&nbsp;由颜色&nbsp;<code>{5,7}</code>&nbsp;组成（和为&nbsp;<code>12</code>），分别来自第一个线段和第二个线段。</li>\n\t\t<li><code>[4,7)</code>&nbsp;由颜色 <code>{7}</code>&nbsp;组成，来自第二个线段。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回二维数组&nbsp;<code>painting</code>&nbsp;，它表示最终绘画的结果（<strong>没有</strong>&nbsp;被涂色的部分不出现在结果中）。你可以按 <strong>任意顺序</strong> 返回最终数组的结果。</p>\n\n<p><strong>半开区间&nbsp;</strong><code>[a, b)</code>&nbsp;是数轴上点&nbsp;<code>a</code> 和点&nbsp;<code>b</code>&nbsp;之间的部分，<strong>包含 </strong>点&nbsp;<code>a</code>&nbsp;且 <strong>不包含</strong>&nbsp;点&nbsp;<code>b</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/18/1.png\" style=\"width: 529px; height: 241px;\" />\n<pre>\n<b>输入：</b>segments = [[1,4,5],[4,7,7],[1,7,9]]\n<b>输出：</b>[[1,4,14],[4,7,16]]\n<strong>解释：</strong>绘画结果可以表示为：\n- [1,4) 颜色为 {5,9} （和为 14），分别来自第一和第二个线段。\n- [4,7) 颜色为 {7,9} （和为 16），分别来自第二和第三个线段。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/18/2.png\" style=\"width: 532px; height: 219px;\" />\n<pre>\n<b>输入：</b>segments = [[1,7,9],[6,8,15],[8,10,7]]\n<b>输出：</b>[[1,6,9],[6,7,24],[7,8,15],[8,10,7]]\n<b>解释：</b>绘画结果可以以表示为：\n- [1,6) 颜色为 9 ，来自第一个线段。\n- [6,7) 颜色为 {9,15} （和为 24），来自第一和第二个线段。\n- [7,8) 颜色为 15 ，来自第二个线段。\n- [8,10) 颜色为 7 ，来自第三个线段。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/04/c1.png\" style=\"width: 529px; height: 289px;\" />\n<pre>\n<b>输入：</b>segments = [[1,4,5],[1,4,7],[4,7,1],[4,7,11]]\n<b>输出：</b>[[1,4,12],[4,7,12]]\n<strong>解释：</strong>绘画结果可以表示为：\n- [1,4) 颜色为 {5,7} （和为 12），分别来自第一和第二个线段。\n- [4,7) 颜色为 {1,11} （和为 12），分别来自第三和第四个线段。\n注意，只返回一个单独的线段 [1,7) 是不正确的，因为混合颜色的集合不相同。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= segments.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>segments[i].length == 3</code></li>\n\t<li><code>1 &lt;= start<sub>i</sub> &lt; end<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= color<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li>每种颜色&nbsp;<code>color<sub>i</sub></code>&nbsp;互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1944队列中可以看到的人数",
        "hardRate": "HARD",
        "passRate": "63.29%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-visible-people-in-a-queue/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-visible-people-in-a-queue/solution",
        "problemsDesc": "<p>有&nbsp;<code>n</code>&nbsp;个人排成一个队列，<strong>从左到右</strong>&nbsp;编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。给你以一个整数数组&nbsp;<code>heights</code>&nbsp;，每个整数 <strong>互不相同</strong>，<code>heights[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个人的高度。</p>\n\n<p>一个人能 <strong>看到</strong> 他右边另一个人的条件是这两人之间的所有人都比他们两人 <strong>矮</strong>&nbsp;。更正式的，第&nbsp;<code>i</code>&nbsp;个人能看到第&nbsp;<code>j</code>&nbsp;个人的条件是&nbsp;<code>i &lt; j</code>&nbsp;且&nbsp;<code>min(heights[i], heights[j]) &gt; max(heights[i+1], heights[i+2], ..., heights[j-1])</code>&nbsp;。</p>\n\n<p>请你返回一个长度为 <code>n</code>&nbsp;的数组<em>&nbsp;</em><code>answer</code><em>&nbsp;</em>，其中<em>&nbsp;</em><code>answer[i]</code><em>&nbsp;</em>是第&nbsp;<code>i</code>&nbsp;个人在他右侧队列中能&nbsp;<strong>看到</strong>&nbsp;的&nbsp;<strong>人数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/29/queue-plane.jpg\" style=\"width: 600px; height: 247px;\" /></p>\n\n<pre>\n<b>输入：</b>heights = [10,6,8,5,11,9]\n<b>输出：</b>[3,1,2,1,1,0]\n<strong>解释：</strong>\n第 0 个人能看到编号为 1 ，2 和 4 的人。\n第 1 个人能看到编号为 2 的人。\n第 2 个人能看到编号为 3 和 4 的人。\n第 3 个人能看到编号为 4 的人。\n第 4 个人能看到编号为 5 的人。\n第 5 个人谁也看不到因为他右边没人。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>heights = [5,1,2,3,10]\n<b>输出：</b>[4,1,1,1,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == heights.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= heights[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>heights</code>&nbsp;中所有数 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1945字符串转化后的各位数字之和",
        "hardRate": "EASY",
        "passRate": "70.42%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-digits-of-string-after-convert/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-digits-of-string-after-convert/solution",
        "problemsDesc": "<p>给你一个由小写字母组成的字符串 <code>s</code> ，以及一个整数 <code>k</code> 。</p>\n\n<p>首先，用字母在字母表中的位置替换该字母，将 <code>s</code> <strong>转化</strong> 为一个整数（也就是，<code>'a'</code> 用 <code>1</code> 替换，<code>'b'</code> 用 <code>2</code> 替换，... <code>'z'</code> 用 <code>26</code> 替换）。接着，将整数 <strong>转换</strong> 为其 <strong>各位数字之和</strong> 。共重复 <strong>转换</strong> 操作 <strong><code>k</code> 次</strong> 。</p>\n\n<p>例如，如果 <code>s = \"zbax\"</code> 且 <code>k = 2</code> ，那么执行下述步骤后得到的结果是整数 <code>8</code> ：</p>\n\n<ul>\n\t<li><strong>转化：</strong><code>\"zbax\" ➝ \"(26)(2)(1)(24)\" ➝ \"262124\" ➝ 262124</code></li>\n\t<li><strong>转换 #1</strong>：<code>262124&nbsp;➝ 2 + 6 + 2 + 1 + 2 + 4&nbsp;➝ 17</code></li>\n\t<li><strong>转换 #2</strong>：<code>17 ➝ 1 + 7 ➝ 8</code></li>\n</ul>\n\n<p>返回执行上述操作后得到的结果整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"iiii\", k = 1\n<strong>输出：</strong>36\n<strong>解释：</strong>操作如下：\n- 转化：\"iiii\" ➝ \"(9)(9)(9)(9)\" ➝ \"9999\" ➝ 9999\n- 转换 #1：9999 ➝ 9 + 9 + 9 + 9 ➝ 36\n因此，结果整数为 36 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"leetcode\", k = 2\n<strong>输出：</strong>6\n<strong>解释：</strong>操作如下：\n- 转化：\"leetcode\" ➝ \"(12)(5)(5)(20)(3)(15)(4)(5)\" ➝ \"12552031545\" ➝ 12552031545\n- 转换 #1：12552031545 ➝ 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 ➝ 33\n- 转换 #2：33 ➝ 3 + 3 ➝ 6\n因此，结果整数为 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= k &lt;= 10</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1946子字符串突变后可能得到的最大整数",
        "hardRate": "MEDIUM",
        "passRate": "32.23%",
        "problemsUrl": "https://leetcode.cn/problems/largest-number-after-mutating-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-number-after-mutating-substring/solution",
        "problemsDesc": "<p>给你一个字符串 <code>num</code> ，该字符串表示一个大整数。另给你一个长度为 <code>10</code> 且 <strong>下标从 0&nbsp; 开始</strong> 的整数数组 <code>change</code> ，该数组将 <code>0-9</code> 中的每个数字映射到另一个数字。更规范的说法是，数字 <code>d</code> 映射为数字 <code>change[d]</code> 。</p>\n\n<p>你可以选择 <strong>突变</strong>&nbsp; <code>num</code> 的任一子字符串。<strong>突变</strong> 子字符串意味着将每位数字 <code>num[i]</code> 替换为该数字在 <code>change</code> 中的映射（也就是说，将 <code>num[i]</code> 替换为 <code>change[num[i]]</code>）。</p>\n\n<p>请你找出在对 <code>num</code> 的任一子字符串执行突变操作（也可以不执行）后，可能得到的 <strong>最大整数</strong> ，并用字符串表示返回。</p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = \"<strong><em>1</em></strong>32\", change = [9,8,5,0,3,6,4,2,6,8]\n<strong>输出：</strong>\"<strong><em>8</em></strong>32\"\n<strong>解释：</strong>替换子字符串 \"1\"：\n- 1 映射为 change[1] = 8 。\n因此 \"<strong><em>1</em></strong>32\" 变为 \"<strong><em>8</em></strong>32\" 。\n\"832\" 是可以构造的最大整数，所以返回它的字符串表示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = \"<strong><em>021</em></strong>\", change = [9,4,3,5,7,2,1,9,0,6]\n<strong>输出：</strong>\"<strong><em>934</em></strong>\"\n<strong>解释：</strong>替换子字符串 \"021\"：\n- 0 映射为 change[0] = 9 。\n- 2 映射为 change[2] = 3 。\n- 1 映射为 change[1] = 4 。\n因此，\"<strong><em>021</em></strong>\" 变为 \"<strong><em>934</em></strong>\" 。\n\"934\" 是可以构造的最大整数，所以返回它的字符串表示。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = \"5\", change = [1,4,7,5,3,2,5,6,9,4]\n<strong>输出：</strong>\"5\"\n<strong>解释：</strong>\"5\" 已经是可以构造的最大整数，所以返回它的字符串表示。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>num</code> 仅由数字 <code>0-9</code> 组成</li>\n\t<li><code>change.length == 10</code></li>\n\t<li><code>0 &lt;= change[d] &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1947最大兼容性评分和",
        "hardRate": "MEDIUM",
        "passRate": "57.91%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-compatibility-score-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-compatibility-score-sum/solution",
        "problemsDesc": "<p>有一份由 <code>n</code> 个问题组成的调查问卷，每个问题的答案要么是 <code>0</code>（no，否），要么是 <code>1</code>（yes，是）。</p>\n\n<p>这份调查问卷被分发给 <code>m</code> 名学生和 <code>m</code> 名导师，学生和导师的编号都是从 <code>0</code> 到 <code>m - 1</code> 。学生的答案用一个二维整数数组 <code>students</code> 表示，其中 <code>students[i]</code> 是一个整数数组，包含第 <code>i</code> 名学生对调查问卷给出的答案（<strong>下标从 0 开始</strong>）。导师的答案用一个二维整数数组 <code>mentors</code> 表示，其中 <code>mentors[j]</code> 是一个整数数组，包含第 <code>j</code> 名导师对调查问卷给出的答案（<strong>下标从 0 开始</strong>）。</p>\n\n<p>每个学生都会被分配给 <strong>一名</strong> 导师，而每位导师也会分配到 <strong>一名</strong> 学生。配对的学生与导师之间的兼容性评分等于学生和导师答案相同的次数。</p>\n\n<ul>\n\t<li>例如，学生答案为<code>[1, <strong><em>0</em></strong>, <strong><em>1</em></strong>]</code> 而导师答案为 <code>[0, <strong><em>0</em></strong>, <strong><em>1</em></strong>]</code> ，那么他们的兼容性评分为 2 ，因为只有第二个和第三个答案相同。</li>\n</ul>\n\n<p>请你找出最优的学生与导师的配对方案，以 <strong>最大程度上</strong> 提高 <strong>兼容性评分和</strong> 。</p>\n\n<p>给你 <code>students</code> 和 <code>mentors</code> ，返回可以得到的<em> </em><strong>最大兼容性评分和</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>students = [[1,1,0],[1,0,1],[0,0,1]], mentors = [[1,0,0],[0,0,1],[1,1,0]]\n<strong>输出：</strong>8\n<strong>解释：</strong>按下述方式分配学生和导师：\n- 学生 0 分配给导师 2 ，兼容性评分为 3 。\n- 学生 1 分配给导师 0 ，兼容性评分为 2 。\n- 学生 2 分配给导师 1 ，兼容性评分为 3 。\n最大兼容性评分和为 3 + 2 + 3 = 8 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>students = [[0,0],[0,0],[0,0]], mentors = [[1,1],[1,1],[1,1]]\n<strong>输出：</strong>0\n<strong>解释：</strong>任意学生与导师配对的兼容性评分都是 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == students.length == mentors.length</code></li>\n\t<li><code>n == students[i].length == mentors[j].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 8</code></li>\n\t<li><code>students[i][k]</code> 为 <code>0</code> 或 <code>1</code></li>\n\t<li><code>mentors[j][k]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1948删除系统中的重复文件夹",
        "hardRate": "HARD",
        "passRate": "54.47%",
        "problemsUrl": "https://leetcode.cn/problems/delete-duplicate-folders-in-system/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-duplicate-folders-in-system/solution",
        "problemsDesc": "<p>由于一个漏洞，文件系统中存在许多重复文件夹。给你一个二维数组 <code>paths</code>，其中 <code>paths[i]</code> 是一个表示文件系统中第 <code>i</code> 个文件夹的绝对路径的数组。</p>\n\n<ul>\n\t<li>例如，<code>[\"one\", \"two\", \"three\"]</code> 表示路径 <code>\"/one/two/three\"</code> 。</li>\n</ul>\n\n<p>如果两个文件夹（不需要在同一层级）包含 <strong>非空且</strong><b>相同的&nbsp;</b>子文件夹&nbsp;<strong>集合</strong> 并具有相同的子文件夹结构，则认为这两个文件夹是相同文件夹。相同文件夹的根层级 <strong>不</strong> 需要相同。如果存在两个（或两个以上）<strong>相同</strong> 文件夹，则需要将这些文件夹和所有它们的子文件夹 <strong>标记</strong> 为待删除。</p>\n\n<ul>\n\t<li>例如，下面文件结构中的文件夹 <code>\"/a\"</code> 和 <code>\"/b\"</code> 相同。它们（以及它们的子文件夹）应该被 <strong>全部</strong> 标记为待删除：\n\n\t<ul>\n\t\t<li><code>/a</code></li>\n\t\t<li><code>/a/x</code></li>\n\t\t<li><code>/a/x/y</code></li>\n\t\t<li><code>/a/z</code></li>\n\t\t<li><code>/b</code></li>\n\t\t<li><code>/b/x</code></li>\n\t\t<li><code>/b/x/y</code></li>\n\t\t<li><code>/b/z</code></li>\n\t</ul>\n\t</li>\n\t<li>然而，如果文件结构中还包含路径 <code>\"/b/w\"</code> ，那么文件夹 <code>\"/a\"</code> 和 <code>\"/b\"</code> 就不相同。注意，即便添加了新的文件夹 <code>\"/b/w\"</code> ，仍然认为 <code>\"/a/x\"</code> 和 <code>\"/b/x\"</code> 相同。</li>\n</ul>\n\n<p>一旦所有的相同文件夹和它们的子文件夹都被标记为待删除，文件系统将会 <strong>删除</strong> 所有上述文件夹。文件系统只会执行一次删除操作。执行完这一次删除操作后，不会删除新出现的相同文件夹。</p>\n\n<p>返回二维数组<em> </em><code>ans</code> ，该数组包含删除所有标记文件夹之后剩余文件夹的路径。路径可以按 <strong>任意顺序</strong> 返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder1.jpg\" style=\"width: 200px; height: 218px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\"],[\"c\"],[\"d\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"a\"]]\n<strong>输出：</strong>[[\"d\"],[\"d\",\"a\"]]\n<strong>解释：</strong>文件结构如上所示。\n文件夹 \"/a\" 和 \"/c\"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 \"b\" 的空文件夹。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder2.jpg\" style=\"width: 200px; height: 355px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\"],[\"c\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"a\",\"b\",\"x\"],[\"a\",\"b\",\"x\",\"y\"],[\"w\"],[\"w\",\"y\"]]\n<strong>输出：</strong>[[\"c\"],[\"c\",\"b\"],[\"a\"],[\"a\",\"b\"]]\n<strong>解释：</strong>文件结构如上所示。\n文件夹 \"/a/b/x\" 和 \"/w\"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 \"y\" 的空文件夹。\n注意，文件夹 \"/a\" 和 \"/c\" 在删除后变为相同文件夹，但这两个文件夹不会被删除，因为删除只会进行一次，且它们没有在删除前被标记。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder3.jpg\" style=\"width: 200px; height: 201px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\",\"b\"],[\"c\",\"d\"],[\"c\"],[\"a\"]]\n<strong>输出：</strong>[[\"c\"],[\"c\",\"d\"],[\"a\"],[\"a\",\"b\"]]\n<strong>解释：</strong>文件系统中所有文件夹互不相同。\n注意，返回的数组可以按不同顺序返回文件夹路径，因为题目对顺序没有要求。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder4_.jpg\" style=\"width: 300px; height: 290px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\"],[\"a\",\"x\"],[\"a\",\"x\",\"y\"],[\"a\",\"z\"],[\"b\"],[\"b\",\"x\"],[\"b\",\"x\",\"y\"],[\"b\",\"z\"]]\n<strong>输出：</strong>[]\n<strong>解释：</strong>文件结构如上所示。\n文件夹 \"/a/x\" 和 \"/b/x\"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 \"y\" 的空文件夹。\n文件夹 \"/a\" 和 \"/b\"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含一个名为 \"z\" 的空文件夹以及上面提到的文件夹 \"x\" 。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder5_.jpg\" style=\"width: 300px; height: 282px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\"],[\"a\",\"x\"],[\"a\",\"x\",\"y\"],[\"a\",\"z\"],[\"b\"],[\"b\",\"x\"],[\"b\",\"x\",\"y\"],[\"b\",\"z\"],[\"b\",\"w\"]]\n<strong>输出：</strong>[[\"b\"],[\"b\",\"w\"],[\"b\",\"z\"],[\"a\"],[\"a\",\"z\"]]\n<strong>解释：</strong>本例与上例的结构基本相同，除了新增 \"/b/w\" 文件夹。\n文件夹 \"/a/x\" 和 \"/b/x\" 仍然会被标记，但 \"/a\" 和 \"/b\" 不再被标记，因为 \"/b\" 中有名为 \"w\" 的空文件夹而 \"/a\" 没有。\n注意，\"/a/z\" 和 \"/b/z\" 不会被标记，因为相同子文件夹的集合必须是非空集合，但这两个文件夹都是空的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= paths.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= paths[i].length &lt;= 500</code></li>\n\t<li><code>1 &lt;= paths[i][j].length &lt;= 10</code></li>\n\t<li><code>1 &lt;= sum(paths[i][j].length) &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>path[i][j]</code> 由小写英文字母组成</li>\n\t<li>不会存在两个路径都指向同一个文件夹的情况</li>\n\t<li>对于不在根层级的任意文件夹，其父文件夹也会包含在输入中</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1949坚定的友谊",
        "hardRate": "MEDIUM",
        "passRate": "52.14%",
        "problemsUrl": "https://leetcode.cn/problems/strong-friendship/",
        "solutionsUrl": "https://leetcode.cn/problems/strong-friendship/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1950所有子数组最小值中的最大值",
        "hardRate": "MEDIUM",
        "passRate": "51.33%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-of-minimum-values-in-all-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-of-minimum-values-in-all-subarrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1951查询具有最多共同关注者的所有两两结对组",
        "hardRate": "MEDIUM",
        "passRate": "65.24%",
        "problemsUrl": "https://leetcode.cn/problems/all-the-pairs-with-the-maximum-number-of-common-followers/",
        "solutionsUrl": "https://leetcode.cn/problems/all-the-pairs-with-the-maximum-number-of-common-followers/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1952三除数",
        "hardRate": "EASY",
        "passRate": "54.78%",
        "problemsUrl": "https://leetcode.cn/problems/three-divisors/",
        "solutionsUrl": "https://leetcode.cn/problems/three-divisors/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> 。如果 <code>n</code> <strong>恰好有三个正除数</strong> ，返回 <code>true</code><em> </em>；否则，返回<em> </em><code>false</code> 。</p>\n\n<p>如果存在整数 <code>k</code> ，满足 <code>n = k * m</code> ，那么整数 <code>m</code> 就是 <code>n</code> 的一个 <strong>除数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>false\n<strong>解释：</strong>2 只有两个除数：1 和 2 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 4\n<strong>输出：</strong>true\n<strong>解释：</strong>4 有三个除数：1、2 和 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1953你可以工作的最大周数",
        "hardRate": "MEDIUM",
        "passRate": "37.18%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-weeks-for-which-you-can-work/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-weeks-for-which-you-can-work/solution",
        "problemsDesc": "<p>给你&nbsp;<code>n</code> 个项目，编号从 <code>0</code> 到 <code>n - 1</code> 。同时给你一个整数数组 <code>milestones</code> ，其中每个 <code>milestones[i]</code> 表示第 <code>i</code> 个项目中的阶段任务数量。</p>\n\n<p>你可以按下面两个规则参与项目中的工作：</p>\n\n<ul>\n\t<li>每周，你将会完成 <strong>某一个</strong> 项目中的 <strong>恰好一个</strong>&nbsp;阶段任务。你每周都 <strong>必须</strong> 工作。</li>\n\t<li>在 <strong>连续的</strong> 两周中，你 <strong>不能</strong> 参与并完成同一个项目中的两个阶段任务。</li>\n</ul>\n\n<p>一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将&nbsp;<strong>停止工作</strong> 。注意，由于这些条件的限制，你可能无法完成所有阶段任务。</p>\n\n<p>返回在不违反上面规则的情况下你&nbsp;<strong>最多</strong>&nbsp;能工作多少周。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>milestones = [1,2,3]\n<strong>输出：</strong>6\n<strong>解释：</strong>一种可能的情形是：\n​​​​- 第 1 周，你参与并完成项目 0 中的一个阶段任务。\n- 第 2 周，你参与并完成项目 2 中的一个阶段任务。\n- 第 3 周，你参与并完成项目 1 中的一个阶段任务。\n- 第 4 周，你参与并完成项目 2 中的一个阶段任务。\n- 第 5 周，你参与并完成项目 1 中的一个阶段任务。\n- 第 6 周，你参与并完成项目 2 中的一个阶段任务。\n总周数是 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>milestones = [5,2,1]\n<strong>输出：</strong>7\n<strong>解释：</strong>一种可能的情形是：\n- 第 1 周，你参与并完成项目 0 中的一个阶段任务。\n- 第 2 周，你参与并完成项目 1 中的一个阶段任务。\n- 第 3 周，你参与并完成项目 0 中的一个阶段任务。\n- 第 4 周，你参与并完成项目 1 中的一个阶段任务。\n- 第 5 周，你参与并完成项目 0 中的一个阶段任务。\n- 第 6 周，你参与并完成项目 2 中的一个阶段任务。\n- 第 7 周，你参与并完成项目 0 中的一个阶段任务。\n总周数是 7 。\n注意，你不能在第 8 周参与完成项目 0 中的最后一个阶段任务，因为这会违反规则。\n因此，项目 0 中会有一个阶段任务维持未完成状态。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == milestones.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= milestones[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1954收集足够苹果的最小花园周长",
        "hardRate": "MEDIUM",
        "passRate": "49.69%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-garden-perimeter-to-collect-enough-apples/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-garden-perimeter-to-collect-enough-apples/solution",
        "problemsDesc": "<p>给你一个用无限二维网格表示的花园，<strong>每一个</strong>&nbsp;整数坐标处都有一棵苹果树。整数坐标&nbsp;<code>(i, j)</code>&nbsp;处的苹果树有 <code>|i| + |j|</code>&nbsp;个苹果。</p>\n\n<p>你将会买下正中心坐标是 <code>(0, 0)</code>&nbsp;的一块 <strong>正方形土地</strong>&nbsp;，且每条边都与两条坐标轴之一平行。</p>\n\n<p>给你一个整数&nbsp;<code>neededApples</code>&nbsp;，请你返回土地的&nbsp;<strong>最小周长</strong>&nbsp;，使得&nbsp;<strong>至少</strong>&nbsp;有<strong>&nbsp;</strong><code>neededApples</code>&nbsp;个苹果在土地&nbsp;<strong>里面或者边缘上</strong>。</p>\n\n<p><code>|x|</code>&nbsp;的值定义为：</p>\n\n<ul>\n\t<li>如果&nbsp;<code>x &gt;= 0</code>&nbsp;，那么值为&nbsp;<code>x</code></li>\n\t<li>如果&nbsp;<code>x &lt;&nbsp;0</code>&nbsp;，那么值为&nbsp;<code>-x</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://pic.leetcode-cn.com/1627790803-qcBKFw-image.png\" style=\"width: 442px; height: 449px;\" />\n<pre>\n<b>输入：</b>neededApples = 1\n<b>输出：</b>8\n<b>解释：</b>边长长度为 1 的正方形不包含任何苹果。\n但是边长为 2 的正方形包含 12 个苹果（如上图所示）。\n周长为 2 * 4 = 8 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>neededApples = 13\n<b>输出：</b>16\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>neededApples = 1000000000\n<b>输出：</b>5040\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= neededApples &lt;= 10<sup>15</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1955统计特殊子序列的数目",
        "hardRate": "HARD",
        "passRate": "52.50%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-special-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-special-subsequences/solution",
        "problemsDesc": "<p><strong>特殊序列</strong> 是由&nbsp;<strong>正整数</strong>&nbsp;个 <code>0</code>&nbsp;，紧接着&nbsp;<strong>正整数</strong>&nbsp;个 <code>1</code>&nbsp;，最后 <strong>正整数</strong>&nbsp;个 <code>2</code>&nbsp;组成的序列。</p>\n\n<ul>\n\t<li>比方说，<code>[0,1,2]</code> 和&nbsp;<code>[0,0,1,1,1,2]</code>&nbsp;是特殊序列。</li>\n\t<li>相反，<code>[2,1,0]</code>&nbsp;，<code>[1]</code>&nbsp;和&nbsp;<code>[0,1,2,0]</code>&nbsp;就不是特殊序列。</li>\n</ul>\n\n<p>给你一个数组&nbsp;<code>nums</code>&nbsp;（<strong>仅</strong>&nbsp;包含整数&nbsp;<code>0</code>，<code>1</code>&nbsp;和&nbsp;<code>2</code>），请你返回 <b>不同特殊子序列的数目</b>&nbsp;。由于答案可能很大，请你将它对&nbsp;<code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后返回。</p>\n\n<p>一个数组的 <strong>子序列</strong>&nbsp;是从原数组中删除零个或者若干个元素后，剩下元素不改变顺序得到的序列。如果两个子序列的 <strong>下标集合</strong>&nbsp;不同，那么这两个子序列是 <strong>不同的</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [0,1,2,2]\n<b>输出：</b>3\n<b>解释：</b>特殊子序列为 [<strong>0</strong>,<strong>1</strong>,<strong>2</strong>,2]，[<strong>0</strong>,<strong>1</strong>,2,<strong>2</strong>] 和 [<strong>0</strong>,<strong>1</strong>,<strong>2</strong>,<strong>2</strong>] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,2,0,0]\n<b>输出：</b>0\n<b>解释：</b>数组 [2,2,0,0] 中没有特殊子序列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [0,1,2,0,1,2]\n<b>输出：</b>7\n<b>解释：</b>特殊子序列包括：\n- [<strong>0</strong>,<strong>1</strong>,<strong>2</strong>,0,1,2]\n- [<strong>0</strong>,<strong>1</strong>,2,0,1,<strong>2</strong>]\n- [<strong>0</strong>,<strong>1</strong>,<strong>2</strong>,0,1,<strong>2</strong>]\n- [<strong>0</strong>,<strong>1</strong>,2,0,<strong>1</strong>,<strong>2</strong>]\n- [<strong>0</strong>,1,2,<strong>0</strong>,<strong>1</strong>,<strong>2</strong>]\n- [<strong>0</strong>,1,2,0,<strong>1</strong>,<strong>2</strong>]\n- [0,1,2,<strong>0</strong>,<strong>1</strong>,<strong>2</strong>]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1956感染 K 种病毒所需的最短时间",
        "hardRate": "HARD",
        "passRate": "38.04%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-for-k-virus-variants-to-spread/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-for-k-virus-variants-to-spread/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1957删除字符使字符串变好",
        "hardRate": "EASY",
        "passRate": "60.05%",
        "problemsUrl": "https://leetcode.cn/problems/delete-characters-to-make-fancy-string/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-characters-to-make-fancy-string/solution",
        "problemsDesc": "<p>一个字符串如果没有 <strong>三个连续</strong>&nbsp;相同字符，那么它就是一个 <strong>好字符串</strong>&nbsp;。</p>\n\n<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，请你从 <code>s</code>&nbsp;删除&nbsp;<strong>最少</strong>&nbsp;的字符，使它变成一个 <strong>好字符串</strong> 。</p>\n\n<p>请你返回删除后的字符串。题目数据保证答案总是 <strong>唯一的 </strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"le<strong>e</strong>etcode\"\n<b>输出：</b>\"leetcode\"\n<strong>解释：</strong>\n从第一组 'e' 里面删除一个 'e' ，得到 \"leetcode\" 。\n没有连续三个相同字符，所以返回 \"leetcode\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"<strong>a</strong>aab<strong>aa</strong>aa\"\n<b>输出：</b>\"aabaa\"\n<strong>解释：</strong>\n从第一组 'a' 里面删除一个 'a' ，得到 \"aabaaaa\" 。\n从第二组 'a' 里面删除两个 'a' ，得到 \"aabaa\" 。\n没有连续三个相同字符，所以返回 \"aabaa\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aab\"\n<b>输出：</b>\"aab\"\n<b>解释：</b>没有连续三个相同字符，所以返回 \"aab\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1958检查操作是否合法",
        "hardRate": "MEDIUM",
        "passRate": "44.76%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-move-is-legal/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-move-is-legal/solution",
        "problemsDesc": "<p>给你一个下标从&nbsp;<strong>0</strong>&nbsp;开始的&nbsp;<code>8 x 8</code> 网格&nbsp;<code>board</code>&nbsp;，其中&nbsp;<code>board[r][c]</code>&nbsp;表示游戏棋盘上的格子&nbsp;<code>(r, c)</code>&nbsp;。棋盘上空格用&nbsp;<code>'.'</code>&nbsp;表示，白色格子用&nbsp;<code>'W'</code>&nbsp;表示，黑色格子用&nbsp;<code>'B'</code>&nbsp;表示。</p>\n\n<p>游戏中每次操作步骤为：选择一个空格子，将它变成你正在执行的颜色（要么白色，要么黑色）。但是，<strong>合法 </strong>操作必须满足：涂色后这个格子是 <strong>好线段的一个端点</strong>&nbsp;（好线段可以是水平的，竖直的或者是对角线）。</p>\n\n<p><strong>好线段</strong>&nbsp;指的是一个包含 <strong>三个或者更多格子（包含端点格子）</strong>的线段，线段两个端点格子为 <strong>同一种颜色</strong>&nbsp;，且中间剩余格子的颜色都为 <strong>另一种颜色</strong>&nbsp;（线段上不能有任何空格子）。你可以在下图找到好线段的例子：</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/22/goodlines5.png\" style=\"width: 500px; height: 312px;\" />\n<p>给你两个整数&nbsp;<code>rMove</code> 和&nbsp;<code>cMove</code>&nbsp;以及一个字符&nbsp;<code>color</code>&nbsp;，表示你正在执行操作的颜色（白或者黑），如果将格子&nbsp;<code>(rMove, cMove)</code>&nbsp;变成颜色&nbsp;<code>color</code>&nbsp;后，是一个&nbsp;<strong>合法</strong>&nbsp;操作，那么返回&nbsp;<code>true</code>&nbsp;，如果不是合法操作返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/10/grid11.png\" style=\"width: 350px; height: 350px;\" /></p>\n\n<pre>\n<b>输入：</b>board = [[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\"W\",\"B\",\"B\",\".\",\"W\",\"W\",\"W\",\"B\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"]], rMove = 4, cMove = 3, color = \"B\"\n<b>输出：</b>true\n<b>解释：</b>'.'，'W' 和 'B' 分别用颜色蓝色，白色和黑色表示。格子 (rMove, cMove) 用 'X' 标记。\n以选中格子为端点的两个好线段在上图中用红色矩形标注出来了。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/10/grid2.png\" style=\"width: 350px; height: 351px;\" /></p>\n\n<pre>\n<b>输入：</b>board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"B\",\".\",\".\",\"W\",\".\",\".\",\".\"],[\".\",\".\",\"W\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\"B\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"B\",\"W\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"W\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"B\"]], rMove = 4, cMove = 4, color = \"W\"\n<b>输出：</b>false\n<b>解释：</b>虽然选中格子涂色后，棋盘上产生了好线段，但选中格子是作为中间格子，没有产生以选中格子为端点的好线段。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>board.length == board[r].length == 8</code></li>\n\t<li><code>0 &lt;= rMove, cMove &lt; 8</code></li>\n\t<li><code>board[rMove][cMove] == '.'</code></li>\n\t<li><code>color</code>&nbsp;要么是&nbsp;<code>'B'</code> 要么是&nbsp;<code>'W'</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1959K 次调整数组大小浪费的最小总空间",
        "hardRate": "MEDIUM",
        "passRate": "45.88%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-total-space-wasted-with-k-resizing-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-total-space-wasted-with-k-resizing-operations/solution",
        "problemsDesc": "<p>你正在设计一个动态数组。给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，其中&nbsp;<code>nums[i]</code>&nbsp;是&nbsp;<code>i</code>&nbsp;时刻数组中的元素数目。除此以外，你还有一个整数 <code>k</code>&nbsp;，表示你可以 <strong>调整</strong>&nbsp;数组大小的 <strong>最多</strong>&nbsp;次数（每次都可以调整成 <strong>任意</strong>&nbsp;大小）。</p>\n\n<p><code>t</code>&nbsp;时刻数组的大小&nbsp;<code>size<sub>t</sub></code>&nbsp;必须大于等于&nbsp;<code>nums[t]</code>&nbsp;，因为数组需要有足够的空间容纳所有元素。<code>t</code>&nbsp;时刻 <strong>浪费的空间</strong>&nbsp;为&nbsp;<code>size<sub>t</sub> - nums[t]</code>&nbsp;，<strong>总</strong>&nbsp;浪费空间为满足&nbsp;<code>0 &lt;= t &lt; nums.length</code>&nbsp;的每一个时刻&nbsp;<code>t</code>&nbsp;浪费的空间&nbsp;<strong>之和</strong>&nbsp;。</p>\n\n<p>在调整数组大小不超过 <code>k</code>&nbsp;次的前提下，请你返回 <strong>最小总浪费空间</strong>&nbsp;。</p>\n\n<p><strong>注意：</strong>数组最开始时可以为&nbsp;<strong>任意大小</strong>&nbsp;，且&nbsp;<strong>不计入</strong>&nbsp;调整大小的操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [10,20], k = 0\n<b>输出：</b>10\n<b>解释：</b>size = [20,20].\n我们可以让数组初始大小为 20 。\n总浪费空间为 (20 - 10) + (20 - 20) = 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [10,20,30], k = 1\n<b>输出：</b>10\n<b>解释：</b>size = [20,20,30].\n我们可以让数组初始大小为 20 ，然后时刻 2 调整大小为 30 。\n总浪费空间为 (20 - 10) + (20 - 20) + (30 - 30) = 10 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [10,20,15,30,20], k = 2\n<b>输出：</b>15\n<b>解释：</b>size = [10,20,20,30,30].\n我们可以让数组初始大小为 10 ，时刻 1 调整大小为 20 ，时刻 3 调整大小为 30 。\n总浪费空间为 (10 - 10) + (20 - 20) + (20 - 15) + (30 - 30) + (30 - 20) = 15 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= nums.length - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1960两个回文子字符串长度的最大乘积",
        "hardRate": "HARD",
        "passRate": "32.31%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-product-of-the-length-of-two-palindromic-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-product-of-the-length-of-two-palindromic-substrings/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>s</code>&nbsp;，你需要找到两个 <strong>不重叠</strong><strong>的回文&nbsp;</strong>子字符串，它们的长度都必须为 <strong>奇数</strong>&nbsp;，使得它们长度的乘积最大。</p>\n\n<p>更正式地，你想要选择四个整数&nbsp;<code>i</code>&nbsp;，<code>j</code>&nbsp;，<code>k</code>&nbsp;，<code>l</code>&nbsp;，使得&nbsp;<code>0 &lt;= i &lt;= j &lt; k &lt;= l &lt; s.length</code>&nbsp;，且子字符串&nbsp;<code>s[i...j]</code> 和&nbsp;<code>s[k...l]</code>&nbsp;都是回文串且长度为奇数。<code>s[i...j]</code>&nbsp;表示下标从 <code>i</code>&nbsp;到 <code>j</code>&nbsp;且 <strong>包含</strong>&nbsp;两端下标的子字符串。</p>\n\n<p>请你返回两个不重叠回文子字符串长度的 <strong>最大</strong>&nbsp;乘积。</p>\n\n<p><strong>回文字符串</strong>&nbsp;指的是一个从前往后读和从后往前读一模一样的字符串。<strong>子字符串</strong>&nbsp;指的是一个字符串中一段连续字符。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"ababbb\"\n<b>输出：</b>9\n<b>解释：</b>子字符串 \"aba\" 和 \"bbb\" 为奇数长度的回文串。乘积为 3 * 3 = 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"zaaaxbbby\"\n<b>输出：</b>9\n<b>解释：</b>子字符串 \"aaa\" 和 \"bbb\" 为奇数长度的回文串。乘积为 3 * 3 = 9 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1961检查字符串是否为数组前缀",
        "hardRate": "EASY",
        "passRate": "52.72%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-string-is-a-prefix-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-string-is-a-prefix-of-array/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和一个字符串数组 <code>words</code> ，请你判断 <code>s</code> 是否为 <code>words</code> 的 <strong>前缀字符串</strong> 。</p>\n\n<p>字符串 <code>s</code> 要成为 <code>words</code> 的 <strong>前缀字符串</strong> ，需要满足：<code>s</code> 可以由 <code>words</code> 中的前 <code>k</code>（<code>k</code> 为 <strong>正数</strong> ）个字符串按顺序相连得到，且 <code>k</code> 不超过 <code>words.length</code> 。</p>\n\n<p>如果 <code>s</code> 是 <code>words</code> 的 <strong>前缀字符串</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"iloveleetcode\", words = [\"i\",\"love\",\"leetcode\",\"apples\"]\n<strong>输出：</strong>true\n<strong>解释：</strong>\ns 可以由 \"i\"、\"love\" 和 \"leetcode\" 相连得到。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"iloveleetcode\", words = [\"apples\",\"i\",\"love\",\"leetcode\"]\n<strong>输出：</strong>false\n<strong>解释：</strong>\n数组的前缀相连无法得到 s 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 20</code></li>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>words[i]</code> 和 <code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1962移除石子使总数最小",
        "hardRate": "MEDIUM",
        "passRate": "46.67%",
        "problemsUrl": "https://leetcode.cn/problems/remove-stones-to-minimize-the-total/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-stones-to-minimize-the-total/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>piles</code> ，数组 <strong>下标从 0 开始</strong> ，其中 <code>piles[i]</code> 表示第 <code>i</code> 堆石子中的石子数量。另给你一个整数 <code>k</code> ，请你执行下述操作 <strong>恰好</strong> <code>k</code> 次：</p>\n\n<ul>\n\t<li>选出任一石子堆 <code>piles[i]</code> ，并从中 <strong>移除</strong> <code>floor(piles[i] / 2)</code> 颗石子。</li>\n</ul>\n\n<p><strong>注意：</strong>你可以对 <strong>同一堆</strong> 石子多次执行此操作。</p>\n\n<p>返回执行 <code>k</code> 次操作后，剩下石子的 <strong>最小</strong> 总数。</p>\n\n<p><code>floor(x)</code> 为 <strong>小于</strong> 或 <strong>等于</strong> <code>x</code> 的 <strong>最大</strong> 整数。（即，对 <code>x</code> 向下取整）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [5,4,9], k = 2\n<strong>输出：</strong>12\n<strong>解释：</strong>可能的执行情景如下：\n- 对第 2 堆石子执行移除操作，石子分布情况变成 [5,4,<strong><em>5</em></strong>] 。\n- 对第 0 堆石子执行移除操作，石子分布情况变成 [<strong><em>3</em></strong>,4,5] 。\n剩下石子的总数为 12 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [4,3,6,7], k = 3\n<strong>输出：</strong>12\n<strong>解释：</strong>可能的执行情景如下：\n- 对第 2 堆石子执行移除操作，石子分布情况变成 [4,3,<strong><em>3</em></strong>,7] 。\n- 对第 3 堆石子执行移除操作，石子分布情况变成 [4,3,3,<strong><em>4</em></strong>] 。\n- 对第 0 堆石子执行移除操作，石子分布情况变成 [<strong><em>2</em></strong>,3,3,4] 。\n剩下石子的总数为 12 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= piles.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= piles[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1963使字符串平衡的最小交换次数",
        "hardRate": "MEDIUM",
        "passRate": "64.54%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-swaps-to-make-the-string-balanced/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-swaps-to-make-the-string-balanced/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，<strong>下标从 0 开始</strong> ，且长度为偶数 <code>n</code> 。字符串 <strong>恰好</strong> 由 <code>n / 2</code> 个开括号 <code>'['</code> 和 <code>n / 2</code> 个闭括号 <code>']'</code> 组成。</p>\n\n<p>只有能满足下述所有条件的字符串才能称为 <strong>平衡字符串</strong> ：</p>\n\n<ul>\n\t<li>字符串是一个空字符串，或者</li>\n\t<li>字符串可以记作 <code>AB</code> ，其中 <code>A</code> 和 <code>B</code> 都是 <strong>平衡字符串</strong> ，或者</li>\n\t<li>字符串可以写成 <code>[C]</code> ，其中 <code>C</code> 是一个 <strong>平衡字符串</strong> 。</li>\n</ul>\n\n<p>你可以交换 <strong>任意</strong> 两个下标所对应的括号 <strong>任意</strong> 次数。</p>\n\n<p>返回使<em> </em><code>s</code> 变成 <strong>平衡字符串</strong> 所需要的 <strong>最小</strong> 交换次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"][][\"\n<strong>输出：</strong>1\n<strong>解释：</strong>交换下标 0 和下标 3 对应的括号，可以使字符串变成平衡字符串。\n最终字符串变成 \"[[]]\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"]]][[[\"\n<strong>输出：</strong>2\n<strong>解释：</strong>执行下述操作可以使字符串变成平衡字符串：\n- 交换下标 0 和下标 4 对应的括号，s = \"[]][][\" 。\n- 交换下标 1 和下标 5 对应的括号，s = \"[[][]]\" 。\n最终字符串变成 \"[[][]]\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"[]\"\n<strong>输出：</strong>0\n<strong>解释：</strong>这个字符串已经是平衡字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == s.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>6</sup></code></li>\n\t<li><code>n</code> 为偶数</li>\n\t<li><code>s[i]</code> 为<code>'['</code> 或 <code>']'</code></li>\n\t<li>开括号 <code>'['</code> 的数目为 <code>n / 2</code> ，闭括号 <code>']'</code> 的数目也是 <code>n / 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1964找出到每个位置为止最长的有效障碍赛跑路线",
        "hardRate": "HARD",
        "passRate": "43.58%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-longest-valid-obstacle-course-at-each-position/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-longest-valid-obstacle-course-at-each-position/solution",
        "problemsDesc": "<p>你打算构建一些障碍赛跑路线。给你一个 <strong>下标从 0 开始</strong> 的整数数组 <code>obstacles</code> ，数组长度为 <code>n</code> ，其中 <code>obstacles[i]</code> 表示第 <code>i</code> 个障碍的高度。</p>\n\n<p>对于每个介于 <code>0</code> 和 <code>n - 1</code> 之间（包含 <code>0</code> 和 <code>n - 1</code>）的下标&nbsp; <code>i</code> ，在满足下述条件的前提下，请你找出&nbsp;<code>obstacles</code> 能构成的最长障碍路线的长度：</p>\n\n<ul>\n\t<li>你可以选择下标介于 <code>0</code> 到 <code>i</code> 之间（包含 <code>0</code> 和 <code>i</code>）的任意个障碍。</li>\n\t<li>在这条路线中，必须包含第 <code>i</code> 个障碍。</li>\n\t<li>你必须按障碍在&nbsp;<code>obstacles</code>&nbsp;中的<strong> </strong><strong>出现顺序</strong> 布置这些障碍。</li>\n\t<li>除第一个障碍外，路线中每个障碍的高度都必须和前一个障碍 <strong>相同</strong> 或者 <strong>更高</strong> 。</li>\n</ul>\n\n<p>返回长度为 <code>n</code> 的答案数组 <code>ans</code> ，其中 <code>ans[i]</code> 是上面所述的下标 <code>i</code> 对应的最长障碍赛跑路线的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>obstacles = [1,2,3,2]\n<strong>输出：</strong>[1,2,3,3]\n<strong>解释：</strong>每个位置的最长有效障碍路线是：\n- i = 0: [<em><strong>1</strong></em>], [1] 长度为 1\n- i = 1: [<em><strong>1</strong></em>,<em><strong>2</strong></em>], [1,2] 长度为 2\n- i = 2: [<em><strong>1</strong></em>,<em><strong>2</strong></em>,<em><strong>3</strong></em>], [1,2,3] 长度为 3\n- i = 3: [<em><strong>1</strong></em>,<em><strong>2</strong></em>,3,<em><strong>2</strong></em>], [1,2,2] 长度为 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>obstacles = [2,2,1]\n<strong>输出：</strong>[1,2,1]\n<strong>解释：</strong>每个位置的最长有效障碍路线是：\n- i = 0: [<em><strong>2</strong></em>], [2] 长度为 1\n- i = 1: [<em><strong>2</strong></em>,<em><strong>2</strong></em>], [2,2] 长度为 2\n- i = 2: [2,2,<em><strong>1</strong></em>], [1] 长度为 1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>obstacles = [3,1,5,6,4,2]\n<strong>输出：</strong>[1,1,2,3,2,2]\n<strong>解释：</strong>每个位置的最长有效障碍路线是：\n- i = 0: [<em><strong>3</strong></em>], [3] 长度为 1\n- i = 1: [3,<em><strong>1</strong></em>], [1] 长度为 1\n- i = 2: [<em><strong>3</strong></em>,1,<em><strong>5</strong></em>], [3,5] 长度为 2, [1,5] 也是有效的障碍赛跑路线\n- i = 3: [<em><strong>3</strong></em>,1,<em><strong>5</strong></em>,<em><strong>6</strong></em>], [3,5,6] 长度为 3, [1,5,6] 也是有效的障碍赛跑路线\n- i = 4: [<em><strong>3</strong></em>,1,5,6,<em><strong>4</strong></em>], [3,4] 长度为 2, [1,4] 也是有效的障碍赛跑路线\n- i = 5: [3,<em><strong>1</strong></em>,5,6,4,<em><strong>2</strong></em>], [1,2] 长度为 2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == obstacles.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= obstacles[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1965丢失信息的雇员",
        "hardRate": "EASY",
        "passRate": "71.06%",
        "problemsUrl": "https://leetcode.cn/problems/employees-with-missing-information/",
        "solutionsUrl": "https://leetcode.cn/problems/employees-with-missing-information/solution",
        "problemsDesc": "<p>表: <code>Employees</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| employee_id | int     |\n| name        | varchar |\n+-------------+---------+\nemployee_id 是这个表的主键。\n每一行表示雇员的id 和他的姓名。\n</pre>\n\n<p>表: <code>Salaries</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| employee_id | int     |\n| salary      | int     |\n+-------------+---------+\nemployee_id is 这个表的主键。\n每一行表示雇员的id 和他的薪水。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写出一个查询语句，找到所有 <strong>丢失信息</strong> 的雇员id。当满足下面一个条件时，就被认为是雇员的信息丢失：</p>\n\n<ul>\n\t<li>雇员的 <strong>姓名</strong> 丢失了，或者</li>\n\t<li>雇员的 <strong>薪水信息</strong> 丢失了，或者</li>\n</ul>\n\n<p>返回这些雇员的id &nbsp;<code>employee_id</code>&nbsp;，&nbsp;<strong>从小到大排序&nbsp;</strong>。</p>\n\n<p>查询结果格式如下面的例子所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nEmployees table:\n+-------------+----------+\n| employee_id | name     |\n+-------------+----------+\n| 2           | Crew     |\n| 4           | Haven    |\n| 5           | Kristian |\n+-------------+----------+\nSalaries table:\n+-------------+--------+\n| employee_id | salary |\n+-------------+--------+\n| 5           | 76071  |\n| 1           | 22517  |\n| 4           | 63539  |\n+-------------+--------+\n<strong>输出：</strong>\n+-------------+\n| employee_id |\n+-------------+\n| 1           |\n| 2           |\n+-------------+\n<strong>解释：</strong>\n雇员1，2，4，5 都工作在这个公司。\n1号雇员的姓名丢失了。\n2号雇员的薪水信息丢失了。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1966未排序数组中的可被二分搜索的数",
        "hardRate": "MEDIUM",
        "passRate": "64.40%",
        "problemsUrl": "https://leetcode.cn/problems/binary-searchable-numbers-in-an-unsorted-array/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-searchable-numbers-in-an-unsorted-array/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1967作为子字符串出现在单词中的字符串数目",
        "hardRate": "EASY",
        "passRate": "79.29%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-strings-that-appear-as-substrings-in-word/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-strings-that-appear-as-substrings-in-word/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>patterns</code> 和一个字符串 <code>word</code> ，统计 <code>patterns</code> 中有多少个字符串是 <code>word</code> 的子字符串。返回字符串数目。</p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>patterns = [\"a\",\"abc\",\"bc\",\"d\"], word = \"abc\"\n<strong>输出：</strong>3\n<strong>解释：</strong>\n- \"a\" 是 \"<em><strong>a</strong></em>bc\" 的子字符串。\n- \"abc\" 是 \"<em><strong>abc</strong></em>\" 的子字符串。\n- \"bc\" 是 \"a<em><strong>bc</strong></em>\" 的子字符串。\n- \"d\" 不是 \"abc\" 的子字符串。\npatterns 中有 3 个字符串作为子字符串出现在 word 中。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>patterns = [\"a\",\"b\",\"c\"], word = \"aaaaabbbbb\"\n<strong>输出：</strong>2\n<strong>解释：</strong>\n- \"a\" 是 \"a<em><strong>a</strong></em>aaabbbbb\" 的子字符串。\n- \"b\" 是 \"aaaaabbbb<em><strong>b</strong></em>\" 的子字符串。\n- \"c\" 不是 \"aaaaabbbbb\" 的字符串。\npatterns 中有 2 个字符串作为子字符串出现在 word 中。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>patterns = [\"a\",\"a\",\"a\"], word = \"ab\"\n<strong>输出：</strong>3\n<strong>解释：</strong>patterns 中的每个字符串都作为子字符串出现在 word \"<em><strong>a</strong></em>b\" 中。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= patterns.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= patterns[i].length &lt;= 100</code></li>\n\t<li><code>1 &lt;= word.length &lt;= 100</code></li>\n\t<li><code>patterns[i]</code> 和 <code>word</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1968构造元素不等于两相邻元素平均值的数组",
        "hardRate": "MEDIUM",
        "passRate": "39.25%",
        "problemsUrl": "https://leetcode.cn/problems/array-with-elements-not-equal-to-average-of-neighbors/",
        "solutionsUrl": "https://leetcode.cn/problems/array-with-elements-not-equal-to-average-of-neighbors/solution",
        "problemsDesc": "<p>给你一个 <strong>下标从 0 开始</strong> 的数组 <code>nums</code> ，数组由若干 <strong>互不相同的</strong> 整数组成。你打算重新排列数组中的元素以满足：重排后，数组中的每个元素都 <strong>不等于</strong> 其两侧相邻元素的 <strong>平均值</strong> 。</p>\n\n<p>更公式化的说法是，重新排列的数组应当满足这一属性：对于范围&nbsp;<code>1 &lt;= i &lt; nums.length - 1</code> 中的每个 <code>i</code> ，<code>(nums[i-1] + nums[i+1]) / 2</code> <strong>不等于</strong> <code>nums[i]</code> 均成立 。</p>\n\n<p>返回满足题意的任一重排结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,5]\n<strong>输出：</strong>[1,2,4,5,3]\n<strong>解释：</strong>\ni=1, nums[i] = 2, 两相邻元素平均值为 (1+4) / 2 = 2.5\ni=2, nums[i] = 4, 两相邻元素平均值为 (2+5) / 2 = 3.5\ni=3, nums[i] = 5, 两相邻元素平均值为 (4+3) / 2 = 3.5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [6,2,0,9,7]\n<strong>输出：</strong>[9,7,6,2,0]\n<strong>解释：</strong>\ni=1, nums[i] = 7, 两相邻元素平均值为 (9+6) / 2 = 7.5\ni=2, nums[i] = 6, 两相邻元素平均值为 (7+2) / 2 = 4.5\ni=3, nums[i] = 2, 两相邻元素平均值为 (6+0) / 2 = 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1969数组元素的最小非零乘积",
        "hardRate": "MEDIUM",
        "passRate": "29.83%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-non-zero-product-of-the-array-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-non-zero-product-of-the-array-elements/solution",
        "problemsDesc": "<p>给你一个正整数&nbsp;<code>p</code>&nbsp;。你有一个下标从 <strong>1</strong>&nbsp;开始的数组&nbsp;<code>nums</code>&nbsp;，这个数组包含范围&nbsp;<code>[1, 2<sup>p</sup> - 1]</code>&nbsp;内所有整数的二进制形式（两端都 <strong>包含</strong>）。你可以进行以下操作 <strong>任意</strong>&nbsp;次：</p>\n\n<ul>\n\t<li>从 <code>nums</code>&nbsp;中选择两个元素&nbsp;<code>x</code>&nbsp;和&nbsp;<code>y</code>&nbsp; 。</li>\n\t<li>选择 <code>x</code>&nbsp;中的一位与 <code>y</code>&nbsp;对应位置的位交换。对应位置指的是两个整数 <strong>相同位置</strong>&nbsp;的二进制位。</li>\n</ul>\n\n<p>比方说，如果&nbsp;<code>x = 11<em><strong>0</strong></em>1</code>&nbsp;且&nbsp;<code>y = 00<em><strong>1</strong></em>1</code>&nbsp;，交换右边数起第 <code>2</code>&nbsp;位后，我们得到&nbsp;<code>x = 11<em><strong>1</strong></em>1</code> 和&nbsp;<code>y = 00<em><strong>0</strong></em>1</code>&nbsp;。</p>\n\n<p>请你算出进行以上操作 <strong>任意次</strong>&nbsp;以后，<code>nums</code>&nbsp;能得到的 <strong>最小非零</strong>&nbsp;乘积。将乘积对<em>&nbsp;</em><code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong> 后返回。</p>\n\n<p><strong>注意：</strong>答案应为取余 <strong>之前</strong>&nbsp;的最小值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>p = 1\n<b>输出：</b>1\n<b>解释：</b>nums = [1] 。\n只有一个元素，所以乘积为该元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>p = 2\n<b>输出：</b>6\n<b>解释：</b>nums = [01, 10, 11] 。\n所有交换要么使乘积变为 0 ，要么乘积与初始乘积相同。\n所以，数组乘积 1 * 2 * 3 = 6 已经是最小值。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>p = 3\n<b>输出：</b>1512\n<b>解释：</b>nums = [001, 010, 011, 100, 101, 110, 111]\n- 第一次操作中，我们交换第二个和第五个元素最左边的数位。\n    - 结果数组为 [001, <em><strong>1</strong></em>10, 011, 100, <em><strong>0</strong></em>01, 110, 111] 。\n- 第二次操作中，我们交换第三个和第四个元素中间的数位。\n    - 结果数组为 [001, 110, 0<em><strong>0</strong></em>1, 1<em><strong>1</strong></em>0, 001, 110, 111] 。\n数组乘积 1 * 6 * 1 * 6 * 1 * 6 * 7 = 1512 是最小乘积。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= p &lt;= 60</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1970你能穿过矩阵的最后一天",
        "hardRate": "HARD",
        "passRate": "50.88%",
        "problemsUrl": "https://leetcode.cn/problems/last-day-where-you-can-still-cross/",
        "solutionsUrl": "https://leetcode.cn/problems/last-day-where-you-can-still-cross/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>1</strong>&nbsp;开始的二进制矩阵，其中&nbsp;<code>0</code>&nbsp;表示陆地，<code>1</code>&nbsp;表示水域。同时给你&nbsp;<code>row</code> 和&nbsp;<code>col</code>&nbsp;分别表示矩阵中行和列的数目。</p>\n\n<p>一开始在第&nbsp;<code>0</code>&nbsp;天，<strong>整个</strong>&nbsp;矩阵都是&nbsp;<strong>陆地</strong>&nbsp;。但每一天都会有一块新陆地被&nbsp;<strong>水</strong>&nbsp;淹没变成水域。给你一个下标从&nbsp;<strong>1</strong>&nbsp;开始的二维数组&nbsp;<code>cells</code>&nbsp;，其中&nbsp;<code>cells[i] = [r<sub>i</sub>, c<sub>i</sub>]</code>&nbsp;表示在第&nbsp;<code>i</code>&nbsp;天，第&nbsp;<code>r<sub>i</sub></code>&nbsp;行&nbsp;<code>c<sub>i</sub></code>&nbsp;列（下标都是从 <strong>1</strong>&nbsp;开始）的陆地会变成 <strong>水域</strong>&nbsp;（也就是 <code>0</code>&nbsp;变成 <code>1</code>&nbsp;）。</p>\n\n<p>你想知道从矩阵最 <strong>上面</strong>&nbsp;一行走到最 <strong>下面</strong>&nbsp;一行，且只经过陆地格子的 <strong>最后一天</strong>&nbsp;是哪一天。你可以从最上面一行的&nbsp;<strong>任意</strong>&nbsp;格子出发，到达最下面一行的&nbsp;<strong>任意</strong>&nbsp;格子。你只能沿着&nbsp;<strong>四个</strong>&nbsp;基本方向移动（也就是上下左右）。</p>\n\n<p>请返回只经过陆地格子能从最 <strong>上面</strong>&nbsp;一行走到最 <strong>下面</strong>&nbsp;一行的 <strong>最后一天</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/27/1.png\" style=\"width: 624px; height: 162px;\">\n<pre><b>输入：</b>row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]\n<b>输出：</b>2\n<b>解释：</b>上图描述了矩阵从第 0 天开始是如何变化的。\n可以从最上面一行到最下面一行的最后一天是第 2 天。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/27/2.png\" style=\"width: 504px; height: 178px;\">\n<pre><b>输入：</b>row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]]\n<b>输出：</b>1\n<b>解释：</b>上图描述了矩阵从第 0 天开始是如何变化的。\n可以从最上面一行到最下面一行的最后一天是第 1 天。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/27/3.png\" style=\"width: 666px; height: 167px;\">\n<pre><b>输入：</b>row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]\n<b>输出：</b>3\n<b>解释：</b>上图描述了矩阵从第 0 天开始是如何变化的。\n可以从最上面一行到最下面一行的最后一天是第 3 天。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= row, col &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>4 &lt;= row * col &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>cells.length == row * col</code></li>\n\t<li><code>1 &lt;= r<sub>i</sub> &lt;= row</code></li>\n\t<li><code>1 &lt;= c<sub>i</sub> &lt;= col</code></li>\n\t<li><code>cells</code>&nbsp;中的所有格子坐标都是 <strong>唯一</strong>&nbsp;的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1971寻找图中是否存在路径",
        "hardRate": "EASY",
        "passRate": "54.11%",
        "problemsUrl": "https://leetcode.cn/problems/find-if-path-exists-in-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/find-if-path-exists-in-graph/solution",
        "problemsDesc": "<p>有一个具有 <code>n</code> 个顶点的 <strong>双向</strong> 图，其中每个顶点标记从 <code>0</code> 到 <code>n - 1</code>（包含 <code>0</code> 和 <code>n - 1</code>）。图中的边用一个二维整数数组 <code>edges</code> 表示，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> 表示顶点 <code>ui</code> 和顶点 <code>vi</code> 之间的双向边。 每个顶点对由 <strong>最多一条</strong> 边连接，并且没有顶点存在与自身相连的边。</p>\n\n<p>请你确定是否存在从顶点 <code>source</code> 开始，到顶点 <code>destination</code> 结束的 <strong>有效路径</strong> 。</p>\n\n<p>给你数组 <code>edges</code> 和整数 <code>n</code>、<code>source</code> 和 <code>destination</code>，如果从 <code>source</code> 到 <code>destination</code> 存在 <strong>有效路径</strong> ，则返回 <code>true</code>，否则返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/14/validpath-ex1.png\" style=\"width: 141px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>存在由顶点 0 到顶点 2 的路径:\n- 0 → 1 → 2 \n- 0 → 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/14/validpath-ex2.png\" style=\"width: 281px; height: 141px;\" />\n<pre>\n<strong>输入：</strong>n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5\n<strong>输出：</strong>false\n<strong>解释：</strong>不存在由顶点 0 到顶点 5 的路径.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= edges.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n\t<li><code>0 &lt;= source, destination &lt;= n - 1</code></li>\n\t<li>不存在重复边</li>\n\t<li>不存在指向顶点自身的边</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1972同一天的第一个电话和最后一个电话",
        "hardRate": "HARD",
        "passRate": "42.52%",
        "problemsUrl": "https://leetcode.cn/problems/first-and-last-call-on-the-same-day/",
        "solutionsUrl": "https://leetcode.cn/problems/first-and-last-call-on-the-same-day/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1973值等于子节点值之和的节点数量",
        "hardRate": "MEDIUM",
        "passRate": "60.16%",
        "problemsUrl": "https://leetcode.cn/problems/count-nodes-equal-to-sum-of-descendants/",
        "solutionsUrl": "https://leetcode.cn/problems/count-nodes-equal-to-sum-of-descendants/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1974使用特殊打字机键入单词的最少时间",
        "hardRate": "EASY",
        "passRate": "71.35%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-type-word-using-special-typewriter/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-type-word-using-special-typewriter/solution",
        "problemsDesc": "<p>有一个特殊打字机，它由一个 <strong>圆盘</strong> 和一个 <strong>指针</strong>&nbsp;组成， 圆盘上标有小写英文字母&nbsp;<code>'a'</code> 到&nbsp;<code>'z'</code>。<strong>只有</strong>&nbsp;当指针指向某个字母时，它才能被键入。指针 <strong>初始时</strong>&nbsp;指向字符 <code>'a'</code>&nbsp;。</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/31/chart.jpg\" style=\"width: 530px; height: 410px;\" />\n<p>每一秒钟，你可以执行以下操作之一：</p>\n\n<ul>\n\t<li>将指针 <strong>顺时针</strong>&nbsp;或者 <b>逆时针</b>&nbsp;移动一个字符。</li>\n\t<li>键入指针 <strong>当前</strong>&nbsp;指向的字符。</li>\n</ul>\n\n<p>给你一个字符串&nbsp;<code>word</code>&nbsp;，请你返回键入&nbsp;<code>word</code>&nbsp;所表示单词的 <b>最少</b>&nbsp;秒数&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>word = \"abc\"\n<b>输出：</b>5\n<strong>解释：\n</strong>单词按如下操作键入：\n- 花 1 秒键入字符 'a' in 1 ，因为指针初始指向 'a' ，故不需移动指针。\n- 花 1 秒将指针顺时针移到 'b' 。\n- 花 1 秒键入字符 'b' 。\n- 花 1 秒将指针顺时针移到 'c' 。\n- 花 1 秒键入字符 'c' 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>word = \"bza\"\n<b>输出：</b>7\n<strong>解释：\n</strong>单词按如下操作键入：\n- 花 1 秒将指针顺时针移到 'b' 。\n- 花 1 秒键入字符 'b' 。\n- 花 2 秒将指针逆时针移到 'z' 。\n- 花 1 秒键入字符 'z' 。\n- 花 1 秒将指针顺时针移到 'a' 。\n- 花 1 秒键入字符 'a' 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>word = \"zjpc\"\n<b>输出：</b>34\n<strong>解释：</strong>\n单词按如下操作键入：\n- 花 1 秒将指针逆时针移到 'z' 。\n- 花 1 秒键入字符 'z' 。\n- 花 10 秒将指针顺时针移到 'j' 。\n- 花 1 秒键入字符 'j' 。\n- 花 6 秒将指针顺时针移到 'p' 。\n- 花 1 秒键入字符 'p' 。\n- 花 13 秒将指针逆时针移到 'c' 。\n- 花 1 秒键入字符 'c' 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 100</code></li>\n\t<li><code>word</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1975最大方阵和",
        "hardRate": "MEDIUM",
        "passRate": "41.59%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-matrix-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-matrix-sum/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>n x n</code>&nbsp;的整数方阵&nbsp;<code>matrix</code>&nbsp;。你可以执行以下操作&nbsp;<strong>任意次</strong>&nbsp;：</p>\n\n<ul>\n\t<li>选择&nbsp;<code>matrix</code>&nbsp;中&nbsp;<strong>相邻</strong>&nbsp;两个元素，并将它们都 <strong>乘以</strong>&nbsp;<code>-1</code>&nbsp;。</li>\n</ul>\n\n<p>如果两个元素有 <strong>公共边</strong>&nbsp;，那么它们就是 <strong>相邻</strong>&nbsp;的。</p>\n\n<p>你的目的是 <strong>最大化</strong>&nbsp;方阵元素的和。请你在执行以上操作之后，返回方阵的&nbsp;<strong>最大</strong>&nbsp;和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/16/pc79-q2ex1.png\" style=\"width: 401px; height: 81px;\">\n<pre><b>输入：</b>matrix = [[1,-1],[-1,1]]\n<b>输出：</b>4\n<b>解释：</b>我们可以执行以下操作使和等于 4 ：\n- 将第一行的 2 个元素乘以 -1 。\n- 将第一列的 2 个元素乘以 -1 。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/16/pc79-q2ex2.png\" style=\"width: 321px; height: 121px;\">\n<pre><b>输入：</b>matrix = [[1,2,3],[-1,-2,-3],[1,2,3]]\n<b>输出：</b>16\n<b>解释：</b>我们可以执行以下操作使和等于 16 ：\n- 将第二行的最后 2 个元素乘以 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == matrix.length == matrix[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 250</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= matrix[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1976到达目的地的方案数",
        "hardRate": "MEDIUM",
        "passRate": "36.44%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/solution",
        "problemsDesc": "<p>你在一个城市里，城市由 <code>n</code>&nbsp;个路口组成，路口编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，某些路口之间有 <strong>双向</strong>&nbsp;道路。输入保证你可以从任意路口出发到达其他任意路口，且任意两个路口之间最多有一条路。</p>\n\n<p>给你一个整数&nbsp;<code>n</code>&nbsp;和二维整数数组&nbsp;<code>roads</code>&nbsp;，其中&nbsp;<code>roads[i] = [u<sub>i</sub>, v<sub>i</sub>, time<sub>i</sub>]</code>&nbsp;表示在路口&nbsp;<code>u<sub>i</sub></code>&nbsp;和&nbsp;<code>v<sub>i</sub></code>&nbsp;之间有一条需要花费&nbsp;<code>time<sub>i</sub></code>&nbsp;时间才能通过的道路。你想知道花费 <strong>最少时间</strong>&nbsp;从路口&nbsp;<code>0</code>&nbsp;出发到达路口&nbsp;<code>n - 1</code>&nbsp;的方案数。</p>\n\n<p>请返回花费 <strong>最少时间</strong>&nbsp;到达目的地的 <strong>路径数目</strong>&nbsp;。由于答案可能很大，将结果对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/17/graph2.png\" style=\"width: 235px; height: 381px;\">\n<pre><b>输入：</b>n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]\n<b>输出：</b>4\n<b>解释：</b>从路口 0 出发到路口 6 花费的最少时间是 7 分钟。\n四条花费 7 分钟的路径分别为：\n- 0 ➝ 6\n- 0 ➝ 4 ➝ 6\n- 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6\n- 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 2, roads = [[1,0,10]]\n<b>输出：</b>1\n<b>解释：</b>只有一条从路口 0 到路口 1 的路，花费 10 分钟。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>n - 1 &lt;= roads.length &lt;= n * (n - 1) / 2</code></li>\n\t<li><code>roads[i].length == 3</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>\n\t<li>任意两个路口之间至多有一条路。</li>\n\t<li>从任意路口出发，你能够到达其他任意路口。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1977划分数字的方案数",
        "hardRate": "HARD",
        "passRate": "30.17%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-separate-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-separate-numbers/solution",
        "problemsDesc": "<p>你写下了若干 <strong>正整数</strong>&nbsp;，并将它们连接成了一个字符串&nbsp;<code>num</code>&nbsp;。但是你忘记给这些数字之间加逗号了。你只记得这一列数字是 <strong>非递减</strong>&nbsp;的且&nbsp;<strong>没有</strong> 任何数字有前导 0 。</p>\n\n<p>请你返回有多少种可能的 <strong>正整数数组</strong>&nbsp;可以得到字符串&nbsp;<code>num</code>&nbsp;。由于答案可能很大，将结果对 <code>10<sup>9</sup> + 7</code>&nbsp;<b>取余</b>&nbsp;后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>num = \"327\"\n<b>输出：</b>2\n<b>解释：</b>以下为可能的方案：\n3, 27\n327\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>num = \"094\"\n<b>输出：</b>0\n<b>解释：</b>不能有数字有前导 0 ，且所有数字均为正数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>num = \"0\"\n<b>输出：</b>0\n<strong>解释：</strong>不能有数字有前导 0 ，且所有数字均为正数。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>num = \"9999999999999\"\n<b>输出：</b>101\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 3500</code></li>\n\t<li><code>num</code>&nbsp;只含有数字&nbsp;<code>'0'</code> 到&nbsp;<code>'9'</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1978上级经理已离职的公司员工",
        "hardRate": "EASY",
        "passRate": "50.02%",
        "problemsUrl": "https://leetcode.cn/problems/employees-whose-manager-left-the-company/",
        "solutionsUrl": "https://leetcode.cn/problems/employees-whose-manager-left-the-company/solution",
        "problemsDesc": "<p>表: <code>Employees</code></p>\n\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| employee_id | int      |\n| name        | varchar  |\n| manager_id  | int      |\n| salary      | int      |\n+-------------+----------+\nemployee_id 是这个表的主键。\n这个表包含了员工，他们的薪水和上级经理的id。\n有一些员工没有上级经理（其manager_id 是空值）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一个查询语句，查询出，这些员工的id，他们的薪水严格少于<code>$30000</code>&nbsp;并且他们的上级经理已离职。当一个经理离开公司时，他们的信息需要从员工表中删除掉，但是表中的员工的<code>manager_id</code> &nbsp;这一列还是设置的离职经理的id&nbsp;。</p>\n\n<p>返回的结果按照<code>employee_id&nbsp;</code>从小到大排序。</p>\n\n<p>查询结果如下所示：</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nEmployees table:\n+-------------+-----------+------------+--------+\n| employee_id | name      | manager_id | salary |\n+-------------+-----------+------------+--------+\n| 3           | Mila      | 9          | 60301  |\n| 12          | Antonella | null       | 31000  |\n| 13          | Emery     | null       | 67084  |\n| 1           | Kalel     | 11         | 21241  |\n| 9           | Mikaela   | null       | 50937  |\n| 11          | Joziah    | 6          | 28485  |\n+-------------+-----------+------------+--------+\n<strong>输出：</strong>\n+-------------+\n| employee_id |\n+-------------+\n| 11          |\n+-------------+\n\n<strong>解释：</strong>\n薪水少于30000美元的员工有1号(Kalel) and 11号 (Joziah)。\nKalel的上级经理是11号员工，他还在公司上班(他是Joziah)。\nJoziah的上级经理是6号员工，他已经离职，因为员工表里面已经没有6号员工的信息了，它被删除了。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1979找出数组的最大公约数",
        "hardRate": "EASY",
        "passRate": "77.08%",
        "problemsUrl": "https://leetcode.cn/problems/find-greatest-common-divisor-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-greatest-common-divisor-of-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，返回数组中最大数和最小数的 <strong>最大公约数</strong> 。</p>\n\n<p>两个数的&nbsp;<strong>最大公约数</strong> 是能够被两个数整除的最大正整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,5,6,9,10]\n<strong>输出：</strong>2\n<strong>解释：</strong>\nnums 中最小的数是 2\nnums 中最大的数是 10\n2 和 10 的最大公约数是 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [7,5,6,8,3]\n<strong>输出：</strong>1\n<strong>解释：</strong>\nnums 中最小的数是 3\nnums 中最大的数是 8\n3 和 8 的最大公约数是 1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>\nnums 中最小的数是 3\nnums 中最大的数是 3\n3 和 3 的最大公约数是 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1980找出不同的二进制字符串",
        "hardRate": "MEDIUM",
        "passRate": "59.78%",
        "problemsUrl": "https://leetcode.cn/problems/find-unique-binary-string/",
        "solutionsUrl": "https://leetcode.cn/problems/find-unique-binary-string/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>nums</code> ，该数组由 <code>n</code> 个 <strong>互不相同</strong> 的二进制字符串组成，且每个字符串长度都是 <code>n</code> 。请你找出并返回一个长度为&nbsp;<code>n</code>&nbsp;且&nbsp;<strong>没有出现</strong> 在 <code>nums</code> 中的二进制字符串<em>。</em>如果存在多种答案，只需返回 <strong>任意一个</strong> 即可。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [\"01\",\"10\"]\n<strong>输出：</strong>\"11\"\n<strong>解释：</strong>\"11\" 没有出现在 nums 中。\"00\" 也是正确答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [\"00\",\"01\"]\n<strong>输出：</strong>\"11\"\n<strong>解释：</strong>\"11\" 没有出现在 nums 中。\"10\" 也是正确答案。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [\"111\",\"011\",\"001\"]\n<strong>输出：</strong>\"101\"\n<strong>解释：</strong>\"101\" 没有出现在 nums 中。\"000\"、\"010\"、\"100\"、\"110\" 也是正确答案。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 16</code></li>\n\t<li><code>nums[i].length == n</code></li>\n\t<li><code>nums[i] </code>为 <code>'0'</code> 或 <code>'1'</code></li>\n\t<li><code>nums</code> 中的所有字符串 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1981最小化目标值与所选元素的差",
        "hardRate": "MEDIUM",
        "passRate": "33.19%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-the-difference-between-target-and-chosen-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-the-difference-between-target-and-chosen-elements/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的整数矩阵 <code>mat</code> 和一个整数 <code>target</code> 。</p>\n\n<p>从矩阵的 <strong>每一行</strong> 中选择一个整数，你的目标是&nbsp;<strong>最小化</strong>&nbsp;所有选中元素之&nbsp;<strong>和</strong>&nbsp;与目标值 <code>target</code> 的 <strong>绝对差</strong> 。</p>\n\n<p>返回 <strong>最小的绝对差</strong> 。</p>\n\n<p><code>a</code> 和 <code>b</code> 两数字的 <strong>绝对差</strong> 是 <code>a - b</code> 的绝对值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/03/matrix1.png\" style=\"width: 181px; height: 181px;\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1,2,3],[4,5,6],[7,8,9]], target = 13\n<strong>输出：</strong>0\n<strong>解释：</strong>一种可能的最优选择方案是：\n- 第一行选出 1\n- 第二行选出 5\n- 第三行选出 7\n所选元素的和是 13 ，等于目标值，所以绝对差是 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/03/matrix1-1.png\" style=\"width: 61px; height: 181px;\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1],[2],[3]], target = 100\n<strong>输出：</strong>94\n<strong>解释：</strong>唯一一种选择方案是：\n- 第一行选出 1\n- 第二行选出 2\n- 第三行选出 3\n所选元素的和是 6 ，绝对差是 94 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/03/matrix1-3.png\" style=\"width: 301px; height: 61px;\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1,2,9,8,7]], target = 6\n<strong>输出：</strong>1\n<strong>解释：</strong>最优的选择方案是选出第一行的 7 。\n绝对差是 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 70</code></li>\n\t<li><code>1 &lt;= mat[i][j] &lt;= 70</code></li>\n\t<li><code>1 &lt;= target &lt;= 800</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1982从子集的和还原数组",
        "hardRate": "HARD",
        "passRate": "48.27%",
        "problemsUrl": "https://leetcode.cn/problems/find-array-given-subset-sums/",
        "solutionsUrl": "https://leetcode.cn/problems/find-array-given-subset-sums/solution",
        "problemsDesc": "<p>存在一个未知数组需要你进行还原，给你一个整数 <code>n</code> 表示该数组的长度。另给你一个数组 <code>sums</code> ，由未知数组中全部 <code>2<sup>n</sup></code> 个 <strong>子集的和</strong> 组成（子集中的元素没有特定的顺序）。</p>\n\n<p>返回一个长度为 <code>n</code> 的数组<em> </em><code>ans</code><em> </em>表示还原得到的未知数组。如果存在 <strong>多种</strong> 答案，只需返回其中 <strong>任意一个</strong> 。</p>\n\n<p>如果可以由数组 <code>arr</code> 删除部分元素（也可能不删除或全删除）得到数组 <code>sub</code> ，那么数组 <code>sub</code> 就是数组 <code>arr</code> 的一个<strong> 子集</strong> 。<code>sub</code> 的元素之和就是 <code>arr</code> 的一个 <strong>子集的和</strong> 。一个空数组的元素之和为 <code>0</code> 。</p>\n\n<p><strong>注意：</strong>生成的测试用例将保证至少存在一个正确答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, sums = [-3,-2,-1,0,0,1,2,3]\n<strong>输出：</strong>[1,2,-3]\n<strong>解释：</strong>[1,2,-3] 能够满足给出的子集的和：\n- []：和是 0\n- [1]：和是 1\n- [2]：和是 2\n- [1,2]：和是 3\n- [-3]：和是 -3\n- [1,-3]：和是 -2\n- [2,-3]：和是 -1\n- [1,2,-3]：和是 0\n注意，[1,2,-3] 的任何排列和 [-1,-2,3] 的任何排列都会被视作正确答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, sums = [0,0,0,0]\n<strong>输出：</strong>[0,0]\n<strong>解释：</strong>唯一的正确答案是 [0,0] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, sums = [0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8]\n<strong>输出：</strong>[0,-1,4,5]\n<strong>解释：</strong>[0,-1,4,5] 能够满足给出的子集的和。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 15</code></li>\n\t<li><code>sums.length == 2<sup>n</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= sums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1983范围和相等的最宽索引对",
        "hardRate": "MEDIUM",
        "passRate": "47.80%",
        "problemsUrl": "https://leetcode.cn/problems/widest-pair-of-indices-with-equal-range-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/widest-pair-of-indices-with-equal-range-sum/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1984学生分数的最小差值",
        "hardRate": "EASY",
        "passRate": "61.83%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-difference-between-highest-and-lowest-of-k-scores/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-difference-between-highest-and-lowest-of-k-scores/solution",
        "problemsDesc": "<p>给你一个 <strong>下标从 0 开始</strong> 的整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 表示第 <code>i</code> 名学生的分数。另给你一个整数 <code>k</code> 。</p>\n\n<p>从数组中选出任意 <code>k</code> 名学生的分数，使这 <code>k</code> 个分数间 <strong>最高分</strong> 和 <strong>最低分</strong> 的 <strong>差值</strong> 达到<strong> 最小化</strong> 。</p>\n\n<p>返回可能的 <strong>最小差值</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [90], k = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>选出 1 名学生的分数，仅有 1 种方法：\n- [<em><strong>90</strong></em>] 最高分和最低分之间的差值是 90 - 90 = 0\n可能的最小差值是 0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [9,4,1,7], k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>选出 2 名学生的分数，有 6 种方法：\n- [<em><strong>9</strong></em>,<em><strong>4</strong></em>,1,7] 最高分和最低分之间的差值是 9 - 4 = 5\n- [<em><strong>9</strong></em>,4,<em><strong>1</strong></em>,7] 最高分和最低分之间的差值是 9 - 1 = 8\n- [<em><strong>9</strong></em>,4,1,<em><strong>7</strong></em>] 最高分和最低分之间的差值是 9 - 7 = 2\n- [9,<em><strong>4</strong></em>,<em><strong>1</strong></em>,7] 最高分和最低分之间的差值是 4 - 1 = 3\n- [9,<em><strong>4</strong></em>,1,<em><strong>7</strong></em>] 最高分和最低分之间的差值是 7 - 4 = 3\n- [9,4,<em><strong>1</strong></em>,<em><strong>7</strong></em>] 最高分和最低分之间的差值是 7 - 1 = 6\n可能的最小差值是 2</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1985找出数组中的第 K 大整数",
        "hardRate": "MEDIUM",
        "passRate": "42.09%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-kth-largest-integer-in-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-kth-largest-integer-in-the-array/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>nums</code> 和一个整数 <code>k</code> 。<code>nums</code> 中的每个字符串都表示一个不含前导零的整数。</p>\n\n<p>返回 <code>nums</code> 中表示第 <code>k</code> 大整数的字符串。</p>\n\n<p><strong>注意：</strong>重复的数字在统计时会视为不同元素考虑。例如，如果 <code>nums</code> 是 <code>[\"1\",\"2\",\"2\"]</code>，那么 <code>\"2\"</code> 是最大的整数，<code>\"2\"</code> 是第二大的整数，<code>\"1\"</code> 是第三大的整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [\"3\",\"6\",\"7\",\"10\"], k = 4\n<strong>输出：</strong>\"3\"\n<strong>解释：</strong>\nnums 中的数字按非递减顺序排列为 [\"3\",\"6\",\"7\",\"10\"]\n其中第 4 大整数是 \"3\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [\"2\",\"21\",\"12\",\"1\"], k = 3\n<strong>输出：</strong>\"2\"\n<strong>解释：</strong>\nnums 中的数字按非递减顺序排列为 [\"1\",\"2\",\"12\",\"21\"]\n其中第 3 大整数是 \"2\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [\"0\",\"0\"], k = 2\n<strong>输出：</strong>\"0\"\n<strong>解释：</strong>\nnums 中的数字按非递减顺序排列为 [\"0\",\"0\"]\n其中第 2 大整数是 \"0\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i].length &lt;= 100</code></li>\n\t<li><code>nums[i]</code> 仅由数字组成</li>\n\t<li><code>nums[i]</code> 不含任何前导零</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1986完成任务的最少工作时间段",
        "hardRate": "MEDIUM",
        "passRate": "33.08%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-work-sessions-to-finish-the-tasks/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-work-sessions-to-finish-the-tasks/solution",
        "problemsDesc": "<p>你被安排了 <code>n</code>&nbsp;个任务。任务需要花费的时间用长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>tasks</code>&nbsp;表示，第 <code>i</code>&nbsp;个任务需要花费&nbsp;<code>tasks[i]</code>&nbsp;小时完成。一个 <strong>工作时间段</strong>&nbsp;中，你可以 <strong>至多</strong>&nbsp;连续工作&nbsp;<code>sessionTime</code>&nbsp;个小时，然后休息一会儿。</p>\n\n<p>你需要按照如下条件完成给定任务：</p>\n\n<ul>\n\t<li>如果你在某一个时间段开始一个任务，你需要在 <strong>同一个</strong>&nbsp;时间段完成它。</li>\n\t<li>完成一个任务后，你可以 <strong>立马</strong>&nbsp;开始一个新的任务。</li>\n\t<li>你可以按 <strong>任意顺序</strong>&nbsp;完成任务。</li>\n</ul>\n\n<p>给你&nbsp;<code>tasks</code> 和&nbsp;<code>sessionTime</code>&nbsp;，请你按照上述要求，返回完成所有任务所需要的&nbsp;<strong>最少</strong>&nbsp;数目的&nbsp;<strong>工作时间段</strong>&nbsp;。</p>\n\n<p>测试数据保证&nbsp;<code>sessionTime</code> <strong>大于等于</strong>&nbsp;<code>tasks[i]</code>&nbsp;中的&nbsp;<strong>最大值</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>tasks = [1,2,3], sessionTime = 3\n<b>输出：</b>2\n<b>解释：</b>你可以在两个工作时间段内完成所有任务。\n- 第一个工作时间段：完成第一和第二个任务，花费 1 + 2 = 3 小时。\n- 第二个工作时间段：完成第三个任务，花费 3 小时。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>tasks = [3,1,3,1,1], sessionTime = 8\n<b>输出：</b>2\n<b>解释：</b>你可以在两个工作时间段内完成所有任务。\n- 第一个工作时间段：完成除了最后一个任务以外的所有任务，花费 3 + 1 + 3 + 1 = 8 小时。\n- 第二个工作时间段，完成最后一个任务，花费 1 小时。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>tasks = [1,2,3,4,5], sessionTime = 15\n<b>输出：</b>1\n<b>解释：</b>你可以在一个工作时间段以内完成所有任务。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == tasks.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 14</code></li>\n\t<li><code>1 &lt;= tasks[i] &lt;= 10</code></li>\n\t<li><code>max(tasks[i]) &lt;= sessionTime &lt;= 15</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1987不同的好子序列数目",
        "hardRate": "HARD",
        "passRate": "50.38%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-unique-good-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-unique-good-subsequences/solution",
        "problemsDesc": "<p>给你一个二进制字符串&nbsp;<code>binary</code>&nbsp;。&nbsp;<code>binary</code>&nbsp;的一个 <strong>子序列</strong>&nbsp;如果是 <strong>非空</strong>&nbsp;的且没有 <b>前导</b>&nbsp;<strong>0</strong>&nbsp;（除非数字是 <code>\"0\"</code>&nbsp;本身），那么它就是一个 <strong>好</strong>&nbsp;的子序列。</p>\n\n<p>请你找到&nbsp;<code>binary</code>&nbsp;<strong>不同好子序列</strong>&nbsp;的数目。</p>\n\n<ul>\n\t<li>比方说，如果&nbsp;<code>binary = \"001\"</code>&nbsp;，那么所有 <strong>好</strong>&nbsp;子序列为&nbsp;<code>[\"0\", \"0\", \"1\"]</code>&nbsp;，所以 <b>不同</b>&nbsp;的好子序列为&nbsp;<code>\"0\"</code> 和&nbsp;<code>\"1\"</code>&nbsp;。 注意，子序列&nbsp;<code>\"00\"</code>&nbsp;，<code>\"01\"</code>&nbsp;和&nbsp;<code>\"001\"</code>&nbsp;不是好的，因为它们有前导 0 。</li>\n</ul>\n\n<p>请你返回&nbsp;<code>binary</code>&nbsp;中&nbsp;<strong>不同好子序列</strong>&nbsp;的数目。由于答案可能很大，请将它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong> 后返回。</p>\n\n<p>一个 <strong>子序列</strong>&nbsp;指的是从原数组中删除若干个（可以一个也不删除）元素后，不改变剩余元素顺序得到的序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>binary = \"001\"\n<b>输出：</b>2\n<b>解释：</b>好的二进制子序列为 [\"0\", \"0\", \"1\"] 。\n不同的好子序列为 \"0\" 和 \"1\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>binary = \"11\"\n<b>输出：</b>2\n<b>解释：</b>好的二进制子序列为 [\"1\", \"1\", \"11\"] 。\n不同的好子序列为 \"1\" 和 \"11\" 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>binary = \"101\"\n<b>输出：</b>5\n<b>解释：</b>好的二进制子序列为 [\"1\", \"0\", \"1\", \"10\", \"11\", \"101\"] 。\n不同的好子序列为 \"0\" ，\"1\" ，\"10\" ，\"11\" 和 \"101\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= binary.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>binary</code>&nbsp;只含有&nbsp;<code>'0'</code>&nbsp;和&nbsp;<code>'1'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1988找出每所学校的最低分数要求",
        "hardRate": "MEDIUM",
        "passRate": "64.55%",
        "problemsUrl": "https://leetcode.cn/problems/find-cutoff-score-for-each-school/",
        "solutionsUrl": "https://leetcode.cn/problems/find-cutoff-score-for-each-school/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1989捉迷藏中可捕获的最大人数",
        "hardRate": "MEDIUM",
        "passRate": "55.42%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-people-that-can-be-caught-in-tag/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-people-that-can-be-caught-in-tag/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1990统计实验的数量",
        "hardRate": "MEDIUM",
        "passRate": "47.02%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-experiments/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-experiments/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1991找到数组的中间位置",
        "hardRate": "EASY",
        "passRate": "63.89%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-middle-index-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-middle-index-in-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，请你找到 <strong>最左边</strong>&nbsp;的中间位置&nbsp;<code>middleIndex</code>&nbsp;（也就是所有可能中间位置下标最小的一个）。</p>\n\n<p>中间位置&nbsp;<code>middleIndex</code>&nbsp;是满足&nbsp;<code>nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1]</code>&nbsp;的数组下标。</p>\n\n<p>如果&nbsp;<code>middleIndex == 0</code>&nbsp;，左边部分的和定义为 <code>0</code>&nbsp;。类似的，如果&nbsp;<code>middleIndex == nums.length - 1</code>&nbsp;，右边部分的和定义为&nbsp;<code>0</code>&nbsp;。</p>\n\n<p>请你返回满足上述条件 <strong>最左边</strong>&nbsp;的<em>&nbsp;</em><code>middleIndex</code>&nbsp;，如果不存在这样的中间位置，请你返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,3,-1,<em><strong>8</strong></em>,4]\n<b>输出：</b>3\n<strong>解释：</strong>\n下标 3 之前的数字和为：2 + 3 + -1 = 4\n下标 3 之后的数字和为：4 = 4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,-1,<em><strong>4</strong></em>]\n<b>输出：</b>2\n<strong>解释：</strong>\n下标 2 之前的数字和为：1 + -1 = 0\n下标 2 之后的数字和为：0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,5]\n<b>输出：</b>-1\n<b>解释：</b>\n不存在符合要求的 middleIndex 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [<em><strong>1</strong></em>]\n<b>输出：</b>0\n<strong>解释：</strong>\n下标 0 之前的数字和为：0\n下标 0 之后的数字和为：0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与主站 724 题相同：<a href=\"https://leetcode-cn.com/problems/find-pivot-index/\" target=\"_blank\">https://leetcode-cn.com/problems/find-pivot-index/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1992找到所有的农场组",
        "hardRate": "MEDIUM",
        "passRate": "61.16%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-groups-of-farmland/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-groups-of-farmland/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始，大小为&nbsp;<code>m x n</code>&nbsp;的二进制矩阵&nbsp;<code>land</code>&nbsp;，其中 <code>0</code>&nbsp;表示一单位的森林土地，<code>1</code>&nbsp;表示一单位的农场土地。</p>\n\n<p>为了让农场保持有序，农场土地之间以矩形的 <strong>农场组</strong> 的形式存在。每一个农场组都 <strong>仅</strong>&nbsp;包含农场土地。且题目保证不会有两个农场组相邻，也就是说一个农场组中的任何一块土地都 <strong>不会</strong>&nbsp;与另一个农场组的任何一块土地在四个方向上相邻。</p>\n\n<p><code>land</code>&nbsp;可以用坐标系统表示，其中 <code>land</code>&nbsp;左上角坐标为&nbsp;<code>(0, 0)</code>&nbsp;，右下角坐标为&nbsp;<code>(m-1, n-1)</code>&nbsp;。请你找到所有 <b>农场组</b>&nbsp;最左上角和最右下角的坐标。一个左上角坐标为&nbsp;<code>(r<sub>1</sub>, c<sub>1</sub>)</code>&nbsp;且右下角坐标为&nbsp;<code>(r<sub>2</sub>, c<sub>2</sub>)</code>&nbsp;的 <strong>农场组</strong> 用长度为 4 的数组&nbsp;<code>[r<sub>1</sub>, c<sub>1</sub>, r<sub>2</sub>, c<sub>2</sub>]</code>&nbsp;表示。</p>\n\n<p>请你返回一个二维数组，它包含若干个长度为 4 的子数组，每个子数组表示 <code>land</code>&nbsp;中的一个 <strong>农场组</strong>&nbsp;。如果没有任何农场组，请你返回一个空数组。可以以 <strong>任意顺序</strong>&nbsp;返回所有农场组。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/27/screenshot-2021-07-27-at-12-23-15-copy-of-diagram-drawio-diagrams-net.png\" style=\"width: 300px; height: 300px;\"></p>\n\n<pre><b>输入：</b>land = [[1,0,0],[0,1,1],[0,1,1]]\n<b>输出：</b>[[0,0,0,0],[1,1,2,2]]\n<strong>解释：</strong>\n第一个农场组的左上角为 land[0][0] ，右下角为 land[0][0] 。\n第二个农场组的左上角为 land[1][1] ，右下角为 land[2][2] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/27/screenshot-2021-07-27-at-12-30-26-copy-of-diagram-drawio-diagrams-net.png\" style=\"width: 200px; height: 200px;\"></p>\n\n<pre><b>输入：</b>land = [[1,1],[1,1]]\n<b>输出：</b>[[0,0,1,1]]\n<strong>解释：</strong>\n第一个农场组左上角为 land[0][0] ，右下角为 land[1][1] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/27/screenshot-2021-07-27-at-12-32-24-copy-of-diagram-drawio-diagrams-net.png\" style=\"width: 100px; height: 100px;\"></p>\n\n<pre><b>输入：</b>land = [[0]]\n<b>输出：</b>[]\n<b>解释：</b>\n没有任何农场组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == land.length</code></li>\n\t<li><code>n == land[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>land</code>&nbsp;只包含&nbsp;<code>0</code>&nbsp;和&nbsp;<code>1</code>&nbsp;。</li>\n\t<li>农场组都是 <strong>矩形</strong>&nbsp;的形状。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1993树上的操作",
        "hardRate": "MEDIUM",
        "passRate": "39.82%",
        "problemsUrl": "https://leetcode.cn/problems/operations-on-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/operations-on-tree/solution",
        "problemsDesc": "<p>给你一棵&nbsp;<code>n</code>&nbsp;个节点的树，编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，以父节点数组&nbsp;<code>parent</code>&nbsp;的形式给出，其中&nbsp;<code>parent[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个节点的父节点。树的根节点为 <code>0</code>&nbsp;号节点，所以&nbsp;<code>parent[0] = -1</code>&nbsp;，因为它没有父节点。你想要设计一个数据结构实现树里面对节点的加锁，解锁和升级操作。</p>\n\n<p>数据结构需要支持如下函数：</p>\n\n<ul>\n\t<li><strong>Lock：</strong>指定用户给指定节点 <strong>上锁</strong>&nbsp;，上锁后其他用户将无法给同一节点上锁。只有当节点处于未上锁的状态下，才能进行上锁操作。</li>\n\t<li><strong>Unlock：</strong>指定用户给指定节点 <strong>解锁</strong>&nbsp;，只有当指定节点当前正被指定用户锁住时，才能执行该解锁操作。</li>\n\t<li><b>Upgrade：</b>指定用户给指定节点&nbsp;<strong>上锁</strong>&nbsp;，并且将该节点的所有子孙节点&nbsp;<strong>解锁</strong>&nbsp;。只有如下 3 个条件 <strong>全部</strong> 满足时才能执行升级操作：\n\t<ul>\n\t\t<li>指定节点当前状态为未上锁。</li>\n\t\t<li>指定节点至少有一个上锁状态的子孙节点（可以是 <strong>任意</strong>&nbsp;用户上锁的）。</li>\n\t\t<li>指定节点没有任何上锁的祖先节点。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你实现&nbsp;<code>LockingTree</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>LockingTree(int[] parent)</code>&nbsp;用父节点数组初始化数据结构。</li>\n\t<li><code>lock(int num, int user)</code> 如果&nbsp;id 为&nbsp;<code>user</code>&nbsp;的用户可以给节点&nbsp;<code>num</code>&nbsp;上锁，那么返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。如果可以执行此操作，节点&nbsp;<code>num</code>&nbsp;会被 id 为 <code>user</code>&nbsp;的用户 <strong>上锁</strong>&nbsp;。</li>\n\t<li><code>unlock(int num, int user)</code>&nbsp;如果 id 为 <code>user</code>&nbsp;的用户可以给节点 <code>num</code>&nbsp;解锁，那么返回&nbsp;<code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。如果可以执行此操作，节点 <code>num</code>&nbsp;变为 <strong>未上锁</strong>&nbsp;状态。</li>\n\t<li><code>upgrade(int num, int user)</code>&nbsp;如果 id 为 <code>user</code>&nbsp;的用户可以给节点 <code>num</code>&nbsp;升级，那么返回&nbsp;<code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。如果可以执行此操作，节点 <code>num</code>&nbsp;会被&nbsp;<strong>升级 </strong>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/29/untitled.png\" style=\"width: 375px; height: 246px;\"></p>\n\n<pre><strong>输入：</strong>\n[\"LockingTree\", \"lock\", \"unlock\", \"unlock\", \"lock\", \"upgrade\", \"lock\"]\n[[[-1, 0, 0, 1, 1, 2, 2]], [2, 2], [2, 3], [2, 2], [4, 5], [0, 1], [0, 1]]\n<strong>输出：</strong>\n[null, true, false, true, true, true, false]\n\n<strong>解释：</strong>\nLockingTree lockingTree = new LockingTree([-1, 0, 0, 1, 1, 2, 2]);\nlockingTree.lock(2, 2);    // 返回 true ，因为节点 2 未上锁。\n                           // 节点 2 被用户 2 上锁。\nlockingTree.unlock(2, 3);  // 返回 false ，因为用户 3 无法解锁被用户 2 上锁的节点。\nlockingTree.unlock(2, 2);  // 返回 true ，因为节点 2 之前被用户 2 上锁。\n                           // 节点 2 现在变为未上锁状态。\nlockingTree.lock(4, 5);    // 返回 true ，因为节点 4 未上锁。\n                           // 节点 4 被用户 5 上锁。\nlockingTree.upgrade(0, 1); // 返回 true ，因为节点 0 未上锁且至少有一个被上锁的子孙节点（节点 4）。\n                           // 节点 0 被用户 1 上锁，节点 4 变为未上锁。\nlockingTree.lock(0, 1);    // 返回 false ，因为节点 0 已经被上锁了。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == parent.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 2000</code></li>\n\t<li>对于&nbsp;<code>i != 0</code>&nbsp;，满足&nbsp;<code>0 &lt;= parent[i] &lt;= n - 1</code></li>\n\t<li><code>parent[0] == -1</code></li>\n\t<li><code>0 &lt;= num &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= user &lt;= 10<sup>4</sup></code></li>\n\t<li><code>parent</code>&nbsp;表示一棵合法的树。</li>\n\t<li><code>lock</code>&nbsp;，<code>unlock</code>&nbsp;和&nbsp;<code>upgrade</code>&nbsp;的调用&nbsp;<strong>总共&nbsp;</strong>不超过&nbsp;<code>2000</code>&nbsp;次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1994好子集的数目",
        "hardRate": "HARD",
        "passRate": "56.13%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-good-subsets/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-good-subsets/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;。如果&nbsp;<code>nums</code>&nbsp;的一个子集中，所有元素的乘积可以表示为一个或多个 <strong>互不相同的质数</strong> 的乘积，那么我们称它为&nbsp;<strong>好子集</strong>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，如果&nbsp;<code>nums = [1, 2, 3, 4]</code>&nbsp;：\n\n\t<ul>\n\t\t<li><code>[2, 3]</code>&nbsp;，<code>[1, 2, 3]</code>&nbsp;和&nbsp;<code>[1, 3]</code>&nbsp;是 <strong>好</strong>&nbsp;子集，乘积分别为&nbsp;<code>6 = 2*3</code>&nbsp;，<code>6 = 2*3</code>&nbsp;和&nbsp;<code>3 = 3</code>&nbsp;。</li>\n\t\t<li><code>[1, 4]</code> 和&nbsp;<code>[4]</code>&nbsp;不是 <strong>好</strong>&nbsp;子集，因为乘积分别为&nbsp;<code>4 = 2*2</code> 和&nbsp;<code>4 = 2*2</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回 <code>nums</code>&nbsp;中不同的&nbsp;<strong>好</strong>&nbsp;子集的数目对<em>&nbsp;</em><code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;的结果。</p>\n\n<p><code>nums</code>&nbsp;中的 <strong>子集</strong>&nbsp;是通过删除 <code>nums</code>&nbsp;中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4]\n<b>输出：</b>6\n<b>解释：</b>好子集为：\n- [1,2]：乘积为 2 ，可以表示为质数 2 的乘积。\n- [1,2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。\n- [1,3]：乘积为 3 ，可以表示为质数 3 的乘积。\n- [2]：乘积为 2 ，可以表示为质数 2 的乘积。\n- [2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。\n- [3]：乘积为 3 ，可以表示为质数 3 的乘积。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [4,2,3,15]\n<b>输出：</b>5\n<b>解释：</b>好子集为：\n- [2]：乘积为 2 ，可以表示为质数 2 的乘积。\n- [2,3]：乘积为 6 ，可以表示为互不相同质数 2 和 3 的乘积。\n- [2,15]：乘积为 30 ，可以表示为互不相同质数 2，3 和 5 的乘积。\n- [3]：乘积为 3 ，可以表示为质数 3 的乘积。\n- [15]：乘积为 15 ，可以表示为互不相同质数 3 和 5 的乘积。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 30</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1995统计特殊四元组",
        "hardRate": "EASY",
        "passRate": "66.28%",
        "problemsUrl": "https://leetcode.cn/problems/count-special-quadruplets/",
        "solutionsUrl": "https://leetcode.cn/problems/count-special-quadruplets/solution",
        "problemsDesc": "<p>给你一个 <strong>下标从 0 开始</strong> 的整数数组 <code>nums</code> ，返回满足下述条件的 <strong>不同</strong> 四元组 <code>(a, b, c, d)</code> 的 <strong>数目</strong> ：</p>\n\n<ul>\n\t<li><code>nums[a] + nums[b] + nums[c] == nums[d]</code> ，且</li>\n\t<li><code>a &lt; b &lt; c &lt; d</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,6]\n<strong>输出：</strong>1\n<strong>解释：</strong>满足要求的唯一一个四元组是 (0, 1, 2, 3) 因为 1 + 2 + 3 == 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,3,6,4,5]\n<strong>输出：</strong>0\n<strong>解释：</strong>[3,3,6,4,5] 中不存在满足要求的四元组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,1,3,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>满足要求的 4 个四元组如下：\n- (0, 1, 2, 3): 1 + 1 + 1 == 3\n- (0, 1, 3, 4): 1 + 1 + 3 == 5\n- (0, 2, 3, 4): 1 + 1 + 3 == 5\n- (1, 2, 3, 4): 1 + 1 + 3 == 5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>4 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1996游戏中弱角色的数量",
        "hardRate": "MEDIUM",
        "passRate": "41.49%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-weak-characters-in-the-game/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-weak-characters-in-the-game/solution",
        "problemsDesc": "<p>你正在参加一个多角色游戏，每个角色都有两个主要属性：<strong>攻击</strong> 和 <strong>防御</strong> 。给你一个二维整数数组 <code>properties</code> ，其中 <code>properties[i] = [attack<sub>i</sub>, defense<sub>i</sub>]</code> 表示游戏中第 <code>i</code> 个角色的属性。</p>\n\n<p>如果存在一个其他角色的攻击和防御等级 <strong>都严格高于</strong> 该角色的攻击和防御等级，则认为该角色为 <strong>弱角色</strong> 。更正式地，如果认为角色 <code>i</code> <strong>弱于</strong> 存在的另一个角色 <code>j</code> ，那么 <code>attack<sub>j</sub> &gt; attack<sub>i</sub></code> 且 <code>defense<sub>j</sub> &gt; defense<sub>i</sub></code> 。</p>\n\n<p>返回 <strong>弱角色</strong> 的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>properties = [[5,5],[6,3],[3,6]]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在攻击和防御都严格高于其他角色的角色。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>properties = [[2,2],[3,3]]\n<strong>输出：</strong>1\n<strong>解释：</strong>第一个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>properties = [[1,5],[10,4],[4,3]]\n<strong>输出：</strong>1\n<strong>解释：</strong>第三个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= properties.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>properties[i].length == 2</code></li>\n\t<li><code>1 &lt;= attack<sub>i</sub>, defense<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1997访问完所有房间的第一天",
        "hardRate": "MEDIUM",
        "passRate": "35.24%",
        "problemsUrl": "https://leetcode.cn/problems/first-day-where-you-have-been-in-all-the-rooms/",
        "solutionsUrl": "https://leetcode.cn/problems/first-day-where-you-have-been-in-all-the-rooms/solution",
        "problemsDesc": "<p>你需要访问&nbsp;<code>n</code> 个房间，房间从 <code>0</code> 到 <code>n - 1</code> 编号。同时，每一天都有一个日期编号，从 <code>0</code> 开始，依天数递增。你每天都会访问一个房间。</p>\n\n<p>最开始的第 <code>0</code> 天，你访问&nbsp;<code>0</code> 号房间。给你一个长度为 <code>n</code> 且 <strong>下标从 0 开始</strong> 的数组 <code>nextVisit</code> 。在接下来的几天中，你访问房间的 <strong>次序</strong> 将根据下面的 <strong>规则</strong> 决定：</p>\n\n<ul>\n\t<li>假设某一天，你访问&nbsp;<code>i</code> 号房间。</li>\n\t<li>如果算上本次访问，访问&nbsp;<code>i</code> 号房间的次数为 <strong>奇数</strong> ，那么 <strong>第二天</strong> 需要访问&nbsp;<code>nextVisit[i]</code> 所指定的房间，其中 <code>0 &lt;= nextVisit[i] &lt;= i</code> 。</li>\n\t<li>如果算上本次访问，访问&nbsp;<code>i</code> 号房间的次数为 <strong>偶数</strong> ，那么 <strong>第二天</strong> 需要访问&nbsp;<code>(i + 1) mod n</code> 号房间。</li>\n</ul>\n\n<p>请返回你访问完所有房间的第一天的日期编号。题目数据保证总是存在这样的一天。由于答案可能很大，返回对 <code>10<sup>9</sup> + 7</code> 取余后的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nextVisit = [0,0]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n- 第 0 天，你访问房间 0 。访问 0 号房间的总次数为 1 ，次数为奇数。\n&nbsp; 下一天你需要访问房间的编号是 nextVisit[0] = 0\n- 第 1 天，你访问房间 0 。访问 0 号房间的总次数为 2 ，次数为偶数。\n&nbsp; 下一天你需要访问房间的编号是 (0 + 1) mod 2 = 1\n- 第 2 天，你访问房间 1 。这是你第一次完成访问所有房间的那天。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nextVisit = [0,0,2]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n你每天访问房间的次序是 [0,0,1,0,0,1,2,...] 。\n第 6 天是你访问完所有房间的第一天。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nextVisit = [0,1,2,0]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n你每天访问房间的次序是 [0,0,1,1,2,2,3,...] 。\n第 6 天是你访问完所有房间的第一天。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nextVisit.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nextVisit[i] &lt;= i</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1998数组的最大公因数排序",
        "hardRate": "HARD",
        "passRate": "45.84%",
        "problemsUrl": "https://leetcode.cn/problems/gcd-sort-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/gcd-sort-of-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，你可以在 <code>nums</code> 上执行下述操作 <strong>任意次</strong> ：</p>\n\n<ul>\n\t<li>如果 <code>gcd(nums[i], nums[j]) &gt; 1</code> ，交换 <code>nums[i]</code> 和 <code>nums[j]</code> 的位置。其中 <code>gcd(nums[i], nums[j])</code> 是&nbsp;<code>nums[i]</code> 和 <code>nums[j]</code> 的最大公因数。</li>\n</ul>\n\n<p>如果能使用上述交换方式将 <code>nums</code> 按 <strong>非递减顺序</strong> 排列，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [7,21,3]\n<strong>输出：</strong>true\n<strong>解释：</strong>可以执行下述操作完成对 [7,21,3] 的排序：\n- 交换 7 和 21 因为 gcd(7,21) = 7 。nums = [<em><strong>21</strong></em>,<em><strong>7</strong></em>,3]\n- 交换 21 和 3 因为 gcd(21,3) = 3 。nums = [<em><strong>3</strong></em>,7,<em><strong>21</strong></em>]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,2,6,2]\n<strong>输出：</strong>false\n<strong>解释：</strong>无法完成排序，因为 5 不能与其他元素交换。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [10,5,9,3,15]\n<strong>输出：</strong>true\n<strong>解释：</strong>\n可以执行下述操作完成对 [10,5,9,3,15] 的排序：\n- 交换 10 和 15 因为 gcd(10,15) = 5 。nums = [<em><strong>15</strong></em>,5,9,3,<em><strong>10</strong></em>]\n- 交换 15 和 3 因为 gcd(15,3) = 3 。nums = [<em><strong>3</strong></em>,5,9,<em><strong>15</strong></em>,10]\n- 交换 10 和 15 因为 gcd(10,15) = 5 。nums = [3,5,9,<em><strong>10</strong></em>,<em><strong>15</strong></em>]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>2 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1999最小的仅由两个数组成的倍数",
        "hardRate": "MEDIUM",
        "passRate": "47.00%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-greater-multiple-made-of-two-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-greater-multiple-made-of-two-digits/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2000反转单词前缀",
        "hardRate": "EASY",
        "passRate": "77.43%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-prefix-of-word/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-prefix-of-word/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>word</code> 和一个字符 <code>ch</code> 。找出 <code>ch</code> 第一次出现的下标 <code>i</code> ，<strong>反转 </strong><code>word</code> 中从下标 <code>0</code> 开始、直到下标 <code>i</code> 结束（含下标 <code>i</code> ）的那段字符。如果 <code>word</code> 中不存在字符 <code>ch</code> ，则无需进行任何操作。</p>\n\n<ul>\n\t<li>例如，如果 <code>word = \"abcdefd\"</code> 且 <code>ch = \"d\"</code> ，那么你应该 <strong>反转</strong> 从下标 0 开始、直到下标 <code>3</code> 结束（含下标 <code>3</code> ）。结果字符串将会是 <code>\"<em><strong>dcba</strong></em>efd\"</code> 。</li>\n</ul>\n\n<p>返回 <strong>结果字符串</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>word = \"<em><strong>abcd</strong></em>efd\", ch = \"d\"\n<strong>输出：</strong>\"<em><strong>dcba</strong></em>efd\"\n<strong>解释：</strong>\"d\" 第一次出现在下标 3 。 \n反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 \"dcbaefd\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>word = \"<em><strong>xyxz</strong></em>xe\", ch = \"z\"\n<strong>输出：</strong>\"<em><strong>zxyx</strong></em>xe\"\n<strong>解释：</strong>\"z\" 第一次也是唯一一次出现是在下标 3 。\n反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 \"zxyxxe\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>word = \"abcd\", ch = \"z\"\n<strong>输出：</strong>\"abcd\"\n<strong>解释：</strong>\"z\" 不存在于 word 中。\n无需执行反转操作，结果字符串是 \"abcd\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 250</code></li>\n\t<li><code>word</code> 由小写英文字母组成</li>\n\t<li><code>ch</code> 是一个小写英文字母</li>\n</ul>\n",
        "isPlus": false
    }
]