[
    {
        "problemsName": " 2401.最长优雅子数组",
        "hardRate": "MEDIUM",
        "passRate": "49.63%",
        "problemsUrl": "https://leetcode.cn/problems/longest-nice-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-nice-subarray/solution",
        "problemsDesc": "<p>给你一个由 <strong>正</strong> 整数组成的数组 <code>nums</code> 。</p>\n\n<p>如果&nbsp;<code>nums</code> 的子数组中位于 <strong>不同</strong> 位置的每对元素按位 <strong>与（AND）</strong>运算的结果等于 <code>0</code> ，则称该子数组为 <strong>优雅</strong> 子数组。</p>\n\n<p>返回 <strong>最长</strong> 的优雅子数组的长度。</p>\n\n<p><strong>子数组</strong> 是数组中的一个 <strong>连续</strong> 部分。</p>\n\n<p><strong>注意：</strong>长度为 <code>1</code> 的子数组始终视作优雅子数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3,8,48,10]\n<strong>输出：</strong>3\n<strong>解释：</strong>最长的优雅子数组是 [3,8,48] 。子数组满足题目条件：\n- 3 AND 8 = 0\n- 3 AND 48 = 0\n- 8 AND 48 = 0\n可以证明不存在更长的优雅子数组，所以返回 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,1,5,11,13]\n<strong>输出：</strong>1\n<strong>解释：</strong>最长的优雅子数组长度为 1 ，任何长度为 1 的子数组都满足题目条件。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2402.会议室 III",
        "hardRate": "HARD",
        "passRate": "32.57%",
        "problemsUrl": "https://leetcode.cn/problems/meeting-rooms-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/meeting-rooms-iii/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，共有编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个会议室。</p>\n\n<p>给你一个二维整数数组 <code>meetings</code> ，其中 <code>meetings[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 表示一场会议将会在 <strong>半闭</strong> 时间区间 <code>[start<sub>i</sub>, end<sub>i</sub>)</code> 举办。所有 <code>start<sub>i</sub></code> 的值 <strong>互不相同</strong> 。</p>\n\n<p>会议将会按以下方式分配给会议室：</p>\n\n<ol>\n\t<li>每场会议都会在未占用且编号 <strong>最小</strong> 的会议室举办。</li>\n\t<li>如果没有可用的会议室，会议将会延期，直到存在空闲的会议室。延期会议的持续时间和原会议持续时间 <strong>相同</strong> 。</li>\n\t<li>当会议室处于未占用状态时，将会优先提供给原 <strong>开始</strong> 时间更早的会议。</li>\n</ol>\n\n<p>返回举办最多次会议的房间 <strong>编号</strong> 。如果存在多个房间满足此条件，则返回编号 <strong>最小</strong> 的房间。</p>\n\n<p><strong>半闭区间 </strong><code>[a, b)</code> 是 <code>a</code> 和 <code>b</code> 之间的区间，<strong>包括</strong> <code>a</code> 但<strong> 不包括</strong> <code>b</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, meetings = [[0,10],[1,5],[2,7],[3,4]]\n<strong>输出：</strong>0\n<strong>解释：</strong>\n- 在时间 0 ，两个会议室都未占用，第一场会议在会议室 0 举办。\n- 在时间 1 ，只有会议室 1 未占用，第二场会议在会议室 1 举办。\n- 在时间 2 ，两个会议室都被占用，第三场会议延期举办。\n- 在时间 3 ，两个会议室都被占用，第四场会议延期举办。\n- 在时间 5 ，会议室 1 的会议结束。第三场会议在会议室 1 举办，时间周期为 [5,10) 。\n- 在时间 10 ，两个会议室的会议都结束。第四场会议在会议室 0 举办，时间周期为 [10,11) 。\n会议室 0 和会议室 1 都举办了 2 场会议，所以返回 0 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n- 在时间 1 ，所有三个会议室都未占用，第一场会议在会议室 0 举办。\n- 在时间 2 ，会议室 1 和 2 未占用，第二场会议在会议室 1 举办。\n- 在时间 3 ，只有会议室 2 未占用，第三场会议在会议室 2 举办。\n- 在时间 4 ，所有三个会议室都被占用，第四场会议延期举办。 \n- 在时间 5 ，会议室 2 的会议结束。第四场会议在会议室 2 举办，时间周期为 [5,10) 。\n- 在时间 6 ，所有三个会议室都被占用，第五场会议延期举办。 \n- 在时间 10 ，会议室 1 和 2 的会议结束。第五场会议在会议室 1 举办，时间周期为 [10,12) 。 \n会议室 1 和会议室 2 都举办了 2 场会议，所以返回 1 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= meetings.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>meetings[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt; end<sub>i</sub> &lt;= 5 * 10<sup>5</sup></code></li>\n\t<li><code>start<sub>i</sub></code> 的所有值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2403.杀死所有怪物的最短时间",
        "hardRate": "HARD",
        "passRate": "70.04%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-kill-all-monsters/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-kill-all-monsters/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2404.出现最频繁的偶数元素",
        "hardRate": "EASY",
        "passRate": "58.33%",
        "problemsUrl": "https://leetcode.cn/problems/most-frequent-even-element/",
        "solutionsUrl": "https://leetcode.cn/problems/most-frequent-even-element/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，返回出现最频繁的偶数元素。</p>\n\n<p>如果存在多个满足条件的元素，只需要返回 <strong>最小</strong> 的一个。如果不存在这样的元素，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,2,2,4,4,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n数组中的偶数元素为 0、2 和 4 ，在这些元素中，2 和 4 出现次数最多。\n返回最小的那个，即返回 2 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,4,4,9,2,4]\n<strong>输出：</strong>4\n<strong>解释：</strong>4 是出现最频繁的偶数元素。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [29,47,21,41,13,37,25,7]\n<strong>输出：</strong>-1\n<strong>解释：</strong>不存在偶数元素。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2405.子字符串的最优划分",
        "hardRate": "MEDIUM",
        "passRate": "74.89%",
        "problemsUrl": "https://leetcode.cn/problems/optimal-partition-of-string/",
        "solutionsUrl": "https://leetcode.cn/problems/optimal-partition-of-string/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，请你将该字符串划分成一个或多个 <strong>子字符串</strong> ，并满足每个子字符串中的字符都是 <strong>唯一</strong> 的。也就是说，在单个子字符串中，字母的出现次数都不超过 <strong>一次</strong> 。</p>\n\n<p>满足题目要求的情况下，返回 <strong>最少</strong> 需要划分多少个子字符串<em>。</em></p>\n\n<p>注意，划分后，原字符串中的每个字符都应该恰好属于一个子字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abacaba\"\n<strong>输出：</strong>4\n<strong>解释：</strong>\n两种可行的划分方法分别是 (\"a\",\"ba\",\"cab\",\"a\") 和 (\"ab\",\"a\",\"ca\",\"ba\") 。\n可以证明最少需要划分 4 个子字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ssssss\"\n<strong>输出：</strong>6\n<strong>解释：\n</strong>只存在一种可行的划分方法 (\"s\",\"s\",\"s\",\"s\",\"s\",\"s\") 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2406.将区间分为最少组数",
        "hardRate": "MEDIUM",
        "passRate": "44.66%",
        "problemsUrl": "https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/solution",
        "problemsDesc": "<p>给你一个二维整数数组&nbsp;<code>intervals</code>&nbsp;，其中&nbsp;<code>intervals[i] = [left<sub>i</sub>, right<sub>i</sub>]</code>&nbsp;表示 <strong>闭</strong>&nbsp;区间&nbsp;<code>[left<sub>i</sub>, right<sub>i</sub>]</code>&nbsp;。</p>\n\n<p>你需要将&nbsp;<code>intervals</code> 划分为一个或者多个区间&nbsp;<strong>组</strong>&nbsp;，每个区间 <b>只</b>&nbsp;属于一个组，且同一个组中任意两个区间 <strong>不相交</strong>&nbsp;。</p>\n\n<p>请你返回 <strong>最少</strong>&nbsp;需要划分成多少个组。</p>\n\n<p>如果两个区间覆盖的范围有重叠（即至少有一个公共数字），那么我们称这两个区间是 <strong>相交</strong>&nbsp;的。比方说区间&nbsp;<code>[1, 5]</code> 和&nbsp;<code>[5, 8]</code>&nbsp;相交。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>intervals = [[5,10],[6,8],[1,5],[2,3],[1,10]]\n<b>输出：</b>3\n<b>解释：</b>我们可以将区间划分为如下的区间组：\n- 第 1 组：[1, 5] ，[6, 8] 。\n- 第 2 组：[2, 3] ，[5, 10] 。\n- 第 3 组：[1, 10] 。\n可以证明无法将区间划分为少于 3 个组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>intervals = [[1,3],[5,6],[8,10],[11,13]]\n<b>输出：</b>1\n<b>解释：</b>所有区间互不相交，所以我们可以把它们全部放在一个组内。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>1 &lt;= left<sub>i</sub> &lt;= right<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2407.最长递增子序列 II",
        "hardRate": "HARD",
        "passRate": "30.56%",
        "problemsUrl": "https://leetcode.cn/problems/longest-increasing-subsequence-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-increasing-subsequence-ii/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>找到&nbsp;<code>nums</code>&nbsp;中满足以下要求的最长子序列：</p>\n\n<ul>\n\t<li>子序列 <strong>严格递增</strong></li>\n\t<li>子序列中相邻元素的差值 <strong>不超过</strong>&nbsp;<code>k</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回满足上述要求的 <strong>最长子序列</strong>&nbsp;的长度。</p>\n\n<p><strong>子序列</strong>&nbsp;是从一个数组中删除部分元素后，剩余元素不改变顺序得到的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [4,2,1,4,3,4,5,8,15], k = 3\n<b>输出：</b>5\n<strong>解释：</strong>\n满足要求的最长子序列是 [1,3,4,5,8] 。\n子序列长度为 5 ，所以我们返回 5 。\n注意子序列 [1,3,4,5,8,15] 不满足要求，因为 15 - 8 = 7 大于 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [7,4,5,1,8,12,4,7], k = 5\n<b>输出：</b>4\n<strong>解释：</strong>\n满足要求的最长子序列是 [4,5,8,12] 。\n子序列长度为 4 ，所以我们返回 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [1,5], k = 1\n<b>输出：</b>1\n<strong>解释：</strong>\n满足要求的最长子序列是 [1] 。\n子序列长度为 1 ，所以我们返回 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2408.设计 SQL",
        "hardRate": "MEDIUM",
        "passRate": "64.04%",
        "problemsUrl": "https://leetcode.cn/problems/design-sql/",
        "solutionsUrl": "https://leetcode.cn/problems/design-sql/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2409.统计共同度过的日子数",
        "hardRate": "EASY",
        "passRate": "55.94%",
        "problemsUrl": "https://leetcode.cn/problems/count-days-spent-together/",
        "solutionsUrl": "https://leetcode.cn/problems/count-days-spent-together/solution",
        "problemsDesc": "<p>Alice 和 Bob 计划分别去罗马开会。</p>\n\n<p>给你四个字符串&nbsp;<code>arriveAlice</code>&nbsp;，<code>leaveAlice</code>&nbsp;，<code>arriveBob</code>&nbsp;和&nbsp;<code>leaveBob</code>&nbsp;。Alice 会在日期&nbsp;<code>arriveAlice</code>&nbsp;到&nbsp;<code>leaveAlice</code>&nbsp;之间在城市里（<strong>日期为闭区间</strong>），而 Bob 在日期&nbsp;<code>arriveBob</code>&nbsp;到&nbsp;<code>leaveBob</code>&nbsp;之间在城市里（<strong>日期为闭区间</strong>）。每个字符串都包含 5 个字符，格式为&nbsp;<code>\"MM-DD\"</code>&nbsp;，对应着一个日期的月和日。</p>\n\n<p>请你返回 Alice和 Bob 同时在罗马的天数。</p>\n\n<p>你可以假设所有日期都在 <strong>同一个</strong>&nbsp;自然年，而且 <strong>不是</strong>&nbsp;闰年。每个月份的天数分别为：<code>[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>arriveAlice = \"08-15\", leaveAlice = \"08-18\", arriveBob = \"08-16\", leaveBob = \"08-19\"\n<b>输出：</b>3\n<b>解释：</b>Alice 从 8 月 15 号到 8 月 18 号在罗马。Bob 从 8 月 16 号到 8 月 19 号在罗马，他们同时在罗马的日期为 8 月 16、17 和 18 号。所以答案为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>arriveAlice = \"10-01\", leaveAlice = \"10-31\", arriveBob = \"11-01\", leaveBob = \"12-31\"\n<b>输出：</b>0\n<b>解释：</b>Alice 和 Bob 没有同时在罗马的日子，所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>所有日期的格式均为&nbsp;<code>\"MM-DD\"</code>&nbsp;。</li>\n\t<li>Alice 和 Bob 的到达日期都 <strong>早于或等于</strong> 他们的离开日期。</li>\n\t<li>题目测试用例所给出的日期均为 <strong>非闰年</strong> 的有效日期。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2410.运动员和训练师的最大匹配数",
        "hardRate": "MEDIUM",
        "passRate": "64.77%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-matching-of-players-with-trainers/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-matching-of-players-with-trainers/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>players</code>&nbsp;，其中&nbsp;<code>players[i]</code>&nbsp;表示第 <code>i</code>&nbsp;名运动员的 <strong>能力</strong>&nbsp;值，同时给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>trainers</code>&nbsp;，其中&nbsp;<code>trainers[j]</code>&nbsp;表示第 <code>j</code>&nbsp;名训练师的 <strong>训练能力值</strong>&nbsp;。</p>\n\n<p>如果第 <code>i</code>&nbsp;名运动员的能力值 <strong>小于等于</strong>&nbsp;第 <code>j</code>&nbsp;名训练师的能力值，那么第&nbsp;<code>i</code>&nbsp;名运动员可以 <strong>匹配</strong>&nbsp;第&nbsp;<code>j</code>&nbsp;名训练师。除此以外，每名运动员至多可以匹配一位训练师，每位训练师最多可以匹配一位运动员。</p>\n\n<p>请你返回满足上述要求&nbsp;<code>players</code>&nbsp;和 <code>trainers</code>&nbsp;的 <strong>最大</strong> 匹配数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>players = [4,7,9], trainers = [8,2,5,8]\n<b>输出：</b>2\n<b>解释：</b>\n得到两个匹配的一种方案是：\n- players[0] 与 trainers[0] 匹配，因为 4 &lt;= 8 。\n- players[1] 与 trainers[3] 匹配，因为 7 &lt;= 8 。\n可以证明 2 是可以形成的最大匹配数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>players = [1,1,1], trainers = [10]\n<b>输出：</b>1\n<b>解释：</b>\n训练师可以匹配所有 3 个运动员\n每个运动员至多只能匹配一个训练师，所以最大答案是 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= players.length, trainers.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= players[i], trainers[j] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2411.按位或最大的最小子数组长度",
        "hardRate": "MEDIUM",
        "passRate": "43.24%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>nums</code>&nbsp;，数组中所有数字均为非负整数。对于&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;之间的每一个下标 <code>i</code>&nbsp;，你需要找出&nbsp;<code>nums</code>&nbsp;中一个 <strong>最小</strong> 非空子数组，它的起始位置为&nbsp;<code>i</code>&nbsp;（包含这个位置），同时有&nbsp;<strong>最大</strong>&nbsp;的 <strong>按位或</strong><b>运算值</b>&nbsp;。</p>\n\n<ul>\n\t<li>换言之，令&nbsp;<code>B<sub>ij</sub></code>&nbsp;表示子数组&nbsp;<code>nums[i...j]</code>&nbsp;的按位或运算的结果，你需要找到一个起始位置为&nbsp;<code>i</code>&nbsp;的最小子数组，这个子数组的按位或运算的结果等于&nbsp;<code>max(B<sub>ik</sub>)</code>&nbsp;，其中&nbsp;<code>i &lt;= k &lt;= n - 1</code>&nbsp;。</li>\n</ul>\n\n<p>一个数组的按位或运算值是这个数组里所有数字按位或运算的结果。</p>\n\n<p>请你返回一个大小为 <code>n</code>&nbsp;的整数数组<em>&nbsp;</em><code>answer</code>，其中<em>&nbsp;</em><code>answer[i]</code>是开始位置为&nbsp;<code>i</code>&nbsp;，按位或运算结果最大，且&nbsp;<strong>最短</strong>&nbsp;子数组的长度。</p>\n\n<p><strong>子数组</strong>&nbsp;是数组里一段连续非空元素组成的序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,0,2,1,3]\n<b>输出：</b>[3,3,2,2,1]\n<strong>解释：</strong>\n任何位置开始，最大按位或运算的结果都是 3 。\n- 下标 0 处，能得到结果 3 的最短子数组是 [1,0,2] 。\n- 下标 1 处，能得到结果 3 的最短子数组是 [0,2,1] 。\n- 下标 2 处，能得到结果 3 的最短子数组是 [2,1] 。\n- 下标 3 处，能得到结果 3 的最短子数组是 [1,3] 。\n- 下标 4 处，能得到结果 3 的最短子数组是 [3] 。\n所以我们返回 [3,3,2,2,1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2]\n<b>输出：</b>[2,1]\n<strong>解释：\n</strong>下标 0 处，能得到最大按位或运算值的最短子数组长度为 2 。\n下标 1 处，能得到最大按位或运算值的最短子数组长度为 1 。\n所以我们返回 [2,1] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2412.完成所有交易的初始最少钱数",
        "hardRate": "HARD",
        "passRate": "48.25%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-money-required-before-transactions/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-money-required-before-transactions/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code><font face=\"monospace\">transactions</font></code>，其中<code>transactions[i] = [cost<sub>i</sub>, cashback<sub>i</sub>]</code>&nbsp;。</p>\n\n<p>数组描述了若干笔交易。其中每笔交易必须以 <strong>某种顺序</strong> 恰好完成一次。在任意一个时刻，你有一定数目的钱&nbsp;<code>money</code>&nbsp;，为了完成交易&nbsp;<code>i</code>&nbsp;，<code>money &gt;= cost<sub>i</sub></code>&nbsp;这个条件必须为真。执行交易后，你的钱数&nbsp;<code>money</code> 变成&nbsp;<code>money - cost<sub>i</sub> + cashback<sub>i</sub></code><sub>&nbsp;</sub>。</p>\n\n<p>请你返回 <strong>任意一种</strong> 交易顺序下，你都能完成所有交易的最少钱数<em>&nbsp;</em><code>money</code>&nbsp;是多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>transactions = [[2,1],[5,0],[4,2]]\n<b>输出：</b>10\n<strong>解释：\n</strong>刚开始 money = 10 ，交易可以以任意顺序进行。\n可以证明如果 money &lt; 10 ，那么某些交易无法进行。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>transactions = [[3,0],[0,3]]\n<b>输出：</b>3\n<strong>解释：</strong>\n- 如果交易执行的顺序是 [[3,0],[0,3]] ，完成所有交易需要的最少钱数是 3 。\n- 如果交易执行的顺序是 [[0,3],[3,0]] ，完成所有交易需要的最少钱数是 0 。\n所以，刚开始钱数为 3 ，任意顺序下交易都可以全部完成。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= transactions.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>transactions[i].length == 2</code></li>\n\t<li><code>0 &lt;= cost<sub>i</sub>, cashback<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2413.最小偶倍数",
        "hardRate": "EASY",
        "passRate": "87.57%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-even-multiple/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-even-multiple/solution",
        "problemsDesc": "给你一个正整数 <code>n</code> ，返回 <code>2</code><em> </em>和<em> </em><code>n</code> 的最小公倍数（正整数）。\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 5\n<strong>输出：</strong>10\n<strong>解释：</strong>5 和 2 的最小公倍数是 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 6\n<strong>输出：</strong>6\n<strong>解释：</strong>6 和 2 的最小公倍数是 6 。注意数字会是它自身的倍数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 150</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2414.最长的字母序连续子字符串的长度",
        "hardRate": "MEDIUM",
        "passRate": "60.42%",
        "problemsUrl": "https://leetcode.cn/problems/length-of-the-longest-alphabetical-continuous-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/length-of-the-longest-alphabetical-continuous-substring/solution",
        "problemsDesc": "<p><strong>字母序连续字符串</strong> 是由字母表中连续字母组成的字符串。换句话说，字符串 <code>\"abcdefghijklmnopqrstuvwxyz\"</code> 的任意子字符串都是 <strong>字母序连续字符串</strong> 。</p>\n\n<ul>\n\t<li>例如，<code>\"abc\"</code> 是一个字母序连续字符串，而 <code>\"acb\"</code> 和 <code>\"za\"</code> 不是。</li>\n</ul>\n\n<p>给你一个仅由小写英文字母组成的字符串 <code>s</code> ，返回其 <strong>最长</strong> 的 字母序连续子字符串 的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abacaba\"\n<strong>输出：</strong>2\n<strong>解释：</strong>共有 4 个不同的字母序连续子字符串 \"a\"、\"b\"、\"c\" 和 \"ab\" 。\n\"ab\" 是最长的字母序连续子字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abcde\"\n<strong>输出：</strong>5\n<strong>解释：</strong>\"abcde\" 是最长的字母序连续子字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2415.反转二叉树的奇数层",
        "hardRate": "MEDIUM",
        "passRate": "70.06%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-odd-levels-of-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-odd-levels-of-binary-tree/solution",
        "problemsDesc": "<p>给你一棵 <strong>完美</strong> 二叉树的根节点 <code>root</code> ，请你反转这棵树中每个 <strong>奇数</strong> 层的节点值。</p>\n\n<ul>\n\t<li>例如，假设第 3 层的节点值是 <code>[2,1,3,4,7,11,29,18]</code> ，那么反转后它应该变成 <code>[18,29,11,7,4,3,1,2]</code> 。</li>\n</ul>\n\n<p>反转后，返回树的根节点。</p>\n\n<p><strong>完美</strong> 二叉树需满足：二叉树的所有父节点都有两个子节点，且所有叶子节点都在同一层。</p>\n\n<p>节点的 <strong>层数</strong> 等于该节点到根节点之间的边数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/28/first_case1.png\" style=\"width: 626px; height: 191px;\" />\n<pre>\n<strong>输入：</strong>root = [2,3,5,8,13,21,34]\n<strong>输出：</strong>[2,5,3,8,13,21,34]\n<strong>解释：</strong>\n这棵树只有一个奇数层。\n在第 1 层的节点分别是 3、5 ，反转后为 5、3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/28/second_case3.png\" style=\"width: 591px; height: 111px;\" />\n<pre>\n<strong>输入：</strong>root = [7,13,11]\n<strong>输出：</strong>[7,11,13]\n<strong>解释：</strong> \n在第 1 层的节点分别是 13、11 ，反转后为 11、13 。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]\n<strong>输出：</strong>[0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]\n<strong>解释：</strong>奇数层由非零值组成。\n在第 1 层的节点分别是 1、2 ，反转后为 2、1 。\n在第 3 层的节点分别是 1、1、1、1、2、2、2、2 ，反转后为 2、2、2、2、1、1、1、1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数目在范围 <code>[1, 2<sup>14</sup>]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>root</code> 是一棵 <strong>完美</strong> 二叉树</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2416.字符串的前缀分数和",
        "hardRate": "HARD",
        "passRate": "40.58%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的数组 <code>words</code> ，该数组由 <strong>非空</strong> 字符串组成。</p>\n\n<p>定义字符串 <code>word</code> 的 <strong>分数</strong> 等于以 <code>word</code> 作为 <strong>前缀</strong> 的 <code>words[i]</code> 的数目。</p>\n\n<ul>\n\t<li>例如，如果 <code>words = [\"a\", \"ab\", \"abc\", \"cab\"]</code> ，那么 <code>\"ab\"</code> 的分数是 <code>2</code> ，因为 <code>\"ab\"</code> 是 <code>\"ab\"</code> 和 <code>\"abc\"</code> 的一个前缀。</li>\n</ul>\n\n<p>返回一个长度为<em> </em><code>n</code> 的数组<em> </em><code>answer</code><em> </em>，其中<em> </em><code>answer[i]</code><em> </em>是<em>&nbsp;</em><code>words[i]</code> 的每个非空前缀的分数 <strong>总和</strong> <em>。</em></p>\n\n<p><strong>注意：</strong>字符串视作它自身的一个前缀。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"abc\",\"ab\",\"bc\",\"b\"]\n<strong>输出：</strong>[5,4,3,2]\n<strong>解释：</strong>对应每个字符串的答案如下：\n- \"abc\" 有 3 个前缀：\"a\"、\"ab\" 和 \"abc\" 。\n- 2 个字符串的前缀为 \"a\" ，2 个字符串的前缀为 \"ab\" ，1 个字符串的前缀为 \"abc\" 。\n总计 answer[0] = 2 + 2 + 1 = 5 。\n- \"ab\" 有 2 个前缀：\"a\" 和 \"ab\" 。\n- 2 个字符串的前缀为 \"a\" ，2 个字符串的前缀为 \"ab\" 。\n总计 answer[1] = 2 + 2 = 4 。\n- \"bc\" 有 2 个前缀：\"b\" 和 \"bc\" 。\n- 2 个字符串的前缀为 \"b\" ，1 个字符串的前缀为 \"bc\" 。 \n总计 answer[2] = 2 + 1 = 3 。\n- \"b\" 有 1 个前缀：\"b\"。\n- 2 个字符串的前缀为 \"b\" 。\n总计 answer[3] = 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"abcd\"]\n<strong>输出：</strong>[4]\n<strong>解释：</strong>\n\"abcd\" 有 4 个前缀 \"a\"、\"ab\"、\"abc\" 和 \"abcd\"。\n每个前缀的分数都是 1 ，总计 answer[0] = 1 + 1 + 1 + 1 = 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 1000</code></li>\n\t<li><code>words[i]</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2417.最近的公平整数",
        "hardRate": "MEDIUM",
        "passRate": "45.48%",
        "problemsUrl": "https://leetcode.cn/problems/closest-fair-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-fair-integer/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2418.按身高排序",
        "hardRate": "EASY",
        "passRate": "79.41%",
        "problemsUrl": "https://leetcode.cn/problems/sort-the-people/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-the-people/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>names</code> ，和一个由 <strong>互不相同</strong> 的正整数组成的数组 <code>heights</code> 。两个数组的长度均为 <code>n</code> 。</p>\n\n<p>对于每个下标 <code>i</code>，<code>names[i]</code> 和 <code>heights[i]</code> 表示第 <code>i</code> 个人的名字和身高。</p>\n\n<p>请按身高 <strong>降序</strong> 顺序返回对应的名字数组 <code>names</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>names = [\"Mary\",\"John\",\"Emma\"], heights = [180,165,170]\n<strong>输出：</strong>[\"Mary\",\"Emma\",\"John\"]\n<strong>解释：</strong>Mary 最高，接着是 Emma 和 John 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>names = [\"Alice\",\"Bob\",\"Bob\"], heights = [155,185,150]\n<strong>输出：</strong>[\"Bob\",\"Alice\",\"Bob\"]\n<strong>解释：</strong>第一个 Bob 最高，然后是 Alice 和第二个 Bob 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == names.length == heights.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>3</sup></code></li>\n\t<li><code>1 &lt;= names[i].length &lt;= 20</code></li>\n\t<li><code>1 &lt;= heights[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>names[i]</code> 由大小写英文字母组成</li>\n\t<li><code>heights</code> 中的所有值互不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2419.按位与最大的最长子数组",
        "hardRate": "MEDIUM",
        "passRate": "42.57%",
        "problemsUrl": "https://leetcode.cn/problems/longest-subarray-with-maximum-bitwise-and/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-subarray-with-maximum-bitwise-and/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 。</p>\n\n<p>考虑 <code>nums</code> 中进行 <strong>按位与（bitwise AND）</strong>运算得到的值 <strong>最大</strong> 的 <strong>非空</strong> 子数组。</p>\n\n<ul>\n\t<li>换句话说，令 <code>k</code> 是 <code>nums</code> <strong>任意</strong> 子数组执行按位与运算所能得到的最大值。那么，只需要考虑那些执行一次按位与运算后等于 <code>k</code> 的子数组。</li>\n</ul>\n\n<p>返回满足要求的 <strong>最长</strong> 子数组的长度。</p>\n\n<p>数组的按位与就是对数组中的所有数字进行按位与运算。</p>\n\n<p><strong>子数组</strong> 是数组中的一个连续元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,3,2,2]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n子数组按位与运算的最大值是 3 。\n能得到此结果的最长子数组是 [3,3]，所以返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n子数组按位与运算的最大值是 4 。 \n能得到此结果的最长子数组是 [4]，所以返回 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2420.找到所有好下标",
        "hardRate": "MEDIUM",
        "passRate": "31.39%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-good-indices/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-good-indices/solution",
        "problemsDesc": "<p>给你一个大小为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;和一个正整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>对于&nbsp;<code>k &lt;= i &lt; n - k</code>&nbsp;之间的一个下标&nbsp;<code>i</code>&nbsp;，如果它满足以下条件，我们就称它为一个&nbsp;<strong>好</strong>&nbsp;下标：</p>\n\n<ul>\n\t<li>下标 <code>i</code> <strong>之前</strong> 的 <code>k</code>&nbsp;个元素是 <strong>非递增的</strong>&nbsp;。</li>\n\t<li>下标 <code>i</code> <strong>之后</strong>&nbsp;的 <code>k</code>&nbsp;个元素是 <strong>非递减的</strong>&nbsp;。</li>\n</ul>\n\n<p>按 <strong>升序</strong>&nbsp;返回所有好下标。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,1,1,1,3,4,1], k = 2\n<b>输出：</b>[2,3]\n<b>解释：</b>数组中有两个好下标：\n- 下标 2 。子数组 [2,1] 是非递增的，子数组 [1,3] 是非递减的。\n- 下标 3 。子数组 [1,1] 是非递增的，子数组 [3,4] 是非递减的。\n注意，下标 4 不是好下标，因为 [4,1] 不是非递减的。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,1,1,2], k = 2\n<b>输出：</b>[]\n<b>解释：</b>数组中没有好下标。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n / 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2421.好路径的数目",
        "hardRate": "HARD",
        "passRate": "42.66%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-good-paths/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-good-paths/solution",
        "problemsDesc": "<p>给你一棵 <code>n</code>&nbsp;个节点的树（连通无向无环的图），节点编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;且恰好有&nbsp;<code>n - 1</code>&nbsp;条边。</p>\n\n<p>给你一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>vals</code>&nbsp;，分别表示每个节点的值。同时给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code><sub>&nbsp;</sub>之间有一条&nbsp;<strong>无向</strong>&nbsp;边。</p>\n\n<p>一条 <strong>好路径</strong>&nbsp;需要满足以下条件：</p>\n\n<ol>\n\t<li>开始节点和结束节点的值 <strong>相同</strong>&nbsp;。</li>\n\t<li>开始节点和结束节点中间的所有节点值都 <strong>小于等于</strong>&nbsp;开始节点的值（也就是说开始节点的值应该是路径上所有节点的最大值）。</li>\n</ol>\n\n<p>请你返回不同好路径的数目。</p>\n\n<p>注意，一条路径和它反向的路径算作 <strong>同一</strong>&nbsp;路径。比方说，&nbsp;<code>0 -&gt; 1</code>&nbsp;与&nbsp;<code>1 -&gt; 0</code>&nbsp;视为同一条路径。单个节点也视为一条合法路径。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/08/04/f9caaac15b383af9115c5586779dec5.png\" style=\"width: 400px; height: 333px;\"></p>\n\n<pre><b>输入：</b>vals = [1,3,2,1,3], edges = [[0,1],[0,2],[2,3],[2,4]]\n<b>输出：</b>6\n<b>解释：</b>总共有 5 条单个节点的好路径。\n还有 1 条好路径：1 -&gt; 0 -&gt; 2 -&gt; 4 。\n（反方向的路径 4 -&gt; 2 -&gt; 0 -&gt; 1 视为跟 1 -&gt; 0 -&gt; 2 -&gt; 4 一样的路径）\n注意 0 -&gt; 2 -&gt; 3 不是一条好路径，因为 vals[2] &gt; vals[0] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/08/04/149d3065ec165a71a1b9aec890776ff.png\" style=\"width: 273px; height: 350px;\"></p>\n\n<pre><b>输入：</b>vals = [1,1,2,2,3], edges = [[0,1],[1,2],[2,3],[2,4]]\n<b>输出：</b>7\n<strong>解释：</strong>总共有 5 条单个节点的好路径。\n还有 2 条好路径：0 -&gt; 1 和 2 -&gt; 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/08/04/31705e22af3d9c0a557459bc7d1b62d.png\" style=\"width: 100px; height: 88px;\"></p>\n\n<pre><b>输入：</b>vals = [1], edges = []\n<b>输出：</b>1\n<b>解释：</b>这棵树只有一个节点，所以只有一条好路径。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == vals.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= vals[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>edges</code>&nbsp;表示一棵合法的树。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2422.使用合并操作将数组转换为回文序列",
        "hardRate": "MEDIUM",
        "passRate": "71.47%",
        "problemsUrl": "https://leetcode.cn/problems/merge-operations-to-turn-array-into-a-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-operations-to-turn-array-into-a-palindrome/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2423.删除字符使频率相同",
        "hardRate": "EASY",
        "passRate": "25.13%",
        "problemsUrl": "https://leetcode.cn/problems/remove-letter-to-equalize-frequency/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-letter-to-equalize-frequency/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>word</code>&nbsp;，字符串只包含小写英文字母。你需要选择 <strong>一个</strong>&nbsp;下标并 <strong>删除</strong>&nbsp;下标处的字符，使得 <code>word</code>&nbsp;中剩余每个字母出现 <strong>频率</strong>&nbsp;相同。</p>\n\n<p>如果删除一个字母后，<code>word</code>&nbsp;中剩余所有字母的出现频率都相同，那么返回 <code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>字母&nbsp;<code>x</code>&nbsp;的 <strong>频率</strong><strong>&nbsp;</strong>是这个字母在字符串中出现的次数。</li>\n\t<li>你 <strong>必须</strong>&nbsp;恰好删除一个字母，不能一个字母都不删除。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>word = \"abcc\"\n<b>输出：</b>true\n<b>解释：</b>选择下标 3 并删除该字母，word 变成 \"abc\" 且每个字母出现频率都为 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>word = \"aazz\"\n<b>输出：</b>false\n<b>解释：</b>我们必须删除一个字母，所以要么 \"a\" 的频率变为 1 且 \"z\" 的频率为 2 ，要么两个字母频率反过来。所以不可能让剩余所有字母出现频率相同。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= word.length &lt;= 100</code></li>\n\t<li><code>word</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2424.最长上传前缀",
        "hardRate": "MEDIUM",
        "passRate": "56.04%",
        "problemsUrl": "https://leetcode.cn/problems/longest-uploaded-prefix/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-uploaded-prefix/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>n</code>&nbsp;个视频的上传序列，每个视频编号为&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;之间的 <strong>不同</strong>&nbsp;数字，你需要依次将这些视频上传到服务器。请你实现一个数据结构，在上传的过程中计算 <strong>最长上传前缀</strong>&nbsp;。</p>\n\n<p>如果&nbsp;<strong>闭区间</strong>&nbsp;<code>1</code>&nbsp;到&nbsp;<code>i</code>&nbsp;之间的视频全部都已经被上传到服务器，那么我们称 <code>i</code>&nbsp;是上传前缀。最长上传前缀指的是符合定义的 <code>i</code>&nbsp;中的 <strong>最大值</strong>&nbsp;。<br>\n<br>\n请你实现&nbsp;<code>LUPrefix</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>LUPrefix(int n)</code>&nbsp;初始化一个 <code>n</code>&nbsp;个视频的流对象。</li>\n\t<li><code>void upload(int video)</code>&nbsp;上传&nbsp;<code>video</code>&nbsp;到服务器。</li>\n\t<li><code>int longest()</code>&nbsp;返回上述定义的 <strong>最长上传前缀</strong>&nbsp;的长度。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>\n[\"LUPrefix\", \"upload\", \"longest\", \"upload\", \"longest\", \"upload\", \"longest\"]\n[[4], [3], [], [1], [], [2], []]\n<strong>输出：</strong>\n[null, null, 0, null, 1, null, 3]\n\n<strong>解释：</strong>\nLUPrefix server = new LUPrefix(4);   // 初始化 4个视频的上传流\nserver.upload(3);                    // 上传视频 3 。\nserver.longest();                    // 由于视频 1 还没有被上传，最长上传前缀是 0 。\nserver.upload(1);                    // 上传视频 1 。\nserver.longest();                    // 前缀 [1] 是最长上传前缀，所以我们返回 1 。\nserver.upload(2);                    // 上传视频 2 。\nserver.longest();                    // 前缀 [1,2,3] 是最长上传前缀，所以我们返回 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= video &lt;= 10<sup>5</sup></code></li>\n\t<li><code>video</code>&nbsp;中所有值 <strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>upload</code> 和&nbsp;<code>longest</code>&nbsp;<strong>总调用</strong> 次数至多不超过&nbsp;<code>2 * 10<sup>5</sup></code>&nbsp;次。</li>\n\t<li>至少会调用&nbsp;<code>longest</code>&nbsp;一次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2425.所有数对的异或和",
        "hardRate": "MEDIUM",
        "passRate": "64.83%",
        "problemsUrl": "https://leetcode.cn/problems/bitwise-xor-of-all-pairings/",
        "solutionsUrl": "https://leetcode.cn/problems/bitwise-xor-of-all-pairings/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;，两个数组都只包含非负整数。请你求出另外一个数组&nbsp;<code>nums3</code>&nbsp;，包含 <code>nums1</code>&nbsp;和 <code>nums2</code>&nbsp;中 <strong>所有数对</strong>&nbsp;的异或和（<code>nums1</code>&nbsp;中每个整数都跟 <code>nums2</code>&nbsp;中每个整数 <strong>恰好</strong>&nbsp;匹配一次）。</p>\n\n<p>请你返回 <code>nums3</code>&nbsp;中所有整数的 <strong>异或和</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [2,1,3], nums2 = [10,2,5,0]\n<b>输出：</b>13\n<strong>解释：</strong>\n一个可能的 nums3 数组是 [8,0,7,2,11,3,4,1,9,1,6,3] 。\n所有这些数字的异或和是 13 ，所以我们返回 13 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,2], nums2 = [3,4]\n<b>输出：</b>0\n<strong>解释：</strong>\n所有数对异或和的结果分别为 nums1[0] ^ nums2[0] ，nums1[0] ^ nums2[1] ，nums1[1] ^ nums2[0] 和 nums1[1] ^ nums2[1] 。\n所以，一个可能的 nums3 数组是 [2,5,1,6] 。\n2 ^ 5 ^ 1 ^ 6 = 0 ，所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[j] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2426.满足不等式的数对数目",
        "hardRate": "HARD",
        "passRate": "46.00%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-pairs-satisfying-inequality/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-pairs-satisfying-inequality/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;，两个数组的大小都为&nbsp;<code>n</code>&nbsp;，同时给你一个整数&nbsp;<code>diff</code>&nbsp;，统计满足以下条件的&nbsp;<strong>数对&nbsp;</strong><code>(i, j)</code>&nbsp;：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt;= n - 1</code>&nbsp;<b>且</b></li>\n\t<li><code>nums1[i] - nums1[j] &lt;= nums2[i] - nums2[j] + diff</code>.</li>\n</ul>\n\n<p>请你返回满足条件的 <strong>数对数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [3,2,5], nums2 = [2,2,1], diff = 1\n<b>输出：</b>3\n<strong>解释：</strong>\n总共有 3 个满足条件的数对：\n1. i = 0, j = 1：3 - 2 &lt;= 2 - 2 + 1 。因为 i &lt; j 且 1 &lt;= 1 ，这个数对满足条件。\n2. i = 0, j = 2：3 - 5 &lt;= 2 - 1 + 1 。因为 i &lt; j 且 -2 &lt;= 2 ，这个数对满足条件。\n3. i = 1, j = 2：2 - 5 &lt;= 2 - 1 + 1 。因为 i &lt; j 且 -3 &lt;= 2 ，这个数对满足条件。\n所以，我们返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [3,-1], nums2 = [-2,2], diff = -1\n<b>输出：</b>0\n<strong>解释：</strong>\n没有满足条件的任何数对，所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length == nums2.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= diff &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2427.公因子的数目",
        "hardRate": "EASY",
        "passRate": "81.66%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-common-factors/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-common-factors/solution",
        "problemsDesc": "<p>给你两个正整数 <code>a</code> 和 <code>b</code> ，返回 <code>a</code> 和 <code>b</code> 的 <strong>公</strong> 因子的数目。</p>\n\n<p>如果 <code>x</code> 可以同时整除 <code>a</code> 和 <code>b</code> ，则认为 <code>x</code> 是 <code>a</code> 和 <code>b</code> 的一个 <strong>公因子</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>a = 12, b = 6\n<strong>输出：</strong>4\n<strong>解释：</strong>12 和 6 的公因子是 1、2、3、6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>a = 25, b = 30\n<strong>输出：</strong>2\n<strong>解释：</strong>25 和 30 的公因子是 1、5 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a, b &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2428.沙漏的最大总和",
        "hardRate": "MEDIUM",
        "passRate": "74.74%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-of-an-hourglass/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-of-an-hourglass/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的整数矩阵 <code>grid</code> 。</p>\n\n<p>按以下形式将矩阵的一部分定义为一个 <strong>沙漏</strong> ：</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/08/21/img.jpg\" style=\"width: 243px; height: 243px;\">\n<p>返回沙漏中元素的 <strong>最大</strong> 总和。</p>\n\n<p><strong>注意：</strong>沙漏无法旋转且必须整个包含在矩阵中。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/08/21/1.jpg\" style=\"width: 323px; height: 323px;\">\n<pre><strong>输入：</strong>grid = [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]]\n<strong>输出：</strong>30\n<strong>解释：</strong>上图中的单元格表示元素总和最大的沙漏：6 + 2 + 1 + 2 + 9 + 2 + 8 = 30 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/08/21/2.jpg\" style=\"width: 243px; height: 243px;\">\n<pre><strong>输入：</strong>grid = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>35\n<strong>解释：</strong>上图中的单元格表示元素总和最大的沙漏：1 + 2 + 3 + 5 + 7 + 8 + 9 = 35 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>3 &lt;= m, n &lt;= 150</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2429.最小 XOR",
        "hardRate": "MEDIUM",
        "passRate": "44.47%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-xor/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-xor/solution",
        "problemsDesc": "<p>给你两个正整数 <code>num1</code> 和 <code>num2</code> ，找出满足下述条件的整数 <code>x</code> ：</p>\n\n<ul>\n\t<li><code>x</code> 的置位数和 <code>num2</code> 相同，且</li>\n\t<li><code>x XOR num1</code> 的值 <strong>最小</strong></li>\n</ul>\n\n<p>注意 <code>XOR</code> 是按位异或运算。</p>\n\n<p>返回整数<em> </em><code>x</code> 。题目保证，对于生成的测试用例， <code>x</code> 是 <strong>唯一确定</strong> 的。</p>\n\n<p>整数的 <strong>置位数</strong> 是其二进制表示中 <code>1</code> 的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num1 = 3, num2 = 5\n<strong>输出：</strong>3\n<strong>解释：</strong>\nnum1 和 num2 的二进制表示分别是 0011 和 0101 。\n整数 <strong>3</strong> 的置位数与 num2 相同，且 <code>3 XOR 3 = 0</code> 是最小的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num1 = 1, num2 = 12\n<strong>输出：</strong>3\n<strong>解释：</strong>\nnum1 和 num2 的二进制表示分别是 0001 和 1100 。\n整数 <strong>3</strong> 的置位数与 num2 相同，且 <code>3 XOR 1 = 2</code> 是最小的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num1, num2 &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2430.对字母串可执行的最大删除数",
        "hardRate": "HARD",
        "passRate": "47.71%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-deletions-on-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-deletions-on-a-string/solution",
        "problemsDesc": "<p>给你一个仅由小写英文字母组成的字符串 <code>s</code> 。在一步操作中，你可以：</p>\n\n<ul>\n\t<li>删除 <strong>整个字符串</strong> <code>s</code> ，或者</li>\n\t<li>对于满足&nbsp;<code>1 &lt;= i &lt;= s.length / 2</code> 的任意 <code>i</code> ，如果 <code>s</code> 中的 <strong>前</strong> <code>i</code> 个字母和接下来的 <code>i</code> 个字母 <strong>相等</strong> ，删除 <strong>前</strong> <code>i</code> 个字母。</li>\n</ul>\n\n<p>例如，如果 <code>s = \"ababc\"</code> ，那么在一步操作中，你可以删除 <code>s</code> 的前两个字母得到 <code>\"abc\"</code> ，因为 <code>s</code> 的前两个字母和接下来的两个字母都等于 <code>\"ab\"</code> 。</p>\n\n<p>返回删除 <code>s</code> 所需的最大操作数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcabcdabc\"\n<strong>输出：</strong>2\n<strong>解释：</strong>\n- 删除前 3 个字母（\"abc\"），因为它们和接下来 3 个字母相等。现在，s = \"abcdabc\"。\n- 删除全部字母。\n一共用了 2 步操作，所以返回 2 。可以证明 2 是所需的最大操作数。\n注意，在第二步操作中无法再次删除 \"abc\" ，因为 \"abc\" 的下一次出现并不是位于接下来的 3 个字母。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aaabaab\"\n<strong>输出：</strong>4\n<strong>解释：</strong>\n- 删除第一个字母（\"a\"），因为它和接下来的字母相等。现在，s = \"aabaab\"。\n- 删除前 3 个字母（\"aab\"），因为它们和接下来 3 个字母相等。现在，s = \"aab\"。 \n- 删除第一个字母（\"a\"），因为它和接下来的字母相等。现在，s = \"ab\"。\n- 删除全部字母。\n一共用了 4 步操作，所以返回 4 。可以证明 4 是所需的最大操作数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aaaaa\"\n<strong>输出：</strong>5\n<strong>解释：</strong>在每一步操作中，都可以仅删除 s 的第一个字母。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 4000</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2431.最大限度地提高购买水果的口味",
        "hardRate": "MEDIUM",
        "passRate": "58.76%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-total-tastiness-of-purchased-fruits/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-total-tastiness-of-purchased-fruits/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2432.处理用时最长的那个任务的员工",
        "hardRate": "EASY",
        "passRate": "55.20%",
        "problemsUrl": "https://leetcode.cn/problems/the-employee-that-worked-on-the-longest-task/",
        "solutionsUrl": "https://leetcode.cn/problems/the-employee-that-worked-on-the-longest-task/solution",
        "problemsDesc": "<p>共有 <code>n</code> 位员工，每位员工都有一个从 <code>0</code> 到 <code>n - 1</code> 的唯一 id 。</p>\n\n<p>给你一个二维整数数组 <code>logs</code> ，其中 <code>logs[i] = [id<sub>i</sub>, leaveTime<sub>i</sub>]</code> ：</p>\n\n<ul>\n\t<li><code>id<sub>i</sub></code> 是处理第 <code>i</code> 个任务的员工的 id ，且</li>\n\t<li><code>leaveTime<sub>i</sub></code> 是员工完成第 <code>i</code> 个任务的时刻。所有 <code>leaveTime<sub>i</sub></code> 的值都是 <strong>唯一</strong> 的。</li>\n</ul>\n\n<p>注意，第 <code>i</code> 个任务在第 <code>(i - 1)</code> 个任务结束后立即开始，且第 <code>0</code> 个任务从时刻 <code>0</code> 开始。</p>\n\n<p>返回处理用时最长的那个任务的员工的 id 。如果存在两个或多个员工同时满足，则返回几人中 <strong>最小</strong> 的 id 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10, logs = [[0,3],[2,5],[0,9],[1,15]]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n任务 0 于时刻 0 开始，且在时刻 3 结束，共计 3 个单位时间。\n任务 1 于时刻 3 开始，且在时刻 5 结束，共计 2 个单位时间。\n任务 2 于时刻 5 开始，且在时刻 9 结束，共计 4 个单位时间。\n任务 3 于时刻 9 开始，且在时刻 15 结束，共计 6 个单位时间。\n时间最长的任务是任务 3 ，而 id 为 1 的员工是处理此任务的员工，所以返回 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 26, logs = [[1,1],[3,7],[2,12],[7,17]]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n任务 0 于时刻 0 开始，且在时刻 1 结束，共计 1 个单位时间。\n任务 1 于时刻 1 开始，且在时刻 7 结束，共计 6 个单位时间。\n任务 2 于时刻 7 开始，且在时刻 12 结束，共计 5 个单位时间。\n任务 3 于时刻 12 开始，且在时刻 17 结束，共计 5 个单位时间。\n时间最长的任务是任务 1 ，而 id 为 3 的员工是处理此任务的员工，所以返回 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, logs = [[0,10],[1,20]]\n<strong>输出：</strong>0\n<strong>解释：</strong>\n任务 0 于时刻 0 开始，且在时刻 10 结束，共计 10 个单位时间。\n任务 1 于时刻 10 开始，且在时刻 20 结束，共计 10 个单位时间。\n时间最长的任务是任务 0 和 1 ，处理这两个任务的员工的 id 分别是 0 和 1 ，所以返回最小的 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= logs.length &lt;= 500</code></li>\n\t<li><code>logs[i].length == 2</code></li>\n\t<li><code>0 &lt;= id<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= leaveTime<sub>i</sub> &lt;= 500</code></li>\n\t<li><code>id<sub>i</sub> != id<sub>i + 1</sub></code></li>\n\t<li><code>leaveTime<sub>i</sub></code> 按严格递增顺序排列</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2433.找出前缀异或的原始数组",
        "hardRate": "MEDIUM",
        "passRate": "84.80%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-original-array-of-prefix-xor/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-original-array-of-prefix-xor/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的 <strong>整数</strong> 数组 <code>pref</code> 。找出并返回满足下述条件且长度为 <code>n</code> 的数组<em> </em><code>arr</code> ：</p>\n\n<ul>\n\t<li><code>pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]</code>.</li>\n</ul>\n\n<p>注意 <code>^</code> 表示 <strong>按位异或</strong>（bitwise-xor）运算。</p>\n\n<p>可以证明答案是 <strong>唯一</strong> 的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>pref = [5,2,0,3,1]\n<strong>输出：</strong>[5,7,2,3,2]\n<strong>解释：</strong>从数组 [5,7,2,3,2] 可以得到如下结果：\n- pref[0] = 5\n- pref[1] = 5 ^ 7 = 2\n- pref[2] = 5 ^ 7 ^ 2 = 0\n- pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3\n- pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>pref = [13]\n<strong>输出：</strong>[13]\n<strong>解释：</strong>pref[0] = arr[0] = 13\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pref.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= pref[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2434.使用机器人打印字典序最小的字符串",
        "hardRate": "MEDIUM",
        "passRate": "42.09%",
        "problemsUrl": "https://leetcode.cn/problems/using-a-robot-to-print-the-lexicographically-smallest-string/",
        "solutionsUrl": "https://leetcode.cn/problems/using-a-robot-to-print-the-lexicographically-smallest-string/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;和一个机器人，机器人当前有一个空字符串&nbsp;<code>t</code>&nbsp;。执行以下操作之一，直到&nbsp;<code>s</code> 和&nbsp;<code>t</code>&nbsp;<strong>都变成空字符串：</strong></p>\n\n<ul>\n\t<li>删除字符串&nbsp;<code>s</code>&nbsp;的 <strong>第一个</strong>&nbsp;字符，并将该字符给机器人。机器人把这个字符添加到 <code>t</code>&nbsp;的尾部。</li>\n\t<li>删除字符串&nbsp;<code>t</code>&nbsp;的&nbsp;<strong>最后一个</strong>&nbsp;字符，并将该字符给机器人。机器人将该字符写到纸上。</li>\n</ul>\n\n<p>请你返回纸上能写出的字典序最小的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"zza\"\n<b>输出：</b>\"azz\"\n<b>解释：</b>用 p 表示写出来的字符串。\n一开始，p=\"\" ，s=\"zza\" ，t=\"\" 。\n执行第一个操作三次，得到 p=\"\" ，s=\"\" ，t=\"zza\" 。\n执行第二个操作三次，得到 p=\"azz\" ，s=\"\" ，t=\"\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"bac\"\n<b>输出：</b>\"abc\"\n<b>解释：</b>用 p 表示写出来的字符串。\n执行第一个操作两次，得到 p=\"\" ，s=\"c\" ，t=\"ba\" 。\n执行第二个操作两次，得到 p=\"ab\" ，s=\"c\" ，t=\"\" 。\n执行第一个操作，得到 p=\"ab\" ，s=\"\" ，t=\"c\" 。\n执行第二个操作，得到 p=\"abc\" ，s=\"\" ，t=\"\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>s = \"bdda\"\n<b>输出：</b>\"addb\"\n<b>解释：</b>用 p 表示写出来的字符串。\n一开始，p=\"\" ，s=\"bdda\" ，t=\"\" 。\n执行第一个操作四次，得到 p=\"\" ，s=\"\" ，t=\"bdda\" 。\n执行第二个操作四次，得到 p=\"addb\" ，s=\"\" ，t=\"\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2435.矩阵中和能被 K 整除的路径",
        "hardRate": "HARD",
        "passRate": "51.46%",
        "problemsUrl": "https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/",
        "solutionsUrl": "https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;整数矩阵&nbsp;<code>grid</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。你从起点&nbsp;<code>(0, 0)</code>&nbsp;出发，每一步只能往 <strong>下</strong>&nbsp;或者往 <strong>右</strong>&nbsp;，你想要到达终点&nbsp;<code>(m - 1, n - 1)</code>&nbsp;。</p>\n\n<p>请你返回路径和能被 <code>k</code>&nbsp;整除的路径数目，由于答案可能很大，返回答案对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2022/08/13/image-20220813183124-1.png\" style=\"width: 437px; height: 200px;\"></p>\n\n<pre><b>输入：</b>grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3\n<b>输出：</b>2\n<b>解释：</b>有两条路径满足路径上元素的和能被 k 整除。\n第一条路径为上图中用红色标注的路径，和为 5 + 2 + 4 + 5 + 2 = 18 ，能被 3 整除。\n第二条路径为上图中用蓝色标注的路径，和为 5 + 3 + 0 + 5 + 2 = 15 ，能被 3 整除。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/08/17/image-20220817112930-3.png\" style=\"height: 85px; width: 132px;\">\n<pre><b>输入：</b>grid = [[0,0]], k = 5\n<b>输出：</b>1\n<b>解释：</b>红色标注的路径和为 0 + 0 = 0 ，能被 5 整除。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/08/12/image-20220812224605-3.png\" style=\"width: 257px; height: 200px;\">\n<pre><b>输入：</b>grid = [[7,3,4,9],[2,3,6,2],[2,3,7,0]], k = 1\n<b>输出：</b>10\n<b>解释：</b>每个数字都能被 1 整除，所以每一条路径的和都能被 k 整除。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 100</code></li>\n\t<li><code>1 &lt;= k &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2436.使子数组最大公约数大于一的最小分割数",
        "hardRate": "MEDIUM",
        "passRate": "76.98%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-split-into-subarrays-with-gcd-greater-than-one/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-split-into-subarrays-with-gcd-greater-than-one/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2437.有效时间的数目",
        "hardRate": "EASY",
        "passRate": "50.49%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-valid-clock-times/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-valid-clock-times/solution",
        "problemsDesc": "<p>给你一个长度为&nbsp;<code>5</code>&nbsp;的字符串&nbsp;<code>time</code>&nbsp;，表示一个电子时钟当前的时间，格式为&nbsp;<code>\"hh:mm\"</code>&nbsp;。<strong>最早</strong>&nbsp;可能的时间是&nbsp;<code>\"00:00\"</code>&nbsp;，<strong>最晚</strong>&nbsp;可能的时间是&nbsp;<code>\"23:59\"</code>&nbsp;。</p>\n\n<p>在字符串&nbsp;<code>time</code>&nbsp;中，被字符&nbsp;<code>?</code>&nbsp;替换掉的数位是 <strong>未知的</strong>&nbsp;，被替换的数字可能是&nbsp;<code>0</code>&nbsp;到&nbsp;<code>9</code>&nbsp;中的任何一个。</p>\n\n<p>请你返回一个整数<em>&nbsp;</em><code>answer</code>&nbsp;，将每一个 <code>?</code>&nbsp;都用<em>&nbsp;</em><code>0</code>&nbsp;到<em>&nbsp;</em><code>9</code>&nbsp;中一个数字替换后，可以得到的有效时间的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>time = \"?5:00\"\n<b>输出：</b>2\n<b>解释：</b>我们可以将 ? 替换成 0 或 1 ，得到 \"05:00\" 或者 \"15:00\" 。注意我们不能替换成 2 ，因为时间 \"25:00\" 是无效时间。所以我们有两个选择。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>time = \"0?:0?\"\n<b>输出：</b>100\n<b>解释：</b>两个 ? 都可以被 0 到 9 之间的任意数字替换，所以我们总共有 100 种选择。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>time = \"??:??\"\n<b>输出：</b>1440\n<b>解释：</b>小时总共有 24 种选择，分钟总共有 60 种选择。所以总共有 24 * 60 = 1440 种选择。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>time</code>&nbsp;是一个长度为 <code>5</code>&nbsp;的有效字符串，格式为&nbsp;<code>\"hh:mm\"</code>&nbsp;。</li>\n\t<li><code>\"00\" &lt;= hh &lt;= \"23\"</code></li>\n\t<li><code>\"00\" &lt;= mm &lt;= \"59\"</code></li>\n\t<li>字符串中有的数位是&nbsp;<code>'?'</code>&nbsp;，需要用&nbsp;<code>0</code>&nbsp;到&nbsp;<code>9</code>&nbsp;之间的数字替换。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2438.二的幂数组中查询范围内的乘积",
        "hardRate": "MEDIUM",
        "passRate": "41.19%",
        "problemsUrl": "https://leetcode.cn/problems/range-product-queries-of-powers/",
        "solutionsUrl": "https://leetcode.cn/problems/range-product-queries-of-powers/solution",
        "problemsDesc": "<p>给你一个正整数&nbsp;<code>n</code>&nbsp;，你需要找到一个下标从&nbsp;<strong>0</strong>&nbsp;开始的数组&nbsp;<code>powers</code>&nbsp;，它包含 <strong>最少</strong>&nbsp;数目的 <code>2</code>&nbsp;的幂，且它们的和为&nbsp;<code>n</code>&nbsp;。<code>powers</code>&nbsp;数组是&nbsp;<strong>非递减</strong>&nbsp;顺序的。根据前面描述，构造&nbsp;<code>powers</code>&nbsp;数组的方法是唯一的。</p>\n\n<p>同时给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>queries</code>&nbsp;，其中&nbsp;<code>queries[i] = [left<sub>i</sub>, right<sub>i</sub>]</code>&nbsp;，其中&nbsp;<code>queries[i]</code>&nbsp;表示请你求出满足&nbsp;<code>left<sub>i</sub> &lt;= j &lt;= right<sub>i</sub></code>&nbsp;的所有&nbsp;<code>powers[j]</code>&nbsp;的乘积。</p>\n\n<p>请你返回一个数组<em>&nbsp;</em><code>answers</code>&nbsp;，长度与<em>&nbsp;</em><code>queries</code>&nbsp;的长度相同，其中<em>&nbsp;</em><code>answers[i]</code>是第<em>&nbsp;</em><code>i</code>&nbsp;个查询的答案。由于查询的结果可能非常大，请你将每个&nbsp;<code>answers[i]</code>&nbsp;都对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 15, queries = [[0,1],[2,2],[0,3]]\n<b>输出：</b>[2,4,64]\n<strong>解释：</strong>\n对于 n = 15 ，得到 powers = [1,2,4,8] 。没法得到元素数目更少的数组。\n第 1 个查询的答案：powers[0] * powers[1] = 1 * 2 = 2 。\n第 2 个查询的答案：powers[2] = 4 。\n第 3 个查询的答案：powers[0] * powers[1] * powers[2] * powers[3] = 1 * 2 * 4 * 8 = 64 。\n每个答案对 10<sup>9</sup> + 7 得到的结果都相同，所以返回 [2,4,64] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 2, queries = [[0,0]]\n<b>输出：</b>[2]\n<strong>解释：</strong>\n对于 n = 2, powers = [2] 。\n唯一一个查询的答案是 powers[0] = 2 。答案对 10<sup>9</sup> + 7 取余后结果相同，所以返回 [2] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt; powers.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2439.最小化数组中的最大值",
        "hardRate": "MEDIUM",
        "passRate": "39.16%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-maximum-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-maximum-of-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>nums</code>&nbsp;，它含有&nbsp;<code>n</code>&nbsp;个非负整数。</p>\n\n<p>每一步操作中，你需要：</p>\n\n<ul>\n\t<li>选择一个满足&nbsp;<code>1 &lt;= i &lt; n</code>&nbsp;的整数 <code>i</code>&nbsp;，且&nbsp;<code>nums[i] &gt; 0</code>&nbsp;。</li>\n\t<li>将&nbsp;<code>nums[i]</code>&nbsp;减 1 。</li>\n\t<li>将&nbsp;<code>nums[i - 1]</code>&nbsp;加 1 。</li>\n</ul>\n\n<p>你可以对数组执行 <strong>任意</strong>&nbsp;次上述操作，请你返回可以得到的 <code>nums</code>&nbsp;数组中<b>&nbsp;最大值</b>&nbsp;<strong>最小</strong> 为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [3,7,1,6]\n<b>输出：</b>5\n<strong>解释：</strong>\n一串最优操作是：\n1. 选择 i = 1 ，nums 变为 [4,6,1,6] 。\n2. 选择 i = 3 ，nums 变为 [4,6,2,5] 。\n3. 选择 i = 1 ，nums 变为 [5,5,2,5] 。\nnums 中最大值为 5 。无法得到比 5 更小的最大值。\n所以我们返回 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [10,1]\n<b>输出：</b>10\n<strong>解释：</strong>\n最优解是不改动 nums ，10 是最大值，所以返回 10 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2440.创建价值相同的连通块",
        "hardRate": "HARD",
        "passRate": "61.40%",
        "problemsUrl": "https://leetcode.cn/problems/create-components-with-same-value/",
        "solutionsUrl": "https://leetcode.cn/problems/create-components-with-same-value/solution",
        "problemsDesc": "<p>有一棵&nbsp;<code>n</code>&nbsp;个节点的无向树，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。</p>\n\n<p>给你一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，其中&nbsp;<code>nums[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个节点的值。同时给你一个长度为 <code>n - 1</code>&nbsp;的二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示节点&nbsp;<code>a<sub>i</sub></code>&nbsp;与&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条边。</p>\n\n<p>你可以 <strong>删除</strong>&nbsp;一些边，将这棵树分成几个连通块。一个连通块的 <strong>价值</strong>&nbsp;定义为这个连通块中 <strong>所有</strong> 节点 <code>i</code>&nbsp;对应的 <code>nums[i]</code>&nbsp;之和。</p>\n\n<p>你需要删除一些边，删除后得到的各个连通块的价值都相等。请返回你可以删除的边数&nbsp;<strong>最多</strong>&nbsp;为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/08/26/diagramdrawio.png\" style=\"width: 441px; height: 351px;\"></p>\n\n<pre><b>输入：</b>nums = [6,2,2,2,6], edges = [[0,1],[1,2],[1,3],[3,4]] \n<b>输出：</b>2 \n<b>解释：</b>上图展示了我们可以删除边 [0,1] 和 [3,4] 。得到的连通块为 [0] ，[1,2,3] 和 [4] 。每个连通块的价值都为 6 。可以证明没有别的更好的删除方案存在了，所以答案为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2], edges = []\n<b>输出：</b>0\n<b>解释：</b>没有任何边可以删除。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>nums.length == n</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 50</code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= edges[i][0], edges[i][1] &lt;= n - 1</code></li>\n\t<li><code>edges</code>&nbsp;表示一棵合法的树。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2441.与对应负数同时存在的最大正整数",
        "hardRate": "EASY",
        "passRate": "72.55%",
        "problemsUrl": "https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/solution",
        "problemsDesc": "<p>给你一个 <strong>不包含</strong> 任何零的整数数组 <code>nums</code> ，找出自身与对应的负数都在数组中存在的最大正整数 <code>k</code> 。</p>\n\n<p>返回正整数<em> </em><code>k</code> ，如果不存在这样的整数，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,2,-3,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>3 是数组中唯一一个满足题目要求的 k 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,10,6,7,-7,1]\n<strong>输出：</strong>7\n<strong>解释：</strong>数组中存在 1 和 7 对应的负数，7 的值更大。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-10,8,6,7,-2,-3]\n<strong>输出：</strong>-1\n<strong>解释：</strong>不存在满足题目要求的 k ，返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>nums[i] != 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2442.反转之后不同整数的数目",
        "hardRate": "MEDIUM",
        "passRate": "75.12%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-distinct-integers-after-reverse-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-distinct-integers-after-reverse-operations/solution",
        "problemsDesc": "<p>给你一个由 <strong>正</strong> 整数组成的数组 <code>nums</code> 。</p>\n\n<p>你必须取出数组中的每个整数，<strong>反转其中每个数位</strong>，并将反转后得到的数字添加到数组的末尾。这一操作只针对 <code>nums</code> 中原有的整数执行。</p>\n\n<p>返回结果数组中 <strong>不同</strong> 整数的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,13,10,12,31]\n<strong>输出：</strong>6\n<strong>解释：</strong>反转每个数字后，结果数组是 [1,13,10,12,31,<em><strong>1,31,1,21,13</strong></em>] 。\n反转后得到的数字添加到数组的末尾并按斜体加粗表示。注意对于整数 10 ，反转之后会变成 01 ，即 1 。\n数组中不同整数的数目为 6（数字 1、10、12、13、21 和 31）。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>反转每个数字后，结果数组是 [2,2,2,<em><strong>2,2,2</strong></em>] 。\n数组中不同整数的数目为 1（数字 2）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2443.反转之后的数字和",
        "hardRate": "MEDIUM",
        "passRate": "46.46%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-number-and-its-reverse/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-number-and-its-reverse/solution",
        "problemsDesc": "<p>给你一个 <strong>非负</strong> 整数 <code>num</code> 。如果存在某个 <strong>非负</strong> 整数 <code>k</code> 满足 <code>k + reverse(k) = num</code>&nbsp; ，则返回 <code>true</code> ；否则，返回<em> </em><code>false</code> 。</p>\n\n<p><code>reverse(k)</code> 表示 <code>k</code> 反转每个数位后得到的数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 443\n<strong>输出：</strong>true\n<strong>解释：</strong>172 + 271 = 443 ，所以返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 63\n<strong>输出：</strong>false\n<strong>解释：</strong>63 不能表示为非负整数及其反转后数字之和，返回 false 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 181\n<strong>输出：</strong>true\n<strong>解释：</strong>140 + 041 = 181 ，所以返回 true 。注意，反转后的数字可能包含前导零。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2444.统计定界子数组的数目",
        "hardRate": "HARD",
        "passRate": "44.46%",
        "problemsUrl": "https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/",
        "solutionsUrl": "https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和两个整数 <code>minK</code> 以及 <code>maxK</code> 。</p>\n\n<p><code>nums</code> 的定界子数组是满足下述条件的一个子数组：</p>\n\n<ul>\n\t<li>子数组中的 <strong>最小值</strong> 等于 <code>minK</code> 。</li>\n\t<li>子数组中的 <strong>最大值</strong> 等于 <code>maxK</code> 。</li>\n</ul>\n\n<p>返回定界子数组的数目。</p>\n\n<p>子数组是数组中的一个连续部分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3,5,2,7,5], minK = 1, maxK = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>定界子数组是 [1,3,5] 和 [1,3,5,2] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,1,1], minK = 1, maxK = 1\n<strong>输出：</strong>10\n<strong>解释：</strong>nums 的每个子数组都是一个定界子数组。共有 10 个子数组。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], minK, maxK &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2445.值为 1 的节点数",
        "hardRate": "MEDIUM",
        "passRate": "78.33%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-nodes-with-value-one/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-nodes-with-value-one/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2446.判断两个事件是否存在冲突",
        "hardRate": "EASY",
        "passRate": "63.53%",
        "problemsUrl": "https://leetcode.cn/problems/determine-if-two-events-have-conflict/",
        "solutionsUrl": "https://leetcode.cn/problems/determine-if-two-events-have-conflict/solution",
        "problemsDesc": "<p>给你两个字符串数组 <code>event1</code> 和&nbsp;<code>event2</code>&nbsp;，表示发生在同一天的两个闭区间时间段事件，其中：</p>\n\n<ul>\n\t<li><code>event1 = [startTime<sub>1</sub>, endTime<sub>1</sub>]</code> 且</li>\n\t<li><code>event2 = [startTime<sub>2</sub>, endTime<sub>2</sub>]</code></li>\n</ul>\n\n<p>事件的时间为有效的 24 小时制且按&nbsp;<code>HH:MM</code>&nbsp;格式给出。</p>\n\n<p>当两个事件存在某个非空的交集时（即，某些时刻是两个事件都包含的），则认为出现 <strong>冲突</strong>&nbsp;。</p>\n\n<p>如果两个事件之间存在冲突，返回&nbsp;<code>true</code><em>&nbsp;</em>；否则，返回<em>&nbsp;</em><code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre>\n<b>输入：</b>event1 = [\"01:15\",\"02:00\"], event2 = [\"02:00\",\"03:00\"]\n<b>输出：</b>true\n<b>解释：</b>两个事件在 2:00 出现交集。\n</pre>\n\n<p><b>示例 2：</b></p>\n\n<pre>\n<b>输入：</b>event1 = [\"01:00\",\"02:00\"], event2 = [\"01:20\",\"03:00\"]\n<b>输出：</b>true\n<b>解释：</b>两个事件的交集从 01:20 开始，到 02:00 结束。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>event1 = [\"10:00\",\"11:00\"], event2 = [\"14:00\",\"15:00\"]\n<b>输出：</b>false\n<b>解释：</b>两个事件不存在交集。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>event1.length == event2.length == 2.</code></li>\n\t<li><code>event1[i].length == event2[i].length == 5</code></li>\n\t<li><code>startTime<sub>1</sub> &lt;= endTime<sub>1</sub></code></li>\n\t<li><code>startTime<sub>2</sub> &lt;= endTime<sub>2</sub></code></li>\n\t<li>所有事件的时间都按照&nbsp;<code>HH:MM</code>&nbsp;格式给出</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2447.最大公因数等于 K 的子数组数目",
        "hardRate": "MEDIUM",
        "passRate": "41.25%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-subarrays-with-gcd-equal-to-k/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-subarrays-with-gcd-equal-to-k/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code> ，请你统计并返回 <code>nums</code>&nbsp;的子数组中元素的最大公因数等于 <code>k</code>&nbsp;的子数组数目。</p>\n\n<p><strong>子数组</strong> 是数组中一个连续的非空序列。</p>\n\n<p><strong>数组的最大公因数</strong>&nbsp;是能整除数组中所有元素的最大整数。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre><b>输入：</b>nums = [9,3,1,2,6,3], k = 3\n<b>输出：</b>4\n<b>解释：</b>nums 的子数组中，以 3 作为最大公因数的子数组如下：\n- [9,<strong><em>3</em></strong>,1,2,6,3]\n- [9,3,1,2,6,<em><strong>3</strong></em>]\n- [<strong><em>9,3</em></strong>,1,2,6,3]\n- [9,3,1,2,<em><strong>6,3</strong></em>]\n</pre>\n\n<p><b>示例 2：</b></p>\n\n<pre><b>输入：</b>nums = [4], k = 7\n<b>输出：</b>0\n<b>解释：</b>不存在以 7 作为最大公因数的子数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2448.使数组相等的最小开销",
        "hardRate": "HARD",
        "passRate": "36.09%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-make-array-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-make-array-equal/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>nums</code> 和&nbsp;<code>cost</code>&nbsp;，分别包含&nbsp;<code>n</code>&nbsp;个&nbsp;<strong>正</strong>&nbsp;整数。</p>\n\n<p>你可以执行下面操作 <strong>任意</strong>&nbsp;次：</p>\n\n<ul>\n\t<li>将&nbsp;<code>nums</code>&nbsp;中 <strong>任意</strong>&nbsp;元素增加或者减小 <code>1</code>&nbsp;。</li>\n</ul>\n\n<p>对第 <code>i</code>&nbsp;个元素执行一次操作的开销是&nbsp;<code>cost[i]</code>&nbsp;。</p>\n\n<p>请你返回使 <code>nums</code>&nbsp;中所有元素 <strong>相等</strong>&nbsp;的 <strong>最少</strong>&nbsp;总开销。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,3,5,2], cost = [2,3,1,14]\n<b>输出：</b>8\n<b>解释：</b>我们可以执行以下操作使所有元素变为 2 ：\n- 增加第 0 个元素 1 次，开销为 2 。\n- 减小第 1 个元素 1 次，开销为 3 。\n- 减小第 2 个元素 3 次，开销为 1 + 1 + 1 = 3 。\n总开销为 2 + 3 + 3 = 8 。\n这是最小开销。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,2,2,2,2], cost = [4,2,8,1,3]\n<b>输出：</b>0\n<b>解释：</b>数组中所有元素已经全部相等，不需要执行额外的操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length == cost.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], cost[i] &lt;= 10<sup>6</sup></code></li>\n\t<li>测试用例确保输出不超过 2<sup>53</sup>-1。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2449.使数组相似的最少操作次数",
        "hardRate": "HARD",
        "passRate": "65.44%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-make-arrays-similar/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-make-arrays-similar/solution",
        "problemsDesc": "<p>给你两个正整数数组&nbsp;<code>nums</code> 和&nbsp;<code>target</code>&nbsp;，两个数组长度相等。</p>\n\n<p>在一次操作中，你可以选择两个 <strong>不同</strong>&nbsp;的下标&nbsp;<code>i</code> 和&nbsp;<code>j</code>&nbsp;，其中&nbsp;<code>0 &lt;= i, j &lt; nums.length</code>&nbsp;，并且：</p>\n\n<ul>\n\t<li>令&nbsp;<code>nums[i] = nums[i] + 2</code>&nbsp;且</li>\n\t<li>令&nbsp;<code>nums[j] = nums[j] - 2</code>&nbsp;。</li>\n</ul>\n\n<p>如果两个数组中每个元素出现的频率相等，我们称两个数组是 <strong>相似</strong>&nbsp;的。</p>\n\n<p>请你返回将 <code>nums</code>&nbsp;变得与 <code>target</code>&nbsp;相似的最少操作次数。测试数据保证 <code>nums</code>&nbsp;一定能变得与 <code>target</code>&nbsp;相似。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [8,12,6], target = [2,14,10]\n<b>输出：</b>2\n<b>解释：</b>可以用两步操作将 nums 变得与 target 相似：\n- 选择 i = 0 和 j = 2 ，nums = [10,12,4] 。\n- 选择 i = 1 和 j = 2 ，nums = [10,14,2] 。\n2 次操作是最少需要的操作次数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,5], target = [4,1,3]\n<b>输出：</b>1\n<b>解释：</b>一步操作可以使 nums 变得与 target 相似：\n- 选择 i = 1 和 j = 2 ，nums = [1,4,3] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,1,1,1,1], target = [1,1,1,1,1]\n<b>输出：</b>0\n<b>解释：</b>数组 nums 已经与 target 相似。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length == target.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], target[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>nums</code>&nbsp;一定可以变得与&nbsp;<code>target</code> 相似。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2450.应用操作后不同二进制字符串的数量",
        "hardRate": "MEDIUM",
        "passRate": "75.59%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-distinct-binary-strings-after-applying-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-distinct-binary-strings-after-applying-operations/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2451.差值数组不同的字符串",
        "hardRate": "EASY",
        "passRate": "66.30%",
        "problemsUrl": "https://leetcode.cn/problems/odd-string-difference/",
        "solutionsUrl": "https://leetcode.cn/problems/odd-string-difference/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>words</code>&nbsp;，每一个字符串长度都相同，令所有字符串的长度都为 <code>n</code>&nbsp;。</p>\n\n<p>每个字符串&nbsp;<code>words[i]</code>&nbsp;可以被转化为一个长度为&nbsp;<code>n - 1</code>&nbsp;的&nbsp;<strong>差值整数数组</strong>&nbsp;<code>difference[i]</code>&nbsp;，其中对于&nbsp;<code>0 &lt;= j &lt;= n - 2</code>&nbsp;有&nbsp;<code>difference[i][j] = words[i][j+1] - words[i][j]</code>&nbsp;。注意两个字母的差值定义为它们在字母表中&nbsp;<strong>位置</strong>&nbsp;之差，也就是说&nbsp;<code>'a'</code>&nbsp;的位置是&nbsp;<code>0</code>&nbsp;，<code>'b'</code>&nbsp;的位置是&nbsp;<code>1</code>&nbsp;，<code>'z'</code>&nbsp;的位置是&nbsp;<code>25</code>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，字符串&nbsp;<code>\"acb\"</code>&nbsp;的差值整数数组是&nbsp;<code>[2 - 0, 1 - 2] = [2, -1]</code>&nbsp;。</li>\n</ul>\n\n<p><code>words</code>&nbsp;中所有字符串 <strong>除了一个字符串以外</strong>&nbsp;，其他字符串的差值整数数组都相同。你需要找到那个不同的字符串。</p>\n\n<p>请你返回<em>&nbsp;</em><code>words</code>中&nbsp;<strong>差值整数数组</strong>&nbsp;不同的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"adc\",\"wzy\",\"abc\"]\n<b>输出：</b>\"abc\"\n<b>解释：</b>\n- \"adc\" 的差值整数数组是 [3 - 0, 2 - 3] = [3, -1] 。\n- \"wzy\" 的差值整数数组是 [25 - 22, 24 - 25]= [3, -1] 。\n- \"abc\" 的差值整数数组是 [1 - 0, 2 - 1] = [1, 1] 。\n不同的数组是 [1, 1]，所以返回对应的字符串，\"abc\"。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"aaa\",\"bob\",\"ccc\",\"ddd\"]\n<b>输出：</b>\"bob\"\n<b>解释：</b>除了 \"bob\" 的差值整数数组是 [13, -13] 以外，其他字符串的差值整数数组都是 [0, 0] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>n == words[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 20</code></li>\n\t<li><code>words[i]</code>&nbsp;只含有小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2452.距离字典两次编辑以内的单词",
        "hardRate": "MEDIUM",
        "passRate": "65.02%",
        "problemsUrl": "https://leetcode.cn/problems/words-within-two-edits-of-dictionary/",
        "solutionsUrl": "https://leetcode.cn/problems/words-within-two-edits-of-dictionary/solution",
        "problemsDesc": "<p>给你两个字符串数组&nbsp;<code>queries</code> 和&nbsp;<code>dictionary</code>&nbsp;。数组中所有单词都只包含小写英文字母，且长度都相同。</p>\n\n<p>一次 <strong>编辑</strong>&nbsp;中，你可以从 <code>queries</code>&nbsp;中选择一个单词，将任意一个字母修改成任何其他字母。从&nbsp;<code>queries</code>&nbsp;中找到所有满足以下条件的字符串：<strong>不超过</strong>&nbsp;两次编辑内，字符串与&nbsp;<code>dictionary</code>&nbsp;中某个字符串相同。</p>\n\n<p>请你返回<em>&nbsp;</em><code>queries</code>&nbsp;中的单词列表，这些单词距离&nbsp;<code>dictionary</code>&nbsp;中的单词&nbsp;<strong>编辑次数</strong>&nbsp;不超过&nbsp;<strong>两次</strong>&nbsp;。单词返回的顺序需要与&nbsp;<code>queries</code>&nbsp;中原本顺序相同。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>queries = [\"word\",\"note\",\"ants\",\"wood\"], dictionary = [\"wood\",\"joke\",\"moat\"]\n<b>输出：</b>[\"word\",\"note\",\"wood\"]\n<strong>解释：</strong>\n- 将 \"word\" 中的 'r' 换成 'o' ，得到 dictionary 中的单词 \"wood\" 。\n- 将 \"note\" 中的 'n' 换成 'j' 且将 't' 换成 'k' ，得到 \"joke\" 。\n- \"ants\" 需要超过 2 次编辑才能得到 dictionary 中的单词。\n- \"wood\" 不需要修改（0 次编辑），就得到 dictionary 中相同的单词。\n所以我们返回 [\"word\",\"note\",\"wood\"] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>queries = [\"yes\"], dictionary = [\"not\"]\n<b>输出：</b>[]\n<strong>解释：</strong>\n\"yes\" 需要超过 2 次编辑才能得到 \"not\" 。\n所以我们返回空数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= queries.length, dictionary.length &lt;= 100</code></li>\n\t<li><code>n == queries[i].length == dictionary[j].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li>所有&nbsp;<code>queries[i]</code> 和&nbsp;<code>dictionary[j]</code>&nbsp;都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2453.摧毁一系列目标",
        "hardRate": "MEDIUM",
        "passRate": "35.45%",
        "problemsUrl": "https://leetcode.cn/problems/destroy-sequential-targets/",
        "solutionsUrl": "https://leetcode.cn/problems/destroy-sequential-targets/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>nums</code>&nbsp;，它包含若干正整数，表示数轴上你需要摧毁的目标所在的位置。同时给你一个整数&nbsp;<code>space</code>&nbsp;。</p>\n\n<p>你有一台机器可以摧毁目标。给机器 <strong>输入</strong>&nbsp;<code>nums[i]</code>&nbsp;，这台机器会摧毁所有位置在&nbsp;<code>nums[i] + c * space</code>&nbsp;的目标，其中&nbsp;<code>c</code>&nbsp;是任意非负整数。你想摧毁&nbsp;<code>nums</code>&nbsp;中 <strong>尽可能多</strong>&nbsp;的目标。</p>\n\n<p>请你返回在摧毁数目最多的前提下，<code>nums[i]</code>&nbsp;的 <strong>最小值</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [3,7,8,1,1,5], space = 2\n<b>输出：</b>1\n<b>解释：</b>如果我们输入 nums[3] ，我们可以摧毁位于 1,3,5,7,9,... 这些位置的目标。\n这种情况下， 我们总共可以摧毁 5 个目标（除了 nums[2]）。\n没有办法摧毁多于 5 个目标，所以我们返回 nums[3] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,3,5,2,4,6], space = 2\n<b>输出：</b>1\n<b>解释：</b>输入 nums[0] 或者 nums[3] 都会摧毁 3 个目标。\n没有办法摧毁多于 3 个目标。\n由于 nums[0] 是最小的可以摧毁 3 个目标的整数，所以我们返回 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [6,2,5], space = 100\n<b>输出：</b>2\n<b>解释：</b>无论我们输入哪个数字，都只能摧毁 1 个目标。输入的最小整数是 nums[1] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= space &lt;=&nbsp;10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2454.下一个更大元素 IV",
        "hardRate": "HARD",
        "passRate": "49.09%",
        "problemsUrl": "https://leetcode.cn/problems/next-greater-element-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/next-greater-element-iv/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的非负整数数组&nbsp;<code>nums</code>&nbsp;。对于&nbsp;<code>nums</code>&nbsp;中每一个整数，你必须找到对应元素的&nbsp;<strong>第二大</strong>&nbsp;整数。</p>\n\n<p>如果&nbsp;<code>nums[j]</code>&nbsp;满足以下条件，那么我们称它为&nbsp;<code>nums[i]</code>&nbsp;的&nbsp;<strong>第二大</strong>&nbsp;整数：</p>\n\n<ul>\n\t<li><code>j &gt; i</code></li>\n\t<li><code>nums[j] &gt; nums[i]</code></li>\n\t<li>恰好存在 <strong>一个</strong>&nbsp;<code>k</code>&nbsp;满足 <code>i &lt; k &lt; j</code>&nbsp;且&nbsp;<code>nums[k] &gt; nums[i]</code>&nbsp;。</li>\n</ul>\n\n<p>如果不存在&nbsp;<code>nums[j]</code>&nbsp;，那么第二大整数为&nbsp;<code>-1</code>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，数组&nbsp;<code>[1, 2, 4, 3]</code>&nbsp;中，<code>1</code>&nbsp;的第二大整数是&nbsp;<code>4</code>&nbsp;，<code>2</code>&nbsp;的第二大整数是&nbsp;<code>3</code>&nbsp;，<code>3</code> 和&nbsp;<code>4</code>&nbsp;的第二大整数是&nbsp;<code>-1</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回一个整数数组<em>&nbsp;</em><code>answer</code>&nbsp;，其中<em>&nbsp;</em><code>answer[i]</code>是<em>&nbsp;</em><code>nums[i]</code>&nbsp;的第二大整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,4,0,9,6]\n<b>输出：</b>[9,6,6,-1,-1]\n<strong>解释：</strong>\n下标为 0 处：2 的右边，4 是大于 2 的第一个整数，9 是第二个大于 2 的整数。\n下标为 1 处：4 的右边，9 是大于 4 的第一个整数，6 是第二个大于 4 的整数。\n下标为 2 处：0 的右边，9 是大于 0 的第一个整数，6 是第二个大于 0 的整数。\n下标为 3 处：右边不存在大于 9 的整数，所以第二大整数为 -1 。\n下标为 4 处：右边不存在大于 6 的整数，所以第二大整数为 -1 。\n所以我们返回 [9,6,6,-1,-1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,3]\n<b>输出：</b>[-1,-1]\n<strong>解释：</strong>\n由于每个数右边都没有更大的数，所以我们返回 [-1,-1] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2455.可被三整除的偶数的平均值",
        "hardRate": "EASY",
        "passRate": "63.56%",
        "problemsUrl": "https://leetcode.cn/problems/average-value-of-even-numbers-that-are-divisible-by-three/",
        "solutionsUrl": "https://leetcode.cn/problems/average-value-of-even-numbers-that-are-divisible-by-three/solution",
        "problemsDesc": "<p>给你一个由正整数组成的整数数组 <code>nums</code> ，返回其中可被 <code>3</code> 整除的所有偶数的平均值。</p>\n\n<p>注意：<code>n</code> 个元素的平均值等于 <code>n</code> 个元素 <strong>求和</strong> 再除以 <code>n</code> ，结果 <strong>向下取整</strong> 到最接近的整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,6,10,12,15]\n<strong>输出：</strong>9\n<strong>解释：</strong>6 和 12 是可以被 3 整除的偶数。(6 + 12) / 2 = 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,4,7,10]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在满足题目要求的整数，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2456.最流行的视频创作者",
        "hardRate": "MEDIUM",
        "passRate": "38.33%",
        "problemsUrl": "https://leetcode.cn/problems/most-popular-video-creator/",
        "solutionsUrl": "https://leetcode.cn/problems/most-popular-video-creator/solution",
        "problemsDesc": "<p>给你两个字符串数组 <code>creators</code> 和 <code>ids</code> ，和一个整数数组 <code>views</code> ，所有数组的长度都是 <code>n</code> 。平台上第 <code>i</code> 个视频者是&nbsp;<code>creator[i]</code> ，视频分配的 id 是 <code>ids[i]</code> ，且播放量为 <code>views[i]</code> 。</p>\n\n<p>视频创作者的 <strong>流行度</strong> 是该创作者的 <strong>所有</strong> 视频的播放量的 <strong>总和</strong> 。请找出流行度 <strong>最高</strong> 创作者以及该创作者播放量 <strong>最大</strong> 的视频的 id 。</p>\n\n<ul>\n\t<li>如果存在多个创作者流行度都最高，则需要找出所有符合条件的创作者。</li>\n\t<li>如果某个创作者存在多个播放量最高的视频，则只需要找出字典序最小的 <code>id</code> 。</li>\n</ul>\n\n<p>返回一个二维字符串数组<em> </em><code>answer</code><em> </em>，其中<em> </em><code>answer[i] = [creator<sub>i</sub>, id<sub>i</sub>]</code><em> </em>表示<em> </em><code>creator<sub>i</sub></code> 的流行度 <strong>最高</strong> 且其最流行的视频 id 是<em> </em><code>id<sub>i</sub></code><em> </em>，可以按任何顺序返回该结果<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>creators = [\"alice\",\"bob\",\"alice\",\"chris\"], ids = [\"one\",\"two\",\"three\",\"four\"], views = [5,10,5,4]\n<strong>输出：</strong>[[\"alice\",\"one\"],[\"bob\",\"two\"]]\n<strong>解释：</strong>\nalice 的流行度是 5 + 5 = 10 。\nbob 的流行度是 10 。\nchris 的流行度是 4 。\nalice 和 bob 是流行度最高的创作者。\nbob 播放量最高的视频 id 为 \"two\" 。\nalice 播放量最高的视频 id 是 \"one\" 和 \"three\" 。由于 \"one\" 的字典序比 \"three\" 更小，所以结果中返回的 id 是 \"one\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>creators = [\"alice\",\"alice\",\"alice\"], ids = [\"a\",\"b\",\"c\"], views = [1,2,2]\n<strong>输出：</strong>[[\"alice\",\"b\"]]\n<strong>解释：</strong>\nid 为 \"b\" 和 \"c\" 的视频都满足播放量最高的条件。\n由于 \"b\" 的字典序比 \"c\" 更小，所以结果中返回的 id 是 \"b\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == creators.length == ids.length == views.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= creators[i].length, ids[i].length &lt;= 5</code></li>\n\t<li><code>creators[i]</code> 和 <code>ids[i]</code> 仅由小写英文字母组成</li>\n\t<li><code>0 &lt;= views[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2457.美丽整数的最小增量",
        "hardRate": "MEDIUM",
        "passRate": "39.47%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-addition-to-make-integer-beautiful/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-addition-to-make-integer-beautiful/solution",
        "problemsDesc": "<p>给你两个正整数 <code>n</code> 和 <code>target</code> 。</p>\n\n<p>如果某个整数每一位上的数字相加小于或等于 <code>target</code> ，则认为这个整数是一个 <strong>美丽整数</strong> 。</p>\n\n<p>找出并返回满足 <code>n + x</code> 是 <strong>美丽整数</strong> 的最小非负整数 <code>x</code> 。生成的输入保证总可以使 <code>n</code> 变成一个美丽整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 16, target = 6\n<strong>输出：</strong>4\n<strong>解释：</strong>最初，n 是 16 ，且其每一位数字的和是 1 + 6 = 7 。在加 4 之后，n 变为 20 且每一位数字的和变成 2 + 0 = 2 。可以证明无法加上一个小于 4 的非负整数使 n 变成一个美丽整数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 467, target = 6\n<strong>输出：</strong>33\n<strong>解释：</strong>最初，n 是 467 ，且其每一位数字的和是 4 + 6 + 7 = 17 。在加 33 之后，n 变为 500 且每一位数字的和变成 5 + 0 + 0 = 5 。可以证明无法加上一个小于 33 的非负整数使 n 变成一个美丽整数。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 1, target = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>最初，n 是 1 ，且其每一位数字的和是 1 ，已经小于等于 target 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>12</sup></code></li>\n\t<li><code>1 &lt;= target &lt;= 150</code></li>\n\t<li>生成的输入保证总可以使 <code>n</code> 变成一个美丽整数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2458.移除子树后的二叉树高度",
        "hardRate": "HARD",
        "passRate": "41.10%",
        "problemsUrl": "https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries/solution",
        "problemsDesc": "<p>给你一棵 <strong>二叉树</strong> 的根节点 <code>root</code> ，树中有 <code>n</code> 个节点。每个节点都可以被分配一个从 <code>1</code> 到 <code>n</code> 且互不相同的值。另给你一个长度为 <code>m</code> 的数组 <code>queries</code> 。</p>\n\n<p>你必须在树上执行 <code>m</code> 个 <strong>独立</strong> 的查询，其中第 <code>i</code> 个查询你需要执行以下操作：</p>\n\n<ul>\n\t<li>从树中 <strong>移除</strong> 以 <code>queries[i]</code> 的值作为根节点的子树。题目所用测试用例保证 <code>queries[i]</code> <strong>不</strong> 等于根节点的值。</li>\n</ul>\n\n<p>返回一个长度为 <code>m</code> 的数组<em> </em><code>answer</code><em> </em>，其中<em> </em><code>answer[i]</code><em> </em>是执行第 <code>i</code> 个查询后树的高度。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>查询之间是独立的，所以在每个查询执行后，树会回到其 <strong>初始</strong> 状态。</li>\n\t<li>树的高度是从根到树中某个节点的 <strong>最长简单路径中的边数</strong> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/07/binaryytreeedrawio-1.png\" style=\"width: 495px; height: 281px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4]\n<strong>输出：</strong>[2]\n<strong>解释：</strong>上图展示了从树中移除以 4 为根节点的子树。\n树的高度是 2（路径为 1 -&gt; 3 -&gt; 2）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/07/binaryytreeedrawio-2.png\" style=\"width: 301px; height: 284px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,8,9,2,1,3,7,4,6], queries = [3,2,4,8]\n<strong>输出：</strong>[3,2,3,2]\n<strong>解释：</strong>执行下述查询：\n- 移除以 3 为根节点的子树。树的高度变为 3（路径为 5 -&gt; 8 -&gt; 2 -&gt; 4）。\n- 移除以 2 为根节点的子树。树的高度变为 2（路径为 5 -&gt; 8 -&gt; 1）。\n- 移除以 4 为根节点的子树。树的高度变为 3（路径为 5 -&gt; 8 -&gt; 2 -&gt; 6）。\n- 移除以 8 为根节点的子树。树的高度变为 2（路径为 5 -&gt; 9 -&gt; 3）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目是 <code>n</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= Node.val &lt;= n</code></li>\n\t<li>树中的所有值 <strong>互不相同</strong></li>\n\t<li><code>m == queries.length</code></li>\n\t<li><code>1 &lt;= m &lt;= min(n, 10<sup>4</sup>)</code></li>\n\t<li><code>1 &lt;= queries[i] &lt;= n</code></li>\n\t<li><code>queries[i] != root.val</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2459.通过移动项目到空白区域来排序数组",
        "hardRate": "HARD",
        "passRate": "60.00%",
        "problemsUrl": "https://leetcode.cn/problems/sort-array-by-moving-items-to-empty-space/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-array-by-moving-items-to-empty-space/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2460.对数组执行操作",
        "hardRate": "EASY",
        "passRate": "68.21%",
        "problemsUrl": "https://leetcode.cn/problems/apply-operations-to-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/apply-operations-to-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，数组大小为 <code>n</code> ，且由 <strong>非负</strong> 整数组成。</p>\n\n<p>你需要对数组执行 <code>n - 1</code> 步操作，其中第 <code>i</code> 步操作（从 <strong>0</strong> 开始计数）要求对 <code>nums</code> 中第 <code>i</code> 个元素执行下述指令：</p>\n\n<ul>\n\t<li>如果 <code>nums[i] == nums[i + 1]</code> ，则 <code>nums[i]</code> 的值变成原来的 <code>2</code> 倍，<code>nums[i + 1]</code> 的值变成 <code>0</code> 。否则，跳过这步操作。</li>\n</ul>\n\n<p>在执行完 <strong>全部</strong> 操作后，将所有 <code>0</code> <strong>移动</strong> 到数组的 <strong>末尾</strong> 。</p>\n\n<ul>\n\t<li>例如，数组 <code>[1,0,2,0,0,1]</code> 将所有 <code>0</code> 移动到末尾后变为 <code>[1,2,1,0,0,0]</code> 。</li>\n</ul>\n\n<p>返回结果数组。</p>\n\n<p><strong>注意</strong> 操作应当 <strong>依次有序</strong> 执行，而不是一次性全部执行。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2,1,1,0]\n<strong>输出：</strong>[1,4,2,0,0,0]\n<strong>解释：</strong>执行以下操作：\n- i = 0: nums[0] 和 nums[1] 不相等，跳过这步操作。\n- i = 1: nums[1] 和 nums[2] 相等，nums[1] 的值变成原来的 2 倍，nums[2] 的值变成 0 。数组变成 [1,<em><strong>4</strong></em>,<em><strong>0</strong></em>,1,1,0] 。\n- i = 2: nums[2] 和 nums[3] 不相等，所以跳过这步操作。\n- i = 3: nums[3] 和 nums[4] 相等，nums[3] 的值变成原来的 2 倍，nums[4] 的值变成 0 。数组变成 [1,4,0,<em><strong>2</strong></em>,<em><strong>0</strong></em>,0] 。\n- i = 4: nums[4] 和 nums[5] 相等，nums[4] 的值变成原来的 2 倍，nums[5] 的值变成 0 。数组变成 [1,4,0,2,<em><strong>0</strong></em>,<em><strong>0</strong></em>] 。\n执行完所有操作后，将 0 全部移动到数组末尾，得到结果数组 [1,4,2,0,0,0] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1]\n<strong>输出：</strong>[1,0]\n<strong>解释：</strong>无法执行任何操作，只需要将 0 移动到末尾。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 2000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2461.长度为 K 子数组中的最大和",
        "hardRate": "MEDIUM",
        "passRate": "30.63%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。请你从 <code>nums</code> 中满足下述条件的全部子数组中找出最大子数组和：</p>\n\n<ul>\n\t<li>子数组的长度是 <code>k</code>，且</li>\n\t<li>子数组中的所有元素 <strong>各不相同 。</strong></li>\n</ul>\n\n<p>返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 <code>0</code> 。</p>\n\n<p><strong>子数组</strong> 是数组中一段连续非空的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,5,4,2,9,9,9], k = 3\n<strong>输出：</strong>15\n<strong>解释：</strong>nums 中长度为 3 的子数组是：\n- [1,5,4] 满足全部条件，和为 10 。\n- [5,4,2] 满足全部条件，和为 11 。\n- [4,2,9] 满足全部条件，和为 15 。\n- [2,9,9] 不满足全部条件，因为元素 9 出现重复。\n- [9,9,9] 不满足全部条件，因为元素 9 出现重复。\n因为 15 是满足全部条件的所有子数组中的最大子数组和，所以返回 15 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,4,4], k = 3\n<strong>输出：</strong>0\n<strong>解释：</strong>nums 中长度为 3 的子数组是：\n- [4,4,4] 不满足全部条件，因为元素 4 出现重复。\n因为不存在满足全部条件的子数组，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2462.雇佣 K 位工人的总代价",
        "hardRate": "MEDIUM",
        "passRate": "37.60%",
        "problemsUrl": "https://leetcode.cn/problems/total-cost-to-hire-k-workers/",
        "solutionsUrl": "https://leetcode.cn/problems/total-cost-to-hire-k-workers/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>costs</code>&nbsp;，其中&nbsp;<code>costs[i]</code>&nbsp;是雇佣第 <code>i</code>&nbsp;位工人的代价。</p>\n\n<p>同时给你两个整数&nbsp;<code>k</code> 和&nbsp;<code>candidates</code>&nbsp;。我们想根据以下规则恰好雇佣&nbsp;<code>k</code>&nbsp;位工人：</p>\n\n<ul>\n\t<li>总共进行&nbsp;<code>k</code>&nbsp;轮雇佣，且每一轮恰好雇佣一位工人。</li>\n\t<li>在每一轮雇佣中，从最前面 <code>candidates</code>&nbsp;和最后面 <code>candidates</code>&nbsp;人中选出代价最小的一位工人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。\n\t<ul>\n\t\t<li>比方说，<code>costs = [3,2,7,7,1,2]</code> 且&nbsp;<code>candidates = 2</code>&nbsp;，第一轮雇佣中，我们选择第&nbsp;<code>4</code>&nbsp;位工人，因为他的代价最小&nbsp;<code>[<em>3,2</em>,7,7,<em><strong>1</strong>,2</em>]</code>&nbsp;。</li>\n\t\t<li>第二轮雇佣，我们选择第&nbsp;<code>1</code>&nbsp;位工人，因为他们的代价与第&nbsp;<code>4</code>&nbsp;位工人一样都是最小代价，而且下标更小，<code>[<em>3,<strong>2</strong></em>,7,<em>7,2</em>]</code>&nbsp;。注意每一轮雇佣后，剩余工人的下标可能会发生变化。</li>\n\t</ul>\n\t</li>\n\t<li>如果剩余员工数目不足 <code>candidates</code>&nbsp;人，那么下一轮雇佣他们中代价最小的一人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。</li>\n\t<li>一位工人只能被选择一次。</li>\n</ul>\n\n<p>返回雇佣恰好<em>&nbsp;</em><code>k</code>&nbsp;位工人的总代价。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n<b>输出：</b>11\n<b>解释：</b>我们总共雇佣 3 位工人。总代价一开始为 0 。\n- 第一轮雇佣，我们从 [<strong><em>17,12,10,2</em></strong>,7,<strong><em>2,11,20,8</em></strong>] 中选择。最小代价是 2 ，有两位工人，我们选择下标更小的一位工人，即第 3 位工人。总代价是 0 + 2 = 2 。\n- 第二轮雇佣，我们从 [<strong><em>17,12,10,7</em></strong>,<strong><em>2,11,20,8</em></strong>] 中选择。最小代价是 2 ，下标为 4 ，总代价是 2 + 2 = 4 。\n- 第三轮雇佣，我们从 [<strong><em>17,12,10,7,11,20,8</em></strong>] 中选择，最小代价是 7 ，下标为 3 ，总代价是 4 + 7 = 11 。注意下标为 3 的工人同时在最前面和最后面 4 位工人中。\n总雇佣代价是 11 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>costs = [1,2,4,1], k = 3, candidates = 3\n<b>输出：</b>4\n<b>解释：</b>我们总共雇佣 3 位工人。总代价一开始为 0 。\n- 第一轮雇佣，我们从 [<strong><em>1,2,4,1</em></strong>] 中选择。最小代价为 1 ，有两位工人，我们选择下标更小的一位工人，即第 0 位工人，总代价是 0 + 1 = 1 。注意，下标为 1 和 2 的工人同时在最前面和最后面 3 位工人中。\n- 第二轮雇佣，我们从 [<strong><em>2,4,1</em></strong>] 中选择。最小代价为 1 ，下标为 2 ，总代价是 1 + 1 = 2 。\n- 第三轮雇佣，少于 3 位工人，我们从剩余工人 [<strong><em>2,4</em></strong>] 中选择。最小代价是 2 ，下标为 0 。总代价为 2 + 2 = 4 。\n总雇佣代价是 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= costs.length &lt;= 10<sup>5 </sup></code></li>\n\t<li><code>1 &lt;= costs[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k, candidates &lt;= costs.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2463.最小移动总距离",
        "hardRate": "HARD",
        "passRate": "46.27%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-total-distance-traveled/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-total-distance-traveled/solution",
        "problemsDesc": "<p>X 轴上有一些机器人和工厂。给你一个整数数组&nbsp;<code>robot</code>&nbsp;，其中&nbsp;<code>robot[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个机器人的位置。再给你一个二维整数数组&nbsp;<code>factory</code>&nbsp;，其中&nbsp;<code>factory[j] = [position<sub>j</sub>, limit<sub>j</sub>]</code>&nbsp;，表示第 <code>j</code>&nbsp;个工厂的位置在&nbsp;<code>position<sub>j</sub></code>&nbsp;，且第 <code>j</code>&nbsp;个工厂最多可以修理&nbsp;<code>limit<sub>j</sub></code>&nbsp;个机器人。</p>\n\n<p>每个机器人所在的位置 <strong>互不相同</strong>&nbsp;。每个工厂所在的位置也 <strong>互不相同</strong>&nbsp;。注意一个机器人可能一开始跟一个工厂在 <strong>相同的位置</strong>&nbsp;。</p>\n\n<p>所有机器人一开始都是坏的，他们会沿着设定的方向一直移动。设定的方向要么是 X 轴的正方向，要么是 X 轴的负方向。当一个机器人经过一个没达到上限的工厂时，这个工厂会维修这个机器人，且机器人停止移动。</p>\n\n<p><b>任何时刻</b>，你都可以设置&nbsp;<strong>部分</strong>&nbsp;机器人的移动方向。你的目标是最小化所有机器人总的移动距离。</p>\n\n<p>请你返回所有机器人移动的最小总距离。测试数据保证所有机器人都可以被维修。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>所有机器人移动速度相同。</li>\n\t<li>如果两个机器人移动方向相同，它们永远不会碰撞。</li>\n\t<li>如果两个机器人迎面相遇，它们也不会碰撞，它们彼此之间会擦肩而过。</li>\n\t<li>如果一个机器人经过了一个已经达到上限的工厂，机器人会当作工厂不存在，继续移动。</li>\n\t<li>机器人从位置&nbsp;<code>x</code> 到位置&nbsp;<code>y</code>&nbsp;的移动距离为&nbsp;<code>|y - x|</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1667542978-utuiPv-image.png\" style=\"width: 500px; height: 320px;\" /></p>\n\n<pre>\n<b>输入：</b>robot = [0,4,6], factory = [[2,2],[6,2]]\n<b>输出：</b>4\n<b>解释：</b>如上图所示：\n- 第一个机器人从位置 0 沿着正方向移动，在第一个工厂处维修。\n- 第二个机器人从位置 4 沿着负方向移动，在第一个工厂处维修。\n- 第三个机器人在位置 6 被第二个工厂维修，它不需要移动。\n第一个工厂的维修上限是 2 ，它维修了 2 个机器人。\n第二个工厂的维修上限是 2 ，它维修了 1 个机器人。\n总移动距离是 |2 - 0| + |2 - 4| + |6 - 6| = 4 。没有办法得到比 4 更少的总移动距离。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1667542984-OAIRFN-image.png\" style=\"width: 500px; height: 329px;\" /></p>\n\n<pre>\n<b>输入：</b>robot = [1,-1], factory = [[-2,1],[2,1]]\n<b>输出：</b>2\n<b>解释：</b>如上图所示：\n- 第一个机器人从位置 1 沿着正方向移动，在第二个工厂处维修。\n- 第二个机器人在位置 -1 沿着负方向移动，在第一个工厂处维修。\n第一个工厂的维修上限是 1 ，它维修了 1 个机器人。\n第二个工厂的维修上限是 1 ，它维修了 1 个机器人。\n总移动距离是 |2 - 1| + |(-2) - (-1)| = 2 。没有办法得到比 2 更少的总移动距离。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= robot.length, factory.length &lt;= 100</code></li>\n\t<li><code>factory[j].length == 2</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= robot[i], position<sub>j</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= limit<sub>j</sub> &lt;= robot.length</code></li>\n\t<li>测试数据保证所有机器人都可以被维修。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2464.有效分割中的最少子数组数目",
        "hardRate": "MEDIUM",
        "passRate": "63.81%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-subarrays-in-a-valid-split/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-subarrays-in-a-valid-split/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2465.不同的平均值数目",
        "hardRate": "EASY",
        "passRate": "72.37%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-distinct-averages/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-distinct-averages/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <strong>偶数</strong>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>只要&nbsp;<code>nums</code> <strong>不是</strong>&nbsp;空数组，你就重复执行以下步骤：</p>\n\n<ul>\n\t<li>找到&nbsp;<code>nums</code>&nbsp;中的最小值，并删除它。</li>\n\t<li>找到&nbsp;<code>nums</code>&nbsp;中的最大值，并删除它。</li>\n\t<li>计算删除两数的平均值。</li>\n</ul>\n\n<p>两数 <code>a</code>&nbsp;和 <code>b</code>&nbsp;的 <strong>平均值</strong>&nbsp;为&nbsp;<code>(a + b) / 2</code>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，<code>2</code>&nbsp;和&nbsp;<code>3</code>&nbsp;的平均值是&nbsp;<code>(2 + 3) / 2 = 2.5</code>&nbsp;。</li>\n</ul>\n\n<p>返回上述过程能得到的 <strong>不同</strong>&nbsp;平均值的数目。</p>\n\n<p><strong>注意</strong>&nbsp;，如果最小值或者最大值有重复元素，可以删除任意一个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [4,1,4,0,3,5]\n<b>输出：</b>2\n<strong>解释：</strong>\n1. 删除 0 和 5 ，平均值是 (0 + 5) / 2 = 2.5 ，现在 nums = [4,1,4,3] 。\n2. 删除 1 和 4 ，平均值是 (1 + 4) / 2 = 2.5 ，现在 nums = [4,3] 。\n3. 删除 3 和 4 ，平均值是 (3 + 4) / 2 = 3.5 。\n2.5 ，2.5 和 3.5 之中总共有 2 个不同的数，我们返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,100]\n<b>输出：</b>1\n<strong>解释：</strong>\n删除 1 和 100 后只有一个平均值，所以我们返回 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>nums.length</code>&nbsp;是偶数。</li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2466.统计构造好字符串的方案数",
        "hardRate": "MEDIUM",
        "passRate": "46.25%",
        "problemsUrl": "https://leetcode.cn/problems/count-ways-to-build-good-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/count-ways-to-build-good-strings/solution",
        "problemsDesc": "<p>给你整数&nbsp;<code>zero</code>&nbsp;，<code>one</code>&nbsp;，<code>low</code>&nbsp;和&nbsp;<code>high</code>&nbsp;，我们从空字符串开始构造一个字符串，每一步执行下面操作中的一种：</p>\n\n<ul>\n\t<li>将&nbsp;<code>'0'</code>&nbsp;在字符串末尾添加&nbsp;<code>zero</code>&nbsp; 次。</li>\n\t<li>将&nbsp;<code>'1'</code>&nbsp;在字符串末尾添加&nbsp;<code>one</code>&nbsp;次。</li>\n</ul>\n\n<p>以上操作可以执行任意次。</p>\n\n<p>如果通过以上过程得到一个 <strong>长度</strong>&nbsp;在&nbsp;<code>low</code> 和&nbsp;<code>high</code>&nbsp;之间（包含上下边界）的字符串，那么这个字符串我们称为&nbsp;<strong>好</strong>&nbsp;字符串。</p>\n\n<p>请你返回满足以上要求的 <strong>不同</strong>&nbsp;好字符串数目。由于答案可能很大，请将结果对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>low = 3, high = 3, zero = 1, one = 1\n<b>输出：</b>8\n<b>解释：</b>\n一个可能的好字符串是 \"011\" 。\n可以这样构造得到：\"\" -&gt; \"0\" -&gt; \"01\" -&gt; \"011\" 。\n从 \"000\" 到 \"111\" 之间所有的二进制字符串都是好字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>low = 2, high = 3, zero = 1, one = 2\n<b>输出：</b>5\n<b>解释：</b>好字符串为 \"00\" ，\"11\" ，\"000\" ，\"110\" 和 \"011\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= low&nbsp;&lt;= high&nbsp;&lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= zero, one &lt;= low</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2467.树上最大得分和路径",
        "hardRate": "MEDIUM",
        "passRate": "50.25%",
        "problemsUrl": "https://leetcode.cn/problems/most-profitable-path-in-a-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/most-profitable-path-in-a-tree/solution",
        "problemsDesc": "<p>一个 <code>n</code>&nbsp;个节点的无向树，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，树的根结点是&nbsp;<code>0</code>&nbsp;号节点。给你一个长度为 <code>n - 1</code>&nbsp;的二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;，表示节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;在树中有一条边。</p>\n\n<p>在每一个节点&nbsp;<code>i</code>&nbsp;处有一扇门。同时给你一个都是偶数的数组&nbsp;<code>amount</code>&nbsp;，其中&nbsp;<code>amount[i]</code>&nbsp;表示：</p>\n\n<ul>\n\t<li>如果 <code>amount[i]</code>&nbsp;的值是负数，那么它表示打开节点&nbsp;<code>i</code>&nbsp;处门扣除的分数。</li>\n\t<li>如果 <code>amount[i]</code>&nbsp;的值是正数，那么它表示打开节点 <code>i</code>&nbsp;处门加上的分数。</li>\n</ul>\n\n<p>游戏按照如下规则进行：</p>\n\n<ul>\n\t<li>一开始，Alice 在节点&nbsp;<code>0</code>&nbsp;处，Bob 在节点&nbsp;<code>bob</code>&nbsp;处。</li>\n\t<li>每一秒钟，Alice 和 Bob <strong>分别</strong>&nbsp;移动到相邻的节点。Alice 朝着某个&nbsp;<strong>叶子结点</strong>&nbsp;移动，Bob 朝着节点&nbsp;<code>0</code>&nbsp;移动。</li>\n\t<li>对于他们之间路径上的 <strong>每一个</strong>&nbsp;节点，Alice 和 Bob 要么打开门并扣分，要么打开门并加分。注意：\n\t<ul>\n\t\t<li>如果门 <strong>已经打开</strong>&nbsp;（被另一个人打开），不会有额外加分也不会扣分。</li>\n\t\t<li>如果&nbsp;Alice 和 Bob <strong>同时</strong>&nbsp;到达一个节点，他们会共享这个节点的加分或者扣分。换言之，如果打开这扇门扣&nbsp;<code>c</code>&nbsp;分，那么&nbsp;Alice 和 Bob 分别扣&nbsp;<code>c / 2</code>&nbsp;分。如果这扇门的加分为&nbsp;<code>c</code>&nbsp;，那么他们分别加&nbsp;<code>c / 2</code>&nbsp;分。</li>\n\t</ul>\n\t</li>\n\t<li>如果 Alice 到达了一个叶子结点，她会停止移动。类似的，如果&nbsp;Bob 到达了节点&nbsp;<code>0</code>&nbsp;，他也会停止移动。注意这些事件互相 <strong>独立</strong>&nbsp;，不会影响另一方移动。</li>\n</ul>\n\n<p>请你返回&nbsp;Alice 朝最优叶子结点移动的 <strong>最大</strong>&nbsp;净得分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/29/eg1.png\" style=\"width: 275px; height: 275px;\"></p>\n\n<pre><b>输入：</b>edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6]\n<b>输出：</b>6\n<b>解释：</b>\n上图展示了输入给出的一棵树。游戏进行如下：\n- Alice 一开始在节点 0 处，Bob 在节点 3 处。他们分别打开所在节点的门。\n  Alice 得分为 -2 。\n- Alice 和 Bob 都移动到节点 1 。\n&nbsp; 因为他们同时到达这个节点，他们一起打开门并平分得分。\n&nbsp; Alice 的得分变为 -2 + (4 / 2) = 0 。\n- Alice 移动到节点 3 。因为 Bob 已经打开了这扇门，Alice 得分不变。\n&nbsp; Bob 移动到节点 0 ，并停止移动。\n- Alice 移动到节点 4 并打开这个节点的门，她得分变为 0 + 6 = 6 。\n现在，Alice 和 Bob 都不能进行任何移动了，所以游戏结束。\nAlice 无法得到更高分数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/29/eg2.png\" style=\"width: 250px; height: 78px;\"></p>\n\n<pre><b>输入：</b>edges = [[0,1]], bob = 1, amount = [-7280,2350]\n<b>输出：</b>-7280\n<b>解释：</b>\nAlice 按照路径 0-&gt;1 移动，同时 Bob 按照路径 1-&gt;0 移动。\n所以 Alice 只打开节点 0 处的门，她的得分为 -7280 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>edges</code>&nbsp;表示一棵有效的树。</li>\n\t<li><code>1 &lt;= bob &lt; n</code></li>\n\t<li><code>amount.length == n</code></li>\n\t<li><code>amount[i]</code>&nbsp;是范围&nbsp;<code>[-10<sup>4</sup>, 10<sup>4</sup>]</code>&nbsp;之间的一个&nbsp;<strong>偶数</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2468.根据限制分割消息",
        "hardRate": "HARD",
        "passRate": "44.39%",
        "problemsUrl": "https://leetcode.cn/problems/split-message-based-on-limit/",
        "solutionsUrl": "https://leetcode.cn/problems/split-message-based-on-limit/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>message</code>&nbsp;和一个正整数&nbsp;<code>limit</code>&nbsp;。</p>\n\n<p>你需要根据 <code>limit</code>&nbsp;将&nbsp;<code>message</code> <strong>分割</strong>&nbsp;成一个或多个 <strong>部分</strong>&nbsp;。每个部分的结尾都是&nbsp;<code>\"&lt;a/b&gt;\"</code>&nbsp;，其中&nbsp;<code>\"b\"</code>&nbsp;用分割出来的总数 <b>替换</b>，&nbsp;<code>\"a\"</code>&nbsp;用当前部分所在的编号 <strong>替换</strong>&nbsp;，编号从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>b</code>&nbsp;依次编号。除此以外，除了最后一部分长度 <strong>小于等于</strong>&nbsp;<code>limit</code>&nbsp;以外，其他每一部分（包括结尾部分）的长度都应该&nbsp;<strong>等于</strong>&nbsp;<code>limit</code>&nbsp;。</p>\n\n<p>你需要确保分割后的结果数组，删掉每部分的结尾并<strong>&nbsp;按顺序&nbsp;</strong>连起来后，能够得到&nbsp;<code>message</code>&nbsp;。同时，结果数组越短越好。</p>\n\n<p>请你返回<em>&nbsp;</em><code>message</code>&nbsp; 分割后得到的结果数组。如果无法按要求分割&nbsp;<code>message</code>&nbsp;，返回一个空数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>message = \"this is really a very awesome message\", limit = 9\n<b>输出：</b>[\"thi&lt;1/14&gt;\",\"s i&lt;2/14&gt;\",\"s r&lt;3/14&gt;\",\"eal&lt;4/14&gt;\",\"ly &lt;5/14&gt;\",\"a v&lt;6/14&gt;\",\"ery&lt;7/14&gt;\",\" aw&lt;8/14&gt;\",\"eso&lt;9/14&gt;\",\"me&lt;10/14&gt;\",\" m&lt;11/14&gt;\",\"es&lt;12/14&gt;\",\"sa&lt;13/14&gt;\",\"ge&lt;14/14&gt;\"]\n<strong>解释：</strong>\n前面 9 个部分分别从 message 中得到 3 个字符。\n接下来的 5 个部分分别从 message 中得到 2 个字符。\n这个例子中，包含最后一个部分在内，每个部分的长度都为 9 。\n可以证明没有办法分割成少于 14 个部分。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>message = \"short message\", limit = 15\n<b>输出：</b>[\"short mess&lt;1/2&gt;\",\"age&lt;2/2&gt;\"]\n<strong>解释：</strong>\n在给定限制下，字符串可以分成两个部分：\n- 第一个部分包含 10 个字符，长度为 15 。\n- 第二个部分包含 3 个字符，长度为 8 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= message.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>message</code>&nbsp;只包含小写英文字母和&nbsp;<code>' '</code>&nbsp;。</li>\n\t<li><code>1 &lt;= limit &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2469.温度转换",
        "hardRate": "EASY",
        "passRate": "86.90%",
        "problemsUrl": "https://leetcode.cn/problems/convert-the-temperature/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-the-temperature/solution",
        "problemsDesc": "<p>给你一个四舍五入到两位小数的非负浮点数 <code>celsius</code> 来表示温度，以 <strong>摄氏度</strong>（<strong>Celsius</strong>）为单位。</p>\n\n<p>你需要将摄氏度转换为 <strong>开氏度</strong>（<strong>Kelvin</strong>）和 <strong>华氏度</strong>（<strong>Fahrenheit</strong>），并以数组 <code>ans = [kelvin, fahrenheit]</code> 的形式返回结果。</p>\n\n<p>返回数组<em> <code>ans</code></em> 。与实际答案误差不超过 <code>10<sup>-5</sup></code> 的会视为正确答案<strong>。</strong></p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><code>开氏度 = 摄氏度 + 273.15</code></li>\n\t<li><code>华氏度 = 摄氏度 * 1.80 + 32.00</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1 ：</strong></p>\n\n<pre><strong>输入：</strong>celsius = 36.50\n<strong>输出：</strong>[309.65000,97.70000]\n<strong>解释：</strong>36.50 摄氏度：转换为开氏度是 309.65 ，转换为华氏度是 97.70 。</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre><strong>输入：</strong>celsius = 122.11\n<strong>输出：</strong>[395.26000,251.79800]\n<strong>解释：</strong>122.11 摄氏度：转换为开氏度是 395.26 ，转换为华氏度是 251.798 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= celsius &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2470.最小公倍数为 K 的子数组数目",
        "hardRate": "MEDIUM",
        "passRate": "40.71%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-subarrays-with-lcm-equal-to-k/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-subarrays-with-lcm-equal-to-k/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <code>nums</code> 的 <strong>子数组</strong> 中满足 <em>元素最小公倍数为 <code>k</code> </em>的子数组数目。</p>\n\n<p><strong>子数组</strong> 是数组中一个连续非空的元素序列。</p>\n\n<p><strong>数组的最小公倍数</strong> 是可被所有数组元素整除的最小正整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1 ：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,6,2,7,1], k = 6\n<strong>输出：</strong>4\n<strong>解释：</strong>以 6 为最小公倍数的子数组是：\n- [<em><strong>3</strong></em>,<em><strong>6</strong></em>,2,7,1]\n- [<em><strong>3</strong></em>,<em><strong>6</strong></em>,<em><strong>2</strong></em>,7,1]\n- [3,<em><strong>6</strong></em>,2,7,1]\n- [3,<em><strong>6</strong></em>,<em><strong>2</strong></em>,7,1]\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3], k = 2\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在以 2 为最小公倍数的子数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2471.逐层排序二叉树所需的最少操作数目",
        "hardRate": "MEDIUM",
        "passRate": "55.67%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/solution",
        "problemsDesc": "<p>给你一个 <strong>值互不相同</strong> 的二叉树的根节点 <code>root</code> 。</p>\n\n<p>在一步操作中，你可以选择 <strong>同一层</strong> 上任意两个节点，交换这两个节点的值。</p>\n\n<p>返回每一层按 <strong>严格递增顺序</strong> 排序所需的最少操作数目。</p>\n\n<p>节点的 <strong>层数</strong> 是该节点和根节点之间的路径的边数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1 ：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/09/18/image-20220918174006-2.png\" style=\"width: 500px; height: 324px;\">\n<pre><strong>输入：</strong>root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n- 交换 4 和 3 。第 2 层变为 [3,4] 。\n- 交换 7 和 5 。第 3 层变为 [5,6,8,7] 。\n- 交换 8 和 7 。第 3 层变为 [5,6,7,8] 。\n共计用了 3 步操作，所以返回 3 。\n可以证明 3 是需要的最少操作数目。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/09/18/image-20220918174026-3.png\" style=\"width: 400px; height: 303px;\">\n<pre><strong>输入：</strong>root = [1,3,2,7,6,5,4]\n<strong>输出：</strong>3\n<strong>解释：\n</strong>- 交换 3 和 2 。第 2 层变为 [2,3] 。 \n- 交换 7 和 4 。第 3 层变为 [4,6,5,7] 。 \n- 交换 6 和 5 。第 3 层变为 [4,5,6,7] 。\n共计用了 3 步操作，所以返回 3 。 \n可以证明 3 是需要的最少操作数目。\n</pre>\n\n<p><strong>示例 3 ：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/09/18/image-20220918174052-4.png\" style=\"width: 400px; height: 274px;\">\n<pre><strong>输入：</strong>root = [1,2,3,4,5,6]\n<strong>输出：</strong>0\n<strong>解释：</strong>每一层已经按递增顺序排序，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 10<sup>5</sup>]</code> 。</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li>树中的所有值 <strong>互不相同</strong> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2472.不重叠回文子字符串的最大数目",
        "hardRate": "HARD",
        "passRate": "43.96%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和一个 <strong>正</strong> 整数 <code>k</code> 。</p>\n\n<p>从字符串 <code>s</code> 中选出一组满足下述条件且 <strong>不重叠</strong> 的子字符串：</p>\n\n<ul>\n\t<li>每个子字符串的长度 <strong>至少</strong> 为 <code>k</code> 。</li>\n\t<li>每个子字符串是一个 <strong>回文串</strong> 。</li>\n</ul>\n\n<p>返回最优方案中能选择的子字符串的 <strong>最大</strong> 数目。</p>\n\n<p><strong>子字符串</strong> 是字符串中一个连续的字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abaccdbbd\", k = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>可以选择 s = \"<em><strong>aba</strong></em>cc<em><strong>dbbd</strong></em>\" 中斜体加粗的子字符串。\"aba\" 和 \"dbbd\" 都是回文，且长度至少为 k = 3 。\n可以证明，无法选出两个以上的有效子字符串。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"adbcda\", k = 2\n<strong>输出：</strong>0\n<strong>解释：</strong>字符串中不存在长度至少为 2 的回文子字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2473.购买苹果的最低成本",
        "hardRate": "MEDIUM",
        "passRate": "59.76%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-buy-apples/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-buy-apples/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2474.购买量严格增加的客户",
        "hardRate": "HARD",
        "passRate": "49.83%",
        "problemsUrl": "https://leetcode.cn/problems/customers-with-strictly-increasing-purchases/",
        "solutionsUrl": "https://leetcode.cn/problems/customers-with-strictly-increasing-purchases/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2475.数组中不等三元组的数目",
        "hardRate": "EASY",
        "passRate": "77.82%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-unequal-triplets-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-unequal-triplets-in-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的正整数数组 <code>nums</code> 。请你找出并统计满足下述条件的三元组 <code>(i, j, k)</code> 的数目：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; k &lt; nums.length</code></li>\n\t<li><code>nums[i]</code>、<code>nums[j]</code> 和 <code>nums[k]</code> <strong>两两不同</strong> 。\n\t<ul>\n\t\t<li>换句话说：<code>nums[i] != nums[j]</code>、<code>nums[i] != nums[k]</code> 且 <code>nums[j] != nums[k]</code> 。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>返回满足上述条件三元组的数目<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,4,2,4,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>下面列出的三元组均满足题目条件：\n- (0, 2, 4) 因为 4 != 2 != 3\n- (1, 2, 4) 因为 4 != 2 != 3\n- (2, 3, 4) 因为 2 != 4 != 3\n共计 3 个三元组，返回 3 。\n注意 (2, 0, 4) 不是有效的三元组，因为 2 &gt; 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,1,1]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在满足条件的三元组，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2476.二叉搜索树最近节点查询",
        "hardRate": "MEDIUM",
        "passRate": "41.38%",
        "problemsUrl": "https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/solution",
        "problemsDesc": "<p>给你一个 <strong>二叉搜索树</strong> 的根节点 <code>root</code> ，和一个由正整数组成、长度为 <code>n</code> 的数组 <code>queries</code> 。</p>\n\n<p>请你找出一个长度为 <code>n</code> 的 <strong>二维</strong> 答案数组 <code>answer</code> ，其中 <code>answer[i] = [min<sub>i</sub>, max<sub>i</sub>]</code> ：</p>\n\n<ul>\n\t<li><code>min<sub>i</sub></code> 是树中小于等于&nbsp;<code>queries[i]</code> 的 <strong>最大值</strong> 。如果不存在这样的值，则使用 <code>-1</code> 代替。</li>\n\t<li><code>max<sub>i</sub></code> 是树中大于等于&nbsp;<code>queries[i]</code> 的 <strong>最小值</strong> 。如果不存在这样的值，则使用 <code>-1</code> 代替。</li>\n</ul>\n\n<p>返回数组 <code>answer</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1 ：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/28/bstreeedrawioo.png\" style=\"width: 261px; height: 281px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]\n<strong>输出：</strong>[[2,2],[4,6],[15,-1]]\n<strong>解释：</strong>按下面的描述找出并返回查询的答案：\n- 树中小于等于 2 的最大值是 2 ，且大于等于 2 的最小值也是 2 。所以第一个查询的答案是 [2,2] 。\n- 树中小于等于 5 的最大值是 4 ，且大于等于 5 的最小值是 6 。所以第二个查询的答案是 [4,6] 。\n- 树中小于等于 16 的最大值是 15 ，且大于等于 16 的最小值不存在。所以第三个查询的答案是 [15,-1] 。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/28/bstttreee.png\" style=\"width: 101px; height: 121px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [4,null,9], queries = [3]\n<strong>输出：</strong>[[-1,4]]\n<strong>解释：</strong>树中不存在小于等于 3 的最大值，且大于等于 3 的最小值是 4 。所以查询的答案是 [-1,4] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[2, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>\n\t<li><code>n == queries.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= queries[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2477.到达首都的最少油耗",
        "hardRate": "MEDIUM",
        "passRate": "53.00%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/solution",
        "problemsDesc": "<p>给你一棵 <code>n</code>&nbsp;个节点的树（一个无向、连通、无环图），每个节点表示一个城市，编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，且恰好有&nbsp;<code>n - 1</code>&nbsp;条路。<code>0</code>&nbsp;是首都。给你一个二维整数数组&nbsp;<code>roads</code>&nbsp;，其中&nbsp;<code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;，表示城市&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条&nbsp;<strong>双向路</strong>&nbsp;。</p>\n\n<p>每个城市里有一个代表，他们都要去首都参加一个会议。</p>\n\n<p>每座城市里有一辆车。给你一个整数&nbsp;<code>seats</code>&nbsp;表示每辆车里面座位的数目。</p>\n\n<p>城市里的代表可以选择乘坐所在城市的车，或者乘坐其他城市的车。相邻城市之间一辆车的油耗是一升汽油。</p>\n\n<p>请你返回到达首都最少需要多少升汽油。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/22/a4c380025e3ff0c379525e96a7d63a3.png\" style=\"width: 303px; height: 332px;\"></p>\n\n<pre><b>输入：</b>roads = [[0,1],[0,2],[0,3]], seats = 5\n<b>输出：</b>3\n<b>解释：</b>\n- 代表 1 直接到达首都，消耗 1 升汽油。\n- 代表 2 直接到达首都，消耗 1 升汽油。\n- 代表 3 直接到达首都，消耗 1 升汽油。\n最少消耗 3 升汽油。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/16/2.png\" style=\"width: 274px; height: 340px;\"></p>\n\n<pre><b>输入：</b>roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2\n<b>输出：</b>7\n<b>解释：</b>\n- 代表 2 到达城市 3 ，消耗 1 升汽油。\n- 代表 2 和代表 3 一起到达城市 1 ，消耗 1 升汽油。\n- 代表 2 和代表 3 一起到达首都，消耗 1 升汽油。\n- 代表 1 直接到达首都，消耗 1 升汽油。\n- 代表 5 直接到达首都，消耗 1 升汽油。\n- 代表 6 到达城市 4 ，消耗 1 升汽油。\n- 代表 4 和代表 6 一起到达首都，消耗 1 升汽油。\n最少消耗 7 升汽油。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/27/efcf7f7be6830b8763639cfd01b690a.png\" style=\"width: 108px; height: 86px;\"></p>\n\n<pre><b>输入：</b>roads = [], seats = 1\n<b>输出：</b>0\n<b>解释：</b>没有代表需要从别的城市到达首都。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>roads.length == n - 1</code></li>\n\t<li><code>roads[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>roads</code>&nbsp;表示一棵合法的树。</li>\n\t<li><code>1 &lt;= seats &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2478.完美分割的方案数",
        "hardRate": "HARD",
        "passRate": "39.93%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-beautiful-partitions/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-beautiful-partitions/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，每个字符是数字&nbsp;<code>'1'</code>&nbsp;到&nbsp;<code>'9'</code>&nbsp;，再给你两个整数&nbsp;<code>k</code> 和&nbsp;<code>minLength</code>&nbsp;。</p>\n\n<p>如果对 <code>s</code>&nbsp;的分割满足以下条件，那么我们认为它是一个 <strong>完美</strong>&nbsp;分割：</p>\n\n<ul>\n\t<li><code>s</code>&nbsp;被分成 <code>k</code>&nbsp;段互不相交的子字符串。</li>\n\t<li>每个子字符串长度都 <strong>至少</strong>&nbsp;为&nbsp;<code>minLength</code>&nbsp;。</li>\n\t<li>每个子字符串的第一个字符都是一个 <b>质数</b> 数字，最后一个字符都是一个 <strong>非质数</strong>&nbsp;数字。质数数字为&nbsp;<code>'2'</code>&nbsp;，<code>'3'</code>&nbsp;，<code>'5'</code>&nbsp;和&nbsp;<code>'7'</code>&nbsp;，剩下的都是非质数数字。</li>\n</ul>\n\n<p>请你返回 <code>s</code>&nbsp;的 <strong>完美</strong>&nbsp;分割数目。由于答案可能很大，请返回答案对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后的结果。</p>\n\n<p>一个 <strong>子字符串</strong>&nbsp;是字符串中一段连续字符串序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"23542185131\", k = 3, minLength = 2\n<b>输出：</b>3\n<b>解释：</b>存在 3 种完美分割方案：\n\"2354 | 218 | 5131\"\n\"2354 | 21851 | 31\"\n\"2354218 | 51 | 31\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"23542185131\", k = 3, minLength = 3\n<b>输出：</b>1\n<b>解释：</b>存在一种完美分割方案：\"2354 | 218 | 5131\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"3312958\", k = 3, minLength = 1\n<b>输出：</b>1\n<b>解释：</b>存在一种完美分割方案：\"331 | 29 | 58\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k, minLength &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code>&nbsp;每个字符都为数字&nbsp;<code>'1'</code>&nbsp;到&nbsp;<code>'9'</code> 之一。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2479.两个不重叠子树的最大异或值",
        "hardRate": "HARD",
        "passRate": "65.86%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-xor-of-two-non-overlapping-subtrees/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-xor-of-two-non-overlapping-subtrees/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2480.形成化学键",
        "hardRate": "EASY",
        "passRate": "84.17%",
        "problemsUrl": "https://leetcode.cn/problems/form-a-chemical-bond/",
        "solutionsUrl": "https://leetcode.cn/problems/form-a-chemical-bond/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2481.分割圆的最少切割次数",
        "hardRate": "EASY",
        "passRate": "58.77%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cuts-to-divide-a-circle/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cuts-to-divide-a-circle/solution",
        "problemsDesc": "<p>圆内一个 <strong>有效切割</strong>&nbsp;，符合以下二者之一：</p>\n\n<ul>\n\t<li>该切割是两个端点在圆上的线段，且该线段经过圆心。</li>\n\t<li>该切割是一端在圆心另一端在圆上的线段。</li>\n</ul>\n\n<p>一些有效和无效的切割如下图所示。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/29/alldrawio.png\" style=\"width: 450px; height: 174px;\" /></p>\n\n<p>给你一个整数&nbsp;<code>n</code>&nbsp;，请你返回将圆切割成相等的&nbsp;<code>n</code>&nbsp;等分的&nbsp;<strong>最少</strong>&nbsp;切割次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/24/11drawio.png\" style=\"width: 200px; height: 200px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 4\n<b>输出：</b>2\n<b>解释：</b>\n上图展示了切割圆 2 次，得到四等分。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/24/22drawio.png\" style=\"width: 200px; height: 201px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 3\n<b>输出：</b>3\n<strong>解释：</strong>\n最少需要切割 3 次，将圆切成三等分。\n少于 3 次切割无法将圆切成大小相等面积相同的 3 等分。\n同时可以观察到，第一次切割无法将圆切割开。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2482.行和列中一和零的差值",
        "hardRate": "MEDIUM",
        "passRate": "82.43%",
        "problemsUrl": "https://leetcode.cn/problems/difference-between-ones-and-zeros-in-row-and-column/",
        "solutionsUrl": "https://leetcode.cn/problems/difference-between-ones-and-zeros-in-row-and-column/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;二进制矩阵&nbsp;<code>grid</code>&nbsp;。</p>\n\n<p>我们按照如下过程，定义一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;差值矩阵&nbsp;<code>diff</code>&nbsp;：</p>\n\n<ul>\n\t<li>令第&nbsp;<code>i</code>&nbsp;行一的数目为&nbsp;<code>onesRow<sub>i</sub></code>&nbsp;。</li>\n\t<li>令第&nbsp;<code>j</code>&nbsp;列一的数目为&nbsp;<code>onesCol<sub>j</sub></code><sub>&nbsp;</sub>。</li>\n\t<li>令第&nbsp;<code>i</code>&nbsp;行零的数目为&nbsp;<code>zerosRow<sub>i</sub></code>&nbsp;。</li>\n\t<li>令第&nbsp;<code>j</code>&nbsp;列零的数目为&nbsp;<code>zerosCol<sub>j</sub></code>&nbsp;。</li>\n\t<li><code>diff[i][j] = onesRow<sub>i</sub> + onesCol<sub>j</sub> - zerosRow<sub>i</sub> - zerosCol<sub>j</sub></code></li>\n</ul>\n\n<p>请你返回差值矩阵<em>&nbsp;</em><code>diff</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2022/11/06/image-20221106171729-5.png\" style=\"width: 400px; height: 208px;\"></p>\n\n<pre><b>输入：</b>grid = [[0,1,1],[1,0,1],[0,0,1]]\n<b>输出：</b>[[0,0,4],[0,0,4],[-2,-2,2]]\n<b>解释：</b>\n- diff[0][0] = <code>onesRow<sub>0</sub> + onesCol<sub>0</sub> - zerosRow<sub>0</sub> - zerosCol<sub>0</sub></code> = 2 + 1 - 1 - 2 = 0 \n- diff[0][1] = <code>onesRow<sub>0</sub> + onesCol<sub>1</sub> - zerosRow<sub>0</sub> - zerosCol<sub>1</sub></code> = 2 + 1 - 1 - 2 = 0 \n- diff[0][2] = <code>onesRow<sub>0</sub> + onesCol<sub>2</sub> - zerosRow<sub>0</sub> - zerosCol<sub>2</sub></code> = 2 + 3 - 1 - 0 = 4 \n- diff[1][0] = <code>onesRow<sub>1</sub> + onesCol<sub>0</sub> - zerosRow<sub>1</sub> - zerosCol<sub>0</sub></code> = 2 + 1 - 1 - 2 = 0 \n- diff[1][1] = <code>onesRow<sub>1</sub> + onesCol<sub>1</sub> - zerosRow<sub>1</sub> - zerosCol<sub>1</sub></code> = 2 + 1 - 1 - 2 = 0 \n- diff[1][2] = <code>onesRow<sub>1</sub> + onesCol<sub>2</sub> - zerosRow<sub>1</sub> - zerosCol<sub>2</sub></code> = 2 + 3 - 1 - 0 = 4 \n- diff[2][0] = <code>onesRow<sub>2</sub> + onesCol<sub>0</sub> - zerosRow<sub>2</sub> - zerosCol<sub>0</sub></code> = 1 + 1 - 2 - 2 = -2\n- diff[2][1] = <code>onesRow<sub>2</sub> + onesCol<sub>1</sub> - zerosRow<sub>2</sub> - zerosCol<sub>1</sub></code> = 1 + 1 - 2 - 2 = -2\n- diff[2][2] = <code>onesRow<sub>2</sub> + onesCol<sub>2</sub> - zerosRow<sub>2</sub> - zerosCol<sub>2</sub></code> = 1 + 3 - 2 - 0 = 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2022/11/06/image-20221106171747-6.png\" style=\"width: 358px; height: 150px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,1,1],[1,1,1]]\n<b>输出：</b>[[5,5,5],[5,5,5]]\n<strong>解释：</strong>\n- diff[0][0] = onesRow<sub>0</sub> + onesCol<sub>0</sub> - zerosRow<sub>0</sub> - zerosCol<sub>0</sub> = 3 + 2 - 0 - 0 = 5\n- diff[0][1] = onesRow<sub>0</sub> + onesCol<sub>1</sub> - zerosRow<sub>0</sub> - zerosCol<sub>1</sub> = 3 + 2 - 0 - 0 = 5\n- diff[0][2] = onesRow<sub>0</sub> + onesCol<sub>2</sub> - zerosRow<sub>0</sub> - zerosCol<sub>2</sub> = 3 + 2 - 0 - 0 = 5\n- diff[1][0] = onesRow<sub>1</sub> + onesCol<sub>0</sub> - zerosRow<sub>1</sub> - zerosCol<sub>0</sub> = 3 + 2 - 0 - 0 = 5\n- diff[1][1] = onesRow<sub>1</sub> + onesCol<sub>1</sub> - zerosRow<sub>1</sub> - zerosCol<sub>1</sub> = 3 + 2 - 0 - 0 = 5\n- diff[1][2] = onesRow<sub>1</sub> + onesCol<sub>2</sub> - zerosRow<sub>1</sub> - zerosCol<sub>2</sub> = 3 + 2 - 0 - 0 = 5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>grid[i][j]</code>&nbsp;要么是&nbsp;<code>0</code>&nbsp;，要么是&nbsp;<code>1</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2483.商店的最少代价",
        "hardRate": "MEDIUM",
        "passRate": "63.24%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-penalty-for-a-shop/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-penalty-for-a-shop/solution",
        "problemsDesc": "<p>给你一个顾客访问商店的日志，用一个下标从 <strong>0</strong>&nbsp;开始且只包含字符&nbsp;<code>'N'</code> 和&nbsp;<code>'Y'</code>&nbsp;的字符串&nbsp;<code>customers</code>&nbsp;表示：</p>\n\n<ul>\n\t<li>如果第&nbsp;<code>i</code>&nbsp;个字符是&nbsp;<code>'Y'</code>&nbsp;，它表示第&nbsp;<code>i</code>&nbsp;小时有顾客到达。</li>\n\t<li>如果第&nbsp;<code>i</code>&nbsp;个字符是&nbsp;<code>'N'</code>&nbsp;，它表示第 <code>i</code>&nbsp;小时没有顾客到达。</li>\n</ul>\n\n<p>如果商店在第&nbsp;<code>j</code>&nbsp;小时关门（<code>0 &lt;= j &lt;= n</code>），代价按如下方式计算：</p>\n\n<ul>\n\t<li>在开门期间，如果某一个小时没有顾客到达，代价增加 <code>1</code>&nbsp;。</li>\n\t<li>在关门期间，如果某一个小时有顾客到达，代价增加&nbsp;<code>1</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回在确保代价 <strong>最小</strong>&nbsp;的前提下，商店的&nbsp;<strong>最早</strong>&nbsp;关门时间。</p>\n\n<p>注意，商店在第 <code>j</code>&nbsp;小时关门表示在第 <code>j</code> 小时以及之后商店处于关门状态。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>customers = \"YYNY\"\n<b>输出：</b>2\n<b>解释：</b>\n- 第 0 小时关门，总共 1+1+0+1 = 3 代价。\n- 第 1 小时关门，总共 0+1+0+1 = 2 代价。\n- 第 2 小时关门，总共 0+0+0+1 = 1 代价。\n- 第 3 小时关门，总共 0+0+1+1 = 2 代价。\n- 第 4 小时关门，总共 0+0+1+0 = 1 代价。\n在第 2 或第 4 小时关门代价都最小。由于第 2 小时更早，所以最优关门时间是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>customers = \"NNNNN\"\n<b>输出：</b>0\n<b>解释：</b>最优关门时间是 0 ，因为自始至终没有顾客到达。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>customers = \"YYYY\"\n<b>输出：</b>4\n<b>解释：</b>最优关门时间是 4 ，因为每一小时均有顾客到达。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= customers.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>customers</code>&nbsp;只包含字符&nbsp;<code>'Y'</code>&nbsp;和&nbsp;<code>'N'</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2484.统计回文子序列数目",
        "hardRate": "HARD",
        "passRate": "47.12%",
        "problemsUrl": "https://leetcode.cn/problems/count-palindromic-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/count-palindromic-subsequences/solution",
        "problemsDesc": "<p>给你数字字符串&nbsp;<code>s</code>&nbsp;，请你返回&nbsp;<code>s</code>&nbsp;中长度为&nbsp;<code>5</code>&nbsp;的 <b>回文子序列</b>&nbsp;数目。由于答案可能很大，请你将答案对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>如果一个字符串从前往后和从后往前读相同，那么它是 <strong>回文字符串</strong>&nbsp;。</li>\n\t<li>子序列是一个字符串中删除若干个字符后，不改变字符顺序，剩余字符构成的字符串。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"103301\"\n<b>输出：</b>2\n<b>解释：</b>\n总共有 6 长度为 5 的子序列：\"10330\" ，\"10331\" ，\"10301\" ，\"10301\" ，\"13301\" ，\"03301\" 。\n它们中有两个（都是 \"10301\"）是回文的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"0000000\"\n<b>输出：</b>21\n<b>解释：</b>所有 21 个长度为 5 的子序列都是 \"00000\" ，都是回文的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>s = \"9999900000\"\n<b>输出：</b>2\n<b>解释：</b>仅有的两个回文子序列是 \"99999\" 和 \"00000\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含数字字符。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2485.找出中枢整数",
        "hardRate": "EASY",
        "passRate": "80.80%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-pivot-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-pivot-integer/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> ，找出满足下述条件的<strong> 中枢整数</strong> <code>x</code> ：</p>\n\n<ul>\n\t<li><code>1</code> 和 <code>x</code> 之间的所有元素之和等于 <code>x</code> 和 <code>n</code> 之间所有元素之和。</li>\n</ul>\n\n<p>返回中枢整数<em> </em><code>x</code> 。如果不存在中枢整数，则返回 <code>-1</code> 。题目保证对于给定的输入，至多存在一个中枢整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 8\n<strong>输出：</strong>6\n<strong>解释：</strong>6 是中枢整数，因为 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>1 是中枢整数，因为 1 = 1 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>-1\n<strong>解释：</strong>可以证明不存在满足题目要求的整数。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2486.追加字符以获得子序列",
        "hardRate": "MEDIUM",
        "passRate": "65.15%",
        "problemsUrl": "https://leetcode.cn/problems/append-characters-to-string-to-make-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/append-characters-to-string-to-make-subsequence/solution",
        "problemsDesc": "<p>给你两个仅由小写英文字母组成的字符串 <code>s</code> 和 <code>t</code> 。</p>\n\n<p>现在需要通过向 <code>s</code> 末尾追加字符的方式使 <code>t</code> 变成 <code>s</code> 的一个 <strong>子序列</strong> ，返回需要追加的最少字符数。</p>\n\n<p>子序列是一个可以由其他字符串删除部分（或不删除）字符但不改变剩下字符顺序得到的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"coaching\", t = \"coding\"\n<strong>输出：</strong>4\n<strong>解释：</strong>向 s 末尾追加字符串 \"ding\" ，s = \"coachingding\" 。\n现在，t 是 s (\"<em><strong>co</strong></em>aching<em><strong>ding</strong></em>\") 的一个子序列。\n可以证明向 s 末尾追加任何 3 个字符都无法使 t 成为 s 的一个子序列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcde\", t = \"a\"\n<strong>输出：</strong>0\n<strong>解释：</strong>t 已经是 s (\"<em><strong>a</strong></em>bcde\") 的一个子序列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"z\", t = \"abcde\"\n<strong>输出：</strong>5\n<strong>解释：</strong>向 s 末尾追加字符串 \"abcde\" ，s = \"zabcde\" 。\n现在，t 是 s (\"z<em><strong>abcde</strong></em>\") 的一个子序列。 \n可以证明向 s 末尾追加任何 4 个字符都无法使 t 成为 s 的一个子序列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 和 <code>t</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2487.从链表中移除节点",
        "hardRate": "MEDIUM",
        "passRate": "68.87%",
        "problemsUrl": "https://leetcode.cn/problems/remove-nodes-from-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-nodes-from-linked-list/solution",
        "problemsDesc": "<p>给你一个链表的头节点 <code>head</code> 。</p>\n\n<p>对于列表中的每个节点 <code>node</code> ，如果其右侧存在一个具有 <strong>严格更大</strong> 值的节点，则移除 <code>node</code> 。</p>\n\n<p>返回修改后链表的头节点<em> </em><code>head</code><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/02/drawio.png\" style=\"width: 631px; height: 51px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [5,2,13,3,8]\n<strong>输出：</strong>[13,8]\n<strong>解释：</strong>需要移除的节点是 5 ，2 和 3 。\n- 节点 13 在节点 5 右侧。\n- 节点 13 在节点 2 右侧。\n- 节点 8 在节点 3 右侧。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,1,1,1]\n<strong>输出：</strong>[1,1,1,1]\n<strong>解释：</strong>每个节点的值都是 1 ，所以没有需要移除的节点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给定列表中的节点数目在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2488.统计中位数为 K 的子数组",
        "hardRate": "HARD",
        "passRate": "50.75%",
        "problemsUrl": "https://leetcode.cn/problems/count-subarrays-with-median-k/",
        "solutionsUrl": "https://leetcode.cn/problems/count-subarrays-with-median-k/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的数组 <code>nums</code> ，该数组由从 <code>1</code> 到 <code>n</code> 的 <strong>不同</strong> 整数组成。另给你一个正整数 <code>k</code> 。</p>\n\n<p>统计并返回 <code>nums</code> 中的 <strong>中位数</strong> 等于 <code>k</code> 的非空子数组的数目。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>数组的中位数是按 <strong>递增</strong> 顺序排列后位于 <strong>中间</strong> 的那个元素，如果数组长度为偶数，则中位数是位于中间靠 <strong>左</strong> 的那个元素。\n\n\t<ul>\n\t\t<li>例如，<code>[2,3,1,4]</code> 的中位数是 <code>2</code> ，<code>[8,4,3,5,1]</code> 的中位数是 <code>4</code> 。</li>\n\t</ul>\n\t</li>\n\t<li>子数组是数组中的一个连续部分。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,1,4,5], k = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>中位数等于 4 的子数组有：[4]、[4,5] 和 [1,4,5] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,1], k = 3\n<strong>输出：</strong>1\n<strong>解释：</strong>[3] 是唯一一个中位数等于 3 的子数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= n</code></li>\n\t<li><code>nums</code> 中的整数互不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2489.固定比率的子字符串数",
        "hardRate": "MEDIUM",
        "passRate": "68.36%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-substrings-with-fixed-ratio/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-substrings-with-fixed-ratio/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2490.回环句",
        "hardRate": "EASY",
        "passRate": "73.66%",
        "problemsUrl": "https://leetcode.cn/problems/circular-sentence/",
        "solutionsUrl": "https://leetcode.cn/problems/circular-sentence/solution",
        "problemsDesc": "<p><strong>句子</strong> 是由单个空格分隔的一组单词，且不含前导或尾随空格。</p>\n\n<ul>\n\t<li>例如，<code>\"Hello World\"</code>、<code>\"HELLO\"</code>、<code>\"hello world hello world\"</code> 都是符合要求的句子。</li>\n</ul>\n\n<p>单词 <strong>仅</strong> 由大写和小写英文字母组成。且大写和小写字母会视作不同字符。</p>\n\n<p>如果句子满足下述全部条件，则认为它是一个 <strong>回环句</strong> ：</p>\n\n<ul>\n\t<li>单词的最后一个字符和下一个单词的第一个字符相等。</li>\n\t<li>最后一个单词的最后一个字符和第一个单词的第一个字符相等。</li>\n</ul>\n\n<p>例如，<code>\"leetcode exercises sound delightful\"</code>、<code>\"eetcode\"</code>、<code>\"leetcode eats soul\"</code> 都是回环句。然而，<code>\"Leetcode is cool\"</code>、<code>\"happy Leetcode\"</code>、<code>\"Leetcode\"</code> 和 <code>\"I like Leetcode\"</code> 都 <strong>不</strong> 是回环句。</p>\n\n<p>给你一个字符串 <code>sentence</code> ，请你判断它是不是一个回环句。如果是，返回 <code>true</code><em> </em>；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"leetcode exercises sound delightful\"\n<strong>输出：</strong>true\n<strong>解释：</strong>句子中的单词是 [\"leetcode\", \"exercises\", \"sound\", \"delightful\"] 。\n- leetcod<strong><em>e</em></strong> 的最后一个字符和 <strong><em>e</em></strong>xercises 的第一个字符相等。\n- exercise<em><strong>s</strong></em> 的最后一个字符和 <em><strong>s</strong></em>ound 的第一个字符相等。\n- <em><strong>s</strong></em>ound 的最后一个字符和 delightfu<em><strong>l</strong></em> 的第一个字符相等。\n- delightfu<em><strong>l</strong></em> 的最后一个字符和 <em><strong>l</strong></em>eetcode 的第一个字符相等。\n这个句子是回环句。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"eetcode\"\n<strong>输出：</strong>true\n<strong>解释：</strong>句子中的单词是 [\"eetcode\"] 。\n- eetcod<em><strong>e</strong></em> 的最后一个字符和 <em><strong>e</strong></em>etcod<em>e</em> 的第一个字符相等。\n这个句子是回环句。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"Leetcode is cool\"\n<strong>输出：</strong>false\n<strong>解释：</strong>句子中的单词是 [\"Leetcode\", \"is\", \"cool\"] 。\n- Leetcod<em><strong>e</strong></em>&nbsp;的最后一个字符和 <em><strong>i</strong></em>s 的第一个字符 <strong>不</strong> 相等。 \n这个句子 <strong>不</strong> 是回环句。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentence.length &lt;= 500</code></li>\n\t<li><code>sentence</code> 仅由大小写英文字母和空格组成</li>\n\t<li><code>sentence</code> 中的单词由单个空格进行分隔</li>\n\t<li>不含任何前导或尾随空格</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2491.划分技能点相等的团队",
        "hardRate": "MEDIUM",
        "passRate": "55.30%",
        "problemsUrl": "https://leetcode.cn/problems/divide-players-into-teams-of-equal-skill/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-players-into-teams-of-equal-skill/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>skill</code> ，数组长度为 <strong>偶数</strong> <code>n</code> ，其中 <code>skill[i]</code> 表示第 <code>i</code> 个玩家的技能点。将所有玩家分成 <code>n / 2</code> 个 <code>2</code> 人团队，使每一个团队的技能点之和 <strong>相等</strong> 。</p>\n\n<p>团队的 <strong>化学反应</strong> 等于团队中玩家的技能点 <strong>乘积</strong> 。</p>\n\n<p>返回所有团队的 <strong>化学反应</strong> 之和，如果无法使每个团队的技能点之和相等，则返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>skill = [3,2,5,1,3,4]\n<strong>输出：</strong>22\n<strong>解释：</strong>\n将玩家分成 3 个团队 (1, 5), (2, 4), (3, 3) ，每个团队的技能点之和都是 6 。\n所有团队的化学反应之和是 1 * 5 + 2 * 4 + 3 * 3 = 5 + 8 + 9 = 22 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>skill = [3,4]\n<strong>输出：</strong>12\n<strong>解释：</strong>\n两个玩家形成一个团队，技能点之和是 7 。\n团队的化学反应是 3 * 4 = 12 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>skill = [1,1,2,3]\n<strong>输出：</strong>-1\n<strong>解释：</strong>\n无法将玩家分成每个团队技能点都相等的若干个 2 人团队。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= skill.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>skill.length</code> 是偶数</li>\n\t<li><code>1 &lt;= skill[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2492.两个城市间路径的最小分数",
        "hardRate": "MEDIUM",
        "passRate": "41.39%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-score-of-a-path-between-two-cities/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-score-of-a-path-between-two-cities/solution",
        "problemsDesc": "<p>给你一个正整数&nbsp;<code>n</code>&nbsp;，表示总共有&nbsp;<code>n</code>&nbsp;个城市，城市从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;编号。给你一个二维数组&nbsp;<code>roads</code>&nbsp;，其中&nbsp;<code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>, distance<sub>i</sub>]</code>&nbsp;表示城市&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条 <strong>双向</strong>&nbsp;道路，道路距离为&nbsp;<code>distance<sub>i</sub></code>&nbsp;。城市构成的图不一定是连通的。</p>\n\n<p>两个城市之间一条路径的 <strong>分数</strong>&nbsp;定义为这条路径中道路的 <strong>最小</strong>&nbsp;距离。</p>\n\n<p><span class=\"text-only\" data-eleid=\"20\" style=\"white-space: pre;\">城市</span><span class=\"text-only text-font-italic\" data-eleid=\"21\" style=\"white-space: pre;\"> </span><code><span class=\"text-only\" data-eleid=\"22\" style=\"white-space: pre;\">1</span></code><span class=\"text-only text-font-italic\" data-eleid=\"23\" style=\"white-space: pre;\"> </span><span class=\"text-only\" data-eleid=\"24\" style=\"white-space: pre;\">和城市</span><span class=\"text-only text-font-italic\" data-eleid=\"25\" style=\"white-space: pre;\"> </span><span class=\"text-only\" data-eleid=\"26\" style=\"white-space: pre;\"><code>n</code> 之间的所有路径的 </span><strong><span class=\"text-only\" data-eleid=\"27\" style=\"white-space: pre;\">最小</span></strong><span class=\"text-only\" data-eleid=\"28\" style=\"white-space: pre;\"> 分数。</span></p>\n\n<p><b>注意：</b></p>\n\n<ul>\n\t<li>一条路径指的是两个城市之间的道路序列。</li>\n\t<li>一条路径可以 <strong>多次</strong> 包含同一条道路，你也可以沿着路径多次到达城市 <code>1</code>&nbsp;和城市 <code>n</code>&nbsp;。</li>\n\t<li>测试数据保证城市 <code>1</code>&nbsp;和城市<code>n</code>&nbsp;之间 <strong>至少</strong>&nbsp;有一条路径。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/12/graph11.png\" style=\"width: 190px; height: 231px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]\n<b>输出：</b>5\n<b>解释：</b>城市 1 到城市 4 的路径中，分数最小的一条为：1 -&gt; 2 -&gt; 4 。这条路径的分数是 min(9,5) = 5 。\n不存在分数更小的路径。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/12/graph22.png\" style=\"width: 190px; height: 231px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]]\n<b>输出：</b>2\n<b>解释：</b>城市 1 到城市 4 分数最小的路径是：1 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4 。这条路径的分数是 min(2,2,4,7) = 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= roads.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>roads[i].length == 3</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>1 &lt;= distance<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li>不会有重复的边。</li>\n\t<li>城市 <code>1</code>&nbsp;和城市 <code>n</code>&nbsp;之间至少有一条路径。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2493.将节点分成尽可能多的组",
        "hardRate": "HARD",
        "passRate": "43.74%",
        "problemsUrl": "https://leetcode.cn/problems/divide-nodes-into-the-maximum-number-of-groups/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-nodes-into-the-maximum-number-of-groups/solution",
        "problemsDesc": "<p>给你一个正整数&nbsp;<code>n</code>&nbsp;，表示一个 <strong>无向</strong>&nbsp;图中的节点数目，节点编号从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;。</p>\n\n<p>同时给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i, </sub>b<sub>i</sub>]</code>&nbsp;表示节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code><sub>&nbsp;</sub>之间有一条&nbsp;<strong>双向</strong>&nbsp;边。注意给定的图可能是不连通的。</p>\n\n<p>请你将图划分为&nbsp;<code>m</code>&nbsp;个组（编号从 <strong>1</strong>&nbsp;开始），满足以下要求：</p>\n\n<ul>\n\t<li>图中每个节点都只属于一个组。</li>\n\t<li>图中每条边连接的两个点&nbsp;<code>[a<sub>i, </sub>b<sub>i</sub>]</code>&nbsp;，如果&nbsp;<code>a<sub>i</sub></code>&nbsp;属于编号为&nbsp;<code>x</code>&nbsp;的组，<code>b<sub>i</sub></code>&nbsp;属于编号为&nbsp;<code>y</code>&nbsp;的组，那么&nbsp;<code>|y - x| = 1</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回最多可以将节点分为多少个组（也就是最大的<em>&nbsp;</em><code>m</code>&nbsp;）。如果没办法在给定条件下分组，请你返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/13/example1.png\" style=\"width: 352px; height: 201px;\"></p>\n\n<pre><b>输入：</b>n = 6, edges = [[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]]\n<b>输出：</b>4\n<b>解释：</b>如上图所示，\n- 节点 5 在第一个组。\n- 节点 1 在第二个组。\n- 节点 2 和节点 4 在第三个组。\n- 节点 3 和节点 6 在第四个组。\n所有边都满足题目要求。\n如果我们创建第五个组，将第三个组或者第四个组中任何一个节点放到第五个组，至少有一条边连接的两个节点所属的组编号不符合题目要求。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 3, edges = [[1,2],[2,3],[3,1]]\n<b>输出：</b>-1\n<b>解释：</b>如果我们将节点 1 放入第一个组，节点 2 放入第二个组，节点 3 放入第三个组，前两条边满足题目要求，但第三条边不满足题目要求。\n没有任何符合题目要求的分组方式。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>两个点之间至多只有一条边。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2494.合并在同一个大厅重叠的活动",
        "hardRate": "HARD",
        "passRate": "39.29%",
        "problemsUrl": "https://leetcode.cn/problems/merge-overlapping-events-in-the-same-hall/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-overlapping-events-in-the-same-hall/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2495.乘积为偶数的子数组数",
        "hardRate": "MEDIUM",
        "passRate": "68.71%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-subarrays-having-even-product/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-subarrays-having-even-product/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2496.数组中字符串的最大值",
        "hardRate": "EASY",
        "passRate": "79.49%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-value-of-a-string-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-value-of-a-string-in-an-array/solution",
        "problemsDesc": "<p>一个由字母和数字组成的字符串的 <strong>值</strong>&nbsp;定义如下：</p>\n\n<ul>\n\t<li>如果字符串 <strong>只</strong> 包含数字，那么值为该字符串在 <code>10</code>&nbsp;进制下的所表示的数字。</li>\n\t<li>否则，值为字符串的 <strong>长度&nbsp;</strong>。</li>\n</ul>\n\n<p>给你一个字符串数组&nbsp;<code>strs</code>&nbsp;，每个字符串都只由字母和数字组成，请你返回 <code>strs</code>&nbsp;中字符串的 <strong>最大值</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"alic3\",\"bob\",\"3\",\"4\",\"00000\"]\n<b>输出：</b>5\n<b>解释：</b>\n- \"alic3\" 包含字母和数字，所以值为长度 5 。\n- \"bob\" 只包含字母，所以值为长度 3 。\n- \"3\" 只包含数字，所以值为 3 。\n- \"4\" 只包含数字，所以值为 4 。\n- \"00000\" 只包含数字，所以值为 0 。\n所以最大的值为 5 ，是字符串 \"alic3\" 的值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>strs = [\"1\",\"01\",\"001\",\"0001\"]\n<b>输出：</b>1\n<b>解释：</b>\n数组中所有字符串的值都是 1 ，所以我们返回 1 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= strs[i].length &lt;= 9</code></li>\n\t<li><code>strs[i]</code>&nbsp;只包含小写英文字母和数字。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2497.图中最大星和",
        "hardRate": "MEDIUM",
        "passRate": "38.24%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-star-sum-of-a-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-star-sum-of-a-graph/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>n</code>&nbsp;个点的无向图，节点从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;编号。给你一个长度为 <code>n</code>&nbsp;下标从&nbsp;<strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>vals</code>&nbsp;，其中&nbsp;<code>vals[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个节点的值。</p>\n\n<p>同时给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条双向边。</p>\n\n<p><strong>星图</strong>&nbsp;是给定图中的一个子图，它包含一个中心节点和&nbsp;<code>0</code>&nbsp;个或更多个邻居。换言之，星图是给定图中一个边的子集，且这些边都有一个公共节点。</p>\n\n<p>下图分别展示了有 <code>3</code>&nbsp;个和 <code>4</code>&nbsp;个邻居的星图，蓝色节点为中心节点。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/07/max-star-sum-descdrawio.png\" style=\"width: 400px; height: 179px;\"></p>\n\n<p><strong>星和</strong> 定义为星图中所有节点值的和。</p>\n\n<p>给你一个整数&nbsp;<code>k</code>&nbsp;，请你返回 <strong>至多</strong>&nbsp;包含 <code>k</code>&nbsp;条边的星图中的 <strong>最大星和</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/07/max-star-sum-example1drawio.png\" style=\"width: 300px; height: 291px;\"></p>\n\n<pre><b>输入：</b>vals = [1,2,3,4,10,-10,-20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2\n<b>输出：</b>16\n<b>解释：</b>上图展示了输入示例。\n最大星和对应的星图在上图中用蓝色标出。中心节点是 3 ，星图中还包含邻居 1 和 4 。\n无法得到一个和大于 16 且边数不超过 2 的星图。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>vals = [-5], edges = [], k = 0\n<b>输出：</b>-5\n<b>解释：</b>只有一个星图，就是节点 0 自己。\n所以我们返回 -5 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == vals.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= vals[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= edges.length &lt;= min(n * (n - 1) / 2</code><code>, 10<sup>5</sup>)</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>0 &lt;= k &lt;= n - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2498.青蛙过河 II",
        "hardRate": "MEDIUM",
        "passRate": "64.50%",
        "problemsUrl": "https://leetcode.cn/problems/frog-jump-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/frog-jump-ii/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>stones</code>&nbsp;，数组中的元素&nbsp;<strong>严格递增</strong>&nbsp;，表示一条河中石头的位置。</p>\n\n<p>一只青蛙一开始在第一块石头上，它想到达最后一块石头，然后回到第一块石头。同时每块石头 <strong>至多</strong> 到达 <strong>一次。</strong></p>\n\n<p>一次跳跃的 <strong>长度</strong>&nbsp;是青蛙跳跃前和跳跃后所在两块石头之间的距离。</p>\n\n<ul>\n\t<li>更正式的，如果青蛙从&nbsp;<code>stones[i]</code>&nbsp;跳到&nbsp;<code>stones[j]</code>&nbsp;，跳跃的长度为&nbsp;<code>|stones[i] - stones[j]|</code>&nbsp;。</li>\n</ul>\n\n<p>一条路径的 <b>代价</b>&nbsp;是这条路径里的&nbsp;<b>最大跳跃长度</b>&nbsp;。</p>\n\n<p>请你返回这只青蛙的 <strong>最小代价</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/14/example-1.png\" style=\"width: 600px; height: 219px;\" /></p>\n\n<pre>\n<b>输入：</b>stones = [0,2,5,6,7]\n<b>输出：</b>5\n<b>解释：</b>上图展示了一条最优路径。\n这条路径的代价是 5 ，是这条路径中的最大跳跃长度。\n无法得到一条代价小于 5 的路径，我们返回 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/14/example-2.png\" style=\"width: 500px; height: 171px;\" /></p>\n\n<pre>\n<b>输入：</b>stones = [0,3,9]\n<b>输出：</b>9\n<b>解释：</b>\n青蛙可以直接跳到最后一块石头，然后跳回第一块石头。\n在这条路径中，每次跳跃长度都是 9 。所以路径代价是 max(9, 9) = 9 。\n这是可行路径中的最小代价。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= stones.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= stones[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>stones[0] == 0</code></li>\n\t<li><code>stones</code>&nbsp;中的元素严格递增。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2499.让数组不相等的最小总代价",
        "hardRate": "HARD",
        "passRate": "42.04%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-total-cost-to-make-arrays-unequal/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-total-cost-to-make-arrays-unequal/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>&nbsp;，两者长度都为&nbsp;<code>n</code>&nbsp;。</p>\n\n<p>每次操作中，你可以选择交换 <code>nums1</code>&nbsp;中任意两个下标处的值。操作的 <strong>开销</strong>&nbsp;为两个下标的 <strong>和</strong>&nbsp;。</p>\n\n<p>你的目标是对于所有的 <code>0 &lt;= i &lt;= n - 1</code>&nbsp;，都满足&nbsp;<code>nums1[i] != nums2[i]</code>&nbsp;，你可以进行 <strong>任意次</strong>&nbsp;操作，请你返回达到这个目标的 <strong>最小</strong>&nbsp;总代价。</p>\n\n<p>请你返回让<em>&nbsp;</em><code>nums1</code> 和&nbsp;<code>nums2</code><em>&nbsp;</em>满足上述条件的 <strong>最小总代价</strong> ，如果无法达成目标，返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]\n<b>输出：</b>10\n<b>解释：</b>\n实现目标的其中一种方法为：\n- 交换下标为 0 和 3 的两个值，代价为 0 + 3 = 3 。现在 nums1 = [4,2,3,1,5] 。\n- 交换下标为 1 和 2 的两个值，代价为 1 + 2 = 3 。现在 nums1 = [4,3,2,1,5] 。\n- 交换下标为 0 和 4 的两个值，代价为 0 + 4 = 4 。现在 nums1 = [5,3,2,1,4] 。\n最后，对于每个下标 i ，都有 nums1[i] != nums2[i] 。总代价为 10 。\n还有别的交换值的方法，但是无法得到代价和小于 10 的方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]\n<b>输出：</b>10\n<b>解释：</b>\n实现目标的一种方法为：\n- 交换下标为 2 和 3 的两个值，代价为 2 + 3 = 5 。现在 nums1 = [2,2,1,2,3] 。\n- 交换下标为 1 和 4 的两个值，代价为 1 + 4 = 5 。现在 nums1 = [2,3,1,2,2] 。\n总代价为 10 ，是所有方案中的最小代价。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums1 = [1,2,2], nums2 = [1,2,2]\n<b>输出：</b>-1\n<b>解释：</b>\n不管怎么操作，都无法满足题目要求。\n所以返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length == nums2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2500.删除每行中的最大值",
        "hardRate": "EASY",
        "passRate": "82.70%",
        "problemsUrl": "https://leetcode.cn/problems/delete-greatest-value-in-each-row/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-greatest-value-in-each-row/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 大小的矩阵 <code>grid</code> ，由若干正整数组成。</p>\n\n<p>执行下述操作，直到 <code>grid</code> 变为空矩阵：</p>\n\n<ul>\n\t<li>从每一行删除值最大的元素。如果存在多个这样的值，删除其中任何一个。</li>\n\t<li>将删除元素中的最大值与答案相加。</li>\n</ul>\n\n<p><strong>注意</strong> 每执行一次操作，矩阵中列的数据就会减 1 。</p>\n\n<p>返回执行上述操作后的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/19/q1ex1.jpg\" style=\"width: 600px; height: 135px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,2,4],[3,3,1]]\n<strong>输出：</strong>8\n<strong>解释：</strong>上图展示在每一步中需要移除的值。\n- 在第一步操作中，从第一行删除 4 ，从第二行删除 3（注意，有两个单元格中的值为 3 ，我们可以删除任一）。在答案上加 4 。\n- 在第二步操作中，从第一行删除 2 ，从第二行删除 3 。在答案上加 3 。\n- 在第三步操作中，从第一行删除 1 ，从第二行删除 1 。在答案上加 1 。\n最终，答案 = 4 + 3 + 1 = 8 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/19/q1ex2.jpg\" style=\"width: 83px; height: 83px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[10]]\n<strong>输出：</strong>10\n<strong>解释：</strong>上图展示在每一步中需要移除的值。\n- 在第一步操作中，从第一行删除 10 。在答案上加 10 。\n最终，答案 = 10 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2501.数组中最长的方波",
        "hardRate": "MEDIUM",
        "passRate": "41.28%",
        "problemsUrl": "https://leetcode.cn/problems/longest-square-streak-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-square-streak-in-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。如果 <code>nums</code> 的子序列满足下述条件，则认为该子序列是一个 <strong>方波</strong> ：</p>\n\n<ul>\n\t<li>子序列的长度至少为 <code>2</code> ，并且</li>\n\t<li>将子序列从小到大排序 <strong>之后</strong> ，除第一个元素外，每个元素都是前一个元素的 <strong>平方</strong> 。</li>\n</ul>\n\n<p>返回<em> </em><code>nums</code><em> </em>中 <strong>最长方波</strong> 的长度，如果不存在 <strong>方波</strong><em> </em>则返回<em> </em><code>-1</code> 。</p>\n\n<p><strong>子序列</strong> 也是一个数组，可以由另一个数组删除一些或不删除元素且不改变剩余元素的顺序得到。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1 ：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,3,6,16,8,2]\n<strong>输出：</strong>3\n<strong>解释：</strong>选出子序列 [4,16,2] 。排序后，得到 [2,4,16] 。\n- 4 = 2 * 2.\n- 16 = 4 * 4.\n因此，[4,16,2] 是一个方波.\n可以证明长度为 4 的子序列都不是方波。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,3,5,6,7]\n<strong>输出：</strong>-1\n<strong>解释：</strong>nums 不存在方波，所以返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2502.设计内存分配器",
        "hardRate": "MEDIUM",
        "passRate": "52.17%",
        "problemsUrl": "https://leetcode.cn/problems/design-memory-allocator/",
        "solutionsUrl": "https://leetcode.cn/problems/design-memory-allocator/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，表示下标从 <strong>0</strong> 开始的内存数组的大小。所有内存单元开始都是空闲的。</p>\n\n<p>请你设计一个具备以下功能的内存分配器：</p>\n\n<ol>\n\t<li><strong>分配 </strong>一块大小为 <code>size</code> 的连续空闲内存单元并赋 id <code>mID</code> 。</li>\n\t<li><strong>释放</strong> 给定 id <code>mID</code> 对应的所有内存单元。</li>\n</ol>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>多个块可以被分配到同一个 <code>mID</code> 。</li>\n\t<li>你必须释放 <code>mID</code> 对应的所有内存单元，即便这些内存单元被分配在不同的块中。</li>\n</ul>\n\n<p>实现 <code>Allocator</code> 类：</p>\n\n<ul>\n\t<li><code>Allocator(int n)</code> 使用一个大小为 <code>n</code> 的内存数组初始化 <code>Allocator</code> 对象。</li>\n\t<li><code>int allocate(int size, int mID)</code> 找出大小为 <code>size</code> 个连续空闲内存单元且位于&nbsp; <strong>最左侧</strong> 的块，分配并赋 id <code>mID</code> 。返回块的第一个下标。如果不存在这样的块，返回 <code>-1</code> 。</li>\n\t<li><code>int free(int mID)</code> 释放 id <code>mID</code> 对应的所有内存单元。返回释放的内存单元数目。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入</strong>\n[\"Allocator\", \"allocate\", \"allocate\", \"allocate\", \"free\", \"allocate\", \"allocate\", \"allocate\", \"free\", \"allocate\", \"free\"]\n[[10], [1, 1], [1, 2], [1, 3], [2], [3, 4], [1, 1], [1, 1], [1], [10, 2], [7]]\n<strong>输出</strong>\n[null, 0, 1, 2, 1, 3, 1, 6, 3, -1, 0]\n\n<strong>解释</strong>\nAllocator loc = new Allocator(10); // 初始化一个大小为 10 的内存数组，所有内存单元都是空闲的。\nloc.allocate(1, 1); // 最左侧的块的第一个下标是 0 。内存数组变为 [<strong>1</strong>, , , , , , , , , ]。返回 0 。\nloc.allocate(1, 2); // 最左侧的块的第一个下标是 1 。内存数组变为 [1,<strong>2</strong>, , , , , , , , ]。返回 1 。\nloc.allocate(1, 3); // 最左侧的块的第一个下标是 2 。内存数组变为 [1,2,<strong>3</strong>, , , , , , , ]。返回 2 。\nloc.free(2); // 释放 mID 为 2 的所有内存单元。内存数组变为 [1, ,<strong>3</strong>, , , , , , , ] 。返回 1 ，因为只有 1 个 mID 为 2 的内存单元。\nloc.allocate(3, 4); // 最左侧的块的第一个下标是 3 。内存数组变为 [1, ,3,<strong>4</strong>,<strong>4</strong>,<strong>4</strong>, , , , ]。返回 3 。\nloc.allocate(1, 1); // 最左侧的块的第一个下标是 1 。内存数组变为 [1,<strong>1</strong>,3,4,4,4, , , , ]。返回 1 。\nloc.allocate(1, 1); // 最左侧的块的第一个下标是 6 。内存数组变为 [1,1,3,4,4,4,<strong>1</strong>, , , ]。返回 6 。\nloc.free(1); // 释放 mID 为 1 的所有内存单元。内存数组变为 [ , ,3,4,4,4,<strong> </strong>, , , ] 。返回 3 ，因为有 3 个 mID 为 1 的内存单元。\nloc.allocate(10, 2); // 无法找出长度为 10 个连续空闲内存单元的空闲块，所有返回 -1 。\nloc.free(7); // 释放 mID 为 7 的所有内存单元。内存数组保持原状，因为不存在 mID 为 7 的内存单元。返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n, size, mID &lt;= 1000</code></li>\n\t<li>最多调用 <code>allocate</code> 和 <code>free</code> 方法 <code>1000</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2503.矩阵查询可获得的最大分数",
        "hardRate": "HARD",
        "passRate": "43.36%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-points-from-grid-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-points-from-grid-queries/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的整数矩阵 <code>grid</code> 和一个大小为 <code>k</code> 的数组 <code>queries</code> 。</p>\n\n<p>找出一个大小为 <code>k</code> 的数组 <code>answer</code> ，且满足对于每个整数 <code>queries[i]</code> ，你从矩阵 <strong>左上角</strong> 单元格开始，重复以下过程：</p>\n\n<ul>\n\t<li>如果 <code>queries[i]</code> <strong>严格</strong> 大于你当前所处位置单元格，如果该单元格是第一次访问，则获得 1 分，并且你可以移动到所有 <code>4</code> 个方向（上、下、左、右）上任一 <strong>相邻</strong> 单元格。</li>\n\t<li>否则，你不能获得任何分，并且结束这一过程。</li>\n</ul>\n\n<p>在过程结束后，<code>answer[i]</code> 是你可以获得的最大分数。注意，对于每个查询，你可以访问同一个单元格 <strong>多次</strong> 。</p>\n\n<p>返回结果数组 <code>answer</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/19/yetgriddrawio.png\" style=\"width: 571px; height: 151px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]\n<strong>输出：</strong>[5,8,1]\n<strong>解释：</strong>上图展示了每个查询中访问并获得分数的单元格。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/20/yetgriddrawio-2.png\" />\n<pre>\n<strong>输入：</strong>grid = [[5,2,1],[1,1,2]], queries = [3]\n<strong>输出：</strong>[0]\n<strong>解释：</strong>无法获得分数，因为左上角单元格的值大于等于 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>k == queries.length</code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= grid[i][j], queries[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2504.把名字和职业联系起来",
        "hardRate": "EASY",
        "passRate": "76.18%",
        "problemsUrl": "https://leetcode.cn/problems/concatenate-the-name-and-the-profession/",
        "solutionsUrl": "https://leetcode.cn/problems/concatenate-the-name-and-the-profession/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2505.所有子序列和的按位或",
        "hardRate": "MEDIUM",
        "passRate": "59.09%",
        "problemsUrl": "https://leetcode.cn/problems/bitwise-or-of-all-subsequence-sums/",
        "solutionsUrl": "https://leetcode.cn/problems/bitwise-or-of-all-subsequence-sums/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2506.统计相似字符串对的数目",
        "hardRate": "EASY",
        "passRate": "78.29%",
        "problemsUrl": "https://leetcode.cn/problems/count-pairs-of-similar-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/count-pairs-of-similar-strings/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串数组 <code>words</code> 。</p>\n\n<p>如果两个字符串由相同的字符组成，则认为这两个字符串 <strong>相似</strong> 。</p>\n\n<ul>\n\t<li>例如，<code>\"abca\"</code> 和 <code>\"cba\"</code> 相似，因为它们都由字符 <code>'a'</code>、<code>'b'</code>、<code>'c'</code> 组成。</li>\n\t<li>然而，<code>\"abacba\"</code> 和 <code>\"bcfd\"</code> 不相似，因为它们不是相同字符组成的。</li>\n</ul>\n\n<p>请你找出满足字符串&nbsp;<code>words[i]</code><em> </em>和<em> </em><code>words[j]</code> 相似的下标对<em> </em><code>(i, j)</code><em> </em>，并返回下标对的数目，其中 <code>0 &lt;= i &lt; j &lt;= word.length - 1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"aba\",\"aabb\",\"abcd\",\"bac\",\"aabc\"]\n<strong>输出：</strong>2\n<strong>解释：</strong>共有 2 对满足条件：\n- i = 0 且 j = 1 ：words[0] 和 words[1] 只由字符 'a' 和 'b' 组成。 \n- i = 3 且 j = 4 ：words[3] 和 words[4] 只由字符 'a'、'b' 和 'c' 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"aabb\",\"ab\",\"ba\"]\n<strong>输出：</strong>3\n<strong>解释：</strong>共有 3 对满足条件：\n- i = 0 且 j = 1 ：words[0] 和 words[1] 只由字符 'a' 和 'b' 组成。 \n- i = 0 且 j = 2 ：words[0] 和 words[2] 只由字符 'a' 和 'b' 组成。 \n- i = 1 且 j = 2 ：words[1] 和 words[2] 只由字符 'a' 和 'b' 组成。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"nba\",\"cba\",\"dba\"]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在满足条件的下标对，返回 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><code>words[i]</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2507.使用质因数之和替换后可以取到的最小值",
        "hardRate": "MEDIUM",
        "passRate": "49.95%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-value-after-replacing-with-sum-of-prime-factors/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-value-after-replacing-with-sum-of-prime-factors/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> 。</p>\n\n<p>请你将 <code>n</code> 的值替换为 <code>n</code> 的 <strong>质因数</strong> 之和，重复这一过程。</p>\n\n<ul>\n\t<li>注意，如果 <code>n</code> 能够被某个质因数多次整除，则在求和时，应当包含这个质因数同样次数。</li>\n</ul>\n\n<p>返回<em> </em><code>n</code><em> </em>可以取到的最小值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 15\n<strong>输出：</strong>5\n<strong>解释：</strong>最开始，n = 15 。\n15 = 3 * 5 ，所以 n 替换为 3 + 5 = 8 。\n8 = 2 * 2 * 2 ，所以 n 替换为 2 + 2 + 2 = 6 。\n6 = 2 * 3 ，所以 n 替换为 2 + 3 = 5 。\n5 是 n 可以取到的最小值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>最开始，n = 3 。\n3 是 n 可以取到的最小值。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2508.添加边使所有节点度数都为偶数",
        "hardRate": "HARD",
        "passRate": "29.39%",
        "problemsUrl": "https://leetcode.cn/problems/add-edges-to-make-degrees-of-all-nodes-even/",
        "solutionsUrl": "https://leetcode.cn/problems/add-edges-to-make-degrees-of-all-nodes-even/solution",
        "problemsDesc": "<p>给你一个有 <code>n</code>&nbsp;个节点的 <strong>无向</strong>&nbsp;图，节点编号为&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;。再给你整数&nbsp;<code>n</code>&nbsp;和一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条边。图不一定连通。</p>\n\n<p>你可以给图中添加 <strong>至多</strong>&nbsp;两条额外的边（也可以一条边都不添加），使得图中没有重边也没有自环。</p>\n\n<p>如果添加额外的边后，可以使得图中所有点的度数都是偶数，返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>点的度数是连接一个点的边的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/26/agraphdrawio.png\" style=\"width: 500px; height: 190px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]\n<b>输出：</b>true\n<b>解释：</b>上图展示了添加一条边的合法方案。\n最终图中每个节点都连接偶数条边。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/26/aagraphdrawio.png\" style=\"width: 400px; height: 120px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 4, edges = [[1,2],[3,4]]\n<b>输出：</b>true\n<b>解释：</b>上图展示了添加两条边的合法方案。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/26/aaagraphdrawio.png\" style=\"width: 150px; height: 158px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 4, edges = [[1,2],[1,3],[1,4]]\n<b>输出：</b>false\n<b>解释：</b>无法添加至多 2 条边得到一个符合要求的图。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>图中不会有重边</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2509.查询树中环的长度",
        "hardRate": "HARD",
        "passRate": "65.23%",
        "problemsUrl": "https://leetcode.cn/problems/cycle-length-queries-in-a-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/cycle-length-queries-in-a-tree/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;，表示你有一棵含有&nbsp;<code>2<sup>n</sup> - 1</code>&nbsp;个节点的 <strong>完全二叉树</strong>&nbsp;。根节点的编号是&nbsp;<code>1</code>&nbsp;，树中编号在<code>[1, 2<sup>n - 1</sup> - 1]</code>&nbsp;之间，编号为&nbsp;<code>val</code>&nbsp;的节点都有两个子节点，满足：</p>\n\n<ul>\n\t<li>左子节点的编号为&nbsp;<code>2 * val</code></li>\n\t<li>右子节点的编号为&nbsp;<code>2 * val + 1</code></li>\n</ul>\n\n<p>给你一个长度为 <code>m</code>&nbsp;的查询数组 <code>queries</code>&nbsp;，它是一个二维整数数组，其中&nbsp;<code>queries[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;。对于每个查询，求出以下问题的解：</p>\n\n<ol>\n\t<li>在节点编号为&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间添加一条边。</li>\n\t<li>求出图中环的长度。</li>\n\t<li>删除节点编号为&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间新添加的边。</li>\n</ol>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><strong>环</strong> 是开始和结束于同一节点的一条路径，路径中每条边都只会被访问一次。</li>\n\t<li>环的长度是环中边的数目。</li>\n\t<li>在树中添加额外的边后，两个点之间可能会有多条边。</li>\n</ul>\n\n<p>请你返回一个长度为 <code>m</code>&nbsp;的数组<em>&nbsp;</em><code>answer</code>&nbsp;，其中&nbsp;<code>answer[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个查询的结果<i>。</i></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/25/bexample1.png\" style=\"width: 647px; height: 128px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 3, queries = [[5,3],[4,7],[2,3]]\n<b>输出：</b>[4,5,3]\n<b>解释：</b>上图是一棵有 2<sup>3</sup> - 1 个节点的树。红色节点表示添加额外边后形成环的节点。\n- 在节点 3 和节点 5 之间添加边后，环为 [5,2,1,3] ，所以第一个查询的结果是 4 。删掉添加的边后处理下一个查询。\n- 在节点 4 和节点 7 之间添加边后，环为 [4,2,1,3,7] ，所以第二个查询的结果是 5 。删掉添加的边后处理下一个查询。\n- 在节点 2 和节点 3 之间添加边后，环为 [2,1,3] ，所以第三个查询的结果是 3 。删掉添加的边。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/25/aexample2.png\" style=\"width: 146px; height: 71px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 2, queries = [[1,2]]\n<b>输出：</b>[2]\n<b>解释：</b>上图是一棵有 2<sup>2</sup> - 1 个节点的树。红色节点表示添加额外边后形成环的节点。\n- 在节点 1 和节点 2 之间添加边后，环为 [2,1] ，所以第一个查询的结果是 2 。删掉添加的边。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 30</code></li>\n\t<li><code>m == queries.length</code></li>\n\t<li><code>1 &lt;= m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= 2<sup>n</sup> - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2510.检查是否有路径经过相同数量的 0 和 1",
        "hardRate": "MEDIUM",
        "passRate": "68.65%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-there-is-a-path-with-equal-number-of-0s-and-1s/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-there-is-a-path-with-equal-number-of-0s-and-1s/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2511.最多可以摧毁的敌人城堡数目",
        "hardRate": "EASY",
        "passRate": "49.63%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-enemy-forts-that-can-be-captured/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-enemy-forts-that-can-be-captured/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;，下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>forts</code>&nbsp;，表示一些城堡。<code>forts[i]</code> 可以是&nbsp;<code>-1</code>&nbsp;，<code>0</code>&nbsp;或者&nbsp;<code>1</code>&nbsp;，其中：</p>\n\n<ul>\n\t<li><code>-1</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个位置 <strong>没有</strong>&nbsp;城堡。</li>\n\t<li><code>0</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个位置有一个 <strong>敌人</strong>&nbsp;的城堡。</li>\n\t<li><code>1</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个位置有一个你控制的城堡。</li>\n</ul>\n\n<p>现在，你需要决定，将你的军队从某个你控制的城堡位置&nbsp;<code>i</code>&nbsp;移动到一个空的位置&nbsp;<code>j</code>&nbsp;，满足：</p>\n\n<ul>\n\t<li><code>0 &lt;= i, j &lt;= n - 1</code></li>\n\t<li>军队经过的位置 <strong>只有</strong>&nbsp;敌人的城堡。正式的，对于所有&nbsp;<code>min(i,j) &lt; k &lt; max(i,j)</code>&nbsp;的&nbsp;<code>k</code>&nbsp;，都满足&nbsp;<code>forts[k] == 0</code>&nbsp;。</li>\n</ul>\n\n<p>当军队移动时，所有途中经过的敌人城堡都会被 <strong>摧毁</strong> 。</p>\n\n<p>请你返回 <strong>最多</strong>&nbsp;可以摧毁的敌人城堡数目。如果 <strong>无法</strong>&nbsp;移动你的军队，或者没有你控制的城堡，请返回 <code>0</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>forts = [1,0,0,-1,0,0,0,0,1]\n<b>输出：</b>4\n<strong>解释：</strong>\n- 将军队从位置 0 移动到位置 3 ，摧毁 2 个敌人城堡，位置分别在 1 和 2 。\n- 将军队从位置 8 移动到位置 3 ，摧毁 4 个敌人城堡。\n4 是最多可以摧毁的敌人城堡数目，所以我们返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>forts = [0,0,1,-1]\n<b>输出：</b>0\n<b>解释：</b>由于无法摧毁敌人的城堡，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= forts.length &lt;= 1000</code></li>\n\t<li><code>-1 &lt;= forts[i] &lt;= 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2512.奖励最顶尖的 K 名学生",
        "hardRate": "MEDIUM",
        "passRate": "46.13%",
        "problemsUrl": "https://leetcode.cn/problems/reward-top-k-students/",
        "solutionsUrl": "https://leetcode.cn/problems/reward-top-k-students/solution",
        "problemsDesc": "<p>给你两个字符串数组&nbsp;<code>positive_feedback</code> 和&nbsp;<code>negative_feedback</code>&nbsp;，分别包含表示正面的和负面的词汇。<strong>不会</strong>&nbsp;有单词同时是正面的和负面的。</p>\n\n<p>一开始，每位学生分数为&nbsp;<code>0</code>&nbsp;。每个正面的单词会给学生的分数 <strong>加&nbsp;</strong><code>3</code>&nbsp;分，每个负面的词会给学生的分数 <strong>减&nbsp;</strong>&nbsp;<code>1</code>&nbsp;分。</p>\n\n<p>给你&nbsp;<code>n</code>&nbsp;个学生的评语，用一个下标从 <strong>0</strong>&nbsp;开始的字符串数组&nbsp;<code>report</code>&nbsp;和一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>student_id</code>&nbsp;表示，其中&nbsp;<code>student_id[i]</code>&nbsp;表示这名学生的 ID ，这名学生的评语是&nbsp;<code>report[i]</code>&nbsp;。每名学生的 ID <strong>互不相同</strong>。</p>\n\n<p>给你一个整数&nbsp;<code>k</code>&nbsp;，请你返回按照得分&nbsp;<strong>从高到低</strong>&nbsp;最顶尖的<em>&nbsp;</em><code>k</code>&nbsp;名学生。如果有多名学生分数相同，ID 越小排名越前。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>positive_feedback = [\"smart\",\"brilliant\",\"studious\"], negative_feedback = [\"not\"], report = [\"this student is studious\",\"the student is smart\"], student_id = [1,2], k = 2\n<b>输出：</b>[1,2]\n<b>解释：</b>\n两名学生都有 1 个正面词汇，都得到 3 分，学生 1 的 ID 更小所以排名更前。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>positive_feedback = [\"smart\",\"brilliant\",\"studious\"], negative_feedback = [\"not\"], report = [\"this student is not studious\",\"the student is smart\"], student_id = [1,2], k = 2\n<b>输出：</b>[2,1]\n<b>解释：</b>\n- ID 为 1 的学生有 1 个正面词汇和 1 个负面词汇，所以得分为 3-1=2 分。\n- ID 为 2 的学生有 1 个正面词汇，得分为 3 分。\n学生 2 分数更高，所以返回 [2,1] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= positive_feedback.length, negative_feedback.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= positive_feedback[i].length, negative_feedback[j].length &lt;= 100</code></li>\n\t<li><code>positive_feedback[i]</code> 和&nbsp;<code>negative_feedback[j]</code>&nbsp;都只包含小写英文字母。</li>\n\t<li><code>positive_feedback</code> 和&nbsp;<code>negative_feedback</code>&nbsp;中不会有相同单词。</li>\n\t<li><code>n == report.length == student_id.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>report[i]</code>&nbsp;只包含小写英文字母和空格&nbsp;<code>' '</code>&nbsp;。</li>\n\t<li><code>report[i]</code>&nbsp;中连续单词之间有单个空格隔开。</li>\n\t<li><code>1 &lt;= report[i].length &lt;= 100</code></li>\n\t<li><code>1 &lt;= student_id[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>student_id[i]</code>&nbsp;的值 <strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2513.最小化两个数组中的最大值",
        "hardRate": "MEDIUM",
        "passRate": "34.67%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-the-maximum-of-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-the-maximum-of-two-arrays/solution",
        "problemsDesc": "<p>给你两个数组&nbsp;<code>arr1</code> 和&nbsp;<code>arr2</code>&nbsp;，它们一开始都是空的。你需要往它们中添加正整数，使它们满足以下条件：</p>\n\n<ul>\n\t<li><code>arr1</code>&nbsp;包含&nbsp;<code>uniqueCnt1</code>&nbsp;个<strong>&nbsp;互不相同</strong>&nbsp;的正整数，每个整数都&nbsp;<strong>不能 </strong>被&nbsp;<code>divisor1</code>&nbsp;<strong>整除</strong>&nbsp;。</li>\n\t<li><code>arr2</code>&nbsp;包含&nbsp;<code>uniqueCnt2</code>&nbsp;个<strong>&nbsp;互不相同</strong>&nbsp;的正整数，每个整数都&nbsp;<strong>不能</strong>&nbsp;被&nbsp;<code>divisor2</code>&nbsp;<strong>整除</strong>&nbsp;。</li>\n\t<li><code>arr1</code> 和&nbsp;<code>arr2</code>&nbsp;中的元素&nbsp;<strong>互不相同</strong>&nbsp;。</li>\n</ul>\n\n<p>给你&nbsp;<code>divisor1</code>&nbsp;，<code>divisor2</code>&nbsp;，<code>uniqueCnt1</code>&nbsp;和&nbsp;<code>uniqueCnt2</code>&nbsp;，请你返回两个数组中&nbsp;<strong>最大元素</strong>&nbsp;的&nbsp;<strong>最小值</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>divisor1 = 2, divisor2 = 7, uniqueCnt1 = 1, uniqueCnt2 = 3\n<b>输出：</b>4\n<b>解释：</b>\n我们可以把前 4 个自然数划分到 arr1 和 arr2 中。\narr1 = [1] 和 arr2 = [2,3,4] 。\n可以看出两个数组都满足条件。\n最大值是 4 ，所以返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>divisor1 = 3, divisor2 = 5, uniqueCnt1 = 2, uniqueCnt2 = 1\n<b>输出：</b>3\n<b>解释：</b>\narr1 = [1,2] 和 arr2 = [3] 满足所有条件。\n最大值是 3 ，所以返回 3 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>divisor1 = 2, divisor2 = 4, uniqueCnt1 = 8, uniqueCnt2 = 2\n<b>输出：</b>15\n<b>解释：</b>\n最终数组为 arr1 = [1,3,5,7,9,11,13,15] 和 arr2 = [2,6] 。\n上述方案是满足所有条件的最优解。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= divisor1, divisor2 &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= uniqueCnt1, uniqueCnt2 &lt; 10<sup>9</sup></code></li>\n\t<li><code>2 &lt;= uniqueCnt1 + uniqueCnt2 &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2514.统计同位异构字符串数目",
        "hardRate": "HARD",
        "passRate": "46.31%",
        "problemsUrl": "https://leetcode.cn/problems/count-anagrams/",
        "solutionsUrl": "https://leetcode.cn/problems/count-anagrams/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，它包含一个或者多个单词。单词之间用单个空格&nbsp;<code>' '</code>&nbsp;隔开。</p>\n\n<p>如果字符串 <code>t</code>&nbsp;中第 <code>i</code>&nbsp;个单词是 <code>s</code>&nbsp;中第 <code>i</code>&nbsp;个单词的一个&nbsp;<strong>排列</strong>&nbsp;，那么我们称字符串&nbsp;<code>t</code>&nbsp;是字符串&nbsp;<code>s</code>&nbsp;的同位异构字符串。</p>\n\n<ul>\n\t<li>比方说，<code>\"acb dfe\"</code>&nbsp;是&nbsp;<code>\"abc def\"</code>&nbsp;的同位异构字符串，但是&nbsp;<code>\"def cab\"</code>&nbsp;和&nbsp;<code>\"adc bef\"</code>&nbsp;不是。</li>\n</ul>\n\n<p>请你返回<em>&nbsp;</em><code>s</code>&nbsp;的同位异构字符串的数目，由于答案可能很大，请你将它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong> 后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"too hot\"\n<b>输出：</b>18\n<b>解释：</b>输入字符串的一些同位异构字符串为 \"too hot\" ，\"oot hot\" ，\"oto toh\" ，\"too toh\" 以及 \"too oht\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"aa\"\n<b>输出：</b>1\n<strong>解释：</strong>输入字符串只有一个同位异构字符串。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 只包含小写英文字母和空格&nbsp;<code>' '</code>&nbsp;。</li>\n\t<li>相邻单词之间由单个空格隔开。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2515.到目标字符串的最短距离",
        "hardRate": "EASY",
        "passRate": "55.61%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-distance-to-target-string-in-a-circular-array/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-distance-to-target-string-in-a-circular-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的 <strong>环形</strong> 字符串数组 <code>words</code> 和一个字符串 <code>target</code> 。<strong>环形数组</strong> 意味着数组首尾相连。</p>\n\n<ul>\n\t<li>形式上， <code>words[i]</code> 的下一个元素是 <code>words[(i + 1) % n]</code> ，而 <code>words[i]</code> 的前一个元素是 <code>words[(i - 1 + n) % n]</code> ，其中 <code>n</code> 是 <code>words</code> 的长度。</li>\n</ul>\n\n<p>从 <code>startIndex</code> 开始，你一次可以用 <code>1</code> 步移动到下一个或者前一个单词。</p>\n\n<p>返回到达目标字符串 <code>target</code> 所需的最短距离。如果 <code>words</code> 中不存在字符串 <code>target</code> ，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"hello\",\"i\",\"am\",\"leetcode\",\"hello\"], target = \"hello\", startIndex = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>从下标 1 开始，可以经由以下步骤到达 \"hello\" ：\n- 向右移动 3 个单位，到达下标 4 。\n- 向左移动 2 个单位，到达下标 4 。\n- 向右移动 4 个单位，到达下标 0 。\n- 向左移动 1 个单位，到达下标 0 。\n到达 \"hello\" 的最短距离是 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"a\",\"b\",\"leetcode\"], target = \"leetcode\", startIndex = 0\n<strong>输出：</strong>1\n<strong>解释：</strong>从下标 0 开始，可以经由以下步骤到达 \"leetcode\" ：\n- 向右移动 2 个单位，到达下标 3 。\n- 向左移动 1 个单位，到达下标 3 。\n到达 \"leetcode\" 的最短距离是 1 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"i\",\"eat\",\"leetcode\"], target = \"ate\", startIndex = 0\n<strong>输出：</strong>-1\n<strong>解释：</strong>因为 words 中不存在字符串 \"ate\" ，所以返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><code>words[i]</code> 和 <code>target</code> 仅由小写英文字母组成</li>\n\t<li><code>0 &lt;= startIndex &lt; words.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2516.每种字符至少取 K 个",
        "hardRate": "MEDIUM",
        "passRate": "37.31%",
        "problemsUrl": "https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/",
        "solutionsUrl": "https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/solution",
        "problemsDesc": "<p>给你一个由字符 <code>'a'</code>、<code>'b'</code>、<code>'c'</code> 组成的字符串 <code>s</code> 和一个非负整数 <code>k</code> 。每分钟，你可以选择取走 <code>s</code> <strong>最左侧</strong> 还是 <strong>最右侧</strong> 的那个字符。</p>\n\n<p>你必须取走每种字符 <strong>至少</strong> <code>k</code> 个，返回需要的 <strong>最少</strong> 分钟数；如果无法取到，则返回<em> </em><code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aabaaaacaabc\", k = 2\n<strong>输出：</strong>8\n<strong>解释：</strong>\n从 s 的左侧取三个字符，现在共取到两个字符 'a' 、一个字符 'b' 。\n从 s 的右侧取五个字符，现在共取到四个字符 'a' 、两个字符 'b' 和两个字符 'c' 。\n共需要 3 + 5 = 8 分钟。\n可以证明需要的最少分钟数是 8 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a\", k = 1\n<strong>输出：</strong>-1\n<strong>解释：</strong>无法取到一个字符 'b' 或者 'c'，所以返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 仅由字母 <code>'a'</code>、<code>'b'</code>、<code>'c'</code> 组成</li>\n\t<li><code>0 &lt;= k &lt;= s.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2517.礼盒的最大甜蜜度",
        "hardRate": "MEDIUM",
        "passRate": "71.93%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>price</code> ，其中 <code>price[i]</code> 表示第 <code>i</code> 类糖果的价格，另给你一个正整数 <code>k</code> 。</p>\n\n<p>商店组合 <code>k</code> 类 <strong>不同</strong> 糖果打包成礼盒出售。礼盒的 <strong>甜蜜度</strong> 是礼盒中任意两种糖果 <strong>价格</strong> 绝对差的最小值。</p>\n\n<p>返回礼盒的 <strong>最大 </strong>甜蜜度<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>price = [13,5,1,8,21,2], k = 3\n<strong>输出：</strong>8\n<strong>解释：</strong>选出价格分别为 [13,5,21] 的三类糖果。\n礼盒的甜蜜度为 min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8 。\n可以证明能够取得的最大甜蜜度就是 8 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>price = [1,3,1], k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>选出价格分别为 [1,3] 的两类糖果。 \n礼盒的甜蜜度为 min(|1 - 3|) = min(2) = 2 。\n可以证明能够取得的最大甜蜜度就是 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>price = [7,7,7,7], k = 2\n<strong>输出：</strong>0\n<strong>解释：</strong>从现有的糖果中任选两类糖果，甜蜜度都会是 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= k &lt;= price.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= price[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2518.好分区的数目",
        "hardRate": "HARD",
        "passRate": "42.63%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-great-partitions/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-great-partitions/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>\n\n<p><strong>分区</strong> 的定义是：将数组划分成两个有序的 <strong>组</strong> ，并满足每个元素 <strong>恰好</strong> 存在于 <strong>某一个</strong> 组中。如果分区中每个组的元素和都大于等于 <code>k</code> ，则认为分区是一个好分区。</p>\n\n<p>返回 <strong>不同</strong> 的好分区的数目。由于答案可能很大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后的结果。</p>\n\n<p>如果在两个分区中，存在某个元素 <code>nums[i]</code> 被分在不同的组中，则认为这两个分区不同。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4], k = 4\n<strong>输出：</strong>6\n<strong>解释：</strong>好分区的情况是 ([1,2,3], [4]), ([1,3], [2,4]), ([1,4], [2,3]), ([2,3], [1,4]), ([2,4], [1,3]) 和 ([4], [1,2,3]) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,3,3], k = 4\n<strong>输出：</strong>0\n<strong>解释：</strong>数组中不存在好分区。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [6,6], k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>可以将 nums[0] 放入第一个分区或第二个分区中。\n好分区的情况是 ([6], [6]) 和 ([6], [6]) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, k &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2519.统计 K-Big 索引的数量",
        "hardRate": "HARD",
        "passRate": "74.89%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-k-big-indices/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-k-big-indices/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2520.统计能整除数字的位数",
        "hardRate": "EASY",
        "passRate": "83.20%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-digits-that-divide-a-number/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-digits-that-divide-a-number/solution",
        "problemsDesc": "<p>给你一个整数 <code>num</code> ，返回 <code>num</code> 中能整除 <code>num</code> 的数位的数目。</p>\n\n<p>如果满足&nbsp;<code>nums % val == 0</code> ，则认为整数 <code>val</code> 可以整除 <code>nums</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 7\n<strong>输出：</strong>1\n<strong>解释：</strong>7 被自己整除，因此答案是 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 121\n<strong>输出：</strong>2\n<strong>解释：</strong>121 可以被 1 整除，但无法被 2 整除。由于 1 出现两次，所以返回 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = 1248\n<strong>输出：</strong>4\n<strong>解释：</strong>1248 可以被它每一位上的数字整除，因此答案是 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10<sup>9</sup></code></li>\n\t<li><code>num</code> 的数位中不含 <code>0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2521.数组乘积中的不同质因数数目",
        "hardRate": "MEDIUM",
        "passRate": "62.66%",
        "problemsUrl": "https://leetcode.cn/problems/distinct-prime-factors-of-product-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/distinct-prime-factors-of-product-of-array/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>nums</code> ，对 <code>nums</code> 所有元素求积之后，找出并返回乘积中 <strong>不同质因数</strong> 的数目。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><strong>质数</strong> 是指大于 <code>1</code> 且仅能被 <code>1</code> 及自身整除的数字。</li>\n\t<li>如果 <code>val2 / val1</code> 是一个整数，则整数 <code>val1</code> 是另一个整数 <code>val2</code> 的一个因数。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,4,3,7,10,6]\n<strong>输出：</strong>4\n<strong>解释：</strong>\nnums 中所有元素的乘积是：2 * 4 * 3 * 7 * 10 * 6 = 10080 = 2<sup>5</sup> * 3<sup>2</sup> * 5 * 7 。\n共有 4 个不同的质因数，所以返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,4,8,16]\n<strong>输出：</strong>1\n<strong>解释：</strong>\nnums 中所有元素的乘积是：2 * 4 * 8 * 16 = 1024 = 2<sup>10</sup> 。\n共有 1 个不同的质因数，所以返回 1 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>2 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2522.将字符串分割成值不超过 K 的子字符串",
        "hardRate": "MEDIUM",
        "passRate": "49.56%",
        "problemsUrl": "https://leetcode.cn/problems/partition-string-into-substrings-with-values-at-most-k/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-string-into-substrings-with-values-at-most-k/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，它每一位都是&nbsp;<code>1</code>&nbsp;到&nbsp;<code>9</code>&nbsp;之间的数字组成，同时给你一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>如果一个字符串 <code>s</code>&nbsp;的分割满足以下条件，我们称它是一个 <strong>好</strong>&nbsp;分割：</p>\n\n<ul>\n\t<li><code>s</code>&nbsp;中每个数位 <strong>恰好</strong>&nbsp;属于一个子字符串。</li>\n\t<li>每个子字符串的值都小于等于&nbsp;<code>k</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回 <code>s</code>&nbsp;所有的 <strong>好</strong>&nbsp;分割中，子字符串的&nbsp;<strong>最少</strong>&nbsp;数目。如果不存在 <code>s</code>&nbsp;的<strong>&nbsp;好</strong>&nbsp;分割，返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p><b>注意：</b></p>\n\n<ul>\n\t<li>一个字符串的 <strong>值</strong>&nbsp;是这个字符串对应的整数。比方说，<code>\"123\"</code>&nbsp;的值为&nbsp;<code>123</code>&nbsp;，<code>\"1\"</code>&nbsp;的值是&nbsp;<code>1</code>&nbsp;。</li>\n\t<li><strong>子字符串</strong>&nbsp;是字符串中一段连续的字符序列。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"165462\", k = 60\n<b>输出：</b>4\n<b>解释：</b>我们将字符串分割成子字符串 \"16\" ，\"54\" ，\"6\" 和 \"2\" 。每个子字符串的值都小于等于 k = 60 。\n不存在小于 4 个子字符串的好分割。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"238182\", k = 5\n<b>输出：</b>-1\n<strong>解释：</strong>这个字符串不存在好分割。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code>&nbsp;是&nbsp;<code>'1'</code>&nbsp;到&nbsp;<code>'9'</code>&nbsp;之间的数字。</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2523.范围内最接近的两个质数",
        "hardRate": "MEDIUM",
        "passRate": "41.38%",
        "problemsUrl": "https://leetcode.cn/problems/closest-prime-numbers-in-range/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-prime-numbers-in-range/solution",
        "problemsDesc": "<p>给你两个正整数&nbsp;<code>left</code> 和&nbsp;<code>right</code>&nbsp;，请你找到两个整数&nbsp;<code>num1</code> 和&nbsp;<code>num2</code>&nbsp;，它们满足：</p>\n\n<ul>\n\t<li><code>left &lt;= nums1 &lt; nums2 &lt;= right&nbsp;</code>&nbsp;。</li>\n\t<li><code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;都是 <strong>质数</strong>&nbsp;。</li>\n\t<li><code>nums2 - nums1</code>&nbsp;是满足上述条件的质数对中的 <strong>最小值</strong>&nbsp;。</li>\n</ul>\n\n<p>请你返回正整数数组&nbsp;<code>ans = [nums1, nums2]</code>&nbsp;。如果有多个整数对满足上述条件，请你返回&nbsp;<code>nums1</code>&nbsp;最小的质数对。如果不存在符合题意的质数对，请你返回&nbsp;<code>[-1, -1]</code>&nbsp;。</p>\n\n<p>如果一个整数大于&nbsp;<code>1</code>&nbsp;，且只能被&nbsp;<code>1</code> 和它自己整除，那么它是一个质数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>left = 10, right = 19\n<b>输出：</b>[11,13]\n<b>解释：</b>10 到 19 之间的质数为 11 ，13 ，17 和 19 。\n质数对的最小差值是 2 ，[11,13] 和 [17,19] 都可以得到最小差值。\n由于 11 比 17 小，我们返回第一个质数对。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>left = 4, right = 6\n<b>输出：</b>[-1,-1]\n<b>解释：</b>给定范围内只有一个质数，所以题目条件无法被满足。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= left &lt;= right &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2524.子数组的最大频率分数",
        "hardRate": "HARD",
        "passRate": "52.40%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-frequency-score-of-a-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-frequency-score-of-a-subarray/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2525.根据规则将箱子分类",
        "hardRate": "EASY",
        "passRate": "47.53%",
        "problemsUrl": "https://leetcode.cn/problems/categorize-box-according-to-criteria/",
        "solutionsUrl": "https://leetcode.cn/problems/categorize-box-according-to-criteria/solution",
        "problemsDesc": "<p>给你四个整数&nbsp;<code>length</code>&nbsp;，<code>width</code>&nbsp;，<code>height</code>&nbsp;和&nbsp;<code>mass</code>&nbsp;，分别表示一个箱子的三个维度和质量，请你返回一个表示箱子 <strong>类别</strong> 的字符串。</p>\n\n<ul>\n\t<li>如果满足以下条件，那么箱子是&nbsp;<code>\"Bulky\"</code>&nbsp;的：\n\n\t<ul>\n\t\t<li>箱子 <strong>至少有一个</strong> 维度大于等于 <code>10<sup>4</sup></code>&nbsp;。</li>\n\t\t<li>或者箱子的 <strong>体积</strong> 大于等于&nbsp;<code>10<sup>9</sup></code>&nbsp;。</li>\n\t</ul>\n\t</li>\n\t<li>如果箱子的质量大于等于&nbsp;<code>100</code>&nbsp;，那么箱子是&nbsp;<code>\"Heavy\"</code>&nbsp;的。</li>\n\t<li>如果箱子同时是&nbsp;<code>\"Bulky\"</code> 和&nbsp;<code>\"Heavy\"</code>&nbsp;，那么返回类别为&nbsp;<code>\"Both\"</code>&nbsp;。</li>\n\t<li>如果箱子既不是&nbsp;<code>\"Bulky\"</code>&nbsp;，也不是&nbsp;<code>\"Heavy\"</code>&nbsp;，那么返回类别为&nbsp;<code>\"Neither\"</code>&nbsp;。</li>\n\t<li>如果箱子是&nbsp;<code>\"Bulky\"</code>&nbsp;但不是&nbsp;<code>\"Heavy\"</code>&nbsp;，那么返回类别为&nbsp;<code>\"Bulky\"</code>&nbsp;。</li>\n\t<li>如果箱子是&nbsp;<code>\"Heavy\"</code>&nbsp;但不是&nbsp;<code>\"Bulky\"</code>&nbsp;，那么返回类别为&nbsp;<code>\"Heavy\"</code>&nbsp;。</li>\n</ul>\n\n<p><strong>注意</strong>，箱子的体积等于箱子的长度、宽度和高度的乘积。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>length = 1000, width = 35, height = 700, mass = 300\n<b>输出：</b>\"Heavy\"\n<b>解释：</b>\n箱子没有任何维度大于等于 10<sup>4 </sup>。\n体积为 24500000 &lt;= 10<sup>9 </sup>。所以不能归类为 \"Bulky\" 。\n但是质量 &gt;= 100 ，所以箱子是 \"Heavy\" 的。\n由于箱子不是 \"Bulky\" 但是是 \"Heavy\" ，所以我们返回 \"Heavy\" 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>length = 200, width = 50, height = 800, mass = 50\n<b>输出：</b>\"Neither\"\n<b>解释：</b>\n箱子没有任何维度大于等于 10<sup>4</sup>&nbsp;。\n体积为 8 * 10<sup>6</sup> &lt;= 10<sup>9</sup>&nbsp;。所以不能归类为 \"Bulky\" 。\n质量小于 100 ，所以不能归类为 \"Heavy\" 。\n由于不属于上述两者任何一类，所以我们返回 \"Neither\" 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= length, width, height &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= mass &lt;= 10<sup>3</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2526.找到数据流中的连续整数",
        "hardRate": "MEDIUM",
        "passRate": "54.10%",
        "problemsUrl": "https://leetcode.cn/problems/find-consecutive-integers-from-a-data-stream/",
        "solutionsUrl": "https://leetcode.cn/problems/find-consecutive-integers-from-a-data-stream/solution",
        "problemsDesc": "<p>给你一个整数数据流，请你实现一个数据结构，检查数据流中最后&nbsp;<code>k</code>&nbsp;个整数是否 <strong>等于</strong> 给定值&nbsp;<code>value</code>&nbsp;。</p>\n\n<p>请你实现&nbsp;<strong>DataStream</strong>&nbsp;类：</p>\n\n<ul>\n\t<li><code>DataStream(int value, int k)</code>&nbsp;用两个整数 <code>value</code>&nbsp;和 <code>k</code>&nbsp;初始化一个空的整数数据流。</li>\n\t<li><code>boolean consec(int num)</code>&nbsp;将&nbsp;<code>num</code>&nbsp;添加到整数数据流。如果后 <code>k</code>&nbsp;个整数都等于&nbsp;<code>value</code>&nbsp;，返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。如果少于&nbsp;<code>k</code>&nbsp;个整数，条件不满足，所以也返回&nbsp;<code>false</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"DataStream\", \"consec\", \"consec\", \"consec\", \"consec\"]\n[[4, 3], [4], [4], [4], [3]]\n<strong>输出：</strong>\n[null, false, false, true, false]\n\n<strong>解释：</strong>\nDataStream dataStream = new DataStream(4, 3); // value = 4, k = 3 \ndataStream.consec(4); // 数据流中只有 1 个整数，所以返回 False 。\ndataStream.consec(4); // 数据流中只有 2 个整数\n                      // 由于 2 小于 k ，返回 False 。\ndataStream.consec(4); // 数据流最后 3 个整数都等于 value， 所以返回 True 。\ndataStream.consec(3); // 最后 k 个整数分别是 [4,4,3] 。\n                      // 由于 3 不等于 value ，返回 False 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= value, num &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li>至多调用 <code>consec</code>&nbsp;次数为&nbsp;<code>10<sup>5</sup></code>&nbsp;次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2527.查询数组 Xor 美丽值",
        "hardRate": "MEDIUM",
        "passRate": "70.33%",
        "problemsUrl": "https://leetcode.cn/problems/find-xor-beauty-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-xor-beauty-of-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>三个下标&nbsp;<code>i</code>&nbsp;，<code>j</code>&nbsp;和&nbsp;<code>k</code>&nbsp;的 <strong>有效值</strong>&nbsp;定义为&nbsp;<code>((nums[i] | nums[j]) &amp; nums[k])</code>&nbsp;。</p>\n\n<p>一个数组的 <strong>xor 美丽值</strong>&nbsp;是数组中所有满足&nbsp;<code>0 &lt;= i, j, k &lt; n</code>&nbsp;&nbsp;<strong>的三元组</strong>&nbsp;<code>(i, j, k)</code>&nbsp;的 <strong>有效值</strong>&nbsp;的异或结果。</p>\n\n<p>请你返回&nbsp;<code>nums</code>&nbsp;的 xor 美丽值。</p>\n\n<p><b>注意：</b></p>\n\n<ul>\n\t<li><code>val1 | val2</code>&nbsp;是&nbsp;<code>val1</code> 和&nbsp;<code>val2</code>&nbsp;的按位或。</li>\n\t<li><code>val1 &amp; val2</code>&nbsp;是&nbsp;<code>val1</code> 和&nbsp;<code>val2</code>&nbsp;的按位与。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,4]\n<b>输出：</b>5\n<b>解释：</b>\n三元组和它们对应的有效值如下：\n- (0,0,0) 有效值为 ((1 | 1) &amp; 1) = 1\n- (0,0,1) 有效值为 ((1 | 1) &amp; 4) = 0\n- (0,1,0) 有效值为 ((1 | 4) &amp; 1) = 1\n- (0,1,1) 有效值为 ((1 | 4) &amp; 4) = 4\n- (1,0,0) 有效值为 ((4 | 1) &amp; 1) = 1\n- (1,0,1) 有效值为 ((4 | 1) &amp; 4) = 4\n- (1,1,0) 有效值为 ((4 | 4) &amp; 1) = 0\n- (1,1,1) 有效值为 ((4 | 4) &amp; 4) = 4 \n数组的 xor 美丽值为所有有效值的按位异或 1 ^ 0 ^ 1 ^ 4 ^ 1 ^ 4 ^ 0 ^ 4 = 5 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [15,45,20,2,34,35,5,44,32,30]\n<b>输出：</b>34\n<code><span style=\"\"><b>解释：</b>数组的 xor 美丽值为</span> 34 。</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length&nbsp;&lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2528.最大化城市的最小供电站数目",
        "hardRate": "HARD",
        "passRate": "40.64%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-the-minimum-powered-city/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-the-minimum-powered-city/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>stations</code>&nbsp;，其中&nbsp;<code>stations[i]</code>&nbsp;表示第 <code>i</code>&nbsp;座城市的供电站数目。</p>\n\n<p>每个供电站可以在一定 <strong>范围</strong>&nbsp;内给所有城市提供电力。换句话说，如果给定的范围是&nbsp;<code>r</code>&nbsp;，在城市&nbsp;<code>i</code>&nbsp;处的供电站可以给所有满足&nbsp;<code>|i - j| &lt;= r</code> 且&nbsp;<code>0 &lt;= i, j &lt;= n - 1</code>&nbsp;的城市&nbsp;<code>j</code>&nbsp;供电。</p>\n\n<ul>\n\t<li><code>|x|</code>&nbsp;表示 <code>x</code>&nbsp;的 <strong>绝对值</strong>&nbsp;。比方说，<code>|7 - 5| = 2</code>&nbsp;，<code>|3 - 10| = 7</code>&nbsp;。</li>\n</ul>\n\n<p>一座城市的 <strong>电量</strong>&nbsp;是所有能给它供电的供电站数目。</p>\n\n<p>政府批准了可以额外建造 <code>k</code>&nbsp;座供电站，你需要决定这些供电站分别应该建在哪里，这些供电站与已经存在的供电站有相同的供电范围。</p>\n\n<p>给你两个整数&nbsp;<code>r</code> 和&nbsp;<code>k</code>&nbsp;，如果以最优策略建造额外的发电站，返回所有城市中，最小供电站数目的最大值是多少。</p>\n\n<p>这 <code>k</code>&nbsp;座供电站可以建在多个城市。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>stations = [1,2,4,5,0], r = 1, k = 2\n<b>输出：</b>5\n<b>解释：</b>\n最优方案之一是把 2 座供电站都建在城市 1 。\n每座城市的供电站数目分别为 [1,4,4,5,0] 。\n- 城市 0 的供电站数目为 1 + 4 = 5 。\n- 城市 1 的供电站数目为 1 + 4 + 4 = 9 。\n- 城市 2 的供电站数目为 4 + 4 + 5 = 13 。\n- 城市 3 的供电站数目为 5 + 4 = 9 。\n- 城市 4 的供电站数目为 5 + 0 = 5 。\n供电站数目最少是 5 。\n无法得到更优解，所以我们返回 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>stations = [4,4,4,4], r = 0, k = 3\n<b>输出：</b>4\n<b>解释：</b>\n无论如何安排，总有一座城市的供电站数目是 4 ，所以最优解是 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == stations.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= stations[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= r&nbsp;&lt;= n - 1</code></li>\n\t<li><code>0 &lt;= k&nbsp;&lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2529.正整数和负整数的最大计数",
        "hardRate": "EASY",
        "passRate": "76.24%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/solution",
        "problemsDesc": "<p>给你一个按 <strong>非递减顺序</strong> 排列的数组 <code>nums</code> ，返回正整数数目和负整数数目中的最大值。</p>\n\n<ul>\n\t<li>换句话讲，如果 <code>nums</code> 中正整数的数目是 <code>pos</code> ，而负整数的数目是 <code>neg</code> ，返回 <code>pos</code> 和 <code>neg</code>二者中的最大值。</li>\n</ul>\n\n<p><strong>注意：</strong><code>0</code> 既不是正整数也不是负整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-2,-1,-1,1,2,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>共有 3 个正整数和 3 个负整数。计数得到的最大值是 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-3,-2,-1,0,0,1,2]\n<strong>输出：</strong>3\n<strong>解释：</strong>共有 2 个正整数和 3 个负整数。计数得到的最大值是 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,20,66,1314]\n<strong>输出：</strong>4\n<strong>解释：</strong>共有 4 个正整数和 0 个负整数。计数得到的最大值是 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2000</code></li>\n\t<li><code>-2000 &lt;= nums[i] &lt;= 2000</code></li>\n\t<li><code>nums</code> 按 <strong>非递减顺序</strong> 排列。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以设计并实现时间复杂度为 <code>O(log(n))</code> 的算法解决此问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2530.执行 K 次操作后的最大分数",
        "hardRate": "MEDIUM",
        "passRate": "44.95%",
        "problemsUrl": "https://leetcode.cn/problems/maximal-score-after-applying-k-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/maximal-score-after-applying-k-operations/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>k</code> 。你的 <strong>起始分数</strong> 为 <code>0</code> 。</p>\n\n<p>在一步 <strong>操作</strong> 中：</p>\n\n<ol>\n\t<li>选出一个满足 <code>0 &lt;= i &lt; nums.length</code> 的下标 <code>i</code> ，</li>\n\t<li>将你的 <strong>分数</strong> 增加 <code>nums[i]</code> ，并且</li>\n\t<li>将 <code>nums[i]</code> 替换为 <code>ceil(nums[i] / 3)</code> 。</li>\n</ol>\n\n<p>返回在 <strong>恰好</strong> 执行 <code>k</code> 次操作后，你可能获得的最大分数。</p>\n\n<p>向上取整函数 <code>ceil(val)</code> 的结果是大于或等于 <code>val</code> 的最小整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,10,10,10,10], k = 5\n<strong>输出：</strong>50\n<strong>解释：</strong>对数组中每个元素执行一次操作。最后分数是 10 + 10 + 10 + 10 + 10 = 50 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,10,3,3,3], k = 3\n<strong>输出：</strong>17\n<strong>解释：</strong>可以执行下述操作：\n第 1 步操作：选中 i = 1 ，nums 变为 [1,<em><strong>4</strong></em>,3,3,3] 。分数增加 10 。\n第 2 步操作：选中 i = 1 ，nums 变为 [1,<em><strong>2</strong></em>,3,3,3] 。分数增加 4 。\n第 3 步操作：选中 i = 2 ，nums 变为 [1,1,<em><strong>1</strong></em>,3,3] 。分数增加 3 。\n最后分数是 10 + 4 + 3 = 17 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2531.使字符串总不同字符的数目相等",
        "hardRate": "MEDIUM",
        "passRate": "29.67%",
        "problemsUrl": "https://leetcode.cn/problems/make-number-of-distinct-characters-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/make-number-of-distinct-characters-equal/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong> 开始的字符串 <code>word1</code> 和 <code>word2</code> 。</p>\n\n<p>一次 <strong>移动</strong> 由以下两个步骤组成：</p>\n\n<ul>\n\t<li>选中两个下标&nbsp;<code>i</code> 和 <code>j</code> ，分别满足 <code>0 &lt;= i &lt; word1.length</code> 和 <code>0 &lt;= j &lt; word2.length</code> ，</li>\n\t<li>交换 <code>word1[i]</code> 和 <code>word2[j]</code> 。</li>\n</ul>\n\n<p>如果可以通过 <strong>恰好一次</strong> 移动，使 <code>word1</code> 和 <code>word2</code> 中不同字符的数目相等，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>word1 = \"ac\", word2 = \"b\"\n<strong>输出：</strong>false\n<strong>解释：</strong>交换任何一组下标都会导致第一个字符串中有 2 个不同的字符，而在第二个字符串中只有 1 个不同字符。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>word1 = \"abcc\", word2 = \"aab\"\n<strong>输出：</strong>true\n<strong>解释：</strong>交换第一个字符串的下标 2 和第二个字符串的下标 0 。之后得到 word1 = \"abac\" 和 word2 = \"cab\" ，各有 3 个不同字符。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>word1 = \"abcde\", word2 = \"fghij\"\n<strong>输出：</strong>true\n<strong>解释：</strong>无论交换哪一组下标，两个字符串中都会有 5 个不同字符。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word1.length, word2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>word1</code> 和 <code>word2</code> 仅由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2532.过桥的时间",
        "hardRate": "HARD",
        "passRate": "51.72%",
        "problemsUrl": "https://leetcode.cn/problems/time-to-cross-a-bridge/",
        "solutionsUrl": "https://leetcode.cn/problems/time-to-cross-a-bridge/solution",
        "problemsDesc": "<p>共有 <code>k</code> 位工人计划将 <code>n</code> 个箱子从旧仓库移动到新仓库。给你两个整数 <code>n</code> 和 <code>k</code>，以及一个二维整数数组 <code>time</code> ，数组的大小为 <code>k x 4</code> ，其中 <code>time[i] = [leftToRight<sub>i</sub>, pickOld<sub>i</sub>, rightToLeft<sub>i</sub>, putNew<sub>i</sub>]</code> 。</p>\n\n<p>一条河将两座仓库分隔，只能通过一座桥通行。旧仓库位于河的右岸，新仓库在河的左岸。开始时，所有 <code>k</code> 位工人都在桥的左侧等待。为了移动这些箱子，第 <code>i</code> 位工人（下标从 <strong>0</strong> 开始）可以：</p>\n\n<ul>\n\t<li>从左岸（新仓库）跨过桥到右岸（旧仓库），用时 <code>leftToRight<sub>i</sub></code> 分钟。</li>\n\t<li>从旧仓库选择一个箱子，并返回到桥边，用时 <code>pickOld<sub>i</sub></code> 分钟。不同工人可以同时搬起所选的箱子。</li>\n\t<li>从右岸（旧仓库）跨过桥到左岸（新仓库），用时 <code>rightToLeft<sub>i</sub></code> 分钟。</li>\n\t<li>将箱子放入新仓库，并返回到桥边，用时 <code>putNew<sub>i</sub></code> 分钟。不同工人可以同时放下所选的箱子。</li>\n</ul>\n\n<p>如果满足下面任一条件，则认为工人 <code>i</code> 的 <strong>效率低于</strong> 工人 <code>j</code> ：</p>\n\n<ul>\n\t<li><code>leftToRight<sub>i</sub> + rightToLeft<sub>i</sub> &gt; leftToRight<sub>j</sub> + rightToLeft<sub>j</sub></code></li>\n\t<li><code>leftToRight<sub>i</sub> + rightToLeft<sub>i</sub> == leftToRight<sub>j</sub> + rightToLeft<sub>j</sub></code> 且 <code>i &gt; j</code></li>\n</ul>\n\n<p>工人通过桥时需要遵循以下规则：</p>\n\n<ul>\n\t<li>如果工人 <code>x</code> 到达桥边时，工人 <code>y</code> 正在过桥，那么工人 <code>x</code> 需要在桥边等待。</li>\n\t<li>如果没有正在过桥的工人，那么在桥右边等待的工人可以先过桥。如果同时有多个工人在右边等待，那么 <strong>效率最低</strong> 的工人会先过桥。</li>\n\t<li>如果没有正在过桥的工人，且桥右边也没有在等待的工人，同时旧仓库还剩下至少一个箱子需要搬运，此时在桥左边的工人可以过桥。如果同时有多个工人在左边等待，那么 <strong>效率最低</strong> 的工人会先过桥。</li>\n</ul>\n\n<p>所有 <code>n</code> 个盒子都需要放入新仓库，<span class=\"text-only\" data-eleid=\"8\" style=\"white-space: pre;\">请你返回最后一个搬运箱子的工人 </span><strong><span class=\"text-only\" data-eleid=\"9\" style=\"white-space: pre;\">到达河左岸</span></strong><span class=\"text-only\" data-eleid=\"10\" style=\"white-space: pre;\"> 的时间。</span></p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, k = 3, time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n从 0 到 1 ：工人 2 从左岸过桥到达右岸。\n从 1 到 2 ：工人 2 从旧仓库搬起一个箱子。\n从 2 到 6 ：工人 2 从右岸过桥到达左岸。\n从 6 到 7 ：工人 2 将箱子放入新仓库。\n整个过程在 7 分钟后结束。因为问题关注的是最后一个工人到达左岸的时间，所以返回 6 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 2, time = [[1,9,1,8],[10,10,10,10]]\n<strong>输出：</strong>50\n<strong>解释：</strong>\n从 0 到 10 ：工人 1 从左岸过桥到达右岸。\n从 10 到 20 ：工人 1 从旧仓库搬起一个箱子。\n从 10 到 11 ：工人 0 从左岸过桥到达右岸。\n从 11 到 20 ：工人 0 从旧仓库搬起一个箱子。\n从 20 到 30 ：工人 1 从右岸过桥到达左岸。\n从 30 到 40 ：工人 1 将箱子放入新仓库。\n从 30 到 31 ：工人 0 从右岸过桥到达左岸。\n从 31 到 39 ：工人 0 将箱子放入新仓库。\n从 39 到 40 ：工人 0 从左岸过桥到达右岸。\n从 40 到 49 ：工人 0 从旧仓库搬起一个箱子。\n从 49 到 50 ：工人 0 从右岸过桥到达左岸。\n从 50 到 58 ：工人 0 将箱子放入新仓库。\n整个过程在 58 分钟后结束。因为问题关注的是最后一个工人到达左岸的时间，所以返回 50 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n, k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>time.length == k</code></li>\n\t<li><code>time[i].length == 4</code></li>\n\t<li><code>1 &lt;= leftToRight<sub>i</sub>, pickOld<sub>i</sub>, rightToLeft<sub>i</sub>, putNew<sub>i</sub> &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2533.好二进制字符串的数量",
        "hardRate": "MEDIUM",
        "passRate": "69.48%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-good-binary-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-good-binary-strings/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2534.通过门的时间",
        "hardRate": "HARD",
        "passRate": "63.25%",
        "problemsUrl": "https://leetcode.cn/problems/time-taken-to-cross-the-door/",
        "solutionsUrl": "https://leetcode.cn/problems/time-taken-to-cross-the-door/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2535.数组元素和与数字和的绝对差",
        "hardRate": "EASY",
        "passRate": "84.25%",
        "problemsUrl": "https://leetcode.cn/problems/difference-between-element-sum-and-digit-sum-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/difference-between-element-sum-and-digit-sum-of-an-array/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>nums</code> 。</p>\n\n<ul>\n\t<li><strong>元素和</strong> 是 <code>nums</code> 中的所有元素相加求和。</li>\n\t<li><strong>数字和</strong> 是&nbsp;<code>nums</code> 中每一个元素的每一数位（重复数位需多次求和）相加求和。</li>\n</ul>\n\n<p>返回 <strong>元素和</strong> 与 <strong>数字和</strong> 的绝对差。</p>\n\n<p><strong>注意：</strong>两个整数 <code>x</code> 和 <code>y</code> 的绝对差定义为 <code>|x - y|</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,15,6,3]\n<strong>输出：</strong>9\n<strong>解释：</strong>\nnums 的元素和是 1 + 15 + 6 + 3 = 25 。\nnums 的数字和是 1 + 1 + 5 + 6 + 3 = 16 。\n元素和与数字和的绝对差是 |25 - 16| = 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>0\n<strong>解释：</strong>\nnums 的元素和是 1 + 2 + 3 + 4 = 10 。\nnums 的数字和是 1 + 2 + 3 + 4 = 10 。\n元素和与数字和的绝对差是 |10 - 10| = 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 2000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2536.子矩阵元素加 1",
        "hardRate": "MEDIUM",
        "passRate": "60.62%",
        "problemsUrl": "https://leetcode.cn/problems/increment-submatrices-by-one/",
        "solutionsUrl": "https://leetcode.cn/problems/increment-submatrices-by-one/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> ，表示最初有一个 <code>n x n</code> 、下标从 <strong>0</strong> 开始的整数矩阵 <code>mat</code> ，矩阵中填满了 0 。</p>\n\n<p>另给你一个二维整数数组 <code>query</code> 。针对每个查询 <code>query[i] = [row1<sub>i</sub>, col1<sub>i</sub>, row2<sub>i</sub>, col2<sub>i</sub>]</code> ，请你执行下述操作：</p>\n\n<ul>\n\t<li>找出 <strong>左上角</strong> 为 <code>(row1<sub>i</sub>, col1<sub>i</sub>)</code> 且 <strong>右下角</strong> 为 <code>(row2<sub>i</sub>, col2<sub>i</sub>)</code> 的子矩阵，将子矩阵中的 <strong>每个元素</strong> 加 <code>1</code> 。也就是给所有满足 <code>row1<sub>i</sub> &lt;= x &lt;= row2<sub>i</sub></code> 和 <code>col1<sub>i</sub> &lt;= y &lt;= col2<sub>i</sub></code> 的 <code>mat[x][y]</code> 加 <code>1</code> 。</li>\n</ul>\n\n<p>返回执行完所有操作后得到的矩阵 <code>mat</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/24/p2example11.png\" style=\"width: 531px; height: 121px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 3, queries = [[1,1,2,2],[0,0,1,1]]\n<strong>输出：</strong>[[1,1,0],[1,2,1],[0,1,1]]\n<strong>解释：</strong>上图所展示的分别是：初始矩阵、执行完第一个操作后的矩阵、执行完第二个操作后的矩阵。\n- 第一个操作：将左上角为 (1, 1) 且右下角为 (2, 2) 的子矩阵中的每个元素加 1 。 \n- 第二个操作：将左上角为 (0, 0) 且右下角为 (1, 1) 的子矩阵中的每个元素加 1 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/24/p2example22.png\" style=\"width: 261px; height: 82px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 2, queries = [[0,0,1,1]]\n<strong>输出：</strong>[[1,1],[1,1]]\n<strong>解释：</strong>上图所展示的分别是：初始矩阵、执行完第一个操作后的矩阵。 \n- 第一个操作：将矩阵中的每个元素加 1 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= row1<sub>i</sub> &lt;= row2<sub>i</sub> &lt; n</code></li>\n\t<li><code>0 &lt;= col1<sub>i</sub> &lt;= col2<sub>i</sub> &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2537.统计好子数组的数目",
        "hardRate": "MEDIUM",
        "passRate": "48.72%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-good-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-good-subarrays/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>&nbsp;和一个整数 <code>k</code>&nbsp;，请你返回 <code>nums</code>&nbsp;中 <strong>好</strong>&nbsp;子数组的数目。</p>\n\n<p>一个子数组 <code>arr</code>&nbsp;如果有 <strong>至少</strong>&nbsp;<code>k</code>&nbsp;对下标 <code>(i, j)</code>&nbsp;满足 <code>i &lt; j</code>&nbsp;且 <code>arr[i] == arr[j]</code>&nbsp;，那么称它是一个 <strong>好</strong>&nbsp;子数组。</p>\n\n<p><strong>子数组</strong>&nbsp;是原数组中一段连续 <strong>非空</strong>&nbsp;的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,1,1,1,1], k = 10\n<b>输出：</b>1\n<b>解释：</b>唯一的好子数组是这个数组本身。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [3,1,4,3,2,2,4], k = 2\n<b>输出：</b>4\n<b>解释：</b>总共有 4 个不同的好子数组：\n- [3,1,4,3,2,2] 有 2 对。\n- [3,1,4,3,2,2,4] 有 3 对。\n- [1,4,3,2,2,4] 有 2 对。\n- [4,3,2,2,4] 有 2 对。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2538.最大价值和与最小价值和的差值",
        "hardRate": "HARD",
        "passRate": "48.52%",
        "problemsUrl": "https://leetcode.cn/problems/difference-between-maximum-and-minimum-price-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/difference-between-maximum-and-minimum-price-sum/solution",
        "problemsDesc": "<p>给你一个 <code>n</code>&nbsp;个节点的无向无根图，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。给你一个整数&nbsp;<code>n</code>&nbsp;和一个长度为 <code>n - 1</code>&nbsp;的二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示树中节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条边。</p>\n\n<p>每个节点都有一个价值。给你一个整数数组&nbsp;<code>price</code>&nbsp;，其中&nbsp;<code>price[i]</code>&nbsp;是第 <code>i</code>&nbsp;个节点的价值。</p>\n\n<p>一条路径的 <strong>价值和</strong>&nbsp;是这条路径上所有节点的价值之和。</p>\n\n<p>你可以选择树中任意一个节点作为根节点&nbsp;<code>root</code>&nbsp;。选择 <code>root</code>&nbsp;为根的 <strong>开销</strong>&nbsp;是以 <code>root</code>&nbsp;为起点的所有路径中，<strong>价值和</strong>&nbsp;最大的一条路径与最小的一条路径的差值。</p>\n\n<p>请你返回所有节点作为根节点的选择中，<strong>最大</strong>&nbsp;的 <strong>开销</strong>&nbsp;为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/01/example14.png\" style=\"width: 556px; height: 231px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\n<b>输出：</b>24\n<b>解释：</b>上图展示了以节点 2 为根的树。左图（红色的节点）是最大价值和路径，右图（蓝色的节点）是最小价值和路径。\n- 第一条路径节点为 [2,1,3,4]：价值为 [7,8,6,10] ，价值和为 31 。\n- 第二条路径节点为 [2] ，价值为 [7] 。\n最大路径和与最小路径和的差值为 24 。24 是所有方案中的最大开销。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/24/p1_example2.png\" style=\"width: 352px; height: 184px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 3, edges = [[0,1],[1,2]], price = [1,1,1]\n<b>输出：</b>2\n<b>解释：</b>上图展示了以节点 0 为根的树。左图（红色的节点）是最大价值和路径，右图（蓝色的节点）是最小价值和路径。\n- 第一条路径包含节点 [0,1,2]：价值为 [1,1,1] ，价值和为 3 。\n- 第二条路径节点为 [0] ，价值为 [1] 。\n最大路径和与最小路径和的差值为 2 。2 是所有方案中的最大开销。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>edges</code> 表示一棵符合题面要求的树。</li>\n\t<li><code>price.length == n</code></li>\n\t<li><code>1 &lt;= price[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2539.好子序列的个数",
        "hardRate": "MEDIUM",
        "passRate": "62.93%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-good-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-good-subsequences/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2540.最小公共值",
        "hardRate": "EASY",
        "passRate": "60.42%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-common-value/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-common-value/solution",
        "problemsDesc": "<p>给你两个整数数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;，它们已经按非降序排序，请你返回两个数组的 <strong>最小公共整数</strong>&nbsp;。如果两个数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;没有公共整数，请你返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>如果一个整数在两个数组中都 <strong>至少出现一次</strong>&nbsp;，那么这个整数是数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;<strong>公共</strong>&nbsp;的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,2,3], nums2 = [2,4]\n<b>输出：</b>2\n<b>解释：</b>两个数组的最小公共元素是 2 ，所以我们返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,2,3,6], nums2 = [2,3,4,5]\n<b>输出：</b>2\n<b>解释：</b>两个数组中的公共元素是 2 和 3 ，2 是较小值，所以返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[j] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;都是 <strong>非降序</strong>&nbsp;的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2541.使数组中所有元素相等的最小操作数 II",
        "hardRate": "MEDIUM",
        "passRate": "31.26%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-array-equal-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-array-equal-ii/solution",
        "problemsDesc": "<p>给你两个整数数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;，两个数组长度都是&nbsp;<code>n</code>&nbsp;，再给你一个整数&nbsp;<code>k</code>&nbsp;。你可以对数组&nbsp;<code>nums1</code>&nbsp;进行以下操作：</p>\n\n<ul>\n\t<li>选择两个下标&nbsp;<code>i</code> 和&nbsp;<code>j</code>&nbsp;，将&nbsp;<code>nums1[i]</code>&nbsp;增加&nbsp;<code>k</code>&nbsp;，将&nbsp;<code>nums1[j]</code>&nbsp;减少&nbsp;<code>k</code>&nbsp;。换言之，<code>nums1[i] = nums1[i] + k</code> 且&nbsp;<code>nums1[j] = nums1[j] - k</code>&nbsp;。</li>\n</ul>\n\n<p>如果对于所有满足&nbsp;<code>0 &lt;= i &lt; n</code>&nbsp;都有&nbsp;<code>num1[i] == nums2[i]</code>&nbsp;，那么我们称&nbsp;<code>nums1</code> <strong>等于</strong>&nbsp;<code>nums2</code>&nbsp;。</p>\n\n<p>请你返回使<em>&nbsp;</em><code>nums1</code><em> </em>等于<em>&nbsp;</em><code>nums2</code>&nbsp;的&nbsp;<strong>最少</strong>&nbsp;操作数。如果没办法让它们相等，请你返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [4,3,1,4], nums2 = [1,3,7,1], k = 3\n<b>输出：</b>2\n<b>解释：</b>我们可以通过 2 个操作将 nums1 变成 nums2 。\n第 1 个操作：i = 2 ，j = 0 。操作后得到 nums1 = [1,3,4,4] 。\n第 2 个操作：i = 2 ，j = 3 。操作后得到 nums1 = [1,3,7,1] 。\n无法用更少操作使两个数组相等。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [3,8,5,2], nums2 = [2,4,1,6], k = 1\n<b>输出：</b>-1\n<b>解释：</b>无法使两个数组相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length == nums2.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[j] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2542.最大子序列的分数",
        "hardRate": "MEDIUM",
        "passRate": "51.39%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-subsequence-score/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-subsequence-score/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>&nbsp;，两者长度都是&nbsp;<code>n</code>&nbsp;，再给你一个正整数&nbsp;<code>k</code>&nbsp;。你必须从&nbsp;<code>nums1</code>&nbsp;中选一个长度为 <code>k</code>&nbsp;的 <strong>子序列</strong>&nbsp;对应的下标。</p>\n\n<p>对于选择的下标&nbsp;<code>i<sub>0</sub></code>&nbsp;，<code>i<sub>1</sub></code>&nbsp;，...，&nbsp;<code>i<sub>k - 1</sub></code>&nbsp;，你的&nbsp;<strong>分数</strong>&nbsp;定义如下：</p>\n\n<ul>\n\t<li><code>nums1</code>&nbsp;中下标对应元素求和，乘以&nbsp;<code>nums2</code>&nbsp;中下标对应元素的&nbsp;<strong>最小值</strong>&nbsp;。</li>\n\t<li>用公示表示：&nbsp;<code>(nums1[i<sub>0</sub>] + nums1[i<sub>1</sub>] +...+ nums1[i<sub>k - 1</sub>]) * min(nums2[i<sub>0</sub>] , nums2[i<sub>1</sub>], ... ,nums2[i<sub>k - 1</sub>])</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回 <strong>最大</strong>&nbsp;可能的分数。</p>\n\n<p>一个数组的 <strong>子序列</strong>&nbsp;下标是集合&nbsp;<code>{0, 1, ..., n-1}</code>&nbsp;中删除若干元素得到的剩余集合，也可以不删除任何元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3\n<b>输出：</b>12\n<b>解释：</b>\n四个可能的子序列分数为：\n- 选择下标 0 ，1 和 2 ，得到分数 (1+3+3) * min(2,1,3) = 7 。\n- 选择下标 0 ，1 和 3 ，得到分数 (1+3+2) * min(2,1,4) = 6 。\n- 选择下标 0 ，2 和 3 ，得到分数 (1+3+2) * min(2,3,4) = 12 。\n- 选择下标 1 ，2 和 3 ，得到分数 (3+3+2) * min(1,3,4) = 8 。\n所以最大分数为 12 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [4,2,3,1,1], nums2 = [7,5,10,9,6], k = 1\n<b>输出：</b>30\n<b>解释：</b>\n选择下标 2 最优：nums1[2] * nums2[2] = 3 * 10 = 30 是最大可能分数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length == nums2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2543.判断一个点是否可以到达",
        "hardRate": "HARD",
        "passRate": "46.10%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-point-is-reachable/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-point-is-reachable/solution",
        "problemsDesc": "<p>给你一个无穷大的网格图。一开始你在&nbsp;<code>(1, 1)</code>&nbsp;，你需要通过有限步移动到达点&nbsp;<code>(targetX, targetY)</code>&nbsp;。</p>\n\n<p><b>每一步</b>&nbsp;，你可以从点&nbsp;<code>(x, y)</code>&nbsp;移动到以下点之一：</p>\n\n<ul>\n\t<li><code>(x, y - x)</code></li>\n\t<li><code>(x - y, y)</code></li>\n\t<li><code>(2 * x, y)</code></li>\n\t<li><code>(x, 2 * y)</code></li>\n</ul>\n\n<p>给你两个整数&nbsp;<code>targetX</code> 和&nbsp;<code>targetY</code>&nbsp;，分别表示你最后需要到达点的 X 和 Y 坐标。如果你可以从&nbsp;<code>(1, 1)</code>&nbsp;出发到达这个点，请你返回<code>true</code> ，否则返回<em>&nbsp;</em><code>false</code><em>&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>targetX = 6, targetY = 9\n<b>输出：</b>false\n<b>解释：</b>没法从 (1,1) 出发到达 (6,9) ，所以返回 false 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>targetX = 4, targetY = 7\n<b>输出：</b>true\n<b>解释：</b>你可以按照以下路径到达：(1,1) -&gt; (1,2) -&gt; (1,4) -&gt; (1,8) -&gt; (1,7) -&gt; (2,7) -&gt; (4,7) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= targetX, targetY&nbsp;&lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2544.交替数字和",
        "hardRate": "EASY",
        "passRate": "79.83%",
        "problemsUrl": "https://leetcode.cn/problems/alternating-digit-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/alternating-digit-sum/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> 。<code>n</code> 中的每一位数字都会按下述规则分配一个符号：</p>\n\n<ul>\n\t<li><strong>最高有效位</strong> 上的数字分配到 <strong>正</strong> 号。</li>\n\t<li>剩余每位上数字的符号都与其相邻数字相反。</li>\n</ul>\n\n<p>返回所有数字及其对应符号的和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 521\n<strong>输出：</strong>4\n<strong>解释：</strong>(+5) + (-2) + (+1) = 4</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 111\n<strong>输出：</strong>1\n<strong>解释：</strong>(+1) + (-1) + (+1) = 1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 886996\n<strong>输出：</strong>0\n<strong>解释：</strong>(+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2545.根据第 K 场考试的分数排序",
        "hardRate": "MEDIUM",
        "passRate": "86.50%",
        "problemsUrl": "https://leetcode.cn/problems/sort-the-students-by-their-kth-score/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-the-students-by-their-kth-score/solution",
        "problemsDesc": "<p>班里有 <code>m</code> 位学生，共计划组织 <code>n</code> 场考试。给你一个下标从 <strong>0</strong> 开始、大小为 <code>m x n</code> 的整数矩阵 <code>score</code> ，其中每一行对应一位学生，而 <code>score[i][j]</code> 表示第 <code>i</code> 位学生在第 <code>j</code> 场考试取得的分数。矩阵 <code>score</code> 包含的整数&nbsp;<strong>互不相同</strong>&nbsp;。</p>\n\n<p>另给你一个整数 <code>k</code> 。请你按第 <code>k</code> 场考试分数从高到低完成对这些学生（矩阵中的行）的排序。</p>\n\n<p>返回排序后的矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/30/example1.png\" style=\"width: 600px; height: 136px;\" /></p>\n\n<pre>\n<strong>输入：</strong>score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2\n<strong>输出：</strong>[[7,5,11,2],[10,6,9,1],[4,8,3,15]]\n<strong>解释：</strong>在上图中，S 表示学生，E 表示考试。\n- 下标为 1 的学生在第 2 场考试取得的分数为 11 ，这是考试的最高分，所以 TA 需要排在第一。\n- 下标为 0 的学生在第 2 场考试取得的分数为 9 ，这是考试的第二高分，所以 TA 需要排在第二。\n- 下标为 2 的学生在第 2 场考试取得的分数为 3 ，这是考试的最低分，所以 TA 需要排在第三。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/30/example2.png\" style=\"width: 486px; height: 121px;\" /></p>\n\n<pre>\n<strong>输入：</strong>score = [[3,4],[5,6]], k = 0\n<strong>输出：</strong>[[5,6],[3,4]]\n<strong>解释：</strong>在上图中，S 表示学生，E 表示考试。\n- 下标为 1 的学生在第 0 场考试取得的分数为 5 ，这是考试的最高分，所以 TA 需要排在第一。\n- 下标为 0 的学生在第 0 场考试取得的分数为 3 ，这是考试的最低分，所以 TA 需要排在第二。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == score.length</code></li>\n\t<li><code>n == score[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 250</code></li>\n\t<li><code>1 &lt;= score[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>score</code> 由 <strong>不同</strong> 的整数组成</li>\n\t<li><code>0 &lt;= k &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2546.执行逐位运算使字符串相等",
        "hardRate": "MEDIUM",
        "passRate": "42.16%",
        "problemsUrl": "https://leetcode.cn/problems/apply-bitwise-operations-to-make-strings-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/apply-bitwise-operations-to-make-strings-equal/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong> 开始的 <strong>二元</strong> 字符串 <code>s</code> 和 <code>target</code> ，两个字符串的长度均为 <code>n</code> 。你可以对 <code>s</code> 执行下述操作 <strong>任意</strong> 次：</p>\n\n<ul>\n\t<li>选择两个 <strong>不同</strong> 的下标 <code>i</code> 和 <code>j</code> ，其中 <code>0 &lt;= i, j &lt; n</code> 。</li>\n\t<li>同时，将 <code>s[i]</code> 替换为 (<code>s[i]</code> <strong>OR</strong> <code>s[j]</code>) ，<code>s[j]</code> 替换为 (<code>s[i]</code> <strong>XOR</strong> <code>s[j]</code>) 。</li>\n</ul>\n\n<p>例如，如果 <code>s = \"0110\"</code> ，你可以选择 <code>i = 0</code> 和 <code>j = 2</code>，然后同时将 <code>s[0]</code> 替换为 (<code>s[0]</code> <strong>OR</strong> <code>s[2]</code> = <code>0</code> <strong>OR</strong> <code>1</code> = <code>1</code>)，并将 <code>s[2]</code> 替换为 (<code>s[0]</code> <strong>XOR</strong> <code>s[2]</code> = <code>0</code> <strong>XOR</strong> <code>1</code> = <code>1</code>)，最终得到 <code>s = \"1110\"</code> 。</p>\n\n<p>如果可以使 <code>s</code> 等于 <code>target</code> ，返回 <code>true</code> ，否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"1010\", target = \"0110\"\n<strong>输出：</strong>true\n<strong>解释：</strong>可以执行下述操作：\n- 选择 i = 2 和 j = 0 ，得到 s = \"<em><strong>0</strong></em>0<em><strong>1</strong></em>0\".\n- 选择 i = 2 和 j = 1 ，得到 s = \"0<em><strong>11</strong></em>0\".\n可以使 s 等于 target ，返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"11\", target = \"00\"\n<strong>输出：</strong>false\n<strong>解释：</strong>执行任意次操作都无法使 s 等于 target 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == s.length == target.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 和 <code>target</code> 仅由数字 <code>0</code> 和 <code>1</code> 组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2547.拆分数组的最小代价",
        "hardRate": "HARD",
        "passRate": "56.53%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-split-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-split-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>\n\n<p>将数组拆分成一些非空子数组。拆分的 <strong>代价</strong> 是每个子数组中的 <strong>重要性</strong> 之和。</p>\n\n<p>令 <code>trimmed(subarray)</code> 作为子数组的一个特征，其中所有仅出现一次的数字将会被移除。</p>\n\n<ul>\n\t<li>例如，<code>trimmed([3,1,2,4,3,4]) = [3,4,3,4]</code> 。</li>\n</ul>\n\n<p>子数组的 <strong>重要性</strong> 定义为 <code>k + trimmed(subarray).length</code> 。</p>\n\n<ul>\n\t<li>例如，如果一个子数组是 <code>[1,2,3,3,3,4,4]</code> ，<code>trimmed([1,2,3,3,3,4,4]) = [3,3,3,4,4]</code> 。这个子数组的重要性就是 <code>k + 5</code> 。</li>\n</ul>\n\n<p>找出并返回拆分 <code>nums</code> 的所有可行方案中的最小代价。</p>\n\n<p><strong>子数组</strong> 是数组的一个连续 <strong>非空</strong> 元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,2,1,3,3], k = 2\n<strong>输出：</strong>8\n<strong>解释：</strong>将 nums 拆分成两个子数组：[1,2], [1,2,1,3,3]\n[1,2] 的重要性是 2 + (0) = 2 。\n[1,2,1,3,3] 的重要性是 2 + (2 + 2) = 6 。\n拆分的代价是 2 + 6 = 8 ，可以证明这是所有可行的拆分方案中的最小代价。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,2,1], k = 2\n<strong>输出：</strong>6\n<strong>解释：</strong>将 nums 拆分成两个子数组：[1,2], [1,2,1] 。\n[1,2] 的重要性是 2 + (0) = 2 。\n[1,2,1] 的重要性是 2 + (2) = 4 。\n拆分的代价是 2 + 4 = 6 ，可以证明这是所有可行的拆分方案中的最小代价。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,2,1], k = 5\n<strong>输出：</strong>10\n<strong>解释：</strong>将 nums 拆分成一个子数组：[1,2,1,2,1].\n[1,2,1,2,1] 的重要性是 5 + (3 + 2) = 10 。\n拆分的代价是 10 ，可以证明这是所有可行的拆分方案中的最小代价。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt; nums.length</code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2548.填满背包的最大价格",
        "hardRate": "MEDIUM",
        "passRate": "58.29%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-price-to-fill-a-bag/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-price-to-fill-a-bag/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2549.统计桌面上的不同数字",
        "hardRate": "EASY",
        "passRate": "62.78%",
        "problemsUrl": "https://leetcode.cn/problems/count-distinct-numbers-on-board/",
        "solutionsUrl": "https://leetcode.cn/problems/count-distinct-numbers-on-board/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> ，开始时，它放在桌面上。在 <code>10<sup>9</sup></code> 天内，每天都要执行下述步骤：</p>\n\n<ul>\n\t<li>对于出现在桌面上的每个数字 <code>x</code> ，找出符合 <code>1 &lt;= i &lt;= n</code> 且满足 <code>x % i == 1</code> 的所有数字 <code>i</code> 。</li>\n\t<li>然后，将这些数字放在桌面上。</li>\n</ul>\n\n<p>返回在 <code>10<sup>9</sup></code> 天之后，出现在桌面上的 <strong>不同</strong> 整数的数目。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>一旦数字放在桌面上，则会一直保留直到结束。</li>\n\t<li><code>%</code> 表示取余运算。例如，<code>14 % 3</code> 等于 <code>2</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>4\n<strong>解释：</strong>最开始，5 在桌面上。 \n第二天，2 和 4 也出现在桌面上，因为 5 % 2 == 1 且 5 % 4 == 1 。 \n再过一天 3 也出现在桌面上，因为 4 % 3 == 1 。 \n在十亿天结束时，桌面上的不同数字有 2 、3 、4 、5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3 \n<strong>输出：</strong>2\n<strong>解释：</strong> \n因为 3 % 2 == 1 ，2 也出现在桌面上。 \n在十亿天结束时，桌面上的不同数字只有两个：2 和 3 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2550.猴子碰撞的方法数",
        "hardRate": "MEDIUM",
        "passRate": "28.99%",
        "problemsUrl": "https://leetcode.cn/problems/count-collisions-of-monkeys-on-a-polygon/",
        "solutionsUrl": "https://leetcode.cn/problems/count-collisions-of-monkeys-on-a-polygon/solution",
        "problemsDesc": "<p>现在有一个正凸多边形，其上共有 <code>n</code> 个顶点。顶点按顺时针方向从 <code>0</code> 到 <code>n - 1</code> 依次编号。每个顶点上 <strong>正好有一只猴子</strong> 。下图中是一个 6 个顶点的凸多边形。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/22/hexagon.jpg\" style=\"width: 300px; height: 293px;\" /></p>\n\n<p>每个猴子同时移动到相邻的顶点。顶点 <code>i</code> 的相邻顶点可以是：</p>\n\n<ul>\n\t<li>顺时针方向的顶点 <code>(i + 1) % n</code> ，或</li>\n\t<li>逆时针方向的顶点 <code>(i - 1 + n) % n</code> 。</li>\n</ul>\n\n<p>如果移动后至少有两只猴子停留在同一个顶点上或者相交在一条边上，则会发生 <strong>碰撞</strong> 。</p>\n\n<p>返回猴子至少发生 <strong>一次碰撞 </strong>的移动方法数。由于答案可能非常大，请返回对 <code>10<sup>9</sup>+7</code> 取余后的结果。</p>\n\n<p><strong>注意</strong>，每只猴子只能移动一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>6\n<strong>解释：</strong>共计 8 种移动方式。\n下面列出两种会发生碰撞的方式：\n- 猴子 1 顺时针移动；猴子 2 逆时针移动；猴子 3 顺时针移动。猴子 1 和猴子 2 碰撞。\n- 猴子 1 逆时针移动；猴子 2 逆时针移动；猴子 3 顺时针移动。猴子 1 和猴子 3 碰撞。\n可以证明，有 6 种让猴子碰撞的方法。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>14\n<strong>解释：</strong>可以证明，有 14 种让猴子碰撞的方法。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2551.将珠子放入背包中",
        "hardRate": "HARD",
        "passRate": "56.47%",
        "problemsUrl": "https://leetcode.cn/problems/put-marbles-in-bags/",
        "solutionsUrl": "https://leetcode.cn/problems/put-marbles-in-bags/solution",
        "problemsDesc": "<p>你有&nbsp;<code>k</code>&nbsp;个背包。给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>weights</code>&nbsp;，其中&nbsp;<code>weights[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个珠子的重量。同时给你整数 <code>k</code>&nbsp;。</p>\n\n<p>请你按照如下规则将所有的珠子放进&nbsp;<code>k</code>&nbsp;个背包。</p>\n\n<ul>\n\t<li>没有背包是空的。</li>\n\t<li>如果第&nbsp;<code>i</code>&nbsp;个珠子和第&nbsp;<code>j</code>&nbsp;个珠子在同一个背包里，那么下标在&nbsp;<code>i</code>&nbsp;到&nbsp;<code>j</code>&nbsp;之间的所有珠子都必须在这同一个背包中。</li>\n\t<li>如果一个背包有下标从&nbsp;<code>i</code>&nbsp;到&nbsp;<code>j</code>&nbsp;的所有珠子，那么这个背包的价格是&nbsp;<code>weights[i] + weights[j]</code>&nbsp;。</li>\n</ul>\n\n<p>一个珠子分配方案的 <strong>分数</strong>&nbsp;是所有 <code>k</code>&nbsp;个背包的价格之和。</p>\n\n<p>请你返回所有分配方案中，<strong>最大分数</strong>&nbsp;与 <strong>最小分数</strong>&nbsp;的 <strong>差值</strong>&nbsp;为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>weights = [1,3,5,1], k = 2\n<b>输出：</b>4\n<b>解释：</b>\n分配方案 [1],[3,5,1] 得到最小得分 (1+1) + (3+1) = 6 。\n分配方案 [1,3],[5,1] 得到最大得分 (1+3) + (5+1) = 10 。\n所以差值为 10 - 6 = 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>weights = [1, 3], k = 2\n<b>输出：</b>0\n<b>解释：</b>唯一的分配方案为 [1],[3] 。\n最大最小得分相等，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= weights.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= weights[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2552.统计上升四元组",
        "hardRate": "HARD",
        "passRate": "44.14%",
        "problemsUrl": "https://leetcode.cn/problems/count-increasing-quadruplets/",
        "solutionsUrl": "https://leetcode.cn/problems/count-increasing-quadruplets/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，它包含&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;的所有数字，请你返回上升四元组的数目。</p>\n\n<p>如果一个四元组&nbsp;<code>(i, j, k, l)</code>&nbsp;满足以下条件，我们称它是上升的：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; k &lt; l &lt; n</code>&nbsp;且</li>\n\t<li><code>nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l]</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,3,2,4,5]\n<b>输出：</b>2\n<b>解释：</b>\n- 当 i = 0 ，j = 1 ，k = 2 且 l = 3 时，有 nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l] 。\n- 当 i = 0 ，j = 1 ，k = 2 且 l = 4 时，有 nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l] 。\n没有其他的四元组，所以我们返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4]\n<b>输出：</b>0\n<b>解释：</b>只存在一个四元组 i = 0 ，j = 1 ，k = 2 ，l = 3 ，但是 nums[j] &lt; nums[k] ，所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>4 &lt;= nums.length &lt;= 4000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>\n\t<li><code>nums</code>&nbsp;中所有数字 <strong>互不相同</strong>&nbsp;，<code>nums</code>&nbsp;是一个排列。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2553.分割数组中数字的数位",
        "hardRate": "EASY",
        "passRate": "82.56%",
        "problemsUrl": "https://leetcode.cn/problems/separate-the-digits-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/separate-the-digits-in-an-array/solution",
        "problemsDesc": "<p>给你一个正整数数组&nbsp;<code>nums</code>&nbsp;，请你返回一个数组<em>&nbsp;</em><code>answer</code> ，你需要将&nbsp;<code>nums</code>&nbsp;中每个整数进行数位分割后，按照&nbsp;<code>nums</code>&nbsp;中出现的&nbsp;<strong>相同顺序</strong>&nbsp;放入答案数组中。</p>\n\n<p>对一个整数进行数位分割，指的是将整数各个数位按原本出现的顺序排列成数组。</p>\n\n<ul>\n\t<li>比方说，整数&nbsp;<code>10921</code>&nbsp;，分割它的各个数位得到&nbsp;<code>[1,0,9,2,1]</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [13,25,83,77]\n<b>输出：</b>[1,3,2,5,8,3,7,7]\n<b>解释：</b>\n- 分割 13 得到 [1,3] 。\n- 分割 25 得到 [2,5] 。\n- 分割 83 得到 [8,3] 。\n- 分割 77 得到 [7,7] 。\nanswer = [1,3,2,5,8,3,7,7] 。answer 中的数字分割结果按照原数字在数组中的相同顺序排列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [7,1,3,9]\n<b>输出：</b>[7,1,3,9]\n<b>解释：</b>nums 中每个整数的分割是它自己。\nanswer = [7,1,3,9] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2554.从一个范围内选择最多整数 I",
        "hardRate": "MEDIUM",
        "passRate": "58.23%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-integers-to-choose-from-a-range-i/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-integers-to-choose-from-a-range-i/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>banned</code>&nbsp;和两个整数&nbsp;<code>n</code> 和&nbsp;<code>maxSum</code>&nbsp;。你需要按照以下规则选择一些整数：</p>\n\n<ul>\n\t<li>被选择整数的范围是&nbsp;<code>[1, n]</code>&nbsp;。</li>\n\t<li>每个整数 <strong>至多</strong>&nbsp;选择 <strong>一次</strong>&nbsp;。</li>\n\t<li>被选择整数不能在数组&nbsp;<code>banned</code>&nbsp;中。</li>\n\t<li>被选择整数的和不超过&nbsp;<code>maxSum</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回按照上述规则 <strong>最多</strong>&nbsp;可以选择的整数数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>banned = [1,6,5], n = 5, maxSum = 6\n<b>输出：</b>2\n<b>解释：</b>你可以选择整数 2 和 4 。\n2 和 4 在范围 [1, 5] 内，且它们都不在 banned 中，它们的和是 6 ，没有超过 maxSum 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>banned = [1,2,3,4,5,6,7], n = 8, maxSum = 1\n<b>输出：</b>0\n<b>解释：</b>按照上述规则无法选择任何整数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>banned = [11], n = 7, maxSum = 50\n<b>输出：</b>7\n<b>解释：</b>你可以选择整数 1, 2, 3, 4, 5, 6 和 7 。\n它们都在范围 [1, 7] 中，且都没出现在 banned 中，它们的和是 28 ，没有超过 maxSum 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= banned.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= banned[i], n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= maxSum &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2555.两个线段获得的最多奖品",
        "hardRate": "MEDIUM",
        "passRate": "39.86%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-win-from-two-segments/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-win-from-two-segments/solution",
        "problemsDesc": "<p>在 <strong>X轴</strong>&nbsp;上有一些奖品。给你一个整数数组&nbsp;<code>prizePositions</code>&nbsp;，它按照 <strong>非递减</strong>&nbsp;顺序排列，其中&nbsp;<code>prizePositions[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;件奖品的位置。数轴上一个位置可能会有多件奖品。再给你一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>你可以选择两个端点为整数的线段。每个线段的长度都必须是 <code>k</code>&nbsp;。你可以获得位置在任一线段上的所有奖品（包括线段的两个端点）。注意，两个线段可能会有相交。</p>\n\n<ul>\n\t<li>比方说&nbsp;<code>k = 2</code>&nbsp;，你可以选择线段&nbsp;<code>[1, 3]</code> 和&nbsp;<code>[2, 4]</code>&nbsp;，你可以获得满足&nbsp;<code>1 &lt;= prizePositions[i] &lt;= 3</code> 或者&nbsp;<code>2 &lt;= prizePositions[i] &lt;= 4</code>&nbsp;的所有奖品 i 。</li>\n</ul>\n\n<p>请你返回在选择两个最优线段的前提下，可以获得的 <strong>最多</strong>&nbsp;奖品数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>prizePositions = [1,1,2,2,3,3,5], k = 2\n<b>输出：</b>7\n<b>解释：</b>这个例子中，你可以选择线段 [1, 3] 和 [3, 5] ，获得 7 个奖品。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>prizePositions = [1,2,3,4], k = 0\n<b>输出：</b>2\n<b>解释：</b>这个例子中，一个选择是选择线段 <code>[3, 3]</code> 和 <code>[4, 4] ，获得 2 个奖品。</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prizePositions.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= prizePositions[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>9</sup> </code></li>\n\t<li><code>prizePositions</code>&nbsp;有序非递减。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2556.二进制矩阵中翻转最多一次使路径不连通",
        "hardRate": "MEDIUM",
        "passRate": "30.25%",
        "problemsUrl": "https://leetcode.cn/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/",
        "solutionsUrl": "https://leetcode.cn/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;<strong>二进制</strong> 矩阵&nbsp;<code>grid</code>&nbsp;。你可以从一个格子&nbsp;<code>(row, col)</code>&nbsp;移动到格子&nbsp;<code>(row + 1, col)</code>&nbsp;或者&nbsp;<code>(row, col + 1)</code>&nbsp;，前提是前往的格子值为 <code>1</code>&nbsp;。如果从&nbsp;<code>(0, 0)</code>&nbsp;到&nbsp;<code>(m - 1, n - 1)</code>&nbsp;没有任何路径，我们称该矩阵是&nbsp;<strong>不连通</strong>&nbsp;的。</p>\n\n<p>你可以翻转 <strong>最多一个</strong>&nbsp;格子的值（也可以不翻转）。你 <strong>不能翻转</strong>&nbsp;格子&nbsp;<code>(0, 0)</code> 和&nbsp;<code>(m - 1, n - 1)</code>&nbsp;。</p>\n\n<p>如果可以使矩阵不连通，请你返回&nbsp;<code>true</code>&nbsp;，否则返回<em>&nbsp;</em><code>false</code><em>&nbsp;</em>。</p>\n\n<p><strong>注意</strong>&nbsp;，翻转一个格子的值，可以使它的值从&nbsp;<code>0</code>&nbsp;变&nbsp;<code>1</code>&nbsp;，或从&nbsp;<code>1</code>&nbsp;变&nbsp;<code>0</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/07/yetgrid2drawio.png\" style=\"width: 441px; height: 151px;\" /></p>\n\n<pre>\n<b>输入：</b>grid = [[1,1,1],[1,0,0],[1,1,1]]\n<strong>输出：</strong>true\n<b>解释：</b>按照上图所示我们翻转蓝色格子里的值，翻转后从 (0, 0) 到 (2, 2) 没有路径。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/07/yetgrid3drawio.png\" /></p>\n\n<pre>\n<b>输入：</b>grid = [[1,1,1],[1,0,1],[1,1,1]]\n<b>输出：</b>false\n<b>解释：</b>无法翻转至多一个格子，使 (0, 0) 到 (2, 2) 没有路径。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>grid[0][0] == grid[m - 1][n - 1] == 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2557.从一个范围内选择最多整数 II",
        "hardRate": "MEDIUM",
        "passRate": "43.22%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-integers-to-choose-from-a-range-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-integers-to-choose-from-a-range-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2558.从数量最多的堆取走礼物",
        "hardRate": "EASY",
        "passRate": "68.09%",
        "problemsUrl": "https://leetcode.cn/problems/take-gifts-from-the-richest-pile/",
        "solutionsUrl": "https://leetcode.cn/problems/take-gifts-from-the-richest-pile/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>gifts</code> ，表示各堆礼物的数量。每一秒，你需要执行以下操作：</p>\n\n<ul>\n\t<li>选择礼物数量最多的那一堆。</li>\n\t<li>如果不止一堆都符合礼物数量最多，从中选择任一堆即可。</li>\n\t<li>选中的那一堆留下平方根数量的礼物（向下取整），取走其他的礼物。</li>\n</ul>\n\n<p>返回在 <code>k</code> 秒后剩下的礼物数量<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>gifts = [25,64,9,4,100], k = 4\n<strong>输出：</strong>29\n<strong>解释：</strong> \n按下述方式取走礼物：\n- 在第一秒，选中最后一堆，剩下 10 个礼物。\n- 接着第二秒选中第二堆礼物，剩下 8 个礼物。\n- 然后选中第一堆礼物，剩下 5 个礼物。\n- 最后，再次选中最后一堆礼物，剩下 3 个礼物。\n最后剩下的礼物数量分别是 [5,8,9,4,3] ，所以，剩下礼物的总数量是 29 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>gifts = [1,1,1,1], k = 4\n<strong>输出：</strong>4\n<strong>解释：</strong>\n在本例中，不管选中哪一堆礼物，都必须剩下 1 个礼物。 \n也就是说，你无法获取任一堆中的礼物。 \n所以，剩下礼物的总数量是 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= gifts.length &lt;= 10<sup>3</sup></code></li>\n\t<li><code>1 &lt;= gifts[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>3</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2559.统计范围内的元音字符串数",
        "hardRate": "MEDIUM",
        "passRate": "64.31%",
        "problemsUrl": "https://leetcode.cn/problems/count-vowel-strings-in-ranges/",
        "solutionsUrl": "https://leetcode.cn/problems/count-vowel-strings-in-ranges/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串数组 <code>words</code> 以及一个二维整数数组 <code>queries</code> 。</p>\n\n<p>每个查询 <code>queries[i] = [l<sub>i</sub>, r<sub>i</sub>]</code> 会要求我们统计在 <code>words</code> 中下标在 <code>l<sub>i</sub></code> 到 <code>r<sub>i</sub></code> 范围内（<strong>包含</strong> 这两个值）并且以元音开头和结尾的字符串的数目。</p>\n\n<p>返回一个整数数组，其中数组的第 <code>i</code> 个元素对应第 <code>i</code> 个查询的答案。</p>\n\n<p><strong>注意：</strong>元音字母是 <code>'a'</code>、<code>'e'</code>、<code>'i'</code>、<code>'o'</code> 和 <code>'u'</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"aba\",\"bcb\",\"ece\",\"aa\",\"e\"], queries = [[0,2],[1,4],[1,1]]\n<strong>输出：</strong>[2,3,0]\n<strong>解释：</strong>以元音开头和结尾的字符串是 \"aba\"、\"ece\"、\"aa\" 和 \"e\" 。\n查询 [0,2] 结果为 2（字符串 \"aba\" 和 \"ece\"）。\n查询 [1,4] 结果为 3（字符串 \"ece\"、\"aa\"、\"e\"）。\n查询 [1,1] 结果为 0 。\n返回结果 [2,3,0] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"a\",\"e\",\"i\"], queries = [[0,2],[0,1],[2,2]]\n<strong>输出：</strong>[3,2,1]\n<strong>解释：</strong>每个字符串都满足这一条件，所以返回 [3,2,1] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 40</code></li>\n\t<li><code>words[i]</code> 仅由小写英文字母组成</li>\n\t<li><code>sum(words[i].length) &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= queries[j][0] &lt;= queries[j][1] &lt;&nbsp;words.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2560.打家劫舍 IV",
        "hardRate": "MEDIUM",
        "passRate": "49.77%",
        "problemsUrl": "https://leetcode.cn/problems/house-robber-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/house-robber-iv/solution",
        "problemsDesc": "<p>沿街有一排连续的房屋。每间房屋内都藏有一定的现金。现在有一位小偷计划从这些房屋中窃取现金。</p>\n\n<p>由于相邻的房屋装有相互连通的防盗系统，所以小偷 <strong>不会窃取相邻的房屋</strong> 。</p>\n\n<p>小偷的 <strong>窃取能力</strong> 定义为他在窃取过程中能从单间房屋中窃取的 <strong>最大金额</strong> 。</p>\n\n<p>给你一个整数数组 <code>nums</code> 表示每间房屋存放的现金金额。形式上，从左起第 <code>i</code> 间房屋中放有 <code>nums[i]</code> 美元。</p>\n\n<p>另给你一个整数&nbsp;<code>k</code> ，表示窃贼将会窃取的 <strong>最少</strong> 房屋数。小偷总能窃取至少 <code>k</code> 间房屋。</p>\n\n<p>返回小偷的 <strong>最小</strong> 窃取能力。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,5,9], k = 2\n<strong>输出：</strong>5\n<strong>解释：</strong>\n小偷窃取至少 2 间房屋，共有 3 种方式：\n- 窃取下标 0 和 2 处的房屋，窃取能力为 max(nums[0], nums[2]) = 5 。\n- 窃取下标 0 和 3 处的房屋，窃取能力为 max(nums[0], nums[3]) = 9 。\n- 窃取下标 1 和 3 处的房屋，窃取能力为 max(nums[1], nums[3]) = 9 。\n因此，返回 min(5, 9, 9) = 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,7,9,3,1], k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>共有 7 种窃取方式。窃取能力最小的情况所对应的方式是窃取下标 0 和 4 处的房屋。返回 max(nums[0], nums[4]) = 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= (nums.length + 1)/2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2561.重排水果",
        "hardRate": "HARD",
        "passRate": "36.52%",
        "problemsUrl": "https://leetcode.cn/problems/rearranging-fruits/",
        "solutionsUrl": "https://leetcode.cn/problems/rearranging-fruits/solution",
        "problemsDesc": "<p>你有两个果篮，每个果篮中有 <code>n</code> 个水果。给你两个下标从 <strong>0</strong> 开始的整数数组 <code>basket1</code> 和 <code>basket2</code> ，用以表示两个果篮中每个水果的成本。</p>\n\n<p>你希望两个果篮相等。为此，可以根据需要多次执行下述操作：</p>\n\n<ul>\n\t<li>选中两个下标 <code>i</code> 和 <code>j</code> ，并交换 <code>basket1</code> 中的第 <code>i</code> 个水果和 <code>basket2</code> 中的第 <code>j</code> 个水果。</li>\n\t<li>交换的成本是 <code>min(basket1<sub>i</sub>,basket2<sub>j</sub>)</code> 。</li>\n</ul>\n\n<p>根据果篮中水果的成本进行排序，如果排序后结果完全相同，则认为两个果篮相等。</p>\n\n<p>返回使两个果篮相等的最小交换成本，如果无法使两个果篮相等，则返回<em> </em><code>-1</code><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>basket1 = [4,2,2,2], basket2 = [1,4,1,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>交换 basket1 中下标为 1 的水果和 basket2 中下标为 0 的水果，交换的成本为 1 。此时，basket1 = [4,1,2,2] 且 basket2 = [2,4,1,2] 。重排两个数组，发现二者相等。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>basket1 = [2,3,4,1], basket2 = [3,2,5,1]\n<strong>输出：</strong>-1\n<strong>解释：</strong>可以证明无法使两个果篮相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>basket1.length == bakste2.length</code></li>\n\t<li><code>1 &lt;= basket1.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= basket1<sub>i</sub>,basket2<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2562.找出数组的串联值",
        "hardRate": "EASY",
        "passRate": "73.24%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-array-concatenation-value/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-array-concatenation-value/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组&nbsp;<code>nums</code> 。</p>\n\n<p>现定义两个数字的 <strong>串联</strong>&nbsp;是由这两个数值串联起来形成的新数字。</p>\n\n<ul>\n\t<li>例如，<code>15</code><span style=\"\">&nbsp;和&nbsp;</span><code>49</code>&nbsp;的串联是&nbsp;<code>1549</code> 。</li>\n</ul>\n\n<p><code>nums</code>&nbsp;的 <strong>串联值</strong>&nbsp;最初等于 <code>0</code> 。执行下述操作直到&nbsp;<code>nums</code>&nbsp;变为空：</p>\n\n<ul>\n\t<li>如果&nbsp;<code>nums</code>&nbsp;中存在不止一个数字，分别选中 <code>nums</code> 中的第一个元素和最后一个元素，将二者串联得到的值加到&nbsp;<code>nums</code>&nbsp;的 <strong>串联值</strong> 上，然后从&nbsp;<code>nums</code>&nbsp;中删除第一个和最后一个元素。</li>\n\t<li>如果仅存在一个元素，则将该元素的值加到&nbsp;<code>nums</code> 的串联值上，然后删除这个元素。</li>\n</ul>\n\n<p>返回执行完所有操作后<em>&nbsp;</em><code>nums</code> 的串联值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [7,52,2,4]\n<b>输出：</b>596\n<b>解释：</b>在执行任一步操作前，nums 为 [7,52,2,4] ，串联值为 0 。\n - 在第一步操作中：\n我们选中第一个元素 7 和最后一个元素 4 。\n二者的串联是 74 ，将其加到串联值上，所以串联值等于 74 。\n接着我们从 nums 中移除这两个元素，所以 nums 变为 [52,2] 。\n - 在第二步操作中： \n我们选中第一个元素 52 和最后一个元素 2 。 \n二者的串联是 522 ，将其加到串联值上，所以串联值等于 596 。\n接着我们从 nums 中移除这两个元素，所以 nums 变为空。\n由于串联值等于 596 ，所以答案就是 596 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5,14,13,8,12]\n<b>输出：</b>673\n<b>解释：</b>在执行任一步操作前，nums 为 [5,14,13,8,12] ，串联值为 0 。 \n- 在第一步操作中： \n我们选中第一个元素 5 和最后一个元素 12 。 \n二者的串联是 512 ，将其加到串联值上，所以串联值等于 512 。 \n接着我们从 nums 中移除这两个元素，所以 nums 变为 [14,13,8] 。\n- 在第二步操作中：\n我们选中第一个元素 14 和最后一个元素 8 。\n二者的串联是 148 ，将其加到串联值上，所以串联值等于 660 。\n接着我们从 nums 中移除这两个元素，所以 nums 变为 [13] 。 \n- 在第三步操作中：\nnums 只有一个元素，所以我们选中 13 并将其加到串联值上，所以串联值等于 673 。\n接着我们从 nums 中移除这个元素，所以 nums 变为空。 \n由于串联值等于 673 ，所以答案就是 673 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2563.统计公平数对的数目",
        "hardRate": "MEDIUM",
        "passRate": "33.67%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-fair-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-fair-pairs/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组&nbsp;<code>nums</code>&nbsp;，和两个整数&nbsp;<code>lower</code> 和&nbsp;<code>upper</code> ，返回 <strong>公平数对的数目</strong> 。</p>\n\n<p>如果&nbsp;<code>(i, j)</code>&nbsp;数对满足以下情况，则认为它是一个 <strong>公平数对</strong>&nbsp;：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; n</code>，且</li>\n\t<li><code>lower &lt;= nums[i] + nums[j] &lt;= upper</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre>\n<b>输入：</b>nums = [0,1,7,4,4,5], lower = 3, upper = 6\n<b>输出：</b>6\n<b>解释：</b>共计 6 个公平数对：(0,3)、(0,4)、(0,5)、(1,3)、(1,4) 和 (1,5) 。\n</pre>\n\n<p><b>示例 2：</b></p>\n\n<pre>\n<b>输入：</b>nums = [1,7,9,2,5], lower = 11, upper = 11\n<b>输出：</b>1\n<b>解释：</b>只有单个公平数对：(2,3) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums.length == n</code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= lower &lt;= upper &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2564.子字符串异或查询",
        "hardRate": "MEDIUM",
        "passRate": "36.37%",
        "problemsUrl": "https://leetcode.cn/problems/substring-xor-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/substring-xor-queries/solution",
        "problemsDesc": "<p>给你一个 <strong>二进制字符串</strong>&nbsp;<code>s</code>&nbsp;和一个整数数组&nbsp;<code>queries</code>&nbsp;，其中&nbsp;<code>queries[i] = [first<sub>i</sub>, second<sub>i</sub>]</code>&nbsp;。</p>\n\n<p>对于第&nbsp;<code>i</code>&nbsp;个查询，找到 <code>s</code>&nbsp;的 <strong>最短子字符串</strong>&nbsp;，它对应的 <strong>十进制</strong>值&nbsp;<code>val</code>&nbsp;与&nbsp;<code>first<sub>i</sub></code>&nbsp;<b>按位异或</b>&nbsp;得到&nbsp;<code>second<sub>i</sub></code>&nbsp;，换言之，<code>val ^ first<sub>i</sub> == second<sub>i</sub></code>&nbsp;。</p>\n\n<p>第&nbsp;<code>i</code>&nbsp;个查询的答案是子字符串&nbsp;<code>[left<sub>i</sub>, right<sub>i</sub>]</code> 的两个端点（下标从&nbsp;<strong>0</strong>&nbsp;开始），如果不存在这样的子字符串，则答案为&nbsp;<code>[-1, -1]</code>&nbsp;。如果有多个答案，请你选择&nbsp;<code>left<sub>i</sub></code>&nbsp;最小的一个。</p>\n\n<p>请你返回一个数组&nbsp;<code>ans</code>&nbsp;，其中&nbsp;<code>ans[i] = [left<sub>i</sub>, right<sub>i</sub>]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个查询的答案。</p>\n\n<p><strong>子字符串</strong>&nbsp;是一个字符串中一段连续非空的字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"101101\", queries = [[0,5],[1,2]]\n<b>输出：</b>[[0,2],[2,3]]\n<b>解释：</b>第一个查询，端点为 <code>[0,2]</code> 的子字符串为 <strong>\"101\"</strong> ，对应十进制数字 <strong><code>5 ，且</code></strong> <strong><code>5 ^ 0 = 5</code></strong>&nbsp;，所以第一个查询的答案为 <code>[0,2]。第二个查询中，</code>端点为 <code>[2,3] 的子字符串为 </code><strong>\"11\" ，对应十进制数字</strong> <strong>3</strong>&nbsp;，且 <strong>3<code> ^ 1 = 2</code></strong><code>&nbsp;。所以第二个查询的答案为</code> <code>[2,3]</code> 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"0101\", queries = [[12,8]]\n<b>输出：</b>[[-1,-1]]\n<b>解释：</b>这个例子中，没有符合查询的答案，所以返回 <code>[-1,-1] 。</code>\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"1\", queries = [[4,5]]\n<b>输出：</b>[[0,0]]\n<b>解释：</b>这个例子中，端点为 <code>[0,0]</code> 的子字符串对应的十进制值为 <strong><code>1</code></strong><code>&nbsp;，且</code> <strong><code>1 ^ 4 = 5</code></strong><code>&nbsp;。所以答案为</code> <code>[0,0] 。</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s[i]</code>&nbsp;要么是&nbsp;<code>'0'</code>&nbsp;，要么是&nbsp;<code>'1'</code>&nbsp;。</li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= first<sub>i</sub>, second<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2565.最少得分子序列",
        "hardRate": "HARD",
        "passRate": "35.90%",
        "problemsUrl": "https://leetcode.cn/problems/subsequence-with-the-minimum-score/",
        "solutionsUrl": "https://leetcode.cn/problems/subsequence-with-the-minimum-score/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>s</code> 和&nbsp;<code>t</code>&nbsp;。</p>\n\n<p>你可以从字符串 <code>t</code>&nbsp;中删除任意数目的字符。</p>\n\n<p>如果没有从字符串&nbsp;<code>t</code>&nbsp;中删除字符，那么得分为&nbsp;<code>0</code>&nbsp;，否则：</p>\n\n<ul>\n\t<li>令&nbsp;<code>left</code>&nbsp;为删除字符中的最小下标。</li>\n\t<li>令&nbsp;<code>right</code>&nbsp;为删除字符中的最大下标。</li>\n</ul>\n\n<p>字符串的得分为&nbsp;<code>right - left + 1</code>&nbsp;。</p>\n\n<p>请你返回使<em>&nbsp;</em><code>t</code><em> </em>成为<em>&nbsp;</em><code>s</code>&nbsp;子序列的最小得分。</p>\n\n<p>一个字符串的 <strong>子序列</strong>&nbsp;是从原字符串中删除一些字符后（也可以一个也不删除），剩余字符不改变顺序得到的字符串。（比方说&nbsp;<code>\"ace\"</code> 是&nbsp;<code>\"<strong><em>a</em></strong>b<strong><em>c</em></strong>d<strong><em>e</em></strong>\"</code>&nbsp;的子序列，但是&nbsp;<code>\"aec\"</code>&nbsp;不是）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"abacaba\", t = \"bzaa\"\n<b>输出：</b>1\n<b>解释：</b>这个例子中，我们删除下标 1 处的字符 \"z\" （下标从 0 开始）。\n字符串 t 变为 \"baa\" ，它是字符串 \"abacaba\" 的子序列，得分为 1 - 1 + 1 = 1 。\n1 是能得到的最小得分。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"cde\", t = \"xyz\"\n<b>输出：</b>3\n<b>解释：</b>这个例子中，我们将下标为 0， 1 和 2 处的字符 \"x\" ，\"y\" 和 \"z\" 删除（下标从 0 开始）。\n字符串变成 \"\" ，它是字符串 \"cde\" 的子序列，得分为 2 - 0 + 1 = 3 。\n3 是能得到的最小得分。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 和&nbsp;<code>t</code>&nbsp;都只包含小写英文字母。</li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2566.替换一个数字后的最大差值",
        "hardRate": "EASY",
        "passRate": "63.66%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-difference-by-remapping-a-digit/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-difference-by-remapping-a-digit/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>num</code>&nbsp;。你知道 Danny Mittal 会偷偷将 <code>0</code>&nbsp;到 <code>9</code>&nbsp;中的一个数字 <strong>替换</strong> 成另一个数字。</p>\n\n<p>请你返回将 <code>num</code>&nbsp;中&nbsp;<strong>恰好一个</strong>&nbsp;数字进行替换后，得到的最大值和最小值的差为多少。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>当 Danny 将一个数字 <code>d1</code> 替换成另一个数字 <code>d2</code> 时，Danny 需要将&nbsp;<code>nums</code>&nbsp;中所有 <code>d1</code>&nbsp;都替换成&nbsp;<code>d2</code>&nbsp;。</li>\n\t<li>Danny 可以将一个数字替换成它自己，也就是说&nbsp;<code>num</code>&nbsp;可以不变。</li>\n\t<li>Danny 可以将数字分别替换成两个不同的数字分别得到最大值和最小值。</li>\n\t<li>替换后得到的数字可以包含前导 0 。</li>\n\t<li>Danny Mittal 获得周赛 326 前 10 名，让我们恭喜他。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>num = 11891\n<b>输出：</b>99009\n<b>解释：</b>\n为了得到最大值，我们将数字 1 替换成数字 9 ，得到 99899 。\n为了得到最小值，我们将数字 1 替换成数字 0 ，得到 890 。\n两个数字的差值为 99009 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>num = 90\n<b>输出：</b>99\n<strong>解释：</strong>\n可以得到的最大值是 99（将 0 替换成 9），最小值是 0（将 9 替换成 0）。\n所以我们得到 99 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2567.修改两个元素的最小分数",
        "hardRate": "MEDIUM",
        "passRate": "51.87%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-score-by-changing-two-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-score-by-changing-two-elements/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<ul>\n\t<li><code>nums</code> 的 <strong>最小</strong>&nbsp;得分是满足 <code>0 &lt;= i &lt; j &lt; nums.length</code>&nbsp;的&nbsp;<code>|nums[i]&nbsp;- nums[j]|</code>&nbsp;的最小值。</li>\n\t<li><code>nums</code>的 <strong>最大 </strong>得分是满足 <code>0 &lt;= i &lt; j &lt; nums.length</code>&nbsp;的&nbsp;<code>|nums[i]&nbsp;- nums[j]|</code>&nbsp;的最大值。</li>\n\t<li><code>nums</code>&nbsp;的分数是 <strong>最大</strong>&nbsp;得分与 <strong>最小</strong>&nbsp;得分的和。</li>\n</ul>\n\n<p>我们的目标是最小化&nbsp;<code>nums</code>&nbsp;的分数。你 <strong>最多</strong> 可以修改&nbsp;<code>nums</code>&nbsp;中&nbsp;<strong>2</strong>&nbsp;个元素的值。</p>\n\n<p>请你返回修改&nbsp;<code>nums</code>&nbsp;中&nbsp;<strong>至多两个</strong>&nbsp;元素的值后，可以得到的 <strong>最小分数</strong>&nbsp;。</p>\n\n<p><code>|x|</code>&nbsp;表示 <code>x</code>&nbsp;的绝对值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,4,3]\n<b>输出：</b>0\n<b>解释：</b>将 nums[1] 和 nums[2] 的值改为 1 ，nums 变为 [1,1,1] 。<code>|nums[i] - nums[j]|</code> 的值永远为 0 ，所以我们返回 0 + 0 = 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,4,7,8,5]\n<b>输出：</b>3\n<b>解释：\n</b>将 nums[0] 和 nums[1] 的值变为 6 ，nums 变为 [6,6,7,8,5] 。\n最小得分是 i = 0 且 j = 1 时得到的 |<code>nums[i] - nums[j]</code>| = |6 - 6| = 0 。\n最大得分是 i = 3 且 j = 4 时得到的 |<code>nums[i] - nums[j]</code>| = |8 - 5| = 3 。\n最大得分与最小得分之和为 3 。这是最优答案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2568.最小无法得到的或值",
        "hardRate": "MEDIUM",
        "passRate": "59.91%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-impossible-or/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-impossible-or/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>如果存在一些整数满足&nbsp;<code>0 &lt;= index<sub>1</sub> &lt; index<sub>2</sub> &lt; ... &lt; index<sub>k</sub> &lt; nums.length</code>&nbsp;，得到&nbsp;<code>nums[index<sub>1</sub>] | nums[index<sub>2</sub>] | ... | nums[index<sub>k</sub>] = x</code>&nbsp;，那么我们说&nbsp;<code>x</code>&nbsp;是&nbsp;<strong>可表达的</strong>&nbsp;。换言之，如果一个整数能由&nbsp;<code>nums</code>&nbsp;的某个子序列的或运算得到，那么它就是可表达的。</p>\n\n<p>请你返回 <code>nums</code>&nbsp;不可表达的 <strong>最小非零整数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,1]\n<b>输出：</b>4\n<b>解释：</b>1 和 2 已经在数组中，因为 nums[0] | nums[1] = 2 | 1 = 3 ，所以 3 是可表达的。由于 4 是不可表达的，所以我们返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [5,3,2]\n<b>输出：</b>1\n<b>解释：</b>1 是最小不可表达的数字。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2569.更新数组后处理求和查询",
        "hardRate": "HARD",
        "passRate": "39.89%",
        "problemsUrl": "https://leetcode.cn/problems/handling-sum-queries-after-update/",
        "solutionsUrl": "https://leetcode.cn/problems/handling-sum-queries-after-update/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;，和一个二维数组&nbsp;<code>queries</code>&nbsp;表示一些操作。总共有 3 种类型的操作：</p>\n\n<ol>\n\t<li>操作类型 1 为&nbsp;<code>queries[i]&nbsp;= [1, l, r]</code>&nbsp;。你需要将 <code>nums1</code>&nbsp;从下标&nbsp;<code>l</code>&nbsp;到下标 <code>r</code>&nbsp;的所有 <code>0</code>&nbsp;反转成 <code>1</code>&nbsp;或将 <code>1</code>&nbsp;反转成 <code>0</code>&nbsp;。<code>l</code>&nbsp;和 <code>r</code>&nbsp;下标都从 <strong>0</strong>&nbsp;开始。</li>\n\t<li>操作类型 2 为&nbsp;<code>queries[i]&nbsp;= [2, p, 0]</code>&nbsp;。对于&nbsp;<code>0 &lt;= i &lt; n</code>&nbsp;中的所有下标，令&nbsp;<code>nums2[i] =&nbsp;nums2[i]&nbsp;+ nums1[i]&nbsp;* p</code>&nbsp;。</li>\n\t<li>操作类型 3 为&nbsp;<code>queries[i]&nbsp;= [3, 0, 0]</code>&nbsp;。求&nbsp;<code>nums2</code>&nbsp;中所有元素的和。</li>\n</ol>\n\n<p>请你返回一个数组，包含所有第三种操作类型的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums1 = [1,0,1], nums2 = [0,0,0], queries = [[1,1,1],[2,1,0],[3,0,0]]\n<b>输出：</b>[3]\n<strong>解释：</strong>第一个操作后 nums1 变为 [1,1,1] 。第二个操作后，nums2 变成 [1,1,1] ，所以第三个操作的答案为 3 。所以返回 [3] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums1 = [1], nums2 = [5], queries = [[2,0,0],[3,0,0]]\n<b>输出：</b>[5]\n<b>解释：</b>第一个操作后，nums2 保持不变为 [5] ，所以第二个操作的答案是 5 。所以返回 [5] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length,nums2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums1.length = nums2.length</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length = 3</code></li>\n\t<li><code>0 &lt;= l &lt;= r &lt;= nums1.length - 1</code></li>\n\t<li><code>0 &lt;= p &lt;= 10<sup>6</sup></code></li>\n\t<li><code>0 &lt;= nums1[i] &lt;= 1</code></li>\n\t<li><code>0 &lt;= nums2[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2570.合并两个二维数组 - 求和法",
        "hardRate": "EASY",
        "passRate": "69.57%",
        "problemsUrl": "https://leetcode.cn/problems/merge-two-2d-arrays-by-summing-values/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-two-2d-arrays-by-summing-values/solution",
        "problemsDesc": "<p>给你两个 <strong>二维</strong> 整数数组 <code>nums1</code> 和 <code>nums2.</code></p>\n\n<ul>\n\t<li><code>nums1[i] = [id<sub>i</sub>, val<sub>i</sub>]</code> 表示编号为 <code>id<sub>i</sub></code> 的数字对应的值等于 <code>val<sub>i</sub></code> 。</li>\n\t<li><code>nums2[i] = [id<sub>i</sub>, val<sub>i</sub>]</code>&nbsp;表示编号为 <code>id<sub>i</sub></code> 的数字对应的值等于 <code>val<sub>i</sub></code> 。</li>\n</ul>\n\n<p>每个数组都包含 <strong>互不相同</strong> 的 id ，并按 id 以 <strong>递增</strong> 顺序排列。</p>\n\n<p>请你将两个数组合并为一个按 id 以递增顺序排列的数组，并符合下述条件：</p>\n\n<ul>\n\t<li>只有在两个数组中至少出现过一次的 id 才能包含在结果数组内。</li>\n\t<li>每个 id 在结果数组中 <strong>只能出现一次</strong> ，并且其对应的值等于两个数组中该 id 所对应的值求和。如果某个数组中不存在该 id ，则认为其对应的值等于 <code>0</code> 。</li>\n</ul>\n\n<p>返回结果数组。返回的数组需要按 id 以递增顺序排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]]\n<strong>输出：</strong>[[1,6],[2,3],[3,2],[4,6]]\n<strong>解释：</strong>结果数组中包含以下元素：\n- id = 1 ，对应的值等于 2 + 4 = 6 。\n- id = 2 ，对应的值等于 3 。\n- id = 3 ，对应的值等于 2 。\n- id = 4 ，对应的值等于5 + 1 = 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]]\n<strong>输出：</strong>[[1,3],[2,4],[3,6],[4,3],[5,5]]\n<strong>解释：</strong>不存在共同 id ，在结果数组中只需要包含每个 id 和其对应的值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 200</code></li>\n\t<li><code>nums1[i].length == nums2[j].length == 2</code></li>\n\t<li><code>1 &lt;= id<sub>i</sub>, val<sub>i</sub> &lt;= 1000</code></li>\n\t<li>数组中的 id 互不相同</li>\n\t<li>数据均按 id 以严格递增顺序排列</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2571.将整数减少到零需要的最少操作数",
        "hardRate": "MEDIUM",
        "passRate": "53.99%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-reduce-an-integer-to-0/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-reduce-an-integer-to-0/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> ，你可以执行下述操作 <strong>任意</strong> 次：</p>\n\n<ul>\n\t<li><code>n</code> 加上或减去 <code>2</code> 的某个 <strong>幂</strong></li>\n</ul>\n\n<p>返回使 <code>n</code> 等于 <code>0</code> 需要执行的 <strong>最少</strong> 操作数。</p>\n\n<p>如果 <code>x == 2<sup>i</sup></code> 且其中 <code>i &gt;= 0</code> ，则数字 <code>x</code> 是 <code>2</code> 的幂。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 39\n<strong>输出：</strong>3\n<strong>解释：</strong>我们可以执行下述操作：\n- n 加上 2<sup>0</sup> = 1 ，得到 n = 40 。\n- n 减去 2<sup>3</sup> = 8 ，得到 n = 32 。\n- n 减去 2<sup>5</sup> = 32 ，得到 n = 0 。\n可以证明使 n 等于 0 需要执行的最少操作数是 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 54\n<strong>输出：</strong>3\n<strong>解释：</strong>我们可以执行下述操作：\n- n 加上 2<sup>1</sup> = 2 ，得到 n = 56 。\n- n 加上 2<sup>3</sup> = 8 ，得到 n = 64 。\n- n 减去 2<sup>6</sup> = 64 ，得到 n = 0 。\n使 n 等于 0 需要执行的最少操作数是 3 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2572.无平方子集计数",
        "hardRate": "MEDIUM",
        "passRate": "29.82%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-square-free-subsets/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-square-free-subsets/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>nums</code> 。</p>\n\n<p>如果数组 <code>nums</code> 的子集中的元素乘积是一个 <strong>无平方因子数</strong> ，则认为该子集是一个 <strong>无平方</strong> 子集。</p>\n\n<p><strong>无平方因子数</strong> 是无法被除 <code>1</code> 之外任何平方数整除的数字。</p>\n\n<p>返回数组 <code>nums</code> 中 <strong>无平方</strong> 且 <strong>非空</strong> 的子集数目。因为答案可能很大，返回对 <code>10<sup>9</sup> + 7</code> 取余的结果。</p>\n\n<p><code>nums</code> 的 <strong>非空子集</strong> 是可以由删除 <code>nums</code> 中一些元素（可以不删除，但不能全部删除）得到的一个数组。如果构成两个子集时选择删除的下标不同，则认为这两个子集不同。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,4,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>示例中有 3 个无平方子集：\n- 由第 0 个元素 [3] 组成的子集。其元素的乘积是 3 ，这是一个无平方因子数。\n- 由第 3 个元素 [5] 组成的子集。其元素的乘积是 5 ，这是一个无平方因子数。\n- 由第 0 个和第 3 个元素 [3,5] 组成的子集。其元素的乘积是 15 ，这是一个无平方因子数。\n可以证明给定数组中不存在超过 3 个无平方子集。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1]\n<strong>输出：</strong>1\n<strong>解释：</strong>示例中有 1 个无平方子集：\n- 由第 0 个元素 [1] 组成的子集。其元素的乘积是 1 ，这是一个无平方因子数。\n可以证明给定数组中不存在超过 1 个无平方子集。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length&nbsp;&lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 30</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2573.找出对应 LCP 矩阵的字符串",
        "hardRate": "HARD",
        "passRate": "35.41%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-string-with-lcp/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-string-with-lcp/solution",
        "problemsDesc": "<p>对任一由 <code>n</code> 个小写英文字母组成的字符串 <code>word</code> ，我们可以定义一个 <code>n x n</code> 的矩阵，并满足：</p>\n\n<ul>\n\t<li><code>lcp[i][j]</code> 等于子字符串&nbsp;<code>word[i,...,n-1]</code> 和 <code>word[j,...,n-1]</code> 之间的最长公共前缀的长度。</li>\n</ul>\n\n<p>给你一个 <code>n x n</code> 的矩阵 <code>lcp</code> 。返回与 <code>lcp</code> 对应的、按字典序最小的字符串&nbsp;<code>word</code> 。如果不存在这样的字符串，则返回空字符串。</p>\n\n<p>对于长度相同的两个字符串 <code>a</code> 和 <code>b</code> ，如果在 <code>a</code> 和 <code>b</code> 不同的第一个位置，字符串 <code>a</code> 的字母在字母表中出现的顺序先于 <code>b</code> 中的对应字母，则认为字符串 <code>a</code> 按字典序比字符串 <code>b</code> 小。例如，<code>\"aabd\"</code> 在字典上小于 <code>\"aaca\"</code> ，因为二者不同的第一位置是第三个字母，而&nbsp;<code>'b'</code> 先于 <code>'c'</code> 出现。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\n<strong>输出：</strong>\"abab\"\n<strong>解释：</strong>lcp 对应由两个交替字母组成的任意 4 字母字符串，字典序最小的是 \"abab\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\n<strong>输出：</strong>\"aaaa\"\n<strong>解释：</strong>lcp 对应只有一个不同字母的任意 4 字母字符串，字典序最小的是 \"aaaa\" 。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>lcp[3][3] 无法等于 3 ，因为 word[3,...,3] 仅由单个字母组成；因此，不存在答案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n ==&nbsp;</code><code>lcp.length == </code><code>lcp[i].length</code>&nbsp;<code>&lt;= 1000</code></li>\n\t<li><code><font face=\"monospace\">0 &lt;= lcp[i][j] &lt;= n</font></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2574.左右元素和的差值",
        "hardRate": "EASY",
        "passRate": "84.98%",
        "problemsUrl": "https://leetcode.cn/problems/left-and-right-sum-differences/",
        "solutionsUrl": "https://leetcode.cn/problems/left-and-right-sum-differences/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，请你找出一个下标从 <strong>0</strong> 开始的整数数组 <code>answer</code> ，其中：</p>\n\n<ul>\n\t<li><code>answer.length == nums.length</code></li>\n\t<li><code>answer[i] = |leftSum[i] - rightSum[i]|</code></li>\n</ul>\n\n<p>其中：</p>\n\n<ul>\n\t<li><code>leftSum[i]</code> 是数组 <code>nums</code> 中下标 <code>i</code> 左侧元素之和。如果不存在对应的元素，<code>leftSum[i] = 0</code> 。</li>\n\t<li><code>rightSum[i]</code> 是数组 <code>nums</code> 中下标 <code>i</code> 右侧元素之和。如果不存在对应的元素，<code>rightSum[i] = 0</code> 。</li>\n</ul>\n\n<p>返回数组 <code>answer</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [10,4,8,3]\n<strong>输出：</strong>[15,1,11,22]\n<strong>解释：</strong>数组 leftSum 为 [0,10,14,22] 且数组 rightSum 为 [15,11,3,0] 。\n数组 answer 为 [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] = [15,1,11,22] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1]\n<strong>输出：</strong>[0]\n<strong>解释：</strong>数组 leftSum 为 [0] 且数组 rightSum 为 [0] 。\n数组 answer 为 [|0 - 0|] = [0] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2575.找出字符串的可整除数组",
        "hardRate": "MEDIUM",
        "passRate": "32.84%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>word</code> ，长度为 <code>n</code> ，由从 <code>0</code> 到 <code>9</code> 的数字组成。另给你一个正整数 <code>m</code> 。</p>\n\n<p><code>word</code> 的 <strong>可整除数组</strong> <code>div</code>&nbsp; 是一个长度为 <code>n</code> 的整数数组，并满足：</p>\n\n<ul>\n\t<li>如果 <code>word[0,...,i]</code> 所表示的 <strong>数值</strong> 能被 <code>m</code> 整除，<code>div[i] = 1</code></li>\n\t<li>否则，<code>div[i] = 0</code></li>\n</ul>\n\n<p>返回<em> </em><code>word</code> 的可整除数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"998244353\", m = 3\n<strong>输出：</strong>[1,1,0,0,0,1,1,0,0]\n<strong>解释：</strong>仅有 4 个前缀可以被 3 整除：\"9\"、\"99\"、\"998244\" 和 \"9982443\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"1010\", m = 10\n<strong>输出：</strong>[0,1,0,1]\n<strong>解释：</strong>仅有 2 个前缀可以被 10 整除：\"10\" 和 \"1010\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>word.length == n</code></li>\n\t<li><code>word</code> 由数字 <code>0</code> 到 <code>9</code> 组成</li>\n\t<li><code>1 &lt;= m &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2576.求出最多标记下标",
        "hardRate": "MEDIUM",
        "passRate": "36.89%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>一开始，所有下标都没有被标记。你可以执行以下操作任意次：</p>\n\n<ul>\n\t<li>选择两个 <strong>互不相同且未标记</strong>&nbsp;的下标&nbsp;<code>i</code> 和&nbsp;<code>j</code>&nbsp;，满足&nbsp;<code>2 * nums[i] &lt;= nums[j]</code>&nbsp;，标记下标&nbsp;<code>i</code> 和&nbsp;<code>j</code>&nbsp;。</li>\n</ul>\n\n<p>请你执行上述操作任意次，返回<em>&nbsp;</em><code>nums</code>&nbsp;中最多可以标记的下标数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,5,2,4]\n<b>输出：</b>2\n<strong>解释：</strong>第一次操作中，选择 i = 2 和 j = 1 ，操作可以执行的原因是 2 * nums[2] &lt;= nums[1] ，标记下标 2 和 1 。\n没有其他更多可执行的操作，所以答案为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [9,2,5,4]\n<b>输出：</b>4\n<strong>解释：</strong>第一次操作中，选择 i = 3 和 j = 0 ，操作可以执行的原因是 2 * nums[3] &lt;= nums[0] ，标记下标 3 和 0 。\n第二次操作中，选择 i = 1 和 j = 2 ，操作可以执行的原因是 2 * nums[1] &lt;= nums[2] ，标记下标 1 和 2 。\n没有其他更多可执行的操作，所以答案为 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [7,6,8]\n<b>输出：</b>0\n<strong>解释：</strong>没有任何可以执行的操作，所以答案为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2577.在网格图中访问一个格子的最少时间",
        "hardRate": "HARD",
        "passRate": "39.47%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的矩阵&nbsp;<code>grid</code>&nbsp;，每个元素都为 <strong>非负</strong>&nbsp;整数，其中&nbsp;<code>grid[row][col]</code>&nbsp;表示可以访问格子&nbsp;<code>(row, col)</code>&nbsp;的&nbsp;<strong>最早</strong>&nbsp;时间。也就是说当你访问格子&nbsp;<code>(row, col)</code>&nbsp;时，最少已经经过的时间为&nbsp;<code>grid[row][col]</code>&nbsp;。</p>\n\n<p>你从 <strong>最左上角</strong>&nbsp;出发，出发时刻为 <code>0</code>&nbsp;，你必须一直移动到上下左右相邻四个格子中的 <strong>任意</strong>&nbsp;一个格子（即不能停留在格子上）。每次移动都需要花费 1 单位时间。</p>\n\n<p>请你返回 <strong>最早</strong>&nbsp;到达右下角格子的时间，如果你无法到达右下角的格子，请你返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-8.png\" /></p>\n\n<pre>\n<b>输入：</b>grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]\n<b>输出：</b>7\n<b>解释：</b>一条可行的路径为：\n- 时刻 t = 0 ，我们在格子 (0,0) 。\n- 时刻 t = 1 ，我们移动到格子 (0,1) ，可以移动的原因是 grid[0][1] &lt;= 1 。\n- 时刻 t = 2 ，我们移动到格子 (1,1) ，可以移动的原因是 grid[1][1] &lt;= 2 。\n- 时刻 t = 3 ，我们移动到格子 (1,2) ，可以移动的原因是 grid[1][2] &lt;= 3 。\n- 时刻 t = 4 ，我们移动到格子 (1,1) ，可以移动的原因是 grid[1][1] &lt;= 4 。\n- 时刻 t = 5 ，我们移动到格子 (1,2) ，可以移动的原因是 grid[1][2] &lt;= 5 。\n- 时刻 t = 6 ，我们移动到格子 (1,3) ，可以移动的原因是 grid[1][3] &lt;= 6 。\n- 时刻 t = 7 ，我们移动到格子 (2,3) ，可以移动的原因是 grid[2][3] &lt;= 7 。\n最终到达时刻为 7 。这是最早可以到达的时间。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-9.png\" style=\"width: 151px; height: 151px;\" /></p>\n\n<pre>\n<b>输入：</b>grid = [[0,2,4],[3,2,1],[1,0,4]]\n<b>输出：</b>-1\n<b>解释：</b>没法从左上角按题目规定走到右下角。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>grid[0][0] == 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2578.最小和分割",
        "hardRate": "EASY",
        "passRate": "76.38%",
        "problemsUrl": "https://leetcode.cn/problems/split-with-minimum-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/split-with-minimum-sum/solution",
        "problemsDesc": "<p>给你一个正整数&nbsp;<code>num</code>&nbsp;，请你将它分割成两个非负整数&nbsp;<code>num1</code> 和&nbsp;<code>num2</code>&nbsp;，满足：</p>\n\n<ul>\n\t<li><code>num1</code> 和&nbsp;<code>num2</code>&nbsp;直接连起来，得到&nbsp;<code>num</code>&nbsp;各数位的一个排列。\n\n\t<ul>\n\t\t<li>换句话说，<code>num1</code> 和&nbsp;<code>num2</code>&nbsp;中所有数字出现的次数之和等于&nbsp;<code>num</code>&nbsp;中所有数字出现的次数。</li>\n\t</ul>\n\t</li>\n\t<li><code>num1</code> 和&nbsp;<code>num2</code>&nbsp;可以包含前导 0 。</li>\n</ul>\n\n<p>请你返回&nbsp;<code>num1</code> 和 <code>num2</code>&nbsp;可以得到的和的 <strong>最小</strong> 值。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><code>num</code>&nbsp;保证没有前导 0 。</li>\n\t<li><code>num1</code> 和&nbsp;<code>num2</code>&nbsp;中数位顺序可以与&nbsp;<code>num</code>&nbsp;中数位顺序不同。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>num = 4325\n<b>输出：</b>59\n<b>解释：</b>我们可以将 4325 分割成 <code>num1 </code>= 24 和 num2<code> = </code>35 ，和为 59 ，59 是最小和。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>num = 687\n<b>输出：</b>75\n<b>解释：</b>我们可以将 687 分割成 <code>num1</code> = 68 和 <code>num2 </code>= 7 ，和为最优值 75 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>10 &lt;= num &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2579.统计染色格子数",
        "hardRate": "MEDIUM",
        "passRate": "66.38%",
        "problemsUrl": "https://leetcode.cn/problems/count-total-number-of-colored-cells/",
        "solutionsUrl": "https://leetcode.cn/problems/count-total-number-of-colored-cells/solution",
        "problemsDesc": "<p>有一个无穷大的二维网格图，一开始所有格子都未染色。给你一个正整数&nbsp;<code>n</code>&nbsp;，表示你需要执行以下步骤&nbsp;<code>n</code>&nbsp;分钟：</p>\n\n<ul>\n\t<li>第一分钟，将 <strong>任一</strong> 格子染成蓝色。</li>\n\t<li>之后的每一分钟，将与蓝色格子相邻的 <strong>所有</strong> 未染色格子染成蓝色。</li>\n</ul>\n\n<p>下图分别是 1、2、3 分钟后的网格图。</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/10/example-copy-2.png\" style=\"width: 500px; height: 279px;\">\n<p>请你返回 <code>n</code>&nbsp;分钟之后 <strong>被染色的格子&nbsp;</strong>数目。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre><b>输入：</b>n = 1\n<b>输出：</b>1\n<b>解释：</b>1 分钟后，只有 1 个蓝色的格子，所以返回 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 2\n<b>输出：</b>5\n<b>解释：</b>2 分钟后，有 4 个在边缘的蓝色格子和 1 个在中间的蓝色格子，所以返回 5 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2580.统计将重叠区间合并成组的方案数",
        "hardRate": "MEDIUM",
        "passRate": "35.48%",
        "problemsUrl": "https://leetcode.cn/problems/count-ways-to-group-overlapping-ranges/",
        "solutionsUrl": "https://leetcode.cn/problems/count-ways-to-group-overlapping-ranges/solution",
        "problemsDesc": "<p>给你一个二维整数数组&nbsp;<code>ranges</code>&nbsp;，其中&nbsp;<code>ranges[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>&nbsp;表示&nbsp;<code>start<sub>i</sub></code>&nbsp;到&nbsp;<code>end<sub>i</sub></code>&nbsp;之间（包括二者）的所有整数都包含在第&nbsp;<code>i</code>&nbsp;个区间中。</p>\n\n<p>你需要将&nbsp;<code>ranges</code>&nbsp;分成 <strong>两个</strong>&nbsp;组（可以为空），满足：</p>\n\n<ul>\n\t<li>每个区间只属于一个组。</li>\n\t<li>两个有 <strong>交集</strong>&nbsp;的区间必须在 <strong>同一个&nbsp;</strong>组内。</li>\n</ul>\n\n<p>如果两个区间有至少 <strong>一个</strong>&nbsp;公共整数，那么这两个区间是 <b>有交集</b>&nbsp;的。</p>\n\n<ul>\n\t<li>比方说，区间&nbsp;<code>[1, 3]</code> 和&nbsp;<code>[2, 5]</code>&nbsp;有交集，因为&nbsp;<code>2</code>&nbsp;和&nbsp;<code>3</code>&nbsp;在两个区间中都被包含。</li>\n</ul>\n\n<p>请你返回将 <code>ranges</code>&nbsp;划分成两个组的 <strong>总方案数</strong>&nbsp;。由于答案可能很大，将它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>ranges = [[6,10],[5,15]]\n<b>输出：</b>2\n<b>解释：</b>\n两个区间有交集，所以它们必须在同一个组内。\n所以有两种方案：\n- 将两个区间都放在第 1 个组中。\n- 将两个区间都放在第 2 个组中。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>ranges = [[1,3],[10,20],[2,5],[4,8]]\n<b>输出：</b>4\n<b>解释：</b>\n区间 [1,3] 和 [2,5] 有交集，所以它们必须在同一个组中。\n同理，区间 [2,5] 和 [4,8] 也有交集，所以它们也必须在同一个组中。\n所以总共有 4 种分组方案：\n- 所有区间都在第 1 组。\n- 所有区间都在第 2 组。\n- 区间 [1,3] ，[2,5] 和 [4,8] 在第 1 个组中，[10,20] 在第 2 个组中。\n- 区间 [1,3] ，[2,5] 和 [4,8] 在第 2 个组中，[10,20] 在第 1 个组中。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= ranges.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>ranges[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2581.统计可能的树根数目",
        "hardRate": "HARD",
        "passRate": "57.75%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-possible-root-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-possible-root-nodes/solution",
        "problemsDesc": "<p>Alice 有一棵 <code>n</code> 个节点的树，节点编号为 <code>0</code> 到 <code>n - 1</code> 。树用一个长度为 <code>n - 1</code> 的二维整数数组 <code>edges</code> 表示，其中 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> ，表示树中节点 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间有一条边。</p>\n\n<p>Alice 想要 Bob 找到这棵树的根。她允许 Bob 对这棵树进行若干次 <strong>猜测</strong> 。每一次猜测，Bob 做如下事情：</p>\n\n<ul>\n\t<li>选择两个 <strong>不相等</strong>&nbsp;的整数&nbsp;<code>u</code> 和&nbsp;<code>v</code>&nbsp;，且树中必须存在边&nbsp;<code>[u, v]</code>&nbsp;。</li>\n\t<li>Bob 猜测树中&nbsp;<code>u</code>&nbsp;是&nbsp;<code>v</code>&nbsp;的 <strong>父节点</strong>&nbsp;。</li>\n</ul>\n\n<p>Bob 的猜测用二维整数数组&nbsp;<code>guesses</code> 表示，其中&nbsp;<code>guesses[j] = [u<sub>j</sub>, v<sub>j</sub>]</code>&nbsp;表示 Bob 猜&nbsp;<code>u<sub>j</sub></code> 是&nbsp;<code>v<sub>j</sub></code>&nbsp;的父节点。</p>\n\n<p>Alice 非常懒，她不想逐个回答&nbsp;Bob 的猜测，只告诉 Bob 这些猜测里面 <strong>至少</strong>&nbsp;有&nbsp;<code>k</code>&nbsp;个猜测的结果为&nbsp;<code>true</code>&nbsp;。</p>\n\n<p>给你二维整数数组 <code>edges</code>&nbsp;，Bob 的所有猜测和整数&nbsp;<code>k</code>&nbsp;，请你返回可能成为树根的&nbsp;<strong>节点数目</strong>&nbsp;。如果没有这样的树，则返回 <code>0</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/19/ex-1.png\" style=\"width: 727px; height: 250px;\" /></p>\n\n<pre>\n<b>输入：</b>edges = [[0,1],[1,2],[1,3],[4,2]], guesses = [[1,3],[0,1],[1,0],[2,4]], k = 3\n<b>输出：</b>3\n<b>解释：</b>\n根为节点 0 ，正确的猜测为 [1,3], [0,1], [2,4]\n根为节点 1 ，正确的猜测为 [1,3], [1,0], [2,4]\n根为节点 2 ，正确的猜测为 [1,3], [1,0], [2,4]\n根为节点 3 ，正确的猜测为 [1,0], [2,4]\n根为节点 4 ，正确的猜测为 [1,3], [1,0]\n节点 0 ，1 或 2 为根时，可以得到 3 个正确的猜测。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/19/ex-2.png\" style=\"width: 600px; height: 303px;\" /></p>\n\n<pre>\n<b>输入：</b>edges = [[0,1],[1,2],[2,3],[3,4]], guesses = [[1,0],[3,4],[2,1],[3,2]], k = 1\n<b>输出：</b>5\n<b>解释：</b>\n根为节点 0 ，正确的猜测为 [3,4]\n根为节点 1 ，正确的猜测为 [1,0], [3,4]\n根为节点 2 ，正确的猜测为 [1,0], [2,1], [3,4]\n根为节点 3 ，正确的猜测为 [1,0], [2,1], [3,2], [3,4]\n根为节点 4 ，正确的猜测为 [1,0], [2,1], [3,2]\n任何节点为根，都至少有 1 个正确的猜测。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= guesses.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub>, u<sub>j</sub>, v<sub>j</sub> &lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>u<sub>j</sub> != v<sub>j</sub></code></li>\n\t<li><code>edges</code>&nbsp;表示一棵有效的树。</li>\n\t<li><code>guesses[j]</code>&nbsp;是树中的一条边。</li>\n\t<li><code>guesses</code>&nbsp;是唯一的。</li>\n\t<li><code>0 &lt;= k &lt;= guesses.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2582.递枕头",
        "hardRate": "EASY",
        "passRate": "55.91%",
        "problemsUrl": "https://leetcode.cn/problems/pass-the-pillow/",
        "solutionsUrl": "https://leetcode.cn/problems/pass-the-pillow/solution",
        "problemsDesc": "<p><code>n</code> 个人站成一排，按从 <code>1</code> 到 <code>n</code> 编号。</p>\n\n<p>最初，排在队首的第一个人拿着一个枕头。每秒钟，拿着枕头的人会将枕头传递给队伍中的下一个人。一旦枕头到达队首或队尾，传递方向就会改变，队伍会继续沿相反方向传递枕头。</p>\n\n<ul>\n\t<li>例如，当枕头到达第 <code>n</code> 个人时，TA 会将枕头传递给第 <code>n - 1</code> 个人，然后传递给第 <code>n - 2</code> 个人，依此类推。</li>\n</ul>\n\n<p>给你两个正整数 <code>n</code> 和 <code>time</code> ，返回 <code>time</code> 秒后拿着枕头的人的编号。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, time = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>队伍中枕头的传递情况为：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 3 -&gt; 2 。\n5 秒后，枕头传递到第 2 个人手中。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, time = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>队伍中枕头的传递情况为：1 -&gt; 2 -&gt; 3 。\n2 秒后，枕头传递到第 3 个人手中。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= time &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2583.二叉树中的第 K 大层和",
        "hardRate": "MEDIUM",
        "passRate": "43.95%",
        "problemsUrl": "https://leetcode.cn/problems/kth-largest-sum-in-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-largest-sum-in-a-binary-tree/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点 <code>root</code> 和一个正整数 <code>k</code> 。</p>\n\n<p>树中的 <strong>层和</strong> 是指 <strong>同一层</strong> 上节点值的总和。</p>\n\n<p>返回树中第 <code>k</code> 大的层和（不一定不同）。如果树少于 <code>k</code> 层，则返回 <code>-1</code> 。</p>\n\n<p><strong>注意</strong>，如果两个节点与根节点的距离相同，则认为它们在同一层。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/14/binaryytreeedrawio-2.png\" style=\"width: 301px; height: 284px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,8,9,2,1,3,7,4,6], k = 2\n<strong>输出：</strong>13\n<strong>解释：</strong>树中每一层的层和分别是：\n- Level 1: 5\n- Level 2: 8 + 9 = 17\n- Level 3: 2 + 1 + 3 + 7 = 13\n- Level 4: 4 + 6 = 10\n第 2 大的层和等于 13 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/14/treedrawio-3.png\" style=\"width: 181px; height: 181px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,null,3], k = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>最大的层和是 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数为 <code>n</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2584.分割数组使乘积互质",
        "hardRate": "HARD",
        "passRate": "25.40%",
        "problemsUrl": "https://leetcode.cn/problems/split-the-array-to-make-coprime-products/",
        "solutionsUrl": "https://leetcode.cn/problems/split-the-array-to-make-coprime-products/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，下标从 <strong>0</strong> 开始。</p>\n\n<p>如果在下标 <code>i</code> 处 <strong>分割</strong> 数组，其中 <code>0 &lt;= i &lt;= n - 2</code> ，使前 <code>i + 1</code> 个元素的乘积和剩余元素的乘积互质，则认为该分割 <strong>有效</strong> 。</p>\n\n<ul>\n\t<li>例如，如果 <code>nums = [2, 3, 3]</code> ，那么在下标 <code>i = 0</code> 处的分割有效，因为 <code>2</code> 和 <code>9</code> 互质，而在下标 <code>i = 1</code> 处的分割无效，因为 <code>6</code> 和 <code>3</code> 不互质。在下标 <code>i = 2</code> 处的分割也无效，因为 <code>i == n - 1</code> 。</li>\n</ul>\n\n<p>返回可以有效分割数组的最小下标 <code>i</code> ，如果不存在有效分割，则返回 <code>-1</code> 。</p>\n\n<p>当且仅当 <code>gcd(val1, val2) == 1</code> 成立时，<code>val1</code> 和 <code>val2</code> 这两个值才是互质的，其中 <code>gcd(val1, val2)</code> 表示 <code>val1</code> 和 <code>val2</code> 的最大公约数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/14/second.PNG\" style=\"width: 450px; height: 211px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,7,8,15,3,5]\n<strong>输出：</strong>2\n<strong>解释：</strong>上表展示了每个下标 i 处的前 i + 1 个元素的乘积、剩余元素的乘积和它们的最大公约数的值。\n唯一一个有效分割位于下标 2 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/14/capture.PNG\" style=\"width: 450px; height: 215px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,7,15,8,3,5]\n<strong>输出：</strong>-1\n<strong>解释：</strong>上表展示了每个下标 i 处的前 i + 1 个元素的乘积、剩余元素的乘积和它们的最大公约数的值。\n不存在有效分割。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2585.获得分数的方法数",
        "hardRate": "HARD",
        "passRate": "64.48%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-earn-points/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-earn-points/solution",
        "problemsDesc": "<p>考试中有 <code>n</code> 种类型的题目。给你一个整数 <code>target</code> 和一个下标从 <strong>0</strong> 开始的二维整数数组 <code>types</code> ，其中 <code>types[i] = [count<sub>i</sub>, marks<sub>i</sub>] </code>表示第 <code>i</code> 种类型的题目有 <code>count<sub>i</sub></code> 道，每道题目对应 <code>marks<sub>i</sub></code> 分。</p>\n\n<p>返回你在考试中恰好得到 <code>target</code> 分的方法数。由于答案可能很大，结果需要对 <code>10<sup>9</sup> +7</code> 取余。</p>\n\n<p><strong>注意</strong>，同类型题目无法区分。</p>\n\n<ul>\n\t<li>比如说，如果有 <code>3</code> 道同类型题目，那么解答第 <code>1</code> 和第 <code>2</code> 道题目与解答第 <code>1</code> 和第 <code>3</code> 道题目或者第 <code>2</code> 和第 <code>3</code> 道题目是相同的。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>target = 6, types = [[6,1],[3,2],[2,3]]\n<strong>输出：</strong>7\n<strong>解释：</strong>要获得 6 分，你可以选择以下七种方法之一：\n- 解决 6 道第 0 种类型的题目：1 + 1 + 1 + 1 + 1 + 1 = 6\n- 解决 4 道第 0 种类型的题目和 1 道第 1 种类型的题目：1 + 1 + 1 + 1 + 2 = 6\n- 解决 2 道第 0 种类型的题目和 2 道第 1 种类型的题目：1 + 1 + 2 + 2 = 6\n- 解决 3 道第 0 种类型的题目和 1 道第 2 种类型的题目：1 + 1 + 1 + 3 = 6\n- 解决 1 道第 0 种类型的题目、1 道第 1 种类型的题目和 1 道第 2 种类型的题目：1 + 2 + 3 = 6\n- 解决 3 道第 1 种类型的题目：2 + 2 + 2 = 6\n- 解决 2 道第 2 种类型的题目：3 + 3 = 6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>target = 5, types = [[50,1],[50,2],[50,5]]\n<strong>输出：</strong>4\n<strong>解释：</strong>要获得 5 分，你可以选择以下四种方法之一：\n- 解决 5 道第 0 种类型的题目：1 + 1 + 1 + 1 + 1 = 5\n- 解决 3 道第 0 种类型的题目和 1 道第 1 种类型的题目：1 + 1 + 1 + 2 = 5\n- 解决 1 道第 0 种类型的题目和 2 道第 1 种类型的题目：1 + 2 + 2 = 5\n- 解决 1 道第 2 种类型的题目：5\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>target = 18, types = [[6,1],[3,2],[2,3]]\n<strong>输出：</strong>1\n<strong>解释：</strong>只有回答所有题目才能获得 18 分。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target &lt;= 1000</code></li>\n\t<li><code>n == types.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>types[i].length == 2</code></li>\n\t<li><code>1 &lt;= count<sub>i</sub>, marks<sub>i</sub> &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2586.统计范围内的元音字符串数",
        "hardRate": "EASY",
        "passRate": "81.49%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-vowel-strings-in-range/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-vowel-strings-in-range/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串数组 <code>words</code> 和两个整数：<code>left</code> 和 <code>right</code> 。</p>\n\n<p>如果字符串以元音字母开头并以元音字母结尾，那么该字符串就是一个 <strong>元音字符串</strong> ，其中元音字母是 <code>'a'</code>、<code>'e'</code>、<code>'i'</code>、<code>'o'</code>、<code>'u'</code> 。</p>\n\n<p>返回<em> </em><code>words[i]</code> 是元音字符串的数目，其中<em> </em><code>i</code> 在闭区间 <code>[left, right]</code> 内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"are\",\"amy\",\"u\"], left = 0, right = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>\n- \"are\" 是一个元音字符串，因为它以 'a' 开头并以 'e' 结尾。\n- \"amy\" 不是元音字符串，因为它没有以元音字母结尾。\n- \"u\" 是一个元音字符串，因为它以 'u' 开头并以 'u' 结尾。\n在上述范围中的元音字符串数目为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"hey\",\"aeo\",\"mu\",\"ooo\",\"artro\"], left = 1, right = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>\n- \"aeo\" 是一个元音字符串，因为它以 'a' 开头并以 'o' 结尾。\n- \"mu\" 不是元音字符串，因为它没有以元音字母开头。\n- \"ooo\" 是一个元音字符串，因为它以 'o' 开头并以 'o' 结尾。\n- \"artro\" 是一个元音字符串，因为它以 'a' 开头并以 'o' 结尾。\n在上述范围中的元音字符串数目为 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>words[i]</code> 仅由小写英文字母组成</li>\n\t<li><code>0 &lt;= left &lt;= right &lt; words.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2587.重排数组以得到最大前缀分数",
        "hardRate": "MEDIUM",
        "passRate": "40.66%",
        "problemsUrl": "https://leetcode.cn/problems/rearrange-array-to-maximize-prefix-score/",
        "solutionsUrl": "https://leetcode.cn/problems/rearrange-array-to-maximize-prefix-score/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。你可以将 <code>nums</code> 中的元素按 <strong>任意顺序</strong> 重排（包括给定顺序）。</p>\n\n<p>令 <code>prefix</code> 为一个数组，它包含了 <code>nums</code> 重新排列后的前缀和。换句话说，<code>prefix[i]</code> 是 <code>nums</code> 重新排列后下标从 <code>0</code> 到 <code>i</code> 的元素之和。<code>nums</code> 的 <strong>分数</strong> 是 <code>prefix</code> 数组中正整数的个数。</p>\n\n<p>返回可以得到的最大分数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,-1,0,1,-3,3,-3]\n<strong>输出：</strong>6\n<strong>解释：</strong>数组重排为 nums = [2,3,1,-1,-3,0,-3] 。\nprefix = [2,5,6,5,2,2,-1] ，分数为 6 。\n可以证明 6 是能够得到的最大分数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [-2,-3,0]\n<strong>输出：</strong>0\n<strong>解释：</strong>不管怎么重排数组得到的分数都是 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>6</sup> &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2588.统计美丽子数组数目",
        "hardRate": "MEDIUM",
        "passRate": "41.98%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组<code>nums</code>&nbsp;。每次操作中，你可以：</p>\n\n<ul>\n\t<li>选择两个满足&nbsp;<code>0 &lt;= i, j &lt; nums.length</code>&nbsp;的不同下标&nbsp;<code>i</code>&nbsp;和&nbsp;<code>j</code>&nbsp;。</li>\n\t<li>选择一个非负整数&nbsp;<code>k</code>&nbsp;，满足 <code>nums[i]</code>&nbsp;和 <code>nums[j]</code>&nbsp;在二进制下的第 <code>k</code>&nbsp;位（下标编号从 <strong>0</strong>&nbsp;开始）是 <code>1</code>&nbsp;。</li>\n\t<li>将 <code>nums[i]</code>&nbsp;和 <code>nums[j]</code>&nbsp;都减去&nbsp;<code>2<sup>k</sup></code>&nbsp;。</li>\n</ul>\n\n<p>如果一个子数组内执行上述操作若干次后，该子数组可以变成一个全为 <code>0</code>&nbsp;的数组，那么我们称它是一个 <strong>美丽</strong>&nbsp;的子数组。</p>\n\n<p>请你返回数组 <code>nums</code>&nbsp;中 <strong>美丽子数组</strong>&nbsp;的数目。</p>\n\n<p>子数组是一个数组中一段连续 <strong>非空</strong>&nbsp;的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [4,3,1,2,4]\n<b>输出：</b>2\n<b>解释：</b>nums 中有 2 个美丽子数组：[4,<em><strong>3,1,2</strong></em>,4] 和 [<em><strong>4,3,1,2,4</strong></em>] 。\n- 按照下述步骤，我们可以将子数组 [3,1,2] 中所有元素变成 0 ：\n  - 选择 [<em><strong>3</strong></em>, 1, <em><strong>2</strong></em>] 和 k = 1 。将 2 个数字都减去 2<sup>1</sup> ，子数组变成 [1, 1, 0] 。\n  - 选择 [<em><strong>1</strong></em>, <em><strong>1</strong></em>, 0] 和 k = 0 。将 2 个数字都减去 2<sup>0</sup> ，子数组变成 [0, 0, 0] 。\n- 按照下述步骤，我们可以将子数组 [4,3,1,2,4] 中所有元素变成 0 ：\n  - 选择 [<em><strong>4</strong></em>, 3, 1, 2, <em><strong>4</strong></em>] 和 k = 2 。将 2 个数字都减去 2<sup>2</sup> ，子数组变成 [0, 3, 1, 2, 0] 。\n  - 选择 [0, <em><strong>3</strong></em>, <em><strong>1</strong></em>, 2, 0] 和 k = 0 。将 2 个数字都减去 2<sup>0</sup> ，子数组变成 [0, 2, 0, 2, 0] 。\n  - 选择 [0, <em><strong>2</strong></em>, 0, <em><strong>2</strong></em>, 0] 和 k = 1 。将 2 个数字都减去 2<sup>1</sup> ，子数组变成 [0, 0, 0, 0, 0] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,10,4]\n<b>输出：</b>0\n<b>解释：</b>nums 中没有任何美丽子数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2589.完成所有任务的最少时间",
        "hardRate": "HARD",
        "passRate": "42.67%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/solution",
        "problemsDesc": "<p>你有一台电脑，它可以 <strong>同时</strong>&nbsp;运行无数个任务。给你一个二维整数数组&nbsp;<code>tasks</code>&nbsp;，其中&nbsp;<code>tasks[i] = [start<sub>i</sub>, end<sub>i</sub>, duration<sub>i</sub>]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个任务需要在 <strong>闭区间</strong>&nbsp;时间段&nbsp;<code>[start<sub>i</sub>, end<sub>i</sub>]</code>&nbsp;内运行&nbsp;<code>duration<sub>i</sub></code>&nbsp;个整数时间点（但不需要连续）。</p>\n\n<p>当电脑需要运行任务时，你可以打开电脑，如果空闲时，你可以将电脑关闭。</p>\n\n<p>请你返回完成所有任务的情况下，电脑最少需要运行多少秒。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>tasks = [[2,3,1],[4,5,1],[1,5,2]]\n<b>输出：</b>2\n<b>解释：</b>\n- 第一个任务在闭区间 [2, 2] 运行。\n- 第二个任务在闭区间 [5, 5] 运行。\n- 第三个任务在闭区间 [2, 2] 和 [5, 5] 运行。\n电脑总共运行 2 个整数时间点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>tasks = [[1,3,2],[2,5,3],[5,6,2]]\n<b>输出：</b>4\n<b>解释：</b>\n- 第一个任务在闭区间 [2, 3] 运行\n- 第二个任务在闭区间 [2, 3] 和 [5, 5] 运行。\n- 第三个任务在闭区间 [5, 6] 运行。\n电脑总共运行 4 个整数时间点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tasks.length &lt;= 2000</code></li>\n\t<li><code>tasks[i].length == 3</code></li>\n\t<li><code>1 &lt;= start<sub>i</sub>, end<sub>i</sub> &lt;= 2000</code></li>\n\t<li><code>1 &lt;= duration<sub>i</sub> &lt;= end<sub>i</sub> - start<sub>i</sub> + 1 </code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2590.设计一个待办事项清单",
        "hardRate": "MEDIUM",
        "passRate": "55.78%",
        "problemsUrl": "https://leetcode.cn/problems/design-a-todo-list/",
        "solutionsUrl": "https://leetcode.cn/problems/design-a-todo-list/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2591.将钱分给最多的儿童",
        "hardRate": "EASY",
        "passRate": "20.76%",
        "problemsUrl": "https://leetcode.cn/problems/distribute-money-to-maximum-children/",
        "solutionsUrl": "https://leetcode.cn/problems/distribute-money-to-maximum-children/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>money</code>&nbsp;，表示你总共有的钱数（单位为美元）和另一个整数&nbsp;<code>children</code>&nbsp;，表示你要将钱分配给多少个儿童。</p>\n\n<p>你需要按照如下规则分配：</p>\n\n<ul>\n\t<li>所有的钱都必须被分配。</li>\n\t<li>每个儿童至少获得&nbsp;<code>1</code>&nbsp;美元。</li>\n\t<li>没有人获得 <code>4</code>&nbsp;美元。</li>\n</ul>\n\n<p>请你按照上述规则分配金钱，并返回 <strong>最多</strong>&nbsp;有多少个儿童获得 <strong>恰好</strong><em>&nbsp;</em><code>8</code>&nbsp;美元。如果没有任何分配方案，返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>money = 20, children = 3\n<b>输出：</b>1\n<b>解释：</b>\n最多获得 8 美元的儿童数为 1 。一种分配方案为：\n- 给第一个儿童分配 8 美元。\n- 给第二个儿童分配 9 美元。\n- 给第三个儿童分配 3 美元。\n没有分配方案能让获得 8 美元的儿童数超过 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>money = 16, children = 2\n<b>输出：</b>2\n<b>解释：</b>每个儿童都可以获得 8 美元。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= money &lt;= 200</code></li>\n\t<li><code>2 &lt;= children &lt;= 30</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2592.最大化数组的伟大值",
        "hardRate": "MEDIUM",
        "passRate": "57.69%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-greatness-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-greatness-of-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 0 开始的整数数组&nbsp;<code>nums</code>&nbsp;。你需要将&nbsp;<code>nums</code>&nbsp;重新排列成一个新的数组&nbsp;<code>perm</code>&nbsp;。</p>\n\n<p>定义 <code>nums</code>&nbsp;的 <strong>伟大值</strong>&nbsp;为满足&nbsp;<code>0 &lt;= i &lt; nums.length</code>&nbsp;且&nbsp;<code>perm[i] &gt; nums[i]</code>&nbsp;的下标数目。</p>\n\n<p>请你返回重新排列 <code>nums</code>&nbsp;后的 <strong>最大</strong>&nbsp;伟大值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,3,5,2,1,3,1]\n<b>输出：</b>4\n<b>解释：</b>一个最优安排方案为 perm = [2,5,1,3,3,1,1] 。\n在下标为 0, 1, 3 和 4 处，都有 perm[i] &gt; nums[i] 。因此我们返回 4 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4]\n<b>输出：</b>3\n<b>解释：</b>最优排列为 [2,3,4,1] 。\n在下标为 0, 1 和 2 处，都有 perm[i] &gt; nums[i] 。因此我们返回 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2593.标记所有元素后数组的分数",
        "hardRate": "MEDIUM",
        "passRate": "52.06%",
        "problemsUrl": "https://leetcode.cn/problems/find-score-of-an-array-after-marking-all-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/find-score-of-an-array-after-marking-all-elements/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>nums</code>&nbsp;，它包含若干正整数。</p>\n\n<p>一开始分数&nbsp;<code>score = 0</code>&nbsp;，请你按照下面算法求出最后分数：</p>\n\n<ul>\n\t<li>从数组中选择最小且没有被标记的整数。如果有相等元素，选择下标最小的一个。</li>\n\t<li>将选中的整数加到&nbsp;<code>score</code>&nbsp;中。</li>\n\t<li>标记 <strong>被选中元素</strong>，如果有相邻元素，则同时标记&nbsp;<strong>与它相邻的两个元素</strong>&nbsp;。</li>\n\t<li>重复此过程直到数组中所有元素都被标记。</li>\n</ul>\n\n<p>请你返回执行上述算法后最后的分数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,1,3,4,5,2]\n<b>输出：</b>7\n<b>解释：</b>我们按照如下步骤标记元素：\n- 1 是最小未标记元素，所以标记它和相邻两个元素：[<em><strong>2</strong></em>,<em><strong>1</strong></em>,<em><strong>3</strong></em>,4,5,2] 。\n- 2 是最小未标记元素，所以标记它和左边相邻元素：[<em><strong>2</strong></em>,<em><strong>1</strong></em>,<em><strong>3</strong></em>,4,<em><strong>5</strong></em>,<em><strong>2</strong></em>] 。\n- 4 是仅剩唯一未标记的元素，所以我们标记它：[<em><strong>2</strong></em>,<em><strong>1</strong></em>,<em><strong>3</strong></em>,<em><strong>4</strong></em>,<em><strong>5</strong></em>,<em><strong>2</strong></em>] 。\n总得分为 1 + 2 + 4 = 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,3,5,1,3,2]\n<b>输出：</b>5\n<b>解释：</b>我们按照如下步骤标记元素：\n- 1 是最小未标记元素，所以标记它和相邻两个元素：[2,3,<em><strong>5</strong></em>,<em><strong>1</strong></em>,<em><strong>3</strong></em>,2] 。\n- 2 是最小未标记元素，由于有两个 2 ，我们选择最左边的一个 2 ，也就是下标为 0 处的 2 ，以及它右边相邻的元素：[<em><strong>2</strong></em>,<em><strong>3</strong></em>,<em><strong>5</strong></em>,<em><strong>1</strong></em>,<em><strong>3</strong></em>,2] 。\n- 2 是仅剩唯一未标记的元素，所以我们标记它：[<em><strong>2</strong></em>,<em><strong>3</strong></em>,<em><strong>5</strong></em>,<em><strong>1</strong></em>,<em><strong>3</strong></em>,<em><strong>2</strong></em>] 。\n总得分为 1 + 2 + 2 = 5 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2594.修车的最少时间",
        "hardRate": "MEDIUM",
        "passRate": "45.49%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-repair-cars/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-repair-cars/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>ranks</code>&nbsp;，表示一些机械工的 <strong>能力值</strong>&nbsp;。<code>ranks<sub>i</sub></code> 是第 <code>i</code> 位机械工的能力值。能力值为&nbsp;<code>r</code>&nbsp;的机械工可以在&nbsp;<code>r * n<sup>2</sup></code>&nbsp;分钟内修好&nbsp;<code>n</code>&nbsp;辆车。</p>\n\n<p>同时给你一个整数&nbsp;<code>cars</code>&nbsp;，表示总共需要修理的汽车数目。</p>\n\n<p>请你返回修理所有汽车&nbsp;<strong>最少</strong>&nbsp;需要多少时间。</p>\n\n<p><strong>注意：</strong>所有机械工可以同时修理汽车。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>ranks = [4,2,3,1], cars = 10\n<b>输出：</b>16\n<b>解释：</b>\n- 第一位机械工修 2 辆车，需要 4 * 2 * 2 = 16 分钟。\n- 第二位机械工修 2 辆车，需要 2 * 2 * 2 = 8 分钟。\n- 第三位机械工修 2 辆车，需要 3 * 2 * 2 = 12 分钟。\n- 第四位机械工修 4 辆车，需要 1 * 4 * 4 = 16 分钟。\n16 分钟是修理完所有车需要的最少时间。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>ranks = [5,1,8], cars = 6\n<b>输出：</b>16\n<b>解释：</b>\n- 第一位机械工修 1 辆车，需要 5 * 1 * 1 = 5 分钟。\n- 第二位机械工修 4 辆车，需要 1 * 4 * 4 = 16 分钟。\n- 第三位机械工修 1 辆车，需要 8 * 1 * 1 = 8 分钟。\n16 分钟时修理完所有车需要的最少时间。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= ranks.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= ranks[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= cars &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2595.奇偶位数",
        "hardRate": "EASY",
        "passRate": "72.78%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-even-and-odd-bits/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-even-and-odd-bits/solution",
        "problemsDesc": "<p>给你一个 <strong>正</strong> 整数 <code>n</code> 。</p>\n\n<p>用 <code>even</code> 表示在 <code>n</code> 的二进制形式（下标从 <strong>0</strong> 开始）中值为 <code>1</code> 的偶数下标的个数。</p>\n\n<p>用 <code>odd</code> 表示在 <code>n</code> 的二进制形式（下标从 <strong>0</strong> 开始）中值为 <code>1</code> 的奇数下标的个数。</p>\n\n<p>返回整数数组<em> </em><code>answer</code><em> </em>，其中<em> </em><code>answer = [even, odd]</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 17\n<strong>输出：</strong>[2,0]\n<strong>解释：</strong>17 的二进制形式是 10001 。 \n下标 0 和 下标 4 对应的值为 1 。 \n共有 2 个偶数下标，0 个奇数下标。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>[0,1]\n<strong>解释：</strong>2 的二进制形式是 10 。 \n下标 1 对应的值为 1 。 \n共有 0 个偶数下标，1 个奇数下标。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2596.检查骑士巡视方案",
        "hardRate": "MEDIUM",
        "passRate": "52.47%",
        "problemsUrl": "https://leetcode.cn/problems/check-knight-tour-configuration/",
        "solutionsUrl": "https://leetcode.cn/problems/check-knight-tour-configuration/solution",
        "problemsDesc": "<p>骑士在一张 <code>n x n</code> 的棋盘上巡视。在有效的巡视方案中，骑士会从棋盘的 <strong>左上角</strong> 出发，并且访问棋盘上的每个格子 <strong>恰好一次</strong> 。</p>\n\n<p>给你一个 <code>n x n</code> 的整数矩阵 <code>grid</code> ，由范围 <code>[0, n * n - 1]</code> 内的不同整数组成，其中 <code>grid[row][col]</code> 表示单元格 <code>(row, col)</code> 是骑士访问的第 <code>grid[row][col]</code> 个单元格。骑士的行动是从下标 <strong>0</strong> 开始的。</p>\n\n<p>如果 <code>grid</code> 表示了骑士的有效巡视方案，返回 <code>true</code>；否则返回 <code>false</code>。</p>\n\n<p><strong>注意</strong>，骑士行动时可以垂直移动两个格子且水平移动一个格子，或水平移动两个格子且垂直移动一个格子。下图展示了骑士从某个格子出发可能的八种行动路线。<br>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/10/12/knight.png\" style=\"width: 300px; height: 300px;\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/28/yetgriddrawio-5.png\" style=\"width: 251px; height: 251px;\">\n<pre><strong>输入：</strong>grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\n<strong>输出：</strong>true\n<strong>解释：</strong>grid 如上图所示，可以证明这是一个有效的巡视方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/28/yetgriddrawio-6.png\" style=\"width: 151px; height: 151px;\">\n<pre><strong>输入：</strong>grid = [[0,3,6],[5,8,1],[2,7,4]]\n<strong>输出：</strong>false\n<strong>解释：</strong>grid 如上图所示，考虑到骑士第 7 次行动后的位置，第 8 次行动是无效的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>3 &lt;= n &lt;= 7</code></li>\n\t<li><code>0 &lt;= grid[row][col] &lt; n * n</code></li>\n\t<li><code>grid</code> 中的所有整数 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2597.美丽子集的数目",
        "hardRate": "MEDIUM",
        "passRate": "34.67%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-beautiful-subsets/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-beautiful-subsets/solution",
        "problemsDesc": "<p>给你一个由正整数组成的数组 <code>nums</code> 和一个 <strong>正</strong> 整数 <code>k</code> 。</p>\n\n<p>如果 <code>nums</code> 的子集中，任意两个整数的绝对差均不等于 <code>k</code> ，则认为该子数组是一个 <strong>美丽</strong> 子集。</p>\n\n<p>返回数组 <code>nums</code> 中 <strong>非空</strong> 且 <strong>美丽</strong> 的子集数目。</p>\n\n<p><code>nums</code> 的子集定义为：可以经由 <code>nums</code> 删除某些元素（也可能不删除）得到的一个数组。只有在删除元素时选择的索引不同的情况下，两个子集才会被视作是不同的子集。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,4,6], k = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>数组 nums 中的美丽子集有：[2], [4], [6], [2, 6] 。\n可以证明数组 [2,4,6] 中只存在 4 个美丽子集。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1], k = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>数组 nums 中的美丽数组有：[1] 。\n可以证明数组 [1] 中只存在 1 个美丽子集。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2598.执行操作后的最大 MEX",
        "hardRate": "MEDIUM",
        "passRate": "39.13%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-missing-non-negative-integer-after-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-missing-non-negative-integer-after-operations/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>value</code> 。</p>\n\n<p>在一步操作中，你可以对 <code>nums</code> 中的任一元素加上或减去 <code>value</code> 。</p>\n\n<ul>\n\t<li>例如，如果 <code>nums = [1,2,3]</code> 且 <code>value = 2</code> ，你可以选择 <code>nums[0]</code> 减去 <code>value</code> ，得到 <code>nums = [-1,2,3]</code> 。</li>\n</ul>\n\n<p>数组的 MEX (minimum excluded) 是指其中数组中缺失的最小非负整数。</p>\n\n<ul>\n\t<li>例如，<code>[-1,2,3]</code> 的 MEX 是 <code>0</code> ，而 <code>[1,0,3]</code> 的 MEX 是 <code>2</code> 。</li>\n</ul>\n\n<p>返回在执行上述操作 <strong>任意次</strong> 后，<code>nums</code><em> </em>的最大 MEX <em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,-10,7,13,6,8], value = 5\n<strong>输出：</strong>4\n<strong>解释：</strong>执行下述操作可以得到这一结果：\n- nums[1] 加上 value 两次，nums = [1,<em><strong>0</strong></em>,7,13,6,8]\n- nums[2] 减去 value 一次，nums = [1,0,<em><strong>2</strong></em>,13,6,8]\n- nums[3] 减去 value 两次，nums = [1,0,2,<em><strong>3</strong></em>,6,8]\nnums 的 MEX 是 4 。可以证明 4 是可以取到的最大 MEX 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,-10,7,13,6,8], value = 7\n<strong>输出：</strong>2\n<strong>解释：</strong>执行下述操作可以得到这一结果：\n- nums[2] 减去 value 一次，nums = [1,-10,<em><strong>0</strong></em>,13,6,8]\nnums 的 MEX 是 2 。可以证明 2 是可以取到的最大 MEX 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, value &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2599.使前缀和数组非负",
        "hardRate": "MEDIUM",
        "passRate": "55.38%",
        "problemsUrl": "https://leetcode.cn/problems/make-the-prefix-sum-non-negative/",
        "solutionsUrl": "https://leetcode.cn/problems/make-the-prefix-sum-non-negative/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2600.K 件物品的最大和",
        "hardRate": "EASY",
        "passRate": "65.87%",
        "problemsUrl": "https://leetcode.cn/problems/k-items-with-the-maximum-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/k-items-with-the-maximum-sum/solution",
        "problemsDesc": "<p>袋子中装有一些物品，每个物品上都标记着数字 <code>1</code> 、<code>0</code> 或 <code>-1</code> 。</p>\n\n<p>给你四个非负整数 <code>numOnes</code> 、<code>numZeros</code> 、<code>numNegOnes</code> 和 <code>k</code> 。</p>\n\n<p>袋子最初包含：</p>\n\n<ul>\n\t<li><code>numOnes</code> 件标记为 <code>1</code> 的物品。</li>\n\t<li><code>numZeroes</code> 件标记为 <code>0</code> 的物品。</li>\n\t<li><code>numNegOnes</code> 件标记为 <code>-1</code> 的物品。</li>\n</ul>\n\n<p>现计划从这些物品中恰好选出 <code>k</code> 件物品。返回所有可行方案中，物品上所标记数字之和的最大值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>numOnes = 3, numZeros = 2, numNegOnes = 0, k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>袋子中的物品分别标记为 {1, 1, 1, 0, 0} 。取 2 件标记为 1 的物品，得到的数字之和为 2 。\n可以证明 2 是所有可行方案中的最大值。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>numOnes = 3, numZeros = 2, numNegOnes = 0, k = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>袋子中的物品分别标记为 {1, 1, 1, 0, 0} 。取 3 件标记为 1 的物品，1 件标记为 0 的物品，得到的数字之和为 3 。\n可以证明 3 是所有可行方案中的最大值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= numOnes, numZeros, numNegOnes &lt;= 50</code></li>\n\t<li><code>0 &lt;= k &lt;= numOnes + numZeros + numNegOnes</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2601.质数减法运算",
        "hardRate": "MEDIUM",
        "passRate": "38.60%",
        "problemsUrl": "https://leetcode.cn/problems/prime-subtraction-operation/",
        "solutionsUrl": "https://leetcode.cn/problems/prime-subtraction-operation/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，数组长度为 <code>n</code> 。</p>\n\n<p>你可以执行无限次下述运算：</p>\n\n<ul>\n\t<li>选择一个之前未选过的下标 <code>i</code> ，并选择一个 <strong>严格小于</strong> <code>nums[i]</code> 的质数 <code>p</code> ，从 <code>nums[i]</code> 中减去 <code>p</code> 。</li>\n</ul>\n\n<p>如果你能通过上述运算使得 <code>nums</code> 成为严格递增数组，则返回 <code>true</code> ；否则返回 <code>false</code> 。</p>\n\n<p><strong>严格递增数组</strong> 中的每个元素都严格大于其前面的元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,9,6,10]\n<strong>输出：</strong>true\n<strong>解释：</strong>\n在第一次运算中：选择 i = 0 和 p = 3 ，然后从 nums[0] 减去 3 ，nums 变为 [1,9,6,10] 。\n在第二次运算中：选择 i = 1 和 p = 7 ，然后从 nums[1] 减去 7 ，nums 变为 [1,2,6,10] 。\n第二次运算后，nums 按严格递增顺序排序，因此答案为 true 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [6,8,11,12]\n<strong>输出：</strong>true\n<strong>解释：</strong>nums 从一开始就按严格递增顺序排序，因此不需要执行任何运算。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,8,3]\n<strong>输出：</strong>false\n<strong>解释：</strong>可以证明，执行运算无法使 nums 按严格递增顺序排序，因此答案是 false 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>nums.length == n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2602.使数组元素全部相等的最少操作次数",
        "hardRate": "MEDIUM",
        "passRate": "33.46%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solution",
        "problemsDesc": "<p>给你一个正整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>同时给你一个长度为 <code>m</code>&nbsp;的整数数组&nbsp;<code>queries</code>&nbsp;。第 <code>i</code>&nbsp;个查询中，你需要将 <code>nums</code>&nbsp;中所有元素变成&nbsp;<code>queries[i]</code>&nbsp;。你可以执行以下操作&nbsp;<strong>任意</strong>&nbsp;次：</p>\n\n<ul>\n\t<li>将数组里一个元素&nbsp;<strong>增大</strong>&nbsp;或者&nbsp;<strong>减小</strong>&nbsp;<code>1</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回一个长度为 <code>m</code>&nbsp;的数组<em>&nbsp;</em><code>answer</code>&nbsp;，其中<em>&nbsp;</em><code>answer[i]</code>是将&nbsp;<code>nums</code>&nbsp;中所有元素变成&nbsp;<code>queries[i]</code>&nbsp;的&nbsp;<strong>最少</strong>&nbsp;操作次数。</p>\n\n<p><strong>注意</strong>，每次查询后，数组变回最开始的值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [3,1,6,8], queries = [1,5]\n<b>输出：</b>[14,10]\n<b>解释：</b>第一个查询，我们可以执行以下操作：\n- 将 nums[0] 减小 2 次，nums = [1,1,6,8] 。\n- 将 nums[2] 减小 5 次，nums = [1,1,1,8] 。\n- 将 nums[3] 减小 7 次，nums = [1,1,1,1] 。\n第一个查询的总操作次数为 2 + 5 + 7 = 14 。\n第二个查询，我们可以执行以下操作：\n- 将 nums[0] 增大 2 次，nums = [5,1,6,8] 。\n- 将 nums[1] 增大 4 次，nums = [5,5,6,8] 。\n- 将 nums[2] 减小 1 次，nums = [5,5,5,8] 。\n- 将 nums[3] 减小 3 次，nums = [5,5,5,5] 。\n第二个查询的总操作次数为 2 + 4 + 1 + 3 = 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,9,6,3], queries = [10]\n<b>输出：</b>[20]\n<b>解释：</b>我们可以将数组中所有元素都增大到 10 ，总操作次数为 8 + 1 + 4 + 7 = 20 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>m == queries.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], queries[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2603.收集树中金币",
        "hardRate": "HARD",
        "passRate": "43.60%",
        "problemsUrl": "https://leetcode.cn/problems/collect-coins-in-a-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/collect-coins-in-a-tree/solution",
        "problemsDesc": "<p>给你一个 <code>n</code>&nbsp;个节点的无向无根树，节点编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。给你整数&nbsp;<code>n</code>&nbsp;和一个长度为 <code>n - 1</code>&nbsp;的二维整数数组 <code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示树中节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条边。再给你一个长度为 <code>n</code>&nbsp;的数组&nbsp;<code>coins</code>&nbsp;，其中&nbsp;<code>coins[i]</code> 可能为&nbsp;<code>0</code>&nbsp;也可能为&nbsp;<code>1</code>&nbsp;，<code>1</code>&nbsp;表示节点 <code>i</code>&nbsp;处有一个金币。</p>\n\n<p>一开始，你需要选择树中任意一个节点出发。你可以执行下述操作任意次：</p>\n\n<ul>\n\t<li>收集距离当前节点距离为 <code>2</code>&nbsp;以内的所有金币，或者</li>\n\t<li>移动到树中一个相邻节点。</li>\n</ul>\n\n<p>你需要收集树中所有的金币，并且回到出发节点，请你返回最少经过的边数。</p>\n\n<p>如果你多次经过一条边，每一次经过都会给答案加一。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/01/graph-2.png\" style=\"width: 522px; height: 522px;\"></p>\n\n<pre><b>输入：</b>coins = [1,0,0,0,0,1], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]\n<b>输出：</b>2\n<b>解释：</b>从节点 2 出发，收集节点 0 处的金币，移动到节点 3 ，收集节点 5 处的金币，然后移动回节点 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/02/graph-4.png\" style=\"width: 522px; height: 522px;\"></p>\n\n<pre><b>输入：</b>coins = [0,0,0,1,1,0,0,1], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]]\n<b>输出：</b>2\n<b>解释：</b>从节点 0 出发，收集节点 4 和 3 处的金币，移动到节点 2 处，收集节点 7 处的金币，移动回节点 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == coins.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= coins[i] &lt;= 1</code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>edges</code>&nbsp;表示一棵合法的树。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2604.吃掉所有谷子的最短时间",
        "hardRate": "HARD",
        "passRate": "36.96%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-eat-all-grains/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-eat-all-grains/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2605.从两个数字数组里生成最小数字",
        "hardRate": "EASY",
        "passRate": "62.94%",
        "problemsUrl": "https://leetcode.cn/problems/form-smallest-number-from-two-digit-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/form-smallest-number-from-two-digit-arrays/solution",
        "problemsDesc": "给你两个只包含 1 到 9 之间数字的数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;，每个数组中的元素 <strong>互不相同</strong>&nbsp;，请你返回 <strong>最小</strong> 的数字，两个数组都 <strong>至少</strong> 包含这个数字的某个数位。\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [4,1,3], nums2 = [5,7]\n<b>输出：</b>15\n<b>解释：</b>数字 15 的数位 1 在 nums1 中出现，数位 5 在 nums2 中出现。15 是我们能得到的最小数字。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [3,5,2,6], nums2 = [3,1,7]\n<b>输出：</b>3\n<b>解释：</b>数字 3 的数位 3 在两个数组中都出现了。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 9</code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 9</code></li>\n\t<li>每个数组中，元素 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2606.找到最大开销的子字符串",
        "hardRate": "MEDIUM",
        "passRate": "53.49%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-substring-with-maximum-cost/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-substring-with-maximum-cost/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，一个字符&nbsp;<strong>互不相同</strong>&nbsp;的字符串&nbsp;<code>chars</code>&nbsp;和一个长度与 <code>chars</code>&nbsp;相同的整数数组&nbsp;<code>vals</code>&nbsp;。</p>\n\n<p><strong>子字符串的开销</strong>&nbsp;是一个子字符串中所有字符对应价值之和。空字符串的开销是 <code>0</code>&nbsp;。</p>\n\n<p><strong>字符的价值</strong>&nbsp;定义如下：</p>\n\n<ul>\n\t<li>如果字符不在字符串&nbsp;<code>chars</code>&nbsp;中，那么它的价值是它在字母表中的位置（下标从 <strong>1</strong>&nbsp;开始）。\n\n\t<ul>\n\t\t<li>比方说，<code>'a'</code>&nbsp;的价值为&nbsp;<code>1</code>&nbsp;，<code>'b'</code>&nbsp;的价值为&nbsp;<code>2</code>&nbsp;，以此类推，<code>'z'</code>&nbsp;的价值为&nbsp;<code>26</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n\t<li>否则，如果这个字符在 <code>chars</code>&nbsp;中的位置为 <code>i</code>&nbsp;，那么它的价值就是&nbsp;<code>vals[i]</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回字符串 <code>s</code>&nbsp;的所有子字符串中的最大开销。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"adaa\", chars = \"d\", vals = [-1000]\n<b>输出：</b>2\n<b>解释：</b>字符 \"a\" 和 \"d\" 的价值分别为 1 和 -1000 。\n最大开销子字符串是 \"aa\" ，它的开销为 1 + 1 = 2 。\n2 是最大开销。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"abc\", chars = \"abc\", vals = [-1,-1,-1]\n<b>输出：</b>0\n<b>解释：</b>字符 \"a\" ，\"b\" 和 \"c\" 的价值分别为 -1 ，-1 和 -1 。\n最大开销子字符串是 \"\" ，它的开销为 0 。\n0 是最大开销。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n\t<li><code>1 &lt;= chars.length &lt;= 26</code></li>\n\t<li><code>chars</code>&nbsp;只包含小写英文字母，且 <strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>vals.length == chars.length</code></li>\n\t<li><code>-1000 &lt;= vals[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2607.使子数组元素和相等",
        "hardRate": "MEDIUM",
        "passRate": "38.69%",
        "problemsUrl": "https://leetcode.cn/problems/make-k-subarray-sums-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/make-k-subarray-sums-equal/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>arr</code> 和一个整数 <code>k</code> 。数组 <code>arr</code> 是一个循环数组。换句话说，数组中的最后一个元素的下一个元素是数组中的第一个元素，数组中第一个元素的前一个元素是数组中的最后一个元素。</p>\n\n<p>你可以执行下述运算任意次：</p>\n\n<ul>\n\t<li>选中 <code>arr</code> 中任意一个元素，并使其值加上 <code>1</code> 或减去 <code>1</code> 。</li>\n</ul>\n\n<p>执行运算使每个长度为 <code>k</code> 的 <strong>子数组</strong> 的元素总和都相等，返回所需要的最少运算次数。</p>\n\n<p><strong>子数组</strong> 是数组的一个连续部分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,4,1,3], k = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>在下标为 1 的元素那里执行一次运算，使其等于 3 。\n执行运算后，数组变为 [1,3,1,3] 。\n- 0 处起始的子数组为 [1, 3] ，元素总和为 4 \n- 1 处起始的子数组为 [3, 1] ，元素总和为 4 \n- 2 处起始的子数组为 [1, 3] ，元素总和为 4 \n- 3 处起始的子数组为 [3, 1] ，元素总和为 4 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,5,5,7], k = 3\n<strong>输出：</strong>5\n<strong>解释：</strong>在下标为 0 的元素那里执行三次运算，使其等于 5 。在下标为 3 的元素那里执行两次运算，使其等于 5 。\n执行运算后，数组变为 [5,5,5,5] 。\n- 0 处起始的子数组为 [5, 5, 5] ，元素总和为 15\n- 1 处起始的子数组为 [5, 5, 5] ，元素总和为 15\n- 2 处起始的子数组为 [5, 5, 5] ，元素总和为 15\n- 3 处起始的子数组为 [5, 5, 5] ，元素总和为 15\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2608.图中的最短环",
        "hardRate": "HARD",
        "passRate": "40.76%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-cycle-in-a-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-cycle-in-a-graph/solution",
        "problemsDesc": "<p>现有一个含 <code>n</code> 个顶点的 <strong>双向</strong> 图，每个顶点按从 <code>0</code> 到 <code>n - 1</code> 标记。图中的边由二维整数数组 <code>edges</code> 表示，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> 表示顶点 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code> 之间存在一条边。每对顶点最多通过一条边连接，并且不存在与自身相连的顶点。</p>\n\n<p>返回图中 <strong>最短</strong> 环的长度。如果不存在环，则返回 <code>-1</code> 。</p>\n\n<p><strong>环</strong> 是指以同一节点开始和结束，并且路径中的每条边仅使用一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/04/cropped.png\" style=\"width: 387px; height: 331px;\">\n<pre><strong>输入：</strong>n = 7, edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]\n<strong>输出：</strong>3\n<strong>解释：</strong>长度最小的循环是：0 -&gt; 1 -&gt; 2 -&gt; 0 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/04/croppedagin.png\" style=\"width: 307px; height: 307px;\">\n<pre><strong>输入：</strong>n = 4, edges = [[0,1],[0,2]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>图中不存在循环\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= 1000</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n\t<li>不存在重复的边</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2609.最长平衡子字符串",
        "hardRate": "EASY",
        "passRate": "49.19%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-longest-balanced-substring-of-a-binary-string/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-longest-balanced-substring-of-a-binary-string/solution",
        "problemsDesc": "<p>给你一个仅由 <code>0</code> 和 <code>1</code> 组成的二进制字符串 <code>s</code> 。<span style=\"\">&nbsp;</span><span style=\"\">&nbsp;</span></p>\n\n<p>如果子字符串中 <strong>所有的<span style=\"\"> </span></strong><code><span style=\"\">0</span></code><strong><span style=\"\"> </span>都在 </strong><code>1</code><strong> 之前</strong> 且其中 <code>0</code> 的数量等于 <code>1</code> 的数量，则认为 <code>s</code> 的这个子字符串是平衡子字符串。请注意，空子字符串也视作平衡子字符串。<span style=\"\">&nbsp;</span></p>\n\n<p>返回&nbsp;<span style=\"\"> </span><code>s</code> 中最长的平衡子字符串长度。</p>\n\n<p>子字符串是字符串中的一个连续字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"01000111\"\n<strong>输出：</strong>6\n<strong>解释：</strong>最长的平衡子字符串是 \"000111\" ，长度为 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"00111\"\n<strong>输出：</strong>4\n<strong>解释：</strong>最长的平衡子字符串是 \"0011\" ，长度为 <span style=\"\">&nbsp;</span>4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"111\"\n<strong>输出：</strong>0\n<strong>解释：</strong>除了空子字符串之外不存在其他平衡子字符串，所以答案为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 50</code></li>\n\t<li><code>'0' &lt;= s[i] &lt;= '1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2610.转换二维数组",
        "hardRate": "MEDIUM",
        "passRate": "85.12%",
        "problemsUrl": "https://leetcode.cn/problems/convert-an-array-into-a-2d-array-with-conditions/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-an-array-into-a-2d-array-with-conditions/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。请你创建一个满足以下条件的二维数组：</p>\n\n<ul>\n\t<li>二维数组应该 <strong>只</strong> 包含数组 <code>nums</code> 中的元素。</li>\n\t<li>二维数组中的每一行都包含 <strong>不同</strong> 的整数。</li>\n\t<li>二维数组的行数应尽可能 <strong>少</strong> 。</li>\n</ul>\n\n<p>返回结果数组。如果存在多种答案，则返回其中任何一种。</p>\n\n<p>请注意，二维数组的每一行上可以存在不同数量的元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3,4,1,2,3,1]\n<strong>输出：</strong>[[1,3,4,2],[1,3],[1]]\n<strong>解释：</strong>根据题目要求可以创建包含以下几行元素的二维数组：\n- 1,3,4,2\n- 1,3\n- 1\nnums 中的所有元素都有用到，并且每一行都由不同的整数组成，所以这是一个符合题目要求的答案。\n可以证明无法创建少于三行且符合题目要求的二维数组。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>[[4,3,2,1]]\n<strong>解释：</strong>nums 中的所有元素都不同，所以我们可以将其全部保存在二维数组中的第一行。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2611.老鼠和奶酪",
        "hardRate": "MEDIUM",
        "passRate": "58.65%",
        "problemsUrl": "https://leetcode.cn/problems/mice-and-cheese/",
        "solutionsUrl": "https://leetcode.cn/problems/mice-and-cheese/solution",
        "problemsDesc": "<p>有两只老鼠和&nbsp;<code>n</code>&nbsp;块不同类型的奶酪，每块奶酪都只能被其中一只老鼠吃掉。</p>\n\n<p>下标为 <code>i</code>&nbsp;处的奶酪被吃掉的得分为：</p>\n\n<ul>\n\t<li>如果第一只老鼠吃掉，则得分为&nbsp;<code>reward1[i]</code>&nbsp;。</li>\n\t<li>如果第二只老鼠吃掉，则得分为&nbsp;<code>reward2[i]</code>&nbsp;。</li>\n</ul>\n\n<p>给你一个正整数数组&nbsp;<code>reward1</code>&nbsp;，一个正整数数组&nbsp;<code>reward2</code>&nbsp;，和一个非负整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>请你返回第一只老鼠恰好吃掉 <code>k</code>&nbsp;块奶酪的情况下，<strong>最大</strong>&nbsp;得分为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2\n<b>输出：</b>15\n<b>解释：</b>这个例子中，第一只老鼠吃掉第 2&nbsp;和 3 块奶酪（下标从 0 开始），第二只老鼠吃掉第 0 和 1 块奶酪。\n总得分为 4 + 4 + 3 + 4 = 15 。\n15 是最高得分。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>reward1 = [1,1], reward2 = [1,1], k = 2\n<b>输出：</b>2\n<b>解释：</b>这个例子中，第一只老鼠吃掉第 0 和 1 块奶酪（下标从 0 开始），第二只老鼠不吃任何奶酪。\n总得分为 1 + 1 = 2 。\n2 是最高得分。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == reward1.length == reward2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= reward1[i],&nbsp;reward2[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2612.最少翻转操作数",
        "hardRate": "HARD",
        "passRate": "20.78%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-reverse-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-reverse-operations/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;和一个在范围 <code>[0, n - 1]</code>&nbsp;以内的整数&nbsp;<code>p</code>&nbsp;，它们表示一个长度为 <code>n</code> 且下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>arr</code>&nbsp;，数组中除了下标为&nbsp;<code>p</code>&nbsp;处是 <code>1</code>&nbsp;以外，其他所有数都是 <code>0</code>&nbsp;。</p>\n\n<p>同时给你一个整数数组&nbsp;<code>banned</code>&nbsp;，它包含数组中的一些位置。<code>banned</code>&nbsp;中第&nbsp;<strong>i</strong>&nbsp;个位置表示&nbsp;<code>arr[banned[i]] = 0</code>&nbsp;，题目保证&nbsp;<code>banned[i] != p</code>&nbsp;。</p>\n\n<p>你可以对 <code>arr</code>&nbsp;进行 <strong>若干次</strong>&nbsp;操作。一次操作中，你选择大小为 <code>k</code>&nbsp;的一个 <strong>子数组</strong>&nbsp;，并将它 <b>翻转</b>&nbsp;。在任何一次翻转操作后，你都需要确保 <code>arr</code>&nbsp;中唯一的 <code>1</code>&nbsp;不会到达任何 <code>banned</code>&nbsp;中的位置。换句话说，<code>arr[banned[i]]</code>&nbsp;始终&nbsp;<strong>保持</strong>&nbsp;<code>0</code>&nbsp;。</p>\n\n<p>请你返回一个数组&nbsp;<code>ans</code>&nbsp;，对于<em>&nbsp;</em><code>[0, n - 1]</code>&nbsp;之间的任意下标&nbsp;<code>i</code>&nbsp;，<code>ans[i]</code>&nbsp;是将&nbsp;<code>1</code>&nbsp;放到位置&nbsp;<code>i</code>&nbsp;处的&nbsp;<strong>最少</strong>&nbsp;翻转操作次数，如果无法放到位置&nbsp;<code>i</code>&nbsp;处，此数为&nbsp;<code>-1</code>&nbsp;。</p>\n\n<ul>\n\t<li><strong>子数组</strong>&nbsp;指的是一个数组里一段连续 <strong>非空</strong>&nbsp;的元素序列。</li>\n\t<li>对于所有的 <code>i</code>&nbsp;，<code>ans[i]</code>&nbsp;相互之间独立计算。</li>\n\t<li>将一个数组中的元素 <strong>翻转</strong> 指的是将数组中的值变成 <strong>相反顺序</strong>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 4, p = 0, banned = [1,2], k = 4\n<b>输出：</b>[0,-1,-1,1]\n<b>解释：</b><code>k = 4，所以只有一种可行的翻转操作，就是将整个数组翻转。一开始 </code>1<strong> </strong>在位置 0 处，所以将它翻转到位置 0 处需要的操作数为 0 。\n我们不能将 1 翻转到 banned 中的位置，所以位置 1 和 2 处的答案都是 -1 。\n通过一次翻转操作，可以将 1 放到位置 3 处，所以位置 3 的答案是 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5, p = 0, banned = [2,4], k = 3\n<b>输出：</b>[0,-1,-1,-1,-1]\n<b>解释：</b>这个例子中 1 一开始在位置 0 处，所以此下标的答案为 0 。\n翻转的子数组长度为 k = 3 ，1 此时在位置 0 处，所以我们可以翻转子数组 [0, 2]，但翻转后的下标 2 在 banned 中，所以不能执行此操作。\n由于 1 没法离开位置 0 ，所以其他位置的答案都是 -1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 4, p = 2, banned = [0,1,3], k = 1\n<b>输出：</b>[-1,-1,0,-1]\n<b>解释：</b>这个例子中，我们只能对长度为 1 的子数组执行翻转操作，所以 1 无法离开初始位置。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= p &lt;= n - 1</code></li>\n\t<li><code>0 &lt;= banned.length &lt;= n - 1</code></li>\n\t<li><code>0 &lt;= banned[i] &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= k &lt;= n&nbsp;</code></li>\n\t<li><code>banned[i] != p</code></li>\n\t<li><code>banned</code>&nbsp;中的值 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2613.美数对",
        "hardRate": "HARD",
        "passRate": "48.18%",
        "problemsUrl": "https://leetcode.cn/problems/beautiful-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/beautiful-pairs/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2614.对角线上的质数",
        "hardRate": "EASY",
        "passRate": "32.90%",
        "problemsUrl": "https://leetcode.cn/problems/prime-in-diagonal/",
        "solutionsUrl": "https://leetcode.cn/problems/prime-in-diagonal/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>nums</code> 。</p>\n\n<p>返回位于 <code>nums</code> 至少一条 <strong>对角线</strong> 上的最大 <strong>质数</strong> 。如果任一对角线上均不存在质数，返回<em> 0 。</em></p>\n\n<p>注意：</p>\n\n<ul>\n\t<li>如果某个整数大于 <code>1</code> ，且不存在除 <code>1</code> 和自身之外的正整数因子，则认为该整数是一个质数。</li>\n\t<li>如果存在整数 <code>i</code> ，使得&nbsp;<code>nums[i][i] = val</code> 或者&nbsp;<code>nums[i][nums.length - i - 1]= val</code> ，则认为整数 <code>val</code> 位于 <code>nums</code> 的一条对角线上。</li>\n</ul>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/06/screenshot-2023-03-06-at-45648-pm.png\" style=\"width: 181px; height: 121px;\" /></p>\n\n<p>在上图中，一条对角线是 <strong>[1,5,9]</strong> ，而另一条对角线是<strong> [3,5,7]</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[1,2,3],[5,6,7],[9,10,11]]\n<strong>输出：</strong>11\n<strong>解释：</strong>数字 1、3、6、9 和 11 是所有 \"位于至少一条对角线上\" 的数字。由于 11 是最大的质数，故返回 11 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[1,2,3],[5,17,7],[9,11,10]]\n<strong>输出：</strong>17\n<strong>解释：</strong>数字 1、3、9、10 和 17 是所有满足\"位于至少一条对角线上\"的数字。由于 17 是最大的质数，故返回 17 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 300</code></li>\n\t<li><code>nums.length == nums<sub>i</sub>.length</code></li>\n\t<li><code>1 &lt;= nums<span style=\"\">[i][j]</span>&nbsp;&lt;= 4*10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2615.等值距离和",
        "hardRate": "MEDIUM",
        "passRate": "35.50%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-distances/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-distances/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。现有一个长度等于 <code>nums.length</code> 的数组 <code>arr</code> 。对于满足 <code>nums[j] == nums[i]</code> 且 <code>j != i</code> 的所有 <code>j</code> ，<code>arr[i]</code> 等于所有 <code>|i - j|</code> 之和。如果不存在这样的 <code>j</code> ，则令 <code>arr[i]</code> 等于 <code>0</code> 。</p>\n\n<p>返回数组<em> </em><code>arr</code><em> 。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,1,1,2]\n<strong>输出：</strong>[5,0,3,4,0]\n<strong>解释：</strong>\ni = 0 ，nums[0] == nums[2] 且 nums[0] == nums[3] 。因此，arr[0] = |0 - 2| + |0 - 3| = 5 。 \ni = 1 ，arr[1] = 0 因为不存在值等于 3 的其他下标。\ni = 2 ，nums[2] == nums[0] 且 nums[2] == nums[3] 。因此，arr[2] = |2 - 0| + |2 - 3| = 3 。\ni = 3 ，nums[3] == nums[0] 且 nums[3] == nums[2] 。因此，arr[3] = |3 - 0| + |3 - 2| = 4 。 \ni = 4 ，arr[4] = 0 因为不存在值等于 2 的其他下标。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,5,3]\n<strong>输出：</strong>[0,0,0]\n<strong>解释：</strong>因为 nums 中的元素互不相同，对于所有 i ，都有 arr[i] = 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2616.最小化数对的最大差值",
        "hardRate": "MEDIUM",
        "passRate": "38.93%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>p</code>&nbsp;。请你从&nbsp;<code>nums</code>&nbsp;中找到&nbsp;<code>p</code> 个下标对，每个下标对对应数值取差值，你需要使得这 <code>p</code> 个差值的&nbsp;<strong>最大值</strong>&nbsp;<strong>最小</strong>。同时，你需要确保每个下标在这&nbsp;<code>p</code>&nbsp;个下标对中最多出现一次。</p>\n\n<p>对于一个下标对&nbsp;<code>i</code>&nbsp;和&nbsp;<code>j</code>&nbsp;，这一对的差值为&nbsp;<code>|nums[i] - nums[j]|</code>&nbsp;，其中&nbsp;<code>|x|</code>&nbsp;表示 <code>x</code>&nbsp;的 <strong>绝对值</strong>&nbsp;。</p>\n\n<p>请你返回 <code>p</code>&nbsp;个下标对对应数值 <strong>最大差值</strong>&nbsp;的 <strong>最小值</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [10,1,2,7,1,3], p = 2\n<b>输出：</b>1\n<b>解释：</b>第一个下标对选择 1 和 4 ，第二个下标对选择 2 和 5 。\n最大差值为 max(|nums[1] - nums[4]|, |nums[2] - nums[5]|) = max(0, 1) = 1 。所以我们返回 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [4,2,1,2], p = 1\n<b>输出：</b>0\n<b>解释：</b>选择下标 1 和 3 构成下标对。差值为 |2 - 2| = 0 ，这是最大差值的最小值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= p &lt;= (nums.length)/2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2617.网格图中最少访问的格子数",
        "hardRate": "HARD",
        "passRate": "32.50%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;整数矩阵&nbsp;<code>grid</code>&nbsp;。你一开始的位置在&nbsp;<strong>左上角</strong>&nbsp;格子&nbsp;<code>(0, 0)</code>&nbsp;。</p>\n\n<p>当你在格子&nbsp;<code>(i, j)</code>&nbsp;的时候，你可以移动到以下格子之一：</p>\n\n<ul>\n\t<li>满足 <code>j &lt; k &lt;= grid[i][j] + j</code>&nbsp;的格子&nbsp;<code>(i, k)</code>&nbsp;（向右移动），或者</li>\n\t<li>满足 <code>i &lt; k &lt;= grid[i][j] + i</code>&nbsp;的格子&nbsp;<code>(k, j)</code>&nbsp;（向下移动）。</li>\n</ul>\n\n<p>请你返回到达 <strong>右下角</strong>&nbsp;格子&nbsp;<code>(m - 1, n - 1)</code>&nbsp;需要经过的最少移动格子数，如果无法到达右下角格子，请你返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/25/ex1.png\" style=\"width: 271px; height: 171px;\"></p>\n\n<pre><b>输入：</b>grid = [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]]\n<b>输出：</b>4\n<b>解释：</b>上图展示了到达右下角格子经过的 4 个格子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/25/ex2.png\" style=\"width: 271px; height: 171px;\"></p>\n\n<pre><b>输入：</b>grid = [[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]]\n<b>输出：</b>3\n<strong>解释：</strong>上图展示了到达右下角格子经过的 3 个格子。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/26/ex3.png\" style=\"width: 181px; height: 81px;\"></p>\n\n<pre><b>输入：</b>grid = [[2,1,0],[1,0,0]]\n<b>输出：</b>-1\n<b>解释：</b>无法到达右下角格子。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt; m * n</code></li>\n\t<li><code>grid[m - 1][n - 1] == 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2618.检查是否是类的对象实例",
        "hardRate": "MEDIUM",
        "passRate": "33.92%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-object-instance-of-class/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-object-instance-of-class/solution",
        "problemsDesc": "<p>请你编写一个函数，检查给定的值是否是给定类或超类的实例。</p>\n\n<p>可以传递给函数的数据类型没有限制。例如，值或类可能是&nbsp; <code>undefined</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>func = () =&gt; checkIfInstance(new Date(), Date)\n<b>输出：</b>true\n<strong>解释：</strong>根据定义，Date 构造函数返回的对象是 Date 的一个实例。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>func = () =&gt; { class Animal {}; class Dog extends Animal {}; return checkIfInstance(new Dog(), Animal); }\n<b>输出：</b>true\n<strong>解释：</strong>\nclass Animal {};\nclass Dog extends Animal {};\ncheckIfInstanceOf(new Dog(), Animal); // true\n\nDog 是 Animal 的子类。因此，Dog 对象同时是 Dog 和 Animal 的实例。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>func = () =&gt; checkIfInstance(Date, Date)\n<b>输出：</b>false\n<strong>解释：</strong>日期的构造函数在逻辑上不能是其自身的实例。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>func = () =&gt; checkIfInstance(5, Number)\n<b>输出：</b>true\n<strong>解释：</strong>5 是一个 Number。注意，\"instanceof\" 关键字将返回 false。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2619.数组原型对象的最后一个元素",
        "hardRate": "EASY",
        "passRate": "72.04%",
        "problemsUrl": "https://leetcode.cn/problems/array-prototype-last/",
        "solutionsUrl": "https://leetcode.cn/problems/array-prototype-last/solution",
        "problemsDesc": "<p>请你编写一段代码实现一个数组方法，使任何数组都可以调用 <code>array.last()</code> 方法，这个方法将返回数组最后一个元素。如果数组中没有元素，则返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>你可以假设数组是 <code>JSON.parse</code> 的输出结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1 ：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [null, {}, 3]\n<b>输出：</b>3\n<b>解释</b>：调用 nums.last() 后返回最后一个元素： 3。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre>\n<b>输入：</b>nums = []\n<b>输出：</b>-1\n<strong>解释：</strong>因为此数组没有元素，所以应该返回 -1。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>0 &lt;= arr.length &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2620.计数器",
        "hardRate": "EASY",
        "passRate": "81.86%",
        "problemsUrl": "https://leetcode.cn/problems/counter/",
        "solutionsUrl": "https://leetcode.cn/problems/counter/solution",
        "problemsDesc": "<p>请你编写并返回一个&nbsp;<strong>计数器&nbsp;</strong>函数，它接收一个整型参数 n 。这个&nbsp;<strong>计数器&nbsp;</strong>函数最初返回 n，每次调用它时返回前一个值加 1 的值 ( <code>n</code> ,&nbsp; <code>n + 1</code> ,&nbsp; <code>n + 2</code> ，等等)。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>\nn = 10 \n[\"call\",\"call\",\"call\"]\n<b>输出：</b>[10,11,12]\n<strong>解释：\n</strong>counter() = 10 // 第一次调用 counter()，返回 n。\ncounter() = 11 // 返回上次调用的值加 1。\ncounter() = 12 // 返回上次调用的值加 1。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>\nn = -2\n[\"call\",\"call\",\"call\",\"call\",\"call\"]\n<b>输出：</b>[-2,-1,0,1,2]\n<b>解释：</b>counter() 最初返回 -2。然后在每个后续调用后增加 1。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-1000<sup>&nbsp;</sup>&lt;= n &lt;= 1000</code></li>\n\t<li><code>最多对 counter() 进行 1000 次调用</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2621.睡眠函数",
        "hardRate": "EASY",
        "passRate": "84.24%",
        "problemsUrl": "https://leetcode.cn/problems/sleep/",
        "solutionsUrl": "https://leetcode.cn/problems/sleep/solution",
        "problemsDesc": "<p>请你编写一个异步函数，它接收一个正整数参数 <code>millis</code>&nbsp;，并休眠这么多毫秒。要求此函数可以解析任何值。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre>\n<b>输入：</b>millis = 100\n<b>输出：</b>100\n<b>解释：</b>\n在 100ms 后此异步函数执行完时返回一个 Promise 对象\nlet t = Date.now();\nsleep(100).then(() =&gt; {\n  console.log(Date.now() - t); // 100\n});\n</pre>\n\n<p><b>示例 2：</b></p>\n\n<pre>\n<b>输入：</b>millis = 200\n<b>输出：</b>200\n<b>解释：</b>在 200ms 后函数执行完时返回一个 Promise 对象\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>1 &lt;= millis &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2622.有时间限制的缓存",
        "hardRate": "MEDIUM",
        "passRate": "55.07%",
        "problemsUrl": "https://leetcode.cn/problems/cache-with-time-limit/",
        "solutionsUrl": "https://leetcode.cn/problems/cache-with-time-limit/solution",
        "problemsDesc": "<p>编写一个类，它允许获取和设置键-值对，并且每个键都有一个&nbsp;<strong>过期时间</strong>&nbsp;。</p>\n\n<p>该类有三个公共方法：</p>\n\n<p><code>set(key, value, duration)</code>&nbsp;：接收参数为整型键 <code>key</code> 、整型值 <code>value</code> 和以毫秒为单位的持续时间 <code>duration</code> 。一旦 <code>duration</code>&nbsp;到期后，这个键就无法访问。如果相同的未过期键已经存在，该方法将返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。如果该键已经存在，则它的值和持续时间都应该被覆盖。</p>\n\n<p><code>get(key)</code>&nbsp;：如果存在一个未过期的键，它应该返回这个键相关的值。否则返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p><code>count()</code>&nbsp;：返回未过期键的总数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong> \n[\"TimeLimitedCache\", \"set\", \"get\", \"count\", \"get\"]\n[[], [1, 42, 100], [1], [], [1]]\n[0, 0, 50, 50, 150]\n<strong>输出：</strong> [null, false, 42, 1, -1]\n<strong>解释：</strong>\n在 t=0 时，缓存被构造。\n在 t=0 时，添加一个键值对 (1: 42) ，过期时间为 100ms 。因为该值不存在，因此返回false。\n在 t=50 时，请求 key=1 并返回值 42。\n在 t=50 时，调用 count() ，缓存中有一个未过期的键。\n在 t=100 时，key=1 到期。\n在 t=150 时，调用 get(1) ，返回 -1，因为缓存是空的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"TimeLimitedCache\", \"set\", \"set\", \"get\", \"get\", \"get\", \"count\"]\n[[], [1, 42, 50], [1, 50, 100], [1], [1], [1], []]\n[0, 0, 40, 50, 120, 200, 250]\n<strong>输出：</strong> [null, false, true, 50, 50, -1]\n<strong>解释：</strong>\n在 t=0 时，缓存被构造。\n在 t=0 时，添加一个键值对 (1: 42) ，过期时间为 50ms。因为该值不存在，因此返回false。\n当 t=40 时，添加一个键值对 (1: 50) ，过期时间为 100ms。因为一个未过期的键已经存在，返回 true 并覆盖这个键的旧值。\n在 t=50 时，调用 get(1) ，返回 50。\n在 t=120 时，调用 get(1) ，返回 50。\n在 t=140 时，key=1 过期。\n在 t=200 时，调用 get(1) ，但缓存为空，因此返回 -1。\n在 t=250 时，count() 返回0 ，因为缓存是空的，没有未过期的键。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= key &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= value &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= duration &lt;= 1000</code></li>\n\t<li><code>方法调用总数不会超过100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2623.记忆函数",
        "hardRate": "MEDIUM",
        "passRate": "60.43%",
        "problemsUrl": "https://leetcode.cn/problems/memoize/",
        "solutionsUrl": "https://leetcode.cn/problems/memoize/solution",
        "problemsDesc": "<p>请你编写一个函数，它接收另一个函数作为输入，并返回该函数的 <strong>记忆化</strong> 后的结果。</p>\n\n<p><strong>记忆函数</strong> 是一个对于相同的输入永远不会被调用两次的函数。相反，它将返回一个缓存值。</p>\n\n<p>你可以假设有 <strong>3</strong> 个可能的输入函数：<code>sum</code> 、<code>fib</code> 和 <code>factorial</code> 。</p>\n\n<ul>\n\t<li>&nbsp;<code>sum</code> 接收两个整型参数 <code>a</code> 和 <code>b</code> ，并返回 <code>a + b</code> 。</li>\n\t<li>&nbsp;<code>fib</code> 接收一个整型参数&nbsp;<code>n</code> ，如果 <code>n &lt;= 1</code> 则返回 <code>1</code>，否则返回 <code>fib (n - 1) + fib (n - 2)</code>。</li>\n\t<li>&nbsp;<code>factorial</code> 接收一个整型参数 <code>n</code> ，如果 <code>n &lt;= 1</code> 则返回&nbsp;&nbsp;<code>1</code>&nbsp;，否则返回 <code>factorial(n - 1) * n</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n\"sum\"\n[\"call\",\"call\",\"getCallCount\",\"call\",\"getCallCount\"]\n[[2,2],[2,2],[],[1,2],[]]\n<strong>输出：</strong>\n[4,4,1,3,2]\n\n<strong>解释：</strong>\nconst sum = (a, b) =&gt; a + b;\nconst memoizedSum = memoize(sum);\nmemoizedSum (2, 2);// 返回 4。sum() 被调用，因为之前没有使用参数 (2, 2) 调用过。\nmemoizedSum (2, 2);// 返回 4。没有调用 sum()，因为前面有相同的输入。\n//总调用数： 1\nmemoizedSum(1、2);// 返回 3。sum() 被调用，因为之前没有使用参数 (1, 2) 调用过。\n//总调用数： 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：\n</strong>\"factorial\"\n[\"call\",\"call\",\"call\",\"getCallCount\",\"call\",\"getCallCount\"]\n[[2],[3],[2],[],[3],[]]\n<strong>输出：</strong>\n[2,6,2,2,6,2]\n\n<strong>解释：</strong>\nconst factorial = (n) =&gt; (n &lt;= 1) ? 1 : (n * factorial(n - 1));\nconst memoFactorial = memoize(factorial);\nmemoFactorial(2); // 返回 2。\nmemoFactorial(3); // 返回 6。\nmemoFactorial(2); // 返回 2。 没有调用 factorial()，因为前面有相同的输入。\n// 总调用数：2\nmemoFactorial(3); // 返回 6。 没有调用 factorial()，因为前面有相同的输入。\n// 总调用数：2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：\n</strong>\"fib\"\n[\"call\",\"getCallCount\"]\n[[5],[]]\n<strong>输出：</strong>\n[8,1]\n\n<strong>解释：\n</strong>fib(5) = 8\n// 总调用数：1\n\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= a, b &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= n &lt;= 10</code></li>\n\t<li><code>at most 10<sup>5</sup>&nbsp;function calls</code></li>\n\t<li><code>at most 10<sup>5</sup>&nbsp;attempts to access callCount</code></li>\n\t<li><code>input function is sum, fib, or factorial</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2624.蜗牛排序",
        "hardRate": "MEDIUM",
        "passRate": "65.22%",
        "problemsUrl": "https://leetcode.cn/problems/snail-traversal/",
        "solutionsUrl": "https://leetcode.cn/problems/snail-traversal/solution",
        "problemsDesc": "<p>请你编写一段代码为所有数组实现&nbsp;&nbsp;<code>snail(rowsCount，colsCount)</code> 方法，该方法将 1D 数组转换为以蜗牛排序的模式的 2D 数组。无效的输入值应该输出一个空数组。当 <code>rowsCount * colsCount&nbsp;!==</code><code>nums.length</code>&nbsp;时。这个输入被认为是无效的。</p>\n\n<p>蜗牛排序从左上角的单元格开始，从当前数组的第一个值开始。然后，它从上到下遍历第一列，接着移动到右边的下一列，并从下到上遍历它。将这种模式持续下去，每列交替变换遍历方向，直到覆盖整个数组。例如，当给定输入数组&nbsp;&nbsp;<code>[19, 10, 3, 7, 9, 8, 5, 2, 1, 17, 16, 14, 12, 18, 6, 13, 11, 20, 4, 15]</code> ，当 <code>rowsCount = 5</code>&nbsp;且&nbsp;<code>colsCount = 4</code> 时，需要输出矩阵如下图所示。注意，矩阵沿箭头方向对应于原数组中数字的顺序</p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"Traversal Diagram\" src=\"https://assets.leetcode.com/uploads/2023/04/10/screen-shot-2023-04-10-at-100006-pm.png\" style=\"width: 275px; height: 343px;\" /></p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre>\n<b>输入：</b>\nnums = [19, 10, 3, 7, 9, 8, 5, 2, 1, 17, 16, 14, 12, 18, 6, 13, 11, 20, 4, 15]\nrowsCount = 5\ncolsCount = 4\n<b>输出：</b>\n[\n [19,17,16,15],\n&nbsp;[10,1,14,4],\n&nbsp;[3,2,12,20],\n&nbsp;[7,5,18,11],\n&nbsp;[9,8,6,13]\n]\n</pre>\n\n<p><b>示例 2：</b></p>\n\n<pre>\n<b>输入：</b>\nnums = [1,2,3,4]\nrowsCount = 1\ncolsCount = 4\n<b>输出：</b>[[1, 2, 3, 4]]\n</pre>\n\n<p><b>示例 3：</b></p>\n\n<pre>\n<b>输入：</b>\nnums = [1,3]\nrowsCount = 2\ncolsCount = 2\n<b>输出：</b>[]\n<strong>Explanation:</strong> 2 * 2 = 4, 且原数组 [1,3] 的长度为 2; 所以，输入是无效的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 250</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= rowsCount &lt;= 250</code></li>\n\t<li><code>1 &lt;= colsCount &lt;= 250</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2625.扁平化嵌套数组",
        "hardRate": "MEDIUM",
        "passRate": "50.64%",
        "problemsUrl": "https://leetcode.cn/problems/flatten-deeply-nested-array/",
        "solutionsUrl": "https://leetcode.cn/problems/flatten-deeply-nested-array/solution",
        "problemsDesc": "<p>请你编写一个函数，它接收一个&nbsp;<strong>多维数组&nbsp;</strong><code>arr</code> 和它的深度 <code>n</code> ，并返回该数组的&nbsp;<strong>扁平化&nbsp;</strong>后的结果。</p>\n\n<p><strong>多维数组&nbsp;</strong>是一种包含整数或其他&nbsp;<strong>多维数组&nbsp;</strong>的递归数据结构。</p>\n\n<p>数组 <strong>扁平化</strong> 是对数组的一种操作，定义是将原数组部分或全部子数组删除，并替换为该子数组中的实际元素。只有当嵌套的数组深度大于 <code>n</code> 时，才应该执行扁平化操作。第一层数组中元素的深度被认为是 0。</p>\n\n<p>请在没有使用内置方法&nbsp;<code>Array.flat</code> 的前提下解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\narr = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]\nn = 0\n<strong>输出</strong>\n[1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]\n\n<strong>解释</strong>\n传递深度 n=0 的多维数组将始终得到原始数组。这是因为 子数组(0) 的最小可能的深度不小于 n=0 。因此，任何子数组都不应该被平面化。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入</strong>\narr = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]\nn = 1\n<strong>输出</strong>\n[1, 2, 3, 4, 5, 6, 7, 8, [9, 10, 11], 12, 13, 14, 15]\n\n<strong>解释</strong>\n以 4 、7 和 13 开头的子数组都被扁平化了，这是因为它们的深度为 0 ， 而 0 小于 1 。然而 [9,10,11] 其深度为 1 ，所以未被扁平化。</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入</strong>\narr = [[1, 2, 3], [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]\nn = 2\n<strong>输出</strong>\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n\n<strong>解释</strong>\n所有子数组的最大深度都为 1 。因此，它们都被扁平化了。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= arr 的元素个数&nbsp;&lt;=&nbsp;10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= arr 的子数组个数&nbsp;&lt;=&nbsp;10<sup>5</sup></code></li>\n\t<li><code>maxDepth &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= each number &lt;= 1000</code></li>\n\t<li><code><font face=\"monospace\">0 &lt;= n &lt;= 1000</font></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2626.数组归约运算",
        "hardRate": "EASY",
        "passRate": "77.44%",
        "problemsUrl": "https://leetcode.cn/problems/array-reduce-transformation/",
        "solutionsUrl": "https://leetcode.cn/problems/array-reduce-transformation/solution",
        "problemsDesc": "<p>请你编写一个函数，它的参数为一个整数数组&nbsp;<code>nums</code>&nbsp;、一个计算函数&nbsp;<code>fn</code>&nbsp;和初始值&nbsp;<font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">init&nbsp;</span></span></font></font>。返回一个数组&nbsp;<strong>归约后 </strong>的值。</p>\n\n<p>你可以定义一个数组&nbsp;<strong>归约后 </strong>的值，然后应用以下操作： <code>val = fn(init, nums[0])</code>&nbsp;， <code>val = fn(val, nums[1])</code>&nbsp;， <code>val = fn(val, nums[2])</code>&nbsp;，<code>...</code>&nbsp;直到数组中的每个元素都被处理完毕。返回 <code>val</code> 的最终值。</p>\n\n<p>如果数组的长度为 0，它应该返回 <code>init</code>&nbsp;的值。</p>\n\n<p>请你在不使用内置数组方法的&nbsp;<code>Array.reduce</code>&nbsp;前提下解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nnums = [1,2,3,4]\nfn = function sum(accum, curr) { return accum + curr; }\ninit = 0\n<strong>输出：</strong>10\n<strong>解释：</strong>\n初始值为 init=0 。\n(0) + nums[0] = 1\n(1) + nums[1] = 3\n(3) + nums[2] = 6\n(6) + nums[3] = 10\nVal 最终值为 10。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong> \nnums = [1,2,3,4]\nfn = function sum(accum, curr) { return accum + curr * curr; }\ninit = 100\n<strong>输出：</strong>130\n<strong>解释：</strong>\n初始值为 init=0 。\n(100) + nums[0]^2 = 101\n(101) + nums[1]^2 = 105\n(105) + nums[2]^2 = 114\n(114) + nums[3]^2 = 130\nVal 最终值为 130。\n</pre>\n\n<p><strong class=\"example\">示例3:</strong></p>\n\n<pre>\n<strong>输入：</strong> \nnums = []\nfn = function sum(accum, curr) { return 0; }\ninit = 25\n<strong>输出：</strong>25\n<b>解释：</b>这是一个空数组，所以返回 init 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= init &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2627.函数防抖",
        "hardRate": "MEDIUM",
        "passRate": "77.17%",
        "problemsUrl": "https://leetcode.cn/problems/debounce/",
        "solutionsUrl": "https://leetcode.cn/problems/debounce/solution",
        "problemsDesc": "<p>请你编写一个函数，接收参数为另一个函数和一个以毫秒为单位的时间 <code>t</code> ，并返回该函数的&nbsp;<b>函数防抖&nbsp;</b>后的结果。</p>\n\n<p><b>函数防抖 </b>方法是一个函数，它的执行被延迟了 <code>t</code> 毫秒，如果在这个时间窗口内再次调用它，它的执行将被取消。你编写的防抖函数也应该接收传递的参数。</p>\n\n<p>例如，假设 <code>t = 50ms</code> ，函数分别在 <code>30ms</code> 、 <code>60ms</code> 和 <code>100ms</code> 时调用。前两个函数调用将被取消，第三个函数调用将在 <code>150ms</code> 执行。如果改为 <code>t = 35ms</code> ，则第一个调用将被取消，第二个调用将在 <code>95ms</code> 执行，第三个调用将在 <code>135ms</code> 执行。</p>\n\n<p><img alt=\"Debounce Schematic\" src=\"https://assets.leetcode.com/uploads/2023/04/08/screen-shot-2023-04-08-at-11048-pm.png\" style=\"width: 800px; height: 242px;\" /></p>\n\n<p>上图展示了了防抖函数是如何转换事件的。其中，每个矩形表示 100ms，反弹时间为 400ms。每种颜色代表一组不同的输入。</p>\n\n<p>请在不使用 lodash 的 <code>_.debounce()</code> 函数的前提下解决该问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>\nt = 50\ncalls = [\n&nbsp; {\"t\": 50, inputs: [1]},\n&nbsp; {\"t\": 75, inputs: [2]}\n]\n<b>输出：</b>[{\"t\": 125, inputs: [2]}]\n<strong>解释：</strong>\nlet start = Date.now();\nfunction log(...inputs) { \n&nbsp; console.log([Date.now() - start, inputs ])\n}\nconst dlog = debounce(log, 50);\nsetTimeout(() =&gt; dlog(1), 50);\nsetTimeout(() =&gt; dlog(2), 75);\n\n第一次调用被第二次调用取消，因为第二次调用发生在 100ms 之前\n第二次调用延迟 50ms，在 125ms 执行。输入为 (2)。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>\nt = 20\ncalls = [\n&nbsp; {\"t\": 50, inputs: [1]},\n&nbsp; {\"t\": 100, inputs: [2]}\n]\n<b>输出：</b>[{\"t\": 70, inputs: [1]}, {\"t\": 120, inputs: [2]}]\n<strong>解释：</strong>\n第一次调用延迟到 70ms。输入为 (1)。\n第二次调用延迟到 120ms。输入为 (2)。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>\nt = 150\ncalls = [\n&nbsp; {\"t\": 50, inputs: [1, 2]},\n&nbsp; {\"t\": 300, inputs: [3, 4]},\n&nbsp; {\"t\": 300, inputs: [5, 6]}\n]\n<b>输出：</b>[{\"t\": 200, inputs: [1,2]}, {\"t\": 450, inputs: [5, 6]}]\n<strong>解释：</strong>\n第一次调用延迟了 150ms，运行时间为 200ms。输入为 (1, 2)。\n第二次调用被第三次调用取消\n第三次调用延迟了 150ms，运行时间为 450ms。输入为 (5, 6)。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= t &lt;= 1000</code></li>\n\t<li><code>1 &lt;= calls.length &lt;= 10</code></li>\n\t<li><code>0 &lt;= calls[i].t &lt;= 1000</code></li>\n\t<li><code>0 &lt;= calls[i].inputs.length &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2628.完全相等的 JSON 字符串",
        "hardRate": "MEDIUM",
        "passRate": "32.21%",
        "problemsUrl": "https://leetcode.cn/problems/json-deep-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/json-deep-equal/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2629.复合函数",
        "hardRate": "EASY",
        "passRate": "81.79%",
        "problemsUrl": "https://leetcode.cn/problems/function-composition/",
        "solutionsUrl": "https://leetcode.cn/problems/function-composition/solution",
        "problemsDesc": "<p>请你编写一个函数，它接收一个函数数组 <code>[f<sub>1</sub>, f<sub>2</sub>, f<sub>3</sub>，…， f<sub>n</sub>]</code> ，并返回一个新的函数 <code>fn</code>&nbsp;，它是函数数组的 <strong>复合函数</strong> 。</p>\n\n<p><code>[f(x)， g(x)， h(x)]</code> 的 <strong>复合函数</strong> 为 <code>fn(x) = f(g(h(x)))</code>&nbsp;。</p>\n\n<p>一个空函数列表的 <strong>复合函数</strong> 是 <strong>恒等函数</strong> <code>f(x) = x</code> 。</p>\n\n<p>你可以假设数组中的每个函数接受一个整型参数作为输入，并返回一个整型作为输出。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>functions = [x =&gt; x + 1, x =&gt; x * x, x =&gt; 2 * x], x = 4\n<b>输出：</b>65\n<strong>解释：</strong>\n从右向左计算......\nStarting with x = 4.\n2 * (4) = 8\n(8) * (8) = 64\n(64) + 1 = 65\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输出：</b>functions = [x =&gt; 10 * x, x =&gt; 10 * x, x =&gt; 10 * x], x = 1\n<b>输入：</b>1000\n<strong>解释：</strong>\n从右向左计算......\n10 * (1) = 10\n10 * (10) = 100\n10 * (100) = 1000\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>functions = [], x = 42\n<b>输出：</b>42\n<strong>解释：</strong>\n空函数列表的复合函数就是恒等函数</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code><font face=\"monospace\">-1000 &lt;= x &lt;= 1000</font></code></li>\n\t<li><code><font face=\"monospace\">0 &lt;= functions.length &lt;= 1000</font></code></li>\n\t<li><font face=\"monospace\"><code>所有函数都接受并返回一个整型</code></font></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2630.记忆函数 II",
        "hardRate": "HARD",
        "passRate": "42.12%",
        "problemsUrl": "https://leetcode.cn/problems/memoize-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/memoize-ii/solution",
        "problemsDesc": "<p>现给定一个函数 <code>fn</code> ，返回该函数的一个 <strong>记忆化</strong> 版本。</p>\n\n<p>一个 <strong>记忆化</strong> 的函数是一个函数，它不会被相同的输入调用两次。而是会返回一个缓存的值。</p>\n\n<p>函数 <code>fn</code> 可以是任何函数，对它所接受的值类型没有任何限制。如果两个输入值在 JavaScript 中使用 <code>===</code>&nbsp;运算符比较时相等，则它们被视为相同。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong> \ngetInputs = () =&gt; [[2,2],[2,2],[1,2]]\nfn = function (a, b) { return a + b; }\n<b>输出：</b>[{\"val\":4,\"calls\":1},{\"val\":4,\"calls\":1},{\"val\":3,\"calls\":2}]\n<strong>解释：</strong>\nconst inputs = getInputs();\nconst memoized = memoize(fn);\nfor (const arr of inputs) {\n  memoized(...arr);\n}\n\n对于参数为 (2, 2) 的输入: 2 + 2 = 4，需要调用 fn() 。\n对于参数为 (2, 2) 的输入: 2 + 2 = 4，这些输入之前已经出现过，因此不需要再次调用 fn()。\n对于参数为 (1, 2) 的输入: 1 + 2 = 3，需要再次调用 fn()，总共调用了 2 次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>\ngetInputs = () =&gt; [[{},{}],[{},{}],[{},{}]] \nfn = function (a, b) { return a + b; }\n<b>输出：</b>[{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":2},{\"val\":{},\"calls\":3}]\n<strong>解释：</strong>\n将两个空对象合并总是会得到一个空对象。尽管看起来应该缓存命中并只调用一次 <code>fn()</code>，但是这些空对象彼此之间都不是 <code>===</code> 相等的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong> \ngetInputs = () =&gt; { const o = {}; return [[o,o],[o,o],[o,o]]; }\nfn = function (a, b) { return ({...a, ...b}); }\n<b>输出：</b>[{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":1}]\n<strong>解释：</strong>\n将两个空对象合并总是会得到一个空对象。因为传入的每个对象都是相同的，所以第二个和第三个函数调用都会命中缓存。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= inputs.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= inputs.flat().length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>inputs[i][j] != NaN</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2631.分组",
        "hardRate": "MEDIUM",
        "passRate": "79.91%",
        "problemsUrl": "https://leetcode.cn/problems/group-by/",
        "solutionsUrl": "https://leetcode.cn/problems/group-by/solution",
        "problemsDesc": "<p>请你编写一段可应用于所有数组的代码，使任何数组调用 <code>array. groupBy(fn)</code> 方法时，它返回对该数组 <strong>分组后</strong> 的结果。</p>\n\n<p>数组 <strong>分组</strong> 是一个对象，其中的每个键都是 <code>fn(arr[i])</code> 的输出的一个数组，该数组中含有原数组中具有该键的所有项。</p>\n\n<p>提供的回调函数 <code>fn</code> 将接受数组中的项并返回一个字符串类型的键。</p>\n\n<p>每个值列表的顺序应该与元素在数组中出现的顺序相同。任何顺序的键都是可以接受的。</p>\n\n<p>请在不使用 lodash 的&nbsp;<code>_.groupBy</code> 函数的前提下解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>\narray = [\n&nbsp; {\"id\":\"1\"},\n&nbsp; {\"id\":\"1\"},\n&nbsp; {\"id\":\"2\"}\n], \nfn = function (item) { \n&nbsp; return item.id; \n}\n<b>输出：</b>\n{ \n&nbsp; \"1\": [{\"id\": \"1\"}, {\"id\": \"1\"}], &nbsp; \n&nbsp; \"2\": [{\"id\": \"2\"}] \n}\n<strong>解释：</strong>\n输出来自函数 array.groupBy(fn)。\n分组选择方法是从数组中的每个项中获取 \"id\" 。\n有两个 \"id\" 为 1 的对象。所以将这两个对象都放在第一个数组中。\n有一个 \"id\" 为 2 的对象。所以该对象被放到第二个数组中。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>\narray = [\n&nbsp; [1, 2, 3],\n&nbsp; [1, 3, 5],\n&nbsp; [1, 5, 9]\n]\nfn = function (list) { \n&nbsp; return String(list[0]); \n}\n<b>输出：</b>\n{ \n&nbsp; \"1\": [[1, 2, 3], [1, 3, 5], [1, 5, 9]] \n}\n<strong>解释：</strong>\n数组可以是任何类型的。在本例中，分组选择方法是将键定义为数组中的第一个元素。\n所有数组的第一个元素都是1，所以它们被组合在一起。\n{\n  \"1\": [[1, 2, 3], [1, 3, 5], [1, 5, 9]]\n}\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输出：</b>\narray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nfn = function (n) { \n&nbsp; return String(n &gt; 5);\n}\n<strong>输入：</strong>\n{\n&nbsp; \"true\": [6, 7, 8, 9, 10],\n&nbsp; \"false\": [1, 2, 3, 4, 5]\n}\n<strong>解释：</strong>\n分组选择方法是根据每个数字是否大于 5 来分割数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= array.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>fn 返回一个字符串</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2632.柯里化",
        "hardRate": "MEDIUM",
        "passRate": "81.58%",
        "problemsUrl": "https://leetcode.cn/problems/curry/",
        "solutionsUrl": "https://leetcode.cn/problems/curry/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2633.将对象转换为 JSON 字符串",
        "hardRate": "MEDIUM",
        "passRate": "57.36%",
        "problemsUrl": "https://leetcode.cn/problems/convert-object-to-json-string/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-object-to-json-string/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2634.过滤数组中的元素",
        "hardRate": "EASY",
        "passRate": "70.10%",
        "problemsUrl": "https://leetcode.cn/problems/filter-elements-from-array/",
        "solutionsUrl": "https://leetcode.cn/problems/filter-elements-from-array/solution",
        "problemsDesc": "<p>给定一个整数数组&nbsp;<code>arr</code> 和一个过滤函数 <code>fn</code>，并返回一个过滤后的数组 <code>filteredArr</code> 。</p>\n\n<p><code>fn</code> 函数接受一个或两个参数：</p>\n\n<ul>\n\t<li><code>arr[i]</code> - <code>arr</code> 中的数字</li>\n\t<li><code>i</code> - <code>arr[i]</code> 的索引</li>\n</ul>\n\n<p><code>filteredArr</code> 应该只包含使表达式 <code>fn(arr[i], i)</code> 的值为 <strong>真值</strong> 的 <code>arr</code> 中的元素。<strong>真值</strong> 是指 <code>Boolean(value)</code>&nbsp;返回参数为&nbsp;<code>true</code> 的值。</p>\n\n<p>请在不使用内置的 Array.filter 方法的情况下解决该问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,10,20,30], fn = function greaterThan10(n) { return n &gt; 10; }\n<b>输出：</b> [20,30]\n<b>解释：</b>\nconst newArray = filter(arr, fn); // [20, 30]\n过滤函数过滤掉不大于 10 的值</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [1,2,3], fn = function firstIndex(n, i) { return i === 0; }\n<b>输出：</b>[1]\n<strong>解释：</strong>\n过滤函数 fn 也可以接受每个元素的索引\n在这种情况下，过滤函数删除索引不为 0 的元素\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [-2,-1,0,1,2], fn = function plusOne(n) { return n + 1 }\n<b>输出：</b>[-2,0,1,2]\n<strong>解释：</strong>\n像 0 这样的假值应被过滤掉\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code><font face=\"monospace\">-10<sup>9</sup>&nbsp;&lt;= arr[i] &lt;= 10<sup>9</sup></font></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2635.转换数组中的每个元素",
        "hardRate": "EASY",
        "passRate": "73.98%",
        "problemsUrl": "https://leetcode.cn/problems/apply-transform-over-each-element-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/apply-transform-over-each-element-in-array/solution",
        "problemsDesc": "<p>编写一个函数，这个函数接收一个整数数组&nbsp;<code>arr</code> 和一个映射函数&nbsp; <code>fn</code>&nbsp;，通过该映射函数返回一个新的数组。</p>\n\n<p>返回数组的创建语句应为 <code>returnedArray[i] = fn(arr[i], i)</code>&nbsp;。</p>\n\n<p>请你在不使用内置方法&nbsp;<code>Array.map</code>&nbsp;的前提下解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3], fn = function plusone(n) { return n + 1; }\n<strong>输出：</strong>[2,3,4]\n<strong>解释： </strong>\nconst newArray = map(arr, plusone); // [2,3,4]\n此映射函数返回值是将数组中每个元素的值加 1。\n</pre>\n\n<p><strong class=\"example\">示例</strong><strong class=\"example\"> 2:</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3], fn = function plusI(n, i) { return n + i; }\n<strong>输出：</strong>[1,3,5]\n<strong>解释：</strong>此映射函数返回值根据输入数组索引增加每个值。\n</pre>\n\n<p><strong class=\"example\">示例&nbsp;3:</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [10,20,30], fn = function constant() { return 42; }\n<strong>输出：</strong>[42,42,42]\n<strong>解释：</strong>此映射函数返回值恒为 42。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code><font face=\"monospace\">-10<sup>9</sup>&nbsp;&lt;= arr[i] &lt;= 10<sup>9</sup></font></code></li>\n\t<li><font face=\"monospace\"><code>fn 返回一个数</code></font></li>\n</ul>\n<span style=\"display:block\"><span style=\"height:0px\"><span style=\"position:absolute\">​​​​​​</span></span></span>",
        "isPlus": false
    },
    {
        "problemsName": " 2636.Promise 对象池",
        "hardRate": "MEDIUM",
        "passRate": "62.04%",
        "problemsUrl": "https://leetcode.cn/problems/promise-pool/",
        "solutionsUrl": "https://leetcode.cn/problems/promise-pool/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2637.有时间限制的 Promise 对象",
        "hardRate": "EASY",
        "passRate": "61.86%",
        "problemsUrl": "https://leetcode.cn/problems/promise-time-limit/",
        "solutionsUrl": "https://leetcode.cn/problems/promise-time-limit/solution",
        "problemsDesc": "<p>请你编写一个函数，它接受一个异步函数 <code>fn</code>&nbsp;和一个以毫秒为单位的时间 <code>t</code>。它应根据限时函数返回一个有 <strong>限时</strong> 效果的函数。函数 <code>fn</code> 接受提供给 <strong>限时</strong> 函数的参数。</p>\n\n<p><strong>限时</strong> 函数应遵循以下规则：</p>\n\n<ul>\n\t<li>如果 <code>fn</code> 在 <code>t</code> 毫秒的时间限制内完成，<strong>限时</strong> 函数应返回结果。</li>\n\t<li>如果 <code>fn</code> 的执行超过时间限制，<strong>限时&nbsp;</strong>函数应拒绝并返回字符串 <code>\"Time Limit Exceeded\"</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre>\n<b>输入：</b>\nfn = async (n) =&gt; { \n&nbsp; await new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp; return n * n; \n}\ninputs = [5]\nt = 50\n<b>输出：</b>{\"rejected\":\"Time Limit Exceeded\",\"time\":50}\n<b>解释：</b>\nconst limited = timeLimit(fn, t)\nconst start = performance.now()\nlet result;\ntry {\n&nbsp; &nbsp;const res = await limited(...inputs)\n&nbsp; &nbsp;result = {\"resolved\": res, \"time\": Math.floor(performance.now() - start)};\n} catch (err) {\n&nbsp;  result = {\"rejected\": err, \"time\": Math.floor(performance.now() - start)};\n}\nconsole.log(result) // 输出结果\n<b>\n</b>提供的函数设置在 100ms 后执行完成，但是设置的超时时间为 50ms，所以在 t=50ms 时拒绝因为达到了超时时间。\n</pre>\n\n<p><b>示例 2：</b></p>\n\n<pre>\n<b>输入：</b>\nfn = async (n) =&gt; { \n&nbsp; await new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp; return n * n; \n}\ninputs = [5]\nt = 150\n<b>输出：</b>{\"resolved\":25,\"time\":100}\n<b>解释：</b>\n在 t=100ms 时执行 5*5=25 ，没有达到超时时间。\n</pre>\n\n<p><b>示例 3：</b></p>\n\n<pre>\n<b>输入：</b>\nfn = async (a, b) =&gt; { \n&nbsp; await new Promise(res =&gt; setTimeout(res, 120)); \n&nbsp; return a + b; \n}\ninputs = [5,10]\nt = 150\n<b>输出：</b>{\"resolved\":15,\"time\":120}\n<b>解释：\n</b>在 t=120ms 时执行 5+10=15，没有达到超时时间。\n</pre>\n\n<p><b>示例 4：</b></p>\n\n<pre>\n<b>输入：</b>\nfn = async () =&gt; { \n&nbsp; throw \"Error\";\n}\ninputs = []\nt = 1000\n<b>输出：</b>{\"rejected\":\"Error\",\"time\":0}\n<b>解释：</b>\n此函数始终丢出 Error</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>0 &lt;= inputs.length &lt;= 10</code></li>\n\t<li><code>0 &lt;= t &lt;= 1000</code></li>\n\t<li><code>fn 返回一个 Promise 对象</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2638.统计 K-Free 子集的总数",
        "hardRate": "MEDIUM",
        "passRate": "59.26%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-k-free-subsets/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-k-free-subsets/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2639.查询网格图中每一列的宽度",
        "hardRate": "EASY",
        "passRate": "76.38%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-width-of-columns-of-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-width-of-columns-of-a-grid/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;整数矩阵&nbsp;<code>grid</code>&nbsp;。矩阵中某一列的宽度是这一列数字的最大 <strong>字符串长度</strong>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，如果&nbsp;<code>grid = [[-10], [3], [12]]</code>&nbsp;，那么唯一一列的宽度是&nbsp;<code>3</code>&nbsp;，因为&nbsp;<code>-10</code>&nbsp;的字符串长度为&nbsp;<code>3</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回一个大小为 <code>n</code>&nbsp;的整数数组&nbsp;<code>ans</code>&nbsp;，其中&nbsp;<code>ans[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;列的宽度。</p>\n\n<p>一个有 <code>len</code>&nbsp;个数位的整数 <code>x</code>&nbsp;，如果是非负数，那么&nbsp;<strong>字符串</strong><strong>长度</strong>&nbsp;为&nbsp;<code>len</code>&nbsp;，否则为&nbsp;<code>len + 1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>grid = [[1],[22],[333]]\n<b>输出：</b>[3]\n<b>解释：</b>第 0 列中，333 字符串长度为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>grid = [[-15,1,3],[15,7,12],[5,6,-2]]\n<b>输出：</b>[3,1,2]\n<b>解释：</b>\n第 0 列中，只有 -15 字符串长度为 3 。\n第 1 列中，所有整数的字符串长度都是 1 。\n第 2 列中，12 和 -2 的字符串长度都为 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100 </code></li>\n\t<li><code>-10<sup>9</sup> &lt;= grid[r][c] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2640.一个数组所有前缀的分数",
        "hardRate": "MEDIUM",
        "passRate": "79.56%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-score-of-all-prefixes-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-score-of-all-prefixes-of-an-array/solution",
        "problemsDesc": "<p>定义一个数组 <code>arr</code>&nbsp;的 <strong>转换数组</strong>&nbsp;<code>conver</code>&nbsp;为：</p>\n\n<ul>\n\t<li><code>conver[i] = arr[i] + max(arr[0..i])</code>，其中&nbsp;<code>max(arr[0..i])</code>&nbsp;是满足 <code>0 &lt;= j &lt;= i</code>&nbsp;的所有&nbsp;<code>arr[j]</code>&nbsp;中的最大值。</li>\n</ul>\n\n<p>定义一个数组 <code>arr</code>&nbsp;的 <strong>分数</strong>&nbsp;为 <code>arr</code>&nbsp;转换数组中所有元素的和。</p>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;，请你返回一个长度为 <code>n</code>&nbsp;的数组<em>&nbsp;</em><code>ans</code>&nbsp;，其中&nbsp;<code>ans[i]</code>是前缀&nbsp;<code>nums[0..i]</code>&nbsp;的分数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,3,7,5,10]\n<b>输出：</b>[4,10,24,36,56]\n<b>解释：</b>\n对于前缀 [2] ，转换数组为 [4] ，所以分数为 4 。\n对于前缀 [2, 3] ，转换数组为 [4, 6] ，所以分数为 10 。\n对于前缀 [2, 3, 7] ，转换数组为 [4, 6, 14] ，所以分数为 24 。\n对于前缀 [2, 3, 7, 5] ，转换数组为 [4, 6, 14, 12] ，所以分数为 36 。\n对于前缀 [2, 3, 7, 5, 10] ，转换数组为 [4, 6, 14, 12, 20] ，所以分数为 56 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,1,2,4,8,16]\n<b>输出：</b>[2,4,8,16,32,64]\n<b>解释：</b>\n对于前缀 [1] ，转换数组为 [2] ，所以分数为 2 。\n对于前缀 [1, 1]，转换数组为 [2, 2] ，所以分数为 4 。\n对于前缀 [1, 1, 2]，转换数组为 [2, 2, 4] ，所以分数为 8 。\n对于前缀 [1, 1, 2, 4]，转换数组为 [2, 2, 4, 8] ，所以分数为 16 。\n对于前缀 [1, 1, 2, 4, 8]，转换数组为 [2, 2, 4, 8, 16] ，所以分数为 32 。\n对于前缀 [1, 1, 2, 4, 8, 16]，转换数组为 [2, 2, 4, 8, 16, 32] ，所以分数为 64 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2641.二叉树的堂兄弟节点 II",
        "hardRate": "MEDIUM",
        "passRate": "70.18%",
        "problemsUrl": "https://leetcode.cn/problems/cousins-in-binary-tree-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/cousins-in-binary-tree-ii/solution",
        "problemsDesc": "<p>给你一棵二叉树的根&nbsp;<code>root</code>&nbsp;，请你将每个节点的值替换成该节点的所有 <strong>堂兄弟节点值的和&nbsp;</strong>。</p>\n\n<p>如果两个节点在树中有相同的深度且它们的父节点不同，那么它们互为 <strong>堂兄弟</strong>&nbsp;。</p>\n\n<p>请你返回修改值之后，树的根<em>&nbsp;</em><code>root</code><em>&nbsp;</em>。</p>\n\n<p><strong>注意</strong>，一个节点的深度指的是从树根节点到这个节点经过的边数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/11/example11.png\" style=\"width: 571px; height: 151px;\" /></p>\n\n<pre>\n<b>输入：</b>root = [5,4,9,1,10,null,7]\n<b>输出：</b>[0,0,0,7,7,null,11]\n<b>解释：</b>上图展示了初始的二叉树和修改每个节点的值之后的二叉树。\n- 值为 5 的节点没有堂兄弟，所以值修改为 0 。\n- 值为 4 的节点没有堂兄弟，所以值修改为 0 。\n- 值为 9 的节点没有堂兄弟，所以值修改为 0 。\n- 值为 1 的节点有一个堂兄弟，值为 7 ，所以值修改为 7 。\n- 值为 10 的节点有一个堂兄弟，值为 7 ，所以值修改为 7 。\n- 值为 7 的节点有两个堂兄弟，值分别为 1 和 10 ，所以值修改为 11 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/11/diagram33.png\" style=\"width: 481px; height: 91px;\" /></p>\n\n<pre>\n<b>输入：</b>root = [3,1,2]\n<b>输出：</b>[0,0,0]\n<b>解释：</b>上图展示了初始的二叉树和修改每个节点的值之后的二叉树。\n- 值为 3 的节点没有堂兄弟，所以值修改为 0 。\n- 值为 1 的节点没有堂兄弟，所以值修改为 0 。\n- 值为 2 的节点没有堂兄弟，所以值修改为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目的范围是&nbsp;<code>[1, 10<sup>5</sup>]</code> 。</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2642.设计可以求最短路径的图类",
        "hardRate": "HARD",
        "passRate": "55.58%",
        "problemsUrl": "https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/",
        "solutionsUrl": "https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/solution",
        "problemsDesc": "<p>给你一个有&nbsp;<code>n</code>&nbsp;个节点的&nbsp;<strong>有向带权</strong>&nbsp;图，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。图中的初始边用数组&nbsp;<code>edges</code>&nbsp;表示，其中&nbsp;<code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>, edgeCost<sub>i</sub>]</code>&nbsp;表示从&nbsp;<code>from<sub>i</sub></code>&nbsp;到&nbsp;<code>to<sub>i</sub></code>&nbsp;有一条代价为&nbsp;<code>edgeCost<sub>i</sub></code>&nbsp;的边。</p>\n\n<p>请你实现一个&nbsp;<code>Graph</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>Graph(int n, int[][] edges)</code>&nbsp;初始化图有&nbsp;<code>n</code>&nbsp;个节点，并输入初始边。</li>\n\t<li><code>addEdge(int[] edge)</code>&nbsp;向边集中添加一条边，其中<strong>&nbsp;</strong><code>edge = [from, to, edgeCost]</code>&nbsp;。数据保证添加这条边之前对应的两个节点之间没有有向边。</li>\n\t<li><code>int shortestPath(int node1, int node2)</code>&nbsp;返回从节点&nbsp;<code>node1</code>&nbsp;到&nbsp;<code>node2</code>&nbsp;的路径<strong>&nbsp;最小</strong>&nbsp;代价。如果路径不存在，返回&nbsp;<code>-1</code>&nbsp;。一条路径的代价是路径中所有边代价之和。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/11/graph3drawio-2.png\" style=\"width: 621px; height: 191px;\"></p>\n\n<pre><strong>输入：</strong>\n[\"Graph\", \"shortestPath\", \"shortestPath\", \"addEdge\", \"shortestPath\"]\n[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]\n<b>输出：</b>\n[null, 6, -1, null, 6]\n\n<strong>解释：</strong>\nGraph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);\ng.shortestPath(3, 2); // 返回 6 。从 3 到 2 的最短路径如第一幅图所示：3 -&gt; 0 -&gt; 1 -&gt; 2 ，总代价为 3 + 2 + 1 = 6 。\ng.shortestPath(0, 3); // 返回 -1 。没有从 0 到 3 的路径。\ng.addEdge([1, 3, 4]); // 添加一条节点 1 到节点 3 的边，得到第二幅图。\ng.shortestPath(0, 3); // 返回 6 。从 0 到 3 的最短路径为 0 -&gt; 1 -&gt; 3 ，总代价为 2 + 4 = 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= edges.length &lt;= n * (n - 1)</code></li>\n\t<li><code>edges[i].length == edge.length == 3</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub>, from, to, node1, node2 &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= edgeCost<sub>i</sub>, edgeCost &lt;= 10<sup>6</sup></code></li>\n\t<li>图中任何时候都不会有重边和自环。</li>\n\t<li>调用 <code>addEdge</code>&nbsp;至多&nbsp;<code>100</code>&nbsp;次。</li>\n\t<li>调用 <code>shortestPath</code>&nbsp;至多&nbsp;<code>100</code>&nbsp;次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2643.一最多的行",
        "hardRate": "EASY",
        "passRate": "80.23%",
        "problemsUrl": "https://leetcode.cn/problems/row-with-maximum-ones/",
        "solutionsUrl": "https://leetcode.cn/problems/row-with-maximum-ones/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>mat</code> ，请你找出包含最多 <strong>1</strong> 的行的下标（从 <strong>0</strong> 开始）以及这一行中 <strong>1</strong> 的数目。</p>\n\n<p>如果有多行包含最多的 1 ，只需要选择 <strong>行下标最小</strong> 的那一行。</p>\n\n<p>返回一个由行下标和该行中 1 的数量组成的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[0,1],[1,0]]\n<strong>输出：</strong>[0,1]\n<strong>解释：</strong>两行中 1 的数量相同。所以返回下标最小的行，下标为 0 。该行 1 的数量为 1 。所以，答案为 [0,1] 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[0,0,0],[0,1,1]]\n<strong>输出：</strong>[1,2]\n<strong>解释：</strong>下标为 1 的行中 1 的数量最多<code>。</code>该行 1 的数量<code>为 2 。所以，答案为</code> [1,2] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[0,0],[1,1],[0,0]]\n<strong>输出：</strong>[1,2]\n<strong>解释：</strong>下标为 1 的行中 1 的数量最多。该行 1 的数量<code>为 2 。所以，答案为</code> [1,2] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code>&nbsp;</li>\n\t<li><code>n == mat[i].length</code>&nbsp;</li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code>&nbsp;</li>\n\t<li><code>mat[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2644.找出可整除性得分最大的整数",
        "hardRate": "EASY",
        "passRate": "50.15%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-maximum-divisibility-score/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-maximum-divisibility-score/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和 <code>divisors</code> 。</p>\n\n<p><code>divisors[i]</code> 的 <strong>可整除性得分</strong> 等于满足 <code>nums[j]</code> 能被 <code>divisors[i]</code> 整除的下标 <code>j</code> 的数量。</p>\n\n<p>返回 <strong>可整除性得分</strong> 最大的整数 <code>divisors[i]</code> 。如果有多个整数具有最大得分，则返回数值最小的一个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,7,9,3,9], divisors = [5,2,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>divisors 中每个元素的可整除性得分为：\ndivisors[0] 的可整除性得分为 0 ，因为 nums 中没有任何数字能被 5 整除。\ndivisors[1] 的可整除性得分为 1 ，因为 nums[0] 能被 2 整除。 \ndivisors[2] 的可整除性得分为 3 ，因为 nums[2]、nums[3] 和 nums[4] 都能被 3 整除。 \n因此，返回 divisors[2] ，它的可整除性得分最大。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [20,14,21,10], divisors = [5,7,5]\n<strong>输出：</strong>5\n<strong>解释：</strong>divisors 中每个元素的可整除性得分为：\ndivisors[0] 的可整除性得分为 2 ，因为 nums[0] 和 nums[3] 都能被 5 整除。\ndivisors[1] 的可整除性得分为 2 ，因为 nums[1] 和 nums[2] 都能被 7 整除。\ndivisors[2] 的可整除性得分为 2 ，因为 nums[0] 和 nums[3] 都能被5整除。 \n由于 divisors[0]、divisors[1] 和 divisors[2] 的可整除性得分都是最大的，因此，我们返回数值最小的一个，即 divisors[2] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [12], divisors = [10,16]\n<strong>输出：</strong>10\n<strong>解释：</strong>divisors 中每个元素的可整除性得分为：\ndivisors[0] 的可整除性得分为 0 ，因为 nums 中没有任何数字能被 10 整除。\ndivisors[1] 的可整除性得分为 0 ，因为 nums 中没有任何数字能被 16 整除。 \n由于 divisors[0] 和 divisors[1] 的可整除性得分都是最大的，因此，我们返回数值最小的一个，即 divisors[0] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, divisors.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i], divisors[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2645.构造有效字符串的最少插入数",
        "hardRate": "MEDIUM",
        "passRate": "56.52%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-additions-to-make-valid-string/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-additions-to-make-valid-string/solution",
        "problemsDesc": "<p>给你一个字符串 <code>word</code> ，你可以向其中任何位置插入 \"a\"、\"b\" 或 \"c\" 任意次，返回使 <code>word</code> <strong>有效</strong> 需要插入的最少字母数。</p>\n\n<p>如果字符串可以由 \"abc\" 串联多次得到，则认为该字符串 <strong>有效</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>word = \"b\"\n<strong>输出：</strong>2\n<strong>解释：</strong>在 \"b\" 之前插入 \"a\" ，在 \"b\" 之后插入 \"c\" 可以得到有效字符串 \"<strong>a</strong>b<strong>c</strong>\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>word = \"aaa\"\n<strong>输出：</strong>6\n<strong>解释：</strong>在每个 \"a\" 之后依次插入 \"b\" 和 \"c\" 可以得到有效字符串 \"a<strong>bc</strong>a<strong>bc</strong>a<strong>bc</strong>\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>word = \"abc\"\n<strong>输出：</strong>0\n<strong>解释：</strong>word 已经是有效字符串，不需要进行修改。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 50</code></li>\n\t<li><code>word</code> 仅由字母 \"a\"、\"b\" 和 \"c\" 组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2646.最小化旅行的价格总和",
        "hardRate": "HARD",
        "passRate": "49.88%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/solution",
        "problemsDesc": "<p>现有一棵无向、无根的树，树中有 <code>n</code> 个节点，按从 <code>0</code> 到 <code>n - 1</code> 编号。给你一个整数 <code>n</code> 和一个长度为 <code>n - 1</code> 的二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示树中节点 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间存在一条边。</p>\n\n<p>每个节点都关联一个价格。给你一个整数数组 <code>price</code> ，其中 <code>price[i]</code> 是第 <code>i</code> 个节点的价格。</p>\n\n<p>给定路径的 <strong>价格总和</strong> 是该路径上所有节点的价格之和。</p>\n\n<p>另给你一个二维整数数组 <code>trips</code> ，其中 <code>trips[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 表示您从节点 <code>start<sub>i</sub></code> 开始第 <code>i</code> 次旅行，并通过任何你喜欢的路径前往节点 <code>end<sub>i</sub></code> 。</p>\n\n<p>在执行第一次旅行之前，你可以选择一些 <strong>非相邻节点</strong> 并将价格减半。</p>\n\n<p>返回执行所有旅行的最小价格总和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/16/diagram2.png\" style=\"width: 541px; height: 181px;\">\n<pre><strong>输入：</strong>n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]\n<strong>输出：</strong>23\n<strong>解释：\n</strong>上图表示将节点 2 视为根之后的树结构。第一个图表示初始树，第二个图表示选择节点 0 、2 和 3 并使其价格减半后的树。\n第 1 次旅行，选择路径 [0,1,3] 。路径的价格总和为 1 + 2 + 3 = 6 。\n第 2 次旅行，选择路径 [2,1] 。路径的价格总和为 2 + 5 = 7 。\n第 3 次旅行，选择路径 [2,1,3] 。路径的价格总和为 5 + 2 + 3 = 10 。\n所有旅行的价格总和为 6 + 7 + 10 = 23 。可以证明，23 是可以实现的最小答案。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/16/diagram3.png\" style=\"width: 456px; height: 111px;\">\n<pre><strong>输入：</strong>n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n上图表示将节点 0 视为根之后的树结构。第一个图表示初始树，第二个图表示选择节点 0 并使其价格减半后的树。 \n第 1 次旅行，选择路径 [0] 。路径的价格总和为 1 。 \n所有旅行的价格总和为 1 。可以证明，1 是可以实现的最小答案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>edges</code> 表示一棵有效的树</li>\n\t<li><code>price.length == n</code></li>\n\t<li><code>price[i]</code> 是一个偶数</li>\n\t<li><code>1 &lt;= price[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= trips.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub>, end<sub>i</sub>&nbsp;&lt;= n - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2647.把三角形染成红色",
        "hardRate": "HARD",
        "passRate": "68.63%",
        "problemsUrl": "https://leetcode.cn/problems/color-the-triangle-red/",
        "solutionsUrl": "https://leetcode.cn/problems/color-the-triangle-red/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2648.生成斐波那契数列",
        "hardRate": "EASY",
        "passRate": "83.50%",
        "problemsUrl": "https://leetcode.cn/problems/generate-fibonacci-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/generate-fibonacci-sequence/solution",
        "problemsDesc": "<p>请你编写一个生成器函数，并返回一个可以生成 <strong>斐波那契数列</strong> 的生成器对象。</p>\n\n<p><strong>斐波那契数列</strong> 的递推公式为 <code>X<sub>n</sub>&nbsp;= X<sub>n-1</sub>&nbsp;+ X<sub>n-2</sub></code> 。</p>\n\n<p>这个数列的前几个数字是 <code>0, 1, 1, 2, 3, 5, 8, 13</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>callCount = 5\n<b>输出：</b>[0,1,1,2,3]\n<strong>解释：</strong>\nconst gen = fibGenerator();\ngen.next().value; // 0\ngen.next().value; // 1\ngen.next().value; // 1\ngen.next().value; // 2\ngen.next().value; // 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>callCount = 0\n<strong>输出：</strong>[]\n<b>解释：</b>gen.next() 永远不会被调用，所以什么也不会输出\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= callCount &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2649.嵌套数组生成器",
        "hardRate": "MEDIUM",
        "passRate": "77.51%",
        "problemsUrl": "https://leetcode.cn/problems/nested-array-generator/",
        "solutionsUrl": "https://leetcode.cn/problems/nested-array-generator/solution",
        "problemsDesc": "<p>现给定一个整数的 <strong>多维数组</strong> ，请你返回一个生成器对象，按照&nbsp;<strong>中序遍历</strong> 的顺序逐个生成整数。</p>\n\n<p><strong>多维数组</strong> 是一个递归数据结构，包含整数和其他 <strong>多维数组</strong>。</p>\n\n<p><strong>中序遍历</strong> 是从左到右遍历每个数组，在遇到任何整数时生成它，遇到任何数组时递归应用 <strong>中序遍历</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [[[6]],[1,3],[]]\n<b>输出：</b>[6,1,3]\n<strong>解释：</strong>\nconst generator = inorderTraversal(arr);\ngenerator.next().value; // 6\ngenerator.next().value; // 1\ngenerator.next().value; // 3\ngenerator.next().done; // true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>arr = []\n<b>输出：</b>[]\n<b>解释：</b>输入的多维数组没有任何参数，所以生成器不需要生成任何值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= arr.flat().length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= arr.flat()[i]&nbsp;&lt;= 10<sup>5</sup></code></li>\n\t<li><code>maxNestingDepth &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2650.设计可取消函数",
        "hardRate": "HARD",
        "passRate": "49.93%",
        "problemsUrl": "https://leetcode.cn/problems/design-cancellable-function/",
        "solutionsUrl": "https://leetcode.cn/problems/design-cancellable-function/solution",
        "problemsDesc": "<p>有时候你会有一个长时间运行的任务，并且你可能希望在它完成之前取消它。为了实现这个目标，请你编写一个名为 <code>cancellable</code> 的函数，它接收一个生成器对象，并返回一个包含两个值的数组：一个 <strong>取消函数</strong> 和一个 <strong>promise</strong> 对象。</p>\n\n<p>你可以假设生成器函数只会生成 promise 对象。你的函数负责将 promise 对象解析的值传回生成器。如果 promise 被拒绝，你的函数应将该错误抛回给生成器。</p>\n\n<p>如果在生成器完成之前调用了取消回调函数，则你的函数应该将错误抛回给生成器。该错误应该是字符串 <code>\"Cancelled\"</code>（而不是一个 <code>Error</code> 对象）。如果错误被捕获，则返回的 promise 应该解析为下一个生成或返回的值。否则，promise 应该被拒绝并抛出该错误。不应执行任何其他代码。</p>\n\n<p>当生成器完成时，您的函数返回的 promise 应该解析为生成器返回的值。但是，如果生成器抛出错误，则返回的 promise 应该拒绝并抛出该错误。</p>\n\n<p>下面是您的代码应如何使用的示例：</p>\n\n<pre>\nfunction* tasks() {\n  const val = yield new Promise(resolve =&gt; resolve(2 + 2));\n  yield new Promise(resolve =&gt; setTimeout(resolve, 100));\n  return val + 1; // calculation shouldn't be done.\n}\nconst [cancel, promise] = cancellable(tasks());\nsetTimeout(cancel, 50);\npromise.catch(console.log); // logs \"Cancelled\" at t=50ms\n</pre>\n\n<p>如果相反， <code>cancel()</code> 没有被调用或者在 <code>t=100ms</code> 之后才被调用，那么 Promise 应被解析为 <code>5</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>\ngeneratorFunction = function*() { \n&nbsp; return 42; \n}\ncancelledAt = 100\n<b>输出：</b>{\"resolved\": 42}\n<strong>解释：</strong>\nconst generator = generatorFunction();\nconst [cancel, promise] = cancellable(generator);\nsetTimeout(cancel, 100);\npromise.then(console.log); // 在 t=0ms 解析为 42\n\n该生成器立即生成 42 并完成。因此，返回的 promise 立即解析为 42。请注意，取消已经完成的生成器没有任何作用。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>\ngeneratorFunction = function*() { \n&nbsp; const msg = yield new Promise(res =&gt; res(\"Hello\")); \n&nbsp; throw `Error: ${msg}`; \n}\ncancelledAt = null\n<b>输出：</b>{\"rejected\": \"Error: Hello\"}\n<strong>解释：</strong>\n一个 Promise 被生成。该函数通过等待 promise 解析并将解析后的值传回生成器来处理它。然后抛出一个错误，这会导致 promise 被同样抛出的错误拒绝。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>\ngeneratorFunction = function*() { \n&nbsp; yield new Promise(res =&gt; setTimeout(res, 200)); \n&nbsp; return \"Success\"; \n}\ncancelledAt = 100\n<b>输出：</b>{\"rejected\": \"Cancelled\"}\n<strong>解释：</strong>\n当函数等待被生成的 promise 解析时，cancel() 被调用。这会导致一个错误消息被发送回生成器。由于这个错误没有被捕获，返回的 promise 会因为这个错误而被拒绝。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>\ngeneratorFunction = function*() { \n&nbsp; let result = 0; \n&nbsp; yield new Promise(res =&gt; setTimeout(res, 100));\n&nbsp; result += yield new Promise(res =&gt; res(1)); \n&nbsp; yield new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp; result += yield new Promise(res =&gt; res(1)); \n&nbsp; return result;\n}\ncancelledAt = null\n<b>输出：</b>{\"resolved\": 2}\n<strong>解释：</strong>\n生成器生成了 4 个 promise 。其中两个 promise 的值被添加到结果中。200ms 后，生成器以值 2 完成，该值被返回的 promise 解析。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<b>输入：</b>\ngeneratorFunction = function*() { \n&nbsp; let result = 0; \n&nbsp; try { \n&nbsp;   yield new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp;   result += yield new Promise(res =&gt; res(1)); \n&nbsp;   yield new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp;   result += yield new Promise(res =&gt; res(1)); \n&nbsp; } catch(e) { \n&nbsp;   return result; \n&nbsp; } \n&nbsp; return result; \n}\ncancelledAt = 150\n<b>输出：</b>{\"resolved\": 1}\n<strong>解释：</strong>\n前两个生成的 promise 解析并导致结果递增。然而，在 t=150ms 时，生成器被取消了。发送给生成器的错误被捕获，结果被返回并最终由返回的 promise 解析。\n</pre>\n\n<p><strong>示例 6：</strong></p>\n\n<pre>\n<b>输入：</b>\ngeneratorFunction = function*() { \n&nbsp; try { \n&nbsp;   yield new Promise((resolve, reject) =&gt; reject(\"Promise Rejected\")); \n&nbsp; } catch(e) { \n&nbsp;   let a = yield new Promise(resolve =&gt; resolve(2));\n    let b = yield new Promise(resolve =&gt; resolve(2)); \n&nbsp;   return a + b; \n&nbsp; }; \n}\ncancelledAt = null\n<b>输出：</b>{\"resolved\": 4}\n<strong>解释：</strong>\n第一个生成的 promise 立即被拒绝。该错误被捕获。因为生成器没有被取消，执行继续像往常一样。最终解析为 2 + 2 = 4。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>cancelledAt == null or 0 &lt;= cancelledAt &lt;= 1000</code></li>\n\t<li><code>generatorFunction 返回一个生成器对象</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2651.计算列车到站时间",
        "hardRate": "EASY",
        "passRate": "86.78%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-delayed-arrival-time/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-delayed-arrival-time/solution",
        "problemsDesc": "<p>给你一个正整数 <code>arrivalTime</code> 表示列车正点到站的时间（单位：小时），另给你一个正整数 <code>delayedTime</code> 表示列车延误的小时数。</p>\n\n<p>返回列车实际到站的时间。</p>\n\n<p>注意，该问题中的时间采用 24 小时制。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arrivalTime = 15, delayedTime = 5 \n<strong>输出：</strong>20 \n<strong>解释：</strong>列车正点到站时间是 15:00 ，延误 5 小时，所以列车实际到站的时间是 15 + 5 = 20（20:00）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arrivalTime = 13, delayedTime = 11\n<strong>输出：</strong>0\n<strong>解释：</strong>列车正点到站时间是 13:00 ，延误 11 小时，所以列车实际到站的时间是 13 + 11 = 24（在 24 小时制中表示为 00:00 ，所以返回 0）。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arrivaltime &lt;&nbsp;24</code></li>\n\t<li><code>1 &lt;= delayedTime &lt;= 24</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2652.倍数求和",
        "hardRate": "EASY",
        "passRate": "83.56%",
        "problemsUrl": "https://leetcode.cn/problems/sum-multiples/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-multiples/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> ，请你计算在 <code>[1，n]</code> 范围内能被 <code>3</code>、<code>5</code>、<code>7</code> 整除的所有整数之和。</p>\n\n<p>返回一个整数，用于表示给定范围内所有满足约束条件的数字之和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 7\n<strong>输出：</strong>21\n<strong>解释：</strong>在 <code>[1, 7]</code> 范围内能被 3、<code>5、</code><code>7 整除的所有整数分别是</code><code> 3、5、6、7</code> 。数字之和为 <code>21</code> 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 10\n<strong>输出：</strong>40\n<strong>解释：</strong>在 <code>[1, 10]</code> 范围内能被 3、<code>5、</code><code>7 整除的所有整数分别是</code><code> 3、5、6、7、9、10</code> 。数字之和为 <code>40</code> 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 9\n<strong>输出：</strong>30\n<strong>解释：</strong>在 <code>[1, 9]</code> 范围内能被 3、<code>5、</code><code>7 整除的所有整数分别是</code><code> 3、5、6、7、9</code> 。数字之和为 <code>30</code> 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>3</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2653.滑动子数组的美丽值",
        "hardRate": "MEDIUM",
        "passRate": "34.99%",
        "problemsUrl": "https://leetcode.cn/problems/sliding-subarray-beauty/",
        "solutionsUrl": "https://leetcode.cn/problems/sliding-subarray-beauty/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;，请你求出每个长度为&nbsp;<code>k</code>&nbsp;的子数组的 <b>美丽值</b>&nbsp;。</p>\n\n<p>一个子数组的 <strong>美丽值</strong>&nbsp;定义为：如果子数组中第 <code>x</code>&nbsp;<strong>小整数</strong>&nbsp;是 <strong>负数</strong>&nbsp;，那么美丽值为第 <code>x</code>&nbsp;小的数，否则美丽值为 <code>0</code>&nbsp;。</p>\n\n<p>请你返回一个包含<em>&nbsp;</em><code>n - k + 1</code>&nbsp;个整数的数组，<strong>依次</strong>&nbsp;表示数组中从第一个下标开始，每个长度为&nbsp;<code>k</code>&nbsp;的子数组的<strong>&nbsp;美丽值</strong>&nbsp;。</p>\n\n<ul>\n\t<li>\n\t<p>子数组指的是数组中一段连续 <strong>非空</strong>&nbsp;的元素序列。</p>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,-1,-3,-2,3], k = 3, x = 2\n<b>输出：</b>[-1,-2,-2]\n<b>解释：</b>总共有 3 个 k = 3 的子数组。\n第一个子数组是 <code>[1, -1, -3]</code> ，第二小的数是负数 -1 。\n第二个子数组是 <code>[-1, -3, -2]</code> ，第二小的数是负数 -2 。\n第三个子数组是 <code>[-3, -2, 3]&nbsp;，第二小的数是负数 -2 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [-1,-2,-3,-4,-5], k = 2, x = 2\n<b>输出：</b>[-1,-2,-3,-4]\n<b>解释：</b>总共有 4 个 k = 2 的子数组。\n<code>[-1, -2] 中第二小的数是负数 -1 。</code>\n<code>[-2, -3] 中第二小的数是负数 -2 。</code>\n<code>[-3, -4] 中第二小的数是负数 -3 。</code>\n<code>[-4, -5] 中第二小的数是负数 -4 。</code></pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [-3,1,2,-3,0,-3], k = 2, x = 1\n<b>输出：</b>[-3,0,-3,-3,-3]\n<b>解释：</b>总共有 5 个 k = 2 的子数组。\n<code>[-3, 1] 中最小的数是负数 -3 。</code>\n<code>[1, 2] 中最小的数不是负数，所以美丽值为 0 。</code>\n<code>[2, -3] 中最小的数是负数 -3 。</code>\n<code>[-3, 0] 中最小的数是负数 -3 。</code>\n<code>[0, -3] 中最小的数是负数 -3 。</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length&nbsp;</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n\t<li><code>1 &lt;= x &lt;= k&nbsp;</code></li>\n\t<li><code>-50&nbsp;&lt;= nums[i] &lt;= 50&nbsp;</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2654.使数组所有元素变成 1 的最少操作次数",
        "hardRate": "MEDIUM",
        "passRate": "40.17%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的 <strong>正</strong>&nbsp;整数数组&nbsp;<code>nums</code>&nbsp;。你可以对数组执行以下操作 <strong>任意</strong>&nbsp;次：</p>\n\n<ul>\n\t<li>选择一个满足&nbsp;<code>0 &lt;= i &lt; n - 1</code>&nbsp;的下标 <code>i</code>&nbsp;，将&nbsp;<code>nums[i]</code> 或者&nbsp;<code>nums[i+1]</code>&nbsp;两者之一替换成它们的最大公约数。</li>\n</ul>\n\n<p>请你返回使数组 <code>nums</code>&nbsp;中所有元素都等于 <code>1</code>&nbsp;的 <strong>最少</strong>&nbsp;操作次数。如果无法让数组全部变成 <code>1</code>&nbsp;，请你返回 <code>-1</code>&nbsp;。</p>\n\n<p>两个正整数的最大公约数指的是能整除这两个数的最大正整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,6,3,4]\n<b>输出：</b>4\n<b>解释：</b>我们可以执行以下操作：\n- 选择下标 i = 2 ，将 nums[2] 替换为 gcd(3,4) = 1 ，得到 nums = [2,6,1,4] 。\n- 选择下标 i = 1 ，将 nums[1] 替换为 gcd(6,1) = 1 ，得到 nums = [2,1,1,4] 。\n- 选择下标 i = 0 ，将 nums[0] 替换为 gcd(2,1) = 1 ，得到 nums = [1,1,1,4] 。\n- 选择下标 i = 2 ，将 nums[3] 替换为 gcd(1,4) = 1 ，得到 nums = [1,1,1,1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,10,6,14]\n<b>输出：</b>-1\n<b>解释：</b>无法将所有元素都变成 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2655.寻找最大长度的未覆盖区间",
        "hardRate": "MEDIUM",
        "passRate": "60.80%",
        "problemsUrl": "https://leetcode.cn/problems/find-maximal-uncovered-ranges/",
        "solutionsUrl": "https://leetcode.cn/problems/find-maximal-uncovered-ranges/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2656.K 个元素的最大和",
        "hardRate": "EASY",
        "passRate": "84.13%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-with-exactly-k-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-with-exactly-k-elements/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code> 和一个整数&nbsp;<code>k</code>&nbsp;。你需要执行以下操作<strong>&nbsp;恰好</strong> <code>k</code>&nbsp;次，最大化你的得分：</p>\n\n<ol>\n\t<li>从 <code>nums</code>&nbsp;中选择一个元素&nbsp;<code>m</code>&nbsp;。</li>\n\t<li>将选中的元素&nbsp;<code>m</code>&nbsp;从数组中删除。</li>\n\t<li>将新元素&nbsp;<code>m + 1</code>&nbsp;添加到数组中。</li>\n\t<li>你的得分增加&nbsp;<code>m</code>&nbsp;。</li>\n</ol>\n\n<p>请你返回执行以上操作恰好 <code>k</code>&nbsp;次后的最大得分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4,5], k = 3\n<b>输出：</b>18\n<b>解释：</b>我们需要从 nums 中恰好选择 3 个元素并最大化得分。\n第一次选择 5 。和为 5 ，nums = [1,2,3,4,6] 。\n第二次选择 6 。和为 6 ，nums = [1,2,3,4,7] 。\n第三次选择 7 。和为 5 + 6 + 7 = 18 ，nums = [1,2,3,4,8] 。\n所以我们返回 18 。\n18 是可以得到的最大答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5,5,5], k = 2\n<b>输出：</b>11\n<b>解释：</b>我们需要从 nums 中恰好选择 2 个元素并最大化得分。\n第一次选择 5 。和为 5 ，nums = [5,5,6] 。\n第二次选择 6 。和为 6 ，nums = [5,5,7] 。\n所以我们返回 11 。\n11 是可以得到的最大答案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2657.找到两个数组的前缀公共数组",
        "hardRate": "MEDIUM",
        "passRate": "83.31%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-prefix-common-array-of-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-prefix-common-array-of-two-arrays/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数排列&nbsp;<code>A</code> 和&nbsp;<code>B</code>&nbsp;。</p>\n\n<p><code>A</code>&nbsp;和&nbsp;<code>B</code>&nbsp;的 <strong>前缀公共数组</strong>&nbsp;定义为数组&nbsp;<code>C</code>&nbsp;，其中&nbsp;<code>C[i]</code>&nbsp;是数组&nbsp;<code>A</code> 和&nbsp;<code>B</code>&nbsp;到下标为&nbsp;<code>i</code>&nbsp;之前公共元素的数目。</p>\n\n<p>请你返回 <code>A</code>&nbsp;和 <code>B</code>&nbsp;的 <strong>前缀公共数组</strong>&nbsp;。</p>\n\n<p>如果一个长度为 <code>n</code>&nbsp;的数组包含 <code>1</code>&nbsp;到 <code>n</code>&nbsp;的元素恰好一次，我们称这个数组是一个长度为 <code>n</code>&nbsp;的 <strong>排列</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>A = [1,3,2,4], B = [3,1,2,4]\n<b>输出：</b>[0,2,3,4]\n<b>解释：</b>i = 0：没有公共元素，所以 C[0] = 0 。\ni = 1：1 和 3 是两个数组的前缀公共元素，所以 C[1] = 2 。\ni = 2：1，2 和 3 是两个数组的前缀公共元素，所以 C[2] = 3 。\ni = 3：1，2，3 和 4 是两个数组的前缀公共元素，所以 C[3] = 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>A = [2,3,1], B = [3,1,2]\n<b>输出：</b>[0,1,3]\n<b>解释：</b>i = 0：没有公共元素，所以 C[0] = 0 。\ni = 1：只有 3 是公共元素，所以 C[1] = 1 。\ni = 2：1，2 和 3 是两个数组的前缀公共元素，所以 C[2] = 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= A.length == B.length == n &lt;= 50</code></li>\n\t<li><code>1 &lt;= A[i], B[i] &lt;= n</code></li>\n\t<li>题目保证&nbsp;<code>A</code>&nbsp;和&nbsp;<code>B</code>&nbsp;两个数组都是&nbsp;<code>n</code>&nbsp;个元素的排列。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2658.网格图中鱼的最大数目",
        "hardRate": "MEDIUM",
        "passRate": "60.45%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-fish-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-fish-in-a-grid/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始大小为 <code>m x n</code>&nbsp;的二维整数数组&nbsp;<code>grid</code>&nbsp;，其中下标在&nbsp;<code>(r, c)</code>&nbsp;处的整数表示：</p>\n\n<ul>\n\t<li>如果&nbsp;<code>grid[r][c] = 0</code>&nbsp;，那么它是一块 <strong>陆地</strong>&nbsp;。</li>\n\t<li>如果&nbsp;<code>grid[r][c] &gt; 0</code>&nbsp;，那么它是一块&nbsp;<strong>水域</strong>&nbsp;，且包含&nbsp;<code>grid[r][c]</code>&nbsp;条鱼。</li>\n</ul>\n\n<p>一位渔夫可以从任意 <strong>水域</strong>&nbsp;格子&nbsp;<code>(r, c)</code>&nbsp;出发，然后执行以下操作任意次：</p>\n\n<ul>\n\t<li>捕捞格子&nbsp;<code>(r, c)</code>&nbsp;处所有的鱼，或者</li>\n\t<li>移动到相邻的 <strong>水域</strong>&nbsp;格子。</li>\n</ul>\n\n<p>请你返回渔夫最优策略下，&nbsp;<strong>最多</strong>&nbsp;可以捕捞多少条鱼。如果没有水域格子，请你返回 <code>0</code>&nbsp;。</p>\n\n<p>格子&nbsp;<code>(r, c)</code>&nbsp;<strong>相邻</strong>&nbsp;的格子为&nbsp;<code>(r, c + 1)</code>&nbsp;，<code>(r, c - 1)</code>&nbsp;，<code>(r + 1, c)</code> 和&nbsp;<code>(r - 1, c)</code>&nbsp;，前提是相邻格子在网格图内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/29/example.png\" style=\"width: 241px; height: 161px;\"></p>\n\n<pre><b>输入：</b>grid = [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]\n<b>输出：</b>7\n<b>解释：</b>渔夫可以从格子 <code>(1,3)</code> 出发，捕捞 3 条鱼，然后移动到格子 <code>(2,3)</code>&nbsp;，捕捞 4 条鱼。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/29/example2.png\"></p>\n\n<pre><b>输入：</b>grid = [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]\n<b>输出：</b>1\n<b>解释：</b>渔夫可以从格子 (0,0) 或者 (3,3) ，捕捞 1 条鱼。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2659.将数组清空",
        "hardRate": "HARD",
        "passRate": "38.50%",
        "problemsUrl": "https://leetcode.cn/problems/make-array-empty/",
        "solutionsUrl": "https://leetcode.cn/problems/make-array-empty/solution",
        "problemsDesc": "<p>给你一个包含若干 <strong>互不相同</strong>&nbsp;整数的数组&nbsp;<code>nums</code>&nbsp;，你需要执行以下操作 <strong>直到</strong><strong>数组为空</strong>&nbsp;：</p>\n\n<ul>\n\t<li>如果数组中第一个元素是当前数组中的 <strong>最小值</strong>&nbsp;，则删除它。</li>\n\t<li>否则，将第一个元素移动到数组的 <strong>末尾</strong>&nbsp;。</li>\n</ul>\n\n<p>请你返回需要多少个操作使<em>&nbsp;</em><code>nums</code><em>&nbsp;</em>为空。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,4,-1]\n<b>输出：</b>5\n</pre>\n\n<table style=\"border: 2px solid black; border-collapse: collapse;\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Operation</th>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Array</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">1</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[4, -1, 3]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">2</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[-1, 3, 4]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">3</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[3, 4]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">4</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[4]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">5</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[]</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,4,3]\n<b>输出：</b>5\n</pre>\n\n<table style=\"border: 2px solid black; border-collapse: collapse;\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Operation</th>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Array</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">1</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[2, 4, 3]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">2</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[4, 3]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">3</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[3, 4]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">4</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[4]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">5</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[]</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3]\n<b>输出：</b>3\n</pre>\n\n<table style=\"border: 2px solid black; border-collapse: collapse;\">\n\t<thead>\n\t\t<tr>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Operation</th>\n\t\t\t<th style=\"border: 2px solid black; padding: 5px;\">Array</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">1</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[2, 3]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">2</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[3]</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">3</td>\n\t\t\t<td style=\"border: 2px solid black; padding: 5px;\">[]</td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9&nbsp;</sup>&lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums</code>&nbsp;中的元素 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2660.保龄球游戏的获胜者",
        "hardRate": "EASY",
        "passRate": "33.51%",
        "problemsUrl": "https://leetcode.cn/problems/determine-the-winner-of-a-bowling-game/",
        "solutionsUrl": "https://leetcode.cn/problems/determine-the-winner-of-a-bowling-game/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong> 开始的整数数组 <code>player1</code> 和 <code>player2</code> ，分别表示玩家 1 和玩家 2 击中的瓶数。</p>\n\n<p>保龄球比赛由 <code>n</code> 轮组成，每轮的瓶数恰好为 <code>10</code> 。</p>\n\n<p>假设玩家在第 <code>i</code> 轮中击中&nbsp;<code>x<sub>i</sub></code> 个瓶子。玩家第 <code>i</code> 轮的价值为：</p>\n\n<ul>\n\t<li>如果玩家在该轮的前两轮的任何一轮中击中了 <code>10</code> 个瓶子，则为 <code>2x<sub>i</sub></code> 。</li>\n\t<li>否则，为&nbsp;<code>x<sub>i</sub></code> 。</li>\n</ul>\n\n<p>玩家的得分是其 <code>n</code> 轮价值的总和。</p>\n\n<p>返回</p>\n\n<ul>\n\t<li>如果玩家 1 的得分高于玩家 2 的得分，则为 <code>1</code> ；</li>\n\t<li>如果玩家 2 的得分高于玩家 1 的得分，则为 <code>2</code> ；</li>\n\t<li>如果平局，则为 <code>0</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>player1 = [4,10,7,9], player2 = [6,5,2,3]\n<strong>输出：</strong>1\n<strong>解释：</strong>player1 的得分是 4 + 10 + 2*7 + 2*9 = 46 。\nplayer2 的得分是 6 + 5 + 2 + 3 = 16 。\nplayer1 的得分高于 player2 的得分，所以 play1 在比赛中获胜，答案为 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>player1 = [3,5,7,6], player2 = [8,10,10,2]\n<strong>输出：</strong>2\n<strong>解释：</strong>player1 的得分是 3 + 5 + 7 + 6 = 21 。\nplayer2 的得分是 8 + 10 + 2*10 + 2*2 = 42 。\nplayer2 的得分高于 player1 的得分，所以 play2 在比赛中获胜，答案为 2 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>player1 = [2,3], player2 = [4,1]\n<strong>输出：</strong>0\n<strong>解释：</strong>player1 的得分是 2 + 3 = 5 。\nplayer2 的得分是 4 + 1 = 5 。\nplayer1 的得分等于 player2 的得分，所以这一场比赛平局，答案为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == player1.length == player2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= player1[i], player2[i] &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2661.找出叠涂元素",
        "hardRate": "MEDIUM",
        "passRate": "51.18%",
        "problemsUrl": "https://leetcode.cn/problems/first-completely-painted-row-or-column/",
        "solutionsUrl": "https://leetcode.cn/problems/first-completely-painted-row-or-column/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>arr</code> 和一个 <code>m x n</code> 的整数 <strong>矩阵</strong> <code>mat</code> 。<code>arr</code> 和 <code>mat</code> 都包含范围 <code>[1，m * n]</code> 内的 <strong>所有</strong> 整数。</p>\n\n<p>从下标 <code>0</code> 开始遍历 <code>arr</code> 中的每个下标 <code>i</code> ，并将包含整数 <code>arr[i]</code> 的 <code>mat</code> 单元格涂色。</p>\n\n<p>请你找出 <code>arr</code> 中在 <code>mat</code> 的某一行或某一列上都被涂色且下标最小的元素，并返回其下标 <code>i</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"image explanation for example 1\" src=\"https://assets.leetcode.com/uploads/2023/01/18/grid1.jpg\" style=\"width: 321px; height: 81px;\" />\n<pre>\n<strong>输入：</strong>arr = [1,3,4,2], mat = [[1,4],[2,3]]\n<strong>输出：</strong>2\n<strong>解释：</strong>遍历如上图所示，arr[2] 在矩阵中的第一行或第二列上都被涂色。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"image explanation for example 2\" src=\"https://assets.leetcode.com/uploads/2023/01/18/grid2.jpg\" style=\"width: 601px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]]\n<strong>输出：</strong>3\n<strong>解释：</strong>遍历如上图所示，arr[3] 在矩阵中的第二列上都被涂色。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n = mat[i].length</code></li>\n\t<li><code>arr.length == m * n</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i], mat[r][c] &lt;= m * n</code></li>\n\t<li><code>arr</code> 中的所有整数 <strong>互不相同</strong></li>\n\t<li><code>mat</code> 中的所有整数 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2662.前往目标的最小代价",
        "hardRate": "MEDIUM",
        "passRate": "36.38%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-of-a-path-with-special-roads/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-of-a-path-with-special-roads/solution",
        "problemsDesc": "<p>给你一个数组 <code>start</code> ，其中 <code>start = [startX, startY]</code> 表示你的初始位置位于二维空间上的 <code>(startX, startY)</code> 。另给你一个数组 <code>target</code> ，其中 <code>target = [targetX, targetY]</code> 表示你的目标位置 <code>(targetX, targetY)</code> 。</p>\n\n<p>从位置 <code>(x1, y1)</code> 到空间中任一其他位置 <code>(x2, y2)</code> 的代价是 <code>|x2 - x1| + |y2 - y1|</code> 。</p>\n\n<p>给你一个二维数组 <code>specialRoads</code> ，表示空间中存在的一些特殊路径。其中 <code>specialRoads[i] = [x1<sub>i</sub>, y1<sub>i</sub>, x2<sub>i</sub>, y2<sub>i</sub>, cost<sub>i</sub>]</code> 表示第 <code>i</code> 条特殊路径可以从 <code>(x1<sub>i</sub>, y1<sub>i</sub>)</code> 到 <code>(x2<sub>i</sub>, y2<sub>i</sub>)</code> ，但成本等于 <code>cost<sub>i</sub></code> 。你可以使用每条特殊路径任意次数。</p>\n\n<p>返回从 <code>(startX, startY)</code> 到 <code>(targetX, targetY)</code> 所需的最小代价。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>start = [1,1], target = [4,5], specialRoads = [[1,2,3,3,2],[3,4,4,5,1]]\n<strong>输出：</strong>5\n<strong>解释：</strong>从 (1,1) 到 (4,5) 的最优路径如下：\n- (1,1) -&gt; (1,2) ，移动的代价是 |1 - 1| + |2 - 1| = 1 。\n- (1,2) -&gt; (3,3) ，移动使用第一条特殊路径，代价是 2 。\n- (3,3) -&gt; (3,4) ，移动的代价是 |3 - 3| + |4 - 3| = 1.\n- (3,4) -&gt; (4,5) ，移动使用第二条特殊路径，代价是 1 。\n总代价是 1 + 2 + 1 + 1 = 5 。\n可以证明无法以小于 5 的代价完成从 (1,1) 到 (4,5) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>start = [3,2], target = [5,7], specialRoads = [[3,2,3,4,4],[3,3,5,5,5],[3,4,5,6,6]]\n<strong>输出：</strong>7\n<strong>解释：</strong>最优路径是不使用任何特殊路径，直接以 |5 - 3| + |7 - 2| = 7 的代价从初始位置到达目标位置。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>start.length == target.length == 2</code></li>\n\t<li><code>1 &lt;= startX &lt;= targetX &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= startY &lt;= targetY &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= specialRoads.length &lt;= 200</code></li>\n\t<li><code>specialRoads[i].length == 5</code></li>\n\t<li><code>startX &lt;= x1<sub>i</sub>, x2<sub>i</sub> &lt;= targetX</code></li>\n\t<li><code>startY &lt;= y1<sub>i</sub>, y2<sub>i</sub> &lt;= targetY</code></li>\n\t<li><code>1 &lt;= cost<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2663.字典序最小的美丽字符串",
        "hardRate": "HARD",
        "passRate": "45.72%",
        "problemsUrl": "https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/",
        "solutionsUrl": "https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/solution",
        "problemsDesc": "<p>如果一个字符串满足以下条件，则称其为 <strong>美丽字符串</strong> ：</p>\n\n<ul>\n\t<li>它由英语小写字母表的前 <code>k</code> 个字母组成。</li>\n\t<li>它不包含任何长度为 <code>2</code> 或更长的回文子字符串。</li>\n</ul>\n\n<p>给你一个长度为 <code>n</code> 的美丽字符串 <code>s</code> 和一个正整数 <code>k</code> 。</p>\n\n<p>请你找出并返回一个长度为 <code>n</code> 的美丽字符串，该字符串还满足：在字典序大于 <code>s</code> 的所有美丽字符串中字典序最小。如果不存在这样的字符串，则返回一个空字符串。</p>\n\n<p>对于长度相同的两个字符串 <code>a</code> 和 <code>b</code> ，如果字符串 <code>a</code> 在与字符串 <code>b</code> 不同的第一个位置上的字符字典序更大，则字符串 <code>a</code> 的字典序大于字符串 <code>b</code> 。</p>\n\n<ul>\n\t<li>例如，<code>\"abcd\"</code> 的字典序比 <code>\"abcc\"</code> 更大，因为在不同的第一个位置（第四个字符）上 <code>d</code> 的字典序大于 <code>c</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcz\", k = 26\n<strong>输出：</strong>\"abda\"\n<strong>解释：</strong>字符串 \"abda\" 既是美丽字符串，又满足字典序大于 \"abcz\" 。\n可以证明不存在字符串同时满足字典序大于 \"abcz\"、美丽字符串、字典序小于 \"abda\" 这三个条件。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"dc\", k = 4\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>可以证明，不存在既是美丽字符串，又字典序大于 \"dc\" 的字符串。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>4 &lt;= k &lt;= 26</code></li>\n\t<li><code>s</code> 是一个美丽字符串</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2664.巡逻的骑士",
        "hardRate": "MEDIUM",
        "passRate": "64.22%",
        "problemsUrl": "https://leetcode.cn/problems/the-knights-tour/",
        "solutionsUrl": "https://leetcode.cn/problems/the-knights-tour/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2665.计数器 II",
        "hardRate": "EASY",
        "passRate": "62.38%",
        "problemsUrl": "https://leetcode.cn/problems/counter-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/counter-ii/solution",
        "problemsDesc": "<p>请你写一个函数&nbsp;<code>createCounter</code>. 这个函数接收一个初始的整数值 <code>init</code>&nbsp;&nbsp;并返回一个包含三个函数的对象。</p>\n\n<p>这三个函数是：</p>\n\n<ul>\n\t<li><code>increment()</code>&nbsp;将当前值加 1 并返回。</li>\n\t<li><code>decrement()</code>&nbsp;将当前值减 1 并返回。</li>\n\t<li><code>reset()</code>&nbsp;将当前值设置为 <code>init</code> 并返回。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>init = 5, calls = [\"increment\",\"reset\",\"decrement\"]\n<b>输出：</b>[6,5,4]\n<strong>解释：</strong>\nconst counter = createCounter(5);\ncounter.increment(); // 6\ncounter.reset(); // 5\ncounter.decrement(); // 4\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>init = 0, calls = [\"increment\",\"increment\",\"decrement\",\"reset\",\"reset\"]\n<b>输出：</b>[1,2,1,0,0]\n<strong>解释：</strong>\nconst counter = createCounter(0);\ncounter.increment(); // 1\ncounter.increment(); // 2\ncounter.decrement(); // 1\ncounter.reset(); // 0\ncounter.reset(); // 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-1000 &lt;= init &lt;= 1000</code></li>\n\t<li><code>总调用次数不会超过&nbsp;1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2666.只允许一次函数调用",
        "hardRate": "EASY",
        "passRate": "81.84%",
        "problemsUrl": "https://leetcode.cn/problems/allow-one-function-call/",
        "solutionsUrl": "https://leetcode.cn/problems/allow-one-function-call/solution",
        "problemsDesc": "<p>给定一个函数 <code>fn</code> ，它返回一个新的函数，返回的函数与原始函数完全相同，只不过它确保 <code>fn</code> 最多被调用一次。</p>\n\n<ul>\n\t<li>第一次调用返回的函数时，它应该返回与 <code>fn</code> 相同的结果。</li>\n\t<li>第一次后的每次调用，它应该返回 <code>undefined</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre>\n<b>输入：</b>fn = (a,b,c) =&gt; (a + b + c), calls = [[1,2,3],[2,3,6]]\n<b>输出：</b>[{\"calls\":1,\"value\":6}]\n<strong>解释：</strong>\nconst onceFn = once(fn);\nonceFn(1, 2, 3); // 6\nonceFn(2, 3, 6); // undefined, fn 没有被调用\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>fn = (a,b,c) =&gt; (a * b * c), calls = [[5,7,4],[2,3,6],[4,6,8]]\n<b>输出：</b>[{\"calls\":1,\"value\":140}]\n<strong>解释：</strong>\nconst onceFn = once(fn);\nonceFn(5, 7, 4); // 140\nonceFn(2, 3, 6); // undefined, fn 没有被调用\nonceFn(4, 6, 8); // undefined, fn 没有被调用\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= calls.length &lt;= 10</code></li>\n\t<li><code>1 &lt;= calls[i].length &lt;= 100</code></li>\n\t<li><code>2 &lt;= JSON.stringify(calls).length &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2667.创建 Hello World 函数",
        "hardRate": "EASY",
        "passRate": "86.51%",
        "problemsUrl": "https://leetcode.cn/problems/create-hello-world-function/",
        "solutionsUrl": "https://leetcode.cn/problems/create-hello-world-function/solution",
        "problemsDesc": "请你编写一个名为 <code>createHelloWorld</code> 的函数。它应该返回一个新的函数，该函数总是返回 <code>\"Hello World\"</code>&nbsp;。\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>args = []\n<b>输出：</b>\"Hello World\"\n<strong>解释：</strong>\nconst f = createHelloWorld();\nf(); // \"Hello World\"\n\ncreateHelloWorld 返回的函数应始终返回 \"Hello World\"。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>args = [{},null,42]\n<b>输出：</b>\"Hello World\"\n<strong>解释：</strong>\nconst f = createHelloWorld();\nf({}, null, 42); // \"Hello World\"\n\n可以传递任何参数给函数，但它应始终返回 \"Hello World\"。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= args.length &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2668.查询员工当前薪水",
        "hardRate": "EASY",
        "passRate": "67.92%",
        "problemsUrl": "https://leetcode.cn/problems/find-latest-salaries/",
        "solutionsUrl": "https://leetcode.cn/problems/find-latest-salaries/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2669.统计 Spotify 排行榜上艺术家出现次数",
        "hardRate": "EASY",
        "passRate": "72.36%",
        "problemsUrl": "https://leetcode.cn/problems/count-artist-occurrences-on-spotify-ranking-list/",
        "solutionsUrl": "https://leetcode.cn/problems/count-artist-occurrences-on-spotify-ranking-list/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2670.找出不同元素数目差数组",
        "hardRate": "EASY",
        "passRate": "75.70%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-distinct-difference-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-distinct-difference-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，数组长度为 <code>n</code> 。</p>\n\n<p><code>nums</code> 的 <strong>不同元素数目差</strong> 数组可以用一个长度为 <code>n</code> 的数组 <code>diff</code> 表示，其中 <code>diff[i]</code> 等于前缀 <code>nums[0, ..., i]</code> 中不同元素的数目 <strong>减去</strong> 后缀 <code>nums[i + 1, ..., n - 1]</code> 中不同元素的数目。</p>\n\n<p>返回<em> </em><code>nums</code> 的 <strong>不同元素数目差</strong> 数组。</p>\n\n<p>注意 <code>nums[i, ..., j]</code> 表示 <code>nums</code> 的一个从下标 <code>i</code> 开始到下标 <code>j</code> 结束的子数组（包含下标 <code>i</code> 和 <code>j</code> 对应元素）。特别需要说明的是，如果 <code>i &gt; j</code> ，则 <code>nums[i, ..., j]</code> 表示一个空子数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4,5]\n<strong>输出：</strong>[-3,-1,1,3,5]\n<strong>解释：\n</strong>对于 i = 0，前缀中有 1 个不同的元素，而在后缀中有 4 个不同的元素。因此，diff[0] = 1 - 4 = -3 。\n对于 i = 1，前缀中有 2 个不同的元素，而在后缀中有 3 个不同的元素。因此，diff[1] = 2 - 3 = -1 。\n对于 i = 2，前缀中有 3 个不同的元素，而在后缀中有 2 个不同的元素。因此，diff[2] = 3 - 2 = 1 。\n对于 i = 3，前缀中有 4 个不同的元素，而在后缀中有 1 个不同的元素。因此，diff[3] = 4 - 1 = 3 。\n对于 i = 4，前缀中有 5 个不同的元素，而在后缀中有 0 个不同的元素。因此，diff[4] = 5 - 0 = 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,3,4,2]\n<strong>输出：</strong>[-2,-1,0,2,3]\n<strong>解释：</strong>\n对于 i = 0，前缀中有 1 个不同的元素，而在后缀中有 3 个不同的元素。因此，diff[0] = 1 - 3 = -2 。\n对于 i = 1，前缀中有 2 个不同的元素，而在后缀中有 3 个不同的元素。因此，diff[1] = 2 - 3 = -1 。\n对于 i = 2，前缀中有 2 个不同的元素，而在后缀中有 2 个不同的元素。因此，diff[2] = 2 - 2 = 0 。\n对于 i = 3，前缀中有 3 个不同的元素，而在后缀中有 1 个不同的元素。因此，diff[3] = 3 - 1 = 2 。\n对于 i = 4，前缀中有 3 个不同的元素，而在后缀中有 0 个不同的元素。因此，diff[4] = 3 - 0 = 3 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == nums.length&nbsp;&lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2671.频率跟踪器",
        "hardRate": "MEDIUM",
        "passRate": "32.49%",
        "problemsUrl": "https://leetcode.cn/problems/frequency-tracker/",
        "solutionsUrl": "https://leetcode.cn/problems/frequency-tracker/solution",
        "problemsDesc": "<p>请你设计并实现一个能够对其中的值进行跟踪的数据结构，并支持对频率相关查询进行应答。</p>\n\n<p>实现 <code>FrequencyTracker</code> 类：</p>\n\n<ul>\n\t<li><code>FrequencyTracker()</code>：使用一个空数组初始化 <code>FrequencyTracker</code> 对象。</li>\n\t<li><code>void add(int number)</code>：添加一个 <code>number</code> 到数据结构中。</li>\n\t<li><code>void deleteOne(int number)</code>：从数据结构中删除一个 <code>number</code> 。数据结构 <strong>可能不包含</strong> <code>number</code> ，在这种情况下不删除任何内容。</li>\n\t<li><code>bool hasFrequency(int frequency)</code>: 如果数据结构中存在出现 <code>frequency</code> 次的数字，则返回 <code>true</code>，否则返回 <code>false</code>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"FrequencyTracker\", \"add\", \"add\", \"hasFrequency\"]\n[[], [3], [3], [2]]\n<strong>输出</strong>\n[null, null, null, true]\n\n<strong>解释</strong>\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.add(3); // 数据结构现在包含 [3]\nfrequencyTracker.add(3); // 数据结构现在包含 [3, 3]\nfrequencyTracker.hasFrequency(2); // 返回 true ，因为 3 出现 2 次\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"FrequencyTracker\", \"add\", \"deleteOne\", \"hasFrequency\"]\n[[], [1], [1], [1]]\n<strong>输出</strong>\n[null, null, null, false]\n\n<strong>解释</strong>\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.add(1); // 数据结构现在包含 [1]\nfrequencyTracker.deleteOne(1); // 数据结构现在为空 []\nfrequencyTracker.hasFrequency(1); // 返回 false ，因为数据结构为空\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"FrequencyTracker\", \"hasFrequency\", \"add\", \"hasFrequency\"]\n[[], [2], [3], [1]]\n<strong>输出</strong>\n[null, false, null, true]\n\n<strong>解释</strong>\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.hasFrequency(2); // 返回 false ，因为数据结构为空\nfrequencyTracker.add(3); // 数据结构现在包含 [3]\nfrequencyTracker.hasFrequency(1); // 返回 true ，因为 3 出现 1 次\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= number &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= frequency &lt;= 10<sup>5</sup></code></li>\n\t<li>最多调用 <code>add</code>、<code>deleteOne</code> 和 <code>hasFrequency</code> <strong>共计</strong> <code>2 *&nbsp;10<sup>5</sup></code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2672.有相同颜色的相邻元素数目",
        "hardRate": "MEDIUM",
        "passRate": "58.35%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-adjacent-elements-with-the-same-color/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-adjacent-elements-with-the-same-color/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始、长度为 <code>n</code>&nbsp;的数组&nbsp;<code>nums</code>&nbsp;。一开始，所有元素都是 <strong>未染色</strong>&nbsp;（值为 <code>0</code>&nbsp;）的。</p>\n\n<p>给你一个二维整数数组&nbsp;<code>queries</code>&nbsp;，其中&nbsp;<code>queries[i] = [index<sub>i</sub>, color<sub>i</sub>]</code>&nbsp;。</p>\n\n<p>对于每个操作，你需要将数组 <code>nums</code>&nbsp;中下标为&nbsp;<code>index<sub>i</sub></code>&nbsp;的格子染色为&nbsp;<code>color<sub>i</sub></code>&nbsp;。</p>\n\n<p>请你返回一个长度与 <code>queries</code>&nbsp;相等的数组<em>&nbsp;</em><code>answer</code><em>&nbsp;</em>，其中<em>&nbsp;</em><code>answer[i]</code>是前 <code>i</code>&nbsp;个操作&nbsp;<strong>之后</strong>&nbsp;，相邻元素颜色相同的数目。</p>\n\n<p>更正式的，<code>answer[i]</code>&nbsp;是执行完前 <code>i</code>&nbsp;个操作后，<code>0 &lt;= j &lt; n - 1</code>&nbsp;的下标 <code>j</code>&nbsp;中，满足&nbsp;<code>nums[j] == nums[j + 1]</code> 且&nbsp;<code>nums[j] != 0</code>&nbsp;的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 4, queries = [[0,2],[1,2],[3,1],[1,1],[2,1]]\n<b>输出：</b>[0,1,1,0,2]\n<b>解释：</b>一开始数组 nums = [0,0,0,0] ，0 表示数组中还没染色的元素。\n- 第 1 个操作后，nums = [2,0,0,0] 。相邻元素颜色相同的数目为 0 。\n- 第 2 个操作后，nums = [2,2,0,0] 。相邻元素颜色相同的数目为 1 。\n- 第 3 个操作后，nums = [2,2,0,1] 。相邻元素颜色相同的数目为 1 。\n- 第 4 个操作后，nums = [2,1,0,1] 。相邻元素颜色相同的数目为 0 。\n- 第 5 个操作后，nums = [2,1,1,1] 。相邻元素颜色相同的数目为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 1, queries = [[0,100000]]\n<b>输出：</b>[0]\n<b>解释：</b>一开始数组 nums = [0] ，0 表示数组中还没染色的元素。\n- 第 1 个操作后，nums = [100000] 。相邻元素颜色相同的数目为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length&nbsp;== 2</code></li>\n\t<li><code>0 &lt;= index<sub>i</sub>&nbsp;&lt;= n - 1</code></li>\n\t<li><code>1 &lt;=&nbsp; color<sub>i</sub>&nbsp;&lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2673.使二叉树所有路径值相等的最小代价",
        "hardRate": "MEDIUM",
        "passRate": "66.26%",
        "problemsUrl": "https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;表示一棵 <b>满二叉树</b>&nbsp;里面节点的数目，节点编号从 <code>1</code>&nbsp;到 <code>n</code>&nbsp;。根节点编号为 <code>1</code>&nbsp;，树中每个非叶子节点&nbsp;<code>i</code>&nbsp;都有两个孩子，分别是左孩子&nbsp;<code>2 * i</code>&nbsp;和右孩子&nbsp;<code>2 * i + 1</code>&nbsp;。</p>\n\n<p>树中每个节点都有一个值，用下标从<b>&nbsp;0</b>&nbsp;开始、长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>cost</code>&nbsp;表示，其中&nbsp;<code>cost[i]</code>&nbsp;是第&nbsp;<code>i + 1</code>&nbsp;个节点的值。每次操作，你可以将树中&nbsp;<strong>任意</strong>&nbsp;节点的值&nbsp;<strong>增加</strong>&nbsp;<code>1</code>&nbsp;。你可以执行操作 <strong>任意</strong> 次。</p>\n\n<p>你的目标是让根到每一个 <strong>叶子结点</strong>&nbsp;的路径值相等。请你返回 <strong>最少</strong>&nbsp;需要执行增加操作多少次。</p>\n\n<p><b>注意：</b></p>\n\n<ul>\n\t<li><strong>满二叉树</strong>&nbsp;指的是一棵树，它满足树中除了叶子节点外每个节点都恰好有 2 个节点，且所有叶子节点距离根节点距离相同。</li>\n\t<li><strong>路径值</strong> 指的是路径上所有节点的值之和。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/04/binaryytreeedrawio-4.png\" /></p>\n\n<pre>\n<b>输入：</b>n = 7, cost = [1,5,2,2,3,3,1]\n<b>输出：</b>6\n<b>解释：</b>我们执行以下的增加操作：\n- 将节点 4 的值增加一次。\n- 将节点 3 的值增加三次。\n- 将节点 7 的值增加两次。\n从根到叶子的每一条路径值都为 9 。\n总共增加次数为 1 + 3 + 2 = 6 。\n这是最小的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/04/binaryytreee2drawio.png\" style=\"width: 205px; height: 151px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 3, cost = [5,3,3]\n<b>输出：</b>0\n<b>解释：</b>两条路径已经有相等的路径值，所以不需要执行任何增加操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>n + 1</code> 是&nbsp;<code>2</code>&nbsp;的幂</li>\n\t<li><code>cost.length == n</code></li>\n\t<li><code>1 &lt;= cost[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2674.拆分循环链表",
        "hardRate": "MEDIUM",
        "passRate": "82.65%",
        "problemsUrl": "https://leetcode.cn/problems/split-a-circular-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/split-a-circular-linked-list/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2675.将对象数组转换为矩阵",
        "hardRate": "MEDIUM",
        "passRate": "61.15%",
        "problemsUrl": "https://leetcode.cn/problems/array-of-objects-to-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/array-of-objects-to-matrix/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2676.节流",
        "hardRate": "MEDIUM",
        "passRate": "43.71%",
        "problemsUrl": "https://leetcode.cn/problems/throttle/",
        "solutionsUrl": "https://leetcode.cn/problems/throttle/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2677.分块数组",
        "hardRate": "EASY",
        "passRate": "72.19%",
        "problemsUrl": "https://leetcode.cn/problems/chunk-array/",
        "solutionsUrl": "https://leetcode.cn/problems/chunk-array/solution",
        "problemsDesc": "<p>给定一个数组&nbsp;<code>arr</code>&nbsp;和一个块大小&nbsp;<code>size</code>&nbsp;，返回一个 <strong>分块</strong>&nbsp;的数组。<strong>分块</strong>&nbsp;的数组包含了&nbsp;<code>arr</code>&nbsp;中的原始元素，但是每个子数组的长度都是&nbsp;<code>size</code>&nbsp;。如果&nbsp;<code>arr.length</code>&nbsp;不能被&nbsp;<code>size</code>&nbsp;整除，那么最后一个子数组的长度可能小于&nbsp;<code>size</code>&nbsp;。</p>\n\n<p>你可以假设该数组是&nbsp;<code>JSON.parse</code>&nbsp;的输出结果。换句话说，它是有效的JSON。</p>\n\n<p>请你在不使用 lodash 的函数&nbsp;<code>_.chunk</code>&nbsp;的情况下解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [1,2,3,4,5], size = 1\n<b>输出：</b>[[1],[2],[3],[4],[5]]\n<b>解释：</b>数组 <code>arr </code>被分割成了每个只有一个元素的子数组。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [1,9,6,3,2], size = 3\n<b>输出：</b>[[1,9,6],[3,2]]\n<b>解释：</b>数组 <code>arr </code>被分割成了每个有三个元素的子数组。然而，第二个子数组只有两个元素。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [8,5,3,2,6], size = 6\n<b>输出：</b>[[8,5,3,2,6]]\n<b>解释：</b><code>size </code>大于 <code>arr.length </code>，因此所有元素都在第一个子数组中。\n</pre>\n\n<p><strong class=\"example\">示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [], size = 1\n<b>输出：</b>[]\n<b>解释：</b>没有元素需要分块，因此返回一个空数组。</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>arr is a valid JSON array</code></li>\n\t<li><code>2 &lt;= JSON.stringify(arr).length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= size &lt;= arr.length + 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2678.老人的数目",
        "hardRate": "EASY",
        "passRate": "83.42%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-senior-citizens/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-senior-citizens/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>details</code>&nbsp;。<code>details</code>&nbsp;中每个元素都是一位乘客的信息，信息用长度为 <code>15</code>&nbsp;的字符串表示，表示方式如下：</p>\n\n<ul>\n\t<li>前十个字符是乘客的手机号码。</li>\n\t<li>接下来的一个字符是乘客的性别。</li>\n\t<li>接下来两个字符是乘客的年龄。</li>\n\t<li>最后两个字符是乘客的座位号。</li>\n</ul>\n\n<p>请你返回乘客中年龄 <strong>严格大于 60 岁</strong>&nbsp;的人数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>details = [\"7868190130M7522\",\"5303914400F9211\",\"9273338290F4010\"]\n<b>输出：</b>2\n<b>解释：</b>下标为 0 ，1 和 2 的乘客年龄分别为 75 ，92 和 40 。所以有 2 人年龄大于 60 岁。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>details = [\"1313579440F2036\",\"2921522980M5644\"]\n<b>输出：</b>0\n<b>解释：</b>没有乘客的年龄大于 60 岁。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= details.length &lt;= 100</code></li>\n\t<li><code>details[i].length == 15</code></li>\n\t<li><code>details[i]</code>&nbsp;中的数字只包含&nbsp;<code>'0'</code>&nbsp;到&nbsp;<code>'9'</code>&nbsp;。</li>\n\t<li><code>details[i][10]</code>&nbsp;是 <code>'M'</code>&nbsp;，<code>'F'</code>&nbsp;或者&nbsp;<code>'O'</code>&nbsp;之一。</li>\n\t<li>所有乘客的手机号码和座位号互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2679.矩阵中的和",
        "hardRate": "MEDIUM",
        "passRate": "80.01%",
        "problemsUrl": "https://leetcode.cn/problems/sum-in-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-in-a-matrix/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>nums</code>&nbsp;。一开始你的分数为&nbsp;<code>0</code>&nbsp;。你需要执行以下操作直到矩阵变为空：</p>\n\n<ol>\n\t<li>矩阵中每一行选取最大的一个数，并删除它。如果一行中有多个最大的数，选择任意一个并删除。</li>\n\t<li>在步骤 1 删除的所有数字中找到最大的一个数字，将它添加到你的 <strong>分数</strong>&nbsp;中。</li>\n</ol>\n\n<p>请你返回最后的 <strong>分数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [[7,2,1],[6,4,2],[6,5,3],[3,2,1]]\n<b>输出：</b>15\n<b>解释：</b>第一步操作中，我们删除 7 ，6 ，6 和 3 ，将分数增加 7 。下一步操作中，删除 2 ，4 ，5 和 2 ，将分数增加 5 。最后删除 1 ，2 ，3 和 1 ，将分数增加 3 。所以总得分为 7 + 5 + 3 = 15 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [[1]]\n<b>输出：</b>1\n<b>解释：</b>我们删除 1 并将分数增加 1 ，所以返回 1 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= nums[i].length &lt;= 500</code></li>\n\t<li><code>0 &lt;= nums[i][j] &lt;= 10<sup>3</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2680.最大或值",
        "hardRate": "MEDIUM",
        "passRate": "42.65%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-or/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-or/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code> 。每一次操作中，你可以选择一个数并将它乘&nbsp;<code>2</code>&nbsp;。</p>\n\n<p>你最多可以进行 <code>k</code>&nbsp;次操作，请你返回<em>&nbsp;</em><code>nums[0] | nums[1] | ... | nums[n - 1]</code>&nbsp;的最大值。</p>\n\n<p><code>a | b</code>&nbsp;表示两个整数 <code>a</code>&nbsp;和 <code>b</code>&nbsp;的 <strong>按位或</strong>&nbsp;运算。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [12,9], k = 1\n<b>输出：</b>30\n<b>解释：</b>如果我们对下标为 1 的元素进行操作，新的数组为 [12,18] 。此时得到最优答案为 12 和 18 的按位或运算的结果，也就是 30 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [8,1,2], k = 2\n<b>输出：</b>35\n<b>解释：</b>如果我们对下标 0 处的元素进行操作，得到新数组 [32,1,2] 。此时得到最优答案为 32|1|2 = 35 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 15</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2681.英雄的力量",
        "hardRate": "HARD",
        "passRate": "35.98%",
        "problemsUrl": "https://leetcode.cn/problems/power-of-heroes/",
        "solutionsUrl": "https://leetcode.cn/problems/power-of-heroes/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，它表示英雄的能力值。如果我们选出一部分英雄，这组英雄的 <strong>力量</strong>&nbsp;定义为：</p>\n\n<ul>\n\t<li><code>i<sub>0</sub></code>&nbsp;，<code>i<sub>1</sub></code>&nbsp;，<span style=\"\">... </span><code><span style=\"\">i<sub>k</sub></span></code><span style=\"\">&nbsp;</span>表示这组英雄在数组中的下标。那么这组英雄的力量为&nbsp;<code><font face=\"monospace\">max(nums[</font>i<sub>0</sub><font face=\"monospace\">],nums[</font>i<sub>1</sub><font face=\"monospace\">] ... nums[</font><span style=\"font-size:10.8333px\">i<sub>k</sub></span><font face=\"monospace\">])<sup>2</sup> * min(nums[</font>i<sub>0</sub><font face=\"monospace\">],nums[</font>i<sub>1</sub><font face=\"monospace\">] ... nums[</font><span style=\"font-size:10.8333px\">i<sub>k</sub></span><font face=\"monospace\">])</font></code> 。</li>\n</ul>\n\n<p>请你返回所有可能的 <strong>非空</strong> 英雄组的 <strong>力量</strong> 之和。由于答案可能非常大，请你将结果对&nbsp;<code>10<sup>9 </sup>+ 7</code>&nbsp;<strong>取余。</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,1,4]\n<b>输出：</b>141\n<b>解释：</b>\n第 1&nbsp;组：[2] 的力量为 2<sup>2</sup>&nbsp;* 2 = 8 。\n第 2&nbsp;组：[1] 的力量为 1<sup>2</sup> * 1 = 1 。\n第 3&nbsp;组：[4] 的力量为 4<sup>2</sup> * 4 = 64 。\n第 4&nbsp;组：[2,1] 的力量为 2<sup>2</sup> * 1 = 4 。\n第 5 组：[2,4] 的力量为 4<sup>2</sup> * 2 = 32 。\n第 6&nbsp;组：[1,4] 的力量为 4<sup>2</sup> * 1 = 16 。\n第​ ​​​​​​7&nbsp;组：[2,1,4] 的力量为 4<sup>2</sup>​​​​​​​ * 1 = 16 。\n所有英雄组的力量之和为 8 + 1 + 64 + 4 + 32 + 16 + 16 = 141 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,1,1]\n<b>输出：</b>7\n<b>解释：</b>总共有 7 个英雄组，每一组的力量都是 1 。所以所有英雄组的力量之和为 7 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2682.找出转圈游戏输家",
        "hardRate": "EASY",
        "passRate": "54.14%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-losers-of-the-circular-game/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-losers-of-the-circular-game/solution",
        "problemsDesc": "<p><code>n</code> 个朋友在玩游戏。这些朋友坐成一个圈，按 <strong>顺时针方向</strong> 从 <code>1</code> 到 <code>n</code> 编号。从第 <code>i</code> 个朋友的位置开始顺时针移动 <code>1</code> 步会到达第 <code>(i + 1)</code> 个朋友的位置（<code>1 &lt;= i &lt; n</code>），而从第 <code>n</code> 个朋友的位置开始顺时针移动 <code>1</code> 步会回到第 <code>1</code> 个朋友的位置。</p>\n\n<p>游戏规则如下：</p>\n\n<p>第 <code>1</code> 个朋友接球。</p>\n\n<ul>\n\t<li>接着，第 <code>1</code> 个朋友将球传给距离他顺时针方向 <code>k</code> 步的朋友。</li>\n\t<li>然后，接球的朋友应该把球传给距离他顺时针方向 <code>2 * k</code> 步的朋友。</li>\n\t<li>接着，接球的朋友应该把球传给距离他顺时针方向 <code>3 * k</code> 步的朋友，以此类推。</li>\n</ul>\n\n<p>换句话说，在第 <code>i</code> 轮中持有球的那位朋友需要将球传递给距离他顺时针方向 <code>i * k</code> 步的朋友。</p>\n\n<p>当某个朋友第 2 次接到球时，游戏结束。</p>\n\n<p>在整场游戏中没有接到过球的朋友是 <strong>输家</strong> 。</p>\n\n<p>给你参与游戏的朋友数量 <code>n</code> 和一个整数 <code>k</code> ，请按升序排列返回包含所有输家编号的数组 <code>answer</code> 作为答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, k = 2\n<strong>输出：</strong>[4,5]\n<strong>解释：</strong>以下为游戏进行情况：\n1）第 1 个朋友接球，第 <code>1</code> 个朋友将球传给距离他顺时针方向 2 步的玩家 —— 第 3 个朋友。\n2）第 3 个朋友将球传给距离他顺时针方向 4 步的玩家 —— 第 2 个朋友。\n3）第 2 个朋友将球传给距离他顺时针方向 6 步的玩家 —— 第 3 个朋友。\n4）第 3 个朋友接到两次球，游戏结束。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, k = 4\n<strong>输出：</strong>[2,3,4]\n<strong>解释：</strong>以下为游戏进行情况：\n1）第 1 个朋友接球，第 <code>1</code> 个朋友将球传给距离他顺时针方向 4 步的玩家 —— 第 1 个朋友。\n2）第 1 个朋友接到两次球，游戏结束。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2683.相邻值的按位异或",
        "hardRate": "MEDIUM",
        "passRate": "69.06%",
        "problemsUrl": "https://leetcode.cn/problems/neighboring-bitwise-xor/",
        "solutionsUrl": "https://leetcode.cn/problems/neighboring-bitwise-xor/solution",
        "problemsDesc": "<p>下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的数组 <code>derived</code> 是由同样长度为 <code>n</code> 的原始 <strong>二进制数组</strong> <code>original</code> 通过计算相邻值的 <strong>按位异或（⊕）</strong>派生而来。</p>\n\n<p>特别地，对于范围&nbsp;<code>[0, n - 1]</code> 内的每个下标 <code>i</code> ：</p>\n\n<ul>\n\t<li>如果 <code>i = n - 1</code> ，那么 <code>derived[i] = original[i] ⊕ original[0]</code></li>\n\t<li>否则 <code>derived[i] = original[i] ⊕ original[i + 1]</code></li>\n</ul>\n\n<p>给你一个数组 <code>derived</code> ，请判断是否存在一个能够派生得到 <code>derived</code> 的 <strong>有效原始二进制数组</strong> <code>original</code> 。</p>\n\n<p>如果存在满足要求的原始二进制数组，返回 <em><strong>true</strong> </em>；否则，返回<em> <strong>false</strong> </em>。</p>\n\n<ul>\n\t<li>二进制数组是仅由 <strong>0</strong> 和 <strong>1</strong> 组成的数组。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>derived = [1,1,0]\n<strong>输出：</strong>true\n<strong>解释：</strong>能够派生得到 [1,1,0] 的有效原始二进制数组是 [0,1,0] ：\nderived[0] = original[0] ⊕ original[1] = 0 ⊕ 1 = 1 \nderived[1] = original[1] ⊕ original[2] = 1 ⊕ 0 = 1\nderived[2] = original[2] ⊕ original[0] = 0 ⊕ 0 = 0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>derived = [1,1]\n<strong>输出：</strong>true\n<strong>解释：</strong>能够派生得到 [1,1] 的有效原始二进制数组是 [0,1] ：\nderived[0] = original[0] ⊕ original[1] = 1\nderived[1] = original[1] ⊕ original[0] = 1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>derived = [1,0]\n<strong>输出：</strong>false\n<strong>解释：</strong>不存在能够派生得到 [1,0] 的有效原始二进制数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == derived.length</code></li>\n\t<li><code>1 &lt;= n&nbsp;&lt;= 10<sup>5</sup></code></li>\n\t<li><code>derived</code> 中的值不是 <strong>0</strong> 就是 <strong>1</strong> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2684.矩阵中移动的最大次数",
        "hardRate": "MEDIUM",
        "passRate": "40.84%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-moves-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-moves-in-a-grid/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>m x n</code> 的矩阵 <code>grid</code> ，矩阵由若干 <strong>正</strong> 整数组成。</p>\n\n<p>你可以从矩阵第一列中的 <strong>任一</strong> 单元格出发，按以下方式遍历&nbsp;<code>grid</code> ：</p>\n\n<ul>\n\t<li>从单元格 <code>(row, col)</code> 可以移动到&nbsp;<code>(row - 1, col + 1)</code>、<code>(row, col + 1)</code> 和 <code>(row + 1, col + 1)</code> 三个单元格中任一满足值 <strong>严格</strong> 大于当前单元格的单元格。</li>\n</ul>\n\n<p>返回你在矩阵中能够 <strong>移动</strong> 的 <strong>最大</strong> 次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/11/yetgriddrawio-10.png\" style=\"width: 201px; height: 201px;\">\n<pre><strong>输入：</strong>grid = [[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]]\n<strong>输出：</strong>3\n<strong>解释：</strong>可以从单元格 (0, 0) 开始并且按下面的路径移动：\n- (0, 0) -&gt; (0, 1).\n- (0, 1) -&gt; (1, 2).\n- (1, 2) -&gt; (2, 3).\n可以证明这是能够移动的最大次数。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/12/yetgrid4drawio.png\">\n<strong>输入：</strong>grid = [[3,2,4],[2,1,9],[1,1,7]]\n<strong>输出：</strong>0\n<strong>解释：</strong>从第一列的任一单元格开始都无法移动。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2685.统计完全连通分量的数量",
        "hardRate": "MEDIUM",
        "passRate": "67.32%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-complete-components/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-complete-components/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> 。现有一个包含 <code>n</code> 个顶点的 <strong>无向</strong> 图，顶点按从 <code>0</code> 到 <code>n - 1</code> 编号。给你一个二维整数数组 <code>edges</code> 其中 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示顶点 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间存在一条 <strong>无向</strong> 边。</p>\n\n<p>返回图中 <strong>完全连通分量</strong> 的数量。</p>\n\n<p>如果在子图中任意两个顶点之间都存在路径，并且子图中没有任何一个顶点与子图外部的顶点共享边，则称其为 <strong>连通分量</strong> 。</p>\n\n<p>如果连通分量中每对节点之间都存在一条边，则称其为 <strong>完全连通分量</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/11/screenshot-from-2023-04-11-23-31-23.png\" style=\"width: 671px; height: 270px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6, edges = [[0,1],[0,2],[1,2],[3,4]]\n<strong>输出：</strong>3\n<strong>解释：</strong>如上图所示，可以看到此图所有分量都是完全连通分量。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/11/screenshot-from-2023-04-11-23-32-00.png\" style=\"width: 671px; height: 270px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6, edges = [[0,1],[0,2],[1,2],[3,4],[3,5]]\n<strong>输出：</strong>1\n<strong>解释：</strong>包含节点 0、1 和 2 的分量是完全连通分量，因为每对节点之间都存在一条边。\n包含节点 3 、4 和 5 的分量不是完全连通分量，因为节点 4 和 5 之间不存在边。\n因此，在图中完全连接分量的数量是 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>0 &lt;= edges.length &lt;= n * (n - 1) / 2</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>不存在重复的边</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2686.即时食物配送 III",
        "hardRate": "MEDIUM",
        "passRate": "67.37%",
        "problemsUrl": "https://leetcode.cn/problems/immediate-food-delivery-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/immediate-food-delivery-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2687.自行车的最后使用时间",
        "hardRate": "EASY",
        "passRate": "85.92%",
        "problemsUrl": "https://leetcode.cn/problems/bikes-last-time-used/",
        "solutionsUrl": "https://leetcode.cn/problems/bikes-last-time-used/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2688.查找活跃用户",
        "hardRate": "MEDIUM",
        "passRate": "45.07%",
        "problemsUrl": "https://leetcode.cn/problems/find-active-users/",
        "solutionsUrl": "https://leetcode.cn/problems/find-active-users/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2689.从 Rope 树中提取第 K 个字符",
        "hardRate": "EASY",
        "passRate": "78.76%",
        "problemsUrl": "https://leetcode.cn/problems/extract-kth-character-from-the-rope-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/extract-kth-character-from-the-rope-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2690.无穷方法对象",
        "hardRate": "EASY",
        "passRate": "93.98%",
        "problemsUrl": "https://leetcode.cn/problems/infinite-method-object/",
        "solutionsUrl": "https://leetcode.cn/problems/infinite-method-object/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2691.不可变辅助工具",
        "hardRate": "HARD",
        "passRate": "25.20%",
        "problemsUrl": "https://leetcode.cn/problems/immutability-helper/",
        "solutionsUrl": "https://leetcode.cn/problems/immutability-helper/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2692.使对象不可变",
        "hardRate": "MEDIUM",
        "passRate": "50.00%",
        "problemsUrl": "https://leetcode.cn/problems/make-object-immutable/",
        "solutionsUrl": "https://leetcode.cn/problems/make-object-immutable/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2693.使用自定义上下文调用函数",
        "hardRate": "MEDIUM",
        "passRate": "72.90%",
        "problemsUrl": "https://leetcode.cn/problems/call-function-with-custom-context/",
        "solutionsUrl": "https://leetcode.cn/problems/call-function-with-custom-context/solution",
        "problemsDesc": "<p>增强所有函数，使其具有&nbsp;<code>callPolyfill</code>&nbsp;方法。该方法接受一个对象&nbsp;<code>obj</code>&nbsp;作为第一个参数，以及任意数量的附加参数。<code>obj</code>&nbsp;成为函数的&nbsp;<code>this</code>&nbsp;上下文。附加参数将传递给该函数（即&nbsp;<code>callPolyfill</code>&nbsp;方法所属的函数）。</p>\n\n<p>例如，如果有以下函数：</p>\n\n<pre>\nfunction tax(price, taxRate) {\n  const totalCost = price * (1 + taxRate);\n&nbsp; console.log(`The cost of ${this.item} is ${totalCost}`);\n}\n</pre>\n\n<p>调用&nbsp;<code>tax(10, 0.1)</code>&nbsp;将输出&nbsp;<code>\"The cost of undefined is 11\"</code>&nbsp;。这是因为&nbsp;<code>this</code>&nbsp;上下文未定义。</p>\n\n<p>然而，调用&nbsp;<code>tax.callPolyfill({item: \"salad\"}, 10, 0.1)</code>&nbsp;将输出&nbsp;<code>\"The cost of salad is 11\"</code>&nbsp;。<code>this</code>&nbsp;上下文被正确设置，函数输出了适当的结果。</p>\n\n<p>请在不使用内置的&nbsp;<code>Function.call</code>&nbsp;方法的情况下解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nfn = function add(b) {\n  return this.a + b;\n}\nargs = [{\"a\": 5}, 7]\n<b>输出：</b>12\n<strong>解释：</strong>\nfn.callPolyfill({\"a\": 5}, 7); // 12\n<code>callPolyfill </code>将 \"this\" 上下文设置为 <code>{\"a\": 5} </code>，并将 7 作为参数传递。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>\nfn = function tax(price, taxRate) { \n&nbsp;return `The cost of the ${this.item} is ${price * taxRate}`; \n}\nargs = [{\"item\": \"burger\"}, 10, 1,1]\n<b>输出：</b>\"The cost of the burger is 11\"\n<b>解释：</b><code>callPolyfill </code>将 \"this\" 上下文设置为 <code>{\"item\": \"burger\"} </code>，并将 10 和 1.1 作为附加参数传递。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul style=\"list-style-type:square;\">\n\t<li><code><font face=\"monospace\">typeof args[0] == 'object' and args[0] != null</font></code></li>\n\t<li><code>1 &lt;= args.length &lt;= 100</code></li>\n\t<li><code>2 &lt;= JSON.stringify(args[0]).length &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2694.事件发射器",
        "hardRate": "MEDIUM",
        "passRate": "60.03%",
        "problemsUrl": "https://leetcode.cn/problems/event-emitter/",
        "solutionsUrl": "https://leetcode.cn/problems/event-emitter/solution",
        "problemsDesc": "<p>设计一个 <code>EventEmitter</code> 类。这个接口与 Node.js 或 DOM 的 Event Target 接口相似，但有一些差异。<code>EventEmitter</code> 应该允许订阅事件和触发事件。</p>\n\n<p>你的 <code>EventEmitter</code> 类应该有以下两个方法：</p>\n\n<ul>\n\t<li><strong>subscribe</strong> - 这个方法接收两个参数：一个作为字符串的事件名和一个回调函数。当事件被触发时，这个回调函数将被调用。 一个事件应该能够有多个监听器。当触发带有多个回调函数的事件时，应按照订阅的顺序依次调用每个回调函数。应返回一个结果数组。你可以假设传递给 <code>subscribe</code> 的回调函数都不是引用相同的。 <code>subscribe</code> 方法还应返回一个对象，其中包含一个 <code>unsubscribe</code> 方法，使用户可以取消订阅。当调用 <code>unsubscribe</code> 方法时，回调函数应该从订阅列表中删除，并返回 undefined。</li>\n\t<li><strong>emit</strong> - 这个方法接收两个参数：一个作为字符串的事件名和一个可选的参数数组，这些参数将传递给回调函数。如果没有订阅给定事件的回调函数，则返回一个空数组。否则，按照它们被订阅的顺序返回所有回调函数调用的结果数组。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>actions = [\"EventEmitter\", \"emit\", \"subscribe\", \"subscribe\", \"emit\"], values = [[], [\"firstEvent\", \"function cb1() { return 5; }\"],  [\"firstEvent\", \"function cb1() { return 5; }\"], [\"firstEvent\"]]\n<b>输出：</b>[[],[\"emitted\",[]],[\"subscribed\"],[\"subscribed\"],[\"emitted\",[5,6]]]\n<b>解释：</b>\nconst emitter = new EventEmitter();\nemitter.emit(\"firstEvent\"); // [], 还没有订阅任何回调函数\nemitter.subscribe(\"firstEvent\", function cb1() { return 5; });\nemitter.subscribe(\"firstEvent\", function cb2() { return 6; });\nemitter.emit(\"firstEvent\"); // [5, 6], 返回 cb1 和 cb2 的输出\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>actions = [\"EventEmitter\", \"subscribe\", \"emit\", \"emit\"], values = [[], [\"firstEvent\", \"function cb1(...args) { return args.join(','); }\"], [\"firstEvent\", [1,2,3]], [\"firstEvent\", [3,4,6]]]\n<b>输出：</b>[[],[\"subscribed\"],[\"emitted\",[\"1,2,3\"]],[\"emitted\",[\"3,4,6\"]]]\n<strong>解释：</strong>注意 emit 方法应该能够接受一个可选的参数数组。\n\nconst emitter = new EventEmitter();\nemitter.subscribe(\"firstEvent, function cb1(...args) { return args.join(','); });\nemitter.emit(\"firstEvent\", [1, 2, 3]); // [\"1,2,3\"]\nemitter.emit(\"firstEvent\", [3, 4, 6]); // [\"3,4,6\"]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>actions = [\"EventEmitter\", \"subscribe\", \"emit\", \"unsubscribe\", \"emit\"], values = [[], [\"firstEvent\", \"(...args) =&gt; args.join(',')\"], [\"firstEvent\", [1,2,3]], [0], [\"firstEvent\", [4,5,6]]]\n<b>输出：</b>[[],[\"subscribed\"],[\"emitted\",[\"1,2,3\"]],[\"unsubscribed\",0],[\"emitted\",[]]]\n<b>解释：</b>\nconst emitter = new EventEmitter();\nconst sub = emitter.subscribe(\"firstEvent\", (...args) =&gt; args.join(','));\nemitter.emit(\"firstEvent\", [1, 2, 3]); // [\"1,2,3\"]\nsub.unsubscribe(); // undefined\nemitter.emit(\"firstEvent\", [4, 5, 6]); // [], 没有订阅者\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>actions = [\"EventEmitter\", \"subscribe\", \"subscribe\", \"unsubscribe\", \"emit\"], values = [[], [\"firstEvent\", \"x =&gt; x + 1\"], [\"firstEvent\", \"x =&gt; x + 2\"], [0], [\"firstEvent\", [5]]]\n<b>输出：</b>[[],[\"subscribed\"],[\"emitted\",[\"1,2,3\"]],[\"unsubscribed\",0],[\"emitted\",[7]]]\n<b>解释：</b>\nconst emitter = new EventEmitter();\nconst sub1 = emitter.subscribe(\"firstEvent\", x =&gt; x + 1);\nconst sub2 = emitter.subscribe(\"firstEvent\", x =&gt; x + 2);\nsub1.unsubscribe(); // undefined\nemitter.emit(\"firstEvent\", [5]); // [7]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= actions.length &lt;= 10</code></li>\n\t<li><code>values.length === actions.length</code></li>\n\t<li>所有测试用例都是有效的。例如，你不需要处理取消一个不存在的订阅的情况。</li>\n\t<li>只有 4 种不同的操作：<code>EventEmitter</code>、<code>emit</code>、<code>subscribe</code> 和 <code>unsubscribe</code>&nbsp;。 <code>EventEmitter</code> 操作没有参数。</li>\n\t<li><code>emit</code> 操作接收 1 或 2 个参数。第一个参数是要触发的事件名，第二个参数传递给回调函数。</li>\n\t<li><code>subscribe</code> 操作接收 2 个参数，第一个是事件名，第二个是回调函数。</li>\n\t<li><code>unsubscribe</code> 操作接收一个参数，即之前进行订阅的顺序（从 0 开始）。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2695.包装数组",
        "hardRate": "EASY",
        "passRate": "72.23%",
        "problemsUrl": "https://leetcode.cn/problems/array-wrapper/",
        "solutionsUrl": "https://leetcode.cn/problems/array-wrapper/solution",
        "problemsDesc": "<p>创建一个名为 <code>ArrayWrapper</code> 的类，它在其构造函数中接受一个整数数组作为参数。该类应具有以下两个特性：</p>\n\n<ul>\n\t<li>当使用 <code>+</code> 运算符将两个该类的实例相加时，结果值为两个数组中所有元素的总和。</li>\n\t<li>当在实例上调用 <code>String()</code> 函数时，它将返回一个由逗号分隔的括在方括号中的字符串。例如，<code>[1,2,3]</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [[1,2],[3,4]], operation = \"Add\"\n<b>输出：</b>10\n<b>解释：</b>\nconst obj1 = new ArrayWrapper([1,2]);\nconst obj2 = new ArrayWrapper([3,4]);\nobj1 + obj2; // 10\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [[23,98,42,70]], operation = \"String\"\n<b>输出：</b>\"[23,98,42,70]\"\n<strong>解释：</strong>\nconst obj = new ArrayWrapper([23,98,42,70]);\nString(obj); // \"[23,98,42,70]\"\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [[],[]], operation = \"Add\"\n<b>输出：</b>0\n<strong>解释：</strong>\nconst obj1 = new ArrayWrapper([]);\nconst obj2 = new ArrayWrapper([]);\nobj1 + obj2; // 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i]&nbsp;&lt;= 1000</code></li>\n\t<li><code>注意：nums 是传递给构造函数的数组。</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2696.删除子串后的字符串最小长度",
        "hardRate": "EASY",
        "passRate": "72.45%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-string-length-after-removing-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-string-length-after-removing-substrings/solution",
        "problemsDesc": "<p>给你一个仅由 <strong>大写</strong> 英文字符组成的字符串 <code>s</code> 。</p>\n\n<p>你可以对此字符串执行一些操作，在每一步操作中，你可以从 <code>s</code> 中删除 <strong>任一个</strong> <code>\"AB\"</code> 或 <code>\"CD\"</code> 子字符串。</p>\n\n<p>通过执行操作，删除所有&nbsp;<code>\"AB\"</code> 和 <code>\"CD\"</code> 子串，返回可获得的最终字符串的 <strong>最小</strong> 可能长度。</p>\n\n<p><strong>注意</strong>，删除子串后，重新连接出的字符串可能会产生新的&nbsp;<code>\"AB\"</code> 或 <code>\"CD\"</code> 子串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ABFCACDB\"\n<strong>输出：</strong>2\n<strong>解释：</strong>你可以执行下述操作：\n- 从 \"<em><strong>AB</strong></em>FCACDB\" 中删除子串 \"AB\"，得到 s = \"FCACDB\" 。\n- 从 \"FCA<em><strong>CD</strong></em>B\" 中删除子串 \"CD\"，得到 s = \"FCAB\" 。\n- 从 \"FC<strong><em>AB</em></strong>\" 中删除子串 \"AB\"，得到 s = \"FC\" 。\n最终字符串的长度为 2 。\n可以证明 2 是可获得的最小长度。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ACBBD\"\n<strong>输出：</strong>5\n<strong>解释：</strong>无法执行操作，字符串长度不变。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 仅由大写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2697.字典序最小回文串",
        "hardRate": "EASY",
        "passRate": "82.95%",
        "problemsUrl": "https://leetcode.cn/problems/lexicographically-smallest-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/lexicographically-smallest-palindrome/solution",
        "problemsDesc": "<p>给你一个由 <strong>小写英文字母</strong> 组成的字符串 <code>s</code> ，你可以对其执行一些操作。在一步操作中，你可以用其他小写英文字母 <strong>替换</strong>&nbsp; <code>s</code> 中的一个字符。</p>\n\n<p>请你执行 <strong>尽可能少的操作</strong> ，使 <code>s</code> 变成一个 <strong>回文串</strong> 。如果执行 <strong>最少</strong> 操作次数的方案不止一种，则只需选取 <strong>字典序最小</strong> 的方案。</p>\n\n<p>对于两个长度相同的字符串 <code>a</code> 和 <code>b</code> ，在 <code>a</code> 和 <code>b</code> 出现不同的第一个位置，如果该位置上 <code>a</code> 中对应字母比 <code>b</code> 中对应字母在字母表中出现顺序更早，则认为 <code>a</code> 的字典序比 <code>b</code> 的字典序要小。</p>\n\n<p>返回最终的回文字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"egcfe\"\n<strong>输出：</strong>\"efcfe\"\n<strong>解释：</strong>将 \"egcfe\" 变成回文字符串的最小操作次数为 1 ，修改 1 次得到的字典序最小回文字符串是 \"efcfe\"，只需将 'g' 改为 'f' 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\"\n<strong>输出：</strong>\"abba\"\n<strong>解释：</strong>将 \"abcd\" 变成回文字符串的最小操作次数为 2 ，修改 2 次得到的字典序最小回文字符串是 \"abba\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"seven\"\n<strong>输出：</strong>\"neven\"\n<strong>解释：</strong>将 \"seven\" 变成回文字符串的最小操作次数为 1 ，修改 1 次得到的字典序最小回文字符串是 \"neven\" 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2698.求一个整数的惩罚数",
        "hardRate": "MEDIUM",
        "passRate": "66.92%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/solution",
        "problemsDesc": "<p>给你一个正整数&nbsp;<code>n</code>&nbsp;，请你返回&nbsp;<code>n</code>&nbsp;的&nbsp;<strong>惩罚数</strong>&nbsp;。</p>\n\n<p><code>n</code>&nbsp;的 <strong>惩罚数</strong>&nbsp;定义为所有满足以下条件 <code>i</code>&nbsp;的数的平方和：</p>\n\n<ul>\n\t<li><code>1 &lt;= i &lt;= n</code></li>\n\t<li><code>i * i</code> 的十进制表示的字符串可以分割成若干连续子字符串，且这些子字符串对应的整数值之和等于 <code>i</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 10\n<b>输出：</b>182\n<b>解释：</b>总共有 3 个整数 i 满足要求：\n- 1 ，因为 1 * 1 = 1\n- 9 ，因为 9 * 9 = 81 ，且 81 可以分割成 8 + 1 。\n- 10 ，因为 10 * 10 = 100 ，且 100 可以分割成 10 + 0 。\n因此，10 的惩罚数为 1 + 81 + 100 = 182\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 37\n<b>输出：</b>1478\n<b>解释：</b>总共有 4 个整数 i 满足要求：\n- 1 ，因为 1 * 1 = 1\n- 9 ，因为 9 * 9 = 81 ，且 81 可以分割成 8 + 1 。\n- 10 ，因为 10 * 10 = 100 ，且 100 可以分割成 10 + 0 。\n- 36 ，因为 36 * 36 = 1296 ，且 1296 可以分割成 1 + 29 + 6 。\n因此，37 的惩罚数为 1 + 81 + 100 + 1296 = 1478\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2699.修改图中的边权",
        "hardRate": "HARD",
        "passRate": "52.56%",
        "problemsUrl": "https://leetcode.cn/problems/modify-graph-edge-weights/",
        "solutionsUrl": "https://leetcode.cn/problems/modify-graph-edge-weights/solution",
        "problemsDesc": "<p>给你一个 <code>n</code>&nbsp;个节点的 <strong>无向带权连通</strong>&nbsp;图，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，再给你一个整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>, w<sub>i</sub>]</code>&nbsp;表示节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条边权为&nbsp;<code>w<sub>i</sub></code>&nbsp;的边。</p>\n\n<p>部分边的边权为&nbsp;<code>-1</code>（<code>w<sub>i</sub> = -1</code>），其他边的边权都为 <strong>正</strong>&nbsp;数（<code>w<sub>i</sub> &gt; 0</code>）。</p>\n\n<p>你需要将所有边权为 <code>-1</code>&nbsp;的边都修改为范围&nbsp;<code>[1, 2 * 10<sup>9</sup>]</code>&nbsp;中的 <strong>正整数</strong>&nbsp;，使得从节点&nbsp;<code>source</code>&nbsp;到节点&nbsp;<code>destination</code>&nbsp;的 <strong>最短距离</strong>&nbsp;为整数&nbsp;<code>target</code>&nbsp;。如果有 <strong>多种</strong>&nbsp;修改方案可以使&nbsp;<code>source</code> 和&nbsp;<code>destination</code>&nbsp;之间的最短距离等于&nbsp;<code>target</code>&nbsp;，你可以返回任意一种方案。</p>\n\n<p>如果存在使 <code>source</code>&nbsp;到 <code>destination</code>&nbsp;最短距离为 <code>target</code>&nbsp;的方案，请你按任意顺序返回包含所有边的数组（包括未修改边权的边）。如果不存在这样的方案，请你返回一个 <strong>空数组</strong>&nbsp;。</p>\n\n<p><strong>注意：</strong>你不能修改一开始边权为正数的边。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/18/graph.png\" style=\"width: 300px; height: 300px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>n = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5\n<b>输出：</b>[[4,1,1],[2,0,1],[0,3,3],[4,3,1]]\n<b>解释：</b>上图展示了一个满足题意的修改方案，从 0 到 1 的最短距离为 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/18/graph-2.png\" style=\"width: 300px; height: 300px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>n = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6\n<b>输出：</b>[]\n<b>解释：</b>上图是一开始的图。没有办法通过修改边权为 -1 的边，使得 0 到 2 的最短距离等于 6 ，所以返回一个空数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/19/graph-3.png\" style=\"width: 300px; height: 300px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>n = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6\n<b>输出：</b>[[1,0,4],[1,2,3],[2,3,5],[0,3,1]]\n<b>解释：</b>上图展示了一个满足题意的修改方案，从 0 到 2 的最短距离为 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= n * (n - 1) / 2</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i&nbsp;</sub>&lt;&nbsp;n</code></li>\n\t<li><code>w<sub>i</sub>&nbsp;= -1</code> 或者 <code>1 &lt;= w<sub>i&nbsp;</sub>&lt;= 10<sup><span style=\"\">7</span></sup></code></li>\n\t<li><code>a<sub>i&nbsp;</sub>!=&nbsp;b<sub>i</sub></code></li>\n\t<li><code>0 &lt;= source, destination &lt; n</code></li>\n\t<li><code>source != destination</code></li>\n\t<li><code>1 &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li>输入的图是连通图，且没有自环和重边。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2700.两个对象之间的差异",
        "hardRate": "MEDIUM",
        "passRate": "58.85%",
        "problemsUrl": "https://leetcode.cn/problems/differences-between-two-objects/",
        "solutionsUrl": "https://leetcode.cn/problems/differences-between-two-objects/solution",
        "problemsDesc": null,
        "isPlus": true
    }
]