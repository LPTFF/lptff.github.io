[
    {
        "problemsName": " 1801.积压订单中的订单总数",
        "hardRate": "MEDIUM",
        "passRate": "53.23%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-orders-in-the-backlog/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-orders-in-the-backlog/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>orders</code> ，其中每个 <code>orders[i] = [price<sub>i</sub>, amount<sub>i</sub>, orderType<sub>i</sub>]</code> 表示有 <code>amount<sub>i</sub></code><sub> </sub>笔类型为 <code>orderType<sub>i</sub></code> 、价格为 <code>price<sub>i</sub></code> 的订单。</p>\n\n<p>订单类型 <code>orderType<sub>i</sub></code> 可以分为两种：</p>\n\n<ul>\n\t<li><code>0</code> 表示这是一批采购订单 <code>buy</code></li>\n\t<li><code>1</code> 表示这是一批销售订单 <code>sell</code></li>\n</ul>\n\n<p>注意，<code>orders[i]</code> 表示一批共计 <code>amount<sub>i</sub></code> 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 <code>i</code> ，由 <code>orders[i]</code> 表示的所有订单提交时间均早于 <code>orders[i+1]</code> 表示的所有订单。</p>\n\n<p>存在由未执行订单组成的 <strong>积压订单</strong> 。积压订单最初是空的。提交订单时，会发生以下情况：</p>\n\n<ul>\n\t<li>如果该订单是一笔采购订单 <code>buy</code> ，则可以查看积压订单中价格 <strong>最低</strong> 的销售订单 <code>sell</code> 。如果该销售订单 <code>sell</code> 的价格 <strong>低于或等于</strong> 当前采购订单 <code>buy</code> 的价格，则匹配并执行这两笔订单，并将销售订单 <code>sell</code> 从积压订单中删除。否则，采购订单 <code>buy</code> 将会添加到积压订单中。</li>\n\t<li>反之亦然，如果该订单是一笔销售订单 <code>sell</code> ，则可以查看积压订单中价格 <strong>最高</strong> 的采购订单 <code>buy</code> 。如果该采购订单 <code>buy</code> 的价格 <strong>高于或等于</strong> 当前销售订单 <code>sell</code> 的价格，则匹配并执行这两笔订单，并将采购订单 <code>buy</code> 从积压订单中删除。否则，销售订单 <code>sell</code> 将会添加到积压订单中。</li>\n</ul>\n\n<p>输入所有订单后，返回积压订单中的 <strong>订单总数</strong> 。由于数字可能很大，所以需要返回对 <code>10<sup>9</sup> + 7</code> 取余的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/21/ex1.png\" style=\"width: 450px; height: 479px;\" />\n<pre>\n<strong>输入：</strong>orders = [[10,5,0],[15,2,1],[25,1,1],[30,4,0]]\n<strong>输出：</strong>6\n<strong>解释：</strong>输入订单后会发生下述情况：\n- 提交 5 笔采购订单，价格为 10 。没有销售订单，所以这 5 笔订单添加到积压订单中。\n- 提交 2 笔销售订单，价格为 15 。没有采购订单的价格大于或等于 15 ，所以这 2 笔订单添加到积压订单中。\n- 提交 1 笔销售订单，价格为 25 。没有采购订单的价格大于或等于 25 ，所以这 1 笔订单添加到积压订单中。\n- 提交 4 笔采购订单，价格为 30 。前 2 笔采购订单与价格最低（价格为 15）的 2 笔销售订单匹配，从积压订单中删除这 2 笔销售订单。第 3 笔采购订单与价格最低的 1 笔销售订单匹配，销售订单价格为 25 ，从积压订单中删除这 1 笔销售订单。积压订单中不存在更多销售订单，所以第 4 笔采购订单需要添加到积压订单中。\n最终，积压订单中有 5 笔价格为 10 的采购订单，和 1 笔价格为 30 的采购订单。所以积压订单中的订单总数为 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/21/ex2.png\" style=\"width: 450px; height: 584px;\" />\n<pre>\n<strong>输入：</strong>orders = [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]]\n<strong>输出：</strong>999999984\n<strong>解释：</strong>输入订单后会发生下述情况：\n- 提交 10<sup>9</sup> 笔销售订单，价格为 7 。没有采购订单，所以这 10<sup>9</sup> 笔订单添加到积压订单中。\n- 提交 3 笔采购订单，价格为 15 。这些采购订单与价格最低（价格为 7 ）的 3 笔销售订单匹配，从积压订单中删除这 3 笔销售订单。\n- 提交 999999995 笔采购订单，价格为 5 。销售订单的最低价为 7 ，所以这 999999995 笔订单添加到积压订单中。\n- 提交 1 笔销售订单，价格为 5 。这笔销售订单与价格最高（价格为 5 ）的 1 笔采购订单匹配，从积压订单中删除这 1 笔采购订单。\n最终，积压订单中有 (1000000000-3) 笔价格为 7 的销售订单，和 (999999995-1) 笔价格为 5 的采购订单。所以积压订单中的订单总数为 1999999991 ，等于 999999984 % (10<sup>9</sup> + 7) 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= orders.length <= 10<sup>5</sup></code></li>\n\t<li><code>orders[i].length == 3</code></li>\n\t<li><code>1 <= price<sub>i</sub>, amount<sub>i</sub> <= 10<sup>9</sup></code></li>\n\t<li><code>orderType<sub>i</sub></code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1802.有界数组中指定下标处的最大值",
        "hardRate": "MEDIUM",
        "passRate": "38.09%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-value-at-a-given-index-in-a-bounded-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-value-at-a-given-index-in-a-bounded-array/solution",
        "problemsDesc": "<p>给你三个正整数 <code>n</code>、<code>index</code> 和 <code>maxSum</code> 。你需要构造一个同时满足下述所有条件的数组 <code>nums</code>（下标 <strong>从 0 开始</strong> 计数）：</p>\n\n<ul>\n\t<li><code>nums.length == n</code></li>\n\t<li><code>nums[i]</code> 是 <strong>正整数</strong> ，其中 <code>0 &lt;= i &lt; n</code></li>\n\t<li><code>abs(nums[i] - nums[i+1]) &lt;= 1</code> ，其中 <code>0 &lt;= i &lt; n-1</code></li>\n\t<li><code>nums</code> 中所有元素之和不超过 <code>maxSum</code></li>\n\t<li><code>nums[index]</code> 的值被 <strong>最大化</strong></li>\n</ul>\n\n<p>返回你所构造的数组中的 <code>nums[index]</code> 。</p>\n\n<p>注意：<code>abs(x)</code> 等于 <code>x</code> 的前提是 <code>x &gt;= 0</code> ；否则，<code>abs(x)</code> 等于 <code>-x</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 4, index = 2,  maxSum = 6\n<strong>输出：</strong>2\n<strong>解释：</strong>数组 [1,1,<strong>2</strong>,1] 和 [1,2,<strong>2</strong>,1] 满足所有条件。不存在其他在指定下标处具有更大值的有效数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 6, index = 1,  maxSum = 10\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= maxSum &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= index &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1803.统计异或值在范围内的数对有多少",
        "hardRate": "HARD",
        "passRate": "56.35%",
        "problemsUrl": "https://leetcode.cn/problems/count-pairs-with-xor-in-a-range/",
        "solutionsUrl": "https://leetcode.cn/problems/count-pairs-with-xor-in-a-range/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> （下标 <strong>从 0 开始</strong> 计数）以及两个整数：<code>low</code> 和 <code>high</code> ，请返回 <strong>漂亮数对</strong> 的数目。</p>\n\n<p><strong>漂亮数对</strong> 是一个形如 <code>(i, j)</code> 的数对，其中 <code>0 &lt;= i &lt; j &lt; nums.length</code> 且 <code>low &lt;= (nums[i] XOR nums[j]) &lt;= high</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,4,2,7], low = 2, high = 6\n<strong>输出：</strong>6\n<strong>解释：</strong>所有漂亮数对 (i, j) 列出如下：\n    - (0, 1): nums[0] XOR nums[1] = 5 \n    - (0, 2): nums[0] XOR nums[2] = 3\n    - (0, 3): nums[0] XOR nums[3] = 6\n    - (1, 2): nums[1] XOR nums[2] = 6\n    - (1, 3): nums[1] XOR nums[3] = 3\n    - (2, 3): nums[2] XOR nums[3] = 5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [9,8,4,2,1], low = 5, high = 14\n<strong>输出：</strong>8\n<strong>解释：</strong>所有漂亮数对 (i, j) 列出如下：\n​​​​​    - (0, 2): nums[0] XOR nums[2] = 13\n    - (0, 3): nums[0] XOR nums[3] = 11\n    - (0, 4): nums[0] XOR nums[4] = 8\n    - (1, 2): nums[1] XOR nums[2] = 12\n    - (1, 3): nums[1] XOR nums[3] = 10\n    - (1, 4): nums[1] XOR nums[4] = 9\n    - (2, 3): nums[2] XOR nums[3] = 6\n    - (2, 4): nums[2] XOR nums[4] = 5</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= low &lt;= high &lt;= 2 * 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1804.实现 Trie （前缀树） II",
        "hardRate": "MEDIUM",
        "passRate": "57.09%",
        "problemsUrl": "https://leetcode.cn/problems/implement-trie-ii-prefix-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/implement-trie-ii-prefix-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1805.字符串中不同整数的数目",
        "hardRate": "EASY",
        "passRate": "43.16%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-different-integers-in-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-different-integers-in-a-string/solution",
        "problemsDesc": "<p>给你一个字符串 <code>word</code> ，该字符串由数字和小写英文字母组成。</p>\n\n<p>请你用空格替换每个不是数字的字符。例如，<code>\"a123bc34d8ef34\"</code> 将会变成 <code>\" 123  34 8  34\"</code> 。注意，剩下的这些整数为（相邻彼此至少有一个空格隔开）：<code>\"123\"</code>、<code>\"34\"</code>、<code>\"8\"</code> 和 <code>\"34\"</code> 。</p>\n\n<p>返回对 <code>word</code> 完成替换后形成的 <strong>不同</strong> 整数的数目。</p>\n\n<p>只有当两个整数的 <strong>不含前导零</strong> 的十进制表示不同， 才认为这两个整数也不同。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"a<strong>123</strong>bc<strong>34</strong>d<strong>8</strong>ef<strong>34</strong>\"\n<strong>输出：</strong>3\n<strong>解释：</strong>不同的整数有 \"123\"、\"34\" 和 \"8\" 。注意，\"34\" 只计数一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"leet<strong>1234</strong>code<strong>234</strong>\"\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"a<strong>1</strong>b<strong>01</strong>c<strong>001</strong>\"\n<strong>输出：</strong>1\n<strong>解释：</strong>\"1\"、\"01\" 和 \"001\" 视为同一个整数的十进制表示，因为在比较十进制值时会忽略前导零的存在。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word.length <= 1000</code></li>\n\t<li><code>word</code> 由数字和小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1806.还原排列的最少操作步数",
        "hardRate": "MEDIUM",
        "passRate": "76.71%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/solution",
        "problemsDesc": "<p>给你一个偶数 <code>n</code>​​​​​​ ，已知存在一个长度为 <code>n</code> 的排列 <code>perm</code> ，其中 <code>perm[i] == i</code>​（下标 <strong>从 0 开始</strong> 计数）。</p>\n\n<p>一步操作中，你将创建一个新数组 <code>arr</code> ，对于每个 <code>i</code> ：</p>\n\n<ul>\n\t<li>如果 <code>i % 2 == 0</code> ，那么 <code>arr[i] = perm[i / 2]</code></li>\n\t<li>如果 <code>i % 2 == 1</code> ，那么 <code>arr[i] = perm[n / 2 + (i - 1) / 2]</code></li>\n</ul>\n\n<p>然后将 <code>arr</code>​​ 赋值​​给 <code>perm</code> 。</p>\n\n<p>要想使 <code>perm</code> 回到排列初始值，至少需要执行多少步操作？返回最小的 <strong>非零</strong> 操作步数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>最初，perm = [0,1]\n第 1 步操作后，perm = [0,1]\n所以，仅需执行 1 步操作</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>最初，perm = [0,1,2,3]\n第 1 步操作后，perm = [0,2,1,3]\n第 2 步操作后，perm = [0,1,2,3]\n所以，仅需执行 2 步操作</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6\n<strong>输出：</strong>4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 1000</code></li>\n\t<li><code>n</code>​​​​​​ 是一个偶数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1807.替换字符串中的括号内容",
        "hardRate": "MEDIUM",
        "passRate": "67.51%",
        "problemsUrl": "https://leetcode.cn/problems/evaluate-the-bracket-pairs-of-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/evaluate-the-bracket-pairs-of-a-string/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，它包含一些括号对，每个括号中包含一个 <strong>非空</strong>&nbsp;的键。</p>\n\n<ul>\n\t<li>比方说，字符串&nbsp;<code>\"(name)is(age)yearsold\"</code>&nbsp;中，有&nbsp;<strong>两个</strong>&nbsp;括号对，分别包含键&nbsp;<code>\"name\"</code> 和&nbsp;<code>\"age\"</code>&nbsp;。</li>\n</ul>\n\n<p>你知道许多键对应的值，这些关系由二维字符串数组&nbsp;<code>knowledge</code>&nbsp;表示，其中&nbsp;<code>knowledge[i] = [key<sub>i</sub>, value<sub>i</sub>]</code>&nbsp;，表示键&nbsp;<code>key<sub>i</sub></code>&nbsp;对应的值为&nbsp;<code>value<sub>i</sub></code><sub>&nbsp;</sub>。</p>\n\n<p>你需要替换 <strong>所有</strong>&nbsp;的括号对。当你替换一个括号对，且它包含的键为&nbsp;<code>key<sub>i</sub></code>&nbsp;时，你需要：</p>\n\n<ul>\n\t<li>将&nbsp;<code>key<sub>i</sub></code>&nbsp;和括号用对应的值&nbsp;<code>value<sub>i</sub></code>&nbsp;替换。</li>\n\t<li>如果从 <code>knowledge</code>&nbsp;中无法得知某个键对应的值，你需要将&nbsp;<code>key<sub>i</sub></code>&nbsp;和括号用问号&nbsp;<code>\"?\"</code>&nbsp;替换（不需要引号）。</li>\n</ul>\n\n<p><code>knowledge</code>&nbsp;中每个键最多只会出现一次。<code>s</code>&nbsp;中不会有嵌套的括号。</p>\n\n<p>请你返回替换 <strong>所有</strong>&nbsp;括号对后的结果字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"(name)is(age)yearsold\", knowledge = [[\"name\",\"bob\"],[\"age\",\"two\"]]\n<b>输出：</b>\"bobistwoyearsold\"\n<strong>解释：</strong>\n键 \"name\" 对应的值为 \"bob\" ，所以将 \"(name)\" 替换为 \"bob\" 。\n键 \"age\" 对应的值为 \"two\" ，所以将 \"(age)\" 替换为 \"two\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"hi(name)\", knowledge = [[\"a\",\"b\"]]\n<b>输出：</b>\"hi?\"\n<b>解释：</b>由于不知道键 \"name\" 对应的值，所以用 \"?\" 替换 \"(name)\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"(a)(a)(a)aaa\", knowledge = [[\"a\",\"yes\"]]\n<b>输出：</b>\"yesyesyesaaa\"\n<b>解释：</b>相同的键在 s 中可能会出现多次。\n键 \"a\" 对应的值为 \"yes\" ，所以将所有的 \"(a)\" 替换为 \"yes\" 。\n注意，不在括号里的 \"a\" 不需要被替换。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= knowledge.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>knowledge[i].length == 2</code></li>\n\t<li><code>1 &lt;= key<sub>i</sub>.length, value<sub>i</sub>.length &lt;= 10</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母和圆括号&nbsp;<code>'('</code>&nbsp;和&nbsp;<code>')'</code>&nbsp;。</li>\n\t<li><code>s</code>&nbsp;中每一个左圆括号&nbsp;<code>'('</code>&nbsp;都有对应的右圆括号&nbsp;<code>')'</code>&nbsp;。</li>\n\t<li><code>s</code>&nbsp;中每对括号内的键都不会为空。</li>\n\t<li><code>s</code>&nbsp;中不会有嵌套括号对。</li>\n\t<li><code>key<sub>i</sub></code>&nbsp;和&nbsp;<code>value<sub>i</sub></code>&nbsp;只包含小写英文字母。</li>\n\t<li><code>knowledge</code>&nbsp;中的&nbsp;<code>key<sub>i</sub></code>&nbsp;不会重复。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1808.好因子的最大数目",
        "hardRate": "HARD",
        "passRate": "28.68%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-number-of-nice-divisors/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-number-of-nice-divisors/solution",
        "problemsDesc": "<p>给你一个正整数 <code>primeFactors</code> 。你需要构造一个正整数 <code>n</code> ，它满足以下条件：</p>\n\n<ul>\n\t<li><code>n</code> 质因数（质因数需要考虑重复的情况）的数目 <strong>不超过 </strong><code>primeFactors</code> 个。</li>\n\t<li><code>n</code> 好因子的数目最大化。如果 <code>n</code> 的一个因子可以被 <code>n</code> 的每一个质因数整除，我们称这个因子是 <strong>好因子</strong> 。比方说，如果 <code>n = 12</code> ，那么它的质因数为 <code>[2,2,3]</code> ，那么 <code>6</code> 和 <code>12</code> 是好因子，但 <code>3</code> 和 <code>4</code> 不是。</li>\n</ul>\n\n<p>请你返回 <code>n</code> 的好因子的数目。由于答案可能会很大，请返回答案对 <code>10<sup>9</sup> + 7</code> <b>取余</b> 的结果。</p>\n\n<p>请注意，一个质数的定义是大于 <code>1</code> ，且不能被分解为两个小于该数的自然数相乘。一个数 <code>n</code> 的质因子是将 <code>n</code> 分解为若干个质因子，且它们的乘积为 <code>n</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>primeFactors = 5\n<strong>输出：</strong>6\n<b>解释：</b>200 是一个可行的 n 。\n它有 5 个质因子：[2,2,2,5,5] ，且有 6 个好因子：[10,20,40,50,100,200] 。\n不存在别的 n 有至多 5 个质因子，且同时有更多的好因子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>primeFactors = 8\n<b>输出：</b>18\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= primeFactors <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1809.没有广告的剧集",
        "hardRate": "EASY",
        "passRate": "61.03%",
        "problemsUrl": "https://leetcode.cn/problems/ad-free-sessions/",
        "solutionsUrl": "https://leetcode.cn/problems/ad-free-sessions/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1810.隐藏网格下的最小消耗路径",
        "hardRate": "MEDIUM",
        "passRate": "62.66%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-path-cost-in-a-hidden-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-path-cost-in-a-hidden-grid/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1811.寻找面试候选人",
        "hardRate": "MEDIUM",
        "passRate": "63.82%",
        "problemsUrl": "https://leetcode.cn/problems/find-interview-candidates/",
        "solutionsUrl": "https://leetcode.cn/problems/find-interview-candidates/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1812.判断国际象棋棋盘中一个格子的颜色",
        "hardRate": "EASY",
        "passRate": "81.73%",
        "problemsUrl": "https://leetcode.cn/problems/determine-color-of-a-chessboard-square/",
        "solutionsUrl": "https://leetcode.cn/problems/determine-color-of-a-chessboard-square/solution",
        "problemsDesc": "<p>给你一个坐标 <code>coordinates</code> ，它是一个字符串，表示国际象棋棋盘中一个格子的坐标。下图是国际象棋棋盘示意图。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/03/chessboard.png\" style=\"width: 400px; height: 396px;\" /></p>\n\n<p>如果所给格子的颜色是白色，请你返回 <code>true</code>，如果是黑色，请返回 <code>false</code> 。</p>\n\n<p>给定坐标一定代表国际象棋棋盘上一个存在的格子。坐标第一个字符是字母，第二个字符是数字。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>coordinates = \"a1\"\n<b>输出：</b>false\n<b>解释：</b>如上图棋盘所示，\"a1\" 坐标的格子是黑色的，所以返回 false 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>coordinates = \"h3\"\n<b>输出：</b>true\n<b>解释：</b>如上图棋盘所示，\"h3\" 坐标的格子是白色的，所以返回 true 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>coordinates = \"c7\"\n<b>输出：</b>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>coordinates.length == 2</code></li>\n\t<li><code>'a' <= coordinates[0] <= 'h'</code></li>\n\t<li><code>'1' <= coordinates[1] <= '8'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1813.句子相似性 III",
        "hardRate": "MEDIUM",
        "passRate": "41.61%",
        "problemsUrl": "https://leetcode.cn/problems/sentence-similarity-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/sentence-similarity-iii/solution",
        "problemsDesc": "<p>一个句子是由一些单词与它们之间的单个空格组成，且句子的开头和结尾没有多余空格。比方说，<code>\"Hello World\"</code> ，<code>\"HELLO\"</code> ，<code>\"hello world hello world\"</code> 都是句子。每个单词都 <strong>只</strong> 包含大写和小写英文字母。</p>\n\n<p>如果两个句子 <code>sentence1</code> 和 <code>sentence2</code> ，可以通过往其中一个句子插入一个任意的句子（<strong>可以是空句子</strong>）而得到另一个句子，那么我们称这两个句子是 <strong>相似的</strong> 。比方说，<code>sentence1 = \"Hello my name is Jane\"</code> 且 <code>sentence2 = \"Hello Jane\"</code> ，我们可以往 <code>sentence2</code> 中 <code>\"Hello\"</code> 和 <code>\"Jane\"</code> 之间插入 <code>\"my name is\"</code> 得到 <code>sentence1</code> 。</p>\n\n<p>给你两个句子 <code>sentence1</code> 和 <code>sentence2</code> ，如果<em> </em><code>sentence1</code> 和<em> </em><code>sentence2</code> 是相似的，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>sentence1 = \"My name is Haley\", sentence2 = \"My Haley\"\n<b>输出：</b>true\n<b>解释：</b>可以往 sentence2 中 \"My\" 和 \"Haley\" 之间插入 \"name is\" ，得到 sentence1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>sentence1 = \"of\", sentence2 = \"A lot of words\"\n<b>输出：</b>false\n<strong>解释：</strong>没法往这两个句子中的一个句子只插入一个句子就得到另一个句子。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>sentence1 = \"Eating right now\", sentence2 = \"Eating\"\n<b>输出：</b>true\n<b>解释：</b>可以往 sentence2 的结尾插入 \"right now\" 得到 sentence1 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>sentence1 = \"Luky\", sentence2 = \"Lucccky\"\n<b>输出：</b>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentence1.length, sentence2.length &lt;= 100</code></li>\n\t<li><code>sentence1</code> 和 <code>sentence2</code> 都只包含大小写英文字母和空格。</li>\n\t<li><code>sentence1</code> 和 <code>sentence2</code> 中的单词都只由单个空格隔开。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1814.统计一个数组中好对子的数目",
        "hardRate": "MEDIUM",
        "passRate": "47.13%",
        "problemsUrl": "https://leetcode.cn/problems/count-nice-pairs-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/count-nice-pairs-in-an-array/solution",
        "problemsDesc": "<p>给你一个数组 <code>nums</code> ，数组中只包含非负整数。定义 <code>rev(x)</code> 的值为将整数 <code>x</code> 各个数字位反转得到的结果。比方说 <code>rev(123) = 321</code> ， <code>rev(120) = 21</code> 。我们称满足下面条件的下标对 <code>(i, j)</code> 是 <strong>好的</strong> ：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; nums.length</code></li>\n\t<li><code>nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])</code></li>\n</ul>\n\n<p>请你返回好下标对的数目。由于结果可能会很大，请将结果对 <code>10<sup>9</sup> + 7</code> <b>取余</b> 后返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [42,11,1,97]\n<b>输出：</b>2\n<b>解释：</b>两个坐标对为：\n - (0,3)：42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121 。\n - (1,2)：11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [13,10,35,24,76]\n<b>输出：</b>4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1815.得到新鲜甜甜圈的最多组数",
        "hardRate": "HARD",
        "passRate": "53.43%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-groups-getting-fresh-donuts/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-groups-getting-fresh-donuts/solution",
        "problemsDesc": "<p>有一个甜甜圈商店，每批次都烤 <code>batchSize</code> 个甜甜圈。这个店铺有个规则，就是在烤一批新的甜甜圈时，之前 <strong>所有</strong> 甜甜圈都必须已经全部销售完毕。给你一个整数 <code>batchSize</code> 和一个整数数组 <code>groups</code> ，数组中的每个整数都代表一批前来购买甜甜圈的顾客，其中 <code>groups[i]</code> 表示这一批顾客的人数。每一位顾客都恰好只要一个甜甜圈。</p>\n\n<p>当有一批顾客来到商店时，他们所有人都必须在下一批顾客来之前购买完甜甜圈。如果一批顾客中第一位顾客得到的甜甜圈不是上一组剩下的，那么这一组人都会很开心。</p>\n\n<p>你可以随意安排每批顾客到来的顺序。请你返回在此前提下，<strong>最多</strong> 有多少组人会感到开心。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>batchSize = 3, groups = [1,2,3,4,5,6]\n<b>输出：</b>4\n<b>解释：</b>你可以将这些批次的顾客顺序安排为 [6,2,4,5,1,3] 。那么第 1，2，4，6 组都会感到开心。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>batchSize = 4, groups = [1,3,2,5,2,2,1,6]\n<b>输出：</b>4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= batchSize <= 9</code></li>\n\t<li><code>1 <= groups.length <= 30</code></li>\n\t<li><code>1 <= groups[i] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1816.截断句子",
        "hardRate": "EASY",
        "passRate": "72.30%",
        "problemsUrl": "https://leetcode.cn/problems/truncate-sentence/",
        "solutionsUrl": "https://leetcode.cn/problems/truncate-sentence/solution",
        "problemsDesc": "<p><strong>句子</strong> 是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。</p>\n\n<ul>\n\t<li>例如，<code>\"Hello World\"</code>、<code>\"HELLO\"</code> 和 <code>\"hello world hello world\"</code> 都是句子。</li>\n</ul>\n\n<p>给你一个句子 <code>s</code>​​​​​​ 和一个整数 <code>k</code>​​​​​​ ，请你将 <code>s</code>​​ <strong>截断</strong> ​，​​​使截断后的句子仅含 <strong>前</strong> <code>k</code>​​​​​​ 个单词。返回 <strong>截断</strong> <code>s</code>​​​​<em>​​ </em>后得到的句子<em>。</em></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"Hello how are you Contestant\", k = 4\n<strong>输出：</strong>\"Hello how are you\"\n<strong>解释：</strong>\ns 中的单词为 [\"Hello\", \"how\" \"are\", \"you\", \"Contestant\"]\n前 4 个单词为 [\"Hello\", \"how\", \"are\", \"you\"]\n因此，应当返回 \"Hello how are you\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"What is the solution to this problem\", k = 4\n<strong>输出：</strong>\"What is the solution\"\n<strong>解释：</strong>\ns 中的单词为 [\"What\", \"is\" \"the\", \"solution\", \"to\", \"this\", \"problem\"]\n前 4 个单词为 [\"What\", \"is\", \"the\", \"solution\"]\n因此，应当返回 \"What is the solution\"</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = \"chopper is not a tanuki\", k = 5\n<strong>输出：</strong>\"chopper is not a tanuki\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>k</code> 的取值范围是 <code>[1,  s 中单词的数目]</code></li>\n\t<li><code>s</code> 仅由大小写英文字母和空格组成</li>\n\t<li><code>s</code> 中的单词之间由单个空格隔开</li>\n\t<li>不存在前导或尾随空格</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1817.查找用户活跃分钟数",
        "hardRate": "MEDIUM",
        "passRate": "79.39%",
        "problemsUrl": "https://leetcode.cn/problems/finding-the-users-active-minutes/",
        "solutionsUrl": "https://leetcode.cn/problems/finding-the-users-active-minutes/solution",
        "problemsDesc": "<p>给你用户在 LeetCode 的操作日志，和一个整数 <code>k</code> 。日志用一个二维整数数组 <code>logs</code> 表示，其中每个 <code>logs[i] = [ID<sub>i</sub>, time<sub>i</sub>]</code> 表示 ID 为 <code>ID<sub>i</sub></code> 的用户在 <code>time<sub>i</sub></code> 分钟时执行了某个操作。</p>\n\n<p><strong>多个用户 </strong>可以同时执行操作，单个用户可以在同一分钟内执行 <strong>多个操作</strong> 。</p>\n\n<p>指定用户的<strong> 用户活跃分钟数（user active minutes，UAM）</strong> 定义为用户对 LeetCode 执行操作的 <strong>唯一分钟数</strong> 。 即使一分钟内执行多个操作，也只能按一分钟计数。</p>\n\n<p>请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 <code>k</code> 且 <strong>下标从 1 开始计数</strong> 的数组 <code>answer</code> ，对于每个 <code>j</code>（<code>1 <= j <= k</code>），<code>answer[j]</code> 表示 <strong>用户活跃分钟数</strong> 等于 <code>j</code> 的用户数。</p>\n\n<p>返回上面描述的答案数组<i> </i><code>answer</code><i> </i>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5\n<strong>输出：</strong>[0,2,0,0,0]\n<strong>解释：</strong>\nID=0 的用户执行操作的分钟分别是：5 、2 和 5 。因此，该用户的用户活跃分钟数为 2（分钟 5 只计数一次）\nID=1 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 2\n2 个用户的用户活跃分钟数都是 2 ，answer[2] 为 2 ，其余 answer[j] 的值都是 0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>logs = [[1,1],[2,2],[2,3]], k = 4\n<strong>输出：</strong>[1,1,0,0]\n<strong>解释：</strong>\nID=1 的用户仅在分钟 1 执行单个操作。因此，该用户的用户活跃分钟数为 1\nID=2 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 2\n1 个用户的用户活跃分钟数是 1 ，1 个用户的用户活跃分钟数是 2 \n因此，answer[1] = 1 ，answer[2] = 1 ，其余的值都是 0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= logs.length <= 10<sup>4</sup></code></li>\n\t<li><code>0 <= ID<sub>i</sub> <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= time<sub>i</sub> <= 10<sup>5</sup></code></li>\n\t<li><code>k</code> 的取值范围是 <code>[用户的最大用户活跃分钟数, 10<sup>5</sup>]</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1818.绝对差值和",
        "hardRate": "MEDIUM",
        "passRate": "37.59%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-absolute-sum-difference/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-absolute-sum-difference/solution",
        "problemsDesc": "<p>给你两个正整数数组 <code>nums1</code> 和 <code>nums2</code> ，数组的长度都是 <code>n</code> 。</p>\n\n<p>数组 <code>nums1</code> 和 <code>nums2</code> 的 <strong>绝对差值和</strong> 定义为所有 <code>|nums1[i] - nums2[i]|</code>（<code>0 <= i < n</code>）的 <strong>总和</strong>（<strong>下标从 0 开始</strong>）。</p>\n\n<p>你可以选用 <code>nums1</code> 中的 <strong>任意一个</strong> 元素来替换 <code>nums1</code> 中的 <strong>至多</strong> 一个元素，以 <strong>最小化</strong> 绝对差值和。</p>\n\n<p>在替换数组 <code>nums1</code> 中最多一个元素 <strong>之后</strong> ，返回最小绝对差值和。因为答案可能很大，所以需要对 <code>10<sup>9</sup> + 7</code> <strong>取余 </strong>后返回。</p>\n\n<p><code>|x|</code> 定义为：</p>\n\n<ul>\n\t<li>如果 <code>x >= 0</code> ，值为 <code>x</code> ，或者</li>\n\t<li>如果 <code>x <= 0</code> ，值为 <code>-x</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,7,5], nums2 = [2,3,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>有两种可能的最优方案：\n- 将第二个元素替换为第一个元素：[1,<strong>7</strong>,5] => [1,<strong>1</strong>,5] ，或者\n- 将第二个元素替换为第三个元素：[1,<strong>7</strong>,5] => [1,<strong>5</strong>,5]\n两种方案的绝对差值和都是 <code>|1-2| + (|1-3| 或者 |5-3|) + |5-5| = </code>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]\n<strong>输出：</strong>0\n<strong>解释：</strong>nums1 和 nums2 相等，所以不用替换元素。绝对差值和为 0\n</pre>\n\n<p><strong>示例 3</strong><strong>：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]\n<strong>输出：</strong>20\n<strong>解释：</strong>将第一个元素替换为第二个元素：[<strong>1</strong>,10,4,4,2,7] => [<strong>10</strong>,10,4,4,2,7]\n绝对差值和为 <code>|10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20</code>\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length</code></li>\n\t<li><code>n == nums2.length</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums1[i], nums2[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1819.序列中不同最大公约数的数目",
        "hardRate": "HARD",
        "passRate": "63.37%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-different-subsequences-gcds/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-different-subsequences-gcds/solution",
        "problemsDesc": "<p>给你一个由正整数组成的数组 <code>nums</code> 。</p>\n\n<p>数字序列的 <strong>最大公约数</strong> 定义为序列中所有整数的共有约数中的最大整数。</p>\n\n<ul>\n\t<li>例如，序列 <code>[4,6,16]</code> 的最大公约数是 <code>2</code> 。</li>\n</ul>\n\n<p>数组的一个 <strong>子序列</strong> 本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。</p>\n\n<ul>\n\t<li>例如，<code>[2,5,10]</code> 是 <code>[1,2,1,<strong>2</strong>,4,1,<strong>5</strong>,<strong>10</strong>]</code> 的一个子序列。</li>\n</ul>\n\n<p>计算并返回 <code>nums</code> 的所有 <strong>非空</strong> 子序列中 <strong>不同</strong> 最大公约数的 <strong>数目</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/03/image-1.png\" />\n<pre>\n<strong>输入：</strong>nums = [6,10,3]\n<strong>输出：</strong>5\n<strong>解释：</strong>上图显示了所有的非空子序列与各自的最大公约数。\n不同的最大公约数为 6 、10 、3 、2 和 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,15,40,5,6]\n<strong>输出：</strong>7\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 2 * 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1820.最多邀请的个数",
        "hardRate": "MEDIUM",
        "passRate": "47.50%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-accepted-invitations/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-accepted-invitations/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1821.寻找今年具有正收入的客户",
        "hardRate": "EASY",
        "passRate": "88.34%",
        "problemsUrl": "https://leetcode.cn/problems/find-customers-with-positive-revenue-this-year/",
        "solutionsUrl": "https://leetcode.cn/problems/find-customers-with-positive-revenue-this-year/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1822.数组元素积的符号",
        "hardRate": "EASY",
        "passRate": "71.70%",
        "problemsUrl": "https://leetcode.cn/problems/sign-of-the-product-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/sign-of-the-product-of-an-array/solution",
        "problemsDesc": "<p>已知函数 <code>signFunc(x)</code> 将会根据 <code>x</code> 的正负返回特定值：</p>\n\n<ul>\n\t<li>如果 <code>x</code> 是正数，返回 <code>1</code> 。</li>\n\t<li>如果 <code>x</code> 是负数，返回 <code>-1</code> 。</li>\n\t<li>如果 <code>x</code> 是等于 <code>0</code> ，返回 <code>0</code> 。</li>\n</ul>\n\n<p>给你一个整数数组 <code>nums</code> 。令 <code>product</code> 为数组 <code>nums</code> 中所有元素值的乘积。</p>\n\n<p>返回 <code>signFunc(product)</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,-2,-3,-4,3,2,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>数组中所有值的乘积是 144 ，且 signFunc(144) = 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5,0,2,-3]\n<strong>输出：</strong>0\n<strong>解释：</strong>数组中所有值的乘积是 0 ，且 signFunc(0) = 0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,1,-1,1,-1]\n<strong>输出：</strong>-1\n<strong>解释：</strong>数组中所有值的乘积是 -1 ，且 signFunc(-1) = -1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 1000</code></li>\n\t<li><code>-100 <= nums[i] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1823.找出游戏的获胜者",
        "hardRate": "MEDIUM",
        "passRate": "78.49%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-winner-of-the-circular-game/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-winner-of-the-circular-game/solution",
        "problemsDesc": "<p>共有 <code>n</code> 名小伙伴一起做游戏。小伙伴们围成一圈，按 <strong>顺时针顺序</strong> 从 <code>1</code> 到 <code>n</code> 编号。确切地说，从第 <code>i</code> 名小伙伴顺时针移动一位会到达第 <code>(i+1)</code> 名小伙伴的位置，其中 <code>1 &lt;= i &lt; n</code> ，从第 <code>n</code> 名小伙伴顺时针移动一位会回到第 <code>1</code> 名小伙伴的位置。</p>\n\n<p>游戏遵循如下规则：</p>\n\n<ol>\n\t<li>从第 <code>1</code> 名小伙伴所在位置 <strong>开始</strong> 。</li>\n\t<li>沿着顺时针方向数 <code>k</code> 名小伙伴，计数时需要 <strong>包含</strong> 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。</li>\n\t<li>你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。</li>\n\t<li>如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 <strong>顺时针下一位</strong> 小伙伴 <strong>开始</strong>，回到步骤 <code>2</code> 继续执行。</li>\n\t<li>否则，圈子中最后一名小伙伴赢得游戏。</li>\n</ol>\n\n<p>给你参与游戏的小伙伴总数 <code>n</code> ，和一个整数 <code>k</code> ，返回游戏的获胜者。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/ic234-q2-ex11.png\" style=\"width: 500px; height: 345px;\" />\n<pre>\n<strong>输入：</strong>n = 5, k = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>游戏运行步骤如下：\n1) 从小伙伴 1 开始。\n2) 顺时针数 2 名小伙伴，也就是小伙伴 1 和 2 。\n3) 小伙伴 2 离开圈子。下一次从小伙伴 3 开始。\n4) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 4 。\n5) 小伙伴 4 离开圈子。下一次从小伙伴 5 开始。\n6) 顺时针数 2 名小伙伴，也就是小伙伴 5 和 1 。\n7) 小伙伴 1 离开圈子。下一次从小伙伴 3 开始。\n8) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 5 。\n9) 小伙伴 5 离开圈子。只剩下小伙伴 3 。所以小伙伴 3 是游戏的获胜者。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6, k = 5\n<strong>输出：</strong>1\n<strong>解释：</strong>小伙伴离开圈子的顺序：5、4、6、2、3 。小伙伴 1 是游戏的获胜者。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 500</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能否使用线性时间复杂度和常数空间复杂度解决此问题？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1824.最少侧跳次数",
        "hardRate": "MEDIUM",
        "passRate": "68.36%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-sideway-jumps/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-sideway-jumps/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的 <strong>3 跑道道路</strong> ，它总共包含 <code>n + 1</code> 个 <strong>点</strong> ，编号为 <code>0</code> 到 <code>n</code> 。一只青蛙从 <code>0</code> 号点第二条跑道 <strong>出发</strong> ，它想要跳到点 <code>n</code> 处。然而道路上可能有一些障碍。</p>\n\n<p>给你一个长度为 <code>n + 1</code> 的数组 <code>obstacles</code> ，其中 <code>obstacles[i]</code> （<b>取值范围从 0 到 3</b>）表示在点 <code>i</code> 处的 <code>obstacles[i]</code> 跑道上有一个障碍。如果 <code>obstacles[i] == 0</code> ，那么点 <code>i</code> 处没有障碍。任何一个点的三条跑道中 <strong>最多有一个</strong> 障碍。</p>\n\n<ul>\n\t<li>比方说，如果 <code>obstacles[2] == 1</code> ，那么说明在点 2 处跑道 1 有障碍。</li>\n</ul>\n\n<p>这只青蛙从点 <code>i</code> 跳到点 <code>i + 1</code> 且跑道不变的前提是点 <code>i + 1</code> 的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在 <strong>同一个</strong> 点处 <strong>侧跳</strong> 到 <strong>另外一条</strong> 跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。</p>\n\n<ul>\n\t<li>比方说，这只青蛙可以从点 3 处的跑道 3 跳到点 3 处的跑道 1 。</li>\n</ul>\n\n<p>这只青蛙从点 0 处跑道 <code>2</code> 出发，并想到达点 <code>n</code> 处的 <strong>任一跑道</strong> ，请你返回 <strong>最少侧跳次数</strong> 。</p>\n\n<p><strong>注意</strong>：点 <code>0</code> 处和点 <code>n</code> 处的任一跑道都不会有障碍。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex1.png\" style=\"width: 500px; height: 244px;\" />\n<pre>\n<b>输入：</b>obstacles = [0,1,2,3,0]\n<b>输出：</b>2 \n<b>解释：</b>最优方案如上图箭头所示。总共有 2 次侧跳（红色箭头）。\n注意，这只青蛙只有当侧跳时才可以跳过障碍（如上图点 2 处所示）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex2.png\" style=\"width: 500px; height: 196px;\" />\n<pre>\n<b>输入：</b>obstacles = [0,1,1,3,3,0]\n<b>输出：</b>0\n<b>解释：</b>跑道 2 没有任何障碍，所以不需要任何侧跳。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex3.png\" style=\"width: 500px; height: 196px;\" />\n<pre>\n<b>输入：</b>obstacles = [0,2,1,0,3,0]\n<b>输出：</b>2\n<b>解释：</b>最优方案如上图所示。总共有 2 次侧跳。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>obstacles.length == n + 1</code></li>\n\t<li><code>1 <= n <= 5 * 10<sup>5</sup></code></li>\n\t<li><code>0 <= obstacles[i] <= 3</code></li>\n\t<li><code>obstacles[0] == obstacles[n] == 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1825.求出 MK 平均值",
        "hardRate": "HARD",
        "passRate": "43.46%",
        "problemsUrl": "https://leetcode.cn/problems/finding-mk-average/",
        "solutionsUrl": "https://leetcode.cn/problems/finding-mk-average/solution",
        "problemsDesc": "<p>给你两个整数&nbsp;<code>m</code>&nbsp;和&nbsp;<code>k</code>&nbsp;，以及数据流形式的若干整数。你需要实现一个数据结构，计算这个数据流的 <b>MK 平均值</b>&nbsp;。</p>\n\n<p><strong>MK 平均值</strong>&nbsp;按照如下步骤计算：</p>\n\n<ol>\n\t<li>如果数据流中的整数少于 <code>m</code>&nbsp;个，<strong>MK 平均值</strong>&nbsp;为 <code>-1</code>&nbsp;，否则将数据流中最后 <code>m</code>&nbsp;个元素拷贝到一个独立的容器中。</li>\n\t<li>从这个容器中删除最小的 <code>k</code>&nbsp;个数和最大的 <code>k</code>&nbsp;个数。</li>\n\t<li>计算剩余元素的平均值，并 <strong>向下取整到最近的整数</strong>&nbsp;。</li>\n</ol>\n\n<p>请你实现&nbsp;<code>MKAverage</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>MKAverage(int m, int k)</code>&nbsp;用一个空的数据流和两个整数 <code>m</code>&nbsp;和 <code>k</code>&nbsp;初始化&nbsp;<strong>MKAverage</strong>&nbsp;对象。</li>\n\t<li><code>void addElement(int num)</code>&nbsp;往数据流中插入一个新的元素&nbsp;<code>num</code>&nbsp;。</li>\n\t<li><code>int calculateMKAverage()</code>&nbsp;对当前的数据流计算并返回 <strong>MK 平均数</strong>&nbsp;，结果需 <strong>向下取整到最近的整数</strong> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"MKAverage\", \"addElement\", \"addElement\", \"calculateMKAverage\", \"addElement\", \"calculateMKAverage\", \"addElement\", \"addElement\", \"addElement\", \"calculateMKAverage\"]\n[[3, 1], [3], [1], [], [10], [], [5], [5], [5], []]\n<strong>输出：</strong>\n[null, null, null, -1, null, 3, null, null, null, 5]\n\n<strong>解释：</strong>\nMKAverage obj = new MKAverage(3, 1); \nobj.addElement(3);        // 当前元素为 [3]\nobj.addElement(1);        // 当前元素为 [3,1]\nobj.calculateMKAverage(); // 返回 -1 ，因为 m = 3 ，但数据流中只有 2 个元素\nobj.addElement(10);       // 当前元素为 [3,1,10]\nobj.calculateMKAverage(); // 最后 3 个元素为 [3,1,10]\n                          // 删除最小以及最大的 1 个元素后，容器为 [3]\n                          // [3] 的平均值等于 3/1 = 3 ，故返回 3\nobj.addElement(5);        // 当前元素为 [3,1,10,5]\nobj.addElement(5);        // 当前元素为 [3,1,10,5,5]\nobj.addElement(5);        // 当前元素为 [3,1,10,5,5,5]\nobj.calculateMKAverage(); // 最后 3 个元素为 [5,5,5]\n                          // 删除最小以及最大的 1 个元素后，容器为 [5]\n                          // [5] 的平均值等于 5/1 = 5 ，故返回 5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k*2 &lt; m</code></li>\n\t<li><code>1 &lt;= num &lt;= 10<sup>5</sup></code></li>\n\t<li><code>addElement</code> 与&nbsp;<code>calculateMKAverage</code>&nbsp;总操作次数不超过 <code>10<sup>5</sup></code> 次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1826.有缺陷的传感器",
        "hardRate": "EASY",
        "passRate": "41.74%",
        "problemsUrl": "https://leetcode.cn/problems/faulty-sensor/",
        "solutionsUrl": "https://leetcode.cn/problems/faulty-sensor/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1827.最少操作使数组递增",
        "hardRate": "EASY",
        "passRate": "81.28%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-array-increasing/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-array-increasing/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> （<strong>下标从 0 开始</strong>）。每一次操作中，你可以选择数组中一个元素，并将它增加 <code>1</code> 。</p>\n\n<ul>\n\t<li>比方说，如果 <code>nums = [1,2,3]</code> ，你可以选择增加 <code>nums[1]</code> 得到 <code>nums = [1,<b>3</b>,3]</code> 。</li>\n</ul>\n\n<p>请你返回使 <code>nums</code> <strong>严格递增</strong> 的 <strong>最少</strong> 操作次数。</p>\n\n<p>我们称数组 <code>nums</code> 是 <strong>严格递增的</strong> ，当它满足对于所有的 <code>0 &lt;= i &lt; nums.length - 1</code> 都有 <code>nums[i] &lt; nums[i+1]</code> 。一个长度为 <code>1</code> 的数组是严格递增的一种特殊情况。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,1,1]\n<b>输出：</b>3\n<b>解释：</b>你可以进行如下操作：\n1) 增加 nums[2] ，数组变为 [1,1,<strong>2</strong>] 。\n2) 增加 nums[1] ，数组变为 [1,<strong>2</strong>,2] 。\n3) 增加 nums[2] ，数组变为 [1,2,<strong>3</strong>] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,5,2,4,1]\n<b>输出：</b>14\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [8]\n<b>输出：</b>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1828.统计一个圆中点的数目",
        "hardRate": "MEDIUM",
        "passRate": "88.44%",
        "problemsUrl": "https://leetcode.cn/problems/queries-on-number-of-points-inside-a-circle/",
        "solutionsUrl": "https://leetcode.cn/problems/queries-on-number-of-points-inside-a-circle/solution",
        "problemsDesc": "<p>给你一个数组 <code>points</code> ，其中 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> ，表示第 <code>i</code> 个点在二维平面上的坐标。多个点可能会有 <strong>相同</strong> 的坐标。</p>\n\n<p>同时给你一个数组 <code>queries</code> ，其中 <code>queries[j] = [x<sub>j</sub>, y<sub>j</sub>, r<sub>j</sub>]</code> ，表示一个圆心在 <code>(x<sub>j</sub>, y<sub>j</sub>)</code> 且半径为 <code>r<sub>j</sub></code><sub> </sub>的圆。</p>\n\n<p>对于每一个查询 <code>queries[j]</code> ，计算在第 <code>j</code> 个圆 <strong>内</strong> 点的数目。如果一个点在圆的 <strong>边界上</strong> ，我们同样认为它在圆 <strong>内</strong> 。</p>\n\n<p>请你返回一个数组<em> </em><code>answer</code> ，其中<em> </em><code>answer[j]</code>是第 <code>j</code> 个查询的答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/chrome_2021-03-25_22-34-16.png\" style=\"width: 500px; height: 418px;\">\n<pre><b>输入：</b>points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]]\n<b>输出：</b>[3,2,2]\n<b>解释：</b>所有的点和圆如上图所示。\nqueries[0] 是绿色的圆，queries[1] 是红色的圆，queries[2] 是蓝色的圆。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/chrome_2021-03-25_22-42-07.png\" style=\"width: 500px; height: 390px;\">\n<pre><b>输入：</b>points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]\n<b>输出：</b>[2,3,2,4]\n<b>解释：</b>所有的点和圆如上图所示。\nqueries[0] 是绿色的圆，queries[1] 是红色的圆，queries[2] 是蓝色的圆，queries[3] 是紫色的圆。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= points.length &lt;= 500</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>​​​​​​i</sub>, y<sub>​​​​​​i</sub> &lt;= 500</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 500</code></li>\n\t<li><code>queries[j].length == 3</code></li>\n\t<li><code>0 &lt;= x<sub>j</sub>, y<sub>j</sub> &lt;= 500</code></li>\n\t<li><code>1 &lt;= r<sub>j</sub> &lt;= 500</code></li>\n\t<li>所有的坐标都是整数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1829.每个查询的最大异或值",
        "hardRate": "MEDIUM",
        "passRate": "72.21%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-xor-for-each-query/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-xor-for-each-query/solution",
        "problemsDesc": "<p>给你一个 <strong>有序</strong> 数组 <code>nums</code> ，它由 <code>n</code> 个非负整数组成，同时给你一个整数 <code>maximumBit</code> 。你需要执行以下查询 <code>n</code> 次：</p>\n\n<ol>\n\t<li>找到一个非负整数 <code>k < 2<sup>maximumBit</sup></code> ，使得 <code>nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k</code> 的结果 <strong>最大化</strong> 。<code>k</code> 是第 <code>i</code> 个查询的答案。</li>\n\t<li>从当前数组 <code>nums</code> 删除 <strong>最后</strong> 一个元素。</li>\n</ol>\n\n<p>请你返回一个数组 <code>answer</code> ，其中<em> </em><code>answer[i]</code>是第 <code>i</code> 个查询的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [0,1,1,3], maximumBit = 2\n<b>输出：</b>[0,3,2,3]\n<b>解释：</b>查询的答案如下：\n第一个查询：nums = [0,1,1,3]，k = 0，因为 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3 。\n第二个查询：nums = [0,1,1]，k = 3，因为 0 XOR 1 XOR 1 XOR 3 = 3 。\n第三个查询：nums = [0,1]，k = 2，因为 0 XOR 1 XOR 2 = 3 。\n第四个查询：nums = [0]，k = 3，因为 0 XOR 3 = 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,3,4,7], maximumBit = 3\n<b>输出：</b>[5,2,6,5]\n<b>解释：</b>查询的答案如下：\n第一个查询：nums = [2,3,4,7]，k = 5，因为 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7。\n第二个查询：nums = [2,3,4]，k = 2，因为 2 XOR 3 XOR 4 XOR 2 = 7 。\n第三个查询：nums = [2,3]，k = 6，因为 2 XOR 3 XOR 6 = 7 。\n第四个查询：nums = [2]，k = 5，因为 2 XOR 5 = 7 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [0,1,2,2,5,7], maximumBit = 3\n<b>输出：</b>[4,3,6,4,6,7]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length == n</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= maximumBit <= 20</code></li>\n\t<li><code>0 <= nums[i] < 2<sup>maximumBit</sup></code></li>\n\t<li><code>nums</code>​​​ 中的数字已经按 <strong>升序</strong> 排好序。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1830.使字符串有序的最少操作次数",
        "hardRate": "HARD",
        "passRate": "53.07%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-make-string-sorted/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-make-string-sorted/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> （<strong>下标从 0 开始</strong>）。你需要对 <code>s</code> 执行以下操作直到它变为一个有序字符串：</p>\n\n<ol>\n\t<li>找到 <strong>最大下标</strong> <code>i</code> ，使得 <code>1 &lt;= i &lt; s.length</code> 且 <code>s[i] &lt; s[i - 1]</code> 。</li>\n\t<li>找到 <strong>最大下标</strong> <code>j</code> ，使得 <code>i &lt;= j &lt; s.length</code> 且对于所有在闭区间 <code>[i, j]</code> 之间的 <code>k</code> 都有 <code>s[k] &lt; s[i - 1]</code> 。</li>\n\t<li>交换下标为 <code>i - 1</code>​​​​ 和 <code>j</code>​​​​ 处的两个字符。</li>\n\t<li>将下标 <code>i</code> 开始的字符串后缀反转。</li>\n</ol>\n\n<p>请你返回将字符串变成有序的最少操作次数。由于答案可能会很大，请返回它对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"cba\"\n<b>输出：</b>5\n<b>解释：</b>模拟过程如下所示：\n操作 1：i=2，j=2。交换 s[1] 和 s[2] 得到 s=\"cab\" ，然后反转下标从 2 开始的后缀字符串，得到 s=\"cab\" 。\n操作 2：i=1，j=2。交换 s[0] 和 s[2] 得到 s=\"bac\" ，然后反转下标从 1 开始的后缀字符串，得到 s=\"bca\" 。\n操作 3：i=2，j=2。交换 s[1] 和 s[2] 得到 s=\"bac\" ，然后反转下标从 2 开始的后缀字符串，得到 s=\"bac\" 。\n操作 4：i=1，j=1。交换 s[0] 和 s[1] 得到 s=\"abc\" ，然后反转下标从 1 开始的后缀字符串，得到 s=\"acb\" 。\n操作 5：i=2，j=2。交换 s[1] 和 s[2] 得到 s=\"abc\" ，然后反转下标从 2 开始的后缀字符串，得到 s=\"abc\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"aabaa\"\n<b>输出：</b>2\n<b>解释：</b>模拟过程如下所示：\n操作 1：i=3，j=4。交换 s[2] 和 s[4] 得到 s=\"aaaab\" ，然后反转下标从 3 开始的后缀字符串，得到 s=\"aaaba\" 。\n操作 2：i=4，j=4。交换 s[3] 和 s[4] 得到 s=\"aaaab\" ，然后反转下标从 4 开始的后缀字符串，得到 s=\"aaaab\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>s = \"cdbea\"\n<b>输出：</b>63</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>s = \"leetcodeleetcodeleetcode\"\n<b>输出：</b>982157772\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3000</code></li>\n\t<li><code>s</code>​ 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1831.每天的最大交易",
        "hardRate": "MEDIUM",
        "passRate": "77.78%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-transaction-each-day/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-transaction-each-day/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1832.判断句子是否为全字母句",
        "hardRate": "EASY",
        "passRate": "84.80%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-the-sentence-is-pangram/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-the-sentence-is-pangram/solution",
        "problemsDesc": "<p><strong>全字母句</strong> 指包含英语字母表中每个字母至少一次的句子。</p>\n\n<p>给你一个仅由小写英文字母组成的字符串 <code>sentence</code> ，请你判断 <code>sentence</code> 是否为 <strong>全字母句</strong> 。</p>\n\n<p>如果是，返回<em> </em><code>true</code> ；否则，返回<em> </em><code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"thequickbrownfoxjumpsoverthelazydog\"\n<strong>输出：</strong>true\n<strong>解释：</strong><code>sentence</code> 包含英语字母表中每个字母至少一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"leetcode\"\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= sentence.length <= 1000</code></li>\n\t<li><code>sentence</code> 由小写英语字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1833.雪糕的最大数量",
        "hardRate": "MEDIUM",
        "passRate": "68.05%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-ice-cream-bars/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-ice-cream-bars/solution",
        "problemsDesc": "<p>夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。</p>\n\n<p>商店中新到 <code>n</code> 支雪糕，用长度为 <code>n</code> 的数组 <code>costs</code> 表示雪糕的定价，其中 <code>costs[i]</code> 表示第 <code>i</code> 支雪糕的现金价格。Tony 一共有 <code>coins</code> 现金可以用于消费，他想要买尽可能多的雪糕。</p>\n\n<p><strong>注意：</strong>Tony 可以按任意顺序购买雪糕。</p>\n\n<p>给你价格数组 <code>costs</code> 和现金量 <code>coins</code> ，请你计算并返回 Tony 用 <code>coins</code> 现金能够买到的雪糕的 <strong>最大数量</strong> 。</p>\n\n<p>你必须使用计数排序解决此问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>costs = [1,3,2,4,1], coins = 7\n<strong>输出：</strong>4\n<strong>解释：</strong>Tony 可以买下标为 0、1、2、4 的雪糕，总价为 1 + 3 + 2 + 1 = 7\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>costs = [10,6,8,7,7,8], coins = 5\n<strong>输出：</strong>0\n<strong>解释：</strong>Tony 没有足够的钱买任何一支雪糕。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>costs = [1,6,3,1,2,5], coins = 20\n<strong>输出：</strong>6\n<strong>解释：</strong>Tony 可以买下所有的雪糕，总价为 1 + 6 + 3 + 1 + 2 + 5 = 18 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>costs.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= costs[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= coins &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1834.单线程 CPU",
        "hardRate": "MEDIUM",
        "passRate": "37.96%",
        "problemsUrl": "https://leetcode.cn/problems/single-threaded-cpu/",
        "solutionsUrl": "https://leetcode.cn/problems/single-threaded-cpu/solution",
        "problemsDesc": "<p>给你一个二维数组 <code>tasks</code> ，用于表示 <code>n</code>​​​​​​ 项从 <code>0</code> 到 <code>n - 1</code> 编号的任务。其中 <code>tasks[i] = [enqueueTime<sub>i</sub>, processingTime<sub>i</sub>]</code> 意味着第 <code>i<sup>​​​​​​</sup></code>​​​​ 项任务将会于 <code>enqueueTime<sub>i</sub></code> 时进入任务队列，需要 <code>processingTime<sub>i</sub></code><sub> </sub>的时长完成执行。</p>\n\n<p>现有一个单线程 CPU ，同一时间只能执行 <strong>最多一项</strong> 任务，该 CPU 将会按照下述方式运行：</p>\n\n<ul>\n\t<li>如果 CPU 空闲，且任务队列中没有需要执行的任务，则 CPU 保持空闲状态。</li>\n\t<li>如果 CPU 空闲，但任务队列中有需要执行的任务，则 CPU 将会选择 <strong>执行时间最短</strong> 的任务开始执行。如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。</li>\n\t<li>一旦某项任务开始执行，CPU 在 <strong>执行完整个任务</strong> 前都不会停止。</li>\n\t<li>CPU 可以在完成一项任务后，立即开始执行一项新任务。</li>\n</ul>\n\n<p>返回<em> </em>CPU<em> </em>处理任务的顺序。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>tasks = [[1,2],[2,4],[3,2],[4,1]]\n<strong>输出：</strong>[0,2,3,1]\n<strong>解释：</strong>事件按下述流程运行： \n- time = 1 ，任务 0 进入任务队列，可执行任务项 = {0}\n- 同样在 time = 1 ，空闲状态的 CPU 开始执行任务 0 ，可执行任务项 = {}\n- time = 2 ，任务 1 进入任务队列，可执行任务项 = {1}\n- time = 3 ，任务 2 进入任务队列，可执行任务项 = {1, 2}\n- 同样在 time = 3 ，CPU 完成任务 0 并开始执行队列中用时最短的任务 2 ，可执行任务项 = {1}\n- time = 4 ，任务 3 进入任务队列，可执行任务项 = {1, 3}\n- time = 5 ，CPU 完成任务 2 并开始执行队列中用时最短的任务 3 ，可执行任务项 = {1}\n- time = 6 ，CPU 完成任务 3 并开始执行任务 1 ，可执行任务项 = {}\n- time = 10 ，CPU 完成任务 1 并进入空闲状态\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]]\n<strong>输出：</strong>[4,3,2,0,1]\n<strong>解释：</strong>事件按下述流程运行： \n- time = 7 ，所有任务同时进入任务队列，可执行任务项  = {0,1,2,3,4}\n- 同样在 time = 7 ，空闲状态的 CPU 开始执行任务 4 ，可执行任务项 = {0,1,2,3}\n- time = 9 ，CPU 完成任务 4 并开始执行任务 3 ，可执行任务项 = {0,1,2}\n- time = 13 ，CPU 完成任务 3 并开始执行任务 2 ，可执行任务项 = {0,1}\n- time = 18 ，CPU 完成任务 2 并开始执行任务 0 ，可执行任务项 = {1}\n- time = 28 ，CPU 完成任务 0 并开始执行任务 1 ，可执行任务项 = {}\n- time = 40 ，CPU 完成任务 1 并进入空闲状态</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>tasks.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= enqueueTime<sub>i</sub>, processingTime<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1835.所有数对按位与结果的异或和",
        "hardRate": "HARD",
        "passRate": "56.02%",
        "problemsUrl": "https://leetcode.cn/problems/find-xor-sum-of-all-pairs-bitwise-and/",
        "solutionsUrl": "https://leetcode.cn/problems/find-xor-sum-of-all-pairs-bitwise-and/solution",
        "problemsDesc": "<p>列表的 <strong>异或和</strong>（<strong>XOR sum</strong>）指对所有元素进行按位 <code>XOR</code> 运算的结果。如果列表中仅有一个元素，那么其 <strong>异或和</strong> 就等于该元素。</p>\n\n<ul>\n\t<li>例如，<code>[1,2,3,4]</code> 的 <strong>异或和</strong> 等于 <code>1 XOR 2 XOR 3 XOR 4 = 4</code> ，而 <code>[3]</code> 的 <strong>异或和</strong> 等于 <code>3</code> 。</li>\n</ul>\n\n<p>给你两个下标 <strong>从 0 开始</strong> 计数的数组 <code>arr1</code> 和 <code>arr2</code> ，两数组均由非负整数组成。</p>\n\n<p>根据每个 <code>(i, j)</code> 数对，构造一个由 <code>arr1[i] AND arr2[j]</code>（按位 <code>AND</code> 运算）结果组成的列表。其中 <code>0 &lt;= i &lt; arr1.length</code> 且 <code>0 &lt;= j &lt; arr2.length</code> 。</p>\n\n<p>返回上述列表的 <strong>异或和</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr1 = [1,2,3], arr2 = [6,5]\n<strong>输出：</strong>0\n<strong>解释：</strong>列表 = [1 AND 6, 1 AND 5, 2 AND 6, 2 AND 5, 3 AND 6, 3 AND 5] = [0,1,2,0,2,1] ，\n异或和 = 0 XOR 1 XOR 2 XOR 0 XOR 2 XOR 1 = 0 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr1 = [12], arr2 = [4]\n<strong>输出：</strong>4\n<strong>解释：</strong>列表 = [12 AND 4] = [4] ，异或和 = 4 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr1.length, arr2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= arr1[i], arr2[j] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1836.从未排序的链表中移除重复元素",
        "hardRate": "MEDIUM",
        "passRate": "73.23%",
        "problemsUrl": "https://leetcode.cn/problems/remove-duplicates-from-an-unsorted-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-duplicates-from-an-unsorted-linked-list/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1837.K 进制表示下的各位数字总和",
        "hardRate": "EASY",
        "passRate": "79.10%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-digits-in-base-k/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-digits-in-base-k/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code>（<code>10</code> 进制）和一个基数 <code>k</code> ，请你将 <code>n</code> 从 <code>10</code> 进制表示转换为 <code>k</code> 进制表示，计算并返回转换后各位数字的 <strong>总和</strong> 。</p>\n\n<p>转换后，各位数字应当视作是 <code>10</code> 进制数字，且它们的总和也应当按 <code>10</code> 进制表示返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 34, k = 6\n<strong>输出：</strong>9\n<strong>解释：</strong>34 (10 进制) 在 6 进制下表示为 54 。5 + 4 = 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10, k = 10\n<strong>输出：</strong>1\n<strong>解释：</strong>n 本身就是 10 进制。 1 + 0 = 1 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>2 <= k <= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1838.最高频元素的频数",
        "hardRate": "MEDIUM",
        "passRate": "43.06%",
        "problemsUrl": "https://leetcode.cn/problems/frequency-of-the-most-frequent-element/",
        "solutionsUrl": "https://leetcode.cn/problems/frequency-of-the-most-frequent-element/solution",
        "problemsDesc": "<p>元素的 <strong>频数</strong> 是该元素在一个数组中出现的次数。</p>\n\n<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。在一步操作中，你可以选择 <code>nums</code> 的一个下标，并将该下标对应元素的值增加 <code>1</code> 。</p>\n\n<p>执行最多 <code>k</code> 次操作后，返回数组中最高频元素的 <strong>最大可能频数</strong> <em>。</em></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,4], k = 5\n<strong>输出：</strong>3<strong>\n解释：</strong>对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums = [4,4,4] 。\n4 是数组中最高频元素，频数是 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,4,8,13], k = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>存在多种最优解决方案：\n- 对第一个元素执行 3 次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。\n- 对第二个元素执行 4 次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。\n- 对第三个元素执行 5 次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,9,6], k = 2\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= k <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1839.所有元音按顺序排布的最长子字符串",
        "hardRate": "MEDIUM",
        "passRate": "49.05%",
        "problemsUrl": "https://leetcode.cn/problems/longest-substring-of-all-vowels-in-order/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-substring-of-all-vowels-in-order/solution",
        "problemsDesc": "<p>当一个字符串满足如下条件时，我们称它是 <b>美丽的</b> ：</p>\n\n<ul>\n\t<li>所有 5 个英文元音字母（<code>'a'</code> ，<code>'e'</code> ，<code>'i'</code> ，<code>'o'</code> ，<code>'u'</code>）都必须 <strong>至少</strong> 出现一次。</li>\n\t<li>这些元音字母的顺序都必须按照 <strong>字典序</strong> 升序排布（也就是说所有的 <code>'a'</code> 都在 <code>'e'</code> 前面，所有的 <code>'e'</code> 都在 <code>'i'</code> 前面，以此类推）</li>\n</ul>\n\n<p>比方说，字符串 <code>\"aeiou\"</code> 和 <code>\"aaaaaaeiiiioou\"</code> 都是 <strong>美丽的</strong> ，但是 <code>\"uaeio\"</code> ，<code>\"aeoiu\"</code> 和 <code>\"aaaeeeooo\"</code> <strong>不是美丽的</strong> 。</p>\n\n<p>给你一个只包含英文元音字母的字符串 <code>word</code> ，请你返回 <code>word</code> 中 <strong>最长美丽子字符串的长度</strong> 。如果不存在这样的子字符串，请返回 <code>0</code> 。</p>\n\n<p><strong>子字符串</strong> 是字符串中一个连续的字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>word = \"aeiaaio<strong>aaaaeiiiiouuu</strong>ooaauuaeiu\"\n<b>输出：</b>13\n<b>解释：</b>最长子字符串是 \"aaaaeiiiiouuu\" ，长度为 13 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>word = \"aeeeiiiioooauuu<strong>aeiou</strong>\"\n<b>输出：</b>5\n<b>解释：</b>最长子字符串是 \"aeiou\" ，长度为 5 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>word = \"a\"\n<b>输出：</b>0\n<b>解释：</b>没有美丽子字符串，所以返回 0 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word.length <= 5 * 10<sup>5</sup></code></li>\n\t<li><code>word</code> 只包含字符 <code>'a'</code>，<code>'e'</code>，<code>'i'</code>，<code>'o'</code> 和 <code>'u'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1840.最高建筑高度",
        "hardRate": "HARD",
        "passRate": "39.44%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-building-height/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-building-height/solution",
        "problemsDesc": "<p>在一座城市里，你需要建 <code>n</code> 栋新的建筑。这些新的建筑会从 <code>1</code> 到 <code>n</code> 编号排成一列。</p>\n\n<p>这座城市对这些新建筑有一些规定：</p>\n\n<ul>\n\t<li>每栋建筑的高度必须是一个非负整数。</li>\n\t<li>第一栋建筑的高度 <strong>必须</strong> 是 <code>0</code> 。</li>\n\t<li>任意两栋相邻建筑的高度差 <strong>不能超过</strong>  <code>1</code> 。</li>\n</ul>\n\n<p>除此以外，某些建筑还有额外的最高高度限制。这些限制会以二维整数数组 <code>restrictions</code> 的形式给出，其中 <code>restrictions[i] = [id<sub>i</sub>, maxHeight<sub>i</sub>]</code> ，表示建筑 <code>id<sub>i</sub></code> 的高度 <strong>不能超过</strong> <code>maxHeight<sub>i</sub></code> 。</p>\n\n<p>题目保证每栋建筑在 <code>restrictions</code> 中<strong> 至多出现一次</strong> ，同时建筑 <code>1</code> <strong>不会</strong> 出现在 <code>restrictions</code> 中。</p>\n\n<p>请你返回 <strong>最高</strong> 建筑能达到的 <strong>最高高度</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/25/ic236-q4-ex1-1.png\" style=\"width: 400px; height: 253px;\" />\n<pre>\n<b>输入：</b>n = 5, restrictions = [[2,1],[4,1]]\n<b>输出：</b>2\n<b>解释：</b>上图中的绿色区域为每栋建筑被允许的最高高度。\n我们可以使建筑高度分别为 [0,1,2,1,2] ，最高建筑的高度为 2 。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/25/ic236-q4-ex2.png\" style=\"width: 500px; height: 269px;\" />\n<pre>\n<b>输入：</b>n = 6, restrictions = []\n<b>输出：</b>5\n<b>解释：</b>上图中的绿色区域为每栋建筑被允许的最高高度。\n我们可以使建筑高度分别为 [0,1,2,3,4,5] ，最高建筑的高度为 5 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/25/ic236-q4-ex3.png\" style=\"width: 500px; height: 187px;\" />\n<pre>\n<b>输入：</b>n = 10, restrictions = [[5,3],[2,5],[7,4],[10,3]]\n<b>输出：</b>5\n<b>解释：</b>上图中的绿色区域为每栋建筑被允许的最高高度。\n我们可以使建筑高度分别为 [0,1,2,3,3,4,4,5,4,3] ，最高建筑的高度为 5 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 10<sup>9</sup></code></li>\n\t<li><code>0 <= restrictions.length <= min(n - 1, 10<sup>5</sup>)</code></li>\n\t<li><code>2 <= id<sub>i</sub> <= n</code></li>\n\t<li><code>id<sub>i</sub></code> 是 <strong>唯一的</strong> 。</li>\n\t<li><code>0 <= maxHeight<sub>i</sub> <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1841.联赛信息统计",
        "hardRate": "MEDIUM",
        "passRate": "52.71%",
        "problemsUrl": "https://leetcode.cn/problems/league-statistics/",
        "solutionsUrl": "https://leetcode.cn/problems/league-statistics/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1842.下个由相同数字构成的回文串",
        "hardRate": "HARD",
        "passRate": "55.86%",
        "problemsUrl": "https://leetcode.cn/problems/next-palindrome-using-same-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/next-palindrome-using-same-digits/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1843.可疑银行账户",
        "hardRate": "MEDIUM",
        "passRate": "43.67%",
        "problemsUrl": "https://leetcode.cn/problems/suspicious-bank-accounts/",
        "solutionsUrl": "https://leetcode.cn/problems/suspicious-bank-accounts/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1844.将所有数字用字符替换",
        "hardRate": "EASY",
        "passRate": "78.61%",
        "problemsUrl": "https://leetcode.cn/problems/replace-all-digits-with-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/replace-all-digits-with-characters/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，它的 <strong>偶数</strong> 下标处为小写英文字母，<strong>奇数</strong> 下标处为数字。</p>\n\n<p>定义一个函数 <code>shift(c, x)</code> ，其中 <code>c</code> 是一个字符且 <code>x</code> 是一个数字，函数返回字母表中 <code>c</code> 后面第 <code>x</code> 个字符。</p>\n\n<ul>\n\t<li>比方说，<code>shift('a', 5) = 'f'</code> 和 <code>shift('x', 0) = 'x'</code> 。</li>\n</ul>\n\n<p>对于每个 <strong>奇数</strong> 下标 <code>i</code> ，你需要将数字 <code>s[i]</code> 用 <code>shift(s[i-1], s[i])</code> 替换。</p>\n\n<p>请你替换所有数字以后，将字符串 <code>s</code> 返回。题目 <strong>保证</strong><em> </em><code>shift(s[i-1], s[i])</code> 不会超过 <code>'z'</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"a1c1e1\"\n<b>输出：</b>\"abcdef\"\n<strong>解释：</strong>数字被替换结果如下：\n- s[1] -&gt; shift('a',1) = 'b'\n- s[3] -&gt; shift('c',1) = 'd'\n- s[5] -&gt; shift('e',1) = 'f'</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"a1b2c3d4e\"\n<b>输出：</b>\"abbdcfdhe\"\n<strong>解释：</strong>数字被替换结果如下：\n- s[1] -&gt; shift('a',1) = 'b'\n- s[3] -&gt; shift('b',2) = 'd'\n- s[5] -&gt; shift('c',3) = 'f'\n- s[7] -&gt; shift('d',4) = 'h'</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 只包含小写英文字母和数字。</li>\n\t<li>对所有 <strong>奇数</strong> 下标处的 <code>i</code> ，满足 <code>shift(s[i-1], s[i]) &lt;= 'z'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1845.座位预约管理系统",
        "hardRate": "MEDIUM",
        "passRate": "48.19%",
        "problemsUrl": "https://leetcode.cn/problems/seat-reservation-manager/",
        "solutionsUrl": "https://leetcode.cn/problems/seat-reservation-manager/solution",
        "problemsDesc": "<p>请你设计一个管理 <code>n</code> 个座位预约的系统，座位编号从 <code>1</code> 到 <code>n</code> 。</p>\n\n<p>请你实现 <code>SeatManager</code> 类：</p>\n\n<ul>\n\t<li><code>SeatManager(int n)</code> 初始化一个 <code>SeatManager</code> 对象，它管理从 <code>1</code> 到 <code>n</code> 编号的 <code>n</code> 个座位。所有座位初始都是可预约的。</li>\n\t<li><code>int reserve()</code> 返回可以预约座位的 <strong>最小编号</strong> ，此座位变为不可预约。</li>\n\t<li><code>void unreserve(int seatNumber)</code> 将给定编号 <code>seatNumber</code> 对应的座位变成可以预约。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>\n[\"SeatManager\", \"reserve\", \"reserve\", \"unreserve\", \"reserve\", \"reserve\", \"reserve\", \"reserve\", \"unreserve\"]\n[[5], [], [], [2], [], [], [], [], [5]]\n<strong>输出：</strong>\n[null, 1, 2, null, 2, 3, 4, 5, null]\n\n<strong>解释：</strong>\nSeatManager seatManager = new SeatManager(5); // 初始化 SeatManager ，有 5 个座位。\nseatManager.reserve();    // 所有座位都可以预约，所以返回最小编号的座位，也就是 1 。\nseatManager.reserve();    // 可以预约的座位为 [2,3,4,5] ，返回最小编号的座位，也就是 2 。\nseatManager.unreserve(2); // 将座位 2 变为可以预约，现在可预约的座位为 [2,3,4,5] 。\nseatManager.reserve();    // 可以预约的座位为 [2,3,4,5] ，返回最小编号的座位，也就是 2 。\nseatManager.reserve();    // 可以预约的座位为 [3,4,5] ，返回最小编号的座位，也就是 3 。\nseatManager.reserve();    // 可以预约的座位为 [4,5] ，返回最小编号的座位，也就是 4 。\nseatManager.reserve();    // 唯一可以预约的是座位 5 ，所以返回 5 。\nseatManager.unreserve(5); // 将座位 5 变为可以预约，现在可预约的座位为 [5] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= seatNumber &lt;= n</code></li>\n\t<li>每一次对 <code>reserve</code> 的调用，题目保证至少存在一个可以预约的座位。</li>\n\t<li>每一次对 <code>unreserve</code> 的调用，题目保证 <code>seatNumber</code> 在调用函数前都是被预约状态。</li>\n\t<li>对 <code>reserve</code> 和 <code>unreserve</code> 的调用 <strong>总共</strong> 不超过 <code>10<sup>5</sup></code> 次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1846.减小和重新排列数组后的最大元素",
        "hardRate": "MEDIUM",
        "passRate": "63.05%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-element-after-decreasing-and-rearranging/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-element-after-decreasing-and-rearranging/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>arr</code> 。请你对 <code>arr</code> 执行一些操作（也可以不进行任何操作），使得数组满足以下条件：</p>\n\n<ul>\n\t<li><code>arr</code> 中 <strong>第一个</strong> 元素必须为 <code>1</code> 。</li>\n\t<li>任意相邻两个元素的差的绝对值 <strong>小于等于</strong> <code>1</code> ，也就是说，对于任意的 <code>1 <= i < arr.length</code> （<strong>数组下标从 0 开始</strong>），都满足 <code>abs(arr[i] - arr[i - 1]) <= 1</code> 。<code>abs(x)</code> 为 <code>x</code> 的绝对值。</li>\n</ul>\n\n<p>你可以执行以下 2 种操作任意次：</p>\n\n<ul>\n\t<li><strong>减小</strong> <code>arr</code> 中任意元素的值，使其变为一个 <strong>更小的正整数</strong> 。</li>\n\t<li><strong>重新排列</strong> <code>arr</code> 中的元素，你可以以任意顺序重新排列。</li>\n</ul>\n\n<p>请你返回执行以上操作后，在满足前文所述的条件下，<code>arr</code> 中可能的 <strong>最大值</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [2,2,1,2,1]\n<b>输出：</b>2\n<b>解释：</b>\n我们可以重新排列 arr 得到 <code>[1,2,2,2,1] ，该数组满足所有条件。</code>\narr 中最大元素为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [100,1,1000]\n<b>输出：</b>3\n<b>解释：</b>\n一个可行的方案如下：\n1. 重新排列 <code>arr</code> 得到 <code>[1,100,1000] 。</code>\n2. 将第二个元素减小为 2 。\n3. 将第三个元素减小为 3 。\n现在 <code>arr = [1,2,3] ，满足所有条件。</code>\narr 中最大元素为 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [1,2,3,4,5]\n<b>输出：</b>5\n<b>解释：</b>数组已经满足所有条件，最大元素为 5 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= arr.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= arr[i] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1847.最近的房间",
        "hardRate": "HARD",
        "passRate": "39.97%",
        "problemsUrl": "https://leetcode.cn/problems/closest-room/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-room/solution",
        "problemsDesc": "<p>一个酒店里有 <code>n</code> 个房间，这些房间用二维整数数组 <code>rooms</code> 表示，其中 <code>rooms[i] = [roomId<sub>i</sub>, size<sub>i</sub>]</code> 表示有一个房间号为 <code>roomId<sub>i</sub></code> 的房间且它的面积为 <code>size<sub>i</sub></code> 。每一个房间号 <code>roomId<sub>i</sub></code> 保证是 <strong>独一无二</strong> 的。</p>\n\n<p>同时给你 <code>k</code> 个查询，用二维数组 <code>queries</code> 表示，其中 <code>queries[j] = [preferred<sub>j</sub>, minSize<sub>j</sub>]</code> 。第 <code>j</code> 个查询的答案是满足如下条件的房间 <code>id</code> ：</p>\n\n<ul>\n\t<li>房间的面积 <b>至少</b> 为 <code>minSize<sub>j</sub></code> ，且</li>\n\t<li><code>abs(id - preferred<sub>j</sub>)</code> 的值 <strong>最小</strong> ，其中 <code>abs(x)</code> 是 <code>x</code> 的绝对值。</li>\n</ul>\n\n<p>如果差的绝对值有 <strong>相等</strong> 的，选择 <strong>最小</strong> 的 <code>id</code> 。如果 <strong>没有满足条件的房间</strong> ，答案为 <code>-1</code> 。</p>\n\n<p>请你返回长度为 <code>k</code> 的数组 <code>answer</code> ，其中<em> </em><code>answer[j]</code> 为第 <code>j</code> 个查询的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>rooms = [[2,2],[1,2],[3,2]], queries = [[3,1],[3,3],[5,2]]\n<b>输出：</b>[3,-1,3]\n<strong>解释：</strong>查询的答案如下：\n查询 [3,1] ：房间 3 的面积为 2 ，大于等于 1 ，且号码是最接近 3 的，为 abs(3 - 3) = 0 ，所以答案为 3 。\n查询 [3,3] ：没有房间的面积至少为 3 ，所以答案为 -1 。\n查询 [5,2] ：房间 3 的面积为 2 ，大于等于 2 ，且号码是最接近 5 的，为 abs(3 - 5) = 2 ，所以答案为 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>rooms = [[1,4],[2,3],[3,5],[4,1],[5,2]], queries = [[2,3],[2,4],[2,5]]\n<b>输出：</b>[2,1,3]\n<strong>解释：</strong>查询的答案如下：\n查询 [2,3] ：房间 2 的面积为 3 ，大于等于 3 ，且号码是最接近的，为 abs(2 - 2) = 0 ，所以答案为 2 。\n查询 [2,4] ：房间 1 和 3 的面积都至少为 4 ，答案为 1 因为它房间编号更小。\n查询 [2,5] ：房间 3 是唯一面积大于等于 5 的，所以答案为 3 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == rooms.length</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>k == queries.length</code></li>\n\t<li><code>1 <= k <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= roomId<sub>i</sub>, preferred<sub>j</sub> <= 10<sup>7</sup></code></li>\n\t<li><code>1 <= size<sub>i</sub>, minSize<sub>j</sub> <= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1848.到目标元素的最小距离",
        "hardRate": "EASY",
        "passRate": "66.17%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-distance-to-the-target-element/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-distance-to-the-target-element/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> （下标 <strong>从 0 开始</strong> 计数）以及两个整数 <code>target</code> 和 <code>start</code> ，请你找出一个下标 <code>i</code> ，满足 <code>nums[i] == target</code> 且 <code>abs(i - start)</code> <strong>最小化</strong> 。注意：<code>abs(x)</code> 表示 <code>x</code> 的绝对值。</p>\n\n<p>返回 <code>abs(i - start)</code> 。</p>\n\n<p>题目数据保证 <code>target</code> 存在于 <code>nums</code> 中。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4,5], target = 5, start = 3\n<strong>输出：</strong>1\n<strong>解释：</strong>nums[4] = 5 是唯一一个等于 target 的值，所以答案是 abs(4 - 3) = 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1], target = 1, start = 0\n<strong>输出：</strong>0\n<strong>解释：</strong>nums[0] = 1 是唯一一个等于 target 的值，所以答案是 abs(0 - 0) = 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0\n<strong>输出：</strong>0\n<strong>解释：</strong>nums 中的每个值都是 1 ，但 nums[0] 使 abs(i - start) 的结果得以最小化，所以答案是 abs(0 - 0) = 0 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 1000</code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>4</sup></code></li>\n\t<li><code>0 <= start < nums.length</code></li>\n\t<li><code>target</code> 存在于 <code>nums</code> 中</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1849.将字符串拆分为递减的连续值",
        "hardRate": "MEDIUM",
        "passRate": "33.22%",
        "problemsUrl": "https://leetcode.cn/problems/splitting-a-string-into-descending-consecutive-values/",
        "solutionsUrl": "https://leetcode.cn/problems/splitting-a-string-into-descending-consecutive-values/solution",
        "problemsDesc": "<p>给你一个仅由数字组成的字符串 <code>s</code> 。</p>\n\n<p>请你判断能否将 <code>s</code> 拆分成两个或者多个 <strong>非空子字符串</strong> ，使子字符串的 <strong>数值</strong> 按 <strong>降序</strong> 排列，且每两个 <strong>相邻子字符串</strong> 的数值之 <strong>差 </strong>等于 <code>1</code> 。</p>\n\n<ul>\n\t<li>例如，字符串 <code>s = \"0090089\"</code> 可以拆分成 <code>[\"0090\", \"089\"]</code> ，数值为 <code>[90,89]</code> 。这些数值满足按降序排列，且相邻值相差 <code>1</code> ，这种拆分方法可行。</li>\n\t<li>另一个例子中，字符串 <code>s = \"001\"</code> 可以拆分成 <code>[\"0\", \"01\"]</code>、<code>[\"00\", \"1\"]</code> 或 <code>[\"0\", \"0\", \"1\"]</code> 。然而，所有这些拆分方法都不可行，因为对应数值分别是 <code>[0,1]</code>、<code>[0,1]</code> 和 <code>[0,0,1]</code> ，都不满足按降序排列的要求。</li>\n</ul>\n\n<p>如果可以按要求拆分 <code>s</code> ，返回 <code>true</code> ；否则，返回 <code>false</code><em> </em>。</p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1234\"\n<strong>输出：</strong>false\n<strong>解释：</strong>不存在拆分 s 的可行方法。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"050043\"\n<strong>输出：</strong>true\n<strong>解释：</strong>s 可以拆分为 [\"05\", \"004\", \"3\"] ，对应数值为 [5,4,3] 。\n满足按降序排列，且相邻值相差 <code>1</code> 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"9080701\"\n<strong>输出：</strong>false\n<strong>解释：</strong>不存在拆分 s 的可行方法。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"10009998\"\n<strong>输出：</strong>true\n<strong>解释：</strong>s 可以拆分为 [\"100\", \"099\", \"98\"] ，对应数值为 [100,99,98] 。\n满足按降序排列，且相邻值相差 <code>1</code> 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 20</code></li>\n\t<li><code>s</code> 仅由数字组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1850.邻位交换的最小次数",
        "hardRate": "MEDIUM",
        "passRate": "62.81%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/solution",
        "problemsDesc": "<p>给你一个表示大整数的字符串 <code>num</code> ，和一个整数 <code>k</code> 。</p>\n\n<p>如果某个整数是 <code>num</code> 中各位数字的一个 <strong>排列</strong> 且它的 <strong>值大于</strong> <code>num</code> ，则称这个整数为 <strong>妙数</strong> 。可能存在很多妙数，但是只需要关注 <strong>值最小</strong> 的那些。</p>\n\n<ul>\n\t<li>例如，<code>num = \"5489355142\"</code> ：\n\n\t<ul>\n\t\t<li>第 1 个最小妙数是 <code>\"5489355214\"</code></li>\n\t\t<li>第 2 个最小妙数是 <code>\"5489355241\"</code></li>\n\t\t<li>第 3 个最小妙数是 <code>\"5489355412\"</code></li>\n\t\t<li>第 4 个最小妙数是 <code>\"5489355421\"</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>返回要得到第 <code>k</code> 个 <strong>最小妙数</strong> 需要对 <code>num</code> 执行的 <strong>相邻位数字交换的最小次数</strong> 。</p>\n\n<p>测试用例是按存在第 <code>k</code> 个最小妙数而生成的。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = \"5489355142\", k = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>第 4 个最小妙数是 \"5489355421\" ，要想得到这个数字：\n- 交换下标 7 和下标 8 对应的位：\"5489355<strong>14</strong>2\" -&gt; \"5489355<strong>41</strong>2\"\n- 交换下标 8 和下标 9 对应的位：\"54893554<strong>12</strong>\" -&gt; \"54893554<strong>21</strong>\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = \"11112\", k = 4\n<strong>输出：</strong>4\n<strong>解释：</strong>第 4 个最小妙数是 \"21111\" ，要想得到这个数字：\n- 交换下标 3 和下标 4 对应的位：\"111<strong>12</strong>\" -&gt; \"111<strong>21</strong>\"\n- 交换下标 2 和下标 3 对应的位：\"11<strong>12</strong>1\" -&gt; \"11<strong>21</strong>1\"\n- 交换下标 1 和下标 2 对应的位：\"1<strong>12</strong>11\" -&gt; \"1<strong>21</strong>11\"\n- 交换下标 0 和下标 1 对应的位：\"<strong>12</strong>111\" -&gt; \"<strong>21</strong>111\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = \"00123\", k = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>第 1 个最小妙数是 \"00132\" ，要想得到这个数字：\n- 交换下标 3 和下标 4 对应的位：\"001<strong>23</strong>\" -&gt; \"001<strong>32</strong>\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= num.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= k &lt;= 1000</code></li>\n\t<li><code>num</code> 仅由数字组成</li>\n</ul>\n",
        "isPlus": false
    }
]