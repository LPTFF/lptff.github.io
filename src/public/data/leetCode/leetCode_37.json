[
    {
        "problemsName": " 2701.连续递增交易",
        "hardRate": "HARD",
        "passRate": "31.91%",
        "problemsUrl": "https://leetcode.cn/problems/consecutive-transactions-with-increasing-amounts/",
        "solutionsUrl": "https://leetcode.cn/problems/consecutive-transactions-with-increasing-amounts/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2702.使数字变为非正数的最小操作次数",
        "hardRate": "HARD",
        "passRate": "51.35%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-numbers-non-positive/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-numbers-non-positive/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2703.返回传递的参数的长度",
        "hardRate": "EASY",
        "passRate": "93.70%",
        "problemsUrl": "https://leetcode.cn/problems/return-length-of-arguments-passed/",
        "solutionsUrl": "https://leetcode.cn/problems/return-length-of-arguments-passed/solution",
        "problemsDesc": "请你编写一个函数 <code>argumentsLength</code>，返回传递给该函数的参数数量。\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>argsArr = [5]\n<b>输出：</b>1\n<strong>解释：</strong>\nargumentsLength(5); // 1\n\n只传递了一个值给函数，因此它应返回 1。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>argsArr = [{}, null, \"3\"]\n<b>输出：</b>3\n<b>解释：</b>\nargumentsLength({}, null, \"3\"); // 3\n\n传递了三个值给函数，因此它应返回 3。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>argsArr 是一个有效的 JSON 数组</code></li>\n\t<li><code>0 &lt;= argsArr.length &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2704.相等还是不相等",
        "hardRate": "EASY",
        "passRate": "49.98%",
        "problemsUrl": "https://leetcode.cn/problems/to-be-or-not-to-be/",
        "solutionsUrl": "https://leetcode.cn/problems/to-be-or-not-to-be/solution",
        "problemsDesc": "<p>请你编写一个名为 <code>expect</code> 的函数，用于帮助开发人员测试他们的代码。它应该接受任何值 <code>val</code> 并返回一个包含以下两个函数的对象。</p>\n\n<ul>\n\t<li><code>toBe(val)</code> 接受另一个值并在两个值相等（ <code>===</code> ）时返回 <code>true</code> 。如果它们不相等，则应抛出错误 <code>\"Not Equal\"</code> 。</li>\n\t<li><code>notToBe(val)</code> 接受另一个值并在两个值不相等（ <code>!==</code> ）时返回 <code>true</code> 。如果它们相等，则应抛出错误 <code>\"Equal\"</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>func = () =&gt; expect(5).toBe(5)\n<b>输出：</b>{\"value\": true}\n<b>解释：</b>5 === 5 因此该表达式返回 true。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>func = () =&gt; expect(5).toBe(null)\n<b>输出：</b>{\"error\": \"Not Equal\"}\n<b>解释：</b>5 !== null 因此抛出错误 \"Not Equal\".\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>func = () =&gt; expect(5).notToBe(null)\n<b>输出：</b>{\"value\": true}\n<b>解释：</b>5 !== null 因此该表达式返回 true.\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2705.精简对象",
        "hardRate": "MEDIUM",
        "passRate": "59.95%",
        "problemsUrl": "https://leetcode.cn/problems/compact-object/",
        "solutionsUrl": "https://leetcode.cn/problems/compact-object/solution",
        "problemsDesc": "<p>现给定一个对象或数组 <code>obj</code>，返回一个 <strong>精简对象</strong> 。<strong>精简对象</strong> 与原始对象相同，只是将包含 <strong>假</strong> 值的键移除。该操作适用于对象及其嵌套对象。数组被视为索引作为键的对象。当 <code>Boolean(value)</code> 返回 <code>false</code> 时，值被视为 <strong>假</strong> 值。</p>\n\n<p>你可以假设 <code>obj</code> 是 <code>JSON.parse</code> 的输出结果。换句话说，它是有效的 JSON。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>obj = [null, 0, false, 1]\n<b>输出：</b>[1]\n<b>解释：</b>数组中的所有假值已被移除。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>obj = {\"a\": null, \"b\": [false, 1]}\n<b>输出：</b>{\"b\": [1]}\n<b>解释：</b>obj[\"a\"] 和 obj[\"b\"][0] 包含假值，因此被移除。</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>obj = [null, 0, 5, [0], [false, 16]]\n<b>输出：</b>[5, [], [16]]\n<b>解释：</b>obj[0], obj[1], obj[3][0], 和 obj[4][0] 包含假值，因此被移除。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>obj 是一个有效的 JSON 对象</code></li>\n\t<li><code>2 &lt;= JSON.stringify(obj).length &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2706.购买两块巧克力",
        "hardRate": "EASY",
        "passRate": "79.18%",
        "problemsUrl": "https://leetcode.cn/problems/buy-two-chocolates/",
        "solutionsUrl": "https://leetcode.cn/problems/buy-two-chocolates/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>prices</code>&nbsp;，它表示一个商店里若干巧克力的价格。同时给你一个整数&nbsp;<code>money</code>&nbsp;，表示你一开始拥有的钱数。</p>\n\n<p>你必须购买 <strong>恰好&nbsp;</strong>两块巧克力，而且剩余的钱数必须是 <strong>非负数</strong>&nbsp;。同时你想最小化购买两块巧克力的总花费。</p>\n\n<p>请你返回在购买两块巧克力后，最多能剩下多少钱。如果购买任意两块巧克力都超过了你拥有的钱，请你返回 <code>money</code>&nbsp;。注意剩余钱数必须是非负数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>prices = [1,2,2], money = 3\n<b>输出：</b>0\n<b>解释：</b>分别购买价格为 1 和 2 的巧克力。你剩下 3 - 3 = 0 块钱。所以我们返回 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>prices = [3,2,3], money = 3\n<b>输出：</b>3\n<b>解释：</b>购买任意 2 块巧克力都会超过你拥有的钱数，所以我们返回 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= prices.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= prices[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= money &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2707.字符串中的额外字符",
        "hardRate": "MEDIUM",
        "passRate": "42.05%",
        "problemsUrl": "https://leetcode.cn/problems/extra-characters-in-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/extra-characters-in-a-string/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>s</code>&nbsp;和一个单词字典&nbsp;<code>dictionary</code>&nbsp;。你需要将&nbsp;<code>s</code>&nbsp;分割成若干个 <strong>互不重叠</strong>&nbsp;的子字符串，每个子字符串都在&nbsp;<code>dictionary</code>&nbsp;中出现过。<code>s</code>&nbsp;中可能会有一些&nbsp;<strong>额外的字符</strong>&nbsp;不在任何子字符串中。</p>\n\n<p>请你采取最优策略分割 <code>s</code>&nbsp;，使剩下的字符 <strong>最少</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"leetscode\", dictionary = [\"leet\",\"code\",\"leetcode\"]\n<b>输出：</b>1\n<b>解释：</b>将 s 分成两个子字符串：下标从 0 到 3 的 \"leet\" 和下标从 5 到 8 的 \"code\" 。只有 1 个字符没有使用（下标为 4），所以我们返回 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"sayhelloworld\", dictionary = [\"hello\",\"world\"]\n<b>输出：</b>3\n<b>解释：</b>将 s 分成两个子字符串：下标从 3 到 7 的 \"hello\" 和下标从 8 到 12 的 \"world\" 。下标为 0 ，1 和 2 的字符没有使用，所以我们返回 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= dictionary.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= dictionary[i].length &lt;= 50</code></li>\n\t<li><code>dictionary[i]</code>&nbsp;和&nbsp;<code>s</code>&nbsp;只包含小写英文字母。</li>\n\t<li><code>dictionary</code>&nbsp;中的单词互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2708.一个小组的最大实力值",
        "hardRate": "MEDIUM",
        "passRate": "30.34%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-strength-of-a-group/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-strength-of-a-group/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，它表示一个班级中所有学生在一次考试中的成绩。老师想选出一部分同学组成一个 <strong>非空</strong>&nbsp;小组，且这个小组的 <strong>实力值</strong>&nbsp;最大，如果这个小组里的学生下标为&nbsp;<code>i<sub>0</sub></code>, <code>i<sub>1</sub></code>, <code>i<sub>2</sub></code>, ... , <code>i<sub>k</sub></code>&nbsp;，那么这个小组的实力值定义为&nbsp;<code>nums[i<sub>0</sub>] * nums[i<sub>1</sub>] * nums[i<sub>2</sub>] * ... * nums[i<sub>k</sub>​]</code>&nbsp;。</p>\n\n<p>请你返回老师创建的小组能得到的最大实力值为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [3,-1,-5,2,5,-9]\n<strong>输出：</strong>1350\n<b>解释：</b>一种构成最大实力值小组的方案是选择下标为 [0,2,3,4,5] 的学生。实力值为 3 * (-5) * 2 * 5 * (-9) = 1350 ，这是可以得到的最大实力值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [-4,-5,-4]\n<b>输出：</b>20\n<b>解释：</b>选择下标为 [0, 1] 的学生。得到的实力值为 20 。我们没法得到更大的实力值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 13</code></li>\n\t<li><code>-9 &lt;= nums[i] &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2709.最大公约数遍历",
        "hardRate": "HARD",
        "passRate": "24.24%",
        "problemsUrl": "https://leetcode.cn/problems/greatest-common-divisor-traversal/",
        "solutionsUrl": "https://leetcode.cn/problems/greatest-common-divisor-traversal/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，你可以在一些下标之间遍历。对于两个下标&nbsp;<code>i</code>&nbsp;和&nbsp;<code>j</code>（<code>i != j</code>），当且仅当&nbsp;<code>gcd(nums[i], nums[j]) &gt; 1</code>&nbsp;时，我们可以在两个下标之间通行，其中&nbsp;<code>gcd</code>&nbsp;是两个数的 <strong>最大公约数</strong>&nbsp;。</p>\n\n<p>你需要判断 <code>nums</code>&nbsp;数组中&nbsp;<strong>任意&nbsp;</strong>两个满足 <code>i &lt; j</code>&nbsp;的下标&nbsp;<code>i</code>&nbsp;和&nbsp;<code>j</code> ，是否存在若干次通行可以从 <code>i</code>&nbsp;遍历到 <code>j</code>&nbsp;。</p>\n\n<p>如果任意满足条件的下标对都可以遍历，那么返回 <code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,3,6]\n<b>输出：</b>true\n<b>解释：</b>这个例子中，总共有 3 个下标对：(0, 1) ，(0, 2) 和 (1, 2) 。\n从下标 0 到下标 1 ，我们可以遍历 0 -&gt; 2 -&gt; 1 ，我们可以从下标 0 到 2 是因为 gcd(nums[0], nums[2]) = gcd(2, 6) = 2 &gt; 1 ，从下标 2 到 1 是因为 gcd(nums[2], nums[1]) = gcd(6, 3) = 3 &gt; 1 。\n从下标 0 到下标 2 ，我们可以直接遍历，因为 gcd(nums[0], nums[2]) = gcd(2, 6) = 2 &gt; 1 。同理，我们也可以从下标 1 到 2 因为 gcd(nums[1], nums[2]) = gcd(3, 6) = 3 &gt; 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,9,5]\n<b>输出：</b>false\n<b>解释：</b>我们没法从下标 0 到 2 ，所以返回 false 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [4,3,12,8]\n<b>输出：</b>true\n<b>解释：</b>总共有 6 个下标对：(0, 1) ，(0, 2) ，(0, 3) ，(1, 2) ，(1, 3) 和 (2, 3) 。所有下标对之间都存在可行的遍历，所以返回 true 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2710.移除字符串中的尾随零",
        "hardRate": "EASY",
        "passRate": "83.42%",
        "problemsUrl": "https://leetcode.cn/problems/remove-trailing-zeros-from-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-trailing-zeros-from-a-string/solution",
        "problemsDesc": "<p>给你一个用字符串表示的正整数 <code>num</code> ，请你以字符串形式返回不含尾随零的整数<em> </em><code>num</code><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = \"51230100\"\n<strong>输出：</strong>\"512301\"\n<strong>解释：</strong>整数 \"51230100\" 有 2 个尾随零，移除并返回整数 \"512301\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = \"123\"\n<strong>输出：</strong>\"123\"\n<strong>解释：</strong>整数 \"123\" 不含尾随零，返回整数 \"123\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 1000</code></li>\n\t<li><code>num</code> 仅由数字 <code>0</code> 到 <code>9</code> 组成</li>\n\t<li><code>num</code> 不含前导零</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2711.对角线上不同值的数量差",
        "hardRate": "MEDIUM",
        "passRate": "71.95%",
        "problemsUrl": "https://leetcode.cn/problems/difference-of-number-of-distinct-values-on-diagonals/",
        "solutionsUrl": "https://leetcode.cn/problems/difference-of-number-of-distinct-values-on-diagonals/solution",
        "problemsDesc": "<p>给你一个下标从 <code>0</code> 开始、大小为 <code>m x n</code> 的二维矩阵 <code>grid</code> ，请你求解大小同样为 <code>m x n</code> 的答案矩阵 <code>answer</code> 。</p>\n\n<p>矩阵 <code>answer</code> 中每个单元格 <code>(r, c)</code> 的值可以按下述方式进行计算：</p>\n\n<ul>\n\t<li>令 <code>topLeft[r][c]</code> 为矩阵 <code>grid</code> 中单元格 <code>(r, c)</code> 左上角对角线上 <strong>不同值</strong> 的数量。</li>\n\t<li>令 <code>bottomRight[r][c]</code> 为矩阵 <code>grid</code> 中单元格 <code>(r, c)</code> 右下角对角线上 <strong>不同值</strong> 的数量。</li>\n</ul>\n\n<p>然后 <code>answer[r][c] = |topLeft[r][c] - bottomRight[r][c]|</code> 。</p>\n\n<p>返回矩阵 <code>answer</code> 。</p>\n\n<p><strong>矩阵对角线</strong> 是从最顶行或最左列的某个单元格开始，向右下方向走到矩阵末尾的对角线。</p>\n\n<p>如果单元格 <code>(r1, c1)</code> 和单元格 <code>(r, c) </code>属于同一条对角线且 <code>r1 &lt; r</code> ，则单元格 <code>(r1, c1)</code> 属于单元格 <code>(r, c)</code> 的左上对角线。类似地，可以定义右下对角线。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/19/ex2.png\" style=\"width: 786px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,2,3],[3,1,5],[3,2,1]]\n<strong>输出：</strong>[[1,1,0],[1,0,1],[0,1,1]]\n<strong>解释：</strong>第 1 个图表示最初的矩阵 grid 。&nbsp;\n第 2 个图表示对单元格 (0,0) 计算，其中蓝色单元格是位于右下对角线的单元格。\n第 3 个图表示对单元格 (1,2) 计算，其中红色单元格是位于左上对角线的单元格。\n第 4 个图表示对单元格 (1,1) 计算，其中蓝色单元格是位于右下对角线的单元格，红色单元格是位于左上对角线的单元格。\n- 单元格 (0,0) 的右下对角线包含 [1,1] ，而左上对角线包含 [] 。对应答案是 |1 - 0| = 1 。\n- 单元格 (1,2) 的右下对角线包含 [] ，而左上对角线包含 [2] 。对应答案是 |0 - 1| = 1 。\n- 单元格 (1,1) 的右下对角线包含 [1] ，而左上对角线包含 [1] 。对应答案是 |1 - 1| = 0 。\n其他单元格的对应答案也可以按照这样的流程进行计算。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1]]\n<strong>输出：</strong>[[0]]\n<strong>解释：</strong>- 单元格 (0,0) 的右下对角线包含 [] ，左上对角线包含 [] 。对应答案是 |0 - 0| = 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n, grid[i][j] &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2712.使所有字符相等的最小成本",
        "hardRate": "MEDIUM",
        "passRate": "56.20%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-make-all-characters-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-make-all-characters-equal/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的二进制字符串 <code>s</code> ，你可以对其执行两种操作：</p>\n\n<ul>\n\t<li>选中一个下标 <code>i</code> 并且反转从下标 <code>0</code> 到下标 <code>i</code>（包括下标 <code>0</code> 和下标 <code>i</code> ）的所有字符，成本为 <code>i + 1</code> 。</li>\n\t<li>选中一个下标 <code>i</code> 并且反转从下标 <code>i</code> 到下标 <code>n - 1</code>（包括下标 <code>i</code> 和下标 <code>n - 1</code> ）的所有字符，成本为 <code>n - i</code> 。</li>\n</ul>\n\n<p>返回使字符串内所有字符 <strong>相等</strong> 需要的 <strong>最小成本</strong> 。</p>\n\n<p><strong>反转</strong> 字符意味着：如果原来的值是 '0' ，则反转后值变为 '1' ，反之亦然。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0011\"\n<strong>输出：</strong>2\n<strong>解释：</strong>执行第二种操作，选中下标 <code>i = 2</code> ，可以得到 <code>s = \"0000\" ，成本为 2</code> 。可以证明 2 是使所有字符相等的最小成本。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"010101\"\n<strong>输出：</strong>9\n<strong>解释：</strong>执行第一种操作，选中下标 i = 2 ，可以得到 s = \"101101\" ，成本为 3 。\n执行第一种操作，选中下标 i = 1 ，可以得到 s = \"011101\" ，成本为 2 。\n执行第一种操作，选中下标 i = 0 ，可以得到 s = \"111101\" ，成本为 1 。\n执行第二种操作，选中下标 i = 4 ，可以得到 s = \"111110\" ，成本为 2 。\n执行第一种操作，选中下标 i = 5 ，可以得到 s = \"111111\" ，成本为 1 。\n使所有字符相等的总成本等于 9 。可以证明 9 是使所有字符相等的最小成本。 </pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length == n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2713.矩阵中严格递增的单元格数",
        "hardRate": "HARD",
        "passRate": "35.23%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>1</strong> 开始、大小为 <code>m x n</code> 的整数矩阵 <code>mat</code>，你可以选择任一单元格作为 <strong>起始单元格</strong> 。</p>\n\n<p>从起始单元格出发，你可以移动到 <strong>同一行或同一列</strong> 中的任何其他单元格，但前提是目标单元格的值<strong> 严格大于 </strong>当前单元格的值。</p>\n\n<p>你可以多次重复这一过程，从一个单元格移动到另一个单元格，直到无法再进行任何移动。</p>\n\n<p>请你找出从某个单元开始访问矩阵所能访问的 <strong>单元格的最大数量</strong> 。</p>\n\n<p>返回一个表示可访问单元格最大数量的整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/23/diag1drawio.png\" style=\"width: 200px; height: 176px;\"></strong></p>\n\n<pre><strong>输入：</strong>mat = [[3,1],[3,4]]\n<strong>输出：</strong>2\n<strong>解释：</strong>上图展示了从第 1 行、第 2 列的单元格开始，可以访问 2 个单元格。可以证明，无论从哪个单元格开始，最多只能访问 2 个单元格，因此答案是 2 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/23/diag3drawio.png\" style=\"width: 200px; height: 176px;\"></strong></p>\n\n<pre><strong>输入：</strong>mat = [[1,1],[1,1]]\n<strong>输出：</strong>1\n<strong>解释：</strong>由于目标单元格必须严格大于当前单元格，在本示例中只能访问 1 个单元格。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/23/diag4drawio.png\" style=\"width: 350px; height: 250px;\"></strong></p>\n\n<pre><strong>输入：</strong>mat = [[3,1,6],[-9,5,7]]\n<strong>输出：</strong>4\n<strong>解释：</strong>上图展示了从第 2 行、第 1 列的单元格开始，可以访问 4 个单元格。可以证明，无论从哪个单元格开始，最多只能访问 4 个单元格，因此答案是 4 。  \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length&nbsp;</code></li>\n\t<li><code>n == mat[i].length&nbsp;</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= mat[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2714.找到最短路径的 K 次跨越",
        "hardRate": "HARD",
        "passRate": "72.22%",
        "problemsUrl": "https://leetcode.cn/problems/find-shortest-path-with-k-hops/",
        "solutionsUrl": "https://leetcode.cn/problems/find-shortest-path-with-k-hops/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2715.执行可取消的延迟函数",
        "hardRate": "EASY",
        "passRate": "76.23%",
        "problemsUrl": "https://leetcode.cn/problems/execute-cancellable-function-with-delay/",
        "solutionsUrl": "https://leetcode.cn/problems/execute-cancellable-function-with-delay/solution",
        "problemsDesc": "<p>现给定一个函数 <code>fn</code>&nbsp;，一个参数数组 <code>args</code> 和一个以毫秒为单位的超时时间 <code>t</code> ，返回一个取消函数 <code>cancelFn</code> 。</p>\n\n<p>在经过 <code>t</code> 毫秒的延迟后，<strong>除非</strong> 先调用 <code>cancelFn</code> ，否则&nbsp;<code>fn</code> 应该以 <code>args</code> 作为参数被调用。并且在这种情况下，<code>fn</code> 不应该被调用。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1:</strong></p>\n\n<pre>\n<b>输入：</b>fn = (x) =&gt; x * 5, args = [2], t = 20, cancelTime = 50\n<b>输出：</b>[{\"time\": 20, \"returned\": 10}]\n<b>解释：</b>\nconst cancel = cancellable(fn, [2], 20); // // 在 t=20ms 时调用 fn(2)\nsetTimeout(cancel, 50);\n\ncancelTime（50ms）在延迟时间（20ms）之后，所以 fn(2) 应该在 t=20ms 时调用。fn 的返回值是 10。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>fn = (x) =&gt; x**2, args = [2], t = 100, cancelTime = 50\n<b>输出：</b>[]\n<b>解释：</b>fn(2) 从未被调用，因为 cancelTime（50ms）在延迟时间（100ms）之前。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>fn = (x1, x2) =&gt; x1 * x2, args = [2,4], t = 30, cancelTime = 100\n<b>输出：</b>[{\"time\": 30, \"returned\": 8}]\n<b>解释：</b>fn(2) 从未被调用，因为 cancelTime（50ms）在延迟时间（100ms）之前。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>fn 是一个函数</code></li>\n\t<li><code>args 是一个有效的 JSON 数组</code></li>\n\t<li><code>1 &lt;= args.length &lt;= 10</code></li>\n\t<li><code><font face=\"monospace\">20 &lt;= t &lt;= 1000</font></code></li>\n\t<li><code><font face=\"monospace\">10 &lt;= cancelT &lt;= 1000</font></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2716.最小化字符串长度",
        "hardRate": "EASY",
        "passRate": "72.37%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-string-length/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-string-length/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，重复执行下述操作 <strong>任意</strong> 次：</p>\n\n<ul>\n\t<li>在字符串中选出一个下标 <code>i</code> ，并使 <code>c</code> 为字符串下标 <code>i</code> 处的字符。并在 <code>i</code> <strong>左侧</strong>（如果有）和 <strong>右侧</strong>（如果有）各 <strong>删除 </strong>一个距离 <code>i</code> <strong>最近</strong> 的字符 <code>c</code> 。</li>\n</ul>\n\n<p>请你通过执行上述操作任意次，使 <code>s</code> 的长度 <strong>最小化</strong> 。</p>\n\n<p>返回一个表示 <strong>最小化</strong> 字符串的长度的整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aaabc\"\n<strong>输出：</strong>3\n<strong>解释：</strong>在这个示例中，s 等于 \"aaabc\" 。我们可以选择位于下标 1 处的字符 'a' 开始。接着删除下标 1 左侧最近的那个 'a'（位于下标 0）以及下标 1 右侧最近的那个 'a'（位于下标 2）。执行操作后，字符串变为 \"abc\" 。继续对字符串执行任何操作都不会改变其长度。因此，最小化字符串的长度是 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"cbbd\"\n<strong>输出：</strong>3\n<strong>解释：</strong>我们可以选择位于下标 1 处的字符 'b' 开始。下标 1 左侧不存在字符 'b' ，但右侧存在一个字符 'b'（位于下标 2），所以会删除位于下标 2 的字符 'b' 。执行操作后，字符串变为 \"cbd\" 。继续对字符串执行任何操作都不会改变其长度。因此，最小化字符串的长度是 3 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"dddaaa\"\n<strong>输出：</strong>2\n<strong>解释：</strong>我们可以选择位于下标 1 处的字符 'd' 开始。接着删除下标 1 左侧最近的那个 'd'（位于下标 0）以及下标 1 右侧最近的那个 'd'（位于下标 2）。执行操作后，字符串变为 \"daaa\" 。继续对新字符串执行操作，可以选择位于下标 2 的字符 'a' 。接着删除下标 2 左侧最近的那个 'a'（位于下标 1）以及下标 2 右侧最近的那个 'a'（位于下标 3）。执行操作后，字符串变为 \"da\" 。继续对字符串执行任何操作都不会改变其长度。因此，最小化字符串的长度是 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2717.半有序排列",
        "hardRate": "EASY",
        "passRate": "72.87%",
        "problemsUrl": "https://leetcode.cn/problems/semi-ordered-permutation/",
        "solutionsUrl": "https://leetcode.cn/problems/semi-ordered-permutation/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数排列 <code>nums</code> 。</p>\n\n<p>如果排列的第一个数字等于 <code>1</code> 且最后一个数字等于 <code>n</code> ，则称其为 <strong>半有序排列</strong> 。你可以执行多次下述操作，直到将 <code>nums</code> 变成一个 <strong>半有序排列</strong> ：</p>\n\n<ul>\n\t<li>选择 <code>nums</code> 中相邻的两个元素，然后交换它们。</li>\n</ul>\n\n<p>返回使 <code>nums</code> 变成 <strong>半有序排列</strong> 所需的最小操作次数。</p>\n\n<p><strong>排列</strong> 是一个长度为 <code>n</code> 的整数序列，其中包含从 <code>1</code> 到 <code>n</code> 的每个数字恰好一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,4,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>可以依次执行下述操作得到半有序排列：\n1 - 交换下标 0 和下标 1 对应元素。排列变为 [1,2,4,3] 。\n2 - 交换下标 2 和下标 3 对应元素。排列变为 [1,2,3,4] 。\n可以证明，要让 nums 成为半有序排列，不存在执行操作少于 2 次的方案。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,4,1,3]\n<strong>输出：</strong>3\n<strong>解释：\n</strong>可以依次执行下述操作得到半有序排列：\n1 - 交换下标 1 和下标 2 对应元素。排列变为 [2,1,4,3] 。\n2 - 交换下标 0 和下标 1 对应元素。排列变为 [1,2,4,3] 。\n3 - 交换下标 2 和下标 3 对应元素。排列变为 [1,2,3,4] 。\n可以证明，要让 nums 成为半有序排列，不存在执行操作少于 3 次的方案。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,4,2,5]\n<strong>输出：</strong>0\n<strong>解释：</strong>这个排列已经是一个半有序排列，无需执行任何操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length == n &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i]&nbsp;&lt;= 50</code></li>\n\t<li><code>nums</code> 是一个 <strong>排列</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2718.查询后矩阵的和",
        "hardRate": "MEDIUM",
        "passRate": "33.11%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-matrix-after-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-matrix-after-queries/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;和一个下标从 <strong>0</strong>&nbsp;开始的 <strong>二维数组</strong>&nbsp;<code>queries</code>&nbsp;，其中&nbsp;<code>queries[i] = [type<sub>i</sub>, index<sub>i</sub>, val<sub>i</sub>]</code>&nbsp;。</p>\n\n<p>一开始，给你一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>n x n</code>&nbsp;矩阵，所有元素均为 <code>0</code>&nbsp;。每一个查询，你需要执行以下操作之一：</p>\n\n<ul>\n\t<li>如果&nbsp;<code>type<sub>i</sub> == 0</code>&nbsp;，将第&nbsp;<code>index<sub>i</sub></code>&nbsp;行的元素全部修改为&nbsp;<code>val<sub>i</sub></code>&nbsp;，覆盖任何之前的值。</li>\n\t<li>如果&nbsp;<code>type<sub>i</sub> == 1</code>&nbsp;，将第&nbsp;<code>index<sub>i</sub></code>&nbsp;列的元素全部修改为 <code>val<sub>i</sub></code>&nbsp;，覆盖任何之前的值。</li>\n</ul>\n\n<p>请你执行完所有查询以后，返回矩阵中所有整数的和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/05/11/exm1.png\" style=\"width: 681px; height: 161px;\"></p>\n\n<pre><b>输入：</b>n = 3, queries = [[0,0,1],[1,2,2],[0,2,3],[1,0,4]]\n<b>输出：</b>23\n<b>解释：</b>上图展示了每个查询以后矩阵的值。所有操作执行完以后，矩阵元素之和为 23 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/05/11/exm2.png\" style=\"width: 681px; height: 331px;\"></p>\n\n<pre><b>输入：</b>n = 3, queries = [[0,0,4],[0,1,2],[1,0,1],[0,2,3],[1,2,1]]\n<b>输出：</b>17\n<b>解释：</b>上图展示了每一个查询操作之后的矩阵。所有操作执行完以后，矩阵元素之和为 17 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>queries[i].length == 3</code></li>\n\t<li><code>0 &lt;= type<sub>i</sub> &lt;= 1</code></li>\n\t<li><code>0 &lt;= index<sub>i</sub>&nbsp;&lt; n</code></li>\n\t<li><code>0 &lt;= val<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2719.统计整数数目",
        "hardRate": "HARD",
        "passRate": "47.22%",
        "problemsUrl": "https://leetcode.cn/problems/count-of-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/count-of-integers/solution",
        "problemsDesc": "<p>给你两个数字字符串&nbsp;<code>num1</code>&nbsp;和&nbsp;<code>num2</code>&nbsp;，以及两个整数&nbsp;<code>max_sum</code> 和&nbsp;<code>min_sum</code>&nbsp;。如果一个整数&nbsp;<code>x</code>&nbsp;满足以下条件，我们称它是一个好整数：</p>\n\n<ul>\n\t<li><code>num1 &lt;= x &lt;= num2</code></li>\n\t<li><code>min_sum &lt;= digit_sum(x) &lt;= max_sum</code>.</li>\n</ul>\n\n<p>请你返回好整数的数目。答案可能很大，请返回答案对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;取余后的结果。</p>\n\n<p>注意，<code>digit_sum(x)</code>&nbsp;表示&nbsp;<code>x</code>&nbsp;各位数字之和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>num1 = \"1\", num2 = \"12\", min_num = 1, max_num = 8\n<b>输出：</b>11\n<b>解释：</b>总共有 11 个整数的数位和在 1 到 8 之间，分别是 1,2,3,4,5,6,7,8,10,11 和 12 。所以我们返回 11 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>num1 = \"1\", num2 = \"5\", min_num = 1, max_num = 5\n<b>输出：</b>5\n<b>解释：</b>数位和在 1 到 5 之间的 5 个整数分别为 1,2,3,4 和 5 。所以我们返回 5 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num1 &lt;= num2 &lt;= 10<sup>22</sup></code></li>\n\t<li><code>1 &lt;= min_sum &lt;= max_sum &lt;= 400</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2720.受欢迎度百分比",
        "hardRate": "HARD",
        "passRate": "56.90%",
        "problemsUrl": "https://leetcode.cn/problems/popularity-percentage/",
        "solutionsUrl": "https://leetcode.cn/problems/popularity-percentage/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2721.并行执行异步函数",
        "hardRate": "MEDIUM",
        "passRate": "57.55%",
        "problemsUrl": "https://leetcode.cn/problems/execute-asynchronous-functions-in-parallel/",
        "solutionsUrl": "https://leetcode.cn/problems/execute-asynchronous-functions-in-parallel/solution",
        "problemsDesc": "<p>给定一个异步函数数组 <code>functions</code>，返回一个新的 promise 对象&nbsp;<code>promise</code>。数组中的每个函数都不接受参数并返回一个 promise。</p>\n\n<p><code>promise</code> resolve 条件：</p>\n\n<ul>\n\t<li>当所有从 <code>functions</code> 返回的 promise 都成功解析时。<code>promise</code> 的解析值应该是一个按照它们在 <code>functions</code> 中的顺序排列的 promise 的解析值数组。</li>\n</ul>\n\n<p><code>promise</code>&nbsp;reject 条件：</p>\n\n<ul>\n\t<li>当任何从 <code>functions</code> 返回的 promise 被拒绝时。<code>promise</code> 也会被拒绝，并返回第一个拒绝的原因。</li>\n</ul>\n\n<p>请在不使用内置的 <code>Promise.all</code> 函数的情况下解决。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>functions = [\n&nbsp; () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(5), 200))\n]\n<b>输出：</b>{\"t\": 200, \"resolved\": [5]}\n<b>解释：</b>\npromiseAll(functions).then(console.log); // [5]\n\n单个函数在 200 毫秒后以值 5 成功解析。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>functions = [\n    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(1), 200)), \n    () =&gt; new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(\"Error\"), 100))\n]\n<b>输出：</b>{\"t\": 100, \"rejected\": \"Error\"}\n<b>解释：</b>由于其中一个 promise 被拒绝，返回的 promise 也在同一时间被拒绝并返回相同的错误。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>functions = [\n    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(4), 50)), \n    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(10), 150)), \n    () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(16), 100))\n]\n<b>输出：</b>{\"t\": 150, \"resolved\": [4, 10, 16]}\n<b>解释：</b>所有的 promise 都成功执行。当最后一个 promise 被解析时，返回的 promise 也被解析了。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>functions&nbsp;is an array of functions that returns promises</code></li>\n\t<li><code>1 &lt;= functions.length &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2722.根据 ID 合并两个数组",
        "hardRate": "MEDIUM",
        "passRate": "47.69%",
        "problemsUrl": "https://leetcode.cn/problems/join-two-arrays-by-id/",
        "solutionsUrl": "https://leetcode.cn/problems/join-two-arrays-by-id/solution",
        "problemsDesc": "<p>现给定两个数组 <code>arr1</code> 和 <code>arr2</code> ，返回一个新的数组 <code>joinedArray</code> 。两个输入数组中的每个对象都包含一个 <code>id</code> 字段。<code>joinedArray</code> 是一个通过 <code>id</code> 将 <code>arr1</code> 和 <code>arr2</code> 连接而成的数组。<code>joinedArray</code> 的长度应为唯一值 <code>id</code> 的长度。返回的数组应按 <code>id</code> <strong>升序</strong> 排序。</p>\n\n<p>如果一个 <code>id</code> 存在于一个数组中但不存在于另一个数组中，则该对象应包含在结果数组中且不进行修改。</p>\n\n<p>如果两个对象共享一个 <code>id</code> ，则它们的属性应进行合并：</p>\n\n<ul>\n\t<li>如果一个键只存在于一个对象中，则该键值对应该包含在对象中。</li>\n\t<li>如果一个键在两个对象中都包含，则 <code>arr2</code> 中的值应覆盖 <code>arr1</code> 中的值。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>\narr1 = [\n&nbsp;   {\"id\": 1, \"x\": 1},\n&nbsp;   {\"id\": 2, \"x\": 9}\n], \narr2 = [\n    {\"id\": 3, \"x\": 5}\n]\n<b>输出：</b>\n[\n&nbsp;   {\"id\": 1, \"x\": 1},\n&nbsp;   {\"id\": 2, \"x\": 9},\n    {\"id\": 3, \"x\": 5}\n]\n<b>解释：</b>没有共同的 id，因此将 arr1 与 arr2 简单地连接起来。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>\narr1 = [\n    {\"id\": 1, \"x\": 2, \"y\": 3},\n    {\"id\": 2, \"x\": 3, \"y\": 6}\n], \narr2 = [\n    {\"id\": 2, \"x\": 10, \"y\": 20},\n    {\"id\": 3, \"x\": 0, \"y\": 0}\n]\n<b>输出：</b>\n[\n    {\"id\": 1, \"x\": 2, \"y\": 3},\n    {\"id\": 2, \"x\": 10, \"y\": 20},\n&nbsp;   {\"id\": 3, \"x\": 0, \"y\": 0}\n]\n<b>解释：</b>id 为 1 和 id 为 3 的对象在结果数组中保持不变。id 为 2 的两个对象合并在一起。arr2 中的键覆盖 arr1 中的值。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>\narr1 = [\n    {\"id\": 1, \"b\": {\"b\": 94},\"v\": [4, 3], \"y\": 48}\n]\narr2 = [\n    {\"id\": 1, \"b\": {\"c\": 84}, \"v\": [1, 3]}\n]\n<strong>输出：</strong> [\n    {\"id\": 1, \"b\": {\"c\": 84}, \"v\": [1, 3], \"y\": 48}\n]\n<b>解释：</b>具有 id 为 1 的对象合并在一起。对于键 \"b\" 和 \"v\" ，使用 arr2 中的值。由于键 \"y\" 只存在于 arr1 中，因此取 arr1 的值。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>arr1 和 arr2 都是有效的 JSON 数组</code></li>\n\t<li><code>在 arr1 和 arr2 中都有唯一的键值 id</code></li>\n\t<li><code>2 &lt;= JSON.stringify(arr1).length &lt;= 10<sup>6</sup></code></li>\n\t<li><code>2 &lt;= JSON.stringify(arr2).length &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2723.添加两个 Promise 对象",
        "hardRate": "EASY",
        "passRate": "87.16%",
        "problemsUrl": "https://leetcode.cn/problems/add-two-promises/",
        "solutionsUrl": "https://leetcode.cn/problems/add-two-promises/solution",
        "problemsDesc": "给定两个 promise 对象&nbsp;<code>promise1</code> 和 <code>promise2</code>，返回一个新的 promise。<code>promise1</code> 和 <code>promise2</code> 都会被解析为一个数字。返回的 Promise 应该解析为这两个数字的和。\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>\npromise1 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(2), 20)), \npromise2 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(5), 60))\n<b>输出：</b>7\n<b>解释：</b>两个输入的 Promise 分别解析为值 2 和 5。返回的 Promise 应该解析为 2 + 5 = 7。返回的 Promise 解析的时间不作为判断条件。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>\npromise1 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(10), 50)), \npromise2 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(-12), 30))\n<b>输出：</b>-2\n<b>解释：</b>两个输入的 Promise 分别解析为值 10 和 -12。返回的 Promise 应该解析为 10 + -12 = -2。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>promise1 和 promise2 都是被解析为一个数字的 promise 对象</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2724.排序方式",
        "hardRate": "EASY",
        "passRate": "77.56%",
        "problemsUrl": "https://leetcode.cn/problems/sort-by/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-by/solution",
        "problemsDesc": "<p>给定一个数组 <code>arr</code> 和一个函数 <code>fn</code>，返回一个排序后的数组 <code>sortedArr</code>。你可以假设 <code>fn</code> 只返回数字，并且这些数字决定了 <code>sortedArr</code> 的排序顺序。<code>sortedArr</code> 必须按照 <code>fn</code> 的输出值&nbsp;<strong>升序</strong> 排序。</p>\n\n<p>你可以假设对于给定的数组，<code>fn</code> 不会返回重复的数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [5, 4, 1, 2, 3], fn = (x) =&gt; x\n<b>输出：</b>[1, 2, 3, 4, 5]\n<b>解释：</b>fn 只是返回传入的数字，因此数组按升序排序。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [{\"x\": 1}, {\"x\": 0}, {\"x\": -1}], fn = (d) =&gt; d.x\n<b>输出：</b>[{\"x\": -1}, {\"x\": 0}, {\"x\": 1}]\n<b>解释：</b>fn 返回 \"x\" 键的值，因此数组根据该值排序。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [[3, 4], [5, 2], [10, 1]], fn = (x) =&gt; x[1]\n<b>输出：</b>[[10, 1], [5, 2], [3, 4]]\n<b>解释：</b>数组按照索引为 1 处的数字升序排序。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>arr 是一个有效的 JSON 数组</code></li>\n\t<li><code>fn 是一个函数，返回一个数字</code></li>\n\t<li><code>1 &lt;=&nbsp;arr.length &lt;= 5 * 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2725.间隔取消",
        "hardRate": "EASY",
        "passRate": "73.75%",
        "problemsUrl": "https://leetcode.cn/problems/interval-cancellation/",
        "solutionsUrl": "https://leetcode.cn/problems/interval-cancellation/solution",
        "problemsDesc": "现给定一个函数 <code>fn</code>，一个参数数组 <code>args</code> 和一个时间间隔 <code>t</code>，返回一个取消函数 <code>cancelFn</code>。函数 <code>fn</code> 应该立即使用 <code>args</code> 调用，并且在每个 <code>t</code> 毫秒内再次调用，直到调用 <code>cancelFn</code>。\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>fn = (x) =&gt; x * 2, args = [4], t = 20, cancelT = 110\n<b>输出：</b>\n[\n   {\"time\": 0, \"returned\": 8},\n   {\"time\": 20, \"returned\": 8},\n   {\"time\": 40, \"returned\": 8},\n   {\"time\": 60, \"returned\": 8},\n   {\"time\": 80, \"returned\": 8},\n   {\"time\": 100, \"returned\": 8}\n]\n<strong>解释：</strong> 每隔 20ms，调用 fn(4)。直到 t=110ms，然后取消。\nconst cancel = cancellable(x =&gt; x * 2, [4], 20);\nsetTimeout(cancel, 110);\n第一次调用 fn 是在 0ms。fn(4) 返回 8。\n第二次调用 fn 是在 20ms。fn(4) 返回 8。\n第三次调用 fn 是在 40ms。fn(4) 返回 8。\n第四次调用 fn 是在&nbsp;60ms。fn(4) 返回 8。\n第五次调用 fn 是在 80ms。fn(4) 返回 8。\n第六次调用 fn 是在 100ms。fn(4) 返回 8。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>fn = (x1, x2) =&gt; (x1 * x2), args = [2, 5], t = 25, cancelT = 140\n<strong>输出：</strong> \n[\n   {\"time\": 0, \"returned\": 10},\n   {\"time\": 25, \"returned\": 10},\n   {\"time\": 50, \"returned\": 10},\n   {\"time\": 75, \"returned\": 10},\n   {\"time\": 100, \"returned\": 10},\n   {\"time\": 125, \"returned\": 10}\n]\n<strong>解释：</strong>每隔 25ms，调用 fn(2, 5)。直到 t=140ms，然后取消。\n第一次调用 fn 是在 0ms\n第二次调用 fn 是在 25ms\n第三次调用 fn 是在 50ms\n第四次调用 fn 是在&nbsp;75ms\n第五次调用 fn 是在 100ms\n第六次调用 fn 是在 125ms\n在 140ms 取消\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>fn = (x1, x2, x3) =&gt; (x1 + x2 + x3), args = [5, 1, 3], t = 50, cancelT = 180\n<b>输出：</b>\n[\n   {\"time\": 0, \"returned\": 9},\n   {\"time\": 50, \"returned\": 9},\n   {\"time\": 100, \"returned\": 9},\n   {\"time\": 150, \"returned\": 9}\n]\n<b>解释：</b>每隔 50ms，调用 fn(5, 1, 3)。直到 t=180ms，然后取消。\n第一次调用 fn 是在 0ms\n第二次调用 fn 是在 50ms\n第三次调用 fn 是在 100ms\n第四次调用 fn 是在&nbsp;150ms\n在 180ms 取消\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>fn 是一个函数</code></li>\n\t<li><code>args 是一个有效的 JSON 数组</code></li>\n\t<li><code>1 &lt;= args.length &lt;= 10</code></li>\n\t<li><code><font face=\"monospace\">20 &lt;= t &lt;= 1000</font></code></li>\n\t<li><code><font face=\"monospace\">10 &lt;= cancelT &lt;= 1000</font></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2726.使用方法链的计算器",
        "hardRate": "EASY",
        "passRate": "59.64%",
        "problemsUrl": "https://leetcode.cn/problems/calculator-with-method-chaining/",
        "solutionsUrl": "https://leetcode.cn/problems/calculator-with-method-chaining/solution",
        "problemsDesc": "<p>设计一个类 <code>Calculator</code> 。该类应提供加法、减法、乘法、除法和乘方等数学运算功能。同时，它还应支持连续操作的方法链式调用。<code>Calculator</code> 类的构造函数应接受一个数字作为 <code>result</code> 的初始值。</p>\n\n<p>你的 <code>Calculator</code> 类应包含以下方法：</p>\n\n<ul>\n\t<li><code>add</code> - 将给定的数字 <code>value</code> 与 <code>result</code> 相加，并返回更新后的 <code>Calculator</code> 对象。</li>\n\t<li><code>subtract</code> - 从 <code>result</code> 中减去给定的数字 <code>value</code>&nbsp;，并返回更新后的 <code>Calculator</code> 对象。</li>\n\t<li><code>multiply</code> - 将 <code>result</code> 乘以给定的数字 <code>value</code> ，并返回更新后的&nbsp;<code>Calculator</code> 对象。</li>\n\t<li><code>divide</code> - 将 <code>result</code> 除以给定的数字 <code>value</code> ，并返回更新后的&nbsp;<code>Calculator</code> 对象。如果传入的值为 <code>0</code> ，则抛出错误 <code>\"Division by zero is not allowed\"</code> 。</li>\n\t<li><code>power</code> - 将 <code>result</code> 的值乘以给定的数字 <code>value</code> ，并返回更新后的&nbsp;<code>Calculator</code> 对象。</li>\n\t<li><code>getResult</code> - 返回 <code>result</code> 的值。</li>\n</ul>\n\n<p>结果与实际结果相差在 <code>10<sup>-5</sup></code><sup>&nbsp;</sup>范围内的解被认为是正确的。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre>\n<b>输入：</b>actions = [\"Calculator\", \"add\", \"subtract\", \"getResult\"], values = [10, 5, 7]\n<b>输出：</b>8\n<b>解释：</b>\nnew Calculator(10).add(5).subtract(7).getResult() // 10 + 5 - 7 = 8\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>actions = [\"Calculator\", \"multiply\", \"power\", \"getResult\"], values = [2, 5, 2]\n<b>输出：</b>100\n<b>解释：</b>\nnew Calculator(2).multiply(5).power(2).getResult() // (2 * 5) ^ 2 = 100\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>actions = [\"Calculator\", \"divide\", \"getResult\"], values = [20, 0]\n<b>输出：</b>\"Division by zero is not allowed\"\n<b>解释：</b>\nnew Calculator(20).divide(0).getResult() // 20 / 0 \n\n由于不能除以零，因此应抛出错误。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= actions.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= values.length &lt;= 2 * 10<sup>4</sup></code><code>&nbsp;- 1</code></li>\n\t<li><code>actions[i] 是 \"Calculator\", \"add\", \"subtract\", \"multiply\", \"divide\", \"power\", 和 \"getResult\" 其中的元素</code></li>\n\t<li><code><font face=\"monospace\">最后一个操作总是&nbsp;\"getResult\"</font></code></li>\n\t<li><code><font face=\"monospace\">values </font>是一个数字的 JSON 数组</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2727.判断对象是否为空",
        "hardRate": "EASY",
        "passRate": "70.97%",
        "problemsUrl": "https://leetcode.cn/problems/is-object-empty/",
        "solutionsUrl": "https://leetcode.cn/problems/is-object-empty/solution",
        "problemsDesc": "<p>给定一个对象或数组，判断它是否为空。</p>\n\n<ul>\n\t<li>一个空对象不包含任何键值对。</li>\n\t<li>一个空数组不包含任何元素。</li>\n</ul>\n\n<p>你可以假设对象或数组是通过 <code>JSON.parse</code> 解析得到的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>obj = {\"x\": 5, \"y\": 42}\n<b>输出：</b>false\n<b>解释：</b>The object has 2 key-value pairs so it is not empty.\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>obj = {}\n<b>输出：</b>true\n<b>解释：</b>The object doesn't have any key-value pairs so it is empty.\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>obj = [null, false, 0]\n<b>输出：</b>false\n<b>解释：</b>The array has 3 elements so it is not empty.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>&nbsp;<code>2 &lt;= JSON.stringify(obj).length &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>你可以在 O(1) 时间复杂度内解决这个问题吗？</strong>",
        "isPlus": false
    },
    {
        "problemsName": " 2728.计算一个环形街道上的房屋数量",
        "hardRate": "EASY",
        "passRate": "87.37%",
        "problemsUrl": "https://leetcode.cn/problems/count-houses-in-a-circular-street/",
        "solutionsUrl": "https://leetcode.cn/problems/count-houses-in-a-circular-street/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2729.判断一个数是否迷人",
        "hardRate": "EASY",
        "passRate": "62.64%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-the-number-is-fascinating/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-the-number-is-fascinating/solution",
        "problemsDesc": "<p>给你一个三位数整数 <code>n</code>&nbsp;。</p>\n\n<p>如果经过以下修改得到的数字 <strong>恰好</strong>&nbsp;包含数字 <code>1</code>&nbsp;到 <code>9</code>&nbsp;各一次且不包含任何 <code>0</code>&nbsp;，那么我们称数字 <code>n</code>&nbsp;是 <strong>迷人的</strong>&nbsp;：</p>\n\n<ul>\n\t<li>将&nbsp;<code>n</code>&nbsp;与数字&nbsp;<code>2 * n</code> 和&nbsp;<code>3 * n</code>&nbsp;<strong>连接</strong>&nbsp;。</li>\n</ul>\n\n<p>如果 <code>n</code>&nbsp;是迷人的，返回&nbsp;<code>true</code>，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p><strong>连接</strong>&nbsp;两个数字表示把它们首尾相接连在一起。比方说&nbsp;<code>121</code> 和&nbsp;<code>371</code>&nbsp;连接得到&nbsp;<code>121371</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 192\n<b>输出：</b>true\n<b>解释：</b>我们将数字 n = 192 ，2 * n = 384 和 3 * n = 576 连接，得到 192384576 。这个数字包含 1 到 9 恰好各一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 100\n<b>输出：</b>false\n<b>解释：</b>我们将数字 n = 100 ，2 * n = 200 和 3 * n = 300 连接，得到 100200300 。这个数字不符合上述条件。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>100 &lt;= n &lt;= 999</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2730.找到最长的半重复子字符串",
        "hardRate": "MEDIUM",
        "passRate": "45.77%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-longest-semi-repetitive-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-longest-semi-repetitive-substring/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>s</code>&nbsp;，这个字符串只包含&nbsp;<code>0</code>&nbsp;到&nbsp;<code>9</code>&nbsp;的数字字符。</p>\n\n<p>如果一个字符串&nbsp;<code>t</code>&nbsp;中至多有一对相邻字符是相等的，那么称这个字符串 <code>t</code> 是 <strong>半重复的</strong>&nbsp;。例如，<code>0010</code> 、<code>002020</code> 、<code>0123</code> 、<code>2002</code> 和 <code>54944</code> 是半重复字符串，而 <code>00101022</code> 和 <code>1101234883</code> 不是。</p>\n\n<p>请你返回 <code>s</code>&nbsp;中最长 <strong>半重复</strong>&nbsp;子字符串的长度。</p>\n\n<p>一个 <strong>子字符串</strong>&nbsp;是一个字符串中一段连续 <strong>非空</strong>&nbsp;的字符。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"52233\"\n<b>输出：</b>4\n<b>解释：</b>最长半重复子字符串是 \"5223\" ，子字符串从 i = 0 开始，在 j = 3 处结束。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"5494\"\n<b>输出：</b>4\n<b>解释：</b>s 就是一个半重复字符串，所以答案为 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"1111111\"\n<b>输出：</b>2\n<b>解释：</b>最长半重复子字符串是 \"11\" ，子字符串从 i = 0 开始，在 j = 1 处结束。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 50</code></li>\n\t<li><code>'0' &lt;= s[i] &lt;= '9'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2731.移动机器人",
        "hardRate": "MEDIUM",
        "passRate": "33.82%",
        "problemsUrl": "https://leetcode.cn/problems/movement-of-robots/",
        "solutionsUrl": "https://leetcode.cn/problems/movement-of-robots/solution",
        "problemsDesc": "<p>有一些机器人分布在一条无限长的数轴上，他们初始坐标用一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;表示。当你给机器人下达命令时，它们以每秒钟一单位的速度开始移动。</p>\n\n<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，每个字符按顺序分别表示每个机器人移动的方向。<code>'L'</code>&nbsp;表示机器人往左或者数轴的负方向移动，<code>'R'</code>&nbsp;表示机器人往右或者数轴的正方向移动。</p>\n\n<p>当两个机器人相撞时，它们开始沿着原本相反的方向移动。</p>\n\n<p>请你返回指令重复执行 <code>d</code>&nbsp;秒后，所有机器人之间两两距离之和。由于答案可能很大，请你将答案对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;取余后返回。</p>\n\n<p><b>注意：</b></p>\n\n<ul>\n\t<li>对于坐标在&nbsp;<code>i</code> 和&nbsp;<code>j</code>&nbsp;的两个机器人，<code>(i,j)</code>&nbsp;和&nbsp;<code>(j,i)</code>&nbsp;视为相同的坐标对。也就是说，机器人视为无差别的。</li>\n\t<li>当机器人相撞时，它们 <strong>立即改变</strong>&nbsp;它们的前进时间，这个过程不消耗任何时间。</li>\n\t<li>\n\t<p>当两个机器人在同一时刻占据相同的位置时，就会相撞。</p>\n\n\t<ul>\n\t\t<li>\n\t\t<p>例如，如果一个机器人位于位置 0 并往右移动，另一个机器人位于位置 2 并往左移动，下一秒，它们都将占据位置 1，并改变方向。再下一秒钟后，第一个机器人位于位置 0 并往左移动，而另一个机器人位于位置 2 并往右移动。</p>\n\t\t</li>\n\t\t<li>\n\t\t<p>例如，如果一个机器人位于位置 0 并往右移动，另一个机器人位于位置 1 并往左移动，下一秒，第一个机器人位于位置 0 并往左行驶，而另一个机器人位于位置 1 并往右移动。</p>\n\t\t</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [-2,0,2], s = \"RLL\", d = 3\n<b>输出：</b>8\n<b>解释：</b>\n1 秒后，机器人的位置为 [-1,-1,1] 。现在下标为 0 的机器人开始往左移动，下标为 1 的机器人开始往右移动。\n2 秒后，机器人的位置为 [-2,0,0] 。现在下标为 1 的机器人开始往左移动，下标为 2 的机器人开始往右移动。\n3 秒后，机器人的位置为 [-3,-1,1] 。\n下标为 0 和 1 的机器人之间距离为 abs(-3 - (-1)) = 2 。\n下标为 0 和 2 的机器人之间的距离为 abs(-3 - 1) = 4 。\n下标为 1 和 2 的机器人之间的距离为 abs(-1 - 1) = 2 。\n所有机器人对之间的总距离为 2 + 4 + 2 = 8 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,0], s = \"RL\", d = 2\n<b>输出：</b>5\n<b>解释：</b>\n1 秒后，机器人的位置为 [2,-1] 。\n2 秒后，机器人的位置为 [3,-2] 。\n两个机器人的距离为 abs(-2 - 3) = 5 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-2 * 10<sup>9</sup>&nbsp;&lt;= nums[i] &lt;= 2 * 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= d &lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums.length == s.length&nbsp;</code></li>\n\t<li><code>s</code>&nbsp;只包含&nbsp;<code>'L'</code> 和 <code>'R'</code>&nbsp;。</li>\n\t<li><code>nums[i]</code>&nbsp;互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2732.找到矩阵中的好子集",
        "hardRate": "HARD",
        "passRate": "56.73%",
        "problemsUrl": "https://leetcode.cn/problems/find-a-good-subset-of-the-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/find-a-good-subset-of-the-matrix/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始大小为&nbsp;<code>m x n</code>&nbsp;的二进制矩阵&nbsp;<code>grid</code>&nbsp;。</p>\n\n<p>从原矩阵中选出若干行构成一个行的 <strong>非空&nbsp;</strong>子集，如果子集中任何一列的和至多为子集大小的一半，那么我们称这个子集是 <strong>好子集</strong>。</p>\n\n<p>更正式的，如果选出来的行子集大小（即行的数量）为 k，那么每一列的和至多为&nbsp;<code>floor(k / 2)</code>&nbsp;。</p>\n\n<p>请你返回一个整数数组，它包含好子集的行下标，请你将子集中的元素&nbsp;<b>升序</b>&nbsp;返回。</p>\n\n<p>如果有多个好子集，你可以返回任意一个。如果没有好子集，请你返回一个空数组。</p>\n\n<p>一个矩阵 <code>grid</code>&nbsp;的行 <strong>子集</strong> ，是删除 <code>grid</code>&nbsp;中某些（也可能不删除）行后，剩余行构成的元素集合。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>grid = [[0,1,1,0],[0,0,0,1],[1,1,1,1]]\n<b>输出：</b>[0,1]\n<b>解释：</b>我们可以选择第 0 和第 1 行构成一个好子集。\n选出来的子集大小为 2 。\n- 第 0&nbsp;列的和为 0 + 0 = 0 ，小于等于子集大小的一半。\n- 第 1&nbsp;列的和为 1 + 0 = 1 ，小于等于子集大小的一半。\n- 第 2&nbsp;列的和为 1 + 0 = 1 ，小于等于子集大小的一半。\n- 第 3&nbsp;列的和为 0 + 1 = 1 ，小于等于子集大小的一半。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>grid = [[0]]\n<b>输出：</b>[0]\n<strong>解释：</strong>我们可以选择第 0 行构成一个好子集。\n选出来的子集大小为 1 。\n- 第 0 列的和为 0 ，小于等于子集大小的一半。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>grid = [[1,1,1],[1,1,1]]\n<b>输出：</b>[]\n<b>解释：</b>没有办法得到一个好子集。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= n &lt;= 5</code></li>\n\t<li><code>grid[i][j]</code>&nbsp;要么是&nbsp;<code>0</code>&nbsp;，要么是&nbsp;<code>1</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2733.既不是最小值也不是最大值",
        "hardRate": "EASY",
        "passRate": "79.91%",
        "problemsUrl": "https://leetcode.cn/problems/neither-minimum-nor-maximum/",
        "solutionsUrl": "https://leetcode.cn/problems/neither-minimum-nor-maximum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，数组由 <strong>不同正整数</strong> 组成，请你找出并返回数组中 <strong>任一</strong> 既不是 <strong>最小值</strong> 也不是 <strong>最大值</strong> 的数字，如果不存在这样的数字，返回 <strong><code>-1</code></strong> 。</p>\n\n<p>返回所选整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,2,1,4]\n<strong>输出：</strong>2\n<strong>解释：</strong>在这个示例中，最小值是 1 ，最大值是 4 。因此，2 或 3 都是有效答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2]\n<strong>输出：</strong>-1\n<strong>解释：</strong>由于不存在既不是最大值也不是最小值的数字，我们无法选出满足题目给定条件的数字。因此，不存在答案，返回 -1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,1,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>2 既不是最小值，也不是最大值，这个示例只有这一个有效答案。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>nums</code> 中的所有数字互不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2734.执行子串操作后的字典序最小字符串",
        "hardRate": "MEDIUM",
        "passRate": "32.97%",
        "problemsUrl": "https://leetcode.cn/problems/lexicographically-smallest-string-after-substring-operation/",
        "solutionsUrl": "https://leetcode.cn/problems/lexicographically-smallest-string-after-substring-operation/solution",
        "problemsDesc": "<p>给你一个仅由小写英文字母组成的字符串 <code>s</code> 。在一步操作中，你可以完成以下行为：</p>\n\n<ul>\n\t<li>选则 <code>s</code> 的任一非空子字符串，可能是整个字符串，接着将字符串中的每一个字符替换为英文字母表中的前一个字符。例如，'b' 用 'a' 替换，'a' 用 'z' 替换。</li>\n</ul>\n\n<p>返回执行上述操作 <strong>恰好一次</strong> 后可以获得的 <strong>字典序最小</strong> 的字符串。</p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>\n现有长度相同的两个字符串 <code>x</code> 和 字符串 <code>y</code> ，在满足&nbsp;<code>x[i] != y[i]</code> 的第一个位置 <code>i</code> 上，如果&nbsp; <code>x[i]</code> 在字母表中先于 <code>y[i]</code> 出现，则认为字符串 <code>x</code> 比字符串 <code>y</code> <strong>字典序更小</strong> 。\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"cbabc\"\n<strong>输出：</strong>\"baabc\"\n<strong>解释：</strong>我们选择从下标 0 开始、到下标 1 结束的子字符串执行操作。 \n可以证明最终得到的字符串是字典序最小的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"acbbc\"\n<strong>输出：</strong>\"abaab\"\n<strong>解释：</strong>我们选择从下标 1 开始、到下标 4 结束的子字符串执行操作。\n可以证明最终得到的字符串是字典序最小的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = \"leetcode\"\n<strong>输出：</strong>\"kddsbncd\"\n<strong>解释：</strong>我们选择整个字符串执行操作。\n可以证明最终得到的字符串是字典序最小的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2735.收集巧克力",
        "hardRate": "MEDIUM",
        "passRate": "43.27%",
        "problemsUrl": "https://leetcode.cn/problems/collecting-chocolates/",
        "solutionsUrl": "https://leetcode.cn/problems/collecting-chocolates/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 、下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，表示收集不同巧克力的成本。每个巧克力都对应一个不同的类型，最初，位于下标 <code>i</code> 的巧克力就对应第 <code>i</code> 个类型。</p>\n\n<p>在一步操作中，你可以用成本 <code>x</code> 执行下述行为：</p>\n\n<ul>\n\t<li>同时修改所有巧克力的类型，将巧克力的类型&nbsp;<code>i<sup>th</sup></code>&nbsp;修改为类型&nbsp;<code>((i + 1) mod n)<sup>th</sup></code>。</li>\n</ul>\n\n<p>假设你可以执行任意次操作，请返回收集所有类型巧克力所需的最小成本。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [20,1,15], x = 5\n<strong>输出：</strong>13\n<strong>解释：</strong>最开始，巧克力的类型分别是 [0,1,2] 。我们可以用成本 1 购买第 1 个类型的巧克力。\n接着，我们用成本 5 执行一次操作，巧克力的类型变更为 [1,2,0] 。我们可以用成本 1 购买第 2 个类型的巧克力。\n然后，我们用成本 5 执行一次操作，巧克力的类型变更为 [2,0,1] 。我们可以用成本 1 购买第 0 个类型的巧克力。\n因此，收集所有类型的巧克力需要的总成本是 (1 + 5 + 1 + 5 + 1) = 13 。可以证明这是一种最优方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3], x = 4\n<strong>输出：</strong>6\n<strong>解释：</strong>我们将会按最初的成本收集全部三个类型的巧克力，而不需执行任何操作。因此，收集所有类型的巧克力需要的总成本是 1 + 2 + 3 = 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= x &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2736.最大和查询",
        "hardRate": "HARD",
        "passRate": "38.80%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-queries/solution",
        "problemsDesc": "<p>给你两个长度为 <code>n</code> 、下标从 <strong>0</strong> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，另给你一个下标从 <strong>1</strong> 开始的二维数组 <code>queries</code> ，其中 <code>queries[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 。</p>\n\n<p>对于第 <code>i</code> 个查询，在所有满足 <code>nums1[j] &gt;= x<sub>i</sub></code> 且 <code>nums2[j] &gt;= y<sub>i</sub></code> 的下标 <code>j</code> <code>(0 &lt;= j &lt; n)</code> 中，找出 <code>nums1[j] + nums2[j]</code> 的 <strong>最大值</strong> ，如果不存在满足条件的 <code>j</code> 则返回 <strong>-1</strong> 。</p>\n\n<p>返回数组<em> </em><code>answer</code><em> ，</em>其中<em> </em><code>answer[i]</code><em> </em>是第 <code>i</code> 个查询的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [4,3,1,2], nums2 = [2,4,9,5], queries = [[4,1],[1,3],[2,5]]\n<strong>输出：</strong>[6,10,7]\n<strong>解释：</strong>\n对于第 1 个查询：<code>x<sub>i</sub> = 4</code>&nbsp;且&nbsp;<code>y<sub>i</sub> = 1</code> ，可以选择下标&nbsp;<code>j = 0</code>&nbsp;，此时 <code>nums1[j] &gt;= 4</code>&nbsp;且&nbsp;<code>nums2[j] &gt;= 1</code> 。<code>nums1[j] + nums2[j]</code>&nbsp;等于 6 ，可以证明 6 是可以获得的最大值。\n对于第 2 个查询：<code>x<sub>i</sub> = 1</code>&nbsp;且&nbsp;<code>y<sub>i</sub> = 3</code> ，可以选择下标&nbsp;<code>j = 2</code>&nbsp;，此时 <code>nums1[j] &gt;= 1</code>&nbsp;且&nbsp;<code>nums2[j] &gt;= 3</code> 。<code>nums1[j] + nums2[j]</code>&nbsp;等于 10 ，可以证明 10 是可以获得的最大值。\n对于第 3 个查询：<code>x<sub>i</sub> = 2</code>&nbsp;且&nbsp;<code>y<sub>i</sub> = 5</code> ，可以选择下标&nbsp;<code>j = 3</code>&nbsp;，此时 <code>nums1[j] &gt;= 2</code>&nbsp;且&nbsp;<code>nums2[j] &gt;= 5</code> 。<code>nums1[j] + nums2[j]</code>&nbsp;等于 7 ，可以证明 7 是可以获得的最大值。\n因此，我们返回&nbsp;<code>[6,10,7]</code> 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [3,2,5], nums2 = [2,3,4], queries = [[4,4],[3,2],[1,1]]\n<strong>输出：</strong>[9,9,9]\n<strong>解释：</strong>对于这个示例，我们可以选择下标&nbsp;<code>j = 2</code>&nbsp;，该下标可以满足每个查询的限制。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [2,1], nums2 = [2,3], queries = [[3,3]]\n<strong>输出：</strong>[-1]\n<strong>解释：</strong>示例中的查询 <code>x<sub>i</sub></code> = 3 且 <code>y<sub>i</sub></code> = 3 。对于每个下标 j ，都只满足 nums1[j] &lt; <code>x<sub>i</sub></code> 或者 nums2[j] &lt; <code>y<sub>i</sub></code> 。因此，不存在答案。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums1.length == nums2.length</code>&nbsp;</li>\n\t<li><code>n ==&nbsp;nums1.length&nbsp;</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup>&nbsp;</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length ==&nbsp;2</code></li>\n\t<li><code>x<sub>i</sub>&nbsp;== queries[i][1]</code></li>\n\t<li><code>y<sub>i</sub> == queries[i][2]</code></li>\n\t<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2737.找到最近的标记节点",
        "hardRate": "MEDIUM",
        "passRate": "49.14%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-closest-marked-node/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-closest-marked-node/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2738.统计文本中单词的出现次数",
        "hardRate": "MEDIUM",
        "passRate": "33.10%",
        "problemsUrl": "https://leetcode.cn/problems/count-occurrences-in-text/",
        "solutionsUrl": "https://leetcode.cn/problems/count-occurrences-in-text/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2739.总行驶距离",
        "hardRate": "EASY",
        "passRate": "52.82%",
        "problemsUrl": "https://leetcode.cn/problems/total-distance-traveled/",
        "solutionsUrl": "https://leetcode.cn/problems/total-distance-traveled/solution",
        "problemsDesc": "<p>卡车有两个油箱。给你两个整数，<code>mainTank</code> 表示主油箱中的燃料（以升为单位），<code>additionalTank</code> 表示副油箱中的燃料（以升为单位）。</p>\n\n<p>该卡车每耗费 <code>1</code> 升燃料都可以行驶 <code>10</code> km。每当主油箱使用了 <code>5</code> 升燃料时，如果副油箱至少有 <code>1</code> 升燃料，则会将 <code>1</code> 升燃料从副油箱转移到主油箱。</p>\n\n<p>返回卡车可以行驶的最大距离。</p>\n\n<p>注意：从副油箱向主油箱注入燃料不是连续行为。这一事件会在每消耗 <code>5</code> 升燃料时突然且立即发生。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>mainTank = 5, additionalTank = 10\n<strong>输出：</strong>60\n<strong>解释：</strong>\n在用掉 5 升燃料后，主油箱中燃料还剩下 (5 - 5 + 1) = 1 升，行驶距离为 50km 。\n在用掉剩下的 1 升燃料后，没有新的燃料注入到主油箱中，主油箱变为空。\n总行驶距离为 60km 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>mainTank = 1, additionalTank = 2\n<strong>输出：</strong>10\n<strong>解释：</strong>\n在用掉 1 升燃料后，主油箱变为空。\n总行驶距离为 10km 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= mainTank, additionalTank &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2740.找出分区值",
        "hardRate": "MEDIUM",
        "passRate": "74.38%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-value-of-the-partition/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-value-of-the-partition/solution",
        "problemsDesc": "<p>给你一个 <strong>正</strong> 整数数组 <code>nums</code> 。</p>\n\n<p>将 <code>nums</code> 分成两个数组：<code>nums1</code> 和 <code>nums2</code> ，并满足下述条件：</p>\n\n<ul>\n\t<li>数组 <code>nums</code> 中的每个元素都属于数组 <code>nums1</code> 或数组 <code>nums2</code> 。</li>\n\t<li>两个数组都 <strong>非空</strong> 。</li>\n\t<li>分区值 <strong>最小</strong> 。</li>\n</ul>\n\n<p>分区值的计算方法是 <code>|max(nums1) - min(nums2)|</code> 。</p>\n\n<p>其中，<code>max(nums1)</code> 表示数组 <code>nums1</code> 中的最大元素，<code>min(nums2)</code> 表示数组 <code>nums2</code> 中的最小元素。</p>\n\n<p>返回表示分区值的整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3,2,4]\n<strong>输出：</strong>1\n<strong>解释：</strong>可以将数组 nums 分成 nums1 = [1,2] 和 nums2 = [3,4] 。\n- 数组 nums1 的最大值等于 2 。\n- 数组 nums2 的最小值等于 3 。\n分区值等于 |2 - 3| = 1 。\n可以证明 1 是所有分区方案的最小值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [100,1,10]\n<strong>输出：</strong>9\n<strong>解释：</strong>可以将数组 nums 分成 nums1 = [10] 和 nums2 = [100,1] 。 \n- 数组 nums1 的最大值等于 10 。 \n- 数组 nums2 的最小值等于 1 。 \n分区值等于 |10 - 1| = 9 。 \n可以证明 9 是所有分区方案的最小值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2741.特别的排列",
        "hardRate": "MEDIUM",
        "passRate": "35.69%",
        "problemsUrl": "https://leetcode.cn/problems/special-permutations/",
        "solutionsUrl": "https://leetcode.cn/problems/special-permutations/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，它包含 <code>n</code>&nbsp;个 <strong>互不相同</strong>&nbsp;的正整数。如果&nbsp;<code>nums</code>&nbsp;的一个排列满足以下条件，我们称它是一个特别的排列：</p>\n\n<ul>\n\t<li>对于&nbsp;<code>0 &lt;= i &lt; n - 1</code>&nbsp;的下标 <code>i</code>&nbsp;，要么&nbsp;<code>nums[i] % nums[i+1] == 0</code>&nbsp;，要么&nbsp;<code>nums[i+1] % nums[i] == 0</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回特别排列的总数目，由于答案可能很大，请将它对<strong>&nbsp;</strong><code>10<sup>9&nbsp;</sup>+ 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,3,6]\n<b>输出：</b>2\n<b>解释：</b>[3,6,2] 和 [2,6,3] 是 nums 两个特别的排列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,4,3]\n<b>输出：</b>2\n<b>解释：</b>[3,1,4] 和 [4,1,3] 是 nums 两个特别的排列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 14</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2742.给墙壁刷油漆",
        "hardRate": "HARD",
        "passRate": "34.87%",
        "problemsUrl": "https://leetcode.cn/problems/painting-the-walls/",
        "solutionsUrl": "https://leetcode.cn/problems/painting-the-walls/solution",
        "problemsDesc": "<p>给你两个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>cost</code> 和&nbsp;<code>time</code>&nbsp;，分别表示给&nbsp;<code>n</code>&nbsp;堵不同的墙刷油漆需要的开销和时间。你有两名油漆匠：</p>\n\n<ul>\n\t<li>一位需要 <strong>付费</strong>&nbsp;的油漆匠，刷第&nbsp;<code>i</code>&nbsp;堵墙需要花费&nbsp;<code>time[i]</code>&nbsp;单位的时间，开销为&nbsp;<code>cost[i]</code>&nbsp;单位的钱。</li>\n\t<li>一位 <strong>免费</strong>&nbsp;的油漆匠，刷 <strong>任意</strong>&nbsp;一堵墙的时间为&nbsp;<code>1</code>&nbsp;单位，开销为&nbsp;<code>0</code>&nbsp;。但是必须在付费油漆匠&nbsp;<strong>工作</strong>&nbsp;时，免费油漆匠才会工作。</li>\n</ul>\n\n<p>请你返回刷完 <code>n</code>&nbsp;堵墙最少开销为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>cost = [1,2,3,2], time = [1,2,3,2]\n<b>输出：</b>3\n<strong>解释：</strong>下标为 0 和 1 的墙由付费油漆匠来刷，需要 3 单位时间。同时，免费油漆匠刷下标为 2 和 3 的墙，需要 2 单位时间，开销为 0 。总开销为 1 + 2 = 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>cost = [2,3,4,2], time = [1,1,1,1]\n<b>输出：</b>4\n<b>解释：</b>下标为 0 和 3 的墙由付费油漆匠来刷，需要 2 单位时间。同时，免费油漆匠刷下标为 1 和 2 的墙，需要 2 单位时间，开销为 0 。总开销为 2 + 2 = 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= cost.length &lt;= 500</code></li>\n\t<li><code>cost.length == time.length</code></li>\n\t<li><code>1 &lt;= cost[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= time[i] &lt;= 500</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2743.计算没有重复字符的子字符串数量",
        "hardRate": "MEDIUM",
        "passRate": "78.57%",
        "problemsUrl": "https://leetcode.cn/problems/count-substrings-without-repeating-character/",
        "solutionsUrl": "https://leetcode.cn/problems/count-substrings-without-repeating-character/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2744.最大字符串配对数目",
        "hardRate": "EASY",
        "passRate": "85.38%",
        "problemsUrl": "https://leetcode.cn/problems/find-maximum-number-of-string-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/find-maximum-number-of-string-pairs/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>words</code>&nbsp;，数组中包含 <strong>互不相同</strong>&nbsp;的字符串。</p>\n\n<p>如果字符串&nbsp;<code>words[i]</code>&nbsp;与字符串 <code>words[j]</code>&nbsp;满足以下条件，我们称它们可以匹配：</p>\n\n<ul>\n\t<li>字符串&nbsp;<code>words[i]</code>&nbsp;等于&nbsp;<code>words[j]</code>&nbsp;的反转字符串。</li>\n\t<li><code>0 &lt;= i &lt; j &lt; words.length</code></li>\n</ul>\n\n<p>请你返回数组 <code>words</code>&nbsp;中的&nbsp;<strong>最大</strong>&nbsp;匹配数目。</p>\n\n<p>注意，每个字符串最多匹配一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"cd\",\"ac\",\"dc\",\"ca\",\"zz\"]\n<b>输出：</b>2\n<strong>解释：</strong>在此示例中，我们可以通过以下方式匹配 2 对字符串：\n- 我们将第 0 个字符串与第 2 个字符串匹配，因为 word[0] 的反转字符串是 \"dc\" 并且等于 words[2]。\n- 我们将第 1 个字符串与第 3 个字符串匹配，因为 word[1] 的反转字符串是 \"ca\" 并且等于 words[3]。\n可以证明最多匹配数目是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"ab\",\"ba\",\"cc\"]\n<b>输出：</b>1\n<b>解释：</b>在此示例中，我们可以通过以下方式匹配 1 对字符串：\n- 我们将第 0 个字符串与第 1 个字符串匹配，因为 words[1] 的反转字符串 \"ab\" 与 words[0] 相等。\n可以证明最多匹配数目是 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"aa\",\"ab\"]\n<b>输出：</b>0\n<strong>解释：</strong>这个例子中，无法匹配任何字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 50</code></li>\n\t<li><code>words[i].length == 2</code></li>\n\t<li><code>words</code>&nbsp;包含的字符串互不相同。</li>\n\t<li><code>words[i]</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2745.构造最长的新字符串",
        "hardRate": "MEDIUM",
        "passRate": "56.50%",
        "problemsUrl": "https://leetcode.cn/problems/construct-the-longest-new-string/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-the-longest-new-string/solution",
        "problemsDesc": "<p>给你三个整数&nbsp;<code>x</code>&nbsp;，<code>y</code>&nbsp;和&nbsp;<code>z</code>&nbsp;。</p>\n\n<p>这三个整数表示你有&nbsp;<code>x</code>&nbsp;个&nbsp;<code>\"AA\"</code>&nbsp;字符串，<code>y</code>&nbsp;个&nbsp;<code>\"BB\"</code>&nbsp;字符串，和&nbsp;<code>z</code>&nbsp;个&nbsp;<code>\"AB\"</code>&nbsp;字符串。你需要选择这些字符串中的部分字符串（可以全部选择也可以一个都不选择），将它们按顺序连接得到一个新的字符串。新字符串不能包含子字符串&nbsp;<code>\"AAA\"</code>&nbsp;或者&nbsp;<code>\"BBB\"</code>&nbsp;。</p>\n\n<p>请你返回新字符串的最大可能长度。</p>\n\n<p><strong>子字符串</strong>&nbsp;是一个字符串中一段连续 <strong>非空</strong>&nbsp;的字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>x = 2, y = 5, z = 1\n<b>输出：</b>12\n<strong>解释： </strong>我们可以按顺序连接 \"BB\" ，\"AA\" ，\"BB\" ，\"AA\" ，\"BB\" 和 \"AB\" ，得到新字符串 \"BBAABBAABBAB\" 。\n字符串长度为 12 ，无法得到一个更长的符合题目要求的字符串。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>x = 3, y = 2, z = 2\n<b>输出：</b>14\n<b>解释：</b>我们可以按顺序连接 \"AB\" ，\"AB\" ，\"AA\" ，\"BB\" ，\"AA\" ，\"BB\" 和 \"AA\" ，得到新字符串 \"ABABAABBAABBAA\" 。\n字符串长度为 14 ，无法得到一个更长的符合题目要求的字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= x, y, z &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2746.字符串连接删减字母",
        "hardRate": "MEDIUM",
        "passRate": "39.03%",
        "problemsUrl": "https://leetcode.cn/problems/decremental-string-concatenation/",
        "solutionsUrl": "https://leetcode.cn/problems/decremental-string-concatenation/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>words</code>&nbsp;，它包含 <code>n</code>&nbsp;个字符串。</p>\n\n<p>定义 <strong>连接</strong>&nbsp;操作&nbsp;<code>join(x, y)</code>&nbsp;表示将字符串&nbsp;<code>x</code> 和&nbsp;<code>y</code>&nbsp;连在一起，得到&nbsp;<code>xy</code>&nbsp;。如果&nbsp;<code>x</code>&nbsp;的最后一个字符与&nbsp;<code>y</code>&nbsp;的第一个字符相等，连接后两个字符中的一个会被&nbsp;<strong>删除</strong>&nbsp;。</p>\n\n<p>比方说&nbsp;<code>join(\"ab\", \"ba\") = \"aba\"</code>&nbsp;，&nbsp;<code>join(\"ab\", \"cde\") = \"abcde\"</code>&nbsp;。</p>\n\n<p>你需要执行&nbsp;<code>n - 1</code>&nbsp;次&nbsp;<strong>连接</strong>&nbsp;操作。令&nbsp;<code>str<sub>0</sub> = words[0]</code>&nbsp;，从&nbsp;<code>i = 1</code> 直到&nbsp;<code>i = n - 1</code>&nbsp;，对于第&nbsp;<code>i</code>&nbsp;个操作，你可以执行以下操作之一：</p>\n\n<ul>\n\t<li>令&nbsp;<code>str<sub>i</sub> = join(str<sub>i - 1</sub>, words[i])</code></li>\n\t<li>令&nbsp;<code>str<sub>i</sub> = join(words[i], str<sub>i - 1</sub>)</code></li>\n</ul>\n\n<p>你的任务是使&nbsp;<code>str<sub>n - 1</sub></code>&nbsp;的长度<strong>&nbsp;最小&nbsp;</strong>。</p>\n\n<p>请你返回一个整数，表示&nbsp;<code>str<sub>n - 1</sub></code>&nbsp;的最小长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"aa\",\"ab\",\"bc\"]\n<b>输出：</b>4\n<strong>解释：</strong>这个例子中，我们按以下顺序执行连接操作，得到 <code>str<sub>2</sub></code> 的最小长度：\n<code>str<sub>0</sub> = \"aa\"</code>\n<code>str<sub>1</sub> = join(str<sub>0</sub>, \"ab\") = \"aab\"\n</code><code>str<sub>2</sub> = join(str<sub>1</sub>, \"bc\") = \"aabc\"</code> \n<code>str<sub>2</sub></code> 的最小长度为 4 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"ab\",\"b\"]\n<b>输出：</b>2\n<b>解释：</b>这个例子中，str<sub>0</sub> = \"ab\"，可以得到两个不同的 str<sub>1</sub>：\njoin(str<sub>0</sub>, \"b\") = \"ab\" 或者 join(\"b\", str<sub>0</sub>) = \"bab\" 。\n第一个字符串 \"ab\" 的长度最短，所以答案为 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"aaa\",\"c\",\"aba\"]\n<b>输出：</b>6\n<b>解释：</b>这个例子中，我们按以下顺序执行连接操作，得到 <code>str<sub>2</sub>&nbsp;的最小长度：</code>\n<code>str<sub>0</sub> = \"</code>aaa\"\n<code>str<sub>1</sub> = join(str<sub>0</sub>, \"c\") = \"aaac\"</code>\n<code>str<sub>2</sub> = join(\"aba\", str<sub>1</sub>) = \"abaaac\"</code>\n<code>str<sub>2</sub></code> 的最小长度为 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 50</code></li>\n\t<li><code>words[i]</code>&nbsp;中只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2747.统计没有收到请求的服务器数目",
        "hardRate": "MEDIUM",
        "passRate": "38.02%",
        "problemsUrl": "https://leetcode.cn/problems/count-zero-request-servers/",
        "solutionsUrl": "https://leetcode.cn/problems/count-zero-request-servers/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;，表示服务器的总数目，再给你一个下标从 <strong>0</strong>&nbsp;开始的 <strong>二维</strong>&nbsp;整数数组&nbsp;<code>logs</code>&nbsp;，其中&nbsp;<code>logs[i] = [server_id, time]</code>&nbsp;表示 id 为&nbsp;<code>server_id</code>&nbsp;的服务器在&nbsp;<code>time</code>&nbsp;时收到了一个请求。</p>\n\n<p>同时给你一个整数&nbsp;<code>x</code>&nbsp;和一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>queries</code>&nbsp; 。</p>\n\n<p>请你返回一个长度等于&nbsp;<code>queries.length</code>&nbsp;的数组&nbsp;<code>arr</code>&nbsp;，其中&nbsp;<code>arr[i]</code>&nbsp;表示在时间区间&nbsp;<code>[queries[i] - x, queries[i]]</code>&nbsp;内没有收到请求的服务器数目。</p>\n\n<p>注意时间区间是个闭区间。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, logs = [[1,3],[2,6],[1,5]], x = 5, queries = [10,11]\n<b>输出：</b>[1,2]\n<b>解释：</b>\n对于 queries[0]：id 为 1 和 2 的服务器在区间 [5, 10] 内收到了请求，所以只有服务器 3 没有收到请求。\n对于 queries[1]：id 为 2 的服务器在区间 [6,11] 内收到了请求，所以 id 为 1 和 3 的服务器在这个时间段内没有收到请求。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, logs = [[2,4],[2,1],[1,2],[3,1]], x = 2, queries = [3,4]\n<b>输出：</b>[0,1]\n<b>解释：</b>\n对于 queries[0]：区间 [1, 3] 内所有服务器都收到了请求。\n对于 queries[1]：只有 id 为 3 的服务器在区间 [2,4] 内没有收到请求。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= logs.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>logs[i].length == 2</code></li>\n\t<li><code>1 &lt;= logs[i][0] &lt;= n</code></li>\n\t<li><code>1 &lt;= logs[i][1] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= x &lt;= 10<sup>5</sup></code></li>\n\t<li><code>x &lt;&nbsp;queries[i]&nbsp;&lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2748.美丽下标对的数目",
        "hardRate": "EASY",
        "passRate": "56.65%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-beautiful-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-beautiful-pairs/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。如果下标对 <code>i</code>、<code>j</code> 满足 <code>0 ≤ i &lt; j &lt; nums.length</code> ，如果&nbsp;<code>nums[i]</code> 的 <strong>第一个数字</strong> 和 <code>nums[j]</code> 的 <strong>最后一个数字</strong> <strong>互质</strong> ，则认为 <code>nums[i]</code> 和 <code>nums[j]</code> 是一组 <strong>美丽下标对</strong> 。</p>\n\n<p>返回 <code>nums</code> 中 <strong>美丽下标对</strong> 的总数目。</p>\n\n<p>对于两个整数 <code>x</code> 和 <code>y</code> ，如果不存在大于 1 的整数可以整除它们，则认为 <code>x</code> 和 <code>y</code> <strong>互质</strong> 。换而言之，如果 <code>gcd(x, y) == 1</code> ，则认为 <code>x</code> 和 <code>y</code> 互质，其中 <code>gcd(x, y)</code> 是 <code>x</code> 和 <code>k</code> <strong>最大公因数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,5,1,4]\n<strong>输出：</strong>5\n<strong>解释：</strong>nums 中共有 5 组美丽下标对：\ni = 0 和 j = 1 ：nums[0] 的第一个数字是 2 ，nums[1] 的最后一个数字是 5 。2 和 5 互质，因此 gcd(2,5) == 1 。\ni = 0 和 j = 2 ：nums[0] 的第一个数字是 2 ，nums[1] 的最后一个数字是 1 。2 和 5 互质，因此 gcd(2,1) == 1 。\ni = 1 和 j = 2 ：nums[0] 的第一个数字是 5 ，nums[1] 的最后一个数字是 1 。2 和 5 互质，因此 gcd(5,1) == 1 。\ni = 1 和 j = 3 ：nums[0] 的第一个数字是 5 ，nums[1] 的最后一个数字是 4 。2 和 5 互质，因此 gcd(5,4) == 1 。\ni = 2 和 j = 3 ：nums[0] 的第一个数字是 1 ，nums[1] 的最后一个数字是 4 。2 和 5 互质，因此 gcd(1,4) == 1 。\n因此，返回 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [11,21,12]\n<strong>输出：</strong>2\n<strong>解释：</strong>共有 2 组美丽下标对：\ni = 0 和 j = 1 ：nums[0] 的第一个数字是 1 ，nums[1] 的最后一个数字是 1 。gcd(1,1) == 1 。\ni = 0 和 j = 2 ：nums[0] 的第一个数字是 1 ，nums[1] 的最后一个数字是 2 。gcd(1,2) == 1 。\n因此，返回 2 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 9999</code></li>\n\t<li><code>nums[i] % 10 != 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2749.得到整数零需要执行的最少操作数",
        "hardRate": "MEDIUM",
        "passRate": "31.71%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-integer-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-integer-zero/solution",
        "problemsDesc": "<p>给你两个整数：<code>num1</code> 和 <code>num2</code> 。</p>\n\n<p>在一步操作中，你需要从范围&nbsp;<code>[0, 60]</code> 中选出一个整数 <code>i</code> ，并从 <code>num1</code> 减去 <code>2<sup>i</sup> + num2</code> 。</p>\n\n<p>请你计算，要想使 <code>num1</code> 等于 <code>0</code> 需要执行的最少操作数，并以整数形式返回。</p>\n\n<p>如果无法使 <code>num1</code> 等于 <code>0</code> ，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = 3, num2 = -2\n<strong>输出：</strong>3\n<strong>解释：</strong>可以执行下述步骤使 3 等于 0 ：\n- 选择 i = 2 ，并从 3 减去 2<sup>2</sup> + (-2) ，num1 = 3 - (4 + (-2)) = 1 。\n- 选择 i = 2 ，并从 1 减去 2<sup>2</sup> + (-2) ，num1 = 1 - (4 + (-2)) = -1 。\n- 选择 i = 0 ，并从 -1 减去 2<sup>0</sup>&nbsp;+ (-2) ，num1 = (-1) - (1 + (-2)) = 0 。\n可以证明 3 是需要执行的最少操作数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = 5, num2 = 7\n<strong>输出：</strong>-1\n<strong>解释：</strong>可以证明，执行操作无法使 5 等于 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num1 &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= num2 &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2750.将数组划分成若干好子数组的方式",
        "hardRate": "MEDIUM",
        "passRate": "38.67%",
        "problemsUrl": "https://leetcode.cn/problems/ways-to-split-array-into-good-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/ways-to-split-array-into-good-subarrays/solution",
        "problemsDesc": "<p>给你一个二元数组 <code>nums</code> 。</p>\n\n<p>如果数组中的某个子数组 <strong>恰好</strong> 只存在 <strong>一</strong> 个值为 <code>1</code> 的元素，则认为该子数组是一个 <strong>好子数组</strong> 。</p>\n\n<p>请你统计将数组 <code>nums</code> 划分成若干 <strong>好子数组</strong> 的方法数，并以整数形式返回。由于数字可能很大，返回其对 <code>10<sup>9</sup> + 7</code> <strong>取余 </strong>之后的结果。</p>\n\n<p>子数组是数组中的一个连续 <strong>非空</strong> 元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,0,0,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>存在 3 种可以将 nums 划分成若干好子数组的方式：\n- [0,1] [0,0,1]\n- [0,1,0] [0,1]\n- [0,1,0,0] [1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,0]\n<strong>输出：</strong>1\n<strong>解释：</strong>存在 1 种可以将 nums 划分成若干好子数组的方式：\n- [0,1,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2751.机器人碰撞",
        "hardRate": "HARD",
        "passRate": "48.94%",
        "problemsUrl": "https://leetcode.cn/problems/robot-collisions/",
        "solutionsUrl": "https://leetcode.cn/problems/robot-collisions/solution",
        "problemsDesc": "<p>现有 <code>n</code> 个机器人，编号从 <strong>1</strong> 开始，每个机器人包含在路线上的位置、健康度和移动方向。</p>\n\n<p>给你下标从 <strong>0</strong> 开始的两个整数数组 <code>positions</code>、<code>healths</code> 和一个字符串 <code>directions</code>（<code>directions[i]</code> 为 <strong>'L'</strong> 表示 <strong>向左</strong> 或 <strong>'R'</strong> 表示 <strong>向右</strong>）。 <code>positions</code> 中的所有整数 <strong>互不相同</strong> 。</p>\n\n<p>所有机器人以 <strong>相同速度</strong> <strong>同时</strong> 沿给定方向在路线上移动。如果两个机器人移动到相同位置，则会发生 <strong>碰撞</strong> 。</p>\n\n<p>如果两个机器人发生碰撞，则将 <strong>健康度较低</strong> 的机器人从路线中 <strong>移除</strong> ，并且另一个机器人的健康度 <strong>减少 1</strong> 。幸存下来的机器人将会继续沿着与之前 <strong>相同</strong> 的方向前进。如果两个机器人的健康度相同，则将二者都从路线中移除。</p>\n\n<p>请你确定全部碰撞后幸存下的所有机器人的 <strong>健康度</strong> ，并按照原来机器人编号的顺序排列。即机器人 1 （如果幸存）的最终健康度，机器人 2 （如果幸存）的最终健康度等。 如果不存在幸存的机器人，则返回空数组。</p>\n\n<p>在不再发生任何碰撞后，请你以数组形式，返回所有剩余机器人的健康度（按机器人输入中的编号顺序）。</p>\n\n<p><strong>注意：</strong>位置&nbsp; <code>positions</code> 可能是乱序的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img height=\"169\" src=\"https://assets.leetcode.com/uploads/2023/05/15/image-20230516011718-12.png\" width=\"808\" /></p>\n\n<pre>\n<strong>输入：</strong>positions = [5,4,3,2,1], healths = [2,17,9,15,10], directions = \"RRRRR\"\n<strong>输出：</strong>[2,17,9,15,10]\n<strong>解释：</strong>在本例中不存在碰撞，因为所有机器人向同一方向移动。所以，从第一个机器人开始依序返回健康度，[2, 17, 9, 15, 10] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img height=\"176\" src=\"https://assets.leetcode.com/uploads/2023/05/15/image-20230516004433-7.png\" width=\"717\" /></p>\n\n<pre>\n<strong>输入：</strong>positions = [3,5,2,6], healths = [10,10,15,12], directions = \"RLRL\"\n<strong>输出：</strong>[14]\n<strong>解释：</strong>本例中发生 2 次碰撞。首先，机器人 1 和机器人 2 将会碰撞，因为二者健康度相同，二者都将被从路线中移除。接下来，机器人 3 和机器人 4 将会发生碰撞，由于机器人 4 的健康度更小，则它会被移除，而机器人 3 的健康度变为 15 - 1 = 14 。仅剩机器人 3 ，所以返回 [14] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img height=\"172\" src=\"https://assets.leetcode.com/uploads/2023/05/15/image-20230516005114-9.png\" width=\"732\" /></p>\n\n<pre>\n<strong>输入：</strong>positions = [1,2,5,6], healths = [10,10,11,11], directions = \"RLRL\"\n<strong>输出：</strong>[]\n<strong>解释：</strong>机器人 1 和机器人 2 将会碰撞，因为二者健康度相同，二者都将被从路线中移除。机器人 3 和机器人 4 将会碰撞，因为二者健康度相同，二者都将被从路线中移除。所以返回空数组 [] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= positions.length == healths.length == directions.length == n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= positions[i], healths[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>directions[i] == 'L'</code> 或 <code>directions[i] == 'R'</code></li>\n\t<li><code>positions</code> 中的所有值互不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2752.在连续天数上进行了最多交易次数的顾客",
        "hardRate": "HARD",
        "passRate": "44.00%",
        "problemsUrl": "https://leetcode.cn/problems/customers-with-maximum-number-of-transactions-on-consecutive-days/",
        "solutionsUrl": "https://leetcode.cn/problems/customers-with-maximum-number-of-transactions-on-consecutive-days/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2753.计算一个环形街道上的房屋数量 II",
        "hardRate": "HARD",
        "passRate": "83.33%",
        "problemsUrl": "https://leetcode.cn/problems/count-houses-in-a-circular-street-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/count-houses-in-a-circular-street-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2754.将函数绑定到上下文",
        "hardRate": "MEDIUM",
        "passRate": "86.67%",
        "problemsUrl": "https://leetcode.cn/problems/bind-function-to-context/",
        "solutionsUrl": "https://leetcode.cn/problems/bind-function-to-context/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2755.深度合并两个对象",
        "hardRate": "MEDIUM",
        "passRate": "65.85%",
        "problemsUrl": "https://leetcode.cn/problems/deep-merge-of-two-objects/",
        "solutionsUrl": "https://leetcode.cn/problems/deep-merge-of-two-objects/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2756.批处理查询",
        "hardRate": "HARD",
        "passRate": "37.50%",
        "problemsUrl": "https://leetcode.cn/problems/query-batching/",
        "solutionsUrl": "https://leetcode.cn/problems/query-batching/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2757.生成循环数组的值",
        "hardRate": "MEDIUM",
        "passRate": "73.91%",
        "problemsUrl": "https://leetcode.cn/problems/generate-circular-array-values/",
        "solutionsUrl": "https://leetcode.cn/problems/generate-circular-array-values/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2758.下一天",
        "hardRate": "EASY",
        "passRate": "85.37%",
        "problemsUrl": "https://leetcode.cn/problems/next-day/",
        "solutionsUrl": "https://leetcode.cn/problems/next-day/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2759.将 JSON 字符串转换为对象",
        "hardRate": "HARD",
        "passRate": "46.15%",
        "problemsUrl": "https://leetcode.cn/problems/convert-json-string-to-object/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-json-string-to-object/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2760.最长奇偶子数组",
        "hardRate": "EASY",
        "passRate": "37.21%",
        "problemsUrl": "https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>threshold</code> 。</p>\n\n<p>请你从 <code>nums</code> 的子数组中找出以下标 <code>l</code> 开头、下标 <code>r</code> 结尾 <code>(0 &lt;= l &lt;= r &lt; nums.length)</code> 且满足以下条件的 <strong>最长子数组</strong> ：</p>\n\n<ul>\n\t<li><code>nums[l] % 2 == 0</code></li>\n\t<li>对于范围&nbsp;<code>[l, r - 1]</code> 内的所有下标 <code>i</code> ，<code>nums[i] % 2 != nums[i + 1] % 2</code></li>\n\t<li>对于范围&nbsp;<code>[l, r]</code> 内的所有下标 <code>i</code> ，<code>nums[i] &lt;= threshold</code></li>\n</ul>\n\n<p>以整数形式返回满足题目要求的最长子数组的长度。</p>\n\n<p><strong>注意：子数组</strong> 是数组中的一个连续非空元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,2,5,4], threshold = 5\n<strong>输出：</strong>3\n<strong>解释：</strong>在这个示例中，我们选择从 l = 1 开始、到 r = 3 结束的子数组 =&gt; [2,5,4] ，满足上述条件。\n因此，答案就是这个子数组的长度 3 。可以证明 3 是满足题目要求的最大长度。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2], threshold = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>\n在这个示例中，我们选择从 l = 1 开始、到 r = 1 结束的子数组 =&gt; [2] 。\n该子数组满足上述全部条件。可以证明 1 是满足题目要求的最大长度。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,3,4,5], threshold = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>\n在这个示例中，我们选择从 l = 0 开始、到 r = 2 结束的子数组 =&gt; [2,3,4] 。 \n该子数组满足上述全部条件。\n因此，答案就是这个子数组的长度 3 。可以证明 3 是满足题目要求的最大长度。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100 </code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100 </code></li>\n\t<li><code>1 &lt;= threshold &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2761.和等于目标值的质数对",
        "hardRate": "MEDIUM",
        "passRate": "34.12%",
        "problemsUrl": "https://leetcode.cn/problems/prime-pairs-with-target-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/prime-pairs-with-target-sum/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> 。如果两个整数 <code>x</code> 和 <code>y</code> 满足下述条件，则认为二者形成一个质数对：</p>\n\n<ul>\n\t<li><code>1 &lt;= x &lt;= y &lt;= n</code></li>\n\t<li><code>x + y == n</code></li>\n\t<li><code>x</code> 和 <code>y</code> 都是质数</li>\n</ul>\n\n<p>请你以二维有序列表的形式返回符合题目要求的所有 <code>[x<sub>i</sub>, y<sub>i</sub>]</code> ，列表需要按 <code>x<sub>i</sub></code> 的 <strong>非递减顺序</strong> 排序。如果不存在符合要求的质数对，则返回一个空数组。</p>\n\n<p><strong>注意：</strong>质数是大于 <code>1</code> 的自然数，并且只有两个因子，即它本身和 <code>1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 10\n<strong>输出：</strong>[[3,7],[5,5]]\n<strong>解释：</strong>在这个例子中，存在满足条件的两个质数对。 \n这两个质数对分别是 [3,7] 和 [5,5]，按照题面描述中的方式排序后返回。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>[]\n<strong>解释：</strong>可以证明不存在和为 2 的质数对，所以返回一个空数组。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2762.不间断子数组",
        "hardRate": "MEDIUM",
        "passRate": "47.18%",
        "problemsUrl": "https://leetcode.cn/problems/continuous-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/continuous-subarrays/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。<code>nums</code>&nbsp;的一个子数组如果满足以下条件，那么它是 <strong>不间断</strong> 的：</p>\n\n<ul>\n\t<li><code>i</code>，<code>i + 1</code>&nbsp;，...，<code>j</code><sub> </sub>&nbsp;表示子数组中的下标。对于所有满足&nbsp;<code>i &lt;= i<sub>1</sub>, i<sub>2</sub> &lt;= j</code>&nbsp;的下标对，都有 <code>0 &lt;= |nums[i<sub>1</sub>] - nums[i<sub>2</sub>]| &lt;= 2</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回 <strong>不间断</strong> 子数组的总数目。</p>\n\n<p>子数组是一个数组中一段连续 <strong>非空</strong>&nbsp;的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5,4,2,4]\n<strong>输出：</strong>8\n<b>解释：</b>\n大小为 1 的不间断子数组：[5], [4], [2], [4] 。\n大小为 2 的不间断子数组：[5,4], [4,2], [2,4] 。\n大小为 3 的不间断子数组：[4,2,4] 。\n没有大小为 4 的不间断子数组。\n不间断子数组的总数目为 4 + 3 + 1 = 8 。\n除了这些以外，没有别的不间断子数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3]\n<b>输出：</b>6\n<b>解释：</b>\n大小为 1 的不间断子数组：[1], [2], [3] 。\n大小为 2 的不间断子数组：[1,2], [2,3] 。\n大小为 3 的不间断子数组：[1,2,3] 。\n不间断子数组的总数目为 3 + 2 + 1 = 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2763.所有子数组中不平衡数字之和",
        "hardRate": "HARD",
        "passRate": "62.12%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-imbalance-numbers-of-all-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-imbalance-numbers-of-all-subarrays/solution",
        "problemsDesc": "<p>一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的整数数组 <code>arr</code>&nbsp;的 <strong>不平衡数字</strong>&nbsp;定义为，在&nbsp;<code>sarr = sorted(arr)</code>&nbsp;数组中，满足以下条件的下标数目：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; n - 1</code>&nbsp;，和</li>\n\t<li><code>sarr[i+1] - sarr[i] &gt; 1</code></li>\n</ul>\n\n<p>这里，<code>sorted(arr)</code>&nbsp;表示将数组 <code>arr</code>&nbsp;排序后得到的数组。</p>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，请你返回它所有&nbsp;<strong>子数组</strong>&nbsp;的&nbsp;<strong>不平衡数字</strong>&nbsp;之和。</p>\n\n<p>子数组指的是一个数组中连续一段 <strong>非空</strong>&nbsp;的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,3,1,4]\n<b>输出：</b>3\n<b>解释：</b>总共有 3 个子数组有非 0 不平衡数字：\n- 子数组 [3, 1] ，不平衡数字为 1 。\n- 子数组 [3, 1, 4] ，不平衡数字为 1 。\n- 子数组 [1, 4] ，不平衡数字为 1 。\n其他所有子数组的不平衡数字都是 0 ，所以所有子数组的不平衡数字之和为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,3,3,3,5]\n<b>输出：</b>8\n<b>解释：</b>总共有 7 个子数组有非 0 不平衡数字：\n- 子数组 [1, 3] ，不平衡数字为 1 。\n- 子数组 [1, 3, 3] ，不平衡数字为 1 。\n- 子数组 [1, 3, 3, 3] ，不平衡数字为 1 。\n- 子数组 [1, 3, 3, 3, 5] ，不平衡数字为 2 。\n- 子数组 [3, 3, 3, 5] ，不平衡数字为 1 。\n- 子数组 [3, 3, 5] ，不平衡数字为 1 。\n- 子数组 [3, 5] ，不平衡数字为 1 。\n其他所有子数组的不平衡数字都是 0 ，所以所有子数组的不平衡数字之和为 8 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2764.",
        "hardRate": "MEDIUM",
        "passRate": "82.50%",
        "problemsUrl": "https://leetcode.cn/problems/is-array-a-preorder-of-some-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/is-array-a-preorder-of-some-binary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2765.最长交替子序列",
        "hardRate": "EASY",
        "passRate": "42.75%",
        "problemsUrl": "https://leetcode.cn/problems/longest-alternating-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-alternating-subarray/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。如果 <code>nums</code>&nbsp;中长度为&nbsp;<code>m</code>&nbsp;的子数组&nbsp;<code>s</code>&nbsp;满足以下条件，我们称它是一个交替子序列：</p>\n\n<ul>\n\t<li><code>m</code>&nbsp;大于&nbsp;<code>1</code>&nbsp;。</li>\n\t<li><code>s<sub>1</sub> = s<sub>0</sub> + 1</code>&nbsp;。</li>\n\t<li>下标从 0 开始的子数组&nbsp;<code>s</code>&nbsp;与数组&nbsp;<code>[s<sub>0</sub>, s<sub>1</sub>, s<sub>0</sub>, s<sub>1</sub>,...,s<sub>(m-1) % 2</sub>]</code>&nbsp;一样。也就是说，<code>s<sub>1</sub> - s<sub>0</sub> = 1</code>&nbsp;，<code>s<sub>2</sub> - s<sub>1</sub> = -1</code>&nbsp;，<code>s<sub>3</sub> - s<sub>2</sub> = 1</code>&nbsp;，<code>s<sub>4</sub> - s<sub>3</sub> = -1</code>&nbsp;，以此类推，直到&nbsp;<code>s[m - 1] - s[m - 2] = (-1)<sup>m</sup></code>&nbsp;。</li>\n</ul>\n\n<p>请你返回 <code>nums</code>&nbsp;中所有 <strong>交替</strong>&nbsp;子数组中，最长的长度，如果不存在交替子数组，请你返回 <code>-1</code>&nbsp;。</p>\n\n<p>子数组是一个数组中一段连续 <strong>非空</strong>&nbsp;的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,3,4,3,4]\n<b>输出：</b>4\n<b>解释：</b>交替子数组有 [3,4] ，[3,4,3] 和 [3,4,3,4] 。最长的子数组为 [3,4,3,4] ，长度为4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [4,5,6]\n<b>输出：</b>2\n<strong>解释：</strong>[4,5] 和 [5,6] 是仅有的两个交替子数组。它们长度都为 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2766.重新放置石块",
        "hardRate": "MEDIUM",
        "passRate": "54.32%",
        "problemsUrl": "https://leetcode.cn/problems/relocate-marbles/",
        "solutionsUrl": "https://leetcode.cn/problems/relocate-marbles/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，表示一些石块的初始位置。再给你两个长度<strong>&nbsp;相等</strong>&nbsp;下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>moveFrom</code> 和&nbsp;<code>moveTo</code>&nbsp;。</p>\n\n<p>在&nbsp;<code>moveFrom.length</code>&nbsp;次操作内，你可以改变石块的位置。在第&nbsp;<code>i</code>&nbsp;次操作中，你将位置在&nbsp;<code>moveFrom[i]</code>&nbsp;的所有石块移到位置&nbsp;<code>moveTo[i]</code>&nbsp;。</p>\n\n<p>完成这些操作后，请你按升序返回所有 <strong>有</strong>&nbsp;石块的位置。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>如果一个位置至少有一个石块，我们称这个位置 <strong>有</strong>&nbsp;石块。</li>\n\t<li>一个位置可能会有多个石块。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,6,7,8], moveFrom = [1,7,2], moveTo = [2,9,5]\n<b>输出：</b>[5,6,8,9]\n<b>解释：</b>一开始，石块在位置 1,6,7,8 。\n第 i = 0 步操作中，我们将位置 1 处的石块移到位置 2 处，位置 2,6,7,8 有石块。\n第 i = 1 步操作中，我们将位置 7 处的石块移到位置 9 处，位置 2,6,8,9 有石块。\n第 i = 2 步操作中，我们将位置 2 处的石块移到位置 5 处，位置 5,6,8,9 有石块。\n最后，至少有一个石块的位置为 [5,6,8,9] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,3,3], moveFrom = [1,3], moveTo = [2,2]\n<b>输出：</b>[2]\n<b>解释：</b>一开始，石块在位置 [1,1,3,3] 。\n第 i = 0 步操作中，我们将位置 1 处的石块移到位置 2 处，有石块的位置为 [2,2,3,3] 。\n第 i = 1 步操作中，我们将位置 3 处的石块移到位置 2 处，有石块的位置为 [2,2,2,2] 。\n由于 2 是唯一有石块的位置，我们返回 [2] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= moveFrom.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>moveFrom.length == moveTo.length</code></li>\n\t<li><code>1 &lt;= nums[i], moveFrom[i], moveTo[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>测试数据保证在进行第&nbsp;<code>i</code>&nbsp;步操作时，<code>moveFrom[i]</code>&nbsp;处至少有一个石块。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2767.将字符串分割为最少的美丽子字符串",
        "hardRate": "MEDIUM",
        "passRate": "53.92%",
        "problemsUrl": "https://leetcode.cn/problems/partition-string-into-minimum-beautiful-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-string-into-minimum-beautiful-substrings/solution",
        "problemsDesc": "<p>给你一个二进制字符串&nbsp;<code>s</code>&nbsp;，你需要将字符串分割成一个或者多个&nbsp;<strong>子字符串</strong>&nbsp;&nbsp;，使每个子字符串都是 <strong>美丽</strong>&nbsp;的。</p>\n\n<p>如果一个字符串满足以下条件，我们称它是 <strong>美丽</strong>&nbsp;的：</p>\n\n<ul>\n\t<li>它不包含前导 0 。</li>\n\t<li>它是 <code>5</code>&nbsp;的幂的 <strong>二进制</strong>&nbsp;表示。</li>\n</ul>\n\n<p>请你返回分割后的子字符串的 <strong>最少</strong>&nbsp;数目。如果无法将字符串&nbsp;<code>s</code>&nbsp;分割成美丽子字符串，请你返回 <code>-1</code>&nbsp;。</p>\n\n<p>子字符串是一个字符串中一段连续的字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"1011\"\n<b>输出：</b>2\n<b>解释：</b>我们可以将输入字符串分成 [\"101\", \"1\"] 。\n- 字符串 \"101\" 不包含前导 0 ，且它是整数 5<sup>1</sup> = 5 的二进制表示。\n- 字符串 \"1\" 不包含前导 0 ，且它是整数 5<sup>0</sup> = 1 的二进制表示。\n最少可以将 s 分成 2 个美丽子字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"111\"\n<b>输出：</b>3\n<b>解释：</b>我们可以将输入字符串分成 [\"1\", \"1\", \"1\"] 。\n- 字符串 \"1\" 不包含前导 0 ，且它是整数 5<sup>0</sup> = 1 的二进制表示。\n最少可以将 s 分成 3 个美丽子字符串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>s = \"0\"\n<b>输出：</b>-1\n<b>解释：</b>无法将给定字符串分成任何美丽子字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 15</code></li>\n\t<li><code>s[i]</code>&nbsp;要么是&nbsp;<code>'0'</code>&nbsp;要么是&nbsp;<code>'1'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2768.黑格子的数目",
        "hardRate": "MEDIUM",
        "passRate": "42.42%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-black-blocks/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-black-blocks/solution",
        "problemsDesc": "<p>给你两个整数&nbsp;<code>m</code> 和&nbsp;<code>n</code>&nbsp;，表示一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;的网格图。</p>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数矩阵&nbsp;<code>coordinates</code>&nbsp;，其中&nbsp;<code>coordinates[i] = [x, y]</code>&nbsp;表示坐标为&nbsp;<code>[x, y]</code>&nbsp;的格子是 <strong>黑色的</strong>&nbsp;，所有没出现在&nbsp;<code>coordinates</code>&nbsp;中的格子都是 <strong>白色的</strong>。</p>\n\n<p>一个块定义为网格图中&nbsp;<code>2 x 2</code>&nbsp;的一个子矩阵。更正式的，对于左上角格子为 <code>[x, y]</code> 的块，其中 <code>0 &lt;= x &lt; m - 1</code> 且&nbsp;<code>0 &lt;= y &lt; n - 1</code> ，包含坐标为&nbsp;<code>[x, y]</code>&nbsp;，<code>[x + 1, y]</code>&nbsp;，<code>[x, y + 1]</code>&nbsp;和&nbsp;<code>[x + 1, y + 1]</code>&nbsp;的格子。</p>\n\n<p>请你返回一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>5</code>&nbsp;的整数数组&nbsp;<code>arr</code>&nbsp;，<code>arr[i]</code>&nbsp;表示恰好包含&nbsp;<code>i</code>&nbsp;个&nbsp;<strong>黑色</strong>&nbsp;格子的块的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>m = 3, n = 3, coordinates = [[0,0]]\n<b>输出：</b>[3,1,0,0,0]\n<b>解释：</b>网格图如下：\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/06/18/screen-shot-2023-06-18-at-44656-am.png\" style=\"width: 150px; height: 128px;\" />\n只有 1 个块有一个黑色格子，这个块是左上角为 [0,0] 的块。\n其他 3 个左上角分别为 [0,1] ，[1,0] 和 [1,1] 的块都有 0 个黑格子。\n所以我们返回 [3,1,0,0,0] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>m = 3, n = 3, coordinates = [[0,0],[1,1],[0,2]]\n<b>输出：</b>[0,2,2,0,0]\n<b>解释：</b>网格图如下：\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/06/18/screen-shot-2023-06-18-at-45018-am.png\" style=\"width: 150px; height: 128px;\" />\n有 2 个块有 2 个黑色格子（左上角格子分别为 [0,0] 和 [0,1]）。\n左上角为 [1,0] 和 [1,1] 的两个块，都有 1 个黑格子。\n所以我们返回 [0,2,2,0,0] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= coordinates.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>coordinates[i].length == 2</code></li>\n\t<li><code>0 &lt;= coordinates[i][0] &lt; m</code></li>\n\t<li><code>0 &lt;= coordinates[i][1] &lt; n</code></li>\n\t<li><code>coordinates</code>&nbsp;中的坐标对两两互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2769.找出最大的可达成数字",
        "hardRate": "EASY",
        "passRate": "95.70%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-maximum-achievable-number/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-maximum-achievable-number/solution",
        "problemsDesc": "<p>给你两个整数 <code>num</code> 和 <code>t</code> 。</p>\n\n<p>如果整数 <code>x</code> 可以在执行下述操作不超过 <code>t</code> 次的情况下变为与 <code>num</code> 相等，则称其为 <strong>可达成数字</strong> ：</p>\n\n<ul>\n\t<li>每次操作将 <code>x</code> 的值增加或减少 <code>1</code> ，同时可以选择将 <code>num</code> 的值增加或减少 <code>1</code> 。</li>\n</ul>\n\n<p>返回所有可达成数字中的最大值。可以证明至少存在一个可达成数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 4, t = 1\n<strong>输出：</strong>6\n<strong>解释：</strong>最大可达成数字是 x = 6 ，执行下述操作可以使其等于 num ：\n- x 减少 1 ，同时 num 增加 1 。此时，x = 5 且 num = 5 。 \n可以证明不存在大于 6 的可达成数字。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 3, t = 2\n<strong>输出：</strong>7\n<strong>解释：</strong>最大的可达成数字是 x = 7 ，执行下述操作可以使其等于 num ：\n- x 减少 1 ，同时 num 增加 1 。此时，x = 6 且 num = 4 。 \n- x 减少 1 ，同时 num 增加 1 。此时，x = 5 且 num = 5 。 \n可以证明不存在大于 7 的可达成数字。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num, t&nbsp;&lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2770.达到末尾下标所需的最大跳跃次数",
        "hardRate": "MEDIUM",
        "passRate": "33.71%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-jumps-to-reach-the-last-index/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-jumps-to-reach-the-last-index/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、由 <code>n</code> 个整数组成的数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>\n\n<p>你的初始位置在下标 <code>0</code> 。在一步操作中，你可以从下标 <code>i</code> 跳跃到任意满足下述条件的下标 <code>j</code> ：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; n</code></li>\n\t<li><code>-target &lt;= nums[j] - nums[i] &lt;= target</code></li>\n</ul>\n\n<p>返回到达下标 <code>n - 1</code> 处所需的 <strong>最大跳跃次数</strong> 。</p>\n\n<p>如果无法到达下标 <code>n - 1</code> ，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3,6,4,1,2], target = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>要想以最大跳跃次数从下标 0 到下标 n - 1 ，可以按下述跳跃序列执行操作：\n- 从下标 0 跳跃到下标 1 。 \n- 从下标 1 跳跃到下标 3 。 \n- 从下标 3 跳跃到下标 5 。 \n可以证明，从 0 到 n - 1 的所有方案中，不存在比 3 步更长的跳跃序列。因此，答案是 3 。 </pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3,6,4,1,2], target = 3\n<strong>输出：</strong>5\n<strong>解释：</strong>要想以最大跳跃次数从下标 0 到下标 n - 1 ，可以按下述跳跃序列执行操作：\n- 从下标 0 跳跃到下标 1 。 \n- 从下标 1 跳跃到下标 2 。 \n- 从下标 2 跳跃到下标 3 。 \n- 从下标 3 跳跃到下标 4 。 \n- 从下标 4 跳跃到下标 5 。 \n可以证明，从 0 到 n - 1 的所有方案中，不存在比 5 步更长的跳跃序列。因此，答案是 5 。 </pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3,6,4,1,2], target = 0\n<strong>输出：</strong>-1\n<strong>解释：</strong>可以证明不存在从 0 到 n - 1 的跳跃序列。因此，答案是 -1 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length == n &lt;= 1000</code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= nums[i]&nbsp;&lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= target &lt;= 2 * 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2771.构造最长非递减子数组",
        "hardRate": "MEDIUM",
        "passRate": "31.78%",
        "problemsUrl": "https://leetcode.cn/problems/longest-non-decreasing-subarray-from-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-non-decreasing-subarray-from-two-arrays/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，长度均为 <code>n</code> 。</p>\n\n<p>让我们定义另一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组，<code>nums3</code> 。对于范围&nbsp;<code>[0, n - 1]</code> 的每个下标 <code>i</code> ，你可以将 <code>nums1[i]</code> 或 <code>nums2[i]</code> 的值赋给 <code>nums3[i]</code> 。</p>\n\n<p>你的任务是使用最优策略为 <code>nums3</code> 赋值，以最大化 <code>nums3</code> 中 <strong>最长非递减子数组</strong> 的长度。</p>\n\n<p>以整数形式表示并返回 <code>nums3</code> 中 <strong>最长非递减</strong> 子数组的长度。</p>\n\n<p><strong>注意：子数组</strong> 是数组中的一个连续非空元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [2,3,1], nums2 = [1,2,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>构造 nums3 的方法之一是： \nnums3 = [nums1[0], nums2[1], nums2[2]] =&gt; [2,2,1]\n从下标 0 开始到下标 1 结束，形成了一个长度为 2 的非递减子数组 [2,2] 。 \n可以证明 2 是可达到的最大长度。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [1,3,2,1], nums2 = [2,2,3,4]\n<strong>输出：</strong>4\n<strong>解释：</strong>构造 nums3 的方法之一是： \nnums3 = [nums1[0], nums2[1], nums2[2], nums2[3]] =&gt; [1,2,3,4]\n整个数组形成了一个长度为 4 的非递减子数组，并且是可达到的最大长度。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [1,1], nums2 = [2,2]\n<strong>输出：</strong>2\n<strong>解释：</strong>构造 nums3 的方法之一是： \nnums3 = [nums1[0], nums1[1]] =&gt; [1,1] \n整个数组形成了一个长度为 2 的非递减子数组，并且是可达到的最大长度。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length == nums2.length == n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2772.使数组中的所有元素都等于零",
        "hardRate": "MEDIUM",
        "passRate": "32.63%",
        "problemsUrl": "https://leetcode.cn/problems/apply-operations-to-make-all-array-elements-equal-to-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/apply-operations-to-make-all-array-elements-equal-to-zero/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个正整数 <code>k</code> 。</p>\n\n<p>你可以对数组执行下述操作 <strong>任意次</strong> ：</p>\n\n<ul>\n\t<li>从数组中选出长度为 <code>k</code> 的 <strong>任一</strong> 子数组，并将子数组中每个元素都 <strong>减去</strong> <code>1</code> 。</li>\n</ul>\n\n<p>如果你可以使数组中的所有元素都等于 <code>0</code> ，返回&nbsp; <code>true</code><em> </em>；否则，返回<em> </em><code>false</code><em> </em>。</p>\n\n<p><strong>子数组</strong> 是数组中的一个非空连续元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,2,3,1,1,0], k = 3\n<strong>输出：</strong>true\n<strong>解释：</strong>可以执行下述操作：\n- 选出子数组 [2,2,3] ，执行操作后，数组变为 nums = [<em><strong>1</strong></em>,<em><strong>1</strong></em>,<em><strong>2</strong></em>,1,1,0] 。\n- 选出子数组 [2,1,1] ，执行操作后，数组变为 nums = [1,1,<em><strong>1</strong></em>,<em><strong>0</strong></em>,<em><strong>0</strong></em>,0] 。\n- 选出子数组 [1,1,1] ，执行操作后，数组变为 nums = [<em><strong>0</strong></em>,<em><strong>0</strong></em>,<em><strong>0</strong></em>,0,0,0] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3,1,1], k = 2\n<strong>输出：</strong>false\n<strong>解释：</strong>无法使数组中的所有元素等于 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2773.猜数字",
        "hardRate": "EASY",
        "passRate": "84.65%",
        "problemsUrl": "https://leetcode.cn/problems/guess-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/guess-numbers/solution",
        "problemsDesc": "<p>小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？</p>\n\n<p>输入的<code>guess</code>数组为 小A 每次的猜测，<code>answer</code>数组为 小B 每次的选择。<code>guess</code>和<code>answer</code>的长度都等于3。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>guess = [1,2,3], answer = [1,2,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>小A 每次都猜对了。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>guess = [2,2,3], answer = [3,2,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>小A 只猜对了第二次。</pre>\n\n<p> </p>\n\n<p><strong>限制：</strong></p>\n\n<ol>\n\t<li><code>guess</code> 的长度 = 3</li>\n\t<li><code>answer</code> 的长度 = 3</li>\n\t<li><code>guess</code> 的元素取值为 <code>{1, 2, 3}</code> 之一。</li>\n\t<li><code>answer</code> 的元素取值为 <code>{1, 2, 3}</code> 之一。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2774.分式化简",
        "hardRate": "EASY",
        "passRate": "70.24%",
        "problemsUrl": "https://leetcode.cn/problems/deep-dark-fraction/",
        "solutionsUrl": "https://leetcode.cn/problems/deep-dark-fraction/solution",
        "problemsDesc": "<p>有一个同学在学习分式。他需要将一个连分数化成最简分数，你能帮助他吗？</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/09/fraction_example_1.jpg\" style=\"height: 195px; width: 480px;\" /></p>\n\n<p>连分数是形如上图的分式。在本题中，所有系数都是大于等于0的整数。</p>\n\n<p> </p>\n\n<p>输入的<code>cont</code>代表连分数的系数（<code>cont[0]</code>代表上图的<code>a<sub>0</sub></code>，以此类推）。返回一个长度为2的数组<code>[n, m]</code>，使得连分数的值等于<code>n / m</code>，且<code>n, m</code>最大公约数为1。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>cont = [3, 2, 0, 2]\n<strong>输出：</strong>[13, 4]\n<strong>解释：</strong>原连分数等价于3 + (1 / (2 + (1 / (0 + 1 / 2))))。注意[26, 8], [-13, -4]都不是正确答案。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>cont = [0, 0, 3]\n<strong>输出：</strong>[3, 1]\n<strong>解释：</strong>如果答案是整数，令分母为1即可。</pre>\n\n<p> </p>\n\n<p><strong>限制：</strong></p>\n\n<ol>\n\t<li><code>cont[i] >= 0</code></li>\n\t<li><code>1 <= cont的长度 <= 10</code></li>\n\t<li><code>cont</code>最后一个元素不等于0</li>\n\t<li>答案的<code>n, m</code>的取值都能被32位int整型存下（即不超过<code>2 ^ 31 - 1</code>）。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2775.机器人大冒险",
        "hardRate": "MEDIUM",
        "passRate": "23.23%",
        "problemsUrl": "https://leetcode.cn/problems/programmable-robot/",
        "solutionsUrl": "https://leetcode.cn/problems/programmable-robot/solution",
        "problemsDesc": "<p>力扣团队买了一个可编程机器人，机器人初始位置在原点<code>(0, 0)</code>。小伙伴事先给机器人输入一串指令<code>command</code>，机器人就会<strong>无限循环</strong>这条指令的步骤进行移动。指令有两种：</p>\n\n<ol>\n\t<li><code>U</code>: 向<code>y</code>轴正方向移动一格</li>\n\t<li><code>R</code>: 向<code>x</code>轴正方向移动一格。</li>\n</ol>\n\n<p>不幸的是，在 xy 平面上还有一些障碍物，他们的坐标用<code>obstacles</code>表示。机器人一旦碰到障碍物就会被<strong>损毁</strong>。</p>\n\n<p>给定终点坐标<code>(x, y)</code>，返回机器人能否<strong>完好</strong>地到达终点。如果能，返回<code>true</code>；否则返回<code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>command = &quot;URR&quot;, obstacles = [], x = 3, y = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>U(0, 1) -&gt; R(1, 1) -&gt; R(2, 1) -&gt; U(2, 2) -&gt; R(3, 2)。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>command = &quot;URR&quot;, obstacles = [[2, 2]], x = 3, y = 2\n<strong>输出：</strong>false\n<strong>解释：</strong>机器人在到达终点前会碰到(2, 2)的障碍物。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>command = &quot;URR&quot;, obstacles = [[4, 2]], x = 3, y = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>到达终点后，再碰到障碍物也不影响返回结果。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<ol>\n\t<li><code>2 &lt;= command的长度 &lt;= 1000</code></li>\n\t<li><code>command</code>由<code>U，R</code>构成，且至少有一个<code>U</code>，至少有一个<code>R</code></li>\n\t<li><code>0 &lt;= x &lt;= 1e9, 0 &lt;= y &lt;= 1e9</code></li>\n\t<li><code>0 &lt;= obstacles的长度 &lt;= 1000</code></li>\n\t<li><code>obstacles[i]</code>不为原点或者终点</li>\n</ol>\n",
        "isPlus": false
    }
]