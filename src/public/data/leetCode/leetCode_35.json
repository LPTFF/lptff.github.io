[
    {
        "problemsName": " 2551.将珠子放入背包中",
        "hardRate": "HARD",
        "passRate": "56.68%",
        "problemsUrl": "https://leetcode.cn/problems/put-marbles-in-bags/",
        "solutionsUrl": "https://leetcode.cn/problems/put-marbles-in-bags/solution",
        "problemsDesc": "<p>你有&nbsp;<code>k</code>&nbsp;个背包。给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>weights</code>&nbsp;，其中&nbsp;<code>weights[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个珠子的重量。同时给你整数 <code>k</code>&nbsp;。</p>\n\n<p>请你按照如下规则将所有的珠子放进&nbsp;<code>k</code>&nbsp;个背包。</p>\n\n<ul>\n\t<li>没有背包是空的。</li>\n\t<li>如果第&nbsp;<code>i</code>&nbsp;个珠子和第&nbsp;<code>j</code>&nbsp;个珠子在同一个背包里，那么下标在&nbsp;<code>i</code>&nbsp;到&nbsp;<code>j</code>&nbsp;之间的所有珠子都必须在这同一个背包中。</li>\n\t<li>如果一个背包有下标从&nbsp;<code>i</code>&nbsp;到&nbsp;<code>j</code>&nbsp;的所有珠子，那么这个背包的价格是&nbsp;<code>weights[i] + weights[j]</code>&nbsp;。</li>\n</ul>\n\n<p>一个珠子分配方案的 <strong>分数</strong>&nbsp;是所有 <code>k</code>&nbsp;个背包的价格之和。</p>\n\n<p>请你返回所有分配方案中，<strong>最大分数</strong>&nbsp;与 <strong>最小分数</strong>&nbsp;的 <strong>差值</strong>&nbsp;为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>weights = [1,3,5,1], k = 2\n<b>输出：</b>4\n<b>解释：</b>\n分配方案 [1],[3,5,1] 得到最小得分 (1+1) + (3+1) = 6 。\n分配方案 [1,3],[5,1] 得到最大得分 (1+3) + (5+1) = 10 。\n所以差值为 10 - 6 = 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>weights = [1, 3], k = 2\n<b>输出：</b>0\n<b>解释：</b>唯一的分配方案为 [1],[3] 。\n最大最小得分相等，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= weights.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= weights[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2552.统计上升四元组",
        "hardRate": "HARD",
        "passRate": "42.27%",
        "problemsUrl": "https://leetcode.cn/problems/count-increasing-quadruplets/",
        "solutionsUrl": "https://leetcode.cn/problems/count-increasing-quadruplets/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，它包含&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;的所有数字，请你返回上升四元组的数目。</p>\n\n<p>如果一个四元组&nbsp;<code>(i, j, k, l)</code>&nbsp;满足以下条件，我们称它是上升的：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; k &lt; l &lt; n</code>&nbsp;且</li>\n\t<li><code>nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l]</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,3,2,4,5]\n<b>输出：</b>2\n<b>解释：</b>\n- 当 i = 0 ，j = 1 ，k = 2 且 l = 3 时，有 nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l] 。\n- 当 i = 0 ，j = 1 ，k = 2 且 l = 4 时，有 nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l] 。\n没有其他的四元组，所以我们返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4]\n<b>输出：</b>0\n<b>解释：</b>只存在一个四元组 i = 0 ，j = 1 ，k = 2 ，l = 3 ，但是 nums[j] &lt; nums[k] ，所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>4 &lt;= nums.length &lt;= 4000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>\n\t<li><code>nums</code>&nbsp;中所有数字 <strong>互不相同</strong>&nbsp;，<code>nums</code>&nbsp;是一个排列。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2553.分割数组中数字的数位",
        "hardRate": "EASY",
        "passRate": "82.64%",
        "problemsUrl": "https://leetcode.cn/problems/separate-the-digits-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/separate-the-digits-in-an-array/solution",
        "problemsDesc": "<p>给你一个正整数数组&nbsp;<code>nums</code>&nbsp;，请你返回一个数组<em>&nbsp;</em><code>answer</code> ，你需要将&nbsp;<code>nums</code>&nbsp;中每个整数进行数位分割后，按照&nbsp;<code>nums</code>&nbsp;中出现的&nbsp;<strong>相同顺序</strong>&nbsp;放入答案数组中。</p>\n\n<p>对一个整数进行数位分割，指的是将整数各个数位按原本出现的顺序排列成数组。</p>\n\n<ul>\n\t<li>比方说，整数&nbsp;<code>10921</code>&nbsp;，分割它的各个数位得到&nbsp;<code>[1,0,9,2,1]</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [13,25,83,77]\n<b>输出：</b>[1,3,2,5,8,3,7,7]\n<b>解释：</b>\n- 分割 13 得到 [1,3] 。\n- 分割 25 得到 [2,5] 。\n- 分割 83 得到 [8,3] 。\n- 分割 77 得到 [7,7] 。\nanswer = [1,3,2,5,8,3,7,7] 。answer 中的数字分割结果按照原数字在数组中的相同顺序排列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [7,1,3,9]\n<b>输出：</b>[7,1,3,9]\n<b>解释：</b>nums 中每个整数的分割是它自己。\nanswer = [7,1,3,9] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2554.从一个范围内选择最多整数 I",
        "hardRate": "MEDIUM",
        "passRate": "58.26%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-integers-to-choose-from-a-range-i/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-integers-to-choose-from-a-range-i/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>banned</code>&nbsp;和两个整数&nbsp;<code>n</code> 和&nbsp;<code>maxSum</code>&nbsp;。你需要按照以下规则选择一些整数：</p>\n\n<ul>\n\t<li>被选择整数的范围是&nbsp;<code>[1, n]</code>&nbsp;。</li>\n\t<li>每个整数 <strong>至多</strong>&nbsp;选择 <strong>一次</strong>&nbsp;。</li>\n\t<li>被选择整数不能在数组&nbsp;<code>banned</code>&nbsp;中。</li>\n\t<li>被选择整数的和不超过&nbsp;<code>maxSum</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回按照上述规则 <strong>最多</strong>&nbsp;可以选择的整数数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>banned = [1,6,5], n = 5, maxSum = 6\n<b>输出：</b>2\n<b>解释：</b>你可以选择整数 2 和 4 。\n2 和 4 在范围 [1, 5] 内，且它们都不在 banned 中，它们的和是 6 ，没有超过 maxSum 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>banned = [1,2,3,4,5,6,7], n = 8, maxSum = 1\n<b>输出：</b>0\n<b>解释：</b>按照上述规则无法选择任何整数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>banned = [11], n = 7, maxSum = 50\n<b>输出：</b>7\n<b>解释：</b>你可以选择整数 1, 2, 3, 4, 5, 6 和 7 。\n它们都在范围 [1, 7] 中，且都没出现在 banned 中，它们的和是 28 ，没有超过 maxSum 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= banned.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= banned[i], n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= maxSum &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2555.两个线段获得的最多奖品",
        "hardRate": "MEDIUM",
        "passRate": "39.83%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-win-from-two-segments/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-win-from-two-segments/solution",
        "problemsDesc": "<p>在 <strong>X轴</strong>&nbsp;上有一些奖品。给你一个整数数组&nbsp;<code>prizePositions</code>&nbsp;，它按照 <strong>非递减</strong>&nbsp;顺序排列，其中&nbsp;<code>prizePositions[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;件奖品的位置。数轴上一个位置可能会有多件奖品。再给你一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>你可以选择两个端点为整数的线段。每个线段的长度都必须是 <code>k</code>&nbsp;。你可以获得位置在任一线段上的所有奖品（包括线段的两个端点）。注意，两个线段可能会有相交。</p>\n\n<ul>\n\t<li>比方说&nbsp;<code>k = 2</code>&nbsp;，你可以选择线段&nbsp;<code>[1, 3]</code> 和&nbsp;<code>[2, 4]</code>&nbsp;，你可以获得满足&nbsp;<code>1 &lt;= prizePositions[i] &lt;= 3</code> 或者&nbsp;<code>2 &lt;= prizePositions[i] &lt;= 4</code>&nbsp;的所有奖品 i 。</li>\n</ul>\n\n<p>请你返回在选择两个最优线段的前提下，可以获得的 <strong>最多</strong>&nbsp;奖品数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>prizePositions = [1,1,2,2,3,3,5], k = 2\n<b>输出：</b>7\n<b>解释：</b>这个例子中，你可以选择线段 [1, 3] 和 [3, 5] ，获得 7 个奖品。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>prizePositions = [1,2,3,4], k = 0\n<b>输出：</b>2\n<b>解释：</b>这个例子中，一个选择是选择线段 <code>[3, 3]</code> 和 <code>[4, 4] ，获得 2 个奖品。</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prizePositions.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= prizePositions[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>9</sup> </code></li>\n\t<li><code>prizePositions</code>&nbsp;有序非递减。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2556.二进制矩阵中翻转最多一次使路径不连通",
        "hardRate": "MEDIUM",
        "passRate": "30.30%",
        "problemsUrl": "https://leetcode.cn/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/",
        "solutionsUrl": "https://leetcode.cn/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;<strong>二进制</strong> 矩阵&nbsp;<code>grid</code>&nbsp;。你可以从一个格子&nbsp;<code>(row, col)</code>&nbsp;移动到格子&nbsp;<code>(row + 1, col)</code>&nbsp;或者&nbsp;<code>(row, col + 1)</code>&nbsp;，前提是前往的格子值为 <code>1</code>&nbsp;。如果从&nbsp;<code>(0, 0)</code>&nbsp;到&nbsp;<code>(m - 1, n - 1)</code>&nbsp;没有任何路径，我们称该矩阵是&nbsp;<strong>不连通</strong>&nbsp;的。</p>\n\n<p>你可以翻转 <strong>最多一个</strong>&nbsp;格子的值（也可以不翻转）。你 <strong>不能翻转</strong>&nbsp;格子&nbsp;<code>(0, 0)</code> 和&nbsp;<code>(m - 1, n - 1)</code>&nbsp;。</p>\n\n<p>如果可以使矩阵不连通，请你返回&nbsp;<code>true</code>&nbsp;，否则返回<em>&nbsp;</em><code>false</code><em>&nbsp;</em>。</p>\n\n<p><strong>注意</strong>&nbsp;，翻转一个格子的值，可以使它的值从&nbsp;<code>0</code>&nbsp;变&nbsp;<code>1</code>&nbsp;，或从&nbsp;<code>1</code>&nbsp;变&nbsp;<code>0</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/07/yetgrid2drawio.png\" style=\"width: 441px; height: 151px;\" /></p>\n\n<pre>\n<b>输入：</b>grid = [[1,1,1],[1,0,0],[1,1,1]]\n<strong>输出：</strong>true\n<b>解释：</b>按照上图所示我们翻转蓝色格子里的值，翻转后从 (0, 0) 到 (2, 2) 没有路径。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/07/yetgrid3drawio.png\" /></p>\n\n<pre>\n<b>输入：</b>grid = [[1,1,1],[1,0,1],[1,1,1]]\n<b>输出：</b>false\n<b>解释：</b>无法翻转至多一个格子，使 (0, 0) 到 (2, 2) 没有路径。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>grid[0][0] == grid[m - 1][n - 1] == 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2557.从一个范围内选择最多整数 II",
        "hardRate": "MEDIUM",
        "passRate": "43.36%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-integers-to-choose-from-a-range-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-integers-to-choose-from-a-range-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2558.从数量最多的堆取走礼物",
        "hardRate": "EASY",
        "passRate": "68.09%",
        "problemsUrl": "https://leetcode.cn/problems/take-gifts-from-the-richest-pile/",
        "solutionsUrl": "https://leetcode.cn/problems/take-gifts-from-the-richest-pile/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>gifts</code> ，表示各堆礼物的数量。每一秒，你需要执行以下操作：</p>\n\n<ul>\n\t<li>选择礼物数量最多的那一堆。</li>\n\t<li>如果不止一堆都符合礼物数量最多，从中选择任一堆即可。</li>\n\t<li>选中的那一堆留下平方根数量的礼物（向下取整），取走其他的礼物。</li>\n</ul>\n\n<p>返回在 <code>k</code> 秒后剩下的礼物数量<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>gifts = [25,64,9,4,100], k = 4\n<strong>输出：</strong>29\n<strong>解释：</strong> \n按下述方式取走礼物：\n- 在第一秒，选中最后一堆，剩下 10 个礼物。\n- 接着第二秒选中第二堆礼物，剩下 8 个礼物。\n- 然后选中第一堆礼物，剩下 5 个礼物。\n- 最后，再次选中最后一堆礼物，剩下 3 个礼物。\n最后剩下的礼物数量分别是 [5,8,9,4,3] ，所以，剩下礼物的总数量是 29 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>gifts = [1,1,1,1], k = 4\n<strong>输出：</strong>4\n<strong>解释：</strong>\n在本例中，不管选中哪一堆礼物，都必须剩下 1 个礼物。 \n也就是说，你无法获取任一堆中的礼物。 \n所以，剩下礼物的总数量是 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= gifts.length &lt;= 10<sup>3</sup></code></li>\n\t<li><code>1 &lt;= gifts[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>3</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2559.统计范围内的元音字符串数",
        "hardRate": "MEDIUM",
        "passRate": "64.30%",
        "problemsUrl": "https://leetcode.cn/problems/count-vowel-strings-in-ranges/",
        "solutionsUrl": "https://leetcode.cn/problems/count-vowel-strings-in-ranges/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串数组 <code>words</code> 以及一个二维整数数组 <code>queries</code> 。</p>\n\n<p>每个查询 <code>queries[i] = [l<sub>i</sub>, r<sub>i</sub>]</code> 会要求我们统计在 <code>words</code> 中下标在 <code>l<sub>i</sub></code> 到 <code>r<sub>i</sub></code> 范围内（<strong>包含</strong> 这两个值）并且以元音开头和结尾的字符串的数目。</p>\n\n<p>返回一个整数数组，其中数组的第 <code>i</code> 个元素对应第 <code>i</code> 个查询的答案。</p>\n\n<p><strong>注意：</strong>元音字母是 <code>'a'</code>、<code>'e'</code>、<code>'i'</code>、<code>'o'</code> 和 <code>'u'</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"aba\",\"bcb\",\"ece\",\"aa\",\"e\"], queries = [[0,2],[1,4],[1,1]]\n<strong>输出：</strong>[2,3,0]\n<strong>解释：</strong>以元音开头和结尾的字符串是 \"aba\"、\"ece\"、\"aa\" 和 \"e\" 。\n查询 [0,2] 结果为 2（字符串 \"aba\" 和 \"ece\"）。\n查询 [1,4] 结果为 3（字符串 \"ece\"、\"aa\"、\"e\"）。\n查询 [1,1] 结果为 0 。\n返回结果 [2,3,0] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"a\",\"e\",\"i\"], queries = [[0,2],[0,1],[2,2]]\n<strong>输出：</strong>[3,2,1]\n<strong>解释：</strong>每个字符串都满足这一条件，所以返回 [3,2,1] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 40</code></li>\n\t<li><code>words[i]</code> 仅由小写英文字母组成</li>\n\t<li><code>sum(words[i].length) &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= queries[j][0] &lt;= queries[j][1] &lt;&nbsp;words.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2560.打家劫舍 IV",
        "hardRate": "MEDIUM",
        "passRate": "49.89%",
        "problemsUrl": "https://leetcode.cn/problems/house-robber-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/house-robber-iv/solution",
        "problemsDesc": "<p>沿街有一排连续的房屋。每间房屋内都藏有一定的现金。现在有一位小偷计划从这些房屋中窃取现金。</p>\n\n<p>由于相邻的房屋装有相互连通的防盗系统，所以小偷 <strong>不会窃取相邻的房屋</strong> 。</p>\n\n<p>小偷的 <strong>窃取能力</strong> 定义为他在窃取过程中能从单间房屋中窃取的 <strong>最大金额</strong> 。</p>\n\n<p>给你一个整数数组 <code>nums</code> 表示每间房屋存放的现金金额。形式上，从左起第 <code>i</code> 间房屋中放有 <code>nums[i]</code> 美元。</p>\n\n<p>另给你一个整数&nbsp;<code>k</code> ，表示窃贼将会窃取的 <strong>最少</strong> 房屋数。小偷总能窃取至少 <code>k</code> 间房屋。</p>\n\n<p>返回小偷的 <strong>最小</strong> 窃取能力。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,5,9], k = 2\n<strong>输出：</strong>5\n<strong>解释：</strong>\n小偷窃取至少 2 间房屋，共有 3 种方式：\n- 窃取下标 0 和 2 处的房屋，窃取能力为 max(nums[0], nums[2]) = 5 。\n- 窃取下标 0 和 3 处的房屋，窃取能力为 max(nums[0], nums[3]) = 9 。\n- 窃取下标 1 和 3 处的房屋，窃取能力为 max(nums[1], nums[3]) = 9 。\n因此，返回 min(5, 9, 9) = 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,7,9,3,1], k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>共有 7 种窃取方式。窃取能力最小的情况所对应的方式是窃取下标 0 和 4 处的房屋。返回 max(nums[0], nums[4]) = 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= (nums.length + 1)/2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2561.重排水果",
        "hardRate": "HARD",
        "passRate": "36.54%",
        "problemsUrl": "https://leetcode.cn/problems/rearranging-fruits/",
        "solutionsUrl": "https://leetcode.cn/problems/rearranging-fruits/solution",
        "problemsDesc": "<p>你有两个果篮，每个果篮中有 <code>n</code> 个水果。给你两个下标从 <strong>0</strong> 开始的整数数组 <code>basket1</code> 和 <code>basket2</code> ，用以表示两个果篮中每个水果的成本。</p>\n\n<p>你希望两个果篮相等。为此，可以根据需要多次执行下述操作：</p>\n\n<ul>\n\t<li>选中两个下标 <code>i</code> 和 <code>j</code> ，并交换 <code>basket1</code> 中的第 <code>i</code> 个水果和 <code>basket2</code> 中的第 <code>j</code> 个水果。</li>\n\t<li>交换的成本是 <code>min(basket1<sub>i</sub>,basket2<sub>j</sub>)</code> 。</li>\n</ul>\n\n<p>根据果篮中水果的成本进行排序，如果排序后结果完全相同，则认为两个果篮相等。</p>\n\n<p>返回使两个果篮相等的最小交换成本，如果无法使两个果篮相等，则返回<em> </em><code>-1</code><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>basket1 = [4,2,2,2], basket2 = [1,4,1,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>交换 basket1 中下标为 1 的水果和 basket2 中下标为 0 的水果，交换的成本为 1 。此时，basket1 = [4,1,2,2] 且 basket2 = [2,4,1,2] 。重排两个数组，发现二者相等。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>basket1 = [2,3,4,1], basket2 = [3,2,5,1]\n<strong>输出：</strong>-1\n<strong>解释：</strong>可以证明无法使两个果篮相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>basket1.length == bakste2.length</code></li>\n\t<li><code>1 &lt;= basket1.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= basket1<sub>i</sub>,basket2<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2562.找出数组的串联值",
        "hardRate": "EASY",
        "passRate": "73.17%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-array-concatenation-value/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-array-concatenation-value/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组&nbsp;<code>nums</code> 。</p>\n\n<p>现定义两个数字的 <strong>串联</strong>&nbsp;是由这两个数值串联起来形成的新数字。</p>\n\n<ul>\n\t<li>例如，<code>15</code><span style=\"\">&nbsp;和&nbsp;</span><code>49</code>&nbsp;的串联是&nbsp;<code>1549</code> 。</li>\n</ul>\n\n<p><code>nums</code>&nbsp;的 <strong>串联值</strong>&nbsp;最初等于 <code>0</code> 。执行下述操作直到&nbsp;<code>nums</code>&nbsp;变为空：</p>\n\n<ul>\n\t<li>如果&nbsp;<code>nums</code>&nbsp;中存在不止一个数字，分别选中 <code>nums</code> 中的第一个元素和最后一个元素，将二者串联得到的值加到&nbsp;<code>nums</code>&nbsp;的 <strong>串联值</strong> 上，然后从&nbsp;<code>nums</code>&nbsp;中删除第一个和最后一个元素。</li>\n\t<li>如果仅存在一个元素，则将该元素的值加到&nbsp;<code>nums</code> 的串联值上，然后删除这个元素。</li>\n</ul>\n\n<p>返回执行完所有操作后<em>&nbsp;</em><code>nums</code> 的串联值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [7,52,2,4]\n<b>输出：</b>596\n<b>解释：</b>在执行任一步操作前，nums 为 [7,52,2,4] ，串联值为 0 。\n - 在第一步操作中：\n我们选中第一个元素 7 和最后一个元素 4 。\n二者的串联是 74 ，将其加到串联值上，所以串联值等于 74 。\n接着我们从 nums 中移除这两个元素，所以 nums 变为 [52,2] 。\n - 在第二步操作中： \n我们选中第一个元素 52 和最后一个元素 2 。 \n二者的串联是 522 ，将其加到串联值上，所以串联值等于 596 。\n接着我们从 nums 中移除这两个元素，所以 nums 变为空。\n由于串联值等于 596 ，所以答案就是 596 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5,14,13,8,12]\n<b>输出：</b>673\n<b>解释：</b>在执行任一步操作前，nums 为 [5,14,13,8,12] ，串联值为 0 。 \n- 在第一步操作中： \n我们选中第一个元素 5 和最后一个元素 12 。 \n二者的串联是 512 ，将其加到串联值上，所以串联值等于 512 。 \n接着我们从 nums 中移除这两个元素，所以 nums 变为 [14,13,8] 。\n- 在第二步操作中：\n我们选中第一个元素 14 和最后一个元素 8 。\n二者的串联是 148 ，将其加到串联值上，所以串联值等于 660 。\n接着我们从 nums 中移除这两个元素，所以 nums 变为 [13] 。 \n- 在第三步操作中：\nnums 只有一个元素，所以我们选中 13 并将其加到串联值上，所以串联值等于 673 。\n接着我们从 nums 中移除这个元素，所以 nums 变为空。 \n由于串联值等于 673 ，所以答案就是 673 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2563.统计公平数对的数目",
        "hardRate": "MEDIUM",
        "passRate": "33.73%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-fair-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-fair-pairs/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组&nbsp;<code>nums</code>&nbsp;，和两个整数&nbsp;<code>lower</code> 和&nbsp;<code>upper</code> ，返回 <strong>公平数对的数目</strong> 。</p>\n\n<p>如果&nbsp;<code>(i, j)</code>&nbsp;数对满足以下情况，则认为它是一个 <strong>公平数对</strong>&nbsp;：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; n</code>，且</li>\n\t<li><code>lower &lt;= nums[i] + nums[j] &lt;= upper</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre>\n<b>输入：</b>nums = [0,1,7,4,4,5], lower = 3, upper = 6\n<b>输出：</b>6\n<b>解释：</b>共计 6 个公平数对：(0,3)、(0,4)、(0,5)、(1,3)、(1,4) 和 (1,5) 。\n</pre>\n\n<p><b>示例 2：</b></p>\n\n<pre>\n<b>输入：</b>nums = [1,7,9,2,5], lower = 11, upper = 11\n<b>输出：</b>1\n<b>解释：</b>只有单个公平数对：(2,3) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums.length == n</code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= lower &lt;= upper &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2564.子字符串异或查询",
        "hardRate": "MEDIUM",
        "passRate": "36.39%",
        "problemsUrl": "https://leetcode.cn/problems/substring-xor-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/substring-xor-queries/solution",
        "problemsDesc": "<p>给你一个 <strong>二进制字符串</strong>&nbsp;<code>s</code>&nbsp;和一个整数数组&nbsp;<code>queries</code>&nbsp;，其中&nbsp;<code>queries[i] = [first<sub>i</sub>, second<sub>i</sub>]</code>&nbsp;。</p>\n\n<p>对于第&nbsp;<code>i</code>&nbsp;个查询，找到 <code>s</code>&nbsp;的 <strong>最短子字符串</strong>&nbsp;，它对应的 <strong>十进制</strong>值&nbsp;<code>val</code>&nbsp;与&nbsp;<code>first<sub>i</sub></code>&nbsp;<b>按位异或</b>&nbsp;得到&nbsp;<code>second<sub>i</sub></code>&nbsp;，换言之，<code>val ^ first<sub>i</sub> == second<sub>i</sub></code>&nbsp;。</p>\n\n<p>第&nbsp;<code>i</code>&nbsp;个查询的答案是子字符串&nbsp;<code>[left<sub>i</sub>, right<sub>i</sub>]</code> 的两个端点（下标从&nbsp;<strong>0</strong>&nbsp;开始），如果不存在这样的子字符串，则答案为&nbsp;<code>[-1, -1]</code>&nbsp;。如果有多个答案，请你选择&nbsp;<code>left<sub>i</sub></code>&nbsp;最小的一个。</p>\n\n<p>请你返回一个数组&nbsp;<code>ans</code>&nbsp;，其中&nbsp;<code>ans[i] = [left<sub>i</sub>, right<sub>i</sub>]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个查询的答案。</p>\n\n<p><strong>子字符串</strong>&nbsp;是一个字符串中一段连续非空的字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"101101\", queries = [[0,5],[1,2]]\n<b>输出：</b>[[0,2],[2,3]]\n<b>解释：</b>第一个查询，端点为 <code>[0,2]</code> 的子字符串为 <strong>\"101\"</strong> ，对应十进制数字 <strong><code>5 ，且</code></strong> <strong><code>5 ^ 0 = 5</code></strong>&nbsp;，所以第一个查询的答案为 <code>[0,2]。第二个查询中，</code>端点为 <code>[2,3] 的子字符串为 </code><strong>\"11\" ，对应十进制数字</strong> <strong>3</strong>&nbsp;，且 <strong>3<code> ^ 1 = 2</code></strong><code>&nbsp;。所以第二个查询的答案为</code> <code>[2,3]</code> 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"0101\", queries = [[12,8]]\n<b>输出：</b>[[-1,-1]]\n<b>解释：</b>这个例子中，没有符合查询的答案，所以返回 <code>[-1,-1] 。</code>\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"1\", queries = [[4,5]]\n<b>输出：</b>[[0,0]]\n<b>解释：</b>这个例子中，端点为 <code>[0,0]</code> 的子字符串对应的十进制值为 <strong><code>1</code></strong><code>&nbsp;，且</code> <strong><code>1 ^ 4 = 5</code></strong><code>&nbsp;。所以答案为</code> <code>[0,0] 。</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s[i]</code>&nbsp;要么是&nbsp;<code>'0'</code>&nbsp;，要么是&nbsp;<code>'1'</code>&nbsp;。</li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= first<sub>i</sub>, second<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2565.最少得分子序列",
        "hardRate": "HARD",
        "passRate": "35.87%",
        "problemsUrl": "https://leetcode.cn/problems/subsequence-with-the-minimum-score/",
        "solutionsUrl": "https://leetcode.cn/problems/subsequence-with-the-minimum-score/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>s</code> 和&nbsp;<code>t</code>&nbsp;。</p>\n\n<p>你可以从字符串 <code>t</code>&nbsp;中删除任意数目的字符。</p>\n\n<p>如果没有从字符串&nbsp;<code>t</code>&nbsp;中删除字符，那么得分为&nbsp;<code>0</code>&nbsp;，否则：</p>\n\n<ul>\n\t<li>令&nbsp;<code>left</code>&nbsp;为删除字符中的最小下标。</li>\n\t<li>令&nbsp;<code>right</code>&nbsp;为删除字符中的最大下标。</li>\n</ul>\n\n<p>字符串的得分为&nbsp;<code>right - left + 1</code>&nbsp;。</p>\n\n<p>请你返回使<em>&nbsp;</em><code>t</code><em> </em>成为<em>&nbsp;</em><code>s</code>&nbsp;子序列的最小得分。</p>\n\n<p>一个字符串的 <strong>子序列</strong>&nbsp;是从原字符串中删除一些字符后（也可以一个也不删除），剩余字符不改变顺序得到的字符串。（比方说&nbsp;<code>\"ace\"</code> 是&nbsp;<code>\"<strong><em>a</em></strong>b<strong><em>c</em></strong>d<strong><em>e</em></strong>\"</code>&nbsp;的子序列，但是&nbsp;<code>\"aec\"</code>&nbsp;不是）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"abacaba\", t = \"bzaa\"\n<b>输出：</b>1\n<b>解释：</b>这个例子中，我们删除下标 1 处的字符 \"z\" （下标从 0 开始）。\n字符串 t 变为 \"baa\" ，它是字符串 \"abacaba\" 的子序列，得分为 1 - 1 + 1 = 1 。\n1 是能得到的最小得分。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"cde\", t = \"xyz\"\n<b>输出：</b>3\n<b>解释：</b>这个例子中，我们将下标为 0， 1 和 2 处的字符 \"x\" ，\"y\" 和 \"z\" 删除（下标从 0 开始）。\n字符串变成 \"\" ，它是字符串 \"cde\" 的子序列，得分为 2 - 0 + 1 = 3 。\n3 是能得到的最小得分。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 和&nbsp;<code>t</code>&nbsp;都只包含小写英文字母。</li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2566.替换一个数字后的最大差值",
        "hardRate": "EASY",
        "passRate": "63.66%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-difference-by-remapping-a-digit/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-difference-by-remapping-a-digit/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>num</code>&nbsp;。你知道 Danny Mittal 会偷偷将 <code>0</code>&nbsp;到 <code>9</code>&nbsp;中的一个数字 <strong>替换</strong> 成另一个数字。</p>\n\n<p>请你返回将 <code>num</code>&nbsp;中&nbsp;<strong>恰好一个</strong>&nbsp;数字进行替换后，得到的最大值和最小值的差为多少。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>当 Danny 将一个数字 <code>d1</code> 替换成另一个数字 <code>d2</code> 时，Danny 需要将&nbsp;<code>nums</code>&nbsp;中所有 <code>d1</code>&nbsp;都替换成&nbsp;<code>d2</code>&nbsp;。</li>\n\t<li>Danny 可以将一个数字替换成它自己，也就是说&nbsp;<code>num</code>&nbsp;可以不变。</li>\n\t<li>Danny 可以将数字分别替换成两个不同的数字分别得到最大值和最小值。</li>\n\t<li>替换后得到的数字可以包含前导 0 。</li>\n\t<li>Danny Mittal 获得周赛 326 前 10 名，让我们恭喜他。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>num = 11891\n<b>输出：</b>99009\n<b>解释：</b>\n为了得到最大值，我们将数字 1 替换成数字 9 ，得到 99899 。\n为了得到最小值，我们将数字 1 替换成数字 0 ，得到 890 。\n两个数字的差值为 99009 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>num = 90\n<b>输出：</b>99\n<strong>解释：</strong>\n可以得到的最大值是 99（将 0 替换成 9），最小值是 0（将 9 替换成 0）。\n所以我们得到 99 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2567.修改两个元素的最小分数",
        "hardRate": "MEDIUM",
        "passRate": "51.85%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-score-by-changing-two-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-score-by-changing-two-elements/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<ul>\n\t<li><code>nums</code> 的 <strong>最小</strong>&nbsp;得分是满足 <code>0 &lt;= i &lt; j &lt; nums.length</code>&nbsp;的&nbsp;<code>|nums[i]&nbsp;- nums[j]|</code>&nbsp;的最小值。</li>\n\t<li><code>nums</code>的 <strong>最大 </strong>得分是满足 <code>0 &lt;= i &lt; j &lt; nums.length</code>&nbsp;的&nbsp;<code>|nums[i]&nbsp;- nums[j]|</code>&nbsp;的最大值。</li>\n\t<li><code>nums</code>&nbsp;的分数是 <strong>最大</strong>&nbsp;得分与 <strong>最小</strong>&nbsp;得分的和。</li>\n</ul>\n\n<p>我们的目标是最小化&nbsp;<code>nums</code>&nbsp;的分数。你 <strong>最多</strong> 可以修改&nbsp;<code>nums</code>&nbsp;中&nbsp;<strong>2</strong>&nbsp;个元素的值。</p>\n\n<p>请你返回修改&nbsp;<code>nums</code>&nbsp;中&nbsp;<strong>至多两个</strong>&nbsp;元素的值后，可以得到的 <strong>最小分数</strong>&nbsp;。</p>\n\n<p><code>|x|</code>&nbsp;表示 <code>x</code>&nbsp;的绝对值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,4,3]\n<b>输出：</b>0\n<b>解释：</b>将 nums[1] 和 nums[2] 的值改为 1 ，nums 变为 [1,1,1] 。<code>|nums[i] - nums[j]|</code> 的值永远为 0 ，所以我们返回 0 + 0 = 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,4,7,8,5]\n<b>输出：</b>3\n<b>解释：\n</b>将 nums[0] 和 nums[1] 的值变为 6 ，nums 变为 [6,6,7,8,5] 。\n最小得分是 i = 0 且 j = 1 时得到的 |<code>nums[i] - nums[j]</code>| = |6 - 6| = 0 。\n最大得分是 i = 3 且 j = 4 时得到的 |<code>nums[i] - nums[j]</code>| = |8 - 5| = 3 。\n最大得分与最小得分之和为 3 。这是最优答案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2568.最小无法得到的或值",
        "hardRate": "MEDIUM",
        "passRate": "60.04%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-impossible-or/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-impossible-or/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>如果存在一些整数满足&nbsp;<code>0 &lt;= index<sub>1</sub> &lt; index<sub>2</sub> &lt; ... &lt; index<sub>k</sub> &lt; nums.length</code>&nbsp;，得到&nbsp;<code>nums[index<sub>1</sub>] | nums[index<sub>2</sub>] | ... | nums[index<sub>k</sub>] = x</code>&nbsp;，那么我们说&nbsp;<code>x</code>&nbsp;是&nbsp;<strong>可表达的</strong>&nbsp;。换言之，如果一个整数能由&nbsp;<code>nums</code>&nbsp;的某个子序列的或运算得到，那么它就是可表达的。</p>\n\n<p>请你返回 <code>nums</code>&nbsp;不可表达的 <strong>最小非零整数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,1]\n<b>输出：</b>4\n<b>解释：</b>1 和 2 已经在数组中，因为 nums[0] | nums[1] = 2 | 1 = 3 ，所以 3 是可表达的。由于 4 是不可表达的，所以我们返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [5,3,2]\n<b>输出：</b>1\n<b>解释：</b>1 是最小不可表达的数字。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2569.更新数组后处理求和查询",
        "hardRate": "HARD",
        "passRate": "39.82%",
        "problemsUrl": "https://leetcode.cn/problems/handling-sum-queries-after-update/",
        "solutionsUrl": "https://leetcode.cn/problems/handling-sum-queries-after-update/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;，和一个二维数组&nbsp;<code>queries</code>&nbsp;表示一些操作。总共有 3 种类型的操作：</p>\n\n<ol>\n\t<li>操作类型 1 为&nbsp;<code>queries[i]&nbsp;= [1, l, r]</code>&nbsp;。你需要将 <code>nums1</code>&nbsp;从下标&nbsp;<code>l</code>&nbsp;到下标 <code>r</code>&nbsp;的所有 <code>0</code>&nbsp;反转成 <code>1</code>&nbsp;或将 <code>1</code>&nbsp;反转成 <code>0</code>&nbsp;。<code>l</code>&nbsp;和 <code>r</code>&nbsp;下标都从 <strong>0</strong>&nbsp;开始。</li>\n\t<li>操作类型 2 为&nbsp;<code>queries[i]&nbsp;= [2, p, 0]</code>&nbsp;。对于&nbsp;<code>0 &lt;= i &lt; n</code>&nbsp;中的所有下标，令&nbsp;<code>nums2[i] =&nbsp;nums2[i]&nbsp;+ nums1[i]&nbsp;* p</code>&nbsp;。</li>\n\t<li>操作类型 3 为&nbsp;<code>queries[i]&nbsp;= [3, 0, 0]</code>&nbsp;。求&nbsp;<code>nums2</code>&nbsp;中所有元素的和。</li>\n</ol>\n\n<p>请你返回一个数组，包含所有第三种操作类型的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums1 = [1,0,1], nums2 = [0,0,0], queries = [[1,1,1],[2,1,0],[3,0,0]]\n<b>输出：</b>[3]\n<strong>解释：</strong>第一个操作后 nums1 变为 [1,1,1] 。第二个操作后，nums2 变成 [1,1,1] ，所以第三个操作的答案为 3 。所以返回 [3] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums1 = [1], nums2 = [5], queries = [[2,0,0],[3,0,0]]\n<b>输出：</b>[5]\n<b>解释：</b>第一个操作后，nums2 保持不变为 [5] ，所以第二个操作的答案是 5 。所以返回 [5] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length,nums2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums1.length = nums2.length</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length = 3</code></li>\n\t<li><code>0 &lt;= l &lt;= r &lt;= nums1.length - 1</code></li>\n\t<li><code>0 &lt;= p &lt;= 10<sup>6</sup></code></li>\n\t<li><code>0 &lt;= nums1[i] &lt;= 1</code></li>\n\t<li><code>0 &lt;= nums2[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2570.合并两个二维数组 - 求和法",
        "hardRate": "EASY",
        "passRate": "69.61%",
        "problemsUrl": "https://leetcode.cn/problems/merge-two-2d-arrays-by-summing-values/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-two-2d-arrays-by-summing-values/solution",
        "problemsDesc": "<p>给你两个 <strong>二维</strong> 整数数组 <code>nums1</code> 和 <code>nums2.</code></p>\n\n<ul>\n\t<li><code>nums1[i] = [id<sub>i</sub>, val<sub>i</sub>]</code> 表示编号为 <code>id<sub>i</sub></code> 的数字对应的值等于 <code>val<sub>i</sub></code> 。</li>\n\t<li><code>nums2[i] = [id<sub>i</sub>, val<sub>i</sub>]</code>&nbsp;表示编号为 <code>id<sub>i</sub></code> 的数字对应的值等于 <code>val<sub>i</sub></code> 。</li>\n</ul>\n\n<p>每个数组都包含 <strong>互不相同</strong> 的 id ，并按 id 以 <strong>递增</strong> 顺序排列。</p>\n\n<p>请你将两个数组合并为一个按 id 以递增顺序排列的数组，并符合下述条件：</p>\n\n<ul>\n\t<li>只有在两个数组中至少出现过一次的 id 才能包含在结果数组内。</li>\n\t<li>每个 id 在结果数组中 <strong>只能出现一次</strong> ，并且其对应的值等于两个数组中该 id 所对应的值求和。如果某个数组中不存在该 id ，则认为其对应的值等于 <code>0</code> 。</li>\n</ul>\n\n<p>返回结果数组。返回的数组需要按 id 以递增顺序排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]]\n<strong>输出：</strong>[[1,6],[2,3],[3,2],[4,6]]\n<strong>解释：</strong>结果数组中包含以下元素：\n- id = 1 ，对应的值等于 2 + 4 = 6 。\n- id = 2 ，对应的值等于 3 。\n- id = 3 ，对应的值等于 2 。\n- id = 4 ，对应的值等于5 + 1 = 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]]\n<strong>输出：</strong>[[1,3],[2,4],[3,6],[4,3],[5,5]]\n<strong>解释：</strong>不存在共同 id ，在结果数组中只需要包含每个 id 和其对应的值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 200</code></li>\n\t<li><code>nums1[i].length == nums2[j].length == 2</code></li>\n\t<li><code>1 &lt;= id<sub>i</sub>, val<sub>i</sub> &lt;= 1000</code></li>\n\t<li>数组中的 id 互不相同</li>\n\t<li>数据均按 id 以严格递增顺序排列</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2571.将整数减少到零需要的最少操作数",
        "hardRate": "MEDIUM",
        "passRate": "54.03%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-reduce-an-integer-to-0/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-reduce-an-integer-to-0/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> ，你可以执行下述操作 <strong>任意</strong> 次：</p>\n\n<ul>\n\t<li><code>n</code> 加上或减去 <code>2</code> 的某个 <strong>幂</strong></li>\n</ul>\n\n<p>返回使 <code>n</code> 等于 <code>0</code> 需要执行的 <strong>最少</strong> 操作数。</p>\n\n<p>如果 <code>x == 2<sup>i</sup></code> 且其中 <code>i &gt;= 0</code> ，则数字 <code>x</code> 是 <code>2</code> 的幂。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 39\n<strong>输出：</strong>3\n<strong>解释：</strong>我们可以执行下述操作：\n- n 加上 2<sup>0</sup> = 1 ，得到 n = 40 。\n- n 减去 2<sup>3</sup> = 8 ，得到 n = 32 。\n- n 减去 2<sup>5</sup> = 32 ，得到 n = 0 。\n可以证明使 n 等于 0 需要执行的最少操作数是 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 54\n<strong>输出：</strong>3\n<strong>解释：</strong>我们可以执行下述操作：\n- n 加上 2<sup>1</sup> = 2 ，得到 n = 56 。\n- n 加上 2<sup>3</sup> = 8 ，得到 n = 64 。\n- n 减去 2<sup>6</sup> = 64 ，得到 n = 0 。\n使 n 等于 0 需要执行的最少操作数是 3 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2572.无平方子集计数",
        "hardRate": "MEDIUM",
        "passRate": "29.85%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-square-free-subsets/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-square-free-subsets/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>nums</code> 。</p>\n\n<p>如果数组 <code>nums</code> 的子集中的元素乘积是一个 <strong>无平方因子数</strong> ，则认为该子集是一个 <strong>无平方</strong> 子集。</p>\n\n<p><strong>无平方因子数</strong> 是无法被除 <code>1</code> 之外任何平方数整除的数字。</p>\n\n<p>返回数组 <code>nums</code> 中 <strong>无平方</strong> 且 <strong>非空</strong> 的子集数目。因为答案可能很大，返回对 <code>10<sup>9</sup> + 7</code> 取余的结果。</p>\n\n<p><code>nums</code> 的 <strong>非空子集</strong> 是可以由删除 <code>nums</code> 中一些元素（可以不删除，但不能全部删除）得到的一个数组。如果构成两个子集时选择删除的下标不同，则认为这两个子集不同。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,4,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>示例中有 3 个无平方子集：\n- 由第 0 个元素 [3] 组成的子集。其元素的乘积是 3 ，这是一个无平方因子数。\n- 由第 3 个元素 [5] 组成的子集。其元素的乘积是 5 ，这是一个无平方因子数。\n- 由第 0 个和第 3 个元素 [3,5] 组成的子集。其元素的乘积是 15 ，这是一个无平方因子数。\n可以证明给定数组中不存在超过 3 个无平方子集。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1]\n<strong>输出：</strong>1\n<strong>解释：</strong>示例中有 1 个无平方子集：\n- 由第 0 个元素 [1] 组成的子集。其元素的乘积是 1 ，这是一个无平方因子数。\n可以证明给定数组中不存在超过 1 个无平方子集。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length&nbsp;&lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 30</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2573.找出对应 LCP 矩阵的字符串",
        "hardRate": "HARD",
        "passRate": "35.43%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-string-with-lcp/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-string-with-lcp/solution",
        "problemsDesc": "<p>对任一由 <code>n</code> 个小写英文字母组成的字符串 <code>word</code> ，我们可以定义一个 <code>n x n</code> 的矩阵，并满足：</p>\n\n<ul>\n\t<li><code>lcp[i][j]</code> 等于子字符串&nbsp;<code>word[i,...,n-1]</code> 和 <code>word[j,...,n-1]</code> 之间的最长公共前缀的长度。</li>\n</ul>\n\n<p>给你一个 <code>n x n</code> 的矩阵 <code>lcp</code> 。返回与 <code>lcp</code> 对应的、按字典序最小的字符串&nbsp;<code>word</code> 。如果不存在这样的字符串，则返回空字符串。</p>\n\n<p>对于长度相同的两个字符串 <code>a</code> 和 <code>b</code> ，如果在 <code>a</code> 和 <code>b</code> 不同的第一个位置，字符串 <code>a</code> 的字母在字母表中出现的顺序先于 <code>b</code> 中的对应字母，则认为字符串 <code>a</code> 按字典序比字符串 <code>b</code> 小。例如，<code>\"aabd\"</code> 在字典上小于 <code>\"aaca\"</code> ，因为二者不同的第一位置是第三个字母，而&nbsp;<code>'b'</code> 先于 <code>'c'</code> 出现。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\n<strong>输出：</strong>\"abab\"\n<strong>解释：</strong>lcp 对应由两个交替字母组成的任意 4 字母字符串，字典序最小的是 \"abab\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\n<strong>输出：</strong>\"aaaa\"\n<strong>解释：</strong>lcp 对应只有一个不同字母的任意 4 字母字符串，字典序最小的是 \"aaaa\" 。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>lcp[3][3] 无法等于 3 ，因为 word[3,...,3] 仅由单个字母组成；因此，不存在答案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n ==&nbsp;</code><code>lcp.length == </code><code>lcp[i].length</code>&nbsp;<code>&lt;= 1000</code></li>\n\t<li><code><font face=\"monospace\">0 &lt;= lcp[i][j] &lt;= n</font></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2574.左右元素和的差值",
        "hardRate": "EASY",
        "passRate": "84.99%",
        "problemsUrl": "https://leetcode.cn/problems/left-and-right-sum-differences/",
        "solutionsUrl": "https://leetcode.cn/problems/left-and-right-sum-differences/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，请你找出一个下标从 <strong>0</strong> 开始的整数数组 <code>answer</code> ，其中：</p>\n\n<ul>\n\t<li><code>answer.length == nums.length</code></li>\n\t<li><code>answer[i] = |leftSum[i] - rightSum[i]|</code></li>\n</ul>\n\n<p>其中：</p>\n\n<ul>\n\t<li><code>leftSum[i]</code> 是数组 <code>nums</code> 中下标 <code>i</code> 左侧元素之和。如果不存在对应的元素，<code>leftSum[i] = 0</code> 。</li>\n\t<li><code>rightSum[i]</code> 是数组 <code>nums</code> 中下标 <code>i</code> 右侧元素之和。如果不存在对应的元素，<code>rightSum[i] = 0</code> 。</li>\n</ul>\n\n<p>返回数组 <code>answer</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [10,4,8,3]\n<strong>输出：</strong>[15,1,11,22]\n<strong>解释：</strong>数组 leftSum 为 [0,10,14,22] 且数组 rightSum 为 [15,11,3,0] 。\n数组 answer 为 [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] = [15,1,11,22] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1]\n<strong>输出：</strong>[0]\n<strong>解释：</strong>数组 leftSum 为 [0] 且数组 rightSum 为 [0] 。\n数组 answer 为 [|0 - 0|] = [0] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2575.找出字符串的可整除数组",
        "hardRate": "MEDIUM",
        "passRate": "32.89%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>word</code> ，长度为 <code>n</code> ，由从 <code>0</code> 到 <code>9</code> 的数字组成。另给你一个正整数 <code>m</code> 。</p>\n\n<p><code>word</code> 的 <strong>可整除数组</strong> <code>div</code>&nbsp; 是一个长度为 <code>n</code> 的整数数组，并满足：</p>\n\n<ul>\n\t<li>如果 <code>word[0,...,i]</code> 所表示的 <strong>数值</strong> 能被 <code>m</code> 整除，<code>div[i] = 1</code></li>\n\t<li>否则，<code>div[i] = 0</code></li>\n</ul>\n\n<p>返回<em> </em><code>word</code> 的可整除数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"998244353\", m = 3\n<strong>输出：</strong>[1,1,0,0,0,1,1,0,0]\n<strong>解释：</strong>仅有 4 个前缀可以被 3 整除：\"9\"、\"99\"、\"998244\" 和 \"9982443\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"1010\", m = 10\n<strong>输出：</strong>[0,1,0,1]\n<strong>解释：</strong>仅有 2 个前缀可以被 10 整除：\"10\" 和 \"1010\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>word.length == n</code></li>\n\t<li><code>word</code> 由数字 <code>0</code> 到 <code>9</code> 组成</li>\n\t<li><code>1 &lt;= m &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2576.求出最多标记下标",
        "hardRate": "MEDIUM",
        "passRate": "36.99%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>一开始，所有下标都没有被标记。你可以执行以下操作任意次：</p>\n\n<ul>\n\t<li>选择两个 <strong>互不相同且未标记</strong>&nbsp;的下标&nbsp;<code>i</code> 和&nbsp;<code>j</code>&nbsp;，满足&nbsp;<code>2 * nums[i] &lt;= nums[j]</code>&nbsp;，标记下标&nbsp;<code>i</code> 和&nbsp;<code>j</code>&nbsp;。</li>\n</ul>\n\n<p>请你执行上述操作任意次，返回<em>&nbsp;</em><code>nums</code>&nbsp;中最多可以标记的下标数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,5,2,4]\n<b>输出：</b>2\n<strong>解释：</strong>第一次操作中，选择 i = 2 和 j = 1 ，操作可以执行的原因是 2 * nums[2] &lt;= nums[1] ，标记下标 2 和 1 。\n没有其他更多可执行的操作，所以答案为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [9,2,5,4]\n<b>输出：</b>4\n<strong>解释：</strong>第一次操作中，选择 i = 3 和 j = 0 ，操作可以执行的原因是 2 * nums[3] &lt;= nums[0] ，标记下标 3 和 0 。\n第二次操作中，选择 i = 1 和 j = 2 ，操作可以执行的原因是 2 * nums[1] &lt;= nums[2] ，标记下标 1 和 2 。\n没有其他更多可执行的操作，所以答案为 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [7,6,8]\n<b>输出：</b>0\n<strong>解释：</strong>没有任何可以执行的操作，所以答案为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2577.在网格图中访问一个格子的最少时间",
        "hardRate": "HARD",
        "passRate": "39.53%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的矩阵&nbsp;<code>grid</code>&nbsp;，每个元素都为 <strong>非负</strong>&nbsp;整数，其中&nbsp;<code>grid[row][col]</code>&nbsp;表示可以访问格子&nbsp;<code>(row, col)</code>&nbsp;的&nbsp;<strong>最早</strong>&nbsp;时间。也就是说当你访问格子&nbsp;<code>(row, col)</code>&nbsp;时，最少已经经过的时间为&nbsp;<code>grid[row][col]</code>&nbsp;。</p>\n\n<p>你从 <strong>最左上角</strong>&nbsp;出发，出发时刻为 <code>0</code>&nbsp;，你必须一直移动到上下左右相邻四个格子中的 <strong>任意</strong>&nbsp;一个格子（即不能停留在格子上）。每次移动都需要花费 1 单位时间。</p>\n\n<p>请你返回 <strong>最早</strong>&nbsp;到达右下角格子的时间，如果你无法到达右下角的格子，请你返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-8.png\" /></p>\n\n<pre>\n<b>输入：</b>grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]\n<b>输出：</b>7\n<b>解释：</b>一条可行的路径为：\n- 时刻 t = 0 ，我们在格子 (0,0) 。\n- 时刻 t = 1 ，我们移动到格子 (0,1) ，可以移动的原因是 grid[0][1] &lt;= 1 。\n- 时刻 t = 2 ，我们移动到格子 (1,1) ，可以移动的原因是 grid[1][1] &lt;= 2 。\n- 时刻 t = 3 ，我们移动到格子 (1,2) ，可以移动的原因是 grid[1][2] &lt;= 3 。\n- 时刻 t = 4 ，我们移动到格子 (1,1) ，可以移动的原因是 grid[1][1] &lt;= 4 。\n- 时刻 t = 5 ，我们移动到格子 (1,2) ，可以移动的原因是 grid[1][2] &lt;= 5 。\n- 时刻 t = 6 ，我们移动到格子 (1,3) ，可以移动的原因是 grid[1][3] &lt;= 6 。\n- 时刻 t = 7 ，我们移动到格子 (2,3) ，可以移动的原因是 grid[2][3] &lt;= 7 。\n最终到达时刻为 7 。这是最早可以到达的时间。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-9.png\" style=\"width: 151px; height: 151px;\" /></p>\n\n<pre>\n<b>输入：</b>grid = [[0,2,4],[3,2,1],[1,0,4]]\n<b>输出：</b>-1\n<b>解释：</b>没法从左上角按题目规定走到右下角。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>grid[0][0] == 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2578.最小和分割",
        "hardRate": "EASY",
        "passRate": "76.21%",
        "problemsUrl": "https://leetcode.cn/problems/split-with-minimum-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/split-with-minimum-sum/solution",
        "problemsDesc": "<p>给你一个正整数&nbsp;<code>num</code>&nbsp;，请你将它分割成两个非负整数&nbsp;<code>num1</code> 和&nbsp;<code>num2</code>&nbsp;，满足：</p>\n\n<ul>\n\t<li><code>num1</code> 和&nbsp;<code>num2</code>&nbsp;直接连起来，得到&nbsp;<code>num</code>&nbsp;各数位的一个排列。\n\n\t<ul>\n\t\t<li>换句话说，<code>num1</code> 和&nbsp;<code>num2</code>&nbsp;中所有数字出现的次数之和等于&nbsp;<code>num</code>&nbsp;中所有数字出现的次数。</li>\n\t</ul>\n\t</li>\n\t<li><code>num1</code> 和&nbsp;<code>num2</code>&nbsp;可以包含前导 0 。</li>\n</ul>\n\n<p>请你返回&nbsp;<code>num1</code> 和 <code>num2</code>&nbsp;可以得到的和的 <strong>最小</strong> 值。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><code>num</code>&nbsp;保证没有前导 0 。</li>\n\t<li><code>num1</code> 和&nbsp;<code>num2</code>&nbsp;中数位顺序可以与&nbsp;<code>num</code>&nbsp;中数位顺序不同。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>num = 4325\n<b>输出：</b>59\n<b>解释：</b>我们可以将 4325 分割成 <code>num1 </code>= 24 和 num2<code> = </code>35 ，和为 59 ，59 是最小和。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>num = 687\n<b>输出：</b>75\n<b>解释：</b>我们可以将 687 分割成 <code>num1</code> = 68 和 <code>num2 </code>= 7 ，和为最优值 75 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>10 &lt;= num &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2579.统计染色格子数",
        "hardRate": "MEDIUM",
        "passRate": "66.25%",
        "problemsUrl": "https://leetcode.cn/problems/count-total-number-of-colored-cells/",
        "solutionsUrl": "https://leetcode.cn/problems/count-total-number-of-colored-cells/solution",
        "problemsDesc": "<p>有一个无穷大的二维网格图，一开始所有格子都未染色。给你一个正整数&nbsp;<code>n</code>&nbsp;，表示你需要执行以下步骤&nbsp;<code>n</code>&nbsp;分钟：</p>\n\n<ul>\n\t<li>第一分钟，将 <strong>任一</strong> 格子染成蓝色。</li>\n\t<li>之后的每一分钟，将与蓝色格子相邻的 <strong>所有</strong> 未染色格子染成蓝色。</li>\n</ul>\n\n<p>下图分别是 1、2、3 分钟后的网格图。</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/10/example-copy-2.png\" style=\"width: 500px; height: 279px;\">\n<p>请你返回 <code>n</code>&nbsp;分钟之后 <strong>被染色的格子&nbsp;</strong>数目。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre><b>输入：</b>n = 1\n<b>输出：</b>1\n<b>解释：</b>1 分钟后，只有 1 个蓝色的格子，所以返回 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 2\n<b>输出：</b>5\n<b>解释：</b>2 分钟后，有 4 个在边缘的蓝色格子和 1 个在中间的蓝色格子，所以返回 5 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2580.统计将重叠区间合并成组的方案数",
        "hardRate": "MEDIUM",
        "passRate": "35.46%",
        "problemsUrl": "https://leetcode.cn/problems/count-ways-to-group-overlapping-ranges/",
        "solutionsUrl": "https://leetcode.cn/problems/count-ways-to-group-overlapping-ranges/solution",
        "problemsDesc": "<p>给你一个二维整数数组&nbsp;<code>ranges</code>&nbsp;，其中&nbsp;<code>ranges[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>&nbsp;表示&nbsp;<code>start<sub>i</sub></code>&nbsp;到&nbsp;<code>end<sub>i</sub></code>&nbsp;之间（包括二者）的所有整数都包含在第&nbsp;<code>i</code>&nbsp;个区间中。</p>\n\n<p>你需要将&nbsp;<code>ranges</code>&nbsp;分成 <strong>两个</strong>&nbsp;组（可以为空），满足：</p>\n\n<ul>\n\t<li>每个区间只属于一个组。</li>\n\t<li>两个有 <strong>交集</strong>&nbsp;的区间必须在 <strong>同一个&nbsp;</strong>组内。</li>\n</ul>\n\n<p>如果两个区间有至少 <strong>一个</strong>&nbsp;公共整数，那么这两个区间是 <b>有交集</b>&nbsp;的。</p>\n\n<ul>\n\t<li>比方说，区间&nbsp;<code>[1, 3]</code> 和&nbsp;<code>[2, 5]</code>&nbsp;有交集，因为&nbsp;<code>2</code>&nbsp;和&nbsp;<code>3</code>&nbsp;在两个区间中都被包含。</li>\n</ul>\n\n<p>请你返回将 <code>ranges</code>&nbsp;划分成两个组的 <strong>总方案数</strong>&nbsp;。由于答案可能很大，将它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>ranges = [[6,10],[5,15]]\n<b>输出：</b>2\n<b>解释：</b>\n两个区间有交集，所以它们必须在同一个组内。\n所以有两种方案：\n- 将两个区间都放在第 1 个组中。\n- 将两个区间都放在第 2 个组中。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>ranges = [[1,3],[10,20],[2,5],[4,8]]\n<b>输出：</b>4\n<b>解释：</b>\n区间 [1,3] 和 [2,5] 有交集，所以它们必须在同一个组中。\n同理，区间 [2,5] 和 [4,8] 也有交集，所以它们也必须在同一个组中。\n所以总共有 4 种分组方案：\n- 所有区间都在第 1 组。\n- 所有区间都在第 2 组。\n- 区间 [1,3] ，[2,5] 和 [4,8] 在第 1 个组中，[10,20] 在第 2 个组中。\n- 区间 [1,3] ，[2,5] 和 [4,8] 在第 2 个组中，[10,20] 在第 1 个组中。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= ranges.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>ranges[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2581.统计可能的树根数目",
        "hardRate": "HARD",
        "passRate": "57.50%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-possible-root-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-possible-root-nodes/solution",
        "problemsDesc": null,
        "isPlus": false
    },
    {
        "problemsName": " 2582.递枕头",
        "hardRate": "EASY",
        "passRate": "55.94%",
        "problemsUrl": "https://leetcode.cn/problems/pass-the-pillow/",
        "solutionsUrl": "https://leetcode.cn/problems/pass-the-pillow/solution",
        "problemsDesc": null,
        "isPlus": false
    },
    {
        "problemsName": " 2583.二叉树中的第 K 大层和",
        "hardRate": "MEDIUM",
        "passRate": "43.98%",
        "problemsUrl": "https://leetcode.cn/problems/kth-largest-sum-in-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-largest-sum-in-a-binary-tree/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点 <code>root</code> 和一个正整数 <code>k</code> 。</p>\n\n<p>树中的 <strong>层和</strong> 是指 <strong>同一层</strong> 上节点值的总和。</p>\n\n<p>返回树中第 <code>k</code> 大的层和（不一定不同）。如果树少于 <code>k</code> 层，则返回 <code>-1</code> 。</p>\n\n<p><strong>注意</strong>，如果两个节点与根节点的距离相同，则认为它们在同一层。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/14/binaryytreeedrawio-2.png\" style=\"width: 301px; height: 284px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,8,9,2,1,3,7,4,6], k = 2\n<strong>输出：</strong>13\n<strong>解释：</strong>树中每一层的层和分别是：\n- Level 1: 5\n- Level 2: 8 + 9 = 17\n- Level 3: 2 + 1 + 3 + 7 = 13\n- Level 4: 4 + 6 = 10\n第 2 大的层和等于 13 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/14/treedrawio-3.png\" style=\"width: 181px; height: 181px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,null,3], k = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>最大的层和是 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数为 <code>n</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2584.分割数组使乘积互质",
        "hardRate": "HARD",
        "passRate": "25.44%",
        "problemsUrl": "https://leetcode.cn/problems/split-the-array-to-make-coprime-products/",
        "solutionsUrl": "https://leetcode.cn/problems/split-the-array-to-make-coprime-products/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，下标从 <strong>0</strong> 开始。</p>\n\n<p>如果在下标 <code>i</code> 处 <strong>分割</strong> 数组，其中 <code>0 &lt;= i &lt;= n - 2</code> ，使前 <code>i + 1</code> 个元素的乘积和剩余元素的乘积互质，则认为该分割 <strong>有效</strong> 。</p>\n\n<ul>\n\t<li>例如，如果 <code>nums = [2, 3, 3]</code> ，那么在下标 <code>i = 0</code> 处的分割有效，因为 <code>2</code> 和 <code>9</code> 互质，而在下标 <code>i = 1</code> 处的分割无效，因为 <code>6</code> 和 <code>3</code> 不互质。在下标 <code>i = 2</code> 处的分割也无效，因为 <code>i == n - 1</code> 。</li>\n</ul>\n\n<p>返回可以有效分割数组的最小下标 <code>i</code> ，如果不存在有效分割，则返回 <code>-1</code> 。</p>\n\n<p>当且仅当 <code>gcd(val1, val2) == 1</code> 成立时，<code>val1</code> 和 <code>val2</code> 这两个值才是互质的，其中 <code>gcd(val1, val2)</code> 表示 <code>val1</code> 和 <code>val2</code> 的最大公约数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/14/second.PNG\" style=\"width: 450px; height: 211px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,7,8,15,3,5]\n<strong>输出：</strong>2\n<strong>解释：</strong>上表展示了每个下标 i 处的前 i + 1 个元素的乘积、剩余元素的乘积和它们的最大公约数的值。\n唯一一个有效分割位于下标 2 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/14/capture.PNG\" style=\"width: 450px; height: 215px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,7,15,8,3,5]\n<strong>输出：</strong>-1\n<strong>解释：</strong>上表展示了每个下标 i 处的前 i + 1 个元素的乘积、剩余元素的乘积和它们的最大公约数的值。\n不存在有效分割。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2585.获得分数的方法数",
        "hardRate": "HARD",
        "passRate": "64.52%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-earn-points/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-earn-points/solution",
        "problemsDesc": "<p>考试中有 <code>n</code> 种类型的题目。给你一个整数 <code>target</code> 和一个下标从 <strong>0</strong> 开始的二维整数数组 <code>types</code> ，其中 <code>types[i] = [count<sub>i</sub>, marks<sub>i</sub>] </code>表示第 <code>i</code> 种类型的题目有 <code>count<sub>i</sub></code> 道，每道题目对应 <code>marks<sub>i</sub></code> 分。</p>\n\n<p>返回你在考试中恰好得到 <code>target</code> 分的方法数。由于答案可能很大，结果需要对 <code>10<sup>9</sup> +7</code> 取余。</p>\n\n<p><strong>注意</strong>，同类型题目无法区分。</p>\n\n<ul>\n\t<li>比如说，如果有 <code>3</code> 道同类型题目，那么解答第 <code>1</code> 和第 <code>2</code> 道题目与解答第 <code>1</code> 和第 <code>3</code> 道题目或者第 <code>2</code> 和第 <code>3</code> 道题目是相同的。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>target = 6, types = [[6,1],[3,2],[2,3]]\n<strong>输出：</strong>7\n<strong>解释：</strong>要获得 6 分，你可以选择以下七种方法之一：\n- 解决 6 道第 0 种类型的题目：1 + 1 + 1 + 1 + 1 + 1 = 6\n- 解决 4 道第 0 种类型的题目和 1 道第 1 种类型的题目：1 + 1 + 1 + 1 + 2 = 6\n- 解决 2 道第 0 种类型的题目和 2 道第 1 种类型的题目：1 + 1 + 2 + 2 = 6\n- 解决 3 道第 0 种类型的题目和 1 道第 2 种类型的题目：1 + 1 + 1 + 3 = 6\n- 解决 1 道第 0 种类型的题目、1 道第 1 种类型的题目和 1 道第 2 种类型的题目：1 + 2 + 3 = 6\n- 解决 3 道第 1 种类型的题目：2 + 2 + 2 = 6\n- 解决 2 道第 2 种类型的题目：3 + 3 = 6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>target = 5, types = [[50,1],[50,2],[50,5]]\n<strong>输出：</strong>4\n<strong>解释：</strong>要获得 5 分，你可以选择以下四种方法之一：\n- 解决 5 道第 0 种类型的题目：1 + 1 + 1 + 1 + 1 = 5\n- 解决 3 道第 0 种类型的题目和 1 道第 1 种类型的题目：1 + 1 + 1 + 2 = 5\n- 解决 1 道第 0 种类型的题目和 2 道第 1 种类型的题目：1 + 2 + 2 = 5\n- 解决 1 道第 2 种类型的题目：5\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>target = 18, types = [[6,1],[3,2],[2,3]]\n<strong>输出：</strong>1\n<strong>解释：</strong>只有回答所有题目才能获得 18 分。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target &lt;= 1000</code></li>\n\t<li><code>n == types.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>types[i].length == 2</code></li>\n\t<li><code>1 &lt;= count<sub>i</sub>, marks<sub>i</sub> &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2586.统计范围内的元音字符串数",
        "hardRate": "EASY",
        "passRate": "81.36%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-vowel-strings-in-range/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-vowel-strings-in-range/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串数组 <code>words</code> 和两个整数：<code>left</code> 和 <code>right</code> 。</p>\n\n<p>如果字符串以元音字母开头并以元音字母结尾，那么该字符串就是一个 <strong>元音字符串</strong> ，其中元音字母是 <code>'a'</code>、<code>'e'</code>、<code>'i'</code>、<code>'o'</code>、<code>'u'</code> 。</p>\n\n<p>返回<em> </em><code>words[i]</code> 是元音字符串的数目，其中<em> </em><code>i</code> 在闭区间 <code>[left, right]</code> 内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"are\",\"amy\",\"u\"], left = 0, right = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>\n- \"are\" 是一个元音字符串，因为它以 'a' 开头并以 'e' 结尾。\n- \"amy\" 不是元音字符串，因为它没有以元音字母结尾。\n- \"u\" 是一个元音字符串，因为它以 'u' 开头并以 'u' 结尾。\n在上述范围中的元音字符串数目为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"hey\",\"aeo\",\"mu\",\"ooo\",\"artro\"], left = 1, right = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>\n- \"aeo\" 是一个元音字符串，因为它以 'a' 开头并以 'o' 结尾。\n- \"mu\" 不是元音字符串，因为它没有以元音字母开头。\n- \"ooo\" 是一个元音字符串，因为它以 'o' 开头并以 'o' 结尾。\n- \"artro\" 是一个元音字符串，因为它以 'a' 开头并以 'o' 结尾。\n在上述范围中的元音字符串数目为 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>words[i]</code> 仅由小写英文字母组成</li>\n\t<li><code>0 &lt;= left &lt;= right &lt; words.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2587.重排数组以得到最大前缀分数",
        "hardRate": "MEDIUM",
        "passRate": "40.68%",
        "problemsUrl": "https://leetcode.cn/problems/rearrange-array-to-maximize-prefix-score/",
        "solutionsUrl": "https://leetcode.cn/problems/rearrange-array-to-maximize-prefix-score/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。你可以将 <code>nums</code> 中的元素按 <strong>任意顺序</strong> 重排（包括给定顺序）。</p>\n\n<p>令 <code>prefix</code> 为一个数组，它包含了 <code>nums</code> 重新排列后的前缀和。换句话说，<code>prefix[i]</code> 是 <code>nums</code> 重新排列后下标从 <code>0</code> 到 <code>i</code> 的元素之和。<code>nums</code> 的 <strong>分数</strong> 是 <code>prefix</code> 数组中正整数的个数。</p>\n\n<p>返回可以得到的最大分数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,-1,0,1,-3,3,-3]\n<strong>输出：</strong>6\n<strong>解释：</strong>数组重排为 nums = [2,3,1,-1,-3,0,-3] 。\nprefix = [2,5,6,5,2,2,-1] ，分数为 6 。\n可以证明 6 是能够得到的最大分数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [-2,-3,0]\n<strong>输出：</strong>0\n<strong>解释：</strong>不管怎么重排数组得到的分数都是 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>6</sup> &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2588.统计美丽子数组数目",
        "hardRate": "MEDIUM",
        "passRate": "41.99%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组<code>nums</code>&nbsp;。每次操作中，你可以：</p>\n\n<ul>\n\t<li>选择两个满足&nbsp;<code>0 &lt;= i, j &lt; nums.length</code>&nbsp;的不同下标&nbsp;<code>i</code>&nbsp;和&nbsp;<code>j</code>&nbsp;。</li>\n\t<li>选择一个非负整数&nbsp;<code>k</code>&nbsp;，满足 <code>nums[i]</code>&nbsp;和 <code>nums[j]</code>&nbsp;在二进制下的第 <code>k</code>&nbsp;位（下标编号从 <strong>0</strong>&nbsp;开始）是 <code>1</code>&nbsp;。</li>\n\t<li>将 <code>nums[i]</code>&nbsp;和 <code>nums[j]</code>&nbsp;都减去&nbsp;<code>2<sup>k</sup></code>&nbsp;。</li>\n</ul>\n\n<p>如果一个子数组内执行上述操作若干次后，该子数组可以变成一个全为 <code>0</code>&nbsp;的数组，那么我们称它是一个 <strong>美丽</strong>&nbsp;的子数组。</p>\n\n<p>请你返回数组 <code>nums</code>&nbsp;中 <strong>美丽子数组</strong>&nbsp;的数目。</p>\n\n<p>子数组是一个数组中一段连续 <strong>非空</strong>&nbsp;的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [4,3,1,2,4]\n<b>输出：</b>2\n<b>解释：</b>nums 中有 2 个美丽子数组：[4,<em><strong>3,1,2</strong></em>,4] 和 [<em><strong>4,3,1,2,4</strong></em>] 。\n- 按照下述步骤，我们可以将子数组 [3,1,2] 中所有元素变成 0 ：\n  - 选择 [<em><strong>3</strong></em>, 1, <em><strong>2</strong></em>] 和 k = 1 。将 2 个数字都减去 2<sup>1</sup> ，子数组变成 [1, 1, 0] 。\n  - 选择 [<em><strong>1</strong></em>, <em><strong>1</strong></em>, 0] 和 k = 0 。将 2 个数字都减去 2<sup>0</sup> ，子数组变成 [0, 0, 0] 。\n- 按照下述步骤，我们可以将子数组 [4,3,1,2,4] 中所有元素变成 0 ：\n  - 选择 [<em><strong>4</strong></em>, 3, 1, 2, <em><strong>4</strong></em>] 和 k = 2 。将 2 个数字都减去 2<sup>2</sup> ，子数组变成 [0, 3, 1, 2, 0] 。\n  - 选择 [0, <em><strong>3</strong></em>, <em><strong>1</strong></em>, 2, 0] 和 k = 0 。将 2 个数字都减去 2<sup>0</sup> ，子数组变成 [0, 2, 0, 2, 0] 。\n  - 选择 [0, <em><strong>2</strong></em>, 0, <em><strong>2</strong></em>, 0] 和 k = 1 。将 2 个数字都减去 2<sup>1</sup> ，子数组变成 [0, 0, 0, 0, 0] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,10,4]\n<b>输出：</b>0\n<b>解释：</b>nums 中没有任何美丽子数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2589.完成所有任务的最少时间",
        "hardRate": "HARD",
        "passRate": "42.70%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/solution",
        "problemsDesc": "<p>你有一台电脑，它可以 <strong>同时</strong>&nbsp;运行无数个任务。给你一个二维整数数组&nbsp;<code>tasks</code>&nbsp;，其中&nbsp;<code>tasks[i] = [start<sub>i</sub>, end<sub>i</sub>, duration<sub>i</sub>]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个任务需要在 <strong>闭区间</strong>&nbsp;时间段&nbsp;<code>[start<sub>i</sub>, end<sub>i</sub>]</code>&nbsp;内运行&nbsp;<code>duration<sub>i</sub></code>&nbsp;个整数时间点（但不需要连续）。</p>\n\n<p>当电脑需要运行任务时，你可以打开电脑，如果空闲时，你可以将电脑关闭。</p>\n\n<p>请你返回完成所有任务的情况下，电脑最少需要运行多少秒。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>tasks = [[2,3,1],[4,5,1],[1,5,2]]\n<b>输出：</b>2\n<b>解释：</b>\n- 第一个任务在闭区间 [2, 2] 运行。\n- 第二个任务在闭区间 [5, 5] 运行。\n- 第三个任务在闭区间 [2, 2] 和 [5, 5] 运行。\n电脑总共运行 2 个整数时间点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>tasks = [[1,3,2],[2,5,3],[5,6,2]]\n<b>输出：</b>4\n<b>解释：</b>\n- 第一个任务在闭区间 [2, 3] 运行\n- 第二个任务在闭区间 [2, 3] 和 [5, 5] 运行。\n- 第三个任务在闭区间 [5, 6] 运行。\n电脑总共运行 4 个整数时间点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tasks.length &lt;= 2000</code></li>\n\t<li><code>tasks[i].length == 3</code></li>\n\t<li><code>1 &lt;= start<sub>i</sub>, end<sub>i</sub> &lt;= 2000</code></li>\n\t<li><code>1 &lt;= duration<sub>i</sub> &lt;= end<sub>i</sub> - start<sub>i</sub> + 1 </code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2590.设计一个待办事项清单",
        "hardRate": "MEDIUM",
        "passRate": "55.78%",
        "problemsUrl": "https://leetcode.cn/problems/design-a-todo-list/",
        "solutionsUrl": "https://leetcode.cn/problems/design-a-todo-list/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2591.将钱分给最多的儿童",
        "hardRate": "EASY",
        "passRate": "20.76%",
        "problemsUrl": "https://leetcode.cn/problems/distribute-money-to-maximum-children/",
        "solutionsUrl": "https://leetcode.cn/problems/distribute-money-to-maximum-children/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>money</code>&nbsp;，表示你总共有的钱数（单位为美元）和另一个整数&nbsp;<code>children</code>&nbsp;，表示你要将钱分配给多少个儿童。</p>\n\n<p>你需要按照如下规则分配：</p>\n\n<ul>\n\t<li>所有的钱都必须被分配。</li>\n\t<li>每个儿童至少获得&nbsp;<code>1</code>&nbsp;美元。</li>\n\t<li>没有人获得 <code>4</code>&nbsp;美元。</li>\n</ul>\n\n<p>请你按照上述规则分配金钱，并返回 <strong>最多</strong>&nbsp;有多少个儿童获得 <strong>恰好</strong><em>&nbsp;</em><code>8</code>&nbsp;美元。如果没有任何分配方案，返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>money = 20, children = 3\n<b>输出：</b>1\n<b>解释：</b>\n最多获得 8 美元的儿童数为 1 。一种分配方案为：\n- 给第一个儿童分配 8 美元。\n- 给第二个儿童分配 9 美元。\n- 给第三个儿童分配 3 美元。\n没有分配方案能让获得 8 美元的儿童数超过 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>money = 16, children = 2\n<b>输出：</b>2\n<b>解释：</b>每个儿童都可以获得 8 美元。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= money &lt;= 200</code></li>\n\t<li><code>2 &lt;= children &lt;= 30</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2592.最大化数组的伟大值",
        "hardRate": "MEDIUM",
        "passRate": "57.60%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-greatness-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-greatness-of-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 0 开始的整数数组&nbsp;<code>nums</code>&nbsp;。你需要将&nbsp;<code>nums</code>&nbsp;重新排列成一个新的数组&nbsp;<code>perm</code>&nbsp;。</p>\n\n<p>定义 <code>nums</code>&nbsp;的 <strong>伟大值</strong>&nbsp;为满足&nbsp;<code>0 &lt;= i &lt; nums.length</code>&nbsp;且&nbsp;<code>perm[i] &gt; nums[i]</code>&nbsp;的下标数目。</p>\n\n<p>请你返回重新排列 <code>nums</code>&nbsp;后的 <strong>最大</strong>&nbsp;伟大值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,3,5,2,1,3,1]\n<b>输出：</b>4\n<b>解释：</b>一个最优安排方案为 perm = [2,5,1,3,3,1,1] 。\n在下标为 0, 1, 3 和 4 处，都有 perm[i] &gt; nums[i] 。因此我们返回 4 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4]\n<b>输出：</b>3\n<b>解释：</b>最优排列为 [2,3,4,1] 。\n在下标为 0, 1 和 2 处，都有 perm[i] &gt; nums[i] 。因此我们返回 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2593.标记所有元素后数组的分数",
        "hardRate": "MEDIUM",
        "passRate": "51.99%",
        "problemsUrl": "https://leetcode.cn/problems/find-score-of-an-array-after-marking-all-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/find-score-of-an-array-after-marking-all-elements/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>nums</code>&nbsp;，它包含若干正整数。</p>\n\n<p>一开始分数&nbsp;<code>score = 0</code>&nbsp;，请你按照下面算法求出最后分数：</p>\n\n<ul>\n\t<li>从数组中选择最小且没有被标记的整数。如果有相等元素，选择下标最小的一个。</li>\n\t<li>将选中的整数加到&nbsp;<code>score</code>&nbsp;中。</li>\n\t<li>标记 <strong>被选中元素</strong>，如果有相邻元素，则同时标记&nbsp;<strong>与它相邻的两个元素</strong>&nbsp;。</li>\n\t<li>重复此过程直到数组中所有元素都被标记。</li>\n</ul>\n\n<p>请你返回执行上述算法后最后的分数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,1,3,4,5,2]\n<b>输出：</b>7\n<b>解释：</b>我们按照如下步骤标记元素：\n- 1 是最小未标记元素，所以标记它和相邻两个元素：[<em><strong>2</strong></em>,<em><strong>1</strong></em>,<em><strong>3</strong></em>,4,5,2] 。\n- 2 是最小未标记元素，所以标记它和左边相邻元素：[<em><strong>2</strong></em>,<em><strong>1</strong></em>,<em><strong>3</strong></em>,4,<em><strong>5</strong></em>,<em><strong>2</strong></em>] 。\n- 4 是仅剩唯一未标记的元素，所以我们标记它：[<em><strong>2</strong></em>,<em><strong>1</strong></em>,<em><strong>3</strong></em>,<em><strong>4</strong></em>,<em><strong>5</strong></em>,<em><strong>2</strong></em>] 。\n总得分为 1 + 2 + 4 = 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,3,5,1,3,2]\n<b>输出：</b>5\n<b>解释：</b>我们按照如下步骤标记元素：\n- 1 是最小未标记元素，所以标记它和相邻两个元素：[2,3,<em><strong>5</strong></em>,<em><strong>1</strong></em>,<em><strong>3</strong></em>,2] 。\n- 2 是最小未标记元素，由于有两个 2 ，我们选择最左边的一个 2 ，也就是下标为 0 处的 2 ，以及它右边相邻的元素：[<em><strong>2</strong></em>,<em><strong>3</strong></em>,<em><strong>5</strong></em>,<em><strong>1</strong></em>,<em><strong>3</strong></em>,2] 。\n- 2 是仅剩唯一未标记的元素，所以我们标记它：[<em><strong>2</strong></em>,<em><strong>3</strong></em>,<em><strong>5</strong></em>,<em><strong>1</strong></em>,<em><strong>3</strong></em>,<em><strong>2</strong></em>] 。\n总得分为 1 + 2 + 2 = 5 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2594.修车的最少时间",
        "hardRate": "MEDIUM",
        "passRate": "45.45%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-repair-cars/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-repair-cars/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>ranks</code>&nbsp;，表示一些机械工的 <strong>能力值</strong>&nbsp;。<code>ranks<sub>i</sub></code> 是第 <code>i</code> 位机械工的能力值。能力值为&nbsp;<code>r</code>&nbsp;的机械工可以在&nbsp;<code>r * n<sup>2</sup></code>&nbsp;分钟内修好&nbsp;<code>n</code>&nbsp;辆车。</p>\n\n<p>同时给你一个整数&nbsp;<code>cars</code>&nbsp;，表示总共需要修理的汽车数目。</p>\n\n<p>请你返回修理所有汽车&nbsp;<strong>最少</strong>&nbsp;需要多少时间。</p>\n\n<p><strong>注意：</strong>所有机械工可以同时修理汽车。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>ranks = [4,2,3,1], cars = 10\n<b>输出：</b>16\n<b>解释：</b>\n- 第一位机械工修 2 辆车，需要 4 * 2 * 2 = 16 分钟。\n- 第二位机械工修 2 辆车，需要 2 * 2 * 2 = 8 分钟。\n- 第三位机械工修 2 辆车，需要 3 * 2 * 2 = 12 分钟。\n- 第四位机械工修 4 辆车，需要 1 * 4 * 4 = 16 分钟。\n16 分钟是修理完所有车需要的最少时间。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>ranks = [5,1,8], cars = 6\n<b>输出：</b>16\n<b>解释：</b>\n- 第一位机械工修 1 辆车，需要 5 * 1 * 1 = 5 分钟。\n- 第二位机械工修 4 辆车，需要 1 * 4 * 4 = 16 分钟。\n- 第三位机械工修 1 辆车，需要 8 * 1 * 1 = 8 分钟。\n16 分钟时修理完所有车需要的最少时间。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= ranks.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= ranks[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= cars &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2595.奇偶位数",
        "hardRate": "EASY",
        "passRate": "72.80%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-even-and-odd-bits/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-even-and-odd-bits/solution",
        "problemsDesc": "<p>给你一个 <strong>正</strong> 整数 <code>n</code> 。</p>\n\n<p>用 <code>even</code> 表示在 <code>n</code> 的二进制形式（下标从 <strong>0</strong> 开始）中值为 <code>1</code> 的偶数下标的个数。</p>\n\n<p>用 <code>odd</code> 表示在 <code>n</code> 的二进制形式（下标从 <strong>0</strong> 开始）中值为 <code>1</code> 的奇数下标的个数。</p>\n\n<p>返回整数数组<em> </em><code>answer</code><em> </em>，其中<em> </em><code>answer = [even, odd]</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 17\n<strong>输出：</strong>[2,0]\n<strong>解释：</strong>17 的二进制形式是 10001 。 \n下标 0 和 下标 4 对应的值为 1 。 \n共有 2 个偶数下标，0 个奇数下标。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>[0,1]\n<strong>解释：</strong>2 的二进制形式是 10 。 \n下标 1 对应的值为 1 。 \n共有 0 个偶数下标，1 个奇数下标。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2596.检查骑士巡视方案",
        "hardRate": "MEDIUM",
        "passRate": "52.40%",
        "problemsUrl": "https://leetcode.cn/problems/check-knight-tour-configuration/",
        "solutionsUrl": "https://leetcode.cn/problems/check-knight-tour-configuration/solution",
        "problemsDesc": "<p>骑士在一张 <code>n x n</code> 的棋盘上巡视。在有效的巡视方案中，骑士会从棋盘的 <strong>左上角</strong> 出发，并且访问棋盘上的每个格子 <strong>恰好一次</strong> 。</p>\n\n<p>给你一个 <code>n x n</code> 的整数矩阵 <code>grid</code> ，由范围 <code>[0, n * n - 1]</code> 内的不同整数组成，其中 <code>grid[row][col]</code> 表示单元格 <code>(row, col)</code> 是骑士访问的第 <code>grid[row][col]</code> 个单元格。骑士的行动是从下标 <strong>0</strong> 开始的。</p>\n\n<p>如果 <code>grid</code> 表示了骑士的有效巡视方案，返回 <code>true</code>；否则返回 <code>false</code>。</p>\n\n<p><strong>注意</strong>，骑士行动时可以垂直移动两个格子且水平移动一个格子，或水平移动两个格子且垂直移动一个格子。下图展示了骑士从某个格子出发可能的八种行动路线。<br>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/10/12/knight.png\" style=\"width: 300px; height: 300px;\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/28/yetgriddrawio-5.png\" style=\"width: 251px; height: 251px;\">\n<pre><strong>输入：</strong>grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\n<strong>输出：</strong>true\n<strong>解释：</strong>grid 如上图所示，可以证明这是一个有效的巡视方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/28/yetgriddrawio-6.png\" style=\"width: 151px; height: 151px;\">\n<pre><strong>输入：</strong>grid = [[0,3,6],[5,8,1],[2,7,4]]\n<strong>输出：</strong>false\n<strong>解释：</strong>grid 如上图所示，考虑到骑士第 7 次行动后的位置，第 8 次行动是无效的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>3 &lt;= n &lt;= 7</code></li>\n\t<li><code>0 &lt;= grid[row][col] &lt; n * n</code></li>\n\t<li><code>grid</code> 中的所有整数 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2597.美丽子集的数目",
        "hardRate": "MEDIUM",
        "passRate": "34.65%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-beautiful-subsets/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-beautiful-subsets/solution",
        "problemsDesc": "<p>给你一个由正整数组成的数组 <code>nums</code> 和一个 <strong>正</strong> 整数 <code>k</code> 。</p>\n\n<p>如果 <code>nums</code> 的子集中，任意两个整数的绝对差均不等于 <code>k</code> ，则认为该子数组是一个 <strong>美丽</strong> 子集。</p>\n\n<p>返回数组 <code>nums</code> 中 <strong>非空</strong> 且 <strong>美丽</strong> 的子集数目。</p>\n\n<p><code>nums</code> 的子集定义为：可以经由 <code>nums</code> 删除某些元素（也可能不删除）得到的一个数组。只有在删除元素时选择的索引不同的情况下，两个子集才会被视作是不同的子集。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,4,6], k = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>数组 nums 中的美丽子集有：[2], [4], [6], [2, 6] 。\n可以证明数组 [2,4,6] 中只存在 4 个美丽子集。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1], k = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>数组 nums 中的美丽数组有：[1] 。\n可以证明数组 [1] 中只存在 1 个美丽子集。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2598.执行操作后的最大 MEX",
        "hardRate": "MEDIUM",
        "passRate": "39.05%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-missing-non-negative-integer-after-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-missing-non-negative-integer-after-operations/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>value</code> 。</p>\n\n<p>在一步操作中，你可以对 <code>nums</code> 中的任一元素加上或减去 <code>value</code> 。</p>\n\n<ul>\n\t<li>例如，如果 <code>nums = [1,2,3]</code> 且 <code>value = 2</code> ，你可以选择 <code>nums[0]</code> 减去 <code>value</code> ，得到 <code>nums = [-1,2,3]</code> 。</li>\n</ul>\n\n<p>数组的 MEX (minimum excluded) 是指其中数组中缺失的最小非负整数。</p>\n\n<ul>\n\t<li>例如，<code>[-1,2,3]</code> 的 MEX 是 <code>0</code> ，而 <code>[1,0,3]</code> 的 MEX 是 <code>2</code> 。</li>\n</ul>\n\n<p>返回在执行上述操作 <strong>任意次</strong> 后，<code>nums</code><em> </em>的最大 MEX <em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,-10,7,13,6,8], value = 5\n<strong>输出：</strong>4\n<strong>解释：</strong>执行下述操作可以得到这一结果：\n- nums[1] 加上 value 两次，nums = [1,<em><strong>0</strong></em>,7,13,6,8]\n- nums[2] 减去 value 一次，nums = [1,0,<em><strong>2</strong></em>,13,6,8]\n- nums[3] 减去 value 两次，nums = [1,0,2,<em><strong>3</strong></em>,6,8]\nnums 的 MEX 是 4 。可以证明 4 是可以取到的最大 MEX 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,-10,7,13,6,8], value = 7\n<strong>输出：</strong>2\n<strong>解释：</strong>执行下述操作可以得到这一结果：\n- nums[2] 减去 value 一次，nums = [1,-10,<em><strong>0</strong></em>,13,6,8]\nnums 的 MEX 是 2 。可以证明 2 是可以取到的最大 MEX 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, value &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2599.使前缀和数组非负",
        "hardRate": "MEDIUM",
        "passRate": "55.56%",
        "problemsUrl": "https://leetcode.cn/problems/make-the-prefix-sum-non-negative/",
        "solutionsUrl": "https://leetcode.cn/problems/make-the-prefix-sum-non-negative/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2600.K 件物品的最大和",
        "hardRate": "EASY",
        "passRate": "67.96%",
        "problemsUrl": "https://leetcode.cn/problems/k-items-with-the-maximum-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/k-items-with-the-maximum-sum/solution",
        "problemsDesc": "<p>袋子中装有一些物品，每个物品上都标记着数字 <code>1</code> 、<code>0</code> 或 <code>-1</code> 。</p>\n\n<p>给你四个非负整数 <code>numOnes</code> 、<code>numZeros</code> 、<code>numNegOnes</code> 和 <code>k</code> 。</p>\n\n<p>袋子最初包含：</p>\n\n<ul>\n\t<li><code>numOnes</code> 件标记为 <code>1</code> 的物品。</li>\n\t<li><code>numZeroes</code> 件标记为 <code>0</code> 的物品。</li>\n\t<li><code>numNegOnes</code> 件标记为 <code>-1</code> 的物品。</li>\n</ul>\n\n<p>现计划从这些物品中恰好选出 <code>k</code> 件物品。返回所有可行方案中，物品上所标记数字之和的最大值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>numOnes = 3, numZeros = 2, numNegOnes = 0, k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>袋子中的物品分别标记为 {1, 1, 1, 0, 0} 。取 2 件标记为 1 的物品，得到的数字之和为 2 。\n可以证明 2 是所有可行方案中的最大值。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>numOnes = 3, numZeros = 2, numNegOnes = 0, k = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>袋子中的物品分别标记为 {1, 1, 1, 0, 0} 。取 3 件标记为 1 的物品，1 件标记为 0 的物品，得到的数字之和为 3 。\n可以证明 3 是所有可行方案中的最大值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= numOnes, numZeros, numNegOnes &lt;= 50</code></li>\n\t<li><code>0 &lt;= k &lt;= numOnes + numZeros + numNegOnes</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2601.质数减法运算",
        "hardRate": "MEDIUM",
        "passRate": "38.58%",
        "problemsUrl": "https://leetcode.cn/problems/prime-subtraction-operation/",
        "solutionsUrl": "https://leetcode.cn/problems/prime-subtraction-operation/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，数组长度为 <code>n</code> 。</p>\n\n<p>你可以执行无限次下述运算：</p>\n\n<ul>\n\t<li>选择一个之前未选过的下标 <code>i</code> ，并选择一个 <strong>严格小于</strong> <code>nums[i]</code> 的质数 <code>p</code> ，从 <code>nums[i]</code> 中减去 <code>p</code> 。</li>\n</ul>\n\n<p>如果你能通过上述运算使得 <code>nums</code> 成为严格递增数组，则返回 <code>true</code> ；否则返回 <code>false</code> 。</p>\n\n<p><strong>严格递增数组</strong> 中的每个元素都严格大于其前面的元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,9,6,10]\n<strong>输出：</strong>true\n<strong>解释：</strong>\n在第一次运算中：选择 i = 0 和 p = 3 ，然后从 nums[0] 减去 3 ，nums 变为 [1,9,6,10] 。\n在第二次运算中：选择 i = 1 和 p = 7 ，然后从 nums[1] 减去 7 ，nums 变为 [1,2,6,10] 。\n第二次运算后，nums 按严格递增顺序排序，因此答案为 true 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [6,8,11,12]\n<strong>输出：</strong>true\n<strong>解释：</strong>nums 从一开始就按严格递增顺序排序，因此不需要执行任何运算。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,8,3]\n<strong>输出：</strong>false\n<strong>解释：</strong>可以证明，执行运算无法使 nums 按严格递增顺序排序，因此答案是 false 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>nums.length == n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2602.使数组元素全部相等的最少操作次数",
        "hardRate": "MEDIUM",
        "passRate": "33.51%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/solution",
        "problemsDesc": "<p>给你一个正整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>同时给你一个长度为 <code>m</code>&nbsp;的整数数组&nbsp;<code>queries</code>&nbsp;。第 <code>i</code>&nbsp;个查询中，你需要将 <code>nums</code>&nbsp;中所有元素变成&nbsp;<code>queries[i]</code>&nbsp;。你可以执行以下操作&nbsp;<strong>任意</strong>&nbsp;次：</p>\n\n<ul>\n\t<li>将数组里一个元素&nbsp;<strong>增大</strong>&nbsp;或者&nbsp;<strong>减小</strong>&nbsp;<code>1</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回一个长度为 <code>m</code>&nbsp;的数组<em>&nbsp;</em><code>answer</code>&nbsp;，其中<em>&nbsp;</em><code>answer[i]</code>是将&nbsp;<code>nums</code>&nbsp;中所有元素变成&nbsp;<code>queries[i]</code>&nbsp;的&nbsp;<strong>最少</strong>&nbsp;操作次数。</p>\n\n<p><strong>注意</strong>，每次查询后，数组变回最开始的值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [3,1,6,8], queries = [1,5]\n<b>输出：</b>[14,10]\n<b>解释：</b>第一个查询，我们可以执行以下操作：\n- 将 nums[0] 减小 2 次，nums = [1,1,6,8] 。\n- 将 nums[2] 减小 5 次，nums = [1,1,1,8] 。\n- 将 nums[3] 减小 7 次，nums = [1,1,1,1] 。\n第一个查询的总操作次数为 2 + 5 + 7 = 14 。\n第二个查询，我们可以执行以下操作：\n- 将 nums[0] 增大 2 次，nums = [5,1,6,8] 。\n- 将 nums[1] 增大 4 次，nums = [5,5,6,8] 。\n- 将 nums[2] 减小 1 次，nums = [5,5,5,8] 。\n- 将 nums[3] 减小 3 次，nums = [5,5,5,5] 。\n第二个查询的总操作次数为 2 + 4 + 1 + 3 = 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,9,6,3], queries = [10]\n<b>输出：</b>[20]\n<b>解释：</b>我们可以将数组中所有元素都增大到 10 ，总操作次数为 8 + 1 + 4 + 7 = 20 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>m == queries.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], queries[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2603.收集树中金币",
        "hardRate": "HARD",
        "passRate": "43.56%",
        "problemsUrl": "https://leetcode.cn/problems/collect-coins-in-a-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/collect-coins-in-a-tree/solution",
        "problemsDesc": "<p>给你一个 <code>n</code>&nbsp;个节点的无向无根树，节点编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。给你整数&nbsp;<code>n</code>&nbsp;和一个长度为 <code>n - 1</code>&nbsp;的二维整数数组 <code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示树中节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条边。再给你一个长度为 <code>n</code>&nbsp;的数组&nbsp;<code>coins</code>&nbsp;，其中&nbsp;<code>coins[i]</code> 可能为&nbsp;<code>0</code>&nbsp;也可能为&nbsp;<code>1</code>&nbsp;，<code>1</code>&nbsp;表示节点 <code>i</code>&nbsp;处有一个金币。</p>\n\n<p>一开始，你需要选择树中任意一个节点出发。你可以执行下述操作任意次：</p>\n\n<ul>\n\t<li>收集距离当前节点距离为 <code>2</code>&nbsp;以内的所有金币，或者</li>\n\t<li>移动到树中一个相邻节点。</li>\n</ul>\n\n<p>你需要收集树中所有的金币，并且回到出发节点，请你返回最少经过的边数。</p>\n\n<p>如果你多次经过一条边，每一次经过都会给答案加一。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/01/graph-2.png\" style=\"width: 522px; height: 522px;\"></p>\n\n<pre><b>输入：</b>coins = [1,0,0,0,0,1], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]\n<b>输出：</b>2\n<b>解释：</b>从节点 2 出发，收集节点 0 处的金币，移动到节点 3 ，收集节点 5 处的金币，然后移动回节点 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/02/graph-4.png\" style=\"width: 522px; height: 522px;\"></p>\n\n<pre><b>输入：</b>coins = [0,0,0,1,1,0,0,1], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]]\n<b>输出：</b>2\n<b>解释：</b>从节点 0 出发，收集节点 4 和 3 处的金币，移动到节点 2 处，收集节点 7 处的金币，移动回节点 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == coins.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= coins[i] &lt;= 1</code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>edges</code>&nbsp;表示一棵合法的树。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2604.吃掉所有谷子的最短时间",
        "hardRate": "HARD",
        "passRate": "35.25%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-eat-all-grains/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-eat-all-grains/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2605.从两个数字数组里生成最小数字",
        "hardRate": "EASY",
        "passRate": "62.60%",
        "problemsUrl": "https://leetcode.cn/problems/form-smallest-number-from-two-digit-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/form-smallest-number-from-two-digit-arrays/solution",
        "problemsDesc": "给你两个只包含 1 到 9 之间数字的数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;，每个数组中的元素 <strong>互不相同</strong>&nbsp;，请你返回 <strong>最小</strong> 的数字，两个数组都 <strong>至少</strong> 包含这个数字的某个数位。\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [4,1,3], nums2 = [5,7]\n<b>输出：</b>15\n<b>解释：</b>数字 15 的数位 1 在 nums1 中出现，数位 5 在 nums2 中出现。15 是我们能得到的最小数字。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [3,5,2,6], nums2 = [3,1,7]\n<b>输出：</b>3\n<b>解释：</b>数字 3 的数位 3 在两个数组中都出现了。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 9</code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 9</code></li>\n\t<li>每个数组中，元素 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2606.找到最大开销的子字符串",
        "hardRate": "MEDIUM",
        "passRate": "53.72%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-substring-with-maximum-cost/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-substring-with-maximum-cost/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，一个字符&nbsp;<strong>互不相同</strong>&nbsp;的字符串&nbsp;<code>chars</code>&nbsp;和一个长度与 <code>chars</code>&nbsp;相同的整数数组&nbsp;<code>vals</code>&nbsp;。</p>\n\n<p><strong>子字符串的开销</strong>&nbsp;是一个子字符串中所有字符对应价值之和。空字符串的开销是 <code>0</code>&nbsp;。</p>\n\n<p><strong>字符的价值</strong>&nbsp;定义如下：</p>\n\n<ul>\n\t<li>如果字符不在字符串&nbsp;<code>chars</code>&nbsp;中，那么它的价值是它在字母表中的位置（下标从 <strong>1</strong>&nbsp;开始）。\n\n\t<ul>\n\t\t<li>比方说，<code>'a'</code>&nbsp;的价值为&nbsp;<code>1</code>&nbsp;，<code>'b'</code>&nbsp;的价值为&nbsp;<code>2</code>&nbsp;，以此类推，<code>'z'</code>&nbsp;的价值为&nbsp;<code>26</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n\t<li>否则，如果这个字符在 <code>chars</code>&nbsp;中的位置为 <code>i</code>&nbsp;，那么它的价值就是&nbsp;<code>vals[i]</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回字符串 <code>s</code>&nbsp;的所有子字符串中的最大开销。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"adaa\", chars = \"d\", vals = [-1000]\n<b>输出：</b>2\n<b>解释：</b>字符 \"a\" 和 \"d\" 的价值分别为 1 和 -1000 。\n最大开销子字符串是 \"aa\" ，它的开销为 1 + 1 = 2 。\n2 是最大开销。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"abc\", chars = \"abc\", vals = [-1,-1,-1]\n<b>输出：</b>0\n<b>解释：</b>字符 \"a\" ，\"b\" 和 \"c\" 的价值分别为 -1 ，-1 和 -1 。\n最大开销子字符串是 \"\" ，它的开销为 0 。\n0 是最大开销。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n\t<li><code>1 &lt;= chars.length &lt;= 26</code></li>\n\t<li><code>chars</code>&nbsp;只包含小写英文字母，且 <strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>vals.length == chars.length</code></li>\n\t<li><code>-1000 &lt;= vals[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2607.使子数组元素和相等",
        "hardRate": "MEDIUM",
        "passRate": "38.70%",
        "problemsUrl": "https://leetcode.cn/problems/make-k-subarray-sums-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/make-k-subarray-sums-equal/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>arr</code> 和一个整数 <code>k</code> 。数组 <code>arr</code> 是一个循环数组。换句话说，数组中的最后一个元素的下一个元素是数组中的第一个元素，数组中第一个元素的前一个元素是数组中的最后一个元素。</p>\n\n<p>你可以执行下述运算任意次：</p>\n\n<ul>\n\t<li>选中 <code>arr</code> 中任意一个元素，并使其值加上 <code>1</code> 或减去 <code>1</code> 。</li>\n</ul>\n\n<p>执行运算使每个长度为 <code>k</code> 的 <strong>子数组</strong> 的元素总和都相等，返回所需要的最少运算次数。</p>\n\n<p><strong>子数组</strong> 是数组的一个连续部分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,4,1,3], k = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>在下标为 1 的元素那里执行一次运算，使其等于 3 。\n执行运算后，数组变为 [1,3,1,3] 。\n- 0 处起始的子数组为 [1, 3] ，元素总和为 4 \n- 1 处起始的子数组为 [3, 1] ，元素总和为 4 \n- 2 处起始的子数组为 [1, 3] ，元素总和为 4 \n- 3 处起始的子数组为 [3, 1] ，元素总和为 4 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,5,5,7], k = 3\n<strong>输出：</strong>5\n<strong>解释：</strong>在下标为 0 的元素那里执行三次运算，使其等于 5 。在下标为 3 的元素那里执行两次运算，使其等于 5 。\n执行运算后，数组变为 [5,5,5,5] 。\n- 0 处起始的子数组为 [5, 5, 5] ，元素总和为 15\n- 1 处起始的子数组为 [5, 5, 5] ，元素总和为 15\n- 2 处起始的子数组为 [5, 5, 5] ，元素总和为 15\n- 3 处起始的子数组为 [5, 5, 5] ，元素总和为 15\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2608.图中的最短环",
        "hardRate": "HARD",
        "passRate": "40.67%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-cycle-in-a-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-cycle-in-a-graph/solution",
        "problemsDesc": "<p>现有一个含 <code>n</code> 个顶点的 <strong>双向</strong> 图，每个顶点按从 <code>0</code> 到 <code>n - 1</code> 标记。图中的边由二维整数数组 <code>edges</code> 表示，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> 表示顶点 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code> 之间存在一条边。每对顶点最多通过一条边连接，并且不存在与自身相连的顶点。</p>\n\n<p>返回图中 <strong>最短</strong> 环的长度。如果不存在环，则返回 <code>-1</code> 。</p>\n\n<p><strong>环</strong> 是指以同一节点开始和结束，并且路径中的每条边仅使用一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/04/cropped.png\" style=\"width: 387px; height: 331px;\">\n<pre><strong>输入：</strong>n = 7, edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]\n<strong>输出：</strong>3\n<strong>解释：</strong>长度最小的循环是：0 -&gt; 1 -&gt; 2 -&gt; 0 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/04/croppedagin.png\" style=\"width: 307px; height: 307px;\">\n<pre><strong>输入：</strong>n = 4, edges = [[0,1],[0,2]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>图中不存在循环\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= 1000</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n\t<li>不存在重复的边</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2609.最长平衡子字符串",
        "hardRate": "EASY",
        "passRate": "49.13%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-longest-balanced-substring-of-a-binary-string/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-longest-balanced-substring-of-a-binary-string/solution",
        "problemsDesc": "<p>给你一个仅由 <code>0</code> 和 <code>1</code> 组成的二进制字符串 <code>s</code> 。<span style=\"\">&nbsp;</span><span style=\"\">&nbsp;</span></p>\n\n<p>如果子字符串中 <strong>所有的<span style=\"\"> </span></strong><code><span style=\"\">0</span></code><strong><span style=\"\"> </span>都在 </strong><code>1</code><strong> 之前</strong> 且其中 <code>0</code> 的数量等于 <code>1</code> 的数量，则认为 <code>s</code> 的这个子字符串是平衡子字符串。请注意，空子字符串也视作平衡子字符串。<span style=\"\">&nbsp;</span></p>\n\n<p>返回&nbsp;<span style=\"\"> </span><code>s</code> 中最长的平衡子字符串长度。</p>\n\n<p>子字符串是字符串中的一个连续字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"01000111\"\n<strong>输出：</strong>6\n<strong>解释：</strong>最长的平衡子字符串是 \"000111\" ，长度为 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"00111\"\n<strong>输出：</strong>4\n<strong>解释：</strong>最长的平衡子字符串是 \"0011\" ，长度为 <span style=\"\">&nbsp;</span>4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"111\"\n<strong>输出：</strong>0\n<strong>解释：</strong>除了空子字符串之外不存在其他平衡子字符串，所以答案为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 50</code></li>\n\t<li><code>'0' &lt;= s[i] &lt;= '1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2610.转换二维数组",
        "hardRate": "MEDIUM",
        "passRate": "85.13%",
        "problemsUrl": "https://leetcode.cn/problems/convert-an-array-into-a-2d-array-with-conditions/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-an-array-into-a-2d-array-with-conditions/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。请你创建一个满足以下条件的二维数组：</p>\n\n<ul>\n\t<li>二维数组应该 <strong>只</strong> 包含数组 <code>nums</code> 中的元素。</li>\n\t<li>二维数组中的每一行都包含 <strong>不同</strong> 的整数。</li>\n\t<li>二维数组的行数应尽可能 <strong>少</strong> 。</li>\n</ul>\n\n<p>返回结果数组。如果存在多种答案，则返回其中任何一种。</p>\n\n<p>请注意，二维数组的每一行上可以存在不同数量的元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3,4,1,2,3,1]\n<strong>输出：</strong>[[1,3,4,2],[1,3],[1]]\n<strong>解释：</strong>根据题目要求可以创建包含以下几行元素的二维数组：\n- 1,3,4,2\n- 1,3\n- 1\nnums 中的所有元素都有用到，并且每一行都由不同的整数组成，所以这是一个符合题目要求的答案。\n可以证明无法创建少于三行且符合题目要求的二维数组。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>[[4,3,2,1]]\n<strong>解释：</strong>nums 中的所有元素都不同，所以我们可以将其全部保存在二维数组中的第一行。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2611.老鼠和奶酪",
        "hardRate": "MEDIUM",
        "passRate": "58.65%",
        "problemsUrl": "https://leetcode.cn/problems/mice-and-cheese/",
        "solutionsUrl": "https://leetcode.cn/problems/mice-and-cheese/solution",
        "problemsDesc": "<p>有两只老鼠和&nbsp;<code>n</code>&nbsp;块不同类型的奶酪，每块奶酪都只能被其中一只老鼠吃掉。</p>\n\n<p>下标为 <code>i</code>&nbsp;处的奶酪被吃掉的得分为：</p>\n\n<ul>\n\t<li>如果第一只老鼠吃掉，则得分为&nbsp;<code>reward1[i]</code>&nbsp;。</li>\n\t<li>如果第二只老鼠吃掉，则得分为&nbsp;<code>reward2[i]</code>&nbsp;。</li>\n</ul>\n\n<p>给你一个正整数数组&nbsp;<code>reward1</code>&nbsp;，一个正整数数组&nbsp;<code>reward2</code>&nbsp;，和一个非负整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>请你返回第一只老鼠恰好吃掉 <code>k</code>&nbsp;块奶酪的情况下，<strong>最大</strong>&nbsp;得分为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2\n<b>输出：</b>15\n<b>解释：</b>这个例子中，第一只老鼠吃掉第 2&nbsp;和 3 块奶酪（下标从 0 开始），第二只老鼠吃掉第 0 和 1 块奶酪。\n总得分为 4 + 4 + 3 + 4 = 15 。\n15 是最高得分。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>reward1 = [1,1], reward2 = [1,1], k = 2\n<b>输出：</b>2\n<b>解释：</b>这个例子中，第一只老鼠吃掉第 0 和 1 块奶酪（下标从 0 开始），第二只老鼠不吃任何奶酪。\n总得分为 1 + 1 = 2 。\n2 是最高得分。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n == reward1.length == reward2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= reward1[i],&nbsp;reward2[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2612.最少翻转操作数",
        "hardRate": "HARD",
        "passRate": "20.81%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-reverse-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-reverse-operations/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;和一个在范围 <code>[0, n - 1]</code>&nbsp;以内的整数&nbsp;<code>p</code>&nbsp;，它们表示一个长度为 <code>n</code> 且下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>arr</code>&nbsp;，数组中除了下标为&nbsp;<code>p</code>&nbsp;处是 <code>1</code>&nbsp;以外，其他所有数都是 <code>0</code>&nbsp;。</p>\n\n<p>同时给你一个整数数组&nbsp;<code>banned</code>&nbsp;，它包含数组中的一些位置。<code>banned</code>&nbsp;中第&nbsp;<strong>i</strong>&nbsp;个位置表示&nbsp;<code>arr[banned[i]] = 0</code>&nbsp;，题目保证&nbsp;<code>banned[i] != p</code>&nbsp;。</p>\n\n<p>你可以对 <code>arr</code>&nbsp;进行 <strong>若干次</strong>&nbsp;操作。一次操作中，你选择大小为 <code>k</code>&nbsp;的一个 <strong>子数组</strong>&nbsp;，并将它 <b>翻转</b>&nbsp;。在任何一次翻转操作后，你都需要确保 <code>arr</code>&nbsp;中唯一的 <code>1</code>&nbsp;不会到达任何 <code>banned</code>&nbsp;中的位置。换句话说，<code>arr[banned[i]]</code>&nbsp;始终&nbsp;<strong>保持</strong>&nbsp;<code>0</code>&nbsp;。</p>\n\n<p>请你返回一个数组&nbsp;<code>ans</code>&nbsp;，对于<em>&nbsp;</em><code>[0, n - 1]</code>&nbsp;之间的任意下标&nbsp;<code>i</code>&nbsp;，<code>ans[i]</code>&nbsp;是将&nbsp;<code>1</code>&nbsp;放到位置&nbsp;<code>i</code>&nbsp;处的&nbsp;<strong>最少</strong>&nbsp;翻转操作次数，如果无法放到位置&nbsp;<code>i</code>&nbsp;处，此数为&nbsp;<code>-1</code>&nbsp;。</p>\n\n<ul>\n\t<li><strong>子数组</strong>&nbsp;指的是一个数组里一段连续 <strong>非空</strong>&nbsp;的元素序列。</li>\n\t<li>对于所有的 <code>i</code>&nbsp;，<code>ans[i]</code>&nbsp;相互之间独立计算。</li>\n\t<li>将一个数组中的元素 <strong>翻转</strong> 指的是将数组中的值变成 <strong>相反顺序</strong>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 4, p = 0, banned = [1,2], k = 4\n<b>输出：</b>[0,-1,-1,1]\n<b>解释：</b><code>k = 4，所以只有一种可行的翻转操作，就是将整个数组翻转。一开始 </code>1<strong> </strong>在位置 0 处，所以将它翻转到位置 0 处需要的操作数为 0 。\n我们不能将 1 翻转到 banned 中的位置，所以位置 1 和 2 处的答案都是 -1 。\n通过一次翻转操作，可以将 1 放到位置 3 处，所以位置 3 的答案是 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5, p = 0, banned = [2,4], k = 3\n<b>输出：</b>[0,-1,-1,-1,-1]\n<b>解释：</b>这个例子中 1 一开始在位置 0 处，所以此下标的答案为 0 。\n翻转的子数组长度为 k = 3 ，1 此时在位置 0 处，所以我们可以翻转子数组 [0, 2]，但翻转后的下标 2 在 banned 中，所以不能执行此操作。\n由于 1 没法离开位置 0 ，所以其他位置的答案都是 -1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 4, p = 2, banned = [0,1,3], k = 1\n<b>输出：</b>[-1,-1,0,-1]\n<b>解释：</b>这个例子中，我们只能对长度为 1 的子数组执行翻转操作，所以 1 无法离开初始位置。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= p &lt;= n - 1</code></li>\n\t<li><code>0 &lt;= banned.length &lt;= n - 1</code></li>\n\t<li><code>0 &lt;= banned[i] &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= k &lt;= n&nbsp;</code></li>\n\t<li><code>banned[i] != p</code></li>\n\t<li><code>banned</code>&nbsp;中的值 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2613.美数对",
        "hardRate": "HARD",
        "passRate": "48.55%",
        "problemsUrl": "https://leetcode.cn/problems/beautiful-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/beautiful-pairs/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2614.对角线上的质数",
        "hardRate": "EASY",
        "passRate": "33.01%",
        "problemsUrl": "https://leetcode.cn/problems/prime-in-diagonal/",
        "solutionsUrl": "https://leetcode.cn/problems/prime-in-diagonal/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>nums</code> 。</p>\n\n<p>返回位于 <code>nums</code> 至少一条 <strong>对角线</strong> 上的最大 <strong>质数</strong> 。如果任一对角线上均不存在质数，返回<em> 0 。</em></p>\n\n<p>注意：</p>\n\n<ul>\n\t<li>如果某个整数大于 <code>1</code> ，且不存在除 <code>1</code> 和自身之外的正整数因子，则认为该整数是一个质数。</li>\n\t<li>如果存在整数 <code>i</code> ，使得&nbsp;<code>nums[i][i] = val</code> 或者&nbsp;<code>nums[i][nums.length - i - 1]= val</code> ，则认为整数 <code>val</code> 位于 <code>nums</code> 的一条对角线上。</li>\n</ul>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/03/06/screenshot-2023-03-06-at-45648-pm.png\" style=\"width: 181px; height: 121px;\" /></p>\n\n<p>在上图中，一条对角线是 <strong>[1,5,9]</strong> ，而另一条对角线是<strong> [3,5,7]</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[1,2,3],[5,6,7],[9,10,11]]\n<strong>输出：</strong>11\n<strong>解释：</strong>数字 1、3、6、9 和 11 是所有 \"位于至少一条对角线上\" 的数字。由于 11 是最大的质数，故返回 11 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[1,2,3],[5,17,7],[9,11,10]]\n<strong>输出：</strong>17\n<strong>解释：</strong>数字 1、3、9、10 和 17 是所有满足\"位于至少一条对角线上\"的数字。由于 17 是最大的质数，故返回 17 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 300</code></li>\n\t<li><code>nums.length == nums<sub>i</sub>.length</code></li>\n\t<li><code>1 &lt;= nums<span style=\"\">[i][j]</span>&nbsp;&lt;= 4*10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2615.等值距离和",
        "hardRate": "MEDIUM",
        "passRate": "35.54%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-distances/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-distances/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。现有一个长度等于 <code>nums.length</code> 的数组 <code>arr</code> 。对于满足 <code>nums[j] == nums[i]</code> 且 <code>j != i</code> 的所有 <code>j</code> ，<code>arr[i]</code> 等于所有 <code>|i - j|</code> 之和。如果不存在这样的 <code>j</code> ，则令 <code>arr[i]</code> 等于 <code>0</code> 。</p>\n\n<p>返回数组<em> </em><code>arr</code><em> 。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,1,1,2]\n<strong>输出：</strong>[5,0,3,4,0]\n<strong>解释：</strong>\ni = 0 ，nums[0] == nums[2] 且 nums[0] == nums[3] 。因此，arr[0] = |0 - 2| + |0 - 3| = 5 。 \ni = 1 ，arr[1] = 0 因为不存在值等于 3 的其他下标。\ni = 2 ，nums[2] == nums[0] 且 nums[2] == nums[3] 。因此，arr[2] = |2 - 0| + |2 - 3| = 3 。\ni = 3 ，nums[3] == nums[0] 且 nums[3] == nums[2] 。因此，arr[3] = |3 - 0| + |3 - 2| = 4 。 \ni = 4 ，arr[4] = 0 因为不存在值等于 2 的其他下标。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,5,3]\n<strong>输出：</strong>[0,0,0]\n<strong>解释：</strong>因为 nums 中的元素互不相同，对于所有 i ，都有 arr[i] = 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2616.最小化数对的最大差值",
        "hardRate": "MEDIUM",
        "passRate": "39.02%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>p</code>&nbsp;。请你从&nbsp;<code>nums</code>&nbsp;中找到&nbsp;<code>p</code> 个下标对，每个下标对对应数值取差值，你需要使得这 <code>p</code> 个差值的&nbsp;<strong>最大值</strong>&nbsp;<strong>最小</strong>。同时，你需要确保每个下标在这&nbsp;<code>p</code>&nbsp;个下标对中最多出现一次。</p>\n\n<p>对于一个下标对&nbsp;<code>i</code>&nbsp;和&nbsp;<code>j</code>&nbsp;，这一对的差值为&nbsp;<code>|nums[i] - nums[j]|</code>&nbsp;，其中&nbsp;<code>|x|</code>&nbsp;表示 <code>x</code>&nbsp;的 <strong>绝对值</strong>&nbsp;。</p>\n\n<p>请你返回 <code>p</code>&nbsp;个下标对对应数值 <strong>最大差值</strong>&nbsp;的 <strong>最小值</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [10,1,2,7,1,3], p = 2\n<b>输出：</b>1\n<b>解释：</b>第一个下标对选择 1 和 4 ，第二个下标对选择 2 和 5 。\n最大差值为 max(|nums[1] - nums[4]|, |nums[2] - nums[5]|) = max(0, 1) = 1 。所以我们返回 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [4,2,1,2], p = 1\n<b>输出：</b>0\n<b>解释：</b>选择下标 1 和 3 构成下标对。差值为 |2 - 2| = 0 ，这是最大差值的最小值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= p &lt;= (nums.length)/2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2617.网格图中最少访问的格子数",
        "hardRate": "HARD",
        "passRate": "32.48%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;整数矩阵&nbsp;<code>grid</code>&nbsp;。你一开始的位置在&nbsp;<strong>左上角</strong>&nbsp;格子&nbsp;<code>(0, 0)</code>&nbsp;。</p>\n\n<p>当你在格子&nbsp;<code>(i, j)</code>&nbsp;的时候，你可以移动到以下格子之一：</p>\n\n<ul>\n\t<li>满足 <code>j &lt; k &lt;= grid[i][j] + j</code>&nbsp;的格子&nbsp;<code>(i, k)</code>&nbsp;（向右移动），或者</li>\n\t<li>满足 <code>i &lt; k &lt;= grid[i][j] + i</code>&nbsp;的格子&nbsp;<code>(k, j)</code>&nbsp;（向下移动）。</li>\n</ul>\n\n<p>请你返回到达 <strong>右下角</strong>&nbsp;格子&nbsp;<code>(m - 1, n - 1)</code>&nbsp;需要经过的最少移动格子数，如果无法到达右下角格子，请你返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/25/ex1.png\" style=\"width: 271px; height: 171px;\"></p>\n\n<pre><b>输入：</b>grid = [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]]\n<b>输出：</b>4\n<b>解释：</b>上图展示了到达右下角格子经过的 4 个格子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/25/ex2.png\" style=\"width: 271px; height: 171px;\"></p>\n\n<pre><b>输入：</b>grid = [[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]]\n<b>输出：</b>3\n<strong>解释：</strong>上图展示了到达右下角格子经过的 3 个格子。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/26/ex3.png\" style=\"width: 181px; height: 81px;\"></p>\n\n<pre><b>输入：</b>grid = [[2,1,0],[1,0,0]]\n<b>输出：</b>-1\n<b>解释：</b>无法到达右下角格子。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt; m * n</code></li>\n\t<li><code>grid[m - 1][n - 1] == 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2618.检查是否是类的对象实例",
        "hardRate": "MEDIUM",
        "passRate": "34.07%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-object-instance-of-class/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-object-instance-of-class/solution",
        "problemsDesc": "<p>请你编写一个函数，检查给定的值是否是给定类或超类的实例。</p>\n\n<p>可以传递给函数的数据类型没有限制。例如，值或类可能是&nbsp; <code>undefined</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>func = () =&gt; checkIfInstance(new Date(), Date)\n<b>输出：</b>true\n<strong>解释：</strong>根据定义，Date 构造函数返回的对象是 Date 的一个实例。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>func = () =&gt; { class Animal {}; class Dog extends Animal {}; return checkIfInstance(new Dog(), Animal); }\n<b>输出：</b>true\n<strong>解释：</strong>\nclass Animal {};\nclass Dog extends Animal {};\ncheckIfInstanceOf(new Dog(), Animal); // true\n\nDog 是 Animal 的子类。因此，Dog 对象同时是 Dog 和 Animal 的实例。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>func = () =&gt; checkIfInstance(Date, Date)\n<b>输出：</b>false\n<strong>解释：</strong>日期的构造函数在逻辑上不能是其自身的实例。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>func = () =&gt; checkIfInstance(5, Number)\n<b>输出：</b>true\n<strong>解释：</strong>5 是一个 Number。注意，\"instanceof\" 关键字将返回 false。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2619.数组原型对象的最后一个元素",
        "hardRate": "EASY",
        "passRate": "71.73%",
        "problemsUrl": "https://leetcode.cn/problems/array-prototype-last/",
        "solutionsUrl": "https://leetcode.cn/problems/array-prototype-last/solution",
        "problemsDesc": "<p>请你编写一段代码实现一个数组方法，使任何数组都可以调用 <code>array.last()</code> 方法，这个方法将返回数组最后一个元素。如果数组中没有元素，则返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>你可以假设数组是 <code>JSON.parse</code> 的输出结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1 ：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [null, {}, 3]\n<b>输出：</b>3\n<b>解释</b>：调用 nums.last() 后返回最后一个元素： 3。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre>\n<b>输入：</b>nums = []\n<b>输出：</b>-1\n<strong>解释：</strong>因为此数组没有元素，所以应该返回 -1。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>0 &lt;= arr.length &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2620.计数器",
        "hardRate": "EASY",
        "passRate": "81.30%",
        "problemsUrl": "https://leetcode.cn/problems/counter/",
        "solutionsUrl": "https://leetcode.cn/problems/counter/solution",
        "problemsDesc": "<p>请你编写并返回一个&nbsp;<strong>计数器&nbsp;</strong>函数，它接收一个整型参数 n 。这个&nbsp;<strong>计数器&nbsp;</strong>函数最初返回 n，每次调用它时返回前一个值加 1 的值 ( <code>n</code> ,&nbsp; <code>n + 1</code> ,&nbsp; <code>n + 2</code> ，等等)。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>\nn = 10 \n[\"call\",\"call\",\"call\"]\n<b>输出：</b>[10,11,12]\n<strong>解释：\n</strong>counter() = 10 // 第一次调用 counter()，返回 n。\ncounter() = 11 // 返回上次调用的值加 1。\ncounter() = 12 // 返回上次调用的值加 1。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>\nn = -2\n[\"call\",\"call\",\"call\",\"call\",\"call\"]\n<b>输出：</b>[-2,-1,0,1,2]\n<b>解释：</b>counter() 最初返回 -2。然后在每个后续调用后增加 1。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-1000<sup>&nbsp;</sup>&lt;= n &lt;= 1000</code></li>\n\t<li><code>最多对 counter() 进行 1000 次调用</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2621.睡眠函数",
        "hardRate": "EASY",
        "passRate": "84.23%",
        "problemsUrl": "https://leetcode.cn/problems/sleep/",
        "solutionsUrl": "https://leetcode.cn/problems/sleep/solution",
        "problemsDesc": "<p>请你编写一个异步函数，它接收一个正整数参数 <code>millis</code>&nbsp;，并休眠这么多毫秒。要求此函数可以解析任何值。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre>\n<b>输入：</b>millis = 100\n<b>输出：</b>100\n<b>解释：</b>\n在 100ms 后此异步函数执行完时返回一个 Promise 对象\nlet t = Date.now();\nsleep(100).then(() =&gt; {\n  console.log(Date.now() - t); // 100\n});\n</pre>\n\n<p><b>示例 2：</b></p>\n\n<pre>\n<b>输入：</b>millis = 200\n<b>输出：</b>200\n<b>解释：</b>在 200ms 后函数执行完时返回一个 Promise 对象\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>1 &lt;= millis &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2622.有时间限制的缓存",
        "hardRate": "MEDIUM",
        "passRate": "55.09%",
        "problemsUrl": "https://leetcode.cn/problems/cache-with-time-limit/",
        "solutionsUrl": "https://leetcode.cn/problems/cache-with-time-limit/solution",
        "problemsDesc": "<p>编写一个类，它允许获取和设置键-值对，并且每个键都有一个&nbsp;<strong>过期时间</strong>&nbsp;。</p>\n\n<p>该类有三个公共方法：</p>\n\n<p><code>set(key, value, duration)</code>&nbsp;：接收参数为整型键 <code>key</code> 、整型值 <code>value</code> 和以毫秒为单位的持续时间 <code>duration</code> 。一旦 <code>duration</code>&nbsp;到期后，这个键就无法访问。如果相同的未过期键已经存在，该方法将返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。如果该键已经存在，则它的值和持续时间都应该被覆盖。</p>\n\n<p><code>get(key)</code>&nbsp;：如果存在一个未过期的键，它应该返回这个键相关的值。否则返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p><code>count()</code>&nbsp;：返回未过期键的总数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong> \n[\"TimeLimitedCache\", \"set\", \"get\", \"count\", \"get\"]\n[[], [1, 42, 100], [1], [], [1]]\n[0, 0, 50, 50, 150]\n<strong>输出：</strong> [null, false, 42, 1, -1]\n<strong>解释：</strong>\n在 t=0 时，缓存被构造。\n在 t=0 时，添加一个键值对 (1: 42) ，过期时间为 100ms 。因为该值不存在，因此返回false。\n在 t=50 时，请求 key=1 并返回值 42。\n在 t=50 时，调用 count() ，缓存中有一个未过期的键。\n在 t=100 时，key=1 到期。\n在 t=150 时，调用 get(1) ，返回 -1，因为缓存是空的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"TimeLimitedCache\", \"set\", \"set\", \"get\", \"get\", \"get\", \"count\"]\n[[], [1, 42, 50], [1, 50, 100], [1], [1], [1], []]\n[0, 0, 40, 50, 120, 200, 250]\n<strong>输出：</strong> [null, false, true, 50, 50, -1]\n<strong>解释：</strong>\n在 t=0 时，缓存被构造。\n在 t=0 时，添加一个键值对 (1: 42) ，过期时间为 50ms。因为该值不存在，因此返回false。\n当 t=40 时，添加一个键值对 (1: 50) ，过期时间为 100ms。因为一个未过期的键已经存在，返回 true 并覆盖这个键的旧值。\n在 t=50 时，调用 get(1) ，返回 50。\n在 t=120 时，调用 get(1) ，返回 50。\n在 t=140 时，key=1 过期。\n在 t=200 时，调用 get(1) ，但缓存为空，因此返回 -1。\n在 t=250 时，count() 返回0 ，因为缓存是空的，没有未过期的键。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= key &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= value &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= duration &lt;= 1000</code></li>\n\t<li><code>方法调用总数不会超过100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2623.记忆函数",
        "hardRate": "MEDIUM",
        "passRate": "60.40%",
        "problemsUrl": "https://leetcode.cn/problems/memoize/",
        "solutionsUrl": "https://leetcode.cn/problems/memoize/solution",
        "problemsDesc": "<p>请你编写一个函数，它接收另一个函数作为输入，并返回该函数的 <strong>记忆化</strong> 后的结果。</p>\n\n<p><strong>记忆函数</strong> 是一个对于相同的输入永远不会被调用两次的函数。相反，它将返回一个缓存值。</p>\n\n<p>你可以假设有 <strong>3</strong> 个可能的输入函数：<code>sum</code> 、<code>fib</code> 和 <code>factorial</code> 。</p>\n\n<ul>\n\t<li>&nbsp;<code>sum</code> 接收两个整型参数 <code>a</code> 和 <code>b</code> ，并返回 <code>a + b</code> 。</li>\n\t<li>&nbsp;<code>fib</code> 接收一个整型参数&nbsp;<code>n</code> ，如果 <code>n &lt;= 1</code> 则返回 <code>1</code>，否则返回 <code>fib (n - 1) + fib (n - 2)</code>。</li>\n\t<li>&nbsp;<code>factorial</code> 接收一个整型参数 <code>n</code> ，如果 <code>n &lt;= 1</code> 则返回&nbsp;&nbsp;<code>1</code>&nbsp;，否则返回 <code>factorial(n - 1) * n</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n\"sum\"\n[\"call\",\"call\",\"getCallCount\",\"call\",\"getCallCount\"]\n[[2,2],[2,2],[],[1,2],[]]\n<strong>输出：</strong>\n[4,4,1,3,2]\n\n<strong>解释：</strong>\nconst sum = (a, b) =&gt; a + b;\nconst memoizedSum = memoize(sum);\nmemoizedSum (2, 2);// 返回 4。sum() 被调用，因为之前没有使用参数 (2, 2) 调用过。\nmemoizedSum (2, 2);// 返回 4。没有调用 sum()，因为前面有相同的输入。\n//总调用数： 1\nmemoizedSum(1、2);// 返回 3。sum() 被调用，因为之前没有使用参数 (1, 2) 调用过。\n//总调用数： 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：\n</strong>\"factorial\"\n[\"call\",\"call\",\"call\",\"getCallCount\",\"call\",\"getCallCount\"]\n[[2],[3],[2],[],[3],[]]\n<strong>输出：</strong>\n[2,6,2,2,6,2]\n\n<strong>解释：</strong>\nconst factorial = (n) =&gt; (n &lt;= 1) ? 1 : (n * factorial(n - 1));\nconst memoFactorial = memoize(factorial);\nmemoFactorial(2); // 返回 2。\nmemoFactorial(3); // 返回 6。\nmemoFactorial(2); // 返回 2。 没有调用 factorial()，因为前面有相同的输入。\n// 总调用数：2\nmemoFactorial(3); // 返回 6。 没有调用 factorial()，因为前面有相同的输入。\n// 总调用数：2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：\n</strong>\"fib\"\n[\"call\",\"getCallCount\"]\n[[5],[]]\n<strong>输出：</strong>\n[8,1]\n\n<strong>解释：\n</strong>fib(5) = 8\n// 总调用数：1\n\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= a, b &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= n &lt;= 10</code></li>\n\t<li><code>at most 10<sup>5</sup>&nbsp;function calls</code></li>\n\t<li><code>at most 10<sup>5</sup>&nbsp;attempts to access callCount</code></li>\n\t<li><code>input function is sum, fib, or factorial</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2624.蜗牛排序",
        "hardRate": "MEDIUM",
        "passRate": "63.21%",
        "problemsUrl": "https://leetcode.cn/problems/snail-traversal/",
        "solutionsUrl": "https://leetcode.cn/problems/snail-traversal/solution",
        "problemsDesc": "<p>请你编写一段代码为所有数组实现&nbsp;&nbsp;<code>snail(rowsCount，colsCount)</code> 方法，该方法将 1D 数组转换为以蜗牛排序的模式的 2D 数组。无效的输入值应该输出一个空数组。当 <code>rowsCount * colsCount&nbsp;!==</code><code>nums.length</code>&nbsp;时。这个输入被认为是无效的。</p>\n\n<p>蜗牛排序从左上角的单元格开始，从当前数组的第一个值开始。然后，它从上到下遍历第一列，接着移动到右边的下一列，并从下到上遍历它。将这种模式持续下去，每列交替变换遍历方向，直到覆盖整个数组。例如，当给定输入数组&nbsp;&nbsp;<code>[19, 10, 3, 7, 9, 8, 5, 2, 1, 17, 16, 14, 12, 18, 6, 13, 11, 20, 4, 15]</code> ，当 <code>rowsCount = 5</code>&nbsp;且&nbsp;<code>colsCount = 4</code> 时，需要输出矩阵如下图所示。注意，矩阵沿箭头方向对应于原数组中数字的顺序</p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"Traversal Diagram\" src=\"https://assets.leetcode.com/uploads/2023/04/10/screen-shot-2023-04-10-at-100006-pm.png\" style=\"width: 275px; height: 343px;\" /></p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre>\n<b>输入：</b>\nnums = [19, 10, 3, 7, 9, 8, 5, 2, 1, 17, 16, 14, 12, 18, 6, 13, 11, 20, 4, 15]\nrowsCount = 5\ncolsCount = 4\n<b>输出：</b>\n[\n [19,17,16,15],\n&nbsp;[10,1,14,4],\n&nbsp;[3,2,12,20],\n&nbsp;[7,5,18,11],\n&nbsp;[9,8,6,13]\n]\n</pre>\n\n<p><b>示例 2：</b></p>\n\n<pre>\n<b>输入：</b>\nnums = [1,2,3,4]\nrowsCount = 1\ncolsCount = 4\n<b>输出：</b>[[1, 2, 3, 4]]\n</pre>\n\n<p><b>示例 3：</b></p>\n\n<pre>\n<b>输入：</b>\nnums = [1,3]\nrowsCount = 2\ncolsCount = 2\n<b>输出：</b>[]\n<strong>Explanation:</strong> 2 * 2 = 4, 且原数组 [1,3] 的长度为 2; 所以，输入是无效的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 250</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= rowsCount &lt;= 250</code></li>\n\t<li><code>1 &lt;= colsCount &lt;= 250</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2625.扁平化嵌套数组",
        "hardRate": "MEDIUM",
        "passRate": "50.17%",
        "problemsUrl": "https://leetcode.cn/problems/flatten-deeply-nested-array/",
        "solutionsUrl": "https://leetcode.cn/problems/flatten-deeply-nested-array/solution",
        "problemsDesc": "<p>请你编写一个函数，它接收一个&nbsp;<strong>多维数组&nbsp;</strong><code>arr</code> 和它的深度 <code>n</code> ，并返回该数组的&nbsp;<strong>扁平化&nbsp;</strong>后的结果。</p>\n\n<p><strong>多维数组&nbsp;</strong>是一种包含整数或其他&nbsp;<strong>多维数组&nbsp;</strong>的递归数据结构。</p>\n\n<p>数组 <strong>扁平化</strong> 是对数组的一种操作，定义是将原数组部分或全部子数组删除，并替换为该子数组中的实际元素。只有当嵌套的数组深度大于 <code>n</code> 时，才应该执行扁平化操作。第一层数组中元素的深度被认为是 0。</p>\n\n<p>请在没有使用内置方法&nbsp;<code>Array.flat</code> 的前提下解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\narr = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]\nn = 0\n<strong>输出</strong>\n[1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]\n\n<strong>解释</strong>\n传递深度 n=0 的多维数组将始终得到原始数组。这是因为 子数组(0) 的最小可能的深度不小于 n=0 。因此，任何子数组都不应该被平面化。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入</strong>\narr = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]\nn = 1\n<strong>输出</strong>\n[1, 2, 3, 4, 5, 6, 7, 8, [9, 10, 11], 12, 13, 14, 15]\n\n<strong>解释</strong>\n以 4 、7 和 13 开头的子数组都被扁平化了，这是因为它们的深度为 0 ， 而 0 小于 1 。然而 [9,10,11] 其深度为 1 ，所以未被扁平化。</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入</strong>\narr = [[1, 2, 3], [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]\nn = 2\n<strong>输出</strong>\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n\n<strong>解释</strong>\n所有子数组的最大深度都为 1 。因此，它们都被扁平化了。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= arr 的元素个数&nbsp;&lt;=&nbsp;10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= arr 的子数组个数&nbsp;&lt;=&nbsp;10<sup>5</sup></code></li>\n\t<li><code>maxDepth &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= each number &lt;= 1000</code></li>\n\t<li><code><font face=\"monospace\">0 &lt;= n &lt;= 1000</font></code></li>\n</ul>\n",
        "isPlus": false
    }
]