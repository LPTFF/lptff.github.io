[
    {
        "problemsName": " 3076.最小高度树",
        "hardRate": "EASY",
        "passRate": "78.90%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-height-tree-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-height-tree-lcci/solution",
        "problemsDesc": "<p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。</p><strong>示例:</strong><pre>给定有序数组: [-10,-3,0,5,9],<br><br>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：<br><br>          0 <br>         / &#92 <br>       -3   9 <br>       /   / <br>     -10  5 <br></pre>",
        "isPlus": false
    },
    {
        "problemsName": " 3077.特定深度节点链表",
        "hardRate": "MEDIUM",
        "passRate": "80.72%",
        "problemsUrl": "https://leetcode.cn/problems/list-of-depth-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/list-of-depth-lcci/solution",
        "problemsDesc": "<p>给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 <code>D</code>，则会创建出 <code>D</code> 个链表）。返回一个包含所有深度的链表的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>[1,2,3,4,5,null,7,8]\n\n        1\n       /  \\ \n      2    3\n     / \\    \\ \n    4   5    7\n   /\n  8\n\n<strong>输出：</strong>[[1],[2,3],[4,5,7],[8]]\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3078.检查平衡性",
        "hardRate": "EASY",
        "passRate": "59.75%",
        "problemsUrl": "https://leetcode.cn/problems/check-balance-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/check-balance-lcci/solution",
        "problemsDesc": "<p>实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。</p><br><strong>示例 1:</strong><pre>给定二叉树 [3,9,20,null,null,15,7]<br>    3<br>   / &#92<br>  9  20<br>    /  &#92<br>   15   7<br>返回 true 。</pre><strong>示例 2:</strong><br><pre>给定二叉树 [1,2,2,3,3,null,null,4,4]<br>      1<br>     / &#92<br>    2   2<br>   / &#92<br>  3   3<br> / &#92<br>4   4<br>返回 false 。</pre>",
        "isPlus": false
    },
    {
        "problemsName": " 3079.合法二叉搜索树",
        "hardRate": "MEDIUM",
        "passRate": "35.71%",
        "problemsUrl": "https://leetcode.cn/problems/legal-binary-search-tree-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/legal-binary-search-tree-lcci/solution",
        "problemsDesc": "<p>实现一个函数，检查一棵二叉树是否为二叉搜索树。</p><strong>示例 1:</strong><pre><strong>输入:</strong><br>    2<br>   / &#92<br>  1   3<br><strong>输出:</strong> true<br></pre><strong>示例 2:</strong><pre><strong>输入:</strong><br>    5<br>   / &#92<br>  1   4<br>     / &#92<br>    3   6<br><strong>输出:</strong> false<br><strong>解释:</strong> 输入为: [5,1,4,null,null,3,6]。<br>     根节点的值为 5 ，但是其右子节点值为 4 。</pre>",
        "isPlus": false
    },
    {
        "problemsName": " 3080.后继者",
        "hardRate": "MEDIUM",
        "passRate": "62.56%",
        "problemsUrl": "https://leetcode.cn/problems/successor-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/successor-lcci/solution",
        "problemsDesc": "<p>设计一个算法，找出二叉搜索树中指定节点的&ldquo;下一个&rdquo;节点（也即中序后继）。</p>\n\n<p>如果指定节点没有对应的&ldquo;下一个&rdquo;节点，则返回<code>null</code>。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> root = <code>[2,1,3], p = 1\n\n  2\n / \\\n1   3\n</code>\n<strong>输出:</strong> 2</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> root = <code>[5,3,6,2,4,null,null,1], p = 6\n\n      5\n     / \\\n    3   6\n   / \\\n  2   4\n /   \n1\n</code>\n<strong>输出:</strong> null</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3081.首个共同祖先",
        "hardRate": "MEDIUM",
        "passRate": "71.57%",
        "problemsUrl": "https://leetcode.cn/problems/first-common-ancestor-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/first-common-ancestor-lcci/solution",
        "problemsDesc": "<p>设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。</p>\n\n<p>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]</p>\n\n<pre>    3\n   / \\\n  5   1\n / \\ / \\\n6  2 0  8\n  / \\\n 7   4\n</pre>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n<strong>输出:</strong> 3\n<strong>解释:</strong> 节点 5 和节点 1 的最近公共祖先是节点 3。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n<strong>输出:</strong> 5\n<strong>解释:</strong> 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</pre>\n\n<p><strong>说明:</strong></p>\n\n<pre>所有节点的值都是唯一的。\np、q 为不同节点且均存在于给定的二叉树中。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3082.二叉搜索树序列",
        "hardRate": "HARD",
        "passRate": "48.87%",
        "problemsUrl": "https://leetcode.cn/problems/bst-sequences-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/bst-sequences-lcci/solution",
        "problemsDesc": "<p>从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。</p>\n\n<p>给定一个由<strong>不同节点</strong>组成的二叉搜索树 <code>root</code>，输出所有可能生成此树的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>root = [2,1,3]\n<strong>输出: </strong>[[2,1,3],[2,3,1]]\n解释: 数组 [2,1,3]、[2,3,1] 均可以通过从左向右遍历元素插入树中形成以下二叉搜索树\n&nbsp;      2 \n&nbsp;     / \\ \n&nbsp;    1   3\n</pre>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<p><strong>示例</strong><strong>&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入: </strong>root = [4,1,null,null,3,2]\n<strong>输出: </strong>[[4,1,3,2]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉搜索树中的节点数在<meta charset=\"UTF-8\" />&nbsp;<code>[0, 1000]</code>&nbsp;的范围内</li>\n\t<li><code>1 &lt;= 节点值&nbsp;&lt;= 10^6</code></li>\n\t<li>\n\t<p>用例保证符合要求的数组数量不超过 <code>5000</code></p>\n\t</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3083.检查子树",
        "hardRate": "MEDIUM",
        "passRate": "67.38%",
        "problemsUrl": "https://leetcode.cn/problems/check-subtree-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/check-subtree-lcci/solution",
        "problemsDesc": "<p>检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断 T2 是否为 T1 的子树。</p>\n\n<p>如果 T1 有这么一个节点 n，其子树与 T2 一模一样，则 T2 为 T1 的子树，也就是说，从节点 n 处把树砍断，得到的树与 T2 完全相同。</p>\n\n<p><strong>注意：</strong>此题相对书上原题略有改动。</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>：t1 = [1, 2, 3], t2 = [2]\n<strong> 输出</strong>：true\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>：t1 = [1, null, 2, 4], t2 = [3, 2]\n<strong> 输出</strong>：false\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>树的节点数目范围为[0, 20000]。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3084.求和路径",
        "hardRate": "MEDIUM",
        "passRate": "49.00%",
        "problemsUrl": "https://leetcode.cn/problems/paths-with-sum-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/paths-with-sum-lcci/solution",
        "problemsDesc": "<p>给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。</p>\n\n<p><strong>示例:</strong><br>\n给定如下二叉树，以及目标和&nbsp;<code>sum = 22</code>，</p>\n\n<pre>              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\    / \\\n        7    2  5   1\n</pre>\n\n<p>返回:</p>\n\n<pre>3\n<strong>解释：</strong>和为 22&nbsp;的路径有：[5,4,11,2], [5,8,4,5], [4,11,7]</pre>\n\n<p>提示：</p>\n\n<ul>\n\t<li><code>节点总数 &lt;= 10000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3085.插入",
        "hardRate": "EASY",
        "passRate": "51.45%",
        "problemsUrl": "https://leetcode.cn/problems/insert-into-bits-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/insert-into-bits-lcci/solution",
        "problemsDesc": "<p>给定两个整型数字 <code>N</code> 与 <code>M</code>，以及表示比特位置的 <code>i</code> 与 <code>j</code>（<code>i <= j</code>，且从 0 位开始计算）。</p>\n\n<p>编写一种方法，使 <code>M</code> 对应的二进制数字插入 <code>N</code> 对应的二进制数字的第 <code>i ~ j</code> 位区域，不足之处用 <code>0</code> 补齐。具体插入过程如图所示。</p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1610104070-NuLVQi-05.01.gif\" style=\"width: 267px; height: 200px;\" /></p>\n\n<p>题目保证从 <code>i</code> 位到 <code>j</code> 位足以容纳 <code>M</code>， 例如： <code>M = 10011</code>，则 <code>i～j</code> 区域至少可容纳 5 位。</p>\n\n<p> </p>\n\n<p><strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>：N = 1024(10000000000), M = 19(10011), i = 2, j = 6\n<strong> 输出</strong>：N = 1100(10001001100)\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>： N = 0, M = 31(11111), i = 0, j = 4\n<strong> 输出</strong>：N = 31(11111)\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3086.二进制数转字符串",
        "hardRate": "MEDIUM",
        "passRate": "76.84%",
        "problemsUrl": "https://leetcode.cn/problems/binary-number-to-string-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-number-to-string-lcci/solution",
        "problemsDesc": "<p>二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字无法精确地用32位以内的二进制表示，则打印“ERROR”。</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>：0.625\n<strong> 输出</strong>：\"0.101\"\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>：0.1\n<strong> 输出</strong>：\"ERROR\"\n<strong> 提示</strong>：0.1无法被二进制准确表示\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>32位包括输出中的 <code>\"0.\"</code> 这两位。</li>\n\t<li>题目保证输入用例的小数位数最多只有 <code>6</code> 位</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3087.翻转数位",
        "hardRate": "EASY",
        "passRate": "37.64%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-bits-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-bits-lcci/solution",
        "problemsDesc": "<p>给定一个32位整数 <code>num</code>，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入:</strong> <code>num</code> = 1775(11011101111<sub>2</sub>)\n<strong>输出:</strong> 8\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入:</strong> <code>num</code> = 7(0111<sub>2</sub>)\n<strong>输出:</strong> 4\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3088.下一个数",
        "hardRate": "MEDIUM",
        "passRate": "35.62%",
        "problemsUrl": "https://leetcode.cn/problems/closed-number-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/closed-number-lcci/solution",
        "problemsDesc": "<p>下一个数。给定一个正整数，找出与其二进制表达式中1的个数相同且大小最接近的那两个数（一个略大，一个略小）。</p>\n\n<p> <strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>：num = 2（或者0b10）\n<strong> 输出</strong>：[4, 1] 或者（[0b100, 0b1]）\n</pre>\n\n<p> <strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>：num = 1\n<strong> 输出</strong>：[2, -1]\n</pre>\n\n<p> <strong>提示:</strong></p>\n\n<ol>\n<li><code>num</code>的范围在[1, 2147483647]之间；</li>\n<li>如果找不到前一个或者后一个满足条件的正数，那么输出 -1。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3089.整数转换",
        "hardRate": "EASY",
        "passRate": "51.61%",
        "problemsUrl": "https://leetcode.cn/problems/convert-integer-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-integer-lcci/solution",
        "problemsDesc": "<p>整数转换。编写一个函数，确定需要改变几个位才能将整数A转成整数B。</p>\n\n<p> <strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>：A = 29 （或者0b11101）, B = 15（或者0b01111）\n<strong> 输出</strong>：2\n</pre>\n\n<p> <strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>：A = 1，B = 2\n<strong> 输出</strong>：2\n</pre>\n\n<p> <strong>提示:</strong></p>\n\n<ol>\n<li>A，B范围在[-2147483648, 2147483647]之间</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3090.配对交换",
        "hardRate": "EASY",
        "passRate": "70.97%",
        "problemsUrl": "https://leetcode.cn/problems/exchange-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/exchange-lcci/solution",
        "problemsDesc": "<p>配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0与位1交换，位2与位3交换，以此类推）。</p>\n\n<p> <strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>：num = 2（或者0b10）\n<strong> 输出</strong> 1 (或者 0b01)\n</pre>\n\n<p> <strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>：num = 3\n<strong> 输出</strong>：3\n</pre>\n\n<p> <strong>提示:</strong></p>\n\n<ol>\n<li><code>num</code>的范围在[0, 2^30 - 1]之间，不会发生整数溢出。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3091.绘制直线",
        "hardRate": "MEDIUM",
        "passRate": "53.73%",
        "problemsUrl": "https://leetcode.cn/problems/draw-line-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/draw-line-lcci/solution",
        "problemsDesc": "<p>已知一个由像素点组成的单色屏幕，每行均有 <code>w</code> 个像素点，所有像素点初始为 <code>0</code>，左上角位置为 <code>(0,0)</code>。</p>\n\n<p>现将每行的像素点按照「每 <code>32</code> 个像素点」为一组存放在一个 <code>int</code> 中，再依次存入长度为 <code>length</code> 的一维数组中。</p>\n\n<p>我们将在屏幕上绘制一条从点 <code>(x1,y)</code> 到点 <code>(x2,y)</code> 的直线（即像素点修改为 <code>1</code>），请返回绘制过后的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>用例保证屏幕宽度 <code>w</code> 可被 32 整除（即一个 <code>int</code> 不会分布在两行上）</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>：length = 1, w = 32, x1 = 30, x2 = 31, y = 0\n<strong> 输出</strong>：[3]\n<strong> 解释</strong>：在第 0 行的第 30 位到第 31 位画一条直线，屏幕二进制形式表示为 [00000000000000000000000000000011]，因此返回 [3]\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>：length = 3, w = 96, x1 = 0, x2 = 95, y = 0\n<strong> 输出</strong>：[-1, -1, -1]\n<strong> 解释</strong>：由于二进制 <strong>11111111111111111111111111111111</strong> 的 int 类型代表 -1，因此返回 [-1,-1,-1]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= w &lt;= 3 * 10^5</code></li>\n\t<li><code>0 &lt;= x1 &lt;= x2 &lt; w</code></li>\n\t<li><code>0 &lt;= y &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3092.三步问题",
        "hardRate": "EASY",
        "passRate": "36.65%",
        "problemsUrl": "https://leetcode.cn/problems/three-steps-problem-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/three-steps-problem-lcci/solution",
        "problemsDesc": "<p>三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。</p>\n\n<p> <strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>：n = 3 \n<strong> 输出</strong>：4\n<strong> 说明</strong>: 有四种走法\n</pre>\n\n<p> <strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>：n = 5\n<strong> 输出</strong>：13\n</pre>\n\n<p> <strong>提示:</strong></p>\n\n<ol>\n<li>n范围在[1, 1000000]之间</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3093.迷路的机器人",
        "hardRate": "MEDIUM",
        "passRate": "36.17%",
        "problemsUrl": "https://leetcode.cn/problems/robot-in-a-grid-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/robot-in-a-grid-lcci/solution",
        "problemsDesc": "<p>设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。</p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png\" style=\"height: 183px; width: 400px;\"></p>\n\n<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>\n\n<p>返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。如果没有可行的路径，返回空数组。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入:\n</strong>[\n&nbsp; [<strong>0</strong>,<strong>0</strong>,<strong>0</strong>],\n&nbsp; [0,1,<strong>0</strong>],\n&nbsp; [0,0,<strong>0</strong>]\n]\n<strong>输出:</strong> [[0,0],[0,1],[0,2],[1,2],[2,2]]\n<strong>解释: \n</strong>输入中标粗的位置即为输出表示的路径，即\n0行0列（左上角） -&gt; 0行1列 -&gt; 0行2列 -&gt; 1行2列 -&gt; 2行2列（右下角）</pre>\n\n<p><strong>说明：</strong><em>r</em>&nbsp;和 <em>c </em>的值均不超过 100。</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3094.魔术索引",
        "hardRate": "EASY",
        "passRate": "67.39%",
        "problemsUrl": "https://leetcode.cn/problems/magic-index-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/magic-index-lcci/solution",
        "problemsDesc": "<p>魔术索引。 在数组<code>A[0...n-1]</code>中，有所谓的魔术索引，满足条件<code>A[i] = i</code>。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre><strong> 输入</strong>：nums = [0, 2, 3, 4, 5]\n<strong> 输出</strong>：0\n<strong> 说明</strong>: 0下标的元素为0\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre><strong> 输入</strong>：nums = [1, 1, 1]\n<strong> 输出</strong>：1\n</pre>\n\n<p><strong>说明:</strong></p>\n\n<ol>\n\t<li>nums长度在[1, 1000000]之间</li>\n\t<li>此题为原书中的 Follow-up，即数组中可能包含重复元素的版本</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3095.幂集",
        "hardRate": "MEDIUM",
        "passRate": "82.11%",
        "problemsUrl": "https://leetcode.cn/problems/power-set-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/power-set-lcci/solution",
        "problemsDesc": "<p>幂集。编写一种方法，返回某集合的所有子集。集合中<strong>不包含重复的元素</strong>。</p>\n\n<p>说明：解集不能包含重复的子集。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong> 输入</strong>： nums = [1,2,3]\n<strong> 输出</strong>：\n[\n  [3],\n&nbsp; [1],\n&nbsp; [2],\n&nbsp; [1,2,3],\n&nbsp; [1,3],\n&nbsp; [2,3],\n&nbsp; [1,2],\n&nbsp; []\n]\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3096.递归乘法",
        "hardRate": "MEDIUM",
        "passRate": "65.60%",
        "problemsUrl": "https://leetcode.cn/problems/recursive-mulitply-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/recursive-mulitply-lcci/solution",
        "problemsDesc": "<p>递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。</p>\n\n<p> <strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>：A = 1, B = 10\n<strong> 输出</strong>：10\n</pre>\n\n<p> <strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>：A = 3, B = 4\n<strong> 输出</strong>：12\n</pre>\n\n<p> <strong>提示:</strong></p>\n\n<ol>\n<li>保证乘法范围不会溢出</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3097.汉诺塔问题",
        "hardRate": "EASY",
        "passRate": "64.84%",
        "problemsUrl": "https://leetcode.cn/problems/hanota-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/hanota-lcci/solution",
        "problemsDesc": "<p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>\n(1) 每次只能移动一个盘子;<br>\n(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>\n(3) 盘子只能叠在比它大的盘子上。</p>\n\n<p>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p>\n\n<p>你需要原地修改栈。</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre><strong> 输入</strong>：A = [2, 1, 0], B = [], C = []\n<strong> 输出</strong>：C = [2, 1, 0]\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre><strong> 输入</strong>：A = [1, 0], B = [], C = []\n<strong> 输出</strong>：C = [1, 0]\n</pre>\n\n<p><strong>提示:</strong></p>\n\n<ol>\n\t<li>A中盘子的数目不大于14个。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3098.无重复字符串的排列组合",
        "hardRate": "MEDIUM",
        "passRate": "80.97%",
        "problemsUrl": "https://leetcode.cn/problems/permutation-i-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/permutation-i-lcci/solution",
        "problemsDesc": "<p>无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。</p>\n\n<p> <strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>：S = \"qwe\"\n<strong> 输出</strong>：[\"qwe\", \"qew\", \"wqe\", \"weq\", \"ewq\", \"eqw\"]\n</pre>\n\n<p> <strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>：S = \"ab\"\n<strong> 输出</strong>：[\"ab\", \"ba\"]\n</pre>\n\n<p> <strong>提示:</strong></p>\n\n<ol>\n<li>字符都是英文字母。</li>\n<li>字符串长度在[1, 9]之间。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3099.有重复字符串的排列组合",
        "hardRate": "MEDIUM",
        "passRate": "69.65%",
        "problemsUrl": "https://leetcode.cn/problems/permutation-ii-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/permutation-ii-lcci/solution",
        "problemsDesc": "<p>有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre><strong> 输入</strong>：S = &quot;qqe&quot;\n<strong> 输出</strong>：[&quot;eqq&quot;,&quot;qeq&quot;,&quot;qqe&quot;]\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre><strong> 输入</strong>：S = &quot;ab&quot;\n<strong> 输出</strong>：[&quot;ab&quot;, &quot;ba&quot;]\n</pre>\n\n<p><strong>提示:</strong></p>\n\n<ol>\n\t<li>字符都是英文字母。</li>\n\t<li>字符串长度在[1, 9]之间。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3100.括号",
        "hardRate": "MEDIUM",
        "passRate": "82.17%",
        "problemsUrl": "https://leetcode.cn/problems/bracket-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/bracket-lcci/solution",
        "problemsDesc": "<p>括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。</p>\n\n<p>说明：解集不能包含重复的子集。</p>\n\n<p>例如，给出 n = 3，生成结果为：</p>\n\n<pre>\n[\n  \"((()))\",\n  \"(()())\",\n  \"(())()\",\n  \"()(())\",\n  \"()()()\"\n]\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3101.颜色填充",
        "hardRate": "EASY",
        "passRate": "55.80%",
        "problemsUrl": "https://leetcode.cn/problems/color-fill-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/color-fill-lcci/solution",
        "problemsDesc": "<p>编写函数，实现许多图片编辑软件都支持的「颜色填充」功能。</p>\n\n<p>待填充的图像用二维数组 <code>image</code> 表示，元素为初始颜色值。初始坐标点的行坐标为 <code>sr</code> 列坐标为 <code>sc</code>。需要填充的新颜色为 <code>newColor</code> 。</p>\n\n<p>「周围区域」是指颜色相同且在上、下、左、右四个方向上存在相连情况的若干元素。</p>\n\n<p>请用新颜色填充初始坐标点的周围区域，并返回填充后的图像。</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>：\nimage = [[1,1,1],[1,1,0],[1,0,1]] \nsr = 1, sc = 1, newColor = 2\n<strong>输出</strong>：[[2,2,2],[2,2,0],[2,0,1]]\n<strong>解释</strong>: \n初始坐标点位于图像的正中间，坐标 (sr,sc)=(1,1) 。\n初始坐标点周围区域上所有符合条件的像素点的颜色都被更改成 2 。\n注意，右下角的像素没有更改为 2 ，因为它不属于初始坐标点的周围区域。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>image</code> 和 <code>image[0]</code> 的长度均在范围 [1, 50] 内。</li>\n\t<li>初始坐标点 <code>(sr,sc)</code> 满足 <code>0 <= sr < image.length</code> 和 <code>0 <= sc < image[0].length</code> 。</li>\n\t<li><code>image[i][j]</code> 和 <code>newColor</code> 表示的颜色值在范围 <code>[0, 65535]</code> 内。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3102.硬币",
        "hardRate": "MEDIUM",
        "passRate": "49.71%",
        "problemsUrl": "https://leetcode.cn/problems/coin-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/coin-lcci/solution",
        "problemsDesc": "<p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p>\n\n<p> <strong>示例1:</strong></p>\n\n<pre>\n<strong> 输入</strong>: n = 5\n<strong> 输出</strong>：2\n<strong> 解释</strong>: 有两种方式可以凑成总金额:\n5=5\n5=1+1+1+1+1\n</pre>\n\n<p> <strong>示例2:</strong></p>\n\n<pre>\n<strong> 输入</strong>: n = 10\n<strong> 输出</strong>：4\n<strong> 解释</strong>: 有四种方式可以凑成总金额:\n10=10\n10=5+5\n10=5+1+1+1+1+1\n10=1+1+1+1+1+1+1+1+1+1\n</pre>\n\n<p> <strong>说明：</strong></p>\n\n<p>注意:</p>\n\n<p>你可以假设：</p>\n\n<ul>\n<li>0 &lt;= n (总金额) &lt;= 1000000</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3103.八皇后",
        "hardRate": "HARD",
        "passRate": "76.42%",
        "problemsUrl": "https://leetcode.cn/problems/eight-queens-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/eight-queens-lcci/solution",
        "problemsDesc": "<p>设计一种算法，打印 N 皇后在 N &times; N 棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。这里的&ldquo;对角线&rdquo;指的是所有的对角线，不只是平分整个棋盘的那两条对角线。</p>\n\n<p><strong>注意：</strong>本题相对原题做了扩展</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong> 输入</strong>：4\n<strong> 输出</strong>：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]\n<strong> 解释</strong>: 4 皇后问题存在如下两个不同的解法。\n[\n&nbsp;[&quot;.Q..&quot;, &nbsp;// 解法 1\n&nbsp; &quot;...Q&quot;,\n&nbsp; &quot;Q...&quot;,\n&nbsp; &quot;..Q.&quot;],\n\n&nbsp;[&quot;..Q.&quot;, &nbsp;// 解法 2\n&nbsp; &quot;Q...&quot;,\n&nbsp; &quot;...Q&quot;,\n&nbsp; &quot;.Q..&quot;]\n]\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3104.堆箱子",
        "hardRate": "HARD",
        "passRate": "51.26%",
        "problemsUrl": "https://leetcode.cn/problems/pile-box-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/pile-box-lcci/solution",
        "problemsDesc": "<p>堆箱子。给你一堆n个箱子，箱子宽 wi、深 di、高 hi。箱子不能翻转，将箱子堆起来时，下面箱子的宽度、高度和深度必须大于上面的箱子。实现一种方法，搭出最高的一堆箱子。箱堆的高度为每个箱子高度的总和。</p>\n\n<p>输入使用数组<code>[wi, di, hi]</code>表示每个箱子。</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre><strong> 输入</strong>：box = [[1, 1, 1], [2, 2, 2], [3, 3, 3]]\n<strong> 输出</strong>：6\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre><strong> 输入</strong>：box = [[1, 1, 1], [2, 3, 4], [2, 6, 7], [3, 4, 5]]\n<strong> 输出</strong>：10\n</pre>\n\n<p><strong>提示:</strong></p>\n\n<ol>\n\t<li>箱子的数目不大于3000个。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3105.布尔运算",
        "hardRate": "MEDIUM",
        "passRate": "52.37%",
        "problemsUrl": "https://leetcode.cn/problems/boolean-evaluation-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/boolean-evaluation-lcci/solution",
        "problemsDesc": "<p>给定一个布尔表达式和一个期望的布尔结果 result，布尔表达式由 <code>0</code> (false)、<code>1</code> (true)、<code>&amp;</code> (AND)、 <code>|</code> (OR) 和 <code>^</code> (XOR) 符号组成。实现一个函数，算出有几种可使该表达式得出 result 值的括号方法。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入: </strong>s = &quot;1^0|0|1&quot;, result = 0\n\n<strong>输出: </strong>2\n<strong>解释:</strong>&nbsp;两种可能的括号方法是\n1^(0|(0|1))\n1^((0|0)|1)\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入: </strong>s = &quot;0&amp;0&amp;0&amp;1^1|0&quot;, result = 1\n\n<strong>输出: </strong>10</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>运算符的数量不超过 19 个</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3106.合并排序的数组",
        "hardRate": "EASY",
        "passRate": "56.13%",
        "problemsUrl": "https://leetcode.cn/problems/sorted-merge-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/sorted-merge-lcci/solution",
        "problemsDesc": "<p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p>\n\n<p>初始化&nbsp;A 和 B 的元素数量分别为&nbsp;<em>m</em> 和 <em>n</em>。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong>\nA = [1,2,3,0,0,0], m = 3\nB = [2,5,6],       n = 3\n\n<strong>输出:</strong>&nbsp;[1,2,2,3,5,6]</pre>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li><code>A.length == n + m</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3107.变位词组",
        "hardRate": "MEDIUM",
        "passRate": "74.31%",
        "problemsUrl": "https://leetcode.cn/problems/group-anagrams-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/group-anagrams-lcci/solution",
        "problemsDesc": "<p>编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。</p>\n\n<p><strong>注意：</strong>本题相对原题稍作修改</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> <code>[&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</code>,\n<strong>输出:</strong>\n[\n  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],\n  [&quot;nat&quot;,&quot;tan&quot;],\n  [&quot;bat&quot;]\n]</pre>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>所有输入均为小写字母。</li>\n\t<li>不考虑答案输出的顺序。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3108.搜索旋转数组",
        "hardRate": "MEDIUM",
        "passRate": "38.49%",
        "problemsUrl": "https://leetcode.cn/problems/search-rotate-array-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/search-rotate-array-lcci/solution",
        "problemsDesc": "<p>搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre><strong> 输入</strong>: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5\n<strong> 输出</strong>: 8（元素5在该数组中的索引）\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre><strong> 输入</strong>：arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 11\n<strong> 输出</strong>：-1 （没有找到）\n</pre>\n\n<p><strong>提示:</strong></p>\n\n<ol>\n\t<li>arr 长度范围在[1, 1000000]之间</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3109.稀疏数组搜索",
        "hardRate": "EASY",
        "passRate": "56.86%",
        "problemsUrl": "https://leetcode.cn/problems/sparse-array-search-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/sparse-array-search-lcci/solution",
        "problemsDesc": "<p>稀疏数组搜索。有个排好序的字符串数组，其中散布着一些空字符串，编写一种方法，找出给定字符串的位置。</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre><strong> 输入</strong>: words = [&quot;at&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;ball&quot;, &quot;&quot;, &quot;&quot;, &quot;car&quot;, &quot;&quot;, &quot;&quot;,&quot;dad&quot;, &quot;&quot;, &quot;&quot;], s = &quot;ta&quot;\n<strong> 输出</strong>：-1\n<strong> 说明</strong>: 不存在返回-1。\n</pre>\n\n<p><strong>示例2:</strong></p>\n\n<pre><strong> 输入</strong>：words = [&quot;at&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;ball&quot;, &quot;&quot;, &quot;&quot;, &quot;car&quot;, &quot;&quot;, &quot;&quot;,&quot;dad&quot;, &quot;&quot;, &quot;&quot;], s = &quot;ball&quot;\n<strong> 输出</strong>：4\n</pre>\n\n<p><strong>提示:</strong></p>\n\n<ol>\n\t<li>words的长度在[1, 1000000]之间</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3110.排序矩阵查找",
        "hardRate": "MEDIUM",
        "passRate": "44.63%",
        "problemsUrl": "https://leetcode.cn/problems/sorted-matrix-search-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/sorted-matrix-search-lcci/solution",
        "problemsDesc": "<p>给定M&times;N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。</p>\n\n<p><strong>示例:</strong></p>\n\n<p>现有矩阵 matrix 如下：</p>\n\n<pre>[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n</pre>\n\n<p>给定 target&nbsp;=&nbsp;<code>5</code>，返回&nbsp;<code>true</code>。</p>\n\n<p>给定&nbsp;target&nbsp;=&nbsp;<code>20</code>，返回&nbsp;<code>false</code>。</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3111.数字流的秩",
        "hardRate": "MEDIUM",
        "passRate": "61.97%",
        "problemsUrl": "https://leetcode.cn/problems/rank-from-stream-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/rank-from-stream-lcci/solution",
        "problemsDesc": "<p>假设你正在读取一串整数。每隔一段时间，你希望能找出数字 x 的秩(小于或等于 x 的值的个数)。请实现数据结构和算法来支持这些操作，也就是说：</p>\n\n<p>实现 <code>track(int x)</code>&nbsp;方法，每读入一个数字都会调用该方法；</p>\n\n<p>实现 <code>getRankOfNumber(int x)</code> 方法，返回小于或等于 x 的值的个数。</p>\n\n<p><strong>注意：</strong>本题相对原题稍作改动</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong>\n[&quot;StreamRank&quot;, &quot;getRankOfNumber&quot;, &quot;track&quot;, &quot;getRankOfNumber&quot;]\n[[], [1], [0], [0]]\n<strong>输出:\n</strong>[null,0,null,1]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>x &lt;= 50000</code></li>\n\t<li><code>track</code>&nbsp;和&nbsp;<code>getRankOfNumber</code> 方法的调用次数均不超过 2000 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3112.峰与谷",
        "hardRate": "MEDIUM",
        "passRate": "65.89%",
        "problemsUrl": "https://leetcode.cn/problems/peaks-and-valleys-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/peaks-and-valleys-lcci/solution",
        "problemsDesc": "<p>在一个整数数组中，&ldquo;峰&rdquo;是大于或等于相邻整数的元素，相应地，&ldquo;谷&rdquo;是小于或等于相邻整数的元素。例如，在数组{5, 8, 4, 2, 3, 4, 6}中，{8, 6}是峰， {5, 2}是谷。现在给定一个整数数组，将该数组按峰与谷的交替顺序排序。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入: </strong>[5, 3, 1, 2, 3]\n<strong>输出:</strong>&nbsp;[5, 1, 3, 2, 3]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length &lt;= 10000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3113.交换数字",
        "hardRate": "MEDIUM",
        "passRate": "81.43%",
        "problemsUrl": "https://leetcode.cn/problems/swap-numbers-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/swap-numbers-lcci/solution",
        "problemsDesc": "<p>编写一个函数，不用临时变量，直接交换<code>numbers = [a, b]</code>中<code>a</code>与<code>b</code>的值。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入:</strong> numbers = [1,2]\n<strong>输出:</strong> [2,1]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>numbers.length == 2</code></li>\n\t<li><code>-2147483647 <= numbers[i] <= 2147483647</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3114.单词频率",
        "hardRate": "MEDIUM",
        "passRate": "76.93%",
        "problemsUrl": "https://leetcode.cn/problems/words-frequency-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/words-frequency-lcci/solution",
        "problemsDesc": "<p>设计一个方法，找出任意指定单词在一本书中的出现频率。</p>\n\n<p>你的实现应该支持如下操作：</p>\n\n<ul>\n\t<li><code>WordsFrequency(book)</code>构造函数，参数为字符串数组构成的一本书</li>\n\t<li><code>get(word)</code>查询指定单词在书中出现的频率</li>\n</ul>\n\n<p><strong>示例：</strong></p>\n\n<pre>WordsFrequency wordsFrequency = new WordsFrequency({&quot;i&quot;, &quot;have&quot;, &quot;an&quot;, &quot;apple&quot;, &quot;he&quot;, &quot;have&quot;, &quot;a&quot;, &quot;pen&quot;});\nwordsFrequency.get(&quot;you&quot;); //返回0，&quot;you&quot;没有出现过\nwordsFrequency.get(&quot;have&quot;); //返回2，&quot;have&quot;出现2次\nwordsFrequency.get(&quot;an&quot;); //返回1\nwordsFrequency.get(&quot;apple&quot;); //返回1\nwordsFrequency.get(&quot;pen&quot;); //返回1\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>book[i]</code>中只包含小写字母</li>\n\t<li><code>1 &lt;= book.length &lt;= 100000</code></li>\n\t<li><code>1 &lt;= book[i].length &lt;= 10</code></li>\n\t<li><code>get</code>函数的调用次数不会超过100000</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3115.交点",
        "hardRate": "HARD",
        "passRate": "43.86%",
        "problemsUrl": "https://leetcode.cn/problems/intersection-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/intersection-lcci/solution",
        "problemsDesc": "<p>给定两条线段（表示为起点<code>start = {X1, Y1}</code>和终点<code>end = {X2, Y2}</code>），如果它们有交点，请计算其交点，没有交点则返回空值。</p>\n\n<p>要求浮点型误差不超过<code>10^-6</code>。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>\nline1 = {0, 0}, {1, 0}\nline2 = {1, 1}, {0, -1}\n<strong>输出：</strong> {0.5, 0}\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>\nline1 = {0, 0}, {3, 3}\nline2 = {1, 1}, {2, 2}\n<strong>输出：</strong> {1, 1}\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>\nline1 = {0, 0}, {1, 1}\nline2 = {1, 0}, {2, 1}\n<strong>输出：</strong> {}，两条线段没有交点\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>坐标绝对值不会超过 2^7</li>\n\t<li>输入的坐标均是有效的二维坐标</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3116.井字游戏",
        "hardRate": "MEDIUM",
        "passRate": "46.89%",
        "problemsUrl": "https://leetcode.cn/problems/tic-tac-toe-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/tic-tac-toe-lcci/solution",
        "problemsDesc": "<p>设计一个算法，判断玩家是否赢了井字游戏。输入是一个 N x N 的数组棋盘，由字符&quot; &quot;，&quot;X&quot;和&quot;O&quot;组成，其中字符&quot; &quot;代表一个空位。</p>\n\n<p>以下是井字游戏的规则：</p>\n\n<ul>\n\t<li>玩家轮流将字符放入空位（&quot; &quot;）中。</li>\n\t<li>第一个玩家总是放字符&quot;O&quot;，且第二个玩家总是放字符&quot;X&quot;。</li>\n\t<li>&quot;X&quot;和&quot;O&quot;只允许放置在空位中，不允许对已放有字符的位置进行填充。</li>\n\t<li>当有N个相同（且非空）的字符填充任何行、列或对角线时，游戏结束，对应该字符的玩家获胜。</li>\n\t<li>当所有位置非空时，也算为游戏结束。</li>\n\t<li>如果游戏结束，玩家不允许再放置字符。</li>\n</ul>\n\n<p>如果游戏存在获胜者，就返回该游戏的获胜者使用的字符（&quot;X&quot;或&quot;O&quot;）；如果游戏以平局结束，则返回 &quot;Draw&quot;；如果仍会有行动（游戏未结束），则返回 &quot;Pending&quot;。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong> board = [&quot;O X&quot;,&quot; XO&quot;,&quot;X O&quot;]\n<strong>输出：</strong> &quot;X&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong> board = [&quot;OOX&quot;,&quot;XXO&quot;,&quot;OXO&quot;]\n<strong>输出：</strong> &quot;Draw&quot;\n<strong>解释：</strong> 没有玩家获胜且不存在空位\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong> board = [&quot;OOX&quot;,&quot;XXO&quot;,&quot;OX &quot;]\n<strong>输出：</strong> &quot;Pending&quot;\n<strong>解释：</strong> 没有玩家获胜且仍存在空位\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= board.length == board[i].length &lt;= 100</code></li>\n\t<li>输入一定遵循井字棋规则</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3117.阶乘尾数",
        "hardRate": "EASY",
        "passRate": "43.71%",
        "problemsUrl": "https://leetcode.cn/problems/factorial-zeros-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/factorial-zeros-lcci/solution",
        "problemsDesc": "<p>设计一个算法，算出 n 阶乘有多少个尾随零。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> 3\n<strong>输出:</strong> 0\n<strong>解释:</strong>&nbsp;3! = 6, 尾数中没有零。</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> 5\n<strong>输出:</strong> 1\n<strong>解释:</strong>&nbsp;5! = 120, 尾数中有 1 个零.</pre>\n\n<p><strong>说明: </strong>你算法的时间复杂度应为&nbsp;<em>O</em>(log&nbsp;<em>n</em>)<em>&nbsp;</em>。</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3118.最小差",
        "hardRate": "MEDIUM",
        "passRate": "42.71%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-difference-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-difference-lcci/solution",
        "problemsDesc": "<p>给定两个整数数组<code>a</code>和<code>b</code>，计算具有最小差绝对值的一对数值（每个数组中取一个值），并返回该对数值的差</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>{1, 3, 15, 11, 2}, {23, 127, 235, 19, 8}\n<strong>输出：</strong>3，即数值对(11, 8)\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= a.length, b.length <= 100000</code></li>\n\t<li><code>-2147483648 <= a[i], b[i] <= 2147483647</code></li>\n\t<li>正确结果在区间 <code>[0, 2147483647]</code> 内</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3119.最大数值",
        "hardRate": "EASY",
        "passRate": "73.94%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-lcci/solution",
        "problemsDesc": "<p>编写一个方法，找出两个数字<code>a</code>和<code>b</code>中最大的那一个。不得使用if-else或其他比较运算符。</p>\n<p><strong>示例：</strong></p>\n<pre><strong>输入：</strong> a = 1, b = 2\n<strong>输出：</strong> 2\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3120.整数的英语表示",
        "hardRate": "HARD",
        "passRate": "39.08%",
        "problemsUrl": "https://leetcode.cn/problems/english-int-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/english-int-lcci/solution",
        "problemsDesc": "<p>给定一个整数，打印该整数的英文描述。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> 123\n<strong>输出:</strong> \"One Hundred Twenty Three\"\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> 12345\n<strong>输出:</strong> \"Twelve Thousand Three Hundred Forty Five\"</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> 1234567\n<strong>输出:</strong> \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"</pre>\n\n<p><strong>示例 4:</strong></p>\n\n<pre>\n<strong>输入:</strong> 1234567891\n<strong>输出:</strong> \"One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One\"</pre>\n\n<p>注意：本题与 273 题相同：<a href=\"https://leetcode-cn.com/problems/integer-to-english-words/\">https://leetcode-cn.com/problems/integer-to-english-words/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3121.运算",
        "hardRate": "MEDIUM",
        "passRate": "56.13%",
        "problemsUrl": "https://leetcode.cn/problems/operations-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/operations-lcci/solution",
        "problemsDesc": "<p>请实现整数数字的乘法、减法和除法运算，运算结果均为整数数字，程序中只允许使用加法运算符和逻辑运算符，允许程序中出现正负常数，不允许使用位运算。</p>\n<p>你的实现应该支持如下操作：</p>\n<ul>\n<li><code>Operations()</code> 构造函数</li>\n<li><code>minus(a, b)</code> 减法，返回<code>a - b</code></li>\n<li><code>multiply(a, b)</code> 乘法，返回<code>a * b</code></li>\n<li><code>divide(a, b)</code> 除法，返回<code>a / b</code></li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre>Operations operations = new Operations();\noperations.minus(1, 2); //返回-1\noperations.multiply(3, 4); //返回12\noperations.divide(5, -2); //返回-2\n</pre>\n<p><strong>提示：</strong></p>\n<ul>\n<li>你可以假设函数输入一定是有效的，例如不会出现除法分母为0的情况</li>\n<li>单个用例的函数调用次数不会超过1000次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3122.生存人数",
        "hardRate": "MEDIUM",
        "passRate": "66.95%",
        "problemsUrl": "https://leetcode.cn/problems/living-people-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/living-people-lcci/solution",
        "problemsDesc": "<p>给定 N 个人的出生年份和死亡年份，第 <code>i</code> 个人的出生年份为 <code>birth[i]</code>，死亡年份为 <code>death[i]</code>，实现一个方法以计算生存人数最多的年份。</p>\n\n<p>你可以假设所有人都出生于 1900 年至 2000 年（含 1900 和 2000 ）之间。如果一个人在某一年的任意时期处于生存状态，那么他应该被纳入那一年的统计中。例如，生于 1908 年、死于 1909 年的人应当被列入 1908 年和 1909 年的计数。</p>\n\n<p>如果有多个年份生存人数相同且均为最大值，输出其中最小的年份。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nbirth = [1900, 1901, 1950]\ndeath = [1948, 1951, 2000]\n<strong>输出：</strong> 1901\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt; birth.length == death.length &lt;= 10000</code></li>\n\t<li><code>birth[i] &lt;= death[i]</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3123.跳水板",
        "hardRate": "EASY",
        "passRate": "43.87%",
        "problemsUrl": "https://leetcode.cn/problems/diving-board-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/diving-board-lcci/solution",
        "problemsDesc": "<p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为<code>shorter</code>，长度较长的木板长度为<code>longer</code>。你必须正好使用<code>k</code>块木板。编写一个方法，生成跳水板所有可能的长度。</p>\n\n<p>返回的长度需要从小到大排列。</p>\n\n<p><strong>示例 1</strong></p>\n\n<pre><code><strong>输入：</strong>\nshorter = 1\nlonger = 2\nk = 3\n<strong>输出：</strong> [3,4,5,6]\n<strong>解释：</strong>\n可以使用 3 次 shorter，得到结果 3；使用 2 次 shorter 和 1 次 longer，得到结果 4 。以此类推，得到最终结果。</code></pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>0 &lt; shorter &lt;= longer</li>\n\t<li>0 &lt;= k &lt;= 100000</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3124.平分正方形",
        "hardRate": "MEDIUM",
        "passRate": "43.67%",
        "problemsUrl": "https://leetcode.cn/problems/bisect-squares-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/bisect-squares-lcci/solution",
        "problemsDesc": "<p>给定两个正方形及一个二维平面。请找出将这两个正方形分割成两半的一条直线。假设正方形顶边和底边与 x 轴平行。</p>\n\n<p>每个正方形的数据<code>square</code>包含3个数值，正方形的左下顶点坐标<code>[X,Y] = [square[0],square[1]]</code>，以及正方形的边长<code>square[2]</code>。所求直线穿过两个正方形会形成4个交点，请返回4个交点形成线段的两端点坐标（两个端点即为4个交点中距离最远的2个点，这2个点所连成的线段一定会穿过另外2个交点）。2个端点坐标<code>[X<sub>1</sub>,Y<sub>1</sub>]</code>和<code>[X<sub>2</sub>,Y<sub>2</sub>]</code>的返回格式为<code>{X<sub>1</sub>,Y<sub>1</sub>,X<sub>2</sub>,Y<sub>2</sub>}</code>，要求若<code>X<sub>1</sub> != X<sub>2</sub></code>，需保证<code>X<sub>1</sub> &lt; X<sub>2</sub></code>，否则需保证<code>Y<sub>1</sub> &lt;= Y<sub>2</sub></code>。</p>\n\n<p>若同时有多条直线满足要求，则选择斜率最大的一条计算并返回（与Y轴平行的直线视为斜率无穷大）。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>\nsquare1 = {-1, -1, 2}\nsquare2 = {0, -1, 2}\n<strong>输出：</strong> {-1,0,2,0}\n<strong>解释：</strong> 直线 y = 0 能将两个正方形同时分为等面积的两部分，返回的两线段端点为[-1,0]和[2,0]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>square.length == 3</code></li>\n\t<li><code>square[2] &gt; 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3125.最佳直线",
        "hardRate": "MEDIUM",
        "passRate": "55.57%",
        "problemsUrl": "https://leetcode.cn/problems/best-line-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/best-line-lcci/solution",
        "problemsDesc": "<p>给定一个二维平面及平面上的 N 个点列表<code>Points</code>，其中第<code>i</code>个点的坐标为<code>Points[i]=[X<sub>i</sub>,Y<sub>i</sub>]</code>。请找出一条直线，其通过的点的数目最多。</p>\n<p>设穿过最多点的直线所穿过的全部点编号从小到大排序的列表为<code>S</code>，你仅需返回<code>[S[0],S[1]]</code>作为答案，若有多条直线穿过了相同数量的点，则选择<code>S[0]</code>值较小的直线返回，<code>S[0]</code>相同则选择<code>S[1]</code>值较小的直线返回。</p>\n<p><strong>示例：</strong></p>\n<pre><strong>输入：</strong> [[0,0],[1,1],[1,0],[2,0]]\n<strong>输出：</strong> [0,2]\n<strong>解释：</strong> 所求直线穿过的3个点的编号为[0,2,3]\n</pre>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>2 <= len(Points) <= 300</code></li>\n<li><code>len(Points[i]) = 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3126.珠玑妙算",
        "hardRate": "EASY",
        "passRate": "46.37%",
        "problemsUrl": "https://leetcode.cn/problems/master-mind-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/master-mind-lcci/solution",
        "problemsDesc": "<p>珠玑妙算游戏（the game of master mind）的玩法如下。</p>\n<p>计算机有4个槽，每个槽放一个球，颜色可能是红色（R）、黄色（Y）、绿色（G）或蓝色（B）。例如，计算机可能有RGGB 4种（槽1为红色，槽2、3为绿色，槽4为蓝色）。作为用户，你试图猜出颜色组合。打个比方，你可能会猜YRGB。要是猜对某个槽的颜色，则算一次“猜中”；要是只猜对颜色但槽位猜错了，则算一次“伪猜中”。注意，“猜中”不能算入“伪猜中”。</p>\n<p>给定一种颜色组合<code>solution</code>和一个猜测<code>guess</code>，编写一个方法，返回猜中和伪猜中的次数<code>answer</code>，其中<code>answer[0]</code>为猜中的次数，<code>answer[1]</code>为伪猜中的次数。</p>\n<p><strong>示例：</strong></p>\n<pre><strong>输入：</strong> solution=\"RGBY\",guess=\"GGRR\"\n<strong>输出：</strong> [1,1]\n<strong>解释：</strong> 猜中1次，伪猜中1次。\n</pre>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>len(solution) = len(guess) = 4</code></li>\n<li><code>solution</code>和<code>guess</code>仅包含<code>\"R\"</code>,<code>\"G\"</code>,<code>\"B\"</code>,<code>\"Y\"</code>这4种字符</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3127.部分排序",
        "hardRate": "MEDIUM",
        "passRate": "46.68%",
        "problemsUrl": "https://leetcode.cn/problems/sub-sort-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/sub-sort-lcci/solution",
        "problemsDesc": "<p>给定一个整数数组，编写一个函数，找出索引<code>m</code>和<code>n</code>，只要将索引区间<code>[m,n]</code>的元素排好序，整个数组就是有序的。注意：<code>n-m</code>尽量最小，也就是说，找出符合条件的最短序列。函数返回值为<code>[m,n]</code>，若不存在这样的<code>m</code>和<code>n</code>（例如整个数组是有序的），请返回<code>[-1,-1]</code>。</p>\n<p><strong>示例：</strong></p>\n<pre><strong>输入：</strong> [1,2,4,7,10,11,7,12,6,7,16,18,19]\n<strong>输出：</strong> [3,9]\n</pre>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 <= len(array) <= 1000000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3128.连续数列",
        "hardRate": "EASY",
        "passRate": "58.90%",
        "problemsUrl": "https://leetcode.cn/problems/contiguous-sequence-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/contiguous-sequence-lcci/solution",
        "problemsDesc": "<p>给定一个整数数组，找出总和最大的连续数列，并返回总和。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong> [-2,1,-3,4,-1,2,1,-5,4]\n<strong>输出：</strong> 6\n<strong>解释：</strong> 连续子数组 [4,-1,2,1] 的和最大，为 6。\n</pre>\n\n<p><strong>进阶：</strong></p>\n\n<p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3129.模式匹配",
        "hardRate": "MEDIUM",
        "passRate": "33.88%",
        "problemsUrl": "https://leetcode.cn/problems/pattern-matching-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/pattern-matching-lcci/solution",
        "problemsDesc": "<p>你有两个字符串，即<code>pattern</code>和<code>value</code>。 <code>pattern</code>字符串由字母<code>&quot;a&quot;</code>和<code>&quot;b&quot;</code>组成，用于描述字符串中的模式。例如，字符串<code>&quot;catcatgocatgo&quot;</code>匹配模式<code>&quot;aabab&quot;</code>（其中<code>&quot;cat&quot;</code>是<code>&quot;a&quot;</code>，<code>&quot;go&quot;</code>是<code>&quot;b&quot;</code>），该字符串也匹配像<code>&quot;a&quot;</code>、<code>&quot;ab&quot;</code>和<code>&quot;b&quot;</code>这样的模式。但需注意<code>&quot;a&quot;</code>和<code>&quot;b&quot;</code>不能同时表示相同的字符串。编写一个方法判断<code>value</code>字符串是否匹配<code>pattern</code>字符串。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong> pattern = &quot;abba&quot;, value = &quot;dogcatcatdog&quot;\n<strong>输出：</strong> true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong> pattern = &quot;abba&quot;, value = &quot;dogcatcatfish&quot;\n<strong>输出：</strong> false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong> pattern = &quot;aaaa&quot;, value = &quot;dogcatcatdog&quot;\n<strong>输出：</strong> false\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong> pattern = &quot;abba&quot;, value = &quot;dogdogdogdog&quot;\n<strong>输出：</strong> true\n<strong>解释：</strong> &quot;a&quot;=&quot;dogdog&quot;,b=&quot;&quot;，反之也符合规则\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= len(pattern) &lt;= 1000</code></li>\n\t<li><code>0 &lt;= len(value) &lt;= 1000</code></li>\n\t<li>你可以假设<code>pattern</code>只包含字母<code>&quot;a&quot;</code>和<code>&quot;b&quot;</code>，<code>value</code>仅包含小写字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3130.水域大小",
        "hardRate": "MEDIUM",
        "passRate": "66.24%",
        "problemsUrl": "https://leetcode.cn/problems/pond-sizes-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/pond-sizes-lcci/solution",
        "problemsDesc": "<p>你有一个用于表示一片土地的整数矩阵<code>land</code>，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。</p>\n<p><strong>示例：</strong></p>\n<pre><strong>输入：</strong>\n[\n  [0,2,1,0],\n  [0,1,0,1],\n  [1,1,0,1],\n  [0,1,0,1]\n]\n<strong>输出：</strong> [1,2,4]\n</pre>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 < len(land) <= 1000</code></li>\n<li><code>0 < len(land[i]) <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3131.T9键盘",
        "hardRate": "MEDIUM",
        "passRate": "71.20%",
        "problemsUrl": "https://leetcode.cn/problems/t9-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/t9-lcci/solution",
        "problemsDesc": "<p>在老式手机上，用户通过数字键盘输入，手机将提供与这些数字相匹配的单词列表。每个数字映射到0至4个字母。给定一个数字序列，实现一个算法来返回匹配单词的列表。你会得到一张含有有效单词的列表。映射如下图所示：</p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png\" style=\"width: 200px;\"></p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> num = &quot;8733&quot;, words = [&quot;tree&quot;, &quot;used&quot;]\n<strong>输出:</strong> [&quot;tree&quot;, &quot;used&quot;]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> num = &quot;2&quot;, words = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]\n<strong>输出:</strong> [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</pre>\n\n<p>提示：</p>\n\n<ul>\n\t<li><code>num.length &lt;= 1000</code></li>\n\t<li><code>words.length &lt;= 500</code></li>\n\t<li><code>words[i].length == num.length</code></li>\n\t<li><code>num</code>中不会出现 0, 1 这两个数字</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3132.交换和",
        "hardRate": "MEDIUM",
        "passRate": "47.67%",
        "problemsUrl": "https://leetcode.cn/problems/sum-swap-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-swap-lcci/solution",
        "problemsDesc": "<p>给定两个整数数组，请交换一对数值（每个数组中取一个数值），使得两个数组所有元素的和相等。</p>\n\n<p>返回一个数组，第一个元素是第一个数组中要交换的元素，第二个元素是第二个数组中要交换的元素。若有多个答案，返回任意一个均可。若无满足条件的数值，返回空数组。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> array1 = [4, 1, 2, 1, 1, 2], array2 = [3, 6, 3, 3]\n<strong>输出:</strong> [1, 3]\n</pre>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> array1 = <code>[1, 2, 3], array2 = [4, 5, 6]</code>\n<strong>输出: </strong>[]</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= array1.length, array2.length &lt;= 100000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3133.兰顿蚂蚁",
        "hardRate": "MEDIUM",
        "passRate": "57.84%",
        "problemsUrl": "https://leetcode.cn/problems/langtons-ant-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/langtons-ant-lcci/solution",
        "problemsDesc": "<p>一只蚂蚁坐在由白色和黑色方格构成的无限网格上。开始时，网格全白，蚂蚁面向右侧。每行走一步，蚂蚁执行以下操作。</p>\n\n<p>(1) 如果在白色方格上，则翻转方格的颜色，向右(顺时针)转 90 度，并向前移动一个单位。<br>\n(2) 如果在黑色方格上，则翻转方格的颜色，向左(逆时针方向)转 90 度，并向前移动一个单位。</p>\n\n<p>编写程序来模拟蚂蚁执行的前 K 个动作，并返回最终的网格。</p>\n\n<p>网格由数组表示，每个元素是一个字符串，代表网格中的一行，黑色方格由&nbsp;<code>&#39;X&#39;</code>&nbsp;表示，白色方格由&nbsp;<code>&#39;_&#39;</code>&nbsp;表示，蚂蚁所在的位置由&nbsp;<code>&#39;L&#39;</code>, <code>&#39;U&#39;</code>, <code>&#39;R&#39;</code>, <code>&#39;D&#39;</code>&nbsp;表示，分别表示蚂蚁&nbsp;左、上、右、下 的朝向。只需要返回能够包含蚂蚁走过的所有方格的最小矩形。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> 0\n<strong>输出: </strong>[&quot;R&quot;]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> 2\n<strong>输出:\n</strong>[\n&nbsp; &quot;_X&quot;,\n&nbsp; &quot;LX&quot;\n]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre><strong>输入:</strong> 5\n<strong>输出:\n</strong>[\n&nbsp; &quot;_U&quot;,\n&nbsp; &quot;X_&quot;,\n&nbsp; &quot;XX&quot;\n]\n</pre>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li><code>K &lt;= 100000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3134.数对和",
        "hardRate": "MEDIUM",
        "passRate": "48.27%",
        "problemsUrl": "https://leetcode.cn/problems/pairs-with-sum-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/pairs-with-sum-lcci/solution",
        "problemsDesc": "<p>设计一个算法，找出数组中两数之和为指定值的所有整数对。一个数只能属于一个数对。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [5,6,5], target = 11\n<strong>输出: </strong>[[5,6]]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [5,6,5,6], target = 11\n<strong>输出: </strong>[[5,6],[5,6]]</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length &lt;= 100000</code></li>\n\t<li><code>-10^5 &lt;= nums[i], target &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3135.LRU 缓存",
        "hardRate": "MEDIUM",
        "passRate": "55.49%",
        "problemsUrl": "https://leetcode.cn/problems/lru-cache-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/lru-cache-lcci/solution",
        "problemsDesc": "<p>设计和构建一个&ldquo;最近最少使用&rdquo;缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。</p>\n\n<p>它应该支持以下操作： 获取数据 <code>get</code> 和 写入数据 <code>put</code> 。</p>\n\n<p>获取数据 <code>get(key)</code> - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>\n写入数据 <code>put(key, value)</code> - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // 返回  1\ncache.put(3, 3);    // 该操作会使得密钥 2 作废\ncache.get(2);       // 返回 -1 (未找到)\ncache.put(4, 4);    // 该操作会使得密钥 1 作废\ncache.get(1);       // 返回 -1 (未找到)\ncache.get(3);       // 返回  3\ncache.get(4);       // 返回  4\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3136.计算器",
        "hardRate": "MEDIUM",
        "passRate": "39.77%",
        "problemsUrl": "https://leetcode.cn/problems/calculator-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/calculator-lcci/solution",
        "problemsDesc": "<p>给定一个包含正整数、加(+)、减(-)、乘(*)、除(/)的算数表达式(括号除外)，计算其结果。</p>\n\n<p>表达式仅包含非负整数，<code>+</code>， <code>-</code> ，<code>*</code>，<code>/</code> 四种运算符和空格&nbsp;<code>&nbsp;</code>。 整数除法仅保留整数部分。</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre><strong>输入: </strong>&quot;3+2*2&quot;\n<strong>输出:</strong> 7\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> &quot; 3/2 &quot;\n<strong>输出:</strong> 1</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre><strong>输入:</strong> &quot; 3+5 / 2 &quot;\n<strong>输出:</strong> 5\n</pre>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>你可以假设所给定的表达式都是有效的。</li>\n\t<li>请<strong>不要</strong>使用内置的库函数 <code>eval</code>。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3137.不用加号的加法",
        "hardRate": "EASY",
        "passRate": "61.57%",
        "problemsUrl": "https://leetcode.cn/problems/add-without-plus-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/add-without-plus-lcci/solution",
        "problemsDesc": "<p>设计一个函数把两个数字相加。不得使用 + 或者其他算术运算符。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> a = 1, b = 1\n<strong>输出:</strong> 2</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>a</code>,&nbsp;<code>b</code>&nbsp;均可能是负数或 0</li>\n\t<li>结果不会溢出 32 位整数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3138.消失的数字",
        "hardRate": "EASY",
        "passRate": "59.40%",
        "problemsUrl": "https://leetcode.cn/problems/missing-number-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/missing-number-lcci/solution",
        "problemsDesc": "<p>数组<code>nums</code>包含从<code>0</code>到<code>n</code>的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？</p>\n\n<p><strong>注意：</strong>本题相对书上原题稍作改动</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[3,0,1]\n<strong>输出：</strong>2</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>[9,6,4,2,3,5,7,0,1]\n<strong>输出：</strong>8\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3139. 字母与数字",
        "hardRate": "MEDIUM",
        "passRate": "47.45%",
        "problemsUrl": "https://leetcode.cn/problems/find-longest-subarray-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/find-longest-subarray-lcci/solution",
        "problemsDesc": "<p>给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。</p>\n\n<p>返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>[\"A\",\"1\",\"B\",\"C\",\"D\",\"2\",\"3\",\"4\",\"E\",\"5\",\"F\",\"G\",\"6\",\"7\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\"]\n\n<strong>输出: </strong>[\"A\",\"1\",\"B\",\"C\",\"D\",\"2\",\"3\",\"4\",\"E\",\"5\",\"F\",\"G\",\"6\",\"7\"]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>[\"A\",\"A\"]\n\n<strong>输出: </strong>[]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>array.length <= 100000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3140.2出现的次数",
        "hardRate": "HARD",
        "passRate": "49.61%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-2s-in-range-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-2s-in-range-lcci/solution",
        "problemsDesc": "<p>编写一个方法，计算从 0 到 n (含 n) 中数字 2 出现的次数。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入: </strong>25\n<strong>输出: </strong>9\n<strong>解释: </strong>(2, 12, 20, 21, 22, 23, 24, 25)(注意 22 应该算作两次)</pre>\n\n<p>提示：</p>\n\n<ul>\n\t<li><code>n &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3141.婴儿名字",
        "hardRate": "MEDIUM",
        "passRate": "41.58%",
        "problemsUrl": "https://leetcode.cn/problems/baby-names-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/baby-names-lcci/solution",
        "problemsDesc": "<p>每年，政府都会公布一万个最常见的婴儿名字和它们出现的频率，也就是同名婴儿的数量。有些名字有多种拼法，例如，John 和 Jon 本质上是相同的名字，但被当成了两个名字公布出来。给定两个列表，一个是名字及对应的频率，另一个是本质相同的名字对。设计一个算法打印出每个真实名字的实际频率。注意，如果 John 和 Jon 是相同的，并且 Jon 和 Johnny 相同，则 John 与 Johnny 也相同，即它们有传递和对称性。</p>\n\n<p>在结果列表中，选择<strong> 字典序最小 </strong>的名字作为真实名字。</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>names = [\"John(15)\",\"Jon(12)\",\"Chris(13)\",\"Kris(4)\",\"Christopher(19)\"], synonyms = [\"(Jon,John)\",\"(John,Johnny)\",\"(Chris,Kris)\",\"(Chris,Christopher)\"]\n<strong>输出：</strong>[\"John(27)\",\"Chris(36)\"]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>names.length <= 100000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3142.马戏团人塔",
        "hardRate": "MEDIUM",
        "passRate": "28.51%",
        "problemsUrl": "https://leetcode.cn/problems/circus-tower-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/circus-tower-lcci/solution",
        "problemsDesc": "<p>有个马戏团正在设计叠罗汉的表演节目，一个人要站在另一人的肩膀上。出于实际和美观的考虑，在上面的人要比下面的人矮一点且轻一点。已知马戏团每个人的身高和体重，请编写代码计算叠罗汉最多能叠几个人。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>height = [65,70,56,75,60,68] weight = [100,150,90,190,95,110]\n<strong>输出：</strong>6\n<strong>解释：</strong>从上往下数，叠罗汉最多能叠 6 层：(56,90), (60,95), (65,100), (68,110), (70,150), (75,190)</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>height.length == weight.length <= 10000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3143.第 k 个数",
        "hardRate": "MEDIUM",
        "passRate": "56.11%",
        "problemsUrl": "https://leetcode.cn/problems/get-kth-magic-number-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/get-kth-magic-number-lcci/solution",
        "problemsDesc": "<p>有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入: </strong>k = 5\n\n<strong>输出: </strong>9\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3144.主要元素",
        "hardRate": "EASY",
        "passRate": "56.22%",
        "problemsUrl": "https://leetcode.cn/problems/find-majority-element-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/find-majority-element-lcci/solution",
        "problemsDesc": "<p>数组中占比超过一半的元素称之为主要元素。给你一个<strong> 整数 </strong>数组，找出其中的主要元素。若没有，返回 <code>-1</code> 。请设计时间复杂度为 <code>O(N)</code> 、空间复杂度为 <code>O(1)</code> 的解决方案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1,2,5,9,5,9,5,5,5]\n<strong>输出：</strong>5</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>[3,2]\n<strong>输出：</strong>-1</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>[2,2,1,1,1,2,2]\n<strong>输出：</strong>2</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3145.单词距离",
        "hardRate": "MEDIUM",
        "passRate": "73.08%",
        "problemsUrl": "https://leetcode.cn/problems/find-closest-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/find-closest-lcci/solution",
        "problemsDesc": "<p>有个内含单词的超大文本文件，给定任意两个<code>不同的</code>单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗?</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"I\",\"am\",\"a\",\"student\",\"from\",\"a\",\"university\",\"in\",\"a\",\"city\"], word1 = \"a\", word2 = \"student\"\n<strong>输出：</strong>1</pre>\n\n<p>提示：</p>\n\n<ul>\n\t<li><code>words.length &lt;= 100000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3146.BiNode",
        "hardRate": "EASY",
        "passRate": "63.91%",
        "problemsUrl": "https://leetcode.cn/problems/binode-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/binode-lcci/solution",
        "problemsDesc": "<p>二叉树数据结构<code>TreeNode</code>可用来表示单向链表（其中<code>left</code>置空，<code>right</code>为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。</p>\n\n<p>返回转换后的单向链表的头节点。</p>\n\n<p><strong>注意：</strong>本题相对原题稍作改动</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong> [4,2,5,1,3,null,6,0]\n<strong>输出：</strong> [0,null,1,null,2,null,3,null,4,null,5,null,6]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>节点数量不会超过 100000。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3147.恢复空格",
        "hardRate": "MEDIUM",
        "passRate": "55.42%",
        "problemsUrl": "https://leetcode.cn/problems/re-space-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/re-space-lcci/solution",
        "problemsDesc": "<p>哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子<code>&quot;I reset the computer. It still didn&rsquo;t boot!&quot;</code>已经变成了<code>&quot;iresetthecomputeritstilldidntboot&quot;</code>。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典<code>dictionary</code>，不过，有些词没在词典里。假设文章用<code>sentence</code>表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。</p>\n\n<p><strong>注意：</strong>本题相对原题稍作改动，只需返回未识别的字符数</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>\ndictionary = [&quot;looked&quot;,&quot;just&quot;,&quot;like&quot;,&quot;her&quot;,&quot;brother&quot;]\nsentence = &quot;jesslookedjustliketimherbrother&quot;\n<strong>输出：</strong> 7\n<strong>解释：</strong> 断句后为&quot;<strong>jess</strong> looked just like <strong>tim</strong> her brother&quot;，共7个未识别字符。\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= len(sentence) &lt;= 1000</code></li>\n\t<li><code>dictionary</code>中总字符数不超过 150000。</li>\n\t<li>你可以认为<code>dictionary</code>和<code>sentence</code>中只包含小写字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3148.最小K个数",
        "hardRate": "MEDIUM",
        "passRate": "58.89%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-k-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-k-lcci/solution",
        "problemsDesc": "<p>设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong> arr = [1,3,5,7,2,4,6,8], k = 4\n<strong>输出：</strong> [1,2,3,4]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= len(arr) &lt;= 100000</code></li>\n\t<li><code>0 &lt;= k &lt;= min(100000, len(arr))</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3149.最长单词",
        "hardRate": "MEDIUM",
        "passRate": "40.83%",
        "problemsUrl": "https://leetcode.cn/problems/longest-word-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-word-lcci/solution",
        "problemsDesc": "<p>给定一组单词<code>words</code>，编写一个程序，找出其中的最长单词，且该单词由这组单词中的其他单词组合而成。若有多个长度相同的结果，返回其中字典序最小的一项，若没有符合要求的单词则返回空字符串。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong> [&quot;cat&quot;,&quot;banana&quot;,&quot;dog&quot;,&quot;nana&quot;,&quot;walk&quot;,&quot;walker&quot;,&quot;dogwalker&quot;]\n<strong>输出：</strong> &quot;dogwalker&quot;\n<strong>解释：</strong> &quot;dogwalker&quot;可由&quot;dog&quot;和&quot;walker&quot;组成。\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= len(words) &lt;= 200</code></li>\n\t<li><code>1 &lt;= len(words[i]) &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3150.按摩师",
        "hardRate": "EASY",
        "passRate": "51.07%",
        "problemsUrl": "https://leetcode.cn/problems/the-masseuse-lcci/",
        "solutionsUrl": "https://leetcode.cn/problems/the-masseuse-lcci/solution",
        "problemsDesc": "<p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>\n\n<p><strong>注意：</strong>本题相对原题稍作改动</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong> [1,2,3,1]\n<strong>输出：</strong> 4\n<strong>解释：</strong> 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong> [2,7,9,3,1]\n<strong>输出：</strong> 12\n<strong>解释：</strong> 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong> [2,1,4,5,3,1,1,3]\n<strong>输出：</strong> 12\n<strong>解释：</strong> 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。\n</pre>\n",
        "isPlus": false
    }
]