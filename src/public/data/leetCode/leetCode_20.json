[
    {
        "problemsName": " 951.翻转等价二叉树",
        "hardRate": "MEDIUM",
        "passRate": "66.86%",
        "problemsUrl": "https://leetcode.cn/problems/flip-equivalent-binary-trees/",
        "solutionsUrl": "https://leetcode.cn/problems/flip-equivalent-binary-trees/solution",
        "problemsDesc": "<p>我们可以为二叉树 <strong>T</strong> 定义一个&nbsp;<strong>翻转操作&nbsp;</strong>，如下所示：选择任意节点，然后交换它的左子树和右子树。</p>\n\n<p>只要经过一定次数的翻转操作后，能使 <strong>X</strong> 等于 <strong>Y</strong>，我们就称二叉树 <strong>X</strong> <em>翻转 等价&nbsp;</em>于二叉树 <strong>Y</strong>。</p>\n\n<p>这些树由根节点&nbsp;<code>root1</code> 和 <code>root2</code>&nbsp;给出。如果两个二叉树是否是<em>翻转 等价&nbsp;</em>的函数，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"Flipped Trees Diagram\" src=\"https://assets.leetcode.com/uploads/2018/11/29/tree_ex.png\" /></p>\n\n<pre>\n<strong>输入：</strong>root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]\n<strong>输出：</strong>true\n<strong>解释：</strong>我们翻转值为 1，3 以及 5 的三个节点。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> root1 = [], root2 = []\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> root1 = [], root2 = [1]\n<strong>输出:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每棵树节点数在&nbsp;<code>[0, 100]</code> 范围内</li>\n\t<li>每棵树中的每个值都是唯一的、在 <code>[0, 99]</code>&nbsp;范围内的整数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 952.按公因数计算最大组件大小",
        "hardRate": "HARD",
        "passRate": "51.08%",
        "problemsUrl": "https://leetcode.cn/problems/largest-component-size-by-common-factor/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-component-size-by-common-factor/solution",
        "problemsDesc": "<p>给定一个由不同正整数的组成的非空数组&nbsp;<code>nums</code> ，考虑下面的图：</p>\n\n<ul>\n\t<li>有&nbsp;<code>nums.length</code>&nbsp;个节点，按从&nbsp;<code>nums[0]</code>&nbsp;到&nbsp;<code>nums[nums.length - 1]</code>&nbsp;标记；</li>\n\t<li>只有当&nbsp;<code>nums[i]</code>&nbsp;和&nbsp;<code>nums[j]</code>&nbsp;共用一个大于 1 的公因数时，<code>nums[i]</code>&nbsp;和&nbsp;<code>nums[j]</code>之间才有一条边。</li>\n</ul>\n\n<p>返回 <em>图中最大连通组件的大小</em> 。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/01/ex1.png\" style=\"height: 97px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,6,15,35]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/01/ex2.png\" style=\"height: 85px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [20,50,9,63]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/01/ex3.png\" style=\"height: 260px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,6,7,4,12,21,39]\n<strong>输出：</strong>8\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums</code>&nbsp;中所有值都 <strong>不同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 953.验证外星语词典",
        "hardRate": "EASY",
        "passRate": "57.67%",
        "problemsUrl": "https://leetcode.cn/problems/verifying-an-alien-dictionary/",
        "solutionsUrl": "https://leetcode.cn/problems/verifying-an-alien-dictionary/solution",
        "problemsDesc": "<p>某种外星语也使用英文小写字母，但可能顺序 <code>order</code> 不同。字母表的顺序（<code>order</code>）是一些小写字母的排列。</p>\n\n<p>给定一组用外星语书写的单词 <code>words</code>，以及其字母表的顺序 <code>order</code>，只有当给定的单词在这种外星语中按字典序排列时，返回 <code>true</code>；否则，返回 <code>false</code>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\n<strong>输出：</strong>true\n<strong>解释：</strong>在该语言的字母表中，'h' 位于 'l' 之前，所以单词序列是按字典序排列的。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\n<strong>输出：</strong>false\n<strong>解释：</strong>在该语言的字母表中，'d' 位于 'l' 之后，那么 words[0] > words[1]，因此单词序列不是按字典序排列的。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\n<strong>输出：</strong>false\n<strong>解释：</strong>当前三个字符 \"app\" 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 \"apple\" > \"app\"，因为 'l' > '∅'，其中 '∅' 是空白字符，定义为比任何其他字符都小（<a href=\"https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E5%BA%8F\" target=\"_blank\">更多信息</a>）。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= words.length <= 100</code></li>\n\t<li><code>1 <= words[i].length <= 20</code></li>\n\t<li><code>order.length == 26</code></li>\n\t<li>在 <code>words[i]</code> 和 <code>order</code> 中的所有字符都是英文小写字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 954.二倍数对数组",
        "hardRate": "MEDIUM",
        "passRate": "39.09%",
        "problemsUrl": "https://leetcode.cn/problems/array-of-doubled-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/array-of-doubled-pairs/solution",
        "problemsDesc": "<p>给定一个长度为偶数的整数数组 <code>arr</code>，只有对 <code>arr</code> 进行重组后可以满足 “对于每个 <code>0 &lt;=&nbsp;i &lt; len(arr) / 2</code>，都有 <code>arr[2 * i + 1] = 2 * arr[2 * i]</code>”&nbsp;时，返回 <code>true</code>；否则，返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [3,1,3,6]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [2,1,2,6]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [4,-2,2,-4]\n<strong>输出：</strong>true\n<strong>解释：</strong>可以用 [-2,-4] 和 [2,4] 这两组组成 [-2,-4,2,4] 或是 [2,4,-2,-4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= arr.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>arr.length</code> 是偶数</li>\n\t<li><code>-10<sup>5</sup> &lt;= arr[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 955.删列造序 II",
        "hardRate": "MEDIUM",
        "passRate": "35.59%",
        "problemsUrl": "https://leetcode.cn/problems/delete-columns-to-make-sorted-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-columns-to-make-sorted-ii/solution",
        "problemsDesc": "<p>给定由 <code>n</code> 个字符串组成的数组 <code>strs</code>，其中每个字符串长度相等。</p>\n\n<p>选取一个删除索引序列，对于 <code>strs</code> 中的每个字符串，删除对应每个索引处的字符。</p>\n\n<p>比如，有 <code>strs = [\"abcdef\", \"uvwxyz\"]</code>，删除索引序列 <code>{0, 2, 3}</code>，删除后 <code>strs</code> 为<code>[\"bef\", \"vyz\"]</code>。</p>\n\n<p>假设，我们选择了一组删除索引 <code>answer</code>，那么在执行删除操作之后，最终得到的数组的元素是按 <strong>字典序</strong>（<code>strs[0] <= strs[1] <= strs[2] ... <= strs[n - 1]</code>）排列的，然后请你返回 <code>answer.length</code> 的最小可能值。</p>\n\n<p> </p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"ca\",\"bb\",\"ac\"]\n<strong>输出：</strong>1\n<strong>解释： </strong>\n删除第一列后，strs = [\"a\", \"b\", \"c\"]。\n现在 strs 中元素是按字典排列的 (即，strs[0] <= strs[1] <= strs[2])。\n我们至少需要进行 1 次删除，因为最初 strs 不是按字典序排列的，所以答案是 1。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"xc\",\"yb\",\"za\"]\n<strong>输出：</strong>0\n<strong>解释：</strong>\nstrs 的列已经是按字典序排列了，所以我们不需要删除任何东西。\n注意 strs 的行不需要按字典序排列。\n也就是说，strs[0][0] <= strs[0][1] <= ... 不一定成立。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"zyx\",\"wvu\",\"tsr\"]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n我们必须删掉每一列。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == strs.length</code></li>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>1 <= strs[i].length <= 100</code></li>\n\t<li><code>strs[i]</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 956.最高的广告牌",
        "hardRate": "HARD",
        "passRate": "46.53%",
        "problemsUrl": "https://leetcode.cn/problems/tallest-billboard/",
        "solutionsUrl": "https://leetcode.cn/problems/tallest-billboard/solution",
        "problemsDesc": "<p>你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。</p>\n\n<p>你有一堆可以焊接在一起的钢筋 <code>rods</code>。举个例子，如果钢筋的长度为 <code>1</code>、<code>2</code> 和 <code>3</code>，则可以将它们焊接在一起形成长度为 <code>6</code>&nbsp;的支架。</p>\n\n<p>返回 <em>广告牌的最大可能安装高度</em> 。如果没法安装广告牌，请返回 <code>0</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1,2,3,6]\n<strong>输出：</strong>6\n<strong>解释：</strong>我们有两个不相交的子集 {1,2,3} 和 {6}，它们具有相同的和 sum = 6。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1,2,3,4,5,6]\n<strong>输出：</strong>10\n<strong>解释：</strong>我们有两个不相交的子集 {2,3,5} 和 {4,6}，它们具有相同的和 sum = 10。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1,2]\n<strong>输出：</strong>0\n<strong>解释：</strong>没法安装广告牌，所以返回 0。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>0 &lt;= rods.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= rods[i] &lt;= 1000</code></li>\n\t<li><code>sum(rods[i]) &lt;= 5000</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 957.N 天后的牢房",
        "hardRate": "MEDIUM",
        "passRate": "37.05%",
        "problemsUrl": "https://leetcode.cn/problems/prison-cells-after-n-days/",
        "solutionsUrl": "https://leetcode.cn/problems/prison-cells-after-n-days/solution",
        "problemsDesc": "<p>监狱中 <code>8</code> 间牢房排成一排，每间牢房可能被占用或空置。</p>\n\n<p>每天，无论牢房是被占用或空置，都会根据以下规则进行变更：</p>\n\n<ul>\n\t<li>如果一间牢房的两个相邻的房间都被占用或都是空的，那么该牢房就会被占用。</li>\n\t<li>否则，它就会被空置。</li>\n</ul>\n\n<p><strong>注意</strong>：由于监狱中的牢房排成一行，所以行中的第一个和最后一个牢房不存在两个相邻的房间。</p>\n\n<p>给你一个整数数组 <code>cells</code> ，用于表示牢房的初始状态：如果第 <code>i</code> 间牢房被占用，则 <code>cell[i]==1</code>，否则 <code>cell[i]==0</code> 。另给你一个整数 <code>n</code> 。</p>\n\n<p>请你返回 <code>n</code> 天后监狱的状况（即，按上文描述进行 <code>n</code> 次变更）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>cells = [0,1,0,1,1,0,0,1], n = 7\n<strong>输出：</strong>[0,0,1,1,0,0,0,0]\n<strong>解释：</strong>下表总结了监狱每天的状况：\nDay 0: [0, 1, 0, 1, 1, 0, 0, 1]\nDay 1: [0, 1, 1, 0, 0, 0, 0, 0]\nDay 2: [0, 0, 0, 0, 1, 1, 1, 0]\nDay 3: [0, 1, 1, 0, 0, 1, 0, 0]\nDay 4: [0, 0, 0, 0, 0, 1, 0, 0]\nDay 5: [0, 1, 1, 1, 0, 1, 0, 0]\nDay 6: [0, 0, 1, 0, 1, 1, 0, 0]\nDay 7: [0, 0, 1, 1, 0, 0, 0, 0]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>cells = [1,0,0,1,0,0,1,0], n = 1000000000\n<strong>输出：</strong>[0,0,1,1,1,1,1,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>cells.length == 8</code></li>\n\t<li><code>cells[i]</code> 为 <code>0</code> 或 <code>1</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 958.二叉树的完全性检验",
        "hardRate": "MEDIUM",
        "passRate": "54.49%",
        "problemsUrl": "https://leetcode.cn/problems/check-completeness-of-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/check-completeness-of-a-binary-tree/solution",
        "problemsDesc": "<p>给定一个二叉树的<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;，确定它是否是一个&nbsp;<em>完全二叉树</em>&nbsp;。</p>\n\n<p>在一个&nbsp;<strong><a href=\"https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin\" target=\"_blank\">完全二叉树</a></strong>&nbsp;中，除了最后一个关卡外，所有关卡都是完全被填满的，并且最后一个关卡中的所有节点都是尽可能靠左的。它可以包含<meta charset=\"UTF-8\" />&nbsp;<code>1</code>&nbsp;到<meta charset=\"UTF-8\" />&nbsp;<code>2<sup>h</sup></code>&nbsp;节点之间的最后一级 <code>h</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-1.png\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,5,6]\n<strong>输出：</strong>true\n<strong>解释：</strong>最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-2.png\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,5,null,7]\n<strong>输出：</strong>false\n<strong>解释：</strong>值为 7 的结点没有尽可能靠向左侧。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树的结点数在范围 <meta charset=\"UTF-8\" />&nbsp;<code>[1, 100]</code>&nbsp;内。</li>\n\t<li><code>1 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 959.由斜杠划分区域",
        "hardRate": "MEDIUM",
        "passRate": "74.22%",
        "problemsUrl": "https://leetcode.cn/problems/regions-cut-by-slashes/",
        "solutionsUrl": "https://leetcode.cn/problems/regions-cut-by-slashes/solution",
        "problemsDesc": "<p>在由 <code>1 x 1</code> 方格组成的 <code>n&nbsp;x n</code>&nbsp;网格&nbsp;<code>grid</code> 中，每个 <code>1 x 1</code>&nbsp;方块由 <code>'/'</code>、<code>'\\'</code> 或空格构成。这些字符会将方块划分为一些共边的区域。</p>\n\n<p>给定网格&nbsp;<code>grid</code>&nbsp;表示为一个字符串数组，返回 <em>区域的数量</em> 。</p>\n\n<p>请注意，反斜杠字符是转义的，因此&nbsp;<code>'\\'</code> 用 <code>'\\\\'</code>&nbsp;表示。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/15/1.png\" style=\"height: 200px; width: 200px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [\" /\",\"/ \"]\n<strong>输出：</strong>2</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/15/2.png\" style=\"height: 198px; width: 200px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [\" /\",\"  \"]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/15/4.png\" style=\"height: 200px; width: 200px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [\"/\\\\\",\"\\\\/\"]\n<strong>输出：</strong>5\n<strong>解释：</strong>回想一下，因为 \\ 字符是转义的，所以 \"/\\\\\" 表示 /\\，而 \"\\\\/\" 表示 \\/。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n\t<li><code>grid[i][j]</code> 是&nbsp;<code>'/'</code>、<code>'\\'</code>、或&nbsp;<code>' '</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 960.删列造序 III",
        "hardRate": "HARD",
        "passRate": "59.20%",
        "problemsUrl": "https://leetcode.cn/problems/delete-columns-to-make-sorted-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-columns-to-make-sorted-iii/solution",
        "problemsDesc": "<p>给定由<meta charset=\"UTF-8\" />&nbsp;<code>n</code>&nbsp;个小写字母字符串组成的数组<meta charset=\"UTF-8\" />&nbsp;<code>strs</code>&nbsp;，其中每个字符串长度相等。</p>\n\n<p>选取一个删除索引序列，对于<meta charset=\"UTF-8\" />&nbsp;<code>strs</code>&nbsp;中的每个字符串，删除对应每个索引处的字符。</p>\n\n<p>比如，有<meta charset=\"UTF-8\" />&nbsp;<code>strs = [\"abcdef\",\"uvwxyz\"]</code>&nbsp;，删除索引序列<meta charset=\"UTF-8\" />&nbsp;<code>{0, 2, 3}</code>&nbsp;，删除后为<meta charset=\"UTF-8\" />&nbsp;<code>[\"bef\", \"vyz\"]</code>&nbsp;。</p>\n\n<p>假设，我们选择了一组删除索引<meta charset=\"UTF-8\" />&nbsp;<code>answer</code>&nbsp;，那么在执行删除操作之后，最终得到的数组的行中的 <strong>每个元素</strong> 都是按<strong>字典序</strong>排列的（即&nbsp;<code>(strs[0][0] &lt;= strs[0][1] &lt;= ... &lt;= strs[0][strs[0].length - 1])</code>&nbsp;和&nbsp;<code>(strs[1][0] &lt;= strs[1][1] &lt;= ... &lt;= strs[1][strs[1].length - 1])</code> ，依此类推）。</p>\n\n<p>请返回<meta charset=\"UTF-8\" /><em>&nbsp;<code>answer.length</code>&nbsp;的最小可能值</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"babca\",\"bbazb\"]\n<strong>输出：</strong>3\n<strong>解释：\n</strong>删除 0、1 和 4 这三列后，最终得到的数组是 strs = [\"bc\", \"az\"]。\n这两行是分别按字典序排列的（即，strs[0][0] &lt;= strs[0][1] 且 strs[1][0] &lt;= strs[1][1]）。\n注意，strs[0] &gt; strs[1] —— 数组 strs 不一定是按字典序排列的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"edcba\"]\n<strong>输出：</strong>4\n<strong>解释：</strong>如果删除的列少于 4 列，则剩下的行都不会按字典序排列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"ghi\",\"def\",\"abc\"]\n<strong>输出：</strong>0\n<strong>解释：</strong>所有行都已按字典序排列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>n == strs.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= strs[i].length &lt;= 100</code></li>\n\t<li><code>strs[i]</code>&nbsp;由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 961.在长度 2N 的数组中找出重复 N 次的元素",
        "hardRate": "EASY",
        "passRate": "70.20%",
        "problemsUrl": "https://leetcode.cn/problems/n-repeated-element-in-size-2n-array/",
        "solutionsUrl": "https://leetcode.cn/problems/n-repeated-element-in-size-2n-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，该数组具有以下属性：</p>\n\n<div class=\"original__bRMd\">\n<div>\n<ul>\n\t<li><code>nums.length == 2 * n</code>.</li>\n\t<li><code>nums</code> 包含 <code>n + 1</code> 个 <strong>不同的</strong> 元素</li>\n\t<li><code>nums</code> 中恰有一个元素重复 <code>n</code> 次</li>\n</ul>\n\n<p>找出并返回重复了 <code>n</code><em> </em>次的那个元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,3]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,2,5,3,2]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,1,5,2,5,3,5,4]\n<strong>输出：</strong>5\n</pre>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 5000</code></li>\n\t<li><code>nums.length == 2 * n</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> 由 <code>n + 1</code> 个<strong> 不同的</strong> 元素组成，且其中一个元素恰好重复 <code>n</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 962.最大宽度坡",
        "hardRate": "MEDIUM",
        "passRate": "47.35%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-width-ramp/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-width-ramp/solution",
        "problemsDesc": "<p>给定一个整数数组&nbsp;<code>A</code>，<em>坡</em>是元组&nbsp;<code>(i, j)</code>，其中&nbsp;&nbsp;<code>i &lt; j</code>&nbsp;且&nbsp;<code>A[i] &lt;= A[j]</code>。这样的坡的宽度为&nbsp;<code>j - i</code>。</p>\n\n<p>找出&nbsp;<code>A</code>&nbsp;中的坡的最大宽度，如果不存在，返回 0 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[6,0,8,2,1,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>\n最大宽度的坡为 (i, j) = (1, 5): A[1] = 0 且 A[5] = 5.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>[9,8,1,0,1,9,4,0,4,1]\n<strong>输出：</strong>7\n<strong>解释：</strong>\n最大宽度的坡为 (i, j) = (2, 9): A[2] = 1 且 A[9] = 1.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>2 &lt;= A.length &lt;= 50000</code></li>\n\t<li><code>0 &lt;= A[i] &lt;= 50000</code></li>\n</ol>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 963.最小面积矩形 II",
        "hardRate": "MEDIUM",
        "passRate": "51.13%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-area-rectangle-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-area-rectangle-ii/solution",
        "problemsDesc": "<p>给定在 xy 平面上的一组点，确定由这些点组成的任何矩形的最小面积，其中矩形的边<strong>不一定平行于</strong> x 轴和 y 轴。</p>\n\n<p>如果没有任何矩形，就返回 0。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/22/1a.png\" style=\"height: 151px; width: 150px;\"></strong></p>\n\n<pre><strong>输入：</strong>[[1,2],[2,1],[1,0],[0,1]]\n<strong>输出：</strong>2.00000\n<strong>解释：</strong>最小面积的矩形出现在 [1,2],[2,1],[1,0],[0,1] 处，面积为 2。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/23/2.png\" style=\"height: 94px; width: 150px;\"></p>\n\n<pre><strong>输入：</strong>[[0,1],[2,1],[1,1],[1,0],[2,0]]\n<strong>输出：</strong>1.00000\n<strong>解释：</strong>最小面积的矩形出现在 [1,0],[1,1],[2,1],[2,0] 处，面积为 1。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/23/3.png\" style=\"height: 94px; width: 150px;\"></p>\n\n<pre><strong>输入：</strong>[[0,3],[1,2],[3,1],[1,3],[2,1]]\n<strong>输出：</strong>0\n<strong>解释：</strong>没法从这些点中组成任何矩形。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/21/4c.png\" style=\"height: 155px; width: 160px;\"></strong></p>\n\n<pre><strong>输入：</strong>[[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]]\n<strong>输出：</strong>2.00000\n<strong>解释：</strong>最小面积的矩形出现在 [2,1],[2,3],[3,3],[3,1] 处，面积为 2。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= points.length &lt;= 50</code></li>\n\t<li><code>0 &lt;=&nbsp;points[i][0] &lt;=&nbsp;40000</code></li>\n\t<li><code>0 &lt;=&nbsp;points[i][1] &lt;=&nbsp;40000</code></li>\n\t<li>所有的点都是不同的。</li>\n\t<li>与真实值误差不超过 <code>10^-5</code>&nbsp;的答案将视为正确结果。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 964.表示数字的最少运算符",
        "hardRate": "HARD",
        "passRate": "46.31%",
        "problemsUrl": "https://leetcode.cn/problems/least-operators-to-express-number/",
        "solutionsUrl": "https://leetcode.cn/problems/least-operators-to-express-number/solution",
        "problemsDesc": "<p>给定一个正整数 <code>x</code>，我们将会写出一个形如&nbsp;<code>x (op1) x (op2) x (op3) x ...</code>&nbsp;的表达式，其中每个运算符&nbsp;<code>op1</code>，<code>op2</code>，… 可以是加、减、乘、除（<code>+</code>，<code>-</code>，<code>*</code>，或是&nbsp;<code>/</code>）之一。例如，对于&nbsp;<code>x = 3</code>，我们可以写出表达式&nbsp;<code>3 * 3 / 3 + 3 - 3</code>，该式的值为 3 。</p>\n\n<p>在写这样的表达式时，我们需要遵守下面的惯例：</p>\n\n<ul>\n\t<li>除运算符（<code>/</code>）返回有理数。</li>\n\t<li>任何地方都没有括号。</li>\n\t<li>我们使用通常的操作顺序：乘法和除法发生在加法和减法之前。</li>\n\t<li>不允许使用一元否定运算符（<code>-</code>）。例如，“<code>x - x</code>” 是一个有效的表达式，因为它只使用减法，但是 “<code>-x + x</code>” 不是，因为它使用了否定运算符。&nbsp;</li>\n</ul>\n\n<p>我们希望编写一个能使表达式等于给定的目标值 <code>target</code> 且运算符最少的表达式。返回所用运算符的最少数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 3, target = 19\n<strong>输出：</strong>5\n<strong>解释：</strong>3 * 3 + 3 * 3 + 3 / 3 。表达式包含 5 个运算符。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 5, target = 501\n<strong>输出：</strong>8\n<strong>解释：</strong>5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5 。表达式包含 8 个运算符。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 100, target = 100000000\n<strong>输出：</strong>3\n<strong>解释：</strong>100 * 100 * 100 * 100 。表达式包含 3 个运算符。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= x &lt;= 100</code></li>\n\t<li><code>1 &lt;= target &lt;= 2 * 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 965.单值二叉树",
        "hardRate": "EASY",
        "passRate": "70.61%",
        "problemsUrl": "https://leetcode.cn/problems/univalued-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/univalued-binary-tree/solution",
        "problemsDesc": "<p>如果二叉树每个节点都具有相同的值，那么该二叉树就是<em>单值</em>二叉树。</p>\n\n<p>只有给定的树是单值二叉树时，才返回&nbsp;<code>true</code>；否则返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/screen-shot-2018-12-25-at-50104-pm.png\" style=\"height: 159px; width: 200px;\"></p>\n\n<pre><strong>输入：</strong>[1,1,1,1,1,null,1]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/screen-shot-2018-12-25-at-50050-pm.png\" style=\"height: 158px; width: 200px;\"></p>\n\n<pre><strong>输入：</strong>[2,2,2,5,2]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>给定树的节点数范围是&nbsp;<code>[1, 100]</code>。</li>\n\t<li>每个节点的值都是整数，范围为&nbsp;<code>[0, 99]</code>&nbsp;。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 966.元音拼写检查器",
        "hardRate": "MEDIUM",
        "passRate": "42.99%",
        "problemsUrl": "https://leetcode.cn/problems/vowel-spellchecker/",
        "solutionsUrl": "https://leetcode.cn/problems/vowel-spellchecker/solution",
        "problemsDesc": "<p>在给定单词列表&nbsp;<code>wordlist</code>&nbsp;的情况下，我们希望实现一个拼写检查器，将查询单词转换为正确的单词。</p>\n\n<p>对于给定的查询单词&nbsp;<code>query</code>，拼写检查器将会处理两类拼写错误：</p>\n\n<ul>\n\t<li>大小写：如果查询匹配单词列表中的某个单词（<strong>不区分大小写</strong>），则返回的正确单词与单词列表中的大小写相同。\n\n\t<ul>\n\t\t<li>例如：<code>wordlist = [\"yellow\"]</code>, <code>query = \"YellOw\"</code>: <code>correct = \"yellow\"</code></li>\n\t\t<li>例如：<code>wordlist = [\"Yellow\"]</code>, <code>query = \"yellow\"</code>: <code>correct = \"Yellow\"</code></li>\n\t\t<li>例如：<code>wordlist = [\"yellow\"]</code>, <code>query = \"yellow\"</code>: <code>correct = \"yellow\"</code></li>\n\t</ul>\n\t</li>\n\t<li>元音错误：如果在将查询单词中的元音 <code>('a', 'e', 'i', 'o', 'u')</code>&nbsp;&nbsp;分别替换为任何元音后，能与单词列表中的单词匹配（<strong>不区分大小写</strong>），则返回的正确单词与单词列表中的匹配项大小写相同。\n\t<ul>\n\t\t<li>例如：<code>wordlist = [\"YellOw\"]</code>, <code>query = \"yollow\"</code>: <code>correct = \"YellOw\"</code></li>\n\t\t<li>例如：<code>wordlist = [\"YellOw\"]</code>, <code>query = \"yeellow\"</code>: <code>correct = \"\"</code> （无匹配项）</li>\n\t\t<li>例如：<code>wordlist = [\"YellOw\"]</code>, <code>query = \"yllw\"</code>: <code>correct = \"\"</code> （无匹配项）</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>此外，拼写检查器还按照以下优先级规则操作：</p>\n\n<ul>\n\t<li>当查询完全匹配单词列表中的某个单词（<strong>区分大小写</strong>）时，应返回相同的单词。</li>\n\t<li>当查询匹配到大小写问题的单词时，您应该返回单词列表中的第一个这样的匹配项。</li>\n\t<li>当查询匹配到元音错误的单词时，您应该返回单词列表中的第一个这样的匹配项。</li>\n\t<li>如果该查询在单词列表中没有匹配项，则应返回空字符串。</li>\n</ul>\n\n<p>给出一些查询 <code>queries</code>，返回一个单词列表 <code>answer</code>，其中 <code>answer[i]</code> 是由查询 <code>query = queries[i]</code> 得到的正确单词。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>wordlist = [\"KiTe\",\"kite\",\"hare\",\"Hare\"], queries = [\"kite\",\"Kite\",\"KiTe\",\"Hare\",\"HARE\",\"Hear\",\"hear\",\"keti\",\"keet\",\"keto\"]\n<strong>输出：</strong>[\"kite\",\"KiTe\",\"KiTe\",\"Hare\",\"hare\",\"\",\"\",\"KiTe\",\"\",\"KiTe\"]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<b>输入：</b>wordlist = [\"yellow\"], queries = [\"YellOw\"]\n<b>输出：</b>[\"yellow\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= wordlist.length, queries.length &lt;= 5000</code></li>\n\t<li><code>1 &lt;= wordlist[i].length, queries[i].length &lt;= 7</code></li>\n\t<li><code>wordlist[i]</code>&nbsp;和&nbsp;<code>queries[i]</code>&nbsp;只包含英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 967.连续差相同的数字",
        "hardRate": "MEDIUM",
        "passRate": "50.56%",
        "problemsUrl": "https://leetcode.cn/problems/numbers-with-same-consecutive-differences/",
        "solutionsUrl": "https://leetcode.cn/problems/numbers-with-same-consecutive-differences/solution",
        "problemsDesc": "<p>返回所有长度为 <code>n</code> 且满足其每两个连续位上的数字之间的差的绝对值为 <code>k</code> 的<strong> 非负整数 </strong>。</p>\n\n<p>请注意，<strong>除了 </strong>数字 <code>0</code> 本身之外，答案中的每个数字都 <strong>不能 </strong>有前导零。例如，<code>01</code> 有一个前导零，所以是无效的；但 <code>0</code>&nbsp;是有效的。</p>\n\n<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 7\n<strong>输出：</strong>[181,292,707,818,929]\n<strong>解释：</strong>注意，070 不是一个有效的数字，因为它有前导零。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, k = 1\n<strong>输出：</strong>[10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, k = 0\n<strong>输出：</strong>[11,22,33,44,55,66,77,88,99]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, k = 2\n<strong>输出：</strong>[13,20,24,31,35,42,46,53,57,64,68,75,79,86,97]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 9</code></li>\n\t<li><code>0 &lt;= k &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 968.监控二叉树",
        "hardRate": "HARD",
        "passRate": "52.32%",
        "problemsUrl": "https://leetcode.cn/problems/binary-tree-cameras/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-tree-cameras/solution",
        "problemsDesc": "<p>给定一个二叉树，我们在树的节点上安装摄像头。</p>\n\n<p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p>\n\n<p>计算监控树的所有节点所需的最小摄像头数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png\" style=\"height: 163px; width: 138px;\"></p>\n\n<pre><strong>输入：</strong>[0,0,null,0,0]\n<strong>输出：</strong>1\n<strong>解释：</strong>如图所示，一台摄像头足以监控所有节点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png\" style=\"height: 312px; width: 139px;\"></p>\n\n<pre><strong>输入：</strong>[0,0,null,0,null,0,null,null,0]\n<strong>输出：</strong>2\n<strong>解释：</strong>需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。\n</pre>\n\n<p><br>\n<strong>提示：</strong></p>\n\n<ol>\n\t<li>给定树的节点数的范围是&nbsp;<code>[1, 1000]</code>。</li>\n\t<li>每个节点的值都是 0。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 969.煎饼排序",
        "hardRate": "MEDIUM",
        "passRate": "67.54%",
        "problemsUrl": "https://leetcode.cn/problems/pancake-sorting/",
        "solutionsUrl": "https://leetcode.cn/problems/pancake-sorting/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> ，请使用 <strong>煎饼翻转</strong><em> </em>完成对数组的排序。</p>\n\n<p>一次煎饼翻转的执行过程如下：</p>\n\n<ul>\n\t<li>选择一个整数 <code>k</code> ，<code>1 <= k <= arr.length</code></li>\n\t<li>反转子数组 <code>arr[0...k-1]</code>（<strong>下标从 0 开始</strong>）</li>\n</ul>\n\n<p>例如，<code>arr = [3,2,1,4]</code> ，选择 <code>k = 3</code> 进行一次煎饼翻转，反转子数组 <code>[3,2,1]</code> ，得到 <code>arr = [<strong>1</strong>,<strong>2</strong>,<strong>3</strong>,4]</code> 。</p>\n\n<p>以数组形式返回能使 <code>arr</code> 有序的煎饼翻转操作所对应的 <code>k</code> 值序列。任何将数组排序且翻转次数在 <code>10 * arr.length</code> 范围内的有效答案都将被判断为正确。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>[3,2,4,1]\n<strong>输出：</strong>[4,2,4,3]\n<strong>解释：</strong>\n我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。\n初始状态 arr = [3, 2, 4, 1]\n第一次翻转后（k = 4）：arr = [<strong>1</strong>, <strong>4</strong>, <strong>2</strong>, <strong>3</strong>]\n第二次翻转后（k = 2）：arr = [<strong>4</strong>, <strong>1</strong>, 2, 3]\n第三次翻转后（k = 4）：arr = [<strong>3</strong>, <strong>2</strong>, <strong>1</strong>, <strong>4</strong>]\n第四次翻转后（k = 3）：arr = [<strong>1</strong>, <strong>2</strong>, <strong>3</strong>, 4]，此时已完成排序。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1,2,3]\n<strong>输出：</strong>[]\n<strong>解释：\n</strong>输入已经排序，因此不需要翻转任何内容。\n请注意，其他可能的答案，如 [3，3] ，也将被判断为正确。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= arr.length <= 100</code></li>\n\t<li><code>1 <= arr[i] <= arr.length</code></li>\n\t<li><code>arr</code> 中的所有整数互不相同（即，<code>arr</code> 是从 <code>1</code> 到 <code>arr.length</code> 整数的一个排列）</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 970.强整数",
        "hardRate": "MEDIUM",
        "passRate": "47.00%",
        "problemsUrl": "https://leetcode.cn/problems/powerful-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/powerful-integers/solution",
        "problemsDesc": "<p>给定三个整数 <code>x</code>&nbsp;、&nbsp;<code>y</code>&nbsp;和<em>&nbsp;</em><code>bound</code><em>&nbsp;</em>，返回 <em>值小于或等于&nbsp;<code>bound</code>&nbsp;的所有&nbsp;<strong>强整数</strong>&nbsp;组成的列表</em>&nbsp;。</p>\n\n<p>如果某一整数可以表示为&nbsp;<code>x<sup>i</sup>&nbsp;+ y<sup>j</sup></code>&nbsp;，其中整数&nbsp;<code>i &gt;= 0</code> 且&nbsp;<code>j &gt;= 0</code>，那么我们认为该整数是一个&nbsp;<strong>强整数</strong>&nbsp;。</p>\n\n<p>你可以按 <strong>任何顺序</strong> 返回答案。在你的回答中，每个值 <strong>最多</strong> 出现一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 2, y = 3, bound = 10\n<strong>输出：</strong>[2,3,4,5,7,9,10]\n<strong>解释： </strong>\n2 = 2<sup>0</sup> + 3<sup>0</sup>\n3 = 2<sup>1</sup> + 3<sup>0</sup>\n4 = 2<sup>0</sup> + 3<sup>1</sup>\n5 = 2<sup>1</sup> + 3<sup>1</sup>\n7 = 2<sup>2</sup> + 3<sup>1</sup>\n9 = 2<sup>3</sup> + 3<sup>0</sup>\n10 = 2<sup>0</sup> + 3<sup>2</sup></pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 3, y = 5, bound = 15\n<strong>输出：</strong>[2,4,6,8,10,14]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= x, y &lt;= 100</code></li>\n\t<li><code>0 &lt;= bound &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 971.翻转二叉树以匹配先序遍历",
        "hardRate": "MEDIUM",
        "passRate": "45.57%",
        "problemsUrl": "https://leetcode.cn/problems/flip-binary-tree-to-match-preorder-traversal/",
        "solutionsUrl": "https://leetcode.cn/problems/flip-binary-tree-to-match-preorder-traversal/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点 <code>root</code> ，树中有 <code>n</code> 个节点，每个节点都有一个不同于其他节点且处于 <code>1</code> 到 <code>n</code> 之间的值。</p>\n\n<p>另给你一个由 <code>n</code> 个值组成的行程序列 <code>voyage</code> ，表示 <strong>预期</strong> 的二叉树 <a href=\"https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin\" target=\"_blank\"><strong>先序遍历</strong></a> 结果。</p>\n\n<p>通过交换节点的左右子树，可以 <strong>翻转</strong> 该二叉树中的任意节点。例，翻转节点 1 的效果如下：</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/15/fliptree.jpg\" style=\"width: 400px; height: 187px;\" />\n<p>请翻转 <strong>最少 </strong>的树中节点，使二叉树的 <strong>先序遍历</strong> 与预期的遍历行程 <code>voyage</code> <strong>相匹配</strong> 。 </p>\n\n<p>如果可以，则返回 <strong>翻转的</strong> 所有节点的值的列表。你可以按任何顺序返回答案。如果不能，则返回列表 <code>[-1]</code>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/02/1219-01.png\" style=\"width: 150px; height: 205px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2], voyage = [2,1]\n<strong>输出：</strong>[-1]\n<strong>解释：</strong>翻转节点无法令先序遍历匹配预期行程。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/02/1219-02.png\" style=\"width: 150px; height: 142px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3], voyage = [1,3,2]\n<strong>输出：</strong>[1]\n<strong>解释：</strong>交换节点 2 和 3 来翻转节点 1 ，先序遍历可以匹配预期行程。</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/02/1219-02.png\" style=\"width: 150px; height: 142px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3], voyage = [1,2,3]\n<strong>输出：</strong>[]\n<strong>解释：</strong>先序遍历已经匹配预期行程，所以不需要翻转节点。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数目为 <code>n</code></li>\n\t<li><code>n == voyage.length</code></li>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>1 <= Node.val, voyage[i] <= n</code></li>\n\t<li>树中的所有值 <strong>互不相同</strong></li>\n\t<li><code>voyage</code> 中的所有值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 972.相等的有理数",
        "hardRate": "HARD",
        "passRate": "41.53%",
        "problemsUrl": "https://leetcode.cn/problems/equal-rational-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/equal-rational-numbers/solution",
        "problemsDesc": "<p>给定两个字符串&nbsp;<code>s</code>&nbsp;和&nbsp;<code>t</code>&nbsp;，每个字符串代表一个非负有理数，只有当它们表示相同的数字时才返回 <code>true</code>&nbsp;。字符串中可以使用括号来表示有理数的重复部分。</p>\n\n<p><strong>有理数</strong>&nbsp;最多可以用三个部分来表示：<em>整数部分</em>&nbsp;<code>&lt;IntegerPart&gt;</code>、<em>小数非重复部分</em>&nbsp;<code>&lt;NonRepeatingPart&gt;</code>&nbsp;和<em>小数重复部分</em>&nbsp;<code>&lt;(&gt;&lt;RepeatingPart&gt;&lt;)&gt;</code>。数字可以用以下三种方法之一来表示：</p>\n\n<ul>\n\t<li><code>&lt;IntegerPart&gt;</code>&nbsp;\n\n\t<ul>\n\t\t<li>例：&nbsp;<code>0</code>&nbsp;,<code>12</code>&nbsp;和&nbsp;<code>123</code>&nbsp;</li>\n\t</ul>\n\t</li>\n\t<li><code>&lt;IntegerPart&gt;&lt;.&gt;&lt;NonRepeatingPart&gt;</code>\n\t<ul>\n\t\t<li>例： <code>0.5<font color=\"#333333\"><font face=\"Helvetica Neue, Helvetica, Arial, sans-serif\"><span style=\"font-size:14px\"><span style=\"background-color:#ffffff\">&nbsp;, </span></span></font></font></code><font color=\"#333333\"><font face=\"Helvetica Neue, Helvetica, Arial, sans-serif\"><span style=\"font-size:14px\"><span style=\"background-color:#ffffff\"><code>1.</code>&nbsp;,&nbsp;</span></span></font></font><code>2.12</code>&nbsp;和&nbsp;<code>123.0001</code></li>\n\t</ul>\n\t</li>\n\t<li><code>&lt;IntegerPart&gt;&lt;.&gt;&lt;NonRepeatingPart&gt;&lt;(&gt;&lt;RepeatingPart&gt;&lt;)&gt;</code>&nbsp;\n\t<ul>\n\t\t<li>例： <code>0.1(6)</code> ， <code>1.(9)</code>， <code>123.00(1212)</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>十进制展开的重复部分通常在一对圆括号内表示。例如：</p>\n\n<ul>\n\t<li><code>1 / 6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66)</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0.(52)\", t = \"0.5(25)\"\n<strong>输出：</strong>true\n<strong>解释：</strong>因为 \"0.(52)\" 代表 0.52525252...，而 \"0.5(25)\" 代表 0.52525252525.....，则这两个字符串表示相同的数字。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0.1666(6)\", t = \"0.166(66)\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0.9(9)\", t = \"1.\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\"0.9(9)\" 代表 0.999999999... 永远重复，等于 1 。[<a href=\"https://baike.baidu.com/item/0.999…/5615429?fr=aladdin\" target=\"_blank\">有关说明，请参阅此链接</a>]\n\"1.\" 表示数字 1，其格式正确：(IntegerPart) = \"1\" 且 (NonRepeatingPart) = \"\" 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每个部分仅由数字组成。</li>\n\t<li>整数部分&nbsp;<code>&lt;IntegerPart&gt;</code>&nbsp;不会以零开头。（零本身除外）</li>\n\t<li><code>1 &lt;= &lt;IntegerPart&gt;.length &lt;= 4 </code></li>\n\t<li><code>0 &lt;= &lt;NonRepeatingPart&gt;.length &lt;= 4 </code></li>\n\t<li><code>1 &lt;= &lt;RepeatingPart&gt;.length &lt;= 4 </code></li>\n</ul>\n<span style=\"display:block\"><span style=\"height:0px\"><span style=\"position:absolute\">​​​​​</span></span></span>",
        "isPlus": false
    },
    {
        "problemsName": " 973.最接近原点的 K 个点",
        "hardRate": "MEDIUM",
        "passRate": "65.24%",
        "problemsUrl": "https://leetcode.cn/problems/k-closest-points-to-origin/",
        "solutionsUrl": "https://leetcode.cn/problems/k-closest-points-to-origin/solution",
        "problemsDesc": "<p>给定一个数组 <code>points</code>&nbsp;，其中&nbsp;<code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;表示 <strong>X-Y</strong> 平面上的一个点，并且是一个整数 <code>k</code> ，返回离原点 <code>(0,0)</code> 最近的 <code>k</code> 个点。</p>\n\n<p>这里，平面上两点之间的距离是&nbsp;<strong>欧几里德距离</strong>（&nbsp;<code>√(x<sub>1</sub>&nbsp;- x<sub>2</sub>)<sup>2</sup>&nbsp;+ (y<sub>1</sub>&nbsp;- y<sub>2</sub>)<sup>2</sup></code>&nbsp;）。</p>\n\n<p>你可以按 <strong>任何顺序</strong> 返回答案。除了点坐标的顺序之外，答案 <strong>确保</strong> 是 <strong>唯一</strong> 的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg\" style=\"height: 400px; width: 400px;\" /></p>\n\n<pre>\n<strong>输入：</strong>points = [[1,3],[-2,2]], k = 1\n<strong>输出：</strong>[[-2,2]]\n<strong>解释： </strong>\n(1, 3) 和原点之间的距离为 sqrt(10)，\n(-2, 2) 和原点之间的距离为 sqrt(8)，\n由于 sqrt(8) &lt; sqrt(10)，(-2, 2) 离原点更近。\n我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[3,3],[5,-1],[-2,4]], k = 2\n<strong>输出：</strong>[[3,3],[-2,4]]\n（答案 [[-2,4],[3,3]] 也会被接受。）\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= points.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt; x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt; 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 974.和可被 K 整除的子数组",
        "hardRate": "MEDIUM",
        "passRate": "47.87%",
        "problemsUrl": "https://leetcode.cn/problems/subarray-sums-divisible-by-k/",
        "solutionsUrl": "https://leetcode.cn/problems/subarray-sums-divisible-by-k/solution",
        "problemsDesc": "<p>给定一个整数数组 <code>nums</code>&nbsp;和一个整数 <code>k</code> ，返回其中元素之和可被 <code>k</code>&nbsp;整除的（连续、非空） <strong>子数组</strong> 的数目。</p>\n\n<p><strong>子数组</strong> 是数组的 <strong>连续</strong> 部分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,5,0,-2,-3,1], k = 5\n<strong>输出：</strong>7\n<strong>解释：\n</strong>有 7 个子数组满足其元素之和可被 k = 5 整除：\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [5], k = 9\n<strong>输出:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>2 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 975.奇偶跳",
        "hardRate": "HARD",
        "passRate": "47.80%",
        "problemsUrl": "https://leetcode.cn/problems/odd-even-jump/",
        "solutionsUrl": "https://leetcode.cn/problems/odd-even-jump/solution",
        "problemsDesc": "<p>给定一个整数数组 <code>A</code>，你可以从某一起始索引出发，跳跃一定次数。在你跳跃的过程中，第 1、3、5... 次跳跃称为奇数跳跃，而第 2、4、6... 次跳跃称为偶数跳跃。</p>\n\n<p>你可以按以下方式从索引 <code>i</code>&nbsp;向后跳转到索引 <code>j</code>（其中 <code>i &lt; j</code>）：</p>\n\n<ul>\n\t<li>在进行奇数跳跃时（如，第&nbsp;1，3，5... 次跳跃），你将会跳到索引 <code>j</code>，使得 <code>A[i] &lt;=&nbsp;A[j]</code>，<code>A[j]</code> 是可能的最小值。如果存在多个这样的索引 <code>j</code>，你只能跳到满足要求的<strong>最小</strong>索引 <code>j</code> 上。</li>\n\t<li>在进行偶数跳跃时（如，第&nbsp;2，4，6... 次跳跃），你将会跳到索引&nbsp;<code>j</code>，使得 <code>A[i] &gt;= A[j]</code>，<code>A[j]</code> 是可能的最大值。如果存在多个这样的索引 <code>j</code>，你只能跳到满足要求的<strong>最小</strong>索引 <code>j</code>&nbsp;上。</li>\n\t<li>（对于某些索引 <code>i</code>，可能无法进行合乎要求的跳跃。）</li>\n</ul>\n\n<p>如果从某一索引开始跳跃一定次数（可能是 0 次或多次），就可以到达数组的末尾（索引 <code>A.length - 1</code>），那么该索引就会被认为是好的起始索引。</p>\n\n<p>返回好的起始索引的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[10,13,12,14,15]\n<strong>输出：</strong>2\n<strong>解释： </strong>\n从起始索引 i = 0 出发，我们可以跳到 i = 2，（因为 A[2] 是 A[1]，A[2]，A[3]，A[4] 中大于或等于 A[0] 的最小值），然后我们就无法继续跳下去了。\n从起始索引 i = 1 和 i = 2 出发，我们可以跳到 i = 3，然后我们就无法继续跳下去了。\n从起始索引 i = 3 出发，我们可以跳到 i = 4，到达数组末尾。\n从起始索引 i = 4 出发，我们已经到达数组末尾。\n总之，我们可以从 2 个不同的起始索引（i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre><strong>输入：</strong>[2,3,1,1,4]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n从起始索引 i=0 出发，我们依次可以跳到 i = 1，i = 2，i = 3：\n\n在我们的第一次跳跃（奇数）中，我们先跳到 i = 1，因为 A[1] 是（A[1]，A[2]，A[3]，A[4]）中大于或等于 A[0] 的最小值。\n\n在我们的第二次跳跃（偶数）中，我们从 i = 1 跳到 i = 2，因为 A[2] 是（A[2]，A[3]，A[4]）中小于或等于 A[1] 的最大值。A[3] 也是最大的值，但 2 是一个较小的索引，所以我们只能跳到 i = 2，而不能跳到 i = 3。\n\n在我们的第三次跳跃（奇数）中，我们从 i = 2 跳到 i = 3，因为 A[3] 是（A[3]，A[4]）中大于或等于 A[2] 的最小值。\n\n我们不能从 i = 3 跳到 i = 4，所以起始索引 i = 0 不是好的起始索引。\n\n类似地，我们可以推断：\n从起始索引 i = 1 出发， 我们跳到 i = 4，这样我们就到达数组末尾。\n从起始索引 i = 2 出发， 我们跳到 i = 3，然后我们就不能再跳了。\n从起始索引 i = 3 出发， 我们跳到 i = 4，这样我们就到达数组末尾。\n从起始索引 i = 4 出发，我们已经到达数组末尾。\n总之，我们可以从 3 个不同的起始索引（i = 1, i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>[5,1,3,4,2]\n<strong>输出：</strong>3\n<strong>解释： </strong>\n我们可以从起始索引 1，2，4 出发到达数组末尾。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= A.length &lt;= 20000</code></li>\n\t<li><code>0 &lt;= A[i] &lt; 100000</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 976.三角形的最大周长",
        "hardRate": "EASY",
        "passRate": "57.49%",
        "problemsUrl": "https://leetcode.cn/problems/largest-perimeter-triangle/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-perimeter-triangle/solution",
        "problemsDesc": "<p>给定由一些正数（代表长度）组成的数组 <code>nums</code>&nbsp;，返回 <em>由其中三个长度组成的、<strong>面积不为零</strong>的三角形的最大周长</em>&nbsp;。如果不能形成任何面积不为零的三角形，返回&nbsp;<code>0</code>。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,2]\n<strong>输出：</strong>5\n<strong>解释：</strong>你可以用三个边长组成一个三角形:1 2 2。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,10]\n<strong>输出：</strong>0\n<strong>解释：</strong>\n你不能用边长 1,1,2 来组成三角形。\n不能用边长 1,1,10 来构成三角形。\n不能用边长 1、2 和 10 来构成三角形。\n因为我们不能用任何三条边长来构成一个非零面积的三角形，所以我们返回 0。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 977.有序数组的平方",
        "hardRate": "EASY",
        "passRate": "67.93%",
        "problemsUrl": "https://leetcode.cn/problems/squares-of-a-sorted-array/",
        "solutionsUrl": "https://leetcode.cn/problems/squares-of-a-sorted-array/solution",
        "problemsDesc": "<p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>\n\n<ul>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-4,-1,0,3,10]\n<strong>输出：</strong>[0,1,9,16,100]\n<strong>解释：</strong>平方后，数组变为 [16,1,0,9,100]\n排序后，数组变为 [0,1,9,16,100]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-7,-3,2,3,11]\n<strong>输出：</strong>[4,9,9,49,121]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code><span>1 <= nums.length <= </span>10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>请你<span style=\"color: rgb(36, 41, 46); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial; display: inline !important; float: none;\">设计时间复杂度为 <code>O(n)</code> 的算法解决本问题</span></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 978.最长湍流子数组",
        "hardRate": "MEDIUM",
        "passRate": "47.53%",
        "problemsUrl": "https://leetcode.cn/problems/longest-turbulent-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-turbulent-subarray/solution",
        "problemsDesc": "<p>给定一个整数数组 <code>arr</code>&nbsp;，返回 <code>arr</code>&nbsp;的&nbsp;<em>最大湍流子数组的<strong>长度</strong></em><strong>&nbsp;</strong>。</p>\n\n<p>如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是&nbsp;<strong>湍流子数组</strong>&nbsp;。</p>\n\n<p>更正式地来说，当 <code>arr</code>&nbsp;的子数组&nbsp;<code>A[i], A[i+1], ..., A[j]</code>&nbsp;满足仅满足下列条件时，我们称其为<em>湍流子数组</em>：</p>\n\n<ul>\n\t<li>若&nbsp;<code>i &lt;= k &lt; j</code>&nbsp;：\n\n\t<ul>\n\t\t<li>当 <code>k</code>&nbsp;为奇数时，&nbsp;<code>A[k] &gt; A[k+1]</code>，且</li>\n\t\t<li>当 <code>k</code> 为偶数时，<code>A[k] &lt; A[k+1]</code>；</li>\n\t</ul>\n\t</li>\n\t<li><strong>或 </strong>若&nbsp;<code>i &lt;= k &lt; j</code>&nbsp;：\n\t<ul>\n\t\t<li>当 <code>k</code> 为偶数时，<code>A[k] &gt; A[k+1]</code>&nbsp;，且</li>\n\t\t<li>当 <code>k</code>&nbsp;为奇数时，&nbsp;<code>A[k] &lt; A[k+1]</code>。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [9,4,2,10,7,8,8,1,9]\n<strong>输出：</strong>5\n<strong>解释：</strong>arr[1] &gt; arr[2] &lt; arr[3] &gt; arr[4] &lt; arr[5]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [4,8,12,16]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [100]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 4 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 979.在二叉树中分配硬币",
        "hardRate": "MEDIUM",
        "passRate": "76.06%",
        "problemsUrl": "https://leetcode.cn/problems/distribute-coins-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/distribute-coins-in-binary-tree/solution",
        "problemsDesc": "<p>给你一个有 <code>n</code> 个结点的二叉树的根结点 <code>root</code> ，其中树中每个结点 <code>node</code> 都对应有 <code>node.val</code> 枚硬币。整棵树上一共有 <code>n</code> 枚硬币。</p>\n\n<p>在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。移动可以是从父结点到子结点，或者从子结点移动到父结点。</p>\n\n<p>返回使每个结点上 <strong>只有</strong> 一枚硬币所需的 <strong>最少</strong> 移动次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/18/tree1.png\" style=\"width: 250px; height: 236px;\" />\n<pre>\n<strong>输入：</strong>root = [3,0,0]\n<strong>输出：</strong>2\n<strong>解释：</strong>一枚硬币从根结点移动到左子结点，一枚硬币从根结点移动到右子结点。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/18/tree2.png\" style=\"width: 250px; height: 236px;\" />\n<pre>\n<strong>输入：</strong>root = [0,3,0]\n<strong>输出：</strong>3\n<strong>解释：</strong>将两枚硬币从根结点的左子结点移动到根结点（两次移动）。然后，将一枚硬币从根结点移动到右子结点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目为 <code>n</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= n</code></li>\n\t<li>所有 <code>Node.val</code> 的值之和是 <code>n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 980.不同路径 III",
        "hardRate": "HARD",
        "passRate": "74.15%",
        "problemsUrl": "https://leetcode.cn/problems/unique-paths-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-paths-iii/solution",
        "problemsDesc": "<p>在二维网格 <code>grid</code> 上，有 4 种类型的方格：</p>\n\n<ul>\n\t<li><code>1</code> 表示起始方格。且只有一个起始方格。</li>\n\t<li><code>2</code> 表示结束方格，且只有一个结束方格。</li>\n\t<li><code>0</code> 表示我们可以走过的空方格。</li>\n\t<li><code>-1</code> 表示我们无法跨越的障碍。</li>\n</ul>\n\n<p>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目<strong>。</strong></p>\n\n<p><strong>每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]\n<strong>输出：</strong>2\n<strong>解释：</strong>我们有以下两条路径：\n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\n2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>[[1,0,0,0],[0,0,0,0],[0,0,0,2]]\n<strong>输出：</strong>4\n<strong>解释：</strong>我们有以下四条路径： \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)\n2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)\n3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)\n4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>[[0,1],[2,0]]\n<strong>输出：</strong>0\n<strong>解释：</strong>\n没有一条路能完全穿过每一个空的方格一次。\n请注意，起始和结束方格可以位于网格中的任意位置。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= grid.length * grid[0].length &lt;= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 981.基于时间的键值存储",
        "hardRate": "MEDIUM",
        "passRate": "52.85%",
        "problemsUrl": "https://leetcode.cn/problems/time-based-key-value-store/",
        "solutionsUrl": "https://leetcode.cn/problems/time-based-key-value-store/solution",
        "problemsDesc": "<p>设计一个基于时间的键值数据结构，该结构可以在不同时间戳存储对应同一个键的多个值，并针对特定时间戳检索键对应的值。</p>\n\n<p>实现 <code>TimeMap</code> 类：</p>\n\n<ul>\n\t<li><code>TimeMap()</code> 初始化数据结构对象</li>\n\t<li><code>void set(String key, String value, int timestamp)</code> 存储键 <code>key</code>、值 <code>value</code>，以及给定的时间戳 <code>timestamp</code>。</li>\n\t<li><code>String get(String key, int timestamp)</code>\n\t<ul>\n\t\t<li>返回先前调用 <code>set(key, value, timestamp_prev)</code> 所存储的值，其中 <code>timestamp_prev <= timestamp</code> 。</li>\n\t\t<li>如果有多个这样的值，则返回对应最大的  <code>timestamp_prev</code> 的那个值。</li>\n\t\t<li>如果没有值，则返回空字符串（<code>\"\"</code>）。</li>\n\t</ul>\n\t</li>\n</ul>\n \n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"]\n[[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]\n<strong>输出：</strong>\n[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]\n\n<strong>解释：</strong>\nTimeMap timeMap = new TimeMap();\ntimeMap.set(\"foo\", \"bar\", 1);  // 存储键 \"foo\" 和值 \"bar\" ，时间戳 timestamp = 1   \ntimeMap.get(\"foo\", 1);         // 返回 \"bar\"\ntimeMap.get(\"foo\", 3);         // 返回 \"bar\", 因为在时间戳 3 和时间戳 2 处没有对应 \"foo\" 的值，所以唯一的值位于时间戳 1 处（即 \"bar\"） 。\ntimeMap.set(\"foo\", \"bar2\", 4); // 存储键 \"foo\" 和值 \"bar2\" ，时间戳 timestamp = 4  \ntimeMap.get(\"foo\", 4);         // 返回 \"bar2\"\ntimeMap.get(\"foo\", 5);         // 返回 \"bar2\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= key.length, value.length <= 100</code></li>\n\t<li><code>key</code> 和 <code>value</code> 由小写英文字母和数字组成</li>\n\t<li><code>1 <= timestamp <= 10<sup>7</sup></code></li>\n\t<li><code>set</code> 操作中的时间戳 <code>timestamp</code> 都是严格递增的</li>\n\t<li>最多调用 <code>set</code> 和 <code>get</code> 操作 <code>2 * 10<sup>5</sup></code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 982.按位与为零的三元组",
        "hardRate": "HARD",
        "passRate": "67.29%",
        "problemsUrl": "https://leetcode.cn/problems/triples-with-bitwise-and-equal-to-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/triples-with-bitwise-and-equal-to-zero/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，返回其中 <strong>按位与三元组</strong> 的数目。</p>\n\n<p><strong>按位与三元组</strong> 是由下标 <code>(i, j, k)</code> 组成的三元组，并满足下述全部条件：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; nums.length</code></li>\n\t<li><code>0 &lt;= j &lt; nums.length</code></li>\n\t<li><code>0 &lt;= k &lt; nums.length</code></li>\n\t<li><code>nums[i] &amp; nums[j] &amp; nums[k] == 0</code> ，其中 <code>&amp;</code> 表示按位与运算符。</li>\n</ul>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,3]\n<strong>输出：</strong>12\n<strong>解释：</strong>可以选出如下 i, j, k 三元组：\n(i=0, j=0, k=1) : 2 &amp; 2 &amp; 1\n(i=0, j=1, k=0) : 2 &amp; 1 &amp; 2\n(i=0, j=1, k=1) : 2 &amp; 1 &amp; 1\n(i=0, j=1, k=2) : 2 &amp; 1 &amp; 3\n(i=0, j=2, k=1) : 2 &amp; 3 &amp; 1\n(i=1, j=0, k=0) : 1 &amp; 2 &amp; 2\n(i=1, j=0, k=1) : 1 &amp; 2 &amp; 1\n(i=1, j=0, k=2) : 1 &amp; 2 &amp; 3\n(i=1, j=1, k=0) : 1 &amp; 1 &amp; 2\n(i=1, j=2, k=0) : 1 &amp; 3 &amp; 2\n(i=2, j=0, k=1) : 3 &amp; 2 &amp; 1\n(i=2, j=1, k=0) : 3 &amp; 1 &amp; 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,0,0]\n<strong>输出：</strong>27\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt; 2<sup>16</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 983.最低票价",
        "hardRate": "MEDIUM",
        "passRate": "63.50%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-for-tickets/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-for-tickets/solution",
        "problemsDesc": "<p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为&nbsp;<code>days</code>&nbsp;的数组给出。每一项是一个从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>365</code>&nbsp;的整数。</p>\n\n<p>火车票有 <strong>三种不同的销售方式</strong> ：</p>\n\n<ul>\n\t<li>一张 <strong>为期一天</strong> 的通行证售价为&nbsp;<code>costs[0]</code> 美元；</li>\n\t<li>一张 <strong>为期七天</strong> 的通行证售价为&nbsp;<code>costs[1]</code> 美元；</li>\n\t<li>一张 <strong>为期三十天</strong> 的通行证售价为&nbsp;<code>costs[2]</code> 美元。</li>\n</ul>\n\n<p>通行证允许数天无限制的旅行。 例如，如果我们在第 <code>2</code> 天获得一张 <strong>为期 7 天</strong> 的通行证，那么我们可以连着旅行 7 天：第 <code>2</code> 天、第 <code>3</code> 天、第 <code>4</code> 天、第 <code>5</code> 天、第 <code>6</code> 天、第 <code>7</code> 天和第 <code>8</code> 天。</p>\n\n<p>返回 <em>你想要完成在给定的列表&nbsp;<code>days</code>&nbsp;中列出的每一天的旅行所需要的最低消费&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>days = [1,4,6,7,8,20], costs = [2,7,15]\n<strong>输出：</strong>11\n<strong>解释： </strong>\n例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：\n在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。\n在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。\n在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。\n你总共花了 $11，并完成了你计划的每一天旅行。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\n<strong>输出：</strong>17\n<strong>解释：\n</strong>例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： \n在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。\n在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 \n你总共花了 $17，并完成了你计划的每一天旅行。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= days.length &lt;= 365</code></li>\n\t<li><code>1 &lt;= days[i] &lt;= 365</code></li>\n\t<li><code>days</code>&nbsp;按顺序严格递增</li>\n\t<li><code>costs.length == 3</code></li>\n\t<li><code>1 &lt;= costs[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 984.不含 AAA 或 BBB 的字符串",
        "hardRate": "MEDIUM",
        "passRate": "43.41%",
        "problemsUrl": "https://leetcode.cn/problems/string-without-aaa-or-bbb/",
        "solutionsUrl": "https://leetcode.cn/problems/string-without-aaa-or-bbb/solution",
        "problemsDesc": "<p>给定两个整数 <code>a</code>&nbsp;和 <code>b</code>&nbsp;，返回&nbsp;<strong>任意</strong>&nbsp;字符串 <code>s</code>&nbsp;，要求满足：</p>\n\n<ul>\n\t<li><code>s</code>&nbsp;的长度为 <code>a + b</code>，且正好包含&nbsp;<code>a</code>&nbsp;个 <code>'a'</code>&nbsp;字母与&nbsp;<code>b</code> 个 <code>'b'</code>&nbsp;字母；</li>\n\t<li>子串&nbsp;<code>'aaa'</code>&nbsp;没有出现在 <code>s</code>&nbsp;中；</li>\n\t<li>子串&nbsp;<code>'bbb'</code> 没有出现在 <code>s</code>&nbsp;中。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 1, b = 2\n<strong>输出：</strong>\"abb\"\n<strong>解释：</strong>\"abb\", \"bab\" 和 \"bba\" 都是正确答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 4, b = 1\n<strong>输出：</strong>\"aabaa\"</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= a, b&nbsp;&lt;= 100</code></li>\n\t<li>对于给定的 <code>a</code> 和 <code>b</code>，保证存在满足要求的 <code>s</code>&nbsp;</li>\n</ul>\n<span style=\"display:block\"><span style=\"height:0px\"><span style=\"position:absolute\">​​​</span></span></span>",
        "isPlus": false
    },
    {
        "problemsName": " 985.查询后的偶数和",
        "hardRate": "MEDIUM",
        "passRate": "61.12%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-even-numbers-after-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-even-numbers-after-queries/solution",
        "problemsDesc": "<p>给出一个整数数组&nbsp;<code>A</code>&nbsp;和一个查询数组&nbsp;<code>queries</code>。</p>\n\n<p>对于第&nbsp;<code>i</code>&nbsp;次查询，有&nbsp;<code>val =&nbsp;queries[i][0], index&nbsp;= queries[i][1]</code>，我们会把&nbsp;<code>val</code>&nbsp;加到&nbsp;<code>A[index]</code>&nbsp;上。然后，第&nbsp;<code>i</code>&nbsp;次查询的答案是 <code>A</code> 中偶数值的和。</p>\n\n<p><em>（此处给定的&nbsp;<code>index = queries[i][1]</code>&nbsp;是从 0 开始的索引，每次查询都会永久修改数组&nbsp;<code>A</code>。）</em></p>\n\n<p>返回所有查询的答案。你的答案应当以数组&nbsp;<code>answer</code>&nbsp;给出，<code>answer[i]</code>&nbsp;为第&nbsp;<code>i</code>&nbsp;次查询的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]\n<strong>输出：</strong>[8,6,2,4]\n<strong>解释：</strong>\n开始时，数组为 [1,2,3,4]。\n将 1 加到 A[0] 上之后，数组为 [2,2,3,4]，偶数值之和为 2 + 2 + 4 = 8。\n将 -3 加到 A[1] 上之后，数组为 [2,-1,3,4]，偶数值之和为 2 + 4 = 6。\n将 -4 加到 A[0] 上之后，数组为 [-2,-1,3,4]，偶数值之和为 -2 + 4 = 2。\n将 2 加到 A[3] 上之后，数组为 [-2,-1,3,6]，偶数值之和为 -2 + 6 = 4。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= A.length &lt;= 10000</code></li>\n\t<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10000</code></li>\n\t<li><code>-10000 &lt;= queries[i][0] &lt;= 10000</code></li>\n\t<li><code>0 &lt;= queries[i][1] &lt; A.length</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 986.区间列表的交集",
        "hardRate": "MEDIUM",
        "passRate": "68.48%",
        "problemsUrl": "https://leetcode.cn/problems/interval-list-intersections/",
        "solutionsUrl": "https://leetcode.cn/problems/interval-list-intersections/solution",
        "problemsDesc": "<p>给定两个由一些<strong> 闭区间 </strong>组成的列表，<code>firstList</code> 和 <code>secondList</code> ，其中 <code>firstList[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 而 <code>secondList[j] = [start<sub>j</sub>, end<sub>j</sub>]</code> 。每个区间列表都是成对 <strong>不相交</strong> 的，并且 <strong>已经排序</strong> 。</p>\n\n<p>返回这 <strong>两个区间列表的交集</strong> 。</p>\n\n<p>形式上，<strong>闭区间</strong> <code>[a, b]</code>（其中 <code>a <= b</code>）表示实数 <code>x</code> 的集合，而 <code>a <= x <= b</code> 。</p>\n\n<p>两个闭区间的 <strong>交集</strong> 是一组实数，要么为空集，要么为闭区间。例如，<code>[1, 3]</code> 和 <code>[2, 4]</code> 的交集为 <code>[2, 3]</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/30/interval1.png\" style=\"width: 700px; height: 194px;\" />\n<pre>\n<strong>输入：</strong>firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]\n<strong>输出：</strong>[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>firstList = [[1,3],[5,9]], secondList = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>firstList = [], secondList = [[4,8],[10,12]]\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>firstList = [[1,7]], secondList = [[3,10]]\n<strong>输出：</strong>[[3,7]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= firstList.length, secondList.length <= 1000</code></li>\n\t<li><code>firstList.length + secondList.length >= 1</code></li>\n\t<li><code>0 <= start<sub>i</sub> < end<sub>i</sub> <= 10<sup>9</sup></code></li>\n\t<li><code>end<sub>i</sub> < start<sub>i+1</sub></code></li>\n\t<li><code>0 <= start<sub>j</sub> < end<sub>j</sub> <= 10<sup>9</sup> </code></li>\n\t<li><code>end<sub>j</sub> < start<sub>j+1</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 987.二叉树的垂序遍历",
        "hardRate": "HARD",
        "passRate": "53.79%",
        "problemsUrl": "https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/solution",
        "problemsDesc": "<p>给你二叉树的根结点 <code>root</code> ，请你设计算法计算二叉树的<em> </em><strong>垂序遍历</strong> 序列。</p>\n\n<p>对位于 <code>(row, col)</code> 的每个结点而言，其左右子结点分别位于 <code>(row + 1, col - 1)</code> 和 <code>(row + 1, col + 1)</code> 。树的根结点位于 <code>(0, 0)</code> 。</p>\n\n<p>二叉树的 <strong>垂序遍历</strong> 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。</p>\n\n<p>返回二叉树的 <strong>垂序遍历</strong> 序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg\" style=\"width: 431px; height: 304px;\" />\n<pre>\n<strong>输入：</strong>root = [3,9,20,null,null,15,7]\n<strong>输出：</strong>[[9],[3,15],[20],[7]]\n<strong>解释：</strong>\n列 -1 ：只有结点 9 在此列中。\n列  0 ：只有结点 3 和 15 在此列中，按从上到下顺序。\n列  1 ：只有结点 20 在此列中。\n列  2 ：只有结点 7 在此列中。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg\" style=\"width: 512px; height: 304px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,5,6,7]\n<strong>输出：</strong>[[4],[2],[1,5,6],[3],[7]]\n<strong>解释：</strong>\n列 -2 ：只有结点 4 在此列中。\n列 -1 ：只有结点 2 在此列中。\n列  0 ：结点 1 、5 和 6 都在此列中。\n          1 在上面，所以它出现在前面。\n          5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。\n列  1 ：只有结点 3 在此列中。\n列  2 ：只有结点 7 在此列中。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg\" style=\"width: 512px; height: 304px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,6,5,7]\n<strong>输出：</strong>[[4],[2],[1,5,6],[3],[7]]\n<strong>解释：</strong>\n这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。\n因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中结点数目总数在范围 <code>[1, 1000]</code> 内</li>\n\t<li><code>0 <= Node.val <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 988.从叶结点开始的最小字符串",
        "hardRate": "MEDIUM",
        "passRate": "51.20%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-string-starting-from-leaf/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-string-starting-from-leaf/solution",
        "problemsDesc": "<p>给定一颗根结点为&nbsp;<code>root</code>&nbsp;的二叉树，树中的每一个结点都有一个&nbsp;<code>[0, 25]</code>&nbsp;范围内的值，分别代表字母&nbsp;<code>'a'</code> 到&nbsp;<code>'z'</code>。</p>\n\n<p>返回 <em><strong>按字典序最小</strong> 的字符串，该字符串从这棵树的一个叶结点开始，到根结点结束</em>。</p>\n\n<blockquote>\n<p>注<strong>：</strong>字符串中任何较短的前缀在 <strong>字典序上</strong> 都是 <strong>较小</strong> 的：</p>\n\n<ul>\n\t<li>例如，在字典序上&nbsp;<code>\"ab\"</code> 比&nbsp;<code>\"aba\"</code>&nbsp;要小。叶结点是指没有子结点的结点。&nbsp;</li>\n</ul>\n</blockquote>\n\n<p>节点的叶节点是没有子节点的节点。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/02/tree1.png\" style=\"height: 358px; width: 534px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [0,1,2,3,4,3,4]\n<strong>输出：</strong>\"dba\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2019/01/30/tree2.png\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [25,1,3,1,3,0,2]\n<strong>输出：</strong>\"adz\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2019/02/01/tree3.png\" style=\"height: 513px; width: 490px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [2,2,1,null,1,0,null,0]\n<strong>输出：</strong>\"abc\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给定树的结点数在&nbsp;<code>[1, 8500]</code> 范围内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 25</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 989.数组形式的整数加法",
        "hardRate": "EASY",
        "passRate": "45.93%",
        "problemsUrl": "https://leetcode.cn/problems/add-to-array-form-of-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/add-to-array-form-of-integer/solution",
        "problemsDesc": "<p>整数的 <strong>数组形式</strong> &nbsp;<code>num</code>&nbsp;是按照从左到右的顺序表示其数字的数组。</p>\n\n<ul>\n\t<li>例如，对于 <code>num = 1321</code> ，数组形式是 <code>[1,3,2,1]</code> 。</li>\n</ul>\n\n<p>给定 <code>num</code> ，整数的 <strong>数组形式</strong> ，和整数 <code>k</code> ，返回 <em>整数 <code>num + k</code> 的 <strong>数组形式</strong></em> 。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = [1,2,0,0], k = 34\n<strong>输出：</strong>[1,2,3,4]\n<strong>解释：</strong>1200 + 34 = 1234\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = [2,7,4], k = 181\n<strong>输出：</strong>[4,5,5]\n<strong>解释：</strong>274 + 181 = 455\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = [2,1,5], k = 806\n<strong>输出：</strong>[1,0,2,1]\n<strong>解释：</strong>215 + 806 = 1021\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= num[i] &lt;= 9</code></li>\n\t<li><code>num</code>&nbsp;不包含任何前导零，除了零本身</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 990.等式方程的可满足性",
        "hardRate": "MEDIUM",
        "passRate": "53.48%",
        "problemsUrl": "https://leetcode.cn/problems/satisfiability-of-equality-equations/",
        "solutionsUrl": "https://leetcode.cn/problems/satisfiability-of-equality-equations/solution",
        "problemsDesc": "<p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 <code>equations[i]</code> 的长度为 <code>4</code>，并采用两种不同的形式之一：<code>&quot;a==b&quot;</code> 或&nbsp;<code>&quot;a!=b&quot;</code>。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p>\n\n<p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回&nbsp;<code>true</code>，否则返回 <code>false</code>。&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[&quot;a==b&quot;,&quot;b!=a&quot;]\n<strong>输出：</strong>false\n<strong>解释：</strong>如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>[&quot;b==a&quot;,&quot;a==b&quot;]\n<strong>输出：</strong>true\n<strong>解释：</strong>我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>[&quot;a==b&quot;,&quot;b==c&quot;,&quot;a==c&quot;]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>[&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>[&quot;c==c&quot;,&quot;b==d&quot;,&quot;x!=z&quot;]\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= equations.length &lt;= 500</code></li>\n\t<li><code>equations[i].length == 4</code></li>\n\t<li><code>equations[i][0]</code> 和&nbsp;<code>equations[i][3]</code>&nbsp;是小写字母</li>\n\t<li><code>equations[i][1]</code> 要么是&nbsp;<code>&#39;=&#39;</code>，要么是&nbsp;<code>&#39;!&#39;</code></li>\n\t<li><code>equations[i][2]</code>&nbsp;是&nbsp;<code>&#39;=&#39;</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 991.坏了的计算器",
        "hardRate": "MEDIUM",
        "passRate": "52.28%",
        "problemsUrl": "https://leetcode.cn/problems/broken-calculator/",
        "solutionsUrl": "https://leetcode.cn/problems/broken-calculator/solution",
        "problemsDesc": "<p>在显示着数字&nbsp;<code>startValue</code>&nbsp;的坏计算器上，我们可以执行以下两种操作：</p>\n\n<ul>\n\t<li><strong>双倍（Double）：</strong>将显示屏上的数字乘 2；</li>\n\t<li><strong>递减（Decrement）：</strong>将显示屏上的数字减 <code>1</code> 。</li>\n</ul>\n\n<p>给定两个整数&nbsp;<code>startValue</code>&nbsp;和&nbsp;<code>target</code>&nbsp;。返回显示数字&nbsp;<code>target</code>&nbsp;所需的最小操作数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>startValue = 2, target = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>先进行双倍运算，然后再进行递减运算 {2 -&gt; 4 -&gt; 3}.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>startValue = 5, target = 8\n<strong>输出：</strong>2\n<strong>解释：</strong>先递减，再双倍 {5 -&gt; 4 -&gt; 8}.\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>startValue = 3, target = 10\n<strong>输出：</strong>3\n<strong>解释：</strong>先双倍，然后递减，再双倍 {3 -&gt; 6 -&gt; 5 -&gt; 10}.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= startValue, target &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 992.K 个不同整数的子数组",
        "hardRate": "HARD",
        "passRate": "47.48%",
        "problemsUrl": "https://leetcode.cn/problems/subarrays-with-k-different-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/subarrays-with-k-different-integers/solution",
        "problemsDesc": "<p>给定一个正整数数组 <code>nums</code>和一个整数 <code>k</code>，返回 <code>nums</code> 中 「<strong>好子数组」</strong><em>&nbsp;</em>的数目。</p>\n\n<p>如果 <code>nums</code>&nbsp;的某个子数组中不同整数的个数恰好为 <code>k</code>，则称 <code>nums</code>&nbsp;的这个连续、不一定不同的子数组为 <strong>「</strong><strong>好子数组 」</strong>。</p>\n\n<ul>\n\t<li>例如，<code>[1,2,3,1,2]</code> 中有&nbsp;<code>3</code>&nbsp;个不同的整数：<code>1</code>，<code>2</code>，以及&nbsp;<code>3</code>。</li>\n</ul>\n\n<p><strong>子数组</strong> 是数组的 <strong>连续</strong> 部分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,2,3], k = 2\n<strong>输出：</strong>7\n<strong>解释：</strong>恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,3,4], k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 993.二叉树的堂兄弟节点",
        "hardRate": "EASY",
        "passRate": "55.78%",
        "problemsUrl": "https://leetcode.cn/problems/cousins-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/cousins-in-binary-tree/solution",
        "problemsDesc": "<p>在二叉树中，根节点位于深度 <code>0</code> 处，每个深度为 <code>k</code> 的节点的子节点位于深度 <code>k+1</code> 处。</p>\n\n<p>如果二叉树的两个节点深度相同，但<strong> 父节点不同</strong> ，则它们是一对<em>堂兄弟节点</em>。</p>\n\n<p>我们给出了具有唯一值的二叉树的根节点 <code>root</code> ，以及树中两个不同节点的值 <code>x</code> 和 <code>y</code> 。</p>\n\n<p>只有与值 <code>x</code> 和 <code>y</code> 对应的节点是堂兄弟节点时，才返回 <code>true</code> 。否则，返回 <code>false</code>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：<br />\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png\" style=\"height: 160px; width: 180px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,4], x = 4, y = 3\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 2：<br />\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-02.png\" style=\"height: 160px; width: 201px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,null,4,null,5], x = 5, y = 4\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-03.png\" style=\"height: 160px; width: 156px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,null,4], x = 2, y = 3\n<strong>输出：</strong>false</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉树的节点数介于 <code>2</code> 到 <code>100</code> 之间。</li>\n\t<li>每个节点的值都是唯一的、范围为 <code>1</code> 到 <code>100</code> 的整数。</li>\n</ul>\n\n<p> </p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 994.腐烂的橘子",
        "hardRate": "MEDIUM",
        "passRate": "50.98%",
        "problemsUrl": "https://leetcode.cn/problems/rotting-oranges/",
        "solutionsUrl": "https://leetcode.cn/problems/rotting-oranges/solution",
        "problemsDesc": "<p>在给定的&nbsp;<code>m x n</code>&nbsp;网格<meta charset=\"UTF-8\" />&nbsp;<code>grid</code>&nbsp;中，每个单元格可以有以下三个值之一：</p>\n\n<ul>\n\t<li>值&nbsp;<code>0</code>&nbsp;代表空单元格；</li>\n\t<li>值&nbsp;<code>1</code>&nbsp;代表新鲜橘子；</li>\n\t<li>值&nbsp;<code>2</code>&nbsp;代表腐烂的橘子。</li>\n</ul>\n\n<p>每分钟，腐烂的橘子&nbsp;<strong>周围&nbsp;4 个方向上相邻</strong> 的新鲜橘子都会腐烂。</p>\n\n<p>返回 <em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回&nbsp;<code>-1</code></em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png\" style=\"height: 137px; width: 650px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[2,1,1],[1,1,0],[0,1,1]]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[2,1,1],[0,1,1],[1,0,1]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,2]]\n<strong>输出：</strong>0\n<strong>解释：</strong>因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10</code></li>\n\t<li><code>grid[i][j]</code> 仅为&nbsp;<code>0</code>、<code>1</code>&nbsp;或&nbsp;<code>2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 995.K 连续位的最小翻转次数",
        "hardRate": "HARD",
        "passRate": "53.93%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/solution",
        "problemsDesc": "<p>给定一个二进制数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>\n\n<p><strong>k位翻转</strong> 就是从 <code>nums</code> 中选择一个长度为 <code>k</code> 的 <strong>子数组</strong> ，同时把子数组中的每一个 <code>0</code> 都改成 <code>1</code> ，把子数组中的每一个 <code>1</code> 都改成 <code>0</code> 。</p>\n\n<p>返回数组中不存在 <code>0</code> 所需的最小 <strong>k位翻转</strong> 次数。如果不可能，则返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p><strong>子数组</strong> 是数组的 <strong>连续</strong> 部分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,0], K = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>先翻转 A[0]，然后翻转 A[2]。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,0], K = 2\n<strong>输出：</strong>-1\n<strong>解释：</strong>无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,0,0,1,0,1,1,0], K = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>\n翻转 A[0],A[1],A[2]:&nbsp;A变成 [1,1,1,1,0,1,1,0]\n翻转 A[4],A[5],A[6]:&nbsp;A变成 [1,1,1,1,1,0,0,0]\n翻转 A[5],A[6],A[7]:&nbsp;A变成 [1,1,1,1,1,1,1,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 996.正方形数组的数目",
        "hardRate": "HARD",
        "passRate": "50.37%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-squareful-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-squareful-arrays/solution",
        "problemsDesc": "<p>给定一个非负整数数组&nbsp;<code>A</code>，如果该数组每对相邻元素之和是一个完全平方数，则称这一数组为<em>正方形</em>数组。</p>\n\n<p>返回 A 的正方形排列的数目。两个排列 <code>A1</code> 和 <code>A2</code> 不同的充要条件是存在某个索引 <code>i</code>，使得 A1[i] != A2[i]。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[1,17,8]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n[1,8,17] 和 [17,8,1] 都是有效的排列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>[2,2,2]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= A.length &lt;= 12</code></li>\n\t<li><code>0 &lt;= A[i] &lt;= 1e9</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 997.找到小镇的法官",
        "hardRate": "EASY",
        "passRate": "51.84%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-town-judge/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-town-judge/solution",
        "problemsDesc": "<p>小镇里有 <code>n</code> 个人，按从 <code>1</code> 到 <code>n</code> 的顺序编号。传言称，这些人中有一个暗地里是小镇法官。</p>\n\n<p>如果小镇法官真的存在，那么：</p>\n\n<ol>\n\t<li>小镇法官不会信任任何人。</li>\n\t<li>每个人（除了小镇法官）都信任这位小镇法官。</li>\n\t<li>只有一个人同时满足属性 <strong>1</strong> 和属性 <strong>2</strong> 。</li>\n</ol>\n\n<p>给你一个数组 <code>trust</code> ，其中 <code>trust[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示编号为 <code>a<sub>i</sub></code> 的人信任编号为 <code>b<sub>i</sub></code> 的人。</p>\n\n<p>如果小镇法官存在并且可以确定他的身份，请返回该法官的编号；否则，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, trust = [[1,2]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, trust = [[1,3],[2,3]]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, trust = [[1,3],[2,3],[3,1]]\n<strong>输出：</strong>-1\n</pre>\n&nbsp;\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= trust.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>trust[i].length == 2</code></li>\n\t<li><code>trust</code> 中的所有<code>trust[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> <strong>互不相同</strong></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 998.最大二叉树 II",
        "hardRate": "MEDIUM",
        "passRate": "68.72%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-binary-tree-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-binary-tree-ii/solution",
        "problemsDesc": "<p><strong>最大树</strong> 定义：一棵树，并满足：其中每个节点的值都大于其子树中的任何其他值。</p>\n\n<p>给你最大树的根节点 <code>root</code> 和一个整数 <code>val</code> 。</p>\n\n<p>就像 <a href=\"https://leetcode.cn/problems/maximum-binary-tree/\" target=\"_blank\">之前的问题</a> 那样，给定的树是利用 <code>Construct(a)</code>&nbsp;例程从列表&nbsp;<code>a</code>（<code>root = Construct(a)</code>）递归地构建的：</p>\n\n<ul>\n\t<li>如果 <code>a</code> 为空，返回&nbsp;<code>null</code> 。</li>\n\t<li>否则，令&nbsp;<code>a[i]</code> 作为 <code>a</code> 的最大元素。创建一个值为&nbsp;<code>a[i]</code>&nbsp;的根节点 <code>root</code> 。</li>\n\t<li><code>root</code>&nbsp;的左子树将被构建为&nbsp;<code>Construct([a[0], a[1], ..., a[i - 1]])</code> 。</li>\n\t<li><code>root</code>&nbsp;的右子树将被构建为&nbsp;<code>Construct([a[i + 1], a[i + 2], ..., a[a.length - 1]])</code> 。</li>\n\t<li>返回&nbsp;<code>root</code> 。</li>\n</ul>\n\n<p>请注意，题目没有直接给出 <code>a</code> ，只是给出一个根节点&nbsp;<code>root = Construct(a)</code> 。</p>\n\n<p>假设 <code>b</code> 是 <code>a</code> 的副本，并在末尾附加值 <code>val</code>。题目数据保证 <code>b</code> 中的值互不相同。</p>\n\n<p>返回&nbsp;<code>Construct(b)</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-1-1.png\" style=\"height: 160px; width: 159px;\" /><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-1-2.png\" style=\"height: 160px; width: 169px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [4,1,3,null,null,2], val = 5\n<strong>输出：</strong>[5,4,null,1,3,null,null,2]\n<strong>解释：</strong>a = [1,4,2,3], b = [1,4,2,3,5]</pre>\n\n<p><strong>示例 2：<br />\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-2-1.png\" style=\"height: 160px; width: 180px;\" /><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-2-2.png\" style=\"height: 160px; width: 214px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [5,2,4,null,1], val = 3\n<strong>输出：</strong>[5,2,4,null,1,null,3]\n<strong>解释：</strong>a = [2,1,5,4], b = [2,1,5,4,3]</pre>\n\n<p><strong>示例 3：<br />\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-3-1.png\" style=\"height: 160px; width: 180px;\" /><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-3-2.png\" style=\"height: 160px; width: 201px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [5,2,3,null,1], val = 4\n<strong>输出：</strong>[5,2,4,null,1,3]\n<strong>解释：</strong>a = [2,1,5,3], b = [2,1,5,3,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[1, 100]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 100</code></li>\n\t<li>树中的所有值 <strong>互不相同</strong></li>\n\t<li><code>1 &lt;= val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 999.可以被一步捕获的棋子数",
        "hardRate": "EASY",
        "passRate": "69.32%",
        "problemsUrl": "https://leetcode.cn/problems/available-captures-for-rook/",
        "solutionsUrl": "https://leetcode.cn/problems/available-captures-for-rook/solution",
        "problemsDesc": "<p>在一个 8 x 8 的棋盘上，有一个白色的车（<code>Rook</code>），用字符 <code>&#39;R&#39;</code> 表示。棋盘上还可能存在空方块，白色的象（<code>Bishop</code>）以及黑色的卒（<code>pawn</code>），分别用字符 <code>&#39;.&#39;</code>，<code>&#39;B&#39;</code> 和 <code>&#39;p&#39;</code> 表示。不难看出，大写字符表示的是白棋，小写字符表示的是黑棋。</p>\n\n<p>车按国际象棋中的规则移动。东，西，南，北四个基本方向任选其一，然后一直向选定的方向移动，直到满足下列四个条件之一：</p>\n\n<ul>\n\t<li>棋手选择主动停下来。</li>\n\t<li>棋子因到达棋盘的边缘而停下。</li>\n\t<li>棋子移动到某一方格来捕获位于该方格上敌方（黑色）的卒，停在该方格内。</li>\n\t<li>车不能进入/越过已经放有其他友方棋子（白色的象）的方格，停在友方棋子前。</li>\n</ul>\n\n<p>你现在可以控制车移动一次，请你统计有多少敌方的卒处于你的捕获范围内（即，可以被一步捕获的棋子数）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_1_improved.PNG\" style=\"height: 305px; width: 300px;\"></p>\n\n<pre><strong>输入：</strong>[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]\n<strong>输出：</strong>3\n<strong>解释：\n</strong>在本例中，车能够捕获所有的卒。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_2_improved.PNG\" style=\"height: 306px; width: 300px;\"></p>\n\n<pre><strong>输入：</strong>[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;R&quot;,&quot;B&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]\n<strong>输出：</strong>0\n<strong>解释：\n</strong>象阻止了车捕获任何卒。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_3_improved.PNG\" style=\"height: 305px; width: 300px;\"></p>\n\n<pre><strong>输入：</strong>[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]\n<strong>输出：</strong>3\n<strong>解释： </strong>\n车可以捕获位置 b5，d6 和 f5 的卒。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>board.length == board[i].length == 8</code></li>\n\t<li><code>board[i][j]</code> 可以是&nbsp;<code>&#39;R&#39;</code>，<code>&#39;.&#39;</code>，<code>&#39;B&#39;</code>&nbsp;或&nbsp;<code>&#39;p&#39;</code></li>\n\t<li>只有一个格子上存在&nbsp;<code>board[i][j] == &#39;R&#39;</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1000.合并石头的最低成本",
        "hardRate": "HARD",
        "passRate": "53.62%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-merge-stones/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-merge-stones/solution",
        "problemsDesc": "<p>有 <code>n</code> 堆石头排成一排，第 <code>i</code> 堆中有&nbsp;<code>stones[i]</code>&nbsp;块石头。</p>\n\n<p>每次 <strong>移动</strong> 需要将 <strong>连续的</strong> <code>k</code> 堆石头合并为一堆，而这次移动的成本为这 <code>k</code> 堆中石头的总数。</p>\n\n<p>返回把所有石头合并成一堆的最低成本。如果无法合并成一堆，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [3,2,4,1], K = 2\n<strong>输出：</strong>20\n<strong>解释：</strong>\n从 [3, 2, 4, 1] 开始。\n合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。\n合并 [4, 1]，成本为 5，剩下 [5, 5]。\n合并 [5, 5]，成本为 10，剩下 [10]。\n总成本 20，这是可能的最小值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [3,2,4,1], K = 3\n<strong>输出：</strong>-1\n<strong>解释：</strong>任何合并操作后，都会剩下 2 堆，我们无法再进行合并。所以这项任务是不可能完成的。.\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [3,5,1,2,6], K = 3\n<strong>输出：</strong>25\n<strong>解释：</strong>\n从 [3, 5, 1, 2, 6] 开始。\n合并 [5, 1, 2]，成本为 8，剩下 [3, 8, 6]。\n合并 [3, 8, 6]，成本为 17，剩下 [17]。\n总成本 25，这是可能的最小值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == stones.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n\t<li><code>1 &lt;= stones[i] &lt;= 100</code></li>\n\t<li><code>2 &lt;= k &lt;= 30</code></li>\n</ul>\n",
        "isPlus": false
    }
]