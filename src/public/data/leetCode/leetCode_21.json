[
    {
        "problemsName": " 1501.可以放心投资的国家",
        "hardRate": "MEDIUM",
        "passRate": "58.13%",
        "problemsUrl": "https://leetcode.cn/problems/countries-you-can-safely-invest-in/",
        "solutionsUrl": "https://leetcode.cn/problems/countries-you-can-safely-invest-in/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1502.判断能否形成等差数列",
        "hardRate": "EASY",
        "passRate": "69.37%",
        "problemsUrl": "https://leetcode.cn/problems/can-make-arithmetic-progression-from-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/can-make-arithmetic-progression-from-sequence/solution",
        "problemsDesc": "<p>给你一个数字数组 <code>arr</code> 。</p>\n\n<p>如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数列就称为 <strong>等差数列</strong> 。</p>\n\n<p>如果可以重新排列数组形成等差数列，请返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,5,1]\n<strong>输出：</strong>true\n<strong>解释：</strong>对数组重新排序得到 [1,3,5] 或者 [5,3,1] ，任意相邻两项的差分别为 2 或 -2 ，可以形成等差数列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,4]\n<strong>输出：</strong>false\n<strong>解释：</strong>无法通过重新排序得到等差数列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>-10^6 &lt;= arr[i] &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1503.所有蚂蚁掉下来前的最后一刻",
        "hardRate": "MEDIUM",
        "passRate": "53.78%",
        "problemsUrl": "https://leetcode.cn/problems/last-moment-before-all-ants-fall-out-of-a-plank/",
        "solutionsUrl": "https://leetcode.cn/problems/last-moment-before-all-ants-fall-out-of-a-plank/solution",
        "problemsDesc": "<p>有一块木板，长度为 <code>n</code> 个 <strong>单位</strong> 。一些蚂蚁在木板上移动，每只蚂蚁都以 <strong>每秒一个单位</strong> 的速度移动。其中，一部分蚂蚁向 <strong>左</strong> 移动，其他蚂蚁向 <strong>右</strong> 移动。</p>\n\n<p>当两只向 <strong>不同</strong> 方向移动的蚂蚁在某个点相遇时，它们会同时改变移动方向并继续移动。假设更改方向不会花费任何额外时间。</p>\n\n<p>而当蚂蚁在某一时刻 <code>t</code> 到达木板的一端时，它立即从木板上掉下来。</p>\n\n<p>给你一个整数 <code>n</code> 和两个整数数组 <code>left</code> 以及 <code>right</code> 。两个数组分别标识向左或者向右移动的蚂蚁在 <code>t = 0</code> 时的位置。请你返回最后一只蚂蚁从木板上掉下来的时刻。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/06/17/ants.jpg\" style=\"height: 610px; width: 450px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 4, left = [4,3], right = [0,1]\n<strong>输出：</strong>4\n<strong>解释：</strong>如上图所示：\n-下标 0 处的蚂蚁命名为 A 并向右移动。\n-下标 1 处的蚂蚁命名为 B 并向右移动。\n-下标 3 处的蚂蚁命名为 C 并向左移动。\n-下标 4 处的蚂蚁命名为 D 并向左移动。\n请注意，蚂蚁在木板上的最后时刻是 t = 4 秒，之后蚂蚁立即从木板上掉下来。（也就是说在 t = 4.0000000001 时，木板上没有蚂蚁）。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/06/17/ants2.jpg\" style=\"height: 101px; width: 639px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 7, left = [], right = [0,1,2,3,4,5,6,7]\n<strong>输出：</strong>7\n<strong>解释：</strong>所有蚂蚁都向右移动，下标为 0 的蚂蚁需要 7 秒才能从木板上掉落。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/06/17/ants3.jpg\" style=\"height: 100px; width: 639px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 7, left = [0,1,2,3,4,5,6,7], right = []\n<strong>输出：</strong>7\n<strong>解释：</strong>所有蚂蚁都向左移动，下标为 7 的蚂蚁需要 7 秒才能从木板上掉落。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^4</code></li>\n\t<li><code>0 &lt;= left.length &lt;= n + 1</code></li>\n\t<li><code>0 &lt;= left[i] &lt;= n</code></li>\n\t<li><code>0 &lt;= right.length &lt;= n + 1</code></li>\n\t<li><code>0 &lt;= right[i] &lt;= n</code></li>\n\t<li><code>1 &lt;= left.length + right.length &lt;= n + 1</code></li>\n\t<li><code>left</code> 和 <code>right</code> 中的所有值都是唯一的，并且每个值 <strong>只能出现在二者之一</strong> 中。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1504.统计全 1 子矩形",
        "hardRate": "MEDIUM",
        "passRate": "62.48%",
        "problemsUrl": "https://leetcode.cn/problems/count-submatrices-with-all-ones/",
        "solutionsUrl": "https://leetcode.cn/problems/count-submatrices-with-all-ones/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的二进制矩阵&nbsp;<code>mat</code>&nbsp;，请你返回有多少个&nbsp;<strong>子矩形</strong>&nbsp;的元素全部都是 1 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/27/ones1-grid.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1,0,1],[1,1,0],[1,1,0]]\n<strong>输出：</strong>13\n<strong>解释：\n</strong>有 <strong>6</strong>&nbsp;个 1x1 的矩形。\n有 <strong>2</strong> 个 1x2 的矩形。\n有 <strong>3</strong> 个 2x1 的矩形。\n有 <strong>1</strong> 个 2x2 的矩形。\n有 <strong>1</strong> 个 3x1 的矩形。\n矩形数目总共 = 6 + 2 + 3 + 1 + 1 = <strong>13</strong>&nbsp;。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/10/27/ones2-grid.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[0,1,1,0],[0,1,1,1],[1,1,1,0]]\n<strong>输出：</strong>24\n<strong>解释：</strong>\n有 <strong>8</strong> 个 1x1 的子矩形。\n有 <strong>5</strong> 个 1x2 的子矩形。\n有 <strong>2</strong> 个 1x3 的子矩形。\n有 <strong>4</strong> 个 2x1 的子矩形。\n有 <strong>2</strong> 个 2x2 的子矩形。\n有 <strong>2</strong> 个 3x1 的子矩形。\n有 <strong>1</strong> 个 3x2 的子矩形。\n矩形数目总共 = 8 + 5 + 2 + 4 + 2 + 2 + 1 = <strong>24</strong><strong> 。</strong>\n\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 150</code></li>\n\t<li><code>mat[i][j]</code>&nbsp;仅包含&nbsp;<code>0</code>&nbsp;或&nbsp;<code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1505.最多 K 次交换相邻数位后得到的最小整数",
        "hardRate": "HARD",
        "passRate": "39.88%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>num</code> 和一个整数&nbsp;<code>k</code> 。其中，<code>num</code> 表示一个很大的整数，字符串中的每个字符依次对应整数上的各个 <strong>数位</strong> 。</p>\n\n<p>你可以交换这个整数相邻数位的数字 <strong>最多</strong>&nbsp;<code>k</code>&nbsp;次。</p>\n\n<p>请你返回你能得到的最小整数，并以字符串形式返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/06/17/q4_1.jpg\" style=\"height:40px; width:500px\" /></p>\n\n<pre>\n<strong>输入：</strong>num = &quot;4321&quot;, k = 4\n<strong>输出：</strong>&quot;1342&quot;\n<strong>解释：</strong>4321 通过 4 次交换相邻数位得到最小整数的步骤如上图所示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = &quot;100&quot;, k = 1\n<strong>输出：</strong>&quot;010&quot;\n<strong>解释：</strong>输出可以包含前导 0 ，但输入保证不会有前导 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = &quot;36789&quot;, k = 1000\n<strong>输出：</strong>&quot;36789&quot;\n<strong>解释：</strong>不需要做任何交换。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = &quot;22&quot;, k = 22\n<strong>输出：</strong>&quot;22&quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = &quot;9438957234785635408&quot;, k = 23\n<strong>输出：</strong>&quot;0345989723478563548&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 30000</code></li>\n\t<li><code>num</code>&nbsp;只包含&nbsp;<strong>数字</strong>&nbsp;且不含有<strong>&nbsp;前导 0&nbsp;</strong>。</li>\n\t<li><code>1 &lt;= k &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1506.找到 N 叉树的根节点",
        "hardRate": "MEDIUM",
        "passRate": "81.32%",
        "problemsUrl": "https://leetcode.cn/problems/find-root-of-n-ary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/find-root-of-n-ary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1507.转变日期格式",
        "hardRate": "EASY",
        "passRate": "58.96%",
        "problemsUrl": "https://leetcode.cn/problems/reformat-date/",
        "solutionsUrl": "https://leetcode.cn/problems/reformat-date/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>date</code>&nbsp;，它的格式为&nbsp;<code>Day Month Year</code>&nbsp;，其中：</p>\n\n<ul>\n\t<li><code>Day</code>&nbsp;是集合&nbsp;<code>{&quot;1st&quot;, &quot;2nd&quot;, &quot;3rd&quot;, &quot;4th&quot;, ..., &quot;30th&quot;, &quot;31st&quot;}</code>&nbsp;中的一个元素。</li>\n\t<li><code>Month</code>&nbsp;是集合&nbsp;<code>{&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;}</code>&nbsp;中的一个元素。</li>\n\t<li><code>Year</code>&nbsp;的范围在 ​<code>[1900, 2100]</code>&nbsp;之间。</li>\n</ul>\n\n<p>请你将字符串转变为&nbsp;<code>YYYY-MM-DD</code>&nbsp;的格式，其中：</p>\n\n<ul>\n\t<li><code>YYYY</code>&nbsp;表示 4 位的年份。</li>\n\t<li><code>MM</code>&nbsp;表示 2 位的月份。</li>\n\t<li><code>DD</code>&nbsp;表示 2 位的天数。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>date = &quot;20th Oct 2052&quot;\n<strong>输出：</strong>&quot;2052-10-20&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>date = &quot;6th Jun 1933&quot;\n<strong>输出：</strong>&quot;1933-06-06&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>date = &quot;26th May 1960&quot;\n<strong>输出：</strong>&quot;1960-05-26&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给定日期保证是合法的，所以不需要处理异常输入。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1508.子数组和排序后的区间和",
        "hardRate": "MEDIUM",
        "passRate": "57.70%",
        "problemsUrl": "https://leetcode.cn/problems/range-sum-of-sorted-subarray-sums/",
        "solutionsUrl": "https://leetcode.cn/problems/range-sum-of-sorted-subarray-sums/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>nums</code>&nbsp;，它包含&nbsp;<code>n</code>&nbsp;个正整数。你需要计算所有非空连续子数组的和，并将它们按升序排序，得到一个新的包含&nbsp;<code>n * (n + 1) / 2</code>&nbsp;个数字的数组。</p>\n\n<p>请你返回在新数组中下标为<em>&nbsp;</em><code>left</code>&nbsp;到&nbsp;<code>right</code> <strong>（下标从 1 开始）</strong>的所有数字和（包括左右端点）。由于答案可能很大，请你将它对 10^9 + 7 取模后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4], n = 4, left = 1, right = 5\n<strong>输出：</strong>13 \n<strong>解释：</strong>所有的子数组和为 1, 3, 6, 10, 2, 5, 9, 3, 7, 4 。将它们升序排序后，我们得到新的数组 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。下标从 le = 1 到 ri = 5 的和为 1 + 2 + 3 + 3 + 4 = 13 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4], n = 4, left = 3, right = 4\n<strong>输出：</strong>6\n<strong>解释：</strong>给定数组与示例 1 一样，所以新数组为 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。下标从 le = 3 到 ri = 4 的和为 3 + 3 = 6 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4], n = 4, left = 1, right = 10\n<strong>输出：</strong>50\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^3</code></li>\n\t<li><code>nums.length == n</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= left &lt;= right&nbsp;&lt;= n * (n + 1) / 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1509.三次操作后最大值与最小值的最小差",
        "hardRate": "MEDIUM",
        "passRate": "55.46%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>每次操作你可以选择&nbsp;<code>nums</code>&nbsp;中的任意一个元素并将它改成 <strong>任意值</strong> 。</p>\n\n<p>在&nbsp;<strong>执行最多三次移动后&nbsp;</strong>，返回&nbsp;<code>nums</code>&nbsp;中最大值与最小值的最小差值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,3,2,4]\n<strong>输出：</strong>0\n<strong>解释：</strong>我们最多可以走 3 步。\n第一步，将 2 变为 3 。 nums 变成 [5,3,3,4] 。\n第二步，将 4 改为 3 。 nums 变成 [5,3,3,3] 。\n第三步，将 5 改为 3 。 nums 变成 [3,3,3,3] 。\n执行 3 次移动后，最小值和最大值之间的差值为 3 - 3 = 0 。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5,0,10,14]\n<strong>输出：</strong>1\n<strong>解释：</strong>我们最多可以走 3 步。\n第一步，将 5 改为 0 。 nums变成 [1,0,0,10,14] 。\n第二步，将 10 改为 0 。 nums变成 [1,0,0,0,14] 。\n第三步，将 14 改为 1 。 nums变成 [1,0,0,0,1] 。\n执行 3 步后，最小值和最大值之间的差值为 1 - 0 = 1 。\n可以看出，没有办法可以在 3 步内使差值变为0。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,100,20]\n<strong>输出：</strong>0\n<strong>解释：</strong>我们最多可以走 3 步。\n第一步，将 100 改为 7 。 nums 变成 [3,7,20] 。\n第二步，将 20 改为 7 。 nums 变成 [3,7,7] 。\n第三步，将 3 改为 7 。 nums 变成 [7,7,7] 。\n执行 3 步后，最小值和最大值之间的差值是 7 - 7 = 0。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1510.石子游戏 IV",
        "hardRate": "HARD",
        "passRate": "60.19%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game-iv/solution",
        "problemsDesc": "<p>Alice 和 Bob 两个人轮流玩一个游戏，Alice 先手。</p>\n\n<p>一开始，有 <code>n</code>&nbsp;个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 <strong>任意</strong>&nbsp;非零 <strong>平方数</strong>&nbsp;个石子。</p>\n\n<p>如果石子堆里没有石子了，则无法操作的玩家输掉游戏。</p>\n\n<p>给你正整数&nbsp;<code>n</code>&nbsp;，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回&nbsp;<code>True</code>&nbsp;，否则返回&nbsp;<code>False</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>true\n<strong>解释：</strong>Alice 拿走 1 个石子并赢得胜利，因为 Bob 无法进行任何操作。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>false\n<strong>解释：</strong>Alice 只能拿走 1 个石子，然后 Bob 拿走最后一个石子并赢得胜利（2 -&gt; 1 -&gt; 0）。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>true\n<strong>解释：</strong>n 已经是一个平方数，Alice 可以一次全拿掉 4 个石子并赢得胜利（4 -&gt; 0）。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 7\n<strong>输出：</strong>false\n<strong>解释：</strong>当 Bob 采取最优策略时，Alice 无法赢得比赛。\n如果 Alice 一开始拿走 4 个石子， Bob 会拿走 1 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 0）。\n如果 Alice 一开始拿走 1 个石子， Bob 会拿走 4 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -&gt; 6 -&gt; 2 -&gt; 1 -&gt; 0）。</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 17\n<strong>输出：</strong>false\n<strong>解释：</strong>如果 Bob 采取最优策略，Alice 无法赢得胜利。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1511.消费者下单频率",
        "hardRate": "EASY",
        "passRate": "68.75%",
        "problemsUrl": "https://leetcode.cn/problems/customer-order-frequency/",
        "solutionsUrl": "https://leetcode.cn/problems/customer-order-frequency/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1512.好数对的数目",
        "hardRate": "EASY",
        "passRate": "84.37%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-good-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-good-pairs/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。</p>\n\n<p>如果一组数字 <code>(i,j)</code> 满足 <code>nums[i]</code> == <code>nums[j]</code> 且 <code>i</code> &lt; <code>j</code> ，就可以认为这是一组 <strong>好数对</strong> 。</p>\n\n<p>返回好数对的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,1,1,3]\n<strong>输出：</strong>4\n<strong>解释：</strong>有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,1,1]\n<strong>输出：</strong>6\n<strong>解释：</strong>数组中的每组数字都是好数对</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1513.仅含 1 的子串数",
        "hardRate": "MEDIUM",
        "passRate": "39.56%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-substrings-with-only-1s/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-substrings-with-only-1s/solution",
        "problemsDesc": "<p>给你一个二进制字符串 <code>s</code>（仅由 &#39;0&#39; 和 &#39;1&#39; 组成的字符串）。</p>\n\n<p>返回所有字符都为 1 的子字符串的数目。</p>\n\n<p>由于答案可能很大，请你将它对 10^9 + 7 取模后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;0110111&quot;\n<strong>输出</strong>：9\n<strong>解释：</strong>共有 9 个子字符串仅由 &#39;1&#39; 组成\n&quot;1&quot; -&gt; 5 次\n&quot;11&quot; -&gt; 3 次\n&quot;111&quot; -&gt; 1 次</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;101&quot;\n<strong>输出：</strong>2\n<strong>解释：</strong>子字符串 &quot;1&quot; 在 s 中共出现 2 次\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;111111&quot;\n<strong>输出：</strong>21\n<strong>解释：</strong>每个子字符串都仅由 &#39;1&#39; 组成\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;000&quot;\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s[i] == &#39;0&#39;</code> 或 <code>s[i] == &#39;1&#39;</code></li>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1514.概率最大的路径",
        "hardRate": "MEDIUM",
        "passRate": "40.75%",
        "problemsUrl": "https://leetcode.cn/problems/path-with-maximum-probability/",
        "solutionsUrl": "https://leetcode.cn/problems/path-with-maximum-probability/solution",
        "problemsDesc": "<p>给你一个由 <code>n</code> 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 <code>edges[i] = [a, b]</code> 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 <code>succProb[i]</code> 。</p>\n\n<p>指定两个节点分别作为起点 <code>start</code> 和终点 <code>end</code> ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。</p>\n\n<p>如果不存在从 <code>start</code> 到 <code>end</code> 的路径，请 <strong>返回 0</strong> 。只要答案与标准答案的误差不超过 <strong>1e-5 </strong>，就会被视作正确答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex1.png\" style=\"height: 186px; width: 187px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2\n<strong>输出：</strong>0.25000\n<strong>解释：</strong>从起点到终点有两条路径，其中一条的成功概率为 0.2 ，而另一条为 0.5 * 0.5 = 0.25\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex2.png\" style=\"height: 186px; width: 189px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2\n<strong>输出：</strong>0.30000\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex3.png\" style=\"height: 191px; width: 215px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2\n<strong>输出：</strong>0.00000\n<strong>解释：</strong>节点 0 和 节点 2 之间不存在路径\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10^4</code></li>\n\t<li><code>0 &lt;= start, end &lt; n</code></li>\n\t<li><code>start != end</code></li>\n\t<li><code>0 &lt;= a, b &lt; n</code></li>\n\t<li><code>a != b</code></li>\n\t<li><code>0 &lt;= succProb.length == edges.length &lt;= 2*10^4</code></li>\n\t<li><code>0 &lt;= succProb[i] &lt;= 1</code></li>\n\t<li>每两个节点之间最多有一条边</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1515.服务中心的最佳位置",
        "hardRate": "HARD",
        "passRate": "35.26%",
        "problemsUrl": "https://leetcode.cn/problems/best-position-for-a-service-centre/",
        "solutionsUrl": "https://leetcode.cn/problems/best-position-for-a-service-centre/solution",
        "problemsDesc": "<p>一家快递公司希望在新城市建立新的服务中心。公司统计了该城市所有客户在二维地图上的坐标，并希望能够以此为依据为新的服务中心选址：使服务中心 <strong>到所有客户的欧几里得距离的总和最小</strong> 。</p>\n\n<p>给你一个数组 <code>positions</code> ，其中 <code>positions[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示第 <code>i</code> 个客户在二维地图上的位置，返回到所有客户的 <strong>欧几里得距离的最小总和 。</strong></p>\n\n<p>换句话说，请你为服务中心选址，该位置的坐标 <code>[x<sub>centre</sub>, y<sub>centre</sub>]</code> 需要使下面的公式取到最小值：</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/q4_edited.jpg\" /></p>\n\n<p>与真实值误差在 <code>10<sup>-5</sup></code>之内的答案将被视作正确答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/q4_e1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>positions = [[0,1],[1,0],[1,2],[2,1]]\n<strong>输出：</strong>4.00000\n<strong>解释：</strong>如图所示，你可以选 [x<sub>centre</sub>, y<sub>centre</sub>] = [1, 1] 作为新中心的位置，这样一来到每个客户的距离就都是 1，所有距离之和为 4 ，这也是可以找到的最小值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/q4_e3.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>positions = [[1,1],[3,3]]\n<strong>输出：</strong>2.82843\n<strong>解释：</strong>欧几里得距离可能的最小总和为 sqrt(2) + sqrt(2) = 2.82843\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= positions.length &lt;= 50</code></li>\n\t<li><code>positions[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1516.移动 N 叉树的子树",
        "hardRate": "HARD",
        "passRate": "55.87%",
        "problemsUrl": "https://leetcode.cn/problems/move-sub-tree-of-n-ary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/move-sub-tree-of-n-ary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1517.查找拥有有效邮箱的用户",
        "hardRate": "EASY",
        "passRate": "50.49%",
        "problemsUrl": "https://leetcode.cn/problems/find-users-with-valid-e-mails/",
        "solutionsUrl": "https://leetcode.cn/problems/find-users-with-valid-e-mails/solution",
        "problemsDesc": "<p>用户表：&nbsp;Users</p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| user_id       | int     |\n| name          | varchar |\n| mail          | varchar | \n+---------------+---------+\nuser_id （用户 ID）是该表的主键。\n这个表包含用户在某网站上注册的信息。有些邮箱是无效的。</pre>\n\n<p>&nbsp;</p>\n\n<p>写一条&nbsp;SQL 语句，查询拥有<strong>有效邮箱</strong>的用户。</p>\n\n<p>有效的邮箱包含符合下列条件的前缀名和域名：</p>\n\n<ul>\n\t<li><strong>前缀名</strong>是包含字母（大写或小写）、数字、下划线&nbsp;<code>&#39;_&#39;</code>、句点&nbsp;<code>&#39;.&#39;</code>&nbsp;和/或横杠&nbsp;<code>&#39;-&#39;</code>&nbsp;的字符串。前缀名<strong>必须</strong>以字母开头。</li>\n\t<li><strong>域名</strong>是&nbsp;<code>&#39;@leetcode.com&#39;</code>&nbsp;。</li>\n</ul>\n\n<p>按任意顺序返回结果表。</p>\n\n<p>&nbsp;</p>\n\n<p>查询格式如下所示：</p>\n\n<pre>\n<code>Users</code>\n+---------+-----------+-------------------------+\n| user_id | name      | mail                    |\n+---------+-----------+-------------------------+\n| 1       | Winston   | winston@leetcode.com    |\n| 2       | Jonathan  | jonathanisgreat         |\n| 3       | Annabelle | bella-@leetcode.com     |\n| 4       | Sally     | sally.come@leetcode.com |\n| 5       | Marwan    | quarz#2020@leetcode.com |\n| 6       | David     | david69@gmail.com       |\n| 7       | Shapiro   | .shapo@leetcode.com     |\n+---------+-----------+-------------------------+\n\n结果表：\n+---------+-----------+-------------------------+\n| user_id | name      | mail                    |\n+---------+-----------+-------------------------+\n| 1       | Winston   | winston@leetcode.com    |\n| 3       | Annabelle | bella-@leetcode.com     |\n| 4       | Sally     | sally.come@leetcode.com |\n+---------+-----------+-------------------------+\n2 号用户的邮箱没有域名。\n5 号用户的邮箱包含非法字符 #。\n6 号用户的邮箱的域名不是 leetcode。\n7 号用户的邮箱以句点（.）开头。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1518.换水问题",
        "hardRate": "EASY",
        "passRate": "69.57%",
        "problemsUrl": "https://leetcode.cn/problems/water-bottles/",
        "solutionsUrl": "https://leetcode.cn/problems/water-bottles/solution",
        "problemsDesc": "<p>超市正在促销，你可以用 <code>numExchange</code> 个空水瓶从超市兑换一瓶水。最开始，你一共购入了 <code>numBottles</code> 瓶水。</p>\n\n<p>如果喝掉了水瓶中的水，那么水瓶就会变成空的。</p>\n\n<p>给你两个整数 <code>numBottles</code> 和 <code>numExchange</code> ，返回你 <strong>最多</strong> 可以喝到多少瓶水。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/19/sample_1_1875.png\" style=\"height: 240px; width: 480px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>numBottles = 9, numExchange = 3\n<strong>输出：</strong>13\n<strong>解释：</strong>你可以用 <code>3</code> 个空瓶兑换 1 瓶水。\n所以最多能喝到 9 + 3 + 1 = 13 瓶水。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/19/sample_2_1875.png\" style=\"height: 240px; width: 790px;\" /></p>\n\n<pre>\n<strong>输入：</strong>numBottles = 15, numExchange = 4\n<strong>输出：</strong>19\n<strong>解释：</strong>你可以用 <code>4</code> 个空瓶兑换 1 瓶水。\n所以最多能喝到 15 + 3 + 1 = 19 瓶水。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numBottles &lt;= 100</code></li>\n\t<li><code>2 &lt;= numExchange &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1519.子树中标签相同的节点数",
        "hardRate": "MEDIUM",
        "passRate": "33.26%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/solution",
        "problemsDesc": "<p>给你一棵树（即，一个连通的无环无向图），这棵树由编号从 <code>0</code>&nbsp; 到 <code>n - 1</code> 的 n 个节点组成，且恰好有 <code>n - 1</code> 条 <code>edges</code> 。树的根节点为节点 <code>0</code> ，树上的每一个节点都有一个标签，也就是字符串 <code>labels</code> 中的一个小写字符（编号为 <code>i</code> 的 节点的标签就是 <code>labels[i]</code> ）</p>\n\n<p>边数组 <code>edges</code> 以 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 的形式给出，该格式表示节点 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间存在一条边。</p>\n\n<p>返回一个大小为 <em><code>n</code></em> 的数组，其中 <code>ans[i]</code> 表示第 <code>i</code> 个节点的子树中与节点 <code>i</code> 标签相同的节点数。</p>\n\n<p>树 <code>T</code> 中的子树是由 <code>T</code> 中的某个节点及其所有后代节点组成的树。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/19/q3e1.jpg\" style=\"height: 321px; width: 441px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = \"abaedcd\"\n<strong>输出：</strong>[2,1,1,1,1,1,1]\n<strong>解释：</strong>节点 0 的标签为 'a' ，以 'a' 为根节点的子树中，节点 2 的标签也是 'a' ，因此答案为 2 。注意树中的每个节点都是这棵子树的一部分。\n节点 1 的标签为 'b' ，节点 1 的子树包含节点 1、4 和 5，但是节点 4、5 的标签与节点 1 不同，故而答案为 1（即，该节点本身）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/19/q3e2.jpg\" style=\"height: 321px; width: 381px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 4, edges = [[0,1],[1,2],[0,3]], labels = \"bbbb\"\n<strong>输出：</strong>[4,2,1,1]\n<strong>解释：</strong>节点 2 的子树中只有节点 2 ，所以答案为 1 。\n节点 3 的子树中只有节点 3 ，所以答案为 1 。\n节点 1 的子树中包含节点 1 和 2 ，标签都是 'b' ，因此答案为 2 。\n节点 0 的子树中包含节点 0、1、2 和 3，标签都是 'b'，因此答案为 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/19/q3e3.jpg\" style=\"height: 321px; width: 381px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = \"aabab\"\n<strong>输出：</strong>[3,2,1,1,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>,&nbsp;b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> !=&nbsp;b<sub>i</sub></code></li>\n\t<li><code>labels.length == n</code></li>\n\t<li><code>labels</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1520.最多的不重叠子字符串",
        "hardRate": "HARD",
        "passRate": "35.70%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-non-overlapping-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-non-overlapping-substrings/solution",
        "problemsDesc": "<p>给你一个只包含小写字母的字符串&nbsp;<code>s</code>&nbsp;，你需要找到 <code>s</code>&nbsp;中最多数目的非空子字符串，满足如下条件：</p>\n\n<ol>\n\t<li>这些字符串之间互不重叠，也就是说对于任意两个子字符串&nbsp;<code>s[i..j]</code> 和&nbsp;<code>s[x..y]</code>&nbsp;，要么&nbsp;<code>j &lt; x</code>&nbsp;要么&nbsp;<code>i &gt; y</code>&nbsp;。</li>\n\t<li>如果一个子字符串包含字符&nbsp;<code>char</code> ，那么&nbsp;<code>s</code>&nbsp;中所有&nbsp;<code>char</code> 字符都应该在这个子字符串中。</li>\n</ol>\n\n<p>请你找到满足上述条件的最多子字符串数目。如果有多个解法有相同的子字符串数目，请返回这些子字符串总长度最小的一个解。可以证明最小总长度解是唯一的。</p>\n\n<p>请注意，你可以以 <strong>任意</strong>&nbsp;顺序返回最优解的子字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"adefaddaccc\"\n<strong>输出：</strong>[\"e\",\"f\",\"ccc\"]\n<strong>解释：</strong>下面为所有满足第二个条件的子字符串：\n[\n&nbsp; \"adefaddaccc\"\n&nbsp; \"adefadda\",\n&nbsp; \"ef\",\n&nbsp; \"e\",\n  \"f\",\n&nbsp; \"ccc\",\n]\n如果我们选择第一个字符串，那么我们无法再选择其他任何字符串，所以答案为 1 。如果我们选择 \"adefadda\" ，剩下子字符串中我们只可以选择 \"ccc\" ，它是唯一不重叠的子字符串，所以答案为 2 。同时我们可以发现，选择 \"ef\" 不是最优的，因为它可以被拆分成 2 个子字符串。所以最优解是选择 [\"e\",\"f\",\"ccc\"] ，答案为 3 。不存在别的相同数目子字符串解。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abbaccd\"\n<strong>输出：</strong>[\"d\",\"bb\",\"cc\"]\n<strong>解释：</strong>注意到解 [\"d\",\"abba\",\"cc\"] 答案也为 3 ，但它不是最优解，因为它的总长度更长。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1521.找到最接近目标值的函数值",
        "hardRate": "HARD",
        "passRate": "43.70%",
        "problemsUrl": "https://leetcode.cn/problems/find-a-value-of-a-mysterious-function-closest-to-target/",
        "solutionsUrl": "https://leetcode.cn/problems/find-a-value-of-a-mysterious-function-closest-to-target/solution",
        "problemsDesc": "<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/19/change.png\" style=\"height: 312px; width: 635px;\"></p>\n\n<p>Winston 构造了一个如上所示的函数&nbsp;<code>func</code>&nbsp;。他有一个整数数组&nbsp;<code>arr</code>&nbsp;和一个整数&nbsp;<code>target</code>&nbsp;，他想找到让&nbsp;<code>|func(arr, l, r) - target|</code>&nbsp;最小的 <code>l</code>&nbsp;和 <code>r</code>&nbsp;。</p>\n\n<p>请你返回&nbsp;<code>|func(arr, l, r) - target|</code>&nbsp;的最小值。</p>\n\n<p>请注意，&nbsp;<code>func</code> 的输入参数&nbsp;<code>l</code> 和&nbsp;<code>r</code>&nbsp;需要满足&nbsp;<code>0 &lt;= l, r &lt; arr.length</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [9,12,3,7,15], target = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>所有可能的 [l,r] 数对包括 [[0,0],[1,1],[2,2],[3,3],[4,4],[0,1],[1,2],[2,3],[3,4],[0,2],[1,3],[2,4],[0,3],[1,4],[0,4]]， Winston 得到的相应结果为 [9,12,3,7,15,8,0,3,7,0,0,3,0,0,0] 。最接近 5 的值是 7 和 3，所以最小差值为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1000000,1000000,1000000], target = 1\n<strong>输出：</strong>999999\n<strong>解释：</strong>Winston 输入函数的所有可能 [l,r] 数对得到的函数值都为 1000000 ，所以最小差值为 999999 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,4,8,16], target = 0\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10^6</code></li>\n\t<li><code>0 &lt;= target &lt;= 10^7</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1522.N 叉树的直径",
        "hardRate": "MEDIUM",
        "passRate": "71.48%",
        "problemsUrl": "https://leetcode.cn/problems/diameter-of-n-ary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/diameter-of-n-ary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1523.在区间范围内统计奇数数目",
        "hardRate": "EASY",
        "passRate": "49.24%",
        "problemsUrl": "https://leetcode.cn/problems/count-odd-numbers-in-an-interval-range/",
        "solutionsUrl": "https://leetcode.cn/problems/count-odd-numbers-in-an-interval-range/solution",
        "problemsDesc": "<p>给你两个非负整数&nbsp;<code>low</code> 和&nbsp;<code>high</code>&nbsp;。请你返回<em>&nbsp;</em><code>low</code><em> </em>和<em>&nbsp;</em><code>high</code><em>&nbsp;</em>之间（包括二者）奇数的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>low = 3, high = 7\n<strong>输出：</strong>3\n<strong>解释：</strong>3 到 7 之间奇数数字为 [3,5,7] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>low = 8, high = 10\n<strong>输出：</strong>1\n<strong>解释：</strong>8 到 10 之间奇数数字为 [9] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= low &lt;= high&nbsp;&lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1524.和为奇数的子数组数目",
        "hardRate": "MEDIUM",
        "passRate": "45.76%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-sub-arrays-with-odd-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-sub-arrays-with-odd-sum/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code>&nbsp;。请你返回和为 <strong>奇数</strong>&nbsp;的子数组数目。</p>\n\n<p>由于答案可能会很大，请你将结果对&nbsp;<code>10^9 + 7</code>&nbsp;取余后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,3,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>所有的子数组为 [[1],[1,3],[1,3,5],[3],[3,5],[5]] 。\n所有子数组的和为 [1,4,9,3,8,5].\n奇数和包括 [1,9,3,5] ，所以答案为 4 。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,4,6]\n<strong>输出：</strong>0\n<strong>解释：</strong>所有子数组为 [[2],[2,4],[2,4,6],[4],[4,6],[6]] 。\n所有子数组和为 [2,6,12,4,10,6] 。\n所有子数组和都是偶数，所以答案为 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,3,4,5,6,7]\n<strong>输出：</strong>16\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [100,100,99,99]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [7]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1525.字符串的好分割数目",
        "hardRate": "MEDIUM",
        "passRate": "66.05%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-good-ways-to-split-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-good-ways-to-split-a-string/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，一个分割被称为 「好分割」&nbsp;当它满足：将&nbsp;<code>s</code>&nbsp;分割成 2 个字符串&nbsp;<code>p</code> 和&nbsp;<code>q</code>&nbsp;，它们连接起来等于&nbsp;<code>s</code>&nbsp;且 <code>p</code>&nbsp;和 <code>q</code>&nbsp;中不同字符的数目相同。</p>\n\n<p>请你返回 <code>s</code>&nbsp;中好分割的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aacaba&quot;\n<strong>输出：</strong>2\n<strong>解释：</strong>总共有 5 种分割字符串 <code>&quot;aacaba&quot;</code> 的方法，其中 2 种是好分割。\n(&quot;a&quot;, &quot;acaba&quot;) 左边字符串和右边字符串分别包含 1 个和 3 个不同的字符。\n(&quot;aa&quot;, &quot;caba&quot;) 左边字符串和右边字符串分别包含 1 个和 3 个不同的字符。\n(&quot;aac&quot;, &quot;aba&quot;) 左边字符串和右边字符串分别包含 2 个和 2 个不同的字符。这是一个好分割。\n(&quot;aaca&quot;, &quot;ba&quot;) 左边字符串和右边字符串分别包含 2 个和 2 个不同的字符。这是一个好分割。\n(&quot;aacab&quot;, &quot;a&quot;) 左边字符串和右边字符串分别包含 3 个和 1 个不同的字符。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abcd&quot;\n<strong>输出：</strong>1\n<strong>解释：</strong>好分割为将字符串分割成 (&quot;ab&quot;, &quot;cd&quot;) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aaaaa&quot;\n<strong>输出：</strong>4\n<strong>解释：</strong>所有分割都是好分割。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;acbadbaada&quot;\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1526.形成目标数组的子数组最少增加次数",
        "hardRate": "HARD",
        "passRate": "64.94%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>target</code>&nbsp;和一个数组&nbsp;<code>initial</code>&nbsp;，<code>initial</code>&nbsp;数组与 <code>target</code>&nbsp; 数组有同样的维度，且一开始全部为 0 。</p>\n\n<p>请你返回从 <code>initial</code>&nbsp;得到&nbsp; <code>target</code>&nbsp;的最少操作次数，每次操作需遵循以下规则：</p>\n\n<ul>\n\t<li>在 <code>initial</code>&nbsp;中选择 <strong>任意</strong>&nbsp;子数组，并将子数组中每个元素增加 1 。</li>\n</ul>\n\n<p>答案保证在 32 位有符号整数以内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>target = [1,2,3,2,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>我们需要至少 3 次操作从 intial 数组得到 target 数组。\n[0,0,0,0,0] 将下标为 0 到 4&nbsp;的元素（包含二者）加 1 。\n[1,1,1,1,1] 将下标为 1 到 3 的元素（包含二者）加 1 。\n[1,2,2,2,1] 将下表为 2 的元素增加 1 。\n[1,2,3,2,1] 得到了目标数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>target = [3,1,1,2]\n<strong>输出：</strong>4\n<strong>解释：</strong>(initial)[0,0,0,0] -&gt; [1,1,1,1] -&gt; [1,1,1,2] -&gt; [2,1,1,2] -&gt; [3,1,1,2] (target) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>target = [3,1,5,4,2]\n<strong>输出：</strong>7\n<strong>解释：</strong>(initial)[0,0,0,0,0] -&gt; [1,1,1,1,1] -&gt; [2,1,1,1,1] -&gt; [3,1,1,1,1] \n                                  -&gt; [3,1,2,2,2] -&gt; [3,1,3,3,2] -&gt; [3,1,4,4,2] -&gt; [3,1,5,4,2] (target)。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>target = [1,1,1,1]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= target[i] &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1527.患某种疾病的患者",
        "hardRate": "EASY",
        "passRate": "46.68%",
        "problemsUrl": "https://leetcode.cn/problems/patients-with-a-condition/",
        "solutionsUrl": "https://leetcode.cn/problems/patients-with-a-condition/solution",
        "problemsDesc": "<p>患者信息表：&nbsp;<code>Patients</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| patient_id   | int     |\n| patient_name | varchar |\n| conditions   | varchar |\n+--------------+---------+\npatient_id （患者 ID）是该表的主键。\n'conditions' （疾病）包含 0 个或以上的疾病代码，以空格分隔。\n这个表包含医院中患者的信息。</pre>\n\n<p>&nbsp;</p>\n\n<p>写一条&nbsp;SQL 语句，查询患有 I 类糖尿病的患者&nbsp;ID （patient_id）、患者姓名（patient_name）以及其患有的所有疾病代码（conditions）。I 类糖尿病的代码总是包含前缀&nbsp;<code>DIAB1</code>&nbsp;。</p>\n\n<p>按 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式如下示例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<code><strong>输入：\n</strong>Patients表：</code>\n+------------+--------------+--------------+\n| patient_id | patient_name | conditions   |\n+------------+--------------+--------------+\n| 1          | Daniel      &nbsp;| YFEV COUGH   |\n| 2    &nbsp;     | Alice        |            &nbsp; |\n| 3    &nbsp;     | Bob         &nbsp;| DIAB100 MYOP&nbsp;|\n| 4 &nbsp;        | George      &nbsp;| ACNE DIAB100&nbsp;|\n| 5 &nbsp;        | Alain       &nbsp;| DIAB201     &nbsp;|\n+------------+--------------+--------------+\n<strong>输出：</strong>\n+------------+--------------+--------------+\n| patient_id | patient_name | conditions   |\n+------------+--------------+--------------+\n| 3    &nbsp;     | Bob         &nbsp;| DIAB100 MYOP&nbsp;|\n| 4 &nbsp;        | George   &nbsp;   | ACNE DIAB100&nbsp;| \n+------------+--------------+--------------+\n<strong>解释：</strong>Bob 和 George 都患有代码以 DIAB1 开头的疾病。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1528.重新排列字符串",
        "hardRate": "EASY",
        "passRate": "78.46%",
        "problemsUrl": "https://leetcode.cn/problems/shuffle-string/",
        "solutionsUrl": "https://leetcode.cn/problems/shuffle-string/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和一个 <strong>长度相同</strong> 的整数数组 <code>indices</code> 。</p>\n\n<p>请你重新排列字符串 <code>s</code> ，其中第 <code>i</code> 个字符需要移动到 <code>indices[i]</code> 指示的位置。</p>\n\n<p>返回重新排列后的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/26/q1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>s = \"codeleet\", <code>indices</code> = [4,5,6,7,0,2,1,3]\n<strong>输出：</strong>\"leetcode\"\n<strong>解释：</strong>如图所示，\"codeleet\" 重新排列后变为 \"leetcode\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\", <code>indices</code> = [0,1,2]\n<strong>输出：</strong>\"abc\"\n<strong>解释：</strong>重新排列后，每个字符都还留在原来的位置上。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s.length == indices.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>s</code> 仅包含小写英文字母</li>\n\t<li><code>0 &lt;= indices[i] &lt;&nbsp;n</code></li>\n\t<li><code>indices</code> 的所有的值都是 <strong>唯一</strong> 的</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1529.最少的后缀翻转次数",
        "hardRate": "MEDIUM",
        "passRate": "70.32%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-suffix-flips/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-suffix-flips/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 、下标从 <strong>0</strong> 开始的二进制字符串 <code>target</code> 。你自己有另一个长度为 <code>n</code> 的二进制字符串 <code>s</code> ，最初每一位上都是 0 。你想要让 <code>s</code> 和 <code>target</code> 相等。</p>\n\n<p>在一步操作，你可以选择下标 <code>i</code>（<code>0 &lt;= i &lt; n</code>）并翻转在 <strong>闭区间</strong> <code>[i, n - 1]</code> 内的所有位。翻转意味着 <code>'0'</code> 变为 <code>'1'</code> ，而 <code>'1'</code> 变为 <code>'0'</code> 。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>返回使<em> </em><code>s</code><em> </em>与<em> </em><code>target</code> 相等需要的最少翻转次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = \"10111\"\n<strong>输出：</strong>3\n<strong>解释：</strong>最初，s = \"00000\" 。\n选择下标 i = 2: \"00<em><strong>000</strong></em>\" -&gt; \"00<em><strong>111</strong></em>\"\n选择下标 i = 0: \"<em><strong>00111</strong></em>\" -&gt; \"<em><strong>11000</strong></em>\"\n选择下标 i = 1: \"1<em><strong>1000</strong></em>\" -&gt; \"1<em><strong>0111</strong></em>\"\n要达成目标，需要至少 3 次翻转。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = \"101\"\n<strong>输出：</strong>3\n<strong>解释：</strong>最初，s = \"000\" 。\n选择下标 i = 0: \"<em><strong>000</strong></em>\" -&gt; \"<em><strong>111</strong></em>\"\n选择下标 i = 1: \"1<em><strong>11</strong></em>\" -&gt; \"1<em><strong>00</strong></em>\"\n选择下标 i = 2: \"10<em><strong>0</strong></em>\" -&gt; \"10<em><strong>1</strong></em>\"\n要达成目标，需要至少 3 次翻转。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = \"00000\"\n<strong>输出：</strong>0\n<strong>解释：</strong>由于 s 已经等于目标，所以不需要任何操作\n</pre>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == target.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>target[i]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1530.好叶子节点对的数量",
        "hardRate": "MEDIUM",
        "passRate": "58.50%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-good-leaf-nodes-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-good-leaf-nodes-pairs/solution",
        "problemsDesc": "<p>给你二叉树的根节点 <code>root</code> 和一个整数 <code>distance</code> 。</p>\n\n<p>如果二叉树中两个 <strong>叶</strong> 节点之间的 <strong>最短路径长度</strong> 小于或者等于 <code>distance</code> ，那它们就可以构成一组 <strong>好叶子节点对</strong> 。</p>\n\n<p>返回树中 <strong>好叶子节点对的数量</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/26/e1.jpg\" style=\"height: 321px; width: 321px;\"></p>\n\n<pre><strong>输入：</strong>root = [1,2,3,null,4], distance = 3\n<strong>输出：</strong>1\n<strong>解释：</strong>树的叶节点是 3 和 4 ，它们之间的最短路径的长度是 3 。这是唯一的好叶子节点对。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/26/e2.jpg\" style=\"height: 321px; width: 441px;\"></p>\n\n<pre><strong>输入：</strong>root = [1,2,3,4,5,6,7], distance = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>好叶子节点对为 [4,5] 和 [6,7] ，最短路径长度都是 2 。但是叶子节点对 [4,6] 不满足要求，因为它们之间的最短路径长度为 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3\n<strong>输出：</strong>1\n<strong>解释：</strong>唯一的好叶子节点对是 [2,5] 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>root = [100], distance = 1\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>root = [1,1,1], distance = 2\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>tree</code> 的节点数在 <code>[1, 2^10]</code> 范围内。</li>\n\t<li>每个节点的值都在 <code>[1, 100]</code> 之间。</li>\n\t<li><code>1 &lt;= distance &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1531.压缩字符串 II",
        "hardRate": "HARD",
        "passRate": "38.09%",
        "problemsUrl": "https://leetcode.cn/problems/string-compression-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/string-compression-ii/solution",
        "problemsDesc": "<p><a href=\"https://baike.baidu.com/item/%E8%A1%8C%E7%A8%8B%E9%95%BF%E5%BA%A6%E7%BC%96%E7%A0%81/2931940?fr=aladdin\" target=\"_blank\">行程长度编码</a> 是一种常用的字符串压缩方法，它将连续的相同字符（重复 2 次或更多次）替换为字符和表示字符计数的数字（行程长度）。例如，用此方法压缩字符串 <code>&quot;aabccc&quot;</code> ，将 <code>&quot;aa&quot;</code> 替换为 <code>&quot;a2&quot;</code> ，<code>&quot;ccc&quot;</code> 替换为` <code>&quot;c3&quot;</code> 。因此压缩后的字符串变为 <code>&quot;a2bc3&quot;</code> 。</p>\n\n<p>注意，本问题中，压缩时没有在单个字符后附加计数 <code>&#39;1&#39;</code> 。</p>\n\n<p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> 。你需要从字符串 <code>s</code> 中删除最多 <code>k</code> 个字符，以使 <code>s</code> 的行程长度编码长度最小。</p>\n\n<p>请你返回删除最多 <code>k</code> 个字符后，<code>s</code> <strong>行程长度编码的最小长度</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aaabcccd&quot;, k = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>在不删除任何内容的情况下，压缩后的字符串是 &quot;a3bc3d&quot; ，长度为 6 。最优的方案是删除 &#39;b&#39; 和 &#39;d&#39;，这样一来，压缩后的字符串为 &quot;a3c3&quot; ，长度是 4 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aabbaa&quot;, k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>如果删去两个 &#39;b&#39; 字符，那么压缩后的字符串是长度为 2 的 &quot;a4&quot; 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aaaaaaaaaaa&quot;, k = 0\n<strong>输出：</strong>3\n<strong>解释：</strong>由于 k 等于 0 ，不能删去任何字符。压缩后的字符串是 &quot;a11&quot; ，长度为 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= k &lt;= s.length</code></li>\n\t<li><code>s</code> 仅包含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1532.最近的三笔订单",
        "hardRate": "MEDIUM",
        "passRate": "63.14%",
        "problemsUrl": "https://leetcode.cn/problems/the-most-recent-three-orders/",
        "solutionsUrl": "https://leetcode.cn/problems/the-most-recent-three-orders/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1533.找到最大整数的索引",
        "hardRate": "MEDIUM",
        "passRate": "58.80%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-index-of-the-large-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-index-of-the-large-integer/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1534.统计好三元组",
        "hardRate": "EASY",
        "passRate": "77.13%",
        "problemsUrl": "https://leetcode.cn/problems/count-good-triplets/",
        "solutionsUrl": "https://leetcode.cn/problems/count-good-triplets/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> ，以及 <code>a</code>、<code>b</code> 、<code>c</code> 三个整数。请你统计其中好三元组的数量。</p>\n\n<p>如果三元组 <code>(arr[i], arr[j], arr[k])</code> 满足下列全部条件，则认为它是一个 <strong>好三元组</strong> 。</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; k &lt;&nbsp;arr.length</code></li>\n\t<li><code>|arr[i] - arr[j]| &lt;= a</code></li>\n\t<li><code>|arr[j] - arr[k]| &lt;= b</code></li>\n\t<li><code>|arr[i] - arr[k]| &lt;= c</code></li>\n</ul>\n\n<p>其中 <code>|x|</code> 表示 <code>x</code> 的绝对值。</p>\n\n<p>返回 <strong>好三元组的数量</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3\n<strong>输出：</strong>4\n<strong>解释：</strong>一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,1,2,2,3], a = 0, b = 0, c = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在满足所有条件的三元组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= arr.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= a, b, c &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1535.找出数组游戏的赢家",
        "hardRate": "MEDIUM",
        "passRate": "46.17%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-winner-of-an-array-game/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-winner-of-an-array-game/solution",
        "problemsDesc": "<p>给你一个由 <strong>不同</strong> 整数组成的整数数组 <code>arr</code> 和一个整数 <code>k</code> 。</p>\n\n<p>每回合游戏都在数组的前两个元素（即 <code>arr[0]</code> 和 <code>arr[1]</code> ）之间进行。比较 <code>arr[0]</code> 与 <code>arr[1]</code> 的大小，较大的整数将会取得这一回合的胜利并保留在位置 <code>0</code> ，较小的整数移至数组的末尾。当一个整数赢得 <code>k</code> 个连续回合时，游戏结束，该整数就是比赛的 <strong>赢家</strong> 。</p>\n\n<p>返回赢得比赛的整数。</p>\n\n<p>题目数据 <strong>保证</strong> 游戏存在赢家。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,1,3,5,4,6,7], k = 2\n<strong>输出：</strong>5\n<strong>解释：</strong>一起看一下本场游戏每回合的情况：\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/30/q-example.png\" style=\"height: 90px; width: 400px;\">\n因此将进行 4 回合比赛，其中 5 是赢家，因为它连胜 2 回合。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,2,1], k = 10\n<strong>输出：</strong>3\n<strong>解释：</strong>3 将会在前 10 个回合中连续获胜。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,9,8,2,3,7,6,4,5], k = 7\n<strong>输出：</strong>9\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,11,22,33,44,55,66,77,88,99], k = 1000000000\n<strong>输出：</strong>99\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10^6</code></li>\n\t<li><code>arr</code> 所含的整数 <strong>各不相同</strong> 。</li>\n\t<li><code>1 &lt;= k &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1536.排布二进制网格的最少交换次数",
        "hardRate": "MEDIUM",
        "passRate": "46.31%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-swaps-to-arrange-a-binary-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-swaps-to-arrange-a-binary-grid/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>n&nbsp;x n</code>&nbsp;的二进制网格&nbsp;<code>grid</code>，每一次操作中，你可以选择网格的&nbsp;<strong>相邻两行</strong>&nbsp;进行交换。</p>\n\n<p>一个符合要求的网格需要满足主对角线以上的格子全部都是 <strong>0</strong>&nbsp;。</p>\n\n<p>请你返回使网格满足要求的最少操作次数，如果无法使网格符合要求，请你返回 <strong>-1</strong>&nbsp;。</p>\n\n<p>主对角线指的是从&nbsp;<code>(1, 1)</code>&nbsp;到&nbsp;<code>(n, n)</code>&nbsp;的这些格子。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/02/fw.jpg\" style=\"height: 141px; width: 750px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[0,0,1],[1,1,0],[1,0,0]]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/02/e2.jpg\" style=\"height: 270px; width: 270px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>所有行都是一样的，交换相邻行无法使网格符合要求。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/02/e3.jpg\" style=\"height: 210px; width: 210px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[1,0,0],[1,1,0],[1,1,1]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= n&nbsp;&lt;= 200</code></li>\n\t<li><code>grid[i][j]</code>&nbsp;要么是&nbsp;<code>0</code>&nbsp;要么是&nbsp;<code>1</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1537.最大得分",
        "hardRate": "HARD",
        "passRate": "40.12%",
        "problemsUrl": "https://leetcode.cn/problems/get-the-maximum-score/",
        "solutionsUrl": "https://leetcode.cn/problems/get-the-maximum-score/solution",
        "problemsDesc": "<p>你有两个 <strong>有序</strong>&nbsp;且数组内元素互不相同的数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;。</p>\n\n<p>一条&nbsp;<strong>合法路径</strong>&nbsp;定义如下：</p>\n\n<ul>\n\t<li>选择数组 nums1 或者 nums2 开始遍历（从下标 0 处开始）。</li>\n\t<li>从左到右遍历当前数组。</li>\n\t<li>如果你遇到了 <code>nums1</code>&nbsp;和 <code>nums2</code>&nbsp;中都存在的值，那么你可以切换路径到另一个数组对应数字处继续遍历（但在合法路径中重复数字只会被统计一次）。</li>\n</ul>\n\n<p>得分定义为合法路径中不同数字的和。</p>\n\n<p>请你返回所有可能合法路径中的最大得分。</p>\n\n<p>由于答案可能很大，请你将它对 10^9 + 7 取余后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/02/sample_1_1893.png\" style=\"height: 163px; width: 538px;\"></strong></p>\n\n<pre><strong>输入：</strong>nums1 = [2,4,5,8,10], nums2 = [4,6,8,9]\n<strong>输出：</strong>30\n<strong>解释：</strong>合法路径包括：\n[2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10],（从 nums1 开始遍历）\n[4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10]  （从 nums2 开始遍历）\n最大得分为上图中的绿色路径 <strong>[2,4,6,8,10]</strong>&nbsp;。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [1,3,5,7,9], nums2 = [3,5,100]\n<strong>输出：</strong>109\n<strong>解释：</strong>最大得分由路径 <strong>[1,3,5,100]</strong> 得到。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10]\n<strong>输出：</strong>40\n<strong>解释：</strong>nums1 和 nums2 之间无相同数字。\n最大得分由路径 <strong>[6,7,8,9,10]</strong> 得到。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums1 = [1,4,5,8,9,11,19], nums2 = [2,3,4,11,12]\n<strong>输出：</strong>61\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= nums2.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10^7</code></li>\n\t<li><code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;都是严格递增的数组。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1538.找出隐藏数组中出现次数最多的元素",
        "hardRate": "MEDIUM",
        "passRate": "57.61%",
        "problemsUrl": "https://leetcode.cn/problems/guess-the-majority-in-a-hidden-array/",
        "solutionsUrl": "https://leetcode.cn/problems/guess-the-majority-in-a-hidden-array/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1539.第 k 个缺失的正整数",
        "hardRate": "EASY",
        "passRate": "54.02%",
        "problemsUrl": "https://leetcode.cn/problems/kth-missing-positive-number/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-missing-positive-number/solution",
        "problemsDesc": "<p>给你一个 <strong>严格升序排列</strong>&nbsp;的正整数数组 <code>arr</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>请你找到这个数组里第&nbsp;<code>k</code>&nbsp;个缺失的正整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [2,3,4,7,11], k = 5\n<strong>输出：</strong>9\n<strong>解释：</strong>缺失的正整数包括 [1,5,6,8,9,10,12,13,...] 。第 5 个缺失的正整数为 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,4], k = 2\n<strong>输出：</strong>6\n<strong>解释：</strong>缺失的正整数包括 [5,6,7,...] 。第 2 个缺失的正整数为 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= k &lt;= 1000</code></li>\n\t<li>对于所有&nbsp;<code>1 &lt;= i &lt; j &lt;= arr.length</code>&nbsp;的 <code>i</code>&nbsp;和 <code>j</code> 满足&nbsp;<code>arr[i] &lt; arr[j]</code>&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<p>你可以设计一个时间复杂度小于 O(n) 的算法解决此问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1540.K 次操作转变字符串",
        "hardRate": "MEDIUM",
        "passRate": "33.42%",
        "problemsUrl": "https://leetcode.cn/problems/can-convert-string-in-k-moves/",
        "solutionsUrl": "https://leetcode.cn/problems/can-convert-string-in-k-moves/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>s</code>&nbsp;和&nbsp;<code>t</code>&nbsp;，你的目标是在 <code>k</code>&nbsp;次操作以内把字符串&nbsp;<code>s</code>&nbsp;转变成&nbsp;<code>t</code>&nbsp;。</p>\n\n<p>在第 <code>i</code>&nbsp;次操作时（<code>1 &lt;= i &lt;= k</code>），你可以选择进行如下操作：</p>\n\n<ul>\n\t<li>选择字符串 <code>s</code>&nbsp;中满足 <code>1 &lt;= j &lt;= s.length</code>&nbsp;且之前未被选过的任意下标 <code>j</code>&nbsp;（下标从 1 开始），并将此位置的字符切换 <code>i</code>&nbsp;次。</li>\n\t<li>不进行任何操作。</li>\n</ul>\n\n<p>切换 1 个字符的意思是用字母表中该字母的下一个字母替换它（字母表环状接起来，所以 <code>'z'</code>&nbsp;切换后会变成 <code>'a'</code>）。第 <code>i</code>&nbsp;次操作意味着该字符应切换&nbsp;<code>i</code>&nbsp;次</p>\n\n<p>请记住任意一个下标 <code>j</code>&nbsp;最多只能被操作&nbsp;1 次。</p>\n\n<p>如果在不超过 <code>k</code>&nbsp;次操作内可以把字符串 <code>s</code>&nbsp;转变成 <code>t</code>&nbsp;，那么请你返回&nbsp;<code>true</code>&nbsp;，否则请你返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"input\", t = \"ouput\", k = 9\n<strong>输出：</strong>true\n<strong>解释：</strong>第 6 次操作时，我们将 'i' 切换 6 次得到 'o' 。第 7 次操作时，我们将 'n' 切换 7 次得到 'u' 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\", t = \"bcd\", k = 10\n<strong>输出：</strong>false\n<strong>解释：</strong>我们需要将每个字符切换 1 次才能得到 t 。我们可以在第 1 次操作时将 'a' 切换成 'b' ，但另外 2 个字母在剩余操作中无法再转变为 t 中对应字母。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aab\", t = \"bbb\", k = 27\n<strong>输出：</strong>true\n<strong>解释：</strong>第 1 次操作时，我们将第一个 'a' 切换 1 次得到 'b' 。在第 27 次操作时，我们将第二个字母 'a' 切换 27 次得到 'b' 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= k &lt;= 10^9</code></li>\n\t<li><code>s</code>&nbsp;和&nbsp;<code>t</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1541.平衡括号字符串的最少插入次数",
        "hardRate": "MEDIUM",
        "passRate": "48.79%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/solution",
        "problemsDesc": "<p>给你一个括号字符串&nbsp;<code>s</code>&nbsp;，它只包含字符&nbsp;<code>&#39;(&#39;</code> 和&nbsp;<code>&#39;)&#39;</code>&nbsp;。一个括号字符串被称为平衡的当它满足：</p>\n\n<ul>\n\t<li>任何左括号&nbsp;<code>&#39;(&#39;</code>&nbsp;必须对应两个连续的右括号&nbsp;<code>&#39;))&#39;</code>&nbsp;。</li>\n\t<li>左括号&nbsp;<code>&#39;(&#39;</code>&nbsp;必须在对应的连续两个右括号&nbsp;<code>&#39;))&#39;</code>&nbsp;之前。</li>\n</ul>\n\n<p>比方说&nbsp;<code>&quot;())&quot;</code>，&nbsp;<code>&quot;())(())))&quot;</code> 和&nbsp;<code>&quot;(())())))&quot;</code>&nbsp;都是平衡的，&nbsp;<code>&quot;)()&quot;</code>，&nbsp;<code>&quot;()))&quot;</code> 和&nbsp;<code>&quot;(()))&quot;</code>&nbsp;都是不平衡的。</p>\n\n<p>你可以在任意位置插入字符 &#39;(&#39; 和 &#39;)&#39; 使字符串平衡。</p>\n\n<p>请你返回让 <code>s</code>&nbsp;平衡的最少插入次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;(()))&quot;\n<strong>输出：</strong>1\n<strong>解释：</strong>第二个左括号有与之匹配的两个右括号，但是第一个左括号只有一个右括号。我们需要在字符串结尾额外增加一个 &#39;)&#39; 使字符串变成平衡字符串 &quot;(())))&quot; 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;())&quot;\n<strong>输出：</strong>0\n<strong>解释：</strong>字符串已经平衡了。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;))())(&quot;\n<strong>输出：</strong>3\n<strong>解释：</strong>添加 &#39;(&#39; 去匹配最开头的 &#39;))&#39; ，然后添加 &#39;))&#39; 去匹配最后一个 &#39;(&#39; 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;((((((&quot;\n<strong>输出：</strong>12\n<strong>解释：</strong>添加 12 个 &#39;)&#39; 得到平衡字符串。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;)))))))&quot;\n<strong>输出：</strong>5\n<strong>解释：</strong>在字符串开头添加 4 个 &#39;(&#39; 并在结尾添加 1 个 &#39;)&#39; ，字符串变成平衡字符串 &quot;(((())))))))&quot; 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>s</code>&nbsp;只包含&nbsp;<code>&#39;(&#39;</code> 和&nbsp;<code>&#39;)&#39;</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1542.找出最长的超赞子字符串",
        "hardRate": "HARD",
        "passRate": "43.91%",
        "problemsUrl": "https://leetcode.cn/problems/find-longest-awesome-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/find-longest-awesome-substring/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 。请返回 <code>s</code> 中最长的 <strong>超赞子字符串</strong> 的长度。</p>\n\n<p>「超赞子字符串」需满足满足下述两个条件：</p>\n\n<ul>\n\t<li>该字符串是 <code>s</code> 的一个非空子字符串</li>\n\t<li>进行任意次数的字符交换后，该字符串可以变成一个回文字符串</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;3242415&quot;\n<strong>输出：</strong>5\n<strong>解释：</strong>&quot;24241&quot; 是最长的超赞子字符串，交换其中的字符后，可以得到回文 &quot;24142&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;12345678&quot;\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;213123&quot;\n<strong>输出：</strong>6\n<strong>解释：</strong>&quot;213123&quot; 是最长的超赞子字符串，交换其中的字符后，可以得到回文 &quot;231132&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;00&quot;\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>s</code> 仅由数字组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1543.产品名称格式修复",
        "hardRate": "EASY",
        "passRate": "55.38%",
        "problemsUrl": "https://leetcode.cn/problems/fix-product-name-format/",
        "solutionsUrl": "https://leetcode.cn/problems/fix-product-name-format/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1544.整理字符串",
        "hardRate": "EASY",
        "passRate": "55.98%",
        "problemsUrl": "https://leetcode.cn/problems/make-the-string-great/",
        "solutionsUrl": "https://leetcode.cn/problems/make-the-string-great/solution",
        "problemsDesc": "<p>给你一个由大小写英文字母组成的字符串 <code>s</code> 。</p>\n\n<p>一个整理好的字符串中，两个相邻字符 <code>s[i]</code> 和 <code>s[i+1]</code>，其中 <code>0<= i <= s.length-2</code> ，要满足如下条件:</p>\n\n<ul>\n\t<li>若 <code>s[i]</code> 是小写字符，则 <code>s[i+1]</code> 不可以是相同的大写字符。</li>\n\t<li>若 <code>s[i]</code> 是大写字符，则 <code>s[i+1]</code> 不可以是相同的小写字符。</li>\n</ul>\n\n<p>请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 <strong>两个相邻</strong> 字符并删除，直到字符串整理好为止。</p>\n\n<p>请返回整理好的 <strong>字符串</strong> 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。</p>\n\n<p><strong>注意：</strong>空字符串也属于整理好的字符串，尽管其中没有任何字符。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"leEeetcode\"\n<strong>输出：</strong>\"leetcode\"\n<strong>解释：</strong>无论你第一次选的是 i = 1 还是 i = 2，都会使 \"leEeetcode\" 缩减为 \"leetcode\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abBAcC\"\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>存在多种不同情况，但所有的情况都会导致相同的结果。例如：\n\"abBAcC\" --> \"aAcC\" --> \"cC\" --> \"\"\n\"abBAcC\" --> \"abBA\" --> \"aA\" --> \"\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"s\"\n<strong>输出：</strong>\"s\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 100</code></li>\n\t<li><code>s</code> 只包含小写和大写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1545.找出第 N 个二进制字符串中的第 K 位",
        "hardRate": "MEDIUM",
        "passRate": "59.00%",
        "problemsUrl": "https://leetcode.cn/problems/find-kth-bit-in-nth-binary-string/",
        "solutionsUrl": "https://leetcode.cn/problems/find-kth-bit-in-nth-binary-string/solution",
        "problemsDesc": "<p>给你两个正整数 <code>n</code> 和 <code>k</code>，二进制字符串  <code>S<sub>n</sub></code> 的形成规则如下：</p>\n\n<ul>\n\t<li><code>S<sub>1</sub> = \"0\"</code></li>\n\t<li>当 <code>i > 1</code> 时，<code>S<sub>i</sub> = S<sub>i-1</sub> + \"1\" + reverse(invert(S<sub>i-1</sub>))</code></li>\n</ul>\n\n<p>其中 <code>+</code> 表示串联操作，<code>reverse(x)</code> 返回反转 <code>x</code> 后得到的字符串，而 <code>invert(x)</code> 则会翻转 x 中的每一位（0 变为 1，而 1 变为 0）。</p>\n\n<p>例如，符合上述描述的序列的前 4 个字符串依次是：</p>\n\n<ul>\n\t<li><code>S<sub>1 </sub>= \"0\"</code></li>\n\t<li><code>S<sub>2 </sub>= \"0<strong>1</strong>1\"</code></li>\n\t<li><code>S<sub>3 </sub>= \"011<strong>1</strong>001\"</code></li>\n\t<li><code>S<sub>4</sub> = \"0111001<strong>1</strong>0110001\"</code></li>\n</ul>\n\n<p>请你返回  <code>S<sub>n</sub></code> 的 <strong>第 <code>k</code> 位字符</strong> ，题目数据保证 <code>k</code> 一定在 <code>S<sub>n</sub></code> 长度范围以内。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 1\n<strong>输出：</strong>\"0\"\n<strong>解释：</strong>S<sub>3</sub> 为 \"<strong>0</strong>111001\"，其第 1 位为 \"0\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, k = 11\n<strong>输出：</strong>\"1\"\n<strong>解释：</strong>S<sub>4</sub> 为 \"0111001101<strong>1</strong>0001\"，其第 11 位为 \"1\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, k = 1\n<strong>输出：</strong>\"0\"\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, k = 3\n<strong>输出：</strong>\"1\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 20</code></li>\n\t<li><code>1 <= k <= 2<sup>n</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1546.和为目标值且不重叠的非空子数组的最大数目",
        "hardRate": "MEDIUM",
        "passRate": "44.81%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>target</code>&nbsp;。</p>\n\n<p>请你返回&nbsp;<strong>非空不重叠</strong>&nbsp;子数组的最大数目，且每个子数组中数字和都为 <code>target</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,1,1,1], target = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>总共有 2 个不重叠子数组（加粗数字表示） [<strong>1,1</strong>,1,<strong>1,1</strong>] ，它们的和为目标值 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [-1,3,5,1,4,2,-9], target = 6\n<strong>输出：</strong>2\n<strong>解释：</strong>总共有 3 个子数组和为 6 。\n([5,1], [4,2], [3,5,1,4,2,-9]) 但只有前 2 个是不重叠的。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [-2,6,6,3,5,4,1,2,8], target = 10\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,0,0], target = 0\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;=&nbsp;10^5</code></li>\n\t<li><code>-10^4 &lt;= nums[i] &lt;=&nbsp;10^4</code></li>\n\t<li><code>0 &lt;= target &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1547.切棍子的最小成本",
        "hardRate": "HARD",
        "passRate": "56.63%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-cut-a-stick/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-cut-a-stick/solution",
        "problemsDesc": "<p>有一根长度为 <code>n</code> 个单位的木棍，棍上从 <code>0</code> 到 <code>n</code> 标记了若干位置。例如，长度为 <strong>6</strong> 的棍子可以标记如下：</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/09/statement.jpg\" style=\"height: 111px; width: 521px;\" /></p>\n\n<p>给你一个整数数组 <code>cuts</code> ，其中 <code>cuts[i]</code> 表示你需要将棍子切开的位置。</p>\n\n<p>你可以按顺序完成切割，也可以根据需要更改切割的顺序。</p>\n\n<p>每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是历次切割成本的总和。对棍子进行切割将会把一根木棍分成两根较小的木棍（这两根木棍的长度和就是切割前木棍的长度）。请参阅第一个示例以获得更直观的解释。</p>\n\n<p>返回切棍子的 <strong>最小总成本</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/09/e1.jpg\" style=\"height: 284px; width: 350px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 7, cuts = [1,3,4,5]\n<strong>输出：</strong>16\n<strong>解释：</strong>按 [1, 3, 4, 5] 的顺序切割的情况如下所示：\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/09/e11.jpg\" style=\"height: 284px; width: 350px;\" />\n第一次切割长度为 7 的棍子，成本为 7 。第二次切割长度为 6 的棍子（即第一次切割得到的第二根棍子），第三次切割为长度 4 的棍子，最后切割长度为 3 的棍子。总成本为 7 + 6 + 4 + 3 = 20 。\n而将切割顺序重新排列为 [3, 5, 1, 4] 后，总成本 = 16（如示例图中 7 + 4 + 3 + 2 = 16）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 9, cuts = [5,6,1,4,2]\n<strong>输出：</strong>22\n<strong>解释：</strong>如果按给定的顺序切割，则总成本为 25 。总成本 <= 25 的切割顺序很多，例如，[4, 6, 5, 2, 1] 的总成本 = 22，是所有可能方案中成本最小的。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 10^6</code></li>\n\t<li><code>1 <= cuts.length <= min(n - 1, 100)</code></li>\n\t<li><code>1 <= cuts[i] <= n - 1</code></li>\n\t<li><code>cuts</code> 数组中的所有整数都 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1548.图中最相似的路径",
        "hardRate": "HARD",
        "passRate": "68.02%",
        "problemsUrl": "https://leetcode.cn/problems/the-most-similar-path-in-a-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/the-most-similar-path-in-a-graph/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1549.每件商品的最新订单",
        "hardRate": "MEDIUM",
        "passRate": "67.71%",
        "problemsUrl": "https://leetcode.cn/problems/the-most-recent-orders-for-each-product/",
        "solutionsUrl": "https://leetcode.cn/problems/the-most-recent-orders-for-each-product/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1550.存在连续三个奇数的数组",
        "hardRate": "EASY",
        "passRate": "65.61%",
        "problemsUrl": "https://leetcode.cn/problems/three-consecutive-odds/",
        "solutionsUrl": "https://leetcode.cn/problems/three-consecutive-odds/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code>，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,6,4,1]\n<strong>输出：</strong>false\n<strong>解释：</strong>不存在连续三个元素都是奇数的情况。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,34,3,4,5,7,23,12]\n<strong>输出：</strong>true\n<strong>解释：</strong>存在连续三个元素都是奇数的情况，即 [5,7,23] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1551.使数组中所有元素相等的最小操作数",
        "hardRate": "MEDIUM",
        "passRate": "82.15%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-array-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-array-equal/solution",
        "problemsDesc": "<p>存在一个长度为 <code>n</code> 的数组 <code>arr</code> ，其中 <code>arr[i] = (2 * i) + 1</code> （ <code>0 &lt;= i &lt; n</code> ）。</p>\n\n<p>一次操作中，你可以选出两个下标，记作 <code>x</code> 和 <code>y</code> （ <code>0 &lt;= x, y &lt; n</code> ）并使 <code>arr[x]</code> 减去 <code>1</code> 、<code>arr[y]</code> 加上 <code>1</code> （即 <code>arr[x] -=1 </code>且 <code>arr[y] += 1</code> ）。最终的目标是使数组中的所有元素都 <strong>相等</strong> 。题目测试用例将会 <strong>保证</strong> ：在执行若干步操作后，数组中的所有元素最终可以全部相等。</p>\n\n<p>给你一个整数 <code>n</code>，即数组的长度。请你返回使数组 <code>arr</code> 中所有元素相等所需的 <strong>最小操作数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>arr = [1, 3, 5]\n第一次操作选出 x = 2 和 y = 0，使数组变为 [2, 3, 4]\n第二次操作继续选出 x = 2 和 y = 0，数组将会变成 [3, 3, 3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 6\n<strong>输出：</strong>9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1552.两球之间的磁力",
        "hardRate": "MEDIUM",
        "passRate": "56.85%",
        "problemsUrl": "https://leetcode.cn/problems/magnetic-force-between-two-balls/",
        "solutionsUrl": "https://leetcode.cn/problems/magnetic-force-between-two-balls/solution",
        "problemsDesc": "<p>在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有&nbsp;<code>n</code>&nbsp;个空的篮子，第&nbsp;<code>i</code>&nbsp;个篮子的位置在&nbsp;<code>position[i]</code>&nbsp;，Morty&nbsp;想把&nbsp;<code>m</code>&nbsp;个球放到这些篮子里，使得任意两球间&nbsp;<strong>最小磁力</strong>&nbsp;最大。</p>\n\n<p>已知两个球如果分别位于&nbsp;<code>x</code>&nbsp;和&nbsp;<code>y</code>&nbsp;，那么它们之间的磁力为&nbsp;<code>|x - y|</code>&nbsp;。</p>\n\n<p>给你一个整数数组&nbsp;<code>position</code>&nbsp;和一个整数&nbsp;<code>m</code>&nbsp;，请你返回最大化的最小磁力。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/16/q3v1.jpg\" style=\"height: 195px; width: 562px;\"></p>\n\n<pre><strong>输入：</strong>position = [1,2,3,4,7], m = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>将 3 个球分别放入位于 1，4 和 7 的三个篮子，两球间的磁力分别为 [3, 3, 6]。最小磁力为 3 。我们没办法让最小磁力大于 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>position = [5,4,3,2,1,1000000000], m = 2\n<strong>输出：</strong>999999999\n<strong>解释：</strong>我们使用位于 1 和 1000000000 的篮子时最小磁力最大。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == position.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= position[i] &lt;= 10^9</code></li>\n\t<li>所有&nbsp;<code>position</code>&nbsp;中的整数 <strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>2 &lt;= m &lt;= position.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1553.吃掉 N 个橘子的最少天数",
        "hardRate": "HARD",
        "passRate": "32.42%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-days-to-eat-n-oranges/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-days-to-eat-n-oranges/solution",
        "problemsDesc": "<p>厨房里总共有 <code>n</code>&nbsp;个橘子，你决定每一天选择如下方式之一吃这些橘子：</p>\n\n<ul>\n\t<li>吃掉一个橘子。</li>\n\t<li>如果剩余橘子数 <code>n</code>&nbsp;能被 2 整除，那么你可以吃掉 <code>n/2</code> 个橘子。</li>\n\t<li>如果剩余橘子数&nbsp;<code>n</code>&nbsp;能被 3 整除，那么你可以吃掉 <code>2*(n/3)</code> 个橘子。</li>\n</ul>\n\n<p>每天你只能从以上 3 种方案中选择一种方案。</p>\n\n<p>请你返回吃掉所有 <code>n</code>&nbsp;个橘子的最少天数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 10\n<strong>输出：</strong>4\n<strong>解释：</strong>你总共有 10 个橘子。\n第 1 天：吃 1 个橘子，剩余橘子数 10 - 1 = 9。\n第 2 天：吃 6 个橘子，剩余橘子数 9 - 2*(9/3) = 9 - 6 = 3。（9 可以被 3 整除）\n第 3 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。\n第 4 天：吃掉最后 1 个橘子，剩余橘子数 1 - 1 = 0。\n你需要至少 4 天吃掉 10 个橘子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 6\n<strong>输出：</strong>3\n<strong>解释：</strong>你总共有 6 个橘子。\n第 1 天：吃 3 个橘子，剩余橘子数 6 - 6/2 = 6 - 3 = 3。（6 可以被 2 整除）\n第 2 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。（3 可以被 3 整除）\n第 3 天：吃掉剩余 1 个橘子，剩余橘子数 1 - 1 = 0。\n你至少需要 3 天吃掉 6 个橘子。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 56\n<strong>输出：</strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2*10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1554.只有一个不同字符的字符串",
        "hardRate": "MEDIUM",
        "passRate": "49.96%",
        "problemsUrl": "https://leetcode.cn/problems/strings-differ-by-one-character/",
        "solutionsUrl": "https://leetcode.cn/problems/strings-differ-by-one-character/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1555.银行账户概要",
        "hardRate": "MEDIUM",
        "passRate": "44.96%",
        "problemsUrl": "https://leetcode.cn/problems/bank-account-summary/",
        "solutionsUrl": "https://leetcode.cn/problems/bank-account-summary/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1556.千位分隔数",
        "hardRate": "EASY",
        "passRate": "56.13%",
        "problemsUrl": "https://leetcode.cn/problems/thousand-separator/",
        "solutionsUrl": "https://leetcode.cn/problems/thousand-separator/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>，请你每隔三位添加点（即 &quot;.&quot; 符号）作为千位分隔符，并将结果以字符串格式返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 987\n<strong>输出：</strong>&quot;987&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 1234\n<strong>输出：</strong>&quot;1.234&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 123456789\n<strong>输出：</strong>&quot;123.456.789&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 0\n<strong>输出：</strong>&quot;0&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt; 2^31</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1557.可以到达所有点的最少点数目",
        "hardRate": "MEDIUM",
        "passRate": "81.54%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-vertices-to-reach-all-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-vertices-to-reach-all-nodes/solution",
        "problemsDesc": "<p>给你一个 <strong>有向无环图</strong>&nbsp;， <code>n</code>&nbsp;个节点编号为 <code>0</code>&nbsp;到 <code>n-1</code>&nbsp;，以及一个边数组 <code>edges</code>&nbsp;，其中 <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>]</code>&nbsp;表示一条从点&nbsp;&nbsp;<code>from<sub>i</sub></code>&nbsp;到点&nbsp;<code>to<sub>i</sub></code>&nbsp;的有向边。</p>\n\n<p>找到最小的点集使得从这些点出发能到达图中所有点。题目保证解存在且唯一。</p>\n\n<p>你可以以任意顺序返回这些节点编号。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5480e1.png\" style=\"height: 181px; width: 231px;\"></p>\n\n<pre><strong>输入：</strong>n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]\n<strong>输出：</strong>[0,3]\n<strong>解释：</strong>从单个节点出发无法到达所有节点。从 0 出发我们可以到达 [0,1,2,5] 。从 3 出发我们可以到达 [3,4,2,5] 。所以我们输出 [0,3] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5480e2.png\" style=\"height: 201px; width: 201px;\"></p>\n\n<pre><strong>输入：</strong>n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]]\n<strong>输出：</strong>[0,2,3]\n<strong>解释：</strong>注意到节点 0，3 和 2 无法从其他节点到达，所以我们必须将它们包含在结果点集中，这些点都能到达节点 1 和 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= min(10^5, n * (n - 1) / 2)</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= from<sub>i,</sub>&nbsp;to<sub>i</sub> &lt; n</code></li>\n\t<li>所有点对&nbsp;<code>(from<sub>i</sub>, to<sub>i</sub>)</code>&nbsp;互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1558.得到目标数组的最少函数调用次数",
        "hardRate": "MEDIUM",
        "passRate": "62.99%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-numbers-of-function-calls-to-make-target-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-numbers-of-function-calls-to-make-target-array/solution",
        "problemsDesc": "<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/10/sample_2_1887.png\" style=\"height:294px; width:573px\" /></p>\n\n<p>给你一个与 <code>nums</code>&nbsp;大小相同且初始值全为 0 的数组 <code>arr</code> ，请你调用以上函数得到整数数组 <code>nums</code>&nbsp;。</p>\n\n<p>请你返回将 <code>arr</code>&nbsp;变成 <code>nums</code>&nbsp;的最少函数调用次数。</p>\n\n<p>答案保证在 32 位有符号整数以内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5]\n<strong>输出：</strong>5\n<strong>解释：</strong>给第二个数加 1 ：[0, 0] 变成 [0, 1] （1 次操作）。\n将所有数字乘以 2 ：[0, 1] -&gt; [0, 2] -&gt; [0, 4] （2 次操作）。\n给两个数字都加 1 ：[0, 4] -&gt; [1, 4] -&gt; <strong>[1, 5]</strong> （2 次操作）。\n总操作次数为：1 + 2 + 2 = 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2]\n<strong>输出：</strong>3\n<strong>解释：</strong>给两个数字都加 1 ：[0, 0] -&gt; [0, 1] -&gt; [1, 1] （2 次操作）。\n将所有数字乘以 2 ： [1, 1] -&gt; <strong>[2, 2]</strong> （1 次操作）。\n总操作次数为： 2 + 1 = 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,2,5]\n<strong>输出：</strong>6\n<strong>解释：</strong>（初始）[0,0,0] -&gt; [1,0,0] -&gt; [1,0,1] -&gt; [2,0,2] -&gt; [2,1,2] -&gt; [4,2,4] -&gt; <strong>[4,2,5] </strong>（nums 数组）。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,2,4]\n<strong>输出：</strong>7\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,4,8,16]\n<strong>输出：</strong>8\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1559.二维网格图中探测环",
        "hardRate": "MEDIUM",
        "passRate": "40.61%",
        "problemsUrl": "https://leetcode.cn/problems/detect-cycles-in-2d-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/detect-cycles-in-2d-grid/solution",
        "problemsDesc": "<p>给你一个二维字符网格数组&nbsp;<code>grid</code>&nbsp;，大小为&nbsp;<code>m x n</code>&nbsp;，你需要检查&nbsp;<code>grid</code>&nbsp;中是否存在 <strong>相同值</strong> 形成的环。</p>\n\n<p>一个环是一条开始和结束于同一个格子的长度 <strong>大于等于 4</strong>&nbsp;的路径。对于一个给定的格子，你可以移动到它上、下、左、右四个方向相邻的格子之一，可以移动的前提是这两个格子有 <strong>相同的值&nbsp;</strong>。</p>\n\n<p>同时，你也不能回到上一次移动时所在的格子。比方说，环&nbsp;&nbsp;<code>(1, 1) -&gt; (1, 2) -&gt; (1, 1)</code>&nbsp;是不合法的，因为从 <code>(1, 2)</code>&nbsp;移动到 <code>(1, 1)</code> 回到了上一次移动时的格子。</p>\n\n<p>如果 <code>grid</code>&nbsp;中有相同值形成的环，请你返回 <code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e1.png\" style=\"height: 152px; width: 231px;\"></strong></p>\n\n<pre><strong>输入：</strong>grid = [[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]]\n<strong>输出：</strong>true\n<strong>解释：</strong>如下图所示，有 2 个用不同颜色标出来的环：\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e11.png\" style=\"height: 163px; width: 225px;\">\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e2.png\" style=\"height: 154px; width: 236px;\"></strong></p>\n\n<pre><strong>输入：</strong>grid = [[&quot;c&quot;,&quot;c&quot;,&quot;c&quot;,&quot;a&quot;],[&quot;c&quot;,&quot;d&quot;,&quot;c&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;c&quot;,&quot;e&quot;,&quot;c&quot;],[&quot;f&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]]\n<strong>输出：</strong>true\n<strong>解释：</strong>如下图所示，只有高亮所示的一个合法环：\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e22.png\" style=\"height: 157px; width: 229px;\">\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e3.png\" style=\"height: 120px; width: 183px;\"></strong></p>\n\n<pre><strong>输入：</strong>grid = [[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;z&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;b&quot;,&quot;a&quot;]]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m &lt;= 500</code></li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>grid</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1560.圆形赛道上经过次数最多的扇区",
        "hardRate": "EASY",
        "passRate": "57.46%",
        "problemsUrl": "https://leetcode.cn/problems/most-visited-sector-in-a-circular-track/",
        "solutionsUrl": "https://leetcode.cn/problems/most-visited-sector-in-a-circular-track/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> 和一个整数数组 <code>rounds</code> 。有一条圆形赛道由 <code>n</code> 个扇区组成，扇区编号从 <code>1</code> 到 <code>n</code> 。现将在这条赛道上举办一场马拉松比赛，该马拉松全程由 <code>m</code> 个阶段组成。其中，第 <code>i</code> 个阶段将会从扇区 <code>rounds[i - 1]</code> 开始，到扇区 <code>rounds[i]</code> 结束。举例来说，第 <code>1</code> 阶段从&nbsp;<code>rounds[0]</code>&nbsp;开始，到&nbsp;<code>rounds[1]</code>&nbsp;结束。</p>\n\n<p>请你以数组形式返回经过次数最多的那几个扇区，按扇区编号 <strong>升序</strong> 排列。</p>\n\n<p>注意，赛道按扇区编号升序逆时针形成一个圆（请参见第一个示例）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/3rd45e.jpg\" style=\"height: 341px; width: 433px;\"></p>\n\n<pre><strong>输入：</strong>n = 4, rounds = [1,3,1,2]\n<strong>输出：</strong>[1,2]\n<strong>解释：</strong>本场马拉松比赛从扇区 1 开始。经过各个扇区的次序如下所示：\n1 --&gt; 2 --&gt; 3（阶段 1 结束）--&gt; 4 --&gt; 1（阶段 2 结束）--&gt; 2（阶段 3 结束，即本场马拉松结束）\n其中，扇区 1 和 2 都经过了两次，它们是经过次数最多的两个扇区。扇区 3 和 4 都只经过了一次。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, rounds = [2,1,2,1,2,1,2,1,2]\n<strong>输出：</strong>[2]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 7, rounds = [1,3,5,7]\n<strong>输出：</strong>[1,2,3,4,5,6,7]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= m &lt;= 100</code></li>\n\t<li><code>rounds.length == m + 1</code></li>\n\t<li><code>1 &lt;= rounds[i] &lt;= n</code></li>\n\t<li><code>rounds[i] != rounds[i + 1]</code> ，其中 <code>0 &lt;= i &lt; m</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1561.你可以获得的最大硬币数目",
        "hardRate": "MEDIUM",
        "passRate": "77.71%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-coins-you-can-get/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-coins-you-can-get/solution",
        "problemsDesc": "<p>有 3n 堆数目不一的硬币，你和你的朋友们打算按以下方式分硬币：</p>\n\n<ul>\n\t<li>每一轮中，你将会选出 <strong>任意</strong> 3 堆硬币（不一定连续）。</li>\n\t<li>Alice 将会取走硬币数量最多的那一堆。</li>\n\t<li>你将会取走硬币数量第二多的那一堆。</li>\n\t<li>Bob 将会取走最后一堆。</li>\n\t<li>重复这个过程，直到没有更多硬币。</li>\n</ul>\n\n<p>给你一个整数数组 <code>piles</code> ，其中 <code>piles[i]</code> 是第 <code>i</code> 堆中硬币的数目。</p>\n\n<p>返回你可以获得的最大硬币数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>piles = [2,4,1,2,7,8]\n<strong>输出：</strong>9\n<strong>解释：</strong>选出 (2, 7, 8) ，Alice 取走 8 枚硬币的那堆，你取走 <strong>7</strong> 枚硬币的那堆，Bob 取走最后一堆。\n选出 (1, 2, 4) , Alice 取走 4 枚硬币的那堆，你取走 <strong>2</strong> 枚硬币的那堆，Bob 取走最后一堆。\n你可以获得的最大硬币数目：7 + 2 = 9.\n考虑另外一种情况，如果选出的是 (1, <strong>2</strong>, 8) 和 (2, <strong>4</strong>, 7) ，你就只能得到 2 + 4 = 6 枚硬币，这不是最优解。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>piles = [2,4,5]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>piles = [9,8,7,6,5,1,2,3,4]\n<strong>输出：</strong>18\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= piles.length &lt;= 10^5</code></li>\n\t<li><code>piles.length % 3 == 0</code></li>\n\t<li><code>1 &lt;= piles[i] &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1562.查找大小为 M 的最新分组",
        "hardRate": "MEDIUM",
        "passRate": "36.63%",
        "problemsUrl": "https://leetcode.cn/problems/find-latest-group-of-size-m/",
        "solutionsUrl": "https://leetcode.cn/problems/find-latest-group-of-size-m/solution",
        "problemsDesc": "<p>给你一个数组 <code>arr</code> ，该数组表示一个从 <code>1</code> 到 <code>n</code> 的数字排列。有一个长度为 <code>n</code> 的二进制字符串，该字符串上的所有位最初都设置为 <code>0</code> 。</p>\n\n<p>在从 <code>1</code> 到 <code>n</code> 的每个步骤 <code>i</code> 中（假设二进制字符串和 <code>arr</code> 都是从 <code>1</code> 开始索引的情况下），二进制字符串上位于位置 <code>arr[i]</code> 的位将会设为 <code>1</code> 。</p>\n\n<p>给你一个整数 <code>m</code> ，请你找出二进制字符串上存在长度为 <code>m</code> 的一组 <code>1</code> 的最后步骤。一组 <code>1</code> 是一个连续的、由 <code>1</code> 组成的子串，且左右两边不再有可以延伸的 <code>1</code> 。</p>\n\n<p>返回存在长度 <strong>恰好</strong> 为 <code>m</code> 的 <strong>一组 <code>1</code>&nbsp;</strong> 的最后步骤。如果不存在这样的步骤，请返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,5,1,2,4], m = 1\n<strong>输出：</strong>4\n<strong>解释：\n</strong>步骤 1：&quot;00<strong>1</strong>00&quot;，由 1 构成的组：[&quot;1&quot;]\n步骤 2：&quot;0010<strong>1</strong>&quot;，由 1 构成的组：[&quot;1&quot;, &quot;1&quot;]\n步骤 3：&quot;<strong>1</strong>0101&quot;，由 1 构成的组：[&quot;1&quot;, &quot;1&quot;, &quot;1&quot;]\n步骤 4：&quot;1<strong>1</strong>101&quot;，由 1 构成的组：[&quot;111&quot;, &quot;1&quot;]\n步骤 5：&quot;111<strong>1</strong>1&quot;，由 1 构成的组：[&quot;11111&quot;]\n存在长度为 1 的一组 1 的最后步骤是步骤 4 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,1,5,4,2], m = 2\n<strong>输出：</strong>-1\n<strong>解释：\n</strong>步骤 1：&quot;00<strong>1</strong>00&quot;，由 1 构成的组：[&quot;1&quot;]\n步骤 2：&quot;<strong>1</strong>0100&quot;，由 1 构成的组：[&quot;1&quot;, &quot;1&quot;]\n步骤 3：&quot;1010<strong>1</strong>&quot;，由 1 构成的组：[&quot;1&quot;, &quot;1&quot;, &quot;1&quot;]\n步骤 4：&quot;101<strong>1</strong>1&quot;，由 1 构成的组：[&quot;1&quot;, &quot;111&quot;]\n步骤 5：&quot;1<strong>1</strong>111&quot;，由 1 构成的组：[&quot;11111&quot;]\n不管是哪一步骤都无法形成长度为 2 的一组 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1], m = 1\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,1], m = 2\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == arr.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= n</code></li>\n\t<li><code>arr</code> 中的所有整数 <strong>互不相同</strong></li>\n\t<li><code>1 &lt;= m&nbsp;&lt;= arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1563.石子游戏 V",
        "hardRate": "HARD",
        "passRate": "39.68%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game-v/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game-v/solution",
        "problemsDesc": "<p>几块石子 <strong>排成一行</strong> ，每块石子都有一个关联值，关联值为整数，由数组 <code>stoneValue</code> 给出。</p>\n\n<p>游戏中的每一轮：Alice 会将这行石子分成两个 <strong>非空行</strong>（即，左侧行和右侧行）；Bob 负责计算每一行的值，即此行中所有石子的值的总和。Bob 会丢弃值最大的行，Alice 的得分为剩下那行的值（每轮累加）。如果两行的值相等，Bob 让 Alice 决定丢弃哪一行。下一轮从剩下的那一行开始。</p>\n\n<p>只 <strong>剩下一块石子</strong> 时，游戏结束。Alice 的分数最初为 <strong><code>0</code></strong> 。</p>\n\n<p>返回 <strong>Alice 能够获得的最大分数</strong><em> 。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>stoneValue = [6,2,3,4,5,5]\n<strong>输出：</strong>18\n<strong>解释：</strong>在第一轮中，Alice 将行划分为 [6，2，3]，[4，5，5] 。左行的值是 11 ，右行的值是 14 。Bob 丢弃了右行，Alice 的分数现在是 11 。\n在第二轮中，Alice 将行分成 [6]，[2，3] 。这一次 Bob 扔掉了左行，Alice 的分数变成了 16（11 + 5）。\n最后一轮 Alice 只能将行分成 [2]，[3] 。Bob 扔掉右行，Alice 的分数现在是 18（16 + 2）。游戏结束，因为这行只剩下一块石头了。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>stoneValue = [7,7,7,7,7,7,7]\n<strong>输出：</strong>28\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>stoneValue = [4]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= stoneValue.length &lt;= 500</code></li>\n\t<li><code>1 &lt;=&nbsp;stoneValue[i] &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1564.把箱子放进仓库里 I",
        "hardRate": "MEDIUM",
        "passRate": "57.90%",
        "problemsUrl": "https://leetcode.cn/problems/put-boxes-into-the-warehouse-i/",
        "solutionsUrl": "https://leetcode.cn/problems/put-boxes-into-the-warehouse-i/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1565.按月统计订单数与顾客数",
        "hardRate": "EASY",
        "passRate": "73.90%",
        "problemsUrl": "https://leetcode.cn/problems/unique-orders-and-customers-per-month/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-orders-and-customers-per-month/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1566.重复至少 K 次且长度为 M 的模式",
        "hardRate": "EASY",
        "passRate": "44.30%",
        "problemsUrl": "https://leetcode.cn/problems/detect-pattern-of-length-m-repeated-k-or-more-times/",
        "solutionsUrl": "https://leetcode.cn/problems/detect-pattern-of-length-m-repeated-k-or-more-times/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>arr</code>，请你找出一个长度为 <code>m</code> 且在数组中至少重复 <code>k</code> 次的模式。</p>\n\n<p><strong>模式</strong> 是由一个或多个值组成的子数组（连续的子序列），<strong>连续</strong> 重复多次但 <strong>不重叠</strong> 。 模式由其长度和重复次数定义。</p>\n\n<p>如果数组中存在至少重复 <code>k</code> 次且长度为 <code>m</code> 的模式，则返回 <code>true</code> ，否则返回&nbsp; <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,4,4,4,4], m = 1, k = 3\n<strong>输出：</strong>true\n<strong>解释：</strong>模式 <strong>(4)</strong> 的长度为 1 ，且连续重复 4 次。注意，模式可以重复 k 次或更多次，但不能少于 k 次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,1,2,1,1,1,3], m = 2, k = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>模式 <strong>(1,2)</strong> 长度为 2 ，且连续重复 2 次。另一个符合题意的模式是 <strong>(2,1) </strong>，同样重复 2 次。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,1,2,1,3], m = 2, k = 3\n<strong>输出：</strong>false\n<strong>解释：</strong>模式 <strong>(1,2)</strong> 长度为 2 ，但是只连续重复 2 次。不存在长度为 2 且至少重复 3 次的模式。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,3,1,2], m = 2, k = 2\n<strong>输出：</strong>false\n<strong>解释：</strong>模式 <strong>(1,2)</strong> 出现 2 次但并不连续，所以不能算作连续重复 2 次。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,2,2,2], m = 2, k = 3\n<strong>输出：</strong>false\n<strong>解释：</strong>长度为 2 的模式只有 <strong>(2,2)</strong> ，但是只连续重复 2 次。注意，不能计算重叠的重复次数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= m&nbsp;&lt;= 100</code></li>\n\t<li><code>2 &lt;= k&nbsp;&lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1567.乘积为正数的最长子数组长度",
        "hardRate": "MEDIUM",
        "passRate": "42.65%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-length-of-subarray-with-positive-product/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-length-of-subarray-with-positive-product/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>&nbsp;，请你求出乘积为正数的最长子数组的长度。</p>\n\n<p>一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。</p>\n\n<p>请你返回乘积为正数的最长子数组长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp; 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,-2,-3,4]\n<strong>输出：</strong>4\n<strong>解释：</strong>数组本身乘积就是正数，值为 24 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,-2,-3,-4]\n<strong>输出：</strong>3\n<strong>解释：</strong>最长乘积为正数的子数组为 [1,-2,-3] ，乘积为 6 。\n注意，我们不能把 0 也包括到子数组中，因为这样乘积为 0 ，不是正数。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,-2,-3,0,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>乘积为正数的最长子数组是 [-1,-2] 或者 [-2,-3] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>-10^9 &lt;= nums[i]&nbsp;&lt;= 10^9</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1568.使陆地分离的最少天数",
        "hardRate": "HARD",
        "passRate": "44.99%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-days-to-disconnect-island/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-days-to-disconnect-island/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> ，由若干 <code>0</code> 和 <code>1</code> 组成的二维网格 <code>grid</code> ，其中 <code>1</code> 表示陆地， <code>0</code> 表示水。<strong>岛屿</strong> 由水平方向或竖直方向上相邻的 <code>1</code> （陆地）连接形成。</p>\n\n<p>如果 <strong>恰好只有一座岛屿 </strong>，则认为陆地是 <strong>连通的</strong> ；否则，陆地就是 <strong>分离的</strong> 。</p>\n\n<p>一天内，可以将 <strong>任何单个</strong> 陆地单元（<code>1</code>）更改为水单元（<code>0</code>）。</p>\n\n<p>返回使陆地分离的最少天数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/24/land1.jpg\" style=\"width: 500px; height: 169px;\" />\n<pre>\n<strong>输入：</strong>grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]\n<strong>输出：</strong>2\n<strong>解释：</strong>至少需要 2 天才能得到分离的陆地。\n将陆地 grid[1][1] 和 grid[0][2] 更改为水，得到两个分离的岛屿。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/24/land2.jpg\" style=\"width: 404px; height: 85px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,1]]\n<strong>输出：</strong>2\n<strong>解释：</strong>如果网格中都是水，也认为是分离的 ([[1,1]] -&gt; [[0,0]])，0 岛屿。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 30</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1569.将子数组重新排序得到同一个二叉搜索树的方案数",
        "hardRate": "HARD",
        "passRate": "49.20%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-reorder-array-to-get-same-bst/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-reorder-array-to-get-same-bst/solution",
        "problemsDesc": "<p>给你一个数组 <code>nums</code>&nbsp;表示 <code>1</code>&nbsp;到 <code>n</code>&nbsp;的一个排列。我们按照元素在 <code>nums</code>&nbsp;中的顺序依次插入一个初始为空的二叉搜索树（BST）。请你统计将 <code>nums</code>&nbsp;重新排序后，统计满足如下条件的方案数：重排后得到的二叉搜索树与 <code>nums</code>&nbsp;原本数字顺序得到的二叉搜索树相同。</p>\n\n<p>比方说，给你&nbsp;<code>nums = [2,1,3]</code>，我们得到一棵 2 为根，1 为左孩子，3 为右孩子的树。数组&nbsp;<code>[2,3,1]</code>&nbsp;也能得到相同的 BST，但&nbsp;<code>[3,2,1]</code>&nbsp;会得到一棵不同的&nbsp;BST 。</p>\n\n<p>请你返回重排 <code>nums</code>&nbsp;后，与原数组 <code>nums</code> 得到相同二叉搜索树的方案数。</p>\n\n<p>由于答案可能会很大，请将结果对<strong>&nbsp;</strong><code>10^9 + 7</code>&nbsp;取余数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/bb.png\" style=\"height: 101px; width: 121px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,3]\n<strong>输出：</strong>1\n<strong>解释：</strong>我们将 nums 重排， [2,3,1] 能得到相同的 BST 。没有其他得到相同 BST 的方案了。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/ex1.png\" style=\"height: 161px; width: 241px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,5,1,2]\n<strong>输出：</strong>5\n<strong>解释：</strong>下面 5 个数组会得到相同的 BST：\n[3,1,2,4,5]\n[3,1,4,2,5]\n[3,1,4,5,2]\n[3,4,1,2,5]\n[3,4,1,5,2]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/ex4.png\" style=\"height: 161px; width: 121px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>0\n<strong>解释：</strong>没有别的排列顺序能得到相同的 BST 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>\n\t<li><code>nums</code>&nbsp;中所有数 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1570.两个稀疏向量的点积",
        "hardRate": "MEDIUM",
        "passRate": "88.78%",
        "problemsUrl": "https://leetcode.cn/problems/dot-product-of-two-sparse-vectors/",
        "solutionsUrl": "https://leetcode.cn/problems/dot-product-of-two-sparse-vectors/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1571.仓库经理",
        "hardRate": "EASY",
        "passRate": "77.57%",
        "problemsUrl": "https://leetcode.cn/problems/warehouse-manager/",
        "solutionsUrl": "https://leetcode.cn/problems/warehouse-manager/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1572.矩阵对角线元素的和",
        "hardRate": "EASY",
        "passRate": "80.73%",
        "problemsUrl": "https://leetcode.cn/problems/matrix-diagonal-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/matrix-diagonal-sum/solution",
        "problemsDesc": "<p>给你一个正方形矩阵 <code>mat</code>，请你返回矩阵对角线元素的和。</p>\n\n<p>请你返回在矩阵主对角线上的元素和副对角线上且不在主对角线上元素的和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp; 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/14/sample_1911.png\" style=\"height:174px; width:336px\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[<strong>1</strong>,2,<strong>3</strong>],\n&nbsp;           [4,<strong>5</strong>,6],\n&nbsp;           [<strong>7</strong>,8,<strong>9</strong>]]\n<strong>输出：</strong>25\n<strong>解释：</strong>对角线的和为：1 + 5 + 9 + 3 + 7 = 25\n请注意，元素 mat[1][1] = 5 只会被计算一次。\n</pre>\n\n<p><strong>示例&nbsp; 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[<strong>1</strong>,1,1,<strong>1</strong>],\n&nbsp;           [1,<strong>1</strong>,<strong>1</strong>,1],\n&nbsp;           [1,<strong>1</strong>,<strong>1</strong>,1],\n&nbsp;           [<strong>1</strong>,1,1,<strong>1</strong>]]\n<strong>输出：</strong>8\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[<strong>5</strong>]]\n<strong>输出：</strong>5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == mat.length == mat[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= mat[i][j] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1573.分割字符串的方案数",
        "hardRate": "MEDIUM",
        "passRate": "31.21%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-split-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-split-a-string/solution",
        "problemsDesc": "<p>给你一个二进制串&nbsp;<code>s</code>&nbsp; （一个只包含 0 和 1 的字符串），我们可以将 <code>s</code>&nbsp;分割成 3 个 <strong>非空</strong>&nbsp;字符串 s1, s2, s3 （s1 + s2 + s3 = s）。</p>\n\n<p>请你返回分割&nbsp;<code>s</code>&nbsp;的方案数，满足 s1，s2 和 s3 中字符 &#39;1&#39; 的数目相同。</p>\n\n<p>由于答案可能很大，请将它对 10^9 + 7 取余后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;10101&quot;\n<strong>输出：</strong>4\n<strong>解释：</strong>总共有 4 种方法将 s 分割成含有 &#39;1&#39; 数目相同的三个子字符串。\n&quot;1|010|1&quot;\n&quot;1|01|01&quot;\n&quot;10|10|1&quot;\n&quot;10|1|01&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1001&quot;\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;0000&quot;\n<strong>输出：</strong>3\n<strong>解释：</strong>总共有 3 种分割 s 的方法。\n&quot;0|0|00&quot;\n&quot;0|00|0&quot;\n&quot;00|0|0&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;100100010100110&quot;\n<strong>输出：</strong>12\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s[i] == &#39;0&#39;</code>&nbsp;或者&nbsp;<code>s[i] == &#39;1&#39;</code></li>\n\t<li><code>3 &lt;= s.length &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1574.删除最短的子数组使剩余数组有序",
        "hardRate": "MEDIUM",
        "passRate": "43.20%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code>&nbsp;，请你删除一个子数组（可以为空），使得 <code>arr</code>&nbsp;中剩下的元素是 <strong>非递减</strong> 的。</p>\n\n<p>一个子数组指的是原数组中连续的一个子序列。</p>\n\n<p>请你返回满足题目要求的最短子数组的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,10,4,2,3,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>我们需要删除的最短子数组是 [10,4,2] ，长度为 3 。剩余元素形成非递减数组 [1,2,3,3,5] 。\n另一个正确的解为删除子数组 [3,10,4] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [5,4,3,2,1]\n<strong>输出：</strong>4\n<strong>解释：</strong>由于数组是严格递减的，我们只能保留一个元素。所以我们需要删除长度为 4 的子数组，要么删除 [5,4,3,2]，要么删除 [4,3,2,1]。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3]\n<strong>输出：</strong>0\n<strong>解释：</strong>数组已经是非递减的了，我们不需要删除任何元素。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1575.统计所有可行路径",
        "hardRate": "HARD",
        "passRate": "57.36%",
        "problemsUrl": "https://leetcode.cn/problems/count-all-possible-routes/",
        "solutionsUrl": "https://leetcode.cn/problems/count-all-possible-routes/solution",
        "problemsDesc": "<p>给你一个 <strong>互不相同</strong>&nbsp;的整数数组，其中&nbsp;<code>locations[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个城市的位置。同时给你&nbsp;<code>start</code>，<code>finish</code>&nbsp;和&nbsp;<code>fuel</code>&nbsp;分别表示出发城市、目的地城市和你初始拥有的汽油总量</p>\n\n<p>每一步中，如果你在城市 <code>i</code>&nbsp;，你可以选择任意一个城市 <code>j</code>&nbsp;，满足 &nbsp;<code>j != i</code>&nbsp;且&nbsp;<code>0 &lt;= j &lt; locations.length</code>&nbsp;，并移动到城市&nbsp;<code>j</code>&nbsp;。从城市&nbsp;<code>i</code>&nbsp;移动到&nbsp;<code>j</code>&nbsp;消耗的汽油量为&nbsp;<code>|locations[i] - locations[j]|</code>，<code>|x|</code>&nbsp;表示&nbsp;<code>x</code>&nbsp;的绝对值。</p>\n\n<p>请注意，&nbsp;<code>fuel</code>&nbsp;任何时刻都&nbsp;<strong>不能</strong>&nbsp;为负，且你&nbsp;<strong>可以</strong>&nbsp;经过任意城市超过一次（包括&nbsp;<code>start</code>&nbsp;和&nbsp;<code>finish</code>&nbsp;）。</p>\n\n<p>请你返回从<em>&nbsp;</em><code>start</code>&nbsp;到&nbsp;<code>finish</code>&nbsp;所有可能路径的数目。</p>\n\n<p>由于答案可能很大， 请将它对&nbsp;<code>10^9 + 7</code>&nbsp;取余后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5\n<strong>输出：</strong>4\n<strong>解释：</strong>以下为所有可能路径，每一条都用了 5 单位的汽油：\n1 -&gt; 3\n1 -&gt; 2 -&gt; 3\n1 -&gt; 4 -&gt; 3\n1 -&gt; 4 -&gt; 2 -&gt; 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>locations = [4,3,1], start = 1, finish = 0, fuel = 6\n<strong>输出：</strong>5\n<strong>解释：</strong>以下为所有可能的路径：\n1 -&gt; 0，使用汽油量为 fuel = 1\n1 -&gt; 2 -&gt; 0，使用汽油量为 fuel = 5\n1 -&gt; 2 -&gt; 1 -&gt; 0，使用汽油量为 fuel = 5\n1 -&gt; 0 -&gt; 1 -&gt; 0，使用汽油量为 fuel = 3\n1 -&gt; 0 -&gt; 1 -&gt; 0 -&gt; 1 -&gt; 0，使用汽油量为 fuel = 5\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>locations = [5,2,1], start = 0, finish = 2, fuel = 3\n<strong>输出：</strong>0\n<strong>解释：</strong>没有办法只用 3 单位的汽油从 0 到达 2 。因为最短路径需要 4 单位的汽油。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= locations.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= locations[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>所有&nbsp;<code>locations</code>&nbsp;中的整数 <strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>0 &lt;= start, finish &lt;&nbsp;locations.length</code></li>\n\t<li><code>1 &lt;= fuel &lt;= 200</code></li>\n</ul>\n",
        "isPlus": false
    }
]