[
    {
        "problemsName": " 2326.螺旋矩阵 IV",
        "hardRate": "MEDIUM",
        "passRate": "66.82%",
        "problemsUrl": "https://leetcode.cn/problems/spiral-matrix-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/spiral-matrix-iv/solution",
        "problemsDesc": "<p>给你两个整数：<code>m</code> 和 <code>n</code> ，表示矩阵的维数。</p>\n\n<p>另给你一个整数链表的头节点 <code>head</code> 。</p>\n\n<p>请你生成一个大小为 <code>m x n</code> 的螺旋矩阵，矩阵包含链表中的所有整数。链表中的整数从矩阵 <strong>左上角</strong> 开始、<strong>顺时针 </strong>按 <strong>螺旋</strong> 顺序填充。如果还存在剩余的空格，则用 <code>-1</code> 填充。</p>\n\n<p>返回生成的矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/09/ex1new.jpg\" style=\"width: 240px; height: 150px;\">\n<pre><strong>输入：</strong>m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]\n<strong>输出：</strong>[[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]\n<strong>解释：</strong>上图展示了链表中的整数在矩阵中是如何排布的。\n注意，矩阵中剩下的空格用 -1 填充。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/11/ex2.jpg\" style=\"width: 221px; height: 60px;\">\n<pre><strong>输入：</strong>m = 1, n = 4, head = [0,1,2]\n<strong>输出：</strong>[[0,1,2,-1]]\n<strong>解释：</strong>上图展示了链表中的整数在矩阵中是如何从左到右排布的。 \n注意，矩阵中剩下的空格用 -1 填充。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li>链表中节点数目在范围 <code>[1, m * n]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2327.知道秘密的人数",
        "hardRate": "MEDIUM",
        "passRate": "45.82%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-people-aware-of-a-secret/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-people-aware-of-a-secret/solution",
        "problemsDesc": "<p>在第 <code>1</code>&nbsp;天，有一个人发现了一个秘密。</p>\n\n<p>给你一个整数&nbsp;<code>delay</code>&nbsp;，表示每个人会在发现秘密后的 <code>delay</code>&nbsp;天之后，<strong>每天</strong>&nbsp;给一个新的人&nbsp;<strong>分享</strong>&nbsp;秘密。同时给你一个整数&nbsp;<code>forget</code>&nbsp;，表示每个人在发现秘密&nbsp;<code>forget</code>&nbsp;天之后会&nbsp;<strong>忘记</strong>&nbsp;这个秘密。一个人&nbsp;<strong>不能</strong>&nbsp;在忘记秘密那一天及之后的日子里分享秘密。</p>\n\n<p>给你一个整数&nbsp;<code>n</code>&nbsp;，请你返回在第 <code>n</code>&nbsp;天结束时，知道秘密的人数。由于答案可能会很大，请你将结果对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 6, delay = 2, forget = 4\n<b>输出：</b>5\n<strong>解释：</strong>\n第 1 天：假设第一个人叫 A 。（一个人知道秘密）\n第 2 天：A 是唯一一个知道秘密的人。（一个人知道秘密）\n第 3 天：A 把秘密分享给 B 。（两个人知道秘密）\n第 4 天：A 把秘密分享给一个新的人 C 。（三个人知道秘密）\n第 5 天：A 忘记了秘密，B 把秘密分享给一个新的人 D 。（三个人知道秘密）\n第 6 天：B 把秘密分享给 E，C 把秘密分享给 F 。（五个人知道秘密）\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 4, delay = 1, forget = 3\n<b>输出：</b>6\n<strong>解释：</strong>\n第 1 天：第一个知道秘密的人为 A 。（一个人知道秘密）\n第 2 天：A 把秘密分享给 B 。（两个人知道秘密）\n第 3 天：A 和 B 把秘密分享给 2 个新的人 C 和 D 。（四个人知道秘密）\n第 4 天：A 忘记了秘密，B、C、D 分别分享给 3 个新的人。（六个人知道秘密）\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= delay &lt; forget &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2328.网格图中递增路径的数目",
        "hardRate": "HARD",
        "passRate": "51.03%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的整数网格图&nbsp;<code>grid</code>&nbsp;，你可以从一个格子移动到&nbsp;<code>4</code>&nbsp;个方向相邻的任意一个格子。</p>\n\n<p>请你返回在网格图中从 <strong>任意</strong>&nbsp;格子出发，达到 <strong>任意</strong>&nbsp;格子，且路径中的数字是 <strong>严格递增</strong>&nbsp;的路径数目。由于答案可能会很大，请将结果对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>如果两条路径中访问过的格子不是完全相同的，那么它们视为两条不同的路径。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/10/griddrawio-4.png\" style=\"width: 181px; height: 121px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,1],[3,4]]\n<b>输出：</b>8\n<b>解释：</b>严格递增路径包括：\n- 长度为 1 的路径：[1]，[1]，[3]，[4] 。\n- 长度为 2 的路径：[1 -&gt; 3]，[1 -&gt; 4]，[3 -&gt; 4] 。\n- 长度为 3 的路径：[1 -&gt; 3 -&gt; 4] 。\n路径数目为 4 + 3 + 1 = 8 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>grid = [[1],[2]]\n<b>输出：</b>3\n<b>解释：</b>严格递增路径包括：\n- 长度为 1 的路径：[1]，[2] 。\n- 长度为 2 的路径：[1 -&gt; 2] 。\n路径数目为 2 + 1 = 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2329.产品销售分析Ⅴ",
        "hardRate": "EASY",
        "passRate": "72.48%",
        "problemsUrl": "https://leetcode.cn/problems/product-sales-analysis-v/",
        "solutionsUrl": "https://leetcode.cn/problems/product-sales-analysis-v/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2330.有效的回文 IV",
        "hardRate": "MEDIUM",
        "passRate": "82.08%",
        "problemsUrl": "https://leetcode.cn/problems/valid-palindrome-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-palindrome-iv/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2331.计算布尔二叉树的值",
        "hardRate": "EASY",
        "passRate": "83.98%",
        "problemsUrl": "https://leetcode.cn/problems/evaluate-boolean-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/evaluate-boolean-binary-tree/solution",
        "problemsDesc": "<p>给你一棵 <strong>完整二叉树</strong>&nbsp;的根，这棵树有以下特征：</p>\n\n<ul>\n\t<li><strong>叶子节点</strong>&nbsp;要么值为&nbsp;<code>0</code>&nbsp;要么值为&nbsp;<code>1</code>&nbsp;，其中&nbsp;<code>0</code> 表示&nbsp;<code>False</code>&nbsp;，<code>1</code> 表示&nbsp;<code>True</code>&nbsp;。</li>\n\t<li><strong>非叶子节点 </strong>要么值为 <code>2</code>&nbsp;要么值为 <code>3</code>&nbsp;，其中&nbsp;<code>2</code>&nbsp;表示逻辑或&nbsp;<code>OR</code> ，<code>3</code>&nbsp;表示逻辑与&nbsp;<code>AND</code>&nbsp;。</li>\n</ul>\n\n<p><strong>计算</strong>&nbsp;一个节点的值方式如下：</p>\n\n<ul>\n\t<li>如果节点是个叶子节点，那么节点的 <strong>值</strong>&nbsp;为它本身，即&nbsp;<code>True</code>&nbsp;或者&nbsp;<code>False</code>&nbsp;。</li>\n\t<li>否则，<strong>计算</strong>&nbsp;两个孩子的节点值，然后将该节点的运算符对两个孩子值进行 <strong>运算</strong>&nbsp;。</li>\n</ul>\n\n<p>返回根节点<em>&nbsp;</em><code>root</code>&nbsp;的布尔运算值。</p>\n\n<p><strong>完整二叉树</strong>&nbsp;是每个节点有 <code>0</code>&nbsp;个或者 <code>2</code>&nbsp;个孩子的二叉树。</p>\n\n<p><strong>叶子节点</strong>&nbsp;是没有孩子的节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/16/example1drawio1.png\" style=\"width: 700px; height: 252px;\"></p>\n\n<pre><b>输入：</b>root = [2,1,3,null,null,0,1]\n<b>输出：</b>true\n<b>解释：</b>上图展示了计算过程。\nAND 与运算节点的值为 False AND True = False 。\nOR 运算节点的值为 True OR False = True 。\n根节点的值为 True ，所以我们返回 true 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>root = [0]\n<b>输出：</b>false\n<b>解释：</b>根节点是叶子节点，且值为 false，所以我们返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在&nbsp;<code>[1, 1000]</code>&nbsp;之间。</li>\n\t<li><code>0 &lt;= Node.val &lt;= 3</code></li>\n\t<li>每个节点的孩子数为&nbsp;<code>0</code> 或&nbsp;<code>2</code>&nbsp;。</li>\n\t<li>叶子节点的值为&nbsp;<code>0</code>&nbsp;或&nbsp;<code>1</code>&nbsp;。</li>\n\t<li>非叶子节点的值为&nbsp;<code>2</code>&nbsp;或&nbsp;<code>3</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2332.坐上公交的最晚时间",
        "hardRate": "MEDIUM",
        "passRate": "24.42%",
        "problemsUrl": "https://leetcode.cn/problems/the-latest-time-to-catch-a-bus/",
        "solutionsUrl": "https://leetcode.cn/problems/the-latest-time-to-catch-a-bus/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>buses</code>&nbsp;，其中&nbsp;<code>buses[i]</code>&nbsp;表示第 <code>i</code>&nbsp;辆公交车的出发时间。同时给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>m</code>&nbsp;的整数数组&nbsp;<code>passengers</code>&nbsp;，其中&nbsp;<code>passengers[j]</code>&nbsp;表示第&nbsp;<code>j</code>&nbsp;位乘客的到达时间。所有公交车出发的时间互不相同，所有乘客到达的时间也互不相同。</p>\n\n<p>给你一个整数&nbsp;<code>capacity</code>&nbsp;，表示每辆公交车&nbsp;<strong>最多</strong>&nbsp;能容纳的乘客数目。</p>\n\n<p>每位乘客都会搭乘下一辆有座位的公交车。如果你在 <code>y</code>&nbsp;时刻到达，公交在&nbsp;<code>x</code>&nbsp;时刻出发，满足&nbsp;<code>y &lt;= x</code>&nbsp;&nbsp;且公交没有满，那么你可以搭乘这一辆公交。<strong>最早</strong>&nbsp;到达的乘客优先上车。</p>\n\n<p>返回你可以搭乘公交车的最晚到达公交站时间。你 <strong>不能</strong>&nbsp;跟别的乘客同时刻到达。</p>\n\n<p><strong>注意：</strong>数组&nbsp;<code>buses</code> 和&nbsp;<code>passengers</code>&nbsp;不一定是有序的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>buses = [10,20], passengers = [2,17,18,19], capacity = 2\n<b>输出：</b>16\n<strong>解释：</strong>\n第 1 辆公交车载着第 1 位乘客。\n第 2 辆公交车载着你和第 2 位乘客。\n注意你不能跟其他乘客同一时间到达，所以你必须在第二位乘客之前到达。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2\n<b>输出：</b>20\n<b>解释：</b>\n第 1 辆公交车载着第 4 位乘客。\n第 2 辆公交车载着第 6 位和第 2 位乘客。\n第 3 辆公交车载着第 1 位乘客和你。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == buses.length</code></li>\n\t<li><code>m == passengers.length</code></li>\n\t<li><code>1 &lt;= n, m, capacity &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= buses[i], passengers[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>buses</code>&nbsp;中的元素 <strong>互不相同&nbsp;</strong>。</li>\n\t<li><code>passengers</code>&nbsp;中的元素 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2333.最小差值平方和",
        "hardRate": "MEDIUM",
        "passRate": "26.72%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-sum-of-squared-difference/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-sum-of-squared-difference/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;，长度为&nbsp;<code>n</code>&nbsp;。</p>\n\n<p>数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;的 <strong>差值平方和</strong>&nbsp;定义为所有满足&nbsp;<code>0 &lt;= i &lt; n</code>&nbsp;的&nbsp;<code>(nums1[i] - nums2[i])<sup>2</sup></code>&nbsp;之和。</p>\n\n<p>同时给你两个正整数&nbsp;<code>k1</code> 和&nbsp;<code>k2</code>&nbsp;。你可以将&nbsp;<code>nums1</code>&nbsp;中的任意元素&nbsp;<code>+1</code> 或者&nbsp;<code>-1</code>&nbsp;至多&nbsp;<code>k1</code>&nbsp;次。类似的，你可以将&nbsp;<code>nums2</code>&nbsp;中的任意元素&nbsp;<code>+1</code> 或者&nbsp;<code>-1</code>&nbsp;至多&nbsp;<code>k2</code>&nbsp;次。</p>\n\n<p>请你返回修改数组<em>&nbsp;</em><code>nums1</code><em>&nbsp;</em>至多<em>&nbsp;</em><code>k1</code>&nbsp;次且修改数组<em>&nbsp;</em><code>nums2</code>&nbsp;至多 <code>k2</code><em>&nbsp;</em>次后的最小&nbsp;<strong>差值平方和</strong>&nbsp;。</p>\n\n<p><strong>注意：</strong>你可以将数组中的元素变成&nbsp;<strong>负</strong>&nbsp;整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,2,3,4], nums2 = [2,10,20,19], k1 = 0, k2 = 0\n<b>输出：</b>579\n<b>解释：</b>nums1 和 nums2 中的元素不能修改，因为 k1 = 0 和 k2 = 0 。\n差值平方和为：(1 - 2)<sup>2 </sup>+ (2 - 10)<sup>2 </sup>+ (3 - 20)<sup>2 </sup>+ (4 - 19)<sup>2</sup>&nbsp;= 579 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,4,10,12], nums2 = [5,8,6,9], k1 = 1, k2 = 1\n<b>输出：</b>43\n<b>解释：</b>一种得到最小差值平方和的方式为：\n- 将 nums1[0] 增加一次。\n- 将 nums2[2] 增加一次。\n最小差值平方和为：\n(2 - 5)<sup>2 </sup>+ (4 - 8)<sup>2 </sup>+ (10 - 7)<sup>2 </sup>+ (12 - 9)<sup>2</sup>&nbsp;= 43 。\n注意，也有其他方式可以得到最小差值平方和，但没有得到比 43 更小答案的方案。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length == nums2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= k1, k2 &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2334.元素值大于变化阈值的子数组",
        "hardRate": "HARD",
        "passRate": "47.41%",
        "problemsUrl": "https://leetcode.cn/problems/subarray-with-elements-greater-than-varying-threshold/",
        "solutionsUrl": "https://leetcode.cn/problems/subarray-with-elements-greater-than-varying-threshold/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>threshold</code>&nbsp;。</p>\n\n<p>找到长度为 <code>k</code>&nbsp;的&nbsp;<code>nums</code>&nbsp;子数组，满足数组中&nbsp;<strong>每个</strong>&nbsp;元素都 <strong>大于</strong>&nbsp;<code>threshold / k</code>&nbsp;。</p>\n\n<p>请你返回满足要求的 <strong>任意</strong>&nbsp;子数组的 <strong>大小</strong>&nbsp;。如果没有这样的子数组，返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p><strong>子数组</strong> 是数组中一段连续非空的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,3,4,3,1], threshold = 6\n<b>输出：</b>3\n<b>解释：</b>子数组 [3,4,3] 大小为 3 ，每个元素都大于 6 / 3 = 2 。\n注意这是唯一合法的子数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [6,5,6,5,8], threshold = 7\n<b>输出：</b>1\n<b>解释：</b>子数组 [8] 大小为 1 ，且 8 &gt; 7 / 1 = 7 。所以返回 1 。\n注意子数组 [6,5] 大小为 2 ，每个元素都大于 7 / 2 = 3.5 。\n类似的，子数组 [6,5,6] ，[6,5,6,5] ，[6,5,6,5,8] 都是符合条件的子数组。\n所以返回 2, 3, 4 和 5 都可以。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], threshold &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2335.装满杯子需要的最短总时长",
        "hardRate": "EASY",
        "passRate": "64.53%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-amount-of-time-to-fill-cups/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-amount-of-time-to-fill-cups/solution",
        "problemsDesc": "<p>现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满 <code>2</code> 杯 <strong>不同</strong> 类型的水或者 <code>1</code> 杯任意类型的水。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>3</code> 的整数数组 <code>amount</code> ，其中 <code>amount[0]</code>、<code>amount[1]</code> 和 <code>amount[2]</code> 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 <strong>最少</strong> 秒数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>amount = [1,4,2]\n<strong>输出：</strong>4\n<strong>解释：</strong>下面给出一种方案：\n第 1 秒：装满一杯冷水和一杯温水。\n第 2 秒：装满一杯温水和一杯热水。\n第 3 秒：装满一杯温水和一杯热水。\n第 4 秒：装满一杯温水。\n可以证明最少需要 4 秒才能装满所有杯子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>amount = [5,4,4]\n<strong>输出：</strong>7\n<strong>解释：</strong>下面给出一种方案：\n第 1 秒：装满一杯冷水和一杯热水。\n第 2 秒：装满一杯冷水和一杯温水。\n第 3 秒：装满一杯冷水和一杯温水。\n第 4 秒：装满一杯温水和一杯热水。\n第 5 秒：装满一杯冷水和一杯热水。\n第 6 秒：装满一杯冷水和一杯温水。\n第 7 秒：装满一杯热水。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>amount = [5,0,0]\n<strong>输出：</strong>5\n<strong>解释：</strong>每秒装满一杯冷水。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>amount.length == 3</code></li>\n\t<li><code>0 &lt;= amount[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2336.无限集中的最小数字",
        "hardRate": "MEDIUM",
        "passRate": "69.65%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-number-in-infinite-set/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-number-in-infinite-set/solution",
        "problemsDesc": "<p>现有一个包含所有正整数的集合 <code>[1, 2, 3, 4, 5, ...]</code> 。</p>\n\n<p>实现 <code>SmallestInfiniteSet</code> 类：</p>\n\n<ul>\n\t<li><code>SmallestInfiniteSet()</code> 初始化 <strong>SmallestInfiniteSet</strong> 对象以包含 <strong>所有</strong> 正整数。</li>\n\t<li><code>int popSmallest()</code> <strong>移除</strong> 并返回该无限集中的最小整数。</li>\n\t<li><code>void addBack(int num)</code> 如果正整数 <code>num</code> <strong>不</strong> 存在于无限集中，则将一个 <code>num</code> <strong>添加</strong> 到该无限集中。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入</strong>\n[\"SmallestInfiniteSet\", \"addBack\", \"popSmallest\", \"popSmallest\", \"popSmallest\", \"addBack\", \"popSmallest\", \"popSmallest\", \"popSmallest\"]\n[[], [2], [], [], [], [1], [], [], []]\n<strong>输出</strong>\n[null, null, 1, 2, 3, null, 1, 4, 5]\n\n<strong>解释</strong>\nSmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet();\nsmallestInfiniteSet.addBack(2);    // 2 已经在集合中，所以不做任何变更。\nsmallestInfiniteSet.popSmallest(); // 返回 1 ，因为 1 是最小的整数，并将其从集合中移除。\nsmallestInfiniteSet.popSmallest(); // 返回 2 ，并将其从集合中移除。\nsmallestInfiniteSet.popSmallest(); // 返回 3 ，并将其从集合中移除。\nsmallestInfiniteSet.addBack(1);    // 将 1 添加到该集合中。\nsmallestInfiniteSet.popSmallest(); // 返回 1 ，因为 1 在上一步中被添加到集合中，\n                                   // 且 1 是最小的整数，并将其从集合中移除。\nsmallestInfiniteSet.popSmallest(); // 返回 4 ，并将其从集合中移除。\nsmallestInfiniteSet.popSmallest(); // 返回 5 ，并将其从集合中移除。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 1000</code></li>\n\t<li>最多调用 <code>popSmallest</code> 和 <code>addBack</code> 方法 <strong>共计</strong> <code>1000</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2337.移动片段得到字符串",
        "hardRate": "MEDIUM",
        "passRate": "39.29%",
        "problemsUrl": "https://leetcode.cn/problems/move-pieces-to-obtain-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/move-pieces-to-obtain-a-string/solution",
        "problemsDesc": "<p>给你两个字符串 <code>start</code> 和 <code>target</code> ，长度均为 <code>n</code> 。每个字符串 <strong>仅</strong> 由字符 <code>'L'</code>、<code>'R'</code> 和 <code>'_'</code> 组成，其中：</p>\n\n<ul>\n\t<li>字符 <code>'L'</code> 和 <code>'R'</code> 表示片段，其中片段 <code>'L'</code> 只有在其左侧直接存在一个 <strong>空位</strong> 时才能向 <strong>左</strong> 移动，而片段 <code>'R'</code> 只有在其右侧直接存在一个 <strong>空位</strong> 时才能向 <strong>右</strong> 移动。</li>\n\t<li>字符 <code>'_'</code> 表示可以被 <strong>任意</strong> <code>'L'</code> 或 <code>'R'</code> 片段占据的空位。</li>\n</ul>\n\n<p>如果在移动字符串 <code>start</code> 中的片段任意次之后可以得到字符串 <code>target</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>start = \"_L__R__R_\", target = \"L______RR\"\n<strong>输出：</strong>true\n<strong>解释：</strong>可以从字符串 start 获得 target ，需要进行下面的移动：\n- 将第一个片段向左移动一步，字符串现在变为 \"<strong>L</strong>___R__R_\" 。\n- 将最后一个片段向右移动一步，字符串现在变为 \"L___R___<strong>R</strong>\" 。\n- 将第二个片段向右移动散步，字符串现在变为 \"L______<strong>R</strong>R\" 。\n可以从字符串 start 得到 target ，所以返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>start = \"R_L_\", target = \"__LR\"\n<strong>输出：</strong>false\n<strong>解释：</strong>字符串 start 中的 'R' 片段可以向右移动一步得到 \"_<strong>R</strong>L_\" 。\n但是，在这一步之后，不存在可以移动的片段，所以无法从字符串 start 得到 target 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>start = \"_R\", target = \"R_\"\n<strong>输出：</strong>false\n<strong>解释：</strong>字符串 start 中的片段只能向右移动，所以无法从字符串 start 得到 target 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == start.length == target.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>start</code> 和 <code>target</code> 由字符 <code>'L'</code>、<code>'R'</code> 和 <code>'_'</code> 组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2338.统计理想数组的数目",
        "hardRate": "HARD",
        "passRate": "30.69%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-ideal-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-ideal-arrays/solution",
        "problemsDesc": "<p>给你两个整数 <code>n</code> 和 <code>maxValue</code> ，用于描述一个 <strong>理想数组</strong> 。</p>\n\n<p>对于下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>arr</code> ，如果满足以下条件，则认为该数组是一个 <strong>理想数组</strong> ：</p>\n\n<ul>\n\t<li>每个 <code>arr[i]</code> 都是从 <code>1</code> 到 <code>maxValue</code> 范围内的一个值，其中 <code>0 &lt;= i &lt; n</code> 。</li>\n\t<li>每个 <code>arr[i]</code> 都可以被 <code>arr[i - 1]</code> 整除，其中 <code>0 &lt; i &lt; n</code> 。</li>\n</ul>\n\n<p>返回长度为 <code>n</code> 的 <strong>不同</strong> 理想数组的数目。由于答案可能很大，返回对 <code>10<sup>9</sup> + 7</code> 取余的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, maxValue = 5\n<strong>输出：</strong>10\n<strong>解释：</strong>存在以下理想数组：\n- 以 1 开头的数组（5 个）：[1,1]、[1,2]、[1,3]、[1,4]、[1,5]\n- 以 2 开头的数组（2 个）：[2,2]、[2,4]\n- 以 3 开头的数组（1 个）：[3,3]\n- 以 4 开头的数组（1 个）：[4,4]\n- 以 5 开头的数组（1 个）：[5,5]\n共计 5 + 2 + 1 + 1 + 1 = 10 个不同理想数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 5, maxValue = 3\n<strong>输出：</strong>11\n<strong>解释：</strong>存在以下理想数组：\n- 以 1 开头的数组（9 个）：\n   - 不含其他不同值（1 个）：[1,1,1,1,1] \n   - 含一个不同值 2（4 个）：[1,1,1,1,2], [1,1,1,2,2], [1,1,2,2,2], [1,2,2,2,2]\n   - 含一个不同值 3（4 个）：[1,1,1,1,3], [1,1,1,3,3], [1,1,3,3,3], [1,3,3,3,3]\n- 以 2 开头的数组（1 个）：[2,2,2,2,2]\n- 以 3 开头的数组（1 个）：[3,3,3,3,3]\n共计 9 + 1 + 1 = 11 个不同理想数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= maxValue &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2339.联赛的所有比赛",
        "hardRate": "EASY",
        "passRate": "75.67%",
        "problemsUrl": "https://leetcode.cn/problems/all-the-matches-of-the-league/",
        "solutionsUrl": "https://leetcode.cn/problems/all-the-matches-of-the-league/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2340.生成有效数组的最少交换次数",
        "hardRate": "MEDIUM",
        "passRate": "76.65%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-adjacent-swaps-to-make-a-valid-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-adjacent-swaps-to-make-a-valid-array/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2341.数组能形成多少数对",
        "hardRate": "EASY",
        "passRate": "81.17%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-pairs-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-pairs-in-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。在一步操作中，你可以执行以下步骤：</p>\n\n<ul>\n\t<li>从 <code>nums</code> 选出 <strong>两个</strong> <strong>相等的</strong> 整数</li>\n\t<li>从 <code>nums</code> 中移除这两个整数，形成一个 <strong>数对</strong></li>\n</ul>\n\n<p>请你在 <code>nums</code> 上多次执行此操作直到无法继续执行。</p>\n\n<p>返回一个下标从 <strong>0</strong> 开始、长度为 <code>2</code> 的整数数组 <code>answer</code> 作为答案，其中<em> </em><code>answer[0]</code><em> </em>是形成的数对数目，<code>answer[1]</code> 是对 <code>nums</code> 尽可能执行上述操作后剩下的整数数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3,2,1,3,2,2]\n<strong>输出：</strong>[3,1]\n<strong>解释：</strong>\nnums[0] 和 nums[3] 形成一个数对，并从 nums 中移除，nums = [3,2,3,2,2] 。\nnums[0] 和 nums[2] 形成一个数对，并从 nums 中移除，nums = [2,2,2] 。\nnums[0] 和 nums[1] 形成一个数对，并从 nums 中移除，nums = [2] 。\n无法形成更多数对。总共形成 3 个数对，nums 中剩下 1 个数字。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1]\n<strong>输出：</strong>[1,0]\n<strong>解释：</strong>nums[0] 和 nums[1] 形成一个数对，并从 nums 中移除，nums = [] 。\n无法形成更多数对。总共形成 1 个数对，nums 中剩下 0 个数字。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0]\n<strong>输出：</strong>[0,1]\n<strong>解释：</strong>无法形成数对，nums 中剩下 1 个数字。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2342.数位和相等数对的最大和",
        "hardRate": "MEDIUM",
        "passRate": "53.64%",
        "problemsUrl": "https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，数组中的元素都是 <strong>正</strong> 整数。请你选出两个下标 <code>i</code> 和 <code>j</code>（<code>i != j</code>），且 <code>nums[i]</code> 的数位和 与&nbsp; <code>nums[j]</code> 的数位和相等。</p>\n\n<p>请你找出所有满足条件的下标 <code>i</code> 和 <code>j</code> ，找出并返回<em> </em><code>nums[i] + nums[j]</code><em> </em>可以得到的 <strong>最大值</strong> <em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [18,43,36,13,7]\n<strong>输出：</strong>54\n<strong>解释：</strong>满足条件的数对 (i, j) 为：\n- (0, 2) ，两个数字的数位和都是 9 ，相加得到 18 + 36 = 54 。\n- (1, 4) ，两个数字的数位和都是 7 ，相加得到 43 + 7 = 50 。\n所以可以获得的最大和是 54 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,12,19,14]\n<strong>输出：</strong>-1\n<strong>解释：</strong>不存在满足条件的数对，返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2343.裁剪数字后查询第 K 小的数字",
        "hardRate": "MEDIUM",
        "passRate": "41.35%",
        "problemsUrl": "https://leetcode.cn/problems/query-kth-smallest-trimmed-number/",
        "solutionsUrl": "https://leetcode.cn/problems/query-kth-smallest-trimmed-number/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串数组&nbsp;<code>nums</code>&nbsp;，其中每个字符串 <strong>长度相等</strong>&nbsp;且只包含数字。</p>\n\n<p>再给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>queries</code>&nbsp;，其中&nbsp;<code>queries[i] = [k<sub>i</sub>, trim<sub>i</sub>]</code>&nbsp;。对于每个&nbsp;<code>queries[i]</code>&nbsp;，你需要：</p>\n\n<ul>\n\t<li>将&nbsp;<code>nums</code>&nbsp;中每个数字 <strong>裁剪</strong>&nbsp;到剩下 <strong>最右边</strong>&nbsp;<code>trim<sub>i</sub></code>&nbsp;个数位。</li>\n\t<li>在裁剪过后的数字中，找到 <code>nums</code>&nbsp;中第&nbsp;<code>k<sub>i</sub></code>&nbsp;小数字对应的 <strong>下标</strong>&nbsp;。如果两个裁剪后数字一样大，那么下标 <strong>更小</strong>&nbsp;的数字视为更小的数字。</li>\n\t<li>将 <code>nums</code>&nbsp;中每个数字恢复到原本字符串。</li>\n</ul>\n\n<p>请你返回一个长度与 <code><span style=\"\">queries</span></code>&nbsp;相等的数组<em>&nbsp;</em><code>answer</code>，其中<em>&nbsp;</em><code>answer[i]</code>是第<em>&nbsp;</em><code>i</code><em>&nbsp;</em>次查询的结果。</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>裁剪到剩下最右边 <code>x</code>&nbsp;个数位的意思是不断删除最左边的数位，直到剩下 <code>x</code>&nbsp;个数位。</li>\n\t<li><code>nums</code>&nbsp;中的字符串可能会有前导 0 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [\"102\",\"473\",\"251\",\"814\"], queries = [[1,1],[2,3],[4,2],[1,2]]\n<b>输出：</b>[2,2,1,0]\n<strong>解释：</strong>\n1. 裁剪到只剩 1 个数位后，nums = [\"2\",\"3\",\"1\",\"4\"] 。最小的数字是 1 ，下标为 2 。\n2. 裁剪到剩 3 个数位后，nums 没有变化。第 2 小的数字是 251 ，下标为 2 。\n3. 裁剪到剩 2 个数位后，nums = [\"02\",\"73\",\"51\",\"14\"] 。第 4 小的数字是 73 ，下标为 1 。\n4. 裁剪到剩 2 个数位后，最小数字是 2 ，下标为 0 。\n   注意，裁剪后数字 \"02\" 值为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [\"24\",\"37\",\"96\",\"04\"], queries = [[2,1],[2,2]]\n<b>输出：</b>[3,0]\n<strong>解释：</strong>\n1. 裁剪到剩 1 个数位，nums = [\"4\",\"7\",\"6\",\"4\"] 。第 2 小的数字是 4 ，下标为 3 。\n   有两个 4 ，下标为 0 的 4 视为小于下标为 3 的 4 。\n2. 裁剪到剩 2 个数位，nums 不变。第二小的数字是 24 ，下标为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i].length &lt;= 100</code></li>\n\t<li><code>nums[i]</code> 只包含数字。</li>\n\t<li>所有&nbsp;<code>nums[i].length</code>&nbsp;的长度 <b>相同</b>&nbsp;。</li>\n\t<li><code>1 &lt;= queries.length &lt;= 100</code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>1 &lt;= k<sub>i</sub> &lt;= nums.length</code></li>\n\t<li><code>1 &lt;= trim<sub>i</sub> &lt;= nums[0].length</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能使用 <strong>基数排序算法</strong> 解决此问题吗？这种解法的复杂度又是多少？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2344.使数组可以被整除的最少删除次数",
        "hardRate": "HARD",
        "passRate": "53.26%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-array-divisible/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-array-divisible/solution",
        "problemsDesc": "<p>给你两个正整数数组&nbsp;<code>nums</code> 和&nbsp;<code>numsDivide</code>&nbsp;。你可以从&nbsp;<code>nums</code>&nbsp;中删除任意数目的元素。</p>\n\n<p>请你返回使 <code>nums</code>&nbsp;中 <strong>最小</strong>&nbsp;元素可以整除 <code>numsDivide</code>&nbsp;中所有元素的 <strong>最少</strong>&nbsp;删除次数。如果无法得到这样的元素，返回 <code>-1</code>&nbsp;。</p>\n\n<p>如果&nbsp;<code>y % x == 0</code>&nbsp;，那么我们说整数&nbsp;<code>x</code>&nbsp;整除&nbsp;<code>y</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,3,2,4,3], numsDivide = [9,6,9,3,15]\n<b>输出：</b>2\n<b>解释：</b>\n[2,3,2,4,3] 中最小元素是 2 ，它无法整除 numsDivide 中所有元素。\n我们从 nums 中删除 2 个大小为 2 的元素，得到 nums = [3,4,3] 。\n[3,4,3] 中最小元素为 3 ，它可以整除 numsDivide 中所有元素。\n可以证明 2 是最少删除次数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [4,3,6], numsDivide = [8,2,6,10]\n<b>输出：</b>-1\n<b>解释：</b>\n我们想 nums 中的最小元素可以整除 numsDivide 中的所有元素。\n没有任何办法可以达到这一目的。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, numsDivide.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], numsDivide[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2345.寻找可见山的数量",
        "hardRate": "MEDIUM",
        "passRate": "48.50%",
        "problemsUrl": "https://leetcode.cn/problems/finding-the-number-of-visible-mountains/",
        "solutionsUrl": "https://leetcode.cn/problems/finding-the-number-of-visible-mountains/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2346.以百分比计算排名",
        "hardRate": "MEDIUM",
        "passRate": "37.78%",
        "problemsUrl": "https://leetcode.cn/problems/compute-the-rank-as-a-percentage/",
        "solutionsUrl": "https://leetcode.cn/problems/compute-the-rank-as-a-percentage/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2347.最好的扑克手牌",
        "hardRate": "EASY",
        "passRate": "59.35%",
        "problemsUrl": "https://leetcode.cn/problems/best-poker-hand/",
        "solutionsUrl": "https://leetcode.cn/problems/best-poker-hand/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>ranks</code>&nbsp;和一个字符数组&nbsp;<code>suit</code>&nbsp;。你有&nbsp;<code>5</code>&nbsp;张扑克牌，第&nbsp;<code>i</code>&nbsp;张牌大小为&nbsp;<code>ranks[i]</code>&nbsp;，花色为&nbsp;<code>suits[i]</code>&nbsp;。</p>\n\n<p>下述是从好到坏你可能持有的 <strong>手牌类型&nbsp;</strong>：</p>\n\n<ol>\n\t<li><code>\"Flush\"</code>：同花，五张相同花色的扑克牌。</li>\n\t<li><code>\"Three of a Kind\"</code>：三条，有 3 张大小相同的扑克牌。</li>\n\t<li><code>\"Pair\"</code>：对子，两张大小一样的扑克牌。</li>\n\t<li><code>\"High Card\"</code>：高牌，五张大小互不相同的扑克牌。</li>\n</ol>\n\n<p>请你返回一个字符串，表示给定的 5 张牌中，你能组成的 <strong>最好手牌类型</strong>&nbsp;。</p>\n\n<p><strong>注意：</strong>返回的字符串&nbsp;<strong>大小写</strong>&nbsp;需与题目描述相同。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>ranks = [13,2,3,1,9], suits = [\"a\",\"a\",\"a\",\"a\",\"a\"]\n<b>输出：</b>\"Flush\"\n<b>解释：</b>5 张扑克牌的花色相同，所以返回 \"Flush\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>ranks = [4,4,2,4,4], suits = [\"d\",\"a\",\"a\",\"b\",\"c\"]\n<b>输出：</b>\"Three of a Kind\"\n<b>解释：</b>第一、二和四张牌组成三张相同大小的扑克牌，所以得到 \"Three of a Kind\" 。\n注意我们也可以得到 \"Pair\" ，但是 \"Three of a Kind\" 是更好的手牌类型。\n有其他的 3 张牌也可以组成 \"Three of a Kind\" 手牌类型。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>ranks = [10,10,2,12,9], suits = [\"a\",\"b\",\"c\",\"a\",\"d\"]\n<b>输出：</b>\"Pair\"\n<b>解释：</b>第一和第二张牌大小相同，所以得到 \"Pair\" 。\n我们无法得到 \"Flush\" 或者 \"Three of a Kind\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>ranks.length == suits.length == 5</code></li>\n\t<li><code>1 &lt;= ranks[i] &lt;= 13</code></li>\n\t<li><code>'a' &lt;= suits[i] &lt;= 'd'</code></li>\n\t<li>任意两张扑克牌不会同时有相同的大小和花色。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2348.全 0 子数组的数目",
        "hardRate": "MEDIUM",
        "passRate": "56.38%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-zero-filled-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-zero-filled-subarrays/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;，返回全部为&nbsp;<code>0</code>&nbsp;的&nbsp;<strong>子数组</strong>&nbsp;数目。</p>\n\n<p><strong>子数组</strong>&nbsp;是一个数组中一段连续非空元素组成的序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,3,0,0,2,0,0,4]\n<b>输出：</b>6\n<b>解释：</b>\n子数组 [0] 出现了 4 次。\n子数组 [0,0] 出现了 2 次。\n不存在长度大于 2 的全 0 子数组，所以我们返回 6 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [0,0,0,2,0,0]\n<b>输出：</b>9\n<strong>解释：\n</strong>子数组 [0] 出现了 5 次。\n子数组 [0,0] 出现了 3 次。\n子数组 [0,0,0] 出现了 1 次。\n不存在长度大于 3 的全 0 子数组，所以我们返回 9 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [2,10,2019]\n<b>输出：</b>0\n<b>解释：</b>没有全 0 子数组，所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2349.设计数字容器系统",
        "hardRate": "MEDIUM",
        "passRate": "37.28%",
        "problemsUrl": "https://leetcode.cn/problems/design-a-number-container-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-a-number-container-system/solution",
        "problemsDesc": "<p>设计一个数字容器系统，可以实现以下功能：</p>\n\n<ul>\n\t<li>在系统中给定下标处&nbsp;<strong>插入</strong>&nbsp;或者 <strong>替换</strong>&nbsp;一个数字。</li>\n\t<li><strong>返回</strong>&nbsp;系统中给定数字的最小下标。</li>\n</ul>\n\n<p>请你实现一个&nbsp;<code>NumberContainers</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>NumberContainers()</code>&nbsp;初始化数字容器系统。</li>\n\t<li><code>void change(int index, int number)</code> 在下标&nbsp;<code>index</code>&nbsp;处填入&nbsp;<code>number</code>&nbsp;。如果该下标&nbsp;<code>index</code>&nbsp;处已经有数字了，那么用 <code>number</code>&nbsp;替换该数字。</li>\n\t<li><code>int find(int number)</code>&nbsp;返回给定数字&nbsp;<code>number</code>&nbsp;在系统中的最小下标。如果系统中没有&nbsp;<code>number</code>&nbsp;，那么返回&nbsp;<code>-1</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"NumberContainers\", \"find\", \"change\", \"change\", \"change\", \"change\", \"find\", \"change\", \"find\"]\n[[], [10], [2, 10], [1, 10], [3, 10], [5, 10], [10], [1, 20], [10]]\n<strong>输出：</strong>\n[null, -1, null, null, null, null, 1, null, 2]\n\n<strong>解释：</strong>\nNumberContainers nc = new NumberContainers();\nnc.find(10); // 没有数字 10 ，所以返回 -1 。\nnc.change(2, 10); // 容器中下标为 2 处填入数字 10 。\nnc.change(1, 10); // 容器中下标为 1 处填入数字 10 。\nnc.change(3, 10); // 容器中下标为 3 处填入数字 10 。\nnc.change(5, 10); // 容器中下标为 5 处填入数字 10 。\nnc.find(10); // 数字 10 所在的下标为 1 ，2 ，3 和 5 。因为最小下标为 1 ，所以返回 1 。\nnc.change(1, 20); // 容器中下标为 1 处填入数字 20 。注意，下标 1 处之前为 10 ，现在被替换为 20 。\nnc.find(10); // 数字 10 所在下标为 2 ，3 和 5 。最小下标为 2 ，所以返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= index, number &lt;= 10<sup>9</sup></code></li>\n\t<li>调用&nbsp;<code>change</code> 和&nbsp;<code>find</code>&nbsp;的&nbsp;<strong>总次数</strong>&nbsp;不超过&nbsp;<code>10<sup>5</sup></code> 次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2350.不可能得到的最短骰子序列",
        "hardRate": "HARD",
        "passRate": "64.88%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-impossible-sequence-of-rolls/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-impossible-sequence-of-rolls/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>rolls</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。你扔一个&nbsp;<code>k</code>&nbsp;面的骰子 <code>n</code>&nbsp;次，骰子的每个面分别是&nbsp;<code>1</code>&nbsp;到&nbsp;<code>k</code>&nbsp;，其中第&nbsp;<code>i</code>&nbsp;次扔得到的数字是&nbsp;<code>rolls[i]</code>&nbsp;。</p>\n\n<p>请你返回 <strong>无法</strong>&nbsp;从 <code>rolls</code>&nbsp;中得到的 <strong>最短</strong>&nbsp;骰子子序列的长度。</p>\n\n<p>扔一个 <code>k</code>&nbsp;面的骰子 <code>len</code>&nbsp;次得到的是一个长度为 <code>len</code>&nbsp;的 <strong>骰子子序列</strong>&nbsp;。</p>\n\n<p><strong>注意</strong>&nbsp;，子序列只需要保持在原数组中的顺序，不需要连续。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>rolls = [4,2,1,2,3,3,2,4,1], k = 4\n<b>输出：</b>3\n<b>解释：</b>所有长度为 1 的骰子子序列 [1] ，[2] ，[3] ，[4] 都可以从原数组中得到。\n所有长度为 2 的骰子子序列 [1, 1] ，[1, 2] ，... ，[4, 4] 都可以从原数组中得到。\n子序列 [1, 4, 2] 无法从原数组中得到，所以我们返回 3 。\n还有别的子序列也无法从原数组中得到。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>rolls = [1,1,2,2], k = 2\n<b>输出：</b>2\n<b>解释：</b>所有长度为 1 的子序列 [1] ，[2] 都可以从原数组中得到。\n子序列 [2, 1] 无法从原数组中得到，所以我们返回 2 。\n还有别的子序列也无法从原数组中得到，但 [2, 1] 是最短的子序列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>rolls = [1,1,3,2,2,2,3,3], k = 4\n<b>输出：</b>1\n<b>解释：</b>子序列 [4] 无法从原数组中得到，所以我们返回 1 。\n还有别的子序列也无法从原数组中得到，但 [4] 是最短的子序列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == rolls.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= rolls[i] &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2351.第一个出现两次的字母",
        "hardRate": "EASY",
        "passRate": "84.74%",
        "problemsUrl": "https://leetcode.cn/problems/first-letter-to-appear-twice/",
        "solutionsUrl": "https://leetcode.cn/problems/first-letter-to-appear-twice/solution",
        "problemsDesc": "<p>给你一个由小写英文字母组成的字符串 <code>s</code> ，请你找出并返回第一个出现 <strong>两次</strong> 的字母。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>如果 <code>a</code> 的 <strong>第二次</strong> 出现比 <code>b</code> 的 <strong>第二次</strong> 出现在字符串中的位置更靠前，则认为字母 <code>a</code> 在字母 <code>b</code> 之前出现两次。</li>\n\t<li><code>s</code> 包含至少一个出现两次的字母。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abccbaacz\"\n<strong>输出：</strong>\"c\"\n<strong>解释：</strong>\n字母 'a' 在下标 0 、5 和 6 处出现。\n字母 'b' 在下标 1 和 4 处出现。\n字母 'c' 在下标 2 、3 和 7 处出现。\n字母 'z' 在下标 8 处出现。\n字母 'c' 是第一个出现两次的字母，因为在所有字母中，'c' 第二次出现的下标是最小的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abcdd\"\n<strong>输出：</strong>\"d\"\n<strong>解释：</strong>\n只有字母 'd' 出现两次，所以返回 'd' 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n\t<li><code>s</code> 包含至少一个重复字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2352.相等行列对",
        "hardRate": "MEDIUM",
        "passRate": "73.92%",
        "problemsUrl": "https://leetcode.cn/problems/equal-row-and-column-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/equal-row-and-column-pairs/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>n x n</code> 的整数矩阵 <code>grid</code> ，返回满足 <code>R<sub>i</sub></code><em> </em>行和<em> </em><code>C<sub>j</sub></code><em> </em>列相等的行列对<em> </em><code>(R<sub>i</sub>, C<sub>j</sub>)</code><em> </em>的数目<em>。</em></p>\n\n<p>如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/01/ex1.jpg\" style=\"width: 150px; height: 153px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[3,2,1],[1,7,6],[2,7,7]]\n<strong>输出：</strong>1\n<strong>解释：</strong>存在一对相等行列对：\n- (第 2 行，第 1 列)：[2,7,7]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/01/ex2.jpg\" style=\"width: 200px; height: 209px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]\n<strong>输出：</strong>3\n<strong>解释：</strong>存在三对相等行列对：\n- (第 0 行，第 0 列)：[3,1,2,2]\n- (第 2 行, 第 2 列)：[2,4,2,2]\n- (第 3 行, 第 2 列)：[2,4,2,2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2353.设计食物评分系统",
        "hardRate": "MEDIUM",
        "passRate": "30.70%",
        "problemsUrl": "https://leetcode.cn/problems/design-a-food-rating-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-a-food-rating-system/solution",
        "problemsDesc": "<p>设计一个支持下述操作的食物评分系统：</p>\n\n<ul>\n\t<li><strong>修改</strong> 系统中列出的某种食物的评分。</li>\n\t<li>返回系统中某一类烹饪方式下评分最高的食物。</li>\n</ul>\n\n<p>实现 <code>FoodRatings</code> 类：</p>\n\n<ul>\n\t<li><code>FoodRatings(String[] foods, String[] cuisines, int[] ratings)</code> 初始化系统。食物由 <code>foods</code>、<code>cuisines</code> 和 <code>ratings</code> 描述，长度均为 <code>n</code> 。\n\n\t<ul>\n\t\t<li><code>foods[i]</code> 是第 <code>i</code> 种食物的名字。</li>\n\t\t<li><code>cuisines[i]</code> 是第 <code>i</code> 种食物的烹饪方式。</li>\n\t\t<li><code>ratings[i]</code> 是第 <code>i</code> 种食物的最初评分。</li>\n\t</ul>\n\t</li>\n\t<li><code>void changeRating(String food, int newRating)</code> 修改名字为 <code>food</code> 的食物的评分。</li>\n\t<li><code>String highestRated(String cuisine)</code> 返回指定烹饪方式 <code>cuisine</code> 下评分最高的食物的名字。如果存在并列，返回 <strong>字典序较小</strong> 的名字。</li>\n</ul>\n\n<p>注意，字符串 <code>x</code> 的字典序比字符串 <code>y</code> 更小的前提是：<code>x</code> 在字典中出现的位置在 <code>y</code> 之前，也就是说，要么 <code>x</code> 是 <code>y</code> 的前缀，或者在满足&nbsp;<code>x[i] != y[i]</code> 的第一个位置 <code>i</code> 处，<code>x[i]</code> 在字母表中出现的位置在 <code>y[i]</code> 之前。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入</strong>\n[\"FoodRatings\", \"highestRated\", \"highestRated\", \"changeRating\", \"highestRated\", \"changeRating\", \"highestRated\"]\n[[[\"kimchi\", \"miso\", \"sushi\", \"moussaka\", \"ramen\", \"bulgogi\"], [\"korean\", \"japanese\", \"japanese\", \"greek\", \"japanese\", \"korean\"], [9, 12, 8, 15, 14, 7]], [\"korean\"], [\"japanese\"], [\"sushi\", 16], [\"japanese\"], [\"ramen\", 16], [\"japanese\"]]\n<strong>输出</strong>\n[null, \"kimchi\", \"ramen\", null, \"sushi\", null, \"ramen\"]\n\n<strong>解释</strong>\nFoodRatings foodRatings = new FoodRatings([\"kimchi\", \"miso\", \"sushi\", \"moussaka\", \"ramen\", \"bulgogi\"], [\"korean\", \"japanese\", \"japanese\", \"greek\", \"japanese\", \"korean\"], [9, 12, 8, 15, 14, 7]);\nfoodRatings.highestRated(\"korean\"); // 返回 \"kimchi\"\n                                    // \"kimchi\" 是分数最高的韩式料理，评分为 9 。\nfoodRatings.highestRated(\"japanese\"); // 返回 \"ramen\"\n                                      // \"ramen\" 是分数最高的日式料理，评分为 14 。\nfoodRatings.changeRating(\"sushi\", 16); // \"sushi\" 现在评分变更为 16 。\nfoodRatings.highestRated(\"japanese\"); // 返回 \"sushi\"\n                                      // \"sushi\" 是分数最高的日式料理，评分为 16 。\nfoodRatings.changeRating(\"ramen\", 16); // \"ramen\" 现在评分变更为 16 。\nfoodRatings.highestRated(\"japanese\"); // 返回 \"ramen\"\n                                      // \"sushi\" 和 \"ramen\" 的评分都是 16 。\n                                      // 但是，\"ramen\" 的字典序比 \"sushi\" 更小。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>n == foods.length == cuisines.length == ratings.length</code></li>\n\t<li><code>1 &lt;= foods[i].length, cuisines[i].length &lt;= 10</code></li>\n\t<li><code>foods[i]</code>、<code>cuisines[i]</code> 由小写英文字母组成</li>\n\t<li><code>1 &lt;= ratings[i] &lt;= 10<sup>8</sup></code></li>\n\t<li><code>foods</code> 中的所有字符串 <strong>互不相同</strong></li>\n\t<li>在对&nbsp;<code>changeRating</code> 的所有调用中，<code>food</code> 是系统中食物的名字。</li>\n\t<li>在对&nbsp;<code>highestRated</code> 的所有调用中，<code>cuisine</code> 是系统中 <strong>至少一种</strong> 食物的烹饪方式。</li>\n\t<li>最多调用 <code>changeRating</code> 和 <code>highestRated</code> <strong>总计</strong> <code>2 * 10<sup>4</sup></code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2354.优质数对的数目",
        "hardRate": "HARD",
        "passRate": "44.64%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-excellent-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-excellent-pairs/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的正整数数组 <code>nums</code> 和一个正整数 <code>k</code> 。</p>\n\n<p>如果满足下述条件，则数对 <code>(num1, num2)</code> 是 <strong>优质数对</strong> ：</p>\n\n<ul>\n\t<li><code>num1</code> 和 <code>num2</code> <strong>都</strong> 在数组 <code>nums</code> 中存在。</li>\n\t<li><code>num1 OR num2</code> 和 <code>num1 AND num2</code> 的二进制表示中值为 <strong>1</strong> 的位数之和大于等于 <code>k</code> ，其中 <code>OR</code> 是按位 <strong>或</strong> 操作，而 <code>AND</code> 是按位 <strong>与</strong> 操作。</li>\n</ul>\n\n<p>返回 <strong>不同</strong> 优质数对的数目。</p>\n\n<p>如果&nbsp;<code>a != c</code> 或者 <code>b != d</code> ，则认为 <code>(a, b)</code> 和 <code>(c, d)</code> 是不同的两个数对。例如，<code>(1, 2)</code> 和 <code>(2, 1)</code> 不同。</p>\n\n<p><strong>注意：</strong>如果 <code>num1</code> 在数组中至少出现 <strong>一次</strong> ，则满足 <code>num1 == num2</code> 的数对 <code>(num1, num2)</code> 也可以是优质数对。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,1], k = 3\n<strong>输出：</strong>5\n<strong>解释：</strong>有如下几个优质数对：\n- (3, 3)：(3 AND 3) 和 (3 OR 3) 的二进制表示都等于 (11) 。值为 1 的位数和等于 2 + 2 = 4 ，大于等于 k = 3 。\n- (2, 3) 和 (3, 2)： (2 AND 3) 的二进制表示等于 (10) ，(2 OR 3) 的二进制表示等于 (11) 。值为 1 的位数和等于 1 + 2 = 3 。\n- (1, 3) 和 (3, 1)： (1 AND 3) 的二进制表示等于 (01) ，(1 OR 3) 的二进制表示等于 (11) 。值为 1 的位数和等于 1 + 2 = 3 。\n所以优质数对的数目是 5 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,1,1], k = 10\n<strong>输出：</strong>0\n<strong>解释：</strong>该数组中不存在优质数对。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 60</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2355.你能拿走的最大图书数量",
        "hardRate": "HARD",
        "passRate": "58.22%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-books-you-can-take/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-books-you-can-take/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2356.每位教师所教授的科目种类的数量",
        "hardRate": "EASY",
        "passRate": "81.11%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-unique-subjects-taught-by-each-teacher/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-unique-subjects-taught-by-each-teacher/solution",
        "problemsDesc": "<p>表: <code>Teacher</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| teacher_id  | int  |\n| subject_id  | int  |\n| dept_id     | int  |\n+-------------+------+\n(subject_id, dept_id) 是该表的主键。\n该表中的每一行都表示带有 teacher_id 的教师在系 dept_id 中教授科目 subject_id。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一个 SQL 来查询每位老师在大学里教授的科目种类的数量。</p>\n\n<p data-group=\"1-1\">以 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式示例如下。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nTeacher 表:\n+------------+------------+---------+\n| teacher_id | subject_id | dept_id |\n+------------+------------+---------+\n| 1          | 2          | 3       |\n| 1          | 2          | 4       |\n| 1          | 3          | 3       |\n| 2          | 1          | 1       |\n| 2          | 2          | 1       |\n| 2          | 3          | 1       |\n| 2          | 4          | 1       |\n+------------+------------+---------+\n<strong>输出:</strong>  \n+------------+-----+\n| teacher_id | cnt |\n+------------+-----+\n| 1          | 2   |\n| 2          | 4   |\n+------------+-----+\n<strong>解释:</strong> \n教师 1:\n  - 他在 3、4 系教科目 2。\n  - 他在 3 系教科目 3。\n教师 2:\n  - 他在 1 系教科目 1。\n  - 他在 1 系教科目 2。\n  - 他在 1 系教科目 3。\n  - 他在 1 系教科目 4。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2357.使数组中所有元素都等于零",
        "hardRate": "EASY",
        "passRate": "75.89%",
        "problemsUrl": "https://leetcode.cn/problems/make-array-zero-by-subtracting-equal-amounts/",
        "solutionsUrl": "https://leetcode.cn/problems/make-array-zero-by-subtracting-equal-amounts/solution",
        "problemsDesc": "<p>给你一个非负整数数组 <code>nums</code> 。在一步操作中，你必须：</p>\n\n<ul>\n\t<li>选出一个正整数 <code>x</code> ，<code>x</code> 需要小于或等于 <code>nums</code> 中 <strong>最小</strong> 的 <strong>非零</strong> 元素。</li>\n\t<li><code>nums</code> 中的每个正整数都减去 <code>x</code>。</li>\n</ul>\n\n<p>返回使 <code>nums</code> 中所有元素都等于<em> </em><code>0</code> 需要的 <strong>最少</strong> 操作数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5,0,3,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n第一步操作：选出 x = 1 ，之后 nums = [0,4,0,2,4] 。\n第二步操作：选出 x = 2 ，之后 nums = [0,2,0,0,2] 。\n第三步操作：选出 x = 2 ，之后 nums = [0,0,0,0,0] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>0\n<strong>解释：</strong>nums 中的每个元素都已经是 0 ，所以不需要执行任何操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2358.分组的最大数量",
        "hardRate": "MEDIUM",
        "passRate": "64.30%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-groups-entering-a-competition/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-groups-entering-a-competition/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>grades</code> ，表示大学中一些学生的成绩。你打算将 <strong>所有</strong> 学生分为一些 <strong>有序</strong> 的非空分组，其中分组间的顺序满足以下全部条件：</p>\n\n<ul>\n\t<li>第 <code>i</code> 个分组中的学生总成绩 <strong>小于</strong> 第 <code>(i + 1)</code> 个分组中的学生总成绩，对所有组均成立（除了最后一组）。</li>\n\t<li>第 <code>i</code> 个分组中的学生总数 <strong>小于</strong> 第 <code>(i + 1)</code> 个分组中的学生总数，对所有组均成立（除了最后一组）。</li>\n</ul>\n\n<p>返回可以形成的 <strong>最大</strong> 组数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>grades = [10,6,12,7,3,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>下面是形成 3 个分组的一种可行方法：\n- 第 1 个分组的学生成绩为 grades = [12] ，总成绩：12 ，学生数：1\n- 第 2 个分组的学生成绩为 grades = [6,7] ，总成绩：6 + 7 = 13 ，学生数：2\n- 第 3 个分组的学生成绩为 grades = [10,3,5] ，总成绩：10 + 3 + 5 = 18 ，学生数：3 \n可以证明无法形成超过 3 个分组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>grades = [8,8]\n<strong>输出：</strong>1\n<strong>解释：</strong>只能形成 1 个分组，因为如果要形成 2 个分组的话，会导致每个分组中的学生数目相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= grades.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= grades[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2359.找到离给定两个节点最近的节点",
        "hardRate": "MEDIUM",
        "passRate": "30.29%",
        "problemsUrl": "https://leetcode.cn/problems/find-closest-node-to-given-two-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/find-closest-node-to-given-two-nodes/solution",
        "problemsDesc": "<p>给你一个 <code>n</code>&nbsp;个节点的 <strong>有向图</strong>&nbsp;，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，每个节点 <strong>至多</strong>&nbsp;有一条出边。</p>\n\n<p>有向图用大小为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>edges</code>&nbsp;表示，表示节点&nbsp;<code>i</code>&nbsp;有一条有向边指向&nbsp;<code>edges[i]</code>&nbsp;。如果节点&nbsp;<code>i</code>&nbsp;没有出边，那么&nbsp;<code>edges[i] == -1</code>&nbsp;。</p>\n\n<p>同时给你两个节点&nbsp;<code>node1</code> 和&nbsp;<code>node2</code>&nbsp;。</p>\n\n<p>请你返回一个从 <code>node1</code>&nbsp;和 <code>node2</code>&nbsp;都能到达节点的编号，使节点 <code>node1</code>&nbsp;和节点 <code>node2</code>&nbsp;到这个节点的距离 <b>较大值最小化</b>。如果有多个答案，请返回 <strong>最小</strong>&nbsp;的节点编号。如果答案不存在，返回 <code>-1</code>&nbsp;。</p>\n\n<p>注意&nbsp;<code>edges</code>&nbsp;可能包含环。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-2.png\" style=\"width: 321px; height: 161px;\"></p>\n\n<pre><b>输入：</b>edges = [2,2,3,-1], node1 = 0, node2 = 1\n<b>输出：</b>2\n<b>解释：</b>从节点 0 到节点 2 的距离为 1 ，从节点 1 到节点 2 的距离为 1 。\n两个距离的较大值为 1 。我们无法得到一个比 1 更小的较大值，所以我们返回节点 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-4.png\" style=\"width: 195px; height: 161px;\"></p>\n\n<pre><b>输入：</b>edges = [1,2,-1], node1 = 0, node2 = 2\n<b>输出：</b>2\n<b>解释：</b>节点 0 到节点 2 的距离为 2 ，节点 2 到它自己的距离为 0 。\n两个距离的较大值为 2 。我们无法得到一个比 2 更小的较大值，所以我们返回节点 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-1 &lt;= edges[i] &lt; n</code></li>\n\t<li><code>edges[i] != i</code></li>\n\t<li><code>0 &lt;= node1, node2 &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2360.图中的最长环",
        "hardRate": "HARD",
        "passRate": "38.03%",
        "problemsUrl": "https://leetcode.cn/problems/longest-cycle-in-a-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-cycle-in-a-graph/solution",
        "problemsDesc": "<p>给你一个 <code>n</code>&nbsp;个节点的 <b>有向图</b>&nbsp;，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，其中每个节点&nbsp;<strong>至多</strong>&nbsp;有一条出边。</p>\n\n<p>图用一个大小为 <code>n</code>&nbsp;下标从<strong>&nbsp;0</strong>&nbsp;开始的数组&nbsp;<code>edges</code>&nbsp;表示，节点 <code>i</code>&nbsp;到节点&nbsp;<code>edges[i]</code>&nbsp;之间有一条有向边。如果节点&nbsp;<code>i</code>&nbsp;没有出边，那么&nbsp;<code>edges[i] == -1</code>&nbsp;。</p>\n\n<p>请你返回图中的 <strong>最长</strong>&nbsp;环，如果没有任何环，请返回 <code>-1</code>&nbsp;。</p>\n\n<p>一个环指的是起点和终点是 <strong>同一个</strong>&nbsp;节点的路径。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/08/graph4drawio-5.png\" style=\"width: 335px; height: 191px;\" /></p>\n\n<pre>\n<b>输入：</b>edges = [3,3,4,2,3]\n<b>输出去：</b>3\n<b>解释：</b>图中的最长环是：2 -&gt; 4 -&gt; 3 -&gt; 2 。\n这个环的长度为 3 ，所以返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-1.png\" style=\"width: 171px; height: 161px;\" /></p>\n\n<pre>\n<b>输入：</b>edges = [2,-1,3,1]\n<b>输出：</b>-1\n<b>解释：</b>图中没有任何环。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-1 &lt;= edges[i] &lt; n</code></li>\n\t<li><code>edges[i] != i</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2361.乘坐火车路线的最少费用",
        "hardRate": "HARD",
        "passRate": "78.11%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-costs-using-the-train-line/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-costs-using-the-train-line/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2362.生成发票",
        "hardRate": "HARD",
        "passRate": "73.02%",
        "problemsUrl": "https://leetcode.cn/problems/generate-the-invoice/",
        "solutionsUrl": "https://leetcode.cn/problems/generate-the-invoice/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2363.合并相似的物品",
        "hardRate": "EASY",
        "passRate": "78.20%",
        "problemsUrl": "https://leetcode.cn/problems/merge-similar-items/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-similar-items/solution",
        "problemsDesc": "<p>给你两个二维整数数组&nbsp;<code>items1</code> 和&nbsp;<code>items2</code>&nbsp;，表示两个物品集合。每个数组&nbsp;<code>items</code>&nbsp;有以下特质：</p>\n\n<ul>\n\t<li><code>items[i] = [value<sub>i</sub>, weight<sub>i</sub>]</code> 其中&nbsp;<code>value<sub>i</sub></code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;件物品的&nbsp;<strong>价值</strong>&nbsp;，<code>weight<sub>i</sub></code>&nbsp;表示第 <code>i</code>&nbsp;件物品的 <strong>重量</strong>&nbsp;。</li>\n\t<li><code>items</code>&nbsp;中每件物品的价值都是 <strong>唯一的</strong>&nbsp;。</li>\n</ul>\n\n<p>请你返回一个二维数组&nbsp;<code>ret</code>，其中&nbsp;<code>ret[i] = [value<sub>i</sub>, weight<sub>i</sub>]</code>，&nbsp;<code>weight<sub>i</sub></code>&nbsp;是所有价值为&nbsp;<code>value<sub>i</sub></code><sub>&nbsp;</sub>物品的&nbsp;<strong>重量之和</strong>&nbsp;。</p>\n\n<p><strong>注意：</strong><code>ret</code>&nbsp;应该按价值 <strong>升序</strong>&nbsp;排序后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]]\n<b>输出：</b>[[1,6],[3,9],[4,5]]\n<b>解释：</b>\nvalue = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 5 ，总重量为 1 + 5 = 6 。\nvalue = 3 的物品再 items1 中 weight = 8 ，在 items2 中 weight = 1 ，总重量为 8 + 1 = 9 。\nvalue = 4 的物品在 items1 中 weight = 5 ，总重量为 5 。\n所以，我们返回 [[1,6],[3,9],[4,5]] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]]\n<b>输出：</b>[[1,4],[2,4],[3,4]]\n<b>解释：</b>\nvalue = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 3 ，总重量为 1 + 3 = 4 。\nvalue = 2 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 1 ，总重量为 3 + 1 = 4 。\nvalue = 3 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。\n所以，我们返回 [[1,4],[2,4],[3,4]] 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]]\n<b>输出：</b>[[1,7],[2,4],[7,1]]\n<strong>解释：\n</strong>value = 1 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 4 ，总重量为 3 + 4 = 7 。\nvalue = 2 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。\nvalue = 7 的物品在 items2 中 weight = 1 ，总重量为 1 。\n所以，我们返回 [[1,7],[2,4],[7,1]] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= items1.length, items2.length &lt;= 1000</code></li>\n\t<li><code>items1[i].length == items2[i].length == 2</code></li>\n\t<li><code>1 &lt;= value<sub>i</sub>, weight<sub>i</sub> &lt;= 1000</code></li>\n\t<li><code>items1</code>&nbsp;中每个 <code>value<sub>i</sub></code>&nbsp;都是 <b>唯一的</b>&nbsp;。</li>\n\t<li><code>items2</code>&nbsp;中每个 <code>value<sub>i</sub></code>&nbsp;都是 <b>唯一的</b>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2364.统计坏数对的数目",
        "hardRate": "MEDIUM",
        "passRate": "42.25%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-bad-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-bad-pairs/solution",
        "problemsDesc": "<p>给你一个下标从<strong>&nbsp;0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。如果 <code>i &lt; j</code>&nbsp;且&nbsp;<code>j - i != nums[j] - nums[i]</code>&nbsp;，那么我们称&nbsp;<code>(i, j)</code>&nbsp;是一个 <strong>坏</strong><strong>数对</strong>&nbsp;。</p>\n\n<p>请你返回 <code>nums</code>&nbsp;中 <strong>坏数对</strong>&nbsp;的总数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [4,1,3,3]\n<b>输出：</b>5\n<b>解释：</b>数对 (0, 1) 是坏数对，因为 1 - 0 != 1 - 4 。\n数对 (0, 2) 是坏数对，因为 2 - 0 != 3 - 4, 2 != -1 。\n数对 (0, 3) 是坏数对，因为 3 - 0 != 3 - 4, 3 != -1 。\n数对 (1, 2) 是坏数对，因为 2 - 1 != 3 - 1, 1 != 2 。\n数对 (2, 3) 是坏数对，因为 3 - 2 != 3 - 3, 1 != 0 。\n总共有 5 个坏数对，所以我们返回 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4,5]\n<b>输出：</b>0\n<strong>解释：</strong>没有坏数对。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2365.任务调度器 II",
        "hardRate": "MEDIUM",
        "passRate": "48.06%",
        "problemsUrl": "https://leetcode.cn/problems/task-scheduler-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/task-scheduler-ii/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的正整数数组&nbsp;<code>tasks</code>&nbsp;，表示需要 <strong>按顺序</strong>&nbsp;完成的任务，其中&nbsp;<code>tasks[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;件任务的 <strong>类型</strong>&nbsp;。</p>\n\n<p>同时给你一个正整数&nbsp;<code>space</code>&nbsp;，表示一个任务完成&nbsp;<strong>后</strong>&nbsp;，另一个&nbsp;<strong>相同</strong>&nbsp;类型任务完成前需要间隔的&nbsp;<strong>最少</strong>&nbsp;天数。</p>\n\n<p>在所有任务完成前的每一天，你都必须进行以下两种操作中的一种：</p>\n\n<ul>\n\t<li>完成&nbsp;<code>tasks</code>&nbsp;中的下一个任务</li>\n\t<li>休息一天</li>\n</ul>\n\n<p>请你返回完成所有任务所需的 <strong>最少</strong>&nbsp;天数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>tasks = [1,2,1,2,3,1], space = 3\n<b>输出：</b>9\n<strong>解释：</strong>\n9 天完成所有任务的一种方法是：\n第 1 天：完成任务 0 。\n第 2 天：完成任务 1 。\n第 3 天：休息。\n第 4 天：休息。\n第 5 天：完成任务 2 。\n第 6 天：完成任务 3 。\n第 7 天：休息。\n第 8 天：完成任务 4 。\n第 9 天：完成任务 5 。\n可以证明无法少于 9 天完成所有任务。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>tasks = [5,8,8,5], space = 2\n<b>输出：</b>6\n<strong>解释：</strong>\n6 天完成所有任务的一种方法是：\n第 1 天：完成任务 0 。\n第 2 天：完成任务 1 。\n第 3 天：休息。\n第 4 天：休息。\n第 5 天：完成任务 2 。\n第 6 天：完成任务 3 。\n可以证明无法少于 6 天完成所有任务。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tasks.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= tasks[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= space &lt;= tasks.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2366.将数组排序的最少替换次数",
        "hardRate": "HARD",
        "passRate": "42.72%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-replacements-to-sort-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-replacements-to-sort-the-array/solution",
        "problemsDesc": "<p>给你一个下表从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。每次操作中，你可以将数组中任何一个元素替换为&nbsp;<strong>任意两个</strong>&nbsp;和为该元素的数字。</p>\n\n<ul>\n\t<li>比方说，<code>nums = [5,6,7]</code>&nbsp;。一次操作中，我们可以将&nbsp;<code>nums[1]</code> 替换成&nbsp;<code>2</code> 和&nbsp;<code>4</code>&nbsp;，将&nbsp;<code>nums</code>&nbsp;转变成&nbsp;<code>[5,2,4,7]</code>&nbsp;。</li>\n</ul>\n\n<p>请你执行上述操作，将数组变成元素按 <strong>非递减</strong> 顺序排列的数组，并返回所需的最少操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,9,3]\n<b>输出：</b>2\n<b>解释：</b>以下是将数组变成非递减顺序的步骤：\n- [3,9,3] ，将9 变成 3 和 6 ，得到数组 [3,3,6,3] \n- [3,3,6,3] ，将 6 变成 3 和 3 ，得到数组 [3,3,3,3,3] \n总共需要 2 步将数组变成非递减有序，所以我们返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4,5]\n<b>输出：</b>0\n<b>解释：</b>数组已经是非递减顺序，所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2367.算术三元组的数目",
        "hardRate": "EASY",
        "passRate": "83.38%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-arithmetic-triplets/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-arithmetic-triplets/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、<strong>严格递增</strong> 的整数数组 <code>nums</code> 和一个正整数 <code>diff</code> 。如果满足下述全部条件，则三元组 <code>(i, j, k)</code> 就是一个 <strong>算术三元组</strong> ：</p>\n\n<ul>\n\t<li><code>i &lt; j &lt; k</code> ，</li>\n\t<li><code>nums[j] - nums[i] == diff</code> 且</li>\n\t<li><code>nums[k] - nums[j] == diff</code></li>\n</ul>\n\n<p>返回不同 <strong>算术三元组</strong> 的数目<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,4,6,7,10], diff = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>\n(1, 2, 4) 是算术三元组：7 - 4 == 3 且 4 - 1 == 3 。\n(2, 4, 5) 是算术三元组：10 - 7 == 3 且 7 - 4 == 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,5,6,7,8,9], diff = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>\n(0, 2, 4) 是算术三元组：8 - 6 == 2 且 6 - 4 == 2 。\n(1, 3, 5) 是算术三元组：9 - 7 == 2 且 7 - 5 == 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 200</code></li>\n\t<li><code>1 &lt;= diff &lt;= 50</code></li>\n\t<li><code>nums</code> <strong>严格</strong> 递增</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2368.受限条件下可到达节点的数目",
        "hardRate": "MEDIUM",
        "passRate": "46.13%",
        "problemsUrl": "https://leetcode.cn/problems/reachable-nodes-with-restrictions/",
        "solutionsUrl": "https://leetcode.cn/problems/reachable-nodes-with-restrictions/solution",
        "problemsDesc": "<p>现有一棵由 <code>n</code> 个节点组成的无向树，节点编号从 <code>0</code> 到 <code>n - 1</code> ，共有 <code>n - 1</code> 条边。</p>\n\n<p>给你一个二维整数数组 <code>edges</code> ，长度为 <code>n - 1</code> ，其中 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示树中节点 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间存在一条边。另给你一个整数数组 <code>restricted</code> 表示 <strong>受限</strong> 节点。</p>\n\n<p>在不访问受限节点的前提下，返回你可以从节点<em> </em><code>0</code><em> </em>到达的 <strong>最多</strong> 节点数目<em>。</em></p>\n\n<p>注意，节点 <code>0</code> <strong>不</strong> 会标记为受限节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/15/ex1drawio.png\" style=\"width: 402px; height: 322px;\">\n<pre><strong>输入：</strong>n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>上图所示正是这棵树。\n在不访问受限节点的前提下，只有节点 [0,1,2,3] 可以从节点 0 到达。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/15/ex2drawio.png\" style=\"width: 412px; height: 312px;\">\n<pre><strong>输入：</strong>n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>上图所示正是这棵树。\n在不访问受限节点的前提下，只有节点 [0,5,6] 可以从节点 0 到达。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>edges</code> 表示一棵有效的树</li>\n\t<li><code>1 &lt;= restricted.length &lt; n</code></li>\n\t<li><code>1 &lt;= restricted[i] &lt; n</code></li>\n\t<li><code>restricted</code> 中的所有值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2369.检查数组是否存在有效划分",
        "hardRate": "MEDIUM",
        "passRate": "38.51%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，你必须将数组划分为一个或多个 <strong>连续</strong> 子数组。</p>\n\n<p>如果获得的这些子数组中每个都能满足下述条件<strong> 之一</strong> ，则可以称其为数组的一种 <strong>有效</strong> 划分：</p>\n\n<ol>\n\t<li>子数组 <strong>恰</strong> 由 <code>2</code> 个相等元素组成，例如，子数组 <code>[2,2]</code> 。</li>\n\t<li>子数组 <strong>恰</strong> 由 <code>3</code> 个相等元素组成，例如，子数组 <code>[4,4,4]</code> 。</li>\n\t<li>子数组 <strong>恰</strong> 由 <code>3</code> 个连续递增元素组成，并且相邻元素之间的差值为 <code>1</code> 。例如，子数组 <code>[3,4,5]</code> ，但是子数组 <code>[1,3,5]</code> 不符合要求。</li>\n</ol>\n\n<p>如果数组 <strong>至少</strong> 存在一种有效划分，返回 <code>true</code><em> </em>，否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,4,4,5,6]\n<strong>输出：</strong>true\n<strong>解释：</strong>数组可以划分成子数组 [4,4] 和 [4,5,6] 。\n这是一种有效划分，所以返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,2]\n<strong>输出：</strong>false\n<strong>解释：</strong>该数组不存在有效划分。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2370.最长理想子序列",
        "hardRate": "MEDIUM",
        "passRate": "43.13%",
        "problemsUrl": "https://leetcode.cn/problems/longest-ideal-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-ideal-subsequence/solution",
        "problemsDesc": "<p>给你一个由小写字母组成的字符串 <code>s</code> ，和一个整数 <code>k</code> 。如果满足下述条件，则可以将字符串 <code>t</code> 视作是 <strong>理想字符串</strong> ：</p>\n\n<ul>\n\t<li><code>t</code> 是字符串 <code>s</code> 的一个子序列。</li>\n\t<li><code>t</code> 中每两个 <strong>相邻</strong> 字母在字母表中位次的绝对差值小于或等于 <code>k</code> 。</li>\n</ul>\n\n<p>返回 <strong>最长</strong> 理想字符串的长度。</p>\n\n<p>字符串的子序列同样是一个字符串，并且子序列还满足：可以经由其他字符串删除某些字符（也可以不删除）但不改变剩余字符的顺序得到。</p>\n\n<p><strong>注意：</strong>字母表顺序不会循环。例如，<code>'a'</code> 和 <code>'z'</code> 在字母表中位次的绝对差值是 <code>25</code> ，而不是 <code>1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"acfgbd\", k = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>最长理想字符串是 \"acbd\" 。该字符串长度为 4 ，所以返回 4 。\n注意 \"acfgbd\" 不是理想字符串，因为 'c' 和 'f' 的字母表位次差值为 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\", k = 3\n<strong>输出：</strong>4\n<strong>解释：</strong>最长理想字符串是 \"abcd\" ，该字符串长度为 4 ，所以返回 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 25</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2371.最小化网格中的最大值",
        "hardRate": "HARD",
        "passRate": "74.28%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-maximum-value-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-maximum-value-in-a-grid/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2372.计算每个销售人员的影响力",
        "hardRate": "MEDIUM",
        "passRate": "77.92%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-the-influence-of-each-salesperson/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-the-influence-of-each-salesperson/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2373.矩阵中的局部最大值",
        "hardRate": "EASY",
        "passRate": "85.15%",
        "problemsUrl": "https://leetcode.cn/problems/largest-local-values-in-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-local-values-in-a-matrix/solution",
        "problemsDesc": "<p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>grid</code> 。</p>\n\n<p>生成一个大小为&nbsp;<code>(n - 2) x (n - 2)</code> 的整数矩阵&nbsp; <code>maxLocal</code> ，并满足：</p>\n\n<ul>\n\t<li><code>maxLocal[i][j]</code> 等于 <code>grid</code> 中以 <code>i + 1</code> 行和 <code>j + 1</code> 列为中心的 <code>3 x 3</code> 矩阵中的 <strong>最大值</strong> 。</li>\n</ul>\n\n<p>换句话说，我们希望找出 <code>grid</code> 中每个&nbsp;<code>3 x 3</code> 矩阵中的最大值。</p>\n\n<p>返回生成的矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/21/ex1.png\" style=\"width: 371px; height: 210px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]\n<strong>输出：</strong>[[9,9],[8,6]]\n<strong>解释：</strong>原矩阵和生成的矩阵如上图所示。\n注意，生成的矩阵中，每个值都对应 grid 中一个相接的 3 x 3 矩阵的最大值。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/02/ex2new2.png\" style=\"width: 436px; height: 240px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]\n<strong>输出：</strong>[[2,2,2],[2,2,2],[2,2,2]]\n<strong>解释：</strong>注意，2 包含在 grid 中每个 3 x 3 的矩阵中。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>3 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2374.边积分最高的节点",
        "hardRate": "MEDIUM",
        "passRate": "42.34%",
        "problemsUrl": "https://leetcode.cn/problems/node-with-highest-edge-score/",
        "solutionsUrl": "https://leetcode.cn/problems/node-with-highest-edge-score/solution",
        "problemsDesc": "<p>给你一个有向图，图中有 <code>n</code> 个节点，节点编号从 <code>0</code> 到 <code>n - 1</code> ，其中每个节点都 <strong>恰有一条</strong> 出边。</p>\n\n<p>图由一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>edges</code> 表示，其中 <code>edges[i]</code> 表示存在一条从节点 <code>i</code> 到节点 <code>edges[i]</code> 的 <strong>有向</strong> 边。</p>\n\n<p>节点 <code>i</code> 的 <strong>边积分</strong> 定义为：所有存在一条指向节点 <code>i</code> 的边的节点的 <strong>编号</strong> 总和。</p>\n\n<p>返回 <strong>边积分</strong> 最高的节点。如果多个节点的 <strong>边积分</strong> 相同，返回编号 <strong>最小</strong> 的那个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/06/20/image-20220620195403-1.png\" style=\"width: 450px; height: 260px;\">\n<pre><strong>输入：</strong>edges = [1,0,0,0,0,7,7,5]\n<strong>输出：</strong>7\n<strong>解释：</strong>\n- 节点 1、2、3 和 4 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 + 3 + 4 = 10 。\n- 节点 0 有一条指向节点 1 的边，节点 1 的边积分等于 0 。\n- 节点 7 有一条指向节点 5 的边，节点 5 的边积分等于 7 。\n- 节点 5 和 6 都有指向节点 7 的边，节点 7 的边积分等于 5 + 6 = 11 。\n节点 7 的边积分最高，所以返回 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/06/20/image-20220620200212-3.png\" style=\"width: 150px; height: 155px;\">\n<pre><strong>输入：</strong>edges = [2,0,0,2]\n<strong>输出：</strong>0\n<strong>解释：\n</strong>- 节点 1 和 2 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 = 3 。\n- 节点 0 和 3 都有指向节点 2 的边，节点 2 的边积分等于 0 + 3 = 3 。\n节点 0 和 2 的边积分都是 3 。由于节点 0 的编号更小，返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= edges[i] &lt; n</code></li>\n\t<li><code>edges[i] != i</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2375.根据模式串构造最小数字",
        "hardRate": "MEDIUM",
        "passRate": "70.00%",
        "problemsUrl": "https://leetcode.cn/problems/construct-smallest-number-from-di-string/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-smallest-number-from-di-string/solution",
        "problemsDesc": "<p>给你下标从 <strong>0</strong> 开始、长度为 <code>n</code>&nbsp;的字符串&nbsp;<code>pattern</code>&nbsp;，它包含两种字符，<code>'I'</code>&nbsp;表示 <strong>上升</strong>&nbsp;，<code>'D'</code>&nbsp;表示 <strong>下降</strong>&nbsp;。</p>\n\n<p>你需要构造一个下标从 <strong>0</strong>&nbsp;开始长度为&nbsp;<code>n + 1</code>&nbsp;的字符串，且它要满足以下条件：</p>\n\n<ul>\n\t<li><code>num</code>&nbsp;包含数字&nbsp;<code>'1'</code>&nbsp;到&nbsp;<code>'9'</code>&nbsp;，其中每个数字&nbsp;<strong>至多</strong>&nbsp;使用一次。</li>\n\t<li>如果&nbsp;<code>pattern[i] == 'I'</code>&nbsp;，那么&nbsp;<code>num[i] &lt; num[i + 1]</code>&nbsp;。</li>\n\t<li>如果&nbsp;<code>pattern[i] == 'D'</code>&nbsp;，那么&nbsp;<code>num[i] &gt; num[i + 1]</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回满足上述条件字典序 <strong>最小</strong>&nbsp;的字符串<em>&nbsp;</em><code>num</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>pattern = \"IIIDIDDD\"\n<b>输出：</b>\"123549876\"\n<strong>解释：\n</strong>下标 0 ，1 ，2 和 4 处，我们需要使 num[i] &lt; num[i+1] 。\n下标 3 ，5 ，6 和 7 处，我们需要使 num[i] &gt; num[i+1] 。\n一些可能的 num 的值为 \"245639871\" ，\"135749862\" 和 \"123849765\" 。\n\"123549876\" 是满足条件最小的数字。\n注意，\"123414321\" 不是可行解因为数字 '1' 使用次数超过 1 次。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>pattern = \"DDD\"\n<b>输出：</b>\"4321\"\n<strong>解释：</strong>\n一些可能的 num 的值为 \"9876\" ，\"7321\" 和 \"8742\" 。\n\"4321\" 是满足条件最小的数字。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pattern.length &lt;= 8</code></li>\n\t<li><code>pattern</code>&nbsp;只包含字符&nbsp;<code>'I'</code> 和&nbsp;<code>'D'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2376.统计特殊整数",
        "hardRate": "HARD",
        "passRate": "51.69%",
        "problemsUrl": "https://leetcode.cn/problems/count-special-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/count-special-integers/solution",
        "problemsDesc": "<p>如果一个正整数每一个数位都是 <strong>互不相同</strong>&nbsp;的，我们称它是 <strong>特殊整数</strong> 。</p>\n\n<p>给你一个 <strong>正</strong>&nbsp;整数&nbsp;<code>n</code>&nbsp;，请你返回区间<em>&nbsp;</em><code>[1, n]</code>&nbsp;之间特殊整数的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 20\n<b>输出：</b>19\n<b>解释：</b>1 到 20 之间所有整数除了 11 以外都是特殊整数。所以总共有 19 个特殊整数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5\n<b>输出：</b>5\n<b>解释：</b>1 到 5 所有整数都是特殊整数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 135\n<b>输出：</b>110\n<b>解释：</b>从 1 到 135 总共有 110 个整数是特殊整数。\n不特殊的部分数字为：22 ，114 和 131 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2377.整理奥运表",
        "hardRate": "EASY",
        "passRate": "80.02%",
        "problemsUrl": "https://leetcode.cn/problems/sort-the-olympic-table/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-the-olympic-table/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2378.选择边来最大化树的得分",
        "hardRate": "MEDIUM",
        "passRate": "69.60%",
        "problemsUrl": "https://leetcode.cn/problems/choose-edges-to-maximize-score-in-a-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/choose-edges-to-maximize-score-in-a-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2379.得到 K 个黑块的最少涂色次数",
        "hardRate": "EASY",
        "passRate": "61.76%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>blocks</code>&nbsp;，<code>blocks[i]</code>&nbsp;要么是&nbsp;<code>'W'</code>&nbsp;要么是&nbsp;<code>'B'</code>&nbsp;，表示第&nbsp;<code>i</code>&nbsp;块的颜色。字符&nbsp;<code>'W'</code> 和&nbsp;<code>'B'</code>&nbsp;分别表示白色和黑色。</p>\n\n<p>给你一个整数&nbsp;<code>k</code>&nbsp;，表示想要&nbsp;<strong>连续</strong>&nbsp;黑色块的数目。</p>\n\n<p>每一次操作中，你可以选择一个白色块将它 <strong>涂成</strong>&nbsp;黑色块。</p>\n\n<p>请你返回至少出现 <strong>一次</strong>&nbsp;连续 <code>k</code>&nbsp;个黑色块的 <strong>最少</strong>&nbsp;操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>blocks = \"WBBWWBBWBW\", k = 7\n<b>输出：</b>3\n<strong>解释：</strong>\n一种得到 7 个连续黑色块的方法是把第 0 ，3 和 4 个块涂成黑色。\n得到 blocks = \"BBBBBBBWBW\" 。\n可以证明无法用少于 3 次操作得到 7 个连续的黑块。\n所以我们返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>blocks = \"WBWBBBW\", k = 2\n<b>输出：</b>0\n<strong>解释：</strong>\n不需要任何操作，因为已经有 2 个连续的黑块。\n所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>n == blocks.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>blocks[i]</code>&nbsp;要么是&nbsp;<code>'W'</code>&nbsp;，要么是&nbsp;<code>'B'</code> 。</li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2380.二进制字符串重新安排顺序需要的时间",
        "hardRate": "MEDIUM",
        "passRate": "56.16%",
        "problemsUrl": "https://leetcode.cn/problems/time-needed-to-rearrange-a-binary-string/",
        "solutionsUrl": "https://leetcode.cn/problems/time-needed-to-rearrange-a-binary-string/solution",
        "problemsDesc": "<p>给你一个二进制字符串&nbsp;<code>s</code>&nbsp;。在一秒之中，<strong>所有</strong>&nbsp;子字符串&nbsp;<code>\"01\"</code> <strong>同时</strong>&nbsp;被替换成&nbsp;<code>\"10\"</code>&nbsp;。这个过程持续进行到没有&nbsp;<code>\"01\"</code>&nbsp;存在。</p>\n\n<p>请你返回完成这个过程所需要的秒数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"0110101\"\n<b>输出：</b>4\n<b>解释：</b>\n一秒后，s 变成 \"1011010\" 。\n再过 1 秒后，s 变成 \"1101100\" 。\n第三秒过后，s 变成 \"1110100\" 。\n第四秒后，s 变成 \"1111000\" 。\n此时没有 \"01\" 存在，整个过程花费 4 秒。\n所以我们返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"11100\"\n<b>输出：</b>0\n<strong>解释：</strong>\ns 中没有 \"01\" 存在，整个过程花费 0 秒。\n所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i]</code>&nbsp;要么是&nbsp;<code>'0'</code>&nbsp;，要么是&nbsp;<code>'1'</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<p>你能以 O(n) 的时间复杂度解决这个问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2381.字母移位 II",
        "hardRate": "MEDIUM",
        "passRate": "36.90%",
        "problemsUrl": "https://leetcode.cn/problems/shifting-letters-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/shifting-letters-ii/solution",
        "problemsDesc": "<p>给你一个小写英文字母组成的字符串&nbsp;<code>s</code>&nbsp;和一个二维整数数组&nbsp;<code>shifts</code>&nbsp;，其中&nbsp;<code>shifts[i] = [start<sub>i</sub>, end<sub>i</sub>, direction<sub>i</sub>]</code>&nbsp;。对于每个&nbsp;<code>i</code>&nbsp;，将&nbsp;<code>s</code>&nbsp;中从下标&nbsp;<code>start<sub>i</sub></code>&nbsp;到下标&nbsp;<code>end<sub>i</sub></code>&nbsp;（两者都包含）所有字符都进行移位运算，如果&nbsp;<code>direction<sub>i</sub> = 1</code>&nbsp;将字符向后移位，如果&nbsp;<code>direction<sub>i</sub> = 0</code>&nbsp;将字符向前移位。</p>\n\n<p>将一个字符 <strong>向后</strong>&nbsp;移位的意思是将这个字符用字母表中 <strong>下一个</strong>&nbsp;字母替换（字母表视为环绕的，所以&nbsp;<code>'z'</code>&nbsp;变成&nbsp;<code>'a'</code>）。类似的，将一个字符 <strong>向前</strong>&nbsp;移位的意思是将这个字符用字母表中 <strong>前一个</strong>&nbsp;字母替换（字母表是环绕的，所以&nbsp;<code>'a'</code>&nbsp;变成&nbsp;<code>'z'</code>&nbsp;）。</p>\n\n<p>请你返回对 <code>s</code>&nbsp;进行所有移位操作以后得到的最终字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"abc\", shifts = [[0,1,0],[1,2,1],[0,2,1]]\n<b>输出：</b>\"ace\"\n<b>解释：</b>首先，将下标从 0 到 1 的字母向前移位，得到 s = \"zac\" 。\n然后，将下标从 1 到 2 的字母向后移位，得到 s = \"zbd\" 。\n最后，将下标从 0 到 2 的字符向后移位，得到 s = \"ace\" 。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><b>输入：</b>s = \"dztz\", shifts = [[0,0,0],[1,1,1]]\n<b>输出：</b>\"catz\"\n<b>解释：</b>首先，将下标从 0 到 0 的字母向前移位，得到 s = \"cztz\" 。\n最后，将下标从 1 到 1 的字符向后移位，得到 s = \"catz\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, shifts.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>shifts[i].length == 3</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt; s.length</code></li>\n\t<li><code>0 &lt;= direction<sub>i</sub> &lt;= 1</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2382.删除操作后的最大子段和",
        "hardRate": "HARD",
        "passRate": "56.29%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-segment-sum-after-removals/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-segment-sum-after-removals/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code> 和&nbsp;<code>removeQueries</code>&nbsp;，两者长度都为&nbsp;<code>n</code>&nbsp;。对于第&nbsp;<code>i</code>&nbsp;个查询，<code>nums</code>&nbsp;中位于下标&nbsp;<code>removeQueries[i]</code>&nbsp;处的元素被删除，将 <code>nums</code>&nbsp;分割成更小的子段。</p>\n\n<p>一个 <strong>子段</strong>&nbsp;是 <code>nums</code>&nbsp;中连续 <strong>正</strong>&nbsp;整数形成的序列。<strong>子段和</strong>&nbsp;是子段中所有元素的和。</p>\n\n<p>请你返回一个长度为 <code>n</code>&nbsp;的整数数组<em>&nbsp;</em><code>answer</code>&nbsp;，其中<em>&nbsp;</em><code>answer[i]</code>是第&nbsp;<code>i</code>&nbsp;次删除操作以后的&nbsp;<strong>最大</strong>&nbsp;子段和。</p>\n\n<p><strong>注意：</strong>一个下标至多只会被删除一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]\n<b>输出：</b>[14,7,2,2,0]\n<b>解释：</b>用 0 表示被删除的元素，答案如下所示：\n查询 1 ：删除第 0 个元素，nums 变成 [0,2,5,6,1] ，最大子段和为子段 [2,5,6,1] 的和 14 。\n查询 2 ：删除第 3 个元素，nums 变成 [0,2,5,0,1] ，最大子段和为子段 [2,5] 的和 7 。\n查询 3 ：删除第 2 个元素，nums 变成 [0,2,0,0,1] ，最大子段和为子段 [2] 的和 2 。\n查询 4 ：删除第 4 个元素，nums 变成 [0,2,0,0,0] ，最大子段和为子段 [2] 的和 2 。\n查询 5 ：删除第 1 个元素，nums 变成 [0,0,0,0,0] ，最大子段和为 0 ，因为没有任何子段存在。\n所以，我们返回 [14,7,2,2,0] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [3,2,11,1], removeQueries = [3,2,1,0]\n<b>输出：</b>[16,5,3,0]\n<b>解释：</b>用 0 表示被删除的元素，答案如下所示：\n查询 1 ：删除第 3 个元素，nums 变成 [3,2,11,0] ，最大子段和为子段 [3,2,11] 的和 16 。\n查询 2 ：删除第 2 个元素，nums 变成 [3,2,0,0] ，最大子段和为子段 [3,2] 的和 5 。\n查询 3 ：删除第 1 个元素，nums 变成 [3,0,0,0] ，最大子段和为子段 [3] 的和 3 。\n查询 5 ：删除第 0 个元素，nums 变成 [0,0,0,0] ，最大子段和为 0 ，因为没有任何子段存在。\n所以，我们返回 [16,5,3,0] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length == removeQueries.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= removeQueries[i] &lt; n</code></li>\n\t<li><code>removeQueries</code>&nbsp;中所有数字 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2383.赢得比赛需要的最少训练时长",
        "hardRate": "EASY",
        "passRate": "47.19%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition/solution",
        "problemsDesc": "<p>你正在参加一场比赛，给你两个 <strong>正</strong> 整数 <code>initialEnergy</code> 和 <code>initialExperience</code> 分别表示你的初始精力和初始经验。</p>\n\n<p>另给你两个下标从 <strong>0</strong> 开始的整数数组 <code>energy</code> 和 <code>experience</code>，长度均为 <code>n</code> 。</p>\n\n<p>你将会 <strong>依次</strong> 对上 <code>n</code> 个对手。第 <code>i</code> 个对手的精力和经验分别用 <code>energy[i]</code> 和 <code>experience[i]</code> 表示。当你对上对手时，需要在经验和精力上都 <strong>严格</strong> 超过对手才能击败他们，然后在可能的情况下继续对上下一个对手。</p>\n\n<p>击败第 <code>i</code> 个对手会使你的经验 <strong>增加</strong> <code>experience[i]</code>，但会将你的精力 <strong>减少</strong>&nbsp; <code>energy[i]</code> 。</p>\n\n<p>在开始比赛前，你可以训练几个小时。每训练一个小时，你可以选择将增加经验增加 1 <strong>或者</strong> 将精力增加 1 。</p>\n\n<p>返回击败全部 <code>n</code> 个对手需要训练的 <strong>最少</strong> 小时数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]\n<strong>输出：</strong>8\n<strong>解释：</strong>在 6 小时训练后，你可以将精力提高到 11 ，并且再训练 2 个小时将经验提高到 5 。\n按以下顺序与对手比赛：\n- 你的精力与经验都超过第 0 个对手，所以获胜。\n  精力变为：11 - 1 = 10 ，经验变为：5 + 2 = 7 。\n- 你的精力与经验都超过第 1 个对手，所以获胜。\n  精力变为：10 - 4 = 6 ，经验变为：7 + 6 = 13 。\n- 你的精力与经验都超过第 2 个对手，所以获胜。\n  精力变为：6 - 3 = 3 ，经验变为：13 + 3 = 16 。\n- 你的精力与经验都超过第 3 个对手，所以获胜。\n  精力变为：3 - 2 = 1 ，经验变为：16 + 1 = 17 。\n在比赛前进行了 8 小时训练，所以返回 8 。\n可以证明不存在更小的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>initialEnergy = 2, initialExperience = 4, energy = [1], experience = [3]\n<strong>输出：</strong>0\n<strong>解释：</strong>你不需要额外的精力和经验就可以赢得比赛，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == energy.length == experience.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= initialEnergy, initialExperience, energy[i], experience[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2384.最大回文数字",
        "hardRate": "MEDIUM",
        "passRate": "31.08%",
        "problemsUrl": "https://leetcode.cn/problems/largest-palindromic-number/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-palindromic-number/solution",
        "problemsDesc": "<p>给你一个仅由数字（<code>0 - 9</code>）组成的字符串 <code>num</code> 。</p>\n\n<p>请你找出能够使用 <code>num</code> 中数字形成的 <strong>最大回文</strong> 整数，并以字符串形式返回。该整数不含 <strong>前导零</strong> 。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>你 <strong>无需</strong> 使用 <code>num</code> 中的所有数字，但你必须使用 <strong>至少</strong> 一个数字。</li>\n\t<li>数字可以重新排序。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"444947137\"\n<strong>输出：</strong>\"7449447\"\n<strong>解释：</strong>\n从 \"<em><strong>44494</strong></em><em><strong>7</strong></em>13<em><strong>7</strong></em>\" 中选用数字 \"4449477\"，可以形成回文整数 \"7449447\" 。\n可以证明 \"7449447\" 是能够形成的最大回文整数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"00009\"\n<strong>输出：</strong>\"9\"\n<strong>解释：</strong>\n可以证明 \"9\" 能够形成的最大回文整数。\n注意返回的整数不应含前导零。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>num</code> 由数字（<code>0 - 9</code>）组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2385.感染二叉树需要的总时间",
        "hardRate": "MEDIUM",
        "passRate": "46.14%",
        "problemsUrl": "https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/",
        "solutionsUrl": "https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点 <code>root</code> ，二叉树中节点的值 <strong>互不相同</strong> 。另给你一个整数 <code>start</code> 。在第 <code>0</code> 分钟，<strong>感染</strong> 将会从值为 <code>start</code> 的节点开始爆发。</p>\n\n<p>每分钟，如果节点满足以下全部条件，就会被感染：</p>\n\n<ul>\n\t<li>节点此前还没有感染。</li>\n\t<li>节点与一个已感染节点相邻。</li>\n</ul>\n\n<p>返回感染整棵树需要的分钟数<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/25/image-20220625231744-1.png\" style=\"width: 400px; height: 306px;\">\n<pre><strong>输入：</strong>root = [1,5,3,null,4,10,6,9,2], start = 3\n<strong>输出：</strong>4\n<strong>解释：</strong>节点按以下过程被感染：\n- 第 0 分钟：节点 3\n- 第 1 分钟：节点 1、10、6\n- 第 2 分钟：节点5\n- 第 3 分钟：节点 4\n- 第 4 分钟：节点 9 和 2\n感染整棵树需要 4 分钟，所以返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/25/image-20220625231812-2.png\" style=\"width: 75px; height: 66px;\">\n<pre><strong>输入：</strong>root = [1], start = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>第 0 分钟，树中唯一一个节点处于感染状态，返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li>每个节点的值 <strong>互不相同</strong></li>\n\t<li>树中必定存在值为 <code>start</code> 的节点</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2386.找出数组的第 K 大和",
        "hardRate": "HARD",
        "passRate": "42.35%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-k-sum-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-k-sum-of-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个 <strong>正</strong> 整数 <code>k</code> 。你可以选择数组的任一 <strong>子序列</strong> 并且对其全部元素求和。</p>\n\n<p>数组的 <strong>第 k 大和</strong> 定义为：可以获得的第 <code>k</code> 个 <strong>最大</strong> 子序列和（子序列和允许出现重复）</p>\n\n<p>返回数组的 <strong>第 k 大和</strong> 。</p>\n\n<p>子序列是一个可以由其他数组删除某些或不删除元素排生而来的数组，且派生过程不改变剩余元素的顺序。</p>\n\n<p><strong>注意：</strong>空子序列的和视作 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,4,-2], k = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>所有可能获得的子序列和列出如下，按递减顺序排列：\n- 6、4、4、2、<strong><em>2</em></strong>、0、0、-2\n数组的第 5 大和是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,-2,3,4,-10,12], k = 16\n<strong>输出：</strong>10\n<strong>解释：</strong>数组的第 16 大和是 10 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= min(2000, 2<sup>n</sup>)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2387.行排序矩阵的中位数",
        "hardRate": "MEDIUM",
        "passRate": "76.22%",
        "problemsUrl": "https://leetcode.cn/problems/median-of-a-row-wise-sorted-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/median-of-a-row-wise-sorted-matrix/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2388.将表中的空值更改为前一个值",
        "hardRate": "MEDIUM",
        "passRate": "67.93%",
        "problemsUrl": "https://leetcode.cn/problems/change-null-values-in-a-table-to-the-previous-value/",
        "solutionsUrl": "https://leetcode.cn/problems/change-null-values-in-a-table-to-the-previous-value/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2389.和有限的最长子序列",
        "hardRate": "EASY",
        "passRate": "70.93%",
        "problemsUrl": "https://leetcode.cn/problems/longest-subsequence-with-limited-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-subsequence-with-limited-sum/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的整数数组 <code>nums</code> ，和一个长度为 <code>m</code> 的整数数组 <code>queries</code> 。</p>\n\n<p>返回一个长度为 <code>m</code> 的数组<em> </em><code>answer</code><em> </em>，其中<em> </em><code>answer[i]</code><em> </em>是 <code>nums</code> 中<span style=\"\"> </span>元素之和小于等于 <code>queries[i]</code> 的 <strong>子序列</strong> 的 <strong>最大</strong> 长度<span style=\"\">&nbsp;</span><span style=\"\"> </span>。</p>\n\n<p><strong>子序列</strong> 是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,5,2,1], queries = [3,10,21]\n<strong>输出：</strong>[2,3,4]\n<strong>解释：</strong>queries 对应的 answer 如下：\n- 子序列 [2,1] 的和小于或等于 3 。可以证明满足题目要求的子序列的最大长度是 2 ，所以 answer[0] = 2 。\n- 子序列 [4,5,1] 的和小于或等于 10 。可以证明满足题目要求的子序列的最大长度是 3 ，所以 answer[1] = 3 。\n- 子序列 [4,5,2,1] 的和小于或等于 21 。可以证明满足题目要求的子序列的最大长度是 4 ，所以 answer[2] = 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,4,5], queries = [1]\n<strong>输出：</strong>[0]\n<strong>解释：</strong>空子序列是唯一一个满足元素和小于或等于 1 的子序列，所以 answer[0] = 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>m == queries.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i], queries[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2390.从字符串中移除星号",
        "hardRate": "MEDIUM",
        "passRate": "69.38%",
        "problemsUrl": "https://leetcode.cn/problems/removing-stars-from-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/removing-stars-from-a-string/solution",
        "problemsDesc": "<p>给你一个包含若干星号 <code>*</code> 的字符串 <code>s</code> 。</p>\n\n<p>在一步操作中，你可以：</p>\n\n<ul>\n\t<li>选中 <code>s</code> 中的一个星号。</li>\n\t<li>移除星号 <strong>左侧</strong> 最近的那个 <strong>非星号</strong> 字符，并移除该星号自身。</li>\n</ul>\n\n<p>返回移除 <strong>所有</strong> 星号之后的字符串<strong>。</strong></p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>生成的输入保证总是可以执行题面中描述的操作。</li>\n\t<li>可以证明结果字符串是唯一的。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"leet**cod*e\"\n<strong>输出：</strong>\"lecoe\"\n<strong>解释：</strong>从左到右执行移除操作：\n- 距离第 1 个星号最近的字符是 \"lee<em><strong>t</strong></em>**cod*e\" 中的 't' ，s 变为 \"lee*cod*e\" 。\n- 距离第 2 个星号最近的字符是 \"le<em><strong>e</strong></em>*cod*e\" 中的 'e' ，s 变为 \"lecod*e\" 。\n- 距离第 3 个星号最近的字符是 \"leco<em><strong>d</strong></em>*e\" 中的 'd' ，s 变为 \"lecoe\" 。\n不存在其他星号，返回 \"lecoe\" 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"erase*****\"\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>整个字符串都会被移除，所以返回空字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写英文字母和星号 <code>*</code> 组成</li>\n\t<li><code>s</code> 可以执行上述操作</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2391.收集垃圾的最少总时间",
        "hardRate": "MEDIUM",
        "passRate": "85.65%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-amount-of-time-to-collect-garbage/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-amount-of-time-to-collect-garbage/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串数组&nbsp;<code>garbage</code>&nbsp;，其中&nbsp;<code>garbage[i]</code>&nbsp;表示第 <code>i</code>&nbsp;个房子的垃圾集合。<code>garbage[i]</code>&nbsp;只包含字符&nbsp;<code>'M'</code>&nbsp;，<code>'P'</code> 和&nbsp;<code>'G'</code>&nbsp;，但可能包含多个相同字符，每个字符分别表示一单位的金属、纸和玻璃。垃圾车收拾 <strong>一</strong>&nbsp;单位的任何一种垃圾都需要花费&nbsp;<code>1</code>&nbsp;分钟。</p>\n\n<p>同时给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>travel</code>&nbsp;，其中&nbsp;<code>travel[i]</code>&nbsp;是垃圾车从房子 <code>i</code>&nbsp;行驶到房子 <code>i + 1</code>&nbsp;需要的分钟数。</p>\n\n<p>城市里总共有三辆垃圾车，分别收拾三种垃圾。每辆垃圾车都从房子 <code>0</code>&nbsp;出发，<strong>按顺序</strong>&nbsp;到达每一栋房子。但它们 <strong>不是必须</strong>&nbsp;到达所有的房子。</p>\n\n<p>任何时刻只有 <strong>一辆</strong>&nbsp;垃圾车处在使用状态。当一辆垃圾车在行驶或者收拾垃圾的时候，另外两辆车 <strong>不能</strong>&nbsp;做任何事情。</p>\n\n<p>请你返回收拾完所有垃圾需要花费的 <strong>最少</strong>&nbsp;总分钟数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>garbage = [\"G\",\"P\",\"GP\",\"GG\"], travel = [2,4,3]\n<b>输出：</b>21\n<strong>解释：</strong>\n收拾纸的垃圾车：\n1. 从房子 0 行驶到房子 1\n2. 收拾房子 1 的纸垃圾\n3. 从房子 1 行驶到房子 2\n4. 收拾房子 2 的纸垃圾\n收拾纸的垃圾车总共花费 8 分钟收拾完所有的纸垃圾。\n收拾玻璃的垃圾车：\n1. 收拾房子 0 的玻璃垃圾\n2. 从房子 0 行驶到房子 1\n3. 从房子 1 行驶到房子 2\n4. 收拾房子 2 的玻璃垃圾\n5. 从房子 2 行驶到房子 3\n6. 收拾房子 3 的玻璃垃圾\n收拾玻璃的垃圾车总共花费 13 分钟收拾完所有的玻璃垃圾。\n由于没有金属垃圾，收拾金属的垃圾车不需要花费任何时间。\n所以总共花费 8 + 13 = 21 分钟收拾完所有垃圾。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>garbage = [\"MMM\",\"PGM\",\"GP\"], travel = [3,10]\n<b>输出：</b>37\n<strong>解释：</strong>\n收拾金属的垃圾车花费 7 分钟收拾完所有的金属垃圾。\n收拾纸的垃圾车花费 15 分钟收拾完所有的纸垃圾。\n收拾玻璃的垃圾车花费 15 分钟收拾完所有的玻璃垃圾。\n总共花费 7 + 15 + 15 = 37 分钟收拾完所有的垃圾。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= garbage.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>garbage[i]</code> 只包含字母&nbsp;<code>'M'</code>&nbsp;，<code>'P'</code>&nbsp;和&nbsp;<code>'G'</code>&nbsp;。</li>\n\t<li><code>1 &lt;= garbage[i].length &lt;= 10</code></li>\n\t<li><code>travel.length == garbage.length - 1</code></li>\n\t<li><code>1 &lt;= travel[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2392.给定条件下构造矩阵",
        "hardRate": "HARD",
        "passRate": "55.80%",
        "problemsUrl": "https://leetcode.cn/problems/build-a-matrix-with-conditions/",
        "solutionsUrl": "https://leetcode.cn/problems/build-a-matrix-with-conditions/solution",
        "problemsDesc": "<p>给你一个 <strong>正</strong>&nbsp;整数&nbsp;<code>k</code>&nbsp;，同时给你：</p>\n\n<ul>\n\t<li>一个大小为 <code>n</code>&nbsp;的二维整数数组&nbsp;<code>rowConditions</code>&nbsp;，其中&nbsp;<code>rowConditions[i] = [above<sub>i</sub>, below<sub>i</sub>]</code>&nbsp;和</li>\n\t<li>一个大小为 <code>m</code>&nbsp;的二维整数数组&nbsp;<code>colConditions</code>&nbsp;，其中&nbsp;<code>colConditions[i] = [left<sub>i</sub>, right<sub>i</sub>]</code>&nbsp;。</li>\n</ul>\n\n<p>两个数组里的整数都是&nbsp;<code>1</code>&nbsp;到&nbsp;<code>k</code>&nbsp;之间的数字。</p>\n\n<p>你需要构造一个&nbsp;<code>k x k</code>&nbsp;的矩阵，<code>1</code>&nbsp;到&nbsp;<code>k</code>&nbsp;每个数字需要&nbsp;<strong>恰好出现一次</strong>&nbsp;。剩余的数字都是<b>&nbsp;</b><code>0</code>&nbsp;。</p>\n\n<p>矩阵还需要满足以下条件：</p>\n\n<ul>\n\t<li>对于所有 <code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;之间的下标&nbsp;<code>i</code>&nbsp;，数字&nbsp;<code>above<sub>i</sub></code>&nbsp;所在的 <strong>行</strong>&nbsp;必须在数字&nbsp;<code>below<sub>i</sub></code>&nbsp;所在行的上面。</li>\n\t<li>对于所有 <code>0</code>&nbsp;到 <code>m - 1</code>&nbsp;之间的下标&nbsp;<code>i</code>&nbsp;，数字&nbsp;<code>left<sub>i</sub></code>&nbsp;所在的 <b>列</b>&nbsp;必须在数字&nbsp;<code>right<sub>i</sub></code>&nbsp;所在列的左边。</li>\n</ul>\n\n<p>返回满足上述要求的 <strong>任意</strong>&nbsp;矩阵。如果不存在答案，返回一个空的矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/06/gridosdrawio.png\" style=\"width: 211px; height: 211px;\"></p>\n\n<pre><b>输入：</b>k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]]\n<b>输出：</b>[[3,0,0],[0,0,1],[0,2,0]]\n<b>解释：</b>上图为一个符合所有条件的矩阵。\n行要求如下：\n- 数字 1 在第 <strong>1</strong> 行，数字 2 在第 <strong>2</strong>&nbsp;行，1 在 2 的上面。\n- 数字 3 在第 <strong>0</strong>&nbsp;行，数字 2 在第 <strong>2</strong>&nbsp;行，3 在 2 的上面。\n列要求如下：\n- 数字 2 在第 <strong>1</strong>&nbsp;列，数字 1 在第 <strong>2</strong>&nbsp;列，2 在 1 的左边。\n- 数字 3 在第 <strong>0</strong>&nbsp;列，数字 2 在第 <strong>1</strong>&nbsp;列，3 在 2 的左边。\n注意，可能有多种正确的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]]\n<b>输出：</b>[]\n<b>解释：</b>由前两个条件可以得到 3 在 1 的下面，但第三个条件是 3 在 1 的上面。\n没有符合条件的矩阵存在，所以我们返回空矩阵。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= k &lt;= 400</code></li>\n\t<li><code>1 &lt;= rowConditions.length, colConditions.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>rowConditions[i].length == colConditions[i].length == 2</code></li>\n\t<li><code>1 &lt;= above<sub>i</sub>, below<sub>i</sub>, left<sub>i</sub>, right<sub>i</sub> &lt;= k</code></li>\n\t<li><code>above<sub>i</sub> != below<sub>i</sub></code></li>\n\t<li><code>left<sub>i</sub> != right<sub>i</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2393.严格递增的子数组个数",
        "hardRate": "MEDIUM",
        "passRate": "78.52%",
        "problemsUrl": "https://leetcode.cn/problems/count-strictly-increasing-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/count-strictly-increasing-subarrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2394.开除员工",
        "hardRate": "MEDIUM",
        "passRate": "53.15%",
        "problemsUrl": "https://leetcode.cn/problems/employees-with-deductions/",
        "solutionsUrl": "https://leetcode.cn/problems/employees-with-deductions/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2395.和相等的子数组",
        "hardRate": "EASY",
        "passRate": "76.25%",
        "problemsUrl": "https://leetcode.cn/problems/find-subarrays-with-equal-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/find-subarrays-with-equal-sum/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，判断是否存在&nbsp;<strong>两个</strong>&nbsp;长度为&nbsp;<code>2</code>&nbsp;的子数组且它们的&nbsp;<strong>和</strong>&nbsp;相等。注意，这两个子数组起始位置的下标必须&nbsp;<strong>不相同</strong>&nbsp;。</p>\n\n<p>如果这样的子数组存在，请返回&nbsp;<code>true</code>，否则返回&nbsp;<code>false</code><em>&nbsp;</em>。</p>\n\n<p><strong>子数组</strong> 是一个数组中一段连续非空的元素组成的序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [4,2,4]\n<b>输出：</b>true\n<b>解释：</b>元素为 [4,2] 和 [2,4] 的子数组有相同的和 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4,5]\n<b>输出：</b>false\n<b>解释：</b>没有长度为 2 的两个子数组和相等。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [0,0,0]\n<b>输出：</b>true\n<b>解释：</b>子数组 [nums[0],nums[1]] 和 [nums[1],nums[2]] 的和相等，都为 0 。\n注意即使子数组的元素相同，这两个子数组也视为不相同的子数组，因为它们在原数组中的起始位置不同。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2396.严格回文的数字",
        "hardRate": "MEDIUM",
        "passRate": "87.89%",
        "problemsUrl": "https://leetcode.cn/problems/strictly-palindromic-number/",
        "solutionsUrl": "https://leetcode.cn/problems/strictly-palindromic-number/solution",
        "problemsDesc": "<p>如果一个整数 <code>n</code>&nbsp;在 <code>b</code>&nbsp;进制下（<code>b</code>&nbsp;为 <code>2</code>&nbsp;到 <code>n - 2</code>&nbsp;之间的所有整数）对应的字符串&nbsp;<strong>全部</strong>&nbsp;都是 <strong>回文的</strong>&nbsp;，那么我们称这个数&nbsp;<code>n</code>&nbsp;是 <strong>严格回文</strong>&nbsp;的。</p>\n\n<p>给你一个整数&nbsp;<code>n</code>&nbsp;，如果 <code>n</code>&nbsp;是 <strong>严格回文</strong>&nbsp;的，请返回&nbsp;<code>true</code> ，否则返回<em>&nbsp;</em><code>false</code>&nbsp;。</p>\n\n<p>如果一个字符串从前往后读和从后往前读完全相同，那么这个字符串是 <strong>回文的</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 9\n<b>输出：</b>false\n<b>解释：</b>在 2 进制下：9 = 1001 ，是回文的。\n在 3 进制下：9 = 100 ，不是回文的。\n所以，9 不是严格回文数字，我们返回 false 。\n注意在 4, 5, 6 和 7 进制下，n = 9 都不是回文的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 4\n<b>输出：</b>false\n<b>解释：</b>我们只考虑 2 进制：4 = 100 ，不是回文的。\n所以我们返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>4 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2397.被列覆盖的最多行数",
        "hardRate": "MEDIUM",
        "passRate": "54.92%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-rows-covered-by-columns/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-rows-covered-by-columns/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;二进制矩阵&nbsp;<code>mat</code>&nbsp;和一个整数&nbsp;<code>cols</code>&nbsp;，表示你需要选出的列数。</p>\n\n<p>如果一行中，所有的 <code>1</code> 都被你选中的列所覆盖，那么我们称这一行 <strong>被覆盖</strong>&nbsp;了。</p>\n\n<p>请你返回在选择 <code>cols</code>&nbsp;列的情况下，<strong>被覆盖</strong>&nbsp;的行数 <strong>最大</strong>&nbsp;为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/14/rowscovered.png\" style=\"width: 250px; height: 417px;\"></strong></p>\n\n<pre><b>输入：</b>mat = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], cols = 2\n<b>输出：</b>3\n<strong>解释：</strong>\n如上图所示，覆盖 3 行的一种可行办法是选择第 0 和第 2 列。\n可以看出，不存在大于 3 行被覆盖的方案，所以我们返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/14/rowscovered2.png\" style=\"width: 83px; height: 247px;\"></strong></p>\n\n<pre><b>输入：</b>mat = [[1],[0]], cols = 1\n<b>输出：</b>2\n<strong>解释：</strong>\n选择唯一的一列，两行都被覆盖了，原因是整个矩阵都被覆盖了。\n所以我们返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 12</code></li>\n\t<li><code>mat[i][j]</code>&nbsp;要么是&nbsp;<code>0</code>&nbsp;要么是&nbsp;<code>1</code>&nbsp;。</li>\n\t<li><code>1 &lt;= cols &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2398.预算内的最多机器人数目",
        "hardRate": "HARD",
        "passRate": "34.48%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-robots-within-budget/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-robots-within-budget/solution",
        "problemsDesc": "<p>你有&nbsp;<code>n</code>&nbsp;个机器人，给你两个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>chargeTimes</code> 和&nbsp;<code>runningCosts</code>&nbsp;，两者长度都为&nbsp;<code>n</code>&nbsp;。第&nbsp;<code>i</code>&nbsp;个机器人充电时间为&nbsp;<code>chargeTimes[i]</code>&nbsp;单位时间，花费&nbsp;<code>runningCosts[i]</code>&nbsp;单位时间运行。再给你一个整数&nbsp;<code>budget</code>&nbsp;。</p>\n\n<p>运行&nbsp;<code>k</code>&nbsp;个机器人 <strong>总开销</strong>&nbsp;是&nbsp;<code>max(chargeTimes) + k * sum(runningCosts)</code>&nbsp;，其中&nbsp;<code>max(chargeTimes)</code>&nbsp;是这&nbsp;<code>k</code>&nbsp;个机器人中最大充电时间，<code>sum(runningCosts)</code>&nbsp;是这 <code>k</code>&nbsp;个机器人的运行时间之和。</p>\n\n<p>请你返回在 <strong>不超过</strong>&nbsp;<code>budget</code>&nbsp;的前提下，你 <strong>最多</strong>&nbsp;可以 <strong>连续</strong>&nbsp;运行的机器人数目为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>chargeTimes = [3,6,1,3,4], runningCosts = [2,1,3,4,5], budget = 25\n<b>输出：</b>3\n<b>解释：</b>\n可以在 budget 以内运行所有单个机器人或者连续运行 2 个机器人。\n选择前 3 个机器人，可以得到答案最大值 3 。总开销是 max(3,6,1) + 3 * sum(2,1,3) = 6 + 3 * 6 = 24 ，小于 25 。\n可以看出无法在 budget 以内连续运行超过 3 个机器人，所以我们返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>chargeTimes = [11,12,19], runningCosts = [10,8,7], budget = 19\n<b>输出：</b>0\n<b>解释：</b>即使运行任何一个单个机器人，还是会超出 budget，所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>chargeTimes.length == runningCosts.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= chargeTimes[i], runningCosts[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= budget &lt;= 10<sup>15</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2399.检查相同字母间的距离",
        "hardRate": "EASY",
        "passRate": "75.26%",
        "problemsUrl": "https://leetcode.cn/problems/check-distances-between-same-letters/",
        "solutionsUrl": "https://leetcode.cn/problems/check-distances-between-same-letters/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，该字符串仅由小写英文字母组成，<code>s</code> 中的每个字母都 <strong>恰好</strong> 出现 <strong>两次</strong> 。另给你一个下标从 <strong>0</strong> 开始、长度为 <code>26</code> 的的整数数组 <code>distance</code> 。</p>\n\n<p>字母表中的每个字母按从 <code>0</code> 到 <code>25</code> 依次编号（即，<code>'a' -&gt; 0</code>, <code>'b' -&gt; 1</code>, <code>'c' -&gt; 2</code>, ... , <code>'z' -&gt; 25</code>）。</p>\n\n<p>在一个 <strong>匀整</strong> 字符串中，第 <code>i</code> 个字母的两次出现之间的字母数量是 <code>distance[i]</code> 。如果第 <code>i</code> 个字母没有在 <code>s</code> 中出现，那么 <code>distance[i]</code> 可以 <strong>忽略</strong> 。</p>\n\n<p>如果 <code>s</code> 是一个 <strong>匀整</strong> 字符串，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abaccb\", distance = [1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n<strong>输出：</strong>true\n<strong>解释：</strong>\n- 'a' 在下标 0 和下标 2 处出现，所以满足 distance[0] = 1 。\n- 'b' 在下标 1 和下标 5 处出现，所以满足 distance[1] = 3 。\n- 'c' 在下标 3 和下标 4 处出现，所以满足 distance[2] = 0 。\n注意 distance[3] = 5 ，但是由于 'd' 没有在 s 中出现，可以忽略。\n因为 s 是一个匀整字符串，返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"aa\", distance = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n<strong>输出：</strong>false\n<strong>解释：</strong>\n- 'a' 在下标 0 和 1 处出现，所以两次出现之间的字母数量为 0 。\n但是 distance[0] = 1 ，s 不是一个匀整字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 52</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n\t<li><code>s</code> 中的每个字母恰好出现两次</li>\n\t<li><code>distance.length == 26</code></li>\n\t<li><code>0 &lt;= distance[i] &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2400.恰好移动 k 步到达某一位置的方法数目",
        "hardRate": "MEDIUM",
        "passRate": "32.66%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/solution",
        "problemsDesc": "<p>给你两个 <strong>正</strong> 整数 <code>startPos</code> 和 <code>endPos</code> 。最初，你站在 <strong>无限</strong> 数轴上位置 <code>startPos</code> 处。在一步移动中，你可以向左或者向右移动一个位置。</p>\n\n<p>给你一个正整数 <code>k</code> ，返回从 <code>startPos</code> 出发、<strong>恰好</strong> 移动 <code>k</code> 步并到达 <code>endPos</code> 的 <strong>不同</strong> 方法数目。由于答案可能会很大，返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p>如果所执行移动的顺序不完全相同，则认为两种方法不同。</p>\n\n<p><strong>注意：</strong>数轴包含负整数<strong>。</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>startPos = 1, endPos = 2, k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>存在 3 种从 1 到 2 且恰好移动 3 步的方法：\n- 1 -&gt; 2 -&gt; 3 -&gt; 2.\n- 1 -&gt; 2 -&gt; 1 -&gt; 2.\n- 1 -&gt; 0 -&gt; 1 -&gt; 2.\n可以证明不存在其他方法，所以返回 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>startPos = 2, endPos = 5, k = 10\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在从 2 到 5 且恰好移动 10 步的方法。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= startPos, endPos, k &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    }
]