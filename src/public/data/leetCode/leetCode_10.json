[
    {
        "problemsName": " 1351.统计有序矩阵中的负数",
        "hardRate": "EASY",
        "passRate": "74.24%",
        "problemsUrl": "https://leetcode.cn/problems/count-negative-numbers-in-a-sorted-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/count-negative-numbers-in-a-sorted-matrix/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m&nbsp;* n</code>&nbsp;的矩阵&nbsp;<code>grid</code>，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。&nbsp;请你统计并返回&nbsp;<code>grid</code>&nbsp;中 <strong>负数</strong> 的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]\n<strong>输出：</strong>8\n<strong>解释：</strong>矩阵中共有 8 个负数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[3,2],[1,0]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>-100 &lt;= grid[i][j] &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(n + m)</code> 的解决方案吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1352.最后 K 个数的乘积",
        "hardRate": "MEDIUM",
        "passRate": "48.35%",
        "problemsUrl": "https://leetcode.cn/problems/product-of-the-last-k-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/product-of-the-last-k-numbers/solution",
        "problemsDesc": "<p>请你实现一个「数字乘积类」<code>ProductOfNumbers</code>，要求支持下述两种方法：</p>\n\n<p>1.<code>&nbsp;add(int num)</code></p>\n\n<ul>\n\t<li>将数字&nbsp;<code>num</code>&nbsp;添加到当前数字列表的最后面。</li>\n</ul>\n\n<p>2.<code> getProduct(int k)</code></p>\n\n<ul>\n\t<li>返回当前数字列表中，最后&nbsp;<code>k</code>&nbsp;个数字的乘积。</li>\n\t<li>你可以假设当前列表中始终 <strong>至少</strong> 包含 <code>k</code> 个数字。</li>\n</ul>\n\n<p>题目数据保证：任何时候，任一连续数字序列的乘积都在 32-bit 整数范围内，不会溢出。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>\n[&quot;ProductOfNumbers&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;getProduct&quot;,&quot;getProduct&quot;,&quot;getProduct&quot;,&quot;add&quot;,&quot;getProduct&quot;]\n[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]\n\n<strong>输出：</strong>\n[null,null,null,null,null,null,20,40,0,null,32]\n\n<strong>解释：</strong>\nProductOfNumbers productOfNumbers = new ProductOfNumbers();\nproductOfNumbers.add(3);        // [3]\nproductOfNumbers.add(0);        // [3,0]\nproductOfNumbers.add(2);        // [3,0,2]\nproductOfNumbers.add(5);        // [3,0,2,5]\nproductOfNumbers.add(4);        // [3,0,2,5,4]\nproductOfNumbers.getProduct(2); // 返回 20 。最后 2 个数字的乘积是 5 * 4 = 20\nproductOfNumbers.getProduct(3); // 返回 40 。最后 3 个数字的乘积是 2 * 5 * 4 = 40\nproductOfNumbers.getProduct(4); // 返回  0 。最后 4 个数字的乘积是 0 * 2 * 5 * 4 = 0\nproductOfNumbers.add(8);        // [3,0,2,5,4,8]\nproductOfNumbers.getProduct(2); // 返回 32 。最后 2 个数字的乘积是 4 * 8 = 32 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>add</code> 和 <code>getProduct</code>&nbsp;两种操作加起来总共不会超过&nbsp;<code>40000</code>&nbsp;次。</li>\n\t<li><code>0 &lt;= num&nbsp;&lt;=&nbsp;100</code></li>\n\t<li><code>1 &lt;= k &lt;= 40000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1353.最多可以参加的会议数目",
        "hardRate": "MEDIUM",
        "passRate": "29.47%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>events</code>，其中&nbsp;<code>events[i] = [startDay<sub>i</sub>, endDay<sub>i</sub>]</code>&nbsp;，表示会议&nbsp;<code>i</code>&nbsp;开始于&nbsp;<code>startDay<sub>i</sub></code>&nbsp;，结束于&nbsp;<code>endDay<sub>i</sub></code>&nbsp;。</p>\n\n<p>你可以在满足&nbsp;<code>startDay<sub>i</sub>&nbsp;&lt;= d &lt;= endDay<sub>i</sub></code><sub>&nbsp;</sub>中的任意一天&nbsp;<code>d</code>&nbsp;参加会议&nbsp;<code>i</code>&nbsp;。注意，一天只能参加一个会议。</p>\n\n<p>请你返回你可以参加的&nbsp;<strong>最大&nbsp;</strong>会议数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/16/e1.png\" style=\"height: 267px; width: 400px;\" /></p>\n\n<pre>\n<strong>输入：</strong>events = [[1,2],[2,3],[3,4]]\n<strong>输出：</strong>3\n<strong>解释：</strong>你可以参加所有的三个会议。\n安排会议的一种方案如上图。\n第 1 天参加第一个会议。\n第 2 天参加第二个会议。\n第 3 天参加第三个会议。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>events= [[1,2],[2,3],[3,4],[1,2]]\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong>​​​​​​</p>\n\n<ul>\n\t<li><code>1 &lt;= events.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>events[i].length == 2</code></li>\n\t<li><code>1 &lt;= startDay<sub>i</sub>&nbsp;&lt;= endDay<sub>i</sub>&nbsp;&lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1354.多次求和构造目标数组",
        "hardRate": "HARD",
        "passRate": "28.96%",
        "problemsUrl": "https://leetcode.cn/problems/construct-target-array-with-multiple-sums/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-target-array-with-multiple-sums/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>target</code> 。一开始，你有一个数组&nbsp;<code>A</code> ，它的所有元素均为 1 ，你可以执行以下操作：</p>\n\n<ul>\n\t<li>令&nbsp;<code>x</code>&nbsp;为你数组里所有元素的和</li>\n\t<li>选择满足&nbsp;<code>0 &lt;= i &lt; target.size</code>&nbsp;的任意下标&nbsp;<code>i</code>&nbsp;，并让&nbsp;<code>A</code>&nbsp;数组里下标为&nbsp;<code>i</code>&nbsp;处的值为&nbsp;<code>x</code>&nbsp;。</li>\n\t<li>你可以重复该过程任意次</li>\n</ul>\n\n<p>如果能从&nbsp;<code>A</code>&nbsp;开始构造出目标数组&nbsp;<code>target</code>&nbsp;，请你返回 True ，否则返回 False 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>target = [9,3,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>从 [1, 1, 1] 开始\n[1, 1, 1], 和为 3 ，选择下标 1\n[1, 3, 1], 和为 5， 选择下标 2\n[1, 3, 5], 和为 9， 选择下标 0\n[9, 3, 5] 完成\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>target = [1,1,1,2]\n<strong>输出：</strong>false\n<strong>解释：</strong>不可能从 [1,1,1,1] 出发构造目标数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>target = [8,5]\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>N == target.length</code></li>\n\t<li><code>1 &lt;= target.length&nbsp;&lt;= 5 * 10^4</code></li>\n\t<li><code>1 &lt;= target[i] &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1355.活动参与者",
        "hardRate": "MEDIUM",
        "passRate": "66.81%",
        "problemsUrl": "https://leetcode.cn/problems/activity-participants/",
        "solutionsUrl": "https://leetcode.cn/problems/activity-participants/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1356.根据数字二进制下 1 的数目排序",
        "hardRate": "EASY",
        "passRate": "73.45%",
        "problemsUrl": "https://leetcode.cn/problems/sort-integers-by-the-number-of-1-bits/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-integers-by-the-number-of-1-bits/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code>&nbsp;。请你将数组中的元素按照其二进制表示中数字 <strong>1</strong> 的数目升序排序。</p>\n\n<p>如果存在多个数字二进制中&nbsp;<strong>1</strong>&nbsp;的数目相同，则必须将它们按照数值大小升序排列。</p>\n\n<p>请你返回排序后的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [0,1,2,3,4,5,6,7,8]\n<strong>输出：</strong>[0,1,2,4,8,3,5,6,7]\n<strong>解释：</strong>[0] 是唯一一个有 0 个 1 的数。\n[1,2,4,8] 都有 1 个 1 。\n[3,5,6] 有 2 个 1 。\n[7] 有 3 个 1 。\n按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1024,512,256,128,64,32,16,8,4,2,1]\n<strong>输出：</strong>[1,2,4,8,16,32,64,128,256,512,1024]\n<strong>解释：</strong>数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [10000,10000]\n<strong>输出：</strong>[10000,10000]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,3,5,7,11,13,17,19]\n<strong>输出：</strong>[2,3,5,17,7,11,13,19]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [10,100,1000,10000]\n<strong>输出：</strong>[10,100,10000,1000]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 500</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1357.每隔 n 个顾客打折",
        "hardRate": "MEDIUM",
        "passRate": "54.59%",
        "problemsUrl": "https://leetcode.cn/problems/apply-discount-every-n-orders/",
        "solutionsUrl": "https://leetcode.cn/problems/apply-discount-every-n-orders/solution",
        "problemsDesc": "<p>超市里正在举行打折活动，每隔&nbsp;<code>n</code>&nbsp;个顾客会得到 <code>discount</code>&nbsp;的折扣。</p>\n\n<p>超市里有一些商品，第&nbsp;<code>i</code>&nbsp;种商品为&nbsp;<code>products[i]</code>&nbsp;且每件单品的价格为&nbsp;<code>prices[i]</code>&nbsp;。</p>\n\n<p>结账系统会统计顾客的数目，每隔&nbsp;<code>n</code>&nbsp;个顾客结账时，该顾客的账单都会打折，折扣为&nbsp;<code>discount</code>&nbsp;（也就是如果原本账单为&nbsp;<code>x</code>&nbsp;，那么实际金额会变成&nbsp;<code>x - (discount * x) / 100</code>&nbsp;），然后系统会重新开始计数。</p>\n\n<p>顾客会购买一些商品，&nbsp;<code>product[i]</code>&nbsp;是顾客购买的第&nbsp;<code>i</code>&nbsp;种商品，&nbsp;<code>amount[i]</code>&nbsp;是对应的购买该种商品的数目。</p>\n\n<p>请你实现&nbsp;<code>Cashier</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>Cashier(int n, int discount, int[] products, int[] prices)</code>&nbsp;初始化实例对象，参数分别为打折频率&nbsp;<code>n</code>&nbsp;，折扣大小 <code>discount</code>&nbsp;，超市里的商品列表 <code>products</code>&nbsp;和它们的价格 <code>prices</code>&nbsp;。</li>\n\t<li><code>double&nbsp;getBill(int[] product, int[] amount)</code>&nbsp;返回账单的实际金额（如果有打折，请返回打折后的结果）。返回结果与标准答案误差在&nbsp;<code>10^-5</code>&nbsp;以内都视为正确结果。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入</strong>\n[&quot;Cashier&quot;,&quot;getBill&quot;,&quot;getBill&quot;,&quot;getBill&quot;,&quot;getBill&quot;,&quot;getBill&quot;,&quot;getBill&quot;,&quot;getBill&quot;]\n[[3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]],[[1,2],[1,2]],[[3,7],[10,10]],[[1,2,3,4,5,6,7],[1,1,1,1,1,1,1]],[[4],[10]],[[7,3],[10,10]],[[7,5,3,1,6,4,2],[10,10,10,9,9,9,7]],[[2,3,5],[5,3,2]]]\n<strong>输出</strong>\n[null,500.0,4000.0,800.0,4000.0,4000.0,7350.0,2500.0]\n<strong>解释</strong>\nCashier cashier = new Cashier(3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]);\ncashier.getBill([1,2],[1,2]);                        // 返回 500.0, 账单金额为 = 1 * 100 + 2 * 200 = 500.\ncashier.getBill([3,7],[10,10]);                      // 返回 4000.0\ncashier.getBill([1,2,3,4,5,6,7],[1,1,1,1,1,1,1]);    // 返回 800.0 ，账单原本为 1600.0 ，但由于该顾客是第三位顾客，他将得到 50% 的折扣，所以实际金额为 1600 - 1600 * (50 / 100) = 800 。\ncashier.getBill([4],[10]);                           // 返回 4000.0\ncashier.getBill([7,3],[10,10]);                      // 返回 4000.0\ncashier.getBill([7,5,3,1,6,4,2],[10,10,10,9,9,9,7]); // 返回 7350.0 ，账单原本为 14700.0 ，但由于系统计数再次达到三，该顾客将得到 50% 的折扣，实际金额为 7350.0 。\ncashier.getBill([2,3,5],[5,3,2]);                    // 返回 2500.0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^4</code></li>\n\t<li><code>0 &lt;= discount &lt;= 100</code></li>\n\t<li><code>1 &lt;= products.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= products[i] &lt;= 200</code></li>\n\t<li><code>products</code>&nbsp;列表中&nbsp;<strong>不会</strong>&nbsp;有重复的元素。</li>\n\t<li><code>prices.length == products.length</code></li>\n\t<li><code>1 &lt;= prices[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= product.length &lt;= products.length</code></li>\n\t<li><code>product[i]</code>&nbsp;在&nbsp;<code>products</code>&nbsp;出现过。</li>\n\t<li><code>amount.length == product.length</code></li>\n\t<li><code>1 &lt;= amount[i] &lt;= 1000</code></li>\n\t<li>最多有&nbsp;<code>1000</code> 次对&nbsp;<code>getBill</code>&nbsp;函数的调用。</li>\n\t<li>返回结果与标准答案误差在&nbsp;<code>10^-5</code>&nbsp;以内都视为正确结果。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1358.包含所有三种字符的子字符串数目",
        "hardRate": "MEDIUM",
        "passRate": "52.96%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code>&nbsp;，它只包含三种字符 a, b 和 c 。</p>\n\n<p>请你返回 a，b 和 c 都&nbsp;<strong>至少&nbsp;</strong>出现过一次的子字符串数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abcabc&quot;\n<strong>输出：</strong>10\n<strong>解释：</strong>包含 a，b 和 c 各至少一次的子字符串为<em> &quot;</em>abc<em>&quot;, &quot;</em>abca<em>&quot;, &quot;</em>abcab<em>&quot;, &quot;</em>abcabc<em>&quot;, &quot;</em>bca<em>&quot;, &quot;</em>bcab<em>&quot;, &quot;</em>bcabc<em>&quot;, &quot;</em>cab<em>&quot;, &quot;</em>cabc<em>&quot; </em>和<em> &quot;</em>abc<em>&quot; </em>(<strong>相同</strong><strong>字符串算多次</strong>)<em>。</em>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aaacb&quot;\n<strong>输出：</strong>3\n<strong>解释：</strong>包含 a，b 和 c 各至少一次的子字符串为<em> &quot;</em>aaacb<em>&quot;, &quot;</em>aacb<em>&quot; </em>和<em> &quot;</em>acb<em>&quot; 。</em>\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abc&quot;\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= s.length &lt;= 5 x 10^4</code></li>\n\t<li><code>s</code>&nbsp;只包含字符 a，b 和 c 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1359.有效的快递序列数目",
        "hardRate": "HARD",
        "passRate": "58.43%",
        "problemsUrl": "https://leetcode.cn/problems/count-all-valid-pickup-and-delivery-options/",
        "solutionsUrl": "https://leetcode.cn/problems/count-all-valid-pickup-and-delivery-options/solution",
        "problemsDesc": "<p>给你&nbsp;<code>n</code>&nbsp;笔订单，每笔订单都需要快递服务。</p>\n\n<p>请你统计所有有效的 收件/配送 序列的数目，确保第 <code>i</code> 个物品的配送服务&nbsp;<code>delivery(i)</code> 总是在其收件服务&nbsp;<code>pickup(i)</code> 之后。</p>\n\n<p>由于答案可能很大，请返回答案对 <code>10^9 + 7</code> 取余的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>只有一种序列 (P1, D1)，物品 1 的配送服务（D1）在物品 1 的收件服务（P1）后。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>6\n<strong>解释：</strong>所有可能的序列包括：\n(P1,P2,D1,D2)，(P1,P2,D2,D1)，(P1,D1,P2,D2)，(P2,P1,D1,D2)，(P2,P1,D2,D1) 和 (P2,D2,P1,D1)。\n(P1,D2,P2,D1) 是一个无效的序列，因为物品 2 的收件服务（P2）不应在物品 2 的配送服务（D2）之后。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 3\n<strong>输出：</strong>90\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1360.日期之间隔几天",
        "hardRate": "EASY",
        "passRate": "51.05%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-days-between-two-dates/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-days-between-two-dates/solution",
        "problemsDesc": "<p>请你编写一个程序来计算两个日期之间隔了多少天。</p>\n\n<p>日期以字符串形式给出，格式为&nbsp;<code>YYYY-MM-DD</code>，如示例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>date1 = &quot;2019-06-29&quot;, date2 = &quot;2019-06-30&quot;\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>date1 = &quot;2020-01-15&quot;, date2 = &quot;2019-12-31&quot;\n<strong>输出：</strong>15\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给定的日期是&nbsp;<code>1971</code>&nbsp;年到 <code>2100</code>&nbsp;年之间的有效日期。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1361.验证二叉树",
        "hardRate": "MEDIUM",
        "passRate": "39.89%",
        "problemsUrl": "https://leetcode.cn/problems/validate-binary-tree-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/validate-binary-tree-nodes/solution",
        "problemsDesc": "<p>二叉树上有 <code>n</code>&nbsp;个节点，按从&nbsp;<code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;编号，其中节点&nbsp;<code>i</code>&nbsp;的两个子节点分别是&nbsp;<code>leftChild[i]</code>&nbsp;和&nbsp;<code>rightChild[i]</code>。</p>\n\n<p>只有 <strong>所有</strong> 节点能够形成且 <strong>只</strong> 形成 <strong>一颗</strong>&nbsp;有效的二叉树时，返回&nbsp;<code>true</code>；否则返回 <code>false</code>。</p>\n\n<p>如果节点&nbsp;<code>i</code>&nbsp;没有左子节点，那么&nbsp;<code>leftChild[i]</code>&nbsp;就等于&nbsp;<code>-1</code>。右子节点也符合该规则。</p>\n\n<p>注意：节点没有值，本问题中仅仅使用节点编号。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/23/1503_ex1.png\" style=\"height: 287px; width: 195px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/23/1503_ex2.png\" style=\"height: 272px; width: 183px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/23/1503_ex3.png\" style=\"height: 174px; width: 82px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 2, leftChild = [1,0], rightChild = [-1,-1]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/23/1503_ex4.png\" style=\"height: 191px; width: 470px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 6, leftChild = [1,-1,-1,4,-1,-1], rightChild = [2,-1,-1,5,-1,-1]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^4</code></li>\n\t<li><code>leftChild.length == rightChild.length == n</code></li>\n\t<li><code>-1 &lt;= leftChild[i], rightChild[i] &lt;= n - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1362.最接近的因数",
        "hardRate": "MEDIUM",
        "passRate": "54.74%",
        "problemsUrl": "https://leetcode.cn/problems/closest-divisors/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-divisors/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>num</code>，请你找出同时满足下面全部要求的两个整数：</p>\n\n<ul>\n\t<li>两数乘积等于 &nbsp;<code>num + 1</code>&nbsp;或&nbsp;<code>num + 2</code></li>\n\t<li>以绝对差进行度量，两数大小最接近</li>\n</ul>\n\n<p>你可以按任意顺序返回这两个整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 8\n<strong>输出：</strong>[3,3]\n<strong>解释：</strong>对于 num + 1 = 9，最接近的两个因数是 3 &amp; 3；对于 num + 2 = 10, 最接近的两个因数是 2 &amp; 5，因此返回 3 &amp; 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 123\n<strong>输出：</strong>[5,25]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = 999\n<strong>输出：</strong>[40,25]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1363.形成三的最大倍数",
        "hardRate": "HARD",
        "passRate": "35.97%",
        "problemsUrl": "https://leetcode.cn/problems/largest-multiple-of-three/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-multiple-of-three/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>digits</code>，你可以通过按任意顺序连接其中某些数字来形成 <strong>3</strong> 的倍数，请你返回所能得到的最大的 3 的倍数。</p>\n\n<p>由于答案可能不在整数数据类型范围内，请以字符串形式返回答案。</p>\n\n<p>如果无法得到答案，请返回一个空字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>digits = [8,1,9]\n<strong>输出：</strong>&quot;981&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>digits = [8,6,7,1,0]\n<strong>输出：</strong>&quot;8760&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>digits = [1]\n<strong>输出：</strong>&quot;&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>digits = [0,0,0,0,0,0]\n<strong>输出：</strong>&quot;0&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= digits.length &lt;= 10^4</code></li>\n\t<li><code>0 &lt;= digits[i] &lt;= 9</code></li>\n\t<li>返回的结果不应包含不必要的前导零。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1364.顾客的可信联系人数量",
        "hardRate": "MEDIUM",
        "passRate": "68.34%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-trusted-contacts-of-a-customer/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-trusted-contacts-of-a-customer/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1365.有多少小于当前数字的数字",
        "hardRate": "EASY",
        "passRate": "82.37%",
        "problemsUrl": "https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/",
        "solutionsUrl": "https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>nums</code>，对于其中每个元素&nbsp;<code>nums[i]</code>，请你统计数组中比它小的所有数字的数目。</p>\n\n<p>换而言之，对于每个&nbsp;<code>nums[i]</code>&nbsp;你必须计算出有效的&nbsp;<code>j</code>&nbsp;的数量，其中 <code>j</code> 满足&nbsp;<code>j != i</code> <strong>且</strong> <code>nums[j] &lt; nums[i]</code>&nbsp;。</p>\n\n<p>以数组形式返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [8,1,2,2,3]\n<strong>输出：</strong>[4,0,1,1,3]\n<strong>解释：</strong> \n对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 \n对于 nums[1]=1 不存在比它小的数字。\n对于 nums[2]=2 存在一个比它小的数字：（1）。 \n对于 nums[3]=2 存在一个比它小的数字：（1）。 \n对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [6,5,4,8]\n<strong>输出：</strong>[2,1,0,3]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [7,7,7,7]\n<strong>输出：</strong>[0,0,0,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1366.通过投票对团队排名",
        "hardRate": "MEDIUM",
        "passRate": "51.14%",
        "problemsUrl": "https://leetcode.cn/problems/rank-teams-by-votes/",
        "solutionsUrl": "https://leetcode.cn/problems/rank-teams-by-votes/solution",
        "problemsDesc": "<p>现在有一个特殊的排名系统，依据参赛团队在投票人心中的次序进行排名，每个投票者都需要按从高到低的顺序对参与排名的所有团队进行排位。</p>\n\n<p>排名规则如下：</p>\n\n<ul>\n\t<li>参赛团队的排名次序依照其所获「排位第一」的票的多少决定。如果存在多个团队并列的情况，将继续考虑其「排位第二」的票的数量。以此类推，直到不再存在并列的情况。</li>\n\t<li>如果在考虑完所有投票情况后仍然出现并列现象，则根据团队字母的字母顺序进行排名。</li>\n</ul>\n\n<p>给你一个字符串数组&nbsp;<code>votes</code> 代表全体投票者给出的排位情况，请你根据上述排名规则对所有参赛团队进行排名。</p>\n\n<p>请你返回能表示按排名系统 <strong>排序后</strong> 的所有团队排名的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>votes = [&quot;ABC&quot;,&quot;ACB&quot;,&quot;ABC&quot;,&quot;ACB&quot;,&quot;ACB&quot;]\n<strong>输出：</strong>&quot;ACB&quot;\n<strong>解释：</strong>A 队获得五票「排位第一」，没有其他队获得「排位第一」，所以 A 队排名第一。\nB 队获得两票「排位第二」，三票「排位第三」。\nC 队获得三票「排位第二」，两票「排位第三」。\n由于 C 队「排位第二」的票数较多，所以 C 队排第二，B 队排第三。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>votes = [&quot;WXYZ&quot;,&quot;XYZW&quot;]\n<strong>输出：</strong>&quot;XWYZ&quot;\n<strong>解释：</strong>X 队在并列僵局打破后成为排名第一的团队。X 队和 W 队的「排位第一」票数一样，但是 X 队有一票「排位第二」，而 W 没有获得「排位第二」。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>votes = [&quot;ZMNAGUEDSJYLBOPHRQICWFXTVK&quot;]\n<strong>输出：</strong>&quot;ZMNAGUEDSJYLBOPHRQICWFXTVK&quot;\n<strong>解释：</strong>只有一个投票者，所以排名完全按照他的意愿。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>votes = [&quot;BCA&quot;,&quot;CAB&quot;,&quot;CBA&quot;,&quot;ABC&quot;,&quot;ACB&quot;,&quot;BAC&quot;]\n<strong>输出：</strong>&quot;ABC&quot;\n<strong>解释：</strong> \nA 队获得两票「排位第一」，两票「排位第二」，两票「排位第三」。\nB 队获得两票「排位第一」，两票「排位第二」，两票「排位第三」。\nC 队获得两票「排位第一」，两票「排位第二」，两票「排位第三」。\n完全并列，所以我们需要按照字母升序排名。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>votes = [&quot;M&quot;,&quot;M&quot;,&quot;M&quot;,&quot;M&quot;]\n<strong>输出：</strong>&quot;M&quot;\n<strong>解释：</strong>只有 M 队参赛，所以它排名第一。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= votes.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= votes[i].length &lt;= 26</code></li>\n\t<li><code>votes[i].length ==&nbsp;votes[j].length</code> for&nbsp;<code>0 &lt;= i, j &lt; votes.length</code></li>\n\t<li><code>votes[i][j]</code>&nbsp;是英文 <strong>大写</strong> 字母</li>\n\t<li><code>votes[i]</code>&nbsp;中的所有字母都是唯一的</li>\n\t<li><code>votes[0]</code>&nbsp;中出现的所有字母 <strong>同样也</strong> 出现在&nbsp;<code>votes[j]</code>&nbsp;中，其中&nbsp;<code>1 &lt;= j &lt; votes.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1367.二叉树中的链表",
        "hardRate": "MEDIUM",
        "passRate": "43.74%",
        "problemsUrl": "https://leetcode.cn/problems/linked-list-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/linked-list-in-binary-tree/solution",
        "problemsDesc": "<p>给你一棵以&nbsp;<code>root</code>&nbsp;为根的二叉树和一个&nbsp;<code>head</code>&nbsp;为第一个节点的链表。</p>\n\n<p>如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以&nbsp;<code>head</code>&nbsp;为首的链表中每个节点的值，那么请你返回 <code>True</code> ，否则返回 <code>False</code> 。</p>\n\n<p>一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/sample_1_1720.png\" style=\"height: 280px; width: 220px;\"></strong></p>\n\n<pre><strong>输入：</strong>head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n<strong>输出：</strong>true\n<strong>解释：</strong>树中蓝色的节点构成了与链表对应的子路径。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/sample_2_1720.png\" style=\"height: 280px; width: 220px;\"></strong></p>\n\n<pre><strong>输入：</strong>head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n<strong>输出：</strong>false\n<strong>解释：</strong>二叉树中不存在一一对应链表的路径。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉树和链表中的每个节点的值都满足&nbsp;<code>1 &lt;= node.val&nbsp;&lt;= 100</code>&nbsp;。</li>\n\t<li>链表包含的节点数目在&nbsp;<code>1</code>&nbsp;到&nbsp;<code>100</code>&nbsp;之间。</li>\n\t<li>二叉树包含的节点数目在&nbsp;<code>1</code>&nbsp;到&nbsp;<code>2500</code>&nbsp;之间。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1368.使网格图至少有一条有效路径的最小代价",
        "hardRate": "HARD",
        "passRate": "59.67%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/solution",
        "problemsDesc": "<p>给你一个 m x n 的网格图&nbsp;<code>grid</code>&nbsp;。&nbsp;<code>grid</code>&nbsp;中每个格子都有一个数字，对应着从该格子出发下一步走的方向。&nbsp;<code>grid[i][j]</code>&nbsp;中的数字可能为以下几种情况：</p>\n\n<ul>\n\t<li><strong>1</strong>&nbsp;，下一步往右走，也就是你会从 <code>grid[i][j]</code>&nbsp;走到 <code>grid[i][j + 1]</code></li>\n\t<li><strong>2</strong>&nbsp;，下一步往左走，也就是你会从 <code>grid[i][j]</code>&nbsp;走到 <code>grid[i][j - 1]</code></li>\n\t<li><strong>3</strong>&nbsp;，下一步往下走，也就是你会从 <code>grid[i][j]</code>&nbsp;走到 <code>grid[i + 1][j]</code></li>\n\t<li><strong>4</strong>&nbsp;，下一步往上走，也就是你会从 <code>grid[i][j]</code>&nbsp;走到 <code>grid[i - 1][j]</code></li>\n</ul>\n\n<p>注意网格图中可能会有&nbsp;<strong>无效数字</strong>&nbsp;，因为它们可能指向&nbsp;<code>grid</code>&nbsp;以外的区域。</p>\n\n<p>一开始，你会从最左上角的格子&nbsp;<code>(0,0)</code>&nbsp;出发。我们定义一条&nbsp;<strong>有效路径</strong>&nbsp;为从格子&nbsp;<code>(0,0)</code>&nbsp;出发，每一步都顺着数字对应方向走，最终在最右下角的格子&nbsp;<code>(m - 1, n - 1)</code>&nbsp;结束的路径。有效路径&nbsp;<strong>不需要是最短路径</strong>&nbsp;。</p>\n\n<p>你可以花费&nbsp;<code>cost = 1</code>&nbsp;的代价修改一个格子中的数字，但每个格子中的数字&nbsp;<strong>只能修改一次</strong>&nbsp;。</p>\n\n<p>请你返回让网格图至少有一条有效路径的最小代价。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid1.png\" style=\"height: 528px; width: 542px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]\n<strong>输出：</strong>3\n<strong>解释：</strong>你将从点 (0, 0) 出发。\n到达 (3, 3) 的路径为： (0, 0) --&gt; (0, 1) --&gt; (0, 2) --&gt; (0, 3) 花费代价 cost = 1 使方向向下 --&gt; (1, 3) --&gt; (1, 2) --&gt; (1, 1) --&gt; (1, 0) 花费代价 cost = 1 使方向向下 --&gt; (2, 0) --&gt; (2, 1) --&gt; (2, 2) --&gt; (2, 3) 花费代价 cost = 1 使方向向下 --&gt; (3, 3)\n总花费为 cost = 3.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid2.png\" style=\"height: 408px; width: 419px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[1,1,3],[3,2,2],[1,1,4]]\n<strong>输出：</strong>0\n<strong>解释：</strong>不修改任何数字你就可以从 (0, 0) 到达 (2, 2) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid3.png\" style=\"height: 302px; width: 314px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[1,2],[4,3]]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[2,2,2],[2,2,2]]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[4]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1369.获取最近第二次的活动",
        "hardRate": "HARD",
        "passRate": "61.58%",
        "problemsUrl": "https://leetcode.cn/problems/get-the-second-most-recent-activity/",
        "solutionsUrl": "https://leetcode.cn/problems/get-the-second-most-recent-activity/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1370.上升下降字符串",
        "hardRate": "EASY",
        "passRate": "78.97%",
        "problemsUrl": "https://leetcode.cn/problems/increasing-decreasing-string/",
        "solutionsUrl": "https://leetcode.cn/problems/increasing-decreasing-string/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，请你根据下面的算法重新构造字符串：</p>\n\n<ol>\n\t<li>从 <code>s</code>&nbsp;中选出 <strong>最小</strong>&nbsp;的字符，将它 <strong>接在</strong>&nbsp;结果字符串的后面。</li>\n\t<li>从 <code>s</code>&nbsp;剩余字符中选出&nbsp;<strong>最小</strong>&nbsp;的字符，且该字符比上一个添加的字符大，将它 <strong>接在</strong>&nbsp;结果字符串后面。</li>\n\t<li>重复步骤 2 ，直到你没法从 <code>s</code>&nbsp;中选择字符。</li>\n\t<li>从 <code>s</code>&nbsp;中选出 <strong>最大</strong>&nbsp;的字符，将它 <strong>接在</strong>&nbsp;结果字符串的后面。</li>\n\t<li>从 <code>s</code>&nbsp;剩余字符中选出&nbsp;<strong>最大</strong>&nbsp;的字符，且该字符比上一个添加的字符小，将它 <strong>接在</strong>&nbsp;结果字符串后面。</li>\n\t<li>重复步骤 5&nbsp;，直到你没法从 <code>s</code>&nbsp;中选择字符。</li>\n\t<li>重复步骤 1 到 6 ，直到 <code>s</code>&nbsp;中所有字符都已经被选过。</li>\n</ol>\n\n<p>在任何一步中，如果最小或者最大字符不止一个&nbsp;，你可以选择其中任意一个，并将其添加到结果字符串。</p>\n\n<p>请你返回将&nbsp;<code>s</code>&nbsp;中字符重新排序后的 <strong>结果字符串</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aaaabbbbcccc&quot;\n<strong>输出：</strong>&quot;abccbaabccba&quot;\n<strong>解释：</strong>第一轮的步骤 1，2，3 后，结果字符串为 result = &quot;abc&quot;\n第一轮的步骤 4，5，6 后，结果字符串为 result = &quot;abccba&quot;\n第一轮结束，现在 s = &quot;aabbcc&quot; ，我们再次回到步骤 1\n第二轮的步骤 1，2，3 后，结果字符串为 result = &quot;abccbaabc&quot;\n第二轮的步骤 4，5，6 后，结果字符串为 result = &quot;abccbaabccba&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;rat&quot;\n<strong>输出：</strong>&quot;art&quot;\n<strong>解释：</strong>单词 &quot;rat&quot; 在上述算法重排序以后变成 &quot;art&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;leetcode&quot;\n<strong>输出：</strong>&quot;cdelotee&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;ggggggg&quot;\n<strong>输出：</strong>&quot;ggggggg&quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;spo&quot;\n<strong>输出：</strong>&quot;ops&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1371.每个元音包含偶数次的最长子字符串",
        "hardRate": "MEDIUM",
        "passRate": "59.08%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即&nbsp;&#39;a&#39;，&#39;e&#39;，&#39;i&#39;，&#39;o&#39;，&#39;u&#39; ，在子字符串中都恰好出现了偶数次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;eleetminicoworoep&quot;\n<strong>输出：</strong>13\n<strong>解释：</strong>最长子字符串是 &quot;leetminicowor&quot; ，它包含 <strong>e，i，o</strong>&nbsp;各 2 个，以及 0 个 <strong>a</strong>，<strong>u </strong>。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;leetcodeisgreat&quot;\n<strong>输出：</strong>5\n<strong>解释：</strong>最长子字符串是 &quot;leetc&quot; ，其中包含 2 个 <strong>e</strong> 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;bcbcbc&quot;\n<strong>输出：</strong>6\n<strong>解释：</strong>这个示例中，字符串 &quot;bcbcbc&quot; 本身就是最长的，因为所有的元音 <strong>a，</strong><strong>e，</strong><strong>i，</strong><strong>o，</strong><strong>u</strong> 都出现了 0 次。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 x 10^5</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1372.二叉树中的最长交错路径",
        "hardRate": "MEDIUM",
        "passRate": "54.72%",
        "problemsUrl": "https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/solution",
        "problemsDesc": "<p>给你一棵以&nbsp;<code>root</code>&nbsp;为根的二叉树，二叉树中的交错路径定义如下：</p>\n\n<ul>\n\t<li>选择二叉树中 <strong>任意</strong>&nbsp;节点和一个方向（左或者右）。</li>\n\t<li>如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。</li>\n\t<li>改变前进方向：左变右或者右变左。</li>\n\t<li>重复第二步和第三步，直到你在树中无法继续移动。</li>\n</ul>\n\n<p>交错路径的长度定义为：<strong>访问过的节点数目 - 1</strong>（单个节点的路径长度为 0 ）。</p>\n\n<p>请你返回给定树中最长 <strong>交错路径</strong>&nbsp;的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/07/sample_1_1702.png\" style=\"height: 283px; width: 151px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>蓝色节点为树中最长交错路径（右 -&gt; 左 -&gt; 右）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/07/sample_2_1702.png\" style=\"height: 253px; width: 120px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [1,1,1,null,1,null,null,1,1,null,1]\n<strong>输出：</strong>4\n<strong>解释：</strong>蓝色节点为树中最长交错路径（左 -&gt; 右 -&gt; 左 -&gt; 右）。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>root = [1]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每棵树最多有&nbsp;<code>50000</code>&nbsp;个节点。</li>\n\t<li>每个节点的值在&nbsp;<code>[1, 100]</code> 之间。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1373.二叉搜索子树的最大键值和",
        "hardRate": "HARD",
        "passRate": "47.87%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/solution",
        "problemsDesc": "<p>给你一棵以 <code>root</code> 为根的 <strong>二叉树</strong> ，请你返回 <strong>任意</strong> 二叉搜索子树的最大键值和。</p>\n\n<p>二叉搜索树的定义如下：</p>\n\n<ul>\n\t<li>任意节点的左子树中的键值都 <strong>小于</strong> 此节点的键值。</li>\n\t<li>任意节点的右子树中的键值都 <strong>大于</strong> 此节点的键值。</li>\n\t<li>任意节点的左子树和右子树都是二叉搜索树。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/07/sample_1_1709.png\" style=\"height: 250px; width: 320px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]\n<strong>输出：</strong>20\n<strong>解释：</strong>键值为 3 的子树是和最大的二叉搜索树。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/07/sample_2_1709.png\" style=\"height: 180px; width: 134px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [4,3,null,1,2]\n<strong>输出：</strong>2\n<strong>解释：</strong>键值为 2 的单节点子树是和最大的二叉搜索树。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [-4,-2,-5]\n<strong>输出：</strong>0\n<strong>解释：</strong>所有节点键值都为负数，和最大的二叉搜索树为空。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [2,1,3]\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [5,4,8,3,null,6,3]\n<strong>输出：</strong>7\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每棵树有 <code>1</code> 到 <code>40000</code> 个节点。</li>\n\t<li>每个节点的键值在 <code>[-4 * 10^4 , 4 * 10^4]</code> 之间。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1374.生成每种字符都是奇数个的字符串",
        "hardRate": "EASY",
        "passRate": "77.65%",
        "problemsUrl": "https://leetcode.cn/problems/generate-a-string-with-characters-that-have-odd-counts/",
        "solutionsUrl": "https://leetcode.cn/problems/generate-a-string-with-characters-that-have-odd-counts/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code>，请你返回一个含<em> <code>n</code> </em>个字符的字符串，其中每种字符在该字符串中都恰好出现 <strong>奇数次</strong> <em><strong>。</strong></em></p>\n\n<p>返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 4\n<strong>输出：</strong>&quot;pppz&quot;\n<strong>解释：</strong>&quot;pppz&quot; 是一个满足题目要求的字符串，因为 &#39;p&#39; 出现 3 次，且 &#39;z&#39; 出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：&quot;ohhh&quot; 和 &quot;love&quot;。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>&quot;xy&quot;\n<strong>解释：</strong>&quot;xy&quot; 是一个满足题目要求的字符串，因为 &#39;x&#39; 和 &#39;y&#39; 各出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：&quot;ag&quot; 和 &quot;ur&quot;。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 7\n<strong>输出：</strong>&quot;holasss&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1375.二进制字符串前缀一致的次数",
        "hardRate": "MEDIUM",
        "passRate": "68.07%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-times-binary-string-is-prefix-aligned/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-times-binary-string-is-prefix-aligned/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 、下标从 <strong>1</strong> 开始的二进制字符串，所有位最开始都是 <code>0</code> 。我们会按步翻转该二进制字符串的所有位（即，将 <code>0</code> 变为 <code>1</code>）。</p>\n\n<p>给你一个下标从 <strong>1</strong> 开始的整数数组 <code>flips</code> ，其中 <code>flips[i]</code> 表示对应下标 <code>i</code> 的位将会在第 <code>i</code> 步翻转。</p>\n\n<p>二进制字符串 <strong>前缀一致</strong> 需满足：在第 <code>i</code> 步之后，在 <strong>闭</strong> 区间&nbsp;<code>[1, i]</code> 内的所有位都是 1 ，而其他位都是 0 。</p>\n\n<p>返回二进制字符串在翻转过程中 <strong>前缀一致</strong> 的次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>flips = [3,2,4,1,5]\n<strong>输出：</strong>2\n<strong>解释：</strong>二进制字符串最开始是 \"00000\" 。\n执行第 1 步：字符串变为 \"00100\" ，不属于前缀一致的情况。\n执行第 2 步：字符串变为 \"01100\" ，不属于前缀一致的情况。\n执行第 3 步：字符串变为 \"01110\" ，不属于前缀一致的情况。\n执行第 4 步：字符串变为 \"11110\" ，属于前缀一致的情况。\n执行第 5 步：字符串变为 \"11111\" ，属于前缀一致的情况。\n在翻转过程中，前缀一致的次数为 2 ，所以返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>flips = [4,1,2,3]\n<strong>输出：</strong>1\n<strong>解释：</strong>二进制字符串最开始是 \"0000\" 。\n执行第 1 步：字符串变为 \"0001\" ，不属于前缀一致的情况。\n执行第 2 步：字符串变为 \"1001\" ，不属于前缀一致的情况。\n执行第 3 步：字符串变为 \"1101\" ，不属于前缀一致的情况。\n执行第 4 步：字符串变为 \"1111\" ，属于前缀一致的情况。\n在翻转过程中，前缀一致的次数为 1 ，所以返回 1 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == flips.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>flips</code> 是范围 <code>[1, n]</code> 中所有整数构成的一个排列</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1376.通知所有员工所需的时间",
        "hardRate": "MEDIUM",
        "passRate": "60.16%",
        "problemsUrl": "https://leetcode.cn/problems/time-needed-to-inform-all-employees/",
        "solutionsUrl": "https://leetcode.cn/problems/time-needed-to-inform-all-employees/solution",
        "problemsDesc": "<p>公司里有 <code>n</code> 名员工，每个员工的 ID 都是独一无二的，编号从 <code>0</code> 到 <code>n - 1</code>。公司的总负责人通过 <code>headID</code> 进行标识。</p>\n\n<p>在 <code>manager</code> 数组中，每个员工都有一个直属负责人，其中 <code>manager[i]</code> 是第 <code>i</code> 名员工的直属负责人。对于总负责人，<code>manager[headID] = -1</code>。题目保证从属关系可以用树结构显示。</p>\n\n<p>公司总负责人想要向公司所有员工通告一条紧急消息。他将会首先通知他的直属下属们，然后由这些下属通知他们的下属，直到所有的员工都得知这条紧急消息。</p>\n\n<p>第 <code>i</code> 名员工需要 <code>informTime[i]</code> 分钟来通知它的所有直属下属（也就是说在 <code>informTime[i]</code> 分钟后，他的所有直属下属都可以开始传播这一消息）。</p>\n\n<p>返回通知所有员工这一紧急消息所需要的 <strong>分钟数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, headID = 0, manager = [-1], informTime = [0]\n<strong>输出：</strong>0\n<strong>解释：</strong>公司总负责人是该公司的唯一一名员工。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/08/graph.png\" style=\"height: 174px; width: 404px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]\n<strong>输出：</strong>1\n<strong>解释：</strong>id = 2 的员工是公司的总负责人，也是其他所有员工的直属负责人，他需要 1 分钟来通知所有员工。\n上图显示了公司员工的树结构。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= headID &lt; n</code></li>\n\t<li><code>manager.length == n</code></li>\n\t<li><code>0 &lt;= manager[i] &lt; n</code></li>\n\t<li><code>manager[headID] == -1</code></li>\n\t<li><code>informTime.length&nbsp;== n</code></li>\n\t<li><code>0 &lt;= informTime[i] &lt;= 1000</code></li>\n\t<li>如果员工 <code>i</code> 没有下属，<code>informTime[i] == 0</code> 。</li>\n\t<li>题目 <strong>保证</strong> 所有员工都可以收到通知。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1377.T 秒后青蛙的位置",
        "hardRate": "HARD",
        "passRate": "42.68%",
        "problemsUrl": "https://leetcode.cn/problems/frog-position-after-t-seconds/",
        "solutionsUrl": "https://leetcode.cn/problems/frog-position-after-t-seconds/solution",
        "problemsDesc": "<p>给你一棵由 <code>n</code> 个顶点组成的无向树，顶点编号从 <code>1</code> 到 <code>n</code>。青蛙从 <strong>顶点 1</strong> 开始起跳。规则如下：</p>\n\n<ul>\n\t<li>在一秒内，青蛙从它所在的当前顶点跳到另一个 <strong>未访问</strong> 过的顶点（如果它们直接相连）。</li>\n\t<li>青蛙无法跳回已经访问过的顶点。</li>\n\t<li>如果青蛙可以跳到多个不同顶点，那么它跳到其中任意一个顶点上的机率都相同。</li>\n\t<li>如果青蛙不能跳到任何未访问过的顶点上，那么它每次跳跃都会停留在原地。</li>\n</ul>\n\n<p>无向树的边用数组 <code>edges</code> 描述，其中 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 意味着存在一条直接连通 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 两个顶点的边。</p>\n\n<p>返回青蛙在 <em><code>t</code></em> 秒后位于目标顶点 <em><code>target</code> </em>上的概率。与实际答案相差不超过 <code>10<sup>-5</sup></code> 的结果将被视为正确答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/12/21/frog1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4\n<strong>输出：</strong>0.16666666666666666 \n<strong>解释：</strong>上图显示了青蛙的跳跃路径。青蛙从顶点 1 起跳，第 <strong>1 秒</strong> 有 1/3 的概率跳到顶点 2 ，然后第 <strong>2 秒</strong> 有 1/2 的概率跳到顶点 4，因此青蛙在 2 秒后位于顶点 4 的概率是 1/3 * 1/2 = 1/6 = 0.16666666666666666 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/12/21/frog2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7\n<strong>输出：</strong>0.3333333333333333\n<strong>解释：</strong>上图显示了青蛙的跳跃路径。青蛙从顶点 1 起跳，有 1/3 = 0.3333333333333333 的概率能够 <strong>1 秒</strong> 后跳到顶点 7 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub>&nbsp;&lt;= n</code></li>\n\t<li><code>1 &lt;= t &lt;= 50</code></li>\n\t<li><code>1 &lt;= target &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1378.使用唯一标识码替换员工ID",
        "hardRate": "EASY",
        "passRate": "85.29%",
        "problemsUrl": "https://leetcode.cn/problems/replace-employee-id-with-the-unique-identifier/",
        "solutionsUrl": "https://leetcode.cn/problems/replace-employee-id-with-the-unique-identifier/solution",
        "problemsDesc": "<p><code>Employees</code> 表：</p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| name          | varchar |\n+---------------+---------+\nid 是这张表的主键。\n这张表的每一行分别代表了某公司其中一位员工的名字和 ID 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><code>EmployeeUNI</code>&nbsp;表：</p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| unique_id     | int     |\n+---------------+---------+\n(id, unique_id) 是这张表的主键。\n这张表的每一行包含了该公司某位员工的 ID 和他的唯一标识码（unique ID）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一段SQL查询来展示每位用户的<strong> 唯一标识码（unique ID ）</strong>；如果某位员工没有唯一标识码，使用 null 填充即可。</p>\n\n<p>你可以以<strong> 任意</strong> 顺序返回结果表。</p>\n\n<p>查询结果的格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<code><strong>输入：</strong>\nEmployees</code> 表:\n+----+----------+\n| id | name     |\n+----+----------+\n| 1  | Alice    |\n| 7  | Bob      |\n| 11 | Meir     |\n| 90 | Winston  |\n| 3  | Jonathan |\n+----+----------+\n<code>EmployeeUNI</code> 表:\n+----+-----------+\n| id | unique_id |\n+----+-----------+\n| 3  | 1         |\n| 11 | 2         |\n| 90 | 3         |\n+----+-----------+\n<strong>输出：</strong>\n+-----------+----------+\n| unique_id | name     |\n+-----------+----------+\n| null      | Alice    |\n| null      | Bob      |\n| 2         | Meir     |\n| 3         | Winston  |\n| 1         | Jonathan |\n+-----------+----------+\n<strong>解释：</strong>\nAlice and Bob 没有唯一标识码, 因此我们使用 null 替代。\nMeir 的唯一标识码是 2 。\nWinston 的唯一标识码是 3 。\nJonathan 唯一标识码是 1 。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1379.找出克隆二叉树中的相同节点",
        "hardRate": "EASY",
        "passRate": "83.25%",
        "problemsUrl": "https://leetcode.cn/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/solution",
        "problemsDesc": "<p>给你两棵二叉树，原始树 <code>original</code> 和克隆树 <code>cloned</code>，以及一个位于原始树 <code>original</code>&nbsp;中的目标节点&nbsp;<code>target</code>。</p>\n\n<p>其中，克隆树 <code>cloned</code>&nbsp;是原始树 <code>original</code>&nbsp;的一个<strong> 副本 </strong>。</p>\n\n<p>请找出在树&nbsp;<code>cloned</code>&nbsp;中，与&nbsp;<code>target</code>&nbsp;<strong>相同&nbsp;</strong>的节点，并返回对该节点的引用（在 C/C++ 等有指针的语言中返回 节点指针，其他语言返回节点本身）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>你 <strong>不能</strong> 对两棵二叉树，以及 <code>target</code>&nbsp;节点进行更改。<strong>只能</strong> 返回对克隆树&nbsp;<code>cloned</code>&nbsp;中已有的节点的引用。</p>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/21/e1.png\" /></p>\n\n<pre>\n<strong>输入:</strong> tree = [7,4,3,null,null,6,19], target = 3\n<strong>输出:</strong> 3\n<strong>解释:</strong> 上图画出了树 original 和 cloned。target 节点在树 original 中，用绿色标记。答案是树 cloned 中的黄颜色的节点（其他示例类似）。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/21/e2.png\" /></p>\n\n<pre>\n<strong>输入:</strong> tree = [7], target =  7\n<strong>输出:</strong> 7\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/21/e3.png\" /></p>\n\n<pre>\n<strong>输入:</strong> tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4\n<strong>输出:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数量范围为<meta charset=\"UTF-8\" />&nbsp;<code>[1, 10<sup>4</sup>]</code>&nbsp;。</li>\n\t<li>同一棵树中，没有值相同的节点。</li>\n\t<li><code>target</code>&nbsp;节点是树&nbsp;<code>original</code>&nbsp;中的一个节点，并且不会是&nbsp;<code>null</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>如果树中允许出现值相同的节点，将如何解答？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1380.矩阵中的幸运数",
        "hardRate": "EASY",
        "passRate": "76.34%",
        "problemsUrl": "https://leetcode.cn/problems/lucky-numbers-in-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/lucky-numbers-in-a-matrix/solution",
        "problemsDesc": "<p>给你一个 <code>m * n</code> 的矩阵，矩阵中的数字 <strong>各不相同</strong> 。请你按 <strong>任意</strong> 顺序返回矩阵中的所有幸运数。</p>\n\n<p><strong>幸运数</strong> 是指矩阵中满足同时下列两个条件的元素：</p>\n\n<ul>\n\t<li>在同一行的所有元素中最小</li>\n\t<li>在同一列的所有元素中最大</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[3,7,8],[9,11,13],[15,16,17]]\n<strong>输出：</strong>[15]\n<strong>解释：</strong>15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]\n<strong>输出：</strong>[12]\n<strong>解释：</strong>12 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[7,8],[1,2]]\n<strong>输出：</strong>[7]\n<strong>解释：</strong>7是唯一的幸运数字，因为它是行中的最小值，列中的最大值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 50</code></li>\n\t<li><code>1 &lt;=&nbsp;matrix[i][j]&nbsp;&lt;= 10^5</code></li>\n\t<li>矩阵中的所有元素都是不同的</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1381.设计一个支持增量操作的栈",
        "hardRate": "MEDIUM",
        "passRate": "72.42%",
        "problemsUrl": "https://leetcode.cn/problems/design-a-stack-with-increment-operation/",
        "solutionsUrl": "https://leetcode.cn/problems/design-a-stack-with-increment-operation/solution",
        "problemsDesc": "<p>请你设计一个支持对其元素进行增量操作的栈。</p>\n\n<p>实现自定义栈类 <code>CustomStack</code> ：</p>\n\n<ul>\n\t<li><code>CustomStack(int maxSize)</code>：用 <code>maxSize</code> 初始化对象，<code>maxSize</code> 是栈中最多能容纳的元素数量。</li>\n\t<li><code>void push(int x)</code>：如果栈还未增长到 <code>maxSize</code> ，就将 <code>x</code> 添加到栈顶。</li>\n\t<li><code>int pop()</code>：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 <strong>-1</strong> 。</li>\n\t<li><code>void inc(int k, int val)</code>：栈底的 <code>k</code> 个元素的值都增加 <code>val</code> 。如果栈中元素总数小于 <code>k</code> ，则栈中的所有元素都增加 <code>val</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n<strong>输出：</strong>\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n<strong>解释：</strong>\nCustomStack stk = new CustomStack(3); // 栈是空的 []\nstk.push(1);                          // 栈变为 [1]\nstk.push(2);                          // 栈变为 [1, 2]\nstk.pop();                            // 返回 2 --&gt; 返回栈顶值 2，栈变为 [1]\nstk.push(2);                          // 栈变为 [1, 2]\nstk.push(3);                          // 栈变为 [1, 2, 3]\nstk.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\nstk.increment(5, 100);                // 栈变为 [101, 102, 103]\nstk.increment(2, 100);                // 栈变为 [201, 202, 103]\nstk.pop();                            // 返回 103 --&gt; 返回栈顶值 103，栈变为 [201, 202]\nstk.pop();                            // 返回 202 --&gt; 返回栈顶值 202，栈变为 [201]\nstk.pop();                            // 返回 201 --&gt; 返回栈顶值 201，栈变为 []\nstk.pop();                            // 返回 -1 --&gt; 栈为空，返回 -1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= maxSize, x, k &lt;= 1000</code></li>\n\t<li><code>0 &lt;= val &lt;= 100</code></li>\n\t<li>每种方法 <code>increment</code>，<code>push</code> 以及 <code>pop</code> 分别最多调用 <code>1000</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1382.将二叉搜索树变平衡",
        "hardRate": "MEDIUM",
        "passRate": "73.67%",
        "problemsUrl": "https://leetcode.cn/problems/balance-a-binary-search-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/balance-a-binary-search-tree/solution",
        "problemsDesc": "<p>给你一棵二叉搜索树，请你返回一棵&nbsp;<strong>平衡后</strong>&nbsp;的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。</p>\n\n<p>如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 <code>1</code> ，我们就称这棵二叉搜索树是&nbsp;<strong>平衡的</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/10/balance1-tree.jpg\" style=\"height: 319px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,null,2,null,3,null,4,null,null]\n<strong>输出：</strong>[2,1,3,null,null,null,4]\n<strong>解释：</strong>这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/10/balanced2-tree.jpg\" style=\"height: 145px; width: 224px;\" /></p>\n\n<pre>\n<strong>输入:</strong> root = [2,1,3]\n<strong>输出:</strong> [2,1,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树节点的数目在&nbsp;<code>[1, 10<sup>4</sup>]</code>&nbsp;范围内。</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1383.最大的团队表现值",
        "hardRate": "HARD",
        "passRate": "35.34%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-performance-of-a-team/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-performance-of-a-team/solution",
        "problemsDesc": "<p>公司有编号为 <code>1</code>&nbsp;到 <code>n</code>&nbsp;的 <code>n</code>&nbsp;个工程师，给你两个数组 <code>speed</code>&nbsp;和 <code>efficiency</code>&nbsp;，其中 <code>speed[i]</code>&nbsp;和 <code>efficiency[i]</code>&nbsp;分别代表第 <code>i</code>&nbsp;位工程师的速度和效率。请你返回由最多&nbsp;<code>k</code>&nbsp;个工程师组成的&nbsp;<strong>​​​​​​最大团队表现值</strong>&nbsp;，由于答案可能很大，请你返回结果对 <code>10^9 + 7</code> 取余后的结果。</p>\n\n<p><strong>团队表现值</strong>&nbsp;的定义为：一个团队中「所有工程师速度的和」乘以他们「效率值中的最小值」。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2\n<strong>输出：</strong>60\n<strong>解释：</strong>\n我们选择工程师 2（speed=10 且 efficiency=4）和工程师 5（speed=5 且 efficiency=7）。他们的团队表现值为 performance = (10 + 5) * min(4, 7) = 60 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3\n<strong>输出：</strong>68\n<strong>解释：\n</strong>此示例与第一个示例相同，除了 k = 3 。我们可以选择工程师 1 ，工程师 2 和工程师 5 得到最大的团队表现值。表现值为 performance = (2 + 10 + 5) * min(5, 4, 7) = 68 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4\n<strong>输出：</strong>72\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>speed.length == n</code></li>\n\t<li><code>efficiency.length == n</code></li>\n\t<li><code>1 &lt;= speed[i] &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= efficiency[i] &lt;= 10^8</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1384.按年度列出销售总额",
        "hardRate": "HARD",
        "passRate": "57.67%",
        "problemsUrl": "https://leetcode.cn/problems/total-sales-amount-by-year/",
        "solutionsUrl": "https://leetcode.cn/problems/total-sales-amount-by-year/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1385.两个数组间的距离值",
        "hardRate": "EASY",
        "passRate": "64.08%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-distance-value-between-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-distance-value-between-two-arrays/solution",
        "problemsDesc": "<p>给你两个整数数组&nbsp;<code>arr1</code>&nbsp;，&nbsp;<code>arr2</code>&nbsp;和一个整数&nbsp;<code>d</code>&nbsp;，请你返回两个数组之间的&nbsp;<strong>距离值</strong>&nbsp;。</p>\n\n<p>「<strong>距离值</strong>」<strong>&nbsp;</strong>定义为符合此距离要求的元素数目：对于元素&nbsp;<code>arr1[i]</code>&nbsp;，不存在任何元素&nbsp;<code>arr2[j]</code>&nbsp;满足 <code>|arr1[i]-arr2[j]| &lt;= d</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>\n对于 arr1[0]=4 我们有：\n|4-10|=6 &gt; d=2 \n|4-9|=5 &gt; d=2 \n|4-1|=3 &gt; d=2 \n|4-8|=4 &gt; d=2 \n所以 arr1[0]=4 符合距离要求\n\n对于 arr1[1]=5 我们有：\n|5-10|=5 &gt; d=2 \n|5-9|=4 &gt; d=2 \n|5-1|=4 &gt; d=2 \n|5-8|=3 &gt; d=2\n所以 arr1[1]=5 也符合距离要求\n\n对于 arr1[2]=8 我们有：\n<strong>|8-10|=2 &lt;= d=2</strong>\n<strong>|8-9|=1 &lt;= d=2</strong>\n|8-1|=7 &gt; d=2\n<strong>|8-8|=0 &lt;= d=2</strong>\n存在距离小于等于 2 的情况，不符合距离要求 \n\n故而只有 arr1[0]=4 和 arr1[1]=5 两个符合距离要求，距离值为 2</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr1.length, arr2.length &lt;= 500</code></li>\n\t<li><code>-10^3 &lt;= arr1[i], arr2[j] &lt;= 10^3</code></li>\n\t<li><code>0 &lt;= d &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1386.安排电影院座位",
        "hardRate": "MEDIUM",
        "passRate": "35.53%",
        "problemsUrl": "https://leetcode.cn/problems/cinema-seat-allocation/",
        "solutionsUrl": "https://leetcode.cn/problems/cinema-seat-allocation/solution",
        "problemsDesc": "<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/cinema_seats_1.png\" style=\"height: 149px; width: 400px;\"></p>\n\n<p>如上图所示，电影院的观影厅中有 <code>n</code>&nbsp;行座位，行编号从 1&nbsp;到 <code>n</code>&nbsp;，且每一行内总共有 10 个座位，列编号从 1 到 10 。</p>\n\n<p>给你数组&nbsp;<code>reservedSeats</code>&nbsp;，包含所有已经被预约了的座位。比如说，<code>researvedSeats[i]=[3,8]</code>&nbsp;，它表示第&nbsp;<strong>3</strong>&nbsp;行第&nbsp;<strong>8</strong>&nbsp;个座位被预约了。</p>\n\n<p>请你返回&nbsp;<strong>最多能安排多少个 4 人家庭</strong>&nbsp;。4 人家庭要占据&nbsp;<strong>同一行内连续&nbsp;</strong>的 4 个座位。隔着过道的座位（比方说 [3,3] 和 [3,4]）不是连续的座位，但是如果你可以将 4 人家庭拆成过道两边各坐 2 人，这样子是允许的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/cinema_seats_3.png\" style=\"height: 96px; width: 400px;\"></p>\n\n<pre><strong>输入：</strong>n = 3, reservedSeats = [[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]]\n<strong>输出：</strong>4\n<strong>解释：</strong>上图所示是最优的安排方案，总共可以安排 4 个家庭。蓝色的叉表示被预约的座位，橙色的连续座位表示一个 4 人家庭。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, reservedSeats = [[2,1],[1,8],[2,6]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 4, reservedSeats = [[4,3],[1,4],[4,6],[1,7]]\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^9</code></li>\n\t<li><code>1 &lt;=&nbsp;reservedSeats.length &lt;= min(10*n, 10^4)</code></li>\n\t<li><code>reservedSeats[i].length == 2</code></li>\n\t<li><code>1&nbsp;&lt;=&nbsp;reservedSeats[i][0] &lt;= n</code></li>\n\t<li><code>1 &lt;=&nbsp;reservedSeats[i][1] &lt;= 10</code></li>\n\t<li>所有&nbsp;<code>reservedSeats[i]</code> 都是互不相同的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1387.将整数按权重排序",
        "hardRate": "MEDIUM",
        "passRate": "69.48%",
        "problemsUrl": "https://leetcode.cn/problems/sort-integers-by-the-power-value/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-integers-by-the-power-value/solution",
        "problemsDesc": "<p>我们将整数 <code>x</code>&nbsp;的 <strong>权重</strong> 定义为按照下述规则将 <code>x</code>&nbsp;变成 <code>1</code>&nbsp;所需要的步数：</p>\n\n<ul>\n\t<li>如果&nbsp;<code>x</code>&nbsp;是偶数，那么&nbsp;<code>x = x / 2</code></li>\n\t<li>如果&nbsp;<code>x</code>&nbsp;是奇数，那么&nbsp;<code>x = 3 * x + 1</code></li>\n</ul>\n\n<p>比方说，x=3 的权重为 7 。因为 3 需要 7 步变成 1 （3 --&gt; 10 --&gt; 5 --&gt; 16 --&gt; 8 --&gt; 4 --&gt; 2 --&gt; 1）。</p>\n\n<p>给你三个整数&nbsp;<code>lo</code>，&nbsp;<code>hi</code> 和&nbsp;<code>k</code>&nbsp;。你的任务是将区间&nbsp;<code>[lo, hi]</code>&nbsp;之间的整数按照它们的权重&nbsp;<strong>升序排序&nbsp;</strong>，如果大于等于 2 个整数有&nbsp;<strong>相同</strong>&nbsp;的权重，那么按照数字自身的数值&nbsp;<strong>升序排序</strong>&nbsp;。</p>\n\n<p>请你返回区间&nbsp;<code>[lo, hi]</code>&nbsp;之间的整数按权重排序后的第&nbsp;<code>k</code>&nbsp;个数。</p>\n\n<p>注意，题目保证对于任意整数&nbsp;<code>x</code>&nbsp;<code>（lo &lt;= x &lt;= hi）</code>&nbsp;，它变成&nbsp;<code>1</code> 所需要的步数是一个 32 位有符号整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>lo = 12, hi = 15, k = 2\n<strong>输出：</strong>13\n<strong>解释：</strong>12 的权重为 9（12 --&gt; 6 --&gt; 3 --&gt; 10 --&gt; 5 --&gt; 16 --&gt; 8 --&gt; 4 --&gt; 2 --&gt; 1）\n13 的权重为 9\n14 的权重为 17\n15 的权重为 17\n区间内的数按权重排序以后的结果为 [12,13,14,15] 。对于 k = 2 ，答案是第二个整数也就是 13 。\n注意，12 和 13 有相同的权重，所以我们按照它们本身升序排序。14 和 15 同理。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>lo = 7, hi = 11, k = 4\n<strong>输出：</strong>7\n<strong>解释：</strong>区间内整数 [7, 8, 9, 10, 11] 对应的权重为 [16, 3, 19, 6, 14] 。\n按权重排序后得到的结果为 [8, 10, 11, 7, 9] 。\n排序后数组中第 4 个数字为 7 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= lo &lt;= hi &lt;= 1000</code></li>\n\t<li><code>1 &lt;= k &lt;= hi - lo + 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1388.3n 块披萨",
        "hardRate": "HARD",
        "passRate": "56.54%",
        "problemsUrl": "https://leetcode.cn/problems/pizza-with-3n-slices/",
        "solutionsUrl": "https://leetcode.cn/problems/pizza-with-3n-slices/solution",
        "problemsDesc": "<p>给你一个披萨，它由 3n 块不同大小的部分组成，现在你和你的朋友们需要按照如下规则来分披萨：</p>\n\n<ul>\n\t<li>你挑选 <strong>任意</strong>&nbsp;一块披萨。</li>\n\t<li>Alice 将会挑选你所选择的披萨逆时针方向的下一块披萨。</li>\n\t<li>Bob 将会挑选你所选择的披萨顺时针方向的下一块披萨。</li>\n\t<li>重复上述过程直到没有披萨剩下。</li>\n</ul>\n\n<p>每一块披萨的大小按顺时针方向由循环数组 <code>slices</code>&nbsp;表示。</p>\n\n<p>请你返回你可以获得的披萨大小总和的最大值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/sample_3_1723.png\" style=\"height: 240px; width: 475px;\" /></p>\n\n<pre>\n<strong>输入：</strong>slices = [1,2,3,4,5,6]\n<strong>输出：</strong>10\n<strong>解释：</strong>选择大小为 4 的披萨，Alice 和 Bob 分别挑选大小为 3 和 5 的披萨。然后你选择大小为 6 的披萨，Alice 和 Bob 分别挑选大小为 2 和 1 的披萨。你获得的披萨总大小为 4 + 6 = 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/sample_4_1723.png\" style=\"height: 250px; width: 475px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>slices = [8,9,8,6,1,1]\n<strong>输出：</strong>16\n<strong>解释：</strong>两轮都选大小为 8 的披萨。如果你选择大小为 9 的披萨，你的朋友们就会选择大小为 8 的披萨，这种情况下你的总和不是最大的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= slices.length &lt;= 500</code></li>\n\t<li><code>slices.length % 3 == 0</code></li>\n\t<li><code>1 &lt;= slices[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1389.按既定顺序创建目标数组",
        "hardRate": "EASY",
        "passRate": "82.98%",
        "problemsUrl": "https://leetcode.cn/problems/create-target-array-in-the-given-order/",
        "solutionsUrl": "https://leetcode.cn/problems/create-target-array-in-the-given-order/solution",
        "problemsDesc": "<p>给你两个整数数组 <code>nums</code> 和 <code>index</code>。你需要按照以下规则创建目标数组：</p>\n\n<ul>\n\t<li>目标数组 <code>target</code> 最初为空。</li>\n\t<li>按从左到右的顺序依次读取 <code>nums[i]</code> 和 <code>index[i]</code>，在 <code>target</code> 数组中的下标 <code>index[i]</code> 处插入值 <code>nums[i]</code> 。</li>\n\t<li>重复上一步，直到在 <code>nums</code> 和 <code>index</code> 中都没有要读取的元素。</li>\n</ul>\n\n<p>请你返回目标数组。</p>\n\n<p>题目保证数字插入位置总是存在。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,2,3,4], index = [0,1,2,2,1]\n<strong>输出：</strong>[0,4,1,3,2]\n<strong>解释：</strong>\nnums       index     target\n0            0        [0]\n1            1        [0,1]\n2            2        [0,1,2]\n3            2        [0,1,3,2]\n4            1        [0,4,1,3,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,0], index = [0,1,2,3,0]\n<strong>输出：</strong>[0,1,2,3,4]\n<strong>解释：</strong>\nnums       index     target\n1            0        [1]\n2            1        [1,2]\n3            2        [1,2,3]\n4            3        [1,2,3,4]\n0            0        [0,1,2,3,4]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1], index = [0]\n<strong>输出：</strong>[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, index.length &lt;= 100</code></li>\n\t<li><code>nums.length == index.length</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>0 &lt;= index[i] &lt;= i</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1390.四因数",
        "hardRate": "MEDIUM",
        "passRate": "38.92%",
        "problemsUrl": "https://leetcode.cn/problems/four-divisors/",
        "solutionsUrl": "https://leetcode.cn/problems/four-divisors/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>，请你返回该数组中恰有四个因数的这些整数的各因数之和。如果数组中不存在满足题意的整数，则返回 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [21,4,7]\n<strong>输出：</strong>32\n<strong>解释：</strong>\n21 有 4 个因数：1, 3, 7, 21\n4 有 3 个因数：1, 2, 4\n7 有 2 个因数：1, 7\n答案仅为 21 的所有因数的和。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [21,21]\n<strong>输出:</strong> 64\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,3,4,5]\n<strong>输出:</strong> 0</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1391.检查网格中是否存在有效路径",
        "hardRate": "MEDIUM",
        "passRate": "42.00%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-there-is-a-valid-path-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-there-is-a-valid-path-in-a-grid/solution",
        "problemsDesc": "<p>给你一个 <em>m</em> x <em>n</em> 的网格 <code>grid</code>。网格里的每个单元都代表一条街道。<code>grid[i][j]</code> 的街道可以是：</p>\n\n<ul>\n\t<li><strong>1</strong> 表示连接左单元格和右单元格的街道。</li>\n\t<li><strong>2</strong> 表示连接上单元格和下单元格的街道。</li>\n\t<li><strong>3</strong>&nbsp;表示连接左单元格和下单元格的街道。</li>\n\t<li><strong>4</strong> 表示连接右单元格和下单元格的街道。</li>\n\t<li><strong>5</strong> 表示连接左单元格和上单元格的街道。</li>\n\t<li><strong>6</strong> 表示连接右单元格和上单元格的街道。</li>\n</ul>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/main.png\" style=\"height: 708px; width: 450px;\"></p>\n\n<p>你最开始从左上角的单元格 <code>(0,0)</code> 开始出发，网格中的「有效路径」是指从左上方的单元格 <code>(0,0)</code> 开始、一直到右下方的 <code>(m-1,n-1)</code> 结束的路径。<strong>该路径必须只沿着街道走</strong>。</p>\n\n<p><strong>注意：</strong>你 <strong>不能</strong> 变更街道。</p>\n\n<p>如果网格中存在有效的路径，则返回 <code>true</code>，否则返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/e1.png\" style=\"height: 311px; width: 455px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[2,4,3],[6,5,2]]\n<strong>输出：</strong>true\n<strong>解释：</strong>如图所示，你可以从 (0, 0) 开始，访问网格中的所有单元格并到达 (m - 1, n - 1) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/e2.png\" style=\"height: 293px; width: 455px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[1,2,1],[1,2,1]]\n<strong>输出：</strong>false\n<strong>解释：</strong>如图所示，单元格 (0, 0) 上的街道没有与任何其他单元格上的街道相连，你只会停在 (0, 0) 处。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[1,1,2]]\n<strong>输出：</strong>false\n<strong>解释：</strong>你会停在 (0, 1)，而且无法到达 (0, 2) 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[1,1,1,1,1,1,3]]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[2],[2],[2],[2],[2],[2],[6]]\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1392.最长快乐前缀",
        "hardRate": "HARD",
        "passRate": "44.56%",
        "problemsUrl": "https://leetcode.cn/problems/longest-happy-prefix/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-happy-prefix/solution",
        "problemsDesc": "<p><strong>「快乐前缀」</strong>&nbsp;是在原字符串中既是&nbsp;<strong>非空</strong> 前缀也是后缀（不包括原字符串自身）的字符串。</p>\n\n<p>给你一个字符串 <code>s</code>，请你返回它的 <strong>最长快乐前缀</strong>。如果不存在满足题意的前缀，则返回一个空字符串<meta charset=\"UTF-8\" />&nbsp;<code>\"\"</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"level\"\n<strong>输出：</strong>\"l\"\n<strong>解释：</strong>不包括 s 自己，一共有 4 个前缀（\"l\", \"le\", \"lev\", \"leve\"）和 4 个后缀（\"l\", \"el\", \"vel\", \"evel\"）。最长的既是前缀也是后缀的字符串是 \"l\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ababab\"\n<strong>输出：</strong>\"abab\"\n<strong>解释：</strong>\"abab\" 是最长的既是前缀也是后缀的字符串。题目允许前后缀在原字符串中重叠。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 只含有小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1393.股票的资本损益",
        "hardRate": "MEDIUM",
        "passRate": "83.80%",
        "problemsUrl": "https://leetcode.cn/problems/capital-gainloss/",
        "solutionsUrl": "https://leetcode.cn/problems/capital-gainloss/solution",
        "problemsDesc": "<p><code>Stocks</code>&nbsp;表：</p>\n\n<pre>+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| stock_name    | varchar |\n| operation     | enum    |\n| operation_day | int     |\n| price         | int     |\n+---------------+---------+\n(stock_name, day) 是这张表的主键\noperation 列使用的是一种枚举类型，包括：(&#39;Sell&#39;,&#39;Buy&#39;)\n此表的每一行代表了名为 stock_name 的某支股票在 operation_day 这一天的操作价格。\n保证股票的每次&#39;Sell&#39;操作前，都有相应的&#39;Buy&#39;操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个SQL查询来报告每支股票的资本损益。</p>\n\n<p>股票的资本损益是一次或多次买卖股票后的全部收益或损失。</p>\n\n<p>以任意顺序返回结果即可。</p>\n\n<p>SQL查询结果的格式如下例所示：</p>\n\n<pre><code>Stocks</code> 表:\n+---------------+-----------+---------------+--------+\n| stock_name    | operation | operation_day | price  |\n+---------------+-----------+---------------+--------+\n| Leetcode      | Buy       | 1             | 1000   |\n| Corona Masks  | Buy       | 2             | 10     |\n| Leetcode      | Sell      | 5             | 9000   |\n| Handbags      | Buy       | 17            | 30000  |\n| Corona Masks  | Sell      | 3             | 1010   |\n| Corona Masks  | Buy       | 4             | 1000   |\n| Corona Masks  | Sell      | 5             | 500    |\n| Corona Masks  | Buy       | 6             | 1000   |\n| Handbags      | Sell      | 29            | 7000   |\n| Corona Masks  | Sell      | 10            | 10000  |\n+---------------+-----------+---------------+--------+\n\nResult 表:\n+---------------+-------------------+\n| stock_name    | capital_gain_loss |\n+---------------+-------------------+\n| Corona Masks  | 9500              |\n| Leetcode      | 8000              |\n| Handbags      | -23000            |\n+---------------+-------------------+\nLeetcode 股票在第一天以1000美元的价格买入，在第五天以9000美元的价格卖出。资本收益=9000-1000=8000美元。\nHandbags 股票在第17天以30000美元的价格买入，在第29天以7000美元的价格卖出。资本损失=7000-30000=-23000美元。\nCorona Masks 股票在第1天以10美元的价格买入，在第3天以1010美元的价格卖出。在第4天以1000美元的价格再次购买，在第5天以500美元的价格出售。最后，它在第6天以1000美元的价格被买走，在第10天以10000美元的价格被卖掉。资本损益是每次（&rsquo;Buy&#39;-&gt;&#39;Sell&#39;）操作资本收益或损失的和=（1010-10）+（500-1000）+（10000-1000）=1000-500+9000=9500美元。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1394.找出数组中的幸运数",
        "hardRate": "EASY",
        "passRate": "65.51%",
        "problemsUrl": "https://leetcode.cn/problems/find-lucky-integer-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-lucky-integer-in-an-array/solution",
        "problemsDesc": "<p>在整数数组中，如果一个整数的出现频次和它的数值大小相等，我们就称这个整数为「幸运数」。</p>\n\n<p>给你一个整数数组 <code>arr</code>，请你从中找出并返回一个幸运数。</p>\n\n<ul>\n\t<li>如果数组中存在多个幸运数，只需返回 <strong>最大</strong> 的那个。</li>\n\t<li>如果数组中不含幸运数，则返回 <strong>-1 </strong>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,2,3,4]\n<strong>输出：</strong>2\n<strong>解释：</strong>数组中唯一的幸运数是 2 ，因为数值 2 的出现频次也是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,2,3,3,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>1、2 以及 3 都是幸运数，只需要返回其中最大的 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,2,2,3,3]\n<strong>输出：</strong>-1\n<strong>解释：</strong>数组中不存在幸运数。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [5]\n<strong>输出：</strong>-1\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [7,7,7,7,7,7,7]\n<strong>输出：</strong>7\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 500</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1395.统计作战单位数",
        "hardRate": "MEDIUM",
        "passRate": "71.28%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-teams/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-teams/solution",
        "problemsDesc": "<p> <code>n</code> 名士兵站成一排。每个士兵都有一个 <strong>独一无二</strong> 的评分 <code>rating</code> 。</p>\n\n<p>每 <strong>3</strong> 个士兵可以组成一个作战单位，分组规则如下：</p>\n\n<ul>\n\t<li>从队伍中选出下标分别为 <code>i</code>、<code>j</code>、<code>k</code> 的 3 名士兵，他们的评分分别为 <code>rating[i]</code>、<code>rating[j]</code>、<code>rating[k]</code></li>\n\t<li>作战单位需满足： <code>rating[i] < rating[j] < rating[k]</code> 或者 <code>rating[i] > rating[j] > rating[k]</code> ，其中  <code>0 <= i < j < k < n</code></li>\n</ul>\n\n<p>请你返回按上述条件可以组建的作战单位数量。每个士兵都可以是多个作战单位的一部分。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rating = [2,5,3,4,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>我们可以组建三个作战单位 (2,3,4)、(5,4,1)、(5,3,1) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rating = [2,1,3]\n<strong>输出：</strong>0\n<strong>解释：</strong>根据题目条件，我们无法组建作战单位。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>rating = [1,2,3,4]\n<strong>输出：</strong>4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == rating.length</code></li>\n\t<li><code>3 <= n <= 1000</code></li>\n\t<li><code>1 <= rating[i] <= 10^5</code></li>\n\t<li><code>rating</code> 中的元素都是唯一的</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1396.设计地铁系统",
        "hardRate": "MEDIUM",
        "passRate": "41.95%",
        "problemsUrl": "https://leetcode.cn/problems/design-underground-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-underground-system/solution",
        "problemsDesc": "<p>地铁系统跟踪不同车站之间的乘客出行时间，并使用这一数据来计算从一站到另一站的平均时间。</p>\n\n<p>实现 <code>UndergroundSystem</code> 类：</p>\n\n<ul>\n\t<li><code>void checkIn(int id, string stationName, int t)</code>\n\n\t<ul>\n\t\t<li>通行卡 ID 等于 <code>id</code> 的乘客，在时间 <code>t</code> ，从 <code>stationName</code> 站进入</li>\n\t\t<li>乘客一次只能从一个站进入</li>\n\t</ul>\n\t</li>\n\t<li><code>void checkOut(int id, string stationName, int t)</code>\n\t<ul>\n\t\t<li>通行卡 ID 等于 <code>id</code> 的乘客，在时间 <code>t</code> ，从 <code>stationName</code> 站离开</li>\n\t</ul>\n\t</li>\n\t<li><code>double getAverageTime(string startStation, string endStation)</code>\n\t<ul>\n\t\t<li>返回从 <code>startStation</code> 站到 <code>endStation</code> 站的平均时间</li>\n\t\t<li>平均时间会根据截至目前所有从 <code>startStation</code> 站 <strong>直接</strong> 到达 <code>endStation</code> 站的行程进行计算，也就是从 <code>startStation</code> 站进入并从 <code>endStation</code> 离开的行程</li>\n\t\t<li>从 <code>startStation</code> 到 <code>endStation</code> 的行程时间与从 <code>endStation</code> 到 <code>startStation</code> 的行程时间可能不同</li>\n\t\t<li>在调用 <code>getAverageTime</code> 之前，至少有一名乘客从 <code>startStation</code> 站到达 <code>endStation</code> 站</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>你可以假设对 <code>checkIn</code> 和 <code>checkOut</code> 方法的所有调用都是符合逻辑的。如果一名乘客在时间 <code>t<sub>1</sub></code> 进站、时间 <code>t<sub>2</sub></code> 出站，那么 <code>t<sub>1</sub> &lt; t<sub>2</sub></code> 。所有时间都按时间顺序发生。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"]\n[[],[45,\"Leyton\",3],[32,\"Paradise\",8],[27,\"Leyton\",10],[45,\"Waterloo\",15],[27,\"Waterloo\",20],[32,\"Cambridge\",22],[\"Paradise\",\"Cambridge\"],[\"Leyton\",\"Waterloo\"],[10,\"Leyton\",24],[\"Leyton\",\"Waterloo\"],[10,\"Waterloo\",38],[\"Leyton\",\"Waterloo\"]]\n\n<strong>输出</strong>\n[null,null,null,null,null,null,null,14.00000,11.00000,null,11.00000,null,12.00000]\n\n<strong>解释</strong>\nUndergroundSystem undergroundSystem = new UndergroundSystem();\nundergroundSystem.checkIn(45, \"Leyton\", 3);\nundergroundSystem.checkIn(32, \"Paradise\", 8);\nundergroundSystem.checkIn(27, \"Leyton\", 10);\nundergroundSystem.checkOut(45, \"Waterloo\", 15);  // 乘客 45 \"Leyton\" -&gt; \"Waterloo\" ，用时 15-3 = 12\nundergroundSystem.checkOut(27, \"Waterloo\", 20);  // 乘客 27 \"Leyton\" -&gt; \"Waterloo\" ，用时 20-10 = 10\nundergroundSystem.checkOut(32, \"Cambridge\", 22); // 乘客 32 \"Paradise\" -&gt; \"Cambridge\" ，用时 22-8 = 14\nundergroundSystem.getAverageTime(\"Paradise\", \"Cambridge\"); // 返回 14.00000 。只有一个 \"Paradise\" -&gt; \"Cambridge\" 的行程，(14) / 1 = 14\nundergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\");    // 返回 11.00000 。有两个 \"Leyton\" -&gt; \"Waterloo\" 的行程，(10 + 12) / 2 = 11\nundergroundSystem.checkIn(10, \"Leyton\", 24);\nundergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\");    // 返回 11.00000\nundergroundSystem.checkOut(10, \"Waterloo\", 38);  // 乘客 10 \"Leyton\" -&gt; \"Waterloo\" ，用时 38-24 = 14\nundergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\");    // 返回 12.00000 。有三个 \"Leyton\" -&gt; \"Waterloo\" 的行程，(10 + 12 + 14) / 3 = 12\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[10,\"Leyton\",3],[10,\"Paradise\",8],[\"Leyton\",\"Paradise\"],[5,\"Leyton\",10],[5,\"Paradise\",16],[\"Leyton\",\"Paradise\"],[2,\"Leyton\",21],[2,\"Paradise\",30],[\"Leyton\",\"Paradise\"]]\n\n<strong>输出</strong>\n[null,null,null,5.00000,null,null,5.50000,null,null,6.66667]\n\n<strong>解释</strong>\nUndergroundSystem undergroundSystem = new UndergroundSystem();\nundergroundSystem.checkIn(10, \"Leyton\", 3);\nundergroundSystem.checkOut(10, \"Paradise\", 8); // 乘客 10 \"Leyton\" -&gt; \"Paradise\" ，用时 8-3 = 5\nundergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // 返回 5.00000 ，(5) / 1 = 5\nundergroundSystem.checkIn(5, \"Leyton\", 10);\nundergroundSystem.checkOut(5, \"Paradise\", 16); // 乘客 5 \"Leyton\" -&gt; \"Paradise\" ，用时 16-10 = 6\nundergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // 返回 5.50000 ，(5 + 6) / 2 = 5.5\nundergroundSystem.checkIn(2, \"Leyton\", 21);\nundergroundSystem.checkOut(2, \"Paradise\", 30); // 乘客 2 \"Leyton\" -&gt; \"Paradise\" ，用时 30-21 = 9\nundergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // 返回 6.66667 ，(5 + 6 + 9) / 3 = 6.66667\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= id, t &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= stationName.length, startStation.length, endStation.length &lt;= 10</code> 次</li>\n\t<li>所有字符串由大小写英文字母与数字组成</li>\n\t<li>总共最多调用 <code>checkIn</code>、<code>checkOut</code> 和 <code>getAverageTime</code> 方法 <code>2 * 10<sup>4 </sup></code></li>\n\t<li>与标准答案误差在 <code>10<sup>-5</sup></code> 以内的结果都被视为正确结果</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1397.找到所有好字符串",
        "hardRate": "HARD",
        "passRate": "43.83%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-good-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-good-strings/solution",
        "problemsDesc": "<p>给你两个长度为 <code>n</code>&nbsp;的字符串&nbsp;<code>s1</code> 和&nbsp;<code>s2</code>&nbsp;，以及一个字符串&nbsp;<code>evil</code>&nbsp;。请你返回 <strong>好字符串&nbsp;</strong>的数目。</p>\n\n<p><strong>好字符串</strong>&nbsp;的定义为：它的长度为&nbsp;<code>n</code>&nbsp;，字典序大于等于&nbsp;<code>s1</code>&nbsp;，字典序小于等于&nbsp;<code>s2</code>&nbsp;，且不包含&nbsp;<code>evil</code>&nbsp;为子字符串。</p>\n\n<p>由于答案可能很大，请你返回答案对 10^9 + 7 取余的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, s1 = &quot;aa&quot;, s2 = &quot;da&quot;, evil = &quot;b&quot;\n<strong>输出：</strong>51 \n<strong>解释：</strong>总共有 25 个以 &#39;a&#39; 开头的好字符串：&quot;aa&quot;，&quot;ac&quot;，&quot;ad&quot;，...，&quot;az&quot;。还有 25 个以 &#39;c&#39; 开头的好字符串：&quot;ca&quot;，&quot;cc&quot;，&quot;cd&quot;，...，&quot;cz&quot;。最后，还有一个以 &#39;d&#39; 开头的好字符串：&quot;da&quot;。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 8, s1 = &quot;leetcode&quot;, s2 = &quot;leetgoes&quot;, evil = &quot;leet&quot;\n<strong>输出：</strong>0 \n<strong>解释：</strong>所有字典序大于等于 s1 且小于等于 s2 的字符串都以 evil 字符串 &quot;leet&quot; 开头。所以没有好字符串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, s1 = &quot;gx&quot;, s2 = &quot;gz&quot;, evil = &quot;x&quot;\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s1.length == n</code></li>\n\t<li><code>s2.length == n</code></li>\n\t<li><code>s1 &lt;= s2</code></li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= evil.length &lt;= 50</code></li>\n\t<li>所有字符串都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1398.购买了产品 A 和产品 B 却没有购买产品 C 的顾客",
        "hardRate": "MEDIUM",
        "passRate": "72.17%",
        "problemsUrl": "https://leetcode.cn/problems/customers-who-bought-products-a-and-b-but-not-c/",
        "solutionsUrl": "https://leetcode.cn/problems/customers-who-bought-products-a-and-b-but-not-c/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1399.统计最大组的数目",
        "hardRate": "EASY",
        "passRate": "67.03%",
        "problemsUrl": "https://leetcode.cn/problems/count-largest-group/",
        "solutionsUrl": "https://leetcode.cn/problems/count-largest-group/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code>&nbsp;。请你先求出从 <code>1</code>&nbsp;到 <code>n</code> 的每个整数 10 进制表示下的数位和（每一位上的数字相加），然后把数位和相等的数字放到同一个组中。</p>\n\n<p>请你统计每个组中的数字数目，并返回数字数目并列最多的组有多少个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 13\n<strong>输出：</strong>4\n<strong>解释：</strong>总共有 9 个组，将 1 到 13 按数位求和后这些组分别是：\n[1,10]，[2,11]，[3,12]，[4,13]，[5]，[6]，[7]，[8]，[9]。总共有 4 个组拥有的数字并列最多。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>总共有 2 个大小为 1 的组 [1]，[2]。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 15\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 24\n<strong>输出：</strong>5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1400.构造 K 个回文字符串",
        "hardRate": "MEDIUM",
        "passRate": "61.31%",
        "problemsUrl": "https://leetcode.cn/problems/construct-k-palindrome-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-k-palindrome-strings/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code>&nbsp;和一个整数 <code>k</code>&nbsp;。请你用 <code>s</code>&nbsp;字符串中 <strong>所有字符</strong>&nbsp;构造 <code>k</code>&nbsp;个非空 <strong>回文串</strong>&nbsp;。</p>\n\n<p>如果你可以用&nbsp;<code>s</code>&nbsp;中所有字符构造&nbsp;<code>k</code>&nbsp;个回文字符串，那么请你返回 <strong>True</strong>&nbsp;，否则返回&nbsp;<strong>False</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;annabelle&quot;, k = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>可以用 s 中所有字符构造 2 个回文字符串。\n一些可行的构造方案包括：&quot;anna&quot; + &quot;elble&quot;，&quot;anbna&quot; + &quot;elle&quot;，&quot;anellena&quot; + &quot;b&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;leetcode&quot;, k = 3\n<strong>输出：</strong>false\n<strong>解释：</strong>无法用 s 中所有字符构造 3 个回文串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;true&quot;, k = 4\n<strong>输出：</strong>true\n<strong>解释：</strong>唯一可行的方案是让 s 中每个字符单独构成一个字符串。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;yzyzyzyzyzyzyzy&quot;, k = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>你只需要将所有的 z 放在一个字符串中，所有的 y 放在另一个字符串中。那么两个字符串都是回文串。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;cr&quot;, k = 7\n<strong>输出：</strong>false\n<strong>解释：</strong>我们没有足够的字符去构造 7 个回文串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>s</code>&nbsp;中所有字符都是小写英文字母。</li>\n\t<li><code>1 &lt;= k &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1401.圆和矩形是否有重叠",
        "hardRate": "MEDIUM",
        "passRate": "51.72%",
        "problemsUrl": "https://leetcode.cn/problems/circle-and-rectangle-overlapping/",
        "solutionsUrl": "https://leetcode.cn/problems/circle-and-rectangle-overlapping/solution",
        "problemsDesc": "<p>给你一个以 <code>(radius, xCenter, yCenter)</code> 表示的圆和一个与坐标轴平行的矩形 <code>(x1, y1, x2, y2)</code> ，其中 <code>(x1, y1)</code> 是矩形左下角的坐标，而 <code>(x2, y2)</code> 是右上角的坐标。</p>\n\n<p>如果圆和矩形有重叠的部分，请你返回 <code>true</code> ，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>换句话说，请你检测是否 <strong>存在</strong> 点 <code>(x<sub>i</sub>, y<sub>i</sub>)</code> ，它既在圆上也在矩形上（两者都包括点落在边界上的情况）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1 ：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/20/sample_4_1728.png\" style=\"width: 258px; height: 167px;\" />\n<pre>\n<strong>输入：</strong>radius = 1, xCenter = 0, yCenter = 0, x1 = 1, y1 = -1, x2 = 3, y2 = 1\n<strong>输出：</strong>true\n<strong>解释：</strong>圆和矩形存在公共点 (1,0) 。\n</pre>\n\n<p><strong class=\"example\">示例 2 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>radius = 1, xCenter = 1, yCenter = 1, x1 = 1, y1 = -3, x2 = 2, y2 = -1\n<strong>输出：</strong>false\n</pre>\n\n<p><strong class=\"example\">示例 3 ：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/20/sample_2_1728.png\" style=\"width: 150px; height: 135px;\" />\n<pre>\n<strong>输入：</strong>radius = 1, xCenter = 0, yCenter = 0, x1 = -1, y1 = 0, x2 = 0, y2 = 1\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= radius &lt;= 2000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= xCenter, yCenter &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= x1 &lt; x2 &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= y1 &lt; y2 &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1402.做菜顺序",
        "hardRate": "HARD",
        "passRate": "76.09%",
        "problemsUrl": "https://leetcode.cn/problems/reducing-dishes/",
        "solutionsUrl": "https://leetcode.cn/problems/reducing-dishes/solution",
        "problemsDesc": "<p>一个厨师收集了他&nbsp;<code>n</code>&nbsp;道菜的满意程度&nbsp;<code>satisfaction</code>&nbsp;，这个厨师做出每道菜的时间都是 1 单位时间。</p>\n\n<p>一道菜的 「喜爱时间」系数定义为烹饪这道菜以及之前每道菜所花费的时间乘以这道菜的满意程度，也就是&nbsp;<code>time[i]</code>*<code>satisfaction[i]</code>&nbsp;。</p>\n\n<p>请你返回做完所有菜 「喜爱时间」总和的最大值为多少。</p>\n\n<p>你可以按&nbsp;<strong>任意</strong>&nbsp;顺序安排做菜的顺序，你也可以选择放弃做某些菜来获得更大的总和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>satisfaction = [-1,-8,0,5,-9]\n<strong>输出：</strong>14\n<strong>解释：</strong>去掉第二道和最后一道菜，最大的喜爱时间系数和为 (-1*1 + 0*2 + 5*3 = 14) 。每道菜都需要花费 1 单位时间完成。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>satisfaction = [4,3,2]\n<strong>输出：</strong>20\n<strong>解释：</strong>按照原来顺序相反的时间做菜 (2*1 + 3*2 + 4*3 = 20)\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>satisfaction = [-1,-4,-5]\n<strong>输出：</strong>0\n<strong>解释：</strong>大家都不喜欢这些菜，所以不做任何菜可以获得最大的喜爱时间系数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == satisfaction.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>-1000 &lt;= satisfaction[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1403.非递增顺序的最小子序列",
        "hardRate": "EASY",
        "passRate": "73.33%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-subsequence-in-non-increasing-order/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-subsequence-in-non-increasing-order/solution",
        "problemsDesc": "<p>给你一个数组 <code>nums</code>，请你从中抽取一个子序列，满足该子序列的元素之和 <strong>严格</strong> 大于未包含在该子序列中的各元素之和。</p>\n\n<p>如果存在多个解决方案，只需返回 <strong>长度最小</strong> 的子序列。如果仍然有多个解决方案，则返回 <strong>元素之和最大</strong> 的子序列。</p>\n\n<p>与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。</p>\n\n<p><strong>注意</strong>，题目数据保证满足所有约束条件的解决方案是 <strong>唯一</strong> 的。同时，返回的答案应当按 <strong>非递增顺序</strong> 排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,3,10,9,8]\n<strong>输出：</strong>[10,9] \n<strong>解释：</strong>子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。&nbsp;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,4,7,6,7]\n<strong>输出：</strong>[7,7,6] \n<strong>解释：</strong>子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。  \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [6]\n<strong>输出：</strong>[6]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1404.将二进制表示减到 1 的步骤数",
        "hardRate": "MEDIUM",
        "passRate": "50.93%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/solution",
        "problemsDesc": "<p>给你一个以二进制形式表示的数字 <code>s</code> 。请你返回按下述规则将其减少到 1 所需要的步骤数：</p>\n\n<ul>\n\t<li>\n\t<p>如果当前数字为偶数，则将其除以 2 。</p>\n\t</li>\n\t<li>\n\t<p>如果当前数字为奇数，则将其加上 1 。</p>\n\t</li>\n</ul>\n\n<p>题目保证你总是可以按上述规则将测试用例变为 1 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1101&quot;\n<strong>输出：</strong>6\n<strong>解释：</strong>&quot;1101&quot; 表示十进制数 13 。\nStep 1) 13 是奇数，加 1 得到 14&nbsp;\nStep 2) 14 是偶数，除 2 得到 7\nStep 3) 7  是奇数，加 1 得到 8\nStep 4) 8  是偶数，除 2 得到 4&nbsp; \nStep 5) 4  是偶数，除 2 得到 2&nbsp;\nStep 6) 2  是偶数，除 2 得到 1&nbsp; \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;10&quot;\n<strong>输出：</strong>1\n<strong>解释：</strong>&quot;10&quot; 表示十进制数 2 。\nStep 1) 2 是偶数，除 2 得到 1 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1&quot;\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length&nbsp;&lt;= 500</code></li>\n\t<li><code>s</code> 由字符 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code> 组成。</li>\n\t<li><code>s[0] == &#39;1&#39;</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1405.最长快乐字符串",
        "hardRate": "MEDIUM",
        "passRate": "63.55%",
        "problemsUrl": "https://leetcode.cn/problems/longest-happy-string/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-happy-string/solution",
        "problemsDesc": "<p>如果字符串中不含有任何 <code>&#39;aaa&#39;</code>，<code>&#39;bbb&#39;</code> 或 <code>&#39;ccc&#39;</code> 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。</p>\n\n<p>给你三个整数 <code>a</code>，<code>b</code> ，<code>c</code>，请你返回 <strong>任意一个</strong> 满足下列全部条件的字符串 <code>s</code>：</p>\n\n<ul>\n\t<li><code>s</code> 是一个尽可能长的快乐字符串。</li>\n\t<li><code>s</code> 中 <strong>最多</strong> 有<code>a</code> 个字母 <code>&#39;a&#39;</code>、<code>b</code>&nbsp;个字母 <code>&#39;b&#39;</code>、<code>c</code> 个字母 <code>&#39;c&#39;</code> 。</li>\n\t<li><code>s </code>中只含有 <code>&#39;a&#39;</code>、<code>&#39;b&#39;</code> 、<code>&#39;c&#39;</code> 三种字母。</li>\n</ul>\n\n<p>如果不存在这样的字符串 <code>s</code> ，请返回一个空字符串 <code>&quot;&quot;</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>a = 1, b = 1, c = 7\n<strong>输出：</strong>&quot;ccaccbcc&quot;\n<strong>解释：</strong>&quot;ccbccacc&quot; 也是一种正确答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>a = 2, b = 2, c = 1\n<strong>输出：</strong>&quot;aabbc&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>a = 7, b = 1, c = 0\n<strong>输出：</strong>&quot;aabaa&quot;\n<strong>解释：</strong>这是该测试用例的唯一正确答案。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= a, b, c &lt;= 100</code></li>\n\t<li><code>a + b + c &gt; 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1406.石子游戏 III",
        "hardRate": "HARD",
        "passRate": "59.19%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game-iii/solution",
        "problemsDesc": "<p>Alice 和 Bob 继续他们的石子游戏。几堆石子 <strong>排成一行</strong> ，每堆石子都对应一个得分，由数组 <code>stoneValue</code> 给出。</p>\n\n<p>Alice 和 Bob 轮流取石子，<strong>Alice</strong> 总是先开始。在每个玩家的回合中，该玩家可以拿走剩下石子中的的前 <strong>1、2 或 3 堆石子</strong> 。比赛一直持续到所有石头都被拿走。</p>\n\n<p>每个玩家的最终得分为他所拿到的每堆石子的对应得分之和。每个玩家的初始分数都是 <strong>0</strong> 。</p>\n\n<p>比赛的目标是决出最高分，得分最高的选手将会赢得比赛，比赛也可能会出现平局。</p>\n\n<p>假设 Alice 和 Bob 都采取 <strong>最优策略</strong> 。</p>\n\n<p>如果 Alice 赢了就返回 <code>\"Alice\"</code> <em>，</em>Bob 赢了就返回<em> </em><code>\"Bob\"</code><em>，</em>分数相同返回 <code>\"Tie\"</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>values = [1,2,3,7]\n<strong>输出：</strong>\"Bob\"\n<strong>解释：</strong>Alice 总是会输，她的最佳选择是拿走前三堆，得分变成 6 。但是 Bob 的得分为 7，Bob 获胜。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>values = [1,2,3,-9]\n<strong>输出：</strong>\"Alice\"\n<strong>解释：</strong>Alice 要想获胜就必须在第一个回合拿走前三堆石子，给 Bob 留下负分。\n如果 Alice 只拿走第一堆，那么她的得分为 1，接下来 Bob 拿走第二、三堆，得分为 5 。之后 Alice 只能拿到分数 -9 的石子堆，输掉比赛。\n如果 Alice 拿走前两堆，那么她的得分为 3，接下来 Bob 拿走第三堆，得分为 3 。之后 Alice 只能拿到分数 -9 的石子堆，同样会输掉比赛。\n注意，他们都应该采取 <strong>最优策略 </strong>，所以在这里 Alice 将选择能够使她获胜的方案。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>values = [1,2,3,6]\n<strong>输出：</strong>\"Tie\"\n<strong>解释：</strong>Alice 无法赢得比赛。如果她决定选择前三堆，她可以以平局结束比赛，否则她就会输。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= stoneValue.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-1000&nbsp;&lt;= stoneValue[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1407.排名靠前的旅行者",
        "hardRate": "EASY",
        "passRate": "56.76%",
        "problemsUrl": "https://leetcode.cn/problems/top-travellers/",
        "solutionsUrl": "https://leetcode.cn/problems/top-travellers/solution",
        "problemsDesc": "<p>表：<code>Users</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| name          | varchar |\n+---------------+---------+\nid 是该表单主键。\nname 是用户名字。</pre>\n\n<p> </p>\n\n<p>表：<code>Rides</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| user_id       | int     |\n| distance      | int     |\n+---------------+---------+\nid 是该表单主键。\nuser_id 是本次行程的用户的 id, 而该用户此次行程距离为 distance 。\n</pre>\n\n<p> </p>\n\n<p>写一段 SQL , 报告每个用户的旅行距离。</p>\n\n<p>返回的结果表单，以 <code>travelled_distance</code> <strong>降序排列</strong> ，如果有两个或者更多的用户旅行了相同的距离, 那么再以 <code>name</code> <strong>升序排列</strong> 。</p>\n\n<p>查询结果格式如下例所示。</p>\n\n<pre>\nUsers 表：\n+------+-----------+\n| id   | name      |\n+------+-----------+\n| 1    | Alice     |\n| 2    | Bob       |\n| 3    | Alex      |\n| 4    | Donald    |\n| 7    | Lee       |\n| 13   | Jonathan  |\n| 19   | Elvis     |\n+------+-----------+\n\nRides 表：\n+------+----------+----------+\n| id   | user_id  | distance |\n+------+----------+----------+\n| 1    | 1        | 120      |\n| 2    | 2        | 317      |\n| 3    | 3        | 222      |\n| 4    | 7        | 100      |\n| 5    | 13       | 312      |\n| 6    | 19       | 50       |\n| 7    | 7        | 120      |\n| 8    | 19       | 400      |\n| 9    | 7        | 230      |\n+------+----------+----------+\n\nResult 表：\n+----------+--------------------+\n| name     | travelled_distance |\n+----------+--------------------+\n| Elvis    | 450                |\n| Lee      | 450                |\n| Bob      | 317                |\n| Jonathan | 312                |\n| Alex     | 222                |\n| Alice    | 120                |\n| Donald   | 0                  |\n+----------+--------------------+\nElvis 和 Lee 旅行了 450 英里，Elvis 是排名靠前的旅行者，因为他的名字在字母表上的排序比 Lee 更小。\nBob, Jonathan, Alex 和 Alice 只有一次行程，我们只按此次行程的全部距离对他们排序。\nDonald 没有任何行程, 他的旅行距离为 0。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1408.数组中的字符串匹配",
        "hardRate": "EASY",
        "passRate": "64.38%",
        "problemsUrl": "https://leetcode.cn/problems/string-matching-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/string-matching-in-an-array/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>words</code> ，数组中的每个字符串都可以看作是一个单词。请你按 <strong>任意</strong> 顺序返回 <code>words</code> 中是其他单词的子字符串的所有单词。</p>\n\n<p>如果你可以删除 <code>words[j]</code>&nbsp;最左侧和/或最右侧的若干字符得到 <code>words[i]</code> ，那么字符串 <code>words[i]</code> 就是 <code>words[j]</code> 的一个子字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"mass\",\"as\",\"hero\",\"superhero\"]\n<strong>输出：</strong>[\"as\",\"hero\"]\n<strong>解释：</strong>\"as\" 是 \"mass\" 的子字符串，\"hero\" 是 \"superhero\" 的子字符串。\n[\"hero\",\"as\"] 也是有效的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"leetcode\",\"et\",\"code\"]\n<strong>输出：</strong>[\"et\",\"code\"]\n<strong>解释：</strong>\"et\" 和 \"code\" 都是 \"leetcode\" 的子字符串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"blue\",\"green\",\"bu\"]\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li><code>words[i]</code> 仅包含小写英文字母。</li>\n\t<li>题目数据 <strong>保证</strong> 每个 <code>words[i]</code> 都是独一无二的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1409.查询带键的排列",
        "hardRate": "MEDIUM",
        "passRate": "81.41%",
        "problemsUrl": "https://leetcode.cn/problems/queries-on-a-permutation-with-key/",
        "solutionsUrl": "https://leetcode.cn/problems/queries-on-a-permutation-with-key/solution",
        "problemsDesc": "<p>给你一个待查数组 <code>queries</code> ，数组中的元素为 <code>1</code> 到 <code>m</code> 之间的正整数。 请你根据以下规则处理所有待查项 <code>queries[i]</code>（从 <code>i=0</code> 到 <code>i=queries.length-1</code>）：</p>\n\n<ul>\n\t<li>一开始，排列 <code>P=[1,2,3,...,m]</code>。</li>\n\t<li>对于当前的 <code>i</code> ，请你找出待查项 <code>queries[i]</code> 在排列 <code>P</code> 中的位置（<strong>下标从 0 开始</strong>），然后将其从原位置移动到排列 <code>P</code> 的起始位置（即下标为 0 处）。注意， <code>queries[i]</code> 在 <code>P</code> 中的位置就是 <code>queries[i]</code> 的查询结果。</li>\n</ul>\n\n<p>请你以数组形式返回待查数组&nbsp; <code>queries</code> 的查询结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>queries = [3,1,2,1], m = 5\n<strong>输出：</strong>[2,1,2,1] \n<strong>解释：</strong>待查数组 queries 处理如下：\n对于 i=0: queries[i]=3, P=[1,2,3,4,5], 3 在 P 中的位置是 <strong>2</strong>，接着我们把 3 移动到 P 的起始位置，得到 P=[3,1,2,4,5] 。\n对于 i=1: queries[i]=1, P=[3,1,2,4,5], 1 在 P 中的位置是 <strong>1</strong>，接着我们把 1 移动到 P 的起始位置，得到 P=[1,3,2,4,5] 。 \n对于 i=2: queries[i]=2, P=[1,3,2,4,5], 2 在 P 中的位置是 <strong>2</strong>，接着我们把 2 移动到 P 的起始位置，得到 P=[2,1,3,4,5] 。\n对于 i=3: queries[i]=1, P=[2,1,3,4,5], 1 在 P 中的位置是 <strong>1</strong>，接着我们把 1 移动到 P 的起始位置，得到 P=[1,2,3,4,5] 。 \n因此，返回的结果数组为 [2,1,2,1] 。  \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>queries = [4,1,2,2], m = 4\n<strong>输出：</strong>[3,1,2,0]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>queries = [7,5,5,8,3], m = 8\n<strong>输出：</strong>[6,5,0,7,5]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m &lt;= 10^3</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= m</code></li>\n\t<li><code>1 &lt;= queries[i] &lt;= m</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1410.HTML 实体解析器",
        "hardRate": "MEDIUM",
        "passRate": "46.99%",
        "problemsUrl": "https://leetcode.cn/problems/html-entity-parser/",
        "solutionsUrl": "https://leetcode.cn/problems/html-entity-parser/solution",
        "problemsDesc": "<p>「HTML&nbsp;实体解析器」 是一种特殊的解析器，它将 HTML 代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。</p>\n\n<p>HTML 里这些特殊字符和它们对应的字符实体包括：</p>\n\n<ul>\n\t<li><strong>双引号：</strong>字符实体为&nbsp;<code>&amp;quot;</code>&nbsp;，对应的字符是&nbsp;<code>&quot;</code>&nbsp;。</li>\n\t<li><strong>单引号：</strong>字符实体为&nbsp;<code>&amp;apos;</code>&nbsp;，对应的字符是&nbsp;<code>&#39;</code>&nbsp;。</li>\n\t<li><strong>与符号：</strong>字符实体为&nbsp;<code>&amp;amp;</code>&nbsp;，对应对的字符是&nbsp;<code>&amp;</code>&nbsp;。</li>\n\t<li><strong>大于号：</strong>字符实体为&nbsp;<code>&amp;gt;</code>&nbsp;，对应的字符是&nbsp;<code>&gt;</code>&nbsp;。</li>\n\t<li><strong>小于号：</strong>字符实体为&nbsp;<code>&amp;lt;</code>&nbsp;，对应的字符是&nbsp;<code>&lt;</code>&nbsp;。</li>\n\t<li><strong>斜线号：</strong>字符实体为&nbsp;<code>&amp;frasl;</code>&nbsp;，对应的字符是&nbsp;<code>/</code>&nbsp;。</li>\n</ul>\n\n<p>给你输入字符串&nbsp;<code>text</code>&nbsp;，请你实现一个 HTML&nbsp;实体解析器，返回解析器解析后的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = &quot;&amp;amp; is an HTML entity but &amp;ambassador; is not.&quot;\n<strong>输出：</strong>&quot;&amp; is an HTML entity but &amp;ambassador; is not.&quot;\n<strong>解释：</strong>解析器把字符实体 &amp;amp; 用 &amp; 替换\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = &quot;and I quote: &amp;quot;...&amp;quot;&quot;\n<strong>输出：</strong>&quot;and I quote: \\&quot;...\\&quot;&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = &quot;Stay home! Practice on Leetcode :)&quot;\n<strong>输出：</strong>&quot;Stay home! Practice on Leetcode :)&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = &quot;x &amp;gt; y &amp;amp;&amp;amp; x &amp;lt; y is always false&quot;\n<strong>输出：</strong>&quot;x &gt; y &amp;&amp; x &lt; y is always false&quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = &quot;leetcode.com&amp;frasl;problemset&amp;frasl;all&quot;\n<strong>输出：</strong>&quot;leetcode.com/problemset/all&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 10^5</code></li>\n\t<li>字符串可能包含 256 个ASCII 字符中的任意字符。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1411.给 N x 3 网格图涂色的方案数",
        "hardRate": "HARD",
        "passRate": "57.21%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-paint-n-3-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-paint-n-3-grid/solution",
        "problemsDesc": "<p>你有一个 <code>n x 3</code>&nbsp;的网格图 <code>grid</code>&nbsp;，你需要用 <strong>红，黄，绿</strong>&nbsp;三种颜色之一给每一个格子上色，且确保相邻格子颜色不同（也就是有相同水平边或者垂直边的格子颜色不同）。</p>\n\n<p>给你网格图的行数 <code>n</code>&nbsp;。</p>\n\n<p>请你返回给&nbsp;<code>grid</code>&nbsp;涂色的方案数。由于答案可能会非常大，请你返回答案对&nbsp;<code>10^9 + 7</code>&nbsp;取余的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>12\n<strong>解释：</strong>总共有 12 种可行的方法：\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/12/e1.png\" style=\"height: 289px; width: 450px;\">\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>54\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 3\n<strong>输出：</strong>246\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 7\n<strong>输出：</strong>106494\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>n = 5000\n<strong>输出：</strong>30228214\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>grid[i].length == 3</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1412.查找成绩处于中游的学生",
        "hardRate": "HARD",
        "passRate": "54.44%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-quiet-students-in-all-exams/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-quiet-students-in-all-exams/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1413.逐步求和得到正数的最小值",
        "hardRate": "EASY",
        "passRate": "73.07%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-value-to-get-positive-step-by-step-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-value-to-get-positive-step-by-step-sum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>&nbsp;。你可以选定任意的&nbsp;<strong>正数</strong> startValue 作为初始值。</p>\n\n<p>你需要从左到右遍历 <code>nums</code>&nbsp;数组，并将 startValue 依次累加上&nbsp;<code>nums</code>&nbsp;数组中的值。</p>\n\n<p>请你在确保累加和始终大于等于 1 的前提下，选出一个最小的&nbsp;<strong>正数</strong>&nbsp;作为 startValue 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-3,2,-3,4,2]\n<strong>输出：</strong>5\n<strong>解释：</strong>如果你选择 startValue = 4，在第三次累加时，和小于 1 。\n<strong>                累加求和\n&nbsp;               startValue = 4 | startValue = 5 | nums\n</strong>&nbsp;                 (4 <strong>-3</strong> ) = 1  | (5 <strong>-3</strong> ) = 2    |  -3\n&nbsp;                 (1 <strong>+2</strong> ) = 3  | (2 <strong>+2</strong> ) = 4    |   2\n&nbsp;                 (3 <strong>-3</strong> ) = 0  | (4 <strong>-3</strong> ) = 1    |  -3\n&nbsp;                 (0 <strong>+4</strong> ) = 4  | (1 <strong>+4</strong> ) = 5    |   4\n&nbsp;                 (4 <strong>+2</strong> ) = 6  | (5 <strong>+2</strong> ) = 7    |   2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>最小的 startValue 需要是正数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,-2,-3]\n<strong>输出：</strong>5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1414.和为 K 的最少斐波那契数字数目",
        "hardRate": "MEDIUM",
        "passRate": "70.37%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/solution",
        "problemsDesc": "<p>给你数字 <code>k</code>&nbsp;，请你返回和为&nbsp;<code>k</code>&nbsp;的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。</p>\n\n<p>斐波那契数字定义为：</p>\n\n<ul>\n\t<li>F<sub>1</sub> = 1</li>\n\t<li>F<sub>2</sub> = 1</li>\n\t<li>F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub>&nbsp;， 其中 n &gt; 2 。</li>\n</ul>\n\n<p>数据保证对于给定的 <code>k</code>&nbsp;，一定能找到可行解。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>k = 7\n<strong>输出：</strong>2 \n<strong>解释：</strong>斐波那契数字为：1，1，2，3，5，8，13，&hellip;&hellip;\n对于 k = 7 ，我们可以得到 2 + 5 = 7 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>k = 10\n<strong>输出：</strong>2 \n<strong>解释：</strong>对于 k = 10 ，我们可以得到 2 + 8 = 10 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>k = 19\n<strong>输出：</strong>3 \n<strong>解释：</strong>对于 k = 19 ，我们可以得到 1 + 5 + 13 = 19 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1415.长度为 n 的开心字符串中字典序第 k 小的字符串",
        "hardRate": "MEDIUM",
        "passRate": "68.67%",
        "problemsUrl": "https://leetcode.cn/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/",
        "solutionsUrl": "https://leetcode.cn/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/solution",
        "problemsDesc": "<p>一个 「开心字符串」定义为：</p>\n\n<ul>\n\t<li>仅包含小写字母&nbsp;<code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code>.</li>\n\t<li>对所有在&nbsp;<code>1</code>&nbsp;到&nbsp;<code>s.length - 1</code>&nbsp;之间的&nbsp;<code>i</code>&nbsp;，满足&nbsp;<code>s[i] != s[i + 1]</code>&nbsp;（字符串的下标从 1 开始）。</li>\n</ul>\n\n<p>比方说，字符串&nbsp;<strong>&quot;abc&quot;</strong>，<strong>&quot;ac&quot;，&quot;b&quot;</strong> 和&nbsp;<strong>&quot;abcbabcbcb&quot;</strong>&nbsp;都是开心字符串，但是&nbsp;<strong>&quot;aa&quot;</strong>，<strong>&quot;baa&quot;</strong>&nbsp;和&nbsp;<strong>&quot;ababbc&quot;</strong>&nbsp;都不是开心字符串。</p>\n\n<p>给你两个整数 <code>n</code>&nbsp;和 <code>k</code>&nbsp;，你需要将长度为 <code>n</code>&nbsp;的所有开心字符串按字典序排序。</p>\n\n<p>请你返回排序后的第 k 个开心字符串，如果长度为 <code>n</code>&nbsp;的开心字符串少于 <code>k</code>&nbsp;个，那么请你返回 <strong>空字符串</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 1, k = 3\n<strong>输出：</strong>&quot;c&quot;\n<strong>解释：</strong>列表 [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 包含了所有长度为 1 的开心字符串。按照字典序排序后第三个字符串为 &quot;c&quot; 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 1, k = 4\n<strong>输出：</strong>&quot;&quot;\n<strong>解释：</strong>长度为 1 的开心字符串只有 3 个。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 3, k = 9\n<strong>输出：</strong>&quot;cab&quot;\n<strong>解释：</strong>长度为 3 的开心字符串总共有 12 个 [&quot;aba&quot;, &quot;abc&quot;, &quot;aca&quot;, &quot;acb&quot;, &quot;bab&quot;, &quot;bac&quot;, &quot;bca&quot;, &quot;bcb&quot;, &quot;cab&quot;, &quot;cac&quot;, &quot;cba&quot;, &quot;cbc&quot;] 。第 9 个字符串为 &quot;cab&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, k = 7\n<strong>输出：</strong>&quot;&quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>n = 10, k = 100\n<strong>输出：</strong>&quot;abacbabacb&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10</code></li>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1416.恢复数组",
        "hardRate": "HARD",
        "passRate": "42.63%",
        "problemsUrl": "https://leetcode.cn/problems/restore-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/restore-the-array/solution",
        "problemsDesc": "<p>某个程序本来应该输出一个整数数组。但是这个程序忘记输出空格了以致输出了一个数字字符串，我们所知道的信息只有：数组中所有整数都在 <code>[1, k]</code>&nbsp;之间，且数组中的数字都没有前导 0 。</p>\n\n<p>给你字符串&nbsp;<code>s</code>&nbsp;和整数&nbsp;<code>k</code>&nbsp;。可能会有多种不同的数组恢复结果。</p>\n\n<p>按照上述程序，请你返回所有可能输出字符串&nbsp;<code>s</code>&nbsp;的数组方案数。</p>\n\n<p>由于数组方案数可能会很大，请你返回它对&nbsp;<code>10^9 + 7</code>&nbsp;<strong>取余</strong>&nbsp;后的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1000&quot;, k = 10000\n<strong>输出：</strong>1\n<strong>解释：</strong>唯一一种可能的数组方案是 [1000]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1000&quot;, k = 10\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在任何数组方案满足所有整数都 &gt;= 1 且 &lt;= 10 同时输出结果为 s 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1317&quot;, k = 2000\n<strong>输出：</strong>8\n<strong>解释：</strong>可行的数组方案为 [1317]，[131,7]，[13,17]，[1,317]，[13,1,7]，[1,31,7]，[1,3,17]，[1,3,1,7]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;2020&quot;, k = 30\n<strong>输出：</strong>1\n<strong>解释：</strong>唯一可能的数组方案是 [20,20] 。 [2020] 不是可行的数组方案，原因是 2020 &gt; 30 。 [2,020] 也不是可行的数组方案，因为 020 含有前导 0 。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1234567890&quot;, k = 90\n<strong>输出：</strong>34\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code>.</li>\n\t<li><code>s</code>&nbsp;只包含数字且不包含前导 0 。</li>\n\t<li><code>1 &lt;= k &lt;= 10^9</code>.</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1417.重新格式化字符串",
        "hardRate": "EASY",
        "passRate": "55.16%",
        "problemsUrl": "https://leetcode.cn/problems/reformat-the-string/",
        "solutionsUrl": "https://leetcode.cn/problems/reformat-the-string/solution",
        "problemsDesc": "<p>给你一个混合了数字和字母的字符串 <code>s</code>，其中的字母均为小写英文字母。</p>\n\n<p>请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。</p>\n\n<p>请你返回 <strong>重新格式化后</strong> 的字符串；如果无法按要求重新格式化，则返回一个 <strong>空字符串</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;a0b1c2&quot;\n<strong>输出：</strong>&quot;0a1b2c&quot;\n<strong>解释：</strong>&quot;0a1b2c&quot; 中任意两个相邻字符的类型都不同。 &quot;a0b1c2&quot;, &quot;0a1b2c&quot;, &quot;0c2a1b&quot; 也是满足题目要求的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;leetcode&quot;\n<strong>输出：</strong>&quot;&quot;\n<strong>解释：</strong>&quot;leetcode&quot; 中只有字母，所以无法满足重新格式化的条件。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1229857369&quot;\n<strong>输出：</strong>&quot;&quot;\n<strong>解释：</strong>&quot;1229857369&quot; 中只有数字，所以无法满足重新格式化的条件。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;covid2019&quot;\n<strong>输出：</strong>&quot;c2o0v1i9d&quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;ab123&quot;\n<strong>输出：</strong>&quot;1a2b3&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>s</code> 仅由小写英文字母和/或数字组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1418.点菜展示表",
        "hardRate": "MEDIUM",
        "passRate": "73.15%",
        "problemsUrl": "https://leetcode.cn/problems/display-table-of-food-orders-in-a-restaurant/",
        "solutionsUrl": "https://leetcode.cn/problems/display-table-of-food-orders-in-a-restaurant/solution",
        "problemsDesc": "<p>给你一个数组 <code>orders</code>，表示客户在餐厅中完成的订单，确切地说， <code>orders[i]=[customerName<sub>i</sub>,tableNumber<sub>i</sub>,foodItem<sub>i</sub>]</code> ，其中 <code>customerName<sub>i</sub></code> 是客户的姓名，<code>tableNumber<sub>i</sub></code> 是客户所在餐桌的桌号，而 <code>foodItem<sub>i</sub></code> 是客户点的餐品名称。</p>\n\n<p>请你返回该餐厅的 <strong>点菜展示表</strong><em> 。</em>在这张表中，表中第一行为标题，其第一列为餐桌桌号 &ldquo;Table&rdquo; ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。</p>\n\n<p>注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>orders = [[&quot;David&quot;,&quot;3&quot;,&quot;Ceviche&quot;],[&quot;Corina&quot;,&quot;10&quot;,&quot;Beef Burrito&quot;],[&quot;David&quot;,&quot;3&quot;,&quot;Fried Chicken&quot;],[&quot;Carla&quot;,&quot;5&quot;,&quot;Water&quot;],[&quot;Carla&quot;,&quot;5&quot;,&quot;Ceviche&quot;],[&quot;Rous&quot;,&quot;3&quot;,&quot;Ceviche&quot;]]\n<strong>输出：</strong>[[&quot;Table&quot;,&quot;Beef Burrito&quot;,&quot;Ceviche&quot;,&quot;Fried Chicken&quot;,&quot;Water&quot;],[&quot;3&quot;,&quot;0&quot;,&quot;2&quot;,&quot;1&quot;,&quot;0&quot;],[&quot;5&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;],[&quot;10&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]] \n<strong>解释：\n</strong>点菜展示表如下所示：\n<strong>Table,Beef Burrito,Ceviche,Fried Chicken,Water</strong>\n3    ,0           ,2      ,1            ,0\n5    ,0           ,1      ,0            ,1\n10   ,1           ,0      ,0            ,0\n对于餐桌 3：David 点了 &quot;Ceviche&quot; 和 &quot;Fried Chicken&quot;，而 Rous 点了 &quot;Ceviche&quot;\n而餐桌 5：Carla 点了 &quot;Water&quot; 和 &quot;Ceviche&quot;\n餐桌 10：Corina 点了 &quot;Beef Burrito&quot; \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>orders = [[&quot;James&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Ratesh&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Amadeus&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Adam&quot;,&quot;1&quot;,&quot;Canadian Waffles&quot;],[&quot;Brianna&quot;,&quot;1&quot;,&quot;Canadian Waffles&quot;]]\n<strong>输出：</strong>[[&quot;Table&quot;,&quot;Canadian Waffles&quot;,&quot;Fried Chicken&quot;],[&quot;1&quot;,&quot;2&quot;,&quot;0&quot;],[&quot;12&quot;,&quot;0&quot;,&quot;3&quot;]] \n<strong>解释：</strong>\n对于餐桌 1：Adam 和 Brianna 都点了 &quot;Canadian Waffles&quot;\n而餐桌 12：James, Ratesh 和 Amadeus 都点了 &quot;Fried Chicken&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>orders = [[&quot;Laura&quot;,&quot;2&quot;,&quot;Bean Burrito&quot;],[&quot;Jhon&quot;,&quot;2&quot;,&quot;Beef Burrito&quot;],[&quot;Melissa&quot;,&quot;2&quot;,&quot;Soda&quot;]]\n<strong>输出：</strong>[[&quot;Table&quot;,&quot;Bean Burrito&quot;,&quot;Beef Burrito&quot;,&quot;Soda&quot;],[&quot;2&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;orders.length &lt;= 5 * 10^4</code></li>\n\t<li><code>orders[i].length == 3</code></li>\n\t<li><code>1 &lt;= customerName<sub>i</sub>.length, foodItem<sub>i</sub>.length &lt;= 20</code></li>\n\t<li><code>customerName<sub>i</sub></code> 和 <code>foodItem<sub>i</sub></code> 由大小写英文字母及空格字符 <code>&#39; &#39;</code> 组成。</li>\n\t<li><code>tableNumber<sub>i</sub></code> 是 <code>1</code> 到 <code>500</code> 范围内的整数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1419.数青蛙",
        "hardRate": "MEDIUM",
        "passRate": "50.18%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-frogs-croaking/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-frogs-croaking/solution",
        "problemsDesc": "<p>给你一个字符串 <code>croakOfFrogs</code>，它表示不同青蛙发出的蛙鸣声（字符串 <code>\"croak\"</code> ）的组合。由于同一时间可以有多只青蛙呱呱作响，所以&nbsp;<code>croakOfFrogs</code> 中会混合多个 <code>“croak”</code> <em>。</em></p>\n\n<p>请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。</p>\n\n<p>要想发出蛙鸣 \"croak\"，青蛙必须 <strong>依序</strong> 输出 <code>‘c’, ’r’, ’o’, ’a’, ’k’</code> 这 5 个字母。如果没有输出全部五个字母，那么它就不会发出声音。如果字符串 <code>croakOfFrogs</code> 不是由若干有效的 \"croak\" 字符混合而成，请返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>croakOfFrogs = \"croakcroak\"\n<strong>输出：</strong>1 \n<strong>解释：</strong>一只青蛙 “呱呱” 两次\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>croakOfFrogs = \"crcoakroak\"\n<strong>输出：</strong>2 \n<strong>解释：</strong>最少需要两只青蛙，“呱呱” 声用黑体标注\n第一只青蛙 \"<strong>cr</strong>c<strong>oak</strong>roak\"\n第二只青蛙 \"cr<strong>c</strong>oak<strong>roak</strong>\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>croakOfFrogs = \"croakcrook\"\n<strong>输出：</strong>-1\n<strong>解释：</strong>给出的字符串不是 \"croak<strong>\"</strong> 的有效组合。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= croakOfFrogs.length &lt;= 10<sup>5</sup></code></li>\n\t<li>字符串中的字符只有 <code>'c'</code>, <code>'r'</code>, <code>'o'</code>, <code>'a'</code> 或者 <code>'k'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1420.生成数组",
        "hardRate": "HARD",
        "passRate": "63.67%",
        "problemsUrl": "https://leetcode.cn/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/",
        "solutionsUrl": "https://leetcode.cn/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/solution",
        "problemsDesc": "<p>给你三个整数 <code>n</code>、<code>m</code> 和 <code>k</code> 。下图描述的算法用于找出正整数数组中最大的元素。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/19/e.png\" style=\"height: 372px; width: 424px;\"></p>\n\n<p>请你生成一个具有下述属性的数组 <code>arr</code> ：</p>\n\n<ul>\n\t<li><code>arr</code> 中有 <code>n</code> 个整数。</li>\n\t<li><code>1 &lt;= arr[i] &lt;= m</code> 其中 <code>(0 &lt;= i &lt; n)</code> 。</li>\n\t<li>将上面提到的算法应用于 <code>arr</code> ，<code>search_cost</code> 的值等于 <code>k</code> 。</li>\n</ul>\n\n<p>返回上述条件下生成数组 <code>arr</code> 的 <strong>方法数</strong> ，由于答案可能会很大，所以 <strong>必须</strong> 对 <code>10^9 + 7</code> 取余。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, m = 3, k = 1\n<strong>输出：</strong>6\n<strong>解释：</strong>可能的数组分别为 [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 5, m = 2, k = 3\n<strong>输出：</strong>0\n<strong>解释：</strong>没有数组可以满足上述条件\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 9, m = 1, k = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>可能的数组只有 [1, 1, 1, 1, 1, 1, 1, 1, 1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 50, m = 100, k = 25\n<strong>输出：</strong>34549172\n<strong>解释：</strong>不要忘了对 1000000007 取余\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>n = 37, m = 17, k = 7\n<strong>输出：</strong>418930126\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>1 &lt;= m &lt;= 100</code></li>\n\t<li><code>0 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1421.净现值查询",
        "hardRate": "EASY",
        "passRate": "70.99%",
        "problemsUrl": "https://leetcode.cn/problems/npv-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/npv-queries/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1422.分割字符串的最大得分",
        "hardRate": "EASY",
        "passRate": "56.72%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-after-splitting-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-after-splitting-a-string/solution",
        "problemsDesc": "<p>给你一个由若干 0 和 1 组成的字符串 <code>s</code> ，请你计算并返回将该字符串分割成两个 <strong>非空</strong> 子字符串（即&nbsp;<strong>左</strong> 子字符串和 <strong>右</strong> 子字符串）所能获得的最大得分。</p>\n\n<p>「分割字符串的得分」为 <strong>左</strong> 子字符串中 <strong>0</strong> 的数量加上 <strong>右</strong> 子字符串中 <strong>1</strong> 的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;011101&quot;\n<strong>输出：</strong>5 \n<strong>解释：</strong>\n将字符串 s 划分为两个非空子字符串的可行方案有：\n左子字符串 = &quot;0&quot; 且 右子字符串 = &quot;11101&quot;，得分 = 1 + 4 = 5 \n左子字符串 = &quot;01&quot; 且 右子字符串 = &quot;1101&quot;，得分 = 1 + 3 = 4 \n左子字符串 = &quot;011&quot; 且 右子字符串 = &quot;101&quot;，得分 = 1 + 2 = 3 \n左子字符串 = &quot;0111&quot; 且 右子字符串 = &quot;01&quot;，得分 = 1 + 1 = 2 \n左子字符串 = &quot;01110&quot; 且 右子字符串 = &quot;1&quot;，得分 = 2 + 1 = 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;00111&quot;\n<strong>输出：</strong>5\n<strong>解释：</strong>当 左子字符串 = &quot;00&quot; 且 右子字符串 = &quot;111&quot; 时，我们得到最大得分 = 2 + 3 = 5\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1111&quot;\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 500</code></li>\n\t<li>字符串 <code>s</code> 仅由字符 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1423.可获得的最大点数",
        "hardRate": "MEDIUM",
        "passRate": "55.00%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/solution",
        "problemsDesc": "<p>几张卡牌<strong> 排成一行</strong>，每张卡牌都有一个对应的点数。点数由整数数组 <code>cardPoints</code> 给出。</p>\n\n<p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 <code>k</code> 张卡牌。</p>\n\n<p>你的点数就是你拿到手中的所有卡牌的点数之和。</p>\n\n<p>给你一个整数数组 <code>cardPoints</code> 和整数 <code>k</code>，请你返回可以获得的最大点数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>cardPoints = [1,2,3,4,5,6,1], k = 3\n<strong>输出：</strong>12\n<strong>解释：</strong>第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>cardPoints = [2,2,2], k = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>无论你拿起哪两张卡牌，可获得的点数总是 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>cardPoints = [9,7,7,9,7,7,9], k = 7\n<strong>输出：</strong>55\n<strong>解释：</strong>你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>cardPoints = [1,1000,1], k = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。 \n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>cardPoints = [1,79,80,1,1,1,200,1], k = 3\n<strong>输出：</strong>202\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= cardPoints.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= cardPoints[i] &lt;= 10^4</code></li>\n\t<li><code>1 &lt;= k &lt;= cardPoints.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1424.对角线遍历 II",
        "hardRate": "MEDIUM",
        "passRate": "42.29%",
        "problemsUrl": "https://leetcode.cn/problems/diagonal-traverse-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/diagonal-traverse-ii/solution",
        "problemsDesc": "<p>给你一个列表&nbsp;<code>nums</code>&nbsp;，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回&nbsp;<code>nums</code>&nbsp;中对角线上的整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/23/sample_1_1784.png\" style=\"height: 143px; width: 158px;\"></strong></p>\n\n<pre><strong>输入：</strong>nums = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>[1,4,2,7,5,3,8,6,9]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/23/sample_2_1784.png\" style=\"height: 177px; width: 230px;\"></strong></p>\n\n<pre><strong>输入：</strong>nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]\n<strong>输出：</strong>[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]]\n<strong>输出：</strong>[1,4,2,5,3,8,6,9,7,10,11]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums = [[1,2,3,4,5,6]]\n<strong>输出：</strong>[1,2,3,4,5,6]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= nums[i].length &lt;=&nbsp;10^5</code></li>\n\t<li><code>1 &lt;= nums[i][j] &lt;= 10^9</code></li>\n\t<li><code>nums</code>&nbsp;中最多有&nbsp;<code>10^5</code>&nbsp;个数字。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1425.带限制的子序列和",
        "hardRate": "HARD",
        "passRate": "47.61%",
        "problemsUrl": "https://leetcode.cn/problems/constrained-subsequence-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/constrained-subsequence-sum/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;，请你返回 <strong>非空</strong>&nbsp;子序列元素和的最大值，子序列需要满足：子序列中每两个 <strong>相邻</strong>&nbsp;的整数&nbsp;<code>nums[i]</code>&nbsp;和&nbsp;<code>nums[j]</code>&nbsp;，它们在原数组中的下标&nbsp;<code>i</code>&nbsp;和&nbsp;<code>j</code>&nbsp;满足&nbsp;<code>i &lt; j</code>&nbsp;且 <code>j - i &lt;= k</code> 。</p>\n\n<p>数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [10,2,-10,5,20], k = 2\n<strong>输出：</strong>37\n<strong>解释：</strong>子序列为 [10, 2, 5, 20] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [-1,-2,-3], k = 1\n<strong>输出：</strong>-1\n<strong>解释：</strong>子序列必须是非空的，所以我们选择最大的数字。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [10,-2,-10,-5,20], k = 2\n<strong>输出：</strong>23\n<strong>解释：</strong>子序列为 [10, -2, -5, 20] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>-10^4&nbsp;&lt;= nums[i] &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1426.数元素",
        "hardRate": "EASY",
        "passRate": "69.35%",
        "problemsUrl": "https://leetcode.cn/problems/counting-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/counting-elements/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1427.字符串的左右移",
        "hardRate": "EASY",
        "passRate": "58.38%",
        "problemsUrl": "https://leetcode.cn/problems/perform-string-shifts/",
        "solutionsUrl": "https://leetcode.cn/problems/perform-string-shifts/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1428.至少有一个 1 的最左端列",
        "hardRate": "MEDIUM",
        "passRate": "61.42%",
        "problemsUrl": "https://leetcode.cn/problems/leftmost-column-with-at-least-a-one/",
        "solutionsUrl": "https://leetcode.cn/problems/leftmost-column-with-at-least-a-one/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1429.第一个唯一数字",
        "hardRate": "MEDIUM",
        "passRate": "53.23%",
        "problemsUrl": "https://leetcode.cn/problems/first-unique-number/",
        "solutionsUrl": "https://leetcode.cn/problems/first-unique-number/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1430.判断给定的序列是否是二叉树从根到叶的路径",
        "hardRate": "MEDIUM",
        "passRate": "54.51%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1431.拥有最多糖果的孩子",
        "hardRate": "EASY",
        "passRate": "84.56%",
        "problemsUrl": "https://leetcode.cn/problems/kids-with-the-greatest-number-of-candies/",
        "solutionsUrl": "https://leetcode.cn/problems/kids-with-the-greatest-number-of-candies/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>candies</code>&nbsp;和一个整数&nbsp;<code>extraCandies</code>&nbsp;，其中&nbsp;<code>candies[i]</code>&nbsp;代表第 <code>i</code> 个孩子拥有的糖果数目。</p>\n\n<p>对每一个孩子，检查是否存在一种方案，将额外的&nbsp;<code>extraCandies</code>&nbsp;个糖果分配给孩子们之后，此孩子有 <strong>最多</strong>&nbsp;的糖果。注意，允许有多个孩子同时拥有 <strong>最多</strong>&nbsp;的糖果数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>candies = [2,3,5,1,3], extraCandies = 3\n<strong>输出：</strong>[true,true,true,false,true] \n<strong>解释：</strong>\n孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。\n孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。\n孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。\n孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。\n孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>candies = [4,2,1,1,2], extraCandies = 1\n<strong>输出：</strong>[true,false,false,false,false] \n<strong>解释：</strong>只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>candies = [12,1,12], extraCandies = 10\n<strong>输出：</strong>[true,false,true]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= candies.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= candies[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= extraCandies &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1432.改变一个整数能得到的最大差值",
        "hardRate": "MEDIUM",
        "passRate": "39.86%",
        "problemsUrl": "https://leetcode.cn/problems/max-difference-you-can-get-from-changing-an-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/max-difference-you-can-get-from-changing-an-integer/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>num</code>&nbsp;。你可以对它进行如下步骤恰好 <strong>两次</strong>&nbsp;：</p>\n\n<ul>\n\t<li>选择一个数字&nbsp;<code>x (0&nbsp;&lt;= x &lt;= 9)</code>.</li>\n\t<li>选择另一个数字&nbsp;<code>y (0&nbsp;&lt;= y &lt;= 9)</code>&nbsp;。数字&nbsp;<code>y</code>&nbsp;可以等于&nbsp;<code>x</code>&nbsp;。</li>\n\t<li>将 <code>num</code>&nbsp;中所有出现 <code>x</code>&nbsp;的数位都用 <code>y</code>&nbsp;替换。</li>\n\t<li>得到的新的整数 <strong>不能</strong>&nbsp;有前导 0 ，得到的新整数也 <strong>不能</strong>&nbsp;是 0&nbsp;。</li>\n</ul>\n\n<p>令两次对 <code>num</code>&nbsp;的操作得到的结果分别为&nbsp;<code>a</code>&nbsp;和&nbsp;<code>b</code>&nbsp;。</p>\n\n<p>请你返回&nbsp;<code>a</code> 和&nbsp;<code>b</code>&nbsp;的 <strong>最大差值</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 555\n<strong>输出：</strong>888\n<strong>解释：</strong>第一次选择 x = 5 且 y = 9 ，并把得到的新数字保存在 a 中。\n第二次选择 x = 5 且 y = 1 ，并把得到的新数字保存在 b 中。\n现在，我们有 a = 999 和 b = 111 ，最大差值为 888\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 9\n<strong>输出：</strong>8\n<strong>解释：</strong>第一次选择 x = 9 且 y = 9 ，并把得到的新数字保存在 a 中。\n第二次选择 x = 9 且 y = 1 ，并把得到的新数字保存在 b 中。\n现在，我们有 a = 9 和 b = 1 ，最大差值为 8\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = 123456\n<strong>输出：</strong>820000\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>num = 10000\n<strong>输出：</strong>80000\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>num = 9288\n<strong>输出：</strong>8700\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10^8</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1433.检查一个字符串是否可以打破另一个字符串",
        "hardRate": "MEDIUM",
        "passRate": "64.70%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-a-string-can-break-another-string/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-a-string-can-break-another-string/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>s1</code>&nbsp;和&nbsp;<code>s2</code>&nbsp;，它们长度相等，请你检查是否存在一个&nbsp;<code>s1</code>&nbsp; 的排列可以打破 <code>s2</code>&nbsp;的一个排列，或者是否存在一个&nbsp;<code>s2</code>&nbsp;的排列可以打破 <code>s1</code> 的一个排列。</p>\n\n<p>字符串&nbsp;<code>x</code>&nbsp;可以打破字符串&nbsp;<code>y</code>&nbsp;（两者长度都为&nbsp;<code>n</code>&nbsp;）需满足对于所有&nbsp;<code>i</code>（在&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;之间）都有&nbsp;<code>x[i] &gt;= y[i]</code>（字典序意义下的顺序）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s1 = &quot;abc&quot;, s2 = &quot;xya&quot;\n<strong>输出：</strong>true\n<strong>解释：</strong>&quot;ayx&quot; 是 s2=&quot;xya&quot; 的一个排列，&quot;abc&quot; 是字符串 s1=&quot;abc&quot; 的一个排列，且 &quot;ayx&quot; 可以打破 &quot;abc&quot; 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s1 = &quot;abe&quot;, s2 = &quot;acd&quot;\n<strong>输出：</strong>false \n<strong>解释：</strong>s1=&quot;abe&quot; 的所有排列包括：&quot;abe&quot;，&quot;aeb&quot;，&quot;bae&quot;，&quot;bea&quot;，&quot;eab&quot; 和 &quot;eba&quot; ，s2=&quot;acd&quot; 的所有排列包括：&quot;acd&quot;，&quot;adc&quot;，&quot;cad&quot;，&quot;cda&quot;，&quot;dac&quot; 和 &quot;dca&quot;。然而没有任何 s1 的排列可以打破 s2 的排列。也没有 s2 的排列能打破 s1 的排列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s1 = &quot;leetcodee&quot;, s2 = &quot;interview&quot;\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s1.length == n</code></li>\n\t<li><code>s2.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li>所有字符串都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1434.每个人戴不同帽子的方案数",
        "hardRate": "HARD",
        "passRate": "51.71%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-wear-different-hats-to-each-other/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-wear-different-hats-to-each-other/solution",
        "problemsDesc": "<p>总共有 <code>n</code>&nbsp;个人和 <code>40</code> 种不同的帽子，帽子编号从 <code>1</code> 到 <code>40</code> 。</p>\n\n<p>给你一个整数列表的列表&nbsp;<code>hats</code>&nbsp;，其中&nbsp;<code>hats[i]</code>&nbsp;是第 <code>i</code>&nbsp;个人所有喜欢帽子的列表。</p>\n\n<p>请你给每个人安排一顶他喜欢的帽子，确保每个人戴的帽子跟别人都不一样，并返回方案数。</p>\n\n<p>由于答案可能很大，请返回它对&nbsp;<code>10^9 + 7</code>&nbsp;取余后的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>hats = [[3,4],[4,5],[5]]\n<strong>输出：</strong>1\n<strong>解释：</strong>给定条件下只有一种方法选择帽子。\n第一个人选择帽子 3，第二个人选择帽子 4，最后一个人选择帽子 5。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>hats = [[3,5,1],[3,5]]\n<strong>输出：</strong>4\n<strong>解释：</strong>总共有 4 种安排帽子的方法：\n(3,5)，(5,3)，(1,3) 和 (1,5)\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]\n<strong>输出：</strong>24\n<strong>解释：</strong>每个人都可以从编号为 1 到 4 的帽子中选。\n(1,2,3,4) 4 个帽子的排列方案数为 24 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>hats = [[1,2,3],[2,3,5,6],[1,3,7,9],[1,8,9],[2,5,7]]\n<strong>输出：</strong>111\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == hats.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10</code></li>\n\t<li><code>1 &lt;= hats[i].length &lt;= 40</code></li>\n\t<li><code>1 &lt;= hats[i][j] &lt;= 40</code></li>\n\t<li><code>hats[i]</code>&nbsp;包含一个数字互不相同的整数列表。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1435.制作会话柱状图",
        "hardRate": "EASY",
        "passRate": "63.77%",
        "problemsUrl": "https://leetcode.cn/problems/create-a-session-bar-chart/",
        "solutionsUrl": "https://leetcode.cn/problems/create-a-session-bar-chart/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1436.旅行终点站",
        "hardRate": "EASY",
        "passRate": "81.74%",
        "problemsUrl": "https://leetcode.cn/problems/destination-city/",
        "solutionsUrl": "https://leetcode.cn/problems/destination-city/solution",
        "problemsDesc": "<p>给你一份旅游线路图，该线路图中的旅行线路用数组 <code>paths</code> 表示，其中 <code>paths[i] = [cityA<sub>i</sub>, cityB<sub>i</sub>]</code> 表示该线路将会从 <code>cityA<sub>i</sub></code> 直接前往 <code>cityB<sub>i</sub></code> 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市<em>。</em></p>\n\n<p>题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>paths = [[\"London\",\"New York\"],[\"New York\",\"Lima\"],[\"Lima\",\"Sao Paulo\"]]\n<strong>输出：</strong>\"Sao Paulo\" \n<strong>解释：</strong>从 \"London\" 出发，最后抵达终点站 \"Sao Paulo\" 。本次旅行的路线是 \"London\" -&gt; \"New York\" -&gt; \"Lima\" -&gt; \"Sao Paulo\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>paths = [[\"B\",\"C\"],[\"D\",\"B\"],[\"C\",\"A\"]]\n<strong>输出：</strong>\"A\"\n<strong>解释：</strong>所有可能的线路是：\n\"D\" -&gt; \"B\" -&gt; \"C\" -&gt; \"A\".&nbsp;\n\"B\" -&gt; \"C\" -&gt; \"A\".&nbsp;\n\"C\" -&gt; \"A\".&nbsp;\n\"A\".&nbsp;\n显然，旅行终点站是 \"A\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>paths = [[\"A\",\"Z\"]]\n<strong>输出：</strong>\"Z\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= paths.length &lt;= 100</code></li>\n\t<li><code>paths[i].length == 2</code></li>\n\t<li><code>1 &lt;=&nbsp;cityA<sub>i</sub>.length,&nbsp;cityB<sub>i</sub>.length &lt;= 10</code></li>\n\t<li><code>cityA<sub>i&nbsp;</sub>!=&nbsp;cityB<sub>i</sub></code></li>\n\t<li>所有字符串均由大小写英文字母和空格字符组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1437.是否所有 1 都至少相隔 k 个元素",
        "hardRate": "EASY",
        "passRate": "55.52%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-all-1s-are-at-least-length-k-places-away/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-all-1s-are-at-least-length-k-places-away/solution",
        "problemsDesc": "<p>给你一个由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>nums</code> 以及整数 <code>k</code>。如果所有 <code>1</code> 都至少相隔 <code>k</code> 个元素，则返回 <code>True</code> ；否则，返回 <code>False</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/03/sample_1_1791.png\" style=\"width: 214px;\"></strong></p>\n\n<pre><strong>输入：</strong>nums = [1,0,0,0,1,0,0,1], k = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>每个 1 都至少相隔 2 个元素。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/03/sample_2_1791.png\" style=\"height: 86px; width: 160px;\"></strong></p>\n\n<pre><strong>输入：</strong>nums = [1,0,0,1,0,1], k = 2\n<strong>输出：</strong>false\n<strong>解释：</strong>第二个 1 和第三个 1 之间只隔了 1 个元素。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,1,1,1], k = 0\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,0,1], k = 1\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= k &lt;= nums.length</code></li>\n\t<li><code>nums[i]</code> 的值为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1438.绝对差不超过限制的最长连续子数组",
        "hardRate": "MEDIUM",
        "passRate": "49.68%",
        "problemsUrl": "https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，和一个表示限制的整数 <code>limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 <code>limit</code><em> 。</em></p>\n\n<p>如果不存在满足条件的子数组，则返回 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [8,2,4,7], limit = 4\n<strong>输出：</strong>2 \n<strong>解释：</strong>所有子数组如下：\n[8] 最大绝对差 |8-8| = 0 &lt;= 4.\n[8,2] 最大绝对差 |8-2| = 6 &gt; 4. \n[8,2,4] 最大绝对差 |8-2| = 6 &gt; 4.\n[8,2,4,7] 最大绝对差 |8-2| = 6 &gt; 4.\n[2] 最大绝对差 |2-2| = 0 &lt;= 4.\n[2,4] 最大绝对差 |2-4| = 2 &lt;= 4.\n[2,4,7] 最大绝对差 |2-7| = 5 &gt; 4.\n[4] 最大绝对差 |4-4| = 0 &lt;= 4.\n[4,7] 最大绝对差 |4-7| = 3 &lt;= 4.\n[7] 最大绝对差 |7-7| = 0 &lt;= 4. \n因此，满足题意的最长子数组的长度为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [10,1,2,4,7,2], limit = 5\n<strong>输出：</strong>4 \n<strong>解释：</strong>满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 &lt;= 5 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,2,2,2,4,4,2,2], limit = 0\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>\n\t<li><code>0 &lt;= limit &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1439.有序矩阵中的第 k 个最小数组和",
        "hardRate": "HARD",
        "passRate": "66.46%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/solution",
        "problemsDesc": "<p>给你一个 <code>m&nbsp;* n</code> 的矩阵 <code>mat</code>，以及一个整数 <code>k</code> ，矩阵中的每一行都以非递减的顺序排列。</p>\n\n<p>你可以从每一行中选出 1 个元素形成一个数组。返回所有可能数组中的第 k 个 <strong>最小</strong> 数组和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[1,3,11],[2,4,6]], k = 5\n<strong>输出：</strong>7\n<strong>解释：</strong>从每一行中选出一个元素，前 k 个和最小的数组分别是：\n[1,2], [1,4], [3,2], [3,4], [1,6]。其中第 5 个的和是 7 。  </pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[1,3,11],[2,4,6]], k = 9\n<strong>输出：</strong>17\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7\n<strong>输出：</strong>9\n<strong>解释：</strong>从每一行中选出一个元素，前 k 个和最小的数组分别是：\n[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]。其中第 7 个的和是 9 。 \n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[1,1,10],[2,2,9]], k = 7\n<strong>输出：</strong>12\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat.length[i]</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 40</code></li>\n\t<li><code>1 &lt;= k &lt;= min(200, n ^&nbsp;m)</code></li>\n\t<li><code>1 &lt;= mat[i][j] &lt;= 5000</code></li>\n\t<li><code>mat[i]</code> 是一个非递减数组</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1440.计算布尔表达式的值",
        "hardRate": "MEDIUM",
        "passRate": "69.74%",
        "problemsUrl": "https://leetcode.cn/problems/evaluate-boolean-expression/",
        "solutionsUrl": "https://leetcode.cn/problems/evaluate-boolean-expression/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1441.用栈操作构建数组",
        "hardRate": "MEDIUM",
        "passRate": "71.55%",
        "problemsUrl": "https://leetcode.cn/problems/build-an-array-with-stack-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/build-an-array-with-stack-operations/solution",
        "problemsDesc": "<p>给你一个数组 <code>target</code> 和一个整数 <code>n</code>。每次迭代，需要从&nbsp; <code>list = { 1 , 2 , 3 ..., n }</code> 中依次读取一个数字。</p>\n\n<p>请使用下述操作来构建目标数组 <code>target</code> ：</p>\n\n<ul>\n\t<li><code>\"Push\"</code>：从 <code>list</code> 中读取一个新元素， 并将其推入数组中。</li>\n\t<li><code>\"Pop\"</code>：删除数组中的最后一个元素。</li>\n\t<li>如果目标数组构建完成，就停止读取更多元素。</li>\n</ul>\n\n<p>题目数据保证目标数组严格递增，并且只包含 <code>1</code> 到 <code>n</code> 之间的数字。</p>\n\n<p>请返回构建目标数组所用的操作序列。如果存在多个可行方案，返回任一即可。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = [1,3], n = 3\n<strong>输出：</strong>[\"Push\",\"Push\",\"Pop\",\"Push\"]\n<strong>解释： \n</strong>读取 1 并自动推入数组 -&gt; [1]\n读取 2 并自动推入数组，然后删除它 -&gt; [1]\n读取 3 并自动推入数组 -&gt; [1,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = [1,2,3], n = 3\n<strong>输出：</strong>[\"Push\",\"Push\",\"Push\"]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = [1,2], n = 4\n<strong>输出：</strong>[\"Push\",\"Push\"]\n<strong>解释：</strong>只需要读取前 2 个数字就可以停止。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= target[i] &lt;= n</code></li>\n\t<li><code>target</code> 严格递增</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1442.形成两个异或相等数组的三元组数目",
        "hardRate": "MEDIUM",
        "passRate": "79.33%",
        "problemsUrl": "https://leetcode.cn/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/",
        "solutionsUrl": "https://leetcode.cn/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> 。</p>\n\n<p>现需要从数组中取三个下标 <code>i</code>、<code>j</code> 和 <code>k</code> ，其中 <code>(0 &lt;= i &lt; j &lt;= k &lt; arr.length)</code> 。</p>\n\n<p><code>a</code> 和 <code>b</code> 定义如下：</p>\n\n<ul>\n\t<li><code>a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]</code></li>\n\t<li><code>b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]</code></li>\n</ul>\n\n<p>注意：<strong>^</strong> 表示 <strong>按位异或</strong> 操作。</p>\n\n<p>请返回能够令 <code>a == b</code> 成立的三元组 (<code>i</code>, <code>j</code> , <code>k</code>) 的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,3,1,6,7]\n<strong>输出：</strong>4\n<strong>解释：</strong>满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4)\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,1,1,1,1]\n<strong>输出：</strong>10\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,3]\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,3,5,7,9]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [7,11,12,9,5,2,7,17,22]\n<strong>输出：</strong>8\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10^8</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1443.收集树上所有苹果的最少时间",
        "hardRate": "MEDIUM",
        "passRate": "43.10%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-collect-all-apples-in-a-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-collect-all-apples-in-a-tree/solution",
        "problemsDesc": "<p>给你一棵有&nbsp;<code>n</code>&nbsp;个节点的无向树，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n-1</code>&nbsp;，它们中有一些节点有苹果。通过树上的一条边，需要花费 1 秒钟。你从&nbsp;<strong>节点 0&nbsp;</strong>出发，请你返回最少需要多少秒，可以收集到所有苹果，并回到节点 0 。</p>\n\n<p>无向树的边由&nbsp;<code>edges</code>&nbsp;给出，其中&nbsp;<code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>]</code>&nbsp;，表示有一条边连接&nbsp;<code>from</code>&nbsp;和&nbsp;<code>to<sub>i</sub></code> 。除此以外，还有一个布尔数组&nbsp;<code>hasApple</code> ，其中&nbsp;<code>hasApple[i] = true</code>&nbsp;代表节点&nbsp;<code>i</code>&nbsp;有一个苹果，否则，节点&nbsp;<code>i</code>&nbsp;没有苹果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/10/min_time_collect_apple_1.png\" style=\"height: 212px; width: 300px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n<strong>输出：</strong>8 \n<strong>解释：</strong>上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/10/min_time_collect_apple_2.png\" style=\"height: 212px; width: 300px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n<strong>输出：</strong>6\n<strong>解释：</strong>上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>&nbsp;&lt; b<sub>i</sub>&nbsp;&lt;= n - 1</code></li>\n\t<li><code>hasApple.length == n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1444.切披萨的方案数",
        "hardRate": "HARD",
        "passRate": "54.30%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-of-cutting-a-pizza/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-of-cutting-a-pizza/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>rows x cols</code>&nbsp;大小的矩形披萨和一个整数 <code>k</code>&nbsp;，矩形包含两种字符：&nbsp;<code>&#39;A&#39;</code> （表示苹果）和&nbsp;<code>&#39;.&#39;</code>&nbsp;（表示空白格子）。你需要切披萨 <code>k-1</code> 次，得到&nbsp;<code>k</code>&nbsp;块披萨并送给别人。</p>\n\n<p>切披萨的每一刀，先要选择是向垂直还是水平方向切，再在矩形的边界上选一个切的位置，将披萨一分为二。如果垂直地切披萨，那么需要把左边的部分送给一个人，如果水平地切，那么需要把上面的部分送给一个人。在切完最后一刀后，需要把剩下来的一块送给最后一个人。</p>\n\n<p>请你返回确保每一块披萨包含&nbsp;<strong>至少</strong>&nbsp;一个苹果的切披萨方案数。由于答案可能是个很大的数字，请你返回它对 10^9 + 7 取余的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/10/ways_to_cut_apple_1.png\" style=\"height: 378px; width: 500px;\"></strong></p>\n\n<pre><strong>输入：</strong>pizza = [&quot;A..&quot;,&quot;AAA&quot;,&quot;...&quot;], k = 3\n<strong>输出：</strong>3 \n<strong>解释：</strong>上图展示了三种切披萨的方案。注意每一块披萨都至少包含一个苹果。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>pizza = [&quot;A..&quot;,&quot;AA.&quot;,&quot;...&quot;], k = 3\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>pizza = [&quot;A..&quot;,&quot;A..&quot;,&quot;...&quot;], k = 1\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rows, cols &lt;= 50</code></li>\n\t<li><code>rows ==&nbsp;pizza.length</code></li>\n\t<li><code>cols ==&nbsp;pizza[i].length</code></li>\n\t<li><code>1 &lt;= k &lt;= 10</code></li>\n\t<li><code>pizza</code>&nbsp;只包含字符&nbsp;<code>&#39;A&#39;</code>&nbsp;和&nbsp;<code>&#39;.&#39;</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1445.苹果和桔子",
        "hardRate": "MEDIUM",
        "passRate": "84.16%",
        "problemsUrl": "https://leetcode.cn/problems/apples-oranges/",
        "solutionsUrl": "https://leetcode.cn/problems/apples-oranges/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1446.连续字符",
        "hardRate": "EASY",
        "passRate": "60.26%",
        "problemsUrl": "https://leetcode.cn/problems/consecutive-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/consecutive-characters/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，字符串的<strong>「能量」</strong>定义为：只包含一种字符的最长非空子字符串的长度。</p>\n\n<p>请你返回字符串 <code>s</code> 的 <strong>能量</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"leetcode\"\n<strong>输出：</strong>2\n<strong>解释：</strong>子字符串 \"ee\" 长度为 2 ，只包含字符 'e' 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abbcccddddeeeeedcba\"\n<strong>输出：</strong>5\n<strong>解释：</strong>子字符串 \"eeeee\" 长度为 5 ，只包含字符 'e' 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1447.最简分数",
        "hardRate": "MEDIUM",
        "passRate": "67.50%",
        "problemsUrl": "https://leetcode.cn/problems/simplified-fractions/",
        "solutionsUrl": "https://leetcode.cn/problems/simplified-fractions/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于&nbsp;&nbsp;<code>n</code>&nbsp;的 <strong>最简&nbsp;</strong>分数&nbsp;。分数可以以 <strong>任意&nbsp;</strong>顺序返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>[&quot;1/2&quot;]\n<strong>解释：</strong>&quot;1/2&quot; 是唯一一个分母小于等于 2 的最简分数。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 3\n<strong>输出：</strong>[&quot;1/2&quot;,&quot;1/3&quot;,&quot;2/3&quot;]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 4\n<strong>输出：</strong>[&quot;1/2&quot;,&quot;1/3&quot;,&quot;1/4&quot;,&quot;2/3&quot;,&quot;3/4&quot;]\n<strong>解释：</strong>&quot;2/4&quot; 不是最简分数，因为它可以化简为 &quot;1/2&quot; 。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1448.统计二叉树中好节点的数目",
        "hardRate": "MEDIUM",
        "passRate": "71.49%",
        "problemsUrl": "https://leetcode.cn/problems/count-good-nodes-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/count-good-nodes-in-binary-tree/solution",
        "problemsDesc": "<p>给你一棵根为&nbsp;<code>root</code>&nbsp;的二叉树，请你返回二叉树中好节点的数目。</p>\n\n<p>「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/16/test_sample_1.png\" style=\"height: 156px; width: 263px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [3,1,4,3,null,1,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>图中蓝色节点为好节点。\n根节点 (3) 永远是个好节点。\n节点 4 -&gt; (3,4) 是路径中的最大值。\n节点 5 -&gt; (3,4,5) 是路径中的最大值。\n节点 3 -&gt; (3,1,3) 是路径中的最大值。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/16/test_sample_2.png\" style=\"height: 161px; width: 157px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [3,3,null,4,2]\n<strong>输出：</strong>3\n<strong>解释：</strong>节点 2 -&gt; (3, 3, 2) 不是好节点，因为 &quot;3&quot; 比它大。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>root = [1]\n<strong>输出：</strong>1\n<strong>解释：</strong>根节点是好节点。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉树中节点数目范围是&nbsp;<code>[1, 10^5]</code>&nbsp;。</li>\n\t<li>每个节点权值的范围是&nbsp;<code>[-10^4, 10^4]</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1449.数位成本和为目标值的最大数字",
        "hardRate": "HARD",
        "passRate": "62.28%",
        "problemsUrl": "https://leetcode.cn/problems/form-largest-integer-with-digits-that-add-up-to-target/",
        "solutionsUrl": "https://leetcode.cn/problems/form-largest-integer-with-digits-that-add-up-to-target/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>cost</code> 和一个整数 <code>target</code> 。请你返回满足如下规则可以得到的 <strong>最大</strong> 整数：</p>\n\n<ul>\n\t<li>给当前结果添加一个数位（<code>i + 1</code>）的成本为 <code>cost[i]</code> （<code>cost</code> 数组下标从 0 开始）。</li>\n\t<li>总成本必须恰好等于 <code>target</code> 。</li>\n\t<li>添加的数位中没有数字 0 。</li>\n</ul>\n\n<p>由于答案可能会很大，请你以字符串形式返回。</p>\n\n<p>如果按照上述要求无法得到任何整数，请你返回 \"0\" 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>cost = [4,3,2,5,6,7,2,5,5], target = 9\n<strong>输出：</strong>\"7772\"\n<strong>解释：</strong>添加数位 '7' 的成本为 2 ，添加数位 '2' 的成本为 3 。所以 \"7772\" 的代价为 2*3+ 3*1 = 9 。 \"977\" 也是满足要求的数字，但 \"7772\" 是较大的数字。\n<strong> 数字     成本</strong>\n  1  ->   4\n  2  ->   3\n  3  ->   2\n  4  ->   5\n  5  ->   6\n  6  ->   7\n  7  ->   2\n  8  ->   5\n  9  ->   5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>cost = [7,6,5,5,5,6,8,7,8], target = 12\n<strong>输出：</strong>\"85\"\n<strong>解释：</strong>添加数位 '8' 的成本是 7 ，添加数位 '5' 的成本是 5 。\"85\" 的成本为 7 + 5 = 12 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>cost = [2,4,6,2,4,6,4,4,4], target = 5\n<strong>输出：</strong>\"0\"\n<strong>解释：</strong>总成本是 target 的条件下，无法生成任何整数。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>cost = [6,10,15,40,40,40,40,40,40], target = 47\n<strong>输出：</strong>\"32211\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>cost.length == 9</code></li>\n\t<li><code>1 <= cost[i] <= 5000</code></li>\n\t<li><code>1 <= target <= 5000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1450.在既定时间做作业的学生人数",
        "hardRate": "EASY",
        "passRate": "82.37%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/solution",
        "problemsDesc": "<p>给你两个整数数组 <code>startTime</code>（开始时间）和 <code>endTime</code>（结束时间），并指定一个整数 <code>queryTime</code> 作为查询时间。</p>\n\n<p>已知，第 <code>i</code> 名学生在 <code>startTime[i]</code> 时开始写作业并于 <code>endTime[i]</code> 时完成作业。</p>\n\n<p>请返回在查询时间 <code>queryTime</code> 时正在做作业的学生人数。形式上，返回能够使 <code>queryTime</code> 处于区间 <code>[startTime[i], endTime[i]]</code>（含）的学生人数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>startTime = [1,2,3], endTime = [3,2,7], queryTime = 4\n<strong>输出：</strong>1\n<strong>解释：</strong>一共有 3 名学生。\n第一名学生在时间 1 开始写作业，并于时间 3 完成作业，在时间 4 没有处于做作业的状态。\n第二名学生在时间 2 开始写作业，并于时间 2 完成作业，在时间 4 没有处于做作业的状态。\n第三名学生在时间 3 开始写作业，预计于时间 7 完成作业，这是是唯一一名在时间 4 时正在做作业的学生。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>startTime = [4], endTime = [4], queryTime = 4\n<strong>输出：</strong>1\n<strong>解释：</strong>在查询时间只有一名学生在做作业。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>startTime = [4], endTime = [4], queryTime = 5\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>startTime = [1,1,1,1], endTime = [1,3,2,4], queryTime = 7\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>startTime = [9,8,7,6,5,4,3,2,1], endTime = [10,10,10,10,10,10,10,10,10], queryTime = 5\n<strong>输出：</strong>5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>startTime.length == endTime.length</code></li>\n\t<li><code>1 &lt;= startTime.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= startTime[i] &lt;= endTime[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;=&nbsp;queryTime &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1451.重新排列句子中的单词",
        "hardRate": "MEDIUM",
        "passRate": "53.94%",
        "problemsUrl": "https://leetcode.cn/problems/rearrange-words-in-a-sentence/",
        "solutionsUrl": "https://leetcode.cn/problems/rearrange-words-in-a-sentence/solution",
        "problemsDesc": "<p>「句子」是一个用空格分隔单词的字符串。给你一个满足下述格式的句子 <code>text</code> :</p>\n\n<ul>\n\t<li>句子的首字母大写</li>\n\t<li><code>text</code> 中的每个单词都用单个空格分隔。</li>\n</ul>\n\n<p>请你重新排列 <code>text</code> 中的单词，使所有单词按其长度的升序排列。如果两个单词的长度相同，则保留其在原句子中的相对顺序。</p>\n\n<p>请同样按上述格式返回新的句子。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;Leetcode is cool&quot;\n<strong>输出：</strong>&quot;Is cool leetcode&quot;\n<strong>解释：</strong>句子中共有 3 个单词，长度为 8 的 &quot;Leetcode&quot; ，长度为 2 的 &quot;is&quot; 以及长度为 4 的 &quot;cool&quot; 。\n输出需要按单词的长度升序排列，新句子中的第一个单词首字母需要大写。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;Keep calm and code on&quot;\n<strong>输出：</strong>&quot;On and keep calm code&quot;\n<strong>解释：</strong>输出的排序情况如下：\n&quot;On&quot; 2 个字母。\n&quot;and&quot; 3 个字母。\n&quot;keep&quot; 4 个字母，因为存在长度相同的其他单词，所以它们之间需要保留在原句子中的相对顺序。\n&quot;calm&quot; 4 个字母。\n&quot;code&quot; 4 个字母。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;To be or not to be&quot;\n<strong>输出：</strong>&quot;To be or to be not&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>text</code> 以大写字母开头，然后包含若干小写字母以及单词间的单个空格。</li>\n\t<li><code>1 &lt;= text.length &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1452.收藏清单",
        "hardRate": "MEDIUM",
        "passRate": "51.08%",
        "problemsUrl": "https://leetcode.cn/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/",
        "solutionsUrl": "https://leetcode.cn/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/solution",
        "problemsDesc": "<p>给你一个数组 <code>favoriteCompanies</code> ，其中 <code>favoriteCompanies[i]</code> 是第 <code>i</code> 名用户收藏的公司清单（<strong>下标从 0 开始</strong>）。</p>\n\n<p>请找出不是其他任何人收藏的公司清单的子集的收藏清单，并返回该清单下标<em>。</em>下标需要按升序排列<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>favoriteCompanies = [[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;],[&quot;google&quot;,&quot;microsoft&quot;],[&quot;google&quot;,&quot;facebook&quot;],[&quot;google&quot;],[&quot;amazon&quot;]]\n<strong>输出：</strong>[0,1,4] \n<strong>解释：</strong>\nfavoriteCompanies[2]=[&quot;google&quot;,&quot;facebook&quot;] 是 favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;] 的子集。\nfavoriteCompanies[3]=[&quot;google&quot;] 是 favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;] 和 favoriteCompanies[1]=[&quot;google&quot;,&quot;microsoft&quot;] 的子集。\n其余的收藏清单均不是其他任何人收藏的公司清单的子集，因此，答案为 [0,1,4] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>favoriteCompanies = [[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;],[&quot;leetcode&quot;,&quot;amazon&quot;],[&quot;facebook&quot;,&quot;google&quot;]]\n<strong>输出：</strong>[0,1] \n<strong>解释：</strong>favoriteCompanies[2]=[&quot;facebook&quot;,&quot;google&quot;] 是 favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;] 的子集，因此，答案为 [0,1] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>favoriteCompanies = [[&quot;leetcode&quot;],[&quot;google&quot;],[&quot;facebook&quot;],[&quot;amazon&quot;]]\n<strong>输出：</strong>[0,1,2,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;favoriteCompanies.length &lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;favoriteCompanies[i].length &lt;= 500</code></li>\n\t<li><code>1 &lt;=&nbsp;favoriteCompanies[i][j].length &lt;= 20</code></li>\n\t<li><code>favoriteCompanies[i]</code> 中的所有字符串 <strong>各不相同</strong> 。</li>\n\t<li>用户收藏的公司清单也 <strong>各不相同</strong> ，也就是说，即便我们按字母顺序排序每个清单， <code>favoriteCompanies[i] != favoriteCompanies[j] </code>仍然成立。</li>\n\t<li>所有字符串仅包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1453.圆形靶内的最大飞镖数量",
        "hardRate": "HARD",
        "passRate": "37.81%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/solution",
        "problemsDesc": "<p>Alice 向一面非常大的墙上掷出 <code>n</code> 支飞镖。给你一个数组 <code>darts</code> ，其中 <code>darts[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示 Alice 掷出的第 <code>i</code> 支飞镖落在墙上的位置。</p>\n\n<p>Bob 知道墙上所有 <code>n</code> 支飞镖的位置。他想要往墙上放置一个半径为 <code>r</code> 的圆形靶。使 Alice 掷出的飞镖尽可能多地落在靶上。</p>\n\n<p>给你整数 <code>r</code> ，请返回能够落在 <strong>任意</strong> 半径为 <code>r</code> 的圆形靶内或靶上的最大飞镖数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1 ：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/04/29/sample_1_1806.png\" style=\"width: 248px; height: 211px;\" />\n<pre>\n<strong>输入：</strong>darts = [[-2,0],[2,0],[0,2],[0,-2]], r = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>如果圆形靶的圆心为 (0,0) ，半径为 2 ，所有的飞镖都落在靶上，此时落在靶上的飞镖数最大，值为 4 。\n</pre>\n\n<p><strong class=\"example\">示例 2 ：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/04/29/sample_2_1806.png\" style=\"width: 306px; height: 244px;\" />\n<pre>\n<strong>输入：</strong>darts = [[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], r = 5\n<strong>输出：</strong>5\n<strong>解释：</strong>如果圆形靶的圆心为 (0,4) ，半径为 5 ，则除了 (7,8) 之外的飞镖都落在靶上，此时落在靶上的飞镖数最大，值为 5 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= darts.length &lt;= 100</code></li>\n\t<li><code>darts[i].length == 2</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li><code>darts</code> 中的元素互不相同</li>\n\t<li><code>1 &lt;= r &lt;= 5000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1454.活跃用户",
        "hardRate": "MEDIUM",
        "passRate": "38.23%",
        "problemsUrl": "https://leetcode.cn/problems/active-users/",
        "solutionsUrl": "https://leetcode.cn/problems/active-users/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1455.检查单词是否为句中其他单词的前缀",
        "hardRate": "EASY",
        "passRate": "64.80%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/solution",
        "problemsDesc": "<p>给你一个字符串 <code>sentence</code> 作为句子并指定检索词为 <code>searchWord</code> ，其中句子由若干用 <strong>单个空格</strong> 分隔的单词组成。请你检查检索词 <code>searchWord</code> 是否为句子 <code>sentence</code> 中任意单词的前缀。</p>\n\n<p>如果&nbsp;<code>searchWord</code> 是某一个单词的前缀，则返回句子&nbsp;<code>sentence</code> 中该单词所对应的下标（<strong>下标从 1 开始</strong>）。如果 <code>searchWord</code> 是多个单词的前缀，则返回匹配的第一个单词的下标（<strong>最小下标</strong>）。如果 <code>searchWord</code> 不是任何单词的前缀，则返回 <code>-1</code><strong> </strong>。</p>\n\n<p>字符串 <code>s</code> 的 <strong>前缀</strong> 是 <code>s</code> 的任何前导连续子字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"i love eating burger\", searchWord = \"burg\"\n<strong>输出：</strong>4\n<strong>解释：</strong>\"burg\" 是 \"burger\" 的前缀，而 \"burger\" 是句子中第 4 个单词。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"this problem is an easy problem\", searchWord = \"pro\"\n<strong>输出：</strong>2\n<strong>解释：</strong>\"pro\" 是 \"problem\" 的前缀，而 \"problem\" 是句子中第 2 个也是第 6 个单词，但是应该返回最小下标 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"i am tired\", searchWord = \"you\"\n<strong>输出：</strong>-1\n<strong>解释：</strong>\"you\" 不是句子中任何单词的前缀。\n\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentence.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= searchWord.length &lt;= 10</code></li>\n\t<li><code>sentence</code> 由小写英文字母和空格组成。</li>\n\t<li><code>searchWord</code> 由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1456.定长子串中元音的最大数目",
        "hardRate": "MEDIUM",
        "passRate": "54.70%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solution",
        "problemsDesc": "<p>给你字符串 <code>s</code> 和整数 <code>k</code> 。</p>\n\n<p>请返回字符串 <code>s</code> 中长度为 <code>k</code> 的单个子字符串中可能包含的最大元音字母数。</p>\n\n<p>英文中的 <strong>元音字母 </strong>为（<code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abciiidef&quot;, k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>子字符串 &quot;iii&quot; 包含 3 个元音字母。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aeiou&quot;, k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>任意长度为 2 的子字符串都包含 2 个元音字母。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;leetcode&quot;, k = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>&quot;lee&quot;、&quot;eet&quot; 和 &quot;ode&quot; 都包含 2 个元音字母。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;rhythms&quot;, k = 4\n<strong>输出：</strong>0\n<strong>解释：</strong>字符串 s 中不含任何元音字母。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;tryhard&quot;, k = 4\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n\t<li><code>1 &lt;= k &lt;= s.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1457.二叉树中的伪回文路径",
        "hardRate": "MEDIUM",
        "passRate": "62.09%",
        "problemsUrl": "https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/solution",
        "problemsDesc": "<p>给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「<strong>伪回文</strong>」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。</p>\n\n<p>请你返回从根到叶子节点的所有路径中&nbsp;<strong>伪回文&nbsp;</strong>路径的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/23/palindromic_paths_1.png\" style=\"height: 201px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [2,3,1,3,1,null,1]\n<strong>输出：</strong>2 \n<strong>解释：</strong>上图为给定的二叉树。总共有 3 条从根到叶子的路径：红色路径 [2,3,3] ，绿色路径 [2,1,1] 和路径 [2,3,1] 。\n     在这些路径中，只有红色和绿色的路径是伪回文路径，因为红色路径 [2,3,3] 存在回文排列 [3,2,3] ，绿色路径 [2,1,1] 存在回文排列 [1,2,1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/23/palindromic_paths_2.png\" style=\"height: 314px; width: 300px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [2,1,1,1,3,null,null,null,null,null,1]\n<strong>输出：</strong>1 \n<strong>解释：</strong>上图为给定二叉树。总共有 3 条从根到叶子的路径：绿色路径 [2,1,1] ，路径 [2,1,3,1] 和路径 [2,1] 。\n     这些路径中只有绿色路径是伪回文路径，因为 [2,1,1] 存在回文排列 [1,2,1] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [9]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给定二叉树的节点数目在范围&nbsp;<code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1458.两个子序列的最大点积",
        "hardRate": "HARD",
        "passRate": "46.91%",
        "problemsUrl": "https://leetcode.cn/problems/max-dot-product-of-two-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/max-dot-product-of-two-subsequences/solution",
        "problemsDesc": "<p>给你两个数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>&nbsp;。</p>\n\n<p>请你返回 <code>nums1</code> 和 <code>nums2</code> 中两个长度相同的 <strong>非空</strong> 子序列的最大点积。</p>\n\n<p>数组的非空子序列是通过删除原数组中某些元素（可能一个也不删除）后剩余数字组成的序列，但不能改变数字间相对顺序。比方说，<code>[2,3,5]</code>&nbsp;是&nbsp;<code>[1,2,3,4,5]</code>&nbsp;的一个子序列而&nbsp;<code>[1,5,3]</code>&nbsp;不是。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [2,1,-2,5], nums2 = [3,0,-6]\n<strong>输出：</strong>18\n<strong>解释：</strong>从 nums1 中得到子序列 [2,-2] ，从 nums2 中得到子序列 [3,-6] 。\n它们的点积为 (2*3 + (-2)*(-6)) = 18 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [3,-2], nums2 = [2,-6,7]\n<strong>输出：</strong>21\n<strong>解释：</strong>从 nums1 中得到子序列 [3] ，从 nums2 中得到子序列 [7] 。\n它们的点积为 (3*7) = 21 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [-1,-1], nums2 = [1,1]\n<strong>输出：</strong>-1\n<strong>解释：</strong>从 nums1 中得到子序列 [-1] ，从 nums2 中得到子序列 [1] 。\n它们的点积为 -1 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 500</code></li>\n\t<li><code>-1000 &lt;= nums1[i], nums2[i] &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>点积：</strong></p>\n\n<pre>\n定义 <code><strong>a</strong>&nbsp;= [<em>a</em><sub>1</sub>,&nbsp;<em>a</em><sub>2</sub>,…,&nbsp;<em>a</em><sub><em>n</em></sub>]</code> 和<strong> <code>b</code></strong><code>&nbsp;= [<em>b</em><sub>1</sub>,&nbsp;<em>b</em><sub>2</sub>,…,&nbsp;<em>b</em><sub><em>n</em></sub>]</code> 的点积为：\n\n<img alt=\"\\mathbf{a}\\cdot \\mathbf{b} = \\sum_{i=1}^n a_ib_i = a_1b_1 + a_2b_2 + \\cdots + a_nb_n \" class=\"tex\" src=\"https://pic.leetcode-cn.com/1666164309-PBJMQp-image.png\" />\n\n这里的 <strong>Σ</strong> 指示总和符号。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1459.矩形面积",
        "hardRate": "MEDIUM",
        "passRate": "62.62%",
        "problemsUrl": "https://leetcode.cn/problems/rectangles-area/",
        "solutionsUrl": "https://leetcode.cn/problems/rectangles-area/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1460.通过翻转子数组使两个数组相等",
        "hardRate": "EASY",
        "passRate": "77.16%",
        "problemsUrl": "https://leetcode.cn/problems/make-two-arrays-equal-by-reversing-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/make-two-arrays-equal-by-reversing-subarrays/solution",
        "problemsDesc": "<p>给你两个长度相同的整数数组&nbsp;<code>target</code>&nbsp;和&nbsp;<code>arr</code>&nbsp;。每一步中，你可以选择&nbsp;<code>arr</code>&nbsp;的任意 <strong>非空子数组</strong>&nbsp;并将它翻转。你可以执行此过程任意次。</p>\n\n<p><em>如果你能让 <code>arr</code>&nbsp;变得与 <code>target</code>&nbsp;相同，返回 True；否则，返回 False 。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = [1,2,3,4], arr = [2,4,1,3]\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以按照如下步骤使 arr 变成 target：\n1- 翻转子数组 [2,4,1] ，arr 变成 [1,4,2,3]\n2- 翻转子数组 [4,2] ，arr 变成 [1,2,4,3]\n3- 翻转子数组 [4,3] ，arr 变成 [1,2,3,4]\n上述方法并不是唯一的，还存在多种将 arr 变成 target 的方法。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = [7], arr = [7]\n<strong>输出：</strong>true\n<strong>解释：</strong>arr 不需要做任何翻转已经与 target 相等。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = [3,7,9], arr = [3,7,11]\n<strong>输出：</strong>false\n<strong>解释：</strong>arr 没有数字 9 ，所以无论如何也无法变成 target 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>target.length == arr.length</code></li>\n\t<li><code>1 &lt;= target.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= target[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1461.检查一个字符串是否包含所有长度为 K 的二进制子串",
        "hardRate": "MEDIUM",
        "passRate": "52.52%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-a-string-contains-all-binary-codes-of-size-k/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-a-string-contains-all-binary-codes-of-size-k/solution",
        "problemsDesc": "<p>给你一个二进制字符串&nbsp;<code>s</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。如果所有长度为 <code>k</code>&nbsp;的二进制字符串都是 <code>s</code>&nbsp;的子串，请返回 <code>true</code> ，否则请返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"00110110\", k = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>长度为 2 的二进制串包括 \"00\"，\"01\"，\"10\" 和 \"11\"。它们分别是 s 中下标为 0，1，3，2 开始的长度为 2 的子串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0110\", k = 1\n<strong>输出：</strong>true\n<strong>解释：</strong>长度为 1 的二进制串包括 \"0\" 和 \"1\"，显然它们都是 s 的子串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0110\", k = 2\n<strong>输出：</strong>false\n<strong>解释：</strong>长度为 2 的二进制串 \"00\" 没有出现在 s 中。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 不是<code>'0'</code> 就是 <code>'1'</code></li>\n\t<li><code>1 &lt;= k &lt;= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1462.课程表 IV",
        "hardRate": "MEDIUM",
        "passRate": "45.77%",
        "problemsUrl": "https://leetcode.cn/problems/course-schedule-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/course-schedule-iv/solution",
        "problemsDesc": "<p>你总共需要上<meta charset=\"UTF-8\" />&nbsp;<code>numCourses</code>&nbsp;门课，课程编号依次为 <code>0</code>&nbsp;到&nbsp;<code>numCourses-1</code>&nbsp;。你会得到一个数组&nbsp;<code>prerequisite</code> ，其中<meta charset=\"UTF-8\" />&nbsp;<code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示如果你想选<meta charset=\"UTF-8\" />&nbsp;<code>b<sub>i</sub></code> 课程，你<strong> 必须</strong> 先选<meta charset=\"UTF-8\" />&nbsp;<code>a<sub>i</sub></code>&nbsp;课程。</p>\n\n<ul>\n\t<li>有的课会有直接的先修课程，比如如果想上课程 <code>1</code>&nbsp;，你必须先上课程 <code>0</code>&nbsp;，那么会以 <code>[0,1]</code>&nbsp;数对的形式给出先修课程数对。</li>\n</ul>\n\n<p>先决条件也可以是 <strong>间接</strong> 的。如果课程 <code>a</code> 是课程 <code>b</code> 的先决条件，课程 <code>b</code> 是课程 <code>c</code> 的先决条件，那么课程 <code>a</code> 就是课程 <code>c</code> 的先决条件。</p>\n\n<p>你也得到一个数组<meta charset=\"UTF-8\" />&nbsp;<code>queries</code>&nbsp;，其中<meta charset=\"UTF-8\" />&nbsp;<code>queries[j] = [u<sub>j</sub>, v<sub>j</sub>]</code>。对于第 <code>j</code> 个查询，您应该回答课程<meta charset=\"UTF-8\" />&nbsp;<code>u<sub>j</sub></code>&nbsp;是否是课程<meta charset=\"UTF-8\" />&nbsp;<code>v<sub>j</sub></code>&nbsp;的先决条件。</p>\n\n<p>返回一个布尔数组 <code>answer</code> ，其中 <code>answer[j]</code> 是第 <code>j</code> 个查询的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/01/courses4-1-graph.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]\n<strong>输出：</strong>[false,true]\n<strong>解释：</strong>课程 0 不是课程 1 的先修课程，但课程 1 是课程 0 的先修课程。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>numCourses = 2, prerequisites = [], queries = [[1,0],[0,1]]\n<strong>输出：</strong>[false,false]\n<strong>解释：</strong>没有先修课程对，所以每门课程之间是独立的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/01/courses4-3-graph.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]]\n<strong>输出：</strong>[true,true]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>2 &lt;= numCourses &lt;= 100</code></li>\n\t<li><code>0 &lt;= prerequisites.length &lt;= (numCourses * (numCourses - 1) / 2)</code></li>\n\t<li><code>prerequisites[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub>&nbsp;&lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub>&nbsp;!= b<sub>i</sub></code></li>\n\t<li>每一对<meta charset=\"UTF-8\" />&nbsp;<code>[a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;都 <strong>不同</strong></li>\n\t<li>先修课程图中没有环。</li>\n\t<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub>&nbsp;&lt;= n - 1</code></li>\n\t<li><code>u<sub>i</sub>&nbsp;!= v<sub>i</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1463.摘樱桃 II",
        "hardRate": "HARD",
        "passRate": "62.11%",
        "problemsUrl": "https://leetcode.cn/problems/cherry-pickup-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/cherry-pickup-ii/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>rows x cols</code> 的矩阵&nbsp;<code>grid</code>&nbsp;来表示一块樱桃地。 <code>grid</code>&nbsp;中每个格子的数字表示你能获得的樱桃数目。</p>\n\n<p>你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 <code>(0,0)</code> 出发，机器人 2 从右上角格子 <code>(0, cols-1)</code> 出发。</p>\n\n<p>请你按照如下规则，返回两个机器人能收集的最多樱桃数目：</p>\n\n<ul>\n\t<li>从格子&nbsp;<code>(i,j)</code> 出发，机器人可以移动到格子&nbsp;<code>(i+1, j-1)</code>，<code>(i+1, j)</code> 或者&nbsp;<code>(i+1, j+1)</code>&nbsp;。</li>\n\t<li>当一个机器人经过某个格子时，它会把该格子内所有的樱桃都摘走，然后这个位置会变成空格子，即没有樱桃的格子。</li>\n\t<li>当两个机器人同时到达同一个格子时，它们中只有一个可以摘到樱桃。</li>\n\t<li>两个机器人在任意时刻都不能移动到 <code>grid</code>&nbsp;外面。</li>\n\t<li>两个机器人最后都要到达&nbsp;<code>grid</code>&nbsp;最底下一行。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_1_1802.png\" style=\"height: 182px; width: 139px;\"></strong></p>\n\n<pre><strong>输入：</strong>grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]\n<strong>输出：</strong>24\n<strong>解释：</strong>机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。\n机器人 1 摘的樱桃数目为 (3 + 2 + 5 + 2) = 12 。\n机器人 2 摘的樱桃数目为 (1 + 5 + 5 + 1) = 12 。\n樱桃总数为： 12 + 12 = 24 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_2_1802.png\" style=\"height: 257px; width: 284px;\"></strong></p>\n\n<pre><strong>输入：</strong>grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]\n<strong>输出：</strong>28\n<strong>解释：</strong>机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。\n机器人 1 摘的樱桃数目为 (1 + 9 + 5 + 2) = 17 。\n机器人 2 摘的樱桃数目为 (1 + 3 + 4 + 3) = 11 。\n樱桃总数为： 17 + 11 = 28 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[1,0,0,3],[0,0,0,3],[0,0,3,3],[9,0,3,3]]\n<strong>输出：</strong>22\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[1,1],[1,1]]\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rows == grid.length</code></li>\n\t<li><code>cols == grid[i].length</code></li>\n\t<li><code>2 &lt;= rows, cols &lt;= 70</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 100&nbsp;</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1464.数组中两元素的最大乘积",
        "hardRate": "EASY",
        "passRate": "78.56%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-product-of-two-elements-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-product-of-two-elements-in-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>，请你选择数组的两个不同下标 <code>i</code> 和 <code>j</code><em>，</em>使 <code>(nums[i]-1)*(nums[j]-1)</code> 取得最大值。</p>\n\n<p>请你计算并返回该式的最大值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,4,5,2]\n<strong>输出：</strong>12 \n<strong>解释：</strong>如果选择下标 i=1 和 j=2（下标从 0 开始），则可以获得最大值，(nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,5,4,5]\n<strong>输出：</strong>16\n<strong>解释：</strong>选择下标 i=1 和 j=3（下标从 0 开始），则可以获得最大值 (5-1)*(5-1) = 16 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,7]\n<strong>输出：</strong>12\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^3</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1465.切割后面积最大的蛋糕",
        "hardRate": "MEDIUM",
        "passRate": "32.86%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/solution",
        "problemsDesc": "<p>矩形蛋糕的高度为 <code>h</code> 且宽度为 <code>w</code>，给你两个整数数组 <code>horizontalCuts</code> 和 <code>verticalCuts</code>，其中：</p>\n\n<ul>\n\t<li>&nbsp;<code>horizontalCuts[i]</code> 是从矩形蛋糕顶部到第&nbsp; <code>i</code> 个水平切口的距离</li>\n\t<li><code>verticalCuts[j]</code> 是从矩形蛋糕的左侧到第 <code>j</code> 个竖直切口的距离</li>\n</ul>\n\n<p>请你按数组 <em><code>horizontalCuts</code> </em>和<em> <code>verticalCuts</code> </em>中提供的水平和竖直位置切割后，请你找出 <strong>面积最大</strong> 的那份蛋糕，并返回其 <strong>面积</strong> 。由于答案可能是一个很大的数字，因此需要将结果&nbsp;<strong>对</strong>&nbsp;<code>10<sup>9</sup>&nbsp;+ 7</code>&nbsp;<strong>取余</strong> 后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/leetcode_max_area_2.png\" /></p>\n\n<pre>\n<strong>输入：</strong>h = 5, w = 4, horizontalCuts = [1,2,4], verticalCuts = [1,3]\n<strong>输出：</strong>4 \n<strong>解释：</strong>上图所示的矩阵蛋糕中，红色线表示水平和竖直方向上的切口。切割蛋糕后，绿色的那份蛋糕面积最大。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/leetcode_max_area_3.png\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>h = 5, w = 4, horizontalCuts = [3,1], verticalCuts = [1]\n<strong>输出：</strong>6\n<strong>解释：</strong>上图所示的矩阵蛋糕中，红色线表示水平和竖直方向上的切口。切割蛋糕后，绿色和黄色的两份蛋糕面积最大。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>h = 5, w = 4, horizontalCuts = [3], verticalCuts = [3]\n<strong>输出：</strong>9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= h, w &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= horizontalCuts.length &lt;= min(h - 1, 10<sup>5</sup>)</code></li>\n\t<li><code>1 &lt;= verticalCuts.length &lt;= min(w - 1, 10<sup>5</sup>)</code></li>\n\t<li><code>1 &lt;= horizontalCuts[i] &lt; h</code></li>\n\t<li><code>1 &lt;= verticalCuts[i] &lt; w</code></li>\n\t<li>题目数据保证 <code>horizontalCuts</code> 中的所有元素各不相同</li>\n\t<li>题目数据保证 <code>verticalCuts</code>&nbsp;中的所有元素各不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1466.重新规划路线",
        "hardRate": "MEDIUM",
        "passRate": "51.20%",
        "problemsUrl": "https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/solution",
        "problemsDesc": "<p><code>n</code> 座城市，从 <code>0</code> 到 <code>n-1</code> 编号，其间共有 <code>n-1</code> 条路线。因此，要想在两座不同城市之间旅行只有唯一一条路线可供选择（路线网形成一颗树）。去年，交通运输部决定重新规划路线，以改变交通拥堵的状况。</p>\n\n<p>路线用 <code>connections</code> 表示，其中 <code>connections[i] = [a, b]</code> 表示从城市 <code>a</code> 到 <code>b</code> 的一条有向路线。</p>\n\n<p>今年，城市 0 将会举办一场大型比赛，很多游客都想前往城市 0 。</p>\n\n<p>请你帮助重新规划路线方向，使每个城市都可以访问城市 0 。返回需要变更方向的最小路线数。</p>\n\n<p>题目数据 <strong>保证</strong> 每个城市在重新规划路线方向后都能到达城市 0 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_1_1819.png\" style=\"height: 150px; width: 240px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]\n<strong>输出：</strong>3\n<strong>解释：</strong>更改以红色显示的路线的方向，使每个城市都可以到达城市 0 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_2_1819.png\" style=\"height: 60px; width: 380px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]\n<strong>输出：</strong>2\n<strong>解释：</strong>更改以红色显示的路线的方向，使每个城市都可以到达城市 0 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 3, connections = [[1,0],[2,0]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 5 * 10^4</code></li>\n\t<li><code>connections.length == n-1</code></li>\n\t<li><code>connections[i].length == 2</code></li>\n\t<li><code>0 &lt;= connections[i][0], connections[i][1] &lt;= n-1</code></li>\n\t<li><code>connections[i][0] != connections[i][1]</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1467.两个盒子中球的颜色数相同的概率",
        "hardRate": "HARD",
        "passRate": "63.19%",
        "problemsUrl": "https://leetcode.cn/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/",
        "solutionsUrl": "https://leetcode.cn/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/solution",
        "problemsDesc": "<p>桌面上有 <code>2n</code> 个颜色不完全相同的球，球上的颜色共有 <code>k</code> 种。给你一个大小为 <code>k</code> 的整数数组 <code>balls</code> ，其中 <code>balls[i]</code> 是颜色为&nbsp;<code>i</code> 的球的数量。</p>\n\n<p>所有的球都已经 <strong>随机打乱顺序</strong> ，前 <code>n</code> 个球放入第一个盒子，后 <code>n</code> 个球放入另一个盒子（请认真阅读示例 2 的解释部分）。</p>\n\n<p><strong>注意：</strong>这两个盒子是不同的。例如，两个球颜色分别为 <code>a</code> 和 <code>b</code>，盒子分别为 <code>[]</code> 和 <code>()</code>，那么 <code>[a] (b)</code> 和 <code>[b] (a)</code> 这两种分配方式是不同的（请认真阅读示例的解释部分）。</p>\n\n<p>请返回「两个盒子中球的颜色数相同」的情况的概率。答案与真实值误差在 <code>10^-5</code> 以内，则被视为正确答案</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>balls = [1,1]\n<strong>输出：</strong>1.00000\n<strong>解释：</strong>球平均分配的方式只有两种：\n- 颜色为 1 的球放入第一个盒子，颜色为 2 的球放入第二个盒子\n- 颜色为 2 的球放入第一个盒子，颜色为 1 的球放入第二个盒子\n这两种分配，两个盒子中球的颜色数都相同。所以概率为 2/2 = 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>balls = [2,1,1]\n<strong>输出：</strong>0.66667\n<strong>解释：</strong>球的列表为 [1, 1, 2, 3]\n随机打乱，得到 12 种等概率的不同打乱方案，每种方案概率为 1/12 ：\n[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\n然后，我们将前两个球放入第一个盒子，后两个球放入第二个盒子。\n这 12 种可能的随机打乱方式中的 8 种满足「两个盒子中球的颜色数相同」。\n概率 = 8/12 = 0.66667\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>balls = [1,2,1,2]\n<strong>输出：</strong>0.60000\n<strong>解释：</strong>球的列表为 [1, 2, 2, 3, 4, 4]。要想显示所有 180 种随机打乱方案是很难的，但只检查「两个盒子中球的颜色数相同」的 108 种情况是比较容易的。\n概率 = 108 / 180 = 0.6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= balls.length &lt;= 8</code></li>\n\t<li><code>1 &lt;= balls[i] &lt;= 6</code></li>\n\t<li><code>sum(balls)</code> 是偶数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1468.计算税后工资",
        "hardRate": "MEDIUM",
        "passRate": "69.98%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-salaries/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-salaries/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1469.寻找所有的独生节点",
        "hardRate": "EASY",
        "passRate": "82.22%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-the-lonely-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-the-lonely-nodes/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1470.重新排列数组",
        "hardRate": "EASY",
        "passRate": "84.83%",
        "problemsUrl": "https://leetcode.cn/problems/shuffle-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/shuffle-the-array/solution",
        "problemsDesc": "<p>给你一个数组 <code>nums</code> ，数组中有 <code>2n</code> 个元素，按 <code>[x<sub>1</sub>,x<sub>2</sub>,...,x<sub>n</sub>,y<sub>1</sub>,y<sub>2</sub>,...,y<sub>n</sub>]</code> 的格式排列。</p>\n\n<p>请你将数组按 <code>[x<sub>1</sub>,y<sub>1</sub>,x<sub>2</sub>,y<sub>2</sub>,...,x<sub>n</sub>,y<sub>n</sub>]</code> 格式重新排列，返回重排后的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,5,1,3,4,7], n = 3\n<strong>输出：</strong>[2,3,5,4,1,7] \n<strong>解释：</strong>由于 x<sub>1</sub>=2, x<sub>2</sub>=5, x<sub>3</sub>=1, y<sub>1</sub>=3, y<sub>2</sub>=4, y<sub>3</sub>=7 ，所以答案为 [2,3,5,4,1,7]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,4,3,2,1], n = 4\n<strong>输出：</strong>[1,4,2,3,3,2,4,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,2,2], n = 2\n<strong>输出：</strong>[1,2,1,2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>nums.length == 2n</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^3</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1471.数组中的 k 个最强值",
        "hardRate": "MEDIUM",
        "passRate": "55.54%",
        "problemsUrl": "https://leetcode.cn/problems/the-k-strongest-values-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/the-k-strongest-values-in-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> 和一个整数 <code>k</code> 。</p>\n\n<p>设 <code>m</code> 为数组的中位数，只要满足下述两个前提之一，就可以判定 <code>arr[i]</code> 的值比 <code>arr[j]</code> 的值更强：</p>\n\n<ul>\n\t<li>&nbsp;<code>|arr[i] - m| &gt; |arr[j]&nbsp;- m|</code></li>\n\t<li>&nbsp;<code>|arr[i] - m| == |arr[j] - m|</code>，且 <code>arr[i] &gt; arr[j]</code></li>\n</ul>\n\n<p>请返回由数组中最强的 <code>k</code> 个值组成的列表。答案可以以 <strong>任意顺序</strong> 返回。</p>\n\n<p><strong>中位数</strong> 是一个有序整数列表中处于中间位置的值。形式上，如果列表的长度为 <code>n</code> ，那么中位数就是该有序列表（下标从 0 开始）中位于 <code>((n - 1) / 2)</code> 的元素。</p>\n\n<ul>\n\t<li>例如 <code>arr =&nbsp;[6, -3, 7, 2, 11]</code>，<code>n = 5</code>：数组排序后得到 <code>arr = [-3, 2, 6, 7, 11]</code> ，数组的中间位置为 <code>m = ((5 - 1) / 2) = 2</code> ，中位数 <code>arr[m]</code> 的值为 <code>6</code> 。</li>\n\t<li>例如 <code>arr =&nbsp;[-7, 22, 17,&thinsp;3]</code>，<code>n = 4</code>：数组排序后得到&nbsp;<code>arr = [-7, 3, 17, 22]</code> ，数组的中间位置为&nbsp;<code>m = ((4 - 1) / 2) = 1</code> ，中位数 <code>arr[m]</code> 的值为 <code>3</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,3,4,5], k = 2\n<strong>输出：</strong>[5,1]\n<strong>解释：</strong>中位数为 3，按从强到弱顺序排序后，数组变为 [5,1,4,2,3]。最强的两个元素是 [5, 1]。[1, 5] 也是正确答案。\n注意，尽管 |5 - 3| == |1 - 3| ，但是 5 比 1 更强，因为 5 &gt; 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,1,3,5,5], k = 2\n<strong>输出：</strong>[5,5]\n<strong>解释：</strong>中位数为 3, 按从强到弱顺序排序后，数组变为 [5,5,1,1,3]。最强的两个元素是 [5, 5]。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [6,7,11,7,6,8], k = 5\n<strong>输出：</strong>[11,8,6,6,7]\n<strong>解释：</strong>中位数为 7, 按从强到弱顺序排序后，数组变为 [11,8,6,6,7,7]。\n[11,8,6,6,7] 的任何排列都是正确答案。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [6,-3,7,2,11], k = 3\n<strong>输出：</strong>[-3,11,2]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [-7,22,17,3], k = 2\n<strong>输出：</strong>[22,17]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>\n\t<li><code>-10^5 &lt;= arr[i] &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= k &lt;= arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1472.设计浏览器历史记录",
        "hardRate": "MEDIUM",
        "passRate": "61.45%",
        "problemsUrl": "https://leetcode.cn/problems/design-browser-history/",
        "solutionsUrl": "https://leetcode.cn/problems/design-browser-history/solution",
        "problemsDesc": "<p>你有一个只支持单个标签页的 <strong>浏览器</strong>&nbsp;，最开始你浏览的网页是&nbsp;<code>homepage</code>&nbsp;，你可以访问其他的网站&nbsp;<code>url</code>&nbsp;，也可以在浏览历史中后退&nbsp;<code>steps</code>&nbsp;步或前进&nbsp;<code>steps</code>&nbsp;步。</p>\n\n<p>请你实现&nbsp;<code>BrowserHistory</code> 类：</p>\n\n<ul>\n\t<li><code>BrowserHistory(string homepage)</code>&nbsp;，用&nbsp;<code>homepage</code>&nbsp;初始化浏览器类。</li>\n\t<li><code>void visit(string url)</code>&nbsp;从当前页跳转访问 <code>url</code> 对应的页面&nbsp;&nbsp;。执行此操作会把浏览历史前进的记录全部删除。</li>\n\t<li><code>string back(int steps)</code>&nbsp;在浏览历史中后退&nbsp;<code>steps</code>&nbsp;步。如果你只能在浏览历史中后退至多&nbsp;<code>x</code> 步且&nbsp;<code>steps &gt; x</code>&nbsp;，那么你只后退&nbsp;<code>x</code>&nbsp;步。请返回后退 <strong>至多</strong> <code>steps</code>&nbsp;步以后的&nbsp;<code>url</code>&nbsp;。</li>\n\t<li><code>string forward(int steps)</code>&nbsp;在浏览历史中前进&nbsp;<code>steps</code>&nbsp;步。如果你只能在浏览历史中前进至多&nbsp;<code>x</code>&nbsp;步且&nbsp;<code>steps &gt; x</code>&nbsp;，那么你只前进 <code>x</code>&nbsp;步。请返回前进&nbsp;<strong>至多</strong>&nbsp;<code>steps</code>步以后的 <code>url</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>\n[&quot;BrowserHistory&quot;,&quot;visit&quot;,&quot;visit&quot;,&quot;visit&quot;,&quot;back&quot;,&quot;back&quot;,&quot;forward&quot;,&quot;visit&quot;,&quot;forward&quot;,&quot;back&quot;,&quot;back&quot;]\n[[&quot;leetcode.com&quot;],[&quot;google.com&quot;],[&quot;facebook.com&quot;],[&quot;youtube.com&quot;],[1],[1],[1],[&quot;linkedin.com&quot;],[2],[2],[7]]\n<strong>输出：</strong>\n[null,null,null,null,&quot;facebook.com&quot;,&quot;google.com&quot;,&quot;facebook.com&quot;,null,&quot;linkedin.com&quot;,&quot;google.com&quot;,&quot;leetcode.com&quot;]\n\n<strong>解释：</strong>\nBrowserHistory browserHistory = new BrowserHistory(&quot;leetcode.com&quot;);\nbrowserHistory.visit(&quot;google.com&quot;);       // 你原本在浏览 &quot;leetcode.com&quot; 。访问 &quot;google.com&quot;\nbrowserHistory.visit(&quot;facebook.com&quot;);     // 你原本在浏览 &quot;google.com&quot; 。访问 &quot;facebook.com&quot;\nbrowserHistory.visit(&quot;youtube.com&quot;);      // 你原本在浏览 &quot;facebook.com&quot; 。访问 &quot;youtube.com&quot;\nbrowserHistory.back(1);                   // 你原本在浏览 &quot;youtube.com&quot; ，后退到 &quot;facebook.com&quot; 并返回 &quot;facebook.com&quot;\nbrowserHistory.back(1);                   // 你原本在浏览 &quot;facebook.com&quot; ，后退到 &quot;google.com&quot; 并返回 &quot;google.com&quot;\nbrowserHistory.forward(1);                // 你原本在浏览 &quot;google.com&quot; ，前进到 &quot;facebook.com&quot; 并返回 &quot;facebook.com&quot;\nbrowserHistory.visit(&quot;linkedin.com&quot;);     // 你原本在浏览 &quot;facebook.com&quot; 。 访问 &quot;linkedin.com&quot;\nbrowserHistory.forward(2);                // 你原本在浏览 &quot;linkedin.com&quot; ，你无法前进任何步数。\nbrowserHistory.back(2);                   // 你原本在浏览 &quot;linkedin.com&quot; ，后退两步依次先到 &quot;facebook.com&quot; ，然后到 &quot;google.com&quot; ，并返回 &quot;google.com&quot;\nbrowserHistory.back(7);                   // 你原本在浏览 &quot;google.com&quot;， 你只能后退一步到 &quot;leetcode.com&quot; ，并返回 &quot;leetcode.com&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= homepage.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= url.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= steps &lt;= 100</code></li>\n\t<li><code>homepage</code> 和&nbsp;<code>url</code>&nbsp;都只包含&nbsp;&#39;.&#39; 或者小写英文字母。</li>\n\t<li>最多调用&nbsp;<code>5000</code>&nbsp;次&nbsp;<code>visit</code>，&nbsp;<code>back</code>&nbsp;和&nbsp;<code>forward</code>&nbsp;函数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1473.粉刷房子 III",
        "hardRate": "HARD",
        "passRate": "66.32%",
        "problemsUrl": "https://leetcode.cn/problems/paint-house-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/paint-house-iii/solution",
        "problemsDesc": "<p>在一个小城市里，有 <code>m</code> 个房子排成一排，你需要给每个房子涂上 <code>n</code> 种颜色之一（颜色编号为 <code>1</code> 到 <code>n</code> ）。有的房子去年夏天已经涂过颜色了，所以这些房子不可以被重新涂色。</p>\n\n<p>我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 <code>houses = [1,2,2,3,3,2,1,1]</code> ，它包含 5 个街区 <code> [{1}, {2,2}, {3,3}, {2}, {1,1}]</code> 。）</p>\n\n<p>给你一个数组 <code>houses</code> ，一个 <code>m * n</code> 的矩阵 <code>cost</code> 和一个整数 <code>target</code> ，其中：</p>\n\n<ul>\n\t<li><code>houses[i]</code>：是第 <code>i</code> 个房子的颜色，<strong>0</strong> 表示这个房子还没有被涂色。</li>\n\t<li><code>cost[i][j]</code>：是将第 <code>i</code> 个房子涂成颜色 <code>j+1</code> 的花费。</li>\n</ul>\n\n<p>请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成 <code>target</code> 个街区。如果没有可用的涂色方案，请返回 <strong>-1</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3\n<strong>输出：</strong>9\n<strong>解释：</strong>房子涂色方案为 [1,2,2,1,1]\n此方案包含 target = 3 个街区，分别是 [{1}, {2,2}, {1,1}]。\n涂色的总花费为 (1 + 1 + 1 + 1 + 5) = 9。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3\n<strong>输出：</strong>11\n<strong>解释：</strong>有的房子已经被涂色了，在此基础上涂色方案为 [2,2,1,2,2]\n此方案包含 target = 3 个街区，分别是 [{2,2}, {1}, {2,2}]。\n给第一个和最后一个房子涂色的花费为 (10 + 1) = 11。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>houses = [0,0,0,0,0], cost = [[1,10],[10,1],[1,10],[10,1],[1,10]], m = 5, n = 2, target = 5\n<strong>输出：</strong>5\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3\n<strong>输出：</strong>-1\n<strong>解释：</strong>房子已经被涂色并组成了 4 个街区，分别是 [{3},{1},{2},{3}] ，无法形成 target = 3 个街区。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == houses.length == cost.length</code></li>\n\t<li><code>n == cost[i].length</code></li>\n\t<li><code>1 <= m <= 100</code></li>\n\t<li><code>1 <= n <= 20</code></li>\n\t<li><code>1 <= target <= m</code></li>\n\t<li><code>0 <= houses[i] <= n</code></li>\n\t<li><code>1 <= cost[i][j] <= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1474.删除链表 M 个节点之后的 N 个节点",
        "hardRate": "EASY",
        "passRate": "69.16%",
        "problemsUrl": "https://leetcode.cn/problems/delete-n-nodes-after-m-nodes-of-a-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-n-nodes-after-m-nodes-of-a-linked-list/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1475.商品折扣后的最终价格",
        "hardRate": "EASY",
        "passRate": "73.27%",
        "problemsUrl": "https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/",
        "solutionsUrl": "https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>prices</code>&nbsp;，其中&nbsp;<code>prices[i]</code>&nbsp;是商店里第&nbsp;<code>i</code>&nbsp;件商品的价格。</p>\n\n<p>商店里正在进行促销活动，如果你要买第&nbsp;<code>i</code>&nbsp;件商品，那么你可以得到与 <code>prices[j]</code> 相等的折扣，其中&nbsp;<code>j</code>&nbsp;是满足&nbsp;<code>j &gt; i</code>&nbsp;且&nbsp;<code>prices[j] &lt;= prices[i]</code>&nbsp;的&nbsp;<strong>最小下标</strong>&nbsp;，如果没有满足条件的&nbsp;<code>j</code>&nbsp;，你将没有任何折扣。</p>\n\n<p>请你返回一个数组，数组中第&nbsp;<code>i</code>&nbsp;个元素是折扣后你购买商品 <code>i</code>&nbsp;最终需要支付的价格。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>prices = [8,4,6,2,3]\n<strong>输出：</strong>[4,2,4,2,3]\n<strong>解释：</strong>\n商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。\n商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。\n商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。\n商品 3 和 4 都没有折扣。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>prices = [1,2,3,4,5]\n<strong>输出：</strong>[1,2,3,4,5]\n<strong>解释：</strong>在这个例子中，所有商品都没有折扣。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>prices = [10,1,1,6]\n<strong>输出：</strong>[9,0,1,6]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= prices[i] &lt;= 10^3</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1476.子矩形查询",
        "hardRate": "MEDIUM",
        "passRate": "86.61%",
        "problemsUrl": "https://leetcode.cn/problems/subrectangle-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/subrectangle-queries/solution",
        "problemsDesc": "<p>请你实现一个类&nbsp;<code>SubrectangleQueries</code>&nbsp;，它的构造函数的参数是一个 <code>rows x cols</code>&nbsp;的矩形（这里用整数矩阵表示），并支持以下两种操作：</p>\n\n<p>1.<code>&nbsp;updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)</code></p>\n\n<ul>\n\t<li>用&nbsp;<code>newValue</code>&nbsp;更新以&nbsp;<code>(row1,col1)</code>&nbsp;为左上角且以&nbsp;<code>(row2,col2)</code>&nbsp;为右下角的子矩形。</li>\n</ul>\n\n<p>2.<code>&nbsp;getValue(int row, int col)</code></p>\n\n<ul>\n\t<li>返回矩形中坐标 <code>(row,col)</code> 的当前值。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>\n[&quot;SubrectangleQueries&quot;,&quot;getValue&quot;,&quot;updateSubrectangle&quot;,&quot;getValue&quot;,&quot;getValue&quot;,&quot;updateSubrectangle&quot;,&quot;getValue&quot;,&quot;getValue&quot;]\n[[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]]\n<strong>输出：</strong>\n[null,1,null,5,5,null,10,5]\n<strong>解释：</strong>\nSubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]);  \n// 初始的 (4x3) 矩形如下：\n// 1 2 1\n// 4 3 4\n// 3 2 1\n// 1 1 1\nsubrectangleQueries.getValue(0, 2); // 返回 1\nsubrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5);\n// 此次更新后矩形变为：\n// 5 5 5\n// 5 5 5\n// 5 5 5\n// 5 5 5 \nsubrectangleQueries.getValue(0, 2); // 返回 5\nsubrectangleQueries.getValue(3, 1); // 返回 5\nsubrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10);\n// 此次更新后矩形变为：\n// 5   5   5\n// 5   5   5\n// 5   5   5\n// 10  10  10 \nsubrectangleQueries.getValue(3, 1); // 返回 10\nsubrectangleQueries.getValue(0, 2); // 返回 5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>\n[&quot;SubrectangleQueries&quot;,&quot;getValue&quot;,&quot;updateSubrectangle&quot;,&quot;getValue&quot;,&quot;getValue&quot;,&quot;updateSubrectangle&quot;,&quot;getValue&quot;]\n[[[[1,1,1],[2,2,2],[3,3,3]]],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]]\n<strong>输出：</strong>\n[null,1,null,100,100,null,20]\n<strong>解释：</strong>\nSubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,1,1],[2,2,2],[3,3,3]]);\nsubrectangleQueries.getValue(0, 0); // 返回 1\nsubrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100);\nsubrectangleQueries.getValue(0, 0); // 返回 100\nsubrectangleQueries.getValue(2, 2); // 返回 100\nsubrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20);\nsubrectangleQueries.getValue(2, 2); // 返回 20\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>最多有&nbsp;<code>500</code>&nbsp;次<code>updateSubrectangle</code> 和&nbsp;<code>getValue</code>&nbsp;操作。</li>\n\t<li><code>1 &lt;= rows, cols &lt;= 100</code></li>\n\t<li><code>rows ==&nbsp;rectangle.length</code></li>\n\t<li><code>cols == rectangle[i].length</code></li>\n\t<li><code>0 &lt;= row1 &lt;= row2 &lt; rows</code></li>\n\t<li><code>0 &lt;= col1 &lt;= col2 &lt; cols</code></li>\n\t<li><code>1 &lt;= newValue, rectangle[i][j] &lt;= 10^9</code></li>\n\t<li><code>0 &lt;= row &lt; rows</code></li>\n\t<li><code>0 &lt;= col &lt; cols</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1477.找两个和为目标值且不重叠的子数组",
        "hardRate": "MEDIUM",
        "passRate": "31.15%",
        "problemsUrl": "https://leetcode.cn/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code> 和一个整数值&nbsp;<code>target</code>&nbsp;。</p>\n\n<p>请你在 <code>arr</code>&nbsp;中找 <strong>两个互不重叠的子数组</strong>&nbsp;且它们的和都等于&nbsp;<code>target</code>&nbsp;。可能会有多种方案，请你返回满足要求的两个子数组长度和的 <strong>最小值</strong> 。</p>\n\n<p>请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 <strong>-1</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,2,2,4,3], target = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>只有两个子数组和为 3 （[3] 和 [3]）。它们的长度和为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [7,3,4,7], target = 7\n<strong>输出：</strong>2\n<strong>解释：</strong>尽管我们有 3 个互不重叠的子数组和为 7 （[7], [3,4] 和 [7]），但我们会选择第一个和第三个子数组，因为它们的长度和 2 是最小值。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [4,3,2,6,2,3,4], target = 6\n<strong>输出：</strong>-1\n<strong>解释：</strong>我们只有一个和为 6 的子数组。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [5,5,4,4,5], target = 3\n<strong>输出：</strong>-1\n<strong>解释：</strong>我们无法找到和为 3 的子数组。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,1,1,1,5,1,2,1], target = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>注意子数组 [1,2] 和 [2,1] 不能成为一个方案因为它们重叠了。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= target &lt;= 10^8</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1478.安排邮筒",
        "hardRate": "HARD",
        "passRate": "62.68%",
        "problemsUrl": "https://leetcode.cn/problems/allocate-mailboxes/",
        "solutionsUrl": "https://leetcode.cn/problems/allocate-mailboxes/solution",
        "problemsDesc": "<p>给你一个房屋数组<code>houses</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;，其中&nbsp;<code>houses[i]</code>&nbsp;是第 <code>i</code>&nbsp;栋房子在一条街上的位置，现需要在这条街上安排 <code>k</code>&nbsp;个邮筒。</p>\n\n<p>请你返回每栋房子与离它最近的邮筒之间的距离的 <strong>最小 </strong>总和。</p>\n\n<p>答案保证在 32 位有符号整数范围以内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/13/sample_11_1816.png\" style=\"height: 154px; width: 454px;\"></p>\n\n<pre><strong>输入：</strong>houses = [1,4,8,10,20], k = 3\n<strong>输出：</strong>5\n<strong>解释：</strong>将邮筒分别安放在位置 3， 9 和 20 处。\n每个房子到最近邮筒的距离和为 |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/13/sample_2_1816.png\" style=\"height: 154px; width: 433px;\"></strong></p>\n\n<pre><strong>输入：</strong>houses = [2,3,5,12,18], k = 2\n<strong>输出：</strong>9\n<strong>解释：</strong>将邮筒分别安放在位置 3 和 14 处。\n每个房子到最近邮筒距离和为 |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>houses = [7,4,6,1], k = 1\n<strong>输出：</strong>8\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>houses = [3,6,14,10], k = 4\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == houses.length</code></li>\n\t<li><code>1 &lt;= n&nbsp;&lt;= 100</code></li>\n\t<li><code>1 &lt;= houses[i] &lt;= 10^4</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n\t<li>数组&nbsp;<code>houses</code>&nbsp;中的整数互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1479.周内每天的销售情况",
        "hardRate": "HARD",
        "passRate": "55.70%",
        "problemsUrl": "https://leetcode.cn/problems/sales-by-day-of-the-week/",
        "solutionsUrl": "https://leetcode.cn/problems/sales-by-day-of-the-week/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1480.一维数组的动态和",
        "hardRate": "EASY",
        "passRate": "76.50%",
        "problemsUrl": "https://leetcode.cn/problems/running-sum-of-1d-array/",
        "solutionsUrl": "https://leetcode.cn/problems/running-sum-of-1d-array/solution",
        "problemsDesc": "<p>给你一个数组 <code>nums</code> 。数组「动态和」的计算公式为：<code>runningSum[i] = sum(nums[0]&hellip;nums[i])</code> 。</p>\n\n<p>请返回 <code>nums</code> 的动态和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>[1,3,6,10]\n<strong>解释：</strong>动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,1,1,1]\n<strong>输出：</strong>[1,2,3,4,5]\n<strong>解释：</strong>动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,1,2,10,1]\n<strong>输出：</strong>[3,4,6,16,17]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-10^6&nbsp;&lt;= nums[i] &lt;=&nbsp;10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1481.不同整数的最少数目",
        "hardRate": "MEDIUM",
        "passRate": "45.25%",
        "problemsUrl": "https://leetcode.cn/problems/least-number-of-unique-integers-after-k-removals/",
        "solutionsUrl": "https://leetcode.cn/problems/least-number-of-unique-integers-after-k-removals/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> 和一个整数 <code>k</code> 。现需要从数组中恰好移除 <code>k</code> 个元素，请找出移除后数组中不同整数的最少数目。</p>\n\n<ol>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [5,5,4], k = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>移除 1 个 4 ，数组中只剩下 5 一种整数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [4,3,1,1,3,3,2], k = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>先移除 4、2 ，然后再移除两个 1 中的任意 1 个或者三个 3 中的任意 1 个，最后剩下 1 和 3 两种整数。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length&nbsp;&lt;= 10^5</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10^9</code></li>\n\t<li><code>0 &lt;= k&nbsp;&lt;= arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1482.制作 m 束花所需的最少天数",
        "hardRate": "MEDIUM",
        "passRate": "56.76%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>bloomDay</code>，以及两个整数 <code>m</code> 和 <code>k</code> 。</p>\n\n<p>现需要制作 <code>m</code> 束花。制作花束时，需要使用花园中 <strong>相邻的 <code>k</code> 朵花</strong> 。</p>\n\n<p>花园中有 <code>n</code> 朵花，第 <code>i</code> 朵花会在 <code>bloomDay[i]</code> 时盛开，<strong>恰好</strong> 可以用于 <strong>一束</strong> 花中。</p>\n\n<p>请你返回从花园中摘 <code>m</code> 束花需要等待的最少的天数。如果不能摘到 <code>m</code> 束花则返回 <strong>-1</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>bloomDay = [1,10,3,10,2], m = 3, k = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。\n现在需要制作 3 束花，每束只需要 1 朵。\n1 天后：[x, _, _, _, _]   // 只能制作 1 束花\n2 天后：[x, _, _, _, x]   // 只能制作 2 束花\n3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>bloomDay = [1,10,3,10,2], m = 3, k = 2\n<strong>输出：</strong>-1\n<strong>解释：</strong>要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3\n<strong>输出：</strong>12\n<strong>解释：</strong>要制作 2 束花，每束需要 3 朵。\n花园在 7 天后和 12 天后的情况如下：\n7 天后：[x, x, x, x, _, x, x]\n可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。\n12 天后：[x, x, x, x, x, x, x]\n显然，我们可以用不同的方式制作两束花。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>bloomDay = [1000000000,1000000000], m = 1, k = 1\n<strong>输出：</strong>1000000000\n<strong>解释：</strong>需要等 1000000000 天才能采到花来制作花束\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2\n<strong>输出：</strong>9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>bloomDay.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= bloomDay[i] &lt;= 10^9</code></li>\n\t<li><code>1 &lt;= m &lt;= 10^6</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1483.树节点的第 K 个祖先",
        "hardRate": "HARD",
        "passRate": "44.93%",
        "problemsUrl": "https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/solution",
        "problemsDesc": "<p>给你一棵树，树上有 <code>n</code> 个节点，按从 <code>0</code> 到 <code>n-1</code> 编号。树以父节点数组的形式给出，其中 <code>parent[i]</code> 是节点 <code>i</code> 的父节点。树的根节点是编号为 <code>0</code> 的节点。</p>\n\n<p>树节点的第 <em><code>k</code> </em>个祖先节点是从该节点到根节点路径上的第 <code>k</code> 个节点。</p>\n\n<p>实现 <code>TreeAncestor</code> 类：</p>\n\n<ul>\n\t<li><code>TreeAncestor（int n， int[] parent）</code> 对树和父数组中的节点数初始化对象。</li>\n\t<li><code>getKthAncestor</code><code>(int node, int k)</code> 返回节点 <code>node</code> 的第 <code>k</code> 个祖先节点。如果不存在这样的祖先节点，返回 <code>-1</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/14/1528_ex1.png\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"TreeAncestor\",\"getKthAncestor\",\"getKthAncestor\",\"getKthAncestor\"]\n[[7,[-1,0,0,1,1,2,2]],[3,1],[5,2],[6,3]]\n\n<strong>输出：</strong>\n[null,1,0,-1]\n\n<strong>解释：</strong>\nTreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);\n\ntreeAncestor.getKthAncestor(3, 1);  // 返回 1 ，它是 3 的父节点\ntreeAncestor.getKthAncestor(5, 2);  // 返回 0 ，它是 5 的祖父节点\ntreeAncestor.getKthAncestor(6, 3);  // 返回 -1 因为不存在满足要求的祖先节点\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>parent[0] == -1</code> 表示编号为 <code>0</code> 的节点是根节点。</li>\n\t<li>对于所有的 <code>0 &lt;&nbsp;i &lt; n</code> ，<code>0 &lt;= parent[i] &lt; n</code> 总成立</li>\n\t<li><code>0 &lt;= node &lt; n</code></li>\n\t<li>至多查询&nbsp;<code>5 * 10<sup>4</sup></code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1484.按日期分组销售产品",
        "hardRate": "EASY",
        "passRate": "67.77%",
        "problemsUrl": "https://leetcode.cn/problems/group-sold-products-by-the-date/",
        "solutionsUrl": "https://leetcode.cn/problems/group-sold-products-by-the-date/solution",
        "problemsDesc": "<p>表&nbsp;<code>Activities</code>：</p>\n\n<pre>\n+-------------+---------+\n| 列名         | 类型    |\n+-------------+---------+\n| sell_date   | date    |\n| product     | varchar |\n+-------------+---------+\n此表没有主键，它可能包含重复项。\n此表的每一行都包含产品名称和在市场上销售的日期。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个 SQL 查询来查找每个日期、销售的不同产品的数量及其名称。<br />\n每个日期的销售产品名称应按词典序排列。<br />\n返回按&nbsp;<code>sell_date</code> 排序的结果表。<br />\n查询结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<code><strong>输入：</strong>\nActivities</code> 表：\n+------------+-------------+\n| sell_date  | product     |\n+------------+-------------+\n| 2020-05-30 | Headphone   |\n| 2020-06-01 | Pencil      |\n| 2020-06-02 | Mask        |\n| 2020-05-30 | Basketball  |\n| 2020-06-01 | Bible       |\n| 2020-06-02 | Mask        |\n| 2020-05-30 | T-Shirt     |\n+------------+-------------+\n<strong>输出：</strong>\n+------------+----------+------------------------------+\n| sell_date  | num_sold | products                     |\n+------------+----------+------------------------------+\n| 2020-05-30 | 3        | Basketball,Headphone,T-shirt |\n| 2020-06-01 | 2        | Bible,Pencil                 |\n| 2020-06-02 | 1        | Mask                         |\n+------------+----------+------------------------------+\n<strong>解释：</strong>\n对于2020-05-30，出售的物品是 (Headphone, Basketball, T-shirt)，按词典序排列，并用逗号 ',' 分隔。\n对于2020-06-01，出售的物品是 (Pencil, Bible)，按词典序排列，并用逗号分隔。\n对于2020-06-02，出售的物品是 (Mask)，只需返回该物品名。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1485.克隆含随机指针的二叉树",
        "hardRate": "MEDIUM",
        "passRate": "78.62%",
        "problemsUrl": "https://leetcode.cn/problems/clone-binary-tree-with-random-pointer/",
        "solutionsUrl": "https://leetcode.cn/problems/clone-binary-tree-with-random-pointer/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1486.数组异或操作",
        "hardRate": "EASY",
        "passRate": "85.43%",
        "problemsUrl": "https://leetcode.cn/problems/xor-operation-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/xor-operation-in-an-array/solution",
        "problemsDesc": "<p>给你两个整数，<code>n</code> 和 <code>start</code> 。</p>\n\n<p>数组 <code>nums</code> 定义为：<code>nums[i] = start + 2*i</code>（下标从 0 开始）且 <code>n == nums.length</code> 。</p>\n\n<p>请返回 <code>nums</code> 中所有元素按位异或（<strong>XOR</strong>）后得到的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 5, start = 0\n<strong>输出：</strong>8\n<strong>解释：</strong>数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。\n     &quot;^&quot; 为按位异或 XOR 运算符。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 4, start = 3\n<strong>输出：</strong>8\n<strong>解释：</strong>数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8.</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 1, start = 7\n<strong>输出：</strong>7\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 10, start = 5\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= start &lt;= 1000</code></li>\n\t<li><code>n == nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1487.保证文件名唯一",
        "hardRate": "MEDIUM",
        "passRate": "41.52%",
        "problemsUrl": "https://leetcode.cn/problems/making-file-names-unique/",
        "solutionsUrl": "https://leetcode.cn/problems/making-file-names-unique/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的字符串数组 <code>names</code> 。你将会在文件系统中创建 <code>n</code> 个文件夹：在第 <code>i</code> 分钟，新建名为 <code>names[i]</code> 的文件夹。</p>\n\n<p>由于两个文件 <strong>不能</strong> 共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，系统会以 <code>(k)</code> 的形式为新文件夹的文件名添加后缀，其中 <code>k</code> 是能保证文件名唯一的 <strong>最小正整数</strong> 。</p>\n\n<p>返回长度为<em> <code>n</code></em> 的字符串数组，其中 <code>ans[i]</code> 是创建第 <code>i</code> 个文件夹时系统分配给该文件夹的实际名称。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>names = [&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;]\n<strong>输出：</strong>[&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;]\n<strong>解释：</strong>文件系统将会这样创建文件名：\n&quot;pes&quot; --&gt; 之前未分配，仍为 &quot;pes&quot;\n&quot;fifa&quot; --&gt; 之前未分配，仍为 &quot;fifa&quot;\n&quot;gta&quot; --&gt; 之前未分配，仍为 &quot;gta&quot;\n&quot;pes(2019)&quot; --&gt; 之前未分配，仍为 &quot;pes(2019)&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>names = [&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta&quot;,&quot;avalon&quot;]\n<strong>输出：</strong>[&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta(2)&quot;,&quot;avalon&quot;]\n<strong>解释：</strong>文件系统将会这样创建文件名：\n&quot;gta&quot; --&gt; 之前未分配，仍为 &quot;gta&quot;\n&quot;gta(1)&quot; --&gt; 之前未分配，仍为 &quot;gta(1)&quot;\n&quot;gta&quot; --&gt; 文件名被占用，系统为该名称添加后缀 (k)，由于 &quot;gta(1)&quot; 也被占用，所以 k = 2 。实际创建的文件名为 &quot;gta(2)&quot; 。\n&quot;avalon&quot; --&gt; 之前未分配，仍为 &quot;avalon&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>names = [&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece&quot;]\n<strong>输出：</strong>[&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece(4)&quot;]\n<strong>解释：</strong>当创建最后一个文件夹时，最小的正有效 k 为 4 ，文件名变为 &quot;onepiece(4)&quot;。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>names = [&quot;wano&quot;,&quot;wano&quot;,&quot;wano&quot;,&quot;wano&quot;]\n<strong>输出：</strong>[&quot;wano&quot;,&quot;wano(1)&quot;,&quot;wano(2)&quot;,&quot;wano(3)&quot;]\n<strong>解释：</strong>每次创建文件夹 &quot;wano&quot; 时，只需增加后缀中 k 的值即可。</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>names = [&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido&quot;,&quot;kaido(1)&quot;]\n<strong>输出：</strong>[&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido(2)&quot;,&quot;kaido(1)(1)&quot;]\n<strong>解释：</strong>注意，如果含后缀文件名被占用，那么系统也会按规则在名称后添加新的后缀 (k) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= names.length &lt;= 5 * 10^4</code></li>\n\t<li><code>1 &lt;= names[i].length &lt;= 20</code></li>\n\t<li><code>names[i]</code> 由小写英文字母、数字和/或圆括号组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1488.避免洪水泛滥",
        "hardRate": "MEDIUM",
        "passRate": "26.29%",
        "problemsUrl": "https://leetcode.cn/problems/avoid-flood-in-the-city/",
        "solutionsUrl": "https://leetcode.cn/problems/avoid-flood-in-the-city/solution",
        "problemsDesc": "<p>你的国家有无数个湖泊，所有湖泊一开始都是空的。当第 <code>n</code>&nbsp;个湖泊下雨前是空的，那么它就会装满水。如果第 <code>n</code>&nbsp;个湖泊下雨前是 <strong>满的&nbsp;</strong>，这个湖泊会发生 <strong>洪水</strong> 。你的目标是避免任意一个湖泊发生洪水。</p>\n\n<p>给你一个整数数组&nbsp;<code>rains</code>&nbsp;，其中：</p>\n\n<ul>\n\t<li><code>rains[i] &gt; 0</code>&nbsp;表示第 <code>i</code>&nbsp;天时，第 <code>rains[i]</code>&nbsp;个湖泊会下雨。</li>\n\t<li><code>rains[i] == 0</code>&nbsp;表示第 <code>i</code>&nbsp;天没有湖泊会下雨，你可以选择 <strong>一个</strong>&nbsp;湖泊并 <strong>抽干</strong>&nbsp;这个湖泊的水。</li>\n</ul>\n\n<p>请返回一个数组<em>&nbsp;</em><code>ans</code>&nbsp;，满足：</p>\n\n<ul>\n\t<li><code>ans.length == rains.length</code></li>\n\t<li>如果&nbsp;<code>rains[i] &gt; 0</code> ，那么<code>ans[i] == -1</code>&nbsp;。</li>\n\t<li>如果&nbsp;<code>rains[i] == 0</code>&nbsp;，<code>ans[i]</code>&nbsp;是你第&nbsp;<code>i</code>&nbsp;天选择抽干的湖泊。</li>\n</ul>\n\n<p>如果有多种可行解，请返回它们中的 <strong>任意一个</strong>&nbsp;。如果没办法阻止洪水，请返回一个 <strong>空的数组</strong>&nbsp;。</p>\n\n<p>请注意，如果你选择抽干一个装满水的湖泊，它会变成一个空的湖泊。但如果你选择抽干一个空的湖泊，那么将无事发生。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rains = [1,2,3,4]\n<strong>输出：</strong>[-1,-1,-1,-1]\n<strong>解释：</strong>第一天后，装满水的湖泊包括 [1]\n第二天后，装满水的湖泊包括 [1,2]\n第三天后，装满水的湖泊包括 [1,2,3]\n第四天后，装满水的湖泊包括 [1,2,3,4]\n没有哪一天你可以抽干任何湖泊的水，也没有湖泊会发生洪水。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rains = [1,2,0,0,2,1]\n<strong>输出：</strong>[-1,-1,2,1,-1,-1]\n<strong>解释：</strong>第一天后，装满水的湖泊包括 [1]\n第二天后，装满水的湖泊包括 [1,2]\n第三天后，我们抽干湖泊 2 。所以剩下装满水的湖泊包括 [1]\n第四天后，我们抽干湖泊 1 。所以暂时没有装满水的湖泊了。\n第五天后，装满水的湖泊包括 [2]。\n第六天后，装满水的湖泊包括 [1,2]。\n可以看出，这个方案下不会有洪水发生。同时， [-1,-1,1,2,-1,-1] 也是另一个可行的没有洪水的方案。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>rains = [1,2,0,1,2]\n<strong>输出：</strong>[]\n<strong>解释：</strong>第二天后，装满水的湖泊包括 [1,2]。我们可以在第三天抽干一个湖泊的水。\n但第三天后，湖泊 1 和 2 都会再次下雨，所以不管我们第三天抽干哪个湖泊的水，另一个湖泊都会发生洪水。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rains.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= rains[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1489.找到最小生成树里的关键边和伪关键边",
        "hardRate": "HARD",
        "passRate": "66.53%",
        "problemsUrl": "https://leetcode.cn/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/solution",
        "problemsDesc": "<p>给你一个 <code>n</code>&nbsp;个点的带权无向连通图，节点编号为 <code>0</code>&nbsp;到 <code>n-1</code>&nbsp;，同时还有一个数组 <code>edges</code>&nbsp;，其中 <code>edges[i] = [from</code><code><sub>i</sub>, to<sub>i</sub>, weight<sub>i</sub>]</code>&nbsp;表示在&nbsp;<code>from<sub>i</sub></code>&nbsp;和&nbsp;<code>to<sub>i</sub></code>&nbsp;节点之间有一条带权无向边。最小生成树&nbsp;(MST) 是给定图中边的一个子集，它连接了所有节点且没有环，而且这些边的权值和最小。</p>\n\n<p>请你找到给定图中最小生成树的所有关键边和伪关键边。如果从图中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。</p>\n\n<p>请注意，你可以分别以任意顺序返回关键边的下标和伪关键边的下标。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/21/ex1.png\" style=\"height: 262px; width: 259px;\"></p>\n\n<pre><strong>输入：</strong>n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\n<strong>输出：</strong>[[0,1],[2,3,4,5]]\n<strong>解释：</strong>上图描述了给定图。\n下图是所有的最小生成树。\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/21/msts.png\" style=\"height: 553px; width: 540px;\">\n注意到第 0 条边和第 1 条边出现在了所有最小生成树中，所以它们是关键边，我们将这两个下标作为输出的第一个列表。\n边 2，3，4 和 5 是所有 MST 的剩余边，所以它们是伪关键边。我们将它们作为输出的第二个列表。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/21/ex2.png\" style=\"height: 253px; width: 247px;\"></p>\n\n<pre><strong>输入：</strong>n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]\n<strong>输出：</strong>[[],[0,1,2,3]]\n<strong>解释：</strong>可以观察到 4 条边都有相同的权值，任选它们中的 3 条可以形成一棵 MST 。所以 4 条边都是伪关键边。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= min(200, n * (n - 1) / 2)</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub> &lt; to<sub>i</sub> &lt; n</code></li>\n\t<li><code>1 &lt;= weight<sub>i</sub>&nbsp;&lt;= 1000</code></li>\n\t<li>所有 <code>(from<sub>i</sub>, to<sub>i</sub>)</code>&nbsp;数对都是互不相同的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1490.克隆 N 叉树",
        "hardRate": "MEDIUM",
        "passRate": "83.44%",
        "problemsUrl": "https://leetcode.cn/problems/clone-n-ary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/clone-n-ary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1491.去掉最低工资和最高工资后的工资平均值",
        "hardRate": "EASY",
        "passRate": "62.67%",
        "problemsUrl": "https://leetcode.cn/problems/average-salary-excluding-the-minimum-and-maximum-salary/",
        "solutionsUrl": "https://leetcode.cn/problems/average-salary-excluding-the-minimum-and-maximum-salary/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>salary</code>&nbsp;，数组里每个数都是 <strong>唯一</strong>&nbsp;的，其中&nbsp;<code>salary[i]</code> 是第&nbsp;<code>i</code>&nbsp;个员工的工资。</p>\n\n<p>请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>salary = [4000,3000,1000,2000]\n<strong>输出：</strong>2500.00000\n<strong>解释：</strong>最低工资和最高工资分别是 1000 和 4000 。\n去掉最低工资和最高工资以后的平均工资是 (2000+3000)/2= 2500\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>salary = [1000,2000,3000]\n<strong>输出：</strong>2000.00000\n<strong>解释：</strong>最低工资和最高工资分别是 1000 和 3000 。\n去掉最低工资和最高工资以后的平均工资是 (2000)/1= 2000\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>salary = [6000,5000,4000,3000,2000,1000]\n<strong>输出：</strong>3500.00000\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>salary = [8000,9000,2000,3000,6000,1000]\n<strong>输出：</strong>4750.00000\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= salary.length &lt;= 100</code></li>\n\t<li><code>10^3&nbsp;&lt;= salary[i] &lt;= 10^6</code></li>\n\t<li><code>salary[i]</code>&nbsp;是唯一的。</li>\n\t<li>与真实值误差在&nbsp;<code>10^-5</code> 以内的结果都将视为正确答案。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1492.n 的第 k 个因子",
        "hardRate": "MEDIUM",
        "passRate": "60.79%",
        "problemsUrl": "https://leetcode.cn/problems/the-kth-factor-of-n/",
        "solutionsUrl": "https://leetcode.cn/problems/the-kth-factor-of-n/solution",
        "problemsDesc": "<p>给你两个正整数&nbsp;<code>n</code> 和&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>如果正整数 <code>i</code> 满足 <code>n % i == 0</code> ，那么我们就说正整数 <code>i</code> 是整数 <code>n</code>&nbsp;的因子。</p>\n\n<p>考虑整数 <code>n</code>&nbsp;的所有因子，将它们 <strong>升序排列</strong>&nbsp;。请你返回第 <code>k</code>&nbsp;个因子。如果 <code>n</code>&nbsp;的因子数少于 <code>k</code>&nbsp;，请你返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 12, k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>因子列表包括 [1, 2, 3, 4, 6, 12]，第 3 个因子是 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 7, k = 2\n<strong>输出：</strong>7\n<strong>解释：</strong>因子列表包括 [1, 7] ，第 2 个因子是 7 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, k = 4\n<strong>输出：</strong>-1\n<strong>解释：</strong>因子列表包括 [1, 2, 4] ，只有 3 个因子，所以我们应该返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<p>你可以设计时间复杂度小于 O(n) 的算法来解决此问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1493.删掉一个元素以后全为 1 的最长子数组",
        "hardRate": "MEDIUM",
        "passRate": "59.69%",
        "problemsUrl": "https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/solution",
        "problemsDesc": "<p>给你一个二进制数组&nbsp;<code>nums</code>&nbsp;，你需要从中删掉一个元素。</p>\n\n<p>请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。</p>\n\n<p>如果不存在这样的子数组，请返回 0 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,0,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,1,1,0,1,1,0,1]\n<strong>输出：</strong>5\n<strong>解释：</strong>删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>你必须要删除一个元素。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code>&nbsp;要么是&nbsp;<code>0</code>&nbsp;要么是&nbsp;<code>1</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1494.并行课程 II",
        "hardRate": "HARD",
        "passRate": "51.88%",
        "problemsUrl": "https://leetcode.cn/problems/parallel-courses-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/parallel-courses-ii/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;表示某所大学里课程的数目，编号为&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;，数组&nbsp;<code>relations</code>&nbsp;中，&nbsp;<code>relations[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp; 表示一个先修课的关系，也就是课程&nbsp;<code>x<sub>i</sub></code>&nbsp;必须在课程&nbsp;<code>y<sub>i</sub></code><sub>&nbsp;</sub>之前上。同时你还有一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>在一个学期中，你 <strong>最多</strong>&nbsp;可以同时上 <code>k</code>&nbsp;门课，前提是这些课的先修课在之前的学期里已经上过了。</p>\n\n<p>请你返回上完所有课最少需要多少个学期。题目保证一定存在一种上完所有课的方式。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/27/leetcode_parallel_courses_1.png\" style=\"height: 164px; width: 300px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, relations = [[2,1],[3,1],[1,4]], k = 2\n<strong>输出：</strong>3 \n<strong>解释：</strong>上图展示了题目输入的图。在第一个学期中，我们可以上课程 2 和课程 3 。然后第二个学期上课程 1 ，第三个学期上课程 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/27/leetcode_parallel_courses_2.png\" style=\"height: 234px; width: 300px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2\n<strong>输出：</strong>4 \n<strong>解释：</strong>上图展示了题目输入的图。一个最优方案是：第一学期上课程 2 和 3，第二学期上课程 4 ，第三学期上课程 1 ，第四学期上课程 5 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 11, relations = [], k = 2\n<strong>输出：</strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 15</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n\t<li><code>0 &lt;=&nbsp;relations.length &lt;= n * (n-1) / 2</code></li>\n\t<li><code>relations[i].length == 2</code></li>\n\t<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= n</code></li>\n\t<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>\n\t<li>所有先修关系都是不同的，也就是说&nbsp;<code>relations[i] != relations[j]</code>&nbsp;。</li>\n\t<li>题目输入的图是个有向无环图。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1495.上月播放的儿童适宜电影",
        "hardRate": "EASY",
        "passRate": "53.51%",
        "problemsUrl": "https://leetcode.cn/problems/friendly-movies-streamed-last-month/",
        "solutionsUrl": "https://leetcode.cn/problems/friendly-movies-streamed-last-month/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1496.判断路径是否相交",
        "hardRate": "EASY",
        "passRate": "53.54%",
        "problemsUrl": "https://leetcode.cn/problems/path-crossing/",
        "solutionsUrl": "https://leetcode.cn/problems/path-crossing/solution",
        "problemsDesc": "<p>给你一个字符串 <code>path</code>，其中 <code>path[i]</code> 的值可以是 <code>'N'</code>、<code>'S'</code>、<code>'E'</code> 或者 <code>'W'</code>，分别表示向北、向南、向东、向西移动一个单位。</p>\n\n<p>你从二维平面上的原点 <code>(0, 0)</code> 处开始出发，按 <code>path</code> 所指示的路径行走。</p>\n\n<p>如果路径在任何位置上与自身相交，也就是走到之前已经走过的位置，请返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/28/screen-shot-2020-06-10-at-123929-pm.png\" style=\"height: 358px; width: 400px;\" /></p>\n\n<pre>\n<strong>输入：</strong>path = \"NES\"\n<strong>输出：</strong>false \n<strong>解释：</strong>该路径没有在任何位置相交。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/28/screen-shot-2020-06-10-at-123843-pm.png\" style=\"height: 339px; width: 400px;\" /></p>\n\n<pre>\n<strong>输入：</strong>path = \"NESWW\"\n<strong>输出：</strong>true\n<strong>解释：</strong>该路径经过原点两次。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= path.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>path[i]</code> 为 <code>'N'</code>、<code>'S'</code>、<code>'E'</code> 或 <code>'W'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1497.检查数组对是否可以被 k 整除",
        "hardRate": "MEDIUM",
        "passRate": "40.18%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-array-pairs-are-divisible-by-k/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-array-pairs-are-divisible-by-k/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> 和一个整数 <code>k</code> ，其中数组长度是偶数，值为 <code>n</code> 。</p>\n\n<p>现在需要把数组恰好分成 <code>n /&nbsp;2</code> 对，以使每对数字的和都能够被 <code>k</code> 整除。</p>\n\n<p>如果存在这样的分法，请返回 <em>True</em> ；否则，返回 <em>False</em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n<strong>输出：</strong>true\n<strong>解释：</strong>划分后的数字对为 (1,9),(2,8),(3,7),(4,6) 以及 (5,10) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,4,5,6], k = 7\n<strong>输出：</strong>true\n<strong>解释：</strong>划分后的数字对为 (1,6),(2,5) 以及 (3,4) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,4,5,6], k = 10\n<strong>输出：</strong>false\n<strong>解释：</strong>无法在将数组中的数字分为三对的同时满足每对数字和能够被 10 整除的条件。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>arr.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>n</code> 为偶数<meta charset=\"UTF-8\" /></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1498.满足条件的子序列数目",
        "hardRate": "MEDIUM",
        "passRate": "38.26%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>\n\n<p>请你统计并返回 <code>nums</code> 中能满足其最小元素与最大元素的 <strong>和</strong> 小于或等于 <code>target</code> 的 <strong>非空</strong> 子序列的数目。</p>\n\n<p>由于答案可能很大，请将结果对<meta charset=\"UTF-8\" />&nbsp;<code>10<sup>9</sup>&nbsp;+ 7</code>&nbsp;取余后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,5,6,7], target = 9\n<strong>输出：</strong>4\n<strong>解释：</strong>有 4 个子序列满足该条件。\n[3] -&gt; 最小元素 + 最大元素 &lt;= target (3 + 3 &lt;= 9)\n[3,5] -&gt; (3 + 5 &lt;= 9)\n[3,5,6] -&gt; (3 + 6 &lt;= 9)\n[3,6] -&gt; (3 + 6 &lt;= 9)\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,3,6,8], target = 10\n<strong>输出：</strong>6\n<strong>解释：</strong>有 6 个子序列满足该条件。（nums 中可以有重复数字）\n[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,3,4,6,7], target = 12\n<strong>输出：</strong>61\n<strong>解释：</strong>共有 63 个非空子序列，其中 2 个不满足条件（[6,7], [7]）\n有效序列总数为（63 - 2 = 61）\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= target &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1499.满足不等式的最大值",
        "hardRate": "HARD",
        "passRate": "40.98%",
        "problemsUrl": "https://leetcode.cn/problems/max-value-of-equation/",
        "solutionsUrl": "https://leetcode.cn/problems/max-value-of-equation/solution",
        "problemsDesc": "<p>给你一个数组 <code>points</code> 和一个整数 <code>k</code> 。数组中每个元素都表示二维平面上的点的坐标，并按照横坐标 x 的值从小到大排序。也就是说 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> ，并且在 <code>1 &lt;= i &lt; j &lt;= points.length</code> 的前提下， <code>x<sub>i</sub> &lt; x<sub>j</sub></code> 总成立。</p>\n\n<p>请你找出<em> </em><code>y<sub>i</sub>&nbsp;+ y<sub>j</sub>&nbsp;+ |x<sub>i</sub>&nbsp;- x<sub>j</sub>|</code> 的 <strong>最大值</strong>，其中 <code>|x<sub>i</sub>&nbsp;- x<sub>j</sub>|&nbsp;&lt;= k</code> 且 <code>1 &lt;= i &lt; j &lt;= points.length</code>。</p>\n\n<p>题目测试数据保证至少存在一对能够满足 <code>|x<sub>i</sub>&nbsp;- x<sub>j</sub>|&nbsp;&lt;= k</code> 的点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>points = [[1,3],[2,0],[5,10],[6,-10]], k = 1\n<strong>输出：</strong>4\n<strong>解释：</strong>前两个点满足 |x<sub>i</sub>&nbsp;- x<sub>j</sub>| &lt;= 1 ，代入方程计算，则得到值 3 + 0 + |1 - 2| = 4 。第三个和第四个点也满足条件，得到值 10 + -10 + |5 - 6| = 1 。\n没有其他满足条件的点，所以返回 4 和 1 中最大的那个。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>points = [[0,0],[3,0],[9,2]], k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>只有前两个点满足 |x<sub>i</sub>&nbsp;- x<sub>j</sub>| &lt;= 3 ，代入方程后得到值 0 + 0 + |0 - 3| = 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= points.length &lt;= 10^5</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>-10^8&nbsp;&lt;= points[i][0], points[i][1] &lt;= 10^8</code></li>\n\t<li><code>0 &lt;= k &lt;= 2 * 10^8</code></li>\n\t<li>对于所有的<code>1 &lt;= i &lt; j &lt;= points.length</code> ，<code>points[i][0] &lt; points[j][0]</code> 都成立。也就是说，<code>x<sub>i</sub></code> 是严格递增的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1500.设计文件分享系统",
        "hardRate": "MEDIUM",
        "passRate": "29.76%",
        "problemsUrl": "https://leetcode.cn/problems/design-a-file-sharing-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-a-file-sharing-system/solution",
        "problemsDesc": null,
        "isPlus": true
    }
]