[
    {
        "problemsName": " 1751.最多可以参加的会议数目 II",
        "hardRate": "HARD",
        "passRate": "54.33%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended-ii/solution",
        "problemsDesc": "<p>给你一个 <code>events</code> 数组，其中 <code>events[i] = [startDay<sub>i</sub>, endDay<sub>i</sub>, value<sub>i</sub>]</code> ，表示第 <code>i</code> 个会议在 <code>startDay<sub>i</sub></code><sub> </sub>天开始，第 <code>endDay<sub>i</sub></code> 天结束，如果你参加这个会议，你能得到价值 <code>value<sub>i</sub></code> 。同时给你一个整数 <code>k</code> 表示你能参加的最多会议数目。</p>\n\n<p>你同一时间只能参加一个会议。如果你选择参加某个会议，那么你必须 <strong>完整</strong> 地参加完这个会议。会议结束日期是包含在会议内的，也就是说你不能同时参加一个开始日期与另一个结束日期相同的两个会议。</p>\n\n<p>请你返回能得到的会议价值 <strong>最大和</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/06/screenshot-2021-01-11-at-60048-pm.png\" style=\"width: 400px; height: 103px;\" /></p>\n\n<pre>\n<b>输入：</b>events = [[1,2,4],[3,4,3],[2,3,1]], k = 2\n<b>输出：</b>7\n<strong>解释：</strong>选择绿色的活动会议 0 和 1，得到总价值和为 4 + 3 = 7 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/06/screenshot-2021-01-11-at-60150-pm.png\" style=\"width: 400px; height: 103px;\" /></p>\n\n<pre>\n<b>输入：</b>events = [[1,2,4],[3,4,3],[2,3,10]], k = 2\n<b>输出：</b>10\n<b>解释：</b>参加会议 2 ，得到价值和为 10 。\n你没法再参加别的会议了，因为跟会议 2 有重叠。你 <strong>不</strong> 需要参加满 k 个会议。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/06/screenshot-2021-01-11-at-60703-pm.png\" style=\"width: 400px; height: 126px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3\n<b>输出：</b>9\n<b>解释：</b>尽管会议互不重叠，你只能参加 3 个会议，所以选择价值最大的 3 个会议。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= k <= events.length</code></li>\n\t<li><code>1 <= k * events.length <= 10<sup>6</sup></code></li>\n\t<li><code>1 <= startDay<sub>i</sub> <= endDay<sub>i</sub> <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= value<sub>i</sub> <= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1752.检查数组是否经排序和轮转得到",
        "hardRate": "EASY",
        "passRate": "58.04%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-array-is-sorted-and-rotated/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-array-is-sorted-and-rotated/solution",
        "problemsDesc": "<p>给你一个数组 <code>nums</code> 。<code>nums</code> 的源数组中，所有元素与 <code>nums</code> 相同，但按非递减顺序排列。</p>\n\n<p>如果&nbsp;<code>nums</code> 能够由源数组轮转若干位置（包括 0 个位置）得到，则返回 <code>true</code><em> </em>；否则，返回 <code>false</code> 。</p>\n\n<p>源数组中可能存在 <strong>重复项</strong> 。</p>\n\n<p><strong>注意：</strong>我们称数组 <code>A</code> 在轮转 <code>x</code> 个位置后得到长度相同的数组 <code>B</code> ，当它们满足 <code>A[i] == B[(i+x) % A.length]</code> ，其中 <code>%</code> 为取余运算。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,5,1,2]\n<strong>输出：</strong>true\n<strong>解释：</strong>[1,2,3,4,5] 为有序的源数组。\n可以轮转 x = 3 个位置，使新数组从值为 3 的元素开始：[3,4,5,1,2] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,3,4]\n<strong>输出：</strong>false\n<strong>解释：</strong>源数组无法经轮转得到 nums 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>true\n<strong>解释：</strong>[1,2,3] 为有序的源数组。\n可以轮转 x = 0 个位置（即不轮转）得到 nums 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1753.移除石子的最大得分",
        "hardRate": "MEDIUM",
        "passRate": "70.67%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-from-removing-stones/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-from-removing-stones/solution",
        "problemsDesc": "<p>你正在玩一个单人游戏，面前放置着大小分别为 <code>a</code>​​​​​​、<code>b</code> 和 <code>c</code>​​​​​​ 的 <strong>三堆</strong> 石子。</p>\n\n<p>每回合你都要从两个 <strong>不同的非空堆</strong> 中取出一颗石子，并在得分上加 <code>1</code> 分。当存在 <strong>两个或更多</strong> 的空堆时，游戏停止。</p>\n\n<p>给你三个整数 <code>a</code> 、<code>b</code> 和 <code>c</code> ，返回可以得到的 <strong>最大分数</strong> 。</p>\n \n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 2, b = 4, c = 6\n<strong>输出：</strong>6\n<strong>解释：</strong>石子起始状态是 (2, 4, 6) ，最优的一组操作是：\n- 从第一和第三堆取，石子状态现在是 (1, 4, 5)\n- 从第一和第三堆取，石子状态现在是 (0, 4, 4)\n- 从第二和第三堆取，石子状态现在是 (0, 3, 3)\n- 从第二和第三堆取，石子状态现在是 (0, 2, 2)\n- 从第二和第三堆取，石子状态现在是 (0, 1, 1)\n- 从第二和第三堆取，石子状态现在是 (0, 0, 0)\n总分：6 分 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 4, b = 4, c = 6\n<strong>输出：</strong>7\n<strong>解释：</strong>石子起始状态是 (4, 4, 6) ，最优的一组操作是：\n- 从第一和第二堆取，石子状态现在是 (3, 3, 6)\n- 从第一和第三堆取，石子状态现在是 (2, 3, 5)\n- 从第一和第三堆取，石子状态现在是 (1, 3, 4)\n- 从第一和第三堆取，石子状态现在是 (0, 3, 3)\n- 从第二和第三堆取，石子状态现在是 (0, 2, 2)\n- 从第二和第三堆取，石子状态现在是 (0, 1, 1)\n- 从第二和第三堆取，石子状态现在是 (0, 0, 0)\n总分：7 分 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 1, b = 8, c = 8\n<strong>输出：</strong>8\n<strong>解释：</strong>最优的一组操作是连续从第二和第三堆取 8 回合，直到将它们取空。\n注意，由于第二和第三堆已经空了，游戏结束，不能继续从第一堆中取石子。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= a, b, c <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1754.构造字典序最大的合并字符串",
        "hardRate": "MEDIUM",
        "passRate": "56.27%",
        "problemsUrl": "https://leetcode.cn/problems/largest-merge-of-two-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-merge-of-two-strings/solution",
        "problemsDesc": "<p>给你两个字符串 <code>word1</code> 和 <code>word2</code> 。你需要按下述方式构造一个新字符串 <code>merge</code> ：如果 <code>word1</code> 或 <code>word2</code> 非空，选择 <strong>下面选项之一</strong> 继续操作：</p>\n\n<ul>\n\t<li>如果 <code>word1</code> 非空，将 <code>word1</code> 中的第一个字符附加到 <code>merge</code> 的末尾，并将其从 <code>word1</code> 中移除。\n\n\t<ul>\n\t\t<li>例如，<code>word1 = \"abc\" </code>且 <code>merge = \"dv\"</code> ，在执行此选项操作之后，<code>word1 = \"bc\"</code> ，同时 <code>merge = \"dva\"</code> 。</li>\n\t</ul>\n\t</li>\n\t<li>如果 <code>word2</code> 非空，将 <code>word2</code> 中的第一个字符附加到 <code>merge</code> 的末尾，并将其从 <code>word2</code> 中移除。\n\t<ul>\n\t\t<li>例如，<code>word2 = \"abc\" </code>且 <code>merge = \"\"</code> ，在执行此选项操作之后，<code>word2 = \"bc\"</code> ，同时 <code>merge = \"a\"</code> 。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>返回你可以构造的字典序 <strong>最大</strong> 的合并字符串<em> </em><code>merge</code><em> 。</em></p>\n\n<p>长度相同的两个字符串 <code>a</code> 和 <code>b</code> 比较字典序大小，如果在 <code>a</code> 和 <code>b</code> 出现不同的第一个位置，<code>a</code> 中字符在字母表中的出现顺序位于 <code>b</code> 中相应字符之后，就认为字符串 <code>a</code> 按字典序比字符串 <code>b</code> 更大。例如，<code>\"abcd\"</code> 按字典序比 <code>\"abcc\"</code> 更大，因为两个字符串出现不同的第一个位置是第四个字符，而 <code>d</code> 在字母表中的出现顺序位于 <code>c</code> 之后。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"cabaa\", word2 = \"bcaaa\"\n<strong>输出：</strong>\"cbcabaaaaa\"\n<strong>解释：</strong>构造字典序最大的合并字符串，可行的一种方法如下所示：\n- 从 word1 中取第一个字符：merge = \"c\"，word1 = \"abaa\"，word2 = \"bcaaa\"\n- 从 word2 中取第一个字符：merge = \"cb\"，word1 = \"abaa\"，word2 = \"caaa\"\n- 从 word2 中取第一个字符：merge = \"cbc\"，word1 = \"abaa\"，word2 = \"aaa\"\n- 从 word1 中取第一个字符：merge = \"cbca\"，word1 = \"baa\"，word2 = \"aaa\"\n- 从 word1 中取第一个字符：merge = \"cbcab\"，word1 = \"aa\"，word2 = \"aaa\"\n- 将 word1 和 word2 中剩下的 5 个 a 附加到 merge 的末尾。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"abcabc\", word2 = \"abdcaba\"\n<strong>输出：</strong>\"abdcabcabcaba\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word1.length, word2.length <= 3000</code></li>\n\t<li><code>word1</code> 和 <code>word2</code> 仅由小写英文组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1755.最接近目标值的子序列和",
        "hardRate": "HARD",
        "passRate": "45.02%",
        "problemsUrl": "https://leetcode.cn/problems/closest-subsequence-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-subsequence-sum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个目标值 <code>goal</code> 。</p>\n\n<p>你需要从 <code>nums</code> 中选出一个子序列，使子序列元素总和最接近 <code>goal</code> 。也就是说，如果子序列元素和为 <code>sum</code> ，你需要 <strong>最小化绝对差</strong> <code>abs(sum - goal)</code> 。</p>\n\n<p>返回 <code>abs(sum - goal)</code> 可能的 <strong>最小值</strong> 。</p>\n\n<p>注意，数组的子序列是通过移除原始数组中的某些元素（可能全部或无）而形成的数组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,-7,3,5], goal = 6\n<strong>输出：</strong>0\n<strong>解释：</strong>选择整个数组作为选出的子序列，元素和为 6 。\n子序列和与目标值相等，所以绝对差为 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [7,-9,15,-2], goal = -5\n<strong>输出：</strong>1\n<strong>解释：</strong>选出子序列 [7,-9,-2] ，元素和为 -4 。\n绝对差为 abs(-4 - (-5)) = abs(1) = 1 ，是可能的最小值。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3], goal = -7\n<strong>输出：</strong>7\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 40</code></li>\n\t<li><code>-10<sup>7</sup> &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= goal &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1756.设计最近使用（MRU）队列",
        "hardRate": "MEDIUM",
        "passRate": "82.42%",
        "problemsUrl": "https://leetcode.cn/problems/design-most-recently-used-queue/",
        "solutionsUrl": "https://leetcode.cn/problems/design-most-recently-used-queue/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1757.可回收且低脂的产品",
        "hardRate": "EASY",
        "passRate": "87.57%",
        "problemsUrl": "https://leetcode.cn/problems/recyclable-and-low-fat-products/",
        "solutionsUrl": "https://leetcode.cn/problems/recyclable-and-low-fat-products/solution",
        "problemsDesc": "<p>表：<code>Products</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| product_id  | int     |\n| low_fats    | enum    |\n| recyclable  | enum    |\n+-------------+---------+\nproduct_id 是这个表的主键。\nlow_fats 是枚举类型，取值为以下两种 ('Y', 'N')，其中 'Y' 表示该产品是低脂产品，'N' 表示不是低脂产品。\nrecyclable 是枚举类型，取值为以下两种 ('Y', 'N')，其中 'Y' 表示该产品可回收，而 'N' 表示不可回收。</pre>\n\n<p> </p>\n\n<p>写出 SQL 语句，查找既是低脂又是可回收的产品编号。</p>\n\n<p>返回结果 <strong>无顺序要求</strong> 。</p>\n\n<p>查询结果格式如下例所示：</p>\n\n<pre>\nProducts 表：\n+-------------+----------+------------+\n| product_id  | low_fats | recyclable |\n+-------------+----------+------------+\n| 0           | Y        | N          |\n| 1           | Y        | Y          |\n| 2           | N        | Y          |\n| 3           | Y        | Y          |\n| 4           | N        | N          |\n+-------------+----------+------------+\nResult 表：\n+-------------+\n| product_id  |\n+-------------+\n| 1           |\n| 3           |\n+-------------+\n只有产品 id 为 1 和 3 的产品，既是低脂又是可回收的产品。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1758.生成交替二进制字符串的最少操作数",
        "hardRate": "EASY",
        "passRate": "69.70%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-changes-to-make-alternating-binary-string/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-changes-to-make-alternating-binary-string/solution",
        "problemsDesc": "<p>给你一个仅由字符 <code>'0'</code> 和 <code>'1'</code> 组成的字符串 <code>s</code> 。一步操作中，你可以将任一 <code>'0'</code> 变成 <code>'1'</code> ，或者将 <code>'1'</code> 变成 <code>'0'</code> 。</p>\n\n<p><strong>交替字符串</strong> 定义为：如果字符串中不存在相邻两个字符相等的情况，那么该字符串就是交替字符串。例如，字符串 <code>\"010\"</code> 是交替字符串，而字符串 <code>\"0100\"</code> 不是。</p>\n\n<p>返回使 <code>s</code> 变成 <strong>交替字符串</strong> 所需的 <strong>最少</strong> 操作数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"0100\"\n<strong>输出：</strong>1\n<strong>解释：</strong>如果将最后一个字符变为 '1' ，s 就变成 \"0101\" ，即符合交替字符串定义。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"10\"\n<strong>输出：</strong>0\n<strong>解释：</strong>s 已经是交替字符串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = \"1111\"\n<strong>输出：</strong>2\n<strong>解释：</strong>需要 2 步操作得到 \"0101\" 或 \"1010\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s[i]</code> 是 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1759.统计同质子字符串的数目",
        "hardRate": "MEDIUM",
        "passRate": "51.10%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-homogenous-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-homogenous-substrings/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，返回<em> </em><code>s</code><em> </em>中 <strong>同质子字符串</strong> 的数目。由于答案可能很大，只需返回对 <code>10<sup>9</sup> + 7</code> <strong>取余 </strong>后的结果。</p>\n\n<p><strong>同质字符串</strong> 的定义为：如果一个字符串中的所有字符都相同，那么该字符串就是同质字符串。</p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abbcccaa\"\n<strong>输出：</strong>13\n<strong>解释：</strong>同质子字符串如下所列：\n\"a\"   出现 3 次。\n\"aa\"  出现 1 次。\n\"b\"   出现 2 次。\n\"bb\"  出现 1 次。\n\"c\"   出现 3 次。\n\"cc\"  出现 2 次。\n\"ccc\" 出现 1 次。\n3 + 1 + 2 + 1 + 3 + 2 + 1 = 13</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"xy\"\n<strong>输出：</strong>2\n<strong>解释：</strong>同质子字符串是 \"x\" 和 \"y\" 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"zzzzz\"\n<strong>输出：</strong>15\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写字符串组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1760.袋子里最少数目的球",
        "hardRate": "MEDIUM",
        "passRate": "64.10%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 表示第 <code>i</code> 个袋子里球的数目。同时给你一个整数 <code>maxOperations</code> 。</p>\n\n<p>你可以进行如下操作至多 <code>maxOperations</code> 次：</p>\n\n<ul>\n\t<li>选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 <strong>正整数</strong> 个球。\n\n\t<ul>\n\t\t<li>比方说，一个袋子里有 <code>5</code> 个球，你可以把它们分到两个新袋子里，分别有 <code>1</code> 个和 <code>4</code> 个球，或者分别有 <code>2</code> 个和 <code>3</code> 个球。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>你的开销是单个袋子里球数目的 <strong>最大值</strong> ，你想要 <strong>最小化</strong> 开销。</p>\n\n<p>请你返回进行上述操作后的最小开销。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [9], maxOperations = 2\n<b>输出：</b>3\n<b>解释：</b>\n- 将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[<strong>9</strong>] -> [6,3] 。\n- 将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[<strong>6</strong>,3] -> [3,3,3] 。\n装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,4,8,2], maxOperations = 4\n<b>输出：</b>2\n<strong>解释：</strong>\n- 将装有 8 个球的袋子分成装有 4 个和 4 个球的袋子。[2,4,<strong>8</strong>,2] -> [2,4,4,4,2] 。\n- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,<strong>4</strong>,4,4,2] -> [2,2,2,4,4,2] 。\n- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,<strong>4</strong>,4,2] -> [2,2,2,2,2,4,2] 。\n- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,2,2,<strong>4</strong>,2] -> [2,2,2,2,2,2,2,2] 。\n装有最多球的袋子里装有 2 个球，所以开销为 2 并返回 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [7,17], maxOperations = 2\n<b>输出：</b>7\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= maxOperations, nums[i] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1761.一个图中连通三元组的最小度数",
        "hardRate": "HARD",
        "passRate": "46.23%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph/solution",
        "problemsDesc": "<p>给你一个无向图，整数 <code>n</code> 表示图中节点的数目，<code>edges</code> 数组表示图中的边，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> ，表示 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code><sub> </sub>之间有一条无向边。</p>\n\n<p>一个 <strong>连通三元组</strong> 指的是 <strong>三个</strong> 节点组成的集合且这三个点之间 <strong>两两</strong> 有边。</p>\n\n<p><strong>连通三元组的度数</strong> 是所有满足此条件的边的数目：一个顶点在这个三元组内，而另一个顶点不在这个三元组内。</p>\n\n<p>请你返回所有连通三元组中度数的 <strong>最小值</strong> ，如果图中没有连通三元组，那么返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/14/trios1.png\" style=\"width: 388px; height: 164px;\" />\n<pre>\n<b>输入：</b>n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]\n<b>输出：</b>3\n<b>解释：</b>只有一个三元组 [1,2,3] 。构成度数的边在上图中已被加粗。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/14/trios2.png\" style=\"width: 388px; height: 164px;\" />\n<pre>\n<b>输入：</b>n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]\n<b>输出：</b>0\n<b>解释：</b>有 3 个三元组：\n1) [1,4,3]，度数为 0 。\n2) [2,5,6]，度数为 2 。\n3) [5,6,7]，度数为 2 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 400</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 <= edges.length <= n * (n-1) / 2</code></li>\n\t<li><code>1 <= u<sub>i</sub>, v<sub>i</sub> <= n</code></li>\n\t<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>\n\t<li>图中没有重复的边。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1762.能看到海景的建筑物",
        "hardRate": "MEDIUM",
        "passRate": "71.46%",
        "problemsUrl": "https://leetcode.cn/problems/buildings-with-an-ocean-view/",
        "solutionsUrl": "https://leetcode.cn/problems/buildings-with-an-ocean-view/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1763.最长的美好子字符串",
        "hardRate": "EASY",
        "passRate": "67.24%",
        "problemsUrl": "https://leetcode.cn/problems/longest-nice-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-nice-substring/solution",
        "problemsDesc": "<p>当一个字符串 <code>s</code> 包含的每一种字母的大写和小写形式 <strong>同时</strong> 出现在 <code>s</code> 中，就称这个字符串 <code>s</code> 是 <strong>美好</strong> 字符串。比方说，<code>\"abABB\"</code> 是美好字符串，因为 <code>'A'</code> 和 <code>'a'</code> 同时出现了，且 <code>'B'</code> 和 <code>'b'</code> 也同时出现了。然而，<code>\"abA\"</code> 不是美好字符串因为 <code>'b'</code> 出现了，而 <code>'B'</code> 没有出现。</p>\n\n<p>给你一个字符串 <code>s</code> ，请你返回 <code>s</code> 最长的 <strong>美好子字符串</strong> 。如果有多个答案，请你返回 <strong>最早</strong> 出现的一个。如果不存在美好子字符串，请你返回一个空字符串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"YazaAay\"\n<b>输出：</b>\"aAa\"\n<strong>解释：</strong>\"aAa\" 是一个美好字符串，因为这个子串中仅含一种字母，其小写形式 'a' 和大写形式 'A' 也同时出现了。\n\"aAa\" 是最长的美好子字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"Bb\"\n<b>输出：</b>\"Bb\"\n<b>解释：</b>\"Bb\" 是美好字符串，因为 'B' 和 'b' 都出现了。整个字符串也是原字符串的子字符串。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"c\"\n<b>输出：</b>\"\"\n<b>解释：</b>没有美好子字符串。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"dDzeE\"\n<b>输出：</b>\"dD\"\n<strong>解释：</strong>\"dD\" 和 \"eE\" 都是最长美好子字符串。\n由于有多个美好子字符串，返回 \"dD\" ，因为它出现得最早。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 100</code></li>\n\t<li><code>s</code> 只包含大写和小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1764.通过连接另一个数组的子数组得到一个数组",
        "hardRate": "MEDIUM",
        "passRate": "55.69%",
        "problemsUrl": "https://leetcode.cn/problems/form-array-by-concatenating-subarrays-of-another-array/",
        "solutionsUrl": "https://leetcode.cn/problems/form-array-by-concatenating-subarrays-of-another-array/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的二维整数数组 <code>groups</code> ，同时给你一个整数数组 <code>nums</code> 。</p>\n\n<p>你是否可以从 <code>nums</code> 中选出 <code>n</code> 个 <strong>不相交</strong> 的子数组，使得第 <code>i</code> 个子数组与 <code>groups[i]</code> （下标从 <strong>0</strong> 开始）完全相同，且如果 <code>i > 0</code> ，那么第 <code>(i-1)</code> 个子数组在 <code>nums</code> 中出现的位置在第 <code>i</code> 个子数组前面。（也就是说，这些子数组在 <code>nums</code> 中出现的顺序需要与 <code>groups</code> 顺序相同）</p>\n\n<p>如果你可以找出这样的 <code>n</code> 个子数组，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p>如果不存在下标为 <code>k</code> 的元素 <code>nums[k]</code> 属于不止一个子数组，就称这些子数组是 <strong>不相交</strong> 的。子数组指的是原数组中连续元素组成的一个序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>groups = [[1,-1,-1],[3,-2,0]], nums = [1,-1,0,1,-1,-1,3,-2,0]\n<b>输出：</b>true\n<b>解释：</b>你可以分别在 nums 中选出第 0 个子数组 [1,-1,0,<strong>1,</strong><strong>-1,</strong><strong>-1</strong>,3,-2,0] 和第 1 个子数组 [1,-1,0,1,-1,-1,<strong>3,</strong><strong>-2,0</strong>] 。\n这两个子数组是不相交的，因为它们没有任何共同的元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>groups = [[10,-2],[1,2,3,4]], nums = [1,2,3,4,10,-2]\n<b>输出：</b>false\n<strong>解释：</strong>选择子数组 [<strong>1,2,3,4</strong>,10,-2] 和 [1,2,3,4,<strong>10,-2</strong>] 是不正确的，因为它们出现的顺序与 groups 中顺序不同。\n[10,-2] 必须出现在 [1,2,3,4] 之前。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>groups = [[1,2,3],[3,4]], nums = [7,7,1,2,3,4,7,7]\n<b>输出：</b>false\n<strong>解释：</strong>选择子数组 [7,7,<strong>1,2,3</strong>,4,7,7] 和 [7,7,1,2,<strong>3,4</strong>,7,7] 是不正确的，因为它们不是不相交子数组。\n它们有一个共同的元素 nums[4] （下标从 0 开始）。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>groups.length == n</code></li>\n\t<li><code>1 <= n <= 10<sup>3</sup></code></li>\n\t<li><code>1 <= groups[i].length, sum(groups[i].length) <= 10<sup><span style=\"\">3</span></sup></code></li>\n\t<li><code>1 <= nums.length <= 10<sup>3</sup></code></li>\n\t<li><code>-10<sup>7</sup> <= groups[i][j], nums[k] <= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1765.地图中的最高点",
        "hardRate": "MEDIUM",
        "passRate": "66.33%",
        "problemsUrl": "https://leetcode.cn/problems/map-of-highest-peak/",
        "solutionsUrl": "https://leetcode.cn/problems/map-of-highest-peak/solution",
        "problemsDesc": "<p>给你一个大小为&nbsp;<code>m x n</code>&nbsp;的整数矩阵&nbsp;<code>isWater</code>&nbsp;，它代表了一个由 <strong>陆地</strong>&nbsp;和 <strong>水域</strong>&nbsp;单元格组成的地图。</p>\n\n<ul>\n\t<li>如果&nbsp;<code>isWater[i][j] == 0</code>&nbsp;，格子&nbsp;<code>(i, j)</code>&nbsp;是一个 <strong>陆地</strong>&nbsp;格子。</li>\n\t<li>如果&nbsp;<code>isWater[i][j] == 1</code>&nbsp;，格子&nbsp;<code>(i, j)</code>&nbsp;是一个 <strong>水域</strong>&nbsp;格子。</li>\n</ul>\n\n<p>你需要按照如下规则给每个单元格安排高度：</p>\n\n<ul>\n\t<li>每个格子的高度都必须是非负的。</li>\n\t<li>如果一个格子是 <strong>水域</strong>&nbsp;，那么它的高度必须为 <code>0</code>&nbsp;。</li>\n\t<li>任意相邻的格子高度差 <strong>至多</strong>&nbsp;为 <code>1</code>&nbsp;。当两个格子在正东、南、西、北方向上相互紧挨着，就称它们为相邻的格子。（也就是说它们有一条公共边）</li>\n</ul>\n\n<p>找到一种安排高度的方案，使得矩阵中的最高高度值&nbsp;<strong>最大</strong>&nbsp;。</p>\n\n<p>请你返回一个大小为&nbsp;<code>m x n</code>&nbsp;的整数矩阵 <code>height</code>&nbsp;，其中 <code>height[i][j]</code>&nbsp;是格子 <code>(i, j)</code>&nbsp;的高度。如果有多种解法，请返回&nbsp;<strong>任意一个</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-82045-am.png\" style=\"width: 220px; height: 219px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>isWater = [[0,1],[0,0]]\n<b>输出：</b>[[1,0],[2,1]]\n<b>解释：</b>上图展示了给各个格子安排的高度。\n蓝色格子是水域格，绿色格子是陆地格。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-82050-am.png\" style=\"width: 300px; height: 296px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>isWater = [[0,0,1],[1,0,0],[0,0,0]]\n<b>输出：</b>[[1,1,0],[0,1,1],[1,2,2]]\n<b>解释：</b>所有安排方案中，最高可行高度为 2 。\n任意安排方案中，只要最高高度为 2 且符合上述规则的，都为可行方案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == isWater.length</code></li>\n\t<li><code>n == isWater[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>isWater[i][j]</code>&nbsp;要么是&nbsp;<code>0</code>&nbsp;，要么是&nbsp;<code>1</code>&nbsp;。</li>\n\t<li>至少有 <strong>1</strong>&nbsp;个水域格子。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1766.互质树",
        "hardRate": "HARD",
        "passRate": "40.29%",
        "problemsUrl": "https://leetcode.cn/problems/tree-of-coprimes/",
        "solutionsUrl": "https://leetcode.cn/problems/tree-of-coprimes/solution",
        "problemsDesc": "<p>给你一个 <code>n</code> 个节点的树（也就是一个无环连通无向图），节点编号从 <code>0</code> 到 <code>n - 1</code> ，且恰好有 <code>n - 1</code> 条边，每个节点有一个值。树的 <strong>根节点</strong> 为 0 号点。</p>\n\n<p>给你一个整数数组 <code>nums</code> 和一个二维数组 <code>edges</code> 来表示这棵树。<code>nums[i]</code> 表示第 <code>i</code> 个点的值，<code>edges[j] = [u<sub>j</sub>, v<sub>j</sub>]</code> 表示节点 <code>u<sub>j</sub></code> 和节点 <code>v<sub>j</sub></code> 在树中有一条边。</p>\n\n<p>当 <code>gcd(x, y) == 1</code> ，我们称两个数 <code>x</code> 和 <code>y</code> 是 <strong>互质的</strong> ，其中 <code>gcd(x, y)</code> 是 <code>x</code> 和 <code>y</code> 的 <strong>最大公约数</strong> 。</p>\n\n<p>从节点 <code>i</code> 到 <strong>根</strong> 最短路径上的点都是节点 <code>i</code> 的祖先节点。一个节点 <strong>不是</strong> 它自己的祖先节点。</p>\n\n<p>请你返回一个大小为 <code>n</code> 的数组 <code>ans</code> ，其中<em> </em><code>ans[i]</code>是离节点 <code>i</code> 最近的祖先节点且满足<em> </em><code>nums[i]</code> 和<em> </em><code>nums[ans[i]]</code> 是 <strong>互质的</strong> ，如果不存在这样的祖先节点，<code>ans[i]</code> 为 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/20/untitled-diagram.png\" style=\"width: 191px; height: 281px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,3,3,2], edges = [[0,1],[1,2],[1,3]]\n<b>输出：</b>[-1,0,0,1]\n<b>解释：</b>上图中，每个节点的值在括号中表示。\n- 节点 0 没有互质祖先。\n- 节点 1 只有一个祖先节点 0 。它们的值是互质的（gcd(2,3) == 1）。\n- 节点 2 有两个祖先节点，分别是节点 1 和节点 0 。节点 1 的值与它的值不是互质的（gcd(3,3) == 3）但节点 0 的值是互质的(gcd(2,3) == 1)，所以节点 0 是最近的符合要求的祖先节点。\n- 节点 3 有两个祖先节点，分别是节点 1 和节点 0 。它与节点 1 互质（gcd(3,2) == 1），所以节点 1 是离它最近的符合要求的祖先节点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/20/untitled-diagram1.png\" style=\"width: 441px; height: 291px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,6,10,2,3,6,15], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]\n<b>输出：</b>[-1,0,-1,0,0,0,-1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length == n</code></li>\n\t<li><code>1 <= nums[i] <= 50</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[j].length == 2</code></li>\n\t<li><code>0 <= u<sub>j</sub>, v<sub>j</sub> < n</code></li>\n\t<li><code>u<sub>j</sub> != v<sub>j</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1767.寻找没有被执行的任务对",
        "hardRate": "HARD",
        "passRate": "80.19%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-subtasks-that-did-not-execute/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-subtasks-that-did-not-execute/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1768.交替合并字符串",
        "hardRate": "EASY",
        "passRate": "75.82%",
        "problemsUrl": "https://leetcode.cn/problems/merge-strings-alternately/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-strings-alternately/solution",
        "problemsDesc": "<p>给你两个字符串 <code>word1</code> 和 <code>word2</code> 。请你从 <code>word1</code> 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。</p>\n\n<p>返回 <strong>合并后的字符串</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"abc\", word2 = \"pqr\"\n<strong>输出：</strong>\"apbqcr\"\n<strong>解释：</strong>字符串合并情况如下所示：\nword1：  a   b   c\nword2：    p   q   r\n合并后：  a p b q c r\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"ab\", word2 = \"pqrs\"\n<strong>输出：</strong>\"apbqrs\"\n<strong>解释：</strong>注意，word2 比 word1 长，\"rs\" 需要追加到合并后字符串的末尾。\nword1：  a   b \nword2：    p   q   r   s\n合并后：  a p b q   r   s\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"abcd\", word2 = \"pq\"\n<strong>输出：</strong>\"apbqcd\"\n<strong>解释：</strong>注意，word1 比 word2 长，\"cd\" 需要追加到合并后字符串的末尾。\nword1：  a   b   c   d\nword2：    p   q \n合并后：  a p b q c   d\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word1.length, word2.length <= 100</code></li>\n\t<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1769.移动所有球到每个盒子所需的最小操作数",
        "hardRate": "MEDIUM",
        "passRate": "87.87%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/solution",
        "problemsDesc": "<p>有 <code>n</code> 个盒子。给你一个长度为 <code>n</code> 的二进制字符串 <code>boxes</code> ，其中 <code>boxes[i]</code> 的值为 <code>'0'</code> 表示第 <code>i</code> 个盒子是 <strong>空</strong> 的，而 <code>boxes[i]</code> 的值为 <code>'1'</code> 表示盒子里有 <strong>一个</strong> 小球。</p>\n\n<p>在一步操作中，你可以将 <strong>一个</strong> 小球从某个盒子移动到一个与之相邻的盒子中。第 <code>i</code> 个盒子和第 <code>j</code> 个盒子相邻需满足 <code>abs(i - j) == 1</code> 。注意，操作执行后，某些盒子中可能会存在不止一个小球。</p>\n\n<p>返回一个长度为 <code>n</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是将所有小球移动到第 <code>i</code> 个盒子所需的 <strong>最小</strong> 操作数。</p>\n\n<p>每个 <code>answer[i]</code> 都需要根据盒子的 <strong>初始状态</strong> 进行计算。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>boxes = \"110\"\n<strong>输出：</strong>[1,1,3]\n<strong>解释：</strong>每个盒子对应的最小操作数如下：\n1) 第 1 个盒子：将一个小球从第 2 个盒子移动到第 1 个盒子，需要 1 步操作。\n2) 第 2 个盒子：将一个小球从第 1 个盒子移动到第 2 个盒子，需要 1 步操作。\n3) 第 3 个盒子：将一个小球从第 1 个盒子移动到第 3 个盒子，需要 2 步操作。将一个小球从第 2 个盒子移动到第 3 个盒子，需要 1 步操作。共计 3 步操作。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>boxes = \"001011\"\n<strong>输出：</strong>[11,8,5,4,3,4]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == boxes.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2000</code></li>\n\t<li><code>boxes[i]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1770.执行乘法运算的最大分数",
        "hardRate": "HARD",
        "passRate": "39.73%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-from-performing-multiplication-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-from-performing-multiplication-operations/solution",
        "problemsDesc": "<p>给你两个长度分别 <code>n</code> 和 <code>m</code> 的整数数组 <code>nums</code> 和 <code>multipliers</code><strong> </strong>，其中 <code>n &gt;= m</code> ，数组下标 <strong>从 1 开始</strong> 计数。</p>\n\n<p>初始时，你的分数为 <code>0</code> 。你需要执行恰好 <code>m</code> 步操作。在第 <code>i</code> 步操作（<strong>从 1 开始</strong> 计数）中，需要：</p>\n\n<ul>\n\t<li>选择数组 <code>nums</code> <strong>开头处或者末尾处</strong> 的整数 <code>x</code> 。</li>\n\t<li>你获得 <code>multipliers[i] * x</code> 分，并累加到你的分数中。</li>\n\t<li>将 <code>x</code> 从数组 <code>nums</code> 中移除。</li>\n</ul>\n\n<p>在执行<em> </em><code>m</code> 步操作后，返回 <strong>最大</strong> 分数<em>。</em></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3], multipliers = [3,2,1]\n<strong>输出：</strong>14\n<strong>解释：</strong>一种最优解决方案如下：\n- 选择末尾处的整数 3 ，[1,2,<strong>3</strong>] ，得 3 * 3 = 9 分，累加到分数中。\n- 选择末尾处的整数 2 ，[1,<strong>2</strong>] ，得 2 * 2 = 4 分，累加到分数中。\n- 选择末尾处的整数 1 ，[<strong>1</strong>] ，得 1 * 1 = 1 分，累加到分数中。\n总分数为 9 + 4 + 1 = 14 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]\n<strong>输出：</strong>102\n<strong>解释：</strong>一种最优解决方案如下：\n- 选择开头处的整数 -5 ，[<strong>-5</strong>,-3,-3,-2,7,1] ，得 -5 * -10 = 50 分，累加到分数中。\n- 选择开头处的整数 -3 ，[<strong>-3</strong>,-3,-2,7,1] ，得 -3 * -5 = 15 分，累加到分数中。\n- 选择开头处的整数 -3 ，[<strong>-3</strong>,-2,7,1] ，得 -3 * 3 = -9 分，累加到分数中。\n- 选择末尾处的整数 1 ，[-2,7,<strong>1</strong>] ，得 1 * 4 = 4 分，累加到分数中。\n- 选择末尾处的整数 7 ，[-2,<strong>7</strong>] ，得 7 * 6 = 42 分，累加到分数中。\n总分数为 50 + 15 - 9 + 4 + 42 = 102 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>m == multipliers.length</code></li>\n\t<li><code>1 &lt;= m &lt;= 10<sup>3</sup></code></li>\n\t<li><code>m &lt;= n &lt;= 10<sup>5</sup></code><code> </code></li>\n\t<li><code>-1000 &lt;= nums[i], multipliers[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1771.由子序列构造的最长回文串的长度",
        "hardRate": "HARD",
        "passRate": "38.57%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-palindrome-length-from-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-palindrome-length-from-subsequences/solution",
        "problemsDesc": "<p>给你两个字符串 <code>word1</code> 和 <code>word2</code> ，请你按下述方法构造一个字符串：</p>\n\n<ul>\n\t<li>从 <code>word1</code> 中选出某个 <strong>非空</strong> 子序列 <code>subsequence1</code> 。</li>\n\t<li>从 <code>word2</code> 中选出某个 <strong>非空</strong> 子序列 <code>subsequence2</code> 。</li>\n\t<li>连接两个子序列 <code>subsequence1 + subsequence2</code> ，得到字符串。</li>\n</ul>\n\n<p>返回可按上述方法构造的最长 <strong>回文串</strong> 的 <strong>长度</strong> 。如果无法构造回文串，返回 <code>0</code> 。</p>\n\n<p>字符串 <code>s</code> 的一个 <strong>子序列</strong> 是通过从 <code>s</code> 中删除一些（也可能不删除）字符而不更改其余字符的顺序生成的字符串。</p>\n\n<p><strong>回文串</strong> 是正着读和反着读结果一致的字符串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>word1 = \"cacb\", word2 = \"cbba\"\n<strong>输出：</strong>5\n<strong>解释：</strong>从 word1 中选出 \"ab\" ，从 word2 中选出 \"cba\" ，得到回文串 \"abcba\" 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>word1 = \"ab\", word2 = \"ab\"\n<strong>输出：</strong>3\n<strong>解释：</strong>从 word1 中选出 \"ab\" ，从 word2 中选出 \"a\" ，得到回文串 \"aba\" 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>word1 = \"aa\", word2 = \"bb\"\n<strong>输出：</strong>0\n<strong>解释：</strong>无法按题面所述方法构造回文串，所以返回 0 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word1.length, word2.length &lt;= 1000</code></li>\n\t<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1772.按受欢迎程度排列功能",
        "hardRate": "MEDIUM",
        "passRate": "47.40%",
        "problemsUrl": "https://leetcode.cn/problems/sort-features-by-popularity/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-features-by-popularity/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1773.统计匹配检索规则的物品数量",
        "hardRate": "EASY",
        "passRate": "86.42%",
        "problemsUrl": "https://leetcode.cn/problems/count-items-matching-a-rule/",
        "solutionsUrl": "https://leetcode.cn/problems/count-items-matching-a-rule/solution",
        "problemsDesc": "<p>给你一个数组 <code>items</code> ，其中 <code>items[i] = [type<sub>i</sub>, color<sub>i</sub>, name<sub>i</sub>]</code> ，描述第 <code>i</code> 件物品的类型、颜色以及名称。</p>\n\n<p>另给你一条由两个字符串 <code>ruleKey</code> 和 <code>ruleValue</code> 表示的检索规则。</p>\n\n<p>如果第 <code>i</code> 件物品能满足下述条件之一，则认为该物品与给定的检索规则 <strong>匹配</strong> ：</p>\n\n<ul>\n\t<li><code>ruleKey == \"type\"</code> 且 <code>ruleValue == type<sub>i</sub></code> 。</li>\n\t<li><code>ruleKey == \"color\"</code> 且 <code>ruleValue == color<sub>i</sub></code> 。</li>\n\t<li><code>ruleKey == \"name\"</code> 且 <code>ruleValue == name<sub>i</sub></code> 。</li>\n</ul>\n\n<p>统计并返回 <strong>匹配检索规则的物品数量</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"color\", ruleValue = \"silver\"\n<strong>输出：</strong>1\n<strong>解释：</strong>只有一件物品匹配检索规则，这件物品是 [\"computer\",\"silver\",\"lenovo\"] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"type\", ruleValue = \"phone\"\n<strong>输出：</strong>2\n<strong>解释：</strong>只有两件物品匹配检索规则，这两件物品分别是 [\"phone\",\"blue\",\"pixel\"] 和 [\"phone\",\"gold\",\"iphone\"] 。注意，[\"computer\",\"silver\",\"phone\"] 未匹配检索规则。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= items.length <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= type<sub>i</sub>.length, color<sub>i</sub>.length, name<sub>i</sub>.length, ruleValue.length <= 10</code></li>\n\t<li><code>ruleKey</code> 等于 <code>\"type\"</code>、<code>\"color\"</code> 或 <code>\"name\"</code></li>\n\t<li>所有字符串仅由小写字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1774.最接近目标价格的甜点成本",
        "hardRate": "MEDIUM",
        "passRate": "57.50%",
        "problemsUrl": "https://leetcode.cn/problems/closest-dessert-cost/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-dessert-cost/solution",
        "problemsDesc": "<p>你打算做甜点，现在需要购买配料。目前共有 <code>n</code> 种冰激凌基料和 <code>m</code> 种配料可供选购。而制作甜点需要遵循以下几条规则：</p>\n\n<ul>\n\t<li>必须选择 <strong>一种</strong> 冰激凌基料。</li>\n\t<li>可以添加 <strong>一种或多种</strong> 配料，也可以不添加任何配料。</li>\n\t<li>每种类型的配料 <strong>最多两份</strong> 。</li>\n</ul>\n\n<p>给你以下三个输入：</p>\n\n<ul>\n\t<li><code>baseCosts</code> ，一个长度为 <code>n</code> 的整数数组，其中每个 <code>baseCosts[i]</code> 表示第 <code>i</code> 种冰激凌基料的价格。</li>\n\t<li><code>toppingCosts</code>，一个长度为 <code>m</code> 的整数数组，其中每个 <code>toppingCosts[i]</code> 表示 <strong>一份</strong> 第 <code>i</code> 种冰激凌配料的价格。</li>\n\t<li><code>target</code> ，一个整数，表示你制作甜点的目标价格。</li>\n</ul>\n\n<p>你希望自己做的甜点总成本尽可能接近目标价格 <code>target</code> 。</p>\n\n<p>返回最接近<em> </em><code>target</code> 的甜点成本。如果有多种方案，返回 <strong>成本相对较低</strong> 的一种。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>baseCosts = [1,7], toppingCosts = [3,4], target = 10\n<strong>输出：</strong>10\n<strong>解释：</strong>考虑下面的方案组合（所有下标均从 0 开始）：\n- 选择 1 号基料：成本 7\n- 选择 1 份 0 号配料：成本 1 x 3 = 3\n- 选择 0 份 1 号配料：成本 0 x 4 = 0\n总成本：7 + 3 + 0 = 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\n<strong>输出：</strong>17\n<strong>解释：</strong>考虑下面的方案组合（所有下标均从 0 开始）：\n- 选择 1 号基料：成本 3\n- 选择 1 份 0 号配料：成本 1 x 4 = 4\n- 选择 2 份 1 号配料：成本 2 x 5 = 10\n- 选择 0 份 2 号配料：成本 0 x 100 = 0\n总成本：3 + 4 + 10 + 0 = 17 。不存在总成本为 18 的甜点制作方案。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>baseCosts = [3,10], toppingCosts = [2,5], target = 9\n<strong>输出：</strong>8\n<strong>解释：</strong>可以制作总成本为 8 和 10 的甜点。返回 8 ，因为这是成本更低的方案。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>baseCosts = [10], toppingCosts = [1], target = 1\n<strong>输出：</strong>10\n<strong>解释：</strong>注意，你可以选择不添加任何配料，但你必须选择一种基料。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == baseCosts.length</code></li>\n\t<li><code>m == toppingCosts.length</code></li>\n\t<li><code>1 <= n, m <= 10</code></li>\n\t<li><code>1 <= baseCosts[i], toppingCosts[i] <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= target <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1775.通过最少操作次数使数组的和相等",
        "hardRate": "MEDIUM",
        "passRate": "56.43%",
        "problemsUrl": "https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/solution",
        "problemsDesc": "<p>给你两个长度可能不等的整数数组 <code>nums1</code> 和 <code>nums2</code> 。两个数组中的所有值都在 <code>1</code> 到 <code>6</code> 之间（包含 <code>1</code> 和 <code>6</code>）。</p>\n\n<p>每次操作中，你可以选择 <strong>任意</strong> 数组中的任意一个整数，将它变成 <code>1</code> 到 <code>6</code> 之间 <strong>任意</strong> 的值（包含 <code>1</code> 和 <code><span style=\"\">6</span></code>）。</p>\n\n<p>请你返回使 <code>nums1</code> 中所有数的和与 <code>nums2</code> 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2]\n<b>输出：</b>3\n<b>解释：</b>你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。\n- 将 nums2[0] 变为 6 。 nums1 = [1,2,3,4,5,6], nums2 = [<strong>6</strong>,1,2,2,2,2] 。\n- 将 nums1[5] 变为 1 。 nums1 = [1,2,3,4,5,<strong>1</strong>], nums2 = [6,1,2,2,2,2] 。\n- 将 nums1[2] 变为 2 。 nums1 = [1,2,<strong>2</strong>,4,5,1], nums2 = [6,1,2,2,2,2] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,1,1,1,1,1,1], nums2 = [6]\n<b>输出：</b>-1\n<b>解释：</b>没有办法减少 nums1 的和或者增加 nums2 的和使二者相等。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums1 = [6,6], nums2 = [1]\n<b>输出：</b>3\n<b>解释：</b>你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。\n- 将 nums1[0] 变为 2 。 nums1 = [<strong>2</strong>,6], nums2 = [1] 。\n- 将 nums1[1] 变为 2 。 nums1 = [2,<strong>2</strong>], nums2 = [1] 。\n- 将 nums2[0] 变为 4 。 nums1 = [2,2], nums2 = [<strong>4</strong>] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1776.车队 II",
        "hardRate": "HARD",
        "passRate": "48.63%",
        "problemsUrl": "https://leetcode.cn/problems/car-fleet-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/car-fleet-ii/solution",
        "problemsDesc": "<p>在一条单车道上有 <code>n</code> 辆车，它们朝着同样的方向行驶。给你一个长度为 <code>n</code> 的数组 <code>cars</code> ，其中 <code>cars[i] = [position<sub>i</sub>, speed<sub>i</sub>]</code> ，它表示：</p>\n\n<ul>\n\t<li><code>position<sub>i</sub></code> 是第 <code>i</code> 辆车和道路起点之间的距离（单位：米）。题目保证 <code>position<sub>i</sub> < position<sub>i+1</sub></code><sub> </sub>。</li>\n\t<li><code>speed<sub>i</sub></code> 是第 <code>i</code> 辆车的初始速度（单位：米/秒）。</li>\n</ul>\n\n<p>简单起见，所有车子可以视为在数轴上移动的点。当两辆车占据同一个位置时，我们称它们相遇了。一旦两辆车相遇，它们会合并成一个车队，这个车队里的车有着同样的位置和相同的速度，速度为这个车队里 <strong>最慢</strong> 一辆车的速度。</p>\n\n<p>请你返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 <code>i</code> 辆车与下一辆车相遇的时间（单位：秒），如果这辆车不会与下一辆车相遇，则 <code>answer[i]</code> 为 <code>-1</code> 。答案精度误差需在 <code>10<sup>-5</sup></code> 以内。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>cars = [[1,2],[2,1],[4,3],[7,2]]\n<b>输出：</b>[1.00000,-1.00000,3.00000,-1.00000]\n<b>解释：</b>经过恰好 1 秒以后，第一辆车会与第二辆车相遇，并形成一个 1 m/s 的车队。经过恰好 3 秒以后，第三辆车会与第四辆车相遇，并形成一个 2 m/s 的车队。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>cars = [[3,4],[5,4],[6,3],[9,1]]\n<b>输出：</b>[2.00000,1.00000,1.50000,-1.00000]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= cars.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= position<sub>i</sub>, speed<sub>i</sub> <= 10<sup>6</sup></code></li>\n\t<li><code>position<sub>i</sub> < position<sub>i+1</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1777.每家商店的产品价格",
        "hardRate": "EASY",
        "passRate": "78.38%",
        "problemsUrl": "https://leetcode.cn/problems/products-price-for-each-store/",
        "solutionsUrl": "https://leetcode.cn/problems/products-price-for-each-store/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1778.未知网格中的最短路径",
        "hardRate": "MEDIUM",
        "passRate": "48.10%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-path-in-a-hidden-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-path-in-a-hidden-grid/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1779.找到最近的有相同 X 或 Y 坐标的点",
        "hardRate": "EASY",
        "passRate": "68.91%",
        "problemsUrl": "https://leetcode.cn/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate/",
        "solutionsUrl": "https://leetcode.cn/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate/solution",
        "problemsDesc": "<p>给你两个整数&nbsp;<code>x</code> 和&nbsp;<code>y</code>&nbsp;，表示你在一个笛卡尔坐标系下的&nbsp;<code>(x, y)</code>&nbsp;处。同时，在同一个坐标系下给你一个数组&nbsp;<code>points</code>&nbsp;，其中&nbsp;<code>points[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示在&nbsp;<code>(a<sub>i</sub>, b<sub>i</sub>)</code>&nbsp;处有一个点。当一个点与你所在的位置有相同的 <code>x</code> 坐标或者相同的 <code>y</code> 坐标时，我们称这个点是 <b>有效的</b>&nbsp;。</p>\n\n<p>请返回距离你当前位置&nbsp;<strong>曼哈顿距离</strong>&nbsp;最近的&nbsp;<strong>有效</strong>&nbsp;点的下标（下标从 <strong>0</strong> 开始）。如果有多个最近的有效点，请返回下标&nbsp;<strong>最小</strong>&nbsp;的一个。如果没有有效点，请返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>两个点 <code>(x<sub>1</sub>, y<sub>1</sub>)</code>&nbsp;和 <code>(x<sub>2</sub>, y<sub>2</sub>)</code>&nbsp;之间的 <strong>曼哈顿距离</strong>&nbsp;为&nbsp;<code>abs(x<sub>1</sub> - x<sub>2</sub>) + abs(y<sub>1</sub> - y<sub>2</sub>)</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]]\n<b>输出：</b>2\n<b>解释：</b>所有点中，[3,1]，[2,4] 和 [4,4] 是有效点。有效点中，[2,4] 和 [4,4] 距离你当前位置的曼哈顿距离最小，都为 1 。[2,4] 的下标最小，所以返回 2 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>x = 3, y = 4, points = [[3,4]]\n<b>输出：</b>0\n<b>提示：</b>答案可以与你当前所在位置坐标相同。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>x = 3, y = 4, points = [[2,3]]\n<b>输出：</b>-1\n<b>解释：</b>没有 有效点。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= points.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>1 &lt;= x, y, a<sub>i</sub>, b<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1780.判断一个数字是否可以表示成三的幂的和",
        "hardRate": "MEDIUM",
        "passRate": "74.79%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-number-is-a-sum-of-powers-of-three/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-number-is-a-sum-of-powers-of-three/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，如果你可以将 <code>n</code> 表示成若干个不同的三的幂之和，请你返回 <code>true</code> ，否则请返回 <code>false</code> 。</p>\n\n<p>对于一个整数 <code>y</code> ，如果存在整数 <code>x</code> 满足 <code>y == 3<sup>x</sup></code> ，我们称这个整数 <code>y</code> 是三的幂。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 12\n<b>输出：</b>true\n<b>解释：</b>12 = 3<sup>1</sup> + 3<sup>2</sup>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 91\n<b>输出：</b>true\n<b>解释：</b>91 = 3<sup>0</sup> + 3<sup>2</sup> + 3<sup>4</sup>\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>n = 21\n<b>输出：</b>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1781.所有子字符串美丽值之和",
        "hardRate": "MEDIUM",
        "passRate": "66.51%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-beauty-of-all-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-beauty-of-all-substrings/solution",
        "problemsDesc": "<p>一个字符串的 <strong>美丽值</strong> 定义为：出现频率最高字符与出现频率最低字符的出现次数之差。</p>\n\n<ul>\n\t<li>比方说，<code>\"abaacc\"</code> 的美丽值为 <code>3 - 1 = 2</code> 。</li>\n</ul>\n\n<p>给你一个字符串 <code>s</code> ，请你返回它所有子字符串的 <strong>美丽值</strong> 之和。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aabcb\"\n<b>输出：</b>5\n<strong>解释：</strong>美丽值不为零的字符串包括 [\"aab\",\"aabc\",\"aabcb\",\"abcb\",\"bcb\"] ，每一个字符串的美丽值都为 1 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aabcbaa\"\n<b>输出：</b>17\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <=<sup> </sup>500</code></li>\n\t<li><code>s</code> 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1782.统计点对的数目",
        "hardRate": "HARD",
        "passRate": "35.82%",
        "problemsUrl": "https://leetcode.cn/problems/count-pairs-of-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/count-pairs-of-nodes/solution",
        "problemsDesc": "<p>给你一个无向图，无向图由整数 <code>n</code>  ，表示图中节点的数目，和 <code>edges</code> 组成，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> 表示 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code><sub> </sub>之间有一条无向边。同时给你一个代表查询的整数数组 <code>queries</code> 。</p>\n\n<p>第 <code>j</code> 个查询的答案是满足如下条件的点对 <code>(a, b)</code> 的数目：</p>\n\n<ul>\n\t<li><code>a < b</code></li>\n\t<li><code>cnt</code> 是与 <code>a</code> <strong>或者 </strong><code>b</code> 相连的边的数目，且 <code>cnt</code> <strong>严格大于 </strong><code>queries[j]</code> 。</li>\n</ul>\n\n<p>请你返回一个数组 <code>answers</code> ，其中 <code>answers.length == queries.length</code> 且 <code>answers[j]</code> 是第 <code>j</code> 个查询的答案。</p>\n\n<p>请注意，图中可能会有 <strong>重复边</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://pic.leetcode-cn.com/1614828447-GMnLVg-image.png\" style=\"width: 310px; height: 278px;\" />\n<pre>\n<b>输入：</b>n = 4, edges = [[1,2],[2,4],[1,3],[2,3],[2,1]], queries = [2,3]\n<b>输出：</b>[6,5]\n<b>解释：</b>每个点对中，与至少一个点相连的边的数目如上图所示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5, edges = [[1,5],[1,5],[3,4],[2,5],[1,3],[5,1],[2,3],[2,5]], queries = [1,2,3,4,5]\n<b>输出：</b>[10,10,9,8,6]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= edges.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= u<sub>i</sub>, v<sub>i</sub> <= n</code></li>\n\t<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>\n\t<li><code>1 <= queries.length <= 20</code></li>\n\t<li><code>0 <= queries[j] < edges.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1783.大满贯数量",
        "hardRate": "MEDIUM",
        "passRate": "80.64%",
        "problemsUrl": "https://leetcode.cn/problems/grand-slam-titles/",
        "solutionsUrl": "https://leetcode.cn/problems/grand-slam-titles/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1784.检查二进制字符串字段",
        "hardRate": "EASY",
        "passRate": "59.48%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-binary-string-has-at-most-one-segment-of-ones/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-binary-string-has-at-most-one-segment-of-ones/solution",
        "problemsDesc": "<p>给你一个二进制字符串 <code>s</code> ，该字符串 <strong>不含前导零</strong> 。</p>\n\n<p>如果 <code>s</code> 包含 <strong>零个或一个由连续的 <code>'1'</code> 组成的字段</strong> ，返回 <code>true</code>​​​ 。否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1001\"\n<strong>输出：</strong>false\n<strong>解释：</strong>由连续若干个&nbsp;<code>'1'</code> 组成的字段数量为 2，返回 false\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"110\"\n<strong>输出：</strong>true</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s[i]</code>​​​​ 为 <code>'0'</code> 或 <code>'1'</code></li>\n\t<li><code>s[0]</code> 为 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1785.构成特定和需要添加的最少元素",
        "hardRate": "MEDIUM",
        "passRate": "43.56%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-elements-to-add-to-form-a-given-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-elements-to-add-to-form-a-given-sum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，和两个整数 <code>limit</code> 与 <code>goal</code> 。数组 <code>nums</code> 有一条重要属性：<code>abs(nums[i]) <= limit</code> 。</p>\n\n<p>返回使数组元素总和等于 <code>goal</code> 所需要向数组中添加的 <strong>最少元素数量</strong> ，添加元素 <strong>不应改变</strong> 数组中 <code>abs(nums[i]) <= limit</code> 这一属性。</p>\n\n<p>注意，如果 <code>x >= 0</code> ，那么 <code>abs(x)</code> 等于 <code>x</code> ；否则，等于 <code>-x</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,-1,1], limit = 3, goal = -4\n<strong>输出：</strong>2\n<strong>解释：</strong>可以将 -2 和 -3 添加到数组中，数组的元素总和变为 1 - 1 + 1 - 2 - 3 = -4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,-10,9,1], limit = 100, goal = 0\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= limit <= 10<sup>6</sup></code></li>\n\t<li><code>-limit <= nums[i] <= limit</code></li>\n\t<li><code>-10<sup>9</sup> <= goal <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1786.从第一个节点出发到最后一个节点的受限路径数",
        "hardRate": "MEDIUM",
        "passRate": "36.45%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-restricted-paths-from-first-to-last-node/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-restricted-paths-from-first-to-last-node/solution",
        "problemsDesc": "<p>现有一个加权无向连通图。给你一个正整数 <code>n</code> ，表示图中有 <code>n</code> 个节点，并按从 <code>1</code> 到 <code>n</code> 给节点编号；另给你一个数组 <code>edges</code> ，其中每个 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, weight<sub>i</sub>]</code> 表示存在一条位于节点 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code> 之间的边，这条边的权重为 <code>weight<sub>i</sub></code> 。</p>\n\n<p>从节点 <code>start</code> 出发到节点 <code>end</code> 的路径是一个形如 <code>[z<sub>0</sub>, z<sub>1</sub>,<sub> </sub>z<sub>2</sub>, ..., z<sub>k</sub>]</code> 的节点序列，满足 <code>z<sub>0 </sub>= start</code> 、<code>z<sub>k</sub> = end</code> 且在所有符合 <code>0 <= i <= k-1</code> 的节点 <code>z<sub>i</sub></code> 和 <code>z<sub>i+1</sub></code> 之间存在一条边。</p>\n\n<p>路径的距离定义为这条路径上所有边的权重总和。用 <code>distanceToLastNode(x)</code> 表示节点 <code>n</code> 和 <code>x</code> 之间路径的最短距离。<strong>受限路径</strong> 为满足 <code>distanceToLastNode(z<sub>i</sub>) > distanceToLastNode(z<sub>i+1</sub>)</code> 的一条路径，其中 <code>0 <= i <= k-1</code> 。</p>\n\n<p>返回从节点 <code>1</code> 出发到节点 <code>n</code> 的 <strong>受限路径数</strong> 。由于数字可能很大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/07/restricted_paths_ex1.png\" style=\"width: 351px; height: 341px;\" />\n<pre>\n<strong>输入：</strong>n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]]\n<strong>输出：</strong>3\n<strong>解释：</strong>每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。三条受限路径分别是：\n1) 1 --> 2 --> 5\n2) 1 --> 2 --> 3 --> 5\n3) 1 --> 3 --> 5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/07/restricted_paths_ex22.png\" style=\"width: 356px; height: 401px;\" />\n<pre>\n<strong>输入：</strong>n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]]\n<strong>输出：</strong>1\n<strong>解释：</strong>每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。唯一一条受限路径是：1 --> 3 --> 7 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 2 * 10<sup>4</sup></code></li>\n\t<li><code>n - 1 <= edges.length <= 4 * 10<sup>4</sup></code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>1 <= u<sub>i</sub>, v<sub>i</sub> <= n</code></li>\n\t<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>\n\t<li><code>1 <= weight<sub>i</sub> <= 10<sup>5</sup></code></li>\n\t<li>任意两个节点之间至多存在一条边</li>\n\t<li>任意两个节点之间至少存在一条路径</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1787.使所有区间的异或结果为零",
        "hardRate": "HARD",
        "passRate": "64.30%",
        "problemsUrl": "https://leetcode.cn/problems/make-the-xor-of-all-segments-equal-to-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/make-the-xor-of-all-segments-equal-to-zero/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>​​​ 和一个整数 <code>k</code>​​​​​ 。区间 <code>[left, right]</code>（<code>left <= right</code>）的 <strong>异或结果</strong> 是对下标位于 <code>left</code> 和 <code>right</code>（包括 <code>left</code> 和 <code>right</code> ）之间所有元素进行 <code>XOR</code> 运算的结果：<code>nums[left] XOR nums[left+1] XOR ... XOR nums[right]</code> 。</p>\n\n<p>返回数组中 <strong>要更改的最小元素数</strong> ，以使所有长度为 <code>k</code> 的区间异或结果等于零。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,0,3,0], k = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>将数组 [<strong>1</strong>,<strong>2</strong>,0,<strong>3</strong>,0] 修改为 [<strong>0</strong>,<strong>0</strong>,0,<strong>0</strong>,0]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,5,2,1,7,3,4,7], k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>将数组 [3,4,<strong>5</strong>,<strong>2</strong>,<strong>1</strong>,7,3,4,7] 修改为 [3,4,<strong>7</strong>,<strong>3</strong>,<strong>4</strong>,7,3,4,7]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,4,1,2,5,1,2,6], k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>将数组[1,2,<strong>4,</strong>1,2,<strong>5</strong>,1,2,<strong>6</strong>] 修改为 [1,2,<strong>3</strong>,1,2,<strong>3</strong>,1,2,<strong>3</strong>]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= k <= nums.length <= 2000</code></li>\n\t<li><code>​​​​​​0 <= nums[i] < 2<sup>10</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1788.最大化花园的美观度",
        "hardRate": "HARD",
        "passRate": "65.56%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-the-beauty-of-the-garden/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-the-beauty-of-the-garden/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1789.员工的直属部门",
        "hardRate": "EASY",
        "passRate": "72.08%",
        "problemsUrl": "https://leetcode.cn/problems/primary-department-for-each-employee/",
        "solutionsUrl": "https://leetcode.cn/problems/primary-department-for-each-employee/solution",
        "problemsDesc": "<p>Table: <code>Employee</code></p>\n\n<pre>+---------------+---------+\n| Column Name   |  Type   |\n+---------------+---------+\n| employee_id   | int     |\n| department_id | int     |\n| primary_flag  | varchar |\n+---------------+---------+\n这张表的主键为 employee_id, department_id\nemployee_id 是员工的ID\ndepartment_id 是部门的ID，表示员工与该部门有关系\nprimary_flag 是一个枚举类型，值分别为('Y', 'N'). 如果值为'Y',表示该部门是员工的直属部门。 如果值是'N',则否\n</pre>\n\n<p> </p>\n\n<p>一个员工可以属于多个部门。</p>\n\n<p>当一个员工加入<strong>超过一个部门</strong>的时候，他需要决定哪个部门是他的直属部门。</p>\n\n<p>请注意，当员工只加入一个部门的时候，那这个部门将默认为他的直属部门，虽然表记录的值为<code>'N'</code>.</p>\n\n<p>请编写一段SQL，查出员工所属的直属部门。</p>\n\n<p>返回结果没有顺序要求。</p>\n\n<p> </p>\n\n<p>示例：</p>\n\n<pre>Employee table:\n+-------------+---------------+--------------+\n| employee_id | department_id | primary_flag |\n+-------------+---------------+--------------+\n| 1           | 1             | N            |\n| 2           | 1             | Y            |\n| 2           | 2             | N            |\n| 3           | 3             | N            |\n| 4           | 2             | N            |\n| 4           | 3             | Y            |\n| 4           | 4             | N            |\n+-------------+---------------+--------------+\n\nResult table:\n+-------------+---------------+\n| employee_id | department_id |\n+-------------+---------------+\n| 1           | 1             |\n| 2           | 1             |\n| 3           | 3             |\n| 4           | 3             |\n+-------------+---------------+\n- 员工1的直属部门是1\n- 员工2的直属部门是1\n- 员工3的直属部门是3\n- 员工4的直属部门是3</pre>\n\n<p> </p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1790.仅执行一次字符串交换能否使两个字符串相等",
        "hardRate": "EASY",
        "passRate": "52.52%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-one-string-swap-can-make-strings-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-one-string-swap-can-make-strings-equal/solution",
        "problemsDesc": "<p>给你长度相等的两个字符串 <code>s1</code> 和 <code>s2</code> 。一次<strong> 字符串交换 </strong>操作的步骤如下：选出某个字符串中的两个下标（不必不同），并交换这两个下标所对应的字符。</p>\n\n<p>如果对 <strong>其中一个字符串</strong> 执行 <strong>最多一次字符串交换</strong> 就可以使两个字符串相等，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"bank\", s2 = \"kanb\"\n<strong>输出：</strong>true\n<strong>解释：</strong>例如，交换 s2 中的第一个和最后一个字符可以得到 \"bank\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"attack\", s2 = \"defend\"\n<strong>输出：</strong>false\n<strong>解释：</strong>一次字符串交换无法使两个字符串相等\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"kelb\", s2 = \"kelb\"\n<strong>输出：</strong>true\n<strong>解释：</strong>两个字符串已经相等，所以不需要进行字符串交换\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"abcd\", s2 = \"dcba\"\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 100</code></li>\n\t<li><code>s1.length == s2.length</code></li>\n\t<li><code>s1</code> 和 <code>s2</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1791.找出星型图的中心节点",
        "hardRate": "EASY",
        "passRate": "83.07%",
        "problemsUrl": "https://leetcode.cn/problems/find-center-of-star-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/find-center-of-star-graph/solution",
        "problemsDesc": "<p>有一个无向的 <strong>星型</strong> 图，由 <code>n</code> 个编号从 <code>1</code> 到 <code>n</code> 的节点组成。星型图有一个 <strong>中心</strong> 节点，并且恰有 <code>n - 1</code> 条边将中心节点与其他每个节点连接起来。</p>\n\n<p>给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> 表示在节点 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code> 之间存在一条边。请你找出并返回 <code>edges</code> 所表示星型图的中心节点。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/14/star_graph.png\" style=\"width: 331px; height: 321px;\" />\n<pre>\n<strong>输入：</strong>edges = [[1,2],[2,3],[4,2]]\n<strong>输出：</strong>2\n<strong>解释：</strong>如上图所示，节点 2 与其他每个节点都相连，所以节点 2 是中心节点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>edges = [[1,2],[5,1],[1,3],[1,4]]\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 <= u<sub>i,</sub> v<sub>i</sub> <= n</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n\t<li>题目数据给出的 <code>edges</code> 表示一个有效的星型图</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1792.最大平均通过率",
        "hardRate": "MEDIUM",
        "passRate": "58.83%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-average-pass-ratio/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-average-pass-ratio/solution",
        "problemsDesc": "<p>一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 <code>classes</code> ，其中 <code>classes[i] = [pass<sub>i</sub>, total<sub>i</sub>]</code> ，表示你提前知道了第 <code>i</code> 个班级总共有 <code>total<sub>i</sub></code> 个学生，其中只有 <code>pass<sub>i</sub></code> 个学生可以通过考试。</p>\n\n<p>给你一个整数 <code>extraStudents</code> ，表示额外有 <code>extraStudents</code> 个聪明的学生，他们 <strong>一定</strong> 能通过任何班级的期末考。你需要给这 <code>extraStudents</code> 个学生每人都安排一个班级，使得 <strong>所有</strong> 班级的 <strong>平均</strong> 通过率 <strong>最大</strong> 。</p>\n\n<p>一个班级的 <strong>通过率</strong> 等于这个班级通过考试的学生人数除以这个班级的总人数。<strong>平均通过率</strong> 是所有班级的通过率之和除以班级数目。</p>\n\n<p>请你返回在安排这 <code><span style=\"\">extraStudents</span></code> 个学生去对应班级后的 <strong>最大</strong> 平均通过率。与标准答案误差范围在 <code>10<sup>-5</sup></code> 以内的结果都会视为正确结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>classes = [[1,2],[3,5],[2,2]], <code>extraStudents</code> = 2\n<b>输出：</b>0.78333\n<b>解释：</b>你可以将额外的两个学生都安排到第一个班级，平均通过率为 (3/4 + 3/5 + 2/2) / 3 = 0.78333 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>classes = [[2,4],[3,9],[4,5],[2,10]], <code>extraStudents</code> = 4\n<strong>输出：</strong>0.53485\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= classes.length <= 10<sup>5</sup></code></li>\n\t<li><code>classes[i].length == 2</code></li>\n\t<li><code>1 <= pass<sub>i</sub> <= total<sub>i</sub> <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= extraStudents <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1793.好子数组的最大分数",
        "hardRate": "HARD",
        "passRate": "45.55%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-of-a-good-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-of-a-good-subarray/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> <strong>（下标从 0 开始）</strong>和一个整数 <code>k</code> 。</p>\n\n<p>一个子数组 <code>(i, j)</code> 的 <strong>分数</strong> 定义为 <code>min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)</code> 。一个 <strong>好</strong> 子数组的两个端点下标需要满足 <code>i &lt;= k &lt;= j</code> 。</p>\n\n<p>请你返回 <strong>好</strong> 子数组的最大可能 <strong>分数</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,4,3,7,4,5], k = 3\n<b>输出：</b>15\n<b>解释：</b>最优子数组的左右端点下标是 (1, 5) ，分数为 min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [5,5,4,5,4,1,1,1], k = 0\n<b>输出：</b>20\n<b>解释：</b>最优子数组的左右端点下标是 (0, 4) ，分数为 min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= k &lt; nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1794.统计距离最小的子串对个数",
        "hardRate": "MEDIUM",
        "passRate": "55.46%",
        "problemsUrl": "https://leetcode.cn/problems/count-pairs-of-equal-substrings-with-minimum-difference/",
        "solutionsUrl": "https://leetcode.cn/problems/count-pairs-of-equal-substrings-with-minimum-difference/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1795.每个产品在不同商店的价格",
        "hardRate": "EASY",
        "passRate": "78.21%",
        "problemsUrl": "https://leetcode.cn/problems/rearrange-products-table/",
        "solutionsUrl": "https://leetcode.cn/problems/rearrange-products-table/solution",
        "problemsDesc": "<p>表：<code>Products</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| product_id  | int     |\n| store1      | int     |\n| store2      | int     |\n| store3      | int     |\n+-------------+---------+\n这张表的主键是product_id（产品Id）。\n每行存储了这一产品在不同商店store1, store2, store3的价格。\n如果这一产品在商店里没有出售，则值将为null。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>请你重构 <code>Products</code> 表，查询每个产品在不同商店的价格，使得输出的格式变为<code>(product_id, store, price)</code> 。如果这一产品在商店里没有出售，则不输出这一行。</p>\n\n<p>输出结果表中的 <strong>顺序不作要求</strong> 。</p>\n\n<p>查询输出格式请参考下面示例。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nProducts table:\n+------------+--------+--------+--------+\n| product_id | store1 | store2 | store3 |\n+------------+--------+--------+--------+\n| 0          | 95     | 100    | 105    |\n| 1          | 70     | null   | 80     |\n+------------+--------+--------+--------+\n<strong>输出：</strong>\n+------------+--------+-------+\n| product_id | store  | price |\n+------------+--------+-------+\n| 0          | store1 | 95    |\n| 0          | store2 | 100   |\n| 0          | store3 | 105   |\n| 1          | store1 | 70    |\n| 1          | store3 | 80    |\n+------------+--------+-------+\n<strong>解释：</strong>\n产品0在store1，store2,store3的价格分别为95,100,105。\n产品1在store1，store3的价格分别为70,80。在store2无法买到。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1796.字符串中第二大的数字",
        "hardRate": "EASY",
        "passRate": "54.88%",
        "problemsUrl": "https://leetcode.cn/problems/second-largest-digit-in-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/second-largest-digit-in-a-string/solution",
        "problemsDesc": "<p>给你一个混合字符串 <code>s</code> ，请你返回 <code>s</code> 中 <strong>第二大 </strong>的数字，如果不存在第二大的数字，请你返回 <code>-1</code> 。</p>\n\n<p><strong>混合字符串 </strong>由小写英文字母和数字组成。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"dfa12321afd\"\n<b>输出：</b>2\n<b>解释：</b>出现在 s 中的数字包括 [1, 2, 3] 。第二大的数字是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"abc1111\"\n<b>输出：</b>-1\n<b>解释：</b>出现在 s 中的数字只包含 [1] 。没有第二大的数字。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 500</code></li>\n\t<li><code>s</code> 只包含小写英文字母和（或）数字。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1797.设计一个验证系统",
        "hardRate": "MEDIUM",
        "passRate": "64.90%",
        "problemsUrl": "https://leetcode.cn/problems/design-authentication-manager/",
        "solutionsUrl": "https://leetcode.cn/problems/design-authentication-manager/solution",
        "problemsDesc": "<p>你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在 <code>currentTime</code> 时刻之后 <code>timeToLive</code> 秒过期。如果验证码被更新了，那么它会在 <code>currentTime</code> （可能与之前的 <code>currentTime</code> 不同）时刻延长 <code>timeToLive</code> 秒。</p>\n\n<p>请你实现 <code>AuthenticationManager</code> 类：</p>\n\n<ul>\n\t<li><code>AuthenticationManager(int timeToLive)</code> 构造 <code>AuthenticationManager</code> 并设置 <code>timeToLive</code> 参数。</li>\n\t<li><code>generate(string tokenId, int currentTime)</code> 给定 <code>tokenId</code> ，在当前时间 <code>currentTime</code> 生成一个新的验证码。</li>\n\t<li><code>renew(string tokenId, int currentTime)</code> 将给定 <code>tokenId</code> 且 <strong>未过期</strong> 的验证码在 <code>currentTime</code> 时刻更新。如果给定 <code>tokenId</code> 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。</li>\n\t<li><code>countUnexpiredTokens(int currentTime)</code> 请返回在给定 <code>currentTime</code> 时刻，<strong>未过期</strong> 的验证码数目。</li>\n</ul>\n\n<p>如果一个验证码在时刻 <code>t</code> 过期，且另一个操作恰好在时刻 <code>t</code> 发生（<code>renew</code> 或者 <code>countUnexpiredTokens</code> 操作），过期事件 <strong>优先于</strong> 其他操作。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/25/copy-of-pc68_q2.png\" style=\"width: 500px; height: 287px;\" />\n<pre>\n<strong>输入：</strong>\n[\"AuthenticationManager\", \"<code>renew</code>\", \"generate\", \"<code>countUnexpiredTokens</code>\", \"generate\", \"<code>renew</code>\", \"<code>renew</code>\", \"<code>countUnexpiredTokens</code>\"]\n[[5], [\"aaa\", 1], [\"aaa\", 2], [6], [\"bbb\", 7], [\"aaa\", 8], [\"bbb\", 10], [15]]\n<strong>输出：</strong>\n[null, null, null, 1, null, null, null, 0]\n\n<strong>解释：</strong>\nAuthenticationManager authenticationManager = new AuthenticationManager(5); // 构造 AuthenticationManager ，设置 <code>timeToLive</code> = 5 秒。\nauthenticationManager.<code>renew</code>(\"aaa\", 1); // 时刻 1 时，没有验证码的 tokenId 为 \"aaa\" ，没有验证码被更新。\nauthenticationManager.generate(\"aaa\", 2); // 时刻 2 时，生成一个 tokenId 为 \"aaa\" 的新验证码。\nauthenticationManager.<code>countUnexpiredTokens</code>(6); // 时刻 6 时，只有 tokenId 为 \"aaa\" 的验证码未过期，所以返回 1 。\nauthenticationManager.generate(\"bbb\", 7); // 时刻 7 时，生成一个 tokenId 为 \"bbb\" 的新验证码。\nauthenticationManager.<code>renew</code>(\"aaa\", 8); // tokenId 为 \"aaa\" 的验证码在时刻 7 过期，且 8 >= 7 ，所以时刻 8 的renew 操作被忽略，没有验证码被更新。\nauthenticationManager.<code>renew</code>(\"bbb\", 10); // tokenId 为 \"bbb\" 的验证码在时刻 10 没有过期，所以 renew 操作会执行，该 token 将在时刻 15 过期。\nauthenticationManager.<code>countUnexpiredTokens</code>(15); // tokenId 为 \"bbb\" 的验证码在时刻 15 过期，tokenId 为 \"aaa\" 的验证码在时刻 7 过期，所有验证码均已过期，所以返回 0 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= timeToLive <= 10<sup>8</sup></code></li>\n\t<li><code>1 <= currentTime <= 10<sup>8</sup></code></li>\n\t<li><code>1 <= tokenId.length <= 5</code></li>\n\t<li><code>tokenId</code> 只包含小写英文字母。</li>\n\t<li>所有 <code>generate</code> 函数的调用都会包含独一无二的 <code>tokenId</code> 值。</li>\n\t<li>所有函数调用中，<code>currentTime</code> 的值 <strong>严格递增</strong> 。</li>\n\t<li>所有函数的调用次数总共不超过 <code>2000</code> 次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1798.你能构造出连续值的最大数目",
        "hardRate": "MEDIUM",
        "passRate": "70.97%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-consecutive-values-you-can-make/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-consecutive-values-you-can-make/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的整数数组 <code>coins</code> ，它代表你拥有的 <code>n</code> 个硬币。第 <code>i</code> 个硬币的值为 <code>coins[i]</code> 。如果你从这些硬币中选出一部分硬币，它们的和为 <code>x</code> ，那么称，你可以 <strong>构造</strong> 出 <code>x</code> 。</p>\n\n<p>请返回从 <code>0</code> 开始（<strong>包括</strong> <code>0</code> ），你最多能 <strong>构造</strong> 出多少个连续整数。</p>\n\n<p>你可能有多个相同值的硬币。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>coins = [1,3]\n<b>输出：</b>2\n<strong>解释：</strong>你可以得到以下这些值：\n- 0：什么都不取 []\n- 1：取 [1]\n从 0 开始，你可以构造出 2 个连续整数。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>coins = [1,1,1,4]\n<b>输出：</b>8\n<strong>解释：</strong>你可以得到以下这些值：\n- 0：什么都不取 []\n- 1：取 [1]\n- 2：取 [1,1]\n- 3：取 [1,1,1]\n- 4：取 [4]\n- 5：取 [4,1]\n- 6：取 [4,1,1]\n- 7：取 [4,1,1,1]\n从 0 开始，你可以构造出 8 个连续整数。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,4,10,3,1]\n<b>输出：</b>20</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>coins.length == n</code></li>\n\t<li><code>1 <= n <= 4 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= coins[i] <= 4 * 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1799.N 次操作后的最大分数和",
        "hardRate": "HARD",
        "passRate": "65.68%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-score-after-n-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-score-after-n-operations/solution",
        "problemsDesc": "<p>给你 <code>nums</code> ，它是一个大小为 <code>2 * n</code> 的正整数数组。你必须对这个数组执行 <code>n</code> 次操作。</p>\n\n<p>在第 <code>i</code> 次操作时（操作编号从 <strong>1</strong> 开始），你需要：</p>\n\n<ul>\n\t<li>选择两个元素 <code>x</code> 和 <code>y</code> 。</li>\n\t<li>获得分数 <code>i * gcd(x, y)</code> 。</li>\n\t<li>将 <code>x</code> 和 <code>y</code> 从 <code>nums</code> 中删除。</li>\n</ul>\n\n<p>请你返回 <code>n</code> 次操作后你能获得的分数和最大为多少。</p>\n\n<p>函数 <code>gcd(x, y)</code> 是 <code>x</code> 和 <code>y</code> 的最大公约数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2]\n<b>输出：</b>1\n<b>解释：</b>最优操作是：\n(1 * gcd(1, 2)) = 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [3,4,6,8]\n<b>输出：</b>11\n<b>解释：</b>最优操作是：\n(1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4,5,6]\n<b>输出：</b>14\n<b>解释：</b>最优操作是：\n(1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 7</code></li>\n\t<li><code>nums.length == 2 * n</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1800.最大升序子数组和",
        "hardRate": "EASY",
        "passRate": "68.67%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-ascending-subarray-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-ascending-subarray-sum/solution",
        "problemsDesc": "<p>给你一个正整数组成的数组 <code>nums</code> ，返回 <code>nums</code> 中一个 <strong>升序 </strong>子数组的最大可能元素和。</p>\n\n<p>子数组是数组中的一个连续数字序列。</p>\n\n<p>已知子数组 <code>[nums<sub>l</sub>, nums<sub>l+1</sub>, ..., nums<sub>r-1</sub>, nums<sub>r</sub>]</code> ，若对所有 <code>i</code>（<code>l <= i < r</code>），<code>nums<sub>i </sub> < nums<sub>i+1</sub></code> 都成立，则称这一子数组为 <strong>升序</strong> 子数组。注意，大小为 <code>1</code> 的子数组也视作 <strong>升序</strong> 子数组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,20,30,5,10,50]\n<strong>输出：</strong>65\n<strong>解释：</strong>[5,10,50] 是元素和最大的升序子数组，最大元素和为 65 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,20,30,40,50]\n<strong>输出：</strong>150\n<strong>解释：</strong>[10,20,30,40,50] 是元素和最大的升序子数组，最大元素和为 150 。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [12,17,15,13,10,11,12]\n<strong>输出：</strong>33\n<strong>解释：</strong>[10,11,12] 是元素和最大的升序子数组，最大元素和为 33 。 \n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [100,10,1]\n<strong>输出：</strong>100\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 100</code></li>\n\t<li><code>1 <= nums[i] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    }
]