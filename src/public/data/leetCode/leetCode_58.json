[
    {
        "problemsName": " 2851.沙地治理",
        "hardRate": "HARD",
        "passRate": "28.19%",
        "problemsUrl": "https://leetcode.cn/problems/XxZZjK/",
        "solutionsUrl": "https://leetcode.cn/problems/XxZZjK/solution",
        "problemsDesc": "在力扣城的沙漠分会场展示了一种沙柳树，这种沙柳树能够将沙地转化为坚实的绿地。\n展示的区域为正三角形，这片区域可以拆分为若干个子区域，每个子区域都是边长为 `1` 的小三角形，其中第 `i` 行有 `2i - 1` 个小三角形。\n\n初始情况下，区域中的所有位置都为沙地，你需要指定一些子区域种植沙柳树成为绿地，以达到转化整片区域为绿地的最终目的，规则如下：\n- 若两个子区域共用一条边，则视为相邻；\n>如下图所示，(1,1)和(2,2)相邻，(3,2)和(3,3)相邻；(2,2)和(3,3)不相邻，因为它们没有共用边。\n- 若至少有两片绿地与同一片沙地相邻，则这片沙地也会转化为绿地\n- 转化为绿地的区域会影响其相邻的沙地\n![image.png](https://pic.leetcode-cn.com/1662692397-VlvErS-image.png)\n\n现要将一片边长为 `size` 的沙地全部转化为绿地，请找到任意一种初始指定 **最少** 数量子区域种植沙柳的方案，并返回所有初始种植沙柳树的绿地坐标。\n\n**示例 1：**\n>输入：`size = 3`\n>输出：`[[1,1],[2,1],[2,3],[3,1],[3,5]]`\n>解释：如下图所示，一种方案为：\n>指定所示的 5 个子区域为绿地。\n>相邻至少两片绿地的 (2,2)，(3,2) 和 (3,4) 演变为绿地。\n>相邻两片绿地的 (3,3) 演变为绿地。\n![image.png](https://pic.leetcode-cn.com/1662692503-ncjywh-image.png){:width=500px}\n\n\n**示例 2：**\n>输入：`size = 2`\n>输出：`[[1,1],[2,1],[2,3]]`\n>解释：如下图所示：\n>指定所示的 3 个子区域为绿地。\n>相邻三片绿地的 (2,2) 演变为绿地。\n![image.png](https://pic.leetcode-cn.com/1662692507-mgFXRj-image.png){:width=276px}\n\n\n\n**提示：**\n- `1 <= size <= 1000`",
        "isPlus": false
    },
    {
        "problemsName": " 2852.集水器",
        "hardRate": "HARD",
        "passRate": "55.91%",
        "problemsUrl": "https://leetcode.cn/problems/kskhHQ/",
        "solutionsUrl": "https://leetcode.cn/problems/kskhHQ/solution",
        "problemsDesc": "字符串数组 `shape` 描述了一个二维平面中的矩阵形式的集水器，`shape[i][j]` 表示集水器的第 `i` 行 `j` 列为：\n- `'l'`表示向左倾斜的隔板（即从左上到右下）；\n- `'r'`表示向右倾斜的隔板（即从左下到右上）；\n- `'.'` 表示此位置没有隔板\n![image.png](https://pic.leetcode-cn.com/1664424667-wMnPja-image.png){:width=200px}\n\n已知当隔板构成存储容器可以存水，每个方格代表的蓄水量为 `2`。集水器初始浸泡在水中，除内部密闭空间外，所有位置均被水填满。\n现将其从水中竖直向上取出，请返回集水器最终的蓄水量。\n\n**注意：**\n- 隔板具有良好的透气性，因此空气可以穿过隔板，但水无法穿过\n\n**示例 1：**\n> 输入：\n> `shape = [\"....rl\",\"l.lr.r\",\".l..r.\",\"..lr..\"]`\n>\n> 输出：`18`\n>\n> 解释：如下图所示，由于空气会穿过隔板，因此红框区域没有水\n![image.png](https://pic.leetcode-cn.com/1664436239-eyYxeP-image.png){:width=\"280px\"}\n\n\n**示例 2：**\n> 输入：\n> `shape = [\".rlrlrlrl\",\"ll..rl..r\",\".llrrllrr\",\"..lr..lr.\"]`\n> 输出：`18`\n>\n> 解释：如图所示。由于红框右侧未闭合，因此多余的水会从该处流走。\n![image.png](https://pic.leetcode-cn.com/1664436082-SibVMv-image.png){:width=\"400px\"}\n\n\n**示例 3：**\n> 输入：\n> `shape = [\"rlrr\",\"llrl\",\"llr.\"]`\n> 输出：`6`\n>\n> 解释：如图所示。\n![image.png](https://pic.leetcode-cn.com/1664424855-dwpUHO-image.png){:width=\"230px\"}\n\n\n\n\n**示例 4：**\n> 输入：\n> `shape = [\"...rl...\",\"..r..l..\",\".r.rl.l.\",\"r.r..l.l\",\"l.l..rl.\",\".l.lr.r.\",\"..l..r..\",\"...lr...\"]`\n>\n> 输出：`30`\n>\n> 解释：如下图所示。由于中间为内部密闭空间，无法蓄水。\n![image.png](https://pic.leetcode-cn.com/1664424894-mClEXh-image.png){:width=\"350px\"}\n\n\n**提示**：\n- `1 <= shape.length <= 50`\n- `1 <= shape[i].length <= 50`\n- `shape[i][j]` 仅为 `'l'`、`'r'` 或 `'.'`\n",
        "isPlus": false
    },
    {
        "problemsName": " 2853.补给马车",
        "hardRate": "EASY",
        "passRate": "69.19%",
        "problemsUrl": "https://leetcode.cn/problems/hqCnmP/",
        "solutionsUrl": "https://leetcode.cn/problems/hqCnmP/solution",
        "problemsDesc": "远征队即将开启未知的冒险之旅，不过在此之前，将对补给车队进行最后的检查。`supplies[i]` 表示编号为 `i` 的补给马车装载的物资数量。\n考虑到车队过长容易被野兽偷袭，他们决定将车队的长度变为原来的一半（向下取整），计划为：\n- 找出车队中 **物资之和最小** 两辆 **相邻** 马车，将它们车辆的物资整合为一辆。若存在多组物资之和相同的马车，则取编号最小的两辆马车进行整合；\n- 重复上述操作直到车队长度符合要求。\n\n请返回车队长度符合要求后，物资的分布情况。\n\n**示例 1：**\n>输入：`supplies = [7,3,6,1,8]`\n>\n>输出：`[10,15]`\n>\n>解释：\n> 第 1 次合并，符合条件的两辆马车为 6,1，合并后的车队为 [7,3,7,8]；\n> 第 2 次合并，符合条件的两辆马车为 (7,3) 和 (3,7)，取编号最小的 (7,3)，合并后的车队为 [10,7,8]；\n> 第 3 次合并，符合条件的两辆马车为 7,8，合并后的车队为 [10,15]；\n>返回 `[10,15]`\n\n**示例 2：**\n>输入：`supplies = [1,3,1,5]`\n>\n>输出：`[5,5]`\n\n**解释：**\n- `2 <= supplies.length <= 1000`\n- `1 <= supplies[i] <= 1000`",
        "isPlus": false
    },
    {
        "problemsName": " 2854.探险营地",
        "hardRate": "MEDIUM",
        "passRate": "45.76%",
        "problemsUrl": "https://leetcode.cn/problems/0Zeoeg/",
        "solutionsUrl": "https://leetcode.cn/problems/0Zeoeg/solution",
        "problemsDesc": "探险家小扣的行动轨迹，都将保存在记录仪中。`expeditions[i]` 表示小扣第 `i` 次探险记录，用一个字符串数组表示。其中的每个「营地」由大小写字母组成，通过子串 `->` 连接。\n> 例：\"Leet->code->Campsite\"，表示到访了 \"Leet\"、\"code\"、\"Campsite\" 三个营地。\n\n`expeditions[0]` 包含了初始小扣已知的所有营地；对于之后的第 `i` 次探险(即 `expeditions[i]` 且 i > 0)，如果记录中包含了之前均没出现的营地，则表示小扣 **新发现** 的营地。\n\n请你找出小扣发现新营地最多且索引最小的那次探险，并返回对应的记录索引。如果所有探险记录都没有发现新的营地，返回 `-1`\n\n**注意：**\n- 大小写不同的营地视为不同的营地；\n- 营地的名称长度均大于 `0`。\n\n**示例 1：**\n>输入：`expeditions = [\"leet->code\",\"leet->code->Campsite->Leet\",\"leet->code->leet->courier\"]`\n>\n>输出：`1`\n>\n>解释：\n>初始已知的所有营地为 \"leet\" 和 \"code\"\n>第 1 次，到访了 \"leet\"、\"code\"、\"Campsite\"、\"Leet\"，新发现营地 2 处：\"Campsite\"、\"Leet\"\n>第 2 次，到访了 \"leet\"、\"code\"、\"courier\"，新发现营地 1 处：\"courier\"\n>第 1 次探险发现的新营地数量最多，因此返回 `1`\n\n**示例 2：**\n>输入：`expeditions = [\"Alice->Dex\",\"\",\"Dex\"]`\n>\n>输出：`-1`\n>\n>解释：\n>初始已知的所有营地为 \"Alice\" 和 \"Dex\"\n>第 1 次，未到访任何营地；\n>第 2 次，到访了 \"Dex\"，未新发现营地；\n>因为两次探险均未发现新的营地，返回 `-1`\n\n**示例 3：**\n>输入：`expeditions = [\"\",\"Gryffindor->Slytherin->Gryffindor\",\"Hogwarts->Hufflepuff->Ravenclaw\"]`\n>\n>输出：`2`\n>\n>解释：\n>初始未发现任何营地；\n>第 1 次，到访 \"Gryffindor\"、\"Slytherin\" 营地，其中重复到访 \"Gryffindor\" 两次，\n>因此新发现营地为 2 处：\"Gryffindor\"、\"Slytherin\"\n>第 2 次，到访 \"Hogwarts\"、\"Hufflepuff\"、\"Ravenclaw\" 营地；\n>新发现营地 3 处：\"Hogwarts\"、\"Hufflepuff\"、\"Ravenclaw\"；\n>第 2 次探险发现的新营地数量最多，因此返回 `2`\n\n**提示：**\n- `1 <= expeditions.length <= 1000`\n- `0 <= expeditions[i].length <= 1000`\n- 探险记录中只包含大小写字母和子串\"->\"",
        "isPlus": false
    },
    {
        "problemsName": " 2855.最强祝福力场",
        "hardRate": "MEDIUM",
        "passRate": "28.96%",
        "problemsUrl": "https://leetcode.cn/problems/xepqZ5/",
        "solutionsUrl": "https://leetcode.cn/problems/xepqZ5/solution",
        "problemsDesc": "小扣在探索丛林的过程中，无意间发现了传说中“落寞的黄金之都”。而在这片建筑废墟的地带中，小扣使用探测仪监测到了存在某种带有「祝福」效果的力场。\n经过不断的勘测记录，小扣将所有力场的分布都记录了下来。`forceField[i] = [x,y,side]` 表示第 `i` 片力场将覆盖以坐标 `(x,y)` 为中心，边长为 `side` 的正方形区域。\n\n若任意一点的 **力场强度** 等于覆盖该点的力场数量，请求出在这片地带中 **力场强度** 最强处的 **力场强度**。\n\n**注意：** \n- 力场范围的边缘同样被力场覆盖。\n\n**示例 1：**\n>输入：\n>`forceField = [[0,0,1],[1,0,1]]`\n>\n>输出：`2`\n>\n>解释：如图所示，（0.5, 0) 处力场强度最强为 2， （0.5，-0.5）处力场强度同样是 2。\n![image.png](https://pic.leetcode.cn/1681805536-zGfghe-image.png){:width=400px}\n\n\n**示例 2：**\n>输入：\n>`forceField = [[4,4,6],[7,5,3],[1,6,2],[5,6,3]]`\n>\n>输出：`3`\n>\n>解释：如下图所示，\n>`forceField[0]、forceField[1]、forceField[3]` 重叠的区域力场强度最大，返回 `3`\n![image.png](https://pic.leetcode.cn/1681805437-HQkyZS-image.png){:width=500px}\n\n\n\n**提示：**\n- `1 <= forceField.length <= 100`\n- `forceField[i].length == 3`\n- `0 <= forceField[i][0], forceField[i][1] <= 10^9`\n- `1 <= forceField[i][2] <= 10^9`",
        "isPlus": false
    },
    {
        "problemsName": " 2856.传送卷轴",
        "hardRate": "HARD",
        "passRate": "36.45%",
        "problemsUrl": "https://leetcode.cn/problems/rdmXM7/",
        "solutionsUrl": "https://leetcode.cn/problems/rdmXM7/solution",
        "problemsDesc": "随着不断的深入，小扣来到了守护者之森寻找的魔法水晶。首先，他必须先通过守护者的考验。\n\n考验的区域是一个正方形的迷宫，`maze[i][j]` 表示在迷宫 `i` 行 `j` 列的地形：\n- 若为 `.` ，表示可以到达的空地；\n- 若为 `#` ，表示不可到达的墙壁；\n- 若为 `S` ，表示小扣的初始位置；\n- 若为 `T` ，表示魔法水晶的位置。\n\n小扣每次可以向 上、下、左、右 相邻的位置移动一格。而守护者拥有一份「传送魔法卷轴」，使用规则如下：\n- 魔法需要在小扣位于 **空地** 时才能释放，发动后卷轴消失；；\n- 发动后，小扣会被传送到水平或者竖直的镜像位置，且目标位置不得为墙壁(如下图所示)；\n![image.png](https://pic.leetcode.cn/1681789509-wTekFu-image.png){:width=400px}\n\n在使用卷轴后，小扣将被「附加负面效果」，因此小扣需要尽可能缩短传送后到达魔法水晶的距离。而守护者的目标是阻止小扣到达魔法水晶的位置；如果无法阻止，则尽可能 **增加** 小扣传送后到达魔法水晶的距离。\n假设小扣和守护者都按最优策略行事，返回小扣需要在 「附加负面效果」的情况下 **最少** 移动多少次才能到达魔法水晶。如果无法到达，返回 `-1`。\n\n**注意：**\n- 守护者可以不使用卷轴；\n- 传送后的镜像位置可能与原位置相同。\n\n**示例 1：**\n>输入：`maze = [\".....\",\"##S..\",\"...#.\",\"T.#..\",\"###..\"]`\n>\n>输出：`7`\n>\n>解释：如下图所示：\n>守护者释放魔法的两个最佳的位置为 [2,0] 或 [3,1]：\n>若小扣经过 [2,0]，守护者在该位置释放魔法，\n>小扣被传送至 [2,4] 处且加上负面效果，此时小扣还需要移动 7 次才能到达魔法水晶；\n>若小扣经过 [3,1]，守护者在该位置释放魔法，\n>小扣被传送至 [3,3] 处且加上负面效果，此时小扣还需要移动 9 次才能到达魔法水晶；\n>因此小扣负面效果下最少需要移动 7 次才能到达魔法水晶。\n![image.png](https://pic.leetcode.cn/1681714676-gksEMT-image.png){:width=300px}\n\n\n**示例 2：**\n>输入：`maze = [\".#..\",\"..##\",\".#S.\",\".#.T\"]`\n>\n>输出：`-1`\n>\n>解释：如下图所示。\n>若小扣向下移动至 [3,2]，守护者使其传送至 [0,2]，小扣将无法到达魔法水晶；\n>若小扣向右移动至 [2,3]，守护者使其传送至 [2,0]，小扣将无法到达魔法水晶；\n![image.png](https://pic.leetcode.cn/1681714693-LsxKAh-image.png){:width=300px}\n\n\n**示例 3：**\n>输入：`maze = [\"S###.\",\"..###\",\"#..##\",\"##..#\",\"###.T\"]`\n>\n>输出：`5`\n>\n>解释：如下图所示：\n>守护者需要小扣在空地才能释放，因此初始无法将其从 [0,0] 传送至 [0,4];\n>当小扣移动至 [2,1] 时，释放卷轴将其传送至水平方向的镜像位置 [2,1]（为原位置）\n>而后小扣需要移动 5 次到达魔法水晶\n![image.png](https://pic.leetcode.cn/1681800985-KrSdru-image.png){:width=300px}\n\n**提示：**\n- `4 <= maze.length == maze[i].length <= 200`\n- `maze[i][j]` 仅包含 `\".\"`、`\"#\"`、`\"S\"`、`\"T\"`",
        "isPlus": false
    },
    {
        "problemsName": " 2857.魔法棋盘",
        "hardRate": "HARD",
        "passRate": "37.12%",
        "problemsUrl": "https://leetcode.cn/problems/1ybDKD/",
        "solutionsUrl": "https://leetcode.cn/problems/1ybDKD/solution",
        "problemsDesc": "在大小为 `n * m` 的棋盘中，有两种不同的棋子：黑色，红色。当两颗颜色不同的棋子同时满足以下两种情况时，将会产生魔法共鸣：\n- 两颗异色棋子在同一行或者同一列\n- 两颗异色棋子之间恰好只有一颗棋子\n    > 注：异色棋子之间可以有空位\n\n由于棋盘上被施加了魔法禁制，棋盘上的部分格子变成问号。`chessboard[i][j]` 表示棋盘第 `i` 行 `j` 列的状态：\n- 若为 `.` ，表示当前格子确定为空\n- 若为 `B` ，表示当前格子确定为 黑棋\n- 若为 `R` ，表示当前格子确定为 红棋\n- 若为 `?` ，表示当前格子待定\n\n现在，探险家小扣的任务是确定所有问号位置的状态（留空/放黑棋/放红棋），使最终的棋盘上，任意两颗棋子间都 **无法** 产生共鸣。请返回可以满足上述条件的放置方案数量。\n\n**示例1：**\n> 输入：`n = 3, m = 3, chessboard = [\"..R\",\"..B\",\"?R?\"]`\n>\n> 输出：`5`\n>\n> 解释：给定的棋盘如图：\n>![image.png](https://pic.leetcode.cn/1681714583-unbRox-image.png){:height=150px}\n> 所有符合题意的最终局面如图：\n>![image.png](https://pic.leetcode.cn/1681714596-beaOHK-image.png){:height=150px}\n\n**示例2：**\n> 输入：`n = 3, m = 3, chessboard = [\"?R?\",\"B?B\",\"?R?\"]`\n>\n> 输出：`105`\n\n**提示：**\n- `n == chessboard.length`\n- `m == chessboard[i].length`\n- `1 <= n*m <= 30`\n- `chessboard` 中仅包含 `\".\"、\"B\"、\"R\"、\"?\"`",
        "isPlus": false
    },
    {
        "problemsName": " 2858.符文储备",
        "hardRate": "EASY",
        "passRate": "71.34%",
        "problemsUrl": "https://leetcode.cn/problems/W2ZX4X/",
        "solutionsUrl": "https://leetcode.cn/problems/W2ZX4X/solution",
        "problemsDesc": "远征队在出发前需要携带一些「符文」，作为后续的冒险储备。`runes[i]` 表示第 `i` 枚符文的魔力值。\n\n他们将从中选取若干符文进行携带，并对这些符文进行重新排列，以确保任意相邻的两块符文之间的魔力值相差不超过 `1`。\n\n请返回他们能够携带的符文 **最大数量**。\n\n**示例 1：**\n>输入：`runes = [1,3,5,4,1,7]`\n>\n>输出：`3`\n>\n>解释：最佳的选择方案为[3,5,4]\n>将其排列为 [3,4,5] 后，任意相邻的两块符文魔力值均不超过 `1`，携带数量为 `3`\n>其他满足条件的方案为 [1,1] 和 [7]，数量均小于 3。\n>因此返回可携带的最大数量 `3`。\n\n**示例 2：**\n>输入：`runes = [1,1,3,3,2,4]`\n>\n>输出：`6`\n>\n>解释：排列为 [1,1,2,3,3,4]，可携带所有的符文\n\n**提示：**\n- `1 <= runes.length <= 10^4`\n- `0 <= runes[i] <= 10^4`\n",
        "isPlus": false
    },
    {
        "problemsName": " 2859.城墙防线",
        "hardRate": "MEDIUM",
        "passRate": "45.49%",
        "problemsUrl": "https://leetcode.cn/problems/Nsibyl/",
        "solutionsUrl": "https://leetcode.cn/problems/Nsibyl/solution",
        "problemsDesc": "在探险营地间，小扣意外发现了一片城墙遗迹，在探索期间，却不巧遇到迁徙中的兽群向他迎面冲来。情急之下小扣吹响了他的苍蓝笛，随着笛声响起，遗迹中的城墙逐渐发生了横向膨胀。\n已知 `rampart[i] = [x,y]` 表示第 `i` 段城墙的初始所在区间。当城墙发生膨胀时，将遵循以下规则：\n- 所有的城墙会同时膨胀相等的长度；\n- 每个城墙可以向左、向右或向两个方向膨胀。\n\n小扣为了确保自身的安全，需要在所有城墙均无重叠的情况下，让城墙尽可能的膨胀。请返回城墙可以膨胀的 **最大值** 。\n\n**注意：**\n- 初始情况下，所有城墙均不重叠，且 `rampart` 中的元素升序排列；\n- 两侧的城墙可以向外无限膨胀。\n\n**示例 1：**\n>输入：`rampart = [[0,3],[4,5],[7,9]]`\n>\n>输出：`3`\n>\n>解释：如下图所示：\n>`rampart[0]` 向左侧膨胀 3 个单位；\n>`rampart[2]` 向右侧膨胀 3 个单位；\n>`rampart[1]` 向左侧膨胀 1 个单位，向右膨胀 2 个单位。\n>不存在膨胀更多的方案，返回 3。\n![image.png](https://pic.leetcode.cn/1681717918-tWywrp-image.png){:width=750px}\n\n**示例 2：**\n>输入：`rampart = [[1,2],[5,8],[11,15],[18,25]]`\n>\n>输出：`4`\n\n**提示：**\n- `3 <= rampart.length <= 10^4`\n- `rampart[i].length == 2`\n- `0 <= rampart[i][0] < rampart[i][1] <= rampart[i+1][0] <= 10^8`",
        "isPlus": false
    },
    {
        "problemsName": " 2860.提取咒文",
        "hardRate": "MEDIUM",
        "passRate": "28.02%",
        "problemsUrl": "https://leetcode.cn/problems/kjpLFZ/",
        "solutionsUrl": "https://leetcode.cn/problems/kjpLFZ/solution",
        "problemsDesc": "随着兽群逐渐远去，一座大升降机缓缓的从地下升到了远征队面前。借由这台升降机，他们将能够到达地底的永恒至森。\n在升降机的操作台上，是一个由魔法符号组成的矩阵，为了便于辨识，我们用小写字母来表示。 `matrix[i][j]` 表示矩阵第 `i` 行 `j` 列的字母。该矩阵上有一个提取装置，可以对所在位置的字母提取。\n提取装置初始位于矩阵的左上角 `[0,0]`，可以通过每次操作移动到上、下、左、右相邻的 1 格位置中。提取装置每次移动或每次提取均记为一次操作。\n\n远征队需要按照顺序，从矩阵中逐一取出字母以组成 `mantra`，才能够成功的启动升降机。请返回他们 **最少** 需要消耗的操作次数。如果无法完成提取，返回 `-1`。\n\n**注意：**\n- 提取装置可对同一位置的字母重复提取，每次提取一个\n- 提取字母时，需按词语顺序依次提取\n\n**示例 1：**\n>输入：`matrix = [\"sd\",\"ep\"], mantra = \"speed\"`\n>\n>输出：`10`\n>\n>解释：如下图所示\n![矩阵 (2).gif](https://pic.leetcode-cn.com/1646288670-OTlvAl-%E7%9F%A9%E9%98%B5%20\\(2\\).gif)\n\n**示例 2：**\n>输入：`matrix = [\"abc\",\"daf\",\"geg\"]， mantra = \"sad\"`\n>\n>输出：`-1`\n>\n>解释：矩阵中不存在 `s` ，无法提取词语\n\n**提示：**\n- `0 < matrix.length, matrix[i].length <= 100`\n- `0 < mantra.length <= 100`\n- `matrix 和 mantra` 仅由小写字母组成",
        "isPlus": false
    },
    {
        "problemsName": " 2861.生物进化录",
        "hardRate": "HARD",
        "passRate": "50.26%",
        "problemsUrl": "https://leetcode.cn/problems/qoQAMX/",
        "solutionsUrl": "https://leetcode.cn/problems/qoQAMX/solution",
        "problemsDesc": "在永恒之森中，存在着一本生物进化录，以 **一个树形结构** 记载了所有生物的演化过程。经过观察并整理了各节点间的关系，`parents[i]` 表示编号 `i` 节点的父节点编号(根节点的父节点为 `-1`)。\n\n为了探索和记录其中的演化规律，队伍中的炼金术师提出了一种方法，可以以字符串的形式将其复刻下来，规则如下：\n- 初始只有一个根节点，表示演化的起点，依次记录 `01` 字符串中的字符，\n- 如果记录 `0`，则在当前节点下添加一个子节点，并将指针指向新添加的子节点；\n- 如果记录 `1`，则将指针回退到当前节点的父节点处。\n\n现在需要应用上述的记录方法，复刻下它的演化过程。请返回能够复刻演化过程的字符串中， **字典序最小** 的 `01` 字符串。\n\n**注意：**\n- 节点指针最终可以停在任何节点上，不一定要回到根节点。\n\n**示例 1：**\n> 输入：`parents = [-1,0,0,2]`\n>\n> 输出：`\"00110\"`\n>\n>解释：树结构如下图所示，共存在 2 种记录方案：\n>第 1 种方案为：0(记录编号 1 的节点) -> 1(回退至节点 0) -> 0(记录编号 2 的节点) -> 0((记录编号 3 的节点))\n>第 2 种方案为：0(记录编号 2 的节点) -> 0(记录编号 3 的节点) -> 1(回退至节点 2) -> 1(回退至节点 0) -> 0(记录编号 1 的节点)\n>返回字典序更小的 `\"00110\"`\n![image.png](https://pic.leetcode.cn/1682319485-cRVudI-image.png){:width=120px}![进化 (3).gif](https://pic.leetcode.cn/1682412701-waHdnm-%E8%BF%9B%E5%8C%96%20\\(3\\).gif){:width=320px}\n\n\n\n**示例 2：**\n> 输入：`parents = [-1,0,0,1,2,2]`\n>\n> 输出：`\"00101100\"`\n\n**提示：**\n\n- `1 <= parents.length <= 10^4`\n- `-1 <= parents[i] < i` (即父节点编号小于子节点)",
        "isPlus": false
    },
    {
        "problemsName": " 2862.与非的谜题",
        "hardRate": "HARD",
        "passRate": "47.71%",
        "problemsUrl": "https://leetcode.cn/problems/ryfUiz/",
        "solutionsUrl": "https://leetcode.cn/problems/ryfUiz/solution",
        "problemsDesc": "在永恒之森中，封存着有关万灵之树线索的卷轴，只要探险队通过最后的考验，便可以获取前往万灵之树的线索。\n\n探险队需要从一段不断变化的谜题数组中找到最终的密码，初始的谜题为长度为 `n` 的数组 `arr`（下标从 0 开始），数组中的数字代表了 `k` 位二进制数。\n破解谜题的过程中，需要使用 `与非（NAND）` 运算方式，`operations[i] = [type,x,y]` 表示第 `i` 次进行的谜题操作信息：\n- 若 `type = 0`，表示修改操作，将谜题数组中下标 `x` 的数字变化为 `y`；\n- 若 `type = 1`，表示运算操作，将数字 `y` 进行 `x*n` 次「与非」操作，第 `i` 次与非操作为 `y = y NAND arr[i%n]`；\n    > 运算操作结果即：`y NAND arr[0%n] NAND arr[1%n] NAND arr[2%n] ... NAND arr[(x*n-1)%n]`\n\n最后，将所有运算操作的结果按顺序逐一进行 `异或（XOR）`运算，从而得到最终解开封印的密码。请返回最终解开封印的密码。\n\n**注意:**\n- 「与非」（NAND）的操作为：先进行 `与` 操作，后进行 `非` 操作。\n    > 例如：两个三位二进制数`2`和`3`，其与非结果为 `NOT ((010) AND (011)) = (101) = 5`\n\n**示例 1：**\n> 输入: \n> `k = 3`\n> `arr = [1,2]`\n> `operations = [[1,2,3],[0,0,3],[1,2,2]]`\n>\n> 输出: `2`\n>\n> 解释：\n> 初始的谜题数组为 [1,2]，二进制位数为 3，\n> 第 0 次进行运算操作，将数字 3(011) 进行 2\\*2 次「与非」运算，\n> 运算操作结果为 `3 NAND 1 NAND 2 NAND 1 NAND 2 = 5`\n> 第 1 次进行修改操作，谜题数组的第 `0` 个数字变化为 `3`，谜题变成 `[3,2]`\n> 第 2 次进行运算操作，将数字 2(010) 进行 2\\*2 次「与非」运算，\n> 运算操作结果为 `2 NAND 3 NAND 2 NAND 3 NAND 2 = 7`\n> 所有运算操作结果进行「异或」运算为 `5 XOR 7 = 2`\n> 因此得到的最终密码为 `2`。\n\n**示例 2：**\n> 输入:\n> `k = 4`\n> `arr = [4,6,4,7,10,9,11]`\n> `operations = [[1,5,7],[1,7,14],[0,6,7],[1,6,5]]`\n> 输出: `9`\n> 解释: \n> 初始的谜题数组为 [4,6,4,7,10,9,11],\n> 第 0 次进行运算操作，运算操作结果为 5；\n> 第 1 次进行运算操作，运算操作结果为 5；\n> 第 2 次进行修改操作，修改后谜题数组为 [4, 6, 4, 7, 10, 9, 7]；\n> 第 3 次进行运算操作，运算操作结果为 9；\n> 所有运算操作结果进行「异或」运算为 `5 XOR 5 XOR 9 = 9`；\n> 因此得到的最终密码为 `9`。\n\n**提示:**\n- `1 <= arr.length, operations.length <= 10^4`\n- `1 <= k <= 30`\n- `0 <= arr[i] < 2^k`\n- 若 `type = 0`，`0 <= x < arr.length` 且 `0 <= y < 2^k`\n- 若 `type = 1`，`1 <= x < 10^9` 且 `0 <= y < 2^k`\n- 保证存在 `type = 1` 的操作\n",
        "isPlus": false
    },
    {
        "problemsName": " 2863.万灵之树",
        "hardRate": "HARD",
        "passRate": "13.89%",
        "problemsUrl": "https://leetcode.cn/problems/cnHoX6/",
        "solutionsUrl": "https://leetcode.cn/problems/cnHoX6/solution",
        "problemsDesc": "探险家小扣终于来到了万灵之树前，挑战最后的谜题。\n已知小扣拥有足够数量的链接节点和 `n` 颗幻境宝石，`gem[i]` 表示第 `i` 颗宝石的数值。现在小扣需要使用这些链接节点和宝石组合成一颗二叉树，其组装规则为：\n- 链接节点将作为二叉树中的非叶子节点，且每个链接节点必须拥有 `2` 个子节点；\n- 幻境宝石将作为二叉树中的叶子节点，所有的幻境宝石都必须被使用。\n\n能量首先进入根节点，而后将按如下规则进行移动和记录：\n- 若能量首次到达该节点时：\n    - 记录数字 `1`；\n    - 若该节点为叶节点，将额外记录该叶节点的数值；\n- 若存在未到达的子节点，则选取未到达的一个子节点（优先选取左子节点）进入；\n- 若无子节点或所有子节点均到达过，此时记录 `9`，并回到当前节点的父节点（若存在）。\n\n如果最终记下的数依序连接成一个整数 `num`，满足 $num \\mod~p=target$，则视为解开谜题。\n请问有多少种二叉树的组装方案，可以使得最终记录下的数字可以解开谜题\n\n**注意：**\n- 两棵结构不同的二叉树，作为不同的组装方案\n- 两棵结构相同的二叉树且存在某个相同位置处的宝石编号不同，也作为不同的组装方案\n- 可能存在数值相同的两颗宝石\n\n**示例 1：**\n> 输入：`gem = [2,3]`\n> `p = 100000007`\n> `target = 11391299`\n>\n> 输出：`1`\n>\n> 解释：\n> 包含 `2` 个叶节点的结构只有一种。\n> 假设 B、C 节点的值分别为 3、2，对应 target 为 11391299，如下图所示。\n> 11391299 % 100000007 = 11391299，满足条件;\n> 假设 B、C 节点的值分别为 2、3，对应 target 为 11291399;\n> 11291399 % 100000007 = 11291399，不满足条件；\n> 因此只存在 1 种方案，返回 1\n![万灵 (1).gif](https://pic.leetcode.cn/1682397079-evMssw-%E4%B8%87%E7%81%B5%20\\(1\\).gif){:height=300px}\n\n\n**示例 2：**\n> 输入：`gem = [3,21,3]`\n> `p = 7`\n> `target = 5`\n>\n> 输出：`4`\n>\n> 解释：\n包含 `3` 个叶节点树结构有两种，列举如下：\n满足条件的组合有四种情况：\n> 当结构为下图（1）时：叶子节点的值为 [3,3,21] 或 [3,3,21]，得到的整数为 `11139139912199`。\n> 当结构为下图（2）时：叶子节点的值为 [21,3,3] 或 [21,3,3]，得到的整数为 `11219113913999`。\n![image.png](https://pic.leetcode.cn/1682322894-vfqJIV-image.png){:width=500px}\n\n\n**提示：**\n- `1 <= gem.length <= 9`\n- `0 <= gem[i] <= 10^9`\n- `1 <= p <= 10^9`，保证 $p$ 为素数。\n- `0 <= target < p`\n- 存在 2 组 `gem.length == 9` 的用例",
        "isPlus": false
    },
    {
        "problemsName": " 2864.下载插件",
        "hardRate": "EASY",
        "passRate": "53.82%",
        "problemsUrl": "https://leetcode.cn/problems/Ju9Xwi/",
        "solutionsUrl": "https://leetcode.cn/problems/Ju9Xwi/solution",
        "problemsDesc": "小扣打算给自己的 **VS code** 安装使用插件，初始状态下带宽每分钟可以完成 `1` 个插件的下载。假定每分钟选择以下两种策略之一:\r\n- 使用当前带宽下载插件\r\n- 将带宽加倍（下载插件数量随之加倍）\r\n\r\n请返回小扣完成下载 `n` 个插件最少需要多少分钟。\r\n\r\n注意：实际的下载的插件数量可以超过 `n` 个\r\n\r\n\r\n**示例 1：**\r\n>输入：`n = 2`\r\n>\r\n>输出：`2`\r\n>\r\n>解释：\r\n> 以下两个方案，都能实现 2 分钟内下载 2 个插件\r\n>- 方案一：第一分钟带宽加倍，带宽可每分钟下载 2 个插件；第二分钟下载 2 个插件\r\n>- 方案二：第一分钟下载 1 个插件，第二分钟下载 1 个插件\r\n\r\n**示例 2：**\r\n>输入：`n = 4`\r\n>\r\n>输出：`3`\r\n>\r\n>解释：\r\n> 最少需要 3 分钟可完成 4 个插件的下载，以下是其中一种方案:\r\n> 第一分钟带宽加倍，带宽可每分钟下载 2 个插件;\r\n> 第二分钟下载 2 个插件;\r\n> 第三分钟下载 2 个插件。\r\n\r\n\r\n\r\n**提示：**\r\n- `1 <= n <= 10^5`\r\n",
        "isPlus": false
    },
    {
        "problemsName": " 2865.完成一半题目",
        "hardRate": "EASY",
        "passRate": "64.42%",
        "problemsUrl": "https://leetcode.cn/problems/WqXACV/",
        "solutionsUrl": "https://leetcode.cn/problems/WqXACV/solution",
        "problemsDesc": "有 `N` 位扣友参加了微软与力扣举办了「以扣会友」线下活动。主办方提供了 `2*N` 道题目，整型数组 `questions` 中每个数字对应了每道题目所涉及的知识点类型。\r\n若每位扣友选择不同的一题，请返回被选的 `N` 道题目至少包含多少种知识点类型。\r\n\r\n\r\n**示例 1：**\r\n>输入：`questions = [2,1,6,2]`\r\n>\r\n>输出：`1`\r\n>\r\n>解释：有 2 位扣友在 4 道题目中选择 2 题。\r\n> 可选择完成知识点类型为 2 的题目时，此时仅一种知识点类型\r\n> 因此至少包含 1 种知识点类型。\r\n\r\n**示例 2：**\r\n>输入：`questions = [1,5,1,3,4,5,2,5,3,3,8,6]`\r\n>\r\n>输出：`2`\r\n>\r\n>解释：有 6 位扣友在 12 道题目中选择题目，需要选择 6 题。\r\n> 选择完成知识点类型为 3、5 的题目，因此至少包含 2 种知识点类型。\r\n\r\n\r\n\r\n**提示：**\r\n- `questions.length == 2*n`\r\n- `2 <= questions.length <= 10^5`\r\n- `1 <= questions[i] <= 1000`",
        "isPlus": false
    },
    {
        "problemsName": " 2866.主题空间",
        "hardRate": "MEDIUM",
        "passRate": "41.35%",
        "problemsUrl": "https://leetcode.cn/problems/YesdPw/",
        "solutionsUrl": "https://leetcode.cn/problems/YesdPw/solution",
        "problemsDesc": "「以扣会友」线下活动所在场地由若干主题空间与走廊组成，场地的地图记作由一维字符串型数组 `grid`，字符串中仅包含 `\"0\"～\"5\"` 这 6 个字符。地图上每一个字符代表面积为 1 的区域，其中 `\"0\"` 表示走廊，其他字符表示主题空间。相同且连续（连续指上、下、左、右四个方向连接）的字符组成同一个主题空间。\n\n假如整个 `grid` 区域的外侧均为走廊。请问，不与走廊直接相邻的主题空间的最大面积是多少？如果不存在这样的空间请返回 `0`。\n\n**示例 1:**\n>输入：`grid = [\"110\",\"231\",\"221\"]`\n>\n>输出：`1`\n>\n>解释：4 个主题空间中，只有 1 个不与走廊相邻，面积为 1。\n>![image.png](https://pic.leetcode-cn.com/1613708145-rscctN-image.png)\n\n\n**示例 2:**\n>输入：`grid = [\"11111100000\",\"21243101111\",\"21224101221\",\"11111101111\"]`\n>\n>输出：`3`\n>\n>解释：8 个主题空间中，有 5 个不与走廊相邻，面积分别为 3、1、1、1、2，最大面积为 3。\n>![image.png](https://pic.leetcode-cn.com/1613707985-KJyiXJ-image.png)\n\n\n**提示：**\n- `1 <= grid.length <= 500`\n- `1 <= grid[i].length <= 500`\n- `grid[i][j]` 仅可能是 `\"0\"～\"5\"`\n\n",
        "isPlus": false
    },
    {
        "problemsName": " 2867.数组中重复的数字",
        "hardRate": "EASY",
        "passRate": "67.03%",
        "problemsUrl": "https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution",
        "problemsDesc": "<p>找出数组中重复的数字。</p>\n\n<p><br>\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>\n[2, 3, 1, 0, 2, 5, 3]\n<strong>输出：</strong>2 或 3 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>2 &lt;= n &lt;= 100000</code></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2868.二维数组中的查找",
        "hardRate": "MEDIUM",
        "passRate": "39.53%",
        "problemsUrl": "https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution",
        "problemsDesc": "<p>在一个 n * m 的二维数组中，每一行都按照从左到右&nbsp;<strong>非递减&nbsp;</strong>的顺序排序，每一列都按照从上到下&nbsp;<strong>非递减&nbsp;</strong>的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例:</strong></p>\n\n<p>现有矩阵 matrix 如下：</p>\n\n<pre>\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n</pre>\n\n<p>给定 target&nbsp;=&nbsp;<code>5</code>，返回&nbsp;<code>true</code>。</p>\n\n<p>给定&nbsp;target&nbsp;=&nbsp;<code>20</code>，返回&nbsp;<code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 &lt;= n &lt;= 1000</code></p>\n\n<p><code>0 &lt;= m &lt;= 1000</code></p>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与主站 240 题相同：<a href=\"https://leetcode-cn.com/problems/search-a-2d-matrix-ii/\">https://leetcode-cn.com/problems/search-a-2d-matrix-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2869.替换空格",
        "hardRate": "EASY",
        "passRate": "75.10%",
        "problemsUrl": "https://leetcode.cn/problems/ti-huan-kong-ge-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/ti-huan-kong-ge-lcof/solution",
        "problemsDesc": "<p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成&quot;%20&quot;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;We are happy.&quot;\n<strong>输出：</strong>&quot;We%20are%20happy.&quot;</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 &lt;= s 的长度 &lt;= 10000</code></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2870.从尾到头打印链表",
        "hardRate": "EASY",
        "passRate": "74.39%",
        "problemsUrl": "https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/solution",
        "problemsDesc": "<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>head = [1,3,2]\n<strong>输出：</strong>[2,3,1]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 &lt;= 链表长度 &lt;= 10000</code></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2871.重建二叉树",
        "hardRate": "MEDIUM",
        "passRate": "70.25%",
        "problemsUrl": "https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/solution",
        "problemsDesc": "<p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p>\n\n<p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree.jpg\" />\n<pre>\n<strong>Input:</strong> preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n<strong>Output:</strong> [3,9,20,null,null,15,7]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> preorder = [-1], inorder = [-1]\n<strong>Output:</strong> [-1]\n</pre>\n\n<p> </p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 <= 节点个数 <= 5000</code></p>\n\n<p> </p>\n\n<p><strong>注意</strong>：本题与主站 105 题重复：<a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2872.用两个栈实现队列",
        "hardRate": "EASY",
        "passRate": "70.33%",
        "problemsUrl": "https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution",
        "problemsDesc": "<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code>&nbsp;操作返回 -1 )</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\",\"deleteHead\"]\n[[],[3],[],[],[]]\n<strong>输出：</strong>[null,null,3,-1,-1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"CQueue\",\"deleteHead\",\"appendTail\",\"appendTail\",\"deleteHead\",\"deleteHead\"]\n[[],[],[5],[2],[],[]]\n<strong>输出：</strong>[null,-1,null,null,5,2]\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= values &lt;= 10000</code></li>\n\t<li>最多会对<code>&nbsp;appendTail、deleteHead </code>进行<code>&nbsp;10000</code>&nbsp;次调用</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2873.斐波那契数列",
        "hardRate": "EASY",
        "passRate": "35.92%",
        "problemsUrl": "https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/solution",
        "problemsDesc": "<p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p>\n\n<pre>\nF(0) = 0,   F(1) = 1\nF(N) = F(N - 1) + F(N - 2), 其中 N > 1.</pre>\n\n<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>\n\n<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>5\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= n <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2874.青蛙跳台阶问题",
        "hardRate": "EASY",
        "passRate": "45.72%",
        "problemsUrl": "https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/solution",
        "problemsDesc": "<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code>&nbsp;级的台阶总共有多少种跳法。</p>\n\n<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 7\n<strong>输出：</strong>21\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 0\n<strong>输出：</strong>1</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 100</code></li>\n</ul>\n\n<p>注意：本题与主站 70 题相同：<a href=\"https://leetcode-cn.com/problems/climbing-stairs/\">https://leetcode-cn.com/problems/climbing-stairs/</a></p>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2875.旋转数组的最小数字",
        "hardRate": "EASY",
        "passRate": "49.47%",
        "problemsUrl": "https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution",
        "problemsDesc": "<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p>\n\n<p>给你一个可能存在&nbsp;<strong>重复</strong>&nbsp;元素值的数组&nbsp;<code>numbers</code>&nbsp;，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的<strong>最小元素</strong>。例如，数组&nbsp;<code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一次旋转，该数组的最小值为 1。&nbsp;&nbsp;</p>\n\n<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 旋转一次 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong><code>numbers = </code>[3,4,5,1,2]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong><code>numbers = </code>[2,2,2,0,1]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == numbers.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>-5000 &lt;= numbers[i] &lt;= 5000</code></li>\n\t<li><code>numbers</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li>\n</ul>\n\n<p>注意：本题与主站 154 题相同：<a href=\"https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/\">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2876.矩阵中的路径",
        "hardRate": "MEDIUM",
        "passRate": "45.67%",
        "problemsUrl": "https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/solution",
        "problemsDesc": "<p>给定一个&nbsp;<code>m x n</code> 二维字符网格&nbsp;<code>board</code> 和一个字符串单词&nbsp;<code>word</code> 。如果&nbsp;<code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>\n\n<p>&nbsp;</p>\n\n<p>例如，在下面的 3×4 的矩阵中包含单词 \"ABCCED\"（单词中的字母已标出）。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word2.jpg\" style=\"width: 322px; height: 242px;\" /></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = [[\"a\",\"b\"],[\"c\",\"d\"]], word = \"abcd\"\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n = board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 6</code></li>\n\t<li><code>1 &lt;= word.length &lt;= 15</code></li>\n\t<li><code>board </code>和<code> word </code>仅由大小写英文字母组成</li>\n</ul>\n\n<p><strong>注意：</strong>本题与主站 79 题相同：<a href=\"https://leetcode-cn.com/problems/word-search/\">https://leetcode-cn.com/problems/word-search/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2877.机器人的运动范围",
        "hardRate": "MEDIUM",
        "passRate": "53.64%",
        "problemsUrl": "https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution",
        "problemsDesc": "<p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0] </code>的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>m = 2, n = 3, k = 1\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>m = 3, n = 1, k = 0\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n,m &lt;= 100</code></li>\n\t<li><code>0 &lt;= k&nbsp;&lt;= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2878.剪绳子",
        "hardRate": "MEDIUM",
        "passRate": "57.44%",
        "problemsUrl": "https://leetcode.cn/problems/jian-sheng-zi-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/jian-sheng-zi-lcof/solution",
        "problemsDesc": "<p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m-1]</code> 。请问 <code>k[0]*k[1]*...*k[m-1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入: </strong>2\n<strong>输出: </strong>1\n<strong>解释: </strong>2 = 1 + 1, 1 &times; 1 = 1</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入: </strong>10\n<strong>输出: </strong>36\n<strong>解释: </strong>10 = 3 + 3 + 4, 3 &times;&nbsp;3 &times;&nbsp;4 = 36</pre>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 58</code></li>\n</ul>\n\n<p>注意：本题与主站 343 题相同：<a href=\"https://leetcode-cn.com/problems/integer-break/\">https://leetcode-cn.com/problems/integer-break/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2879.剪绳子 II",
        "hardRate": "MEDIUM",
        "passRate": "31.41%",
        "problemsUrl": "https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/solution",
        "problemsDesc": "<p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code>&nbsp;段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m - 1]</code> 。请问 <code>k[0]*k[1]*...*k[m - 1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>\n\n<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入: </strong>2\n<strong>输出: </strong>1\n<strong>解释: </strong>2 = 1 + 1, 1 &times; 1 = 1</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入: </strong>10\n<strong>输出: </strong>36\n<strong>解释: </strong>10 = 3 + 3 + 4, 3 &times;&nbsp;3 &times;&nbsp;4 = 36</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n</ul>\n\n<p>注意：本题与主站 343 题相同：<a href=\"https://leetcode-cn.com/problems/integer-break/\">https://leetcode-cn.com/problems/integer-break/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2880.二进制中1的个数",
        "hardRate": "EASY",
        "passRate": "75.71%",
        "problemsUrl": "https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/solution",
        "problemsDesc": "<p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 <a href=\"http://en.wikipedia.org/wiki/Hamming_weight\" target=\"_blank\">汉明重量</a>).）。</p>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>\n\t<li>在 Java 中，编译器使用 <a href=\"https://baike.baidu.com/item/二进制补码/5295284\">二进制补码</a> 记法来表示有符号整数。因此，在上面的 <strong>示例 3 </strong>中，输入表示有符号整数 <code>-3</code>。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 11 (控制台输入 00000000000000000000000000001011)\n<strong>输出：</strong>3\n<strong>解释：</strong>输入的二进制串 <code><strong>00000000000000000000000000001011</strong> 中，共有三位为 '1'。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 128 (控制台输入 00000000000000000000000010000000)\n<strong>输出：</strong>1\n<strong>解释：</strong>输入的二进制串 <strong>00000000000000000000000010000000</strong> 中，共有一位为 '1'。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）\n<strong>输出：</strong>31\n<strong>解释：</strong>输入的二进制串 <strong>11111111111111111111111111111101</strong> 中，共有 31 位为 '1'。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</li>\n</ul>\n\n<p> </p>\n\n<p>注意：本题与主站 191 题相同：<a href=\"https://leetcode-cn.com/problems/number-of-1-bits/\">https://leetcode-cn.com/problems/number-of-1-bits/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2881.数值的整数次方",
        "hardRate": "MEDIUM",
        "passRate": "34.84%",
        "problemsUrl": "https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution",
        "problemsDesc": "<p>实现&nbsp;<a href=\"https://www.cplusplus.com/reference/valarray/pow/\">pow(<em>x</em>,&nbsp;<em>n</em>)</a>&nbsp;，即计算 x 的 n 次幂函数（即，x<sup>n</sup>）。不得使用库函数，同时不需要考虑大数问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 2.00000, n = 10\n<strong>输出：</strong>1024.00000\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 2.10000, n = 3\n<strong>输出：</strong>9.26100</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 2.00000, n = -2\n<strong>输出：</strong>0.25000\n<strong>解释：</strong>2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-100.0 &lt; x &lt; 100.0</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup>-1</code></li>\n\t<li><code>n</code>&nbsp;是一个整数</li>\n\t<li>要么 <code>x</code> 不为零，要么 <code>n &gt; 0</code> 。</li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sup>n</sup> &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 50 题相同：<a href=\"https://leetcode-cn.com/problems/powx-n/\">https://leetcode-cn.com/problems/powx-n/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2882.打印从1到最大的n位数",
        "hardRate": "EASY",
        "passRate": "77.68%",
        "problemsUrl": "https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solution",
        "problemsDesc": "<p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> n = 1\n<strong>输出:</strong> [1,2,3,4,5,6,7,8,9]\n</pre>\n\n<p>&nbsp;</p>\n\n<p>说明：</p>\n\n<ul>\n\t<li>用返回一个整数列表来代替打印</li>\n\t<li>n 为正整数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2883.删除链表的节点",
        "hardRate": "EASY",
        "passRate": "59.91%",
        "problemsUrl": "https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/solution",
        "problemsDesc": "<p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>\n\n<p>返回删除后的链表的头节点。</p>\n\n<p><strong>注意：</strong>此题对比原题有改动</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> head = [4,5,1,9], val = 5\n<strong>输出:</strong> [4,1,9]\n<strong>解释: </strong>给定你链表中值为&nbsp;5&nbsp;的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> head = [4,5,1,9], val = 1\n<strong>输出:</strong> [4,5,9]\n<strong>解释: </strong>给定你链表中值为&nbsp;1&nbsp;的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>题目保证链表中节点的值互不相同</li>\n\t<li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2884.正则表达式匹配",
        "hardRate": "HARD",
        "passRate": "38.46%",
        "problemsUrl": "https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution",
        "problemsDesc": "<p>请实现一个函数用来匹配包含<code>&#39;. &#39;</code>和<code>&#39;*&#39;</code>的正则表达式。模式中的字符<code>&#39;.&#39;</code>表示任意一个字符，而<code>&#39;*&#39;</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>&quot;aaa&quot;</code>与模式<code>&quot;a.a&quot;</code>和<code>&quot;ab*ac*a&quot;</code>匹配，但与<code>&quot;aa.a&quot;</code>和<code>&quot;ab*a&quot;</code>均不匹配。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong>\ns = &quot;aa&quot;\np = &quot;a&quot;\n<strong>输出:</strong> false\n<strong>解释:</strong> &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong>\ns = &quot;aa&quot;\np = &quot;a*&quot;\n<strong>输出:</strong> true\n<strong>解释:</strong>&nbsp;因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。\n</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre><strong>输入:</strong>\ns = &quot;ab&quot;\np = &quot;.*&quot;\n<strong>输出:</strong> true\n<strong>解释:</strong>&nbsp;&quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。\n</pre>\n\n<p><strong>示例 4:</strong></p>\n\n<pre><strong>输入:</strong>\ns = &quot;aab&quot;\np = &quot;c*a*b&quot;\n<strong>输出:</strong> true\n<strong>解释:</strong>&nbsp;因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。\n</pre>\n\n<p><strong>示例 5:</strong></p>\n\n<pre><strong>输入:</strong>\ns = &quot;mississippi&quot;\np = &quot;mis*is*p*.&quot;\n<strong>输出:</strong> false</pre>\n\n<ul>\n\t<li><code>s</code>&nbsp;可能为空，且只包含从&nbsp;<code>a-z</code>&nbsp;的小写字母。</li>\n\t<li><code>p</code>&nbsp;可能为空，且只包含从&nbsp;<code>a-z</code>&nbsp;的小写字母以及字符&nbsp;<code>.</code>&nbsp;和&nbsp;<code>*</code>，无连续的 <code>&#39;*&#39;</code>。</li>\n</ul>\n\n<p>注意：本题与主站 10&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/regular-expression-matching/\">https://leetcode-cn.com/problems/regular-expression-matching/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2885.表示数值的字符串",
        "hardRate": "MEDIUM",
        "passRate": "25.05%",
        "problemsUrl": "https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution",
        "problemsDesc": "<p>请实现一个函数用来判断字符串是否表示<strong>数值</strong>（包括整数和小数）。</p>\n\n<p><strong>数值</strong>（按顺序）可以分成以下几个部分：</p>\n\n<ol>\n\t<li>若干空格</li>\n\t<li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li>\n\t<li>（可选）一个 <code>'e'</code> 或 <code>'E'</code> ，后面跟着一个 <strong>整数</strong></li>\n\t<li>若干空格</li>\n</ol>\n\n<p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p>\n\n<ol>\n\t<li>（可选）一个符号字符（<code>'+'</code> 或 <code>'-'</code>）</li>\n\t<li>下述格式之一：\n\t<ol>\n\t\t<li>至少一位数字，后面跟着一个点 <code>'.'</code></li>\n\t\t<li>至少一位数字，后面跟着一个点 <code>'.'</code> ，后面再跟着至少一位数字</li>\n\t\t<li>一个点 <code>'.'</code> ，后面跟着至少一位数字</li>\n\t</ol>\n\t</li>\n</ol>\n\n<p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p>\n\n<ol>\n\t<li>（可选）一个符号字符（<code>'+'</code> 或 <code>'-'</code>）</li>\n\t<li>至少一位数字</li>\n</ol>\n\n<p>部分<strong>数值</strong>列举如下：</p>\n\n<ul>\n\t<li><code>[\"+100\", \"5e2\", \"-123\", \"3.1416\", \"-1E-16\", \"0123\"]</code></li>\n</ul>\n\n<p>部分<strong>非数值</strong>列举如下：</p>\n\n<ul>\n\t<li><code>[\"12e\", \"1a3.14\", \"1.2.3\", \"+-5\", \"12e+5.4\"]</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"e\"\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \".\"\n<strong>输出：</strong>false</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"    .1  \"\n<strong>输出：</strong>true\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 20</code></li>\n\t<li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>'+'</code> ，减号 <code>'-'</code> ，空格 <code>' '</code> 或者点 <code>'.'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2886.调整数组顺序使奇数位于偶数前面",
        "hardRate": "EASY",
        "passRate": "65.03%",
        "problemsUrl": "https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/solution",
        "problemsDesc": "<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums =&nbsp;[1,2,3,4]\n<strong>输出：</strong>[1,3,2,4] \n<strong>注：</strong>[3,1,2,4] 也是正确的答案之一。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>0 &lt;= nums.length &lt;= 50000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10000</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2887.链表中倒数第k个节点",
        "hardRate": "EASY",
        "passRate": "80.13%",
        "problemsUrl": "https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/solution",
        "problemsDesc": "<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>\n\n<p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点。</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n给定一个链表: <strong>1->2->3->4->5</strong>, 和 <em>k </em><strong>= 2</strong>.\n\n返回链表 4<strong>->5</strong>.</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2888.反转链表",
        "hardRate": "EASY",
        "passRate": "74.20%",
        "problemsUrl": "https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/solution",
        "problemsDesc": "<p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL\n<strong>输出:</strong> 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 &lt;= 节点个数 &lt;= 5000</code></p>\n\n<p>&nbsp;</p>\n\n<p><strong>注意</strong>：本题与主站 206 题相同：<a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\">https://leetcode-cn.com/problems/reverse-linked-list/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2889.合并两个排序的链表",
        "hardRate": "EASY",
        "passRate": "72.17%",
        "problemsUrl": "https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/solution",
        "problemsDesc": "<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>\n\n<p><strong>示例1：</strong></p>\n\n<pre><strong>输入：</strong>1-&gt;2-&gt;4, 1-&gt;3-&gt;4\n<strong>输出：</strong>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</pre>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 &lt;= 链表长度 &lt;= 1000</code></p>\n\n<p>注意：本题与主站 21 题相同：<a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/\">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2890.树的子结构",
        "hardRate": "MEDIUM",
        "passRate": "46.40%",
        "problemsUrl": "https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solution",
        "problemsDesc": "<p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>\n\n<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>\n\n<p>例如:<br>\n给定的树 A:</p>\n\n<p><code>&nbsp; &nbsp; &nbsp;3<br>\n&nbsp; &nbsp; / \\<br>\n&nbsp; &nbsp;4 &nbsp; 5<br>\n&nbsp; / \\<br>\n&nbsp;1 &nbsp; 2</code><br>\n给定的树 B：</p>\n\n<p><code>&nbsp; &nbsp;4&nbsp;<br>\n&nbsp; /<br>\n&nbsp;1</code><br>\n返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>A = [1,2,3], B = [3,1]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>A = [3,4,5,1,2], B = [4,1]\n<strong>输出：</strong>true</pre>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 &lt;= 节点个数 &lt;= 10000</code></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2891.二叉树的镜像",
        "hardRate": "EASY",
        "passRate": "79.64%",
        "problemsUrl": "https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/solution",
        "problemsDesc": "<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>\n\n<p>例如输入：</p>\n\n<p><code>&nbsp; &nbsp; &nbsp;4<br>\n&nbsp; &nbsp;/ &nbsp; \\<br>\n&nbsp; 2 &nbsp; &nbsp; 7<br>\n&nbsp;/ \\ &nbsp; / \\<br>\n1 &nbsp; 3 6 &nbsp; 9</code><br>\n镜像输出：</p>\n\n<p><code>&nbsp; &nbsp; &nbsp;4<br>\n&nbsp; &nbsp;/ &nbsp; \\<br>\n&nbsp; 7 &nbsp; &nbsp; 2<br>\n&nbsp;/ \\ &nbsp; / \\<br>\n9 &nbsp; 6 3&nbsp; &nbsp;1</code></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>root = [4,2,7,1,3,6,9]\n<strong>输出：</strong>[4,7,2,9,6,3,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 &lt;= 节点个数 &lt;= 1000</code></p>\n\n<p>注意：本题与主站 226 题相同：<a href=\"https://leetcode-cn.com/problems/invert-binary-tree/\">https://leetcode-cn.com/problems/invert-binary-tree/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2892.对称的二叉树",
        "hardRate": "EASY",
        "passRate": "57.63%",
        "problemsUrl": "https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/solution",
        "problemsDesc": "<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>\n\n<p>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p>\n\n<p><code>&nbsp; &nbsp; 1<br>\n&nbsp; &nbsp;/ \\<br>\n&nbsp; 2 &nbsp; 2<br>\n&nbsp;/ \\ / \\<br>\n3 &nbsp;4 4 &nbsp;3</code><br>\n但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p>\n\n<p><code>&nbsp; &nbsp; 1<br>\n&nbsp; &nbsp;/ \\<br>\n&nbsp; 2 &nbsp; 2<br>\n&nbsp; &nbsp;\\ &nbsp; \\<br>\n&nbsp; &nbsp;3 &nbsp; &nbsp;3</code></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>root = [1,2,2,3,4,4,3]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>root = [1,2,2,null,3,null,3]\n<strong>输出：</strong>false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<p><code>0 &lt;= 节点个数 &lt;= 1000</code></p>\n\n<p>注意：本题与主站 101 题相同：<a href=\"https://leetcode-cn.com/problems/symmetric-tree/\">https://leetcode-cn.com/problems/symmetric-tree/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2893.顺时针打印矩阵",
        "hardRate": "EASY",
        "passRate": "43.02%",
        "problemsUrl": "https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution",
        "problemsDesc": "<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>[1,2,3,6,9,8,7,4,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>matrix =&nbsp;[[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n<strong>输出：</strong>[1,2,3,4,8,12,11,10,9,5,6,7]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>限制：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= matrix.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= matrix[i].length&nbsp;&lt;= 100</code></li>\n</ul>\n\n<p>注意：本题与主站 54 题相同：<a href=\"https://leetcode-cn.com/problems/spiral-matrix/\">https://leetcode-cn.com/problems/spiral-matrix/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2894.包含min函数的栈",
        "hardRate": "EASY",
        "passRate": "55.33%",
        "problemsUrl": "https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/solution",
        "problemsDesc": "<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>MinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.min();   --&gt; 返回 -3.\nminStack.pop();\nminStack.top();      --&gt; 返回 0.\nminStack.min();   --&gt; 返回 -2.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>各函数的调用总次数不超过 20000 次</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 155 题相同：<a href=\"https://leetcode-cn.com/problems/min-stack/\">https://leetcode-cn.com/problems/min-stack/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2895.栈的压入、弹出序列",
        "hardRate": "MEDIUM",
        "passRate": "61.06%",
        "problemsUrl": "https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/solution",
        "problemsDesc": "<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\n<strong>输出：</strong>true\n<strong>解释：</strong>我们可以按以下顺序执行：\npush(1), push(2), push(3), push(4), pop() -&gt; 4,\npush(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\n<strong>输出：</strong>false\n<strong>解释：</strong>1 不能在 2 之前弹出。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>0 &lt;= pushed.length == popped.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= pushed[i], popped[i] &lt; 1000</code></li>\n\t<li><code>pushed</code>&nbsp;是&nbsp;<code>popped</code>&nbsp;的排列。</li>\n</ol>\n\n<p>注意：本题与主站 946 题相同：<a href=\"https://leetcode-cn.com/problems/validate-stack-sequences/\">https://leetcode-cn.com/problems/validate-stack-sequences/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2896.从上到下打印二叉树",
        "hardRate": "MEDIUM",
        "passRate": "63.12%",
        "problemsUrl": "https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/solution",
        "problemsDesc": "<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>\n\n<p>&nbsp;</p>\n\n<p>例如:<br>\n给定二叉树:&nbsp;<code>[3,9,20,null,null,15,7]</code>,</p>\n\n<pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</pre>\n\n<p>返回：</p>\n\n<pre>[3,9,20,15,7]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>节点总数 &lt;= 1000</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2897.从上到下打印二叉树 II",
        "hardRate": "EASY",
        "passRate": "68.86%",
        "problemsUrl": "https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/solution",
        "problemsDesc": "<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>\n\n<p>&nbsp;</p>\n\n<p>例如:<br>\n给定二叉树:&nbsp;<code>[3,9,20,null,null,15,7]</code>,</p>\n\n<pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</pre>\n\n<p>返回其层次遍历结果：</p>\n\n<pre>[\n  [3],\n  [9,20],\n  [15,7]\n]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>节点总数 &lt;= 1000</code></li>\n</ol>\n\n<p>注意：本题与主站 102 题相同：<a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal/\">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2898.从上到下打印二叉树 III",
        "hardRate": "MEDIUM",
        "passRate": "58.18%",
        "problemsUrl": "https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/solution",
        "problemsDesc": "<p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>\n\n<p>&nbsp;</p>\n\n<p>例如:<br>\n给定二叉树:&nbsp;<code>[3,9,20,null,null,15,7]</code>,</p>\n\n<pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</pre>\n\n<p>返回其层次遍历结果：</p>\n\n<pre>[\n  [3],\n  [20,9],\n  [15,7]\n]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>节点总数 &lt;= 1000</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2899.二叉搜索树的后序遍历序列",
        "hardRate": "MEDIUM",
        "passRate": "56.89%",
        "problemsUrl": "https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution",
        "problemsDesc": "<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回&nbsp;<code>true</code>，否则返回&nbsp;<code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>\n\n<p>&nbsp;</p>\n\n<p>参考以下这颗二叉搜索树：</p>\n\n<pre>     5\n    / \\\n   2   6\n  / \\\n 1   3</pre>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入: </strong>[1,6,3,2,5]\n<strong>输出: </strong>false</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入: </strong>[1,3,2,6,5]\n<strong>输出: </strong>true</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>数组长度 &lt;= 1000</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2900.二叉树中和为某一值的路径",
        "hardRate": "MEDIUM",
        "passRate": "59.04%",
        "problemsUrl": "https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/",
        "solutionsUrl": "https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/solution",
        "problemsDesc": "<p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>\n\n<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n<strong>输出：</strong>[[5,4,11,2],[5,8,4,5]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3], targetSum = 5\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2], targetSum = 0\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点总数在范围 <code>[0, 5000]</code> 内</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>\n</ul>\n\n<p>注意：本题与主站 113&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/path-sum-ii/\">https://leetcode-cn.com/problems/path-sum-ii/</a></p>\n",
        "isPlus": false
    }
]