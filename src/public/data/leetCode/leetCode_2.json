[
    {
        "problemsName": " 501二叉搜索树中的众数",
        "hardRate": "EASY",
        "passRate": "54.66%",
        "problemsUrl": "https://leetcode.cn/problems/find-mode-in-binary-search-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/find-mode-in-binary-search-tree/solution",
        "problemsDesc": "<p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code> ，找出并返回 BST 中的所有 <a href=\"https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796\" target=\"_blank\">众数</a>（即，出现频率最高的元素）。</p>\n\n<p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p>\n\n<p>假定 BST 满足如下定义：</p>\n\n<ul>\n\t<li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li>\n\t<li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li>\n\t<li>左子树和右子树都是二叉搜索树</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg\" style=\"width: 142px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>root = [1,null,2,2]\n<strong>输出：</strong>[2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [0]\n<strong>输出：</strong>[0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 502IPO",
        "hardRate": "HARD",
        "passRate": "44.86%",
        "problemsUrl": "https://leetcode.cn/problems/ipo/",
        "solutionsUrl": "https://leetcode.cn/problems/ipo/solution",
        "problemsDesc": "<p>假设 力扣（LeetCode）即将开始 <strong>IPO</strong> 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 <code>k</code> 个不同的项目。帮助 力扣 设计完成最多 <code>k</code> 个不同项目后得到最大总资本的方式。</p>\n\n<p>给你 <code>n</code> 个项目。对于每个项目 <code>i</code><strong> </strong>，它都有一个纯利润 <code>profits[i]</code> ，和启动该项目需要的最小资本 <code>capital[i]</code> 。</p>\n\n<p>最初，你的资本为 <code>w</code> 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。</p>\n\n<p>总而言之，从给定项目中选择 <strong>最多</strong> <code>k</code> 个不同项目的列表，以 <strong>最大化最终资本</strong> ，并输出最终可获得的最多资本。</p>\n\n<p>答案保证在 32 位有符号整数范围内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\n<strong>输出：</strong>4\n<strong>解释：\n</strong>由于你的初始资本为 0，你仅可以从 0 号项目开始。\n在完成后，你将获得 1 的利润，你的总资本将变为 1。\n此时你可以选择开始 1 号或 2 号项目。\n由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。\n因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]\n<strong>输出：</strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= w &lt;= 10<sup>9</sup></code></li>\n\t<li><code>n == profits.length</code></li>\n\t<li><code>n == capital.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= profits[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= capital[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 503下一个更大元素 II",
        "hardRate": "MEDIUM",
        "passRate": "66.85%",
        "problemsUrl": "https://leetcode.cn/problems/next-greater-element-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/next-greater-element-ii/solution",
        "problemsDesc": "<p>给定一个循环数组&nbsp;<code>nums</code>&nbsp;（&nbsp;<code>nums[nums.length - 1]</code>&nbsp;的下一个元素是&nbsp;<code>nums[0]</code>&nbsp;），返回&nbsp;<em><code>nums</code>&nbsp;中每个元素的 <strong>下一个更大元素</strong></em> 。</p>\n\n<p>数字 <code>x</code>&nbsp;的 <strong>下一个更大的元素</strong> 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,1]\n<strong>输出:</strong> [2,-1,2]\n<strong>解释:</strong> 第一个 1 的下一个更大的数是 2；\n数字 2 找不到下一个更大的数； \n第二个 1 的下一个最大的数需要循环搜索，结果也是 2。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,3,4,3]\n<strong>输出:</strong> [2,3,4,-1,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 504七进制数",
        "hardRate": "EASY",
        "passRate": "51.76%",
        "problemsUrl": "https://leetcode.cn/problems/base-7/",
        "solutionsUrl": "https://leetcode.cn/problems/base-7/solution",
        "problemsDesc": "<p>给定一个整数 <code>num</code>，将其转化为 <strong>7 进制</strong>，并以字符串形式输出。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> num = 100\n<strong>输出:</strong> \"202\"\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> num = -7\n<strong>输出:</strong> \"-10\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-10<sup>7</sup>&nbsp;&lt;= num &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 505迷宫 II",
        "hardRate": "MEDIUM",
        "passRate": "51.56%",
        "problemsUrl": "https://leetcode.cn/problems/the-maze-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/the-maze-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 506相对名次",
        "hardRate": "EASY",
        "passRate": "65.05%",
        "problemsUrl": "https://leetcode.cn/problems/relative-ranks/",
        "solutionsUrl": "https://leetcode.cn/problems/relative-ranks/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的整数数组 <code>score</code> ，其中 <code>score[i]</code> 是第 <code>i</code> 位运动员在比赛中的得分。所有得分都 <strong>互不相同</strong> 。</p>\n\n<p>运动员将根据得分 <strong>决定名次</strong> ，其中名次第 <code>1</code> 的运动员得分最高，名次第 <code>2</code> 的运动员得分第 <code>2</code> 高，依此类推。运动员的名次决定了他们的获奖情况：</p>\n\n<ul>\n\t<li>名次第 <code>1</code> 的运动员获金牌 <code>\"Gold Medal\"</code> 。</li>\n\t<li>名次第 <code>2</code> 的运动员获银牌 <code>\"Silver Medal\"</code> 。</li>\n\t<li>名次第 <code>3</code> 的运动员获铜牌 <code>\"Bronze Medal\"</code> 。</li>\n\t<li>从名次第 <code>4</code> 到第 <code>n</code> 的运动员，只能获得他们的名次编号（即，名次第 <code>x</code> 的运动员获得编号 <code>\"x\"</code>）。</li>\n</ul>\n\n<p>使用长度为 <code>n</code> 的数组 <code>answer</code> 返回获奖，其中 <code>answer[i]</code> 是第 <code>i</code> 位运动员的获奖情况。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>score = [5,4,3,2,1]\n<strong>输出：</strong>[\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\n<strong>解释：</strong>名次为 [1<sup>st</sup>, 2<sup>nd</sup>, 3<sup>rd</sup>, 4<sup>th</sup>, 5<sup>th</sup>] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>score = [10,3,8,9,4]\n<strong>输出：</strong>[\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\n<strong>解释：</strong>名次为 [1<sup>st</sup>, 5<sup>th</sup>, 3<sup>rd</sup>, 2<sup>nd</sup>, 4<sup>th</sup>] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == score.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= score[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>score</code> 中的所有值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 507完美数",
        "hardRate": "EASY",
        "passRate": "49.12%",
        "problemsUrl": "https://leetcode.cn/problems/perfect-number/",
        "solutionsUrl": "https://leetcode.cn/problems/perfect-number/solution",
        "problemsDesc": "<p>对于一个&nbsp;<strong>正整数</strong>，如果它和除了它自身以外的所有 <strong>正因子</strong> 之和相等，我们称它为 <strong>「完美数」</strong>。</p>\n\n<p>给定一个&nbsp;<strong>整数&nbsp;</strong><code>n</code>，&nbsp;如果是完美数，返回 <code>true</code>；否则返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 28\n<strong>输出：</strong>true\n<strong>解释：</strong>28 = 1 + 2 + 4 + 7 + 14\n1, 2, 4, 7, 和 14 是 28 的所有正因子。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 7\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 508出现次数最多的子树元素和",
        "hardRate": "MEDIUM",
        "passRate": "75.51%",
        "problemsUrl": "https://leetcode.cn/problems/most-frequent-subtree-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/most-frequent-subtree-sum/solution",
        "problemsDesc": "<p>给你一个二叉树的根结点&nbsp;<code>root</code>&nbsp;，请返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。</p>\n\n<p>一个结点的&nbsp;<strong>「子树元素和」</strong>&nbsp;定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/24/freq1-tree.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> root = [5,2,-3]\n<strong>输出:</strong> [2,-3,4]\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/24/freq2-tree.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> root = [5,2,-5]\n<b>输出:</b> [2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>节点数在&nbsp;<code>[1, 10<sup>4</sup>]</code>&nbsp;范围内</li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 509斐波那契数",
        "hardRate": "EASY",
        "passRate": "66.17%",
        "problemsUrl": "https://leetcode.cn/problems/fibonacci-number/",
        "solutionsUrl": "https://leetcode.cn/problems/fibonacci-number/solution",
        "problemsDesc": "<p><strong>斐波那契数</strong>&nbsp;（通常用&nbsp;<code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由&nbsp;<code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>\n\n<pre>\nF(0) = 0，F(1)&nbsp;= 1\nF(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1\n</pre>\n\n<p>给定&nbsp;<code>n</code> ，请计算 <code>F(n)</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>F(2) = F(1) + F(0) = 1 + 0 = 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>F(3) = F(2) + F(1) = 1 + 1 = 2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>F(4) = F(3) + F(2) = 2 + 1 = 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 30</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 510二叉搜索树中的中序后继 II",
        "hardRate": "MEDIUM",
        "passRate": "60.39%",
        "problemsUrl": "https://leetcode.cn/problems/inorder-successor-in-bst-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/inorder-successor-in-bst-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 511游戏玩法分析 I",
        "hardRate": "EASY",
        "passRate": "70.69%",
        "problemsUrl": "https://leetcode.cn/problems/game-play-analysis-i/",
        "solutionsUrl": "https://leetcode.cn/problems/game-play-analysis-i/solution",
        "problemsDesc": "<p>活动表&nbsp;<code>Activity</code>：</p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| player_id    | int     |\n| device_id    | int     |\n| event_date   | date    |\n| games_played | int     |\n+--------------+---------+\n表的主键是 (player_id, event_date)。\n这张表展示了一些游戏玩家在游戏平台上的行为活动。\n每行数据记录了一名玩家在退出平台之前，当天使用同一台设备登录平台后打开的游戏的数目（可能是 0 个）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一条 SQL&nbsp;查询语句获取每位玩家 <strong>第一次登陆平台的日期</strong>。</p>\n\n<p>查询结果的格式如下所示：</p>\n\n<pre>\nActivity 表：\n+-----------+-----------+------------+--------------+\n| player_id | device_id | event_date | games_played |\n+-----------+-----------+------------+--------------+\n| 1         | 2         | 2016-03-01 | 5            |\n| 1         | 2         | 2016-05-02 | 6            |\n| 2         | 3         | 2017-06-25 | 1            |\n| 3         | 1         | 2016-03-02 | 0            |\n| 3         | 4         | 2018-07-03 | 5            |\n+-----------+-----------+------------+--------------+\n\nResult 表：\n+-----------+-------------+\n| player_id | first_login |\n+-----------+-------------+\n| 1         | 2016-03-01  |\n| 2         | 2017-06-25  |\n| 3         | 2016-03-02  |\n+-----------+-------------+\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 512游戏玩法分析 II",
        "hardRate": "EASY",
        "passRate": "54.21%",
        "problemsUrl": "https://leetcode.cn/problems/game-play-analysis-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/game-play-analysis-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 513找树左下角的值",
        "hardRate": "MEDIUM",
        "passRate": "73.52%",
        "problemsUrl": "https://leetcode.cn/problems/find-bottom-left-tree-value/",
        "solutionsUrl": "https://leetcode.cn/problems/find-bottom-left-tree-value/solution",
        "problemsDesc": "<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边 </strong>节点的值。</p>\n\n<p>假设二叉树中至少有一个节点。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg\" style=\"width: 182px; \" /></p>\n\n<pre>\n<strong>输入: </strong>root = [2,1,3]\n<strong>输出: </strong>1\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg\" style=\"width: 242px; \" /><strong> </strong></p>\n\n<pre>\n<strong>输入: </strong>[1,2,3,4,null,5,6,null,null,7]\n<strong>输出: </strong>7\n</pre>\n\n<p> </p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[1,10<sup>4</sup>]</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>-2<sup>31</sup> <= Node.val <= 2<sup>31</sup> - 1</code> </li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 514自由之路",
        "hardRate": "HARD",
        "passRate": "51.48%",
        "problemsUrl": "https://leetcode.cn/problems/freedom-trail/",
        "solutionsUrl": "https://leetcode.cn/problems/freedom-trail/solution",
        "problemsDesc": "<p>电子游戏“辐射4”中，任务 <strong>“通向自由”</strong> 要求玩家到达名为 “<strong>Freedom Trail Ring”</strong> 的金属表盘，并使用表盘拼写特定关键词才能开门。</p>\n\n<p>给定一个字符串&nbsp;<code>ring</code>&nbsp;，表示刻在外环上的编码；给定另一个字符串&nbsp;<code>key</code>&nbsp;，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的<strong>最少</strong>步数。</p>\n\n<p>最初，<strong>ring&nbsp;</strong>的第一个字符与 <code>12:00</code> 方向对齐。您需要顺时针或逆时针旋转 <code>ring</code> 以使&nbsp;<strong>key&nbsp;</strong>的一个字符在 <code>12:00</code> 方向对齐，然后按下中心按钮，以此逐个拼写完&nbsp;<strong><code>key</code>&nbsp;</strong>中的所有字符。</p>\n\n<p>旋转&nbsp;<code>ring</code><strong>&nbsp;</strong>拼出 key 字符&nbsp;<code>key[i]</code><strong>&nbsp;</strong>的阶段中：</p>\n\n<ol>\n\t<li>您可以将&nbsp;<strong>ring&nbsp;</strong>顺时针或逆时针旋转&nbsp;<strong>一个位置&nbsp;</strong>，计为1步。旋转的最终目的是将字符串&nbsp;<strong><code>ring</code>&nbsp;</strong>的一个字符与 <code>12:00</code> 方向对齐，并且这个字符必须等于字符&nbsp;<strong><code>key[i]</code> 。</strong></li>\n\t<li>如果字符&nbsp;<strong><code>key[i]</code>&nbsp;</strong>已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作&nbsp;<strong>1 步</strong>。按完之后，您可以开始拼写&nbsp;<strong>key&nbsp;</strong>的下一个字符（下一阶段）, 直至完成所有拼写。</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/22/ring.jpg\" style=\"height: 450px; width: 450px;\" /></p>\n\n<center>&nbsp;</center>\n\n<pre>\n<strong>输入:</strong> ring = \"godding\", key = \"gd\"\n<strong>输出:</strong> 4\n<strong>解释:</strong>\n 对于 key 的第一个字符 'g'，已经在正确的位置, 我们只需要1步来拼写这个字符。 \n 对于 key 的第二个字符 'd'，我们需要逆时针旋转 ring \"godding\" 2步使它变成 \"ddinggo\"。\n 当然, 我们还需要1步进行拼写。\n 因此最终的输出是 4。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> ring = \"godding\", key = \"godding\"\n<strong>输出:</strong> 13\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= ring.length, key.length &lt;= 100</code></li>\n\t<li><code>ring</code>&nbsp;和&nbsp;<code>key</code>&nbsp;只包含小写英文字母</li>\n\t<li><strong>保证</strong> 字符串&nbsp;<code>key</code>&nbsp;一定可以由字符串 &nbsp;<code>ring</code>&nbsp;旋转拼出</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 515在每个树行中找最大值",
        "hardRate": "MEDIUM",
        "passRate": "66.42%",
        "problemsUrl": "https://leetcode.cn/problems/find-largest-value-in-each-tree-row/",
        "solutionsUrl": "https://leetcode.cn/problems/find-largest-value-in-each-tree-row/solution",
        "problemsDesc": "<p>给定一棵二叉树的根节点&nbsp;<code>root</code> ，请找出该二叉树中每一层的最大值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/21/largest_e1.jpg\" style=\"height: 172px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入: </strong>root = [1,3,2,5,3,null,9]\n<strong>输出: </strong>[1,3,9]\n</pre>\n\n<p><strong>示例2：</strong></p>\n\n<pre>\n<strong>输入: </strong>root = [1,2,3]\n<strong>输出: </strong>[1,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[0,10<sup>4</sup>]</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>-2<sup>31</sup>&nbsp;&lt;= Node.val &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 516最长回文子序列",
        "hardRate": "MEDIUM",
        "passRate": "67.16%",
        "problemsUrl": "https://leetcode.cn/problems/longest-palindromic-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-palindromic-subsequence/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p>\n\n<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"bbbab\"\n<strong>输出：</strong>4\n<strong>解释：</strong>一个可能的最长回文子序列为 \"bbbb\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"cbbd\"\n<strong>输出：</strong>2\n<strong>解释：</strong>一个可能的最长回文子序列为 \"bb\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 1000</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 517超级洗衣机",
        "hardRate": "HARD",
        "passRate": "51.10%",
        "problemsUrl": "https://leetcode.cn/problems/super-washing-machines/",
        "solutionsUrl": "https://leetcode.cn/problems/super-washing-machines/solution",
        "problemsDesc": "<p>假设有 <code>n</code><strong>&nbsp;</strong>台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。</p>\n\n<p>在每一步操作中，你可以选择任意 <code>m</code> (<code>1 &lt;= m &lt;= n</code>) 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。</p>\n\n<p>给定一个整数数组&nbsp;<code>machines</code> 代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的 <strong>最少的操作步数 </strong>。如果不能使每台洗衣机中衣物的数量相等，则返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>machines = [1,0,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n第一步:    1     0 &lt;-- 5    =&gt;    1     1     4\n第二步:    1 &lt;-- 1 &lt;-- 4    =&gt;    2     1     3    \n第三步:    2     1 &lt;-- 3    =&gt;    2     2     2   \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>machines = [0,3,0]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n第一步:    0 &lt;-- 3     0    =&gt;    1     2     0    \n第二步:    1     2 --&gt; 0    =&gt;    1     1     1     \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>machines = [0,2,0]\n<strong>输出：</strong>-1\n<strong>解释：</strong>\n不可能让所有三个洗衣机同时剩下相同数量的衣物。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == machines.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= machines[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 518零钱兑换 II",
        "hardRate": "MEDIUM",
        "passRate": "70.53%",
        "problemsUrl": "https://leetcode.cn/problems/coin-change-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/coin-change-ii/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p>\n\n<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p>\n\n<p>假设每一种面额的硬币有无限个。 </p>\n\n<p>题目数据保证结果符合 32 位带符号整数。</p>\n\n<p> </p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>amount = 5, coins = [1, 2, 5]\n<strong>输出：</strong>4\n<strong>解释：</strong>有四种方式可以凑成总金额：\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>amount = 3, coins = [2]\n<strong>输出：</strong>0\n<strong>解释：</strong>只用面额 2 的硬币不能凑成总金额 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>amount = 10, coins = [10] \n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= coins.length <= 300</code></li>\n\t<li><code>1 <= coins[i] <= 5000</code></li>\n\t<li><code>coins</code> 中的所有值 <strong>互不相同</strong></li>\n\t<li><code>0 <= amount <= 5000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 519随机翻转矩阵",
        "hardRate": "MEDIUM",
        "passRate": "46.25%",
        "problemsUrl": "https://leetcode.cn/problems/random-flip-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/random-flip-matrix/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的二元矩阵 <code>matrix</code> ，且所有值被初始化为 <code>0</code> 。请你设计一个算法，随机选取一个满足&nbsp;<code>matrix[i][j] == 0</code> 的下标&nbsp;<code>(i, j)</code> ，并将它的值变为 <code>1</code> 。所有满足 <code>matrix[i][j] == 0</code> 的下标 <code>(i, j)</code> 被选取的概率应当均等。</p>\n\n<p>尽量最少调用内置的随机函数，并且优化时间和空间复杂度。</p>\n\n<p>实现 <code>Solution</code> 类：</p>\n\n<ul>\n\t<li><code>Solution(int m, int n)</code> 使用二元矩阵的大小 <code>m</code> 和 <code>n</code> 初始化该对象</li>\n\t<li><code>int[] flip()</code> 返回一个满足&nbsp;<code>matrix[i][j] == 0</code> 的随机下标 <code>[i, j]</code> ，并将其对应格子中的值变为 <code>1</code></li>\n\t<li><code>void reset()</code> 将矩阵中所有的值重置为 <code>0</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"]\n[[3, 1], [], [], [], [], []]\n<strong>输出</strong>\n[null, [1, 0], [2, 0], [0, 0], null, [2, 0]]\n\n<strong>解释</strong>\nSolution solution = new Solution(3, 1);\nsolution.flip();  // 返回 [1, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同\nsolution.flip();  // 返回 [2, 0]，因为 [1,0] 已经返回过了，此时返回 [2,0] 和 [0,0] 的概率应当相同\nsolution.flip();  // 返回 [0, 0]，根据前面已经返回过的下标，此时只能返回 [0,0]\nsolution.reset(); // 所有值都重置为 0 ，并可以再次选择下标返回\nsolution.flip();  // 返回 [2, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>4</sup></code></li>\n\t<li>每次调用<code>flip</code> 时，矩阵中至少存在一个值为 0 的格子。</li>\n\t<li>最多调用 <code>1000</code> 次 <code>flip</code> 和 <code>reset</code> 方法。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 520检测大写字母",
        "hardRate": "EASY",
        "passRate": "56.77%",
        "problemsUrl": "https://leetcode.cn/problems/detect-capital/",
        "solutionsUrl": "https://leetcode.cn/problems/detect-capital/solution",
        "problemsDesc": "<p>我们定义，在以下情况时，单词的大写用法是正确的：</p>\n\n<ul>\n\t<li>全部字母都是大写，比如 <code>\"USA\"</code> 。</li>\n\t<li>单词中所有字母都不是大写，比如 <code>\"leetcode\"</code> 。</li>\n\t<li>如果单词不只含有一个字母，只有首字母大写，&nbsp;比如&nbsp;<code>\"Google\"</code> 。</li>\n</ul>\n\n<p>给你一个字符串 <code>word</code> 。如果大写用法正确，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"USA\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"FlaG\"\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 100</code></li>\n\t<li><code>word</code> 由小写和大写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 521最长特殊序列 Ⅰ",
        "hardRate": "EASY",
        "passRate": "73.66%",
        "problemsUrl": "https://leetcode.cn/problems/longest-uncommon-subsequence-i/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-uncommon-subsequence-i/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>a</code>&nbsp;和&nbsp;<code>b</code>，请返回 <em>这两个字符串中 <strong>最长的特殊序列</strong>&nbsp;</em> 的长度。如果不存在，则返回 <code>-1</code>&nbsp;。</p>\n\n<p><strong>「最长特殊序列」</strong>&nbsp;定义如下：该序列为&nbsp;<strong>某字符串独有的最长子序列（即不能是其他字符串的子序列）</strong>&nbsp;。</p>\n\n<p>字符串&nbsp;<code>s</code>&nbsp;的子序列是在从&nbsp;<code>s</code>&nbsp;中删除任意数量的字符后可以获得的字符串。</p>\n\n<ul>\n\t<li>例如，<code>\"abc\"</code> 是 <code>\"aebdc\"</code> 的子序列，因为删除 <code>\"a<em><strong>e</strong></em>b<strong><em>d</em></strong>c\"</code> 中斜体加粗的字符可以得到 <code>\"abc\"</code> 。 <code>\"aebdc\"</code> 的子序列还包括 <code>\"aebdc\"</code> 、 <code>\"aeb\"</code> 和 <code>\"\"</code> (空字符串)。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> a = \"aba\", b = \"cdc\"\n<strong>输出:</strong> 3\n<strong>解释:</strong> 最长特殊序列可为 \"aba\" (或 \"cdc\")，两者均为自身的子序列且不是对方的子序列。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = \"aaa\", b = \"bbb\"\n<strong>输出：</strong>3\n<strong>解释:</strong> 最长特殊序列是 \"aaa\" 和 \"bbb\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = \"aaa\", b = \"aaa\"\n<strong>输出：</strong>-1\n<strong>解释:</strong> 字符串 a 的每个子序列也是字符串 b 的每个子序列。同样，字符串 b 的每个子序列也是字符串 a 的子序列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 100</code></li>\n\t<li><code>a</code>&nbsp;和&nbsp;<code>b</code>&nbsp;由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 522最长特殊序列 II",
        "hardRate": "MEDIUM",
        "passRate": "48.81%",
        "problemsUrl": "https://leetcode.cn/problems/longest-uncommon-subsequence-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-uncommon-subsequence-ii/solution",
        "problemsDesc": "<p>给定字符串列表&nbsp;<code>strs</code> ，返回其中 <strong>最长的特殊序列</strong>&nbsp;的长度。如果最长特殊序列不存在，返回 <code>-1</code> 。</p>\n\n<p><strong>特殊序列</strong> 定义如下：该序列为某字符串 <strong>独有的子序列（即不能是其他字符串的子序列）</strong>。</p>\n\n<p>&nbsp;<code>s</code>&nbsp;的&nbsp;<strong>子序列</strong>可以通过删去字符串&nbsp;<code>s</code>&nbsp;中的某些字符实现。</p>\n\n<ul>\n\t<li>例如，<code>\"abc\"</code>&nbsp;是 <code>\"aebdc\"</code>&nbsp;的子序列，因为您可以删除<code>\"a<u>e</u>b<u>d</u>c\"</code>中的下划线字符来得到 <code>\"abc\"</code>&nbsp;。<code>\"aebdc\"</code>的子序列还包括<code>\"aebdc\"</code>、 <code>\"aeb\"</code>&nbsp;和 <font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size: 12.6px; background-color: rgb(249, 242, 244);\">\"\"</span></font>&nbsp;(空字符串)。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> strs = [\"aba\",\"cdc\",\"eae\"]\n<strong>输出:</strong> 3\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> strs = [\"aaa\",\"aaa\",\"aa\"]\n<strong>输出:</strong> -1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= strs.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= strs[i].length &lt;= 10</code></li>\n\t<li><code>strs[i]</code>&nbsp;只包含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 523连续的子数组和",
        "hardRate": "MEDIUM",
        "passRate": "28.52%",
        "problemsUrl": "https://leetcode.cn/problems/continuous-subarray-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/continuous-subarray-sum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：</p>\n\n<ul>\n\t<li>子数组大小 <strong>至少为 2</strong> ，且</li>\n\t<li>子数组元素总和为 <code>k</code> 的倍数。</li>\n</ul>\n\n<p>如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>如果存在一个整数 <code>n</code> ，令整数 <code>x</code> 符合 <code>x = n * k</code> ，则称 <code>x</code> 是 <code>k</code> 的一个倍数。<code>0</code> 始终视为 <code>k</code> 的一个倍数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [23<u>,2,4</u>,6,7], k = 6\n<strong>输出：</strong>true\n<strong>解释：</strong>[2,4] 是一个大小为 2 的子数组，并且和为 6 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<u>23,2,6,4,7</u>], k = 6\n<strong>输出：</strong>true\n<strong>解释：</strong>[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 \n42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [23,2,6,4,7], k = 13\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= nums[i] <= 10<sup>9</sup></code></li>\n\t<li><code>0 <= sum(nums[i]) <= 2<sup>31</sup> - 1</code></li>\n\t<li><code>1 <= k <= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 524通过删除字母匹配到字典里最长单词",
        "hardRate": "MEDIUM",
        "passRate": "50.04%",
        "problemsUrl": "https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和一个字符串数组 <code>dictionary</code> ，找出并返回&nbsp;<code>dictionary</code> 中最长的字符串，该字符串可以通过删除 <code>s</code> 中的某些字符得到。</p>\n\n<p>如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abpcplea\", dictionary = [\"ale\",\"apple\",\"monkey\",\"plea\"]\n<strong>输出：</strong>\"apple\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abpcplea\", dictionary = [\"a\",\"b\",\"c\"]\n<strong>输出：</strong>\"a\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= dictionary.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= dictionary[i].length &lt;= 1000</code></li>\n\t<li><code>s</code> 和 <code>dictionary[i]</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 525连续数组",
        "hardRate": "MEDIUM",
        "passRate": "54.67%",
        "problemsUrl": "https://leetcode.cn/problems/contiguous-array/",
        "solutionsUrl": "https://leetcode.cn/problems/contiguous-array/solution",
        "problemsDesc": "<p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [0,1]\n<strong>输出:</strong> 2\n<strong>说明:</strong> [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [0,1,0]\n<strong>输出:</strong> 2\n<strong>说明:</strong> [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 526优美的排列",
        "hardRate": "MEDIUM",
        "passRate": "73.24%",
        "problemsUrl": "https://leetcode.cn/problems/beautiful-arrangement/",
        "solutionsUrl": "https://leetcode.cn/problems/beautiful-arrangement/solution",
        "problemsDesc": "<p>假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 <code>perm</code>（<strong>下标从 1 开始</strong>），只要满足下述条件 <strong>之一</strong> ，该数组就是一个 <strong>优美的排列</strong> ：</p>\n\n<ul>\n\t<li><code>perm[i]</code> 能够被 <code>i</code> 整除</li>\n\t<li><code>i</code> 能够被 <code>perm[i]</code> 整除</li>\n</ul>\n\n<p>给你一个整数 <code>n</code> ，返回可以构造的 <strong>优美排列 </strong>的 <strong>数量</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>2\n<b>解释：</b>\n第 1 个优美的排列是 [1,2]：\n    - perm[1] = 1 能被 i = 1 整除\n    - perm[2] = 2 能被 i = 2 整除\n第 2 个优美的排列是 [2,1]:\n    - perm[1] = 2 能被 i = 1 整除\n    - i = 2 能被 perm[2] = 1 整除\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 15</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 527单词缩写",
        "hardRate": "HARD",
        "passRate": "60.16%",
        "problemsUrl": "https://leetcode.cn/problems/word-abbreviation/",
        "solutionsUrl": "https://leetcode.cn/problems/word-abbreviation/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 528按权重随机选择",
        "hardRate": "MEDIUM",
        "passRate": "48.40%",
        "problemsUrl": "https://leetcode.cn/problems/random-pick-with-weight/",
        "solutionsUrl": "https://leetcode.cn/problems/random-pick-with-weight/solution",
        "problemsDesc": "<p>给你一个 <strong>下标从 0 开始</strong> 的正整数数组&nbsp;<code>w</code> ，其中&nbsp;<code>w[i]</code> 代表第 <code>i</code> 个下标的权重。</p>\n\n<p>请你实现一个函数&nbsp;<code>pickIndex</code>&nbsp;，它可以 <strong>随机地</strong> 从范围 <code>[0, w.length - 1]</code> 内（含 <code>0</code> 和 <code>w.length - 1</code>）选出并返回一个下标。选取下标 <code>i</code>&nbsp;的 <strong>概率</strong> 为 <code>w[i] / sum(w)</code> 。</p>\n\n<ol>\n</ol>\n\n<ul>\n\t<li>例如，对于 <code>w = [1, 3]</code>，挑选下标 <code>0</code> 的概率为 <code>1 / (1 + 3)&nbsp;= 0.25</code> （即，25%），而选取下标 <code>1</code> 的概率为 <code>3 / (1 + 3)&nbsp;= 0.75</code>（即，<code>75%</code>）。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"Solution\",\"pickIndex\"]\n[[[1]],[]]\n<strong>输出：</strong>\n[null,0]\n<strong>解释：</strong>\nSolution solution = new Solution([1]);\nsolution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"]\n[[[1,3]],[],[],[],[],[]]\n<strong>输出：</strong>\n[null,1,1,1,1,0]\n<strong>解释：</strong>\nSolution solution = new Solution([1, 3]);\nsolution.pickIndex(); // 返回 1，返回下标 1，返回该下标概率为 3/4 。\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 0，返回下标 0，返回该下标概率为 1/4 。\n\n由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的:\n[null,1,1,1,1,0]\n[null,1,1,1,1,1]\n[null,1,1,1,0,0]\n[null,1,1,1,0,1]\n[null,1,0,1,0,0]\n......\n诸若此类。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= w.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= w[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pickIndex</code>&nbsp;将被调用不超过 <code>10<sup>4</sup></code>&nbsp;次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 529扫雷游戏",
        "hardRate": "MEDIUM",
        "passRate": "63.95%",
        "problemsUrl": "https://leetcode.cn/problems/minesweeper/",
        "solutionsUrl": "https://leetcode.cn/problems/minesweeper/solution",
        "problemsDesc": "<p>让我们一起来玩扫雷游戏！</p>\n\n<p>给你一个大小为 <code>m x n</code> 二维字符矩阵&nbsp;<code>board</code> ，表示扫雷游戏的盘面，其中：</p>\n\n<ul>\n\t<li><code>'M'</code>&nbsp;代表一个 <strong>未挖出的</strong> 地雷，</li>\n\t<li><code>'E'</code>&nbsp;代表一个<strong> 未挖出的 </strong>空方块，</li>\n\t<li><code>'B'</code><strong>&nbsp;</strong>代表没有相邻（上，下，左，右，和所有4个对角线）地雷的<strong> 已挖出的 </strong>空白方块，</li>\n\t<li><strong>数字</strong>（<code>'1'</code> 到 <code>'8'</code>）表示有多少地雷与这块<strong> 已挖出的</strong> 方块相邻，</li>\n\t<li><code>'X'</code>&nbsp;则表示一个<strong> 已挖出的</strong> 地雷。</li>\n</ul>\n\n<p>给你一个整数数组 <code>click</code> ，其中 <code>click = [click<sub>r</sub>, click<sub>c</sub>]</code> 表示在所有<strong> 未挖出的 </strong>方块（<code>'M'</code> 或者 <code>'E'</code>）中的下一个点击位置（<code>click<sub>r</sub></code> 是行下标，<code>click<sub>c</sub></code> 是列下标）。</p>\n\n<p>根据以下规则，返回相应位置被点击后对应的盘面：</p>\n\n<ol>\n\t<li>如果一个地雷（<code>'M'</code>）被挖出，游戏就结束了- 把它改为&nbsp;<code>'X'</code> 。</li>\n\t<li>如果一个<strong> 没有相邻地雷 </strong>的空方块（<code>'E'</code>）被挖出，修改它为（<code>'B'</code>），并且所有和其相邻的<strong> 未挖出 </strong>方块都应该被递归地揭露。</li>\n\t<li>如果一个<strong> 至少与一个地雷相邻</strong> 的空方块（<code>'E'</code>）被挖出，修改它为数字（<code>'1'</code> 到 <code>'8'</code> ），表示相邻地雷的数量。</li>\n\t<li>如果在此次点击中，若无更多方块可被揭露，则返回盘面。</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/12/minesweeper_example_1.png\" style=\"width: 500px; max-width: 400px; height: 269px;\" />\n<pre>\n<strong>输入：</strong>board = [[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"M\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"]], click = [3,0]\n<strong>输出：</strong>[[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/12/minesweeper_example_2.png\" style=\"width: 500px; max-width: 400px; height: 275px;\" />\n<pre>\n<strong>输入：</strong>board = [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]], click = [1,2]\n<strong>输出：</strong>[[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"X\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>board[i][j]</code> 为 <code>'M'</code>、<code>'E'</code>、<code>'B'</code> 或数字 <code>'1'</code> 到 <code>'8'</code> 中的一个</li>\n\t<li><code>click.length == 2</code></li>\n\t<li><code>0 &lt;= click<sub>r</sub> &lt; m</code></li>\n\t<li><code>0 &lt;= click<sub>c</sub> &lt; n</code></li>\n\t<li><code>board[click<sub>r</sub>][click<sub>c</sub>]</code> 为 <code>'M'</code> 或 <code>'E'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 530二叉搜索树的最小绝对差",
        "hardRate": "EASY",
        "passRate": "63.42%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-absolute-difference-in-bst/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-absolute-difference-in-bst/solution",
        "problemsDesc": "<p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p>\n\n<p>差值是一个正数，其数值等于两值之差的绝对值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg\" style=\"width: 292px; height: 301px;\" />\n<pre>\n<strong>输入：</strong>root = [4,2,6,1,3]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg\" style=\"width: 282px; height: 301px;\" />\n<pre>\n<strong>输入：</strong>root = [1,0,48,null,null,12,49]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目范围是 <code>[2, 10<sup>4</sup>]</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与 783 <a href=\"https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/\">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/</a> 相同</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 531孤独像素 I",
        "hardRate": "MEDIUM",
        "passRate": "64.18%",
        "problemsUrl": "https://leetcode.cn/problems/lonely-pixel-i/",
        "solutionsUrl": "https://leetcode.cn/problems/lonely-pixel-i/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 532数组中的 k-diff 数对",
        "hardRate": "MEDIUM",
        "passRate": "45.62%",
        "problemsUrl": "https://leetcode.cn/problems/k-diff-pairs-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/k-diff-pairs-in-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code> 和一个整数&nbsp;<code>k</code>，请你在数组中找出<strong> 不同的&nbsp;</strong>k-diff 数对，并返回不同的 <strong>k-diff 数对</strong> 的数目。</p>\n\n<p><strong>k-diff</strong>&nbsp;数对定义为一个整数对 <code>(nums[i], nums[j])</code><strong> </strong>，并满足下述全部条件：</p>\n\n<ul>\n\t<li><code>0 &lt;= i, j &lt; nums.length</code></li>\n\t<li><code>i != j</code></li>\n\t<li><code>nums[i] - nums[j] == k</code></li>\n</ul>\n\n<p><strong>注意</strong>，<code>|val|</code> 表示 <code>val</code> 的绝对值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3, 1, 4, 1, 5], k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。\n尽管数组中有两个 1 ，但我们只应返回不同的数对的数量。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1, 2, 3, 4, 5], k = 1\n<strong>输出：</strong>4\n<strong>解释：</strong>数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1, 3, 1, 5, 4], k = 0\n<strong>输出：</strong>1\n<strong>解释：</strong>数组中只有一个 0-diff 数对，(1, 1) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>7</sup> &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 533孤独像素 II",
        "hardRate": "MEDIUM",
        "passRate": "52.67%",
        "problemsUrl": "https://leetcode.cn/problems/lonely-pixel-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/lonely-pixel-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 534游戏玩法分析 III",
        "hardRate": "MEDIUM",
        "passRate": "68.95%",
        "problemsUrl": "https://leetcode.cn/problems/game-play-analysis-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/game-play-analysis-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 535TinyURL 的加密与解密",
        "hardRate": "MEDIUM",
        "passRate": "87.54%",
        "problemsUrl": "https://leetcode.cn/problems/encode-and-decode-tinyurl/",
        "solutionsUrl": "https://leetcode.cn/problems/encode-and-decode-tinyurl/solution",
        "problemsDesc": "<p>TinyURL 是一种 URL 简化服务， 比如：当你输入一个 URL&nbsp;<code>https://leetcode.com/problems/design-tinyurl</code>&nbsp;时，它将返回一个简化的URL&nbsp;<code>http://tinyurl.com/4e9iAk</code> 。请你设计一个类来加密与解密 TinyURL 。</p>\n\n<p>加密和解密算法如何设计和运作是没有限制的，你只需要保证一个 URL 可以被加密成一个 TinyURL ，并且这个 TinyURL 可以用解密方法恢复成原本的 URL 。</p>\n\n<p>实现 <code>Solution</code> 类：</p>\n\n<div class=\"original__bRMd\">\n<div>\n<ul>\n\t<li><code>Solution()</code> 初始化 TinyURL 系统对象。</li>\n\t<li><code>String encode(String longUrl)</code> 返回 <code>longUrl</code> 对应的 TinyURL 。</li>\n\t<li><code>String decode(String shortUrl)</code> 返回 <code>shortUrl</code> 原本的 URL 。题目数据保证给定的 <code>shortUrl</code> 是由同一个系统对象加密的。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>url = \"https://leetcode.com/problems/design-tinyurl\"\n<strong>输出：</strong>\"https://leetcode.com/problems/design-tinyurl\"\n\n<strong>解释：</strong>\nSolution obj = new Solution();\nstring tiny = obj.encode(url); // 返回加密后得到的 TinyURL 。\nstring ans = obj.decode(tiny); // 返回解密后得到的原本的 URL 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= url.length &lt;= 10<sup>4</sup></code></li>\n\t<li>题目数据保证 <code>url</code> 是一个有效的 URL</li>\n</ul>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 536从字符串生成二叉树",
        "hardRate": "MEDIUM",
        "passRate": "55.23%",
        "problemsUrl": "https://leetcode.cn/problems/construct-binary-tree-from-string/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-binary-tree-from-string/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 537复数乘法",
        "hardRate": "MEDIUM",
        "passRate": "74.58%",
        "problemsUrl": "https://leetcode.cn/problems/complex-number-multiplication/",
        "solutionsUrl": "https://leetcode.cn/problems/complex-number-multiplication/solution",
        "problemsDesc": "<p><a href=\"https://baike.baidu.com/item/%E5%A4%8D%E6%95%B0/254365?fr=aladdin\" target=\"_blank\">复数</a> 可以用字符串表示，遵循 <code>\"<strong>实部</strong>+<strong>虚部</strong>i\"</code> 的形式，并满足下述条件：</p>\n\n<ul>\n\t<li><code>实部</code> 是一个整数，取值范围是 <code>[-100, 100]</code></li>\n\t<li><code>虚部</code> 也是一个整数，取值范围是 <code>[-100, 100]</code></li>\n\t<li><code>i<sup>2</sup> == -1</code></li>\n</ul>\n\n<p>给你两个字符串表示的复数 <code>num1</code> 和 <code>num2</code> ，请你遵循复数表示形式，返回表示它们乘积的字符串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = \"1+1i\", num2 = \"1+1i\"\n<strong>输出：</strong>\"0+2i\"\n<strong>解释：</strong>(1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i ，你需要将它转换为 0+2i 的形式。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = \"1+-1i\", num2 = \"1+-1i\"\n<strong>输出：</strong>\"0+-2i\"\n<strong>解释：</strong>(1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i ，你需要将它转换为 0+-2i 的形式。 \n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>num1</code> 和 <code>num2</code> 都是有效的复数表示。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 538把二叉搜索树转换为累加树",
        "hardRate": "MEDIUM",
        "passRate": "76.59%",
        "problemsUrl": "https://leetcode.cn/problems/convert-bst-to-greater-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-bst-to-greater-tree/solution",
        "problemsDesc": "<p>给出二叉<strong> 搜索 </strong>树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code>&nbsp;的新值等于原树中大于或等于&nbsp;<code>node.val</code>&nbsp;的值之和。</p>\n\n<p>提醒一下，二叉搜索树满足下列约束条件：</p>\n\n<ul>\n\t<li>节点的左子树仅包含键<strong> 小于 </strong>节点键的节点。</li>\n\t<li>节点的右子树仅包含键<strong> 大于</strong> 节点键的节点。</li>\n\t<li>左右子树也必须是二叉搜索树。</li>\n</ul>\n\n<p><strong>注意：</strong>本题和 1038:&nbsp;<a href=\"https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/\">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png\" style=\"height: 364px; width: 534px;\"></strong></p>\n\n<pre><strong>输入：</strong>[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n<strong>输出：</strong>[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>root = [0,null,1]\n<strong>输出：</strong>[1,null,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>root = [1,0,2]\n<strong>输出：</strong>[3,3,2]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>root = [3,2,4,1]\n<strong>输出：</strong>[7,9,4,10]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数介于 <code>0</code>&nbsp;和 <code>10<sup>4</sup></code><sup>&nbsp;</sup>之间。</li>\n\t<li>每个节点的值介于 <code>-10<sup>4</sup></code>&nbsp;和&nbsp;<code>10<sup>4</sup></code>&nbsp;之间。</li>\n\t<li>树中的所有值 <strong>互不相同</strong> 。</li>\n\t<li>给定的树为二叉搜索树。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 539最小时间差",
        "hardRate": "MEDIUM",
        "passRate": "65.95%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-difference/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-difference/solution",
        "problemsDesc": "<p>给定一个 24 小时制（小时:分钟 <strong>\"HH:MM\"</strong>）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>timePoints = [\"23:59\",\"00:00\"]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>timePoints = [\"00:00\",\"23:59\",\"00:00\"]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= timePoints.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>timePoints[i]</code> 格式为 <strong>\"HH:MM\"</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 540有序数组中的单一元素",
        "hardRate": "MEDIUM",
        "passRate": "60.50%",
        "problemsUrl": "https://leetcode.cn/problems/single-element-in-a-sorted-array/",
        "solutionsUrl": "https://leetcode.cn/problems/single-element-in-a-sorted-array/solution",
        "problemsDesc": "<p>给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。</p>\n\n<p>请你找出并返回只出现一次的那个数。</p>\n\n<p>你设计的解决方案必须满足 <code>O(log n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,1,2,3,3,4,4,8,8]\n<strong>输出:</strong> 2\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums =  [3,3,7,7,10,11,11]\n<strong>输出:</strong> 10\n</pre>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i]&nbsp;&lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 541反转字符串 II",
        "hardRate": "EASY",
        "passRate": "58.01%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-string-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-string-ii/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p>\n\n<ul>\n\t<li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li>\n\t<li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcdefg\", k = 2\n<strong>输出：</strong>\"bacdfeg\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\", k = 2\n<strong>输出：</strong>\"bacd\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> 仅由小写英文组成</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 54201 矩阵",
        "hardRate": "MEDIUM",
        "passRate": "46.59%",
        "problemsUrl": "https://leetcode.cn/problems/01-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/01-matrix/solution",
        "problemsDesc": "<p>给定一个由 <code>0</code> 和 <code>1</code> 组成的矩阵 <code>mat</code> ，请输出一个大小相同的矩阵，其中每一个格子是 <code>mat</code> 中对应位置元素到最近的 <code>0</code> 的距离。</p>\n\n<p>两个相邻元素间的距离为 <code>1</code> 。</p>\n\n<p> </p>\n\n<p><b>示例 1：</b></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626667201-NCWmuP-image.png\" style=\"width: 150px; \" /></p>\n\n<pre>\n<strong>输入：</strong>mat =<strong> </strong>[[0,0,0],[0,1,0],[0,0,0]]\n<strong>输出：</strong>[[0,0,0],[0,1,0],[0,0,0]]\n</pre>\n\n<p><b>示例 2：</b></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626667205-xFxIeK-image.png\" style=\"width: 150px; \" /></p>\n\n<pre>\n<b>输入：</b>mat =<b> </b>[[0,0,0],[0,1,0],[1,1,1]]\n<strong>输出：</strong>[[0,0,0],[0,1,0],[1,2,1]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 <= m, n <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= m * n <= 10<sup>4</sup></code></li>\n\t<li><code>mat[i][j] is either 0 or 1.</code></li>\n\t<li><code>mat</code> 中至少有一个 <code>0 </code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 543二叉树的直径",
        "hardRate": "EASY",
        "passRate": "58.58%",
        "problemsUrl": "https://leetcode.cn/problems/diameter-of-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/diameter-of-binary-tree/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。</p>\n\n<p>二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。</p>\n\n<p>两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg\" style=\"width: 292px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[1, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 544输出比赛匹配对",
        "hardRate": "MEDIUM",
        "passRate": "72.29%",
        "problemsUrl": "https://leetcode.cn/problems/output-contest-matches/",
        "solutionsUrl": "https://leetcode.cn/problems/output-contest-matches/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 545二叉树的边界",
        "hardRate": "MEDIUM",
        "passRate": "44.75%",
        "problemsUrl": "https://leetcode.cn/problems/boundary-of-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/boundary-of-binary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 546移除盒子",
        "hardRate": "HARD",
        "passRate": "60.84%",
        "problemsUrl": "https://leetcode.cn/problems/remove-boxes/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-boxes/solution",
        "problemsDesc": "<p>给出一些不同颜色的盒子<meta charset=\"UTF-8\" />&nbsp;<code>boxes</code>&nbsp;，盒子的颜色由不同的正数表示。</p>\n\n<p>你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 <code>k</code> 个盒子（<code>k&nbsp;&gt;= 1</code>），这样一轮之后你将得到 <code>k * k</code> 个积分。</p>\n\n<p>返回 <em>你能获得的最大积分和</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>boxes = [1,3,2,2,2,3,4,3,1]\n<strong>输出：</strong>23\n<strong>解释：</strong>\n[1, 3, 2, 2, 2, 3, 4, 3, 1] \n----&gt; [1, 3, 3, 4, 3, 1] (3*3=9 分) \n----&gt; [1, 3, 3, 3, 1] (1*1=1 分) \n----&gt; [1, 1] (3*3=9 分) \n----&gt; [] (2*2=4 分)\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>boxes = [1,1,1]\n<strong>输出：</strong>9\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>boxes = [1]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= boxes.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= boxes[i]&nbsp;&lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 547省份数量",
        "hardRate": "MEDIUM",
        "passRate": "62.21%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-provinces/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-provinces/solution",
        "problemsDesc": "<div class=\"original__bRMd\">\n<div>\n<p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p>\n\n<p><strong>省份</strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>\n\n<p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p>\n\n<p>返回矩阵中 <strong>省份</strong> 的数量。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg\" style=\"width: 222px; height: 142px;\" />\n<pre>\n<strong>输入：</strong>isConnected = [[1,1,0],[1,1,0],[0,0,1]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg\" style=\"width: 222px; height: 142px;\" />\n<pre>\n<strong>输入：</strong>isConnected = [[1,0,0],[0,1,0],[0,0,1]]\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 200</code></li>\n\t<li><code>n == isConnected.length</code></li>\n\t<li><code>n == isConnected[i].length</code></li>\n\t<li><code>isConnected[i][j]</code> 为 <code>1</code> 或 <code>0</code></li>\n\t<li><code>isConnected[i][i] == 1</code></li>\n\t<li><code>isConnected[i][j] == isConnected[j][i]</code></li>\n</ul>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 548将数组分割成和相等的子数组",
        "hardRate": "HARD",
        "passRate": "39.06%",
        "problemsUrl": "https://leetcode.cn/problems/split-array-with-equal-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/split-array-with-equal-sum/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 549二叉树中最长的连续序列",
        "hardRate": "MEDIUM",
        "passRate": "50.34%",
        "problemsUrl": "https://leetcode.cn/problems/binary-tree-longest-consecutive-sequence-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-tree-longest-consecutive-sequence-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 550游戏玩法分析 IV",
        "hardRate": "MEDIUM",
        "passRate": "43.68%",
        "problemsUrl": "https://leetcode.cn/problems/game-play-analysis-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/game-play-analysis-iv/solution",
        "problemsDesc": "<p>Table:&nbsp;<code>Activity</code></p>\n\n<pre>+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| player_id    | int     |\n| device_id    | int     |\n| event_date   | date    |\n| games_played | int     |\n+--------------+---------+\n（player_id，event_date）是此表的主键。\n这张表显示了某些游戏的玩家的活动情况。\n每一行是一个玩家的记录，他在某一天使用某个设备注销之前登录并玩了很多游戏（可能是 0）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个 SQL 查询，报告在首次登录的第二天再次登录的玩家的比率，四舍五入到小数点后两位。换句话说，您需要计算从首次登录日期开始至少连续两天登录的玩家的数量，然后除以玩家总数。</p>\n\n<p>查询结果格式如下所示：</p>\n\n<pre>Activity table:\n+-----------+-----------+------------+--------------+\n| player_id | device_id | event_date | games_played |\n+-----------+-----------+------------+--------------+\n| 1         | 2         | 2016-03-01 | 5            |\n| 1         | 2         | 2016-03-02 | 6            |\n| 2         | 3         | 2017-06-25 | 1            |\n| 3         | 1         | 2016-03-02 | 0            |\n| 3         | 4         | 2018-07-03 | 5            |\n+-----------+-----------+------------+--------------+\n\nResult table:\n+-----------+\n| fraction  |\n+-----------+\n| 0.33      |\n+-----------+\n只有 ID 为 1 的玩家在第一天登录后才重新登录，所以答案是 1/3 = 0.33\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 551学生出勤记录 I",
        "hardRate": "EASY",
        "passRate": "56.74%",
        "problemsUrl": "https://leetcode.cn/problems/student-attendance-record-i/",
        "solutionsUrl": "https://leetcode.cn/problems/student-attendance-record-i/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：</p>\n\n<ul>\n\t<li><code>'A'</code>：Absent，缺勤</li>\n\t<li><code>'L'</code>：Late，迟到</li>\n\t<li><code>'P'</code>：Present，到场</li>\n</ul>\n\n<p>如果学生能够 <strong>同时</strong> 满足下面两个条件，则可以获得出勤奖励：</p>\n\n<ul>\n\t<li>按 <strong>总出勤</strong> 计，学生缺勤（<code>'A'</code>）<strong>严格</strong> 少于两天。</li>\n\t<li>学生 <strong>不会</strong> 存在 <strong>连续</strong> 3 天或 <strong>连续</strong> 3 天以上的迟到（<code>'L'</code>）记录。</li>\n</ul>\n\n<p>如果学生可以获得出勤奖励，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"PPALLP\"\n<strong>输出：</strong>true\n<strong>解释：</strong>学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"PPALLL\"\n<strong>输出：</strong>false\n<strong>解释：</strong>学生最后三天连续迟到，所以不满足出勤奖励的条件。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i]</code> 为 <code>'A'</code>、<code>'L'</code> 或 <code>'P'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 552学生出勤记录 II",
        "hardRate": "HARD",
        "passRate": "57.77%",
        "problemsUrl": "https://leetcode.cn/problems/student-attendance-record-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/student-attendance-record-ii/solution",
        "problemsDesc": "可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：\n<ul>\n\t<li><code>'A'</code>：Absent，缺勤</li>\n\t<li><code>'L'</code>：Late，迟到</li>\n\t<li><code>'P'</code>：Present，到场</li>\n</ul>\n\n<p>如果学生能够 <strong>同时</strong> 满足下面两个条件，则可以获得出勤奖励：</p>\n\n<ul>\n\t<li>按 <strong>总出勤</strong> 计，学生缺勤（<code>'A'</code>）<strong>严格</strong> 少于两天。</li>\n\t<li>学生 <strong>不会</strong> 存在 <strong>连续</strong> 3 天或 <strong>连续</strong> 3 天以上的迟到（<code>'L'</code>）记录。</li>\n</ul>\n\n<p>给你一个整数 <code>n</code> ，表示出勤记录的长度（次数）。请你返回记录长度为 <code>n</code> 时，可能获得出勤奖励的记录情况 <strong>数量</strong> 。答案可能很大，所以返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>8\n<strong>解释：\n</strong>有 8 种长度为 2 的记录将被视为可奖励：\n\"PP\" , \"AP\", \"PA\", \"LP\", \"PL\", \"AL\", \"LA\", \"LL\" \n只有\"AA\"不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10101\n<strong>输出：</strong>183236316\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 553最优除法",
        "hardRate": "MEDIUM",
        "passRate": "64.77%",
        "problemsUrl": "https://leetcode.cn/problems/optimal-division/",
        "solutionsUrl": "https://leetcode.cn/problems/optimal-division/solution",
        "problemsDesc": "<p>给定一正整数数组<strong> </strong><code>nums</code><strong>，</strong><code>nums</code> 中的相邻整数将进行浮点除法。例如，&nbsp;[2,3,4] -&gt; 2 / 3 / 4 。</p>\n\n<ul>\n\t<li>例如，<code>nums = [2,3,4]</code>，我们将求表达式的值&nbsp;<code>\"2/3/4\"</code>。</li>\n</ul>\n\n<p>但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，以便计算后的表达式的值为最大值。</p>\n\n<p>以字符串格式返回具有最大值的对应表达式。</p>\n\n<p><strong>注意：</strong>你的表达式不应该包含多余的括号。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> [1000,100,10,2]\n<strong>输出:</strong> \"1000/(100/10/2)\"\n<strong>解释: </strong>1000/(100/10/2) = 1000/((100/10)/2) = 200\n但是，以下加粗的括号 \"1000/(<strong>(</strong>100/10<strong>)</strong>/2)\" 是冗余的，\n因为他们并不影响操作的优先级，所以你需要返回 \"1000/(100/10/2)\"。\n\n其他用例:\n1000/(100/10)/2 = 50\n1000/(100/(10/2)) = 50\n1000/100/10/2 = 0.5\n1000/100/(10/2) = 2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [2,3,4]\n<strong>输出:</strong> \"2/(3/4)\"\n<strong>解释:</strong> (2/(3/4)) = 8/3 = 2.667\n可以看出，在尝试了所有的可能性之后，我们无法得到一个结果大于 2.667 的表达式。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10</code></li>\n\t<li><code>2 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>对于给定的输入只有一种最优除法。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 554砖墙",
        "hardRate": "MEDIUM",
        "passRate": "51.49%",
        "problemsUrl": "https://leetcode.cn/problems/brick-wall/",
        "solutionsUrl": "https://leetcode.cn/problems/brick-wall/solution",
        "problemsDesc": "<p>你的面前有一堵矩形的、由 <code>n</code> 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和相等。</p>\n\n<p>你现在要画一条 <strong>自顶向下 </strong>的、穿过 <strong>最少 </strong>砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。<strong>你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。</strong></p>\n\n<p>给你一个二维数组 <code>wall</code> ，该数组包含这堵墙的相关信息。其中，<code>wall[i]</code> 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 <strong>穿过的砖块数量最少</strong> ，并且返回 <strong>穿过的砖块数量</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/24/cutwall-grid.jpg\" style=\"width: 493px; height: 577px;\" />\n<pre>\n<strong>输入：</strong>wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>wall = [[1],[1],[1]]\n<strong>输出：</strong>3\n</pre>\n \n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == wall.length</code></li>\n\t<li><code>1 <= n <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= wall[i].length <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= sum(wall[i].length) <= 2 * 10<sup>4</sup></code></li>\n\t<li>对于每一行 <code>i</code> ，<code>sum(wall[i])</code> 是相同的</li>\n\t<li><code>1 <= wall[i][j] <= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 555分割连接字符串",
        "hardRate": "MEDIUM",
        "passRate": "37.67%",
        "problemsUrl": "https://leetcode.cn/problems/split-concatenated-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/split-concatenated-strings/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 556下一个更大元素 III",
        "hardRate": "MEDIUM",
        "passRate": "36.89%",
        "problemsUrl": "https://leetcode.cn/problems/next-greater-element-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/next-greater-element-iii/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> ，请你找出符合条件的最小整数，其由重新排列 <code>n</code><strong> </strong>中存在的每位数字组成，并且其值大于 <code>n</code> 。如果不存在这样的正整数，则返回 <code>-1</code> 。</p>\n\n<p><strong>注意</strong> ，返回的整数应当是一个 <strong>32 位整数</strong> ，如果存在满足题意的答案，但不是 <strong>32 位整数</strong> ，同样返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 12\n<strong>输出：</strong>21\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 21\n<strong>输出：</strong>-1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 557反转字符串中的单词 III",
        "hardRate": "EASY",
        "passRate": "73.76%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-words-in-a-string-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-words-in-a-string-iii/solution",
        "problemsDesc": "<p>给定一个字符串<meta charset=\"UTF-8\" />&nbsp;<code>s</code>&nbsp;，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"Let's take LeetCode contest\"\n<strong>输出：</strong>\"s'teL ekat edoCteeL tsetnoc\"\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入：</strong> s = \"God Ding\"\n<strong>输出：</strong>\"doG gniD\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong><strong><strong><strong>提示：</strong></strong></strong></strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><meta charset=\"UTF-8\" /><code>s</code>&nbsp;包含可打印的 <strong>ASCII</strong> 字符。</li>\n\t<li><meta charset=\"UTF-8\" /><code>s</code>&nbsp;不包含任何开头或结尾空格。</li>\n\t<li><meta charset=\"UTF-8\" /><code>s</code>&nbsp;里 <strong>至少</strong> 有一个词。</li>\n\t<li><meta charset=\"UTF-8\" /><code>s</code>&nbsp;中的所有单词都用一个空格隔开。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 558四叉树交集",
        "hardRate": "MEDIUM",
        "passRate": "62.77%",
        "problemsUrl": "https://leetcode.cn/problems/logical-or-of-two-binary-grids-represented-as-quad-trees/",
        "solutionsUrl": "https://leetcode.cn/problems/logical-or-of-two-binary-grids-represented-as-quad-trees/solution",
        "problemsDesc": "<p>二进制矩阵中的所有元素不是 <strong>0</strong> 就是 <strong>1 </strong>。</p>\n\n<p>给你两个四叉树，<code>quadTree1</code> 和 <code>quadTree2</code>。其中 <code>quadTree1</code> 表示一个 <code>n * n</code> 二进制矩阵，而 <code>quadTree2</code> 表示另一个 <code>n * n</code> 二进制矩阵。</p>\n\n<p>请你返回一个表示 <code>n * n</code> 二进制矩阵的四叉树，它是 <code>quadTree1</code> 和 <code>quadTree2</code> 所表示的两个二进制矩阵进行 <strong>按位逻辑或运算</strong> 的结果。</p>\n\n<p>注意，当 <code>isLeaf</code> 为 <strong>False </strong>时，你可以把 <strong>True</strong> 或者 <strong>False</strong> 赋值给节点，两种值都会被判题机制 <strong>接受</strong> 。</p>\n\n<p>四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：</p>\n\n<ul>\n\t<li><code>val</code>：储存叶子结点所代表的区域的值。1 对应 <strong>True</strong>，0 对应 <strong>False</strong>；</li>\n\t<li><code>isLeaf</code>: 当这个节点是一个叶子结点时为 <strong>True</strong>，如果它有 4 个子节点则为 <strong>False</strong> 。</li>\n</ul>\n\n<pre>\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}</pre>\n\n<p>我们可以按以下步骤为二维区域构建四叉树：</p>\n\n<ol>\n\t<li>如果当前网格的值相同（即，全为 <code>0</code> 或者全为 <code>1</code>），将 <code>isLeaf</code> 设为 True ，将 <code>val</code> 设为网格相应的值，并将四个子节点都设为 Null 然后停止。</li>\n\t<li>如果当前网格的值不同，将 <code>isLeaf</code> 设为 False， 将 <code>val</code> 设为任意值，然后如下图所示，将当前网格划分为四个子网格。</li>\n\t<li>使用适当的子网格递归每个子节点。</li>\n</ol>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/11/new_top.png\" style=\"height: 181px; width: 777px;\" /></p>\n\n<p>如果你想了解更多关于四叉树的内容，可以参考 <a href=\"https://en.wikipedia.org/wiki/Quadtree\">wiki</a> 。</p>\n\n<p><strong>四叉树格式：</strong></p>\n\n<p>输出为使用层序遍历后四叉树的序列化形式，其中 <code>null</code> 表示路径终止符，其下面不存在节点。</p>\n\n<p>它与二叉树的序列化非常相似。唯一的区别是节点以列表形式表示 <code>[isLeaf, val]</code> 。</p>\n\n<p>如果 <code>isLeaf</code> 或者 <code>val</code> 的值为 True ，则表示它在列表 <code>[isLeaf, val]</code> 中的值为 <strong>1</strong> ；如果 <code>isLeaf</code> 或者 <code>val</code> 的值为 False ，则表示值为 <strong>0 </strong>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/11/qt1.png\" style=\"height: 196px; width: 550px;\" /> <img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/11/qt2.png\" style=\"height: 278px; width: 550px;\" /></p>\n\n<pre>\n<strong>输入：</strong>quadTree1 = [[0,1],[1,1],[1,1],[1,0],[1,0]]\n, quadTree2 = [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\n<strong>输出：</strong>[[0,0],[1,1],[1,1],[1,1],[1,0]]\n<strong>解释：</strong>quadTree1 和 quadTree2 如上所示。由四叉树所表示的二进制矩阵也已经给出。\n如果我们对这两个矩阵进行按位逻辑或运算，则可以得到下面的二进制矩阵，由一个作为结果的四叉树表示。\n注意，我们展示的二进制矩阵仅仅是为了更好地说明题意，你无需构造二进制矩阵来获得结果四叉树。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/11/qtr.png\" style=\"height: 222px; width: 777px;\" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>quadTree1 = [[1,0]]\n, quadTree2 = [[1,0]]\n<strong>输出：</strong>[[1,0]]\n<strong>解释：</strong>两个数所表示的矩阵大小都为 1*1，值全为 0 \n结果矩阵大小为 1*1，值全为 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>quadTree1 = [[0,0],[1,0],[1,0],[1,1],[1,1]]\n, quadTree2 = [[0,0],[1,1],[1,1],[1,0],[1,1]]\n<strong>输出：</strong>[[1,1]]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>quadTree1 = [[0,0],[1,1],[1,0],[1,1],[1,1]]\n, quadTree2 = [[0,0],[1,1],[0,1],[1,1],[1,1],null,null,null,null,[1,1],[1,0],[1,0],[1,1]]\n<strong>输出：</strong>[[0,0],[1,1],[0,1],[1,1],[1,1],null,null,null,null,[1,1],[1,0],[1,0],[1,1]]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>quadTree1 = [[0,1],[1,0],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\n, quadTree2 = [[0,1],[0,1],[1,0],[1,1],[1,0],[1,0],[1,0],[1,1],[1,1]]\n<strong>输出：</strong>[[0,0],[0,1],[0,1],[1,1],[1,0],[1,0],[1,0],[1,1],[1,1],[1,0],[1,0],[1,1],[1,1]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>quadTree1</code> 和 <code>quadTree2</code> 都是符合题目要求的四叉树，每个都代表一个 <code>n * n</code> 的矩阵。</li>\n\t<li><code>n == 2^x</code> ，其中 <code>0 <= x <= 9</code>.</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 559N 叉树的最大深度",
        "hardRate": "EASY",
        "passRate": "75.00%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/solution",
        "problemsDesc": "<p>给定一个 N 叉树，找到其最大深度。</p>\n\n<p class=\"MachineTrans-lang-zh-CN\">最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p>\n\n<p class=\"MachineTrans-lang-zh-CN\">N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p>\n\n<p class=\"MachineTrans-lang-zh-CN\"> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 100%; max-width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,null,3,2,4,null,5,6]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"width: 296px; height: 241px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>输出：</strong>5\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树的深度不会超过 <code>1000</code> 。</li>\n\t<li>树的节点数目位于 <code>[0, 10<sup>4</sup>]</code> 之间。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 560和为 K 的子数组",
        "hardRate": "MEDIUM",
        "passRate": "45.02%",
        "problemsUrl": "https://leetcode.cn/problems/subarray-sum-equals-k/",
        "solutionsUrl": "https://leetcode.cn/problems/subarray-sum-equals-k/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数&nbsp;<code>k</code> ，请你统计并返回 <em>该数组中和为&nbsp;<code>k</code><strong>&nbsp;</strong>的连续子数组的个数&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1], k = 2\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3], k = 3\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>-10<sup>7</sup> &lt;= k &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 561数组拆分",
        "hardRate": "EASY",
        "passRate": "78.52%",
        "problemsUrl": "https://leetcode.cn/problems/array-partition/",
        "solutionsUrl": "https://leetcode.cn/problems/array-partition/solution",
        "problemsDesc": "<p>给定长度为&nbsp;<code>2n</code><strong>&nbsp;</strong>的整数数组 <code>nums</code> ，你的任务是将这些数分成&nbsp;<code>n</code><strong> </strong>对, 例如 <code>(a<sub>1</sub>, b<sub>1</sub>), (a<sub>2</sub>, b<sub>2</sub>), ..., (a<sub>n</sub>, b<sub>n</sub>)</code> ，使得从 <code>1</code> 到&nbsp;<code>n</code> 的 <code>min(a<sub>i</sub>, b<sub>i</sub>)</code> 总和最大。</p>\n\n<p>返回该 <strong>最大总和</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,4,3,2]\n<strong>输出：</strong>4\n<strong>解释：</strong>所有可能的分法（忽略元素顺序）为：\n1. (1, 4), (2, 3) -&gt; min(1, 4) + min(2, 3) = 1 + 2 = 3\n2. (1, 3), (2, 4) -&gt; min(1, 3) + min(2, 4) = 1 + 2 = 3\n3. (1, 2), (3, 4) -&gt; min(1, 2) + min(3, 4) = 1 + 3 = 4\n所以最大总和为 4</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [6,2,6,5,1,2]\n<strong>输出：</strong>9\n<strong>解释：</strong>最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums.length == 2 * n</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 562矩阵中最长的连续1线段",
        "hardRate": "MEDIUM",
        "passRate": "49.70%",
        "problemsUrl": "https://leetcode.cn/problems/longest-line-of-consecutive-one-in-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-line-of-consecutive-one-in-matrix/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 563二叉树的坡度",
        "hardRate": "EASY",
        "passRate": "65.89%",
        "problemsUrl": "https://leetcode.cn/problems/binary-tree-tilt/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-tree-tilt/solution",
        "problemsDesc": "<p>给你一个二叉树的根节点 <code>root</code> ，计算并返回 <strong>整个树 </strong>的坡度 。</p>\n\n<p>一个树的<strong> 节点的坡度 </strong>定义即为，该节点左子树的节点之和和右子树节点之和的 <strong>差的绝对值 </strong>。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。</p>\n\n<p><strong>整个树</strong> 的坡度就是其所有节点的坡度之和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt1.jpg\" style=\"width: 712px; height: 182px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n节点 2 的坡度：|0-0| = 0（没有子节点）\n节点 3 的坡度：|0-0| = 0（没有子节点）\n节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）\n坡度总和：0 + 0 + 1 = 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt2.jpg\" style=\"width: 800px; height: 203px;\" />\n<pre>\n<strong>输入：</strong>root = [4,2,9,3,5,null,7]\n<strong>输出：</strong>15\n<strong>解释：</strong>\n节点 3 的坡度：|0-0| = 0（没有子节点）\n节点 5 的坡度：|0-0| = 0（没有子节点）\n节点 7 的坡度：|0-0| = 0（没有子节点）\n节点 2 的坡度：|3-5| = 2（左子树就是左子节点，所以和是 3 ；右子树就是右子节点，所以和是 5 ）\n节点 9 的坡度：|0-7| = 7（没有左子树，所以和是 0 ；右子树正好是右子节点，所以和是 7 ）\n节点 4 的坡度：|(3+5+2)-(9+7)| = |10-16| = 6（左子树值为 3、5 和 2 ，和是 10 ；右子树值为 9 和 7 ，和是 16 ）\n坡度总和：0 + 0 + 0 + 2 + 7 + 6 = 15\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt3.jpg\" style=\"width: 800px; height: 293px;\" />\n<pre>\n<strong>输入：</strong>root = [21,7,14,1,1,2,2,3,3]\n<strong>输出：</strong>9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目的范围在 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 564寻找最近的回文数",
        "hardRate": "HARD",
        "passRate": "30.42%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-closest-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-closest-palindrome/solution",
        "problemsDesc": "<p>给定一个表示整数的字符串&nbsp;<code>n</code> ，返回与它最近的回文整数（不包括自身）。如果不止一个，返回较小的那个。</p>\n\n<p>“最近的”定义为两个整数<strong>差的绝对值</strong>最小。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = \"123\"\n<strong>输出:</strong> \"121\"\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = \"1\"\n<strong>输出:</strong> \"0\"\n<strong>解释:</strong> 0 和 2是最近的回文，但我们返回最小的，也就是 0。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n.length &lt;= 18</code></li>\n\t<li><code>n</code>&nbsp;只由数字组成</li>\n\t<li><code>n</code>&nbsp;不含前导 0</li>\n\t<li><code>n</code>&nbsp;代表在&nbsp;<code>[1, 10<sup>18</sup>&nbsp;- 1]</code> 范围内的整数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 565数组嵌套",
        "hardRate": "MEDIUM",
        "passRate": "62.38%",
        "problemsUrl": "https://leetcode.cn/problems/array-nesting/",
        "solutionsUrl": "https://leetcode.cn/problems/array-nesting/solution",
        "problemsDesc": "<p>索引从<code>0</code>开始长度为<code>N</code>的数组<code>A</code>，包含<code>0</code>到<code>N - 1</code>的所有整数。找到最大的集合<code>S</code>并返回其大小，其中 <code>S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }</code>且遵守以下的规则。</p>\n\n<p>假设选择索引为<code>i</code>的元素<code>A[i]</code>为<code>S</code>的第一个元素，<code>S</code>的下一个元素应该是<code>A[A[i]]</code>，之后是<code>A[A[A[i]]]...</code> 以此类推，不断添加直到<code>S</code>出现重复的元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> A = [5,4,0,3,1,6,2]\n<strong>输出:</strong> 4\n<strong>解释:</strong> \nA[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.\n\n其中一种最长的 S[K]:\nS[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt; nums.length</code></li>\n\t<li><code>A</code>中不含有重复的元素。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 566重塑矩阵",
        "hardRate": "EASY",
        "passRate": "64.80%",
        "problemsUrl": "https://leetcode.cn/problems/reshape-the-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/reshape-the-matrix/solution",
        "problemsDesc": "<p>在 MATLAB 中，有一个非常有用的函数 <code>reshape</code> ，它可以将一个&nbsp;<code>m x n</code> 矩阵重塑为另一个大小不同（<code>r x c</code>）的新矩阵，但保留其原始数据。</p>\n\n<p>给你一个由二维数组 <code>mat</code> 表示的&nbsp;<code>m x n</code> 矩阵，以及两个正整数 <code>r</code> 和 <code>c</code> ，分别表示想要的重构的矩阵的行数和列数。</p>\n\n<p>重构后的矩阵需要将原始矩阵的所有元素以相同的<strong> 行遍历顺序 </strong>填充。</p>\n\n<p>如果具有给定参数的 <code>reshape</code> 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/24/reshape1-grid.jpg\" style=\"width: 613px; height: 173px;\" />\n<pre>\n<strong>输入：</strong>mat = [[1,2],[3,4]], r = 1, c = 4\n<strong>输出：</strong>[[1,2,3,4]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg\" style=\"width: 453px; height: 173px;\" />\n<pre>\n<strong>输入：</strong>mat = [[1,2],[3,4]], r = 2, c = 4\n<strong>输出：</strong>[[1,2],[3,4]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>-1000 &lt;= mat[i][j] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= r, c &lt;= 300</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 567字符串的排列",
        "hardRate": "MEDIUM",
        "passRate": "44.48%",
        "problemsUrl": "https://leetcode.cn/problems/permutation-in-string/",
        "solutionsUrl": "https://leetcode.cn/problems/permutation-in-string/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>s1</code>&nbsp;和&nbsp;<code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code><strong>&nbsp;</strong>的排列。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 <strong>子串</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"ab\" s2 = \"eidbaooo\"\n<strong>输出：</strong>true\n<strong>解释：</strong>s2 包含 s1 的排列之一 (\"ba\").\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1= \"ab\" s2 = \"eidboaoo\"\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s1</code> 和 <code>s2</code> 仅包含小写字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 568最大休假天数",
        "hardRate": "HARD",
        "passRate": "53.82%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-vacation-days/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-vacation-days/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 569员工薪水中位数",
        "hardRate": "HARD",
        "passRate": "57.36%",
        "problemsUrl": "https://leetcode.cn/problems/median-employee-salary/",
        "solutionsUrl": "https://leetcode.cn/problems/median-employee-salary/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 570至少有5名直接下属的经理",
        "hardRate": "MEDIUM",
        "passRate": "64.91%",
        "problemsUrl": "https://leetcode.cn/problems/managers-with-at-least-5-direct-reports/",
        "solutionsUrl": "https://leetcode.cn/problems/managers-with-at-least-5-direct-reports/solution",
        "problemsDesc": "<p>表:&nbsp;<code>Employee</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n| department  | varchar |\n| managerId   | int     |\n+-------------+---------+\nId是该表的主键列。\n该表的每一行都表示雇员的名字、他们的部门和他们的经理的id。\n如果managerId为空，则该员工没有经理。\n没有员工会成为自己的管理者。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个SQL查询，查询<strong>至少有5名直接下属</strong>的经理<strong> </strong>。</p>\n\n<p>以 <strong>任意顺序 </strong>返回结果表。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nEmployee 表:\n+-----+-------+------------+-----------+\n| id  | name  | department | managerId |\n+-----+-------+------------+-----------+\n| 101 | John  | A          | None      |\n| 102 | Dan   | A          | 101       |\n| 103 | James | A          | 101       |\n| 104 | Amy   | A          | 101       |\n| 105 | Anne  | A          | 101       |\n| 106 | Ron   | B          | 101       |\n+-----+-------+------------+-----------+\n<strong>输出:</strong> \n+------+\n| name |\n+------+\n| John |\n+------+</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 571给定数字的频率查询中位数",
        "hardRate": "HARD",
        "passRate": "47.06%",
        "problemsUrl": "https://leetcode.cn/problems/find-median-given-frequency-of-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/find-median-given-frequency-of-numbers/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 572另一棵树的子树",
        "hardRate": "EASY",
        "passRate": "47.50%",
        "problemsUrl": "https://leetcode.cn/problems/subtree-of-another-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/subtree-of-another-tree/solution",
        "problemsDesc": "<div class=\"original__bRMd\">\n<div>\n<p>给你两棵二叉树 <code>root</code> 和 <code>subRoot</code> 。检验 <code>root</code> 中是否包含和 <code>subRoot</code> 具有相同结构和节点值的子树。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>二叉树 <code>tree</code> 的一棵子树包括 <code>tree</code> 的某个节点和这个节点的所有后代节点。<code>tree</code> 也可以看做它自身的一棵子树。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg\" style=\"width: 532px; height: 400px;\" />\n<pre>\n<strong>输入：</strong>root = [3,4,5,1,2], subRoot = [4,1,2]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/28/subtree2-tree.jpg\" style=\"width: 502px; height: 458px;\" />\n<pre>\n<strong>输入：</strong>root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>root</code> 树上的节点数量范围是 <code>[1, 2000]</code></li>\n\t<li><code>subRoot</code> 树上的节点数量范围是 <code>[1, 1000]</code></li>\n\t<li><code>-10<sup>4</sup> <= root.val <= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= subRoot.val <= 10<sup>4</sup></code></li>\n</ul>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 573松鼠模拟",
        "hardRate": "MEDIUM",
        "passRate": "65.30%",
        "problemsUrl": "https://leetcode.cn/problems/squirrel-simulation/",
        "solutionsUrl": "https://leetcode.cn/problems/squirrel-simulation/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 574当选者",
        "hardRate": "MEDIUM",
        "passRate": "66.37%",
        "problemsUrl": "https://leetcode.cn/problems/winning-candidate/",
        "solutionsUrl": "https://leetcode.cn/problems/winning-candidate/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 575分糖果",
        "hardRate": "EASY",
        "passRate": "70.44%",
        "problemsUrl": "https://leetcode.cn/problems/distribute-candies/",
        "solutionsUrl": "https://leetcode.cn/problems/distribute-candies/solution",
        "problemsDesc": "<p>Alice 有 <code>n</code> 枚糖，其中第 <code>i</code> 枚糖的类型为 <code>candyType[i]</code> 。Alice 注意到她的体重正在增长，所以前去拜访了一位医生。</p>\n\n<p>医生建议 Alice 要少摄入糖分，只吃掉她所有糖的 <code>n / 2</code> 即可（<code>n</code> 是一个偶数）。Alice 非常喜欢这些糖，她想要在遵循医生建议的情况下，尽可能吃到最多不同种类的糖。</p>\n\n<p>给你一个长度为 <code>n</code> 的整数数组 <code>candyType</code> ，返回： Alice <em>在仅吃掉 <code>n / 2</code> 枚糖的情况下，可以吃到糖的 <strong>最多</strong> 种类数</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>candyType = [1,1,2,2,3,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>Alice 只能吃 6 / 2 = 3 枚糖，由于只有 3 种糖，她可以每种吃一枚。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>candyType = [1,1,2,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>Alice 只能吃 4 / 2 = 2 枚糖，不管她选择吃的种类是 [1,2]、[1,3] 还是 [2,3]，她只能吃到两种不同类的糖。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>candyType = [6,6,6,6]\n<strong>输出：</strong>1\n<strong>解释：</strong>Alice 只能吃 4 / 2 = 2 枚糖，尽管她能吃 2 枚，但只能吃到 1 种糖。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == candyType.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>n</code> 是一个偶数</li>\n\t<li><code>-10<sup>5</sup> &lt;= candyType[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 576出界的路径数",
        "hardRate": "MEDIUM",
        "passRate": "46.99%",
        "problemsUrl": "https://leetcode.cn/problems/out-of-boundary-paths/",
        "solutionsUrl": "https://leetcode.cn/problems/out-of-boundary-paths/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的网格和一个球。球的起始坐标为 <code>[startRow, startColumn]</code> 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 <strong>最多</strong> 可以移动 <code>maxMove</code> 次球。</p>\n\n<p>给你五个整数 <code>m</code>、<code>n</code>、<code>maxMove</code>、<code>startRow</code> 以及 <code>startColumn</code> ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_1.png\" style=\"width: 500px; height: 296px;\" />\n<pre>\n<strong>输入：</strong>m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_2.png\" style=\"width: 500px; height: 293px;\" />\n<pre>\n<strong>输入：</strong>m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1\n<strong>输出：</strong>12\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>0 &lt;= maxMove &lt;= 50</code></li>\n\t<li><code>0 &lt;= startRow &lt; m</code></li>\n\t<li><code>0 &lt;= startColumn &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 577员工奖金",
        "hardRate": "EASY",
        "passRate": "69.20%",
        "problemsUrl": "https://leetcode.cn/problems/employee-bonus/",
        "solutionsUrl": "https://leetcode.cn/problems/employee-bonus/solution",
        "problemsDesc": "<p>选出所有 bonus &lt; 1000 的员工的 name 及其 bonus。</p>\n\n<p><code>Employee</code> 表单</p>\n\n<pre>+-------+--------+-----------+--------+\n| empId |  name  | supervisor| salary |\n+-------+--------+-----------+--------+\n|   1   | John   |  3        | 1000   |\n|   2   | Dan    |  3        | 2000   |\n|   3   | Brad   |  null     | 4000   |\n|   4   | Thomas |  3        | 4000   |\n+-------+--------+-----------+--------+\nempId 是这张表单的主关键字\n</pre>\n\n<p><code>Bonus</code> 表单</p>\n\n<pre>+-------+-------+\n| empId | bonus |\n+-------+-------+\n| 2     | 500   |\n| 4     | 2000  |\n+-------+-------+\nempId 是这张表单的主关键字\n</pre>\n\n<p>输出示例：</p>\n\n<pre>+-------+-------+\n| name  | bonus |\n+-------+-------+\n| John  | null  |\n| Dan   | 500   |\n| Brad  | null  |\n+-------+-------+\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 578查询回答率最高的问题",
        "hardRate": "MEDIUM",
        "passRate": "42.31%",
        "problemsUrl": "https://leetcode.cn/problems/get-highest-answer-rate-question/",
        "solutionsUrl": "https://leetcode.cn/problems/get-highest-answer-rate-question/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 579查询员工的累计薪水",
        "hardRate": "HARD",
        "passRate": "44.15%",
        "problemsUrl": "https://leetcode.cn/problems/find-cumulative-salary-of-an-employee/",
        "solutionsUrl": "https://leetcode.cn/problems/find-cumulative-salary-of-an-employee/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 580统计各专业学生人数",
        "hardRate": "MEDIUM",
        "passRate": "53.64%",
        "problemsUrl": "https://leetcode.cn/problems/count-student-number-in-departments/",
        "solutionsUrl": "https://leetcode.cn/problems/count-student-number-in-departments/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 581最短无序连续子数组",
        "hardRate": "MEDIUM",
        "passRate": "41.78%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，你需要找出一个 <strong>连续子数组</strong> ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>\n\n<p>请你找出符合题意的 <strong>最短</strong> 子数组，并输出它的长度。</p>\n\n<p> </p>\n\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,6,4,8,10,9,15]\n<strong>输出：</strong>5\n<strong>解释：</strong>你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1]\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>5</sup> <= nums[i] <= 10<sup>5</sup></code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(n)</code> 的解决方案吗？</p>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 582杀掉进程",
        "hardRate": "MEDIUM",
        "passRate": "45.90%",
        "problemsUrl": "https://leetcode.cn/problems/kill-process/",
        "solutionsUrl": "https://leetcode.cn/problems/kill-process/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 583两个字符串的删除操作",
        "hardRate": "MEDIUM",
        "passRate": "66.63%",
        "problemsUrl": "https://leetcode.cn/problems/delete-operation-for-two-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-operation-for-two-strings/solution",
        "problemsDesc": "<p>给定两个单词&nbsp;<code>word1</code>&nbsp;和<meta charset=\"UTF-8\" />&nbsp;<code>word2</code>&nbsp;，返回使得<meta charset=\"UTF-8\" />&nbsp;<code>word1</code>&nbsp;和&nbsp;<meta charset=\"UTF-8\" />&nbsp;<code>word2</code><em>&nbsp;</em><strong>相同</strong>所需的<strong>最小步数</strong>。</p>\n\n<p><strong>每步&nbsp;</strong>可以删除任意一个字符串中的一个字符。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> word1 = \"sea\", word2 = \"eat\"\n<strong>输出:</strong> 2\n<strong>解释:</strong> 第一步将 \"sea\" 变为 \"ea\" ，第二步将 \"eat \"变为 \"ea\"\n</pre>\n\n<p><strong>示例 &nbsp;2:</strong></p>\n\n<pre>\n<b>输入：</b>word1 = \"leetcode\", word2 = \"etco\"\n<b>输出：</b>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>1 &lt;= word1.length, word2.length &lt;= 500</code></li>\n\t<li><code>word1</code>&nbsp;和&nbsp;<code>word2</code>&nbsp;只包含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 584寻找用户推荐人",
        "hardRate": "EASY",
        "passRate": "65.39%",
        "problemsUrl": "https://leetcode.cn/problems/find-customer-referee/",
        "solutionsUrl": "https://leetcode.cn/problems/find-customer-referee/solution",
        "problemsDesc": "<p>给定表 <code>customer</code> ，里面保存了所有客户信息和他们的推荐人。</p>\n\n<pre>\n+------+------+-----------+\n| id   | name | referee_id|\n+------+------+-----------+\n|    1 | Will |      NULL |\n|    2 | Jane |      NULL |\n|    3 | Alex |         2 |\n|    4 | Bill |      NULL |\n|    5 | Zack |         1 |\n|    6 | Mark |         2 |\n+------+------+-----------+\n</pre>\n\n<p>写一个查询语句，返回一个客户列表，列表中客户的推荐人的编号都 <strong>不是 </strong>2。</p>\n\n<p>对于上面的示例数据，结果为：</p>\n\n<pre>\n+------+\n| name |\n+------+\n| Will |\n| Jane |\n| Bill |\n| Zack |\n+------+\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 5852016年的投资",
        "hardRate": "MEDIUM",
        "passRate": "47.62%",
        "problemsUrl": "https://leetcode.cn/problems/investments-in-2016/",
        "solutionsUrl": "https://leetcode.cn/problems/investments-in-2016/solution",
        "problemsDesc": "<p><code>Insurance</code> 表：</p>\n\n<div class=\"original__bRMd\">\n<div>\n<pre>\n+-------------+-------+\n| Column Name | Type  |\n+-------------+-------+\n| pid         | int   |\n| tiv_2015    | float |\n| tiv_2016    | float |\n| lat         | float |\n| lon         | float |\n+-------------+-------+\npid 是这张表的主键。\n表中的每一行都包含一条保险信息，其中：\npid 是投保人的投保编号。\ntiv_2015 是该投保人在 2015 年的总投保金额，tiv_2016 是该投保人在 2016 年的总投保金额。\nlat 是投保人所在城市的纬度。题目数据确保 lat 不为空。\nlon 是投保人所在城市的经度。题目数据确保 lon 不为空。</pre>\n\n<p>&nbsp;</p>\n\n<p>请你编写一个 SQL 查询，报告 2016 年 (<code>tiv_2016</code>) 所有满足下述条件的投保人的投保金额之和：</p>\n\n<ul>\n\t<li>他在 2015 年的投保额&nbsp;(<code>tiv_2015</code>) 至少跟一个其他投保人在 2015 年的投保额相同。</li>\n\t<li>他所在的城市必须与其他投保人都不同（也就是说&nbsp;(<code>lat, lon</code>) 不能跟其他任何一个投保人完全相同）。</li>\n</ul>\n\n<p><code>tiv_2016</code> 四舍五入的 <strong>两位小数</strong> 。</p>\n\n<p>查询结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nInsurance 表：\n+-----+----------+----------+-----+-----+\n| pid | tiv_2015 | tiv_2016 | lat | lon |\n+-----+----------+----------+-----+-----+\n| 1   | 10       | 5        | 10  | 10  |\n| 2   | 20       | 20       | 20  | 20  |\n| 3   | 10       | 30       | 20  | 20  |\n| 4   | 10       | 40       | 40  | 40  |\n+-----+----------+----------+-----+-----+\n<strong>输出：</strong>\n+----------+\n| tiv_2016 |\n+----------+\n| 45.00    |\n+----------+\n<strong>解释：\n</strong>表中的第一条记录和最后一条记录都满足两个条件。\ntiv_2015 值为 10 与第三条和第四条记录相同，且其位置是唯一的。\n第二条记录不符合任何一个条件。其 tiv_2015 与其他投保人不同，并且位置与第三条记录相同，这也导致了第三条记录不符合题目要求。\n因此，结果是第一条记录和最后一条记录的 tiv_2016 之和，即 45 。</pre>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 586订单最多的客户",
        "hardRate": "EASY",
        "passRate": "69.47%",
        "problemsUrl": "https://leetcode.cn/problems/customer-placing-the-largest-number-of-orders/",
        "solutionsUrl": "https://leetcode.cn/problems/customer-placing-the-largest-number-of-orders/solution",
        "problemsDesc": "<p>表:&nbsp;<code>Orders</code></p>\n\n<pre>\n+-----------------+----------+\n| Column Name     | Type     |\n+-----------------+----------+\n| order_number    | int      |\n| customer_number | int      |\n+-----------------+----------+\nOrder_number是该表的主键。\n此表包含关于订单ID和客户ID的信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个SQL查询，为下了 <strong>最多订单</strong> 的客户查找 <code>customer_number</code> 。</p>\n\n<p>测试用例生成后， <strong>恰好有一个客户</strong> 比任何其他客户下了更多的订单。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nOrders 表:\n+--------------+-----------------+\n| order_number | customer_number |\n+--------------+-----------------+\n| 1            | 1               |\n| 2            | 2               |\n| 3            | 3               |\n| 4            | 3               |\n+--------------+-----------------+\n<strong>输出:</strong> \n+-----------------+\n| customer_number |\n+-----------------+\n| 3               |\n+-----------------+\n<strong>解释:</strong> \ncustomer_number 为 '3' 的顾客有两个订单，比顾客 '1' 或者 '2' 都要多，因为他们只有一个订单。\n所以结果是该顾客的 customer_number ，也就是 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong> 如果有多位顾客订单数并列最多，你能找到他们所有的 <code>customer_number</code> 吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 587安装栅栏",
        "hardRate": "HARD",
        "passRate": "60.87%",
        "problemsUrl": "https://leetcode.cn/problems/erect-the-fence/",
        "solutionsUrl": "https://leetcode.cn/problems/erect-the-fence/solution",
        "problemsDesc": "<p>给定一个数组 <code>trees</code>，其中 <code>trees[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示树在花园中的位置。</p>\n\n<p>你被要求用最短长度的绳子把整个花园围起来，因为绳子很贵。只有把&nbsp;<strong>所有的树都围起来</strong>，花园才围得很好。</p>\n\n<p>返回<em>恰好位于围栏周边的树木的坐标</em>。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/24/erect2-plane.jpg\" style=\"width: 400px;\" /></p>\n\n<pre>\n<strong>输入:</strong> points = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\n<strong>输出:</strong> [[1,1],[2,0],[3,3],[2,4],[4,2]]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/24/erect1-plane.jpg\" style=\"height: 393px; width: 400px;\" /></p>\n\n<pre>\n<strong>输入:</strong> points = [[1,2],[2,2],[4,2]]\n<strong>输出:</strong> [[4,2],[2,2],[1,2]]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>注意:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= points.length &lt;= 3000</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= 100</code></li>\n\t<li>\n\t<p data-group=\"1-1\">所有给定的点都是&nbsp;<strong>唯一&nbsp;</strong>的。</p>\n\t</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 588设计内存文件系统",
        "hardRate": "HARD",
        "passRate": "43.47%",
        "problemsUrl": "https://leetcode.cn/problems/design-in-memory-file-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-in-memory-file-system/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 589N 叉树的前序遍历",
        "hardRate": "EASY",
        "passRate": "76.56%",
        "problemsUrl": "https://leetcode.cn/problems/n-ary-tree-preorder-traversal/",
        "solutionsUrl": "https://leetcode.cn/problems/n-ary-tree-preorder-traversal/solution",
        "problemsDesc": "<p>给定一个 n&nbsp;叉树的根节点 <meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;，返回 <em>其节点值的<strong> 前序遍历</strong></em> 。</p>\n\n<p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p>\n\n<p><br />\n<strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"height: 193px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,null,3,2,4,null,5,6]\n<strong>输出：</strong>[1,3,5,6,2,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"height: 272px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>输出：</strong>[1,2,3,6,7,11,14,4,8,12,5,9,13,10]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>节点总数在范围<meta charset=\"UTF-8\" />&nbsp;<code>[0, 10<sup>4</sup>]</code>内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>n 叉树的高度小于或等于 <code>1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>递归法很简单，你可以使用迭代法完成此题吗?</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 590N 叉树的后序遍历",
        "hardRate": "EASY",
        "passRate": "78.68%",
        "problemsUrl": "https://leetcode.cn/problems/n-ary-tree-postorder-traversal/",
        "solutionsUrl": "https://leetcode.cn/problems/n-ary-tree-postorder-traversal/solution",
        "problemsDesc": "<p>给定一个 n&nbsp;叉树的根节点<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;，返回 <em>其节点值的<strong> 后序遍历</strong></em> 。</p>\n\n<p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"height: 193px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,null,3,2,4,null,5,6]\n<strong>输出：</strong>[5,6,3,2,4,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"height: 269px; width: 296px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>输出：</strong>[2,6,14,11,7,3,12,8,4,13,9,10,5,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>节点总数在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>n 叉树的高度小于或等于 <code>1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>递归法很简单，你可以使用迭代法完成此题吗?</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 591标签验证器",
        "hardRate": "HARD",
        "passRate": "52.07%",
        "problemsUrl": "https://leetcode.cn/problems/tag-validator/",
        "solutionsUrl": "https://leetcode.cn/problems/tag-validator/solution",
        "problemsDesc": "<p>给定一个表示代码片段的字符串，你需要实现一个验证器来解析这段代码，并返回它是否合法。合法的代码片段需要遵守以下的所有规则：</p>\n\n<ol>\n\t<li>代码必须被<strong>合法的闭合标签</strong>包围。否则，代码是无效的。</li>\n\t<li><strong>闭合标签</strong>（不一定合法）要严格符合格式：<code>&lt;TAG_NAME&gt;TAG_CONTENT&lt;/TAG_NAME&gt;</code>。其中，<code>&lt;TAG_NAME&gt;</code>是起始标签，<code>&lt;/TAG_NAME&gt;</code>是结束标签。起始和结束标签中的 TAG_NAME 应当相同。当且仅当&nbsp;TAG_NAME 和 TAG_CONTENT 都是合法的，闭合标签才是<strong>合法的</strong>。</li>\n\t<li><strong>合法的</strong>&nbsp;<code>TAG_NAME</code>&nbsp;仅含有<strong>大写字母</strong>，长度在范围 [1,9] 之间。否则，该&nbsp;<code>TAG_NAME</code>&nbsp;是<strong>不合法的</strong>。</li>\n\t<li><strong>合法的</strong>&nbsp;<code>TAG_CONTENT</code>&nbsp;可以包含其他<strong>合法的闭合标签</strong>，<strong>cdata</strong>&nbsp;（请参考规则7）和任意字符（注意参考规则1）<strong>除了</strong>不匹配的<code>&lt;</code>、不匹配的起始和结束标签、不匹配的或带有不合法 TAG_NAME 的闭合标签。否则，<code>TAG_CONTENT</code>&nbsp;是<strong>不合法的</strong>。</li>\n\t<li>一个起始标签，如果没有具有相同&nbsp;TAG_NAME 的结束标签与之匹配，是不合法的。反之亦然。不过，你也需要考虑标签嵌套的问题。</li>\n\t<li>一个<code>&lt;</code>，如果你找不到一个后续的<code>&gt;</code>与之匹配，是不合法的。并且当你找到一个<code>&lt;</code>或<code>&lt;/</code>时，所有直到下一个<code>&gt;</code>的前的字符，都应当被解析为&nbsp;TAG_NAME（不一定合法）。</li>\n\t<li>cdata 有如下格式：<code>&lt;![CDATA[CDATA_CONTENT]]&gt;</code>。<code>CDATA_CONTENT</code>&nbsp;的范围被定义成&nbsp;<code>&lt;![CDATA[</code>&nbsp;和<strong>后续的第一个</strong>&nbsp;<code>]]&gt;</code>之间的字符。</li>\n\t<li><code>CDATA_CONTENT</code>&nbsp;可以包含<strong>任意字符</strong>。cdata 的功能是阻止验证器解析<code>CDATA_CONTENT</code>，所以即使其中有一些字符可以被解析为标签（无论合法还是不合法），也应该将它们视为<strong>常规字符</strong>。</li>\n</ol>\n\n<p><strong>合法代码的例子:</strong></p>\n\n<pre>\n<strong>输入:</strong> &quot;&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt;]]&gt;&lt;/DIV&gt;&quot;\n\n<strong>输出:</strong> True\n\n<strong>解释:</strong> \n\n代码被包含在了闭合的标签内： &lt;DIV&gt; 和 &lt;/DIV&gt; 。\n\nTAG_NAME 是合法的，TAG_CONTENT 包含了一些字符和 cdata 。 \n\n即使 CDATA_CONTENT 含有不匹配的起始标签和不合法的 TAG_NAME，它应该被视为普通的文本，而不是标签。\n\n所以 TAG_CONTENT 是合法的，因此代码是合法的。最终返回True。\n\n\n<strong>输入:</strong> &quot;&lt;DIV&gt;&gt;&gt;  ![cdata[]] &lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&gt;]&lt;/DIV&gt;&quot;\n\n<strong>输出:</strong> True\n\n<strong>解释:</strong>\n\n我们首先将代码分割为： start_tag|tag_content|end_tag 。\n\nstart_tag -&gt; <strong>&quot;&lt;DIV&gt;&quot;</strong>\n\nend_tag -&gt; <strong>&quot;&lt;/DIV&gt;&quot;</strong>\n\ntag_content 也可被分割为： text1|cdata|text2 。\n\ntext1 -&gt; <strong>&quot;&gt;&gt;  ![cdata[]] &quot;</strong>\n\ncdata -&gt; <strong>&quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;&quot;</strong> ，其中 CDATA_CONTENT 为 <strong>&quot;&lt;div&gt;]&gt;&quot;</strong>\n\ntext2 -&gt; <strong>&quot;]]&gt;&gt;]&quot;</strong>\n\n\nstart_tag <strong>不</strong>是 <strong>&quot;&lt;DIV&gt;&gt;&gt;&quot;</strong> 的原因参照规则 6 。\ncdata <strong>不</strong>是 <strong>&quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&quot;</strong> 的原因参照规则 7 。\n</pre>\n\n<p><strong>不合法代码的例子:</strong></p>\n\n<pre>\n<strong>输入:</strong> &quot;&lt;A&gt;  &lt;B&gt; &lt;/A&gt;   &lt;/B&gt;&quot;\n<strong>输出:</strong> False\n<strong>解释:</strong> 不合法。如果 &quot;&lt;A&gt;&quot; 是闭合的，那么 &quot;&lt;B&gt;&quot; 一定是不匹配的，反之亦然。\n\n<strong>输入:</strong> &quot;&lt;DIV&gt;  div tag is not closed  &lt;DIV&gt;&quot;\n<strong>输出:</strong> False\n\n<strong>输入:</strong> &quot;&lt;DIV&gt;  unmatched &lt;  &lt;/DIV&gt;&quot;\n<strong>输出:</strong> False\n\n<strong>输入:</strong> &quot;&lt;DIV&gt; closed tags with invalid tag name  &lt;b&gt;123&lt;/b&gt; &lt;/DIV&gt;&quot;\n<strong>输出:</strong> False\n\n<strong>输入:</strong> &quot;&lt;DIV&gt; unmatched tags with invalid tag name  &lt;/1234567890&gt; and &lt;CDATA[[]]&gt;  &lt;/DIV&gt;&quot;\n<strong>输出:</strong> False\n\n<strong>输入:</strong> &quot;&lt;DIV&gt;  unmatched start tag &lt;B&gt;  and unmatched end tag &lt;/C&gt;  &lt;/DIV&gt;&quot;\n<strong>输出:</strong> False\n</pre>\n\n<p><strong>注意:</strong></p>\n\n<ol>\n\t<li>为简明起见，你可以假设输入的代码（包括提到的<strong>任意字符</strong>）只包含<code>数字</code>, <font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"background-color:#f9f2f4; font-size:12.6px\">字母</span></font>, <code>&#39;&lt;&#39;</code>,<code>&#39;&gt;&#39;</code>,<code>&#39;/&#39;</code>,<code>&#39;!&#39;</code>,<code>&#39;[&#39;</code>,<code>&#39;]&#39;</code>和<code>&#39; &#39;</code>。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 592分数加减运算",
        "hardRate": "MEDIUM",
        "passRate": "59.79%",
        "problemsUrl": "https://leetcode.cn/problems/fraction-addition-and-subtraction/",
        "solutionsUrl": "https://leetcode.cn/problems/fraction-addition-and-subtraction/solution",
        "problemsDesc": "<p>给定一个表示分数加减运算的字符串&nbsp;<code>expression</code>&nbsp;，你需要返回一个字符串形式的计算结果。&nbsp;</p>\n\n<p>这个结果应该是不可约分的分数，即<a href=\"https://baike.baidu.com/item/%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0\" target=\"_blank\">最简分数</a>。&nbsp;如果最终结果是一个整数，例如&nbsp;<code>2</code>，你需要将它转换成分数形式，其分母为&nbsp;<code>1</code>。所以在上述例子中, <code>2</code>&nbsp;应该被转换为&nbsp;<code>2/1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;<code>expression</code>&nbsp;= \"-1/2+1/2\"\n<strong>输出:</strong> \"0/1\"\n</pre>\n\n<p><strong>&nbsp;示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;<code>expression</code>&nbsp;= \"-1/2+1/2+1/3\"\n<strong>输出:</strong> \"1/3\"\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;<code>expression</code>&nbsp;= \"1/3-1/2\"\n<strong>输出:</strong> \"-1/6\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>输入和输出字符串只包含&nbsp;<code>'0'</code> 到&nbsp;<code>'9'</code>&nbsp;的数字，以及&nbsp;<code>'/'</code>, <code>'+'</code> 和&nbsp;<code>'-'</code>。&nbsp;</li>\n\t<li>输入和输出分数格式均为&nbsp;<code>±分子/分母</code>。如果输入的第一个分数或者输出的分数是正数，则&nbsp;<code>'+'</code>&nbsp;会被省略掉。</li>\n\t<li>输入只包含合法的<strong>最简分数</strong>，每个分数的<strong>分子</strong>与<strong>分母</strong>的范围是&nbsp;&nbsp;[1,10]。&nbsp;如果分母是1，意味着这个分数实际上是一个整数。</li>\n\t<li>输入的分数个数范围是 [1,10]。</li>\n\t<li><strong>最终结果</strong>的分子与分母保证是 32 位整数范围内的有效整数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 593有效的正方形",
        "hardRate": "MEDIUM",
        "passRate": "47.11%",
        "problemsUrl": "https://leetcode.cn/problems/valid-square/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-square/solution",
        "problemsDesc": "<p>给定2D空间中四个点的坐标&nbsp;<code>p1</code>,&nbsp;<code>p2</code>,&nbsp;<code>p3</code>&nbsp;和&nbsp;<code>p4</code>，如果这四个点构成一个正方形，则返回 <code>true</code> 。</p>\n\n<p>点的坐标&nbsp;<code>p<sub>i</sub></code> 表示为 <code>[xi, yi]</code> 。 <code>输入没有任何顺序</code> 。</p>\n\n<p>一个 <strong>有效的正方形</strong> 有四条等边和四个等角(90度角)。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]\n<strong>输出:</strong> True\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入：</strong>p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]\n<b>输出：</b>false\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<b>输入：</b>p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]\n<b>输出：</b>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>p1.length == p2.length == p3.length == p4.length == 2</code></li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 594最长和谐子序列",
        "hardRate": "EASY",
        "passRate": "56.12%",
        "problemsUrl": "https://leetcode.cn/problems/longest-harmonious-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-harmonious-subsequence/solution",
        "problemsDesc": "<p>和谐数组是指一个数组里元素的最大值和最小值之间的差别 <strong>正好是 <code>1</code></strong> 。</p>\n\n<p>现在，给你一个整数数组 <code>nums</code> ，请你在所有可能的子序列中找到最长的和谐子序列的长度。</p>\n\n<p>数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,2,2,5,2,3,7]\n<strong>输出：</strong>5\n<strong>解释：</strong>最长的和谐子序列是 [3,2,2,2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,1]\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 2 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 595大的国家",
        "hardRate": "EASY",
        "passRate": "66.82%",
        "problemsUrl": "https://leetcode.cn/problems/big-countries/",
        "solutionsUrl": "https://leetcode.cn/problems/big-countries/solution",
        "problemsDesc": "<p><code>World</code> 表：</p>\n\n<div class=\"top-view__1vxA\">\n<div class=\"original__bRMd\">\n<div>\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| name        | varchar |\n| continent   | varchar |\n| area        | int     |\n| population  | int     |\n| gdp         | bigint  |\n+-------------+---------+\nname 是这张表的主键。\n这张表的每一行提供：国家名称、所属大陆、面积、人口和 GDP 值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>如果一个国家满足下述两个条件之一，则认为该国是 <strong>大国</strong> ：</p>\n\n<ul>\n\t<li>面积至少为 300 万平方公里（即，<code>3000000 km<sup>2</sup></code>），或者</li>\n\t<li>人口至少为 2500 万（即 <code>25000000</code>）</li>\n</ul>\n\n<p>编写一个 SQL 查询以报告 <strong>大国</strong> 的国家名称、人口和面积。</p>\n\n<p>按 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nWorld 表：\n+-------------+-----------+---------+------------+--------------+\n| name        | continent | area    | population | gdp          |\n+-------------+-----------+---------+------------+--------------+\n| Afghanistan | Asia      | 652230  | 25500100   | 20343000000  |\n| Albania     | Europe    | 28748   | 2831741    | 12960000000  |\n| Algeria     | Africa    | 2381741 | 37100000   | 188681000000 |\n| Andorra     | Europe    | 468     | 78115      | 3712000000   |\n| Angola      | Africa    | 1246700 | 20609294   | 100990000000 |\n+-------------+-----------+---------+------------+--------------+\n<strong>输出：</strong>\n+-------------+------------+---------+\n| name        | population | area    |\n+-------------+------------+---------+\n| Afghanistan | 25500100   | 652230  |\n| Algeria     | 37100000   | 2381741 |\n+-------------+------------+---------+\n</pre>\n</div>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 596超过5名学生的课",
        "hardRate": "EASY",
        "passRate": "50.76%",
        "problemsUrl": "https://leetcode.cn/problems/classes-more-than-5-students/",
        "solutionsUrl": "https://leetcode.cn/problems/classes-more-than-5-students/solution",
        "problemsDesc": "<p>表:&nbsp;<code>Courses</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| student     | varchar |\n| class       | varchar |\n+-------------+---------+\n(student, class)是该表的主键列。\n该表的每一行表示学生的名字和他们注册的班级。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个SQL查询来报告 <strong>至少有5个学生</strong> 的所有班级。</p>\n\n<p>以 <strong>任意顺序 </strong>返回结果表。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nCourses table:\n+---------+----------+\n| student | class    |\n+---------+----------+\n| A       | Math     |\n| B       | English  |\n| C       | Math     |\n| D       | Biology  |\n| E       | Math     |\n| F       | Computer |\n| G       | Math     |\n| H       | Math     |\n| I       | Math     |\n+---------+----------+\n<strong>输出:</strong> \n+---------+ \n| class &nbsp; | \n+---------+ \n| Math &nbsp; &nbsp;| \n+---------+\n<strong>解释: </strong>\n-数学课有6个学生，所以我们包括它。\n-英语课有1名学生，所以我们不包括它。\n-生物课有1名学生，所以我们不包括它。\n-计算机课有1个学生，所以我们不包括它。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 597好友申请 I：总体通过率",
        "hardRate": "EASY",
        "passRate": "43.20%",
        "problemsUrl": "https://leetcode.cn/problems/friend-requests-i-overall-acceptance-rate/",
        "solutionsUrl": "https://leetcode.cn/problems/friend-requests-i-overall-acceptance-rate/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 598范围求和 II",
        "hardRate": "EASY",
        "passRate": "57.76%",
        "problemsUrl": "https://leetcode.cn/problems/range-addition-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/range-addition-ii/solution",
        "problemsDesc": "<p>给你一个 <code>m x&nbsp;n</code> 的矩阵&nbsp;<code>M</code><strong>&nbsp;</strong>，初始化时所有的 <code>0</code> 和一个操作数组 <code>op</code> ，其中 <code>ops[i] = [ai, bi]</code> 意味着当所有的 <code>0 &lt;= x &lt; ai</code> 和 <code>0 &lt;= y &lt; bi</code> 时， <code>M[x][y]</code> 应该加 1。</p>\n\n<p>在&nbsp;<em>执行完所有操作后</em>&nbsp;，计算并返回&nbsp;<em>矩阵中最大整数的个数</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/02/ex1.jpg\" style=\"height: 176px; width: 750px;\" /></p>\n\n<pre>\n<strong>输入:</strong> m = 3, n = 3，ops = [[2,2],[3,3]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]\n<strong>输出:</strong> 4\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> m = 3, n = 3, ops = []\n<strong>输出:</strong> 9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 4 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= ops.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>ops[i].length == 2</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>&nbsp;&lt;= m</code></li>\n\t<li><code>1 &lt;= b<sub>i</sub>&nbsp;&lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 599两个列表的最小索引总和",
        "hardRate": "EASY",
        "passRate": "56.67%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-index-sum-of-two-lists/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-index-sum-of-two-lists/solution",
        "problemsDesc": "<p>假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。</p>\n\n<p>你需要帮助他们用<strong>最少的索引和</strong>找出他们<strong>共同喜爱的餐厅</strong>。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>list1 = [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]，list2 = [\"Piatti\", \"The Grill at Torrey Pines\", \"Hungry Hunter Steakhouse\", \"Shogun\"]\n<strong>输出:</strong> [\"Shogun\"]\n<strong>解释:</strong> 他们唯一共同喜爱的餐厅是“Shogun”。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong>list1 = [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]，list2 = [\"KFC\", \"Shogun\", \"Burger King\"]\n<strong>输出:</strong> [\"Shogun\"]\n<strong>解释:</strong> 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= list1.length, list2.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= list1[i].length, list2[i].length &lt;= 30</code>&nbsp;</li>\n\t<li><code>list1[i]</code> 和 <code>list2[i]</code> 由空格<meta charset=\"UTF-8\" />&nbsp;<code>' '</code>&nbsp;和英文字母组成。</li>\n\t<li><code>list1</code> 的所有字符串都是 <strong>唯一</strong> 的。</li>\n\t<li><code>list2</code> 中的所有字符串都是 <strong>唯一</strong> 的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 600不含连续1的非负整数",
        "hardRate": "HARD",
        "passRate": "49.49%",
        "problemsUrl": "https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/",
        "solutionsUrl": "https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/solution",
        "problemsDesc": "<p>给定一个正整数 <code>n</code> ，请你统计在&nbsp;<code>[0, n]</code> 范围的非负整数中，有多少个整数的二进制表示中不存在 <strong>连续的 1 </strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 5\n<strong>输出:</strong> 5\n<strong>解释:</strong> \n下面列出范围在 [0, 5] 的非负整数与其对应的二进制表示：\n0 : 0\n1 : 1\n2 : 10\n3 : 11\n4 : 100\n5 : 101\n其中，只有整数 3 违反规则（有两个连续的 1 ），其他 5 个满足规则。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 1\n<strong>输出:</strong> 2\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 2\n<strong>输出:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 601体育馆的人流量",
        "hardRate": "HARD",
        "passRate": "48.02%",
        "problemsUrl": "https://leetcode.cn/problems/human-traffic-of-stadium/",
        "solutionsUrl": "https://leetcode.cn/problems/human-traffic-of-stadium/solution",
        "problemsDesc": "表：<code>Stadium</code>\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| visit_date    | date    |\n| people        | int     |\n+---------------+---------+\nvisit_date 是表的主键\n每日人流量信息被记录在这三列信息中：<strong>序号</strong> (id)、<strong>日期</strong> (visit_date)、&nbsp;<strong>人流量</strong> (people)\n每天只有一行记录，日期随着 id 的增加而增加\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个 SQL 查询以找出每行的人数大于或等于 <code>100</code> 且 <code>id</code> 连续的三行或更多行记录。</p>\n\n<p>返回按 <code>visit_date</code> <strong>升序排列</strong> 的结果表。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<code><strong>输入：</strong>\nStadium</code> 表:\n+------+------------+-----------+\n| id   | visit_date | people    |\n+------+------------+-----------+\n| 1    | 2017-01-01 | 10        |\n| 2    | 2017-01-02 | 109       |\n| 3    | 2017-01-03 | 150       |\n| 4    | 2017-01-04 | 99        |\n| 5    | 2017-01-05 | 145       |\n| 6    | 2017-01-06 | 1455      |\n| 7    | 2017-01-07 | 199       |\n| 8    | 2017-01-09 | 188       |\n+------+------------+-----------+\n<strong>输出：</strong>\n+------+------------+-----------+\n| id   | visit_date | people    |\n+------+------------+-----------+\n| 5    | 2017-01-05 | 145       |\n| 6    | 2017-01-06 | 1455      |\n| 7    | 2017-01-07 | 199       |\n| 8    | 2017-01-09 | 188       |\n+------+------------+-----------+\n<strong>解释：\nid</strong> 为 5、6、7、8 的四行 id 连续，并且每行都有 &gt;= 100 的人数记录。\n请注意，即使第 7 行和第 8 行的 visit_date 不是连续的，输出也应当包含第 8 行，因为我们只需要考虑 id 连续的记录。\n不输出 id 为 2 和 3 的行，因为至少需要三条 id 连续的记录。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 602好友申请 II ：谁有最多的好友",
        "hardRate": "MEDIUM",
        "passRate": "61.08%",
        "problemsUrl": "https://leetcode.cn/problems/friend-requests-ii-who-has-the-most-friends/",
        "solutionsUrl": "https://leetcode.cn/problems/friend-requests-ii-who-has-the-most-friends/solution",
        "problemsDesc": "<p>在 Facebook 或者 Twitter 这样的社交应用中，人们经常会发好友申请也会收到其他人的好友申请。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p><code>RequestAccepted</code> 表：</p>\n\n<pre>\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| requester_id   | int     |\n| accepter_id    | int     |\n| accept_date    | date    |\n+----------------+---------+\n(requester_id, accepter_id) 是这张表的主键。\n这张表包含发送好友请求的人的 ID ，接收好友请求的人的 ID ，以及好友请求通过的日期。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一个查询语句，找出拥有最多的好友的人和他拥有的好友数目。</p>\n\n<p>生成的测试用例保证拥有最多好友数目的只有 1 个人。</p>\n\n<p>查询结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nRequestAccepted 表：\n+--------------+-------------+-------------+\n| requester_id | accepter_id | accept_date |\n+--------------+-------------+-------------+\n| 1            | 2           | 2016/06/03  |\n| 1            | 3           | 2016/06/08  |\n| 2            | 3           | 2016/06/08  |\n| 3            | 4           | 2016/06/09  |\n+--------------+-------------+-------------+\n<strong>输出：</strong>\n+----+-----+\n| id | num |\n+----+-----+\n| 3  | 3   |\n+----+-----+\n<strong>解释：</strong>\n编号为 3 的人是编号为 1 ，2 和 4 的人的好友，所以他总共有 3 个好友，比其他人都多。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>在真实世界里，可能会有多个人拥有好友数相同且最多，你能找到所有这些人吗？</p>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 603连续空余座位",
        "hardRate": "EASY",
        "passRate": "64.03%",
        "problemsUrl": "https://leetcode.cn/problems/consecutive-available-seats/",
        "solutionsUrl": "https://leetcode.cn/problems/consecutive-available-seats/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 604迭代压缩字符串",
        "hardRate": "EASY",
        "passRate": "38.81%",
        "problemsUrl": "https://leetcode.cn/problems/design-compressed-string-iterator/",
        "solutionsUrl": "https://leetcode.cn/problems/design-compressed-string-iterator/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 605种花问题",
        "hardRate": "EASY",
        "passRate": "32.29%",
        "problemsUrl": "https://leetcode.cn/problems/can-place-flowers/",
        "solutionsUrl": "https://leetcode.cn/problems/can-place-flowers/solution",
        "problemsDesc": "<p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>\n\n<p>给你一个整数数组&nbsp;<code>flowerbed</code> 表示花坛，由若干 <code>0</code> 和 <code>1</code> 组成，其中 <code>0</code> 表示没种植花，<code>1</code> 表示种植了花。另有一个数&nbsp;<code>n</code><strong> </strong>，能否在不打破种植规则的情况下种入&nbsp;<code>n</code><strong>&nbsp;</strong>朵花？能则返回 <code>true</code> ，不能则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>flowerbed = [1,0,0,0,1], n = 1\n<strong>输出：</strong>true\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>flowerbed = [1,0,0,0,1], n = 2\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= flowerbed.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>flowerbed[i]</code> 为 <code>0</code> 或 <code>1</code></li>\n\t<li><code>flowerbed</code> 中不存在相邻的两朵花</li>\n\t<li><code>0 &lt;= n &lt;= flowerbed.length</code></li>\n</ul>",
        "isPlus": false
    },
    {
        "problemsName": " 606根据二叉树创建字符串",
        "hardRate": "EASY",
        "passRate": "62.20%",
        "problemsUrl": "https://leetcode.cn/problems/construct-string-from-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-string-from-binary-tree/solution",
        "problemsDesc": "<p>给你二叉树的根节点 <code>root</code> ，请你采用前序遍历的方式，将二叉树转化为一个由括号和整数组成的字符串，返回构造出的字符串。</p>\n\n<p>空节点使用一对空括号对 <code>\"()\"</code> 表示，转化后需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/cons1-tree.jpg\" style=\"width: 292px; height: 301px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,4]\n<strong>输出：</strong>\"1(2(4))(3)\"\n<strong>解释：</strong>初步转化后得到 \"1(2(4)())(3()())\" ，但省略所有不必要的空括号对后，字符串应该是\"1(2(4))(3)\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/cons2-tree.jpg\" style=\"width: 207px; height: 293px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,null,4]\n<strong>输出：</strong>\"1(2()(4))(3)\"\n<strong>解释：</strong>和第一个示例类似，但是无法省略第一个空括号对，否则会破坏输入与输出一一映射的关系。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目范围是 <code>[1, 10<sup>4</sup>]</code></li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 607销售员",
        "hardRate": "EASY",
        "passRate": "68.18%",
        "problemsUrl": "https://leetcode.cn/problems/sales-person/",
        "solutionsUrl": "https://leetcode.cn/problems/sales-person/solution",
        "problemsDesc": "<p>表:&nbsp;<code>SalesPerson</code></p>\n\n<pre>\n+-----------------+---------+\n| Column Name     | Type    |\n+-----------------+---------+\n| sales_id        | int     |\n| name            | varchar |\n| salary          | int     |\n| commission_rate | int     |\n| hire_date       | date    |\n+-----------------+---------+\nsales_id 是该表的主键列。\n该表的每一行都显示了销售人员的姓名和 ID ，以及他们的工资、佣金率和雇佣日期。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>表:&nbsp;<code>Company</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| com_id      | int     |\n| name        | varchar |\n| city        | varchar |\n+-------------+---------+\ncom_id 是该表的主键列。\n该表的每一行都表示公司的名称和 ID ，以及公司所在的城市。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>表:&nbsp;<code>Orders</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| order_id    | int  |\n| order_date  | date |\n| com_id      | int  |\n| sales_id    | int  |\n| amount      | int  |\n+-------------+------+\norder_id 是该表的主键列。\ncom_id 是 Company 表中 com_id 的外键。\nsales_id 是来自销售员表 sales_id 的外键。\n该表的每一行包含一个订单的信息。这包括公司的 ID 、销售人员的 ID 、订单日期和支付的金额。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个SQL查询，报告没有任何与名为 <strong>“RED”</strong> 的公司相关的订单的所有销售人员的姓名。</p>\n\n<p>以 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nSalesPerson 表:\n+----------+------+--------+-----------------+------------+\n| sales_id | name | salary | commission_rate | hire_date  |\n+----------+------+--------+-----------------+------------+\n| 1        | John | 100000 | 6               | 4/1/2006   |\n| 2        | Amy  | 12000  | 5               | 5/1/2010   |\n| 3        | Mark | 65000  | 12              | 12/25/2008 |\n| 4        | Pam  | 25000  | 25              | 1/1/2005   |\n| 5        | Alex | 5000   | 10              | 2/3/2007   |\n+----------+------+--------+-----------------+------------+\nCompany 表:\n+--------+--------+----------+\n| com_id | name   | city     |\n+--------+--------+----------+\n| 1      | RED    | Boston   |\n| 2      | ORANGE | New York |\n| 3      | YELLOW | Boston   |\n| 4      | GREEN  | Austin   |\n+--------+--------+----------+\nOrders 表:\n+----------+------------+--------+----------+--------+\n| order_id | order_date | com_id | sales_id | amount |\n+----------+------------+--------+----------+--------+\n| 1        | 1/1/2014   | 3      | 4        | 10000  |\n| 2        | 2/1/2014   | 4      | 5        | 5000   |\n| 3        | 3/1/2014   | 1      | 1        | 50000  |\n| 4        | 4/1/2014   | 1      | 4        | 25000  |\n+----------+------------+--------+----------+--------+\n<strong>输出：</strong>\n+------+\n| name |\n+------+\n| Amy  |\n| Mark |\n| Alex |\n+------+\n<strong>解释：</strong>\n根据表&nbsp;<code>orders</code>&nbsp;中的订单 '3' 和 '4' ，容易看出只有 'John' 和 'Pam' 两个销售员曾经向公司 'RED' 销售过。\n所以我们需要输出表&nbsp;<code>salesperson</code>&nbsp;中所有其他人的名字。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 608树节点",
        "hardRate": "MEDIUM",
        "passRate": "61.05%",
        "problemsUrl": "https://leetcode.cn/problems/tree-node/",
        "solutionsUrl": "https://leetcode.cn/problems/tree-node/solution",
        "problemsDesc": "<p>给定一个表&nbsp;<code>tree</code>，<strong>id</strong> 是树节点的编号，&nbsp;<strong>p_id</strong>&nbsp;是它父节点的&nbsp;<strong>id 。</strong></p>\n\n<pre>+----+------+\n| id | p_id |\n+----+------+\n| 1  | null |\n| 2  | 1    |\n| 3  | 1    |\n| 4  | 2    |\n| 5  | 2    |\n+----+------+</pre>\n\n<p>树中每个节点属于以下三种类型之一：</p>\n\n<ul>\n\t<li>叶子：如果这个节点没有任何孩子节点。</li>\n\t<li>根：如果这个节点是整棵树的根，即没有父节点。</li>\n\t<li>内部节点：如果这个节点既不是叶子节点也不是根节点。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>写一个查询语句，输出所有节点的编号和节点的类型，并将结果按照节点编号排序。上面样例的结果为：</p>\n\n<p>&nbsp;</p>\n\n<pre>+----+------+\n| id | Type |\n+----+------+\n| 1  | Root |\n| 2  | Inner|\n| 3  | Leaf |\n| 4  | Leaf |\n| 5  | Leaf |\n+----+------+\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>解释</strong></p>\n\n<ul>\n\t<li>节点 &#39;1&#39; 是根节点，因为它的父节点是 NULL ，同时它有孩子节点 &#39;2&#39; 和 &#39;3&#39; 。</li>\n\t<li>节点 &#39;2&#39; 是内部节点，因为它有父节点 &#39;1&#39; ，也有孩子节点 &#39;4&#39; 和 &#39;5&#39; 。</li>\n\t<li>节点 &#39;3&#39;, &#39;4&#39; 和 &#39;5&#39; 都是叶子节点，因为它们都有父节点同时没有孩子节点。</li>\n\t<li>样例中树的形态如下：\n\t<p>&nbsp;</p>\n\n\t<pre>\t\t\t  1\n\t\t\t/   \\\n                      2       3\n                    /   \\\n                  4       5\n</pre>\n\n\t<p>&nbsp;</p>\n\t</li>\n</ul>\n\n<p><strong>注意</strong></p>\n\n<p>如果树中只有一个节点，你只需要输出它的根属性。</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 609在系统中查找重复文件",
        "hardRate": "MEDIUM",
        "passRate": "52.45%",
        "problemsUrl": "https://leetcode.cn/problems/find-duplicate-file-in-system/",
        "solutionsUrl": "https://leetcode.cn/problems/find-duplicate-file-in-system/solution",
        "problemsDesc": "<p>给你一个目录信息列表&nbsp;<code>paths</code> ，包括目录路径，以及该目录中的所有文件及其内容，请你按路径返回文件系统中的所有重复文件。答案可按 <strong>任意顺序</strong> 返回。</p>\n\n<p>一组重复的文件至少包括 <strong>两个 </strong>具有完全相同内容的文件。</p>\n\n<p><strong>输入 </strong>列表中的单个目录信息字符串的格式如下：</p>\n\n<ul>\n\t<li><code>\"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)\"</code></li>\n</ul>\n\n<p>这意味着，在目录&nbsp;<code>root/d1/d2/.../dm</code>&nbsp;下，有 <code>n</code> 个文件 ( <code>f1.txt</code>,&nbsp;<code>f2.txt</code>&nbsp;...&nbsp;<code>fn.txt</code> ) 的内容分别是 ( <code>f1_content</code>,&nbsp;<code>f2_content</code>&nbsp;...&nbsp;<code>fn_content</code> ) 。注意：<code>n &gt;= 1</code> 且 <code>m &gt;= 0</code> 。如果 <code>m = 0</code> ，则表示该目录是根目录。</p>\n\n<p><strong>输出 </strong>是由 <strong>重复文件路径组</strong> 构成的列表。其中每个组由所有具有相同内容文件的文件路径组成。文件路径是具有下列格式的字符串：</p>\n\n<ul>\n\t<li><code>\"directory_path/file_name.txt\"</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]\n<strong>输出：</strong>[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]\n<strong>输出：</strong>[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= paths.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= paths[i].length &lt;= 3000</code></li>\n\t<li><code>1 &lt;= sum(paths[i].length) &lt;= 5 * 10<sup>5</sup></code></li>\n\t<li><code>paths[i]</code> 由英文字母、数字、字符 <code>'/'</code>、<code>'.'</code>、<code>'('</code>、<code>')'</code> 和 <code>' '</code> 组成</li>\n\t<li>你可以假设在同一目录中没有任何文件或目录共享相同的名称。</li>\n\t<li>你可以假设每个给定的目录信息代表一个唯一的目录。目录路径和文件信息用单个空格分隔。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>假设您有一个真正的文件系统，您将如何搜索文件？广度搜索还是宽度搜索？</li>\n\t<li>如果文件内容非常大（GB级别），您将如何修改您的解决方案？</li>\n\t<li>如果每次只能读取 1 kb 的文件，您将如何修改解决方案？</li>\n\t<li>修改后的解决方案的时间复杂度是多少？其中最耗时的部分和消耗内存的部分是什么？如何优化？</li>\n\t<li>如何确保您发现的重复文件不是误报？</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 610判断三角形",
        "hardRate": "EASY",
        "passRate": "64.42%",
        "problemsUrl": "https://leetcode.cn/problems/triangle-judgement/",
        "solutionsUrl": "https://leetcode.cn/problems/triangle-judgement/solution",
        "problemsDesc": "<p>表:&nbsp;<code>Triangle</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| x           | int  |\n| y           | int  |\n| z           | int  |\n+-------------+------+\n(x, y, z)是该表的主键列。\n该表的每一行包含三个线段的长度。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一个SQL查询，每三个线段报告它们是否可以形成一个三角形。</p>\n\n<p>以&nbsp;<strong>任意顺序&nbsp;</strong>返回结果表。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nTriangle 表:\n+----+----+----+\n| x  | y  | z  |\n+----+----+----+\n| 13 | 15 | 30 |\n| 10 | 20 | 15 |\n+----+----+----+\n<strong>输出:</strong> \n+----+----+----+----------+\n| x  | y  | z  | triangle |\n+----+----+----+----------+\n| 13 | 15 | 30 | No       |\n| 10 | 20 | 15 | Yes      |\n+----+----+----+----------+</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 611有效三角形的个数",
        "hardRate": "MEDIUM",
        "passRate": "53.73%",
        "problemsUrl": "https://leetcode.cn/problems/valid-triangle-number/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-triangle-number/solution",
        "problemsDesc": "<p>给定一个包含非负整数的数组&nbsp;<code>nums</code> ，返回其中可以组成三角形三条边的三元组个数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [2,2,3,4]\n<strong>输出:</strong> 3\n<strong>解释:</strong>有效的组合是: \n2,3,4 (使用第一个 2)\n2,3,4 (使用第二个 2)\n2,2,3\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [4,2,3,4]\n<strong>输出:</strong> 4</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 612平面上的最近距离",
        "hardRate": "MEDIUM",
        "passRate": "64.97%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-distance-in-a-plane/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-distance-in-a-plane/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 613直线上的最近距离",
        "hardRate": "EASY",
        "passRate": "79.63%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-distance-in-a-line/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-distance-in-a-line/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 614二级关注者",
        "hardRate": "MEDIUM",
        "passRate": "37.27%",
        "problemsUrl": "https://leetcode.cn/problems/second-degree-follower/",
        "solutionsUrl": "https://leetcode.cn/problems/second-degree-follower/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 615平均工资：部门与公司比较",
        "hardRate": "HARD",
        "passRate": "42.33%",
        "problemsUrl": "https://leetcode.cn/problems/average-salary-departments-vs-company/",
        "solutionsUrl": "https://leetcode.cn/problems/average-salary-departments-vs-company/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 616给字符串添加加粗标签",
        "hardRate": "MEDIUM",
        "passRate": "49.31%",
        "problemsUrl": "https://leetcode.cn/problems/add-bold-tag-in-string/",
        "solutionsUrl": "https://leetcode.cn/problems/add-bold-tag-in-string/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 617合并二叉树",
        "hardRate": "EASY",
        "passRate": "79.15%",
        "problemsUrl": "https://leetcode.cn/problems/merge-two-binary-trees/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-two-binary-trees/solution",
        "problemsDesc": "<p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p>\n\n<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p>\n\n<p>返回合并后的二叉树。</p>\n\n<p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/05/merge.jpg\" style=\"height: 163px; width: 600px;\" />\n<pre>\n<strong>输入：</strong>root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\n<strong>输出：</strong>[3,4,5,5,4,null,7]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root1 = [1], root2 = [1,2]\n<strong>输出：</strong>[2,2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 618学生地理信息报告",
        "hardRate": "HARD",
        "passRate": "62.23%",
        "problemsUrl": "https://leetcode.cn/problems/students-report-by-geography/",
        "solutionsUrl": "https://leetcode.cn/problems/students-report-by-geography/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 619只出现一次的最大数字",
        "hardRate": "EASY",
        "passRate": "48.26%",
        "problemsUrl": "https://leetcode.cn/problems/biggest-single-number/",
        "solutionsUrl": "https://leetcode.cn/problems/biggest-single-number/solution",
        "problemsDesc": "<p><code>MyNumbers</code> 表：</p>\n\n<div class=\"original__bRMd\">\n<div>\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| num         | int  |\n+-------------+------+\n这张表没有主键。可能包含重复数字。\n这张表的每一行都含有一个整数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>单一数字</strong> 是在 <code>MyNumbers</code> 表中只出现一次的数字。</p>\n\n<p>请你编写一个 SQL 查询来报告最大的 <strong>单一数字</strong> 。如果不存在 <strong>单一数字</strong> ，查询需报告 <code>null</code> 。</p>\n\n<p>查询结果如下例所示。</p>\n<ptable> </ptable>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nMyNumbers 表：\n+-----+\n| num |\n+-----+\n| 8   |\n| 8   |\n| 3   |\n| 3   |\n| 1   |\n| 4   |\n| 5   |\n| 6   |\n+-----+\n<strong>输出：</strong>\n+-----+\n| num |\n+-----+\n| 6   |\n+-----+\n<strong>解释：</strong>单一数字有 1、4、5 和 6 。\n6 是最大的单一数字，返回 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nMyNumbers table:\n+-----+\n| num |\n+-----+\n| 8   |\n| 8   |\n| 7   |\n| 7   |\n| 3   |\n| 3   |\n| 3   |\n+-----+\n<strong>输出：</strong>\n+------+\n| num  |\n+------+\n| null |\n+------+\n<strong>解释：</strong>输入的表中不存在单一数字，所以返回 null 。\n</pre>\n</div>\n</div>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 620有趣的电影",
        "hardRate": "EASY",
        "passRate": "77.15%",
        "problemsUrl": "https://leetcode.cn/problems/not-boring-movies/",
        "solutionsUrl": "https://leetcode.cn/problems/not-boring-movies/solution",
        "problemsDesc": "<p>某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。</p>\n\n<p>作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为<strong>非</strong>&nbsp;<code>boring</code>&nbsp;(不无聊)&nbsp;的并且<strong> id 为奇数&nbsp;</strong>的影片，结果请按等级 <code>rating</code> 排列。</p>\n\n<p>&nbsp;</p>\n\n<p>例如，下表 <code>cinema</code>:</p>\n\n<pre>\n+---------+-----------+--------------+-----------+\n|   id    | movie     |  description |  rating   |\n+---------+-----------+--------------+-----------+\n|   1     | War       |   great 3D   |   8.9     |\n|   2     | Science   |   fiction    |   8.5     |\n|   3     | irish     |   boring     |   6.2     |\n|   4     | Ice song  |   Fantacy    |   8.6     |\n|   5     | House card|   Interesting|   9.1     |\n+---------+-----------+--------------+-----------+\n</pre>\n\n<p>对于上面的例子，则正确的输出是为：</p>\n\n<pre>\n+---------+-----------+--------------+-----------+\n|   id    | movie     |  description |  rating   |\n+---------+-----------+--------------+-----------+\n|   5     | House card|   Interesting|   9.1     |\n|   1     | War       |   great 3D   |   8.9     |\n+---------+-----------+--------------+-----------+\n</pre>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 621任务调度器",
        "hardRate": "MEDIUM",
        "passRate": "59.75%",
        "problemsUrl": "https://leetcode.cn/problems/task-scheduler/",
        "solutionsUrl": "https://leetcode.cn/problems/task-scheduler/solution",
        "problemsDesc": "<p>给你一个用字符数组 <code>tasks</code> 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p>\n\n<p>然而，两个<strong> 相同种类</strong> 的任务之间必须有长度为整数<strong> </strong><code>n</code><strong> </strong>的冷却时间，因此至少有连续 <code>n</code> 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p>\n\n<p>你需要计算完成所有任务所需要的<strong> 最短时间</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\n<strong>输出：</strong>8\n<strong>解释：</strong>A -> B -> (待命) -> A -> B -> (待命) -> A -> B\n     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 </pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 0\n<strong>输出：</strong>6\n<strong>解释：</strong>在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0\n[\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"]\n[\"A\",\"B\",\"A\",\"B\",\"A\",\"B\"]\n[\"B\",\"B\",\"B\",\"A\",\"A\",\"A\"]\n...\n诸如此类\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>tasks = [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"], n = 2\n<strong>输出：</strong>16\n<strong>解释：</strong>一种可能的解决方案是：\n     A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> (待命) -> (待命) -> A -> (待命) -> (待命) -> A\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= task.length <= 10<sup>4</sup></code></li>\n\t<li><code>tasks[i]</code> 是大写英文字母</li>\n\t<li><code>n</code> 的取值范围为 <code>[0, 100]</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 622设计循环队列",
        "hardRate": "MEDIUM",
        "passRate": "47.11%",
        "problemsUrl": "https://leetcode.cn/problems/design-circular-queue/",
        "solutionsUrl": "https://leetcode.cn/problems/design-circular-queue/solution",
        "problemsDesc": "<p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为&ldquo;环形缓冲器&rdquo;。</p>\n\n<p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p>\n\n<p>你的实现应该支持如下操作：</p>\n\n<ul>\n\t<li><code>MyCircularQueue(k)</code>: 构造器，设置队列长度为 k 。</li>\n\t<li><code>Front</code>: 从队首获取元素。如果队列为空，返回 -1 。</li>\n\t<li><code>Rear</code>: 获取队尾元素。如果队列为空，返回 -1 。</li>\n\t<li><code>enQueue(value)</code>: 向循环队列插入一个元素。如果成功插入则返回真。</li>\n\t<li><code>deQueue()</code>: 从循环队列中删除一个元素。如果成功删除则返回真。</li>\n\t<li><code>isEmpty()</code>: 检查循环队列是否为空。</li>\n\t<li><code>isFull()</code>: 检查循环队列是否已满。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3\ncircularQueue.enQueue(1); &nbsp;// 返回 true\ncircularQueue.enQueue(2); &nbsp;// 返回 true\ncircularQueue.enQueue(3); &nbsp;// 返回 true\ncircularQueue.enQueue(4); &nbsp;// 返回 false，队列已满\ncircularQueue.Rear(); &nbsp;// 返回 3\ncircularQueue.isFull(); &nbsp;// 返回 true\ncircularQueue.deQueue(); &nbsp;// 返回 true\ncircularQueue.enQueue(4); &nbsp;// 返回 true\ncircularQueue.Rear(); &nbsp;// 返回 4</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>所有的值都在 0&nbsp;至 1000 的范围内；</li>\n\t<li>操作数将在 1 至 1000 的范围内；</li>\n\t<li>请不要使用内置的队列库。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 623在二叉树中增加一行",
        "hardRate": "MEDIUM",
        "passRate": "60.11%",
        "problemsUrl": "https://leetcode.cn/problems/add-one-row-to-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/add-one-row-to-tree/solution",
        "problemsDesc": "<p>给定一个二叉树的根&nbsp;<code>root</code>&nbsp;和两个整数 <code>val</code> 和&nbsp;<code>depth</code>&nbsp;，在给定的深度&nbsp;<code>depth</code>&nbsp;处添加一个值为 <code>val</code> 的节点行。</p>\n\n<p>注意，根节点&nbsp;<code>root</code>&nbsp;位于深度&nbsp;<code>1</code>&nbsp;。</p>\n\n<p>加法规则如下:</p>\n\n<ul>\n\t<li>给定整数&nbsp;<code>depth</code>，对于深度为&nbsp;<code>depth - 1</code> 的每个非空树节点 <code>cur</code> ，创建两个值为 <code>val</code> 的树节点作为 <code>cur</code> 的左子树根和右子树根。</li>\n\t<li><code>cur</code> 原来的左子树应该是新的左子树根的左子树。</li>\n\t<li><code>cur</code> 原来的右子树应该是新的右子树根的右子树。</li>\n\t<li>如果 <code>depth == 1 </code>意味着&nbsp;<code>depth - 1</code>&nbsp;根本没有深度，那么创建一个树节点，值 <code>val </code>作为整个原始树的新根，而原始树就是新根的左子树。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/03/15/addrow-tree.jpg\" style=\"height: 231px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入:</strong> root = [4,2,6,3,1,5], val = 1, depth = 2\n<strong>输出:</strong> [4,1,1,2,null,null,6,3,1,5]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/03/11/add2-tree.jpg\" style=\"height: 277px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入:</strong> root = [4,2,null,3,1], val = 1, depth = 3\n<strong>输出:</strong>  [4,2,null,1,1,3,null,null,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>节点数在&nbsp;<code>[1, 10<sup>4</sup>]</code>&nbsp;范围内</li>\n\t<li>树的深度在&nbsp;<code>[1, 10<sup>4</sup>]</code>范围内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= depth &lt;= the depth of tree + 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 624数组列表中的最大距离",
        "hardRate": "MEDIUM",
        "passRate": "40.74%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-distance-in-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-distance-in-arrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 625最小因式分解",
        "hardRate": "MEDIUM",
        "passRate": "34.57%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-factorization/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-factorization/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 626换座位",
        "hardRate": "MEDIUM",
        "passRate": "67.97%",
        "problemsUrl": "https://leetcode.cn/problems/exchange-seats/",
        "solutionsUrl": "https://leetcode.cn/problems/exchange-seats/solution",
        "problemsDesc": "<p>表:&nbsp;<code>Seat</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\nId是该表的主键列。\n该表的每一行都表示学生的姓名和ID。\nId是一个连续的增量。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写SQL查询来交换每两个连续的学生的座位号。如果学生的数量是奇数，则最后一个学生的id不交换。</p>\n\n<p>按 <code>id</code> <strong>升序</strong> 返回结果表。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nSeat 表:\n+----+---------+\n| id | student |\n+----+---------+\n| 1  | Abbot   |\n| 2  | Doris   |\n| 3  | Emerson |\n| 4  | Green   |\n| 5  | Jeames  |\n+----+---------+\n<strong>输出:</strong> \n+----+---------+\n| id | student |\n+----+---------+\n| 1  | Doris   |\n| 2  | Abbot   |\n| 3  | Green   |\n| 4  | Emerson |\n| 5  | Jeames  |\n+----+---------+\n<strong>解释:\n</strong>请注意，如果学生人数为奇数，则不需要更换最后一名学生的座位。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 627变更性别",
        "hardRate": "EASY",
        "passRate": "82.12%",
        "problemsUrl": "https://leetcode.cn/problems/swap-salary/",
        "solutionsUrl": "https://leetcode.cn/problems/swap-salary/solution",
        "problemsDesc": "<div class=\"original__bRMd\">\n<div>\n<p><code>Salary</code> 表：</p>\n\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| id          | int      |\n| name        | varchar  |\n| sex         | ENUM     |\n| salary      | int      |\n+-------------+----------+\nid 是这个表的主键。\nsex 这一列的值是 ENUM 类型，只能从 ('m', 'f') 中取。\n本表包含公司雇员的信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>请你编写一个 SQL 查询来交换所有的 <code>'f'</code> 和 <code>'m'</code> （即，将所有 <code>'f'</code> 变为 <code>'m'</code> ，反之亦然），仅使用 <strong>单个 update 语句</strong> ，且不产生中间临时表。</p>\n\n<p>注意，你必须仅使用一条 update 语句，且 <strong>不能</strong> 使用 select 语句。</p>\n\n<p>查询结果如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nSalary 表：\n+----+------+-----+--------+\n| id | name | sex | salary |\n+----+------+-----+--------+\n| 1  | A    | m   | 2500   |\n| 2  | B    | f   | 1500   |\n| 3  | C    | m   | 5500   |\n| 4  | D    | f   | 500    |\n+----+------+-----+--------+\n<strong>输出：</strong>\n+----+------+-----+--------+\n| id | name | sex | salary |\n+----+------+-----+--------+\n| 1  | A    | f   | 2500   |\n| 2  | B    | m   | 1500   |\n| 3  | C    | f   | 5500   |\n| 4  | D    | m   | 500    |\n+----+------+-----+--------+\n<strong>解释：</strong>\n(1, A) 和 (3, C) 从 'm' 变为 'f' 。\n(2, B) 和 (4, D) 从 'f' 变为 'm' 。</pre>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 628三个数的最大乘积",
        "hardRate": "EASY",
        "passRate": "51.99%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-product-of-three-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-product-of-three-numbers/solution",
        "problemsDesc": "<p>给你一个整型数组 <code>nums</code> ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>24\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,-2,-3]\n<strong>输出：</strong>-6\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 <= nums.length <= 10<sup>4</sup></code></li>\n\t<li><code>-1000 <= nums[i] <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 629K 个逆序对数组",
        "hardRate": "HARD",
        "passRate": "51.10%",
        "problemsUrl": "https://leetcode.cn/problems/k-inverse-pairs-array/",
        "solutionsUrl": "https://leetcode.cn/problems/k-inverse-pairs-array/solution",
        "problemsDesc": "<p>逆序对的定义如下：对于数组 <code>nums</code> 的第 <code>i</code> 个和第 <code>j</code> 个元素，如果满足 <code>0 &lt;= i &lt; j &lt; nums.length</code> 且&nbsp;<code>nums[i] &gt; nums[j]</code>，则其为一个逆序对；否则不是。</p>\n\n<p>给你两个整数&nbsp;<code>n</code>&nbsp;和&nbsp;<code>k</code>，找出所有包含从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;的数字，且恰好拥有&nbsp;<code>k</code>&nbsp;个 <strong>逆序对</strong> 的不同的数组的个数。由于答案可能很大，只需要返回对 <code>10<sup>9</sup>&nbsp;+ 7</code> 取余的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 0\n<strong>输出：</strong>1\n<strong>解释：</strong>\n只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>\n数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= k &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 630课程表 III",
        "hardRate": "HARD",
        "passRate": "46.24%",
        "problemsUrl": "https://leetcode.cn/problems/course-schedule-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/course-schedule-iii/solution",
        "problemsDesc": "<p>这里有 <code>n</code> 门不同的在线课程，按从 <code>1</code> 到 <code>n</code>&nbsp;编号。给你一个数组 <code>courses</code> ，其中 <code>courses[i] = [duration<sub>i</sub>, lastDay<sub>i</sub>]</code> 表示第 <code>i</code> 门课将会 <strong>持续</strong> 上 <code>duration<sub>i</sub></code> 天课，并且必须在不晚于 <code>lastDay<sub>i</sub></code> 的时候完成。</p>\n\n<p>你的学期从第 <code>1</code> 天开始。且不能同时修读两门及两门以上的课程。</p>\n\n<p>返回你最多可以修读的课程数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>courses = [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n这里一共有 4 门课程，但是你最多可以修 3 门：\n首先，修第 1 门课，耗费 100 天，在第 100 天完成，在第 101 天开始下门课。\n第二，修第 3 门课，耗费 1000 天，在第 1100 天完成，在第 1101 天开始下门课程。\n第三，修第 2 门课，耗时 200 天，在第 1300 天完成。\n第 4 门课现在不能修，因为将会在第 3300 天完成它，这已经超出了关闭日期。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>courses = [[1,2]]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>courses = [[3,2],[4,3]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= courses.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= duration<sub>i</sub>, lastDay<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 631设计 Excel 求和公式",
        "hardRate": "HARD",
        "passRate": "33.44%",
        "problemsUrl": "https://leetcode.cn/problems/design-excel-sum-formula/",
        "solutionsUrl": "https://leetcode.cn/problems/design-excel-sum-formula/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 632最小区间",
        "hardRate": "HARD",
        "passRate": "60.73%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/solution",
        "problemsDesc": "<p>你有&nbsp;<code>k</code>&nbsp;个 <strong>非递减排列</strong> 的整数列表。找到一个 <strong>最小 </strong>区间，使得&nbsp;<code>k</code>&nbsp;个列表中的每个列表至少有一个数包含在其中。</p>\n\n<p>我们定义如果&nbsp;<code>b-a &lt; d-c</code>&nbsp;或者在&nbsp;<code>b-a == d-c</code>&nbsp;时&nbsp;<code>a &lt; c</code>，则区间 <code>[a,b]</code> 比 <code>[c,d]</code> 小。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]\n<strong>输出：</strong>[20,24]\n<strong>解释：</strong> \n列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。\n列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。\n列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[1,2,3],[1,2,3],[1,2,3]]\n<strong>输出：</strong>[1,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length == k</code></li>\n\t<li><code>1 &lt;= k &lt;= 3500</code></li>\n\t<li><code>1 &lt;= nums[i].length &lt;= 50</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> 按非递减顺序排列</li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 633平方数之和",
        "hardRate": "MEDIUM",
        "passRate": "38.27%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-square-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-square-numbers/solution",
        "problemsDesc": "<p>给定一个非负整数&nbsp;<code>c</code>&nbsp;，你要判断是否存在两个整数 <code>a</code> 和 <code>b</code>，使得&nbsp;<code>a<sup>2</sup> + b<sup>2</sup> = c</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>c = 5\n<strong>输出：</strong>true\n<strong>解释：</strong>1 * 1 + 2 * 2 = 5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>c = 3\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= c &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 634寻找数组的错位排列",
        "hardRate": "MEDIUM",
        "passRate": "47.37%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-derangement-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-derangement-of-an-array/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 635设计日志存储系统",
        "hardRate": "MEDIUM",
        "passRate": "56.36%",
        "problemsUrl": "https://leetcode.cn/problems/design-log-storage-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-log-storage-system/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 636函数的独占时间",
        "hardRate": "MEDIUM",
        "passRate": "66.01%",
        "problemsUrl": "https://leetcode.cn/problems/exclusive-time-of-functions/",
        "solutionsUrl": "https://leetcode.cn/problems/exclusive-time-of-functions/solution",
        "problemsDesc": "<p>有一个 <strong>单线程</strong> CPU 正在运行一个含有 <code>n</code> 道函数的程序。每道函数都有一个位于  <code>0</code> 和 <code>n-1</code> 之间的唯一标识符。</p>\n\n<p>函数调用 <strong>存储在一个 <a href=\"https://baike.baidu.com/item/%E8%B0%83%E7%94%A8%E6%A0%88/22718047?fr=aladdin\" target=\"_blank\">调用栈</a> 上</strong> ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 <strong>当前正在执行的函数</strong> 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。</p>\n\n<p>给你一个由日志组成的列表 <code>logs</code> ，其中 <code>logs[i]</code> 表示第 <code>i</code> 条日志消息，该消息是一个按 <code>\"{function_id}:{\"start\" | \"end\"}:{timestamp}\"</code> 进行格式化的字符串。例如，<code>\"0:start:3\"</code> 意味着标识符为 <code>0</code> 的函数调用在时间戳 <code>3</code> 的 <strong>起始开始执行</strong> ；而 <code>\"1:end:2\"</code> 意味着标识符为 <code>1</code> 的函数调用在时间戳 <code>2</code> 的 <strong>末尾结束执行</strong>。注意，函数可以 <strong>调用多次，可能存在递归调用 </strong>。</p>\n\n<p>函数的 <strong>独占时间</strong> 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 <code>2</code> 单位时间，另一次调用执行 <code>1</code> 单位时间，那么该函数的 <strong>独占时间</strong> 为 <code>2 + 1 = 3</code> 。</p>\n\n<p>以数组形式返回每个函数的 <strong>独占时间</strong> ，其中第 <code>i</code> 个下标对应的值表示标识符 <code>i</code> 的函数的独占时间。</p>\n \n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/04/05/diag1b.png\" style=\"width: 550px; height: 239px;\" />\n<pre>\n<strong>输入：</strong>n = 2, logs = [\"0:start:0\",\"1:start:2\",\"1:end:5\",\"0:end:6\"]\n<strong>输出：</strong>[3,4]\n<strong>解释：</strong>\n函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，于时间戳 1 的末尾结束执行。 \n函数 1 在时间戳 2 的起始开始执行，执行 4 个单位时间，于时间戳 5 的末尾结束执行。 \n函数 0 在时间戳 6 的开始恢复执行，执行 1 个单位时间。 \n所以函数 0 总共执行 2 + 1 = 3 个单位时间，函数 1 总共执行 4 个单位时间。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"0:start:6\",\"0:end:6\",\"0:end:7\"]\n<strong>输出：</strong>[8]\n<strong>解释：</strong>\n函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。\n函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。\n函数 0（初始调用）恢复执行，并立刻再次调用它自身。\n函数 0（第二次递归调用）在时间戳 6 的起始开始执行，执行 1 个单位时间。\n函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间。\n所以函数 0 总共执行 2 + 4 + 1 + 1 = 8 个单位时间。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:6\",\"1:end:6\",\"0:end:7\"]\n<strong>输出：</strong>[7,1]\n<strong>解释：</strong>\n函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。\n函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。\n函数 0（初始调用）恢复执行，并立刻调用函数 1 。\n函数 1在时间戳 6 的起始开始执行，执行 1 个单位时间，于时间戳 6 的末尾结束执行。\n函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间，于时间戳 7 的末尾结束执行。\n所以函数 0 总共执行 2 + 4 + 1 = 7 个单位时间，函数 1 总共执行 1 个单位时间。 </pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\n<strong>输出：</strong>[8,1]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, logs = [\"0:start:0\",\"0:end:0\"]\n<strong>输出：</strong>[1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>1 <= logs.length <= 500</code></li>\n\t<li><code>0 <= function_id < n</code></li>\n\t<li><code>0 <= timestamp <= 10<sup>9</sup></code></li>\n\t<li>两个开始事件不会在同一时间戳发生</li>\n\t<li>两个结束事件不会在同一时间戳发生</li>\n\t<li>每道函数都有一个对应 <code>\"start\"</code> 日志的 <code>\"end\"</code> 日志</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 637二叉树的层平均值",
        "hardRate": "EASY",
        "passRate": "69.79%",
        "problemsUrl": "https://leetcode.cn/problems/average-of-levels-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/average-of-levels-in-binary-tree/solution",
        "problemsDesc": "<p>给定一个非空二叉树的根节点<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;, 以数组的形式返回每一层节点的平均值。与实际答案相差&nbsp;<code>10<sup>-5</sup></code> 以内的答案可以被接受。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [3,9,20,null,null,15,7]\n<strong>输出：</strong>[3.00000,14.50000,11.00000]\n<strong>解释：</strong>第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。\n因此返回 [3, 14.5, 11] 。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [3,9,20,15,7]\n<strong>输出：</strong>[3.00000,14.50000,11.00000]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li>树中节点数量在&nbsp;<code>[1, 10<sup>4</sup>]</code> 范围内</li>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= Node.val &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 638大礼包",
        "hardRate": "MEDIUM",
        "passRate": "62.86%",
        "problemsUrl": "https://leetcode.cn/problems/shopping-offers/",
        "solutionsUrl": "https://leetcode.cn/problems/shopping-offers/solution",
        "problemsDesc": "<p>在 LeetCode 商店中， 有 <code>n</code> 件在售的物品。每件物品都有对应的价格。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。</p>\n\n<p>给你一个整数数组 <code>price</code> 表示物品价格，其中 <code>price[i]</code> 是第 <code>i</code> 件物品的价格。另有一个整数数组 <code>needs</code> 表示购物清单，其中 <code>needs[i]</code> 是需要购买第 <code>i</code> 件物品的数量。</p>\n\n<p>还有一个数组 <code>special</code> 表示大礼包，<code>special[i]</code> 的长度为 <code>n + 1</code> ，其中 <code>special[i][j]</code> 表示第 <code>i</code> 个大礼包中内含第 <code>j</code> 件物品的数量，且 <code>special[i][n]</code> （也就是数组中的最后一个整数）为第 <code>i</code> 个大礼包的价格。</p>\n\n<p>返回<strong> 确切 </strong>满足购物清单所需花费的最低价格，你可以充分利用大礼包的优惠活动。你不能购买超出购物清单指定数量的物品，即使那样会降低整体价格。任意大礼包可无限次购买。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]\n<strong>输出：</strong>14\n<strong>解释：</strong>有 A 和 B 两种物品，价格分别为 ¥2 和 ¥5 。 \n大礼包 1 ，你可以以 ¥5 的价格购买 3A 和 0B 。 \n大礼包 2 ，你可以以 ¥10 的价格购买 1A 和 2B 。 \n需要购买 3 个 A 和 2 个 B ， 所以付 ¥10 购买 1A 和 2B（大礼包 2），以及 ¥4 购买 2A 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]\n<strong>输出：</strong>11\n<strong>解释：</strong>A ，B ，C 的价格分别为 ¥2 ，¥3 ，¥4 。\n可以用 ¥4 购买 1A 和 1B ，也可以用 ¥9 购买 2A ，2B 和 1C 。 \n需要买 1A ，2B 和 1C ，所以付 ¥4 买 1A 和 1B（大礼包 1），以及 ¥3 购买 1B ， ¥4 购买 1C 。 \n不可以购买超出待购清单的物品，尽管购买大礼包 2 更加便宜。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == price.length</code></li>\n\t<li><code>n == needs.length</code></li>\n\t<li><code>1 <= n <= 6</code></li>\n\t<li><code>0 <= price[i] <= 10</code></li>\n\t<li><code>0 <= needs[i] <= 10</code></li>\n\t<li><code>1 <= special.length <= 100</code></li>\n\t<li><code>special[i].length == n + 1</code></li>\n\t<li><code>0 <= special[i][j] <= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 639解码方法 II",
        "hardRate": "HARD",
        "passRate": "37.38%",
        "problemsUrl": "https://leetcode.cn/problems/decode-ways-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/decode-ways-ii/solution",
        "problemsDesc": "<p>一条包含字母&nbsp;<code>A-Z</code> 的消息通过以下的方式进行了 <strong>编码</strong> ：</p>\n\n<pre>\n'A' -&gt; \"1\"\n'B' -&gt; \"2\"\n...\n'Z' -&gt; \"26\"</pre>\n\n<p>要 <strong>解码</strong> 一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，<code>\"11106\"</code> 可以映射为：</p>\n\n<ul>\n\t<li><code>\"AAJF\"</code> 对应分组 <code>(1 1 10 6)</code></li>\n\t<li><code>\"KJF\"</code> 对应分组 <code>(11 10 6)</code></li>\n</ul>\n\n<p>注意，像 <code>(1 11 06)</code> 这样的分组是无效的，因为 <code>\"06\"</code> 不可以映射为 <code>'F'</code> ，因为 <code>\"6\"</code> 与 <code>\"06\"</code> 不同。</p>\n\n<p><strong>除了</strong> 上面描述的数字字母映射方案，编码消息中可能包含 <code>'*'</code> 字符，可以表示从 <code>'1'</code> 到 <code>'9'</code> 的任一数字（不包括 <code>'0'</code>）。例如，编码字符串 <code>\"1*\"</code> 可以表示 <code>\"11\"</code>、<code>\"12\"</code>、<code>\"13\"</code>、<code>\"14\"</code>、<code>\"15\"</code>、<code>\"16\"</code>、<code>\"17\"</code>、<code>\"18\"</code> 或 <code>\"19\"</code> 中的任意一条消息。对 <code>\"1*\"</code> 进行解码，相当于解码该字符串可以表示的任何编码消息。</p>\n\n<p>给你一个字符串 <code>s</code> ，由数字和 <code>'*'</code> 字符组成，返回 <strong>解码</strong> 该字符串的方法 <strong>数目</strong> 。</p>\n\n<p>由于答案数目可能非常大，返回&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;的&nbsp;<b>模</b>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"*\"\n<strong>输出：</strong>9\n<strong>解释：</strong>这一条编码消息可以表示 \"1\"、\"2\"、\"3\"、\"4\"、\"5\"、\"6\"、\"7\"、\"8\" 或 \"9\" 中的任意一条。\n可以分别解码成字符串 \"A\"、\"B\"、\"C\"、\"D\"、\"E\"、\"F\"、\"G\"、\"H\" 和 \"I\" 。\n因此，\"*\" 总共有 9 种解码方法。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1*\"\n<strong>输出：</strong>18\n<strong>解释：</strong>这一条编码消息可以表示 \"11\"、\"12\"、\"13\"、\"14\"、\"15\"、\"16\"、\"17\"、\"18\" 或 \"19\" 中的任意一条。\n每种消息都可以由 2 种方法解码（例如，\"11\" 可以解码成 \"AA\" 或 \"K\"）。\n因此，\"1*\" 共有 9 * 2 = 18 种解码方法。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"2*\"\n<strong>输出：</strong>15\n<strong>解释：</strong>这一条编码消息可以表示 \"21\"、\"22\"、\"23\"、\"24\"、\"25\"、\"26\"、\"27\"、\"28\" 或 \"29\" 中的任意一条。\n\"21\"、\"22\"、\"23\"、\"24\"、\"25\" 和 \"26\" 由 2 种解码方法，但 \"27\"、\"28\" 和 \"29\" 仅有 1 种解码方法。\n因此，\"2*\" 共有 (6 * 2) + (3 * 1) = 12 + 3 = 15 种解码方法。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 是 <code>0 - 9</code> 中的一位数字或字符 <code>'*'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 640求解方程",
        "hardRate": "MEDIUM",
        "passRate": "44.59%",
        "problemsUrl": "https://leetcode.cn/problems/solve-the-equation/",
        "solutionsUrl": "https://leetcode.cn/problems/solve-the-equation/solution",
        "problemsDesc": "<p>求解一个给定的方程，将<code>x</code>以字符串 <code>\"x=#value\"</code>&nbsp;的形式返回。该方程仅包含 <code>'+'</code> ， <code>'-'</code> 操作，变量&nbsp;<code>x</code>&nbsp;和其对应系数。</p>\n\n<p>如果方程没有解或存在的解不为整数，请返回&nbsp;<code>\"No solution\"</code>&nbsp;。如果方程有无限解，则返回 <code>“Infinite solutions”</code> 。</p>\n\n<p>题目保证，如果方程中只有一个解，则 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">'x'</span></span></font></font> 的值是一个整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> equation = \"x+5-3+x=6+x-2\"\n<strong>输出:</strong> \"x=2\"\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> equation = \"x=x\"\n<strong>输出:</strong> \"Infinite solutions\"\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> equation = \"2x=x\"\n<strong>输出:</strong> \"x=0\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= equation.length &lt;= 1000</code></li>\n\t<li><code>equation</code>&nbsp;只有一个&nbsp;<code>'='</code>.&nbsp;</li>\n\t<li>方程由绝对值在&nbsp;<code>[0, 100]</code>&nbsp; 范围内且无任何前导零的整数和变量 <code>'x'</code>&nbsp;组成。<span style=\"display:block\"><span style=\"height:0px\"><span style=\"position:absolute\">​​​</span></span></span></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 641设计循环双端队列",
        "hardRate": "MEDIUM",
        "passRate": "57.11%",
        "problemsUrl": "https://leetcode.cn/problems/design-circular-deque/",
        "solutionsUrl": "https://leetcode.cn/problems/design-circular-deque/solution",
        "problemsDesc": "<p>设计实现双端队列。</p>\n\n<p>实现 <code>MyCircularDeque</code> 类:</p>\n\n<ul>\n\t<li><code>MyCircularDeque(int k)</code>&nbsp;：构造函数,双端队列最大为 <code>k</code> 。</li>\n\t<li><code>boolean insertFront()</code>：将一个元素添加到双端队列头部。 如果操作成功返回 <code>true</code>&nbsp;，否则返回 <code>false</code> 。</li>\n\t<li><code>boolean insertLast()</code>&nbsp;：将一个元素添加到双端队列尾部。如果操作成功返回 <code>true</code>&nbsp;，否则返回 <code>false</code> 。</li>\n\t<li><code>boolean deleteFront()</code>&nbsp;：从双端队列头部删除一个元素。 如果操作成功返回 <code>true</code>&nbsp;，否则返回 <code>false</code> 。</li>\n\t<li><code>boolean deleteLast()</code>&nbsp;：从双端队列尾部删除一个元素。如果操作成功返回 <code>true</code>&nbsp;，否则返回 <code>false</code> 。</li>\n\t<li><code>int getFront()</code>&nbsp;)：从双端队列头部获得一个元素。如果双端队列为空，返回 <code>-1</code>&nbsp;。</li>\n\t<li><code>int getRear()</code>&nbsp;：获得双端队列的最后一个元素。&nbsp;如果双端队列为空，返回 <code>-1</code> 。</li>\n\t<li><code>boolean isEmpty()</code>&nbsp;：若双端队列为空，则返回&nbsp;<code>true</code>&nbsp;，否则返回 <code>false</code> &nbsp;。</li>\n\t<li><code>boolean isFull()</code>&nbsp;：若双端队列满了，则返回&nbsp;<code>true</code>&nbsp;，否则返回 <code>false</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\n[[3], [1], [2], [3], [4], [], [], [], [4], []]\n<strong>输出</strong>\n[null, true, true, true, false, 2, true, true, true, 4]\n\n<strong>解释</strong>\nMyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3\ncircularDeque.insertLast(1);\t\t\t        // 返回 true\ncircularDeque.insertLast(2);\t\t\t        // 返回 true\ncircularDeque.insertFront(3);\t\t\t        // 返回 true\ncircularDeque.insertFront(4);\t\t\t        // 已经满了，返回 false\ncircularDeque.getRear();  \t\t\t\t// 返回 2\ncircularDeque.isFull();\t\t\t\t        // 返回 true\ncircularDeque.deleteLast();\t\t\t        // 返回 true\ncircularDeque.insertFront(4);\t\t\t        // 返回 true\ncircularDeque.getFront();\t\t\t\t// 返回 4\n&nbsp;</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 1000</code></li>\n\t<li><code>0 &lt;= value &lt;= 1000</code></li>\n\t<li><code>insertFront</code>,&nbsp;<code>insertLast</code>,&nbsp;<code>deleteFront</code>,&nbsp;<code>deleteLast</code>,&nbsp;<code>getFront</code>,&nbsp;<code>getRear</code>,&nbsp;<code>isEmpty</code>,&nbsp;<code>isFull</code>&nbsp; 调用次数不大于&nbsp;<code>2000</code>&nbsp;次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 642设计搜索自动补全系统",
        "hardRate": "HARD",
        "passRate": "56.09%",
        "problemsUrl": "https://leetcode.cn/problems/design-search-autocomplete-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-search-autocomplete-system/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 643子数组最大平均数 I",
        "hardRate": "EASY",
        "passRate": "43.34%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-average-subarray-i/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-average-subarray-i/solution",
        "problemsDesc": "<p>给你一个由 <code>n</code> 个元素组成的整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>\n\n<p>请你找出平均数最大且 <strong>长度为 <code>k</code></strong> 的连续子数组，并输出该最大平均数。</p>\n\n<p>任何误差小于 <code>10<sup>-5</sup></code> 的答案都将被视为正确答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,12,-5,-6,50,3], k = 4\n<strong>输出：</strong>12.75\n<strong>解释：</strong>最大平均数 (12-5-6+50)/4 = 51/4 = 12.75\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5], k = 1\n<strong>输出：</strong>5.00000\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 644子数组最大平均数 II",
        "hardRate": "HARD",
        "passRate": "44.39%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-average-subarray-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-average-subarray-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 645错误的集合",
        "hardRate": "EASY",
        "passRate": "39.74%",
        "problemsUrl": "https://leetcode.cn/problems/set-mismatch/",
        "solutionsUrl": "https://leetcode.cn/problems/set-mismatch/solution",
        "problemsDesc": "<p>集合 <code>s</code> 包含从 <code>1</code> 到 <code>n</code> 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 <strong>丢失了一个数字</strong> 并且 <strong>有一个数字重复</strong> 。</p>\n\n<p>给定一个数组 <code>nums</code> 代表了集合 <code>S</code> 发生错误后的结果。</p>\n\n<p>请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2,4]\n<strong>输出：</strong>[2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= nums.length <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 646最长数对链",
        "hardRate": "MEDIUM",
        "passRate": "62.25%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-length-of-pair-chain/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-length-of-pair-chain/solution",
        "problemsDesc": "<p>给你一个由&nbsp;<code>n</code>&nbsp;个数对组成的数对数组&nbsp;<code>pairs</code>&nbsp;，其中&nbsp;<code>pairs[i] = [left<sub>i</sub>, right<sub>i</sub>]</code>&nbsp;且&nbsp;<code>left<sub>i</sub>&nbsp;&lt; right<sub>i</sub></code><sub> 。</sub></p>\n\n<p>现在，我们定义一种 <strong>跟随</strong> 关系，当且仅当&nbsp;<code>b &lt; c</code>&nbsp;时，数对&nbsp;<code>p2 = [c, d]</code>&nbsp;才可以跟在&nbsp;<code>p1 = [a, b]</code>&nbsp;后面。我们用这种形式来构造 <strong>数对链</strong> 。</p>\n\n<p>找出并返回能够形成的 <strong>最长数对链的长度</strong> 。</p>\n\n<p>你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>pairs =&nbsp;[[1,2], [2,3], [3,4]]\n<strong>输出：</strong>2\n<strong>解释：</strong>最长的数对链是 [1,2] -&gt; [3,4] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>pairs = [[1,2],[7,8],[4,5]]\n<b>输出：</b>3\n<b>解释：</b>最长的数对链是 [1,2] -&gt; [4,5] -&gt; [7,8] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == pairs.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= left<sub>i</sub>&nbsp;&lt; right<sub>i</sub>&nbsp;&lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 647回文子串",
        "hardRate": "MEDIUM",
        "passRate": "66.87%",
        "problemsUrl": "https://leetcode.cn/problems/palindromic-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/palindromic-substrings/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p>\n\n<p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p>\n\n<p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p>\n\n<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\"\n<strong>输出：</strong>3\n<strong>解释：</strong>三个回文子串: \"a\", \"b\", \"c\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aaa\"\n<strong>输出：</strong>6\n<strong>解释：</strong>6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\"</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 648单词替换",
        "hardRate": "MEDIUM",
        "passRate": "63.98%",
        "problemsUrl": "https://leetcode.cn/problems/replace-words/",
        "solutionsUrl": "https://leetcode.cn/problems/replace-words/solution",
        "problemsDesc": "<p>在英语中，我们有一个叫做&nbsp;<code>词根</code>(root) 的概念，可以词根<strong>后面</strong>添加其他一些词组成另一个较长的单词——我们称这个词为&nbsp;<code>继承词</code>(successor)。例如，词根<code>an</code>，跟随着单词&nbsp;<code>other</code>(其他)，可以形成新的单词&nbsp;<code>another</code>(另一个)。</p>\n\n<p>现在，给定一个由许多<strong>词根</strong>组成的词典 <code>dictionary</code> 和一个用空格分隔单词形成的句子 <code>sentence</code>。你需要将句子中的所有<strong>继承词</strong>用<strong>词根</strong>替换掉。如果<strong>继承词</strong>有许多可以形成它的<strong>词根</strong>，则用<strong>最短</strong>的词根替换它。</p>\n\n<p>你需要输出替换之后的句子。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"\n<strong>输出：</strong>\"the cat was rat by the bat\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf absbs bbab cadsfafs\"\n<strong>输出：</strong>\"a a b c\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= dictionary.length&nbsp;&lt;= 1000</code></li>\n\t<li><code>1 &lt;= dictionary[i].length &lt;= 100</code></li>\n\t<li><code>dictionary[i]</code>&nbsp;仅由小写字母组成。</li>\n\t<li><code>1 &lt;= sentence.length &lt;= 10^6</code></li>\n\t<li><code>sentence</code>&nbsp;仅由小写字母和空格组成。</li>\n\t<li><code>sentence</code> 中单词的总量在范围 <code>[1, 1000]</code> 内。</li>\n\t<li><code>sentence</code> 中每个单词的长度在范围 <code>[1, 1000]</code> 内。</li>\n\t<li><code>sentence</code> 中单词之间由一个空格隔开。</li>\n\t<li><code>sentence</code>&nbsp;没有前导或尾随空格。</li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 649Dota2 参议院",
        "hardRate": "MEDIUM",
        "passRate": "48.16%",
        "problemsUrl": "https://leetcode.cn/problems/dota2-senate/",
        "solutionsUrl": "https://leetcode.cn/problems/dota2-senate/solution",
        "problemsDesc": "<p>Dota2 的世界里有两个阵营：<code>Radiant</code>（天辉）和&nbsp;<code>Dire</code>（夜魇）</p>\n\n<p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的 <strong>一 </strong>项：</p>\n\n<ul>\n\t<li><strong>禁止一名参议员的权利</strong>：参议员可以让另一位参议员在这一轮和随后的几轮中丧失<strong> 所有的权利 </strong>。</li>\n\t<li><strong>宣布胜利</strong>：如果参议员发现有权利投票的参议员都是 <strong>同一个阵营的</strong> ，他可以宣布胜利并决定在游戏中的有关变化。</li>\n</ul>\n\n<p>给你一个字符串&nbsp;<code>senate</code> 代表每个参议员的阵营。字母 <code>'R'</code> 和 <code>'D'</code>分别代表了&nbsp;<code>Radiant</code>（天辉）和&nbsp;<code>Dire</code>（夜魇）。然后，如果有 <code>n</code> 个参议员，给定字符串的大小将是&nbsp;<code>n</code>。</p>\n\n<p>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</p>\n\n<p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是&nbsp;<code>\"Radiant\"</code> 或 <code>\"Dire\"</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>senate = \"RD\"\n<strong>输出：</strong>\"Radiant\"\n<strong>解释：\n</strong><code>第 1 轮时，第一个参议员来自 Radiant 阵营，他可以使用第一项权利让第二个参议员失去所有权利。\n这一轮中，第二个参议员将会被跳过，因为他的权利被禁止了。\n第 2 轮时，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人</code>。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>senate = \"RDD\"\n<strong>输出：</strong>\"Dire\"\n<strong>解释：</strong>\n第 1 轮时，第一个<code>来自 Radiant 阵营的</code>参议员可以使用第一项权利禁止第二个参议员的权利。\n<code>这一轮中，</code>第二个<code>来自 Dire 阵营的</code>参议员会将被跳过，因为他的权利被禁止了。\n<code>这一轮中，</code>第三个<code>来自 Dire 阵营的</code>参议员可以使用他的第一项权利禁止第一个参议员的权利。\n因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == senate.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>senate[i]</code> 为 <code>'R'</code> 或 <code>'D'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 650只有两个键的键盘",
        "hardRate": "MEDIUM",
        "passRate": "57.70%",
        "problemsUrl": "https://leetcode.cn/problems/2-keys-keyboard/",
        "solutionsUrl": "https://leetcode.cn/problems/2-keys-keyboard/solution",
        "problemsDesc": "<p>最初记事本上只有一个字符 <code>'A'</code> 。你每次可以对这个记事本进行两种操作：</p>\n\n<ul>\n\t<li><code>Copy All</code>（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。</li>\n\t<li><code>Paste</code>（粘贴）：粘贴<strong> 上一次 </strong>复制的字符。</li>\n</ul>\n\n<p>给你一个数字&nbsp;<code>n</code> ，你需要使用最少的操作次数，在记事本上输出 <strong>恰好</strong>&nbsp;<code>n</code>&nbsp;个 <code>'A'</code> 。返回能够打印出&nbsp;<code>n</code>&nbsp;个 <code>'A'</code> 的最少操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>3\n<strong>输出：</strong>3\n<strong>解释：</strong>\n最初, 只有一个字符 'A'。\n第 1 步, 使用 <strong>Copy All</strong> 操作。\n第 2 步, 使用 <strong>Paste </strong>操作来获得 'AA'。\n第 3 步, 使用 <strong>Paste</strong> 操作来获得 'AAA'。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 6514键键盘",
        "hardRate": "MEDIUM",
        "passRate": "59.73%",
        "problemsUrl": "https://leetcode.cn/problems/4-keys-keyboard/",
        "solutionsUrl": "https://leetcode.cn/problems/4-keys-keyboard/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 652寻找重复的子树",
        "hardRate": "MEDIUM",
        "passRate": "61.32%",
        "problemsUrl": "https://leetcode.cn/problems/find-duplicate-subtrees/",
        "solutionsUrl": "https://leetcode.cn/problems/find-duplicate-subtrees/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点 <code>root</code> ，返回所有 <strong>重复的子树 </strong>。</p>\n\n<p>对于同一类的重复子树，你只需要返回其中任意 <strong>一棵 </strong>的根结点即可。</p>\n\n<p>如果两棵树具有<strong> 相同的结构</strong> 和 <strong>相同的结点值 </strong>，则认为二者是 <strong>重复 </strong>的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/16/e1.jpg\" style=\"height: 236px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,null,2,4,null,null,4]\n<strong>输出：</strong>[[2,4],[4]]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/16/e2.jpg\" style=\"height: 125px; width: 200px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [2,1,1]\n<strong>输出：</strong>[[1]]</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/16/e33.jpg\" style=\"height: 202px; width: 300px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [2,2,2,3,null,3,null]\n<strong>输出：</strong>[[2,3],[3]]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的结点数在 <code>[1, 5000]</code> 范围内。</li>\n\t<li><code>-200 &lt;= Node.val &lt;= 200</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 653两数之和 IV - 输入二叉搜索树",
        "hardRate": "EASY",
        "passRate": "63.52%",
        "problemsUrl": "https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/",
        "solutionsUrl": "https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/solution",
        "problemsDesc": "<p>给定一个二叉搜索树 <code>root</code> 和一个目标结果 <code>k</code>，如果二叉搜索树中存在两个元素且它们的和等于给定的目标结果，则返回 <code>true</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg\" style=\"height: 229px; width: 400px;\" />\n<pre>\n<strong>输入:</strong> root = [5,3,6,2,4,null,7], k = 9\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/21/sum_tree_2.jpg\" style=\"height: 229px; width: 400px;\" />\n<pre>\n<strong>输入:</strong> root = [5,3,6,2,4,null,7], k = 28\n<strong>输出:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是&nbsp;&nbsp;<code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>题目数据保证，输入的 <code>root</code> 是一棵 <strong>有效</strong> 的二叉搜索树</li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 654最大二叉树",
        "hardRate": "MEDIUM",
        "passRate": "82.56%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-binary-tree/solution",
        "problemsDesc": "<p>给定一个不重复的整数数组&nbsp;<code>nums</code> 。&nbsp;<strong>最大二叉树</strong>&nbsp;可以用下面的算法从&nbsp;<code>nums</code> 递归地构建:</p>\n\n<ol>\n\t<li>创建一个根节点，其值为&nbsp;<code>nums</code> 中的最大值。</li>\n\t<li>递归地在最大值&nbsp;<strong>左边</strong>&nbsp;的&nbsp;<strong>子数组前缀上</strong>&nbsp;构建左子树。</li>\n\t<li>递归地在最大值 <strong>右边</strong> 的&nbsp;<strong>子数组后缀上</strong>&nbsp;构建右子树。</li>\n</ol>\n\n<p>返回&nbsp;<em><code>nums</code> 构建的 </em><strong><em>最大二叉树</em> </strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg\" />\n<pre>\n<strong>输入：</strong>nums = [3,2,1,6,0,5]\n<strong>输出：</strong>[6,3,5,null,2,0,null,null,1]\n<strong>解释：</strong>递归调用如下所示：\n- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。\n    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。\n        - 空数组，无子节点。\n        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。\n            - 空数组，无子节点。\n            - 只有一个元素，所以子节点是一个值为 1 的节点。\n    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。\n        - 只有一个元素，所以子节点是一个值为 0 的节点。\n        - 空数组，无子节点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg\" />\n<pre>\n<strong>输入：</strong>nums = [3,2,1]\n<strong>输出：</strong>[3,null,2,null,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 655输出二叉树",
        "hardRate": "MEDIUM",
        "passRate": "69.66%",
        "problemsUrl": "https://leetcode.cn/problems/print-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/print-binary-tree/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点 <code>root</code> ，请你构造一个下标从 <strong>0</strong> 开始、大小为 <code>m x n</code> 的字符串矩阵 <code>res</code> ，用以表示树的 <strong>格式化布局</strong> 。构造此格式化布局矩阵需要遵循以下规则：</p>\n\n<ul>\n\t<li>树的 <strong>高度</strong> 为 <code>height</code> ，矩阵的行数 <code>m</code> 应该等于 <code>height + 1</code> 。</li>\n\t<li>矩阵的列数 <code>n</code> 应该等于 <code>2<sup>height+1</sup> - 1</code> 。</li>\n\t<li><strong>根节点</strong> 需要放置在 <strong>顶行</strong> 的 <strong>正中间</strong> ，对应位置为 <code>res[0][(n-1)/2]</code> 。</li>\n\t<li>对于放置在矩阵中的每个节点，设对应位置为 <code>res[r][c]</code> ，将其左子节点放置在 <code>res[r+1][c-2<sup>height-r-1</sup>]</code> ，右子节点放置在 <code>res[r+1][c+2<sup>height-r-1</sup>]</code> 。</li>\n\t<li>继续这一过程，直到树中的所有节点都妥善放置。</li>\n\t<li>任意空单元格都应该包含空字符串 <code>\"\"</code> 。</li>\n</ul>\n\n<p>返回构造得到的矩阵<em> </em><code>res</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/print1-tree.jpg\" style=\"width: 141px; height: 181px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2]\n<strong>输出：</strong>\n[[\"\",\"1\",\"\"],\n&nbsp;[\"2\",\"\",\"\"]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/print2-tree.jpg\" style=\"width: 207px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,null,4]\n<strong>输出：</strong>\n[[\"\",\"\",\"\",\"1\",\"\",\"\",\"\"],\n&nbsp;[\"\",\"2\",\"\",\"\",\"\",\"3\",\"\"],\n&nbsp;[\"\",\"\",\"4\",\"\",\"\",\"\",\"\"]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数在范围 <code>[1, 2<sup>10</sup>]</code> 内</li>\n\t<li><code>-99 &lt;= Node.val &lt;= 99</code></li>\n\t<li>树的深度在范围 <code>[1, 10]</code> 内</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 656金币路径",
        "hardRate": "HARD",
        "passRate": "34.23%",
        "problemsUrl": "https://leetcode.cn/problems/coin-path/",
        "solutionsUrl": "https://leetcode.cn/problems/coin-path/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 657机器人能否返回原点",
        "hardRate": "EASY",
        "passRate": "78.97%",
        "problemsUrl": "https://leetcode.cn/problems/robot-return-to-origin/",
        "solutionsUrl": "https://leetcode.cn/problems/robot-return-to-origin/solution",
        "problemsDesc": "<p>在二维平面上，有一个机器人从原点 <code>(0, 0)</code> 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在<strong>&nbsp;<code>(0, 0)</code> 处结束</strong>。</p>\n\n<p>移动顺序由字符串&nbsp;<code>moves</code>&nbsp;表示。字符 <code>move[i]</code> 表示其第 <code>i</code> 次移动。机器人的有效动作有&nbsp;<code>R</code>（右），<code>L</code>（左），<code>U</code>（上）和 <code>D</code>（下）。</p>\n\n<p>如果机器人在完成所有动作后返回原点，则返回 <code>true</code>。否则，返回 <code>false</code>。</p>\n\n<p><strong>注意：</strong>机器人“面朝”的方向无关紧要。 <code>“R”</code> 将始终使机器人向右移动一次，<code>“L”</code> 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> moves = \"UD\"\n<strong>输出:</strong> true\n<strong>解释：</strong>机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> moves = \"LL\"\n<strong>输出:</strong> false\n<strong>解释：</strong>机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= moves.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>moves</code>&nbsp;只包含字符&nbsp;<code>'U'</code>,&nbsp;<code>'D'</code>,&nbsp;<code>'L'</code>&nbsp;和&nbsp;<code>'R'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 658找到 K 个最接近的元素",
        "hardRate": "MEDIUM",
        "passRate": "47.90%",
        "problemsUrl": "https://leetcode.cn/problems/find-k-closest-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/find-k-closest-elements/solution",
        "problemsDesc": "<p>给定一个 <strong>排序好</strong> 的数组&nbsp;<code>arr</code> ，两个整数 <code>k</code> 和 <code>x</code> ，从数组中找到最靠近 <code>x</code>（两数之差最小）的 <code>k</code> 个数。返回的结果必须要是按升序排好的。</p>\n\n<p>整数 <code>a</code> 比整数 <code>b</code> 更接近 <code>x</code> 需要满足：</p>\n\n<ul>\n\t<li><code>|a - x| &lt; |b - x|</code> 或者</li>\n\t<li><code>|a - x| == |b - x|</code> 且 <code>a &lt; b</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,4,5], k = 4, x = 3\n<strong>输出：</strong>[1,2,3,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,4,5], k = 4, x = -1\n<strong>输出：</strong>[1,2,3,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= arr.length</code></li>\n\t<li><code>1 &lt;= arr.length&nbsp;&lt;= 10<sup>4</sup></code><meta charset=\"UTF-8\" /></li>\n\t<li><code>arr</code>&nbsp;按 <strong>升序</strong> 排列</li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= arr[i], x &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 659分割数组为连续子序列",
        "hardRate": "MEDIUM",
        "passRate": "54.70%",
        "problemsUrl": "https://leetcode.cn/problems/split-array-into-consecutive-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/split-array-into-consecutive-subsequences/solution",
        "problemsDesc": "<p>给你一个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums</code> 。</p>\n\n<p>请你判断是否能在将 <code>nums</code> 分割成 <strong>一个或多个子序列</strong> 的同时满足下述 <strong>两个</strong> 条件：</p>\n\n<div class=\"original__bRMd\">\n<div>\n<ul>\n\t<li>每个子序列都是一个 <strong>连续递增序列</strong>（即，每个整数 <strong>恰好</strong> 比前一个整数大 <strong>1</strong> ）。</li>\n\t<li>所有子序列的长度 <strong>至少</strong> 为 <code>3</code><strong> </strong>。</li>\n</ul>\n\n<p>如果可以分割 <code>nums</code> 并满足上述条件，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,3,4,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>nums 可以分割成以下子序列：\n[<em><strong>1</strong></em>,<em><strong>2</strong></em>,<em><strong>3</strong></em>,3,4,5] --&gt; 1, 2, 3\n[1,2,3,<em><strong>3</strong></em>,<em><strong>4</strong></em>,<em><strong>5</strong></em>] --&gt; 3, 4, 5\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,3,4,4,5,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>nums 可以分割成以下子序列：\n[<em><strong>1</strong></em>,<em><strong>2</strong></em>,<em><strong>3</strong></em>,3,<em><strong>4</strong></em>,4,<em><strong>5</strong></em>,5] --&gt; 1, 2, 3, 4, 5\n[1,2,3,<em><strong>3</strong></em>,4,<em><strong>4</strong></em>,5,<em><strong>5</strong></em>] --&gt; 3, 4, 5\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4,4,5]\n<strong>输出：</strong>false\n<strong>解释：</strong>无法将 nums 分割成长度至少为 3 的连续递增子序列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>nums</code> 按非递减顺序排列</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 660移除 9",
        "hardRate": "HARD",
        "passRate": "64.98%",
        "problemsUrl": "https://leetcode.cn/problems/remove-9/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-9/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 661图片平滑器",
        "hardRate": "EASY",
        "passRate": "64.18%",
        "problemsUrl": "https://leetcode.cn/problems/image-smoother/",
        "solutionsUrl": "https://leetcode.cn/problems/image-smoother/solution",
        "problemsDesc": "<p><strong>图像平滑器</strong> 是大小为&nbsp;<code>3 x 3</code> 的过滤器，用于对图像的每个单元格平滑处理，平滑处理后单元格的值为该单元格的平均灰度。</p>\n\n<p>每个单元格的<strong>&nbsp; 平均灰度</strong> 定义为：该单元格自身及其周围的 8 个单元格的平均值，结果需向下取整。（即，需要计算蓝色平滑器中 9 个单元格的平均值）。</p>\n\n<p>如果一个单元格周围存在单元格缺失的情况，则计算平均灰度时不考虑缺失的单元格（即，需要计算红色平滑器中 4 个单元格的平均值）。</p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/05/03/smoother-grid.jpg\" style=\"height: 493px; width: 493px;\" /></p>\n\n<p>给你一个表示图像灰度的 <code>m x n</code> 整数矩阵 <code>img</code> ，返回对图像的每个单元格平滑处理后的图像&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/05/03/smooth-grid.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong>img = [[1,1,1],[1,0,1],[1,1,1]]\n<strong>输出:</strong>[[0, 0, 0],[0, 0, 0], [0, 0, 0]]\n<strong>解释:</strong>\n对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0\n对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0\n对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0\n</pre>\n\n<p><strong>示例 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/smooth2-grid.jpg\" />\n<pre>\n<strong>输入:</strong> img = [[100,200,100],[200,50,200],[100,200,100]]\n<strong>输出:</strong> [[137,141,137],[141,138,141],[137,141,137]]\n<strong>解释:</strong>\n对于点 (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137\n对于点 (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141\n对于点 (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>m == img.length</code></li>\n\t<li><code>n == img[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= img[i][j] &lt;= 255</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 662二叉树最大宽度",
        "hardRate": "MEDIUM",
        "passRate": "43.65%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-width-of-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-width-of-binary-tree/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点 <code>root</code> ，返回树的 <strong>最大宽度</strong> 。</p>\n\n<p>树的 <strong>最大宽度</strong> 是所有层中最大的 <strong>宽度</strong> 。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>每一层的 <strong>宽度</strong> 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 <code>null</code> 节点，这些 <code>null</code> 节点也计入长度。</p>\n\n<p>题目数据保证答案将会在&nbsp; <strong>32 位</strong> 带符号整数范围内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/width1-tree.jpg\" style=\"width: 359px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>root = [1,3,2,5,3,null,9]\n<strong>输出：</strong>4\n<strong>解释：</strong>最大宽度出现在树的第 3 层，宽度为 4 (5,3,null,9) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/14/maximum-width-of-binary-tree-v3.jpg\" style=\"width: 442px; height: 422px;\" />\n<pre>\n<strong>输入：</strong>root = [1,3,2,5,null,null,9,6,null,7]\n<strong>输出：</strong>7\n<strong>解释：</strong>最大宽度出现在树的第 4 层，宽度为 7 (6,null,null,null,null,null,7) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/width3-tree.jpg\" style=\"width: 289px; height: 299px;\" />\n<pre>\n<strong>输入：</strong>root = [1,3,2,5]\n<strong>输出：</strong>2\n<strong>解释：</strong>最大宽度出现在树的第 2 层，宽度为 2 (3,2) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目范围是 <code>[1, 3000]</code></li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 663均匀树划分",
        "hardRate": "MEDIUM",
        "passRate": "45.93%",
        "problemsUrl": "https://leetcode.cn/problems/equal-tree-partition/",
        "solutionsUrl": "https://leetcode.cn/problems/equal-tree-partition/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 664奇怪的打印机",
        "hardRate": "HARD",
        "passRate": "65.32%",
        "problemsUrl": "https://leetcode.cn/problems/strange-printer/",
        "solutionsUrl": "https://leetcode.cn/problems/strange-printer/solution",
        "problemsDesc": "<p>有台奇怪的打印机有以下两个特殊要求：</p>\n\n<ul>\n\t<li>打印机每次只能打印由 <strong>同一个字符</strong> 组成的序列。</li>\n\t<li>每次可以在从起始到结束的任意位置打印新字符，并且会覆盖掉原来已有的字符。</li>\n</ul>\n\n<p>给你一个字符串 <code>s</code> ，你的任务是计算这个打印机打印它需要的最少打印次数。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aaabbb\"\n<strong>输出：</strong>2\n<strong>解释：</strong>首先打印 \"aaa\" 然后打印 \"bbb\"。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aba\"\n<strong>输出：</strong>2\n<strong>解释：</strong>首先打印 \"aaa\" 然后在第二个位置打印 \"b\" 覆盖掉原来的字符 'a'。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 665非递减数列",
        "hardRate": "MEDIUM",
        "passRate": "27.67%",
        "problemsUrl": "https://leetcode.cn/problems/non-decreasing-array/",
        "solutionsUrl": "https://leetcode.cn/problems/non-decreasing-array/solution",
        "problemsDesc": "<p>给你一个长度为&nbsp;<code>n</code>&nbsp;的整数数组<meta charset=\"UTF-8\" />&nbsp;<code>nums</code>&nbsp;，请你判断在 <strong>最多 </strong>改变&nbsp;<code>1</code> 个元素的情况下，该数组能否变成一个非递减数列。</p>\n\n<p>我们是这样定义一个非递减数列的：&nbsp;对于数组中任意的&nbsp;<code>i</code> <code>(0 &lt;= i &lt;= n-2)</code>，总满足 <code>nums[i] &lt;= nums[i + 1]</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [4,2,3]\n<strong>输出:</strong> true\n<strong>解释:</strong> 你可以通过把第一个 4 变成 1 来使得它成为一个非递减数列。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [4,2,1]\n<strong>输出:</strong> false\n<strong>解释:</strong> 你不能在只改变一个元素的情况下将其变为非递减数列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 666路径总和 IV",
        "hardRate": "MEDIUM",
        "passRate": "62.66%",
        "problemsUrl": "https://leetcode.cn/problems/path-sum-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/path-sum-iv/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 667优美的排列 II",
        "hardRate": "MEDIUM",
        "passRate": "66.73%",
        "problemsUrl": "https://leetcode.cn/problems/beautiful-arrangement-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/beautiful-arrangement-ii/solution",
        "problemsDesc": "<p>给你两个整数 <code>n</code> 和 <code>k</code> ，请你构造一个答案列表 <code>answer</code> ，该列表应当包含从 <code>1</code> 到 <code>n</code> 的 <code>n</code> 个不同正整数，并同时满足下述条件：</p>\n\n<ul>\n\t<li>假设该列表是 <code>answer = [a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, ... , a<sub>n</sub>]</code> ，那么列表 <code>[|a<sub>1</sub> - a<sub>2</sub>|, |a<sub>2</sub> - a<sub>3</sub>|, |a<sub>3</sub> - a<sub>4</sub>|, ... , |a<sub>n-1</sub> - a<sub>n</sub>|]</code> 中应该有且仅有 <code>k</code> 个不同整数。</li>\n</ul>\n\n<p>返回列表 <code>answer</code> 。如果存在多种答案，只需返回其中 <strong>任意一种</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 1\n<strong>输出：</strong>[1, 2, 3]\n<strong>解释：</strong>[1, 2, 3] 包含 3 个范围在 1-3 的不同整数，并且 [1, 1] 中有且仅有 1 个不同整数：1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 2\n<strong>输出：</strong>[1, 3, 2]\n<strong>解释：</strong>[1, 3, 2] 包含 3 个范围在 1-3 的不同整数，并且 [2, 1] 中有且仅有 2 个不同整数：1 和 2\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= k < n <= 10<sup>4</sup></code></li>\n</ul>\n\n<p> </p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 668乘法表中第k小的数",
        "hardRate": "HARD",
        "passRate": "58.56%",
        "problemsUrl": "https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/solution",
        "problemsDesc": "<p>几乎每一个人都用&nbsp;<a href=\"https://baike.baidu.com/item/%E4%B9%98%E6%B3%95%E8%A1%A8\">乘法表</a>。但是你能在乘法表中快速找到第 <code>k</code> 小的数字吗？</p>\n\n<p>乘法表是大小为 <code>m x n</code> 的一个整数矩阵，其中&nbsp;<code>mat[i][j] == i * j</code>（下标从 <strong>1</strong> 开始）。</p>\n\n<p>给你三个整数 <code>m</code>、<code>n</code> 和 <code>k</code>，请你在大小为&nbsp;<code>m x n</code> 的乘法表中，找出并返回第 <code>k</code>&nbsp;小的数字。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/02/multtable1-grid.jpg\" style=\"width: 500px; height: 254px;\" />\n<pre>\n<strong>输入：</strong>m = 3, n = 3, k = 5\n<strong>输出：</strong>3\n<strong>解释：</strong>第 5 小的数字是 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/02/multtable2-grid.jpg\" style=\"width: 493px; height: 293px;\" />\n<pre>\n<strong>输入：</strong>m = 2, n = 3, k = 6\n<strong>输出：</strong>6\n<strong>解释：</strong>第 6 小的数字是 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= m * n</code></li>\n</ul>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 669修剪二叉搜索树",
        "hardRate": "MEDIUM",
        "passRate": "67.47%",
        "problemsUrl": "https://leetcode.cn/problems/trim-a-binary-search-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/trim-a-binary-search-tree/solution",
        "problemsDesc": "<p>给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界<code>low</code> 和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树 <strong>不应该</strong>&nbsp;改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在&nbsp;<strong>唯一的答案</strong>&nbsp;。</p>\n\n<p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg\" style=\"height: 126px; width: 450px;\" />\n<pre>\n<strong>输入：</strong>root = [1,0,2], low = 1, high = 2\n<strong>输出：</strong>[1,null,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg\" style=\"height: 277px; width: 450px;\" />\n<pre>\n<strong>输入：</strong>root = [3,0,4,null,2,null,null,1], low = 1, high = 3\n<strong>输出：</strong>[3,2,null,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数在范围 <code>[1, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>树中每个节点的值都是 <strong>唯一</strong> 的</li>\n\t<li>题目数据保证输入是一棵有效的二叉搜索树</li>\n\t<li><code>0 &lt;= low &lt;= high &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 670最大交换",
        "hardRate": "MEDIUM",
        "passRate": "47.89%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-swap/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-swap/solution",
        "problemsDesc": "<p>给定一个非负整数，你<strong>至多</strong>可以交换一次数字中的任意两位。返回你能得到的最大值。</p>\n\n<p><strong>示例 1 :</strong></p>\n\n<pre>\n<strong>输入:</strong> 2736\n<strong>输出:</strong> 7236\n<strong>解释:</strong> 交换数字2和数字7。\n</pre>\n\n<p><strong>示例 2 :</strong></p>\n\n<pre>\n<strong>输入:</strong> 9973\n<strong>输出:</strong> 9973\n<strong>解释:</strong> 不需要交换。\n</pre>\n\n<p><strong>注意:</strong></p>\n\n<ol>\n\t<li>给定数字的范围是&nbsp;[0, 10<sup>8</sup>]</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 671二叉树中第二小的节点",
        "hardRate": "EASY",
        "passRate": "48.00%",
        "problemsUrl": "https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/solution",
        "problemsDesc": "<p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为&nbsp;<code>2</code>&nbsp;或&nbsp;<code>0</code>。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</p>\n\n<p>更正式地说，即&nbsp;<code>root.val = min(root.left.val, root.right.val)</code> 总成立。</p>\n\n<p>给出这样的一个二叉树，你需要输出所有节点中的&nbsp;<strong>第二小的值 </strong>。</p>\n\n<p>如果第二小的值不存在的话，输出 -1 <strong>。</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/smbt1.jpg\" style=\"height: 210px; width: 300px;\" />\n<pre>\n<strong>输入：</strong>root = [2,2,5,null,null,5,7]\n<strong>输出：</strong>5\n<strong>解释：</strong>最小的值是 2 ，第二小的值是 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/smbt2.jpg\" style=\"height: 113px; width: 200px;\" />\n<pre>\n<strong>输入：</strong>root = [2,2,2]\n<strong>输出：</strong>-1\n<strong>解释：</strong>最小的值是 2, 但是不存在第二小的值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[1, 25]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>对于树中每个节点 <code>root.val == min(root.left.val, root.right.val)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 672灯泡开关 Ⅱ",
        "hardRate": "MEDIUM",
        "passRate": "60.78%",
        "problemsUrl": "https://leetcode.cn/problems/bulb-switcher-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/bulb-switcher-ii/solution",
        "problemsDesc": "<p>房间中有 <code>n</code>&nbsp;只已经打开的灯泡，编号从 <code>1</code> 到 <code>n</code> 。墙上挂着 <strong>4 个开关</strong> 。</p>\n\n<p>这 4 个开关各自都具有不同的功能，其中：</p>\n\n<ul>\n\t<li><strong>开关 1 ：</strong>反转当前所有灯的状态（即开变为关，关变为开）</li>\n\t<li><strong>开关 2 ：</strong>反转编号为偶数的灯的状态（即 <code>0, 2, 4, ...</code>）</li>\n\t<li><strong>开关 3 ：</strong>反转编号为奇数的灯的状态（即 <code>1, 3, ...</code>）</li>\n\t<li><strong>开关 4 ：</strong>反转编号为 <code>j = 3k + 1</code> 的灯的状态，其中 <code>k = 0, 1, 2, ...</code>（即 <code>1, 4, 7, 10, ...</code>）</li>\n</ul>\n\n<p>你必须 <strong>恰好</strong> 按压开关 <code>presses</code> 次。每次按压，你都需要从 4 个开关中选出一个来执行按压操作。</p>\n\n<p>给你两个整数 <code>n</code> 和 <code>presses</code> ，执行完所有按压之后，返回 <strong>不同可能状态</strong> 的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, presses = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>状态可以是：\n- 按压开关 1 ，[关]\n- 按压开关 2 ，[开]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, presses = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>状态可以是：\n- 按压开关 1 ，[关, 关]\n- 按压开关 2 ，[开, 关]\n- 按压开关 3 ，[关, 开]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, presses = 1\n<strong>输出：</strong>4\n<strong>解释：</strong>状态可以是：\n- 按压开关 1 ，[关, 关, 关]\n- 按压开关 2 ，[关, 开, 关]\n- 按压开关 3 ，[开, 关, 开]\n- 按压开关 4 ，[关, 开, 开]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= presses &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 673最长递增子序列的个数",
        "hardRate": "MEDIUM",
        "passRate": "44.64%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-longest-increasing-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-longest-increasing-subsequence/solution",
        "problemsDesc": "<p>给定一个未排序的整数数组<meta charset=\"UTF-8\" />&nbsp;<code>nums</code>&nbsp;，&nbsp;<em>返回最长递增子序列的个数</em>&nbsp;。</p>\n\n<p><strong>注意</strong>&nbsp;这个数列必须是 <strong>严格</strong> 递增的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> [1,3,5,4,7]\n<strong>输出:</strong> 2\n<strong>解释:</strong> 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> [2,2,2,2,2]\n<strong>输出:</strong> 5\n<strong>解释:</strong> 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2000</code></li>\n\t<li><code>-10<sup>6</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 674最长连续递增序列",
        "hardRate": "EASY",
        "passRate": "55.63%",
        "problemsUrl": "https://leetcode.cn/problems/longest-continuous-increasing-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-continuous-increasing-subsequence/solution",
        "problemsDesc": "<p>给定一个未经排序的整数数组，找到最长且<strong> 连续递增的子序列</strong>，并返回该序列的长度。</p>\n\n<p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l < r</code>）确定，如果对于每个 <code>l <= i < r</code>，都有 <code>nums[i] < nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,5,4,7]\n<strong>输出：</strong>3\n<strong>解释：</strong>最长连续递增序列是 [1,3,5], 长度为3。\n尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,2,2,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>最长连续递增序列是 [2], 长度为1。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 675为高尔夫比赛砍树",
        "hardRate": "HARD",
        "passRate": "52.45%",
        "problemsUrl": "https://leetcode.cn/problems/cut-off-trees-for-golf-event/",
        "solutionsUrl": "https://leetcode.cn/problems/cut-off-trees-for-golf-event/solution",
        "problemsDesc": "<p>你被请来给一个要举办高尔夫比赛的树林砍树。树林由一个 <code>m x n</code> 的矩阵表示， 在这个矩阵中：</p>\n\n<ul>\n\t<li><code>0</code> 表示障碍，无法触碰</li>\n\t<li><code>1</code> 表示地面，可以行走</li>\n\t<li><code>比 1 大的数</code> 表示有树的单元格，可以行走，数值表示树的高度</li>\n</ul>\n\n<p>每一步，你都可以向上、下、左、右四个方向之一移动一个单位，如果你站的地方有一棵树，那么你可以决定是否要砍倒它。</p>\n\n<p>你需要按照树的高度从低向高砍掉所有的树，每砍过一颗树，该单元格的值变为 <code>1</code>（即变为地面）。</p>\n\n<p>你将从 <code>(0, 0)</code> 点开始工作，返回你砍完所有树需要走的最小步数。 如果你无法砍完所有的树，返回 <code>-1</code> 。</p>\n\n<p>可以保证的是，没有两棵树的高度是相同的，并且你至少需要砍倒一棵树。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/trees1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>forest = [[1,2,3],[0,0,4],[7,6,5]]\n<strong>输出：</strong>6\n<strong>解释：</strong>沿着上面的路径，你可以用 6 步，按从最矮到最高的顺序砍掉这些树。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/trees2.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>forest = [[1,2,3],[0,0,0],[7,6,5]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>由于中间一行被障碍阻塞，无法访问最下面一行中的树。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>forest = [[2,3,4],[0,0,5],[8,7,6]]\n<strong>输出：</strong>6\n<strong>解释：</strong>可以按与示例 1 相同的路径来砍掉所有的树。\n(0,0) 位置的树，可以直接砍去，不用算步数。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == forest.length</code></li>\n\t<li><code>n == forest[i].length</code></li>\n\t<li><code>1 <= m, n <= 50</code></li>\n\t<li><code>0 <= forest[i][j] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 676实现一个魔法字典",
        "hardRate": "MEDIUM",
        "passRate": "65.27%",
        "problemsUrl": "https://leetcode.cn/problems/implement-magic-dictionary/",
        "solutionsUrl": "https://leetcode.cn/problems/implement-magic-dictionary/solution",
        "problemsDesc": "<p>设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 <strong>互不相同</strong> 。 如果给出一个单词，请判定能否只将这个单词中<strong>一个</strong>字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。</p>\n\n<p>实现 <code>MagicDictionary</code> 类：</p>\n\n<ul>\n\t<li><code>MagicDictionary()</code> 初始化对象</li>\n\t<li><code>void buildDict(String[] dictionary)</code> 使用字符串数组 <code>dictionary</code> 设定该数据结构，<code>dictionary</code> 中的字符串互不相同</li>\n\t<li><code>bool search(String searchWord)</code> 给定一个字符串 <code>searchWord</code> ，判定能否只将字符串中<strong> 一个 </strong>字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n</ul>\n\n<p> </p>\n\n<div class=\"top-view__1vxA\">\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"]\n[[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]\n<strong>输出</strong>\n[null, null, false, true, false, false]\n\n<strong>解释</strong>\nMagicDictionary magicDictionary = new MagicDictionary();\nmagicDictionary.buildDict([\"hello\", \"leetcode\"]);\nmagicDictionary.search(\"hello\"); // 返回 False\nmagicDictionary.search(\"hhllo\"); // 将第二个 'h' 替换为 'e' 可以匹配 \"hello\" ，所以返回 True\nmagicDictionary.search(\"hell\"); // 返回 False\nmagicDictionary.search(\"leetcoded\"); // 返回 False\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= dictionary.length <= 100</code></li>\n\t<li><code>1 <= dictionary[i].length <= 100</code></li>\n\t<li><code>dictionary[i]</code> 仅由小写英文字母组成</li>\n\t<li><code>dictionary</code> 中的所有字符串 <strong>互不相同</strong></li>\n\t<li><code>1 <= searchWord.length <= 100</code></li>\n\t<li><code>searchWord</code> 仅由小写英文字母组成</li>\n\t<li><code>buildDict</code> 仅在 <code>search</code> 之前调用一次</li>\n\t<li>最多调用 <code>100</code> 次 <code>search</code></li>\n</ul>\n</div>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 677键值映射",
        "hardRate": "MEDIUM",
        "passRate": "65.67%",
        "problemsUrl": "https://leetcode.cn/problems/map-sum-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/map-sum-pairs/solution",
        "problemsDesc": "<p>设计一个 map ，满足以下几点:</p>\n\n<ul>\n\t<li>字符串表示键，整数表示值</li>\n\t<li>返回具有前缀等于给定字符串的键的值的总和</li>\n</ul>\n\n<p>实现一个 <code>MapSum</code> 类：</p>\n\n<ul>\n\t<li><code>MapSum()</code> 初始化 <code>MapSum</code> 对象</li>\n\t<li><code>void insert(String key, int val)</code> 插入 <code>key-val</code> 键值对，字符串表示键 <code>key</code> ，整数表示值 <code>val</code> 。如果键 <code>key</code> 已经存在，那么原来的键值对&nbsp;<code>key-value</code>&nbsp;将被替代成新的键值对。</li>\n\t<li><code>int sum(string prefix)</code> 返回所有以该前缀 <code>prefix</code> 开头的键 <code>key</code> 的值的总和。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"]\n[[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]\n<strong>输出：</strong>\n[null, null, 3, null, 5]\n\n<strong>解释：</strong>\nMapSum mapSum = new MapSum();\nmapSum.insert(\"apple\", 3);  \nmapSum.sum(\"ap\");           // 返回 3 (<u>ap</u>ple = 3)\nmapSum.insert(\"app\", 2);    \nmapSum.sum(\"ap\");           // 返回 5 (<u>ap</u>ple + <u>ap</u>p = 3 + 2 = 5)\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= key.length, prefix.length &lt;= 50</code></li>\n\t<li><code>key</code> 和 <code>prefix</code> 仅由小写英文字母组成</li>\n\t<li><code>1 &lt;= val &lt;= 1000</code></li>\n\t<li>最多调用 <code>50</code> 次 <code>insert</code> 和 <code>sum</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 678有效的括号字符串",
        "hardRate": "MEDIUM",
        "passRate": "39.25%",
        "problemsUrl": "https://leetcode.cn/problems/valid-parenthesis-string/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-parenthesis-string/solution",
        "problemsDesc": "<p>给你一个只包含三种字符的字符串，支持的字符类型分别是 <code>'('</code>、<code>')'</code> 和 <code>'*'</code>。请你检验这个字符串是否为有效字符串，如果是有效字符串返回 <code>true</code> 。</p>\n\n<p>有效字符串符合如下规则：</p>\n\n<ul>\n\t<li>任何左括号 <code>'('</code>&nbsp;必须有相应的右括号 <code>')'</code>。</li>\n\t<li>任何右括号 <code>')'</code>&nbsp;必须有相应的左括号 <code>'('</code>&nbsp;。</li>\n\t<li>左括号 <code>'('</code> 必须在对应的右括号之前 <code>')'</code>。</li>\n\t<li><code>'*'</code>&nbsp;可以被视为单个右括号 <code>')'</code>&nbsp;，或单个左括号 <code>'('</code>&nbsp;，或一个空字符串。</li>\n\t<li>一个空字符串也被视为有效字符串。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"()\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(*)\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(*))\"\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s[i]</code> 为 <code>'('</code>、<code>')'</code> 或 <code>'*'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 67924 点游戏",
        "hardRate": "HARD",
        "passRate": "53.80%",
        "problemsUrl": "https://leetcode.cn/problems/24-game/",
        "solutionsUrl": "https://leetcode.cn/problems/24-game/solution",
        "problemsDesc": "<p>给定一个长度为4的整数数组&nbsp;<code>cards</code>&nbsp;。你有 <code>4</code> 张卡片，每张卡片上都包含一个范围在 <code>[1,9]</code> 的数字。您应该使用运算符&nbsp;<code>['+', '-', '*', '/']</code>&nbsp;和括号&nbsp;<code>'('</code>&nbsp;和&nbsp;<code>')'</code>&nbsp;将这些卡片上的数字排列成数学表达式，以获得值24。</p>\n\n<p>你须遵守以下规则:</p>\n\n<ul>\n\t<li>除法运算符 <code>'/'</code> 表示实数除法，而不是整数除法。\n\n\t<ul>\n\t\t<li>例如，&nbsp;<code>4 /(1 - 2 / 3)= 4 /(1 / 3)= 12</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n\t<li>每个运算都在两个数字之间。特别是，不能使用 <code>“-”</code> 作为一元运算符。\n\t<ul>\n\t\t<li>例如，如果 <code>cards =[1,1,1,1]</code> ，则表达式 <code>“-1 -1 -1 -1”</code> 是 <strong>不允许</strong> 的。</li>\n\t</ul>\n\t</li>\n\t<li>你不能把数字串在一起\n\t<ul>\n\t\t<li>例如，如果 <code>cards =[1,2,1,2]</code> ，则表达式 <code>“12 + 12”</code> 无效。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>如果可以得到这样的表达式，其计算结果为 <code>24</code> ，则返回 <code>true </code>，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> cards = [4, 1, 8, 7]\n<strong>输出:</strong> true\n<strong>解释:</strong> (8-4) * (7-1) = 24\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> cards = [1, 2, 1, 2]\n<strong>输出:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>cards.length == 4</code></li>\n\t<li><code>1 &lt;= cards[i] &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 680验证回文串 II",
        "hardRate": "EASY",
        "passRate": "39.98%",
        "problemsUrl": "https://leetcode.cn/problems/valid-palindrome-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-palindrome-ii/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>，<strong>最多</strong> 可以从中删除一个字符。</p>\n\n<p>请你判断 <code>s</code> 是否能成为回文字符串：如果能，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aba\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abca\"\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以删除字符 'c' 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\"\n<strong>输出：</strong>false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 681最近时刻",
        "hardRate": "MEDIUM",
        "passRate": "49.88%",
        "problemsUrl": "https://leetcode.cn/problems/next-closest-time/",
        "solutionsUrl": "https://leetcode.cn/problems/next-closest-time/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 682棒球比赛",
        "hardRate": "EASY",
        "passRate": "71.29%",
        "problemsUrl": "https://leetcode.cn/problems/baseball-game/",
        "solutionsUrl": "https://leetcode.cn/problems/baseball-game/solution",
        "problemsDesc": "<p>你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。</p>\n\n<p>比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 <code>ops</code>，其中 <code>ops[i]</code> 是你需要记录的第 <code>i</code> 项操作，<code>ops</code> 遵循下述规则：</p>\n\n<ol>\n\t<li>整数 <code>x</code> - 表示本回合新获得分数 <code>x</code></li>\n\t<li><code>\"+\"</code> - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。</li>\n\t<li><code>\"D\"</code> - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。</li>\n\t<li><code>\"C\"</code> - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。</li>\n</ol>\n\n<p>请你返回记录中所有得分的总和。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]\n<strong>输出：</strong>30\n<strong>解释：</strong>\n\"5\" - 记录加 5 ，记录现在是 [5]\n\"2\" - 记录加 2 ，记录现在是 [5, 2]\n\"C\" - 使前一次得分的记录无效并将其移除，记录现在是 [5].\n\"D\" - 记录加 2 * 5 = 10 ，记录现在是 [5, 10].\n\"+\" - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15].\n所有得分的总和 5 + 10 + 15 = 30\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\n<strong>输出：</strong>27\n<strong>解释：</strong>\n\"5\" - 记录加 5 ，记录现在是 [5]\n\"-2\" - 记录加 -2 ，记录现在是 [5, -2]\n\"4\" - 记录加 4 ，记录现在是 [5, -2, 4]\n\"C\" - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2]\n\"D\" - 记录加 2 * -2 = -4 ，记录现在是 [5, -2, -4]\n\"9\" - 记录加 9 ，记录现在是 [5, -2, -4, 9]\n\"+\" - 记录加 -4 + 9 = 5 ，记录现在是 [5, -2, -4, 9, 5]\n\"+\" - 记录加 9 + 5 = 14 ，记录现在是 [5, -2, -4, 9, 5, 14]\n所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 = 27\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>ops = [\"1\"]\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= ops.length <= 1000</code></li>\n\t<li><code>ops[i]</code> 为 <code>\"C\"</code>、<code>\"D\"</code>、<code>\"+\"</code>，或者一个表示整数的字符串。整数范围是 <code>[-3 * 10<sup>4</sup>, 3 * 10<sup>4</sup>]</code></li>\n\t<li>对于 <code>\"+\"</code> 操作，题目数据保证记录此操作时前面总是存在两个有效的分数</li>\n\t<li>对于 <code>\"C\"</code> 和 <code>\"D\"</code> 操作，题目数据保证记录此操作时前面总是存在一个有效的分数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 683K 个关闭的灯泡",
        "hardRate": "HARD",
        "passRate": "45.92%",
        "problemsUrl": "https://leetcode.cn/problems/k-empty-slots/",
        "solutionsUrl": "https://leetcode.cn/problems/k-empty-slots/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 684冗余连接",
        "hardRate": "MEDIUM",
        "passRate": "67.42%",
        "problemsUrl": "https://leetcode.cn/problems/redundant-connection/",
        "solutionsUrl": "https://leetcode.cn/problems/redundant-connection/solution",
        "problemsDesc": "<p>树可以看成是一个连通且 <strong>无环&nbsp;</strong>的&nbsp;<strong>无向&nbsp;</strong>图。</p>\n\n<p>给定往一棵&nbsp;<code>n</code> 个节点 (节点值&nbsp;<code>1～n</code>) 的树中添加一条边后的图。添加的边的两个顶点包含在 <code>1</code> 到 <code>n</code>&nbsp;中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 <code>n</code> 的二维数组 <code>edges</code>&nbsp;，<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示图中在 <code>ai</code> 和 <code>bi</code> 之间存在一条边。</p>\n\n<p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 <code>n</code> 个节点的树。如果有多个答案，则返回数组&nbsp;<code>edges</code>&nbsp;中最后出现的那个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626676174-hOEVUL-image.png\" style=\"width: 152px; \" /></p>\n\n<pre>\n<strong>输入:</strong> edges = [[1,2], [1,3], [2,3]]\n<strong>输出:</strong> [2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626676179-kGxcmu-image.png\" style=\"width: 250px; \" /></p>\n\n<pre>\n<strong>输入:</strong> edges = [[1,2], [2,3], [3,4], [1,4], [1,5]]\n<strong>输出:</strong> [1,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>3 &lt;= n &lt;= 1000</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 &lt;= ai&nbsp;&lt; bi&nbsp;&lt;= edges.length</code></li>\n\t<li><code>ai != bi</code></li>\n\t<li><code>edges</code> 中无重复元素</li>\n\t<li>给定的图是连通的&nbsp;</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 685冗余连接 II",
        "hardRate": "HARD",
        "passRate": "42.22%",
        "problemsUrl": "https://leetcode.cn/problems/redundant-connection-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/redundant-connection-ii/solution",
        "problemsDesc": "<p>在本问题中，有根树指满足以下条件的 <strong>有向</strong> 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。</p>\n\n<p>输入一个有向图，该图由一个有着 <code>n</code> 个节点（节点值不重复，从 <code>1</code> 到 <code>n</code>）的树及一条附加的有向边构成。附加的边包含在 <code>1</code> 到 <code>n</code> 中的两个不同顶点间，这条附加的边不属于树中已存在的边。</p>\n\n<p>结果图是一个以边组成的二维数组 <code>edges</code> 。 每个元素是一对 <code>[u<sub>i</sub>, v<sub>i</sub>]</code>，用以表示 <strong>有向 </strong>图中连接顶点 <code>u<sub>i</sub></code> 和顶点 <code>v<sub>i</sub></code> 的边，其中 <code>u<sub>i</sub></code> 是 <code>v<sub>i</sub></code> 的一个父节点。</p>\n\n<p>返回一条能删除的边，使得剩下的图是有 <code>n</code> 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/graph1.jpg\" style=\"width: 222px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>edges = [[1,2],[1,3],[2,3]]\n<strong>输出：</strong>[2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/graph2.jpg\" style=\"width: 222px; height: 382px;\" />\n<pre>\n<strong>输入：</strong>edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]\n<strong>输出：</strong>[4,1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>3 <= n <= 1000</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 <= u<sub>i</sub>, v<sub>i</sub> <= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 686重复叠加字符串匹配",
        "hardRate": "MEDIUM",
        "passRate": "39.84%",
        "problemsUrl": "https://leetcode.cn/problems/repeated-string-match/",
        "solutionsUrl": "https://leetcode.cn/problems/repeated-string-match/solution",
        "problemsDesc": "<p>给定两个字符串&nbsp;<code>a</code> 和 <code>b</code>，寻找重复叠加字符串 <code>a</code> 的最小次数，使得字符串 <code>b</code> 成为叠加后的字符串 <code>a</code> 的子串，如果不存在则返回 <code>-1</code>。</p>\n\n<p><strong>注意：</strong>字符串 <code>&quot;abc&quot;</code>&nbsp;重复叠加 0 次是 <code>&quot;&quot;</code>，重复叠加 1 次是&nbsp;<code>&quot;abc&quot;</code>，重复叠加 2 次是&nbsp;<code>&quot;abcabc&quot;</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>a = &quot;abcd&quot;, b = &quot;cdabcdab&quot;\n<strong>输出：</strong>3\n<strong>解释：</strong>a 重复叠加三遍后为 &quot;ab<strong>cdabcdab</strong>cd&quot;, 此时 b 是其子串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>a = &quot;a&quot;, b = &quot;aa&quot;\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>a = &quot;a&quot;, b = &quot;a&quot;\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>a = &quot;abc&quot;, b = &quot;wxyz&quot;\n<strong>输出：</strong>-1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= b.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>a</code> 和 <code>b</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 687最长同值路径",
        "hardRate": "MEDIUM",
        "passRate": "47.65%",
        "problemsUrl": "https://leetcode.cn/problems/longest-univalue-path/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-univalue-path/solution",
        "problemsDesc": "<p>给定一个二叉树的<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;，返回&nbsp;<em>最长的路径的长度</em> ，这个路径中的&nbsp;<em>每个节点具有相同值</em>&nbsp;。 这条路径可以经过也可以不经过根节点。</p>\n\n<p><strong>两个节点之间的路径长度</strong>&nbsp;由它们之间的边数表示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/ex1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,4,5,1,1,5]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/ex2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,4,5,4,4,5]\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>树的节点数的范围是<meta charset=\"UTF-8\" />&nbsp;<code>[0, 10<sup>4</sup>]</code>&nbsp;</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li>树的深度将不超过 <code>1000</code>&nbsp;</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 688骑士在棋盘上的概率",
        "hardRate": "MEDIUM",
        "passRate": "58.15%",
        "problemsUrl": "https://leetcode.cn/problems/knight-probability-in-chessboard/",
        "solutionsUrl": "https://leetcode.cn/problems/knight-probability-in-chessboard/solution",
        "problemsDesc": "<p>在一个&nbsp;<code>n x n</code>&nbsp;的国际象棋棋盘上，一个骑士从单元格 <code>(row, column)</code>&nbsp;开始，并尝试进行 <code>k</code> 次移动。行和列是 <strong>从 0 开始</strong> 的，所以左上单元格是 <code>(0,0)</code> ，右下单元格是 <code>(n - 1, n - 1)</code> 。</p>\n\n<p>象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。</p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/knight.png\" style=\"height: 300px; width: 300px;\" /></p>\n\n<p>每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。</p>\n\n<p>骑士继续移动，直到它走了 <code>k</code> 步或离开了棋盘。</p>\n\n<p>返回 <em>骑士在棋盘停止移动后仍留在棋盘上的概率</em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 3, k = 2, row = 0, column = 0\n<strong>输出:</strong> 0.0625\n<strong>解释:</strong> 有两步(到(1,2)，(2,1))可以让骑士留在棋盘上。\n在每一个位置上，也有两种移动可以让骑士留在棋盘上。\n骑士留在棋盘上的总概率是0.0625。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 1, k = 0, row = 0, column = 0\n<strong>输出:</strong> 1.00000\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 25</code></li>\n\t<li><code>0 &lt;= k &lt;= 100</code></li>\n\t<li><code>0 &lt;= row, column &lt;= n - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 689三个无重叠子数组的最大和",
        "hardRate": "HARD",
        "passRate": "56.18%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-of-3-non-overlapping-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-of-3-non-overlapping-subarrays/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，找出三个长度为 <code>k</code> 、互不重叠、且全部数字和（<code>3 * k</code> 项）最大的子数组，并返回这三个子数组。</p>\n\n<p>以下标的数组形式返回结果，数组中的每一项分别指示每个子数组的起始位置（下标从 <strong>0</strong> 开始）。如果有多个结果，返回字典序最小的一个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,2,6,7,5,1], k = 2\n<strong>输出：</strong>[0,3,5]\n<strong>解释：</strong>子数组 [1, 2], [2, 6], [7, 5] 对应的起始下标为 [0, 3, 5]。\n也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,2,1,2,1,2,1], k = 2\n<strong>输出：</strong>[0,2,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;&nbsp;2<sup>16</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= floor(nums.length / 3)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 690员工的重要性",
        "hardRate": "MEDIUM",
        "passRate": "65.70%",
        "problemsUrl": "https://leetcode.cn/problems/employee-importance/",
        "solutionsUrl": "https://leetcode.cn/problems/employee-importance/solution",
        "problemsDesc": "<p>给定一个保存员工信息的数据结构，它包含了员工 <strong>唯一的 id </strong>，<strong>重要度 </strong>和 <strong>直系下属的 id </strong>。</p>\n\n<p>比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。注意虽然员工 3 也是员工 1 的一个下属，但是由于 <strong>并不是直系</strong> 下属，因此没有体现在员工 1 的数据结构中。</p>\n\n<p>现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1\n<strong>输出：</strong>11\n<strong>解释：</strong>\n员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1 的总重要度是 5 + 3 + 3 = 11 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>一个员工最多有一个<strong> 直系 </strong>领导，但是可以有多个 <strong>直系 </strong>下属</li>\n\t<li>员工数量不超过 2000 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 691贴纸拼词",
        "hardRate": "HARD",
        "passRate": "58.81%",
        "problemsUrl": "https://leetcode.cn/problems/stickers-to-spell-word/",
        "solutionsUrl": "https://leetcode.cn/problems/stickers-to-spell-word/solution",
        "problemsDesc": "<p>我们有 <code>n</code> 种不同的贴纸。每个贴纸上都有一个小写的英文单词。</p>\n\n<p>您想要拼写出给定的字符串 <code>target</code>&nbsp;，方法是从收集的贴纸中切割单个字母并重新排列它们。如果你愿意，你可以多次使用每个贴纸，每个贴纸的数量是无限的。</p>\n\n<p>返回你需要拼出 <code>target</code>&nbsp;的最小贴纸数量。如果任务不可能，则返回 <code>-1</code> 。</p>\n\n<p><strong>注意：</strong>在所有的测试用例中，所有的单词都是从 <code>1000</code> 个最常见的美国英语单词中随机选择的，并且 <code>target</code>&nbsp;被选择为两个随机单词的连接。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong> stickers = [\"with\",\"example\",\"science\"], target = \"thehat\"\n<b>输出：</b>3\n<strong>解释：\n</strong>我们可以使用 2 个 \"with\" 贴纸，和 1 个 \"example\" 贴纸。\n把贴纸上的字母剪下来并重新排列后，就可以形成目标 “thehat“ 了。\n此外，这是形成目标字符串所需的最小贴纸数量。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<b>输入：</b>stickers = [\"notice\",\"possible\"], target = \"basicbasic\"\n<b>输出：</b>-1\n<strong>解释：</strong>我们不能通过剪切给定贴纸的字母来形成目标“basicbasic”。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>n == stickers.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>1 &lt;= stickers[i].length &lt;= 10</code></li>\n\t<li><code>1 &lt;= target.length &lt;= 15</code></li>\n\t<li><code>stickers[i]</code>&nbsp;和&nbsp;<code>target</code>&nbsp;由小写英文单词组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 692前K个高频单词",
        "hardRate": "MEDIUM",
        "passRate": "56.23%",
        "problemsUrl": "https://leetcode.cn/problems/top-k-frequent-words/",
        "solutionsUrl": "https://leetcode.cn/problems/top-k-frequent-words/solution",
        "problemsDesc": "<p>给定一个单词列表&nbsp;<code>words</code>&nbsp;和一个整数 <code>k</code> ，返回前&nbsp;<code>k</code><em>&nbsp;</em>个出现次数最多的单词。</p>\n\n<p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， <strong>按字典顺序</strong> 排序。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> words = [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\n<strong>输出:</strong> [\"i\", \"love\"]\n<strong>解析:</strong> \"i\" 和 \"love\" 为出现次数最多的两个单词，均为2次。\n    注意，按字母顺序 \"i\" 在 \"love\" 之前。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\n<strong>输出:</strong> [\"the\", \"is\", \"sunny\", \"day\"]\n<strong>解析:</strong> \"the\", \"is\", \"sunny\" 和 \"day\" 是出现次数最多的四个单词，\n    出现次数依次为 4, 3, 2 和 1 次。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= words[i] &lt;= 10</code></li>\n\t<li><code>words[i]</code>&nbsp;由小写英文字母组成。</li>\n\t<li><code>k</code> 的取值范围是&nbsp;<code>[1, <strong>不同</strong> words[i] 的数量]</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>尝试以&nbsp;<code>O(n log k)</code> 时间复杂度和&nbsp;<code>O(n)</code> 空间复杂度解决。</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 693交替位二进制数",
        "hardRate": "EASY",
        "passRate": "65.15%",
        "problemsUrl": "https://leetcode.cn/problems/binary-number-with-alternating-bits/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-number-with-alternating-bits/solution",
        "problemsDesc": "<p>给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>true\n<strong>解释：</strong>5 的二进制表示是：101\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 7\n<strong>输出：</strong>false\n<strong>解释：</strong>7 的二进制表示是：111.</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 11\n<strong>输出：</strong>false\n<strong>解释：</strong>11 的二进制表示是：1011.</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 694不同岛屿的数量",
        "hardRate": "MEDIUM",
        "passRate": "57.58%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-distinct-islands/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-distinct-islands/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 695岛屿的最大面积",
        "hardRate": "MEDIUM",
        "passRate": "68.03%",
        "problemsUrl": "https://leetcode.cn/problems/max-area-of-island/",
        "solutionsUrl": "https://leetcode.cn/problems/max-area-of-island/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> 。</p>\n\n<p><strong>岛屿</strong>&nbsp;是由一些相邻的&nbsp;<code>1</code>&nbsp;(代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在 <strong>水平或者竖直的四个方向上 </strong>相邻。你可以假设&nbsp;<code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p>\n\n<p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目。</p>\n\n<p>计算并返回 <code>grid</code> 中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg\" style=\"width: 500px; height: 310px;\" />\n<pre>\n<strong>输入：</strong>grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\n<strong>输出：</strong>6\n<strong>解释：</strong>答案不应该是 <code>11</code> ，因为岛屿只能包含水平或垂直这四个方向上的 <code>1</code> 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,0,0,0,0,0,0,0]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 696计数二进制子串",
        "hardRate": "EASY",
        "passRate": "63.69%",
        "problemsUrl": "https://leetcode.cn/problems/count-binary-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/count-binary-substrings/solution",
        "problemsDesc": "<p>给定一个字符串&nbsp;<code>s</code>，统计并返回具有相同数量 <code>0</code> 和 <code>1</code> 的非空（连续）子字符串的数量，并且这些子字符串中的所有 <code>0</code> 和所有 <code>1</code> 都是成组连续的。</p>\n\n<p>重复出现（不同位置）的子串也要统计它们出现的次数。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"00110011\"\n<strong>输出：</strong>6\n<strong>解释：</strong>6 个子串满足具有相同数量的连续 1 和 0 ：\"0011\"、\"01\"、\"1100\"、\"10\"、\"0011\" 和 \"01\" 。\n注意，一些重复出现的子串（不同位置）要统计它们出现的次数。\n另外，\"00110011\" 不是有效的子串，因为所有的 0（还有 1 ）没有组合在一起。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"10101\"\n<strong>输出：</strong>4\n<strong>解释：</strong>有 4 个子串：\"10\"、\"01\"、\"10\"、\"01\" ，具有相同数量的连续 1 和 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 697数组的度",
        "hardRate": "EASY",
        "passRate": "59.33%",
        "problemsUrl": "https://leetcode.cn/problems/degree-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/degree-of-an-array/solution",
        "problemsDesc": "<p>给定一个非空且只包含非负数的整数数组&nbsp;<code>nums</code>，数组的 <strong>度</strong> 的定义是指数组里任一元素出现频数的最大值。</p>\n\n<p>你的任务是在 <code>nums</code> 中找到与&nbsp;<code>nums</code>&nbsp;拥有相同大小的度的最短连续子数组，返回其长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2,3,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n输入数组的度是 2 ，因为元素 1 和 2 的出现频数最大，均为 2 。\n连续子数组里面拥有相同度的有如下所示：\n[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]\n最短连续子数组 [2, 2] 的长度为 2 ，所以返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2,3,1,4,2]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n数组的度是 3 ，因为元素 2 重复出现 3 次。\n所以 [2,2,3,1,4,2] 是最短子数组，因此返回 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length</code>&nbsp;在 <code>1</code> 到 <code>50,000</code> 范围内。</li>\n\t<li><code>nums[i]</code>&nbsp;是一个在 <code>0</code> 到 <code>49,999</code> 范围内的整数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 698划分为k个相等的子集",
        "hardRate": "MEDIUM",
        "passRate": "42.12%",
        "problemsUrl": "https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/solution",
        "problemsDesc": "<p>给定一个整数数组&nbsp;&nbsp;<code>nums</code> 和一个正整数 <code>k</code>，找出是否有可能把这个数组分成 <code>k</code> 个非空子集，其总和都相等。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong> nums = [4, 3, 2, 3, 5, 2, 1], k = 4\n<strong>输出：</strong> True\n<strong>说明：</strong> 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,3,4], k = 3\n<strong>输出:</strong> false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= len(nums) &lt;= 16</code></li>\n\t<li><code>0 &lt; nums[i] &lt; 10000</code></li>\n\t<li>每个元素的频率在 <code>[1,4]</code> 范围内</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 699掉落的方块",
        "hardRate": "HARD",
        "passRate": "54.82%",
        "problemsUrl": "https://leetcode.cn/problems/falling-squares/",
        "solutionsUrl": "https://leetcode.cn/problems/falling-squares/solution",
        "problemsDesc": "<p>在二维平面上的 x 轴上，放置着一些方块。</p>\n\n<p>给你一个二维整数数组 <code>positions</code> ，其中 <code>positions[i] = [left<sub>i</sub>, sideLength<sub>i</sub>]</code> 表示：第 <code>i</code> 个方块边长为 <code>sideLength<sub>i</sub></code> ，其左侧边与 x 轴上坐标点&nbsp;<code>left<sub>i</sub></code> 对齐。</p>\n\n<p>每个方块都从一个比目前所有的落地方块更高的高度掉落而下。方块沿 y 轴负方向下落，直到着陆到 <strong>另一个正方形的顶边</strong> 或者是 <strong>x 轴上</strong> 。一个方块仅仅是擦过另一个方块的左侧边或右侧边不算着陆。一旦着陆，它就会固定在原地，无法移动。</p>\n\n<p>在每个方块掉落后，你必须记录目前所有已经落稳的 <strong>方块堆叠的最高高度</strong> 。</p>\n\n<p>返回一个整数数组 <code>ans</code> ，其中 <code>ans[i]</code> 表示在第 <code>i</code> 块方块掉落后堆叠的最高高度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/28/fallingsq1-plane.jpg\" style=\"width: 500px; height: 505px;\" />\n<pre>\n<strong>输入：</strong>positions = [[1,2],[2,3],[6,1]]\n<strong>输出：</strong>[2,5,5]\n<strong>解释：</strong>\n第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 2 。\n第 2 个方块掉落后，最高的堆叠由方块 1 和 2 组成，堆叠的最高高度为 5 。\n第 3 个方块掉落后，最高的堆叠仍然由方块 1 和 2 组成，堆叠的最高高度为 5 。\n因此，返回 [2, 5, 5] 作为答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>positions = [[100,100],[200,100]]\n<strong>输出：</strong>[100,100]\n<strong>解释：</strong>\n第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 100 。\n第 2 个方块掉落后，最高的堆叠可以由方块 1 组成也可以由方块 2 组成，堆叠的最高高度为 100 。\n因此，返回 [100, 100] 作为答案。\n注意，方块 2 擦过方块 1 的右侧边，但不会算作在方块 1 上着陆。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= positions.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= left<sub>i</sub> &lt;= 10<sup>8</sup></code></li>\n\t<li><code>1 &lt;= sideLength<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 700二叉搜索树中的搜索",
        "hardRate": "EASY",
        "passRate": "77.56%",
        "problemsUrl": "https://leetcode.cn/problems/search-in-a-binary-search-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/search-in-a-binary-search-tree/solution",
        "problemsDesc": "<p>给定二叉搜索树（BST）的根节点<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;和一个整数值<meta charset=\"UTF-8\" />&nbsp;<code>val</code>。</p>\n\n<p>你需要在 BST 中找到节点值等于&nbsp;<code>val</code>&nbsp;的节点。 返回以该节点为根的子树。 如果节点不存在，则返回<meta charset=\"UTF-8\" />&nbsp;<code>null</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg\" style=\"height: 179px; width: 250px;\" /><meta charset=\"UTF-8\" /></p>\n\n<pre>\n<b>输入：</b>root = [4,2,7,1,3], val = 2\n<b>输出：</b>[2,1,3]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg\" style=\"height: 179px; width: 250px;\" />\n<pre>\n<b>输入：</b>root = [4,2,7,1,3], val = 5\n<b>输出：</b>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>数中节点数在&nbsp;<code>[1, 5000]</code>&nbsp;范围内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>7</sup></code></li>\n\t<li><code>root</code>&nbsp;是二叉搜索树</li>\n\t<li><code>1 &lt;= val &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 701二叉搜索树中的插入操作",
        "hardRate": "MEDIUM",
        "passRate": "70.84%",
        "problemsUrl": "https://leetcode.cn/problems/insert-into-a-binary-search-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/insert-into-a-binary-search-tree/solution",
        "problemsDesc": "<p>给定二叉搜索树（BST）的根节点<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;和要插入树中的值<meta charset=\"UTF-8\" />&nbsp;<code>value</code>&nbsp;，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p>\n\n<p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg\" />\n<pre>\n<strong>输入：</strong>root = [4,2,7,1,3], val = 5\n<strong>输出：</strong>[4,2,7,1,3,5]\n<strong>解释：</strong>另一个满足题目要求可以通过的树是：\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/bst.jpg\" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [40,20,60,10,30,50,70], val = 25\n<strong>输出：</strong>[40,20,60,10,30,50,70,null,null,25]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\n<strong>输出：</strong>[4,2,7,1,3,5]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数将在<meta charset=\"UTF-8\" />&nbsp;<code>[0,&nbsp;10<sup>4</sup>]</code>的范围内。<meta charset=\"UTF-8\" /></li>\n\t<li><code>-10<sup>8</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>8</sup></code></li>\n\t<li>所有值&nbsp;<meta charset=\"UTF-8\" /><code>Node.val</code>&nbsp;是&nbsp;<strong>独一无二</strong>&nbsp;的。</li>\n\t<li><code>-10<sup>8</sup>&nbsp;&lt;= val &lt;= 10<sup>8</sup></code></li>\n\t<li><strong>保证</strong>&nbsp;<code>val</code>&nbsp;在原始BST中不存在。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 702搜索长度未知的有序数组",
        "hardRate": "MEDIUM",
        "passRate": "74.80%",
        "problemsUrl": "https://leetcode.cn/problems/search-in-a-sorted-array-of-unknown-size/",
        "solutionsUrl": "https://leetcode.cn/problems/search-in-a-sorted-array-of-unknown-size/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 703数据流中的第 K 大元素",
        "hardRate": "EASY",
        "passRate": "52.53%",
        "problemsUrl": "https://leetcode.cn/problems/kth-largest-element-in-a-stream/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-largest-element-in-a-stream/solution",
        "problemsDesc": "<p>设计一个找到数据流中第 <code>k</code> 大元素的类（class）。注意是排序后的第 <code>k</code> 大元素，不是第 <code>k</code> 个不同的元素。</p>\n\n<p>请实现 <code>KthLargest</code> 类：</p>\n\n<ul>\n\t<li><code>KthLargest(int k, int[] nums)</code> 使用整数 <code>k</code> 和整数流 <code>nums</code> 初始化对象。</li>\n\t<li><code>int add(int val)</code> 将 <code>val</code> 插入数据流 <code>nums</code> 后，返回当前数据流中第 <code>k</code> 大的元素。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\n<strong>输出：</strong>\n[null, 4, 5, 5, 8, 8]\n\n<strong>解释：</strong>\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8\n</pre>\n\n<p> </p>\n<strong>提示：</strong>\n\n<ul>\n\t<li><code>1 <= k <= 10<sup>4</sup></code></li>\n\t<li><code>0 <= nums.length <= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= val <= 10<sup>4</sup></code></li>\n\t<li>最多调用 <code>add</code> 方法 <code>10<sup>4</sup></code> 次</li>\n\t<li>题目数据保证，在查找第 <code>k</code> 大元素时，数组中至少有 <code>k</code> 个元素</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 704二分查找",
        "hardRate": "EASY",
        "passRate": "54.49%",
        "problemsUrl": "https://leetcode.cn/problems/binary-search/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-search/solution",
        "problemsDesc": "<p>给定一个&nbsp;<code>n</code>&nbsp;个元素有序的（升序）整型数组&nbsp;<code>nums</code> 和一个目标值&nbsp;<code>target</code> &nbsp;，写一个函数搜索&nbsp;<code>nums</code>&nbsp;中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p>\n\n<p><br>\n<strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> <code>nums</code> = [-1,0,3,5,9,12], <code>target</code> = 9\n<strong>输出:</strong> 4\n<strong>解释:</strong> 9 出现在 <code>nums</code> 中并且下标为 4\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> <code>nums</code> = [-1,0,3,5,9,12], <code>target</code> = 2\n<strong>输出:</strong> -1\n<strong>解释:</strong> 2 不存在 <code>nums</code> 中因此返回 -1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>你可以假设 <code>nums</code>&nbsp;中的所有元素是不重复的。</li>\n\t<li><code>n</code>&nbsp;将在&nbsp;<code>[1, 10000]</code>之间。</li>\n\t<li><code>nums</code>&nbsp;的每个元素都将在&nbsp;<code>[-9999, 9999]</code>之间。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 705设计哈希集合",
        "hardRate": "EASY",
        "passRate": "63.33%",
        "problemsUrl": "https://leetcode.cn/problems/design-hashset/",
        "solutionsUrl": "https://leetcode.cn/problems/design-hashset/solution",
        "problemsDesc": "<p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。</p>\n\n<p>实现 <code>MyHashSet</code> 类：</p>\n\n<ul>\n\t<li><code>void add(key)</code> 向哈希集合中插入值 <code>key</code> 。</li>\n\t<li><code>bool contains(key)</code> 返回哈希集合中是否存在这个值 <code>key</code> 。</li>\n\t<li><code>void remove(key)</code> 将给定值 <code>key</code> 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</li>\n</ul>\n&nbsp;\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"]\n[[], [1], [2], [1], [3], [2], [2], [2], [2]]\n<strong>输出：</strong>\n[null, null, null, true, false, null, true, null, false]\n\n<strong>解释：</strong>\nMyHashSet myHashSet = new MyHashSet();\nmyHashSet.add(1);      // set = [1]\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(1); // 返回 True\nmyHashSet.contains(3); // 返回 False ，（未找到）\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(2); // 返回 True\nmyHashSet.remove(2);   // set = [1]\nmyHashSet.contains(2); // 返回 False ，（已移除）</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= key &lt;= 10<sup>6</sup></code></li>\n\t<li>最多调用 <code>10<sup>4</sup></code> 次 <code>add</code>、<code>remove</code> 和 <code>contains</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 706设计哈希映射",
        "hardRate": "EASY",
        "passRate": "63.61%",
        "problemsUrl": "https://leetcode.cn/problems/design-hashmap/",
        "solutionsUrl": "https://leetcode.cn/problems/design-hashmap/solution",
        "problemsDesc": "<p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。</p>\n\n<p>实现 <code>MyHashMap</code> 类：</p>\n\n<ul>\n\t<li><code>MyHashMap()</code> 用空映射初始化对象</li>\n\t<li><code>void put(int key, int value)</code> 向 HashMap 插入一个键值对 <code>(key, value)</code> 。如果 <code>key</code> 已经存在于映射中，则更新其对应的值 <code>value</code> 。</li>\n\t<li><code>int get(int key)</code> 返回特定的 <code>key</code> 所映射的 <code>value</code> ；如果映射中不包含 <code>key</code> 的映射，返回 <code>-1</code> 。</li>\n\t<li><code>void remove(key)</code> 如果映射中存在 <code>key</code> 的映射，则移除 <code>key</code> 和它所对应的 <code>value</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>：\n[\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"]\n[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]\n<strong>输出</strong>：\n[null, null, null, 1, -1, null, 1, null, -1]\n\n<strong>解释</strong>：\nMyHashMap myHashMap = new MyHashMap();\nmyHashMap.put(1, 1); // myHashMap 现在为 [[1,1]]\nmyHashMap.put(2, 2); // myHashMap 现在为 [[1,1], [2,2]]\nmyHashMap.get(1);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,2]]\nmyHashMap.get(3);    // 返回 -1（未找到），myHashMap 现在为 [[1,1], [2,2]]\nmyHashMap.put(2, 1); // myHashMap 现在为 [[1,1], [2,1]]（更新已有的值）\nmyHashMap.get(2);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,1]]\nmyHashMap.remove(2); // 删除键为 2 的数据，myHashMap 现在为 [[1,1]]\nmyHashMap.get(2);    // 返回 -1（未找到），myHashMap 现在为 [[1,1]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= key, value &lt;= 10<sup>6</sup></code></li>\n\t<li>最多调用 <code>10<sup>4</sup></code> 次 <code>put</code>、<code>get</code> 和 <code>remove</code> 方法</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 707设计链表",
        "hardRate": "MEDIUM",
        "passRate": "34.64%",
        "problemsUrl": "https://leetcode.cn/problems/design-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/design-linked-list/solution",
        "problemsDesc": "<p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p>\n\n<p>单链表中的节点应该具备两个属性：<code>val</code> 和 <code>next</code> 。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针/引用。</p>\n\n<p>如果是双向链表，则还需要属性&nbsp;<code>prev</code>&nbsp;以指示链表中的上一个节点。假设链表中的所有节点下标从 <strong>0</strong> 开始。</p>\n\n<p>实现 <code>MyLinkedList</code> 类：</p>\n\n<ul>\n\t<li><code>MyLinkedList()</code> 初始化 <code>MyLinkedList</code> 对象。</li>\n\t<li><code>int get(int index)</code> 获取链表中下标为 <code>index</code> 的节点的值。如果下标无效，则返回 <code>-1</code> 。</li>\n\t<li><code>void addAtHead(int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li>\n\t<li><code>void addAtTail(int val)</code> 将一个值为 <code>val</code> 的节点追加到链表中作为链表的最后一个元素。</li>\n\t<li><code>void addAtIndex(int index, int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中下标为 <code>index</code> 的节点之前。如果 <code>index</code> 等于链表的长度，那么该节点会被追加到链表的末尾。如果 <code>index</code> 比长度更大，该节点将 <strong>不会插入</strong> 到链表中。</li>\n\t<li><code>void deleteAtIndex(int index)</code> 如果下标有效，则删除链表中下标为 <code>index</code> 的节点。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"MyLinkedList\", \"addAtHead\", \"addAtTail\", \"addAtIndex\", \"get\", \"deleteAtIndex\", \"get\"]\n[[], [1], [3], [1, 2], [1], [1], [1]]\n<strong>输出</strong>\n[null, null, null, null, 2, null, 3]\n\n<strong>解释</strong>\nMyLinkedList myLinkedList = new MyLinkedList();\nmyLinkedList.addAtHead(1);\nmyLinkedList.addAtTail(3);\nmyLinkedList.addAtIndex(1, 2);    // 链表变为 1-&gt;2-&gt;3\nmyLinkedList.get(1);              // 返回 2\nmyLinkedList.deleteAtIndex(1);    // 现在，链表变为 1-&gt;3\nmyLinkedList.get(1);              // 返回 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= index, val &lt;= 1000</code></li>\n\t<li>请不要使用内置的 LinkedList 库。</li>\n\t<li>调用 <code>get</code>、<code>addAtHead</code>、<code>addAtTail</code>、<code>addAtIndex</code> 和 <code>deleteAtIndex</code> 的次数不超过 <code>2000</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 708循环有序列表的插入",
        "hardRate": "MEDIUM",
        "passRate": "37.73%",
        "problemsUrl": "https://leetcode.cn/problems/insert-into-a-sorted-circular-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/insert-into-a-sorted-circular-linked-list/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 709转换成小写字母",
        "hardRate": "EASY",
        "passRate": "76.83%",
        "problemsUrl": "https://leetcode.cn/problems/to-lower-case/",
        "solutionsUrl": "https://leetcode.cn/problems/to-lower-case/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"Hello\"\n<strong>输出：</strong>\"hello\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"here\"\n<strong>输出：</strong>\"here\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"LOVELY\"\n<strong>输出：</strong>\"lovely\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 100</code></li>\n\t<li><code>s</code> 由 ASCII 字符集中的可打印字符组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 710黑名单中的随机数",
        "hardRate": "HARD",
        "passRate": "43.68%",
        "problemsUrl": "https://leetcode.cn/problems/random-pick-with-blacklist/",
        "solutionsUrl": "https://leetcode.cn/problems/random-pick-with-blacklist/solution",
        "problemsDesc": "<p>给定一个整数 <code>n</code> 和一个 <strong>无重复</strong> 黑名单整数数组&nbsp;<code>blacklist</code>&nbsp;。设计一种算法，从 <code>[0, n - 1]</code> 范围内的任意整数中选取一个&nbsp;<strong>未加入&nbsp;</strong>黑名单&nbsp;<code>blacklist</code>&nbsp;的整数。任何在上述范围内且不在黑名单&nbsp;<code>blacklist</code>&nbsp;中的整数都应该有 <strong>同等的可能性</strong> 被返回。</p>\n\n<p>优化你的算法，使它最小化调用语言 <strong>内置</strong> 随机函数的次数。</p>\n\n<p>实现&nbsp;<code>Solution</code>&nbsp;类:</p>\n\n<ul>\n\t<li><code>Solution(int n, int[] blacklist)</code>&nbsp;初始化整数 <code>n</code> 和被加入黑名单&nbsp;<code>blacklist</code>&nbsp;的整数</li>\n\t<li><code>int pick()</code>&nbsp;返回一个范围为 <code>[0, n - 1]</code> 且不在黑名单&nbsp;<code>blacklist</code> 中的随机整数</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]\n<strong>输出</strong>\n[null, 0, 4, 1, 6, 1, 0, 4]\n\n<b>解释\n</b>Solution solution = new Solution(7, [2, 3, 5]);\nsolution.pick(); // 返回0，任何[0,1,4,6]的整数都可以。注意，对于每一个pick的调用，\n                 // 0、1、4和6的返回概率必须相等(即概率为1/4)。\nsolution.pick(); // 返回 4\nsolution.pick(); // 返回 1\nsolution.pick(); // 返回 6\nsolution.pick(); // 返回 1\nsolution.pick(); // 返回 0\nsolution.pick(); // 返回 4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= blacklist.length &lt;= min(10<sup>5</sup>, n - 1)</code></li>\n\t<li><code>0 &lt;= blacklist[i] &lt; n</code></li>\n\t<li><code>blacklist</code>&nbsp;中所有值都 <strong>不同</strong></li>\n\t<li>&nbsp;<code>pick</code>&nbsp;最多被调用&nbsp;<code>2 * 10<sup>4</sup></code>&nbsp;次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 711不同岛屿的数量 II",
        "hardRate": "HARD",
        "passRate": "56.03%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-distinct-islands-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-distinct-islands-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 712两个字符串的最小ASCII删除和",
        "hardRate": "MEDIUM",
        "passRate": "68.90%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/solution",
        "problemsDesc": "<p>给定两个字符串<code>s1</code>&nbsp;和&nbsp;<code>s2</code>，返回 <em>使两个字符串相等所需删除字符的&nbsp;<strong>ASCII&nbsp;</strong>值的最小和&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> s1 = \"sea\", s2 = \"eat\"\n<strong>输出:</strong> 231\n<strong>解释:</strong> 在 \"sea\" 中删除 \"s\" 并将 \"s\" 的值(115)加入总和。\n在 \"eat\" 中删除 \"t\" 并将 116 加入总和。\n结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s1 = \"delete\", s2 = \"leet\"\n<strong>输出:</strong> 403\n<strong>解释:</strong> 在 \"delete\" 中删除 \"dee\" 字符串变成 \"let\"，\n将 100[d]+101[e]+101[e] 加入总和。在 \"leet\" 中删除 \"e\" 将 101[e] 加入总和。\n结束时，两个字符串都等于 \"let\"，结果即为 100+101+101+101 = 403 。\n如果改为将两个字符串转换为 \"lee\" 或 \"eet\"，我们会得到 433 或 417 的结果，比答案更大。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s1.length, s2.length &lt;= 1000</code></li>\n\t<li><code>s1</code>&nbsp;和&nbsp;<code>s2</code>&nbsp;由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 713乘积小于 K 的子数组",
        "hardRate": "MEDIUM",
        "passRate": "49.58%",
        "problemsUrl": "https://leetcode.cn/problems/subarray-product-less-than-k/",
        "solutionsUrl": "https://leetcode.cn/problems/subarray-product-less-than-k/solution",
        "problemsDesc": "给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回子数组内所有元素的乘积严格小于<em> </em><code>k</code> 的连续子数组的数目。\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,5,2,6], k = 100\n<strong>输出：</strong>8\n<strong>解释：</strong>8 个乘积小于 100 的子数组分别为：[10]、[5]、[2],、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。\n需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3], k = 0\n<strong>输出：</strong>0</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:&nbsp;</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 714买卖股票的最佳时机含手续费",
        "hardRate": "MEDIUM",
        "passRate": "75.25%",
        "problemsUrl": "https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/",
        "solutionsUrl": "https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution",
        "problemsDesc": "<p>给定一个整数数组&nbsp;<code>prices</code>，其中 <code>prices[i]</code>表示第&nbsp;<code>i</code>&nbsp;天的股票价格 ；整数&nbsp;<code>fee</code> 代表了交易股票的手续费用。</p>\n\n<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>\n\n<p>返回获得利润的最大值。</p>\n\n<p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [1, 3, 2, 8, 4, 9], fee = 2\n<strong>输出：</strong>8\n<strong>解释：</strong>能够达到的最大利润:  \n在此处买入&nbsp;prices[0] = 1\n在此处卖出 prices[3] = 8\n在此处买入 prices[4] = 4\n在此处卖出 prices[5] = 9\n总利润:&nbsp;((8 - 1) - 2) + ((9 - 4) - 2) = 8</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [1,3,7,5,10,3], fee = 3\n<strong>输出：</strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= prices[i] &lt; 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= fee &lt; 5 * 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 715Range 模块",
        "hardRate": "HARD",
        "passRate": "52.90%",
        "problemsUrl": "https://leetcode.cn/problems/range-module/",
        "solutionsUrl": "https://leetcode.cn/problems/range-module/solution",
        "problemsDesc": "<p>Range模块是跟踪数字范围的模块。设计一个数据结构来跟踪表示为 <strong>半开区间</strong> 的范围并查询它们。</p>\n\n<p><strong>半开区间</strong>&nbsp;<code>[left, right)</code>&nbsp;表示所有&nbsp;<code>left &lt;= x &lt; right</code>&nbsp;的实数 <code>x</code> 。</p>\n\n<p>实现 <code>RangeModule</code> 类:</p>\n\n<ul>\n\t<li><code>RangeModule()</code>&nbsp;初始化数据结构的对象。</li>\n\t<li><code>void addRange(int left, int right)</code> 添加 <strong>半开区间</strong>&nbsp;<code>[left, right)</code>，跟踪该区间中的每个实数。添加与当前跟踪的数字部分重叠的区间时，应当添加在区间&nbsp;<code>[left, right)</code>&nbsp;中尚未跟踪的任何数字到该区间中。</li>\n\t<li><code>boolean queryRange(int left, int right)</code>&nbsp;只有在当前正在跟踪区间&nbsp;<code>[left, right)</code>&nbsp;中的每一个实数时，才返回 <code>true</code>&nbsp;，否则返回 <code>false</code> 。</li>\n\t<li><code>void removeRange(int left, int right)</code>&nbsp;停止跟踪 <strong>半开区间</strong>&nbsp;<code>[left, right)</code>&nbsp;中当前正在跟踪的每个实数。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"RangeModule\", \"addRange\", \"removeRange\", \"queryRange\", \"queryRange\", \"queryRange\"]\n[[], [10, 20], [14, 16], [10, 14], [13, 15], [16, 17]]\n<strong>输出</strong>\n[null, null, null, true, false, true]\n\n<strong>解释</strong>\nRangeModule rangeModule = new RangeModule();\nrangeModule.addRange(10, 20);\nrangeModule.removeRange(14, 16);\nrangeModule.queryRange(10, 14); 返回 true （区间 [10, 14) 中的每个数都正在被跟踪）\nrangeModule.queryRange(13, 15); 返回 false（未跟踪区间 [13, 15) 中像 14, 14.03, 14.17 这样的数字）\nrangeModule.queryRange(16, 17); 返回 true （尽管执行了删除操作，区间 [16, 17) 中的数字 16 仍然会被跟踪）\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= left &lt; right &lt;= 10<sup>9</sup></code></li>\n\t<li>在单个测试用例中，对&nbsp;<code>addRange</code>&nbsp;、&nbsp; <code>queryRange</code>&nbsp;和 <code>removeRange</code> 的调用总数不超过&nbsp;<code>10<sup>4</sup></code>&nbsp;次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 716最大栈",
        "hardRate": "HARD",
        "passRate": "44.30%",
        "problemsUrl": "https://leetcode.cn/problems/max-stack/",
        "solutionsUrl": "https://leetcode.cn/problems/max-stack/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 7171 比特与 2 比特字符",
        "hardRate": "EASY",
        "passRate": "55.27%",
        "problemsUrl": "https://leetcode.cn/problems/1-bit-and-2-bit-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/1-bit-and-2-bit-characters/solution",
        "problemsDesc": "<p>有两种特殊字符：</p>\n\n<ul>\n\t<li>第一种字符可以用一比特&nbsp;<code>0</code> 表示</li>\n\t<li>第二种字符可以用两比特（<code>10</code>&nbsp;或&nbsp;<code>11</code>）表示</li>\n</ul>\n\n<p>给你一个以 <code>0</code> 结尾的二进制数组&nbsp;<code>bits</code>&nbsp;，如果最后一个字符必须是一个一比特字符，则返回 <code>true</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> bits = [1, 0, 0]\n<strong>输出:</strong> true\n<strong>解释:</strong> 唯一的解码方式是将其解析为一个两比特字符和一个一比特字符。\n所以最后一个字符是一比特字符。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入：</strong>bits = [1,1,1,0]\n<strong>输出：</strong>false\n<strong>解释：</strong>唯一的解码方式是将其解析为两比特字符和两比特字符。\n所以最后一个字符不是一比特字符。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= bits.length &lt;= 1000</code></li>\n\t<li><code>bits[i]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 718最长重复子数组",
        "hardRate": "MEDIUM",
        "passRate": "56.91%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-length-of-repeated-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-length-of-repeated-subarray/solution",
        "problemsDesc": "<p>给两个整数数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>&nbsp;，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]\n<strong>输出：</strong>3\n<strong>解释：</strong>长度最长的公共子数组是 [3,2,1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]\n<strong>输出：</strong>5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 719找出第 K 小的数对距离",
        "hardRate": "HARD",
        "passRate": "46.68%",
        "problemsUrl": "https://leetcode.cn/problems/find-k-th-smallest-pair-distance/",
        "solutionsUrl": "https://leetcode.cn/problems/find-k-th-smallest-pair-distance/solution",
        "problemsDesc": "<p>数对 <code>(a,b)</code> 由整数 <code>a</code> 和 <code>b</code> 组成，其数对距离定义为 <code>a</code> 和 <code>b</code> 的绝对差值。</p>\n\n<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，数对由 <code>nums[i]</code> 和 <code>nums[j]</code> 组成且满足 <code>0 &lt;= i &lt; j &lt; nums.length</code> 。返回 <strong>所有数对距离中</strong> 第 <code>k</code> 小的数对距离。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,1], k = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>数对和对应的距离如下：\n(1,3) -&gt; 2\n(1,1) -&gt; 0\n(3,1) -&gt; 2\n距离第 1 小的数对是 (1,1) ，距离为 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1], k = 2\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,6,1], k = 3\n<strong>输出：</strong>5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n * (n - 1) / 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 720词典中最长的单词",
        "hardRate": "MEDIUM",
        "passRate": "51.87%",
        "problemsUrl": "https://leetcode.cn/problems/longest-word-in-dictionary/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-word-in-dictionary/solution",
        "problemsDesc": "<p>给出一个字符串数组&nbsp;<code>words</code> 组成的一本英语词典。返回&nbsp;<code>words</code> 中最长的一个单词，该单词是由&nbsp;<code>words</code>&nbsp;词典中其他单词逐步添加一个字母组成。</p>\n\n<p>若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"w\",\"wo\",\"wor\",\"worl\", \"world\"]\n<strong>输出：</strong>\"world\"\n<strong>解释：</strong> 单词\"world\"可由\"w\", \"wo\", \"wor\", 和 \"worl\"逐步添加一个字母组成。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"a\", \"banana\", \"app\", \"appl\", \"ap\", \"apply\", \"apple\"]\n<strong>输出：</strong>\"apple\"\n<strong>解释：</strong>\"apply\" 和 \"apple\" 都能由词典中的单词组成。但是 \"apple\" 的字典序小于 \"apply\" \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li>所有输入的字符串&nbsp;<code>words[i]</code>&nbsp;都只包含小写字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 721账户合并",
        "hardRate": "MEDIUM",
        "passRate": "48.21%",
        "problemsUrl": "https://leetcode.cn/problems/accounts-merge/",
        "solutionsUrl": "https://leetcode.cn/problems/accounts-merge/solution",
        "problemsDesc": "<p>给定一个列表 <code>accounts</code>，每个元素 <code>accounts[i]</code>&nbsp;是一个字符串列表，其中第一个元素 <code>accounts[i][0]</code>&nbsp;是&nbsp;<em>名称 (name)</em>，其余元素是 <em><strong>emails</strong> </em>表示该账户的邮箱地址。</p>\n\n<p>现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。</p>\n\n<p>合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是 <strong>按字符 ASCII 顺序排列</strong> 的邮箱地址。账户本身可以以 <strong>任意顺序</strong> 返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>accounts = [[\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"], [\"John\", \"johnnybravo@mail.com\"], [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"], [\"Mary\", \"mary@mail.com\"]]\n<b>输出：</b>[[\"John\", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  [\"John\", \"johnnybravo@mail.com\"], [\"Mary\", \"mary@mail.com\"]]\n<b>解释：</b>\n第一个和第三个 John 是同一个人，因为他们有共同的邮箱地址 \"johnsmith@mail.com\"。 \n第二个 John 和 Mary 是不同的人，因为他们的邮箱地址没有被其他帐户使用。\n可以以任何顺序返回这些列表，例如答案 [['Mary'，'mary@mail.com']，['John'，'johnnybravo@mail.com']，\n['John'，'john00@mail.com'，'john_newyork@mail.com'，'johnsmith@mail.com']] 也是正确的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]\n<strong>输出：</strong>[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= accounts.length &lt;= 1000</code></li>\n\t<li><code>2 &lt;= accounts[i].length &lt;= 10</code></li>\n\t<li><code>1 &lt;= accounts[i][j].length &lt;= 30</code></li>\n\t<li><code>accounts[i][0]</code> 由英文字母组成</li>\n\t<li><code>accounts[i][j] (for j &gt; 0)</code> 是有效的邮箱地址</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 722删除注释",
        "hardRate": "MEDIUM",
        "passRate": "34.17%",
        "problemsUrl": "https://leetcode.cn/problems/remove-comments/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-comments/solution",
        "problemsDesc": "<p>给一个 C++ 程序，删除程序中的注释。这个程序<code>source</code>是一个数组，其中<code>source[i]</code>表示第&nbsp;<code>i</code>&nbsp;行源码。&nbsp;这表示每行源码由<font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\"> <code>'\\n'&nbsp;</code></span></span></font></font>分隔。</p>\n\n<p>在 C++ 中有两种注释风格，行内注释和块注释。</p>\n\n<ul>\n\t<li>字符串<code>//</code> 表示行注释，表示<code>//</code>和其右侧的其余字符应该被忽略。</li>\n\t<li>字符串<code>/*</code> 表示一个块注释，它表示直到下一个（非重叠）出现的<code>*/</code>之间的所有字符都应该被忽略。（阅读顺序为从左到右）非重叠是指，字符串<code>/*/</code>并没有结束块注释，因为注释的结尾与开头相重叠。</li>\n</ul>\n\n<p>第一个有效注释优先于其他注释。</p>\n\n<ul>\n\t<li>如果字符串<code>//</code>出现在块注释中会被忽略。</li>\n\t<li>同样，如果字符串<code>/*</code>出现在行或块注释中也会被忽略。</li>\n</ul>\n\n<p>如果一行在删除注释之后变为空字符串，那么<strong>不要</strong>输出该行。即，答案列表中的每个字符串都是非空的。</p>\n\n<p>样例中<strong>没有</strong>控制字符，单引号或双引号字符。</p>\n\n<ul>\n\t<li>比如，<code>source = \"string s = \"/* Not a comment. */\";\"</code> 不会出现在测试样例里。</li>\n</ul>\n\n<p>此外，没有其他内容（如定义或宏）会干扰注释。</p>\n\n<p>我们保证每一个块注释最终都会被闭合， 所以在行或块注释之外的<code>/*</code>总是开始新的注释。</p>\n\n<p>最后，隐式换行符<strong>可以</strong>通过块注释删除。 有关详细信息，请参阅下面的示例。</p>\n\n<p>从源代码中删除注释后，需要以相同的格式返回源代码。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> source = [\"/*Test program */\", \"int main()\", \"{ \", \"  // variable declaration \", \"int a, b, c;\", \"/* This is a test\", \"   multiline  \", \"   comment for \", \"   testing */\", \"a = b + c;\", \"}\"]\n<strong>输出:</strong> [\"int main()\",\"{ \",\"  \",\"int a, b, c;\",\"a = b + c;\",\"}\"]\n<strong>解释:</strong> 示例代码可以编排成这样:\n/*Test program */\nint main()\n{ \n  // variable declaration \nint a, b, c;\n/* This is a test\n   multiline  \n   comment for \n   testing */\na = b + c;\n}\n第 1 行和第 6-9 行的字符串 /* 表示块注释。第 4 行的字符串 // 表示行注释。\n编排后: \nint main()\n{ \n  \nint a, b, c;\na = b + c;\n}</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> source = [\"a/*comment\", \"line\", \"more_comment*/b\"]\n<strong>输出:</strong> [\"ab\"]\n<strong>解释:</strong> 原始的 source 字符串是 \"a/*comment<strong>\\n</strong>line<strong>\\n</strong>more_comment*/b\", 其中我们用粗体显示了换行符。删除注释后，隐含的换行符被删除，留下字符串 \"ab\" 用换行符分隔成数组时就是 [\"ab\"].\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= source.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= source[i].length &lt;= 80</code></li>\n\t<li><code>source[i]</code>&nbsp;由可打印的 <strong>ASCII</strong> 字符组成。</li>\n\t<li>每个块注释都会被闭合。</li>\n\t<li>给定的源码中不会有单引号、双引号或其他控制字符。</li>\n</ul>\n<span style=\"display:block\"><span style=\"height:0px\"><span style=\"position:absolute\"><span style=\"top:0px\"><span style=\"left:-9999px\"><span style=\"opacity:0\"><span style=\"overflow:hidden\">&nbsp;</span></span></span></span></span></span>​​​​​​</span>",
        "isPlus": false
    },
    {
        "problemsName": " 723粉碎糖果",
        "hardRate": "MEDIUM",
        "passRate": "73.94%",
        "problemsUrl": "https://leetcode.cn/problems/candy-crush/",
        "solutionsUrl": "https://leetcode.cn/problems/candy-crush/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 724寻找数组的中心下标",
        "hardRate": "EASY",
        "passRate": "51.59%",
        "problemsUrl": "https://leetcode.cn/problems/find-pivot-index/",
        "solutionsUrl": "https://leetcode.cn/problems/find-pivot-index/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code> ，请计算数组的 <strong>中心下标 </strong>。</p>\n\n<p>数组<strong> 中心下标</strong><strong> </strong>是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p>\n\n<p>如果中心下标位于数组最左端，那么左侧数之和视为 <code>0</code> ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p>\n\n<p>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1, 7, 3, 6, 5, 6]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n中心下标是 3 。\n左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，\n右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1, 2, 3]\n<strong>输出：</strong>-1\n<strong>解释：</strong>\n数组中不存在满足此条件的中心下标。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2, 1, -1]\n<strong>输出：</strong>0\n<strong>解释：</strong>\n中心下标是 0 。\n左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），\n右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与主站 1991 题相同：<a href=\"https://leetcode-cn.com/problems/find-the-middle-index-in-array/\" target=\"_blank\">https://leetcode-cn.com/problems/find-the-middle-index-in-array/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 725分隔链表",
        "hardRate": "MEDIUM",
        "passRate": "60.46%",
        "problemsUrl": "https://leetcode.cn/problems/split-linked-list-in-parts/",
        "solutionsUrl": "https://leetcode.cn/problems/split-linked-list-in-parts/solution",
        "problemsDesc": "<p>给你一个头结点为 <code>head</code> 的单链表和一个整数 <code>k</code> ，请你设计一个算法将链表分隔为 <code>k</code> 个连续的部分。</p>\n\n<p>每部分的长度应该尽可能的相等：任意两部分的长度差距不能超过 1 。这可能会导致有些部分为 null 。</p>\n\n<p>这 <code>k</code> 个部分应该按照在链表中出现的顺序排列，并且排在前面的部分的长度应该大于或等于排在后面的长度。</p>\n\n<p>返回一个由上述 <code>k</code> 部分组成的数组。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/13/split1-lc.jpg\" style=\"width: 400px; height: 134px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3], k = 5\n<strong>输出：</strong>[[1],[2],[3],[],[]]\n<strong>解释：</strong>\n第一个元素 output[0] 为 output[0].val = 1 ，output[0].next = null 。\n最后一个元素 output[4] 为 null ，但它作为 ListNode 的字符串表示是 [] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/13/split2-lc.jpg\" style=\"width: 600px; height: 60px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5,6,7,8,9,10], k = 3\n<strong>输出：</strong>[[1,2,3,4],[5,6,7],[8,9,10]]\n<strong>解释：</strong>\n输入被分成了几个连续的部分，并且每部分的长度相差不超过 1 。前面部分的长度大于等于后面部分的长度。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目在范围 <code>[0, 1000]</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n\t<li><code>1 &lt;= k &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 726原子的数量",
        "hardRate": "HARD",
        "passRate": "55.19%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-atoms/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-atoms/solution",
        "problemsDesc": "<p>给你一个字符串化学式 <code>formula</code> ，返回 <strong>每种原子的数量</strong> 。</p>\n\n<p>原子总是以一个大写字母开始，接着跟随 0 个或任意个小写字母，表示原子的名字。</p>\n\n<p>如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。</p>\n\n<ul>\n\t<li>例如，<code>\"H2O\"</code> 和 <code>\"H2O2\"</code> 是可行的，但 <code>\"H1O2\"</code> 这个表达是不可行的。</li>\n</ul>\n\n<p>两个化学式连在一起可以构成新的化学式。</p>\n\n<ul>\n\t<li>例如 <code>\"H2O2He3Mg4\"</code> 也是化学式。</li>\n</ul>\n\n<p>由括号括起的化学式并佐以数字（可选择性添加）也是化学式。</p>\n\n<ul>\n\t<li>例如 <code>\"(H2O2)\"</code> 和 <code>\"(H2O2)3\"</code> 是化学式。</li>\n</ul>\n\n<p>返回所有原子的数量，格式为：第一个（按字典序）原子的名字，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>formula = \"H2O\"\n<strong>输出：</strong>\"H2O\"\n<strong>解释：</strong>原子的数量是 {'H': 2, 'O': 1}。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>formula = \"Mg(OH)2\"\n<strong>输出：</strong>\"H2MgO2\"\n<strong>解释：</strong>原子的数量是 {'H': 2, 'Mg': 1, 'O': 2}。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>formula = \"K4(ON(SO3)2)2\"\n<strong>输出：</strong>\"K4N2O14S4\"\n<strong>解释：</strong>原子的数量是 {'K': 4, 'N': 2, 'O': 14, 'S': 4}。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= formula.length&nbsp;&lt;= 1000</code></li>\n\t<li><code>formula</code> 由英文字母、数字、<code>'('</code> 和 <code>')'</code> 组成</li>\n\t<li><code>formula</code> 总是有效的化学式</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 727最小窗口子序列",
        "hardRate": "HARD",
        "passRate": "42.44%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-window-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-window-subsequence/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 728自除数",
        "hardRate": "EASY",
        "passRate": "77.18%",
        "problemsUrl": "https://leetcode.cn/problems/self-dividing-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/self-dividing-numbers/solution",
        "problemsDesc": "<p><strong>自除数</strong><em>&nbsp;</em>是指可以被它包含的每一位数整除的数。</p>\n\n<ul>\n\t<li>例如，<code>128</code> 是一个 <strong>自除数</strong> ，因为&nbsp;<code>128 % 1 == 0</code>，<code>128 % 2 == 0</code>，<code>128 % 8 == 0</code>。</li>\n</ul>\n\n<p><strong>自除数</strong> 不允许包含 0 。</p>\n\n<p>给定两个整数&nbsp;<code>left</code>&nbsp;和&nbsp;<code>right</code> ，返回一个列表，<em>列表的元素是范围&nbsp;<code>[left, right]</code>&nbsp;内所有的 <strong>自除数</strong></em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>left = 1, right = 22\n<strong>输出：</strong>[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<b>输入：</b>left = 47, right = 85\n<b>输出：</b>[48,55,66,77]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= left &lt;= right &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 729我的日程安排表 I",
        "hardRate": "MEDIUM",
        "passRate": "58.37%",
        "problemsUrl": "https://leetcode.cn/problems/my-calendar-i/",
        "solutionsUrl": "https://leetcode.cn/problems/my-calendar-i/solution",
        "problemsDesc": "<p>实现一个 <code>MyCalendar</code> 类来存放你的日程安排。如果要添加的日程安排不会造成 <strong>重复预订</strong> ，则可以存储这个新的日程安排。</p>\n\n<p>当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生 <strong>重复预订</strong> 。</p>\n\n<p>日程可以用一对整数 <code>start</code> 和 <code>end</code> 表示，这里的时间是半开区间，即 <code>[start, end)</code>, 实数&nbsp;<code>x</code> 的范围为， &nbsp;<code>start &lt;= x &lt; end</code> 。</p>\n\n<p>实现 <code>MyCalendar</code> 类：</p>\n\n<ul>\n\t<li><code>MyCalendar()</code> 初始化日历对象。</li>\n\t<li><code>boolean book(int start, int end)</code> 如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 <code>true</code> 。否则，返回 <code>false</code>&nbsp;并且不要将该日程安排添加到日历中。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"MyCalendar\", \"book\", \"book\", \"book\"]\n[[], [10, 20], [15, 25], [20, 30]]\n<strong>输出：</strong>\n[null, true, false, true]\n\n<strong>解释：</strong>\nMyCalendar myCalendar = new MyCalendar();\nmyCalendar.book(10, 20); // return True\nmyCalendar.book(15, 25); // return False ，这个日程安排不能添加到日历中，因为时间 15 已经被另一个日程安排预订了。\nmyCalendar.book(20, 30); // return True ，这个日程安排可以添加到日历中，因为第一个日程安排预订的每个时间都小于 20 ，且不包含时间 20 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= start &lt; end &lt;= 10<sup>9</sup></code></li>\n\t<li>每个测试用例，调用 <code>book</code> 方法的次数最多不超过 <code>1000</code> 次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 730统计不同回文子序列",
        "hardRate": "HARD",
        "passRate": "64.16%",
        "problemsUrl": "https://leetcode.cn/problems/count-different-palindromic-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/count-different-palindromic-subsequences/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，返回 <code>s</code>&nbsp;中不同的非空回文子序列个数 。由于答案可能很大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p>字符串的子序列可以经由字符串删除 0 个或多个字符获得。</p>\n\n<p>如果一个序列与它反转后的序列一致，那么它是回文序列。</p>\n\n<p>如果存在某个 <code>i</code> , 满足&nbsp;<code>a<sub>i</sub>&nbsp;!= b<sub>i</sub></code><sub>&nbsp;</sub>，则两个序列&nbsp;<code>a<sub>1</sub>, a<sub>2</sub>, ...</code>&nbsp;和&nbsp;<code>b<sub>1</sub>, b<sub>2</sub>, ...</code>&nbsp;不同。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = 'bccb'\n<strong>输出：</strong>6\n<strong>解释：</strong>6 个不同的非空回文子字符序列分别为：'b', 'c', 'bb', 'cc', 'bcb', 'bccb'。\n注意：'bcb' 虽然出现两次但仅计数一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = 'abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba'\n<strong>输出：</strong>104860361\n<strong>解释：</strong>共有 3104860382 个不同的非空回文子序列，104860361 是对 10<sup>9</sup> + 7 取余后的值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i]</code>&nbsp;仅包含&nbsp;<code>'a'</code>,&nbsp;<code>'b'</code>,&nbsp;<code>'c'</code>&nbsp;或&nbsp;<code>'d'</code>&nbsp;</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 731我的日程安排表 II",
        "hardRate": "MEDIUM",
        "passRate": "62.74%",
        "problemsUrl": "https://leetcode.cn/problems/my-calendar-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/my-calendar-ii/solution",
        "problemsDesc": "<p>实现一个 <code>MyCalendar</code> 类来存放你的日程安排。如果要添加的时间内不会导致三重预订时，则可以存储这个新的日程安排。</p>\n\n<p><code>MyCalendar</code> 有一个 <code>book(int start, int end)</code>方法。它意味着在 <code>start</code> 到 <code>end</code> 时间内增加一个日程安排，注意，这里的时间是半开区间，即 <code>[start, end)</code>, 实数&nbsp;<code>x</code> 的范围为， &nbsp;<code>start &lt;= x &lt; end</code>。</p>\n\n<p>当三个日程安排有一些时间上的交叉时（例如三个日程安排都在同一时间内），就会产生三重预订。</p>\n\n<p>每次调用 <code>MyCalendar.book</code>方法时，如果可以将日程安排成功添加到日历中而不会导致三重预订，返回 <code>true</code>。否则，返回 <code>false</code> 并且不要将该日程安排添加到日历中。</p>\n\n<p>请按照以下步骤调用<code>MyCalendar</code> 类: <code>MyCalendar cal = new MyCalendar();</code> <code>MyCalendar.book(start, end)</code></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>MyCalendar();\nMyCalendar.book(10, 20); // returns true\nMyCalendar.book(50, 60); // returns true\nMyCalendar.book(10, 40); // returns true\nMyCalendar.book(5, 15); // returns false\nMyCalendar.book(5, 10); // returns true\nMyCalendar.book(25, 55); // returns true\n<strong>解释：</strong> \n前两个日程安排可以添加至日历中。 第三个日程安排会导致双重预订，但可以添加至日历中。\n第四个日程安排活动（5,15）不能添加至日历中，因为它会导致三重预订。\n第五个日程安排（5,10）可以添加至日历中，因为它未使用已经双重预订的时间10。\n第六个日程安排（25,55）可以添加至日历中，因为时间 [25,40] 将和第三个日程安排双重预订；\n时间 [40,50] 将单独预订，时间 [50,55）将和第二个日程安排双重预订。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每个测试用例，调用&nbsp;<code>MyCalendar.book</code>&nbsp;函数最多不超过&nbsp;<code>1000</code>次。</li>\n\t<li>调用函数&nbsp;<code>MyCalendar.book(start, end)</code>时，&nbsp;<code>start</code> 和&nbsp;<code>end</code> 的取值范围为&nbsp;<code>[0, 10^9]</code>。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 732我的日程安排表 III",
        "hardRate": "HARD",
        "passRate": "71.42%",
        "problemsUrl": "https://leetcode.cn/problems/my-calendar-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/my-calendar-iii/solution",
        "problemsDesc": "<p>当 <code>k</code> 个日程安排有一些时间上的交叉时（例如 <code>k</code> 个日程安排都在同一时间内），就会产生 <code>k</code> 次预订。</p>\n\n<p>给你一些日程安排 <code>[start, end)</code> ，请你在每个日程安排添加后，返回一个整数 <code>k</code> ，表示所有先前日程安排会产生的最大 <code>k</code> 次预订。</p>\n\n<p>实现一个 <code>MyCalendarThree</code> 类来存放你的日程安排，你可以一直添加新的日程安排。</p>\n\n<ul>\n\t<li><code>MyCalendarThree()</code> 初始化对象。</li>\n\t<li><code>int book(int start, int end)</code> 返回一个整数 <code>k</code> ，表示日历中存在的 <code>k</code> 次预订的最大值。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"]\n[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]\n<strong>输出：</strong>\n[null, 1, 1, 2, 3, 3, 3]\n\n<strong>解释：</strong>\nMyCalendarThree myCalendarThree = new MyCalendarThree();\nmyCalendarThree.book(10, 20); // 返回 1 ，第一个日程安排可以预订并且不存在相交，所以最大 k 次预订是 1 次预订。\nmyCalendarThree.book(50, 60); // 返回 1 ，第二个日程安排可以预订并且不存在相交，所以最大 k 次预订是 1 次预订。\nmyCalendarThree.book(10, 40); // 返回 2 ，第三个日程安排 [10, 40) 与第一个日程安排相交，所以最大 k 次预订是 2 次预订。\nmyCalendarThree.book(5, 15); // 返回 3 ，剩下的日程安排的最大 k 次预订是 3 次预订。\nmyCalendarThree.book(5, 10); // 返回 3\nmyCalendarThree.book(25, 55); // 返回 3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= start < end <= 10<sup>9</sup></code></li>\n\t<li>每个测试用例，调用 <code>book</code> 函数最多不超过 <code>400</code>次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 733图像渲染",
        "hardRate": "EASY",
        "passRate": "58.66%",
        "problemsUrl": "https://leetcode.cn/problems/flood-fill/",
        "solutionsUrl": "https://leetcode.cn/problems/flood-fill/solution",
        "problemsDesc": "<p>有一幅以&nbsp;<code>m x n</code>&nbsp;的二维整数数组表示的图画&nbsp;<code>image</code>&nbsp;，其中&nbsp;<code>image[i][j]</code>&nbsp;表示该图画的像素值大小。</p>\n\n<p>你也被给予三个整数 <code>sr</code> ,&nbsp; <code>sc</code> 和 <code>newColor</code> 。你应该从像素&nbsp;<code>image[sr][sc]</code>&nbsp;开始对图像进行 上色<strong>填充</strong> 。</p>\n\n<p>为了完成<strong> 上色工作</strong> ，从初始像素开始，记录初始坐标的 <strong>上下左右四个方向上</strong> 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 <strong>四个方向上</strong> 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为&nbsp;<code>newColor</code>&nbsp;。</p>\n\n<p>最后返回 <em>经过上色渲染后的图像&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/01/flood1-grid.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> image = [[1,1,1],[1,1,0],[1,0,1]]，sr = 1, sc = 1, newColor = 2\n<strong>输出:</strong> [[2,2,2],[2,2,0],[2,0,1]]\n<strong>解析:</strong> 在图像的正中间，(坐标(sr,sc)=(1,1)),在路径上所有符合条件的像素点的颜色都被更改成2。\n注意，右下角的像素没有更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2\n<strong>输出:</strong> [[2,2,2],[2,2,2]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>m == image.length</code></li>\n\t<li><code>n == image[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>0 &lt;= image[i][j], newColor &lt; 2<sup>16</sup></code></li>\n\t<li><code>0 &lt;= sr &lt;&nbsp;m</code></li>\n\t<li><code>0 &lt;= sc &lt;&nbsp;n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 734句子相似性",
        "hardRate": "EASY",
        "passRate": "46.67%",
        "problemsUrl": "https://leetcode.cn/problems/sentence-similarity/",
        "solutionsUrl": "https://leetcode.cn/problems/sentence-similarity/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 735行星碰撞",
        "hardRate": "MEDIUM",
        "passRate": "42.90%",
        "problemsUrl": "https://leetcode.cn/problems/asteroid-collision/",
        "solutionsUrl": "https://leetcode.cn/problems/asteroid-collision/solution",
        "problemsDesc": "<p>给定一个整数数组 <code>asteroids</code>，表示在同一行的行星。</p>\n\n<p>对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。</p>\n\n<p>找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>asteroids = [5,10,-5]\n<strong>输出：</strong>[5,10]\n<b>解释：</b>10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>asteroids = [8,-8]\n<strong>输出：</strong>[]\n<b>解释：</b>8 和 -8 碰撞后，两者都发生爆炸。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>asteroids = [10,2,-5]\n<strong>输出：</strong>[10]\n<b>解释：</b>2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下 10 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= asteroids.length&nbsp;&lt;= 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= asteroids[i] &lt;= 1000</code></li>\n\t<li><code>asteroids[i] != 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 736Lisp 语法解析",
        "hardRate": "HARD",
        "passRate": "66.35%",
        "problemsUrl": "https://leetcode.cn/problems/parse-lisp-expression/",
        "solutionsUrl": "https://leetcode.cn/problems/parse-lisp-expression/solution",
        "problemsDesc": "<p>给你一个类似 Lisp 语句的字符串表达式 <code>expression</code>，求出其计算结果。</p>\n\n<p>表达式语法如下所示:</p>\n\n<ul>\n\t<li>表达式可以为整数，<strong>let</strong> 表达式，<strong>add</strong> 表达式，<strong>mult</strong> 表达式，或赋值的变量。表达式的结果总是一个整数。</li>\n\t<li>(整数可以是正整数、负整数、0)</li>\n\t<li><strong>let</strong> 表达式采用&nbsp;<code>\"(let v<sub>1</sub> e<sub>1</sub> v<sub>2</sub> e<sub>2</sub> ... v<sub>n</sub> e<sub>n</sub> expr)\"</code> 的形式，其中&nbsp;<code>let</code> 总是以字符串&nbsp;<code>\"let\"</code>来表示，接下来会跟随一对或多对交替的变量和表达式，也就是说，第一个变量&nbsp;<code>v<sub>1</sub></code>被分配为表达式&nbsp;<code>e<sub>1</sub></code>&nbsp;的值，第二个变量&nbsp;<code>v<sub>2</sub></code>&nbsp;被分配为表达式&nbsp;<code>e<sub>2</sub></code>&nbsp;的值，<strong>依次类推</strong>；最终 <code>let</code> 表达式的值为&nbsp;<code>expr</code>表达式的值。</li>\n\t<li><strong>add </strong>表达式表示为&nbsp;<code>\"(add e<sub>1</sub> e<sub>2</sub>)\"</code> ，其中&nbsp;<code>add</code> 总是以字符串&nbsp;<code>\"add\"</code> 来表示，该表达式总是包含两个表达式 <code>e<sub>1</sub></code>、<code>e<sub>2</sub></code> ，最终结果是&nbsp;<code>e<sub>1</sub></code> 表达式的值与&nbsp;<code>e<sub>2</sub></code>&nbsp;表达式的值之 <strong>和 </strong>。</li>\n\t<li><strong>mult</strong> 表达式表示为&nbsp;<code>\"(mult e<sub>1</sub> e<sub>2</sub>)\"</code>&nbsp;，其中&nbsp;<code>mult</code> 总是以字符串 <code>\"mult\"</code> 表示，该表达式总是包含两个表达式 <code>e<sub>1</sub></code>、<code>e<sub>2</sub></code>，最终结果是&nbsp;<code>e<sub>1</sub></code> 表达式的值与&nbsp;<code>e<sub>2</sub></code>&nbsp;表达式的值之<strong> 积 </strong>。</li>\n\t<li>在该题目中，变量名以小写字符开始，之后跟随 0 个或多个小写字符或数字。为了方便，<code>\"add\"</code> ，<code>\"let\"</code> ，<code>\"mult\"</code> 会被定义为 \"关键字\" ，不会用作变量名。</li>\n\t<li>最后，要说一下作用域的概念。计算变量名所对应的表达式时，在计算上下文中，首先检查最内层作用域（按括号计），然后按顺序依次检查外部作用域。测试用例中每一个表达式都是合法的。有关作用域的更多详细信息，请参阅示例。</li>\n</ul>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"(let x 2 (mult x (let x 3 y 4 (add x y))))\"\n<strong>输出：</strong>14\n<strong>解释：</strong>\n计算表达式 (add x y), 在检查变量 x 值时，\n在变量的上下文中由最内层作用域依次向外检查。\n首先找到 x = 3, 所以此处的 x 值是 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"(let x 3 x 2 x)\"\n<strong>输出：</strong>2\n<strong>解释：</strong>let 语句中的赋值运算按顺序处理即可。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"(let x 1 y 2 x (add x y) (add x y))\"\n<strong>输出：</strong>5\n<strong>解释：</strong>\n第一个 (add x y) 计算结果是 3，并且将此值赋给了 x 。 \n第二个 (add x y) 计算结果是 3 + 2 = 5 。\n</pre>\n&nbsp;\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= expression.length &lt;= 2000</code></li>\n\t<li><code>exprssion</code> 中不含前导和尾随空格</li>\n\t<li><code>expressoin</code> 中的不同部分（token）之间用单个空格进行分隔</li>\n\t<li>答案和所有中间计算结果都符合 <strong>32-bit</strong> 整数范围</li>\n\t<li>测试用例中的表达式均为合法的且最终结果为整数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 737句子相似性 II",
        "hardRate": "MEDIUM",
        "passRate": "48.39%",
        "problemsUrl": "https://leetcode.cn/problems/sentence-similarity-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/sentence-similarity-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 738单调递增的数字",
        "hardRate": "MEDIUM",
        "passRate": "50.33%",
        "problemsUrl": "https://leetcode.cn/problems/monotone-increasing-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/monotone-increasing-digits/solution",
        "problemsDesc": "<p>当且仅当每个相邻位数上的数字&nbsp;<code>x</code>&nbsp;和&nbsp;<code>y</code>&nbsp;满足&nbsp;<code>x &lt;= y</code>&nbsp;时，我们称这个整数是<strong>单调递增</strong>的。</p>\n\n<p>给定一个整数 <code>n</code> ，返回 <em>小于或等于 <code>n</code> 的最大数字，且数字呈 <strong>单调递增</strong></em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 10\n<strong>输出:</strong> 9\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 1234\n<strong>输出:</strong> 1234\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 332\n<strong>输出:</strong> 299\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 739每日温度",
        "hardRate": "MEDIUM",
        "passRate": "68.89%",
        "problemsUrl": "https://leetcode.cn/problems/daily-temperatures/",
        "solutionsUrl": "https://leetcode.cn/problems/daily-temperatures/solution",
        "problemsDesc": "<p>给定一个整数数组&nbsp;<code>temperatures</code>&nbsp;，表示每天的温度，返回一个数组&nbsp;<code>answer</code>&nbsp;，其中&nbsp;<code>answer[i]</code>&nbsp;是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用&nbsp;<code>0</code> 来代替。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>temperatures</code> = [73,74,75,71,69,72,76,73]\n<strong>输出:</strong>&nbsp;[1,1,4,2,1,1,0,0]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> temperatures = [30,40,50,60]\n<strong>输出:</strong>&nbsp;[1,1,1,0]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> temperatures = [30,60,90]\n<strong>输出: </strong>[1,1,0]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;temperatures.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>30 &lt;=&nbsp;temperatures[i]&nbsp;&lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 740删除并获得点数",
        "hardRate": "MEDIUM",
        "passRate": "62.01%",
        "problemsUrl": "https://leetcode.cn/problems/delete-and-earn/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-and-earn/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，你可以对它进行一些操作。</p>\n\n<p>每次操作中，选择任意一个 <code>nums[i]</code> ，删除它并获得 <code>nums[i]</code> 的点数。之后，你必须删除 <strong>所有 </strong>等于 <code>nums[i] - 1</code> 和 <code>nums[i] + 1</code> 的元素。</p>\n\n<p>开始你拥有 <code>0</code> 个点数。返回你能通过这些操作获得的最大点数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,2]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n删除 4 获得 4 个点数，因此 3 也被删除。\n之后，删除 2 获得 2 个点数。总共获得 6 个点数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,3,3,3,4]\n<strong>输出：</strong>9\n<strong>解释：</strong>\n删除 3 获得 3 个点数，接着要删除两个 2 和 4 。\n之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。\n总共获得 9 个点数。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 741摘樱桃",
        "hardRate": "HARD",
        "passRate": "50.52%",
        "problemsUrl": "https://leetcode.cn/problems/cherry-pickup/",
        "solutionsUrl": "https://leetcode.cn/problems/cherry-pickup/solution",
        "problemsDesc": "<p>给你一个 <code>n x n</code> 的网格 <code>grid</code> ，代表一块樱桃地，每个格子由以下三种数字的一种来表示：</p>\n\n<ul>\n\t<li><code>0</code> 表示这个格子是空的，所以你可以穿过它。</li>\n\t<li><code>1</code> 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。</li>\n\t<li><code>-1</code> 表示这个格子里有荆棘，挡着你的路。</li>\n</ul>\n\n<p>请你统计并返回：在遵守下列规则的情况下，能摘到的最多樱桃数：</p>\n\n<ul>\n\t<li>从位置&nbsp;<code>(0, 0)</code> 出发，最后到达 <code>(n - 1, n - 1)</code> ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为 <code>0</code> 或者 <code>1</code> 的格子）；</li>\n\t<li>当到达 <code>(n - 1, n&nbsp;- 1)</code> 后，你要继续走，直到返回到 <code>(0, 0) </code>，只能向上或向左走，并且只能穿越有效的格子；</li>\n\t<li>当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为 <code>0</code> ）；</li>\n\t<li>如果在 <code>(0, 0)</code> 和 <code>(n - 1, n - 1)</code> 之间不存在一条可经过的路径，则无法摘到任何一个樱桃。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/14/grid.jpg\" />\n<pre>\n<b>输入：</b>grid = [[0,1,-1],[1,0,-1],[1,1,1]]\n<b>输出：</b>5\n<b>解释：</b>玩家从 (0, 0) 出发：向下、向下、向右、向右移动至 (2, 2) 。\n在这一次行程中捡到 4 个樱桃，矩阵变成 [[0,1,-1],[0,0,-1],[0,0,0]] 。\n然后，玩家向左、向上、向上、向左返回起点，再捡到 1 个樱桃。\n总共捡到 5 个樱桃，这是最大可能值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>grid = [[1,1,-1],[1,-1,1],[-1,1,1]]\n<b>输出：</b>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>grid[i][j]</code>&nbsp;为&nbsp;<code>-1</code>、<code>0</code>&nbsp;或&nbsp;<code>1</code></li>\n\t<li><code>grid[0][0] != -1</code></li>\n\t<li><code>grid[n - 1][n - 1] != -1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 742二叉树最近的叶节点",
        "hardRate": "MEDIUM",
        "passRate": "48.91%",
        "problemsUrl": "https://leetcode.cn/problems/closest-leaf-in-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-leaf-in-a-binary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 743网络延迟时间",
        "hardRate": "MEDIUM",
        "passRate": "55.65%",
        "problemsUrl": "https://leetcode.cn/problems/network-delay-time/",
        "solutionsUrl": "https://leetcode.cn/problems/network-delay-time/solution",
        "problemsDesc": "<p>有 <code>n</code> 个网络节点，标记为&nbsp;<code>1</code>&nbsp;到 <code>n</code>。</p>\n\n<p>给你一个列表&nbsp;<code>times</code>，表示信号经过 <strong>有向</strong> 边的传递时间。&nbsp;<code>times[i] = (u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>)</code>，其中&nbsp;<code>u<sub>i</sub></code>&nbsp;是源节点，<code>v<sub>i</sub></code>&nbsp;是目标节点， <code>w<sub>i</sub></code>&nbsp;是一个信号从源节点传递到目标节点的时间。</p>\n\n<p>现在，从某个节点&nbsp;<code>K</code>&nbsp;发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回&nbsp;<code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png\" style=\"height: 220px; width: 200px;\" /></p>\n\n<pre>\n<strong>输入：</strong>times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>times = [[1,2,1]], n = 2, k = 1\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>times = [[1,2,1]], n = 2, k = 2\n<strong>输出：</strong>-1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= times.length &lt;= 6000</code></li>\n\t<li><code>times[i].length == 3</code></li>\n\t<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n\t<li><code>0 &lt;= w<sub>i</sub> &lt;= 100</code></li>\n\t<li>所有 <code>(u<sub>i</sub>, v<sub>i</sub>)</code> 对都 <strong>互不相同</strong>（即，不含重复边）</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 744寻找比目标字母大的最小字母",
        "hardRate": "EASY",
        "passRate": "48.36%",
        "problemsUrl": "https://leetcode.cn/problems/find-smallest-letter-greater-than-target/",
        "solutionsUrl": "https://leetcode.cn/problems/find-smallest-letter-greater-than-target/solution",
        "problemsDesc": "<p>给你一个字符数组 <code>letters</code>，该数组按<strong>非递减顺序</strong>排序，以及一个字符 <code>target</code>。<code>letters</code>&nbsp;里<strong>至少有两个不同</strong>的字符。</p>\n\n<p>返回&nbsp;<code>letters</code>&nbsp;中大于 <code>target</code> 的最小的字符。如果不存在这样的字符，则返回&nbsp;<code>letters</code> 的第一个字符。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>letters = [\"c\", \"f\", \"j\"]，target = \"a\"\n<strong>输出:</strong> \"c\"\n<strong>解释：</strong>letters 中字典上比 'a' 大的最小字符是 'c'。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> letters = [\"c\",\"f\",\"j\"], target = \"c\"\n<strong>输出:</strong> \"f\"\n<strong>解释：</strong>letters 中字典顺序上大于 'c' 的最小字符是 'f'。</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> letters = [\"x\",\"x\",\"y\",\"y\"], target = \"z\"\n<strong>输出:</strong> \"x\"\n<strong>解释：</strong>letters 中没有一个字符在字典上大于 'z'，所以我们返回 letters[0]。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= letters.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>letters[i]</code>&nbsp;是一个小写字母</li>\n\t<li><code>letters</code> 按<strong>非递减顺序</strong>排序</li>\n\t<li><code>letters</code> 最少包含两个不同的字母</li>\n\t<li><code>target</code> 是一个小写字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 745前缀和后缀搜索",
        "hardRate": "HARD",
        "passRate": "43.92%",
        "problemsUrl": "https://leetcode.cn/problems/prefix-and-suffix-search/",
        "solutionsUrl": "https://leetcode.cn/problems/prefix-and-suffix-search/solution",
        "problemsDesc": "<p>设计一个包含一些单词的特殊词典，并能够通过前缀和后缀来检索单词。</p>\n\n<p>实现 <code>WordFilter</code> 类：</p>\n\n<ul>\n\t<li><code>WordFilter(string[] words)</code> 使用词典中的单词 <code>words</code> 初始化对象。</li>\n\t<li><code>f(string pref, string suff)</code> 返回词典中具有前缀&nbsp;<code>prefix</code>&nbsp;和后缀 <code>suff</code>&nbsp;的单词的下标。如果存在不止一个满足要求的下标，返回其中 <strong>最大的下标</strong> 。如果不存在这样的单词，返回 <code>-1</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"WordFilter\", \"f\"]\n[[[\"apple\"]], [\"a\", \"e\"]]\n<strong>输出</strong>\n[null, 0]\n<strong>解释</strong>\nWordFilter wordFilter = new WordFilter([\"apple\"]);\nwordFilter.f(\"a\", \"e\"); // 返回 0 ，因为下标为 0 的单词：前缀 prefix = \"a\" 且 后缀 suff = \"e\" 。\n</pre>\n&nbsp;\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 7</code></li>\n\t<li><code>1 &lt;= pref.length, suff.length &lt;= 7</code></li>\n\t<li><code>words[i]</code>、<code>pref</code> 和 <code>suff</code> 仅由小写英文字母组成</li>\n\t<li>最多对函数 <code>f</code> 执行 <code>10<sup>4</sup></code> 次调用</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 746使用最小花费爬楼梯",
        "hardRate": "EASY",
        "passRate": "64.76%",
        "problemsUrl": "https://leetcode.cn/problems/min-cost-climbing-stairs/",
        "solutionsUrl": "https://leetcode.cn/problems/min-cost-climbing-stairs/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>\n\n<p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p>\n\n<p>请你计算并返回达到楼梯顶部的最低花费。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>cost = [10,<em><strong>15</strong></em>,20]\n<strong>输出：</strong>15\n<strong>解释：</strong>你将从下标为 1 的台阶开始。\n- 支付 15 ，向上爬两个台阶，到达楼梯顶部。\n总花费为 15 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>cost = [<em><strong>1</strong></em>,100,<em><strong>1</strong></em>,1,<em><strong>1</strong></em>,100,<em><strong>1</strong></em>,<em><strong>1</strong></em>,100,<em><strong>1</strong></em>]\n<strong>输出：</strong>6\n<strong>解释：</strong>你将从下标为 0 的台阶开始。\n- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。\n- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。\n- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。\n- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。\n- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。\n- 支付 1 ，向上爬一个台阶，到达楼梯顶部。\n总花费为 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= cost.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= cost[i] &lt;= 999</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 747至少是其他数字两倍的最大数",
        "hardRate": "EASY",
        "passRate": "46.33%",
        "problemsUrl": "https://leetcode.cn/problems/largest-number-at-least-twice-of-others/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-number-at-least-twice-of-others/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，其中总是存在 <strong>唯一的</strong> 一个最大整数 。</p>\n\n<p>请你找出数组中的最大元素并检查它是否 <strong>至少是数组中每个其他数字的两倍</strong> 。如果是，则返回 <strong>最大元素的下标</strong> ，否则返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,6,1,0]\n<strong>输出：</strong>1\n<strong>解释：</strong>6 是最大的整数，对于数组中的其他整数，6 至少是数组中其他元素的两倍。6 的下标是 1 ，所以返回 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>-1\n<strong>解释：</strong>4 没有超过 3 的两倍大，所以返回 -1 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1]\n<strong>输出：</strong>0\n<strong>解释：</strong>因为不存在其他数字，所以认为现有数字 1 至少是其他数字的两倍。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>nums</code> 中的最大元素是唯一的</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 748最短补全词",
        "hardRate": "EASY",
        "passRate": "66.66%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-completing-word/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-completing-word/solution",
        "problemsDesc": "<p>给你一个字符串 <code>licensePlate</code> 和一个字符串数组 <code>words</code> ，请你找出&nbsp;<code>words</code> 中的 <strong>最短补全词</strong> 。</p>\n\n<p><strong>补全词 </strong>是一个包含 <code>licensePlate</code> 中所有字母的单词。<strong>忽略</strong>&nbsp;<code>licensePlate</code> 中的 <strong>数字和空格 </strong>。<strong>不区分大小写</strong>。如果某个字母在 <code>licensePlate</code> 中出现不止一次，那么该字母在补全词中的出现次数应当一致或者更多。</p>\n\n<p>例如：<code>licensePlate</code><code> = \"aBc 12c\"</code>，那么它的补全词应当包含字母 <code>'a'</code>、<code>'b'</code> （忽略大写）和两个 <code>'c'</code> 。可能的 <strong>补全词</strong> 有 <code>\"abccdef\"</code>、<code>\"caaacab\"</code> 以及 <code>\"cbca\"</code> 。</p>\n\n<p>请返回 <code>words</code> 中的 <strong>最短补全词</strong> 。题目数据保证一定存在一个最短补全词。当有多个单词都符合最短补全词的匹配条件时取 <code>words</code> 中 <strong>第一个</strong> 出现的那个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>licensePlate = \"1s3 PSt\", words = [\"step\", \"steps\", \"stripe\", \"stepple\"]\n<strong>输出：</strong>\"steps\"\n<strong>解释：</strong>最短补全词应该包括 \"s\"、\"p\"、\"s\"（忽略大小写） 以及 \"t\"。\n\"step\" 包含 \"t\"、\"p\"，但只包含一个 \"s\"，所以它不符合条件。\n\"steps\" 包含 \"t\"、\"p\" 和两个 \"s\"。\n\"stripe\" 缺一个 \"s\"。\n\"stepple\" 缺一个 \"s\"。\n因此，\"steps\" 是唯一一个包含所有字母的单词，也是本例的答案。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>licensePlate = \"1s3 456\", words = [\"looks\", \"pest\", \"stew\", \"show\"]\n<strong>输出：</strong>\"pest\"\n<strong>解释：</strong>licensePlate 只包含字母 \"s\" 。所有的单词都包含字母 \"s\" ，其中 \"pest\"、\"stew\"、和 \"show\" 三者最短。答案是 \"pest\" ，因为它是三个单词中在 words 里最靠前的那个。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= licensePlate.length &lt;= 7</code></li>\n\t<li><code>licensePlate</code> 由数字、大小写字母或空格 <code>' '</code> 组成</li>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 15</code></li>\n\t<li><code>words[i]</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 749隔离病毒",
        "hardRate": "HARD",
        "passRate": "69.05%",
        "problemsUrl": "https://leetcode.cn/problems/contain-virus/",
        "solutionsUrl": "https://leetcode.cn/problems/contain-virus/solution",
        "problemsDesc": "<p>病毒扩散得很快，现在你的任务是尽可能地通过安装防火墙来隔离病毒。</p>\n\n<p>假设世界由&nbsp;<code>m x n</code>&nbsp;的二维矩阵&nbsp;<code>isInfected</code>&nbsp;组成，&nbsp;<code>isInfected[i][j] == 0</code>&nbsp;表示该区域未感染病毒，而 &nbsp;<code>isInfected[i][j] == 1</code>&nbsp;表示该区域已感染病毒。可以在任意 2 个相邻单元之间的共享边界上安装一个防火墙（并且只有一个防火墙）。</p>\n\n<p>每天晚上，病毒会从被感染区域向相邻未感染区域扩散，除非被防火墙隔离。现由于资源有限，每天你只能安装一系列防火墙来隔离其中一个被病毒感染的区域（一个区域或连续的一片区域），且该感染区域对未感染区域的威胁最大且 <strong>保证唯一&nbsp;</strong>。</p>\n\n<p>你需要努力使得最后有部分区域不被病毒感染，如果可以成功，那么返回需要使用的防火墙个数; 如果无法实现，则返回在世界被病毒全部感染时已安装的防火墙个数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/01/virus11-grid.jpg\" style=\"height: 255px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入:</strong> isInfected = [[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]]\n<strong>输出:</strong> 10\n<strong>解释:</strong>一共有两块被病毒感染的区域。\n在第一天，添加 5 墙隔离病毒区域的左侧。病毒传播后的状态是:\n<img src=\"https://assets.leetcode.com/uploads/2021/06/01/virus12edited-grid.jpg\" style=\"height: 261px; width: 500px;\" />\n第二天，在右侧添加 5 个墙来隔离病毒区域。此时病毒已经被完全控制住了。\n<img src=\"https://assets.leetcode.com/uploads/2021/06/01/virus13edited-grid.jpg\" style=\"height: 261px; width: 500px;\" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/01/virus2-grid.jpg\" style=\"height: 253px; width: 653px;\" /></p>\n\n<pre>\n<strong>输入:</strong> isInfected = [[1,1,1],[1,0,1],[1,1,1]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> 虽然只保存了一个小区域，但却有四面墙。\n注意，防火墙只建立在两个不同区域的共享边界上。\n</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre>\n<strong>输入:</strong> isInfected = [[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]]\n<strong>输出:</strong> 13\n<strong>解释:</strong> 在隔离右边感染区域后，隔离左边病毒区域只需要 2 个防火墙。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>m ==&nbsp;isInfected.length</code></li>\n\t<li><code>n ==&nbsp;isInfected[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>isInfected[i][j]</code>&nbsp;is either&nbsp;<code>0</code>&nbsp;or&nbsp;<code>1</code></li>\n\t<li>在整个描述的过程中，总有一个相邻的病毒区域，它将在下一轮 <strong>严格地感染更多未受污染的方块</strong>&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 750角矩形的数量",
        "hardRate": "MEDIUM",
        "passRate": "73.11%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-corner-rectangles/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-corner-rectangles/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 751IP 到 CIDR",
        "hardRate": "MEDIUM",
        "passRate": "48.37%",
        "problemsUrl": "https://leetcode.cn/problems/ip-to-cidr/",
        "solutionsUrl": "https://leetcode.cn/problems/ip-to-cidr/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 752打开转盘锁",
        "hardRate": "MEDIUM",
        "passRate": "52.71%",
        "problemsUrl": "https://leetcode.cn/problems/open-the-lock/",
        "solutionsUrl": "https://leetcode.cn/problems/open-the-lock/solution",
        "problemsDesc": "<p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： <code>'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'</code> 。每个拨轮可以自由旋转：例如把 <code>'9'</code> 变为&nbsp;<code>'0'</code>，<code>'0'</code> 变为 <code>'9'</code> 。每次旋转都只能旋转一个拨轮的一位数字。</p>\n\n<p>锁的初始数字为 <code>'0000'</code> ，一个代表四个拨轮的数字的字符串。</p>\n\n<p>列表 <code>deadends</code> 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p>\n\n<p>字符串 <code>target</code> 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"\n<strong>输出：</strong>6\n<strong>解释：</strong>\n可能的移动序列为 \"0000\" -&gt; \"1000\" -&gt; \"1100\" -&gt; \"1200\" -&gt; \"1201\" -&gt; \"1202\" -&gt; \"0202\"。\n注意 \"0000\" -&gt; \"0001\" -&gt; \"0002\" -&gt; \"0102\" -&gt; \"0202\" 这样的序列是不能解锁的，\n因为当拨动到 \"0102\" 时这个锁就会被锁定。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> deadends = [\"8888\"], target = \"0009\"\n<strong>输出：</strong>1\n<strong>解释：</strong>把最后一位反向旋转一次即可 \"0000\" -&gt; \"0009\"。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"\n<strong>输出：</strong>-1\n<strong>解释：</strong>无法旋转到目标数字且不被锁定。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;deadends.length &lt;= 500</code></li>\n\t<li><code><font face=\"monospace\">deadends[i].length == 4</font></code></li>\n\t<li><code><font face=\"monospace\">target.length == 4</font></code></li>\n\t<li><code>target</code> <strong>不在</strong> <code>deadends</code> 之中</li>\n\t<li><code>target</code> 和 <code>deadends[i]</code> 仅由若干位数字组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 753破解保险箱",
        "hardRate": "HARD",
        "passRate": "74.87%",
        "problemsUrl": "https://leetcode.cn/problems/cracking-the-safe/",
        "solutionsUrl": "https://leetcode.cn/problems/cracking-the-safe/solution",
        "problemsDesc": "<p>有一个需要密码才能打开的保险箱。密码是&nbsp;<code>n</code> 位数, 密码的每一位都是范围&nbsp;<code>[0, k - 1]</code>&nbsp;中的一个数字。</p>\n\n<p>保险箱有一种特殊的密码校验方法，你可以随意输入密码序列，保险箱会自动记住 <strong>最后&nbsp;<code>n</code>&nbsp;位输入</strong> ，如果匹配，则能够打开保险箱。</p>\n\n<ul>\n\t<li>例如，正确的密码是 <code>\"345\"</code> ，并且你输入的是 <code>\"012345\"</code> ：\n\n\t<ul>\n\t\t<li>输入 <code>0</code> 之后，最后 <code>3</code> 位输入是 <code>\"0\"</code> ，不正确。</li>\n\t\t<li>输入 <code>1</code> 之后，最后 <code>3</code> 位输入是 <code>\"01\"</code> ，不正确。</li>\n\t\t<li>输入 <code>2</code> 之后，最后 <code>3</code> 位输入是 <code>\"012\"</code> ，不正确。</li>\n\t\t<li>输入 <code>3</code> 之后，最后 <code>3</code> 位输入是 <code>\"123\"</code> ，不正确。</li>\n\t\t<li>输入 <code>4</code> 之后，最后 <code>3</code> 位输入是 <code>\"234\"</code> ，不正确。</li>\n\t\t<li>输入 <code>5</code> 之后，最后 <code>3</code> 位输入是 <code>\"345\"</code> ，正确，打开保险箱。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>在只知道密码位数 <code>n</code> 和范围边界 <code>k</code> 的前提下，请你找出并返回确保在输入的 <strong>某个时刻</strong> 能够打开保险箱的任一 <strong>最短</strong> 密码序列 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, k = 2\n<strong>输出：</strong>\"10\"\n<strong>解释：</strong>密码只有 1 位，所以输入每一位就可以。\"01\" 也能够确保打开保险箱。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, k = 2\n<strong>输出：</strong>\"01100\"\n<strong>解释：</strong>对于每种可能的密码：\n- \"00\" 从第 4 位开始输入。\n- \"01\" 从第 1 位开始输入。\n- \"10\" 从第 3 位开始输入。\n- \"11\" 从第 2 位开始输入。\n因此 \"01100\" 可以确保打开保险箱。\"01100\"、\"10011\" 和 \"11001\" 也可以确保打开保险箱。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 4</code></li>\n\t<li><code>1 &lt;= k &lt;= 10</code></li>\n\t<li><code>1 &lt;= k<sup>n</sup> &lt;= 4096</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 754到达终点数字",
        "hardRate": "MEDIUM",
        "passRate": "51.42%",
        "problemsUrl": "https://leetcode.cn/problems/reach-a-number/",
        "solutionsUrl": "https://leetcode.cn/problems/reach-a-number/solution",
        "problemsDesc": "<p>在一根无限长的数轴上，你站在<code>0</code>的位置。终点在<code>target</code>的位置。</p>\n\n<p>你可以做一些数量的移动 <code>numMoves</code> :</p>\n\n<ul>\n\t<li>每次你可以选择向左或向右移动。</li>\n\t<li>第 <code>i</code>&nbsp;次移动（从 &nbsp;<code>i == 1</code>&nbsp;开始，到&nbsp;<code>i == numMoves</code> ），在选择的方向上走 <code>i</code>&nbsp;步。</li>\n</ul>\n\n<p>给定整数&nbsp;<code>target</code> ，返回 <em>到达目标所需的 <strong>最小&nbsp;</strong>移动次数(即最小 <code>numMoves</code> )&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> target = 2\n<strong>输出:</strong> 3\n<strong>解释:</strong>\n第一次移动，从 0 到 1 。\n第二次移动，从 1 到 -1 。\n第三次移动，从 -1 到 2 。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> target = 3\n<strong>输出:</strong> 2\n<strong>解释:</strong>\n第一次移动，从 0 到 1 。\n第二次移动，从 1 到 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><code>target != 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 755倒水",
        "hardRate": "MEDIUM",
        "passRate": "48.26%",
        "problemsUrl": "https://leetcode.cn/problems/pour-water/",
        "solutionsUrl": "https://leetcode.cn/problems/pour-water/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 756金字塔转换矩阵",
        "hardRate": "MEDIUM",
        "passRate": "52.18%",
        "problemsUrl": "https://leetcode.cn/problems/pyramid-transition-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/pyramid-transition-matrix/solution",
        "problemsDesc": "<p>你正在把积木堆成金字塔。每个块都有一个颜色，用一个字母表示。每一行的块比它下面的行 <strong>少一个块</strong> ，并且居中。</p>\n\n<p>为了使金字塔美观，只有特定的 <strong>三角形图案</strong> 是允许的。一个三角形的图案由&nbsp;<strong>两个块</strong>&nbsp;和叠在上面的 <strong>单个块</strong> 组成。模式是以三个字母字符串的列表形式&nbsp;<code>allowed</code>&nbsp;给出的，其中模式的前两个字符分别表示左右底部块，第三个字符表示顶部块。</p>\n\n<ul>\n\t<li>例如，<code>\"ABC\"</code>&nbsp;表示一个三角形图案，其中一个 <code>“C”</code> 块堆叠在一个&nbsp;<code>'A'</code>&nbsp;块(左)和一个&nbsp;<code>'B'</code>&nbsp;块(右)之上。请注意，这与 <code>\"BAC\"</code>&nbsp;不同，<code>\"B\"</code>&nbsp;在左下角，<code>\"A\"</code>&nbsp;在右下角。</li>\n</ul>\n\n<p>你从底部的一排积木&nbsp;<code>bottom</code>&nbsp;开始，作为一个单一的字符串，你 <strong>必须</strong> 使用作为金字塔的底部。</p>\n\n<p>在给定&nbsp;<code>bottom</code>&nbsp;和&nbsp;<code>allowed</code>&nbsp;的情况下，如果你能一直构建到金字塔顶部，使金字塔中的 <strong>每个三角形图案</strong> 都是允许的，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/26/pyramid1-grid.jpg\" style=\"height: 232px; width: 600px;\" /></p>\n\n<pre>\n<strong>输入：</strong>bottom = \"BCD\", allowed = [\"BCC\",\"CDE\",\"CEA\",\"FFF\"]\n<strong>输出：</strong>true\n<strong>解释：</strong>允许的三角形模式显示在右边。\n从最底层(第3层)开始，我们可以在第2层构建“CE”，然后在第1层构建“E”。\n金字塔中有三种三角形图案，分别是“BCC”、“CDE”和“CEA”。都是允许的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/26/pyramid2-grid.jpg\" style=\"height: 359px; width: 600px;\" /></p>\n\n<pre>\n<strong>输入：</strong>bottom = \"AAAA\", allowed = [\"AAB\",\"AAC\",\"BCD\",\"BBE\",\"DEF\"]\n<strong>输出：</strong>false\n<strong>解释：</strong>允许的三角形模式显示在右边。\n从最底层(游戏邦注:即第4个关卡)开始，创造第3个关卡有多种方法，但如果尝试所有可能性，你便会在创造第1个关卡前陷入困境。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= bottom.length &lt;= 6</code></li>\n\t<li><code>0 &lt;= allowed.length &lt;= 216</code></li>\n\t<li><code>allowed[i].length == 3</code></li>\n\t<li>所有输入字符串中的字母来自集合&nbsp;<code>{'A', 'B', 'C', 'D', 'E', 'F', 'G'}</code>。</li>\n\t<li>&nbsp;<code>allowed</code>&nbsp;中所有值都是 <strong>唯一的</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 757设置交集大小至少为2",
        "hardRate": "HARD",
        "passRate": "56.07%",
        "problemsUrl": "https://leetcode.cn/problems/set-intersection-size-at-least-two/",
        "solutionsUrl": "https://leetcode.cn/problems/set-intersection-size-at-least-two/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>intervals</code> ，其中 <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 表示从 <code>start<sub>i</sub></code> 到 <code>end<sub>i</sub></code> 的所有整数，包括 <code>start<sub>i</sub></code> 和 <code>end<sub>i</sub></code> 。</p>\n\n<p><strong>包含集合</strong> 是一个名为 <code>nums</code> 的数组，并满足 <code>intervals</code> 中的每个区间都 <strong>至少</strong> 有 <strong>两个</strong> 整数在 <code>nums</code> 中。</p>\n\n<ul>\n\t<li>例如，如果 <code>intervals = [[1,3], [3,7], [8,9]]</code> ，那么 <code>[1,2,4,7,8,9]</code> 和 <code>[2,3,4,8,9]</code> 都符合 <strong>包含集合</strong> 的定义。</li>\n</ul>\n\n<p>返回包含集合可能的最小大小。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,3],[3,7],[8,9]]\n<strong>输出：</strong>5\n<strong>解释：</strong>nums = [2, 3, 4, 8, 9].\n可以证明不存在元素数量为 4 的包含集合。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,3],[1,4],[2,5],[3,5]]\n<strong>输出：</strong>3\n<strong>解释：</strong>nums = [2, 3, 4].\n可以证明不存在元素数量为 2 的包含集合。 \n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,2],[2,3],[2,4],[4,5]]\n<strong>输出：</strong>5\n<strong>解释：</strong>nums = [1, 2, 3, 4, 5].\n可以证明不存在元素数量为 4 的包含集合。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 3000</code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt; end<sub>i</sub> &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 758字符串中的加粗单词",
        "hardRate": "MEDIUM",
        "passRate": "48.33%",
        "problemsUrl": "https://leetcode.cn/problems/bold-words-in-string/",
        "solutionsUrl": "https://leetcode.cn/problems/bold-words-in-string/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 759员工空闲时间",
        "hardRate": "HARD",
        "passRate": "70.54%",
        "problemsUrl": "https://leetcode.cn/problems/employee-free-time/",
        "solutionsUrl": "https://leetcode.cn/problems/employee-free-time/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 760找出变位映射",
        "hardRate": "EASY",
        "passRate": "84.40%",
        "problemsUrl": "https://leetcode.cn/problems/find-anagram-mappings/",
        "solutionsUrl": "https://leetcode.cn/problems/find-anagram-mappings/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 761特殊的二进制序列",
        "hardRate": "HARD",
        "passRate": "75.23%",
        "problemsUrl": "https://leetcode.cn/problems/special-binary-string/",
        "solutionsUrl": "https://leetcode.cn/problems/special-binary-string/solution",
        "problemsDesc": "<p>特殊的二进制序列是具有以下两个性质的二进制序列：</p>\n\n<ul>\n\t<li>0 的数量与 1 的数量相等。</li>\n\t<li>二进制序列的每一个前缀码中 1 的数量要大于等于 0 的数量。</li>\n</ul>\n\n<p>给定一个特殊的二进制序列&nbsp;<code>S</code>，以字符串形式表示。定义一个<em>操作 </em>为首先选择&nbsp;<code>S</code>&nbsp;的两个连续且非空的特殊的子串，然后将它们交换。（两个子串为连续的当且仅当第一个子串的最后一个字符恰好为第二个子串的第一个字符的前一个字符。)</p>\n\n<p>在任意次数的操作之后，交换后的字符串按照字典序排列的最大的结果是什么？</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> S = &quot;11011000&quot;\n<strong>输出:</strong> &quot;11100100&quot;\n<strong>解释:</strong>\n将子串 &quot;10&quot; （在S[1]出现） 和 &quot;1100&quot; （在S[3]出现）进行交换。\n这是在进行若干次操作后按字典序排列最大的结果。\n</pre>\n\n<p><strong>说明:</strong></p>\n\n<ol>\n\t<li><code>S</code>&nbsp;的长度不超过&nbsp;<code>50</code>。</li>\n\t<li><code>S</code>&nbsp;保证为一个满足上述定义的<em>特殊 </em>的二进制序列。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 762二进制表示中质数个计算置位",
        "hardRate": "EASY",
        "passRate": "75.31%",
        "problemsUrl": "https://leetcode.cn/problems/prime-number-of-set-bits-in-binary-representation/",
        "solutionsUrl": "https://leetcode.cn/problems/prime-number-of-set-bits-in-binary-representation/solution",
        "problemsDesc": "<p>给你两个整数&nbsp;<code>left</code>&nbsp;和&nbsp;<code>right</code> ，在闭区间 <code>[left, right]</code>&nbsp;范围内，统计并返回 <strong>计算置位位数为质数</strong> 的整数个数。</p>\n\n<p><strong>计算置位位数</strong> 就是二进制表示中 <code>1</code> 的个数。</p>\n\n<ul>\n\t<li>例如， <code>21</code>&nbsp;的二进制表示&nbsp;<code>10101</code>&nbsp;有 <code>3</code> 个计算置位。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>left = 6, right = 10\n<strong>输出：</strong>4\n<strong>解释：</strong>\n6 -&gt; 110 (2 个计算置位，2 是质数)\n7 -&gt; 111 (3 个计算置位，3 是质数)\n9 -&gt; 1001 (2 个计算置位，2 是质数)\n10-&gt; 1010 (2 个计算置位，2 是质数)\n共计 4 个计算置位为质数的数字。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>left = 10, right = 15\n<strong>输出：</strong>5\n<strong>解释：</strong>\n10 -&gt; 1010 (2 个计算置位, 2 是质数)\n11 -&gt; 1011 (3 个计算置位, 3 是质数)\n12 -&gt; 1100 (2 个计算置位, 2 是质数)\n13 -&gt; 1101 (3 个计算置位, 3 是质数)\n14 -&gt; 1110 (3 个计算置位, 3 是质数)\n15 -&gt; 1111 (4 个计算置位, 4 不是质数)\n共计 5 个计算置位为质数的数字。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= left &lt;= right &lt;= 10<sup>6</sup></code></li>\n\t<li><code>0 &lt;= right - left &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 763划分字母区间",
        "hardRate": "MEDIUM",
        "passRate": "76.79%",
        "problemsUrl": "https://leetcode.cn/problems/partition-labels/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-labels/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p>\n\n<p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code> 。</p>\n\n<p>返回一个表示每个字符串片段的长度的列表。</p>\n\n<p>&nbsp;</p>\n<strong class=\"example\">示例 1：</strong>\n\n<pre>\n<strong>输入：</strong>s = \"ababcbacadefegdehijhklij\"\n<strong>输出：</strong>[9,7,8]\n<strong>解释：</strong>\n划分结果为 \"ababcbaca\"、\"defegde\"、\"hijhklij\" 。\n每个字母最多出现在一个片段中。\n像 \"ababcbacadefegde\", \"hijhklij\" 这样的划分是错误的，因为划分的片段数较少。 </pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"eccbbbbdec\"\n<strong>输出：</strong>[10]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 764最大加号标志",
        "hardRate": "MEDIUM",
        "passRate": "54.24%",
        "problemsUrl": "https://leetcode.cn/problems/largest-plus-sign/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-plus-sign/solution",
        "problemsDesc": "<p>在一个 <code>n x n</code> 的矩阵&nbsp;<code>grid</code>&nbsp;中，除了在数组&nbsp;<code>mines</code>&nbsp;中给出的元素为&nbsp;<code>0</code>，其他每个元素都为&nbsp;<code>1</code>。<code>mines[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>表示&nbsp;<code>grid[x<sub>i</sub>][y<sub>i</sub>] == 0</code></p>\n\n<p>返回 <em>&nbsp;</em><code>grid</code><em> 中包含&nbsp;<code>1</code>&nbsp;的最大的 <strong>轴对齐</strong> 加号标志的阶数</em> 。如果未找到加号标志，则返回 <code>0</code> 。</p>\n\n<p>一个&nbsp;<code>k</code>&nbsp;阶由&nbsp;<em><code>1</code></em>&nbsp;组成的 <strong>“轴对称”加号标志</strong> 具有中心网格&nbsp;<code>grid[r][c] == 1</code>&nbsp;，以及4个从中心向上、向下、向左、向右延伸，长度为&nbsp;<code>k-1</code>，由&nbsp;<code>1</code>&nbsp;组成的臂。注意，只有加号标志的所有网格要求为 <code>1</code> ，别的网格可能为 <code>0</code> 也可能为 <code>1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/13/plus1-grid.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> n = 5, mines = [[4, 2]]\n<strong>输出:</strong> 2\n<strong>解释: </strong>在上面的网格中，最大加号标志的阶只能是2。一个标志已在图中标出。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/13/plus2-grid.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> n = 1, mines = [[0, 0]]\n<strong>输出:</strong> 0\n<strong>解释: </strong>没有加号标志，返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= mines.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt; n</code></li>\n\t<li>每一对&nbsp;<code>(x<sub>i</sub>, y<sub>i</sub>)</code>&nbsp;都 <strong>不重复</strong>​​​​​​​</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 765情侣牵手",
        "hardRate": "HARD",
        "passRate": "65.93%",
        "problemsUrl": "https://leetcode.cn/problems/couples-holding-hands/",
        "solutionsUrl": "https://leetcode.cn/problems/couples-holding-hands/solution",
        "problemsDesc": "<p><code>n</code> 对情侣坐在连续排列的 <code>2n</code>&nbsp;个座位上，想要牵到对方的手。</p>\n\n<p>人和座位由一个整数数组 <code>row</code> 表示，其中 <code>row[i]</code> 是坐在第 <code>i </code>个座位上的人的 <strong>ID</strong>。情侣们按顺序编号，第一对是&nbsp;<code>(0, 1)</code>，第二对是&nbsp;<code>(2, 3)</code>，以此类推，最后一对是&nbsp;<code>(2n-2, 2n-1)</code>。</p>\n\n<p>返回 <em>最少交换座位的次数，以便每对情侣可以并肩坐在一起</em>。 <i>每次</i>交换可选择任意两人，让他们站起来交换座位。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> row = [0,2,1,3]\n<strong>输出:</strong> 1\n<strong>解释:</strong> 只需要交换row[1]和row[2]的位置即可。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> row = [3,2,0,1]\n<strong>输出:</strong> 0\n<strong>解释:</strong> 无需交换座位，所有的情侣都已经可以手牵手了。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>2n == row.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 30</code></li>\n\t<li><code>n</code>&nbsp;是偶数</li>\n\t<li><code>0 &lt;= row[i] &lt; 2n</code></li>\n\t<li><code>row</code>&nbsp;中所有元素均<strong>无重复</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 766托普利茨矩阵",
        "hardRate": "EASY",
        "passRate": "70.24%",
        "problemsUrl": "https://leetcode.cn/problems/toeplitz-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/toeplitz-matrix/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> 。如果这个矩阵是托普利茨矩阵，返回 <code>true</code> ；否则，返回<em> </em><code>false</code><em> 。</em></p>\n\n<p>如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是<em> </em><strong>托普利茨矩阵</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/ex1.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]\n<strong>输出：</strong>true\n<strong>解释：</strong>\n在上述矩阵中, 其对角线为: \n\"[9]\", \"[5, 5]\", \"[1, 1, 1]\", \"[2, 2, 2]\", \"[3, 3]\", \"[4]\"。 \n各条对角线上的所有元素均相同, 因此答案是 True 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/ex2.jpg\" style=\"width: 162px; height: 162px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,2],[2,2]]\n<strong>输出：</strong>false\n<strong>解释：</strong>\n对角线 \"[1, 2]\" 上的元素不同。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 <= m, n <= 20</code></li>\n\t<li><code>0 <= matrix[i][j] <= 99</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>如果矩阵存储在磁盘上，并且内存有限，以至于一次最多只能将矩阵的一行加载到内存中，该怎么办？</li>\n\t<li>如果矩阵太大，以至于一次只能将不完整的一行加载到内存中，该怎么办？</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 767重构字符串",
        "hardRate": "MEDIUM",
        "passRate": "48.45%",
        "problemsUrl": "https://leetcode.cn/problems/reorganize-string/",
        "solutionsUrl": "https://leetcode.cn/problems/reorganize-string/solution",
        "problemsDesc": "<p>给定一个字符串&nbsp;<code>s</code>&nbsp;，检查是否能重新排布其中的字母，使得两相邻的字符不同。</p>\n\n<p>返回<em> <code>s</code>&nbsp;的任意可能的重新排列。若不可行，返回空字符串&nbsp;<code>\"\"</code></em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"aab\"\n<strong>输出:</strong> \"aba\"\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"aaab\"\n<strong>输出:</strong> \"\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>s</code> 只包含小写字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 768最多能完成排序的块 II",
        "hardRate": "HARD",
        "passRate": "58.73%",
        "problemsUrl": "https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> 。</p>\n\n<p>将 <code>arr</code> 分割成若干 <strong>块</strong> ，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。</p>\n\n<p>返回能将数组分成的最多块数？</p>\n&nbsp;\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [5,4,3,2,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n将数组分成2块或者更多块，都无法得到所需的结果。 \n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 \n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [2,1,3,4,4]\n<strong>输出：</strong>4\n<strong>解释：</strong>\n可以把它分成两块，例如 [2, 1], [3, 4, 4]。 \n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 2000</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 769最多能完成排序的块",
        "hardRate": "MEDIUM",
        "passRate": "59.24%",
        "problemsUrl": "https://leetcode.cn/problems/max-chunks-to-make-sorted/",
        "solutionsUrl": "https://leetcode.cn/problems/max-chunks-to-make-sorted/solution",
        "problemsDesc": "<p>给定一个长度为 <code>n</code> 的整数数组 <code>arr</code> ，它表示在 <code>[0, n - 1]</code> 范围内的整数的排列。</p>\n\n<p>我们将 <code>arr</code> 分割成若干 <strong>块</strong> (即分区)，并对每个块单独排序。将它们连接起来后，使得连接的结果和按升序排序后的原数组相同。</p>\n\n<p>返回数组能分成的最多块数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> arr = [4,3,2,1,0]\n<strong>输出:</strong> 1\n<strong>解释:</strong>\n将数组分成2块或者更多块，都无法得到所需的结果。\n例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> arr = [1,0,2,3,4]\n<strong>输出:</strong> 4\n<strong>解释:</strong>\n我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。\n然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。\n对每个块单独排序后，结果为 [0, 1], [2], [3], [4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>n == arr.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10</code></li>\n\t<li><code>0 &lt;= arr[i] &lt; n</code></li>\n\t<li><code>arr</code>&nbsp;中每个元素都 <strong>不同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 770基本计算器 IV",
        "hardRate": "HARD",
        "passRate": "56.07%",
        "problemsUrl": "https://leetcode.cn/problems/basic-calculator-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/basic-calculator-iv/solution",
        "problemsDesc": "<p>给定一个表达式如&nbsp;<code>expression = \"e + 8 - a + 5\"</code>&nbsp;和一个求值映射，如&nbsp;<code>{\"e\": 1}</code>（给定的形式为&nbsp;<code>evalvars = [\"e\"]</code> 和&nbsp;<code>evalints = [1]</code>），返回表示简化表达式的标记列表，例如 <code>[\"-1*a\",\"14\"]</code></p>\n\n<ul>\n\t<li>表达式交替使用块和符号，每个块和符号之间有一个空格。</li>\n\t<li>块要么是括号中的表达式，要么是变量，要么是非负整数。</li>\n\t<li>变量是一个由小写字母组成的字符串（不包括数字）。请注意，变量可以是多个字母，并注意变量从不具有像&nbsp;<code>\"2x\"</code>&nbsp;或&nbsp;<code>\"-x\"</code>&nbsp;这样的前导系数或一元运算符&nbsp;。</li>\n</ul>\n\n<p>表达式按通常顺序进行求值：先是括号，然后求乘法，再计算加法和减法。</p>\n\n<ul>\n\t<li>例如，<code>expression = \"1 + 2 * 3\"</code>&nbsp;的答案是 <code>[\"7\"]</code>。</li>\n</ul>\n\n<p>输出格式如下：</p>\n\n<ul>\n\t<li>对于系数非零的每个自变量项，我们按字典排序的顺序将自变量写在一个项中。\n\t<ul>\n\t\t<li>例如，我们永远不会写像 <code>“b*a*c”</code> 这样的项，只写 <code>“a*b*c”</code>。</li>\n\t</ul>\n\t</li>\n\t<li>项的次数等于被乘的自变量的数目，并计算重复项。我们先写出答案的最大次数项，用字典顺序打破关系，此时忽略词的前导系数。\n\t<ul>\n\t\t<li>例如，<code>\"a*a*b*c\"</code> 的次数为 4。</li>\n\t</ul>\n\t</li>\n\t<li>项的前导系数直接放在左边，用星号将它与变量分隔开(如果存在的话)。前导系数 1 仍然要打印出来。</li>\n\t<li>格式良好的一个示例答案是&nbsp;<code>[\"-2*a*a*a\", \"3*a*a*b\", \"3*b*b\", \"4*a\", \"5*c\", \"-6\"]</code>&nbsp;。</li>\n\t<li>系数为 <code>0</code> 的项（包括常数项）不包括在内。\n\t<ul>\n\t\t<li>例如，<code>“0”</code> 的表达式输出为&nbsp;<code>[]</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p><strong>注意：</strong>你可以假设给定的表达式均有效。所有中间结果都在区间 <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code> 内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"e + 8 - a + 5\", evalvars = [\"e\"], evalints = [1]\n<strong>输出：</strong>[\"-1*a\",\"14\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"e - 8 + temperature - pressure\",\nevalvars = [\"e\", \"temperature\"], evalints = [1, 12]\n<strong>输出：</strong>[\"-1*pressure\",\"5\"]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"(e + 8) * (e - 8)\", evalvars = [], evalints = []\n<strong>输出：</strong>[\"1*e*e\",\"-64\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= expression.length &lt;= 250</code></li>\n\t<li><code>expression</code>&nbsp;由小写英文字母，数字&nbsp;<code>'+'</code>,&nbsp;<code>'-'</code>,&nbsp;<code>'*'</code>,&nbsp;<code>'('</code>,&nbsp;<code>')'</code>,&nbsp;<code>' '</code>&nbsp;组成</li>\n\t<li><code>expression</code>&nbsp;不包含任何前空格或后空格</li>\n\t<li><code>expression</code>&nbsp;中的所有符号都用一个空格隔开</li>\n\t<li><code>0 &lt;= evalvars.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= evalvars[i].length &lt;= 20</code></li>\n\t<li><code>evalvars[i]</code>&nbsp;由小写英文字母组成</li>\n\t<li><code>evalints.length == evalvars.length</code></li>\n\t<li><code>-100 &lt;= evalints[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 771宝石与石头",
        "hardRate": "EASY",
        "passRate": "85.13%",
        "problemsUrl": "https://leetcode.cn/problems/jewels-and-stones/",
        "solutionsUrl": "https://leetcode.cn/problems/jewels-and-stones/solution",
        "problemsDesc": "<p>&nbsp;给你一个字符串 <code>jewels</code>&nbsp;代表石头中宝石的类型，另有一个字符串 <code>stones</code> 代表你拥有的石头。&nbsp;<code>stones</code>&nbsp;中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p>\n\n<p>字母区分大小写，因此 <code>\"a\"</code> 和 <code>\"A\"</code> 是不同类型的石头。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>jewels = \"aA\", stones = \"aAAbbbb\"\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>jewels = \"z\", stones = \"ZZ\"\n<strong>输出：</strong>0<strong>\n</strong></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;jewels.length, stones.length &lt;= 50</code></li>\n\t<li><code>jewels</code> 和 <code>stones</code> 仅由英文字母组成</li>\n\t<li><code>jewels</code> 中的所有字符都是 <strong>唯一的</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 772基本计算器 III",
        "hardRate": "HARD",
        "passRate": "53.05%",
        "problemsUrl": "https://leetcode.cn/problems/basic-calculator-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/basic-calculator-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 773滑动谜题",
        "hardRate": "HARD",
        "passRate": "70.20%",
        "problemsUrl": "https://leetcode.cn/problems/sliding-puzzle/",
        "solutionsUrl": "https://leetcode.cn/problems/sliding-puzzle/solution",
        "problemsDesc": "<p>在一个 <code>2 x 3</code> 的板上（<code>board</code>）有 5 块砖瓦，用数字 <code>1~5</code> 来表示, 以及一块空缺用&nbsp;<code>0</code>&nbsp;来表示。一次 <strong>移动</strong> 定义为选择&nbsp;<code>0</code>&nbsp;与一个相邻的数字（上下左右）进行交换.</p>\n\n<p>最终当板&nbsp;<code>board</code>&nbsp;的结果是&nbsp;<code>[[1,2,3],[4,5,0]]</code>&nbsp;谜板被解开。</p>\n\n<p>给出一个谜板的初始状态&nbsp;<code>board</code>&nbsp;，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/29/slide1-grid.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>board = [[1,2,3],[4,0,5]]\n<strong>输出：</strong>1\n<strong>解释：</strong>交换 0 和 5 ，1 步完成\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/29/slide2-grid.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>board = [[1,2,3],[5,4,0]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>没有办法完成谜板\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/29/slide3-grid.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>board = [[4,1,2],[5,0,3]]\n<strong>输出：</strong>5\n<strong>解释：</strong>\n最少完成谜板的最少移动次数是 5 ，\n一种移动路径:\n尚未移动: [[4,1,2],[5,0,3]]\n移动 1 次: [[4,1,2],[0,5,3]]\n移动 2 次: [[0,1,2],[4,5,3]]\n移动 3 次: [[1,0,2],[4,5,3]]\n移动 4 次: [[1,2,0],[4,5,3]]\n移动 5 次: [[1,2,3],[4,5,0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>board.length == 2</code></li>\n\t<li><code>board[i].length == 3</code></li>\n\t<li><code>0 &lt;= board[i][j] &lt;= 5</code></li>\n\t<li><code>board[i][j]</code>&nbsp;中每个值都 <strong>不同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 774最小化去加油站的最大距离",
        "hardRate": "HARD",
        "passRate": "63.97%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-max-distance-to-gas-station/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-max-distance-to-gas-station/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 775全局倒置与局部倒置",
        "hardRate": "MEDIUM",
        "passRate": "49.43%",
        "problemsUrl": "https://leetcode.cn/problems/global-and-local-inversions/",
        "solutionsUrl": "https://leetcode.cn/problems/global-and-local-inversions/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，表示由范围 <code>[0, n - 1]</code> 内所有整数组成的一个排列。</p>\n\n<p><strong>全局倒置</strong> 的数目等于满足下述条件不同下标对 <code>(i, j)</code> 的数目：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; n</code></li>\n\t<li><code>nums[i] &gt; nums[j]</code></li>\n</ul>\n\n<p><strong>局部倒置</strong> 的数目等于满足下述条件的下标 <code>i</code> 的数目：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; n - 1</code></li>\n\t<li><code>nums[i] &gt; nums[i + 1]</code></li>\n</ul>\n\n<p>当数组 <code>nums</code> 中 <strong>全局倒置</strong> 的数量等于 <strong>局部倒置</strong> 的数量时，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,0,2]\n<strong>输出：</strong>true\n<strong>解释：</strong>有 1 个全局倒置，和 1 个局部倒置。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,0]\n<strong>输出：</strong>false\n<strong>解释：</strong>有 2 个全局倒置，和 1 个局部倒置。\n</pre>\n&nbsp;\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt; n</code></li>\n\t<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>\n\t<li><code>nums</code> 是范围 <code>[0, n - 1]</code> 内所有数字组成的一个排列</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 776拆分二叉搜索树",
        "hardRate": "MEDIUM",
        "passRate": "59.82%",
        "problemsUrl": "https://leetcode.cn/problems/split-bst/",
        "solutionsUrl": "https://leetcode.cn/problems/split-bst/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 777在LR字符串中交换相邻字符",
        "hardRate": "MEDIUM",
        "passRate": "38.38%",
        "problemsUrl": "https://leetcode.cn/problems/swap-adjacent-in-lr-string/",
        "solutionsUrl": "https://leetcode.cn/problems/swap-adjacent-in-lr-string/solution",
        "problemsDesc": "<p>在一个由 <code>&#39;L&#39;</code> , <code>&#39;R&#39;</code> 和 <code>&#39;X&#39;</code> 三个字符组成的字符串（例如<code>&quot;RXXLRXRXL&quot;</code>）中进行移动操作。一次移动操作指用一个<code>&quot;LX&quot;</code>替换一个<code>&quot;XL&quot;</code>，或者用一个<code>&quot;XR&quot;</code>替换一个<code>&quot;RX&quot;</code>。现给定起始字符串<code>start</code>和结束字符串<code>end</code>，请编写代码，当且仅当存在一系列移动操作使得<code>start</code>可以转换成<code>end</code>时， 返回<code>True</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 :</strong></p>\n\n<pre><strong>输入:</strong> start = &quot;RXXLRXRXL&quot;, end = &quot;XRLXXRRLX&quot;\n<strong>输出:</strong> True\n<strong>解释:</strong>\n我们可以通过以下几步将start转换成end:\nRXXLRXRXL -&gt;\nXRXLRXRXL -&gt;\nXRLXRXRXL -&gt;\nXRLXXRRXL -&gt;\nXRLXXRRLX\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= len(start) = len(end) &lt;= 10000</code>。</li>\n\t<li><code>start</code>和<code>end</code>中的字符串仅限于<code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>和<code>&#39;X&#39;</code>。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 778水位上升的泳池中游泳",
        "hardRate": "HARD",
        "passRate": "59.06%",
        "problemsUrl": "https://leetcode.cn/problems/swim-in-rising-water/",
        "solutionsUrl": "https://leetcode.cn/problems/swim-in-rising-water/solution",
        "problemsDesc": "<p>在一个 <code>n x n</code>&nbsp;的整数矩阵&nbsp;<code>grid</code> 中，每一个方格的值 <code>grid[i][j]</code> 表示位置 <code>(i, j)</code> 的平台高度。</p>\n\n<p>当开始下雨时，在时间为&nbsp;<code>t</code>&nbsp;时，水池中的水位为&nbsp;<code>t</code>&nbsp;。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。</p>\n\n<p>你从坐标方格的左上平台&nbsp;<code>(0，0)</code> 出发。返回 <em>你到达坐标方格的右下平台&nbsp;<code>(n-1, n-1)</code>&nbsp;所需的最少时间 。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/29/swim1-grid.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> grid = [[0,2],[1,3]]\n<strong>输出:</strong> 3\n<strong>解释:</strong>\n时间为0时，你位于坐标方格的位置为 <code>(0, 0)。</code>\n此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。\n等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/29/swim2-grid-1.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]\n<strong>输出:</strong> 16\n<strong>解释: </strong>最终的路线用加粗进行了标记。\n我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;&nbsp;n<sup>2</sup></code></li>\n\t<li><code>grid[i][j]</code>&nbsp;中每个值&nbsp;<strong>均无重复</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 779第K个语法符号",
        "hardRate": "MEDIUM",
        "passRate": "49.74%",
        "problemsUrl": "https://leetcode.cn/problems/k-th-symbol-in-grammar/",
        "solutionsUrl": "https://leetcode.cn/problems/k-th-symbol-in-grammar/solution",
        "problemsDesc": "<p>我们构建了一个包含 <code>n</code> 行(&nbsp;<strong>索引从 1&nbsp; 开始&nbsp;</strong>)的表。首先在第一行我们写上一个 <code>0</code>。接下来的每一行，将前一行中的<code>0</code>替换为<code>01</code>，<code>1</code>替换为<code>10</code>。</p>\n\n<ul>\n\t<li>例如，对于 <code>n = 3</code> ，第 <code>1</code> 行是 <code>0</code> ，第 <code>2</code> 行是 <code>01</code> ，第3行是 <code>0110</code> 。</li>\n</ul>\n\n<p>给定行数&nbsp;<code>n</code>&nbsp;和序数 <code>k</code>，返回第 <code>n</code> 行中第 <code>k</code>&nbsp;个字符。（&nbsp;<code>k</code>&nbsp;<strong>从索引 1 开始</strong>）</p>\n\n<p><br />\n<strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 1, k = 1\n<strong>输出:</strong> 0\n<strong>解释: </strong>第一行：<u>0</u>\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 2, k = 1\n<strong>输出:</strong> 0\n<strong>解释:</strong> \n第一行: 0 \n第二行: <u>0</u>1\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 2, k = 2\n<strong>输出:</strong> 1\n<strong>解释:</strong>\n第一行: 0\n第二行: 0<u>1</u>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n\t<li><code>1 &lt;= k &lt;= 2<sup>n - 1</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 780到达终点",
        "hardRate": "HARD",
        "passRate": "37.64%",
        "problemsUrl": "https://leetcode.cn/problems/reaching-points/",
        "solutionsUrl": "https://leetcode.cn/problems/reaching-points/solution",
        "problemsDesc": "<p>给定四个整数&nbsp;<code>sx</code>&nbsp;,&nbsp;<code>sy</code>&nbsp;，<code>tx</code>&nbsp;和&nbsp;<code>ty</code>，如果通过一系列的<strong>转换</strong>可以从起点&nbsp;<code>(sx, sy)</code>&nbsp;到达终点&nbsp;<code>(tx, ty)</code>，则返回 <code>true</code>，否则返回&nbsp;<code>false</code>。</p>\n\n<p>从点&nbsp;<code>(x, y)</code>&nbsp;可以<strong>转换</strong>到&nbsp;<code>(x, x+y)</code>&nbsp; 或者&nbsp;<code>(x+y, y)</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> sx = 1, sy = 1, tx = 3, ty = 5\n<strong>输出:</strong> true\n<strong>解释:\n</strong>可以通过以下一系列<strong>转换</strong>从起点转换到终点：\n(1, 1) -&gt; (1, 2)\n(1, 2) -&gt; (3, 2)\n(3, 2) -&gt; (3, 5)\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> sx = 1, sy = 1, tx = 2, ty = 2 \n<strong>输出:</strong> false\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> sx = 1, sy = 1, tx = 1, ty = 1 \n<strong>输出:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sx, sy, tx, ty &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 781森林中的兔子",
        "hardRate": "MEDIUM",
        "passRate": "58.87%",
        "problemsUrl": "https://leetcode.cn/problems/rabbits-in-forest/",
        "solutionsUrl": "https://leetcode.cn/problems/rabbits-in-forest/solution",
        "problemsDesc": "<p>森林中有未知数量的兔子。提问其中若干只兔子<strong> \"还有多少只兔子与你（指被提问的兔子）颜色相同?\"</strong> ，将答案收集到一个整数数组 <code>answers</code> 中，其中 <code>answers[i]</code> 是第 <code>i</code> 只兔子的回答。</p>\n\n<p>给你数组 <code>answers</code> ，返回森林中兔子的最少数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>answers = [1,1,2]\n<strong>输出：</strong>5\n<strong>解释：</strong>\n两只回答了 \"1\" 的兔子可能有相同的颜色，设为红色。 \n之后回答了 \"2\" 的兔子不会是红色，否则他们的回答会相互矛盾。\n设回答了 \"2\" 的兔子为蓝色。 \n此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。 \n因此森林中兔子的最少数量是 5 只：3 只回答的和 2 只没有回答的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>answers = [10,10,10]\n<strong>输出：</strong>11\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= answers.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= answers[i] &lt; 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 782变为棋盘",
        "hardRate": "HARD",
        "passRate": "59.64%",
        "problemsUrl": "https://leetcode.cn/problems/transform-to-chessboard/",
        "solutionsUrl": "https://leetcode.cn/problems/transform-to-chessboard/solution",
        "problemsDesc": "<p>一个&nbsp;<code>n x n</code>&nbsp;的二维网络&nbsp;<code>board</code>&nbsp;仅由&nbsp;<code>0</code>&nbsp;和&nbsp;<code>1</code>&nbsp;组成&nbsp;。每次移动，你能任意交换两列或是两行的位置。</p>\n\n<p>返回 <em>将这个矩阵变为<strong>&nbsp; “棋盘”&nbsp;&nbsp;</strong>所需的最小移动次数&nbsp;</em>。如果不存在可行的变换，输出 <code>-1</code>。</p>\n\n<p><strong>“棋盘”</strong> 是指任意一格的上下左右四个方向的值均与本身不同的矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/29/chessboard1-grid.jpg\" style=\"height: 145px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入:</strong> board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]\n<strong>输出:</strong> 2\n<strong>解释:</strong>一种可行的变换方式如下，从左到右：\n第一次移动交换了第一列和第二列。\n第二次移动交换了第二行和第三行。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/29/chessboard2-grid.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> board = [[0, 1], [1, 0]]\n<strong>输出:</strong> 0\n<strong>解释: </strong>注意左上角的格值为0时也是合法的棋盘，也是合法的棋盘.\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/29/chessboard3-grid.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> board = [[1, 0], [1, 0]]\n<strong>输出:</strong> -1\n<strong>解释: </strong>任意的变换都不能使这个输入变为合法的棋盘。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 30</code></li>\n\t<li><code>board[i][j]</code>&nbsp;将只包含&nbsp;<code>0</code>或&nbsp;<code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 783二叉搜索树节点最小距离",
        "hardRate": "EASY",
        "passRate": "60.12%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-distance-between-bst-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-distance-between-bst-nodes/solution",
        "problemsDesc": "<p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p>\n\n<p>差值是一个正数，其数值等于两值之差的绝对值。</p>\n\n<p>&nbsp;</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg\" style=\"width: 292px; height: 301px;\" />\n<pre>\n<strong>输入：</strong>root = [4,2,6,1,3]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg\" style=\"width: 282px; height: 301px;\" />\n<pre>\n<strong>输入：</strong>root = [1,0,48,null,null,12,49]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目范围是 <code>[2, 100]</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与 530：<a href=\"https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/\">https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/</a> 相同</p>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 784字母大小写全排列",
        "hardRate": "MEDIUM",
        "passRate": "72.56%",
        "problemsUrl": "https://leetcode.cn/problems/letter-case-permutation/",
        "solutionsUrl": "https://leetcode.cn/problems/letter-case-permutation/solution",
        "problemsDesc": "<p>给定一个字符串&nbsp;<code>s</code>&nbsp;，通过将字符串&nbsp;<code>s</code>&nbsp;中的每个字母转变大小写，我们可以获得一个新的字符串。</p>\n\n<p>返回 <em>所有可能得到的字符串集合</em> 。以 <strong>任意顺序</strong> 返回输出。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a1b2\"\n<strong>输出：</strong>[\"a1b2\", \"a1B2\", \"A1b2\", \"A1B2\"]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"3z4\"\n<strong>输出:</strong> [\"3z4\",\"3Z4\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 12</code></li>\n\t<li><code>s</code>&nbsp;由小写英文字母、大写英文字母和数字组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 785判断二分图",
        "hardRate": "MEDIUM",
        "passRate": "54.65%",
        "problemsUrl": "https://leetcode.cn/problems/is-graph-bipartite/",
        "solutionsUrl": "https://leetcode.cn/problems/is-graph-bipartite/solution",
        "problemsDesc": "存在一个 <strong>无向图</strong> ，图中有 <code>n</code> 个节点。其中每个节点都有一个介于 <code>0</code> 到 <code>n - 1</code> 之间的唯一编号。给你一个二维数组 <code>graph</code> ，其中 <code>graph[u]</code> 是一个节点数组，由节点 <code>u</code> 的邻接节点组成。形式上，对于 <code>graph[u]</code> 中的每个 <code>v</code> ，都存在一条位于节点 <code>u</code> 和节点 <code>v</code> 之间的无向边。该无向图同时具有以下属性：\n<ul>\n\t<li>不存在自环（<code>graph[u]</code> 不包含 <code>u</code>）。</li>\n\t<li>不存在平行边（<code>graph[u]</code> 不包含重复值）。</li>\n\t<li>如果 <code>v</code> 在 <code>graph[u]</code> 内，那么 <code>u</code> 也应该在 <code>graph[v]</code> 内（该图是无向图）</li>\n\t<li>这个图可能不是连通图，也就是说两个节点 <code>u</code> 和 <code>v</code> 之间可能不存在一条连通彼此的路径。</li>\n</ul>\n\n<p><strong>二分图</strong> 定义：如果能将一个图的节点集合分割成两个独立的子集 <code>A</code> 和 <code>B</code> ，并使图中的每一条边的两个节点一个来自 <code>A</code> 集合，一个来自 <code>B</code> 集合，就将这个图称为 <strong>二分图</strong> 。</p>\n\n<p>如果图是二分图，返回 <code>true</code><em> </em>；否则，返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg\" style=\"width: 222px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\n<strong>输出：</strong>false\n<strong>解释：</strong><code>不能将节点分割成两个独立的子集，</code>以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg\" style=\"width: 222px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>graph = [[1,3],[0,2],[1,3],[0,2]]\n<strong>输出：</strong>true\n<strong>解释：</strong><code>可以将节点分成两组: {0, 2} 和 {1, 3} 。</code></pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>graph.length == n</code></li>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>0 <= graph[u].length < n</code></li>\n\t<li><code>0 <= graph[u][i] <= n - 1</code></li>\n\t<li><code>graph[u]</code> 不会包含 <code>u</code></li>\n\t<li><code>graph[u]</code> 的所有值 <strong>互不相同</strong></li>\n\t<li>如果 <code>graph[u]</code> 包含 <code>v</code>，那么 <code>graph[v]</code> 也会包含 <code>u</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 786第 K 个最小的素数分数",
        "hardRate": "MEDIUM",
        "passRate": "67.62%",
        "problemsUrl": "https://leetcode.cn/problems/k-th-smallest-prime-fraction/",
        "solutionsUrl": "https://leetcode.cn/problems/k-th-smallest-prime-fraction/solution",
        "problemsDesc": "<p>给你一个按递增顺序排序的数组 <code>arr</code> 和一个整数 <code>k</code> 。数组 <code>arr</code> 由 <code>1</code> 和若干 <strong>素数</strong>&nbsp; 组成，且其中所有整数互不相同。</p>\n\n<p>对于每对满足 <code>0 &lt;= i &lt; j &lt; arr.length</code> 的 <code>i</code> 和 <code>j</code> ，可以得到分数 <code>arr[i] / arr[j]</code> 。</p>\n\n<p>那么第&nbsp;<code>k</code>&nbsp;个最小的分数是多少呢?&nbsp; 以长度为 <code>2</code> 的整数数组返回你的答案, 这里&nbsp;<code>answer[0] == arr[i]</code>&nbsp;且&nbsp;<code>answer[1] == arr[j]</code> 。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,5], k = 3\n<strong>输出：</strong>[2,5]\n<strong>解释：</strong>已构造好的分数,排序后如下所示: \n1/5, 1/3, 2/5, 1/2, 3/5, 2/3\n很明显第三个最小的分数是 2/5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,7], k = 1\n<strong>输出：</strong>[1,7]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>arr[0] == 1</code></li>\n\t<li><code>arr[i]</code> 是一个 <strong>素数</strong> ，<code>i &gt; 0</code></li>\n\t<li><code>arr</code> 中的所有数字 <strong>互不相同</strong> ，且按 <strong>严格递增</strong> 排序</li>\n\t<li><code>1 &lt;= k &lt;= arr.length * (arr.length - 1) / 2</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以设计并实现时间复杂度小于 <code>O(n<sup>2</sup>)</code> 的算法解决此问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 787K 站中转内最便宜的航班",
        "hardRate": "MEDIUM",
        "passRate": "39.67%",
        "problemsUrl": "https://leetcode.cn/problems/cheapest-flights-within-k-stops/",
        "solutionsUrl": "https://leetcode.cn/problems/cheapest-flights-within-k-stops/solution",
        "problemsDesc": "<p>有 <code>n</code> 个城市通过一些航班连接。给你一个数组&nbsp;<code>flights</code> ，其中&nbsp;<code>flights[i] = [from<sub>i</sub>, to<sub>i</sub>, price<sub>i</sub>]</code> ，表示该航班都从城市 <code>from<sub>i</sub></code> 开始，以价格 <code>price<sub>i</sub></code> 抵达 <code>to<sub>i</sub></code>。</p>\n\n<p>现在给定所有的城市和航班，以及出发城市 <code>src</code> 和目的地 <code>dst</code>，你的任务是找到出一条最多经过 <code>k</code>&nbsp;站中转的路线，使得从 <code>src</code> 到 <code>dst</code> 的 <strong>价格最便宜</strong> ，并返回该价格。 如果不存在这样的路线，则输出 <code>-1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> \nn = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]\nsrc = 0, dst = 2, k = 1\n<strong>输出:</strong> 200\n<strong>解释:</strong> \n城市航班图如下\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png\" style=\"height: 180px; width: 246px;\" />\n\n从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> \nn = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]\nsrc = 0, dst = 2, k = 0\n<strong>输出:</strong> 500\n<strong>解释:</strong> \n城市航班图如下\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png\" style=\"height: 180px; width: 246px;\" />\n\n从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= flights.length &lt;= (n * (n - 1) / 2)</code></li>\n\t<li><code>flights[i].length == 3</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt; n</code></li>\n\t<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>\n\t<li><code>1 &lt;= price<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li>航班没有重复，且不存在自环</li>\n\t<li><code>0 &lt;= src, dst, k &lt; n</code></li>\n\t<li><code>src != dst</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 788旋转数字",
        "hardRate": "MEDIUM",
        "passRate": "66.24%",
        "problemsUrl": "https://leetcode.cn/problems/rotated-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/rotated-digits/solution",
        "problemsDesc": "<p>我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。</p>\n\n<p>如果一个数的每位数字被旋转以后仍然还是一个数字，&nbsp;则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，2 和 5 互为镜像）；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。</p>\n\n<p>现在我们有一个正整数&nbsp;<code>N</code>, 计算从&nbsp;<code>1</code> 到&nbsp;<code>N</code> 中有多少个数&nbsp;X 是好数？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入:</strong> 10\n<strong>输出:</strong> 4\n<strong>解释:</strong> \n在[1, 10]中有四个好数： 2, 5, 6, 9。\n注意 1 和 10 不是好数, 因为他们在旋转之后不变。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>N&nbsp;的取值范围是&nbsp;<code>[1, 10000]</code>。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 789逃脱阻碍者",
        "hardRate": "MEDIUM",
        "passRate": "68.48%",
        "problemsUrl": "https://leetcode.cn/problems/escape-the-ghosts/",
        "solutionsUrl": "https://leetcode.cn/problems/escape-the-ghosts/solution",
        "problemsDesc": "<p>你在进行一个简化版的吃豆人游戏。你从 <code>[0, 0]</code> 点开始出发，你的目的地是&nbsp;<code>target = [x<sub>target</sub>, y<sub>target</sub>]</code> 。地图上有一些阻碍者，以数组 <code>ghosts</code> 给出，第 <code>i</code> 个阻碍者从&nbsp;<code>ghosts[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;出发。所有输入均为 <strong>整数坐标</strong> 。</p>\n\n<p>每一回合，你和阻碍者们可以同时向东，西，南，北四个方向移动，每次可以移动到距离原位置 <strong>1 个单位</strong> 的新位置。当然，也可以选择 <strong>不动</strong> 。所有动作 <strong>同时</strong> 发生。</p>\n\n<p>如果你可以在任何阻碍者抓住你 <strong>之前</strong> 到达目的地（阻碍者可以采取任意行动方式），则被视为逃脱成功。如果你和阻碍者 <strong>同时</strong> 到达了一个位置（包括目的地）&nbsp;<strong>都不算</strong>&nbsp;是逃脱成功。</p>\n\n<p>如果不管阻碍者怎么移动都可以成功逃脱时，输出 <code>true</code> ；否则，输出 <code>false</code> 。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>ghosts = [[1,0],[0,3]], target = [0,1]\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以直接一步到达目的地 (0,1) ，在 (1, 0) 或者 (0, 3) 位置的阻碍者都不可能抓住你。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>ghosts = [[1,0]], target = [2,0]\n<strong>输出：</strong>false\n<strong>解释：</strong>你需要走到位于 (2, 0) 的目的地，但是在 (1, 0) 的阻碍者位于你和目的地之间。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>ghosts = [[2,0]], target = [1,0]\n<strong>输出：</strong>false\n<strong>解释：</strong>阻碍者可以和你同时达到目的地。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= ghosts.length &lt;= 100</code></li>\n\t<li><code>ghosts[i].length == 2</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li>同一位置可能有 <strong>多个阻碍者</strong> 。</li>\n\t<li><code>target.length == 2</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sub>target</sub>, y<sub>target</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 790多米诺和托米诺平铺",
        "hardRate": "MEDIUM",
        "passRate": "55.73%",
        "problemsUrl": "https://leetcode.cn/problems/domino-and-tromino-tiling/",
        "solutionsUrl": "https://leetcode.cn/problems/domino-and-tromino-tiling/solution",
        "problemsDesc": "<p>有两种形状的瓷砖：一种是&nbsp;<code>2 x 1</code> 的多米诺形，另一种是形如&nbsp;\"L\" 的托米诺形。两种形状都可以旋转。</p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/15/lc-domino.jpg\" style=\"height: 195px; width: 362px;\" /></p>\n\n<p>给定整数 n ，返回可以平铺&nbsp;<code>2 x n</code> 的面板的方法的数量。<strong>返回对</strong>&nbsp;<code>10<sup>9</sup>&nbsp;+ 7</code>&nbsp;<strong>取模&nbsp;</strong>的值。</p>\n\n<p>平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/15/lc-domino1.jpg\" style=\"height: 226px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入:</strong> n = 3\n<strong>输出:</strong> 5\n<strong>解释:</strong> 五种不同的方法如上所示。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 1\n<strong>输出:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 791自定义字符串排序",
        "hardRate": "MEDIUM",
        "passRate": "74.18%",
        "problemsUrl": "https://leetcode.cn/problems/custom-sort-string/",
        "solutionsUrl": "https://leetcode.cn/problems/custom-sort-string/solution",
        "problemsDesc": "<p>给定两个字符串 <code>order</code> 和 <code>s</code> 。<code>order</code> 的所有字母都是 <strong>唯一</strong> 的，并且以前按照一些自定义的顺序排序。</p>\n\n<p>对 <code>s</code> 的字符进行置换，使其与排序的&nbsp;<code>order</code>&nbsp;相匹配。更具体地说，如果在&nbsp;<code>order</code>&nbsp;中的字符 <code>x</code> 出现字符 <code>y</code> 之前，那么在排列后的字符串中， <code>x</code>&nbsp;也应该出现在 <code>y</code> 之前。</p>\n\n<p>返回 <em>满足这个性质的 <code>s</code> 的任意一种排列&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> order = \"cba\", s = \"abcd\"\n<strong>输出:</strong> \"cbad\"\n<strong>解释:</strong> \n“a”、“b”、“c”是按顺序出现的，所以“a”、“b”、“c”的顺序应该是“c”、“b”、“a”。\n因为“d”不是按顺序出现的，所以它可以在返回的字符串中的任何位置。“dcba”、“cdba”、“cbda”也是有效的输出。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> order = \"cbafg\", s = \"abcd\"\n<strong>输出:</strong> \"cbad\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= order.length &lt;= 26</code></li>\n\t<li><code>1 &lt;= s.length &lt;= 200</code></li>\n\t<li><code>order</code>&nbsp;和&nbsp;<code>s</code>&nbsp;由小写英文字母组成</li>\n\t<li><code>order</code>&nbsp;中的所有字符都 <strong>不同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 792匹配子序列的单词数",
        "hardRate": "MEDIUM",
        "passRate": "51.00%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-matching-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-matching-subsequences/solution",
        "problemsDesc": "<p>给定字符串 <code>s</code>&nbsp;和字符串数组&nbsp;<code>words</code>, 返回&nbsp;&nbsp;<em><code>words[i]</code>&nbsp;中是<code>s</code>的子序列的单词个数</em>&nbsp;。</p>\n\n<p>字符串的 <strong>子序列</strong> 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。</p>\n\n<ul>\n\t<li>例如， <code>“ace”</code> 是 <code>“abcde”</code> 的子序列。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"abcde\", words = [\"a\",\"bb\",\"acd\",\"ace\"]\n<strong>输出:</strong> 3\n<strong>解释:</strong> 有三个是&nbsp;s 的子序列的单词: \"a\", \"acd\", \"ace\"。\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"dsahjpjauf\", words = [\"ahjpjau\",\"ja\",\"ahbwzgqnuk\",\"tnmlanowax\"]\n<strong>输出:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words.length &lt;= 5000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 50</code></li>\n\t<li><code>words[i]</code>和 <font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size: 12.6px; background-color: rgb(249, 242, 244);\">s</span></font>&nbsp;都只由小写字母组成。</li>\n</ul>\n<span style=\"display:block\"><span style=\"height:0px\"><span style=\"position:absolute\">​​​​</span></span></span>",
        "isPlus": false
    },
    {
        "problemsName": " 793阶乘函数后 K 个零",
        "hardRate": "HARD",
        "passRate": "48.67%",
        "problemsUrl": "https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/",
        "solutionsUrl": "https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/solution",
        "problemsDesc": "<p>&nbsp;<code>f(x)</code>&nbsp;是&nbsp;<code>x!</code>&nbsp;末尾是 0 的数量。回想一下&nbsp;<code>x! = 1 * 2 * 3 * ... * x</code>，且 <code>0! = 1</code>&nbsp;。</p>\n\n<ul>\n\t<li>例如，&nbsp;<code>f(3) = 0</code>&nbsp;，因为 <code>3! = 6</code> 的末尾没有 0 ；而 <code>f(11) = 2</code>&nbsp;，因为 <code>11!= 39916800</code> 末端有 2 个 0 。</li>\n</ul>\n\n<p>给定&nbsp;<code>k</code>，找出返回能满足 <code>f(x) = k</code>&nbsp;的非负整数 <code>x</code>&nbsp;的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong><strong> </strong></p>\n\n<pre>\n<strong>输入：</strong>k = 0<strong>\n输出：</strong>5<strong>\n解释：</strong>0!, 1!, 2!, 3!, 和 4!&nbsp;均符合 k = 0 的条件。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 5\n<strong>输出：</strong>0\n<strong>解释：</strong>没有匹配到这样的 x!，符合 k = 5 的条件。</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> k = 3\n<strong>输出:</strong> 5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 794有效的井字游戏",
        "hardRate": "MEDIUM",
        "passRate": "38.61%",
        "problemsUrl": "https://leetcode.cn/problems/valid-tic-tac-toe-state/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-tic-tac-toe-state/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>board</code> 表示井字游戏的棋盘。当且仅当在井字游戏过程中，棋盘有可能达到 <code>board</code> 所显示的状态时，才返回 <code>true</code> 。</p>\n\n<p>井字游戏的棋盘是一个 <code>3 x 3</code> 数组，由字符 <code>' '</code>，<code>'X'</code> 和 <code>'O'</code> 组成。字符 <code>' '</code> 代表一个空位。</p>\n\n<p>以下是井字游戏的规则：</p>\n\n<ul>\n\t<li>玩家轮流将字符放入空位（<code>' '</code>）中。</li>\n\t<li>玩家 1 总是放字符 <code>'X'</code> ，而玩家 2 总是放字符 <code>'O'</code> 。</li>\n\t<li><code>'X'</code> 和 <code>'O'</code> 只允许放置在空位中，不允许对已放有字符的位置进行填充。</li>\n\t<li>当有 3 个相同（且非空）的字符填充任何行、列或对角线时，游戏结束。</li>\n\t<li>当所有位置非空时，也算为游戏结束。</li>\n\t<li>如果游戏结束，玩家不允许再放置字符。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/15/tictactoe1-grid.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>输入：</strong>board = [\"O  \",\"   \",\"   \"]\n<strong>输出：</strong>false\n<strong>解释：</strong>玩家 1 总是放字符 \"X\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/15/tictactoe2-grid.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>输入：</strong>board = [\"XOX\",\" X \",\"   \"]\n<strong>输出：</strong>false\n<strong>解释：</strong>玩家应该轮流放字符。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/15/tictactoe4-grid.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>输入：</strong>board = [\"XOX\",\"O O\",\"XOX\"]\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>board.length == 3</code></li>\n\t<li><code>board[i].length == 3</code></li>\n\t<li><code>board[i][j]</code> 为 <code>'X'</code>、<code>'O'</code> 或 <code>' '</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 795区间子数组个数",
        "hardRate": "MEDIUM",
        "passRate": "57.77%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和两个整数：<code>left</code> 及 <code>right</code> 。找出 <code>nums</code> 中连续、非空且其中最大元素在范围&nbsp;<code>[left, right]</code> 内的子数组，并返回满足条件的子数组的个数。</p>\n\n<p>生成的测试用例保证结果符合 <strong>32-bit</strong> 整数范围。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,4,3], left = 2, right = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>满足条件的三个子数组：[2], [2, 1], [3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,9,2,5,6], left = 2, right = 8\n<strong>输出：</strong>7\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= left &lt;= right &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 796旋转字符串",
        "hardRate": "EASY",
        "passRate": "63.29%",
        "problemsUrl": "https://leetcode.cn/problems/rotate-string/",
        "solutionsUrl": "https://leetcode.cn/problems/rotate-string/solution",
        "problemsDesc": "<p>给定两个字符串, <code>s</code>&nbsp;和&nbsp;<code>goal</code>。如果在若干次旋转操作之后，<code>s</code>&nbsp;能变成&nbsp;<code>goal</code>&nbsp;，那么返回&nbsp;<code>true</code>&nbsp;。</p>\n\n<p><code>s</code>&nbsp;的 <strong>旋转操作</strong> 就是将&nbsp;<code>s</code> 最左边的字符移动到最右边。&nbsp;</p>\n\n<ul>\n\t<li>例如, 若&nbsp;<code>s = 'abcde'</code>，在旋转一次之后结果就是<code>'bcdea'</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"abcde\", goal = \"cdeab\"\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"abcde\", goal = \"abced\"\n<strong>输出:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, goal.length &lt;= 100</code></li>\n\t<li><code>s</code>&nbsp;和&nbsp;<code>goal</code>&nbsp;由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 797所有可能的路径",
        "hardRate": "MEDIUM",
        "passRate": "78.86%",
        "problemsUrl": "https://leetcode.cn/problems/all-paths-from-source-to-target/",
        "solutionsUrl": "https://leetcode.cn/problems/all-paths-from-source-to-target/solution",
        "problemsDesc": "<p>给你一个有&nbsp;<code>n</code>&nbsp;个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code>&nbsp;到节点 <code>n-1</code>&nbsp;的路径并输出（<strong>不要求按特定顺序</strong>）</p>\n\n<p><meta charset=\"UTF-8\" />&nbsp;<code>graph[i]</code>&nbsp;是一个从节点 <code>i</code> 可以访问的所有节点的列表（即从节点 <code>i</code> 到节点&nbsp;<code>graph[i][j]</code>存在一条有向边）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,2],[3],[3],[]]\n<strong>输出：</strong>[[0,1,3],[0,2,3]]\n<strong>解释：</strong>有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>graph = [[4,3,1],[3,2,4],[3],[4],[]]\n<strong>输出：</strong>[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == graph.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 15</code></li>\n\t<li><code>0 &lt;= graph[i][j] &lt; n</code></li>\n\t<li><code>graph[i][j] != i</code>（即不存在自环）</li>\n\t<li><code>graph[i]</code> 中的所有元素 <strong>互不相同</strong></li>\n\t<li>保证输入为 <strong>有向无环图（DAG）</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 798得分最高的最小轮调",
        "hardRate": "HARD",
        "passRate": "61.59%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-rotation-with-highest-score/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-rotation-with-highest-score/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>nums</code>，我们可以将它按一个非负整数 <code>k</code> 进行轮调，这样可以使数组变为&nbsp;<code>[nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]</code>&nbsp;的形式。此后，任何值小于或等于其索引的项都可以记作一分。</p>\n\n<ul>\n\t<li>例如，数组为&nbsp;<code>nums = [2,4,1,3,0]</code>，我们按&nbsp;<code>k = 2</code>&nbsp;进行轮调后，它将变成&nbsp;<code>[1,3,0,2,4]</code>。这将记为 <code>3</code> 分，因为 <code>1 &gt; 0</code> [不计分]、<code>3 &gt; 1</code> [不计分]、<code>0 &lt;= 2</code> [计 1 分]、<code>2 &lt;= 3</code> [计 1 分]，<code>4 &lt;= 4</code> [计 1 分]。</li>\n</ul>\n\n<p>在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调下标 <code>k</code> 。如果有多个答案，返回满足条件的最小的下标 <code>k</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,1,4,0]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n下面列出了每个 k 的得分：\nk = 0,  nums = [2,3,1,4,0],    score 2\nk = 1,  nums = [3,1,4,0,2],    score 3\nk = 2,  nums = [1,4,0,2,3],    score 3\nk = 3,  nums = [4,0,2,3,1],    score 4\nk = 4,  nums = [0,2,3,1,4],    score 3\n所以我们应当选择&nbsp;k = 3，得分最高。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,0,2,4]\n<strong>输出：</strong>0\n<strong>解释：</strong>\nnums 无论怎么变化总是有 3 分。\n所以我们将选择最小的 k，即 0。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt; nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 799香槟塔",
        "hardRate": "MEDIUM",
        "passRate": "53.03%",
        "problemsUrl": "https://leetcode.cn/problems/champagne-tower/",
        "solutionsUrl": "https://leetcode.cn/problems/champagne-tower/solution",
        "problemsDesc": "<p>我们把玻璃杯摆成金字塔的形状，其中&nbsp;<strong>第一层</strong>&nbsp;有 <code>1</code> 个玻璃杯， <strong>第二层</strong>&nbsp;有 <code>2</code> 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。</p>\n\n<p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p>\n\n<p>例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。</p>\n\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/09/tower.png\" style=\"height: 241px; width: 350px;\" /></p>\n\n<p>现在当倾倒了非负整数杯香槟后，返回第 <code>i</code> 行 <code>j</code>&nbsp;个玻璃杯所盛放的香槟占玻璃杯容积的比例（ <code>i</code> 和 <code>j</code>&nbsp;都从0开始）。</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<strong>示例 1:</strong>\n<strong>输入:</strong> poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1\n<strong>输出:</strong> 0.00000\n<strong>解释:</strong> 我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。\n\n<strong>示例 2:</strong>\n<strong>输入:</strong> poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1\n<strong>输出:</strong> 0.50000\n<strong>解释:</strong> 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。\n</pre>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> poured = 100000009, query_row = 33, query_glass = 17\n<strong>输出:</strong> 1.00000\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;=&nbsp;poured &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= query_glass &lt;= query_row&nbsp;&lt; 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 800相似 RGB 颜色",
        "hardRate": "EASY",
        "passRate": "70.24%",
        "problemsUrl": "https://leetcode.cn/problems/similar-rgb-color/",
        "solutionsUrl": "https://leetcode.cn/problems/similar-rgb-color/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 801使序列递增的最小交换次数",
        "hardRate": "HARD",
        "passRate": "50.61%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/solution",
        "problemsDesc": "<p>我们有两个长度相等且不为空的整型数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>&nbsp;。在一次操作中，我们可以交换&nbsp;<code>nums1[i]</code>&nbsp;和&nbsp;<code>nums2[i]</code>的元素。</p>\n\n<ul>\n\t<li>例如，如果 <code>nums1 = [1,2,3,<u>8</u>]</code> ， <code>nums2 =[5,6,7,<u>4</u>]</code> ，你可以交换 <code>i = 3</code> 处的元素，得到 <code>nums1 =[1,2,3,4]</code> 和 <code>nums2 =[5,6,7,8]</code> 。</li>\n</ul>\n\n<p>返回 <em>使 <code>nums1</code> 和 <code>nums2</code> <strong>严格递增&nbsp;</strong>所需操作的最小次数</em> 。</p>\n\n<p>数组&nbsp;<code>arr</code>&nbsp;<strong>严格递增</strong> 且&nbsp;&nbsp;<code>arr[0] &lt; arr[1] &lt; arr[2] &lt; ... &lt; arr[arr.length - 1]</code>&nbsp;。</p>\n\n<p><b>注意：</b></p>\n\n<ul>\n\t<li>用例保证可以实现操作。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums1 = [1,3,5,4], nums2 = [1,2,3,7]\n<strong>输出:</strong> 1\n<strong>解释: </strong>\n交换 A[3] 和 B[3] 后，两个数组如下:\nA = [1, 3, 5, 7] ， B = [1, 2, 3, 4]\n两个数组均为严格递增的。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums1 = [0,3,5,8,9], nums2 = [2,1,4,6,9]\n<strong>输出:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums1.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums2.length == nums1.length</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 2 * 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 802找到最终的安全状态",
        "hardRate": "MEDIUM",
        "passRate": "59.22%",
        "problemsUrl": "https://leetcode.cn/problems/find-eventual-safe-states/",
        "solutionsUrl": "https://leetcode.cn/problems/find-eventual-safe-states/solution",
        "problemsDesc": "<p>有一个有 <code>n</code> 个节点的有向图，节点按 <code>0</code> 到 <code>n - 1</code> 编号。图由一个 <strong>索引从 0 开始</strong> 的 2D 整数数组&nbsp;<code>graph</code>表示，&nbsp;<code>graph[i]</code>是与节点 <code>i</code> 相邻的节点的整数数组，这意味着从节点 <code>i</code> 到&nbsp;<code>graph[i]</code>中的每个节点都有一条边。</p>\n\n<p>如果一个节点没有连出的有向边，则该节点是 <strong>终端节点</strong> 。如果从该节点开始的所有可能路径都通向 <strong>终端节点</strong> ，则该节点为 <strong>安全节点</strong> 。</p>\n\n<p>返回一个由图中所有 <strong>安全节点</strong> 组成的数组作为答案。答案数组中的元素应当按 <strong>升序</strong> 排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"Illustration of graph\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png\" /></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,2],[2,3],[5],[0],[5],[],[]]\n<strong>输出：</strong>[2,4,5,6]\n<strong>解释：</strong>示意图如上。\n节点 5 和节点 6 是终端节点，因为它们都没有出边。\n从节点 2、4、5 和 6 开始的所有路径都指向节点 5 或 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\n<strong>输出：</strong>[4]\n<strong>解释:</strong>\n只有节点 4 是终端节点，从节点 4 开始的所有路径都通向节点 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == graph.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= graph[i].length &lt;= n</code></li>\n\t<li><code>0 &lt;= graph[i][j] &lt;= n - 1</code></li>\n\t<li><code>graph[i]</code> 按严格递增顺序排列。</li>\n\t<li>图中可能包含自环。</li>\n\t<li>图中边的数目在范围 <code>[1, 4 * 10<sup>4</sup>]</code> 内。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 803打砖块",
        "hardRate": "HARD",
        "passRate": "47.05%",
        "problemsUrl": "https://leetcode.cn/problems/bricks-falling-when-hit/",
        "solutionsUrl": "https://leetcode.cn/problems/bricks-falling-when-hit/solution",
        "problemsDesc": "<p>有一个 <code>m x n</code> 的二元网格<meta charset=\"UTF-8\" />&nbsp;<code>grid</code>&nbsp;，其中 <code>1</code> 表示砖块，<code>0</code> 表示空白。砖块 <strong>稳定</strong>（不会掉落）的前提是：</p>\n\n<ul>\n\t<li>一块砖直接连接到网格的顶部，或者</li>\n\t<li>至少有一块相邻（4&nbsp;个方向之一）砖块<strong> 稳定 </strong>不会掉落时</li>\n</ul>\n\n<p>给你一个数组 <code>hits</code> ，这是需要依次消除砖块的位置。每当消除&nbsp;<code>hits[i] = (rowi, coli)</code> 位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而 <strong>掉落</strong> 。一旦砖块掉落，它会 <strong>立即</strong> 从网格&nbsp;<code>grid</code>&nbsp;中消失（即，它不会落在其他稳定的砖块上）。</p>\n\n<p>返回一个数组 <code>result</code> ，其中 <code>result[i]</code> 表示第 <code>i</code> 次消除操作对应掉落的砖块数目。</p>\n\n<p><strong>注意</strong>，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]\n<strong>输出：</strong>[2]\n<strong>解释：</strong>网格开始为：\n[[1,0,0,0]，\n [<strong>1</strong>,1,1,0]]\n消除 (1,0) 处加粗的砖块，得到网格：\n[[1,0,0,0]\n [0,<strong>1</strong>,<strong>1</strong>,0]]\n两个加粗的砖不再稳定，因为它们不再与顶部相连，也不再与另一个稳定的砖相邻，因此它们将掉落。得到网格：\n[[1,0,0,0],\n [0,0,0,0]]\n因此，结果为 [2] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]\n<strong>输出：</strong>[0,0]\n<strong>解释：</strong>网格开始为：\n[[1,0,0,0],\n [1,<strong>1</strong>,0,0]]\n消除 (1,1) 处加粗的砖块，得到网格：\n[[1,0,0,0],\n [1,0,0,0]]\n剩下的砖都很稳定，所以不会掉落。网格保持不变：\n[[1,0,0,0], \n [<strong>1</strong>,0,0,0]]\n接下来消除 (1,0) 处加粗的砖块，得到网格：\n[[1,0,0,0],\n [0,0,0,0]]\n剩下的砖块仍然是稳定的，所以不会有砖块掉落。\n因此，结果为 [0,0] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n\t<li><code>1 &lt;= hits.length &lt;= 4 * 10<sup>4</sup></code></li>\n\t<li><code>hits[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i&nbsp;</sub>&lt;= m - 1</code></li>\n\t<li><code>0 &lt;=&nbsp;y<sub>i</sub> &lt;= n - 1</code></li>\n\t<li>所有 <code>(x<sub>i</sub>, y<sub>i</sub>)</code> 互不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 804唯一摩尔斯密码词",
        "hardRate": "EASY",
        "passRate": "82.20%",
        "problemsUrl": "https://leetcode.cn/problems/unique-morse-code-words/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-morse-code-words/solution",
        "problemsDesc": "<p>国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串，&nbsp;比如:</p>\n\n<ul>\n\t<li><code>'a'</code> 对应 <code>\".-\"</code> ，</li>\n\t<li><code>'b'</code> 对应 <code>\"-...\"</code> ，</li>\n\t<li><code>'c'</code> 对应 <code>\"-.-.\"</code> ，以此类推。</li>\n</ul>\n\n<p>为了方便，所有 <code>26</code> 个英文字母的摩尔斯密码表如下：</p>\n\n<pre>\n[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]</pre>\n\n<p>给你一个字符串数组 <code>words</code> ，每个单词可以写成每个字母对应摩尔斯密码的组合。</p>\n\n<ul>\n\t<li>例如，<code>\"cab\"</code> 可以写成 <code>\"-.-..--...\"</code> ，(即 <code>\"-.-.\"</code> + <code>\".-\"</code> + <code>\"-...\"</code> 字符串的结合)。我们将这样一个连接过程称作 <strong>单词翻译</strong> 。</li>\n</ul>\n\n<p>对<strong> </strong><code>words</code> 中所有单词进行单词翻译，返回不同 <strong>单词翻译</strong> 的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> words = [\"gin\", \"zen\", \"gig\", \"msg\"]\n<strong>输出:</strong> 2\n<strong>解释: </strong>\n各单词翻译如下:\n\"gin\" -&gt; \"--...-.\"\n\"zen\" -&gt; \"--...-.\"\n\"gig\" -&gt; \"--...--.\"\n\"msg\" -&gt; \"--...--.\"\n\n共有 2 种不同翻译, \"--...-.\" 和 \"--...--.\".\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"a\"]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 12</code></li>\n\t<li><code>words[i]</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 805数组的均值分割",
        "hardRate": "HARD",
        "passRate": "42.96%",
        "problemsUrl": "https://leetcode.cn/problems/split-array-with-same-average/",
        "solutionsUrl": "https://leetcode.cn/problems/split-array-with-same-average/solution",
        "problemsDesc": "<p>给定你一个整数数组<meta charset=\"UTF-8\" />&nbsp;<code>nums</code></p>\n\n<p>我们要将<meta charset=\"UTF-8\" />&nbsp;<code>nums</code>&nbsp;数组中的每个元素移动到&nbsp;<code>A</code>&nbsp;数组 或者&nbsp;<code>B</code>&nbsp;数组中，使得&nbsp;<code>A</code>&nbsp;数组和<meta charset=\"UTF-8\" />&nbsp;<code>B</code>&nbsp;数组不为空，并且<meta charset=\"UTF-8\" />&nbsp;<code>average(A) == average(B)</code>&nbsp;。</p>\n\n<p>如果可以完成则返回<code>true</code>&nbsp;， 否则返回 <code>false</code>&nbsp;&nbsp;。</p>\n\n<p><strong>注意：</strong>对于数组<meta charset=\"UTF-8\" />&nbsp;<code>arr</code>&nbsp;, <meta charset=\"UTF-8\" />&nbsp;<code>average(arr)</code>&nbsp;是<meta charset=\"UTF-8\" />&nbsp;<code>arr</code>&nbsp;的所有元素的和除以<meta charset=\"UTF-8\" />&nbsp;<code>arr</code>&nbsp;长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,3,4,5,6,7,8]\n<strong>输出:</strong> true\n<strong>解释: </strong>我们可以将数组分割为 [1,4,5,8] 和 [2,3,6,7], 他们的平均值都是4.5。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [3,1]\n<strong>输出:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 30</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 806写字符串需要的行数",
        "hardRate": "EASY",
        "passRate": "68.42%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-lines-to-write-string/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-lines-to-write-string/solution",
        "problemsDesc": "<p>我们要把给定的字符串 <code>S</code>&nbsp;从左到右写到每一行上，每一行的最大宽度为100个单位，如果我们在写某个字母的时候会使这行超过了100 个单位，那么我们应该把这个字母写到下一行。我们给定了一个数组&nbsp;<code>widths</code>&nbsp;，这个数组&nbsp;widths[0] 代表 &#39;a&#39; 需要的单位，&nbsp;widths[1] 代表 &#39;b&#39; 需要的单位，...，&nbsp;widths[25] 代表 &#39;z&#39; 需要的单位。</p>\n\n<p>现在回答两个问题：至少多少行能放下<code>S</code>，以及最后一行使用的宽度是多少个单位？将你的答案作为长度为2的整数列表返回。</p>\n\n<pre>\n<strong>示例 1:</strong>\n<strong>输入:</strong> \nwidths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]\nS = &quot;abcdefghijklmnopqrstuvwxyz&quot;\n<strong>输出:</strong> [3, 60]\n<strong>解释: \n</strong>所有的字符拥有相同的占用单位10。所以书写所有的26个字母，\n我们需要2个整行和占用60个单位的一行。\n</pre>\n\n<pre>\n<strong>示例 2:</strong>\n<strong>输入:</strong> \nwidths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]\nS = &quot;bbbcccdddaaa&quot;\n<strong>输出:</strong> [2, 4]\n<strong>解释: \n</strong>除去字母&#39;a&#39;所有的字符都是相同的单位10，并且字符串 &quot;bbbcccdddaa&quot; 将会覆盖 9 * 10 + 2 * 4 = 98 个单位.\n最后一个字母 &#39;a&#39; 将会被写到第二行，因为第一行只剩下2个单位了。\n所以，这个答案是2行，第二行有4个单位宽度。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>注:</strong></p>\n\n<ul>\n\t<li>字符串&nbsp;<code>S</code> 的长度在&nbsp;[1, 1000] 的范围。</li>\n\t<li><code>S</code> 只包含小写字母。</li>\n\t<li><code>widths</code> 是长度为&nbsp;<code>26</code>的数组。</li>\n\t<li><code>widths[i]</code>&nbsp;值的范围在&nbsp;<code>[2, 10]</code>。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 807保持城市天际线",
        "hardRate": "MEDIUM",
        "passRate": "88.08%",
        "problemsUrl": "https://leetcode.cn/problems/max-increase-to-keep-city-skyline/",
        "solutionsUrl": "https://leetcode.cn/problems/max-increase-to-keep-city-skyline/solution",
        "problemsDesc": "<p>给你一座由 <code>n x n</code> 个街区组成的城市，每个街区都包含一座立方体建筑。给你一个下标从 <strong>0</strong> 开始的 <code>n x n</code> 整数矩阵 <code>grid</code> ，其中 <code>grid[r][c]</code> 表示坐落于 <code>r</code> 行 <code>c</code> 列的建筑物的 <strong>高度</strong> 。</p>\n\n<p>城市的 <strong>天际线</strong> 是从远处观察城市时，所有建筑物形成的外部轮廓。从东、南、西、北四个主要方向观测到的 <strong>天际线</strong> 可能不同。</p>\n\n<p>我们被允许为 <strong>任意数量的建筑物 </strong>的高度增加<strong> 任意增量（不同建筑物的增量可能不同）</strong> 。 高度为 <code>0</code> 的建筑物的高度也可以增加。然而，增加的建筑物高度 <strong>不能影响</strong> 从任何主要方向观察城市得到的 <strong>天际线</strong> 。</p>\n\n<p>在 <strong>不改变</strong> 从任何主要方向观测到的城市 <strong>天际线</strong> 的前提下，返回建筑物可以增加的 <strong>最大高度增量总和</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/21/807-ex1.png\" style=\"width: 700px; height: 603px;\" />\n<pre>\n<strong>输入：</strong>grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]\n<strong>输出：</strong>35\n<strong>解释：</strong>建筑物的高度如上图中心所示。\n用红色绘制从不同方向观看得到的天际线。\n在不影响天际线的情况下，增加建筑物的高度：\ngridNew = [ [8, 4, 8, 7],\n            [7, 4, 7, 7],\n            [9, 4, 8, 7],\n            [3, 3, 3, 3] ]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,0,0],[0,0,0],[0,0,0]]\n<strong>输出：</strong>0\n<strong>解释：</strong>增加任何建筑物的高度都会导致天际线的变化。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[r].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 50</code></li>\n\t<li><code>0 &lt;= grid[r][c] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 808分汤",
        "hardRate": "MEDIUM",
        "passRate": "58.77%",
        "problemsUrl": "https://leetcode.cn/problems/soup-servings/",
        "solutionsUrl": "https://leetcode.cn/problems/soup-servings/solution",
        "problemsDesc": "<p>有&nbsp;<strong>A&nbsp;和&nbsp;B 两种类型&nbsp;</strong>的汤。一开始每种类型的汤有&nbsp;<code>n</code>&nbsp;毫升。有四种分配操作：</p>\n\n<ol>\n\t<li>提供 <code>100ml</code> 的 <strong>汤A</strong> 和 <code>0ml</code> 的 <strong>汤B</strong> 。</li>\n\t<li>提供 <code>75ml</code> 的 <strong>汤A</strong> 和 <code>25ml</code> 的 <strong>汤B</strong> 。</li>\n\t<li>提供 <code>50ml</code> 的 <strong>汤A</strong> 和 <code>50ml</code> 的 <strong>汤B</strong> 。</li>\n\t<li>提供 <code>25ml</code> 的 <strong>汤A</strong> 和 <code>75ml</code> 的 <strong>汤B</strong> 。</li>\n</ol>\n\n<p>当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为 <code>0.25</code> 的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。</p>\n\n<p><strong>注意&nbsp;</strong>不存在先分配 <code>100</code> ml <strong>汤B</strong> 的操作。</p>\n\n<p>需要返回的值：&nbsp;<strong>汤A&nbsp;</strong>先分配完的概率 +&nbsp;&nbsp;<strong>汤A和汤B&nbsp;</strong>同时分配完的概率 / 2。返回值在正确答案&nbsp;<code>10<sup>-5</sup></code>&nbsp;的范围内将被认为是正确的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 50\n<strong>输出:</strong> 0.62500\n<strong>解释:</strong>如果我们选择前两个操作<strong>，</strong>A 首先将变为空。\n对于第三个操作，A 和 B 会同时变为空。\n对于第四个操作，B 首先将变为空。<strong>\n</strong>所以 A 变为空的总概率加上 A 和 B 同时变为空的概率的一半是 0.25 *(1 + 1 + 0.5 + 0)= 0.625。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 100\n<strong>输出:</strong> 0.71875\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code>​​​​​​​</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 809情感丰富的文字",
        "hardRate": "MEDIUM",
        "passRate": "48.94%",
        "problemsUrl": "https://leetcode.cn/problems/expressive-words/",
        "solutionsUrl": "https://leetcode.cn/problems/expressive-words/solution",
        "problemsDesc": "<p>有时候人们会用重复写一些字母来表示额外的感受，比如 <code>\"hello\" -&gt; \"heeellooo\"</code>, <code>\"hi\" -&gt; \"hiii\"</code>。我们将相邻字母都相同的一串字符定义为相同字母组，例如：\"h\", \"eee\", \"ll\", \"ooo\"。</p>\n\n<p>对于一个给定的字符串 S ，如果另一个单词能够通过将一些字母组扩张从而使其和 S 相同，我们将这个单词定义为可扩张的（stretchy）。扩张操作定义如下：选择一个字母组（包含字母&nbsp;<code>c</code>&nbsp;），然后往其中添加相同的字母&nbsp;<code>c</code>&nbsp;使其长度达到 3 或以上。</p>\n\n<p>例如，以&nbsp;\"hello\" 为例，我们可以对字母组&nbsp;\"o\" 扩张得到 \"hellooo\"，但是无法以同样的方法得到 \"helloo\" 因为字母组 \"oo\" 长度小于&nbsp;3。此外，我们可以进行另一种扩张 \"ll\" -&gt; \"lllll\" 以获得&nbsp;\"helllllooo\"。如果&nbsp;<code>s = \"helllllooo\"</code>，那么查询词&nbsp;\"hello\" 是可扩张的，因为可以对它执行这两种扩张操作使得&nbsp;<code>query = \"hello\" -&gt; \"hellooo\" -&gt;&nbsp;\"helllllooo\" = s</code>。</p>\n\n<p>输入一组查询单词，输出其中可扩张的单词数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong> \ns = \"heeellooo\"\nwords = [\"hello\", \"hi\", \"helo\"]\n<strong>输出：</strong>1\n<strong>解释</strong>：\n我们能通过扩张 \"hello\" 的 \"e\" 和 \"o\" 来得到 \"heeellooo\"。\n我们不能通过扩张 \"helo\" 来得到 \"heeellooo\" 因为 \"ll\" 的长度小于 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size: 12.6px; background-color: rgb(249, 242, 244);\">s</span></font> 和所有在&nbsp;<code>words</code>&nbsp;中的单词都只由小写字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 810黑板异或游戏",
        "hardRate": "HARD",
        "passRate": "72.54%",
        "problemsUrl": "https://leetcode.cn/problems/chalkboard-xor-game/",
        "solutionsUrl": "https://leetcode.cn/problems/chalkboard-xor-game/solution",
        "problemsDesc": "<p>黑板上写着一个非负整数数组 <code>nums[i]</code> 。</p>\n\n<p>Alice 和 Bob 轮流从黑板上擦掉一个数字，Alice 先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 <code>0</code> 的话，当前玩家游戏失败。&nbsp;另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为&nbsp;<code>0</code>。</p>\n\n<p>并且，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 <code>0</code> ，这个玩家获胜。</p>\n\n<p>假设两个玩家每步都使用最优解，当且仅当 Alice 获胜时返回 <code>true</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,1,2]\n<strong>输出:</strong> false\n<strong>解释:</strong> \nAlice 有两个选择: 擦掉数字 1 或 2。\n如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 = 3。那么 Bob 可以擦掉任意数字，因为 Alice 会成为擦掉最后一个数字的人，她总是会输。\n如果 Alice 擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 = 0。Alice 仍然会输掉游戏。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [0,1]\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,3]\n<strong>输出:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt; 2<sup>16</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 811子域名访问计数",
        "hardRate": "MEDIUM",
        "passRate": "76.66%",
        "problemsUrl": "https://leetcode.cn/problems/subdomain-visit-count/",
        "solutionsUrl": "https://leetcode.cn/problems/subdomain-visit-count/solution",
        "problemsDesc": "<p>网站域名 <code>\"discuss.leetcode.com\"</code> 由多个子域名组成。顶级域名为 <code>\"com\"</code> ，二级域名为 <code>\"leetcode.com\"</code> ，最低一级为 <code>\"discuss.leetcode.com\"</code> 。当访问域名 <code>\"discuss.leetcode.com\"</code> 时，同时也会隐式访问其父域名 <code>\"leetcode.com\" </code>以及 <code>\"com\"</code> 。</p>\n\n<p><strong>计数配对域名</strong> 是遵循 <code>\"rep d1.d2.d3\"</code> 或 <code>\"rep d1.d2\"</code> 格式的一个域名表示，其中 <code>rep</code> 表示访问域名的次数，<code>d1.d2.d3</code> 为域名本身。</p>\n\n<ul>\n\t<li>例如，<code>\"9001 discuss.leetcode.com\"</code> 就是一个 <strong>计数配对域名</strong> ，表示 <code>discuss.leetcode.com</code> 被访问了 <code>9001</code> 次。</li>\n</ul>\n\n<p>给你一个<strong> 计数配对域名 </strong>组成的数组 <code>cpdomains</code> ，解析得到输入中每个子域名对应的&nbsp;<strong>计数配对域名</strong> ，并以数组形式返回。可以按 <strong>任意顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>cpdomains = [\"9001 discuss.leetcode.com\"]\n<strong>输出：</strong>[\"9001 leetcode.com\",\"9001 discuss.leetcode.com\",\"9001 com\"]\n<strong>解释：</strong>例子中仅包含一个网站域名：\"discuss.leetcode.com\"。\n按照前文描述，子域名 \"leetcode.com\" 和 \"com\" 都会被访问，所以它们都被访问了 9001 次。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>cpdomains = [\"900 google.mail.com\", \"50 yahoo.com\", \"1 intel.mail.com\", \"5 wiki.org\"]\n<strong>输出：</strong>[\"901 mail.com\",\"50 yahoo.com\",\"900 google.mail.com\",\"5 wiki.org\",\"5 org\",\"1 intel.mail.com\",\"951 com\"]\n<strong>解释：</strong>按照前文描述，会访问 \"google.mail.com\" 900 次，\"yahoo.com\" 50 次，\"intel.mail.com\" 1 次，\"wiki.org\" 5 次。\n而对于父域名，会访问 \"mail.com\" 900 + 1 = 901 次，\"com\" 900 + 50 + 1 = 951 次，和 \"org\" 5 次。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= cpdomain.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= cpdomain[i].length &lt;= 100</code></li>\n\t<li><code>cpdomain[i]</code> 会遵循 <code>\"rep<sub>i</sub> d1<sub>i</sub>.d2<sub>i</sub>.d3<sub>i</sub>\"</code> 或 <code>\"rep<sub>i</sub> d1<sub>i</sub>.d2<sub>i</sub>\"</code> 格式</li>\n\t<li><code>rep<sub>i</sub></code> 是范围 <code>[1, 10<sup>4</sup>]</code> 内的一个整数</li>\n\t<li><code>d1<sub>i</sub></code>、<code>d2<sub>i</sub></code> 和 <code>d3<sub>i</sub></code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 812最大三角形面积",
        "hardRate": "EASY",
        "passRate": "68.21%",
        "problemsUrl": "https://leetcode.cn/problems/largest-triangle-area/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-triangle-area/solution",
        "problemsDesc": "<p>给你一个由 <strong>X-Y</strong> 平面上的点组成的数组 <code>points</code> ，其中 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 。从其中取任意三个不同的点组成三角形，返回能组成的最大三角形的面积。与真实值误差在 <code>10<sup>-5</sup></code> 内的答案将会视为正确答案<strong>。</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/04/1027.png\" style=\"height: 369px; width: 450px;\" />\n<pre>\n<strong>输入：</strong>points = [[0,0],[0,1],[1,0],[0,2],[2,0]]\n<strong>输出：</strong>2.00000\n<strong>解释：</strong>输入中的 5 个点如上图所示，红色的三角形面积最大。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[1,0],[0,0],[0,1]]\n<strong>输出：</strong>0.50000\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= points.length &lt;= 50</code></li>\n\t<li><code>-50 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 50</code></li>\n\t<li>给出的所有点 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 813最大平均值和的分组",
        "hardRate": "MEDIUM",
        "passRate": "61.72%",
        "problemsUrl": "https://leetcode.cn/problems/largest-sum-of-averages/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-sum-of-averages/solution",
        "problemsDesc": "<p>给定数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。我们将给定的数组&nbsp;<code>nums</code>&nbsp;分成 <strong>最多</strong>&nbsp;<code>k</code>&nbsp;个相邻的非空子数组 。&nbsp;<strong>分数</strong> 由每个子数组内的平均值的总和构成。</p>\n\n<p>注意我们必须使用 <code>nums</code> 数组中的每一个数进行分组，并且分数不一定需要是整数。</p>\n\n<p>返回我们所能得到的最大 <strong>分数</strong> 是多少。答案误差在&nbsp;<code>10<sup>-6</sup></code>&nbsp;内被视为是正确的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [9,1,2,3,9], k = 3\n<strong>输出:</strong> 20.00000\n<strong>解释:</strong> \nnums 的最优分组是[9], [1, 2, 3], [9]. 得到的分数是 9 + (1 + 2 + 3) / 3 + 9 = 20. \n我们也可以把 nums 分成[9, 1], [2], [3, 9]. \n这样的分组得到的分数为 5 + 2 + 6 = 13, 但不是最大值.\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,3,4,5,6,7], k = 4\n<strong>输出:</strong> 20.50000\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 814二叉树剪枝",
        "hardRate": "MEDIUM",
        "passRate": "72.55%",
        "problemsUrl": "https://leetcode.cn/problems/binary-tree-pruning/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-tree-pruning/solution",
        "problemsDesc": "<p>给你二叉树的根结点&nbsp;<code>root</code>&nbsp;，此外树的每个结点的值要么是 <code>0</code> ，要么是 <code>1</code> 。</p>\n\n<p>返回移除了所有不包含 <code>1</code> 的子树的原二叉树。</p>\n\n<p>节点 <code>node</code> 的子树为 <code>node</code> 本身加上所有 <code>node</code> 的后代。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_2.png\" style=\"width: 500px; height: 140px;\" />\n<pre>\n<strong>输入：</strong>root = [1,null,0,0,1]\n<strong>输出：</strong>[1,null,0,null,1]\n<strong>解释：</strong>\n只有红色节点满足条件“所有不包含 1 的子树”。 右图为返回的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_1.png\" style=\"width: 500px; height: 115px;\" />\n<pre>\n<strong>输入：</strong>root = [1,0,1,0,0,0,1]\n<strong>输出：</strong>[1,null,1,null,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/05/1028.png\" style=\"width: 500px; height: 134px;\" />\n<pre>\n<strong>输入：</strong>root = [1,1,0,1,1,0,1,0]\n<strong>输出：</strong>[1,1,0,1,1,null,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 200]</code> 内</li>\n\t<li><code>Node.val</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 815公交路线",
        "hardRate": "HARD",
        "passRate": "44.42%",
        "problemsUrl": "https://leetcode.cn/problems/bus-routes/",
        "solutionsUrl": "https://leetcode.cn/problems/bus-routes/solution",
        "problemsDesc": "<p>给你一个数组 <code>routes</code> ，表示一系列公交线路，其中每个 <code>routes[i]</code> 表示一条公交线路，第 <code>i</code> 辆公交车将会在上面循环行驶。</p>\n\n<ul>\n\t<li>例如，路线 <code>routes[0] = [1, 5, 7]</code> 表示第 <code>0</code> 辆公交车会一直按序列 <code>1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ...</code> 这样的车站路线行驶。</li>\n</ul>\n\n<p>现在从 <code>source</code> 车站出发（初始时不在公交车上），要前往 <code>target</code> 车站。 期间仅可乘坐公交车。</p>\n\n<p>求出 <strong>最少乘坐的公交车数量</strong> 。如果不可能到达终点车站，返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>routes = [[1,2,7],[3,6,7]], source = 1, target = 6\n<strong>输出：</strong>2\n<strong>解释：</strong>最优策略是先乘坐第一辆公交车到达车站 7 , 然后换乘第二辆公交车到车站 6 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12\n<strong>输出：</strong>-1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= routes.length <= 500</code>.</li>\n\t<li><code>1 <= routes[i].length <= 10<sup>5</sup></code></li>\n\t<li><code>routes[i]</code> 中的所有值 <strong>互不相同</strong></li>\n\t<li><code>sum(routes[i].length) <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= routes[i][j] < 10<sup>6</sup></code></li>\n\t<li><code>0 <= source, target < 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 816模糊坐标",
        "hardRate": "MEDIUM",
        "passRate": "62.58%",
        "problemsUrl": "https://leetcode.cn/problems/ambiguous-coordinates/",
        "solutionsUrl": "https://leetcode.cn/problems/ambiguous-coordinates/solution",
        "problemsDesc": "<p>我们有一些二维坐标，如&nbsp;<code>&quot;(1, 3)&quot;</code>&nbsp;或&nbsp;<code>&quot;(2, 0.5)&quot;</code>，然后我们移除所有逗号，小数点和空格，得到一个字符串<code>S</code>。返回所有可能的原始字符串到一个列表中。</p>\n\n<p>原始的坐标表示法不会存在多余的零，所以不会出现类似于&quot;00&quot;, &quot;0.0&quot;, &quot;0.00&quot;, &quot;1.0&quot;, &quot;001&quot;, &quot;00.01&quot;或一些其他更小的数来表示坐标。此外，一个小数点前至少存在一个数，所以也不会出现&ldquo;.1&rdquo;形式的数字。</p>\n\n<p>最后返回的列表可以是任意顺序的。而且注意返回的两个数字中间（逗号之后）都有一个空格。</p>\n\n<p>&nbsp;</p>\n\n<pre>\n<strong>示例 1:</strong>\n<strong>输入:</strong> &quot;(123)&quot;\n<strong>输出:</strong> [&quot;(1, 23)&quot;, &quot;(12, 3)&quot;, &quot;(1.2, 3)&quot;, &quot;(1, 2.3)&quot;]\n</pre>\n\n<pre>\n<strong>示例 2:</strong>\n<strong>输入:</strong> &quot;(00011)&quot;\n<strong>输出:</strong> &nbsp;[&quot;(0.001, 1)&quot;, &quot;(0, 0.011)&quot;]\n<strong>解释:</strong> \n0.0, 00, 0001 或 00.01 是不被允许的。\n</pre>\n\n<pre>\n<strong>示例 3:</strong>\n<strong>输入:</strong> &quot;(0123)&quot;\n<strong>输出:</strong> [&quot;(0, 123)&quot;, &quot;(0, 12.3)&quot;, &quot;(0, 1.23)&quot;, &quot;(0.1, 23)&quot;, &quot;(0.1, 2.3)&quot;, &quot;(0.12, 3)&quot;]\n</pre>\n\n<pre>\n<strong>示例 4:</strong>\n<strong>输入:</strong> &quot;(100)&quot;\n<strong>输出:</strong> [(10, 0)]\n<strong>解释:</strong> \n1.0 是不被允许的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示: </strong></p>\n\n<ul>\n\t<li><code>4 &lt;= S.length &lt;= 12</code>.</li>\n\t<li><code>S[0]</code> = &quot;(&quot;, <code>S[S.length - 1]</code> = &quot;)&quot;, 且字符串&nbsp;<code>S</code>&nbsp;中的其他元素都是数字。</li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 817链表组件",
        "hardRate": "MEDIUM",
        "passRate": "61.39%",
        "problemsUrl": "https://leetcode.cn/problems/linked-list-components/",
        "solutionsUrl": "https://leetcode.cn/problems/linked-list-components/solution",
        "problemsDesc": "<p>给定链表头结点&nbsp;<code>head</code>，该链表上的每个结点都有一个 <strong>唯一的整型值</strong> 。同时给定列表&nbsp;<code>nums</code>，该列表是上述链表中整型值的一个子集。</p>\n\n<p>返回列表&nbsp;<code>nums</code>&nbsp;中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表&nbsp;<code>nums</code>&nbsp;中）构成的集合。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/22/lc-linkedlistcom1.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> head = [0,1,2,3], nums = [0,1,3]\n<strong>输出:</strong> 2\n<strong>解释:</strong> 链表中,0 和 1 是相连接的，且 nums 中不包含 2，所以 [0, 1] 是 nums 的一个组件，同理 [3] 也是一个组件，故返回 2。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong>&nbsp;</strong><img src=\"https://assets.leetcode.com/uploads/2021/07/22/lc-linkedlistcom2.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> head = [0,1,2,3,4], nums = [0,3,1,4]\n<strong>输出:</strong> 2\n<strong>解释:</strong> 链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点数为<code>n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= Node.val &lt; n</code></li>\n\t<li><code>Node.val</code>&nbsp;中所有值 <strong>不同</strong></li>\n\t<li><code>1 &lt;= nums.length &lt;= n</code></li>\n\t<li><code>0 &lt;= nums[i] &lt; n</code></li>\n\t<li><code>nums</code> 中所有值 <strong>不同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 818赛车",
        "hardRate": "HARD",
        "passRate": "44.84%",
        "problemsUrl": "https://leetcode.cn/problems/race-car/",
        "solutionsUrl": "https://leetcode.cn/problems/race-car/solution",
        "problemsDesc": "你的赛车可以从位置 <code>0</code> 开始，并且速度为 <code>+1</code> ，在一条无限长的数轴上行驶。赛车也可以向负方向行驶。赛车可以按照由加速指令 <code>'A'</code> 和倒车指令 <code>'R'</code> 组成的指令序列自动行驶。\n<ul>\n\t<li>当收到指令 <code>'A'</code> 时，赛车这样行驶：\n\t<ul>\n\t\t<li><code>position += speed</code></li>\n\t\t<li><code>speed *= 2</code></li>\n\t</ul>\n\t</li>\n\t<li>当收到指令 <code>'R'</code> 时，赛车这样行驶：\n\t<ul>\n\t\t<li>如果速度为正数，那么<code>speed = -1</code></li>\n\t\t<li>否则 <code>speed = 1</code></li>\n\t</ul>\n\t当前所处位置不变。</li>\n</ul>\n\n<p>例如，在执行指令 <code>\"AAR\"</code> 后，赛车位置变化为 <code>0 --&gt; 1 --&gt; 3 --&gt; 3</code> ，速度变化为 <code>1 --&gt; 2 --&gt; 4 --&gt; -1</code> 。</p>\n\n<p>给你一个目标位置 <code>target</code> ，返回能到达目标位置的最短指令序列的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>\n最短指令序列是 \"AA\" 。\n位置变化 0 --&gt; 1 --&gt; 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 6\n<strong>输出：</strong>5\n<strong>解释：</strong>\n最短指令序列是 \"AAARA\" 。\n位置变化 0 --&gt; 1 --&gt; 3 --&gt; 7 --&gt; 7 --&gt; 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 819最常见的单词",
        "hardRate": "EASY",
        "passRate": "45.62%",
        "problemsUrl": "https://leetcode.cn/problems/most-common-word/",
        "solutionsUrl": "https://leetcode.cn/problems/most-common-word/solution",
        "problemsDesc": "<p>给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不在禁用列表中的单词。</p>\n\n<p>题目保证至少有一个词不在禁用列表中，而且答案唯一。</p>\n\n<p>禁用列表中的单词用小写字母表示，不含标点符号。段落中的单词不区分大小写。答案都是小写字母。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入:</strong> \nparagraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;\nbanned = [&quot;hit&quot;]\n<strong>输出:</strong> &quot;ball&quot;\n<strong>解释:</strong> \n&quot;hit&quot; 出现了3次，但它是一个禁用的单词。\n&quot;ball&quot; 出现了2次 (同时没有其他单词出现2次)，所以它是段落里出现次数最多的，且不在禁用列表中的单词。 \n注意，所有这些单词在段落里不区分大小写，标点符号需要忽略（即使是紧挨着单词也忽略， 比如 &quot;ball,&quot;）， \n&quot;hit&quot;不是最终的答案，虽然它出现次数更多，但它在禁用单词列表中。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= 段落长度 &lt;= 1000</code></li>\n\t<li><code>0 &lt;= 禁用单词个数 &lt;= 100</code></li>\n\t<li><code>1 &lt;= 禁用单词长度 &lt;= 10</code></li>\n\t<li>答案是唯一的, 且都是小写字母&nbsp;(即使在 <code>paragraph</code> 里是大写的，即使是一些特定的名词，答案都是小写的。)</li>\n\t<li><code>paragraph</code>&nbsp;只包含字母、空格和下列标点符号<code>!?&#39;,;.</code></li>\n\t<li>不存在没有连字符或者带有连字符的单词。</li>\n\t<li>单词里只包含字母，不会出现省略号或者其他标点符号。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 820单词的压缩编码",
        "hardRate": "MEDIUM",
        "passRate": "52.08%",
        "problemsUrl": "https://leetcode.cn/problems/short-encoding-of-words/",
        "solutionsUrl": "https://leetcode.cn/problems/short-encoding-of-words/solution",
        "problemsDesc": "<p>单词数组 <code>words</code> 的 <strong>有效编码</strong> 由任意助记字符串 <code>s</code> 和下标数组 <code>indices</code> 组成，且满足：</p>\n\n<ul>\n\t<li><code>words.length == indices.length</code></li>\n\t<li>助记字符串 <code>s</code> 以 <code>'#'</code> 字符结尾</li>\n\t<li>对于每个下标 <code>indices[i]</code> ，<code>s</code> 的一个从 <code>indices[i]</code> 开始、到下一个 <code>'#'</code> 字符结束（但不包括 <code>'#'</code>）的 <strong>子字符串</strong> 恰好与 <code>words[i]</code> 相等</li>\n</ul>\n\n<p>给你一个单词数组 <code>words</code> ，返回成功对 <code>words</code> 进行编码的最小助记字符串 <code>s</code> 的长度 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"time\", \"me\", \"bell\"]\n<strong>输出：</strong>10\n<strong>解释：</strong>一组有效编码为 s = <code>\"time#bell#\" 和 indices = [0, 2, 5</code>] 。\nwords[0] = \"time\" ，s 开始于 indices[0] = 0 到下一个 '#' 结束的子字符串，如加粗部分所示 \"<strong>time</strong>#bell#\"\nwords[1] = \"me\" ，s 开始于 indices[1] = 2 到下一个 '#' 结束的子字符串，如加粗部分所示 \"ti<strong>me</strong>#bell#\"\nwords[2] = \"bell\" ，s 开始于 indices[2] = 5 到下一个 '#' 结束的子字符串，如加粗部分所示 \"time#<strong>bell</strong>#\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"t\"]\n<strong>输出：</strong>2\n<strong>解释：</strong>一组有效编码为 s = \"t#\" 和 indices = [0] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= words.length <= 2000</code></li>\n\t<li><code>1 <= words[i].length <= 7</code></li>\n\t<li><code>words[i]</code> 仅由小写字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 821字符的最短距离",
        "hardRate": "EASY",
        "passRate": "72.87%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-distance-to-a-character/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-distance-to-a-character/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和一个字符 <code>c</code> ，且 <code>c</code> 是 <code>s</code> 中出现过的字符。</p>\n\n<p>返回一个整数数组 <code>answer</code> ，其中 <code>answer.length == s.length</code> 且 <code>answer[i]</code> 是 <code>s</code> 中从下标 <code>i</code> 到离它 <strong>最近</strong> 的字符 <code>c</code> 的 <strong>距离</strong> 。</p>\n\n<p>两个下标&nbsp;<code>i</code> 和 <code>j</code> 之间的 <strong>距离</strong> 为 <code>abs(i - j)</code> ，其中 <code>abs</code> 是绝对值函数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"loveleetcode\", c = \"e\"\n<strong>输出：</strong>[3,2,1,0,1,0,0,1,2,2,1,0]\n<strong>解释：</strong>字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aaab\", c = \"b\"\n<strong>输出：</strong>[3,2,1,0]\n</pre>\n\n<p>&nbsp;</p>\n<strong>提示：</strong>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s[i]</code> 和 <code>c</code> 均为小写英文字母</li>\n\t<li>题目数据保证 <code>c</code> 在 <code>s</code> 中至少出现一次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 822翻转卡片游戏",
        "hardRate": "MEDIUM",
        "passRate": "51.68%",
        "problemsUrl": "https://leetcode.cn/problems/card-flipping-game/",
        "solutionsUrl": "https://leetcode.cn/problems/card-flipping-game/solution",
        "problemsDesc": "<p>在桌子上有 <code>N</code> 张卡片，每张卡片的正面和背面都写着一个正数（正面与背面上的数有可能不一样）。</p>\n\n<p>我们可以先翻转任意张卡片，然后选择其中一张卡片。</p>\n\n<p>如果选中的那张卡片背面的数字 <code>X</code> 与任意一张卡片的正面的数字都不同，那么这个数字是我们想要的数字。</p>\n\n<p>哪个数是这些想要的数字中最小的数（找到这些数中的最小值）呢？如果没有一个数字符合要求的，输出 0。</p>\n\n<p>其中, <code>fronts[i]</code>&nbsp;和&nbsp;<code>backs[i]</code>&nbsp;分别代表第&nbsp;<code>i</code>&nbsp;张卡片的正面和背面的数字。</p>\n\n<p>如果我们通过翻转卡片来交换正面与背面上的数，那么当初在正面的数就变成背面的数，背面的数就变成正面的数。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>fronts = [1,2,4,4,7], backs = [1,3,4,1,3]\n<strong>输出：</strong><code>2</code>\n<strong>解释：</strong>假设我们翻转第二张卡片，那么在正面的数变成了 <code>[1,3,4,4,7]</code> ， 背面的数变成了 <code>[1,2,4,1,3]。</code>\n接着我们选择第二张卡片，因为现在该卡片的背面的数是 2，2 与任意卡片上正面的数都不同，所以 2 就是我们想要的数字。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= fronts.length == backs.length&nbsp;&lt;=&nbsp;1000</code></li>\n\t<li><code>1 &lt;=&nbsp;fronts[i]&nbsp;&lt;= 2000</code></li>\n\t<li><code>1 &lt;= backs[i]&nbsp;&lt;= 2000</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 823带因子的二叉树",
        "hardRate": "MEDIUM",
        "passRate": "43.46%",
        "problemsUrl": "https://leetcode.cn/problems/binary-trees-with-factors/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-trees-with-factors/solution",
        "problemsDesc": "<p>给出一个含有不重复整数元素的数组 <code>arr</code> ，每个整数 <code>arr[i]</code> 均大于 1。</p>\n\n<p>用这些整数来构建二叉树，每个整数可以使用任意次数。其中：每个非叶结点的值应等于它的两个子结点的值的乘积。</p>\n\n<p>满足条件的二叉树一共有多少个？答案可能很大，返回<strong> 对 </strong><code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>arr = [2, 4]</code>\n<strong>输出:</strong> 3\n<strong>解释:</strong> 可以得到这些二叉树: <code>[2], [4], [4, 2, 2]</code></pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>arr = [2, 4, 5, 10]</code>\n<strong>输出:</strong> <code>7</code>\n<strong>解释:</strong> 可以得到这些二叉树: <code>[2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2]</code>.</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>2 &lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>arr</code> 中的所有值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 824山羊拉丁文",
        "hardRate": "EASY",
        "passRate": "65.09%",
        "problemsUrl": "https://leetcode.cn/problems/goat-latin/",
        "solutionsUrl": "https://leetcode.cn/problems/goat-latin/solution",
        "problemsDesc": "<p>给你一个由若干单词组成的句子&nbsp;<code>sentence</code> ，单词间由空格分隔。每个单词仅由大写和小写英文字母组成。</p>\n\n<p>请你将句子转换为 <em>“</em>山羊拉丁文（<em>Goat Latin</em>）<em>”</em>（一种类似于 猪拉丁文&nbsp;- Pig Latin 的虚构语言）。山羊拉丁文的规则如下：</p>\n\n<ul>\n\t<li>如果单词以元音开头（<code>'a'</code>, <code>'e'</code>, <code>'i'</code>, <code>'o'</code>, <code>'u'</code>），在单词后添加<code>\"ma\"</code>。\n\n\t<ul>\n\t\t<li>例如，单词 <code>\"apple\"</code> 变为 <code>\"applema\"</code> 。</li>\n\t</ul>\n\t</li>\n\t<li>如果单词以辅音字母开头（即，非元音字母），移除第一个字符并将它放到末尾，之后再添加<code>\"ma\"</code>。\n\t<ul>\n\t\t<li>例如，单词 <code>\"goat\"</code> 变为 <code>\"oatgma\"</code> 。</li>\n\t</ul>\n\t</li>\n\t<li>根据单词在句子中的索引，在单词最后添加与索引相同数量的字母<code>'a'</code>，索引从 <code>1</code> 开始。\n\t<ul>\n\t\t<li>例如，在第一个单词后添加 <code>\"a\"</code> ，在第二个单词后添加 <code>\"aa\"</code> ，以此类推。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>返回将 <code>sentence</code> 转换为山羊拉丁文后的句子。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"I speak Goat Latin\"\n<strong>输出：</strong>\"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"The quick brown fox jumped over the lazy dog\"\n<strong>输出：</strong>\"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentence.length &lt;= 150</code></li>\n\t<li><code>sentence</code> 由英文字母和空格组成</li>\n\t<li><code>sentence</code> 不含前导或尾随空格</li>\n\t<li><code>sentence</code> 中的所有单词由单个空格分隔</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 825适龄的朋友",
        "hardRate": "MEDIUM",
        "passRate": "45.40%",
        "problemsUrl": "https://leetcode.cn/problems/friends-of-appropriate-ages/",
        "solutionsUrl": "https://leetcode.cn/problems/friends-of-appropriate-ages/solution",
        "problemsDesc": "<p>在社交媒体网站上有 <code>n</code> 个用户。给你一个整数数组 <code>ages</code> ，其中 <code>ages[i]</code> 是第 <code>i</code> 个用户的年龄。</p>\n\n<p>如果下述任意一个条件为真，那么用户 <code>x</code> 将不会向用户 <code>y</code>（<code>x != y</code>）发送好友请求：</p>\n\n<ul>\n\t<li><code>ages[y] &lt;= 0.5 * ages[x] + 7</code></li>\n\t<li><code>ages[y] &gt; ages[x]</code></li>\n\t<li><code>ages[y] &gt; 100 &amp;&amp; ages[x] &lt; 100</code></li>\n</ul>\n\n<p>否则，<code>x</code> 将会向 <code>y</code> 发送一条好友请求。</p>\n\n<p>注意，如果 <code>x</code> 向 <code>y</code> 发送一条好友请求，<code>y</code> 不必也向 <code>x</code> 发送一条好友请求。另外，用户不会向自己发送好友请求。</p>\n\n<p>返回在该社交媒体网站上产生的好友请求总数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>ages = [16,16]\n<strong>输出：</strong>2\n<strong>解释：</strong>2 人互发好友请求。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>ages = [16,17,18]\n<strong>输出：</strong>2\n<strong>解释：</strong>产生的好友请求为 17 -&gt; 16 ，18 -&gt; 17 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>ages = [20,30,100,110,120]\n<strong>输出：</strong>3\n<strong>解释：</strong>产生的好友请求为 110 -&gt; 100 ，120 -&gt; 110 ，120 -&gt; 100 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == ages.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= ages[i] &lt;= 120</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 826安排工作以达到最大收益",
        "hardRate": "MEDIUM",
        "passRate": "42.57%",
        "problemsUrl": "https://leetcode.cn/problems/most-profit-assigning-work/",
        "solutionsUrl": "https://leetcode.cn/problems/most-profit-assigning-work/solution",
        "problemsDesc": "<p>你有 <code>n</code>&nbsp;个工作和 <code>m</code> 个工人。给定三个数组：&nbsp;<code>difficulty</code>,&nbsp;<code>profit</code>&nbsp;和&nbsp;<code>worker</code>&nbsp;，其中:</p>\n\n<ul>\n\t<li><code>difficulty[i]</code>&nbsp;表示第 <code>i</code> 个工作的难度，<code>profit[i]</code> 表示第 <code>i</code> 个工作的收益。</li>\n\t<li><code>worker[i]</code> 是第 <code>i</code> 个工人的能力，即该工人只能完成难度小于等于 <code>worker[i]</code> 的工作。</li>\n</ul>\n\n<p>每个工人&nbsp;<strong>最多</strong> 只能安排 <strong>一个</strong> 工作，但是一个工作可以 <strong>完成多次</strong> 。</p>\n\n<ul>\n\t<li>举个例子，如果 3 个工人都尝试完成一份报酬为 <code>$1</code> 的同样工作，那么总收益为 <code>$3</code>&nbsp;。如果一个工人不能完成任何工作，他的收益为 <code>$0</code> 。</li>\n</ul>\n\n<p>返回 <em>在把工人分配到工作岗位后，我们所能获得的最大利润&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]\n<strong>输出: </strong>100 \n<strong>解释: </strong>工人被分配的工作难度是 [4,4,6,6] ，分别获得 [20,20,30,30] 的收益。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]\n<strong>输出:</strong> 0</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>n == difficulty.length</code></li>\n\t<li><code>n == profit.length</code></li>\n\t<li><code>m == worker.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= difficulty[i], profit[i], worker[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 827最大人工岛",
        "hardRate": "HARD",
        "passRate": "47.10%",
        "problemsUrl": "https://leetcode.cn/problems/making-a-large-island/",
        "solutionsUrl": "https://leetcode.cn/problems/making-a-large-island/solution",
        "problemsDesc": "<p>给你一个大小为 <code>n x n</code> 二进制矩阵 <code>grid</code> 。<strong>最多</strong> 只能将一格 <code>0</code> 变成 <code>1</code> 。</p>\n\n<p>返回执行此操作后，<code>grid</code> 中最大的岛屿面积是多少？</p>\n\n<p><strong>岛屿</strong> 由一组上、下、左、右四个方向相连的 <code>1</code> 形成。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>grid = [[1, 0], [0, 1]]\n<strong>输出:</strong> 3\n<strong>解释:</strong> 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>grid =<strong> </strong>[[1, 1], [1, 0]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> 将一格0变成1，岛屿的面积扩大为 4。</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入: </strong>grid = [[1, 1], [1, 1]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> 没有0可以让我们变成1，面积依然为 4。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 <= n <= 500</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 828统计子串中的唯一字符",
        "hardRate": "HARD",
        "passRate": "65.60%",
        "problemsUrl": "https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/",
        "solutionsUrl": "https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/solution",
        "problemsDesc": "<p>我们定义了一个函数 <code>countUniqueChars(s)</code> 来统计字符串 <code>s</code> 中的唯一字符，并返回唯一字符的个数。</p>\n\n<p>例如：<code>s = \"LEETCODE\"</code> ，则其中 <code>\"L\"</code>, <code>\"T\"</code>,<code>\"C\"</code>,<code>\"O\"</code>,<code>\"D\"</code> 都是唯一字符，因为它们只出现一次，所以 <code>countUniqueChars(s) = 5</code> 。</p>\n\n<p>本题将会给你一个字符串 <code>s</code> ，我们需要返回 <code>countUniqueChars(t)</code> 的总和，其中 <code>t</code> 是 <code>s</code> 的子字符串。输入用例保证返回值为&nbsp;32 位整数。</p>\n\n<p>注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 <code>s</code> 的所有子字符串中的唯一字符）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"ABC\"\n<strong>输出: </strong>10\n<strong>解释:</strong> 所有可能的子串为：\"A\",\"B\",\"C\",\"AB\",\"BC\" 和 \"ABC\"。\n     其中，每一个子串都由独特字符构成。\n     所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"ABA\"\n<strong>输出: </strong>8\n<strong>解释: </strong>除<code>了 countUniqueChars</code>(\"ABA\") = 1 之外，其余与示例 1 相同。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"LEETCODE\"\n<strong>输出：</strong>92\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>s</code> 只包含大写英文字符</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 829连续整数求和",
        "hardRate": "HARD",
        "passRate": "46.25%",
        "problemsUrl": "https://leetcode.cn/problems/consecutive-numbers-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/consecutive-numbers-sum/solution",
        "problemsDesc": "<p>给定一个正整数 <code>n</code>，返回 <em>连续正整数满足所有数字之和为 <code>n</code>&nbsp;的组数</em> 。&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示</strong><strong>例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>n = 5\n<strong>输出: </strong>2\n<strong>解释: </strong>5 = 2 + 3，共有两组连续整数([5],[2,3])求和后为 5。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>n = 9\n<strong>输出: </strong>3\n<strong>解释: </strong>9 = 4 + 5 = 2 + 3 + 4</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入: </strong>n = 15\n<strong>输出: </strong>4\n<strong>解释: </strong>15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code>​​​​​​​</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 830较大分组的位置",
        "hardRate": "EASY",
        "passRate": "54.11%",
        "problemsUrl": "https://leetcode.cn/problems/positions-of-large-groups/",
        "solutionsUrl": "https://leetcode.cn/problems/positions-of-large-groups/solution",
        "problemsDesc": "<p>在一个由小写字母构成的字符串 <code>s</code> 中，包含由一些连续的相同字符所构成的分组。</p>\n\n<p>例如，在字符串 <code>s = \"abbxxxxzyy\"</code> 中，就含有 <code>\"a\"</code>, <code>\"bb\"</code>, <code>\"xxxx\"</code>, <code>\"z\"</code> 和 <code>\"yy\"</code> 这样的一些分组。</p>\n\n<p>分组可以用区间 <code>[start, end]</code> 表示，其中 <code>start</code> 和 <code>end</code> 分别表示该分组的起始和终止位置的下标。上例中的 <code>\"xxxx\"</code> 分组用区间表示为 <code>[3,6]</code> 。</p>\n\n<p>我们称所有包含大于或等于三个连续字符的分组为 <strong>较大分组</strong> 。</p>\n\n<p>找到每一个 <strong>较大分组</strong> 的区间，<strong>按起始位置下标递增顺序排序后</strong>，返回结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abbxxxxzzy\"\n<strong>输出：</strong>[[3,6]]\n<strong>解释</strong><strong>：</strong><code>\"xxxx\" 是一个起始于 3 且终止于 6 的较大分组</code>。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\"\n<strong>输出：</strong>[]\n<strong>解释：</strong>\"a\",\"b\" 和 \"c\" 均不是符合要求的较大分组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcdddeeeeaabbbcd\"\n<strong>输出：</strong>[[3,5],[6,9],[12,14]]\n<strong>解释：</strong>较大分组为 \"ddd\", \"eeee\" 和 \"bbb\"</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aba\"\n<strong>输出：</strong>[]\n</pre>\n \n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 1000</code></li>\n\t<li><code>s</code> 仅含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 831隐藏个人信息",
        "hardRate": "MEDIUM",
        "passRate": "53.78%",
        "problemsUrl": "https://leetcode.cn/problems/masking-personal-information/",
        "solutionsUrl": "https://leetcode.cn/problems/masking-personal-information/solution",
        "problemsDesc": "<p>给你一条个人信息字符串 <code>s</code> ，可能表示一个 <strong>邮箱地址</strong> ，也可能表示一串 <strong>电话号码</strong> 。返回按如下规则 <strong>隐藏</strong> 个人信息后的结果：</p>\n\n<p><em><strong>电子邮件地址：</strong></em></p>\n\n<p>一个电子邮件地址由以下部分组成：</p>\n\n<ul>\n\t<li>一个 <strong>名字</strong> ，由大小写英文字母组成，后面跟着</li>\n\t<li>一个 <code>'@'</code> 字符，后面跟着</li>\n\t<li>一个 <strong>域名</strong> ，由大小写英文字母和一个位于中间的 <code>'.'</code> 字符组成。<code>'.'</code> 不会是域名的第一个或者最后一个字符。</li>\n</ul>\n\n<p>要想隐藏电子邮件地址中的个人信息：</p>\n\n<ul>\n\t<li><strong>名字</strong> 和 <strong>域名</strong> 部分的大写英文字母应当转换成小写英文字母。</li>\n\t<li><strong>名字</strong> 中间的字母（即，除第一个和最后一个字母外）必须用 5 个 <code>\"*****\"</code> 替换。</li>\n</ul>\n\n<p><em><strong>电话号码：</strong></em></p>\n\n<p>一个电话号码应当按下述格式组成：</p>\n\n<ul>\n\t<li>电话号码可以由 10-13 位数字组成</li>\n\t<li>后 10 位构成 <strong>本地号码</strong></li>\n\t<li>前面剩下的 0-3 位，构成 <strong>国家代码</strong></li>\n\t<li>利用 <code>{'+', '-', '(', ')', ' '}</code> 这些 <strong>分隔字符</strong> 按某种形式对上述数字进行分隔</li>\n</ul>\n\n<p>要想隐藏电话号码中的个人信息：</p>\n\n<ul>\n\t<li>移除所有 <strong>分隔字符</strong></li>\n\t<li>隐藏个人信息后的电话号码应该遵从这种格式：\n\t<ul>\n\t\t<li><code>\"***-***-XXXX\"</code> 如果国家代码为 0 位数字</li>\n\t\t<li><code>\"+*-***-***-XXXX\"</code> 如果国家代码为 1 位数字</li>\n\t\t<li><code>\"+**-***-***-XXXX\"</code> 如果国家代码为 2 位数字</li>\n\t\t<li><code>\"+***-***-***-XXXX\"</code> 如果国家代码为 3 位数字</li>\n\t</ul>\n\t</li>\n\t<li><code>\"XXXX\"</code> 是最后 4 位 <strong>本地号码</strong></li>\n</ul>\n&nbsp;\n\n<div class=\"top-view__1vxA\">\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"LeetCode@LeetCode.com\"\n<strong>输出：</strong>\"l*****e@leetcode.com\"\n<strong>解释：</strong>s 是一个电子邮件地址。\n名字和域名都转换为小写，名字的中间用 5 个 * 替换。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"AB@qq.com\"\n<strong>输出：</strong>\"a*****b@qq.com\"\n<strong>解释：</strong>s 是一个电子邮件地址。\n名字和域名都转换为小写，名字的中间用 5 个 * 替换。\n注意，尽管 \"ab\" 只有两个字符，但中间仍然必须有 5 个 * 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1(234)567-890\"\n<strong>输出：</strong>\"***-***-7890\"\n<strong>解释：</strong>s 是一个电话号码。\n共计 10 位数字，所以本地号码为 10 位数字，国家代码为 0 位数字。\n因此，隐藏后的电话号码应该是 \"***-***-7890\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s</code> 是一个 <strong>有效</strong> 的电子邮件或者电话号码</li>\n\t<li>如果 <code>s</code> 是一个电子邮件：\n\t<ul>\n\t\t<li><code>8 &lt;= s.length &lt;= 40</code></li>\n\t\t<li><code>s</code> 是由大小写英文字母，恰好一个 <code>'@'</code> 字符，以及 <code>'.'</code> 字符组成</li>\n\t</ul>\n\t</li>\n\t<li>如果 <code>s</code> 是一个电话号码：\n\t<ul>\n\t\t<li><code>10 &lt;= s.length &lt;= 20</code></li>\n\t\t<li><code>s</code> 是由数字、空格、字符 <code>'('</code>、<code>')'</code>、<code>'-'</code> 和 <code>'+'</code> 组成</li>\n\t</ul>\n\t</li>\n</ul>\n</div>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 832翻转图像",
        "hardRate": "EASY",
        "passRate": "79.47%",
        "problemsUrl": "https://leetcode.cn/problems/flipping-an-image/",
        "solutionsUrl": "https://leetcode.cn/problems/flipping-an-image/solution",
        "problemsDesc": "<p>给定一个<meta charset=\"UTF-8\" />&nbsp;<code>n x n</code>&nbsp;的二进制矩阵&nbsp;<code>image</code>&nbsp;，先 <strong>水平</strong> 翻转图像，然后&nbsp;<strong>反转&nbsp;</strong>图像并返回&nbsp;<em>结果</em>&nbsp;。</p>\n\n<p><strong>水平</strong>翻转图片就是将图片的每一行都进行翻转，即逆序。</p>\n\n<ul>\n\t<li>例如，水平翻转&nbsp;<code>[1,1,0]</code>&nbsp;的结果是&nbsp;<code>[0,1,1]</code>。</li>\n</ul>\n\n<p><strong>反转</strong>图片的意思是图片中的&nbsp;<code>0</code>&nbsp;全部被&nbsp;<code>1</code>&nbsp;替换，&nbsp;<code>1</code>&nbsp;全部被&nbsp;<code>0</code>&nbsp;替换。</p>\n\n<ul>\n\t<li>例如，反转&nbsp;<code>[0,1,1]</code>&nbsp;的结果是&nbsp;<code>[1,0,0]</code>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>image = [[1,1,0],[1,0,1],[0,0,0]]\n<strong>输出：</strong>[[1,0,0],[0,1,0],[1,1,1]]\n<strong>解释：</strong>首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；\n     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\n<strong>输出：</strong>[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n<strong>解释：</strong>首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；\n     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>n == image.length</code></li>\n\t<li><code>n == image[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>images[i][j]</code>&nbsp;==&nbsp;<code>0</code>&nbsp;或&nbsp;<code>1</code>.</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 833字符串中的查找与替换",
        "hardRate": "MEDIUM",
        "passRate": "43.98%",
        "problemsUrl": "https://leetcode.cn/problems/find-and-replace-in-string/",
        "solutionsUrl": "https://leetcode.cn/problems/find-and-replace-in-string/solution",
        "problemsDesc": "<p>你会得到一个字符串 <code>s</code>&nbsp;(索引从 0 开始)，你必须对它执行 <code>k</code> 个替换操作。替换操作以三个长度均为 <code>k</code> 的并行数组给出：<code>indices</code>,&nbsp;<code>sources</code>,&nbsp;&nbsp;<code>targets</code>。</p>\n\n<p>要完成第 <code>i</code> 个替换操作:</p>\n\n<ol>\n\t<li>检查 <strong>子字符串</strong> &nbsp;<code>sources[i]</code>&nbsp;是否出现在 <strong>原字符串</strong> <code>s</code> 的索引&nbsp;<code>indices[i]</code>&nbsp;处。</li>\n\t<li>如果没有出现，&nbsp;<strong>什么也不做</strong>&nbsp;。</li>\n\t<li>如果出现，则用&nbsp;<code>targets[i]</code>&nbsp;<strong>替换</strong>&nbsp;该子字符串。</li>\n</ol>\n\n<p>例如，如果 <code>s = \"abcd\"</code>&nbsp;，&nbsp;<code>indices[i] = 0</code> ,&nbsp;<code>sources[i] = \"ab\"</code>， <code>targets[i] = \"eee\"</code> ，那么替换的结果将是 <code>\"<u>eee</u>cd\"</code> 。</p>\n\n<p>所有替换操作必须 <strong>同时</strong> 发生，这意味着替换操作不应该影响彼此的索引。测试用例保证元素间<strong>不会重叠 </strong>。</p>\n\n<ul>\n\t<li>例如，一个 <code>s = \"abc\"</code> ，&nbsp; <code>indices = [0,1]</code> ， <code>sources = [\"ab\"，\"bc\"]</code>&nbsp;的测试用例将不会生成，因为 <code>\"ab\"</code> 和 <code>\"bc\"</code> 替换重叠。</li>\n</ul>\n\n<p><em>在对 <code>s</code>&nbsp;执行所有替换操作后返回 <strong>结果字符串</strong> 。</em></p>\n\n<p><strong>子字符串</strong> 是字符串中连续的字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/12/833-ex1.png\" style=\"height: 251px; width: 411px;\" /></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\", indexes = [0,2], sources = [\"a\",\"cd\"], targets = [\"eee\",\"ffff\"]\n<strong>输出：</strong>\"eeebffff\"\n<strong>解释：\n</strong>\"a\" 从 s 中的索引 0 开始，所以它被替换为 \"eee\"。\n\"cd\" 从 s 中的索引 2 开始，所以它被替换为 \"ffff\"。\n</pre>\n\n<p><strong>示例 2：</strong><img src=\"https://assets.leetcode.com/uploads/2021/06/12/833-ex2-1.png\" style=\"height: 251px; width: 411px;\" /></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\", indexes = [0,2], sources = [\"ab\",\"ec\"], targets = [\"eee\",\"ffff\"]\n<strong>输出：</strong>\"eeecd\"\n<strong>解释：\n</strong>\"ab\" 从 s 中的索引 0 开始，所以它被替换为 \"eee\"。\n\"ec\" 没有从<strong>原始的</strong> S 中的索引 2 开始，所以它没有被替换。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>k == indices.length == sources.length == targets.length</code></li>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n\t<li><code>0 &lt;= indexes[i] &lt; s.length</code></li>\n\t<li><code>1 &lt;= sources[i].length, targets[i].length &lt;= 50</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n\t<li><code>sources[i]</code> 和 <code>targets[i]</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 834树中距离之和",
        "hardRate": "HARD",
        "passRate": "54.43%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-distances-in-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-distances-in-tree/solution",
        "problemsDesc": "<p>给定一个无向、连通的树。树中有 <code>n</code> 个标记为 <code>0...n-1</code> 的节点以及 <code>n-1</code>&nbsp;条边&nbsp;。</p>\n\n<p>给定整数 <code>n</code> 和数组&nbsp;<code>edges</code>&nbsp;，&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>表示树中的节点&nbsp;<code>a<sub>i</sub></code>&nbsp;和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条边。</p>\n\n<p>返回长度为 <code>n</code> 的数组&nbsp;<code>answer</code>&nbsp;，其中&nbsp;<code>answer[i]</code>&nbsp;是树中第 <code>i</code> 个节点与所有其他节点之间的距离之和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-sumdist1.jpg\" /></p>\n\n<pre>\n<strong>输入: </strong>n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]\n<strong>输出: </strong>[8,12,6,10,10,10]\n<strong>解释: </strong>树如图所示。\n我们可以计算出 dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) \n也就是 1 + 1 + 2 + 2 + 2 = 8。 因此，answer[0] = 8，以此类推。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-sumdist2.jpg\" />\n<pre>\n<strong>输入:</strong> n = 1, edges = []\n<strong>输出:</strong> [0]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-sumdist3.jpg\" />\n<pre>\n<strong>输入:</strong> n = 2, edges = [[1,0]]\n<strong>输出:</strong> [1,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub>&nbsp;&lt; n</code></li>\n\t<li><code>a<sub>i</sub>&nbsp;!= b<sub>i</sub></code></li>\n\t<li>给定的输入保证为有效的树</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 835图像重叠",
        "hardRate": "MEDIUM",
        "passRate": "58.26%",
        "problemsUrl": "https://leetcode.cn/problems/image-overlap/",
        "solutionsUrl": "https://leetcode.cn/problems/image-overlap/solution",
        "problemsDesc": "<p>给你两个图像 <code>img1</code> 和 <code>img2</code> ，两个图像的大小都是 <code>n x n</code> ，用大小相同的二进制正方形矩阵表示。二进制矩阵仅由若干 <code>0</code> 和若干 <code>1</code> 组成。</p>\n\n<p><strong>转换</strong> 其中一个图像，将所有的 <code>1</code> 向左，右，上，或下滑动任何数量的单位；然后把它放在另一个图像的上面。该转换的 <strong>重叠</strong> 是指两个图像 <strong>都</strong> 具有 <code>1</code> 的位置的数目。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>请注意，转换 <strong>不包括</strong> 向任何方向旋转。越过矩阵边界的 <code>1</code> 都将被清除。</p>\n\n<p>最大可能的重叠数量是多少？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/overlap1.jpg\" style=\"width: 450px; height: 231px;\" />\n<pre>\n<strong>输入：</strong>img1 = [[1,1,0],[0,1,0],[0,1,0]], img2 = [[0,0,0],[0,1,1],[0,0,1]]\n<strong>输出：</strong>3\n<strong>解释：</strong>将 img1 向右移动 1 个单位，再向下移动 1 个单位。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/overlap_step1.jpg\" style=\"width: 450px; height: 105px;\" />\n两个图像都具有 <code>1</code> 的位置的数目是 3（用红色标识）。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/overlap_step2.jpg\" style=\"width: 450px; height: 231px;\" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>img1 = [[1]], img2 = [[1]]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>img1 = [[0]], img2 = [[0]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == img1.length == img1[i].length</code></li>\n\t<li><code>n == img2.length == img2[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n\t<li><code>img1[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n\t<li><code>img2[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n</div>\n</div>\n",
        "isPlus": false
    },
    {
        "problemsName": " 836矩形重叠",
        "hardRate": "EASY",
        "passRate": "49.02%",
        "problemsUrl": "https://leetcode.cn/problems/rectangle-overlap/",
        "solutionsUrl": "https://leetcode.cn/problems/rectangle-overlap/solution",
        "problemsDesc": "<p>矩形以列表 <code>[x1, y1, x2, y2]</code> 的形式表示，其中 <code>(x1, y1)</code> 为左下角的坐标，<code>(x2, y2)</code> 是右上角的坐标。矩形的上下边平行于 x 轴，左右边平行于 y 轴。</p>\n\n<p>如果相交的面积为 <strong>正</strong> ，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</p>\n\n<p>给出两个矩形 <code>rec1</code> 和 <code>rec2</code> 。如果它们重叠，返回 <code>true</code>；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rec1 = [0,0,2,2], rec2 = [1,1,3,3]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rec1 = [0,0,1,1], rec2 = [1,0,2,1]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>rec1 = [0,0,1,1], rec2 = [2,2,3,3]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rect1.length == 4</code></li>\n\t<li><code>rect2.length == 4</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= rec1[i], rec2[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>rec1</code> 和 <code>rec2</code> 表示一个面积不为零的有效矩形</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 837新 21 点",
        "hardRate": "MEDIUM",
        "passRate": "39.74%",
        "problemsUrl": "https://leetcode.cn/problems/new-21-game/",
        "solutionsUrl": "https://leetcode.cn/problems/new-21-game/solution",
        "problemsDesc": "<p>爱丽丝参与一个大致基于纸牌游戏 <strong>“21点”</strong> 规则的游戏，描述如下：</p>\n\n<p>爱丽丝以 <code>0</code> 分开始，并在她的得分少于 <code>k</code> 分时抽取数字。 抽取时，她从 <code>[1, maxPts]</code> 的范围中随机获得一个整数作为分数进行累计，其中 <code>maxPts</code> 是一个整数。 每次抽取都是独立的，其结果具有相同的概率。</p>\n\n<p>当爱丽丝获得 <code>k</code> 分 <strong>或更多分</strong> 时，她就停止抽取数字。</p>\n\n<p>爱丽丝的分数不超过 <code>n</code> 的概率是多少？</p>\n\n<p>与实际答案误差不超过&nbsp;<code>10<sup>-5</sup></code> 的答案将被视为正确答案。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10, k = 1, maxPts = 10\n<strong>输出：</strong>1.00000\n<strong>解释：</strong>爱丽丝得到一张牌，然后停止。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6, k = 1, maxPts = 10\n<strong>输出：</strong>0.60000\n<strong>解释：</strong>爱丽丝得到一张牌，然后停止。 在 10 种可能性中的 6 种情况下，她的得分不超过 6 分。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 21, k = 17, maxPts = 10\n<strong>输出：</strong>0.73278\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= k &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= maxPts &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 838推多米诺",
        "hardRate": "MEDIUM",
        "passRate": "55.65%",
        "problemsUrl": "https://leetcode.cn/problems/push-dominoes/",
        "solutionsUrl": "https://leetcode.cn/problems/push-dominoes/solution",
        "problemsDesc": "<p><code>n</code> 张多米诺骨牌排成一行，将每张多米诺骨牌垂直竖立。在开始时，同时把一些多米诺骨牌向左或向右推。</p>\n\n<p>每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。</p>\n\n<p>如果一张垂直竖立的多米诺骨牌的两侧同时有多米诺骨牌倒下时，由于受力平衡， 该骨牌仍然保持不变。</p>\n\n<p>就这个问题而言，我们会认为一张正在倒下的多米诺骨牌不会对其它正在倒下或已经倒下的多米诺骨牌施加额外的力。</p>\n\n<p>给你一个字符串 <code>dominoes</code> 表示这一行多米诺骨牌的初始状态，其中：</p>\n\n<ul>\n\t<li><code>dominoes[i] = 'L'</code>，表示第 <code>i</code> 张多米诺骨牌被推向左侧，</li>\n\t<li><code>dominoes[i] = 'R'</code>，表示第 <code>i</code> 张多米诺骨牌被推向右侧，</li>\n\t<li><code>dominoes[i] = '.'</code>，表示没有推动第 <code>i</code> 张多米诺骨牌。</li>\n</ul>\n\n<p>返回表示最终状态的字符串。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>dominoes = \"RR.L\"\n<strong>输出：</strong>\"RR.L\"\n<strong>解释：</strong>第一张多米诺骨牌没有给第二张施加额外的力。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/05/18/domino.png\" style=\"height: 196px; width: 512px;\" />\n<pre>\n<strong>输入：</strong>dominoes = \".L.R...LR..L..\"\n<strong>输出：</strong>\"LL.RR.LLRRLL..\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == dominoes.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>dominoes[i]</code> 为 <code>'L'</code>、<code>'R'</code> 或 <code>'.'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 839相似字符串组",
        "hardRate": "HARD",
        "passRate": "58.85%",
        "problemsUrl": "https://leetcode.cn/problems/similar-string-groups/",
        "solutionsUrl": "https://leetcode.cn/problems/similar-string-groups/solution",
        "problemsDesc": "<p>如果交换字符串&nbsp;<code>X</code> 中的两个不同位置的字母，使得它和字符串&nbsp;<code>Y</code> 相等，那么称 <code>X</code> 和 <code>Y</code> 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。</p>\n\n<p>例如，<code>\"tars\"</code> 和 <code>\"rats\"</code> 是相似的 (交换 <code>0</code> 与 <code>2</code> 的位置)；&nbsp;<code>\"rats\"</code> 和 <code>\"arts\"</code> 也是相似的，但是 <code>\"star\"</code> 不与 <code>\"tars\"</code>，<code>\"rats\"</code>，或 <code>\"arts\"</code> 相似。</p>\n\n<p>总之，它们通过相似性形成了两个关联组：<code>{\"tars\", \"rats\", \"arts\"}</code> 和 <code>{\"star\"}</code>。注意，<code>\"tars\"</code> 和 <code>\"arts\"</code> 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。</p>\n\n<p>给你一个字符串列表 <code>strs</code>。列表中的每个字符串都是 <code>strs</code> 中其它所有字符串的一个字母异位词。请问 <code>strs</code> 中有多少个相似字符串组？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"tars\",\"rats\",\"arts\",\"star\"]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"omv\",\"ovm\"]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= strs[i].length &lt;= 300</code></li>\n\t<li><code>strs[i]</code> 只包含小写字母。</li>\n\t<li><code>strs</code> 中的所有单词都具有相同的长度，且是彼此的字母异位词。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 840矩阵中的幻方",
        "hardRate": "MEDIUM",
        "passRate": "36.62%",
        "problemsUrl": "https://leetcode.cn/problems/magic-squares-in-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/magic-squares-in-grid/solution",
        "problemsDesc": "<p><code>3 x 3</code> 的幻方是一个填充有&nbsp;<strong>从 <code>1</code> 到 <code>9</code>&nbsp;</strong> 的不同数字的 <code>3 x 3</code> 矩阵，其中每行，每列以及两条对角线上的各数之和都相等。</p>\n\n<p>给定一个由整数组成的<code>row x col</code>&nbsp;的 <code>grid</code>，其中有多少个&nbsp;<code>3 × 3</code> 的 “幻方” 子矩阵？（每个子矩阵都是连续的）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/11/magic_main.jpg\" /></p>\n\n<pre>\n<strong>输入: </strong>grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]\n<strong>输出: </strong>1\n<strong>解释: </strong>\n下面的子矩阵是一个 3 x 3 的幻方：\n<img src=\"https://assets.leetcode.com/uploads/2020/09/11/magic_valid.jpg\" />\n而这一个不是：\n<img src=\"https://assets.leetcode.com/uploads/2020/09/11/magic_invalid.jpg\" />\n总的来说，在本示例所给定的矩阵中只有一个 3 x 3 的幻方子矩阵。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输出:</strong> grid = [[8]]\n<strong>输入:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>row == grid.length</code></li>\n\t<li><code>col == grid[i].length</code></li>\n\t<li><code>1 &lt;= row, col &lt;= 10</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 15</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 841钥匙和房间",
        "hardRate": "MEDIUM",
        "passRate": "67.94%",
        "problemsUrl": "https://leetcode.cn/problems/keys-and-rooms/",
        "solutionsUrl": "https://leetcode.cn/problems/keys-and-rooms/solution",
        "problemsDesc": "<p>有 <code>n</code> 个房间，房间按从 <code>0</code> 到 <code>n - 1</code> 编号。最初，除 <code>0</code> 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。</p>\n\n<p>当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。</p>\n\n<p>给你一个数组 <code>rooms</code> 其中 <code>rooms[i]</code> 是你进入 <code>i</code> 号房间可以获得的钥匙集合。如果能进入 <strong>所有</strong> 房间返回 <code>true</code>，否则返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rooms = [[1],[2],[3],[]]\n<strong>输出：</strong>true\n<strong>解释：</strong>\n我们从 0 号房间开始，拿到钥匙 1。\n之后我们去 1 号房间，拿到钥匙 2。\n然后我们去 2 号房间，拿到钥匙 3。\n最后我们去了 3 号房间。\n由于我们能够进入每个房间，我们返回 true。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rooms = [[1,3],[3,0,1],[2],[0]]\n<strong>输出：</strong>false\n<strong>解释：</strong>我们不能进入 2 号房间。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == rooms.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= sum(rooms[i].length) &lt;= 3000</code></li>\n\t<li><code>0 &lt;= rooms[i][j] &lt; n</code></li>\n\t<li>所有 <code>rooms[i]</code> 的值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 842将数组拆分成斐波那契序列",
        "hardRate": "MEDIUM",
        "passRate": "48.30%",
        "problemsUrl": "https://leetcode.cn/problems/split-array-into-fibonacci-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/split-array-into-fibonacci-sequence/solution",
        "problemsDesc": "<p>给定一个数字字符串 <code>num</code>，比如 <code>\"123456579\"</code>，我们可以将它分成「斐波那契式」的序列 <code>[123, 456, 579]</code>。</p>\n\n<p>形式上，<strong>斐波那契式&nbsp;</strong>序列是一个非负整数列表 <code>f</code>，且满足：</p>\n\n<ul>\n\t<li><code>0 &lt;= f[i] &lt; 2<sup>31</sup></code>&nbsp;，（也就是说，每个整数都符合 <strong>32 位</strong>&nbsp;有符号整数类型）</li>\n\t<li><code>f.length &gt;= 3</code></li>\n\t<li>对于所有的<code>0 &lt;= i &lt; f.length - 2</code>，都有 <code>f[i] + f[i + 1] = f[i + 2]</code></li>\n</ul>\n\n<p>另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 <code>0</code> 本身。</p>\n\n<p>返回从 <code>num</code> 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 <code>[]</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"1101111\"\n<strong>输出：</strong>[11,0,11,11]\n<strong>解释：</strong>输出[110,1,111]也可以。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>num = \"112358130\"\n<strong>输出: </strong>[]\n<strong>解释: </strong>无法拆分。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>\"0123\"\n<strong>输出：</strong>[]\n<strong>解释：</strong>每个块的数字不能以零开头，因此 \"01\"，\"2\"，\"3\" 不是有效答案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 200</code></li>\n\t<li><code>num</code>&nbsp;中只含有数字</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 843猜猜这个单词",
        "hardRate": "HARD",
        "passRate": "36.70%",
        "problemsUrl": "https://leetcode.cn/problems/guess-the-word/",
        "solutionsUrl": "https://leetcode.cn/problems/guess-the-word/solution",
        "problemsDesc": "<p>给你一个由 <strong>不同</strong> 字符串组成的单词列表&nbsp;<code>words</code> ，其中 <code>words[i]</code>&nbsp;长度均为&nbsp;<code>6</code> 。<code>words</code> 中的一个单词将被选作秘密单词 <code>secret</code>&nbsp;。</p>\n\n<p>另给你一个辅助对象&nbsp;<code>Master</code> ，你可以调用&nbsp;<code>Master.guess(word)</code> 来猜单词，其中参数 <code>word</code> 长度为 6 且必须是 <code>words</code> 中的字符串。</p>\n\n<p><code>Master.guess(word)</code> 将会返回如下结果：</p>\n\n<ul>\n\t<li>如果 <code>word</code> 不是 <code>words</code> 中的字符串，返回 <code>-1</code> ，或者</li>\n\t<li>一个整数，表示你所猜测的单词 <code>word</code> 与 <strong>秘密单词</strong>&nbsp;<code>secret</code>&nbsp;的准确匹配（值和位置同时匹配）的数目。</li>\n</ul>\n\n<p>每组测试用例都会包含一个参数 <code>allowedGuesses</code> ，其中 <code>allowedGuesses</code> 是你可以调用 <code>Master.guess(word)</code> 的最大次数。</p>\n\n<p>对于每组测试用例，在不超过允许猜测的次数的前提下，你应该调用 <code>Master.guess</code> 来猜出秘密单词。最终，你将会得到以下结果：</p>\n\n<ul>\n\t<li>如果你调用 <code>Master.guess</code> 的次数大于 <code>allowedGuesses</code> 所限定的次数或者你没有用 <code>Master.guess</code> 猜到秘密单词，则得到 <strong><code>\"Either you took too many guesses, or you did not find the secret word.\"</code> 。</strong></li>\n\t<li>如果你调用 <code>Master.guess</code> 猜到秘密单词，且调用 <code>Master.guess</code> 的次数小于或等于 <code>allowedGuesses</code> ，则得到 <strong><code>\"You guessed the secret word correctly.\"</code> 。</strong></li>\n</ul>\n\n<p>生成的测试用例保证你可以利用某种合理的策略（而不是暴力）猜到秘密单词。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>secret = \"acckzz\", words = [\"acckzz\",\"ccbazz\",\"eiowzz\",\"abcczz\"], allowedGuesses = 10\n<strong>输出：</strong>You guessed the secret word correctly.\n<strong>解释：</strong>\nmaster.guess(\"aaaaaa\") 返回 -1 ，因为 \"aaaaaa\" 不在 words 中。\nmaster.guess(\"acckzz\") 返回 6 ，因为 \"acckzz\" 是秘密单词 secret ，共有 6 个字母匹配。\nmaster.guess(\"ccbazz\") 返回 3 ，因为 \"ccbazz\" 共有 3 个字母匹配。\nmaster.guess(\"eiowzz\") 返回 2 ，因为 \"eiowzz\" 共有 2 个字母匹配。\nmaster.guess(\"abcczz\") 返回 4 ，因为 \"abcczz\" 共有 4 个字母匹配。\n一共调用 5 次 master.guess ，其中一个为秘密单词，所以通过测试用例。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>secret = \"hamada\", words = [\"hamada\",\"khaled\"], allowedGuesses = 10\n<strong>输出：</strong>You guessed the secret word correctly.\n<strong>解释：</strong>共有 2 个单词，且其中一个为秘密单词，可以通过测试用例。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>words[i].length == 6</code></li>\n\t<li><code>words[i]</code> 仅由小写英文字母组成</li>\n\t<li><code>words</code> 中所有字符串 <strong>互不相同</strong></li>\n\t<li><code>secret</code> 存在于 <code>words</code> 中</li>\n\t<li><code>10 &lt;= allowedGuesses &lt;= 30</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 844比较含退格的字符串",
        "hardRate": "EASY",
        "passRate": "47.89%",
        "problemsUrl": "https://leetcode.cn/problems/backspace-string-compare/",
        "solutionsUrl": "https://leetcode.cn/problems/backspace-string-compare/solution",
        "problemsDesc": "<p>给定 <code>s</code> 和 <code>t</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 <code>true</code> 。<code>#</code> 代表退格字符。</p>\n\n<p><strong>注意：</strong>如果对空文本输入退格字符，文本继续为空。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ab#c\", t = \"ad#c\"\n<strong>输出：</strong>true\n<strong>解释：</strong>s 和 t 都会变成 \"ac\"。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ab##\", t = \"c#d#\"\n<strong>输出：</strong>true\n<strong>解释：</strong>s 和 t 都会变成 \"\"。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a#c\", t = \"b\"\n<strong>输出：</strong>false\n<strong>解释：</strong>s 会变成 \"c\"，但 t 仍然是 \"b\"。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 200</code></li>\n\t<li><code>s</code> 和 <code>t</code> 只含有小写字母以及字符 <code>'#'</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你可以用 <code>O(n)</code> 的时间复杂度和 <code>O(1)</code> 的空间复杂度解决该问题吗？</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 845数组中的最长山脉",
        "hardRate": "MEDIUM",
        "passRate": "42.31%",
        "problemsUrl": "https://leetcode.cn/problems/longest-mountain-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-mountain-in-array/solution",
        "problemsDesc": "<p>把符合下列属性的数组 <code>arr</code> 称为 <strong>山脉数组</strong> ：</p>\n\n<ul>\n\t<li><code>arr.length &gt;= 3</code></li>\n\t<li>存在下标 <code>i</code>（<code>0 &lt; i &lt; arr.length - 1</code>），满足\n\t<ul>\n\t\t<li><code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]</code></li>\n\t\t<li><code>arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>给出一个整数数组 <code>arr</code>，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [2,1,4,7,3,2,5]\n<strong>输出：</strong>5\n<strong>解释：</strong>最长的山脉子数组是 [1,4,7,3,2]，长度为 5。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [2,2,2]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在山脉子数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你可以仅用一趟扫描解决此问题吗？</li>\n\t<li>你可以用 <code>O(1)</code> 空间解决此问题吗？</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 846一手顺子",
        "hardRate": "MEDIUM",
        "passRate": "57.24%",
        "problemsUrl": "https://leetcode.cn/problems/hand-of-straights/",
        "solutionsUrl": "https://leetcode.cn/problems/hand-of-straights/solution",
        "problemsDesc": "<p>Alice 手中有一把牌，她想要重新排列这些牌，分成若干组，使每一组的牌数都是 <code>groupSize</code> ，并且由 <code>groupSize</code> 张连续的牌组成。</p>\n\n<p>给你一个整数数组 <code>hand</code> 其中 <code>hand[i]</code> 是写在第 <code>i</code> 张牌上的<strong>数值</strong>。如果她可能重新排列这些牌，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>hand = [1,2,3,6,2,3,4,7,8], groupSize = 3\n<strong>输出：</strong>true\n<strong>解释：</strong>Alice 手中的牌可以被重新排列为 <code>[1,2,3]，[2,3,4]，[6,7,8]</code>。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>hand = [1,2,3,4,5], groupSize = 4\n<strong>输出：</strong>false\n<strong>解释：</strong>Alice 手中的牌无法被重新排列成几个大小为 4 的组。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= hand.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= hand[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= groupSize &lt;= hand.length</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>此题目与 1296 重复：<a href=\"https://leetcode-cn.com/problems/divide-array-in-sets-of-k-consecutive-numbers/\" target=\"_blank\">https://leetcode-cn.com/problems/divide-array-in-sets-of-k-consecutive-numbers/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 847访问所有节点的最短路径",
        "hardRate": "HARD",
        "passRate": "67.56%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-path-visiting-all-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-path-visiting-all-nodes/solution",
        "problemsDesc": "<p>存在一个由 <code>n</code> 个节点组成的无向连通图，图中的节点按从 <code>0</code> 到 <code>n - 1</code> 编号。</p>\n\n<p>给你一个数组 <code>graph</code> 表示这个图。其中，<code>graph[i]</code> 是一个列表，由所有与节点 <code>i</code> 直接相连的节点组成。</p>\n\n<p>返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/12/shortest1-graph.jpg\" style=\"width: 222px; height: 183px;\" />\n<pre>\n<strong>输入：</strong>graph = [[1,2,3],[0],[0],[0]]\n<strong>输出：</strong>4\n<strong>解释：</strong>一种可能的路径为 [1,0,2,0,3]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/12/shortest2-graph.jpg\" style=\"width: 382px; height: 222px;\" /></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]\n<strong>输出：</strong>4\n<strong>解释：</strong>一种可能的路径为 [0,1,4,2,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == graph.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 12</code></li>\n\t<li><code>0 &lt;= graph[i].length &lt;&nbsp;n</code></li>\n\t<li><code>graph[i]</code> 不包含 <code>i</code></li>\n\t<li>如果 <code>graph[a]</code> 包含 <code>b</code> ，那么 <code>graph[b]</code> 也包含 <code>a</code></li>\n\t<li>输入的图总是连通图</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 848字母移位",
        "hardRate": "MEDIUM",
        "passRate": "46.19%",
        "problemsUrl": "https://leetcode.cn/problems/shifting-letters/",
        "solutionsUrl": "https://leetcode.cn/problems/shifting-letters/solution",
        "problemsDesc": "<p>有一个由小写字母组成的字符串 <code>s</code>，和一个长度相同的整数数组 <code>shifts</code>。</p>\n\n<p>我们将字母表中的下一个字母称为原字母的 <em>移位</em>&nbsp;<code>shift()</code>&nbsp;（由于字母表是环绕的， <code>'z'</code>&nbsp;将会变成&nbsp;<code>'a'</code>）。</p>\n\n<ul>\n\t<li>例如，<code>shift('a') = 'b'<font color=\"#333333\"><font face=\"Helvetica Neue, Helvetica, Arial, sans-serif\"><span style=\"font-size:14px\"><span style=\"background-color:#ffffff\">,&nbsp;</span></span></font></font></code><code>shift('t') = 'u'</code>,&nbsp;以及&nbsp;<code>shift('z') = 'a'</code>。</li>\n</ul>\n\n<p>对于每个&nbsp;<code>shifts[i] = x</code>&nbsp;， 我们会将 <code>s</code>&nbsp;中的前&nbsp;<code>i + 1</code>&nbsp;个字母移位&nbsp;<code>x</code>&nbsp;次。</p>\n\n<p>返回 <em>将所有这些移位都应用到 <code>s</code> 后最终得到的字符串</em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\", shifts = [3,5,9]\n<strong>输出：</strong>\"rpl\"\n<strong>解释： </strong>\n我们以 \"abc\" 开始。\n将 S 中的第 1 个字母移位 3 次后，我们得到 \"dbc\"。\n再将 S 中的前 2 个字母移位 5 次后，我们得到 \"igc\"。\n最后将 S 中的这 3 个字母移位 9 次后，我们得到答案 \"rpl\"。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"aaa\", shifts = [1,2,3]\n<strong>输出:</strong> \"gfd\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;由小写英文字母组成</li>\n\t<li><code>shifts.length == s.length</code></li>\n\t<li><code>0 &lt;= shifts[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n<span style=\"display:block\"><span style=\"height:0px\"><span style=\"position:absolute\">​​​​​​</span></span></span>",
        "isPlus": false
    },
    {
        "problemsName": " 849到最近的人的最大距离",
        "hardRate": "MEDIUM",
        "passRate": "44.15%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-distance-to-closest-person/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-distance-to-closest-person/solution",
        "problemsDesc": "<p>给你一个数组 <code>seats</code> 表示一排座位，其中 <code>seats[i] = 1</code> 代表有人坐在第 <code>i</code> 个座位上，<code>seats[i] = 0</code> 代表座位 <code>i</code> 上是空的（<strong>下标从 0 开始</strong>）。</p>\n\n<p>至少有一个空座位，且至少有一人已经坐在座位上。</p>\n\n<p>亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。</p>\n\n<p>返回他到离他最近的人的最大距离。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/10/distance.jpg\" style=\"width: 650px; height: 257px;\" />\n<pre>\n<strong>输入：</strong>seats = [1,0,0,0,1,0,1]\n<strong>输出：</strong>2\n<strong>解释：\n</strong>如果亚历克斯坐在第二个空位（seats[2]）上，他到离他最近的人的距离为 2 。\n如果亚历克斯坐在其它任何一个空位上，他到离他最近的人的距离为 1 。\n因此，他到离他最近的人的最大距离是 2 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>seats = [1,0,0,0]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n如果亚历克斯坐在最后一个座位上，他离最近的人有 3 个座位远。\n这是可能的最大距离，所以答案是 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>seats = [0,1]\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= seats.length <= 2 * 10<sup>4</sup></code></li>\n\t<li><code>seats[i]</code> 为 <code>0</code> 或 <code>1</code></li>\n\t<li>至少有一个 <strong>空座位</strong></li>\n\t<li>至少有一个 <strong>座位上有人</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 850矩形面积 II",
        "hardRate": "HARD",
        "passRate": "62.91%",
        "problemsUrl": "https://leetcode.cn/problems/rectangle-area-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/rectangle-area-ii/solution",
        "problemsDesc": "<p>给你一个轴对齐的二维数组&nbsp;<code>rectangles</code>&nbsp;。 对于&nbsp;<code>rectangle[i] = [x1, y1, x2, y2]</code>，其中（x1，y1）是矩形&nbsp;<code>i</code>&nbsp;左下角的坐标，<meta charset=\"UTF-8\" />&nbsp;<code>(x<sub>i1</sub>, y<sub>i1</sub>)</code>&nbsp;是该矩形 <strong>左下角</strong> 的坐标，<meta charset=\"UTF-8\" />&nbsp;<code>(x<sub>i2</sub>, y<sub>i2</sub>)</code>&nbsp;是该矩形&nbsp;<strong>右上角</strong> 的坐标。</p>\n\n<p>计算平面中所有&nbsp;<code>rectangles</code>&nbsp;所覆盖的 <strong>总面积 </strong>。任何被两个或多个矩形覆盖的区域应只计算 <strong>一次</strong> 。</p>\n\n<p>返回<em> <strong>总面积</strong> </em>。因为答案可能太大，返回<meta charset=\"UTF-8\" />&nbsp;<code>10<sup>9</sup>&nbsp;+ 7</code> 的&nbsp;<strong>模</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/06/rectangle_area_ii_pic.png\" style=\"height: 360px; width: 480px;\" /></p>\n\n<pre>\n<strong>输入：</strong>rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]\n<strong>输出：</strong>6\n<strong>解释：</strong>如图所示，三个矩形覆盖了总面积为 6 的区域。\n从(1,1)到(2,2)，绿色矩形和红色矩形重叠。\n从(1,0)到(2,3)，三个矩形都重叠。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rectangles = [[0,0,1000000000,1000000000]]\n<strong>输出：</strong>49\n<strong>解释：</strong>答案是 10<sup>18</sup> 对 (10<sup>9</sup> + 7) 取模的结果， 即 49 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rectangles.length &lt;= 200</code></li>\n\t<li><code>rectanges[i].length = 4</code><meta charset=\"UTF-8\" /></li>\n\t<li><code>0 &lt;= x<sub>i1</sub>, y<sub>i1</sub>, x<sub>i2</sub>, y<sub>i2</sub>&nbsp;&lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 851喧闹和富有",
        "hardRate": "MEDIUM",
        "passRate": "63.09%",
        "problemsUrl": "https://leetcode.cn/problems/loud-and-rich/",
        "solutionsUrl": "https://leetcode.cn/problems/loud-and-rich/solution",
        "problemsDesc": "<p>有一组 <code>n</code> 个人作为实验对象，从 <code>0</code> 到 <code>n - 1</code> 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为&nbsp;<code>x</code>&nbsp;的人简称为 \"person&nbsp;<code>x</code>&nbsp;\"。</p>\n\n<p>给你一个数组 <code>richer</code> ，其中 <code>richer[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示 person&nbsp;<code>a<sub>i</sub></code>&nbsp;比 person&nbsp;<code>b<sub>i</sub></code>&nbsp;更有钱。另给你一个整数数组 <code>quiet</code> ，其中&nbsp;<code>quiet[i]</code> 是 person <code>i</code> 的安静值。<code>richer</code> 中所给出的数据 <strong>逻辑自洽</strong>（也就是说，在 person <code>x</code> 比 person <code>y</code> 更有钱的同时，不会出现 person <code>y</code> 比 person <code>x</code> 更有钱的情况 ）。</p>\n\n<p>现在，返回一个整数数组 <code>answer</code> 作为答案，其中&nbsp;<code>answer[x] = y</code>&nbsp;的前提是，在所有拥有的钱肯定不少于&nbsp;person&nbsp;<code>x</code>&nbsp;的人中，person&nbsp;<code>y</code>&nbsp;是最安静的人（也就是安静值&nbsp;<code>quiet[y]</code>&nbsp;最小的人）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\n<strong>输出：</strong>[5,5,2,5,4,5,6,7]\n<strong>解释： </strong>\nanswer[0] = 5，\nperson 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。\n唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7，\n但是目前还不清楚他是否比 person 0 更有钱。\nanswer[7] = 7，\n在所有拥有的钱肯定不少于 person 7 的人中（这可能包括 person 3，4，5，6 以及 7），\n最安静（有较低安静值 quiet[x]）的人是 person 7。\n其他的答案也可以用类似的推理来解释。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>richer = [], quiet = [0]\n<strong>输出：</strong>[0]\n</pre>\n&nbsp;\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == quiet.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>0 &lt;= quiet[i] &lt; n</code></li>\n\t<li><code>quiet</code> 的所有值 <strong>互不相同</strong></li>\n\t<li><code>0 &lt;= richer.length &lt;= n * (n - 1) / 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i </sub>!= b<sub>i</sub></code></li>\n\t<li><code>richer</code> 中的所有数对 <strong>互不相同</strong></li>\n\t<li>对<strong> </strong><code>richer</code> 的观察在逻辑上是一致的</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 852山脉数组的峰顶索引",
        "hardRate": "MEDIUM",
        "passRate": "68.65%",
        "problemsUrl": "https://leetcode.cn/problems/peak-index-in-a-mountain-array/",
        "solutionsUrl": "https://leetcode.cn/problems/peak-index-in-a-mountain-array/solution",
        "problemsDesc": "符合下列属性的数组 <code>arr</code> 称为 <strong>山脉数组</strong> ：\n<ul>\n\t<li><code>arr.length &gt;= 3</code></li>\n\t<li>存在 <code>i</code>（<code>0 &lt; i&nbsp;&lt; arr.length - 1</code>）使得：\n\t<ul>\n\t\t<li><code>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] </code></li>\n\t\t<li><code>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>给你由整数组成的山脉数组 <code>arr</code> ，返回满足 <code>arr[0] &lt; arr[1] &lt; ... arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code> 的下标 <code>i</code> 。</p>\n\n<p>你必须设计并实现时间复杂度为 <code>O(log(n))</code> 的解决方案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,1,0]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,2,1,0]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,10,5,2]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10<sup>6</sup></code></li>\n\t<li>题目数据保证 <code>arr</code> 是一个山脉数组</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 853车队",
        "hardRate": "MEDIUM",
        "passRate": "41.37%",
        "problemsUrl": "https://leetcode.cn/problems/car-fleet/",
        "solutionsUrl": "https://leetcode.cn/problems/car-fleet/solution",
        "problemsDesc": "<p>在一条单行道上，有 <code>n</code> 辆车开往同一目的地。目的地是几英里以外的&nbsp;<code>target</code>&nbsp;。</p>\n\n<p>给定两个整数数组&nbsp;<code>position</code>&nbsp;和&nbsp;<code>speed</code>&nbsp;，长度都是 <code>n</code> ，其中&nbsp;<code>position[i]</code>&nbsp;是第 <code>i</code> 辆车的位置，&nbsp;<code>speed[i]</code>&nbsp;是第 <code>i</code> 辆车的速度(单位是英里/小时)。</p>\n\n<p>一辆车永远不会超过前面的另一辆车，但它可以追上去，并与前车 <strong>以相同的速度</strong> 紧接着行驶。此时，我们会忽略这两辆车之间的距离，也就是说，它们被假定处于相同的位置。</p>\n\n<p><strong>车队</strong><em>&nbsp;</em>是一些由行驶在相同位置、具有相同速度的车组成的非空集合。注意，一辆车也可以是一个车队。</p>\n\n<p>即便一辆车在目的地才赶上了一个车队，它们仍然会被视作是同一个车队。</p>\n\n<p>返回到达目的地的 <strong>车队数量</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n从 10 和 8 开始的车会组成一个车队，它们在 12 处相遇。\n从 0 处开始的车无法追上其它车，所以它自己就是一个车队。\n从 5 和 3 开始的车会组成一个车队，它们在 6 处相遇。\n请注意，在到达目的地之前没有其它车会遇到这些车队，所以答案是 3。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> target = 10, position = [3], speed = [3]\n<strong>输出:</strong> 1\n<strong>解释:</strong> 只有一辆车，因此只有一个车队。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> target = 100, position = [0,2,4], speed = [4,2,1]\n<strong>输出:</strong> 1\n<strong>解释:</strong>\n以0(速度4)和2(速度2)出发的车辆组成车队，在4点相遇。舰队以2的速度前进。\n然后，车队(速度2)和以4(速度1)出发的汽车组成一个车队，在6点相遇。舰队以1的速度前进，直到到达目标。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == position.length == speed.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt; target &lt;= 10<sup>6</sup></code></li>\n\t<li><code>0 &lt;= position[i] &lt; target</code></li>\n\t<li><code>position</code>&nbsp;中每个值都 <strong>不同</strong></li>\n\t<li><code>0 &lt; speed[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 854相似度为 K 的字符串",
        "hardRate": "HARD",
        "passRate": "46.77%",
        "problemsUrl": "https://leetcode.cn/problems/k-similar-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/k-similar-strings/solution",
        "problemsDesc": "<p>对于某些非负整数 <code>k</code> ，如果交换 <code>s1</code> 中两个字母的位置恰好 <code>k</code> 次，能够使结果字符串等于 <code>s2</code> ，则认为字符串 <code>s1</code> 和 <code>s2</code> 的<strong> 相似度为 </strong><code>k</code><strong> </strong><strong>。</strong></p>\n\n<p>给你两个字母异位词 <code>s1</code> 和 <code>s2</code> ，返回 <code>s1</code> 和 <code>s2</code> 的相似度 <code>k</code><strong> </strong>的最小值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"ab\", s2 = \"ba\"\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"abc\", s2 = \"bca\"\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length &lt;= 20</code></li>\n\t<li><code>s2.length == s1.length</code></li>\n\t<li><code>s1</code>&nbsp;和&nbsp;<code>s2</code>&nbsp;&nbsp;只包含集合&nbsp;<code>{'a', 'b', 'c', 'd', 'e', 'f'}</code>&nbsp;中的小写字母</li>\n\t<li><code>s2</code> 是 <code>s1</code> 的一个字母异位词</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 855考场就座",
        "hardRate": "MEDIUM",
        "passRate": "47.70%",
        "problemsUrl": "https://leetcode.cn/problems/exam-room/",
        "solutionsUrl": "https://leetcode.cn/problems/exam-room/solution",
        "problemsDesc": "<p>在考场里，一排有&nbsp;<code>N</code>&nbsp;个座位，分别编号为&nbsp;<code>0, 1, 2, ..., N-1</code>&nbsp;。</p>\n\n<p>当学生进入考场后，他必须坐在能够使他与离他最近的人之间的距离达到最大化的座位上。如果有多个这样的座位，他会坐在编号最小的座位上。(另外，如果考场里没有人，那么学生就坐在 0 号座位上。)</p>\n\n<p>返回&nbsp;<code>ExamRoom(int N)</code>&nbsp;类，它有两个公开的函数：其中，函数&nbsp;<code>ExamRoom.seat()</code>&nbsp;会返回一个&nbsp;<code>int</code>&nbsp;（整型数据），代表学生坐的位置；函数&nbsp;<code>ExamRoom.leave(int p)</code>&nbsp;代表坐在座位 <code>p</code> 上的学生现在离开了考场。每次调用&nbsp;<code>ExamRoom.leave(p)</code>&nbsp;时都保证有学生坐在座位&nbsp;<code>p</code>&nbsp;上。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>[&quot;ExamRoom&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;leave&quot;,&quot;seat&quot;], [[10],[],[],[],[],[4],[]]\n<strong>输出：</strong>[null,0,9,4,2,null,5]\n<strong>解释：</strong>\nExamRoom(10) -&gt; null\nseat() -&gt; 0，没有人在考场里，那么学生坐在 0 号座位上。\nseat() -&gt; 9，学生最后坐在 9 号座位上。\nseat() -&gt; 4，学生最后坐在 4 号座位上。\nseat() -&gt; 2，学生最后坐在 2 号座位上。\nleave(4) -&gt; null\nseat() -&gt; 5，学生最后坐在 5 号座位上。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= N &lt;= 10^9</code></li>\n\t<li>在所有的测试样例中&nbsp;<code>ExamRoom.seat()</code>&nbsp;和&nbsp;<code>ExamRoom.leave()</code>&nbsp;最多被调用&nbsp;<code>10^4</code>&nbsp;次。</li>\n\t<li>保证在调用&nbsp;<code>ExamRoom.leave(p)</code>&nbsp;时有学生正坐在座位 <code>p</code> 上。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 856括号的分数",
        "hardRate": "MEDIUM",
        "passRate": "68.43%",
        "problemsUrl": "https://leetcode.cn/problems/score-of-parentheses/",
        "solutionsUrl": "https://leetcode.cn/problems/score-of-parentheses/solution",
        "problemsDesc": "<p>给定一个平衡括号字符串&nbsp;<code>S</code>，按下述规则计算该字符串的分数：</p>\n\n<ul>\n\t<li><code>()</code> 得 1 分。</li>\n\t<li><code>AB</code> 得&nbsp;<code>A + B</code>&nbsp;分，其中 A 和 B 是平衡括号字符串。</li>\n\t<li><code>(A)</code> 得&nbsp;<code>2 * A</code>&nbsp;分，其中 A 是平衡括号字符串。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入： </strong>&quot;()&quot;\n<strong>输出： </strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入： </strong>&quot;(())&quot;\n<strong>输出： </strong>2\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre><strong>输入： </strong>&quot;()()&quot;\n<strong>输出： </strong>2\n</pre>\n\n<p><strong>示例&nbsp;4：</strong></p>\n\n<pre><strong>输入： </strong>&quot;(()(()))&quot;\n<strong>输出： </strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>S</code>&nbsp;是平衡括号字符串，且只含有&nbsp;<code>(</code>&nbsp;和&nbsp;<code>)</code>&nbsp;。</li>\n\t<li><code>2 &lt;= S.length &lt;= 50</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 857雇佣 K 名工人的最低成本",
        "hardRate": "HARD",
        "passRate": "63.58%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/solution",
        "problemsDesc": "<p>有 <code>n</code>&nbsp;名工人。&nbsp;给定两个数组&nbsp;<code>quality</code>&nbsp;和&nbsp;<code>wage</code>&nbsp;，其中，<code>quality[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;名工人的工作质量，其最低期望工资为&nbsp;<code>wage[i]</code>&nbsp;。</p>\n\n<p>现在我们想雇佣&nbsp;<code>k</code>&nbsp;名工人组成一个<em>工资组。</em>在雇佣&nbsp;一组 <code>k</code>&nbsp;名工人时，我们必须按照下述规则向他们支付工资：</p>\n\n<ol>\n\t<li>对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。</li>\n\t<li>工资组中的每名工人至少应当得到他们的最低期望工资。</li>\n</ol>\n\n<p>给定整数 <code>k</code> ，返回 <em>组成满足上述条件的付费群体所需的最小金额&nbsp;</em>。在实际答案的&nbsp;<code>10<sup>-5</sup></code>&nbsp;以内的答案将被接受。。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入： </strong>quality = [10,20,5], wage = [70,50,30], k = 2\n<strong>输出： </strong>105.00000\n<strong>解释：</strong> 我们向 0 号工人支付 70，向 2 号工人支付 35。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入： </strong>quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3\n<strong>输出： </strong>30.66667\n<strong>解释： </strong>我们向 0 号工人支付 4，向 2 号和 3 号分别支付 13.33333。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == quality.length == wage.length</code></li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= quality[i], wage[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 858镜面反射",
        "hardRate": "MEDIUM",
        "passRate": "57.47%",
        "problemsUrl": "https://leetcode.cn/problems/mirror-reflection/",
        "solutionsUrl": "https://leetcode.cn/problems/mirror-reflection/solution",
        "problemsDesc": "<p>有一个特殊的正方形房间，每面墙上都有一面镜子。除西南角以外，每个角落都放有一个接受器，编号为&nbsp;<code>0</code>，&nbsp;<code>1</code>，以及&nbsp;<code>2</code>。</p>\n\n<p>正方形房间的墙壁长度为&nbsp;<code>p</code>，一束激光从西南角射出，首先会与东墙相遇，入射点到接收器 <code>0</code> 的距离为 <code>q</code> 。</p>\n\n<p>返回光线最先遇到的接收器的编号（保证光线最终会遇到一个接收器）。</p>\n&nbsp;\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/18/reflection.png\" style=\"width: 218px; height: 217px;\" />\n<pre>\n<strong>输入：</strong>p = 2, q = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>这条光线在第一次被反射回左边的墙时就遇到了接收器 2 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>p = 3, q = 1\n<strong>输入：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= q &lt;= p &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 859亲密字符串",
        "hardRate": "EASY",
        "passRate": "34.51%",
        "problemsUrl": "https://leetcode.cn/problems/buddy-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/buddy-strings/solution",
        "problemsDesc": "<p>给你两个字符串 <code>s</code> 和 <code>goal</code> ，只要我们可以通过交换 <code>s</code> 中的两个字母得到与 <code>goal</code> 相等的结果，就返回&nbsp;<code>true</code>&nbsp;；否则返回 <code>false</code> 。</p>\n\n<p>交换字母的定义是：取两个下标 <code>i</code> 和 <code>j</code> （下标从 <code>0</code> 开始）且满足 <code>i != j</code> ，接着交换 <code>s[i]</code> 和 <code>s[j]</code> 处的字符。</p>\n\n<ul>\n\t<li>例如，在 <code>\"abcd\"</code> 中交换下标 <code>0</code> 和下标 <code>2</code> 的元素可以生成 <code>\"cbad\"</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ab\", goal = \"ba\"\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以交换 s[0] = 'a' 和 s[1] = 'b' 生成 \"ba\"，此时 s 和 goal 相等。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ab\", goal = \"ab\"\n<strong>输出：</strong>false\n<strong>解释：</strong>你只能交换 s[0] = 'a' 和 s[1] = 'b' 生成 \"ba\"，此时 s 和 goal 不相等。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aa\", goal = \"aa\"\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以交换 s[0] = 'a' 和 s[1] = 'a' 生成 \"aa\"，此时 s 和 goal 相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, goal.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> 和 <code>goal</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 860柠檬水找零",
        "hardRate": "EASY",
        "passRate": "58.60%",
        "problemsUrl": "https://leetcode.cn/problems/lemonade-change/",
        "solutionsUrl": "https://leetcode.cn/problems/lemonade-change/solution",
        "problemsDesc": "<p>在柠檬水摊上，每一杯柠檬水的售价为&nbsp;<code>5</code>&nbsp;美元。顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p>\n\n<p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p>\n\n<p>注意，一开始你手头没有任何零钱。</p>\n\n<p>给你一个整数数组 <code>bills</code> ，其中 <code>bills[i]</code> 是第 <code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回&nbsp;<code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>bills = [5,5,5,10,20]\n<strong>输出：</strong>true\n<strong>解释：\n</strong>前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。\n第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。\n第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。\n由于所有客户都得到了正确的找零，所以我们输出 true。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>bills = [5,5,10,10,20]\n<strong>输出：</strong>false\n<strong>解释：</strong>\n前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。\n对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。\n对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。\n由于不是每位顾客都得到了正确的找零，所以答案是 false。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= bills.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>bills[i]</code>&nbsp;不是&nbsp;<code>5</code>&nbsp;就是&nbsp;<code>10</code>&nbsp;或是&nbsp;<code>20</code>&nbsp;</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 861翻转矩阵后的得分",
        "hardRate": "MEDIUM",
        "passRate": "80.79%",
        "problemsUrl": "https://leetcode.cn/problems/score-after-flipping-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/score-after-flipping-matrix/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的二元矩阵 <code>grid</code> ，矩阵中每个元素的值为 <code>0</code> 或 <code>1</code> 。</p>\n\n<p>一次 <strong>移动</strong> 是指选择任一行或列，并转换该行或列中的每一个值：将所有 <code>0</code> 都更改为 <code>1</code>，将所有 <code>1</code> 都更改为 <code>0</code>。</p>\n\n<p>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的 <strong>得分</strong> 就是这些数字的总和。</p>\n\n<p>在执行任意次 <strong>移动</strong> 后（含 0 次），返回可能的最高分数。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-toogle1.jpg\" style=\"width: 500px; height: 299px;\" />\n<pre>\n<strong>输入：</strong>grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]\n<strong>输出：</strong>39\n<strong>解释：</strong>0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0]]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 20</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 862和至少为 K 的最短子数组",
        "hardRate": "HARD",
        "passRate": "26.52%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，找出 <code>nums</code> 中和至少为 <code>k</code> 的 <strong>最短非空子数组</strong> ，并返回该子数组的长度。如果不存在这样的 <strong>子数组</strong> ，返回 <code>-1</code> 。</p>\n\n<p><strong>子数组</strong> 是数组中 <strong>连续</strong> 的一部分。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1], k = 1\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2], k = 4\n<strong>输出：</strong>-1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,-1,2], k = 3\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 863二叉树中所有距离为 K 的结点",
        "hardRate": "MEDIUM",
        "passRate": "61.40%",
        "problemsUrl": "https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/solution",
        "problemsDesc": "<p>给定一个二叉树（具有根结点&nbsp;<code>root</code>），&nbsp;一个目标结点&nbsp;<code>target</code>&nbsp;，和一个整数值 <code>k</code> 。</p>\n\n<p>返回到目标结点 <code>target</code> 距离为 <code>k</code> 的所有结点的值的列表。 答案可以以 <strong>任何顺序</strong> 返回。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png\" style=\"height: 429px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2\n<strong>输出：</strong>[7,4,1]\n<strong>解释：</strong>所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> root = [1], target = 1, k = 3\n<strong>输出:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>节点数在&nbsp;<code>[1, 500]</code>&nbsp;范围内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 500</code></li>\n\t<li><code>Node.val</code>&nbsp;中所有值 <strong>不同</strong></li>\n\t<li>目标结点&nbsp;<code>target</code>&nbsp;是树上的结点。</li>\n\t<li><code>0 &lt;= k &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 864获取所有钥匙的最短路径",
        "hardRate": "HARD",
        "passRate": "59.52%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-path-to-get-all-keys/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-path-to-get-all-keys/solution",
        "problemsDesc": "<p>给定一个二维网格&nbsp;<code>grid</code>&nbsp;，其中：</p>\n\n<ul>\n\t<li><font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">'.'</span></span></font></font> 代表一个空房间</li>\n\t<li><font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">'#'</span></span></font></font> 代表一堵墙</li>\n\t<li><font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">'@'</span></span></font></font>&nbsp;是起点</li>\n\t<li>小写字母代表钥匙</li>\n\t<li>大写字母代表锁</li>\n</ul>\n\n<p>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。</p>\n\n<p>假设 k&nbsp;为 钥匙/锁 的个数，且满足&nbsp;<code>1 &lt;= k&nbsp;&lt;= 6</code>，字母表中的前 <code>k</code>&nbsp;个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。</p>\n\n<p>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-keys2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [\"@.a.#\",\"###.#\",\"b.A.B\"]\n<strong>输出：</strong>8\n<strong>解释：</strong>目标是获得所有钥匙，而不是打开所有锁。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-key2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [\"@..aA\",\"..B#.\",\"....b\"]\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-keys3.jpg\" />\n<pre>\n<strong>输入:</strong> grid = [\"@Aa\"]\n<strong>输出:</strong> -1</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 30</code></li>\n\t<li><code>grid[i][j]</code>&nbsp;只含有&nbsp;<code>'.'</code>,&nbsp;<code>'#'</code>,&nbsp;<code>'@'</code>,&nbsp;<code>'a'-</code><code>'f</code><code>'</code>&nbsp;以及&nbsp;<code>'A'-'F'</code></li>\n\t<li>钥匙的数目范围是&nbsp;<code>[1, 6]</code>&nbsp;</li>\n\t<li>每个钥匙都对应一个 <strong>不同</strong> 的字母</li>\n\t<li>每个钥匙正好打开一个对应的锁</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 865具有所有最深节点的最小子树",
        "hardRate": "MEDIUM",
        "passRate": "68.91%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/solution",
        "problemsDesc": "<p>给定一个根为&nbsp;<code>root</code>&nbsp;的二叉树，每个节点的深度是 <strong>该节点到根的最短距离</strong> 。</p>\n\n<p>返回包含原始树中所有 <strong>最深节点</strong> 的 <em>最小子树</em> 。</p>\n\n<p>如果一个节点在 <strong>整个树 </strong>的任意节点之间具有最大的深度，则该节点是 <strong>最深的</strong> 。</p>\n\n<p>一个节点的 <strong>子树</strong> 是该节点加上它的所有后代的集合。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png\" style=\"width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4]\n<strong>输出：</strong>[2,7,4]\n<strong>解释：</strong>\n我们返回值为 2 的节点，在图中用黄色标记。\n在图中用蓝色标记的是树的最深的节点。\n注意，节点 5、3 和 2 包含树中最深的节点，但节点 2 的子树最小，因此我们返回它。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[1]\n<strong>解释：</strong>根节点是树中最深的节点。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [0,1,3,null,2]\n<strong>输出：</strong>[2]\n<strong>解释：</strong>树中最深的节点为 2 ，有效子树为节点 2、1 和 0 的子树，但节点 2 的子树最小。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数量在<meta charset=\"UTF-8\" />&nbsp;<code>[1, 500]</code>&nbsp;范围内。</li>\n\t<li><code>0 &lt;= Node.val &lt;= 500</code></li>\n\t<li>每个节点的值都是 <strong>独一无二</strong> 的。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与力扣 1123 重复：<a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/\" target=\"_blank\">https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 866回文素数",
        "hardRate": "MEDIUM",
        "passRate": "23.84%",
        "problemsUrl": "https://leetcode.cn/problems/prime-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/prime-palindrome/solution",
        "problemsDesc": "<p>求出大于或等于&nbsp;<code>N</code>&nbsp;的最小回文素数。</p>\n\n<p>回顾一下，如果一个数大于 1，且其因数只有 1 和它自身，那么这个数是<em>素数</em>。</p>\n\n<p>例如，2，3，5，7，11 以及&nbsp;13 是素数。</p>\n\n<p>回顾一下，如果一个数从左往右读与从右往左读是一样的，那么这个数是<em>回文数。</em></p>\n\n<p>例如，12321 是回文数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>6\n<strong>输出：</strong>7\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre><strong>输入：</strong>8\n<strong>输出：</strong>11\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre><strong>输入：</strong>13\n<strong>输出：</strong>101</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= N &lt;= 10^8</code></li>\n\t<li>答案肯定存在，且小于&nbsp;<code>2 * 10^8</code>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 867转置矩阵",
        "hardRate": "EASY",
        "passRate": "66.77%",
        "problemsUrl": "https://leetcode.cn/problems/transpose-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/transpose-matrix/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>matrix</code>， 返回 <code>matrix</code> 的 <strong>转置矩阵</strong> 。</p>\n\n<p>矩阵的 <strong>转置</strong> 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/10/hint_transpose.png\" style=\"width: 600px; height: 197px;\" /></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>[[1,4,7],[2,5,8],[3,6,9]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3],[4,5,6]]\n<strong>输出：</strong>[[1,4],[2,5],[3,6]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 <= m, n <= 1000</code></li>\n\t<li><code>1 <= m * n <= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> <= matrix[i][j] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 868二进制间距",
        "hardRate": "EASY",
        "passRate": "69.36%",
        "problemsUrl": "https://leetcode.cn/problems/binary-gap/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-gap/solution",
        "problemsDesc": "<p>给定一个正整数 <code>n</code>，找到并返回 <code>n</code> 的二进制表示中两个 <strong>相邻</strong> 1 之间的<strong> 最长距离 </strong>。如果不存在两个相邻的 1，返回 <code>0</code> 。</p>\n\n<p>如果只有 <code>0</code> 将两个 <code>1</code> 分隔开（可能不存在 <code>0</code> ），则认为这两个 1 彼此 <strong>相邻</strong> 。两个 <code>1</code> 之间的距离是它们的二进制表示中位置的绝对差。例如，<code>\"1001\"</code> 中的两个 <code>1</code> 的距离为 3 。</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 22\n<strong>输出：</strong>2\n<strong>解释：</strong>22 的二进制是 \"10110\" 。\n在 22 的二进制表示中，有三个 1，组成两对相邻的 1 。\n第一对相邻的 1 中，两个 1 之间的距离为 2 。\n第二对相邻的 1 中，两个 1 之间的距离为 1 。\n答案取两个距离之中最大的，也就是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 8\n<strong>输出：</strong>0\n<strong>解释：</strong>8 的二进制是 \"1000\" 。\n在 8 的二进制表示中没有相邻的两个 1，所以返回 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>5 的二进制是 \"101\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 869重新排序得到 2 的幂",
        "hardRate": "MEDIUM",
        "passRate": "63.60%",
        "problemsUrl": "https://leetcode.cn/problems/reordered-power-of-2/",
        "solutionsUrl": "https://leetcode.cn/problems/reordered-power-of-2/solution",
        "problemsDesc": "<p>给定正整数&nbsp;<code>n</code>&nbsp;，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。</p>\n\n<p>如果我们可以通过上述方式得到&nbsp;2 的幂，返回 <code>true</code>；否则，返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 870优势洗牌",
        "hardRate": "MEDIUM",
        "passRate": "50.40%",
        "problemsUrl": "https://leetcode.cn/problems/advantage-shuffle/",
        "solutionsUrl": "https://leetcode.cn/problems/advantage-shuffle/solution",
        "problemsDesc": "<p>给定两个长度相等的数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>，<code>nums1</code>&nbsp;相对于 <code>nums2</code> 的<em>优势</em>可以用满足&nbsp;<code>nums1[i] &gt; nums2[i]</code>&nbsp;的索引 <code>i</code>&nbsp;的数目来描述。</p>\n\n<p>返回 <font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\" size=\"1\"><span style=\"background-color: rgb(249, 242, 244);\">nums1</span></font>&nbsp;的<strong>任意</strong>排列，使其相对于 <code>nums2</code>&nbsp;的优势最大化。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [2,7,11,15], nums2 = [1,10,4,11]\n<strong>输出：</strong>[2,11,7,15]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [12,24,8,32], nums2 = [13,25,32,11]\n<strong>输出：</strong>[24,32,8,12]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums2.length == nums1.length</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 871最低加油次数",
        "hardRate": "HARD",
        "passRate": "43.23%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-refueling-stops/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-refueling-stops/solution",
        "problemsDesc": "<p>汽车从起点出发驶向目的地，该目的地位于出发位置东面 <code>target</code>&nbsp;英里处。</p>\n\n<p>沿途有加油站，用数组&nbsp;<code>stations</code> 表示。其中 <code>stations[i] = [position<sub>i</sub>, fuel<sub>i</sub>]</code> 表示第 <code>i</code> 个加油站位于出发位置东面&nbsp;<code>position<sub>i</sub></code> 英里处，并且有&nbsp;<code>fuel<sub>i</sub></code>&nbsp;升汽油。</p>\n\n<p>假设汽车油箱的容量是无限的，其中最初有&nbsp;<code>startFuel</code>&nbsp;升燃料。它每行驶 1 英里就会用掉 1 升汽油。当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。</p>\n\n<p>为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 <code>-1</code> 。</p>\n\n<p>注意：如果汽车到达加油站时剩余燃料为 <code>0</code>，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 <code>0</code>，仍然认为它已经到达目的地。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 1, startFuel = 1, stations = []\n<strong>输出：</strong>0\n<strong>解释：</strong>可以在不加油的情况下到达目的地。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 100, startFuel = 1, stations = [[10,100]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>无法抵达目的地，甚至无法到达第一个加油站。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n出发时有 10 升燃料。\n开车来到距起点 10 英里处的加油站，消耗 10 升燃料。将汽油从 0 升加到 60 升。\n然后，从 10 英里处的加油站开到 60 英里处的加油站（消耗 50 升燃料），\n并将汽油从 10 升加到 50 升。然后开车抵达目的地。\n沿途在两个加油站停靠，所以返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target, startFuel &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= stations.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= position<sub>i</sub> &lt; position<sub>i+1</sub> &lt; target</code></li>\n\t<li><code>1 &lt;= fuel<sub>i</sub> &lt; 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 872叶子相似的树",
        "hardRate": "EASY",
        "passRate": "65.00%",
        "problemsUrl": "https://leetcode.cn/problems/leaf-similar-trees/",
        "solutionsUrl": "https://leetcode.cn/problems/leaf-similar-trees/solution",
        "problemsDesc": "<p>请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个&nbsp;<strong>叶值序列 </strong>。</p>\n\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png\" style=\"height: 336px; width: 400px;\" /></p>\n\n<p>举个例子，如上图所示，给定一棵叶值序列为&nbsp;<code>(6, 7, 4, 9, 8)</code>&nbsp;的树。</p>\n\n<p>如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是&nbsp;<em>叶相似&nbsp;</em>的。</p>\n\n<p>如果给定的两个根结点分别为&nbsp;<code>root1</code> 和&nbsp;<code>root2</code>&nbsp;的树是叶相似的，则返回&nbsp;<code>true</code>；否则返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-1.jpg\" style=\"height: 237px; width: 600px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-2.jpg\" style=\"height: 110px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root1 = [1,2,3], root2 = [1,3,2]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给定的两棵树结点数在&nbsp;<code>[1, 200]</code> 范围内</li>\n\t<li>给定的两棵树上的值在&nbsp;<code>[0, 200]</code> 范围内</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 873最长的斐波那契子序列的长度",
        "hardRate": "MEDIUM",
        "passRate": "56.26%",
        "problemsUrl": "https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/solution",
        "problemsDesc": "<p>如果序列 <code>X_1, X_2, ..., X_n</code> 满足下列条件，就说它是 <em>斐波那契式 </em>的：</p>\n\n<ul>\n\t<li><code>n >= 3</code></li>\n\t<li>对于所有 <code>i + 2 <= n</code>，都有 <code>X_i + X_{i+1} = X_{i+2}</code></li>\n</ul>\n\n<p>给定一个<strong>严格递增</strong>的正整数数组形成序列 arr ，找到 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.600000381469727px\"><span style=\"caret-color:#c7254e\"><span style=\"background-color:#f9f2f4\">arr</span></span></span></font></font> 中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。</p>\n\n<p><em>（回想一下，子序列是从原序列 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.600000381469727px\"><span style=\"caret-color:#c7254e\"><span style=\"background-color:#f9f2f4\">arr</span></span></span></font></font> 中派生出来的，它从 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.600000381469727px\"><span style=\"caret-color:#c7254e\"><span style=\"background-color:#f9f2f4\">arr</span></span></span></font></font> 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， <code>[3, 5, 8]</code> 是 <code>[3, 4, 5, 6, 7, 8]</code> 的一个子序列）</em></p>\n\n<p> </p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>arr =<strong> </strong>[1,2,3,4,5,6,7,8]\n<strong>输出: </strong>5\n<strong>解释: </strong>最长的斐波那契式子序列为 [1,2,3,5,8] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>arr =<strong> </strong>[1,3,7,11,12,14,18]\n<strong>输出: </strong>3\n<strong>解释</strong>: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 <= arr.length <= 1000</code></li>\n\t<li>\n\t<p><code>1 <= arr[i] < arr[i + 1] <= 10^9</code></p>\n\t</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 874模拟行走机器人",
        "hardRate": "MEDIUM",
        "passRate": "43.09%",
        "problemsUrl": "https://leetcode.cn/problems/walking-robot-simulation/",
        "solutionsUrl": "https://leetcode.cn/problems/walking-robot-simulation/solution",
        "problemsDesc": "<p>机器人在一个无限大小的 XY 网格平面上行走，从点 <code>(0, 0)</code> 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 <code>commands</code> ：</p>\n\n<ul>\n\t<li><code>-2</code> ：向左转 <code>90</code> 度</li>\n\t<li><code>-1</code> ：向右转 <code>90</code> 度</li>\n\t<li><code>1 <= x <= 9</code> ：向前移动 <code>x</code> 个单位长度</li>\n</ul>\n\n<p>在网格上有一些格子被视为障碍物 <code>obstacles</code> 。第 <code>i</code> 个障碍物位于网格点  <code>obstacles[i] = (x<sub>i</sub>, y<sub>i</sub>)</code> 。</p>\n\n<p>机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续尝试进行该路线的其余部分。</p>\n\n<p>返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。（即，如果距离为 <code>5</code> ，则返回 <code>25</code> ）</p>\n\n<div class=\"d-google dictRoot saladict-panel isAnimate\">\n<div>\n<div class=\"MachineTrans-Text\">\n<div class=\"MachineTrans-Lines\">\n<div class=\"MachineTrans-Lines-collapse MachineTrans-lang-en\"> </div>\n</div>\n\n<div class=\"MachineTrans-Lines\">\n<p class=\"MachineTrans-lang-zh-CN\"><strong>注意：</strong></p>\n\n<ul>\n\t<li class=\"MachineTrans-lang-zh-CN\">北表示 <code>+Y</code> 方向。</li>\n\t<li class=\"MachineTrans-lang-zh-CN\">东表示 <code>+X</code> 方向。</li>\n\t<li class=\"MachineTrans-lang-zh-CN\">南表示 <code>-Y</code> 方向。</li>\n\t<li class=\"MachineTrans-lang-zh-CN\">西表示 <code>-X</code> 方向。</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>commands = [4,-1,3], obstacles = []\n<strong>输出：</strong>25\n<strong>解释：\n</strong>机器人开始位于 (0, 0)：\n1. 向北移动 4 个单位，到达 (0, 4)\n2. 右转\n3. 向东移动 3 个单位，到达 (3, 4)\n距离原点最远的是 (3, 4) ，距离为 3<sup>2</sup> + 4<sup>2</sup> = 25</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>commands = [4,-1,4,-2,4], obstacles = [[2,4]]\n<strong>输出：</strong>65\n<strong>解释</strong>：机器人开始位于 (0, 0)：\n1. 向北移动 4 个单位，到达 (0, 4)\n2. 右转\n3. 向东移动 1 个单位，然后被位于 (2, 4) 的障碍物阻挡，机器人停在 (1, 4)\n4. 左转\n5. 向北走 4 个单位，到达 (1, 8)\n距离原点最远的是 (1, 8) ，距离为 1<sup>2</sup> + 8<sup>2</sup> = 65</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= commands.length <= 10<sup>4</sup></code></li>\n\t<li><code>commands[i]</code> is one of the values in the list <code>[-2,-1,1,2,3,4,5,6,7,8,9]</code>.</li>\n\t<li><code>0 <= obstacles.length <= 10<sup>4</sup></code></li>\n\t<li><code>-3 * 10<sup>4</sup> <= x<sub>i</sub>, y<sub>i</sub> <= 3 * 10<sup>4</sup></code></li>\n\t<li>答案保证小于 <code>2<sup>31</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 875爱吃香蕉的珂珂",
        "hardRate": "MEDIUM",
        "passRate": "49.47%",
        "problemsUrl": "https://leetcode.cn/problems/koko-eating-bananas/",
        "solutionsUrl": "https://leetcode.cn/problems/koko-eating-bananas/solution",
        "problemsDesc": "<p>珂珂喜欢吃香蕉。这里有 <code>n</code> 堆香蕉，第 <code>i</code> 堆中有&nbsp;<code>piles[i]</code>&nbsp;根香蕉。警卫已经离开了，将在 <code>h</code> 小时后回来。</p>\n\n<p>珂珂可以决定她吃香蕉的速度 <code>k</code> （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 <code>k</code> 根。如果这堆香蕉少于 <code>k</code> 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。&nbsp;&nbsp;</p>\n\n<p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p>\n\n<p>返回她可以在 <code>h</code> 小时内吃掉所有香蕉的最小速度 <code>k</code>（<code>k</code> 为整数）。</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [3,6,7,11], h = 8\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [30,11,23,4,20], h = 5\n<strong>输出：</strong>30\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [30,11,23,4,20], h = 6\n<strong>输出：</strong>23\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= piles.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>piles.length &lt;= h &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= piles[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 876链表的中间结点",
        "hardRate": "EASY",
        "passRate": "70.19%",
        "problemsUrl": "https://leetcode.cn/problems/middle-of-the-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/middle-of-the-linked-list/solution",
        "problemsDesc": "<p>给你单链表的头结点 <code>head</code> ，请你找出并返回链表的中间结点。</p>\n\n<p>如果有两个中间结点，则返回第二个中间结点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg\" style=\"width: 544px; height: 65px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5]\n<strong>输出：</strong>[3,4,5]\n<strong>解释：</strong>链表只有一个中间结点，值为 3 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/23/lc-midlist2.jpg\" style=\"width: 664px; height: 65px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5,6]\n<strong>输出：</strong>[4,5,6]\n<strong>解释：</strong>该链表有两个中间结点，值分别为 3 和 4 ，返回第二个结点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表的结点数范围是 <code>[1, 100]</code></li>\n\t<li><code>1 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 877石子游戏",
        "hardRate": "MEDIUM",
        "passRate": "76.46%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game/solution",
        "problemsDesc": "<p>Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，<strong>排成一行</strong>；每堆都有 <strong>正</strong> 整数颗石子，数目为 <code>piles[i]</code>&nbsp;。</p>\n\n<p>游戏以谁手中的石子最多来决出胜负。石子的 <strong>总数</strong> 是 <strong>奇数</strong> ，所以没有平局。</p>\n\n<p>Alice 和 Bob 轮流进行，<strong>Alice 先开始</strong> 。 每回合，玩家从行的 <strong>开始</strong> 或 <strong>结束</strong> 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 <strong>石子最多</strong> 的玩家 <strong>获胜</strong> 。</p>\n\n<p>假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回&nbsp;<code>true</code>&nbsp;，当 Bob 赢得比赛时返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [5,3,4,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>\nAlice 先开始，只能拿前 5 颗或后 5 颗石子 。\n假设他取了前 5 颗，这一行就变成了 [3,4,5] 。\n如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。\n如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。\n这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [3,7,2,3]\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= piles.length &lt;= 500</code></li>\n\t<li><code>piles.length</code> 是 <strong>偶数</strong></li>\n\t<li><code>1 &lt;= piles[i] &lt;= 500</code></li>\n\t<li><code>sum(piles[i])</code>&nbsp;是 <strong>奇数</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 878第 N 个神奇数字",
        "hardRate": "HARD",
        "passRate": "40.00%",
        "problemsUrl": "https://leetcode.cn/problems/nth-magical-number/",
        "solutionsUrl": "https://leetcode.cn/problems/nth-magical-number/solution",
        "problemsDesc": "<p>一个正整数如果能被 <code>a</code> 或 <code>b</code> 整除，那么它是神奇的。</p>\n\n<p>给定三个整数 <code>n</code> ,&nbsp;<code>a</code> , <code>b</code> ，返回第 <code>n</code> 个神奇的数字。因为答案可能很大，所以返回答案&nbsp;<strong>对&nbsp;</strong><code>10<sup>9</sup>&nbsp;+ 7</code> <strong>取模&nbsp;</strong>后的值。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, a = 2, b = 3\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, a = 2, b = 3\n<strong>输出：</strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n\t<li><code>2 &lt;= a, b &lt;= 4 * 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 879盈利计划",
        "hardRate": "HARD",
        "passRate": "54.66%",
        "problemsUrl": "https://leetcode.cn/problems/profitable-schemes/",
        "solutionsUrl": "https://leetcode.cn/problems/profitable-schemes/solution",
        "problemsDesc": "<p>集团里有 <code>n</code> 名员工，他们可以完成各种各样的工作创造利润。</p>\n\n<p>第 <code>i</code> 种工作会产生 <code>profit[i]</code> 的利润，它要求 <code>group[i]</code> 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。</p>\n\n<p>工作的任何至少产生 <code>minProfit</code> 利润的子集称为 <strong>盈利计划</strong> 。并且工作的成员总数最多为 <code>n</code> 。</p>\n\n<p>有多少种计划可以选择？因为答案很大，所以<strong> 返回结果模 </strong><code>10^9 + 7</code><strong> 的值</strong>。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, minProfit = 3, group = [2,2], profit = [2,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。\n总的来说，有两种计划。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]\n<strong>输出：</strong>7\n<strong>解释：</strong>至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。\n有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。</pre>\n</div>\n</div>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>0 <= minProfit <= 100</code></li>\n\t<li><code>1 <= group.length <= 100</code></li>\n\t<li><code>1 <= group[i] <= 100</code></li>\n\t<li><code>profit.length == group.length</code></li>\n\t<li><code>0 <= profit[i] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 880索引处的解码字符串",
        "hardRate": "MEDIUM",
        "passRate": "26.94%",
        "problemsUrl": "https://leetcode.cn/problems/decoded-string-at-index/",
        "solutionsUrl": "https://leetcode.cn/problems/decoded-string-at-index/solution",
        "problemsDesc": "<p>给定一个编码字符串 <code>S</code>。请你找出<em> </em><strong>解码字符串</strong> 并将其写入磁带。解码时，从编码字符串中<strong> 每次读取一个字符 </strong>，并采取以下步骤：</p>\n\n<ul>\n\t<li>如果所读的字符是字母，则将该字母写在磁带上。</li>\n\t<li>如果所读的字符是数字（例如 <code>d</code>），则整个当前磁带总共会被重复写&nbsp;<code>d-1</code> 次。</li>\n</ul>\n\n<p>现在，对于给定的编码字符串 <code>S</code> 和索引 <code>K</code>，查找并返回解码字符串中的第&nbsp;<code>K</code>&nbsp;个字母。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>S = &quot;leet2code3&quot;, K = 10\n<strong>输出：</strong>&quot;o&quot;\n<strong>解释：</strong>\n解码后的字符串为 &quot;leetleetcodeleetleetcodeleetleetcode&quot;。\n字符串中的第 10 个字母是 &quot;o&quot;。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>S = &quot;ha22&quot;, K = 5\n<strong>输出：</strong>&quot;h&quot;\n<strong>解释：</strong>\n解码后的字符串为 &quot;hahahaha&quot;。第 5 个字母是 &quot;h&quot;。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>S = &quot;a2345678999999999999999&quot;, K = 1\n<strong>输出：</strong>&quot;a&quot;\n<strong>解释：</strong>\n解码后的字符串为 &quot;a&quot; 重复 8301530446056247680 次。第 1 个字母是 &quot;a&quot;。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= S.length &lt;= 100</code></li>\n\t<li><code>S</code>&nbsp;只包含小写字母与数字 <code>2</code> 到 <code>9</code> 。</li>\n\t<li><code>S</code>&nbsp;以字母开头。</li>\n\t<li><code>1 &lt;= K &lt;= 10^9</code></li>\n\t<li>题目保证 <code>K</code> 小于或等于解码字符串的长度。</li>\n\t<li>解码后的字符串保证少于&nbsp;<code>2^63</code>&nbsp;个字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 881救生艇",
        "hardRate": "MEDIUM",
        "passRate": "53.73%",
        "problemsUrl": "https://leetcode.cn/problems/boats-to-save-people/",
        "solutionsUrl": "https://leetcode.cn/problems/boats-to-save-people/solution",
        "problemsDesc": "<p>给定数组<meta charset=\"UTF-8\" />&nbsp;<code>people</code>&nbsp;。<code>people[i]</code>表示第 <code>i</code><sup>&nbsp;</sup>个人的体重&nbsp;，<strong>船的数量不限</strong>，每艘船可以承载的最大重量为&nbsp;<code>limit</code>。</p>\n\n<p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为&nbsp;<code>limit</code>。</p>\n\n<p>返回 <em>承载所有人所需的最小船数</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>people = [1,2], limit = 3\n<strong>输出：</strong>1\n<strong>解释：</strong>1 艘船载 (1, 2)\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>people = [3,2,2,1], limit = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>3 艘船分别载 (1, 2), (2) 和 (3)\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>people = [3,5,3,4], limit = 5\n<strong>输出：</strong>4\n<strong>解释：</strong>4 艘船分别载 (3), (3), (4), (5)</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= people.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= people[i] &lt;= limit &lt;= 3 * 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 882细分图中的可到达节点",
        "hardRate": "HARD",
        "passRate": "64.06%",
        "problemsUrl": "https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/solution",
        "problemsDesc": "<p>给你一个无向图（<strong>原始图</strong>），图中有 <code>n</code> 个节点，编号从 <code>0</code> 到 <code>n - 1</code> 。你决定将图中的每条边 <strong>细分</strong> 为一条节点链，每条边之间的新节点数各不相同。</p>\n\n<p>图用由边组成的二维数组 <code>edges</code> 表示，其中&nbsp;<code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, cnt<sub>i</sub>]</code> 表示原始图中节点&nbsp;<code>u<sub>i</sub></code> 和&nbsp;<code>v<sub>i</sub></code> 之间存在一条边，<code>cnt<sub>i</sub></code> 是将边 <strong>细分</strong> 后的新节点总数。注意，<code>cnt<sub>i</sub> == 0</code> 表示边不可细分。</p>\n\n<p>要 <strong>细分</strong> 边 <code>[ui, vi]</code> ，需要将其替换为 <code>(cnt<sub>i</sub> + 1)</code> 条新边，和&nbsp;<code>cnt<sub>i</sub></code> 个新节点。新节点为 <code>x<sub>1</sub></code>, <code>x<sub>2</sub></code>, ..., <code>x<sub>cnt<sub>i</sub></sub></code> ，新边为 <code>[u<sub>i</sub>, x<sub>1</sub>]</code>, <code>[x<sub>1</sub>, x<sub>2</sub>]</code>, <code>[x<sub>2</sub>, x<sub>3</sub>]</code>, ..., <code>[x<sub>cnt<sub>i</sub>-1</sub>, x<sub>cnt<sub>i</sub></sub>]</code>, <code>[x<sub>cnt<sub>i</sub></sub>, v<sub>i</sub>]</code> 。</p>\n\n<p>现在得到一个&nbsp;<strong>新的细分图</strong> ，请你计算从节点 <code>0</code> 出发，可以到达多少个节点？如果节点间距离是 <code>maxMoves</code> 或更少，则视为 <strong>可以到达</strong> 。</p>\n\n<p>给你原始图和 <code>maxMoves</code> ，返回 <em>新的细分图中从节点 <code>0</code> 出发</em><strong><em> 可到达的节点数</em></strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/01/origfinal.png\" style=\"height: 247px; width: 600px;\" />\n<pre>\n<strong>输入：</strong>edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3\n<strong>输出：</strong>13\n<strong>解释：</strong>边的细分情况如上图所示。\n可以到达的节点已经用黄色标注出来。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4\n<strong>输出：</strong>23\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5\n<strong>输出：</strong>1\n<strong>解释：</strong>节点 0 与图的其余部分没有连通，所以只有节点 0 可以到达。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= edges.length &lt;= min(n * (n - 1) / 2, 10<sup>4</sup>)</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub> &lt; v<sub>i</sub> &lt; n</code></li>\n\t<li>图中 <strong>不存在平行边</strong></li>\n\t<li><code>0 &lt;= cnt<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= maxMoves &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= n &lt;= 3000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 883三维形体投影面积",
        "hardRate": "EASY",
        "passRate": "76.36%",
        "problemsUrl": "https://leetcode.cn/problems/projection-area-of-3d-shapes/",
        "solutionsUrl": "https://leetcode.cn/problems/projection-area-of-3d-shapes/solution",
        "problemsDesc": "<p>在<meta charset=\"UTF-8\" />&nbsp;<code>n x n</code>&nbsp;的网格<meta charset=\"UTF-8\" />&nbsp;<code>grid</code>&nbsp;中，我们放置了一些与 x，y，z 三轴对齐的<meta charset=\"UTF-8\" />&nbsp;<code>1 x 1 x 1</code>&nbsp;立方体。</p>\n\n<p>每个值&nbsp;<code>v = grid[i][j]</code>&nbsp;表示 <code>v</code>&nbsp;个正方体叠放在单元格&nbsp;<code>(i, j)</code>&nbsp;上。</p>\n\n<p>现在，我们查看这些立方体在 <code>xy</code>&nbsp;、<code>yz</code>&nbsp;和 <code>zx</code>&nbsp;平面上的<em>投影</em>。</p>\n\n<p><strong>投影</strong>&nbsp;就像影子，将 <strong>三维</strong> 形体映射到一个 <strong>二维</strong> 平面上。从顶部、前面和侧面看立方体时，我们会看到“影子”。</p>\n\n<p>返回 <em>所有三个投影的总面积</em> 。</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<ul>\n</ul>\n\n<ul>\n</ul>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/02/shadow.png\" style=\"height: 214px; width: 800px;\" /></p>\n\n<pre>\n<strong>输入：</strong>[[1,2],[3,4]]\n<strong>输出：</strong>17\n<strong>解释：</strong>这里有该形体在三个轴对齐平面上的三个投影(“阴影部分”)。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[2]]\n<strong>输出：</strong>5\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>[[1,0],[0,2]]\n<strong>输出：</strong>8\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 884两句话中的不常见单词",
        "hardRate": "EASY",
        "passRate": "71.25%",
        "problemsUrl": "https://leetcode.cn/problems/uncommon-words-from-two-sentences/",
        "solutionsUrl": "https://leetcode.cn/problems/uncommon-words-from-two-sentences/solution",
        "problemsDesc": "<p><strong>句子</strong> 是一串由空格分隔的单词。每个 <strong>单词</strong><em> </em>仅由小写字母组成。</p>\n\n<p>如果某个单词在其中一个句子中恰好出现一次，在另一个句子中却 <strong>没有出现</strong> ，那么这个单词就是 <strong>不常见的</strong><em> </em>。</p>\n\n<p>给你两个 <strong>句子</strong> <code>s1</code> 和 <code>s2</code> ，返回所有 <strong>不常用单词</strong> 的列表。返回列表中单词可以按 <strong>任意顺序</strong> 组织。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"this apple is sweet\", s2 = \"this apple is sour\"\n<strong>输出：</strong>[\"sweet\",\"sour\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"apple apple\", s2 = \"banana\"\n<strong>输出：</strong>[\"banana\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 200</code></li>\n\t<li><code>s1</code> 和 <code>s2</code> 由小写英文字母和空格组成</li>\n\t<li><code>s1</code> 和 <code>s2</code> 都不含前导或尾随空格</li>\n\t<li><code>s1</code> 和 <code>s2</code> 中的所有单词间均由单个空格分隔</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 885螺旋矩阵 III",
        "hardRate": "MEDIUM",
        "passRate": "71.16%",
        "problemsUrl": "https://leetcode.cn/problems/spiral-matrix-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/spiral-matrix-iii/solution",
        "problemsDesc": "<p>在 <code>rows x cols</code> 的网格上，你从单元格 <code>(rStart, cStart)</code> 面朝东面开始。网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。</p>\n\n<p>你需要以顺时针按螺旋状行走，访问此网格中的每个位置。每当移动到网格的边界之外时，需要继续在网格之外行走（但稍后可能会返回到网格边界）。</p>\n\n<p>最终，我们到过网格的所有&nbsp;<code>rows x cols</code>&nbsp;个空间。</p>\n\n<p>按照访问顺序返回表示网格位置的坐标列表。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_1.png\" style=\"width: 174px; height: 99px;\" />\n<pre>\n<strong>输入：</strong>rows = 1, cols = 4, rStart = 0, cStart = 0\n<strong>输出：</strong>[[0,0],[0,1],[0,2],[0,3]]\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_2.png\" style=\"width: 202px; height: 142px;\" />\n<pre>\n<strong>输入：</strong>rows = 5, cols = 6, rStart = 1, cStart = 4\n<strong>输出：</strong>[[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rows, cols &lt;= 100</code></li>\n\t<li><code>0 &lt;= rStart &lt; rows</code></li>\n\t<li><code>0 &lt;= cStart &lt; cols</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 886可能的二分法",
        "hardRate": "MEDIUM",
        "passRate": "52.09%",
        "problemsUrl": "https://leetcode.cn/problems/possible-bipartition/",
        "solutionsUrl": "https://leetcode.cn/problems/possible-bipartition/solution",
        "problemsDesc": "<p>给定一组&nbsp;<code>n</code>&nbsp;人（编号为&nbsp;<code>1, 2, ..., n</code>），&nbsp;我们想把每个人分进<strong>任意</strong>大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。</p>\n\n<p>给定整数 <code>n</code>&nbsp;和数组 <code>dislikes</code>&nbsp;，其中&nbsp;<code>dislikes[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;，表示不允许将编号为 <code>a<sub>i</sub></code>&nbsp;和&nbsp;&nbsp;<code>b<sub>i</sub></code>的人归入同一组。当可以用这种方法将所有人分进两组时，返回 <code>true</code>；否则返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, dislikes = [[1,2],[1,3],[2,4]]\n<strong>输出：</strong>true\n<strong>解释：</strong>group1 [1,4], group2 [2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, dislikes = [[1,2],[1,3],[2,3]]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2000</code></li>\n\t<li><code>0 &lt;= dislikes.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>dislikes[i].length == 2</code></li>\n\t<li><code>1 &lt;= dislikes[i][j] &lt;= n</code></li>\n\t<li><code>a<sub>i</sub>&nbsp;&lt; b<sub>i</sub></code></li>\n\t<li><code>dislikes</code>&nbsp;中每一组都 <strong>不同</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 887鸡蛋掉落",
        "hardRate": "HARD",
        "passRate": "30.64%",
        "problemsUrl": "https://leetcode.cn/problems/super-egg-drop/",
        "solutionsUrl": "https://leetcode.cn/problems/super-egg-drop/solution",
        "problemsDesc": "<p>给你 <code>k</code> 枚相同的鸡蛋，并可以使用一栋从第 <code>1</code> 层到第 <code>n</code> 层共有 <code>n</code> 层楼的建筑。</p>\n\n<p>已知存在楼层 <code>f</code> ，满足 <code>0 <= f <= n</code> ，任何从<strong> 高于</strong> <code>f</code> 的楼层落下的鸡蛋都会碎，从 <code>f</code> 楼层或比它低的楼层落下的鸡蛋都不会破。</p>\n\n<p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 <code>x</code> 扔下（满足 <code>1 <= x <= n</code>）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 <strong>重复使用</strong> 这枚鸡蛋。</p>\n\n<p>请你计算并返回要确定 <code>f</code> <strong>确切的值</strong> 的 <strong>最小操作次数</strong> 是多少？</p>\n \n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 1, n = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>\n鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。 \n否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。 \n如果它没碎，那么肯定能得出 f = 2 。 \n因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 2, n = 6\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 3, n = 14\n<strong>输出：</strong>4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= k <= 100</code></li>\n\t<li><code>1 <= n <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 888公平的糖果交换",
        "hardRate": "EASY",
        "passRate": "63.57%",
        "problemsUrl": "https://leetcode.cn/problems/fair-candy-swap/",
        "solutionsUrl": "https://leetcode.cn/problems/fair-candy-swap/solution",
        "problemsDesc": "<p>爱丽丝和鲍勃拥有不同总数量的糖果。给你两个数组 <code>aliceSizes</code> 和 <code>bobSizes</code> ，<code>aliceSizes[i]</code> 是爱丽丝拥有的第 <code>i</code> 盒糖果中的糖果数量，<code>bobSizes[j]</code> 是鲍勃拥有的第 <code>j</code> 盒糖果中的糖果数量。</p>\n\n<p>两人想要互相交换一盒糖果，这样在交换之后，他们就可以拥有相同总数量的糖果。一个人拥有的糖果总数量是他们每盒糖果数量的总和。</p>\n\n<p>返回一个整数数组 <code>answer</code>，其中 <code>answer[0]</code> 是爱丽丝必须交换的糖果盒中的糖果的数目，<code>answer[1]</code> 是鲍勃必须交换的糖果盒中的糖果的数目。如果存在多个答案，你可以返回其中 <strong>任何一个</strong> 。题目测试用例保证存在与输入对应的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>aliceSizes = [1,1], bobSizes = [2,2]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>aliceSizes = [1,2], bobSizes = [2,3]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>aliceSizes = [2], bobSizes = [1,3]\n<strong>输出：</strong>[2,3]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>aliceSizes = [1,2,5], bobSizes = [2,4]\n<strong>输出：</strong>[5,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= aliceSizes.length, bobSizes.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= aliceSizes[i], bobSizes[j] &lt;= 10<sup>5</sup></code></li>\n\t<li>爱丽丝和鲍勃的糖果总数量不同。</li>\n\t<li>题目数据保证对于给定的输入至少存在一个有效答案。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 889根据前序和后序遍历构造二叉树",
        "hardRate": "MEDIUM",
        "passRate": "68.01%",
        "problemsUrl": "https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/solution",
        "problemsDesc": "<p>给定两个整数数组，<code>preorder</code>&nbsp;和 <code>postorder</code> ，其中 <code>preorder</code> 是一个具有 <strong>无重复</strong> 值的二叉树的前序遍历，<code>postorder</code> 是同一棵树的后序遍历，重构并返回二叉树。</p>\n\n<p>如果存在多个答案，您可以返回其中 <strong>任何</strong> 一个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/24/lc-prepost.jpg\" style=\"height: 265px; width: 304px;\" /></p>\n\n<pre>\n<strong>输入：</strong>preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\n<strong>输出：</strong>[1,2,3,4,5,6,7]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> preorder = [1], postorder = [1]\n<strong>输出:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= preorder.length &lt;= 30</code></li>\n\t<li><code>1 &lt;= preorder[i] &lt;= preorder.length</code></li>\n\t<li><code>preorder</code>&nbsp;中所有值都 <strong>不同</strong></li>\n\t<li><code>postorder.length == preorder.length</code></li>\n\t<li><code>1 &lt;= postorder[i] &lt;= postorder.length</code></li>\n\t<li><code>postorder</code>&nbsp;中所有值都 <strong>不同</strong></li>\n\t<li>保证 <code>preorder</code>&nbsp;和 <code>postorder</code>&nbsp;是同一棵二叉树的前序遍历和后序遍历</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 890查找和替换模式",
        "hardRate": "MEDIUM",
        "passRate": "78.58%",
        "problemsUrl": "https://leetcode.cn/problems/find-and-replace-pattern/",
        "solutionsUrl": "https://leetcode.cn/problems/find-and-replace-pattern/solution",
        "problemsDesc": "<p>你有一个单词列表&nbsp;<code>words</code>&nbsp;和一个模式&nbsp;&nbsp;<code>pattern</code>，你想知道 <code>words</code> 中的哪些单词与模式匹配。</p>\n\n<p>如果存在字母的排列 <code>p</code>&nbsp;，使得将模式中的每个字母 <code>x</code> 替换为 <code>p(x)</code> 之后，我们就得到了所需的单词，那么单词与模式是匹配的。</p>\n\n<p><em>（回想一下，字母的排列是从字母到字母的双射：每个字母映射到另一个字母，没有两个字母映射到同一个字母。）</em></p>\n\n<p>返回 <code>words</code> 中与给定模式匹配的单词列表。</p>\n\n<p>你可以按任何顺序返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;], pattern = &quot;abb&quot;\n<strong>输出：</strong>[&quot;mee&quot;,&quot;aqq&quot;]\n<strong>解释：\n</strong>&quot;mee&quot; 与模式匹配，因为存在排列 {a -&gt; m, b -&gt; e, ...}。\n&quot;ccc&quot; 与模式不匹配，因为 {a -&gt; c, b -&gt; c, ...} 不是排列。\n因为 a 和 b 映射到同一个字母。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= pattern.length = words[i].length&nbsp;&lt;= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 891子序列宽度之和",
        "hardRate": "HARD",
        "passRate": "46.52%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-subsequence-widths/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-subsequence-widths/solution",
        "problemsDesc": "<p>一个序列的 <strong>宽度</strong> 定义为该序列中最大元素和最小元素的差值。</p>\n\n<p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 的所有非空 <strong>子序列</strong> 的 <strong>宽度之和</strong> 。由于答案可能非常大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后的结果。</p>\n\n<p><strong>子序列</strong> 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，<code>[3,6,2,7]</code> 就是数组 <code>[0,3,1,6,2,2,7]</code> 的一个子序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,3]\n<strong>输出：</strong>6\n<strong>解释：</strong>子序列为 [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3] 。\n相应的宽度是 0, 0, 0, 1, 1, 2, 2 。\n宽度之和是 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 892三维形体的表面积",
        "hardRate": "EASY",
        "passRate": "64.44%",
        "problemsUrl": "https://leetcode.cn/problems/surface-area-of-3d-shapes/",
        "solutionsUrl": "https://leetcode.cn/problems/surface-area-of-3d-shapes/solution",
        "problemsDesc": "<p>给你一个 <code>n * n</code> 的网格&nbsp;<code>grid</code> ，上面放置着一些&nbsp;<code>1 x 1 x 1</code>&nbsp;的正方体。每个值&nbsp;<code>v = grid[i][j]</code>&nbsp;表示&nbsp;<code>v</code>&nbsp;个正方体叠放在对应单元格&nbsp;<code>(i, j)</code>&nbsp;上。</p>\n\n<p>放置好正方体后，任何直接相邻的正方体都会互相粘在一起，形成一些不规则的三维形体。</p>\n\n<p>请你返回最终这些形体的总表面积。</p>\n\n<p><strong>注意：</strong>每个形体的底面也需要计入表面积中。</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/08/tmp-grid2.jpg\" style=\"height: 80px; width: 80px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,2],[3,4]]\n<strong>输出：</strong>34\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/08/tmp-grid4.jpg\" style=\"height: 100px; width: 100px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,1,1],[1,0,1],[1,1,1]]\n<strong>输出：</strong>32\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/08/tmp-grid5.jpg\" style=\"height: 100px; width: 100px;\" />\n<pre>\n<strong>输入：</strong>grid = [[2,2,2],[2,1,2],[2,2,2]]\n<strong>输出：</strong>46\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 893特殊等价字符串组",
        "hardRate": "MEDIUM",
        "passRate": "73.00%",
        "problemsUrl": "https://leetcode.cn/problems/groups-of-special-equivalent-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/groups-of-special-equivalent-strings/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>words</code>。</p>\n\n<p>一步操作中，你可以交换字符串 <code>words[i]</code> 的任意两个偶数下标对应的字符或任意两个奇数下标对应的字符。</p>\n\n<p>对两个字符串&nbsp;<code>words[i]</code> 和 <code>words[j]</code> 而言，如果经过任意次数的操作，<code>words[i] == words[j]</code> ，那么这两个字符串是 <strong>特殊等价 </strong>的。</p>\n\n<ul>\n\t<li>例如，<code>words[i] = \"zzxy\"</code> 和 <code>words[j] = \"xyzz\"</code> 是一对 <strong>特殊等价</strong> 字符串，因为可以按 <code>\"zzxy\" -&gt; \"xzzy\" -&gt; \"xyzz\"</code> 的操作路径使&nbsp;<code>words[i] == words[j]</code> 。</li>\n</ul>\n\n<p>现在规定，<strong><code>words</code> </strong>的 <strong>一组特殊等价字符串 </strong>就是 <code>words</code> 的一个同时满足下述条件的非空子集：</p>\n\n<ul>\n\t<li>该组中的每一对字符串都是<strong> 特殊等价 </strong>的</li>\n\t<li>该组字符串已经涵盖了该类别中的所有特殊等价字符串，容量达到理论上的最大值（也就是说，如果一个字符串不在该组中，那么这个字符串就 <strong>不会</strong> 与该组内任何字符串特殊等价）</li>\n</ul>\n\n<p>返回 <code>words</code> 中 <strong>特殊等价字符串组</strong> 的数量。</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"abcd\",\"cdab\",\"cbad\",\"xyzz\",\"zzxy\",\"zzyx\"]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n其中一组为 [\"abcd\", \"cdab\", \"cbad\"]，因为它们是成对的特殊等价字符串，且没有其他字符串与这些字符串特殊等价。\n另外两组分别是 [\"xyzz\", \"zzxy\"] 和 [\"zzyx\"]。特别需要注意的是，\"zzxy\" 不与 \"zzyx\" 特殊等价。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\n<strong>输出：</strong>3\n<strong>解释：</strong>3 组 [\"abc\",\"cba\"]，[\"acb\",\"bca\"]，[\"bac\",\"cab\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 20</code></li>\n\t<li>所有 <code>words[i]</code>&nbsp;都只由小写字母组成。</li>\n\t<li>所有 <code>words[i]</code>&nbsp;都具有相同的长度。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 894所有可能的真二叉树",
        "hardRate": "MEDIUM",
        "passRate": "77.67%",
        "problemsUrl": "https://leetcode.cn/problems/all-possible-full-binary-trees/",
        "solutionsUrl": "https://leetcode.cn/problems/all-possible-full-binary-trees/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，请你找出所有可能含 <code>n</code> 个节点的 <strong>真二叉树</strong> ，并以列表形式返回。答案中每棵树的每个节点都必须符合 <code>Node.val == 0</code> 。</p>\n\n<p>答案的每个元素都是一棵真二叉树的根节点。你可以按 <strong>任意顺序</strong> 返回最终的真二叉树列表<strong>。</strong></p>\n\n<p><strong>真二叉树</strong> 是一类二叉树，树中每个节点恰好有 <code>0</code> 或 <code>2</code> 个子节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png\" style=\"width: 700px; height: 400px;\" />\n<pre>\n<strong>输入：</strong>n = 7\n<strong>输出：</strong>[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>[[0,0,0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 895最大频率栈",
        "hardRate": "HARD",
        "passRate": "64.38%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-frequency-stack/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-frequency-stack/solution",
        "problemsDesc": "<p>设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出<strong>出现频率</strong>最高的元素。</p>\n\n<p>实现 <code>FreqStack</code>&nbsp;类:</p>\n\n<ul>\n\t<li><meta charset=\"UTF-8\" /><code>FreqStack()</code>&nbsp;构造一个空的堆栈。</li>\n\t<li><meta charset=\"UTF-8\" /><code>void push(int val)</code>&nbsp;将一个整数&nbsp;<code>val</code>&nbsp;压入栈顶。</li>\n\t<li><meta charset=\"UTF-8\" /><code>int pop()</code>&nbsp;删除并返回堆栈中出现频率最高的元素。\n\t<ul>\n\t\t<li>如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"FreqStack\",\"push\",\"push\",\"push\",\"push\",\"push\",\"push\",\"pop\",\"pop\",\"pop\",\"pop\"],\n[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]\n<strong>输出：</strong>[null,null,null,null,null,null,null,5,7,5,4]\n<strong>解释：</strong>\nFreqStack = new FreqStack();\nfreqStack.push (5);//堆栈为 [5]\nfreqStack.push (7);//堆栈是 [5,7]\nfreqStack.push (5);//堆栈是 [5,7,5]\nfreqStack.push (7);//堆栈是 [5,7,5,7]\nfreqStack.push (4);//堆栈是 [5,7,5,7,4]\nfreqStack.push (5);//堆栈是 [5,7,5,7,4,5]\nfreqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。\nfreqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。\nfreqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。\nfreqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= val &lt;= 10<sup>9</sup></code></li>\n\t<li><code>push</code>&nbsp;和 <code>pop</code>&nbsp;的操作数不大于 <code>2 * 10<sup>4</sup></code>。</li>\n\t<li>输入保证在调用&nbsp;<code>pop</code>&nbsp;之前堆栈中至少有一个元素。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 896单调数列",
        "hardRate": "EASY",
        "passRate": "57.04%",
        "problemsUrl": "https://leetcode.cn/problems/monotonic-array/",
        "solutionsUrl": "https://leetcode.cn/problems/monotonic-array/solution",
        "problemsDesc": "<p>如果数组是单调递增或单调递减的，那么它是&nbsp;<strong>单调 </strong><em>的</em>。</p>\n\n<p>如果对于所有 <code>i &lt;= j</code>，<code>nums[i] &lt;= nums[j]</code>，那么数组 <code>nums</code> 是单调递增的。 如果对于所有 <code>i &lt;= j</code>，<code>nums[i]&gt; = nums[j]</code>，那么数组 <code>nums</code>&nbsp;是单调递减的。</p>\n\n<p>当给定的数组 <code>nums</code>&nbsp;是单调数组时返回 <code>true</code>，否则返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2,3]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [6,5,4,4]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,2]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 897递增顺序搜索树",
        "hardRate": "EASY",
        "passRate": "74.02%",
        "problemsUrl": "https://leetcode.cn/problems/increasing-order-search-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/increasing-order-search-tree/solution",
        "problemsDesc": "<p>给你一棵二叉搜索树的<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;，请你 <strong>按中序遍历</strong> 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg\" style=\"height: 350px; width: 600px;\" />\n<pre>\n<strong>输入：</strong>root = [5,3,6,2,4,null,8,1,null,null,null,7,9]\n<strong>输出：</strong>[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/17/ex2.jpg\" style=\"height: 114px; width: 300px;\" />\n<pre>\n<strong>输入：</strong>root = [5,1,7]\n<strong>输出：</strong>[1,null,5,null,7]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数的取值范围是 <code>[1, 100]</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 898子数组按位或操作",
        "hardRate": "MEDIUM",
        "passRate": "39.09%",
        "problemsUrl": "https://leetcode.cn/problems/bitwise-ors-of-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/bitwise-ors-of-subarrays/solution",
        "problemsDesc": "<p>我们有一个非负整数数组<meta charset=\"UTF-8\" />&nbsp;<code>arr</code>&nbsp;。</p>\n\n<p>对于每个（连续的）子数组<meta charset=\"UTF-8\" />&nbsp;<code>sub = [arr[i], arr[i + 1], ..., arr[j]]</code>&nbsp;（&nbsp;<code>i &lt;= j</code>），我们对<meta charset=\"UTF-8\" />&nbsp;<code>sub</code>&nbsp;中的每个元素进行按位或操作，获得结果<meta charset=\"UTF-8\" />&nbsp;<code>arr[i] | arr[i + 1] | ... | arr[j]</code>&nbsp;。</p>\n\n<p>返回可能结果的数量。 多次出现的结果在最终答案中仅计算一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n只有一个可能的结果 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,1,2]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n可能的子数组为 [1]，[1]，[2]，[1, 1]，[1, 2]，[1, 1, 2]。\n产生的结果为 1，1，2，1，3，3 。\n有三个唯一值，所以答案是 3 。\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,4]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n可能的结果是 1，2，3，4，6，以及 7 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i]&nbsp;&lt;= 10<sup>9</sup></code>​​​​​​​</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 899有序队列",
        "hardRate": "HARD",
        "passRate": "64.12%",
        "problemsUrl": "https://leetcode.cn/problems/orderly-queue/",
        "solutionsUrl": "https://leetcode.cn/problems/orderly-queue/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>&nbsp;。你可以从 <code>s</code> 的前 <code>k</code> 个字母中选择一个，并把它加到字符串的末尾。</p>\n\n<p>返回 <em>在应用上述步骤的任意数量的移动后，字典上最小的字符串&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"cba\", k = 1\n<strong>输出：</strong>\"acb\"\n<strong>解释：</strong>\n在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “bac”。\n在第二步中，我们将第一个字符（“b”）移动到最后，获得最终结果 “acb”。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"baaca\", k = 3\n<strong>输出：</strong>\"aaabc\"\n<strong>解释：\n</strong>在第一步中，我们将第一个字符（“b”）移动到最后，获得字符串 “aacab”。\n在第二步中，我们将第三个字符（“c”）移动到最后，获得最终结果 “aaabc”。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k&nbsp;&lt;= S.length&nbsp;&lt;= 1000</code></li>\n\t<li><code>s</code>&nbsp;只由小写字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 900RLE 迭代器",
        "hardRate": "MEDIUM",
        "passRate": "51.26%",
        "problemsUrl": "https://leetcode.cn/problems/rle-iterator/",
        "solutionsUrl": "https://leetcode.cn/problems/rle-iterator/solution",
        "problemsDesc": "<p>我们可以使用游程编码(即&nbsp;<strong>RLE&nbsp;</strong>)来编码一个整数序列。在偶数长度&nbsp;<code>encoding</code>&nbsp;( <strong>从 0 开始</strong> )的游程编码数组中，对于所有偶数 <code>i</code> ，<code>encoding[i]</code>&nbsp;告诉我们非负整数&nbsp;<code>encoding[i + 1]</code>&nbsp;在序列中重复的次数。</p>\n\n<ul>\n\t<li>例如，序列&nbsp;<code>arr = [8,8,8,5,5]</code>&nbsp;可以被编码为 <code>encoding =[3,8,2,5]</code> 。<code>encoding =[3,8,0,9,2,5]</code>&nbsp;和 <code>encoding =[2,8,1,8,2,5]</code> 也是&nbsp;<code>arr</code> 有效的 <strong>RLE</strong> 。</li>\n</ul>\n\n<p>给定一个游程长度的编码数组，设计一个迭代器来遍历它。</p>\n\n<p>实现 <code>RLEIterator</code> 类:</p>\n\n<ul>\n\t<li><code>RLEIterator(int[] encoded)</code>&nbsp;用编码后的数组初始化对象。</li>\n\t<li><code>int next(int n)</code> 以这种方式耗尽后 <code>n</code> 个元素并返回最后一个耗尽的元素。如果没有剩余的元素要耗尽，则返回 <code>-1</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：\n</strong>[\"RLEIterator\",\"next\",\"next\",\"next\",\"next\"]\n[[[3,8,0,9,2,5]],[2],[1],[1],[2]]\n<strong>输出：\n</strong>[null,8,8,5,-1]\n<strong>解释：</strong>\nRLEIterator rLEIterator = new RLEIterator([3, 8, 0, 9, 2, 5]); // 这映射到序列 [8,8,8,5,5]。\nrLEIterator.next(2); // 耗去序列的 2 个项，返回 8。现在剩下的序列是 [8, 5, 5]。\nrLEIterator.next(1); // 耗去序列的 1 个项，返回 8。现在剩下的序列是 [5, 5]。\nrLEIterator.next(1); // 耗去序列的 1 个项，返回 5。现在剩下的序列是 [5]。\nrLEIterator.next(2); // 耗去序列的 2 个项，返回 -1。 这是由于第一个被耗去的项是 5，\n但第二个项并不存在。由于最后一个要耗去的项不存在，我们返回 -1。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= encoding.length &lt;= 1000</code></li>\n\t<li><code>encoding.length</code>&nbsp;为偶</li>\n\t<li><code>0 &lt;= encoding[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n\t<li>每个测试用例调用<code>next </code>不高于&nbsp;<code>1000</code>&nbsp;次&nbsp;</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 901股票价格跨度",
        "hardRate": "MEDIUM",
        "passRate": "62.26%",
        "problemsUrl": "https://leetcode.cn/problems/online-stock-span/",
        "solutionsUrl": "https://leetcode.cn/problems/online-stock-span/solution",
        "problemsDesc": "<p>设计一个算法收集某些股票的每日报价，并返回该股票当日价格的 <strong>跨度</strong> 。</p>\n\n<p>当日股票价格的 <strong>跨度</strong> 被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。</p>\n\n<ul>\n\t<li>\n\t<p>例如，如果未来 7 天股票的价格是 <code>[100,80,60,70,60,75,85]</code>，那么股票跨度将是 <code>[1,1,1,2,1,4,6]</code> 。</p>\n\t</li>\n</ul>\n\n<p>实现 <code>StockSpanner</code> 类：</p>\n\n<ul>\n\t<li><code>StockSpanner()</code> 初始化类对象。</li>\n\t<li><code>int next(int price)</code> 给出今天的股价 <code>price</code> ，返回该股票当日价格的 <strong>跨度</strong> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例：</strong></p>\n\n<pre>\n<strong>输入</strong>：\n[\"StockSpanner\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\"]\n[[], [100], [80], [60], [70], [60], [75], [85]]\n<strong>输出</strong>：\n[null, 1, 1, 1, 2, 1, 4, 6]\n\n<strong>解释：</strong>\nStockSpanner stockSpanner = new StockSpanner();\nstockSpanner.next(100); // 返回 1\nstockSpanner.next(80);  // 返回 1\nstockSpanner.next(60);  // 返回 1\nstockSpanner.next(70);  // 返回 2\nstockSpanner.next(60);  // 返回 1\nstockSpanner.next(75);  // 返回 4 ，因为截至今天的最后 4 个股价 (包括今天的股价 75) 都小于或等于今天的股价。\nstockSpanner.next(85);  // 返回 6\n</pre>\n&nbsp;\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= price &lt;= 10<sup>5</sup></code></li>\n\t<li>最多调用 <code>next</code> 方法 <code>10<sup>4</sup></code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 902最大为 N 的数字组合",
        "hardRate": "HARD",
        "passRate": "46.22%",
        "problemsUrl": "https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/",
        "solutionsUrl": "https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/solution",
        "problemsDesc": "<p>给定一个按&nbsp;<strong>非递减顺序</strong>&nbsp;排列的数字数组<meta charset=\"UTF-8\" />&nbsp;<code>digits</code>&nbsp;。你可以用任意次数&nbsp;<code>digits[i]</code>&nbsp;来写的数字。例如，如果<meta charset=\"UTF-8\" />&nbsp;<code>digits = ['1','3','5']</code>，我们可以写数字，如<meta charset=\"UTF-8\" />&nbsp;<code>'13'</code>,&nbsp;<code>'551'</code>, 和&nbsp;<code>'1351315'</code>。</p>\n\n<p>返回 <em>可以生成的小于或等于给定整数 <code>n</code> 的正整数的个数</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = [\"1\",\"3\",\"5\",\"7\"], n = 100\n<strong>输出：</strong>20\n<strong>解释：</strong>\n可写出的 20 个数字是：\n1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = [\"1\",\"4\",\"9\"], n = 1000000000\n<strong>输出：</strong>29523\n<strong>解释：</strong>\n我们可以写 3 个一位数字，9 个两位数字，27 个三位数字，\n81 个四位数字，243 个五位数字，729 个六位数字，\n2187 个七位数字，6561 个八位数字和 19683 个九位数字。\n总共，可以使用D中的数字写出 29523 个整数。</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = [\"7\"], n = 8\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>1 &lt;= digits.length &lt;= 9</code></li>\n\t<li><code>digits[i].length == 1</code></li>\n\t<li><code>digits[i]</code>&nbsp;是从&nbsp;<code>'1'</code>&nbsp;到&nbsp;<code>'9'</code> 的数</li>\n\t<li><code>digits</code>&nbsp;中的所有值都 <strong>不同</strong>&nbsp;</li>\n\t<li><code>digits</code>&nbsp;按&nbsp;<strong>非递减顺序</strong>&nbsp;排列</li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 903DI 序列的有效排列",
        "hardRate": "HARD",
        "passRate": "56.43%",
        "problemsUrl": "https://leetcode.cn/problems/valid-permutations-for-di-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-permutations-for-di-sequence/solution",
        "problemsDesc": "<p>给定一个长度为 <code>n</code> 的字符串 <code>s</code> ，其中 <code>s[i]</code> 是:</p>\n\n<ul>\n\t<li><code>“D”</code> 意味着减少，或者</li>\n\t<li><code>“I”</code> 意味着增加</li>\n</ul>\n\n<p><strong>有效排列</strong>&nbsp;是对有&nbsp;<code>n + 1</code>&nbsp;个在&nbsp;<code>[0, n]</code>&nbsp; 范围内的整数的一个排列&nbsp;<code>perm</code>&nbsp;，使得对所有的&nbsp;<code>i</code>：</p>\n\n<ul>\n\t<li>如果 <code>s[i] == 'D'</code>，那么&nbsp;<code>perm[i] &gt; perm[i+1]</code>，以及；</li>\n\t<li>如果 <code>s[i] == 'I'</code>，那么 <code>perm[i] &lt; perm[i+1]</code>。</li>\n</ul>\n\n<p>返回 <em><strong>有效排列 </strong>&nbsp;</em><code>perm</code><em>的数量 </em>。因为答案可能很大，所以请<strong>返回你的答案对</strong>&nbsp;<code>10<sup>9</sup>&nbsp;+ 7</code><strong>&nbsp;取余</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"DID\"\n<strong>输出：</strong>5\n<strong>解释：</strong>\n(0, 1, 2, 3) 的五个有效排列是：\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"D\"\n<strong>输出:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>n == s.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>s[i]</code>&nbsp;不是&nbsp;<code>'I'</code>&nbsp;就是&nbsp;<code>'D'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 904水果成篮",
        "hardRate": "MEDIUM",
        "passRate": "44.83%",
        "problemsUrl": "https://leetcode.cn/problems/fruit-into-baskets/",
        "solutionsUrl": "https://leetcode.cn/problems/fruit-into-baskets/solution",
        "problemsDesc": "<p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 <code>fruits</code> 表示，其中 <code>fruits[i]</code> 是第 <code>i</code> 棵树上的水果 <strong>种类</strong> 。</p>\n\n<p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p>\n\n<ul>\n\t<li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装 <strong>单一类型</strong> 的水果。每个篮子能够装的水果总量没有限制。</li>\n\t<li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong> 树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong> 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li>\n\t<li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li>\n</ul>\n\n<p>给你一个整数数组 <code>fruits</code> ，返回你可以收集的水果的 <strong>最大</strong> 数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>fruits = [<em><strong>1,2,1</strong></em>]\n<strong>输出：</strong>3\n<strong>解释：</strong>可以采摘全部 3 棵树。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>fruits = [0,<em><strong>1,2,2</strong></em>]\n<strong>输出：</strong>3\n<strong>解释：</strong>可以采摘 [1,2,2] 这三棵树。\n如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>fruits = [1,<em><strong>2,3,2,2</strong></em>]\n<strong>输出：</strong>4\n<strong>解释：</strong>可以采摘 [2,3,2,2] 这四棵树。\n如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>fruits = [3,3,3,<em><strong>1,2,1,1,2</strong></em>,3,3,4]\n<strong>输出：</strong>5\n<strong>解释：</strong>可以采摘 [1,2,1,1,2] 这五棵树。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= fruits.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= fruits[i] &lt; fruits.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 905按奇偶排序数组",
        "hardRate": "EASY",
        "passRate": "70.97%",
        "problemsUrl": "https://leetcode.cn/problems/sort-array-by-parity/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-array-by-parity/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>，将 <code>nums</code> 中的的所有偶数元素移动到数组的前面，后跟所有奇数元素。</p>\n\n<p>返回满足此条件的 <strong>任一数组</strong> 作为答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,1,2,4]\n<strong>输出：</strong>[2,4,3,1]\n<strong>解释：</strong>[4,2,3,1]、[2,4,1,3] 和 [4,2,1,3] 也会被视作正确答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>[0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 5000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 906超级回文数",
        "hardRate": "HARD",
        "passRate": "31.77%",
        "problemsUrl": "https://leetcode.cn/problems/super-palindromes/",
        "solutionsUrl": "https://leetcode.cn/problems/super-palindromes/solution",
        "problemsDesc": "<p>如果一个正整数自身是回文数，而且它也是一个回文数的平方，那么我们称这个数为超级回文数。</p>\n\n<p>现在，给定两个正整数&nbsp;<code>L</code> 和&nbsp;<code>R</code> （以字符串形式表示），返回包含在范围 <code>[L, R]</code> 中的超级回文数的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>L = &quot;4&quot;, R = &quot;1000&quot;\n<strong>输出：</strong>4\n<strong>解释：\n</strong>4，9，121，以及 484 是超级回文数。\n注意 676 不是一个超级回文数： 26 * 26 = 676，但是 26 不是回文数。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= len(L) &lt;= 18</code></li>\n\t<li><code>1 &lt;= len(R) &lt;= 18</code></li>\n\t<li><code>L</code> 和&nbsp;<code>R</code>&nbsp;是表示&nbsp;<code>[1, 10^18)</code>&nbsp;范围的整数的字符串。</li>\n\t<li><code>int(L) &lt;= int(R)</code></li>\n</ol>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 907子数组的最小值之和",
        "hardRate": "MEDIUM",
        "passRate": "38.27%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-subarray-minimums/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-subarray-minimums/solution",
        "problemsDesc": "<p>给定一个整数数组 <code>arr</code>，找到 <code>min(b)</code> 的总和，其中 <code>b</code> 的范围为 <code>arr</code> 的每个（连续）子数组。</p>\n\n<p>由于答案可能很大，因此<strong> 返回答案模 <code>10^9 + 7</code></strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [3,1,2,4]\n<strong>输出：</strong>17\n<strong>解释：\n</strong>子数组为<strong> </strong>[3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 \n最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [11,81,94,43,3]\n<strong>输出：</strong>444\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= arr.length <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= arr[i] <= 3 * 10<sup>4</sup></code></li>\n</ul>\n\n<p> </p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 908最小差值 I",
        "hardRate": "EASY",
        "passRate": "74.37%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-range-i/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-range-i/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>，和一个整数 <code>k</code> 。</p>\n\n<p>在一个操作中，您可以选择 <code>0 &lt;= i &lt; nums.length</code> 的任何索引 <code>i</code> 。将 <code>nums[i]</code> 改为 <code>nums[i] + x</code> ，其中 <code>x</code> 是一个范围为 <code>[-k, k]</code> 的整数。对于每个索引 <code>i</code> ，最多 <strong>只能 </strong>应用 <strong>一次</strong> 此操作。</p>\n\n<p><code>nums</code>&nbsp;的&nbsp;<strong>分数&nbsp;</strong>是&nbsp;<code>nums</code>&nbsp;中最大和最小元素的差值。&nbsp;</p>\n\n<p><em>在对&nbsp; <code>nums</code> 中的每个索引最多应用一次上述操作后，返回&nbsp;<code>nums</code> 的最低 <strong>分数</strong></em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1], k = 0\n<strong>输出：</strong>0\n<strong>解释：</strong>分数是 max(nums) - min(nums) = 1 - 1 = 0。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,10], k = 2\n<strong>输出：</strong>6\n<strong>解释：</strong>将 nums 改为 [2,8]。分数是 max(nums) - min(nums) = 8 - 2 = 6。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,6], k = 3\n<strong>输出：</strong>0\n<strong>解释：</strong>将 nums 改为 [4,4,4]。分数是 max(nums) - min(nums) = 4 - 4 = 0。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 909蛇梯棋",
        "hardRate": "MEDIUM",
        "passRate": "45.85%",
        "problemsUrl": "https://leetcode.cn/problems/snakes-and-ladders/",
        "solutionsUrl": "https://leetcode.cn/problems/snakes-and-ladders/solution",
        "problemsDesc": "<p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>board</code> ，方格按从&nbsp;<code>1</code> 到 <code>n<sup>2</sup></code> 编号，编号遵循 <a href=\"https://baike.baidu.com/item/%E7%89%9B%E8%80%95%E5%BC%8F%E8%BD%AC%E8%A1%8C%E4%B9%A6%E5%86%99%E6%B3%95/17195786\">转行交替方式</a><strong> </strong>，<strong>从左下角开始</strong>&nbsp;（即，从 <code>board[n - 1][0]</code> 开始）每一行交替方向。</p>\n\n<p>玩家从棋盘上的方格&nbsp;<code>1</code> （总是在最后一行、第一列）开始出发。</p>\n\n<p>每一回合，玩家需要从当前方格 <code>curr</code> 开始出发，按下述要求前进：</p>\n\n<ul>\n\t<li>选定目标方格 <code>next</code> ，目标方格的编号符合范围&nbsp;<code>[curr + 1, min(curr + 6, n<sup>2</sup>)]</code> 。\n\n\t<ul>\n\t\t<li>该选择模拟了掷 <strong>六面体骰子</strong> 的情景，无论棋盘大小如何，玩家最多只能有 6 个目的地。</li>\n\t</ul>\n\t</li>\n\t<li>传送玩家：如果目标方格 <code>next</code> 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 <code>next</code> 。&nbsp;</li>\n\t<li>当玩家到达编号 <code>n<sup>2</sup></code> 的方格时，游戏结束。</li>\n</ul>\n\n<p><code>r</code> 行 <code>c</code> 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 <code>board[r][c] != -1</code>，那个蛇或梯子的目的地将会是 <code>board[r][c]</code>。编号为 <code>1</code> 和 <code>n<sup>2</sup></code> 的方格上没有蛇或梯子。</p>\n\n<p>注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也 <strong>不能</strong> 继续移动。</p>\n\n<ul>\n\t<li>举个例子，假设棋盘是 <code>[[-1,4],[-1,3]]</code> ，第一次移动，玩家的目标方格是 <code>2</code> 。那么这个玩家将会顺着梯子到达方格 <code>3</code> ，但 <strong>不能</strong> 顺着方格 <code>3</code> 上的梯子前往方格 <code>4</code> 。</li>\n</ul>\n\n<p>返回达到编号为&nbsp;<code>n<sup>2</sup></code> 的方格所需的最少移动次数，如果不可能，则返回 <code>-1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/09/23/snakes.png\" style=\"width: 500px; height: 394px;\" />\n<pre>\n<strong>输入：</strong>board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]\n<strong>输出：</strong>4\n<strong>解释：</strong>\n首先，从方格 1 [第 5 行，第 0 列] 开始。 \n先决定移动到方格 2 ，并必须爬过梯子移动到到方格 15 。\n然后决定移动到方格 17 [第 3 行，第 4 列]，必须爬过蛇到方格 13 。\n接着决定移动到方格 14 ，且必须通过梯子移动到方格 35 。 \n最后决定移动到方格 36 , 游戏结束。 \n可以证明需要至少 4 次移动才能到达最后一个方格，所以答案是 4 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = [[-1,-1],[-1,3]]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == board.length == board[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 20</code></li>\n\t<li><code>grid[i][j]</code> 的值是 <code>-1</code> 或在范围 <code>[1, n<sup>2</sup>]</code> 内</li>\n\t<li>编号为 <code>1</code> 和 <code>n<sup>2</sup></code> 的方格上没有蛇或梯子</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 910最小差值 II",
        "hardRate": "MEDIUM",
        "passRate": "35.66%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-range-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-range-ii/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>，和一个整数&nbsp;<code>k</code> 。</p>\n\n<p>对于每个下标 <code>i</code>（<code>0 &lt;= i &lt; nums.length</code>），将 <code>nums[i]</code> 变成<strong> </strong> <code>nums[i] + k</code> 或 <code>nums[i] - k</code> 。</p>\n\n<p><code>nums</code> 的 <strong>分数</strong> 是 <code>nums</code> 中最大元素和最小元素的差值。</p>\n\n<p>在更改每个下标对应的值之后，返回 <code>nums</code> 的最小 <strong>分数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1], k = 0\n<strong>输出：</strong>0\n<strong>解释：</strong>分数 = max(nums) - min(nums) = 1 - 1 = 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,10], k = 2\n<strong>输出：</strong>6\n<strong>解释：</strong>将数组变为 [2, 8] 。分数 = max(nums) - min(nums) = 8 - 2 = 6 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,6], k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>将数组变为 [4, 6, 3] 。分数 = max(nums) - min(nums) = 6 - 3 = 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 911在线选举",
        "hardRate": "MEDIUM",
        "passRate": "53.80%",
        "problemsUrl": "https://leetcode.cn/problems/online-election/",
        "solutionsUrl": "https://leetcode.cn/problems/online-election/solution",
        "problemsDesc": "<p>给你两个整数数组 <code>persons</code> 和 <code>times</code> 。在选举中，第&nbsp;<code>i</code>&nbsp;张票是在时刻为&nbsp;<code>times[i]</code>&nbsp;时投给候选人 <code>persons[i]</code>&nbsp;的。</p>\n\n<p>对于发生在时刻 <code>t</code> 的每个查询，需要找出在&nbsp;<code>t</code> 时刻在选举中领先的候选人的编号。</p>\n\n<p>在&nbsp;<code>t</code> 时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。</p>\n\n<p>实现 <code>TopVotedCandidate</code> 类：</p>\n\n<ul>\n\t<li><code>TopVotedCandidate(int[] persons, int[] times)</code> 使用&nbsp;<code>persons</code> 和 <code>times</code> 数组初始化对象。</li>\n\t<li><code>int q(int t)</code> 根据前面描述的规则，返回在时刻 <code>t</code> 在选举中领先的候选人的编号。</li>\n</ul>\n&nbsp;\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"TopVotedCandidate\", \"q\", \"q\", \"q\", \"q\", \"q\", \"q\"]\n[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]\n<strong>输出：</strong>\n[null, 0, 1, 1, 0, 0, 1]\n\n<strong>解释：</strong>\nTopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);\ntopVotedCandidate.q(3); // 返回 0 ，在时刻 3 ，票数分布为 [0] ，编号为 0 的候选人领先。\ntopVotedCandidate.q(12); // 返回 1 ，在时刻 12 ，票数分布为 [0,1,1] ，编号为 1 的候选人领先。\ntopVotedCandidate.q(25); // 返回 1 ，在时刻 25 ，票数分布为 [0,1,1,0,0,1] ，编号为 1 的候选人领先。（在平局的情况下，1 是最近获得投票的候选人）。\ntopVotedCandidate.q(15); // 返回 0\ntopVotedCandidate.q(24); // 返回 0\ntopVotedCandidate.q(8); // 返回 1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= persons.length &lt;= 5000</code></li>\n\t<li><code>times.length == persons.length</code></li>\n\t<li><code>0 &lt;= persons[i] &lt; persons.length</code></li>\n\t<li><code>0 &lt;= times[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>times</code> 是一个严格递增的有序数组</li>\n\t<li><code>times[0] &lt;= t &lt;= 10<sup>9</sup></code></li>\n\t<li>每个测试用例最多调用 <code>10<sup>4</sup></code> 次 <code>q</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 912排序数组",
        "hardRate": "MEDIUM",
        "passRate": "51.78%",
        "problemsUrl": "https://leetcode.cn/problems/sort-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>，请你将该数组升序排列。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,2,3,1]\n<strong>输出：</strong>[1,2,3,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,1,1,2,0,0]\n<strong>输出：</strong>[0,0,1,1,2,5]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-5 * 10<sup>4</sup> &lt;= nums[i] &lt;= 5 * 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 913猫和老鼠",
        "hardRate": "HARD",
        "passRate": "53.97%",
        "problemsUrl": "https://leetcode.cn/problems/cat-and-mouse/",
        "solutionsUrl": "https://leetcode.cn/problems/cat-and-mouse/solution",
        "problemsDesc": "<p>两位玩家分别扮演猫和老鼠，在一张 <strong>无向</strong> 图上进行游戏，两人轮流行动。</p>\n\n<p>图的形式是：<code>graph[a]</code> 是一个列表，由满足&nbsp;<code>ab</code> 是图中的一条边的所有节点 <code>b</code> 组成。</p>\n\n<p>老鼠从节点 <code>1</code> 开始，第一个出发；猫从节点 <code>2</code> 开始，第二个出发。在节点 <code>0</code> 处有一个洞。</p>\n\n<p>在每个玩家的行动中，他们 <strong>必须</strong> 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 <code>1</code> ，那么它必须移动到 <code>graph[1]</code> 中的任一节点。</p>\n\n<p>此外，猫无法移动到洞中（节点 <code>0</code>）。</p>\n\n<p>然后，游戏在出现以下三种情形之一时结束：</p>\n\n<ul>\n\t<li>如果猫和老鼠出现在同一个节点，猫获胜。</li>\n\t<li>如果老鼠到达洞中，老鼠获胜。</li>\n\t<li>如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。</li>\n</ul>\n\n<p>给你一张图 <code>graph</code> ，并假设两位玩家都都以最佳状态参与游戏：</p>\n\n<ul>\n\t<li>如果老鼠获胜，则返回&nbsp;<code>1</code>；</li>\n\t<li>如果猫获胜，则返回 <code>2</code>；</li>\n\t<li>如果平局，则返回 <code>0</code> 。</li>\n</ul>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/17/cat1.jpg\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>输入：</strong>graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/17/cat2.jpg\" style=\"width: 200px; height: 200px;\" />\n<pre>\n<strong>输入：</strong>graph = [[1,3],[0],[3],[0,2]]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= graph.length &lt;= 50</code></li>\n\t<li><code>1&nbsp;&lt;= graph[i].length &lt; graph.length</code></li>\n\t<li><code>0 &lt;= graph[i][j] &lt; graph.length</code></li>\n\t<li><code>graph[i][j] != i</code></li>\n\t<li><code>graph[i]</code> 互不相同</li>\n\t<li>猫和老鼠在游戏中总是可以移动</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 914卡牌分组",
        "hardRate": "EASY",
        "passRate": "37.48%",
        "problemsUrl": "https://leetcode.cn/problems/x-of-a-kind-in-a-deck-of-cards/",
        "solutionsUrl": "https://leetcode.cn/problems/x-of-a-kind-in-a-deck-of-cards/solution",
        "problemsDesc": "<p>给定一副牌，每张牌上都写着一个整数。</p>\n\n<p>此时，你需要选定一个数字 <code>X</code>，使我们可以将整副牌按下述规则分成 1 组或更多组：</p>\n\n<ul>\n\t<li>每组都有&nbsp;<code>X</code>&nbsp;张牌。</li>\n\t<li>组内所有的牌上都写着相同的整数。</li>\n</ul>\n\n<p>仅当你可选的 <code>X &gt;= 2</code> 时返回&nbsp;<code>true</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>deck = [1,2,3,4,4,3,2,1]\n<strong>输出：</strong>true\n<strong>解释：</strong>可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>deck = [1,1,1,2,2,2,3,3]\n<strong>输出：</strong>false\n<strong>解释：</strong>没有满足要求的分组。\n</pre>\n\n<p><br />\n<strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= deck.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= deck[i] &lt; 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 915分割数组",
        "hardRate": "MEDIUM",
        "passRate": "50.09%",
        "problemsUrl": "https://leetcode.cn/problems/partition-array-into-disjoint-intervals/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-array-into-disjoint-intervals/solution",
        "problemsDesc": "<p>给定一个数组&nbsp;<code>nums</code>&nbsp;，将其划分为两个连续子数组&nbsp;<code>left</code>&nbsp;和&nbsp;<code>right</code>，&nbsp;使得：</p>\n\n<ul>\n\t<li><code>left</code>&nbsp;中的每个元素都小于或等于&nbsp;<code>right</code>&nbsp;中的每个元素。</li>\n\t<li><code>left</code> 和&nbsp;<code>right</code>&nbsp;都是非空的。</li>\n\t<li><code>left</code> 的长度要尽可能小。</li>\n</ul>\n\n<p><em>在完成这样的分组后返回&nbsp;<code>left</code>&nbsp;的&nbsp;<strong>长度&nbsp;</strong></em>。</p>\n\n<p>用例可以保证存在这样的划分方法。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,0,3,8,6]\n<strong>输出：</strong>3\n<strong>解释：</strong>left = [5,0,3]，right = [8,6]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,0,6,12]\n<strong>输出：</strong>4\n<strong>解释：</strong>left = [1,1,1,0]，right = [6,12]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n\t<li>可以保证至少有一种方法能够按题目所描述的那样对 <code>nums</code> 进行划分。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 916单词子集",
        "hardRate": "MEDIUM",
        "passRate": "46.20%",
        "problemsUrl": "https://leetcode.cn/problems/word-subsets/",
        "solutionsUrl": "https://leetcode.cn/problems/word-subsets/solution",
        "problemsDesc": "<p>给你两个字符串数组 <code>words1</code>&nbsp;和&nbsp;<code>words2</code>。</p>\n\n<p>现在，如果&nbsp;<code>b</code> 中的每个字母都出现在 <code>a</code> 中，<strong>包括重复出现的字母</strong>，那么称字符串 <code>b</code> 是字符串 <code>a</code> 的 <strong>子集</strong> 。</p>\n\n<ul>\n\t<li>例如，<code>\"wrr\"</code> 是 <code>\"warrior\"</code> 的子集，但不是 <code>\"world\"</code> 的子集。</li>\n</ul>\n\n<p>如果对 <code>words2</code> 中的每一个单词&nbsp;<code>b</code>，<code>b</code> 都是 <code>a</code> 的子集，那么我们称&nbsp;<code>words1</code> 中的单词 <code>a</code> 是<em> </em><strong>通用单词</strong><em> </em>。</p>\n\n<p>以数组形式返回&nbsp;<code>words1</code> 中所有的通用单词。你可以按 <strong>任意顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"e\",\"o\"]\n<strong>输出：</strong>[\"facebook\",\"google\",\"leetcode\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"l\",\"e\"]\n<strong>输出：</strong>[\"apple\",\"google\",\"leetcode\"]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"e\",\"oo\"]\n<strong>输出：</strong>[\"facebook\",\"google\"]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"lo\",\"eo\"]\n<strong>输出：</strong>[\"google\",\"leetcode\"]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"ec\",\"oc\",\"ceo\"]\n<strong>输出：</strong>[\"facebook\",\"leetcode\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words1.length, words2.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words1[i].length, words2[i].length &lt;= 10</code></li>\n\t<li><code>words1[i]</code> 和 <code>words2[i]</code> 仅由小写英文字母组成</li>\n\t<li><code>words1</code> 中的所有字符串 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 917仅仅反转字母",
        "hardRate": "EASY",
        "passRate": "59.37%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-only-letters/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-only-letters/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，根据下述规则反转字符串：</p>\n\n<ul>\n\t<li>所有非英文字母保留在原有位置。</li>\n\t<li>所有英文字母（小写或大写）位置反转。</li>\n</ul>\n\n<p>返回反转后的 <code>s</code><em> 。</em></p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ab-cd\"\n<strong>输出：</strong>\"dc-ba\"\n</pre>\n\n<ol>\n</ol>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a-bC-dEf-ghIj\"\n<strong>输出：</strong>\"j-Ih-gfE-dCba\"\n</pre>\n\n<ol>\n</ol>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"Test1ng-Leet=code-Q!\"\n<strong>输出：</strong>\"Qedo1ct-eeLg=ntse-T!\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 仅由 ASCII 值在范围 <code>[33, 122]</code> 的字符组成</li>\n\t<li><code>s</code> 不含 <code>'\\\"'</code> 或 <code>'\\\\'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 918环形子数组的最大和",
        "hardRate": "MEDIUM",
        "passRate": "37.78%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-circular-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-circular-subarray/solution",
        "problemsDesc": "<p>给定一个长度为 <code>n</code> 的<strong>环形整数数组</strong>&nbsp;<code>nums</code>&nbsp;，返回<em>&nbsp;<code>nums</code>&nbsp;的非空 <strong>子数组</strong> 的最大可能和&nbsp;</em>。</p>\n\n<p><strong>环形数组</strong><em>&nbsp;</em>意味着数组的末端将会与开头相连呈环状。形式上， <code>nums[i]</code> 的下一个元素是 <code>nums[(i + 1) % n]</code> ， <code>nums[i]</code>&nbsp;的前一个元素是 <code>nums[(i - 1 + n) % n]</code> 。</p>\n\n<p><strong>子数组</strong> 最多只能包含固定缓冲区&nbsp;<code>nums</code>&nbsp;中的每个元素一次。形式上，对于子数组&nbsp;<code>nums[i], nums[i + 1], ..., nums[j]</code>&nbsp;，不存在&nbsp;<code>i &lt;= k1, k2 &lt;= j</code>&nbsp;其中&nbsp;<code>k1 % n == k2 % n</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,-2,3,-2]\n<strong>输出：</strong>3\n<strong>解释：</strong>从子数组 [3] 得到最大和 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,-3,5]\n<strong>输出：</strong>10\n<strong>解释：</strong>从子数组 [5,5] 得到最大和 5 + 5 = 10\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,-2,2,-3]\n<strong>输出：</strong>3\n<strong>解释：</strong>从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-3 * 10<sup>4</sup>&nbsp;&lt;= nums[i] &lt;= 3 * 10<sup>4</sup></code>​​​​​​​</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 919完全二叉树插入器",
        "hardRate": "MEDIUM",
        "passRate": "66.91%",
        "problemsUrl": "https://leetcode.cn/problems/complete-binary-tree-inserter/",
        "solutionsUrl": "https://leetcode.cn/problems/complete-binary-tree-inserter/solution",
        "problemsDesc": "<p><strong>完全二叉树</strong> 是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。</p>\n\n<p>设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。</p>\n\n<p>实现 <code>CBTInserter</code> 类:</p>\n\n<ul>\n\t<li><code>CBTInserter(TreeNode root)</code>&nbsp;使用头节点为&nbsp;<code>root</code>&nbsp;的给定树初始化该数据结构；</li>\n\t<li><code>CBTInserter.insert(int v)</code>&nbsp; 向树中插入一个值为&nbsp;<code>Node.val == val</code>的新节点&nbsp;<code>TreeNode</code>。使树保持完全二叉树的状态，<strong>并返回插入节点</strong>&nbsp;<code>TreeNode</code>&nbsp;<strong>的父节点的值</strong>；</li>\n\t<li><code>CBTInserter.get_root()</code> 将返回树的头节点。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/03/lc-treeinsert.jpg\" style=\"height: 143px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入</strong>\n[\"CBTInserter\", \"insert\", \"insert\", \"get_root\"]\n[[[1, 2]], [3], [4], []]\n<strong>输出</strong>\n[null, 1, 2, [1, 2, 3, 4]]\n\n<strong>解释</strong>\nCBTInserter cBTInserter = new CBTInserter([1, 2]);\ncBTInserter.insert(3);  // 返回 1\ncBTInserter.insert(4);  // 返回 2\ncBTInserter.get_root(); // 返回 [1, 2, 3, 4]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数量范围为&nbsp;<code>[1, 1000]</code>&nbsp;</li>\n\t<li><code>0 &lt;= Node.val &lt;= 5000</code></li>\n\t<li><code>root</code>&nbsp;是完全二叉树</li>\n\t<li><code>0 &lt;= val &lt;= 5000</code>&nbsp;</li>\n\t<li>每个测试用例最多调用&nbsp;<code>insert</code>&nbsp;和&nbsp;<code>get_root</code>&nbsp;操作&nbsp;<code>10<sup>4</sup></code>&nbsp;次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 920播放列表的数量",
        "hardRate": "HARD",
        "passRate": "52.09%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-music-playlists/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-music-playlists/solution",
        "problemsDesc": "<p>你的音乐播放器里有 <code>n</code> 首不同的歌，在旅途中，你计划听 <code>goal</code> 首歌（不一定不同，即，允许歌曲重复）。你将会按如下规则创建播放列表：</p>\n\n<ul>\n\t<li>每首歌 <strong>至少播放一次</strong> 。</li>\n\t<li>一首歌只有在其他 <code>k</code> 首歌播放完之后才能再次播放。</li>\n</ul>\n\n<p>给你 <code>n</code>、<code>goal</code> 和 <code>k</code> ，返回可以满足要求的播放列表的数量。由于答案可能非常大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, goal = 3, k = 1\n<strong>输出：</strong>6\n<strong>解释：</strong>有 6 种可能的播放列表。[1, 2, 3]，[1, 3, 2]，[2, 1, 3]，[2, 3, 1]，[3, 1, 2]，[3, 2, 1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, goal = 3, k = 0\n<strong>输出：</strong>6\n<strong>解释：</strong>有 6 种可能的播放列表。[1, 1, 2]，[1, 2, 1]，[2, 1, 1]，[2, 2, 1]，[2, 1, 2]，[1, 2, 2] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, goal = 3, k = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>有 2 种可能的播放列表。[1, 2, 1]，[2, 1, 2] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= k &lt; n &lt;= goal &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 921使括号有效的最少添加",
        "hardRate": "MEDIUM",
        "passRate": "73.03%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/solution",
        "problemsDesc": "<p>只有满足下面几点之一，括号字符串才是有效的：</p>\n\n<ul>\n\t<li>它是一个空字符串，或者</li>\n\t<li>它可以被写成&nbsp;<code>AB</code>&nbsp;（<code>A</code>&nbsp;与&nbsp;<code>B</code>&nbsp;连接）, 其中&nbsp;<code>A</code> 和&nbsp;<code>B</code>&nbsp;都是有效字符串，或者</li>\n\t<li>它可以被写作&nbsp;<code>(A)</code>，其中&nbsp;<code>A</code>&nbsp;是有效字符串。</li>\n</ul>\n\n<p>给定一个括号字符串 <code>s</code> ，在每一次操作中，你都可以在字符串的任何位置插入一个括号</p>\n\n<ul>\n\t<li>例如，如果 <code>s = \"()))\"</code> ，你可以插入一个开始括号为 <code>\"(()))\"</code> 或结束括号为 <code>\"())))\"</code> 。</li>\n</ul>\n\n<p>返回 <em>为使结果字符串 <code>s</code> 有效而必须添加的最少括号数</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"())\"\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(((\"\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> 只包含&nbsp;<code>'('</code> 和&nbsp;<code>')'</code>&nbsp;字符。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 922按奇偶排序数组 II",
        "hardRate": "EASY",
        "passRate": "71.34%",
        "problemsUrl": "https://leetcode.cn/problems/sort-array-by-parity-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-array-by-parity-ii/solution",
        "problemsDesc": "<p>给定一个非负整数数组&nbsp;<code>nums</code>，&nbsp;&nbsp;<code>nums</code> 中一半整数是 <strong>奇数</strong> ，一半整数是 <strong>偶数</strong> 。</p>\n\n<p>对数组进行排序，以便当&nbsp;<code>nums[i]</code> 为奇数时，<code>i</code>&nbsp;也是 <strong>奇数</strong> ；当&nbsp;<code>nums[i]</code>&nbsp;为偶数时， <code>i</code> 也是 <strong>偶数</strong> 。</p>\n\n<p>你可以返回 <em>任何满足上述条件的数组作为答案</em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,2,5,7]\n<strong>输出：</strong>[4,5,2,7]\n<strong>解释：</strong>[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,3]\n<b>输出：</b>[2,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>nums.length</code>&nbsp;是偶数</li>\n\t<li><code>nums</code>&nbsp;中一半是偶数</li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>可以不使用额外空间解决问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 923三数之和的多种可能",
        "hardRate": "MEDIUM",
        "passRate": "36.94%",
        "problemsUrl": "https://leetcode.cn/problems/3sum-with-multiplicity/",
        "solutionsUrl": "https://leetcode.cn/problems/3sum-with-multiplicity/solution",
        "problemsDesc": "<p>给定一个整数数组<meta charset=\"UTF-8\" />&nbsp;<code>arr</code>&nbsp;，以及一个整数&nbsp;<code>target</code>&nbsp;作为目标值，返回满足 <code>i &lt; j &lt; k</code> 且<meta charset=\"UTF-8\" />&nbsp;<code>arr[i] + arr[j] + arr[k] == target</code>&nbsp;的元组&nbsp;<code>i, j, k</code>&nbsp;的数量。</p>\n\n<p>由于结果会非常大，请返回 <code>10<sup>9</sup>&nbsp;+ 7</code>&nbsp;的模。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,1,2,2,3,3,4,4,5,5], target = 8\n<strong>输出：</strong>20\n<strong>解释：</strong>\n按值枚举(arr[i], arr[j], arr[k])：\n(1, 2, 5) 出现 8 次；\n(1, 3, 4) 出现 8 次；\n(2, 2, 4) 出现 2 次；\n(2, 3, 3) 出现 2 次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,1,2,2,2,2], target = 5\n<strong>输出：</strong>12\n<strong>解释：</strong>\narr[i] = 1, arr[j] = arr[k] = 2 出现 12 次：\n我们从 [1,1] 中选择一个 1，有 2 种情况，\n从 [2,2,2,2] 中选出两个 2，有 6 种情况。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= arr.length &lt;= 3000</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 100</code></li>\n\t<li><code>0 &lt;= target &lt;= 300</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 924尽量减少恶意软件的传播",
        "hardRate": "HARD",
        "passRate": "35.86%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-malware-spread/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-malware-spread/solution",
        "problemsDesc": "<p>给出了一个由 <code>n</code> 个节点组成的网络，用 <code>n × n</code> 个邻接矩阵图<meta charset=\"UTF-8\" />&nbsp;<code>graph</code>&nbsp;表示。在节点网络中，当 <code>graph[i][j] = 1</code>&nbsp;时，表示节点&nbsp;<code>i</code>&nbsp;能够直接连接到另一个节点 <code>j</code>。&nbsp;</p>\n\n<p>一些节点&nbsp;<code>initial</code>&nbsp;最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。</p>\n\n<p>假设 <code>M(initial)</code> 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。</p>\n\n<p>如果从&nbsp;<code>initial</code>&nbsp;中<strong>移除某一节点</strong>能够最小化 <code>M(initial)</code>， 返回该节点。如果有多个节点满足条件，就返回<strong>索引最小</strong>的节点。</p>\n\n<p>请注意，如果某个节点已从受感染节点的列表 <code>initial</code> 中删除，它以后仍有可能因恶意软件传播而受到感染。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>n == graph.length</code></li>\n\t<li><code>n == graph[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 300</code></li>\n\t<li><code>graph[i][j]&nbsp;==&nbsp;0</code>&nbsp;或&nbsp;<code>1</code>.</li>\n\t<li><code>graph[i][j] == graph[j][i]</code></li>\n\t<li><code>graph[i][i] == 1</code></li>\n\t<li><code>1 &lt;= initial.length &lt;= n</code></li>\n\t<li><code>0 &lt;= initial[i] &lt;= n - 1</code></li>\n\t<li><code>initial</code>&nbsp;中所有整数均<strong>不重复</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 925长按键入",
        "hardRate": "EASY",
        "passRate": "37.45%",
        "problemsUrl": "https://leetcode.cn/problems/long-pressed-name/",
        "solutionsUrl": "https://leetcode.cn/problems/long-pressed-name/solution",
        "problemsDesc": "<p>你的朋友正在使用键盘输入他的名字&nbsp;<code>name</code>。偶尔，在键入字符&nbsp;<code>c</code>&nbsp;时，按键可能会被<em>长按</em>，而字符可能被输入 1 次或多次。</p>\n\n<p>你将会检查键盘输入的字符&nbsp;<code>typed</code>。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回&nbsp;<code>True</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>name = \"alex\", typed = \"aaleex\"\n<strong>输出：</strong>true\n<strong>解释：</strong>'alex' 中的 'a' 和 'e' 被长按。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>name = \"saeed\", typed = \"ssaaedd\"\n<strong>输出：</strong>false\n<strong>解释：</strong>'e' 一定需要被键入两次，但在 typed 的输出中不是这样。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= name.length, typed.length &lt;= 1000</code></li>\n\t<li><code>name</code> 和&nbsp;<code>typed</code>&nbsp;的字符都是小写字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 926将字符串翻转到单调递增",
        "hardRate": "MEDIUM",
        "passRate": "63.49%",
        "problemsUrl": "https://leetcode.cn/problems/flip-string-to-monotone-increasing/",
        "solutionsUrl": "https://leetcode.cn/problems/flip-string-to-monotone-increasing/solution",
        "problemsDesc": "<p>如果一个二进制字符串，是以一些 <code>0</code>（可能没有 <code>0</code>）后面跟着一些 <code>1</code>（也可能没有 <code>1</code>）的形式组成的，那么该字符串是 <strong>单调递增 </strong>的。</p>\n\n<p>给你一个二进制字符串 <code>s</code>，你可以将任何 <code>0</code> 翻转为 <code>1</code> 或者将 <code>1</code> 翻转为 <code>0</code> 。</p>\n\n<p>返回使 <code>s</code> 单调递增的最小翻转次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"00110\"\n<strong>输出：</strong>1\n<strong>解释：</strong>翻转最后一位得到 00111.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"010110\"\n<strong>输出：</strong>2\n<strong>解释：</strong>翻转得到 011111，或者是 000111。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"00011000\"\n<strong>输出：</strong>2\n<strong>解释：</strong>翻转得到 00000000。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 927三等分",
        "hardRate": "HARD",
        "passRate": "43.87%",
        "problemsUrl": "https://leetcode.cn/problems/three-equal-parts/",
        "solutionsUrl": "https://leetcode.cn/problems/three-equal-parts/solution",
        "problemsDesc": "<p>给定一个由 <code>0</code> 和 <code>1</code> 组成的数组<meta charset=\"UTF-8\" />&nbsp;<code>arr</code>&nbsp;，将数组分成 &nbsp;<strong>3&nbsp;个非空的部分</strong> ，使得所有这些部分表示相同的二进制值。</p>\n\n<p>如果可以做到，请返回<strong>任何</strong>&nbsp;<code>[i, j]</code>，其中 <code>i+1 &lt; j</code>，这样一来：</p>\n\n<ul>\n\t<li><code>arr[0], arr[1], ..., arr[i]</code>&nbsp;为第一部分；</li>\n\t<li><code>arr[i + 1], arr[i + 2], ..., arr[j - 1]</code>&nbsp;为第二部分；</li>\n\t<li><code>arr[j], arr[j + 1], ..., arr[arr.length - 1]</code>&nbsp;为第三部分。</li>\n\t<li>这三个部分所表示的二进制值相等。</li>\n</ul>\n\n<p>如果无法做到，就返回&nbsp;<code>[-1, -1]</code>。</p>\n\n<p>注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如，<code>[1,1,0]</code>&nbsp;表示十进制中的&nbsp;<code>6</code>，而不会是&nbsp;<code>3</code>。此外，前导零也是<strong>被允许</strong>的，所以&nbsp;<code>[0,1,1]</code> 和&nbsp;<code>[1,1]</code>&nbsp;表示相同的值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,0,1,0,1]\n<strong>输出：</strong>[0,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,1,0,1,1]\n<strong>输出：</strong>[-1,-1]</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,1,0,0,1]\n<strong>输出：</strong>[0,2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>3 &lt;= arr.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>arr[i]</code>&nbsp;是&nbsp;<code>0</code>&nbsp;或&nbsp;<code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 928尽量减少恶意软件的传播 II",
        "hardRate": "HARD",
        "passRate": "43.74%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-malware-spread-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-malware-spread-ii/solution",
        "problemsDesc": "<p>给定一个由 <code>n</code> 个节点组成的网络，用 <code>n x n</code> 个邻接矩阵&nbsp;<code>graph</code>&nbsp;表示。在节点网络中，只有当&nbsp;<code>graph[i][j] = 1</code>&nbsp;时，节点&nbsp;<code>i</code>&nbsp;能够直接连接到另一个节点&nbsp;<code>j</code>。</p>\n\n<p>一些节点&nbsp;<code>initial</code>&nbsp;最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。</p>\n\n<p>假设&nbsp;<code>M(initial)</code>&nbsp;是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。</p>\n\n<p>我们可以从 <code>initial</code> 中<strong>删除一个节点</strong>，<strong>并完全移除该节点以及从该节点到任何其他节点的任何连接。</strong></p>\n\n<p>请返回移除后能够使&nbsp;<code>M(initial)</code>&nbsp;最小化的节点。如果有多个节点满足条件，返回索引 <strong>最小的节点</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输出：</strong>graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\n<strong>输入：</strong>0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>n == graph.length</code></li>\n\t<li><code>n == graph[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 300</code></li>\n\t<li><code>graph[i][j]</code>&nbsp;是&nbsp;<code>0</code>&nbsp;或&nbsp;<code>1</code>.</li>\n\t<li><code>graph[i][j] == graph[j][i]</code></li>\n\t<li><code>graph[i][i] == 1</code></li>\n\t<li><code>1 &lt;= initial.length &lt;&nbsp;n</code></li>\n\t<li><code>0 &lt;= initial[i] &lt;= n - 1</code></li>\n\t<li>&nbsp;<code>initial</code>&nbsp;中每个整数都<strong>不同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 929独特的电子邮件地址",
        "hardRate": "EASY",
        "passRate": "68.61%",
        "problemsUrl": "https://leetcode.cn/problems/unique-email-addresses/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-email-addresses/solution",
        "problemsDesc": "<p>每个 <strong>有效电子邮件地址</strong> 都由一个 <strong>本地名</strong> 和一个 <strong>域名</strong> 组成，以 <code>'@'</code> 符号分隔。除小写字母之外，电子邮件地址还可以含有一个或多个&nbsp;<code>'.'</code> 或 <code>'+'</code> 。</p>\n\n<ul>\n\t<li>例如，在&nbsp;<code>alice@leetcode.com</code>中，&nbsp;<code>alice</code>&nbsp;是 <strong>本地名</strong> ，而&nbsp;<code>leetcode.com</code>&nbsp;是 <strong>域名</strong> 。</li>\n</ul>\n\n<p>如果在电子邮件地址的<strong> 本地名 </strong>部分中的某些字符之间添加句点（<code>'.'</code>），则发往那里的邮件将会转发到本地名中没有点的同一地址。请注意，此规则 <strong>不适用于域名</strong> 。</p>\n\n<ul>\n\t<li>例如，<code>\"alice.z@leetcode.com”</code> 和 <code>“alicez@leetcode.com”</code>&nbsp;会转发到同一电子邮件地址。</li>\n</ul>\n\n<p>如果在<strong> 本地名 </strong>中添加加号（<code>'+'</code>），则会忽略第一个加号后面的所有内容。这允许过滤某些电子邮件。同样，此规则 <strong>不适用于域名</strong> 。</p>\n\n<ul>\n\t<li>例如 <code>m.y+name@email.com</code> 将转发到 <code>my@email.com</code>。</li>\n</ul>\n\n<p>可以同时使用这两个规则。</p>\n\n<p>给你一个字符串数组 <code>emails</code>，我们会向每个 <code>emails[i]</code> 发送一封电子邮件。返回实际收到邮件的不同地址数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>emails = [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\n<strong>输出：</strong>2\n<strong>解释：</strong>实际收到邮件的是 \"testemail@leetcode.com\" 和 \"testemail@lee.tcode.com\"。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>emails = [\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"]\n<strong>输出：</strong>3\n</pre>\n\n<p><br />\n<strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= emails.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= emails[i].length&nbsp;&lt;= 100</code></li>\n\t<li><code>emails[i]</code> 由小写英文字母、<code>'+'</code>、<code>'.'</code> 和 <code>'@'</code> 组成</li>\n\t<li>每个 <code>emails[i]</code> 都包含有且仅有一个 <code>'@'</code> 字符</li>\n\t<li>所有本地名和域名都不为空</li>\n\t<li>本地名不会以 <code>'+'</code> 字符作为开头</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 930和相同的二元子数组",
        "hardRate": "MEDIUM",
        "passRate": "55.10%",
        "problemsUrl": "https://leetcode.cn/problems/binary-subarrays-with-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-subarrays-with-sum/solution",
        "problemsDesc": "<p>给你一个二元数组 <code>nums</code> ，和一个整数 <code>goal</code> ，请你统计并返回有多少个和为 <code>goal</code> 的<strong> 非空</strong> 子数组。</p>\n\n<p><strong>子数组</strong> 是数组的一段连续部分。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,0,1,0,1], goal = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>\n有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,0,0,0,0], goal = 0\n<strong>输出：</strong>15\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code></li>\n\t<li><code>0 <= goal <= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 931下降路径最小和",
        "hardRate": "MEDIUM",
        "passRate": "67.08%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-falling-path-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-falling-path-sum/solution",
        "problemsDesc": "<p>给你一个 <code>n x n</code> 的<strong> 方形 </strong>整数数组&nbsp;<code>matrix</code> ，请你找出并返回通过 <code>matrix</code> 的<strong>下降路径</strong><em> </em>的<strong> </strong><strong>最小和</strong> 。</p>\n\n<p><strong>下降路径</strong> 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 <code>(row, col)</code> 的下一个元素应当是 <code>(row + 1, col - 1)</code>、<code>(row + 1, col)</code> 或者 <code>(row + 1, col + 1)</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/03/failing1-grid.jpg\" style=\"height: 500px; width: 499px;\" /></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[2,1,3],[6,5,4],[7,8,9]]\n<strong>输出：</strong>13\n<strong>解释：</strong>如图所示，为和最小的两条下降路径\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/03/failing2-grid.jpg\" style=\"height: 365px; width: 164px;\" /></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[-19,57],[-40,-5]]\n<strong>输出：</strong>-59\n<strong>解释：</strong>如图所示，为和最小的下降路径\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == matrix.length == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 932漂亮数组",
        "hardRate": "MEDIUM",
        "passRate": "65.64%",
        "problemsUrl": "https://leetcode.cn/problems/beautiful-array/",
        "solutionsUrl": "https://leetcode.cn/problems/beautiful-array/solution",
        "problemsDesc": "<p>如果长度为 <code>n</code> 的数组 <code>nums</code> 满足下述条件，则认为该数组是一个 <strong>漂亮数组</strong> ：</p>\n\n<ul>\n\t<li><code>nums</code> 是由范围 <code>[1, n]</code> 的整数组成的一个排列。</li>\n\t<li>对于每个 <code>0 &lt;= i &lt; j &lt; n</code> ，均不存在下标 <code>k</code>（<code>i &lt; k &lt; j</code>）使得 <code>2 * nums[k] == nums[i] + nums[j]</code> 。</li>\n</ul>\n\n<p>给你整数 <code>n</code> ，返回长度为 <code>n</code> 的任一 <strong>漂亮数组</strong> 。本题保证对于给定的 <code>n</code> 至少存在一个有效答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>[2,1,4,3]\n</pre>\n\n<p><strong class=\"example\">示例 2 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>[3,1,2,5,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 933最近的请求次数",
        "hardRate": "EASY",
        "passRate": "76.76%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-recent-calls/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-recent-calls/solution",
        "problemsDesc": "<p>写一个&nbsp;<code>RecentCounter</code>&nbsp;类来计算特定时间范围内最近的请求。</p>\n\n<p>请你实现 <code>RecentCounter</code> 类：</p>\n\n<ul>\n\t<li><code>RecentCounter()</code> 初始化计数器，请求数为 0 。</li>\n\t<li><code>int ping(int t)</code> 在时间 <code>t</code> 添加一个新请求，其中 <code>t</code> 表示以毫秒为单位的某个时间，并返回过去 <code>3000</code> 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 <code>[t-3000, t]</code> 内发生的请求数。</li>\n</ul>\n\n<p><strong>保证</strong> 每次对 <code>ping</code> 的调用都使用比之前更大的 <code>t</code> 值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"RecentCounter\", \"ping\", \"ping\", \"ping\", \"ping\"]\n[[], [1], [100], [3001], [3002]]\n<strong>输出：</strong>\n[null, 1, 2, 3, 3]\n\n<strong>解释：</strong>\nRecentCounter recentCounter = new RecentCounter();\nrecentCounter.ping(1);     // requests = [<strong>1</strong>]，范围是 [-2999,1]，返回 1\nrecentCounter.ping(100);   // requests = [<strong>1</strong>, <strong>100</strong>]，范围是 [-2900,100]，返回 2\nrecentCounter.ping(3001);  // requests = [<strong>1</strong>, <strong>100</strong>, <strong>3001</strong>]，范围是 [1,3001]，返回 3\nrecentCounter.ping(3002);  // requests = [1, <strong>100</strong>, <strong>3001</strong>, <strong>3002</strong>]，范围是 [2,3002]，返回 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= t &lt;= 10<sup>9</sup></code></li>\n\t<li>保证每次对 <code>ping</code> 调用所使用的 <code>t</code> 值都 <strong>严格递增</strong></li>\n\t<li>至多调用 <code>ping</code> 方法 <code>10<sup>4</sup></code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 934最短的桥",
        "hardRate": "MEDIUM",
        "passRate": "52.42%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-bridge/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-bridge/solution",
        "problemsDesc": "<p>给你一个大小为 <code>n x n</code> 的二元矩阵 <code>grid</code> ，其中 <code>1</code> 表示陆地，<code>0</code> 表示水域。</p>\n\n<p><strong>岛</strong> 是由四面相连的 <code>1</code> 形成的一个最大组，即不会与非组内的任何其他 <code>1</code> 相连。<code>grid</code> 中 <strong>恰好存在两座岛</strong> 。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>你可以将任意数量的 <code>0</code> 变为 <code>1</code> ，以使两座岛连接起来，变成 <strong>一座岛</strong> 。</p>\n\n<p>返回必须翻转的 <code>0</code> 的最小数目。</p>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,1],[1,0]]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,1,0],[0,0,0],[0,0,1]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n\t<li><code>grid</code> 中恰有两个岛</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 935骑士拨号器",
        "hardRate": "MEDIUM",
        "passRate": "51.51%",
        "problemsUrl": "https://leetcode.cn/problems/knight-dialer/",
        "solutionsUrl": "https://leetcode.cn/problems/knight-dialer/solution",
        "problemsDesc": "<p>象棋骑士有一个<strong>独特的移动方式</strong>，它可以垂直移动两个方格，水平移动一个方格，或者水平移动两个方格，垂直移动一个方格(两者都形成一个&nbsp;<strong>L&nbsp;</strong>的形状)。</p>\n\n<p>象棋骑士可能的移动方式如下图所示:</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/18/chess.jpg\" style=\"height: 200px; width: 200px;\" /></p>\n\n<p>我们有一个象棋骑士和一个电话垫，如下所示，骑士<strong>只能站在一个数字单元格上</strong>(即蓝色单元格)。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/18/phone.jpg\" style=\"height: 200px; width: 150px;\" /></p>\n\n<p>给定一个整数 n，返回我们可以拨多少个长度为 n 的不同电话号码。</p>\n\n<p>你可以将骑士放置在<strong>任何数字单元格</strong>上，然后你应该执行 n - 1 次移动来获得长度为 n 的号码。所有的跳跃应该是<strong>有效</strong>的骑士跳跃。</p>\n\n<p>因为答案可能很大，<strong>所以输出答案模&nbsp;</strong><code>10<sup>9</sup>&nbsp;+ 7</code>.</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>10\n<strong>解释：</strong>我们需要拨一个长度为1的数字，所以把骑士放在10个单元格中的任何一个数字单元格上都能满足条件。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>20\n<strong>解释：</strong>我们可以拨打的所有有效号码为[04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3131\n<strong>输出：</strong>136006598\n<strong>解释：</strong>注意取模\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 936戳印序列",
        "hardRate": "HARD",
        "passRate": "42.26%",
        "problemsUrl": "https://leetcode.cn/problems/stamping-the-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/stamping-the-sequence/solution",
        "problemsDesc": "<p>你想要用<strong>小写字母</strong>组成一个目标字符串&nbsp;<code>target</code>。&nbsp;</p>\n\n<p>开始的时候，序列由&nbsp;<code>target.length</code>&nbsp;个&nbsp;<code>&#39;?&#39;</code>&nbsp;记号组成。而你有一个小写字母印章&nbsp;<code>stamp</code>。</p>\n\n<p>在每个回合，你可以将印章放在序列上，并将序列中的每个字母替换为印章上的相应字母。你最多可以进行&nbsp;<code>10 * target.length</code>&nbsp; 个回合。</p>\n\n<p>举个例子，如果初始序列为 &quot;?????&quot;，而你的印章 <code>stamp</code>&nbsp;是&nbsp;<code>&quot;abc&quot;</code>，那么在第一回合，你可以得到&nbsp;&quot;abc??&quot;、&quot;?abc?&quot;、&quot;??abc&quot;。（请注意，印章必须完全包含在序列的边界内才能盖下去。）</p>\n\n<p>如果可以印出序列，那么返回一个数组，该数组由每个回合中被印下的最左边字母的索引组成。如果不能印出序列，就返回一个空数组。</p>\n\n<p>例如，如果序列是 &quot;ababc&quot;，印章是 <code>&quot;abc&quot;</code>，那么我们就可以返回与操作&nbsp;&quot;?????&quot; -&gt; &quot;abc??&quot; -&gt; &quot;ababc&quot; 相对应的答案 <code>[0, 2]</code>；</p>\n\n<p>另外，如果可以印出序列，那么需要保证可以在 <code>10 * target.length</code>&nbsp;个回合内完成。任何超过此数字的答案将不被接受。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>stamp = &quot;abc&quot;, target = &quot;ababc&quot;\n<strong>输出：</strong>[0,2]\n（[1,0,2] 以及其他一些可能的结果也将作为答案被接受）\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>stamp = &quot;abca&quot;, target = &quot;aabcaca&quot;\n<strong>输出：</strong>[3,0,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= stamp.length &lt;= target.length &lt;= 1000</code></li>\n\t<li><code>stamp</code> 和&nbsp;<code>target</code>&nbsp;只包含小写字母。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 937重新排列日志文件",
        "hardRate": "MEDIUM",
        "passRate": "63.46%",
        "problemsUrl": "https://leetcode.cn/problems/reorder-data-in-log-files/",
        "solutionsUrl": "https://leetcode.cn/problems/reorder-data-in-log-files/solution",
        "problemsDesc": "<p>给你一个日志数组 <code>logs</code>。每条日志都是以空格分隔的字串，其第一个字为字母与数字混合的<em> </em><strong>标识符 </strong>。</p>\n\n<p>有两种不同类型的日志：</p>\n\n<ul>\n\t<li><strong>字母日志</strong>：除标识符之外，所有字均由小写字母组成</li>\n\t<li><strong>数字日志</strong>：除标识符之外，所有字均由数字组成</li>\n</ul>\n\n<p>请按下述规则将日志重新排序：</p>\n\n<ul>\n\t<li>所有 <strong>字母日志</strong> 都排在 <strong>数字日志</strong> 之前。</li>\n\t<li><strong>字母日志</strong> 在内容不同时，忽略标识符后，按内容字母顺序排序；在内容相同时，按标识符排序。</li>\n\t<li><strong>数字日志</strong> 应该保留原来的相对顺序。</li>\n</ul>\n\n<p>返回日志的最终顺序。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>logs = [\"dig1 8 1 5 1\",\"let1 art can\",\"dig2 3 6\",\"let2 own kit dig\",\"let3 art zero\"]\n<strong>输出：</strong>[\"let1 art can\",\"let3 art zero\",\"let2 own kit dig\",\"dig1 8 1 5 1\",\"dig2 3 6\"]\n<strong>解释：</strong>\n字母日志的内容都不同，所以顺序为 \"art can\", \"art zero\", \"own kit dig\" 。\n数字日志保留原来的相对顺序 \"dig1 8 1 5 1\", \"dig2 3 6\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>logs = [\"a1 9 2 3 1\",\"g1 act car\",\"zo4 4 7\",\"ab1 off key dog\",\"a8 act zoo\"]\n<strong>输出：</strong>[\"g1 act car\",\"a8 act zoo\",\"ab1 off key dog\",\"a1 9 2 3 1\",\"zo4 4 7\"]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= logs.length <= 100</code></li>\n\t<li><code>3 <= logs[i].length <= 100</code></li>\n\t<li><code>logs[i]</code> 中，字与字之间都用 <strong>单个</strong> 空格分隔</li>\n\t<li>题目数据保证 <code>logs[i]</code> 都有一个标识符，并且在标识符之后至少存在一个字</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 938二叉搜索树的范围和",
        "hardRate": "EASY",
        "passRate": "82.11%",
        "problemsUrl": "https://leetcode.cn/problems/range-sum-of-bst/",
        "solutionsUrl": "https://leetcode.cn/problems/range-sum-of-bst/solution",
        "problemsDesc": "<p>给定二叉搜索树的根结点 <code>root</code>，返回值位于范围 <em><code>[low, high]</code></em> 之间的所有结点的值的和。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg\" style=\"width: 400px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>root = [10,5,15,3,7,null,18], low = 7, high = 15\n<strong>输出：</strong>32\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/bst2.jpg\" style=\"width: 400px; height: 335px;\" />\n<pre>\n<strong>输入：</strong>root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10\n<strong>输出：</strong>23\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[1, 2 * 10<sup>4</sup>]</code> 内</li>\n\t<li><code>1 <= Node.val <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= low <= high <= 10<sup>5</sup></code></li>\n\t<li>所有 <code>Node.val</code> <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 939最小面积矩形",
        "hardRate": "MEDIUM",
        "passRate": "48.39%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-area-rectangle/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-area-rectangle/solution",
        "problemsDesc": "<p>给定在 xy 平面上的一组点，确定由这些点组成的矩形的最小面积，其中矩形的边平行于 x 轴和 y 轴。</p>\n\n<p>如果没有任何矩形，就返回 0。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[[1,1],[1,3],[3,1],[3,3],[2,2]]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>[[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= points.length &lt;= 500</code></li>\n\t<li><code>0 &lt;=&nbsp;points[i][0] &lt;=&nbsp;40000</code></li>\n\t<li><code>0 &lt;=&nbsp;points[i][1] &lt;=&nbsp;40000</code></li>\n\t<li>所有的点都是不同的。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 940不同的子序列 II",
        "hardRate": "HARD",
        "passRate": "53.46%",
        "problemsUrl": "https://leetcode.cn/problems/distinct-subsequences-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/distinct-subsequences-ii/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code>，计算 <code>s</code> 的 <strong>不同非空子序列</strong> 的个数。因为结果可能很大，所以返回答案需要对<strong> </strong><strong><code>10^9 + 7</code> 取余</strong> 。</p>\n\n<p>字符串的 <strong>子序列</strong> 是经由原字符串删除一些（也可能不删除）字符但不改变剩余字符相对位置的一个新字符串。</p>\n\n<ul>\n\t<li>例如，<code>\"ace\"</code> 是 <code>\"<em><strong>a</strong></em>b<em><strong>c</strong></em>d<em><strong>e</strong></em>\"</code> 的一个子序列，但 <code>\"aec\"</code> 不是。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\"\n<strong>输出：</strong>7\n<strong>解释：</strong>7 个不同的子序列分别是 \"a\", \"b\", \"c\", \"ab\", \"ac\", \"bc\", 以及 \"abc\"。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aba\"\n<strong>输出：</strong>6\n<strong>解释：</strong>6 个不同的子序列分别是 \"a\", \"b\", \"ab\", \"ba\", \"aa\" 以及 \"aba\"。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aaa\"\n<strong>输出：</strong>3\n<strong>解释：</strong>3 个不同的子序列分别是 \"a\", \"aa\" 以及 \"aaa\"。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 941有效的山脉数组",
        "hardRate": "EASY",
        "passRate": "39.50%",
        "problemsUrl": "https://leetcode.cn/problems/valid-mountain-array/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-mountain-array/solution",
        "problemsDesc": "<p>给定一个整数数组 <code>arr</code>，如果它是有效的山脉数组就返回&nbsp;<code>true</code>，否则返回 <code>false</code>。</p>\n\n<p>让我们回顾一下，如果 <code>arr</code>&nbsp;满足下述条件，那么它是一个山脉数组：</p>\n\n<ul>\n\t<li><code>arr.length &gt;= 3</code></li>\n\t<li>在&nbsp;<code>0 &lt; i&nbsp;&lt; arr.length - 1</code>&nbsp;条件下，存在&nbsp;<code>i</code>&nbsp;使得：\n\t<ul>\n\t\t<li><code>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] </code></li>\n\t\t<li><code>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_valid_mountain_array.png\" style=\"height: 316px; width: 500px;\" /></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [2,1]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [3,5,5]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,3,2,1]\n<strong>输出：</strong>true</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 942增减字符串匹配",
        "hardRate": "EASY",
        "passRate": "77.21%",
        "problemsUrl": "https://leetcode.cn/problems/di-string-match/",
        "solutionsUrl": "https://leetcode.cn/problems/di-string-match/solution",
        "problemsDesc": "<p>由范围 <code>[0,n]</code> 内所有整数组成的 <code>n + 1</code> 个整数的排列序列可以表示为长度为 <code>n</code> 的字符串 <code>s</code> ，其中:</p>\n\n<ul>\n\t<li>如果&nbsp;<code>perm[i] &lt; perm[i + 1]</code>&nbsp;，那么&nbsp;<code>s[i] == 'I'</code>&nbsp;</li>\n\t<li>如果&nbsp;<code>perm[i] &gt; perm[i + 1]</code>&nbsp;，那么 <code>s[i] == 'D'</code>&nbsp;</li>\n</ul>\n\n<p>给定一个字符串 <code>s</code> ，重构排列&nbsp;<code>perm</code> 并返回它。如果有多个有效排列perm，则返回其中 <strong>任何一个</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"IDID\"\n<strong>输出：</strong>[0,4,1,3,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"III\"\n<strong>输出：</strong>[0,1,2,3]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"DDI\"\n<strong>输出：</strong>[3,2,0,1]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code><font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">s</span></span></font></font></code> 只包含字符&nbsp;<code>\"I\"</code>&nbsp;或&nbsp;<code>\"D\"</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 943最短超级串",
        "hardRate": "HARD",
        "passRate": "47.25%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-shortest-superstring/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-shortest-superstring/solution",
        "problemsDesc": "<p>给定一个字符串数组 <code>words</code>，找到以 <code>words</code> 中每个字符串作为子字符串的最短字符串。如果有多个有效最短字符串满足题目条件，返回其中 <strong>任意一个</strong> 即可。</p>\n\n<p>我们可以假设 <code>words</code> 中没有字符串是 <code>words</code> 中另一个字符串的子字符串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"alex\",\"loves\",\"leetcode\"]\n<strong>输出：</strong>\"alexlovesleetcode\"\n<strong>解释：</strong>\"alex\"，\"loves\"，\"leetcode\" 的所有排列都会被接受。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"catg\",\"ctaagt\",\"gcta\",\"ttca\",\"atgcatc\"]\n<strong>输出：</strong>\"gctaagttcatgcatc\"</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= words.length <= 12</code></li>\n\t<li><code>1 <= words[i].length <= 20</code></li>\n\t<li><code>words[i]</code> 由小写英文字母组成</li>\n\t<li><code>words</code> 中的所有字符串 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 944删列造序",
        "hardRate": "EASY",
        "passRate": "69.04%",
        "problemsUrl": "https://leetcode.cn/problems/delete-columns-to-make-sorted/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-columns-to-make-sorted/solution",
        "problemsDesc": "<p>给你由 <code>n</code> 个小写字母字符串组成的数组 <code>strs</code>，其中每个字符串长度相等。</p>\n\n<p>这些字符串可以每个一行，排成一个网格。例如，<code>strs = [\"abc\", \"bce\", \"cae\"]</code> 可以排列为：</p>\n\n<pre>\nabc\nbce\ncae</pre>\n\n<p>你需要找出并删除 <strong>不是按字典序升序排列的</strong> 列。在上面的例子（下标从 0 开始）中，列 0（<code>'a'</code>, <code>'b'</code>, <code>'c'</code>）和列 2（<code>'c'</code>, <code>'e'</code>, <code>'e'</code>）都是按升序排列的，而列 1（<code>'b'</code>, <code>'c'</code>, <code>'a'</code>）不是，所以要删除列 1 。</p>\n\n<p>返回你需要删除的列数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"cba\",\"daf\",\"ghi\"]\n<strong>输出：</strong>1\n<strong>解释：</strong>网格示意如下：\n  cba\n  daf\n  ghi\n列 0 和列 2 按升序排列，但列 1 不是，所以只需要删除列 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"a\",\"b\"]\n<strong>输出：</strong>0\n<strong>解释：</strong>网格示意如下：\n  a\n  b\n只有列 0 这一列，且已经按升序排列，所以不用删除任何列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"zyx\",\"wvu\",\"tsr\"]\n<strong>输出：</strong>3\n<strong>解释：</strong>网格示意如下：\n  zyx\n  wvu\n  tsr\n所有 3 列都是非升序排列的，所以都要删除。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == strs.length</code></li>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>1 <= strs[i].length <= 1000</code></li>\n\t<li><code>strs[i]</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 945使数组唯一的最小增量",
        "hardRate": "MEDIUM",
        "passRate": "47.92%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-increment-to-make-array-unique/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-increment-to-make-array-unique/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。每次 move 操作将会选择任意一个满足 <code>0 &lt;= i &lt; nums.length</code> 的下标 <code>i</code>，并将&nbsp;<code>nums[i]</code> 递增&nbsp;<code>1</code>。</p>\n\n<p>返回使 <code>nums</code> 中的每个值都变成唯一的所需要的最少操作次数。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>经过一次 <em>move</em> 操作，数组将变为 [1, 2, 3]。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,1,2,1,7]\n<strong>输出：</strong>6\n<strong>解释：</strong>经过 6 次 <em>move</em> 操作，数组将变为 [3, 4, 1, 2, 5, 7]。\n可以看出 5 次或 5 次以下的 <em>move</em> 操作是不能让数组的每个值唯一的。</pre>\n</div>\n</div>\n\n<p>&nbsp;</p>\n<strong>提示：</strong>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 946验证栈序列",
        "hardRate": "MEDIUM",
        "passRate": "66.64%",
        "problemsUrl": "https://leetcode.cn/problems/validate-stack-sequences/",
        "solutionsUrl": "https://leetcode.cn/problems/validate-stack-sequences/solution",
        "problemsDesc": "<p>给定&nbsp;<code>pushed</code>&nbsp;和&nbsp;<code>popped</code>&nbsp;两个序列，每个序列中的 <strong>值都不重复</strong>，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 <code>true</code>；否则，返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\n<strong>输出：</strong>true\n<strong>解释：</strong>我们可以按以下顺序执行：\npush(1), push(2), push(3), push(4), pop() -&gt; 4,\npush(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\n<strong>输出：</strong>false\n<strong>解释：</strong>1 不能在 2 之前弹出。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pushed.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= pushed[i] &lt;= 1000</code></li>\n\t<li><code>pushed</code> 的所有元素 <strong>互不相同</strong></li>\n\t<li><code>popped.length == pushed.length</code></li>\n\t<li><code>popped</code> 是 <code>pushed</code> 的一个排列</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 947移除最多的同行或同列石头",
        "hardRate": "MEDIUM",
        "passRate": "61.56%",
        "problemsUrl": "https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/",
        "solutionsUrl": "https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/solution",
        "problemsDesc": "<p><code>n</code> 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。</p>\n\n<p>如果一块石头的 <strong>同行或者同列</strong> 上有其他石头存在，那么就可以移除这块石头。</p>\n\n<p>给你一个长度为 <code>n</code> 的数组 <code>stones</code> ，其中 <code>stones[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示第 <code>i</code> 块石头的位置，返回 <strong>可以移除的石子</strong> 的最大数量。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\n<strong>输出：</strong>5\n<strong>解释：</strong>一种移除 5 块石头的方法如下所示：\n1. 移除石头 [2,2] ，因为它和 [2,1] 同行。\n2. 移除石头 [2,1] ，因为它和 [0,1] 同列。\n3. 移除石头 [1,2] ，因为它和 [1,0] 同行。\n4. 移除石头 [1,0] ，因为它和 [0,0] 同列。\n5. 移除石头 [0,1] ，因为它和 [0,0] 同行。\n石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\n<strong>输出：</strong>3\n<strong>解释：</strong>一种移除 3 块石头的方法如下所示：\n1. 移除石头 [2,2] ，因为它和 [2,0] 同行。\n2. 移除石头 [2,0] ，因为它和 [0,0] 同列。\n3. 移除石头 [0,2] ，因为它和 [0,0] 同行。\n石头 [0,0] 和 [1,1] 不能移除，因为它们没有与另一块石头同行/列。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [[0,0]]\n<strong>输出：</strong>0\n<strong>解释：</strong>[0,0] 是平面上唯一一块石头，所以不可以移除它。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= stones.length <= 1000</code></li>\n\t<li><code>0 <= x<sub>i</sub>, y<sub>i</sub> <= 10<sup>4</sup></code></li>\n\t<li>不会有两块石头放在同一个坐标点上</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 948令牌放置",
        "hardRate": "MEDIUM",
        "passRate": "40.50%",
        "problemsUrl": "https://leetcode.cn/problems/bag-of-tokens/",
        "solutionsUrl": "https://leetcode.cn/problems/bag-of-tokens/solution",
        "problemsDesc": "<p>你的初始 <strong>能量</strong> 为 <code>power</code>，初始 <strong>分数</strong> 为&nbsp;<code>0</code>，只有一包令牌 <code>tokens</code> 。其中 <code>tokens[i]</code> 是第 <code>i</code> 个令牌的值（下标从 0 开始）。</p>\n\n<p>令牌可能的两种使用方法如下：</p>\n\n<ul>\n\t<li>如果你至少有&nbsp;<code>token[i]</code>&nbsp;点 <strong>能量</strong> ，可以将令牌 <code>i</code> 置为正面朝上，失去&nbsp;<code>token[i]</code>&nbsp;点 <strong>能量</strong> ，并得到&nbsp;<code>1</code>&nbsp;<strong>分</strong> 。</li>\n\t<li>如果我们至少有&nbsp;<code>1</code>&nbsp;<strong>分 </strong>，可以将令牌 <code>i</code> 置为反面朝上，获得&nbsp;<code>token[i]</code> 点 <strong>能量</strong> ，并失去&nbsp;<code>1</code>&nbsp;<strong>分</strong> 。</li>\n</ul>\n\n<p>每个令牌 <strong>最多</strong> 只能使用一次，使用 <strong>顺序不限</strong> ，<strong>不需</strong> 使用所有令牌。</p>\n\n<p>在使用任意数量的令牌后，返回我们可以得到的最大 <strong>分数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>tokens = [100], power = 50\n<strong>输出：</strong>0\n<strong>解释：</strong>无法使用唯一的令牌，因为能量和分数都太少了。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>tokens = [100,200], power = 150\n<strong>输出：</strong>1\n<strong>解释：</strong>令牌 0 正面朝上，能量变为 50，分数变为 1 。\n不必使用令牌 1 ，因为你无法使用它来提高分数。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>tokens = [100,200,300,400], power = 200\n<strong>输出：</strong>2\n<strong>解释：</strong>按下面顺序使用令牌可以得到 2 分：\n1. 令牌 0 正面朝上，能量变为 100 ，分数变为 1\n2. 令牌 3 正面朝下，能量变为 500 ，分数变为 0\n3. 令牌 1 正面朝上，能量变为 300 ，分数变为 1\n4. 令牌 2 正面朝上，能量变为 0 ，分数变为 2</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= tokens.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= tokens[i],&nbsp;power &lt; 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 949给定数字能组成的最大时间",
        "hardRate": "MEDIUM",
        "passRate": "37.94%",
        "problemsUrl": "https://leetcode.cn/problems/largest-time-for-given-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-time-for-given-digits/solution",
        "problemsDesc": "<p>给定一个由 4 位数字组成的数组，返回可以设置的符合 24 小时制的最大时间。</p>\n\n<p>24 小时格式为 <code>\"HH:MM\"</code> ，其中 <code>HH</code> 在 <code>00</code> 到 <code>23</code> 之间，<code>MM</code> 在 <code>00</code> 到 <code>59</code> 之间。最小的 24 小时制时间是 <code>00:00</code> ，而最大的是 <code>23:59</code> 。从 00:00 （午夜）开始算起，过得越久，时间越大。</p>\n\n<p>以长度为 5 的字符串，按 <code>\"HH:MM\"</code> 格式返回答案。如果不能确定有效时间，则返回空字符串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,4]\n<strong>输出：</strong>\"23:41\"\n<strong>解释：</strong>有效的 24 小时制时间是 \"12:34\"，\"12:43\"，\"13:24\"，\"13:42\"，\"14:23\"，\"14:32\"，\"21:34\"，\"21:43\"，\"23:14\" 和 \"23:41\" 。这些时间中，\"23:41\" 是最大时间。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [5,5,5,5]\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>不存在有效的 24 小时制时间，因为 \"55:55\" 无效。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,0,0,0]\n<strong>输出：</strong>\"00:00\"\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,0,1,0]\n<strong>输出：</strong>\"10:00\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>arr.length == 4</code></li>\n\t<li><code>0 <= arr[i] <= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 950按递增顺序显示卡牌",
        "hardRate": "MEDIUM",
        "passRate": "78.62%",
        "problemsUrl": "https://leetcode.cn/problems/reveal-cards-in-increasing-order/",
        "solutionsUrl": "https://leetcode.cn/problems/reveal-cards-in-increasing-order/solution",
        "problemsDesc": "<p>牌组中的每张卡牌都对应有一个唯一的整数。你可以按你想要的顺序对这套卡片进行排序。</p>\n\n<p>最初，这些卡牌在牌组里是正面朝下的（即，未显示状态）。</p>\n\n<p>现在，重复执行以下步骤，直到显示所有卡牌为止：</p>\n\n<ol>\n\t<li>从牌组顶部抽一张牌，显示它，然后将其从牌组中移出。</li>\n\t<li>如果牌组中仍有牌，则将下一张处于牌组顶部的牌放在牌组的底部。</li>\n\t<li>如果仍有未显示的牌，那么返回步骤 1。否则，停止行动。</li>\n</ol>\n\n<p>返回能以<strong>递增顺序</strong>显示卡牌的牌组顺序。</p>\n\n<p>答案中的第一张牌被认为处于牌堆顶部。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>[17,13,11,2,3,5,7]\n<strong>输出：</strong>[2,13,3,11,5,17,7]\n<strong>解释：\n</strong>我们得到的牌组顺序为 [17,13,11,2,3,5,7]（这个顺序不重要），然后将其重新排序。\n重新排序后，牌组以 [2,13,3,11,5,17,7] 开始，其中 2 位于牌组的顶部。\n我们显示 2，然后将 13 移到底部。牌组现在是 [3,11,5,17,7,13]。\n我们显示 3，并将 11 移到底部。牌组现在是 [5,17,7,13,11]。\n我们显示 5，然后将 17 移到底部。牌组现在是 [7,13,11,17]。\n我们显示 7，并将 13 移到底部。牌组现在是 [11,17,13]。\n我们显示 11，然后将 17 移到底部。牌组现在是 [13,17]。\n我们展示 13，然后将 17 移到底部。牌组现在是 [17]。\n我们显示 17。\n由于所有卡片都是按递增顺序排列显示的，所以答案是正确的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= A.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= A[i] &lt;= 10^6</code></li>\n\t<li>对于所有的&nbsp;<code>i != j</code>，<code>A[i] != A[j]</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 951翻转等价二叉树",
        "hardRate": "MEDIUM",
        "passRate": "66.85%",
        "problemsUrl": "https://leetcode.cn/problems/flip-equivalent-binary-trees/",
        "solutionsUrl": "https://leetcode.cn/problems/flip-equivalent-binary-trees/solution",
        "problemsDesc": "<p>我们可以为二叉树 <strong>T</strong> 定义一个&nbsp;<strong>翻转操作&nbsp;</strong>，如下所示：选择任意节点，然后交换它的左子树和右子树。</p>\n\n<p>只要经过一定次数的翻转操作后，能使 <strong>X</strong> 等于 <strong>Y</strong>，我们就称二叉树 <strong>X</strong> <em>翻转 等价&nbsp;</em>于二叉树 <strong>Y</strong>。</p>\n\n<p>这些树由根节点&nbsp;<code>root1</code> 和 <code>root2</code>&nbsp;给出。如果两个二叉树是否是<em>翻转 等价&nbsp;</em>的函数，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"Flipped Trees Diagram\" src=\"https://assets.leetcode.com/uploads/2018/11/29/tree_ex.png\" /></p>\n\n<pre>\n<strong>输入：</strong>root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]\n<strong>输出：</strong>true\n<strong>解释：</strong>我们翻转值为 1，3 以及 5 的三个节点。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> root1 = [], root2 = []\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> root1 = [], root2 = [1]\n<strong>输出:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每棵树节点数在&nbsp;<code>[0, 100]</code> 范围内</li>\n\t<li>每棵树中的每个值都是唯一的、在 <code>[0, 99]</code>&nbsp;范围内的整数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 952按公因数计算最大组件大小",
        "hardRate": "HARD",
        "passRate": "51.09%",
        "problemsUrl": "https://leetcode.cn/problems/largest-component-size-by-common-factor/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-component-size-by-common-factor/solution",
        "problemsDesc": "<p>给定一个由不同正整数的组成的非空数组&nbsp;<code>nums</code> ，考虑下面的图：</p>\n\n<ul>\n\t<li>有&nbsp;<code>nums.length</code>&nbsp;个节点，按从&nbsp;<code>nums[0]</code>&nbsp;到&nbsp;<code>nums[nums.length - 1]</code>&nbsp;标记；</li>\n\t<li>只有当&nbsp;<code>nums[i]</code>&nbsp;和&nbsp;<code>nums[j]</code>&nbsp;共用一个大于 1 的公因数时，<code>nums[i]</code>&nbsp;和&nbsp;<code>nums[j]</code>之间才有一条边。</li>\n</ul>\n\n<p>返回 <em>图中最大连通组件的大小</em> 。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/01/ex1.png\" style=\"height: 97px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,6,15,35]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/01/ex2.png\" style=\"height: 85px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [20,50,9,63]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/01/ex3.png\" style=\"height: 260px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,6,7,4,12,21,39]\n<strong>输出：</strong>8\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums</code>&nbsp;中所有值都 <strong>不同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 953验证外星语词典",
        "hardRate": "EASY",
        "passRate": "57.69%",
        "problemsUrl": "https://leetcode.cn/problems/verifying-an-alien-dictionary/",
        "solutionsUrl": "https://leetcode.cn/problems/verifying-an-alien-dictionary/solution",
        "problemsDesc": "<p>某种外星语也使用英文小写字母，但可能顺序 <code>order</code> 不同。字母表的顺序（<code>order</code>）是一些小写字母的排列。</p>\n\n<p>给定一组用外星语书写的单词 <code>words</code>，以及其字母表的顺序 <code>order</code>，只有当给定的单词在这种外星语中按字典序排列时，返回 <code>true</code>；否则，返回 <code>false</code>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\n<strong>输出：</strong>true\n<strong>解释：</strong>在该语言的字母表中，'h' 位于 'l' 之前，所以单词序列是按字典序排列的。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\n<strong>输出：</strong>false\n<strong>解释：</strong>在该语言的字母表中，'d' 位于 'l' 之后，那么 words[0] > words[1]，因此单词序列不是按字典序排列的。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\n<strong>输出：</strong>false\n<strong>解释：</strong>当前三个字符 \"app\" 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 \"apple\" > \"app\"，因为 'l' > '∅'，其中 '∅' 是空白字符，定义为比任何其他字符都小（<a href=\"https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E5%BA%8F\" target=\"_blank\">更多信息</a>）。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= words.length <= 100</code></li>\n\t<li><code>1 <= words[i].length <= 20</code></li>\n\t<li><code>order.length == 26</code></li>\n\t<li>在 <code>words[i]</code> 和 <code>order</code> 中的所有字符都是英文小写字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 954二倍数对数组",
        "hardRate": "MEDIUM",
        "passRate": "39.07%",
        "problemsUrl": "https://leetcode.cn/problems/array-of-doubled-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/array-of-doubled-pairs/solution",
        "problemsDesc": "<p>给定一个长度为偶数的整数数组 <code>arr</code>，只有对 <code>arr</code> 进行重组后可以满足 “对于每个 <code>0 &lt;=&nbsp;i &lt; len(arr) / 2</code>，都有 <code>arr[2 * i + 1] = 2 * arr[2 * i]</code>”&nbsp;时，返回 <code>true</code>；否则，返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [3,1,3,6]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [2,1,2,6]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [4,-2,2,-4]\n<strong>输出：</strong>true\n<strong>解释：</strong>可以用 [-2,-4] 和 [2,4] 这两组组成 [-2,-4,2,4] 或是 [2,4,-2,-4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= arr.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>arr.length</code> 是偶数</li>\n\t<li><code>-10<sup>5</sup> &lt;= arr[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 955删列造序 II",
        "hardRate": "MEDIUM",
        "passRate": "35.50%",
        "problemsUrl": "https://leetcode.cn/problems/delete-columns-to-make-sorted-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-columns-to-make-sorted-ii/solution",
        "problemsDesc": "<p>给定由 <code>n</code> 个字符串组成的数组 <code>strs</code>，其中每个字符串长度相等。</p>\n\n<p>选取一个删除索引序列，对于 <code>strs</code> 中的每个字符串，删除对应每个索引处的字符。</p>\n\n<p>比如，有 <code>strs = [\"abcdef\", \"uvwxyz\"]</code>，删除索引序列 <code>{0, 2, 3}</code>，删除后 <code>strs</code> 为<code>[\"bef\", \"vyz\"]</code>。</p>\n\n<p>假设，我们选择了一组删除索引 <code>answer</code>，那么在执行删除操作之后，最终得到的数组的元素是按 <strong>字典序</strong>（<code>strs[0] <= strs[1] <= strs[2] ... <= strs[n - 1]</code>）排列的，然后请你返回 <code>answer.length</code> 的最小可能值。</p>\n\n<p> </p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"ca\",\"bb\",\"ac\"]\n<strong>输出：</strong>1\n<strong>解释： </strong>\n删除第一列后，strs = [\"a\", \"b\", \"c\"]。\n现在 strs 中元素是按字典排列的 (即，strs[0] <= strs[1] <= strs[2])。\n我们至少需要进行 1 次删除，因为最初 strs 不是按字典序排列的，所以答案是 1。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"xc\",\"yb\",\"za\"]\n<strong>输出：</strong>0\n<strong>解释：</strong>\nstrs 的列已经是按字典序排列了，所以我们不需要删除任何东西。\n注意 strs 的行不需要按字典序排列。\n也就是说，strs[0][0] <= strs[0][1] <= ... 不一定成立。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"zyx\",\"wvu\",\"tsr\"]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n我们必须删掉每一列。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == strs.length</code></li>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>1 <= strs[i].length <= 100</code></li>\n\t<li><code>strs[i]</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 956最高的广告牌",
        "hardRate": "HARD",
        "passRate": "46.38%",
        "problemsUrl": "https://leetcode.cn/problems/tallest-billboard/",
        "solutionsUrl": "https://leetcode.cn/problems/tallest-billboard/solution",
        "problemsDesc": "<p>你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。</p>\n\n<p>你有一堆可以焊接在一起的钢筋 <code>rods</code>。举个例子，如果钢筋的长度为 <code>1</code>、<code>2</code> 和 <code>3</code>，则可以将它们焊接在一起形成长度为 <code>6</code>&nbsp;的支架。</p>\n\n<p>返回 <em>广告牌的最大可能安装高度</em> 。如果没法安装广告牌，请返回 <code>0</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1,2,3,6]\n<strong>输出：</strong>6\n<strong>解释：</strong>我们有两个不相交的子集 {1,2,3} 和 {6}，它们具有相同的和 sum = 6。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1,2,3,4,5,6]\n<strong>输出：</strong>10\n<strong>解释：</strong>我们有两个不相交的子集 {2,3,5} 和 {4,6}，它们具有相同的和 sum = 10。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1,2]\n<strong>输出：</strong>0\n<strong>解释：</strong>没法安装广告牌，所以返回 0。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>0 &lt;= rods.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= rods[i] &lt;= 1000</code></li>\n\t<li><code>sum(rods[i]) &lt;= 5000</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 957N 天后的牢房",
        "hardRate": "MEDIUM",
        "passRate": "37.02%",
        "problemsUrl": "https://leetcode.cn/problems/prison-cells-after-n-days/",
        "solutionsUrl": "https://leetcode.cn/problems/prison-cells-after-n-days/solution",
        "problemsDesc": "<p>监狱中 <code>8</code> 间牢房排成一排，每间牢房可能被占用或空置。</p>\n\n<p>每天，无论牢房是被占用或空置，都会根据以下规则进行变更：</p>\n\n<ul>\n\t<li>如果一间牢房的两个相邻的房间都被占用或都是空的，那么该牢房就会被占用。</li>\n\t<li>否则，它就会被空置。</li>\n</ul>\n\n<p><strong>注意</strong>：由于监狱中的牢房排成一行，所以行中的第一个和最后一个牢房不存在两个相邻的房间。</p>\n\n<p>给你一个整数数组 <code>cells</code> ，用于表示牢房的初始状态：如果第 <code>i</code> 间牢房被占用，则 <code>cell[i]==1</code>，否则 <code>cell[i]==0</code> 。另给你一个整数 <code>n</code> 。</p>\n\n<p>请你返回 <code>n</code> 天后监狱的状况（即，按上文描述进行 <code>n</code> 次变更）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>cells = [0,1,0,1,1,0,0,1], n = 7\n<strong>输出：</strong>[0,0,1,1,0,0,0,0]\n<strong>解释：</strong>下表总结了监狱每天的状况：\nDay 0: [0, 1, 0, 1, 1, 0, 0, 1]\nDay 1: [0, 1, 1, 0, 0, 0, 0, 0]\nDay 2: [0, 0, 0, 0, 1, 1, 1, 0]\nDay 3: [0, 1, 1, 0, 0, 1, 0, 0]\nDay 4: [0, 0, 0, 0, 0, 1, 0, 0]\nDay 5: [0, 1, 1, 1, 0, 1, 0, 0]\nDay 6: [0, 0, 1, 0, 1, 1, 0, 0]\nDay 7: [0, 0, 1, 1, 0, 0, 0, 0]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>cells = [1,0,0,1,0,0,1,0], n = 1000000000\n<strong>输出：</strong>[0,0,1,1,1,1,1,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>cells.length == 8</code></li>\n\t<li><code>cells[i]</code> 为 <code>0</code> 或 <code>1</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 958二叉树的完全性检验",
        "hardRate": "MEDIUM",
        "passRate": "54.47%",
        "problemsUrl": "https://leetcode.cn/problems/check-completeness-of-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/check-completeness-of-a-binary-tree/solution",
        "problemsDesc": "<p>给定一个二叉树的<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;，确定它是否是一个&nbsp;<em>完全二叉树</em>&nbsp;。</p>\n\n<p>在一个&nbsp;<strong><a href=\"https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin\" target=\"_blank\">完全二叉树</a></strong>&nbsp;中，除了最后一个关卡外，所有关卡都是完全被填满的，并且最后一个关卡中的所有节点都是尽可能靠左的。它可以包含<meta charset=\"UTF-8\" />&nbsp;<code>1</code>&nbsp;到<meta charset=\"UTF-8\" />&nbsp;<code>2<sup>h</sup></code>&nbsp;节点之间的最后一级 <code>h</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-1.png\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,5,6]\n<strong>输出：</strong>true\n<strong>解释：</strong>最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-2.png\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,5,null,7]\n<strong>输出：</strong>false\n<strong>解释：</strong>值为 7 的结点没有尽可能靠向左侧。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树的结点数在范围 <meta charset=\"UTF-8\" />&nbsp;<code>[1, 100]</code>&nbsp;内。</li>\n\t<li><code>1 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 959由斜杠划分区域",
        "hardRate": "MEDIUM",
        "passRate": "74.22%",
        "problemsUrl": "https://leetcode.cn/problems/regions-cut-by-slashes/",
        "solutionsUrl": "https://leetcode.cn/problems/regions-cut-by-slashes/solution",
        "problemsDesc": "<p>在由 <code>1 x 1</code> 方格组成的 <code>n&nbsp;x n</code>&nbsp;网格&nbsp;<code>grid</code> 中，每个 <code>1 x 1</code>&nbsp;方块由 <code>'/'</code>、<code>'\\'</code> 或空格构成。这些字符会将方块划分为一些共边的区域。</p>\n\n<p>给定网格&nbsp;<code>grid</code>&nbsp;表示为一个字符串数组，返回 <em>区域的数量</em> 。</p>\n\n<p>请注意，反斜杠字符是转义的，因此&nbsp;<code>'\\'</code> 用 <code>'\\\\'</code>&nbsp;表示。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/15/1.png\" style=\"height: 200px; width: 200px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [\" /\",\"/ \"]\n<strong>输出：</strong>2</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/15/2.png\" style=\"height: 198px; width: 200px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [\" /\",\"  \"]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/15/4.png\" style=\"height: 200px; width: 200px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [\"/\\\\\",\"\\\\/\"]\n<strong>输出：</strong>5\n<strong>解释：</strong>回想一下，因为 \\ 字符是转义的，所以 \"/\\\\\" 表示 /\\，而 \"\\\\/\" 表示 \\/。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n\t<li><code>grid[i][j]</code> 是&nbsp;<code>'/'</code>、<code>'\\'</code>、或&nbsp;<code>' '</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 960删列造序 III",
        "hardRate": "HARD",
        "passRate": "59.14%",
        "problemsUrl": "https://leetcode.cn/problems/delete-columns-to-make-sorted-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-columns-to-make-sorted-iii/solution",
        "problemsDesc": "<p>给定由<meta charset=\"UTF-8\" />&nbsp;<code>n</code>&nbsp;个小写字母字符串组成的数组<meta charset=\"UTF-8\" />&nbsp;<code>strs</code>&nbsp;，其中每个字符串长度相等。</p>\n\n<p>选取一个删除索引序列，对于<meta charset=\"UTF-8\" />&nbsp;<code>strs</code>&nbsp;中的每个字符串，删除对应每个索引处的字符。</p>\n\n<p>比如，有<meta charset=\"UTF-8\" />&nbsp;<code>strs = [\"abcdef\",\"uvwxyz\"]</code>&nbsp;，删除索引序列<meta charset=\"UTF-8\" />&nbsp;<code>{0, 2, 3}</code>&nbsp;，删除后为<meta charset=\"UTF-8\" />&nbsp;<code>[\"bef\", \"vyz\"]</code>&nbsp;。</p>\n\n<p>假设，我们选择了一组删除索引<meta charset=\"UTF-8\" />&nbsp;<code>answer</code>&nbsp;，那么在执行删除操作之后，最终得到的数组的行中的 <strong>每个元素</strong> 都是按<strong>字典序</strong>排列的（即&nbsp;<code>(strs[0][0] &lt;= strs[0][1] &lt;= ... &lt;= strs[0][strs[0].length - 1])</code>&nbsp;和&nbsp;<code>(strs[1][0] &lt;= strs[1][1] &lt;= ... &lt;= strs[1][strs[1].length - 1])</code> ，依此类推）。</p>\n\n<p>请返回<meta charset=\"UTF-8\" /><em>&nbsp;<code>answer.length</code>&nbsp;的最小可能值</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"babca\",\"bbazb\"]\n<strong>输出：</strong>3\n<strong>解释：\n</strong>删除 0、1 和 4 这三列后，最终得到的数组是 A = [\"bc\", \"az\"]。\n这两行是分别按字典序排列的（即，A[0][0] &lt;= A[0][1] 且 A[1][0] &lt;= A[1][1]）。\n注意，A[0] &gt; A[1] —— 数组 A 不一定是按字典序排列的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"edcba\"]\n<strong>输出：</strong>4\n<strong>解释：</strong>如果删除的列少于 4 列，则剩下的行都不会按字典序排列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"ghi\",\"def\",\"abc\"]\n<strong>输出：</strong>0\n<strong>解释：</strong>所有行都已按字典序排列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>n == strs.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= strs[i].length &lt;= 100</code></li>\n\t<li><code>strs[i]</code>&nbsp;由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 961在长度 2N 的数组中找出重复 N 次的元素",
        "hardRate": "EASY",
        "passRate": "70.19%",
        "problemsUrl": "https://leetcode.cn/problems/n-repeated-element-in-size-2n-array/",
        "solutionsUrl": "https://leetcode.cn/problems/n-repeated-element-in-size-2n-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，该数组具有以下属性：</p>\n\n<div class=\"original__bRMd\">\n<div>\n<ul>\n\t<li><code>nums.length == 2 * n</code>.</li>\n\t<li><code>nums</code> 包含 <code>n + 1</code> 个 <strong>不同的</strong> 元素</li>\n\t<li><code>nums</code> 中恰有一个元素重复 <code>n</code> 次</li>\n</ul>\n\n<p>找出并返回重复了 <code>n</code><em> </em>次的那个元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,3]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,2,5,3,2]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,1,5,2,5,3,5,4]\n<strong>输出：</strong>5\n</pre>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 5000</code></li>\n\t<li><code>nums.length == 2 * n</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> 由 <code>n + 1</code> 个<strong> 不同的</strong> 元素组成，且其中一个元素恰好重复 <code>n</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 962最大宽度坡",
        "hardRate": "MEDIUM",
        "passRate": "47.36%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-width-ramp/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-width-ramp/solution",
        "problemsDesc": "<p>给定一个整数数组&nbsp;<code>A</code>，<em>坡</em>是元组&nbsp;<code>(i, j)</code>，其中&nbsp;&nbsp;<code>i &lt; j</code>&nbsp;且&nbsp;<code>A[i] &lt;= A[j]</code>。这样的坡的宽度为&nbsp;<code>j - i</code>。</p>\n\n<p>找出&nbsp;<code>A</code>&nbsp;中的坡的最大宽度，如果不存在，返回 0 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[6,0,8,2,1,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>\n最大宽度的坡为 (i, j) = (1, 5): A[1] = 0 且 A[5] = 5.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>[9,8,1,0,1,9,4,0,4,1]\n<strong>输出：</strong>7\n<strong>解释：</strong>\n最大宽度的坡为 (i, j) = (2, 9): A[2] = 1 且 A[9] = 1.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>2 &lt;= A.length &lt;= 50000</code></li>\n\t<li><code>0 &lt;= A[i] &lt;= 50000</code></li>\n</ol>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 963最小面积矩形 II",
        "hardRate": "MEDIUM",
        "passRate": "51.15%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-area-rectangle-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-area-rectangle-ii/solution",
        "problemsDesc": "<p>给定在 xy 平面上的一组点，确定由这些点组成的任何矩形的最小面积，其中矩形的边<strong>不一定平行于</strong> x 轴和 y 轴。</p>\n\n<p>如果没有任何矩形，就返回 0。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/22/1a.png\" style=\"height: 151px; width: 150px;\"></strong></p>\n\n<pre><strong>输入：</strong>[[1,2],[2,1],[1,0],[0,1]]\n<strong>输出：</strong>2.00000\n<strong>解释：</strong>最小面积的矩形出现在 [1,2],[2,1],[1,0],[0,1] 处，面积为 2。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/23/2.png\" style=\"height: 94px; width: 150px;\"></p>\n\n<pre><strong>输入：</strong>[[0,1],[2,1],[1,1],[1,0],[2,0]]\n<strong>输出：</strong>1.00000\n<strong>解释：</strong>最小面积的矩形出现在 [1,0],[1,1],[2,1],[2,0] 处，面积为 1。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/23/3.png\" style=\"height: 94px; width: 150px;\"></p>\n\n<pre><strong>输入：</strong>[[0,3],[1,2],[3,1],[1,3],[2,1]]\n<strong>输出：</strong>0\n<strong>解释：</strong>没法从这些点中组成任何矩形。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/21/4c.png\" style=\"height: 155px; width: 160px;\"></strong></p>\n\n<pre><strong>输入：</strong>[[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]]\n<strong>输出：</strong>2.00000\n<strong>解释：</strong>最小面积的矩形出现在 [2,1],[2,3],[3,3],[3,1] 处，面积为 2。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= points.length &lt;= 50</code></li>\n\t<li><code>0 &lt;=&nbsp;points[i][0] &lt;=&nbsp;40000</code></li>\n\t<li><code>0 &lt;=&nbsp;points[i][1] &lt;=&nbsp;40000</code></li>\n\t<li>所有的点都是不同的。</li>\n\t<li>与真实值误差不超过 <code>10^-5</code>&nbsp;的答案将视为正确结果。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 964表示数字的最少运算符",
        "hardRate": "HARD",
        "passRate": "46.46%",
        "problemsUrl": "https://leetcode.cn/problems/least-operators-to-express-number/",
        "solutionsUrl": "https://leetcode.cn/problems/least-operators-to-express-number/solution",
        "problemsDesc": "<p>给定一个正整数 <code>x</code>，我们将会写出一个形如&nbsp;<code>x (op1) x (op2) x (op3) x ...</code>&nbsp;的表达式，其中每个运算符&nbsp;<code>op1</code>，<code>op2</code>，… 可以是加、减、乘、除（<code>+</code>，<code>-</code>，<code>*</code>，或是&nbsp;<code>/</code>）之一。例如，对于&nbsp;<code>x = 3</code>，我们可以写出表达式&nbsp;<code>3 * 3 / 3 + 3 - 3</code>，该式的值为 3 。</p>\n\n<p>在写这样的表达式时，我们需要遵守下面的惯例：</p>\n\n<ul>\n\t<li>除运算符（<code>/</code>）返回有理数。</li>\n\t<li>任何地方都没有括号。</li>\n\t<li>我们使用通常的操作顺序：乘法和除法发生在加法和减法之前。</li>\n\t<li>不允许使用一元否定运算符（<code>-</code>）。例如，“<code>x - x</code>” 是一个有效的表达式，因为它只使用减法，但是 “<code>-x + x</code>” 不是，因为它使用了否定运算符。&nbsp;</li>\n</ul>\n\n<p>我们希望编写一个能使表达式等于给定的目标值 <code>target</code> 且运算符最少的表达式。返回所用运算符的最少数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 3, target = 19\n<strong>输出：</strong>5\n<strong>解释：</strong>3 * 3 + 3 * 3 + 3 / 3 。表达式包含 5 个运算符。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 5, target = 501\n<strong>输出：</strong>8\n<strong>解释：</strong>5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5 。表达式包含 8 个运算符。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 100, target = 100000000\n<strong>输出：</strong>3\n<strong>解释：</strong>100 * 100 * 100 * 100 。表达式包含 3 个运算符。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= x &lt;= 100</code></li>\n\t<li><code>1 &lt;= target &lt;= 2 * 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 965单值二叉树",
        "hardRate": "EASY",
        "passRate": "70.67%",
        "problemsUrl": "https://leetcode.cn/problems/univalued-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/univalued-binary-tree/solution",
        "problemsDesc": "<p>如果二叉树每个节点都具有相同的值，那么该二叉树就是<em>单值</em>二叉树。</p>\n\n<p>只有给定的树是单值二叉树时，才返回&nbsp;<code>true</code>；否则返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/screen-shot-2018-12-25-at-50104-pm.png\" style=\"height: 159px; width: 200px;\"></p>\n\n<pre><strong>输入：</strong>[1,1,1,1,1,null,1]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/screen-shot-2018-12-25-at-50050-pm.png\" style=\"height: 158px; width: 200px;\"></p>\n\n<pre><strong>输入：</strong>[2,2,2,5,2]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>给定树的节点数范围是&nbsp;<code>[1, 100]</code>。</li>\n\t<li>每个节点的值都是整数，范围为&nbsp;<code>[0, 99]</code>&nbsp;。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 966元音拼写检查器",
        "hardRate": "MEDIUM",
        "passRate": "42.93%",
        "problemsUrl": "https://leetcode.cn/problems/vowel-spellchecker/",
        "solutionsUrl": "https://leetcode.cn/problems/vowel-spellchecker/solution",
        "problemsDesc": "<p>在给定单词列表&nbsp;<code>wordlist</code>&nbsp;的情况下，我们希望实现一个拼写检查器，将查询单词转换为正确的单词。</p>\n\n<p>对于给定的查询单词&nbsp;<code>query</code>，拼写检查器将会处理两类拼写错误：</p>\n\n<ul>\n\t<li>大小写：如果查询匹配单词列表中的某个单词（<strong>不区分大小写</strong>），则返回的正确单词与单词列表中的大小写相同。\n\n\t<ul>\n\t\t<li>例如：<code>wordlist = [\"yellow\"]</code>, <code>query = \"YellOw\"</code>: <code>correct = \"yellow\"</code></li>\n\t\t<li>例如：<code>wordlist = [\"Yellow\"]</code>, <code>query = \"yellow\"</code>: <code>correct = \"Yellow\"</code></li>\n\t\t<li>例如：<code>wordlist = [\"yellow\"]</code>, <code>query = \"yellow\"</code>: <code>correct = \"yellow\"</code></li>\n\t</ul>\n\t</li>\n\t<li>元音错误：如果在将查询单词中的元音 <code>('a', 'e', 'i', 'o', 'u')</code>&nbsp;&nbsp;分别替换为任何元音后，能与单词列表中的单词匹配（<strong>不区分大小写</strong>），则返回的正确单词与单词列表中的匹配项大小写相同。\n\t<ul>\n\t\t<li>例如：<code>wordlist = [\"YellOw\"]</code>, <code>query = \"yollow\"</code>: <code>correct = \"YellOw\"</code></li>\n\t\t<li>例如：<code>wordlist = [\"YellOw\"]</code>, <code>query = \"yeellow\"</code>: <code>correct = \"\"</code> （无匹配项）</li>\n\t\t<li>例如：<code>wordlist = [\"YellOw\"]</code>, <code>query = \"yllw\"</code>: <code>correct = \"\"</code> （无匹配项）</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>此外，拼写检查器还按照以下优先级规则操作：</p>\n\n<ul>\n\t<li>当查询完全匹配单词列表中的某个单词（<strong>区分大小写</strong>）时，应返回相同的单词。</li>\n\t<li>当查询匹配到大小写问题的单词时，您应该返回单词列表中的第一个这样的匹配项。</li>\n\t<li>当查询匹配到元音错误的单词时，您应该返回单词列表中的第一个这样的匹配项。</li>\n\t<li>如果该查询在单词列表中没有匹配项，则应返回空字符串。</li>\n</ul>\n\n<p>给出一些查询 <code>queries</code>，返回一个单词列表 <code>answer</code>，其中 <code>answer[i]</code> 是由查询 <code>query = queries[i]</code> 得到的正确单词。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>wordlist = [\"KiTe\",\"kite\",\"hare\",\"Hare\"], queries = [\"kite\",\"Kite\",\"KiTe\",\"Hare\",\"HARE\",\"Hear\",\"hear\",\"keti\",\"keet\",\"keto\"]\n<strong>输出：</strong>[\"kite\",\"KiTe\",\"KiTe\",\"Hare\",\"hare\",\"\",\"\",\"KiTe\",\"\",\"KiTe\"]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<b>输入：</b>wordlist = [\"yellow\"], queries = [\"YellOw\"]\n<b>输出：</b>[\"yellow\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= wordlist.length, queries.length &lt;= 5000</code></li>\n\t<li><code>1 &lt;= wordlist[i].length, queries[i].length &lt;= 7</code></li>\n\t<li><code>wordlist[i]</code>&nbsp;和&nbsp;<code>queries[i]</code>&nbsp;只包含英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 967连续差相同的数字",
        "hardRate": "MEDIUM",
        "passRate": "50.51%",
        "problemsUrl": "https://leetcode.cn/problems/numbers-with-same-consecutive-differences/",
        "solutionsUrl": "https://leetcode.cn/problems/numbers-with-same-consecutive-differences/solution",
        "problemsDesc": "<p>返回所有长度为 <code>n</code> 且满足其每两个连续位上的数字之间的差的绝对值为 <code>k</code> 的<strong> 非负整数 </strong>。</p>\n\n<p>请注意，<strong>除了 </strong>数字 <code>0</code> 本身之外，答案中的每个数字都 <strong>不能 </strong>有前导零。例如，<code>01</code> 有一个前导零，所以是无效的；但 <code>0</code>&nbsp;是有效的。</p>\n\n<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 7\n<strong>输出：</strong>[181,292,707,818,929]\n<strong>解释：</strong>注意，070 不是一个有效的数字，因为它有前导零。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, k = 1\n<strong>输出：</strong>[10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, k = 0\n<strong>输出：</strong>[11,22,33,44,55,66,77,88,99]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, k = 2\n<strong>输出：</strong>[13,20,24,31,35,42,46,53,57,64,68,75,79,86,97]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 9</code></li>\n\t<li><code>0 &lt;= k &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 968监控二叉树",
        "hardRate": "HARD",
        "passRate": "52.35%",
        "problemsUrl": "https://leetcode.cn/problems/binary-tree-cameras/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-tree-cameras/solution",
        "problemsDesc": "<p>给定一个二叉树，我们在树的节点上安装摄像头。</p>\n\n<p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p>\n\n<p>计算监控树的所有节点所需的最小摄像头数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png\" style=\"height: 163px; width: 138px;\"></p>\n\n<pre><strong>输入：</strong>[0,0,null,0,0]\n<strong>输出：</strong>1\n<strong>解释：</strong>如图所示，一台摄像头足以监控所有节点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png\" style=\"height: 312px; width: 139px;\"></p>\n\n<pre><strong>输入：</strong>[0,0,null,0,null,0,null,null,0]\n<strong>输出：</strong>2\n<strong>解释：</strong>需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。\n</pre>\n\n<p><br>\n<strong>提示：</strong></p>\n\n<ol>\n\t<li>给定树的节点数的范围是&nbsp;<code>[1, 1000]</code>。</li>\n\t<li>每个节点的值都是 0。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 969煎饼排序",
        "hardRate": "MEDIUM",
        "passRate": "67.53%",
        "problemsUrl": "https://leetcode.cn/problems/pancake-sorting/",
        "solutionsUrl": "https://leetcode.cn/problems/pancake-sorting/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> ，请使用 <strong>煎饼翻转</strong><em> </em>完成对数组的排序。</p>\n\n<p>一次煎饼翻转的执行过程如下：</p>\n\n<ul>\n\t<li>选择一个整数 <code>k</code> ，<code>1 <= k <= arr.length</code></li>\n\t<li>反转子数组 <code>arr[0...k-1]</code>（<strong>下标从 0 开始</strong>）</li>\n</ul>\n\n<p>例如，<code>arr = [3,2,1,4]</code> ，选择 <code>k = 3</code> 进行一次煎饼翻转，反转子数组 <code>[3,2,1]</code> ，得到 <code>arr = [<strong>1</strong>,<strong>2</strong>,<strong>3</strong>,4]</code> 。</p>\n\n<p>以数组形式返回能使 <code>arr</code> 有序的煎饼翻转操作所对应的 <code>k</code> 值序列。任何将数组排序且翻转次数在 <code>10 * arr.length</code> 范围内的有效答案都将被判断为正确。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>[3,2,4,1]\n<strong>输出：</strong>[4,2,4,3]\n<strong>解释：</strong>\n我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。\n初始状态 arr = [3, 2, 4, 1]\n第一次翻转后（k = 4）：arr = [<strong>1</strong>, <strong>4</strong>, <strong>2</strong>, <strong>3</strong>]\n第二次翻转后（k = 2）：arr = [<strong>4</strong>, <strong>1</strong>, 2, 3]\n第三次翻转后（k = 4）：arr = [<strong>3</strong>, <strong>2</strong>, <strong>1</strong>, <strong>4</strong>]\n第四次翻转后（k = 3）：arr = [<strong>1</strong>, <strong>2</strong>, <strong>3</strong>, 4]，此时已完成排序。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1,2,3]\n<strong>输出：</strong>[]\n<strong>解释：\n</strong>输入已经排序，因此不需要翻转任何内容。\n请注意，其他可能的答案，如 [3，3] ，也将被判断为正确。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= arr.length <= 100</code></li>\n\t<li><code>1 <= arr[i] <= arr.length</code></li>\n\t<li><code>arr</code> 中的所有整数互不相同（即，<code>arr</code> 是从 <code>1</code> 到 <code>arr.length</code> 整数的一个排列）</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 970强整数",
        "hardRate": "MEDIUM",
        "passRate": "47.00%",
        "problemsUrl": "https://leetcode.cn/problems/powerful-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/powerful-integers/solution",
        "problemsDesc": "<p>给定三个整数 <code>x</code>&nbsp;、&nbsp;<code>y</code>&nbsp;和<em>&nbsp;</em><code>bound</code><em>&nbsp;</em>，返回 <em>值小于或等于&nbsp;<code>bound</code>&nbsp;的所有&nbsp;<strong>强整数</strong>&nbsp;组成的列表</em>&nbsp;。</p>\n\n<p>如果某一整数可以表示为&nbsp;<code>x<sup>i</sup>&nbsp;+ y<sup>j</sup></code>&nbsp;，其中整数&nbsp;<code>i &gt;= 0</code> 且&nbsp;<code>j &gt;= 0</code>，那么我们认为该整数是一个&nbsp;<strong>强整数</strong>&nbsp;。</p>\n\n<p>你可以按 <strong>任何顺序</strong> 返回答案。在你的回答中，每个值 <strong>最多</strong> 出现一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 2, y = 3, bound = 10\n<strong>输出：</strong>[2,3,4,5,7,9,10]\n<strong>解释： </strong>\n2 = 2<sup>0</sup> + 3<sup>0</sup>\n3 = 2<sup>1</sup> + 3<sup>0</sup>\n4 = 2<sup>0</sup> + 3<sup>1</sup>\n5 = 2<sup>1</sup> + 3<sup>1</sup>\n7 = 2<sup>2</sup> + 3<sup>1</sup>\n9 = 2<sup>3</sup> + 3<sup>0</sup>\n10 = 2<sup>0</sup> + 3<sup>2</sup></pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 3, y = 5, bound = 15\n<strong>输出：</strong>[2,4,6,8,10,14]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= x, y &lt;= 100</code></li>\n\t<li><code>0 &lt;= bound &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 971翻转二叉树以匹配先序遍历",
        "hardRate": "MEDIUM",
        "passRate": "45.51%",
        "problemsUrl": "https://leetcode.cn/problems/flip-binary-tree-to-match-preorder-traversal/",
        "solutionsUrl": "https://leetcode.cn/problems/flip-binary-tree-to-match-preorder-traversal/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点 <code>root</code> ，树中有 <code>n</code> 个节点，每个节点都有一个不同于其他节点且处于 <code>1</code> 到 <code>n</code> 之间的值。</p>\n\n<p>另给你一个由 <code>n</code> 个值组成的行程序列 <code>voyage</code> ，表示 <strong>预期</strong> 的二叉树 <a href=\"https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin\" target=\"_blank\"><strong>先序遍历</strong></a> 结果。</p>\n\n<p>通过交换节点的左右子树，可以 <strong>翻转</strong> 该二叉树中的任意节点。例，翻转节点 1 的效果如下：</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/15/fliptree.jpg\" style=\"width: 400px; height: 187px;\" />\n<p>请翻转 <strong>最少 </strong>的树中节点，使二叉树的 <strong>先序遍历</strong> 与预期的遍历行程 <code>voyage</code> <strong>相匹配</strong> 。 </p>\n\n<p>如果可以，则返回 <strong>翻转的</strong> 所有节点的值的列表。你可以按任何顺序返回答案。如果不能，则返回列表 <code>[-1]</code>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/02/1219-01.png\" style=\"width: 150px; height: 205px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2], voyage = [2,1]\n<strong>输出：</strong>[-1]\n<strong>解释：</strong>翻转节点无法令先序遍历匹配预期行程。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/02/1219-02.png\" style=\"width: 150px; height: 142px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3], voyage = [1,3,2]\n<strong>输出：</strong>[1]\n<strong>解释：</strong>交换节点 2 和 3 来翻转节点 1 ，先序遍历可以匹配预期行程。</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/02/1219-02.png\" style=\"width: 150px; height: 142px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3], voyage = [1,2,3]\n<strong>输出：</strong>[]\n<strong>解释：</strong>先序遍历已经匹配预期行程，所以不需要翻转节点。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数目为 <code>n</code></li>\n\t<li><code>n == voyage.length</code></li>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>1 <= Node.val, voyage[i] <= n</code></li>\n\t<li>树中的所有值 <strong>互不相同</strong></li>\n\t<li><code>voyage</code> 中的所有值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 972相等的有理数",
        "hardRate": "HARD",
        "passRate": "41.51%",
        "problemsUrl": "https://leetcode.cn/problems/equal-rational-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/equal-rational-numbers/solution",
        "problemsDesc": "<p>给定两个字符串&nbsp;<code>s</code>&nbsp;和&nbsp;<code>t</code>&nbsp;，每个字符串代表一个非负有理数，只有当它们表示相同的数字时才返回 <code>true</code>&nbsp;。字符串中可以使用括号来表示有理数的重复部分。</p>\n\n<p><strong>有理数</strong>&nbsp;最多可以用三个部分来表示：<em>整数部分</em>&nbsp;<code>&lt;IntegerPart&gt;</code>、<em>小数非重复部分</em>&nbsp;<code>&lt;NonRepeatingPart&gt;</code>&nbsp;和<em>小数重复部分</em>&nbsp;<code>&lt;(&gt;&lt;RepeatingPart&gt;&lt;)&gt;</code>。数字可以用以下三种方法之一来表示：</p>\n\n<ul>\n\t<li><code>&lt;IntegerPart&gt;</code>&nbsp;\n\n\t<ul>\n\t\t<li>例：&nbsp;<code>0</code>&nbsp;,<code>12</code>&nbsp;和&nbsp;<code>123</code>&nbsp;</li>\n\t</ul>\n\t</li>\n\t<li><code>&lt;IntegerPart&gt;&lt;.&gt;&lt;NonRepeatingPart&gt;</code>\n\t<ul>\n\t\t<li>例： <code>0.5<font color=\"#333333\"><font face=\"Helvetica Neue, Helvetica, Arial, sans-serif\"><span style=\"font-size:14px\"><span style=\"background-color:#ffffff\">&nbsp;, </span></span></font></font></code><font color=\"#333333\"><font face=\"Helvetica Neue, Helvetica, Arial, sans-serif\"><span style=\"font-size:14px\"><span style=\"background-color:#ffffff\"><code>1.</code>&nbsp;,&nbsp;</span></span></font></font><code>2.12</code>&nbsp;和&nbsp;<code>123.0001</code></li>\n\t</ul>\n\t</li>\n\t<li><code>&lt;IntegerPart&gt;&lt;.&gt;&lt;NonRepeatingPart&gt;&lt;(&gt;&lt;RepeatingPart&gt;&lt;)&gt;</code>&nbsp;\n\t<ul>\n\t\t<li>例： <code>0.1(6)</code> ， <code>1.(9)</code>， <code>123.00(1212)</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>十进制展开的重复部分通常在一对圆括号内表示。例如：</p>\n\n<ul>\n\t<li><code>1 / 6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66)</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0.(52)\", t = \"0.5(25)\"\n<strong>输出：</strong>true\n<strong>解释：</strong>因为 \"0.(52)\" 代表 0.52525252...，而 \"0.5(25)\" 代表 0.52525252525.....，则这两个字符串表示相同的数字。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0.1666(6)\", t = \"0.166(66)\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0.9(9)\", t = \"1.\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\"0.9(9)\" 代表 0.999999999... 永远重复，等于 1 。[<a href=\"https://baike.baidu.com/item/0.999…/5615429?fr=aladdin\" target=\"_blank\">有关说明，请参阅此链接</a>]\n\"1.\" 表示数字 1，其格式正确：(IntegerPart) = \"1\" 且 (NonRepeatingPart) = \"\" 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每个部分仅由数字组成。</li>\n\t<li>整数部分&nbsp;<code>&lt;IntegerPart&gt;</code>&nbsp;不会以零开头。（零本身除外）</li>\n\t<li><code>1 &lt;= &lt;IntegerPart&gt;.length &lt;= 4 </code></li>\n\t<li><code>0 &lt;= &lt;NonRepeatingPart&gt;.length &lt;= 4 </code></li>\n\t<li><code>1 &lt;= &lt;RepeatingPart&gt;.length &lt;= 4 </code></li>\n</ul>\n<span style=\"display:block\"><span style=\"height:0px\"><span style=\"position:absolute\">​​​​​</span></span></span>",
        "isPlus": false
    },
    {
        "problemsName": " 973最接近原点的 K 个点",
        "hardRate": "MEDIUM",
        "passRate": "65.22%",
        "problemsUrl": "https://leetcode.cn/problems/k-closest-points-to-origin/",
        "solutionsUrl": "https://leetcode.cn/problems/k-closest-points-to-origin/solution",
        "problemsDesc": "<p>给定一个数组 <code>points</code>&nbsp;，其中&nbsp;<code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;表示 <strong>X-Y</strong> 平面上的一个点，并且是一个整数 <code>k</code> ，返回离原点 <code>(0,0)</code> 最近的 <code>k</code> 个点。</p>\n\n<p>这里，平面上两点之间的距离是&nbsp;<strong>欧几里德距离</strong>（&nbsp;<code>√(x<sub>1</sub>&nbsp;- x<sub>2</sub>)<sup>2</sup>&nbsp;+ (y<sub>1</sub>&nbsp;- y<sub>2</sub>)<sup>2</sup></code>&nbsp;）。</p>\n\n<p>你可以按 <strong>任何顺序</strong> 返回答案。除了点坐标的顺序之外，答案 <strong>确保</strong> 是 <strong>唯一</strong> 的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg\" style=\"height: 400px; width: 400px;\" /></p>\n\n<pre>\n<strong>输入：</strong>points = [[1,3],[-2,2]], k = 1\n<strong>输出：</strong>[[-2,2]]\n<strong>解释： </strong>\n(1, 3) 和原点之间的距离为 sqrt(10)，\n(-2, 2) 和原点之间的距离为 sqrt(8)，\n由于 sqrt(8) &lt; sqrt(10)，(-2, 2) 离原点更近。\n我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[3,3],[5,-1],[-2,4]], k = 2\n<strong>输出：</strong>[[3,3],[-2,4]]\n（答案 [[-2,4],[3,3]] 也会被接受。）\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= points.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt; x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt; 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 974和可被 K 整除的子数组",
        "hardRate": "MEDIUM",
        "passRate": "47.88%",
        "problemsUrl": "https://leetcode.cn/problems/subarray-sums-divisible-by-k/",
        "solutionsUrl": "https://leetcode.cn/problems/subarray-sums-divisible-by-k/solution",
        "problemsDesc": "<p>给定一个整数数组 <code>nums</code>&nbsp;和一个整数 <code>k</code> ，返回其中元素之和可被 <code>k</code>&nbsp;整除的（连续、非空） <strong>子数组</strong> 的数目。</p>\n\n<p><strong>子数组</strong> 是数组的 <strong>连续</strong> 部分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,5,0,-2,-3,1], k = 5\n<strong>输出：</strong>7\n<strong>解释：\n</strong>有 7 个子数组满足其元素之和可被 k = 5 整除：\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [5], k = 9\n<strong>输出:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>2 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 975奇偶跳",
        "hardRate": "HARD",
        "passRate": "47.76%",
        "problemsUrl": "https://leetcode.cn/problems/odd-even-jump/",
        "solutionsUrl": "https://leetcode.cn/problems/odd-even-jump/solution",
        "problemsDesc": "<p>给定一个整数数组 <code>A</code>，你可以从某一起始索引出发，跳跃一定次数。在你跳跃的过程中，第 1、3、5... 次跳跃称为奇数跳跃，而第 2、4、6... 次跳跃称为偶数跳跃。</p>\n\n<p>你可以按以下方式从索引 <code>i</code>&nbsp;向后跳转到索引 <code>j</code>（其中 <code>i &lt; j</code>）：</p>\n\n<ul>\n\t<li>在进行奇数跳跃时（如，第&nbsp;1，3，5... 次跳跃），你将会跳到索引 <code>j</code>，使得 <code>A[i] &lt;=&nbsp;A[j]</code>，<code>A[j]</code> 是可能的最小值。如果存在多个这样的索引 <code>j</code>，你只能跳到满足要求的<strong>最小</strong>索引 <code>j</code> 上。</li>\n\t<li>在进行偶数跳跃时（如，第&nbsp;2，4，6... 次跳跃），你将会跳到索引&nbsp;<code>j</code>，使得 <code>A[i] &gt;= A[j]</code>，<code>A[j]</code> 是可能的最大值。如果存在多个这样的索引 <code>j</code>，你只能跳到满足要求的<strong>最小</strong>索引 <code>j</code>&nbsp;上。</li>\n\t<li>（对于某些索引 <code>i</code>，可能无法进行合乎要求的跳跃。）</li>\n</ul>\n\n<p>如果从某一索引开始跳跃一定次数（可能是 0 次或多次），就可以到达数组的末尾（索引 <code>A.length - 1</code>），那么该索引就会被认为是好的起始索引。</p>\n\n<p>返回好的起始索引的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[10,13,12,14,15]\n<strong>输出：</strong>2\n<strong>解释： </strong>\n从起始索引 i = 0 出发，我们可以跳到 i = 2，（因为 A[2] 是 A[1]，A[2]，A[3]，A[4] 中大于或等于 A[0] 的最小值），然后我们就无法继续跳下去了。\n从起始索引 i = 1 和 i = 2 出发，我们可以跳到 i = 3，然后我们就无法继续跳下去了。\n从起始索引 i = 3 出发，我们可以跳到 i = 4，到达数组末尾。\n从起始索引 i = 4 出发，我们已经到达数组末尾。\n总之，我们可以从 2 个不同的起始索引（i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre><strong>输入：</strong>[2,3,1,1,4]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n从起始索引 i=0 出发，我们依次可以跳到 i = 1，i = 2，i = 3：\n\n在我们的第一次跳跃（奇数）中，我们先跳到 i = 1，因为 A[1] 是（A[1]，A[2]，A[3]，A[4]）中大于或等于 A[0] 的最小值。\n\n在我们的第二次跳跃（偶数）中，我们从 i = 1 跳到 i = 2，因为 A[2] 是（A[2]，A[3]，A[4]）中小于或等于 A[1] 的最大值。A[3] 也是最大的值，但 2 是一个较小的索引，所以我们只能跳到 i = 2，而不能跳到 i = 3。\n\n在我们的第三次跳跃（奇数）中，我们从 i = 2 跳到 i = 3，因为 A[3] 是（A[3]，A[4]）中大于或等于 A[2] 的最小值。\n\n我们不能从 i = 3 跳到 i = 4，所以起始索引 i = 0 不是好的起始索引。\n\n类似地，我们可以推断：\n从起始索引 i = 1 出发， 我们跳到 i = 4，这样我们就到达数组末尾。\n从起始索引 i = 2 出发， 我们跳到 i = 3，然后我们就不能再跳了。\n从起始索引 i = 3 出发， 我们跳到 i = 4，这样我们就到达数组末尾。\n从起始索引 i = 4 出发，我们已经到达数组末尾。\n总之，我们可以从 3 个不同的起始索引（i = 1, i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>[5,1,3,4,2]\n<strong>输出：</strong>3\n<strong>解释： </strong>\n我们可以从起始索引 1，2，4 出发到达数组末尾。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= A.length &lt;= 20000</code></li>\n\t<li><code>0 &lt;= A[i] &lt; 100000</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 976三角形的最大周长",
        "hardRate": "EASY",
        "passRate": "57.51%",
        "problemsUrl": "https://leetcode.cn/problems/largest-perimeter-triangle/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-perimeter-triangle/solution",
        "problemsDesc": "<p>给定由一些正数（代表长度）组成的数组 <code>nums</code>&nbsp;，返回 <em>由其中三个长度组成的、<strong>面积不为零</strong>的三角形的最大周长</em>&nbsp;。如果不能形成任何面积不为零的三角形，返回&nbsp;<code>0</code>。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,2]\n<strong>输出：</strong>5\n<strong>解释：</strong>你可以用三个边长组成一个三角形:1 2 2。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,10]\n<strong>输出：</strong>0\n<strong>解释：</strong>\n你不能用边长 1,1,2 来组成三角形。\n不能用边长 1,1,10 来构成三角形。\n不能用边长 1、2 和 10 来构成三角形。\n因为我们不能用任何三条边长来构成一个非零面积的三角形，所以我们返回 0。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 977有序数组的平方",
        "hardRate": "EASY",
        "passRate": "67.96%",
        "problemsUrl": "https://leetcode.cn/problems/squares-of-a-sorted-array/",
        "solutionsUrl": "https://leetcode.cn/problems/squares-of-a-sorted-array/solution",
        "problemsDesc": "<p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>\n\n<ul>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-4,-1,0,3,10]\n<strong>输出：</strong>[0,1,9,16,100]\n<strong>解释：</strong>平方后，数组变为 [16,1,0,9,100]\n排序后，数组变为 [0,1,9,16,100]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-7,-3,2,3,11]\n<strong>输出：</strong>[4,9,9,49,121]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code><span>1 <= nums.length <= </span>10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>请你<span style=\"color: rgb(36, 41, 46); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial; display: inline !important; float: none;\">设计时间复杂度为 <code>O(n)</code> 的算法解决本问题</span></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 978最长湍流子数组",
        "hardRate": "MEDIUM",
        "passRate": "47.53%",
        "problemsUrl": "https://leetcode.cn/problems/longest-turbulent-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-turbulent-subarray/solution",
        "problemsDesc": "<p>给定一个整数数组 <code>arr</code>&nbsp;，返回 <code>arr</code>&nbsp;的&nbsp;<em>最大湍流子数组的<strong>长度</strong></em><strong>&nbsp;</strong>。</p>\n\n<p>如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是&nbsp;<strong>湍流子数组</strong>&nbsp;。</p>\n\n<p>更正式地来说，当 <code>arr</code>&nbsp;的子数组&nbsp;<code>A[i], A[i+1], ..., A[j]</code>&nbsp;满足仅满足下列条件时，我们称其为<em>湍流子数组</em>：</p>\n\n<ul>\n\t<li>若&nbsp;<code>i &lt;= k &lt; j</code>&nbsp;：\n\n\t<ul>\n\t\t<li>当 <code>k</code>&nbsp;为奇数时，&nbsp;<code>A[k] &gt; A[k+1]</code>，且</li>\n\t\t<li>当 <code>k</code> 为偶数时，<code>A[k] &lt; A[k+1]</code>；</li>\n\t</ul>\n\t</li>\n\t<li><strong>或 </strong>若&nbsp;<code>i &lt;= k &lt; j</code>&nbsp;：\n\t<ul>\n\t\t<li>当 <code>k</code> 为偶数时，<code>A[k] &gt; A[k+1]</code>&nbsp;，且</li>\n\t\t<li>当 <code>k</code>&nbsp;为奇数时，&nbsp;<code>A[k] &lt; A[k+1]</code>。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [9,4,2,10,7,8,8,1,9]\n<strong>输出：</strong>5\n<strong>解释：</strong>arr[1] &gt; arr[2] &lt; arr[3] &gt; arr[4] &lt; arr[5]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [4,8,12,16]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [100]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 4 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 979在二叉树中分配硬币",
        "hardRate": "MEDIUM",
        "passRate": "72.40%",
        "problemsUrl": "https://leetcode.cn/problems/distribute-coins-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/distribute-coins-in-binary-tree/solution",
        "problemsDesc": "<p>给定一个有 <code>N</code> 个结点的二叉树的根结点 <code>root</code>，树中的每个结点上都对应有 <code>node.val</code> 枚硬币，并且总共有 <code>N</code> 枚硬币。</p>\n\n<p>在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。</p>\n\n<p>返回使每个结点上只有一枚硬币所需的移动次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/tree1.png\" style=\"height: 142px; width: 150px;\"></strong></p>\n\n<pre><strong>输入：</strong>[3,0,0]\n<strong>输出：</strong>2\n<strong>解释：</strong>从树的根结点开始，我们将一枚硬币移到它的左子结点上，一枚硬币移到它的右子结点上。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/tree2.png\" style=\"height: 142px; width: 150px;\"></strong></p>\n\n<pre><strong>输入：</strong>[0,3,0]\n<strong>输出：</strong>3\n<strong>解释：</strong>从根结点的左子结点开始，我们将两枚硬币移到根结点上 [移动两次]。然后，我们把一枚硬币从根结点移到右子结点上。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/tree3.png\" style=\"height: 142px; width: 150px;\"></strong></p>\n\n<pre><strong>输入：</strong>[1,0,2]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/tree4.png\" style=\"height: 156px; width: 155px;\"></strong></p>\n\n<pre><strong>输入：</strong>[1,0,0,null,3]\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1&lt;= N &lt;= 100</code></li>\n\t<li><code>0 &lt;= node.val &lt;= N</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 980不同路径 III",
        "hardRate": "HARD",
        "passRate": "74.12%",
        "problemsUrl": "https://leetcode.cn/problems/unique-paths-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-paths-iii/solution",
        "problemsDesc": "<p>在二维网格 <code>grid</code> 上，有 4 种类型的方格：</p>\n\n<ul>\n\t<li><code>1</code> 表示起始方格。且只有一个起始方格。</li>\n\t<li><code>2</code> 表示结束方格，且只有一个结束方格。</li>\n\t<li><code>0</code> 表示我们可以走过的空方格。</li>\n\t<li><code>-1</code> 表示我们无法跨越的障碍。</li>\n</ul>\n\n<p>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目<strong>。</strong></p>\n\n<p><strong>每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]\n<strong>输出：</strong>2\n<strong>解释：</strong>我们有以下两条路径：\n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\n2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>[[1,0,0,0],[0,0,0,0],[0,0,0,2]]\n<strong>输出：</strong>4\n<strong>解释：</strong>我们有以下四条路径： \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)\n2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)\n3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)\n4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>[[0,1],[2,0]]\n<strong>输出：</strong>0\n<strong>解释：</strong>\n没有一条路能完全穿过每一个空的方格一次。\n请注意，起始和结束方格可以位于网格中的任意位置。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= grid.length * grid[0].length &lt;= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 981基于时间的键值存储",
        "hardRate": "MEDIUM",
        "passRate": "52.87%",
        "problemsUrl": "https://leetcode.cn/problems/time-based-key-value-store/",
        "solutionsUrl": "https://leetcode.cn/problems/time-based-key-value-store/solution",
        "problemsDesc": "<p>设计一个基于时间的键值数据结构，该结构可以在不同时间戳存储对应同一个键的多个值，并针对特定时间戳检索键对应的值。</p>\n\n<p>实现 <code>TimeMap</code> 类：</p>\n\n<ul>\n\t<li><code>TimeMap()</code> 初始化数据结构对象</li>\n\t<li><code>void set(String key, String value, int timestamp)</code> 存储键 <code>key</code>、值 <code>value</code>，以及给定的时间戳 <code>timestamp</code>。</li>\n\t<li><code>String get(String key, int timestamp)</code>\n\t<ul>\n\t\t<li>返回先前调用 <code>set(key, value, timestamp_prev)</code> 所存储的值，其中 <code>timestamp_prev <= timestamp</code> 。</li>\n\t\t<li>如果有多个这样的值，则返回对应最大的  <code>timestamp_prev</code> 的那个值。</li>\n\t\t<li>如果没有值，则返回空字符串（<code>\"\"</code>）。</li>\n\t</ul>\n\t</li>\n</ul>\n \n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"]\n[[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]\n<strong>输出：</strong>\n[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]\n\n<strong>解释：</strong>\nTimeMap timeMap = new TimeMap();\ntimeMap.set(\"foo\", \"bar\", 1);  // 存储键 \"foo\" 和值 \"bar\" ，时间戳 timestamp = 1   \ntimeMap.get(\"foo\", 1);         // 返回 \"bar\"\ntimeMap.get(\"foo\", 3);         // 返回 \"bar\", 因为在时间戳 3 和时间戳 2 处没有对应 \"foo\" 的值，所以唯一的值位于时间戳 1 处（即 \"bar\"） 。\ntimeMap.set(\"foo\", \"bar2\", 4); // 存储键 \"foo\" 和值 \"bar2\" ，时间戳 timestamp = 4  \ntimeMap.get(\"foo\", 4);         // 返回 \"bar2\"\ntimeMap.get(\"foo\", 5);         // 返回 \"bar2\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= key.length, value.length <= 100</code></li>\n\t<li><code>key</code> 和 <code>value</code> 由小写英文字母和数字组成</li>\n\t<li><code>1 <= timestamp <= 10<sup>7</sup></code></li>\n\t<li><code>set</code> 操作中的时间戳 <code>timestamp</code> 都是严格递增的</li>\n\t<li>最多调用 <code>set</code> 和 <code>get</code> 操作 <code>2 * 10<sup>5</sup></code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 982按位与为零的三元组",
        "hardRate": "HARD",
        "passRate": "67.29%",
        "problemsUrl": "https://leetcode.cn/problems/triples-with-bitwise-and-equal-to-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/triples-with-bitwise-and-equal-to-zero/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，返回其中 <strong>按位与三元组</strong> 的数目。</p>\n\n<p><strong>按位与三元组</strong> 是由下标 <code>(i, j, k)</code> 组成的三元组，并满足下述全部条件：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; nums.length</code></li>\n\t<li><code>0 &lt;= j &lt; nums.length</code></li>\n\t<li><code>0 &lt;= k &lt; nums.length</code></li>\n\t<li><code>nums[i] &amp; nums[j] &amp; nums[k] == 0</code> ，其中 <code>&amp;</code> 表示按位与运算符。</li>\n</ul>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,3]\n<strong>输出：</strong>12\n<strong>解释：</strong>可以选出如下 i, j, k 三元组：\n(i=0, j=0, k=1) : 2 &amp; 2 &amp; 1\n(i=0, j=1, k=0) : 2 &amp; 1 &amp; 2\n(i=0, j=1, k=1) : 2 &amp; 1 &amp; 1\n(i=0, j=1, k=2) : 2 &amp; 1 &amp; 3\n(i=0, j=2, k=1) : 2 &amp; 3 &amp; 1\n(i=1, j=0, k=0) : 1 &amp; 2 &amp; 2\n(i=1, j=0, k=1) : 1 &amp; 2 &amp; 1\n(i=1, j=0, k=2) : 1 &amp; 2 &amp; 3\n(i=1, j=1, k=0) : 1 &amp; 1 &amp; 2\n(i=1, j=2, k=0) : 1 &amp; 3 &amp; 2\n(i=2, j=0, k=1) : 3 &amp; 2 &amp; 1\n(i=2, j=1, k=0) : 3 &amp; 1 &amp; 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,0,0]\n<strong>输出：</strong>27\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt; 2<sup>16</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 983最低票价",
        "hardRate": "MEDIUM",
        "passRate": "63.50%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-for-tickets/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-for-tickets/solution",
        "problemsDesc": "<p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为&nbsp;<code>days</code>&nbsp;的数组给出。每一项是一个从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>365</code>&nbsp;的整数。</p>\n\n<p>火车票有 <strong>三种不同的销售方式</strong> ：</p>\n\n<ul>\n\t<li>一张 <strong>为期一天</strong> 的通行证售价为&nbsp;<code>costs[0]</code> 美元；</li>\n\t<li>一张 <strong>为期七天</strong> 的通行证售价为&nbsp;<code>costs[1]</code> 美元；</li>\n\t<li>一张 <strong>为期三十天</strong> 的通行证售价为&nbsp;<code>costs[2]</code> 美元。</li>\n</ul>\n\n<p>通行证允许数天无限制的旅行。 例如，如果我们在第 <code>2</code> 天获得一张 <strong>为期 7 天</strong> 的通行证，那么我们可以连着旅行 7 天：第 <code>2</code> 天、第 <code>3</code> 天、第 <code>4</code> 天、第 <code>5</code> 天、第 <code>6</code> 天、第 <code>7</code> 天和第 <code>8</code> 天。</p>\n\n<p>返回 <em>你想要完成在给定的列表&nbsp;<code>days</code>&nbsp;中列出的每一天的旅行所需要的最低消费&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>days = [1,4,6,7,8,20], costs = [2,7,15]\n<strong>输出：</strong>11\n<strong>解释： </strong>\n例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：\n在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。\n在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。\n在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。\n你总共花了 $11，并完成了你计划的每一天旅行。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\n<strong>输出：</strong>17\n<strong>解释：\n</strong>例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： \n在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。\n在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 \n你总共花了 $17，并完成了你计划的每一天旅行。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= days.length &lt;= 365</code></li>\n\t<li><code>1 &lt;= days[i] &lt;= 365</code></li>\n\t<li><code>days</code>&nbsp;按顺序严格递增</li>\n\t<li><code>costs.length == 3</code></li>\n\t<li><code>1 &lt;= costs[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 984不含 AAA 或 BBB 的字符串",
        "hardRate": "MEDIUM",
        "passRate": "43.40%",
        "problemsUrl": "https://leetcode.cn/problems/string-without-aaa-or-bbb/",
        "solutionsUrl": "https://leetcode.cn/problems/string-without-aaa-or-bbb/solution",
        "problemsDesc": "<p>给定两个整数 <code>a</code>&nbsp;和 <code>b</code>&nbsp;，返回&nbsp;<strong>任意</strong>&nbsp;字符串 <code>s</code>&nbsp;，要求满足：</p>\n\n<ul>\n\t<li><code>s</code>&nbsp;的长度为 <code>a + b</code>，且正好包含&nbsp;<code>a</code>&nbsp;个 <code>'a'</code>&nbsp;字母与&nbsp;<code>b</code> 个 <code>'b'</code>&nbsp;字母；</li>\n\t<li>子串&nbsp;<code>'aaa'</code>&nbsp;没有出现在 <code>s</code>&nbsp;中；</li>\n\t<li>子串&nbsp;<code>'bbb'</code> 没有出现在 <code>s</code>&nbsp;中。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 1, b = 2\n<strong>输出：</strong>\"abb\"\n<strong>解释：</strong>\"abb\", \"bab\" 和 \"bba\" 都是正确答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 4, b = 1\n<strong>输出：</strong>\"aabaa\"</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= a, b&nbsp;&lt;= 100</code></li>\n\t<li>对于给定的 <code>a</code> 和 <code>b</code>，保证存在满足要求的 <code>s</code>&nbsp;</li>\n</ul>\n<span style=\"display:block\"><span style=\"height:0px\"><span style=\"position:absolute\">​​​</span></span></span>",
        "isPlus": false
    },
    {
        "problemsName": " 985查询后的偶数和",
        "hardRate": "MEDIUM",
        "passRate": "61.11%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-even-numbers-after-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-even-numbers-after-queries/solution",
        "problemsDesc": "<p>给出一个整数数组&nbsp;<code>A</code>&nbsp;和一个查询数组&nbsp;<code>queries</code>。</p>\n\n<p>对于第&nbsp;<code>i</code>&nbsp;次查询，有&nbsp;<code>val =&nbsp;queries[i][0], index&nbsp;= queries[i][1]</code>，我们会把&nbsp;<code>val</code>&nbsp;加到&nbsp;<code>A[index]</code>&nbsp;上。然后，第&nbsp;<code>i</code>&nbsp;次查询的答案是 <code>A</code> 中偶数值的和。</p>\n\n<p><em>（此处给定的&nbsp;<code>index = queries[i][1]</code>&nbsp;是从 0 开始的索引，每次查询都会永久修改数组&nbsp;<code>A</code>。）</em></p>\n\n<p>返回所有查询的答案。你的答案应当以数组&nbsp;<code>answer</code>&nbsp;给出，<code>answer[i]</code>&nbsp;为第&nbsp;<code>i</code>&nbsp;次查询的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]\n<strong>输出：</strong>[8,6,2,4]\n<strong>解释：</strong>\n开始时，数组为 [1,2,3,4]。\n将 1 加到 A[0] 上之后，数组为 [2,2,3,4]，偶数值之和为 2 + 2 + 4 = 8。\n将 -3 加到 A[1] 上之后，数组为 [2,-1,3,4]，偶数值之和为 2 + 4 = 6。\n将 -4 加到 A[0] 上之后，数组为 [-2,-1,3,4]，偶数值之和为 -2 + 4 = 2。\n将 2 加到 A[3] 上之后，数组为 [-2,-1,3,6]，偶数值之和为 -2 + 6 = 4。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= A.length &lt;= 10000</code></li>\n\t<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10000</code></li>\n\t<li><code>-10000 &lt;= queries[i][0] &lt;= 10000</code></li>\n\t<li><code>0 &lt;= queries[i][1] &lt; A.length</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 986区间列表的交集",
        "hardRate": "MEDIUM",
        "passRate": "68.48%",
        "problemsUrl": "https://leetcode.cn/problems/interval-list-intersections/",
        "solutionsUrl": "https://leetcode.cn/problems/interval-list-intersections/solution",
        "problemsDesc": "<p>给定两个由一些<strong> 闭区间 </strong>组成的列表，<code>firstList</code> 和 <code>secondList</code> ，其中 <code>firstList[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 而 <code>secondList[j] = [start<sub>j</sub>, end<sub>j</sub>]</code> 。每个区间列表都是成对 <strong>不相交</strong> 的，并且 <strong>已经排序</strong> 。</p>\n\n<p>返回这 <strong>两个区间列表的交集</strong> 。</p>\n\n<p>形式上，<strong>闭区间</strong> <code>[a, b]</code>（其中 <code>a <= b</code>）表示实数 <code>x</code> 的集合，而 <code>a <= x <= b</code> 。</p>\n\n<p>两个闭区间的 <strong>交集</strong> 是一组实数，要么为空集，要么为闭区间。例如，<code>[1, 3]</code> 和 <code>[2, 4]</code> 的交集为 <code>[2, 3]</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/30/interval1.png\" style=\"width: 700px; height: 194px;\" />\n<pre>\n<strong>输入：</strong>firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]\n<strong>输出：</strong>[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>firstList = [[1,3],[5,9]], secondList = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>firstList = [], secondList = [[4,8],[10,12]]\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>firstList = [[1,7]], secondList = [[3,10]]\n<strong>输出：</strong>[[3,7]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= firstList.length, secondList.length <= 1000</code></li>\n\t<li><code>firstList.length + secondList.length >= 1</code></li>\n\t<li><code>0 <= start<sub>i</sub> < end<sub>i</sub> <= 10<sup>9</sup></code></li>\n\t<li><code>end<sub>i</sub> < start<sub>i+1</sub></code></li>\n\t<li><code>0 <= start<sub>j</sub> < end<sub>j</sub> <= 10<sup>9</sup> </code></li>\n\t<li><code>end<sub>j</sub> < start<sub>j+1</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 987二叉树的垂序遍历",
        "hardRate": "HARD",
        "passRate": "53.79%",
        "problemsUrl": "https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/solution",
        "problemsDesc": "<p>给你二叉树的根结点 <code>root</code> ，请你设计算法计算二叉树的<em> </em><strong>垂序遍历</strong> 序列。</p>\n\n<p>对位于 <code>(row, col)</code> 的每个结点而言，其左右子结点分别位于 <code>(row + 1, col - 1)</code> 和 <code>(row + 1, col + 1)</code> 。树的根结点位于 <code>(0, 0)</code> 。</p>\n\n<p>二叉树的 <strong>垂序遍历</strong> 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。</p>\n\n<p>返回二叉树的 <strong>垂序遍历</strong> 序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg\" style=\"width: 431px; height: 304px;\" />\n<pre>\n<strong>输入：</strong>root = [3,9,20,null,null,15,7]\n<strong>输出：</strong>[[9],[3,15],[20],[7]]\n<strong>解释：</strong>\n列 -1 ：只有结点 9 在此列中。\n列  0 ：只有结点 3 和 15 在此列中，按从上到下顺序。\n列  1 ：只有结点 20 在此列中。\n列  2 ：只有结点 7 在此列中。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg\" style=\"width: 512px; height: 304px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,5,6,7]\n<strong>输出：</strong>[[4],[2],[1,5,6],[3],[7]]\n<strong>解释：</strong>\n列 -2 ：只有结点 4 在此列中。\n列 -1 ：只有结点 2 在此列中。\n列  0 ：结点 1 、5 和 6 都在此列中。\n          1 在上面，所以它出现在前面。\n          5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。\n列  1 ：只有结点 3 在此列中。\n列  2 ：只有结点 7 在此列中。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg\" style=\"width: 512px; height: 304px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,6,5,7]\n<strong>输出：</strong>[[4],[2],[1,5,6],[3],[7]]\n<strong>解释：</strong>\n这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。\n因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中结点数目总数在范围 <code>[1, 1000]</code> 内</li>\n\t<li><code>0 <= Node.val <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 988从叶结点开始的最小字符串",
        "hardRate": "MEDIUM",
        "passRate": "51.18%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-string-starting-from-leaf/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-string-starting-from-leaf/solution",
        "problemsDesc": "<p>给定一颗根结点为&nbsp;<code>root</code>&nbsp;的二叉树，树中的每一个结点都有一个&nbsp;<code>[0, 25]</code>&nbsp;范围内的值，分别代表字母&nbsp;<code>'a'</code> 到&nbsp;<code>'z'</code>。</p>\n\n<p>返回 <em><strong>按字典序最小</strong> 的字符串，该字符串从这棵树的一个叶结点开始，到根结点结束</em>。</p>\n\n<blockquote>\n<p>注<strong>：</strong>字符串中任何较短的前缀在 <strong>字典序上</strong> 都是 <strong>较小</strong> 的：</p>\n\n<ul>\n\t<li>例如，在字典序上&nbsp;<code>\"ab\"</code> 比&nbsp;<code>\"aba\"</code>&nbsp;要小。叶结点是指没有子结点的结点。&nbsp;</li>\n</ul>\n</blockquote>\n\n<p>节点的叶节点是没有子节点的节点。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/02/tree1.png\" style=\"height: 358px; width: 534px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [0,1,2,3,4,3,4]\n<strong>输出：</strong>\"dba\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2019/01/30/tree2.png\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [25,1,3,1,3,0,2]\n<strong>输出：</strong>\"adz\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2019/02/01/tree3.png\" style=\"height: 513px; width: 490px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [2,2,1,null,1,0,null,0]\n<strong>输出：</strong>\"abc\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给定树的结点数在&nbsp;<code>[1, 8500]</code> 范围内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 25</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 989数组形式的整数加法",
        "hardRate": "EASY",
        "passRate": "45.96%",
        "problemsUrl": "https://leetcode.cn/problems/add-to-array-form-of-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/add-to-array-form-of-integer/solution",
        "problemsDesc": "<p>整数的 <strong>数组形式</strong> &nbsp;<code>num</code>&nbsp;是按照从左到右的顺序表示其数字的数组。</p>\n\n<ul>\n\t<li>例如，对于 <code>num = 1321</code> ，数组形式是 <code>[1,3,2,1]</code> 。</li>\n</ul>\n\n<p>给定 <code>num</code> ，整数的 <strong>数组形式</strong> ，和整数 <code>k</code> ，返回 <em>整数 <code>num + k</code> 的 <strong>数组形式</strong></em> 。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = [1,2,0,0], k = 34\n<strong>输出：</strong>[1,2,3,4]\n<strong>解释：</strong>1200 + 34 = 1234\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = [2,7,4], k = 181\n<strong>输出：</strong>[4,5,5]\n<strong>解释：</strong>274 + 181 = 455\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = [2,1,5], k = 806\n<strong>输出：</strong>[1,0,2,1]\n<strong>解释：</strong>215 + 806 = 1021\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= num[i] &lt;= 9</code></li>\n\t<li><code>num</code>&nbsp;不包含任何前导零，除了零本身</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 990等式方程的可满足性",
        "hardRate": "MEDIUM",
        "passRate": "53.44%",
        "problemsUrl": "https://leetcode.cn/problems/satisfiability-of-equality-equations/",
        "solutionsUrl": "https://leetcode.cn/problems/satisfiability-of-equality-equations/solution",
        "problemsDesc": "<p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 <code>equations[i]</code> 的长度为 <code>4</code>，并采用两种不同的形式之一：<code>&quot;a==b&quot;</code> 或&nbsp;<code>&quot;a!=b&quot;</code>。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p>\n\n<p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回&nbsp;<code>true</code>，否则返回 <code>false</code>。&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[&quot;a==b&quot;,&quot;b!=a&quot;]\n<strong>输出：</strong>false\n<strong>解释：</strong>如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>[&quot;b==a&quot;,&quot;a==b&quot;]\n<strong>输出：</strong>true\n<strong>解释：</strong>我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>[&quot;a==b&quot;,&quot;b==c&quot;,&quot;a==c&quot;]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>[&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>[&quot;c==c&quot;,&quot;b==d&quot;,&quot;x!=z&quot;]\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= equations.length &lt;= 500</code></li>\n\t<li><code>equations[i].length == 4</code></li>\n\t<li><code>equations[i][0]</code> 和&nbsp;<code>equations[i][3]</code>&nbsp;是小写字母</li>\n\t<li><code>equations[i][1]</code> 要么是&nbsp;<code>&#39;=&#39;</code>，要么是&nbsp;<code>&#39;!&#39;</code></li>\n\t<li><code>equations[i][2]</code>&nbsp;是&nbsp;<code>&#39;=&#39;</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 991坏了的计算器",
        "hardRate": "MEDIUM",
        "passRate": "52.30%",
        "problemsUrl": "https://leetcode.cn/problems/broken-calculator/",
        "solutionsUrl": "https://leetcode.cn/problems/broken-calculator/solution",
        "problemsDesc": "<p>在显示着数字&nbsp;<code>startValue</code>&nbsp;的坏计算器上，我们可以执行以下两种操作：</p>\n\n<ul>\n\t<li><strong>双倍（Double）：</strong>将显示屏上的数字乘 2；</li>\n\t<li><strong>递减（Decrement）：</strong>将显示屏上的数字减 <code>1</code> 。</li>\n</ul>\n\n<p>给定两个整数&nbsp;<code>startValue</code>&nbsp;和&nbsp;<code>target</code>&nbsp;。返回显示数字&nbsp;<code>target</code>&nbsp;所需的最小操作数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>startValue = 2, target = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>先进行双倍运算，然后再进行递减运算 {2 -&gt; 4 -&gt; 3}.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>startValue = 5, target = 8\n<strong>输出：</strong>2\n<strong>解释：</strong>先递减，再双倍 {5 -&gt; 4 -&gt; 8}.\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>startValue = 3, target = 10\n<strong>输出：</strong>3\n<strong>解释：</strong>先双倍，然后递减，再双倍 {3 -&gt; 6 -&gt; 5 -&gt; 10}.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= startValue, target &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 992K 个不同整数的子数组",
        "hardRate": "HARD",
        "passRate": "47.45%",
        "problemsUrl": "https://leetcode.cn/problems/subarrays-with-k-different-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/subarrays-with-k-different-integers/solution",
        "problemsDesc": "<p>给定一个正整数数组 <code>nums</code>和一个整数 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">\bk</span></span></font></font>&nbsp;，返回 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">num</span></span></font></font>&nbsp;中 「<strong>好子数组」</strong><em>&nbsp;</em>的数目。</p>\n\n<p>如果 <code>nums</code>&nbsp;的某个子数组中不同整数的个数恰好为 <code>k</code>，则称 <code>nums</code>&nbsp;的这个连续、不一定不同的子数组为 <strong>「</strong><strong>好子数组 」</strong>。</p>\n\n<ul>\n\t<li>例如，<code>[1,2,3,1,2]</code> 中有&nbsp;<code>3</code>&nbsp;个不同的整数：<code>1</code>，<code>2</code>，以及&nbsp;<code>3</code>。</li>\n</ul>\n\n<p><strong>子数组</strong> 是数组的 <strong>连续</strong> 部分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,2,3], k = 2\n<strong>输出：</strong>7\n<strong>解释：</strong>恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,3,4], k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 993二叉树的堂兄弟节点",
        "hardRate": "EASY",
        "passRate": "55.78%",
        "problemsUrl": "https://leetcode.cn/problems/cousins-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/cousins-in-binary-tree/solution",
        "problemsDesc": "<p>在二叉树中，根节点位于深度 <code>0</code> 处，每个深度为 <code>k</code> 的节点的子节点位于深度 <code>k+1</code> 处。</p>\n\n<p>如果二叉树的两个节点深度相同，但<strong> 父节点不同</strong> ，则它们是一对<em>堂兄弟节点</em>。</p>\n\n<p>我们给出了具有唯一值的二叉树的根节点 <code>root</code> ，以及树中两个不同节点的值 <code>x</code> 和 <code>y</code> 。</p>\n\n<p>只有与值 <code>x</code> 和 <code>y</code> 对应的节点是堂兄弟节点时，才返回 <code>true</code> 。否则，返回 <code>false</code>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：<br />\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png\" style=\"height: 160px; width: 180px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,4], x = 4, y = 3\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 2：<br />\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-02.png\" style=\"height: 160px; width: 201px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,null,4,null,5], x = 5, y = 4\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-03.png\" style=\"height: 160px; width: 156px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,null,4], x = 2, y = 3\n<strong>输出：</strong>false</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉树的节点数介于 <code>2</code> 到 <code>100</code> 之间。</li>\n\t<li>每个节点的值都是唯一的、范围为 <code>1</code> 到 <code>100</code> 的整数。</li>\n</ul>\n\n<p> </p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 994腐烂的橘子",
        "hardRate": "MEDIUM",
        "passRate": "51.00%",
        "problemsUrl": "https://leetcode.cn/problems/rotting-oranges/",
        "solutionsUrl": "https://leetcode.cn/problems/rotting-oranges/solution",
        "problemsDesc": "<p>在给定的&nbsp;<code>m x n</code>&nbsp;网格<meta charset=\"UTF-8\" />&nbsp;<code>grid</code>&nbsp;中，每个单元格可以有以下三个值之一：</p>\n\n<ul>\n\t<li>值&nbsp;<code>0</code>&nbsp;代表空单元格；</li>\n\t<li>值&nbsp;<code>1</code>&nbsp;代表新鲜橘子；</li>\n\t<li>值&nbsp;<code>2</code>&nbsp;代表腐烂的橘子。</li>\n</ul>\n\n<p>每分钟，腐烂的橘子&nbsp;<strong>周围&nbsp;4 个方向上相邻</strong> 的新鲜橘子都会腐烂。</p>\n\n<p>返回 <em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回&nbsp;<code>-1</code></em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png\" style=\"height: 137px; width: 650px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[2,1,1],[1,1,0],[0,1,1]]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[2,1,1],[0,1,1],[1,0,1]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,2]]\n<strong>输出：</strong>0\n<strong>解释：</strong>因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10</code></li>\n\t<li><code>grid[i][j]</code> 仅为&nbsp;<code>0</code>、<code>1</code>&nbsp;或&nbsp;<code>2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 995K 连续位的最小翻转次数",
        "hardRate": "HARD",
        "passRate": "53.94%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/solution",
        "problemsDesc": "<p>给定一个二进制数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>\n\n<p><strong>k位翻转</strong> 就是从 <code>nums</code> 中选择一个长度为 <code>k</code> 的 <strong>子数组</strong> ，同时把子数组中的每一个 <code>0</code> 都改成 <code>1</code> ，把子数组中的每一个 <code>1</code> 都改成 <code>0</code> 。</p>\n\n<p>返回数组中不存在 <code>0</code> 所需的最小 <strong>k位翻转</strong> 次数。如果不可能，则返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p><strong>子数组</strong> 是数组的 <strong>连续</strong> 部分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,0], K = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>先翻转 A[0]，然后翻转 A[2]。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,0], K = 2\n<strong>输出：</strong>-1\n<strong>解释：</strong>无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,0,0,1,0,1,1,0], K = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>\n翻转 A[0],A[1],A[2]:&nbsp;A变成 [1,1,1,1,0,1,1,0]\n翻转 A[4],A[5],A[6]:&nbsp;A变成 [1,1,1,1,1,0,0,0]\n翻转 A[5],A[6],A[7]:&nbsp;A变成 [1,1,1,1,1,1,1,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 996正方形数组的数目",
        "hardRate": "HARD",
        "passRate": "50.34%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-squareful-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-squareful-arrays/solution",
        "problemsDesc": "<p>给定一个非负整数数组&nbsp;<code>A</code>，如果该数组每对相邻元素之和是一个完全平方数，则称这一数组为<em>正方形</em>数组。</p>\n\n<p>返回 A 的正方形排列的数目。两个排列 <code>A1</code> 和 <code>A2</code> 不同的充要条件是存在某个索引 <code>i</code>，使得 A1[i] != A2[i]。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[1,17,8]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n[1,8,17] 和 [17,8,1] 都是有效的排列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>[2,2,2]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= A.length &lt;= 12</code></li>\n\t<li><code>0 &lt;= A[i] &lt;= 1e9</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 997找到小镇的法官",
        "hardRate": "EASY",
        "passRate": "51.86%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-town-judge/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-town-judge/solution",
        "problemsDesc": "<p>小镇里有 <code>n</code> 个人，按从 <code>1</code> 到 <code>n</code> 的顺序编号。传言称，这些人中有一个暗地里是小镇法官。</p>\n\n<p>如果小镇法官真的存在，那么：</p>\n\n<ol>\n\t<li>小镇法官不会信任任何人。</li>\n\t<li>每个人（除了小镇法官）都信任这位小镇法官。</li>\n\t<li>只有一个人同时满足属性 <strong>1</strong> 和属性 <strong>2</strong> 。</li>\n</ol>\n\n<p>给你一个数组 <code>trust</code> ，其中 <code>trust[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示编号为 <code>a<sub>i</sub></code> 的人信任编号为 <code>b<sub>i</sub></code> 的人。</p>\n\n<p>如果小镇法官存在并且可以确定他的身份，请返回该法官的编号；否则，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, trust = [[1,2]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, trust = [[1,3],[2,3]]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, trust = [[1,3],[2,3],[3,1]]\n<strong>输出：</strong>-1\n</pre>\n&nbsp;\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= trust.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>trust[i].length == 2</code></li>\n\t<li><code>trust</code> 中的所有<code>trust[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> <strong>互不相同</strong></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 998最大二叉树 II",
        "hardRate": "MEDIUM",
        "passRate": "68.72%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-binary-tree-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-binary-tree-ii/solution",
        "problemsDesc": "<p><strong>最大树</strong> 定义：一棵树，并满足：其中每个节点的值都大于其子树中的任何其他值。</p>\n\n<p>给你最大树的根节点 <code>root</code> 和一个整数 <code>val</code> 。</p>\n\n<p>就像 <a href=\"https://leetcode.cn/problems/maximum-binary-tree/\" target=\"_blank\">之前的问题</a> 那样，给定的树是利用 <code>Construct(a)</code>&nbsp;例程从列表&nbsp;<code>a</code>（<code>root = Construct(a)</code>）递归地构建的：</p>\n\n<ul>\n\t<li>如果 <code>a</code> 为空，返回&nbsp;<code>null</code> 。</li>\n\t<li>否则，令&nbsp;<code>a[i]</code> 作为 <code>a</code> 的最大元素。创建一个值为&nbsp;<code>a[i]</code>&nbsp;的根节点 <code>root</code> 。</li>\n\t<li><code>root</code>&nbsp;的左子树将被构建为&nbsp;<code>Construct([a[0], a[1], ..., a[i - 1]])</code> 。</li>\n\t<li><code>root</code>&nbsp;的右子树将被构建为&nbsp;<code>Construct([a[i + 1], a[i + 2], ..., a[a.length - 1]])</code> 。</li>\n\t<li>返回&nbsp;<code>root</code> 。</li>\n</ul>\n\n<p>请注意，题目没有直接给出 <code>a</code> ，只是给出一个根节点&nbsp;<code>root = Construct(a)</code> 。</p>\n\n<p>假设 <code>b</code> 是 <code>a</code> 的副本，并在末尾附加值 <code>val</code>。题目数据保证 <code>b</code> 中的值互不相同。</p>\n\n<p>返回&nbsp;<code>Construct(b)</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-1-1.png\" style=\"height: 160px; width: 159px;\" /><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-1-2.png\" style=\"height: 160px; width: 169px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [4,1,3,null,null,2], val = 5\n<strong>输出：</strong>[5,4,null,1,3,null,null,2]\n<strong>解释：</strong>a = [1,4,2,3], b = [1,4,2,3,5]</pre>\n\n<p><strong>示例 2：<br />\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-2-1.png\" style=\"height: 160px; width: 180px;\" /><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-2-2.png\" style=\"height: 160px; width: 214px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [5,2,4,null,1], val = 3\n<strong>输出：</strong>[5,2,4,null,1,null,3]\n<strong>解释：</strong>a = [2,1,5,4], b = [2,1,5,4,3]</pre>\n\n<p><strong>示例 3：<br />\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-3-1.png\" style=\"height: 160px; width: 180px;\" /><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-3-2.png\" style=\"height: 160px; width: 201px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [5,2,3,null,1], val = 4\n<strong>输出：</strong>[5,2,4,null,1,3]\n<strong>解释：</strong>a = [2,1,5,3], b = [2,1,5,3,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[1, 100]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 100</code></li>\n\t<li>树中的所有值 <strong>互不相同</strong></li>\n\t<li><code>1 &lt;= val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 999可以被一步捕获的棋子数",
        "hardRate": "EASY",
        "passRate": "69.34%",
        "problemsUrl": "https://leetcode.cn/problems/available-captures-for-rook/",
        "solutionsUrl": "https://leetcode.cn/problems/available-captures-for-rook/solution",
        "problemsDesc": "<p>在一个 8 x 8 的棋盘上，有一个白色的车（<code>Rook</code>），用字符 <code>&#39;R&#39;</code> 表示。棋盘上还可能存在空方块，白色的象（<code>Bishop</code>）以及黑色的卒（<code>pawn</code>），分别用字符 <code>&#39;.&#39;</code>，<code>&#39;B&#39;</code> 和 <code>&#39;p&#39;</code> 表示。不难看出，大写字符表示的是白棋，小写字符表示的是黑棋。</p>\n\n<p>车按国际象棋中的规则移动。东，西，南，北四个基本方向任选其一，然后一直向选定的方向移动，直到满足下列四个条件之一：</p>\n\n<ul>\n\t<li>棋手选择主动停下来。</li>\n\t<li>棋子因到达棋盘的边缘而停下。</li>\n\t<li>棋子移动到某一方格来捕获位于该方格上敌方（黑色）的卒，停在该方格内。</li>\n\t<li>车不能进入/越过已经放有其他友方棋子（白色的象）的方格，停在友方棋子前。</li>\n</ul>\n\n<p>你现在可以控制车移动一次，请你统计有多少敌方的卒处于你的捕获范围内（即，可以被一步捕获的棋子数）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_1_improved.PNG\" style=\"height: 305px; width: 300px;\"></p>\n\n<pre><strong>输入：</strong>[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]\n<strong>输出：</strong>3\n<strong>解释：\n</strong>在本例中，车能够捕获所有的卒。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_2_improved.PNG\" style=\"height: 306px; width: 300px;\"></p>\n\n<pre><strong>输入：</strong>[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;R&quot;,&quot;B&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]\n<strong>输出：</strong>0\n<strong>解释：\n</strong>象阻止了车捕获任何卒。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_3_improved.PNG\" style=\"height: 305px; width: 300px;\"></p>\n\n<pre><strong>输入：</strong>[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]\n<strong>输出：</strong>3\n<strong>解释： </strong>\n车可以捕获位置 b5，d6 和 f5 的卒。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>board.length == board[i].length == 8</code></li>\n\t<li><code>board[i][j]</code> 可以是&nbsp;<code>&#39;R&#39;</code>，<code>&#39;.&#39;</code>，<code>&#39;B&#39;</code>&nbsp;或&nbsp;<code>&#39;p&#39;</code></li>\n\t<li>只有一个格子上存在&nbsp;<code>board[i][j] == &#39;R&#39;</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1000合并石头的最低成本",
        "hardRate": "HARD",
        "passRate": "53.60%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-merge-stones/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-merge-stones/solution",
        "problemsDesc": "<p>有 <code>n</code> 堆石头排成一排，第 <code>i</code> 堆中有&nbsp;<code>stones[i]</code>&nbsp;块石头。</p>\n\n<p>每次 <strong>移动</strong> 需要将 <strong>连续的</strong> <code>k</code> 堆石头合并为一堆，而这次移动的成本为这 <code>k</code> 堆中石头的总数。</p>\n\n<p>返回把所有石头合并成一堆的最低成本。如果无法合并成一堆，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [3,2,4,1], K = 2\n<strong>输出：</strong>20\n<strong>解释：</strong>\n从 [3, 2, 4, 1] 开始。\n合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。\n合并 [4, 1]，成本为 5，剩下 [5, 5]。\n合并 [5, 5]，成本为 10，剩下 [10]。\n总成本 20，这是可能的最小值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [3,2,4,1], K = 3\n<strong>输出：</strong>-1\n<strong>解释：</strong>任何合并操作后，都会剩下 2 堆，我们无法再进行合并。所以这项任务是不可能完成的。.\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [3,5,1,2,6], K = 3\n<strong>输出：</strong>25\n<strong>解释：</strong>\n从 [3, 5, 1, 2, 6] 开始。\n合并 [5, 1, 2]，成本为 8，剩下 [3, 8, 6]。\n合并 [3, 8, 6]，成本为 17，剩下 [17]。\n总成本 25，这是可能的最小值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == stones.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n\t<li><code>1 &lt;= stones[i] &lt;= 100</code></li>\n\t<li><code>2 &lt;= k &lt;= 30</code></li>\n</ul>\n",
        "isPlus": false
    }
]