[
    {
        "problemsName": " 1901.寻找峰值 II",
        "hardRate": "MEDIUM",
        "passRate": "58.93%",
        "problemsUrl": "https://leetcode.cn/problems/find-a-peak-element-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/find-a-peak-element-ii/solution",
        "problemsDesc": "<p>一个 2D 网格中的 <strong>峰值</strong><strong> </strong>是指那些 <strong>严格大于 </strong>其相邻格子(上、下、左、右)的元素。</p>\n\n<p>给你一个<strong> 从 0 开始编号 </strong>的 <code>m x n</code> 矩阵 <code>mat</code> ，其中任意两个相邻格子的值都<strong> 不相同</strong> 。找出 <strong>任意一个 峰值</strong> <code>mat[i][j]</code> 并 <strong>返回其位置 </strong><code>[i,j]</code> 。</p>\n\n<p>你可以假设整个矩阵周边环绕着一圈值为 <code>-1</code> 的格子。</p>\n\n<p>要求必须写出时间复杂度为 <code>O(m log(n))</code> 或 <code>O(n log(m))</code> 的算法</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/08/1.png\" style=\"width: 206px; height: 209px;\" /></p>\n\n<pre>\n<strong>输入:</strong> mat = [[1,4],[3,2]]\n<strong>输出:</strong> [0,1]\n<strong>解释:</strong>&nbsp;3 和 4 都是峰值，所以[1,0]和[0,1]都是可接受的答案。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/07/3.png\" style=\"width: 254px; height: 257px;\" /></strong></p>\n\n<pre>\n<strong>输入:</strong> mat = [[10,20,15],[21,30,14],[7,16,32]]\n<strong>输出:</strong> [1,1]\n<strong>解释:</strong>&nbsp;30 和 32 都是峰值，所以[1,1]和[2,2]都是可接受的答案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>1 &lt;= mat[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li>任意两个相邻元素均不相等.</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1902.给定二叉搜索树的插入顺序求深度",
        "hardRate": "MEDIUM",
        "passRate": "51.10%",
        "problemsUrl": "https://leetcode.cn/problems/depth-of-bst-given-insertion-order/",
        "solutionsUrl": "https://leetcode.cn/problems/depth-of-bst-given-insertion-order/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1903.字符串中的最大奇数",
        "hardRate": "EASY",
        "passRate": "60.47%",
        "problemsUrl": "https://leetcode.cn/problems/largest-odd-number-in-string/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-odd-number-in-string/solution",
        "problemsDesc": "<p>给你一个字符串 <code>num</code> ，表示一个大整数。请你在字符串 <code>num</code> 的所有 <strong>非空子字符串</strong> 中找出 <strong>值最大的奇数</strong> ，并以字符串形式返回。如果不存在奇数，则返回一个空字符串<em> </em><code>\"\"</code><em> </em>。</p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续的字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"52\"\n<strong>输出：</strong>\"5\"\n<strong>解释：</strong>非空子字符串仅有 \"5\"、\"2\" 和 \"52\" 。\"5\" 是其中唯一的奇数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"4206\"\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>在 \"4206\" 中不存在奇数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"35427\"\n<strong>输出：</strong>\"35427\"\n<strong>解释：</strong>\"35427\" 本身就是一个奇数。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= num.length <= 10<sup>5</sup></code></li>\n\t<li><code>num</code> 仅由数字组成且不含前导零</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1904.你完成的完整对局数",
        "hardRate": "MEDIUM",
        "passRate": "31.42%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-full-rounds-you-have-played/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-full-rounds-you-have-played/solution",
        "problemsDesc": "<p>一款新的在线电子游戏在近期发布，在该电子游戏中，以 <strong>刻钟</strong> 为周期规划若干时长为 <strong>15 分钟</strong> 的游戏对局。这意味着，在 <code>HH:00</code>、<code>HH:15</code>、<code>HH:30</code> 和 <code>HH:45</code> ，将会开始一个新的对局，其中 <code>HH</code> 用一个从 <code>00</code> 到 <code>23</code> 的整数表示。游戏中使用 <strong>24 小时制的时钟</strong> ，所以一天中最早的时间是 <code>00:00</code> ，最晚的时间是 <code>23:59</code> 。</p>\n\n<p>给你两个字符串 <code>startTime</code> 和 <code>finishTime</code> ，均符合 <code>\"HH:MM\"</code> 格式，分别表示你 <strong>进入</strong> 和 <strong>退出</strong> 游戏的确切时间，请计算在整个游戏会话期间，你完成的 <strong>完整对局的对局数</strong> 。</p>\n\n<ul>\n\t<li>例如，如果 <code>startTime = \"05:20\"</code> 且 <code>finishTime = \"05:59\"</code> ，这意味着你仅仅完成从 <code>05:30</code> 到 <code>05:45</code> 这一个完整对局。而你没有完成从 <code>05:15</code> 到 <code>05:30</code> 的完整对局，因为你是在对局开始后进入的游戏；同时，你也没有完成从 <code>05:45</code> 到 <code>06:00</code> 的完整对局，因为你是在对局结束前退出的游戏。</li>\n</ul>\n\n<p>如果 <code>finishTime</code> <strong>早于</strong> <code>startTime</code> ，这表示你玩了个通宵（也就是从 <code>startTime</code> 到午夜，再从午夜到 <code>finishTime</code>）。</p>\n\n<p>假设你是从 <code>startTime</code> 进入游戏，并在 <code>finishTime</code> 退出游戏，请计算并返回你完成的 <strong>完整对局的对局数</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>startTime = \"12:01\", finishTime = \"12:44\"\n<strong>输出：</strong>1\n<strong>解释：</strong>你完成了从 12:15 到 12:30 的一个完整对局。\n你没有完成从 12:00 到 12:15 的完整对局，因为你是在对局开始后的 12:01 进入的游戏。\n你没有完成从 12:30 到 12:45 的完整对局，因为你是在对局结束前的 12:44 退出的游戏。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>startTime = \"20:00\", finishTime = \"06:00\"\n<strong>输出：</strong>40\n<strong>解释：</strong>你完成了从 20:00 到 00:00 的 16 个完整的对局，以及从 00:00 到 06:00 的 24 个完整的对局。\n16 + 24 = 40\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>startTime = \"00:00\", finishTime = \"23:59\"\n<strong>输出：</strong>95\n<strong>解释：</strong>除最后一个小时你只完成了 3 个完整对局外，其余每个小时均完成了 4 场完整对局。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>startTime</code> 和 <code>finishTime</code> 的格式为 <code>HH:MM</code></li>\n\t<li><code>00 <= HH <= 23</code></li>\n\t<li><code>00 <= MM <= 59</code></li>\n\t<li><code>startTime</code> 和 <code>finishTime</code> 不相等</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1905.统计子岛屿",
        "hardRate": "MEDIUM",
        "passRate": "67.18%",
        "problemsUrl": "https://leetcode.cn/problems/count-sub-islands/",
        "solutionsUrl": "https://leetcode.cn/problems/count-sub-islands/solution",
        "problemsDesc": "<p>给你两个 <code>m x n</code> 的二进制矩阵 <code>grid1</code> 和 <code>grid2</code> ，它们只包含 <code>0</code> （表示水域）和 <code>1</code> （表示陆地）。一个 <strong>岛屿</strong> 是由 <strong>四个方向</strong> （水平或者竖直）上相邻的 <code>1</code> 组成的区域。任何矩阵以外的区域都视为水域。</p>\n\n<p>如果 <code>grid2</code> 的一个岛屿，被 <code>grid1</code> 的一个岛屿 <strong>完全</strong> 包含，也就是说 <code>grid2</code> 中该岛屿的每一个格子都被 <code>grid1</code> 中同一个岛屿完全包含，那么我们称 <code>grid2</code> 中的这个岛屿为 <strong>子岛屿</strong> 。</p>\n\n<p>请你返回 <code>grid2</code> 中 <strong>子岛屿</strong> 的 <strong>数目</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/10/test1.png\" style=\"width: 493px; height: 205px;\">\n<pre><b>输入：</b>grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]\n<b>输出：</b>3\n<strong>解释：</strong>如上图所示，左边为 grid1 ，右边为 grid2 。\ngrid2 中标红的 1 区域是子岛屿，总共有 3 个子岛屿。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/03/testcasex2.png\" style=\"width: 491px; height: 201px;\">\n<pre><b>输入：</b>grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\n<b>输出：</b>2 \n<strong>解释：</strong>如上图所示，左边为 grid1 ，右边为 grid2 。\ngrid2 中标红的 1 区域是子岛屿，总共有 2 个子岛屿。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid1.length == grid2.length</code></li>\n\t<li><code>n == grid1[i].length == grid2[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>grid1[i][j]</code> 和 <code>grid2[i][j]</code> 都要么是 <code>0</code> 要么是 <code>1</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1906.查询差绝对值的最小值",
        "hardRate": "MEDIUM",
        "passRate": "45.03%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-absolute-difference-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-absolute-difference-queries/solution",
        "problemsDesc": "<p>一个数组 <code>a</code> 的 <strong>差绝对值的最小值</strong> 定义为：<code>0 <= i < j < a.length</code> 且 <code>a[i] != a[j]</code> 的<strong> </strong><code><span style=\"\">|a[i] - a[j]|</span></code> 的 <strong>最小值</strong>。如果 <code>a</code> 中所有元素都 <strong>相同</strong> ，那么差绝对值的最小值为 <code>-1</code> 。</p>\n\n<ul>\n\t<li>比方说，数组 <code>[5,<strong>2</strong>,<strong>3</strong>,7,2]</code> 差绝对值的最小值是 <code>|2 - 3| = 1</code> 。注意答案不为 <code>0</code> ，因为 <code>a[i]</code> 和 <code>a[j]</code> 必须不相等。</li>\n</ul>\n\n<p>给你一个整数数组 <code>nums</code> 和查询数组 <code>queries</code> ，其中 <code>queries[i] = [l<sub>i</sub>, r<sub>i</sub>]</code> 。对于每个查询 <code>i</code> ，计算 <strong>子数组</strong> <code>nums[l<sub>i</sub>...r<sub>i</sub>]</code> 中 <strong>差绝对值的最小值</strong> ，子数组 <code>nums[l<sub>i</sub>...r<sub>i</sub>]</code> 包含 <code>nums</code> 数组（下标从 <strong>0</strong> 开始）中下标在 <code>l<sub>i</sub></code> 和 <code>r<sub>i</sub></code> 之间的所有元素（包含 <code>l<sub>i</sub></code> 和 <code>r<sub>i</sub></code> 在内）。</p>\n\n<p>请你返回 <code>ans</code> <strong>数组</strong>，其中 <code>ans[i]</code> 是第 <code>i</code> 个查询的答案。</p>\n\n<p><strong>子数组</strong> 是一个数组中连续的一段元素。</p>\n\n<p><code>|x|</code> 的值定义为：</p>\n\n<ul>\n\t<li>如果 <code>x >= 0</code> ，那么值为 <code>x</code> 。</li>\n\t<li>如果 <code>x < 0</code> ，那么值为 <code>-x</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,3,4,8], queries = [[0,1],[1,2],[2,3],[0,3]]\n<b>输出：</b>[2,1,4,1]\n<b>解释：</b>查询结果如下：\n- queries[0] = [0,1]：子数组是 [<strong>1</strong>,<strong>3</strong>] ，差绝对值的最小值为 |1-3| = 2 。\n- queries[1] = [1,2]：子数组是 [<strong>3</strong>,<strong>4</strong>] ，差绝对值的最小值为 |3-4| = 1 。\n- queries[2] = [2,3]：子数组是 [<strong>4</strong>,<strong>8</strong>] ，差绝对值的最小值为 |4-8| = 4 。\n- queries[3] = [0,3]：子数组是 [1,<strong>3</strong>,<strong>4</strong>,8] ，差的绝对值的最小值为 |3-4| = 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [4,5,2,2,7,10], queries = [[2,3],[0,2],[0,5],[3,5]]\n<b>输出：</b>[-1,1,1,3]\n<strong>解释：</strong>查询结果如下：\n- queries[0] = [2,3]：子数组是 [2,2] ，差绝对值的最小值为 -1 ，因为所有元素相等。\n- queries[1] = [0,2]：子数组是 [<strong>4</strong>,<strong>5</strong>,2] ，差绝对值的最小值为 |4-5| = 1 。\n- queries[2] = [0,5]：子数组是 [<strong>4</strong>,<strong>5</strong>,2,2,7,10] ，差绝对值的最小值为 |4-5| = 1 。\n- queries[3] = [3,5]：子数组是 [2,<strong>7</strong>,<strong>10</strong>] ，差绝对值的最小值为 |7-10| = 3 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 100</code></li>\n\t<li><code>1 <= queries.length <= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 <= l<sub>i</sub> < r<sub>i</sub> < nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1907.按分类统计薪水",
        "hardRate": "MEDIUM",
        "passRate": "63.78%",
        "problemsUrl": "https://leetcode.cn/problems/count-salary-categories/",
        "solutionsUrl": "https://leetcode.cn/problems/count-salary-categories/solution",
        "problemsDesc": "<p>表: <code>Accounts</code></p>\n\n<pre>\n+-------------+------+\n| 列名        | 类型  |\n+-------------+------+\n| account_id  | int  |\n| income      | int  |\n+-------------+------+\naccount_id&nbsp;是这个表的主键。\n每一行都包含一个银行帐户的月收入的信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写出一个&nbsp;SQL&nbsp;查询，来报告每个工资类别的银行账户数量。&nbsp;工资类别如下：</p>\n\n<ul>\n\t<li><code>\"Low Salary\"</code>：所有工资 <strong>严格低于</strong> <code>20000</code> 美元。</li>\n\t<li><code>\"Average Salary\"</code>： <strong>包含</strong> 范围内的所有工资&nbsp;<code>[$20000,&nbsp;$50000]</code> 。</li>\n\t<li>\n\t<p><code>\"High Salary\"</code>：所有工资 <strong>严格大于</strong> <code>50000</code> 美元。</p>\n\t</li>\n</ul>\n\n<p>结果表 <strong>必须</strong> 包含所有三个类别。&nbsp;如果某个类别中没有帐户，则报告&nbsp;<code>0</code> 。</p>\n\n<p>按 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式如下示例。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>\nAccounts 表:\n+------------+--------+\n| account_id | income |\n+------------+--------+\n| 3          | 108939 |\n| 2          | 12747  |\n| 8          | 87709  |\n| 6          | 91796  |\n+------------+--------+\n<strong>输出：</strong>\n+----------------+----------------+\n| category       | accounts_count |\n+----------------+----------------+\n| Low Salary     | 1              |\n| Average Salary | 0              |\n| High Salary    | 3              |\n+----------------+----------------+\n<strong>解释：</strong>\n低薪: 数量为 2.\n中等薪水: 没有.\n高薪: 有三个账户，他们是 3, 6和 8.</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1908.Nim 游戏 II",
        "hardRate": "MEDIUM",
        "passRate": "62.47%",
        "problemsUrl": "https://leetcode.cn/problems/game-of-nim/",
        "solutionsUrl": "https://leetcode.cn/problems/game-of-nim/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1909.删除一个元素使数组严格递增",
        "hardRate": "EASY",
        "passRate": "29.96%",
        "problemsUrl": "https://leetcode.cn/problems/remove-one-element-to-make-the-array-strictly-increasing/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-one-element-to-make-the-array-strictly-increasing/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，如果 <strong>恰好</strong> 删除 <strong>一个</strong> 元素后，数组 <strong>严格递增</strong> ，那么请你返回 <code>true</code> ，否则返回 <code>false</code> 。如果数组本身已经是严格递增的，请你也返回 <code>true</code> 。</p>\n\n<p>数组 <code>nums</code> 是 <strong>严格递增</strong> 的定义为：对于任意下标的 <code>1 &lt;= i &lt; nums.length</code> 都满足 <code>nums[i - 1] &lt; nums[i]</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,<strong>10</strong>,5,7]\n<b>输出：</b>true\n<b>解释：</b>从 nums 中删除下标 2 处的 10 ，得到 [1,2,5,7] 。\n[1,2,5,7] 是严格递增的，所以返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,3,1,2]\n<b>输出：</b>false\n<b>解释：</b>\n[3,1,2] 是删除下标 0 处元素后得到的结果。\n[2,1,2] 是删除下标 1 处元素后得到的结果。\n[2,3,2] 是删除下标 2 处元素后得到的结果。\n[2,3,1] 是删除下标 3 处元素后得到的结果。\n没有任何结果数组是严格递增的，所以返回 false 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [1,1,1]\n<b>输出：</b>false\n<b>解释：</b>删除任意元素后的结果都是 [1,1] 。\n[1,1] 不是严格递增的，所以返回 false 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3]\n<b>输出：</b>true\n<b>解释：</b>[1,2,3] 已经是严格递增的，所以返回 true 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1910.删除一个字符串中所有出现的给定子字符串",
        "hardRate": "MEDIUM",
        "passRate": "66.41%",
        "problemsUrl": "https://leetcode.cn/problems/remove-all-occurrences-of-a-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-all-occurrences-of-a-substring/solution",
        "problemsDesc": "<p>给你两个字符串 <code>s</code> 和 <code>part</code> ，请你对 <code>s</code> 反复执行以下操作直到 <b>所有</b> 子字符串 <code>part</code> 都被删除：</p>\n\n<ul>\n\t<li>找到 <code>s</code> 中 <strong>最左边</strong> 的子字符串 <code>part</code> ，并将它从 <code>s</code> 中删除。</li>\n</ul>\n\n<p>请你返回从 <code>s</code> 中删除所有 <code>part</code> 子字符串以后得到的剩余字符串。</p>\n\n<p>一个 <strong>子字符串</strong> 是一个字符串中连续的字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"daabcbaabcbc\", part = \"abc\"\n<b>输出：</b>\"dab\"\n<b>解释：</b>以下操作按顺序执行：\n- s = \"da<strong>abc</strong>baabcbc\" ，删除下标从 2 开始的 \"abc\" ，得到 s = \"dabaabcbc\" 。\n- s = \"daba<strong>abc</strong>bc\" ，删除下标从 4 开始的 \"abc\" ，得到 s = \"dababc\" 。\n- s = \"dab<strong>abc</strong>\" ，删除下标从 3 开始的 \"abc\" ，得到 s = \"dab\" 。\n此时 s 中不再含有子字符串 \"abc\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"axxxxyyyyb\", part = \"xy\"\n<b>输出：</b>\"ab\"\n<b>解释：</b>以下操作按顺序执行：\n- s = \"axxx<strong>xy</strong>yyyb\" ，删除下标从 4 开始的 \"xy\" ，得到 s = \"axxxyyyb\" 。\n- s = \"axx<strong>xy</strong>yyb\" ，删除下标从 3 开始的 \"xy\" ，得到 s = \"axxyyb\" 。\n- s = \"ax<strong>xy</strong>yb\" ，删除下标从 2 开始的 \"xy\" ，得到 s = \"axyb\" 。\n- s = \"a<strong>xy</strong>b\" ，删除下标从 1 开始的 \"xy\" ，得到 s = \"ab\" 。\n此时 s 中不再含有子字符串 \"xy\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= part.length &lt;= 1000</code></li>\n\t<li><code>s</code>​​​​​​ 和 <code>part</code> 只包小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1911.最大子序列交替和",
        "hardRate": "MEDIUM",
        "passRate": "67.49%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-alternating-subsequence-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-alternating-subsequence-sum/solution",
        "problemsDesc": "<p>一个下标从 <strong>0</strong> 开始的数组的 <strong>交替和</strong> 定义为 <strong>偶数</strong> 下标处元素之 <strong>和</strong> 减去 <strong>奇数</strong> 下标处元素之 <strong>和</strong> 。</p>\n\n<ul>\n\t<li>比方说，数组 <code>[4,2,5,3]</code> 的交替和为 <code>(4 + 5) - (2 + 3) = 4</code> 。</li>\n</ul>\n\n<p>给你一个数组 <code>nums</code> ，请你返回 <code>nums</code> 中任意子序列的 <strong>最大交替和</strong> （子序列的下标 <strong>重新</strong> 从 0 开始编号）。</p>\n\n<ul>\n</ul>\n\n<p>一个数组的 <strong>子序列</strong> 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。比方说，<code>[2,7,4]</code> 是 <code>[4,<strong>2</strong>,3,<strong>7</strong>,2,1,<strong>4</strong>]</code> 的一个子序列（加粗元素），但是 <code>[2,4,2]</code> 不是。</p>\n\n<p> </p>\n\n<p><b>示例 1：</b></p>\n\n<pre><b>输入：</b>nums = [<strong>4</strong>,<strong>2</strong>,<strong>5</strong>,3]\n<b>输出：</b>7\n<b>解释：</b>最优子序列为 [4,2,5] ，交替和为 (4 + 5) - 2 = 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [5,6,7,<strong>8</strong>]\n<b>输出：</b>8\n<b>解释：</b>最优子序列为 [8] ，交替和为 8 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [<strong>6</strong>,2,<strong>1</strong>,2,4,<strong>5</strong>]\n<b>输出：</b>10\n<b>解释：</b>最优子序列为 [6,1,5] ，交替和为 (6 + 5) - 1 = 10 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1912.设计电影租借系统",
        "hardRate": "HARD",
        "passRate": "24.14%",
        "problemsUrl": "https://leetcode.cn/problems/design-movie-rental-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-movie-rental-system/solution",
        "problemsDesc": "<p>你有一个电影租借公司和 <code>n</code> 个电影商店。你想要实现一个电影租借系统，它支持查询、预订和返还电影的操作。同时系统还能生成一份当前被借出电影的报告。</p>\n\n<p>所有电影用二维整数数组 <code>entries</code> 表示，其中 <code>entries[i] = [shop<sub>i</sub>, movie<sub>i</sub>, price<sub>i</sub>]</code> 表示商店 <code>shop<sub>i</sub></code> 有一份电影 <code>movie<sub>i</sub></code> 的拷贝，租借价格为 <code>price<sub>i</sub></code> 。每个商店有 <strong>至多一份</strong> 编号为 <code>movie<sub>i</sub></code> 的电影拷贝。</p>\n\n<p>系统需要支持以下操作：</p>\n\n<ul>\n\t<li><strong>Search：</strong>找到拥有指定电影且 <strong>未借出</strong> 的商店中 <strong>最便宜的 5 个</strong> 。商店需要按照 <strong>价格</strong> 升序排序，如果价格相同，则 <code>shop<sub>i</sub></code> <strong>较小</strong> 的商店排在前面。如果查询结果少于 5 个商店，则将它们全部返回。如果查询结果没有任何商店，则返回空列表。</li>\n\t<li><strong>Rent：</strong>从指定商店借出指定电影，题目保证指定电影在指定商店 <strong>未借出</strong> 。</li>\n\t<li><strong>Drop：</strong>在指定商店返还 <strong>之前已借出</strong> 的指定电影。</li>\n\t<li><strong>Report：</strong>返回 <strong>最便宜的 5 部已借出电影</strong> （可能有重复的电影 ID），将结果用二维列表 <code>res</code> 返回，其中 <code>res[j] = [shop<sub>j</sub>, movie<sub>j</sub>]</code> 表示第 <code>j</code> 便宜的已借出电影是从商店 <code>shop<sub>j</sub></code> 借出的电影 <code>movie<sub>j</sub></code> 。<code>res</code> 中的电影需要按 <strong>价格</strong> 升序排序；如果价格相同，则<strong> </strong><code>shop<sub>j</sub></code> <strong>较小</strong> 的排在前面；如果仍然相同，则 <code>movie<sub>j</sub></code> <strong>较小 </strong>的排在前面。如果当前借出的电影小于 5 部，则将它们全部返回。如果当前没有借出电影，则返回一个空的列表。</li>\n</ul>\n\n<p>请你实现 <code>MovieRentingSystem</code> 类：</p>\n\n<ul>\n\t<li><code>MovieRentingSystem(int n, int[][] entries)</code> 将 <code>MovieRentingSystem</code> 对象用 <code>n</code> 个商店和 <code>entries</code> 表示的电影列表初始化。</li>\n\t<li><code>List&lt;Integer&gt; search(int movie)</code> 如上所述，返回 <strong>未借出</strong> 指定 <code>movie</code> 的商店列表。</li>\n\t<li><code>void rent(int shop, int movie)</code> 从指定商店 <code>shop</code> 借出指定电影 <code>movie</code> 。</li>\n\t<li><code>void drop(int shop, int movie)</code> 在指定商店 <code>shop</code> 返还之前借出的电影 <code>movie</code> 。</li>\n\t<li><code>List&lt;List&lt;Integer&gt;&gt; report()</code> 如上所述，返回最便宜的 <strong>已借出</strong> 电影列表。</li>\n</ul>\n\n<p><strong>注意：</strong>测试数据保证 <code>rent</code> 操作中指定商店拥有 <strong>未借出 </strong>的指定电影，且 <code>drop</code> 操作指定的商店 <strong>之前已借出</strong> 指定电影。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"MovieRentingSystem\", \"search\", \"rent\", \"rent\", \"report\", \"drop\", \"search\"]\n[[3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]], [1], [0, 1], [1, 2], [], [1, 2], [2]]\n<strong>输出：</strong>\n[null, [1, 0, 2], null, null, [[0, 1], [1, 2]], null, [0, 1]]\n\n<strong>解释：</strong>\nMovieRentingSystem movieRentingSystem = new MovieRentingSystem(3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]);\nmovieRentingSystem.search(1);  // 返回 [1, 0, 2] ，商店 1，0 和 2 有未借出的 ID 为 1 的电影。商店 1 最便宜，商店 0 和 2 价格相同，所以按商店编号排序。\nmovieRentingSystem.rent(0, 1); // 从商店 0 借出电影 1 。现在商店 0 未借出电影编号为 [2,3] 。\nmovieRentingSystem.rent(1, 2); // 从商店 1 借出电影 2 。现在商店 1 未借出的电影编号为 [1] 。\nmovieRentingSystem.report();   // 返回 [[0, 1], [1, 2]] 。商店 0 借出的电影 1 最便宜，然后是商店 1 借出的电影 2 。\nmovieRentingSystem.drop(1, 2); // 在商店 1 返还电影 2 。现在商店 1 未借出的电影编号为 [1,2] 。\nmovieRentingSystem.search(2);  // 返回 [0, 1] 。商店 0 和 1 有未借出的 ID 为 2 的电影。商店 0 最便宜，然后是商店 1 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 3 * 10<sup>5</sup></code></li>\n\t<li><code>1 <= entries.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= shop<sub>i</sub> < n</code></li>\n\t<li><code>1 <= movie<sub>i</sub>, price<sub>i</sub> <= 10<sup>4</sup></code></li>\n\t<li>每个商店 <strong>至多</strong> 有一份电影 <code>movie<sub>i</sub></code> 的拷贝。</li>\n\t<li><code>search</code>，<code>rent</code>，<code>drop</code> 和 <code>report</code> 的调用 <strong>总共</strong> 不超过 <code>10<sup>5</sup></code> 次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1913.两个数对之间的最大乘积差",
        "hardRate": "EASY",
        "passRate": "81.40%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-product-difference-between-two-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-product-difference-between-two-pairs/solution",
        "problemsDesc": "<p>两个数对 <code>(a, b)</code> 和 <code>(c, d)</code> 之间的 <strong>乘积差</strong> 定义为 <code>(a * b) - (c * d)</code> 。</p>\n\n<ul>\n\t<li>例如，<code>(5, 6)</code> 和 <code>(2, 7)</code> 之间的乘积差是 <code>(5 * 6) - (2 * 7) = 16</code> 。</li>\n</ul>\n\n<p>给你一个整数数组 <code>nums</code> ，选出四个 <strong>不同的</strong> 下标 <code>w</code>、<code>x</code>、<code>y</code> 和 <code>z</code> ，使数对 <code>(nums[w], nums[x])</code> 和 <code>(nums[y], nums[z])</code> 之间的 <strong>乘积差</strong> 取到 <strong>最大值</strong> 。</p>\n\n<p>返回以这种方式取得的乘积差中的 <strong>最大值</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,6,2,7,4]\n<strong>输出：</strong>34\n<strong>解释：</strong>可以选出下标为 1 和 3 的元素构成第一个数对 (6, 7) 以及下标 2 和 4 构成第二个数对 (2, 4)\n乘积差是 (6 * 7) - (2 * 4) = 34\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,2,5,9,7,4,8]\n<strong>输出：</strong>64\n<strong>解释：</strong>可以选出下标为 3 和 6 的元素构成第一个数对 (9, 8) 以及下标 1 和 5 构成第二个数对 (2, 4)\n乘积差是 (9 * 8) - (2 * 4) = 64\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>4 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1914.循环轮转矩阵",
        "hardRate": "MEDIUM",
        "passRate": "46.56%",
        "problemsUrl": "https://leetcode.cn/problems/cyclically-rotating-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/cyclically-rotating-a-grid/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的整数矩阵 <code>grid</code>​​​ ，其中 <code>m</code> 和 <code>n</code> 都是 <strong>偶数</strong> ；另给你一个整数 <code>k</code> 。</p>\n\n<p>矩阵由若干层组成，如下图所示，每种颜色代表一层：</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/10/ringofgrid.png\" style=\"width: 231px; height: 258px;\"></p>\n\n<p>矩阵的循环轮转是通过分别循环轮转矩阵中的每一层完成的。在对某一层进行一次循环旋转操作时，层中的每一个元素将会取代其 <strong>逆时针 </strong>方向的相邻元素。轮转示例如下：</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/22/explanation_grid.jpg\" style=\"width: 500px; height: 268px;\">\n<p>返回执行 <code>k</code> 次循环轮转操作后的矩阵。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/19/rod2.png\" style=\"width: 421px; height: 191px;\">\n<pre><strong>输入：</strong>grid = [[40,10],[30,20]], k = 1\n<strong>输出：</strong>[[10,20],[40,30]]\n<strong>解释：</strong>上图展示了矩阵在执行循环轮转操作时每一步的状态。</pre>\n\n<p><strong>示例 2：</strong></p>\n<strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/10/ringofgrid5.png\" style=\"width: 231px; height: 262px;\"></strong> <strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/10/ringofgrid6.png\" style=\"width: 231px; height: 262px;\"></strong> <strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/10/ringofgrid7.png\" style=\"width: 231px; height: 262px;\"></strong>\n\n<pre><strong>输入：</strong>grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2\n<strong>输出：</strong>[[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]]\n<strong>解释：</strong>上图展示了矩阵在执行循环轮转操作时每一步的状态。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>m</code> 和 <code>n</code> 都是 <strong>偶数</strong></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;=<sup> </sup>5000</code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1915.最美子字符串的数目",
        "hardRate": "MEDIUM",
        "passRate": "44.65%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-wonderful-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-wonderful-substrings/solution",
        "problemsDesc": "<p>如果某个字符串中 <strong>至多一个</strong> 字母出现 <strong>奇数</strong> 次，则称其为 <strong>最美</strong> 字符串。</p>\n\n<ul>\n\t<li>例如，<code>\"ccjjc\"</code> 和 <code>\"abab\"</code> 都是最美字符串，但 <code>\"ab\"</code> 不是。</li>\n</ul>\n\n<p>给你一个字符串 <code>word</code> ，该字符串由前十个小写英文字母组成（<code>'a'</code> 到 <code>'j'</code>）。请你返回 <code>word</code> 中 <strong>最美非空子字符串</strong> 的数目<em>。</em>如果同样的子字符串在<em> </em><code>word</code> 中出现多次，那么应当对 <strong>每次出现</strong> 分别计数<em>。</em></p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"aba\"\n<strong>输出：</strong>4\n<strong>解释：</strong>4 个最美子字符串如下所示：\n- \"<strong>a</strong>ba\" -> \"a\"\n- \"a<strong>b</strong>a\" -> \"b\"\n- \"ab<strong>a</strong>\" -> \"a\"\n- \"<strong>aba</strong>\" -> \"aba\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"aabb\"\n<strong>输出：</strong>9\n<strong>解释：</strong>9 个最美子字符串如下所示：\n- \"<strong>a</strong>abb\" -> \"a\"\n- \"<strong>aa</strong>bb\" -> \"aa\"\n- \"<strong>aab</strong>b\" -> \"aab\"\n- \"<strong>aabb</strong>\" -> \"aabb\"\n- \"a<strong>a</strong>bb\" -> \"a\"\n- \"a<strong>abb</strong>\" -> \"abb\"\n- \"aa<strong>b</strong>b\" -> \"b\"\n- \"aa<strong>bb</strong>\" -> \"bb\"\n- \"aab<strong>b</strong>\" -> \"b\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"he\"\n<strong>输出：</strong>2\n<strong>解释：</strong>2 个最美子字符串如下所示：\n- \"<b>h</b>e\" -> \"h\"\n- \"h<strong>e</strong>\" -> \"e\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word.length <= 10<sup>5</sup></code></li>\n\t<li><code>word</code> 由从 <code>'a'</code> 到 <code>'j'</code> 的小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1916.统计为蚁群构筑房间的不同顺序",
        "hardRate": "HARD",
        "passRate": "55.70%",
        "problemsUrl": "https://leetcode.cn/problems/count-ways-to-build-rooms-in-an-ant-colony/",
        "solutionsUrl": "https://leetcode.cn/problems/count-ways-to-build-rooms-in-an-ant-colony/solution",
        "problemsDesc": "<p>你是一只蚂蚁，负责为蚁群构筑 <code>n</code> 间编号从 <code>0</code> 到 <code>n-1</code> 的新房间。给你一个 <strong>下标从 0 开始</strong> 且长度为 <code>n</code> 的整数数组&nbsp;<code>prevRoom</code> 作为扩建计划。其中，<code>prevRoom[i]</code> 表示在构筑房间 <code>i</code> 之前，你必须先构筑房间 <code>prevRoom[i]</code> ，并且这两个房间必须 <strong>直接</strong> 相连。房间 <code>0</code> 已经构筑完成，所以 <code>prevRoom[0] = -1</code> 。扩建计划中还有一条硬性要求，在完成所有房间的构筑之后，从房间 <code>0</code> 可以访问到每个房间。</p>\n\n<p>你一次只能构筑 <strong>一个</strong> 房间。你可以在 <strong>已经构筑好的</strong> 房间之间自由穿行，只要这些房间是 <strong>相连的</strong> 。如果房间&nbsp;<code>prevRoom[i]</code> 已经构筑完成，那么你就可以构筑房间 <code>i</code>。</p>\n\n<p>返回你构筑所有房间的 <strong>不同顺序的数目</strong> 。由于答案可能很大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/19/d1.JPG\" style=\"width: 200px; height: 212px;\" />\n<pre>\n<strong>输入：</strong><code>prevRoom</code> = [-1,0,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>仅有一种方案可以完成所有房间的构筑：0 → 1 → 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/19/d2.JPG\" style=\"width: 200px; height: 239px;\" /></strong>\n\n<pre>\n<strong>输入：</strong><code>prevRoom</code> = [-1,0,0,1,2]\n<strong>输出：</strong>6\n<strong>解释：\n</strong>有 6 种不同顺序：\n0 → 1 → 3 → 2 → 4\n0 → 2 → 4 → 1 → 3\n0 → 1 → 2 → 3 → 4\n0 → 1 → 2 → 4 → 3\n0 → 2 → 1 → 3 → 4\n0 → 2 → 1 → 4 → 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == prevRoom.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>prevRoom[0] == -1</code></li>\n\t<li>对于所有的&nbsp;<code>1 &lt;= i &lt; n</code>&nbsp;，都有&nbsp;<code>0 &lt;= prevRoom[i] &lt; n</code></li>\n\t<li>题目保证所有房间都构筑完成后，从房间 <code>0</code> 可以访问到每个房间</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1917.Leetcodify 好友推荐",
        "hardRate": "HARD",
        "passRate": "31.52%",
        "problemsUrl": "https://leetcode.cn/problems/leetcodify-friends-recommendations/",
        "solutionsUrl": "https://leetcode.cn/problems/leetcodify-friends-recommendations/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1918.第 K 小的子数组和·",
        "hardRate": "MEDIUM",
        "passRate": "47.98%",
        "problemsUrl": "https://leetcode.cn/problems/kth-smallest-subarray-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-smallest-subarray-sum/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1919.兴趣相同的朋友",
        "hardRate": "HARD",
        "passRate": "43.47%",
        "problemsUrl": "https://leetcode.cn/problems/leetcodify-similar-friends/",
        "solutionsUrl": "https://leetcode.cn/problems/leetcodify-similar-friends/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1920.基于排列构建数组",
        "hardRate": "EASY",
        "passRate": "86.62%",
        "problemsUrl": "https://leetcode.cn/problems/build-array-from-permutation/",
        "solutionsUrl": "https://leetcode.cn/problems/build-array-from-permutation/solution",
        "problemsDesc": "<p>给你一个 <strong>从 0 开始的排列</strong> <code>nums</code>（<strong>下标也从 0 开始</strong>）。请你构建一个 <strong>同样长度</strong> 的数组 <code>ans</code> ，其中，对于每个 <code>i</code>（<code>0 &lt;= i &lt; nums.length</code>），都满足 <code>ans[i] = nums[nums[i]]</code> 。返回构建好的数组 <code>ans</code> 。</p>\n\n<p><strong>从 0 开始的排列</strong> <code>nums</code> 是一个由 <code>0</code> 到 <code>nums.length - 1</code>（<code>0</code> 和 <code>nums.length - 1</code> 也包含在内）的不同整数组成的数组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,2,1,5,3,4]\n<strong>输出：</strong>[0,1,2,4,5,3]<strong>\n解释：</strong>数组 ans 构建如下：\nans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n    = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]]\n    = [0,1,2,4,5,3]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,0,1,2,3,4]\n<strong>输出：</strong>[4,5,0,1,2,3]\n<strong>解释：</strong>数组 ans 构建如下：\nans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n    = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]]\n    = [4,5,0,1,2,3]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt; nums.length</code></li>\n\t<li><code>nums</code> 中的元素 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1921.消灭怪物的最大数量",
        "hardRate": "MEDIUM",
        "passRate": "37.06%",
        "problemsUrl": "https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/",
        "solutionsUrl": "https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/solution",
        "problemsDesc": "<p>你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。给你一个 <strong>下标从 0 开始</strong> 且长度为 <code>n</code> 的整数数组 <code>dist</code> ，其中 <code>dist[i]</code> 是第 <code>i</code> 个怪物与城市的 <strong>初始距离</strong>（单位：米）。</p>\n\n<p>怪物以 <strong>恒定</strong> 的速度走向城市。给你一个长度为 <code>n</code> 的整数数组 <code>speed</code> 表示每个怪物的速度，其中 <code>speed[i]</code> 是第 <code>i</code> 个怪物的速度（单位：米/分）。</p>\n\n<p>怪物从 <strong>第 0 分钟</strong> 时开始移动。你有一把武器，并可以 <strong>选择</strong> 在每一分钟的开始时使用，包括第 0 分钟。但是你无法在一分钟的中间使用武器。这种武器威力惊人，一次可以消灭任一还活着的怪物。</p>\n\n<p>一旦任一怪物到达城市，你就输掉了这场游戏。如果某个怪物 <strong>恰</strong> 在某一分钟开始时到达城市，这会被视为<strong> 输掉</strong> 游戏，在你可以使用武器之前，游戏就会结束。</p>\n\n<p>返回在你输掉游戏前可以消灭的怪物的 <strong>最大</strong> 数量。如果你可以在所有怪物到达城市前将它们全部消灭，返回  <code>n</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [1,3,4], speed = [1,1,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n第 0 分钟开始时，怪物的距离是 [1,3,4]，你消灭了第一个怪物。\n第 1 分钟开始时，怪物的距离是 [X,2,3]，你没有消灭任何怪物。\n第 2 分钟开始时，怪物的距离是 [X,1,2]，你消灭了第二个怪物。\n第 3 分钟开始时，怪物的距离是 [X,X,1]，你消灭了第三个怪物。\n所有 3 个怪物都可以被消灭。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [1,1,2,3], speed = [1,1,1,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n第 0 分钟开始时，怪物的距离是 [1,1,2,3]，你消灭了第一个怪物。\n第 1 分钟开始时，怪物的距离是 [X,0,1,2]，你输掉了游戏。\n你只能消灭 1 个怪物。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [3,2,4], speed = [5,3,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n第 0 分钟开始时，怪物的距离是 [3,2,4]，你消灭了第一个怪物。\n第 1 分钟开始时，怪物的距离是 [X,0,2]，你输掉了游戏。 \n你只能消灭 1 个怪物。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == dist.length == speed.length</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= dist[i], speed[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1922.统计好数字的数目",
        "hardRate": "MEDIUM",
        "passRate": "36.20%",
        "problemsUrl": "https://leetcode.cn/problems/count-good-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/count-good-numbers/solution",
        "problemsDesc": "<p>我们称一个数字字符串是 <strong>好数字</strong> 当它满足（下标从 <strong>0</strong> 开始）<strong>偶数</strong> 下标处的数字为 <strong>偶数</strong> 且 <strong>奇数</strong> 下标处的数字为 <strong>质数</strong> （<code>2</code>，<code>3</code>，<code>5</code> 或 <code>7</code>）。</p>\n\n<ul>\n\t<li>比方说，<code>\"2582\"</code> 是好数字，因为偶数下标处的数字（<code>2</code> 和 <code>8</code>）是偶数且奇数下标处的数字（<code>5</code> 和 <code>2</code>）为质数。但 <code>\"3245\"</code> <strong>不是</strong> 好数字，因为 <code>3</code> 在偶数下标处但不是偶数。</li>\n</ul>\n\n<p>给你一个整数 <code>n</code> ，请你返回长度为 <code>n</code> 且为好数字的数字字符串 <strong>总数</strong> 。由于答案可能会很大，请你将它对<strong> </strong><code>10<sup>9</sup> + 7</code> <strong>取余后返回</strong> 。</p>\n\n<p>一个 <strong>数字字符串</strong> 是每一位都由 <code>0</code> 到 <code>9</code> 组成的字符串，且可能包含前导 0 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 1\n<b>输出：</b>5\n<b>解释：</b>长度为 1 的好数字包括 \"0\"，\"2\"，\"4\"，\"6\"，\"8\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 4\n<b>输出：</b>400\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 50\n<b>输出：</b>564908303\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 10<sup>15</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1923.最长公共子路径",
        "hardRate": "HARD",
        "passRate": "26.79%",
        "problemsUrl": "https://leetcode.cn/problems/longest-common-subpath/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-common-subpath/solution",
        "problemsDesc": "<p>一个国家由 <code>n</code> 个编号为 <code>0</code> 到 <code>n - 1</code> 的城市组成。在这个国家里，<strong>每两个</strong> 城市之间都有一条道路连接。</p>\n\n<p>总共有 <code>m</code> 个编号为 <code>0</code> 到 <code>m - 1</code> 的朋友想在这个国家旅游。他们每一个人的路径都会包含一些城市。每条路径都由一个整数数组表示，每个整数数组表示一个朋友按顺序访问过的城市序列。同一个城市在一条路径中可能 <strong>重复</strong> 出现，但同一个城市在一条路径中不会连续出现。</p>\n\n<p>给你一个整数 <code>n</code> 和二维数组 <code>paths</code> ，其中 <code>paths[i]</code> 是一个整数数组，表示第 <code>i</code> 个朋友走过的路径，请你返回 <strong>每一个</strong> 朋友都走过的 <strong>最长公共子路径</strong> 的长度，如果不存在公共子路径，请你返回 <code>0</code> 。</p>\n\n<p>一个 <strong>子路径</strong> 指的是一条路径中连续的城市序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5, paths = [[0,1,<strong>2,3</strong>,4],\n                     [<strong>2,3</strong>,4],\n                     [4,0,1,<strong>2,3</strong>]]\n<b>输出：</b>2\n<b>解释：</b>最长公共子路径为 [2,3] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, paths = [[0],[1],[2]]\n<b>输出：</b>0\n<b>解释：</b>三条路径没有公共子路径。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5, paths = [[<strong>0</strong>,1,2,3,4],\n                     [4,3,2,1,<strong>0</strong>]]\n<b>输出：</b>1\n<b>解释：</b>最长公共子路径为 [0]，[1]，[2]，[3] 和 [4] 。它们长度都为 1 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>m == paths.length</code></li>\n\t<li><code>2 <= m <= 10<sup>5</sup></code></li>\n\t<li><code>sum(paths[i].length) <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= paths[i][j] < n</code></li>\n\t<li><code>paths[i]</code> 中同一个城市不会连续重复出现。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1924.安装栅栏 II",
        "hardRate": "HARD",
        "passRate": "44.84%",
        "problemsUrl": "https://leetcode.cn/problems/erect-the-fence-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/erect-the-fence-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1925.统计平方和三元组的数目",
        "hardRate": "EASY",
        "passRate": "69.56%",
        "problemsUrl": "https://leetcode.cn/problems/count-square-sum-triples/",
        "solutionsUrl": "https://leetcode.cn/problems/count-square-sum-triples/solution",
        "problemsDesc": "<p>一个 <strong>平方和三元组</strong> <code>(a,b,c)</code> 指的是满足 <code>a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup></code> 的 <strong>整数 </strong>三元组 <code>a</code>，<code>b</code> 和 <code>c</code> 。</p>\n\n<p>给你一个整数 <code>n</code> ，请你返回满足<em> </em><code>1 &lt;= a, b, c &lt;= n</code> 的 <strong>平方和三元组</strong> 的数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 5\n<b>输出：</b>2\n<b>解释：</b>平方和三元组为 (3,4,5) 和 (4,3,5) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 10\n<b>输出：</b>4\n<b>解释：</b>平方和三元组为 (3,4,5)，(4,3,5)，(6,8,10) 和 (8,6,10) 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 250</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1926.迷宫中离入口最近的出口",
        "hardRate": "MEDIUM",
        "passRate": "39.43%",
        "problemsUrl": "https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/",
        "solutionsUrl": "https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的迷宫矩阵 <code>maze</code> （<strong>下标从 0 开始</strong>），矩阵中有空格子（用 <code>'.'</code> 表示）和墙（用 <code>'+'</code> 表示）。同时给你迷宫的入口 <code>entrance</code> ，用 <code>entrance = [entrance<sub>row</sub>, entrance<sub>col</sub>]</code> 表示你一开始所在格子的行和列。</p>\n\n<p>每一步操作，你可以往 <strong>上</strong>，<strong>下</strong>，<strong>左</strong> 或者 <strong>右</strong> 移动一个格子。你不能进入墙所在的格子，你也不能离开迷宫。你的目标是找到离 <code>entrance</code> <strong>最近</strong> 的出口。<strong>出口</strong> 的含义是 <code>maze</code> <strong>边界</strong> 上的 <strong>空格子</strong>。<code>entrance</code> 格子 <strong>不算</strong> 出口。</p>\n\n<p>请你返回从 <code>entrance</code> 到最近出口的最短路径的 <strong>步数</strong> ，如果不存在这样的路径，请你返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/nearest1-grid.jpg\" style=\"width: 333px; height: 253px;\">\n<pre><b>输入：</b>maze = [[\"+\",\"+\",\".\",\"+\"],[\".\",\".\",\".\",\"+\"],[\"+\",\"+\",\"+\",\".\"]], entrance = [1,2]\n<b>输出：</b>1\n<b>解释：</b>总共有 3 个出口，分别位于 (1,0)，(0,2) 和 (2,3) 。\n一开始，你在入口格子 (1,2) 处。\n- 你可以往左移动 2 步到达 (1,0) 。\n- 你可以往上移动 1 步到达 (0,2) 。\n从入口处没法到达 (2,3) 。\n所以，最近的出口是 (0,2) ，距离为 1 步。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/nearesr2-grid.jpg\" style=\"width: 253px; height: 253px;\">\n<pre><b>输入：</b>maze = [[\"+\",\"+\",\"+\"],[\".\",\".\",\".\"],[\"+\",\"+\",\"+\"]], entrance = [1,0]\n<b>输出：</b>2\n<b>解释：</b>迷宫中只有 1 个出口，在 (1,2) 处。\n(1,0) 不算出口，因为它是入口格子。\n初始时，你在入口与格子 (1,0) 处。\n- 你可以往右移动 2 步到达 (1,2) 处。\n所以，最近的出口为 (1,2) ，距离为 2 步。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/nearest3-grid.jpg\" style=\"width: 173px; height: 93px;\">\n<pre><b>输入：</b>maze = [[\".\",\"+\"]], entrance = [0,0]\n<b>输出：</b>-1\n<b>解释：</b>这个迷宫中没有出口。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>maze.length == m</code></li>\n\t<li><code>maze[i].length == n</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>maze[i][j]</code> 要么是 <code>'.'</code> ，要么是 <code>'+'</code> 。</li>\n\t<li><code>entrance.length == 2</code></li>\n\t<li><code>0 &lt;= entrance<sub>row</sub> &lt; m</code></li>\n\t<li><code>0 &lt;= entrance<sub>col</sub> &lt; n</code></li>\n\t<li><code>entrance</code> 一定是空格子。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1927.求和游戏",
        "hardRate": "MEDIUM",
        "passRate": "43.56%",
        "problemsUrl": "https://leetcode.cn/problems/sum-game/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-game/solution",
        "problemsDesc": "<p>Alice 和 Bob 玩一个游戏，两人轮流行动，<strong>Alice 先手</strong> 。</p>\n\n<p>给你一个 <strong>偶数长度</strong> 的字符串 <code>num</code> ，每一个字符为数字字符或者 <code>'?'</code> 。每一次操作中，如果 <code>num</code> 中至少有一个 <code>'?'</code> ，那么玩家可以执行以下操作：</p>\n\n<ol>\n\t<li>选择一个下标 <code>i</code> 满足 <code>num[i] == '?'</code> 。</li>\n\t<li>将 <code>num[i]</code> 用 <code>'0'</code> 到 <code>'9'</code> 之间的一个数字字符替代。</li>\n</ol>\n\n<p>当 <code>num</code> 中没有<span style=\"\"> </span><code>'?'</code> 时，游戏结束。</p>\n\n<p>Bob 获胜的条件是 <code>num</code> 中前一半数字的和 <strong>等于</strong> 后一半数字的和。Alice 获胜的条件是前一半的和与后一半的和 <strong>不相等</strong> 。</p>\n\n<ul>\n\t<li>比方说，游戏结束时 <code>num = \"243801\"</code> ，那么 Bob 获胜，因为 <code>2+4+3 = 8+0+1</code> 。如果游戏结束时 <code>num = \"243803\"</code> ，那么 Alice 获胜，因为 <code>2+4+3 != 8+0+3</code> 。</li>\n</ul>\n\n<p>在 Alice 和 Bob 都采取 <strong>最优</strong> 策略的前提下，如果 Alice 获胜，请返回 <code>true</code> ，如果 Bob 获胜，请返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>num = \"5023\"\n<b>输出：</b>false\n<b>解释：</b>num 中没有 '?' ，没法进行任何操作。\n前一半的和等于后一半的和：5 + 0 = 2 + 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>num = \"25??\"\n<b>输出：</b>true\n<strong>解释：</strong>Alice 可以将两个 '?' 中的一个替换为 '9' ，Bob 无论如何都无法使前一半的和等于后一半的和。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>num = \"?3295???\"\n<b>输出：</b>false\n<b>解释：</b>Bob 总是能赢。一种可能的结果是：\n- Alice 将第一个 '?' 用 '9' 替换。num = \"93295???\" 。\n- Bob 将后面一半中的一个 '?' 替换为 '9' 。num = \"932959??\" 。\n- Alice 将后面一半中的一个 '?' 替换为 '2' 。num = \"9329592?\" 。\n- Bob 将后面一半中最后一个 '?' 替换为 '7' 。num = \"93295927\" 。\nBob 获胜，因为 9 + 3 + 2 + 9 = 5 + 9 + 2 + 7 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= num.length <= 10<sup>5</sup></code></li>\n\t<li><code>num.length</code> 是 <strong>偶数</strong> 。</li>\n\t<li><code>num</code> 只包含数字字符和 <code>'?'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1928.规定时间内到达终点的最小花费",
        "hardRate": "HARD",
        "passRate": "45.93%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/solution",
        "problemsDesc": "<p>一个国家有 <code>n</code> 个城市，城市编号为 <code>0</code> 到 <code>n - 1</code> ，题目保证 <strong>所有城市</strong> 都由双向道路 <b>连接在一起</b> 。道路由二维整数数组 <code>edges</code> 表示，其中 <code>edges[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>]</code> 表示城市 <code>x<sub>i</sub></code> 和 <code>y<sub>i</sub></code> 之间有一条双向道路，耗费时间为 <code>time<sub>i</sub></code> 分钟。两个城市之间可能会有多条耗费时间不同的道路，但是不会有道路两头连接着同一座城市。</p>\n\n<p>每次经过一个城市时，你需要付通行费。通行费用一个长度为 <code>n</code> 且下标从 <strong>0</strong> 开始的整数数组 <code>passingFees</code> 表示，其中 <code>passingFees[j]</code> 是你经过城市 <code>j</code> 需要支付的费用。</p>\n\n<p>一开始，你在城市 <code>0</code> ，你想要在 <code>maxTime</code> <strong>分钟以内</strong> （包含 <code>maxTime</code> 分钟）到达城市 <code>n - 1</code> 。旅行的 <strong>费用</strong> 为你经过的所有城市 <strong>通行费之和</strong> （<strong>包括</strong> 起点和终点城市的通行费）。</p>\n\n<p>给你 <code>maxTime</code>，<code>edges</code> 和 <code>passingFees</code> ，请你返回完成旅行的 <strong>最小费用</strong> ，如果无法在 <code>maxTime</code> 分钟以内完成旅行，请你返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/leetgraph1-1.png\" style=\"width: 371px; height: 171px;\" /></p>\n\n<pre>\n<b>输入：</b>maxTime = 30, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n<b>输出：</b>11\n<b>解释：</b>最优路径为 0 -> 1 -> 2 -> 5 ，总共需要耗费 30 分钟，需要支付 11 的通行费。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/copy-of-leetgraph1-1.png\" style=\"width: 371px; height: 171px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>maxTime = 29, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n<b>输出：</b>48\n<b>解释：</b>最优路径为 0 -> 3 -> 4 -> 5 ，总共需要耗费 26 分钟，需要支付 48 的通行费。\n你不能选择路径 0 -> 1 -> 2 -> 5 ，因为这条路径耗费的时间太长。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>maxTime = 25, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n<b>输出：</b>-1\n<b>解释：</b>无法在 25 分钟以内从城市 0 到达城市 5 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= maxTime <= 1000</code></li>\n\t<li><code>n == passingFees.length</code></li>\n\t<li><code>2 <= n <= 1000</code></li>\n\t<li><code>n - 1 <= edges.length <= 1000</code></li>\n\t<li><code>0 <= x<sub>i</sub>, y<sub>i</sub> <= n - 1</code></li>\n\t<li><code>1 <= time<sub>i</sub> <= 1000</code></li>\n\t<li><code>1 <= passingFees[j] <= 1000</code> </li>\n\t<li>图中两个节点之间可能有多条路径。</li>\n\t<li>图中不含有自环。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1929.数组串联",
        "hardRate": "EASY",
        "passRate": "86.10%",
        "problemsUrl": "https://leetcode.cn/problems/concatenation-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/concatenation-of-array/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 。请你构建一个长度为 <code>2n</code> 的答案数组 <code>ans</code> ，数组下标<strong> 从 0 开始计数 </strong>，对于所有 <code>0 <= i < n</code> 的 <code>i</code> ，满足下述所有要求：</p>\n\n<ul>\n\t<li><code>ans[i] == nums[i]</code></li>\n\t<li><code>ans[i + n] == nums[i]</code></li>\n</ul>\n\n<p>具体而言，<code>ans</code> 由两个 <code>nums</code> 数组 <strong>串联</strong> 形成。</p>\n\n<p>返回数组<em> </em><code>ans</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1]\n<strong>输出：</strong>[1,2,1,1,2,1]\n<strong>解释：</strong>数组 ans 按下述方式形成：\n- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]\n- ans = [1,2,1,1,2,1]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,2,1]\n<strong>输出：</strong>[1,3,2,1,1,3,2,1]\n<strong>解释：</strong>数组 ans 按下述方式形成：\n- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]\n- ans = [1,3,2,1,1,3,2,1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 <= n <= 1000</code></li>\n\t<li><code>1 <= nums[i] <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1930.长度为 3 的不同回文子序列",
        "hardRate": "MEDIUM",
        "passRate": "51.73%",
        "problemsUrl": "https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，返回 <code>s</code> 中 <strong>长度为 3 </strong>的<strong>不同回文子序列</strong> 的个数。</p>\n\n<p>即便存在多种方法来构建相同的子序列，但相同的子序列只计数一次。</p>\n\n<p><strong>回文</strong> 是正着读和反着读一样的字符串。</p>\n\n<p><strong>子序列</strong> 是由原字符串删除其中部分字符（也可以不删除）且不改变剩余字符之间相对顺序形成的一个新字符串。</p>\n\n<ul>\n\t<li>例如，<code>\"ace\"</code> 是 <code>\"<strong><em>a</em></strong>b<strong><em>c</em></strong>d<strong><em>e</em></strong>\"</code> 的一个子序列。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aabca\"\n<strong>输出：</strong>3\n<strong>解释：</strong>长度为 3 的 3 个回文子序列分别是：\n- \"aba\" (\"<strong><em>a</em></strong>a<strong><em>b</em></strong>c<strong><em>a</em></strong>\" 的子序列)\n- \"aaa\" (\"<strong><em>aa</em></strong>bc<strong><em>a</em></strong>\" 的子序列)\n- \"aca\" (\"<strong><em>a</em></strong>ab<strong><em>ca</em></strong>\" 的子序列)\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"adc\"\n<strong>输出：</strong>0\n<strong>解释：</strong>\"adc\" 不存在长度为 3 的回文子序列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"bbcbaba\"\n<strong>输出：</strong>4\n<strong>解释：</strong>长度为 3 的 4 个回文子序列分别是：\n- \"bbb\" (\"<strong><em>bb</em></strong>c<strong><em>b</em></strong>aba\" 的子序列)\n- \"bcb\" (\"<strong><em>b</em></strong>b<strong><em>cb</em></strong>aba\" 的子序列)\n- \"bab\" (\"<strong><em>b</em></strong>bcb<strong><em>ab</em></strong>a\" 的子序列)\n- \"aba\" (\"bbcb<strong><em>aba</em></strong>\" 的子序列)\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 <= s.length <= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1931.用三种不同颜色为网格涂色",
        "hardRate": "HARD",
        "passRate": "59.44%",
        "problemsUrl": "https://leetcode.cn/problems/painting-a-grid-with-three-different-colors/",
        "solutionsUrl": "https://leetcode.cn/problems/painting-a-grid-with-three-different-colors/solution",
        "problemsDesc": "<p>给你两个整数 <code>m</code> 和 <code>n</code> 。构造一个 <code>m x n</code> 的网格，其中每个单元格最开始是白色。请你用 <strong>红、绿、蓝</strong> 三种颜色为每个单元格涂色。所有单元格都需要被涂色。</p>\n\n<p>涂色方案需要满足：<strong>不存在相邻两个单元格颜色相同的情况</strong> 。返回网格涂色的方法数。因为答案可能非常大， 返回 <strong>对 </strong><code>10<sup>9</sup> + 7</code><strong> 取余</strong> 的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/22/colorthegrid.png\" style=\"width: 200px; height: 50px;\" />\n<pre>\n<strong>输入：</strong>m = 1, n = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>如上图所示，存在三种可能的涂色方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/22/copy-of-colorthegrid.png\" style=\"width: 321px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>m = 1, n = 2\n<strong>输出：</strong>6\n<strong>解释：</strong>如上图所示，存在六种可能的涂色方案。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 5, n = 5\n<strong>输出：</strong>580986\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= m <= 5</code></li>\n\t<li><code>1 <= n <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1932.合并多棵二叉搜索树",
        "hardRate": "HARD",
        "passRate": "33.28%",
        "problemsUrl": "https://leetcode.cn/problems/merge-bsts-to-create-single-bst/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-bsts-to-create-single-bst/solution",
        "problemsDesc": "<p>给你 <code>n</code> 个 <strong>二叉搜索树的根节点</strong> ，存储在数组 <code>trees</code> 中（<strong>下标从 0 开始</strong>），对应 <code>n</code> 棵不同的二叉搜索树。<code>trees</code> 中的每棵二叉搜索树 <strong>最多有 3 个节点</strong> ，且不存在值相同的两个根节点。在一步操作中，将会完成下述步骤：</p>\n\n<ul>\n\t<li>选择两个 <strong>不同的</strong> 下标 <code>i</code> 和 <code>j</code> ，要求满足在&nbsp;<code>trees[i]</code> 中的某个 <strong>叶节点</strong> 的值等于&nbsp;<code>trees[j]</code> 的 <strong>根节点的值</strong> 。</li>\n\t<li>用&nbsp;<code>trees[j]</code> 替换 <code>trees[i]</code> 中的那个叶节点。</li>\n\t<li>从 <code>trees</code> 中移除 <code>trees[j]</code> 。</li>\n</ul>\n\n<p>如果在执行 <code>n - 1</code> 次操作后，能形成一棵有效的二叉搜索树，则返回结果二叉树的 <strong>根节点</strong> ；如果无法构造一棵有效的二叉搜索树<em>，</em>返回<em> </em><code>null</code> 。</p>\n\n<p>二叉搜索树是一种二叉树，且树中每个节点均满足下述属性：</p>\n\n<ul>\n\t<li>任意节点的左子树中的值都 <strong>严格小于</strong>&nbsp;此节点的值。</li>\n\t<li>任意节点的右子树中的值都 <strong>严格大于</strong>&nbsp;此节点的值。</li>\n</ul>\n\n<p>叶节点是不含子节点的节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/08/d1.png\" />\n<pre>\n<strong>输入：</strong>trees = [[2,1],[3,2,5],[5,4]]\n<strong>输出：</strong>[3,2,5,1,null,4]\n<strong>解释：</strong>\n第一步操作中，选出 i=1 和 j=0 ，并将 trees[0] 合并到 trees[1] 中。\n删除 trees[0] ，trees = [[3,2,5,1],[5,4]] 。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/24/diagram.png\" />\n在第二步操作中，选出 i=0 和 j=1 ，将 trees[1] 合并到 trees[0] 中。\n删除 trees[1] ，trees = [[3,2,5,1,null,4]] 。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/24/diagram-2.png\" />\n结果树如上图所示，为一棵有效的二叉搜索树，所以返回该树的根节点。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/08/d2.png\" />\n<pre>\n<strong>输入：</strong>trees = [[5,3,8],[3,2,6]]\n<strong>输出：</strong>[]\n<strong>解释：</strong>\n选出 i=0 和 j=1 ，然后将 trees[1] 合并到 trees[0] 中。\n删除 trees[1] ，trees = [[5,3,8,2,6]] 。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/24/diagram-3.png\" />\n结果树如上图所示。仅能执行一次有效的操作，但结果树不是一棵有效的二叉搜索树，所以返回 null 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/08/d3.png\" />\n<pre>\n<strong>输入：</strong>trees = [[5,4],[3]]\n<strong>输出：</strong>[]\n<strong>解释：</strong>无法执行任何操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == trees.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li>每棵树中节点数目在范围 <code>[1, 3]</code> 内。</li>\n\t<li>输入数据的每个节点可能有子节点但不存在子节点的子节点</li>\n\t<li><code>trees</code> 中不存在两棵树根节点值相同的情况。</li>\n\t<li>输入中的所有树都是 <strong>有效的二叉树搜索树</strong> 。</li>\n\t<li><code>1 &lt;= TreeNode.val &lt;= 5 * 10<sup>4</sup></code>.</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1933.判断字符串是否可分解为值均等的子串",
        "hardRate": "EASY",
        "passRate": "49.42%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-string-is-decomposable-into-value-equal-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-string-is-decomposable-into-value-equal-substrings/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1934.确认率",
        "hardRate": "MEDIUM",
        "passRate": "66.86%",
        "problemsUrl": "https://leetcode.cn/problems/confirmation-rate/",
        "solutionsUrl": "https://leetcode.cn/problems/confirmation-rate/solution",
        "problemsDesc": "<p>表: <code>Signups</code></p>\n\n<pre>\n+----------------+----------+\n| Column Name    | Type     |\n+----------------+----------+\n| user_id        | int      |\n| time_stamp     | datetime |\n+----------------+----------+\nUser_id是该表的主键。\n每一行都包含ID为user_id的用户的注册时间信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>表: <code>Confirmations</code></p>\n\n<pre>\n+----------------+----------+\n| Column Name    | Type     |\n+----------------+----------+\n| user_id        | int      |\n| time_stamp     | datetime |\n| action         | ENUM     |\n+----------------+----------+\n(user_id, time_stamp)是该表的主键。\nuser_id是一个引用到注册表的外键。\naction是类型为('confirmed'， 'timeout')的ENUM\n该表的每一行都表示ID为user_id的用户在time_stamp请求了一条确认消息，该确认消息要么被确认('confirmed')，要么被过期('timeout')。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>用户的 <strong>确认率</strong>&nbsp;是 <code>'confirmed'</code>&nbsp;消息的数量除以请求的确认消息的总数。没有请求任何确认消息的用户的确认率为&nbsp;<code>0</code> 。确认率四舍五入到 <strong>小数点后两位</strong> 。</p>\n\n<p>编写一个SQL查询来查找每个用户的 确认率 。<br />\n<br />\n以 任意顺序&nbsp;返回结果表。<br />\n<br />\n查询结果格式如下所示。<br />\n<br />\n<strong>示例1:</strong></p>\n\n<pre>\n<b>输入：</b>\nSignups 表:\n+---------+---------------------+\n| user_id | time_stamp          |\n+---------+---------------------+\n| 3       | 2020-03-21 10:16:13 |\n| 7       | 2020-01-04 13:57:59 |\n| 2       | 2020-07-29 23:09:44 |\n| 6       | 2020-12-09 10:39:37 |\n+---------+---------------------+\nConfirmations 表:\n+---------+---------------------+-----------+\n| user_id | time_stamp          | action    |\n+---------+---------------------+-----------+\n| 3       | 2021-01-06 03:30:46 | timeout   |\n| 3       | 2021-07-14 14:00:00 | timeout   |\n| 7       | 2021-06-12 11:57:29 | confirmed |\n| 7       | 2021-06-13 12:58:28 | confirmed |\n| 7       | 2021-06-14 13:59:27 | confirmed |\n| 2       | 2021-01-22 00:00:00 | confirmed |\n| 2       | 2021-02-28 23:59:59 | timeout   |\n+---------+---------------------+-----------+\n<strong>输出:</strong> \n+---------+-------------------+\n| user_id | confirmation_rate |\n+---------+-------------------+\n| 6       | 0.00              |\n| 3       | 0.00              |\n| 7       | 1.00              |\n| 2       | 0.50              |\n+---------+-------------------+\n<strong>解释:\n</strong>用户 6 没有请求任何确认消息。确认率为 0。\n用户 3 进行了 2 次请求，都超时了。确认率为 0。\n用户 7 提出了 3 个请求，所有请求都得到了确认。确认率为 1。\n用户 2 做了 2 个请求，其中一个被确认，另一个超时。确认率为 1 / 2 = 0.5。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1935.可以输入的最大单词数",
        "hardRate": "EASY",
        "passRate": "70.83%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-words-you-can-type/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-words-you-can-type/solution",
        "problemsDesc": "<p>键盘出现了一些故障，有些字母键无法正常工作。而键盘上所有其他键都能够正常工作。</p>\n\n<p>给你一个由若干单词组成的字符串 <code>text</code> ，单词间由单个空格组成（不含前导和尾随空格）；另有一个字符串 <code>brokenLetters</code> ，由所有已损坏的不同字母键组成，返回你可以使用此键盘完全输入的 <code>text</code> 中单词的数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>text = \"hello world\", brokenLetters = \"ad\"\n<strong>输出：</strong>1\n<strong>解释：</strong>无法输入 \"world\" ，因为字母键 'd' 已损坏。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>text = \"leet code\", brokenLetters = \"lt\"\n<strong>输出：</strong>1\n<strong>解释：</strong>无法输入 \"leet\" ，因为字母键 'l' 和 't' 已损坏。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>text = \"leet code\", brokenLetters = \"e\"\n<strong>输出：</strong>0\n<strong>解释：</strong>无法输入任何单词，因为字母键 'e' 已损坏。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= brokenLetters.length &lt;= 26</code></li>\n\t<li><code>text</code> 由若干用单个空格分隔的单词组成，且不含任何前导和尾随空格</li>\n\t<li>每个单词仅由小写英文字母组成</li>\n\t<li><code>brokenLetters</code> 由 <strong>互不相同</strong> 的小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1936.新增的最少台阶数",
        "hardRate": "MEDIUM",
        "passRate": "46.27%",
        "problemsUrl": "https://leetcode.cn/problems/add-minimum-number-of-rungs/",
        "solutionsUrl": "https://leetcode.cn/problems/add-minimum-number-of-rungs/solution",
        "problemsDesc": "<p>给你一个 <strong>严格递增</strong> 的整数数组 <code>rungs</code> ，用于表示梯子上每一台阶的 <strong>高度</strong> 。当前你正站在高度为 <code>0</code> 的地板上，并打算爬到最后一个台阶。</p>\n\n<p>另给你一个整数 <code>dist</code> 。每次移动中，你可以到达下一个距离你当前位置（地板或台阶）<strong>不超过</strong> <code>dist</code> 高度的台阶。当然，你也可以在任何正 <strong>整数</strong> 高度处插入尚不存在的新台阶。</p>\n\n<p>返回爬到最后一阶时必须添加到梯子上的 <strong>最少</strong> 台阶数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rungs = [1,3,5,10], dist = 2\n<strong>输出：</strong>2\n<strong>解释：\n</strong>现在无法到达最后一阶。\n在高度为 7 和 8 的位置增设新的台阶，以爬上梯子。 \n梯子在高度为 [1,3,5,<strong><em>7</em></strong>,<strong><em>8</em></strong>,10] 的位置上有台阶。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rungs = [3,6,8,10], dist = 3\n<strong>输出：</strong>0\n<strong>解释：</strong>\n这个梯子无需增设新台阶也可以爬上去。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>rungs = [3,4,6,7], dist = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>\n现在无法从地板到达梯子的第一阶。 \n在高度为 1 的位置增设新的台阶，以爬上梯子。 \n梯子在高度为 [<strong><em>1</em></strong>,3,4,6,7] 的位置上有台阶。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>rungs = [5], dist = 10\n<strong>输出：</strong>0\n<strong>解释：</strong>这个梯子无需增设新台阶也可以爬上去。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= rungs.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= rungs[i] <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= dist <= 10<sup>9</sup></code></li>\n\t<li><code>rungs</code> <strong>严格递增</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1937.扣分后的最大得分",
        "hardRate": "MEDIUM",
        "passRate": "28.96%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-points-with-cost/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-points-with-cost/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的整数矩阵 <code>points</code> （下标从 <strong>0</strong> 开始）。一开始你的得分为 <code>0</code> ，你想最大化从矩阵中得到的分数。</p>\n\n<p>你的得分方式为：<strong>每一行</strong> 中选取一个格子，选中坐标为 <code>(r, c)</code> 的格子会给你的总得分 <strong>增加</strong> <code>points[r][c]</code> 。</p>\n\n<p>然而，相邻行之间被选中的格子如果隔得太远，你会失去一些得分。对于相邻行 <code>r</code> 和 <code>r + 1</code> （其中 <code>0 <= r < m - 1</code>），选中坐标为 <code>(r, c<sub>1</sub>)</code> 和 <code>(r + 1, c<sub>2</sub>)</code> 的格子，你的总得分 <b>减少</b> <code>abs(c<sub>1</sub> - c<sub>2</sub>)</code> 。</p>\n\n<p>请你返回你能得到的 <strong>最大</strong> 得分。</p>\n\n<p><code>abs(x)</code> 定义为：</p>\n\n<ul>\n\t<li>如果 <code>x >= 0</code> ，那么值为 <code>x</code> 。</li>\n\t<li>如果 <code>x < 0</code> ，那么值为 <code>-x</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-40-26-diagram-drawio-diagrams-net.png\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<b>输入：</b>points = [[1,2,3],[1,5,1],[3,1,1]]\n<b>输出：</b>9\n<strong>解释：</strong>\n蓝色格子是最优方案选中的格子，坐标分别为 (0, 2)，(1, 1) 和 (2, 0) 。\n你的总得分增加 3 + 5 + 3 = 11 。\n但是你的总得分需要扣除 abs(2 - 1) + abs(1 - 0) = 2 。\n你的最终得分为 11 - 2 = 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-42-14-diagram-drawio-diagrams-net.png\" style=\"width: 200px; height: 299px;\" />\n<pre>\n<b>输入：</b>points = [[1,5],[2,3],[4,2]]\n<b>输出：</b>11\n<strong>解释：</strong>\n蓝色格子是最优方案选中的格子，坐标分别为 (0, 1)，(1, 1) 和 (2, 0) 。\n你的总得分增加 5 + 3 + 4 = 12 。\n但是你的总得分需要扣除 abs(1 - 1) + abs(1 - 0) = 1 。\n你的最终得分为 12 - 1 = 11 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == points.length</code></li>\n\t<li><code>n == points[r].length</code></li>\n\t<li><code>1 <= m, n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= m * n <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= points[r][c] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1938.查询最大基因差",
        "hardRate": "HARD",
        "passRate": "40.26%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-genetic-difference-query/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-genetic-difference-query/solution",
        "problemsDesc": "<p>给你一棵 <code>n</code> 个节点的有根树，节点编号从 <code>0</code> 到 <code>n - 1</code> 。每个节点的编号表示这个节点的 <strong>独一无二的基因值</strong> （也就是说节点 <code>x</code> 的基因值为 <code>x</code>）。两个基因值的 <strong>基因差</strong> 是两者的 <strong>异或和</strong> 。给你整数数组 <code>parents</code> ，其中 <code>parents[i]</code> 是节点 <code>i</code> 的父节点。如果节点 <code>x</code> 是树的 <strong>根</strong> ，那么 <code>parents[x] == -1</code> 。</p>\n\n<p>给你查询数组 <code>queries</code> ，其中 <code>queries[i] = [node<sub>i</sub>, val<sub>i</sub>]</code> 。对于查询 <code>i</code> ，请你找到 <code>val<sub>i</sub></code> 和 <code>p<sub>i</sub></code> 的 <strong>最大基因差</strong> ，其中 <code>p<sub>i</sub></code> 是节点 <code>node<sub>i</sub></code> 到根之间的任意节点（包含 <code>node<sub>i</sub></code> 和根节点）。更正式的，你想要最大化 <code>val<sub>i</sub> XOR p<sub>i</sub></code><sub> </sub>。</p>\n\n<p>请你返回数组<em> </em><code>ans</code> ，其中 <code>ans[i]</code> 是第 <code>i</code> 个查询的答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/29/c1.png\" style=\"width: 118px; height: 163px;\">\n<pre><b>输入：</b>parents = [-1,0,1,1], queries = [[0,2],[3,2],[2,5]]\n<b>输出：</b>[2,3,7]\n<strong>解释：</strong>查询数组处理如下：\n- [0,2]：最大基因差的对应节点为 0 ，基因差为 2 XOR 0 = 2 。\n- [3,2]：最大基因差的对应节点为 1 ，基因差为 2 XOR 1 = 3 。\n- [2,5]：最大基因差的对应节点为 2 ，基因差为 5 XOR 2 = 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/29/c2.png\" style=\"width: 256px; height: 221px;\">\n<pre><b>输入：</b>parents = [3,7,-1,2,0,7,0,2], queries = [[4,6],[1,15],[0,5]]\n<b>输出：</b>[6,14,7]\n<strong>解释：</strong>查询数组处理如下：\n- [4,6]：最大基因差的对应节点为 0 ，基因差为 6 XOR 0 = 6 。\n- [1,15]：最大基因差的对应节点为 1 ，基因差为 15 XOR 1 = 14 。\n- [0,5]：最大基因差的对应节点为 2 ，基因差为 5 XOR 2 = 7 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= parents.length &lt;= 10<sup>5</sup></code></li>\n\t<li>对于每个 <strong>不是</strong> 根节点的 <code>i</code> ，有 <code>0 &lt;= parents[i] &lt;= parents.length - 1</code> 。</li>\n\t<li><code>parents[root] == -1</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= node<sub>i</sub> &lt;= parents.length - 1</code></li>\n\t<li><code>0 &lt;= val<sub>i</sub> &lt;= 2 * 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1939.主动请求确认消息的用户",
        "hardRate": "EASY",
        "passRate": "59.74%",
        "problemsUrl": "https://leetcode.cn/problems/users-that-actively-request-confirmation-messages/",
        "solutionsUrl": "https://leetcode.cn/problems/users-that-actively-request-confirmation-messages/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1940.排序数组之间的最长公共子序列",
        "hardRate": "MEDIUM",
        "passRate": "73.97%",
        "problemsUrl": "https://leetcode.cn/problems/longest-common-subsequence-between-sorted-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-common-subsequence-between-sorted-arrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1941.检查是否所有字符出现次数相同",
        "hardRate": "EASY",
        "passRate": "73.53%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-all-characters-have-equal-number-of-occurrences/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-all-characters-have-equal-number-of-occurrences/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，如果 <code>s</code> 是一个 <strong>好</strong> 字符串，请你返回 <code>true</code> ，否则请返回 <code>false</code> 。</p>\n\n<p>如果 <code>s</code> 中出现过的 <strong>所有</strong> 字符的出现次数 <strong>相同</strong> ，那么我们称字符串 <code>s</code> 是 <strong>好</strong> 字符串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"abacbc\"\n<b>输出：</b>true\n<b>解释：</b>s 中出现过的字符为 'a'，'b' 和 'c' 。s 中所有字符均出现 2 次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"aaabb\"\n<b>输出：</b>false\n<b>解释：</b>s 中出现过的字符为 'a' 和 'b' 。\n'a' 出现了 3 次，'b' 出现了 2 次，两者出现次数不同。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1942.最小未被占据椅子的编号",
        "hardRate": "MEDIUM",
        "passRate": "42.06%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-the-smallest-unoccupied-chair/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-the-smallest-unoccupied-chair/solution",
        "problemsDesc": "<p>有 <code>n</code> 个朋友在举办一个派对，这些朋友从 <code>0</code> 到 <code>n - 1</code> 编号。派对里有 <strong>无数</strong> 张椅子，编号为 <code>0</code> 到 <code>infinity</code> 。当一个朋友到达派对时，他会占据 <strong>编号最小</strong> 且未被占据的椅子。</p>\n\n<ul>\n\t<li>比方说，当一个朋友到达时，如果椅子 <code>0</code> ，<code>1</code> 和 <code>5</code> 被占据了，那么他会占据 <code>2</code> 号椅子。</li>\n</ul>\n\n<p>当一个朋友离开派对时，他的椅子会立刻变成未占据状态。如果同一时刻有另一个朋友到达，可以立即占据这张椅子。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>times</code> ，其中 <code>times[i] = [arrival<sub>i</sub>, leaving<sub>i</sub>]</code> 表示第 <code>i</code> 个朋友到达和离开的时刻，同时给你一个整数 <code>targetFriend</code> 。所有到达时间 <strong>互不相同</strong> 。</p>\n\n<p>请你返回编号为 <code>targetFriend</code> 的朋友占据的 <strong>椅子编号</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>times = [[1,4],[2,3],[4,6]], targetFriend = 1\n<b>输出：</b>1\n<b>解释：</b>\n- 朋友 0 时刻 1 到达，占据椅子 0 。\n- 朋友 1 时刻 2 到达，占据椅子 1 。\n- 朋友 1 时刻 3 离开，椅子 1 变成未占据。\n- 朋友 0 时刻 4 离开，椅子 0 变成未占据。\n- 朋友 2 时刻 4 到达，占据椅子 0 。\n朋友 1 占据椅子 1 ，所以返回 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>times = [[3,10],[1,5],[2,6]], targetFriend = 0\n<b>输出：</b>2\n<b>解释：</b>\n- 朋友 1 时刻 1 到达，占据椅子 0 。\n- 朋友 2 时刻 2 到达，占据椅子 1 。\n- 朋友 0 时刻 3 到达，占据椅子 2 。\n- 朋友 1 时刻 5 离开，椅子 0 变成未占据。\n- 朋友 2 时刻 6 离开，椅子 1 变成未占据。\n- 朋友 0 时刻 10 离开，椅子 2 变成未占据。\n朋友 0 占据椅子 2 ，所以返回 2 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == times.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>times[i].length == 2</code></li>\n\t<li><code>1 &lt;= arrival<sub>i</sub> &lt; leaving<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= targetFriend &lt;= n - 1</code></li>\n\t<li>每个 <code>arrival<sub>i</sub></code> 时刻 <strong>互不相同</strong> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1943.描述绘画结果",
        "hardRate": "MEDIUM",
        "passRate": "43.95%",
        "problemsUrl": "https://leetcode.cn/problems/describe-the-painting/",
        "solutionsUrl": "https://leetcode.cn/problems/describe-the-painting/solution",
        "problemsDesc": "<p>给你一个细长的画，用数轴表示。这幅画由若干有重叠的线段表示，每个线段有 <strong>独一无二</strong>&nbsp;的颜色。给你二维整数数组&nbsp;<code>segments</code>&nbsp;，其中&nbsp;<code>segments[i] = [start<sub>i</sub>, end<sub>i</sub>, color<sub>i</sub>]</code>&nbsp;表示线段为&nbsp;<strong>半开区间</strong>&nbsp;<code>[start<sub>i</sub>, end<sub>i</sub>)</code> 且颜色为&nbsp;<code>color<sub>i</sub></code>&nbsp;。</p>\n\n<p>线段间重叠部分的颜色会被 <strong>混合</strong>&nbsp;。如果有两种或者更多颜色混合时，它们会形成一种新的颜色，用一个 <strong>集合</strong>&nbsp;表示这个混合颜色。</p>\n\n<ul>\n\t<li>比方说，如果颜色&nbsp;<code>2</code>&nbsp;，<code>4</code>&nbsp;和&nbsp;<code>6</code>&nbsp;被混合，那么结果颜色为&nbsp;<code>{2,4,6}</code>&nbsp;。</li>\n</ul>\n\n<p>为了简化题目，你不需要输出整个集合，只需要用集合中所有元素的 <strong>和</strong>&nbsp;来表示颜色集合。</p>\n\n<p>你想要用 <strong>最少数目</strong>&nbsp;不重叠 <strong>半开区间</strong>&nbsp;来 <b>表示</b>&nbsp;这幅混合颜色的画。这些线段可以用二维数组&nbsp;<code>painting</code>&nbsp;表示，其中 <code>painting[j] = [left<sub>j</sub>, right<sub>j</sub>, mix<sub>j</sub>]</code>&nbsp;表示一个&nbsp;<strong>半开区间</strong><code>[left<sub>j</sub>, right<sub>j</sub>)</code>&nbsp;的颜色 <strong>和</strong>&nbsp;为&nbsp;<code>mix<sub>j</sub></code>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，这幅画由&nbsp;<code>segments = [[1,4,5],[1,7,7]]</code>&nbsp;组成，那么它可以表示为&nbsp;<code>painting = [[1,4,12],[4,7,7]]</code>&nbsp;，因为：\n\n\t<ul>\n\t\t<li><code>[1,4)</code>&nbsp;由颜色&nbsp;<code>{5,7}</code>&nbsp;组成（和为&nbsp;<code>12</code>），分别来自第一个线段和第二个线段。</li>\n\t\t<li><code>[4,7)</code>&nbsp;由颜色 <code>{7}</code>&nbsp;组成，来自第二个线段。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回二维数组&nbsp;<code>painting</code>&nbsp;，它表示最终绘画的结果（<strong>没有</strong>&nbsp;被涂色的部分不出现在结果中）。你可以按 <strong>任意顺序</strong> 返回最终数组的结果。</p>\n\n<p><strong>半开区间&nbsp;</strong><code>[a, b)</code>&nbsp;是数轴上点&nbsp;<code>a</code> 和点&nbsp;<code>b</code>&nbsp;之间的部分，<strong>包含 </strong>点&nbsp;<code>a</code>&nbsp;且 <strong>不包含</strong>&nbsp;点&nbsp;<code>b</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/18/1.png\" style=\"width: 529px; height: 241px;\" />\n<pre>\n<b>输入：</b>segments = [[1,4,5],[4,7,7],[1,7,9]]\n<b>输出：</b>[[1,4,14],[4,7,16]]\n<strong>解释：</strong>绘画结果可以表示为：\n- [1,4) 颜色为 {5,9} （和为 14），分别来自第一和第二个线段。\n- [4,7) 颜色为 {7,9} （和为 16），分别来自第二和第三个线段。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/18/2.png\" style=\"width: 532px; height: 219px;\" />\n<pre>\n<b>输入：</b>segments = [[1,7,9],[6,8,15],[8,10,7]]\n<b>输出：</b>[[1,6,9],[6,7,24],[7,8,15],[8,10,7]]\n<b>解释：</b>绘画结果可以以表示为：\n- [1,6) 颜色为 9 ，来自第一个线段。\n- [6,7) 颜色为 {9,15} （和为 24），来自第一和第二个线段。\n- [7,8) 颜色为 15 ，来自第二个线段。\n- [8,10) 颜色为 7 ，来自第三个线段。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/04/c1.png\" style=\"width: 529px; height: 289px;\" />\n<pre>\n<b>输入：</b>segments = [[1,4,5],[1,4,7],[4,7,1],[4,7,11]]\n<b>输出：</b>[[1,4,12],[4,7,12]]\n<strong>解释：</strong>绘画结果可以表示为：\n- [1,4) 颜色为 {5,7} （和为 12），分别来自第一和第二个线段。\n- [4,7) 颜色为 {1,11} （和为 12），分别来自第三和第四个线段。\n注意，只返回一个单独的线段 [1,7) 是不正确的，因为混合颜色的集合不相同。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= segments.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>segments[i].length == 3</code></li>\n\t<li><code>1 &lt;= start<sub>i</sub> &lt; end<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= color<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li>每种颜色&nbsp;<code>color<sub>i</sub></code>&nbsp;互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1944.队列中可以看到的人数",
        "hardRate": "HARD",
        "passRate": "63.36%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-visible-people-in-a-queue/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-visible-people-in-a-queue/solution",
        "problemsDesc": "<p>有&nbsp;<code>n</code>&nbsp;个人排成一个队列，<strong>从左到右</strong>&nbsp;编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。给你以一个整数数组&nbsp;<code>heights</code>&nbsp;，每个整数 <strong>互不相同</strong>，<code>heights[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个人的高度。</p>\n\n<p>一个人能 <strong>看到</strong> 他右边另一个人的条件是这两人之间的所有人都比他们两人 <strong>矮</strong>&nbsp;。更正式的，第&nbsp;<code>i</code>&nbsp;个人能看到第&nbsp;<code>j</code>&nbsp;个人的条件是&nbsp;<code>i &lt; j</code>&nbsp;且&nbsp;<code>min(heights[i], heights[j]) &gt; max(heights[i+1], heights[i+2], ..., heights[j-1])</code>&nbsp;。</p>\n\n<p>请你返回一个长度为 <code>n</code>&nbsp;的数组<em>&nbsp;</em><code>answer</code><em>&nbsp;</em>，其中<em>&nbsp;</em><code>answer[i]</code><em>&nbsp;</em>是第&nbsp;<code>i</code>&nbsp;个人在他右侧队列中能&nbsp;<strong>看到</strong>&nbsp;的&nbsp;<strong>人数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/29/queue-plane.jpg\" style=\"width: 600px; height: 247px;\" /></p>\n\n<pre>\n<b>输入：</b>heights = [10,6,8,5,11,9]\n<b>输出：</b>[3,1,2,1,1,0]\n<strong>解释：</strong>\n第 0 个人能看到编号为 1 ，2 和 4 的人。\n第 1 个人能看到编号为 2 的人。\n第 2 个人能看到编号为 3 和 4 的人。\n第 3 个人能看到编号为 4 的人。\n第 4 个人能看到编号为 5 的人。\n第 5 个人谁也看不到因为他右边没人。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>heights = [5,1,2,3,10]\n<b>输出：</b>[4,1,1,1,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == heights.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= heights[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>heights</code>&nbsp;中所有数 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1945.字符串转化后的各位数字之和",
        "hardRate": "EASY",
        "passRate": "70.39%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-digits-of-string-after-convert/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-digits-of-string-after-convert/solution",
        "problemsDesc": "<p>给你一个由小写字母组成的字符串 <code>s</code> ，以及一个整数 <code>k</code> 。</p>\n\n<p>首先，用字母在字母表中的位置替换该字母，将 <code>s</code> <strong>转化</strong> 为一个整数（也就是，<code>'a'</code> 用 <code>1</code> 替换，<code>'b'</code> 用 <code>2</code> 替换，... <code>'z'</code> 用 <code>26</code> 替换）。接着，将整数 <strong>转换</strong> 为其 <strong>各位数字之和</strong> 。共重复 <strong>转换</strong> 操作 <strong><code>k</code> 次</strong> 。</p>\n\n<p>例如，如果 <code>s = \"zbax\"</code> 且 <code>k = 2</code> ，那么执行下述步骤后得到的结果是整数 <code>8</code> ：</p>\n\n<ul>\n\t<li><strong>转化：</strong><code>\"zbax\" ➝ \"(26)(2)(1)(24)\" ➝ \"262124\" ➝ 262124</code></li>\n\t<li><strong>转换 #1</strong>：<code>262124&nbsp;➝ 2 + 6 + 2 + 1 + 2 + 4&nbsp;➝ 17</code></li>\n\t<li><strong>转换 #2</strong>：<code>17 ➝ 1 + 7 ➝ 8</code></li>\n</ul>\n\n<p>返回执行上述操作后得到的结果整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"iiii\", k = 1\n<strong>输出：</strong>36\n<strong>解释：</strong>操作如下：\n- 转化：\"iiii\" ➝ \"(9)(9)(9)(9)\" ➝ \"9999\" ➝ 9999\n- 转换 #1：9999 ➝ 9 + 9 + 9 + 9 ➝ 36\n因此，结果整数为 36 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"leetcode\", k = 2\n<strong>输出：</strong>6\n<strong>解释：</strong>操作如下：\n- 转化：\"leetcode\" ➝ \"(12)(5)(5)(20)(3)(15)(4)(5)\" ➝ \"12552031545\" ➝ 12552031545\n- 转换 #1：12552031545 ➝ 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 ➝ 33\n- 转换 #2：33 ➝ 3 + 3 ➝ 6\n因此，结果整数为 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= k &lt;= 10</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1946.子字符串突变后可能得到的最大整数",
        "hardRate": "MEDIUM",
        "passRate": "32.27%",
        "problemsUrl": "https://leetcode.cn/problems/largest-number-after-mutating-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-number-after-mutating-substring/solution",
        "problemsDesc": "<p>给你一个字符串 <code>num</code> ，该字符串表示一个大整数。另给你一个长度为 <code>10</code> 且 <strong>下标从 0&nbsp; 开始</strong> 的整数数组 <code>change</code> ，该数组将 <code>0-9</code> 中的每个数字映射到另一个数字。更规范的说法是，数字 <code>d</code> 映射为数字 <code>change[d]</code> 。</p>\n\n<p>你可以选择 <strong>突变</strong>&nbsp; <code>num</code> 的任一子字符串。<strong>突变</strong> 子字符串意味着将每位数字 <code>num[i]</code> 替换为该数字在 <code>change</code> 中的映射（也就是说，将 <code>num[i]</code> 替换为 <code>change[num[i]]</code>）。</p>\n\n<p>请你找出在对 <code>num</code> 的任一子字符串执行突变操作（也可以不执行）后，可能得到的 <strong>最大整数</strong> ，并用字符串表示返回。</p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = \"<strong><em>1</em></strong>32\", change = [9,8,5,0,3,6,4,2,6,8]\n<strong>输出：</strong>\"<strong><em>8</em></strong>32\"\n<strong>解释：</strong>替换子字符串 \"1\"：\n- 1 映射为 change[1] = 8 。\n因此 \"<strong><em>1</em></strong>32\" 变为 \"<strong><em>8</em></strong>32\" 。\n\"832\" 是可以构造的最大整数，所以返回它的字符串表示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = \"<strong><em>021</em></strong>\", change = [9,4,3,5,7,2,1,9,0,6]\n<strong>输出：</strong>\"<strong><em>934</em></strong>\"\n<strong>解释：</strong>替换子字符串 \"021\"：\n- 0 映射为 change[0] = 9 。\n- 2 映射为 change[2] = 3 。\n- 1 映射为 change[1] = 4 。\n因此，\"<strong><em>021</em></strong>\" 变为 \"<strong><em>934</em></strong>\" 。\n\"934\" 是可以构造的最大整数，所以返回它的字符串表示。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = \"5\", change = [1,4,7,5,3,2,5,6,9,4]\n<strong>输出：</strong>\"5\"\n<strong>解释：</strong>\"5\" 已经是可以构造的最大整数，所以返回它的字符串表示。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>num</code> 仅由数字 <code>0-9</code> 组成</li>\n\t<li><code>change.length == 10</code></li>\n\t<li><code>0 &lt;= change[d] &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1947.最大兼容性评分和",
        "hardRate": "MEDIUM",
        "passRate": "57.94%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-compatibility-score-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-compatibility-score-sum/solution",
        "problemsDesc": "<p>有一份由 <code>n</code> 个问题组成的调查问卷，每个问题的答案要么是 <code>0</code>（no，否），要么是 <code>1</code>（yes，是）。</p>\n\n<p>这份调查问卷被分发给 <code>m</code> 名学生和 <code>m</code> 名导师，学生和导师的编号都是从 <code>0</code> 到 <code>m - 1</code> 。学生的答案用一个二维整数数组 <code>students</code> 表示，其中 <code>students[i]</code> 是一个整数数组，包含第 <code>i</code> 名学生对调查问卷给出的答案（<strong>下标从 0 开始</strong>）。导师的答案用一个二维整数数组 <code>mentors</code> 表示，其中 <code>mentors[j]</code> 是一个整数数组，包含第 <code>j</code> 名导师对调查问卷给出的答案（<strong>下标从 0 开始</strong>）。</p>\n\n<p>每个学生都会被分配给 <strong>一名</strong> 导师，而每位导师也会分配到 <strong>一名</strong> 学生。配对的学生与导师之间的兼容性评分等于学生和导师答案相同的次数。</p>\n\n<ul>\n\t<li>例如，学生答案为<code>[1, <strong><em>0</em></strong>, <strong><em>1</em></strong>]</code> 而导师答案为 <code>[0, <strong><em>0</em></strong>, <strong><em>1</em></strong>]</code> ，那么他们的兼容性评分为 2 ，因为只有第二个和第三个答案相同。</li>\n</ul>\n\n<p>请你找出最优的学生与导师的配对方案，以 <strong>最大程度上</strong> 提高 <strong>兼容性评分和</strong> 。</p>\n\n<p>给你 <code>students</code> 和 <code>mentors</code> ，返回可以得到的<em> </em><strong>最大兼容性评分和</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>students = [[1,1,0],[1,0,1],[0,0,1]], mentors = [[1,0,0],[0,0,1],[1,1,0]]\n<strong>输出：</strong>8\n<strong>解释：</strong>按下述方式分配学生和导师：\n- 学生 0 分配给导师 2 ，兼容性评分为 3 。\n- 学生 1 分配给导师 0 ，兼容性评分为 2 。\n- 学生 2 分配给导师 1 ，兼容性评分为 3 。\n最大兼容性评分和为 3 + 2 + 3 = 8 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>students = [[0,0],[0,0],[0,0]], mentors = [[1,1],[1,1],[1,1]]\n<strong>输出：</strong>0\n<strong>解释：</strong>任意学生与导师配对的兼容性评分都是 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == students.length == mentors.length</code></li>\n\t<li><code>n == students[i].length == mentors[j].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 8</code></li>\n\t<li><code>students[i][k]</code> 为 <code>0</code> 或 <code>1</code></li>\n\t<li><code>mentors[j][k]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1948.删除系统中的重复文件夹",
        "hardRate": "HARD",
        "passRate": "54.51%",
        "problemsUrl": "https://leetcode.cn/problems/delete-duplicate-folders-in-system/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-duplicate-folders-in-system/solution",
        "problemsDesc": "<p>由于一个漏洞，文件系统中存在许多重复文件夹。给你一个二维数组 <code>paths</code>，其中 <code>paths[i]</code> 是一个表示文件系统中第 <code>i</code> 个文件夹的绝对路径的数组。</p>\n\n<ul>\n\t<li>例如，<code>[\"one\", \"two\", \"three\"]</code> 表示路径 <code>\"/one/two/three\"</code> 。</li>\n</ul>\n\n<p>如果两个文件夹（不需要在同一层级）包含 <strong>非空且</strong><b>相同的&nbsp;</b>子文件夹&nbsp;<strong>集合</strong> 并具有相同的子文件夹结构，则认为这两个文件夹是相同文件夹。相同文件夹的根层级 <strong>不</strong> 需要相同。如果存在两个（或两个以上）<strong>相同</strong> 文件夹，则需要将这些文件夹和所有它们的子文件夹 <strong>标记</strong> 为待删除。</p>\n\n<ul>\n\t<li>例如，下面文件结构中的文件夹 <code>\"/a\"</code> 和 <code>\"/b\"</code> 相同。它们（以及它们的子文件夹）应该被 <strong>全部</strong> 标记为待删除：\n\n\t<ul>\n\t\t<li><code>/a</code></li>\n\t\t<li><code>/a/x</code></li>\n\t\t<li><code>/a/x/y</code></li>\n\t\t<li><code>/a/z</code></li>\n\t\t<li><code>/b</code></li>\n\t\t<li><code>/b/x</code></li>\n\t\t<li><code>/b/x/y</code></li>\n\t\t<li><code>/b/z</code></li>\n\t</ul>\n\t</li>\n\t<li>然而，如果文件结构中还包含路径 <code>\"/b/w\"</code> ，那么文件夹 <code>\"/a\"</code> 和 <code>\"/b\"</code> 就不相同。注意，即便添加了新的文件夹 <code>\"/b/w\"</code> ，仍然认为 <code>\"/a/x\"</code> 和 <code>\"/b/x\"</code> 相同。</li>\n</ul>\n\n<p>一旦所有的相同文件夹和它们的子文件夹都被标记为待删除，文件系统将会 <strong>删除</strong> 所有上述文件夹。文件系统只会执行一次删除操作。执行完这一次删除操作后，不会删除新出现的相同文件夹。</p>\n\n<p>返回二维数组<em> </em><code>ans</code> ，该数组包含删除所有标记文件夹之后剩余文件夹的路径。路径可以按 <strong>任意顺序</strong> 返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder1.jpg\" style=\"width: 200px; height: 218px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\"],[\"c\"],[\"d\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"a\"]]\n<strong>输出：</strong>[[\"d\"],[\"d\",\"a\"]]\n<strong>解释：</strong>文件结构如上所示。\n文件夹 \"/a\" 和 \"/c\"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 \"b\" 的空文件夹。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder2.jpg\" style=\"width: 200px; height: 355px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\"],[\"c\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"a\",\"b\",\"x\"],[\"a\",\"b\",\"x\",\"y\"],[\"w\"],[\"w\",\"y\"]]\n<strong>输出：</strong>[[\"c\"],[\"c\",\"b\"],[\"a\"],[\"a\",\"b\"]]\n<strong>解释：</strong>文件结构如上所示。\n文件夹 \"/a/b/x\" 和 \"/w\"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 \"y\" 的空文件夹。\n注意，文件夹 \"/a\" 和 \"/c\" 在删除后变为相同文件夹，但这两个文件夹不会被删除，因为删除只会进行一次，且它们没有在删除前被标记。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder3.jpg\" style=\"width: 200px; height: 201px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\",\"b\"],[\"c\",\"d\"],[\"c\"],[\"a\"]]\n<strong>输出：</strong>[[\"c\"],[\"c\",\"d\"],[\"a\"],[\"a\",\"b\"]]\n<strong>解释：</strong>文件系统中所有文件夹互不相同。\n注意，返回的数组可以按不同顺序返回文件夹路径，因为题目对顺序没有要求。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder4_.jpg\" style=\"width: 300px; height: 290px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\"],[\"a\",\"x\"],[\"a\",\"x\",\"y\"],[\"a\",\"z\"],[\"b\"],[\"b\",\"x\"],[\"b\",\"x\",\"y\"],[\"b\",\"z\"]]\n<strong>输出：</strong>[]\n<strong>解释：</strong>文件结构如上所示。\n文件夹 \"/a/x\" 和 \"/b/x\"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 \"y\" 的空文件夹。\n文件夹 \"/a\" 和 \"/b\"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含一个名为 \"z\" 的空文件夹以及上面提到的文件夹 \"x\" 。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder5_.jpg\" style=\"width: 300px; height: 282px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\"],[\"a\",\"x\"],[\"a\",\"x\",\"y\"],[\"a\",\"z\"],[\"b\"],[\"b\",\"x\"],[\"b\",\"x\",\"y\"],[\"b\",\"z\"],[\"b\",\"w\"]]\n<strong>输出：</strong>[[\"b\"],[\"b\",\"w\"],[\"b\",\"z\"],[\"a\"],[\"a\",\"z\"]]\n<strong>解释：</strong>本例与上例的结构基本相同，除了新增 \"/b/w\" 文件夹。\n文件夹 \"/a/x\" 和 \"/b/x\" 仍然会被标记，但 \"/a\" 和 \"/b\" 不再被标记，因为 \"/b\" 中有名为 \"w\" 的空文件夹而 \"/a\" 没有。\n注意，\"/a/z\" 和 \"/b/z\" 不会被标记，因为相同子文件夹的集合必须是非空集合，但这两个文件夹都是空的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= paths.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= paths[i].length &lt;= 500</code></li>\n\t<li><code>1 &lt;= paths[i][j].length &lt;= 10</code></li>\n\t<li><code>1 &lt;= sum(paths[i][j].length) &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>path[i][j]</code> 由小写英文字母组成</li>\n\t<li>不会存在两个路径都指向同一个文件夹的情况</li>\n\t<li>对于不在根层级的任意文件夹，其父文件夹也会包含在输入中</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1949.坚定的友谊",
        "hardRate": "MEDIUM",
        "passRate": "52.29%",
        "problemsUrl": "https://leetcode.cn/problems/strong-friendship/",
        "solutionsUrl": "https://leetcode.cn/problems/strong-friendship/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1950.所有子数组最小值中的最大值",
        "hardRate": "MEDIUM",
        "passRate": "50.91%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-of-minimum-values-in-all-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-of-minimum-values-in-all-subarrays/solution",
        "problemsDesc": null,
        "isPlus": true
    }
]