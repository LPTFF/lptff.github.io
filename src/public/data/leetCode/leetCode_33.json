[
    {
        "problemsName": " 1601.最多可达成的换楼请求数目",
        "hardRate": "HARD",
        "passRate": "61.90%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-achievable-transfer-requests/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-achievable-transfer-requests/solution",
        "problemsDesc": "<p>我们有&nbsp;<code>n</code>&nbsp;栋楼，编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。每栋楼有若干员工。由于现在是换楼的季节，部分员工想要换一栋楼居住。</p>\n\n<p>给你一个数组 <code>requests</code>&nbsp;，其中&nbsp;<code>requests[i] = [from<sub>i</sub>, to<sub>i</sub>]</code>&nbsp;，表示一个员工请求从编号为&nbsp;<code>from<sub>i</sub></code>&nbsp;的楼搬到编号为&nbsp;<code>to<sub>i</sub></code><sub>&nbsp;</sub>的楼。</p>\n\n<p>一开始&nbsp;<strong>所有楼都是满的</strong>，所以从请求列表中选出的若干个请求是可行的需要满足 <strong>每栋楼员工净变化为 0&nbsp;</strong>。意思是每栋楼 <strong>离开</strong>&nbsp;的员工数目 <strong>等于</strong>&nbsp;该楼 <strong>搬入</strong>&nbsp;的员工数数目。比方说&nbsp;<code>n = 3</code>&nbsp;且两个员工要离开楼&nbsp;<code>0</code>&nbsp;，一个员工要离开楼&nbsp;<code>1</code>&nbsp;，一个员工要离开楼 <code>2</code>&nbsp;，如果该请求列表可行，应该要有两个员工搬入楼&nbsp;<code>0</code>&nbsp;，一个员工搬入楼&nbsp;<code>1</code>&nbsp;，一个员工搬入楼&nbsp;<code>2</code>&nbsp;。</p>\n\n<p>请你从原请求列表中选出若干个请求，使得它们是一个可行的请求列表，并返回所有可行列表中最大请求数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/26/move1.jpg\" style=\"height: 406px; width: 600px;\"></p>\n\n<pre><strong>输入：</strong>n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]\n<strong>输出：</strong>5\n<strong>解释：</strong>请求列表如下：\n从楼 0 离开的员工为 x 和 y ，且他们都想要搬到楼 1 。\n从楼 1 离开的员工为 a 和 b ，且他们分别想要搬到楼 2 和 0 。\n从楼 2 离开的员工为 z ，且他想要搬到楼 0 。\n从楼 3 离开的员工为 c ，且他想要搬到楼 4 。\n没有员工从楼 4 离开。\n我们可以让 x 和 b 交换他们的楼，以满足他们的请求。\n我们可以让 y，a 和 z 三人在三栋楼间交换位置，满足他们的要求。\n所以最多可以满足 5 个请求。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/26/move2.jpg\" style=\"height: 327px; width: 450px;\"></p>\n\n<pre><strong>输入：</strong>n = 3, requests = [[0,0],[1,2],[2,1]]\n<strong>输出：</strong>3\n<strong>解释：</strong>请求列表如下：\n从楼 0 离开的员工为 x ，且他想要回到原来的楼 0 。\n从楼 1 离开的员工为 y ，且他想要搬到楼 2 。\n从楼 2 离开的员工为 z ，且他想要搬到楼 1 。\n我们可以满足所有的请求。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>1 &lt;= requests.length &lt;= 16</code></li>\n\t<li><code>requests[i].length == 2</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1602.找到二叉树中最近的右侧节点",
        "hardRate": "MEDIUM",
        "passRate": "74.63%",
        "problemsUrl": "https://leetcode.cn/problems/find-nearest-right-node-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/find-nearest-right-node-in-binary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1603.设计停车系统",
        "hardRate": "EASY",
        "passRate": "83.76%",
        "problemsUrl": "https://leetcode.cn/problems/design-parking-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-parking-system/solution",
        "problemsDesc": "<p>请你给一个停车场设计一个停车系统。停车场总共有三种不同大小的车位：大，中和小，每种尺寸分别有固定数目的车位。</p>\n\n<p>请你实现 <code>ParkingSystem</code> 类：</p>\n\n<ul>\n\t<li><code>ParkingSystem(int big, int medium, int small)</code> 初始化 <code>ParkingSystem</code> 类，三个参数分别对应每种停车位的数目。</li>\n\t<li><code>bool addCar(int carType)</code> 检查是否有 <code>carType</code> 对应的停车位。 <code>carType</code> 有三种类型：大，中，小，分别用数字 <code>1</code>， <code>2</code> 和 <code>3</code> 表示。<strong>一辆车只能停在</strong> <strong> </strong><code>carType</code> 对应尺寸的停车位中。如果没有空车位，请返回 <code>false</code> ，否则将该车停入车位并返回 <code>true</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"ParkingSystem\", \"addCar\", \"addCar\", \"addCar\", \"addCar\"]\n[[1, 1, 0], [1], [2], [3], [1]]\n<strong>输出：</strong>\n[null, true, true, false, false]\n\n<strong>解释：</strong>\nParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);\nparkingSystem.addCar(1); // 返回 true ，因为有 1 个空的大车位\nparkingSystem.addCar(2); // 返回 true ，因为有 1 个空的中车位\nparkingSystem.addCar(3); // 返回 false ，因为没有空的小车位\nparkingSystem.addCar(1); // 返回 false ，因为没有空的大车位，唯一一个大车位已经被占据了\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= big, medium, small <= 1000</code></li>\n\t<li><code>carType</code> 取值为 <code>1</code>， <code>2</code> 或 <code>3</code></li>\n\t<li>最多会调用 <code>addCar</code> 函数 <code>1000</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1604.警告一小时内使用相同员工卡大于等于三次的人",
        "hardRate": "MEDIUM",
        "passRate": "50.37%",
        "problemsUrl": "https://leetcode.cn/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/",
        "solutionsUrl": "https://leetcode.cn/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/solution",
        "problemsDesc": "<p>力扣公司的员工都使用员工卡来开办公室的门。每当一个员工使用一次他的员工卡，安保系统会记录下员工的名字和使用时间。如果一个员工在一小时时间内使用员工卡的次数大于等于三次，这个系统会自动发布一个 <strong>警告</strong>&nbsp;。</p>\n\n<p>给你字符串数组&nbsp;<code>keyName</code>&nbsp;和&nbsp;<code>keyTime</code> ，其中&nbsp;<code>[keyName[i], keyTime[i]]</code>&nbsp;对应一个人的名字和他在&nbsp;<strong>某一天</strong> 内使用员工卡的时间。</p>\n\n<p>使用时间的格式是 <strong>24小时制</strong>&nbsp;，形如<strong>&nbsp;\"HH:MM\"</strong>&nbsp;，比方说&nbsp;<code>\"23:51\"</code> 和&nbsp;<code>\"09:49\"</code>&nbsp;。</p>\n\n<p>请你返回去重后的收到系统警告的员工名字，将它们按 <strong>字典序</strong><strong>升序&nbsp;</strong>排序后返回。</p>\n\n<p>请注意&nbsp;<code>\"10:00\"</code> - <code>\"11:00\"</code>&nbsp;视为一个小时时间范围内，而&nbsp;<code>\"22:51\"</code> - <code>\"23:52\"</code>&nbsp;不被视为一小时时间范围内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>keyName = [\"daniel\",\"daniel\",\"daniel\",\"luis\",\"luis\",\"luis\",\"luis\"], keyTime = [\"10:00\",\"10:40\",\"11:00\",\"09:00\",\"11:00\",\"13:00\",\"15:00\"]\n<strong>输出：</strong>[\"daniel\"]\n<strong>解释：</strong>\"daniel\" 在一小时内使用了 3 次员工卡（\"10:00\"，\"10:40\"，\"11:00\"）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>keyName = [\"alice\",\"alice\",\"alice\",\"bob\",\"bob\",\"bob\",\"bob\"], keyTime = [\"12:01\",\"12:00\",\"18:00\",\"21:00\",\"21:20\",\"21:30\",\"23:00\"]\n<strong>输出：</strong>[\"bob\"]\n<strong>解释：</strong>\"bob\" 在一小时内使用了 3 次员工卡（\"21:00\"，\"21:20\"，\"21:30\"）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= keyName.length, keyTime.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>keyName.length == keyTime.length</code></li>\n\t<li><code>keyTime</code> 格式为&nbsp;<strong>\"HH:MM\"&nbsp;</strong>。</li>\n\t<li>保证&nbsp;<code>[keyName[i], keyTime[i]]</code>&nbsp;形成的二元对&nbsp;<strong>互不相同&nbsp;</strong>。</li>\n\t<li><code>1 &lt;= keyName[i].length &lt;= 10</code></li>\n\t<li><code>keyName[i]</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1605.给定行和列的和求可行矩阵",
        "hardRate": "MEDIUM",
        "passRate": "80.87%",
        "problemsUrl": "https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/",
        "solutionsUrl": "https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/solution",
        "problemsDesc": "<p>给你两个非负整数数组&nbsp;<code>rowSum</code> 和&nbsp;<code>colSum</code>&nbsp;，其中&nbsp;<code>rowSum[i]</code>&nbsp;是二维矩阵中第 <code>i</code>&nbsp;行元素的和， <code>colSum[j]</code>&nbsp;是第 <code>j</code>&nbsp;列元素的和。换言之你不知道矩阵里的每个元素，但是你知道每一行和每一列的和。</p>\n\n<p>请找到大小为&nbsp;<code>rowSum.length x colSum.length</code>&nbsp;的任意 <strong>非负整数</strong>&nbsp;矩阵，且该矩阵满足&nbsp;<code>rowSum</code> 和&nbsp;<code>colSum</code>&nbsp;的要求。</p>\n\n<p>请你返回任意一个满足题目要求的二维矩阵，题目保证存在 <strong>至少一个</strong>&nbsp;可行矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rowSum = [3,8], colSum = [4,7]\n<strong>输出：</strong>[[3,0],\n      [1,7]]\n<strong>解释：</strong>\n第 0 行：3 + 0 = 3 == rowSum[0]\n第 1 行：1 + 7 = 8 == rowSum[1]\n第 0 列：3 + 1 = 4 == colSum[0]\n第 1 列：0 + 7 = 7 == colSum[1]\n行和列的和都满足题目要求，且所有矩阵元素都是非负的。\n另一个可行的矩阵为：[[1,2],\n                  [3,5]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rowSum = [5,7,10], colSum = [8,6,8]\n<strong>输出：</strong>[[0,5,0],\n      [6,1,0],\n      [2,0,8]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>rowSum = [14,9], colSum = [6,9,8]\n<strong>输出：</strong>[[0,9,5],\n      [6,0,3]]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>rowSum = [1,0], colSum = [1]\n<strong>输出：</strong>[[1],\n      [0]]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>rowSum = [0], colSum = [0]\n<strong>输出：</strong>[[0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rowSum.length, colSum.length &lt;= 500</code></li>\n\t<li><code>0 &lt;= rowSum[i], colSum[i] &lt;= 10<sup>8</sup></code></li>\n\t<li><code>sum(rowSum) == sum(colSum)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1606.找到处理最多请求的服务器",
        "hardRate": "HARD",
        "passRate": "48.42%",
        "problemsUrl": "https://leetcode.cn/problems/find-servers-that-handled-most-number-of-requests/",
        "solutionsUrl": "https://leetcode.cn/problems/find-servers-that-handled-most-number-of-requests/solution",
        "problemsDesc": "<p>你有 <code>k</code>&nbsp;个服务器，编号为 <code>0</code>&nbsp;到 <code>k-1</code>&nbsp;，它们可以同时处理多个请求组。每个服务器有无穷的计算能力但是 <strong>不能同时处理超过一个请求</strong>&nbsp;。请求分配到服务器的规则如下：</p>\n\n<ul>\n\t<li>第&nbsp;<code>i</code>&nbsp;（序号从 0 开始）个请求到达。</li>\n\t<li>如果所有服务器都已被占据，那么该请求被舍弃（完全不处理）。</li>\n\t<li>如果第&nbsp;<code>(i % k)</code>&nbsp;个服务器空闲，那么对应服务器会处理该请求。</li>\n\t<li>否则，将请求安排给下一个空闲的服务器（服务器构成一个环，必要的话可能从第 0 个服务器开始继续找下一个空闲的服务器）。比方说，如果第 <code>i</code>&nbsp;个服务器在忙，那么会查看第 <code>(i+1)</code>&nbsp;个服务器，第 <code>(i+2)</code>&nbsp;个服务器等等。</li>\n</ul>\n\n<p>给你一个 <strong>严格递增</strong>&nbsp;的正整数数组&nbsp;<code>arrival</code>&nbsp;，表示第&nbsp;<code>i</code>&nbsp;个任务的到达时间，和另一个数组&nbsp;<code>load</code>&nbsp;，其中&nbsp;<code>load[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个请求的工作量（也就是服务器完成它所需要的时间）。你的任务是找到 <strong>最繁忙的服务器</strong>&nbsp;。最繁忙定义为一个服务器处理的请求数是所有服务器里最多的。</p>\n\n<p>请你返回包含所有&nbsp;<strong>最繁忙服务器</strong>&nbsp;序号的列表，你可以以任意顺序返回这个列表。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/03/load-1.png\" style=\"height: 221px; width: 389px;\" /></p>\n\n<pre>\n<strong>输入：</strong>k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] \n<strong>输出：</strong>[1] \n<strong>解释：</strong>\n所有服务器一开始都是空闲的。\n前 3 个请求分别由前 3 台服务器依次处理。\n请求 3 进来的时候，服务器 0 被占据，所以它被安排到下一台空闲的服务器，也就是服务器 1 。\n请求 4 进来的时候，由于所有服务器都被占据，该请求被舍弃。\n服务器 0 和 2 分别都处理了一个请求，服务器 1 处理了两个请求。所以服务器 1 是最忙的服务器。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 3, arrival = [1,2,3,4], load = [1,2,1,2]\n<strong>输出：</strong>[0]\n<strong>解释：</strong>\n前 3 个请求分别被前 3 个服务器处理。\n请求 3 进来，由于服务器 0 空闲，它被服务器 0 处理。\n服务器 0 处理了两个请求，服务器 1 和 2 分别处理了一个请求。所以服务器 0 是最忙的服务器。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 3, arrival = [1,2,3], load = [10,12,11]\n<strong>输出：</strong>[0,1,2]\n<strong>解释：</strong>每个服务器分别处理了一个请求，所以它们都是最忙的服务器。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 3, arrival = [1,2,3,4,8,9,10], load = [5,2,10,3,1,2,2]\n<strong>输出：</strong>[1]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 1, arrival = [1], load = [1]\n<strong>输出：</strong>[0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arrival.length, load.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>arrival.length == load.length</code></li>\n\t<li><code>1 &lt;= arrival[i], load[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>arrival</code>&nbsp;保证 <strong>严格递增</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1607.没有卖出的卖家",
        "hardRate": "EASY",
        "passRate": "54.29%",
        "problemsUrl": "https://leetcode.cn/problems/sellers-with-no-sales/",
        "solutionsUrl": "https://leetcode.cn/problems/sellers-with-no-sales/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1608.特殊数组的特征值",
        "hardRate": "EASY",
        "passRate": "61.36%",
        "problemsUrl": "https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x/",
        "solutionsUrl": "https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x/solution",
        "problemsDesc": "<p>给你一个非负整数数组 <code>nums</code> 。如果存在一个数 <code>x</code> ，使得 <code>nums</code> 中恰好有 <code>x</code> 个元素 <strong>大于或者等于</strong> <code>x</code> ，那么就称 <code>nums</code> 是一个 <strong>特殊数组</strong> ，而 <code>x</code> 是该数组的 <strong>特征值</strong> 。</p>\n\n<p>注意： <code>x</code> <strong>不必</strong> 是 <code>nums</code> 的中的元素。</p>\n\n<p>如果数组 <code>nums</code> 是一个 <strong>特殊数组</strong> ，请返回它的特征值 <code>x</code> 。否则，返回<em> </em><code>-1</code> 。可以证明的是，如果 <code>nums</code> 是特殊数组，那么其特征值 <code>x</code> 是 <strong>唯一的</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,5]\n<strong>输出：</strong>2\n<strong>解释：</strong>有 2 个元素（3 和 5）大于或等于 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,0]\n<strong>输出：</strong>-1\n<strong>解释：</strong>没有满足题目要求的特殊数组，故而也不存在特征值 x 。\n如果 x = 0，应该有 0 个元素 &gt;= x，但实际有 2 个。\n如果 x = 1，应该有 1 个元素 &gt;= x，但实际有 0 个。\n如果 x = 2，应该有 2 个元素 &gt;= x，但实际有 0 个。\nx 不能取更大的值，因为 nums 中只有两个元素。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,4,3,0,4]\n<strong>输出：</strong>3\n<strong>解释：</strong>有 3 个元素大于或等于 3 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,6,7,7,0]\n<strong>输出：</strong>-1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1609.奇偶树",
        "hardRate": "MEDIUM",
        "passRate": "58.05%",
        "problemsUrl": "https://leetcode.cn/problems/even-odd-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/even-odd-tree/solution",
        "problemsDesc": "<p>如果一棵二叉树满足下述几个条件，则可以称为 <strong>奇偶树</strong> ：</p>\n\n<ul>\n\t<li>二叉树根节点所在层下标为 <code>0</code> ，根的子节点所在层下标为 <code>1</code> ，根的孙节点所在层下标为 <code>2</code> ，依此类推。</li>\n\t<li><strong>偶数下标</strong> 层上的所有节点的值都是 <strong>奇</strong> 整数，从左到右按顺序 <strong>严格递增</strong></li>\n\t<li><strong>奇数下标</strong> 层上的所有节点的值都是 <strong>偶</strong> 整数，从左到右按顺序 <strong>严格递减</strong></li>\n</ul>\n\n<p>给你二叉树的根节点，如果二叉树为 <strong>奇偶树 </strong>，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_1_1966.png\" style=\"height: 229px; width: 362px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,10,4,3,null,7,9,12,8,6,null,null,2]\n<strong>输出：</strong>true\n<strong>解释：</strong>每一层的节点值分别是：\n0 层：[1]\n1 层：[10,4]\n2 层：[3,7,9]\n3 层：[12,8,6,2]\n由于 0 层和 2 层上的节点值都是奇数且严格递增，而 1 层和 3 层上的节点值都是偶数且严格递减，因此这是一棵奇偶树。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_2_1966.png\" style=\"height: 167px; width: 363px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [5,4,2,3,3,7]\n<strong>输出：</strong>false\n<strong>解释：</strong>每一层的节点值分别是：\n0 层：[5]\n1 层：[4,2]\n2 层：[3,3,7]\n2 层上的节点值不满足严格递增的条件，所以这不是一棵奇偶树。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/sample_1_333_1966.png\" style=\"height: 167px; width: 363px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,9,1,3,5,7]\n<strong>输出：</strong>false\n<strong>解释：</strong>1 层上的节点值应为偶数。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [11,8,6,1,3,9,11,30,20,18,16,12,10,4,2,17]\n<strong>输出：</strong>true\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 <= Node.val <= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1610.可见点的最大数目",
        "hardRate": "HARD",
        "passRate": "44.39%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-visible-points/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-visible-points/solution",
        "problemsDesc": "<p>给你一个点数组 <code>points</code> 和一个表示角度的整数 <code>angle</code> ，你的位置是 <code>location</code> ，其中 <code>location = [pos<sub>x</sub>, pos<sub>y</sub>]</code> 且 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 都表示 X-Y 平面上的整数坐标。</p>\n\n<p>最开始，你面向东方进行观测。你 <strong>不能</strong> 进行移动改变位置，但可以通过 <strong>自转</strong> 调整观测角度。换句话说，<code>pos<sub>x</sub></code> 和 <code>pos<sub>y</sub></code> 不能改变。你的视野范围的角度用 <code>angle</code> 表示， 这决定了你观测任意方向时可以多宽。设 <code>d</code> 为你逆时针自转旋转的度数，那么你的视野就是角度范围 <code>[d - angle/2, d + angle/2]</code> 所指示的那片区域。</p>\n\n<video autoplay=\"\" controls=\"\" height=\"360\" muted=\"\" style=\"max-width:100%;height:auto;\" width=\"750\"><source src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/angle.mp4\" type=\"video/mp4\" />Your browser does not support the video tag or this video format.</video>\n\n<p>对于每个点，如果由该点、你的位置以及从你的位置直接向东的方向形成的角度 <strong>位于你的视野中</strong> ，那么你就可以看到它。</p>\n\n<p>同一个坐标上可以有多个点。你所在的位置也可能存在一些点，但不管你的怎么旋转，总是可以看到这些点。同时，点不会阻碍你看到其他点。</p>\n\n<p>返回你能看到的点的最大数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/89a07e9b-00ab-4967-976a-c723b2aa8656.png\" style=\"height: 300px; width: 400px;\" /></p>\n\n<pre>\n<strong>输入：</strong>points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>阴影区域代表你的视野。在你的视野中，所有的点都清晰可见，尽管 [2,2] 和 [3,3]在同一条直线上，你仍然可以看到 [3,3] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[2,1],[2,2],[3,4],[1,1]], angle = 90, location = [1,1]\n<strong>输出：</strong>4\n<strong>解释：</strong>在你的视野中，所有的点都清晰可见，包括你所在位置的那个点。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/04/5010bfd3-86e6-465f-ac64-e9df941d2e49.png\" style=\"height: 348px; width: 690px;\" /></p>\n\n<pre>\n<strong>输入：</strong>points = [[1,0],[2,1]], angle = 13, location = [1,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>如图所示，你只能看到两点之一。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= points.length <= 10<sup>5</sup></code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>location.length == 2</code></li>\n\t<li><code>0 <= angle < 360</code></li>\n\t<li><code>0 <= pos<sub>x</sub>, pos<sub>y</sub>, x<sub>i</sub>, y<sub>i</sub> <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1611.使整数变为 0 的最少操作次数",
        "hardRate": "HARD",
        "passRate": "60.70%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-one-bit-operations-to-make-integers-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-one-bit-operations-to-make-integers-zero/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code>，你需要重复执行多次下述操作将其转换为 <code>0</code> ：</p>\n\n<ul>\n\t<li>翻转 <code>n</code> 的二进制表示中最右侧位（第 <code>0</code> 位）。</li>\n\t<li>如果第 <code>(i-1)</code> 位为 <code>1</code> 且从第 <code>(i-2)</code> 位到第 <code>0</code> 位都为 <code>0</code>，则翻转 <code>n</code> 的二进制表示中的第 <code>i</code> 位。</li>\n</ul>\n\n<p>返回将 <code>n</code> 转换为 <code>0</code> 的最小操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>3 的二进制表示为 \"11\"\n\"<strong>1</strong>1\" -&gt; \"<strong>0</strong>1\" ，执行的是第 2 种操作，因为第 0 位为 1 。\n\"0<strong>1</strong>\" -&gt; \"0<strong>0</strong>\" ，执行的是第 1 种操作。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6\n<strong>输出：</strong>4\n<strong>解释：</strong>6 的二进制表示为 \"110\".\n\"<strong>1</strong>10\" -&gt; \"<strong>0</strong>10\" ，执行的是第 2 种操作，因为第 1 位为 1 ，第 0 到 0 位为 0 。\n\"01<strong>0</strong>\" -&gt; \"01<strong>1</strong>\" ，执行的是第 1 种操作。\n\"0<strong>1</strong>1\" -&gt; \"0<strong>0</strong>1\" ，执行的是第 2 种操作，因为第 0 位为 1 。\n\"00<strong>1</strong>\" -&gt; \"00<strong>0</strong>\" ，执行的是第 1 种操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1612.检查两棵二叉表达式树是否等价",
        "hardRate": "MEDIUM",
        "passRate": "74.48%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-two-expression-trees-are-equivalent/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-two-expression-trees-are-equivalent/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1613.找到遗失的ID",
        "hardRate": "MEDIUM",
        "passRate": "72.96%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-missing-ids/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-missing-ids/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1614.括号的最大嵌套深度",
        "hardRate": "EASY",
        "passRate": "82.29%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-nesting-depth-of-the-parentheses/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-nesting-depth-of-the-parentheses/solution",
        "problemsDesc": "<p>如果字符串满足以下条件之一，则可以称之为 <strong>有效括号字符串</strong><strong>（valid parentheses string</strong>，可以简写为 <strong>VPS</strong>）：</p>\n\n<ul>\n\t<li>字符串是一个空字符串 <code>\"\"</code>，或者是一个不为 <code>\"(\"</code> 或 <code>\")\"</code> 的单字符。</li>\n\t<li>字符串可以写为 <code>AB</code>（<code>A</code> 与 <code>B</code>&nbsp;字符串连接），其中 <code>A</code> 和 <code>B</code> 都是 <strong>有效括号字符串</strong> 。</li>\n\t<li>字符串可以写为 <code>(A)</code>，其中 <code>A</code> 是一个 <strong>有效括号字符串</strong> 。</li>\n</ul>\n\n<p>类似地，可以定义任何有效括号字符串&nbsp;<code>S</code> 的 <strong>嵌套深度</strong> <code>depth(S)</code>：</p>\n\n<ul>\n\t<li><code>depth(\"\") = 0</code></li>\n\t<li><code>depth(C) = 0</code>，其中 <code>C</code> 是单个字符的字符串，且该字符不是 <code>\"(\"</code> 或者 <code>\")\"</code></li>\n\t<li><code>depth(A + B) = max(depth(A), depth(B))</code>，其中 <code>A</code> 和 <code>B</code> 都是 <strong>有效括号字符串</strong></li>\n\t<li><code>depth(\"(\" + A + \")\") = 1 + depth(A)</code>，其中 <code>A</code> 是一个 <strong>有效括号字符串</strong></li>\n</ul>\n\n<p>例如：<code>\"\"</code>、<code>\"()()\"</code>、<code>\"()(()())\"</code> 都是 <strong>有效括号字符串</strong>（嵌套深度分别为 0、1、2），而 <code>\")(\"</code> 、<code>\"(()\"</code> 都不是 <strong>有效括号字符串</strong> 。</p>\n\n<p>给你一个 <strong>有效括号字符串</strong> <code>s</code>，返回该字符串的<em> </em><code>s</code> <strong>嵌套深度</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(1+(2*3)+((<strong>8</strong>)/4))+1\"\n<strong>输出：</strong>3\n<strong>解释：</strong>数字 8 在嵌套的 3 层括号中。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(1)+((2))+(((<strong>3</strong>)))\"\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 由数字 <code>0-9</code> 和字符 <code>'+'</code>、<code>'-'</code>、<code>'*'</code>、<code>'/'</code>、<code>'('</code>、<code>')'</code> 组成</li>\n\t<li>题目数据保证括号表达式 <code>s</code> 是 <strong>有效的括号表达式</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1615.最大网络秩",
        "hardRate": "MEDIUM",
        "passRate": "60.14%",
        "problemsUrl": "https://leetcode.cn/problems/maximal-network-rank/",
        "solutionsUrl": "https://leetcode.cn/problems/maximal-network-rank/solution",
        "problemsDesc": "<p><code>n</code> 座城市和一些连接这些城市的道路 <code>roads</code> 共同组成一个基础设施网络。每个 <code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 都表示在城市 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间有一条双向道路。</p>\n\n<p>两座不同城市构成的 <strong>城市对</strong> 的 <strong>网络秩</strong> 定义为：与这两座城市 <strong>直接</strong> 相连的道路总数。如果存在一条道路直接连接这两座城市，则这条道路只计算 <strong>一次</strong> 。</p>\n\n<p>整个基础设施网络的 <strong>最大网络秩</strong> 是所有不同城市对中的 <strong>最大网络秩</strong> 。</p>\n\n<p>给你整数 <code>n</code> 和数组 <code>roads</code>，返回整个基础设施网络的 <strong>最大网络秩</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/11/ex1.png\" style=\"width: 292px; height: 172px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, roads = [[0,1],[0,3],[1,2],[1,3]]\n<strong>输出：</strong>4\n<strong>解释：</strong>城市 0 和 1 的网络秩是 4，因为共有 4 条道路与城市 0 或 1 相连。位于 0 和 1 之间的道路只计算一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/11/ex2.png\" style=\"width: 292px; height: 172px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]]\n<strong>输出：</strong>5\n<strong>解释：</strong>共有 5 条道路与城市 1 或 2 相连。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]]\n<strong>输出：</strong>5\n<strong>解释：</strong>2 和 5 的网络秩为 5，注意并非所有的城市都需要连接起来。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 100</code></li>\n\t<li><code>0 <= roads.length <= n * (n - 1) / 2</code></li>\n\t<li><code>roads[i].length == 2</code></li>\n\t<li><code>0 <= a<sub>i</sub>, b<sub>i</sub> <= n-1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>每对城市之间 <strong>最多只有一条</strong> 道路相连</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1616.分割两个字符串得到回文串",
        "hardRate": "MEDIUM",
        "passRate": "37.53%",
        "problemsUrl": "https://leetcode.cn/problems/split-two-strings-to-make-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/split-two-strings-to-make-palindrome/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>a</code> 和&nbsp;<code>b</code>&nbsp;，它们长度相同。请你选择一个下标，将两个字符串都在&nbsp;<strong>相同的下标 </strong>分割开。由&nbsp;<code>a</code>&nbsp;可以得到两个字符串：&nbsp;<code>a<sub>prefix</sub></code>&nbsp;和&nbsp;<code>a<sub>suffix</sub></code>&nbsp;，满足&nbsp;<code>a = a<sub>prefix</sub> + a<sub>suffix</sub></code><sub>&nbsp;</sub>，同理，由&nbsp;<code>b</code> 可以得到两个字符串&nbsp;<code>b<sub>prefix</sub></code> 和&nbsp;<code>b<sub>suffix</sub></code>&nbsp;，满足&nbsp;<code>b = b<sub>prefix</sub> + b<sub>suffix</sub></code>&nbsp;。请你判断&nbsp;<code>a<sub>prefix</sub> + b<sub>suffix</sub></code> 或者&nbsp;<code>b<sub>prefix</sub> + a<sub>suffix</sub></code>&nbsp;能否构成回文串。</p>\n\n<p>当你将一个字符串&nbsp;<code>s</code>&nbsp;分割成&nbsp;<code>s<sub>prefix</sub></code> 和&nbsp;<code>s<sub>suffix</sub></code>&nbsp;时，&nbsp;<code>s<sub>suffix</sub></code> 或者&nbsp;<code>s<sub>prefix</sub></code> 可以为空。比方说，&nbsp;<code>s = \"abc\"</code>&nbsp;那么&nbsp;<code>\"\" + \"abc\"</code>&nbsp;，&nbsp;<code>\"a\" + \"bc\"&nbsp;</code>，&nbsp;<code>\"ab\" + \"c\"</code>&nbsp;和&nbsp;<code>\"abc\" + \"\"</code>&nbsp;都是合法分割。</p>\n\n<p>如果 <strong>能构成回文字符串</strong> ，那么请返回&nbsp;<code>true</code>，否则返回<em>&nbsp;</em><code>false</code>&nbsp;。</p>\n\n<p><strong>注意</strong>，&nbsp;<code>x + y</code>&nbsp;表示连接字符串&nbsp;<code>x</code> 和&nbsp;<code>y</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>a = \"x\", b = \"y\"\n<b>输出：</b>true\n<b>解释：</b>如果 a 或者 b 是回文串，那么答案一定为 true ，因为你可以如下分割：\na<sub>prefix</sub> = \"\", a<sub>suffix</sub> = \"x\"\nb<sub>prefix</sub> = \"\", b<sub>suffix</sub> = \"y\"\n那么 a<sub>prefix</sub> + b<sub>suffix</sub> = \"\" + \"y\" = \"y\" 是回文串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = \"abdef\", b = \"fecab\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>a = \"ulacfd\", b = \"jizalu\"\n<b>输出：</b>true\n<b>解释：</b>在下标为 3 处分割：\na<sub>prefix</sub> = \"ula\", a<sub>suffix</sub> = \"cfd\"\nb<sub>prefix</sub> = \"jiz\", b<sub>suffix</sub> = \"alu\"\n那么 a<sub>prefix</sub> + b<sub>suffix</sub> = \"ula\" + \"alu\" = \"ulaalu\" 是回文串。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>a.length == b.length</code></li>\n\t<li><code>a</code> 和&nbsp;<code>b</code>&nbsp;都只包含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1617.统计子树中城市之间最大距离",
        "hardRate": "HARD",
        "passRate": "79.18%",
        "problemsUrl": "https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/",
        "solutionsUrl": "https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/solution",
        "problemsDesc": "<p>给你 <code>n</code> 个城市，编号为从 <code>1</code> 到 <code>n</code> 。同时给你一个大小为 <code>n-1</code> 的数组 <code>edges</code> ，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> 表示城市 <code>u<sub>i</sub></code> 和 <code>v<sub>i</sub></code><sub> </sub>之间有一条双向边。题目保证任意城市之间只有唯一的一条路径。换句话说，所有城市形成了一棵 <strong>树</strong> 。</p>\n\n<p>一棵 <strong>子树</strong> 是城市的一个子集，且子集中任意城市之间可以通过子集中的其他城市和边到达。两个子树被认为不一样的条件是至少有一个城市在其中一棵子树中存在，但在另一棵子树中不存在。</p>\n\n<p>对于 <code>d</code> 从 <code>1</code> 到 <code>n-1</code> ，请你找到城市间 <strong>最大距离</strong> 恰好为 <code>d</code> 的所有子树数目。</p>\n\n<p>请你返回一个大小为 <code>n-1</code> 的数组，其中第<em> </em><code>d</code><em> </em>个元素（<strong>下标从 1 开始</strong>）是城市间 <strong>最大距离</strong> 恰好等于 <code>d</code> 的子树数目。</p>\n\n<p><strong>请注意</strong>，两个城市间距离定义为它们之间需要经过的边的数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/11/p1.png\" style=\"width: 161px; height: 181px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>n = 4, edges = [[1,2],[2,3],[2,4]]\n<b>输出：</b>[3,4,0]\n<strong>解释：\n</strong>子树 {1,2}, {2,3} 和 {2,4} 最大距离都是 1 。\n子树 {1,2,3}, {1,2,4}, {2,3,4} 和 {1,2,3,4} 最大距离都为 2 。\n不存在城市间最大距离为 3 的子树。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 2, edges = [[1,2]]\n<b>输出：</b>[1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, edges = [[1,2],[2,3]]\n<b>输出：</b>[2,1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 15</code></li>\n\t<li><code>edges.length == n-1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 <= u<sub>i</sub>, v<sub>i</sub> <= n</code></li>\n\t<li>题目保证 <code>(u<sub>i</sub>, v<sub>i</sub>)</code> 所表示的边互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1618.找出适应屏幕的最大字号",
        "hardRate": "MEDIUM",
        "passRate": "62.47%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-font-to-fit-a-sentence-in-a-screen/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-font-to-fit-a-sentence-in-a-screen/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1619.删除某些元素后的数组均值",
        "hardRate": "EASY",
        "passRate": "71.72%",
        "problemsUrl": "https://leetcode.cn/problems/mean-of-array-after-removing-some-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/mean-of-array-after-removing-some-elements/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> ，请你删除最小 <code>5%</code> 的数字和最大 <code>5%</code> 的数字后，剩余数字的平均值。</p>\n\n<p>与 <strong>标准答案</strong> 误差在 <code>10<sup>-5</sup></code> 的结果都被视为正确结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n<b>输出：</b>2.00000\n<b>解释：</b>删除数组中最大和最小的元素后，所有元素都等于 2，所以平均值为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n<b>输出：</b>4.00000\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n<b>输出：</b>4.77778\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n<b>输出：</b>5.27778\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n<b>输出：</b>5.29167\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>20 <= arr.length <= 1000</code></li>\n\t<li><code>arr.length</code><b> </b>是 <code>20</code> 的<strong> 倍数</strong> </li>\n\t<li><code>0 <= arr[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1620.网络信号最好的坐标",
        "hardRate": "MEDIUM",
        "passRate": "46.05%",
        "problemsUrl": "https://leetcode.cn/problems/coordinate-with-maximum-network-quality/",
        "solutionsUrl": "https://leetcode.cn/problems/coordinate-with-maximum-network-quality/solution",
        "problemsDesc": "<p>给你一个数组 <code>towers</code>&nbsp;和一个整数 <code>radius</code> 。</p>\n\n<p>数组&nbsp; <code>towers</code>&nbsp; 中包含一些网络信号塔，其中&nbsp;<code>towers[i] = [x<sub>i</sub>, y<sub>i</sub>, q<sub>i</sub>]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个网络信号塔的坐标是&nbsp;<code>(x<sub>i</sub>, y<sub>i</sub>)</code>&nbsp;且信号强度参数为&nbsp;<code>q<sub>i</sub></code><sub>&nbsp;</sub>。所有坐标都是在&nbsp; X-Y 坐标系内的&nbsp;<strong>整数</strong>&nbsp;坐标。两个坐标之间的距离用 <strong>欧几里得距离</strong>&nbsp;计算。</p>\n\n<p>整数&nbsp;<code>radius</code>&nbsp;表示一个塔 <strong>能到达&nbsp;</strong>的 <strong>最远距离</strong>&nbsp;。如果一个坐标跟塔的距离在 <code>radius</code>&nbsp;以内，那么该塔的信号可以到达该坐标。在这个范围以外信号会很微弱，所以 <code>radius</code>&nbsp;以外的距离该塔是 <strong>不能到达的</strong>&nbsp;。</p>\n\n<p>如果第 <code>i</code>&nbsp;个塔能到达 <code>(x, y)</code>&nbsp;，那么该塔在此处的信号为&nbsp;<code>⌊q<sub>i</sub> / (1 + d)⌋</code>&nbsp;，其中&nbsp;<code>d</code>&nbsp;是塔跟此坐标的距离。一个坐标的 <b>信号强度</b> 是所有 <strong>能到达&nbsp;</strong>该坐标的塔的信号强度之和。</p>\n\n<p>请你返回数组 <code>[c<sub>x</sub>, c<sub>y</sub>]</code> ，表示 <strong>信号强度</strong> 最大的 <strong>整数</strong> 坐标点&nbsp;<code>(c<sub>x</sub>, c<sub>y</sub>)</code> 。如果有多个坐标网络信号一样大，请你返回字典序最小的 <strong>非负</strong> 坐标。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>坐标&nbsp;<code>(x1, y1)</code>&nbsp;字典序比另一个坐标&nbsp;<code>(x2, y2)</code> 小，需满足以下条件之一：\n\n\t<ul>\n\t\t<li>要么&nbsp;<code>x1 &lt; x2</code>&nbsp;，</li>\n\t\t<li>要么&nbsp;<code>x1 == x2</code> 且&nbsp;<code>y1 &lt; y2</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n\t<li><code>⌊val⌋</code>&nbsp;表示小于等于&nbsp;<code>val</code>&nbsp;的最大整数（向下取整函数）。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/17/untitled-diagram.png\" style=\"width: 176px; height: 176px;\" />\n<pre>\n<b>输入：</b>towers = [[1,2,5],[2,1,7],[3,1,9]], radius = 2\n<b>输出：</b>[2,1]\n<strong>解释：</strong>\n坐标 (2, 1) 信号强度之和为 13\n- 塔 (2, 1) 强度参数为 7 ，在该点强度为 ⌊7 / (1 + sqrt(0)⌋ = ⌊7⌋ = 7\n- 塔 (1, 2) 强度参数为 5 ，在该点强度为 ⌊5 / (1 + sqrt(2)⌋ = ⌊2.07⌋ = 2\n- 塔 (3, 1) 强度参数为 9 ，在该点强度为 ⌊9 / (1 + sqrt(1)⌋ = ⌊4.5⌋ = 4\n没有别的坐标有更大的信号强度。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>towers = [[23,11,21]], radius = 9\n<b>输出：</b>[23,11]\n<strong>解释：</strong>由于仅存在一座信号塔，所以塔的位置信号强度最大。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>towers = [[1,2,13],[2,1,7],[0,1,9]], radius = 2\n<b>输出：</b>[1,2]\n<strong>解释：</strong>坐标 (1, 2) 的信号强度最大。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= towers.length &lt;= 50</code></li>\n\t<li><code>towers[i].length == 3</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>, q<sub>i</sub> &lt;= 50</code></li>\n\t<li><code>1 &lt;= radius &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1621.大小为 K 的不重叠线段的数目",
        "hardRate": "MEDIUM",
        "passRate": "47.99%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-sets-of-k-non-overlapping-line-segments/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-sets-of-k-non-overlapping-line-segments/solution",
        "problemsDesc": "<p>给你一维空间的 <code>n</code> 个点，其中第 <code>i</code> 个点（编号从 <code>0</code> 到 <code>n-1</code>）位于 <code>x = i</code> 处，请你找到 <strong>恰好</strong> <code>k</code> <strong>个不重叠</strong> 线段且每个线段至少覆盖两个点的方案数。线段的两个端点必须都是 <strong>整数坐标</strong> 。这 <code>k</code> 个线段不需要全部覆盖全部 <code>n</code> 个点，且它们的端点 <strong>可以 </strong>重合。</p>\n\n<p>请你返回 <code>k</code> 个不重叠线段的方案数。由于答案可能很大，请将结果对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/17/ex1.png\" style=\"width: 179px; height: 222px;\" />\n<pre>\n<b>输入：</b>n = 4, k = 2\n<b>输出：</b>5\n<strong>解释：\n</strong>如图所示，两个线段分别用红色和蓝色标出。\n上图展示了 5 种不同的方案 {(0,2),(2,3)}，{(0,1),(1,3)}，{(0,1),(2,3)}，{(1,2),(2,3)}，{(0,1),(1,2)} 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, k = 1\n<b>输出：</b>3\n<strong>解释：</strong>总共有 3 种不同的方案 {(0,1)}, {(0,2)}, {(1,2)} 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 30, k = 7\n<b>输出：</b>796297179\n<strong>解释：</strong>画 7 条线段的总方案数为 3796297200 种。将这个数对 10<sup>9</sup> + 7 取余得到 796297179 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5, k = 3\n<b>输出：</b>7\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, k = 2\n<b>输出：</b>1</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 1000</code></li>\n\t<li><code>1 <= k <= n-1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1622.奇妙序列",
        "hardRate": "HARD",
        "passRate": "17.31%",
        "problemsUrl": "https://leetcode.cn/problems/fancy-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/fancy-sequence/solution",
        "problemsDesc": "<p>请你实现三个 API <code>append</code>，<code>addAll</code> 和 <code>multAll</code> 来实现奇妙序列。</p>\n\n<p>请实现 <code>Fancy</code> 类 ：</p>\n\n<ul>\n\t<li><code>Fancy()</code> 初始化一个空序列对象。</li>\n\t<li><code>void append(val)</code> 将整数 <code>val</code> 添加在序列末尾。</li>\n\t<li><code>void addAll(inc)</code> 将所有序列中的现有数值都增加 <code>inc</code> 。</li>\n\t<li><code>void multAll(m)</code> 将序列中的所有现有数值都乘以整数 <code>m</code> 。</li>\n\t<li><code>int getIndex(idx)</code> 得到下标为 <code>idx</code> 处的数值（下标从 0 开始），并将结果对 <code>10<sup>9</sup> + 7</code> 取余。如果下标大于等于序列的长度，请返回 <code>-1</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"Fancy\", \"append\", \"addAll\", \"append\", \"multAll\", \"getIndex\", \"addAll\", \"append\", \"multAll\", \"getIndex\", \"getIndex\", \"getIndex\"]\n[[], [2], [3], [7], [2], [0], [3], [10], [2], [0], [1], [2]]\n<strong>输出：</strong>\n[null, null, null, null, null, 10, null, null, null, 26, 34, 20]\n\n<strong>解释：</strong>\nFancy fancy = new Fancy();\nfancy.append(2);   // 奇妙序列：[2]\nfancy.addAll(3);   // 奇妙序列：[2+3] -> [5]\nfancy.append(7);   // 奇妙序列：[5, 7]\nfancy.multAll(2);  // 奇妙序列：[5*2, 7*2] -> [10, 14]\nfancy.getIndex(0); // 返回 10\nfancy.addAll(3);   // 奇妙序列：[10+3, 14+3] -> [13, 17]\nfancy.append(10);  // 奇妙序列：[13, 17, 10]\nfancy.multAll(2);  // 奇妙序列：[13*2, 17*2, 10*2] -> [26, 34, 20]\nfancy.getIndex(0); // 返回 26\nfancy.getIndex(1); // 返回 34\nfancy.getIndex(2); // 返回 20\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= val, inc, m <= 100</code></li>\n\t<li><code>0 <= idx <= 10<sup>5</sup></code></li>\n\t<li>总共最多会有 <code>10<sup>5</sup></code> 次对 <code>append</code>，<code>addAll</code>，<code>multAll</code> 和 <code>getIndex</code> 的调用。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1623.三人国家代表队",
        "hardRate": "EASY",
        "passRate": "78.50%",
        "problemsUrl": "https://leetcode.cn/problems/all-valid-triplets-that-can-represent-a-country/",
        "solutionsUrl": "https://leetcode.cn/problems/all-valid-triplets-that-can-represent-a-country/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1624.两个相同字符之间的最长子字符串",
        "hardRate": "EASY",
        "passRate": "64.42%",
        "problemsUrl": "https://leetcode.cn/problems/largest-substring-between-two-equal-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-substring-between-two-equal-characters/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code>，请你返回 <strong>两个相同字符之间的最长子字符串的长度</strong> <em>，</em>计算长度时不含这两个字符。如果不存在这样的子字符串，返回 <code>-1</code> 。</p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"aa\"\n<strong>输出：</strong>0\n<strong>解释：</strong>最优的子字符串是两个 'a' 之间的空子字符串。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abca\"\n<strong>输出：</strong>2\n<strong>解释：</strong>最优的子字符串是 \"bc\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = \"cbzxy\"\n<strong>输出：</strong>-1\n<strong>解释：</strong>s 中不存在出现出现两次的字符，所以返回 -1 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = \"cabbac\"\n<strong>输出：</strong>4\n<strong>解释：</strong>最优的子字符串是 \"abba\" ，其他的非最优解包括 \"bb\" 和 \"\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 300</code></li>\n\t<li><code>s</code> 只含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1625.执行操作后字典序最小的字符串",
        "hardRate": "MEDIUM",
        "passRate": "66.71%",
        "problemsUrl": "https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 以及两个整数 <code>a</code> 和 <code>b</code> 。其中，字符串 <code>s</code> 的长度为偶数，且仅由数字 <code>0</code> 到 <code>9</code> 组成。</p>\n\n<p>你可以在 <code>s</code> 上按任意顺序多次执行下面两个操作之一：</p>\n\n<ul>\n\t<li>累加：将  <code>a</code> 加到 <code>s</code> 中所有下标为奇数的元素上（<strong>下标从 0 开始</strong>）。数字一旦超过 <code>9</code> 就会变成 <code>0</code>，如此循环往复。例如，<code>s = \"3456\"</code> 且 <code>a = 5</code>，则执行此操作后 <code>s</code> 变成 <code>\"3951\"</code>。</li>\n\t<li>轮转：将 <code>s</code> 向右轮转 <code>b</code> 位。例如，<code>s = \"3456\"</code> 且 <code>b = 1</code>，则执行此操作后 <code>s</code> 变成 <code>\"6345\"</code>。</li>\n</ul>\n\n<p>请你返回在 <code>s</code> 上执行上述操作任意次后可以得到的 <strong>字典序最小</strong> 的字符串。</p>\n\n<p>如果两个字符串长度相同，那么字符串 <code>a</code> 字典序比字符串 <code>b</code> 小可以这样定义：在 <code>a</code> 和 <code>b</code> 出现不同的第一个位置上，字符串 <code>a</code> 中的字符出现在字母表中的时间早于 <code>b</code> 中的对应字符。例如，<code>\"0158”</code> 字典序比 <code>\"0190\"</code> 小，因为不同的第一个位置是在第三个字符，显然 <code>'5'</code> 出现在 <code>'9'</code> 之前。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"5525\", a = 9, b = 2\n<strong>输出：</strong>\"2050\"\n<strong>解释：</strong>执行操作如下：\n初态：\"5525\"\n轮转：\"2555\"\n累加：\"2454\"\n累加：\"2353\"\n轮转：\"5323\"\n累加：\"5222\"\n累加：\"5121\"\n轮转：\"2151\"\n累加：\"2050\"​​​​​​​​​​​​\n无法获得字典序小于 \"2050\" 的字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"74\", a = 5, b = 1\n<strong>输出：</strong>\"24\"\n<strong>解释：</strong>执行操作如下：\n初态：\"74\"\n轮转：\"47\"\n累加：\"42\"\n轮转：\"24\"​​​​​​​​​​​​\n无法获得字典序小于 \"24\" 的字符串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0011\", a = 4, b = 2\n<strong>输出：</strong>\"0011\"\n<strong>解释：</strong>无法获得字典序小于 \"0011\" 的字符串。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"43987654\", a = 7, b = 3\n<strong>输出：</strong>\"00553311\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= s.length <= 100</code></li>\n\t<li><code>s.length</code> 是偶数</li>\n\t<li><code>s</code> 仅由数字 <code>0</code> 到 <code>9</code> 组成</li>\n\t<li><code>1 <= a <= 9</code></li>\n\t<li><code>1 <= b <= s.length - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1626.无矛盾的最佳球队",
        "hardRate": "MEDIUM",
        "passRate": "53.72%",
        "problemsUrl": "https://leetcode.cn/problems/best-team-with-no-conflicts/",
        "solutionsUrl": "https://leetcode.cn/problems/best-team-with-no-conflicts/solution",
        "problemsDesc": "<p>假设你是球队的经理。对于即将到来的锦标赛，你想组合一支总体得分最高的球队。球队的得分是球队中所有球员的分数 <strong>总和</strong> 。</p>\n\n<p>然而，球队中的矛盾会限制球员的发挥，所以必须选出一支 <strong>没有矛盾</strong> 的球队。如果一名年龄较小球员的分数 <strong>严格大于</strong> 一名年龄较大的球员，则存在矛盾。同龄球员之间不会发生矛盾。</p>\n\n<p>给你两个列表 <code>scores</code> 和 <code>ages</code>，其中每组 <code>scores[i]</code> 和 <code>ages[i]</code> 表示第 <code>i</code> 名球员的分数和年龄。请你返回 <strong>所有可能的无矛盾球队中得分最高那支的分数</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>scores = [1,3,5,10,15], ages = [1,2,3,4,5]\n<strong>输出：</strong>34\n<strong>解释：</strong>你可以选中所有球员。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>scores = [4,5,6,5], ages = [2,1,2,1]\n<strong>输出：</strong>16\n<strong>解释：</strong>最佳的选择是后 3 名球员。注意，你可以选中多个同龄球员。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>scores = [1,2,3,5], ages = [8,9,10,1]\n<strong>输出：</strong>6\n<strong>解释：</strong>最佳的选择是前 3 名球员。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= scores.length, ages.length &lt;= 1000</code></li>\n\t<li><code>scores.length == ages.length</code></li>\n\t<li><code>1 &lt;= scores[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= ages[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1627.带阈值的图连通性",
        "hardRate": "HARD",
        "passRate": "42.26%",
        "problemsUrl": "https://leetcode.cn/problems/graph-connectivity-with-threshold/",
        "solutionsUrl": "https://leetcode.cn/problems/graph-connectivity-with-threshold/solution",
        "problemsDesc": "<p>有 <code>n</code> 座城市，编号从 <code>1</code> 到 <code>n</code> 。编号为 <code>x</code> 和 <code>y</code> 的两座城市直接连通的前提是： <code>x</code> 和 <code>y</code> 的公因数中，至少有一个 <strong>严格大于</strong> 某个阈值 <code>threshold</code> 。更正式地说，如果存在整数 <code>z</code> ，且满足以下所有条件，则编号 <code>x</code> 和 <code>y</code> 的城市之间有一条道路：</p>\n\n<ul>\n\t<li><code>x % z == 0</code></li>\n\t<li><code>y % z == 0</code></li>\n\t<li><code>z > threshold</code></li>\n</ul>\n\n<p>给你两个整数 <code>n</code> 和 <code>threshold</code> ，以及一个待查询数组，请你判断每个查询<code> queries[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 指向的城市 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 是否连通（即，它们之间是否存在一条路径）。</p>\n\n<p>返回数组 <code>answer</code> ，其中<code>answer.length == queries.length</code> 。如果第 <code>i</code> 个查询中指向的城市 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 连通，则 <code>answer[i]</code> 为 <code>true</code> ；如果不连通，则 <code>answer[i]</code> 为 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/18/ex1.jpg\" style=\"width: 382px; height: 181px;\" /></p>\n\n<p> </p>\n\n<pre>\n<strong>输入：</strong>n = 6, threshold = 2, queries = [[1,4],[2,5],[3,6]]\n<strong>输出：</strong>[false,false,true]\n<strong>解释：</strong>每个数的因数如下：\n1:   1\n2:   1, 2\n3:   1, <strong>3</strong>\n4:   1, 2, <strong>4</strong>\n5:   1, <strong>5</strong>\n6:   1, 2, <strong>3</strong>, <strong>6</strong>\n所有大于阈值的的因数已经加粗标识，只有城市 3 和 6 共享公约数 3 ，因此结果是： \n[1,4]   1 与 4 不连通\n[2,5]   2 与 5 不连通\n[3,6]   3 与 6 连通，存在路径 3--6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/18/tmp.jpg\" style=\"width: 532px; height: 302px;\" /></p>\n\n<p> </p>\n\n<pre>\n<strong>输入：</strong>n = 6, threshold = 0, queries = [[4,5],[3,4],[3,2],[2,6],[1,3]]\n<strong>输出：</strong>[true,true,true,true,true]\n<strong>解释：</strong>每个数的因数与上一个例子相同。但是，由于阈值为 0 ，所有的因数都大于阈值。因为所有的数字共享公因数 1 ，所以所有的城市都互相连通。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/16/ex3.jpg\" style=\"width: 282px; height: 282px;\" /></p>\n\n<p> </p>\n\n<pre>\n<strong>输入：</strong>n = 5, threshold = 1, queries = [[4,5],[4,5],[3,2],[2,3],[3,4]]\n<strong>输出：</strong>[false,false,false,false,false]\n<strong>解释：</strong>只有城市 2 和 4 共享的公约数 2 严格大于阈值 1 ，所以只有这两座城市是连通的。\n注意，同一对节点 [x, y] 可以有多个查询，并且查询 [x，y] 等同于查询 [y，x] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 10<sup>4</sup></code></li>\n\t<li><code>0 <= threshold <= n</code></li>\n\t<li><code>1 <= queries.length <= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>1 <= a<sub>i</sub>, b<sub>i</sub> <= cities</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1628.设计带解析函数的表达式树",
        "hardRate": "MEDIUM",
        "passRate": "82.46%",
        "problemsUrl": "https://leetcode.cn/problems/design-an-expression-tree-with-evaluate-function/",
        "solutionsUrl": "https://leetcode.cn/problems/design-an-expression-tree-with-evaluate-function/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1629.按键持续时间最长的键",
        "hardRate": "EASY",
        "passRate": "55.86%",
        "problemsUrl": "https://leetcode.cn/problems/slowest-key/",
        "solutionsUrl": "https://leetcode.cn/problems/slowest-key/solution",
        "problemsDesc": "<p>LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 <code>n</code> 个），每次一个。</p>\n\n<p>给你一个长度为 <code>n</code> 的字符串 <code>keysPressed</code> ，其中 <code>keysPressed[i]</code> 表示测试序列中第 <code>i</code> 个被按下的键。<code>releaseTimes</code> 是一个升序排列的列表，其中 <code>releaseTimes[i]</code> 表示松开第 <code>i</code> 个键的时间。字符串和数组的 <strong>下标都从 0 开始</strong> 。第 <code>0</code> 个键在时间为 <code>0</code> 时被按下，接下来每个键都 <strong>恰好</strong> 在前一个键松开时被按下。</p>\n\n<p>测试人员想要找出按键 <strong>持续时间最长</strong> 的键。第 <code>i</code><sup> </sup>次按键的持续时间为 <code>releaseTimes[i] - releaseTimes[i - 1]</code> ，第 <code>0</code> 次按键的持续时间为 <code>releaseTimes[0]</code> 。</p>\n\n<p>注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。</p>\n\n<p>请返回单次按键 <strong>持续时间最长</strong> 的键，如果有多个这样的键，则返回 <strong>按字母顺序排列最大</strong> 的那个键。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>releaseTimes = [9,29,49,50], keysPressed = \"cbcd\"\n<strong>输出：</strong>\"c\"\n<strong>解释：</strong>按键顺序和持续时间如下：\n按下 'c' ，持续时间 9（时间 0 按下，时间 9 松开）\n按下 'b' ，持续时间 29 - 9 = 20（松开上一个键的时间 9 按下，时间 29 松开）\n按下 'c' ，持续时间 49 - 29 = 20（松开上一个键的时间 29 按下，时间 49 松开）\n按下 'd' ，持续时间 50 - 49 = 1（松开上一个键的时间 49 按下，时间 50 松开）\n按键持续时间最长的键是 'b' 和 'c'（第二次按下时），持续时间都是 20\n'c' 按字母顺序排列比 'b' 大，所以答案是 'c'\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>releaseTimes = [12,23,36,46,62], keysPressed = \"spuda\"\n<strong>输出：</strong>\"a\"\n<strong>解释：</strong>按键顺序和持续时间如下：\n按下 's' ，持续时间 12\n按下 'p' ，持续时间 23 - 12 = 11\n按下 'u' ，持续时间 36 - 23 = 13\n按下 'd' ，持续时间 46 - 36 = 10\n按下 'a' ，持续时间 62 - 46 = 16\n按键持续时间最长的键是 'a' ，持续时间 16</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>releaseTimes.length == n</code></li>\n\t<li><code>keysPressed.length == n</code></li>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= releaseTimes[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>releaseTimes[i] &lt; releaseTimes[i+1]</code></li>\n\t<li><code>keysPressed</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1630.等差子数组",
        "hardRate": "MEDIUM",
        "passRate": "76.15%",
        "problemsUrl": "https://leetcode.cn/problems/arithmetic-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/arithmetic-subarrays/solution",
        "problemsDesc": "<p>如果一个数列由至少两个元素组成，且每两个连续元素之间的差值都相同，那么这个序列就是 <strong>等差数列</strong> 。更正式地，数列 <code>s</code> 是等差数列，只需要满足：对于每个有效的 <code>i</code> ， <code>s[i+1] - s[i] == s[1] - s[0]</code> 都成立。</p>\n\n<p>例如，下面这些都是 <strong>等差数列</strong> ：</p>\n\n<pre>1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9</pre>\n\n<p>下面的数列 <strong>不是等差数列</strong> ：</p>\n\n<pre>1, 1, 2, 5, 7</pre>\n\n<p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code>，和两个由 <code>m</code> 个整数组成的数组 <code>l</code> 和 <code>r</code>，后两个数组表示 <code>m</code> 组范围查询，其中第 <code>i</code> 个查询对应范围 <code>[l[i], r[i]]</code> 。所有数组的下标都是 <strong>从 0 开始</strong> 的。</p>\n\n<p>返回<em> </em><code>boolean</code> 元素构成的答案列表 <code>answer</code> 。如果子数组 <code>nums[l[i]], nums[l[i]+1], ... , nums[r[i]]</code> 可以 <strong>重新排列</strong> 形成 <strong>等差数列</strong> ，<code>answer[i]</code> 的值就是 <code>true</code>；否则<code>answer[i]</code> 的值就是 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = <code>[4,6,5,9,3,7]</code>, l = <code>[0,0,2]</code>, r = <code>[2,3,5]</code>\n<strong>输出：</strong><code>[true,false,true]</code>\n<strong>解释：</strong>\n第 0 个查询，对应子数组 [4,6,5] 。可以重新排列为等差数列 [6,5,4] 。\n第 1 个查询，对应子数组 [4,6,5,9] 。无法重新排列形成等差数列。\n第 2 个查询，对应子数组 <code>[5,9,3,7] 。</code>可以重新排列为等差数列 <code>[3,5,7,9] 。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]\n<strong>输出：</strong>[false,true,false,false,true,true]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>m == l.length</code></li>\n\t<li><code>m == r.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= m &lt;= 500</code></li>\n\t<li><code>0 &lt;= l[i] &lt; r[i] &lt; n</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1631.最小体力消耗路径",
        "hardRate": "MEDIUM",
        "passRate": "50.93%",
        "problemsUrl": "https://leetcode.cn/problems/path-with-minimum-effort/",
        "solutionsUrl": "https://leetcode.cn/problems/path-with-minimum-effort/solution",
        "problemsDesc": "<p>你准备参加一场远足活动。给你一个二维 <code>rows x columns</code> 的地图 <code>heights</code> ，其中 <code>heights[row][col]</code> 表示格子 <code>(row, col)</code> 的高度。一开始你在最左上角的格子 <code>(0, 0)</code> ，且你希望去最右下角的格子 <code>(rows-1, columns-1)</code> （注意下标从 <strong>0</strong> 开始编号）。你每次可以往 <strong>上</strong>，<strong>下</strong>，<strong>左</strong>，<strong>右</strong> 四个方向之一移动，你想要找到耗费 <strong>体力</strong> 最小的一条路径。</p>\n\n<p>一条路径耗费的 <strong>体力值</strong> 是路径上相邻格子之间 <strong>高度差绝对值</strong> 的 <strong>最大值</strong> 决定的。</p>\n\n<p>请你返回从左上角走到右下角的最小<strong> 体力消耗值</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex1.png\" style=\"width: 300px; height: 300px;\" /></p>\n\n<pre>\n<b>输入：</b>heights = [[1,2,2],[3,8,2],[5,3,5]]\n<b>输出：</b>2\n<b>解释：</b>路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。\n这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex2.png\" style=\"width: 300px; height: 300px;\" /></p>\n\n<pre>\n<b>输入：</b>heights = [[1,2,3],[3,8,4],[5,3,5]]\n<b>输出：</b>1\n<b>解释：</b>路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex3.png\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<b>输入：</b>heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]\n<b>输出：</b>0\n<b>解释：</b>上图所示路径不需要消耗任何体力。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rows == heights.length</code></li>\n\t<li><code>columns == heights[i].length</code></li>\n\t<li><code>1 <= rows, columns <= 100</code></li>\n\t<li><code>1 <= heights[i][j] <= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1632.矩阵转换后的秩",
        "hardRate": "HARD",
        "passRate": "57.47%",
        "problemsUrl": "https://leetcode.cn/problems/rank-transform-of-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/rank-transform-of-a-matrix/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> ，请你返回一个新的矩阵<em> </em><code>answer</code> ，其中<em> </em><code>answer[row][col]</code> 是 <code>matrix[row][col]</code> 的秩。</p>\n\n<p>每个元素的 <b>秩</b> 是一个整数，表示这个元素相对于其他元素的大小关系，它按照如下规则计算：</p>\n\n<ul>\n\t<li>秩是从 1 开始的一个整数。</li>\n\t<li>如果两个元素 <code>p</code> 和 <code>q</code> 在 <strong>同一行</strong> 或者 <strong>同一列</strong> ，那么：\n\t<ul>\n\t\t<li>如果 <code>p < q</code> ，那么 <code>rank(p) < rank(q)</code></li>\n\t\t<li>如果 <code>p == q</code> ，那么 <code>rank(p) == rank(q)</code></li>\n\t\t<li>如果 <code>p > q</code> ，那么 <code>rank(p) > rank(q)</code></li>\n\t</ul>\n\t</li>\n\t<li><b>秩</b> 需要越 <strong>小</strong> 越好。</li>\n</ul>\n\n<p>题目保证按照上面规则 <code>answer</code> 数组是唯一的。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank1.jpg\" style=\"width: 442px; height: 162px;\" />\n<pre>\n<b>输入：</b>matrix = [[1,2],[3,4]]\n<b>输出：</b>[[1,2],[2,3]]\n<strong>解释：</strong>\nmatrix[0][0] 的秩为 1 ，因为它是所在行和列的最小整数。\nmatrix[0][1] 的秩为 2 ，因为 matrix[0][1] > matrix[0][0] 且 matrix[0][0] 的秩为 1 。\nmatrix[1][0] 的秩为 2 ，因为 matrix[1][0] > matrix[0][0] 且 matrix[0][0] 的秩为 1 。\nmatrix[1][1] 的秩为 3 ，因为 matrix[1][1] > matrix[0][1]， matrix[1][1] > matrix[1][0] 且 matrix[0][1] 和 matrix[1][0] 的秩都为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank2.jpg\" style=\"width: 442px; height: 162px;\" />\n<pre>\n<b>输入：</b>matrix = [[7,7],[7,7]]\n<b>输出：</b>[[1,1],[1,1]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank3.jpg\" style=\"width: 601px; height: 322px;\" />\n<pre>\n<b>输入：</b>matrix = [[20,-21,14],[-19,4,19],[22,-47,24],[-19,4,19]]\n<b>输出：</b>[[4,2,3],[1,3,4],[5,1,6],[1,3,4]]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/rank4.jpg\" style=\"width: 601px; height: 242px;\" />\n<pre>\n<b>输入：</b>matrix = [[7,3,6],[1,4,5],[9,8,2]]\n<b>输出：</b>[[5,1,4],[1,2,3],[6,3,1]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 <= m, n <= 500</code></li>\n\t<li><code>-10<sup>9</sup> <= matrix[row][col] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1633.各赛事的用户注册率",
        "hardRate": "EASY",
        "passRate": "62.61%",
        "problemsUrl": "https://leetcode.cn/problems/percentage-of-users-attended-a-contest/",
        "solutionsUrl": "https://leetcode.cn/problems/percentage-of-users-attended-a-contest/solution",
        "problemsDesc": "<p>用户表：&nbsp;<code>Users</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| user_id     | int     |\n| user_name   | varchar |\n+-------------+---------+\nuser_id 是该表的主键。\n该表中的每行包括用户 ID 和用户名。</pre>\n\n<p>&nbsp;</p>\n\n<p>注册表：&nbsp;<code>Register</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| contest_id  | int     |\n| user_id     | int     |\n+-------------+---------+\n(contest_id, user_id) 是该表的主键。\n该表中的每行包含用户的 ID 和他们注册的赛事。</pre>\n\n<p>&nbsp;</p>\n\n<p>写一条 SQL 语句，查询各赛事的用户注册百分率，保留两位小数。</p>\n\n<p>返回的结果表按&nbsp;<code>percentage</code>&nbsp;的&nbsp;<strong>降序&nbsp;</strong>排序，若相同则按&nbsp;<code>contest_id</code>&nbsp;的&nbsp;<strong>升序&nbsp;</strong>排序。</p>\n\n<p>查询结果如下示例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<code><strong>输入：</strong>\nUsers</code> 表：\n+---------+-----------+\n| user_id | user_name |\n+---------+-----------+\n| 6       | Alice     |\n| 2       | Bob       |\n| 7       | Alex      |\n+---------+-----------+\n\n<code>Register</code> 表：\n+------------+---------+\n| contest_id | user_id |\n+------------+---------+\n| 215        | 6       |\n| 209        | 2       |\n| 208        | 2       |\n| 210        | 6       |\n| 208        | 6       |\n| 209        | 7       |\n| 209        | 6       |\n| 215        | 7       |\n| 208        | 7       |\n| 210        | 2       |\n| 207        | 2       |\n| 210        | 7       |\n+------------+---------+\n<strong>输出：</strong>\n+------------+------------+\n| contest_id | percentage |\n+------------+------------+\n| 208        | 100.0      |\n| 209        | 100.0      |\n| 210        | 100.0      |\n| 215        | 66.67      |\n| 207        | 33.33      |\n+------------+------------+\n<strong>解释：</strong>\n所有用户都注册了 208、209 和 210 赛事，因此这些赛事的注册率为 100% ，我们按 contest_id 的降序排序加入结果表中。\nAlice 和 Alex 注册了 215 赛事，注册率为 ((2/3) * 100) = 66.67%\nBob 注册了 207 赛事，注册率为 ((1/3) * 100) = 33.33%</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1634.求两个多项式链表的和",
        "hardRate": "MEDIUM",
        "passRate": "60.16%",
        "problemsUrl": "https://leetcode.cn/problems/add-two-polynomials-represented-as-linked-lists/",
        "solutionsUrl": "https://leetcode.cn/problems/add-two-polynomials-represented-as-linked-lists/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1635.Hopper 公司查询 I",
        "hardRate": "HARD",
        "passRate": "49.28%",
        "problemsUrl": "https://leetcode.cn/problems/hopper-company-queries-i/",
        "solutionsUrl": "https://leetcode.cn/problems/hopper-company-queries-i/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1636.按照频率将数组升序排序",
        "hardRate": "EASY",
        "passRate": "74.74%",
        "problemsUrl": "https://leetcode.cn/problems/sort-array-by-increasing-frequency/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-array-by-increasing-frequency/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，请你将数组按照每个值的频率 <strong>升序</strong> 排序。如果有多个值的频率相同，请你按照数值本身将它们 <strong>降序</strong> 排序。 </p>\n\n<p>请你返回排序后的数组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,1,2,2,2,3]\n<b>输出：</b>[3,1,1,2,2,2]\n<b>解释：</b>'3' 频率为 1，'1' 频率为 2，'2' 频率为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,3,1,3,2]\n<b>输出：</b>[1,3,3,2,2]\n<b>解释：</b>'2' 和 '3' 频率都为 2 ，所以它们之间按照数值本身降序排序。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [-1,1,-6,4,5,-6,1,4,1]\n<b>输出：</b>[5,-1,4,4,-6,-6,1,1,1]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1637.两点之间不包含任何点的最宽垂直区域",
        "hardRate": "MEDIUM",
        "passRate": "84.34%",
        "problemsUrl": "https://leetcode.cn/problems/widest-vertical-area-between-two-points-containing-no-points/",
        "solutionsUrl": "https://leetcode.cn/problems/widest-vertical-area-between-two-points-containing-no-points/solution",
        "problemsDesc": "<p>给你&nbsp;<code>n</code>&nbsp;个二维平面上的点 <code>points</code> ，其中&nbsp;<code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;，请你返回两点之间内部不包含任何点的&nbsp;<strong>最宽垂直区域</strong> 的宽度。</p>\n\n<p><strong>垂直区域</strong> 的定义是固定宽度，而 y 轴上无限延伸的一块区域（也就是高度为无穷大）。 <strong>最宽垂直区域</strong> 为宽度最大的一个垂直区域。</p>\n\n<p>请注意，垂直区域&nbsp;<strong>边上</strong>&nbsp;的点&nbsp;<strong>不在</strong>&nbsp;区域内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/31/points3.png\" style=\"width: 276px; height: 371px;\" />​\n<pre>\n<b>输入：</b>points = [[8,7],[9,9],[7,4],[9,7]]\n<b>输出：</b>1\n<b>解释：</b>红色区域和蓝色区域都是最优区域。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]\n<b>输出：</b>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == points.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1638.统计只差一个字符的子串数目",
        "hardRate": "MEDIUM",
        "passRate": "77.61%",
        "problemsUrl": "https://leetcode.cn/problems/count-substrings-that-differ-by-one-character/",
        "solutionsUrl": "https://leetcode.cn/problems/count-substrings-that-differ-by-one-character/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>s</code> 和&nbsp;<code>t</code>&nbsp;，请你找出 <code>s</code>&nbsp;中的非空子串的数目，这些子串满足替换 <strong>一个不同字符</strong>&nbsp;以后，是 <code>t</code>&nbsp;串的子串。换言之，请你找到 <code>s</code>&nbsp;和 <code>t</code>&nbsp;串中 <strong>恰好</strong>&nbsp;只有一个字符不同的子字符串对的数目。</p>\n\n<p>比方说，&nbsp;<code>\"<u>compute</u>r\"</code>&nbsp;and&nbsp;<code>\"<u>computa</u>tion\"&nbsp;</code>只有一个字符不同：&nbsp;<code>'e'</code>/<code>'a'</code>&nbsp;，所以这一对子字符串会给答案加 1 。</p>\n\n<p>请你返回满足上述条件的不同子字符串对数目。</p>\n\n<p>一个 <strong>子字符串</strong>&nbsp;是一个字符串中连续的字符。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aba\", t = \"baba\"\n<b>输出：</b>6\n<strong>解释：</strong>以下为只相差 1 个字符的 s 和 t 串的子字符串对：\n(\"<strong>a</strong>ba\", \"<strong>b</strong>aba\")\n(\"<strong>a</strong>ba\", \"ba<strong>b</strong>a\")\n(\"ab<strong>a</strong>\", \"<strong>b</strong>aba\")\n(\"ab<strong>a</strong>\", \"ba<strong>b</strong>a\")\n(\"a<strong>b</strong>a\", \"b<strong>a</strong>ba\")\n(\"a<strong>b</strong>a\", \"bab<strong>a</strong>\")\n加粗部分分别表示 s 和 t 串选出来的子字符串。\n</pre>\n<strong>示例 2：</strong>\n\n<pre>\n<b>输入：</b>s = \"ab\", t = \"bb\"\n<b>输出：</b>3\n<strong>解释：</strong>以下为只相差 1 个字符的 s 和 t 串的子字符串对：\n(\"<strong>a</strong>b\", \"<strong>b</strong>b\")\n(\"<strong>a</strong>b\", \"b<strong>b</strong>\")\n(\"<strong>ab</strong>\", \"<strong>bb</strong>\")\n加粗部分分别表示 s 和 t 串选出来的子字符串。\n</pre>\n<strong>示例 3：</strong>\n\n<pre>\n<b>输入：</b>s = \"a\", t = \"a\"\n<b>输出：</b>0\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"abe\", t = \"bbc\"\n<b>输出：</b>10\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 100</code></li>\n\t<li><code>s</code> 和&nbsp;<code>t</code>&nbsp;都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1639.通过给定词典构造目标字符串的方案数",
        "hardRate": "HARD",
        "passRate": "46.96%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solution",
        "problemsDesc": "<p>给你一个字符串列表 <code>words</code> 和一个目标字符串 <code>target</code> 。<code>words</code> 中所有字符串都 <strong>长度相同</strong>  。</p>\n\n<p>你的目标是使用给定的 <code>words</code> 字符串列表按照下述规则构造 <code>target</code> ：</p>\n\n<ul>\n\t<li>从左到右依次构造 <code>target</code> 的每一个字符。</li>\n\t<li>为了得到 <code>target</code> 第 <code>i</code> 个字符（下标从 <strong>0</strong> 开始），当 <code>target[i] = words[j][k]</code> 时，你可以使用 <code>words</code> 列表中第 <code>j</code> 个字符串的第 <code>k</code> 个字符。</li>\n\t<li>一旦你使用了 <code>words</code> 中第 <code>j</code> 个字符串的第 <code>k</code> 个字符，你不能再使用 <code>words</code> 字符串列表中任意单词的第 <code>x</code> 个字符（<code>x <= k</code>）。也就是说，所有单词下标小于等于 <code>k</code> 的字符都不能再被使用。</li>\n\t<li>请你重复此过程直到得到目标字符串 <code>target</code> 。</li>\n</ul>\n\n<p><strong>请注意</strong>， 在构造目标字符串的过程中，你可以按照上述规定使用 <code>words</code> 列表中 <strong>同一个字符串</strong> 的 <strong>多个字符</strong> 。</p>\n\n<p>请你返回使用 <code>words</code> 构造 <code>target</code> 的方案数。由于答案可能会很大，请对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后返回。</p>\n\n<p>（译者注：此题目求的是有多少个不同的 <code>k</code> 序列，详情请见示例。）</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"acca\",\"bbbb\",\"caca\"], target = \"aba\"\n<b>输出：</b>6\n<b>解释：</b>总共有 6 种方法构造目标串。\n\"aba\" -> 下标为 0 (\"<strong>a</strong>cca\")，下标为 1 (\"b<strong>b</strong>bb\")，下标为 3 (\"cac<strong>a</strong>\")\n\"aba\" -> 下标为 0 (\"<strong>a</strong>cca\")，下标为 2 (\"bb<strong>b</strong>b\")，下标为 3 (\"cac<strong>a</strong>\")\n\"aba\" -> 下标为 0 (\"<strong>a</strong>cca\")，下标为 1 (\"b<strong>b</strong>bb\")，下标为 3 (\"acc<strong>a</strong>\")\n\"aba\" -> 下标为 0 (\"<strong>a</strong>cca\")，下标为 2 (\"bb<strong>b</strong>b\")，下标为 3 (\"acc<strong>a</strong>\")\n\"aba\" -> 下标为 1 (\"c<strong>a</strong>ca\")，下标为 2 (\"bb<strong>b</strong>b\")，下标为 3 (\"acc<strong>a</strong>\")\n\"aba\" -> 下标为 1 (\"c<strong>a</strong>ca\")，下标为 2 (\"bb<strong>b</strong>b\")，下标为 3 (\"cac<strong>a</strong>\")\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"abba\",\"baab\"], target = \"bab\"\n<b>输出：</b>4\n<b>解释：</b>总共有 4 种不同形成 target 的方法。\n\"bab\" -> 下标为 0 (\"<strong>b</strong>aab\")，下标为 1 (\"b<strong>a</strong>ab\")，下标为 2 (\"ab<strong>b</strong>a\")\n\"bab\" -> 下标为 0 (\"<strong>b</strong>aab\")，下标为 1 (\"b<strong>a</strong>ab\")，下标为 3 (\"baa<strong>b</strong>\")\n\"bab\" -> 下标为 0 (\"<strong>b</strong>aab\")，下标为 2 (\"ba<strong>a</strong>b\")，下标为 3 (\"baa<strong>b</strong>\")\n\"bab\" -> 下标为 1 (\"a<strong>b</strong>ba\")，下标为 2 (\"ba<strong>a</strong>b\")，下标为 3 (\"baa<strong>b</strong>\")\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"abcd\"], target = \"abcd\"\n<b>输出：</b>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"abab\",\"baba\",\"abba\",\"baab\"], target = \"abba\"\n<b>输出：</b>16\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= words.length <= 1000</code></li>\n\t<li><code>1 <= words[i].length <= 1000</code></li>\n\t<li><code>words</code> 中所有单词长度相同。</li>\n\t<li><code>1 <= target.length <= 1000</code></li>\n\t<li><code>words[i]</code> 和 <code>target</code> 都仅包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1640.能否连接形成数组",
        "hardRate": "EASY",
        "passRate": "60.95%",
        "problemsUrl": "https://leetcode.cn/problems/check-array-formation-through-concatenation/",
        "solutionsUrl": "https://leetcode.cn/problems/check-array-formation-through-concatenation/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> ，数组中的每个整数 <strong>互不相同</strong> 。另有一个由整数数组构成的数组 <code>pieces</code>，其中的整数也 <strong>互不相同</strong> 。请你以 <strong>任意顺序</strong> 连接 <code>pieces</code> 中的数组以形成 <code>arr</code> 。但是，<strong>不允许</strong> 对每个数组 <code>pieces[i]</code> 中的整数重新排序。</p>\n\n<p>如果可以连接<em> </em><code>pieces</code> 中的数组形成 <code>arr</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [15,88], pieces = [[88],[15]]\n<strong>输出：</strong>true\n<strong>解释：</strong>依次连接 <code>[15]</code> 和 <code>[88]</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [49,18,16], pieces = [[16,18,49]]\n<strong>输出：</strong>false\n<strong>解释：</strong>即便数字相符，也不能重新排列 pieces[0]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [91,4,64,78], pieces = [[78],[4,64],[91]]\n<strong>输出：</strong>true\n<strong>解释：</strong>依次连接 <code>[91]</code>、<code>[4,64]</code> 和 <code>[78]</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pieces.length &lt;= arr.length &lt;= 100</code></li>\n\t<li><code>sum(pieces[i].length) == arr.length</code></li>\n\t<li><code>1 &lt;= pieces[i].length &lt;= arr.length</code></li>\n\t<li><code>1 &lt;= arr[i], pieces[i][j] &lt;= 100</code></li>\n\t<li><code>arr</code> 中的整数 <strong>互不相同</strong></li>\n\t<li><code>pieces</code> 中的整数 <strong>互不相同</strong>（也就是说，如果将 <code>pieces</code> 扁平化成一维数组，数组中的所有整数互不相同）</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1641.统计字典序元音字符串的数目",
        "hardRate": "MEDIUM",
        "passRate": "82.37%",
        "problemsUrl": "https://leetcode.cn/problems/count-sorted-vowel-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/count-sorted-vowel-strings/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code>，请返回长度为 <code>n</code> 、仅由元音 (<code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>) 组成且按 <strong>字典序排列</strong> 的字符串数量。</p>\n\n<p>字符串 <code>s</code> 按 <strong>字典序排列</strong> 需要满足：对于所有有效的 <code>i</code>，<code>s[i]</code> 在字母表中的位置总是与 <code>s[i+1]</code> 相同或在 <code>s[i+1]</code> 之前。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>5\n<strong>解释：</strong>仅由元音组成的 5 个字典序字符串为 <code>[\"a\",\"e\",\"i\",\"o\",\"u\"]</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>15\n<strong>解释：</strong>仅由元音组成的 15 个字典序字符串为\n[\"aa\",\"ae\",\"ai\",\"ao\",\"au\",\"ee\",\"ei\",\"eo\",\"eu\",\"ii\",\"io\",\"iu\",\"oo\",\"ou\",\"uu\"]\n注意，\"ea\" 不是符合题意的字符串，因为 'e' 在字母表中的位置比 'a' 靠后\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 33\n<strong>输出：</strong>66045\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 50</code> </li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1642.可以到达的最远建筑",
        "hardRate": "MEDIUM",
        "passRate": "45.33%",
        "problemsUrl": "https://leetcode.cn/problems/furthest-building-you-can-reach/",
        "solutionsUrl": "https://leetcode.cn/problems/furthest-building-you-can-reach/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>heights</code> ，表示建筑物的高度。另有一些砖块 <code>bricks</code> 和梯子 <code>ladders</code> 。</p>\n\n<p>你从建筑物 <code>0</code> 开始旅程，不断向后面的建筑物移动，期间可能会用到砖块或梯子。</p>\n\n<p>当从建筑物 <code>i</code> 移动到建筑物 <code>i+1</code>（下标<strong> 从 0 开始 </strong>）时：</p>\n\n<ul>\n\t<li>如果当前建筑物的高度 <strong>大于或等于</strong> 下一建筑物的高度，则不需要梯子或砖块</li>\n\t<li>如果当前建筑的高度 <strong>小于</strong> 下一个建筑的高度，您可以使用 <strong>一架梯子</strong> 或 <strong><code>(h[i+1] - h[i])</code> 个砖块</strong></li>\n</ul>\n如果以最佳方式使用给定的梯子和砖块，返回你可以到达的最远建筑物的下标（下标<strong> 从 0 开始 </strong>）。\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/31/q4.gif\" style=\"width: 562px; height: 561px;\" />\n<pre>\n<strong>输入：</strong>heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1\n<strong>输出：</strong>4\n<strong>解释：</strong>从建筑物 0 出发，你可以按此方案完成旅程：\n- 不使用砖块或梯子到达建筑物 1 ，因为 4 >= 2\n- 使用 5 个砖块到达建筑物 2 。你必须使用砖块或梯子，因为 2 < 7\n- 不使用砖块或梯子到达建筑物 3 ，因为 7 >= 6\n- 使用唯一的梯子到达建筑物 4 。你必须使用砖块或梯子，因为 6 < 9\n无法越过建筑物 4 ，因为没有更多砖块或梯子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2\n<strong>输出：</strong>7\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>heights = [14,3,19,3], bricks = 17, ladders = 0\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= heights.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= heights[i] <= 10<sup>6</sup></code></li>\n\t<li><code>0 <= bricks <= 10<sup>9</sup></code></li>\n\t<li><code>0 <= ladders <= heights.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1643.第 K 条最小指令",
        "hardRate": "HARD",
        "passRate": "48.09%",
        "problemsUrl": "https://leetcode.cn/problems/kth-smallest-instructions/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-smallest-instructions/solution",
        "problemsDesc": "<p>Bob 站在单元格 <code>(0, 0)</code> ，想要前往目的地 <code>destination</code> ：<code>(row, column)</code> 。他只能向 <strong>右</strong> 或向 <strong>下</strong> 走。你可以为 Bob 提供导航 <strong>指令</strong> 来帮助他到达目的地 <code>destination</code> 。</p>\n\n<p><strong>指令</strong> 用字符串表示，其中每个字符：</p>\n\n<ul>\n\t<li><code>'H'</code> ，意味着水平向右移动</li>\n\t<li><code>'V'</code> ，意味着竖直向下移动</li>\n</ul>\n\n<p>能够为 Bob 导航到目的地 <code>destination</code> 的指令可以有多种，例如，如果目的地 <code>destination</code> 是 <code>(2, 3)</code>，<code>\"HHHVV\"</code> 和 <code>\"HVHVH\"</code> 都是有效<strong> 指令</strong> 。</p>\n\n<ul>\n</ul>\n\n<p>然而，Bob 很挑剔。因为他的幸运数字是 <code>k</code>，他想要遵循 <strong>按字典序排列后的第 <code>k</code> 条最小指令 </strong>的导航前往目的地 <code>destination</code> 。<code>k</code>  的编号 <strong>从 1 开始</strong> 。</p>\n\n<p>给你一个整数数组 <code>destination</code> 和一个整数 <code>k</code> ，请你返回可以为<em> </em>Bob<em> </em>提供前往目的地 <code>destination</code> 导航的<strong> 按字典序排列后的第 <code>k</code> 条最小指令 </strong>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/01/ex1.png\" style=\"width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>destination = [2,3], k = 1\n<strong>输出：</strong>\"HHHVV\"\n<strong>解释：</strong>能前往 (2, 3) 的所有导航指令 <strong>按字典序排列后</strong> 如下所示：\n[\"HHHVV\", \"HHVHV\", \"HHVVH\", \"HVHHV\", \"HVHVH\", \"HVVHH\", \"VHHHV\", \"VHHVH\", \"VHVHH\", \"VVHHH\"].\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/01/ex2.png\" style=\"width: 300px; height: 229px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>destination = [2,3], k = 2\n<strong>输出：</strong>\"HHVHV\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/01/ex3.png\" style=\"width: 300px; height: 229px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>destination = [2,3], k = 3\n<strong>输出：</strong>\"HHVVH\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>destination.length == 2</code></li>\n\t<li><code>1 <= row, column <= 15</code></li>\n\t<li><code>1 <= k <= nCr(row + column, row)</code>，其中 <code>nCr(a, b)</code> 表示组合数，即从 <code>a</code> 个物品中选 <code>b</code> 个物品的不同方案数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1644.二叉树的最近公共祖先 II",
        "hardRate": "MEDIUM",
        "passRate": "56.13%",
        "problemsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1645.1645.Hopper 公司查询 II",
        "hardRate": "HARD",
        "passRate": "41.79%",
        "problemsUrl": "https://leetcode.cn/problems/hopper-company-queries-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/hopper-company-queries-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1646.获取生成数组中的最大值",
        "hardRate": "EASY",
        "passRate": "51.85%",
        "problemsUrl": "https://leetcode.cn/problems/get-maximum-in-generated-array/",
        "solutionsUrl": "https://leetcode.cn/problems/get-maximum-in-generated-array/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> 。按下述规则生成一个长度为 <code>n + 1</code> 的数组 <code>nums</code> ：</p>\n\n<ul>\n\t<li><code>nums[0] = 0</code></li>\n\t<li><code>nums[1] = 1</code></li>\n\t<li>当 <code>2 <= 2 * i <= n</code> 时，<code>nums[2 * i] = nums[i]</code></li>\n\t<li>当 <code>2 <= 2 * i + 1 <= n</code> 时，<code>nums[2 * i + 1] = nums[i] + nums[i + 1]</code></li>\n</ul>\n\n<p>返回生成数组 <code>nums</code> 中的 <strong>最大</strong> 值。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 7\n<strong>输出：</strong>3\n<strong>解释：</strong>根据规则：\n  nums[0] = 0\n  nums[1] = 1\n  nums[(1 * 2) = 2] = nums[1] = 1\n  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n  nums[(2 * 2) = 4] = nums[2] = 1\n  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n  nums[(3 * 2) = 6] = nums[3] = 2\n  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\n因此，nums = [0,1,1,2,1,3,2,3]，最大值 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>根据规则，nums[0]、nums[1] 和 nums[2] 之中的最大值是 1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>根据规则，nums[0]、nums[1]、nums[2] 和 nums[3] 之中的最大值是 2\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= n <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1647.字符频次唯一的最小删除次数",
        "hardRate": "MEDIUM",
        "passRate": "54.53%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-character-frequencies-unique/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-character-frequencies-unique/solution",
        "problemsDesc": "<p>如果字符串 <code>s</code> 中 <strong>不存在</strong> 两个不同字符 <strong>频次</strong> 相同的情况，就称 <code>s</code> 是 <strong>优质字符串</strong> 。</p>\n\n<p>给你一个字符串 <code>s</code>，返回使 <code>s</code> 成为 <strong>优质字符串</strong> 需要删除的 <strong>最小</strong> 字符数。</p>\n\n<p>字符串中字符的 <strong>频次</strong> 是该字符在字符串中的出现次数。例如，在字符串 <code>\"aab\"</code> 中，<code>'a'</code> 的频次是 <code>2</code>，而 <code>'b'</code> 的频次是 <code>1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aab\"\n<strong>输出：</strong>0\n<strong>解释：</strong><code>s</code> 已经是优质字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aaabbbcc\"\n<strong>输出：</strong>2\n<strong>解释：</strong>可以删除两个 'b' , 得到优质字符串 \"aaabcc\" 。\n另一种方式是删除一个 'b' 和一个 'c' ，得到优质字符串 \"aaabbc\" 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ceabaacb\"\n<strong>输出：</strong>2\n<strong>解释：</strong>可以删除两个 'c' 得到优质字符串 \"eabaab\" 。\n注意，只需要关注结果字符串中仍然存在的字符。（即，频次为 0 的字符会忽略不计。）\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 仅含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1648.销售价值减少的颜色球",
        "hardRate": "MEDIUM",
        "passRate": "31.56%",
        "problemsUrl": "https://leetcode.cn/problems/sell-diminishing-valued-colored-balls/",
        "solutionsUrl": "https://leetcode.cn/problems/sell-diminishing-valued-colored-balls/solution",
        "problemsDesc": "<p>你有一些球的库存 <code>inventory</code> ，里面包含着不同颜色的球。一个顾客想要 <strong>任意颜色</strong> 总数为 <code>orders</code> 的球。</p>\n\n<p>这位顾客有一种特殊的方式衡量球的价值：每个球的价值是目前剩下的 <strong>同色球</strong> 的数目。比方说还剩下 <code>6</code> 个黄球，那么顾客买第一个黄球的时候该黄球的价值为 <code>6</code> 。这笔交易以后，只剩下 <code>5</code> 个黄球了，所以下一个黄球的价值为 <code>5</code> （也就是球的价值随着顾客购买同色球是递减的）</p>\n\n<p>给你整数数组 <code>inventory</code> ，其中 <code>inventory[i]</code> 表示第 <code>i</code> 种颜色球一开始的数目。同时给你整数 <code>orders</code> ，表示顾客总共想买的球数目。你可以按照 <strong>任意顺序</strong> 卖球。</p>\n\n<p>请你返回卖了 <code>orders</code> 个球以后 <strong>最大</strong> 总价值之和。由于答案可能会很大，请你返回答案对 <code>10<sup>9</sup> + 7</code> <strong>取余数</strong> 的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/08/jj.gif\" style=\"width: 480px; height: 270px;\" />\n<pre>\n<b>输入：</b>inventory = [2,5], orders = 4\n<b>输出：</b>14\n<b>解释：</b>卖 1 个第一种颜色的球（价值为 2 )，卖 3 个第二种颜色的球（价值为 5 + 4 + 3）。\n最大总和为 2 + 5 + 4 + 3 = 14 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>inventory = [3,5], orders = 6\n<b>输出：</b>19\n<strong>解释：</strong>卖 2 个第一种颜色的球（价值为 3 + 2），卖 4 个第二种颜色的球（价值为 5 + 4 + 3 + 2）。\n最大总和为 3 + 2 + 5 + 4 + 3 + 2 = 19 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>inventory = [2,8,4,10,6], orders = 20\n<b>输出：</b>110\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>inventory = [1000000000], orders = 1000000000\n<b>输出：</b>21\n<strong>解释：</strong>卖 1000000000 次第一种颜色的球，总价值为 500000000500000000 。 500000000500000000 对 10<sup>9 </sup>+ 7 取余为 21 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= inventory.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= inventory[i] <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= orders <= min(sum(inventory[i]), 10<sup>9</sup>)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1649.通过指令创建有序数组",
        "hardRate": "HARD",
        "passRate": "49.31%",
        "problemsUrl": "https://leetcode.cn/problems/create-sorted-array-through-instructions/",
        "solutionsUrl": "https://leetcode.cn/problems/create-sorted-array-through-instructions/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>instructions</code> ，你需要根据 <code>instructions</code> 中的元素创建一个有序数组。一开始你有一个空的数组 <code>nums</code> ，你需要 <strong>从左到右</strong> 遍历 <code>instructions</code> 中的元素，将它们依次插入 <code>nums</code> 数组中。每一次插入操作的 <strong>代价</strong> 是以下两者的 <strong>较小值</strong> ：</p>\n\n<ul>\n\t<li><code>nums</code> 中 <strong>严格小于 </strong> <code>instructions[i]</code> 的数字数目。</li>\n\t<li><code>nums</code> 中 <strong>严格大于 </strong> <code>instructions[i]</code> 的数字数目。</li>\n</ul>\n\n<p>比方说，如果要将 <code>3</code> 插入到 <code>nums = [1,2,3,5]</code> ，那么插入操作的 <strong>代价</strong> 为 <code>min(2, 1)</code> (元素 <code>1</code> 和  <code>2</code> 小于 <code>3</code> ，元素 <code>5</code> 大于 <code>3</code> ），插入后 <code>nums</code> 变成 <code>[1,2,3,3,5]</code> 。</p>\n\n<p>请你返回将 <code>instructions</code> 中所有元素依次插入 <code>nums</code> 后的 <strong>总最小代价 </strong>。由于答案会很大，请将它对 <code>10<sup>9</sup> + 7</code> <b>取余</b> 后返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>instructions = [1,5,6,2]\n<b>输出：</b>1\n<b>解释：</b>一开始 nums = [] 。\n插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。\n插入 5 ，代价为 min(1, 0) = 0 ，现在 nums = [1,5] 。\n插入 6 ，代价为 min(2, 0) = 0 ，现在 nums = [1,5,6] 。\n插入 2 ，代价为 min(1, 2) = 1 ，现在 nums = [1,2,5,6] 。\n总代价为 0 + 0 + 0 + 1 = 1 。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><b>输入：</b>instructions = [1,2,3,6,5,4]\n<b>输出：</b>3\n<b>解释：</b>一开始 nums = [] 。\n插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。\n插入 2 ，代价为 min(1, 0) = 0 ，现在 nums = [1,2] 。\n插入 3 ，代价为 min(2, 0) = 0 ，现在 nums = [1,2,3] 。\n插入 6 ，代价为 min(3, 0) = 0 ，现在 nums = [1,2,3,6] 。\n插入 5 ，代价为 min(3, 1) = 1 ，现在 nums = [1,2,3,5,6] 。\n插入 4 ，代价为 min(3, 2) = 2 ，现在 nums = [1,2,3,4,5,6] 。\n总代价为 0 + 0 + 0 + 0 + 1 + 2 = 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>instructions = [1,3,3,3,2,4,2,1,2]\n<b>输出：</b>4\n<b>解释：</b>一开始 nums = [] 。\n插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。\n插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3] 。\n插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3,3] 。\n插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3,3,3] 。\n插入 2 ，代价为 min(1, 3) = 1 ，现在 nums = [1,2,3,3,3] 。\n插入 4 ，代价为 min(5, 0) = 0 ，现在 nums = [1,2,3,3,3,4] 。\n​​​​​插入 2 ，代价为 min(1, 4) = 1 ，现在 nums = [1,2,2,3,3,3,4] 。\n插入 1 ，代价为 min(0, 6) = 0 ，现在 nums = [1,1,2,2,3,3,3,4] 。\n插入 2 ，代价为 min(2, 4) = 2 ，现在 nums = [1,1,2,2,2,3,3,3,4] 。\n总代价为 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 2 = 4 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= instructions.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= instructions[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1650.二叉树的最近公共祖先 III",
        "hardRate": "MEDIUM",
        "passRate": "80.01%",
        "problemsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    }
]