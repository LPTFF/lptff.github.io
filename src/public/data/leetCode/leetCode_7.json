[
    {
        "problemsName": " 1801.积压订单中的订单总数",
        "hardRate": "MEDIUM",
        "passRate": "53.23%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-orders-in-the-backlog/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-orders-in-the-backlog/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>orders</code> ，其中每个 <code>orders[i] = [price<sub>i</sub>, amount<sub>i</sub>, orderType<sub>i</sub>]</code> 表示有 <code>amount<sub>i</sub></code><sub> </sub>笔类型为 <code>orderType<sub>i</sub></code> 、价格为 <code>price<sub>i</sub></code> 的订单。</p>\n\n<p>订单类型 <code>orderType<sub>i</sub></code> 可以分为两种：</p>\n\n<ul>\n\t<li><code>0</code> 表示这是一批采购订单 <code>buy</code></li>\n\t<li><code>1</code> 表示这是一批销售订单 <code>sell</code></li>\n</ul>\n\n<p>注意，<code>orders[i]</code> 表示一批共计 <code>amount<sub>i</sub></code> 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 <code>i</code> ，由 <code>orders[i]</code> 表示的所有订单提交时间均早于 <code>orders[i+1]</code> 表示的所有订单。</p>\n\n<p>存在由未执行订单组成的 <strong>积压订单</strong> 。积压订单最初是空的。提交订单时，会发生以下情况：</p>\n\n<ul>\n\t<li>如果该订单是一笔采购订单 <code>buy</code> ，则可以查看积压订单中价格 <strong>最低</strong> 的销售订单 <code>sell</code> 。如果该销售订单 <code>sell</code> 的价格 <strong>低于或等于</strong> 当前采购订单 <code>buy</code> 的价格，则匹配并执行这两笔订单，并将销售订单 <code>sell</code> 从积压订单中删除。否则，采购订单 <code>buy</code> 将会添加到积压订单中。</li>\n\t<li>反之亦然，如果该订单是一笔销售订单 <code>sell</code> ，则可以查看积压订单中价格 <strong>最高</strong> 的采购订单 <code>buy</code> 。如果该采购订单 <code>buy</code> 的价格 <strong>高于或等于</strong> 当前销售订单 <code>sell</code> 的价格，则匹配并执行这两笔订单，并将采购订单 <code>buy</code> 从积压订单中删除。否则，销售订单 <code>sell</code> 将会添加到积压订单中。</li>\n</ul>\n\n<p>输入所有订单后，返回积压订单中的 <strong>订单总数</strong> 。由于数字可能很大，所以需要返回对 <code>10<sup>9</sup> + 7</code> 取余的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/21/ex1.png\" style=\"width: 450px; height: 479px;\" />\n<pre>\n<strong>输入：</strong>orders = [[10,5,0],[15,2,1],[25,1,1],[30,4,0]]\n<strong>输出：</strong>6\n<strong>解释：</strong>输入订单后会发生下述情况：\n- 提交 5 笔采购订单，价格为 10 。没有销售订单，所以这 5 笔订单添加到积压订单中。\n- 提交 2 笔销售订单，价格为 15 。没有采购订单的价格大于或等于 15 ，所以这 2 笔订单添加到积压订单中。\n- 提交 1 笔销售订单，价格为 25 。没有采购订单的价格大于或等于 25 ，所以这 1 笔订单添加到积压订单中。\n- 提交 4 笔采购订单，价格为 30 。前 2 笔采购订单与价格最低（价格为 15）的 2 笔销售订单匹配，从积压订单中删除这 2 笔销售订单。第 3 笔采购订单与价格最低的 1 笔销售订单匹配，销售订单价格为 25 ，从积压订单中删除这 1 笔销售订单。积压订单中不存在更多销售订单，所以第 4 笔采购订单需要添加到积压订单中。\n最终，积压订单中有 5 笔价格为 10 的采购订单，和 1 笔价格为 30 的采购订单。所以积压订单中的订单总数为 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/21/ex2.png\" style=\"width: 450px; height: 584px;\" />\n<pre>\n<strong>输入：</strong>orders = [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]]\n<strong>输出：</strong>999999984\n<strong>解释：</strong>输入订单后会发生下述情况：\n- 提交 10<sup>9</sup> 笔销售订单，价格为 7 。没有采购订单，所以这 10<sup>9</sup> 笔订单添加到积压订单中。\n- 提交 3 笔采购订单，价格为 15 。这些采购订单与价格最低（价格为 7 ）的 3 笔销售订单匹配，从积压订单中删除这 3 笔销售订单。\n- 提交 999999995 笔采购订单，价格为 5 。销售订单的最低价为 7 ，所以这 999999995 笔订单添加到积压订单中。\n- 提交 1 笔销售订单，价格为 5 。这笔销售订单与价格最高（价格为 5 ）的 1 笔采购订单匹配，从积压订单中删除这 1 笔采购订单。\n最终，积压订单中有 (1000000000-3) 笔价格为 7 的销售订单，和 (999999995-1) 笔价格为 5 的采购订单。所以积压订单中的订单总数为 1999999991 ，等于 999999984 % (10<sup>9</sup> + 7) 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= orders.length <= 10<sup>5</sup></code></li>\n\t<li><code>orders[i].length == 3</code></li>\n\t<li><code>1 <= price<sub>i</sub>, amount<sub>i</sub> <= 10<sup>9</sup></code></li>\n\t<li><code>orderType<sub>i</sub></code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1802.有界数组中指定下标处的最大值",
        "hardRate": "MEDIUM",
        "passRate": "38.08%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-value-at-a-given-index-in-a-bounded-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-value-at-a-given-index-in-a-bounded-array/solution",
        "problemsDesc": "<p>给你三个正整数 <code>n</code>、<code>index</code> 和 <code>maxSum</code> 。你需要构造一个同时满足下述所有条件的数组 <code>nums</code>（下标 <strong>从 0 开始</strong> 计数）：</p>\n\n<ul>\n\t<li><code>nums.length == n</code></li>\n\t<li><code>nums[i]</code> 是 <strong>正整数</strong> ，其中 <code>0 &lt;= i &lt; n</code></li>\n\t<li><code>abs(nums[i] - nums[i+1]) &lt;= 1</code> ，其中 <code>0 &lt;= i &lt; n-1</code></li>\n\t<li><code>nums</code> 中所有元素之和不超过 <code>maxSum</code></li>\n\t<li><code>nums[index]</code> 的值被 <strong>最大化</strong></li>\n</ul>\n\n<p>返回你所构造的数组中的 <code>nums[index]</code> 。</p>\n\n<p>注意：<code>abs(x)</code> 等于 <code>x</code> 的前提是 <code>x &gt;= 0</code> ；否则，<code>abs(x)</code> 等于 <code>-x</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 4, index = 2,  maxSum = 6\n<strong>输出：</strong>2\n<strong>解释：</strong>数组 [1,1,<strong>2</strong>,1] 和 [1,2,<strong>2</strong>,1] 满足所有条件。不存在其他在指定下标处具有更大值的有效数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 6, index = 1,  maxSum = 10\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= maxSum &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= index &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1803.统计异或值在范围内的数对有多少",
        "hardRate": "HARD",
        "passRate": "56.33%",
        "problemsUrl": "https://leetcode.cn/problems/count-pairs-with-xor-in-a-range/",
        "solutionsUrl": "https://leetcode.cn/problems/count-pairs-with-xor-in-a-range/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> （下标 <strong>从 0 开始</strong> 计数）以及两个整数：<code>low</code> 和 <code>high</code> ，请返回 <strong>漂亮数对</strong> 的数目。</p>\n\n<p><strong>漂亮数对</strong> 是一个形如 <code>(i, j)</code> 的数对，其中 <code>0 &lt;= i &lt; j &lt; nums.length</code> 且 <code>low &lt;= (nums[i] XOR nums[j]) &lt;= high</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,4,2,7], low = 2, high = 6\n<strong>输出：</strong>6\n<strong>解释：</strong>所有漂亮数对 (i, j) 列出如下：\n    - (0, 1): nums[0] XOR nums[1] = 5 \n    - (0, 2): nums[0] XOR nums[2] = 3\n    - (0, 3): nums[0] XOR nums[3] = 6\n    - (1, 2): nums[1] XOR nums[2] = 6\n    - (1, 3): nums[1] XOR nums[3] = 3\n    - (2, 3): nums[2] XOR nums[3] = 5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [9,8,4,2,1], low = 5, high = 14\n<strong>输出：</strong>8\n<strong>解释：</strong>所有漂亮数对 (i, j) 列出如下：\n​​​​​    - (0, 2): nums[0] XOR nums[2] = 13\n    - (0, 3): nums[0] XOR nums[3] = 11\n    - (0, 4): nums[0] XOR nums[4] = 8\n    - (1, 2): nums[1] XOR nums[2] = 12\n    - (1, 3): nums[1] XOR nums[3] = 10\n    - (1, 4): nums[1] XOR nums[4] = 9\n    - (2, 3): nums[2] XOR nums[3] = 6\n    - (2, 4): nums[2] XOR nums[4] = 5</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= low &lt;= high &lt;= 2 * 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1804.实现 Trie （前缀树） II",
        "hardRate": "MEDIUM",
        "passRate": "57.16%",
        "problemsUrl": "https://leetcode.cn/problems/implement-trie-ii-prefix-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/implement-trie-ii-prefix-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1805.字符串中不同整数的数目",
        "hardRate": "EASY",
        "passRate": "43.18%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-different-integers-in-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-different-integers-in-a-string/solution",
        "problemsDesc": "<p>给你一个字符串 <code>word</code> ，该字符串由数字和小写英文字母组成。</p>\n\n<p>请你用空格替换每个不是数字的字符。例如，<code>\"a123bc34d8ef34\"</code> 将会变成 <code>\" 123  34 8  34\"</code> 。注意，剩下的这些整数为（相邻彼此至少有一个空格隔开）：<code>\"123\"</code>、<code>\"34\"</code>、<code>\"8\"</code> 和 <code>\"34\"</code> 。</p>\n\n<p>返回对 <code>word</code> 完成替换后形成的 <strong>不同</strong> 整数的数目。</p>\n\n<p>只有当两个整数的 <strong>不含前导零</strong> 的十进制表示不同， 才认为这两个整数也不同。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"a<strong>123</strong>bc<strong>34</strong>d<strong>8</strong>ef<strong>34</strong>\"\n<strong>输出：</strong>3\n<strong>解释：</strong>不同的整数有 \"123\"、\"34\" 和 \"8\" 。注意，\"34\" 只计数一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"leet<strong>1234</strong>code<strong>234</strong>\"\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"a<strong>1</strong>b<strong>01</strong>c<strong>001</strong>\"\n<strong>输出：</strong>1\n<strong>解释：</strong>\"1\"、\"01\" 和 \"001\" 视为同一个整数的十进制表示，因为在比较十进制值时会忽略前导零的存在。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word.length <= 1000</code></li>\n\t<li><code>word</code> 由数字和小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1806.还原排列的最少操作步数",
        "hardRate": "MEDIUM",
        "passRate": "76.70%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/solution",
        "problemsDesc": "<p>给你一个偶数 <code>n</code>​​​​​​ ，已知存在一个长度为 <code>n</code> 的排列 <code>perm</code> ，其中 <code>perm[i] == i</code>​（下标 <strong>从 0 开始</strong> 计数）。</p>\n\n<p>一步操作中，你将创建一个新数组 <code>arr</code> ，对于每个 <code>i</code> ：</p>\n\n<ul>\n\t<li>如果 <code>i % 2 == 0</code> ，那么 <code>arr[i] = perm[i / 2]</code></li>\n\t<li>如果 <code>i % 2 == 1</code> ，那么 <code>arr[i] = perm[n / 2 + (i - 1) / 2]</code></li>\n</ul>\n\n<p>然后将 <code>arr</code>​​ 赋值​​给 <code>perm</code> 。</p>\n\n<p>要想使 <code>perm</code> 回到排列初始值，至少需要执行多少步操作？返回最小的 <strong>非零</strong> 操作步数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>最初，perm = [0,1]\n第 1 步操作后，perm = [0,1]\n所以，仅需执行 1 步操作</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>最初，perm = [0,1,2,3]\n第 1 步操作后，perm = [0,2,1,3]\n第 2 步操作后，perm = [0,1,2,3]\n所以，仅需执行 2 步操作</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6\n<strong>输出：</strong>4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 1000</code></li>\n\t<li><code>n</code>​​​​​​ 是一个偶数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1807.替换字符串中的括号内容",
        "hardRate": "MEDIUM",
        "passRate": "67.51%",
        "problemsUrl": "https://leetcode.cn/problems/evaluate-the-bracket-pairs-of-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/evaluate-the-bracket-pairs-of-a-string/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，它包含一些括号对，每个括号中包含一个 <strong>非空</strong>&nbsp;的键。</p>\n\n<ul>\n\t<li>比方说，字符串&nbsp;<code>\"(name)is(age)yearsold\"</code>&nbsp;中，有&nbsp;<strong>两个</strong>&nbsp;括号对，分别包含键&nbsp;<code>\"name\"</code> 和&nbsp;<code>\"age\"</code>&nbsp;。</li>\n</ul>\n\n<p>你知道许多键对应的值，这些关系由二维字符串数组&nbsp;<code>knowledge</code>&nbsp;表示，其中&nbsp;<code>knowledge[i] = [key<sub>i</sub>, value<sub>i</sub>]</code>&nbsp;，表示键&nbsp;<code>key<sub>i</sub></code>&nbsp;对应的值为&nbsp;<code>value<sub>i</sub></code><sub>&nbsp;</sub>。</p>\n\n<p>你需要替换 <strong>所有</strong>&nbsp;的括号对。当你替换一个括号对，且它包含的键为&nbsp;<code>key<sub>i</sub></code>&nbsp;时，你需要：</p>\n\n<ul>\n\t<li>将&nbsp;<code>key<sub>i</sub></code>&nbsp;和括号用对应的值&nbsp;<code>value<sub>i</sub></code>&nbsp;替换。</li>\n\t<li>如果从 <code>knowledge</code>&nbsp;中无法得知某个键对应的值，你需要将&nbsp;<code>key<sub>i</sub></code>&nbsp;和括号用问号&nbsp;<code>\"?\"</code>&nbsp;替换（不需要引号）。</li>\n</ul>\n\n<p><code>knowledge</code>&nbsp;中每个键最多只会出现一次。<code>s</code>&nbsp;中不会有嵌套的括号。</p>\n\n<p>请你返回替换 <strong>所有</strong>&nbsp;括号对后的结果字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"(name)is(age)yearsold\", knowledge = [[\"name\",\"bob\"],[\"age\",\"two\"]]\n<b>输出：</b>\"bobistwoyearsold\"\n<strong>解释：</strong>\n键 \"name\" 对应的值为 \"bob\" ，所以将 \"(name)\" 替换为 \"bob\" 。\n键 \"age\" 对应的值为 \"two\" ，所以将 \"(age)\" 替换为 \"two\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"hi(name)\", knowledge = [[\"a\",\"b\"]]\n<b>输出：</b>\"hi?\"\n<b>解释：</b>由于不知道键 \"name\" 对应的值，所以用 \"?\" 替换 \"(name)\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"(a)(a)(a)aaa\", knowledge = [[\"a\",\"yes\"]]\n<b>输出：</b>\"yesyesyesaaa\"\n<b>解释：</b>相同的键在 s 中可能会出现多次。\n键 \"a\" 对应的值为 \"yes\" ，所以将所有的 \"(a)\" 替换为 \"yes\" 。\n注意，不在括号里的 \"a\" 不需要被替换。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= knowledge.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>knowledge[i].length == 2</code></li>\n\t<li><code>1 &lt;= key<sub>i</sub>.length, value<sub>i</sub>.length &lt;= 10</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母和圆括号&nbsp;<code>'('</code>&nbsp;和&nbsp;<code>')'</code>&nbsp;。</li>\n\t<li><code>s</code>&nbsp;中每一个左圆括号&nbsp;<code>'('</code>&nbsp;都有对应的右圆括号&nbsp;<code>')'</code>&nbsp;。</li>\n\t<li><code>s</code>&nbsp;中每对括号内的键都不会为空。</li>\n\t<li><code>s</code>&nbsp;中不会有嵌套括号对。</li>\n\t<li><code>key<sub>i</sub></code>&nbsp;和&nbsp;<code>value<sub>i</sub></code>&nbsp;只包含小写英文字母。</li>\n\t<li><code>knowledge</code>&nbsp;中的&nbsp;<code>key<sub>i</sub></code>&nbsp;不会重复。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1808.好因子的最大数目",
        "hardRate": "HARD",
        "passRate": "28.63%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-number-of-nice-divisors/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-number-of-nice-divisors/solution",
        "problemsDesc": "<p>给你一个正整数 <code>primeFactors</code> 。你需要构造一个正整数 <code>n</code> ，它满足以下条件：</p>\n\n<ul>\n\t<li><code>n</code> 质因数（质因数需要考虑重复的情况）的数目 <strong>不超过 </strong><code>primeFactors</code> 个。</li>\n\t<li><code>n</code> 好因子的数目最大化。如果 <code>n</code> 的一个因子可以被 <code>n</code> 的每一个质因数整除，我们称这个因子是 <strong>好因子</strong> 。比方说，如果 <code>n = 12</code> ，那么它的质因数为 <code>[2,2,3]</code> ，那么 <code>6</code> 和 <code>12</code> 是好因子，但 <code>3</code> 和 <code>4</code> 不是。</li>\n</ul>\n\n<p>请你返回 <code>n</code> 的好因子的数目。由于答案可能会很大，请返回答案对 <code>10<sup>9</sup> + 7</code> <b>取余</b> 的结果。</p>\n\n<p>请注意，一个质数的定义是大于 <code>1</code> ，且不能被分解为两个小于该数的自然数相乘。一个数 <code>n</code> 的质因子是将 <code>n</code> 分解为若干个质因子，且它们的乘积为 <code>n</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>primeFactors = 5\n<strong>输出：</strong>6\n<b>解释：</b>200 是一个可行的 n 。\n它有 5 个质因子：[2,2,2,5,5] ，且有 6 个好因子：[10,20,40,50,100,200] 。\n不存在别的 n 有至多 5 个质因子，且同时有更多的好因子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>primeFactors = 8\n<b>输出：</b>18\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= primeFactors <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1809.没有广告的剧集",
        "hardRate": "EASY",
        "passRate": "60.95%",
        "problemsUrl": "https://leetcode.cn/problems/ad-free-sessions/",
        "solutionsUrl": "https://leetcode.cn/problems/ad-free-sessions/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1810.隐藏网格下的最小消耗路径",
        "hardRate": "MEDIUM",
        "passRate": "62.76%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-path-cost-in-a-hidden-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-path-cost-in-a-hidden-grid/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1811.寻找面试候选人",
        "hardRate": "MEDIUM",
        "passRate": "63.75%",
        "problemsUrl": "https://leetcode.cn/problems/find-interview-candidates/",
        "solutionsUrl": "https://leetcode.cn/problems/find-interview-candidates/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1812.判断国际象棋棋盘中一个格子的颜色",
        "hardRate": "EASY",
        "passRate": "81.79%",
        "problemsUrl": "https://leetcode.cn/problems/determine-color-of-a-chessboard-square/",
        "solutionsUrl": "https://leetcode.cn/problems/determine-color-of-a-chessboard-square/solution",
        "problemsDesc": "<p>给你一个坐标 <code>coordinates</code> ，它是一个字符串，表示国际象棋棋盘中一个格子的坐标。下图是国际象棋棋盘示意图。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/03/chessboard.png\" style=\"width: 400px; height: 396px;\" /></p>\n\n<p>如果所给格子的颜色是白色，请你返回 <code>true</code>，如果是黑色，请返回 <code>false</code> 。</p>\n\n<p>给定坐标一定代表国际象棋棋盘上一个存在的格子。坐标第一个字符是字母，第二个字符是数字。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>coordinates = \"a1\"\n<b>输出：</b>false\n<b>解释：</b>如上图棋盘所示，\"a1\" 坐标的格子是黑色的，所以返回 false 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>coordinates = \"h3\"\n<b>输出：</b>true\n<b>解释：</b>如上图棋盘所示，\"h3\" 坐标的格子是白色的，所以返回 true 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>coordinates = \"c7\"\n<b>输出：</b>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>coordinates.length == 2</code></li>\n\t<li><code>'a' <= coordinates[0] <= 'h'</code></li>\n\t<li><code>'1' <= coordinates[1] <= '8'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1813.句子相似性 III",
        "hardRate": "MEDIUM",
        "passRate": "41.62%",
        "problemsUrl": "https://leetcode.cn/problems/sentence-similarity-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/sentence-similarity-iii/solution",
        "problemsDesc": "<p>一个句子是由一些单词与它们之间的单个空格组成，且句子的开头和结尾没有多余空格。比方说，<code>\"Hello World\"</code> ，<code>\"HELLO\"</code> ，<code>\"hello world hello world\"</code> 都是句子。每个单词都 <strong>只</strong> 包含大写和小写英文字母。</p>\n\n<p>如果两个句子 <code>sentence1</code> 和 <code>sentence2</code> ，可以通过往其中一个句子插入一个任意的句子（<strong>可以是空句子</strong>）而得到另一个句子，那么我们称这两个句子是 <strong>相似的</strong> 。比方说，<code>sentence1 = \"Hello my name is Jane\"</code> 且 <code>sentence2 = \"Hello Jane\"</code> ，我们可以往 <code>sentence2</code> 中 <code>\"Hello\"</code> 和 <code>\"Jane\"</code> 之间插入 <code>\"my name is\"</code> 得到 <code>sentence1</code> 。</p>\n\n<p>给你两个句子 <code>sentence1</code> 和 <code>sentence2</code> ，如果<em> </em><code>sentence1</code> 和<em> </em><code>sentence2</code> 是相似的，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>sentence1 = \"My name is Haley\", sentence2 = \"My Haley\"\n<b>输出：</b>true\n<b>解释：</b>可以往 sentence2 中 \"My\" 和 \"Haley\" 之间插入 \"name is\" ，得到 sentence1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>sentence1 = \"of\", sentence2 = \"A lot of words\"\n<b>输出：</b>false\n<strong>解释：</strong>没法往这两个句子中的一个句子只插入一个句子就得到另一个句子。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>sentence1 = \"Eating right now\", sentence2 = \"Eating\"\n<b>输出：</b>true\n<b>解释：</b>可以往 sentence2 的结尾插入 \"right now\" 得到 sentence1 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>sentence1 = \"Luky\", sentence2 = \"Lucccky\"\n<b>输出：</b>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentence1.length, sentence2.length &lt;= 100</code></li>\n\t<li><code>sentence1</code> 和 <code>sentence2</code> 都只包含大小写英文字母和空格。</li>\n\t<li><code>sentence1</code> 和 <code>sentence2</code> 中的单词都只由单个空格隔开。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1814.统计一个数组中好对子的数目",
        "hardRate": "MEDIUM",
        "passRate": "47.13%",
        "problemsUrl": "https://leetcode.cn/problems/count-nice-pairs-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/count-nice-pairs-in-an-array/solution",
        "problemsDesc": "<p>给你一个数组 <code>nums</code> ，数组中只包含非负整数。定义 <code>rev(x)</code> 的值为将整数 <code>x</code> 各个数字位反转得到的结果。比方说 <code>rev(123) = 321</code> ， <code>rev(120) = 21</code> 。我们称满足下面条件的下标对 <code>(i, j)</code> 是 <strong>好的</strong> ：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; nums.length</code></li>\n\t<li><code>nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])</code></li>\n</ul>\n\n<p>请你返回好下标对的数目。由于结果可能会很大，请将结果对 <code>10<sup>9</sup> + 7</code> <b>取余</b> 后返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [42,11,1,97]\n<b>输出：</b>2\n<b>解释：</b>两个坐标对为：\n - (0,3)：42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121 。\n - (1,2)：11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [13,10,35,24,76]\n<b>输出：</b>4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1815.得到新鲜甜甜圈的最多组数",
        "hardRate": "HARD",
        "passRate": "53.42%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-groups-getting-fresh-donuts/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-groups-getting-fresh-donuts/solution",
        "problemsDesc": "<p>有一个甜甜圈商店，每批次都烤 <code>batchSize</code> 个甜甜圈。这个店铺有个规则，就是在烤一批新的甜甜圈时，之前 <strong>所有</strong> 甜甜圈都必须已经全部销售完毕。给你一个整数 <code>batchSize</code> 和一个整数数组 <code>groups</code> ，数组中的每个整数都代表一批前来购买甜甜圈的顾客，其中 <code>groups[i]</code> 表示这一批顾客的人数。每一位顾客都恰好只要一个甜甜圈。</p>\n\n<p>当有一批顾客来到商店时，他们所有人都必须在下一批顾客来之前购买完甜甜圈。如果一批顾客中第一位顾客得到的甜甜圈不是上一组剩下的，那么这一组人都会很开心。</p>\n\n<p>你可以随意安排每批顾客到来的顺序。请你返回在此前提下，<strong>最多</strong> 有多少组人会感到开心。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>batchSize = 3, groups = [1,2,3,4,5,6]\n<b>输出：</b>4\n<b>解释：</b>你可以将这些批次的顾客顺序安排为 [6,2,4,5,1,3] 。那么第 1，2，4，6 组都会感到开心。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>batchSize = 4, groups = [1,3,2,5,2,2,1,6]\n<b>输出：</b>4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= batchSize <= 9</code></li>\n\t<li><code>1 <= groups.length <= 30</code></li>\n\t<li><code>1 <= groups[i] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1816.截断句子",
        "hardRate": "EASY",
        "passRate": "72.41%",
        "problemsUrl": "https://leetcode.cn/problems/truncate-sentence/",
        "solutionsUrl": "https://leetcode.cn/problems/truncate-sentence/solution",
        "problemsDesc": "<p><strong>句子</strong> 是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。</p>\n\n<ul>\n\t<li>例如，<code>\"Hello World\"</code>、<code>\"HELLO\"</code> 和 <code>\"hello world hello world\"</code> 都是句子。</li>\n</ul>\n\n<p>给你一个句子 <code>s</code>​​​​​​ 和一个整数 <code>k</code>​​​​​​ ，请你将 <code>s</code>​​ <strong>截断</strong> ​，​​​使截断后的句子仅含 <strong>前</strong> <code>k</code>​​​​​​ 个单词。返回 <strong>截断</strong> <code>s</code>​​​​<em>​​ </em>后得到的句子<em>。</em></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"Hello how are you Contestant\", k = 4\n<strong>输出：</strong>\"Hello how are you\"\n<strong>解释：</strong>\ns 中的单词为 [\"Hello\", \"how\" \"are\", \"you\", \"Contestant\"]\n前 4 个单词为 [\"Hello\", \"how\", \"are\", \"you\"]\n因此，应当返回 \"Hello how are you\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"What is the solution to this problem\", k = 4\n<strong>输出：</strong>\"What is the solution\"\n<strong>解释：</strong>\ns 中的单词为 [\"What\", \"is\" \"the\", \"solution\", \"to\", \"this\", \"problem\"]\n前 4 个单词为 [\"What\", \"is\", \"the\", \"solution\"]\n因此，应当返回 \"What is the solution\"</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = \"chopper is not a tanuki\", k = 5\n<strong>输出：</strong>\"chopper is not a tanuki\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>k</code> 的取值范围是 <code>[1,  s 中单词的数目]</code></li>\n\t<li><code>s</code> 仅由大小写英文字母和空格组成</li>\n\t<li><code>s</code> 中的单词之间由单个空格隔开</li>\n\t<li>不存在前导或尾随空格</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1817.查找用户活跃分钟数",
        "hardRate": "MEDIUM",
        "passRate": "79.40%",
        "problemsUrl": "https://leetcode.cn/problems/finding-the-users-active-minutes/",
        "solutionsUrl": "https://leetcode.cn/problems/finding-the-users-active-minutes/solution",
        "problemsDesc": "<p>给你用户在 LeetCode 的操作日志，和一个整数 <code>k</code> 。日志用一个二维整数数组 <code>logs</code> 表示，其中每个 <code>logs[i] = [ID<sub>i</sub>, time<sub>i</sub>]</code> 表示 ID 为 <code>ID<sub>i</sub></code> 的用户在 <code>time<sub>i</sub></code> 分钟时执行了某个操作。</p>\n\n<p><strong>多个用户 </strong>可以同时执行操作，单个用户可以在同一分钟内执行 <strong>多个操作</strong> 。</p>\n\n<p>指定用户的<strong> 用户活跃分钟数（user active minutes，UAM）</strong> 定义为用户对 LeetCode 执行操作的 <strong>唯一分钟数</strong> 。 即使一分钟内执行多个操作，也只能按一分钟计数。</p>\n\n<p>请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 <code>k</code> 且 <strong>下标从 1 开始计数</strong> 的数组 <code>answer</code> ，对于每个 <code>j</code>（<code>1 <= j <= k</code>），<code>answer[j]</code> 表示 <strong>用户活跃分钟数</strong> 等于 <code>j</code> 的用户数。</p>\n\n<p>返回上面描述的答案数组<i> </i><code>answer</code><i> </i>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5\n<strong>输出：</strong>[0,2,0,0,0]\n<strong>解释：</strong>\nID=0 的用户执行操作的分钟分别是：5 、2 和 5 。因此，该用户的用户活跃分钟数为 2（分钟 5 只计数一次）\nID=1 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 2\n2 个用户的用户活跃分钟数都是 2 ，answer[2] 为 2 ，其余 answer[j] 的值都是 0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>logs = [[1,1],[2,2],[2,3]], k = 4\n<strong>输出：</strong>[1,1,0,0]\n<strong>解释：</strong>\nID=1 的用户仅在分钟 1 执行单个操作。因此，该用户的用户活跃分钟数为 1\nID=2 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 2\n1 个用户的用户活跃分钟数是 1 ，1 个用户的用户活跃分钟数是 2 \n因此，answer[1] = 1 ，answer[2] = 1 ，其余的值都是 0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= logs.length <= 10<sup>4</sup></code></li>\n\t<li><code>0 <= ID<sub>i</sub> <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= time<sub>i</sub> <= 10<sup>5</sup></code></li>\n\t<li><code>k</code> 的取值范围是 <code>[用户的最大用户活跃分钟数, 10<sup>5</sup>]</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1818.绝对差值和",
        "hardRate": "MEDIUM",
        "passRate": "37.58%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-absolute-sum-difference/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-absolute-sum-difference/solution",
        "problemsDesc": "<p>给你两个正整数数组 <code>nums1</code> 和 <code>nums2</code> ，数组的长度都是 <code>n</code> 。</p>\n\n<p>数组 <code>nums1</code> 和 <code>nums2</code> 的 <strong>绝对差值和</strong> 定义为所有 <code>|nums1[i] - nums2[i]|</code>（<code>0 <= i < n</code>）的 <strong>总和</strong>（<strong>下标从 0 开始</strong>）。</p>\n\n<p>你可以选用 <code>nums1</code> 中的 <strong>任意一个</strong> 元素来替换 <code>nums1</code> 中的 <strong>至多</strong> 一个元素，以 <strong>最小化</strong> 绝对差值和。</p>\n\n<p>在替换数组 <code>nums1</code> 中最多一个元素 <strong>之后</strong> ，返回最小绝对差值和。因为答案可能很大，所以需要对 <code>10<sup>9</sup> + 7</code> <strong>取余 </strong>后返回。</p>\n\n<p><code>|x|</code> 定义为：</p>\n\n<ul>\n\t<li>如果 <code>x >= 0</code> ，值为 <code>x</code> ，或者</li>\n\t<li>如果 <code>x <= 0</code> ，值为 <code>-x</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,7,5], nums2 = [2,3,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>有两种可能的最优方案：\n- 将第二个元素替换为第一个元素：[1,<strong>7</strong>,5] => [1,<strong>1</strong>,5] ，或者\n- 将第二个元素替换为第三个元素：[1,<strong>7</strong>,5] => [1,<strong>5</strong>,5]\n两种方案的绝对差值和都是 <code>|1-2| + (|1-3| 或者 |5-3|) + |5-5| = </code>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]\n<strong>输出：</strong>0\n<strong>解释：</strong>nums1 和 nums2 相等，所以不用替换元素。绝对差值和为 0\n</pre>\n\n<p><strong>示例 3</strong><strong>：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]\n<strong>输出：</strong>20\n<strong>解释：</strong>将第一个元素替换为第二个元素：[<strong>1</strong>,10,4,4,2,7] => [<strong>10</strong>,10,4,4,2,7]\n绝对差值和为 <code>|10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20</code>\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length</code></li>\n\t<li><code>n == nums2.length</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums1[i], nums2[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1819.序列中不同最大公约数的数目",
        "hardRate": "HARD",
        "passRate": "63.34%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-different-subsequences-gcds/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-different-subsequences-gcds/solution",
        "problemsDesc": "<p>给你一个由正整数组成的数组 <code>nums</code> 。</p>\n\n<p>数字序列的 <strong>最大公约数</strong> 定义为序列中所有整数的共有约数中的最大整数。</p>\n\n<ul>\n\t<li>例如，序列 <code>[4,6,16]</code> 的最大公约数是 <code>2</code> 。</li>\n</ul>\n\n<p>数组的一个 <strong>子序列</strong> 本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。</p>\n\n<ul>\n\t<li>例如，<code>[2,5,10]</code> 是 <code>[1,2,1,<strong>2</strong>,4,1,<strong>5</strong>,<strong>10</strong>]</code> 的一个子序列。</li>\n</ul>\n\n<p>计算并返回 <code>nums</code> 的所有 <strong>非空</strong> 子序列中 <strong>不同</strong> 最大公约数的 <strong>数目</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/03/image-1.png\" />\n<pre>\n<strong>输入：</strong>nums = [6,10,3]\n<strong>输出：</strong>5\n<strong>解释：</strong>上图显示了所有的非空子序列与各自的最大公约数。\n不同的最大公约数为 6 、10 、3 、2 和 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,15,40,5,6]\n<strong>输出：</strong>7\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 2 * 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1820.最多邀请的个数",
        "hardRate": "MEDIUM",
        "passRate": "47.60%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-accepted-invitations/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-accepted-invitations/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1821.寻找今年具有正收入的客户",
        "hardRate": "EASY",
        "passRate": "88.41%",
        "problemsUrl": "https://leetcode.cn/problems/find-customers-with-positive-revenue-this-year/",
        "solutionsUrl": "https://leetcode.cn/problems/find-customers-with-positive-revenue-this-year/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1822.数组元素积的符号",
        "hardRate": "EASY",
        "passRate": "71.72%",
        "problemsUrl": "https://leetcode.cn/problems/sign-of-the-product-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/sign-of-the-product-of-an-array/solution",
        "problemsDesc": "<p>已知函数 <code>signFunc(x)</code> 将会根据 <code>x</code> 的正负返回特定值：</p>\n\n<ul>\n\t<li>如果 <code>x</code> 是正数，返回 <code>1</code> 。</li>\n\t<li>如果 <code>x</code> 是负数，返回 <code>-1</code> 。</li>\n\t<li>如果 <code>x</code> 是等于 <code>0</code> ，返回 <code>0</code> 。</li>\n</ul>\n\n<p>给你一个整数数组 <code>nums</code> 。令 <code>product</code> 为数组 <code>nums</code> 中所有元素值的乘积。</p>\n\n<p>返回 <code>signFunc(product)</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,-2,-3,-4,3,2,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>数组中所有值的乘积是 144 ，且 signFunc(144) = 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5,0,2,-3]\n<strong>输出：</strong>0\n<strong>解释：</strong>数组中所有值的乘积是 0 ，且 signFunc(0) = 0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,1,-1,1,-1]\n<strong>输出：</strong>-1\n<strong>解释：</strong>数组中所有值的乘积是 -1 ，且 signFunc(-1) = -1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 1000</code></li>\n\t<li><code>-100 <= nums[i] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1823.找出游戏的获胜者",
        "hardRate": "MEDIUM",
        "passRate": "78.51%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-winner-of-the-circular-game/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-winner-of-the-circular-game/solution",
        "problemsDesc": "<p>共有 <code>n</code> 名小伙伴一起做游戏。小伙伴们围成一圈，按 <strong>顺时针顺序</strong> 从 <code>1</code> 到 <code>n</code> 编号。确切地说，从第 <code>i</code> 名小伙伴顺时针移动一位会到达第 <code>(i+1)</code> 名小伙伴的位置，其中 <code>1 &lt;= i &lt; n</code> ，从第 <code>n</code> 名小伙伴顺时针移动一位会回到第 <code>1</code> 名小伙伴的位置。</p>\n\n<p>游戏遵循如下规则：</p>\n\n<ol>\n\t<li>从第 <code>1</code> 名小伙伴所在位置 <strong>开始</strong> 。</li>\n\t<li>沿着顺时针方向数 <code>k</code> 名小伙伴，计数时需要 <strong>包含</strong> 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。</li>\n\t<li>你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。</li>\n\t<li>如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 <strong>顺时针下一位</strong> 小伙伴 <strong>开始</strong>，回到步骤 <code>2</code> 继续执行。</li>\n\t<li>否则，圈子中最后一名小伙伴赢得游戏。</li>\n</ol>\n\n<p>给你参与游戏的小伙伴总数 <code>n</code> ，和一个整数 <code>k</code> ，返回游戏的获胜者。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/ic234-q2-ex11.png\" style=\"width: 500px; height: 345px;\" />\n<pre>\n<strong>输入：</strong>n = 5, k = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>游戏运行步骤如下：\n1) 从小伙伴 1 开始。\n2) 顺时针数 2 名小伙伴，也就是小伙伴 1 和 2 。\n3) 小伙伴 2 离开圈子。下一次从小伙伴 3 开始。\n4) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 4 。\n5) 小伙伴 4 离开圈子。下一次从小伙伴 5 开始。\n6) 顺时针数 2 名小伙伴，也就是小伙伴 5 和 1 。\n7) 小伙伴 1 离开圈子。下一次从小伙伴 3 开始。\n8) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 5 。\n9) 小伙伴 5 离开圈子。只剩下小伙伴 3 。所以小伙伴 3 是游戏的获胜者。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6, k = 5\n<strong>输出：</strong>1\n<strong>解释：</strong>小伙伴离开圈子的顺序：5、4、6、2、3 。小伙伴 1 是游戏的获胜者。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 500</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能否使用线性时间复杂度和常数空间复杂度解决此问题？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1824.最少侧跳次数",
        "hardRate": "MEDIUM",
        "passRate": "68.37%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-sideway-jumps/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-sideway-jumps/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的 <strong>3 跑道道路</strong> ，它总共包含 <code>n + 1</code> 个 <strong>点</strong> ，编号为 <code>0</code> 到 <code>n</code> 。一只青蛙从 <code>0</code> 号点第二条跑道 <strong>出发</strong> ，它想要跳到点 <code>n</code> 处。然而道路上可能有一些障碍。</p>\n\n<p>给你一个长度为 <code>n + 1</code> 的数组 <code>obstacles</code> ，其中 <code>obstacles[i]</code> （<b>取值范围从 0 到 3</b>）表示在点 <code>i</code> 处的 <code>obstacles[i]</code> 跑道上有一个障碍。如果 <code>obstacles[i] == 0</code> ，那么点 <code>i</code> 处没有障碍。任何一个点的三条跑道中 <strong>最多有一个</strong> 障碍。</p>\n\n<ul>\n\t<li>比方说，如果 <code>obstacles[2] == 1</code> ，那么说明在点 2 处跑道 1 有障碍。</li>\n</ul>\n\n<p>这只青蛙从点 <code>i</code> 跳到点 <code>i + 1</code> 且跑道不变的前提是点 <code>i + 1</code> 的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在 <strong>同一个</strong> 点处 <strong>侧跳</strong> 到 <strong>另外一条</strong> 跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。</p>\n\n<ul>\n\t<li>比方说，这只青蛙可以从点 3 处的跑道 3 跳到点 3 处的跑道 1 。</li>\n</ul>\n\n<p>这只青蛙从点 0 处跑道 <code>2</code> 出发，并想到达点 <code>n</code> 处的 <strong>任一跑道</strong> ，请你返回 <strong>最少侧跳次数</strong> 。</p>\n\n<p><strong>注意</strong>：点 <code>0</code> 处和点 <code>n</code> 处的任一跑道都不会有障碍。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex1.png\" style=\"width: 500px; height: 244px;\" />\n<pre>\n<b>输入：</b>obstacles = [0,1,2,3,0]\n<b>输出：</b>2 \n<b>解释：</b>最优方案如上图箭头所示。总共有 2 次侧跳（红色箭头）。\n注意，这只青蛙只有当侧跳时才可以跳过障碍（如上图点 2 处所示）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex2.png\" style=\"width: 500px; height: 196px;\" />\n<pre>\n<b>输入：</b>obstacles = [0,1,1,3,3,0]\n<b>输出：</b>0\n<b>解释：</b>跑道 2 没有任何障碍，所以不需要任何侧跳。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex3.png\" style=\"width: 500px; height: 196px;\" />\n<pre>\n<b>输入：</b>obstacles = [0,2,1,0,3,0]\n<b>输出：</b>2\n<b>解释：</b>最优方案如上图所示。总共有 2 次侧跳。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>obstacles.length == n + 1</code></li>\n\t<li><code>1 <= n <= 5 * 10<sup>5</sup></code></li>\n\t<li><code>0 <= obstacles[i] <= 3</code></li>\n\t<li><code>obstacles[0] == obstacles[n] == 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1825.求出 MK 平均值",
        "hardRate": "HARD",
        "passRate": "43.44%",
        "problemsUrl": "https://leetcode.cn/problems/finding-mk-average/",
        "solutionsUrl": "https://leetcode.cn/problems/finding-mk-average/solution",
        "problemsDesc": "<p>给你两个整数&nbsp;<code>m</code>&nbsp;和&nbsp;<code>k</code>&nbsp;，以及数据流形式的若干整数。你需要实现一个数据结构，计算这个数据流的 <b>MK 平均值</b>&nbsp;。</p>\n\n<p><strong>MK 平均值</strong>&nbsp;按照如下步骤计算：</p>\n\n<ol>\n\t<li>如果数据流中的整数少于 <code>m</code>&nbsp;个，<strong>MK 平均值</strong>&nbsp;为 <code>-1</code>&nbsp;，否则将数据流中最后 <code>m</code>&nbsp;个元素拷贝到一个独立的容器中。</li>\n\t<li>从这个容器中删除最小的 <code>k</code>&nbsp;个数和最大的 <code>k</code>&nbsp;个数。</li>\n\t<li>计算剩余元素的平均值，并 <strong>向下取整到最近的整数</strong>&nbsp;。</li>\n</ol>\n\n<p>请你实现&nbsp;<code>MKAverage</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>MKAverage(int m, int k)</code>&nbsp;用一个空的数据流和两个整数 <code>m</code>&nbsp;和 <code>k</code>&nbsp;初始化&nbsp;<strong>MKAverage</strong>&nbsp;对象。</li>\n\t<li><code>void addElement(int num)</code>&nbsp;往数据流中插入一个新的元素&nbsp;<code>num</code>&nbsp;。</li>\n\t<li><code>int calculateMKAverage()</code>&nbsp;对当前的数据流计算并返回 <strong>MK 平均数</strong>&nbsp;，结果需 <strong>向下取整到最近的整数</strong> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"MKAverage\", \"addElement\", \"addElement\", \"calculateMKAverage\", \"addElement\", \"calculateMKAverage\", \"addElement\", \"addElement\", \"addElement\", \"calculateMKAverage\"]\n[[3, 1], [3], [1], [], [10], [], [5], [5], [5], []]\n<strong>输出：</strong>\n[null, null, null, -1, null, 3, null, null, null, 5]\n\n<strong>解释：</strong>\nMKAverage obj = new MKAverage(3, 1); \nobj.addElement(3);        // 当前元素为 [3]\nobj.addElement(1);        // 当前元素为 [3,1]\nobj.calculateMKAverage(); // 返回 -1 ，因为 m = 3 ，但数据流中只有 2 个元素\nobj.addElement(10);       // 当前元素为 [3,1,10]\nobj.calculateMKAverage(); // 最后 3 个元素为 [3,1,10]\n                          // 删除最小以及最大的 1 个元素后，容器为 [3]\n                          // [3] 的平均值等于 3/1 = 3 ，故返回 3\nobj.addElement(5);        // 当前元素为 [3,1,10,5]\nobj.addElement(5);        // 当前元素为 [3,1,10,5,5]\nobj.addElement(5);        // 当前元素为 [3,1,10,5,5,5]\nobj.calculateMKAverage(); // 最后 3 个元素为 [5,5,5]\n                          // 删除最小以及最大的 1 个元素后，容器为 [5]\n                          // [5] 的平均值等于 5/1 = 5 ，故返回 5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k*2 &lt; m</code></li>\n\t<li><code>1 &lt;= num &lt;= 10<sup>5</sup></code></li>\n\t<li><code>addElement</code> 与&nbsp;<code>calculateMKAverage</code>&nbsp;总操作次数不超过 <code>10<sup>5</sup></code> 次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1826.有缺陷的传感器",
        "hardRate": "EASY",
        "passRate": "41.74%",
        "problemsUrl": "https://leetcode.cn/problems/faulty-sensor/",
        "solutionsUrl": "https://leetcode.cn/problems/faulty-sensor/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1827.最少操作使数组递增",
        "hardRate": "EASY",
        "passRate": "81.36%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-array-increasing/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-array-increasing/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> （<strong>下标从 0 开始</strong>）。每一次操作中，你可以选择数组中一个元素，并将它增加 <code>1</code> 。</p>\n\n<ul>\n\t<li>比方说，如果 <code>nums = [1,2,3]</code> ，你可以选择增加 <code>nums[1]</code> 得到 <code>nums = [1,<b>3</b>,3]</code> 。</li>\n</ul>\n\n<p>请你返回使 <code>nums</code> <strong>严格递增</strong> 的 <strong>最少</strong> 操作次数。</p>\n\n<p>我们称数组 <code>nums</code> 是 <strong>严格递增的</strong> ，当它满足对于所有的 <code>0 &lt;= i &lt; nums.length - 1</code> 都有 <code>nums[i] &lt; nums[i+1]</code> 。一个长度为 <code>1</code> 的数组是严格递增的一种特殊情况。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,1,1]\n<b>输出：</b>3\n<b>解释：</b>你可以进行如下操作：\n1) 增加 nums[2] ，数组变为 [1,1,<strong>2</strong>] 。\n2) 增加 nums[1] ，数组变为 [1,<strong>2</strong>,2] 。\n3) 增加 nums[2] ，数组变为 [1,2,<strong>3</strong>] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,5,2,4,1]\n<b>输出：</b>14\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [8]\n<b>输出：</b>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1828.统计一个圆中点的数目",
        "hardRate": "MEDIUM",
        "passRate": "88.50%",
        "problemsUrl": "https://leetcode.cn/problems/queries-on-number-of-points-inside-a-circle/",
        "solutionsUrl": "https://leetcode.cn/problems/queries-on-number-of-points-inside-a-circle/solution",
        "problemsDesc": "<p>给你一个数组 <code>points</code> ，其中 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> ，表示第 <code>i</code> 个点在二维平面上的坐标。多个点可能会有 <strong>相同</strong> 的坐标。</p>\n\n<p>同时给你一个数组 <code>queries</code> ，其中 <code>queries[j] = [x<sub>j</sub>, y<sub>j</sub>, r<sub>j</sub>]</code> ，表示一个圆心在 <code>(x<sub>j</sub>, y<sub>j</sub>)</code> 且半径为 <code>r<sub>j</sub></code><sub> </sub>的圆。</p>\n\n<p>对于每一个查询 <code>queries[j]</code> ，计算在第 <code>j</code> 个圆 <strong>内</strong> 点的数目。如果一个点在圆的 <strong>边界上</strong> ，我们同样认为它在圆 <strong>内</strong> 。</p>\n\n<p>请你返回一个数组<em> </em><code>answer</code> ，其中<em> </em><code>answer[j]</code>是第 <code>j</code> 个查询的答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/chrome_2021-03-25_22-34-16.png\" style=\"width: 500px; height: 418px;\">\n<pre><b>输入：</b>points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]]\n<b>输出：</b>[3,2,2]\n<b>解释：</b>所有的点和圆如上图所示。\nqueries[0] 是绿色的圆，queries[1] 是红色的圆，queries[2] 是蓝色的圆。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/chrome_2021-03-25_22-42-07.png\" style=\"width: 500px; height: 390px;\">\n<pre><b>输入：</b>points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]\n<b>输出：</b>[2,3,2,4]\n<b>解释：</b>所有的点和圆如上图所示。\nqueries[0] 是绿色的圆，queries[1] 是红色的圆，queries[2] 是蓝色的圆，queries[3] 是紫色的圆。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= points.length &lt;= 500</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>​​​​​​i</sub>, y<sub>​​​​​​i</sub> &lt;= 500</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 500</code></li>\n\t<li><code>queries[j].length == 3</code></li>\n\t<li><code>0 &lt;= x<sub>j</sub>, y<sub>j</sub> &lt;= 500</code></li>\n\t<li><code>1 &lt;= r<sub>j</sub> &lt;= 500</code></li>\n\t<li>所有的坐标都是整数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1829.每个查询的最大异或值",
        "hardRate": "MEDIUM",
        "passRate": "72.16%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-xor-for-each-query/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-xor-for-each-query/solution",
        "problemsDesc": "<p>给你一个 <strong>有序</strong> 数组 <code>nums</code> ，它由 <code>n</code> 个非负整数组成，同时给你一个整数 <code>maximumBit</code> 。你需要执行以下查询 <code>n</code> 次：</p>\n\n<ol>\n\t<li>找到一个非负整数 <code>k < 2<sup>maximumBit</sup></code> ，使得 <code>nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k</code> 的结果 <strong>最大化</strong> 。<code>k</code> 是第 <code>i</code> 个查询的答案。</li>\n\t<li>从当前数组 <code>nums</code> 删除 <strong>最后</strong> 一个元素。</li>\n</ol>\n\n<p>请你返回一个数组 <code>answer</code> ，其中<em> </em><code>answer[i]</code>是第 <code>i</code> 个查询的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [0,1,1,3], maximumBit = 2\n<b>输出：</b>[0,3,2,3]\n<b>解释：</b>查询的答案如下：\n第一个查询：nums = [0,1,1,3]，k = 0，因为 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3 。\n第二个查询：nums = [0,1,1]，k = 3，因为 0 XOR 1 XOR 1 XOR 3 = 3 。\n第三个查询：nums = [0,1]，k = 2，因为 0 XOR 1 XOR 2 = 3 。\n第四个查询：nums = [0]，k = 3，因为 0 XOR 3 = 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,3,4,7], maximumBit = 3\n<b>输出：</b>[5,2,6,5]\n<b>解释：</b>查询的答案如下：\n第一个查询：nums = [2,3,4,7]，k = 5，因为 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7。\n第二个查询：nums = [2,3,4]，k = 2，因为 2 XOR 3 XOR 4 XOR 2 = 7 。\n第三个查询：nums = [2,3]，k = 6，因为 2 XOR 3 XOR 6 = 7 。\n第四个查询：nums = [2]，k = 5，因为 2 XOR 5 = 7 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [0,1,2,2,5,7], maximumBit = 3\n<b>输出：</b>[4,3,6,4,6,7]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length == n</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= maximumBit <= 20</code></li>\n\t<li><code>0 <= nums[i] < 2<sup>maximumBit</sup></code></li>\n\t<li><code>nums</code>​​​ 中的数字已经按 <strong>升序</strong> 排好序。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1830.使字符串有序的最少操作次数",
        "hardRate": "HARD",
        "passRate": "53.05%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-make-string-sorted/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-make-string-sorted/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> （<strong>下标从 0 开始</strong>）。你需要对 <code>s</code> 执行以下操作直到它变为一个有序字符串：</p>\n\n<ol>\n\t<li>找到 <strong>最大下标</strong> <code>i</code> ，使得 <code>1 &lt;= i &lt; s.length</code> 且 <code>s[i] &lt; s[i - 1]</code> 。</li>\n\t<li>找到 <strong>最大下标</strong> <code>j</code> ，使得 <code>i &lt;= j &lt; s.length</code> 且对于所有在闭区间 <code>[i, j]</code> 之间的 <code>k</code> 都有 <code>s[k] &lt; s[i - 1]</code> 。</li>\n\t<li>交换下标为 <code>i - 1</code>​​​​ 和 <code>j</code>​​​​ 处的两个字符。</li>\n\t<li>将下标 <code>i</code> 开始的字符串后缀反转。</li>\n</ol>\n\n<p>请你返回将字符串变成有序的最少操作次数。由于答案可能会很大，请返回它对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"cba\"\n<b>输出：</b>5\n<b>解释：</b>模拟过程如下所示：\n操作 1：i=2，j=2。交换 s[1] 和 s[2] 得到 s=\"cab\" ，然后反转下标从 2 开始的后缀字符串，得到 s=\"cab\" 。\n操作 2：i=1，j=2。交换 s[0] 和 s[2] 得到 s=\"bac\" ，然后反转下标从 1 开始的后缀字符串，得到 s=\"bca\" 。\n操作 3：i=2，j=2。交换 s[1] 和 s[2] 得到 s=\"bac\" ，然后反转下标从 2 开始的后缀字符串，得到 s=\"bac\" 。\n操作 4：i=1，j=1。交换 s[0] 和 s[1] 得到 s=\"abc\" ，然后反转下标从 1 开始的后缀字符串，得到 s=\"acb\" 。\n操作 5：i=2，j=2。交换 s[1] 和 s[2] 得到 s=\"abc\" ，然后反转下标从 2 开始的后缀字符串，得到 s=\"abc\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"aabaa\"\n<b>输出：</b>2\n<b>解释：</b>模拟过程如下所示：\n操作 1：i=3，j=4。交换 s[2] 和 s[4] 得到 s=\"aaaab\" ，然后反转下标从 3 开始的后缀字符串，得到 s=\"aaaba\" 。\n操作 2：i=4，j=4。交换 s[3] 和 s[4] 得到 s=\"aaaab\" ，然后反转下标从 4 开始的后缀字符串，得到 s=\"aaaab\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>s = \"cdbea\"\n<b>输出：</b>63</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>s = \"leetcodeleetcodeleetcode\"\n<b>输出：</b>982157772\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3000</code></li>\n\t<li><code>s</code>​ 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1831.每天的最大交易",
        "hardRate": "MEDIUM",
        "passRate": "78.11%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-transaction-each-day/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-transaction-each-day/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1832.判断句子是否为全字母句",
        "hardRate": "EASY",
        "passRate": "84.84%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-the-sentence-is-pangram/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-the-sentence-is-pangram/solution",
        "problemsDesc": "<p><strong>全字母句</strong> 指包含英语字母表中每个字母至少一次的句子。</p>\n\n<p>给你一个仅由小写英文字母组成的字符串 <code>sentence</code> ，请你判断 <code>sentence</code> 是否为 <strong>全字母句</strong> 。</p>\n\n<p>如果是，返回<em> </em><code>true</code> ；否则，返回<em> </em><code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"thequickbrownfoxjumpsoverthelazydog\"\n<strong>输出：</strong>true\n<strong>解释：</strong><code>sentence</code> 包含英语字母表中每个字母至少一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"leetcode\"\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= sentence.length <= 1000</code></li>\n\t<li><code>sentence</code> 由小写英语字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1833.雪糕的最大数量",
        "hardRate": "MEDIUM",
        "passRate": "68.07%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-ice-cream-bars/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-ice-cream-bars/solution",
        "problemsDesc": "<p>夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。</p>\n\n<p>商店中新到 <code>n</code> 支雪糕，用长度为 <code>n</code> 的数组 <code>costs</code> 表示雪糕的定价，其中 <code>costs[i]</code> 表示第 <code>i</code> 支雪糕的现金价格。Tony 一共有 <code>coins</code> 现金可以用于消费，他想要买尽可能多的雪糕。</p>\n\n<p><strong>注意：</strong>Tony 可以按任意顺序购买雪糕。</p>\n\n<p>给你价格数组 <code>costs</code> 和现金量 <code>coins</code> ，请你计算并返回 Tony 用 <code>coins</code> 现金能够买到的雪糕的 <strong>最大数量</strong> 。</p>\n\n<p>你必须使用计数排序解决此问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>costs = [1,3,2,4,1], coins = 7\n<strong>输出：</strong>4\n<strong>解释：</strong>Tony 可以买下标为 0、1、2、4 的雪糕，总价为 1 + 3 + 2 + 1 = 7\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>costs = [10,6,8,7,7,8], coins = 5\n<strong>输出：</strong>0\n<strong>解释：</strong>Tony 没有足够的钱买任何一支雪糕。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>costs = [1,6,3,1,2,5], coins = 20\n<strong>输出：</strong>6\n<strong>解释：</strong>Tony 可以买下所有的雪糕，总价为 1 + 6 + 3 + 1 + 2 + 5 = 18 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>costs.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= costs[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= coins &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1834.单线程 CPU",
        "hardRate": "MEDIUM",
        "passRate": "37.85%",
        "problemsUrl": "https://leetcode.cn/problems/single-threaded-cpu/",
        "solutionsUrl": "https://leetcode.cn/problems/single-threaded-cpu/solution",
        "problemsDesc": "<p>给你一个二维数组 <code>tasks</code> ，用于表示 <code>n</code>​​​​​​ 项从 <code>0</code> 到 <code>n - 1</code> 编号的任务。其中 <code>tasks[i] = [enqueueTime<sub>i</sub>, processingTime<sub>i</sub>]</code> 意味着第 <code>i<sup>​​​​​​</sup></code>​​​​ 项任务将会于 <code>enqueueTime<sub>i</sub></code> 时进入任务队列，需要 <code>processingTime<sub>i</sub></code><sub> </sub>的时长完成执行。</p>\n\n<p>现有一个单线程 CPU ，同一时间只能执行 <strong>最多一项</strong> 任务，该 CPU 将会按照下述方式运行：</p>\n\n<ul>\n\t<li>如果 CPU 空闲，且任务队列中没有需要执行的任务，则 CPU 保持空闲状态。</li>\n\t<li>如果 CPU 空闲，但任务队列中有需要执行的任务，则 CPU 将会选择 <strong>执行时间最短</strong> 的任务开始执行。如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。</li>\n\t<li>一旦某项任务开始执行，CPU 在 <strong>执行完整个任务</strong> 前都不会停止。</li>\n\t<li>CPU 可以在完成一项任务后，立即开始执行一项新任务。</li>\n</ul>\n\n<p>返回<em> </em>CPU<em> </em>处理任务的顺序。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>tasks = [[1,2],[2,4],[3,2],[4,1]]\n<strong>输出：</strong>[0,2,3,1]\n<strong>解释：</strong>事件按下述流程运行： \n- time = 1 ，任务 0 进入任务队列，可执行任务项 = {0}\n- 同样在 time = 1 ，空闲状态的 CPU 开始执行任务 0 ，可执行任务项 = {}\n- time = 2 ，任务 1 进入任务队列，可执行任务项 = {1}\n- time = 3 ，任务 2 进入任务队列，可执行任务项 = {1, 2}\n- 同样在 time = 3 ，CPU 完成任务 0 并开始执行队列中用时最短的任务 2 ，可执行任务项 = {1}\n- time = 4 ，任务 3 进入任务队列，可执行任务项 = {1, 3}\n- time = 5 ，CPU 完成任务 2 并开始执行队列中用时最短的任务 3 ，可执行任务项 = {1}\n- time = 6 ，CPU 完成任务 3 并开始执行任务 1 ，可执行任务项 = {}\n- time = 10 ，CPU 完成任务 1 并进入空闲状态\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]]\n<strong>输出：</strong>[4,3,2,0,1]\n<strong>解释：</strong>事件按下述流程运行： \n- time = 7 ，所有任务同时进入任务队列，可执行任务项  = {0,1,2,3,4}\n- 同样在 time = 7 ，空闲状态的 CPU 开始执行任务 4 ，可执行任务项 = {0,1,2,3}\n- time = 9 ，CPU 完成任务 4 并开始执行任务 3 ，可执行任务项 = {0,1,2}\n- time = 13 ，CPU 完成任务 3 并开始执行任务 2 ，可执行任务项 = {0,1}\n- time = 18 ，CPU 完成任务 2 并开始执行任务 0 ，可执行任务项 = {1}\n- time = 28 ，CPU 完成任务 0 并开始执行任务 1 ，可执行任务项 = {}\n- time = 40 ，CPU 完成任务 1 并进入空闲状态</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>tasks.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= enqueueTime<sub>i</sub>, processingTime<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1835.所有数对按位与结果的异或和",
        "hardRate": "HARD",
        "passRate": "55.96%",
        "problemsUrl": "https://leetcode.cn/problems/find-xor-sum-of-all-pairs-bitwise-and/",
        "solutionsUrl": "https://leetcode.cn/problems/find-xor-sum-of-all-pairs-bitwise-and/solution",
        "problemsDesc": "<p>列表的 <strong>异或和</strong>（<strong>XOR sum</strong>）指对所有元素进行按位 <code>XOR</code> 运算的结果。如果列表中仅有一个元素，那么其 <strong>异或和</strong> 就等于该元素。</p>\n\n<ul>\n\t<li>例如，<code>[1,2,3,4]</code> 的 <strong>异或和</strong> 等于 <code>1 XOR 2 XOR 3 XOR 4 = 4</code> ，而 <code>[3]</code> 的 <strong>异或和</strong> 等于 <code>3</code> 。</li>\n</ul>\n\n<p>给你两个下标 <strong>从 0 开始</strong> 计数的数组 <code>arr1</code> 和 <code>arr2</code> ，两数组均由非负整数组成。</p>\n\n<p>根据每个 <code>(i, j)</code> 数对，构造一个由 <code>arr1[i] AND arr2[j]</code>（按位 <code>AND</code> 运算）结果组成的列表。其中 <code>0 &lt;= i &lt; arr1.length</code> 且 <code>0 &lt;= j &lt; arr2.length</code> 。</p>\n\n<p>返回上述列表的 <strong>异或和</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr1 = [1,2,3], arr2 = [6,5]\n<strong>输出：</strong>0\n<strong>解释：</strong>列表 = [1 AND 6, 1 AND 5, 2 AND 6, 2 AND 5, 3 AND 6, 3 AND 5] = [0,1,2,0,2,1] ，\n异或和 = 0 XOR 1 XOR 2 XOR 0 XOR 2 XOR 1 = 0 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr1 = [12], arr2 = [4]\n<strong>输出：</strong>4\n<strong>解释：</strong>列表 = [12 AND 4] = [4] ，异或和 = 4 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr1.length, arr2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= arr1[i], arr2[j] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1836.从未排序的链表中移除重复元素",
        "hardRate": "MEDIUM",
        "passRate": "73.12%",
        "problemsUrl": "https://leetcode.cn/problems/remove-duplicates-from-an-unsorted-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-duplicates-from-an-unsorted-linked-list/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1837.K 进制表示下的各位数字总和",
        "hardRate": "EASY",
        "passRate": "79.32%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-digits-in-base-k/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-digits-in-base-k/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code>（<code>10</code> 进制）和一个基数 <code>k</code> ，请你将 <code>n</code> 从 <code>10</code> 进制表示转换为 <code>k</code> 进制表示，计算并返回转换后各位数字的 <strong>总和</strong> 。</p>\n\n<p>转换后，各位数字应当视作是 <code>10</code> 进制数字，且它们的总和也应当按 <code>10</code> 进制表示返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 34, k = 6\n<strong>输出：</strong>9\n<strong>解释：</strong>34 (10 进制) 在 6 进制下表示为 54 。5 + 4 = 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10, k = 10\n<strong>输出：</strong>1\n<strong>解释：</strong>n 本身就是 10 进制。 1 + 0 = 1 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>2 <= k <= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1838.最高频元素的频数",
        "hardRate": "MEDIUM",
        "passRate": "43.05%",
        "problemsUrl": "https://leetcode.cn/problems/frequency-of-the-most-frequent-element/",
        "solutionsUrl": "https://leetcode.cn/problems/frequency-of-the-most-frequent-element/solution",
        "problemsDesc": "<p>元素的 <strong>频数</strong> 是该元素在一个数组中出现的次数。</p>\n\n<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。在一步操作中，你可以选择 <code>nums</code> 的一个下标，并将该下标对应元素的值增加 <code>1</code> 。</p>\n\n<p>执行最多 <code>k</code> 次操作后，返回数组中最高频元素的 <strong>最大可能频数</strong> <em>。</em></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,4], k = 5\n<strong>输出：</strong>3<strong>\n解释：</strong>对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums = [4,4,4] 。\n4 是数组中最高频元素，频数是 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,4,8,13], k = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>存在多种最优解决方案：\n- 对第一个元素执行 3 次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。\n- 对第二个元素执行 4 次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。\n- 对第三个元素执行 5 次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,9,6], k = 2\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= k <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1839.所有元音按顺序排布的最长子字符串",
        "hardRate": "MEDIUM",
        "passRate": "49.13%",
        "problemsUrl": "https://leetcode.cn/problems/longest-substring-of-all-vowels-in-order/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-substring-of-all-vowels-in-order/solution",
        "problemsDesc": "<p>当一个字符串满足如下条件时，我们称它是 <b>美丽的</b> ：</p>\n\n<ul>\n\t<li>所有 5 个英文元音字母（<code>'a'</code> ，<code>'e'</code> ，<code>'i'</code> ，<code>'o'</code> ，<code>'u'</code>）都必须 <strong>至少</strong> 出现一次。</li>\n\t<li>这些元音字母的顺序都必须按照 <strong>字典序</strong> 升序排布（也就是说所有的 <code>'a'</code> 都在 <code>'e'</code> 前面，所有的 <code>'e'</code> 都在 <code>'i'</code> 前面，以此类推）</li>\n</ul>\n\n<p>比方说，字符串 <code>\"aeiou\"</code> 和 <code>\"aaaaaaeiiiioou\"</code> 都是 <strong>美丽的</strong> ，但是 <code>\"uaeio\"</code> ，<code>\"aeoiu\"</code> 和 <code>\"aaaeeeooo\"</code> <strong>不是美丽的</strong> 。</p>\n\n<p>给你一个只包含英文元音字母的字符串 <code>word</code> ，请你返回 <code>word</code> 中 <strong>最长美丽子字符串的长度</strong> 。如果不存在这样的子字符串，请返回 <code>0</code> 。</p>\n\n<p><strong>子字符串</strong> 是字符串中一个连续的字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>word = \"aeiaaio<strong>aaaaeiiiiouuu</strong>ooaauuaeiu\"\n<b>输出：</b>13\n<b>解释：</b>最长子字符串是 \"aaaaeiiiiouuu\" ，长度为 13 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>word = \"aeeeiiiioooauuu<strong>aeiou</strong>\"\n<b>输出：</b>5\n<b>解释：</b>最长子字符串是 \"aeiou\" ，长度为 5 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>word = \"a\"\n<b>输出：</b>0\n<b>解释：</b>没有美丽子字符串，所以返回 0 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word.length <= 5 * 10<sup>5</sup></code></li>\n\t<li><code>word</code> 只包含字符 <code>'a'</code>，<code>'e'</code>，<code>'i'</code>，<code>'o'</code> 和 <code>'u'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1840.最高建筑高度",
        "hardRate": "HARD",
        "passRate": "39.45%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-building-height/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-building-height/solution",
        "problemsDesc": "<p>在一座城市里，你需要建 <code>n</code> 栋新的建筑。这些新的建筑会从 <code>1</code> 到 <code>n</code> 编号排成一列。</p>\n\n<p>这座城市对这些新建筑有一些规定：</p>\n\n<ul>\n\t<li>每栋建筑的高度必须是一个非负整数。</li>\n\t<li>第一栋建筑的高度 <strong>必须</strong> 是 <code>0</code> 。</li>\n\t<li>任意两栋相邻建筑的高度差 <strong>不能超过</strong>  <code>1</code> 。</li>\n</ul>\n\n<p>除此以外，某些建筑还有额外的最高高度限制。这些限制会以二维整数数组 <code>restrictions</code> 的形式给出，其中 <code>restrictions[i] = [id<sub>i</sub>, maxHeight<sub>i</sub>]</code> ，表示建筑 <code>id<sub>i</sub></code> 的高度 <strong>不能超过</strong> <code>maxHeight<sub>i</sub></code> 。</p>\n\n<p>题目保证每栋建筑在 <code>restrictions</code> 中<strong> 至多出现一次</strong> ，同时建筑 <code>1</code> <strong>不会</strong> 出现在 <code>restrictions</code> 中。</p>\n\n<p>请你返回 <strong>最高</strong> 建筑能达到的 <strong>最高高度</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/25/ic236-q4-ex1-1.png\" style=\"width: 400px; height: 253px;\" />\n<pre>\n<b>输入：</b>n = 5, restrictions = [[2,1],[4,1]]\n<b>输出：</b>2\n<b>解释：</b>上图中的绿色区域为每栋建筑被允许的最高高度。\n我们可以使建筑高度分别为 [0,1,2,1,2] ，最高建筑的高度为 2 。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/25/ic236-q4-ex2.png\" style=\"width: 500px; height: 269px;\" />\n<pre>\n<b>输入：</b>n = 6, restrictions = []\n<b>输出：</b>5\n<b>解释：</b>上图中的绿色区域为每栋建筑被允许的最高高度。\n我们可以使建筑高度分别为 [0,1,2,3,4,5] ，最高建筑的高度为 5 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/25/ic236-q4-ex3.png\" style=\"width: 500px; height: 187px;\" />\n<pre>\n<b>输入：</b>n = 10, restrictions = [[5,3],[2,5],[7,4],[10,3]]\n<b>输出：</b>5\n<b>解释：</b>上图中的绿色区域为每栋建筑被允许的最高高度。\n我们可以使建筑高度分别为 [0,1,2,3,3,4,4,5,4,3] ，最高建筑的高度为 5 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 10<sup>9</sup></code></li>\n\t<li><code>0 <= restrictions.length <= min(n - 1, 10<sup>5</sup>)</code></li>\n\t<li><code>2 <= id<sub>i</sub> <= n</code></li>\n\t<li><code>id<sub>i</sub></code> 是 <strong>唯一的</strong> 。</li>\n\t<li><code>0 <= maxHeight<sub>i</sub> <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1841.联赛信息统计",
        "hardRate": "MEDIUM",
        "passRate": "52.71%",
        "problemsUrl": "https://leetcode.cn/problems/league-statistics/",
        "solutionsUrl": "https://leetcode.cn/problems/league-statistics/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1842.下个由相同数字构成的回文串",
        "hardRate": "HARD",
        "passRate": "55.71%",
        "problemsUrl": "https://leetcode.cn/problems/next-palindrome-using-same-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/next-palindrome-using-same-digits/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1843.可疑银行账户",
        "hardRate": "MEDIUM",
        "passRate": "43.76%",
        "problemsUrl": "https://leetcode.cn/problems/suspicious-bank-accounts/",
        "solutionsUrl": "https://leetcode.cn/problems/suspicious-bank-accounts/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1844.将所有数字用字符替换",
        "hardRate": "EASY",
        "passRate": "78.63%",
        "problemsUrl": "https://leetcode.cn/problems/replace-all-digits-with-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/replace-all-digits-with-characters/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，它的 <strong>偶数</strong> 下标处为小写英文字母，<strong>奇数</strong> 下标处为数字。</p>\n\n<p>定义一个函数 <code>shift(c, x)</code> ，其中 <code>c</code> 是一个字符且 <code>x</code> 是一个数字，函数返回字母表中 <code>c</code> 后面第 <code>x</code> 个字符。</p>\n\n<ul>\n\t<li>比方说，<code>shift('a', 5) = 'f'</code> 和 <code>shift('x', 0) = 'x'</code> 。</li>\n</ul>\n\n<p>对于每个 <strong>奇数</strong> 下标 <code>i</code> ，你需要将数字 <code>s[i]</code> 用 <code>shift(s[i-1], s[i])</code> 替换。</p>\n\n<p>请你替换所有数字以后，将字符串 <code>s</code> 返回。题目 <strong>保证</strong><em> </em><code>shift(s[i-1], s[i])</code> 不会超过 <code>'z'</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"a1c1e1\"\n<b>输出：</b>\"abcdef\"\n<strong>解释：</strong>数字被替换结果如下：\n- s[1] -&gt; shift('a',1) = 'b'\n- s[3] -&gt; shift('c',1) = 'd'\n- s[5] -&gt; shift('e',1) = 'f'</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"a1b2c3d4e\"\n<b>输出：</b>\"abbdcfdhe\"\n<strong>解释：</strong>数字被替换结果如下：\n- s[1] -&gt; shift('a',1) = 'b'\n- s[3] -&gt; shift('b',2) = 'd'\n- s[5] -&gt; shift('c',3) = 'f'\n- s[7] -&gt; shift('d',4) = 'h'</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 只包含小写英文字母和数字。</li>\n\t<li>对所有 <strong>奇数</strong> 下标处的 <code>i</code> ，满足 <code>shift(s[i-1], s[i]) &lt;= 'z'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1845.座位预约管理系统",
        "hardRate": "MEDIUM",
        "passRate": "48.12%",
        "problemsUrl": "https://leetcode.cn/problems/seat-reservation-manager/",
        "solutionsUrl": "https://leetcode.cn/problems/seat-reservation-manager/solution",
        "problemsDesc": "<p>请你设计一个管理 <code>n</code> 个座位预约的系统，座位编号从 <code>1</code> 到 <code>n</code> 。</p>\n\n<p>请你实现 <code>SeatManager</code> 类：</p>\n\n<ul>\n\t<li><code>SeatManager(int n)</code> 初始化一个 <code>SeatManager</code> 对象，它管理从 <code>1</code> 到 <code>n</code> 编号的 <code>n</code> 个座位。所有座位初始都是可预约的。</li>\n\t<li><code>int reserve()</code> 返回可以预约座位的 <strong>最小编号</strong> ，此座位变为不可预约。</li>\n\t<li><code>void unreserve(int seatNumber)</code> 将给定编号 <code>seatNumber</code> 对应的座位变成可以预约。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>\n[\"SeatManager\", \"reserve\", \"reserve\", \"unreserve\", \"reserve\", \"reserve\", \"reserve\", \"reserve\", \"unreserve\"]\n[[5], [], [], [2], [], [], [], [], [5]]\n<strong>输出：</strong>\n[null, 1, 2, null, 2, 3, 4, 5, null]\n\n<strong>解释：</strong>\nSeatManager seatManager = new SeatManager(5); // 初始化 SeatManager ，有 5 个座位。\nseatManager.reserve();    // 所有座位都可以预约，所以返回最小编号的座位，也就是 1 。\nseatManager.reserve();    // 可以预约的座位为 [2,3,4,5] ，返回最小编号的座位，也就是 2 。\nseatManager.unreserve(2); // 将座位 2 变为可以预约，现在可预约的座位为 [2,3,4,5] 。\nseatManager.reserve();    // 可以预约的座位为 [2,3,4,5] ，返回最小编号的座位，也就是 2 。\nseatManager.reserve();    // 可以预约的座位为 [3,4,5] ，返回最小编号的座位，也就是 3 。\nseatManager.reserve();    // 可以预约的座位为 [4,5] ，返回最小编号的座位，也就是 4 。\nseatManager.reserve();    // 唯一可以预约的是座位 5 ，所以返回 5 。\nseatManager.unreserve(5); // 将座位 5 变为可以预约，现在可预约的座位为 [5] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= seatNumber &lt;= n</code></li>\n\t<li>每一次对 <code>reserve</code> 的调用，题目保证至少存在一个可以预约的座位。</li>\n\t<li>每一次对 <code>unreserve</code> 的调用，题目保证 <code>seatNumber</code> 在调用函数前都是被预约状态。</li>\n\t<li>对 <code>reserve</code> 和 <code>unreserve</code> 的调用 <strong>总共</strong> 不超过 <code>10<sup>5</sup></code> 次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1846.减小和重新排列数组后的最大元素",
        "hardRate": "MEDIUM",
        "passRate": "63.06%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-element-after-decreasing-and-rearranging/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-element-after-decreasing-and-rearranging/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>arr</code> 。请你对 <code>arr</code> 执行一些操作（也可以不进行任何操作），使得数组满足以下条件：</p>\n\n<ul>\n\t<li><code>arr</code> 中 <strong>第一个</strong> 元素必须为 <code>1</code> 。</li>\n\t<li>任意相邻两个元素的差的绝对值 <strong>小于等于</strong> <code>1</code> ，也就是说，对于任意的 <code>1 <= i < arr.length</code> （<strong>数组下标从 0 开始</strong>），都满足 <code>abs(arr[i] - arr[i - 1]) <= 1</code> 。<code>abs(x)</code> 为 <code>x</code> 的绝对值。</li>\n</ul>\n\n<p>你可以执行以下 2 种操作任意次：</p>\n\n<ul>\n\t<li><strong>减小</strong> <code>arr</code> 中任意元素的值，使其变为一个 <strong>更小的正整数</strong> 。</li>\n\t<li><strong>重新排列</strong> <code>arr</code> 中的元素，你可以以任意顺序重新排列。</li>\n</ul>\n\n<p>请你返回执行以上操作后，在满足前文所述的条件下，<code>arr</code> 中可能的 <strong>最大值</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [2,2,1,2,1]\n<b>输出：</b>2\n<b>解释：</b>\n我们可以重新排列 arr 得到 <code>[1,2,2,2,1] ，该数组满足所有条件。</code>\narr 中最大元素为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [100,1,1000]\n<b>输出：</b>3\n<b>解释：</b>\n一个可行的方案如下：\n1. 重新排列 <code>arr</code> 得到 <code>[1,100,1000] 。</code>\n2. 将第二个元素减小为 2 。\n3. 将第三个元素减小为 3 。\n现在 <code>arr = [1,2,3] ，满足所有条件。</code>\narr 中最大元素为 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>arr = [1,2,3,4,5]\n<b>输出：</b>5\n<b>解释：</b>数组已经满足所有条件，最大元素为 5 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= arr.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= arr[i] <= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1847.最近的房间",
        "hardRate": "HARD",
        "passRate": "39.92%",
        "problemsUrl": "https://leetcode.cn/problems/closest-room/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-room/solution",
        "problemsDesc": "<p>一个酒店里有 <code>n</code> 个房间，这些房间用二维整数数组 <code>rooms</code> 表示，其中 <code>rooms[i] = [roomId<sub>i</sub>, size<sub>i</sub>]</code> 表示有一个房间号为 <code>roomId<sub>i</sub></code> 的房间且它的面积为 <code>size<sub>i</sub></code> 。每一个房间号 <code>roomId<sub>i</sub></code> 保证是 <strong>独一无二</strong> 的。</p>\n\n<p>同时给你 <code>k</code> 个查询，用二维数组 <code>queries</code> 表示，其中 <code>queries[j] = [preferred<sub>j</sub>, minSize<sub>j</sub>]</code> 。第 <code>j</code> 个查询的答案是满足如下条件的房间 <code>id</code> ：</p>\n\n<ul>\n\t<li>房间的面积 <b>至少</b> 为 <code>minSize<sub>j</sub></code> ，且</li>\n\t<li><code>abs(id - preferred<sub>j</sub>)</code> 的值 <strong>最小</strong> ，其中 <code>abs(x)</code> 是 <code>x</code> 的绝对值。</li>\n</ul>\n\n<p>如果差的绝对值有 <strong>相等</strong> 的，选择 <strong>最小</strong> 的 <code>id</code> 。如果 <strong>没有满足条件的房间</strong> ，答案为 <code>-1</code> 。</p>\n\n<p>请你返回长度为 <code>k</code> 的数组 <code>answer</code> ，其中<em> </em><code>answer[j]</code> 为第 <code>j</code> 个查询的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>rooms = [[2,2],[1,2],[3,2]], queries = [[3,1],[3,3],[5,2]]\n<b>输出：</b>[3,-1,3]\n<strong>解释：</strong>查询的答案如下：\n查询 [3,1] ：房间 3 的面积为 2 ，大于等于 1 ，且号码是最接近 3 的，为 abs(3 - 3) = 0 ，所以答案为 3 。\n查询 [3,3] ：没有房间的面积至少为 3 ，所以答案为 -1 。\n查询 [5,2] ：房间 3 的面积为 2 ，大于等于 2 ，且号码是最接近 5 的，为 abs(3 - 5) = 2 ，所以答案为 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>rooms = [[1,4],[2,3],[3,5],[4,1],[5,2]], queries = [[2,3],[2,4],[2,5]]\n<b>输出：</b>[2,1,3]\n<strong>解释：</strong>查询的答案如下：\n查询 [2,3] ：房间 2 的面积为 3 ，大于等于 3 ，且号码是最接近的，为 abs(2 - 2) = 0 ，所以答案为 2 。\n查询 [2,4] ：房间 1 和 3 的面积都至少为 4 ，答案为 1 因为它房间编号更小。\n查询 [2,5] ：房间 3 是唯一面积大于等于 5 的，所以答案为 3 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == rooms.length</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>k == queries.length</code></li>\n\t<li><code>1 <= k <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= roomId<sub>i</sub>, preferred<sub>j</sub> <= 10<sup>7</sup></code></li>\n\t<li><code>1 <= size<sub>i</sub>, minSize<sub>j</sub> <= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1848.到目标元素的最小距离",
        "hardRate": "EASY",
        "passRate": "66.17%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-distance-to-the-target-element/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-distance-to-the-target-element/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> （下标 <strong>从 0 开始</strong> 计数）以及两个整数 <code>target</code> 和 <code>start</code> ，请你找出一个下标 <code>i</code> ，满足 <code>nums[i] == target</code> 且 <code>abs(i - start)</code> <strong>最小化</strong> 。注意：<code>abs(x)</code> 表示 <code>x</code> 的绝对值。</p>\n\n<p>返回 <code>abs(i - start)</code> 。</p>\n\n<p>题目数据保证 <code>target</code> 存在于 <code>nums</code> 中。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4,5], target = 5, start = 3\n<strong>输出：</strong>1\n<strong>解释：</strong>nums[4] = 5 是唯一一个等于 target 的值，所以答案是 abs(4 - 3) = 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1], target = 1, start = 0\n<strong>输出：</strong>0\n<strong>解释：</strong>nums[0] = 1 是唯一一个等于 target 的值，所以答案是 abs(0 - 0) = 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0\n<strong>输出：</strong>0\n<strong>解释：</strong>nums 中的每个值都是 1 ，但 nums[0] 使 abs(i - start) 的结果得以最小化，所以答案是 abs(0 - 0) = 0 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 1000</code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>4</sup></code></li>\n\t<li><code>0 <= start < nums.length</code></li>\n\t<li><code>target</code> 存在于 <code>nums</code> 中</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1849.将字符串拆分为递减的连续值",
        "hardRate": "MEDIUM",
        "passRate": "33.22%",
        "problemsUrl": "https://leetcode.cn/problems/splitting-a-string-into-descending-consecutive-values/",
        "solutionsUrl": "https://leetcode.cn/problems/splitting-a-string-into-descending-consecutive-values/solution",
        "problemsDesc": "<p>给你一个仅由数字组成的字符串 <code>s</code> 。</p>\n\n<p>请你判断能否将 <code>s</code> 拆分成两个或者多个 <strong>非空子字符串</strong> ，使子字符串的 <strong>数值</strong> 按 <strong>降序</strong> 排列，且每两个 <strong>相邻子字符串</strong> 的数值之 <strong>差 </strong>等于 <code>1</code> 。</p>\n\n<ul>\n\t<li>例如，字符串 <code>s = \"0090089\"</code> 可以拆分成 <code>[\"0090\", \"089\"]</code> ，数值为 <code>[90,89]</code> 。这些数值满足按降序排列，且相邻值相差 <code>1</code> ，这种拆分方法可行。</li>\n\t<li>另一个例子中，字符串 <code>s = \"001\"</code> 可以拆分成 <code>[\"0\", \"01\"]</code>、<code>[\"00\", \"1\"]</code> 或 <code>[\"0\", \"0\", \"1\"]</code> 。然而，所有这些拆分方法都不可行，因为对应数值分别是 <code>[0,1]</code>、<code>[0,1]</code> 和 <code>[0,0,1]</code> ，都不满足按降序排列的要求。</li>\n</ul>\n\n<p>如果可以按要求拆分 <code>s</code> ，返回 <code>true</code> ；否则，返回 <code>false</code><em> </em>。</p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1234\"\n<strong>输出：</strong>false\n<strong>解释：</strong>不存在拆分 s 的可行方法。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"050043\"\n<strong>输出：</strong>true\n<strong>解释：</strong>s 可以拆分为 [\"05\", \"004\", \"3\"] ，对应数值为 [5,4,3] 。\n满足按降序排列，且相邻值相差 <code>1</code> 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"9080701\"\n<strong>输出：</strong>false\n<strong>解释：</strong>不存在拆分 s 的可行方法。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"10009998\"\n<strong>输出：</strong>true\n<strong>解释：</strong>s 可以拆分为 [\"100\", \"099\", \"98\"] ，对应数值为 [100,99,98] 。\n满足按降序排列，且相邻值相差 <code>1</code> 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 20</code></li>\n\t<li><code>s</code> 仅由数字组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1850.邻位交换的最小次数",
        "hardRate": "MEDIUM",
        "passRate": "62.77%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/solution",
        "problemsDesc": "<p>给你一个表示大整数的字符串 <code>num</code> ，和一个整数 <code>k</code> 。</p>\n\n<p>如果某个整数是 <code>num</code> 中各位数字的一个 <strong>排列</strong> 且它的 <strong>值大于</strong> <code>num</code> ，则称这个整数为 <strong>妙数</strong> 。可能存在很多妙数，但是只需要关注 <strong>值最小</strong> 的那些。</p>\n\n<ul>\n\t<li>例如，<code>num = \"5489355142\"</code> ：\n\n\t<ul>\n\t\t<li>第 1 个最小妙数是 <code>\"5489355214\"</code></li>\n\t\t<li>第 2 个最小妙数是 <code>\"5489355241\"</code></li>\n\t\t<li>第 3 个最小妙数是 <code>\"5489355412\"</code></li>\n\t\t<li>第 4 个最小妙数是 <code>\"5489355421\"</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>返回要得到第 <code>k</code> 个 <strong>最小妙数</strong> 需要对 <code>num</code> 执行的 <strong>相邻位数字交换的最小次数</strong> 。</p>\n\n<p>测试用例是按存在第 <code>k</code> 个最小妙数而生成的。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = \"5489355142\", k = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>第 4 个最小妙数是 \"5489355421\" ，要想得到这个数字：\n- 交换下标 7 和下标 8 对应的位：\"5489355<strong>14</strong>2\" -&gt; \"5489355<strong>41</strong>2\"\n- 交换下标 8 和下标 9 对应的位：\"54893554<strong>12</strong>\" -&gt; \"54893554<strong>21</strong>\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = \"11112\", k = 4\n<strong>输出：</strong>4\n<strong>解释：</strong>第 4 个最小妙数是 \"21111\" ，要想得到这个数字：\n- 交换下标 3 和下标 4 对应的位：\"111<strong>12</strong>\" -&gt; \"111<strong>21</strong>\"\n- 交换下标 2 和下标 3 对应的位：\"11<strong>12</strong>1\" -&gt; \"11<strong>21</strong>1\"\n- 交换下标 1 和下标 2 对应的位：\"1<strong>12</strong>11\" -&gt; \"1<strong>21</strong>11\"\n- 交换下标 0 和下标 1 对应的位：\"<strong>12</strong>111\" -&gt; \"<strong>21</strong>111\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = \"00123\", k = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>第 1 个最小妙数是 \"00132\" ，要想得到这个数字：\n- 交换下标 3 和下标 4 对应的位：\"001<strong>23</strong>\" -&gt; \"001<strong>32</strong>\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= num.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= k &lt;= 1000</code></li>\n\t<li><code>num</code> 仅由数字组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1851.包含每个查询的最小区间",
        "hardRate": "HARD",
        "passRate": "44.07%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-interval-to-include-each-query/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-interval-to-include-each-query/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>intervals</code> ，其中 <code>intervals[i] = [left<sub>i</sub>, right<sub>i</sub>]</code> 表示第 <code>i</code> 个区间开始于 <code>left<sub>i</sub></code> 、结束于 <code>right<sub>i</sub></code>（包含两侧取值，<strong>闭区间</strong>）。区间的 <strong>长度</strong> 定义为区间中包含的整数数目，更正式地表达是 <code>right<sub>i</sub> - left<sub>i</sub> + 1</code> 。</p>\n\n<p>再给你一个整数数组 <code>queries</code> 。第 <code>j</code> 个查询的答案是满足 <code>left<sub>i</sub> <= queries[j] <= right<sub>i</sub></code> 的 <strong>长度最小区间 <code>i</code> 的长度</strong> 。如果不存在这样的区间，那么答案是 <code>-1</code> 。</p>\n\n<p>以数组形式返回对应查询的所有答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]\n<strong>输出：</strong>[3,3,1,4]\n<strong>解释：</strong>查询处理如下：\n- Query = 2 ：区间 [2,4] 是包含 2 的最小区间，答案为 4 - 2 + 1 = 3 。\n- Query = 3 ：区间 [2,4] 是包含 3 的最小区间，答案为 4 - 2 + 1 = 3 。\n- Query = 4 ：区间 [4,4] 是包含 4 的最小区间，答案为 4 - 4 + 1 = 1 。\n- Query = 5 ：区间 [3,6] 是包含 5 的最小区间，答案为 6 - 3 + 1 = 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]\n<strong>输出：</strong>[2,-1,4,6]\n<strong>解释：</strong>查询处理如下：\n- Query = 2 ：区间 [2,3] 是包含 2 的最小区间，答案为 3 - 2 + 1 = 2 。\n- Query = 19：不存在包含 19 的区间，答案为 -1 。\n- Query = 5 ：区间 [2,5] 是包含 5 的最小区间，答案为 5 - 2 + 1 = 4 。\n- Query = 22：区间 [20,25] 是包含 22 的最小区间，答案为 25 - 20 + 1 = 6 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= intervals.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= queries.length <= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>1 <= left<sub>i</sub> <= right<sub>i</sub> <= 10<sup>7</sup></code></li>\n\t<li><code>1 <= queries[j] <= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1852.每个子数组的数字种类数",
        "hardRate": "MEDIUM",
        "passRate": "59.49%",
        "problemsUrl": "https://leetcode.cn/problems/distinct-numbers-in-each-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/distinct-numbers-in-each-subarray/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1853.转换日期格式",
        "hardRate": "EASY",
        "passRate": "62.84%",
        "problemsUrl": "https://leetcode.cn/problems/convert-date-format/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-date-format/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1854.人口最多的年份",
        "hardRate": "EASY",
        "passRate": "72.34%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-population-year/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-population-year/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>logs</code> ，其中每个 <code>logs[i] = [birth<sub>i</sub>, death<sub>i</sub>]</code> 表示第 <code>i</code> 个人的出生和死亡年份。</p>\n\n<p>年份 <code>x</code> 的 <strong>人口</strong> 定义为这一年期间活着的人的数目。第 <code>i</code> 个人被计入年份 <code>x</code> 的人口需要满足：<code>x</code> 在闭区间 <code>[birth<sub>i</sub>, death<sub>i</sub> - 1]</code> 内。注意，人不应当计入他们死亡当年的人口中。</p>\n\n<p>返回 <strong>人口最多</strong> 且 <strong>最早</strong> 的年份。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>logs = [[1993,1999],[2000,2010]]\n<strong>输出：</strong>1993\n<strong>解释：</strong>人口最多为 1 ，而 1993 是人口为 1 的最早年份。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>logs = [[1950,1961],[1960,1971],[1970,1981]]\n<strong>输出：</strong>1960\n<strong>解释：</strong> \n人口最多为 2 ，分别出现在 1960 和 1970 。\n其中最早年份是 1960 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= logs.length &lt;= 100</code></li>\n\t<li><code>1950 &lt;= birth<sub>i</sub> &lt; death<sub>i</sub> &lt;= 2050</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1855.下标对中的最大距离",
        "hardRate": "MEDIUM",
        "passRate": "59.43%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-distance-between-a-pair-of-values/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-distance-between-a-pair-of-values/solution",
        "problemsDesc": "<p>给你两个 <strong>非递增</strong> 的整数数组 <code>nums1</code>​​​​​​ 和 <code>nums2</code>​​​​​​ ，数组下标均 <strong>从 0 开始</strong> 计数。</p>\n\n<p>下标对 <code>(i, j)</code> 中 <code>0 &lt;= i &lt; nums1.length</code> 且 <code>0 &lt;= j &lt; nums2.length</code> 。如果该下标对同时满足 <code>i &lt;= j</code> 且 <code>nums1[i] &lt;= nums2[j]</code> ，则称之为 <strong>有效</strong> 下标对，该下标对的 <strong>距离</strong> 为 <code>j - i</code>​​ 。​​</p>\n\n<p>返回所有 <strong>有效</strong> 下标对<em> </em><code>(i, j)</code><em> </em>中的 <strong>最大距离</strong> 。如果不存在有效下标对，返回 <code>0</code> 。</p>\n\n<p>一个数组 <code>arr</code> ，如果每个 <code>1 &lt;= i &lt; arr.length</code> 均有 <code>arr[i-1] &gt;= arr[i]</code> 成立，那么该数组是一个 <strong>非递增</strong> 数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [55,30,5,4,2], nums2 = [100,20,10,10,5]\n<strong>输出：</strong>2\n<strong>解释：</strong>有效下标对是 (0,0), (2,2), (2,3), (2,4), (3,3), (3,4) 和 (4,4) 。\n最大距离是 2 ，对应下标对 (2,4) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [2,2,2], nums2 = [10,10,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>有效下标对是 (0,0), (0,1) 和 (1,1) 。\n最大距离是 1 ，对应下标对 (0,1) 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [30,29,19,5], nums2 = [25,25,25,25,25]\n<strong>输出：</strong>2\n<strong>解释：</strong>有效下标对是 (2,2), (2,3), (2,4), (3,3) 和 (3,4) 。\n最大距离是 2 ，对应下标对 (2,4) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums1</code> 和 <code>nums2</code> 都是 <strong>非递增</strong> 数组</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1856.子数组最小乘积的最大值",
        "hardRate": "MEDIUM",
        "passRate": "37.44%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-subarray-min-product/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-subarray-min-product/solution",
        "problemsDesc": "<p>一个数组的 <strong>最小乘积</strong> 定义为这个数组中 <strong>最小值</strong> <strong>乘以 </strong>数组的 <strong>和</strong> 。</p>\n\n<ul>\n\t<li>比方说，数组 <code>[3,2,5]</code> （最小值是 <code>2</code>）的最小乘积为 <code>2 * (3+2+5) = 2 * 10 = 20</code> 。</li>\n</ul>\n\n<p>给你一个正整数数组 <code>nums</code> ，请你返回 <code>nums</code> 任意 <strong>非空子数组</strong> 的<strong>最小乘积</strong> 的 <strong>最大值</strong> 。由于答案可能很大，请你返回答案对  <code>10<sup>9</sup> + 7</code> <strong>取余 </strong>的结果。</p>\n\n<p>请注意，最小乘积的最大值考虑的是取余操作 <strong>之前</strong> 的结果。题目保证最小乘积的最大值在 <strong>不取余</strong> 的情况下可以用 <strong>64 位有符号整数</strong> 保存。</p>\n\n<p><strong>子数组</strong> 定义为一个数组的 <strong>连续</strong> 部分。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,<strong>2,3,2</strong>]\n<b>输出：</b>14\n<b>解释：</b>最小乘积的最大值由子数组 [2,3,2] （最小值是 2）得到。\n2 * (2+3+2) = 2 * 7 = 14 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,<strong>3,3</strong>,1,2]\n<b>输出：</b>18\n<b>解释：</b>最小乘积的最大值由子数组 [3,3] （最小值是 3）得到。\n3 * (3+3) = 3 * 6 = 18 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,1,<strong>5,6,4</strong>,2]\n<b>输出：</b>60\n<b>解释：</b>最小乘积的最大值由子数组 [5,6,4] （最小值是 4）得到。\n4 * (5+6+4) = 4 * 15 = 60 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1857.有向图中最大颜色值",
        "hardRate": "HARD",
        "passRate": "49.03%",
        "problemsUrl": "https://leetcode.cn/problems/largest-color-value-in-a-directed-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-color-value-in-a-directed-graph/solution",
        "problemsDesc": "<p>给你一个 <strong>有向图</strong> ，它含有 <code>n</code> 个节点和 <code>m</code> 条边。节点编号从 <code>0</code> 到 <code>n - 1</code> 。</p>\n\n<p>给你一个字符串 <code>colors</code> ，其中 <code>colors[i]</code> 是小写英文字母，表示图中第 <code>i</code> 个节点的 <b>颜色</b> （下标从 <strong>0</strong> 开始）。同时给你一个二维数组 <code>edges</code> ，其中 <code>edges[j] = [a<sub>j</sub>, b<sub>j</sub>]</code> 表示从节点 <code>a<sub>j</sub></code> 到节点 <code>b<sub>j</sub></code><sub> </sub>有一条 <strong>有向边</strong> 。</p>\n\n<p>图中一条有效 <strong>路径</strong> 是一个点序列 <code>x<sub>1</sub> -&gt; x<sub>2</sub> -&gt; x<sub>3</sub> -&gt; ... -&gt; x<sub>k</sub></code> ，对于所有 <code>1 &lt;= i &lt; k</code> ，从 <code>x<sub>i</sub></code> 到 <code>x<sub>i+1</sub></code> 在图中有一条有向边。路径的 <strong>颜色值</strong> 是路径中 <strong>出现次数最多</strong> 颜色的节点数目。</p>\n\n<p>请你返回给定图中有效路径里面的 <strong>最大颜色值</strong><strong> 。</strong>如果图中含有环，请返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/21/leet1.png\" style=\"width: 400px; height: 182px;\"></p>\n\n<pre><b>输入：</b>colors = \"abaca\", edges = [[0,1],[0,2],[2,3],[3,4]]\n<b>输出：</b>3\n<b>解释：</b>路径 0 -&gt; 2 -&gt; 3 -&gt; 4 含有 3 个颜色为 <code>\"a\" 的节点（上图中的红色节点）。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/21/leet2.png\" style=\"width: 85px; height: 85px;\"></p>\n\n<pre><b>输入：</b>colors = \"a\", edges = [[0,0]]\n<b>输出：</b>-1\n<b>解释：</b>从 0 到 0 有一个环。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == colors.length</code></li>\n\t<li><code>m == edges.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>colors</code> 只含有小写英文字母。</li>\n\t<li><code>0 &lt;= a<sub>j</sub>, b<sub>j</sub> &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1858.包含所有前缀的最长单词",
        "hardRate": "MEDIUM",
        "passRate": "66.05%",
        "problemsUrl": "https://leetcode.cn/problems/longest-word-with-all-prefixes/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-word-with-all-prefixes/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1859.将句子排序",
        "hardRate": "EASY",
        "passRate": "72.85%",
        "problemsUrl": "https://leetcode.cn/problems/sorting-the-sentence/",
        "solutionsUrl": "https://leetcode.cn/problems/sorting-the-sentence/solution",
        "problemsDesc": "<p>一个 <strong>句子</strong> 指的是一个序列的单词用单个空格连接起来，且开头和结尾没有任何空格。每个单词都只包含小写或大写英文字母。</p>\n\n<p>我们可以给一个句子添加 <strong>从 1 开始的单词位置索引 </strong>，并且将句子中所有单词 <strong>打乱顺序</strong> 。</p>\n\n<ul>\n\t<li>比方说，句子 <code>\"This is a sentence\"</code> 可以被打乱顺序得到 <code>\"sentence4 a3 is2 This1\"</code> 或者 <code>\"is2 sentence4 This1 a3\"</code> 。</li>\n</ul>\n\n<p>给你一个 <strong>打乱顺序</strong> 的句子 <code>s</code> ，它包含的单词不超过 <code>9</code> 个，请你重新构造并得到原本顺序的句子。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"is2 sentence4 This1 a3\"\n<b>输出：</b>\"This is a sentence\"\n<b>解释：</b>将 s 中的单词按照初始位置排序，得到 \"This1 is2 a3 sentence4\" ，然后删除数字。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"Myself2 Me1 I4 and3\"\n<b>输出：</b>\"Me Myself and I\"\n<b>解释：</b>将 s 中的单词按照初始位置排序，得到 \"Me1 Myself2 and3 I4\" ，然后删除数字。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= s.length <= 200</code></li>\n\t<li><code>s</code> 只包含小写和大写英文字母、空格以及从 <code>1</code> 到 <code>9</code> 的数字。</li>\n\t<li><code>s</code> 中单词数目为 <code>1</code> 到 <code>9</code> 个。</li>\n\t<li><code>s</code> 中的单词由单个空格分隔。</li>\n\t<li><code>s</code> 不包含任何前导或者后缀空格。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1860.增长的内存泄露",
        "hardRate": "MEDIUM",
        "passRate": "76.01%",
        "problemsUrl": "https://leetcode.cn/problems/incremental-memory-leak/",
        "solutionsUrl": "https://leetcode.cn/problems/incremental-memory-leak/solution",
        "problemsDesc": "<p>给你两个整数 <code>memory1</code> 和 <code>memory2</code> 分别表示两个内存条剩余可用内存的位数。现在有一个程序每秒递增的速度消耗着内存。</p>\n\n<p>在第 <code>i</code> 秒（秒数从 1 开始），有 <code>i</code> 位内存被分配到 <strong>剩余内存较多</strong> 的内存条（如果两者一样多，则分配到第一个内存条）。如果两者剩余内存都不足 <code>i</code> 位，那么程序将 <b>意外退出</b> 。</p>\n\n<p>请你返回一个数组，包含<em> </em><code>[crashTime, memory1<sub>crash</sub>, memory2<sub>crash</sub>]</code> ，其中 <code>crashTime</code>是程序意外退出的时间（单位为秒），<em> </em><code>memory1<sub>crash</sub></code><em> </em>和<em> </em><code>memory2<sub>crash</sub></code><em> </em>分别是两个内存条最后剩余内存的位数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>memory1 = 2, memory2 = 2\n<b>输出：</b>[3,1,0]\n<b>解释：</b>内存分配如下：\n- 第 1 秒，内存条 1 被占用 1 位内存。内存条 1 现在有 1 位剩余可用内存。\n- 第 2 秒，内存条 2 被占用 2 位内存。内存条 2 现在有 0 位剩余可用内存。\n- 第 3 秒，程序意外退出，两个内存条分别有 1 位和 0 位剩余可用内存。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>memory1 = 8, memory2 = 11\n<b>输出：</b>[6,0,4]\n<b>解释：</b>内存分配如下：\n- 第 1 秒，内存条 2 被占用 1 位内存，内存条 2 现在有 10 位剩余可用内存。\n- 第 2 秒，内存条 2 被占用 2 位内存，内存条 2 现在有 8 位剩余可用内存。\n- 第 3 秒，内存条 1 被占用 3 位内存，内存条 1 现在有 5 位剩余可用内存。\n- 第 4 秒，内存条 2 被占用 4 位内存，内存条 2 现在有 4 位剩余可用内存。\n- 第 5 秒，内存条 1 被占用 5 位内存，内存条 1 现在有 0 位剩余可用内存。\n- 第 6 秒，程序意外退出，两个内存条分别有 0 位和 4 位剩余可用内存。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= memory1, memory2 &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1861.旋转盒子",
        "hardRate": "MEDIUM",
        "passRate": "63.40%",
        "problemsUrl": "https://leetcode.cn/problems/rotating-the-box/",
        "solutionsUrl": "https://leetcode.cn/problems/rotating-the-box/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的字符矩阵 <code>box</code> ，它表示一个箱子的侧视图。箱子的每一个格子可能为：</p>\n\n<ul>\n\t<li><code>'#'</code> 表示石头</li>\n\t<li><code>'*'</code> 表示固定的障碍物</li>\n\t<li><code>'.'</code> 表示空位置</li>\n</ul>\n\n<p>这个箱子被 <strong>顺时针旋转 90 度</strong> ，由于重力原因，部分石头的位置会发生改变。每个石头会垂直掉落，直到它遇到障碍物，另一个石头或者箱子的底部。重力 <strong>不会</strong> 影响障碍物的位置，同时箱子旋转不会产生<strong>惯性</strong> ，也就是说石头的水平位置不会发生改变。</p>\n\n<p>题目保证初始时 <code>box</code> 中的石头要么在一个障碍物上，要么在另一个石头上，要么在箱子的底部。</p>\n\n<p>请你返回一个<em> </em><code>n x m</code>的矩阵，表示按照上述旋转后，箱子内的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcodewithstones.png\" style=\"width: 300px; height: 150px;\"></p>\n\n<pre><b>输入：</b>box = [[\"#\",\".\",\"#\"]]\n<b>输出：</b>[[\".\"],\n      [\"#\"],\n      [\"#\"]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcode2withstones.png\" style=\"width: 375px; height: 195px;\"></p>\n\n<pre><b>输入：</b>box = [[\"#\",\".\",\"*\",\".\"],\n            [\"#\",\"#\",\"*\",\".\"]]\n<b>输出：</b>[[\"#\",\".\"],\n      [\"#\",\"#\"],\n      [\"*\",\"*\"],\n      [\".\",\".\"]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcode3withstone.png\" style=\"width: 400px; height: 218px;\"></p>\n\n<pre><b>输入：</b>box = [[\"#\",\"#\",\"*\",\".\",\"*\",\".\"],\n            [\"#\",\"#\",\"#\",\"*\",\".\",\".\"],\n            [\"#\",\"#\",\"#\",\".\",\"#\",\".\"]]\n<b>输出：</b>[[\".\",\"#\",\"#\"],\n      [\".\",\"#\",\"#\"],\n      [\"#\",\"#\",\"*\"],\n      [\"#\",\"*\",\".\"],\n      [\"#\",\".\",\"*\"],\n      [\"#\",\".\",\".\"]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == box.length</code></li>\n\t<li><code>n == box[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>box[i][j]</code> 只可能是 <code>'#'</code> ，<code>'*'</code> 或者 <code>'.'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1862.向下取整数对和",
        "hardRate": "HARD",
        "passRate": "34.66%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-floored-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-floored-pairs/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，请你返回所有下标对 <code>0 &lt;= i, j &lt; nums.length</code> 的 <code>floor(nums[i] / nums[j])</code> 结果之和。由于答案可能会很大，请你返回答案对<code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p>函数 <code>floor()</code> 返回输入数字的整数部分。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,5,9]\n<b>输出：</b>10\n<strong>解释：</strong>\nfloor(2 / 5) = floor(2 / 9) = floor(5 / 9) = 0\nfloor(2 / 2) = floor(5 / 5) = floor(9 / 9) = 1\nfloor(5 / 2) = 2\nfloor(9 / 2) = 4\nfloor(9 / 5) = 1\n我们计算每一个数对商向下取整的结果并求和得到 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [7,7,7,7,7,7,7]\n<b>输出：</b>49\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1863.找出所有子集的异或总和再求和",
        "hardRate": "EASY",
        "passRate": "84.01%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-all-subset-xor-totals/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-all-subset-xor-totals/solution",
        "problemsDesc": "<p>一个数组的<strong> 异或总和</strong> 定义为数组中所有元素按位 <code>XOR</code> 的结果；如果数组为 <strong>空</strong> ，则异或总和为 <code>0</code> 。</p>\n\n<ul>\n\t<li>例如，数组 <code>[2,5,6]</code> 的 <strong>异或总和</strong> 为 <code>2 XOR 5 XOR 6 = 1</code> 。</li>\n</ul>\n\n<p>给你一个数组 <code>nums</code> ，请你求出 <code>nums</code> 中每个 <strong>子集</strong> 的 <strong>异或总和</strong> ，计算并返回这些值相加之 <strong>和</strong> 。</p>\n\n<p><strong>注意：</strong>在本题中，元素 <strong>相同</strong> 的不同子集应 <strong>多次</strong> 计数。</p>\n\n<p>数组 <code>a</code> 是数组 <code>b</code> 的一个 <strong>子集</strong> 的前提条件是：从 <code>b</code> 删除几个（也可能不删除）元素能够得到 <code>a</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3]\n<strong>输出：</strong>6\n<strong>解释：</strong>[1,3] 共有 4 个子集：\n- 空子集的异或总和是 0 。\n- [1] 的异或总和为 1 。\n- [3] 的异或总和为 3 。\n- [1,3] 的异或总和为 1 XOR 3 = 2 。\n0 + 1 + 3 + 2 = 6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,1,6]\n<strong>输出：</strong>28\n<strong>解释：</strong>[5,1,6] 共有 8 个子集：\n- 空子集的异或总和是 0 。\n- [5] 的异或总和为 5 。\n- [1] 的异或总和为 1 。\n- [6] 的异或总和为 6 。\n- [5,1] 的异或总和为 5 XOR 1 = 4 。\n- [5,6] 的异或总和为 5 XOR 6 = 3 。\n- [1,6] 的异或总和为 1 XOR 6 = 7 。\n- [5,1,6] 的异或总和为 5 XOR 1 XOR 6 = 2 。\n0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,4,5,6,7,8]\n<strong>输出：</strong>480\n<strong>解释：</strong>每个子集的全部异或总和值之和为 480 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 12</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1864.构成交替字符串需要的最小交换次数",
        "hardRate": "MEDIUM",
        "passRate": "40.85%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating/solution",
        "problemsDesc": "<p>给你一个二进制字符串 <code>s</code> ，现需要将其转化为一个 <strong>交替字符串</strong> 。请你计算并返回转化所需的 <strong>最小</strong> 字符交换次数，如果无法完成转化，返回<em> </em><code>-1</code><em> </em>。</p>\n\n<p><strong>交替字符串</strong> 是指：相邻字符之间不存在相等情况的字符串。例如，字符串 <code>\"010\"</code> 和 <code>\"1010\"</code> 属于交替字符串，但 <code>\"0100\"</code> 不是。</p>\n\n<p>任意两个字符都可以进行交换，<strong>不必相邻</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"111000\"\n<strong>输出：</strong>1\n<strong>解释：</strong>交换位置 1 和 4：\"1<em><strong>1</strong></em>10<em><strong>0</strong></em>0\" -> \"1<em><strong>0</strong></em>10<em><strong>1</strong></em>0\" ，字符串变为交替字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"010\"\n<strong>输出：</strong>0\n<strong>解释：</strong>字符串已经是交替字符串了，不需要交换。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1110\"\n<strong>输出：</strong>-1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 1000</code></li>\n\t<li><code>s[i]</code> 的值为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1865.找出和为指定值的下标对",
        "hardRate": "MEDIUM",
        "passRate": "50.83%",
        "problemsUrl": "https://leetcode.cn/problems/finding-pairs-with-a-certain-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/finding-pairs-with-a-certain-sum/solution",
        "problemsDesc": "<p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，请你实现一个支持下述两类查询的数据结构：</p>\n\n<ol>\n\t<li><strong>累加</strong> ，将一个正整数加到 <code>nums2</code> 中指定下标对应元素上。</li>\n\t<li><strong>计数 </strong>，统计满足 <code>nums1[i] + nums2[j]</code> 等于指定值的下标对 <code>(i, j)</code> 数目（<code>0 <= i < nums1.length</code> 且 <code>0 <= j < nums2.length</code>）。</li>\n</ol>\n\n<p>实现 <code>FindSumPairs</code> 类：</p>\n\n<ul>\n\t<li><code>FindSumPairs(int[] nums1, int[] nums2)</code> 使用整数数组 <code>nums1</code> 和 <code>nums2</code> 初始化 <code>FindSumPairs</code> 对象。</li>\n\t<li><code>void add(int index, int val)</code> 将 <code>val</code> 加到 <code>nums2[index]</code> 上，即，执行 <code>nums2[index] += val</code> 。</li>\n\t<li><code>int count(int tot)</code> 返回满足 <code>nums1[i] + nums2[j] == tot</code> 的下标对 <code>(i, j)</code> 数目。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"FindSumPairs\", \"count\", \"add\", \"count\", \"count\", \"add\", \"add\", \"count\"]\n[[[1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]], [7], [3, 2], [8], [4], [0, 1], [1, 1], [7]]\n<strong>输出：</strong>\n[null, 8, null, 2, 1, null, null, 11]\n\n<strong>解释：</strong>\nFindSumPairs findSumPairs = new FindSumPairs([1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]);\nfindSumPairs.count(7);  // 返回 8 ; 下标对 (2,2), (3,2), (4,2), (2,4), (3,4), (4,4) 满足 2 + 5 = 7 ，下标对 (5,1), (5,5) 满足 3 + 4 = 7\nfindSumPairs.add(3, 2); // 此时 nums2 = [1,4,5,<em><strong>4</strong></em><code>,5,4</code>]\nfindSumPairs.count(8);  // 返回 2 ；下标对 (5,2), (5,4) 满足 3 + 5 = 8\nfindSumPairs.count(4);  // 返回 1 ；下标对 (5,0) 满足 3 + 1 = 4\nfindSumPairs.add(0, 1); // 此时 nums2 = [<em><strong><code>2</code></strong></em>,4,5,4<code>,5,4</code>]\nfindSumPairs.add(1, 1); // 此时 nums2 = [<code>2</code>,<em><strong>5</strong></em>,5,4<code>,5,4</code>]\nfindSumPairs.count(7);  // 返回 11 ；下标对 (2,1), (2,2), (2,4), (3,1), (3,2), (3,4), (4,1), (4,2), (4,4) 满足 2 + 5 = 7 ，下标对 (5,3), (5,5) 满足 3 + 4 = 7\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums1.length <= 1000</code></li>\n\t<li><code>1 <= nums2.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums1[i] <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= nums2[i] <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= index < nums2.length</code></li>\n\t<li><code>1 <= val <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= tot <= 10<sup>9</sup></code></li>\n\t<li>最多调用 <code>add</code> 和 <code>count</code> 函数各 <code>1000</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1866.恰有 K 根木棍可以看到的排列数目",
        "hardRate": "HARD",
        "passRate": "61.88%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/solution",
        "problemsDesc": "<p>有 <code>n</code> 根长度互不相同的木棍，长度为从 <code>1</code> 到 <code>n</code> 的整数。请你将这些木棍排成一排，并满足从左侧 <strong>可以看到</strong> <strong>恰好</strong> <code>k</code> 根木棍。从左侧 <strong>可以看到</strong> 木棍的前提是这个木棍的 <strong>左侧</strong> 不存在比它 <strong>更长的</strong> 木棍。</p>\n\n<ul>\n\t<li>例如，如果木棍排列为 <code>[<em><strong>1</strong></em>,<em><strong>3</strong></em>,2,<em><strong>5</strong></em>,4]</code> ，那么从左侧可以看到的就是长度分别为 <code>1</code>、<code>3</code> 、<code>5</code> 的木棍。</li>\n</ul>\n\n<p>给你 <code>n</code> 和 <code>k</code> ，返回符合题目要求的排列 <strong>数目</strong> 。由于答案可能很大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余 </strong>的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 3, k = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>[<strong><em>1</em></strong>,<strong><em>3</em></strong>,2], [<em><strong>2</strong></em>,<em><strong>3</strong></em>,1] 和 [<em><strong>2</strong></em>,1,<em><strong>3</strong></em>] 是仅有的能满足恰好 2 根木棍可以看到的排列。\n可以看到的木棍已经用粗体+斜体标识。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 5, k = 5\n<strong>输出：</strong>1\n<strong>解释：</strong>[<em><strong>1</strong></em>,<em><strong>2</strong></em>,<em><strong>3</strong></em>,<em><strong>4</strong></em>,<em><strong>5</strong></em>] 是唯一一种能满足全部 5 根木棍可以看到的排列。\n可以看到的木棍已经用粗体+斜体标识。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 20, k = 11\n<strong>输出：</strong>647427950\n<strong>解释：</strong>总共有 647427950 (mod 10<sup>9 </sup>+ 7) 种能满足恰好有 11 根木棍可以看到的排列。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1867.最大数量高于平均水平的订单",
        "hardRate": "MEDIUM",
        "passRate": "68.04%",
        "problemsUrl": "https://leetcode.cn/problems/orders-with-maximum-quantity-above-average/",
        "solutionsUrl": "https://leetcode.cn/problems/orders-with-maximum-quantity-above-average/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1868.两个行程编码数组的积",
        "hardRate": "MEDIUM",
        "passRate": "48.79%",
        "problemsUrl": "https://leetcode.cn/problems/product-of-two-run-length-encoded-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/product-of-two-run-length-encoded-arrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1869.哪种连续子字符串更长",
        "hardRate": "EASY",
        "passRate": "70.61%",
        "problemsUrl": "https://leetcode.cn/problems/longer-contiguous-segments-of-ones-than-zeros/",
        "solutionsUrl": "https://leetcode.cn/problems/longer-contiguous-segments-of-ones-than-zeros/solution",
        "problemsDesc": "<p>给你一个二进制字符串 <code>s</code> 。如果字符串中由 <code>1</code> 组成的 <strong>最长</strong> 连续子字符串 <strong>严格长于</strong> 由 <code>0</code> 组成的 <strong>最长</strong> 连续子字符串，返回 <code>true</code> ；否则，返回 <code>false</code><em> </em>。</p>\n\n<ul>\n\t<li>例如，<code>s = \"<strong>11</strong>01<strong>000</strong>10\"</code> 中，由 <code>1</code> 组成的最长连续子字符串的长度是 <code>2</code> ，由 <code>0</code> 组成的最长连续子字符串的长度是 <code>3</code> 。</li>\n</ul>\n\n<p>注意，如果字符串中不存在 <code>0</code> ，此时认为由 <code>0</code> 组成的最长连续子字符串的长度是 <code>0</code> 。字符串中不存在 <code>1</code> 的情况也适用此规则。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1101\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\n由 <code>1</code> 组成的最长连续子字符串的长度是 2：\"<strong>11</strong>01\"\n由 <code>0</code> 组成的最长连续子字符串的长度是 1：\"11<strong>0</strong>1\"\n由 1 组成的子字符串更长，故返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"111000\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\n由 <code>1</code> 组成的最长连续子字符串的长度是 3：\"<strong>111</strong>000\"\n由<code> 0</code> 组成的最长连续子字符串的长度是 3：\"111<strong>000</strong>\"\n由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"110100010\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\n由 <code>1</code> 组成的最长连续子字符串的长度是 2：\"<strong>11</strong>0100010\"\n由 <code>0</code> 组成的最长连续子字符串的长度是 3：\"1101<strong>000</strong>10\"\n由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 100</code></li>\n\t<li><code>s[i]</code> 不是 <code>'0'</code> 就是 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1870.准时到达的列车最小时速",
        "hardRate": "MEDIUM",
        "passRate": "42.13%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/solution",
        "problemsDesc": "<p>给你一个浮点数 <code>hour</code> ，表示你到达办公室可用的总通勤时间。要到达办公室，你必须按给定次序乘坐 <code>n</code> 趟列车。另给你一个长度为 <code>n</code> 的整数数组 <code>dist</code> ，其中 <code>dist[i]</code> 表示第 <code>i</code> 趟列车的行驶距离（单位是千米）。</p>\n\n<p>每趟列车均只能在整点发车，所以你可能需要在两趟列车之间等待一段时间。</p>\n\n<ul>\n\t<li>例如，第 <code>1</code> 趟列车需要 <code>1.5</code> 小时，那你必须再等待 <code>0.5</code> 小时，搭乘在第 2 小时发车的第 <code>2</code> 趟列车。</li>\n</ul>\n\n<p>返回能满足你准时到达办公室所要求全部列车的<strong> 最小正整数 </strong>时速（单位：千米每小时），如果无法准时到达，则返回 <code>-1</code> 。</p>\n\n<p>生成的测试用例保证答案不超过 <code>10<sup>7</sup></code> ，且 <code>hour</code> 的 <strong>小数点后最多存在两位数字</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [1,3,2], hour = 6\n<strong>输出：</strong>1\n<strong>解释：</strong>速度为 1 时：\n- 第 1 趟列车运行需要 1/1 = 1 小时。\n- 由于是在整数时间到达，可以立即换乘在第 1 小时发车的列车。第 2 趟列车运行需要 3/1 = 3 小时。\n- 由于是在整数时间到达，可以立即换乘在第 4 小时发车的列车。第 3 趟列车运行需要 2/1 = 2 小时。\n- 你将会恰好在第 6 小时到达。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [1,3,2], hour = 2.7\n<strong>输出：</strong>3\n<strong>解释：</strong>速度为 3 时：\n- 第 1 趟列车运行需要 1/3 = 0.33333 小时。\n- 由于不是在整数时间到达，故需要等待至第 1 小时才能搭乘列车。第 2 趟列车运行需要 3/3 = 1 小时。\n- 由于是在整数时间到达，可以立即换乘在第 2 小时发车的列车。第 3 趟列车运行需要 2/3 = 0.66667 小时。\n- 你将会在第 2.66667 小时到达。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [1,3,2], hour = 1.9\n<strong>输出：</strong>-1\n<strong>解释：</strong>不可能准时到达，因为第 3 趟列车最早是在第 2 小时发车。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == dist.length</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= dist[i] <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= hour <= 10<sup>9</sup></code></li>\n\t<li><code>hours</code> 中，小数点后最多存在两位数字</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1871.跳跃游戏 VII",
        "hardRate": "MEDIUM",
        "passRate": "28.31%",
        "problemsUrl": "https://leetcode.cn/problems/jump-game-vii/",
        "solutionsUrl": "https://leetcode.cn/problems/jump-game-vii/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0 </strong>开始的二进制字符串 <code>s</code> 和两个整数 <code>minJump</code> 和 <code>maxJump</code> 。一开始，你在下标 <code>0</code> 处，且该位置的值一定为 <code>'0'</code> 。当同时满足如下条件时，你可以从下标 <code>i</code> 移动到下标 <code>j</code> 处：</p>\n\n<ul>\n\t<li><code>i + minJump <= j <= min(i + maxJump, s.length - 1)</code> 且</li>\n\t<li><code>s[j] == '0'</code>.</li>\n</ul>\n\n<p>如果你可以到达 <code>s</code> 的下标<i> </i><code>s.length - 1</code> 处，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"<strong>0</strong>11<strong>0</strong>1<strong>0</strong>\", minJump = 2, maxJump = 3\n<b>输出：</b>true\n<strong>解释：</strong>\n第一步，从下标 0 移动到下标 3 。\n第二步，从下标 3 移动到下标 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"01101110\", minJump = 2, maxJump = 3\n<b>输出：</b>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= s.length <= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 要么是 <code>'0'</code> ，要么是 <code>'1'</code></li>\n\t<li><code>s[0] == '0'</code></li>\n\t<li><code>1 <= minJump <= maxJump < s.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1872.石子游戏 VIII",
        "hardRate": "HARD",
        "passRate": "61.25%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game-viii/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game-viii/solution",
        "problemsDesc": "<p>Alice 和 Bob 玩一个游戏，两人轮流操作， <strong>Alice 先手</strong> 。</p>\n\n<p>总共有 <code>n</code> 个石子排成一行。轮到某个玩家的回合时，如果石子的数目 <strong>大于 1</strong> ，他将执行以下操作：</p>\n\n<ol>\n\t<li>选择一个整数 <code>x &gt; 1</code> ，并且 <strong>移除</strong> 最左边的 <code>x</code> 个石子。</li>\n\t<li>将<strong> 移除</strong> 的石子价值之 <strong>和</strong> 累加到该玩家的分数中。</li>\n\t<li>将一个 <strong>新的石子</strong> 放在最左边，且新石子的值为被移除石子值之和。</li>\n</ol>\n\n<p>当只剩下 <strong>一个</strong> 石子时，游戏结束。</p>\n\n<p>Alice 和 Bob 的 <strong>分数之差</strong> 为 <code>(Alice 的分数 - Bob 的分数)</code> 。 Alice 的目标是<strong> 最大化</strong> 分数差，Bob 的目标是 <strong>最小化</strong> 分数差。</p>\n\n<p>给你一个长度为 <code>n</code> 的整数数组 <code>stones</code> ，其中 <code>stones[i]</code> 是 <strong>从左边起</strong> 第 <code>i</code> 个石子的价值。请你返回在双方都采用 <strong>最优</strong> 策略的情况下，Alice 和 Bob 的 <strong>分数之差</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>stones = [-1,2,-3,4,-5]\n<b>输出：</b>5\n<strong>解释：</strong>\n- Alice 移除最左边的 4 个石子，得分增加 (-1) + 2 + (-3) + 4 = 2 ，并且将一个价值为 2 的石子放在最左边。stones = [2,-5] 。\n- Bob 移除最左边的 2 个石子，得分增加 2 + (-5) = -3 ，并且将一个价值为 -3 的石子放在最左边。stones = [-3] 。\n两者分数之差为 2 - (-3) = 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>stones = [7,-6,5,10,5,-2,-6]\n<b>输出：</b>13\n<b>解释：</b>\n- Alice 移除所有石子，得分增加 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 ，并且将一个价值为 13 的石子放在最左边。stones = [13] 。\n两者分数之差为 13 - 0 = 13 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>stones = [-10,-12]\n<b>输出：</b>-22\n<strong>解释：</strong>\n- Alice 只有一种操作，就是移除所有石子。得分增加 (-10) + (-12) = -22 ，并且将一个价值为 -22 的石子放在最左边。stones = [-22] 。\n两者分数之差为 (-22) - 0 = -22 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == stones.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= stones[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1873.计算特殊奖金",
        "hardRate": "EASY",
        "passRate": "62.73%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-special-bonus/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-special-bonus/solution",
        "problemsDesc": "<p>表: <code>Employees</code></p>\n\n<pre>\n+-------------+---------+\n| 列名        | 类型     |\n+-------------+---------+\n| employee_id | int     |\n| name        | varchar |\n| salary      | int     |\n+-------------+---------+\nemployee_id 是这个表的主键。\n此表的每一行给出了雇员id ，名字和薪水。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写出一个SQL 查询语句，计算每个雇员的奖金。如果一个雇员的id是奇数并且他的名字不是以'M'开头，那么他的奖金是他工资的100%，否则奖金为0。</p>\n\n<p>Return the result table ordered by <code>employee_id</code>.</p>\n\n<p>返回的结果集请按照<code>employee_id</code>排序。</p>\n\n<p>查询结果格式如下面的例子所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nEmployees 表:\n+-------------+---------+--------+\n| employee_id | name    | salary |\n+-------------+---------+--------+\n| 2           | Meir    | 3000   |\n| 3           | Michael | 3800   |\n| 7           | Addilyn | 7400   |\n| 8           | Juan    | 6100   |\n| 9           | Kannon  | 7700   |\n+-------------+---------+--------+\n<strong>输出：</strong>\n+-------------+-------+\n| employee_id | bonus |\n+-------------+-------+\n| 2           | 0     |\n| 3           | 0     |\n| 7           | 7400  |\n| 8           | 0     |\n| 9           | 7700  |\n+-------------+-------+\n<strong>解释：</strong>\n因为雇员id是偶数，所以雇员id 是2和8的两个雇员得到的奖金是0。\n雇员id为3的因为他的名字以'M'开头，所以，奖金是0。\n其他的雇员得到了百分之百的奖金。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1874.两个数组的最小乘积和",
        "hardRate": "MEDIUM",
        "passRate": "86.58%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-product-sum-of-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-product-sum-of-two-arrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1875.将工资相同的雇员分组",
        "hardRate": "MEDIUM",
        "passRate": "64.45%",
        "problemsUrl": "https://leetcode.cn/problems/group-employees-of-the-same-salary/",
        "solutionsUrl": "https://leetcode.cn/problems/group-employees-of-the-same-salary/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1876.长度为三且各字符不同的子字符串",
        "hardRate": "EASY",
        "passRate": "70.47%",
        "problemsUrl": "https://leetcode.cn/problems/substrings-of-size-three-with-distinct-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/substrings-of-size-three-with-distinct-characters/solution",
        "problemsDesc": "<p>如果一个字符串不含有任何重复字符，我们称这个字符串为 <strong>好</strong> 字符串。</p>\n\n<p>给你一个字符串 <code>s</code> ，请你返回 <code>s</code> 中长度为 <strong>3</strong> 的 <strong>好子字符串</strong> 的数量。</p>\n\n<p>注意，如果相同的好子字符串出现多次，每一次都应该被记入答案之中。</p>\n\n<p><strong>子字符串</strong> 是一个字符串中连续的字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"xyzzaz\"\n<b>输出：</b>1\n<b>解释：</b>总共有 4 个长度为 3 的子字符串：\"xyz\"，\"yzz\"，\"zza\" 和 \"zaz\" 。\n唯一的长度为 3 的好子字符串是 \"xyz\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aababcabc\"\n<b>输出：</b>4\n<b>解释：</b>总共有 7 个长度为 3 的子字符串：\"aab\"，\"aba\"，\"bab\"，\"abc\"，\"bca\"，\"cab\" 和 \"abc\" 。\n好子字符串包括 \"abc\"，\"bca\"，\"cab\" 和 \"abc\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 100</code></li>\n\t<li><code>s</code>​​​​​​ 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1877.数组中最大数对和的最小值",
        "hardRate": "MEDIUM",
        "passRate": "81.15%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-maximum-pair-sum-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-maximum-pair-sum-in-array/solution",
        "problemsDesc": "<p>一个数对 <code>(a,b)</code> 的 <strong>数对和</strong> 等于 <code>a + b</code> 。<strong>最大数对和</strong> 是一个数对数组中最大的 <strong>数对和</strong> 。</p>\n\n<ul>\n\t<li>比方说，如果我们有数对 <code>(1,5)</code> ，<code>(2,3)</code> 和 <code>(4,4)</code>，<strong>最大数对和</strong> 为 <code>max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8</code> 。</li>\n</ul>\n\n<p>给你一个长度为 <strong>偶数</strong> <code>n</code> 的数组 <code>nums</code> ，请你将 <code>nums</code> 中的元素分成 <code>n / 2</code> 个数对，使得：</p>\n\n<ul>\n\t<li><code>nums</code> 中每个元素 <strong>恰好</strong> 在 <strong>一个</strong> 数对中，且</li>\n\t<li><strong>最大数对和</strong> 的值 <strong>最小</strong> 。</li>\n</ul>\n\n<p>请你在最优数对划分的方案下，返回最小的 <strong>最大数对和</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [3,5,2,3]\n<b>输出：</b>7\n<b>解释：</b>数组中的元素可以分为数对 (3,3) 和 (5,2) 。\n最大数对和为 max(3+3, 5+2) = max(6, 7) = 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [3,5,4,2,4,6]\n<b>输出：</b>8\n<b>解释：</b>数组中的元素可以分为数对 (3,5)，(4,4) 和 (6,2) 。\n最大数对和为 max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>n</code> 是 <strong>偶数</strong> 。</li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1878.矩阵中最大的三个菱形和",
        "hardRate": "MEDIUM",
        "passRate": "45.51%",
        "problemsUrl": "https://leetcode.cn/problems/get-biggest-three-rhombus-sums-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/get-biggest-three-rhombus-sums-in-a-grid/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的整数矩阵 <code>grid</code> 。</p>\n\n<p><strong>菱形和</strong> 指的是 <code>grid</code> 中一个正菱形 <strong>边界</strong> 上的元素之和。本题中的菱形必须为正方形旋转45度，且四个角都在一个格子当中。下图是四个可行的菱形，每个菱形和应该包含的格子都用了相应颜色标注在图中。</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-desc-2.png\" style=\"width: 385px; height: 385px;\" />\n<p> </p>\n\n<p>注意，菱形可以是一个面积为 0 的区域，如上图中右下角的紫色菱形所示。</p>\n\n<p>请你按照 <strong>降序</strong> 返回 <code>grid</code> 中三个最大的 <strong>互不相同的菱形和</strong> 。如果不同的和少于三个，则将它们全部返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-ex1.png\" style=\"width: 360px; height: 361px;\" />\n<pre>\n<b>输入：</b>grid = [[3,4,5,1,3],[3,3,4,2,3],[20,30,200,40,10],[1,5,5,4,1],[4,3,2,2,5]]\n<b>输出：</b>[228,216,211]\n<b>解释：</b>最大的三个菱形和如上图所示。\n- 蓝色：20 + 3 + 200 + 5 = 228\n- 红色：200 + 2 + 10 + 4 = 216\n- 绿色：5 + 200 + 4 + 2 = 211\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-ex2.png\" style=\"width: 217px; height: 217px;\" />\n<pre>\n<b>输入：</b>grid = [[1,2,3],[4,5,6],[7,8,9]]\n<b>输出：</b>[20,9,8]\n<b>解释：</b>最大的三个菱形和如上图所示。\n- 蓝色：4 + 2 + 6 + 8 = 20\n- 红色：9 （右下角红色的面积为 0 的菱形）\n- 绿色：8 （下方中央面积为 0 的菱形）\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>grid = [[7,7,7]]\n<b>输出：</b>[7]\n<b>解释：</b>所有三个可能的菱形和都相同，所以返回 [7] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 <= m, n <= 100</code></li>\n\t<li><code>1 <= grid[i][j] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1879.两个数组最小的异或值之和",
        "hardRate": "HARD",
        "passRate": "49.99%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-xor-sum-of-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-xor-sum-of-two-arrays/solution",
        "problemsDesc": "<p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，它们长度都为 <code>n</code> 。</p>\n\n<p>两个数组的 <strong>异或值之和</strong> 为 <code>(nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1])</code> （<strong>下标从 0 开始</strong>）。</p>\n\n<ul>\n\t<li>比方说，<code>[1,2,3]</code> 和 <code>[3,2,1]</code> 的 <strong>异或值之和</strong> 等于 <code>(1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4</code> 。</li>\n</ul>\n\n<p>请你将 <code>nums2</code> 中的元素重新排列，使得 <strong>异或值之和</strong> <strong>最小</strong> 。</p>\n\n<p>请你返回重新排列之后的 <strong>异或值之和</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,2], nums2 = [2,3]\n<b>输出：</b>2\n<b>解释：</b>将 <code>nums2</code> 重新排列得到 <code>[3,2] 。</code>\n异或值之和为 (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,0,3], nums2 = [5,3,4]\n<b>输出：</b>8\n<b>解释：</b>将 <code>nums2 重新排列得到</code> <code>[5,4,3] 。</code>\n异或值之和为 (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length</code></li>\n\t<li><code>n == nums2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 14</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1880.检查某单词是否等于两单词之和",
        "hardRate": "EASY",
        "passRate": "76.29%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-word-equals-summation-of-two-words/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-word-equals-summation-of-two-words/solution",
        "problemsDesc": "<p>字母的 <strong>字母值</strong> 取决于字母在字母表中的位置，<strong>从 0 开始</strong> 计数。即，<code>'a' -&gt; 0</code>、<code>'b' -&gt; 1</code>、<code>'c' -&gt; 2</code>，以此类推。</p>\n\n<p>对某个由小写字母组成的字符串 <code>s</code> 而言，其 <strong>数值</strong> 就等于将 <code>s</code> 中每个字母的 <strong>字母值</strong> 按顺序 <strong>连接</strong> 并 <strong>转换</strong> 成对应整数。</p>\n\n<ul>\n\t<li>例如，<code>s = \"acb\"</code> ，依次连接每个字母的字母值可以得到 <code>\"021\"</code> ，转换为整数得到 <code>21</code> 。</li>\n</ul>\n\n<p>给你三个字符串 <code>firstWord</code>、<code>secondWord</code> 和 <code>targetWord</code> ，每个字符串都由从 <code>'a'</code> 到 <code>'j'</code> （<strong>含 </strong><code>'a'</code> 和 <code>'j'</code><strong> </strong>）的小写英文字母组成。</p>\n\n<p>如果 <code>firstWord</code><em> </em>和<em> </em><code>secondWord</code> 的 <strong>数值之和</strong> 等于<em> </em><code>targetWord</code><em> </em>的数值，返回 <code>true</code> ；否则，返回<em> </em><code>false</code><em> </em>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>firstWord = \"acb\", secondWord = \"cba\", targetWord = \"cdb\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\nfirstWord 的数值为 \"acb\" -&gt; \"021\" -&gt; 21\nsecondWord 的数值为 \"cba\" -&gt; \"210\" -&gt; 210\ntargetWord 的数值为 \"cdb\" -&gt; \"231\" -&gt; 231\n由于 21 + 210 == 231 ，返回 true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aab\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\nfirstWord 的数值为 \"aaa\" -&gt; \"000\" -&gt; 0\nsecondWord 的数值为 \"a\" -&gt; \"0\" -&gt; 0\ntargetWord 的数值为 \"aab\" -&gt; \"001\" -&gt; 1\n由于 0 + 0 != 1 ，返回 false</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aaaa\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\nfirstWord 的数值为 \"aaa\" -&gt; \"000\" -&gt; 0\nsecondWord 的数值为 \"a\" -&gt; \"0\" -&gt; 0\ntargetWord 的数值为 \"aaaa\" -&gt; \"0000\" -&gt; 0\n由于 0 + 0 == 0 ，返回 true\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= firstWord.length, </code><code>secondWord.length, </code><code>targetWord.length &lt;= 8</code></li>\n\t<li><code>firstWord</code>、<code>secondWord</code> 和 <code>targetWord</code> 仅由从 <code>'a'</code> 到 <code>'j'</code> （<strong>含 </strong><code>'a'</code> 和 <code>'j'</code><strong> </strong>）的小写英文字母组成<strong>。</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1881.插入后的最大值",
        "hardRate": "MEDIUM",
        "passRate": "37.76%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-value-after-insertion/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-value-after-insertion/solution",
        "problemsDesc": "<p>给你一个非常大的整数 <code>n</code> 和一个整数数字 <code>x</code> ，大整数 <code>n</code> 用一个字符串表示。<code>n</code> 中每一位数字和数字 <code>x</code> 都处于闭区间 <code>[1, 9]</code> 中，且 <code>n</code> 可能表示一个 <strong>负数</strong> 。</p>\n\n<p>你打算通过在 <code>n</code> 的十进制表示的任意位置插入 <code>x</code> 来 <strong>最大化</strong> <code>n</code> 的 <strong>数值</strong> ​​​​​​。但 <strong>不能</strong> 在负号的左边插入 <code>x</code> 。</p>\n\n<ul>\n\t<li>例如，如果 <code>n = 73</code> 且 <code>x = 6</code> ，那么最佳方案是将 <code>6</code> 插入 <code>7</code> 和 <code>3</code> 之间，使 <code>n = 763</code> 。</li>\n\t<li>如果 <code>n = -55</code> 且 <code>x = 2</code> ，那么最佳方案是将 <code>2</code> 插在第一个 <code>5</code> 之前，使 <code>n = -255</code> 。</li>\n</ul>\n\n<p>返回插入操作后，用字符串表示的 <code>n</code> 的最大值。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = \"99\", x = 9\n<strong>输出：</strong>\"999\"\n<strong>解释：</strong>不管在哪里插入 9 ，结果都是相同的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = \"-13\", x = 2\n<strong>输出：</strong>\"-123\"\n<strong>解释：</strong>向 n 中插入 x 可以得到 -213、-123 或者 -132 ，三者中最大的是 -123 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= x <= 9</code></li>\n\t<li><code>n</code>​​​ 中每一位的数字都在闭区间 <code>[1, 9]</code> 中。</li>\n\t<li><code>n</code> 代表一个有效的整数。</li>\n\t<li>当 <code>n</code> 表示负数时，将会以字符 <code>'-'</code> 开始。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1882.使用服务器处理任务",
        "hardRate": "MEDIUM",
        "passRate": "30.79%",
        "problemsUrl": "https://leetcode.cn/problems/process-tasks-using-servers/",
        "solutionsUrl": "https://leetcode.cn/problems/process-tasks-using-servers/solution",
        "problemsDesc": "<p>给你两个 <strong>下标从 0 开始</strong> 的整数数组 <code>servers</code> 和 <code>tasks</code> ，长度分别为 <code>n</code>​​​​​​ 和 <code>m</code>​​​​​​ 。<code>servers[i]</code> 是第 <code>i<sup>​​​​​​</sup></code>​​​​ 台服务器的 <strong>权重</strong> ，而 <code>tasks[j]</code> 是处理第 <code>j<sup>​​​​​​</sup></code> 项任务 <strong>所需要的时间</strong>（单位：秒）。</p>\n\n<p>你正在运行一个仿真系统，在处理完所有任务后，该系统将会关闭。每台服务器只能同时处理一项任务。第 <code>0</code> 项任务在第 <code>0</code> 秒可以开始处理，相应地，第 <code>j</code> 项任务在第 <code>j</code> 秒可以开始处理。处理第 <code>j</code> 项任务时，你需要为它分配一台 <strong>权重最小</strong> 的空闲服务器。如果存在多台相同权重的空闲服务器，请选择 <strong>下标最小</strong> 的服务器。如果一台空闲服务器在第 <code>t</code> 秒分配到第 <code>j</code> 项任务，那么在 <code>t + tasks[j]</code> 时它将恢复空闲状态。</p>\n\n<p>如果没有空闲服务器，则必须等待，直到出现一台空闲服务器，并 <strong>尽可能早</strong> 地处理剩余任务。 如果有多项任务等待分配，则按照 <strong>下标递增</strong> 的顺序完成分配。</p>\n\n<p>如果同一时刻存在多台空闲服务器，可以同时将多项任务分别分配给它们。</p>\n\n<p>构建长度为 <code>m</code> 的答案数组 <code>ans</code> ，其中 <code>ans[j]</code> 是第 <code>j</code> 项任务分配的服务器的下标。</p>\n\n<p>返回答案数组<em> </em><code>ans</code>​​​​ 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>servers = [3,3,2], tasks = [1,2,3,2,1,2]\n<strong>输出：</strong>[2,2,0,2,1,2]\n<strong>解释：</strong>事件按时间顺序如下：\n- 0 秒时，第 0 项任务加入到任务队列，使用第 2 台服务器处理到 1 秒。\n- 1 秒时，第 2 台服务器空闲，第 1 项任务加入到任务队列，使用第 2 台服务器处理到 3 秒。\n- 2 秒时，第 2 项任务加入到任务队列，使用第 0 台服务器处理到 5 秒。\n- 3 秒时，第 2 台服务器空闲，第 3 项任务加入到任务队列，使用第 2 台服务器处理到 5 秒。\n- 4 秒时，第 4 项任务加入到任务队列，使用第 1 台服务器处理到 5 秒。\n- 5 秒时，所有服务器都空闲，第 5 项任务加入到任务队列，使用第 2 台服务器处理到 7 秒。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>servers = [5,1,4,3,2], tasks = [2,1,2,4,5,2,1]\n<strong>输出：</strong>[1,4,1,4,1,3,2]\n<strong>解释：</strong>事件按时间顺序如下：\n- 0 秒时，第 0 项任务加入到任务队列，使用第 1 台服务器处理到 2 秒。\n- 1 秒时，第 1 项任务加入到任务队列，使用第 4 台服务器处理到 2 秒。\n- 2 秒时，第 1 台和第 4 台服务器空闲，第 2 项任务加入到任务队列，使用第 1 台服务器处理到 4 秒。\n- 3 秒时，第 3 项任务加入到任务队列，使用第 4 台服务器处理到 7 秒。\n- 4 秒时，第 1 台服务器空闲，第 4 项任务加入到任务队列，使用第 1 台服务器处理到 9 秒。\n- 5 秒时，第 5 项任务加入到任务队列，使用第 3 台服务器处理到 7 秒。\n- 6 秒时，第 6 项任务加入到任务队列，使用第 2 台服务器处理到 7 秒。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>servers.length == n</code></li>\n\t<li><code>tasks.length == m</code></li>\n\t<li><code>1 <= n, m <= 2 * 10<sup>5</sup></code></li>\n\t<li><code>1 <= servers[i], tasks[j] <= 2 * 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1883.准时抵达会议现场的最小跳过休息次数",
        "hardRate": "HARD",
        "passRate": "40.22%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-skips-to-arrive-at-meeting-on-time/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-skips-to-arrive-at-meeting-on-time/solution",
        "problemsDesc": "<p>给你一个整数 <code>hoursBefore</code> ，表示你要前往会议所剩下的可用小时数。要想成功抵达会议现场，你必须途经 <code>n</code> 条道路。道路的长度用一个长度为 <code>n</code> 的整数数组 <code>dist</code> 表示，其中 <code>dist[i]</code> 表示第 <code>i</code> 条道路的长度（单位：<strong>千米</strong>）。另给你一个整数 <code>speed</code> ，表示你在道路上前进的速度（单位：<strong>千米每小时</strong>）。</p>\n\n<p>当你通过第 <code>i</code> 条路之后，就必须休息并等待，直到 <strong>下一个整数小时</strong> 才能开始继续通过下一条道路。注意：你不需要在通过最后一条道路后休息，因为那时你已经抵达会议现场。</p>\n\n<ul>\n\t<li>例如，如果你通过一条道路用去 <code>1.4</code> 小时，那你必须停下来等待，到 <code>2</code> 小时才可以继续通过下一条道路。如果通过一条道路恰好用去 <code>2</code> 小时，就无需等待，可以直接继续。</li>\n</ul>\n\n<p>然而，为了能准时到达，你可以选择 <strong>跳过</strong> 一些路的休息时间，这意味着你不必等待下一个整数小时。注意，这意味着与不跳过任何休息时间相比，你可能在不同时刻到达接下来的道路。</p>\n\n<ul>\n\t<li>例如，假设通过第 <code>1</code> 条道路用去 <code>1.4</code> 小时，且通过第 <code>2</code> 条道路用去 <code>0.6</code> 小时。跳过第 <code>1</code> 条道路的休息时间意味着你将会在恰好 <code>2</code> 小时完成通过第 <code>2</code> 条道路，且你能够立即开始通过第 <code>3</code> 条道路。</li>\n</ul>\n\n<p>返回准时抵达会议现场所需要的 <strong>最小跳过次数</strong> ，如果 <strong>无法准时参会</strong> ，返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [1,3,2], speed = 4, hoursBefore = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>\n不跳过任何休息时间，你将用 (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 小时才能抵达会议现场。\n可以跳过第 1 次休息时间，共用 ((1/4 + <strong>0</strong>) + (3/4 + 0)) + (2/4) = 1.5 小时抵达会议现场。\n注意，第 2 次休息时间缩短为 0 ，由于跳过第 1 次休息时间，你是在整数小时处完成通过第 2 条道路。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [7,3,5,5], speed = 2, hoursBefore = 10\n<strong>输出：</strong>2\n<strong>解释：</strong>\n不跳过任何休息时间，你将用 (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 小时才能抵达会议现场。\n可以跳过第 1 次和第 3 次休息时间，共用 ((7/2 + <strong>0</strong>) + (3/2 + 0)) + ((5/2 + <strong>0</strong>) + (5/2)) = 10 小时抵达会议现场。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [7,3,5,5], speed = 1, hoursBefore = 10\n<strong>输出：</strong>-1\n<strong>解释：</strong>即使跳过所有的休息时间，也无法准时参加会议。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == dist.length</code></li>\n\t<li><code>1 <= n <= 1000</code></li>\n\t<li><code>1 <= dist[i] <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= speed <= 10<sup>6</sup></code></li>\n\t<li><code>1 <= hoursBefore <= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1884.鸡蛋掉落-两枚鸡蛋",
        "hardRate": "MEDIUM",
        "passRate": "70.44%",
        "problemsUrl": "https://leetcode.cn/problems/egg-drop-with-2-eggs-and-n-floors/",
        "solutionsUrl": "https://leetcode.cn/problems/egg-drop-with-2-eggs-and-n-floors/solution",
        "problemsDesc": "<p>给你 <strong>2&nbsp;枚相同 </strong>的鸡蛋，和一栋从第 <code>1</code>&nbsp;层到第 <code>n</code> 层共有 <code>n</code> 层楼的建筑。</p>\n\n<p>已知存在楼层 <code>f</code> ，满足&nbsp;<code>0 &lt;= f &lt;= n</code> ，任何从 <strong>高于 </strong><code>f</code> 的楼层落下的鸡蛋都<strong> 会碎 </strong>，从 <strong><code>f</code> 楼层或比它低 </strong>的楼层落下的鸡蛋都 <strong>不会碎 </strong>。</p>\n\n<p>每次操作，你可以取一枚<strong> 没有碎</strong> 的鸡蛋并把它从任一楼层 <code>x</code> 扔下（满足&nbsp;<code>1 &lt;= x &lt;= n</code>）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中<strong> 重复使用 </strong>这枚鸡蛋。</p>\n\n<p>请你计算并返回要确定 <code>f</code> <strong>确切的值 </strong>的 <strong>最小操作次数</strong> 是多少？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>我们可以将第一枚鸡蛋从 1 楼扔下，然后将第二枚从 2 楼扔下。\n如果第一枚鸡蛋碎了，可知 f = 0；\n如果第二枚鸡蛋碎了，但第一枚没碎，可知 f = 1；\n否则，当两个鸡蛋都没碎时，可知 f = 2。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 100\n<strong>输出：</strong>14\n<strong>解释：\n</strong>一种最优的策略是：\n- 将第一枚鸡蛋从 9 楼扔下。如果碎了，那么 f 在 0 和 8 之间。将第二枚从 1 楼扔下，然后每扔一次上一层楼，在 8 次内找到 f 。总操作次数 = 1 + 8 = 9 。\n- 如果第一枚鸡蛋没有碎，那么再把第一枚鸡蛋从 22 层扔下。如果碎了，那么 f 在 9 和 21 之间。将第二枚鸡蛋从 10 楼扔下，然后每扔一次上一层楼，在 12 次内找到 f 。总操作次数 = 2 + 12 = 14 。\n- 如果第一枚鸡蛋没有再次碎掉，则按照类似的方法从 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99 和 100 楼分别扔下第一枚鸡蛋。\n不管结果如何，最多需要扔 14 次来确定 f 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1885.统计数对",
        "hardRate": "MEDIUM",
        "passRate": "59.03%",
        "problemsUrl": "https://leetcode.cn/problems/count-pairs-in-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/count-pairs-in-two-arrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1886.判断矩阵经轮转后是否一致",
        "hardRate": "EASY",
        "passRate": "59.39%",
        "problemsUrl": "https://leetcode.cn/problems/determine-whether-matrix-can-be-obtained-by-rotation/",
        "solutionsUrl": "https://leetcode.cn/problems/determine-whether-matrix-can-be-obtained-by-rotation/solution",
        "problemsDesc": "<p>给你两个大小为 <code>n x n</code> 的二进制矩阵 <code>mat</code> 和 <code>target</code> 。现<strong> 以 90 度顺时针轮转 </strong>矩阵 <code>mat</code> 中的元素 <strong>若干次</strong> ，如果能够使 <code>mat</code> 与 <code>target</code> 一致，返回 <code>true</code> ；否则，返回<em> </em><code>false</code><em> 。</em></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/20/grid3.png\" style=\"width: 301px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>mat = [[0,1],[1,0]], target = [[1,0],[0,1]]\n<strong>输出：</strong>true\n<strong>解释：</strong>顺时针轮转 90 度一次可以使 mat 和 target 一致。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/20/grid4.png\" style=\"width: 301px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>mat = [[0,1],[1,1]], target = [[1,0],[0,1]]\n<strong>输出：</strong>false\n<strong>解释：</strong>无法通过轮转矩阵中的元素使 equal 与 target 一致。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/26/grid4.png\" style=\"width: 661px; height: 184px;\" />\n<pre>\n<strong>输入：</strong>mat = [[0,0,0],[0,1,0],[1,1,1]], target = [[1,1,1],[0,1,0],[0,0,0]]\n<strong>输出：</strong>true\n<strong>解释：</strong>顺时针轮转 90 度两次可以使 mat 和 target 一致。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == mat.length == target.length</code></li>\n\t<li><code>n == mat[i].length == target[i].length</code></li>\n\t<li><code>1 <= n <= 10</code></li>\n\t<li><code>mat[i][j]</code> 和 <code>target[i][j]</code> 不是 <code>0</code> 就是 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1887.使数组元素相等的减少操作次数",
        "hardRate": "MEDIUM",
        "passRate": "65.50%",
        "problemsUrl": "https://leetcode.cn/problems/reduction-operations-to-make-the-array-elements-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/reduction-operations-to-make-the-array-elements-equal/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，你的目标是令 <code>nums</code> 中的所有元素相等。完成一次减少操作需要遵照下面的几个步骤：</p>\n\n<ol>\n\t<li>找出 <code>nums</code> 中的 <strong>最大</strong> 值。记这个值为 <code>largest</code> 并取其下标 <code>i</code> （<strong>下标从 0 开始计数</strong>）。如果有多个元素都是最大值，则取最小的 <code>i</code> 。</li>\n\t<li>找出 <code>nums</code> 中的 <strong>下一个最大</strong> 值，这个值 <strong>严格小于</strong> <code>largest</code> ，记为 <code>nextLargest</code> 。</li>\n\t<li>将 <code>nums[i]</code> 减少到 <code>nextLargest</code> 。</li>\n</ol>\n\n<p>返回使<em> </em><code>nums</code><em> </em>中的所有元素相等的操作次数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,1,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>需要 3 次操作使 nums 中的所有元素相等：\n1. largest = 5 下标为 0 。nextLargest = 3 。将 nums[0] 减少到 3 。nums = [<strong>3</strong>,1,3] 。\n2. largest = 3 下标为 0 。nextLargest = 1 。将 nums[0] 减少到 1 。nums = [<strong>1</strong>,1,3] 。\n3. largest = 3 下标为 2 。nextLargest = 1 。将 nums[2] 减少到 1 。nums = [<strong>1</strong>,1,<strong>1</strong>] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1]\n<strong>输出：</strong>0\n<strong>解释：</strong>nums 中的所有元素已经是相等的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,2,2,3]\n<strong>输出：</strong>4\n<strong>解释：</strong>需要 4 次操作使 nums 中的所有元素相等：\n1. largest = 3 下标为 4 。nextLargest = 2 。将 nums[4] 减少到 2 。nums = [1,1,2,2,<strong>2</strong>] 。\n2. largest = 2 下标为 2 。nextLargest = 1 。将 nums[2] 减少到 1 。nums = [1,1,<strong>1</strong>,2,2] 。 \n3. largest = 2 下标为 3 。nextLargest = 1 。将 nums[3] 减少到 1 。nums = [1,1,1,<strong>1</strong>,2] 。 \n4. largest = 2 下标为 4 。nextLargest = 1 。将 nums[4] 减少到 1 。nums = [1,1,1,1,<strong>1</strong>] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= nums[i] <= 5 * 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1888.使二进制字符串字符交替的最少反转次数",
        "hardRate": "MEDIUM",
        "passRate": "36.51%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/solution",
        "problemsDesc": "<p>给你一个二进制字符串 <code>s</code> 。你可以按任意顺序执行以下两种操作任意次：</p>\n\n<ul>\n\t<li><strong>类型 1 ：删除</strong> 字符串 <code>s</code> 的第一个字符并将它 <strong>添加</strong> 到字符串结尾。</li>\n\t<li><strong>类型 2 ：选择 </strong>字符串 <code>s</code> 中任意一个字符并将该字符 <strong>反转 </strong>，也就是如果值为 <code>'0'</code> ，则反转得到 <code>'1'</code> ，反之亦然。</li>\n</ul>\n\n<p>请你返回使 <code>s</code> 变成 <strong>交替</strong> 字符串的前提下， <strong>类型 2 </strong>的 <strong>最少</strong> 操作次数 。</p>\n\n<p>我们称一个字符串是 <strong>交替</strong> 的，需要满足任意相邻字符都不同。</p>\n\n<ul>\n\t<li>比方说，字符串 <code>\"010\"</code> 和 <code>\"1010\"</code> 都是交替的，但是字符串 <code>\"0100\"</code> 不是。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"111000\"\n<b>输出：</b>2\n<b>解释：</b>执行第一种操作两次，得到 s = \"100011\" 。\n然后对第三个和第六个字符执行第二种操作，得到 s = \"10<strong>1</strong>01<strong>0</strong>\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"010\"\n<b>输出：</b>0\n<strong>解释：</strong>字符串已经是交替的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>s = \"1110\"\n<b>输出：</b>1\n<b>解释：</b>对第二个字符执行第二种操作，得到 s = \"1<strong>0</strong>10\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 要么是 <code>'0'</code> ，要么是 <code>'1'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1889.装包裹的最小浪费空间",
        "hardRate": "HARD",
        "passRate": "29.56%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-space-wasted-from-packaging/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-space-wasted-from-packaging/solution",
        "problemsDesc": "<p>给你 <code>n</code> 个包裹，你需要把它们装在箱子里，<strong>每个箱子装一个包裹</strong>。总共有 <code>m</code> 个供应商提供 <strong>不同尺寸</strong> 的箱子（每个规格都有无数个箱子）。如果一个包裹的尺寸 <strong>小于等于</strong> 一个箱子的尺寸，那么这个包裹就可以放入这个箱子之中。</p>\n\n<p>包裹的尺寸用一个整数数组 <code>packages</code> 表示，其中 <code>packages[i]</code> 是第 <code>i</code> 个包裹的尺寸。供应商用二维数组 <code>boxes</code> 表示，其中 <code>boxes[j]</code> 是第 <code>j</code> 个供应商提供的所有箱子尺寸的数组。</p>\n\n<p>你想要选择 <strong>一个供应商</strong> 并只使用该供应商提供的箱子，使得 <strong>总浪费空间最小</strong> 。对于每个装了包裹的箱子，我们定义 <strong>浪费的</strong> 空间等于 <code>箱子的尺寸 - 包裹的尺寸</code> 。<strong>总浪费空间</strong> 为 <strong>所有</strong> 箱子中浪费空间的总和。</p>\n\n<ul>\n\t<li>比方说，如果你想要用尺寸数组为 <code>[4,8]</code> 的箱子装下尺寸为 <code>[2,3,5]</code> 的包裹，你可以将尺寸为 <code>2</code> 和 <code>3</code> 的两个包裹装入两个尺寸为 <code>4</code> 的箱子中，同时把尺寸为 <code>5</code> 的包裹装入尺寸为 <code>8</code> 的箱子中。总浪费空间为 <code>(4-2) + (4-3) + (8-5) = 6</code> 。</li>\n</ul>\n\n<p>请你选择 <strong>最优</strong> 箱子供应商，使得 <strong>总浪费空间最小</strong> 。如果 <strong>无法</strong> 将所有包裹放入箱子中，请你返回 <code>-1</code> 。由于答案可能会 <strong>很大</strong> ，请返回它对<strong> </strong><code>10<sup>9</sup> + 7</code> <b>取余</b> 的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>packages = [2,3,5], boxes = [[4,8],[2,8]]\n<b>输出：</b>6\n<b>解释：</b>选择第一个供应商最优，用两个尺寸为 4 的箱子和一个尺寸为 8 的箱子。\n总浪费空间为 (4-2) + (4-3) + (8-5) = 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>packages = [2,3,5], boxes = [[1,4],[2,3],[3,4]]\n<b>输出：</b>-1\n<b>解释：</b>没有箱子能装下尺寸为 5 的包裹。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>packages = [3,5,8,10,11,12], boxes = [[12],[11,9],[10,5,14]]\n<b>输出：</b>9\n<b>解释：</b>选择第三个供应商最优，用两个尺寸为 5 的箱子，两个尺寸为 10 的箱子和两个尺寸为 14 的箱子。\n总浪费空间为 (5-3) + (5-5) + (10-8) + (10-10) + (14-11) + (14-12) = 9 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == packages.length</code></li>\n\t<li><code>m == boxes.length</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= m <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= packages[i] <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= boxes[j].length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= boxes[j][k] <= 10<sup>5</sup></code></li>\n\t<li><code>sum(boxes[j].length) <= 10<sup>5</sup></code></li>\n\t<li><code>boxes[j]</code> 中的元素 <strong>互不相同</strong> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1890.2020年最后一次登录",
        "hardRate": "EASY",
        "passRate": "70.01%",
        "problemsUrl": "https://leetcode.cn/problems/the-latest-login-in-2020/",
        "solutionsUrl": "https://leetcode.cn/problems/the-latest-login-in-2020/solution",
        "problemsDesc": "<p>表: <code>Logins</code></p>\n\n<pre>\n+----------------+----------+\n| 列名           | 类型      |\n+----------------+----------+\n| user_id        | int      |\n| time_stamp     | datetime |\n+----------------+----------+\n(user_id, time_stamp) 是这个表的主键。\n每一行包含的信息是user_id 这个用户的登录时间。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个 SQL 查询，该查询可以获取在 <code>2020</code> 年登录过的所有用户的本年度 <strong>最后一次 </strong>登录时间。结果集 <strong>不</strong> 包含 <code>2020</code> 年没有登录过的用户。</p>\n\n<p>返回的结果集可以按 <strong>任意顺序 </strong>排列。</p>\n\n<p>查询结果格式如下例。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nLogins 表:\n+---------+---------------------+\n| user_id | time_stamp          |\n+---------+---------------------+\n| 6       | 2020-06-30 15:06:07 |\n| 6       | 2021-04-21 14:06:06 |\n| 6       | 2019-03-07 00:18:15 |\n| 8       | 2020-02-01 05:10:53 |\n| 8       | 2020-12-30 00:46:50 |\n| 2       | 2020-01-16 02:49:50 |\n| 2       | 2019-08-25 07:59:08 |\n| 14      | 2019-07-14 09:00:00 |\n| 14      | 2021-01-06 11:59:59 |\n+---------+---------------------+\n<strong>输出：</strong>\n+---------+---------------------+\n| user_id | last_stamp          |\n+---------+---------------------+\n| 6       | 2020-06-30 15:06:07 |\n| 8       | 2020-12-30 00:46:50 |\n| 2       | 2020-01-16 02:49:50 |\n+---------+---------------------+\n<strong>解释：</strong>\n6号用户登录了3次，但是在2020年仅有一次，所以结果集应包含此次登录。\n8号用户在2020年登录了2次，一次在2月，一次在12月，所以，结果集应该包含12月的这次登录。\n2号用户登录了2次，但是在2020年仅有一次，所以结果集应包含此次登录。\n14号用户在2020年没有登录，所以结果集不应包含。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1891.割绳子",
        "hardRate": "MEDIUM",
        "passRate": "42.15%",
        "problemsUrl": "https://leetcode.cn/problems/cutting-ribbons/",
        "solutionsUrl": "https://leetcode.cn/problems/cutting-ribbons/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1892.页面推荐Ⅱ",
        "hardRate": "HARD",
        "passRate": "37.60%",
        "problemsUrl": "https://leetcode.cn/problems/page-recommendations-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/page-recommendations-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1893.检查是否区域内所有整数都被覆盖",
        "hardRate": "EASY",
        "passRate": "58.87%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-all-the-integers-in-a-range-are-covered/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-all-the-integers-in-a-range-are-covered/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>ranges</code> 和两个整数 <code>left</code> 和 <code>right</code> 。每个 <code>ranges[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 表示一个从 <code>start<sub>i</sub></code> 到 <code>end<sub>i</sub></code> 的 <strong>闭区间</strong> 。</p>\n\n<p>如果闭区间 <code>[left, right]</code> 内每个整数都被 <code>ranges</code> 中 <strong>至少一个</strong> 区间覆盖，那么请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p>已知区间 <code>ranges[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> ，如果整数 <code>x</code> 满足 <code>start<sub>i</sub> <= x <= end<sub>i</sub></code> ，那么我们称整数<code>x</code> 被覆盖了。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5\n<b>输出：</b>true\n<b>解释：</b>2 到 5 的每个整数都被覆盖了：\n- 2 被第一个区间覆盖。\n- 3 和 4 被第二个区间覆盖。\n- 5 被第三个区间覆盖。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>ranges = [[1,10],[10,20]], left = 21, right = 21\n<b>输出：</b>false\n<b>解释：</b>21 没有被任何一个区间覆盖。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= ranges.length <= 50</code></li>\n\t<li><code>1 <= start<sub>i</sub> <= end<sub>i</sub> <= 50</code></li>\n\t<li><code>1 <= left <= right <= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1894.找到需要补充粉笔的学生编号",
        "hardRate": "MEDIUM",
        "passRate": "45.84%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-student-that-will-replace-the-chalk/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-student-that-will-replace-the-chalk/solution",
        "problemsDesc": "<p>一个班级里有&nbsp;<code>n</code>&nbsp;个学生，编号为 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;。每个学生会依次回答问题，编号为 <code>0</code>&nbsp;的学生先回答，然后是编号为 <code>1</code>&nbsp;的学生，以此类推，直到编号为 <code>n - 1</code>&nbsp;的学生，然后老师会重复这个过程，重新从编号为 <code>0</code>&nbsp;的学生开始回答问题。</p>\n\n<p>给你一个长度为 <code>n</code>&nbsp;且下标从 <code>0</code>&nbsp;开始的整数数组&nbsp;<code>chalk</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。一开始粉笔盒里总共有&nbsp;<code>k</code>&nbsp;支粉笔。当编号为&nbsp;<code>i</code>&nbsp;的学生回答问题时，他会消耗 <code>chalk[i]</code>&nbsp;支粉笔。如果剩余粉笔数量 <strong>严格小于</strong>&nbsp;<code>chalk[i]</code>&nbsp;，那么学生 <code>i</code>&nbsp;需要 <strong>补充</strong>&nbsp;粉笔。</p>\n\n<p>请你返回需要 <strong>补充</strong>&nbsp;粉笔的学生 <strong>编号</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>chalk = [5,1,5], k = 22\n<b>输出：</b>0\n<strong>解释：</strong>学生消耗粉笔情况如下：\n- 编号为 0 的学生使用 5 支粉笔，然后 k = 17 。\n- 编号为 1 的学生使用 1 支粉笔，然后 k = 16 。\n- 编号为 2 的学生使用 5 支粉笔，然后 k = 11 。\n- 编号为 0 的学生使用 5 支粉笔，然后 k = 6 。\n- 编号为 1 的学生使用 1 支粉笔，然后 k = 5 。\n- 编号为 2 的学生使用 5 支粉笔，然后 k = 0 。\n编号为 0 的学生没有足够的粉笔，所以他需要补充粉笔。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>chalk = [3,4,1,2], k = 25\n<b>输出：</b>1\n<b>解释：</b>学生消耗粉笔情况如下：\n- 编号为 0 的学生使用 3 支粉笔，然后 k = 22 。\n- 编号为 1 的学生使用 4 支粉笔，然后 k = 18 。\n- 编号为 2 的学生使用 1 支粉笔，然后 k = 17 。\n- 编号为 3 的学生使用 2 支粉笔，然后 k = 15 。\n- 编号为 0 的学生使用 3 支粉笔，然后 k = 12 。\n- 编号为 1 的学生使用 4 支粉笔，然后 k = 8 。\n- 编号为 2 的学生使用 1 支粉笔，然后 k = 7 。\n- 编号为 3 的学生使用 2 支粉笔，然后 k = 5 。\n- 编号为 0 的学生使用 3 支粉笔，然后 k = 2 。\n编号为 1 的学生没有足够的粉笔，所以他需要补充粉笔。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>chalk.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= chalk[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1895.最大的幻方",
        "hardRate": "MEDIUM",
        "passRate": "56.28%",
        "problemsUrl": "https://leetcode.cn/problems/largest-magic-square/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-magic-square/solution",
        "problemsDesc": "<p>一个 <code>k x k</code> 的<strong> 幻方</strong> 指的是一个 <code>k x k</code> 填满整数的方格阵，且每一行、每一列以及两条对角线的和 <strong>全部</strong><strong>相等</strong> 。幻方中的整数 <strong>不需要互不相同</strong> 。显然，每个 <code>1 x 1</code> 的方格都是一个幻方。</p>\n\n<p>给你一个 <code>m x n</code> 的整数矩阵 <code>grid</code> ，请你返回矩阵中 <strong>最大幻方</strong> 的 <strong>尺寸</strong> （即边长 <code>k</code>）。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/29/magicsquare-grid.jpg\" style=\"width: 413px; height: 335px;\">\n<pre><b>输入：</b>grid = [[7,1,4,5,6],[2,5,1,6,4],[1,5,4,3,2],[1,2,7,3,4]]\n<b>输出：</b>3\n<b>解释：</b>最大幻方尺寸为 3 。\n每一行，每一列以及两条对角线的和都等于 12 。\n- 每一行的和：5+1+6 = 5+4+3 = 2+7+3 = 12\n- 每一列的和：5+5+2 = 1+4+7 = 6+3+3 = 12\n- 对角线的和：5+4+3 = 6+4+2 = 12\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/29/magicsquare2-grid.jpg\" style=\"width: 333px; height: 255px;\">\n<pre><b>输入：</b>grid = [[5,1,3,1],[9,3,3,1],[1,3,3,8]]\n<b>输出：</b>2\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1896.反转表达式值的最少操作次数",
        "hardRate": "HARD",
        "passRate": "51.52%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-change-the-final-value-of-expression/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-change-the-final-value-of-expression/solution",
        "problemsDesc": "<p>给你一个 <strong>有效的</strong> 布尔表达式，用字符串 <code>expression</code> 表示。这个字符串包含字符 <code>'1'</code>，<code>'0'</code>，<code>'&amp;'</code>（按位 <strong>与</strong> 运算），<code>'|'</code>（按位 <strong>或</strong> 运算），<code>'('</code> 和 <code>')'</code> 。</p>\n\n<ul>\n\t<li>比方说，<code>\"()1|1\"</code> 和 <code>\"(1)&amp;()\"</code> <strong>不是有效</strong> 布尔表达式。而 <code>\"1\"</code>， <code>\"(((1))|(0))\"</code> 和 <code>\"1|(0&amp;(1))\"</code> 是 <strong>有效</strong> 布尔表达式。</li>\n</ul>\n\n<p>你的目标是将布尔表达式的 <strong>值</strong> <strong>反转 </strong>（也就是将 <code>0</code> 变为 <code>1</code> ，或者将 <code>1</code> 变为 <code>0</code>），请你返回达成目标需要的 <strong>最少操作</strong> 次数。</p>\n\n<ul>\n\t<li>比方说，如果表达式 <code>expression = \"1|1|(0&amp;0)&amp;1\"</code> ，它的 <strong>值</strong> 为 <code>1|1|(0&amp;0)&amp;1 = 1|1|0&amp;1 = 1|0&amp;1 = 1&amp;1 = 1</code> 。我们想要执行操作将 <strong>新的</strong> 表达式的值变成 <code>0</code> 。</li>\n</ul>\n\n<p>可执行的 <strong>操作</strong> 如下：</p>\n\n<ul>\n\t<li>将一个 <code>'1'</code> 变成一个 <code>'0'</code> 。</li>\n\t<li>将一个 <code>'0'</code> 变成一个 <code>'1'</code> 。</li>\n\t<li>将一个 <code>'&amp;'</code> 变成一个 <code>'|'</code> 。</li>\n\t<li>将一个 <code>'|'</code> 变成一个 <code>'&amp;'</code> 。</li>\n</ul>\n\n<p><strong>注意：</strong><code>'&amp;'</code> 的 <strong>运算优先级</strong> 与 <code>'|'</code> <strong>相同</strong> 。计算表达式时，括号优先级 <strong>最高</strong> ，然后按照 <strong>从左到右</strong> 的顺序运算。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>expression = \"1&amp;(0|1)\"\n<b>输出：</b>1\n<b>解释：</b>我们可以将 \"1&amp;(0<strong>|</strong>1)\" 变成 \"1&amp;(0<strong>&amp;</strong>1)\" ，执行的操作为将一个 '|' 变成一个 '&amp;' ，执行了 1 次操作。\n新表达式的值为 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>expression = \"(0&amp;0)&amp;(0&amp;0&amp;0)\"\n<b>输出：</b>3\n<b>解释：</b>我们可以将 \"(0<strong>&amp;0</strong>)<strong>&amp;</strong>(0&amp;0&amp;0)\" 变成 \"(0<strong>|1</strong>)<strong>|</strong>(0&amp;0&amp;0)\" ，执行了 3 次操作。\n新表达式的值为 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>expression = \"(0|(1|0&amp;1))\"\n<b>输出：</b>1\n<b>解释：</b>我们可以将 \"(0|(<strong>1</strong>|0&amp;1))\" 变成 \"(0|(<strong>0</strong>|0&amp;1))\" ，执行了 1 次操作。\n新表达式的值为 0 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= expression.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>expression</code> 只包含 <code>'1'</code>，<code>'0'</code>，<code>'&amp;'</code>，<code>'|'</code>，<code>'('</code> 和 <code>')'</code></li>\n\t<li>所有括号都有与之匹配的对应括号。</li>\n\t<li>不会有空的括号（也就是说 <code>\"()\"</code> 不是 <code>expression</code> 的子字符串）。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1897.重新分配字符使所有字符串都相等",
        "hardRate": "EASY",
        "passRate": "55.24%",
        "problemsUrl": "https://leetcode.cn/problems/redistribute-characters-to-make-all-strings-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/redistribute-characters-to-make-all-strings-equal/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>words</code>（下标 <strong>从 0 开始</strong> 计数）。</p>\n\n<p>在一步操作中，需先选出两个 <strong>不同</strong> 下标 <code>i</code> 和 <code>j</code>，其中 <code>words[i]</code> 是一个非空字符串，接着将 <code>words[i]</code> 中的 <strong>任一</strong> 字符移动到 <code>words[j]</code> 中的 <strong>任一</strong> 位置上。</p>\n\n<p>如果执行任意步操作可以使 <code>words</code> 中的每个字符串都相等，返回 <code>true</code><em> </em>；否则，返回<em> </em><code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"abc\",\"aabc\",\"bc\"]\n<strong>输出：</strong>true\n<strong>解释：</strong>将 <code>words[1] 中的第一个</code> 'a' 移动到<code> words[2] 的最前面。\n使 </code><code>words[1]</code> = \"abc\" 且 words[2] = \"abc\" 。\n所有字符串都等于 \"abc\" ，所以返回 <code>true</code> 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"ab\",\"a\"]\n<strong>输出：</strong>false\n<strong>解释：</strong>执行操作无法使所有字符串都相等。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><code>words[i]</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1898.可移除字符的最大数目",
        "hardRate": "MEDIUM",
        "passRate": "38.05%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-removable-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-removable-characters/solution",
        "problemsDesc": "<p>给你两个字符串 <code>s</code> 和 <code>p</code> ，其中 <code>p</code> 是 <code>s</code> 的一个 <strong>子序列</strong> 。同时，给你一个元素 <strong>互不相同</strong> 且下标 <strong>从 0 开始</strong> 计数的整数数组 <code>removable</code> ，该数组是 <code>s</code> 中下标的一个子集（<code>s</code> 的下标也 <strong>从 0 开始</strong> 计数）。</p>\n\n<p>请你找出一个整数 <code>k</code>（<code>0 <= k <= removable.length</code>），选出 <code>removable</code> 中的 <strong>前</strong> <code>k</code> 个下标，然后从 <code>s</code> 中移除这些下标对应的 <code>k</code> 个字符。整数 <code>k</code> 需满足：在执行完上述步骤后， <code>p</code> 仍然是 <code>s</code> 的一个 <strong>子序列</strong> 。更正式的解释是，对于每个 <code>0 <= i < k</code> ，先标记出位于 <code>s[removable[i]]</code> 的字符，接着移除所有标记过的字符，然后检查 <code>p</code> 是否仍然是 <code>s</code> 的一个子序列。</p>\n\n<p>返回你可以找出的 <strong>最大</strong><em> </em><code>k</code><em> </em>，满足在移除字符后<em> </em><code>p</code><em> </em>仍然是 <code>s</code> 的一个子序列。</p>\n\n<p>字符串的一个 <strong>子序列</strong> 是一个由原字符串生成的新字符串，生成过程中可能会移除原字符串中的一些字符（也可能不移除）但不改变剩余字符之间的相对顺序。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcacb\", p = \"ab\", removable = [3,1,0]\n<strong>输出：</strong>2\n<strong>解释：</strong>在移除下标 3 和 1 对应的字符后，\"a<strong>b</strong>c<strong>a</strong>cb\" 变成 \"accb\" 。\n\"ab\" 是 \"<strong>a</strong>cc<strong>b</strong>\" 的一个子序列。\n如果移除下标 3、1 和 0 对应的字符后，\"<strong>ab</strong>c<strong>a</strong>cb\" 变成 \"ccb\" ，那么 \"ab\" 就不再是 s 的一个子序列。\n因此，最大的 k 是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcbddddd\", p = \"abcd\", removable = [3,2,1,4,5,6]\n<strong>输出：</strong>1\n<strong>解释：</strong>在移除下标 3 对应的字符后，\"abc<strong>b</strong>ddddd\" 变成 \"abcddddd\" 。\n\"abcd\" 是 \"<strong>abcd</strong>dddd\" 的一个子序列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcab\", p = \"abc\", removable = [0,1,2,3,4]\n<strong>输出：</strong>0\n<strong>解释：</strong>如果移除数组 removable 的第一个下标，\"abc\" 就不再是 s 的一个子序列。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= p.length <= s.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= removable.length < s.length</code></li>\n\t<li><code>0 <= removable[i] < s.length</code></li>\n\t<li><code>p</code> 是 <code>s</code> 的一个 <strong>子字符串</strong></li>\n\t<li><code>s</code> 和 <code>p</code> 都由小写英文字母组成</li>\n\t<li><code>removable</code> 中的元素 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1899.合并若干三元组以形成目标三元组",
        "hardRate": "MEDIUM",
        "passRate": "65.35%",
        "problemsUrl": "https://leetcode.cn/problems/merge-triplets-to-form-target-triplet/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-triplets-to-form-target-triplet/solution",
        "problemsDesc": "<p><strong>三元组</strong> 是一个由三个整数组成的数组。给你一个二维整数数组 <code>triplets</code> ，其中 <code>triplets[i] = [a<sub>i</sub>, b<sub>i</sub>, c<sub>i</sub>]</code> 表示第 <code>i</code> 个 <strong>三元组</strong> 。同时，给你一个整数数组 <code>target = [x, y, z]</code> ，表示你想要得到的 <strong>三元组</strong> 。</p>\n\n<p>为了得到 <code>target</code> ，你需要对 <code>triplets</code> 执行下面的操作 <strong>任意次</strong>（可能 <strong>零</strong> 次）：</p>\n\n<ul>\n\t<li>选出两个下标（下标 <strong>从 0 开始</strong> 计数）<code>i</code> 和 <code>j</code>（<code>i != j</code>），并 <strong>更新</strong> <code>triplets[j]</code> 为 <code>[max(a<sub>i</sub>, a<sub>j</sub>), max(b<sub>i</sub>, b<sub>j</sub>), max(c<sub>i</sub>, c<sub>j</sub>)]</code> 。\n\n\t<ul>\n\t\t<li>例如，<code>triplets[i] = [2, 5, 3]</code> 且 <code>triplets[j] = [1, 7, 5]</code>，<code>triplets[j]</code> 将会更新为 <code>[max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5]</code> 。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>如果通过以上操作我们可以使得目标 <strong>三元组</strong> <code>target</code> 成为 <code>triplets</code> 的一个 <strong>元素</strong> ，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>执行下述操作：\n- 选择第一个和最后一个三元组 [<strong>[2,5,3]</strong>,[1,8,4],<strong>[1,7,5]</strong>] 。更新最后一个三元组为 [max(2,1), max(5,7), max(3,5)] = [2,7,5] 。triplets = [[2,5,3],[1,8,4],<strong>[2,7,5]</strong>]\n目标三元组 [2,7,5] 现在是 triplets 的一个元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>triplets = [[1,3,4],[2,5,8]], target = [2,5,8]\n<strong>输出：</strong>true\n<strong>解释：</strong>目标三元组 [2,5,8] 已经是 triplets 的一个元素。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], target = [5,5,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>执行下述操作：\n- 选择第一个和第三个三元组 [<strong>[2,5,3]</strong>,[2,3,4],<strong>[1,2,5]</strong>,[5,2,3]] 。更新第三个三元组为 [max(2,1), max(5,2), max(3,5)] = [2,5,5] 。triplets = [[2,5,3],[2,3,4],<strong>[2,5,5]</strong>,[5,2,3]] 。\n- 选择第三个和第四个三元组 [[2,5,3],[2,3,4],<strong>[2,5,5]</strong>,<strong>[5,2,3]</strong>] 。更新第四个三元组为 [max(2,5), max(5,2), max(5,3)] = [5,5,5] 。triplets = [[2,5,3],[2,3,4],[2,5,5],<strong>[5,5,5]</strong>] 。\n目标三元组 [5,5,5] 现在是 triplets 的一个元素。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>triplets = [[3,4,5],[4,5,6]], target = [3,2,5]\n<strong>输出：</strong>false\n<strong>解释：</strong>无法得到 [3,2,5] ，因为 triplets 不含 2 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= triplets.length <= 10<sup>5</sup></code></li>\n\t<li><code>triplets[i].length == target.length == 3</code></li>\n\t<li><code>1 <= a<sub>i</sub>, b<sub>i</sub>, c<sub>i</sub>, x, y, z <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1900.最佳运动员的比拼回合",
        "hardRate": "HARD",
        "passRate": "45.87%",
        "problemsUrl": "https://leetcode.cn/problems/the-earliest-and-latest-rounds-where-players-compete/",
        "solutionsUrl": "https://leetcode.cn/problems/the-earliest-and-latest-rounds-where-players-compete/solution",
        "problemsDesc": "<p><code>n</code> 名运动员参与一场锦标赛，所有运动员站成一排，并根据 <strong>最开始的</strong> 站位从 <code>1</code> 到 <code>n</code> 编号（运动员 <code>1</code> 是这一排中的第一个运动员，运动员 <code>2</code> 是第二个运动员，依此类推）。</p>\n\n<p>锦标赛由多个回合组成（从回合 <code>1</code> 开始）。每一回合中，这一排从前往后数的第 <code>i</code> 名运动员需要与从后往前数的第 <code>i</code> 名运动员比拼，获胜者将会进入下一回合。如果当前回合中运动员数目为奇数，那么中间那位运动员将轮空晋级下一回合。</p>\n\n<ul>\n\t<li>例如，当前回合中，运动员 <code>1, 2, 4, 6, 7</code> 站成一排\n\n\t<ul>\n\t\t<li>运动员 <code>1</code> 需要和运动员 <code>7</code> 比拼</li>\n\t\t<li>运动员 <code>2</code> 需要和运动员 <code>6</code> 比拼</li>\n\t\t<li>运动员 <code>4</code> 轮空晋级下一回合</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>每回合结束后，获胜者将会基于最开始分配给他们的原始顺序（升序）重新排成一排。</p>\n\n<p>编号为 <code>firstPlayer</code> 和 <code>secondPlayer</code> 的运动员是本场锦标赛中的最佳运动员。在他们开始比拼之前，完全可以战胜任何其他运动员。而任意两个其他运动员进行比拼时，其中任意一个都有获胜的可能，因此你可以 <strong>裁定</strong> 谁是这一回合的获胜者。</p>\n\n<p>给你三个整数 <code>n</code>、<code>firstPlayer</code> 和 <code>secondPlayer</code> 。返回一个由两个值组成的整数数组，分别表示两位最佳运动员在本场锦标赛中比拼的 <strong>最早</strong> 回合数和 <strong>最晚</strong> 回合数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 11, firstPlayer = 2, secondPlayer = 4\n<strong>输出：</strong>[3,4]\n<strong>解释：</strong>\n一种能够产生最早回合数的情景是：\n回合 1：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n回合 2：2, 3, 4, 5, 6, 11\n回合 3：2, 3, 4\n一种能够产生最晚回合数的情景是：\n回合 1：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n回合 2：1, 2, 3, 4, 5, 6\n回合 3：1, 2, 4\n回合 4：2, 4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 5, firstPlayer = 1, secondPlayer = 5\n<strong>输出：</strong>[1,1]\n<strong>解释：</strong>两名最佳运动员 1 和 5 将会在回合 1 进行比拼。\n不存在使他们在其他回合进行比拼的可能。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 28</code></li>\n\t<li><code>1 &lt;= firstPlayer &lt; secondPlayer &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1901.寻找峰值 II",
        "hardRate": "MEDIUM",
        "passRate": "58.93%",
        "problemsUrl": "https://leetcode.cn/problems/find-a-peak-element-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/find-a-peak-element-ii/solution",
        "problemsDesc": "<p>一个 2D 网格中的 <strong>峰值</strong><strong> </strong>是指那些 <strong>严格大于 </strong>其相邻格子(上、下、左、右)的元素。</p>\n\n<p>给你一个<strong> 从 0 开始编号 </strong>的 <code>m x n</code> 矩阵 <code>mat</code> ，其中任意两个相邻格子的值都<strong> 不相同</strong> 。找出 <strong>任意一个 峰值</strong> <code>mat[i][j]</code> 并 <strong>返回其位置 </strong><code>[i,j]</code> 。</p>\n\n<p>你可以假设整个矩阵周边环绕着一圈值为 <code>-1</code> 的格子。</p>\n\n<p>要求必须写出时间复杂度为 <code>O(m log(n))</code> 或 <code>O(n log(m))</code> 的算法</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/08/1.png\" style=\"width: 206px; height: 209px;\" /></p>\n\n<pre>\n<strong>输入:</strong> mat = [[1,4],[3,2]]\n<strong>输出:</strong> [0,1]\n<strong>解释:</strong>&nbsp;3 和 4 都是峰值，所以[1,0]和[0,1]都是可接受的答案。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/07/3.png\" style=\"width: 254px; height: 257px;\" /></strong></p>\n\n<pre>\n<strong>输入:</strong> mat = [[10,20,15],[21,30,14],[7,16,32]]\n<strong>输出:</strong> [1,1]\n<strong>解释:</strong>&nbsp;30 和 32 都是峰值，所以[1,1]和[2,2]都是可接受的答案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>1 &lt;= mat[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li>任意两个相邻元素均不相等.</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1902.给定二叉搜索树的插入顺序求深度",
        "hardRate": "MEDIUM",
        "passRate": "50.93%",
        "problemsUrl": "https://leetcode.cn/problems/depth-of-bst-given-insertion-order/",
        "solutionsUrl": "https://leetcode.cn/problems/depth-of-bst-given-insertion-order/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1903.字符串中的最大奇数",
        "hardRate": "EASY",
        "passRate": "60.47%",
        "problemsUrl": "https://leetcode.cn/problems/largest-odd-number-in-string/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-odd-number-in-string/solution",
        "problemsDesc": "<p>给你一个字符串 <code>num</code> ，表示一个大整数。请你在字符串 <code>num</code> 的所有 <strong>非空子字符串</strong> 中找出 <strong>值最大的奇数</strong> ，并以字符串形式返回。如果不存在奇数，则返回一个空字符串<em> </em><code>\"\"</code><em> </em>。</p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续的字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"52\"\n<strong>输出：</strong>\"5\"\n<strong>解释：</strong>非空子字符串仅有 \"5\"、\"2\" 和 \"52\" 。\"5\" 是其中唯一的奇数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"4206\"\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>在 \"4206\" 中不存在奇数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"35427\"\n<strong>输出：</strong>\"35427\"\n<strong>解释：</strong>\"35427\" 本身就是一个奇数。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= num.length <= 10<sup>5</sup></code></li>\n\t<li><code>num</code> 仅由数字组成且不含前导零</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1904.你完成的完整对局数",
        "hardRate": "MEDIUM",
        "passRate": "31.39%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-full-rounds-you-have-played/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-full-rounds-you-have-played/solution",
        "problemsDesc": "<p>一款新的在线电子游戏在近期发布，在该电子游戏中，以 <strong>刻钟</strong> 为周期规划若干时长为 <strong>15 分钟</strong> 的游戏对局。这意味着，在 <code>HH:00</code>、<code>HH:15</code>、<code>HH:30</code> 和 <code>HH:45</code> ，将会开始一个新的对局，其中 <code>HH</code> 用一个从 <code>00</code> 到 <code>23</code> 的整数表示。游戏中使用 <strong>24 小时制的时钟</strong> ，所以一天中最早的时间是 <code>00:00</code> ，最晚的时间是 <code>23:59</code> 。</p>\n\n<p>给你两个字符串 <code>startTime</code> 和 <code>finishTime</code> ，均符合 <code>\"HH:MM\"</code> 格式，分别表示你 <strong>进入</strong> 和 <strong>退出</strong> 游戏的确切时间，请计算在整个游戏会话期间，你完成的 <strong>完整对局的对局数</strong> 。</p>\n\n<ul>\n\t<li>例如，如果 <code>startTime = \"05:20\"</code> 且 <code>finishTime = \"05:59\"</code> ，这意味着你仅仅完成从 <code>05:30</code> 到 <code>05:45</code> 这一个完整对局。而你没有完成从 <code>05:15</code> 到 <code>05:30</code> 的完整对局，因为你是在对局开始后进入的游戏；同时，你也没有完成从 <code>05:45</code> 到 <code>06:00</code> 的完整对局，因为你是在对局结束前退出的游戏。</li>\n</ul>\n\n<p>如果 <code>finishTime</code> <strong>早于</strong> <code>startTime</code> ，这表示你玩了个通宵（也就是从 <code>startTime</code> 到午夜，再从午夜到 <code>finishTime</code>）。</p>\n\n<p>假设你是从 <code>startTime</code> 进入游戏，并在 <code>finishTime</code> 退出游戏，请计算并返回你完成的 <strong>完整对局的对局数</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>startTime = \"12:01\", finishTime = \"12:44\"\n<strong>输出：</strong>1\n<strong>解释：</strong>你完成了从 12:15 到 12:30 的一个完整对局。\n你没有完成从 12:00 到 12:15 的完整对局，因为你是在对局开始后的 12:01 进入的游戏。\n你没有完成从 12:30 到 12:45 的完整对局，因为你是在对局结束前的 12:44 退出的游戏。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>startTime = \"20:00\", finishTime = \"06:00\"\n<strong>输出：</strong>40\n<strong>解释：</strong>你完成了从 20:00 到 00:00 的 16 个完整的对局，以及从 00:00 到 06:00 的 24 个完整的对局。\n16 + 24 = 40\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>startTime = \"00:00\", finishTime = \"23:59\"\n<strong>输出：</strong>95\n<strong>解释：</strong>除最后一个小时你只完成了 3 个完整对局外，其余每个小时均完成了 4 场完整对局。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>startTime</code> 和 <code>finishTime</code> 的格式为 <code>HH:MM</code></li>\n\t<li><code>00 <= HH <= 23</code></li>\n\t<li><code>00 <= MM <= 59</code></li>\n\t<li><code>startTime</code> 和 <code>finishTime</code> 不相等</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1905.统计子岛屿",
        "hardRate": "MEDIUM",
        "passRate": "67.13%",
        "problemsUrl": "https://leetcode.cn/problems/count-sub-islands/",
        "solutionsUrl": "https://leetcode.cn/problems/count-sub-islands/solution",
        "problemsDesc": "<p>给你两个 <code>m x n</code> 的二进制矩阵 <code>grid1</code> 和 <code>grid2</code> ，它们只包含 <code>0</code> （表示水域）和 <code>1</code> （表示陆地）。一个 <strong>岛屿</strong> 是由 <strong>四个方向</strong> （水平或者竖直）上相邻的 <code>1</code> 组成的区域。任何矩阵以外的区域都视为水域。</p>\n\n<p>如果 <code>grid2</code> 的一个岛屿，被 <code>grid1</code> 的一个岛屿 <strong>完全</strong> 包含，也就是说 <code>grid2</code> 中该岛屿的每一个格子都被 <code>grid1</code> 中同一个岛屿完全包含，那么我们称 <code>grid2</code> 中的这个岛屿为 <strong>子岛屿</strong> 。</p>\n\n<p>请你返回 <code>grid2</code> 中 <strong>子岛屿</strong> 的 <strong>数目</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/10/test1.png\" style=\"width: 493px; height: 205px;\">\n<pre><b>输入：</b>grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]\n<b>输出：</b>3\n<strong>解释：</strong>如上图所示，左边为 grid1 ，右边为 grid2 。\ngrid2 中标红的 1 区域是子岛屿，总共有 3 个子岛屿。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/03/testcasex2.png\" style=\"width: 491px; height: 201px;\">\n<pre><b>输入：</b>grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\n<b>输出：</b>2 \n<strong>解释：</strong>如上图所示，左边为 grid1 ，右边为 grid2 。\ngrid2 中标红的 1 区域是子岛屿，总共有 2 个子岛屿。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid1.length == grid2.length</code></li>\n\t<li><code>n == grid1[i].length == grid2[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>grid1[i][j]</code> 和 <code>grid2[i][j]</code> 都要么是 <code>0</code> 要么是 <code>1</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1906.查询差绝对值的最小值",
        "hardRate": "MEDIUM",
        "passRate": "44.98%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-absolute-difference-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-absolute-difference-queries/solution",
        "problemsDesc": "<p>一个数组 <code>a</code> 的 <strong>差绝对值的最小值</strong> 定义为：<code>0 <= i < j < a.length</code> 且 <code>a[i] != a[j]</code> 的<strong> </strong><code><span style=\"\">|a[i] - a[j]|</span></code> 的 <strong>最小值</strong>。如果 <code>a</code> 中所有元素都 <strong>相同</strong> ，那么差绝对值的最小值为 <code>-1</code> 。</p>\n\n<ul>\n\t<li>比方说，数组 <code>[5,<strong>2</strong>,<strong>3</strong>,7,2]</code> 差绝对值的最小值是 <code>|2 - 3| = 1</code> 。注意答案不为 <code>0</code> ，因为 <code>a[i]</code> 和 <code>a[j]</code> 必须不相等。</li>\n</ul>\n\n<p>给你一个整数数组 <code>nums</code> 和查询数组 <code>queries</code> ，其中 <code>queries[i] = [l<sub>i</sub>, r<sub>i</sub>]</code> 。对于每个查询 <code>i</code> ，计算 <strong>子数组</strong> <code>nums[l<sub>i</sub>...r<sub>i</sub>]</code> 中 <strong>差绝对值的最小值</strong> ，子数组 <code>nums[l<sub>i</sub>...r<sub>i</sub>]</code> 包含 <code>nums</code> 数组（下标从 <strong>0</strong> 开始）中下标在 <code>l<sub>i</sub></code> 和 <code>r<sub>i</sub></code> 之间的所有元素（包含 <code>l<sub>i</sub></code> 和 <code>r<sub>i</sub></code> 在内）。</p>\n\n<p>请你返回 <code>ans</code> <strong>数组</strong>，其中 <code>ans[i]</code> 是第 <code>i</code> 个查询的答案。</p>\n\n<p><strong>子数组</strong> 是一个数组中连续的一段元素。</p>\n\n<p><code>|x|</code> 的值定义为：</p>\n\n<ul>\n\t<li>如果 <code>x >= 0</code> ，那么值为 <code>x</code> 。</li>\n\t<li>如果 <code>x < 0</code> ，那么值为 <code>-x</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,3,4,8], queries = [[0,1],[1,2],[2,3],[0,3]]\n<b>输出：</b>[2,1,4,1]\n<b>解释：</b>查询结果如下：\n- queries[0] = [0,1]：子数组是 [<strong>1</strong>,<strong>3</strong>] ，差绝对值的最小值为 |1-3| = 2 。\n- queries[1] = [1,2]：子数组是 [<strong>3</strong>,<strong>4</strong>] ，差绝对值的最小值为 |3-4| = 1 。\n- queries[2] = [2,3]：子数组是 [<strong>4</strong>,<strong>8</strong>] ，差绝对值的最小值为 |4-8| = 4 。\n- queries[3] = [0,3]：子数组是 [1,<strong>3</strong>,<strong>4</strong>,8] ，差的绝对值的最小值为 |3-4| = 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [4,5,2,2,7,10], queries = [[2,3],[0,2],[0,5],[3,5]]\n<b>输出：</b>[-1,1,1,3]\n<strong>解释：</strong>查询结果如下：\n- queries[0] = [2,3]：子数组是 [2,2] ，差绝对值的最小值为 -1 ，因为所有元素相等。\n- queries[1] = [0,2]：子数组是 [<strong>4</strong>,<strong>5</strong>,2] ，差绝对值的最小值为 |4-5| = 1 。\n- queries[2] = [0,5]：子数组是 [<strong>4</strong>,<strong>5</strong>,2,2,7,10] ，差绝对值的最小值为 |4-5| = 1 。\n- queries[3] = [3,5]：子数组是 [2,<strong>7</strong>,<strong>10</strong>] ，差绝对值的最小值为 |7-10| = 3 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= 100</code></li>\n\t<li><code>1 <= queries.length <= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 <= l<sub>i</sub> < r<sub>i</sub> < nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1907.按分类统计薪水",
        "hardRate": "MEDIUM",
        "passRate": "63.48%",
        "problemsUrl": "https://leetcode.cn/problems/count-salary-categories/",
        "solutionsUrl": "https://leetcode.cn/problems/count-salary-categories/solution",
        "problemsDesc": "<p>表: <code>Accounts</code></p>\n\n<pre>\n+-------------+------+\n| 列名        | 类型  |\n+-------------+------+\n| account_id  | int  |\n| income      | int  |\n+-------------+------+\naccount_id&nbsp;是这个表的主键。\n每一行都包含一个银行帐户的月收入的信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写出一个&nbsp;SQL&nbsp;查询，来报告每个工资类别的银行账户数量。&nbsp;工资类别如下：</p>\n\n<ul>\n\t<li><code>\"Low Salary\"</code>：所有工资 <strong>严格低于</strong> <code>20000</code> 美元。</li>\n\t<li><code>\"Average Salary\"</code>： <strong>包含</strong> 范围内的所有工资&nbsp;<code>[$20000,&nbsp;$50000]</code> 。</li>\n\t<li>\n\t<p><code>\"High Salary\"</code>：所有工资 <strong>严格大于</strong> <code>50000</code> 美元。</p>\n\t</li>\n</ul>\n\n<p>结果表 <strong>必须</strong> 包含所有三个类别。&nbsp;如果某个类别中没有帐户，则报告&nbsp;<code>0</code> 。</p>\n\n<p>按 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式如下示例。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>\nAccounts 表:\n+------------+--------+\n| account_id | income |\n+------------+--------+\n| 3          | 108939 |\n| 2          | 12747  |\n| 8          | 87709  |\n| 6          | 91796  |\n+------------+--------+\n<strong>输出：</strong>\n+----------------+----------------+\n| category       | accounts_count |\n+----------------+----------------+\n| Low Salary     | 1              |\n| Average Salary | 0              |\n| High Salary    | 3              |\n+----------------+----------------+\n<strong>解释：</strong>\n低薪: 数量为 2.\n中等薪水: 没有.\n高薪: 有三个账户，他们是 3, 6和 8.</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1908.Nim 游戏 II",
        "hardRate": "MEDIUM",
        "passRate": "62.41%",
        "problemsUrl": "https://leetcode.cn/problems/game-of-nim/",
        "solutionsUrl": "https://leetcode.cn/problems/game-of-nim/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1909.删除一个元素使数组严格递增",
        "hardRate": "EASY",
        "passRate": "29.97%",
        "problemsUrl": "https://leetcode.cn/problems/remove-one-element-to-make-the-array-strictly-increasing/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-one-element-to-make-the-array-strictly-increasing/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，如果 <strong>恰好</strong> 删除 <strong>一个</strong> 元素后，数组 <strong>严格递增</strong> ，那么请你返回 <code>true</code> ，否则返回 <code>false</code> 。如果数组本身已经是严格递增的，请你也返回 <code>true</code> 。</p>\n\n<p>数组 <code>nums</code> 是 <strong>严格递增</strong> 的定义为：对于任意下标的 <code>1 &lt;= i &lt; nums.length</code> 都满足 <code>nums[i - 1] &lt; nums[i]</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,<strong>10</strong>,5,7]\n<b>输出：</b>true\n<b>解释：</b>从 nums 中删除下标 2 处的 10 ，得到 [1,2,5,7] 。\n[1,2,5,7] 是严格递增的，所以返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,3,1,2]\n<b>输出：</b>false\n<b>解释：</b>\n[3,1,2] 是删除下标 0 处元素后得到的结果。\n[2,1,2] 是删除下标 1 处元素后得到的结果。\n[2,3,2] 是删除下标 2 处元素后得到的结果。\n[2,3,1] 是删除下标 3 处元素后得到的结果。\n没有任何结果数组是严格递增的，所以返回 false 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [1,1,1]\n<b>输出：</b>false\n<b>解释：</b>删除任意元素后的结果都是 [1,1] 。\n[1,1] 不是严格递增的，所以返回 false 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3]\n<b>输出：</b>true\n<b>解释：</b>[1,2,3] 已经是严格递增的，所以返回 true 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1910.删除一个字符串中所有出现的给定子字符串",
        "hardRate": "MEDIUM",
        "passRate": "66.47%",
        "problemsUrl": "https://leetcode.cn/problems/remove-all-occurrences-of-a-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-all-occurrences-of-a-substring/solution",
        "problemsDesc": "<p>给你两个字符串 <code>s</code> 和 <code>part</code> ，请你对 <code>s</code> 反复执行以下操作直到 <b>所有</b> 子字符串 <code>part</code> 都被删除：</p>\n\n<ul>\n\t<li>找到 <code>s</code> 中 <strong>最左边</strong> 的子字符串 <code>part</code> ，并将它从 <code>s</code> 中删除。</li>\n</ul>\n\n<p>请你返回从 <code>s</code> 中删除所有 <code>part</code> 子字符串以后得到的剩余字符串。</p>\n\n<p>一个 <strong>子字符串</strong> 是一个字符串中连续的字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"daabcbaabcbc\", part = \"abc\"\n<b>输出：</b>\"dab\"\n<b>解释：</b>以下操作按顺序执行：\n- s = \"da<strong>abc</strong>baabcbc\" ，删除下标从 2 开始的 \"abc\" ，得到 s = \"dabaabcbc\" 。\n- s = \"daba<strong>abc</strong>bc\" ，删除下标从 4 开始的 \"abc\" ，得到 s = \"dababc\" 。\n- s = \"dab<strong>abc</strong>\" ，删除下标从 3 开始的 \"abc\" ，得到 s = \"dab\" 。\n此时 s 中不再含有子字符串 \"abc\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"axxxxyyyyb\", part = \"xy\"\n<b>输出：</b>\"ab\"\n<b>解释：</b>以下操作按顺序执行：\n- s = \"axxx<strong>xy</strong>yyyb\" ，删除下标从 4 开始的 \"xy\" ，得到 s = \"axxxyyyb\" 。\n- s = \"axx<strong>xy</strong>yyb\" ，删除下标从 3 开始的 \"xy\" ，得到 s = \"axxyyb\" 。\n- s = \"ax<strong>xy</strong>yb\" ，删除下标从 2 开始的 \"xy\" ，得到 s = \"axyb\" 。\n- s = \"a<strong>xy</strong>b\" ，删除下标从 1 开始的 \"xy\" ，得到 s = \"ab\" 。\n此时 s 中不再含有子字符串 \"xy\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= part.length &lt;= 1000</code></li>\n\t<li><code>s</code>​​​​​​ 和 <code>part</code> 只包小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1911.最大子序列交替和",
        "hardRate": "MEDIUM",
        "passRate": "59.19%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-alternating-subsequence-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-alternating-subsequence-sum/solution",
        "problemsDesc": "<p>一个下标从 <strong>0</strong> 开始的数组的 <strong>交替和</strong> 定义为 <strong>偶数</strong> 下标处元素之 <strong>和</strong> 减去 <strong>奇数</strong> 下标处元素之 <strong>和</strong> 。</p>\n\n<ul>\n\t<li>比方说，数组 <code>[4,2,5,3]</code> 的交替和为 <code>(4 + 5) - (2 + 3) = 4</code> 。</li>\n</ul>\n\n<p>给你一个数组 <code>nums</code> ，请你返回 <code>nums</code> 中任意子序列的 <strong>最大交替和</strong> （子序列的下标 <strong>重新</strong> 从 0 开始编号）。</p>\n\n<ul>\n</ul>\n\n<p>一个数组的 <strong>子序列</strong> 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。比方说，<code>[2,7,4]</code> 是 <code>[4,<strong>2</strong>,3,<strong>7</strong>,2,1,<strong>4</strong>]</code> 的一个子序列（加粗元素），但是 <code>[2,4,2]</code> 不是。</p>\n\n<p> </p>\n\n<p><b>示例 1：</b></p>\n\n<pre><b>输入：</b>nums = [<strong>4</strong>,<strong>2</strong>,<strong>5</strong>,3]\n<b>输出：</b>7\n<b>解释：</b>最优子序列为 [4,2,5] ，交替和为 (4 + 5) - 2 = 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [5,6,7,<strong>8</strong>]\n<b>输出：</b>8\n<b>解释：</b>最优子序列为 [8] ，交替和为 8 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [<strong>6</strong>,2,<strong>1</strong>,2,4,<strong>5</strong>]\n<b>输出：</b>10\n<b>解释：</b>最优子序列为 [6,1,5] ，交替和为 (6 + 5) - 1 = 10 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1912.设计电影租借系统",
        "hardRate": "HARD",
        "passRate": "24.10%",
        "problemsUrl": "https://leetcode.cn/problems/design-movie-rental-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-movie-rental-system/solution",
        "problemsDesc": "<p>你有一个电影租借公司和 <code>n</code> 个电影商店。你想要实现一个电影租借系统，它支持查询、预订和返还电影的操作。同时系统还能生成一份当前被借出电影的报告。</p>\n\n<p>所有电影用二维整数数组 <code>entries</code> 表示，其中 <code>entries[i] = [shop<sub>i</sub>, movie<sub>i</sub>, price<sub>i</sub>]</code> 表示商店 <code>shop<sub>i</sub></code> 有一份电影 <code>movie<sub>i</sub></code> 的拷贝，租借价格为 <code>price<sub>i</sub></code> 。每个商店有 <strong>至多一份</strong> 编号为 <code>movie<sub>i</sub></code> 的电影拷贝。</p>\n\n<p>系统需要支持以下操作：</p>\n\n<ul>\n\t<li><strong>Search：</strong>找到拥有指定电影且 <strong>未借出</strong> 的商店中 <strong>最便宜的 5 个</strong> 。商店需要按照 <strong>价格</strong> 升序排序，如果价格相同，则 <code>shop<sub>i</sub></code> <strong>较小</strong> 的商店排在前面。如果查询结果少于 5 个商店，则将它们全部返回。如果查询结果没有任何商店，则返回空列表。</li>\n\t<li><strong>Rent：</strong>从指定商店借出指定电影，题目保证指定电影在指定商店 <strong>未借出</strong> 。</li>\n\t<li><strong>Drop：</strong>在指定商店返还 <strong>之前已借出</strong> 的指定电影。</li>\n\t<li><strong>Report：</strong>返回 <strong>最便宜的 5 部已借出电影</strong> （可能有重复的电影 ID），将结果用二维列表 <code>res</code> 返回，其中 <code>res[j] = [shop<sub>j</sub>, movie<sub>j</sub>]</code> 表示第 <code>j</code> 便宜的已借出电影是从商店 <code>shop<sub>j</sub></code> 借出的电影 <code>movie<sub>j</sub></code> 。<code>res</code> 中的电影需要按 <strong>价格</strong> 升序排序；如果价格相同，则<strong> </strong><code>shop<sub>j</sub></code> <strong>较小</strong> 的排在前面；如果仍然相同，则 <code>movie<sub>j</sub></code> <strong>较小 </strong>的排在前面。如果当前借出的电影小于 5 部，则将它们全部返回。如果当前没有借出电影，则返回一个空的列表。</li>\n</ul>\n\n<p>请你实现 <code>MovieRentingSystem</code> 类：</p>\n\n<ul>\n\t<li><code>MovieRentingSystem(int n, int[][] entries)</code> 将 <code>MovieRentingSystem</code> 对象用 <code>n</code> 个商店和 <code>entries</code> 表示的电影列表初始化。</li>\n\t<li><code>List&lt;Integer&gt; search(int movie)</code> 如上所述，返回 <strong>未借出</strong> 指定 <code>movie</code> 的商店列表。</li>\n\t<li><code>void rent(int shop, int movie)</code> 从指定商店 <code>shop</code> 借出指定电影 <code>movie</code> 。</li>\n\t<li><code>void drop(int shop, int movie)</code> 在指定商店 <code>shop</code> 返还之前借出的电影 <code>movie</code> 。</li>\n\t<li><code>List&lt;List&lt;Integer&gt;&gt; report()</code> 如上所述，返回最便宜的 <strong>已借出</strong> 电影列表。</li>\n</ul>\n\n<p><strong>注意：</strong>测试数据保证 <code>rent</code> 操作中指定商店拥有 <strong>未借出 </strong>的指定电影，且 <code>drop</code> 操作指定的商店 <strong>之前已借出</strong> 指定电影。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"MovieRentingSystem\", \"search\", \"rent\", \"rent\", \"report\", \"drop\", \"search\"]\n[[3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]], [1], [0, 1], [1, 2], [], [1, 2], [2]]\n<strong>输出：</strong>\n[null, [1, 0, 2], null, null, [[0, 1], [1, 2]], null, [0, 1]]\n\n<strong>解释：</strong>\nMovieRentingSystem movieRentingSystem = new MovieRentingSystem(3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]);\nmovieRentingSystem.search(1);  // 返回 [1, 0, 2] ，商店 1，0 和 2 有未借出的 ID 为 1 的电影。商店 1 最便宜，商店 0 和 2 价格相同，所以按商店编号排序。\nmovieRentingSystem.rent(0, 1); // 从商店 0 借出电影 1 。现在商店 0 未借出电影编号为 [2,3] 。\nmovieRentingSystem.rent(1, 2); // 从商店 1 借出电影 2 。现在商店 1 未借出的电影编号为 [1] 。\nmovieRentingSystem.report();   // 返回 [[0, 1], [1, 2]] 。商店 0 借出的电影 1 最便宜，然后是商店 1 借出的电影 2 。\nmovieRentingSystem.drop(1, 2); // 在商店 1 返还电影 2 。现在商店 1 未借出的电影编号为 [1,2] 。\nmovieRentingSystem.search(2);  // 返回 [0, 1] 。商店 0 和 1 有未借出的 ID 为 2 的电影。商店 0 最便宜，然后是商店 1 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 3 * 10<sup>5</sup></code></li>\n\t<li><code>1 <= entries.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= shop<sub>i</sub> < n</code></li>\n\t<li><code>1 <= movie<sub>i</sub>, price<sub>i</sub> <= 10<sup>4</sup></code></li>\n\t<li>每个商店 <strong>至多</strong> 有一份电影 <code>movie<sub>i</sub></code> 的拷贝。</li>\n\t<li><code>search</code>，<code>rent</code>，<code>drop</code> 和 <code>report</code> 的调用 <strong>总共</strong> 不超过 <code>10<sup>5</sup></code> 次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1913.两个数对之间的最大乘积差",
        "hardRate": "EASY",
        "passRate": "81.43%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-product-difference-between-two-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-product-difference-between-two-pairs/solution",
        "problemsDesc": "<p>两个数对 <code>(a, b)</code> 和 <code>(c, d)</code> 之间的 <strong>乘积差</strong> 定义为 <code>(a * b) - (c * d)</code> 。</p>\n\n<ul>\n\t<li>例如，<code>(5, 6)</code> 和 <code>(2, 7)</code> 之间的乘积差是 <code>(5 * 6) - (2 * 7) = 16</code> 。</li>\n</ul>\n\n<p>给你一个整数数组 <code>nums</code> ，选出四个 <strong>不同的</strong> 下标 <code>w</code>、<code>x</code>、<code>y</code> 和 <code>z</code> ，使数对 <code>(nums[w], nums[x])</code> 和 <code>(nums[y], nums[z])</code> 之间的 <strong>乘积差</strong> 取到 <strong>最大值</strong> 。</p>\n\n<p>返回以这种方式取得的乘积差中的 <strong>最大值</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,6,2,7,4]\n<strong>输出：</strong>34\n<strong>解释：</strong>可以选出下标为 1 和 3 的元素构成第一个数对 (6, 7) 以及下标 2 和 4 构成第二个数对 (2, 4)\n乘积差是 (6 * 7) - (2 * 4) = 34\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,2,5,9,7,4,8]\n<strong>输出：</strong>64\n<strong>解释：</strong>可以选出下标为 3 和 6 的元素构成第一个数对 (9, 8) 以及下标 1 和 5 构成第二个数对 (2, 4)\n乘积差是 (9 * 8) - (2 * 4) = 64\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>4 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1914.循环轮转矩阵",
        "hardRate": "MEDIUM",
        "passRate": "46.55%",
        "problemsUrl": "https://leetcode.cn/problems/cyclically-rotating-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/cyclically-rotating-a-grid/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的整数矩阵 <code>grid</code>​​​ ，其中 <code>m</code> 和 <code>n</code> 都是 <strong>偶数</strong> ；另给你一个整数 <code>k</code> 。</p>\n\n<p>矩阵由若干层组成，如下图所示，每种颜色代表一层：</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/10/ringofgrid.png\" style=\"width: 231px; height: 258px;\"></p>\n\n<p>矩阵的循环轮转是通过分别循环轮转矩阵中的每一层完成的。在对某一层进行一次循环旋转操作时，层中的每一个元素将会取代其 <strong>逆时针 </strong>方向的相邻元素。轮转示例如下：</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/22/explanation_grid.jpg\" style=\"width: 500px; height: 268px;\">\n<p>返回执行 <code>k</code> 次循环轮转操作后的矩阵。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/19/rod2.png\" style=\"width: 421px; height: 191px;\">\n<pre><strong>输入：</strong>grid = [[40,10],[30,20]], k = 1\n<strong>输出：</strong>[[10,20],[40,30]]\n<strong>解释：</strong>上图展示了矩阵在执行循环轮转操作时每一步的状态。</pre>\n\n<p><strong>示例 2：</strong></p>\n<strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/10/ringofgrid5.png\" style=\"width: 231px; height: 262px;\"></strong> <strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/10/ringofgrid6.png\" style=\"width: 231px; height: 262px;\"></strong> <strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/10/ringofgrid7.png\" style=\"width: 231px; height: 262px;\"></strong>\n\n<pre><strong>输入：</strong>grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2\n<strong>输出：</strong>[[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]]\n<strong>解释：</strong>上图展示了矩阵在执行循环轮转操作时每一步的状态。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>m</code> 和 <code>n</code> 都是 <strong>偶数</strong></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;=<sup> </sup>5000</code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1915.最美子字符串的数目",
        "hardRate": "MEDIUM",
        "passRate": "44.66%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-wonderful-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-wonderful-substrings/solution",
        "problemsDesc": "<p>如果某个字符串中 <strong>至多一个</strong> 字母出现 <strong>奇数</strong> 次，则称其为 <strong>最美</strong> 字符串。</p>\n\n<ul>\n\t<li>例如，<code>\"ccjjc\"</code> 和 <code>\"abab\"</code> 都是最美字符串，但 <code>\"ab\"</code> 不是。</li>\n</ul>\n\n<p>给你一个字符串 <code>word</code> ，该字符串由前十个小写英文字母组成（<code>'a'</code> 到 <code>'j'</code>）。请你返回 <code>word</code> 中 <strong>最美非空子字符串</strong> 的数目<em>。</em>如果同样的子字符串在<em> </em><code>word</code> 中出现多次，那么应当对 <strong>每次出现</strong> 分别计数<em>。</em></p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"aba\"\n<strong>输出：</strong>4\n<strong>解释：</strong>4 个最美子字符串如下所示：\n- \"<strong>a</strong>ba\" -> \"a\"\n- \"a<strong>b</strong>a\" -> \"b\"\n- \"ab<strong>a</strong>\" -> \"a\"\n- \"<strong>aba</strong>\" -> \"aba\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"aabb\"\n<strong>输出：</strong>9\n<strong>解释：</strong>9 个最美子字符串如下所示：\n- \"<strong>a</strong>abb\" -> \"a\"\n- \"<strong>aa</strong>bb\" -> \"aa\"\n- \"<strong>aab</strong>b\" -> \"aab\"\n- \"<strong>aabb</strong>\" -> \"aabb\"\n- \"a<strong>a</strong>bb\" -> \"a\"\n- \"a<strong>abb</strong>\" -> \"abb\"\n- \"aa<strong>b</strong>b\" -> \"b\"\n- \"aa<strong>bb</strong>\" -> \"bb\"\n- \"aab<strong>b</strong>\" -> \"b\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"he\"\n<strong>输出：</strong>2\n<strong>解释：</strong>2 个最美子字符串如下所示：\n- \"<b>h</b>e\" -> \"h\"\n- \"h<strong>e</strong>\" -> \"e\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word.length <= 10<sup>5</sup></code></li>\n\t<li><code>word</code> 由从 <code>'a'</code> 到 <code>'j'</code> 的小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1916.统计为蚁群构筑房间的不同顺序",
        "hardRate": "HARD",
        "passRate": "55.56%",
        "problemsUrl": "https://leetcode.cn/problems/count-ways-to-build-rooms-in-an-ant-colony/",
        "solutionsUrl": "https://leetcode.cn/problems/count-ways-to-build-rooms-in-an-ant-colony/solution",
        "problemsDesc": "<p>你是一只蚂蚁，负责为蚁群构筑 <code>n</code> 间编号从 <code>0</code> 到 <code>n-1</code> 的新房间。给你一个 <strong>下标从 0 开始</strong> 且长度为 <code>n</code> 的整数数组&nbsp;<code>prevRoom</code> 作为扩建计划。其中，<code>prevRoom[i]</code> 表示在构筑房间 <code>i</code> 之前，你必须先构筑房间 <code>prevRoom[i]</code> ，并且这两个房间必须 <strong>直接</strong> 相连。房间 <code>0</code> 已经构筑完成，所以 <code>prevRoom[0] = -1</code> 。扩建计划中还有一条硬性要求，在完成所有房间的构筑之后，从房间 <code>0</code> 可以访问到每个房间。</p>\n\n<p>你一次只能构筑 <strong>一个</strong> 房间。你可以在 <strong>已经构筑好的</strong> 房间之间自由穿行，只要这些房间是 <strong>相连的</strong> 。如果房间&nbsp;<code>prevRoom[i]</code> 已经构筑完成，那么你就可以构筑房间 <code>i</code>。</p>\n\n<p>返回你构筑所有房间的 <strong>不同顺序的数目</strong> 。由于答案可能很大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/19/d1.JPG\" style=\"width: 200px; height: 212px;\" />\n<pre>\n<strong>输入：</strong><code>prevRoom</code> = [-1,0,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>仅有一种方案可以完成所有房间的构筑：0 → 1 → 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/19/d2.JPG\" style=\"width: 200px; height: 239px;\" /></strong>\n\n<pre>\n<strong>输入：</strong><code>prevRoom</code> = [-1,0,0,1,2]\n<strong>输出：</strong>6\n<strong>解释：\n</strong>有 6 种不同顺序：\n0 → 1 → 3 → 2 → 4\n0 → 2 → 4 → 1 → 3\n0 → 1 → 2 → 3 → 4\n0 → 1 → 2 → 4 → 3\n0 → 2 → 1 → 3 → 4\n0 → 2 → 1 → 4 → 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == prevRoom.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>prevRoom[0] == -1</code></li>\n\t<li>对于所有的&nbsp;<code>1 &lt;= i &lt; n</code>&nbsp;，都有&nbsp;<code>0 &lt;= prevRoom[i] &lt; n</code></li>\n\t<li>题目保证所有房间都构筑完成后，从房间 <code>0</code> 可以访问到每个房间</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1917.Leetcodify 好友推荐",
        "hardRate": "HARD",
        "passRate": "31.57%",
        "problemsUrl": "https://leetcode.cn/problems/leetcodify-friends-recommendations/",
        "solutionsUrl": "https://leetcode.cn/problems/leetcodify-friends-recommendations/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1918.第 K 小的子数组和·",
        "hardRate": "MEDIUM",
        "passRate": "48.04%",
        "problemsUrl": "https://leetcode.cn/problems/kth-smallest-subarray-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-smallest-subarray-sum/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1919.兴趣相同的朋友",
        "hardRate": "HARD",
        "passRate": "43.33%",
        "problemsUrl": "https://leetcode.cn/problems/leetcodify-similar-friends/",
        "solutionsUrl": "https://leetcode.cn/problems/leetcodify-similar-friends/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1920.基于排列构建数组",
        "hardRate": "EASY",
        "passRate": "86.62%",
        "problemsUrl": "https://leetcode.cn/problems/build-array-from-permutation/",
        "solutionsUrl": "https://leetcode.cn/problems/build-array-from-permutation/solution",
        "problemsDesc": "<p>给你一个 <strong>从 0 开始的排列</strong> <code>nums</code>（<strong>下标也从 0 开始</strong>）。请你构建一个 <strong>同样长度</strong> 的数组 <code>ans</code> ，其中，对于每个 <code>i</code>（<code>0 &lt;= i &lt; nums.length</code>），都满足 <code>ans[i] = nums[nums[i]]</code> 。返回构建好的数组 <code>ans</code> 。</p>\n\n<p><strong>从 0 开始的排列</strong> <code>nums</code> 是一个由 <code>0</code> 到 <code>nums.length - 1</code>（<code>0</code> 和 <code>nums.length - 1</code> 也包含在内）的不同整数组成的数组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,2,1,5,3,4]\n<strong>输出：</strong>[0,1,2,4,5,3]<strong>\n解释：</strong>数组 ans 构建如下：\nans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n    = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]]\n    = [0,1,2,4,5,3]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,0,1,2,3,4]\n<strong>输出：</strong>[4,5,0,1,2,3]\n<strong>解释：</strong>数组 ans 构建如下：\nans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n    = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]]\n    = [4,5,0,1,2,3]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt; nums.length</code></li>\n\t<li><code>nums</code> 中的元素 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1921.消灭怪物的最大数量",
        "hardRate": "MEDIUM",
        "passRate": "36.99%",
        "problemsUrl": "https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/",
        "solutionsUrl": "https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/solution",
        "problemsDesc": "<p>你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。给你一个 <strong>下标从 0 开始</strong> 且长度为 <code>n</code> 的整数数组 <code>dist</code> ，其中 <code>dist[i]</code> 是第 <code>i</code> 个怪物与城市的 <strong>初始距离</strong>（单位：米）。</p>\n\n<p>怪物以 <strong>恒定</strong> 的速度走向城市。给你一个长度为 <code>n</code> 的整数数组 <code>speed</code> 表示每个怪物的速度，其中 <code>speed[i]</code> 是第 <code>i</code> 个怪物的速度（单位：米/分）。</p>\n\n<p>怪物从 <strong>第 0 分钟</strong> 时开始移动。你有一把武器，并可以 <strong>选择</strong> 在每一分钟的开始时使用，包括第 0 分钟。但是你无法在一分钟的中间使用武器。这种武器威力惊人，一次可以消灭任一还活着的怪物。</p>\n\n<p>一旦任一怪物到达城市，你就输掉了这场游戏。如果某个怪物 <strong>恰</strong> 在某一分钟开始时到达城市，这会被视为<strong> 输掉</strong> 游戏，在你可以使用武器之前，游戏就会结束。</p>\n\n<p>返回在你输掉游戏前可以消灭的怪物的 <strong>最大</strong> 数量。如果你可以在所有怪物到达城市前将它们全部消灭，返回  <code>n</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [1,3,4], speed = [1,1,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n第 0 分钟开始时，怪物的距离是 [1,3,4]，你消灭了第一个怪物。\n第 1 分钟开始时，怪物的距离是 [X,2,3]，你没有消灭任何怪物。\n第 2 分钟开始时，怪物的距离是 [X,1,2]，你消灭了第二个怪物。\n第 3 分钟开始时，怪物的距离是 [X,X,1]，你消灭了第三个怪物。\n所有 3 个怪物都可以被消灭。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [1,1,2,3], speed = [1,1,1,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n第 0 分钟开始时，怪物的距离是 [1,1,2,3]，你消灭了第一个怪物。\n第 1 分钟开始时，怪物的距离是 [X,0,1,2]，你输掉了游戏。\n你只能消灭 1 个怪物。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>dist = [3,2,4], speed = [5,3,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n第 0 分钟开始时，怪物的距离是 [3,2,4]，你消灭了第一个怪物。\n第 1 分钟开始时，怪物的距离是 [X,0,2]，你输掉了游戏。 \n你只能消灭 1 个怪物。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == dist.length == speed.length</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= dist[i], speed[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1922.统计好数字的数目",
        "hardRate": "MEDIUM",
        "passRate": "36.20%",
        "problemsUrl": "https://leetcode.cn/problems/count-good-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/count-good-numbers/solution",
        "problemsDesc": "<p>我们称一个数字字符串是 <strong>好数字</strong> 当它满足（下标从 <strong>0</strong> 开始）<strong>偶数</strong> 下标处的数字为 <strong>偶数</strong> 且 <strong>奇数</strong> 下标处的数字为 <strong>质数</strong> （<code>2</code>，<code>3</code>，<code>5</code> 或 <code>7</code>）。</p>\n\n<ul>\n\t<li>比方说，<code>\"2582\"</code> 是好数字，因为偶数下标处的数字（<code>2</code> 和 <code>8</code>）是偶数且奇数下标处的数字（<code>5</code> 和 <code>2</code>）为质数。但 <code>\"3245\"</code> <strong>不是</strong> 好数字，因为 <code>3</code> 在偶数下标处但不是偶数。</li>\n</ul>\n\n<p>给你一个整数 <code>n</code> ，请你返回长度为 <code>n</code> 且为好数字的数字字符串 <strong>总数</strong> 。由于答案可能会很大，请你将它对<strong> </strong><code>10<sup>9</sup> + 7</code> <strong>取余后返回</strong> 。</p>\n\n<p>一个 <strong>数字字符串</strong> 是每一位都由 <code>0</code> 到 <code>9</code> 组成的字符串，且可能包含前导 0 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 1\n<b>输出：</b>5\n<b>解释：</b>长度为 1 的好数字包括 \"0\"，\"2\"，\"4\"，\"6\"，\"8\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 4\n<b>输出：</b>400\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 50\n<b>输出：</b>564908303\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 10<sup>15</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1923.最长公共子路径",
        "hardRate": "HARD",
        "passRate": "26.85%",
        "problemsUrl": "https://leetcode.cn/problems/longest-common-subpath/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-common-subpath/solution",
        "problemsDesc": "<p>一个国家由 <code>n</code> 个编号为 <code>0</code> 到 <code>n - 1</code> 的城市组成。在这个国家里，<strong>每两个</strong> 城市之间都有一条道路连接。</p>\n\n<p>总共有 <code>m</code> 个编号为 <code>0</code> 到 <code>m - 1</code> 的朋友想在这个国家旅游。他们每一个人的路径都会包含一些城市。每条路径都由一个整数数组表示，每个整数数组表示一个朋友按顺序访问过的城市序列。同一个城市在一条路径中可能 <strong>重复</strong> 出现，但同一个城市在一条路径中不会连续出现。</p>\n\n<p>给你一个整数 <code>n</code> 和二维数组 <code>paths</code> ，其中 <code>paths[i]</code> 是一个整数数组，表示第 <code>i</code> 个朋友走过的路径，请你返回 <strong>每一个</strong> 朋友都走过的 <strong>最长公共子路径</strong> 的长度，如果不存在公共子路径，请你返回 <code>0</code> 。</p>\n\n<p>一个 <strong>子路径</strong> 指的是一条路径中连续的城市序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5, paths = [[0,1,<strong>2,3</strong>,4],\n                     [<strong>2,3</strong>,4],\n                     [4,0,1,<strong>2,3</strong>]]\n<b>输出：</b>2\n<b>解释：</b>最长公共子路径为 [2,3] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 3, paths = [[0],[1],[2]]\n<b>输出：</b>0\n<b>解释：</b>三条路径没有公共子路径。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5, paths = [[<strong>0</strong>,1,2,3,4],\n                     [4,3,2,1,<strong>0</strong>]]\n<b>输出：</b>1\n<b>解释：</b>最长公共子路径为 [0]，[1]，[2]，[3] 和 [4] 。它们长度都为 1 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>m == paths.length</code></li>\n\t<li><code>2 <= m <= 10<sup>5</sup></code></li>\n\t<li><code>sum(paths[i].length) <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= paths[i][j] < n</code></li>\n\t<li><code>paths[i]</code> 中同一个城市不会连续重复出现。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1924.安装栅栏 II",
        "hardRate": "HARD",
        "passRate": "46.40%",
        "problemsUrl": "https://leetcode.cn/problems/erect-the-fence-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/erect-the-fence-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1925.统计平方和三元组的数目",
        "hardRate": "EASY",
        "passRate": "69.54%",
        "problemsUrl": "https://leetcode.cn/problems/count-square-sum-triples/",
        "solutionsUrl": "https://leetcode.cn/problems/count-square-sum-triples/solution",
        "problemsDesc": "<p>一个 <strong>平方和三元组</strong> <code>(a,b,c)</code> 指的是满足 <code>a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup></code> 的 <strong>整数 </strong>三元组 <code>a</code>，<code>b</code> 和 <code>c</code> 。</p>\n\n<p>给你一个整数 <code>n</code> ，请你返回满足<em> </em><code>1 &lt;= a, b, c &lt;= n</code> 的 <strong>平方和三元组</strong> 的数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 5\n<b>输出：</b>2\n<b>解释：</b>平方和三元组为 (3,4,5) 和 (4,3,5) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 10\n<b>输出：</b>4\n<b>解释：</b>平方和三元组为 (3,4,5)，(4,3,5)，(6,8,10) 和 (8,6,10) 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 250</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1926.迷宫中离入口最近的出口",
        "hardRate": "MEDIUM",
        "passRate": "39.51%",
        "problemsUrl": "https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/",
        "solutionsUrl": "https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的迷宫矩阵 <code>maze</code> （<strong>下标从 0 开始</strong>），矩阵中有空格子（用 <code>'.'</code> 表示）和墙（用 <code>'+'</code> 表示）。同时给你迷宫的入口 <code>entrance</code> ，用 <code>entrance = [entrance<sub>row</sub>, entrance<sub>col</sub>]</code> 表示你一开始所在格子的行和列。</p>\n\n<p>每一步操作，你可以往 <strong>上</strong>，<strong>下</strong>，<strong>左</strong> 或者 <strong>右</strong> 移动一个格子。你不能进入墙所在的格子，你也不能离开迷宫。你的目标是找到离 <code>entrance</code> <strong>最近</strong> 的出口。<strong>出口</strong> 的含义是 <code>maze</code> <strong>边界</strong> 上的 <strong>空格子</strong>。<code>entrance</code> 格子 <strong>不算</strong> 出口。</p>\n\n<p>请你返回从 <code>entrance</code> 到最近出口的最短路径的 <strong>步数</strong> ，如果不存在这样的路径，请你返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/nearest1-grid.jpg\" style=\"width: 333px; height: 253px;\">\n<pre><b>输入：</b>maze = [[\"+\",\"+\",\".\",\"+\"],[\".\",\".\",\".\",\"+\"],[\"+\",\"+\",\"+\",\".\"]], entrance = [1,2]\n<b>输出：</b>1\n<b>解释：</b>总共有 3 个出口，分别位于 (1,0)，(0,2) 和 (2,3) 。\n一开始，你在入口格子 (1,2) 处。\n- 你可以往左移动 2 步到达 (1,0) 。\n- 你可以往上移动 1 步到达 (0,2) 。\n从入口处没法到达 (2,3) 。\n所以，最近的出口是 (0,2) ，距离为 1 步。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/nearesr2-grid.jpg\" style=\"width: 253px; height: 253px;\">\n<pre><b>输入：</b>maze = [[\"+\",\"+\",\"+\"],[\".\",\".\",\".\"],[\"+\",\"+\",\"+\"]], entrance = [1,0]\n<b>输出：</b>2\n<b>解释：</b>迷宫中只有 1 个出口，在 (1,2) 处。\n(1,0) 不算出口，因为它是入口格子。\n初始时，你在入口与格子 (1,0) 处。\n- 你可以往右移动 2 步到达 (1,2) 处。\n所以，最近的出口为 (1,2) ，距离为 2 步。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/nearest3-grid.jpg\" style=\"width: 173px; height: 93px;\">\n<pre><b>输入：</b>maze = [[\".\",\"+\"]], entrance = [0,0]\n<b>输出：</b>-1\n<b>解释：</b>这个迷宫中没有出口。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>maze.length == m</code></li>\n\t<li><code>maze[i].length == n</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>maze[i][j]</code> 要么是 <code>'.'</code> ，要么是 <code>'+'</code> 。</li>\n\t<li><code>entrance.length == 2</code></li>\n\t<li><code>0 &lt;= entrance<sub>row</sub> &lt; m</code></li>\n\t<li><code>0 &lt;= entrance<sub>col</sub> &lt; n</code></li>\n\t<li><code>entrance</code> 一定是空格子。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1927.求和游戏",
        "hardRate": "MEDIUM",
        "passRate": "43.52%",
        "problemsUrl": "https://leetcode.cn/problems/sum-game/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-game/solution",
        "problemsDesc": "<p>Alice 和 Bob 玩一个游戏，两人轮流行动，<strong>Alice 先手</strong> 。</p>\n\n<p>给你一个 <strong>偶数长度</strong> 的字符串 <code>num</code> ，每一个字符为数字字符或者 <code>'?'</code> 。每一次操作中，如果 <code>num</code> 中至少有一个 <code>'?'</code> ，那么玩家可以执行以下操作：</p>\n\n<ol>\n\t<li>选择一个下标 <code>i</code> 满足 <code>num[i] == '?'</code> 。</li>\n\t<li>将 <code>num[i]</code> 用 <code>'0'</code> 到 <code>'9'</code> 之间的一个数字字符替代。</li>\n</ol>\n\n<p>当 <code>num</code> 中没有<span style=\"\"> </span><code>'?'</code> 时，游戏结束。</p>\n\n<p>Bob 获胜的条件是 <code>num</code> 中前一半数字的和 <strong>等于</strong> 后一半数字的和。Alice 获胜的条件是前一半的和与后一半的和 <strong>不相等</strong> 。</p>\n\n<ul>\n\t<li>比方说，游戏结束时 <code>num = \"243801\"</code> ，那么 Bob 获胜，因为 <code>2+4+3 = 8+0+1</code> 。如果游戏结束时 <code>num = \"243803\"</code> ，那么 Alice 获胜，因为 <code>2+4+3 != 8+0+3</code> 。</li>\n</ul>\n\n<p>在 Alice 和 Bob 都采取 <strong>最优</strong> 策略的前提下，如果 Alice 获胜，请返回 <code>true</code> ，如果 Bob 获胜，请返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>num = \"5023\"\n<b>输出：</b>false\n<b>解释：</b>num 中没有 '?' ，没法进行任何操作。\n前一半的和等于后一半的和：5 + 0 = 2 + 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>num = \"25??\"\n<b>输出：</b>true\n<strong>解释：</strong>Alice 可以将两个 '?' 中的一个替换为 '9' ，Bob 无论如何都无法使前一半的和等于后一半的和。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>num = \"?3295???\"\n<b>输出：</b>false\n<b>解释：</b>Bob 总是能赢。一种可能的结果是：\n- Alice 将第一个 '?' 用 '9' 替换。num = \"93295???\" 。\n- Bob 将后面一半中的一个 '?' 替换为 '9' 。num = \"932959??\" 。\n- Alice 将后面一半中的一个 '?' 替换为 '2' 。num = \"9329592?\" 。\n- Bob 将后面一半中最后一个 '?' 替换为 '7' 。num = \"93295927\" 。\nBob 获胜，因为 9 + 3 + 2 + 9 = 5 + 9 + 2 + 7 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= num.length <= 10<sup>5</sup></code></li>\n\t<li><code>num.length</code> 是 <strong>偶数</strong> 。</li>\n\t<li><code>num</code> 只包含数字字符和 <code>'?'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1928.规定时间内到达终点的最小花费",
        "hardRate": "HARD",
        "passRate": "45.82%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/solution",
        "problemsDesc": "<p>一个国家有 <code>n</code> 个城市，城市编号为 <code>0</code> 到 <code>n - 1</code> ，题目保证 <strong>所有城市</strong> 都由双向道路 <b>连接在一起</b> 。道路由二维整数数组 <code>edges</code> 表示，其中 <code>edges[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>]</code> 表示城市 <code>x<sub>i</sub></code> 和 <code>y<sub>i</sub></code> 之间有一条双向道路，耗费时间为 <code>time<sub>i</sub></code> 分钟。两个城市之间可能会有多条耗费时间不同的道路，但是不会有道路两头连接着同一座城市。</p>\n\n<p>每次经过一个城市时，你需要付通行费。通行费用一个长度为 <code>n</code> 且下标从 <strong>0</strong> 开始的整数数组 <code>passingFees</code> 表示，其中 <code>passingFees[j]</code> 是你经过城市 <code>j</code> 需要支付的费用。</p>\n\n<p>一开始，你在城市 <code>0</code> ，你想要在 <code>maxTime</code> <strong>分钟以内</strong> （包含 <code>maxTime</code> 分钟）到达城市 <code>n - 1</code> 。旅行的 <strong>费用</strong> 为你经过的所有城市 <strong>通行费之和</strong> （<strong>包括</strong> 起点和终点城市的通行费）。</p>\n\n<p>给你 <code>maxTime</code>，<code>edges</code> 和 <code>passingFees</code> ，请你返回完成旅行的 <strong>最小费用</strong> ，如果无法在 <code>maxTime</code> 分钟以内完成旅行，请你返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/leetgraph1-1.png\" style=\"width: 371px; height: 171px;\" /></p>\n\n<pre>\n<b>输入：</b>maxTime = 30, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n<b>输出：</b>11\n<b>解释：</b>最优路径为 0 -> 1 -> 2 -> 5 ，总共需要耗费 30 分钟，需要支付 11 的通行费。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/04/copy-of-leetgraph1-1.png\" style=\"width: 371px; height: 171px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>maxTime = 29, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n<b>输出：</b>48\n<b>解释：</b>最优路径为 0 -> 3 -> 4 -> 5 ，总共需要耗费 26 分钟，需要支付 48 的通行费。\n你不能选择路径 0 -> 1 -> 2 -> 5 ，因为这条路径耗费的时间太长。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>maxTime = 25, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]\n<b>输出：</b>-1\n<b>解释：</b>无法在 25 分钟以内从城市 0 到达城市 5 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= maxTime <= 1000</code></li>\n\t<li><code>n == passingFees.length</code></li>\n\t<li><code>2 <= n <= 1000</code></li>\n\t<li><code>n - 1 <= edges.length <= 1000</code></li>\n\t<li><code>0 <= x<sub>i</sub>, y<sub>i</sub> <= n - 1</code></li>\n\t<li><code>1 <= time<sub>i</sub> <= 1000</code></li>\n\t<li><code>1 <= passingFees[j] <= 1000</code> </li>\n\t<li>图中两个节点之间可能有多条路径。</li>\n\t<li>图中不含有自环。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1929.数组串联",
        "hardRate": "EASY",
        "passRate": "86.14%",
        "problemsUrl": "https://leetcode.cn/problems/concatenation-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/concatenation-of-array/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 。请你构建一个长度为 <code>2n</code> 的答案数组 <code>ans</code> ，数组下标<strong> 从 0 开始计数 </strong>，对于所有 <code>0 <= i < n</code> 的 <code>i</code> ，满足下述所有要求：</p>\n\n<ul>\n\t<li><code>ans[i] == nums[i]</code></li>\n\t<li><code>ans[i + n] == nums[i]</code></li>\n</ul>\n\n<p>具体而言，<code>ans</code> 由两个 <code>nums</code> 数组 <strong>串联</strong> 形成。</p>\n\n<p>返回数组<em> </em><code>ans</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1]\n<strong>输出：</strong>[1,2,1,1,2,1]\n<strong>解释：</strong>数组 ans 按下述方式形成：\n- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]\n- ans = [1,2,1,1,2,1]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,2,1]\n<strong>输出：</strong>[1,3,2,1,1,3,2,1]\n<strong>解释：</strong>数组 ans 按下述方式形成：\n- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]\n- ans = [1,3,2,1,1,3,2,1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 <= n <= 1000</code></li>\n\t<li><code>1 <= nums[i] <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1930.长度为 3 的不同回文子序列",
        "hardRate": "MEDIUM",
        "passRate": "51.63%",
        "problemsUrl": "https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，返回 <code>s</code> 中 <strong>长度为 3 </strong>的<strong>不同回文子序列</strong> 的个数。</p>\n\n<p>即便存在多种方法来构建相同的子序列，但相同的子序列只计数一次。</p>\n\n<p><strong>回文</strong> 是正着读和反着读一样的字符串。</p>\n\n<p><strong>子序列</strong> 是由原字符串删除其中部分字符（也可以不删除）且不改变剩余字符之间相对顺序形成的一个新字符串。</p>\n\n<ul>\n\t<li>例如，<code>\"ace\"</code> 是 <code>\"<strong><em>a</em></strong>b<strong><em>c</em></strong>d<strong><em>e</em></strong>\"</code> 的一个子序列。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aabca\"\n<strong>输出：</strong>3\n<strong>解释：</strong>长度为 3 的 3 个回文子序列分别是：\n- \"aba\" (\"<strong><em>a</em></strong>a<strong><em>b</em></strong>c<strong><em>a</em></strong>\" 的子序列)\n- \"aaa\" (\"<strong><em>aa</em></strong>bc<strong><em>a</em></strong>\" 的子序列)\n- \"aca\" (\"<strong><em>a</em></strong>ab<strong><em>ca</em></strong>\" 的子序列)\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"adc\"\n<strong>输出：</strong>0\n<strong>解释：</strong>\"adc\" 不存在长度为 3 的回文子序列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"bbcbaba\"\n<strong>输出：</strong>4\n<strong>解释：</strong>长度为 3 的 4 个回文子序列分别是：\n- \"bbb\" (\"<strong><em>bb</em></strong>c<strong><em>b</em></strong>aba\" 的子序列)\n- \"bcb\" (\"<strong><em>b</em></strong>b<strong><em>cb</em></strong>aba\" 的子序列)\n- \"bab\" (\"<strong><em>b</em></strong>bcb<strong><em>ab</em></strong>a\" 的子序列)\n- \"aba\" (\"bbcb<strong><em>aba</em></strong>\" 的子序列)\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 <= s.length <= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1931.用三种不同颜色为网格涂色",
        "hardRate": "HARD",
        "passRate": "59.34%",
        "problemsUrl": "https://leetcode.cn/problems/painting-a-grid-with-three-different-colors/",
        "solutionsUrl": "https://leetcode.cn/problems/painting-a-grid-with-three-different-colors/solution",
        "problemsDesc": "<p>给你两个整数 <code>m</code> 和 <code>n</code> 。构造一个 <code>m x n</code> 的网格，其中每个单元格最开始是白色。请你用 <strong>红、绿、蓝</strong> 三种颜色为每个单元格涂色。所有单元格都需要被涂色。</p>\n\n<p>涂色方案需要满足：<strong>不存在相邻两个单元格颜色相同的情况</strong> 。返回网格涂色的方法数。因为答案可能非常大， 返回 <strong>对 </strong><code>10<sup>9</sup> + 7</code><strong> 取余</strong> 的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/22/colorthegrid.png\" style=\"width: 200px; height: 50px;\" />\n<pre>\n<strong>输入：</strong>m = 1, n = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>如上图所示，存在三种可能的涂色方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/22/copy-of-colorthegrid.png\" style=\"width: 321px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>m = 1, n = 2\n<strong>输出：</strong>6\n<strong>解释：</strong>如上图所示，存在六种可能的涂色方案。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 5, n = 5\n<strong>输出：</strong>580986\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= m <= 5</code></li>\n\t<li><code>1 <= n <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1932.合并多棵二叉搜索树",
        "hardRate": "HARD",
        "passRate": "33.29%",
        "problemsUrl": "https://leetcode.cn/problems/merge-bsts-to-create-single-bst/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-bsts-to-create-single-bst/solution",
        "problemsDesc": "<p>给你 <code>n</code> 个 <strong>二叉搜索树的根节点</strong> ，存储在数组 <code>trees</code> 中（<strong>下标从 0 开始</strong>），对应 <code>n</code> 棵不同的二叉搜索树。<code>trees</code> 中的每棵二叉搜索树 <strong>最多有 3 个节点</strong> ，且不存在值相同的两个根节点。在一步操作中，将会完成下述步骤：</p>\n\n<ul>\n\t<li>选择两个 <strong>不同的</strong> 下标 <code>i</code> 和 <code>j</code> ，要求满足在&nbsp;<code>trees[i]</code> 中的某个 <strong>叶节点</strong> 的值等于&nbsp;<code>trees[j]</code> 的 <strong>根节点的值</strong> 。</li>\n\t<li>用&nbsp;<code>trees[j]</code> 替换 <code>trees[i]</code> 中的那个叶节点。</li>\n\t<li>从 <code>trees</code> 中移除 <code>trees[j]</code> 。</li>\n</ul>\n\n<p>如果在执行 <code>n - 1</code> 次操作后，能形成一棵有效的二叉搜索树，则返回结果二叉树的 <strong>根节点</strong> ；如果无法构造一棵有效的二叉搜索树<em>，</em>返回<em> </em><code>null</code> 。</p>\n\n<p>二叉搜索树是一种二叉树，且树中每个节点均满足下述属性：</p>\n\n<ul>\n\t<li>任意节点的左子树中的值都 <strong>严格小于</strong>&nbsp;此节点的值。</li>\n\t<li>任意节点的右子树中的值都 <strong>严格大于</strong>&nbsp;此节点的值。</li>\n</ul>\n\n<p>叶节点是不含子节点的节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/08/d1.png\" />\n<pre>\n<strong>输入：</strong>trees = [[2,1],[3,2,5],[5,4]]\n<strong>输出：</strong>[3,2,5,1,null,4]\n<strong>解释：</strong>\n第一步操作中，选出 i=1 和 j=0 ，并将 trees[0] 合并到 trees[1] 中。\n删除 trees[0] ，trees = [[3,2,5,1],[5,4]] 。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/24/diagram.png\" />\n在第二步操作中，选出 i=0 和 j=1 ，将 trees[1] 合并到 trees[0] 中。\n删除 trees[1] ，trees = [[3,2,5,1,null,4]] 。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/24/diagram-2.png\" />\n结果树如上图所示，为一棵有效的二叉搜索树，所以返回该树的根节点。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/08/d2.png\" />\n<pre>\n<strong>输入：</strong>trees = [[5,3,8],[3,2,6]]\n<strong>输出：</strong>[]\n<strong>解释：</strong>\n选出 i=0 和 j=1 ，然后将 trees[1] 合并到 trees[0] 中。\n删除 trees[1] ，trees = [[5,3,8,2,6]] 。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/24/diagram-3.png\" />\n结果树如上图所示。仅能执行一次有效的操作，但结果树不是一棵有效的二叉搜索树，所以返回 null 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/08/d3.png\" />\n<pre>\n<strong>输入：</strong>trees = [[5,4],[3]]\n<strong>输出：</strong>[]\n<strong>解释：</strong>无法执行任何操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == trees.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li>每棵树中节点数目在范围 <code>[1, 3]</code> 内。</li>\n\t<li>输入数据的每个节点可能有子节点但不存在子节点的子节点</li>\n\t<li><code>trees</code> 中不存在两棵树根节点值相同的情况。</li>\n\t<li>输入中的所有树都是 <strong>有效的二叉树搜索树</strong> 。</li>\n\t<li><code>1 &lt;= TreeNode.val &lt;= 5 * 10<sup>4</sup></code>.</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1933.判断字符串是否可分解为值均等的子串",
        "hardRate": "EASY",
        "passRate": "49.31%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-string-is-decomposable-into-value-equal-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-string-is-decomposable-into-value-equal-substrings/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1934.确认率",
        "hardRate": "MEDIUM",
        "passRate": "67.30%",
        "problemsUrl": "https://leetcode.cn/problems/confirmation-rate/",
        "solutionsUrl": "https://leetcode.cn/problems/confirmation-rate/solution",
        "problemsDesc": "<p>表: <code>Signups</code></p>\n\n<pre>\n+----------------+----------+\n| Column Name    | Type     |\n+----------------+----------+\n| user_id        | int      |\n| time_stamp     | datetime |\n+----------------+----------+\nUser_id是该表的主键。\n每一行都包含ID为user_id的用户的注册时间信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>表: <code>Confirmations</code></p>\n\n<pre>\n+----------------+----------+\n| Column Name    | Type     |\n+----------------+----------+\n| user_id        | int      |\n| time_stamp     | datetime |\n| action         | ENUM     |\n+----------------+----------+\n(user_id, time_stamp)是该表的主键。\nuser_id是一个引用到注册表的外键。\naction是类型为('confirmed'， 'timeout')的ENUM\n该表的每一行都表示ID为user_id的用户在time_stamp请求了一条确认消息，该确认消息要么被确认('confirmed')，要么被过期('timeout')。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>用户的 <strong>确认率</strong>&nbsp;是 <code>'confirmed'</code>&nbsp;消息的数量除以请求的确认消息的总数。没有请求任何确认消息的用户的确认率为&nbsp;<code>0</code> 。确认率四舍五入到 <strong>小数点后两位</strong> 。</p>\n\n<p>编写一个SQL查询来查找每个用户的 确认率 。<br />\n<br />\n以 任意顺序&nbsp;返回结果表。<br />\n<br />\n查询结果格式如下所示。<br />\n<br />\n<strong>示例1:</strong></p>\n\n<pre>\n<b>输入：</b>\nSignups 表:\n+---------+---------------------+\n| user_id | time_stamp          |\n+---------+---------------------+\n| 3       | 2020-03-21 10:16:13 |\n| 7       | 2020-01-04 13:57:59 |\n| 2       | 2020-07-29 23:09:44 |\n| 6       | 2020-12-09 10:39:37 |\n+---------+---------------------+\nConfirmations 表:\n+---------+---------------------+-----------+\n| user_id | time_stamp          | action    |\n+---------+---------------------+-----------+\n| 3       | 2021-01-06 03:30:46 | timeout   |\n| 3       | 2021-07-14 14:00:00 | timeout   |\n| 7       | 2021-06-12 11:57:29 | confirmed |\n| 7       | 2021-06-13 12:58:28 | confirmed |\n| 7       | 2021-06-14 13:59:27 | confirmed |\n| 2       | 2021-01-22 00:00:00 | confirmed |\n| 2       | 2021-02-28 23:59:59 | timeout   |\n+---------+---------------------+-----------+\n<strong>输出:</strong> \n+---------+-------------------+\n| user_id | confirmation_rate |\n+---------+-------------------+\n| 6       | 0.00              |\n| 3       | 0.00              |\n| 7       | 1.00              |\n| 2       | 0.50              |\n+---------+-------------------+\n<strong>解释:\n</strong>用户 6 没有请求任何确认消息。确认率为 0。\n用户 3 进行了 2 次请求，都超时了。确认率为 0。\n用户 7 提出了 3 个请求，所有请求都得到了确认。确认率为 1。\n用户 2 做了 2 个请求，其中一个被确认，另一个超时。确认率为 1 / 2 = 0.5。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1935.可以输入的最大单词数",
        "hardRate": "EASY",
        "passRate": "70.85%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-words-you-can-type/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-words-you-can-type/solution",
        "problemsDesc": "<p>键盘出现了一些故障，有些字母键无法正常工作。而键盘上所有其他键都能够正常工作。</p>\n\n<p>给你一个由若干单词组成的字符串 <code>text</code> ，单词间由单个空格组成（不含前导和尾随空格）；另有一个字符串 <code>brokenLetters</code> ，由所有已损坏的不同字母键组成，返回你可以使用此键盘完全输入的 <code>text</code> 中单词的数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>text = \"hello world\", brokenLetters = \"ad\"\n<strong>输出：</strong>1\n<strong>解释：</strong>无法输入 \"world\" ，因为字母键 'd' 已损坏。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>text = \"leet code\", brokenLetters = \"lt\"\n<strong>输出：</strong>1\n<strong>解释：</strong>无法输入 \"leet\" ，因为字母键 'l' 和 't' 已损坏。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>text = \"leet code\", brokenLetters = \"e\"\n<strong>输出：</strong>0\n<strong>解释：</strong>无法输入任何单词，因为字母键 'e' 已损坏。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= brokenLetters.length &lt;= 26</code></li>\n\t<li><code>text</code> 由若干用单个空格分隔的单词组成，且不含任何前导和尾随空格</li>\n\t<li>每个单词仅由小写英文字母组成</li>\n\t<li><code>brokenLetters</code> 由 <strong>互不相同</strong> 的小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1936.新增的最少台阶数",
        "hardRate": "MEDIUM",
        "passRate": "46.25%",
        "problemsUrl": "https://leetcode.cn/problems/add-minimum-number-of-rungs/",
        "solutionsUrl": "https://leetcode.cn/problems/add-minimum-number-of-rungs/solution",
        "problemsDesc": "<p>给你一个 <strong>严格递增</strong> 的整数数组 <code>rungs</code> ，用于表示梯子上每一台阶的 <strong>高度</strong> 。当前你正站在高度为 <code>0</code> 的地板上，并打算爬到最后一个台阶。</p>\n\n<p>另给你一个整数 <code>dist</code> 。每次移动中，你可以到达下一个距离你当前位置（地板或台阶）<strong>不超过</strong> <code>dist</code> 高度的台阶。当然，你也可以在任何正 <strong>整数</strong> 高度处插入尚不存在的新台阶。</p>\n\n<p>返回爬到最后一阶时必须添加到梯子上的 <strong>最少</strong> 台阶数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rungs = [1,3,5,10], dist = 2\n<strong>输出：</strong>2\n<strong>解释：\n</strong>现在无法到达最后一阶。\n在高度为 7 和 8 的位置增设新的台阶，以爬上梯子。 \n梯子在高度为 [1,3,5,<strong><em>7</em></strong>,<strong><em>8</em></strong>,10] 的位置上有台阶。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rungs = [3,6,8,10], dist = 3\n<strong>输出：</strong>0\n<strong>解释：</strong>\n这个梯子无需增设新台阶也可以爬上去。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>rungs = [3,4,6,7], dist = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>\n现在无法从地板到达梯子的第一阶。 \n在高度为 1 的位置增设新的台阶，以爬上梯子。 \n梯子在高度为 [<strong><em>1</em></strong>,3,4,6,7] 的位置上有台阶。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>rungs = [5], dist = 10\n<strong>输出：</strong>0\n<strong>解释：</strong>这个梯子无需增设新台阶也可以爬上去。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= rungs.length <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= rungs[i] <= 10<sup>9</sup></code></li>\n\t<li><code>1 <= dist <= 10<sup>9</sup></code></li>\n\t<li><code>rungs</code> <strong>严格递增</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1937.扣分后的最大得分",
        "hardRate": "MEDIUM",
        "passRate": "28.91%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-points-with-cost/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-points-with-cost/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的整数矩阵 <code>points</code> （下标从 <strong>0</strong> 开始）。一开始你的得分为 <code>0</code> ，你想最大化从矩阵中得到的分数。</p>\n\n<p>你的得分方式为：<strong>每一行</strong> 中选取一个格子，选中坐标为 <code>(r, c)</code> 的格子会给你的总得分 <strong>增加</strong> <code>points[r][c]</code> 。</p>\n\n<p>然而，相邻行之间被选中的格子如果隔得太远，你会失去一些得分。对于相邻行 <code>r</code> 和 <code>r + 1</code> （其中 <code>0 <= r < m - 1</code>），选中坐标为 <code>(r, c<sub>1</sub>)</code> 和 <code>(r + 1, c<sub>2</sub>)</code> 的格子，你的总得分 <b>减少</b> <code>abs(c<sub>1</sub> - c<sub>2</sub>)</code> 。</p>\n\n<p>请你返回你能得到的 <strong>最大</strong> 得分。</p>\n\n<p><code>abs(x)</code> 定义为：</p>\n\n<ul>\n\t<li>如果 <code>x >= 0</code> ，那么值为 <code>x</code> 。</li>\n\t<li>如果 <code>x < 0</code> ，那么值为 <code>-x</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-40-26-diagram-drawio-diagrams-net.png\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<b>输入：</b>points = [[1,2,3],[1,5,1],[3,1,1]]\n<b>输出：</b>9\n<strong>解释：</strong>\n蓝色格子是最优方案选中的格子，坐标分别为 (0, 2)，(1, 1) 和 (2, 0) 。\n你的总得分增加 3 + 5 + 3 = 11 。\n但是你的总得分需要扣除 abs(2 - 1) + abs(1 - 0) = 2 。\n你的最终得分为 11 - 2 = 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-42-14-diagram-drawio-diagrams-net.png\" style=\"width: 200px; height: 299px;\" />\n<pre>\n<b>输入：</b>points = [[1,5],[2,3],[4,2]]\n<b>输出：</b>11\n<strong>解释：</strong>\n蓝色格子是最优方案选中的格子，坐标分别为 (0, 1)，(1, 1) 和 (2, 0) 。\n你的总得分增加 5 + 3 + 4 = 12 。\n但是你的总得分需要扣除 abs(1 - 1) + abs(1 - 0) = 1 。\n你的最终得分为 12 - 1 = 11 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == points.length</code></li>\n\t<li><code>n == points[r].length</code></li>\n\t<li><code>1 <= m, n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= m * n <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= points[r][c] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1938.查询最大基因差",
        "hardRate": "HARD",
        "passRate": "40.20%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-genetic-difference-query/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-genetic-difference-query/solution",
        "problemsDesc": "<p>给你一棵 <code>n</code> 个节点的有根树，节点编号从 <code>0</code> 到 <code>n - 1</code> 。每个节点的编号表示这个节点的 <strong>独一无二的基因值</strong> （也就是说节点 <code>x</code> 的基因值为 <code>x</code>）。两个基因值的 <strong>基因差</strong> 是两者的 <strong>异或和</strong> 。给你整数数组 <code>parents</code> ，其中 <code>parents[i]</code> 是节点 <code>i</code> 的父节点。如果节点 <code>x</code> 是树的 <strong>根</strong> ，那么 <code>parents[x] == -1</code> 。</p>\n\n<p>给你查询数组 <code>queries</code> ，其中 <code>queries[i] = [node<sub>i</sub>, val<sub>i</sub>]</code> 。对于查询 <code>i</code> ，请你找到 <code>val<sub>i</sub></code> 和 <code>p<sub>i</sub></code> 的 <strong>最大基因差</strong> ，其中 <code>p<sub>i</sub></code> 是节点 <code>node<sub>i</sub></code> 到根之间的任意节点（包含 <code>node<sub>i</sub></code> 和根节点）。更正式的，你想要最大化 <code>val<sub>i</sub> XOR p<sub>i</sub></code><sub> </sub>。</p>\n\n<p>请你返回数组<em> </em><code>ans</code> ，其中 <code>ans[i]</code> 是第 <code>i</code> 个查询的答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/29/c1.png\" style=\"width: 118px; height: 163px;\">\n<pre><b>输入：</b>parents = [-1,0,1,1], queries = [[0,2],[3,2],[2,5]]\n<b>输出：</b>[2,3,7]\n<strong>解释：</strong>查询数组处理如下：\n- [0,2]：最大基因差的对应节点为 0 ，基因差为 2 XOR 0 = 2 。\n- [3,2]：最大基因差的对应节点为 1 ，基因差为 2 XOR 1 = 3 。\n- [2,5]：最大基因差的对应节点为 2 ，基因差为 5 XOR 2 = 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/29/c2.png\" style=\"width: 256px; height: 221px;\">\n<pre><b>输入：</b>parents = [3,7,-1,2,0,7,0,2], queries = [[4,6],[1,15],[0,5]]\n<b>输出：</b>[6,14,7]\n<strong>解释：</strong>查询数组处理如下：\n- [4,6]：最大基因差的对应节点为 0 ，基因差为 6 XOR 0 = 6 。\n- [1,15]：最大基因差的对应节点为 1 ，基因差为 15 XOR 1 = 14 。\n- [0,5]：最大基因差的对应节点为 2 ，基因差为 5 XOR 2 = 7 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= parents.length &lt;= 10<sup>5</sup></code></li>\n\t<li>对于每个 <strong>不是</strong> 根节点的 <code>i</code> ，有 <code>0 &lt;= parents[i] &lt;= parents.length - 1</code> 。</li>\n\t<li><code>parents[root] == -1</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= node<sub>i</sub> &lt;= parents.length - 1</code></li>\n\t<li><code>0 &lt;= val<sub>i</sub> &lt;= 2 * 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1939.主动请求确认消息的用户",
        "hardRate": "EASY",
        "passRate": "59.70%",
        "problemsUrl": "https://leetcode.cn/problems/users-that-actively-request-confirmation-messages/",
        "solutionsUrl": "https://leetcode.cn/problems/users-that-actively-request-confirmation-messages/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1940.排序数组之间的最长公共子序列",
        "hardRate": "MEDIUM",
        "passRate": "73.92%",
        "problemsUrl": "https://leetcode.cn/problems/longest-common-subsequence-between-sorted-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-common-subsequence-between-sorted-arrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1941.检查是否所有字符出现次数相同",
        "hardRate": "EASY",
        "passRate": "73.55%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-all-characters-have-equal-number-of-occurrences/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-all-characters-have-equal-number-of-occurrences/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，如果 <code>s</code> 是一个 <strong>好</strong> 字符串，请你返回 <code>true</code> ，否则请返回 <code>false</code> 。</p>\n\n<p>如果 <code>s</code> 中出现过的 <strong>所有</strong> 字符的出现次数 <strong>相同</strong> ，那么我们称字符串 <code>s</code> 是 <strong>好</strong> 字符串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"abacbc\"\n<b>输出：</b>true\n<b>解释：</b>s 中出现过的字符为 'a'，'b' 和 'c' 。s 中所有字符均出现 2 次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"aaabb\"\n<b>输出：</b>false\n<b>解释：</b>s 中出现过的字符为 'a' 和 'b' 。\n'a' 出现了 3 次，'b' 出现了 2 次，两者出现次数不同。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1942.最小未被占据椅子的编号",
        "hardRate": "MEDIUM",
        "passRate": "41.93%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-the-smallest-unoccupied-chair/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-the-smallest-unoccupied-chair/solution",
        "problemsDesc": "<p>有 <code>n</code> 个朋友在举办一个派对，这些朋友从 <code>0</code> 到 <code>n - 1</code> 编号。派对里有 <strong>无数</strong> 张椅子，编号为 <code>0</code> 到 <code>infinity</code> 。当一个朋友到达派对时，他会占据 <strong>编号最小</strong> 且未被占据的椅子。</p>\n\n<ul>\n\t<li>比方说，当一个朋友到达时，如果椅子 <code>0</code> ，<code>1</code> 和 <code>5</code> 被占据了，那么他会占据 <code>2</code> 号椅子。</li>\n</ul>\n\n<p>当一个朋友离开派对时，他的椅子会立刻变成未占据状态。如果同一时刻有另一个朋友到达，可以立即占据这张椅子。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>times</code> ，其中 <code>times[i] = [arrival<sub>i</sub>, leaving<sub>i</sub>]</code> 表示第 <code>i</code> 个朋友到达和离开的时刻，同时给你一个整数 <code>targetFriend</code> 。所有到达时间 <strong>互不相同</strong> 。</p>\n\n<p>请你返回编号为 <code>targetFriend</code> 的朋友占据的 <strong>椅子编号</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>times = [[1,4],[2,3],[4,6]], targetFriend = 1\n<b>输出：</b>1\n<b>解释：</b>\n- 朋友 0 时刻 1 到达，占据椅子 0 。\n- 朋友 1 时刻 2 到达，占据椅子 1 。\n- 朋友 1 时刻 3 离开，椅子 1 变成未占据。\n- 朋友 0 时刻 4 离开，椅子 0 变成未占据。\n- 朋友 2 时刻 4 到达，占据椅子 0 。\n朋友 1 占据椅子 1 ，所以返回 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>times = [[3,10],[1,5],[2,6]], targetFriend = 0\n<b>输出：</b>2\n<b>解释：</b>\n- 朋友 1 时刻 1 到达，占据椅子 0 。\n- 朋友 2 时刻 2 到达，占据椅子 1 。\n- 朋友 0 时刻 3 到达，占据椅子 2 。\n- 朋友 1 时刻 5 离开，椅子 0 变成未占据。\n- 朋友 2 时刻 6 离开，椅子 1 变成未占据。\n- 朋友 0 时刻 10 离开，椅子 2 变成未占据。\n朋友 0 占据椅子 2 ，所以返回 2 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == times.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>times[i].length == 2</code></li>\n\t<li><code>1 &lt;= arrival<sub>i</sub> &lt; leaving<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= targetFriend &lt;= n - 1</code></li>\n\t<li>每个 <code>arrival<sub>i</sub></code> 时刻 <strong>互不相同</strong> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1943.描述绘画结果",
        "hardRate": "MEDIUM",
        "passRate": "43.87%",
        "problemsUrl": "https://leetcode.cn/problems/describe-the-painting/",
        "solutionsUrl": "https://leetcode.cn/problems/describe-the-painting/solution",
        "problemsDesc": "<p>给你一个细长的画，用数轴表示。这幅画由若干有重叠的线段表示，每个线段有 <strong>独一无二</strong>&nbsp;的颜色。给你二维整数数组&nbsp;<code>segments</code>&nbsp;，其中&nbsp;<code>segments[i] = [start<sub>i</sub>, end<sub>i</sub>, color<sub>i</sub>]</code>&nbsp;表示线段为&nbsp;<strong>半开区间</strong>&nbsp;<code>[start<sub>i</sub>, end<sub>i</sub>)</code> 且颜色为&nbsp;<code>color<sub>i</sub></code>&nbsp;。</p>\n\n<p>线段间重叠部分的颜色会被 <strong>混合</strong>&nbsp;。如果有两种或者更多颜色混合时，它们会形成一种新的颜色，用一个 <strong>集合</strong>&nbsp;表示这个混合颜色。</p>\n\n<ul>\n\t<li>比方说，如果颜色&nbsp;<code>2</code>&nbsp;，<code>4</code>&nbsp;和&nbsp;<code>6</code>&nbsp;被混合，那么结果颜色为&nbsp;<code>{2,4,6}</code>&nbsp;。</li>\n</ul>\n\n<p>为了简化题目，你不需要输出整个集合，只需要用集合中所有元素的 <strong>和</strong>&nbsp;来表示颜色集合。</p>\n\n<p>你想要用 <strong>最少数目</strong>&nbsp;不重叠 <strong>半开区间</strong>&nbsp;来 <b>表示</b>&nbsp;这幅混合颜色的画。这些线段可以用二维数组&nbsp;<code>painting</code>&nbsp;表示，其中 <code>painting[j] = [left<sub>j</sub>, right<sub>j</sub>, mix<sub>j</sub>]</code>&nbsp;表示一个&nbsp;<strong>半开区间</strong><code>[left<sub>j</sub>, right<sub>j</sub>)</code>&nbsp;的颜色 <strong>和</strong>&nbsp;为&nbsp;<code>mix<sub>j</sub></code>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，这幅画由&nbsp;<code>segments = [[1,4,5],[1,7,7]]</code>&nbsp;组成，那么它可以表示为&nbsp;<code>painting = [[1,4,12],[4,7,7]]</code>&nbsp;，因为：\n\n\t<ul>\n\t\t<li><code>[1,4)</code>&nbsp;由颜色&nbsp;<code>{5,7}</code>&nbsp;组成（和为&nbsp;<code>12</code>），分别来自第一个线段和第二个线段。</li>\n\t\t<li><code>[4,7)</code>&nbsp;由颜色 <code>{7}</code>&nbsp;组成，来自第二个线段。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回二维数组&nbsp;<code>painting</code>&nbsp;，它表示最终绘画的结果（<strong>没有</strong>&nbsp;被涂色的部分不出现在结果中）。你可以按 <strong>任意顺序</strong> 返回最终数组的结果。</p>\n\n<p><strong>半开区间&nbsp;</strong><code>[a, b)</code>&nbsp;是数轴上点&nbsp;<code>a</code> 和点&nbsp;<code>b</code>&nbsp;之间的部分，<strong>包含 </strong>点&nbsp;<code>a</code>&nbsp;且 <strong>不包含</strong>&nbsp;点&nbsp;<code>b</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/18/1.png\" style=\"width: 529px; height: 241px;\" />\n<pre>\n<b>输入：</b>segments = [[1,4,5],[4,7,7],[1,7,9]]\n<b>输出：</b>[[1,4,14],[4,7,16]]\n<strong>解释：</strong>绘画结果可以表示为：\n- [1,4) 颜色为 {5,9} （和为 14），分别来自第一和第二个线段。\n- [4,7) 颜色为 {7,9} （和为 16），分别来自第二和第三个线段。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/18/2.png\" style=\"width: 532px; height: 219px;\" />\n<pre>\n<b>输入：</b>segments = [[1,7,9],[6,8,15],[8,10,7]]\n<b>输出：</b>[[1,6,9],[6,7,24],[7,8,15],[8,10,7]]\n<b>解释：</b>绘画结果可以以表示为：\n- [1,6) 颜色为 9 ，来自第一个线段。\n- [6,7) 颜色为 {9,15} （和为 24），来自第一和第二个线段。\n- [7,8) 颜色为 15 ，来自第二个线段。\n- [8,10) 颜色为 7 ，来自第三个线段。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/04/c1.png\" style=\"width: 529px; height: 289px;\" />\n<pre>\n<b>输入：</b>segments = [[1,4,5],[1,4,7],[4,7,1],[4,7,11]]\n<b>输出：</b>[[1,4,12],[4,7,12]]\n<strong>解释：</strong>绘画结果可以表示为：\n- [1,4) 颜色为 {5,7} （和为 12），分别来自第一和第二个线段。\n- [4,7) 颜色为 {1,11} （和为 12），分别来自第三和第四个线段。\n注意，只返回一个单独的线段 [1,7) 是不正确的，因为混合颜色的集合不相同。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= segments.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>segments[i].length == 3</code></li>\n\t<li><code>1 &lt;= start<sub>i</sub> &lt; end<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= color<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li>每种颜色&nbsp;<code>color<sub>i</sub></code>&nbsp;互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1944.队列中可以看到的人数",
        "hardRate": "HARD",
        "passRate": "63.31%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-visible-people-in-a-queue/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-visible-people-in-a-queue/solution",
        "problemsDesc": "<p>有&nbsp;<code>n</code>&nbsp;个人排成一个队列，<strong>从左到右</strong>&nbsp;编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。给你以一个整数数组&nbsp;<code>heights</code>&nbsp;，每个整数 <strong>互不相同</strong>，<code>heights[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个人的高度。</p>\n\n<p>一个人能 <strong>看到</strong> 他右边另一个人的条件是这两人之间的所有人都比他们两人 <strong>矮</strong>&nbsp;。更正式的，第&nbsp;<code>i</code>&nbsp;个人能看到第&nbsp;<code>j</code>&nbsp;个人的条件是&nbsp;<code>i &lt; j</code>&nbsp;且&nbsp;<code>min(heights[i], heights[j]) &gt; max(heights[i+1], heights[i+2], ..., heights[j-1])</code>&nbsp;。</p>\n\n<p>请你返回一个长度为 <code>n</code>&nbsp;的数组<em>&nbsp;</em><code>answer</code><em>&nbsp;</em>，其中<em>&nbsp;</em><code>answer[i]</code><em>&nbsp;</em>是第&nbsp;<code>i</code>&nbsp;个人在他右侧队列中能&nbsp;<strong>看到</strong>&nbsp;的&nbsp;<strong>人数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/29/queue-plane.jpg\" style=\"width: 600px; height: 247px;\" /></p>\n\n<pre>\n<b>输入：</b>heights = [10,6,8,5,11,9]\n<b>输出：</b>[3,1,2,1,1,0]\n<strong>解释：</strong>\n第 0 个人能看到编号为 1 ，2 和 4 的人。\n第 1 个人能看到编号为 2 的人。\n第 2 个人能看到编号为 3 和 4 的人。\n第 3 个人能看到编号为 4 的人。\n第 4 个人能看到编号为 5 的人。\n第 5 个人谁也看不到因为他右边没人。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>heights = [5,1,2,3,10]\n<b>输出：</b>[4,1,1,1,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == heights.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= heights[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>heights</code>&nbsp;中所有数 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1945.字符串转化后的各位数字之和",
        "hardRate": "EASY",
        "passRate": "70.42%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-digits-of-string-after-convert/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-digits-of-string-after-convert/solution",
        "problemsDesc": "<p>给你一个由小写字母组成的字符串 <code>s</code> ，以及一个整数 <code>k</code> 。</p>\n\n<p>首先，用字母在字母表中的位置替换该字母，将 <code>s</code> <strong>转化</strong> 为一个整数（也就是，<code>'a'</code> 用 <code>1</code> 替换，<code>'b'</code> 用 <code>2</code> 替换，... <code>'z'</code> 用 <code>26</code> 替换）。接着，将整数 <strong>转换</strong> 为其 <strong>各位数字之和</strong> 。共重复 <strong>转换</strong> 操作 <strong><code>k</code> 次</strong> 。</p>\n\n<p>例如，如果 <code>s = \"zbax\"</code> 且 <code>k = 2</code> ，那么执行下述步骤后得到的结果是整数 <code>8</code> ：</p>\n\n<ul>\n\t<li><strong>转化：</strong><code>\"zbax\" ➝ \"(26)(2)(1)(24)\" ➝ \"262124\" ➝ 262124</code></li>\n\t<li><strong>转换 #1</strong>：<code>262124&nbsp;➝ 2 + 6 + 2 + 1 + 2 + 4&nbsp;➝ 17</code></li>\n\t<li><strong>转换 #2</strong>：<code>17 ➝ 1 + 7 ➝ 8</code></li>\n</ul>\n\n<p>返回执行上述操作后得到的结果整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"iiii\", k = 1\n<strong>输出：</strong>36\n<strong>解释：</strong>操作如下：\n- 转化：\"iiii\" ➝ \"(9)(9)(9)(9)\" ➝ \"9999\" ➝ 9999\n- 转换 #1：9999 ➝ 9 + 9 + 9 + 9 ➝ 36\n因此，结果整数为 36 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"leetcode\", k = 2\n<strong>输出：</strong>6\n<strong>解释：</strong>操作如下：\n- 转化：\"leetcode\" ➝ \"(12)(5)(5)(20)(3)(15)(4)(5)\" ➝ \"12552031545\" ➝ 12552031545\n- 转换 #1：12552031545 ➝ 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 ➝ 33\n- 转换 #2：33 ➝ 3 + 3 ➝ 6\n因此，结果整数为 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= k &lt;= 10</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1946.子字符串突变后可能得到的最大整数",
        "hardRate": "MEDIUM",
        "passRate": "32.24%",
        "problemsUrl": "https://leetcode.cn/problems/largest-number-after-mutating-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-number-after-mutating-substring/solution",
        "problemsDesc": "<p>给你一个字符串 <code>num</code> ，该字符串表示一个大整数。另给你一个长度为 <code>10</code> 且 <strong>下标从 0&nbsp; 开始</strong> 的整数数组 <code>change</code> ，该数组将 <code>0-9</code> 中的每个数字映射到另一个数字。更规范的说法是，数字 <code>d</code> 映射为数字 <code>change[d]</code> 。</p>\n\n<p>你可以选择 <strong>突变</strong>&nbsp; <code>num</code> 的任一子字符串。<strong>突变</strong> 子字符串意味着将每位数字 <code>num[i]</code> 替换为该数字在 <code>change</code> 中的映射（也就是说，将 <code>num[i]</code> 替换为 <code>change[num[i]]</code>）。</p>\n\n<p>请你找出在对 <code>num</code> 的任一子字符串执行突变操作（也可以不执行）后，可能得到的 <strong>最大整数</strong> ，并用字符串表示返回。</p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = \"<strong><em>1</em></strong>32\", change = [9,8,5,0,3,6,4,2,6,8]\n<strong>输出：</strong>\"<strong><em>8</em></strong>32\"\n<strong>解释：</strong>替换子字符串 \"1\"：\n- 1 映射为 change[1] = 8 。\n因此 \"<strong><em>1</em></strong>32\" 变为 \"<strong><em>8</em></strong>32\" 。\n\"832\" 是可以构造的最大整数，所以返回它的字符串表示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = \"<strong><em>021</em></strong>\", change = [9,4,3,5,7,2,1,9,0,6]\n<strong>输出：</strong>\"<strong><em>934</em></strong>\"\n<strong>解释：</strong>替换子字符串 \"021\"：\n- 0 映射为 change[0] = 9 。\n- 2 映射为 change[2] = 3 。\n- 1 映射为 change[1] = 4 。\n因此，\"<strong><em>021</em></strong>\" 变为 \"<strong><em>934</em></strong>\" 。\n\"934\" 是可以构造的最大整数，所以返回它的字符串表示。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = \"5\", change = [1,4,7,5,3,2,5,6,9,4]\n<strong>输出：</strong>\"5\"\n<strong>解释：</strong>\"5\" 已经是可以构造的最大整数，所以返回它的字符串表示。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>num</code> 仅由数字 <code>0-9</code> 组成</li>\n\t<li><code>change.length == 10</code></li>\n\t<li><code>0 &lt;= change[d] &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1947.最大兼容性评分和",
        "hardRate": "MEDIUM",
        "passRate": "57.91%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-compatibility-score-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-compatibility-score-sum/solution",
        "problemsDesc": "<p>有一份由 <code>n</code> 个问题组成的调查问卷，每个问题的答案要么是 <code>0</code>（no，否），要么是 <code>1</code>（yes，是）。</p>\n\n<p>这份调查问卷被分发给 <code>m</code> 名学生和 <code>m</code> 名导师，学生和导师的编号都是从 <code>0</code> 到 <code>m - 1</code> 。学生的答案用一个二维整数数组 <code>students</code> 表示，其中 <code>students[i]</code> 是一个整数数组，包含第 <code>i</code> 名学生对调查问卷给出的答案（<strong>下标从 0 开始</strong>）。导师的答案用一个二维整数数组 <code>mentors</code> 表示，其中 <code>mentors[j]</code> 是一个整数数组，包含第 <code>j</code> 名导师对调查问卷给出的答案（<strong>下标从 0 开始</strong>）。</p>\n\n<p>每个学生都会被分配给 <strong>一名</strong> 导师，而每位导师也会分配到 <strong>一名</strong> 学生。配对的学生与导师之间的兼容性评分等于学生和导师答案相同的次数。</p>\n\n<ul>\n\t<li>例如，学生答案为<code>[1, <strong><em>0</em></strong>, <strong><em>1</em></strong>]</code> 而导师答案为 <code>[0, <strong><em>0</em></strong>, <strong><em>1</em></strong>]</code> ，那么他们的兼容性评分为 2 ，因为只有第二个和第三个答案相同。</li>\n</ul>\n\n<p>请你找出最优的学生与导师的配对方案，以 <strong>最大程度上</strong> 提高 <strong>兼容性评分和</strong> 。</p>\n\n<p>给你 <code>students</code> 和 <code>mentors</code> ，返回可以得到的<em> </em><strong>最大兼容性评分和</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>students = [[1,1,0],[1,0,1],[0,0,1]], mentors = [[1,0,0],[0,0,1],[1,1,0]]\n<strong>输出：</strong>8\n<strong>解释：</strong>按下述方式分配学生和导师：\n- 学生 0 分配给导师 2 ，兼容性评分为 3 。\n- 学生 1 分配给导师 0 ，兼容性评分为 2 。\n- 学生 2 分配给导师 1 ，兼容性评分为 3 。\n最大兼容性评分和为 3 + 2 + 3 = 8 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>students = [[0,0],[0,0],[0,0]], mentors = [[1,1],[1,1],[1,1]]\n<strong>输出：</strong>0\n<strong>解释：</strong>任意学生与导师配对的兼容性评分都是 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == students.length == mentors.length</code></li>\n\t<li><code>n == students[i].length == mentors[j].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 8</code></li>\n\t<li><code>students[i][k]</code> 为 <code>0</code> 或 <code>1</code></li>\n\t<li><code>mentors[j][k]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1948.删除系统中的重复文件夹",
        "hardRate": "HARD",
        "passRate": "54.48%",
        "problemsUrl": "https://leetcode.cn/problems/delete-duplicate-folders-in-system/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-duplicate-folders-in-system/solution",
        "problemsDesc": "<p>由于一个漏洞，文件系统中存在许多重复文件夹。给你一个二维数组 <code>paths</code>，其中 <code>paths[i]</code> 是一个表示文件系统中第 <code>i</code> 个文件夹的绝对路径的数组。</p>\n\n<ul>\n\t<li>例如，<code>[\"one\", \"two\", \"three\"]</code> 表示路径 <code>\"/one/two/three\"</code> 。</li>\n</ul>\n\n<p>如果两个文件夹（不需要在同一层级）包含 <strong>非空且</strong><b>相同的&nbsp;</b>子文件夹&nbsp;<strong>集合</strong> 并具有相同的子文件夹结构，则认为这两个文件夹是相同文件夹。相同文件夹的根层级 <strong>不</strong> 需要相同。如果存在两个（或两个以上）<strong>相同</strong> 文件夹，则需要将这些文件夹和所有它们的子文件夹 <strong>标记</strong> 为待删除。</p>\n\n<ul>\n\t<li>例如，下面文件结构中的文件夹 <code>\"/a\"</code> 和 <code>\"/b\"</code> 相同。它们（以及它们的子文件夹）应该被 <strong>全部</strong> 标记为待删除：\n\n\t<ul>\n\t\t<li><code>/a</code></li>\n\t\t<li><code>/a/x</code></li>\n\t\t<li><code>/a/x/y</code></li>\n\t\t<li><code>/a/z</code></li>\n\t\t<li><code>/b</code></li>\n\t\t<li><code>/b/x</code></li>\n\t\t<li><code>/b/x/y</code></li>\n\t\t<li><code>/b/z</code></li>\n\t</ul>\n\t</li>\n\t<li>然而，如果文件结构中还包含路径 <code>\"/b/w\"</code> ，那么文件夹 <code>\"/a\"</code> 和 <code>\"/b\"</code> 就不相同。注意，即便添加了新的文件夹 <code>\"/b/w\"</code> ，仍然认为 <code>\"/a/x\"</code> 和 <code>\"/b/x\"</code> 相同。</li>\n</ul>\n\n<p>一旦所有的相同文件夹和它们的子文件夹都被标记为待删除，文件系统将会 <strong>删除</strong> 所有上述文件夹。文件系统只会执行一次删除操作。执行完这一次删除操作后，不会删除新出现的相同文件夹。</p>\n\n<p>返回二维数组<em> </em><code>ans</code> ，该数组包含删除所有标记文件夹之后剩余文件夹的路径。路径可以按 <strong>任意顺序</strong> 返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder1.jpg\" style=\"width: 200px; height: 218px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\"],[\"c\"],[\"d\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"a\"]]\n<strong>输出：</strong>[[\"d\"],[\"d\",\"a\"]]\n<strong>解释：</strong>文件结构如上所示。\n文件夹 \"/a\" 和 \"/c\"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 \"b\" 的空文件夹。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder2.jpg\" style=\"width: 200px; height: 355px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\"],[\"c\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"a\",\"b\",\"x\"],[\"a\",\"b\",\"x\",\"y\"],[\"w\"],[\"w\",\"y\"]]\n<strong>输出：</strong>[[\"c\"],[\"c\",\"b\"],[\"a\"],[\"a\",\"b\"]]\n<strong>解释：</strong>文件结构如上所示。\n文件夹 \"/a/b/x\" 和 \"/w\"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 \"y\" 的空文件夹。\n注意，文件夹 \"/a\" 和 \"/c\" 在删除后变为相同文件夹，但这两个文件夹不会被删除，因为删除只会进行一次，且它们没有在删除前被标记。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder3.jpg\" style=\"width: 200px; height: 201px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\",\"b\"],[\"c\",\"d\"],[\"c\"],[\"a\"]]\n<strong>输出：</strong>[[\"c\"],[\"c\",\"d\"],[\"a\"],[\"a\",\"b\"]]\n<strong>解释：</strong>文件系统中所有文件夹互不相同。\n注意，返回的数组可以按不同顺序返回文件夹路径，因为题目对顺序没有要求。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder4_.jpg\" style=\"width: 300px; height: 290px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\"],[\"a\",\"x\"],[\"a\",\"x\",\"y\"],[\"a\",\"z\"],[\"b\"],[\"b\",\"x\"],[\"b\",\"x\",\"y\"],[\"b\",\"z\"]]\n<strong>输出：</strong>[]\n<strong>解释：</strong>文件结构如上所示。\n文件夹 \"/a/x\" 和 \"/b/x\"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 \"y\" 的空文件夹。\n文件夹 \"/a\" 和 \"/b\"（以及它们的子文件夹）都会被标记为待删除，因为它们都包含一个名为 \"z\" 的空文件夹以及上面提到的文件夹 \"x\" 。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder5_.jpg\" style=\"width: 300px; height: 282px;\" />\n<pre>\n<strong>输入：</strong>paths = [[\"a\"],[\"a\",\"x\"],[\"a\",\"x\",\"y\"],[\"a\",\"z\"],[\"b\"],[\"b\",\"x\"],[\"b\",\"x\",\"y\"],[\"b\",\"z\"],[\"b\",\"w\"]]\n<strong>输出：</strong>[[\"b\"],[\"b\",\"w\"],[\"b\",\"z\"],[\"a\"],[\"a\",\"z\"]]\n<strong>解释：</strong>本例与上例的结构基本相同，除了新增 \"/b/w\" 文件夹。\n文件夹 \"/a/x\" 和 \"/b/x\" 仍然会被标记，但 \"/a\" 和 \"/b\" 不再被标记，因为 \"/b\" 中有名为 \"w\" 的空文件夹而 \"/a\" 没有。\n注意，\"/a/z\" 和 \"/b/z\" 不会被标记，因为相同子文件夹的集合必须是非空集合，但这两个文件夹都是空的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= paths.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= paths[i].length &lt;= 500</code></li>\n\t<li><code>1 &lt;= paths[i][j].length &lt;= 10</code></li>\n\t<li><code>1 &lt;= sum(paths[i][j].length) &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>path[i][j]</code> 由小写英文字母组成</li>\n\t<li>不会存在两个路径都指向同一个文件夹的情况</li>\n\t<li>对于不在根层级的任意文件夹，其父文件夹也会包含在输入中</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1949.坚定的友谊",
        "hardRate": "MEDIUM",
        "passRate": "52.14%",
        "problemsUrl": "https://leetcode.cn/problems/strong-friendship/",
        "solutionsUrl": "https://leetcode.cn/problems/strong-friendship/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1950.所有子数组最小值中的最大值",
        "hardRate": "MEDIUM",
        "passRate": "51.33%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-of-minimum-values-in-all-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-of-minimum-values-in-all-subarrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1951.查询具有最多共同关注者的所有两两结对组",
        "hardRate": "MEDIUM",
        "passRate": "65.24%",
        "problemsUrl": "https://leetcode.cn/problems/all-the-pairs-with-the-maximum-number-of-common-followers/",
        "solutionsUrl": "https://leetcode.cn/problems/all-the-pairs-with-the-maximum-number-of-common-followers/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1952.三除数",
        "hardRate": "EASY",
        "passRate": "54.80%",
        "problemsUrl": "https://leetcode.cn/problems/three-divisors/",
        "solutionsUrl": "https://leetcode.cn/problems/three-divisors/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> 。如果 <code>n</code> <strong>恰好有三个正除数</strong> ，返回 <code>true</code><em> </em>；否则，返回<em> </em><code>false</code> 。</p>\n\n<p>如果存在整数 <code>k</code> ，满足 <code>n = k * m</code> ，那么整数 <code>m</code> 就是 <code>n</code> 的一个 <strong>除数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>false\n<strong>解释：</strong>2 只有两个除数：1 和 2 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 4\n<strong>输出：</strong>true\n<strong>解释：</strong>4 有三个除数：1、2 和 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1953.你可以工作的最大周数",
        "hardRate": "MEDIUM",
        "passRate": "37.19%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-weeks-for-which-you-can-work/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-weeks-for-which-you-can-work/solution",
        "problemsDesc": "<p>给你&nbsp;<code>n</code> 个项目，编号从 <code>0</code> 到 <code>n - 1</code> 。同时给你一个整数数组 <code>milestones</code> ，其中每个 <code>milestones[i]</code> 表示第 <code>i</code> 个项目中的阶段任务数量。</p>\n\n<p>你可以按下面两个规则参与项目中的工作：</p>\n\n<ul>\n\t<li>每周，你将会完成 <strong>某一个</strong> 项目中的 <strong>恰好一个</strong>&nbsp;阶段任务。你每周都 <strong>必须</strong> 工作。</li>\n\t<li>在 <strong>连续的</strong> 两周中，你 <strong>不能</strong> 参与并完成同一个项目中的两个阶段任务。</li>\n</ul>\n\n<p>一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将&nbsp;<strong>停止工作</strong> 。注意，由于这些条件的限制，你可能无法完成所有阶段任务。</p>\n\n<p>返回在不违反上面规则的情况下你&nbsp;<strong>最多</strong>&nbsp;能工作多少周。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>milestones = [1,2,3]\n<strong>输出：</strong>6\n<strong>解释：</strong>一种可能的情形是：\n​​​​- 第 1 周，你参与并完成项目 0 中的一个阶段任务。\n- 第 2 周，你参与并完成项目 2 中的一个阶段任务。\n- 第 3 周，你参与并完成项目 1 中的一个阶段任务。\n- 第 4 周，你参与并完成项目 2 中的一个阶段任务。\n- 第 5 周，你参与并完成项目 1 中的一个阶段任务。\n- 第 6 周，你参与并完成项目 2 中的一个阶段任务。\n总周数是 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>milestones = [5,2,1]\n<strong>输出：</strong>7\n<strong>解释：</strong>一种可能的情形是：\n- 第 1 周，你参与并完成项目 0 中的一个阶段任务。\n- 第 2 周，你参与并完成项目 1 中的一个阶段任务。\n- 第 3 周，你参与并完成项目 0 中的一个阶段任务。\n- 第 4 周，你参与并完成项目 1 中的一个阶段任务。\n- 第 5 周，你参与并完成项目 0 中的一个阶段任务。\n- 第 6 周，你参与并完成项目 2 中的一个阶段任务。\n- 第 7 周，你参与并完成项目 0 中的一个阶段任务。\n总周数是 7 。\n注意，你不能在第 8 周参与完成项目 0 中的最后一个阶段任务，因为这会违反规则。\n因此，项目 0 中会有一个阶段任务维持未完成状态。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == milestones.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= milestones[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1954.收集足够苹果的最小花园周长",
        "hardRate": "MEDIUM",
        "passRate": "49.69%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-garden-perimeter-to-collect-enough-apples/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-garden-perimeter-to-collect-enough-apples/solution",
        "problemsDesc": "<p>给你一个用无限二维网格表示的花园，<strong>每一个</strong>&nbsp;整数坐标处都有一棵苹果树。整数坐标&nbsp;<code>(i, j)</code>&nbsp;处的苹果树有 <code>|i| + |j|</code>&nbsp;个苹果。</p>\n\n<p>你将会买下正中心坐标是 <code>(0, 0)</code>&nbsp;的一块 <strong>正方形土地</strong>&nbsp;，且每条边都与两条坐标轴之一平行。</p>\n\n<p>给你一个整数&nbsp;<code>neededApples</code>&nbsp;，请你返回土地的&nbsp;<strong>最小周长</strong>&nbsp;，使得&nbsp;<strong>至少</strong>&nbsp;有<strong>&nbsp;</strong><code>neededApples</code>&nbsp;个苹果在土地&nbsp;<strong>里面或者边缘上</strong>。</p>\n\n<p><code>|x|</code>&nbsp;的值定义为：</p>\n\n<ul>\n\t<li>如果&nbsp;<code>x &gt;= 0</code>&nbsp;，那么值为&nbsp;<code>x</code></li>\n\t<li>如果&nbsp;<code>x &lt;&nbsp;0</code>&nbsp;，那么值为&nbsp;<code>-x</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://pic.leetcode-cn.com/1627790803-qcBKFw-image.png\" style=\"width: 442px; height: 449px;\" />\n<pre>\n<b>输入：</b>neededApples = 1\n<b>输出：</b>8\n<b>解释：</b>边长长度为 1 的正方形不包含任何苹果。\n但是边长为 2 的正方形包含 12 个苹果（如上图所示）。\n周长为 2 * 4 = 8 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>neededApples = 13\n<b>输出：</b>16\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>neededApples = 1000000000\n<b>输出：</b>5040\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= neededApples &lt;= 10<sup>15</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1955.统计特殊子序列的数目",
        "hardRate": "HARD",
        "passRate": "52.51%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-special-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-special-subsequences/solution",
        "problemsDesc": "<p><strong>特殊序列</strong> 是由&nbsp;<strong>正整数</strong>&nbsp;个 <code>0</code>&nbsp;，紧接着&nbsp;<strong>正整数</strong>&nbsp;个 <code>1</code>&nbsp;，最后 <strong>正整数</strong>&nbsp;个 <code>2</code>&nbsp;组成的序列。</p>\n\n<ul>\n\t<li>比方说，<code>[0,1,2]</code> 和&nbsp;<code>[0,0,1,1,1,2]</code>&nbsp;是特殊序列。</li>\n\t<li>相反，<code>[2,1,0]</code>&nbsp;，<code>[1]</code>&nbsp;和&nbsp;<code>[0,1,2,0]</code>&nbsp;就不是特殊序列。</li>\n</ul>\n\n<p>给你一个数组&nbsp;<code>nums</code>&nbsp;（<strong>仅</strong>&nbsp;包含整数&nbsp;<code>0</code>，<code>1</code>&nbsp;和&nbsp;<code>2</code>），请你返回 <b>不同特殊子序列的数目</b>&nbsp;。由于答案可能很大，请你将它对&nbsp;<code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后返回。</p>\n\n<p>一个数组的 <strong>子序列</strong>&nbsp;是从原数组中删除零个或者若干个元素后，剩下元素不改变顺序得到的序列。如果两个子序列的 <strong>下标集合</strong>&nbsp;不同，那么这两个子序列是 <strong>不同的</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [0,1,2,2]\n<b>输出：</b>3\n<b>解释：</b>特殊子序列为 [<strong>0</strong>,<strong>1</strong>,<strong>2</strong>,2]，[<strong>0</strong>,<strong>1</strong>,2,<strong>2</strong>] 和 [<strong>0</strong>,<strong>1</strong>,<strong>2</strong>,<strong>2</strong>] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,2,0,0]\n<b>输出：</b>0\n<b>解释：</b>数组 [2,2,0,0] 中没有特殊子序列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [0,1,2,0,1,2]\n<b>输出：</b>7\n<b>解释：</b>特殊子序列包括：\n- [<strong>0</strong>,<strong>1</strong>,<strong>2</strong>,0,1,2]\n- [<strong>0</strong>,<strong>1</strong>,2,0,1,<strong>2</strong>]\n- [<strong>0</strong>,<strong>1</strong>,<strong>2</strong>,0,1,<strong>2</strong>]\n- [<strong>0</strong>,<strong>1</strong>,2,0,<strong>1</strong>,<strong>2</strong>]\n- [<strong>0</strong>,1,2,<strong>0</strong>,<strong>1</strong>,<strong>2</strong>]\n- [<strong>0</strong>,1,2,0,<strong>1</strong>,<strong>2</strong>]\n- [0,1,2,<strong>0</strong>,<strong>1</strong>,<strong>2</strong>]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1956.感染 K 种病毒所需的最短时间",
        "hardRate": "HARD",
        "passRate": "38.04%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-for-k-virus-variants-to-spread/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-for-k-virus-variants-to-spread/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1957.删除字符使字符串变好",
        "hardRate": "EASY",
        "passRate": "60.06%",
        "problemsUrl": "https://leetcode.cn/problems/delete-characters-to-make-fancy-string/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-characters-to-make-fancy-string/solution",
        "problemsDesc": "<p>一个字符串如果没有 <strong>三个连续</strong>&nbsp;相同字符，那么它就是一个 <strong>好字符串</strong>&nbsp;。</p>\n\n<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，请你从 <code>s</code>&nbsp;删除&nbsp;<strong>最少</strong>&nbsp;的字符，使它变成一个 <strong>好字符串</strong> 。</p>\n\n<p>请你返回删除后的字符串。题目数据保证答案总是 <strong>唯一的 </strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"le<strong>e</strong>etcode\"\n<b>输出：</b>\"leetcode\"\n<strong>解释：</strong>\n从第一组 'e' 里面删除一个 'e' ，得到 \"leetcode\" 。\n没有连续三个相同字符，所以返回 \"leetcode\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"<strong>a</strong>aab<strong>aa</strong>aa\"\n<b>输出：</b>\"aabaa\"\n<strong>解释：</strong>\n从第一组 'a' 里面删除一个 'a' ，得到 \"aabaaaa\" 。\n从第二组 'a' 里面删除两个 'a' ，得到 \"aabaa\" 。\n没有连续三个相同字符，所以返回 \"aabaa\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aab\"\n<b>输出：</b>\"aab\"\n<b>解释：</b>没有连续三个相同字符，所以返回 \"aab\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1958.检查操作是否合法",
        "hardRate": "MEDIUM",
        "passRate": "44.77%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-move-is-legal/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-move-is-legal/solution",
        "problemsDesc": "<p>给你一个下标从&nbsp;<strong>0</strong>&nbsp;开始的&nbsp;<code>8 x 8</code> 网格&nbsp;<code>board</code>&nbsp;，其中&nbsp;<code>board[r][c]</code>&nbsp;表示游戏棋盘上的格子&nbsp;<code>(r, c)</code>&nbsp;。棋盘上空格用&nbsp;<code>'.'</code>&nbsp;表示，白色格子用&nbsp;<code>'W'</code>&nbsp;表示，黑色格子用&nbsp;<code>'B'</code>&nbsp;表示。</p>\n\n<p>游戏中每次操作步骤为：选择一个空格子，将它变成你正在执行的颜色（要么白色，要么黑色）。但是，<strong>合法 </strong>操作必须满足：涂色后这个格子是 <strong>好线段的一个端点</strong>&nbsp;（好线段可以是水平的，竖直的或者是对角线）。</p>\n\n<p><strong>好线段</strong>&nbsp;指的是一个包含 <strong>三个或者更多格子（包含端点格子）</strong>的线段，线段两个端点格子为 <strong>同一种颜色</strong>&nbsp;，且中间剩余格子的颜色都为 <strong>另一种颜色</strong>&nbsp;（线段上不能有任何空格子）。你可以在下图找到好线段的例子：</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/22/goodlines5.png\" style=\"width: 500px; height: 312px;\" />\n<p>给你两个整数&nbsp;<code>rMove</code> 和&nbsp;<code>cMove</code>&nbsp;以及一个字符&nbsp;<code>color</code>&nbsp;，表示你正在执行操作的颜色（白或者黑），如果将格子&nbsp;<code>(rMove, cMove)</code>&nbsp;变成颜色&nbsp;<code>color</code>&nbsp;后，是一个&nbsp;<strong>合法</strong>&nbsp;操作，那么返回&nbsp;<code>true</code>&nbsp;，如果不是合法操作返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/10/grid11.png\" style=\"width: 350px; height: 350px;\" /></p>\n\n<pre>\n<b>输入：</b>board = [[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"],[\"W\",\"B\",\"B\",\".\",\"W\",\"W\",\"W\",\"B\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\".\",\".\",\".\",\".\"]], rMove = 4, cMove = 3, color = \"B\"\n<b>输出：</b>true\n<b>解释：</b>'.'，'W' 和 'B' 分别用颜色蓝色，白色和黑色表示。格子 (rMove, cMove) 用 'X' 标记。\n以选中格子为端点的两个好线段在上图中用红色矩形标注出来了。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/10/grid2.png\" style=\"width: 350px; height: 351px;\" /></p>\n\n<pre>\n<b>输入：</b>board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"B\",\".\",\".\",\"W\",\".\",\".\",\".\"],[\".\",\".\",\"W\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"W\",\"B\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\"B\",\"W\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"W\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"B\"]], rMove = 4, cMove = 4, color = \"W\"\n<b>输出：</b>false\n<b>解释：</b>虽然选中格子涂色后，棋盘上产生了好线段，但选中格子是作为中间格子，没有产生以选中格子为端点的好线段。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>board.length == board[r].length == 8</code></li>\n\t<li><code>0 &lt;= rMove, cMove &lt; 8</code></li>\n\t<li><code>board[rMove][cMove] == '.'</code></li>\n\t<li><code>color</code>&nbsp;要么是&nbsp;<code>'B'</code> 要么是&nbsp;<code>'W'</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1959.K 次调整数组大小浪费的最小总空间",
        "hardRate": "MEDIUM",
        "passRate": "45.89%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-total-space-wasted-with-k-resizing-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-total-space-wasted-with-k-resizing-operations/solution",
        "problemsDesc": "<p>你正在设计一个动态数组。给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，其中&nbsp;<code>nums[i]</code>&nbsp;是&nbsp;<code>i</code>&nbsp;时刻数组中的元素数目。除此以外，你还有一个整数 <code>k</code>&nbsp;，表示你可以 <strong>调整</strong>&nbsp;数组大小的 <strong>最多</strong>&nbsp;次数（每次都可以调整成 <strong>任意</strong>&nbsp;大小）。</p>\n\n<p><code>t</code>&nbsp;时刻数组的大小&nbsp;<code>size<sub>t</sub></code>&nbsp;必须大于等于&nbsp;<code>nums[t]</code>&nbsp;，因为数组需要有足够的空间容纳所有元素。<code>t</code>&nbsp;时刻 <strong>浪费的空间</strong>&nbsp;为&nbsp;<code>size<sub>t</sub> - nums[t]</code>&nbsp;，<strong>总</strong>&nbsp;浪费空间为满足&nbsp;<code>0 &lt;= t &lt; nums.length</code>&nbsp;的每一个时刻&nbsp;<code>t</code>&nbsp;浪费的空间&nbsp;<strong>之和</strong>&nbsp;。</p>\n\n<p>在调整数组大小不超过 <code>k</code>&nbsp;次的前提下，请你返回 <strong>最小总浪费空间</strong>&nbsp;。</p>\n\n<p><strong>注意：</strong>数组最开始时可以为&nbsp;<strong>任意大小</strong>&nbsp;，且&nbsp;<strong>不计入</strong>&nbsp;调整大小的操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [10,20], k = 0\n<b>输出：</b>10\n<b>解释：</b>size = [20,20].\n我们可以让数组初始大小为 20 。\n总浪费空间为 (20 - 10) + (20 - 20) = 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [10,20,30], k = 1\n<b>输出：</b>10\n<b>解释：</b>size = [20,20,30].\n我们可以让数组初始大小为 20 ，然后时刻 2 调整大小为 30 。\n总浪费空间为 (20 - 10) + (20 - 20) + (30 - 30) = 10 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [10,20,15,30,20], k = 2\n<b>输出：</b>15\n<b>解释：</b>size = [10,20,20,30,30].\n我们可以让数组初始大小为 10 ，时刻 1 调整大小为 20 ，时刻 3 调整大小为 30 。\n总浪费空间为 (10 - 10) + (20 - 20) + (20 - 15) + (30 - 30) + (30 - 20) = 15 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= nums.length - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1960.两个回文子字符串长度的最大乘积",
        "hardRate": "HARD",
        "passRate": "32.32%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-product-of-the-length-of-two-palindromic-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-product-of-the-length-of-two-palindromic-substrings/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>s</code>&nbsp;，你需要找到两个 <strong>不重叠</strong><strong>的回文&nbsp;</strong>子字符串，它们的长度都必须为 <strong>奇数</strong>&nbsp;，使得它们长度的乘积最大。</p>\n\n<p>更正式地，你想要选择四个整数&nbsp;<code>i</code>&nbsp;，<code>j</code>&nbsp;，<code>k</code>&nbsp;，<code>l</code>&nbsp;，使得&nbsp;<code>0 &lt;= i &lt;= j &lt; k &lt;= l &lt; s.length</code>&nbsp;，且子字符串&nbsp;<code>s[i...j]</code> 和&nbsp;<code>s[k...l]</code>&nbsp;都是回文串且长度为奇数。<code>s[i...j]</code>&nbsp;表示下标从 <code>i</code>&nbsp;到 <code>j</code>&nbsp;且 <strong>包含</strong>&nbsp;两端下标的子字符串。</p>\n\n<p>请你返回两个不重叠回文子字符串长度的 <strong>最大</strong>&nbsp;乘积。</p>\n\n<p><strong>回文字符串</strong>&nbsp;指的是一个从前往后读和从后往前读一模一样的字符串。<strong>子字符串</strong>&nbsp;指的是一个字符串中一段连续字符。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"ababbb\"\n<b>输出：</b>9\n<b>解释：</b>子字符串 \"aba\" 和 \"bbb\" 为奇数长度的回文串。乘积为 3 * 3 = 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"zaaaxbbby\"\n<b>输出：</b>9\n<b>解释：</b>子字符串 \"aaa\" 和 \"bbb\" 为奇数长度的回文串。乘积为 3 * 3 = 9 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1961.检查字符串是否为数组前缀",
        "hardRate": "EASY",
        "passRate": "52.73%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-string-is-a-prefix-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-string-is-a-prefix-of-array/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和一个字符串数组 <code>words</code> ，请你判断 <code>s</code> 是否为 <code>words</code> 的 <strong>前缀字符串</strong> 。</p>\n\n<p>字符串 <code>s</code> 要成为 <code>words</code> 的 <strong>前缀字符串</strong> ，需要满足：<code>s</code> 可以由 <code>words</code> 中的前 <code>k</code>（<code>k</code> 为 <strong>正数</strong> ）个字符串按顺序相连得到，且 <code>k</code> 不超过 <code>words.length</code> 。</p>\n\n<p>如果 <code>s</code> 是 <code>words</code> 的 <strong>前缀字符串</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"iloveleetcode\", words = [\"i\",\"love\",\"leetcode\",\"apples\"]\n<strong>输出：</strong>true\n<strong>解释：</strong>\ns 可以由 \"i\"、\"love\" 和 \"leetcode\" 相连得到。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"iloveleetcode\", words = [\"apples\",\"i\",\"love\",\"leetcode\"]\n<strong>输出：</strong>false\n<strong>解释：</strong>\n数组的前缀相连无法得到 s 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 20</code></li>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>words[i]</code> 和 <code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1962.移除石子使总数最小",
        "hardRate": "MEDIUM",
        "passRate": "46.67%",
        "problemsUrl": "https://leetcode.cn/problems/remove-stones-to-minimize-the-total/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-stones-to-minimize-the-total/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>piles</code> ，数组 <strong>下标从 0 开始</strong> ，其中 <code>piles[i]</code> 表示第 <code>i</code> 堆石子中的石子数量。另给你一个整数 <code>k</code> ，请你执行下述操作 <strong>恰好</strong> <code>k</code> 次：</p>\n\n<ul>\n\t<li>选出任一石子堆 <code>piles[i]</code> ，并从中 <strong>移除</strong> <code>floor(piles[i] / 2)</code> 颗石子。</li>\n</ul>\n\n<p><strong>注意：</strong>你可以对 <strong>同一堆</strong> 石子多次执行此操作。</p>\n\n<p>返回执行 <code>k</code> 次操作后，剩下石子的 <strong>最小</strong> 总数。</p>\n\n<p><code>floor(x)</code> 为 <strong>小于</strong> 或 <strong>等于</strong> <code>x</code> 的 <strong>最大</strong> 整数。（即，对 <code>x</code> 向下取整）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [5,4,9], k = 2\n<strong>输出：</strong>12\n<strong>解释：</strong>可能的执行情景如下：\n- 对第 2 堆石子执行移除操作，石子分布情况变成 [5,4,<strong><em>5</em></strong>] 。\n- 对第 0 堆石子执行移除操作，石子分布情况变成 [<strong><em>3</em></strong>,4,5] 。\n剩下石子的总数为 12 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>piles = [4,3,6,7], k = 3\n<strong>输出：</strong>12\n<strong>解释：</strong>可能的执行情景如下：\n- 对第 2 堆石子执行移除操作，石子分布情况变成 [4,3,<strong><em>3</em></strong>,7] 。\n- 对第 3 堆石子执行移除操作，石子分布情况变成 [4,3,3,<strong><em>4</em></strong>] 。\n- 对第 0 堆石子执行移除操作，石子分布情况变成 [<strong><em>2</em></strong>,3,3,4] 。\n剩下石子的总数为 12 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= piles.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= piles[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1963.使字符串平衡的最小交换次数",
        "hardRate": "MEDIUM",
        "passRate": "64.54%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-swaps-to-make-the-string-balanced/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-swaps-to-make-the-string-balanced/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，<strong>下标从 0 开始</strong> ，且长度为偶数 <code>n</code> 。字符串 <strong>恰好</strong> 由 <code>n / 2</code> 个开括号 <code>'['</code> 和 <code>n / 2</code> 个闭括号 <code>']'</code> 组成。</p>\n\n<p>只有能满足下述所有条件的字符串才能称为 <strong>平衡字符串</strong> ：</p>\n\n<ul>\n\t<li>字符串是一个空字符串，或者</li>\n\t<li>字符串可以记作 <code>AB</code> ，其中 <code>A</code> 和 <code>B</code> 都是 <strong>平衡字符串</strong> ，或者</li>\n\t<li>字符串可以写成 <code>[C]</code> ，其中 <code>C</code> 是一个 <strong>平衡字符串</strong> 。</li>\n</ul>\n\n<p>你可以交换 <strong>任意</strong> 两个下标所对应的括号 <strong>任意</strong> 次数。</p>\n\n<p>返回使<em> </em><code>s</code> 变成 <strong>平衡字符串</strong> 所需要的 <strong>最小</strong> 交换次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"][][\"\n<strong>输出：</strong>1\n<strong>解释：</strong>交换下标 0 和下标 3 对应的括号，可以使字符串变成平衡字符串。\n最终字符串变成 \"[[]]\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"]]][[[\"\n<strong>输出：</strong>2\n<strong>解释：</strong>执行下述操作可以使字符串变成平衡字符串：\n- 交换下标 0 和下标 4 对应的括号，s = \"[]][][\" 。\n- 交换下标 1 和下标 5 对应的括号，s = \"[[][]]\" 。\n最终字符串变成 \"[[][]]\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"[]\"\n<strong>输出：</strong>0\n<strong>解释：</strong>这个字符串已经是平衡字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == s.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>6</sup></code></li>\n\t<li><code>n</code> 为偶数</li>\n\t<li><code>s[i]</code> 为<code>'['</code> 或 <code>']'</code></li>\n\t<li>开括号 <code>'['</code> 的数目为 <code>n / 2</code> ，闭括号 <code>']'</code> 的数目也是 <code>n / 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1964.找出到每个位置为止最长的有效障碍赛跑路线",
        "hardRate": "HARD",
        "passRate": "43.57%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-longest-valid-obstacle-course-at-each-position/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-longest-valid-obstacle-course-at-each-position/solution",
        "problemsDesc": "<p>你打算构建一些障碍赛跑路线。给你一个 <strong>下标从 0 开始</strong> 的整数数组 <code>obstacles</code> ，数组长度为 <code>n</code> ，其中 <code>obstacles[i]</code> 表示第 <code>i</code> 个障碍的高度。</p>\n\n<p>对于每个介于 <code>0</code> 和 <code>n - 1</code> 之间（包含 <code>0</code> 和 <code>n - 1</code>）的下标&nbsp; <code>i</code> ，在满足下述条件的前提下，请你找出&nbsp;<code>obstacles</code> 能构成的最长障碍路线的长度：</p>\n\n<ul>\n\t<li>你可以选择下标介于 <code>0</code> 到 <code>i</code> 之间（包含 <code>0</code> 和 <code>i</code>）的任意个障碍。</li>\n\t<li>在这条路线中，必须包含第 <code>i</code> 个障碍。</li>\n\t<li>你必须按障碍在&nbsp;<code>obstacles</code>&nbsp;中的<strong> </strong><strong>出现顺序</strong> 布置这些障碍。</li>\n\t<li>除第一个障碍外，路线中每个障碍的高度都必须和前一个障碍 <strong>相同</strong> 或者 <strong>更高</strong> 。</li>\n</ul>\n\n<p>返回长度为 <code>n</code> 的答案数组 <code>ans</code> ，其中 <code>ans[i]</code> 是上面所述的下标 <code>i</code> 对应的最长障碍赛跑路线的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>obstacles = [1,2,3,2]\n<strong>输出：</strong>[1,2,3,3]\n<strong>解释：</strong>每个位置的最长有效障碍路线是：\n- i = 0: [<em><strong>1</strong></em>], [1] 长度为 1\n- i = 1: [<em><strong>1</strong></em>,<em><strong>2</strong></em>], [1,2] 长度为 2\n- i = 2: [<em><strong>1</strong></em>,<em><strong>2</strong></em>,<em><strong>3</strong></em>], [1,2,3] 长度为 3\n- i = 3: [<em><strong>1</strong></em>,<em><strong>2</strong></em>,3,<em><strong>2</strong></em>], [1,2,2] 长度为 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>obstacles = [2,2,1]\n<strong>输出：</strong>[1,2,1]\n<strong>解释：</strong>每个位置的最长有效障碍路线是：\n- i = 0: [<em><strong>2</strong></em>], [2] 长度为 1\n- i = 1: [<em><strong>2</strong></em>,<em><strong>2</strong></em>], [2,2] 长度为 2\n- i = 2: [2,2,<em><strong>1</strong></em>], [1] 长度为 1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>obstacles = [3,1,5,6,4,2]\n<strong>输出：</strong>[1,1,2,3,2,2]\n<strong>解释：</strong>每个位置的最长有效障碍路线是：\n- i = 0: [<em><strong>3</strong></em>], [3] 长度为 1\n- i = 1: [3,<em><strong>1</strong></em>], [1] 长度为 1\n- i = 2: [<em><strong>3</strong></em>,1,<em><strong>5</strong></em>], [3,5] 长度为 2, [1,5] 也是有效的障碍赛跑路线\n- i = 3: [<em><strong>3</strong></em>,1,<em><strong>5</strong></em>,<em><strong>6</strong></em>], [3,5,6] 长度为 3, [1,5,6] 也是有效的障碍赛跑路线\n- i = 4: [<em><strong>3</strong></em>,1,5,6,<em><strong>4</strong></em>], [3,4] 长度为 2, [1,4] 也是有效的障碍赛跑路线\n- i = 5: [3,<em><strong>1</strong></em>,5,6,4,<em><strong>2</strong></em>], [1,2] 长度为 2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == obstacles.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= obstacles[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1965.丢失信息的雇员",
        "hardRate": "EASY",
        "passRate": "71.06%",
        "problemsUrl": "https://leetcode.cn/problems/employees-with-missing-information/",
        "solutionsUrl": "https://leetcode.cn/problems/employees-with-missing-information/solution",
        "problemsDesc": "<p>表: <code>Employees</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| employee_id | int     |\n| name        | varchar |\n+-------------+---------+\nemployee_id 是这个表的主键。\n每一行表示雇员的id 和他的姓名。\n</pre>\n\n<p>表: <code>Salaries</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| employee_id | int     |\n| salary      | int     |\n+-------------+---------+\nemployee_id is 这个表的主键。\n每一行表示雇员的id 和他的薪水。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写出一个查询语句，找到所有 <strong>丢失信息</strong> 的雇员id。当满足下面一个条件时，就被认为是雇员的信息丢失：</p>\n\n<ul>\n\t<li>雇员的 <strong>姓名</strong> 丢失了，或者</li>\n\t<li>雇员的 <strong>薪水信息</strong> 丢失了，或者</li>\n</ul>\n\n<p>返回这些雇员的id &nbsp;<code>employee_id</code>&nbsp;，&nbsp;<strong>从小到大排序&nbsp;</strong>。</p>\n\n<p>查询结果格式如下面的例子所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nEmployees table:\n+-------------+----------+\n| employee_id | name     |\n+-------------+----------+\n| 2           | Crew     |\n| 4           | Haven    |\n| 5           | Kristian |\n+-------------+----------+\nSalaries table:\n+-------------+--------+\n| employee_id | salary |\n+-------------+--------+\n| 5           | 76071  |\n| 1           | 22517  |\n| 4           | 63539  |\n+-------------+--------+\n<strong>输出：</strong>\n+-------------+\n| employee_id |\n+-------------+\n| 1           |\n| 2           |\n+-------------+\n<strong>解释：</strong>\n雇员1，2，4，5 都工作在这个公司。\n1号雇员的姓名丢失了。\n2号雇员的薪水信息丢失了。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1966.未排序数组中的可被二分搜索的数",
        "hardRate": "MEDIUM",
        "passRate": "64.40%",
        "problemsUrl": "https://leetcode.cn/problems/binary-searchable-numbers-in-an-unsorted-array/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-searchable-numbers-in-an-unsorted-array/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1967.作为子字符串出现在单词中的字符串数目",
        "hardRate": "EASY",
        "passRate": "79.29%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-strings-that-appear-as-substrings-in-word/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-strings-that-appear-as-substrings-in-word/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>patterns</code> 和一个字符串 <code>word</code> ，统计 <code>patterns</code> 中有多少个字符串是 <code>word</code> 的子字符串。返回字符串数目。</p>\n\n<p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>patterns = [\"a\",\"abc\",\"bc\",\"d\"], word = \"abc\"\n<strong>输出：</strong>3\n<strong>解释：</strong>\n- \"a\" 是 \"<em><strong>a</strong></em>bc\" 的子字符串。\n- \"abc\" 是 \"<em><strong>abc</strong></em>\" 的子字符串。\n- \"bc\" 是 \"a<em><strong>bc</strong></em>\" 的子字符串。\n- \"d\" 不是 \"abc\" 的子字符串。\npatterns 中有 3 个字符串作为子字符串出现在 word 中。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>patterns = [\"a\",\"b\",\"c\"], word = \"aaaaabbbbb\"\n<strong>输出：</strong>2\n<strong>解释：</strong>\n- \"a\" 是 \"a<em><strong>a</strong></em>aaabbbbb\" 的子字符串。\n- \"b\" 是 \"aaaaabbbb<em><strong>b</strong></em>\" 的子字符串。\n- \"c\" 不是 \"aaaaabbbbb\" 的字符串。\npatterns 中有 2 个字符串作为子字符串出现在 word 中。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>patterns = [\"a\",\"a\",\"a\"], word = \"ab\"\n<strong>输出：</strong>3\n<strong>解释：</strong>patterns 中的每个字符串都作为子字符串出现在 word \"<em><strong>a</strong></em>b\" 中。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= patterns.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= patterns[i].length &lt;= 100</code></li>\n\t<li><code>1 &lt;= word.length &lt;= 100</code></li>\n\t<li><code>patterns[i]</code> 和 <code>word</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1968.构造元素不等于两相邻元素平均值的数组",
        "hardRate": "MEDIUM",
        "passRate": "39.25%",
        "problemsUrl": "https://leetcode.cn/problems/array-with-elements-not-equal-to-average-of-neighbors/",
        "solutionsUrl": "https://leetcode.cn/problems/array-with-elements-not-equal-to-average-of-neighbors/solution",
        "problemsDesc": "<p>给你一个 <strong>下标从 0 开始</strong> 的数组 <code>nums</code> ，数组由若干 <strong>互不相同的</strong> 整数组成。你打算重新排列数组中的元素以满足：重排后，数组中的每个元素都 <strong>不等于</strong> 其两侧相邻元素的 <strong>平均值</strong> 。</p>\n\n<p>更公式化的说法是，重新排列的数组应当满足这一属性：对于范围&nbsp;<code>1 &lt;= i &lt; nums.length - 1</code> 中的每个 <code>i</code> ，<code>(nums[i-1] + nums[i+1]) / 2</code> <strong>不等于</strong> <code>nums[i]</code> 均成立 。</p>\n\n<p>返回满足题意的任一重排结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,5]\n<strong>输出：</strong>[1,2,4,5,3]\n<strong>解释：</strong>\ni=1, nums[i] = 2, 两相邻元素平均值为 (1+4) / 2 = 2.5\ni=2, nums[i] = 4, 两相邻元素平均值为 (2+5) / 2 = 3.5\ni=3, nums[i] = 5, 两相邻元素平均值为 (4+3) / 2 = 3.5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [6,2,0,9,7]\n<strong>输出：</strong>[9,7,6,2,0]\n<strong>解释：</strong>\ni=1, nums[i] = 7, 两相邻元素平均值为 (9+6) / 2 = 7.5\ni=2, nums[i] = 6, 两相邻元素平均值为 (7+2) / 2 = 4.5\ni=3, nums[i] = 2, 两相邻元素平均值为 (6+0) / 2 = 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1969.数组元素的最小非零乘积",
        "hardRate": "MEDIUM",
        "passRate": "29.83%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-non-zero-product-of-the-array-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-non-zero-product-of-the-array-elements/solution",
        "problemsDesc": "<p>给你一个正整数&nbsp;<code>p</code>&nbsp;。你有一个下标从 <strong>1</strong>&nbsp;开始的数组&nbsp;<code>nums</code>&nbsp;，这个数组包含范围&nbsp;<code>[1, 2<sup>p</sup> - 1]</code>&nbsp;内所有整数的二进制形式（两端都 <strong>包含</strong>）。你可以进行以下操作 <strong>任意</strong>&nbsp;次：</p>\n\n<ul>\n\t<li>从 <code>nums</code>&nbsp;中选择两个元素&nbsp;<code>x</code>&nbsp;和&nbsp;<code>y</code>&nbsp; 。</li>\n\t<li>选择 <code>x</code>&nbsp;中的一位与 <code>y</code>&nbsp;对应位置的位交换。对应位置指的是两个整数 <strong>相同位置</strong>&nbsp;的二进制位。</li>\n</ul>\n\n<p>比方说，如果&nbsp;<code>x = 11<em><strong>0</strong></em>1</code>&nbsp;且&nbsp;<code>y = 00<em><strong>1</strong></em>1</code>&nbsp;，交换右边数起第 <code>2</code>&nbsp;位后，我们得到&nbsp;<code>x = 11<em><strong>1</strong></em>1</code> 和&nbsp;<code>y = 00<em><strong>0</strong></em>1</code>&nbsp;。</p>\n\n<p>请你算出进行以上操作 <strong>任意次</strong>&nbsp;以后，<code>nums</code>&nbsp;能得到的 <strong>最小非零</strong>&nbsp;乘积。将乘积对<em>&nbsp;</em><code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong> 后返回。</p>\n\n<p><strong>注意：</strong>答案应为取余 <strong>之前</strong>&nbsp;的最小值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>p = 1\n<b>输出：</b>1\n<b>解释：</b>nums = [1] 。\n只有一个元素，所以乘积为该元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>p = 2\n<b>输出：</b>6\n<b>解释：</b>nums = [01, 10, 11] 。\n所有交换要么使乘积变为 0 ，要么乘积与初始乘积相同。\n所以，数组乘积 1 * 2 * 3 = 6 已经是最小值。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>p = 3\n<b>输出：</b>1512\n<b>解释：</b>nums = [001, 010, 011, 100, 101, 110, 111]\n- 第一次操作中，我们交换第二个和第五个元素最左边的数位。\n    - 结果数组为 [001, <em><strong>1</strong></em>10, 011, 100, <em><strong>0</strong></em>01, 110, 111] 。\n- 第二次操作中，我们交换第三个和第四个元素中间的数位。\n    - 结果数组为 [001, 110, 0<em><strong>0</strong></em>1, 1<em><strong>1</strong></em>0, 001, 110, 111] 。\n数组乘积 1 * 6 * 1 * 6 * 1 * 6 * 7 = 1512 是最小乘积。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= p &lt;= 60</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1970.你能穿过矩阵的最后一天",
        "hardRate": "HARD",
        "passRate": "50.89%",
        "problemsUrl": "https://leetcode.cn/problems/last-day-where-you-can-still-cross/",
        "solutionsUrl": "https://leetcode.cn/problems/last-day-where-you-can-still-cross/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>1</strong>&nbsp;开始的二进制矩阵，其中&nbsp;<code>0</code>&nbsp;表示陆地，<code>1</code>&nbsp;表示水域。同时给你&nbsp;<code>row</code> 和&nbsp;<code>col</code>&nbsp;分别表示矩阵中行和列的数目。</p>\n\n<p>一开始在第&nbsp;<code>0</code>&nbsp;天，<strong>整个</strong>&nbsp;矩阵都是&nbsp;<strong>陆地</strong>&nbsp;。但每一天都会有一块新陆地被&nbsp;<strong>水</strong>&nbsp;淹没变成水域。给你一个下标从&nbsp;<strong>1</strong>&nbsp;开始的二维数组&nbsp;<code>cells</code>&nbsp;，其中&nbsp;<code>cells[i] = [r<sub>i</sub>, c<sub>i</sub>]</code>&nbsp;表示在第&nbsp;<code>i</code>&nbsp;天，第&nbsp;<code>r<sub>i</sub></code>&nbsp;行&nbsp;<code>c<sub>i</sub></code>&nbsp;列（下标都是从 <strong>1</strong>&nbsp;开始）的陆地会变成 <strong>水域</strong>&nbsp;（也就是 <code>0</code>&nbsp;变成 <code>1</code>&nbsp;）。</p>\n\n<p>你想知道从矩阵最 <strong>上面</strong>&nbsp;一行走到最 <strong>下面</strong>&nbsp;一行，且只经过陆地格子的 <strong>最后一天</strong>&nbsp;是哪一天。你可以从最上面一行的&nbsp;<strong>任意</strong>&nbsp;格子出发，到达最下面一行的&nbsp;<strong>任意</strong>&nbsp;格子。你只能沿着&nbsp;<strong>四个</strong>&nbsp;基本方向移动（也就是上下左右）。</p>\n\n<p>请返回只经过陆地格子能从最 <strong>上面</strong>&nbsp;一行走到最 <strong>下面</strong>&nbsp;一行的 <strong>最后一天</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/27/1.png\" style=\"width: 624px; height: 162px;\">\n<pre><b>输入：</b>row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]\n<b>输出：</b>2\n<b>解释：</b>上图描述了矩阵从第 0 天开始是如何变化的。\n可以从最上面一行到最下面一行的最后一天是第 2 天。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/27/2.png\" style=\"width: 504px; height: 178px;\">\n<pre><b>输入：</b>row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]]\n<b>输出：</b>1\n<b>解释：</b>上图描述了矩阵从第 0 天开始是如何变化的。\n可以从最上面一行到最下面一行的最后一天是第 1 天。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/27/3.png\" style=\"width: 666px; height: 167px;\">\n<pre><b>输入：</b>row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]\n<b>输出：</b>3\n<b>解释：</b>上图描述了矩阵从第 0 天开始是如何变化的。\n可以从最上面一行到最下面一行的最后一天是第 3 天。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= row, col &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>4 &lt;= row * col &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>cells.length == row * col</code></li>\n\t<li><code>1 &lt;= r<sub>i</sub> &lt;= row</code></li>\n\t<li><code>1 &lt;= c<sub>i</sub> &lt;= col</code></li>\n\t<li><code>cells</code>&nbsp;中的所有格子坐标都是 <strong>唯一</strong>&nbsp;的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1971.寻找图中是否存在路径",
        "hardRate": "EASY",
        "passRate": "54.10%",
        "problemsUrl": "https://leetcode.cn/problems/find-if-path-exists-in-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/find-if-path-exists-in-graph/solution",
        "problemsDesc": "<p>有一个具有 <code>n</code> 个顶点的 <strong>双向</strong> 图，其中每个顶点标记从 <code>0</code> 到 <code>n - 1</code>（包含 <code>0</code> 和 <code>n - 1</code>）。图中的边用一个二维整数数组 <code>edges</code> 表示，其中 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> 表示顶点 <code>ui</code> 和顶点 <code>vi</code> 之间的双向边。 每个顶点对由 <strong>最多一条</strong> 边连接，并且没有顶点存在与自身相连的边。</p>\n\n<p>请你确定是否存在从顶点 <code>source</code> 开始，到顶点 <code>destination</code> 结束的 <strong>有效路径</strong> 。</p>\n\n<p>给你数组 <code>edges</code> 和整数 <code>n</code>、<code>source</code> 和 <code>destination</code>，如果从 <code>source</code> 到 <code>destination</code> 存在 <strong>有效路径</strong> ，则返回 <code>true</code>，否则返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/14/validpath-ex1.png\" style=\"width: 141px; height: 121px;\" />\n<pre>\n<strong>输入：</strong>n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>存在由顶点 0 到顶点 2 的路径:\n- 0 → 1 → 2 \n- 0 → 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/14/validpath-ex2.png\" style=\"width: 281px; height: 141px;\" />\n<pre>\n<strong>输入：</strong>n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5\n<strong>输出：</strong>false\n<strong>解释：</strong>不存在由顶点 0 到顶点 5 的路径.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= edges.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n\t<li><code>0 &lt;= source, destination &lt;= n - 1</code></li>\n\t<li>不存在重复边</li>\n\t<li>不存在指向顶点自身的边</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1972.同一天的第一个电话和最后一个电话",
        "hardRate": "HARD",
        "passRate": "42.50%",
        "problemsUrl": "https://leetcode.cn/problems/first-and-last-call-on-the-same-day/",
        "solutionsUrl": "https://leetcode.cn/problems/first-and-last-call-on-the-same-day/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1973.值等于子节点值之和的节点数量",
        "hardRate": "MEDIUM",
        "passRate": "60.16%",
        "problemsUrl": "https://leetcode.cn/problems/count-nodes-equal-to-sum-of-descendants/",
        "solutionsUrl": "https://leetcode.cn/problems/count-nodes-equal-to-sum-of-descendants/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1974.使用特殊打字机键入单词的最少时间",
        "hardRate": "EASY",
        "passRate": "71.36%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-type-word-using-special-typewriter/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-type-word-using-special-typewriter/solution",
        "problemsDesc": "<p>有一个特殊打字机，它由一个 <strong>圆盘</strong> 和一个 <strong>指针</strong>&nbsp;组成， 圆盘上标有小写英文字母&nbsp;<code>'a'</code> 到&nbsp;<code>'z'</code>。<strong>只有</strong>&nbsp;当指针指向某个字母时，它才能被键入。指针 <strong>初始时</strong>&nbsp;指向字符 <code>'a'</code>&nbsp;。</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/31/chart.jpg\" style=\"width: 530px; height: 410px;\" />\n<p>每一秒钟，你可以执行以下操作之一：</p>\n\n<ul>\n\t<li>将指针 <strong>顺时针</strong>&nbsp;或者 <b>逆时针</b>&nbsp;移动一个字符。</li>\n\t<li>键入指针 <strong>当前</strong>&nbsp;指向的字符。</li>\n</ul>\n\n<p>给你一个字符串&nbsp;<code>word</code>&nbsp;，请你返回键入&nbsp;<code>word</code>&nbsp;所表示单词的 <b>最少</b>&nbsp;秒数&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>word = \"abc\"\n<b>输出：</b>5\n<strong>解释：\n</strong>单词按如下操作键入：\n- 花 1 秒键入字符 'a' in 1 ，因为指针初始指向 'a' ，故不需移动指针。\n- 花 1 秒将指针顺时针移到 'b' 。\n- 花 1 秒键入字符 'b' 。\n- 花 1 秒将指针顺时针移到 'c' 。\n- 花 1 秒键入字符 'c' 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>word = \"bza\"\n<b>输出：</b>7\n<strong>解释：\n</strong>单词按如下操作键入：\n- 花 1 秒将指针顺时针移到 'b' 。\n- 花 1 秒键入字符 'b' 。\n- 花 2 秒将指针逆时针移到 'z' 。\n- 花 1 秒键入字符 'z' 。\n- 花 1 秒将指针顺时针移到 'a' 。\n- 花 1 秒键入字符 'a' 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>word = \"zjpc\"\n<b>输出：</b>34\n<strong>解释：</strong>\n单词按如下操作键入：\n- 花 1 秒将指针逆时针移到 'z' 。\n- 花 1 秒键入字符 'z' 。\n- 花 10 秒将指针顺时针移到 'j' 。\n- 花 1 秒键入字符 'j' 。\n- 花 6 秒将指针顺时针移到 'p' 。\n- 花 1 秒键入字符 'p' 。\n- 花 13 秒将指针逆时针移到 'c' 。\n- 花 1 秒键入字符 'c' 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 100</code></li>\n\t<li><code>word</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1975.最大方阵和",
        "hardRate": "MEDIUM",
        "passRate": "41.60%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-matrix-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-matrix-sum/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>n x n</code>&nbsp;的整数方阵&nbsp;<code>matrix</code>&nbsp;。你可以执行以下操作&nbsp;<strong>任意次</strong>&nbsp;：</p>\n\n<ul>\n\t<li>选择&nbsp;<code>matrix</code>&nbsp;中&nbsp;<strong>相邻</strong>&nbsp;两个元素，并将它们都 <strong>乘以</strong>&nbsp;<code>-1</code>&nbsp;。</li>\n</ul>\n\n<p>如果两个元素有 <strong>公共边</strong>&nbsp;，那么它们就是 <strong>相邻</strong>&nbsp;的。</p>\n\n<p>你的目的是 <strong>最大化</strong>&nbsp;方阵元素的和。请你在执行以上操作之后，返回方阵的&nbsp;<strong>最大</strong>&nbsp;和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/16/pc79-q2ex1.png\" style=\"width: 401px; height: 81px;\">\n<pre><b>输入：</b>matrix = [[1,-1],[-1,1]]\n<b>输出：</b>4\n<b>解释：</b>我们可以执行以下操作使和等于 4 ：\n- 将第一行的 2 个元素乘以 -1 。\n- 将第一列的 2 个元素乘以 -1 。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/16/pc79-q2ex2.png\" style=\"width: 321px; height: 121px;\">\n<pre><b>输入：</b>matrix = [[1,2,3],[-1,-2,-3],[1,2,3]]\n<b>输出：</b>16\n<b>解释：</b>我们可以执行以下操作使和等于 16 ：\n- 将第二行的最后 2 个元素乘以 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == matrix.length == matrix[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 250</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= matrix[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1976.到达目的地的方案数",
        "hardRate": "MEDIUM",
        "passRate": "36.45%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/solution",
        "problemsDesc": "<p>你在一个城市里，城市由 <code>n</code>&nbsp;个路口组成，路口编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，某些路口之间有 <strong>双向</strong>&nbsp;道路。输入保证你可以从任意路口出发到达其他任意路口，且任意两个路口之间最多有一条路。</p>\n\n<p>给你一个整数&nbsp;<code>n</code>&nbsp;和二维整数数组&nbsp;<code>roads</code>&nbsp;，其中&nbsp;<code>roads[i] = [u<sub>i</sub>, v<sub>i</sub>, time<sub>i</sub>]</code>&nbsp;表示在路口&nbsp;<code>u<sub>i</sub></code>&nbsp;和&nbsp;<code>v<sub>i</sub></code>&nbsp;之间有一条需要花费&nbsp;<code>time<sub>i</sub></code>&nbsp;时间才能通过的道路。你想知道花费 <strong>最少时间</strong>&nbsp;从路口&nbsp;<code>0</code>&nbsp;出发到达路口&nbsp;<code>n - 1</code>&nbsp;的方案数。</p>\n\n<p>请返回花费 <strong>最少时间</strong>&nbsp;到达目的地的 <strong>路径数目</strong>&nbsp;。由于答案可能很大，将结果对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/17/graph2.png\" style=\"width: 235px; height: 381px;\">\n<pre><b>输入：</b>n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]\n<b>输出：</b>4\n<b>解释：</b>从路口 0 出发到路口 6 花费的最少时间是 7 分钟。\n四条花费 7 分钟的路径分别为：\n- 0 ➝ 6\n- 0 ➝ 4 ➝ 6\n- 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6\n- 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 2, roads = [[1,0,10]]\n<b>输出：</b>1\n<b>解释：</b>只有一条从路口 0 到路口 1 的路，花费 10 分钟。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>n - 1 &lt;= roads.length &lt;= n * (n - 1) / 2</code></li>\n\t<li><code>roads[i].length == 3</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>u<sub>i </sub>!= v<sub>i</sub></code></li>\n\t<li>任意两个路口之间至多有一条路。</li>\n\t<li>从任意路口出发，你能够到达其他任意路口。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1977.划分数字的方案数",
        "hardRate": "HARD",
        "passRate": "30.18%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-separate-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-separate-numbers/solution",
        "problemsDesc": "<p>你写下了若干 <strong>正整数</strong>&nbsp;，并将它们连接成了一个字符串&nbsp;<code>num</code>&nbsp;。但是你忘记给这些数字之间加逗号了。你只记得这一列数字是 <strong>非递减</strong>&nbsp;的且&nbsp;<strong>没有</strong> 任何数字有前导 0 。</p>\n\n<p>请你返回有多少种可能的 <strong>正整数数组</strong>&nbsp;可以得到字符串&nbsp;<code>num</code>&nbsp;。由于答案可能很大，将结果对 <code>10<sup>9</sup> + 7</code>&nbsp;<b>取余</b>&nbsp;后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>num = \"327\"\n<b>输出：</b>2\n<b>解释：</b>以下为可能的方案：\n3, 27\n327\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>num = \"094\"\n<b>输出：</b>0\n<b>解释：</b>不能有数字有前导 0 ，且所有数字均为正数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>num = \"0\"\n<b>输出：</b>0\n<strong>解释：</strong>不能有数字有前导 0 ，且所有数字均为正数。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>num = \"9999999999999\"\n<b>输出：</b>101\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 3500</code></li>\n\t<li><code>num</code>&nbsp;只含有数字&nbsp;<code>'0'</code> 到&nbsp;<code>'9'</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1978.上级经理已离职的公司员工",
        "hardRate": "EASY",
        "passRate": "49.98%",
        "problemsUrl": "https://leetcode.cn/problems/employees-whose-manager-left-the-company/",
        "solutionsUrl": "https://leetcode.cn/problems/employees-whose-manager-left-the-company/solution",
        "problemsDesc": "<p>表: <code>Employees</code></p>\n\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| employee_id | int      |\n| name        | varchar  |\n| manager_id  | int      |\n| salary      | int      |\n+-------------+----------+\nemployee_id 是这个表的主键。\n这个表包含了员工，他们的薪水和上级经理的id。\n有一些员工没有上级经理（其manager_id 是空值）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一个查询语句，查询出，这些员工的id，他们的薪水严格少于<code>$30000</code>&nbsp;并且他们的上级经理已离职。当一个经理离开公司时，他们的信息需要从员工表中删除掉，但是表中的员工的<code>manager_id</code> &nbsp;这一列还是设置的离职经理的id&nbsp;。</p>\n\n<p>返回的结果按照<code>employee_id&nbsp;</code>从小到大排序。</p>\n\n<p>查询结果如下所示：</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nEmployees table:\n+-------------+-----------+------------+--------+\n| employee_id | name      | manager_id | salary |\n+-------------+-----------+------------+--------+\n| 3           | Mila      | 9          | 60301  |\n| 12          | Antonella | null       | 31000  |\n| 13          | Emery     | null       | 67084  |\n| 1           | Kalel     | 11         | 21241  |\n| 9           | Mikaela   | null       | 50937  |\n| 11          | Joziah    | 6          | 28485  |\n+-------------+-----------+------------+--------+\n<strong>输出：</strong>\n+-------------+\n| employee_id |\n+-------------+\n| 11          |\n+-------------+\n\n<strong>解释：</strong>\n薪水少于30000美元的员工有1号(Kalel) and 11号 (Joziah)。\nKalel的上级经理是11号员工，他还在公司上班(他是Joziah)。\nJoziah的上级经理是6号员工，他已经离职，因为员工表里面已经没有6号员工的信息了，它被删除了。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1979.找出数组的最大公约数",
        "hardRate": "EASY",
        "passRate": "77.08%",
        "problemsUrl": "https://leetcode.cn/problems/find-greatest-common-divisor-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-greatest-common-divisor-of-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，返回数组中最大数和最小数的 <strong>最大公约数</strong> 。</p>\n\n<p>两个数的&nbsp;<strong>最大公约数</strong> 是能够被两个数整除的最大正整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,5,6,9,10]\n<strong>输出：</strong>2\n<strong>解释：</strong>\nnums 中最小的数是 2\nnums 中最大的数是 10\n2 和 10 的最大公约数是 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [7,5,6,8,3]\n<strong>输出：</strong>1\n<strong>解释：</strong>\nnums 中最小的数是 3\nnums 中最大的数是 8\n3 和 8 的最大公约数是 1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>\nnums 中最小的数是 3\nnums 中最大的数是 3\n3 和 3 的最大公约数是 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1980.找出不同的二进制字符串",
        "hardRate": "MEDIUM",
        "passRate": "59.79%",
        "problemsUrl": "https://leetcode.cn/problems/find-unique-binary-string/",
        "solutionsUrl": "https://leetcode.cn/problems/find-unique-binary-string/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>nums</code> ，该数组由 <code>n</code> 个 <strong>互不相同</strong> 的二进制字符串组成，且每个字符串长度都是 <code>n</code> 。请你找出并返回一个长度为&nbsp;<code>n</code>&nbsp;且&nbsp;<strong>没有出现</strong> 在 <code>nums</code> 中的二进制字符串<em>。</em>如果存在多种答案，只需返回 <strong>任意一个</strong> 即可。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [\"01\",\"10\"]\n<strong>输出：</strong>\"11\"\n<strong>解释：</strong>\"11\" 没有出现在 nums 中。\"00\" 也是正确答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [\"00\",\"01\"]\n<strong>输出：</strong>\"11\"\n<strong>解释：</strong>\"11\" 没有出现在 nums 中。\"10\" 也是正确答案。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [\"111\",\"011\",\"001\"]\n<strong>输出：</strong>\"101\"\n<strong>解释：</strong>\"101\" 没有出现在 nums 中。\"000\"、\"010\"、\"100\"、\"110\" 也是正确答案。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 16</code></li>\n\t<li><code>nums[i].length == n</code></li>\n\t<li><code>nums[i] </code>为 <code>'0'</code> 或 <code>'1'</code></li>\n\t<li><code>nums</code> 中的所有字符串 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1981.最小化目标值与所选元素的差",
        "hardRate": "MEDIUM",
        "passRate": "33.19%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-the-difference-between-target-and-chosen-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-the-difference-between-target-and-chosen-elements/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的整数矩阵 <code>mat</code> 和一个整数 <code>target</code> 。</p>\n\n<p>从矩阵的 <strong>每一行</strong> 中选择一个整数，你的目标是&nbsp;<strong>最小化</strong>&nbsp;所有选中元素之&nbsp;<strong>和</strong>&nbsp;与目标值 <code>target</code> 的 <strong>绝对差</strong> 。</p>\n\n<p>返回 <strong>最小的绝对差</strong> 。</p>\n\n<p><code>a</code> 和 <code>b</code> 两数字的 <strong>绝对差</strong> 是 <code>a - b</code> 的绝对值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/03/matrix1.png\" style=\"width: 181px; height: 181px;\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1,2,3],[4,5,6],[7,8,9]], target = 13\n<strong>输出：</strong>0\n<strong>解释：</strong>一种可能的最优选择方案是：\n- 第一行选出 1\n- 第二行选出 5\n- 第三行选出 7\n所选元素的和是 13 ，等于目标值，所以绝对差是 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/03/matrix1-1.png\" style=\"width: 61px; height: 181px;\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1],[2],[3]], target = 100\n<strong>输出：</strong>94\n<strong>解释：</strong>唯一一种选择方案是：\n- 第一行选出 1\n- 第二行选出 2\n- 第三行选出 3\n所选元素的和是 6 ，绝对差是 94 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/03/matrix1-3.png\" style=\"width: 301px; height: 61px;\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1,2,9,8,7]], target = 6\n<strong>输出：</strong>1\n<strong>解释：</strong>最优的选择方案是选出第一行的 7 。\n绝对差是 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 70</code></li>\n\t<li><code>1 &lt;= mat[i][j] &lt;= 70</code></li>\n\t<li><code>1 &lt;= target &lt;= 800</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1982.从子集的和还原数组",
        "hardRate": "HARD",
        "passRate": "48.18%",
        "problemsUrl": "https://leetcode.cn/problems/find-array-given-subset-sums/",
        "solutionsUrl": "https://leetcode.cn/problems/find-array-given-subset-sums/solution",
        "problemsDesc": "<p>存在一个未知数组需要你进行还原，给你一个整数 <code>n</code> 表示该数组的长度。另给你一个数组 <code>sums</code> ，由未知数组中全部 <code>2<sup>n</sup></code> 个 <strong>子集的和</strong> 组成（子集中的元素没有特定的顺序）。</p>\n\n<p>返回一个长度为 <code>n</code> 的数组<em> </em><code>ans</code><em> </em>表示还原得到的未知数组。如果存在 <strong>多种</strong> 答案，只需返回其中 <strong>任意一个</strong> 。</p>\n\n<p>如果可以由数组 <code>arr</code> 删除部分元素（也可能不删除或全删除）得到数组 <code>sub</code> ，那么数组 <code>sub</code> 就是数组 <code>arr</code> 的一个<strong> 子集</strong> 。<code>sub</code> 的元素之和就是 <code>arr</code> 的一个 <strong>子集的和</strong> 。一个空数组的元素之和为 <code>0</code> 。</p>\n\n<p><strong>注意：</strong>生成的测试用例将保证至少存在一个正确答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, sums = [-3,-2,-1,0,0,1,2,3]\n<strong>输出：</strong>[1,2,-3]\n<strong>解释：</strong>[1,2,-3] 能够满足给出的子集的和：\n- []：和是 0\n- [1]：和是 1\n- [2]：和是 2\n- [1,2]：和是 3\n- [-3]：和是 -3\n- [1,-3]：和是 -2\n- [2,-3]：和是 -1\n- [1,2,-3]：和是 0\n注意，[1,2,-3] 的任何排列和 [-1,-2,3] 的任何排列都会被视作正确答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, sums = [0,0,0,0]\n<strong>输出：</strong>[0,0]\n<strong>解释：</strong>唯一的正确答案是 [0,0] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, sums = [0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8]\n<strong>输出：</strong>[0,-1,4,5]\n<strong>解释：</strong>[0,-1,4,5] 能够满足给出的子集的和。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 15</code></li>\n\t<li><code>sums.length == 2<sup>n</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= sums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1983.范围和相等的最宽索引对",
        "hardRate": "MEDIUM",
        "passRate": "47.80%",
        "problemsUrl": "https://leetcode.cn/problems/widest-pair-of-indices-with-equal-range-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/widest-pair-of-indices-with-equal-range-sum/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1984.学生分数的最小差值",
        "hardRate": "EASY",
        "passRate": "61.83%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-difference-between-highest-and-lowest-of-k-scores/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-difference-between-highest-and-lowest-of-k-scores/solution",
        "problemsDesc": "<p>给你一个 <strong>下标从 0 开始</strong> 的整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 表示第 <code>i</code> 名学生的分数。另给你一个整数 <code>k</code> 。</p>\n\n<p>从数组中选出任意 <code>k</code> 名学生的分数，使这 <code>k</code> 个分数间 <strong>最高分</strong> 和 <strong>最低分</strong> 的 <strong>差值</strong> 达到<strong> 最小化</strong> 。</p>\n\n<p>返回可能的 <strong>最小差值</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [90], k = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>选出 1 名学生的分数，仅有 1 种方法：\n- [<em><strong>90</strong></em>] 最高分和最低分之间的差值是 90 - 90 = 0\n可能的最小差值是 0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [9,4,1,7], k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>选出 2 名学生的分数，有 6 种方法：\n- [<em><strong>9</strong></em>,<em><strong>4</strong></em>,1,7] 最高分和最低分之间的差值是 9 - 4 = 5\n- [<em><strong>9</strong></em>,4,<em><strong>1</strong></em>,7] 最高分和最低分之间的差值是 9 - 1 = 8\n- [<em><strong>9</strong></em>,4,1,<em><strong>7</strong></em>] 最高分和最低分之间的差值是 9 - 7 = 2\n- [9,<em><strong>4</strong></em>,<em><strong>1</strong></em>,7] 最高分和最低分之间的差值是 4 - 1 = 3\n- [9,<em><strong>4</strong></em>,1,<em><strong>7</strong></em>] 最高分和最低分之间的差值是 7 - 4 = 3\n- [9,4,<em><strong>1</strong></em>,<em><strong>7</strong></em>] 最高分和最低分之间的差值是 7 - 1 = 6\n可能的最小差值是 2</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1985.找出数组中的第 K 大整数",
        "hardRate": "MEDIUM",
        "passRate": "42.09%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-kth-largest-integer-in-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-kth-largest-integer-in-the-array/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>nums</code> 和一个整数 <code>k</code> 。<code>nums</code> 中的每个字符串都表示一个不含前导零的整数。</p>\n\n<p>返回 <code>nums</code> 中表示第 <code>k</code> 大整数的字符串。</p>\n\n<p><strong>注意：</strong>重复的数字在统计时会视为不同元素考虑。例如，如果 <code>nums</code> 是 <code>[\"1\",\"2\",\"2\"]</code>，那么 <code>\"2\"</code> 是最大的整数，<code>\"2\"</code> 是第二大的整数，<code>\"1\"</code> 是第三大的整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [\"3\",\"6\",\"7\",\"10\"], k = 4\n<strong>输出：</strong>\"3\"\n<strong>解释：</strong>\nnums 中的数字按非递减顺序排列为 [\"3\",\"6\",\"7\",\"10\"]\n其中第 4 大整数是 \"3\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [\"2\",\"21\",\"12\",\"1\"], k = 3\n<strong>输出：</strong>\"2\"\n<strong>解释：</strong>\nnums 中的数字按非递减顺序排列为 [\"1\",\"2\",\"12\",\"21\"]\n其中第 3 大整数是 \"2\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [\"0\",\"0\"], k = 2\n<strong>输出：</strong>\"0\"\n<strong>解释：</strong>\nnums 中的数字按非递减顺序排列为 [\"0\",\"0\"]\n其中第 2 大整数是 \"0\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i].length &lt;= 100</code></li>\n\t<li><code>nums[i]</code> 仅由数字组成</li>\n\t<li><code>nums[i]</code> 不含任何前导零</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1986.完成任务的最少工作时间段",
        "hardRate": "MEDIUM",
        "passRate": "33.08%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-work-sessions-to-finish-the-tasks/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-work-sessions-to-finish-the-tasks/solution",
        "problemsDesc": "<p>你被安排了 <code>n</code>&nbsp;个任务。任务需要花费的时间用长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>tasks</code>&nbsp;表示，第 <code>i</code>&nbsp;个任务需要花费&nbsp;<code>tasks[i]</code>&nbsp;小时完成。一个 <strong>工作时间段</strong>&nbsp;中，你可以 <strong>至多</strong>&nbsp;连续工作&nbsp;<code>sessionTime</code>&nbsp;个小时，然后休息一会儿。</p>\n\n<p>你需要按照如下条件完成给定任务：</p>\n\n<ul>\n\t<li>如果你在某一个时间段开始一个任务，你需要在 <strong>同一个</strong>&nbsp;时间段完成它。</li>\n\t<li>完成一个任务后，你可以 <strong>立马</strong>&nbsp;开始一个新的任务。</li>\n\t<li>你可以按 <strong>任意顺序</strong>&nbsp;完成任务。</li>\n</ul>\n\n<p>给你&nbsp;<code>tasks</code> 和&nbsp;<code>sessionTime</code>&nbsp;，请你按照上述要求，返回完成所有任务所需要的&nbsp;<strong>最少</strong>&nbsp;数目的&nbsp;<strong>工作时间段</strong>&nbsp;。</p>\n\n<p>测试数据保证&nbsp;<code>sessionTime</code> <strong>大于等于</strong>&nbsp;<code>tasks[i]</code>&nbsp;中的&nbsp;<strong>最大值</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>tasks = [1,2,3], sessionTime = 3\n<b>输出：</b>2\n<b>解释：</b>你可以在两个工作时间段内完成所有任务。\n- 第一个工作时间段：完成第一和第二个任务，花费 1 + 2 = 3 小时。\n- 第二个工作时间段：完成第三个任务，花费 3 小时。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>tasks = [3,1,3,1,1], sessionTime = 8\n<b>输出：</b>2\n<b>解释：</b>你可以在两个工作时间段内完成所有任务。\n- 第一个工作时间段：完成除了最后一个任务以外的所有任务，花费 3 + 1 + 3 + 1 = 8 小时。\n- 第二个工作时间段，完成最后一个任务，花费 1 小时。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>tasks = [1,2,3,4,5], sessionTime = 15\n<b>输出：</b>1\n<b>解释：</b>你可以在一个工作时间段以内完成所有任务。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == tasks.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 14</code></li>\n\t<li><code>1 &lt;= tasks[i] &lt;= 10</code></li>\n\t<li><code>max(tasks[i]) &lt;= sessionTime &lt;= 15</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1987.不同的好子序列数目",
        "hardRate": "HARD",
        "passRate": "50.42%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-unique-good-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-unique-good-subsequences/solution",
        "problemsDesc": "<p>给你一个二进制字符串&nbsp;<code>binary</code>&nbsp;。&nbsp;<code>binary</code>&nbsp;的一个 <strong>子序列</strong>&nbsp;如果是 <strong>非空</strong>&nbsp;的且没有 <b>前导</b>&nbsp;<strong>0</strong>&nbsp;（除非数字是 <code>\"0\"</code>&nbsp;本身），那么它就是一个 <strong>好</strong>&nbsp;的子序列。</p>\n\n<p>请你找到&nbsp;<code>binary</code>&nbsp;<strong>不同好子序列</strong>&nbsp;的数目。</p>\n\n<ul>\n\t<li>比方说，如果&nbsp;<code>binary = \"001\"</code>&nbsp;，那么所有 <strong>好</strong>&nbsp;子序列为&nbsp;<code>[\"0\", \"0\", \"1\"]</code>&nbsp;，所以 <b>不同</b>&nbsp;的好子序列为&nbsp;<code>\"0\"</code> 和&nbsp;<code>\"1\"</code>&nbsp;。 注意，子序列&nbsp;<code>\"00\"</code>&nbsp;，<code>\"01\"</code>&nbsp;和&nbsp;<code>\"001\"</code>&nbsp;不是好的，因为它们有前导 0 。</li>\n</ul>\n\n<p>请你返回&nbsp;<code>binary</code>&nbsp;中&nbsp;<strong>不同好子序列</strong>&nbsp;的数目。由于答案可能很大，请将它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong> 后返回。</p>\n\n<p>一个 <strong>子序列</strong>&nbsp;指的是从原数组中删除若干个（可以一个也不删除）元素后，不改变剩余元素顺序得到的序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>binary = \"001\"\n<b>输出：</b>2\n<b>解释：</b>好的二进制子序列为 [\"0\", \"0\", \"1\"] 。\n不同的好子序列为 \"0\" 和 \"1\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>binary = \"11\"\n<b>输出：</b>2\n<b>解释：</b>好的二进制子序列为 [\"1\", \"1\", \"11\"] 。\n不同的好子序列为 \"1\" 和 \"11\" 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>binary = \"101\"\n<b>输出：</b>5\n<b>解释：</b>好的二进制子序列为 [\"1\", \"0\", \"1\", \"10\", \"11\", \"101\"] 。\n不同的好子序列为 \"0\" ，\"1\" ，\"10\" ，\"11\" 和 \"101\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= binary.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>binary</code>&nbsp;只含有&nbsp;<code>'0'</code>&nbsp;和&nbsp;<code>'1'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1988.找出每所学校的最低分数要求",
        "hardRate": "MEDIUM",
        "passRate": "64.55%",
        "problemsUrl": "https://leetcode.cn/problems/find-cutoff-score-for-each-school/",
        "solutionsUrl": "https://leetcode.cn/problems/find-cutoff-score-for-each-school/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1989.捉迷藏中可捕获的最大人数",
        "hardRate": "MEDIUM",
        "passRate": "55.42%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-people-that-can-be-caught-in-tag/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-people-that-can-be-caught-in-tag/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1990.统计实验的数量",
        "hardRate": "MEDIUM",
        "passRate": "47.02%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-experiments/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-experiments/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1991.找到数组的中间位置",
        "hardRate": "EASY",
        "passRate": "63.89%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-middle-index-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-middle-index-in-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，请你找到 <strong>最左边</strong>&nbsp;的中间位置&nbsp;<code>middleIndex</code>&nbsp;（也就是所有可能中间位置下标最小的一个）。</p>\n\n<p>中间位置&nbsp;<code>middleIndex</code>&nbsp;是满足&nbsp;<code>nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1]</code>&nbsp;的数组下标。</p>\n\n<p>如果&nbsp;<code>middleIndex == 0</code>&nbsp;，左边部分的和定义为 <code>0</code>&nbsp;。类似的，如果&nbsp;<code>middleIndex == nums.length - 1</code>&nbsp;，右边部分的和定义为&nbsp;<code>0</code>&nbsp;。</p>\n\n<p>请你返回满足上述条件 <strong>最左边</strong>&nbsp;的<em>&nbsp;</em><code>middleIndex</code>&nbsp;，如果不存在这样的中间位置，请你返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,3,-1,<em><strong>8</strong></em>,4]\n<b>输出：</b>3\n<strong>解释：</strong>\n下标 3 之前的数字和为：2 + 3 + -1 = 4\n下标 3 之后的数字和为：4 = 4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,-1,<em><strong>4</strong></em>]\n<b>输出：</b>2\n<strong>解释：</strong>\n下标 2 之前的数字和为：1 + -1 = 0\n下标 2 之后的数字和为：0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,5]\n<b>输出：</b>-1\n<b>解释：</b>\n不存在符合要求的 middleIndex 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [<em><strong>1</strong></em>]\n<b>输出：</b>0\n<strong>解释：</strong>\n下标 0 之前的数字和为：0\n下标 0 之后的数字和为：0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与主站 724 题相同：<a href=\"https://leetcode-cn.com/problems/find-pivot-index/\" target=\"_blank\">https://leetcode-cn.com/problems/find-pivot-index/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1992.找到所有的农场组",
        "hardRate": "MEDIUM",
        "passRate": "61.16%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-groups-of-farmland/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-groups-of-farmland/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始，大小为&nbsp;<code>m x n</code>&nbsp;的二进制矩阵&nbsp;<code>land</code>&nbsp;，其中 <code>0</code>&nbsp;表示一单位的森林土地，<code>1</code>&nbsp;表示一单位的农场土地。</p>\n\n<p>为了让农场保持有序，农场土地之间以矩形的 <strong>农场组</strong> 的形式存在。每一个农场组都 <strong>仅</strong>&nbsp;包含农场土地。且题目保证不会有两个农场组相邻，也就是说一个农场组中的任何一块土地都 <strong>不会</strong>&nbsp;与另一个农场组的任何一块土地在四个方向上相邻。</p>\n\n<p><code>land</code>&nbsp;可以用坐标系统表示，其中 <code>land</code>&nbsp;左上角坐标为&nbsp;<code>(0, 0)</code>&nbsp;，右下角坐标为&nbsp;<code>(m-1, n-1)</code>&nbsp;。请你找到所有 <b>农场组</b>&nbsp;最左上角和最右下角的坐标。一个左上角坐标为&nbsp;<code>(r<sub>1</sub>, c<sub>1</sub>)</code>&nbsp;且右下角坐标为&nbsp;<code>(r<sub>2</sub>, c<sub>2</sub>)</code>&nbsp;的 <strong>农场组</strong> 用长度为 4 的数组&nbsp;<code>[r<sub>1</sub>, c<sub>1</sub>, r<sub>2</sub>, c<sub>2</sub>]</code>&nbsp;表示。</p>\n\n<p>请你返回一个二维数组，它包含若干个长度为 4 的子数组，每个子数组表示 <code>land</code>&nbsp;中的一个 <strong>农场组</strong>&nbsp;。如果没有任何农场组，请你返回一个空数组。可以以 <strong>任意顺序</strong>&nbsp;返回所有农场组。</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/27/screenshot-2021-07-27-at-12-23-15-copy-of-diagram-drawio-diagrams-net.png\" style=\"width: 300px; height: 300px;\"></p>\n\n<pre><b>输入：</b>land = [[1,0,0],[0,1,1],[0,1,1]]\n<b>输出：</b>[[0,0,0,0],[1,1,2,2]]\n<strong>解释：</strong>\n第一个农场组的左上角为 land[0][0] ，右下角为 land[0][0] 。\n第二个农场组的左上角为 land[1][1] ，右下角为 land[2][2] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/27/screenshot-2021-07-27-at-12-30-26-copy-of-diagram-drawio-diagrams-net.png\" style=\"width: 200px; height: 200px;\"></p>\n\n<pre><b>输入：</b>land = [[1,1],[1,1]]\n<b>输出：</b>[[0,0,1,1]]\n<strong>解释：</strong>\n第一个农场组左上角为 land[0][0] ，右下角为 land[1][1] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/27/screenshot-2021-07-27-at-12-32-24-copy-of-diagram-drawio-diagrams-net.png\" style=\"width: 100px; height: 100px;\"></p>\n\n<pre><b>输入：</b>land = [[0]]\n<b>输出：</b>[]\n<b>解释：</b>\n没有任何农场组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == land.length</code></li>\n\t<li><code>n == land[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>land</code>&nbsp;只包含&nbsp;<code>0</code>&nbsp;和&nbsp;<code>1</code>&nbsp;。</li>\n\t<li>农场组都是 <strong>矩形</strong>&nbsp;的形状。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1993.树上的操作",
        "hardRate": "MEDIUM",
        "passRate": "39.82%",
        "problemsUrl": "https://leetcode.cn/problems/operations-on-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/operations-on-tree/solution",
        "problemsDesc": "<p>给你一棵&nbsp;<code>n</code>&nbsp;个节点的树，编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，以父节点数组&nbsp;<code>parent</code>&nbsp;的形式给出，其中&nbsp;<code>parent[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个节点的父节点。树的根节点为 <code>0</code>&nbsp;号节点，所以&nbsp;<code>parent[0] = -1</code>&nbsp;，因为它没有父节点。你想要设计一个数据结构实现树里面对节点的加锁，解锁和升级操作。</p>\n\n<p>数据结构需要支持如下函数：</p>\n\n<ul>\n\t<li><strong>Lock：</strong>指定用户给指定节点 <strong>上锁</strong>&nbsp;，上锁后其他用户将无法给同一节点上锁。只有当节点处于未上锁的状态下，才能进行上锁操作。</li>\n\t<li><strong>Unlock：</strong>指定用户给指定节点 <strong>解锁</strong>&nbsp;，只有当指定节点当前正被指定用户锁住时，才能执行该解锁操作。</li>\n\t<li><b>Upgrade：</b>指定用户给指定节点&nbsp;<strong>上锁</strong>&nbsp;，并且将该节点的所有子孙节点&nbsp;<strong>解锁</strong>&nbsp;。只有如下 3 个条件 <strong>全部</strong> 满足时才能执行升级操作：\n\t<ul>\n\t\t<li>指定节点当前状态为未上锁。</li>\n\t\t<li>指定节点至少有一个上锁状态的子孙节点（可以是 <strong>任意</strong>&nbsp;用户上锁的）。</li>\n\t\t<li>指定节点没有任何上锁的祖先节点。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你实现&nbsp;<code>LockingTree</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>LockingTree(int[] parent)</code>&nbsp;用父节点数组初始化数据结构。</li>\n\t<li><code>lock(int num, int user)</code> 如果&nbsp;id 为&nbsp;<code>user</code>&nbsp;的用户可以给节点&nbsp;<code>num</code>&nbsp;上锁，那么返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。如果可以执行此操作，节点&nbsp;<code>num</code>&nbsp;会被 id 为 <code>user</code>&nbsp;的用户 <strong>上锁</strong>&nbsp;。</li>\n\t<li><code>unlock(int num, int user)</code>&nbsp;如果 id 为 <code>user</code>&nbsp;的用户可以给节点 <code>num</code>&nbsp;解锁，那么返回&nbsp;<code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。如果可以执行此操作，节点 <code>num</code>&nbsp;变为 <strong>未上锁</strong>&nbsp;状态。</li>\n\t<li><code>upgrade(int num, int user)</code>&nbsp;如果 id 为 <code>user</code>&nbsp;的用户可以给节点 <code>num</code>&nbsp;升级，那么返回&nbsp;<code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。如果可以执行此操作，节点 <code>num</code>&nbsp;会被&nbsp;<strong>升级 </strong>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/29/untitled.png\" style=\"width: 375px; height: 246px;\"></p>\n\n<pre><strong>输入：</strong>\n[\"LockingTree\", \"lock\", \"unlock\", \"unlock\", \"lock\", \"upgrade\", \"lock\"]\n[[[-1, 0, 0, 1, 1, 2, 2]], [2, 2], [2, 3], [2, 2], [4, 5], [0, 1], [0, 1]]\n<strong>输出：</strong>\n[null, true, false, true, true, true, false]\n\n<strong>解释：</strong>\nLockingTree lockingTree = new LockingTree([-1, 0, 0, 1, 1, 2, 2]);\nlockingTree.lock(2, 2);    // 返回 true ，因为节点 2 未上锁。\n                           // 节点 2 被用户 2 上锁。\nlockingTree.unlock(2, 3);  // 返回 false ，因为用户 3 无法解锁被用户 2 上锁的节点。\nlockingTree.unlock(2, 2);  // 返回 true ，因为节点 2 之前被用户 2 上锁。\n                           // 节点 2 现在变为未上锁状态。\nlockingTree.lock(4, 5);    // 返回 true ，因为节点 4 未上锁。\n                           // 节点 4 被用户 5 上锁。\nlockingTree.upgrade(0, 1); // 返回 true ，因为节点 0 未上锁且至少有一个被上锁的子孙节点（节点 4）。\n                           // 节点 0 被用户 1 上锁，节点 4 变为未上锁。\nlockingTree.lock(0, 1);    // 返回 false ，因为节点 0 已经被上锁了。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == parent.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 2000</code></li>\n\t<li>对于&nbsp;<code>i != 0</code>&nbsp;，满足&nbsp;<code>0 &lt;= parent[i] &lt;= n - 1</code></li>\n\t<li><code>parent[0] == -1</code></li>\n\t<li><code>0 &lt;= num &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= user &lt;= 10<sup>4</sup></code></li>\n\t<li><code>parent</code>&nbsp;表示一棵合法的树。</li>\n\t<li><code>lock</code>&nbsp;，<code>unlock</code>&nbsp;和&nbsp;<code>upgrade</code>&nbsp;的调用&nbsp;<strong>总共&nbsp;</strong>不超过&nbsp;<code>2000</code>&nbsp;次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1994.好子集的数目",
        "hardRate": "HARD",
        "passRate": "56.13%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-good-subsets/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-good-subsets/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;。如果&nbsp;<code>nums</code>&nbsp;的一个子集中，所有元素的乘积可以表示为一个或多个 <strong>互不相同的质数</strong> 的乘积，那么我们称它为&nbsp;<strong>好子集</strong>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，如果&nbsp;<code>nums = [1, 2, 3, 4]</code>&nbsp;：\n\n\t<ul>\n\t\t<li><code>[2, 3]</code>&nbsp;，<code>[1, 2, 3]</code>&nbsp;和&nbsp;<code>[1, 3]</code>&nbsp;是 <strong>好</strong>&nbsp;子集，乘积分别为&nbsp;<code>6 = 2*3</code>&nbsp;，<code>6 = 2*3</code>&nbsp;和&nbsp;<code>3 = 3</code>&nbsp;。</li>\n\t\t<li><code>[1, 4]</code> 和&nbsp;<code>[4]</code>&nbsp;不是 <strong>好</strong>&nbsp;子集，因为乘积分别为&nbsp;<code>4 = 2*2</code> 和&nbsp;<code>4 = 2*2</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回 <code>nums</code>&nbsp;中不同的&nbsp;<strong>好</strong>&nbsp;子集的数目对<em>&nbsp;</em><code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;的结果。</p>\n\n<p><code>nums</code>&nbsp;中的 <strong>子集</strong>&nbsp;是通过删除 <code>nums</code>&nbsp;中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4]\n<b>输出：</b>6\n<b>解释：</b>好子集为：\n- [1,2]：乘积为 2 ，可以表示为质数 2 的乘积。\n- [1,2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。\n- [1,3]：乘积为 3 ，可以表示为质数 3 的乘积。\n- [2]：乘积为 2 ，可以表示为质数 2 的乘积。\n- [2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。\n- [3]：乘积为 3 ，可以表示为质数 3 的乘积。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [4,2,3,15]\n<b>输出：</b>5\n<b>解释：</b>好子集为：\n- [2]：乘积为 2 ，可以表示为质数 2 的乘积。\n- [2,3]：乘积为 6 ，可以表示为互不相同质数 2 和 3 的乘积。\n- [2,15]：乘积为 30 ，可以表示为互不相同质数 2，3 和 5 的乘积。\n- [3]：乘积为 3 ，可以表示为质数 3 的乘积。\n- [15]：乘积为 15 ，可以表示为互不相同质数 3 和 5 的乘积。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 30</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1995.统计特殊四元组",
        "hardRate": "EASY",
        "passRate": "66.28%",
        "problemsUrl": "https://leetcode.cn/problems/count-special-quadruplets/",
        "solutionsUrl": "https://leetcode.cn/problems/count-special-quadruplets/solution",
        "problemsDesc": "<p>给你一个 <strong>下标从 0 开始</strong> 的整数数组 <code>nums</code> ，返回满足下述条件的 <strong>不同</strong> 四元组 <code>(a, b, c, d)</code> 的 <strong>数目</strong> ：</p>\n\n<ul>\n\t<li><code>nums[a] + nums[b] + nums[c] == nums[d]</code> ，且</li>\n\t<li><code>a &lt; b &lt; c &lt; d</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,6]\n<strong>输出：</strong>1\n<strong>解释：</strong>满足要求的唯一一个四元组是 (0, 1, 2, 3) 因为 1 + 2 + 3 == 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,3,6,4,5]\n<strong>输出：</strong>0\n<strong>解释：</strong>[3,3,6,4,5] 中不存在满足要求的四元组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,1,3,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>满足要求的 4 个四元组如下：\n- (0, 1, 2, 3): 1 + 1 + 1 == 3\n- (0, 1, 3, 4): 1 + 1 + 3 == 5\n- (0, 2, 3, 4): 1 + 1 + 3 == 5\n- (1, 2, 3, 4): 1 + 1 + 3 == 5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>4 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1996.游戏中弱角色的数量",
        "hardRate": "MEDIUM",
        "passRate": "41.49%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-weak-characters-in-the-game/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-weak-characters-in-the-game/solution",
        "problemsDesc": "<p>你正在参加一个多角色游戏，每个角色都有两个主要属性：<strong>攻击</strong> 和 <strong>防御</strong> 。给你一个二维整数数组 <code>properties</code> ，其中 <code>properties[i] = [attack<sub>i</sub>, defense<sub>i</sub>]</code> 表示游戏中第 <code>i</code> 个角色的属性。</p>\n\n<p>如果存在一个其他角色的攻击和防御等级 <strong>都严格高于</strong> 该角色的攻击和防御等级，则认为该角色为 <strong>弱角色</strong> 。更正式地，如果认为角色 <code>i</code> <strong>弱于</strong> 存在的另一个角色 <code>j</code> ，那么 <code>attack<sub>j</sub> &gt; attack<sub>i</sub></code> 且 <code>defense<sub>j</sub> &gt; defense<sub>i</sub></code> 。</p>\n\n<p>返回 <strong>弱角色</strong> 的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>properties = [[5,5],[6,3],[3,6]]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在攻击和防御都严格高于其他角色的角色。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>properties = [[2,2],[3,3]]\n<strong>输出：</strong>1\n<strong>解释：</strong>第一个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>properties = [[1,5],[10,4],[4,3]]\n<strong>输出：</strong>1\n<strong>解释：</strong>第三个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= properties.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>properties[i].length == 2</code></li>\n\t<li><code>1 &lt;= attack<sub>i</sub>, defense<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1997.访问完所有房间的第一天",
        "hardRate": "MEDIUM",
        "passRate": "35.24%",
        "problemsUrl": "https://leetcode.cn/problems/first-day-where-you-have-been-in-all-the-rooms/",
        "solutionsUrl": "https://leetcode.cn/problems/first-day-where-you-have-been-in-all-the-rooms/solution",
        "problemsDesc": "<p>你需要访问&nbsp;<code>n</code> 个房间，房间从 <code>0</code> 到 <code>n - 1</code> 编号。同时，每一天都有一个日期编号，从 <code>0</code> 开始，依天数递增。你每天都会访问一个房间。</p>\n\n<p>最开始的第 <code>0</code> 天，你访问&nbsp;<code>0</code> 号房间。给你一个长度为 <code>n</code> 且 <strong>下标从 0 开始</strong> 的数组 <code>nextVisit</code> 。在接下来的几天中，你访问房间的 <strong>次序</strong> 将根据下面的 <strong>规则</strong> 决定：</p>\n\n<ul>\n\t<li>假设某一天，你访问&nbsp;<code>i</code> 号房间。</li>\n\t<li>如果算上本次访问，访问&nbsp;<code>i</code> 号房间的次数为 <strong>奇数</strong> ，那么 <strong>第二天</strong> 需要访问&nbsp;<code>nextVisit[i]</code> 所指定的房间，其中 <code>0 &lt;= nextVisit[i] &lt;= i</code> 。</li>\n\t<li>如果算上本次访问，访问&nbsp;<code>i</code> 号房间的次数为 <strong>偶数</strong> ，那么 <strong>第二天</strong> 需要访问&nbsp;<code>(i + 1) mod n</code> 号房间。</li>\n</ul>\n\n<p>请返回你访问完所有房间的第一天的日期编号。题目数据保证总是存在这样的一天。由于答案可能很大，返回对 <code>10<sup>9</sup> + 7</code> 取余后的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nextVisit = [0,0]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n- 第 0 天，你访问房间 0 。访问 0 号房间的总次数为 1 ，次数为奇数。\n&nbsp; 下一天你需要访问房间的编号是 nextVisit[0] = 0\n- 第 1 天，你访问房间 0 。访问 0 号房间的总次数为 2 ，次数为偶数。\n&nbsp; 下一天你需要访问房间的编号是 (0 + 1) mod 2 = 1\n- 第 2 天，你访问房间 1 。这是你第一次完成访问所有房间的那天。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nextVisit = [0,0,2]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n你每天访问房间的次序是 [0,0,1,0,0,1,2,...] 。\n第 6 天是你访问完所有房间的第一天。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nextVisit = [0,1,2,0]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n你每天访问房间的次序是 [0,0,1,1,2,2,3,...] 。\n第 6 天是你访问完所有房间的第一天。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nextVisit.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nextVisit[i] &lt;= i</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1998.数组的最大公因数排序",
        "hardRate": "HARD",
        "passRate": "45.84%",
        "problemsUrl": "https://leetcode.cn/problems/gcd-sort-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/gcd-sort-of-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，你可以在 <code>nums</code> 上执行下述操作 <strong>任意次</strong> ：</p>\n\n<ul>\n\t<li>如果 <code>gcd(nums[i], nums[j]) &gt; 1</code> ，交换 <code>nums[i]</code> 和 <code>nums[j]</code> 的位置。其中 <code>gcd(nums[i], nums[j])</code> 是&nbsp;<code>nums[i]</code> 和 <code>nums[j]</code> 的最大公因数。</li>\n</ul>\n\n<p>如果能使用上述交换方式将 <code>nums</code> 按 <strong>非递减顺序</strong> 排列，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [7,21,3]\n<strong>输出：</strong>true\n<strong>解释：</strong>可以执行下述操作完成对 [7,21,3] 的排序：\n- 交换 7 和 21 因为 gcd(7,21) = 7 。nums = [<em><strong>21</strong></em>,<em><strong>7</strong></em>,3]\n- 交换 21 和 3 因为 gcd(21,3) = 3 。nums = [<em><strong>3</strong></em>,7,<em><strong>21</strong></em>]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,2,6,2]\n<strong>输出：</strong>false\n<strong>解释：</strong>无法完成排序，因为 5 不能与其他元素交换。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [10,5,9,3,15]\n<strong>输出：</strong>true\n<strong>解释：</strong>\n可以执行下述操作完成对 [10,5,9,3,15] 的排序：\n- 交换 10 和 15 因为 gcd(10,15) = 5 。nums = [<em><strong>15</strong></em>,5,9,3,<em><strong>10</strong></em>]\n- 交换 15 和 3 因为 gcd(15,3) = 3 。nums = [<em><strong>3</strong></em>,5,9,<em><strong>15</strong></em>,10]\n- 交换 10 和 15 因为 gcd(10,15) = 5 。nums = [3,5,9,<em><strong>10</strong></em>,<em><strong>15</strong></em>]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>2 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1999.最小的仅由两个数组成的倍数",
        "hardRate": "MEDIUM",
        "passRate": "47.00%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-greater-multiple-made-of-two-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-greater-multiple-made-of-two-digits/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2000.反转单词前缀",
        "hardRate": "EASY",
        "passRate": "77.43%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-prefix-of-word/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-prefix-of-word/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>word</code> 和一个字符 <code>ch</code> 。找出 <code>ch</code> 第一次出现的下标 <code>i</code> ，<strong>反转 </strong><code>word</code> 中从下标 <code>0</code> 开始、直到下标 <code>i</code> 结束（含下标 <code>i</code> ）的那段字符。如果 <code>word</code> 中不存在字符 <code>ch</code> ，则无需进行任何操作。</p>\n\n<ul>\n\t<li>例如，如果 <code>word = \"abcdefd\"</code> 且 <code>ch = \"d\"</code> ，那么你应该 <strong>反转</strong> 从下标 0 开始、直到下标 <code>3</code> 结束（含下标 <code>3</code> ）。结果字符串将会是 <code>\"<em><strong>dcba</strong></em>efd\"</code> 。</li>\n</ul>\n\n<p>返回 <strong>结果字符串</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>word = \"<em><strong>abcd</strong></em>efd\", ch = \"d\"\n<strong>输出：</strong>\"<em><strong>dcba</strong></em>efd\"\n<strong>解释：</strong>\"d\" 第一次出现在下标 3 。 \n反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 \"dcbaefd\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>word = \"<em><strong>xyxz</strong></em>xe\", ch = \"z\"\n<strong>输出：</strong>\"<em><strong>zxyx</strong></em>xe\"\n<strong>解释：</strong>\"z\" 第一次也是唯一一次出现是在下标 3 。\n反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 \"zxyxxe\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>word = \"abcd\", ch = \"z\"\n<strong>输出：</strong>\"abcd\"\n<strong>解释：</strong>\"z\" 不存在于 word 中。\n无需执行反转操作，结果字符串是 \"abcd\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 250</code></li>\n\t<li><code>word</code> 由小写英文字母组成</li>\n\t<li><code>ch</code> 是一个小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2001.可互换矩形的组数",
        "hardRate": "MEDIUM",
        "passRate": "38.93%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-pairs-of-interchangeable-rectangles/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-pairs-of-interchangeable-rectangles/solution",
        "problemsDesc": "<p>用一个下标从 <strong>0</strong> 开始的二维整数数组&nbsp;<code>rectangles</code> 来表示 <code>n</code> 个矩形，其中 <code>rectangles[i] = [width<sub>i</sub>, height<sub>i</sub>]</code> 表示第 <code>i</code> 个矩形的宽度和高度。</p>\n\n<p>如果两个矩形 <code>i</code> 和 <code>j</code>（<code>i &lt; j</code>）的宽高比相同，则认为这两个矩形 <strong>可互换</strong> 。更规范的说法是，两个矩形满足&nbsp;<code>width<sub>i</sub>/height<sub>i</sub> == width<sub>j</sub>/height<sub>j</sub></code>（使用实数除法而非整数除法），则认为这两个矩形 <strong>可互换</strong> 。</p>\n\n<p>计算并返回&nbsp;<code>rectangles</code> 中有多少对 <strong>可互换 </strong>矩形。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rectangles = [[4,8],[3,6],[10,20],[15,30]]\n<strong>输出：</strong>6\n<strong>解释：</strong>下面按下标（从 0 开始）列出可互换矩形的配对情况：\n- 矩形 0 和矩形 1 ：4/8 == 3/6\n- 矩形 0 和矩形 2 ：4/8 == 10/20\n- 矩形 0 和矩形 3 ：4/8 == 15/30\n- 矩形 1 和矩形 2 ：3/6 == 10/20\n- 矩形 1 和矩形 3 ：3/6 == 15/30\n- 矩形 2 和矩形 3 ：10/20 == 15/30\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rectangles = [[4,5],[7,8]]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在成对的可互换矩形。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == rectangles.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>rectangles[i].length == 2</code></li>\n\t<li><code>1 &lt;= width<sub>i</sub>, height<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2002.两个回文子序列长度的最大乘积",
        "hardRate": "MEDIUM",
        "passRate": "60.36%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，请你找到&nbsp;<code>s</code>&nbsp;中两个&nbsp;<strong>不相交回文子序列</strong>&nbsp;，使得它们长度的&nbsp;<strong>乘积最大</strong>&nbsp;。两个子序列在原字符串中如果没有任何相同下标的字符，则它们是&nbsp;<strong>不相交</strong>&nbsp;的。</p>\n\n<p>请你返回两个回文子序列长度可以达到的<strong>&nbsp;最大乘积</strong>&nbsp;。</p>\n\n<p><strong>子序列</strong>&nbsp;指的是从原字符串中删除若干个字符（可以一个也不删除）后，剩余字符不改变顺序而得到的结果。如果一个字符串从前往后读和从后往前读一模一样，那么这个字符串是一个 <strong>回文字符串</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"example-1\" src=\"https://assets.leetcode.com/uploads/2021/08/24/two-palindromic-subsequences.png\" style=\"width: 550px; height: 124px;\"></p>\n\n<pre><b>输入：</b>s = \"leetcodecom\"\n<b>输出：</b>9\n<b>解释：</b>最优方案是选择 \"ete\" 作为第一个子序列，\"cdc\" 作为第二个子序列。\n它们的乘积为 3 * 3 = 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"bb\"\n<b>输出：</b>1\n<b>解释：</b>最优方案为选择 \"b\" （第一个字符）作为第一个子序列，\"b\" （第二个字符）作为第二个子序列。\n它们的乘积为 1 * 1 = 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>s = \"accbcaxxcxx\"\n<b>输出：</b>25\n<b>解释：</b>最优方案为选择 \"accca\" 作为第一个子序列，\"xxcxx\" 作为第二个子序列。\n它们的乘积为 5 * 5 = 25 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 12</code></li>\n\t<li><code>s</code>&nbsp;只含有小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2003.每棵子树内缺失的最小基因值",
        "hardRate": "HARD",
        "passRate": "43.01%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-missing-genetic-value-in-each-subtree/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-missing-genetic-value-in-each-subtree/solution",
        "problemsDesc": "<p>有一棵根节点为 <code>0</code>&nbsp;的 <strong>家族树</strong>&nbsp;，总共包含 <code>n</code>&nbsp;个节点，节点编号为 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;。给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组 <code>parents</code>&nbsp;，其中&nbsp;<code>parents[i]</code>&nbsp;是节点 <code>i</code>&nbsp;的父节点。由于节点 <code>0</code>&nbsp;是 <strong>根</strong>&nbsp;，所以&nbsp;<code>parents[0] == -1</code>&nbsp;。</p>\n\n<p>总共有&nbsp;<code>10<sup>5</sup></code>&nbsp;个基因值，每个基因值都用 <strong>闭区间</strong>&nbsp;<code>[1, 10<sup>5</sup>]</code>&nbsp;中的一个整数表示。给你一个下标从&nbsp;<strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，其中&nbsp;<code>nums[i]</code>&nbsp;是节点 <code>i</code>&nbsp;的基因值，且基因值 <strong>互不相同</strong>&nbsp;。</p>\n\n<p>请你返回一个数组<em>&nbsp;</em><code>ans</code>&nbsp;，长度为&nbsp;<code>n</code>&nbsp;，其中&nbsp;<code>ans[i]</code>&nbsp;是以节点&nbsp;<code>i</code>&nbsp;为根的子树内 <b>缺失</b>&nbsp;的&nbsp;<strong>最小</strong>&nbsp;基因值。</p>\n\n<p>节点 <code>x</code>&nbsp;为根的 <strong>子树&nbsp;</strong>包含节点 <code>x</code>&nbsp;和它所有的 <strong>后代</strong>&nbsp;节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/23/case-1.png\" style=\"width: 204px; height: 167px;\"></p>\n\n<pre><b>输入：</b>parents = [-1,0,0,2], nums = [1,2,3,4]\n<b>输出：</b>[5,1,1,1]\n<b>解释：</b>每个子树答案计算结果如下：\n- 0：子树包含节点 [0,1,2,3] ，基因值分别为 [1,2,3,4] 。5 是缺失的最小基因值。\n- 1：子树只包含节点 1 ，基因值为 2 。1 是缺失的最小基因值。\n- 2：子树包含节点 [2,3] ，基因值分别为 [3,4] 。1 是缺失的最小基因值。\n- 3：子树只包含节点 3 ，基因值为 4 。1是缺失的最小基因值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/23/case-2.png\" style=\"width: 247px; height: 168px;\"></p>\n\n<pre><b>输入：</b>parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3]\n<b>输出：</b>[7,1,1,4,2,1]\n<b>解释：</b>每个子树答案计算结果如下：\n- 0：子树内包含节点 [0,1,2,3,4,5] ，基因值分别为 [5,4,6,2,1,3] 。7 是缺失的最小基因值。\n- 1：子树内包含节点 [1,2] ，基因值分别为 [4,6] 。 1 是缺失的最小基因值。\n- 2：子树内只包含节点 2 ，基因值为 6 。1 是缺失的最小基因值。\n- 3：子树内包含节点 [3,4,5] ，基因值分别为 [2,1,3] 。4 是缺失的最小基因值。\n- 4：子树内只包含节点 4 ，基因值为 1 。2 是缺失的最小基因值。\n- 5：子树内只包含节点 5 ，基因值为 3 。1 是缺失的最小基因值。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8]\n<b>输出：</b>[1,1,1,1,1,1,1]\n<b>解释：</b>所有子树都缺失基因值 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == parents.length == nums.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li>对于&nbsp;<code>i != 0</code>&nbsp;，满足&nbsp;<code>0 &lt;= parents[i] &lt;= n - 1</code></li>\n\t<li><code>parents[0] == -1</code></li>\n\t<li><code>parents</code>&nbsp;表示一棵合法的树。</li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code>&nbsp;互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2004.职员招聘人数",
        "hardRate": "HARD",
        "passRate": "41.91%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-seniors-and-juniors-to-join-the-company/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-seniors-and-juniors-to-join-the-company/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2005.斐波那契树的移除子树游戏",
        "hardRate": "HARD",
        "passRate": "50.14%",
        "problemsUrl": "https://leetcode.cn/problems/subtree-removal-game-with-fibonacci-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/subtree-removal-game-with-fibonacci-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2006.差的绝对值为 K 的数对数目",
        "hardRate": "EASY",
        "passRate": "83.93%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-pairs-with-absolute-difference-k/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-pairs-with-absolute-difference-k/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;，请你返回数对&nbsp;<code>(i, j)</code>&nbsp;的数目，满足&nbsp;<code>i &lt; j</code>&nbsp;且&nbsp;<code>|nums[i] - nums[j]| == k</code>&nbsp;。</p>\n\n<p><code>|x|</code>&nbsp;的值定义为：</p>\n\n<ul>\n\t<li>如果&nbsp;<code>x &gt;= 0</code>&nbsp;，那么值为&nbsp;<code>x</code>&nbsp;。</li>\n\t<li>如果&nbsp;<code>x &lt; 0</code>&nbsp;，那么值为&nbsp;<code>-x</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,2,1], k = 1\n<b>输出：</b>4\n<b>解释：</b>差的绝对值为 1 的数对为：\n- [<em><strong>1</strong></em>,<em><strong>2</strong></em>,2,1]\n- [<em><strong>1</strong></em>,2,<em><strong>2</strong></em>,1]\n- [1,<em><strong>2</strong></em>,2,<em><strong>1</strong></em>]\n- [1,2,<em><strong>2</strong></em>,<em><strong>1</strong></em>]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,3], k = 3\n<b>输出：</b>0\n<b>解释：</b>没有任何数对差的绝对值为 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [3,2,1,5,4], k = 2\n<b>输出：</b>3\n<b>解释：</b>差的绝对值为 2 的数对为：\n- [<em><strong>3</strong></em>,2,<em><strong>1</strong></em>,5,4]\n- [<em><strong>3</strong></em>,2,1,<em><strong>5</strong></em>,4]\n- [3,<em><strong>2</strong></em>,1,5,<em><strong>4</strong></em>]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= k &lt;= 99</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2007.从双倍数组中还原原数组",
        "hardRate": "MEDIUM",
        "passRate": "33.52%",
        "problemsUrl": "https://leetcode.cn/problems/find-original-array-from-doubled-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-original-array-from-doubled-array/solution",
        "problemsDesc": "<p>一个整数数组&nbsp;<code>original</code>&nbsp;可以转变成一个 <strong>双倍</strong>&nbsp;数组&nbsp;<code>changed</code>&nbsp;，转变方式为将 <code>original</code>&nbsp;中每个元素 <strong>值乘以 2 </strong>加入数组中，然后将所有元素 <strong>随机打乱</strong>&nbsp;。</p>\n\n<p>给你一个数组&nbsp;<code>changed</code>&nbsp;，如果&nbsp;<code>change</code>&nbsp;是&nbsp;<strong>双倍</strong>&nbsp;数组，那么请你返回&nbsp;<code>original</code>数组，否则请返回空数组。<code>original</code>&nbsp;的元素可以以&nbsp;<strong>任意</strong>&nbsp;顺序返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>changed = [1,3,4,2,6,8]\n<b>输出：</b>[1,3,4]\n<b>解释：</b>一个可能的 original 数组为 [1,3,4] :\n- 将 1 乘以 2 ，得到 1 * 2 = 2 。\n- 将 3 乘以 2 ，得到 3 * 2 = 6 。\n- 将 4 乘以 2 ，得到 4 * 2 = 8 。\n其他可能的原数组方案为 [4,3,1] 或者 [3,1,4] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>changed = [6,3,0,1]\n<b>输出：</b>[]\n<b>解释：</b>changed 不是一个双倍数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>changed = [1]\n<b>输出：</b>[]\n<b>解释：</b>changed 不是一个双倍数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= changed.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= changed[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2008.出租车的最大盈利",
        "hardRate": "MEDIUM",
        "passRate": "46.03%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-earnings-from-taxi/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-earnings-from-taxi/solution",
        "problemsDesc": "<p>你驾驶出租车行驶在一条有 <code>n</code>&nbsp;个地点的路上。这 <code>n</code>&nbsp;个地点从近到远编号为&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;，你想要从 <code>1</code>&nbsp;开到 <code>n</code>&nbsp;，通过接乘客订单盈利。你只能沿着编号递增的方向前进，不能改变方向。</p>\n\n<p>乘客信息用一个下标从 <strong>0</strong>&nbsp;开始的二维数组&nbsp;<code>rides</code>&nbsp;表示，其中&nbsp;<code>rides[i] = [start<sub>i</sub>, end<sub>i</sub>, tip<sub>i</sub>]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;位乘客需要从地点&nbsp;<code>start<sub>i</sub></code>&nbsp;前往&nbsp;<code>end<sub>i</sub></code>&nbsp;，愿意支付&nbsp;<code>tip<sub>i</sub></code>&nbsp;元的小费。</p>\n\n<p><strong>每一位</strong> 你选择接单的乘客&nbsp;<code>i</code>&nbsp;，你可以 <strong>盈利</strong>&nbsp;<code>end<sub>i</sub> - start<sub>i</sub> + tip<sub>i</sub></code>&nbsp;元。你同时&nbsp;<strong>最多</strong>&nbsp;只能接一个订单。</p>\n\n<p>给你 <code>n</code>&nbsp;和 <code>rides</code>&nbsp;，请你返回在最优接单方案下，你能盈利&nbsp;<strong>最多</strong>&nbsp;多少元。</p>\n\n<p><strong>注意：</strong>你可以在一个地点放下一位乘客，并在同一个地点接上另一位乘客。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 5, rides = [<em><strong>[2,5,4]</strong></em>,[1,5,1]]\n<b>输出：</b>7\n<b>解释：</b>我们可以接乘客 0 的订单，获得 5 - 2 + 4 = 7 元。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 20, rides = [[1,6,1],<strong><em>[3,10,2]</em></strong>,<em><strong>[10,12,3]</strong></em>,[11,12,2],[12,15,2],<strong><em>[13,18,1]</em></strong>]\n<b>输出：</b>20\n<b>解释：</b>我们可以接以下乘客的订单：\n- 将乘客 1 从地点 3 送往地点 10 ，获得 10 - 3 + 2 = 9 元。\n- 将乘客 2 从地点 10 送往地点 12 ，获得 12 - 10 + 3 = 5 元。\n- 将乘客 5 从地点 13 送往地点 18 ，获得 18 - 13 + 1 = 6 元。\n我们总共获得 9 + 5 + 6 = 20 元。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= rides.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>rides[i].length == 3</code></li>\n\t<li><code>1 &lt;= start<sub>i</sub> &lt; end<sub>i</sub> &lt;= n</code></li>\n\t<li><code>1 &lt;= tip<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2009.使数组连续的最少操作数",
        "hardRate": "HARD",
        "passRate": "43.30%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-continuous/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-continuous/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;。每一次操作中，你可以将&nbsp;<code>nums</code>&nbsp;中&nbsp;<strong>任意</strong>&nbsp;一个元素替换成 <strong>任意&nbsp;</strong>整数。</p>\n\n<p>如果&nbsp;<code>nums</code>&nbsp;满足以下条件，那么它是 <strong>连续的</strong>&nbsp;：</p>\n\n<ul>\n\t<li><code>nums</code>&nbsp;中所有元素都是 <b>互不相同</b>&nbsp;的。</li>\n\t<li><code>nums</code>&nbsp;中 <strong>最大</strong>&nbsp;元素与&nbsp;<strong>最小</strong>&nbsp;元素的差等于&nbsp;<code>nums.length - 1</code>&nbsp;。</li>\n</ul>\n\n<p>比方说，<code>nums = [4, 2, 5, 3]</code>&nbsp;是 <strong>连续的</strong>&nbsp;，但是&nbsp;<code>nums = [1, 2, 3, 5, 6]</code> <strong>不是连续的</strong>&nbsp;。</p>\n\n<p>请你返回使 <code>nums</code>&nbsp;<strong>连续</strong>&nbsp;的 <strong>最少</strong>&nbsp;操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [4,2,5,3]\n<b>输出：</b>0\n<b>解释：</b>nums 已经是连续的了。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,5,6]\n<b>输出：</b>1\n<b>解释：</b>一个可能的解是将最后一个元素变为 4 。\n结果数组为 [1,2,3,5,4] ，是连续数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [1,10,100,1000]\n<b>输出：</b>3\n<b>解释：</b>一个可能的解是：\n- 将第二个元素变为 2 。\n- 将第三个元素变为 3 。\n- 将第四个元素变为 4 。\n结果数组为 [1,2,3,4] ，是连续数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2010.职员招聘人数 II",
        "hardRate": "HARD",
        "passRate": "61.15%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-seniors-and-juniors-to-join-the-company-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-seniors-and-juniors-to-join-the-company-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2011.执行操作后的变量值",
        "hardRate": "EASY",
        "passRate": "86.92%",
        "problemsUrl": "https://leetcode.cn/problems/final-value-of-variable-after-performing-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/final-value-of-variable-after-performing-operations/solution",
        "problemsDesc": "<p>存在一种仅支持 4 种操作和 1 个变量 <code>X</code> 的编程语言：</p>\n\n<ul>\n\t<li><code>++X</code> 和 <code>X++</code> 使变量 <code>X</code> 的值 <strong>加</strong> <code>1</code></li>\n\t<li><code>--X</code> 和 <code>X--</code> 使变量 <code>X</code> 的值 <strong>减</strong> <code>1</code></li>\n</ul>\n\n<p>最初，<code>X</code> 的值是 <code>0</code></p>\n\n<p>给你一个字符串数组 <code>operations</code> ，这是由操作组成的一个列表，返回执行所有操作后，<em> </em><code>X</code> 的 <strong>最终值</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>operations = [\"--X\",\"X++\",\"X++\"]\n<strong>输出：</strong>1\n<strong>解释：</strong>操作按下述步骤执行：\n最初，X = 0\n--X：X 减 1 ，X =  0 - 1 = -1\nX++：X 加 1 ，X = -1 + 1 =  0\nX++：X 加 1 ，X =  0 + 1 =  1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>operations = [\"++X\",\"++X\",\"X++\"]\n<strong>输出：</strong>3\n<strong>解释：</strong>操作按下述步骤执行： \n最初，X = 0\n++X：X 加 1 ，X = 0 + 1 = 1\n++X：X 加 1 ，X = 1 + 1 = 2\nX++：X 加 1 ，X = 2 + 1 = 3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>operations = [\"X++\",\"++X\",\"--X\",\"X--\"]\n<strong>输出：</strong>0\n<strong>解释：</strong>操作按下述步骤执行：\n最初，X = 0\nX++：X 加 1 ，X = 0 + 1 = 1\n++X：X 加 1 ，X = 1 + 1 = 2\n--X：X 减 1 ，X = 2 - 1 = 1\nX--：X 减 1 ，X = 1 - 1 = 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= operations.length &lt;= 100</code></li>\n\t<li><code>operations[i]</code> 将会是 <code>\"++X\"</code>、<code>\"X++\"</code>、<code>\"--X\"</code> 或 <code>\"X--\"</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2012.数组美丽值求和",
        "hardRate": "MEDIUM",
        "passRate": "38.95%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-beauty-in-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-beauty-in-the-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。对于每个下标 <code>i</code>（<code>1 &lt;= i &lt;= nums.length - 2</code>），<code>nums[i]</code> 的 <strong>美丽值</strong> 等于：</p>\n\n<ul>\n\t<li><code>2</code>，对于所有 <code>0 &lt;= j &lt; i</code> 且 <code>i &lt; k &lt;= nums.length - 1</code> ，满足 <code>nums[j] &lt; nums[i] &lt; nums[k]</code></li>\n\t<li><code>1</code>，如果满足 <code>nums[i - 1] &lt; nums[i] &lt; nums[i + 1]</code> ，且不满足前面的条件</li>\n\t<li><code>0</code>，如果上述条件全部不满足</li>\n</ul>\n\n<p>返回符合 <code>1 &lt;= i &lt;= nums.length - 2</code> 的所有<em> </em><code>nums[i]</code><em> </em>的 <strong>美丽值的总和</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>对于每个符合范围 1 &lt;= i &lt;= 1 的下标 i :\n- nums[1] 的美丽值等于 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,4,6,4]\n<strong>输出：</strong>1\n<strong>解释：</strong>对于每个符合范围 1 &lt;= i &lt;= 2 的下标 i :\n- nums[1] 的美丽值等于 1\n- nums[2] 的美丽值等于 0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,2,1]\n<strong>输出：</strong>0\n<strong>解释：</strong>对于每个符合范围 1 &lt;= i &lt;= 1 的下标 i :\n- nums[1] 的美丽值等于 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2013.检测正方形",
        "hardRate": "MEDIUM",
        "passRate": "56.61%",
        "problemsUrl": "https://leetcode.cn/problems/detect-squares/",
        "solutionsUrl": "https://leetcode.cn/problems/detect-squares/solution",
        "problemsDesc": "<p>给你一个在 X-Y 平面上的点构成的数据流。设计一个满足下述要求的算法：</p>\n\n<ul>\n\t<li><strong>添加</strong> 一个在数据流中的新点到某个数据结构中<strong>。</strong>可以添加 <strong>重复</strong> 的点，并会视作不同的点进行处理。</li>\n\t<li>给你一个查询点，请你从数据结构中选出三个点，使这三个点和查询点一同构成一个 <strong>面积为正</strong> 的 <strong>轴对齐正方形</strong> ，<strong>统计</strong> 满足该要求的方案数目<strong>。</strong></li>\n</ul>\n\n<p><strong>轴对齐正方形</strong> 是一个正方形，除四条边长度相同外，还满足每条边都与 x-轴 或 y-轴 平行或垂直。</p>\n\n<p>实现 <code>DetectSquares</code> 类：</p>\n\n<ul>\n\t<li><code>DetectSquares()</code> 使用空数据结构初始化对象</li>\n\t<li><code>void add(int[] point)</code> 向数据结构添加一个新的点 <code>point = [x, y]</code></li>\n\t<li><code>int count(int[] point)</code> 统计按上述方式与点 <code>point = [x, y]</code> 共同构造 <strong>轴对齐正方形</strong> 的方案数。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/01/image.png\" style=\"width: 869px; height: 504px;\" />\n<pre>\n<strong>输入：</strong>\n[\"DetectSquares\", \"add\", \"add\", \"add\", \"count\", \"count\", \"add\", \"count\"]\n[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]\n<strong>输出：</strong>\n[null, null, null, null, 1, 0, null, 2]\n\n<strong>解释：</strong>\nDetectSquares detectSquares = new DetectSquares();\ndetectSquares.add([3, 10]);\ndetectSquares.add([11, 2]);\ndetectSquares.add([3, 2]);\ndetectSquares.count([11, 10]); // 返回 1 。你可以选择：\n                               //   - 第一个，第二个，和第三个点\ndetectSquares.count([14, 8]);  // 返回 0 。查询点无法与数据结构中的这些点构成正方形。\ndetectSquares.add([11, 2]);    // 允许添加重复的点。\ndetectSquares.count([11, 10]); // 返回 2 。你可以选择：\n                               //   - 第一个，第二个，和第三个点\n                               //   - 第一个，第三个，和第四个点\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>point.length == 2</code></li>\n\t<li><code>0 &lt;= x, y &lt;= 1000</code></li>\n\t<li>调用&nbsp;<code>add</code> 和 <code>count</code> 的 <strong>总次数</strong> 最多为 <code>5000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2014.重复 K 次的最长子序列",
        "hardRate": "HARD",
        "passRate": "54.63%",
        "problemsUrl": "https://leetcode.cn/problems/longest-subsequence-repeated-k-times/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-subsequence-repeated-k-times/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的字符串 <code>s</code> ，和一个整数 <code>k</code> 。请你找出字符串 <code>s</code> 中 <strong>重复</strong> <code>k</code> 次的 <strong>最长子序列</strong> 。</p>\n\n<p><strong>子序列</strong> 是由其他字符串删除某些（或不删除）字符派生而来的一个字符串。</p>\n\n<p>如果&nbsp;<code>seq * k</code> 是 <code>s</code> 的一个子序列，其中 <code>seq * k</code> 表示一个由 <code>seq</code> 串联 <code>k</code>&nbsp;次构造的字符串，那么就称 <code>seq</code><strong> </strong>是字符串 <code>s</code> 中一个 <strong>重复 <code>k</code> 次</strong> 的子序列。</p>\n\n<ul>\n\t<li>举个例子，<code>\"bba\"</code> 是字符串 <code>\"bababcba\"</code> 中的一个重复 <code>2</code> 次的子序列，因为字符串 <code>\"bbabba\"</code> 是由 <code>\"bba\"</code> 串联 <code>2</code> 次构造的，而&nbsp;<code>\"bbabba\"</code> 是字符串 <code>\"<em><strong>b</strong></em>a<em><strong>bab</strong></em>c<em><strong>ba</strong></em>\"</code> 的一个子序列。</li>\n</ul>\n\n<p>返回字符串 <code>s</code> 中 <strong>重复 k 次的最长子序列</strong>&nbsp; 。如果存在多个满足的子序列，则返回 <strong>字典序最大</strong> 的那个。如果不存在这样的子序列，返回一个 <strong>空</strong> 字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"example 1\" src=\"https://assets.leetcode.com/uploads/2021/08/30/longest-subsequence-repeat-k-times.png\" style=\"width: 457px; height: 99px;\" /></p>\n\n<pre>\n<strong>输入：</strong>s = \"letsleetcode\", k = 2\n<strong>输出：</strong>\"let\"\n<strong>解释：</strong>存在两个最长子序列重复 2 次：let\" 和 \"ete\" 。\n\"let\" 是其中字典序最大的一个。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"bb\", k = 2\n<strong>输出：</strong>\"b\"\n<strong>解释：</strong>重复 2 次的最长子序列是 \"b\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ab\", k = 2\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>不存在重复 2 次的最长子序列。返回空字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == s.length</code></li>\n\t<li><code>2 &lt;= k &lt;= 2000</code></li>\n\t<li><code>2 &lt;= n &lt; k * 8</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2015.每段建筑物的平均高度",
        "hardRate": "MEDIUM",
        "passRate": "57.28%",
        "problemsUrl": "https://leetcode.cn/problems/average-height-of-buildings-in-each-segment/",
        "solutionsUrl": "https://leetcode.cn/problems/average-height-of-buildings-in-each-segment/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2016.增量元素之间的最大差值",
        "hardRate": "EASY",
        "passRate": "59.68%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-difference-between-increasing-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-difference-between-increasing-elements/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，该数组的大小为 <code>n</code> ，请你计算 <code>nums[j] - nums[i]</code> 能求得的 <strong>最大差值 </strong>，其中 <code>0 &lt;= i &lt; j &lt; n</code> 且 <code>nums[i] &lt; nums[j]</code> 。</p>\n\n<p>返回 <strong>最大差值</strong> 。如果不存在满足要求的 <code>i</code> 和 <code>j</code> ，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [7,<em><strong>1</strong></em>,<em><strong>5</strong></em>,4]\n<strong>输出：</strong>4\n<strong>解释：</strong>\n最大差值出现在 i = 1 且 j = 2 时，nums[j] - nums[i] = 5 - 1 = 4 。\n注意，尽管 i = 1 且 j = 0 时 ，nums[j] - nums[i] = 7 - 1 = 6 &gt; 4 ，但 i &gt; j 不满足题面要求，所以 6 不是有效的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [9,4,3,2]\n<strong>输出：</strong>-1\n<strong>解释：</strong>\n不存在同时满足 i &lt; j 和 nums[i] &lt; nums[j] 这两个条件的 i, j 组合。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [<em><strong>1</strong></em>,5,2,<em><strong>10</strong></em>]\n<strong>输出：</strong>9\n<strong>解释：</strong>\n最大差值出现在 i = 0 且 j = 3 时，nums[j] - nums[i] = 10 - 1 = 9 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2017.网格游戏",
        "hardRate": "MEDIUM",
        "passRate": "38.51%",
        "problemsUrl": "https://leetcode.cn/problems/grid-game/",
        "solutionsUrl": "https://leetcode.cn/problems/grid-game/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的二维数组 <code>grid</code> ，数组大小为 <code>2 x n</code> ，其中 <code>grid[r][c]</code> 表示矩阵中 <code>(r, c)</code> 位置上的点数。现在有两个机器人正在矩阵上参与一场游戏。</p>\n\n<p>两个机器人初始位置都是 <code>(0, 0)</code> ，目标位置是 <code>(1, n-1)</code> 。每个机器人只会 <strong>向右</strong> (<code>(r, c)</code> 到 <code>(r, c + 1)</code>) 或 <strong>向下 </strong>(<code>(r, c)</code> 到 <code>(r + 1, c)</code>) 。</p>\n\n<p>游戏开始，<strong>第一个</strong> 机器人从 <code>(0, 0)</code> 移动到 <code>(1, n-1)</code> ，并收集路径上单元格的全部点数。对于路径上所有单元格 <code>(r, c)</code> ，途经后 <code>grid[r][c]</code> 会重置为 <code>0</code> 。然后，<strong>第二个</strong> 机器人从 <code>(0, 0)</code> 移动到 <code>(1, n-1)</code> ，同样收集路径上单元的全部点数。注意，它们的路径可能会存在相交的部分。</p>\n\n<p><strong>第一个</strong> 机器人想要打击竞争对手，使 <strong>第二个</strong> 机器人收集到的点数 <strong>最小化</strong> 。与此相对，<strong>第二个</strong> 机器人想要 <strong>最大化</strong> 自己收集到的点数。两个机器人都发挥出自己的 <strong>最佳水平</strong>&nbsp;的前提下，返回 <strong>第二个</strong> 机器人收集到的 <strong>点数</strong> <em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/08/a1.png\" style=\"width: 388px; height: 103px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[2,5,4],[1,5,1]]\n<strong>输出：</strong>4\n<strong>解释：</strong>第一个机器人的最佳路径如红色所示，第二个机器人的最佳路径如蓝色所示。\n第一个机器人访问过的单元格将会重置为 0 。\n第二个机器人将会收集到 0 + 0 + 4 + 0 = 4 个点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/08/a2.png\" style=\"width: 384px; height: 105px;\" />\n<pre>\n<strong>输入：</strong>grid = [[3,3,1],[8,5,2]]\n<strong>输出：</strong>4\n<strong>解释：</strong>第一个机器人的最佳路径如红色所示，第二个机器人的最佳路径如蓝色所示。 \n第一个机器人访问过的单元格将会重置为 0 。\n第二个机器人将会收集到 0 + 3 + 1 + 0 = 4 个点。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/08/a3.png\" style=\"width: 493px; height: 103px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,3,1,15],[1,3,3,1]]\n<strong>输出：</strong>7\n<strong>解释：</strong>第一个机器人的最佳路径如红色所示，第二个机器人的最佳路径如蓝色所示。\n第一个机器人访问过的单元格将会重置为 0 。\n第二个机器人将会收集到 0 + 1 + 3 + 3 + 0 = 7 个点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>grid.length == 2</code></li>\n\t<li><code>n == grid[r].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= grid[r][c] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2018.判断单词是否能放入填字游戏内",
        "hardRate": "MEDIUM",
        "passRate": "42.26%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-word-can-be-placed-in-crossword/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-word-can-be-placed-in-crossword/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的矩阵&nbsp;<code>board</code>&nbsp;，它代表一个填字游戏&nbsp;<strong>当前</strong>&nbsp;的状态。填字游戏格子中包含小写英文字母（已填入的单词），表示&nbsp;<strong>空</strong>&nbsp;格的&nbsp;<code>' '</code>&nbsp;和表示&nbsp;<strong>障碍</strong>&nbsp;格子的&nbsp;<code>'#'</code>&nbsp;。</p>\n\n<p>如果满足以下条件，那么我们可以 <strong>水平</strong>&nbsp;（从左到右 <strong>或者</strong>&nbsp;从右到左）或 <strong>竖直</strong>&nbsp;（从上到下 <strong>或者</strong>&nbsp;从下到上）填入一个单词：</p>\n\n<ul>\n\t<li>该单词不占据任何&nbsp;<code>'#'</code>&nbsp;对应的格子。</li>\n\t<li>每个字母对应的格子要么是&nbsp;<code>' '</code>&nbsp;（空格）要么与 <code>board</code>&nbsp;中已有字母 <strong>匹配</strong>&nbsp;。</li>\n\t<li>如果单词是 <strong>水平</strong>&nbsp;放置的，那么该单词左边和右边 <strong>相邻</strong>&nbsp;格子不能为&nbsp;<code>' '</code>&nbsp;或小写英文字母。</li>\n\t<li>如果单词是&nbsp;<strong>竖直</strong>&nbsp;放置的，那么该单词上边和下边&nbsp;<strong>相邻</strong><strong>&nbsp;</strong>格子不能为&nbsp;<code>' '</code>&nbsp;或小写英文字母。</li>\n</ul>\n\n<p>给你一个字符串&nbsp;<code>word</code>&nbsp;，如果&nbsp;<code>word</code>&nbsp;可以被放入&nbsp;<code>board</code>&nbsp;中，请你返回&nbsp;<code>true</code>&nbsp;，否则请返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/18/crossword-1.png\" style=\"width: 170px; height: 150px;\" /></p>\n\n<pre>\n<b>输入：</b>board = [[\"#\", \" \", \"#\"], [\" \", \" \", \"#\"], [\"#\", \"c\", \" \"]], word = \"abc\"\n<b>输出：</b>true\n<b>解释：</b>单词 \"abc\" 可以如上图放置（从上往下）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/18/c2.png\" style=\"width: 170px; height: 151px;\" /></p>\n\n<pre>\n<b>输入：</b>board = [[\" \", \"#\", \"a\"], [\" \", \"#\", \"c\"], [\" \", \"#\", \"a\"]], word = \"ac\"\n<b>输出：</b>false\n<b>解释：</b>无法放置单词，因为放置该单词后上方或者下方相邻格会有空格。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/18/crossword-2.png\" style=\"width: 171px; height: 146px;\" /></p>\n\n<pre>\n<b>输入：</b>board = [[\"#\", \" \", \"#\"], [\" \", \" \", \"#\"], [\"#\", \" \", \"c\"]], word = \"ca\"\n<b>输出：</b>true\n<b>解释：</b>单词 \"ca\" 可以如上图放置（从右到左）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m * n &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>board[i][j]</code>&nbsp;可能为&nbsp;<code>' '</code>&nbsp;，<code>'#'</code>&nbsp;或者一个小写英文字母。</li>\n\t<li><code>1 &lt;= word.length &lt;= max(m, n)</code></li>\n\t<li><code>word</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2019.解出数学表达式的学生分数",
        "hardRate": "HARD",
        "passRate": "37.62%",
        "problemsUrl": "https://leetcode.cn/problems/the-score-of-students-solving-math-expression/",
        "solutionsUrl": "https://leetcode.cn/problems/the-score-of-students-solving-math-expression/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，它 <strong>只</strong> 包含数字&nbsp;<code>0-9</code>&nbsp;，加法运算符&nbsp;<code>'+'</code>&nbsp;和乘法运算符&nbsp;<code>'*'</code>&nbsp;，这个字符串表示一个&nbsp;<strong>合法</strong>&nbsp;的只含有&nbsp;<strong>个位数</strong><strong>数字</strong>&nbsp;的数学表达式（比方说&nbsp;<code>3+5*2</code>）。有 <code>n</code>&nbsp;位小学生将计算这个数学表达式，并遵循如下 <strong>运算顺序</strong>&nbsp;：</p>\n\n<ol>\n\t<li>按照 <strong>从左到右</strong>&nbsp;的顺序计算 <strong>乘法</strong>&nbsp;，然后</li>\n\t<li>按照 <strong>从左到右</strong>&nbsp;的顺序计算 <strong>加法</strong>&nbsp;。</li>\n</ol>\n\n<p>给你一个长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>answers</code>&nbsp;，表示每位学生提交的答案。你的任务是给 <code>answer</code>&nbsp;数组按照如下 <strong>规则</strong>&nbsp;打分：</p>\n\n<ul>\n\t<li>如果一位学生的答案 <strong>等于</strong>&nbsp;表达式的正确结果，这位学生将得到 <code>5</code>&nbsp;分。</li>\n\t<li>否则，如果答案由&nbsp;<strong>一处或多处错误的运算顺序</strong>&nbsp;计算得到，那么这位学生能得到 <code>2</code>&nbsp;分。</li>\n\t<li>否则，这位学生将得到 <code>0</code>&nbsp;分。</li>\n</ul>\n\n<p>请你返回所有学生的分数和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/17/student_solving_math.png\" style=\"width: 678px; height: 109px;\"></p>\n\n<pre><b>输入：</b>s = \"7+3*1*2\", answers = [20,13,42]\n<b>输出：</b>7\n<b>解释：</b>如上图所示，正确答案为 13 ，因此有一位学生得分为 5 分：[20,<em><strong>13</strong></em>,42] 。\n一位学生可能通过错误的运算顺序得到结果 20 ：7+3=10，10*1=10，10*2=20 。所以这位学生得分为 2 分：[<em><strong>20</strong></em>,13,42] 。\n所有学生得分分别为：[2,5,0] 。所有得分之和为 2+5+0=7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"3+5*2\", answers = [13,0,10,13,13,16,16]\n<b>输出：</b>19\n<b>解释：</b>表达式的正确结果为 13 ，所以有 3 位学生得到 5 分：[<em><strong>13</strong></em>,0,10,<em><strong>13</strong></em>,<em><strong>13</strong></em>,16,16] 。\n学生可能通过错误的运算顺序得到结果 16 ：3+5=8，8*2=16 。所以两位学生得到 2 分：[13,0,10,13,13,<em><strong>16</strong></em>,<em><strong>16</strong></em>] 。\n所有学生得分分别为：[5,0,0,5,5,2,2] 。所有得分之和为 5+0+0+5+5+2+2=19 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>s = \"6+0*1\", answers = [12,9,6,4,8,6]\n<b>输出：</b>10\n<b>解释：</b>表达式的正确结果为 6 。\n如果一位学生通过错误的运算顺序计算该表达式，结果仍为 6 。\n根据打分规则，运算顺序错误的学生也将得到 5 分（因为他们仍然得到了正确的结果），而不是 2 分。\n所有学生得分分别为：[0,0,5,0,0,5] 。所有得分之和为 10 分。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= s.length &lt;= 31</code></li>\n\t<li><code>s</code>&nbsp;表示一个只包含&nbsp;<code>0-9</code>&nbsp;，<code>'+'</code>&nbsp;和&nbsp;<code>'*'</code>&nbsp;的合法表达式。</li>\n\t<li>表达式中所有整数运算数字都在闭区间&nbsp;<code>[0, 9]</code>&nbsp;以内。</li>\n\t<li><code>1 &lt;=</code>&nbsp;数学表达式中所有运算符数目（<code>'+'</code> 和&nbsp;<code>'*'</code>）&nbsp;<code>&lt;= 15</code></li>\n\t<li>测试数据保证正确表达式结果在范围&nbsp;<code>[0, 1000]</code>&nbsp;以内。</li>\n\t<li><code>n == answers.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= answers[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2020.无流量的帐户数",
        "hardRate": "MEDIUM",
        "passRate": "70.74%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-accounts-that-did-not-stream/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-accounts-that-did-not-stream/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2021.街上最亮的位置",
        "hardRate": "MEDIUM",
        "passRate": "63.03%",
        "problemsUrl": "https://leetcode.cn/problems/brightest-position-on-street/",
        "solutionsUrl": "https://leetcode.cn/problems/brightest-position-on-street/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2022.将一维数组转变成二维数组",
        "hardRate": "EASY",
        "passRate": "65.44%",
        "problemsUrl": "https://leetcode.cn/problems/convert-1d-array-into-2d-array/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-1d-array-into-2d-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的一维整数数组&nbsp;<code>original</code>&nbsp;和两个整数&nbsp;<code>m</code>&nbsp;和&nbsp;&nbsp;<code>n</code>&nbsp;。你需要使用&nbsp;<code>original</code>&nbsp;中&nbsp;<strong>所有</strong>&nbsp;元素创建一个&nbsp;<code>m</code>&nbsp;行&nbsp;<code>n</code>&nbsp;列的二维数组。</p>\n\n<p><code>original</code>&nbsp;中下标从 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;（都 <strong>包含</strong> ）的元素构成二维数组的第一行，下标从 <code>n</code>&nbsp;到 <code>2 * n - 1</code>&nbsp;（都 <strong>包含</strong>&nbsp;）的元素构成二维数组的第二行，依此类推。</p>\n\n<p>请你根据上述过程返回一个<em>&nbsp;</em><code>m x n</code>&nbsp;的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2021/08/26/image-20210826114243-1.png\" style=\"width: 500px; height: 174px;\">\n<pre><b>输入：</b>original = [1,2,3,4], m = 2, n = 2\n<b>输出：</b>[[1,2],[3,4]]\n<strong>解释：\n</strong>构造出的二维数组应该包含 2 行 2 列。\noriginal 中第一个 n=2 的部分为 [1,2] ，构成二维数组的第一行。\noriginal 中第二个 n=2 的部分为 [3,4] ，构成二维数组的第二行。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>original = [1,2,3], m = 1, n = 3\n<b>输出：</b>[[1,2,3]]\n<b>解释：</b>\n构造出的二维数组应该包含 1 行 3 列。\n将 original 中所有三个元素放入第一行中，构成要求的二维数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>original = [1,2], m = 1, n = 1\n<b>输出：</b>[]\n<strong>解释：\n</strong>original 中有 2 个元素。\n无法将 2 个元素放入到一个 1x1 的二维数组中，所以返回一个空的二维数组。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>original = [3], m = 1, n = 2\n<b>输出：</b>[]\n<strong>解释：</strong>\noriginal 中只有 1 个元素。\n无法将 1 个元素放满一个 1x2 的二维数组，所以返回一个空的二维数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= original.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= original[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m, n &lt;= 4 * 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2023.连接后等于目标字符串的字符串对",
        "hardRate": "MEDIUM",
        "passRate": "74.20%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/solution",
        "problemsDesc": "<p>给你一个 <strong>数字</strong>&nbsp;字符串数组 <code>nums</code>&nbsp;和一个 <strong>数字</strong>&nbsp;字符串 <code>target</code>&nbsp;，请你返回 <code>nums[i] + nums[j]</code>&nbsp;（两个字符串连接）结果等于 <code>target</code>&nbsp;的下标 <code>(i, j)</code>&nbsp;（需满足 <code>i != j</code>）的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [\"777\",\"7\",\"77\",\"77\"], target = \"7777\"\n<b>输出：</b>4\n<b>解释：</b>符合要求的下标对包括：\n- (0, 1)：\"777\" + \"7\"\n- (1, 0)：\"7\" + \"777\"\n- (2, 3)：\"77\" + \"77\"\n- (3, 2)：\"77\" + \"77\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [\"123\",\"4\",\"12\",\"34\"], target = \"1234\"\n<b>输出：</b>2\n<b>解释：</b>符合要求的下标对包括\n- (0, 1)：\"123\" + \"4\"\n- (2, 3)：\"12\" + \"34\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [\"1\",\"1\",\"1\"], target = \"11\"\n<b>输出：</b>6\n<b>解释：</b>符合要求的下标对包括\n- (0, 1)：\"1\" + \"1\"\n- (1, 0)：\"1\" + \"1\"\n- (0, 2)：\"1\" + \"1\"\n- (2, 0)：\"1\" + \"1\"\n- (1, 2)：\"1\" + \"1\"\n- (2, 1)：\"1\" + \"1\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i].length &lt;= 100</code></li>\n\t<li><code>2 &lt;= target.length &lt;= 100</code></li>\n\t<li><code>nums[i]</code>&nbsp;和&nbsp;<code>target</code>&nbsp;只包含数字。</li>\n\t<li><code>nums[i]</code>&nbsp;和&nbsp;<code>target</code>&nbsp;不含有任何前导 0 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2024.考试的最大困扰度",
        "hardRate": "MEDIUM",
        "passRate": "57.26%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/solution",
        "problemsDesc": "<p>一位老师正在出一场由 <code>n</code>&nbsp;道判断题构成的考试，每道题的答案为 true （用 <code><span style=\"\">'T'</span></code> 表示）或者 false （用 <code>'F'</code>&nbsp;表示）。老师想增加学生对自己做出答案的不确定性，方法是&nbsp;<strong>最大化&nbsp;</strong>有 <strong>连续相同</strong>&nbsp;结果的题数。（也就是连续出现 true 或者连续出现 false）。</p>\n\n<p>给你一个字符串&nbsp;<code>answerKey</code>&nbsp;，其中&nbsp;<code>answerKey[i]</code>&nbsp;是第 <code>i</code>&nbsp;个问题的正确结果。除此以外，还给你一个整数 <code>k</code>&nbsp;，表示你能进行以下操作的最多次数：</p>\n\n<ul>\n\t<li>每次操作中，将问题的正确答案改为&nbsp;<code>'T'</code> 或者&nbsp;<code>'F'</code>&nbsp;（也就是将 <code>answerKey[i]</code> 改为&nbsp;<code>'T'</code>&nbsp;或者&nbsp;<code>'F'</code>&nbsp;）。</li>\n</ul>\n\n<p>请你返回在不超过 <code>k</code>&nbsp;次操作的情况下，<strong>最大</strong>&nbsp;连续 <code>'T'</code>&nbsp;或者 <code>'F'</code>&nbsp;的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>answerKey = \"TTFF\", k = 2\n<b>输出：</b>4\n<b>解释：</b>我们可以将两个 'F' 都变为 'T' ，得到 answerKey = \"<em><strong>TTTT</strong></em>\" 。\n总共有四个连续的 'T' 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>answerKey = \"TFFT\", k = 1\n<b>输出：</b>3\n<b>解释：</b>我们可以将最前面的 'T' 换成 'F' ，得到 answerKey = \"<em><strong>FFF</strong></em>T\" 。\n或者，我们可以将第二个 'T' 换成 'F' ，得到 answerKey = \"T<em><strong>FFF</strong></em>\" 。\n两种情况下，都有三个连续的 'F' 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>answerKey = \"TTFTTFTT\", k = 1\n<b>输出：</b>5\n<b>解释：</b>我们可以将第一个 'F' 换成 'T' ，得到 answerKey = \"<em><strong>TTTTT</strong></em>FTT\" 。\n或者我们可以将第二个 'F' 换成 'T' ，得到 answerKey = \"TTF<em><strong>TTTTT</strong></em>\" 。\n两种情况下，都有五个连续的 'T' 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == answerKey.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>answerKey[i]</code>&nbsp;要么是&nbsp;<code>'T'</code> ，要么是&nbsp;<code>'F'</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2025.分割数组的最多方案数",
        "hardRate": "HARD",
        "passRate": "30.40%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-ways-to-partition-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-ways-to-partition-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始且长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;。<strong>分割</strong>&nbsp;数组 <code>nums</code>&nbsp;的方案数定义为符合以下两个条件的 <code>pivot</code>&nbsp;数目：</p>\n\n<ul>\n\t<li><code>1 &lt;= pivot &lt; n</code></li>\n\t<li><code>nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]</code></li>\n</ul>\n\n<p>同时给你一个整数&nbsp;<code>k</code>&nbsp;。你可以将&nbsp;<code>nums</code>&nbsp;中&nbsp;<strong>一个</strong>&nbsp;元素变为&nbsp;<code>k</code>&nbsp;或&nbsp;<strong>不改变</strong>&nbsp;数组。</p>\n\n<p>请你返回在 <strong>至多</strong>&nbsp;改变一个元素的前提下，<strong>最多</strong>&nbsp;有多少种方法 <strong>分割</strong>&nbsp;<code>nums</code>&nbsp;使得上述两个条件都满足。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,-1,2], k = 3\n<b>输出：</b>1\n<b>解释：</b>一个最优的方案是将 nums[0] 改为 k&nbsp;。数组变为 [<em><strong>3</strong></em>,-1,2] 。\n有一种方法分割数组：\n- pivot = 2 ，我们有分割 [3,-1 | 2]：3 + -1 == 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [0,0,0], k = 1\n<b>输出：</b>2\n<b>解释：</b>一个最优的方案是不改动数组。\n有两种方法分割数组：\n- pivot = 1 ，我们有分割 [0 | 0,0]：0 == 0 + 0 。\n- pivot = 2 ，我们有分割 [0,0 | 0]: 0 + 0 == 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33\n<b>输出：</b>4\n<b>解释：</b>一个最优的方案是将 nums[2] 改为 k 。数组变为 [22,4,<em><strong>-33</strong></em>,-20,-15,15,-16,7,19,-10,0,-13,-14] 。\n有四种方法分割数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= k, nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2026.低质量的问题",
        "hardRate": "EASY",
        "passRate": "79.95%",
        "problemsUrl": "https://leetcode.cn/problems/low-quality-problems/",
        "solutionsUrl": "https://leetcode.cn/problems/low-quality-problems/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2027.转换字符串的最少操作次数",
        "hardRate": "EASY",
        "passRate": "66.97%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-moves-to-convert-string/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-moves-to-convert-string/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，由 <code>n</code> 个字符组成，每个字符不是 <code>'X'</code> 就是 <code>'O'</code> 。</p>\n\n<p>一次<strong> 操作</strong> 定义为从 <code>s</code> 中选出 <strong>三个连续字符 </strong>并将选中的每个字符都转换为 <code>'O'</code> 。注意，如果字符已经是 <code>'O'</code> ，只需要保持 <strong>不变</strong> 。</p>\n\n<p>返回将 <code>s</code> 中所有字符均转换为 <code>'O'</code> 需要执行的&nbsp;<strong>最少</strong>&nbsp;操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"XXX\"\n<strong>输出：</strong>1\n<strong>解释：<em>XXX</em></strong> -&gt; OOO\n一次操作，选中全部 3 个字符，并将它们转换为 <code>'O' 。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"XXOX\"\n<strong>输出：</strong>2\n<strong>解释：<em>XXO</em></strong>X -&gt; O<em><strong>OOX</strong></em> -&gt; OOOO\n第一次操作，选择前 3 个字符，并将这些字符转换为 <code>'O'</code> 。\n然后，选中后 3 个字符，并执行转换。最终得到的字符串全由字符 <code>'O'</code> 组成。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"OOOO\"\n<strong>输出：</strong>0\n<strong>解释：</strong>s 中不存在需要转换的 <code>'X' 。</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i]</code> 为 <code>'X'</code> 或 <code>'O'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2028.找出缺失的观测数据",
        "hardRate": "MEDIUM",
        "passRate": "50.67%",
        "problemsUrl": "https://leetcode.cn/problems/find-missing-observations/",
        "solutionsUrl": "https://leetcode.cn/problems/find-missing-observations/solution",
        "problemsDesc": "<p>现有一份 <code>n + m</code>&nbsp;次投掷单个<strong> 六面</strong> 骰子的观测数据，骰子的每个面从 <code>1</code> 到 <code>6</code> 编号。观测数据中缺失了 <code>n</code> 份，你手上只拿到剩余&nbsp;<code>m</code> 次投掷的数据。幸好你有之前计算过的这 <code>n + m</code> 次投掷数据的 <strong>平均值</strong> 。</p>\n\n<p>给你一个长度为 <code>m</code> 的整数数组 <code>rolls</code> ，其中&nbsp;<code>rolls[i]</code> 是第 <code>i</code> 次观测的值。同时给你两个整数 <code>mean</code> 和 <code>n</code> 。</p>\n\n<p>返回一个长度为<em> </em><code>n</code><em> </em>的数组，包含所有缺失的观测数据，且满足这<em> </em><code>n + m</code><em> </em>次投掷的 <strong>平均值</strong> 是<em> </em><code>mean</code> 。如果存在多组符合要求的答案，只需要返回其中任意一组即可。如果不存在答案，返回一个空数组。</p>\n\n<p><code>k</code>&nbsp;个数字的 <strong>平均值</strong> 为这些数字求和后再除以&nbsp;<code>k</code> 。</p>\n\n<p>注意 <code>mean</code> 是一个整数，所以 <code>n + m</code> 次投掷的总和需要被&nbsp;<code>n + m</code>&nbsp;整除。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rolls = [3,2,4,3], mean = 4, n = 2\n<strong>输出：</strong>[6,6]\n<strong>解释：</strong>所有 n + m 次投掷的平均值是 (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rolls = [1,5,6], mean = 3, n = 4\n<strong>输出：</strong>[2,3,2,2]\n<strong>解释：</strong>所有 n + m 次投掷的平均值是 (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>rolls = [1,2,3,4], mean = 6, n = 4\n<strong>输出：</strong>[]\n<strong>解释：</strong>无论丢失的 4 次数据是什么，平均值都不可能是 6 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>rolls = [1], mean = 3, n = 1\n<strong>输出：</strong>[5]\n<strong>解释：</strong>所有 n + m 次投掷的平均值是 (1 + 5) / 2 = 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == rolls.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= rolls[i], mean &lt;= 6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2029.石子游戏 IX",
        "hardRate": "MEDIUM",
        "passRate": "46.94%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game-ix/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game-ix/solution",
        "problemsDesc": "<p>Alice 和 Bob 再次设计了一款新的石子游戏。现有一行 n 个石子，每个石子都有一个关联的数字表示它的价值。给你一个整数数组 <code>stones</code> ，其中 <code>stones[i]</code> 是第 <code>i</code> 个石子的价值。</p>\n\n<p>Alice 和 Bob 轮流进行自己的回合，<strong>Alice</strong> 先手。每一回合，玩家需要从 <code>stones</code>&nbsp;中移除任一石子。</p>\n\n<ul>\n\t<li>如果玩家移除石子后，导致 <strong>所有已移除石子</strong> 的价值&nbsp;<strong>总和</strong> 可以被 3 整除，那么该玩家就 <strong>输掉游戏</strong> 。</li>\n\t<li>如果不满足上一条，且移除后没有任何剩余的石子，那么 Bob 将会直接获胜（即便是在 Alice 的回合）。</li>\n</ul>\n\n<p>假设两位玩家均采用&nbsp;<strong>最佳</strong> 决策。如果 Alice 获胜，返回 <code>true</code> ；如果 Bob 获胜，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [2,1]\n<strong>输出：</strong>true\n<strong>解释：</strong>游戏进行如下：\n- 回合 1：Alice 可以移除任意一个石子。\n- 回合 2：Bob 移除剩下的石子。 \n已移除的石子的值总和为 1 + 2 = 3 且可以被 3 整除。因此，Bob 输，Alice 获胜。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [2]\n<strong>输出：</strong>false\n<strong>解释：</strong>Alice 会移除唯一一个石子，已移除石子的值总和为 2 。 \n由于所有石子都已移除，且值总和无法被 3 整除，Bob 获胜。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [5,1,2,4,3]\n<strong>输出：</strong>false\n<strong>解释：</strong>Bob 总会获胜。其中一种可能的游戏进行方式如下：\n- 回合 1：Alice 可以移除值为 1 的第 2 个石子。已移除石子值总和为 1 。\n- 回合 2：Bob 可以移除值为 3 的第 5 个石子。已移除石子值总和为 = 1 + 3 = 4 。\n- 回合 3：Alices 可以移除值为 4 的第 4 个石子。已移除石子值总和为 = 1 + 3 + 4 = 8 。\n- 回合 4：Bob 可以移除值为 2 的第 3 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 = 10.\n- 回合 5：Alice 可以移除值为 5 的第 1 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 + 5 = 15.\nAlice 输掉游戏，因为已移除石子值总和（15）可以被 3 整除，Bob 获胜。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= stones.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= stones[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2030.含特定字母的最小子序列",
        "hardRate": "HARD",
        "passRate": "36.39%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，一个整数 <code>k</code> ，一个字母 <code>letter</code> 以及另一个整数 <code>repetition</code> 。</p>\n\n<p>返回 <code>s</code> 中长度为 <code>k</code> 且 <strong>字典序最小</strong> 的子序列，该子序列同时应满足字母 <code>letter</code> 出现<strong> 至少</strong> <code>repetition</code> 次。生成的测试用例满足 <code>letter</code> 在 <code>s</code> 中出现 <strong>至少</strong> <code>repetition</code> 次。</p>\n\n<p><strong>子序列</strong> 是由原字符串删除一些（或不删除）字符且不改变剩余字符顺序得到的剩余字符串。</p>\n\n<p>字符串 <code>a</code> 字典序比字符串 <code>b</code> 小的定义为：在 <code>a</code> 和 <code>b</code> 出现不同字符的第一个位置上，字符串 <code>a</code> 的字符在字母表中的顺序早于字符串 <code>b</code>&nbsp;的字符。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"leet\", k = 3, letter = \"e\", repetition = 1\n<strong>输出：</strong>\"eet\"\n<strong>解释：</strong>存在 4 个长度为 3 ，且满足字母 'e' 出现至少 1 次的子序列：\n- \"lee\"（\"<em><strong>lee</strong></em>t\"）\n- \"let\"（\"<em><strong>le</strong></em>e<em><strong>t</strong></em>\"）\n- \"let\"（\"<em><strong>l</strong></em>e<em><strong>et</strong></em>\"）\n- \"eet\"（\"l<em><strong>eet</strong></em>\"）\n其中字典序最小的子序列是 \"eet\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"example-2\" src=\"https://assets.leetcode.com/uploads/2021/09/13/smallest-k-length-subsequence.png\" style=\"width: 339px; height: 67px;\" /></p>\n\n<pre>\n<strong>输入：</strong>s = \"leetcode\", k = 4, letter = \"e\", repetition = 2\n<strong>输出：</strong>\"ecde\"\n<strong>解释：</strong>\"ecde\" 是长度为 4 且满足字母 \"e\" 出现至少 2 次的字典序最小的子序列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"bb\", k = 2, letter = \"b\", repetition = 2\n<strong>输出：</strong>\"bb\"\n<strong>解释：</strong>\"bb\" 是唯一一个长度为 2 且满足字母 \"b\" 出现至少 2 次的子序列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= repetition &lt;= k &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n\t<li><code>letter</code> 是一个小写英文字母，在 <code>s</code>&nbsp;中至少出现 <code>repetition</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2031.1 比 0 多的子数组个数",
        "hardRate": "MEDIUM",
        "passRate": "55.18%",
        "problemsUrl": "https://leetcode.cn/problems/count-subarrays-with-more-ones-than-zeros/",
        "solutionsUrl": "https://leetcode.cn/problems/count-subarrays-with-more-ones-than-zeros/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2032.至少在两个数组中出现的值",
        "hardRate": "EASY",
        "passRate": "73.14%",
        "problemsUrl": "https://leetcode.cn/problems/two-out-of-three/",
        "solutionsUrl": "https://leetcode.cn/problems/two-out-of-three/solution",
        "problemsDesc": "给你三个整数数组 <code>nums1</code>、<code>nums2</code> 和 <code>nums3</code> ，请你构造并返回一个 <strong>元素各不相同的</strong> 数组，且由 <strong>至少</strong> 在 <strong>两个</strong> 数组中出现的所有值组成<em>。</em>数组中的元素可以按 <strong>任意</strong> 顺序排列。\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3]\n<strong>输出：</strong>[3,2]\n<strong>解释：</strong>至少在两个数组中出现的所有值为：\n- 3 ，在全部三个数组中都出现过。\n- 2 ，在数组 nums1 和 nums2 中出现过。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [3,1], nums2 = [2,3], nums3 = [1,2]\n<strong>输出：</strong>[2,3,1]\n<strong>解释：</strong>至少在两个数组中出现的所有值为：\n- 2 ，在数组 nums2 和 nums3 中出现过。\n- 3 ，在数组 nums1 和 nums2 中出现过。\n- 1 ，在数组 nums1 和 nums3 中出现过。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5]\n<strong>输出：</strong>[]\n<strong>解释：</strong>不存在至少在两个数组中出现的值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length, nums3.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[j], nums3[k] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2033.获取单值网格的最小操作数",
        "hardRate": "MEDIUM",
        "passRate": "43.23%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-a-uni-value-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-a-uni-value-grid/solution",
        "problemsDesc": "<p>给你一个大小为&nbsp;<code>m x n</code> 的二维整数网格 <code>grid</code> 和一个整数 <code>x</code> 。每一次操作，你可以对 <code>grid</code> 中的任一元素 <strong>加</strong> <code>x</code> 或 <strong>减</strong> <code>x</code> 。</p>\n\n<p><strong>单值网格</strong> 是全部元素都相等的网格。</p>\n\n<p>返回使网格化为单值网格所需的 <strong>最小</strong> 操作数。如果不能，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/21/gridtxt.png\" style=\"width: 164px; height: 165px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[2,4],[6,8]], x = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>可以执行下述操作使所有元素都等于 4 ： \n- 2 加 x 一次。\n- 6 减 x 一次。\n- 8 减 x 两次。\n共计 4 次操作。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/21/gridtxt-1.png\" style=\"width: 164px; height: 165px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,5],[2,3]], x = 1\n<strong>输出：</strong>5\n<strong>解释：</strong>可以使所有元素都等于 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/21/gridtxt-2.png\" style=\"width: 164px; height: 165px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,2],[3,4]], x = 2\n<strong>输出：</strong>-1\n<strong>解释：</strong>无法使所有元素相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= x, grid[i][j] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2034.股票价格波动",
        "hardRate": "MEDIUM",
        "passRate": "45.81%",
        "problemsUrl": "https://leetcode.cn/problems/stock-price-fluctuation/",
        "solutionsUrl": "https://leetcode.cn/problems/stock-price-fluctuation/solution",
        "problemsDesc": "<p>给你一支股票价格的数据流。数据流中每一条记录包含一个 <strong>时间戳</strong>&nbsp;和该时间点股票对应的 <strong>价格</strong>&nbsp;。</p>\n\n<p>不巧的是，由于股票市场内在的波动性，股票价格记录可能不是按时间顺序到来的。某些情况下，有的记录可能是错的。如果两个有相同时间戳的记录出现在数据流中，前一条记录视为错误记录，后出现的记录 <b>更正</b>&nbsp;前一条错误的记录。</p>\n\n<p>请你设计一个算法，实现：</p>\n\n<ul>\n\t<li><strong>更新 </strong>股票在某一时间戳的股票价格，如果有之前同一时间戳的价格，这一操作将&nbsp;<strong>更正</strong>&nbsp;之前的错误价格。</li>\n\t<li>找到当前记录里 <b>最新股票价格</b>&nbsp;。<strong>最新股票价格</strong>&nbsp;定义为时间戳最晚的股票价格。</li>\n\t<li>找到当前记录里股票的 <strong>最高价格</strong>&nbsp;。</li>\n\t<li>找到当前记录里股票的 <strong>最低价格</strong>&nbsp;。</li>\n</ul>\n\n<p>请你实现&nbsp;<code>StockPrice</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>StockPrice()</code>&nbsp;初始化对象，当前无股票价格记录。</li>\n\t<li><code>void update(int timestamp, int price)</code>&nbsp;在时间点 <code>timestamp</code>&nbsp;更新股票价格为 <code>price</code>&nbsp;。</li>\n\t<li><code>int current()</code>&nbsp;返回股票 <strong>最新价格</strong>&nbsp;。</li>\n\t<li><code>int maximum()</code>&nbsp;返回股票 <strong>最高价格</strong>&nbsp;。</li>\n\t<li><code>int minimum()</code>&nbsp;返回股票 <strong>最低价格</strong>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>\n[\"StockPrice\", \"update\", \"update\", \"current\", \"maximum\", \"update\", \"maximum\", \"update\", \"minimum\"]\n[[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []]\n<strong>输出：</strong>\n[null, null, null, 5, 10, null, 5, null, 2]\n\n<strong>解释：</strong>\nStockPrice stockPrice = new StockPrice();\nstockPrice.update(1, 10); // 时间戳为 [1] ，对应的股票价格为 [10] 。\nstockPrice.update(2, 5);  // 时间戳为 [1,2] ，对应的股票价格为 [10,5] 。\nstockPrice.current();     // 返回 5 ，最新时间戳为 2 ，对应价格为 5 。\nstockPrice.maximum();     // 返回 10 ，最高价格的时间戳为 1 ，价格为 10 。\nstockPrice.update(1, 3);  // 之前时间戳为 1 的价格错误，价格更新为 3 。\n                          // 时间戳为 [1,2] ，对应股票价格为 [3,5] 。\nstockPrice.maximum();     // 返回 5 ，更正后最高价格为 5 。\nstockPrice.update(4, 2);  // 时间戳为 [1,2,4] ，对应价格为 [3,5,2] 。\nstockPrice.minimum();     // 返回 2 ，最低价格时间戳为 4 ，价格为 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= timestamp, price &lt;= 10<sup>9</sup></code></li>\n\t<li><code>update</code>，<code>current</code>，<code>maximum</code>&nbsp;和&nbsp;<code>minimum</code>&nbsp;<strong>总</strong> 调用次数不超过&nbsp;<code>10<sup>5</sup></code>&nbsp;。</li>\n\t<li><code>current</code>，<code>maximum</code>&nbsp;和&nbsp;<code>minimum</code>&nbsp;被调用时，<code>update</code>&nbsp;操作 <strong>至少</strong>&nbsp;已经被调用过 <strong>一次</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2035.将数组分成两个数组并最小化数组和的差",
        "hardRate": "HARD",
        "passRate": "34.80%",
        "problemsUrl": "https://leetcode.cn/problems/partition-array-into-two-arrays-to-minimize-sum-difference/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-array-into-two-arrays-to-minimize-sum-difference/solution",
        "problemsDesc": "<p>给你一个长度为 <code>2 * n</code>&nbsp;的整数数组。你需要将&nbsp;<code>nums</code>&nbsp;分成&nbsp;<strong>两个</strong>&nbsp;长度为&nbsp;<code>n</code>&nbsp;的数组，分别求出两个数组的和，并 <strong>最小化</strong>&nbsp;两个数组和之&nbsp;<b>差的绝对值</b>&nbsp;。<code>nums</code>&nbsp;中每个元素都需要放入两个数组之一。</p>\n\n<p>请你返回&nbsp;<strong>最小</strong>&nbsp;的数组和之差。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"example-1\" src=\"https://assets.leetcode.com/uploads/2021/10/02/ex1.png\" style=\"width: 240px; height: 106px;\"></p>\n\n<pre><b>输入：</b>nums = [3,9,7,3]\n<b>输出：</b>2\n<strong>解释：</strong>最优分组方案是分成 [3,9] 和 [7,3] 。\n数组和之差的绝对值为 abs((3 + 9) - (7 + 3)) = 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [-36,36]\n<b>输出：</b>72\n<strong>解释：</strong>最优分组方案是分成 [-36] 和 [36] 。\n数组和之差的绝对值为 abs((-36) - (36)) = 72 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"example-3\" src=\"https://assets.leetcode.com/uploads/2021/10/02/ex3.png\" style=\"width: 316px; height: 106px;\"></p>\n\n<pre><b>输入：</b>nums = [2,-1,0,4,-2,-9]\n<b>输出：</b>0\n<strong>解释：</strong>最优分组方案是分成 [2,4,-9] 和 [-1,0,-2] 。\n数组和之差的绝对值为 abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 15</code></li>\n\t<li><code>nums.length == 2 * n</code></li>\n\t<li><code>-10<sup>7</sup> &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2036.最大交替子数组和",
        "hardRate": "MEDIUM",
        "passRate": "42.50%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-alternating-subarray-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-alternating-subarray-sum/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2037.使每位学生都有座位的最少移动次数",
        "hardRate": "EASY",
        "passRate": "85.10%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-moves-to-seat-everyone/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-moves-to-seat-everyone/solution",
        "problemsDesc": "<p>一个房间里有 <code>n</code>&nbsp;个座位和 <code>n</code>&nbsp;名学生，房间用一个数轴表示。给你一个长度为 <code>n</code>&nbsp;的数组&nbsp;<code>seats</code>&nbsp;，其中&nbsp;<code>seats[i]</code> 是第 <code>i</code>&nbsp;个座位的位置。同时给你一个长度为 <code>n</code>&nbsp;的数组&nbsp;<code>students</code>&nbsp;，其中&nbsp;<code>students[j]</code>&nbsp;是第 <code>j</code>&nbsp;位学生的位置。</p>\n\n<p>你可以执行以下操作任意次：</p>\n\n<ul>\n\t<li>增加或者减少第&nbsp;<code>i</code>&nbsp;位学生的位置，每次变化量为 <code>1</code>&nbsp;（也就是将第 <code>i</code>&nbsp;位学生从位置 <code>x</code>&nbsp;移动到 <code>x + 1</code>&nbsp;或者 <code>x - 1</code>）</li>\n</ul>\n\n<p>请你返回使所有学生都有座位坐的 <strong>最少移动次数</strong>&nbsp;，并确保没有两位学生的座位相同。</p>\n\n<p>请注意，初始时有可能有多个座位或者多位学生在 <strong>同一</strong>&nbsp;位置。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>seats = [3,1,5], students = [2,7,4]\n<b>输出：</b>4\n<b>解释：</b>学生移动方式如下：\n- 第一位学生从位置 2 移动到位置 1 ，移动 1 次。\n- 第二位学生从位置 7 移动到位置 5 ，移动 2 次。\n- 第三位学生从位置 4 移动到位置 3 ，移动 1 次。\n总共 1 + 2 + 1 = 4 次移动。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>seats = [4,1,5,9], students = [1,3,2,6]\n<b>输出：</b>7\n<strong>解释：</strong>学生移动方式如下：\n- 第一位学生不移动。\n- 第二位学生从位置 3 移动到位置 4 ，移动 1 次。\n- 第三位学生从位置 2 移动到位置 5 ，移动 3 次。\n- 第四位学生从位置 6 移动到位置 9 ，移动 3 次。\n总共 0 + 1 + 3 + 3 = 7 次移动。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>seats = [2,2,6,6], students = [1,3,2,6]\n<b>输出：</b>4\n<b>解释：</b>学生移动方式如下：\n- 第一位学生从位置 1 移动到位置 2 ，移动 1 次。\n- 第二位学生从位置 3 移动到位置 6 ，移动 3 次。\n- 第三位学生不移动。\n- 第四位学生不移动。\n总共 1 + 3 + 0 + 0 = 4 次移动。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == seats.length == students.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= seats[i], students[j] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2038.如果相邻两个颜色均相同则删除当前颜色",
        "hardRate": "MEDIUM",
        "passRate": "63.37%",
        "problemsUrl": "https://leetcode.cn/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/solution",
        "problemsDesc": "<p>总共有 <code>n</code>&nbsp;个颜色片段排成一列，每个颜色片段要么是&nbsp;<code>'A'</code>&nbsp;要么是&nbsp;<code>'B'</code>&nbsp;。给你一个长度为&nbsp;<code>n</code>&nbsp;的字符串&nbsp;<code>colors</code>&nbsp;，其中&nbsp;<code>colors[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个颜色片段的颜色。</p>\n\n<p>Alice 和 Bob 在玩一个游戏，他们 <strong>轮流</strong>&nbsp;从这个字符串中删除颜色。Alice <strong>先手</strong>&nbsp;。</p>\n\n<ul>\n\t<li>如果一个颜色片段为 <code>'A'</code>&nbsp;且 <strong>相邻两个颜色</strong>&nbsp;都是颜色 <code>'A'</code>&nbsp;，那么 Alice 可以删除该颜色片段。Alice&nbsp;<strong>不可以</strong>&nbsp;删除任何颜色&nbsp;<code>'B'</code>&nbsp;片段。</li>\n\t<li>如果一个颜色片段为 <code>'B'</code>&nbsp;且 <strong>相邻两个颜色</strong>&nbsp;都是颜色 <code>'B'</code>&nbsp;，那么 Bob 可以删除该颜色片段。Bob <strong>不可以</strong>&nbsp;删除任何颜色 <code>'A'</code>&nbsp;片段。</li>\n\t<li>Alice 和 Bob <strong>不能</strong>&nbsp;从字符串两端删除颜色片段。</li>\n\t<li>如果其中一人无法继续操作，则该玩家 <b>输</b>&nbsp;掉游戏且另一玩家 <strong>获胜</strong>&nbsp;。</li>\n</ul>\n\n<p>假设 Alice 和 Bob 都采用最优策略，如果 Alice 获胜，请返回&nbsp;<code>true</code>，否则 Bob 获胜，返回<em>&nbsp;</em><code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>colors = \"AAABABB\"\n<b>输出：</b>true\n<b>解释：</b>\nA<em><strong>A</strong></em>ABABB -&gt; AABABB\nAlice 先操作。\n她删除从左数第二个 'A' ，这也是唯一一个相邻颜色片段都是 'A' 的 'A' 。\n\n现在轮到 Bob 操作。\nBob 无法执行任何操作，因为没有相邻位置都是 'B' 的颜色片段 'B' 。\n因此，Alice 获胜，返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>colors = \"AA\"\n<b>输出：</b>false\n<strong>解释：</strong>\nAlice 先操作。\n只有 2 个 'A' 且它们都在字符串的两端，所以她无法执行任何操作。\n因此，Bob 获胜，返回 false 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>colors = \"ABBBBBBBAAA\"\n<b>输出：</b>false\n<strong>解释：</strong>\nABBBBBBBA<em><strong>A</strong></em>A -&gt; ABBBBBBBAA\nAlice 先操作。\n她唯一的选择是删除从右数起第二个 'A' 。\n\nABBBB<strong><em>B</em></strong>BBAA -&gt; ABBBBBBAA\n接下来轮到 Bob 操作。\n他有许多选择，他可以选择任何一个 'B' 删除。\n\n然后轮到 Alice 操作，她无法删除任何片段。\n所以 Bob 获胜，返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;colors.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>colors</code>&nbsp;只包含字母&nbsp;<code>'A'</code>&nbsp;和&nbsp;<code>'B'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2039.网络空闲的时刻",
        "hardRate": "MEDIUM",
        "passRate": "55.86%",
        "problemsUrl": "https://leetcode.cn/problems/the-time-when-the-network-becomes-idle/",
        "solutionsUrl": "https://leetcode.cn/problems/the-time-when-the-network-becomes-idle/solution",
        "problemsDesc": "<p>给你一个有 <code>n</code>&nbsp;个服务器的计算机网络，服务器编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。同时给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code>&nbsp;表示服务器&nbsp;<code>u<sub>i</sub></code> 和&nbsp;<code>v<sub>i</sub></code><sub>&nbsp;</sub>之间有一条信息线路，在&nbsp;<strong>一秒</strong>&nbsp;内它们之间可以传输&nbsp;<strong>任意</strong>&nbsp;数目的信息。再给你一个长度为 <code>n</code>&nbsp;且下标从&nbsp;<strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>patience</code>&nbsp;。</p>\n\n<p>题目保证所有服务器都是 <b>相通</b>&nbsp;的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。</p>\n\n<p>编号为 <code>0</code>&nbsp;的服务器是 <strong>主</strong>&nbsp;服务器，其他服务器为 <strong>数据</strong>&nbsp;服务器。每个数据服务器都要向主服务器发送信息，并等待回复。信息在服务器之间按 <strong>最优</strong>&nbsp;线路传输，也就是说每个信息都会以 <strong>最少时间</strong>&nbsp;到达主服务器。主服务器会处理 <strong>所有</strong>&nbsp;新到达的信息并 <strong>立即</strong>&nbsp;按照每条信息来时的路线 <strong>反方向</strong> 发送回复信息。</p>\n\n<p>在 <code>0</code>&nbsp;秒的开始，所有数据服务器都会发送各自需要处理的信息。从第 <code>1</code>&nbsp;秒开始，<strong>每</strong>&nbsp;一秒最 <strong>开始</strong>&nbsp;时，每个数据服务器都会检查它是否收到了主服务器的回复信息（包括新发出信息的回复信息）：</p>\n\n<ul>\n\t<li>如果还没收到任何回复信息，那么该服务器会周期性&nbsp;<strong>重发</strong>&nbsp;信息。数据服务器&nbsp;<code>i</code>&nbsp;每&nbsp;<code>patience[i]</code>&nbsp;秒都会重发一条信息，也就是说，数据服务器&nbsp;<code>i</code>&nbsp;在上一次发送信息给主服务器后的 <code>patience[i]</code>&nbsp;秒 <strong>后</strong>&nbsp;会重发一条信息给主服务器。</li>\n\t<li>否则，该数据服务器&nbsp;<strong>不会重发</strong>&nbsp;信息。</li>\n</ul>\n\n<p>当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为 <strong>空闲</strong>&nbsp;状态。</p>\n\n<p>请返回计算机网络变为 <strong>空闲</strong>&nbsp;状态的&nbsp;<strong>最早秒数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"example 1\" src=\"https://assets.leetcode.com/uploads/2021/09/22/quiet-place-example1.png\" style=\"width: 750px; height: 384px;\"></p>\n\n<pre><b>输入：</b>edges = [[0,1],[1,2]], patience = [0,2,1]\n<b>输出：</b>8\n<strong>解释：</strong>\n0 秒最开始时，\n- 数据服务器 1 给主服务器发出信息（用 1A 表示）。\n- 数据服务器 2 给主服务器发出信息（用 2A 表示）。\n\n1 秒时，\n- 信息 1A 到达主服务器，主服务器立刻处理信息 1A 并发出 1A 的回复信息。\n- 数据服务器 1 还没收到任何回复。距离上次发出信息过去了 1 秒（1 &lt; patience[1] = 2），所以不会重发信息。\n- 数据服务器 2 还没收到任何回复。距离上次发出信息过去了 1 秒（1 == patience[2] = 1），所以它重发一条信息（用 2B 表示）。\n\n2 秒时，\n- 回复信息 1A 到达服务器 1 ，服务器 1 不会再重发信息。\n- 信息 2A 到达主服务器，主服务器立刻处理信息 2A 并发出 2A 的回复信息。\n- 服务器 2 重发一条信息（用 2C 表示）。\n...\n4 秒时，\n- 回复信息 2A 到达服务器 2 ，服务器 2 不会再重发信息。\n...\n7 秒时，回复信息 2D 到达服务器 2 。\n\n从第 8 秒开始，不再有任何信息在服务器之间传输，也不再有信息到达服务器。\n所以第 8 秒是网络变空闲的最早时刻。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"example 2\" src=\"https://assets.leetcode.com/uploads/2021/09/04/network_a_quiet_place_2.png\" style=\"width: 100px; height: 85px;\"></p>\n\n<pre><b>输入：</b>edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]\n<b>输出：</b>3\n<b>解释：</b>数据服务器 1 和 2 第 2 秒初收到回复信息。\n从第 3 秒开始，网络变空闲。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == patience.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>patience[0] == 0</code></li>\n\t<li>对于&nbsp;<code>1 &lt;= i &lt; n</code> ，满足&nbsp;<code>1 &lt;= patience[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= edges.length &lt;= min(10<sup>5</sup>, n * (n - 1) / 2)</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n\t<li>不会有重边。</li>\n\t<li>每个服务器都直接或间接与别的服务器相连。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2040.两个有序数组的第 K 小乘积",
        "hardRate": "HARD",
        "passRate": "33.47%",
        "problemsUrl": "https://leetcode.cn/problems/kth-smallest-product-of-two-sorted-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-smallest-product-of-two-sorted-arrays/solution",
        "problemsDesc": "给你两个 <strong>从小到大排好序</strong>&nbsp;且下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;以及一个整数&nbsp;<code>k</code>&nbsp;，请你返回第<em>&nbsp;</em><code>k</code>&nbsp;（从 <strong>1</strong>&nbsp;开始编号）小的&nbsp;<code>nums1[i] * nums2[j]</code><em>&nbsp;</em>的乘积，其中<em>&nbsp;</em><code>0 &lt;= i &lt; nums1.length</code><em> </em>且<em> </em><code>0 &lt;= j &lt; nums2.length</code>&nbsp;。\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [2,5], nums2 = [3,4], k = 2\n<b>输出：</b>8\n<b>解释：</b>第 2 小的乘积计算如下：\n- nums1[0] * nums2[0] = 2 * 3 = 6\n- nums1[0] * nums2[1] = 2 * 4 = 8\n第 2 小的乘积为 8 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [-4,-2,0,3], nums2 = [2,4], k = 6\n<b>输出：</b>0\n<strong>解释：</strong>第 6 小的乘积计算如下：\n- nums1[0] * nums2[1] = (-4) * 4 = -16\n- nums1[0] * nums2[0] = (-4) * 2 = -8\n- nums1[1] * nums2[1] = (-2) * 4 = -8\n- nums1[1] * nums2[0] = (-2) * 2 = -4\n- nums1[2] * nums2[0] = 0 * 2 = 0\n- nums1[2] * nums2[1] = 0 * 4 = 0\n第 6 小的乘积为 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums1 = [-2,-1,0,1,2], nums2 = [-3,-1,2,4,5], k = 3\n<b>输出：</b>-6\n<b>解释：</b>第 3 小的乘积计算如下：\n- nums1[0] * nums2[4] = (-2) * 5 = -10\n- nums1[0] * nums2[3] = (-2) * 4 = -8\n- nums1[4] * nums2[0] = 2 * (-3) = -6\n第 3 小的乘积为 -6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums1[i], nums2[j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums1.length * nums2.length</code></li>\n\t<li><code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;都是从小到大排好序的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2041.面试中被录取的候选人",
        "hardRate": "MEDIUM",
        "passRate": "76.38%",
        "problemsUrl": "https://leetcode.cn/problems/accepted-candidates-from-the-interviews/",
        "solutionsUrl": "https://leetcode.cn/problems/accepted-candidates-from-the-interviews/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2042.检查句子中的数字是否递增",
        "hardRate": "EASY",
        "passRate": "71.97%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-numbers-are-ascending-in-a-sentence/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-numbers-are-ascending-in-a-sentence/solution",
        "problemsDesc": "<p>句子是由若干 <strong>token</strong> 组成的一个列表，<strong>token</strong> 间用 <strong>单个</strong> 空格分隔，句子没有前导或尾随空格。每个 token 要么是一个由数字 <code>0-9</code> 组成的不含前导零的 <strong>正整数</strong>&nbsp;，要么是一个由小写英文字母组成的 <strong>单词</strong> 。</p>\n\n<ul>\n\t<li>示例，<code>\"a puppy has 2 eyes 4 legs\"</code> 是一个由 7 个 token 组成的句子：<code>\"2\"</code> 和 <code>\"4\"</code> 是数字，其他像&nbsp;<code>\"puppy\"</code> 这样的 tokens 属于单词。</li>\n</ul>\n\n<p>给你一个表示句子的字符串 <code>s</code> ，你需要检查 <code>s</code> 中的 <strong>全部</strong> 数字是否从左到右严格递增（即，除了最后一个数字，<code>s</code> 中的 <strong>每个</strong> 数字都严格小于它 <strong>右侧</strong> 的数字）。</p>\n\n<p>如果满足题目要求，返回 <code>true</code>&nbsp;，否则，返回<em> </em><code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"example-1\" src=\"https://assets.leetcode.com/uploads/2021/09/30/example1.png\" style=\"width: 637px; height: 48px;\" /></p>\n\n<pre>\n<strong>输入：</strong>s = \"1 box has 3 blue 4 red 6 green and 12 yellow marbles\"\n<strong>输出：</strong>true\n<strong>解释：</strong>句子中的数字是：1, 3, 4, 6, 12 。\n这些数字是按从左到右严格递增的 1 &lt; 3 &lt; 4 &lt; 6 &lt; 12 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"hello world 5 x 5\"\n<strong>输出：</strong>false\n<strong>解释：</strong>句子中的数字是：<em><strong>5</strong></em>, <strong><em>5</em></strong> 。这些数字不是严格递增的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"example-3\" src=\"https://assets.leetcode.com/uploads/2021/09/30/example3.png\" style=\"width: 794px; height: 48px;\" /></p>\n\n<pre>\n<strong>输入：</strong>s = \"sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s\"\n<strong>输出：</strong>false\n<strong>解释：</strong>s 中的数字是：7, <em><strong>51</strong></em>, <em><strong>50</strong></em>, 60 。这些数字不是严格递增的。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"4 5 11 26\"\n<strong>输出：</strong>true\n<strong>解释：</strong>s 中的数字是：4, 5, 11, 26 。\n这些数字是按从左到右严格递增的：4 &lt; 5 &lt; 11 &lt; 26 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= s.length &lt;= 200</code></li>\n\t<li><code>s</code> 由小写英文字母、空格和数字 <code>0</code> 到 <code>9</code> 组成（包含 <code>0</code> 和 <code>9</code>）</li>\n\t<li><code>s</code> 中数字 token 的数目在 <code>2</code> 和 <code>100</code> 之间（包含 <code>2</code> 和 <code>100</code>）</li>\n\t<li><code>s</code> 中的 token 之间由单个空格分隔</li>\n\t<li><code>s</code> 中至少有 <strong>两个</strong> 数字</li>\n\t<li><code>s</code> 中的每个数字都是一个 <strong>小于</strong> <code>100</code> 的 <strong>正</strong> 数，且不含前导零</li>\n\t<li><code>s</code> 不含前导或尾随空格</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2043.简易银行系统",
        "hardRate": "MEDIUM",
        "passRate": "66.01%",
        "problemsUrl": "https://leetcode.cn/problems/simple-bank-system/",
        "solutionsUrl": "https://leetcode.cn/problems/simple-bank-system/solution",
        "problemsDesc": "<p>你的任务是为一个很受欢迎的银行设计一款程序，以自动化执行所有传入的交易（转账，存款和取款）。银行共有 <code>n</code> 个账户，编号从 <code>1</code> 到 <code>n</code> 。每个账号的初始余额存储在一个下标从 <strong>0</strong> 开始的整数数组 <code>balance</code>&nbsp;中，其中第 <code>(i + 1)</code> 个账户的初始余额是 <code>balance[i]</code> 。</p>\n\n<p>请你执行所有 <strong>有效的</strong> 交易。如果满足下面全部条件，则交易 <strong>有效</strong> ：</p>\n\n<ul>\n\t<li>指定的账户数量在 <code>1</code> 和 <code>n</code> 之间，且</li>\n\t<li>取款或者转账需要的钱的总数 <strong>小于或者等于</strong> 账户余额。</li>\n</ul>\n\n<p>实现 <code>Bank</code> 类：</p>\n\n<ul>\n\t<li><code>Bank(long[] balance)</code> 使用下标从 <strong>0</strong> 开始的整数数组 <code>balance</code> 初始化该对象。</li>\n\t<li><code>boolean transfer(int account1, int account2, long money)</code> 从编号为&nbsp;<code>account1</code> 的账户向编号为 <code>account2</code> 的账户转帐 <code>money</code> 美元。如果交易成功，返回 <code>true</code> ，否则，返回 <code>false</code> 。</li>\n\t<li><code>boolean deposit(int account, long money)</code> 向编号为&nbsp;<code>account</code> 的账户存款 <code>money</code> 美元。如果交易成功，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n\t<li><code>boolean withdraw(int account, long money)</code> 从编号为 <code>account</code> 的账户取款 <code>money</code> 美元。如果交易成功，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>：\n[\"Bank\", \"withdraw\", \"transfer\", \"deposit\", \"transfer\", \"withdraw\"]\n[[[10, 100, 20, 50, 30]], [3, 10], [5, 1, 20], [5, 20], [3, 4, 15], [10, 50]]\n<strong>输出：</strong>\n[null, true, true, true, false, false]\n\n<strong>解释：</strong>\nBank bank = new Bank([10, 100, 20, 50, 30]);\nbank.withdraw(3, 10);    // 返回 true ，账户 3 的余额是 $20 ，所以可以取款 $10 。\n                         // 账户 3 余额为 $20 - $10 = $10 。\nbank.transfer(5, 1, 20); // 返回 true ，账户 5 的余额是 $30 ，所以可以转账 $20 。\n                         // 账户 5 的余额为 $30 - $20 = $10 ，账户 1 的余额为 $10 + $20 = $30 。\nbank.deposit(5, 20);     // 返回 true ，可以向账户 5 存款 $20 。\n                         // 账户 5 的余额为 $10 + $20 = $30 。\nbank.transfer(3, 4, 15); // 返回 false ，账户 3 的当前余额是 $10 。\n                         // 所以无法转账 $15 。\nbank.withdraw(10, 50);   // 返回 false ，交易无效，因为账户 10 并不存在。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == balance.length</code></li>\n\t<li><code>1 &lt;= n, account, account1, account2 &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= balance[i], money &lt;= 10<sup>12</sup></code></li>\n\t<li><code>transfer</code>, <code>deposit</code>, <code>withdraw</code> 三个函数，<strong>每个</strong> 最多调用 <code>10<sup>4</sup></code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2044.统计按位或能得到最大值的子集数目",
        "hardRate": "MEDIUM",
        "passRate": "81.79%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-maximum-bitwise-or-subsets/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-maximum-bitwise-or-subsets/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，请你找出 <code>nums</code> 子集 <strong>按位或</strong> 可能得到的<strong> </strong><strong>最大值</strong> ，并返回按位或能得到最大值的 <strong>不同非空子集的数目</strong> 。</p>\n\n<p>如果数组 <code>a</code> 可以由数组 <code>b</code> 删除一些元素（或不删除）得到，则认为数组 <code>a</code> 是数组 <code>b</code> 的一个 <strong>子集</strong> 。如果选中的元素下标位置不一样，则认为两个子集 <strong>不同</strong> 。</p>\n\n<p>对数组 <code>a</code> 执行 <strong>按位或</strong>&nbsp;，结果等于 <code>a[0] <strong>OR</strong> a[1] <strong>OR</strong> ... <strong>OR</strong> a[a.length - 1]</code>（下标从 <strong>0</strong> 开始）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>子集按位或能得到的最大值是 3 。有 2 个子集按位或可以得到 3 ：\n- [3]\n- [3,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,2]\n<strong>输出：</strong>7\n<strong>解释：</strong>[2,2,2] 的所有非空子集的按位或都可以得到 2 。总共有 2<sup>3</sup> - 1 = 7 个子集。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,1,5]\n<strong>输出：</strong>6\n<strong>解释：</strong>子集按位或可能的最大值是 7 。有 6 个子集按位或可以得到 7 ：\n- [3,5]\n- [3,1,5]\n- [3,2,5]\n- [3,2,1,5]\n- [2,5]\n- [2,1,5]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 16</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2045.到达目的地的第二短时间",
        "hardRate": "HARD",
        "passRate": "53.33%",
        "problemsUrl": "https://leetcode.cn/problems/second-minimum-time-to-reach-destination/",
        "solutionsUrl": "https://leetcode.cn/problems/second-minimum-time-to-reach-destination/solution",
        "problemsDesc": "<p>城市用一个 <strong>双向连通</strong> 图表示，图中有 <code>n</code> 个节点，从 <code>1</code> 到 <code>n</code> 编号（包含 <code>1</code> 和 <code>n</code>）。图中的边用一个二维整数数组 <code>edges</code> 表示，其中每个 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code>&nbsp;表示一条节点&nbsp;<code>u<sub>i</sub></code> 和节点&nbsp;<code>v<sub>i</sub></code> 之间的双向连通边。每组节点对由 <strong>最多一条</strong> 边连通，顶点不存在连接到自身的边。穿过任意一条边的时间是 <code>time</code>&nbsp;分钟。</p>\n\n<p>每个节点都有一个交通信号灯，每 <code>change</code> 分钟改变一次，从绿色变成红色，再由红色变成绿色，循环往复。所有信号灯都&nbsp;<strong>同时</strong> 改变。你可以在 <strong>任何时候</strong> 进入某个节点，但是 <strong>只能</strong> 在节点&nbsp;<strong>信号灯是绿色时</strong> 才能离开。如果信号灯是&nbsp; <strong>绿色</strong> ，你 <strong>不能</strong> 在节点等待，必须离开。</p>\n\n<p><strong>第二小的值</strong> 是&nbsp;<strong>严格大于</strong> 最小值的所有值中最小的值。</p>\n\n<ul>\n\t<li>例如，<code>[2, 3, 4]</code> 中第二小的值是 <code>3</code> ，而 <code>[2, 2, 4]</code> 中第二小的值是 <code>4</code> 。</li>\n</ul>\n\n<p>给你 <code>n</code>、<code>edges</code>、<code>time</code> 和 <code>change</code> ，返回从节点 <code>1</code> 到节点 <code>n</code> 需要的 <strong>第二短时间</strong> 。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>你可以 <strong>任意次</strong> 穿过任意顶点，<strong>包括</strong> <code>1</code> 和 <code>n</code> 。</li>\n\t<li>你可以假设在 <strong>启程时</strong> ，所有信号灯刚刚变成 <strong>绿色</strong> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/29/e1.png\" style=\"width: 200px; height: 250px;\" />        <img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/29/e2.png\" style=\"width: 200px; height: 250px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5\n<strong>输出：</strong>13\n<strong>解释：</strong>\n上面的左图展现了给出的城市交通图。\n右图中的蓝色路径是最短时间路径。\n花费的时间是：\n- 从节点 1 开始，总花费时间=0\n- 1 -&gt; 4：3 分钟，总花费时间=3\n- 4 -&gt; 5：3 分钟，总花费时间=6\n因此需要的最小时间是 6 分钟。\n\n右图中的红色路径是第二短时间路径。\n- 从节点 1 开始，总花费时间=0\n- 1 -&gt; 3：3 分钟，总花费时间=3\n- 3 -&gt; 4：3 分钟，总花费时间=6\n- 在节点 4 等待 4 分钟，总花费时间=10\n- 4 -&gt; 5：3 分钟，总花费时间=13\n因此第二短时间是 13 分钟。      \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/29/eg2.png\" style=\"width: 225px; height: 50px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 2, edges = [[1,2]], time = 3, change = 2\n<strong>输出：</strong>11\n<strong>解释：</strong>\n最短时间路径是 1 -&gt; 2 ，总花费时间 = 3 分钟\n第二短时间路径是 1 -&gt; 2 -&gt; 1 -&gt; 2 ，总花费时间 = 11 分钟</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>n - 1 &lt;= edges.length &lt;= min(2 * 10<sup>4</sup>, n * (n - 1) / 2)</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n\t<li>不含重复边</li>\n\t<li>每个节点都可以从其他节点直接或者间接到达</li>\n\t<li><code>1 &lt;= time, change &lt;= 10<sup>3</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2046.给按照绝对值排序的链表排序",
        "hardRate": "MEDIUM",
        "passRate": "64.14%",
        "problemsUrl": "https://leetcode.cn/problems/sort-linked-list-already-sorted-using-absolute-values/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-linked-list-already-sorted-using-absolute-values/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2047.句子中的有效单词数",
        "hardRate": "EASY",
        "passRate": "38.62%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-valid-words-in-a-sentence/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-valid-words-in-a-sentence/solution",
        "problemsDesc": "<p>句子仅由小写字母（<code>'a'</code> 到 <code>'z'</code>）、数字（<code>'0'</code> 到 <code>'9'</code>）、连字符（<code>'-'</code>）、标点符号（<code>'!'</code>、<code>'.'</code> 和 <code>','</code>）以及空格（<code>' '</code>）组成。每个句子可以根据空格分解成 <strong>一个或者多个 token</strong> ，这些 token 之间由一个或者多个空格 <code>' '</code> 分隔。</p>\n\n<p>如果一个 token 同时满足下述条件，则认为这个 token 是一个有效单词：</p>\n\n<ul>\n\t<li>仅由小写字母、连字符和/或标点（不含数字）\b组成。</li>\n\t<li><strong>至多一个</strong> 连字符 <code>'-'</code> 。如果存在，连字符两侧应当都存在小写字母（<code>\"a-b\"</code> 是一个有效单词，但 <code>\"-ab\"</code> 和 <code>\"ab-\"</code> 不是有效单词）。</li>\n\t<li><strong>至多一个 </strong>标点符号。如果存在，标点符号应当位于 token 的 <strong>末尾</strong> 。</li>\n</ul>\n\n<p>这里给出几个有效单词的例子：<code>\"a-b.\"</code>、<code>\"afad\"</code>、<code>\"ba-c\"</code>、<code>\"a!\"</code> 和 <code>\"!\"</code> 。</p>\n\n<p>给你一个字符串 <code>sentence</code> ，请你找出并返回<em> </em><code>sentence</code> 中<strong> 有效单词的数目</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"<em><strong>cat</strong></em> <em><strong>and</strong></em>  <em><strong>dog</strong></em>\"\n<strong>输出：</strong>3\n<strong>解释：</strong>句子中的有效单词是 \"cat\"、\"and\" 和 \"dog\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"!this  1-s b8d!\"\n<strong>输出：</strong>0\n<strong>解释：</strong>句子中没有有效单词\n\"!this\" 不是有效单词，因为它以一个标点开头\n\"1-s\" 和 \"b8d\" 也不是有效单词，因为它们都包含数字\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"<em><strong>alice</strong></em> <em><strong>and</strong></em>  <em><strong>bob</strong></em> <em><strong>are</strong></em> <em><strong>playing</strong></em> stone-game10\"\n<strong>输出：</strong>5\n<strong>解释：</strong>句子中的有效单词是 \"alice\"、\"and\"、\"bob\"、\"are\" 和 \"playing\"\n\"stone-game10\" 不是有效单词，因为它含有数字\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentence.length &lt;= 1000</code></li>\n\t<li><code>sentence</code> 由小写英文字母、数字（<code>0-9</code>）、以及字符（<code>' '</code>、<code>'-'</code>、<code>'!'</code>、<code>'.'</code> 和 <code>','</code>）组成</li>\n\t<li>句子中至少有 <code>1</code> 个 token</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2048.下一个更大的数值平衡数",
        "hardRate": "MEDIUM",
        "passRate": "45.42%",
        "problemsUrl": "https://leetcode.cn/problems/next-greater-numerically-balanced-number/",
        "solutionsUrl": "https://leetcode.cn/problems/next-greater-numerically-balanced-number/solution",
        "problemsDesc": "<p>如果整数&nbsp; <code>x</code> 满足：对于每个数位&nbsp;<code>d</code> ，这个数位&nbsp;<strong>恰好</strong> 在 <code>x</code> 中出现 <code>d</code> 次。那么整数 <code>x</code> 就是一个 <strong>数值平衡数</strong> 。</p>\n\n<p>给你一个整数 <code>n</code> ，请你返回 <strong>严格大于</strong> <code>n</code> 的 <strong>最小数值平衡数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>22\n<strong>解释：</strong>\n22 是一个数值平衡数，因为：\n- 数字 2 出现 2 次 \n这也是严格大于 1 的最小数值平衡数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1000\n<strong>输出：</strong>1333\n<strong>解释：</strong>\n1333 是一个数值平衡数，因为：\n- 数字 1 出现 1 次。\n- 数字 3 出现 3 次。 \n这也是严格大于 1000 的最小数值平衡数。\n注意，1022 不能作为本输入的答案，因为数字 0 的出现次数超过了 0 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3000\n<strong>输出：</strong>3133\n<strong>解释：</strong>\n3133 是一个数值平衡数，因为：\n- 数字 1 出现 1 次。\n- 数字 3 出现 3 次。 \n这也是严格大于 3000 的最小数值平衡数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2049.统计最高分的节点数目",
        "hardRate": "MEDIUM",
        "passRate": "51.78%",
        "problemsUrl": "https://leetcode.cn/problems/count-nodes-with-the-highest-score/",
        "solutionsUrl": "https://leetcode.cn/problems/count-nodes-with-the-highest-score/solution",
        "problemsDesc": "<p>给你一棵根节点为 <code>0</code> 的&nbsp;<strong>二叉树</strong>&nbsp;，它总共有 <code>n</code>&nbsp;个节点，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。同时给你一个下标从&nbsp;<strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>parents</code>&nbsp;表示这棵树，其中&nbsp;<code>parents[i]</code>&nbsp;是节点 <code>i</code>&nbsp;的父节点。由于节点 <code>0</code>&nbsp;是根，所以&nbsp;<code>parents[0] == -1</code>&nbsp;。</p>\n\n<p>一个子树的 <strong>大小</strong>&nbsp;为这个子树内节点的数目。每个节点都有一个与之关联的&nbsp;<strong>分数</strong>&nbsp;。求出某个节点分数的方法是，将这个节点和与它相连的边全部 <strong>删除</strong>&nbsp;，剩余部分是若干个 <strong>非空</strong>&nbsp;子树，这个节点的 <strong>分数</strong>&nbsp;为所有这些子树 <strong>大小的乘积</strong>&nbsp;。</p>\n\n<p>请你返回有 <strong>最高得分</strong>&nbsp;节点的 <strong>数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<p><img alt=\"example-1\" src=\"https://assets.leetcode.com/uploads/2021/10/03/example-1.png\" style=\"width: 604px; height: 266px;\"></p>\n\n<pre><b>输入：</b>parents = [-1,2,0,2,0]\n<b>输出：</b>3\n<strong>解释：</strong>\n- 节点 0 的分数为：3 * 1 = 3\n- 节点 1 的分数为：4 = 4\n- 节点 2 的分数为：1 * 1 * 2 = 2\n- 节点 3 的分数为：4 = 4\n- 节点 4 的分数为：4 = 4\n最高得分为 4 ，有三个节点得分为 4 （分别是节点 1，3 和 4 ）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"example-2\" src=\"https://assets.leetcode.com/uploads/2021/10/03/example-2.png\" style=\"width: 95px; height: 143px;\"></p>\n\n<pre><b>输入：</b>parents = [-1,2,0]\n<b>输出：</b>2\n<strong>解释：</strong>\n- 节点 0 的分数为：2 = 2\n- 节点 1 的分数为：2 = 2\n- 节点 2 的分数为：1 * 1 = 1\n最高分数为 2 ，有两个节点分数为 2 （分别为节点 0 和 1 ）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == parents.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>parents[0] == -1</code></li>\n\t<li>对于&nbsp;<code>i != 0</code>&nbsp;，有&nbsp;<code>0 &lt;= parents[i] &lt;= n - 1</code></li>\n\t<li><code>parents</code>&nbsp;表示一棵二叉树。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2050.并行课程 III",
        "hardRate": "HARD",
        "passRate": "58.52%",
        "problemsUrl": "https://leetcode.cn/problems/parallel-courses-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/parallel-courses-iii/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;，表示有&nbsp;<code>n</code>&nbsp;节课，课程编号从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;。同时给你一个二维整数数组&nbsp;<code>relations</code>&nbsp;，其中&nbsp;<code>relations[j] = [prevCourse<sub>j</sub>, nextCourse<sub>j</sub>]</code>&nbsp;，表示课程&nbsp;<code>prevCourse<sub>j</sub></code>&nbsp;必须在课程&nbsp;<code>nextCourse<sub>j</sub></code>&nbsp;<strong>之前</strong>&nbsp;完成（先修课的关系）。同时给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>time</code>&nbsp;，其中&nbsp;<code>time[i]</code>&nbsp;表示完成第&nbsp;<code>(i+1)</code>&nbsp;门课程需要花费的 <strong>月份</strong>&nbsp;数。</p>\n\n<p>请你根据以下规则算出完成所有课程所需要的 <strong>最少</strong>&nbsp;月份数：</p>\n\n<ul>\n\t<li>如果一门课的所有先修课都已经完成，你可以在 <strong>任意</strong>&nbsp;时间开始这门课程。</li>\n\t<li>你可以&nbsp;<strong>同时</strong>&nbsp;上&nbsp;<strong>任意门课程</strong>&nbsp;。</li>\n</ul>\n\n<p>请你返回完成所有课程所需要的 <strong>最少</strong>&nbsp;月份数。</p>\n\n<p><strong>注意：</strong>测试数据保证一定可以完成所有课程（也就是先修课的关系构成一个有向无环图）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/07/ex1.png\" style=\"width: 392px; height: 232px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 3, relations = [[1,3],[2,3]], time = [3,2,5]\n<b>输出：</b>8\n<b>解释：</b>上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。\n你可以在月份 0 同时开始课程 1 和 2 。\n课程 1 花费 3 个月，课程 2 花费 2 个月。\n所以，最早开始课程 3 的时间是月份 3 ，完成所有课程所需时间为 3 + 5 = 8 个月。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/07/ex2.png\" style=\"width: 500px; height: 365px;\"></strong></p>\n\n<pre><b>输入：</b>n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5]\n<b>输出：</b>12\n<b>解释：</b>上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。\n你可以在月份 0 同时开始课程 1 ，2 和 3 。\n在月份 1，2 和 3 分别完成这三门课程。\n课程 4 需在课程 3 之后开始，也就是 3 个月后。课程 4 在 3 + 4 = 7 月完成。\n课程 5 需在课程 1，2，3 和 4 之后开始，也就是在 max(1,2,3,7) = 7 月开始。\n所以完成所有课程所需的最少时间为 7 + 5 = 12 个月。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= relations.length &lt;= min(n * (n - 1) / 2, 5 * 10<sup>4</sup>)</code></li>\n\t<li><code>relations[j].length == 2</code></li>\n\t<li><code>1 &lt;= prevCourse<sub>j</sub>, nextCourse<sub>j</sub> &lt;= n</code></li>\n\t<li><code>prevCourse<sub>j</sub> != nextCourse<sub>j</sub></code></li>\n\t<li>所有的先修课程对&nbsp;<code>[prevCourse<sub>j</sub>, nextCourse<sub>j</sub>]</code>&nbsp;都是 <strong>互不相同</strong>&nbsp;的。</li>\n\t<li><code>time.length == n</code></li>\n\t<li><code>1 &lt;= time[i] &lt;= 10<sup>4</sup></code></li>\n\t<li>先修课程图是一个有向无环图。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2051.商店中每个成员的级别",
        "hardRate": "MEDIUM",
        "passRate": "65.16%",
        "problemsUrl": "https://leetcode.cn/problems/the-category-of-each-member-in-the-store/",
        "solutionsUrl": "https://leetcode.cn/problems/the-category-of-each-member-in-the-store/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2052.将句子分隔成行的最低成本",
        "hardRate": "MEDIUM",
        "passRate": "48.24%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-separate-sentence-into-rows/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-separate-sentence-into-rows/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2053.数组中第 K 个独一无二的字符串",
        "hardRate": "EASY",
        "passRate": "71.13%",
        "problemsUrl": "https://leetcode.cn/problems/kth-distinct-string-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-distinct-string-in-an-array/solution",
        "problemsDesc": "<p><strong>独一无二的字符串</strong>&nbsp;指的是在一个数组中只出现过 <strong>一次</strong>&nbsp;的字符串。</p>\n\n<p>给你一个字符串数组&nbsp;<code>arr</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;，请你返回&nbsp;<code>arr</code>&nbsp;中第&nbsp;<code>k</code>&nbsp;个&nbsp;<strong>独一无二的字符串</strong>&nbsp;。如果&nbsp;<strong>少于</strong>&nbsp;<code>k</code>&nbsp;个独一无二的字符串，那么返回&nbsp;<strong>空字符串</strong>&nbsp;<code>\"\"</code>&nbsp;。</p>\n\n<p>注意，按照字符串在原数组中的 <strong>顺序</strong>&nbsp;找到第 <code>k</code>&nbsp;个独一无二字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><b>输入：</b>arr = [\"d\",\"b\",\"c\",\"b\",\"c\",\"a\"], k = 2\n<b>输出：</b>\"a\"\n<strong>解释：</strong>\narr 中独一无二字符串包括 \"d\" 和 \"a\"<code>&nbsp;。</code>\n\"d\" 首先出现，所以它是第 1 个独一无二字符串。\n\"a\" 第二个出现，所以它是 2 个独一无二字符串。\n由于 k == 2 ，返回 \"a\" 。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><b>输入：</b>arr = [\"aaa\",\"aa\",\"a\"], k = 1\n<b>输出：</b>\"aaa\"\n<strong>解释：</strong>\narr 中所有字符串都是独一无二的，所以返回第 1 个字符串 \"aaa\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>arr = [\"a\",\"b\",\"a\"], k = 3\n<b>输出：</b>\"\"\n<strong>解释：</strong>\n唯一一个独一无二字符串是 \"b\" 。由于少于 3 个独一无二字符串，我们返回空字符串 \"\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= arr[i].length &lt;= 5</code></li>\n\t<li><code>arr[i]</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2054.两个最好的不重叠活动",
        "hardRate": "MEDIUM",
        "passRate": "38.26%",
        "problemsUrl": "https://leetcode.cn/problems/two-best-non-overlapping-events/",
        "solutionsUrl": "https://leetcode.cn/problems/two-best-non-overlapping-events/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>events</code>&nbsp;，其中&nbsp;<code>events[i] = [startTime<sub>i</sub>, endTime<sub>i</sub>, value<sub>i</sub>]</code>&nbsp;。第&nbsp;<code>i</code>&nbsp;个活动开始于&nbsp;<code>startTime<sub>i</sub></code>&nbsp;，结束于&nbsp;<code>endTime<sub>i</sub></code>&nbsp;，如果你参加这个活动，那么你可以得到价值&nbsp;<code>value<sub>i</sub></code>&nbsp;。你 <strong>最多</strong>&nbsp;可以参加&nbsp;<strong>两个时间不重叠</strong>&nbsp;活动，使得它们的价值之和 <strong>最大</strong>&nbsp;。</p>\n\n<p>请你返回价值之和的 <strong>最大值</strong>&nbsp;。</p>\n\n<p>注意，活动的开始时间和结束时间是 <strong>包括</strong>&nbsp;在活动时间内的，也就是说，你不能参加两个活动且它们之一的开始时间等于另一个活动的结束时间。更具体的，如果你参加一个活动，且结束时间为 <code>t</code>&nbsp;，那么下一个活动必须在&nbsp;<code>t + 1</code>&nbsp;或之后的时间开始。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/21/picture5.png\" style=\"width: 400px; height: 75px;\"></p>\n\n<pre><b>输入：</b>events = [[1,3,2],[4,5,2],[2,4,3]]\n<b>输出：</b>4\n<strong>解释：</strong>选择绿色的活动 0 和 1 ，价值之和为 2 + 2 = 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"Example 1 Diagram\" src=\"https://assets.leetcode.com/uploads/2021/09/21/picture1.png\" style=\"width: 400px; height: 77px;\"></p>\n\n<pre><b>输入：</b>events = [[1,3,2],[4,5,2],[1,5,5]]\n<b>输出：</b>5\n<strong>解释：</strong>选择活动 2 ，价值和为 5 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/21/picture3.png\" style=\"width: 400px; height: 66px;\"></p>\n\n<pre><b>输入：</b>events = [[1,5,3],[1,5,1],[6,6,5]]\n<b>输出：</b>8\n<strong>解释：</strong>选择活动 0 和 2 ，价值之和为 3 + 5 = 8 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= events.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>events[i].length == 3</code></li>\n\t<li><code>1 &lt;= startTime<sub>i</sub> &lt;= endTime<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= value<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2055.蜡烛之间的盘子",
        "hardRate": "MEDIUM",
        "passRate": "43.43%",
        "problemsUrl": "https://leetcode.cn/problems/plates-between-candles/",
        "solutionsUrl": "https://leetcode.cn/problems/plates-between-candles/solution",
        "problemsDesc": "<p>给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>s</code>&nbsp;，它只包含字符&nbsp;<code>'*'</code> 和&nbsp;<code>'|'</code>&nbsp;，其中&nbsp;<code>'*'</code>&nbsp;表示一个 <strong>盘子</strong>&nbsp;，<code>'|'</code>&nbsp;表示一支&nbsp;<strong>蜡烛</strong>&nbsp;。</p>\n\n<p>同时给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>queries</code>&nbsp;，其中&nbsp;<code>queries[i] = [left<sub>i</sub>, right<sub>i</sub>]</code>&nbsp;表示 <strong>子字符串</strong>&nbsp;<code>s[left<sub>i</sub>...right<sub>i</sub>]</code>&nbsp;（<strong>包含左右端点的字符</strong>）。对于每个查询，你需要找到 <strong>子字符串中</strong>&nbsp;在 <strong>两支蜡烛之间</strong>&nbsp;的盘子的 <b>数目</b>&nbsp;。如果一个盘子在 <strong>子字符串中</strong>&nbsp;左边和右边 <strong>都</strong>&nbsp;至少有一支蜡烛，那么这个盘子满足在 <strong>两支蜡烛之间</strong>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，<code>s = \"||**||**|*\"</code>&nbsp;，查询&nbsp;<code>[3, 8]</code>&nbsp;，表示的是子字符串&nbsp;<code>\"*||<strong><em>**</em></strong>|\"</code>&nbsp;。子字符串中在两支蜡烛之间的盘子数目为&nbsp;<code>2</code>&nbsp;，子字符串中右边两个盘子在它们左边和右边 <strong>都 </strong>至少有一支蜡烛。</li>\n</ul>\n\n<p>请你返回一个整数数组&nbsp;<code>answer</code>&nbsp;，其中&nbsp;<code>answer[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个查询的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"ex-1\" src=\"https://assets.leetcode.com/uploads/2021/10/04/ex-1.png\" style=\"width: 400px; height: 134px;\"></p>\n\n<pre><b>输入：</b>s = \"**|**|***|\", queries = [[2,5],[5,9]]\n<b>输出：</b>[2,3]\n<b>解释：</b>\n- queries[0] 有两个盘子在蜡烛之间。\n- queries[1] 有三个盘子在蜡烛之间。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img alt=\"ex-2\" src=\"https://assets.leetcode.com/uploads/2021/10/04/ex-2.png\" style=\"width: 600px; height: 193px;\"></p>\n\n<pre><b>输入：</b>s = \"***|**|*****|**||**|*\", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]\n<b>输出：</b>[9,0,0,0,0]\n<strong>解释：</strong>\n- queries[0] 有 9 个盘子在蜡烛之间。\n- 另一个查询没有盘子在蜡烛之间。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含字符&nbsp;<code>'*'</code> 和&nbsp;<code>'|'</code>&nbsp;。</li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>0 &lt;= left<sub>i</sub> &lt;= right<sub>i</sub> &lt; s.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2056.棋盘上有效移动组合的数目",
        "hardRate": "HARD",
        "passRate": "58.68%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-valid-move-combinations-on-chessboard/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-valid-move-combinations-on-chessboard/solution",
        "problemsDesc": "<p>有一个&nbsp;<code>8 x 8</code>&nbsp;的棋盘，它包含&nbsp;<code>n</code>&nbsp;个棋子（棋子包括车，后和象三种）。给你一个长度为 <code>n</code>&nbsp;的字符串数组&nbsp;<code>pieces</code>&nbsp;，其中&nbsp;<code>pieces[i]</code>&nbsp;表示第 <code>i</code>&nbsp;个棋子的类型（车，后或象）。除此以外，还给你一个长度为 <code>n</code>&nbsp;的二维整数数组&nbsp;<code>positions</code>&nbsp;，其中 <code>positions[i] = [r<sub>i</sub>, c<sub>i</sub>]</code>&nbsp;表示第 <code>i</code>&nbsp;个棋子现在在棋盘上的位置为&nbsp;<code>(r<sub>i</sub>, c<sub>i</sub>)</code>&nbsp;，棋盘下标从 <strong>1</strong>&nbsp;开始。</p>\n\n<p>棋盘上每个棋子都可以移动 <b>至多一次</b>&nbsp;。每个棋子的移动中，首先选择移动的 <strong>方向</strong>&nbsp;，然后选择 <strong>移动的步数</strong>&nbsp;，同时你要确保移动过程中棋子不能移到棋盘以外的地方。棋子需按照以下规则移动：</p>\n\n<ul>\n\t<li>车可以 <strong>水平或者竖直</strong>&nbsp;从&nbsp;<code>(r, c)</code>&nbsp;沿着方向&nbsp;<code>(r+1, c)</code>，<code>(r-1, c)</code>，<code>(r, c+1)</code>&nbsp;或者&nbsp;<code>(r, c-1)</code>&nbsp;移动。</li>\n\t<li>后可以 <strong>水平竖直或者斜对角</strong>&nbsp;从&nbsp;<code>(r, c)</code> 沿着方向&nbsp;<code>(r+1, c)</code>，<code>(r-1, c)</code>，<code>(r, c+1)</code>，<code>(r, c-1)</code>，<code>(r+1, c+1)</code>，<code>(r+1, c-1)</code>，<code>(r-1, c+1)</code>，<code>(r-1, c-1)</code>&nbsp;移动。</li>\n\t<li>象可以 <strong>斜对角</strong>&nbsp;从&nbsp;<code>(r, c)</code>&nbsp;沿着方向&nbsp;<code>(r+1, c+1)</code>，<code>(r+1, c-1)</code>，<code>(r-1, c+1)</code>，<code>(r-1, c-1)</code>&nbsp;移动。</li>\n</ul>\n\n<p><strong>移动组合</strong>&nbsp;包含所有棋子的 <strong>移动</strong>&nbsp;。每一秒，每个棋子都沿着它们选择的方向往前移动 <strong>一步</strong>&nbsp;，直到它们到达目标位置。所有棋子从时刻 <code>0</code>&nbsp;开始移动。如果在某个时刻，两个或者更多棋子占据了同一个格子，那么这个移动组合 <strong>不有效</strong>&nbsp;。</p>\n\n<p>请你返回 <strong>有效</strong>&nbsp;移动组合的数目。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>初始时，<strong>不会有两个棋子</strong>&nbsp;在 <strong>同一个位置 。</strong></li>\n\t<li>有可能在一个移动组合中，有棋子不移动。</li>\n\t<li>如果两个棋子 <strong>直接相邻</strong>&nbsp;且两个棋子下一秒要互相占据对方的位置，可以将它们在同一秒内 <strong>交换位置</strong>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/23/a1.png\" style=\"width: 215px; height: 215px;\" /></p>\n\n<pre>\n<b>输入：</b>pieces = [\"rook\"], positions = [[1,1]]\n<b>输出：</b>15\n<b>解释：</b>上图展示了棋子所有可能的移动。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/23/a2.png\" style=\"width: 215px; height: 215px;\" /></p>\n\n<pre>\n<b>输入：</b>pieces = [\"queen\"], positions = [[1,1]]\n<b>输出：</b>22\n<b>解释：</b>上图展示了棋子所有可能的移动。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/23/a3.png\" style=\"width: 214px; height: 215px;\" /></p>\n\n<pre>\n<b>输入：</b>pieces = [\"bishop\"], positions = [[4,3]]\n<b>输出：</b>12\n<b>解释：</b>上图展示了棋子所有可能的移动。\n</pre>\n\n<p><strong>示例 4:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/23/a4.png\" style=\"width: 216px; height: 219px;\" /></p>\n\n<pre>\n<b>输入：</b>pieces = [\"rook\",\"rook\"], positions = [[1,1],[8,8]]\n<b>输出：</b>223\n<b>解释：</b>每个车有 15 种移动，所以总共有 15 * 15 = 225 种移动组合。\n但是，有两个是不有效的移动组合：\n- 将两个车都移动到 (8, 1) ，会导致它们在同一个格子相遇。\n- 将两个车都移动到 (1, 8) ，会导致它们在同一个格子相遇。\n所以，总共有 225 - 2 = 223 种有效移动组合。\n注意，有两种有效的移动组合，分别是一个车在 (1, 8) ，另一个车在 (8, 1) 。\n即使棋盘状态是相同的，这两个移动组合被视为不同的，因为每个棋子移动操作是不相同的。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/23/a5.png\" style=\"width: 214px; height: 213px;\" /></p>\n\n<pre>\n<b>输入：</b>pieces = [\"queen\",\"bishop\"], positions = [[5,7],[3,4]]\n<b>输出：</b>281\n<b>解释：</b>总共有 12 * 24 = 288 种移动组合。\n但是，有一些不有效的移动组合：\n- 如果后停在 (6, 7) ，它会阻挡象到达 (6, 7) 或者 (7, 8) 。\n- 如果后停在 (5, 6) ，它会阻挡象到达 (5, 6) ，(6, 7) 或者 (7, 8) 。\n- 如果象停在 (5, 2) ，它会阻挡后到达 (5, 2) 或者 (5, 1) 。\n在 288 个移动组合当中，281 个是有效的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == pieces.length </code></li>\n\t<li><code>n == positions.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 4</code></li>\n\t<li><code>pieces</code>&nbsp;只包含字符串&nbsp;<code>\"rook\"</code>&nbsp;，<code>\"queen\"</code>&nbsp;和&nbsp;<code>\"bishop\"</code>&nbsp;。</li>\n\t<li>棋盘上总共最多只有一个后。</li>\n\t<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 8</code></li>\n\t<li>每一个&nbsp;<code>positions[i]</code>&nbsp;互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2057.值相等的最小索引",
        "hardRate": "EASY",
        "passRate": "75.41%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-index-with-equal-value/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-index-with-equal-value/solution",
        "problemsDesc": "<p>给你一个下标从 0 开始的整数数组 <code>nums</code> ，返回 <code>nums</code> 中满足<em> </em><code>i mod 10 == nums[i]</code><em> </em>的最小下标 <code>i</code> ；如果不存在这样的下标，返回<em> </em><code>-1</code><em> </em>。</p>\n\n<p><code>x mod y</code> 表示 <code>x</code> 除以 <code>y</code> 的 <strong>余数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,2]\n<strong>输出：</strong>0\n<strong>解释：</strong>\ni=0: 0 mod 10 = 0 == nums[0].\ni=1: 1 mod 10 = 1 == nums[1].\ni=2: 2 mod 10 = 2 == nums[2].\n所有下标都满足 i mod 10 == nums[i] ，所以返回最小下标 0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,3,2,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>\ni=0: 0 mod 10 = 0 != nums[0].\ni=1: 1 mod 10 = 1 != nums[1].\ni=2: 2 mod 10 = 2 == nums[2].\ni=3: 3 mod 10 = 3 != nums[3].\n2 唯一一个满足 i mod 10 == nums[i] 的下标\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,5,6,7,8,9,0]\n<strong>输出：</strong>-1\n<strong>解释：</strong>不存在满足 i mod 10 == nums[i] 的下标\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,1,3,5,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>1 是唯一一个满足 i mod 10 == nums[i] 的下标\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2058.找出临界点之间的最小和最大距离",
        "hardRate": "MEDIUM",
        "passRate": "56.45%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/solution",
        "problemsDesc": "<p>链表中的 <strong>临界点</strong> 定义为一个 <strong>局部极大值点</strong> <strong>或</strong> <strong>局部极小值点 。</strong></p>\n\n<p>如果当前节点的值 <strong>严格大于</strong> 前一个节点和后一个节点，那么这个节点就是一个<strong>&nbsp; 局部极大值点</strong> 。</p>\n\n<p>如果当前节点的值 <strong>严格小于</strong> 前一个节点和后一个节点，那么这个节点就是一个<strong>&nbsp; 局部极小值点</strong> 。</p>\n\n<p>注意：节点只有在同时存在前一个节点和后一个节点的情况下，才能成为一个 <strong>局部极大值点 / 极小值点</strong> 。</p>\n\n<p>给你一个链表 <code>head</code> ，返回一个长度为 2 的数组<em> </em><code>[minDistance, maxDistance]</code> ，其中<em> </em><code>minDistance</code><em> </em>是任意两个不同临界点之间的最小距离，<code>maxDistance</code> 是任意两个不同临界点之间的最大距离。如果临界点少于两个，则返回 <code>[-1，-1]</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/13/a1.png\" style=\"width: 148px; height: 55px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [3,1]\n<strong>输出：</strong>[-1,-1]\n<strong>解释：</strong>链表 [3,1] 中不存在临界点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/13/a2.png\" style=\"width: 624px; height: 46px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [5,3,1,2,5,1,2]\n<strong>输出：</strong>[1,3]\n<strong>解释：</strong>存在三个临界点：\n- [5,3,<em><strong>1</strong></em>,2,5,1,2]：第三个节点是一个局部极小值点，因为 1 比 3 和 2 小。\n- [5,3,1,2,<em><strong>5</strong></em>,1,2]：第五个节点是一个局部极大值点，因为 5 比 2 和 1 大。\n- [5,3,1,2,5,<em><strong>1</strong></em>,2]：第六个节点是一个局部极小值点，因为 1 比 5 和 2 小。\n第五个节点和第六个节点之间距离最小。minDistance = 6 - 5 = 1 。\n第三个节点和第六个节点之间距离最大。maxDistance = 6 - 3 = 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/14/a5.png\" style=\"width: 624px; height: 39px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,3,2,2,3,2,2,2,7]\n<strong>输出：</strong>[3,3]\n<strong>解释：</strong>存在两个临界点：\n- [1,<em><strong>3</strong></em>,2,2,3,2,2,2,7]：第二个节点是一个局部极大值点，因为 3 比 1 和 2 大。\n- [1,3,2,2,<em><strong>3</strong></em>,2,2,2,7]：第五个节点是一个局部极大值点，因为 3 比 2 和 2 大。\n最小和最大距离都存在于第二个节点和第五个节点之间。\n因此，minDistance 和 maxDistance 是 5 - 2 = 3 。\n注意，最后一个节点不算一个局部极大值点，因为它之后就没有节点了。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/13/a4.png\" style=\"width: 345px; height: 52px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [2,3,3,2]\n<strong>输出：</strong>[-1,-1]\n<strong>解释：</strong>链表 [2,3,3,2] 中不存在临界点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数量在范围 <code>[2, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2059.转化数字的最小运算数",
        "hardRate": "MEDIUM",
        "passRate": "48.12%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-convert-number/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-convert-number/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，该数组由 <strong>互不相同</strong> 的数字组成。另给你两个整数 <code>start</code> 和 <code>goal</code> 。</p>\n\n<p>整数 <code>x</code> 的值最开始设为 <code>start</code> ，你打算执行一些运算使 <code>x</code> 转化为 <code>goal</code> 。你可以对数字 <code>x</code> 重复执行下述运算：</p>\n\n<p>如果 <code>0 &lt;= x &lt;= 1000</code> ，那么，对于数组中的任一下标 <code>i</code>（<code>0 &lt;= i &lt; nums.length</code>），可以将 <code>x</code> 设为下述任一值：</p>\n\n<ul>\n\t<li><code>x + nums[i]</code></li>\n\t<li><code>x - nums[i]</code></li>\n\t<li><code>x ^ nums[i]</code>（按位异或 XOR）</li>\n</ul>\n\n<p>注意，你可以按任意顺序使用每个 <code>nums[i]</code> 任意次。使 <code>x</code> 越过 <code>0 &lt;= x &lt;= 1000</code> 范围的运算同样可以生效，但该该运算执行后将不能执行其他运算。</p>\n\n<p>返回将 <code>x = start</code><em> </em>转化为<em> </em><code>goal</code><em> </em>的最小操作数；如果无法完成转化，则返回<em> </em><code>-1</code><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,4,12], start = 2, goal = 12\n<strong>输出：</strong>2\n<strong>解释：</strong>\n可以按 2 → 14 → 12 的转化路径进行，只需执行下述 2 次运算：\n- 2 + 12 = 14\n- 14 - 2 = 12\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,5,7], start = 0, goal = -4\n<strong>输出：</strong>2\n<strong>解释：</strong>\n可以按 0 → 3 → -4 的转化路径进行，只需执行下述 2 次运算：\n- 0 + 3 = 3\n- 3 - 7 = -4\n注意，最后一步运算使 x 超过范围 0 &lt;= x &lt;= 1000 ，但该运算仍然可以生效。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,8,16], start = 0, goal = 1\n<strong>输出：</strong>-1\n<strong>解释：</strong>\n无法将 0 转化为 1</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i], goal &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= start &lt;= 1000</code></li>\n\t<li><code>start != goal</code></li>\n\t<li><code>nums</code> 中的所有整数互不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2060.同源字符串检测",
        "hardRate": "HARD",
        "passRate": "40.36%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-an-original-string-exists-given-two-encoded-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-an-original-string-exists-given-two-encoded-strings/solution",
        "problemsDesc": "<p>原字符串由小写字母组成，可以按下述步骤编码：</p>\n\n<ul>\n\t<li>任意将其 <strong>分割</strong> 为由若干 <strong>非空</strong> 子字符串组成的一个 <strong>序列</strong> 。</li>\n\t<li>任意选择序列中的一些元素（也可能不选择），然后将这些元素替换为元素各自的长度（作为一个数字型的字符串）。</li>\n\t<li>重新 <strong>顺次连接</strong> 序列，得到编码后的字符串。</li>\n</ul>\n\n<p>例如，编码 <code>\"abcdefghijklmnop\"</code> 的一种方法可以描述为：</p>\n\n<ul>\n\t<li>将原字符串分割得到一个序列：<code>[\"ab\", \"cdefghijklmn\", \"o\", \"p\"]</code> 。</li>\n\t<li>选出其中第二个和第三个元素并分别替换为它们自身的长度。序列变为 <code>[\"ab\", \"12\", \"1\", \"p\"]</code> 。</li>\n\t<li>重新顺次连接序列中的元素，得到编码后的字符串：<code>\"ab121p\"</code> 。</li>\n</ul>\n\n<p>给你两个编码后的字符串 <code>s1</code> 和 <code>s2</code> ，由小写英文字母和数字 <code>1-9</code> 组成。如果存在能够同时编码得到 <code>s1</code> 和 <code>s2</code> 原字符串，返回 <code>true</code> ；否则，返回 <code>false</code>。</p>\n\n<p><strong>注意：</strong>生成的测试用例满足 <code>s1</code> 和 <code>s2</code> 中连续数字数不超过 <code>3</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"internationalization\", s2 = \"i18n\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\"internationalization\" 可以作为原字符串\n- \"internationalization\" \n  -&gt; 分割：      [\"internationalization\"]\n  -&gt; 不替换任何元素\n  -&gt; 连接：      \"internationalization\"，得到 s1\n- \"internationalization\"\n  -&gt; 分割：      [\"i\", \"nternationalizatio\", \"n\"]\n  -&gt; 替换：      [\"i\", \"18\",                 \"n\"]\n  -&gt; 连接：      \"i18n\"，得到 s2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"l123e\", s2 = \"44\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\"leetcode\" 可以作为原字符串\n- \"leetcode\" \n  -&gt; 分割：       [\"l\", \"e\", \"et\", \"cod\", \"e\"]\n  -&gt; 替换：       [\"l\", \"1\", \"2\",  \"3\",   \"e\"]\n  -&gt; 连接：       \"l123e\"，得到 s1\n- \"leetcode\" \n  -&gt; 分割：       [\"leet\", \"code\"]\n  -&gt; 替换：       [\"4\",    \"4\"]\n  -&gt; 连接：       \"44\"，得到 s2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"a5b\", s2 = \"c5b\"\n<strong>输出：</strong>false\n<strong>解释：</strong>不存在这样的原字符串\n- 编码为 s1 的字符串必须以字母 'a' 开头\n- 编码为 s2 的字符串必须以字母 'c' 开头\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"112s\", s2 = \"g841\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\"gaaaaaaaaaaaas\" 可以作为原字符串\n- \"gaaaaaaaaaaaas\"\n  -&gt; 分割：       [\"g\", \"aaaaaaaaaaaa\", \"s\"]\n  -&gt; 替换：       [\"1\", \"12\",           \"s\"]\n  -&gt; 连接：       \"112s\"，得到 s1\n- \"gaaaaaaaaaaaas\"\n  -&gt; 分割：       [\"g\", \"aaaaaaaa\", \"aaaa\", \"s\"]\n  -&gt; 替换：       [\"g\", \"8\",        \"4\",    \"1\"]\n  -&gt; 连接         \"g841\"，得到 s2\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"ab\", s2 = \"a2\"\n<strong>输出：</strong>false\n<strong>解释：</strong>不存在这样的原字符串\n- 编码为 s1 的字符串由两个字母组成\n- 编码为 s2 的字符串由三个字母组成\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 40</code></li>\n\t<li><code>s1</code> 和 <code>s2</code> 仅由数字 <code>1-9</code> 和小写英文字母组成</li>\n\t<li><code>s1</code> 和 <code>s2</code> 中连续数字数不超过 <code>3</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2061.扫地机器人清扫过的空间个数",
        "hardRate": "MEDIUM",
        "passRate": "50.19%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-spaces-cleaning-robot-cleaned/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-spaces-cleaning-robot-cleaned/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2062.统计字符串中的元音子字符串",
        "hardRate": "EASY",
        "passRate": "62.68%",
        "problemsUrl": "https://leetcode.cn/problems/count-vowel-substrings-of-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/count-vowel-substrings-of-a-string/solution",
        "problemsDesc": "<p><strong>子字符串</strong> 是字符串中的一个连续（非空）的字符序列。</p>\n\n<p><strong>元音子字符串</strong> 是 <strong>仅</strong> 由元音（<code>'a'</code>、<code>'e'</code>、<code>'i'</code>、<code>'o'</code> 和 <code>'u'</code>）组成的一个子字符串，且必须包含 <strong>全部五种</strong> 元音。</p>\n\n<p>给你一个字符串 <code>word</code> ，统计并返回 <code>word</code> 中 <strong>元音子字符串的数目</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"aeiouu\"\n<strong>输出：</strong>2\n<strong>解释：</strong>下面列出 word 中的元音子字符串（斜体加粗部分）：\n- \"<em><strong>aeiou</strong></em>u\"\n- \"<strong><em>aeiouu</em></strong>\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"unicornarihan\"\n<strong>输出：</strong>0\n<strong>解释：</strong>word 中不含 5 种元音，所以也不会存在元音子字符串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"cuaieuouac\"\n<strong>输出：</strong>7\n<strong>解释：</strong>下面列出 word 中的元音子字符串（斜体加粗部分）：\n- \"c<em><strong>uaieuo</strong></em>uac\"\n- \"c<em><strong>uaieuou</strong></em>ac\"\n- \"c<em><strong>uaieuoua</strong></em>c\"\n- \"cu<em><strong>aieuo</strong></em>uac\"\n- \"cu<em><strong>aieuou</strong></em>ac\"\n- \"cu<em><strong>aieuoua</strong></em>c\"\n- \"cua<em><strong>ieuoua</strong></em>c\"</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"bbaeixoubb\"\n<strong>输出：</strong>0\n<strong>解释：</strong>所有包含全部五种元音的子字符串都含有辅音，所以不存在元音子字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 100</code></li>\n\t<li><code>word</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2063.所有子字符串中的元音",
        "hardRate": "MEDIUM",
        "passRate": "51.68%",
        "problemsUrl": "https://leetcode.cn/problems/vowels-of-all-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/vowels-of-all-substrings/solution",
        "problemsDesc": "<p>给你一个字符串 <code>word</code> ，返回 <code>word</code> 的所有子字符串中 <strong>元音的总数</strong> ，元音是指 <code>'a'</code>、<code>'e'</code><em>、</em><code>'i'</code><em>、</em><code>'o'</code><em> </em>和 <code>'u'</code><em> 。</em></p>\n\n<p><strong>子字符串</strong> 是字符串中一个连续（非空）的字符序列。</p>\n\n<p><strong>注意：</strong>由于对 <code>word</code> 长度的限制比较宽松，答案可能超过有符号 32 位整数的范围。计算时需当心。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"aba\"\n<strong>输出：</strong>6\n<strong>解释：</strong>\n所有子字符串是：\"a\"、\"ab\"、\"aba\"、\"b\"、\"ba\" 和 \"a\" 。\n- \"b\" 中有 0 个元音\n- \"a\"、\"ab\"、\"ba\" 和 \"a\" 每个都有 1 个元音\n- \"aba\" 中有 2 个元音\n因此，元音总数 = 0 + 1 + 1 + 1 + 1 + 2 = 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"abc\"\n<strong>输出：</strong>3\n<strong>解释：</strong>\n所有子字符串是：\"a\"、\"ab\"、\"abc\"、\"b\"、\"bc\" 和 \"c\" 。\n- \"a\"、\"ab\" 和 \"abc\" 每个都有 1 个元音\n- \"b\"、\"bc\" 和 \"c\" 每个都有 0 个元音\n因此，元音总数 = 1 + 1 + 1 + 0 + 0 + 0 = 3 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"ltcd\"\n<strong>输出：</strong>0\n<strong>解释：</strong>\"ltcd\" 的子字符串均不含元音。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"noosabasboosa\"\n<strong>输出：</strong>237\n<strong>解释：</strong>所有子字符串中共有 237 个元音。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>word</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2064.分配给商店的最多商品的最小值",
        "hardRate": "MEDIUM",
        "passRate": "45.02%",
        "problemsUrl": "https://leetcode.cn/problems/minimized-maximum-of-products-distributed-to-any-store/",
        "solutionsUrl": "https://leetcode.cn/problems/minimized-maximum-of-products-distributed-to-any-store/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;，表示有&nbsp;<code>n</code>&nbsp;间零售商店。总共有&nbsp;<code>m</code>&nbsp;种产品，每种产品的数目用一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>quantities</code>&nbsp;表示，其中&nbsp;<code>quantities[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;种商品的数目。</p>\n\n<p>你需要将 <strong>所有商品</strong>&nbsp;分配到零售商店，并遵守这些规则：</p>\n\n<ul>\n\t<li>一间商店 <strong>至多</strong>&nbsp;只能有 <strong>一种商品</strong> ，但一间商店拥有的商品数目可以为&nbsp;<strong>任意</strong>&nbsp;件。</li>\n\t<li>分配后，每间商店都会被分配一定数目的商品（可能为 <code>0</code>&nbsp;件）。用&nbsp;<code>x</code>&nbsp;表示所有商店中分配商品数目的最大值，你希望 <code>x</code>&nbsp;越小越好。也就是说，你想 <strong>最小化</strong>&nbsp;分配给任意商店商品数目的 <strong>最大值</strong>&nbsp;。</li>\n</ul>\n\n<p>请你返回最小的可能的&nbsp;<code>x</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 6, quantities = [11,6]\n<b>输出：</b>3\n<strong>解释： </strong>一种最优方案为：\n- 11 件种类为 0 的商品被分配到前 4 间商店，分配数目分别为：2，3，3，3 。\n- 6 件种类为 1 的商品被分配到另外 2 间商店，分配数目分别为：3，3 。\n分配给所有商店的最大商品数目为 max(2, 3, 3, 3, 3, 3) = 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 7, quantities = [15,10,10]\n<b>输出：</b>5\n<b>解释：</b>一种最优方案为：\n- 15 件种类为 0 的商品被分配到前 3 间商店，分配数目为：5，5，5 。\n- 10 件种类为 1 的商品被分配到接下来 2 间商店，数目为：5，5 。\n- 10 件种类为 2 的商品被分配到最后 2 间商店，数目为：5，5 。\n分配给所有商店的最大商品数目为 max(5, 5, 5, 5, 5, 5, 5) = 5 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 1, quantities = [100000]\n<b>输出：</b>100000\n<b>解释：</b>唯一一种最优方案为：\n- 所有 100000 件商品 0 都分配到唯一的商店中。\n分配给所有商店的最大商品数目为 max(100000) = 100000 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == quantities.length</code></li>\n\t<li><code>1 &lt;= m &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= quantities[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2065.最大化一张图中的路径价值",
        "hardRate": "HARD",
        "passRate": "54.27%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-path-quality-of-a-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-path-quality-of-a-graph/solution",
        "problemsDesc": "<p>给你一张 <strong>无向</strong>&nbsp;图，图中有 <code>n</code>&nbsp;个节点，节点编号从 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;（<strong>都包括</strong>）。同时给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>values</code>&nbsp;，其中&nbsp;<code>values[i]</code>&nbsp;是第 <code>i</code>&nbsp;个节点的 <strong>价值</strong>&nbsp;。同时给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[j] = [u<sub>j</sub>, v<sub>j</sub>, time<sub>j</sub>]</code>&nbsp;表示节点&nbsp;<code>u<sub>j</sub></code> 和&nbsp;<code>v<sub>j</sub></code>&nbsp;之间有一条需要&nbsp;<code>time<sub>j</sub></code>&nbsp;秒才能通过的无向边。最后，给你一个整数&nbsp;<code>maxTime</code>&nbsp;。</p>\n\n<p><strong>合法路径</strong>&nbsp;指的是图中任意一条从节点&nbsp;<code>0</code>&nbsp;开始，最终回到节点 <code>0</code>&nbsp;，且花费的总时间 <strong>不超过</strong>&nbsp;<code>maxTime</code> 秒的一条路径。你可以访问一个节点任意次。一条合法路径的 <b>价值</b>&nbsp;定义为路径中 <strong>不同节点</strong>&nbsp;的价值 <strong>之和</strong>&nbsp;（每个节点的价值 <strong>至多</strong>&nbsp;算入价值总和中一次）。</p>\n\n<p>请你返回一条合法路径的 <strong>最大</strong>&nbsp;价值。</p>\n\n<p><strong>注意：</strong>每个节点 <strong>至多</strong>&nbsp;有 <strong>四条</strong>&nbsp;边与之相连。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/19/ex1drawio.png\" style=\"width: 269px; height: 170px;\" /></p>\n\n<pre>\n<b>输入：</b>values = [0,32,10,43], edges = [[0,1,10],[1,2,15],[0,3,10]], maxTime = 49\n<b>输出：</b>75\n<strong>解释：</strong>\n一条可能的路径为：0 -&gt; 1 -&gt; 0 -&gt; 3 -&gt; 0 。总花费时间为 10 + 10 + 10 + 10 = 40 &lt;= 49 。\n访问过的节点为 0 ，1 和 3 ，最大路径价值为 0 + 32 + 43 = 75 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/19/ex2drawio.png\" style=\"width: 269px; height: 170px;\" /></p>\n\n<pre>\n<b>输入：</b>values = [5,10,15,20], edges = [[0,1,10],[1,2,10],[0,3,10]], maxTime = 30\n<b>输出：</b>25\n<strong>解释：</strong>\n一条可能的路径为：0 -&gt; 3 -&gt; 0 。总花费时间为 10 + 10 = 20 &lt;= 30 。\n访问过的节点为 0 和 3 ，最大路径价值为 5 + 20 = 25 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/19/ex31drawio.png\" style=\"width: 236px; height: 170px;\" /></p>\n\n<pre>\n<b>输入：</b>values = [1,2,3,4], edges = [[0,1,10],[1,2,11],[2,3,12],[1,3,13]], maxTime = 50\n<b>输出：</b>7\n<strong>解释：</strong>\n一条可能的路径为：0 -&gt; 1 -&gt; 3 -&gt; 1 -&gt; 0 。总花费时间为 10 + 13 + 13 + 10 = 46 &lt;= 50 。\n访问过的节点为 0 ，1 和 3 ，最大路径价值为 1 + 2 + 4 = 7 。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/21/ex4drawio.png\" style=\"width: 270px; height: 71px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>values = [0,1,2], edges = [[1,2,10]], maxTime = 10\n<b>输出：</b>0\n<b>解释：</b>\n唯一一条路径为 0 。总花费时间为 0 。\n唯一访问过的节点为 0 ，最大路径价值为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == values.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= values[i] &lt;= 10<sup>8</sup></code></li>\n\t<li><code>0 &lt;= edges.length &lt;= 2000</code></li>\n\t<li><code>edges[j].length == 3 </code></li>\n\t<li><code>0 &lt;= u<sub>j </sub>&lt; v<sub>j</sub> &lt;= n - 1</code></li>\n\t<li><code>10 &lt;= time<sub>j</sub>, maxTime &lt;= 100</code></li>\n\t<li><code>[u<sub>j</sub>, v<sub>j</sub>]</code>&nbsp;所有节点对 <strong>互不相同</strong>&nbsp;。</li>\n\t<li>每个节点 <strong>至多有四条&nbsp;</strong>边。</li>\n\t<li>图可能不连通。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2066.账户余额",
        "hardRate": "MEDIUM",
        "passRate": "78.78%",
        "problemsUrl": "https://leetcode.cn/problems/account-balance/",
        "solutionsUrl": "https://leetcode.cn/problems/account-balance/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2067.等计数子串的数量",
        "hardRate": "MEDIUM",
        "passRate": "54.48%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-equal-count-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-equal-count-substrings/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2068.检查两个字符串是否几乎相等",
        "hardRate": "EASY",
        "passRate": "69.99%",
        "problemsUrl": "https://leetcode.cn/problems/check-whether-two-strings-are-almost-equivalent/",
        "solutionsUrl": "https://leetcode.cn/problems/check-whether-two-strings-are-almost-equivalent/solution",
        "problemsDesc": "<p>如果两个字符串 <code>word1</code>&nbsp;和 <code>word2</code>&nbsp;中从 <code>'a'</code>&nbsp;到 <code>'z'</code>&nbsp;每一个字母出现频率之差都 <strong>不超过</strong>&nbsp;<code>3</code>&nbsp;，那么我们称这两个字符串&nbsp;<code>word1</code> 和&nbsp;<code>word2</code> <strong>几乎相等</strong>&nbsp;。</p>\n\n<p>给你两个长度都为&nbsp;<code>n</code>&nbsp;的字符串&nbsp;<code>word1</code> 和&nbsp;<code>word2</code>&nbsp;，如果&nbsp;<code>word1</code>&nbsp;和&nbsp;<code>word2</code>&nbsp;<strong>几乎相等</strong>&nbsp;，请你返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>一个字母 <code>x</code>&nbsp;的出现 <strong>频率</strong>&nbsp;指的是它在字符串中出现的次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>word1 = \"aaaa\", word2 = \"bccb\"\n<b>输出：</b>false\n<b>解释：</b>字符串 \"aaaa\" 中有 4 个 'a' ，但是 \"bccb\" 中有 0 个 'a' 。\n两者之差为 4 ，大于上限 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>word1 = \"abcdeef\", word2 = \"abaaacc\"\n<b>输出：</b>true\n<b>解释：</b>word1 和 word2 中每个字母出现频率之差至多为 3 ：\n- 'a' 在 word1 中出现了 1 次，在 word2 中出现了 4 次，差为 3 。\n- 'b' 在 word1 中出现了 1 次，在 word2 中出现了 1 次，差为 0 。\n- 'c' 在 word1 中出现了 1 次，在 word2 中出现了 2 次，差为 1 。\n- 'd' 在 word1 中出现了 1 次，在 word2 中出现了 0 次，差为 1 。\n- 'e' 在 word1 中出现了 2 次，在 word2 中出现了 0 次，差为 2 。\n- 'f' 在 word1 中出现了 1 次，在 word2 中出现了 0 次，差为 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>word1 = \"cccddabba\", word2 = \"babababab\"\n<b>输出：</b>true\n<b>解释：</b>word1 和 word2 中每个字母出现频率之差至多为 3 ：\n- 'a' 在 word1 中出现了 2 次，在 word2 中出现了 4 次，差为 2 。\n- 'b' 在 word1 中出现了 2 次，在 word2 中出现了 5 次，差为 3 。\n- 'c' 在 word1 中出现了 3 次，在 word2 中出现了 0 次，差为 3 。\n- 'd' 在 word1 中出现了 2 次，在 word2 中出现了 0 次，差为 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == word1.length == word2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>word1</code> 和&nbsp;<code>word2</code>&nbsp;都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2069.模拟行走机器人 II",
        "hardRate": "MEDIUM",
        "passRate": "22.12%",
        "problemsUrl": "https://leetcode.cn/problems/walking-robot-simulation-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/walking-robot-simulation-ii/solution",
        "problemsDesc": "<p>给你一个在 XY 平面上的&nbsp;<code>width x height</code>&nbsp;的网格图，<strong>左下角</strong>&nbsp;的格子为&nbsp;<code>(0, 0)</code>&nbsp;，<strong>右上角</strong>&nbsp;的格子为&nbsp;<code>(width - 1, height - 1)</code>&nbsp;。网格图中相邻格子为四个基本方向之一（<code>\"North\"</code>，<code>\"East\"</code>，<code>\"South\"</code>&nbsp;和&nbsp;<code>\"West\"</code>）。一个机器人 <strong>初始</strong>&nbsp;在格子&nbsp;<code>(0, 0)</code>&nbsp;，方向为&nbsp;<code>\"East\"</code>&nbsp;。</p>\n\n<p>机器人可以根据指令移动指定的 <strong>步数</strong>&nbsp;。每一步，它可以执行以下操作。</p>\n\n<ol>\n\t<li>沿着当前方向尝试 <strong>往前一步</strong>&nbsp;。</li>\n\t<li>如果机器人下一步将到达的格子 <strong>超出了边界</strong>&nbsp;，机器人会 <strong>逆时针</strong>&nbsp;转 90 度，然后再尝试往前一步。</li>\n</ol>\n\n<p>如果机器人完成了指令要求的移动步数，它将停止移动并等待下一个指令。</p>\n\n<p>请你实现&nbsp;<code>Robot</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>Robot(int width, int height)</code>&nbsp;初始化一个&nbsp;<code>width x height</code>&nbsp;的网格图，机器人初始在&nbsp;<code>(0, 0)</code>&nbsp;，方向朝&nbsp;<code>\"East\"</code>&nbsp;。</li>\n\t<li><code>void step(int num)</code>&nbsp;给机器人下达前进&nbsp;<code>num</code>&nbsp;步的指令。</li>\n\t<li><code>int[] getPos()</code>&nbsp;返回机器人当前所处的格子位置，用一个长度为 2 的数组&nbsp;<code>[x, y]</code>&nbsp;表示。</li>\n\t<li><code>String getDir()</code>&nbsp;返回当前机器人的朝向，为&nbsp;<code>\"North\"</code>&nbsp;，<code>\"East\"</code>&nbsp;，<code>\"South\"</code>&nbsp;或者&nbsp;<code>\"West\"</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"example-1\" src=\"https://assets.leetcode.com/uploads/2021/10/09/example-1.png\" style=\"width: 498px; height: 268px;\" /></p>\n\n<pre>\n<strong>输入：</strong>\n[\"Robot\", \"step\", \"step\", \"getPos\", \"getDir\", \"step\", \"step\", \"step\", \"getPos\", \"getDir\"]\n[[6, 3], [2], [2], [], [], [2], [1], [4], [], []]\n<strong>输出：</strong>\n[null, null, null, [4, 0], \"East\", null, null, null, [1, 2], \"West\"]\n\n<strong>解释：</strong>\nRobot robot = new Robot(6, 3); // 初始化网格图，机器人在 (0, 0) ，朝东。\nrobot.step(2);  // 机器人朝东移动 2 步，到达 (2, 0) ，并朝东。\nrobot.step(2);  // 机器人朝东移动 2 步，到达 (4, 0) ，并朝东。\nrobot.getPos(); // 返回 [4, 0]\nrobot.getDir(); // 返回 \"East\"\nrobot.step(2);  // 朝东移动 1 步到达 (5, 0) ，并朝东。\n                // 下一步继续往东移动将出界，所以逆时针转变方向朝北。\n                // 然后，往北移动 1 步到达 (5, 1) ，并朝北。\nrobot.step(1);  // 朝北移动 1 步到达 (5, 2) ，并朝 <strong>北</strong> （不是朝西）。\nrobot.step(4);  // 下一步继续往北移动将出界，所以逆时针转变方向朝西。\n                // 然后，移动 4 步到 (1, 2) ，并朝西。\nrobot.getPos(); // 返回 [1, 2]\nrobot.getDir(); // 返回 \"West\"\n\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= width, height &lt;= 100</code></li>\n\t<li><code>1 &lt;= num &lt;= 10<sup>5</sup></code></li>\n\t<li><code>step</code> ，<code>getPos</code>&nbsp;和&nbsp;<code>getDir</code>&nbsp;<strong>总共&nbsp;</strong>调用次数不超过&nbsp;<code>10<sup>4</sup></code>&nbsp;次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2070.每一个查询的最大美丽值",
        "hardRate": "MEDIUM",
        "passRate": "45.08%",
        "problemsUrl": "https://leetcode.cn/problems/most-beautiful-item-for-each-query/",
        "solutionsUrl": "https://leetcode.cn/problems/most-beautiful-item-for-each-query/solution",
        "problemsDesc": "<p>给你一个二维整数数组&nbsp;<code>items</code>&nbsp;，其中&nbsp;<code>items[i] = [price<sub>i</sub>, beauty<sub>i</sub>]</code>&nbsp;分别表示每一个物品的 <strong>价格</strong>&nbsp;和 <strong>美丽值</strong>&nbsp;。</p>\n\n<p>同时给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>queries</code>&nbsp;。对于每个查询&nbsp;<code>queries[j]</code>&nbsp;，你想求出价格小于等于&nbsp;<code>queries[j]</code>&nbsp;的物品中，<strong>最大的美丽值</strong>&nbsp;是多少。如果不存在符合条件的物品，那么查询的结果为&nbsp;<code>0</code>&nbsp;。</p>\n\n<p>请你返回一个长度与 <code>queries</code>&nbsp;相同的数组<em>&nbsp;</em><code>answer</code>，其中<em>&nbsp;</em><code>answer[j]</code>是第&nbsp;<code>j</code>&nbsp;个查询的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]\n<b>输出：</b>[2,4,5,5,6,6]\n<strong>解释：</strong>\n- queries[0]=1 ，[1,2] 是唯一价格 &lt;= 1 的物品。所以这个查询的答案为 2 。\n- queries[1]=2 ，符合条件的物品有 [1,2] 和 [2,4] 。\n  它们中的最大美丽值为 4 。\n- queries[2]=3 和 queries[3]=4 ，符合条件的物品都为 [1,2] ，[3,2] ，[2,4] 和 [3,5] 。\n  它们中的最大美丽值为 5 。\n- queries[4]=5 和 queries[5]=6 ，所有物品都符合条件。\n  所以，答案为所有物品中的最大美丽值，为 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]\n<b>输出：</b>[4]\n<b>解释：</b>\n每个物品的价格均为 1 ，所以我们选择最大美丽值 4 。\n注意，多个物品可能有相同的价格和美丽值。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>items = [[10,1000]], queries = [5]\n<b>输出：</b>[0]\n<strong>解释：</strong>\n没有物品的价格小于等于 5 ，所以没有物品可以选择。\n因此，查询的结果为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= items.length, queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>items[i].length == 2</code></li>\n\t<li><code>1 &lt;= price<sub>i</sub>, beauty<sub>i</sub>, queries[j] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2071.你可以安排的最多任务数目",
        "hardRate": "HARD",
        "passRate": "29.95%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-tasks-you-can-assign/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-tasks-you-can-assign/solution",
        "problemsDesc": "<p>给你&nbsp;<code>n</code>&nbsp;个任务和&nbsp;<code>m</code>&nbsp;个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>tasks</code>&nbsp;中，第 <code>i</code>&nbsp;个任务需要&nbsp;<code>tasks[i]</code>&nbsp;的力量才能完成。每个工人的力量值保存在下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>workers</code>&nbsp;中，第&nbsp;<code>j</code>&nbsp;个工人的力量值为&nbsp;<code>workers[j]</code>&nbsp;。每个工人只能完成 <strong>一个</strong>&nbsp;任务，且力量值需要 <strong>大于等于</strong>&nbsp;该任务的力量要求值（即&nbsp;<code>workers[j] &gt;= tasks[i]</code>&nbsp;）。</p>\n\n<p>除此以外，你还有&nbsp;<code>pills</code>&nbsp;个神奇药丸，可以给 <strong>一个工人的力量值</strong>&nbsp;增加&nbsp;<code>strength</code>&nbsp;。你可以决定给哪些工人使用药丸，但每个工人&nbsp;<strong>最多</strong>&nbsp;只能使用&nbsp;<strong>一片</strong>&nbsp;药丸。</p>\n\n<p>给你下标从 <strong>0</strong>&nbsp;开始的整数数组<code>tasks</code> 和&nbsp;<code>workers</code>&nbsp;以及两个整数&nbsp;<code>pills</code> 和&nbsp;<code>strength</code>&nbsp;，请你返回 <strong>最多</strong>&nbsp;有多少个任务可以被完成。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>tasks = [<em><strong>3</strong></em>,<em><strong>2</strong></em>,<em><strong>1</strong></em>], workers = [<em><strong>0</strong></em>,<em><strong>3</strong></em>,<em><strong>3</strong></em>], pills = 1, strength = 1\n<b>输出：</b>3\n<strong>解释：</strong>\n我们可以按照如下方案安排药丸：\n- 给 0 号工人药丸。\n- 0 号工人完成任务 2（0 + 1 &gt;= 1）\n- 1 号工人完成任务 1（3 &gt;= 2）\n- 2 号工人完成任务 0（3 &gt;= 3）\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>tasks = [<em><strong>5</strong></em>,4], workers = [<em><strong>0</strong></em>,0,0], pills = 1, strength = 5\n<b>输出：</b>1\n<strong>解释：</strong>\n我们可以按照如下方案安排药丸：\n- 给 0 号工人药丸。\n- 0 号工人完成任务 0（0 + 5 &gt;= 5）\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>tasks = [<em><strong>10</strong></em>,<em><strong>15</strong></em>,30], workers = [<em><strong>0</strong></em>,<em><strong>10</strong></em>,10,10,10], pills = 3, strength = 10\n<b>输出：</b>2\n<strong>解释：</strong>\n我们可以按照如下方案安排药丸：\n- 给 0 号和 1 号工人药丸。\n- 0 号工人完成任务 0（0 + 10 &gt;= 10）\n- 1 号工人完成任务 1（10 + 10 &gt;= 15）\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>tasks = [<em><strong>5</strong></em>,9,<em><strong>8</strong></em>,<em><strong>5</strong></em>,9], workers = [1,<em><strong>6</strong></em>,<em><strong>4</strong></em>,2,<em><strong>6</strong></em>], pills = 1, strength = 5\n<b>输出：</b>3\n<strong>解释：</strong>\n我们可以按照如下方案安排药丸：\n- 给 2 号工人药丸。\n- 1 号工人完成任务 0（6 &gt;= 5）\n- 2 号工人完成任务 2（4 + 5 &gt;= 8）\n- 4 号工人完成任务 3（6 &gt;= 5）\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == tasks.length</code></li>\n\t<li><code>m == workers.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= pills &lt;= m</code></li>\n\t<li><code>0 &lt;= tasks[i], workers[j], strength &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2072.赢得比赛的大学",
        "hardRate": "EASY",
        "passRate": "68.66%",
        "problemsUrl": "https://leetcode.cn/problems/the-winner-university/",
        "solutionsUrl": "https://leetcode.cn/problems/the-winner-university/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2073.买票需要的时间",
        "hardRate": "EASY",
        "passRate": "61.68%",
        "problemsUrl": "https://leetcode.cn/problems/time-needed-to-buy-tickets/",
        "solutionsUrl": "https://leetcode.cn/problems/time-needed-to-buy-tickets/solution",
        "problemsDesc": "<p>有 <code>n</code> 个人前来排队买票，其中第 <code>0</code> 人站在队伍 <strong>最前方</strong> ，第 <code>(n - 1)</code> 人站在队伍 <strong>最后方</strong> 。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>tickets</code> ，数组长度为 <code>n</code> ，其中第 <code>i</code> 人想要购买的票数为 <code>tickets[i]</code> 。</p>\n\n<p>每个人买票都需要用掉 <strong>恰好 1 秒</strong> 。一个人 <strong>一次只能买一张票</strong> ，如果需要购买更多票，他必须走到&nbsp; <strong>队尾</strong> 重新排队（<strong>瞬间 </strong>发生，不计时间）。如果一个人没有剩下需要买的票，那他将会 <strong>离开</strong> 队伍。</p>\n\n<p>返回位于位置 <code>k</code>（下标从 <strong>0</strong> 开始）的人完成买票需要的时间（以秒为单位）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>tickets = [2,3,2], k = 2\n<strong>输出：</strong>6\n<strong>解释：</strong> \n- 第一轮，队伍中的每个人都买到一张票，队伍变为 [1, 2, 1] 。\n- 第二轮，队伍中的每个都又都买到一张票，队伍变为 [0, 1, 0] 。\n位置 2 的人成功买到 2 张票，用掉 3 + 3 = 6 秒。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>tickets = [5,1,1,1], k = 0\n<strong>输出：</strong>8\n<strong>解释：</strong>\n- 第一轮，队伍中的每个人都买到一张票，队伍变为 [4, 0, 0, 0] 。\n- 接下来的 4 轮，只有位置 0 的人在买票。\n位置 0 的人成功买到 5 张票，用掉 4 + 1 + 1 + 1 + 1 = 8 秒。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == tickets.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= tickets[i] &lt;= 100</code></li>\n\t<li><code>0 &lt;= k &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2074.反转偶数长度组的节点",
        "hardRate": "MEDIUM",
        "passRate": "45.73%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-nodes-in-even-length-groups/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-nodes-in-even-length-groups/solution",
        "problemsDesc": "<p>给你一个链表的头节点 <code>head</code> 。</p>\n\n<p>链表中的节点 <strong>按顺序</strong> 划分成若干 <strong>非空</strong> 组，这些非空组的长度构成一个自然数序列（<code>1, 2, 3, 4, ...</code>）。一个组的 <strong>长度</strong> 就是组中分配到的节点数目。换句话说：</p>\n\n<ul>\n\t<li>节点 <code>1</code> 分配给第一组</li>\n\t<li>节点 <code>2</code> 和 <code>3</code> 分配给第二组</li>\n\t<li>节点 <code>4</code>、<code>5</code> 和 <code>6</code> 分配给第三组，以此类推</li>\n</ul>\n\n<p>注意，最后一组的长度可能小于或者等于 <code>1 + 倒数第二组的长度</code> 。</p>\n\n<p><strong>反转</strong> 每个 <strong>偶数</strong> 长度组中的节点，并返回修改后链表的头节点 <code>head</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/25/eg1.png\" style=\"width: 699px; height: 124px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [5,2,6,3,9,1,7,3,8,4]\n<strong>输出：</strong>[5,6,2,3,9,1,4,8,3,7]\n<strong>解释：</strong>\n- 第一组长度为 1 ，奇数，没有发生反转。\n- 第二组长度为 2 ，偶数，节点反转。\n- 第三组长度为 3 ，奇数，没有发生反转。\n- 最后一组长度为 4 ，偶数，节点反转。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/25/eg2.png\" style=\"width: 284px; height: 114px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,1,0,6]\n<strong>输出：</strong>[1,0,1,6]\n<strong>解释：</strong>\n- 第一组长度为 1 ，没有发生反转。\n- 第二组长度为 2 ，节点反转。\n- 最后一组长度为 1 ，没有发生反转。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/28/eg3.png\" style=\"width: 139px; height: 114px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [2,1]\n<strong>输出：</strong>[2,1]\n<strong>解释：</strong>\n- 第一组长度为 1 ，没有发生反转。\n- 最后一组长度为 1 ，没有发生反转。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点数目范围是 <code>[1, 10<sup>5</sup>]</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2075.解码斜向换位密码",
        "hardRate": "MEDIUM",
        "passRate": "46.92%",
        "problemsUrl": "https://leetcode.cn/problems/decode-the-slanted-ciphertext/",
        "solutionsUrl": "https://leetcode.cn/problems/decode-the-slanted-ciphertext/solution",
        "problemsDesc": "<p>字符串 <code>originalText</code> 使用 <strong>斜向换位密码</strong> ，经由 <strong>行数固定</strong> 为 <code>rows</code> 的矩阵辅助，加密得到一个字符串 <code>encodedText</code> 。</p>\n\n<p><code>originalText</code> 先按从左上到右下的方式放置到矩阵中。</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/07/exa11.png\" style=\"width: 300px; height: 185px;\" />\n<p>先填充蓝色单元格，接着是红色单元格，然后是黄色单元格，以此类推，直到到达 <code>originalText</code> 末尾。箭头指示顺序即为单元格填充顺序。所有空单元格用 <code>' '</code> 进行填充。矩阵的列数需满足：用 <code>originalText</code> 填充之后，最右侧列 <strong>不为空</strong> 。</p>\n\n<p>接着按行将字符附加到矩阵中，构造&nbsp;<code>encodedText</code> 。</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/07/exa12.png\" style=\"width: 300px; height: 200px;\" />\n<p>先把蓝色单元格中的字符附加到 <code>encodedText</code> 中，接着是红色单元格，最后是黄色单元格。箭头指示单元格访问顺序。</p>\n\n<p>例如，如果 <code>originalText = \"cipher\"</code> 且 <code>rows = 3</code> ，那么我们可以按下述方法将其编码：</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/25/desc2.png\" style=\"width: 281px; height: 211px;\" />\n<p>蓝色箭头标识 <code>originalText</code> 是如何放入矩阵中的，红色箭头标识形成 <code>encodedText</code> 的顺序。在上述例子中，<code>encodedText = \"ch&nbsp; &nbsp;ie&nbsp; &nbsp;pr\"</code> 。</p>\n\n<p>给你编码后的字符串 <code>encodedText</code> 和矩阵的行数 <code>rows</code> ，返回源字符串 <code>originalText</code> 。</p>\n\n<p><strong>注意：</strong><code>originalText</code> <strong>不</strong> 含任何尾随空格 <code>' '</code> 。生成的测试用例满足 <strong>仅存在一个</strong> 可能的 <code>originalText</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>encodedText = \"ch   ie   pr\", rows = 3\n<strong>输出：</strong>\"cipher\"\n<strong>解释：</strong>此示例与问题描述中的例子相同。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/26/exam1.png\" style=\"width: 250px; height: 168px;\" /></p>\n\n<pre>\n<strong>输入：</strong>encodedText = \"iveo    eed   l te   olc\", rows = 4\n<strong>输出：</strong>\"i love leetcode\"\n<strong>解释：</strong>上图标识用于编码 originalText 的矩阵。 \n蓝色箭头展示如何从 encodedText 找到 originalText 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/26/eg2.png\" style=\"width: 300px; height: 51px;\" /></p>\n\n<pre>\n<strong>输入：</strong>encodedText = \"coding\", rows = 1\n<strong>输出：</strong>\"coding\"\n<strong>解释：</strong>由于只有 1 行，所以 originalText 和 encodedText 是相同的。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/26/exam3.png\" style=\"width: 150px; height: 101px;\" />\n<pre>\n<strong>输入：</strong>encodedText = \" b  ac\", rows = 2\n<strong>输出：</strong>\" abc\"\n<strong>解释：</strong>originalText 不能含尾随空格，但它可能会有一个或者多个前置空格。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= encodedText.length &lt;= 10<sup>6</sup></code></li>\n\t<li><code>encodedText</code> 仅由小写英文字母和 <code>' '</code> 组成</li>\n\t<li><code>encodedText</code> 是对某个 <strong>不含</strong> 尾随空格的 <code>originalText</code> 的一个有效编码</li>\n\t<li><code>1 &lt;= rows &lt;= 1000</code></li>\n\t<li>生成的测试用例满足 <strong>仅存在一个</strong> 可能的 <code>originalText</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2076.处理含限制条件的好友请求",
        "hardRate": "HARD",
        "passRate": "50.99%",
        "problemsUrl": "https://leetcode.cn/problems/process-restricted-friend-requests/",
        "solutionsUrl": "https://leetcode.cn/problems/process-restricted-friend-requests/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，表示网络上的用户数目。每个用户按从 <code>0</code> 到 <code>n - 1</code> 进行编号。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>restrictions</code> ，其中 <code>restrictions[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 意味着用户 <code>x<sub>i</sub></code> 和用户 <code>y<sub>i</sub></code> <strong>不能</strong> 成为 <strong>朋友</strong> ，不管是 <strong>直接</strong> 还是通过其他用户 <strong>间接</strong> 。</p>\n\n<p>最初，用户里没有人是其他用户的朋友。给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>requests</code> 表示好友请求的列表，其中 <code>requests[j] = [u<sub>j</sub>, v<sub>j</sub>]</code> 是用户 <code>u<sub>j</sub></code> 和用户 <code>v<sub>j</sub></code> 之间的一条好友请求。</p>\n\n<p>如果 <code>u<sub>j</sub></code> 和 <code>v<sub>j</sub></code> 可以成为 <strong>朋友</strong> ，那么好友请求将会 <strong>成功</strong> 。每个好友请求都会按列表中给出的顺序进行处理（即，<code>requests[j]</code> 会在 <code>requests[j + 1]</code> 前）。一旦请求成功，那么对所有未来的好友请求而言， <code>u<sub>j</sub></code> 和 <code>v<sub>j</sub></code> 将会 <strong>成为直接朋友 。</strong></p>\n\n<p>返回一个 <strong>布尔数组</strong> <code>result</code> ，其中元素遵循此规则：如果第 <code>j</code> 个好友请求 <strong>成功</strong><em> </em>，那么 <code>result[j]</code><em> </em>就是<em> </em><code>true</code><em> </em>；否则，为<em> </em><code>false</code> 。</p>\n\n<p><strong>注意：</strong>如果 <code>u<sub>j</sub></code> 和 <code>v<sub>j</sub></code> 已经是直接朋友，那么他们之间的请求将仍然&nbsp;<strong>成功</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]]\n<strong>输出：</strong>[true,false]\n<strong>解释：\n</strong>请求 0 ：用户 0 和 用户 2 可以成为朋友，所以他们成为直接朋友。 \n请求 1 ：用户 2 和 用户 1 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (1--2--0) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]]\n<strong>输出：</strong>[true,false]\n<strong>解释：</strong>\n请求 0 ：用户 1 和 用户 2 可以成为朋友，所以他们成为直接朋友。 \n请求 1 ：用户 0 和 用户 2 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (0--2--1) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]]\n<strong>输出：</strong>[true,false,true,false]\n<strong>解释：\n</strong>请求 0 ：用户 0 和 用户 4 可以成为朋友，所以他们成为直接朋友。 \n请求 1 ：用户 1 和 用户 2 不能成为朋友，因为他们之间存在限制。\n请求 2 ：用户 3 和 用户 1 可以成为朋友，所以他们成为直接朋友。 \n请求 3 ：用户 3 和 用户 4 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (0--4--3--1) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= restrictions.length &lt;= 1000</code></li>\n\t<li><code>restrictions[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>\n\t<li><code>1 &lt;= requests.length &lt;= 1000</code></li>\n\t<li><code>requests[j].length == 2</code></li>\n\t<li><code>0 &lt;= u<sub>j</sub>, v<sub>j</sub> &lt;= n - 1</code></li>\n\t<li><code>u<sub>j</sub> != v<sub>j</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2077.殊途同归",
        "hardRate": "MEDIUM",
        "passRate": "62.89%",
        "problemsUrl": "https://leetcode.cn/problems/paths-in-maze-that-lead-to-same-room/",
        "solutionsUrl": "https://leetcode.cn/problems/paths-in-maze-that-lead-to-same-room/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2078.两栋颜色不同且距离最远的房子",
        "hardRate": "EASY",
        "passRate": "72.35%",
        "problemsUrl": "https://leetcode.cn/problems/two-furthest-houses-with-different-colors/",
        "solutionsUrl": "https://leetcode.cn/problems/two-furthest-houses-with-different-colors/solution",
        "problemsDesc": "<p>街上有 <code>n</code> 栋房子整齐地排成一列，每栋房子都粉刷上了漂亮的颜色。给你一个下标从 <strong>0</strong> 开始且长度为 <code>n</code> 的整数数组 <code>colors</code> ，其中 <code>colors[i]</code> 表示第&nbsp; <code>i</code> 栋房子的颜色。</p>\n\n<p>返回 <strong>两栋</strong> 颜色 <strong>不同</strong> 房子之间的 <strong>最大</strong> 距离。</p>\n\n<p>第 <code>i</code> 栋房子和第 <code>j</code> 栋房子之间的距离是 <code>abs(i - j)</code> ，其中 <code>abs(x)</code> 是 <code>x</code> 的绝对值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/31/eg1.png\" style=\"width: 610px; height: 84px;\" /></p>\n\n<pre>\n<strong>输入：</strong>colors = [<strong><em>1</em></strong>,1,1,<em><strong>6</strong></em>,1,1,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>上图中，颜色 1 标识成蓝色，颜色 6 标识成红色。\n两栋颜色不同且距离最远的房子是房子 0 和房子 3 。\n房子 0 的颜色是颜色 1 ，房子 3 的颜色是颜色 6 。两栋房子之间的距离是 abs(0 - 3) = 3 。\n注意，房子 3 和房子 6 也可以产生最佳答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/31/eg2.png\" style=\"width: 426px; height: 84px;\" /></p>\n\n<pre>\n<strong>输入：</strong>colors = [<em><strong>1</strong></em>,8,3,8,<em><strong>3</strong></em>]\n<strong>输出：</strong>4\n<strong>解释：</strong>上图中，颜色 1 标识成蓝色，颜色 8 标识成黄色，颜色 3 标识成绿色。\n两栋颜色不同且距离最远的房子是房子 0 和房子 4 。\n房子 0 的颜色是颜色 1 ，房子 4 的颜色是颜色 3 。两栋房子之间的距离是 abs(0 - 4) = 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>colors = [<em><strong>0</strong></em>,<em><strong>1</strong></em>]\n<strong>输出：</strong>1\n<strong>解释：</strong>两栋颜色不同且距离最远的房子是房子 0 和房子 1 。\n房子 0 的颜色是颜色 0 ，房子 1 的颜色是颜色 1 。两栋房子之间的距离是 abs(0 - 1) = 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n ==&nbsp;colors.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= colors[i] &lt;= 100</code></li>\n\t<li>生成的测试数据满足 <strong>至少 </strong>存在 2 栋颜色不同的房子</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2079.给植物浇水",
        "hardRate": "MEDIUM",
        "passRate": "77.69%",
        "problemsUrl": "https://leetcode.cn/problems/watering-plants/",
        "solutionsUrl": "https://leetcode.cn/problems/watering-plants/solution",
        "problemsDesc": "<p>你打算用一个水罐给花园里的 <code>n</code> 株植物浇水。植物排成一行，从左到右进行标记，编号从 <code>0</code> 到 <code>n - 1</code> 。其中，第 <code>i</code> 株植物的位置是 <code>x = i</code> 。<code>x = -1</code>&nbsp;处有一条河，你可以在那里重新灌满你的水罐。</p>\n\n<p>每一株植物都需要浇特定量的水。你将会按下面描述的方式完成浇水：</p>\n\n<ul>\n\t<li>按从左到右的顺序给植物浇水。</li>\n\t<li>在给当前植物浇完水之后，如果你没有足够的水 <strong>完全</strong> 浇灌下一株植物，那么你就需要返回河边重新装满水罐。</li>\n\t<li>你 <strong>不能</strong> 提前重新灌满水罐。</li>\n</ul>\n\n<p>最初，你在河边（也就是，<code>x = -1</code>），在 x 轴上每移动 <strong>一个单位</strong>&nbsp;都需要 <strong>一步</strong> 。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>plants</code> ，数组由 <code>n</code> 个整数组成。其中，<code>plants[i]</code> 为第 <code>i</code> 株植物需要的水量。另有一个整数 <code>capacity</code> 表示水罐的容量，返回浇灌所有植物需要的 <strong>步数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>plants = [2,2,3,3], capacity = 5\n<strong>输出：</strong>14\n<strong>解释：</strong>从河边开始，此时水罐是装满的：\n- 走到植物 0 (1 步) ，浇水。水罐中还有 3 单位的水。\n- 走到植物 1 (1 步) ，浇水。水罐中还有 1 单位的水。\n- 由于不能完全浇灌植物 2 ，回到河边取水 (2 步)。\n- 走到植物 2 (3 步) ，浇水。水罐中还有 2 单位的水。\n- 由于不能完全浇灌植物 3 ，回到河边取水 (3 步)。\n- 走到植物 3 (4 步) ，浇水。\n需要的步数是 = 1 + 1 + 2 + 3 + 3 + 4 = 14 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>plants = [1,1,1,4,2,3], capacity = 4\n<strong>输出：</strong>30\n<strong>解释：</strong>从河边开始，此时水罐是装满的：\n- 走到植物 0，1，2 (3 步) ，浇水。回到河边取水 (3 步)。\n- 走到植物 3 (4 步) ，浇水。回到河边取水 (4 步)。\n- 走到植物 4 (5 步) ，浇水。回到河边取水 (5 步)。\n- 走到植物 5 (6 步) ，浇水。\n需要的步数是 = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>plants = [7,7,7,7,7,7,7], capacity = 8\n<strong>输出：</strong>49\n<strong>解释：</strong>每次浇水都需要重新灌满水罐。\n需要的步数是 = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == plants.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= plants[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>max(plants[i]) &lt;= capacity &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2080.区间内查询数字的频率",
        "hardRate": "MEDIUM",
        "passRate": "31.42%",
        "problemsUrl": "https://leetcode.cn/problems/range-frequency-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/range-frequency-queries/solution",
        "problemsDesc": "<p>请你设计一个数据结构，它能求出给定子数组内一个给定值的 <strong>频率</strong>&nbsp;。</p>\n\n<p>子数组中一个值的 <strong>频率</strong>&nbsp;指的是这个子数组中这个值的出现次数。</p>\n\n<p>请你实现&nbsp;<code>RangeFreqQuery</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>RangeFreqQuery(int[] arr)</code>&nbsp;用下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>arr</code>&nbsp;构造一个类的实例。</li>\n\t<li><code>int query(int left, int right, int value)</code>&nbsp;返回子数组&nbsp;<code>arr[left...right]</code>&nbsp;中&nbsp;<code>value</code>&nbsp;的&nbsp;<strong>频率</strong>&nbsp;。</li>\n</ul>\n\n<p>一个 <strong>子数组</strong> 指的是数组中一段连续的元素。<code>arr[left...right]</code>&nbsp;指的是 <code>nums</code>&nbsp;中包含下标 <code>left</code>&nbsp;和 <code>right</code>&nbsp;<strong>在内</strong>&nbsp;的中间一段连续元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>\n[\"RangeFreqQuery\", \"query\", \"query\"]\n[[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]\n<strong>输出：</strong>\n[null, 1, 2]\n\n<strong>解释：</strong>\nRangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]);\nrangeFreqQuery.query(1, 2, 4); // 返回 1 。4 在子数组 [33, 4] 中出现 1 次。\nrangeFreqQuery.query(0, 11, 33); // 返回 2 。33 在整个子数组中出现 2 次。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i], value &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= left &lt;= right &lt; arr.length</code></li>\n\t<li>调用&nbsp;<code>query</code>&nbsp;不超过&nbsp;<code>10<sup>5</sup></code>&nbsp;次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2081.k 镜像数字的和",
        "hardRate": "HARD",
        "passRate": "43.56%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-k-mirror-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-k-mirror-numbers/solution",
        "problemsDesc": "<p>一个 <strong>k 镜像数字</strong>&nbsp;指的是一个在十进制和 k 进制下从前往后读和从后往前读都一样的&nbsp;<strong>没有前导 0</strong>&nbsp;的&nbsp;<strong>正</strong>&nbsp;整数。</p>\n\n<ul>\n\t<li>比方说，<code>9</code>&nbsp;是一个 2 镜像数字。<code>9</code>&nbsp;在十进制下为&nbsp;<code>9</code>&nbsp;，二进制下为&nbsp;<code>1001</code>&nbsp;，两者从前往后读和从后往前读都一样。</li>\n\t<li>相反地，<code>4</code>&nbsp;不是一个 2 镜像数字。<code>4</code>&nbsp;在二进制下为&nbsp;<code>100</code>&nbsp;，从前往后和从后往前读不相同。</li>\n</ul>\n\n<p>给你进制&nbsp;<code>k</code>&nbsp;和一个数字&nbsp;<code>n</code>&nbsp;，请你返回 k 镜像数字中 <strong>最小</strong> 的 <code>n</code>&nbsp;个数 <strong>之和</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre><b>输入：</b>k = 2, n = 5\n<b>输出：</b>25\n<strong>解释：\n</strong>最小的 5 个 2 镜像数字和它们的二进制表示如下：\n  十进制       二进制\n    1          1\n    3          11\n    5          101\n    7          111\n    9          1001\n它们的和为 1 + 3 + 5 + 7 + 9 = 25 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>k = 3, n = 7\n<b>输出：</b>499\n<strong>解释：\n</strong>7 个最小的 3 镜像数字和它们的三进制表示如下：\n  十进制       三进制\n    1          1\n    2          2\n    4          11\n    8          22\n    121        11111\n    151        12121\n    212        21212\n它们的和为 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>k = 7, n = 17\n<b>输出：</b>20379000\n<b>解释：</b>17 个最小的 7 镜像数字分别为：\n1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= k &lt;= 9</code></li>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2082.富有客户的数量",
        "hardRate": "EASY",
        "passRate": "74.10%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-rich-customers/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-rich-customers/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2083.求以相同字母开头和结尾的子串总数",
        "hardRate": "MEDIUM",
        "passRate": "60.92%",
        "problemsUrl": "https://leetcode.cn/problems/substrings-that-begin-and-end-with-the-same-letter/",
        "solutionsUrl": "https://leetcode.cn/problems/substrings-that-begin-and-end-with-the-same-letter/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2084.为订单类型为 0 的客户删除类型为 1 的订单",
        "hardRate": "MEDIUM",
        "passRate": "82.48%",
        "problemsUrl": "https://leetcode.cn/problems/drop-type-1-orders-for-customers-with-type-0-orders/",
        "solutionsUrl": "https://leetcode.cn/problems/drop-type-1-orders-for-customers-with-type-0-orders/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2085.统计出现过一次的公共字符串",
        "hardRate": "EASY",
        "passRate": "71.42%",
        "problemsUrl": "https://leetcode.cn/problems/count-common-words-with-one-occurrence/",
        "solutionsUrl": "https://leetcode.cn/problems/count-common-words-with-one-occurrence/solution",
        "problemsDesc": "<p>给你两个字符串数组&nbsp;<code>words1</code>&nbsp;和&nbsp;<code>words2</code>&nbsp;，请你返回在两个字符串数组中 <strong>都恰好出现一次</strong>&nbsp;的字符串的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>words1 = [\"leetcode\",\"is\",\"amazing\",\"as\",\"is\"], words2 = [\"amazing\",\"leetcode\",\"is\"]\n<b>输出：</b>2\n<strong>解释：</strong>\n- \"leetcode\" 在两个数组中都恰好出现一次，计入答案。\n- \"amazing\" 在两个数组中都恰好出现一次，计入答案。\n- \"is\" 在两个数组中都出现过，但在 words1 中出现了 2 次，不计入答案。\n- \"as\" 在 words1 中出现了一次，但是在 words2 中没有出现过，不计入答案。\n所以，有 2 个字符串在两个数组中都恰好出现了一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>words1 = [\"b\",\"bb\",\"bbb\"], words2 = [\"a\",\"aa\",\"aaa\"]\n<b>输出：</b>0\n<b>解释：</b>没有字符串在两个数组中都恰好出现一次。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>words1 = [\"a\",\"ab\"], words2 = [\"a\",\"a\",\"a\",\"ab\"]\n<b>输出：</b>1\n<b>解释：</b>唯一在两个数组中都出现一次的字符串是 \"ab\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words1.length, words2.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words1[i].length, words2[j].length &lt;= 30</code></li>\n\t<li><code>words1[i]</code> 和&nbsp;<code>words2[j]</code>&nbsp;都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2086.从房屋收集雨水需要的最少水桶数",
        "hardRate": "MEDIUM",
        "passRate": "46.78%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-food-buckets-to-feed-the-hamsters/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-food-buckets-to-feed-the-hamsters/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>street</code>&nbsp;。<code>street</code>&nbsp;中每个字符要么是表示房屋的&nbsp;<code>'H'</code> ，要么是表示空位的&nbsp;<code>'.'</code>&nbsp;。</p>\n\n<p>你可以在 <strong>空位</strong>&nbsp;放置水桶，从相邻的房屋收集雨水。位置在 <code>i - 1</code>&nbsp;<strong>或者</strong> <code>i + 1</code>&nbsp;的水桶可以收集位置为 <code>i</code>&nbsp;处房屋的雨水。一个水桶如果相邻两个位置都有房屋，那么它可以收集 <strong>两个</strong> 房屋的雨水。</p>\n\n<p>在确保 <strong>每个</strong>&nbsp;房屋旁边都 <strong>至少</strong>&nbsp;有一个水桶的前提下，请你返回需要的 <strong>最少</strong>&nbsp;水桶数。如果无解请返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>street = \"H..H\"\n<b>输出：</b>2\n<strong>解释：</strong>\n我们可以在下标为 1 和 2 处放水桶。\n\"H..H\" -&gt; \"HBBH\"（'B' 表示放置水桶）。\n下标为 0 处的房屋右边有水桶，下标为 3 处的房屋左边有水桶。\n所以每个房屋旁边都至少有一个水桶收集雨水。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>street = \".H.H.\"\n<b>输出：</b>1\n<strong>解释：</strong>\n我们可以在下标为 2 处放置一个水桶。\n\".H.H.\" -&gt; \".HBH.\"（'B' 表示放置水桶）。\n下标为 1 处的房屋右边有水桶，下标为 3 处的房屋左边有水桶。\n所以每个房屋旁边都至少有一个水桶收集雨水。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>street = \".HHH.\"\n<b>输出：</b>-1\n<strong>解释：</strong>\n没有空位可以放置水桶收集下标为 2 处的雨水。\n所以没有办法收集所有房屋的雨水。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>street = \"H\"\n<b>输出：</b>-1\n<strong>解释：</strong>\n没有空位放置水桶。\n所以没有办法收集所有房屋的雨水。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><b>输入：</b>street = \".\"\n<b>输出：</b>0\n<strong>解释：</strong>\n没有房屋需要收集雨水。\n所以需要 0 个水桶。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= street.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>street[i]</code>&nbsp;要么是&nbsp;<code>'H'</code>&nbsp;，要么是&nbsp;<code>'.'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2087.网格图中机器人回家的最小代价",
        "hardRate": "MEDIUM",
        "passRate": "50.12%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-homecoming-of-a-robot-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-homecoming-of-a-robot-in-a-grid/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的网格图，其中&nbsp;<code>(0, 0)</code>&nbsp;是最左上角的格子，<code>(m - 1, n - 1)</code>&nbsp;是最右下角的格子。给你一个整数数组&nbsp;<code>startPos</code>&nbsp;，<code>startPos = [start<sub>row</sub>, start<sub>col</sub>]</code>&nbsp;表示 <strong>初始</strong>&nbsp;有一个 <strong>机器人</strong>&nbsp;在格子&nbsp;<code>(start<sub>row</sub>, start<sub>col</sub>)</code>&nbsp;处。同时给你一个整数数组&nbsp;<code>homePos</code>&nbsp;，<code>homePos = [home<sub>row</sub>, home<sub>col</sub>]</code>&nbsp;表示机器人的 <strong>家</strong>&nbsp;在格子&nbsp;<code>(home<sub>row</sub>, home<sub>col</sub>)</code>&nbsp;处。</p>\n\n<p>机器人需要回家。每一步它可以往四个方向移动：<strong>上</strong>，<strong>下</strong>，<strong>左</strong>，<strong>右</strong>，同时机器人不能移出边界。每一步移动都有一定代价。再给你两个下标从&nbsp;<strong>0</strong>&nbsp;开始的额整数数组：长度为&nbsp;<code>m</code>&nbsp;的数组&nbsp;<code>rowCosts</code> &nbsp;和长度为 <code>n</code>&nbsp;的数组&nbsp;<code>colCosts</code>&nbsp;。</p>\n\n<ul>\n\t<li>如果机器人往 <strong>上</strong>&nbsp;或者往 <strong>下</strong>&nbsp;移动到第 <code>r</code>&nbsp;<strong>行</strong>&nbsp;的格子，那么代价为&nbsp;<code>rowCosts[r]</code>&nbsp;。</li>\n\t<li>如果机器人往 <strong>左</strong>&nbsp;或者往 <strong>右</strong>&nbsp;移动到第 <code>c</code>&nbsp;<strong>列</strong> 的格子，那么代价为&nbsp;<code>colCosts[c]</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回机器人回家需要的 <strong>最小总代价</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/11/eg-1.png\" style=\"width: 282px; height: 217px;\"></p>\n\n<pre><strong>输入：</strong>startPos = [1, 0], homePos = [2, 3], rowCosts = [5, 4, 3], colCosts = [8, 2, 6, 7]\n<b>输出：</b>18\n<b>解释：</b>一个最优路径为：\n从 (1, 0) 开始\n-&gt; 往下走到 (<em><strong>2</strong></em>, 0) 。代价为 rowCosts[2] = 3 。\n-&gt; 往右走到 (2, <em><strong>1</strong></em>) 。代价为 colCosts[1] = 2 。\n-&gt; 往右走到 (2, <em><strong>2</strong></em>) 。代价为 colCosts[2] = 6 。\n-&gt; 往右走到 (2, <em><strong>3</strong></em>) 。代价为 colCosts[3] = 7 。\n总代价为 3 + 2 + 6 + 7 = 18</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>startPos = [0, 0], homePos = [0, 0], rowCosts = [5], colCosts = [26]\n<b>输出：</b>0\n<b>解释：</b>机器人已经在家了，所以不需要移动。总代价为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == rowCosts.length</code></li>\n\t<li><code>n == colCosts.length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= rowCosts[r], colCosts[c] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>startPos.length == 2</code></li>\n\t<li><code>homePos.length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>row</sub>, home<sub>row</sub> &lt; m</code></li>\n\t<li><code>0 &lt;= start<sub>col</sub>, home<sub>col</sub> &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2088.统计农场中肥沃金字塔的数目",
        "hardRate": "HARD",
        "passRate": "63.40%",
        "problemsUrl": "https://leetcode.cn/problems/count-fertile-pyramids-in-a-land/",
        "solutionsUrl": "https://leetcode.cn/problems/count-fertile-pyramids-in-a-land/solution",
        "problemsDesc": "<p>有一个 <strong>矩形网格</strong>&nbsp;状的农场，划分为&nbsp;<code>m</code>&nbsp;行&nbsp;<code>n</code>&nbsp;列的单元格。每个格子要么是 <strong>肥沃的</strong>&nbsp;（用 <code>1</code>&nbsp;表示），要么是 <strong>贫瘠</strong>&nbsp;的（用 <code>0</code>&nbsp;表示）。网格图以外的所有与格子都视为贫瘠的。</p>\n\n<p>农场中的&nbsp;<strong>金字塔</strong>&nbsp;区域定义如下：</p>\n\n<ol>\n\t<li>区域内格子数目 <strong>大于&nbsp;</strong><code>1</code>&nbsp;且所有格子都是 <strong>肥沃的</strong>&nbsp;。</li>\n\t<li>金字塔 <strong>顶端</strong>&nbsp;是这个金字塔 <strong>最上方</strong>&nbsp;的格子。金字塔的高度是它所覆盖的行数。令&nbsp;<code>(r, c)</code>&nbsp;为金字塔的顶端且高度为 <code>h</code>&nbsp;，那么金字塔区域内包含的任一格子&nbsp;<code>(i, j)</code>&nbsp;需满足&nbsp;<code>r &lt;= i &lt;= r + h - 1</code>&nbsp;<strong>且</strong>&nbsp;<code>c - (i - r) &lt;= j &lt;= c + (i - r)</code>&nbsp;。</li>\n</ol>\n\n<p>一个 <strong>倒金字塔</strong>&nbsp;类似定义如下：</p>\n\n<ol>\n\t<li>区域内格子数目 <strong>大于</strong>&nbsp;<code>1</code>&nbsp;且所有格子都是 <b>肥沃的</b>&nbsp;。</li>\n\t<li>倒金字塔的 <strong>顶端</strong>&nbsp;是这个倒金字塔 <strong>最下方</strong>&nbsp;的格子。倒金字塔的高度是它所覆盖的行数。令&nbsp;<code>(r, c)</code>&nbsp;为金字塔的顶端且高度为 <code>h</code>&nbsp;，那么金字塔区域内包含的任一格子&nbsp;<code>(i, j)</code>&nbsp;需满足&nbsp;<code>r - h + 1 &lt;= i &lt;= r</code> <strong>且</strong> <code>c - (r - i) &lt;= j &lt;= c + (r - i)</code>&nbsp;。</li>\n</ol>\n\n<p>下图展示了部分符合定义和不符合定义的金字塔区域。黑色区域表示肥沃的格子。</p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/11/08/image.png\" style=\"width: 700px; height: 156px;\"></p>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始且大小为 <code>m x n</code>&nbsp;的二进制矩阵&nbsp;<code>grid</code>&nbsp;，它表示农场，请你返回 <code>grid</code>&nbsp;中金字塔和倒金字塔的&nbsp;<strong>总数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/eg11.png\" style=\"width: 200px; height: 102px;\">&nbsp;<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/exa12.png\" style=\"width: 200px; height: 102px;\">&nbsp;<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/exa13.png\" style=\"width: 200px; height: 102px;\"></p>\n\n<pre><b>输入：</b>grid = [[0,1,1,0],[1,1,1,1]]\n<b>输出：</b>2\n<strong>解释：</strong>\n2 个可能的金字塔区域分别如上图蓝色和红色区域所示。\n这个网格图中没有倒金字塔区域。\n所以金字塔区域总数为 2 + 0 = 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/eg21.png\" style=\"width: 180px; height: 122px;\">&nbsp;<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/exa22.png\" style=\"width: 180px; height: 122px;\">&nbsp;<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/exa23.png\" style=\"width: 180px; height: 122px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,1,1],[1,1,1]]\n<b>输出：</b>2\n<strong>解释：</strong>\n金字塔区域如上图蓝色区域所示，倒金字塔如上图红色区域所示。\n所以金字塔区域总数目为 1 + 1 = 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/eg3.png\" style=\"width: 149px; height: 150px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,0,1],[0,0,0],[1,0,1]]\n<b>输出：</b>0\n<strong>解释：</strong>\n网格图中没有任何金字塔或倒金字塔区域。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/eg41.png\" style=\"width: 180px; height: 144px;\">&nbsp;<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/eg42.png\" style=\"width: 180px; height: 144px;\">&nbsp;<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/eg43.png\" style=\"width: 180px; height: 144px;\">&nbsp;<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/eg44.png\" style=\"width: 180px; height: 144px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]]\n<b>输出：</b>13\n<strong>解释：</strong>\n有 7 个金字塔区域。上图第二和第三张图中展示了它们中的 3 个。\n有 6 个倒金字塔区域。上图中最后一张图展示了它们中的 2 个。\n所以金字塔区域总数目为 7 + 6 = 13.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>grid[i][j]</code>&nbsp;要么是&nbsp;<code>0</code>&nbsp;，要么是&nbsp;<code>1</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2089.找出数组排序后的目标下标",
        "hardRate": "EASY",
        "passRate": "78.51%",
        "problemsUrl": "https://leetcode.cn/problems/find-target-indices-after-sorting-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-target-indices-after-sorting-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 以及一个目标元素 <code>target</code> 。</p>\n\n<p><strong>目标下标</strong> 是一个满足&nbsp;<code>nums[i] == target</code> 的下标 <code>i</code> 。</p>\n\n<p>将 <code>nums</code> 按 <strong>非递减</strong> 顺序排序后，返回由 <code>nums</code> 中目标下标组成的列表。如果不存在目标下标，返回一个 <strong>空</strong> 列表。返回的列表必须按 <strong>递增</strong> 顺序排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,5,2,3], target = 2\n<strong>输出：</strong>[1,2]\n<strong>解释：</strong>排序后，nums 变为 [1,<em><strong>2</strong></em>,<em><strong>2</strong></em>,3,5] 。\n满足 nums[i] == 2 的下标是 1 和 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,5,2,3], target = 3\n<strong>输出：</strong>[3]\n<strong>解释：</strong>排序后，nums 变为 [1,2,2,<em><strong>3</strong></em>,5] 。\n满足 nums[i] == 3 的下标是 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,5,2,3], target = 5\n<strong>输出：</strong>[4]\n<strong>解释：</strong>排序后，nums 变为 [1,2,2,3,<em><strong>5</strong></em>] 。\n满足 nums[i] == 5 的下标是 4 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,5,2,3], target = 4\n<strong>输出：</strong>[]\n<strong>解释：</strong>nums 中不含值为 4 的元素。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i], target &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2090.半径为 k 的子数组平均值",
        "hardRate": "MEDIUM",
        "passRate": "37.53%",
        "problemsUrl": "https://leetcode.cn/problems/k-radius-subarray-averages/",
        "solutionsUrl": "https://leetcode.cn/problems/k-radius-subarray-averages/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，数组中有 <code>n</code> 个整数，另给你一个整数 <code>k</code> 。</p>\n\n<p><strong>半径为 k 的子数组平均值</strong> 是指：<code>nums</code> 中一个以下标 <code>i</code> 为 <strong>中心</strong> 且 <strong>半径</strong> 为 <code>k</code> 的子数组中所有元素的平均值，即下标在&nbsp;<code>i - k</code> 和 <code>i + k</code> 范围（<strong>含</strong> <code>i - k</code> 和 <code>i + k</code>）内所有元素的平均值。如果在下标 <code>i</code> 前或后不足 <code>k</code> 个元素，那么<strong> 半径为 k 的子数组平均值 </strong>是 <code>-1</code> 。</p>\n\n<p>构建并返回一个长度为 <code>n</code> 的数组<em> </em><code>avgs</code><em> </em>，其中<em> </em><code>avgs[i]</code><em> </em>是以下标 <code>i</code> 为中心的子数组的<strong> 半径为 k 的子数组平均值 </strong>。</p>\n\n<p><code>x</code> 个元素的 <strong>平均值</strong> 是 <code>x</code> 个元素相加之和除以 <code>x</code> ，此时使用截断式 <strong>整数除法</strong> ，即需要去掉结果的小数部分。</p>\n\n<ul>\n\t<li>例如，四个元素 <code>2</code>、<code>3</code>、<code>1</code> 和 <code>5</code> 的平均值是 <code>(2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75</code>，截断后得到 <code>2</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/07/eg1.png\" style=\"width: 343px; height: 119px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [7,4,3,9,1,8,5,2,6], k = 3\n<strong>输出：</strong>[-1,-1,-1,5,4,4,-1,-1,-1]\n<strong>解释：</strong>\n- avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。\n- 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。\n  使用截断式 <strong>整数除法</strong>，avg[3] = 37 / 7 = 5 。\n- 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。\n- 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。\n- avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [100000], k = 0\n<strong>输出：</strong>[100000]\n<strong>解释：</strong>\n- 中心为下标 0 且半径 0 的子数组的元素总和是：100000 。\n  avg[0] = 100000 / 1 = 100000 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [8], k = 100000\n<strong>输出：</strong>[-1]\n<strong>解释：</strong>\n- avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i], k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2091.从数组中移除最大值和最小值",
        "hardRate": "MEDIUM",
        "passRate": "56.57%",
        "problemsUrl": "https://leetcode.cn/problems/removing-minimum-and-maximum-from-array/",
        "solutionsUrl": "https://leetcode.cn/problems/removing-minimum-and-maximum-from-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，数组由若干 <strong>互不相同</strong> 的整数组成。</p>\n\n<p><code>nums</code> 中有一个值最小的元素和一个值最大的元素。分别称为 <strong>最小值</strong> 和 <strong>最大值</strong> 。你的目标是从数组中移除这两个元素。</p>\n\n<p>一次 <strong>删除</strong> 操作定义为从数组的 <strong>前面</strong> 移除一个元素或从数组的 <strong>后面</strong> 移除一个元素。</p>\n\n<p>返回将数组中最小值和最大值 <strong>都</strong> 移除需要的最小删除次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,<em><strong>10</strong></em>,7,5,4,<em><strong>1</strong></em>,8,6]\n<strong>输出：</strong>5\n<strong>解释：</strong>\n数组中的最小元素是 nums[5] ，值为 1 。\n数组中的最大元素是 nums[1] ，值为 10 。\n将最大值和最小值都移除需要从数组前面移除 2 个元素，从数组后面移除 3 个元素。\n结果是 2 + 3 = 5 ，这是所有可能情况中的最小删除次数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,<em><strong>-4</strong></em>,<em><strong>19</strong></em>,1,8,-2,-3,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n数组中的最小元素是 nums[1] ，值为 -4 。\n数组中的最大元素是 nums[2] ，值为 19 。\n将最大值和最小值都移除需要从数组前面移除 3 个元素。\n结果是 3 ，这是所有可能情况中的最小删除次数。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<em><strong>101</strong></em>]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n数组中只有这一个元素，那么它既是数组中的最小值又是数组中的最大值。\n移除它只需要 1 次删除操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums</code> 中的整数 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2092.找出知晓秘密的所有专家",
        "hardRate": "HARD",
        "passRate": "29.12%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-people-with-secret/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-people-with-secret/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，表示有 <code>n</code> 个专家从 <code>0</code> 到 <code>n - 1</code> 编号。另外给你一个下标从 0 开始的二维整数数组 <code>meetings</code> ，其中 <code>meetings[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>]</code> 表示专家 <code>x<sub>i</sub></code> 和专家 <code>y<sub>i</sub></code> 在时间 <code>time<sub>i</sub></code> 要开一场会。一个专家可以同时参加 <strong>多场会议</strong> 。最后，给你一个整数 <code>firstPerson</code> 。</p>\n\n<p>专家 <code>0</code> 有一个 <strong>秘密</strong> ，最初，他在时间&nbsp;<code>0</code> 将这个秘密分享给了专家 <code>firstPerson</code> 。接着，这个秘密会在每次有知晓这个秘密的专家参加会议时进行传播。更正式的表达是，每次会议，如果专家 <code>x<sub>i</sub></code> 在时间 <code>time<sub>i</sub></code> 时知晓这个秘密，那么他将会与专家 <code>y<sub>i</sub></code> 分享这个秘密，反之亦然。</p>\n\n<p>秘密共享是 <strong>瞬时发生</strong> 的。也就是说，在同一时间，一个专家不光可以接收到秘密，还能在其他会议上与其他专家分享。</p>\n\n<p>在所有会议都结束之后，返回所有知晓这个秘密的专家列表。你可以按 <strong>任何顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1\n<strong>输出：</strong>[0,1,2,3,5]\n<strong>解释：\n</strong>时间 0 ，专家 0 将秘密与专家 1 共享。\n时间 5 ，专家 1 将秘密与专家 2 共享。\n时间 8 ，专家 2 将秘密与专家 3 共享。\n时间 10 ，专家 1 将秘密与专家 5 共享。\n因此，在所有会议结束后，专家 0、1、2、3 和 5 都将知晓这个秘密。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3\n<strong>输出：</strong>[0,1,3]\n<strong>解释：</strong>\n时间 0 ，专家 0 将秘密与专家 3 共享。\n时间 2 ，专家 1 与专家 2 都不知晓这个秘密。\n时间 3 ，专家 3 将秘密与专家 0 和专家 1 共享。\n因此，在所有会议结束后，专家 0、1 和 3 都将知晓这个秘密。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1\n<strong>输出：</strong>[0,1,2,3,4]\n<strong>解释：</strong>\n时间 0 ，专家 0 将秘密与专家 1 共享。\n时间 1 ，专家 1 将秘密与专家 2 共享，专家 2 将秘密与专家 3 共享。\n注意，专家 2 可以在收到秘密的同一时间分享此秘密。\n时间 2 ，专家 3 将秘密与专家 4 共享。\n因此，在所有会议结束后，专家 0、1、2、3 和 4 都将知晓这个秘密。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= meetings.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>meetings[i].length == 3</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i </sub>&lt;= n - 1</code></li>\n\t<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>\n\t<li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= firstPerson &lt;= n - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2093.前往目标城市的最小费用",
        "hardRate": "MEDIUM",
        "passRate": "58.63%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-reach-city-with-discounts/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-reach-city-with-discounts/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2094.找出 3 位偶数",
        "hardRate": "EASY",
        "passRate": "55.73%",
        "problemsUrl": "https://leetcode.cn/problems/finding-3-digit-even-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/finding-3-digit-even-numbers/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>digits</code> ，其中每个元素是一个数字（<code>0 - 9</code>）。数组中可能存在重复元素。</p>\n\n<p>你需要找出 <strong>所有</strong> 满足下述条件且 <strong>互不相同</strong> 的整数：</p>\n\n<ul>\n\t<li>该整数由 <code>digits</code> 中的三个元素按 <strong>任意</strong> 顺序 <strong>依次连接</strong> 组成。</li>\n\t<li>该整数不含 <strong>前导零</strong></li>\n\t<li>该整数是一个 <strong>偶数</strong></li>\n</ul>\n\n<p>例如，给定的 <code>digits</code> 是 <code>[1, 2, 3]</code> ，整数 <code>132</code> 和 <code>312</code> 满足上面列出的全部条件。</p>\n\n<p>将找出的所有互不相同的整数按 <strong>递增顺序</strong> 排列，并以数组形式返回<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = [2,1,3,0]\n<strong>输出：</strong>[102,120,130,132,210,230,302,310,312,320]\n<strong>解释：</strong>\n所有满足题目条件的整数都在输出数组中列出。 \n注意，答案数组中不含有 <strong>奇数</strong> 或带 <strong>前导零</strong> 的整数。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = [2,2,8,8,2]\n<strong>输出：</strong>[222,228,282,288,822,828,882]\n<strong>解释：</strong>\n同样的数字（0 - 9）在构造整数时可以重复多次，重复次数最多与其在 <code>digits</code> 中出现的次数一样。 \n在这个例子中，数字 8 在构造 288、828 和 882 时都重复了两次。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = [3,7,5]\n<strong>输出：</strong>[]\n<strong>解释：</strong>\n使用给定的 digits 无法构造偶数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;=&nbsp;digits.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= digits[i] &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2095.删除链表的中间节点",
        "hardRate": "MEDIUM",
        "passRate": "57.52%",
        "problemsUrl": "https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/solution",
        "problemsDesc": "<p>给你一个链表的头节点 <code>head</code> 。<strong>删除</strong> 链表的 <strong>中间节点</strong> ，并返回修改后的链表的头节点 <code>head</code> 。</p>\n\n<p>长度为 <code>n</code> 链表的中间节点是从头数起第 <code>⌊n / 2⌋</code> 个节点（下标从 <strong>0</strong> 开始），其中 <code>⌊x⌋</code> 表示小于或等于 <code>x</code> 的最大整数。</p>\n\n<ul>\n\t<li>对于 <code>n</code> = <code>1</code>、<code>2</code>、<code>3</code>、<code>4</code> 和 <code>5</code> 的情况，中间节点的下标分别是 <code>0</code>、<code>1</code>、<code>1</code>、<code>2</code> 和 <code>2</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/16/eg1drawio.png\" style=\"width: 500px; height: 77px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,3,4,7,1,2,6]\n<strong>输出：</strong>[1,3,4,1,2,6]\n<strong>解释：</strong>\n上图表示给出的链表。节点的下标分别标注在每个节点的下方。\n由于 n = 7 ，值为 7 的节点 3 是中间节点，用红色标注。\n返回结果为移除节点后的新链表。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/16/eg2drawio.png\" style=\"width: 250px; height: 43px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,3,4]\n<strong>输出：</strong>[1,2,4]\n<strong>解释：</strong>\n上图表示给出的链表。\n对于 n = 4 ，值为 3 的节点 2 是中间节点，用红色标注。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/16/eg3drawio.png\" style=\"width: 150px; height: 58px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [2,1]\n<strong>输出：</strong>[2]\n<strong>解释：</strong>\n上图表示给出的链表。\n对于 n = 2 ，值为 1 的节点 1 是中间节点，用红色标注。\n值为 2 的节点 0 是移除节点 1 后剩下的唯一一个节点。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2096.从二叉树一个节点到另一个节点每一步的方向",
        "hardRate": "MEDIUM",
        "passRate": "44.58%",
        "problemsUrl": "https://leetcode.cn/problems/step-by-step-directions-from-a-binary-tree-node-to-another/",
        "solutionsUrl": "https://leetcode.cn/problems/step-by-step-directions-from-a-binary-tree-node-to-another/solution",
        "problemsDesc": "<p>给你一棵 <strong>二叉树</strong>&nbsp;的根节点&nbsp;<code>root</code>&nbsp;，这棵二叉树总共有&nbsp;<code>n</code>&nbsp;个节点。每个节点的值为&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;中的一个整数，且互不相同。给你一个整数&nbsp;<code>startValue</code>&nbsp;，表示起点节点 <code>s</code>&nbsp;的值，和另一个不同的整数&nbsp;<code>destValue</code>&nbsp;，表示终点节点&nbsp;<code>t</code>&nbsp;的值。</p>\n\n<p>请找到从节点&nbsp;<code>s</code>&nbsp;到节点 <code>t</code>&nbsp;的 <strong>最短路径</strong>&nbsp;，并以字符串的形式返回每一步的方向。每一步用 <strong>大写</strong>&nbsp;字母&nbsp;<code>'L'</code>&nbsp;，<code>'R'</code>&nbsp;和&nbsp;<code>'U'</code>&nbsp;分别表示一种方向：</p>\n\n<ul>\n\t<li><code>'L'</code>&nbsp;表示从一个节点前往它的 <strong>左孩子</strong>&nbsp;节点。</li>\n\t<li><code>'R'</code>&nbsp;表示从一个节点前往它的 <strong>右孩子</strong>&nbsp;节点。</li>\n\t<li><code>'U'</code>&nbsp;表示从一个节点前往它的 <strong>父</strong>&nbsp;节点。</li>\n</ul>\n\n<p>请你返回从 <code>s</code>&nbsp;到 <code>t</code>&nbsp;<strong>最短路径</strong>&nbsp;每一步的方向。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/15/eg1.png\" style=\"width: 214px; height: 163px;\"></p>\n\n<pre><b>输入：</b>root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6\n<b>输出：</b>\"UURL\"\n<b>解释：</b>最短路径为：3 → 1 → 5 → 2 → 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/15/eg2.png\" style=\"width: 74px; height: 102px;\"></p>\n\n<pre><b>输入：</b>root = [2,1], startValue = 2, destValue = 1\n<b>输出：</b>\"L\"\n<b>解释：</b>最短路径为：2 → 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目为&nbsp;<code>n</code>&nbsp;。</li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= Node.val &lt;= n</code></li>\n\t<li>树中所有节点的值 <strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>1 &lt;= startValue, destValue &lt;= n</code></li>\n\t<li><code>startValue != destValue</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2097.合法重新排列数对",
        "hardRate": "HARD",
        "passRate": "37.97%",
        "problemsUrl": "https://leetcode.cn/problems/valid-arrangement-of-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-arrangement-of-pairs/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>pairs</code>&nbsp;，其中&nbsp;<code>pairs[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>&nbsp;。如果 <code>pairs</code>&nbsp;的一个重新排列，满足对每一个下标 <code>i</code> （&nbsp;<code>1 &lt;= i &lt; pairs.length</code>&nbsp;）都有&nbsp;<code>end<sub>i-1</sub> == start<sub>i</sub></code><sub> </sub>，那么我们就认为这个重新排列是&nbsp;<code>pairs</code> 的一个 <strong>合法重新排列</strong> 。</p>\n\n<p>请你返回 <strong>任意一个</strong>&nbsp;<code>pairs</code> 的合法重新排列。</p>\n\n<p><b>注意：</b>数据保证至少存在一个 <code>pairs</code>&nbsp;的合法重新排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>pairs = [[5,1],[4,5],[11,9],[9,4]]\n<b>输出：</b>[[11,9],[9,4],[4,5],[5,1]]\n<strong>解释：\n</strong>输出的是一个合法重新排列，因为每一个 end<sub>i-1</sub> 都等于 start<sub>i</sub>&nbsp;。\nend<sub>0</sub> = 9 == 9 = start<sub>1</sub> \nend<sub>1</sub> = 4 == 4 = start<sub>2</sub>\nend<sub>2</sub> = 5 == 5 = start<sub>3</sub>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>pairs = [[1,3],[3,2],[2,1]]\n<b>输出：</b>[[1,3],[3,2],[2,1]]\n<strong>解释：</strong>\n输出的是一个合法重新排列，因为每一个 end<sub>i-1</sub> 都等于 start<sub>i</sub>&nbsp;。\nend<sub>0</sub> = 3 == 3 = start<sub>1</sub>\nend<sub>1</sub> = 2 == 2 = start<sub>2</sub>\n重新排列后的数组 [[2,1],[1,3],[3,2]] 和 [[3,2],[2,1],[1,3]] 都是合法的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>pairs = [[1,2],[1,3],[2,1]]\n<b>输出：</b>[[1,2],[2,1],[1,3]]\n<strong>解释：</strong>\n输出的是一个合法重新排列，因为每一个 end<sub>i-1</sub> 都等于 start<sub>i</sub>&nbsp;。\nend<sub>0</sub> = 2 == 2 = start<sub>1</sub>\nend<sub>1</sub> = 1 == 1 = start<sub>2</sub>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pairs.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pairs[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub>, end<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>start<sub>i</sub> != end<sub>i</sub></code></li>\n\t<li><code>pairs</code>&nbsp;中不存在一模一样的数对。</li>\n\t<li>至少 <strong>存在</strong> 一个合法的&nbsp;<code>pairs</code>&nbsp;重新排列。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2098.长度为 K 的最大偶数和子序列",
        "hardRate": "MEDIUM",
        "passRate": "35.03%",
        "problemsUrl": "https://leetcode.cn/problems/subsequence-of-size-k-with-the-largest-even-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/subsequence-of-size-k-with-the-largest-even-sum/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2099.找到和最大的长度为 K 的子序列",
        "hardRate": "EASY",
        "passRate": "48.40%",
        "problemsUrl": "https://leetcode.cn/problems/find-subsequence-of-length-k-with-the-largest-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/find-subsequence-of-length-k-with-the-largest-sum/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。你需要找到&nbsp;<code>nums</code>&nbsp;中长度为 <code>k</code>&nbsp;的 <strong>子序列</strong>&nbsp;，且这个子序列的&nbsp;<strong>和最大&nbsp;</strong>。</p>\n\n<p>请你返回 <strong>任意</strong> 一个长度为&nbsp;<code>k</code>&nbsp;的整数子序列。</p>\n\n<p><strong>子序列</strong>&nbsp;定义为从一个数组里删除一些元素后，不改变剩下元素的顺序得到的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,1,3,3], k = 2\n<b>输出：</b>[3,3]\n<strong>解释：</strong>\n子序列有最大和：3 + 3 = 6 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [-1,-2,3,4], k = 3\n<b>输出：</b>[-1,3,4]\n<b>解释：</b>\n子序列有最大和：-1 + 3 + 4 = 6 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [3,4,3,3], k = 2\n<b>输出：</b>[3,4]\n<strong>解释：</strong>\n子序列有最大和：3 + 4 = 7 。\n另一个可行的子序列为 [4, 3] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2100.适合打劫银行的日子",
        "hardRate": "MEDIUM",
        "passRate": "48.68%",
        "problemsUrl": "https://leetcode.cn/problems/find-good-days-to-rob-the-bank/",
        "solutionsUrl": "https://leetcode.cn/problems/find-good-days-to-rob-the-bank/solution",
        "problemsDesc": "<p>你和一群强盗准备打劫银行。给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>security</code>&nbsp;，其中&nbsp;<code>security[i]</code>&nbsp;是第 <code>i</code>&nbsp;天执勤警卫的数量。日子从 <code>0</code>&nbsp;开始编号。同时给你一个整数&nbsp;<code>time</code>&nbsp;。</p>\n\n<p>如果第 <code>i</code>&nbsp;天满足以下所有条件，我们称它为一个适合打劫银行的日子：</p>\n\n<ul>\n\t<li>第 <code>i</code>&nbsp;天前和后都分别至少有 <code>time</code>&nbsp;天。</li>\n\t<li>第 <code>i</code>&nbsp;天前连续 <code>time</code>&nbsp;天警卫数目都是非递增的。</li>\n\t<li>第 <code>i</code>&nbsp;天后连续 <code>time</code>&nbsp;天警卫数目都是非递减的。</li>\n</ul>\n\n<p>更正式的，第 <code>i</code> 天是一个合适打劫银行的日子当且仅当：<code>security[i - time] &gt;= security[i - time + 1] &gt;= ... &gt;= security[i] &lt;= ... &lt;= security[i + time - 1] &lt;= security[i + time]</code>.</p>\n\n<p>请你返回一个数组，包含 <strong>所有</strong> 适合打劫银行的日子（下标从 <strong>0</strong>&nbsp;开始）。返回的日子可以 <strong>任意</strong>&nbsp;顺序排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>security = [5,3,3,3,5,6,2], time = 2\n<b>输出：</b>[2,3]\n<strong>解释：</strong>\n第 2 天，我们有 security[0] &gt;= security[1] &gt;= security[2] &lt;= security[3] &lt;= security[4] 。\n第 3 天，我们有 security[1] &gt;= security[2] &gt;= security[3] &lt;= security[4] &lt;= security[5] 。\n没有其他日子符合这个条件，所以日子 2 和 3 是适合打劫银行的日子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>security = [1,1,1,1,1], time = 0\n<b>输出：</b>[0,1,2,3,4]\n<strong>解释：</strong>\n因为 time 等于 0 ，所以每一天都是适合打劫银行的日子，所以返回每一天。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>security = [1,2,3,4,5,6], time = 2\n<b>输出：</b>[]\n<strong>解释：</strong>\n没有任何一天的前 2 天警卫数目是非递增的。\n所以没有适合打劫银行的日子，返回空数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= security.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= security[i], time &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    }
]