[
    {
        "problemsName": " 901.股票价格跨度",
        "hardRate": "MEDIUM",
        "passRate": "62.26%",
        "problemsUrl": "https://leetcode.cn/problems/online-stock-span/",
        "solutionsUrl": "https://leetcode.cn/problems/online-stock-span/solution",
        "problemsDesc": "<p>设计一个算法收集某些股票的每日报价，并返回该股票当日价格的 <strong>跨度</strong> 。</p>\n\n<p>当日股票价格的 <strong>跨度</strong> 被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。</p>\n\n<ul>\n\t<li>\n\t<p>例如，如果未来 7 天股票的价格是 <code>[100,80,60,70,60,75,85]</code>，那么股票跨度将是 <code>[1,1,1,2,1,4,6]</code> 。</p>\n\t</li>\n</ul>\n\n<p>实现 <code>StockSpanner</code> 类：</p>\n\n<ul>\n\t<li><code>StockSpanner()</code> 初始化类对象。</li>\n\t<li><code>int next(int price)</code> 给出今天的股价 <code>price</code> ，返回该股票当日价格的 <strong>跨度</strong> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例：</strong></p>\n\n<pre>\n<strong>输入</strong>：\n[\"StockSpanner\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\"]\n[[], [100], [80], [60], [70], [60], [75], [85]]\n<strong>输出</strong>：\n[null, 1, 1, 1, 2, 1, 4, 6]\n\n<strong>解释：</strong>\nStockSpanner stockSpanner = new StockSpanner();\nstockSpanner.next(100); // 返回 1\nstockSpanner.next(80);  // 返回 1\nstockSpanner.next(60);  // 返回 1\nstockSpanner.next(70);  // 返回 2\nstockSpanner.next(60);  // 返回 1\nstockSpanner.next(75);  // 返回 4 ，因为截至今天的最后 4 个股价 (包括今天的股价 75) 都小于或等于今天的股价。\nstockSpanner.next(85);  // 返回 6\n</pre>\n&nbsp;\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= price &lt;= 10<sup>5</sup></code></li>\n\t<li>最多调用 <code>next</code> 方法 <code>10<sup>4</sup></code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 902.最大为 N 的数字组合",
        "hardRate": "HARD",
        "passRate": "46.23%",
        "problemsUrl": "https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/",
        "solutionsUrl": "https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/solution",
        "problemsDesc": "<p>给定一个按&nbsp;<strong>非递减顺序</strong>&nbsp;排列的数字数组<meta charset=\"UTF-8\" />&nbsp;<code>digits</code>&nbsp;。你可以用任意次数&nbsp;<code>digits[i]</code>&nbsp;来写的数字。例如，如果<meta charset=\"UTF-8\" />&nbsp;<code>digits = ['1','3','5']</code>，我们可以写数字，如<meta charset=\"UTF-8\" />&nbsp;<code>'13'</code>,&nbsp;<code>'551'</code>, 和&nbsp;<code>'1351315'</code>。</p>\n\n<p>返回 <em>可以生成的小于或等于给定整数 <code>n</code> 的正整数的个数</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = [\"1\",\"3\",\"5\",\"7\"], n = 100\n<strong>输出：</strong>20\n<strong>解释：</strong>\n可写出的 20 个数字是：\n1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = [\"1\",\"4\",\"9\"], n = 1000000000\n<strong>输出：</strong>29523\n<strong>解释：</strong>\n我们可以写 3 个一位数字，9 个两位数字，27 个三位数字，\n81 个四位数字，243 个五位数字，729 个六位数字，\n2187 个七位数字，6561 个八位数字和 19683 个九位数字。\n总共，可以使用D中的数字写出 29523 个整数。</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = [\"7\"], n = 8\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>1 &lt;= digits.length &lt;= 9</code></li>\n\t<li><code>digits[i].length == 1</code></li>\n\t<li><code>digits[i]</code>&nbsp;是从&nbsp;<code>'1'</code>&nbsp;到&nbsp;<code>'9'</code> 的数</li>\n\t<li><code>digits</code>&nbsp;中的所有值都 <strong>不同</strong>&nbsp;</li>\n\t<li><code>digits</code>&nbsp;按&nbsp;<strong>非递减顺序</strong>&nbsp;排列</li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 903.DI 序列的有效排列",
        "hardRate": "HARD",
        "passRate": "56.46%",
        "problemsUrl": "https://leetcode.cn/problems/valid-permutations-for-di-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-permutations-for-di-sequence/solution",
        "problemsDesc": "<p>给定一个长度为 <code>n</code> 的字符串 <code>s</code> ，其中 <code>s[i]</code> 是:</p>\n\n<ul>\n\t<li><code>“D”</code> 意味着减少，或者</li>\n\t<li><code>“I”</code> 意味着增加</li>\n</ul>\n\n<p><strong>有效排列</strong>&nbsp;是对有&nbsp;<code>n + 1</code>&nbsp;个在&nbsp;<code>[0, n]</code>&nbsp; 范围内的整数的一个排列&nbsp;<code>perm</code>&nbsp;，使得对所有的&nbsp;<code>i</code>：</p>\n\n<ul>\n\t<li>如果 <code>s[i] == 'D'</code>，那么&nbsp;<code>perm[i] &gt; perm[i+1]</code>，以及；</li>\n\t<li>如果 <code>s[i] == 'I'</code>，那么 <code>perm[i] &lt; perm[i+1]</code>。</li>\n</ul>\n\n<p>返回 <em><strong>有效排列 </strong>&nbsp;</em><code>perm</code><em>的数量 </em>。因为答案可能很大，所以请<strong>返回你的答案对</strong>&nbsp;<code>10<sup>9</sup>&nbsp;+ 7</code><strong>&nbsp;取余</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"DID\"\n<strong>输出：</strong>5\n<strong>解释：</strong>\n(0, 1, 2, 3) 的五个有效排列是：\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"D\"\n<strong>输出:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>n == s.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>s[i]</code>&nbsp;不是&nbsp;<code>'I'</code>&nbsp;就是&nbsp;<code>'D'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 904.水果成篮",
        "hardRate": "MEDIUM",
        "passRate": "44.80%",
        "problemsUrl": "https://leetcode.cn/problems/fruit-into-baskets/",
        "solutionsUrl": "https://leetcode.cn/problems/fruit-into-baskets/solution",
        "problemsDesc": "<p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 <code>fruits</code> 表示，其中 <code>fruits[i]</code> 是第 <code>i</code> 棵树上的水果 <strong>种类</strong> 。</p>\n\n<p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p>\n\n<ul>\n\t<li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装 <strong>单一类型</strong> 的水果。每个篮子能够装的水果总量没有限制。</li>\n\t<li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong> 树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong> 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li>\n\t<li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li>\n</ul>\n\n<p>给你一个整数数组 <code>fruits</code> ，返回你可以收集的水果的 <strong>最大</strong> 数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>fruits = [<em><strong>1,2,1</strong></em>]\n<strong>输出：</strong>3\n<strong>解释：</strong>可以采摘全部 3 棵树。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>fruits = [0,<em><strong>1,2,2</strong></em>]\n<strong>输出：</strong>3\n<strong>解释：</strong>可以采摘 [1,2,2] 这三棵树。\n如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>fruits = [1,<em><strong>2,3,2,2</strong></em>]\n<strong>输出：</strong>4\n<strong>解释：</strong>可以采摘 [2,3,2,2] 这四棵树。\n如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>fruits = [3,3,3,<em><strong>1,2,1,1,2</strong></em>,3,3,4]\n<strong>输出：</strong>5\n<strong>解释：</strong>可以采摘 [1,2,1,1,2] 这五棵树。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= fruits.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= fruits[i] &lt; fruits.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 905.按奇偶排序数组",
        "hardRate": "EASY",
        "passRate": "70.97%",
        "problemsUrl": "https://leetcode.cn/problems/sort-array-by-parity/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-array-by-parity/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>，将 <code>nums</code> 中的的所有偶数元素移动到数组的前面，后跟所有奇数元素。</p>\n\n<p>返回满足此条件的 <strong>任一数组</strong> 作为答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,1,2,4]\n<strong>输出：</strong>[2,4,3,1]\n<strong>解释：</strong>[4,2,3,1]、[2,4,1,3] 和 [4,2,1,3] 也会被视作正确答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>[0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 5000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 906.超级回文数",
        "hardRate": "HARD",
        "passRate": "31.73%",
        "problemsUrl": "https://leetcode.cn/problems/super-palindromes/",
        "solutionsUrl": "https://leetcode.cn/problems/super-palindromes/solution",
        "problemsDesc": "<p>如果一个正整数自身是回文数，而且它也是一个回文数的平方，那么我们称这个数为超级回文数。</p>\n\n<p>现在，给定两个正整数&nbsp;<code>L</code> 和&nbsp;<code>R</code> （以字符串形式表示），返回包含在范围 <code>[L, R]</code> 中的超级回文数的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>L = &quot;4&quot;, R = &quot;1000&quot;\n<strong>输出：</strong>4\n<strong>解释：\n</strong>4，9，121，以及 484 是超级回文数。\n注意 676 不是一个超级回文数： 26 * 26 = 676，但是 26 不是回文数。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= len(L) &lt;= 18</code></li>\n\t<li><code>1 &lt;= len(R) &lt;= 18</code></li>\n\t<li><code>L</code> 和&nbsp;<code>R</code>&nbsp;是表示&nbsp;<code>[1, 10^18)</code>&nbsp;范围的整数的字符串。</li>\n\t<li><code>int(L) &lt;= int(R)</code></li>\n</ol>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 907.子数组的最小值之和",
        "hardRate": "MEDIUM",
        "passRate": "38.27%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-subarray-minimums/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-subarray-minimums/solution",
        "problemsDesc": "<p>给定一个整数数组 <code>arr</code>，找到 <code>min(b)</code> 的总和，其中 <code>b</code> 的范围为 <code>arr</code> 的每个（连续）子数组。</p>\n\n<p>由于答案可能很大，因此<strong> 返回答案模 <code>10^9 + 7</code></strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [3,1,2,4]\n<strong>输出：</strong>17\n<strong>解释：\n</strong>子数组为<strong> </strong>[3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 \n最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [11,81,94,43,3]\n<strong>输出：</strong>444\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= arr.length <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= arr[i] <= 3 * 10<sup>4</sup></code></li>\n</ul>\n\n<p> </p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 908.最小差值 I",
        "hardRate": "EASY",
        "passRate": "74.36%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-range-i/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-range-i/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>，和一个整数 <code>k</code> 。</p>\n\n<p>在一个操作中，您可以选择 <code>0 &lt;= i &lt; nums.length</code> 的任何索引 <code>i</code> 。将 <code>nums[i]</code> 改为 <code>nums[i] + x</code> ，其中 <code>x</code> 是一个范围为 <code>[-k, k]</code> 的整数。对于每个索引 <code>i</code> ，最多 <strong>只能 </strong>应用 <strong>一次</strong> 此操作。</p>\n\n<p><code>nums</code>&nbsp;的&nbsp;<strong>分数&nbsp;</strong>是&nbsp;<code>nums</code>&nbsp;中最大和最小元素的差值。&nbsp;</p>\n\n<p><em>在对&nbsp; <code>nums</code> 中的每个索引最多应用一次上述操作后，返回&nbsp;<code>nums</code> 的最低 <strong>分数</strong></em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1], k = 0\n<strong>输出：</strong>0\n<strong>解释：</strong>分数是 max(nums) - min(nums) = 1 - 1 = 0。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,10], k = 2\n<strong>输出：</strong>6\n<strong>解释：</strong>将 nums 改为 [2,8]。分数是 max(nums) - min(nums) = 8 - 2 = 6。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,6], k = 3\n<strong>输出：</strong>0\n<strong>解释：</strong>将 nums 改为 [4,4,4]。分数是 max(nums) - min(nums) = 4 - 4 = 0。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 909.蛇梯棋",
        "hardRate": "MEDIUM",
        "passRate": "45.83%",
        "problemsUrl": "https://leetcode.cn/problems/snakes-and-ladders/",
        "solutionsUrl": "https://leetcode.cn/problems/snakes-and-ladders/solution",
        "problemsDesc": "<p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>board</code> ，方格按从&nbsp;<code>1</code> 到 <code>n<sup>2</sup></code> 编号，编号遵循 <a href=\"https://baike.baidu.com/item/%E7%89%9B%E8%80%95%E5%BC%8F%E8%BD%AC%E8%A1%8C%E4%B9%A6%E5%86%99%E6%B3%95/17195786\">转行交替方式</a><strong> </strong>，<strong>从左下角开始</strong>&nbsp;（即，从 <code>board[n - 1][0]</code> 开始）每一行交替方向。</p>\n\n<p>玩家从棋盘上的方格&nbsp;<code>1</code> （总是在最后一行、第一列）开始出发。</p>\n\n<p>每一回合，玩家需要从当前方格 <code>curr</code> 开始出发，按下述要求前进：</p>\n\n<ul>\n\t<li>选定目标方格 <code>next</code> ，目标方格的编号符合范围&nbsp;<code>[curr + 1, min(curr + 6, n<sup>2</sup>)]</code> 。\n\n\t<ul>\n\t\t<li>该选择模拟了掷 <strong>六面体骰子</strong> 的情景，无论棋盘大小如何，玩家最多只能有 6 个目的地。</li>\n\t</ul>\n\t</li>\n\t<li>传送玩家：如果目标方格 <code>next</code> 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 <code>next</code> 。&nbsp;</li>\n\t<li>当玩家到达编号 <code>n<sup>2</sup></code> 的方格时，游戏结束。</li>\n</ul>\n\n<p><code>r</code> 行 <code>c</code> 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 <code>board[r][c] != -1</code>，那个蛇或梯子的目的地将会是 <code>board[r][c]</code>。编号为 <code>1</code> 和 <code>n<sup>2</sup></code> 的方格上没有蛇或梯子。</p>\n\n<p>注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也 <strong>不能</strong> 继续移动。</p>\n\n<ul>\n\t<li>举个例子，假设棋盘是 <code>[[-1,4],[-1,3]]</code> ，第一次移动，玩家的目标方格是 <code>2</code> 。那么这个玩家将会顺着梯子到达方格 <code>3</code> ，但 <strong>不能</strong> 顺着方格 <code>3</code> 上的梯子前往方格 <code>4</code> 。</li>\n</ul>\n\n<p>返回达到编号为&nbsp;<code>n<sup>2</sup></code> 的方格所需的最少移动次数，如果不可能，则返回 <code>-1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/09/23/snakes.png\" style=\"width: 500px; height: 394px;\" />\n<pre>\n<strong>输入：</strong>board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]\n<strong>输出：</strong>4\n<strong>解释：</strong>\n首先，从方格 1 [第 5 行，第 0 列] 开始。 \n先决定移动到方格 2 ，并必须爬过梯子移动到到方格 15 。\n然后决定移动到方格 17 [第 3 行，第 4 列]，必须爬过蛇到方格 13 。\n接着决定移动到方格 14 ，且必须通过梯子移动到方格 35 。 \n最后决定移动到方格 36 , 游戏结束。 \n可以证明需要至少 4 次移动才能到达最后一个方格，所以答案是 4 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = [[-1,-1],[-1,3]]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == board.length == board[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 20</code></li>\n\t<li><code>grid[i][j]</code> 的值是 <code>-1</code> 或在范围 <code>[1, n<sup>2</sup>]</code> 内</li>\n\t<li>编号为 <code>1</code> 和 <code>n<sup>2</sup></code> 的方格上没有蛇或梯子</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 910.最小差值 II",
        "hardRate": "MEDIUM",
        "passRate": "35.68%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-range-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-range-ii/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>，和一个整数&nbsp;<code>k</code> 。</p>\n\n<p>对于每个下标 <code>i</code>（<code>0 &lt;= i &lt; nums.length</code>），将 <code>nums[i]</code> 变成<strong> </strong> <code>nums[i] + k</code> 或 <code>nums[i] - k</code> 。</p>\n\n<p><code>nums</code> 的 <strong>分数</strong> 是 <code>nums</code> 中最大元素和最小元素的差值。</p>\n\n<p>在更改每个下标对应的值之后，返回 <code>nums</code> 的最小 <strong>分数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1], k = 0\n<strong>输出：</strong>0\n<strong>解释：</strong>分数 = max(nums) - min(nums) = 1 - 1 = 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,10], k = 2\n<strong>输出：</strong>6\n<strong>解释：</strong>将数组变为 [2, 8] 。分数 = max(nums) - min(nums) = 8 - 2 = 6 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,6], k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>将数组变为 [4, 6, 3] 。分数 = max(nums) - min(nums) = 6 - 3 = 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 911.在线选举",
        "hardRate": "MEDIUM",
        "passRate": "53.81%",
        "problemsUrl": "https://leetcode.cn/problems/online-election/",
        "solutionsUrl": "https://leetcode.cn/problems/online-election/solution",
        "problemsDesc": "<p>给你两个整数数组 <code>persons</code> 和 <code>times</code> 。在选举中，第&nbsp;<code>i</code>&nbsp;张票是在时刻为&nbsp;<code>times[i]</code>&nbsp;时投给候选人 <code>persons[i]</code>&nbsp;的。</p>\n\n<p>对于发生在时刻 <code>t</code> 的每个查询，需要找出在&nbsp;<code>t</code> 时刻在选举中领先的候选人的编号。</p>\n\n<p>在&nbsp;<code>t</code> 时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。</p>\n\n<p>实现 <code>TopVotedCandidate</code> 类：</p>\n\n<ul>\n\t<li><code>TopVotedCandidate(int[] persons, int[] times)</code> 使用&nbsp;<code>persons</code> 和 <code>times</code> 数组初始化对象。</li>\n\t<li><code>int q(int t)</code> 根据前面描述的规则，返回在时刻 <code>t</code> 在选举中领先的候选人的编号。</li>\n</ul>\n&nbsp;\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"TopVotedCandidate\", \"q\", \"q\", \"q\", \"q\", \"q\", \"q\"]\n[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]\n<strong>输出：</strong>\n[null, 0, 1, 1, 0, 0, 1]\n\n<strong>解释：</strong>\nTopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);\ntopVotedCandidate.q(3); // 返回 0 ，在时刻 3 ，票数分布为 [0] ，编号为 0 的候选人领先。\ntopVotedCandidate.q(12); // 返回 1 ，在时刻 12 ，票数分布为 [0,1,1] ，编号为 1 的候选人领先。\ntopVotedCandidate.q(25); // 返回 1 ，在时刻 25 ，票数分布为 [0,1,1,0,0,1] ，编号为 1 的候选人领先。（在平局的情况下，1 是最近获得投票的候选人）。\ntopVotedCandidate.q(15); // 返回 0\ntopVotedCandidate.q(24); // 返回 0\ntopVotedCandidate.q(8); // 返回 1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= persons.length &lt;= 5000</code></li>\n\t<li><code>times.length == persons.length</code></li>\n\t<li><code>0 &lt;= persons[i] &lt; persons.length</code></li>\n\t<li><code>0 &lt;= times[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>times</code> 是一个严格递增的有序数组</li>\n\t<li><code>times[0] &lt;= t &lt;= 10<sup>9</sup></code></li>\n\t<li>每个测试用例最多调用 <code>10<sup>4</sup></code> 次 <code>q</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 912.排序数组",
        "hardRate": "MEDIUM",
        "passRate": "51.70%",
        "problemsUrl": "https://leetcode.cn/problems/sort-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>，请你将该数组升序排列。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,2,3,1]\n<strong>输出：</strong>[1,2,3,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,1,1,2,0,0]\n<strong>输出：</strong>[0,0,1,1,2,5]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-5 * 10<sup>4</sup> &lt;= nums[i] &lt;= 5 * 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 913.猫和老鼠",
        "hardRate": "HARD",
        "passRate": "53.89%",
        "problemsUrl": "https://leetcode.cn/problems/cat-and-mouse/",
        "solutionsUrl": "https://leetcode.cn/problems/cat-and-mouse/solution",
        "problemsDesc": "<p>两位玩家分别扮演猫和老鼠，在一张 <strong>无向</strong> 图上进行游戏，两人轮流行动。</p>\n\n<p>图的形式是：<code>graph[a]</code> 是一个列表，由满足&nbsp;<code>ab</code> 是图中的一条边的所有节点 <code>b</code> 组成。</p>\n\n<p>老鼠从节点 <code>1</code> 开始，第一个出发；猫从节点 <code>2</code> 开始，第二个出发。在节点 <code>0</code> 处有一个洞。</p>\n\n<p>在每个玩家的行动中，他们 <strong>必须</strong> 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 <code>1</code> ，那么它必须移动到 <code>graph[1]</code> 中的任一节点。</p>\n\n<p>此外，猫无法移动到洞中（节点 <code>0</code>）。</p>\n\n<p>然后，游戏在出现以下三种情形之一时结束：</p>\n\n<ul>\n\t<li>如果猫和老鼠出现在同一个节点，猫获胜。</li>\n\t<li>如果老鼠到达洞中，老鼠获胜。</li>\n\t<li>如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。</li>\n</ul>\n\n<p>给你一张图 <code>graph</code> ，并假设两位玩家都都以最佳状态参与游戏：</p>\n\n<ul>\n\t<li>如果老鼠获胜，则返回&nbsp;<code>1</code>；</li>\n\t<li>如果猫获胜，则返回 <code>2</code>；</li>\n\t<li>如果平局，则返回 <code>0</code> 。</li>\n</ul>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/17/cat1.jpg\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>输入：</strong>graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/17/cat2.jpg\" style=\"width: 200px; height: 200px;\" />\n<pre>\n<strong>输入：</strong>graph = [[1,3],[0],[3],[0,2]]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= graph.length &lt;= 50</code></li>\n\t<li><code>1&nbsp;&lt;= graph[i].length &lt; graph.length</code></li>\n\t<li><code>0 &lt;= graph[i][j] &lt; graph.length</code></li>\n\t<li><code>graph[i][j] != i</code></li>\n\t<li><code>graph[i]</code> 互不相同</li>\n\t<li>猫和老鼠在游戏中总是可以移动</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 914.卡牌分组",
        "hardRate": "EASY",
        "passRate": "37.47%",
        "problemsUrl": "https://leetcode.cn/problems/x-of-a-kind-in-a-deck-of-cards/",
        "solutionsUrl": "https://leetcode.cn/problems/x-of-a-kind-in-a-deck-of-cards/solution",
        "problemsDesc": "<p>给定一副牌，每张牌上都写着一个整数。</p>\n\n<p>此时，你需要选定一个数字 <code>X</code>，使我们可以将整副牌按下述规则分成 1 组或更多组：</p>\n\n<ul>\n\t<li>每组都有&nbsp;<code>X</code>&nbsp;张牌。</li>\n\t<li>组内所有的牌上都写着相同的整数。</li>\n</ul>\n\n<p>仅当你可选的 <code>X &gt;= 2</code> 时返回&nbsp;<code>true</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>deck = [1,2,3,4,4,3,2,1]\n<strong>输出：</strong>true\n<strong>解释：</strong>可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>deck = [1,1,1,2,2,2,3,3]\n<strong>输出：</strong>false\n<strong>解释：</strong>没有满足要求的分组。\n</pre>\n\n<p><br />\n<strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= deck.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= deck[i] &lt; 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 915.分割数组",
        "hardRate": "MEDIUM",
        "passRate": "50.10%",
        "problemsUrl": "https://leetcode.cn/problems/partition-array-into-disjoint-intervals/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-array-into-disjoint-intervals/solution",
        "problemsDesc": "<p>给定一个数组&nbsp;<code>nums</code>&nbsp;，将其划分为两个连续子数组&nbsp;<code>left</code>&nbsp;和&nbsp;<code>right</code>，&nbsp;使得：</p>\n\n<ul>\n\t<li><code>left</code>&nbsp;中的每个元素都小于或等于&nbsp;<code>right</code>&nbsp;中的每个元素。</li>\n\t<li><code>left</code> 和&nbsp;<code>right</code>&nbsp;都是非空的。</li>\n\t<li><code>left</code> 的长度要尽可能小。</li>\n</ul>\n\n<p><em>在完成这样的分组后返回&nbsp;<code>left</code>&nbsp;的&nbsp;<strong>长度&nbsp;</strong></em>。</p>\n\n<p>用例可以保证存在这样的划分方法。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,0,3,8,6]\n<strong>输出：</strong>3\n<strong>解释：</strong>left = [5,0,3]，right = [8,6]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,0,6,12]\n<strong>输出：</strong>4\n<strong>解释：</strong>left = [1,1,1,0]，right = [6,12]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n\t<li>可以保证至少有一种方法能够按题目所描述的那样对 <code>nums</code> 进行划分。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 916.单词子集",
        "hardRate": "MEDIUM",
        "passRate": "46.21%",
        "problemsUrl": "https://leetcode.cn/problems/word-subsets/",
        "solutionsUrl": "https://leetcode.cn/problems/word-subsets/solution",
        "problemsDesc": "<p>给你两个字符串数组 <code>words1</code>&nbsp;和&nbsp;<code>words2</code>。</p>\n\n<p>现在，如果&nbsp;<code>b</code> 中的每个字母都出现在 <code>a</code> 中，<strong>包括重复出现的字母</strong>，那么称字符串 <code>b</code> 是字符串 <code>a</code> 的 <strong>子集</strong> 。</p>\n\n<ul>\n\t<li>例如，<code>\"wrr\"</code> 是 <code>\"warrior\"</code> 的子集，但不是 <code>\"world\"</code> 的子集。</li>\n</ul>\n\n<p>如果对 <code>words2</code> 中的每一个单词&nbsp;<code>b</code>，<code>b</code> 都是 <code>a</code> 的子集，那么我们称&nbsp;<code>words1</code> 中的单词 <code>a</code> 是<em> </em><strong>通用单词</strong><em> </em>。</p>\n\n<p>以数组形式返回&nbsp;<code>words1</code> 中所有的通用单词。你可以按 <strong>任意顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"e\",\"o\"]\n<strong>输出：</strong>[\"facebook\",\"google\",\"leetcode\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"l\",\"e\"]\n<strong>输出：</strong>[\"apple\",\"google\",\"leetcode\"]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"e\",\"oo\"]\n<strong>输出：</strong>[\"facebook\",\"google\"]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"lo\",\"eo\"]\n<strong>输出：</strong>[\"google\",\"leetcode\"]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"ec\",\"oc\",\"ceo\"]\n<strong>输出：</strong>[\"facebook\",\"leetcode\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words1.length, words2.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words1[i].length, words2[i].length &lt;= 10</code></li>\n\t<li><code>words1[i]</code> 和 <code>words2[i]</code> 仅由小写英文字母组成</li>\n\t<li><code>words1</code> 中的所有字符串 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 917.仅仅反转字母",
        "hardRate": "EASY",
        "passRate": "59.37%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-only-letters/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-only-letters/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，根据下述规则反转字符串：</p>\n\n<ul>\n\t<li>所有非英文字母保留在原有位置。</li>\n\t<li>所有英文字母（小写或大写）位置反转。</li>\n</ul>\n\n<p>返回反转后的 <code>s</code><em> 。</em></p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ab-cd\"\n<strong>输出：</strong>\"dc-ba\"\n</pre>\n\n<ol>\n</ol>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a-bC-dEf-ghIj\"\n<strong>输出：</strong>\"j-Ih-gfE-dCba\"\n</pre>\n\n<ol>\n</ol>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"Test1ng-Leet=code-Q!\"\n<strong>输出：</strong>\"Qedo1ct-eeLg=ntse-T!\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 仅由 ASCII 值在范围 <code>[33, 122]</code> 的字符组成</li>\n\t<li><code>s</code> 不含 <code>'\\\"'</code> 或 <code>'\\\\'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 918.环形子数组的最大和",
        "hardRate": "MEDIUM",
        "passRate": "37.82%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-circular-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-circular-subarray/solution",
        "problemsDesc": "<p>给定一个长度为 <code>n</code> 的<strong>环形整数数组</strong>&nbsp;<code>nums</code>&nbsp;，返回<em>&nbsp;<code>nums</code>&nbsp;的非空 <strong>子数组</strong> 的最大可能和&nbsp;</em>。</p>\n\n<p><strong>环形数组</strong><em>&nbsp;</em>意味着数组的末端将会与开头相连呈环状。形式上， <code>nums[i]</code> 的下一个元素是 <code>nums[(i + 1) % n]</code> ， <code>nums[i]</code>&nbsp;的前一个元素是 <code>nums[(i - 1 + n) % n]</code> 。</p>\n\n<p><strong>子数组</strong> 最多只能包含固定缓冲区&nbsp;<code>nums</code>&nbsp;中的每个元素一次。形式上，对于子数组&nbsp;<code>nums[i], nums[i + 1], ..., nums[j]</code>&nbsp;，不存在&nbsp;<code>i &lt;= k1, k2 &lt;= j</code>&nbsp;其中&nbsp;<code>k1 % n == k2 % n</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,-2,3,-2]\n<strong>输出：</strong>3\n<strong>解释：</strong>从子数组 [3] 得到最大和 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,-3,5]\n<strong>输出：</strong>10\n<strong>解释：</strong>从子数组 [5,5] 得到最大和 5 + 5 = 10\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,-2,2,-3]\n<strong>输出：</strong>3\n<strong>解释：</strong>从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-3 * 10<sup>4</sup>&nbsp;&lt;= nums[i] &lt;= 3 * 10<sup>4</sup></code>​​​​​​​</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 919.完全二叉树插入器",
        "hardRate": "MEDIUM",
        "passRate": "66.91%",
        "problemsUrl": "https://leetcode.cn/problems/complete-binary-tree-inserter/",
        "solutionsUrl": "https://leetcode.cn/problems/complete-binary-tree-inserter/solution",
        "problemsDesc": "<p><strong>完全二叉树</strong> 是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。</p>\n\n<p>设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。</p>\n\n<p>实现 <code>CBTInserter</code> 类:</p>\n\n<ul>\n\t<li><code>CBTInserter(TreeNode root)</code>&nbsp;使用头节点为&nbsp;<code>root</code>&nbsp;的给定树初始化该数据结构；</li>\n\t<li><code>CBTInserter.insert(int v)</code>&nbsp; 向树中插入一个值为&nbsp;<code>Node.val == val</code>的新节点&nbsp;<code>TreeNode</code>。使树保持完全二叉树的状态，<strong>并返回插入节点</strong>&nbsp;<code>TreeNode</code>&nbsp;<strong>的父节点的值</strong>；</li>\n\t<li><code>CBTInserter.get_root()</code> 将返回树的头节点。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/03/lc-treeinsert.jpg\" style=\"height: 143px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入</strong>\n[\"CBTInserter\", \"insert\", \"insert\", \"get_root\"]\n[[[1, 2]], [3], [4], []]\n<strong>输出</strong>\n[null, 1, 2, [1, 2, 3, 4]]\n\n<strong>解释</strong>\nCBTInserter cBTInserter = new CBTInserter([1, 2]);\ncBTInserter.insert(3);  // 返回 1\ncBTInserter.insert(4);  // 返回 2\ncBTInserter.get_root(); // 返回 [1, 2, 3, 4]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数量范围为&nbsp;<code>[1, 1000]</code>&nbsp;</li>\n\t<li><code>0 &lt;= Node.val &lt;= 5000</code></li>\n\t<li><code>root</code>&nbsp;是完全二叉树</li>\n\t<li><code>0 &lt;= val &lt;= 5000</code>&nbsp;</li>\n\t<li>每个测试用例最多调用&nbsp;<code>insert</code>&nbsp;和&nbsp;<code>get_root</code>&nbsp;操作&nbsp;<code>10<sup>4</sup></code>&nbsp;次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 920.播放列表的数量",
        "hardRate": "HARD",
        "passRate": "52.15%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-music-playlists/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-music-playlists/solution",
        "problemsDesc": "<p>你的音乐播放器里有 <code>n</code> 首不同的歌，在旅途中，你计划听 <code>goal</code> 首歌（不一定不同，即，允许歌曲重复）。你将会按如下规则创建播放列表：</p>\n\n<ul>\n\t<li>每首歌 <strong>至少播放一次</strong> 。</li>\n\t<li>一首歌只有在其他 <code>k</code> 首歌播放完之后才能再次播放。</li>\n</ul>\n\n<p>给你 <code>n</code>、<code>goal</code> 和 <code>k</code> ，返回可以满足要求的播放列表的数量。由于答案可能非常大，请返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, goal = 3, k = 1\n<strong>输出：</strong>6\n<strong>解释：</strong>有 6 种可能的播放列表。[1, 2, 3]，[1, 3, 2]，[2, 1, 3]，[2, 3, 1]，[3, 1, 2]，[3, 2, 1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, goal = 3, k = 0\n<strong>输出：</strong>6\n<strong>解释：</strong>有 6 种可能的播放列表。[1, 1, 2]，[1, 2, 1]，[2, 1, 1]，[2, 2, 1]，[2, 1, 2]，[1, 2, 2] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, goal = 3, k = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>有 2 种可能的播放列表。[1, 2, 1]，[2, 1, 2] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= k &lt; n &lt;= goal &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 921.使括号有效的最少添加",
        "hardRate": "MEDIUM",
        "passRate": "73.02%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/solution",
        "problemsDesc": "<p>只有满足下面几点之一，括号字符串才是有效的：</p>\n\n<ul>\n\t<li>它是一个空字符串，或者</li>\n\t<li>它可以被写成&nbsp;<code>AB</code>&nbsp;（<code>A</code>&nbsp;与&nbsp;<code>B</code>&nbsp;连接）, 其中&nbsp;<code>A</code> 和&nbsp;<code>B</code>&nbsp;都是有效字符串，或者</li>\n\t<li>它可以被写作&nbsp;<code>(A)</code>，其中&nbsp;<code>A</code>&nbsp;是有效字符串。</li>\n</ul>\n\n<p>给定一个括号字符串 <code>s</code> ，在每一次操作中，你都可以在字符串的任何位置插入一个括号</p>\n\n<ul>\n\t<li>例如，如果 <code>s = \"()))\"</code> ，你可以插入一个开始括号为 <code>\"(()))\"</code> 或结束括号为 <code>\"())))\"</code> 。</li>\n</ul>\n\n<p>返回 <em>为使结果字符串 <code>s</code> 有效而必须添加的最少括号数</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"())\"\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(((\"\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> 只包含&nbsp;<code>'('</code> 和&nbsp;<code>')'</code>&nbsp;字符。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 922.按奇偶排序数组 II",
        "hardRate": "EASY",
        "passRate": "71.34%",
        "problemsUrl": "https://leetcode.cn/problems/sort-array-by-parity-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-array-by-parity-ii/solution",
        "problemsDesc": "<p>给定一个非负整数数组&nbsp;<code>nums</code>，&nbsp;&nbsp;<code>nums</code> 中一半整数是 <strong>奇数</strong> ，一半整数是 <strong>偶数</strong> 。</p>\n\n<p>对数组进行排序，以便当&nbsp;<code>nums[i]</code> 为奇数时，<code>i</code>&nbsp;也是 <strong>奇数</strong> ；当&nbsp;<code>nums[i]</code>&nbsp;为偶数时， <code>i</code> 也是 <strong>偶数</strong> 。</p>\n\n<p>你可以返回 <em>任何满足上述条件的数组作为答案</em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,2,5,7]\n<strong>输出：</strong>[4,5,2,7]\n<strong>解释：</strong>[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,3]\n<b>输出：</b>[2,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>nums.length</code>&nbsp;是偶数</li>\n\t<li><code>nums</code>&nbsp;中一半是偶数</li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>可以不使用额外空间解决问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 923.三数之和的多种可能",
        "hardRate": "MEDIUM",
        "passRate": "36.96%",
        "problemsUrl": "https://leetcode.cn/problems/3sum-with-multiplicity/",
        "solutionsUrl": "https://leetcode.cn/problems/3sum-with-multiplicity/solution",
        "problemsDesc": "<p>给定一个整数数组<meta charset=\"UTF-8\" />&nbsp;<code>arr</code>&nbsp;，以及一个整数&nbsp;<code>target</code>&nbsp;作为目标值，返回满足 <code>i &lt; j &lt; k</code> 且<meta charset=\"UTF-8\" />&nbsp;<code>arr[i] + arr[j] + arr[k] == target</code>&nbsp;的元组&nbsp;<code>i, j, k</code>&nbsp;的数量。</p>\n\n<p>由于结果会非常大，请返回 <code>10<sup>9</sup>&nbsp;+ 7</code>&nbsp;的模。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,1,2,2,3,3,4,4,5,5], target = 8\n<strong>输出：</strong>20\n<strong>解释：</strong>\n按值枚举(arr[i], arr[j], arr[k])：\n(1, 2, 5) 出现 8 次；\n(1, 3, 4) 出现 8 次；\n(2, 2, 4) 出现 2 次；\n(2, 3, 3) 出现 2 次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,1,2,2,2,2], target = 5\n<strong>输出：</strong>12\n<strong>解释：</strong>\narr[i] = 1, arr[j] = arr[k] = 2 出现 12 次：\n我们从 [1,1] 中选择一个 1，有 2 种情况，\n从 [2,2,2,2] 中选出两个 2，有 6 种情况。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= arr.length &lt;= 3000</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 100</code></li>\n\t<li><code>0 &lt;= target &lt;= 300</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 924.尽量减少恶意软件的传播",
        "hardRate": "HARD",
        "passRate": "35.84%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-malware-spread/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-malware-spread/solution",
        "problemsDesc": "<p>给出了一个由 <code>n</code> 个节点组成的网络，用 <code>n × n</code> 个邻接矩阵图<meta charset=\"UTF-8\" />&nbsp;<code>graph</code>&nbsp;表示。在节点网络中，当 <code>graph[i][j] = 1</code>&nbsp;时，表示节点&nbsp;<code>i</code>&nbsp;能够直接连接到另一个节点 <code>j</code>。&nbsp;</p>\n\n<p>一些节点&nbsp;<code>initial</code>&nbsp;最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。</p>\n\n<p>假设 <code>M(initial)</code> 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。</p>\n\n<p>如果从&nbsp;<code>initial</code>&nbsp;中<strong>移除某一节点</strong>能够最小化 <code>M(initial)</code>， 返回该节点。如果有多个节点满足条件，就返回<strong>索引最小</strong>的节点。</p>\n\n<p>请注意，如果某个节点已从受感染节点的列表 <code>initial</code> 中删除，它以后仍有可能因恶意软件传播而受到感染。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>n == graph.length</code></li>\n\t<li><code>n == graph[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 300</code></li>\n\t<li><code>graph[i][j]&nbsp;==&nbsp;0</code>&nbsp;或&nbsp;<code>1</code>.</li>\n\t<li><code>graph[i][j] == graph[j][i]</code></li>\n\t<li><code>graph[i][i] == 1</code></li>\n\t<li><code>1 &lt;= initial.length &lt;= n</code></li>\n\t<li><code>0 &lt;= initial[i] &lt;= n - 1</code></li>\n\t<li><code>initial</code>&nbsp;中所有整数均<strong>不重复</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 925.长按键入",
        "hardRate": "EASY",
        "passRate": "37.44%",
        "problemsUrl": "https://leetcode.cn/problems/long-pressed-name/",
        "solutionsUrl": "https://leetcode.cn/problems/long-pressed-name/solution",
        "problemsDesc": "<p>你的朋友正在使用键盘输入他的名字&nbsp;<code>name</code>。偶尔，在键入字符&nbsp;<code>c</code>&nbsp;时，按键可能会被<em>长按</em>，而字符可能被输入 1 次或多次。</p>\n\n<p>你将会检查键盘输入的字符&nbsp;<code>typed</code>。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回&nbsp;<code>True</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>name = \"alex\", typed = \"aaleex\"\n<strong>输出：</strong>true\n<strong>解释：</strong>'alex' 中的 'a' 和 'e' 被长按。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>name = \"saeed\", typed = \"ssaaedd\"\n<strong>输出：</strong>false\n<strong>解释：</strong>'e' 一定需要被键入两次，但在 typed 的输出中不是这样。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= name.length, typed.length &lt;= 1000</code></li>\n\t<li><code>name</code> 和&nbsp;<code>typed</code>&nbsp;的字符都是小写字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 926.将字符串翻转到单调递增",
        "hardRate": "MEDIUM",
        "passRate": "63.48%",
        "problemsUrl": "https://leetcode.cn/problems/flip-string-to-monotone-increasing/",
        "solutionsUrl": "https://leetcode.cn/problems/flip-string-to-monotone-increasing/solution",
        "problemsDesc": "<p>如果一个二进制字符串，是以一些 <code>0</code>（可能没有 <code>0</code>）后面跟着一些 <code>1</code>（也可能没有 <code>1</code>）的形式组成的，那么该字符串是 <strong>单调递增 </strong>的。</p>\n\n<p>给你一个二进制字符串 <code>s</code>，你可以将任何 <code>0</code> 翻转为 <code>1</code> 或者将 <code>1</code> 翻转为 <code>0</code> 。</p>\n\n<p>返回使 <code>s</code> 单调递增的最小翻转次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"00110\"\n<strong>输出：</strong>1\n<strong>解释：</strong>翻转最后一位得到 00111.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"010110\"\n<strong>输出：</strong>2\n<strong>解释：</strong>翻转得到 011111，或者是 000111。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"00011000\"\n<strong>输出：</strong>2\n<strong>解释：</strong>翻转得到 00000000。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 927.三等分",
        "hardRate": "HARD",
        "passRate": "43.83%",
        "problemsUrl": "https://leetcode.cn/problems/three-equal-parts/",
        "solutionsUrl": "https://leetcode.cn/problems/three-equal-parts/solution",
        "problemsDesc": "<p>给定一个由 <code>0</code> 和 <code>1</code> 组成的数组<meta charset=\"UTF-8\" />&nbsp;<code>arr</code>&nbsp;，将数组分成 &nbsp;<strong>3&nbsp;个非空的部分</strong> ，使得所有这些部分表示相同的二进制值。</p>\n\n<p>如果可以做到，请返回<strong>任何</strong>&nbsp;<code>[i, j]</code>，其中 <code>i+1 &lt; j</code>，这样一来：</p>\n\n<ul>\n\t<li><code>arr[0], arr[1], ..., arr[i]</code>&nbsp;为第一部分；</li>\n\t<li><code>arr[i + 1], arr[i + 2], ..., arr[j - 1]</code>&nbsp;为第二部分；</li>\n\t<li><code>arr[j], arr[j + 1], ..., arr[arr.length - 1]</code>&nbsp;为第三部分。</li>\n\t<li>这三个部分所表示的二进制值相等。</li>\n</ul>\n\n<p>如果无法做到，就返回&nbsp;<code>[-1, -1]</code>。</p>\n\n<p>注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如，<code>[1,1,0]</code>&nbsp;表示十进制中的&nbsp;<code>6</code>，而不会是&nbsp;<code>3</code>。此外，前导零也是<strong>被允许</strong>的，所以&nbsp;<code>[0,1,1]</code> 和&nbsp;<code>[1,1]</code>&nbsp;表示相同的值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,0,1,0,1]\n<strong>输出：</strong>[0,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,1,0,1,1]\n<strong>输出：</strong>[-1,-1]</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,1,0,0,1]\n<strong>输出：</strong>[0,2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>3 &lt;= arr.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>arr[i]</code>&nbsp;是&nbsp;<code>0</code>&nbsp;或&nbsp;<code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 928.尽量减少恶意软件的传播 II",
        "hardRate": "HARD",
        "passRate": "43.74%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-malware-spread-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-malware-spread-ii/solution",
        "problemsDesc": "<p>给定一个由 <code>n</code> 个节点组成的网络，用 <code>n x n</code> 个邻接矩阵&nbsp;<code>graph</code>&nbsp;表示。在节点网络中，只有当&nbsp;<code>graph[i][j] = 1</code>&nbsp;时，节点&nbsp;<code>i</code>&nbsp;能够直接连接到另一个节点&nbsp;<code>j</code>。</p>\n\n<p>一些节点&nbsp;<code>initial</code>&nbsp;最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。</p>\n\n<p>假设&nbsp;<code>M(initial)</code>&nbsp;是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。</p>\n\n<p>我们可以从 <code>initial</code> 中<strong>删除一个节点</strong>，<strong>并完全移除该节点以及从该节点到任何其他节点的任何连接。</strong></p>\n\n<p>请返回移除后能够使&nbsp;<code>M(initial)</code>&nbsp;最小化的节点。如果有多个节点满足条件，返回索引 <strong>最小的节点</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输出：</strong>graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\n<strong>输入：</strong>0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>n == graph.length</code></li>\n\t<li><code>n == graph[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 300</code></li>\n\t<li><code>graph[i][j]</code>&nbsp;是&nbsp;<code>0</code>&nbsp;或&nbsp;<code>1</code>.</li>\n\t<li><code>graph[i][j] == graph[j][i]</code></li>\n\t<li><code>graph[i][i] == 1</code></li>\n\t<li><code>1 &lt;= initial.length &lt;&nbsp;n</code></li>\n\t<li><code>0 &lt;= initial[i] &lt;= n - 1</code></li>\n\t<li>&nbsp;<code>initial</code>&nbsp;中每个整数都<strong>不同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 929.独特的电子邮件地址",
        "hardRate": "EASY",
        "passRate": "68.59%",
        "problemsUrl": "https://leetcode.cn/problems/unique-email-addresses/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-email-addresses/solution",
        "problemsDesc": "<p>每个 <strong>有效电子邮件地址</strong> 都由一个 <strong>本地名</strong> 和一个 <strong>域名</strong> 组成，以 <code>'@'</code> 符号分隔。除小写字母之外，电子邮件地址还可以含有一个或多个&nbsp;<code>'.'</code> 或 <code>'+'</code> 。</p>\n\n<ul>\n\t<li>例如，在&nbsp;<code>alice@leetcode.com</code>中，&nbsp;<code>alice</code>&nbsp;是 <strong>本地名</strong> ，而&nbsp;<code>leetcode.com</code>&nbsp;是 <strong>域名</strong> 。</li>\n</ul>\n\n<p>如果在电子邮件地址的<strong> 本地名 </strong>部分中的某些字符之间添加句点（<code>'.'</code>），则发往那里的邮件将会转发到本地名中没有点的同一地址。请注意，此规则 <strong>不适用于域名</strong> 。</p>\n\n<ul>\n\t<li>例如，<code>\"alice.z@leetcode.com”</code> 和 <code>“alicez@leetcode.com”</code>&nbsp;会转发到同一电子邮件地址。</li>\n</ul>\n\n<p>如果在<strong> 本地名 </strong>中添加加号（<code>'+'</code>），则会忽略第一个加号后面的所有内容。这允许过滤某些电子邮件。同样，此规则 <strong>不适用于域名</strong> 。</p>\n\n<ul>\n\t<li>例如 <code>m.y+name@email.com</code> 将转发到 <code>my@email.com</code>。</li>\n</ul>\n\n<p>可以同时使用这两个规则。</p>\n\n<p>给你一个字符串数组 <code>emails</code>，我们会向每个 <code>emails[i]</code> 发送一封电子邮件。返回实际收到邮件的不同地址数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>emails = [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\n<strong>输出：</strong>2\n<strong>解释：</strong>实际收到邮件的是 \"testemail@leetcode.com\" 和 \"testemail@lee.tcode.com\"。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>emails = [\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"]\n<strong>输出：</strong>3\n</pre>\n\n<p><br />\n<strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= emails.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= emails[i].length&nbsp;&lt;= 100</code></li>\n\t<li><code>emails[i]</code> 由小写英文字母、<code>'+'</code>、<code>'.'</code> 和 <code>'@'</code> 组成</li>\n\t<li>每个 <code>emails[i]</code> 都包含有且仅有一个 <code>'@'</code> 字符</li>\n\t<li>所有本地名和域名都不为空</li>\n\t<li>本地名不会以 <code>'+'</code> 字符作为开头</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 930.和相同的二元子数组",
        "hardRate": "MEDIUM",
        "passRate": "55.08%",
        "problemsUrl": "https://leetcode.cn/problems/binary-subarrays-with-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-subarrays-with-sum/solution",
        "problemsDesc": "<p>给你一个二元数组 <code>nums</code> ，和一个整数 <code>goal</code> ，请你统计并返回有多少个和为 <code>goal</code> 的<strong> 非空</strong> 子数组。</p>\n\n<p><strong>子数组</strong> 是数组的一段连续部分。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,0,1,0,1], goal = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>\n有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,0,0,0,0], goal = 0\n<strong>输出：</strong>15\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code></li>\n\t<li><code>0 <= goal <= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 931.下降路径最小和",
        "hardRate": "MEDIUM",
        "passRate": "67.10%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-falling-path-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-falling-path-sum/solution",
        "problemsDesc": "<p>给你一个 <code>n x n</code> 的<strong> 方形 </strong>整数数组&nbsp;<code>matrix</code> ，请你找出并返回通过 <code>matrix</code> 的<strong>下降路径</strong><em> </em>的<strong> </strong><strong>最小和</strong> 。</p>\n\n<p><strong>下降路径</strong> 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 <code>(row, col)</code> 的下一个元素应当是 <code>(row + 1, col - 1)</code>、<code>(row + 1, col)</code> 或者 <code>(row + 1, col + 1)</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/03/failing1-grid.jpg\" style=\"height: 500px; width: 499px;\" /></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[2,1,3],[6,5,4],[7,8,9]]\n<strong>输出：</strong>13\n<strong>解释：</strong>如图所示，为和最小的两条下降路径\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/03/failing2-grid.jpg\" style=\"height: 365px; width: 164px;\" /></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[-19,57],[-40,-5]]\n<strong>输出：</strong>-59\n<strong>解释：</strong>如图所示，为和最小的下降路径\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == matrix.length == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 932.漂亮数组",
        "hardRate": "MEDIUM",
        "passRate": "65.68%",
        "problemsUrl": "https://leetcode.cn/problems/beautiful-array/",
        "solutionsUrl": "https://leetcode.cn/problems/beautiful-array/solution",
        "problemsDesc": "<p>如果长度为 <code>n</code> 的数组 <code>nums</code> 满足下述条件，则认为该数组是一个 <strong>漂亮数组</strong> ：</p>\n\n<ul>\n\t<li><code>nums</code> 是由范围 <code>[1, n]</code> 的整数组成的一个排列。</li>\n\t<li>对于每个 <code>0 &lt;= i &lt; j &lt; n</code> ，均不存在下标 <code>k</code>（<code>i &lt; k &lt; j</code>）使得 <code>2 * nums[k] == nums[i] + nums[j]</code> 。</li>\n</ul>\n\n<p>给你整数 <code>n</code> ，返回长度为 <code>n</code> 的任一 <strong>漂亮数组</strong> 。本题保证对于给定的 <code>n</code> 至少存在一个有效答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>[2,1,4,3]\n</pre>\n\n<p><strong class=\"example\">示例 2 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>[3,1,2,5,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 933.最近的请求次数",
        "hardRate": "EASY",
        "passRate": "76.78%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-recent-calls/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-recent-calls/solution",
        "problemsDesc": "<p>写一个&nbsp;<code>RecentCounter</code>&nbsp;类来计算特定时间范围内最近的请求。</p>\n\n<p>请你实现 <code>RecentCounter</code> 类：</p>\n\n<ul>\n\t<li><code>RecentCounter()</code> 初始化计数器，请求数为 0 。</li>\n\t<li><code>int ping(int t)</code> 在时间 <code>t</code> 添加一个新请求，其中 <code>t</code> 表示以毫秒为单位的某个时间，并返回过去 <code>3000</code> 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 <code>[t-3000, t]</code> 内发生的请求数。</li>\n</ul>\n\n<p><strong>保证</strong> 每次对 <code>ping</code> 的调用都使用比之前更大的 <code>t</code> 值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"RecentCounter\", \"ping\", \"ping\", \"ping\", \"ping\"]\n[[], [1], [100], [3001], [3002]]\n<strong>输出：</strong>\n[null, 1, 2, 3, 3]\n\n<strong>解释：</strong>\nRecentCounter recentCounter = new RecentCounter();\nrecentCounter.ping(1);     // requests = [<strong>1</strong>]，范围是 [-2999,1]，返回 1\nrecentCounter.ping(100);   // requests = [<strong>1</strong>, <strong>100</strong>]，范围是 [-2900,100]，返回 2\nrecentCounter.ping(3001);  // requests = [<strong>1</strong>, <strong>100</strong>, <strong>3001</strong>]，范围是 [1,3001]，返回 3\nrecentCounter.ping(3002);  // requests = [1, <strong>100</strong>, <strong>3001</strong>, <strong>3002</strong>]，范围是 [2,3002]，返回 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= t &lt;= 10<sup>9</sup></code></li>\n\t<li>保证每次对 <code>ping</code> 调用所使用的 <code>t</code> 值都 <strong>严格递增</strong></li>\n\t<li>至多调用 <code>ping</code> 方法 <code>10<sup>4</sup></code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 934.最短的桥",
        "hardRate": "MEDIUM",
        "passRate": "52.42%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-bridge/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-bridge/solution",
        "problemsDesc": "<p>给你一个大小为 <code>n x n</code> 的二元矩阵 <code>grid</code> ，其中 <code>1</code> 表示陆地，<code>0</code> 表示水域。</p>\n\n<p><strong>岛</strong> 是由四面相连的 <code>1</code> 形成的一个最大组，即不会与非组内的任何其他 <code>1</code> 相连。<code>grid</code> 中 <strong>恰好存在两座岛</strong> 。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>你可以将任意数量的 <code>0</code> 变为 <code>1</code> ，以使两座岛连接起来，变成 <strong>一座岛</strong> 。</p>\n\n<p>返回必须翻转的 <code>0</code> 的最小数目。</p>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,1],[1,0]]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,1,0],[0,0,0],[0,0,1]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n\t<li><code>grid</code> 中恰有两个岛</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 935.骑士拨号器",
        "hardRate": "MEDIUM",
        "passRate": "51.60%",
        "problemsUrl": "https://leetcode.cn/problems/knight-dialer/",
        "solutionsUrl": "https://leetcode.cn/problems/knight-dialer/solution",
        "problemsDesc": "<p>象棋骑士有一个<strong>独特的移动方式</strong>，它可以垂直移动两个方格，水平移动一个方格，或者水平移动两个方格，垂直移动一个方格(两者都形成一个&nbsp;<strong>L&nbsp;</strong>的形状)。</p>\n\n<p>象棋骑士可能的移动方式如下图所示:</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/18/chess.jpg\" style=\"height: 200px; width: 200px;\" /></p>\n\n<p>我们有一个象棋骑士和一个电话垫，如下所示，骑士<strong>只能站在一个数字单元格上</strong>(即蓝色单元格)。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/18/phone.jpg\" style=\"height: 200px; width: 150px;\" /></p>\n\n<p>给定一个整数 n，返回我们可以拨多少个长度为 n 的不同电话号码。</p>\n\n<p>你可以将骑士放置在<strong>任何数字单元格</strong>上，然后你应该执行 n - 1 次移动来获得长度为 n 的号码。所有的跳跃应该是<strong>有效</strong>的骑士跳跃。</p>\n\n<p>因为答案可能很大，<strong>所以输出答案模&nbsp;</strong><code>10<sup>9</sup>&nbsp;+ 7</code>.</p>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>10\n<strong>解释：</strong>我们需要拨一个长度为1的数字，所以把骑士放在10个单元格中的任何一个数字单元格上都能满足条件。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>20\n<strong>解释：</strong>我们可以拨打的所有有效号码为[04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3131\n<strong>输出：</strong>136006598\n<strong>解释：</strong>注意取模\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 936.戳印序列",
        "hardRate": "HARD",
        "passRate": "42.30%",
        "problemsUrl": "https://leetcode.cn/problems/stamping-the-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/stamping-the-sequence/solution",
        "problemsDesc": "<p>你想要用<strong>小写字母</strong>组成一个目标字符串&nbsp;<code>target</code>。&nbsp;</p>\n\n<p>开始的时候，序列由&nbsp;<code>target.length</code>&nbsp;个&nbsp;<code>&#39;?&#39;</code>&nbsp;记号组成。而你有一个小写字母印章&nbsp;<code>stamp</code>。</p>\n\n<p>在每个回合，你可以将印章放在序列上，并将序列中的每个字母替换为印章上的相应字母。你最多可以进行&nbsp;<code>10 * target.length</code>&nbsp; 个回合。</p>\n\n<p>举个例子，如果初始序列为 &quot;?????&quot;，而你的印章 <code>stamp</code>&nbsp;是&nbsp;<code>&quot;abc&quot;</code>，那么在第一回合，你可以得到&nbsp;&quot;abc??&quot;、&quot;?abc?&quot;、&quot;??abc&quot;。（请注意，印章必须完全包含在序列的边界内才能盖下去。）</p>\n\n<p>如果可以印出序列，那么返回一个数组，该数组由每个回合中被印下的最左边字母的索引组成。如果不能印出序列，就返回一个空数组。</p>\n\n<p>例如，如果序列是 &quot;ababc&quot;，印章是 <code>&quot;abc&quot;</code>，那么我们就可以返回与操作&nbsp;&quot;?????&quot; -&gt; &quot;abc??&quot; -&gt; &quot;ababc&quot; 相对应的答案 <code>[0, 2]</code>；</p>\n\n<p>另外，如果可以印出序列，那么需要保证可以在 <code>10 * target.length</code>&nbsp;个回合内完成。任何超过此数字的答案将不被接受。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>stamp = &quot;abc&quot;, target = &quot;ababc&quot;\n<strong>输出：</strong>[0,2]\n（[1,0,2] 以及其他一些可能的结果也将作为答案被接受）\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>stamp = &quot;abca&quot;, target = &quot;aabcaca&quot;\n<strong>输出：</strong>[3,0,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= stamp.length &lt;= target.length &lt;= 1000</code></li>\n\t<li><code>stamp</code> 和&nbsp;<code>target</code>&nbsp;只包含小写字母。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 937.重新排列日志文件",
        "hardRate": "MEDIUM",
        "passRate": "63.46%",
        "problemsUrl": "https://leetcode.cn/problems/reorder-data-in-log-files/",
        "solutionsUrl": "https://leetcode.cn/problems/reorder-data-in-log-files/solution",
        "problemsDesc": "<p>给你一个日志数组 <code>logs</code>。每条日志都是以空格分隔的字串，其第一个字为字母与数字混合的<em> </em><strong>标识符 </strong>。</p>\n\n<p>有两种不同类型的日志：</p>\n\n<ul>\n\t<li><strong>字母日志</strong>：除标识符之外，所有字均由小写字母组成</li>\n\t<li><strong>数字日志</strong>：除标识符之外，所有字均由数字组成</li>\n</ul>\n\n<p>请按下述规则将日志重新排序：</p>\n\n<ul>\n\t<li>所有 <strong>字母日志</strong> 都排在 <strong>数字日志</strong> 之前。</li>\n\t<li><strong>字母日志</strong> 在内容不同时，忽略标识符后，按内容字母顺序排序；在内容相同时，按标识符排序。</li>\n\t<li><strong>数字日志</strong> 应该保留原来的相对顺序。</li>\n</ul>\n\n<p>返回日志的最终顺序。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>logs = [\"dig1 8 1 5 1\",\"let1 art can\",\"dig2 3 6\",\"let2 own kit dig\",\"let3 art zero\"]\n<strong>输出：</strong>[\"let1 art can\",\"let3 art zero\",\"let2 own kit dig\",\"dig1 8 1 5 1\",\"dig2 3 6\"]\n<strong>解释：</strong>\n字母日志的内容都不同，所以顺序为 \"art can\", \"art zero\", \"own kit dig\" 。\n数字日志保留原来的相对顺序 \"dig1 8 1 5 1\", \"dig2 3 6\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>logs = [\"a1 9 2 3 1\",\"g1 act car\",\"zo4 4 7\",\"ab1 off key dog\",\"a8 act zoo\"]\n<strong>输出：</strong>[\"g1 act car\",\"a8 act zoo\",\"ab1 off key dog\",\"a1 9 2 3 1\",\"zo4 4 7\"]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= logs.length <= 100</code></li>\n\t<li><code>3 <= logs[i].length <= 100</code></li>\n\t<li><code>logs[i]</code> 中，字与字之间都用 <strong>单个</strong> 空格分隔</li>\n\t<li>题目数据保证 <code>logs[i]</code> 都有一个标识符，并且在标识符之后至少存在一个字</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 938.二叉搜索树的范围和",
        "hardRate": "EASY",
        "passRate": "82.11%",
        "problemsUrl": "https://leetcode.cn/problems/range-sum-of-bst/",
        "solutionsUrl": "https://leetcode.cn/problems/range-sum-of-bst/solution",
        "problemsDesc": "<p>给定二叉搜索树的根结点 <code>root</code>，返回值位于范围 <em><code>[low, high]</code></em> 之间的所有结点的值的和。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg\" style=\"width: 400px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>root = [10,5,15,3,7,null,18], low = 7, high = 15\n<strong>输出：</strong>32\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/bst2.jpg\" style=\"width: 400px; height: 335px;\" />\n<pre>\n<strong>输入：</strong>root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10\n<strong>输出：</strong>23\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[1, 2 * 10<sup>4</sup>]</code> 内</li>\n\t<li><code>1 <= Node.val <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= low <= high <= 10<sup>5</sup></code></li>\n\t<li>所有 <code>Node.val</code> <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 939.最小面积矩形",
        "hardRate": "MEDIUM",
        "passRate": "48.40%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-area-rectangle/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-area-rectangle/solution",
        "problemsDesc": "<p>给定在 xy 平面上的一组点，确定由这些点组成的矩形的最小面积，其中矩形的边平行于 x 轴和 y 轴。</p>\n\n<p>如果没有任何矩形，就返回 0。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[[1,1],[1,3],[3,1],[3,3],[2,2]]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>[[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= points.length &lt;= 500</code></li>\n\t<li><code>0 &lt;=&nbsp;points[i][0] &lt;=&nbsp;40000</code></li>\n\t<li><code>0 &lt;=&nbsp;points[i][1] &lt;=&nbsp;40000</code></li>\n\t<li>所有的点都是不同的。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 940.不同的子序列 II",
        "hardRate": "HARD",
        "passRate": "53.43%",
        "problemsUrl": "https://leetcode.cn/problems/distinct-subsequences-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/distinct-subsequences-ii/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code>，计算 <code>s</code> 的 <strong>不同非空子序列</strong> 的个数。因为结果可能很大，所以返回答案需要对<strong> </strong><strong><code>10^9 + 7</code> 取余</strong> 。</p>\n\n<p>字符串的 <strong>子序列</strong> 是经由原字符串删除一些（也可能不删除）字符但不改变剩余字符相对位置的一个新字符串。</p>\n\n<ul>\n\t<li>例如，<code>\"ace\"</code> 是 <code>\"<em><strong>a</strong></em>b<em><strong>c</strong></em>d<em><strong>e</strong></em>\"</code> 的一个子序列，但 <code>\"aec\"</code> 不是。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\"\n<strong>输出：</strong>7\n<strong>解释：</strong>7 个不同的子序列分别是 \"a\", \"b\", \"c\", \"ab\", \"ac\", \"bc\", 以及 \"abc\"。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aba\"\n<strong>输出：</strong>6\n<strong>解释：</strong>6 个不同的子序列分别是 \"a\", \"b\", \"ab\", \"ba\", \"aa\" 以及 \"aba\"。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aaa\"\n<strong>输出：</strong>3\n<strong>解释：</strong>3 个不同的子序列分别是 \"a\", \"aa\" 以及 \"aaa\"。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 941.有效的山脉数组",
        "hardRate": "EASY",
        "passRate": "39.50%",
        "problemsUrl": "https://leetcode.cn/problems/valid-mountain-array/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-mountain-array/solution",
        "problemsDesc": "<p>给定一个整数数组 <code>arr</code>，如果它是有效的山脉数组就返回&nbsp;<code>true</code>，否则返回 <code>false</code>。</p>\n\n<p>让我们回顾一下，如果 <code>arr</code>&nbsp;满足下述条件，那么它是一个山脉数组：</p>\n\n<ul>\n\t<li><code>arr.length &gt;= 3</code></li>\n\t<li>在&nbsp;<code>0 &lt; i&nbsp;&lt; arr.length - 1</code>&nbsp;条件下，存在&nbsp;<code>i</code>&nbsp;使得：\n\t<ul>\n\t\t<li><code>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] </code></li>\n\t\t<li><code>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_valid_mountain_array.png\" style=\"height: 316px; width: 500px;\" /></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [2,1]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [3,5,5]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,3,2,1]\n<strong>输出：</strong>true</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 942.增减字符串匹配",
        "hardRate": "EASY",
        "passRate": "77.22%",
        "problemsUrl": "https://leetcode.cn/problems/di-string-match/",
        "solutionsUrl": "https://leetcode.cn/problems/di-string-match/solution",
        "problemsDesc": "<p>由范围 <code>[0,n]</code> 内所有整数组成的 <code>n + 1</code> 个整数的排列序列可以表示为长度为 <code>n</code> 的字符串 <code>s</code> ，其中:</p>\n\n<ul>\n\t<li>如果&nbsp;<code>perm[i] &lt; perm[i + 1]</code>&nbsp;，那么&nbsp;<code>s[i] == 'I'</code>&nbsp;</li>\n\t<li>如果&nbsp;<code>perm[i] &gt; perm[i + 1]</code>&nbsp;，那么 <code>s[i] == 'D'</code>&nbsp;</li>\n</ul>\n\n<p>给定一个字符串 <code>s</code> ，重构排列&nbsp;<code>perm</code> 并返回它。如果有多个有效排列perm，则返回其中 <strong>任何一个</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"IDID\"\n<strong>输出：</strong>[0,4,1,3,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"III\"\n<strong>输出：</strong>[0,1,2,3]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"DDI\"\n<strong>输出：</strong>[3,2,0,1]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code><font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">s</span></span></font></font></code> 只包含字符&nbsp;<code>\"I\"</code>&nbsp;或&nbsp;<code>\"D\"</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 943.最短超级串",
        "hardRate": "HARD",
        "passRate": "47.26%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-shortest-superstring/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-shortest-superstring/solution",
        "problemsDesc": "<p>给定一个字符串数组 <code>words</code>，找到以 <code>words</code> 中每个字符串作为子字符串的最短字符串。如果有多个有效最短字符串满足题目条件，返回其中 <strong>任意一个</strong> 即可。</p>\n\n<p>我们可以假设 <code>words</code> 中没有字符串是 <code>words</code> 中另一个字符串的子字符串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"alex\",\"loves\",\"leetcode\"]\n<strong>输出：</strong>\"alexlovesleetcode\"\n<strong>解释：</strong>\"alex\"，\"loves\"，\"leetcode\" 的所有排列都会被接受。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"catg\",\"ctaagt\",\"gcta\",\"ttca\",\"atgcatc\"]\n<strong>输出：</strong>\"gctaagttcatgcatc\"</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= words.length <= 12</code></li>\n\t<li><code>1 <= words[i].length <= 20</code></li>\n\t<li><code>words[i]</code> 由小写英文字母组成</li>\n\t<li><code>words</code> 中的所有字符串 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 944.删列造序",
        "hardRate": "EASY",
        "passRate": "69.03%",
        "problemsUrl": "https://leetcode.cn/problems/delete-columns-to-make-sorted/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-columns-to-make-sorted/solution",
        "problemsDesc": "<p>给你由 <code>n</code> 个小写字母字符串组成的数组 <code>strs</code>，其中每个字符串长度相等。</p>\n\n<p>这些字符串可以每个一行，排成一个网格。例如，<code>strs = [\"abc\", \"bce\", \"cae\"]</code> 可以排列为：</p>\n\n<pre>\nabc\nbce\ncae</pre>\n\n<p>你需要找出并删除 <strong>不是按字典序升序排列的</strong> 列。在上面的例子（下标从 0 开始）中，列 0（<code>'a'</code>, <code>'b'</code>, <code>'c'</code>）和列 2（<code>'c'</code>, <code>'e'</code>, <code>'e'</code>）都是按升序排列的，而列 1（<code>'b'</code>, <code>'c'</code>, <code>'a'</code>）不是，所以要删除列 1 。</p>\n\n<p>返回你需要删除的列数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"cba\",\"daf\",\"ghi\"]\n<strong>输出：</strong>1\n<strong>解释：</strong>网格示意如下：\n  cba\n  daf\n  ghi\n列 0 和列 2 按升序排列，但列 1 不是，所以只需要删除列 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"a\",\"b\"]\n<strong>输出：</strong>0\n<strong>解释：</strong>网格示意如下：\n  a\n  b\n只有列 0 这一列，且已经按升序排列，所以不用删除任何列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"zyx\",\"wvu\",\"tsr\"]\n<strong>输出：</strong>3\n<strong>解释：</strong>网格示意如下：\n  zyx\n  wvu\n  tsr\n所有 3 列都是非升序排列的，所以都要删除。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == strs.length</code></li>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>1 <= strs[i].length <= 1000</code></li>\n\t<li><code>strs[i]</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 945.使数组唯一的最小增量",
        "hardRate": "MEDIUM",
        "passRate": "47.92%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-increment-to-make-array-unique/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-increment-to-make-array-unique/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。每次 move 操作将会选择任意一个满足 <code>0 &lt;= i &lt; nums.length</code> 的下标 <code>i</code>，并将&nbsp;<code>nums[i]</code> 递增&nbsp;<code>1</code>。</p>\n\n<p>返回使 <code>nums</code> 中的每个值都变成唯一的所需要的最少操作次数。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>经过一次 <em>move</em> 操作，数组将变为 [1, 2, 3]。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,1,2,1,7]\n<strong>输出：</strong>6\n<strong>解释：</strong>经过 6 次 <em>move</em> 操作，数组将变为 [3, 4, 1, 2, 5, 7]。\n可以看出 5 次或 5 次以下的 <em>move</em> 操作是不能让数组的每个值唯一的。</pre>\n</div>\n</div>\n\n<p>&nbsp;</p>\n<strong>提示：</strong>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 946.验证栈序列",
        "hardRate": "MEDIUM",
        "passRate": "66.62%",
        "problemsUrl": "https://leetcode.cn/problems/validate-stack-sequences/",
        "solutionsUrl": "https://leetcode.cn/problems/validate-stack-sequences/solution",
        "problemsDesc": "<p>给定&nbsp;<code>pushed</code>&nbsp;和&nbsp;<code>popped</code>&nbsp;两个序列，每个序列中的 <strong>值都不重复</strong>，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 <code>true</code>；否则，返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\n<strong>输出：</strong>true\n<strong>解释：</strong>我们可以按以下顺序执行：\npush(1), push(2), push(3), push(4), pop() -&gt; 4,\npush(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\n<strong>输出：</strong>false\n<strong>解释：</strong>1 不能在 2 之前弹出。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pushed.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= pushed[i] &lt;= 1000</code></li>\n\t<li><code>pushed</code> 的所有元素 <strong>互不相同</strong></li>\n\t<li><code>popped.length == pushed.length</code></li>\n\t<li><code>popped</code> 是 <code>pushed</code> 的一个排列</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 947.移除最多的同行或同列石头",
        "hardRate": "MEDIUM",
        "passRate": "61.57%",
        "problemsUrl": "https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/",
        "solutionsUrl": "https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/solution",
        "problemsDesc": "<p><code>n</code> 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。</p>\n\n<p>如果一块石头的 <strong>同行或者同列</strong> 上有其他石头存在，那么就可以移除这块石头。</p>\n\n<p>给你一个长度为 <code>n</code> 的数组 <code>stones</code> ，其中 <code>stones[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示第 <code>i</code> 块石头的位置，返回 <strong>可以移除的石子</strong> 的最大数量。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\n<strong>输出：</strong>5\n<strong>解释：</strong>一种移除 5 块石头的方法如下所示：\n1. 移除石头 [2,2] ，因为它和 [2,1] 同行。\n2. 移除石头 [2,1] ，因为它和 [0,1] 同列。\n3. 移除石头 [1,2] ，因为它和 [1,0] 同行。\n4. 移除石头 [1,0] ，因为它和 [0,0] 同列。\n5. 移除石头 [0,1] ，因为它和 [0,0] 同行。\n石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\n<strong>输出：</strong>3\n<strong>解释：</strong>一种移除 3 块石头的方法如下所示：\n1. 移除石头 [2,2] ，因为它和 [2,0] 同行。\n2. 移除石头 [2,0] ，因为它和 [0,0] 同列。\n3. 移除石头 [0,2] ，因为它和 [0,0] 同行。\n石头 [0,0] 和 [1,1] 不能移除，因为它们没有与另一块石头同行/列。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [[0,0]]\n<strong>输出：</strong>0\n<strong>解释：</strong>[0,0] 是平面上唯一一块石头，所以不可以移除它。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= stones.length <= 1000</code></li>\n\t<li><code>0 <= x<sub>i</sub>, y<sub>i</sub> <= 10<sup>4</sup></code></li>\n\t<li>不会有两块石头放在同一个坐标点上</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 948.令牌放置",
        "hardRate": "MEDIUM",
        "passRate": "40.53%",
        "problemsUrl": "https://leetcode.cn/problems/bag-of-tokens/",
        "solutionsUrl": "https://leetcode.cn/problems/bag-of-tokens/solution",
        "problemsDesc": "<p>你的初始 <strong>能量</strong> 为 <code>power</code>，初始 <strong>分数</strong> 为&nbsp;<code>0</code>，只有一包令牌 <code>tokens</code> 。其中 <code>tokens[i]</code> 是第 <code>i</code> 个令牌的值（下标从 0 开始）。</p>\n\n<p>令牌可能的两种使用方法如下：</p>\n\n<ul>\n\t<li>如果你至少有&nbsp;<code>token[i]</code>&nbsp;点 <strong>能量</strong> ，可以将令牌 <code>i</code> 置为正面朝上，失去&nbsp;<code>token[i]</code>&nbsp;点 <strong>能量</strong> ，并得到&nbsp;<code>1</code>&nbsp;<strong>分</strong> 。</li>\n\t<li>如果我们至少有&nbsp;<code>1</code>&nbsp;<strong>分 </strong>，可以将令牌 <code>i</code> 置为反面朝上，获得&nbsp;<code>token[i]</code> 点 <strong>能量</strong> ，并失去&nbsp;<code>1</code>&nbsp;<strong>分</strong> 。</li>\n</ul>\n\n<p>每个令牌 <strong>最多</strong> 只能使用一次，使用 <strong>顺序不限</strong> ，<strong>不需</strong> 使用所有令牌。</p>\n\n<p>在使用任意数量的令牌后，返回我们可以得到的最大 <strong>分数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>tokens = [100], power = 50\n<strong>输出：</strong>0\n<strong>解释：</strong>无法使用唯一的令牌，因为能量和分数都太少了。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>tokens = [100,200], power = 150\n<strong>输出：</strong>1\n<strong>解释：</strong>令牌 0 正面朝上，能量变为 50，分数变为 1 。\n不必使用令牌 1 ，因为你无法使用它来提高分数。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>tokens = [100,200,300,400], power = 200\n<strong>输出：</strong>2\n<strong>解释：</strong>按下面顺序使用令牌可以得到 2 分：\n1. 令牌 0 正面朝上，能量变为 100 ，分数变为 1\n2. 令牌 3 正面朝下，能量变为 500 ，分数变为 0\n3. 令牌 1 正面朝上，能量变为 300 ，分数变为 1\n4. 令牌 2 正面朝上，能量变为 0 ，分数变为 2</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= tokens.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= tokens[i],&nbsp;power &lt; 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 949.给定数字能组成的最大时间",
        "hardRate": "MEDIUM",
        "passRate": "37.95%",
        "problemsUrl": "https://leetcode.cn/problems/largest-time-for-given-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-time-for-given-digits/solution",
        "problemsDesc": "<p>给定一个由 4 位数字组成的数组，返回可以设置的符合 24 小时制的最大时间。</p>\n\n<p>24 小时格式为 <code>\"HH:MM\"</code> ，其中 <code>HH</code> 在 <code>00</code> 到 <code>23</code> 之间，<code>MM</code> 在 <code>00</code> 到 <code>59</code> 之间。最小的 24 小时制时间是 <code>00:00</code> ，而最大的是 <code>23:59</code> 。从 00:00 （午夜）开始算起，过得越久，时间越大。</p>\n\n<p>以长度为 5 的字符串，按 <code>\"HH:MM\"</code> 格式返回答案。如果不能确定有效时间，则返回空字符串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,4]\n<strong>输出：</strong>\"23:41\"\n<strong>解释：</strong>有效的 24 小时制时间是 \"12:34\"，\"12:43\"，\"13:24\"，\"13:42\"，\"14:23\"，\"14:32\"，\"21:34\"，\"21:43\"，\"23:14\" 和 \"23:41\" 。这些时间中，\"23:41\" 是最大时间。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [5,5,5,5]\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>不存在有效的 24 小时制时间，因为 \"55:55\" 无效。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,0,0,0]\n<strong>输出：</strong>\"00:00\"\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,0,1,0]\n<strong>输出：</strong>\"10:00\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>arr.length == 4</code></li>\n\t<li><code>0 <= arr[i] <= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 950.按递增顺序显示卡牌",
        "hardRate": "MEDIUM",
        "passRate": "78.65%",
        "problemsUrl": "https://leetcode.cn/problems/reveal-cards-in-increasing-order/",
        "solutionsUrl": "https://leetcode.cn/problems/reveal-cards-in-increasing-order/solution",
        "problemsDesc": "<p>牌组中的每张卡牌都对应有一个唯一的整数。你可以按你想要的顺序对这套卡片进行排序。</p>\n\n<p>最初，这些卡牌在牌组里是正面朝下的（即，未显示状态）。</p>\n\n<p>现在，重复执行以下步骤，直到显示所有卡牌为止：</p>\n\n<ol>\n\t<li>从牌组顶部抽一张牌，显示它，然后将其从牌组中移出。</li>\n\t<li>如果牌组中仍有牌，则将下一张处于牌组顶部的牌放在牌组的底部。</li>\n\t<li>如果仍有未显示的牌，那么返回步骤 1。否则，停止行动。</li>\n</ol>\n\n<p>返回能以<strong>递增顺序</strong>显示卡牌的牌组顺序。</p>\n\n<p>答案中的第一张牌被认为处于牌堆顶部。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>[17,13,11,2,3,5,7]\n<strong>输出：</strong>[2,13,3,11,5,17,7]\n<strong>解释：\n</strong>我们得到的牌组顺序为 [17,13,11,2,3,5,7]（这个顺序不重要），然后将其重新排序。\n重新排序后，牌组以 [2,13,3,11,5,17,7] 开始，其中 2 位于牌组的顶部。\n我们显示 2，然后将 13 移到底部。牌组现在是 [3,11,5,17,7,13]。\n我们显示 3，并将 11 移到底部。牌组现在是 [5,17,7,13,11]。\n我们显示 5，然后将 17 移到底部。牌组现在是 [7,13,11,17]。\n我们显示 7，并将 13 移到底部。牌组现在是 [11,17,13]。\n我们显示 11，然后将 17 移到底部。牌组现在是 [13,17]。\n我们展示 13，然后将 17 移到底部。牌组现在是 [17]。\n我们显示 17。\n由于所有卡片都是按递增顺序排列显示的，所以答案是正确的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= A.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= A[i] &lt;= 10^6</code></li>\n\t<li>对于所有的&nbsp;<code>i != j</code>，<code>A[i] != A[j]</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 951.翻转等价二叉树",
        "hardRate": "MEDIUM",
        "passRate": "66.83%",
        "problemsUrl": "https://leetcode.cn/problems/flip-equivalent-binary-trees/",
        "solutionsUrl": "https://leetcode.cn/problems/flip-equivalent-binary-trees/solution",
        "problemsDesc": "<p>我们可以为二叉树 <strong>T</strong> 定义一个&nbsp;<strong>翻转操作&nbsp;</strong>，如下所示：选择任意节点，然后交换它的左子树和右子树。</p>\n\n<p>只要经过一定次数的翻转操作后，能使 <strong>X</strong> 等于 <strong>Y</strong>，我们就称二叉树 <strong>X</strong> <em>翻转 等价&nbsp;</em>于二叉树 <strong>Y</strong>。</p>\n\n<p>这些树由根节点&nbsp;<code>root1</code> 和 <code>root2</code>&nbsp;给出。如果两个二叉树是否是<em>翻转 等价&nbsp;</em>的函数，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"Flipped Trees Diagram\" src=\"https://assets.leetcode.com/uploads/2018/11/29/tree_ex.png\" /></p>\n\n<pre>\n<strong>输入：</strong>root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]\n<strong>输出：</strong>true\n<strong>解释：</strong>我们翻转值为 1，3 以及 5 的三个节点。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> root1 = [], root2 = []\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> root1 = [], root2 = [1]\n<strong>输出:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每棵树节点数在&nbsp;<code>[0, 100]</code> 范围内</li>\n\t<li>每棵树中的每个值都是唯一的、在 <code>[0, 99]</code>&nbsp;范围内的整数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 952.按公因数计算最大组件大小",
        "hardRate": "HARD",
        "passRate": "51.09%",
        "problemsUrl": "https://leetcode.cn/problems/largest-component-size-by-common-factor/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-component-size-by-common-factor/solution",
        "problemsDesc": "<p>给定一个由不同正整数的组成的非空数组&nbsp;<code>nums</code> ，考虑下面的图：</p>\n\n<ul>\n\t<li>有&nbsp;<code>nums.length</code>&nbsp;个节点，按从&nbsp;<code>nums[0]</code>&nbsp;到&nbsp;<code>nums[nums.length - 1]</code>&nbsp;标记；</li>\n\t<li>只有当&nbsp;<code>nums[i]</code>&nbsp;和&nbsp;<code>nums[j]</code>&nbsp;共用一个大于 1 的公因数时，<code>nums[i]</code>&nbsp;和&nbsp;<code>nums[j]</code>之间才有一条边。</li>\n</ul>\n\n<p>返回 <em>图中最大连通组件的大小</em> 。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/01/ex1.png\" style=\"height: 97px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,6,15,35]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/01/ex2.png\" style=\"height: 85px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [20,50,9,63]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/01/ex3.png\" style=\"height: 260px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,6,7,4,12,21,39]\n<strong>输出：</strong>8\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums</code>&nbsp;中所有值都 <strong>不同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 953.验证外星语词典",
        "hardRate": "EASY",
        "passRate": "57.69%",
        "problemsUrl": "https://leetcode.cn/problems/verifying-an-alien-dictionary/",
        "solutionsUrl": "https://leetcode.cn/problems/verifying-an-alien-dictionary/solution",
        "problemsDesc": "<p>某种外星语也使用英文小写字母，但可能顺序 <code>order</code> 不同。字母表的顺序（<code>order</code>）是一些小写字母的排列。</p>\n\n<p>给定一组用外星语书写的单词 <code>words</code>，以及其字母表的顺序 <code>order</code>，只有当给定的单词在这种外星语中按字典序排列时，返回 <code>true</code>；否则，返回 <code>false</code>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\n<strong>输出：</strong>true\n<strong>解释：</strong>在该语言的字母表中，'h' 位于 'l' 之前，所以单词序列是按字典序排列的。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\n<strong>输出：</strong>false\n<strong>解释：</strong>在该语言的字母表中，'d' 位于 'l' 之后，那么 words[0] > words[1]，因此单词序列不是按字典序排列的。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\n<strong>输出：</strong>false\n<strong>解释：</strong>当前三个字符 \"app\" 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 \"apple\" > \"app\"，因为 'l' > '∅'，其中 '∅' 是空白字符，定义为比任何其他字符都小（<a href=\"https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E5%BA%8F\" target=\"_blank\">更多信息</a>）。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= words.length <= 100</code></li>\n\t<li><code>1 <= words[i].length <= 20</code></li>\n\t<li><code>order.length == 26</code></li>\n\t<li>在 <code>words[i]</code> 和 <code>order</code> 中的所有字符都是英文小写字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 954.二倍数对数组",
        "hardRate": "MEDIUM",
        "passRate": "39.08%",
        "problemsUrl": "https://leetcode.cn/problems/array-of-doubled-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/array-of-doubled-pairs/solution",
        "problemsDesc": "<p>给定一个长度为偶数的整数数组 <code>arr</code>，只有对 <code>arr</code> 进行重组后可以满足 “对于每个 <code>0 &lt;=&nbsp;i &lt; len(arr) / 2</code>，都有 <code>arr[2 * i + 1] = 2 * arr[2 * i]</code>”&nbsp;时，返回 <code>true</code>；否则，返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [3,1,3,6]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [2,1,2,6]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [4,-2,2,-4]\n<strong>输出：</strong>true\n<strong>解释：</strong>可以用 [-2,-4] 和 [2,4] 这两组组成 [-2,-4,2,4] 或是 [2,4,-2,-4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= arr.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>arr.length</code> 是偶数</li>\n\t<li><code>-10<sup>5</sup> &lt;= arr[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 955.删列造序 II",
        "hardRate": "MEDIUM",
        "passRate": "35.54%",
        "problemsUrl": "https://leetcode.cn/problems/delete-columns-to-make-sorted-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-columns-to-make-sorted-ii/solution",
        "problemsDesc": "<p>给定由 <code>n</code> 个字符串组成的数组 <code>strs</code>，其中每个字符串长度相等。</p>\n\n<p>选取一个删除索引序列，对于 <code>strs</code> 中的每个字符串，删除对应每个索引处的字符。</p>\n\n<p>比如，有 <code>strs = [\"abcdef\", \"uvwxyz\"]</code>，删除索引序列 <code>{0, 2, 3}</code>，删除后 <code>strs</code> 为<code>[\"bef\", \"vyz\"]</code>。</p>\n\n<p>假设，我们选择了一组删除索引 <code>answer</code>，那么在执行删除操作之后，最终得到的数组的元素是按 <strong>字典序</strong>（<code>strs[0] <= strs[1] <= strs[2] ... <= strs[n - 1]</code>）排列的，然后请你返回 <code>answer.length</code> 的最小可能值。</p>\n\n<p> </p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"ca\",\"bb\",\"ac\"]\n<strong>输出：</strong>1\n<strong>解释： </strong>\n删除第一列后，strs = [\"a\", \"b\", \"c\"]。\n现在 strs 中元素是按字典排列的 (即，strs[0] <= strs[1] <= strs[2])。\n我们至少需要进行 1 次删除，因为最初 strs 不是按字典序排列的，所以答案是 1。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"xc\",\"yb\",\"za\"]\n<strong>输出：</strong>0\n<strong>解释：</strong>\nstrs 的列已经是按字典序排列了，所以我们不需要删除任何东西。\n注意 strs 的行不需要按字典序排列。\n也就是说，strs[0][0] <= strs[0][1] <= ... 不一定成立。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"zyx\",\"wvu\",\"tsr\"]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n我们必须删掉每一列。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == strs.length</code></li>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>1 <= strs[i].length <= 100</code></li>\n\t<li><code>strs[i]</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 956.最高的广告牌",
        "hardRate": "HARD",
        "passRate": "46.49%",
        "problemsUrl": "https://leetcode.cn/problems/tallest-billboard/",
        "solutionsUrl": "https://leetcode.cn/problems/tallest-billboard/solution",
        "problemsDesc": "<p>你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。</p>\n\n<p>你有一堆可以焊接在一起的钢筋 <code>rods</code>。举个例子，如果钢筋的长度为 <code>1</code>、<code>2</code> 和 <code>3</code>，则可以将它们焊接在一起形成长度为 <code>6</code>&nbsp;的支架。</p>\n\n<p>返回 <em>广告牌的最大可能安装高度</em> 。如果没法安装广告牌，请返回 <code>0</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1,2,3,6]\n<strong>输出：</strong>6\n<strong>解释：</strong>我们有两个不相交的子集 {1,2,3} 和 {6}，它们具有相同的和 sum = 6。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1,2,3,4,5,6]\n<strong>输出：</strong>10\n<strong>解释：</strong>我们有两个不相交的子集 {2,3,5} 和 {4,6}，它们具有相同的和 sum = 10。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1,2]\n<strong>输出：</strong>0\n<strong>解释：</strong>没法安装广告牌，所以返回 0。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>0 &lt;= rods.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= rods[i] &lt;= 1000</code></li>\n\t<li><code>sum(rods[i]) &lt;= 5000</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 957.N 天后的牢房",
        "hardRate": "MEDIUM",
        "passRate": "37.04%",
        "problemsUrl": "https://leetcode.cn/problems/prison-cells-after-n-days/",
        "solutionsUrl": "https://leetcode.cn/problems/prison-cells-after-n-days/solution",
        "problemsDesc": "<p>监狱中 <code>8</code> 间牢房排成一排，每间牢房可能被占用或空置。</p>\n\n<p>每天，无论牢房是被占用或空置，都会根据以下规则进行变更：</p>\n\n<ul>\n\t<li>如果一间牢房的两个相邻的房间都被占用或都是空的，那么该牢房就会被占用。</li>\n\t<li>否则，它就会被空置。</li>\n</ul>\n\n<p><strong>注意</strong>：由于监狱中的牢房排成一行，所以行中的第一个和最后一个牢房不存在两个相邻的房间。</p>\n\n<p>给你一个整数数组 <code>cells</code> ，用于表示牢房的初始状态：如果第 <code>i</code> 间牢房被占用，则 <code>cell[i]==1</code>，否则 <code>cell[i]==0</code> 。另给你一个整数 <code>n</code> 。</p>\n\n<p>请你返回 <code>n</code> 天后监狱的状况（即，按上文描述进行 <code>n</code> 次变更）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>cells = [0,1,0,1,1,0,0,1], n = 7\n<strong>输出：</strong>[0,0,1,1,0,0,0,0]\n<strong>解释：</strong>下表总结了监狱每天的状况：\nDay 0: [0, 1, 0, 1, 1, 0, 0, 1]\nDay 1: [0, 1, 1, 0, 0, 0, 0, 0]\nDay 2: [0, 0, 0, 0, 1, 1, 1, 0]\nDay 3: [0, 1, 1, 0, 0, 1, 0, 0]\nDay 4: [0, 0, 0, 0, 0, 1, 0, 0]\nDay 5: [0, 1, 1, 1, 0, 1, 0, 0]\nDay 6: [0, 0, 1, 0, 1, 1, 0, 0]\nDay 7: [0, 0, 1, 1, 0, 0, 0, 0]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>cells = [1,0,0,1,0,0,1,0], n = 1000000000\n<strong>输出：</strong>[0,0,1,1,1,1,1,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>cells.length == 8</code></li>\n\t<li><code>cells[i]</code> 为 <code>0</code> 或 <code>1</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 958.二叉树的完全性检验",
        "hardRate": "MEDIUM",
        "passRate": "54.48%",
        "problemsUrl": "https://leetcode.cn/problems/check-completeness-of-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/check-completeness-of-a-binary-tree/solution",
        "problemsDesc": "<p>给定一个二叉树的<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;，确定它是否是一个&nbsp;<em>完全二叉树</em>&nbsp;。</p>\n\n<p>在一个&nbsp;<strong><a href=\"https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin\" target=\"_blank\">完全二叉树</a></strong>&nbsp;中，除了最后一个关卡外，所有关卡都是完全被填满的，并且最后一个关卡中的所有节点都是尽可能靠左的。它可以包含<meta charset=\"UTF-8\" />&nbsp;<code>1</code>&nbsp;到<meta charset=\"UTF-8\" />&nbsp;<code>2<sup>h</sup></code>&nbsp;节点之间的最后一级 <code>h</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-1.png\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,5,6]\n<strong>输出：</strong>true\n<strong>解释：</strong>最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-2.png\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,5,null,7]\n<strong>输出：</strong>false\n<strong>解释：</strong>值为 7 的结点没有尽可能靠向左侧。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树的结点数在范围 <meta charset=\"UTF-8\" />&nbsp;<code>[1, 100]</code>&nbsp;内。</li>\n\t<li><code>1 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 959.由斜杠划分区域",
        "hardRate": "MEDIUM",
        "passRate": "74.22%",
        "problemsUrl": "https://leetcode.cn/problems/regions-cut-by-slashes/",
        "solutionsUrl": "https://leetcode.cn/problems/regions-cut-by-slashes/solution",
        "problemsDesc": "<p>在由 <code>1 x 1</code> 方格组成的 <code>n&nbsp;x n</code>&nbsp;网格&nbsp;<code>grid</code> 中，每个 <code>1 x 1</code>&nbsp;方块由 <code>'/'</code>、<code>'\\'</code> 或空格构成。这些字符会将方块划分为一些共边的区域。</p>\n\n<p>给定网格&nbsp;<code>grid</code>&nbsp;表示为一个字符串数组，返回 <em>区域的数量</em> 。</p>\n\n<p>请注意，反斜杠字符是转义的，因此&nbsp;<code>'\\'</code> 用 <code>'\\\\'</code>&nbsp;表示。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/15/1.png\" style=\"height: 200px; width: 200px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [\" /\",\"/ \"]\n<strong>输出：</strong>2</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/15/2.png\" style=\"height: 198px; width: 200px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [\" /\",\"  \"]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/15/4.png\" style=\"height: 200px; width: 200px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [\"/\\\\\",\"\\\\/\"]\n<strong>输出：</strong>5\n<strong>解释：</strong>回想一下，因为 \\ 字符是转义的，所以 \"/\\\\\" 表示 /\\，而 \"\\\\/\" 表示 \\/。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n\t<li><code>grid[i][j]</code> 是&nbsp;<code>'/'</code>、<code>'\\'</code>、或&nbsp;<code>' '</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 960.删列造序 III",
        "hardRate": "HARD",
        "passRate": "59.12%",
        "problemsUrl": "https://leetcode.cn/problems/delete-columns-to-make-sorted-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-columns-to-make-sorted-iii/solution",
        "problemsDesc": "<p>给定由<meta charset=\"UTF-8\" />&nbsp;<code>n</code>&nbsp;个小写字母字符串组成的数组<meta charset=\"UTF-8\" />&nbsp;<code>strs</code>&nbsp;，其中每个字符串长度相等。</p>\n\n<p>选取一个删除索引序列，对于<meta charset=\"UTF-8\" />&nbsp;<code>strs</code>&nbsp;中的每个字符串，删除对应每个索引处的字符。</p>\n\n<p>比如，有<meta charset=\"UTF-8\" />&nbsp;<code>strs = [\"abcdef\",\"uvwxyz\"]</code>&nbsp;，删除索引序列<meta charset=\"UTF-8\" />&nbsp;<code>{0, 2, 3}</code>&nbsp;，删除后为<meta charset=\"UTF-8\" />&nbsp;<code>[\"bef\", \"vyz\"]</code>&nbsp;。</p>\n\n<p>假设，我们选择了一组删除索引<meta charset=\"UTF-8\" />&nbsp;<code>answer</code>&nbsp;，那么在执行删除操作之后，最终得到的数组的行中的 <strong>每个元素</strong> 都是按<strong>字典序</strong>排列的（即&nbsp;<code>(strs[0][0] &lt;= strs[0][1] &lt;= ... &lt;= strs[0][strs[0].length - 1])</code>&nbsp;和&nbsp;<code>(strs[1][0] &lt;= strs[1][1] &lt;= ... &lt;= strs[1][strs[1].length - 1])</code> ，依此类推）。</p>\n\n<p>请返回<meta charset=\"UTF-8\" /><em>&nbsp;<code>answer.length</code>&nbsp;的最小可能值</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"babca\",\"bbazb\"]\n<strong>输出：</strong>3\n<strong>解释：\n</strong>删除 0、1 和 4 这三列后，最终得到的数组是 A = [\"bc\", \"az\"]。\n这两行是分别按字典序排列的（即，A[0][0] &lt;= A[0][1] 且 A[1][0] &lt;= A[1][1]）。\n注意，A[0] &gt; A[1] —— 数组 A 不一定是按字典序排列的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"edcba\"]\n<strong>输出：</strong>4\n<strong>解释：</strong>如果删除的列少于 4 列，则剩下的行都不会按字典序排列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"ghi\",\"def\",\"abc\"]\n<strong>输出：</strong>0\n<strong>解释：</strong>所有行都已按字典序排列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>n == strs.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= strs[i].length &lt;= 100</code></li>\n\t<li><code>strs[i]</code>&nbsp;由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 961.在长度 2N 的数组中找出重复 N 次的元素",
        "hardRate": "EASY",
        "passRate": "70.19%",
        "problemsUrl": "https://leetcode.cn/problems/n-repeated-element-in-size-2n-array/",
        "solutionsUrl": "https://leetcode.cn/problems/n-repeated-element-in-size-2n-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，该数组具有以下属性：</p>\n\n<div class=\"original__bRMd\">\n<div>\n<ul>\n\t<li><code>nums.length == 2 * n</code>.</li>\n\t<li><code>nums</code> 包含 <code>n + 1</code> 个 <strong>不同的</strong> 元素</li>\n\t<li><code>nums</code> 中恰有一个元素重复 <code>n</code> 次</li>\n</ul>\n\n<p>找出并返回重复了 <code>n</code><em> </em>次的那个元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,3]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,2,5,3,2]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,1,5,2,5,3,5,4]\n<strong>输出：</strong>5\n</pre>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 5000</code></li>\n\t<li><code>nums.length == 2 * n</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> 由 <code>n + 1</code> 个<strong> 不同的</strong> 元素组成，且其中一个元素恰好重复 <code>n</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 962.最大宽度坡",
        "hardRate": "MEDIUM",
        "passRate": "47.36%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-width-ramp/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-width-ramp/solution",
        "problemsDesc": "<p>给定一个整数数组&nbsp;<code>A</code>，<em>坡</em>是元组&nbsp;<code>(i, j)</code>，其中&nbsp;&nbsp;<code>i &lt; j</code>&nbsp;且&nbsp;<code>A[i] &lt;= A[j]</code>。这样的坡的宽度为&nbsp;<code>j - i</code>。</p>\n\n<p>找出&nbsp;<code>A</code>&nbsp;中的坡的最大宽度，如果不存在，返回 0 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[6,0,8,2,1,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>\n最大宽度的坡为 (i, j) = (1, 5): A[1] = 0 且 A[5] = 5.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>[9,8,1,0,1,9,4,0,4,1]\n<strong>输出：</strong>7\n<strong>解释：</strong>\n最大宽度的坡为 (i, j) = (2, 9): A[2] = 1 且 A[9] = 1.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>2 &lt;= A.length &lt;= 50000</code></li>\n\t<li><code>0 &lt;= A[i] &lt;= 50000</code></li>\n</ol>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 963.最小面积矩形 II",
        "hardRate": "MEDIUM",
        "passRate": "51.10%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-area-rectangle-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-area-rectangle-ii/solution",
        "problemsDesc": "<p>给定在 xy 平面上的一组点，确定由这些点组成的任何矩形的最小面积，其中矩形的边<strong>不一定平行于</strong> x 轴和 y 轴。</p>\n\n<p>如果没有任何矩形，就返回 0。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/22/1a.png\" style=\"height: 151px; width: 150px;\"></strong></p>\n\n<pre><strong>输入：</strong>[[1,2],[2,1],[1,0],[0,1]]\n<strong>输出：</strong>2.00000\n<strong>解释：</strong>最小面积的矩形出现在 [1,2],[2,1],[1,0],[0,1] 处，面积为 2。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/23/2.png\" style=\"height: 94px; width: 150px;\"></p>\n\n<pre><strong>输入：</strong>[[0,1],[2,1],[1,1],[1,0],[2,0]]\n<strong>输出：</strong>1.00000\n<strong>解释：</strong>最小面积的矩形出现在 [1,0],[1,1],[2,1],[2,0] 处，面积为 1。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/23/3.png\" style=\"height: 94px; width: 150px;\"></p>\n\n<pre><strong>输入：</strong>[[0,3],[1,2],[3,1],[1,3],[2,1]]\n<strong>输出：</strong>0\n<strong>解释：</strong>没法从这些点中组成任何矩形。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/21/4c.png\" style=\"height: 155px; width: 160px;\"></strong></p>\n\n<pre><strong>输入：</strong>[[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]]\n<strong>输出：</strong>2.00000\n<strong>解释：</strong>最小面积的矩形出现在 [2,1],[2,3],[3,3],[3,1] 处，面积为 2。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= points.length &lt;= 50</code></li>\n\t<li><code>0 &lt;=&nbsp;points[i][0] &lt;=&nbsp;40000</code></li>\n\t<li><code>0 &lt;=&nbsp;points[i][1] &lt;=&nbsp;40000</code></li>\n\t<li>所有的点都是不同的。</li>\n\t<li>与真实值误差不超过 <code>10^-5</code>&nbsp;的答案将视为正确结果。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 964.表示数字的最少运算符",
        "hardRate": "HARD",
        "passRate": "46.44%",
        "problemsUrl": "https://leetcode.cn/problems/least-operators-to-express-number/",
        "solutionsUrl": "https://leetcode.cn/problems/least-operators-to-express-number/solution",
        "problemsDesc": "<p>给定一个正整数 <code>x</code>，我们将会写出一个形如&nbsp;<code>x (op1) x (op2) x (op3) x ...</code>&nbsp;的表达式，其中每个运算符&nbsp;<code>op1</code>，<code>op2</code>，… 可以是加、减、乘、除（<code>+</code>，<code>-</code>，<code>*</code>，或是&nbsp;<code>/</code>）之一。例如，对于&nbsp;<code>x = 3</code>，我们可以写出表达式&nbsp;<code>3 * 3 / 3 + 3 - 3</code>，该式的值为 3 。</p>\n\n<p>在写这样的表达式时，我们需要遵守下面的惯例：</p>\n\n<ul>\n\t<li>除运算符（<code>/</code>）返回有理数。</li>\n\t<li>任何地方都没有括号。</li>\n\t<li>我们使用通常的操作顺序：乘法和除法发生在加法和减法之前。</li>\n\t<li>不允许使用一元否定运算符（<code>-</code>）。例如，“<code>x - x</code>” 是一个有效的表达式，因为它只使用减法，但是 “<code>-x + x</code>” 不是，因为它使用了否定运算符。&nbsp;</li>\n</ul>\n\n<p>我们希望编写一个能使表达式等于给定的目标值 <code>target</code> 且运算符最少的表达式。返回所用运算符的最少数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 3, target = 19\n<strong>输出：</strong>5\n<strong>解释：</strong>3 * 3 + 3 * 3 + 3 / 3 。表达式包含 5 个运算符。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 5, target = 501\n<strong>输出：</strong>8\n<strong>解释：</strong>5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5 。表达式包含 8 个运算符。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 100, target = 100000000\n<strong>输出：</strong>3\n<strong>解释：</strong>100 * 100 * 100 * 100 。表达式包含 3 个运算符。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= x &lt;= 100</code></li>\n\t<li><code>1 &lt;= target &lt;= 2 * 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 965.单值二叉树",
        "hardRate": "EASY",
        "passRate": "70.63%",
        "problemsUrl": "https://leetcode.cn/problems/univalued-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/univalued-binary-tree/solution",
        "problemsDesc": "<p>如果二叉树每个节点都具有相同的值，那么该二叉树就是<em>单值</em>二叉树。</p>\n\n<p>只有给定的树是单值二叉树时，才返回&nbsp;<code>true</code>；否则返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/screen-shot-2018-12-25-at-50104-pm.png\" style=\"height: 159px; width: 200px;\"></p>\n\n<pre><strong>输入：</strong>[1,1,1,1,1,null,1]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/screen-shot-2018-12-25-at-50050-pm.png\" style=\"height: 158px; width: 200px;\"></p>\n\n<pre><strong>输入：</strong>[2,2,2,5,2]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>给定树的节点数范围是&nbsp;<code>[1, 100]</code>。</li>\n\t<li>每个节点的值都是整数，范围为&nbsp;<code>[0, 99]</code>&nbsp;。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 966.元音拼写检查器",
        "hardRate": "MEDIUM",
        "passRate": "42.97%",
        "problemsUrl": "https://leetcode.cn/problems/vowel-spellchecker/",
        "solutionsUrl": "https://leetcode.cn/problems/vowel-spellchecker/solution",
        "problemsDesc": "<p>在给定单词列表&nbsp;<code>wordlist</code>&nbsp;的情况下，我们希望实现一个拼写检查器，将查询单词转换为正确的单词。</p>\n\n<p>对于给定的查询单词&nbsp;<code>query</code>，拼写检查器将会处理两类拼写错误：</p>\n\n<ul>\n\t<li>大小写：如果查询匹配单词列表中的某个单词（<strong>不区分大小写</strong>），则返回的正确单词与单词列表中的大小写相同。\n\n\t<ul>\n\t\t<li>例如：<code>wordlist = [\"yellow\"]</code>, <code>query = \"YellOw\"</code>: <code>correct = \"yellow\"</code></li>\n\t\t<li>例如：<code>wordlist = [\"Yellow\"]</code>, <code>query = \"yellow\"</code>: <code>correct = \"Yellow\"</code></li>\n\t\t<li>例如：<code>wordlist = [\"yellow\"]</code>, <code>query = \"yellow\"</code>: <code>correct = \"yellow\"</code></li>\n\t</ul>\n\t</li>\n\t<li>元音错误：如果在将查询单词中的元音 <code>('a', 'e', 'i', 'o', 'u')</code>&nbsp;&nbsp;分别替换为任何元音后，能与单词列表中的单词匹配（<strong>不区分大小写</strong>），则返回的正确单词与单词列表中的匹配项大小写相同。\n\t<ul>\n\t\t<li>例如：<code>wordlist = [\"YellOw\"]</code>, <code>query = \"yollow\"</code>: <code>correct = \"YellOw\"</code></li>\n\t\t<li>例如：<code>wordlist = [\"YellOw\"]</code>, <code>query = \"yeellow\"</code>: <code>correct = \"\"</code> （无匹配项）</li>\n\t\t<li>例如：<code>wordlist = [\"YellOw\"]</code>, <code>query = \"yllw\"</code>: <code>correct = \"\"</code> （无匹配项）</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>此外，拼写检查器还按照以下优先级规则操作：</p>\n\n<ul>\n\t<li>当查询完全匹配单词列表中的某个单词（<strong>区分大小写</strong>）时，应返回相同的单词。</li>\n\t<li>当查询匹配到大小写问题的单词时，您应该返回单词列表中的第一个这样的匹配项。</li>\n\t<li>当查询匹配到元音错误的单词时，您应该返回单词列表中的第一个这样的匹配项。</li>\n\t<li>如果该查询在单词列表中没有匹配项，则应返回空字符串。</li>\n</ul>\n\n<p>给出一些查询 <code>queries</code>，返回一个单词列表 <code>answer</code>，其中 <code>answer[i]</code> 是由查询 <code>query = queries[i]</code> 得到的正确单词。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>wordlist = [\"KiTe\",\"kite\",\"hare\",\"Hare\"], queries = [\"kite\",\"Kite\",\"KiTe\",\"Hare\",\"HARE\",\"Hear\",\"hear\",\"keti\",\"keet\",\"keto\"]\n<strong>输出：</strong>[\"kite\",\"KiTe\",\"KiTe\",\"Hare\",\"hare\",\"\",\"\",\"KiTe\",\"\",\"KiTe\"]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<b>输入：</b>wordlist = [\"yellow\"], queries = [\"YellOw\"]\n<b>输出：</b>[\"yellow\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= wordlist.length, queries.length &lt;= 5000</code></li>\n\t<li><code>1 &lt;= wordlist[i].length, queries[i].length &lt;= 7</code></li>\n\t<li><code>wordlist[i]</code>&nbsp;和&nbsp;<code>queries[i]</code>&nbsp;只包含英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 967.连续差相同的数字",
        "hardRate": "MEDIUM",
        "passRate": "50.55%",
        "problemsUrl": "https://leetcode.cn/problems/numbers-with-same-consecutive-differences/",
        "solutionsUrl": "https://leetcode.cn/problems/numbers-with-same-consecutive-differences/solution",
        "problemsDesc": "<p>返回所有长度为 <code>n</code> 且满足其每两个连续位上的数字之间的差的绝对值为 <code>k</code> 的<strong> 非负整数 </strong>。</p>\n\n<p>请注意，<strong>除了 </strong>数字 <code>0</code> 本身之外，答案中的每个数字都 <strong>不能 </strong>有前导零。例如，<code>01</code> 有一个前导零，所以是无效的；但 <code>0</code>&nbsp;是有效的。</p>\n\n<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 7\n<strong>输出：</strong>[181,292,707,818,929]\n<strong>解释：</strong>注意，070 不是一个有效的数字，因为它有前导零。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, k = 1\n<strong>输出：</strong>[10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, k = 0\n<strong>输出：</strong>[11,22,33,44,55,66,77,88,99]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, k = 2\n<strong>输出：</strong>[13,20,24,31,35,42,46,53,57,64,68,75,79,86,97]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 9</code></li>\n\t<li><code>0 &lt;= k &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 968.监控二叉树",
        "hardRate": "HARD",
        "passRate": "52.32%",
        "problemsUrl": "https://leetcode.cn/problems/binary-tree-cameras/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-tree-cameras/solution",
        "problemsDesc": "<p>给定一个二叉树，我们在树的节点上安装摄像头。</p>\n\n<p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p>\n\n<p>计算监控树的所有节点所需的最小摄像头数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png\" style=\"height: 163px; width: 138px;\"></p>\n\n<pre><strong>输入：</strong>[0,0,null,0,0]\n<strong>输出：</strong>1\n<strong>解释：</strong>如图所示，一台摄像头足以监控所有节点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png\" style=\"height: 312px; width: 139px;\"></p>\n\n<pre><strong>输入：</strong>[0,0,null,0,null,0,null,null,0]\n<strong>输出：</strong>2\n<strong>解释：</strong>需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。\n</pre>\n\n<p><br>\n<strong>提示：</strong></p>\n\n<ol>\n\t<li>给定树的节点数的范围是&nbsp;<code>[1, 1000]</code>。</li>\n\t<li>每个节点的值都是 0。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 969.煎饼排序",
        "hardRate": "MEDIUM",
        "passRate": "67.53%",
        "problemsUrl": "https://leetcode.cn/problems/pancake-sorting/",
        "solutionsUrl": "https://leetcode.cn/problems/pancake-sorting/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> ，请使用 <strong>煎饼翻转</strong><em> </em>完成对数组的排序。</p>\n\n<p>一次煎饼翻转的执行过程如下：</p>\n\n<ul>\n\t<li>选择一个整数 <code>k</code> ，<code>1 <= k <= arr.length</code></li>\n\t<li>反转子数组 <code>arr[0...k-1]</code>（<strong>下标从 0 开始</strong>）</li>\n</ul>\n\n<p>例如，<code>arr = [3,2,1,4]</code> ，选择 <code>k = 3</code> 进行一次煎饼翻转，反转子数组 <code>[3,2,1]</code> ，得到 <code>arr = [<strong>1</strong>,<strong>2</strong>,<strong>3</strong>,4]</code> 。</p>\n\n<p>以数组形式返回能使 <code>arr</code> 有序的煎饼翻转操作所对应的 <code>k</code> 值序列。任何将数组排序且翻转次数在 <code>10 * arr.length</code> 范围内的有效答案都将被判断为正确。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>[3,2,4,1]\n<strong>输出：</strong>[4,2,4,3]\n<strong>解释：</strong>\n我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。\n初始状态 arr = [3, 2, 4, 1]\n第一次翻转后（k = 4）：arr = [<strong>1</strong>, <strong>4</strong>, <strong>2</strong>, <strong>3</strong>]\n第二次翻转后（k = 2）：arr = [<strong>4</strong>, <strong>1</strong>, 2, 3]\n第三次翻转后（k = 4）：arr = [<strong>3</strong>, <strong>2</strong>, <strong>1</strong>, <strong>4</strong>]\n第四次翻转后（k = 3）：arr = [<strong>1</strong>, <strong>2</strong>, <strong>3</strong>, 4]，此时已完成排序。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1,2,3]\n<strong>输出：</strong>[]\n<strong>解释：\n</strong>输入已经排序，因此不需要翻转任何内容。\n请注意，其他可能的答案，如 [3，3] ，也将被判断为正确。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= arr.length <= 100</code></li>\n\t<li><code>1 <= arr[i] <= arr.length</code></li>\n\t<li><code>arr</code> 中的所有整数互不相同（即，<code>arr</code> 是从 <code>1</code> 到 <code>arr.length</code> 整数的一个排列）</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 970.强整数",
        "hardRate": "MEDIUM",
        "passRate": "47.00%",
        "problemsUrl": "https://leetcode.cn/problems/powerful-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/powerful-integers/solution",
        "problemsDesc": "<p>给定三个整数 <code>x</code>&nbsp;、&nbsp;<code>y</code>&nbsp;和<em>&nbsp;</em><code>bound</code><em>&nbsp;</em>，返回 <em>值小于或等于&nbsp;<code>bound</code>&nbsp;的所有&nbsp;<strong>强整数</strong>&nbsp;组成的列表</em>&nbsp;。</p>\n\n<p>如果某一整数可以表示为&nbsp;<code>x<sup>i</sup>&nbsp;+ y<sup>j</sup></code>&nbsp;，其中整数&nbsp;<code>i &gt;= 0</code> 且&nbsp;<code>j &gt;= 0</code>，那么我们认为该整数是一个&nbsp;<strong>强整数</strong>&nbsp;。</p>\n\n<p>你可以按 <strong>任何顺序</strong> 返回答案。在你的回答中，每个值 <strong>最多</strong> 出现一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 2, y = 3, bound = 10\n<strong>输出：</strong>[2,3,4,5,7,9,10]\n<strong>解释： </strong>\n2 = 2<sup>0</sup> + 3<sup>0</sup>\n3 = 2<sup>1</sup> + 3<sup>0</sup>\n4 = 2<sup>0</sup> + 3<sup>1</sup>\n5 = 2<sup>1</sup> + 3<sup>1</sup>\n7 = 2<sup>2</sup> + 3<sup>1</sup>\n9 = 2<sup>3</sup> + 3<sup>0</sup>\n10 = 2<sup>0</sup> + 3<sup>2</sup></pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 3, y = 5, bound = 15\n<strong>输出：</strong>[2,4,6,8,10,14]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= x, y &lt;= 100</code></li>\n\t<li><code>0 &lt;= bound &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 971.翻转二叉树以匹配先序遍历",
        "hardRate": "MEDIUM",
        "passRate": "45.56%",
        "problemsUrl": "https://leetcode.cn/problems/flip-binary-tree-to-match-preorder-traversal/",
        "solutionsUrl": "https://leetcode.cn/problems/flip-binary-tree-to-match-preorder-traversal/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点 <code>root</code> ，树中有 <code>n</code> 个节点，每个节点都有一个不同于其他节点且处于 <code>1</code> 到 <code>n</code> 之间的值。</p>\n\n<p>另给你一个由 <code>n</code> 个值组成的行程序列 <code>voyage</code> ，表示 <strong>预期</strong> 的二叉树 <a href=\"https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin\" target=\"_blank\"><strong>先序遍历</strong></a> 结果。</p>\n\n<p>通过交换节点的左右子树，可以 <strong>翻转</strong> 该二叉树中的任意节点。例，翻转节点 1 的效果如下：</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/15/fliptree.jpg\" style=\"width: 400px; height: 187px;\" />\n<p>请翻转 <strong>最少 </strong>的树中节点，使二叉树的 <strong>先序遍历</strong> 与预期的遍历行程 <code>voyage</code> <strong>相匹配</strong> 。 </p>\n\n<p>如果可以，则返回 <strong>翻转的</strong> 所有节点的值的列表。你可以按任何顺序返回答案。如果不能，则返回列表 <code>[-1]</code>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/02/1219-01.png\" style=\"width: 150px; height: 205px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2], voyage = [2,1]\n<strong>输出：</strong>[-1]\n<strong>解释：</strong>翻转节点无法令先序遍历匹配预期行程。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/02/1219-02.png\" style=\"width: 150px; height: 142px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3], voyage = [1,3,2]\n<strong>输出：</strong>[1]\n<strong>解释：</strong>交换节点 2 和 3 来翻转节点 1 ，先序遍历可以匹配预期行程。</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/02/1219-02.png\" style=\"width: 150px; height: 142px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3], voyage = [1,2,3]\n<strong>输出：</strong>[]\n<strong>解释：</strong>先序遍历已经匹配预期行程，所以不需要翻转节点。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数目为 <code>n</code></li>\n\t<li><code>n == voyage.length</code></li>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>1 <= Node.val, voyage[i] <= n</code></li>\n\t<li>树中的所有值 <strong>互不相同</strong></li>\n\t<li><code>voyage</code> 中的所有值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 972.相等的有理数",
        "hardRate": "HARD",
        "passRate": "41.53%",
        "problemsUrl": "https://leetcode.cn/problems/equal-rational-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/equal-rational-numbers/solution",
        "problemsDesc": "<p>给定两个字符串&nbsp;<code>s</code>&nbsp;和&nbsp;<code>t</code>&nbsp;，每个字符串代表一个非负有理数，只有当它们表示相同的数字时才返回 <code>true</code>&nbsp;。字符串中可以使用括号来表示有理数的重复部分。</p>\n\n<p><strong>有理数</strong>&nbsp;最多可以用三个部分来表示：<em>整数部分</em>&nbsp;<code>&lt;IntegerPart&gt;</code>、<em>小数非重复部分</em>&nbsp;<code>&lt;NonRepeatingPart&gt;</code>&nbsp;和<em>小数重复部分</em>&nbsp;<code>&lt;(&gt;&lt;RepeatingPart&gt;&lt;)&gt;</code>。数字可以用以下三种方法之一来表示：</p>\n\n<ul>\n\t<li><code>&lt;IntegerPart&gt;</code>&nbsp;\n\n\t<ul>\n\t\t<li>例：&nbsp;<code>0</code>&nbsp;,<code>12</code>&nbsp;和&nbsp;<code>123</code>&nbsp;</li>\n\t</ul>\n\t</li>\n\t<li><code>&lt;IntegerPart&gt;&lt;.&gt;&lt;NonRepeatingPart&gt;</code>\n\t<ul>\n\t\t<li>例： <code>0.5<font color=\"#333333\"><font face=\"Helvetica Neue, Helvetica, Arial, sans-serif\"><span style=\"font-size:14px\"><span style=\"background-color:#ffffff\">&nbsp;, </span></span></font></font></code><font color=\"#333333\"><font face=\"Helvetica Neue, Helvetica, Arial, sans-serif\"><span style=\"font-size:14px\"><span style=\"background-color:#ffffff\"><code>1.</code>&nbsp;,&nbsp;</span></span></font></font><code>2.12</code>&nbsp;和&nbsp;<code>123.0001</code></li>\n\t</ul>\n\t</li>\n\t<li><code>&lt;IntegerPart&gt;&lt;.&gt;&lt;NonRepeatingPart&gt;&lt;(&gt;&lt;RepeatingPart&gt;&lt;)&gt;</code>&nbsp;\n\t<ul>\n\t\t<li>例： <code>0.1(6)</code> ， <code>1.(9)</code>， <code>123.00(1212)</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>十进制展开的重复部分通常在一对圆括号内表示。例如：</p>\n\n<ul>\n\t<li><code>1 / 6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66)</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0.(52)\", t = \"0.5(25)\"\n<strong>输出：</strong>true\n<strong>解释：</strong>因为 \"0.(52)\" 代表 0.52525252...，而 \"0.5(25)\" 代表 0.52525252525.....，则这两个字符串表示相同的数字。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0.1666(6)\", t = \"0.166(66)\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0.9(9)\", t = \"1.\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\"0.9(9)\" 代表 0.999999999... 永远重复，等于 1 。[<a href=\"https://baike.baidu.com/item/0.999…/5615429?fr=aladdin\" target=\"_blank\">有关说明，请参阅此链接</a>]\n\"1.\" 表示数字 1，其格式正确：(IntegerPart) = \"1\" 且 (NonRepeatingPart) = \"\" 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每个部分仅由数字组成。</li>\n\t<li>整数部分&nbsp;<code>&lt;IntegerPart&gt;</code>&nbsp;不会以零开头。（零本身除外）</li>\n\t<li><code>1 &lt;= &lt;IntegerPart&gt;.length &lt;= 4 </code></li>\n\t<li><code>0 &lt;= &lt;NonRepeatingPart&gt;.length &lt;= 4 </code></li>\n\t<li><code>1 &lt;= &lt;RepeatingPart&gt;.length &lt;= 4 </code></li>\n</ul>\n<span style=\"display:block\"><span style=\"height:0px\"><span style=\"position:absolute\">​​​​​</span></span></span>",
        "isPlus": false
    },
    {
        "problemsName": " 973.最接近原点的 K 个点",
        "hardRate": "MEDIUM",
        "passRate": "65.23%",
        "problemsUrl": "https://leetcode.cn/problems/k-closest-points-to-origin/",
        "solutionsUrl": "https://leetcode.cn/problems/k-closest-points-to-origin/solution",
        "problemsDesc": "<p>给定一个数组 <code>points</code>&nbsp;，其中&nbsp;<code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;表示 <strong>X-Y</strong> 平面上的一个点，并且是一个整数 <code>k</code> ，返回离原点 <code>(0,0)</code> 最近的 <code>k</code> 个点。</p>\n\n<p>这里，平面上两点之间的距离是&nbsp;<strong>欧几里德距离</strong>（&nbsp;<code>√(x<sub>1</sub>&nbsp;- x<sub>2</sub>)<sup>2</sup>&nbsp;+ (y<sub>1</sub>&nbsp;- y<sub>2</sub>)<sup>2</sup></code>&nbsp;）。</p>\n\n<p>你可以按 <strong>任何顺序</strong> 返回答案。除了点坐标的顺序之外，答案 <strong>确保</strong> 是 <strong>唯一</strong> 的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg\" style=\"height: 400px; width: 400px;\" /></p>\n\n<pre>\n<strong>输入：</strong>points = [[1,3],[-2,2]], k = 1\n<strong>输出：</strong>[[-2,2]]\n<strong>解释： </strong>\n(1, 3) 和原点之间的距离为 sqrt(10)，\n(-2, 2) 和原点之间的距离为 sqrt(8)，\n由于 sqrt(8) &lt; sqrt(10)，(-2, 2) 离原点更近。\n我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[3,3],[5,-1],[-2,4]], k = 2\n<strong>输出：</strong>[[3,3],[-2,4]]\n（答案 [[-2,4],[3,3]] 也会被接受。）\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= points.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt; x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt; 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 974.和可被 K 整除的子数组",
        "hardRate": "MEDIUM",
        "passRate": "47.87%",
        "problemsUrl": "https://leetcode.cn/problems/subarray-sums-divisible-by-k/",
        "solutionsUrl": "https://leetcode.cn/problems/subarray-sums-divisible-by-k/solution",
        "problemsDesc": "<p>给定一个整数数组 <code>nums</code>&nbsp;和一个整数 <code>k</code> ，返回其中元素之和可被 <code>k</code>&nbsp;整除的（连续、非空） <strong>子数组</strong> 的数目。</p>\n\n<p><strong>子数组</strong> 是数组的 <strong>连续</strong> 部分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,5,0,-2,-3,1], k = 5\n<strong>输出：</strong>7\n<strong>解释：\n</strong>有 7 个子数组满足其元素之和可被 k = 5 整除：\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [5], k = 9\n<strong>输出:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>2 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 975.奇偶跳",
        "hardRate": "HARD",
        "passRate": "47.80%",
        "problemsUrl": "https://leetcode.cn/problems/odd-even-jump/",
        "solutionsUrl": "https://leetcode.cn/problems/odd-even-jump/solution",
        "problemsDesc": "<p>给定一个整数数组 <code>A</code>，你可以从某一起始索引出发，跳跃一定次数。在你跳跃的过程中，第 1、3、5... 次跳跃称为奇数跳跃，而第 2、4、6... 次跳跃称为偶数跳跃。</p>\n\n<p>你可以按以下方式从索引 <code>i</code>&nbsp;向后跳转到索引 <code>j</code>（其中 <code>i &lt; j</code>）：</p>\n\n<ul>\n\t<li>在进行奇数跳跃时（如，第&nbsp;1，3，5... 次跳跃），你将会跳到索引 <code>j</code>，使得 <code>A[i] &lt;=&nbsp;A[j]</code>，<code>A[j]</code> 是可能的最小值。如果存在多个这样的索引 <code>j</code>，你只能跳到满足要求的<strong>最小</strong>索引 <code>j</code> 上。</li>\n\t<li>在进行偶数跳跃时（如，第&nbsp;2，4，6... 次跳跃），你将会跳到索引&nbsp;<code>j</code>，使得 <code>A[i] &gt;= A[j]</code>，<code>A[j]</code> 是可能的最大值。如果存在多个这样的索引 <code>j</code>，你只能跳到满足要求的<strong>最小</strong>索引 <code>j</code>&nbsp;上。</li>\n\t<li>（对于某些索引 <code>i</code>，可能无法进行合乎要求的跳跃。）</li>\n</ul>\n\n<p>如果从某一索引开始跳跃一定次数（可能是 0 次或多次），就可以到达数组的末尾（索引 <code>A.length - 1</code>），那么该索引就会被认为是好的起始索引。</p>\n\n<p>返回好的起始索引的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[10,13,12,14,15]\n<strong>输出：</strong>2\n<strong>解释： </strong>\n从起始索引 i = 0 出发，我们可以跳到 i = 2，（因为 A[2] 是 A[1]，A[2]，A[3]，A[4] 中大于或等于 A[0] 的最小值），然后我们就无法继续跳下去了。\n从起始索引 i = 1 和 i = 2 出发，我们可以跳到 i = 3，然后我们就无法继续跳下去了。\n从起始索引 i = 3 出发，我们可以跳到 i = 4，到达数组末尾。\n从起始索引 i = 4 出发，我们已经到达数组末尾。\n总之，我们可以从 2 个不同的起始索引（i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre><strong>输入：</strong>[2,3,1,1,4]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n从起始索引 i=0 出发，我们依次可以跳到 i = 1，i = 2，i = 3：\n\n在我们的第一次跳跃（奇数）中，我们先跳到 i = 1，因为 A[1] 是（A[1]，A[2]，A[3]，A[4]）中大于或等于 A[0] 的最小值。\n\n在我们的第二次跳跃（偶数）中，我们从 i = 1 跳到 i = 2，因为 A[2] 是（A[2]，A[3]，A[4]）中小于或等于 A[1] 的最大值。A[3] 也是最大的值，但 2 是一个较小的索引，所以我们只能跳到 i = 2，而不能跳到 i = 3。\n\n在我们的第三次跳跃（奇数）中，我们从 i = 2 跳到 i = 3，因为 A[3] 是（A[3]，A[4]）中大于或等于 A[2] 的最小值。\n\n我们不能从 i = 3 跳到 i = 4，所以起始索引 i = 0 不是好的起始索引。\n\n类似地，我们可以推断：\n从起始索引 i = 1 出发， 我们跳到 i = 4，这样我们就到达数组末尾。\n从起始索引 i = 2 出发， 我们跳到 i = 3，然后我们就不能再跳了。\n从起始索引 i = 3 出发， 我们跳到 i = 4，这样我们就到达数组末尾。\n从起始索引 i = 4 出发，我们已经到达数组末尾。\n总之，我们可以从 3 个不同的起始索引（i = 1, i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>[5,1,3,4,2]\n<strong>输出：</strong>3\n<strong>解释： </strong>\n我们可以从起始索引 1，2，4 出发到达数组末尾。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= A.length &lt;= 20000</code></li>\n\t<li><code>0 &lt;= A[i] &lt; 100000</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 976.三角形的最大周长",
        "hardRate": "EASY",
        "passRate": "57.50%",
        "problemsUrl": "https://leetcode.cn/problems/largest-perimeter-triangle/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-perimeter-triangle/solution",
        "problemsDesc": "<p>给定由一些正数（代表长度）组成的数组 <code>nums</code>&nbsp;，返回 <em>由其中三个长度组成的、<strong>面积不为零</strong>的三角形的最大周长</em>&nbsp;。如果不能形成任何面积不为零的三角形，返回&nbsp;<code>0</code>。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,2]\n<strong>输出：</strong>5\n<strong>解释：</strong>你可以用三个边长组成一个三角形:1 2 2。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,10]\n<strong>输出：</strong>0\n<strong>解释：</strong>\n你不能用边长 1,1,2 来组成三角形。\n不能用边长 1,1,10 来构成三角形。\n不能用边长 1、2 和 10 来构成三角形。\n因为我们不能用任何三条边长来构成一个非零面积的三角形，所以我们返回 0。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 977.有序数组的平方",
        "hardRate": "EASY",
        "passRate": "67.94%",
        "problemsUrl": "https://leetcode.cn/problems/squares-of-a-sorted-array/",
        "solutionsUrl": "https://leetcode.cn/problems/squares-of-a-sorted-array/solution",
        "problemsDesc": "<p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>\n\n<ul>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-4,-1,0,3,10]\n<strong>输出：</strong>[0,1,9,16,100]\n<strong>解释：</strong>平方后，数组变为 [16,1,0,9,100]\n排序后，数组变为 [0,1,9,16,100]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-7,-3,2,3,11]\n<strong>输出：</strong>[4,9,9,49,121]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code><span>1 <= nums.length <= </span>10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>请你<span style=\"color: rgb(36, 41, 46); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial; display: inline !important; float: none;\">设计时间复杂度为 <code>O(n)</code> 的算法解决本问题</span></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 978.最长湍流子数组",
        "hardRate": "MEDIUM",
        "passRate": "47.53%",
        "problemsUrl": "https://leetcode.cn/problems/longest-turbulent-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-turbulent-subarray/solution",
        "problemsDesc": "<p>给定一个整数数组 <code>arr</code>&nbsp;，返回 <code>arr</code>&nbsp;的&nbsp;<em>最大湍流子数组的<strong>长度</strong></em><strong>&nbsp;</strong>。</p>\n\n<p>如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是&nbsp;<strong>湍流子数组</strong>&nbsp;。</p>\n\n<p>更正式地来说，当 <code>arr</code>&nbsp;的子数组&nbsp;<code>A[i], A[i+1], ..., A[j]</code>&nbsp;满足仅满足下列条件时，我们称其为<em>湍流子数组</em>：</p>\n\n<ul>\n\t<li>若&nbsp;<code>i &lt;= k &lt; j</code>&nbsp;：\n\n\t<ul>\n\t\t<li>当 <code>k</code>&nbsp;为奇数时，&nbsp;<code>A[k] &gt; A[k+1]</code>，且</li>\n\t\t<li>当 <code>k</code> 为偶数时，<code>A[k] &lt; A[k+1]</code>；</li>\n\t</ul>\n\t</li>\n\t<li><strong>或 </strong>若&nbsp;<code>i &lt;= k &lt; j</code>&nbsp;：\n\t<ul>\n\t\t<li>当 <code>k</code> 为偶数时，<code>A[k] &gt; A[k+1]</code>&nbsp;，且</li>\n\t\t<li>当 <code>k</code>&nbsp;为奇数时，&nbsp;<code>A[k] &lt; A[k+1]</code>。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [9,4,2,10,7,8,8,1,9]\n<strong>输出：</strong>5\n<strong>解释：</strong>arr[1] &gt; arr[2] &lt; arr[3] &gt; arr[4] &lt; arr[5]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [4,8,12,16]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [100]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 4 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 979.在二叉树中分配硬币",
        "hardRate": "MEDIUM",
        "passRate": "72.43%",
        "problemsUrl": "https://leetcode.cn/problems/distribute-coins-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/distribute-coins-in-binary-tree/solution",
        "problemsDesc": "<p>给定一个有 <code>N</code> 个结点的二叉树的根结点 <code>root</code>，树中的每个结点上都对应有 <code>node.val</code> 枚硬币，并且总共有 <code>N</code> 枚硬币。</p>\n\n<p>在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。</p>\n\n<p>返回使每个结点上只有一枚硬币所需的移动次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/tree1.png\" style=\"height: 142px; width: 150px;\"></strong></p>\n\n<pre><strong>输入：</strong>[3,0,0]\n<strong>输出：</strong>2\n<strong>解释：</strong>从树的根结点开始，我们将一枚硬币移到它的左子结点上，一枚硬币移到它的右子结点上。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/tree2.png\" style=\"height: 142px; width: 150px;\"></strong></p>\n\n<pre><strong>输入：</strong>[0,3,0]\n<strong>输出：</strong>3\n<strong>解释：</strong>从根结点的左子结点开始，我们将两枚硬币移到根结点上 [移动两次]。然后，我们把一枚硬币从根结点移到右子结点上。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/tree3.png\" style=\"height: 142px; width: 150px;\"></strong></p>\n\n<pre><strong>输入：</strong>[1,0,2]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/tree4.png\" style=\"height: 156px; width: 155px;\"></strong></p>\n\n<pre><strong>输入：</strong>[1,0,0,null,3]\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1&lt;= N &lt;= 100</code></li>\n\t<li><code>0 &lt;= node.val &lt;= N</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 980.不同路径 III",
        "hardRate": "HARD",
        "passRate": "74.12%",
        "problemsUrl": "https://leetcode.cn/problems/unique-paths-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-paths-iii/solution",
        "problemsDesc": "<p>在二维网格 <code>grid</code> 上，有 4 种类型的方格：</p>\n\n<ul>\n\t<li><code>1</code> 表示起始方格。且只有一个起始方格。</li>\n\t<li><code>2</code> 表示结束方格，且只有一个结束方格。</li>\n\t<li><code>0</code> 表示我们可以走过的空方格。</li>\n\t<li><code>-1</code> 表示我们无法跨越的障碍。</li>\n</ul>\n\n<p>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目<strong>。</strong></p>\n\n<p><strong>每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]\n<strong>输出：</strong>2\n<strong>解释：</strong>我们有以下两条路径：\n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\n2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>[[1,0,0,0],[0,0,0,0],[0,0,0,2]]\n<strong>输出：</strong>4\n<strong>解释：</strong>我们有以下四条路径： \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)\n2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)\n3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)\n4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>[[0,1],[2,0]]\n<strong>输出：</strong>0\n<strong>解释：</strong>\n没有一条路能完全穿过每一个空的方格一次。\n请注意，起始和结束方格可以位于网格中的任意位置。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= grid.length * grid[0].length &lt;= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 981.基于时间的键值存储",
        "hardRate": "MEDIUM",
        "passRate": "52.87%",
        "problemsUrl": "https://leetcode.cn/problems/time-based-key-value-store/",
        "solutionsUrl": "https://leetcode.cn/problems/time-based-key-value-store/solution",
        "problemsDesc": "<p>设计一个基于时间的键值数据结构，该结构可以在不同时间戳存储对应同一个键的多个值，并针对特定时间戳检索键对应的值。</p>\n\n<p>实现 <code>TimeMap</code> 类：</p>\n\n<ul>\n\t<li><code>TimeMap()</code> 初始化数据结构对象</li>\n\t<li><code>void set(String key, String value, int timestamp)</code> 存储键 <code>key</code>、值 <code>value</code>，以及给定的时间戳 <code>timestamp</code>。</li>\n\t<li><code>String get(String key, int timestamp)</code>\n\t<ul>\n\t\t<li>返回先前调用 <code>set(key, value, timestamp_prev)</code> 所存储的值，其中 <code>timestamp_prev <= timestamp</code> 。</li>\n\t\t<li>如果有多个这样的值，则返回对应最大的  <code>timestamp_prev</code> 的那个值。</li>\n\t\t<li>如果没有值，则返回空字符串（<code>\"\"</code>）。</li>\n\t</ul>\n\t</li>\n</ul>\n \n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"]\n[[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]\n<strong>输出：</strong>\n[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]\n\n<strong>解释：</strong>\nTimeMap timeMap = new TimeMap();\ntimeMap.set(\"foo\", \"bar\", 1);  // 存储键 \"foo\" 和值 \"bar\" ，时间戳 timestamp = 1   \ntimeMap.get(\"foo\", 1);         // 返回 \"bar\"\ntimeMap.get(\"foo\", 3);         // 返回 \"bar\", 因为在时间戳 3 和时间戳 2 处没有对应 \"foo\" 的值，所以唯一的值位于时间戳 1 处（即 \"bar\"） 。\ntimeMap.set(\"foo\", \"bar2\", 4); // 存储键 \"foo\" 和值 \"bar2\" ，时间戳 timestamp = 4  \ntimeMap.get(\"foo\", 4);         // 返回 \"bar2\"\ntimeMap.get(\"foo\", 5);         // 返回 \"bar2\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= key.length, value.length <= 100</code></li>\n\t<li><code>key</code> 和 <code>value</code> 由小写英文字母和数字组成</li>\n\t<li><code>1 <= timestamp <= 10<sup>7</sup></code></li>\n\t<li><code>set</code> 操作中的时间戳 <code>timestamp</code> 都是严格递增的</li>\n\t<li>最多调用 <code>set</code> 和 <code>get</code> 操作 <code>2 * 10<sup>5</sup></code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 982.按位与为零的三元组",
        "hardRate": "HARD",
        "passRate": "67.29%",
        "problemsUrl": "https://leetcode.cn/problems/triples-with-bitwise-and-equal-to-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/triples-with-bitwise-and-equal-to-zero/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，返回其中 <strong>按位与三元组</strong> 的数目。</p>\n\n<p><strong>按位与三元组</strong> 是由下标 <code>(i, j, k)</code> 组成的三元组，并满足下述全部条件：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; nums.length</code></li>\n\t<li><code>0 &lt;= j &lt; nums.length</code></li>\n\t<li><code>0 &lt;= k &lt; nums.length</code></li>\n\t<li><code>nums[i] &amp; nums[j] &amp; nums[k] == 0</code> ，其中 <code>&amp;</code> 表示按位与运算符。</li>\n</ul>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,3]\n<strong>输出：</strong>12\n<strong>解释：</strong>可以选出如下 i, j, k 三元组：\n(i=0, j=0, k=1) : 2 &amp; 2 &amp; 1\n(i=0, j=1, k=0) : 2 &amp; 1 &amp; 2\n(i=0, j=1, k=1) : 2 &amp; 1 &amp; 1\n(i=0, j=1, k=2) : 2 &amp; 1 &amp; 3\n(i=0, j=2, k=1) : 2 &amp; 3 &amp; 1\n(i=1, j=0, k=0) : 1 &amp; 2 &amp; 2\n(i=1, j=0, k=1) : 1 &amp; 2 &amp; 1\n(i=1, j=0, k=2) : 1 &amp; 2 &amp; 3\n(i=1, j=1, k=0) : 1 &amp; 1 &amp; 2\n(i=1, j=2, k=0) : 1 &amp; 3 &amp; 2\n(i=2, j=0, k=1) : 3 &amp; 2 &amp; 1\n(i=2, j=1, k=0) : 3 &amp; 1 &amp; 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,0,0]\n<strong>输出：</strong>27\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt; 2<sup>16</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 983.最低票价",
        "hardRate": "MEDIUM",
        "passRate": "63.50%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-for-tickets/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-for-tickets/solution",
        "problemsDesc": "<p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为&nbsp;<code>days</code>&nbsp;的数组给出。每一项是一个从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>365</code>&nbsp;的整数。</p>\n\n<p>火车票有 <strong>三种不同的销售方式</strong> ：</p>\n\n<ul>\n\t<li>一张 <strong>为期一天</strong> 的通行证售价为&nbsp;<code>costs[0]</code> 美元；</li>\n\t<li>一张 <strong>为期七天</strong> 的通行证售价为&nbsp;<code>costs[1]</code> 美元；</li>\n\t<li>一张 <strong>为期三十天</strong> 的通行证售价为&nbsp;<code>costs[2]</code> 美元。</li>\n</ul>\n\n<p>通行证允许数天无限制的旅行。 例如，如果我们在第 <code>2</code> 天获得一张 <strong>为期 7 天</strong> 的通行证，那么我们可以连着旅行 7 天：第 <code>2</code> 天、第 <code>3</code> 天、第 <code>4</code> 天、第 <code>5</code> 天、第 <code>6</code> 天、第 <code>7</code> 天和第 <code>8</code> 天。</p>\n\n<p>返回 <em>你想要完成在给定的列表&nbsp;<code>days</code>&nbsp;中列出的每一天的旅行所需要的最低消费&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>days = [1,4,6,7,8,20], costs = [2,7,15]\n<strong>输出：</strong>11\n<strong>解释： </strong>\n例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：\n在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。\n在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。\n在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。\n你总共花了 $11，并完成了你计划的每一天旅行。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\n<strong>输出：</strong>17\n<strong>解释：\n</strong>例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： \n在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。\n在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 \n你总共花了 $17，并完成了你计划的每一天旅行。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= days.length &lt;= 365</code></li>\n\t<li><code>1 &lt;= days[i] &lt;= 365</code></li>\n\t<li><code>days</code>&nbsp;按顺序严格递增</li>\n\t<li><code>costs.length == 3</code></li>\n\t<li><code>1 &lt;= costs[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 984.不含 AAA 或 BBB 的字符串",
        "hardRate": "MEDIUM",
        "passRate": "43.40%",
        "problemsUrl": "https://leetcode.cn/problems/string-without-aaa-or-bbb/",
        "solutionsUrl": "https://leetcode.cn/problems/string-without-aaa-or-bbb/solution",
        "problemsDesc": "<p>给定两个整数 <code>a</code>&nbsp;和 <code>b</code>&nbsp;，返回&nbsp;<strong>任意</strong>&nbsp;字符串 <code>s</code>&nbsp;，要求满足：</p>\n\n<ul>\n\t<li><code>s</code>&nbsp;的长度为 <code>a + b</code>，且正好包含&nbsp;<code>a</code>&nbsp;个 <code>'a'</code>&nbsp;字母与&nbsp;<code>b</code> 个 <code>'b'</code>&nbsp;字母；</li>\n\t<li>子串&nbsp;<code>'aaa'</code>&nbsp;没有出现在 <code>s</code>&nbsp;中；</li>\n\t<li>子串&nbsp;<code>'bbb'</code> 没有出现在 <code>s</code>&nbsp;中。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 1, b = 2\n<strong>输出：</strong>\"abb\"\n<strong>解释：</strong>\"abb\", \"bab\" 和 \"bba\" 都是正确答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 4, b = 1\n<strong>输出：</strong>\"aabaa\"</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= a, b&nbsp;&lt;= 100</code></li>\n\t<li>对于给定的 <code>a</code> 和 <code>b</code>，保证存在满足要求的 <code>s</code>&nbsp;</li>\n</ul>\n<span style=\"display:block\"><span style=\"height:0px\"><span style=\"position:absolute\">​​​</span></span></span>",
        "isPlus": false
    },
    {
        "problemsName": " 985.查询后的偶数和",
        "hardRate": "MEDIUM",
        "passRate": "61.11%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-even-numbers-after-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-even-numbers-after-queries/solution",
        "problemsDesc": "<p>给出一个整数数组&nbsp;<code>A</code>&nbsp;和一个查询数组&nbsp;<code>queries</code>。</p>\n\n<p>对于第&nbsp;<code>i</code>&nbsp;次查询，有&nbsp;<code>val =&nbsp;queries[i][0], index&nbsp;= queries[i][1]</code>，我们会把&nbsp;<code>val</code>&nbsp;加到&nbsp;<code>A[index]</code>&nbsp;上。然后，第&nbsp;<code>i</code>&nbsp;次查询的答案是 <code>A</code> 中偶数值的和。</p>\n\n<p><em>（此处给定的&nbsp;<code>index = queries[i][1]</code>&nbsp;是从 0 开始的索引，每次查询都会永久修改数组&nbsp;<code>A</code>。）</em></p>\n\n<p>返回所有查询的答案。你的答案应当以数组&nbsp;<code>answer</code>&nbsp;给出，<code>answer[i]</code>&nbsp;为第&nbsp;<code>i</code>&nbsp;次查询的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]\n<strong>输出：</strong>[8,6,2,4]\n<strong>解释：</strong>\n开始时，数组为 [1,2,3,4]。\n将 1 加到 A[0] 上之后，数组为 [2,2,3,4]，偶数值之和为 2 + 2 + 4 = 8。\n将 -3 加到 A[1] 上之后，数组为 [2,-1,3,4]，偶数值之和为 2 + 4 = 6。\n将 -4 加到 A[0] 上之后，数组为 [-2,-1,3,4]，偶数值之和为 -2 + 4 = 2。\n将 2 加到 A[3] 上之后，数组为 [-2,-1,3,6]，偶数值之和为 -2 + 6 = 4。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= A.length &lt;= 10000</code></li>\n\t<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10000</code></li>\n\t<li><code>-10000 &lt;= queries[i][0] &lt;= 10000</code></li>\n\t<li><code>0 &lt;= queries[i][1] &lt; A.length</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 986.区间列表的交集",
        "hardRate": "MEDIUM",
        "passRate": "68.48%",
        "problemsUrl": "https://leetcode.cn/problems/interval-list-intersections/",
        "solutionsUrl": "https://leetcode.cn/problems/interval-list-intersections/solution",
        "problemsDesc": "<p>给定两个由一些<strong> 闭区间 </strong>组成的列表，<code>firstList</code> 和 <code>secondList</code> ，其中 <code>firstList[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 而 <code>secondList[j] = [start<sub>j</sub>, end<sub>j</sub>]</code> 。每个区间列表都是成对 <strong>不相交</strong> 的，并且 <strong>已经排序</strong> 。</p>\n\n<p>返回这 <strong>两个区间列表的交集</strong> 。</p>\n\n<p>形式上，<strong>闭区间</strong> <code>[a, b]</code>（其中 <code>a <= b</code>）表示实数 <code>x</code> 的集合，而 <code>a <= x <= b</code> 。</p>\n\n<p>两个闭区间的 <strong>交集</strong> 是一组实数，要么为空集，要么为闭区间。例如，<code>[1, 3]</code> 和 <code>[2, 4]</code> 的交集为 <code>[2, 3]</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/30/interval1.png\" style=\"width: 700px; height: 194px;\" />\n<pre>\n<strong>输入：</strong>firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]\n<strong>输出：</strong>[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>firstList = [[1,3],[5,9]], secondList = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>firstList = [], secondList = [[4,8],[10,12]]\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>firstList = [[1,7]], secondList = [[3,10]]\n<strong>输出：</strong>[[3,7]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= firstList.length, secondList.length <= 1000</code></li>\n\t<li><code>firstList.length + secondList.length >= 1</code></li>\n\t<li><code>0 <= start<sub>i</sub> < end<sub>i</sub> <= 10<sup>9</sup></code></li>\n\t<li><code>end<sub>i</sub> < start<sub>i+1</sub></code></li>\n\t<li><code>0 <= start<sub>j</sub> < end<sub>j</sub> <= 10<sup>9</sup> </code></li>\n\t<li><code>end<sub>j</sub> < start<sub>j+1</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 987.二叉树的垂序遍历",
        "hardRate": "HARD",
        "passRate": "53.78%",
        "problemsUrl": "https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/solution",
        "problemsDesc": "<p>给你二叉树的根结点 <code>root</code> ，请你设计算法计算二叉树的<em> </em><strong>垂序遍历</strong> 序列。</p>\n\n<p>对位于 <code>(row, col)</code> 的每个结点而言，其左右子结点分别位于 <code>(row + 1, col - 1)</code> 和 <code>(row + 1, col + 1)</code> 。树的根结点位于 <code>(0, 0)</code> 。</p>\n\n<p>二叉树的 <strong>垂序遍历</strong> 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。</p>\n\n<p>返回二叉树的 <strong>垂序遍历</strong> 序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg\" style=\"width: 431px; height: 304px;\" />\n<pre>\n<strong>输入：</strong>root = [3,9,20,null,null,15,7]\n<strong>输出：</strong>[[9],[3,15],[20],[7]]\n<strong>解释：</strong>\n列 -1 ：只有结点 9 在此列中。\n列  0 ：只有结点 3 和 15 在此列中，按从上到下顺序。\n列  1 ：只有结点 20 在此列中。\n列  2 ：只有结点 7 在此列中。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg\" style=\"width: 512px; height: 304px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,5,6,7]\n<strong>输出：</strong>[[4],[2],[1,5,6],[3],[7]]\n<strong>解释：</strong>\n列 -2 ：只有结点 4 在此列中。\n列 -1 ：只有结点 2 在此列中。\n列  0 ：结点 1 、5 和 6 都在此列中。\n          1 在上面，所以它出现在前面。\n          5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。\n列  1 ：只有结点 3 在此列中。\n列  2 ：只有结点 7 在此列中。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg\" style=\"width: 512px; height: 304px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,6,5,7]\n<strong>输出：</strong>[[4],[2],[1,5,6],[3],[7]]\n<strong>解释：</strong>\n这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。\n因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中结点数目总数在范围 <code>[1, 1000]</code> 内</li>\n\t<li><code>0 <= Node.val <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 988.从叶结点开始的最小字符串",
        "hardRate": "MEDIUM",
        "passRate": "51.20%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-string-starting-from-leaf/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-string-starting-from-leaf/solution",
        "problemsDesc": "<p>给定一颗根结点为&nbsp;<code>root</code>&nbsp;的二叉树，树中的每一个结点都有一个&nbsp;<code>[0, 25]</code>&nbsp;范围内的值，分别代表字母&nbsp;<code>'a'</code> 到&nbsp;<code>'z'</code>。</p>\n\n<p>返回 <em><strong>按字典序最小</strong> 的字符串，该字符串从这棵树的一个叶结点开始，到根结点结束</em>。</p>\n\n<blockquote>\n<p>注<strong>：</strong>字符串中任何较短的前缀在 <strong>字典序上</strong> 都是 <strong>较小</strong> 的：</p>\n\n<ul>\n\t<li>例如，在字典序上&nbsp;<code>\"ab\"</code> 比&nbsp;<code>\"aba\"</code>&nbsp;要小。叶结点是指没有子结点的结点。&nbsp;</li>\n</ul>\n</blockquote>\n\n<p>节点的叶节点是没有子节点的节点。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/02/tree1.png\" style=\"height: 358px; width: 534px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [0,1,2,3,4,3,4]\n<strong>输出：</strong>\"dba\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2019/01/30/tree2.png\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [25,1,3,1,3,0,2]\n<strong>输出：</strong>\"adz\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2019/02/01/tree3.png\" style=\"height: 513px; width: 490px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [2,2,1,null,1,0,null,0]\n<strong>输出：</strong>\"abc\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给定树的结点数在&nbsp;<code>[1, 8500]</code> 范围内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 25</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 989.数组形式的整数加法",
        "hardRate": "EASY",
        "passRate": "45.93%",
        "problemsUrl": "https://leetcode.cn/problems/add-to-array-form-of-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/add-to-array-form-of-integer/solution",
        "problemsDesc": "<p>整数的 <strong>数组形式</strong> &nbsp;<code>num</code>&nbsp;是按照从左到右的顺序表示其数字的数组。</p>\n\n<ul>\n\t<li>例如，对于 <code>num = 1321</code> ，数组形式是 <code>[1,3,2,1]</code> 。</li>\n</ul>\n\n<p>给定 <code>num</code> ，整数的 <strong>数组形式</strong> ，和整数 <code>k</code> ，返回 <em>整数 <code>num + k</code> 的 <strong>数组形式</strong></em> 。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = [1,2,0,0], k = 34\n<strong>输出：</strong>[1,2,3,4]\n<strong>解释：</strong>1200 + 34 = 1234\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = [2,7,4], k = 181\n<strong>输出：</strong>[4,5,5]\n<strong>解释：</strong>274 + 181 = 455\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = [2,1,5], k = 806\n<strong>输出：</strong>[1,0,2,1]\n<strong>解释：</strong>215 + 806 = 1021\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= num[i] &lt;= 9</code></li>\n\t<li><code>num</code>&nbsp;不包含任何前导零，除了零本身</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 990.等式方程的可满足性",
        "hardRate": "MEDIUM",
        "passRate": "53.47%",
        "problemsUrl": "https://leetcode.cn/problems/satisfiability-of-equality-equations/",
        "solutionsUrl": "https://leetcode.cn/problems/satisfiability-of-equality-equations/solution",
        "problemsDesc": "<p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 <code>equations[i]</code> 的长度为 <code>4</code>，并采用两种不同的形式之一：<code>&quot;a==b&quot;</code> 或&nbsp;<code>&quot;a!=b&quot;</code>。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p>\n\n<p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回&nbsp;<code>true</code>，否则返回 <code>false</code>。&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[&quot;a==b&quot;,&quot;b!=a&quot;]\n<strong>输出：</strong>false\n<strong>解释：</strong>如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>[&quot;b==a&quot;,&quot;a==b&quot;]\n<strong>输出：</strong>true\n<strong>解释：</strong>我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>[&quot;a==b&quot;,&quot;b==c&quot;,&quot;a==c&quot;]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>[&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>[&quot;c==c&quot;,&quot;b==d&quot;,&quot;x!=z&quot;]\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= equations.length &lt;= 500</code></li>\n\t<li><code>equations[i].length == 4</code></li>\n\t<li><code>equations[i][0]</code> 和&nbsp;<code>equations[i][3]</code>&nbsp;是小写字母</li>\n\t<li><code>equations[i][1]</code> 要么是&nbsp;<code>&#39;=&#39;</code>，要么是&nbsp;<code>&#39;!&#39;</code></li>\n\t<li><code>equations[i][2]</code>&nbsp;是&nbsp;<code>&#39;=&#39;</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 991.坏了的计算器",
        "hardRate": "MEDIUM",
        "passRate": "52.28%",
        "problemsUrl": "https://leetcode.cn/problems/broken-calculator/",
        "solutionsUrl": "https://leetcode.cn/problems/broken-calculator/solution",
        "problemsDesc": "<p>在显示着数字&nbsp;<code>startValue</code>&nbsp;的坏计算器上，我们可以执行以下两种操作：</p>\n\n<ul>\n\t<li><strong>双倍（Double）：</strong>将显示屏上的数字乘 2；</li>\n\t<li><strong>递减（Decrement）：</strong>将显示屏上的数字减 <code>1</code> 。</li>\n</ul>\n\n<p>给定两个整数&nbsp;<code>startValue</code>&nbsp;和&nbsp;<code>target</code>&nbsp;。返回显示数字&nbsp;<code>target</code>&nbsp;所需的最小操作数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>startValue = 2, target = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>先进行双倍运算，然后再进行递减运算 {2 -&gt; 4 -&gt; 3}.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>startValue = 5, target = 8\n<strong>输出：</strong>2\n<strong>解释：</strong>先递减，再双倍 {5 -&gt; 4 -&gt; 8}.\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>startValue = 3, target = 10\n<strong>输出：</strong>3\n<strong>解释：</strong>先双倍，然后递减，再双倍 {3 -&gt; 6 -&gt; 5 -&gt; 10}.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= startValue, target &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 992.K 个不同整数的子数组",
        "hardRate": "HARD",
        "passRate": "47.45%",
        "problemsUrl": "https://leetcode.cn/problems/subarrays-with-k-different-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/subarrays-with-k-different-integers/solution",
        "problemsDesc": "<p>给定一个正整数数组 <code>nums</code>和一个整数 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">\bk</span></span></font></font>&nbsp;，返回 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">num</span></span></font></font>&nbsp;中 「<strong>好子数组」</strong><em>&nbsp;</em>的数目。</p>\n\n<p>如果 <code>nums</code>&nbsp;的某个子数组中不同整数的个数恰好为 <code>k</code>，则称 <code>nums</code>&nbsp;的这个连续、不一定不同的子数组为 <strong>「</strong><strong>好子数组 」</strong>。</p>\n\n<ul>\n\t<li>例如，<code>[1,2,3,1,2]</code> 中有&nbsp;<code>3</code>&nbsp;个不同的整数：<code>1</code>，<code>2</code>，以及&nbsp;<code>3</code>。</li>\n</ul>\n\n<p><strong>子数组</strong> 是数组的 <strong>连续</strong> 部分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,2,3], k = 2\n<strong>输出：</strong>7\n<strong>解释：</strong>恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,3,4], k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 993.二叉树的堂兄弟节点",
        "hardRate": "EASY",
        "passRate": "55.79%",
        "problemsUrl": "https://leetcode.cn/problems/cousins-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/cousins-in-binary-tree/solution",
        "problemsDesc": "<p>在二叉树中，根节点位于深度 <code>0</code> 处，每个深度为 <code>k</code> 的节点的子节点位于深度 <code>k+1</code> 处。</p>\n\n<p>如果二叉树的两个节点深度相同，但<strong> 父节点不同</strong> ，则它们是一对<em>堂兄弟节点</em>。</p>\n\n<p>我们给出了具有唯一值的二叉树的根节点 <code>root</code> ，以及树中两个不同节点的值 <code>x</code> 和 <code>y</code> 。</p>\n\n<p>只有与值 <code>x</code> 和 <code>y</code> 对应的节点是堂兄弟节点时，才返回 <code>true</code> 。否则，返回 <code>false</code>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：<br />\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png\" style=\"height: 160px; width: 180px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,4], x = 4, y = 3\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 2：<br />\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-02.png\" style=\"height: 160px; width: 201px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,null,4,null,5], x = 5, y = 4\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-03.png\" style=\"height: 160px; width: 156px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,null,4], x = 2, y = 3\n<strong>输出：</strong>false</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉树的节点数介于 <code>2</code> 到 <code>100</code> 之间。</li>\n\t<li>每个节点的值都是唯一的、范围为 <code>1</code> 到 <code>100</code> 的整数。</li>\n</ul>\n\n<p> </p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 994.腐烂的橘子",
        "hardRate": "MEDIUM",
        "passRate": "50.99%",
        "problemsUrl": "https://leetcode.cn/problems/rotting-oranges/",
        "solutionsUrl": "https://leetcode.cn/problems/rotting-oranges/solution",
        "problemsDesc": "<p>在给定的&nbsp;<code>m x n</code>&nbsp;网格<meta charset=\"UTF-8\" />&nbsp;<code>grid</code>&nbsp;中，每个单元格可以有以下三个值之一：</p>\n\n<ul>\n\t<li>值&nbsp;<code>0</code>&nbsp;代表空单元格；</li>\n\t<li>值&nbsp;<code>1</code>&nbsp;代表新鲜橘子；</li>\n\t<li>值&nbsp;<code>2</code>&nbsp;代表腐烂的橘子。</li>\n</ul>\n\n<p>每分钟，腐烂的橘子&nbsp;<strong>周围&nbsp;4 个方向上相邻</strong> 的新鲜橘子都会腐烂。</p>\n\n<p>返回 <em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回&nbsp;<code>-1</code></em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png\" style=\"height: 137px; width: 650px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[2,1,1],[1,1,0],[0,1,1]]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[2,1,1],[0,1,1],[1,0,1]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,2]]\n<strong>输出：</strong>0\n<strong>解释：</strong>因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10</code></li>\n\t<li><code>grid[i][j]</code> 仅为&nbsp;<code>0</code>、<code>1</code>&nbsp;或&nbsp;<code>2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 995.K 连续位的最小翻转次数",
        "hardRate": "HARD",
        "passRate": "53.93%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/solution",
        "problemsDesc": "<p>给定一个二进制数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>\n\n<p><strong>k位翻转</strong> 就是从 <code>nums</code> 中选择一个长度为 <code>k</code> 的 <strong>子数组</strong> ，同时把子数组中的每一个 <code>0</code> 都改成 <code>1</code> ，把子数组中的每一个 <code>1</code> 都改成 <code>0</code> 。</p>\n\n<p>返回数组中不存在 <code>0</code> 所需的最小 <strong>k位翻转</strong> 次数。如果不可能，则返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p><strong>子数组</strong> 是数组的 <strong>连续</strong> 部分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,0], K = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>先翻转 A[0]，然后翻转 A[2]。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,0], K = 2\n<strong>输出：</strong>-1\n<strong>解释：</strong>无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,0,0,1,0,1,1,0], K = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>\n翻转 A[0],A[1],A[2]:&nbsp;A变成 [1,1,1,1,0,1,1,0]\n翻转 A[4],A[5],A[6]:&nbsp;A变成 [1,1,1,1,1,0,0,0]\n翻转 A[5],A[6],A[7]:&nbsp;A变成 [1,1,1,1,1,1,1,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 996.正方形数组的数目",
        "hardRate": "HARD",
        "passRate": "50.37%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-squareful-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-squareful-arrays/solution",
        "problemsDesc": "<p>给定一个非负整数数组&nbsp;<code>A</code>，如果该数组每对相邻元素之和是一个完全平方数，则称这一数组为<em>正方形</em>数组。</p>\n\n<p>返回 A 的正方形排列的数目。两个排列 <code>A1</code> 和 <code>A2</code> 不同的充要条件是存在某个索引 <code>i</code>，使得 A1[i] != A2[i]。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>[1,17,8]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n[1,8,17] 和 [17,8,1] 都是有效的排列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>[2,2,2]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= A.length &lt;= 12</code></li>\n\t<li><code>0 &lt;= A[i] &lt;= 1e9</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 997.找到小镇的法官",
        "hardRate": "EASY",
        "passRate": "51.85%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-town-judge/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-town-judge/solution",
        "problemsDesc": "<p>小镇里有 <code>n</code> 个人，按从 <code>1</code> 到 <code>n</code> 的顺序编号。传言称，这些人中有一个暗地里是小镇法官。</p>\n\n<p>如果小镇法官真的存在，那么：</p>\n\n<ol>\n\t<li>小镇法官不会信任任何人。</li>\n\t<li>每个人（除了小镇法官）都信任这位小镇法官。</li>\n\t<li>只有一个人同时满足属性 <strong>1</strong> 和属性 <strong>2</strong> 。</li>\n</ol>\n\n<p>给你一个数组 <code>trust</code> ，其中 <code>trust[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示编号为 <code>a<sub>i</sub></code> 的人信任编号为 <code>b<sub>i</sub></code> 的人。</p>\n\n<p>如果小镇法官存在并且可以确定他的身份，请返回该法官的编号；否则，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, trust = [[1,2]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, trust = [[1,3],[2,3]]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, trust = [[1,3],[2,3],[3,1]]\n<strong>输出：</strong>-1\n</pre>\n&nbsp;\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= trust.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>trust[i].length == 2</code></li>\n\t<li><code>trust</code> 中的所有<code>trust[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> <strong>互不相同</strong></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 998.最大二叉树 II",
        "hardRate": "MEDIUM",
        "passRate": "68.72%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-binary-tree-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-binary-tree-ii/solution",
        "problemsDesc": "<p><strong>最大树</strong> 定义：一棵树，并满足：其中每个节点的值都大于其子树中的任何其他值。</p>\n\n<p>给你最大树的根节点 <code>root</code> 和一个整数 <code>val</code> 。</p>\n\n<p>就像 <a href=\"https://leetcode.cn/problems/maximum-binary-tree/\" target=\"_blank\">之前的问题</a> 那样，给定的树是利用 <code>Construct(a)</code>&nbsp;例程从列表&nbsp;<code>a</code>（<code>root = Construct(a)</code>）递归地构建的：</p>\n\n<ul>\n\t<li>如果 <code>a</code> 为空，返回&nbsp;<code>null</code> 。</li>\n\t<li>否则，令&nbsp;<code>a[i]</code> 作为 <code>a</code> 的最大元素。创建一个值为&nbsp;<code>a[i]</code>&nbsp;的根节点 <code>root</code> 。</li>\n\t<li><code>root</code>&nbsp;的左子树将被构建为&nbsp;<code>Construct([a[0], a[1], ..., a[i - 1]])</code> 。</li>\n\t<li><code>root</code>&nbsp;的右子树将被构建为&nbsp;<code>Construct([a[i + 1], a[i + 2], ..., a[a.length - 1]])</code> 。</li>\n\t<li>返回&nbsp;<code>root</code> 。</li>\n</ul>\n\n<p>请注意，题目没有直接给出 <code>a</code> ，只是给出一个根节点&nbsp;<code>root = Construct(a)</code> 。</p>\n\n<p>假设 <code>b</code> 是 <code>a</code> 的副本，并在末尾附加值 <code>val</code>。题目数据保证 <code>b</code> 中的值互不相同。</p>\n\n<p>返回&nbsp;<code>Construct(b)</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-1-1.png\" style=\"height: 160px; width: 159px;\" /><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-1-2.png\" style=\"height: 160px; width: 169px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [4,1,3,null,null,2], val = 5\n<strong>输出：</strong>[5,4,null,1,3,null,null,2]\n<strong>解释：</strong>a = [1,4,2,3], b = [1,4,2,3,5]</pre>\n\n<p><strong>示例 2：<br />\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-2-1.png\" style=\"height: 160px; width: 180px;\" /><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-2-2.png\" style=\"height: 160px; width: 214px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [5,2,4,null,1], val = 3\n<strong>输出：</strong>[5,2,4,null,1,null,3]\n<strong>解释：</strong>a = [2,1,5,4], b = [2,1,5,4,3]</pre>\n\n<p><strong>示例 3：<br />\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-3-1.png\" style=\"height: 160px; width: 180px;\" /><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-3-2.png\" style=\"height: 160px; width: 201px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [5,2,3,null,1], val = 4\n<strong>输出：</strong>[5,2,4,null,1,3]\n<strong>解释：</strong>a = [2,1,5,3], b = [2,1,5,3,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[1, 100]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 100</code></li>\n\t<li>树中的所有值 <strong>互不相同</strong></li>\n\t<li><code>1 &lt;= val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 999.可以被一步捕获的棋子数",
        "hardRate": "EASY",
        "passRate": "69.34%",
        "problemsUrl": "https://leetcode.cn/problems/available-captures-for-rook/",
        "solutionsUrl": "https://leetcode.cn/problems/available-captures-for-rook/solution",
        "problemsDesc": "<p>在一个 8 x 8 的棋盘上，有一个白色的车（<code>Rook</code>），用字符 <code>&#39;R&#39;</code> 表示。棋盘上还可能存在空方块，白色的象（<code>Bishop</code>）以及黑色的卒（<code>pawn</code>），分别用字符 <code>&#39;.&#39;</code>，<code>&#39;B&#39;</code> 和 <code>&#39;p&#39;</code> 表示。不难看出，大写字符表示的是白棋，小写字符表示的是黑棋。</p>\n\n<p>车按国际象棋中的规则移动。东，西，南，北四个基本方向任选其一，然后一直向选定的方向移动，直到满足下列四个条件之一：</p>\n\n<ul>\n\t<li>棋手选择主动停下来。</li>\n\t<li>棋子因到达棋盘的边缘而停下。</li>\n\t<li>棋子移动到某一方格来捕获位于该方格上敌方（黑色）的卒，停在该方格内。</li>\n\t<li>车不能进入/越过已经放有其他友方棋子（白色的象）的方格，停在友方棋子前。</li>\n</ul>\n\n<p>你现在可以控制车移动一次，请你统计有多少敌方的卒处于你的捕获范围内（即，可以被一步捕获的棋子数）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_1_improved.PNG\" style=\"height: 305px; width: 300px;\"></p>\n\n<pre><strong>输入：</strong>[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]\n<strong>输出：</strong>3\n<strong>解释：\n</strong>在本例中，车能够捕获所有的卒。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_2_improved.PNG\" style=\"height: 306px; width: 300px;\"></p>\n\n<pre><strong>输入：</strong>[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;R&quot;,&quot;B&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]\n<strong>输出：</strong>0\n<strong>解释：\n</strong>象阻止了车捕获任何卒。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_3_improved.PNG\" style=\"height: 305px; width: 300px;\"></p>\n\n<pre><strong>输入：</strong>[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]\n<strong>输出：</strong>3\n<strong>解释： </strong>\n车可以捕获位置 b5，d6 和 f5 的卒。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>board.length == board[i].length == 8</code></li>\n\t<li><code>board[i][j]</code> 可以是&nbsp;<code>&#39;R&#39;</code>，<code>&#39;.&#39;</code>，<code>&#39;B&#39;</code>&nbsp;或&nbsp;<code>&#39;p&#39;</code></li>\n\t<li>只有一个格子上存在&nbsp;<code>board[i][j] == &#39;R&#39;</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1000.合并石头的最低成本",
        "hardRate": "HARD",
        "passRate": "53.61%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-merge-stones/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-merge-stones/solution",
        "problemsDesc": "<p>有 <code>n</code> 堆石头排成一排，第 <code>i</code> 堆中有&nbsp;<code>stones[i]</code>&nbsp;块石头。</p>\n\n<p>每次 <strong>移动</strong> 需要将 <strong>连续的</strong> <code>k</code> 堆石头合并为一堆，而这次移动的成本为这 <code>k</code> 堆中石头的总数。</p>\n\n<p>返回把所有石头合并成一堆的最低成本。如果无法合并成一堆，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [3,2,4,1], K = 2\n<strong>输出：</strong>20\n<strong>解释：</strong>\n从 [3, 2, 4, 1] 开始。\n合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。\n合并 [4, 1]，成本为 5，剩下 [5, 5]。\n合并 [5, 5]，成本为 10，剩下 [10]。\n总成本 20，这是可能的最小值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [3,2,4,1], K = 3\n<strong>输出：</strong>-1\n<strong>解释：</strong>任何合并操作后，都会剩下 2 堆，我们无法再进行合并。所以这项任务是不可能完成的。.\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [3,5,1,2,6], K = 3\n<strong>输出：</strong>25\n<strong>解释：</strong>\n从 [3, 5, 1, 2, 6] 开始。\n合并 [5, 1, 2]，成本为 8，剩下 [3, 8, 6]。\n合并 [3, 8, 6]，成本为 17，剩下 [17]。\n总成本 25，这是可能的最小值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == stones.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n\t<li><code>1 &lt;= stones[i] &lt;= 100</code></li>\n\t<li><code>2 &lt;= k &lt;= 30</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1001.网格照明",
        "hardRate": "HARD",
        "passRate": "44.86%",
        "problemsUrl": "https://leetcode.cn/problems/grid-illumination/",
        "solutionsUrl": "https://leetcode.cn/problems/grid-illumination/solution",
        "problemsDesc": "<p>在大小为 <code>n x n</code> 的网格 <code>grid</code> 上，每个单元格都有一盏灯，最初灯都处于 <strong>关闭</strong> 状态。</p>\n\n<p>给你一个由灯的位置组成的二维数组&nbsp;<code>lamps</code> ，其中 <code>lamps[i] = [row<sub>i</sub>, col<sub>i</sub>]</code> 表示 <strong>打开</strong> 位于 <code>grid[row<sub>i</sub>][col<sub>i</sub>]</code> 的灯。即便同一盏灯可能在 <code>lamps</code> 中多次列出，不会影响这盏灯处于 <strong>打开</strong> 状态。</p>\n\n<p>当一盏灯处于打开状态，它将会照亮 <strong>自身所在单元格</strong> 以及同一 <strong>行</strong> 、同一 <strong>列</strong> 和两条 <strong>对角线</strong> 上的 <strong>所有其他单元格</strong> 。</p>\n\n<p>另给你一个二维数组 <code>queries</code> ，其中 <code>queries[j] = [row<sub>j</sub>, col<sub>j</sub>]</code> 。对于第 <code>j</code> 个查询，如果单元格 <code>[row<sub>j</sub>, col<sub>j</sub>]</code> 是被照亮的，则查询结果为 <code>1</code> ，否则为 <code>0</code> 。在第 <code>j</code> 次查询之后 [按照查询的顺序] ，<strong>关闭</strong> 位于单元格 <code>grid[row<sub>j</sub>][col<sub>j</sub>]</code> 上及相邻 8 个方向上（与单元格 <code>grid[row<sub>i</sub>][col<sub>i</sub>]</code> 共享角或边）的任何灯。</p>\n\n<p>返回一个整数数组 <code>ans</code> 作为答案， <code>ans[j]</code> 应等于第 <code>j</code> 次查询&nbsp;<code>queries[j]</code>&nbsp;的结果，<code>1</code> 表示照亮，<code>0</code> 表示未照亮。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/19/illu_1.jpg\" style=\"height: 209px; width: 750px;\" />\n<pre>\n<strong>输入：</strong>n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]\n<strong>输出：</strong>[1,0]\n<strong>解释：</strong>最初所有灯都是关闭的。在执行查询之前，打开位于 [0, 0] 和 [4, 4] 的灯。第 0&nbsp;次查询检查 grid[1][1] 是否被照亮（蓝色方框）。该单元格被照亮，所以 ans[0] = 1 。然后，关闭红色方框中的所有灯。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/19/illu_step1.jpg\" style=\"height: 218px; width: 500px;\" />\n第 1&nbsp;次查询检查 grid[1][0] 是否被照亮（蓝色方框）。该单元格没有被照亮，所以 ans[1] = 0 。然后，关闭红色矩形中的所有灯。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/19/illu_step2.jpg\" style=\"height: 219px; width: 500px;\" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,1]]\n<strong>输出：</strong>[1,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, lamps = [[0,0],[0,4]], queries = [[0,4],[0,1],[1,4]]\n<strong>输出：</strong>[1,1,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= lamps.length &lt;= 20000</code></li>\n\t<li><code>0 &lt;= queries.length &lt;= 20000</code></li>\n\t<li><code>lamps[i].length == 2</code></li>\n\t<li><code>0 &lt;= row<sub>i</sub>, col<sub>i</sub> &lt; n</code></li>\n\t<li><code>queries[j].length == 2</code></li>\n\t<li><code>0 &lt;= row<sub>j</sub>, col<sub>j</sub> &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1002.查找共用字符",
        "hardRate": "EASY",
        "passRate": "70.61%",
        "problemsUrl": "https://leetcode.cn/problems/find-common-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/find-common-characters/solution",
        "problemsDesc": "给你一个字符串数组 <code>words</code> ，请你找出所有在 <code>words</code> 的每个字符串中都出现的共用字符（ <strong>包括重复字符</strong>），并以数组形式返回。你可以按 <strong>任意顺序</strong> 返回答案。\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"bella\",\"label\",\"roller\"]\n<strong>输出：</strong>[\"e\",\"l\",\"l\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"cool\",\"lock\",\"cook\"]\n<strong>输出：</strong>[\"c\",\"o\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><code>words[i]</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1003.检查替换后的词是否有效",
        "hardRate": "MEDIUM",
        "passRate": "63.64%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-word-is-valid-after-substitutions/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-word-is-valid-after-substitutions/solution",
        "problemsDesc": "给你一个字符串 <code>s</code> ，请你判断它是否 <strong>有效</strong> 。\n<p>字符串 <code>s</code> <strong>有效</strong> 需要满足：假设开始有一个空字符串 <code>t = \"\"</code> ，你可以执行 <strong>任意次</strong> 下述操作将<strong> </strong><code>t</code><strong> 转换为 </strong><code>s</code> ：</p>\n\n<ul>\n\t<li>将字符串 <code>\"abc\"</code> 插入到 <code>t</code> 中的任意位置。形式上，<code>t</code> 变为 <code>t<sub>left</sub> + \"abc\" + t<sub>right</sub></code>，其中 <code>t == t<sub>left</sub> + t<sub>right</sub></code> 。注意，<code>t<sub>left</sub></code> 和 <code>t<sub>right</sub></code> 可能为 <strong>空</strong> 。</li>\n</ul>\n\n<p>如果字符串 <code>s</code> 有效，则返回 <code>true</code>；否则，返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aabcbc\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\n\"\" -&gt; \"<strong>abc</strong>\" -&gt; \"a<strong>abc</strong>bc\"\n因此，\"aabcbc\" 有效。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcabcababcc\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\n\"\" -&gt; \"<strong>abc</strong>\" -&gt; \"abc<strong>abc</strong>\" -&gt; \"abcabc<strong>abc</strong>\" -&gt; \"abcabcab<strong>abc</strong>c\"\n因此，\"abcabcababcc\" 有效。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abccba\"\n<strong>输出：</strong>false\n<strong>解释：</strong>执行操作无法得到 \"abccba\" 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> 由字母 <code>'a'</code>、<code>'b'</code> 和 <code>'c'</code> 组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1004.最大连续1的个数 III",
        "hardRate": "MEDIUM",
        "passRate": "59.49%",
        "problemsUrl": "https://leetcode.cn/problems/max-consecutive-ones-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/max-consecutive-ones-iii/solution",
        "problemsDesc": "<p>给定一个二进制数组&nbsp;<code>nums</code>&nbsp;和一个整数 <code>k</code>，如果可以翻转最多 <code>k</code> 个 <code>0</code> ，则返回 <em>数组中连续 <code>1</code> 的最大个数</em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2\n<strong>输出：</strong>6\n<strong>解释：</strong>[1,1,1,0,0,<strong>1</strong>,1,1,1,1,<strong>1</strong>]\n粗体数字从 0 翻转到 1，最长的子数组长度为 6。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3\n<strong>输出：</strong>10\n<strong>解释：</strong>[0,0,1,1,<strong>1</strong>,<strong>1</strong>,1,1,1,<strong>1</strong>,1,1,0,0,0,1,1,1,1]\n粗体数字从 0 翻转到 1，最长的子数组长度为 10。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code>&nbsp;不是&nbsp;<code>0</code>&nbsp;就是&nbsp;<code>1</code></li>\n\t<li><code>0 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1005.K 次取反后最大化的数组和",
        "hardRate": "EASY",
        "passRate": "50.82%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，按以下方法修改该数组：</p>\n\n<ul>\n\t<li>选择某个下标 <code>i</code>&nbsp;并将 <code>nums[i]</code> 替换为 <code>-nums[i]</code> 。</li>\n</ul>\n\n<p>重复这个过程恰好 <code>k</code> 次。可以多次选择同一个下标 <code>i</code> 。</p>\n\n<p>以这种方式修改数组后，返回数组 <strong>可能的最大和</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,2,3], k = 1\n<strong>输出：</strong>5\n<strong>解释：</strong>选择下标 1 ，nums 变为 [4,-2,3] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,-1,0,2], k = 3\n<strong>输出：</strong>6\n<strong>解释：</strong>选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,-3,-1,5,-4], k = 2\n<strong>输出：</strong>13\n<strong>解释：</strong>选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1006.笨阶乘",
        "hardRate": "MEDIUM",
        "passRate": "62.73%",
        "problemsUrl": "https://leetcode.cn/problems/clumsy-factorial/",
        "solutionsUrl": "https://leetcode.cn/problems/clumsy-factorial/solution",
        "problemsDesc": "<p>通常，正整数 <code>n</code> 的阶乘是所有小于或等于 <code>n</code> 的正整数的乘积。例如，<code>factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1</code>。</p>\n\n<p>相反，我们设计了一个笨阶乘 <code>clumsy</code>：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。</p>\n\n<p>例如，<code>clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1</code>。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。</p>\n\n<p>另外，我们使用的除法是地板除法（<em>floor division</em>），所以&nbsp;<code>10 * 9 / 8</code>&nbsp;等于&nbsp;<code>11</code>。这保证结果是一个整数。</p>\n\n<p>实现上面定义的笨函数：给定一个整数 <code>N</code>，它返回 <code>N</code> 的笨阶乘。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>4\n<strong>输出：</strong>7\n<strong>解释：</strong>7 = 4 * 3 / 2 + 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>10\n<strong>输出：</strong>12\n<strong>解释：</strong>12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= N &lt;= 10000</code></li>\n\t<li><code>-2^31 &lt;= answer &lt;= 2^31 - 1</code>&nbsp; （答案保证符合 32 位整数。）</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1007.行相等的最少多米诺旋转",
        "hardRate": "MEDIUM",
        "passRate": "47.80%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-domino-rotations-for-equal-row/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-domino-rotations-for-equal-row/solution",
        "problemsDesc": "<p>在一排多米诺骨牌中，<code>tops[i]</code> 和 <code>bottoms[i]</code>&nbsp;分别代表第 <code>i</code> 个多米诺骨牌的上半部分和下半部分。（一个多米诺是两个从 1 到 6 的数字同列平铺形成的&nbsp;—— 该平铺的每一半上都有一个数字。）</p>\n\n<p>我们可以旋转第&nbsp;<code>i</code>&nbsp;张多米诺，使得 <code>tops[i]</code> 和 <code>bottoms[i]</code>&nbsp;的值交换。</p>\n\n<p>返回能使 <code>tops</code> 中所有值或者 <code>bottoms</code> 中所有值都相同的最小旋转次数。</p>\n\n<p>如果无法做到，返回&nbsp;<code>-1</code>.</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/14/domino.png\" style=\"height: 300px; width: 421px;\" />\n<pre>\n<strong>输入：</strong>tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2]\n<strong>输出：</strong>2\n<strong>解释：</strong> \n图一表示：在我们旋转之前， tops 和 bottoms 给出的多米诺牌。 \n如果我们旋转第二个和第四个多米诺骨牌，我们可以使上面一行中的每个值都等于 2，如图二所示。 \n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>tops = [3,5,1,2,3], bottoms = [3,6,3,3,4]\n<strong>输出：</strong>-1\n<strong>解释：</strong> 在这种情况下，不可能旋转多米诺牌使一行的值相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= tops.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>bottoms.length == tops.length</code></li>\n\t<li><code>1 &lt;= tops[i], bottoms[i] &lt;= 6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1008.前序遍历构造二叉搜索树",
        "hardRate": "MEDIUM",
        "passRate": "71.74%",
        "problemsUrl": "https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/solution",
        "problemsDesc": "<p>给定一个整数数组，它表示BST(即 <strong>二叉搜索树</strong> )的 <strong>先</strong><strong>序遍历</strong> ，构造树并返回其根。</p>\n\n<p><strong>保证</strong> 对于给定的测试用例，总是有可能找到具有给定需求的二叉搜索树。</p>\n\n<p><strong>二叉搜索树</strong> 是一棵二叉树，其中每个节点，&nbsp;<code>Node.left</code>&nbsp;的任何后代的值 <strong>严格小于</strong> <code>Node.val</code>&nbsp;,&nbsp;<code>Node.right</code>&nbsp;的任何后代的值 <strong>严格大于</strong> <code>Node.val</code>。</p>\n\n<p>二叉树的 <strong>前序遍历</strong> 首先显示节点的值，然后遍历<code>Node.left</code>，最后遍历<code>Node.right</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2019/03/06/1266.png\" /></p>\n\n<pre>\n<strong>输入：</strong>preorder = [8,5,1,7,10,12]\n<strong>输出：</strong>[8,5,10,1,7,null,12]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> preorder = [1,3]\n<strong>输出:</strong> [1,null,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= preorder.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= preorder[i]&nbsp;&lt;= 10^8</code></li>\n\t<li><code>preorder</code> 中的值 <strong>互不相同</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1009.十进制整数的反码",
        "hardRate": "EASY",
        "passRate": "58.63%",
        "problemsUrl": "https://leetcode.cn/problems/complement-of-base-10-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/complement-of-base-10-integer/solution",
        "problemsDesc": "<p>每个非负整数&nbsp;<code>N</code>&nbsp;都有其二进制表示。例如，&nbsp;<code>5</code>&nbsp;可以被表示为二进制&nbsp;<code>&quot;101&quot;</code>，<code>11</code> 可以用二进制&nbsp;<code>&quot;1011&quot;</code>&nbsp;表示，依此类推。注意，除&nbsp;<code>N = 0</code>&nbsp;外，任何二进制表示中都不含前导零。</p>\n\n<p>二进制的反码表示是将每个&nbsp;<code>1</code>&nbsp;改为&nbsp;<code>0</code>&nbsp;且每个&nbsp;<code>0</code>&nbsp;变为&nbsp;<code>1</code>。例如，二进制数&nbsp;<code>&quot;101&quot;</code>&nbsp;的二进制反码为&nbsp;<code>&quot;010&quot;</code>。</p>\n\n<p>给你一个十进制数&nbsp;<code>N</code>，请你返回其二进制表示的反码所对应的十进制整数。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>5\n<strong>输出：</strong>2\n<strong>解释：</strong>5 的二进制表示为 &quot;101&quot;，其二进制反码为 &quot;010&quot;，也就是十进制中的 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>7\n<strong>输出：</strong>0\n<strong>解释：</strong>7 的二进制表示为 &quot;111&quot;，其二进制反码为 &quot;000&quot;，也就是十进制中的 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>10\n<strong>输出：</strong>5\n<strong>解释：</strong>10 的二进制表示为 &quot;1010&quot;，其二进制反码为 &quot;0101&quot;，也就是十进制中的 5 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>0 &lt;= N &lt; 10^9</code></li>\n\t<li>本题与 476：<a href=\"https://leetcode-cn.com/problems/number-complement/\">https://leetcode-cn.com/problems/number-complement/</a> 相同</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1010.总持续时间可被 60 整除的歌曲",
        "hardRate": "MEDIUM",
        "passRate": "49.62%",
        "problemsUrl": "https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60/",
        "solutionsUrl": "https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60/solution",
        "problemsDesc": "<p>在歌曲列表中，第 <code>i</code> 首歌曲的持续时间为 <code>time[i]</code> 秒。</p>\n\n<p>返回其总持续时间（以秒为单位）可被 <code>60</code> 整除的歌曲对的数量。形式上，我们希望下标数字 <code>i</code> 和 <code>j</code> 满足&nbsp; <code>i &lt; j</code> 且有&nbsp;<code>(time[i] + time[j]) % 60 == 0</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>time = [30,20,150,100,40]\n<strong>输出：</strong>3\n<strong>解释：</strong>这三对的总持续时间可被 60 整除：\n(time[0] = 30, time[2] = 150): 总持续时间 180\n(time[1] = 20, time[3] = 100): 总持续时间 120\n(time[1] = 20, time[4] = 40): 总持续时间 60\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>time = [60,60,60]\n<strong>输出：</strong>3\n<strong>解释：</strong>所有三对的总持续时间都是 120，可以被 60 整除。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= time.length &lt;= 6 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= time[i] &lt;= 500</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1011.在 D 天内送达包裹的能力",
        "hardRate": "MEDIUM",
        "passRate": "62.03%",
        "problemsUrl": "https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/",
        "solutionsUrl": "https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/solution",
        "problemsDesc": "<p>传送带上的包裹必须在 <code>days</code> 天内从一个港口运送到另一个港口。</p>\n\n<p>传送带上的第 <code>i</code>&nbsp;个包裹的重量为&nbsp;<code>weights[i]</code>。每一天，我们都会按给出重量（<code>weights</code>）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p>\n\n<p>返回能在 <code>days</code> 天内将传送带上的所有包裹送达的船的最低运载能力。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>weights = [1,2,3,4,5,6,7,8,9,10], days = 5\n<strong>输出：</strong>15\n<strong>解释：</strong>\n船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：\n第 1 天：1, 2, 3, 4, 5\n第 2 天：6, 7\n第 3 天：8\n第 4 天：9\n第 5 天：10\n\n请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>weights = [3,2,2,4,1,4], days = 3\n<strong>输出：</strong>6\n<strong>解释：</strong>\n船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：\n第 1 天：3, 2\n第 2 天：2, 4\n第 3 天：1, 4\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>weights = [1,2,3,1,1], days = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>\n第 1 天：1\n第 2 天：2\n第 3 天：3\n第 4 天：1, 1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= days &lt;= weights.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= weights[i] &lt;= 500</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1012.至少有 1 位重复的数字",
        "hardRate": "HARD",
        "passRate": "52.45%",
        "problemsUrl": "https://leetcode.cn/problems/numbers-with-repeated-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/numbers-with-repeated-digits/solution",
        "problemsDesc": "<p>给定正整数&nbsp;<code>n</code>，返回在<em>&nbsp;</em><code>[1, n]</code><em>&nbsp;</em>范围内具有 <strong>至少 1 位</strong> 重复数字的正整数的个数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 20\n<strong>输出：</strong>1\n<strong>解释：</strong>具有至少 1 位重复数字的正数（&lt;= 20）只有 11 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 100\n<strong>输出：</strong>10\n<strong>解释：</strong>具有至少 1 位重复数字的正数（&lt;= 100）有 11，22，33，44，55，66，77，88，99 和 100 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1000\n<strong>输出：</strong>262\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1013.将数组分成和相等的三个部分",
        "hardRate": "EASY",
        "passRate": "38.53%",
        "problemsUrl": "https://leetcode.cn/problems/partition-array-into-three-parts-with-equal-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-array-into-three-parts-with-equal-sum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code>，只有可以将其划分为三个和相等的 <strong>非空</strong> 部分时才返回 <code>true</code>，否则返回 <code>false</code>。</p>\n\n<p>形式上，如果可以找出索引 <code>i + 1 < j</code> 且满足 <code>(arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])</code> 就可以将数组三等分。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,2,1,-6,6,-7,9,1,2,0,1]\n<strong>输出：</strong>true\n<strong>解释：</strong>0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [0,2,1,-6,6,7,9,-1,2,0,1]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [3,3,6,5,-2,2,5,1,-9,4]\n<strong>输出：</strong>true\n<strong>解释：</strong>3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 <= arr.length <= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= arr[i] <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1014.最佳观光组合",
        "hardRate": "MEDIUM",
        "passRate": "57.12%",
        "problemsUrl": "https://leetcode.cn/problems/best-sightseeing-pair/",
        "solutionsUrl": "https://leetcode.cn/problems/best-sightseeing-pair/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>values</code>，其中 <code>values[i]</code> 表示第 <code>i</code> 个观光景点的评分，并且两个景点 <code>i</code> 和 <code>j</code> 之间的 <strong>距离</strong> 为 <code>j - i</code>。</p>\n\n<p>一对景点（<code>i < j</code>）组成的观光组合的得分为 <code>values[i] + values[j] + i - j</code> ，也就是景点的评分之和<strong> 减去 </strong>它们两者之间的距离。</p>\n\n<p>返回一对观光景点能取得的最高分。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>values = [8,1,5,2,6]\n<strong>输出：</strong>11\n<strong>解释：</strong>i = 0, j = 2, values[i] + values[j] + i - j = 8 + 5 + 0 - 2 = 11\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>values = [1,2]\n<strong>输出：</strong>2\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= values.length <= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= values[i] <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1015.可被 K 整除的最小整数",
        "hardRate": "MEDIUM",
        "passRate": "46.52%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-integer-divisible-by-k/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-integer-divisible-by-k/solution",
        "problemsDesc": "<p>给定正整数 <code>k</code>&nbsp;，你需要找出可以被 <code>k</code>&nbsp;整除的、仅包含数字 <code><strong>1</strong></code> 的最 <strong>小</strong> 正整数 <code>n</code>&nbsp;的长度。</p>\n\n<p>返回 <code>n</code>&nbsp;的长度。如果不存在这样的 <code>n</code>&nbsp;，就返回-1。</p>\n\n<p><strong>注意：</strong> <code>n</code> 可能不符合 64 位带符号整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>最小的答案是 n = 1，其长度为 1。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 2\n<strong>输出：</strong>-1\n<strong>解释：</strong>不存在可被 2 整除的正整数 n 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>最小的答案是 n = 111，其长度为 3。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1016.子串能表示从 1 到 N 数字的二进制串",
        "hardRate": "MEDIUM",
        "passRate": "63.25%",
        "problemsUrl": "https://leetcode.cn/problems/binary-string-with-substrings-representing-1-to-n/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-string-with-substrings-representing-1-to-n/solution",
        "problemsDesc": "<p>给定一个二进制字符串&nbsp;<code>s</code>&nbsp;和一个正整数&nbsp;<code>n</code>，如果对于&nbsp;<code>[1, n]</code>&nbsp;范围内的每个整数，<em>其二进制表示都是&nbsp;<code>s</code> 的 <strong>子字符串</strong> ，就返回 <code>true</code>，否则返回 <code>false</code>&nbsp;</em>。</p>\n\n<p><strong>子字符串</strong>&nbsp;是字符串中连续的字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0110\", n = 3\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0110\", n = 4\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i]</code>&nbsp;不是&nbsp;<code>'0'</code>&nbsp;就是&nbsp;<code>'1'</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1017.负二进制转换",
        "hardRate": "MEDIUM",
        "passRate": "65.01%",
        "problemsUrl": "https://leetcode.cn/problems/convert-to-base-2/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-to-base-2/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，以二进制字符串的形式返回该整数的 <strong>负二进制（<code>base -2</code>）</strong>表示。</p>\n\n<p><strong>注意，</strong>除非字符串就是&nbsp;<code>\"0\"</code>，否则返回的字符串中不能含有前导零。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>\"110\"\n<strong>解释：</strong>(-2)<sup>2</sup> + (-2)<sup>1</sup> = 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>\"111\"\n<strong>解释：</strong>(-2)<sup>2</sup> + (-2)<sup>1</sup> + (-2)<sup>0</sup> = 3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>\"100\"\n<strong>解释：</strong>(-2)<sup>2</sup> = 4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1018.可被 5 整除的二进制前缀",
        "hardRate": "EASY",
        "passRate": "50.61%",
        "problemsUrl": "https://leetcode.cn/problems/binary-prefix-divisible-by-5/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-prefix-divisible-by-5/solution",
        "problemsDesc": "<p>给定一个二进制数组 <code>nums</code> (&nbsp;<strong>索引从0开始&nbsp;</strong>)。</p>\n\n<p>我们将<code>x<sub>i</sub></code>&nbsp;定义为其二进制表示形式为子数组&nbsp;<code>nums[0..i]</code>&nbsp;(从最高有效位到最低有效位)。</p>\n\n<ul>\n\t<li>例如，如果 <code>nums =[1,0,1]</code> ，那么&nbsp;<code>x<sub>0</sub>&nbsp;= 1</code>,&nbsp;<code>x<sub>1</sub>&nbsp;= 2</code>, 和&nbsp;<code>x<sub>2</sub>&nbsp;= 5</code>。</li>\n</ul>\n\n<p>返回布尔值列表&nbsp;<code>answer</code>，只有当&nbsp;<code>x<sub>i</sub></code><em>&nbsp;</em>可以被 <code>5</code>&nbsp;整除时，答案&nbsp;<code>answer[i]</code> 为&nbsp;<code>true</code>，否则为 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,1]\n<strong>输出：</strong>[true,false,false]\n<strong>解释：</strong>\n输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1]\n<strong>输出：</strong>[false,false,false]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code><sup>&nbsp;</sup></li>\n\t<li><code>nums[i]</code>&nbsp;仅为&nbsp;<code>0</code>&nbsp;或&nbsp;<code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1019.链表中的下一个更大节点",
        "hardRate": "MEDIUM",
        "passRate": "64.25%",
        "problemsUrl": "https://leetcode.cn/problems/next-greater-node-in-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/next-greater-node-in-linked-list/solution",
        "problemsDesc": "<p>给定一个长度为&nbsp;<code>n</code>&nbsp;的链表&nbsp;<code>head</code></p>\n\n<p>对于列表中的每个节点，查找下一个 <strong>更大节点</strong> 的值。也就是说，对于每个节点，找到它旁边的第一个节点的值，这个节点的值 <strong>严格大于</strong> 它的值。</p>\n\n<p>返回一个整数数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 <code>i</code> 个节点( <strong>从1开始</strong> )的下一个更大的节点的值。如果第 <code>i</code> 个节点没有下一个更大的节点，设置&nbsp;<code>answer[i] = 0</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/05/linkedlistnext1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [2,1,5]\n<strong>输出：</strong>[5,5,0]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/05/linkedlistnext2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [2,7,4,3,5]\n<strong>输出：</strong>[7,0,5,5,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点数为&nbsp;<code>n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1020.飞地的数量",
        "hardRate": "MEDIUM",
        "passRate": "62.34%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-enclaves/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-enclaves/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> ，其中 <code>0</code> 表示一个海洋单元格、<code>1</code> 表示一个陆地单元格。</p>\n\n<p>一次 <strong>移动</strong> 是指从一个陆地单元格走到另一个相邻（<strong>上、下、左、右</strong>）的陆地单元格或跨过 <code>grid</code> 的边界。</p>\n\n<p>返回网格中<strong> 无法 </strong>在任意次数的移动中离开网格边界的陆地单元格的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/enclaves1.jpg\" style=\"height: 200px; width: 200px;\" />\n<pre>\n<strong>输入：</strong>grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]\n<strong>输出：</strong>3\n<strong>解释：</strong>有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/enclaves2.jpg\" style=\"height: 200px; width: 200px;\" />\n<pre>\n<strong>输入：</strong>grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]\n<strong>输出：</strong>0\n<strong>解释：</strong>所有 1 都在边界上或可以到达边界。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>grid[i][j]</code> 的值为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1021.删除最外层的括号",
        "hardRate": "EASY",
        "passRate": "81.39%",
        "problemsUrl": "https://leetcode.cn/problems/remove-outermost-parentheses/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-outermost-parentheses/solution",
        "problemsDesc": "<p>有效括号字符串为空 <code>\"\"</code>、<code>\"(\" + A + \")\"</code> 或 <code>A + B</code> ，其中 <code>A</code> 和 <code>B</code> 都是有效的括号字符串，<code>+</code> 代表字符串的连接。</p>\n\n<ul>\n\t<li>例如，<code>\"\"</code>，<code>\"()\"</code>，<code>\"(())()\"</code> 和 <code>\"(()(()))\"</code> 都是有效的括号字符串。</li>\n</ul>\n\n<p>如果有效字符串 <code>s</code> 非空，且不存在将其拆分为 <code>s = A + B</code> 的方法，我们称其为<strong>原语（primitive）</strong>，其中 <code>A</code> 和 <code>B</code> 都是非空有效括号字符串。</p>\n\n<p>给出一个非空有效字符串 <code>s</code>，考虑将其进行原语化分解，使得：<code>s = P_1 + P_2 + ... + P_k</code>，其中 <code>P_i</code> 是有效括号字符串原语。</p>\n\n<p>对 <code>s</code> 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 <code>s</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(()())(())\"\n<strong>输出：</strong>\"()()()\"\n<strong>解释：\n</strong>输入字符串为 \"(()())(())\"，原语化分解得到 \"(()())\" + \"(())\"，\n删除每个部分中的最外层括号后得到 \"()()\" + \"()\" = \"()()()\"。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(()())(())(()(()))\"\n<strong>输出：</strong>\"()()()()(())\"\n<strong>解释：</strong>\n输入字符串为 \"(()())(())(()(()))\"，原语化分解得到 \"(()())\" + \"(())\" + \"(()(()))\"，\n删除每个部分中的最外层括号后得到 \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\"。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"()()\"\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>\n输入字符串为 \"()()\"，原语化分解得到 \"()\" + \"()\"，\n删除每个部分中的最外层括号后得到 \"\" + \"\" = \"\"。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 为 <code>'('</code> 或 <code>')'</code></li>\n\t<li><code>s</code> 是一个有效括号字符串</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1022.从根到叶的二进制数之和",
        "hardRate": "EASY",
        "passRate": "74.77%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/solution",
        "problemsDesc": "<p>给出一棵二叉树，其上每个结点的值都是&nbsp;<code>0</code>&nbsp;或&nbsp;<code>1</code>&nbsp;。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。</p>\n\n<ul>\n\t<li>例如，如果路径为&nbsp;<code>0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1</code>，那么它表示二进制数&nbsp;<code>01101</code>，也就是&nbsp;<code>13</code>&nbsp;。</li>\n</ul>\n\n<p>对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。</p>\n\n<p>返回这些数字之和。题目数据保证答案是一个 <strong>32 位 </strong>整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/04/04/sum-of-root-to-leaf-binary-numbers.png\" />\n<pre>\n<strong>输入：</strong>root = [1,0,1,0,1,0,1]\n<strong>输出：</strong>22\n<strong>解释：</strong>(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [0]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数在&nbsp;<code>[1, 1000]</code>&nbsp;范围内</li>\n\t<li><code>Node.val</code>&nbsp;仅为 <code>0</code> 或 <code>1</code>&nbsp;</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1023.驼峰式匹配",
        "hardRate": "MEDIUM",
        "passRate": "64.56%",
        "problemsUrl": "https://leetcode.cn/problems/camelcase-matching/",
        "solutionsUrl": "https://leetcode.cn/problems/camelcase-matching/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>queries</code>，和一个表示模式的字符串&nbsp;<code>pattern</code>，请你返回一个布尔数组 <code>answer</code> 。只有在待查项&nbsp;<code>queries[i]</code> 与模式串&nbsp;<code>pattern</code> 匹配时，&nbsp;<code>answer[i]</code>&nbsp;才为 <code>true</code>，否则为 <code>false</code>。</p>\n\n<p>如果可以将<strong>小写字母</strong>插入模式串&nbsp;<code>pattern</code>&nbsp;得到待查询项&nbsp;<code>query</code>，那么待查询项与给定模式串匹配。可以在任何位置插入每个字符，也可以不插入字符。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>queries = [\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"], pattern = \"FB\"\n<strong>输出：</strong>[true,false,true,true,false]\n<strong>示例：</strong>\n\"FooBar\" 可以这样生成：\"F\" + \"oo\" + \"B\" + \"ar\"。\n\"FootBall\" 可以这样生成：\"F\" + \"oot\" + \"B\" + \"all\".\n\"FrameBuffer\" 可以这样生成：\"F\" + \"rame\" + \"B\" + \"uffer\".</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>queries = [\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"], pattern = \"FoBa\"\n<strong>输出：</strong>[true,false,true,false,false]\n<strong>解释：</strong>\n\"FooBar\" 可以这样生成：\"Fo\" + \"o\" + \"Ba\" + \"r\".\n\"FootBall\" 可以这样生成：\"Fo\" + \"ot\" + \"Ba\" + \"ll\".\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>queries = [\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"], pattern = \"FoBaT\"\n<strong>输出：</strong>[false,true,false,false,false]\n<strong>解释： </strong>\n\"FooBarTest\" 可以这样生成：\"Fo\" + \"o\" + \"Ba\" + \"r\" + \"T\" + \"est\".\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pattern.length, queries.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= queries[i].length &lt;= 100</code></li>\n\t<li><code>queries[i]</code> 和 <code>pattern</code> 由英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1024.视频拼接",
        "hardRate": "MEDIUM",
        "passRate": "53.11%",
        "problemsUrl": "https://leetcode.cn/problems/video-stitching/",
        "solutionsUrl": "https://leetcode.cn/problems/video-stitching/solution",
        "problemsDesc": "<p>你将会获得一系列视频片段，这些片段来自于一项持续时长为&nbsp;<code>time</code>&nbsp;秒的体育赛事。这些片段可能有所重叠，也可能长度不一。</p>\n\n<p>使用数组&nbsp;<code>clips</code> 描述所有的视频片段，其中 <code>clips[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 表示：某个视频片段开始于&nbsp;<code>start<sub>i</sub></code>&nbsp;并于&nbsp;<code>end<sub>i</sub></code>&nbsp;结束。</p>\n\n<p>甚至可以对这些片段自由地再剪辑：</p>\n\n<ul>\n\t<li>例如，片段&nbsp;<code>[0, 7]</code>&nbsp;可以剪切成&nbsp;<code>[0, 1] +&nbsp;[1, 3] + [3, 7]</code>&nbsp;三部分。</li>\n</ul>\n\n<p>我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（<code>[0, time]</code>）。返回所需片段的最小数目，如果无法完成该任务，则返回&nbsp;<code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10\n<strong>输出：</strong>3\n<strong>解释：</strong>\n选中 [0,2], [8,10], [1,9] 这三个片段。\n然后，按下面的方案重制比赛片段：\n将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。\n现在手上的片段为 [0,2] + [2,8] + [8,10]，而这些覆盖了整场比赛 [0, 10]。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>clips = [[0,1],[1,2]], time = 5\n<strong>输出：</strong>-1\n<strong>解释：</strong>\n无法只用 [0,1] 和 [1,2] 覆盖 [0,5] 的整个过程。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], time = 9\n<strong>输出：</strong>3\n<strong>解释： </strong>\n选取片段 [0,4], [4,7] 和 [6,9] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= clips.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 100</code></li>\n\t<li><code>1 &lt;= time &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1025.除数博弈",
        "hardRate": "EASY",
        "passRate": "70.65%",
        "problemsUrl": "https://leetcode.cn/problems/divisor-game/",
        "solutionsUrl": "https://leetcode.cn/problems/divisor-game/solution",
        "problemsDesc": "<p>爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。</p>\n\n<p>最初，黑板上有一个数字&nbsp;<code>n</code>&nbsp;。在每个玩家的回合，玩家需要执行以下操作：</p>\n\n<ul>\n\t<li>选出任一&nbsp;<code>x</code>，满足&nbsp;<code>0 &lt; x &lt; n</code>&nbsp;且&nbsp;<code>n % x == 0</code>&nbsp;。</li>\n\t<li>用 <code>n - x</code>&nbsp;替换黑板上的数字&nbsp;<code>n</code> 。</li>\n</ul>\n\n<p>如果玩家无法执行这些操作，就会输掉游戏。</p>\n\n<p><em>只有在爱丽丝在游戏中取得胜利时才返回&nbsp;<code>true</code>&nbsp;。假设两个玩家都以最佳状态参与游戏。</em></p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>爱丽丝选择 1，鲍勃无法进行操作。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>false\n<strong>解释：</strong>爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1026.节点与其祖先之间的最大差值",
        "hardRate": "MEDIUM",
        "passRate": "75.17%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/solution",
        "problemsDesc": "<p>给定二叉树的根节点 <code>root</code>，找出存在于 <strong>不同</strong> 节点 <code>A</code> 和 <code>B</code> 之间的最大值 <code>V</code>，其中 <code>V = |A.val - B.val|</code>，且 <code>A</code> 是 <code>B</code> 的祖先。</p>\n\n<p>（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/09/tmp-tree.jpg\" style=\"width: 400px; height: 390px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [8,3,10,1,6,null,14,null,null,4,7,13]\n<strong>输出：</strong>7\n<strong>解释： </strong>\n我们有大量的节点与其祖先的差值，其中一些如下：\n|8 - 3| = 5\n|3 - 7| = 4\n|8 - 1| = 7\n|10 - 13| = 3\n在所有可能的差值中，最大值 7 由 |8 - 1| = 7 得出。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/09/tmp-tree-1.jpg\" style=\"width: 250px; height: 349px;\" />\n<pre>\n<strong>输入：</strong>root = [1,null,2,null,0,3]\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数在 <code>2</code> 到 <code>5000</code> 之间。</li>\n\t<li><code>0 <= Node.val <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1027.最长等差数列",
        "hardRate": "MEDIUM",
        "passRate": "49.40%",
        "problemsUrl": "https://leetcode.cn/problems/longest-arithmetic-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-arithmetic-subsequence/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>，返回 <code>nums</code>&nbsp;中最长等差子序列的<strong>长度</strong>。</p>\n\n<p>回想一下，<code>nums</code> 的子序列是一个列表&nbsp;<code>nums[i<sub>1</sub>], nums[i<sub>2</sub>], ..., nums[i<sub>k</sub>]</code> ，且&nbsp;<code>0 &lt;= i<sub>1</sub> &lt; i<sub>2</sub> &lt; ... &lt; i<sub>k</sub> &lt;= nums.length - 1</code>。并且如果&nbsp;<code>seq[i+1] - seq[i]</code>(&nbsp;<code>0 &lt;= i &lt; seq.length - 1</code>) 的值都相同，那么序列&nbsp;<code>seq</code>&nbsp;是等差的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,6,9,12]\n<strong>输出：</strong>4\n<strong>解释： </strong>\n整个数组是公差为 3 的等差数列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [9,4,7,2,10]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n最长的等差子序列是 [4,7,10]。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [20,1,15,3,10,5,8]\n<strong>输出：</strong>4\n<strong>解释：</strong>\n最长的等差子序列是 [20,15,10,5]。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 500</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1028.从先序遍历还原二叉树",
        "hardRate": "HARD",
        "passRate": "72.78%",
        "problemsUrl": "https://leetcode.cn/problems/recover-a-tree-from-preorder-traversal/",
        "solutionsUrl": "https://leetcode.cn/problems/recover-a-tree-from-preorder-traversal/solution",
        "problemsDesc": "<p>我们从二叉树的根节点 <code>root</code>&nbsp;开始进行深度优先搜索。</p>\n\n<p>在遍历中的每个节点处，我们输出&nbsp;<code>D</code>&nbsp;条短划线（其中&nbsp;<code>D</code>&nbsp;是该节点的深度），然后输出该节点的值。（<em>如果节点的深度为 <code>D</code>，则其直接子节点的深度为 <code>D + 1</code>。根节点的深度为 <code>0</code>）。</em></p>\n\n<p>如果节点只有一个子节点，那么保证该子节点为左子节点。</p>\n\n<p>给出遍历输出&nbsp;<code>S</code>，还原树并返回其根节点&nbsp;<code>root</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/12/recover-a-tree-from-preorder-traversal.png\" style=\"height: 200px; width: 320px;\"></strong></p>\n\n<pre><strong>输入：</strong>&quot;1-2--3--4-5--6--7&quot;\n<strong>输出：</strong>[1,2,5,3,4,6,7]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/12/screen-shot-2019-04-10-at-114101-pm.png\" style=\"height: 250px; width: 256px;\"></strong></p>\n\n<pre><strong>输入：</strong>&quot;1-2--3---4-5--6---7&quot;\n<strong>输出：</strong>[1,2,5,3,null,6,null,4,null,7]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/12/screen-shot-2019-04-10-at-114955-pm.png\" style=\"height: 250px; width: 276px;\"></p>\n\n<pre><strong>输入：</strong>&quot;1-401--349---90--88&quot;\n<strong>输出：</strong>[1,401,null,349,88,90]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>原始树中的节点数介于 <code>1</code> 和 <code>1000</code> 之间。</li>\n\t<li>每个节点的值介于 <code>1</code> 和 <code>10 ^ 9</code> 之间。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1029.两地调度",
        "hardRate": "MEDIUM",
        "passRate": "68.80%",
        "problemsUrl": "https://leetcode.cn/problems/two-city-scheduling/",
        "solutionsUrl": "https://leetcode.cn/problems/two-city-scheduling/solution",
        "problemsDesc": "<p>公司计划面试 <code>2n</code> 人。给你一个数组 <code>costs</code> ，其中 <code>costs[i] = [aCost<sub>i</sub>, bCost<sub>i</sub>]</code> 。第 <code>i</code> 人飞往 <code>a</code> 市的费用为 <code>aCost<sub>i</sub></code> ，飞往 <code>b</code> 市的费用为 <code>bCost<sub>i</sub></code> 。</p>\n\n<p>返回将每个人都飞到 <code>a</code> 、<code>b</code> 中某座城市的最低费用，要求每个城市都有 <code>n</code> 人抵达<strong>。</strong></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>costs = [[10,20],[30,200],[400,50],[30,20]]\n<strong>输出：</strong>110\n<strong>解释：</strong>\n第一个人去 a 市，费用为 10。\n第二个人去 a 市，费用为 30。\n第三个人去 b 市，费用为 50。\n第四个人去 b 市，费用为 20。\n\n最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>costs = [[259,770],[448,54],[926,667],[184,139],[840,118],[577,469]]\n<strong>输出：</strong>1859\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>costs = [[515,563],[451,713],[537,709],[343,819],[855,779],[457,60],[650,359],[631,42]]\n<strong>输出：</strong>3086\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 * n == costs.length</code></li>\n\t<li><code>2 <= costs.length <= 100</code></li>\n\t<li><code>costs.length</code> 为偶数</li>\n\t<li><code>1 <= aCost<sub>i</sub>, bCost<sub>i</sub> <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1030.距离顺序排列矩阵单元格",
        "hardRate": "EASY",
        "passRate": "70.60%",
        "problemsUrl": "https://leetcode.cn/problems/matrix-cells-in-distance-order/",
        "solutionsUrl": "https://leetcode.cn/problems/matrix-cells-in-distance-order/solution",
        "problemsDesc": "<p>给定四个整数 <code>rows</code>&nbsp;,&nbsp; &nbsp;<code>cols</code> ,&nbsp; <code>rCenter</code> 和 <code>cCenter</code> 。有一个&nbsp;<code>rows x cols</code>&nbsp;的矩阵，你在单元格上的坐标是&nbsp;<code>(rCenter, cCenter)</code> 。</p>\n\n<p>返回矩阵中的所有单元格的坐标，并按与<em>&nbsp;</em><code>(rCenter, cCenter)</code><em>&nbsp;</em>的 <strong>距离</strong> 从最小到最大的顺序排。你可以按 <strong>任何</strong> 满足此条件的顺序返回答案。</p>\n\n<p>单元格<code>(r1, c1)</code> 和 <code>(r2, c2)</code> 之间的距离为<code>|r1 - r2| + |c1 - c2|</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rows = 1, cols = 2, rCenter = 0, cCenter = 0\n<strong>输出：</strong>[[0,0],[0,1]]\n<strong>解释</strong>：从 (r0, c0) 到其他单元格的距离为：[0,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rows = 2, cols = 2, rCenter = 0, cCenter = 1\n<strong>输出：</strong>[[0,1],[0,0],[1,1],[1,0]]\n<strong>解释</strong>：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2]\n[[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>rows = 2, cols = 3, rCenter = 1, cCenter = 2\n<strong>输出：</strong>[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]\n<strong>解释</strong>：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3]\n其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rows, cols &lt;= 100</code></li>\n\t<li><code>0 &lt;= rCenter &lt; rows</code></li>\n\t<li><code>0 &lt;= cCenter &lt; cols</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1031.两个非重叠子数组的最大和",
        "hardRate": "MEDIUM",
        "passRate": "65.57%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-of-two-non-overlapping-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-of-two-non-overlapping-subarrays/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和两个整数 <code>firstLen</code> 和 <code>secondLen</code>，请你找出并返回两个非重叠<strong> 子数组 </strong>中元素的最大和<em>，</em>长度分别为 <code>firstLen</code> 和 <code>secondLen</code> 。</p>\n\n<p>长度为 <code>firstLen</code> 的子数组可以出现在长为 <code>secondLen</code> 的子数组之前或之后，但二者必须是不重叠的。</p>\n\n<p>子数组是数组的一个 <strong>连续</strong> 部分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,6,5,2,2,5,1,9,4], firstLen = 1, secondLen = 2\n<strong>输出：</strong>20\n<strong>解释：</strong>子数组的一种选择中，[9] 长度为 1，[6,5] 长度为 2。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,8,1,3,2,1,8,9,0], firstLen = 3, secondLen = 2\n<strong>输出：</strong>29\n<strong>解释：</strong>子数组的一种选择中，[3,8,1] 长度为 3，[8,9] 长度为 2。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,5,6,0,9,5,0,3,8], firstLen = 4, secondLen = 3\n<strong>输出：</strong>31\n<strong>解释：</strong>子数组的一种选择中，[5,6,0,9] 长度为 4，[0,3,8] 长度为 3。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= firstLen, secondLen &lt;= 1000</code></li>\n\t<li><code>2 &lt;= firstLen + secondLen &lt;= 1000</code></li>\n\t<li><code>firstLen + secondLen &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1032.字符流",
        "hardRate": "HARD",
        "passRate": "56.59%",
        "problemsUrl": "https://leetcode.cn/problems/stream-of-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/stream-of-characters/solution",
        "problemsDesc": "<p>设计一个算法：接收一个字符流，并检查这些字符的后缀是否是字符串数组 <code>words</code> 中的一个字符串。</p>\n\n<p>例如，<code>words = [\"abc\", \"xyz\"]</code> 且字符流中逐个依次加入 4 个字符 <code>'a'</code>、<code>'x'</code>、<code>'y'</code> 和 <code>'z'</code> ，你所设计的算法应当可以检测到&nbsp;<code>\"axyz\"</code> 的后缀 <code>\"xyz\"</code> 与&nbsp;<code>words</code> 中的字符串 <code>\"xyz\"</code> 匹配。</p>\n\n<p>按下述要求实现 <code>StreamChecker</code> 类：</p>\n\n<ul>\n\t<li><code>StreamChecker(String[] words)</code> ：构造函数，用字符串数组&nbsp;<code>words</code> 初始化数据结构。</li>\n\t<li><code>boolean query(char letter)</code>：从字符流中接收一个新字符，如果字符流中的任一非空后缀能匹配 <code>words</code> 中的某一字符串，返回 <code>true</code> ；否则，返回 <code>false</code>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"StreamChecker\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\", \"query\"]\n[[[\"cd\", \"f\", \"kl\"]], [\"a\"], [\"b\"], [\"c\"], [\"d\"], [\"e\"], [\"f\"], [\"g\"], [\"h\"], [\"i\"], [\"j\"], [\"k\"], [\"l\"]]\n<strong>输出：</strong>\n[null, false, false, false, true, false, true, false, false, false, false, false, true]\n\n<strong>解释：</strong>\nStreamChecker streamChecker = new StreamChecker([\"cd\", \"f\", \"kl\"]);\nstreamChecker.query(\"a\"); // 返回 False\nstreamChecker.query(\"b\"); // 返回 False\nstreamChecker.query(\"c\"); // 返回n False\nstreamChecker.query(\"d\"); // 返回 True ，因为 'cd' 在 words 中\nstreamChecker.query(\"e\"); // 返回 False\nstreamChecker.query(\"f\"); // 返回 True ，因为 'f' 在 words 中\nstreamChecker.query(\"g\"); // 返回 False\nstreamChecker.query(\"h\"); // 返回 False\nstreamChecker.query(\"i\"); // 返回 False\nstreamChecker.query(\"j\"); // 返回 False\nstreamChecker.query(\"k\"); // 返回 False\nstreamChecker.query(\"l\"); // 返回 True ，因为 'kl' 在 words 中\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 2000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 200</code></li>\n\t<li><code>words[i]</code> 由小写英文字母组成</li>\n\t<li><code>letter</code> 是一个小写英文字母</li>\n\t<li>最多调用查询 <code>4 * 10<sup>4</sup></code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1033.移动石子直到连续",
        "hardRate": "MEDIUM",
        "passRate": "49.34%",
        "problemsUrl": "https://leetcode.cn/problems/moving-stones-until-consecutive/",
        "solutionsUrl": "https://leetcode.cn/problems/moving-stones-until-consecutive/solution",
        "problemsDesc": "<p>三枚石子放置在数轴上，位置分别为 <code>a</code>，<code>b</code>，<code>c</code>。</p>\n\n<p>每一回合，你可以从两端之一拿起一枚石子（位置最大或最小），并将其放入两端之间的任一空闲位置。形式上，假设这三枚石子当前分别位于位置 <code>x, y, z</code> 且 <code>x < y < z</code>。那么就可以从位置 <code>x</code> 或者是位置 <code>z</code> 拿起一枚石子，并将该石子移动到某一整数位置 <code>k</code> 处，其中 <code>x < k < z</code> 且 <code>k != y</code>。</p>\n\n<p>当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。</p>\n\n<p>要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：<code>answer = [minimum_moves, maximum_moves]</code></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 1, b = 2, c = 5\n<strong>输出：</strong>[1, 2]\n<strong>解释：</strong>将石子从 5 移动到 4 再移动到 3，或者我们可以直接将石子移动到 3。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 4, b = 3, c = 2\n<strong>输出：</strong>[0, 0]\n<strong>解释：</strong>我们无法进行任何移动。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 <= a <= 100</code></li>\n\t<li><code>1 <= b <= 100</code></li>\n\t<li><code>1 <= c <= 100</code></li>\n\t<li><code>a != b, b != c, c != a</code></li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1034.边界着色",
        "hardRate": "MEDIUM",
        "passRate": "55.13%",
        "problemsUrl": "https://leetcode.cn/problems/coloring-a-border/",
        "solutionsUrl": "https://leetcode.cn/problems/coloring-a-border/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的整数矩阵 <code>grid</code> ，表示一个网格。另给你三个整数&nbsp;<code>row</code>、<code>col</code> 和 <code>color</code> 。网格中的每个值表示该位置处的网格块的颜色。</p>\n\n<p>如果两个方块在任意 4 个方向上相邻，则称它们&nbsp;<strong>相邻 </strong>。</p>\n\n<p>如果两个方块具有相同的颜色且相邻，它们则属于同一个 <strong>连通分量</strong> 。</p>\n\n<p><strong>连通分量的边界</strong><strong> </strong>是指连通分量中满足下述条件之一的所有网格块：</p>\n\n<ul>\n\t<li>在上、下、左、右任意一个方向上与不属于同一连通分量的网格块相邻</li>\n\t<li>在网格的边界上（第一行/列或最后一行/列）</li>\n</ul>\n\n<p>请你使用指定颜色&nbsp;<code>color</code> 为所有包含网格块&nbsp;<code>grid[row][col]</code> 的 <strong>连通分量的边界</strong> 进行着色。</p>\n\n<p>并返回最终的网格&nbsp;<code>grid</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,1],[1,2]], row = 0, col = 0, color = 3\n<strong>输出：</strong>[[3,3],[3,2]]</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3\n<strong>输出：</strong>[[1,3,3],[2,3,3]]</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2\n<strong>输出：</strong>[[2,2,2],[2,1,2],[2,2,2]]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>1 &lt;= grid[i][j], color &lt;= 1000</code></li>\n\t<li><code>0 &lt;= row &lt; m</code></li>\n\t<li><code>0 &lt;= col &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1035.不相交的线",
        "hardRate": "MEDIUM",
        "passRate": "70.33%",
        "problemsUrl": "https://leetcode.cn/problems/uncrossed-lines/",
        "solutionsUrl": "https://leetcode.cn/problems/uncrossed-lines/solution",
        "problemsDesc": "<p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数。</p>\n\n<p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code>&nbsp;和 <code>nums2[j]</code>&nbsp;的直线，这些直线需要同时满足满足：</p>\n\n<ul>\n\t<li>&nbsp;<code>nums1[i] == nums2[j]</code></li>\n\t<li>且绘制的直线不与任何其他连线（非水平线）相交。</li>\n</ul>\n\n<p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p>\n\n<p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/04/26/142.png\" style=\"width: 400px; height: 286px;\" />\n<pre>\n<strong>输入：</strong>nums1 = <span id=\"example-input-1-1\">[1,4,2]</span>, nums2 = <span id=\"example-input-1-2\">[1,2,4]</span>\n<strong>输出：</strong><span id=\"example-output-1\">2</span>\n<strong>解释：</strong>可以画出两条不交叉的线，如上图所示。 \n但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。\n</pre>\n\n<div>\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = <span id=\"example-input-2-1\">[2,5,1,2,5]</span>, nums2 = <span id=\"example-input-2-2\">[10,5,2,1,5,2]</span>\n<strong>输出：</strong><span id=\"example-output-2\">3</span>\n</pre>\n\n<div>\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = <span id=\"example-input-3-1\">[1,3,7,1,7,5]</span>, nums2 = <span id=\"example-input-3-2\">[1,9,2,5,1]</span>\n<strong>输出：</strong><span id=\"example-output-3\">2</span></pre>\n\n<p>&nbsp;</p>\n</div>\n</div>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[j] &lt;= 2000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1036.逃离大迷宫",
        "hardRate": "HARD",
        "passRate": "46.79%",
        "problemsUrl": "https://leetcode.cn/problems/escape-a-large-maze/",
        "solutionsUrl": "https://leetcode.cn/problems/escape-a-large-maze/solution",
        "problemsDesc": "<p>在一个 10<sup>6</sup> x 10<sup>6</sup> 的网格中，每个网格上方格的坐标为 <code>(x, y)</code> 。</p>\n\n<p>现在从源方格 <code>source = [s<sub>x</sub>, s<sub>y</sub>]</code> 开始出发，意图赶往目标方格 <code>target = [t<sub>x</sub>, t<sub>y</sub>]</code> 。数组 <code>blocked</code> 是封锁的方格列表，其中每个 <code>blocked[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示坐标为 <code>(x<sub>i</sub>, y<sub>i</sub>)</code> 的方格是禁止通行的。</p>\n\n<p>每次移动，都可以走到网格中在四个方向上相邻的方格，只要该方格 <strong>不</strong> 在给出的封锁列表 <code>blocked</code> 上。同时，不允许走出网格。</p>\n\n<p>只有在可以通过一系列的移动从源方格 <code>source</code> 到达目标方格 <code>target</code> 时才返回 <code>true</code>。否则，返回 <code>false</code>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]\n<strong>输出：</strong>false\n<strong>解释：</strong>\n从源方格无法到达目标方格，因为我们无法在网格中移动。\n无法向北或者向东移动是因为方格禁止通行。\n无法向南或者向西移动是因为不能走出网格。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>blocked = [], source = [0,0], target = [999999,999999]\n<strong>输出：</strong>true\n<strong>解释：</strong>\n因为没有方格被封锁，所以一定可以到达目标方格。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= blocked.length <= 200</code></li>\n\t<li><code>blocked[i].length == 2</code></li>\n\t<li><code>0 <= x<sub>i</sub>, y<sub>i</sub> < 10<sup>6</sup></code></li>\n\t<li><code>source.length == target.length == 2</code></li>\n\t<li><code>0 <= s<sub>x</sub>, s<sub>y</sub>, t<sub>x</sub>, t<sub>y</sub> < 10<sup>6</sup></code></li>\n\t<li><code>source != target</code></li>\n\t<li>题目数据保证 <code>source</code> 和 <code>target</code> 不在封锁列表内</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1037.有效的回旋镖",
        "hardRate": "EASY",
        "passRate": "48.54%",
        "problemsUrl": "https://leetcode.cn/problems/valid-boomerang/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-boomerang/solution",
        "problemsDesc": "<p>给定一个数组<meta charset=\"UTF-8\" />&nbsp;<code>points</code>&nbsp;，其中<meta charset=\"UTF-8\" />&nbsp;<code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;表示 <strong>X-Y</strong> 平面上的一个点，<em>如果这些点构成一个&nbsp;</em><strong>回旋镖</strong>&nbsp;则返回&nbsp;<code>true</code>&nbsp;。</p>\n\n<p><strong>回旋镖</strong>&nbsp;定义为一组三个点，这些点&nbsp;<strong>各不相同</strong>&nbsp;且&nbsp;<strong>不在一条直线上</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[1,1],[2,3],[3,2]]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[1,1],[2,2],[3,3]]\n<strong>输出：</strong>false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>points.length == 3</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1038.从二叉搜索树到更大和树",
        "hardRate": "MEDIUM",
        "passRate": "81.32%",
        "problemsUrl": "https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/solution",
        "problemsDesc": "<p><span style=\"font-size:10.5pt\"><span style=\"font-family:Calibri\"><span style=\"font-size:10.5000pt\"><span style=\"font-family:宋体\"><font face=\"宋体\">给定一个二叉搜索树</font></span></span></span></span>&nbsp;<code>root</code>&nbsp;(BST)<span style=\"font-size:10.5pt\"><span style=\"font-family:Calibri\"><span style=\"font-size:10.5000pt\"><span style=\"font-family:宋体\"><font face=\"宋体\">，请将它的每个</font></span></span></span></span>节点<span style=\"font-size:10.5pt\"><span style=\"font-family:Calibri\"><span style=\"font-size:10.5000pt\"><span style=\"font-family:宋体\"><font face=\"宋体\">的值替换成树中大于或者等于该</font></span></span></span></span>节点<span style=\"font-size:10.5pt\"><span style=\"font-family:Calibri\"><span style=\"font-size:10.5000pt\"><span style=\"font-family:宋体\"><font face=\"宋体\">值的所有</font></span></span></span></span>节点<span style=\"font-size:10.5pt\"><span style=\"font-family:Calibri\"><span style=\"font-size:10.5000pt\"><span style=\"font-family:宋体\"><font face=\"宋体\">值之和。</font></span></span></span></span></p>\n\n<p>提醒一下， <em>二叉搜索树</em> 满足下列约束条件：</p>\n\n<ul>\n\t<li>节点的左子树仅包含键<strong> 小于 </strong>节点键的节点。</li>\n\t<li>节点的右子树仅包含键<strong> 大于</strong> 节点键的节点。</li>\n\t<li>左右子树也必须是二叉搜索树。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png\" style=\"height:273px; width:400px\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n<strong>输出：</strong>[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [0,null,1]\n<strong>输出：</strong>[1,null,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数在&nbsp;<code>[1, 100]</code>&nbsp;范围内。</li>\n\t<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n\t<li>树中的所有值均 <strong>不重复</strong>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>该题目与 538:&nbsp;<a href=\"https://leetcode-cn.com/problems/convert-bst-to-greater-tree/\">https://leetcode-cn.com/problems/convert-bst-to-greater-tree/&nbsp; </a>相同</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1039.多边形三角剖分的最低得分",
        "hardRate": "MEDIUM",
        "passRate": "64.52%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/solution",
        "problemsDesc": "<p>你有一个凸的<meta charset=\"UTF-8\" />&nbsp;<code>n</code>&nbsp;边形，其每个顶点都有一个整数值。给定一个整数数组<meta charset=\"UTF-8\" />&nbsp;<code>values</code>&nbsp;，其中<meta charset=\"UTF-8\" />&nbsp;<code>values[i]</code>&nbsp;是第 <code>i</code> 个顶点的值（即 <strong>顺时针顺序</strong> ）。</p>\n\n<p>假设将多边形 <strong>剖分</strong>&nbsp;为 <code>n - 2</code>&nbsp;个三角形。对于每个三角形，该三角形的值是顶点标记的<strong>乘积</strong>，三角剖分的分数是进行三角剖分后所有 <code>n - 2</code>&nbsp;个三角形的值之和。</p>\n\n<p>返回 <em>多边形进行三角剖分后可以得到的最低分</em> 。<br />\n&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/25/shape1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>values = [1,2,3]\n<strong>输出：</strong>6\n<strong>解释：</strong>多边形已经三角化，唯一三角形的分数为 6。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/25/shape2.jpg\" style=\"height: 163px; width: 446px;\" /></p>\n\n<pre>\n<strong>输入：</strong>values = [3,7,4,5]\n<strong>输出：</strong>144\n<strong>解释：</strong>有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 = 245，或 3*4*5 + 3*4*7 = 144。最低分数为 144。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/25/shape3.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>values = [1,3,1,4,1,5]\n<strong>输出：</strong>13\n<strong>解释：</strong>最低分数三角剖分的得分情况为 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == values.length</code></li>\n\t<li><code>3 &lt;= n &lt;= 50</code></li>\n\t<li><code>1 &lt;= values[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1040.移动石子直到连续 II",
        "hardRate": "MEDIUM",
        "passRate": "66.14%",
        "problemsUrl": "https://leetcode.cn/problems/moving-stones-until-consecutive-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/moving-stones-until-consecutive-ii/solution",
        "problemsDesc": "<p>在一个长度 <strong>无限 </strong>的数轴上，第 <code>i</code> 颗石子的位置为 <code>stones[i]</code>。如果一颗石子的位置最小/最大，那么该石子被称作 <strong>端点石子 </strong>。</p>\n\n<p>每个回合，你可以将一颗端点石子拿起并移动到一个未占用的位置，使得该石子不再是一颗端点石子。</p>\n\n<p>值得注意的是，如果石子像 <code>stones = [1,2,5]</code> 这样，你将 <strong>无法 </strong>移动位于位置 5 的端点石子，因为无论将它移动到任何位置（例如 0 或 3），该石子都仍然会是端点石子。</p>\n\n<p>当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。</p>\n\n<p>要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：<code>answer = [minimum_moves, maximum_moves]</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>[7,4,9]\n<strong>输出：</strong>[1,2]\n<strong>解释：</strong>\n我们可以移动一次，4 -> 8，游戏结束。\n或者，我们可以移动两次 9 -> 5，4 -> 6，游戏结束。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>[6,5,4,3,10]\n<strong>输出：</strong>[2,3]\n<strong>解释：</strong>\n我们可以移动 3 -> 8，接着是 10 -> 7，游戏结束。\n或者，我们可以移动 3 -> 7, 4 -> 8, 5 -> 9，游戏结束。\n注意，我们无法进行 10 -> 2 这样的移动来结束游戏，因为这是不合要求的移动。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>[100,101,104,102,103]\n<strong>输出：</strong>[0,0]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 <= stones.length <= 10^4</code></li>\n\t<li><code>1 <= stones[i] <= 10^9</code></li>\n\t<li><code>stones[i]</code> 的值各不相同。</li>\n</ul>\n\n<p> </p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1041.困于环中的机器人",
        "hardRate": "MEDIUM",
        "passRate": "57.03%",
        "problemsUrl": "https://leetcode.cn/problems/robot-bounded-in-circle/",
        "solutionsUrl": "https://leetcode.cn/problems/robot-bounded-in-circle/solution",
        "problemsDesc": "<p>在无限的平面上，机器人最初位于&nbsp;<code>(0, 0)</code>&nbsp;处，面朝北方。注意:</p>\n\n<ul>\n\t<li><strong>北方向</strong> 是y轴的正方向。</li>\n\t<li><strong>南方向</strong> 是y轴的负方向。</li>\n\t<li><strong>东方向</strong> 是x轴的正方向。</li>\n\t<li><strong>西方向</strong> 是x轴的负方向。</li>\n</ul>\n\n<p>机器人可以接受下列三条指令之一：</p>\n\n<ul>\n\t<li><code>\"G\"</code>：直走 1 个单位</li>\n\t<li><code>\"L\"</code>：左转 90 度</li>\n\t<li><code>\"R\"</code>：右转 90 度</li>\n</ul>\n\n<p>机器人按顺序执行指令&nbsp;<code>instructions</code>，并一直重复它们。</p>\n\n<p>只有在平面中存在环使得机器人永远无法离开时，返回&nbsp;<code>true</code>。否则，返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>instructions = \"GGLLGG\"\n<strong>输出：</strong>true\n<strong>解释：</strong>机器人最初在(0,0)处，面向北方。\n“G”:移动一步。位置:(0,1)方向:北。\n“G”:移动一步。位置:(0,2).方向:北。\n“L”:逆时针旋转90度。位置:(0,2).方向:西。\n“L”:逆时针旋转90度。位置:(0,2)方向:南。\n“G”:移动一步。位置:(0,1)方向:南。\n“G”:移动一步。位置:(0,0)方向:南。\n重复指令，机器人进入循环:(0,0)——&gt;(0,1)——&gt;(0,2)——&gt;(0,1)——&gt;(0,0)。\n在此基础上，我们返回true。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>instructions = \"GG\"\n<strong>输出：</strong>false\n<strong>解释：</strong>机器人最初在(0,0)处，面向北方。\n“G”:移动一步。位置:(0,1)方向:北。\n“G”:移动一步。位置:(0,2).方向:北。\n重复这些指示，继续朝北前进，不会进入循环。\n在此基础上，返回false。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>instructions = \"GL\"\n<strong>输出：</strong>true\n<strong>解释：</strong>机器人最初在(0,0)处，面向北方。\n“G”:移动一步。位置:(0,1)方向:北。\n“L”:逆时针旋转90度。位置:(0,1).方向:西。\n“G”:移动一步。位置:(- 1,1)方向:西。\n“L”:逆时针旋转90度。位置:(- 1,1)方向:南。\n“G”:移动一步。位置:(- 1,0)方向:南。\n“L”:逆时针旋转90度。位置:(- 1,0)方向:东方。\n“G”:移动一步。位置:(0,0)方向:东方。\n“L”:逆时针旋转90度。位置:(0,0)方向:北。\n重复指令，机器人进入循环:(0,0)——&gt;(0,1)——&gt;(- 1,1)——&gt;(- 1,0)——&gt;(0,0)。\n在此基础上，我们返回true。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= instructions.length &lt;= 100</code></li>\n\t<li><code>instructions[i]</code>&nbsp;仅包含&nbsp;<code>'G', 'L', 'R'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1042.不邻接植花",
        "hardRate": "MEDIUM",
        "passRate": "61.14%",
        "problemsUrl": "https://leetcode.cn/problems/flower-planting-with-no-adjacent/",
        "solutionsUrl": "https://leetcode.cn/problems/flower-planting-with-no-adjacent/solution",
        "problemsDesc": "<p>有 <code>n</code> 个花园，按从&nbsp;<code>1</code>&nbsp;到 <code>n</code> 标记。另有数组 <code>paths</code> ，其中 <code>paths[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;描述了花园&nbsp;<code>x<sub>i</sub></code> 到花园&nbsp;<code>y<sub>i</sub></code> 的双向路径。在每个花园中，你打算种下四种花之一。</p>\n\n<p>另外，所有花园 <strong>最多</strong> 有 <strong>3</strong> 条路径可以进入或离开.</p>\n\n<p>你需要为每个花园选择一种花，使得通过路径相连的任何两个花园中的花的种类互不相同。</p>\n\n<p><em>以数组形式返回 <strong>任一</strong> 可行的方案作为答案&nbsp;<code>answer</code>，其中&nbsp;<code>answer[i]</code>&nbsp;为在第&nbsp;<code>(i+1)</code>&nbsp;个花园中种植的花的种类。花的种类用 &nbsp;1、2、3、4 表示。保证存在答案。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, paths = [[1,2],[2,3],[3,1]]\n<strong>输出：</strong>[1,2,3]\n<strong>解释：</strong>\n花园 1 和 2 花的种类不同。\n花园 2 和 3 花的种类不同。\n花园 3 和 1 花的种类不同。\n因此，[1,2,3] 是一个满足题意的答案。其他满足题意的答案有 [1,2,4]、[1,4,2] 和 [3,2,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, paths = [[1,2],[3,4]]\n<strong>输出：</strong>[1,2,1,2]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]]\n<strong>输出：</strong>[1,2,3,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= paths.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>paths[i].length == 2</code></li>\n\t<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= n</code></li>\n\t<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>\n\t<li>每个花园 <strong>最多</strong> 有 <strong>3</strong> 条路径可以进入或离开</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1043.分隔数组以得到最大和",
        "hardRate": "MEDIUM",
        "passRate": "75.48%",
        "problemsUrl": "https://leetcode.cn/problems/partition-array-for-maximum-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-array-for-maximum-sum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code>，请你将该数组分隔为长度 <strong>最多 </strong>为 k 的一些（连续）子数组。分隔完成后，每个子数组的中的所有值都会变为该子数组中的最大值。</p>\n\n<p>返回将数组分隔变换后能够得到的元素最大和。本题所用到的测试用例会确保答案是一个 32 位整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,15,7,9,2,5,10], k = 3\n<strong>输出：</strong>84\n<strong>解释：</strong>数组变为 [15,15,15,9,10,10,10]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\n<strong>输出：</strong>83\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1], k = 1\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 500</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1044.最长重复子串",
        "hardRate": "HARD",
        "passRate": "35.40%",
        "problemsUrl": "https://leetcode.cn/problems/longest-duplicate-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-duplicate-substring/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，考虑其所有 <em>重复子串</em> ：即&nbsp;<code>s</code> 的（连续）子串，在 <code>s</code> 中出现 2 次或更多次。这些出现之间可能存在重叠。</p>\n\n<p>返回 <strong>任意一个</strong> 可能具有最长长度的重复子串。如果 <code>s</code> 不含重复子串，那么答案为 <code>\"\"</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"banana\"\n<strong>输出：</strong>\"ana\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\"\n<strong>输出：</strong>\"\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1045.买下所有产品的客户",
        "hardRate": "MEDIUM",
        "passRate": "61.45%",
        "problemsUrl": "https://leetcode.cn/problems/customers-who-bought-all-products/",
        "solutionsUrl": "https://leetcode.cn/problems/customers-who-bought-all-products/solution",
        "problemsDesc": "<p><code>Customer</code>&nbsp;表：</p>\n\n<pre>+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| customer_id | int     |\n| product_key | int     |\n+-------------+---------+\nproduct_key 是 <code>Customer 表的外键</code>。\n</pre>\n\n<p><code>Product</code>&nbsp;表：</p>\n\n<pre>+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| product_key | int     |\n+-------------+---------+\nproduct_key 是这张表的主键。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一条 SQL 查询语句，从 <code>Customer</code> 表中查询购买了 <code>Product</code> 表中所有产品的客户的 id。</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>Customer 表：\n+-------------+-------------+\n| customer_id | product_key |\n+-------------+-------------+\n| 1           | 5           |\n| 2           | 6           |\n| 3           | 5           |\n| 3           | 6           |\n| 1           | 6           |\n+-------------+-------------+\n\nProduct 表：\n+-------------+\n| product_key |\n+-------------+\n| 5           |\n| 6           |\n+-------------+\n\nResult 表：\n+-------------+\n| customer_id |\n+-------------+\n| 1           |\n| 3           |\n+-------------+\n购买了所有产品（5 和 6）的客户的 id 是 1 和 3 。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1046.最后一块石头的重量",
        "hardRate": "EASY",
        "passRate": "65.55%",
        "problemsUrl": "https://leetcode.cn/problems/last-stone-weight/",
        "solutionsUrl": "https://leetcode.cn/problems/last-stone-weight/solution",
        "problemsDesc": "<p>有一堆石头，每块石头的重量都是正整数。</p>\n\n<p>每一回合，从中选出两块<strong> 最重的</strong> 石头，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x <= y</code>。那么粉碎的可能结果如下：</p>\n\n<ul>\n\t<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>\n\t<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>\n</ul>\n\n<p>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 <code>0</code>。</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>[2,7,4,1,8,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，\n再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，\n接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，\n最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= stones.length <= 30</code></li>\n\t<li><code>1 <= stones[i] <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1047.删除字符串中的所有相邻重复项",
        "hardRate": "EASY",
        "passRate": "72.33%",
        "problemsUrl": "https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/solution",
        "problemsDesc": "<p>给出由小写字母组成的字符串&nbsp;<code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p>\n\n<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>\n\n<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>&quot;abbaca&quot;\n<strong>输出：</strong>&quot;ca&quot;\n<strong>解释：</strong>\n例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= S.length &lt;= 20000</code></li>\n\t<li><code>S</code> 仅由小写英文字母组成。</li>\n</ol>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1048.最长字符串链",
        "hardRate": "MEDIUM",
        "passRate": "55.76%",
        "problemsUrl": "https://leetcode.cn/problems/longest-string-chain/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-string-chain/solution",
        "problemsDesc": "<p>给出一个单词数组&nbsp;<code>words</code>&nbsp;，其中每个单词都由小写英文字母组成。</p>\n\n<p>如果我们可以&nbsp;<strong>不改变其他字符的顺序&nbsp;</strong>，在 <code>word<sub>A</sub></code>&nbsp;的任何地方添加 <strong>恰好一个</strong> 字母使其变成&nbsp;<code>word<sub>B</sub></code>&nbsp;，那么我们认为&nbsp;<code>word<sub>A</sub></code>&nbsp;是&nbsp;<code>word<sub>B</sub></code>&nbsp;的 <strong>前身</strong> 。</p>\n\n<ul>\n\t<li>例如，<code>\"abc\"</code>&nbsp;是&nbsp;<code>\"abac\"</code>&nbsp;的 <strong>前身</strong>&nbsp;，而&nbsp;<code>\"cba\"</code>&nbsp;不是&nbsp;<code>\"bcad\"</code>&nbsp;的 <strong>前身</strong></li>\n</ul>\n\n<p><strong>词链</strong>是单词&nbsp;<code>[word_1, word_2, ..., word_k]</code>&nbsp;组成的序列，<code>k &gt;= 1</code>，其中&nbsp;<code>word<sub>1</sub></code>&nbsp;是&nbsp;<code>word<sub>2</sub></code>&nbsp;的前身，<code>word<sub>2</sub></code>&nbsp;是&nbsp;<code>word<sub>3</sub></code>&nbsp;的前身，依此类推。一个单词通常是 <code>k == 1</code> 的 <strong>单词链</strong>&nbsp;。</p>\n\n<p>从给定单词列表 <code>words</code> 中选择单词组成词链，返回 词链的&nbsp;<strong>最长可能长度</strong> 。<br />\n&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\n<strong>输出：</strong>4\n<strong>解释：</strong>最长单词链之一为 [\"a\",\"<u>b</u>a\",\"b<u>d</u>a\",\"bd<u>c</u>a\"]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"xbc\",\"pcxbcf\",\"xb\",\"cxbc\",\"pcxbc\"]\n<b>输出：</b>5\n<b>解释：</b>所有的单词都可以放入单词链 [\"xb\", \"xb<u>c</u>\", \"<u>c</u>xbc\", \"<u>p</u>cxbc\", \"pcxbc<u>f</u>\"].\n</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"abcd\",\"dbqca\"]\n<strong>输出：</strong>1\n<b>解释：</b>字链[\"abcd\"]是最长的字链之一。\n[\"abcd\"，\"dbqca\"]不是一个有效的单词链，因为字母的顺序被改变了。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 16</code></li>\n\t<li><code>words[i]</code>&nbsp;仅由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1049.最后一块石头的重量 II",
        "hardRate": "MEDIUM",
        "passRate": "69.27%",
        "problemsUrl": "https://leetcode.cn/problems/last-stone-weight-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/last-stone-weight-ii/solution",
        "problemsDesc": "<p>有一堆石头，用整数数组&nbsp;<code>stones</code> 表示。其中&nbsp;<code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p>\n\n<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为&nbsp;<code>x</code> 和&nbsp;<code>y</code>，且&nbsp;<code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>\n\n<ul>\n\t<li>如果&nbsp;<code>x == y</code>，那么两块石头都会被完全粉碎；</li>\n\t<li>如果&nbsp;<code>x != y</code>，那么重量为&nbsp;<code>x</code>&nbsp;的石头将会完全粉碎，而重量为&nbsp;<code>y</code>&nbsp;的石头新重量为&nbsp;<code>y-x</code>。</li>\n</ul>\n\n<p>最后，<strong>最多只会剩下一块 </strong>石头。返回此石头 <strong>最小的可能重量 </strong>。如果没有石头剩下，就返回 <code>0</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [2,7,4,1,8,1]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，\n组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，\n组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，\n组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [31,26,33,21,40]\n<strong>输出：</strong>5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= stones.length &lt;= 30</code></li>\n\t<li><code>1 &lt;= stones[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1050.合作过至少三次的演员和导演",
        "hardRate": "EASY",
        "passRate": "76.70%",
        "problemsUrl": "https://leetcode.cn/problems/actors-and-directors-who-cooperated-at-least-three-times/",
        "solutionsUrl": "https://leetcode.cn/problems/actors-and-directors-who-cooperated-at-least-three-times/solution",
        "problemsDesc": "<p><code>ActorDirector</code>&nbsp;表：</p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| actor_id    | int     |\n| director_id | int     |\n| timestamp   | int     |\n+-------------+---------+\ntimestamp 是这张表的主键.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一条SQL查询语句获取合作过至少三次的演员和导演的 id 对&nbsp;<code>(actor_id, director_id)</code></p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\nActorDirector 表：\n+-------------+-------------+-------------+\n| actor_id    | director_id | timestamp   |\n+-------------+-------------+-------------+\n| 1           | 1           | 0           |\n| 1           | 1           | 1           |\n| 1           | 1           | 2           |\n| 1           | 2           | 3           |\n| 1           | 2           | 4           |\n| 2           | 1           | 5           |\n| 2           | 1           | 6           |\n+-------------+-------------+-------------+\n\nResult 表：\n+-------------+-------------+\n| actor_id    | director_id |\n+-------------+-------------+\n| 1           | 1           |\n+-------------+-------------+\n唯一的 id 对是 (1, 1)，他们恰好合作了 3 次。</pre>\n",
        "isPlus": false
    }
]