[
    {
        "problemsName": " 2951.和为 k 的子数组",
        "hardRate": "MEDIUM",
        "passRate": "42.94%",
        "problemsUrl": "https://leetcode.cn/problems/QTMn0o/",
        "solutionsUrl": "https://leetcode.cn/problems/QTMn0o/solution",
        "problemsDesc": "<p>给定一个整数数组和一个整数&nbsp;<code>k</code><strong> ，</strong>请找到该数组中和为&nbsp;<code>k</code><strong>&nbsp;</strong>的连续子数组的个数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong>nums = [1,1,1], k = 2\n<strong>输出:</strong> 2\n<strong>解释:</strong> 此题 [1,1] 与 [1,1] 为两种不同的情况\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong>nums = [1,2,3], k = 3\n<strong>输出:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>\n\t<p><code>-10<sup>7</sup>&nbsp;&lt;= k &lt;= 10<sup>7</sup></code></p>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 560&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/subarray-sum-equals-k/\">https://leetcode-cn.com/problems/subarray-sum-equals-k/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2952.0 和 1 个数相同的子数组",
        "hardRate": "MEDIUM",
        "passRate": "54.84%",
        "problemsUrl": "https://leetcode.cn/problems/A1NYOS/",
        "solutionsUrl": "https://leetcode.cn/problems/A1NYOS/solution",
        "problemsDesc": "<p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [0,1]\n<strong>输出:</strong> 2\n<strong>说明:</strong> [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [0,1,0]\n<strong>输出:</strong> 2\n<strong>说明:</strong> [0, 1] (或 [1, 0]) 是具有相同数量 0 和 1 的最长连续子数组。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 525&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/contiguous-array/\">https://leetcode-cn.com/problems/contiguous-array/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2953.左右两边子数组的和相等",
        "hardRate": "EASY",
        "passRate": "67.07%",
        "problemsUrl": "https://leetcode.cn/problems/tvdfij/",
        "solutionsUrl": "https://leetcode.cn/problems/tvdfij/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code> ，请计算数组的 <strong>中心下标 </strong>。</p>\n\n<p>数组<strong> 中心下标</strong><strong> </strong>是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p>\n\n<p>如果中心下标位于数组最左端，那么左侧数之和视为 <code>0</code> ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p>\n\n<p>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,7,3,6,5,6]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n中心下标是 3 。\n左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，\n右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1, 2, 3]\n<strong>输出：</strong>-1\n<strong>解释：</strong>\n数组中不存在满足此条件的中心下标。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2, 1, -1]\n<strong>输出：</strong>0\n<strong>解释：</strong>\n中心下标是 0 。\n左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），\n右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 724&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/find-pivot-index/\">https://leetcode-cn.com/problems/find-pivot-index/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2954.二维子矩阵的和",
        "hardRate": "MEDIUM",
        "passRate": "68.92%",
        "problemsUrl": "https://leetcode.cn/problems/O4NDxx/",
        "solutionsUrl": "https://leetcode.cn/problems/O4NDxx/solution",
        "problemsDesc": "<p><big><small>给定一个二维矩阵 <code>matrix</code>，</small></big>以下类型的多个请求：</p>\n\n<ul>\n\t<li><big><small>计算其子矩形范围内元素的总和，该子矩阵的左上角为 <code>(row1,&nbsp;col1)</code> ，右下角为 <code>(row2,&nbsp;col2)</code> 。</small></big></li>\n</ul>\n\n<p>实现 <code>NumMatrix</code> 类：</p>\n\n<ul>\n\t<li><code>NumMatrix(int[][] matrix)</code>&nbsp;给定整数矩阵 <code>matrix</code> 进行初始化</li>\n\t<li><code>int sumRegion(int row1, int col1, int row2, int col2)</code>&nbsp;返回<big><small>左上角</small></big><big><small> <code>(row1,&nbsp;col1)</code>&nbsp;、右下角&nbsp;<code>(row2,&nbsp;col2)</code></small></big>&nbsp;的子矩阵的元素总和。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://pic.leetcode-cn.com/1626332422-wUpUHT-image.png\" style=\"width: 200px;\" /></p>\n\n<pre>\n<strong>输入:</strong> \n[&quot;NumMatrix&quot;,&quot;sumRegion&quot;,&quot;sumRegion&quot;,&quot;sumRegion&quot;]\n[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]\n<strong>输出:</strong> \n[null, 8, 11, 12]\n\n<strong>解释:</strong>\nNumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]]);\nnumMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和)\nnumMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和)\nnumMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和)\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m,&nbsp;n &lt;=&nbsp;200</code><meta charset=\"UTF-8\" /></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= matrix[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= row1 &lt;= row2 &lt; m</code></li>\n\t<li><code>0 &lt;= col1 &lt;= col2 &lt; n</code></li>\n\t<li><meta charset=\"UTF-8\" />最多调用 <code>10<sup>4</sup></code> 次&nbsp;<code>sumRegion</code> 方法</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 304&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/range-sum-query-2d-immutable/\">https://leetcode-cn.com/problems/range-sum-query-2d-immutable/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2955.字符串中的变位词",
        "hardRate": "MEDIUM",
        "passRate": "51.46%",
        "problemsUrl": "https://leetcode.cn/problems/MPnaiL/",
        "solutionsUrl": "https://leetcode.cn/problems/MPnaiL/solution",
        "problemsDesc": "<p>给定两个字符串&nbsp;<code>s1</code>&nbsp;和&nbsp;<code>s2</code>，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code><strong>&nbsp;</strong>的某个变位词。</p>\n\n<p>换句话说，第一个字符串的排列之一是第二个字符串的 <strong>子串</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;\n<strong>输出: </strong>True\n<strong>解释:</strong> s2 包含 s1 的排列之一 (&quot;ba&quot;).\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;\n<strong>输出:</strong> False\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s1</code> 和 <code>s2</code> 仅包含小写字母</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 567&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/permutation-in-string/\">https://leetcode-cn.com/problems/permutation-in-string/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2956.字符串中的所有变位词",
        "hardRate": "MEDIUM",
        "passRate": "61.70%",
        "problemsUrl": "https://leetcode.cn/problems/VabMRr/",
        "solutionsUrl": "https://leetcode.cn/problems/VabMRr/solution",
        "problemsDesc": "<p>给定两个字符串&nbsp;<code>s</code>&nbsp;和<b>&nbsp;</b><code>p</code>，找到&nbsp;<code>s</code><strong>&nbsp;</strong>中所有 <code>p</code> 的&nbsp;<strong>变位词&nbsp;</strong>的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>\n\n<p><strong>变位词 </strong>指字母相同，但排列不同的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入: </strong>s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;\n<strong>输出: </strong>[0,6]\n<strong>解释:</strong>\n起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的变位词。\n起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的变位词。\n</pre>\n\n<p><strong>&nbsp;示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>s = &quot;abab&quot;, p = &quot;ab&quot;\n<strong>输出: </strong>[0,1,2]\n<strong>解释:</strong>\n起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的变位词。\n起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的变位词。\n起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的变位词。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, p.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>s</code>&nbsp;和 <code>p</code> 仅包含小写字母</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 438&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/\" style=\"background-color: rgb(255, 255, 255);\">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2957.不含重复字符的最长子字符串",
        "hardRate": "MEDIUM",
        "passRate": "47.56%",
        "problemsUrl": "https://leetcode.cn/problems/wtcaE1/",
        "solutionsUrl": "https://leetcode.cn/problems/wtcaE1/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的&nbsp;<strong>最长连续子字符串&nbsp;</strong>的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = &quot;abcabcbb&quot;\n<strong>输出: </strong>3 \n<strong>解释:</strong> 因为无重复字符的最长子字符串是 <code>&quot;abc&quot;，所以其</code>长度为 3。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = &quot;bbbbb&quot;\n<strong>输出: </strong>1\n<strong>解释: </strong>因为无重复字符的最长子字符串是 <code>&quot;b&quot;</code>，所以其长度为 1。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = &quot;pwwkew&quot;\n<strong>输出: </strong>3\n<strong>解释: </strong>因为无重复字符的最长子串是&nbsp;<code>&quot;wke&quot;</code>，所以其长度为 3。\n&nbsp;    请注意，你的答案必须是 <strong>子串 </strong>的长度，<code>&quot;pwke&quot;</code>&nbsp;是一个<em>子序列，</em>不是子串。\n</pre>\n\n<p><strong>示例 4:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = &quot;&quot;\n<strong>输出: </strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code>&nbsp;由英文字母、数字、符号和空格组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 3&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2958.含有所有字符的最短字符串",
        "hardRate": "HARD",
        "passRate": "50.88%",
        "problemsUrl": "https://leetcode.cn/problems/M1oyTv/",
        "solutionsUrl": "https://leetcode.cn/problems/M1oyTv/solution",
        "problemsDesc": "<p>给定两个字符串 <code>s</code> 和&nbsp;<code>t</code> 。返回 <code>s</code> 中包含&nbsp;<code>t</code>&nbsp;的所有字符的最短子字符串。如果 <code>s</code> 中不存在符合条件的子字符串，则返回空字符串 <code>&quot;&quot;</code> 。</p>\n\n<p>如果 <code>s</code> 中存在多个符合条件的子字符串，返回任意一个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>注意： </strong>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;\n<strong>输出：</strong>&quot;BANC&quot; \n<strong>解释：</strong>最短子字符串 &quot;BANC&quot; 包含了字符串 t 的所有字符 &#39;A&#39;、&#39;B&#39;、&#39;C&#39;</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;a&quot;, t = &quot;a&quot;\n<strong>输出：</strong>&quot;a&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;a&quot;, t = &quot;aa&quot;\n<strong>输出：</strong>&quot;&quot;\n<strong>解释：</strong>t 中两个字符 &#39;a&#39; 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能设计一个在 <code>o(n)</code> 时间内解决此问题的算法吗？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 76&nbsp;题相似（本题答案不唯一）：<a href=\"https://leetcode-cn.com/problems/minimum-window-substring/\">https://leetcode-cn.com/problems/minimum-window-substring/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2959.有效的回文",
        "hardRate": "EASY",
        "passRate": "51.53%",
        "problemsUrl": "https://leetcode.cn/problems/XltzEq/",
        "solutionsUrl": "https://leetcode.cn/problems/XltzEq/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code> ，验证 <code>s</code>&nbsp;是否是&nbsp;<strong>回文串&nbsp;</strong>，只考虑字母和数字字符，可以忽略字母的大小写。</p>\n\n<p>本题中，将空字符串定义为有效的&nbsp;<strong>回文串&nbsp;</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>s =<strong> </strong>&quot;A man, a plan, a canal: Panama&quot;\n<strong>输出:</strong> true\n<strong>解释：</strong>&quot;amanaplanacanalpanama&quot; 是回文串</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = &quot;race a car&quot;\n<strong>输出:</strong> false\n解释：&quot;raceacar&quot; 不是回文串</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li>字符串 <code>s</code> 由 ASCII 字符组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 125&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/valid-palindrome/\">https://leetcode-cn.com/problems/valid-palindrome/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2960.最多删除一个字符得到回文",
        "hardRate": "EASY",
        "passRate": "45.60%",
        "problemsUrl": "https://leetcode.cn/problems/RQku0D/",
        "solutionsUrl": "https://leetcode.cn/problems/RQku0D/solution",
        "problemsDesc": "<p>给定一个非空字符串&nbsp;<code>s</code>，请判断如果&nbsp;<strong>最多 </strong>从字符串中删除一个字符能否得到一个回文字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = &quot;aba&quot;\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = &quot;abca&quot;\n<strong>输出:</strong> true\n<strong>解释:</strong> 可以删除 &quot;c&quot; 字符 或者 &quot;b&quot; 字符\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = &quot;abc&quot;\n<strong>输出:</strong> false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 680&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/valid-palindrome-ii/\">https://leetcode-cn.com/problems/valid-palindrome-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2961.回文子字符串的个数",
        "hardRate": "MEDIUM",
        "passRate": "71.67%",
        "problemsUrl": "https://leetcode.cn/problems/a7VOhD/",
        "solutionsUrl": "https://leetcode.cn/problems/a7VOhD/solution",
        "problemsDesc": "<p>给定一个字符串 <code>s</code> ，请计算这个字符串中有多少个回文子字符串。</p>\n\n<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\"\n<strong>输出：</strong>3\n<strong>解释：</strong>三个回文子串: \"a\", \"b\", \"c\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s =<strong> </strong>\"aaa\"\n<strong>输出：</strong>6\n<strong>解释：</strong>6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\"</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 647 题相同：<a href=\"https://leetcode-cn.com/problems/palindromic-substrings/\">https://leetcode-cn.com/problems/palindromic-substrings/</a>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2962.删除链表的倒数第 n 个结点",
        "hardRate": "MEDIUM",
        "passRate": "54.22%",
        "problemsUrl": "https://leetcode.cn/problems/SLwz0R/",
        "solutionsUrl": "https://leetcode.cn/problems/SLwz0R/solution",
        "problemsDesc": "<p>给定一个链表，删除链表的倒数第&nbsp;<code>n</code><em>&nbsp;</em>个结点，并且返回链表的头结点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg\" style=\"width: 542px; height: 222px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], n = 2\n<strong>输出：</strong>[1,2,3,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1], n = 1\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2], n = 1\n<strong>输出：</strong>[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中结点的数目为 <code>sz</code></li>\n\t<li><code>1 &lt;= sz &lt;= 30</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>1 &lt;= n &lt;= sz</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>能尝试使用一趟扫描实现吗？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 19&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2963.链表中环的入口节点",
        "hardRate": "MEDIUM",
        "passRate": "55.84%",
        "problemsUrl": "https://leetcode.cn/problems/c32eOV/",
        "solutionsUrl": "https://leetcode.cn/problems/c32eOV/solution",
        "problemsDesc": "<p>给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 <code>next</code> 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回&nbsp;<code>null</code>。</p>\n\n<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意，<code>pos</code> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</strong></p>\n\n<p><strong>说明：</strong>不允许修改给定的链表。</p>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png\" style=\"height: 97px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [3,2,0,-4], pos = 1\n<strong>输出：</strong>返回索引为 1 的链表节点\n<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png\" style=\"height: 74px; width: 141px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2], pos = 0\n<strong>输出：</strong>返回索引为 0 的链表节点\n<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png\" style=\"height: 45px; width: 45px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1], pos = -1\n<strong>输出：</strong>返回 null\n<strong>解释：</strong>链表中没有环。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目范围在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>是否可以使用 <code>O(1)</code> 空间解决此题？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 142&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/\">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2964.两个链表的第一个重合节点",
        "hardRate": "EASY",
        "passRate": "70.03%",
        "problemsUrl": "https://leetcode.cn/problems/3u1WK4/",
        "solutionsUrl": "https://leetcode.cn/problems/3u1WK4/solution",
        "problemsDesc": "<p>给定两个单链表的头节点&nbsp;<code>headA</code> 和 <code>headB</code> ，请找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p>\n\n<p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>\n\n<p><a href=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\" style=\"height: 130px; width: 400px;\" /></a></p>\n\n<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>\n\n<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png\" style=\"height: 130px; width: 400px;\" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n<strong>输出：</strong>Intersected at &#39;8&#39;\n<strong>解释：</strong>相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png\" style=\"height: 136px; width: 350px;\" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal&nbsp;= 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n<strong>输出：</strong>Intersected at &#39;2&#39;\n<strong>解释：</strong>相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png\" style=\"height: 126px; width: 200px;\" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n<strong>输出：</strong>null\n<strong>解释：</strong>从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>listA</code> 中节点数目为 <code>m</code></li>\n\t<li><code>listB</code> 中节点数目为 <code>n</code></li>\n\t<li><code>0 &lt;= m, n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= skipA &lt;= m</code></li>\n\t<li><code>0 &lt;= skipB &lt;= n</code></li>\n\t<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>\n\t<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 160&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2965.反转链表",
        "hardRate": "EASY",
        "passRate": "75.36%",
        "problemsUrl": "https://leetcode.cn/problems/UHnkqh/",
        "solutionsUrl": "https://leetcode.cn/problems/UHnkqh/solution",
        "problemsDesc": "<p>给定单链表的头节点 <code>head</code> ，请反转链表，并返回反转后的链表的头节点。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg\" style=\"width: 302px; \" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5]\n<strong>输出：</strong>[5,4,3,2,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg\" style=\"width: 102px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2]\n<strong>输出：</strong>[2,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = []\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>\n\t<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 206&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\">https://leetcode-cn.com/problems/reverse-linked-list/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2966.链表中的两数相加",
        "hardRate": "MEDIUM",
        "passRate": "58.32%",
        "problemsUrl": "https://leetcode.cn/problems/lMSNwu/",
        "solutionsUrl": "https://leetcode.cn/problems/lMSNwu/solution",
        "problemsDesc": "<p>给定两个 <strong>非空链表</strong> <code>l1</code>和 <code>l2</code>&nbsp;来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>\n\n<p>可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例1：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626420025-fZfzMX-image.png\" style=\"width: 302px; \" /></p>\n\n<pre>\n<strong>输入：</strong>l1 = [7,2,4,3], l2 = [5,6,4]\n<strong>输出：</strong>[7,8,0,7]\n</pre>\n\n<p><strong>示例2：</strong></p>\n\n<pre>\n<strong>输入：</strong>l1 = [2,4,3], l2 = [5,6,4]\n<strong>输出：</strong>[8,0,7]\n</pre>\n\n<p><strong>示例3：</strong></p>\n\n<pre>\n<strong>输入：</strong>l1 = [0], l2 = [0]\n<strong>输出：</strong>[0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表的长度范围为<code> [1, 100]</code></li>\n\t<li><code>0 &lt;= node.val &lt;= 9</code></li>\n\t<li>输入数据保证链表代表的数字无前导 0</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转。</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 445&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/add-two-numbers-ii/\">https://leetcode-cn.com/problems/add-two-numbers-ii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2967.重排链表",
        "hardRate": "MEDIUM",
        "passRate": "66.49%",
        "problemsUrl": "https://leetcode.cn/problems/LGjMqU/",
        "solutionsUrl": "https://leetcode.cn/problems/LGjMqU/solution",
        "problemsDesc": "<p>给定一个单链表 <code>L</code><em> </em>的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p>\n\n<p><code>&nbsp;L<sub>0&nbsp;</sub>&rarr; L<sub>1&nbsp;</sub>&rarr; &hellip; &rarr; L<sub>n-1&nbsp;</sub>&rarr; L<sub>n&nbsp;</sub></code><br />\n请将其重新排列后变为：</p>\n\n<p><code>L<sub>0&nbsp;</sub>&rarr;&nbsp;L<sub>n&nbsp;</sub>&rarr;&nbsp;L<sub>1&nbsp;</sub>&rarr;&nbsp;L<sub>n-1&nbsp;</sub>&rarr;&nbsp;L<sub>2&nbsp;</sub>&rarr;&nbsp;L<sub>n-2&nbsp;</sub>&rarr; &hellip;</code></p>\n\n<p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png\" style=\"width: 240px; \" /></p>\n\n<pre>\n<strong>输入: </strong>head = [1,2,3,4]\n<strong>输出: </strong>[1,4,2,3]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626420320-YUiulT-image.png\" style=\"width: 320px; \" /></p>\n\n<pre>\n<strong>输入: </strong>head = [1,2,3,4,5]\n<strong>输出: </strong>[1,5,2,4,3]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表的长度范围为 <code>[1, 5 * 10<sup>4</sup>]</code></li>\n\t<li><code>1 &lt;= node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 143&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/reorder-list/\">https://leetcode-cn.com/problems/reorder-list/</a>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2968.回文链表",
        "hardRate": "EASY",
        "passRate": "61.03%",
        "problemsUrl": "https://leetcode.cn/problems/aMhZSa/",
        "solutionsUrl": "https://leetcode.cn/problems/aMhZSa/solution",
        "problemsDesc": "<p>给定一个链表的 <strong>头节点&nbsp;</strong><code>head</code><strong>&nbsp;，</strong>请判断其是否为回文链表。</p>\n\n<p>如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626421737-LjXceN-image.png\" /></strong></p>\n\n<pre>\n<strong>输入:</strong> head = [1,2,3,3,2,1]\n<strong>输出:</strong> true</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626422231-wgvnWh-image.png\" style=\"width: 138px; height: 62px;\" /></strong></p>\n\n<pre>\n<strong>输入:</strong> head = [1,2]\n<strong>输出:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表 L 的长度范围为 <code>[1, 10<sup><span style=\"font-size: 9.449999809265137px;\">5</span></sup>]</code></li>\n\t<li><code>0&nbsp;&lt;= node.val &lt;= 9</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>能否用&nbsp;O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 234&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/palindrome-linked-list/\">https://leetcode-cn.com/problems/palindrome-linked-list/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2969.展平多级双向链表",
        "hardRate": "MEDIUM",
        "passRate": "60.00%",
        "problemsUrl": "https://leetcode.cn/problems/Qv1Da2/",
        "solutionsUrl": "https://leetcode.cn/problems/Qv1Da2/solution",
        "problemsDesc": "<p>多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p>\n\n<p>给定位于列表第一级的头节点，请扁平化列表，即将这样的多级双向链表展平成普通的双向链表，使所有结点出现在单级双链表中。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]\n<strong>输出：</strong>[1,2,3,7,8,11,12,9,10,4,5,6]\n<strong>解释：\n</strong>\n输入的多级列表如下图所示：\n\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlist.png\" style=\"height: 363px; width: 640px;\" />\n\n扁平化后的链表如下图：\n\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlistflattened.png\" style=\"height: 80px; width: 1100px;\" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,null,3]\n<strong>输出：</strong>[1,3,2]\n<strong>解释：\n\n</strong>输入的多级列表如下图所示：\n\n  1---2---NULL\n  |\n  3---NULL\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = []\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>如何表示测试用例中的多级链表？</strong></p>\n\n<p>以 <strong>示例 1</strong> 为例：</p>\n\n<pre>\n 1---2---3---4---5---6--NULL\n         |\n         7---8---9---10--NULL\n             |\n             11--12--NULL</pre>\n\n<p>序列化其中的每一级之后：</p>\n\n<pre>\n[1,2,3,4,5,6,null]\n[7,8,9,10,null]\n[11,12,null]\n</pre>\n\n<p>为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。</p>\n\n<pre>\n[1,2,3,4,5,6,null]\n[null,null,7,8,9,10,null]\n[null,11,12,null]\n</pre>\n\n<p>合并所有序列化结果，并去除末尾的 null 。</p>\n\n<pre>\n[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>节点数目不超过 <code>1000</code></li>\n\t<li><code>1 &lt;= Node.val &lt;= 10^5</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 430&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/\">https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2970.排序的循环链表",
        "hardRate": "MEDIUM",
        "passRate": "33.27%",
        "problemsUrl": "https://leetcode.cn/problems/4ueAj6/",
        "solutionsUrl": "https://leetcode.cn/problems/4ueAj6/solution",
        "problemsDesc": "<p>给定<strong>循环单调非递减列表</strong>中的一个点，写一个函数向这个列表中插入一个新元素&nbsp;<code>insertVal</code> ，使这个列表仍然是循环升序的。</p>\n\n<p>给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针。</p>\n\n<p>如果有多个满足条件的插入位置，可以选择任意一个位置插入新的值，插入后整个列表仍然保持有序。</p>\n\n<p>如果列表为空（给定的节点是 <code>null</code>），需要创建一个循环有序列表并返回这个节点。否则。请返回原先给定的节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/19/example_1_before_65p.jpg\" style=\"height: 149px; width: 250px;\" /><br />\n&nbsp;</p>\n\n<pre>\n<strong>输入：</strong>head = [3,4,1], insertVal = 2\n<strong>输出：</strong>[3,4,1,2]\n<strong>解释：</strong>在上图中，有一个包含三个元素的循环有序列表，你获得值为 3 的节点的指针，我们需要向表中插入元素 2 。新插入的节点应该在 1 和 3 之间，插入之后，整个列表如上图所示，最后返回节点 3 。\n\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/19/example_1_after_65p.jpg\" style=\"height: 149px; width: 250px;\" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [], insertVal = 1\n<strong>输出：</strong>[1]\n<strong>解释：</strong>列表为空（给定的节点是 <code>null</code>），创建一个循环有序列表并返回这个节点。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1], insertVal = 0\n<strong>输出：</strong>[1,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= Number of Nodes &lt;= 5 * 10^4</code></li>\n\t<li><code><font face=\"monospace\">-10^6 &lt;= Node.val &lt;= 10^6</font></code></li>\n\t<li><code>-10^6 &lt;=&nbsp;insertVal &lt;= 10^6</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 708&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/insert-into-a-sorted-circular-linked-list/\">https://leetcode-cn.com/problems/insert-into-a-sorted-circular-linked-list/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2971.插入、删除和随机访问都是 O(1) 的容器",
        "hardRate": "MEDIUM",
        "passRate": "53.81%",
        "problemsUrl": "https://leetcode.cn/problems/FortPu/",
        "solutionsUrl": "https://leetcode.cn/problems/FortPu/solution",
        "problemsDesc": "<p>设计一个支持在<em>平均&nbsp;</em>时间复杂度 <strong>O(1)</strong>&nbsp;下，执行以下操作的数据结构：</p>\n\n<ul>\n\t<li><code>insert(val)</code>：当元素 <code>val</code> 不存在时返回 <code>true</code>&nbsp;，并向集合中插入该项，否则返回 <code>false</code> 。</li>\n\t<li><code>remove(val)</code>：当元素 <code>val</code> 存在时返回 <code>true</code>&nbsp;，并从集合中移除该项，否则返回 <code>false</code>&nbsp;。</li>\n\t<li><code>getRandom</code>：随机返回现有集合中的一项。每个元素应该有&nbsp;<strong>相同的概率&nbsp;</strong>被返回。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 :</strong></p>\n\n<pre>\n<strong>输入: </strong>inputs = [&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]\n[[], [1], [2], [2], [], [1], [2], []]\n<strong>输出: </strong>[null, true, false, true, 2, true, false, 2]\n<strong>解释:\n</strong>RandomizedSet randomSet = new RandomizedSet();  // 初始化一个空的集合\nrandomSet.insert(1); // 向集合中插入 1 ， 返回 true 表示 1 被成功地插入\n\nrandomSet.remove(2); // 返回 false，表示集合中不存在 2 \n\nrandomSet.insert(2); // 向集合中插入 2 返回 true ，集合现在包含 [1,2] \n\nrandomSet.getRandom(); // getRandom 应随机返回 1 或 2 \n  \nrandomSet.remove(1); // 从集合中移除 1 返回 true 。集合现在包含 [2] \n\nrandomSet.insert(2); // 2 已在集合中，所以返回 false \n\nrandomSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= val &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n\t<li>最多进行<code> 2 * 10<sup>5</sup></code> 次&nbsp;<code>insert</code> ， <code>remove</code> 和 <code>getRandom</code> 方法调用</li>\n\t<li>当调用&nbsp;<code>getRandom</code> 方法时，集合中至少有一个元素</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 380&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/insert-delete-getrandom-o1/\">https://leetcode-cn.com/problems/insert-delete-getrandom-o1/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2972.最近最少使用缓存",
        "hardRate": "MEDIUM",
        "passRate": "55.60%",
        "problemsUrl": "https://leetcode.cn/problems/OrIXps/",
        "solutionsUrl": "https://leetcode.cn/problems/OrIXps/solution",
        "problemsDesc": "<div class=\"title__3Vvk\">\n<p>运用所掌握的数据结构，设计和实现一个&nbsp; <a href=\"https://baike.baidu.com/item/LRU\" target=\"_blank\">LRU (Least Recently Used，最近最少使用) 缓存机制</a> 。</p>\n\n<p>实现 <code>LRUCache</code> 类：</p>\n\n<ul>\n\t<li><code>LRUCache(int capacity)</code> 以正整数作为容量&nbsp;<code>capacity</code> 初始化 LRU 缓存</li>\n\t<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>\n\t<li><code>void put(int key, int value)</code>&nbsp;如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n<strong>输出</strong>\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n<strong>解释</strong>\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // 缓存是 {1=1}\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\nlRUCache.get(1);    // 返回 1\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\nlRUCache.get(2);    // 返回 -1 (未找到)\nlRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\nlRUCache.get(1);    // 返回 -1 (未找到)\nlRUCache.get(3);    // 返回 3\nlRUCache.get(4);    // 返回 4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= capacity &lt;= 3000</code></li>\n\t<li><code>0 &lt;= key &lt;= 10000</code></li>\n\t<li><code>0 &lt;= value &lt;= 10<sup>5</sup></code></li>\n\t<li>最多调用 <code>2 * 10<sup>5</sup></code> 次 <code>get</code> 和 <code>put</code></li>\n</ul>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶</strong>：是否可以在&nbsp;<code>O(1)</code> 时间复杂度内完成这两种操作？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 146&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/lru-cache/\">https://leetcode-cn.com/problems/lru-cache/</a>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2973.有效的变位词",
        "hardRate": "EASY",
        "passRate": "59.70%",
        "problemsUrl": "https://leetcode.cn/problems/dKk3P7/",
        "solutionsUrl": "https://leetcode.cn/problems/dKk3P7/solution",
        "problemsDesc": "<p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断它们是不是一组变位词（字母异位词）。</p>\n\n<p><strong>注意：</strong>若&nbsp;<code><em>s</em></code> 和 <code><em>t</em></code><em>&nbsp;</em>中每个字符出现的次数都相同且<strong>字符顺序不完全相同</strong>，则称&nbsp;<code><em>s</em></code> 和 <code><em>t</em></code><em>&nbsp;</em>互为变位词（字母异位词）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = &quot;anagram&quot;, t = &quot;nagaram&quot;\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = &quot;rat&quot;, t = &quot;car&quot;\n<strong>输出: </strong>false</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = &quot;a&quot;, t = &quot;a&quot;\n<strong>输出: </strong>false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code>&nbsp;and&nbsp;<code>t</code>&nbsp;仅包含小写字母</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶:&nbsp;</strong>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 242&nbsp;题相似（字母异位词定义不同）：<a href=\"https://leetcode-cn.com/problems/valid-anagram/\">https://leetcode-cn.com/problems/valid-anagram/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2974.变位词组",
        "hardRate": "MEDIUM",
        "passRate": "74.64%",
        "problemsUrl": "https://leetcode.cn/problems/sfvd7V/",
        "solutionsUrl": "https://leetcode.cn/problems/sfvd7V/solution",
        "problemsDesc": "<p>给定一个字符串数组 <code>strs</code> ，将&nbsp;<strong>变位词&nbsp;</strong>组合在一起。 可以按任意顺序返回结果列表。</p>\n\n<p><strong>注意：</strong>若两个字符串中每个字符出现的次数都相同，则称它们互为变位词。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> strs = <code>[&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</code>\n<strong>输出: </strong>[[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> strs = <code>[&quot;&quot;]</code>\n<strong>输出: </strong>[[&quot;&quot;]]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> strs = <code>[&quot;a&quot;]</code>\n<strong>输出: </strong>[[&quot;a&quot;]]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>\n\t<li><code>strs[i]</code>&nbsp;仅包含小写字母</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 49&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/group-anagrams/\">https://leetcode-cn.com/problems/group-anagrams/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2975.外星语言是否排序",
        "hardRate": "EASY",
        "passRate": "55.75%",
        "problemsUrl": "https://leetcode.cn/problems/lwyVBB/",
        "solutionsUrl": "https://leetcode.cn/problems/lwyVBB/solution",
        "problemsDesc": "<p>某种外星语也使用英文小写字母，但可能顺序 <code>order</code> 不同。字母表的顺序（<code>order</code>）是一些小写字母的排列。</p>\n\n<p>给定一组用外星语书写的单词 <code>words</code>，以及其字母表的顺序 <code>order</code>，只有当给定的单词在这种外星语中按字典序排列时，返回 <code>true</code>；否则，返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot;\n<strong>输出：</strong>true\n<strong>解释：</strong>在该语言的字母表中，&#39;h&#39; 位于 &#39;l&#39; 之前，所以单词序列是按字典序排列的。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order = &quot;worldabcefghijkmnpqstuvxyz&quot;\n<strong>输出：</strong>false\n<strong>解释：</strong>在该语言的字母表中，&#39;d&#39; 位于 &#39;l&#39; 之后，那么 words[0] &gt; words[1]，因此单词序列不是按字典序排列的。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [&quot;apple&quot;,&quot;app&quot;], order = &quot;abcdefghijklmnopqrstuvwxyz&quot;\n<strong>输出：</strong>false\n<strong>解释：</strong>当前三个字符 &quot;app&quot; 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 &quot;apple&quot; &gt; &quot;app&quot;，因为 &#39;l&#39; &gt; &#39;&empty;&#39;，其中 &#39;&empty;&#39; 是空白字符，定义为比任何其他字符都小（<a href=\"https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E5%BA%8F\" target=\"_blank\">更多信息</a>）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 20</code></li>\n\t<li><code>order.length == 26</code></li>\n\t<li>在&nbsp;<code>words[i]</code>&nbsp;和&nbsp;<code>order</code>&nbsp;中的所有字符都是英文小写字母。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 953&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/verifying-an-alien-dictionary/\">https://leetcode-cn.com/problems/verifying-an-alien-dictionary/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2976.最小时间差",
        "hardRate": "MEDIUM",
        "passRate": "65.97%",
        "problemsUrl": "https://leetcode.cn/problems/569nqc/",
        "solutionsUrl": "https://leetcode.cn/problems/569nqc/solution",
        "problemsDesc": "<p>给定一个 24 小时制（小时:分钟 <strong>&quot;HH:MM&quot;</strong>）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>timePoints = [&quot;23:59&quot;,&quot;00:00&quot;]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>timePoints = [&quot;00:00&quot;,&quot;23:59&quot;,&quot;00:00&quot;]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= timePoints &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>timePoints[i]</code> 格式为 <strong>&quot;HH:MM&quot;</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 539&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/minimum-time-difference/\">https://leetcode-cn.com/problems/minimum-time-difference/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2977.后缀表达式",
        "hardRate": "MEDIUM",
        "passRate": "55.38%",
        "problemsUrl": "https://leetcode.cn/problems/8Zf90G/",
        "solutionsUrl": "https://leetcode.cn/problems/8Zf90G/solution",
        "problemsDesc": "<p>根据<a href=\"https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437\" target=\"_blank\"> 逆波兰表示法</a>，求该后缀表达式的计算结果。</p>\n\n<p>有效的算符包括&nbsp;<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>&nbsp;。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>整数除法只保留整数部分。</li>\n\t<li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]\n<strong>输出：</strong>9\n<strong>解释：</strong>该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]\n<strong>输出：</strong>6\n<strong>解释：</strong>该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre>\n<strong>输入：</strong>tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]\n<strong>输出：</strong>22\n<strong>解释：</strong>\n该算式转化为常见的中缀算术表达式为：\n  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tokens.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>tokens[i]</code> 要么是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），要么是一个在范围 <code>[-200, 200]</code> 内的整数</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>逆波兰表达式：</strong></p>\n\n<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>\n\n<ul>\n\t<li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li>\n\t<li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li>\n</ul>\n\n<p>逆波兰表达式主要有以下两个优点：</p>\n\n<ul>\n\t<li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li>\n\t<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 150&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/\">https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2978.小行星碰撞",
        "hardRate": "MEDIUM",
        "passRate": "44.84%",
        "problemsUrl": "https://leetcode.cn/problems/XagZNi/",
        "solutionsUrl": "https://leetcode.cn/problems/XagZNi/solution",
        "problemsDesc": "<p>给定一个整数数组 <code>asteroids</code>，表示在同一行的小行星。</p>\n\n<p>对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。</p>\n\n<p>找出碰撞后剩下的所有小行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>asteroids = [5,10,-5]\n<strong>输出：</strong>[5,10]\n<b>解释：</b>10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>asteroids = [8,-8]\n<strong>输出：</strong>[]\n<b>解释：</b>8 和 -8 碰撞后，两者都发生爆炸。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>asteroids = [10,2,-5]\n<strong>输出：</strong>[10]\n<b>解释：</b>2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下 10 。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>asteroids = [-2,-1,1,2]\n<strong>输出：</strong>[-2,-1,1,2]\n<b>解释</b><strong>：</strong>-2 和 -1 向左移动，而 1 和 2 向右移动。 由于移动方向相同的行星不会发生碰撞，所以最终没有行星发生碰撞。 </pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= asteroids.length&nbsp;&lt;= 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= asteroids[i] &lt;= 1000</code></li>\n\t<li><code>asteroids[i] != 0</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 735&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/asteroid-collision/\">https://leetcode-cn.com/problems/asteroid-collision/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2979.每日温度",
        "hardRate": "MEDIUM",
        "passRate": "76.24%",
        "problemsUrl": "https://leetcode.cn/problems/iIQa4I/",
        "solutionsUrl": "https://leetcode.cn/problems/iIQa4I/solution",
        "problemsDesc": "<p>请根据每日 <code>气温</code> 列表 <code>temperatures</code>&nbsp;，重新生成一个列表，要求其对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用&nbsp;<code>0</code> 来代替。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>temperatures</code> = [73,74,75,71,69,72,76,73]\n<strong>输出:</strong>&nbsp;[1,1,4,2,1,1,0,0]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> temperatures = [30,40,50,60]\n<strong>输出:</strong>&nbsp;[1,1,1,0]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> temperatures = [30,60,90]\n<strong>输出: </strong>[1,1,0]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;temperatures.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>30 &lt;=&nbsp;temperatures[i]&nbsp;&lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 739&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/daily-temperatures/\">https://leetcode-cn.com/problems/daily-temperatures/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2980.直方图最大矩形面积",
        "hardRate": "HARD",
        "passRate": "50.71%",
        "problemsUrl": "https://leetcode.cn/problems/0ynMMM/",
        "solutionsUrl": "https://leetcode.cn/problems/0ynMMM/solution",
        "problemsDesc": "<p>给定非负整数数组 <code>heights</code>&nbsp;，数组中的数字用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 <code>1</code> 。</p>\n\n<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>heights = [2,1,5,6,2,3]\n<strong>输出：</strong>10\n<strong>解释：</strong>最大的矩形为图中红色区域，面积为 10\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong> heights = [2,4]\n<b>输出：</b> 4</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= heights.length &lt;=10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= heights[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 84&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/\">https://leetcode-cn.com/problems/largest-rectangle-in-histogram/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2981.矩阵中最大的矩形",
        "hardRate": "HARD",
        "passRate": "58.22%",
        "problemsUrl": "https://leetcode.cn/problems/PLYXKQ/",
        "solutionsUrl": "https://leetcode.cn/problems/PLYXKQ/solution",
        "problemsDesc": "<p>给定一个由&nbsp;<code>0</code> 和 <code>1</code>&nbsp;组成的矩阵 <code>matrix</code>&nbsp;，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p>\n\n<p><strong>注意：</strong>此题 <code>matrix</code>&nbsp;输入格式为一维 <code>01</code> 字符串数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg\" style=\"width: 402px; height: 322px;\" /></p>\n\n<pre>\n<strong>输入：</strong>matrix = [\"10100\",\"10111\",\"11111\",\"10010\"]\n<strong>输出：</strong>6\n<strong>解释：</strong>最大矩形如上图所示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = []\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [\"0\"]\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [\"1\"]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [\"00\"]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rows == matrix.length</code></li>\n\t<li><code>cols == matrix[0].length</code></li>\n\t<li><code>0 &lt;= row, cols &lt;= 200</code></li>\n\t<li><code>matrix[i][j]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 85 题相同（输入参数格式不同）：&nbsp;<a href=\"https://leetcode-cn.com/problems/maximal-rectangle/\">https://leetcode-cn.com/problems/maximal-rectangle/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2982.滑动窗口的平均值",
        "hardRate": "EASY",
        "passRate": "77.81%",
        "problemsUrl": "https://leetcode.cn/problems/qIsx9U/",
        "solutionsUrl": "https://leetcode.cn/problems/qIsx9U/solution",
        "problemsDesc": "<p>给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算滑动窗口里所有数字的平均值。</p>\n\n<p>实现 <code>MovingAverage</code> 类：</p>\n\n<ul>\n\t<li><code>MovingAverage(int size)</code> 用窗口大小 <code>size</code> 初始化对象。</li>\n\t<li><code>double next(int val)</code>&nbsp;成员函数 <code>next</code>&nbsp;每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后 <code>size</code> 个值的移动平均值，即滑动窗口里所有数字的平均值。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\ninputs = [&quot;MovingAverage&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;, &quot;next&quot;]\ninputs = [[3], [1], [10], [3], [5]]\n<strong>输出：</strong>\n[null, 1.0, 5.5, 4.66667, 6.0]\n\n<strong>解释：</strong>\nMovingAverage movingAverage = new MovingAverage(3);\nmovingAverage.next(1); // 返回 1.0 = 1 / 1\nmovingAverage.next(10); // 返回 5.5 = (1 + 10) / 2\nmovingAverage.next(3); // 返回 4.66667 = (1 + 10 + 3) / 3\nmovingAverage.next(5); // 返回 6.0 = (10 + 3 + 5) / 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= size &lt;= 1000</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= val &lt;= 10<sup>5</sup></code></li>\n\t<li>最多调用 <code>next</code> 方法 <code>10<sup>4</sup></code> 次</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 346&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/moving-average-from-data-stream/\">https://leetcode-cn.com/problems/moving-average-from-data-stream/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2983.最近请求次数",
        "hardRate": "EASY",
        "passRate": "82.05%",
        "problemsUrl": "https://leetcode.cn/problems/H8086Q/",
        "solutionsUrl": "https://leetcode.cn/problems/H8086Q/solution",
        "problemsDesc": "<p>写一个&nbsp;<code>RecentCounter</code>&nbsp;类来计算特定时间范围内最近的请求。</p>\n\n<p>请实现 <code>RecentCounter</code> 类：</p>\n\n<ul>\n\t<li><code>RecentCounter()</code> 初始化计数器，请求数为 0 。</li>\n\t<li><code>int ping(int t)</code> 在时间 <code>t</code> 添加一个新请求，其中 <code>t</code> 表示以毫秒为单位的某个时间，并返回过去 <code>3000</code> 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 <code>[t-3000, t]</code> 内发生的请求数。</li>\n</ul>\n\n<p><strong>保证</strong> 每次对 <code>ping</code> 的调用都使用比之前更大的 <code>t</code> 值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\ninputs = [&quot;RecentCounter&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;]\ninputs = [[], [1], [100], [3001], [3002]]\n<strong>输出：</strong>\n[null, 1, 2, 3, 3]\n\n<strong>解释：</strong>\nRecentCounter recentCounter = new RecentCounter();\nrecentCounter.ping(1);     // requests = [<strong>1</strong>]，范围是 [-2999,1]，返回 1\nrecentCounter.ping(100);   // requests = [<strong>1</strong>, <strong>100</strong>]，范围是 [-2900,100]，返回 2\nrecentCounter.ping(3001);  // requests = [<strong>1</strong>, <strong>100</strong>, <strong>3001</strong>]，范围是 [1,3001]，返回 3\nrecentCounter.ping(3002);  // requests = [1, <strong>100</strong>, <strong>3001</strong>, <strong>3002</strong>]，范围是 [2,3002]，返回 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= t &lt;= 10<sup>9</sup></code></li>\n\t<li>保证每次对 <code>ping</code> 调用所使用的 <code>t</code> 值都 <strong>严格递增</strong></li>\n\t<li>至多调用 <code>ping</code> 方法 <code>10<sup>4</sup></code> 次</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 933&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/number-of-recent-calls/\">https://leetcode-cn.com/problems/number-of-recent-calls/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2984.往完全二叉树添加节点",
        "hardRate": "MEDIUM",
        "passRate": "62.41%",
        "problemsUrl": "https://leetcode.cn/problems/NaqhDT/",
        "solutionsUrl": "https://leetcode.cn/problems/NaqhDT/solution",
        "problemsDesc": "<p>完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大，第 <code>n</code> 层有 <code>2<sup>n-1</sup></code>&nbsp;个节点）的，并且所有的节点都尽可能地集中在左侧。</p>\n\n<p>设计一个用完全二叉树初始化的数据结构&nbsp;<code>CBTInserter</code>，它支持以下几种操作：</p>\n\n<ul>\n\t<li><code>CBTInserter(TreeNode root)</code>&nbsp;使用根节点为&nbsp;<code>root</code>&nbsp;的给定树初始化该数据结构；</li>\n\t<li><code>CBTInserter.insert(int v)</code>&nbsp; 向树中插入一个新节点，节点类型为 <code>TreeNode</code>，值为 <code>v</code> 。使树保持完全二叉树的状态，<strong>并返回插入的新节点的父节点的值</strong>；</li>\n\t<li><code>CBTInserter.get_root()</code> 将返回树的根节点。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>inputs = [&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;get_root&quot;], inputs = [[[1]],[2],[]]\n<strong>输出：</strong>[null,1,[1,2]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>inputs = [&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;insert&quot;,&quot;get_root&quot;], inputs = [[[1,2,3,4,5,6]],[7],[8],[]]\n<strong>输出：</strong>[null,3,4,[1,2,3,4,5,6,7,8]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>最初给定的树是完全二叉树，且包含&nbsp;<code>1</code>&nbsp;到&nbsp;<code>1000</code>&nbsp;个节点。</li>\n\t<li>每个测试用例最多调用&nbsp;<code>CBTInserter.insert</code>&nbsp; 操作&nbsp;<code>10000</code>&nbsp;次。</li>\n\t<li>给定节点或插入节点的每个值都在&nbsp;<code>0</code>&nbsp;到&nbsp;<code>5000</code>&nbsp;之间。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 919&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/complete-binary-tree-inserter/\">https://leetcode-cn.com/problems/complete-binary-tree-inserter/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2985.二叉树每层的最大值",
        "hardRate": "MEDIUM",
        "passRate": "64.15%",
        "problemsUrl": "https://leetcode.cn/problems/hPov7L/",
        "solutionsUrl": "https://leetcode.cn/problems/hPov7L/solution",
        "problemsDesc": "<p>给定一棵二叉树的根节点&nbsp;<code>root</code> ，请找出该二叉树中每一层的最大值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例1：</strong></p>\n\n<pre>\n<strong>输入: </strong>root = [1,3,2,5,3,null,9]\n<strong>输出: </strong>[1,3,9]\n<strong>解释:</strong>\n          1\n         / \\\n        3   2\n       / \\   \\  \n      5   3   9 \n</pre>\n\n<p><strong>示例2：</strong></p>\n\n<pre>\n<strong>输入: </strong>root = [1,2,3]\n<strong>输出: </strong>[1,3]\n<strong>解释:</strong>\n          1\n         / \\\n        2   3\n</pre>\n\n<p><strong>示例3：</strong></p>\n\n<pre>\n<strong>输入: </strong>root = [1]\n<strong>输出: </strong>[1]\n</pre>\n\n<p><strong>示例4：</strong></p>\n\n<pre>\n<strong>输入: </strong>root = [1,null,2]\n<strong>输出: </strong>[1,2]\n<strong>解释:</strong>      \n&nbsp;          1 \n&nbsp;           \\\n&nbsp;            2     \n</pre>\n\n<p><strong>示例5：</strong></p>\n\n<pre>\n<strong>输入: </strong>root = []\n<strong>输出: </strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[0,10<sup>4</sup>]</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>-2<sup>31</sup>&nbsp;&lt;= Node.val &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 515&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/\">https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2986.二叉树最底层最左边的值",
        "hardRate": "MEDIUM",
        "passRate": "79.23%",
        "problemsUrl": "https://leetcode.cn/problems/LwUNpT/",
        "solutionsUrl": "https://leetcode.cn/problems/LwUNpT/solution",
        "problemsDesc": "<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的&nbsp;<strong>最底层&nbsp;最左边&nbsp;</strong>节点的值。</p>\n\n<p>假设二叉树中至少有一个节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg\" style=\"width: 182px; \" /></p>\n\n<pre>\n<strong>输入: </strong>root = [2,1,3]\n<strong>输出: </strong>1\n</pre>\n\n<p><strong>示例 2: </strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg\" style=\"width: 242px; \" /><strong> </strong></p>\n\n<pre>\n<strong>输入: </strong>[1,2,3,4,null,5,6,null,null,7]\n<strong>输出: </strong>7\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[1,10<sup>4</sup>]</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>-2<sup>31</sup>&nbsp;&lt;= Node.val &lt;= 2<sup>31</sup>&nbsp;- 1</code>&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 513&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/find-bottom-left-tree-value/\">https://leetcode-cn.com/problems/find-bottom-left-tree-value/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2987.二叉树的右侧视图",
        "hardRate": "MEDIUM",
        "passRate": "70.53%",
        "problemsUrl": "https://leetcode.cn/problems/WNC0Lk/",
        "solutionsUrl": "https://leetcode.cn/problems/WNC0Lk/solution",
        "problemsDesc": "<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/02/14/tree.jpg\" style=\"width: 270px; \" /></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;[1,2,3,null,5,null,4]\n<strong>输出:</strong>&nbsp;[1,3,4]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;[1,null,3]\n<strong>输出:</strong>&nbsp;[1,3]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;[]\n<strong>输出:</strong>&nbsp;[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[0,100]</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>-100&nbsp;&lt;= Node.val &lt;= 100</code>&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 199&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/binary-tree-right-side-view/\">https://leetcode-cn.com/problems/binary-tree-right-side-view/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2988.二叉树剪枝",
        "hardRate": "MEDIUM",
        "passRate": "68.41%",
        "problemsUrl": "https://leetcode.cn/problems/pOCWxh/",
        "solutionsUrl": "https://leetcode.cn/problems/pOCWxh/solution",
        "problemsDesc": "<p>给定一个二叉树 <strong>根节点</strong>&nbsp;<code>root</code>&nbsp;，树的每个节点的值要么是 <code>0</code>，要么是 <code>1</code>。请剪除该二叉树中所有节点的值为 <code>0</code> 的子树。</p>\n\n<p>节点 <code>node</code> 的子树为&nbsp;<code>node</code> 本身，以及所有 <code>node</code>&nbsp;的后代。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> [1,null,0,0,1]\n<strong>输出: </strong>[1,null,0,null,1] \n<strong>解释:</strong> \n只有红色节点满足条件&ldquo;所有不包含 1 的子树&rdquo;。\n右图为返回的答案。\n\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_2.png\" style=\"width:450px\" />\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> [1,0,1,0,0,0,1]\n<strong>输出: </strong>[1,null,1,null,1]\n<strong>解释:</strong> \n\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_1.png\" style=\"width:450px\" />\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> [1,1,0,1,1,0,1,0]\n<strong>输出: </strong>[1,1,0,1,1,null,1]\n<strong>解释:</strong> \n\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/05/1028.png\" style=\"width:450px\" />\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[1,200]</code></li>\n\t<li>二叉树节点的值只会是 <code>0</code> 或 <code>1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 814&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/binary-tree-pruning/\">https://leetcode-cn.com/problems/binary-tree-pruning/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2989.序列化与反序列化二叉树",
        "hardRate": "HARD",
        "passRate": "66.92%",
        "problemsUrl": "https://leetcode.cn/problems/h54YBf/",
        "solutionsUrl": "https://leetcode.cn/problems/h54YBf/solution",
        "problemsDesc": "<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>\n\n<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg\" style=\"width: 442px; height: 324px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,null,null,4,5]\n<strong>输出：</strong>[1,2,3,null,null,4,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅&nbsp;<a href=\"/faq/#binary-tree\">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，也可以采用其他的方法解决这个问题。</li>\n\t<li>树中结点数在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 297&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/\">https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/</a>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2990.从根节点到叶节点的路径数字之和",
        "hardRate": "MEDIUM",
        "passRate": "73.73%",
        "problemsUrl": "https://leetcode.cn/problems/3Etpl5/",
        "solutionsUrl": "https://leetcode.cn/problems/3Etpl5/solution",
        "problemsDesc": "<p>给定一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>每条从根节点到叶节点的路径都代表一个数字：</p>\n\n<ul>\n\t<li>例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code> 。</li>\n</ul>\n\n<p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p>\n\n<p><strong>叶节点</strong> 是指没有子节点的节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg\" style=\"width: 212px; height: 182px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3]\n<strong>输出：</strong>25\n<strong>解释：</strong>\n从根到叶子节点路径 <code>1-&gt;2</code> 代表数字 <code>12</code>\n从根到叶子节点路径 <code>1-&gt;3</code> 代表数字 <code>13</code>\n因此，数字总和 = 12 + 13 = <code>25</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg\" style=\"width: 292px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>root = [4,9,0,5,1]\n<strong>输出：</strong>1026\n<strong>解释：</strong>\n从根到叶子节点路径 <code>4-&gt;9-&gt;5</code> 代表数字 495\n从根到叶子节点路径 <code>4-&gt;9-&gt;1</code> 代表数字 491\n从根到叶子节点路径 <code>4-&gt;0</code> 代表数字 40\n因此，数字总和 = 495 + 491 + 40 = <code>1026</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 1000]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n\t<li>树的深度不超过 <code>10</code></li>\n</ul>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 129&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/\">https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2991.向下的路径节点之和",
        "hardRate": "MEDIUM",
        "passRate": "50.96%",
        "problemsUrl": "https://leetcode.cn/problems/6eUYwP/",
        "solutionsUrl": "https://leetcode.cn/problems/6eUYwP/solution",
        "problemsDesc": "<p>给定一个二叉树的根节点 <code>root</code>&nbsp;，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p>\n\n<p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg\" style=\"width: 452px; \" /></p>\n\n<pre>\n<strong>输入：</strong>root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\n<strong>输出：</strong>3\n<strong>解释：</strong>和等于 8 的路径有 3 条，如图所示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[0,1000]</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>-10<sup><span style=\"font-size: 9.449999809265137px;\">9</span></sup>&nbsp;&lt;= Node.val &lt;= 10<sup><span style=\"font-size: 9.449999809265137px;\">9</span></sup></code>&nbsp;</li>\n\t<li><code>-1000&nbsp;&lt;= targetSum&nbsp;&lt;= 1000</code>&nbsp;</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 437&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/path-sum-iii/\">https://leetcode-cn.com/problems/path-sum-iii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2992.节点之和最大的路径",
        "hardRate": "HARD",
        "passRate": "49.16%",
        "problemsUrl": "https://leetcode.cn/problems/jC7MId/",
        "solutionsUrl": "https://leetcode.cn/problems/jC7MId/solution",
        "problemsDesc": "<p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径<strong> 至少包含一个 </strong>节点，且不一定经过根节点。</p>\n\n<p><strong>路径和</strong> 是路径中各节点值的总和。</p>\n\n<p>给定一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong>，即所有路径上节点值之和的最大值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg\" style=\"width: 322px; height: 182px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3]\n<strong>输出：</strong>6\n<strong>解释：</strong>最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [-10,9,20,null,null,15,7]\n<strong>输出：</strong>42\n<strong>解释：</strong>最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目范围是 <code>[1, 3 * 10<sup>4</sup>]</code></li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 124&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/\">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2993.展平二叉搜索树",
        "hardRate": "EASY",
        "passRate": "73.61%",
        "problemsUrl": "https://leetcode.cn/problems/NYBBNL/",
        "solutionsUrl": "https://leetcode.cn/problems/NYBBNL/solution",
        "problemsDesc": "<p>给你一棵二叉搜索树，请&nbsp;<strong>按中序遍历</strong> 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg\" style=\"width: 600px; height: 350px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,3,6,2,4,null,8,1,null,null,null,7,9]\n<strong>输出：</strong>[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/17/ex2.jpg\" style=\"width: 300px; height: 114px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,1,7]\n<strong>输出：</strong>[1,null,5,null,7]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数的取值范围是 <code>[1, 100]</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 897&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/increasing-order-search-tree/\">https://leetcode-cn.com/problems/increasing-order-search-tree/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2994.二叉搜索树中的中序后继",
        "hardRate": "MEDIUM",
        "passRate": "63.22%",
        "problemsUrl": "https://leetcode.cn/problems/P5rCT8/",
        "solutionsUrl": "https://leetcode.cn/problems/P5rCT8/solution",
        "problemsDesc": "<p>给定一棵二叉搜索树和其中的一个节点 <code>p</code> ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 <code>null</code> 。</p>\n\n<p>节点&nbsp;<code>p</code>&nbsp;的后继是值比&nbsp;<code>p.val</code>&nbsp;大的节点中键值最小的节点，即按中序遍历的顺序节点 <code>p</code> 的下一个节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/23/285_example_1.PNG\" style=\"height: 117px; width: 122px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [2,1,3], p = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>这里 1 的中序后继是 2。请注意 p 和返回值都应是 TreeNode 类型。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/23/285_example_2.PNG\" style=\"height: 229px; width: 246px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,3,6,2,4,null,null,1], p = 6\n<strong>输出：</strong>null\n<strong>解释：</strong>因为给出的节点没有中序后继，所以答案就返回 <code>null 了。</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 10<sup>4</sup>]</code> 内。</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li>树中各节点的值均保证唯一。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 285&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/inorder-successor-in-bst/\">https://leetcode-cn.com/problems/inorder-successor-in-bst/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2995.所有大于等于节点的值之和",
        "hardRate": "MEDIUM",
        "passRate": "85.66%",
        "problemsUrl": "https://leetcode.cn/problems/w6cpku/",
        "solutionsUrl": "https://leetcode.cn/problems/w6cpku/solution",
        "problemsDesc": "<p><span style=\"font-size:10.5pt\"><span style=\"font-family:Calibri\"><span style=\"font-size:10.5000pt\"><span style=\"font-family:宋体\"><font face=\"宋体\">给定一个二叉搜索树，请将它的每个</font></span></span></span></span>节点<span style=\"font-size:10.5pt\"><span style=\"font-family:Calibri\"><span style=\"font-size:10.5000pt\"><span style=\"font-family:宋体\"><font face=\"宋体\">的值替换成树中大于或者等于该</font></span></span></span></span>节点<span style=\"font-size:10.5pt\"><span style=\"font-family:Calibri\"><span style=\"font-size:10.5000pt\"><span style=\"font-family:宋体\"><font face=\"宋体\">值的所有</font></span></span></span></span>节点<span style=\"font-size:10.5pt\"><span style=\"font-family:Calibri\"><span style=\"font-size:10.5000pt\"><span style=\"font-family:宋体\"><font face=\"宋体\">值之和。</font></span></span></span></span></p>\n\n<p style=\"margin:0pt 0pt 0.0001pt; text-align:justify\">&nbsp;</p>\n\n<p>提醒一下，二叉搜索树满足下列约束条件：</p>\n\n<ul>\n\t<li>节点的左子树仅包含键<strong> 小于 </strong>节点键的节点。</li>\n\t<li>节点的右子树仅包含键<strong> 大于</strong> 节点键的节点。</li>\n\t<li>左右子树也必须是二叉搜索树。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png\" style=\"height: 364px; width: 534px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root<strong> </strong>=<strong> </strong>[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n<strong>输出：</strong>[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [0,null,1]\n<strong>输出：</strong>[1,null,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,0,2]\n<strong>输出：</strong>[3,3,2]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [3,2,4,1]\n<strong>输出：</strong>[7,9,4,10]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数介于 <code>0</code>&nbsp;和 <code>10<sup>4</sup></code><sup>&nbsp;</sup>之间。</li>\n\t<li>每个节点的值介于 <code>-10<sup>4</sup></code>&nbsp;和&nbsp;<code>10<sup>4</sup></code>&nbsp;之间。</li>\n\t<li>树中的所有值 <strong>互不相同</strong> 。</li>\n\t<li>给定的树为二叉搜索树。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：</p>\n\n<ul>\n\t<li>本题与主站 538&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/convert-bst-to-greater-tree/\">https://leetcode-cn.com/problems/convert-bst-to-greater-tree/</a></li>\n\t<li>本题与主站 1038&nbsp;题相同：<a href=\"https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/\">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2996.二叉搜索树迭代器",
        "hardRate": "MEDIUM",
        "passRate": "85.26%",
        "problemsUrl": "https://leetcode.cn/problems/kTOapQ/",
        "solutionsUrl": "https://leetcode.cn/problems/kTOapQ/solution",
        "problemsDesc": "<p>实现一个二叉搜索树迭代器类<code>BSTIterator</code> ，表示一个按中序遍历二叉搜索树（BST）的迭代器：</p>\n\n<div class=\"original__bRMd\">\n<div>\n<ul>\n\t<li><code>BSTIterator(TreeNode root)</code> 初始化 <code>BSTIterator</code> 类的一个对象。BST 的根节点 <code>root</code> 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。</li>\n\t<li><code>boolean hasNext()</code> 如果向指针右侧遍历存在数字，则返回 <code>true</code> ；否则返回 <code>false</code> 。</li>\n\t<li><code>int next()</code>将指针向右移动，然后返回指针处的数字。</li>\n</ul>\n\n<p>注意，指针初始化为一个不存在于 BST 中的数字，所以对 <code>next()</code> 的首次调用将返回 BST 中的最小元素。</p>\n</div>\n</div>\n\n<p>可以假设&nbsp;<code>next()</code>&nbsp;调用总是有效的，也就是说，当调用 <code>next()</code>&nbsp;时，BST 的中序遍历中至少存在一个下一个数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png\" style=\"width: 189px; height: 178px;\" /></p>\n\n<pre>\n<strong>输入</strong>\ninputs = [&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]\ninputs = [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n<strong>输出</strong>\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\n<strong>解释</strong>\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // 返回 3\nbSTIterator.next();    // 返回 7\nbSTIterator.hasNext(); // 返回 True\nbSTIterator.next();    // 返回 9\nbSTIterator.hasNext(); // 返回 True\nbSTIterator.next();    // 返回 15\nbSTIterator.hasNext(); // 返回 True\nbSTIterator.next();    // 返回 20\nbSTIterator.hasNext(); // 返回 False\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>\n\t<li>最多调用 <code>10<sup>5</sup></code> 次 <code>hasNext</code> 和 <code>next</code> 操作</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你可以设计一个满足下述条件的解决方案吗？<code>next()</code> 和 <code>hasNext()</code> 操作均摊时间复杂度为 <code>O(1)</code> ，并使用 <code>O(h)</code> 内存。其中 <code>h</code> 是树的高度。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 173&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/binary-search-tree-iterator/\">https://leetcode-cn.com/problems/binary-search-tree-iterator/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2997.二叉搜索树中两个节点之和",
        "hardRate": "EASY",
        "passRate": "73.38%",
        "problemsUrl": "https://leetcode.cn/problems/opLdQZ/",
        "solutionsUrl": "https://leetcode.cn/problems/opLdQZ/solution",
        "problemsDesc": "<p>给定一个二叉搜索树的 <strong>根节点</strong> <code>root</code>&nbsp;和一个整数 <code>k</code> , 请判断该二叉搜索树中是否存在两个节点它们的值之和等于 <code>k</code> 。假设二叉搜索树中节点的值均唯一。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: </strong>root =<strong> </strong>[8,6,10,5,7,9,11], k = 12\n<strong>输出: </strong>true\n<strong>解释: </strong>节点 5 和节点 7 之和等于 12\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入: </strong>root =<strong> </strong>[8,6,10,5,7,9,11], k = 22\n<strong>输出: </strong>false\n<strong>解释: </strong>不存在两个节点值之和为 22 的节点\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是&nbsp;&nbsp;<code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li><code>root</code>&nbsp;为二叉搜索树</li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>注意：本题与主站 653 题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/\">https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2998.值和下标之差都在给定的范围内",
        "hardRate": "MEDIUM",
        "passRate": "34.95%",
        "problemsUrl": "https://leetcode.cn/problems/7WqeDu/",
        "solutionsUrl": "https://leetcode.cn/problems/7WqeDu/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和两个整数&nbsp;<code>k</code> 和 <code>t</code> 。请你判断是否存在 <b>两个不同下标</b> <code>i</code> 和 <code>j</code>，使得&nbsp;<code>abs(nums[i] - nums[j]) &lt;= t</code> ，同时又满足 <code>abs(i - j) &lt;= k</code><em> </em>。</p>\n\n<p>如果存在则返回 <code>true</code>，不存在返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,1], k<em> </em>= 3, t = 0\n<strong>输出：</strong>true</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,0,1,1], k<em> </em>=<em> </em>1, t = 2\n<strong>输出：</strong>true</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5,9,1,5,9], k = 2, t = 3\n<strong>输出：</strong>false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= t &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 220&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/contains-duplicate-iii/\">https://leetcode-cn.com/problems/contains-duplicate-iii/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2999.日程表",
        "hardRate": "MEDIUM",
        "passRate": "61.19%",
        "problemsUrl": "https://leetcode.cn/problems/fi9suh/",
        "solutionsUrl": "https://leetcode.cn/problems/fi9suh/solution",
        "problemsDesc": "<p>请实现一个 <code>MyCalendar</code> 类来存放你的日程安排。如果要添加的时间内没有其他安排，则可以存储这个新的日程安排。</p>\n\n<p><code>MyCalendar</code> 有一个 <code>book(int start, int end)</code>方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 <code>[start, end)</code>, 实数&nbsp;<code>x</code> 的范围为， &nbsp;<code>start &lt;= x &lt; end</code>。</p>\n\n<p>当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生重复预订。</p>\n\n<p>每次调用 <code>MyCalendar.book</code>方法时，如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 <code>true</code>。否则，返回 <code>false</code>&nbsp;并且不要将该日程安排添加到日历中。</p>\n\n<p>请按照以下步骤调用 <code>MyCalendar</code> 类: <code>MyCalendar cal = new MyCalendar();</code> <code>MyCalendar.book(start, end)</code></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例:</strong></p>\n\n<pre>\n<strong>输入:\n</strong>[&quot;MyCalendar&quot;,&quot;book&quot;,&quot;book&quot;,&quot;book&quot;]\n[[],[10,20],[15,25],[20,30]]\n<strong>输出:</strong> [null,true,false,true]\n<strong>解释:</strong> \nMyCalendar myCalendar = new MyCalendar();\nMyCalendar.book(10, 20); // returns true \nMyCalendar.book(15, 25); // returns false ，第二个日程安排不能添加到日历中，因为时间 15 已经被第一个日程安排预定了\nMyCalendar.book(20, 30); // returns true ，第三个日程安排可以添加到日历中，因为第一个日程安排并不包含时间 20 \n</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每个测试用例，调用&nbsp;<code>MyCalendar.book</code>&nbsp;函数最多不超过&nbsp;<code>1000</code>次。</li>\n\t<li><code>0 &lt;= start &lt; end &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 729&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/my-calendar-i/\">https://leetcode-cn.com/problems/my-calendar-i/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 3000.数据流的第 K 大数值",
        "hardRate": "EASY",
        "passRate": "62.72%",
        "problemsUrl": "https://leetcode.cn/problems/jBjn9C/",
        "solutionsUrl": "https://leetcode.cn/problems/jBjn9C/solution",
        "problemsDesc": "<p>设计一个找到数据流中第 <code>k</code> 大元素的类（class）。注意是排序后的第 <code>k</code> 大元素，不是第 <code>k</code> 个不同的元素。</p>\n\n<p>请实现 <code>KthLargest</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>KthLargest(int k, int[] nums)</code> 使用整数 <code>k</code> 和整数流 <code>nums</code> 初始化对象。</li>\n\t<li><code>int add(int val)</code> 将 <code>val</code> 插入数据流 <code>nums</code> 后，返回当前数据流中第 <code>k</code> 大的元素。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\n<strong>输出：</strong>\n[null, 4, 5, 5, 8, 8]\n\n<strong>解释：</strong>\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= val &lt;= 10<sup>4</sup></code></li>\n\t<li>最多调用 <code>add</code> 方法 <code>10<sup>4</sup></code> 次</li>\n\t<li>题目数据保证，在查找第 <code>k</code> 大元素时，数组中至少有 <code>k</code> 个元素</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" />注意：本题与主站 703&nbsp;题相同：&nbsp;<a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/\">https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/</a></p>\n",
        "isPlus": false
    }
]