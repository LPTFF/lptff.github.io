[
    {
        "problemsName": " 2001可互换矩形的组数",
        "hardRate": "MEDIUM",
        "passRate": "38.93%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-pairs-of-interchangeable-rectangles/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-pairs-of-interchangeable-rectangles/solution",
        "problemsDesc": "<p>用一个下标从 <strong>0</strong> 开始的二维整数数组&nbsp;<code>rectangles</code> 来表示 <code>n</code> 个矩形，其中 <code>rectangles[i] = [width<sub>i</sub>, height<sub>i</sub>]</code> 表示第 <code>i</code> 个矩形的宽度和高度。</p>\n\n<p>如果两个矩形 <code>i</code> 和 <code>j</code>（<code>i &lt; j</code>）的宽高比相同，则认为这两个矩形 <strong>可互换</strong> 。更规范的说法是，两个矩形满足&nbsp;<code>width<sub>i</sub>/height<sub>i</sub> == width<sub>j</sub>/height<sub>j</sub></code>（使用实数除法而非整数除法），则认为这两个矩形 <strong>可互换</strong> 。</p>\n\n<p>计算并返回&nbsp;<code>rectangles</code> 中有多少对 <strong>可互换 </strong>矩形。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rectangles = [[4,8],[3,6],[10,20],[15,30]]\n<strong>输出：</strong>6\n<strong>解释：</strong>下面按下标（从 0 开始）列出可互换矩形的配对情况：\n- 矩形 0 和矩形 1 ：4/8 == 3/6\n- 矩形 0 和矩形 2 ：4/8 == 10/20\n- 矩形 0 和矩形 3 ：4/8 == 15/30\n- 矩形 1 和矩形 2 ：3/6 == 10/20\n- 矩形 1 和矩形 3 ：3/6 == 15/30\n- 矩形 2 和矩形 3 ：10/20 == 15/30\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rectangles = [[4,5],[7,8]]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在成对的可互换矩形。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == rectangles.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>rectangles[i].length == 2</code></li>\n\t<li><code>1 &lt;= width<sub>i</sub>, height<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2002两个回文子序列长度的最大乘积",
        "hardRate": "MEDIUM",
        "passRate": "60.35%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，请你找到&nbsp;<code>s</code>&nbsp;中两个&nbsp;<strong>不相交回文子序列</strong>&nbsp;，使得它们长度的&nbsp;<strong>乘积最大</strong>&nbsp;。两个子序列在原字符串中如果没有任何相同下标的字符，则它们是&nbsp;<strong>不相交</strong>&nbsp;的。</p>\n\n<p>请你返回两个回文子序列长度可以达到的<strong>&nbsp;最大乘积</strong>&nbsp;。</p>\n\n<p><strong>子序列</strong>&nbsp;指的是从原字符串中删除若干个字符（可以一个也不删除）后，剩余字符不改变顺序而得到的结果。如果一个字符串从前往后读和从后往前读一模一样，那么这个字符串是一个 <strong>回文字符串</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"example-1\" src=\"https://assets.leetcode.com/uploads/2021/08/24/two-palindromic-subsequences.png\" style=\"width: 550px; height: 124px;\"></p>\n\n<pre><b>输入：</b>s = \"leetcodecom\"\n<b>输出：</b>9\n<b>解释：</b>最优方案是选择 \"ete\" 作为第一个子序列，\"cdc\" 作为第二个子序列。\n它们的乘积为 3 * 3 = 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"bb\"\n<b>输出：</b>1\n<b>解释：</b>最优方案为选择 \"b\" （第一个字符）作为第一个子序列，\"b\" （第二个字符）作为第二个子序列。\n它们的乘积为 1 * 1 = 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>s = \"accbcaxxcxx\"\n<b>输出：</b>25\n<b>解释：</b>最优方案为选择 \"accca\" 作为第一个子序列，\"xxcxx\" 作为第二个子序列。\n它们的乘积为 5 * 5 = 25 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 12</code></li>\n\t<li><code>s</code>&nbsp;只含有小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2003每棵子树内缺失的最小基因值",
        "hardRate": "HARD",
        "passRate": "43.01%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-missing-genetic-value-in-each-subtree/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-missing-genetic-value-in-each-subtree/solution",
        "problemsDesc": "<p>有一棵根节点为 <code>0</code>&nbsp;的 <strong>家族树</strong>&nbsp;，总共包含 <code>n</code>&nbsp;个节点，节点编号为 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;。给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组 <code>parents</code>&nbsp;，其中&nbsp;<code>parents[i]</code>&nbsp;是节点 <code>i</code>&nbsp;的父节点。由于节点 <code>0</code>&nbsp;是 <strong>根</strong>&nbsp;，所以&nbsp;<code>parents[0] == -1</code>&nbsp;。</p>\n\n<p>总共有&nbsp;<code>10<sup>5</sup></code>&nbsp;个基因值，每个基因值都用 <strong>闭区间</strong>&nbsp;<code>[1, 10<sup>5</sup>]</code>&nbsp;中的一个整数表示。给你一个下标从&nbsp;<strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，其中&nbsp;<code>nums[i]</code>&nbsp;是节点 <code>i</code>&nbsp;的基因值，且基因值 <strong>互不相同</strong>&nbsp;。</p>\n\n<p>请你返回一个数组<em>&nbsp;</em><code>ans</code>&nbsp;，长度为&nbsp;<code>n</code>&nbsp;，其中&nbsp;<code>ans[i]</code>&nbsp;是以节点&nbsp;<code>i</code>&nbsp;为根的子树内 <b>缺失</b>&nbsp;的&nbsp;<strong>最小</strong>&nbsp;基因值。</p>\n\n<p>节点 <code>x</code>&nbsp;为根的 <strong>子树&nbsp;</strong>包含节点 <code>x</code>&nbsp;和它所有的 <strong>后代</strong>&nbsp;节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/23/case-1.png\" style=\"width: 204px; height: 167px;\"></p>\n\n<pre><b>输入：</b>parents = [-1,0,0,2], nums = [1,2,3,4]\n<b>输出：</b>[5,1,1,1]\n<b>解释：</b>每个子树答案计算结果如下：\n- 0：子树包含节点 [0,1,2,3] ，基因值分别为 [1,2,3,4] 。5 是缺失的最小基因值。\n- 1：子树只包含节点 1 ，基因值为 2 。1 是缺失的最小基因值。\n- 2：子树包含节点 [2,3] ，基因值分别为 [3,4] 。1 是缺失的最小基因值。\n- 3：子树只包含节点 3 ，基因值为 4 。1是缺失的最小基因值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/23/case-2.png\" style=\"width: 247px; height: 168px;\"></p>\n\n<pre><b>输入：</b>parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3]\n<b>输出：</b>[7,1,1,4,2,1]\n<b>解释：</b>每个子树答案计算结果如下：\n- 0：子树内包含节点 [0,1,2,3,4,5] ，基因值分别为 [5,4,6,2,1,3] 。7 是缺失的最小基因值。\n- 1：子树内包含节点 [1,2] ，基因值分别为 [4,6] 。 1 是缺失的最小基因值。\n- 2：子树内只包含节点 2 ，基因值为 6 。1 是缺失的最小基因值。\n- 3：子树内包含节点 [3,4,5] ，基因值分别为 [2,1,3] 。4 是缺失的最小基因值。\n- 4：子树内只包含节点 4 ，基因值为 1 。2 是缺失的最小基因值。\n- 5：子树内只包含节点 5 ，基因值为 3 。1 是缺失的最小基因值。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8]\n<b>输出：</b>[1,1,1,1,1,1,1]\n<b>解释：</b>所有子树都缺失基因值 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == parents.length == nums.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li>对于&nbsp;<code>i != 0</code>&nbsp;，满足&nbsp;<code>0 &lt;= parents[i] &lt;= n - 1</code></li>\n\t<li><code>parents[0] == -1</code></li>\n\t<li><code>parents</code>&nbsp;表示一棵合法的树。</li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code>&nbsp;互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2004职员招聘人数",
        "hardRate": "HARD",
        "passRate": "41.89%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-seniors-and-juniors-to-join-the-company/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-seniors-and-juniors-to-join-the-company/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2005斐波那契树的移除子树游戏",
        "hardRate": "HARD",
        "passRate": "50.14%",
        "problemsUrl": "https://leetcode.cn/problems/subtree-removal-game-with-fibonacci-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/subtree-removal-game-with-fibonacci-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2006差的绝对值为 K 的数对数目",
        "hardRate": "EASY",
        "passRate": "83.93%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-pairs-with-absolute-difference-k/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-pairs-with-absolute-difference-k/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;，请你返回数对&nbsp;<code>(i, j)</code>&nbsp;的数目，满足&nbsp;<code>i &lt; j</code>&nbsp;且&nbsp;<code>|nums[i] - nums[j]| == k</code>&nbsp;。</p>\n\n<p><code>|x|</code>&nbsp;的值定义为：</p>\n\n<ul>\n\t<li>如果&nbsp;<code>x &gt;= 0</code>&nbsp;，那么值为&nbsp;<code>x</code>&nbsp;。</li>\n\t<li>如果&nbsp;<code>x &lt; 0</code>&nbsp;，那么值为&nbsp;<code>-x</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,2,1], k = 1\n<b>输出：</b>4\n<b>解释：</b>差的绝对值为 1 的数对为：\n- [<em><strong>1</strong></em>,<em><strong>2</strong></em>,2,1]\n- [<em><strong>1</strong></em>,2,<em><strong>2</strong></em>,1]\n- [1,<em><strong>2</strong></em>,2,<em><strong>1</strong></em>]\n- [1,2,<em><strong>2</strong></em>,<em><strong>1</strong></em>]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,3], k = 3\n<b>输出：</b>0\n<b>解释：</b>没有任何数对差的绝对值为 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [3,2,1,5,4], k = 2\n<b>输出：</b>3\n<b>解释：</b>差的绝对值为 2 的数对为：\n- [<em><strong>3</strong></em>,2,<em><strong>1</strong></em>,5,4]\n- [<em><strong>3</strong></em>,2,1,<em><strong>5</strong></em>,4]\n- [3,<em><strong>2</strong></em>,1,5,<em><strong>4</strong></em>]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= k &lt;= 99</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2007从双倍数组中还原原数组",
        "hardRate": "MEDIUM",
        "passRate": "33.52%",
        "problemsUrl": "https://leetcode.cn/problems/find-original-array-from-doubled-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-original-array-from-doubled-array/solution",
        "problemsDesc": "<p>一个整数数组&nbsp;<code>original</code>&nbsp;可以转变成一个 <strong>双倍</strong>&nbsp;数组&nbsp;<code>changed</code>&nbsp;，转变方式为将 <code>original</code>&nbsp;中每个元素 <strong>值乘以 2 </strong>加入数组中，然后将所有元素 <strong>随机打乱</strong>&nbsp;。</p>\n\n<p>给你一个数组&nbsp;<code>changed</code>&nbsp;，如果&nbsp;<code>change</code>&nbsp;是&nbsp;<strong>双倍</strong>&nbsp;数组，那么请你返回&nbsp;<code>original</code>数组，否则请返回空数组。<code>original</code>&nbsp;的元素可以以&nbsp;<strong>任意</strong>&nbsp;顺序返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>changed = [1,3,4,2,6,8]\n<b>输出：</b>[1,3,4]\n<b>解释：</b>一个可能的 original 数组为 [1,3,4] :\n- 将 1 乘以 2 ，得到 1 * 2 = 2 。\n- 将 3 乘以 2 ，得到 3 * 2 = 6 。\n- 将 4 乘以 2 ，得到 4 * 2 = 8 。\n其他可能的原数组方案为 [4,3,1] 或者 [3,1,4] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>changed = [6,3,0,1]\n<b>输出：</b>[]\n<b>解释：</b>changed 不是一个双倍数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>changed = [1]\n<b>输出：</b>[]\n<b>解释：</b>changed 不是一个双倍数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= changed.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= changed[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2008出租车的最大盈利",
        "hardRate": "MEDIUM",
        "passRate": "46.02%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-earnings-from-taxi/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-earnings-from-taxi/solution",
        "problemsDesc": "<p>你驾驶出租车行驶在一条有 <code>n</code>&nbsp;个地点的路上。这 <code>n</code>&nbsp;个地点从近到远编号为&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;，你想要从 <code>1</code>&nbsp;开到 <code>n</code>&nbsp;，通过接乘客订单盈利。你只能沿着编号递增的方向前进，不能改变方向。</p>\n\n<p>乘客信息用一个下标从 <strong>0</strong>&nbsp;开始的二维数组&nbsp;<code>rides</code>&nbsp;表示，其中&nbsp;<code>rides[i] = [start<sub>i</sub>, end<sub>i</sub>, tip<sub>i</sub>]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;位乘客需要从地点&nbsp;<code>start<sub>i</sub></code>&nbsp;前往&nbsp;<code>end<sub>i</sub></code>&nbsp;，愿意支付&nbsp;<code>tip<sub>i</sub></code>&nbsp;元的小费。</p>\n\n<p><strong>每一位</strong> 你选择接单的乘客&nbsp;<code>i</code>&nbsp;，你可以 <strong>盈利</strong>&nbsp;<code>end<sub>i</sub> - start<sub>i</sub> + tip<sub>i</sub></code>&nbsp;元。你同时&nbsp;<strong>最多</strong>&nbsp;只能接一个订单。</p>\n\n<p>给你 <code>n</code>&nbsp;和 <code>rides</code>&nbsp;，请你返回在最优接单方案下，你能盈利&nbsp;<strong>最多</strong>&nbsp;多少元。</p>\n\n<p><strong>注意：</strong>你可以在一个地点放下一位乘客，并在同一个地点接上另一位乘客。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 5, rides = [<em><strong>[2,5,4]</strong></em>,[1,5,1]]\n<b>输出：</b>7\n<b>解释：</b>我们可以接乘客 0 的订单，获得 5 - 2 + 4 = 7 元。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 20, rides = [[1,6,1],<strong><em>[3,10,2]</em></strong>,<em><strong>[10,12,3]</strong></em>,[11,12,2],[12,15,2],<strong><em>[13,18,1]</em></strong>]\n<b>输出：</b>20\n<b>解释：</b>我们可以接以下乘客的订单：\n- 将乘客 1 从地点 3 送往地点 10 ，获得 10 - 3 + 2 = 9 元。\n- 将乘客 2 从地点 10 送往地点 12 ，获得 12 - 10 + 3 = 5 元。\n- 将乘客 5 从地点 13 送往地点 18 ，获得 18 - 13 + 1 = 6 元。\n我们总共获得 9 + 5 + 6 = 20 元。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= rides.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>rides[i].length == 3</code></li>\n\t<li><code>1 &lt;= start<sub>i</sub> &lt; end<sub>i</sub> &lt;= n</code></li>\n\t<li><code>1 &lt;= tip<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2009使数组连续的最少操作数",
        "hardRate": "HARD",
        "passRate": "43.30%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-continuous/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-continuous/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;。每一次操作中，你可以将&nbsp;<code>nums</code>&nbsp;中&nbsp;<strong>任意</strong>&nbsp;一个元素替换成 <strong>任意&nbsp;</strong>整数。</p>\n\n<p>如果&nbsp;<code>nums</code>&nbsp;满足以下条件，那么它是 <strong>连续的</strong>&nbsp;：</p>\n\n<ul>\n\t<li><code>nums</code>&nbsp;中所有元素都是 <b>互不相同</b>&nbsp;的。</li>\n\t<li><code>nums</code>&nbsp;中 <strong>最大</strong>&nbsp;元素与&nbsp;<strong>最小</strong>&nbsp;元素的差等于&nbsp;<code>nums.length - 1</code>&nbsp;。</li>\n</ul>\n\n<p>比方说，<code>nums = [4, 2, 5, 3]</code>&nbsp;是 <strong>连续的</strong>&nbsp;，但是&nbsp;<code>nums = [1, 2, 3, 5, 6]</code> <strong>不是连续的</strong>&nbsp;。</p>\n\n<p>请你返回使 <code>nums</code>&nbsp;<strong>连续</strong>&nbsp;的 <strong>最少</strong>&nbsp;操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [4,2,5,3]\n<b>输出：</b>0\n<b>解释：</b>nums 已经是连续的了。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,5,6]\n<b>输出：</b>1\n<b>解释：</b>一个可能的解是将最后一个元素变为 4 。\n结果数组为 [1,2,3,5,4] ，是连续数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [1,10,100,1000]\n<b>输出：</b>3\n<b>解释：</b>一个可能的解是：\n- 将第二个元素变为 2 。\n- 将第三个元素变为 3 。\n- 将第四个元素变为 4 。\n结果数组为 [1,2,3,4] ，是连续数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2010职员招聘人数 II",
        "hardRate": "HARD",
        "passRate": "61.14%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-seniors-and-juniors-to-join-the-company-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-seniors-and-juniors-to-join-the-company-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2011执行操作后的变量值",
        "hardRate": "EASY",
        "passRate": "86.92%",
        "problemsUrl": "https://leetcode.cn/problems/final-value-of-variable-after-performing-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/final-value-of-variable-after-performing-operations/solution",
        "problemsDesc": "<p>存在一种仅支持 4 种操作和 1 个变量 <code>X</code> 的编程语言：</p>\n\n<ul>\n\t<li><code>++X</code> 和 <code>X++</code> 使变量 <code>X</code> 的值 <strong>加</strong> <code>1</code></li>\n\t<li><code>--X</code> 和 <code>X--</code> 使变量 <code>X</code> 的值 <strong>减</strong> <code>1</code></li>\n</ul>\n\n<p>最初，<code>X</code> 的值是 <code>0</code></p>\n\n<p>给你一个字符串数组 <code>operations</code> ，这是由操作组成的一个列表，返回执行所有操作后，<em> </em><code>X</code> 的 <strong>最终值</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>operations = [\"--X\",\"X++\",\"X++\"]\n<strong>输出：</strong>1\n<strong>解释：</strong>操作按下述步骤执行：\n最初，X = 0\n--X：X 减 1 ，X =  0 - 1 = -1\nX++：X 加 1 ，X = -1 + 1 =  0\nX++：X 加 1 ，X =  0 + 1 =  1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>operations = [\"++X\",\"++X\",\"X++\"]\n<strong>输出：</strong>3\n<strong>解释：</strong>操作按下述步骤执行： \n最初，X = 0\n++X：X 加 1 ，X = 0 + 1 = 1\n++X：X 加 1 ，X = 1 + 1 = 2\nX++：X 加 1 ，X = 2 + 1 = 3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>operations = [\"X++\",\"++X\",\"--X\",\"X--\"]\n<strong>输出：</strong>0\n<strong>解释：</strong>操作按下述步骤执行：\n最初，X = 0\nX++：X 加 1 ，X = 0 + 1 = 1\n++X：X 加 1 ，X = 1 + 1 = 2\n--X：X 减 1 ，X = 2 - 1 = 1\nX--：X 减 1 ，X = 1 - 1 = 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= operations.length &lt;= 100</code></li>\n\t<li><code>operations[i]</code> 将会是 <code>\"++X\"</code>、<code>\"X++\"</code>、<code>\"--X\"</code> 或 <code>\"X--\"</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2012数组美丽值求和",
        "hardRate": "MEDIUM",
        "passRate": "38.95%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-beauty-in-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-beauty-in-the-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。对于每个下标 <code>i</code>（<code>1 &lt;= i &lt;= nums.length - 2</code>），<code>nums[i]</code> 的 <strong>美丽值</strong> 等于：</p>\n\n<ul>\n\t<li><code>2</code>，对于所有 <code>0 &lt;= j &lt; i</code> 且 <code>i &lt; k &lt;= nums.length - 1</code> ，满足 <code>nums[j] &lt; nums[i] &lt; nums[k]</code></li>\n\t<li><code>1</code>，如果满足 <code>nums[i - 1] &lt; nums[i] &lt; nums[i + 1]</code> ，且不满足前面的条件</li>\n\t<li><code>0</code>，如果上述条件全部不满足</li>\n</ul>\n\n<p>返回符合 <code>1 &lt;= i &lt;= nums.length - 2</code> 的所有<em> </em><code>nums[i]</code><em> </em>的 <strong>美丽值的总和</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>对于每个符合范围 1 &lt;= i &lt;= 1 的下标 i :\n- nums[1] 的美丽值等于 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,4,6,4]\n<strong>输出：</strong>1\n<strong>解释：</strong>对于每个符合范围 1 &lt;= i &lt;= 2 的下标 i :\n- nums[1] 的美丽值等于 1\n- nums[2] 的美丽值等于 0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,2,1]\n<strong>输出：</strong>0\n<strong>解释：</strong>对于每个符合范围 1 &lt;= i &lt;= 1 的下标 i :\n- nums[1] 的美丽值等于 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2013检测正方形",
        "hardRate": "MEDIUM",
        "passRate": "56.61%",
        "problemsUrl": "https://leetcode.cn/problems/detect-squares/",
        "solutionsUrl": "https://leetcode.cn/problems/detect-squares/solution",
        "problemsDesc": "<p>给你一个在 X-Y 平面上的点构成的数据流。设计一个满足下述要求的算法：</p>\n\n<ul>\n\t<li><strong>添加</strong> 一个在数据流中的新点到某个数据结构中<strong>。</strong>可以添加 <strong>重复</strong> 的点，并会视作不同的点进行处理。</li>\n\t<li>给你一个查询点，请你从数据结构中选出三个点，使这三个点和查询点一同构成一个 <strong>面积为正</strong> 的 <strong>轴对齐正方形</strong> ，<strong>统计</strong> 满足该要求的方案数目<strong>。</strong></li>\n</ul>\n\n<p><strong>轴对齐正方形</strong> 是一个正方形，除四条边长度相同外，还满足每条边都与 x-轴 或 y-轴 平行或垂直。</p>\n\n<p>实现 <code>DetectSquares</code> 类：</p>\n\n<ul>\n\t<li><code>DetectSquares()</code> 使用空数据结构初始化对象</li>\n\t<li><code>void add(int[] point)</code> 向数据结构添加一个新的点 <code>point = [x, y]</code></li>\n\t<li><code>int count(int[] point)</code> 统计按上述方式与点 <code>point = [x, y]</code> 共同构造 <strong>轴对齐正方形</strong> 的方案数。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/01/image.png\" style=\"width: 869px; height: 504px;\" />\n<pre>\n<strong>输入：</strong>\n[\"DetectSquares\", \"add\", \"add\", \"add\", \"count\", \"count\", \"add\", \"count\"]\n[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]\n<strong>输出：</strong>\n[null, null, null, null, 1, 0, null, 2]\n\n<strong>解释：</strong>\nDetectSquares detectSquares = new DetectSquares();\ndetectSquares.add([3, 10]);\ndetectSquares.add([11, 2]);\ndetectSquares.add([3, 2]);\ndetectSquares.count([11, 10]); // 返回 1 。你可以选择：\n                               //   - 第一个，第二个，和第三个点\ndetectSquares.count([14, 8]);  // 返回 0 。查询点无法与数据结构中的这些点构成正方形。\ndetectSquares.add([11, 2]);    // 允许添加重复的点。\ndetectSquares.count([11, 10]); // 返回 2 。你可以选择：\n                               //   - 第一个，第二个，和第三个点\n                               //   - 第一个，第三个，和第四个点\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>point.length == 2</code></li>\n\t<li><code>0 &lt;= x, y &lt;= 1000</code></li>\n\t<li>调用&nbsp;<code>add</code> 和 <code>count</code> 的 <strong>总次数</strong> 最多为 <code>5000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2014重复 K 次的最长子序列",
        "hardRate": "HARD",
        "passRate": "54.63%",
        "problemsUrl": "https://leetcode.cn/problems/longest-subsequence-repeated-k-times/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-subsequence-repeated-k-times/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的字符串 <code>s</code> ，和一个整数 <code>k</code> 。请你找出字符串 <code>s</code> 中 <strong>重复</strong> <code>k</code> 次的 <strong>最长子序列</strong> 。</p>\n\n<p><strong>子序列</strong> 是由其他字符串删除某些（或不删除）字符派生而来的一个字符串。</p>\n\n<p>如果&nbsp;<code>seq * k</code> 是 <code>s</code> 的一个子序列，其中 <code>seq * k</code> 表示一个由 <code>seq</code> 串联 <code>k</code>&nbsp;次构造的字符串，那么就称 <code>seq</code><strong> </strong>是字符串 <code>s</code> 中一个 <strong>重复 <code>k</code> 次</strong> 的子序列。</p>\n\n<ul>\n\t<li>举个例子，<code>\"bba\"</code> 是字符串 <code>\"bababcba\"</code> 中的一个重复 <code>2</code> 次的子序列，因为字符串 <code>\"bbabba\"</code> 是由 <code>\"bba\"</code> 串联 <code>2</code> 次构造的，而&nbsp;<code>\"bbabba\"</code> 是字符串 <code>\"<em><strong>b</strong></em>a<em><strong>bab</strong></em>c<em><strong>ba</strong></em>\"</code> 的一个子序列。</li>\n</ul>\n\n<p>返回字符串 <code>s</code> 中 <strong>重复 k 次的最长子序列</strong>&nbsp; 。如果存在多个满足的子序列，则返回 <strong>字典序最大</strong> 的那个。如果不存在这样的子序列，返回一个 <strong>空</strong> 字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"example 1\" src=\"https://assets.leetcode.com/uploads/2021/08/30/longest-subsequence-repeat-k-times.png\" style=\"width: 457px; height: 99px;\" /></p>\n\n<pre>\n<strong>输入：</strong>s = \"letsleetcode\", k = 2\n<strong>输出：</strong>\"let\"\n<strong>解释：</strong>存在两个最长子序列重复 2 次：let\" 和 \"ete\" 。\n\"let\" 是其中字典序最大的一个。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"bb\", k = 2\n<strong>输出：</strong>\"b\"\n<strong>解释：</strong>重复 2 次的最长子序列是 \"b\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ab\", k = 2\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>不存在重复 2 次的最长子序列。返回空字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == s.length</code></li>\n\t<li><code>2 &lt;= k &lt;= 2000</code></li>\n\t<li><code>2 &lt;= n &lt; k * 8</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2015每段建筑物的平均高度",
        "hardRate": "MEDIUM",
        "passRate": "57.28%",
        "problemsUrl": "https://leetcode.cn/problems/average-height-of-buildings-in-each-segment/",
        "solutionsUrl": "https://leetcode.cn/problems/average-height-of-buildings-in-each-segment/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2016增量元素之间的最大差值",
        "hardRate": "EASY",
        "passRate": "59.68%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-difference-between-increasing-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-difference-between-increasing-elements/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，该数组的大小为 <code>n</code> ，请你计算 <code>nums[j] - nums[i]</code> 能求得的 <strong>最大差值 </strong>，其中 <code>0 &lt;= i &lt; j &lt; n</code> 且 <code>nums[i] &lt; nums[j]</code> 。</p>\n\n<p>返回 <strong>最大差值</strong> 。如果不存在满足要求的 <code>i</code> 和 <code>j</code> ，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [7,<em><strong>1</strong></em>,<em><strong>5</strong></em>,4]\n<strong>输出：</strong>4\n<strong>解释：</strong>\n最大差值出现在 i = 1 且 j = 2 时，nums[j] - nums[i] = 5 - 1 = 4 。\n注意，尽管 i = 1 且 j = 0 时 ，nums[j] - nums[i] = 7 - 1 = 6 &gt; 4 ，但 i &gt; j 不满足题面要求，所以 6 不是有效的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [9,4,3,2]\n<strong>输出：</strong>-1\n<strong>解释：</strong>\n不存在同时满足 i &lt; j 和 nums[i] &lt; nums[j] 这两个条件的 i, j 组合。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [<em><strong>1</strong></em>,5,2,<em><strong>10</strong></em>]\n<strong>输出：</strong>9\n<strong>解释：</strong>\n最大差值出现在 i = 0 且 j = 3 时，nums[j] - nums[i] = 10 - 1 = 9 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2017网格游戏",
        "hardRate": "MEDIUM",
        "passRate": "38.52%",
        "problemsUrl": "https://leetcode.cn/problems/grid-game/",
        "solutionsUrl": "https://leetcode.cn/problems/grid-game/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的二维数组 <code>grid</code> ，数组大小为 <code>2 x n</code> ，其中 <code>grid[r][c]</code> 表示矩阵中 <code>(r, c)</code> 位置上的点数。现在有两个机器人正在矩阵上参与一场游戏。</p>\n\n<p>两个机器人初始位置都是 <code>(0, 0)</code> ，目标位置是 <code>(1, n-1)</code> 。每个机器人只会 <strong>向右</strong> (<code>(r, c)</code> 到 <code>(r, c + 1)</code>) 或 <strong>向下 </strong>(<code>(r, c)</code> 到 <code>(r + 1, c)</code>) 。</p>\n\n<p>游戏开始，<strong>第一个</strong> 机器人从 <code>(0, 0)</code> 移动到 <code>(1, n-1)</code> ，并收集路径上单元格的全部点数。对于路径上所有单元格 <code>(r, c)</code> ，途经后 <code>grid[r][c]</code> 会重置为 <code>0</code> 。然后，<strong>第二个</strong> 机器人从 <code>(0, 0)</code> 移动到 <code>(1, n-1)</code> ，同样收集路径上单元的全部点数。注意，它们的路径可能会存在相交的部分。</p>\n\n<p><strong>第一个</strong> 机器人想要打击竞争对手，使 <strong>第二个</strong> 机器人收集到的点数 <strong>最小化</strong> 。与此相对，<strong>第二个</strong> 机器人想要 <strong>最大化</strong> 自己收集到的点数。两个机器人都发挥出自己的 <strong>最佳水平</strong>&nbsp;的前提下，返回 <strong>第二个</strong> 机器人收集到的 <strong>点数</strong> <em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/08/a1.png\" style=\"width: 388px; height: 103px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[2,5,4],[1,5,1]]\n<strong>输出：</strong>4\n<strong>解释：</strong>第一个机器人的最佳路径如红色所示，第二个机器人的最佳路径如蓝色所示。\n第一个机器人访问过的单元格将会重置为 0 。\n第二个机器人将会收集到 0 + 0 + 4 + 0 = 4 个点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/08/a2.png\" style=\"width: 384px; height: 105px;\" />\n<pre>\n<strong>输入：</strong>grid = [[3,3,1],[8,5,2]]\n<strong>输出：</strong>4\n<strong>解释：</strong>第一个机器人的最佳路径如红色所示，第二个机器人的最佳路径如蓝色所示。 \n第一个机器人访问过的单元格将会重置为 0 。\n第二个机器人将会收集到 0 + 3 + 1 + 0 = 4 个点。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/08/a3.png\" style=\"width: 493px; height: 103px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,3,1,15],[1,3,3,1]]\n<strong>输出：</strong>7\n<strong>解释：</strong>第一个机器人的最佳路径如红色所示，第二个机器人的最佳路径如蓝色所示。\n第一个机器人访问过的单元格将会重置为 0 。\n第二个机器人将会收集到 0 + 1 + 3 + 3 + 0 = 7 个点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>grid.length == 2</code></li>\n\t<li><code>n == grid[r].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= grid[r][c] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2018判断单词是否能放入填字游戏内",
        "hardRate": "MEDIUM",
        "passRate": "42.26%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-word-can-be-placed-in-crossword/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-word-can-be-placed-in-crossword/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的矩阵&nbsp;<code>board</code>&nbsp;，它代表一个填字游戏&nbsp;<strong>当前</strong>&nbsp;的状态。填字游戏格子中包含小写英文字母（已填入的单词），表示&nbsp;<strong>空</strong>&nbsp;格的&nbsp;<code>' '</code>&nbsp;和表示&nbsp;<strong>障碍</strong>&nbsp;格子的&nbsp;<code>'#'</code>&nbsp;。</p>\n\n<p>如果满足以下条件，那么我们可以 <strong>水平</strong>&nbsp;（从左到右 <strong>或者</strong>&nbsp;从右到左）或 <strong>竖直</strong>&nbsp;（从上到下 <strong>或者</strong>&nbsp;从下到上）填入一个单词：</p>\n\n<ul>\n\t<li>该单词不占据任何&nbsp;<code>'#'</code>&nbsp;对应的格子。</li>\n\t<li>每个字母对应的格子要么是&nbsp;<code>' '</code>&nbsp;（空格）要么与 <code>board</code>&nbsp;中已有字母 <strong>匹配</strong>&nbsp;。</li>\n\t<li>如果单词是 <strong>水平</strong>&nbsp;放置的，那么该单词左边和右边 <strong>相邻</strong>&nbsp;格子不能为&nbsp;<code>' '</code>&nbsp;或小写英文字母。</li>\n\t<li>如果单词是&nbsp;<strong>竖直</strong>&nbsp;放置的，那么该单词上边和下边&nbsp;<strong>相邻</strong><strong>&nbsp;</strong>格子不能为&nbsp;<code>' '</code>&nbsp;或小写英文字母。</li>\n</ul>\n\n<p>给你一个字符串&nbsp;<code>word</code>&nbsp;，如果&nbsp;<code>word</code>&nbsp;可以被放入&nbsp;<code>board</code>&nbsp;中，请你返回&nbsp;<code>true</code>&nbsp;，否则请返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/18/crossword-1.png\" style=\"width: 170px; height: 150px;\" /></p>\n\n<pre>\n<b>输入：</b>board = [[\"#\", \" \", \"#\"], [\" \", \" \", \"#\"], [\"#\", \"c\", \" \"]], word = \"abc\"\n<b>输出：</b>true\n<b>解释：</b>单词 \"abc\" 可以如上图放置（从上往下）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/18/c2.png\" style=\"width: 170px; height: 151px;\" /></p>\n\n<pre>\n<b>输入：</b>board = [[\" \", \"#\", \"a\"], [\" \", \"#\", \"c\"], [\" \", \"#\", \"a\"]], word = \"ac\"\n<b>输出：</b>false\n<b>解释：</b>无法放置单词，因为放置该单词后上方或者下方相邻格会有空格。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/18/crossword-2.png\" style=\"width: 171px; height: 146px;\" /></p>\n\n<pre>\n<b>输入：</b>board = [[\"#\", \" \", \"#\"], [\" \", \" \", \"#\"], [\"#\", \" \", \"c\"]], word = \"ca\"\n<b>输出：</b>true\n<b>解释：</b>单词 \"ca\" 可以如上图放置（从右到左）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m * n &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>board[i][j]</code>&nbsp;可能为&nbsp;<code>' '</code>&nbsp;，<code>'#'</code>&nbsp;或者一个小写英文字母。</li>\n\t<li><code>1 &lt;= word.length &lt;= max(m, n)</code></li>\n\t<li><code>word</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2019解出数学表达式的学生分数",
        "hardRate": "HARD",
        "passRate": "37.62%",
        "problemsUrl": "https://leetcode.cn/problems/the-score-of-students-solving-math-expression/",
        "solutionsUrl": "https://leetcode.cn/problems/the-score-of-students-solving-math-expression/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，它 <strong>只</strong> 包含数字&nbsp;<code>0-9</code>&nbsp;，加法运算符&nbsp;<code>'+'</code>&nbsp;和乘法运算符&nbsp;<code>'*'</code>&nbsp;，这个字符串表示一个&nbsp;<strong>合法</strong>&nbsp;的只含有&nbsp;<strong>个位数</strong><strong>数字</strong>&nbsp;的数学表达式（比方说&nbsp;<code>3+5*2</code>）。有 <code>n</code>&nbsp;位小学生将计算这个数学表达式，并遵循如下 <strong>运算顺序</strong>&nbsp;：</p>\n\n<ol>\n\t<li>按照 <strong>从左到右</strong>&nbsp;的顺序计算 <strong>乘法</strong>&nbsp;，然后</li>\n\t<li>按照 <strong>从左到右</strong>&nbsp;的顺序计算 <strong>加法</strong>&nbsp;。</li>\n</ol>\n\n<p>给你一个长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>answers</code>&nbsp;，表示每位学生提交的答案。你的任务是给 <code>answer</code>&nbsp;数组按照如下 <strong>规则</strong>&nbsp;打分：</p>\n\n<ul>\n\t<li>如果一位学生的答案 <strong>等于</strong>&nbsp;表达式的正确结果，这位学生将得到 <code>5</code>&nbsp;分。</li>\n\t<li>否则，如果答案由&nbsp;<strong>一处或多处错误的运算顺序</strong>&nbsp;计算得到，那么这位学生能得到 <code>2</code>&nbsp;分。</li>\n\t<li>否则，这位学生将得到 <code>0</code>&nbsp;分。</li>\n</ul>\n\n<p>请你返回所有学生的分数和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/17/student_solving_math.png\" style=\"width: 678px; height: 109px;\"></p>\n\n<pre><b>输入：</b>s = \"7+3*1*2\", answers = [20,13,42]\n<b>输出：</b>7\n<b>解释：</b>如上图所示，正确答案为 13 ，因此有一位学生得分为 5 分：[20,<em><strong>13</strong></em>,42] 。\n一位学生可能通过错误的运算顺序得到结果 20 ：7+3=10，10*1=10，10*2=20 。所以这位学生得分为 2 分：[<em><strong>20</strong></em>,13,42] 。\n所有学生得分分别为：[2,5,0] 。所有得分之和为 2+5+0=7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"3+5*2\", answers = [13,0,10,13,13,16,16]\n<b>输出：</b>19\n<b>解释：</b>表达式的正确结果为 13 ，所以有 3 位学生得到 5 分：[<em><strong>13</strong></em>,0,10,<em><strong>13</strong></em>,<em><strong>13</strong></em>,16,16] 。\n学生可能通过错误的运算顺序得到结果 16 ：3+5=8，8*2=16 。所以两位学生得到 2 分：[13,0,10,13,13,<em><strong>16</strong></em>,<em><strong>16</strong></em>] 。\n所有学生得分分别为：[5,0,0,5,5,2,2] 。所有得分之和为 5+0+0+5+5+2+2=19 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>s = \"6+0*1\", answers = [12,9,6,4,8,6]\n<b>输出：</b>10\n<b>解释：</b>表达式的正确结果为 6 。\n如果一位学生通过错误的运算顺序计算该表达式，结果仍为 6 。\n根据打分规则，运算顺序错误的学生也将得到 5 分（因为他们仍然得到了正确的结果），而不是 2 分。\n所有学生得分分别为：[0,0,5,0,0,5] 。所有得分之和为 10 分。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= s.length &lt;= 31</code></li>\n\t<li><code>s</code>&nbsp;表示一个只包含&nbsp;<code>0-9</code>&nbsp;，<code>'+'</code>&nbsp;和&nbsp;<code>'*'</code>&nbsp;的合法表达式。</li>\n\t<li>表达式中所有整数运算数字都在闭区间&nbsp;<code>[0, 9]</code>&nbsp;以内。</li>\n\t<li><code>1 &lt;=</code>&nbsp;数学表达式中所有运算符数目（<code>'+'</code> 和&nbsp;<code>'*'</code>）&nbsp;<code>&lt;= 15</code></li>\n\t<li>测试数据保证正确表达式结果在范围&nbsp;<code>[0, 1000]</code>&nbsp;以内。</li>\n\t<li><code>n == answers.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= answers[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2020无流量的帐户数",
        "hardRate": "MEDIUM",
        "passRate": "70.74%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-accounts-that-did-not-stream/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-accounts-that-did-not-stream/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2021街上最亮的位置",
        "hardRate": "MEDIUM",
        "passRate": "63.03%",
        "problemsUrl": "https://leetcode.cn/problems/brightest-position-on-street/",
        "solutionsUrl": "https://leetcode.cn/problems/brightest-position-on-street/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2022将一维数组转变成二维数组",
        "hardRate": "EASY",
        "passRate": "65.44%",
        "problemsUrl": "https://leetcode.cn/problems/convert-1d-array-into-2d-array/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-1d-array-into-2d-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的一维整数数组&nbsp;<code>original</code>&nbsp;和两个整数&nbsp;<code>m</code>&nbsp;和&nbsp;&nbsp;<code>n</code>&nbsp;。你需要使用&nbsp;<code>original</code>&nbsp;中&nbsp;<strong>所有</strong>&nbsp;元素创建一个&nbsp;<code>m</code>&nbsp;行&nbsp;<code>n</code>&nbsp;列的二维数组。</p>\n\n<p><code>original</code>&nbsp;中下标从 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;（都 <strong>包含</strong> ）的元素构成二维数组的第一行，下标从 <code>n</code>&nbsp;到 <code>2 * n - 1</code>&nbsp;（都 <strong>包含</strong>&nbsp;）的元素构成二维数组的第二行，依此类推。</p>\n\n<p>请你根据上述过程返回一个<em>&nbsp;</em><code>m x n</code>&nbsp;的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2021/08/26/image-20210826114243-1.png\" style=\"width: 500px; height: 174px;\">\n<pre><b>输入：</b>original = [1,2,3,4], m = 2, n = 2\n<b>输出：</b>[[1,2],[3,4]]\n<strong>解释：\n</strong>构造出的二维数组应该包含 2 行 2 列。\noriginal 中第一个 n=2 的部分为 [1,2] ，构成二维数组的第一行。\noriginal 中第二个 n=2 的部分为 [3,4] ，构成二维数组的第二行。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>original = [1,2,3], m = 1, n = 3\n<b>输出：</b>[[1,2,3]]\n<b>解释：</b>\n构造出的二维数组应该包含 1 行 3 列。\n将 original 中所有三个元素放入第一行中，构成要求的二维数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>original = [1,2], m = 1, n = 1\n<b>输出：</b>[]\n<strong>解释：\n</strong>original 中有 2 个元素。\n无法将 2 个元素放入到一个 1x1 的二维数组中，所以返回一个空的二维数组。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>original = [3], m = 1, n = 2\n<b>输出：</b>[]\n<strong>解释：</strong>\noriginal 中只有 1 个元素。\n无法将 1 个元素放满一个 1x2 的二维数组，所以返回一个空的二维数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= original.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= original[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m, n &lt;= 4 * 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2023连接后等于目标字符串的字符串对",
        "hardRate": "MEDIUM",
        "passRate": "74.20%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/solution",
        "problemsDesc": "<p>给你一个 <strong>数字</strong>&nbsp;字符串数组 <code>nums</code>&nbsp;和一个 <strong>数字</strong>&nbsp;字符串 <code>target</code>&nbsp;，请你返回 <code>nums[i] + nums[j]</code>&nbsp;（两个字符串连接）结果等于 <code>target</code>&nbsp;的下标 <code>(i, j)</code>&nbsp;（需满足 <code>i != j</code>）的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [\"777\",\"7\",\"77\",\"77\"], target = \"7777\"\n<b>输出：</b>4\n<b>解释：</b>符合要求的下标对包括：\n- (0, 1)：\"777\" + \"7\"\n- (1, 0)：\"7\" + \"777\"\n- (2, 3)：\"77\" + \"77\"\n- (3, 2)：\"77\" + \"77\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [\"123\",\"4\",\"12\",\"34\"], target = \"1234\"\n<b>输出：</b>2\n<b>解释：</b>符合要求的下标对包括\n- (0, 1)：\"123\" + \"4\"\n- (2, 3)：\"12\" + \"34\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [\"1\",\"1\",\"1\"], target = \"11\"\n<b>输出：</b>6\n<b>解释：</b>符合要求的下标对包括\n- (0, 1)：\"1\" + \"1\"\n- (1, 0)：\"1\" + \"1\"\n- (0, 2)：\"1\" + \"1\"\n- (2, 0)：\"1\" + \"1\"\n- (1, 2)：\"1\" + \"1\"\n- (2, 1)：\"1\" + \"1\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i].length &lt;= 100</code></li>\n\t<li><code>2 &lt;= target.length &lt;= 100</code></li>\n\t<li><code>nums[i]</code>&nbsp;和&nbsp;<code>target</code>&nbsp;只包含数字。</li>\n\t<li><code>nums[i]</code>&nbsp;和&nbsp;<code>target</code>&nbsp;不含有任何前导 0 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2024考试的最大困扰度",
        "hardRate": "MEDIUM",
        "passRate": "57.26%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/solution",
        "problemsDesc": "<p>一位老师正在出一场由 <code>n</code>&nbsp;道判断题构成的考试，每道题的答案为 true （用 <code><span style=\"\">'T'</span></code> 表示）或者 false （用 <code>'F'</code>&nbsp;表示）。老师想增加学生对自己做出答案的不确定性，方法是&nbsp;<strong>最大化&nbsp;</strong>有 <strong>连续相同</strong>&nbsp;结果的题数。（也就是连续出现 true 或者连续出现 false）。</p>\n\n<p>给你一个字符串&nbsp;<code>answerKey</code>&nbsp;，其中&nbsp;<code>answerKey[i]</code>&nbsp;是第 <code>i</code>&nbsp;个问题的正确结果。除此以外，还给你一个整数 <code>k</code>&nbsp;，表示你能进行以下操作的最多次数：</p>\n\n<ul>\n\t<li>每次操作中，将问题的正确答案改为&nbsp;<code>'T'</code> 或者&nbsp;<code>'F'</code>&nbsp;（也就是将 <code>answerKey[i]</code> 改为&nbsp;<code>'T'</code>&nbsp;或者&nbsp;<code>'F'</code>&nbsp;）。</li>\n</ul>\n\n<p>请你返回在不超过 <code>k</code>&nbsp;次操作的情况下，<strong>最大</strong>&nbsp;连续 <code>'T'</code>&nbsp;或者 <code>'F'</code>&nbsp;的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>answerKey = \"TTFF\", k = 2\n<b>输出：</b>4\n<b>解释：</b>我们可以将两个 'F' 都变为 'T' ，得到 answerKey = \"<em><strong>TTTT</strong></em>\" 。\n总共有四个连续的 'T' 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>answerKey = \"TFFT\", k = 1\n<b>输出：</b>3\n<b>解释：</b>我们可以将最前面的 'T' 换成 'F' ，得到 answerKey = \"<em><strong>FFF</strong></em>T\" 。\n或者，我们可以将第二个 'T' 换成 'F' ，得到 answerKey = \"T<em><strong>FFF</strong></em>\" 。\n两种情况下，都有三个连续的 'F' 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>answerKey = \"TTFTTFTT\", k = 1\n<b>输出：</b>5\n<b>解释：</b>我们可以将第一个 'F' 换成 'T' ，得到 answerKey = \"<em><strong>TTTTT</strong></em>FTT\" 。\n或者我们可以将第二个 'F' 换成 'T' ，得到 answerKey = \"TTF<em><strong>TTTTT</strong></em>\" 。\n两种情况下，都有五个连续的 'T' 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == answerKey.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>answerKey[i]</code>&nbsp;要么是&nbsp;<code>'T'</code> ，要么是&nbsp;<code>'F'</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2025分割数组的最多方案数",
        "hardRate": "HARD",
        "passRate": "30.39%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-ways-to-partition-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-ways-to-partition-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始且长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;。<strong>分割</strong>&nbsp;数组 <code>nums</code>&nbsp;的方案数定义为符合以下两个条件的 <code>pivot</code>&nbsp;数目：</p>\n\n<ul>\n\t<li><code>1 &lt;= pivot &lt; n</code></li>\n\t<li><code>nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]</code></li>\n</ul>\n\n<p>同时给你一个整数&nbsp;<code>k</code>&nbsp;。你可以将&nbsp;<code>nums</code>&nbsp;中&nbsp;<strong>一个</strong>&nbsp;元素变为&nbsp;<code>k</code>&nbsp;或&nbsp;<strong>不改变</strong>&nbsp;数组。</p>\n\n<p>请你返回在 <strong>至多</strong>&nbsp;改变一个元素的前提下，<strong>最多</strong>&nbsp;有多少种方法 <strong>分割</strong>&nbsp;<code>nums</code>&nbsp;使得上述两个条件都满足。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,-1,2], k = 3\n<b>输出：</b>1\n<b>解释：</b>一个最优的方案是将 nums[0] 改为 k&nbsp;。数组变为 [<em><strong>3</strong></em>,-1,2] 。\n有一种方法分割数组：\n- pivot = 2 ，我们有分割 [3,-1 | 2]：3 + -1 == 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [0,0,0], k = 1\n<b>输出：</b>2\n<b>解释：</b>一个最优的方案是不改动数组。\n有两种方法分割数组：\n- pivot = 1 ，我们有分割 [0 | 0,0]：0 == 0 + 0 。\n- pivot = 2 ，我们有分割 [0,0 | 0]: 0 + 0 == 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33\n<b>输出：</b>4\n<b>解释：</b>一个最优的方案是将 nums[2] 改为 k 。数组变为 [22,4,<em><strong>-33</strong></em>,-20,-15,15,-16,7,19,-10,0,-13,-14] 。\n有四种方法分割数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= k, nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2026低质量的问题",
        "hardRate": "EASY",
        "passRate": "79.95%",
        "problemsUrl": "https://leetcode.cn/problems/low-quality-problems/",
        "solutionsUrl": "https://leetcode.cn/problems/low-quality-problems/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2027转换字符串的最少操作次数",
        "hardRate": "EASY",
        "passRate": "66.97%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-moves-to-convert-string/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-moves-to-convert-string/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，由 <code>n</code> 个字符组成，每个字符不是 <code>'X'</code> 就是 <code>'O'</code> 。</p>\n\n<p>一次<strong> 操作</strong> 定义为从 <code>s</code> 中选出 <strong>三个连续字符 </strong>并将选中的每个字符都转换为 <code>'O'</code> 。注意，如果字符已经是 <code>'O'</code> ，只需要保持 <strong>不变</strong> 。</p>\n\n<p>返回将 <code>s</code> 中所有字符均转换为 <code>'O'</code> 需要执行的&nbsp;<strong>最少</strong>&nbsp;操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"XXX\"\n<strong>输出：</strong>1\n<strong>解释：<em>XXX</em></strong> -&gt; OOO\n一次操作，选中全部 3 个字符，并将它们转换为 <code>'O' 。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"XXOX\"\n<strong>输出：</strong>2\n<strong>解释：<em>XXO</em></strong>X -&gt; O<em><strong>OOX</strong></em> -&gt; OOOO\n第一次操作，选择前 3 个字符，并将这些字符转换为 <code>'O'</code> 。\n然后，选中后 3 个字符，并执行转换。最终得到的字符串全由字符 <code>'O'</code> 组成。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"OOOO\"\n<strong>输出：</strong>0\n<strong>解释：</strong>s 中不存在需要转换的 <code>'X' 。</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i]</code> 为 <code>'X'</code> 或 <code>'O'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2028找出缺失的观测数据",
        "hardRate": "MEDIUM",
        "passRate": "50.67%",
        "problemsUrl": "https://leetcode.cn/problems/find-missing-observations/",
        "solutionsUrl": "https://leetcode.cn/problems/find-missing-observations/solution",
        "problemsDesc": "<p>现有一份 <code>n + m</code>&nbsp;次投掷单个<strong> 六面</strong> 骰子的观测数据，骰子的每个面从 <code>1</code> 到 <code>6</code> 编号。观测数据中缺失了 <code>n</code> 份，你手上只拿到剩余&nbsp;<code>m</code> 次投掷的数据。幸好你有之前计算过的这 <code>n + m</code> 次投掷数据的 <strong>平均值</strong> 。</p>\n\n<p>给你一个长度为 <code>m</code> 的整数数组 <code>rolls</code> ，其中&nbsp;<code>rolls[i]</code> 是第 <code>i</code> 次观测的值。同时给你两个整数 <code>mean</code> 和 <code>n</code> 。</p>\n\n<p>返回一个长度为<em> </em><code>n</code><em> </em>的数组，包含所有缺失的观测数据，且满足这<em> </em><code>n + m</code><em> </em>次投掷的 <strong>平均值</strong> 是<em> </em><code>mean</code> 。如果存在多组符合要求的答案，只需要返回其中任意一组即可。如果不存在答案，返回一个空数组。</p>\n\n<p><code>k</code>&nbsp;个数字的 <strong>平均值</strong> 为这些数字求和后再除以&nbsp;<code>k</code> 。</p>\n\n<p>注意 <code>mean</code> 是一个整数，所以 <code>n + m</code> 次投掷的总和需要被&nbsp;<code>n + m</code>&nbsp;整除。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rolls = [3,2,4,3], mean = 4, n = 2\n<strong>输出：</strong>[6,6]\n<strong>解释：</strong>所有 n + m 次投掷的平均值是 (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rolls = [1,5,6], mean = 3, n = 4\n<strong>输出：</strong>[2,3,2,2]\n<strong>解释：</strong>所有 n + m 次投掷的平均值是 (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>rolls = [1,2,3,4], mean = 6, n = 4\n<strong>输出：</strong>[]\n<strong>解释：</strong>无论丢失的 4 次数据是什么，平均值都不可能是 6 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>rolls = [1], mean = 3, n = 1\n<strong>输出：</strong>[5]\n<strong>解释：</strong>所有 n + m 次投掷的平均值是 (1 + 5) / 2 = 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == rolls.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= rolls[i], mean &lt;= 6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2029石子游戏 IX",
        "hardRate": "MEDIUM",
        "passRate": "46.94%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game-ix/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game-ix/solution",
        "problemsDesc": "<p>Alice 和 Bob 再次设计了一款新的石子游戏。现有一行 n 个石子，每个石子都有一个关联的数字表示它的价值。给你一个整数数组 <code>stones</code> ，其中 <code>stones[i]</code> 是第 <code>i</code> 个石子的价值。</p>\n\n<p>Alice 和 Bob 轮流进行自己的回合，<strong>Alice</strong> 先手。每一回合，玩家需要从 <code>stones</code>&nbsp;中移除任一石子。</p>\n\n<ul>\n\t<li>如果玩家移除石子后，导致 <strong>所有已移除石子</strong> 的价值&nbsp;<strong>总和</strong> 可以被 3 整除，那么该玩家就 <strong>输掉游戏</strong> 。</li>\n\t<li>如果不满足上一条，且移除后没有任何剩余的石子，那么 Bob 将会直接获胜（即便是在 Alice 的回合）。</li>\n</ul>\n\n<p>假设两位玩家均采用&nbsp;<strong>最佳</strong> 决策。如果 Alice 获胜，返回 <code>true</code> ；如果 Bob 获胜，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [2,1]\n<strong>输出：</strong>true\n<strong>解释：</strong>游戏进行如下：\n- 回合 1：Alice 可以移除任意一个石子。\n- 回合 2：Bob 移除剩下的石子。 \n已移除的石子的值总和为 1 + 2 = 3 且可以被 3 整除。因此，Bob 输，Alice 获胜。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [2]\n<strong>输出：</strong>false\n<strong>解释：</strong>Alice 会移除唯一一个石子，已移除石子的值总和为 2 。 \n由于所有石子都已移除，且值总和无法被 3 整除，Bob 获胜。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [5,1,2,4,3]\n<strong>输出：</strong>false\n<strong>解释：</strong>Bob 总会获胜。其中一种可能的游戏进行方式如下：\n- 回合 1：Alice 可以移除值为 1 的第 2 个石子。已移除石子值总和为 1 。\n- 回合 2：Bob 可以移除值为 3 的第 5 个石子。已移除石子值总和为 = 1 + 3 = 4 。\n- 回合 3：Alices 可以移除值为 4 的第 4 个石子。已移除石子值总和为 = 1 + 3 + 4 = 8 。\n- 回合 4：Bob 可以移除值为 2 的第 3 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 = 10.\n- 回合 5：Alice 可以移除值为 5 的第 1 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 + 5 = 15.\nAlice 输掉游戏，因为已移除石子值总和（15）可以被 3 整除，Bob 获胜。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= stones.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= stones[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2030含特定字母的最小子序列",
        "hardRate": "HARD",
        "passRate": "36.39%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，一个整数 <code>k</code> ，一个字母 <code>letter</code> 以及另一个整数 <code>repetition</code> 。</p>\n\n<p>返回 <code>s</code> 中长度为 <code>k</code> 且 <strong>字典序最小</strong> 的子序列，该子序列同时应满足字母 <code>letter</code> 出现<strong> 至少</strong> <code>repetition</code> 次。生成的测试用例满足 <code>letter</code> 在 <code>s</code> 中出现 <strong>至少</strong> <code>repetition</code> 次。</p>\n\n<p><strong>子序列</strong> 是由原字符串删除一些（或不删除）字符且不改变剩余字符顺序得到的剩余字符串。</p>\n\n<p>字符串 <code>a</code> 字典序比字符串 <code>b</code> 小的定义为：在 <code>a</code> 和 <code>b</code> 出现不同字符的第一个位置上，字符串 <code>a</code> 的字符在字母表中的顺序早于字符串 <code>b</code>&nbsp;的字符。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"leet\", k = 3, letter = \"e\", repetition = 1\n<strong>输出：</strong>\"eet\"\n<strong>解释：</strong>存在 4 个长度为 3 ，且满足字母 'e' 出现至少 1 次的子序列：\n- \"lee\"（\"<em><strong>lee</strong></em>t\"）\n- \"let\"（\"<em><strong>le</strong></em>e<em><strong>t</strong></em>\"）\n- \"let\"（\"<em><strong>l</strong></em>e<em><strong>et</strong></em>\"）\n- \"eet\"（\"l<em><strong>eet</strong></em>\"）\n其中字典序最小的子序列是 \"eet\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"example-2\" src=\"https://assets.leetcode.com/uploads/2021/09/13/smallest-k-length-subsequence.png\" style=\"width: 339px; height: 67px;\" /></p>\n\n<pre>\n<strong>输入：</strong>s = \"leetcode\", k = 4, letter = \"e\", repetition = 2\n<strong>输出：</strong>\"ecde\"\n<strong>解释：</strong>\"ecde\" 是长度为 4 且满足字母 \"e\" 出现至少 2 次的字典序最小的子序列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"bb\", k = 2, letter = \"b\", repetition = 2\n<strong>输出：</strong>\"bb\"\n<strong>解释：</strong>\"bb\" 是唯一一个长度为 2 且满足字母 \"b\" 出现至少 2 次的子序列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= repetition &lt;= k &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n\t<li><code>letter</code> 是一个小写英文字母，在 <code>s</code>&nbsp;中至少出现 <code>repetition</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 20311 比 0 多的子数组个数",
        "hardRate": "MEDIUM",
        "passRate": "55.18%",
        "problemsUrl": "https://leetcode.cn/problems/count-subarrays-with-more-ones-than-zeros/",
        "solutionsUrl": "https://leetcode.cn/problems/count-subarrays-with-more-ones-than-zeros/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2032至少在两个数组中出现的值",
        "hardRate": "EASY",
        "passRate": "73.14%",
        "problemsUrl": "https://leetcode.cn/problems/two-out-of-three/",
        "solutionsUrl": "https://leetcode.cn/problems/two-out-of-three/solution",
        "problemsDesc": "给你三个整数数组 <code>nums1</code>、<code>nums2</code> 和 <code>nums3</code> ，请你构造并返回一个 <strong>元素各不相同的</strong> 数组，且由 <strong>至少</strong> 在 <strong>两个</strong> 数组中出现的所有值组成<em>。</em>数组中的元素可以按 <strong>任意</strong> 顺序排列。\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3]\n<strong>输出：</strong>[3,2]\n<strong>解释：</strong>至少在两个数组中出现的所有值为：\n- 3 ，在全部三个数组中都出现过。\n- 2 ，在数组 nums1 和 nums2 中出现过。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [3,1], nums2 = [2,3], nums3 = [1,2]\n<strong>输出：</strong>[2,3,1]\n<strong>解释：</strong>至少在两个数组中出现的所有值为：\n- 2 ，在数组 nums2 和 nums3 中出现过。\n- 3 ，在数组 nums1 和 nums2 中出现过。\n- 1 ，在数组 nums1 和 nums3 中出现过。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5]\n<strong>输出：</strong>[]\n<strong>解释：</strong>不存在至少在两个数组中出现的值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length, nums3.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[j], nums3[k] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2033获取单值网格的最小操作数",
        "hardRate": "MEDIUM",
        "passRate": "43.23%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-a-uni-value-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-a-uni-value-grid/solution",
        "problemsDesc": "<p>给你一个大小为&nbsp;<code>m x n</code> 的二维整数网格 <code>grid</code> 和一个整数 <code>x</code> 。每一次操作，你可以对 <code>grid</code> 中的任一元素 <strong>加</strong> <code>x</code> 或 <strong>减</strong> <code>x</code> 。</p>\n\n<p><strong>单值网格</strong> 是全部元素都相等的网格。</p>\n\n<p>返回使网格化为单值网格所需的 <strong>最小</strong> 操作数。如果不能，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/21/gridtxt.png\" style=\"width: 164px; height: 165px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[2,4],[6,8]], x = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>可以执行下述操作使所有元素都等于 4 ： \n- 2 加 x 一次。\n- 6 减 x 一次。\n- 8 减 x 两次。\n共计 4 次操作。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/21/gridtxt-1.png\" style=\"width: 164px; height: 165px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,5],[2,3]], x = 1\n<strong>输出：</strong>5\n<strong>解释：</strong>可以使所有元素都等于 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/21/gridtxt-2.png\" style=\"width: 164px; height: 165px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,2],[3,4]], x = 2\n<strong>输出：</strong>-1\n<strong>解释：</strong>无法使所有元素相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= x, grid[i][j] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2034股票价格波动",
        "hardRate": "MEDIUM",
        "passRate": "45.81%",
        "problemsUrl": "https://leetcode.cn/problems/stock-price-fluctuation/",
        "solutionsUrl": "https://leetcode.cn/problems/stock-price-fluctuation/solution",
        "problemsDesc": "<p>给你一支股票价格的数据流。数据流中每一条记录包含一个 <strong>时间戳</strong>&nbsp;和该时间点股票对应的 <strong>价格</strong>&nbsp;。</p>\n\n<p>不巧的是，由于股票市场内在的波动性，股票价格记录可能不是按时间顺序到来的。某些情况下，有的记录可能是错的。如果两个有相同时间戳的记录出现在数据流中，前一条记录视为错误记录，后出现的记录 <b>更正</b>&nbsp;前一条错误的记录。</p>\n\n<p>请你设计一个算法，实现：</p>\n\n<ul>\n\t<li><strong>更新 </strong>股票在某一时间戳的股票价格，如果有之前同一时间戳的价格，这一操作将&nbsp;<strong>更正</strong>&nbsp;之前的错误价格。</li>\n\t<li>找到当前记录里 <b>最新股票价格</b>&nbsp;。<strong>最新股票价格</strong>&nbsp;定义为时间戳最晚的股票价格。</li>\n\t<li>找到当前记录里股票的 <strong>最高价格</strong>&nbsp;。</li>\n\t<li>找到当前记录里股票的 <strong>最低价格</strong>&nbsp;。</li>\n</ul>\n\n<p>请你实现&nbsp;<code>StockPrice</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>StockPrice()</code>&nbsp;初始化对象，当前无股票价格记录。</li>\n\t<li><code>void update(int timestamp, int price)</code>&nbsp;在时间点 <code>timestamp</code>&nbsp;更新股票价格为 <code>price</code>&nbsp;。</li>\n\t<li><code>int current()</code>&nbsp;返回股票 <strong>最新价格</strong>&nbsp;。</li>\n\t<li><code>int maximum()</code>&nbsp;返回股票 <strong>最高价格</strong>&nbsp;。</li>\n\t<li><code>int minimum()</code>&nbsp;返回股票 <strong>最低价格</strong>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>\n[\"StockPrice\", \"update\", \"update\", \"current\", \"maximum\", \"update\", \"maximum\", \"update\", \"minimum\"]\n[[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []]\n<strong>输出：</strong>\n[null, null, null, 5, 10, null, 5, null, 2]\n\n<strong>解释：</strong>\nStockPrice stockPrice = new StockPrice();\nstockPrice.update(1, 10); // 时间戳为 [1] ，对应的股票价格为 [10] 。\nstockPrice.update(2, 5);  // 时间戳为 [1,2] ，对应的股票价格为 [10,5] 。\nstockPrice.current();     // 返回 5 ，最新时间戳为 2 ，对应价格为 5 。\nstockPrice.maximum();     // 返回 10 ，最高价格的时间戳为 1 ，价格为 10 。\nstockPrice.update(1, 3);  // 之前时间戳为 1 的价格错误，价格更新为 3 。\n                          // 时间戳为 [1,2] ，对应股票价格为 [3,5] 。\nstockPrice.maximum();     // 返回 5 ，更正后最高价格为 5 。\nstockPrice.update(4, 2);  // 时间戳为 [1,2,4] ，对应价格为 [3,5,2] 。\nstockPrice.minimum();     // 返回 2 ，最低价格时间戳为 4 ，价格为 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= timestamp, price &lt;= 10<sup>9</sup></code></li>\n\t<li><code>update</code>，<code>current</code>，<code>maximum</code>&nbsp;和&nbsp;<code>minimum</code>&nbsp;<strong>总</strong> 调用次数不超过&nbsp;<code>10<sup>5</sup></code>&nbsp;。</li>\n\t<li><code>current</code>，<code>maximum</code>&nbsp;和&nbsp;<code>minimum</code>&nbsp;被调用时，<code>update</code>&nbsp;操作 <strong>至少</strong>&nbsp;已经被调用过 <strong>一次</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2035将数组分成两个数组并最小化数组和的差",
        "hardRate": "HARD",
        "passRate": "34.79%",
        "problemsUrl": "https://leetcode.cn/problems/partition-array-into-two-arrays-to-minimize-sum-difference/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-array-into-two-arrays-to-minimize-sum-difference/solution",
        "problemsDesc": "<p>给你一个长度为 <code>2 * n</code>&nbsp;的整数数组。你需要将&nbsp;<code>nums</code>&nbsp;分成&nbsp;<strong>两个</strong>&nbsp;长度为&nbsp;<code>n</code>&nbsp;的数组，分别求出两个数组的和，并 <strong>最小化</strong>&nbsp;两个数组和之&nbsp;<b>差的绝对值</b>&nbsp;。<code>nums</code>&nbsp;中每个元素都需要放入两个数组之一。</p>\n\n<p>请你返回&nbsp;<strong>最小</strong>&nbsp;的数组和之差。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"example-1\" src=\"https://assets.leetcode.com/uploads/2021/10/02/ex1.png\" style=\"width: 240px; height: 106px;\"></p>\n\n<pre><b>输入：</b>nums = [3,9,7,3]\n<b>输出：</b>2\n<strong>解释：</strong>最优分组方案是分成 [3,9] 和 [7,3] 。\n数组和之差的绝对值为 abs((3 + 9) - (7 + 3)) = 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [-36,36]\n<b>输出：</b>72\n<strong>解释：</strong>最优分组方案是分成 [-36] 和 [36] 。\n数组和之差的绝对值为 abs((-36) - (36)) = 72 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"example-3\" src=\"https://assets.leetcode.com/uploads/2021/10/02/ex3.png\" style=\"width: 316px; height: 106px;\"></p>\n\n<pre><b>输入：</b>nums = [2,-1,0,4,-2,-9]\n<b>输出：</b>0\n<strong>解释：</strong>最优分组方案是分成 [2,4,-9] 和 [-1,0,-2] 。\n数组和之差的绝对值为 abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 15</code></li>\n\t<li><code>nums.length == 2 * n</code></li>\n\t<li><code>-10<sup>7</sup> &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2036最大交替子数组和",
        "hardRate": "MEDIUM",
        "passRate": "42.50%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-alternating-subarray-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-alternating-subarray-sum/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2037使每位学生都有座位的最少移动次数",
        "hardRate": "EASY",
        "passRate": "85.10%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-moves-to-seat-everyone/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-moves-to-seat-everyone/solution",
        "problemsDesc": "<p>一个房间里有 <code>n</code>&nbsp;个座位和 <code>n</code>&nbsp;名学生，房间用一个数轴表示。给你一个长度为 <code>n</code>&nbsp;的数组&nbsp;<code>seats</code>&nbsp;，其中&nbsp;<code>seats[i]</code> 是第 <code>i</code>&nbsp;个座位的位置。同时给你一个长度为 <code>n</code>&nbsp;的数组&nbsp;<code>students</code>&nbsp;，其中&nbsp;<code>students[j]</code>&nbsp;是第 <code>j</code>&nbsp;位学生的位置。</p>\n\n<p>你可以执行以下操作任意次：</p>\n\n<ul>\n\t<li>增加或者减少第&nbsp;<code>i</code>&nbsp;位学生的位置，每次变化量为 <code>1</code>&nbsp;（也就是将第 <code>i</code>&nbsp;位学生从位置 <code>x</code>&nbsp;移动到 <code>x + 1</code>&nbsp;或者 <code>x - 1</code>）</li>\n</ul>\n\n<p>请你返回使所有学生都有座位坐的 <strong>最少移动次数</strong>&nbsp;，并确保没有两位学生的座位相同。</p>\n\n<p>请注意，初始时有可能有多个座位或者多位学生在 <strong>同一</strong>&nbsp;位置。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>seats = [3,1,5], students = [2,7,4]\n<b>输出：</b>4\n<b>解释：</b>学生移动方式如下：\n- 第一位学生从位置 2 移动到位置 1 ，移动 1 次。\n- 第二位学生从位置 7 移动到位置 5 ，移动 2 次。\n- 第三位学生从位置 4 移动到位置 3 ，移动 1 次。\n总共 1 + 2 + 1 = 4 次移动。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>seats = [4,1,5,9], students = [1,3,2,6]\n<b>输出：</b>7\n<strong>解释：</strong>学生移动方式如下：\n- 第一位学生不移动。\n- 第二位学生从位置 3 移动到位置 4 ，移动 1 次。\n- 第三位学生从位置 2 移动到位置 5 ，移动 3 次。\n- 第四位学生从位置 6 移动到位置 9 ，移动 3 次。\n总共 0 + 1 + 3 + 3 = 7 次移动。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>seats = [2,2,6,6], students = [1,3,2,6]\n<b>输出：</b>4\n<b>解释：</b>学生移动方式如下：\n- 第一位学生从位置 1 移动到位置 2 ，移动 1 次。\n- 第二位学生从位置 3 移动到位置 6 ，移动 3 次。\n- 第三位学生不移动。\n- 第四位学生不移动。\n总共 1 + 3 + 0 + 0 = 4 次移动。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == seats.length == students.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= seats[i], students[j] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2038如果相邻两个颜色均相同则删除当前颜色",
        "hardRate": "MEDIUM",
        "passRate": "63.37%",
        "problemsUrl": "https://leetcode.cn/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/solution",
        "problemsDesc": "<p>总共有 <code>n</code>&nbsp;个颜色片段排成一列，每个颜色片段要么是&nbsp;<code>'A'</code>&nbsp;要么是&nbsp;<code>'B'</code>&nbsp;。给你一个长度为&nbsp;<code>n</code>&nbsp;的字符串&nbsp;<code>colors</code>&nbsp;，其中&nbsp;<code>colors[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个颜色片段的颜色。</p>\n\n<p>Alice 和 Bob 在玩一个游戏，他们 <strong>轮流</strong>&nbsp;从这个字符串中删除颜色。Alice <strong>先手</strong>&nbsp;。</p>\n\n<ul>\n\t<li>如果一个颜色片段为 <code>'A'</code>&nbsp;且 <strong>相邻两个颜色</strong>&nbsp;都是颜色 <code>'A'</code>&nbsp;，那么 Alice 可以删除该颜色片段。Alice&nbsp;<strong>不可以</strong>&nbsp;删除任何颜色&nbsp;<code>'B'</code>&nbsp;片段。</li>\n\t<li>如果一个颜色片段为 <code>'B'</code>&nbsp;且 <strong>相邻两个颜色</strong>&nbsp;都是颜色 <code>'B'</code>&nbsp;，那么 Bob 可以删除该颜色片段。Bob <strong>不可以</strong>&nbsp;删除任何颜色 <code>'A'</code>&nbsp;片段。</li>\n\t<li>Alice 和 Bob <strong>不能</strong>&nbsp;从字符串两端删除颜色片段。</li>\n\t<li>如果其中一人无法继续操作，则该玩家 <b>输</b>&nbsp;掉游戏且另一玩家 <strong>获胜</strong>&nbsp;。</li>\n</ul>\n\n<p>假设 Alice 和 Bob 都采用最优策略，如果 Alice 获胜，请返回&nbsp;<code>true</code>，否则 Bob 获胜，返回<em>&nbsp;</em><code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>colors = \"AAABABB\"\n<b>输出：</b>true\n<b>解释：</b>\nA<em><strong>A</strong></em>ABABB -&gt; AABABB\nAlice 先操作。\n她删除从左数第二个 'A' ，这也是唯一一个相邻颜色片段都是 'A' 的 'A' 。\n\n现在轮到 Bob 操作。\nBob 无法执行任何操作，因为没有相邻位置都是 'B' 的颜色片段 'B' 。\n因此，Alice 获胜，返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>colors = \"AA\"\n<b>输出：</b>false\n<strong>解释：</strong>\nAlice 先操作。\n只有 2 个 'A' 且它们都在字符串的两端，所以她无法执行任何操作。\n因此，Bob 获胜，返回 false 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>colors = \"ABBBBBBBAAA\"\n<b>输出：</b>false\n<strong>解释：</strong>\nABBBBBBBA<em><strong>A</strong></em>A -&gt; ABBBBBBBAA\nAlice 先操作。\n她唯一的选择是删除从右数起第二个 'A' 。\n\nABBBB<strong><em>B</em></strong>BBAA -&gt; ABBBBBBAA\n接下来轮到 Bob 操作。\n他有许多选择，他可以选择任何一个 'B' 删除。\n\n然后轮到 Alice 操作，她无法删除任何片段。\n所以 Bob 获胜，返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;colors.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>colors</code>&nbsp;只包含字母&nbsp;<code>'A'</code>&nbsp;和&nbsp;<code>'B'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2039网络空闲的时刻",
        "hardRate": "MEDIUM",
        "passRate": "55.86%",
        "problemsUrl": "https://leetcode.cn/problems/the-time-when-the-network-becomes-idle/",
        "solutionsUrl": "https://leetcode.cn/problems/the-time-when-the-network-becomes-idle/solution",
        "problemsDesc": "<p>给你一个有 <code>n</code>&nbsp;个服务器的计算机网络，服务器编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。同时给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code>&nbsp;表示服务器&nbsp;<code>u<sub>i</sub></code> 和&nbsp;<code>v<sub>i</sub></code><sub>&nbsp;</sub>之间有一条信息线路，在&nbsp;<strong>一秒</strong>&nbsp;内它们之间可以传输&nbsp;<strong>任意</strong>&nbsp;数目的信息。再给你一个长度为 <code>n</code>&nbsp;且下标从&nbsp;<strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>patience</code>&nbsp;。</p>\n\n<p>题目保证所有服务器都是 <b>相通</b>&nbsp;的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。</p>\n\n<p>编号为 <code>0</code>&nbsp;的服务器是 <strong>主</strong>&nbsp;服务器，其他服务器为 <strong>数据</strong>&nbsp;服务器。每个数据服务器都要向主服务器发送信息，并等待回复。信息在服务器之间按 <strong>最优</strong>&nbsp;线路传输，也就是说每个信息都会以 <strong>最少时间</strong>&nbsp;到达主服务器。主服务器会处理 <strong>所有</strong>&nbsp;新到达的信息并 <strong>立即</strong>&nbsp;按照每条信息来时的路线 <strong>反方向</strong> 发送回复信息。</p>\n\n<p>在 <code>0</code>&nbsp;秒的开始，所有数据服务器都会发送各自需要处理的信息。从第 <code>1</code>&nbsp;秒开始，<strong>每</strong>&nbsp;一秒最 <strong>开始</strong>&nbsp;时，每个数据服务器都会检查它是否收到了主服务器的回复信息（包括新发出信息的回复信息）：</p>\n\n<ul>\n\t<li>如果还没收到任何回复信息，那么该服务器会周期性&nbsp;<strong>重发</strong>&nbsp;信息。数据服务器&nbsp;<code>i</code>&nbsp;每&nbsp;<code>patience[i]</code>&nbsp;秒都会重发一条信息，也就是说，数据服务器&nbsp;<code>i</code>&nbsp;在上一次发送信息给主服务器后的 <code>patience[i]</code>&nbsp;秒 <strong>后</strong>&nbsp;会重发一条信息给主服务器。</li>\n\t<li>否则，该数据服务器&nbsp;<strong>不会重发</strong>&nbsp;信息。</li>\n</ul>\n\n<p>当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为 <strong>空闲</strong>&nbsp;状态。</p>\n\n<p>请返回计算机网络变为 <strong>空闲</strong>&nbsp;状态的&nbsp;<strong>最早秒数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"example 1\" src=\"https://assets.leetcode.com/uploads/2021/09/22/quiet-place-example1.png\" style=\"width: 750px; height: 384px;\"></p>\n\n<pre><b>输入：</b>edges = [[0,1],[1,2]], patience = [0,2,1]\n<b>输出：</b>8\n<strong>解释：</strong>\n0 秒最开始时，\n- 数据服务器 1 给主服务器发出信息（用 1A 表示）。\n- 数据服务器 2 给主服务器发出信息（用 2A 表示）。\n\n1 秒时，\n- 信息 1A 到达主服务器，主服务器立刻处理信息 1A 并发出 1A 的回复信息。\n- 数据服务器 1 还没收到任何回复。距离上次发出信息过去了 1 秒（1 &lt; patience[1] = 2），所以不会重发信息。\n- 数据服务器 2 还没收到任何回复。距离上次发出信息过去了 1 秒（1 == patience[2] = 1），所以它重发一条信息（用 2B 表示）。\n\n2 秒时，\n- 回复信息 1A 到达服务器 1 ，服务器 1 不会再重发信息。\n- 信息 2A 到达主服务器，主服务器立刻处理信息 2A 并发出 2A 的回复信息。\n- 服务器 2 重发一条信息（用 2C 表示）。\n...\n4 秒时，\n- 回复信息 2A 到达服务器 2 ，服务器 2 不会再重发信息。\n...\n7 秒时，回复信息 2D 到达服务器 2 。\n\n从第 8 秒开始，不再有任何信息在服务器之间传输，也不再有信息到达服务器。\n所以第 8 秒是网络变空闲的最早时刻。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"example 2\" src=\"https://assets.leetcode.com/uploads/2021/09/04/network_a_quiet_place_2.png\" style=\"width: 100px; height: 85px;\"></p>\n\n<pre><b>输入：</b>edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]\n<b>输出：</b>3\n<b>解释：</b>数据服务器 1 和 2 第 2 秒初收到回复信息。\n从第 3 秒开始，网络变空闲。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == patience.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>patience[0] == 0</code></li>\n\t<li>对于&nbsp;<code>1 &lt;= i &lt; n</code> ，满足&nbsp;<code>1 &lt;= patience[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= edges.length &lt;= min(10<sup>5</sup>, n * (n - 1) / 2)</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n\t<li>不会有重边。</li>\n\t<li>每个服务器都直接或间接与别的服务器相连。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2040两个有序数组的第 K 小乘积",
        "hardRate": "HARD",
        "passRate": "33.47%",
        "problemsUrl": "https://leetcode.cn/problems/kth-smallest-product-of-two-sorted-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-smallest-product-of-two-sorted-arrays/solution",
        "problemsDesc": "给你两个 <strong>从小到大排好序</strong>&nbsp;且下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;以及一个整数&nbsp;<code>k</code>&nbsp;，请你返回第<em>&nbsp;</em><code>k</code>&nbsp;（从 <strong>1</strong>&nbsp;开始编号）小的&nbsp;<code>nums1[i] * nums2[j]</code><em>&nbsp;</em>的乘积，其中<em>&nbsp;</em><code>0 &lt;= i &lt; nums1.length</code><em> </em>且<em> </em><code>0 &lt;= j &lt; nums2.length</code>&nbsp;。\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [2,5], nums2 = [3,4], k = 2\n<b>输出：</b>8\n<b>解释：</b>第 2 小的乘积计算如下：\n- nums1[0] * nums2[0] = 2 * 3 = 6\n- nums1[0] * nums2[1] = 2 * 4 = 8\n第 2 小的乘积为 8 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [-4,-2,0,3], nums2 = [2,4], k = 6\n<b>输出：</b>0\n<strong>解释：</strong>第 6 小的乘积计算如下：\n- nums1[0] * nums2[1] = (-4) * 4 = -16\n- nums1[0] * nums2[0] = (-4) * 2 = -8\n- nums1[1] * nums2[1] = (-2) * 4 = -8\n- nums1[1] * nums2[0] = (-2) * 2 = -4\n- nums1[2] * nums2[0] = 0 * 2 = 0\n- nums1[2] * nums2[1] = 0 * 4 = 0\n第 6 小的乘积为 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums1 = [-2,-1,0,1,2], nums2 = [-3,-1,2,4,5], k = 3\n<b>输出：</b>-6\n<b>解释：</b>第 3 小的乘积计算如下：\n- nums1[0] * nums2[4] = (-2) * 5 = -10\n- nums1[0] * nums2[3] = (-2) * 4 = -8\n- nums1[4] * nums2[0] = 2 * (-3) = -6\n第 3 小的乘积为 -6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums1[i], nums2[j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums1.length * nums2.length</code></li>\n\t<li><code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;都是从小到大排好序的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2041面试中被录取的候选人",
        "hardRate": "MEDIUM",
        "passRate": "76.38%",
        "problemsUrl": "https://leetcode.cn/problems/accepted-candidates-from-the-interviews/",
        "solutionsUrl": "https://leetcode.cn/problems/accepted-candidates-from-the-interviews/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2042检查句子中的数字是否递增",
        "hardRate": "EASY",
        "passRate": "71.97%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-numbers-are-ascending-in-a-sentence/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-numbers-are-ascending-in-a-sentence/solution",
        "problemsDesc": "<p>句子是由若干 <strong>token</strong> 组成的一个列表，<strong>token</strong> 间用 <strong>单个</strong> 空格分隔，句子没有前导或尾随空格。每个 token 要么是一个由数字 <code>0-9</code> 组成的不含前导零的 <strong>正整数</strong>&nbsp;，要么是一个由小写英文字母组成的 <strong>单词</strong> 。</p>\n\n<ul>\n\t<li>示例，<code>\"a puppy has 2 eyes 4 legs\"</code> 是一个由 7 个 token 组成的句子：<code>\"2\"</code> 和 <code>\"4\"</code> 是数字，其他像&nbsp;<code>\"puppy\"</code> 这样的 tokens 属于单词。</li>\n</ul>\n\n<p>给你一个表示句子的字符串 <code>s</code> ，你需要检查 <code>s</code> 中的 <strong>全部</strong> 数字是否从左到右严格递增（即，除了最后一个数字，<code>s</code> 中的 <strong>每个</strong> 数字都严格小于它 <strong>右侧</strong> 的数字）。</p>\n\n<p>如果满足题目要求，返回 <code>true</code>&nbsp;，否则，返回<em> </em><code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"example-1\" src=\"https://assets.leetcode.com/uploads/2021/09/30/example1.png\" style=\"width: 637px; height: 48px;\" /></p>\n\n<pre>\n<strong>输入：</strong>s = \"1 box has 3 blue 4 red 6 green and 12 yellow marbles\"\n<strong>输出：</strong>true\n<strong>解释：</strong>句子中的数字是：1, 3, 4, 6, 12 。\n这些数字是按从左到右严格递增的 1 &lt; 3 &lt; 4 &lt; 6 &lt; 12 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"hello world 5 x 5\"\n<strong>输出：</strong>false\n<strong>解释：</strong>句子中的数字是：<em><strong>5</strong></em>, <strong><em>5</em></strong> 。这些数字不是严格递增的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"example-3\" src=\"https://assets.leetcode.com/uploads/2021/09/30/example3.png\" style=\"width: 794px; height: 48px;\" /></p>\n\n<pre>\n<strong>输入：</strong>s = \"sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s\"\n<strong>输出：</strong>false\n<strong>解释：</strong>s 中的数字是：7, <em><strong>51</strong></em>, <em><strong>50</strong></em>, 60 。这些数字不是严格递增的。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"4 5 11 26\"\n<strong>输出：</strong>true\n<strong>解释：</strong>s 中的数字是：4, 5, 11, 26 。\n这些数字是按从左到右严格递增的：4 &lt; 5 &lt; 11 &lt; 26 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= s.length &lt;= 200</code></li>\n\t<li><code>s</code> 由小写英文字母、空格和数字 <code>0</code> 到 <code>9</code> 组成（包含 <code>0</code> 和 <code>9</code>）</li>\n\t<li><code>s</code> 中数字 token 的数目在 <code>2</code> 和 <code>100</code> 之间（包含 <code>2</code> 和 <code>100</code>）</li>\n\t<li><code>s</code> 中的 token 之间由单个空格分隔</li>\n\t<li><code>s</code> 中至少有 <strong>两个</strong> 数字</li>\n\t<li><code>s</code> 中的每个数字都是一个 <strong>小于</strong> <code>100</code> 的 <strong>正</strong> 数，且不含前导零</li>\n\t<li><code>s</code> 不含前导或尾随空格</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2043简易银行系统",
        "hardRate": "MEDIUM",
        "passRate": "66.01%",
        "problemsUrl": "https://leetcode.cn/problems/simple-bank-system/",
        "solutionsUrl": "https://leetcode.cn/problems/simple-bank-system/solution",
        "problemsDesc": "<p>你的任务是为一个很受欢迎的银行设计一款程序，以自动化执行所有传入的交易（转账，存款和取款）。银行共有 <code>n</code> 个账户，编号从 <code>1</code> 到 <code>n</code> 。每个账号的初始余额存储在一个下标从 <strong>0</strong> 开始的整数数组 <code>balance</code>&nbsp;中，其中第 <code>(i + 1)</code> 个账户的初始余额是 <code>balance[i]</code> 。</p>\n\n<p>请你执行所有 <strong>有效的</strong> 交易。如果满足下面全部条件，则交易 <strong>有效</strong> ：</p>\n\n<ul>\n\t<li>指定的账户数量在 <code>1</code> 和 <code>n</code> 之间，且</li>\n\t<li>取款或者转账需要的钱的总数 <strong>小于或者等于</strong> 账户余额。</li>\n</ul>\n\n<p>实现 <code>Bank</code> 类：</p>\n\n<ul>\n\t<li><code>Bank(long[] balance)</code> 使用下标从 <strong>0</strong> 开始的整数数组 <code>balance</code> 初始化该对象。</li>\n\t<li><code>boolean transfer(int account1, int account2, long money)</code> 从编号为&nbsp;<code>account1</code> 的账户向编号为 <code>account2</code> 的账户转帐 <code>money</code> 美元。如果交易成功，返回 <code>true</code> ，否则，返回 <code>false</code> 。</li>\n\t<li><code>boolean deposit(int account, long money)</code> 向编号为&nbsp;<code>account</code> 的账户存款 <code>money</code> 美元。如果交易成功，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n\t<li><code>boolean withdraw(int account, long money)</code> 从编号为 <code>account</code> 的账户取款 <code>money</code> 美元。如果交易成功，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>：\n[\"Bank\", \"withdraw\", \"transfer\", \"deposit\", \"transfer\", \"withdraw\"]\n[[[10, 100, 20, 50, 30]], [3, 10], [5, 1, 20], [5, 20], [3, 4, 15], [10, 50]]\n<strong>输出：</strong>\n[null, true, true, true, false, false]\n\n<strong>解释：</strong>\nBank bank = new Bank([10, 100, 20, 50, 30]);\nbank.withdraw(3, 10);    // 返回 true ，账户 3 的余额是 $20 ，所以可以取款 $10 。\n                         // 账户 3 余额为 $20 - $10 = $10 。\nbank.transfer(5, 1, 20); // 返回 true ，账户 5 的余额是 $30 ，所以可以转账 $20 。\n                         // 账户 5 的余额为 $30 - $20 = $10 ，账户 1 的余额为 $10 + $20 = $30 。\nbank.deposit(5, 20);     // 返回 true ，可以向账户 5 存款 $20 。\n                         // 账户 5 的余额为 $10 + $20 = $30 。\nbank.transfer(3, 4, 15); // 返回 false ，账户 3 的当前余额是 $10 。\n                         // 所以无法转账 $15 。\nbank.withdraw(10, 50);   // 返回 false ，交易无效，因为账户 10 并不存在。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == balance.length</code></li>\n\t<li><code>1 &lt;= n, account, account1, account2 &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= balance[i], money &lt;= 10<sup>12</sup></code></li>\n\t<li><code>transfer</code>, <code>deposit</code>, <code>withdraw</code> 三个函数，<strong>每个</strong> 最多调用 <code>10<sup>4</sup></code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2044统计按位或能得到最大值的子集数目",
        "hardRate": "MEDIUM",
        "passRate": "81.79%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-maximum-bitwise-or-subsets/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-maximum-bitwise-or-subsets/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，请你找出 <code>nums</code> 子集 <strong>按位或</strong> 可能得到的<strong> </strong><strong>最大值</strong> ，并返回按位或能得到最大值的 <strong>不同非空子集的数目</strong> 。</p>\n\n<p>如果数组 <code>a</code> 可以由数组 <code>b</code> 删除一些元素（或不删除）得到，则认为数组 <code>a</code> 是数组 <code>b</code> 的一个 <strong>子集</strong> 。如果选中的元素下标位置不一样，则认为两个子集 <strong>不同</strong> 。</p>\n\n<p>对数组 <code>a</code> 执行 <strong>按位或</strong>&nbsp;，结果等于 <code>a[0] <strong>OR</strong> a[1] <strong>OR</strong> ... <strong>OR</strong> a[a.length - 1]</code>（下标从 <strong>0</strong> 开始）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>子集按位或能得到的最大值是 3 。有 2 个子集按位或可以得到 3 ：\n- [3]\n- [3,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,2]\n<strong>输出：</strong>7\n<strong>解释：</strong>[2,2,2] 的所有非空子集的按位或都可以得到 2 。总共有 2<sup>3</sup> - 1 = 7 个子集。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,1,5]\n<strong>输出：</strong>6\n<strong>解释：</strong>子集按位或可能的最大值是 7 。有 6 个子集按位或可以得到 7 ：\n- [3,5]\n- [3,1,5]\n- [3,2,5]\n- [3,2,1,5]\n- [2,5]\n- [2,1,5]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 16</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2045到达目的地的第二短时间",
        "hardRate": "HARD",
        "passRate": "53.33%",
        "problemsUrl": "https://leetcode.cn/problems/second-minimum-time-to-reach-destination/",
        "solutionsUrl": "https://leetcode.cn/problems/second-minimum-time-to-reach-destination/solution",
        "problemsDesc": "<p>城市用一个 <strong>双向连通</strong> 图表示，图中有 <code>n</code> 个节点，从 <code>1</code> 到 <code>n</code> 编号（包含 <code>1</code> 和 <code>n</code>）。图中的边用一个二维整数数组 <code>edges</code> 表示，其中每个 <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code>&nbsp;表示一条节点&nbsp;<code>u<sub>i</sub></code> 和节点&nbsp;<code>v<sub>i</sub></code> 之间的双向连通边。每组节点对由 <strong>最多一条</strong> 边连通，顶点不存在连接到自身的边。穿过任意一条边的时间是 <code>time</code>&nbsp;分钟。</p>\n\n<p>每个节点都有一个交通信号灯，每 <code>change</code> 分钟改变一次，从绿色变成红色，再由红色变成绿色，循环往复。所有信号灯都&nbsp;<strong>同时</strong> 改变。你可以在 <strong>任何时候</strong> 进入某个节点，但是 <strong>只能</strong> 在节点&nbsp;<strong>信号灯是绿色时</strong> 才能离开。如果信号灯是&nbsp; <strong>绿色</strong> ，你 <strong>不能</strong> 在节点等待，必须离开。</p>\n\n<p><strong>第二小的值</strong> 是&nbsp;<strong>严格大于</strong> 最小值的所有值中最小的值。</p>\n\n<ul>\n\t<li>例如，<code>[2, 3, 4]</code> 中第二小的值是 <code>3</code> ，而 <code>[2, 2, 4]</code> 中第二小的值是 <code>4</code> 。</li>\n</ul>\n\n<p>给你 <code>n</code>、<code>edges</code>、<code>time</code> 和 <code>change</code> ，返回从节点 <code>1</code> 到节点 <code>n</code> 需要的 <strong>第二短时间</strong> 。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>你可以 <strong>任意次</strong> 穿过任意顶点，<strong>包括</strong> <code>1</code> 和 <code>n</code> 。</li>\n\t<li>你可以假设在 <strong>启程时</strong> ，所有信号灯刚刚变成 <strong>绿色</strong> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/29/e1.png\" style=\"width: 200px; height: 250px;\" />        <img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/29/e2.png\" style=\"width: 200px; height: 250px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5\n<strong>输出：</strong>13\n<strong>解释：</strong>\n上面的左图展现了给出的城市交通图。\n右图中的蓝色路径是最短时间路径。\n花费的时间是：\n- 从节点 1 开始，总花费时间=0\n- 1 -&gt; 4：3 分钟，总花费时间=3\n- 4 -&gt; 5：3 分钟，总花费时间=6\n因此需要的最小时间是 6 分钟。\n\n右图中的红色路径是第二短时间路径。\n- 从节点 1 开始，总花费时间=0\n- 1 -&gt; 3：3 分钟，总花费时间=3\n- 3 -&gt; 4：3 分钟，总花费时间=6\n- 在节点 4 等待 4 分钟，总花费时间=10\n- 4 -&gt; 5：3 分钟，总花费时间=13\n因此第二短时间是 13 分钟。      \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/29/eg2.png\" style=\"width: 225px; height: 50px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 2, edges = [[1,2]], time = 3, change = 2\n<strong>输出：</strong>11\n<strong>解释：</strong>\n最短时间路径是 1 -&gt; 2 ，总花费时间 = 3 分钟\n第二短时间路径是 1 -&gt; 2 -&gt; 1 -&gt; 2 ，总花费时间 = 11 分钟</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>n - 1 &lt;= edges.length &lt;= min(2 * 10<sup>4</sup>, n * (n - 1) / 2)</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n\t<li>不含重复边</li>\n\t<li>每个节点都可以从其他节点直接或者间接到达</li>\n\t<li><code>1 &lt;= time, change &lt;= 10<sup>3</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2046给按照绝对值排序的链表排序",
        "hardRate": "MEDIUM",
        "passRate": "64.14%",
        "problemsUrl": "https://leetcode.cn/problems/sort-linked-list-already-sorted-using-absolute-values/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-linked-list-already-sorted-using-absolute-values/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2047句子中的有效单词数",
        "hardRate": "EASY",
        "passRate": "38.62%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-valid-words-in-a-sentence/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-valid-words-in-a-sentence/solution",
        "problemsDesc": "<p>句子仅由小写字母（<code>'a'</code> 到 <code>'z'</code>）、数字（<code>'0'</code> 到 <code>'9'</code>）、连字符（<code>'-'</code>）、标点符号（<code>'!'</code>、<code>'.'</code> 和 <code>','</code>）以及空格（<code>' '</code>）组成。每个句子可以根据空格分解成 <strong>一个或者多个 token</strong> ，这些 token 之间由一个或者多个空格 <code>' '</code> 分隔。</p>\n\n<p>如果一个 token 同时满足下述条件，则认为这个 token 是一个有效单词：</p>\n\n<ul>\n\t<li>仅由小写字母、连字符和/或标点（不含数字）\b组成。</li>\n\t<li><strong>至多一个</strong> 连字符 <code>'-'</code> 。如果存在，连字符两侧应当都存在小写字母（<code>\"a-b\"</code> 是一个有效单词，但 <code>\"-ab\"</code> 和 <code>\"ab-\"</code> 不是有效单词）。</li>\n\t<li><strong>至多一个 </strong>标点符号。如果存在，标点符号应当位于 token 的 <strong>末尾</strong> 。</li>\n</ul>\n\n<p>这里给出几个有效单词的例子：<code>\"a-b.\"</code>、<code>\"afad\"</code>、<code>\"ba-c\"</code>、<code>\"a!\"</code> 和 <code>\"!\"</code> 。</p>\n\n<p>给你一个字符串 <code>sentence</code> ，请你找出并返回<em> </em><code>sentence</code> 中<strong> 有效单词的数目</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"<em><strong>cat</strong></em> <em><strong>and</strong></em>  <em><strong>dog</strong></em>\"\n<strong>输出：</strong>3\n<strong>解释：</strong>句子中的有效单词是 \"cat\"、\"and\" 和 \"dog\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"!this  1-s b8d!\"\n<strong>输出：</strong>0\n<strong>解释：</strong>句子中没有有效单词\n\"!this\" 不是有效单词，因为它以一个标点开头\n\"1-s\" 和 \"b8d\" 也不是有效单词，因为它们都包含数字\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"<em><strong>alice</strong></em> <em><strong>and</strong></em>  <em><strong>bob</strong></em> <em><strong>are</strong></em> <em><strong>playing</strong></em> stone-game10\"\n<strong>输出：</strong>5\n<strong>解释：</strong>句子中的有效单词是 \"alice\"、\"and\"、\"bob\"、\"are\" 和 \"playing\"\n\"stone-game10\" 不是有效单词，因为它含有数字\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentence.length &lt;= 1000</code></li>\n\t<li><code>sentence</code> 由小写英文字母、数字（<code>0-9</code>）、以及字符（<code>' '</code>、<code>'-'</code>、<code>'!'</code>、<code>'.'</code> 和 <code>','</code>）组成</li>\n\t<li>句子中至少有 <code>1</code> 个 token</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2048下一个更大的数值平衡数",
        "hardRate": "MEDIUM",
        "passRate": "45.42%",
        "problemsUrl": "https://leetcode.cn/problems/next-greater-numerically-balanced-number/",
        "solutionsUrl": "https://leetcode.cn/problems/next-greater-numerically-balanced-number/solution",
        "problemsDesc": "<p>如果整数&nbsp; <code>x</code> 满足：对于每个数位&nbsp;<code>d</code> ，这个数位&nbsp;<strong>恰好</strong> 在 <code>x</code> 中出现 <code>d</code> 次。那么整数 <code>x</code> 就是一个 <strong>数值平衡数</strong> 。</p>\n\n<p>给你一个整数 <code>n</code> ，请你返回 <strong>严格大于</strong> <code>n</code> 的 <strong>最小数值平衡数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>22\n<strong>解释：</strong>\n22 是一个数值平衡数，因为：\n- 数字 2 出现 2 次 \n这也是严格大于 1 的最小数值平衡数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1000\n<strong>输出：</strong>1333\n<strong>解释：</strong>\n1333 是一个数值平衡数，因为：\n- 数字 1 出现 1 次。\n- 数字 3 出现 3 次。 \n这也是严格大于 1000 的最小数值平衡数。\n注意，1022 不能作为本输入的答案，因为数字 0 的出现次数超过了 0 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3000\n<strong>输出：</strong>3133\n<strong>解释：</strong>\n3133 是一个数值平衡数，因为：\n- 数字 1 出现 1 次。\n- 数字 3 出现 3 次。 \n这也是严格大于 3000 的最小数值平衡数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2049统计最高分的节点数目",
        "hardRate": "MEDIUM",
        "passRate": "51.78%",
        "problemsUrl": "https://leetcode.cn/problems/count-nodes-with-the-highest-score/",
        "solutionsUrl": "https://leetcode.cn/problems/count-nodes-with-the-highest-score/solution",
        "problemsDesc": "<p>给你一棵根节点为 <code>0</code> 的&nbsp;<strong>二叉树</strong>&nbsp;，它总共有 <code>n</code>&nbsp;个节点，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。同时给你一个下标从&nbsp;<strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>parents</code>&nbsp;表示这棵树，其中&nbsp;<code>parents[i]</code>&nbsp;是节点 <code>i</code>&nbsp;的父节点。由于节点 <code>0</code>&nbsp;是根，所以&nbsp;<code>parents[0] == -1</code>&nbsp;。</p>\n\n<p>一个子树的 <strong>大小</strong>&nbsp;为这个子树内节点的数目。每个节点都有一个与之关联的&nbsp;<strong>分数</strong>&nbsp;。求出某个节点分数的方法是，将这个节点和与它相连的边全部 <strong>删除</strong>&nbsp;，剩余部分是若干个 <strong>非空</strong>&nbsp;子树，这个节点的 <strong>分数</strong>&nbsp;为所有这些子树 <strong>大小的乘积</strong>&nbsp;。</p>\n\n<p>请你返回有 <strong>最高得分</strong>&nbsp;节点的 <strong>数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<p><img alt=\"example-1\" src=\"https://assets.leetcode.com/uploads/2021/10/03/example-1.png\" style=\"width: 604px; height: 266px;\"></p>\n\n<pre><b>输入：</b>parents = [-1,2,0,2,0]\n<b>输出：</b>3\n<strong>解释：</strong>\n- 节点 0 的分数为：3 * 1 = 3\n- 节点 1 的分数为：4 = 4\n- 节点 2 的分数为：1 * 1 * 2 = 2\n- 节点 3 的分数为：4 = 4\n- 节点 4 的分数为：4 = 4\n最高得分为 4 ，有三个节点得分为 4 （分别是节点 1，3 和 4 ）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"example-2\" src=\"https://assets.leetcode.com/uploads/2021/10/03/example-2.png\" style=\"width: 95px; height: 143px;\"></p>\n\n<pre><b>输入：</b>parents = [-1,2,0]\n<b>输出：</b>2\n<strong>解释：</strong>\n- 节点 0 的分数为：2 = 2\n- 节点 1 的分数为：2 = 2\n- 节点 2 的分数为：1 * 1 = 1\n最高分数为 2 ，有两个节点分数为 2 （分别为节点 0 和 1 ）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == parents.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>parents[0] == -1</code></li>\n\t<li>对于&nbsp;<code>i != 0</code>&nbsp;，有&nbsp;<code>0 &lt;= parents[i] &lt;= n - 1</code></li>\n\t<li><code>parents</code>&nbsp;表示一棵二叉树。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2050并行课程 III",
        "hardRate": "HARD",
        "passRate": "58.52%",
        "problemsUrl": "https://leetcode.cn/problems/parallel-courses-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/parallel-courses-iii/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;，表示有&nbsp;<code>n</code>&nbsp;节课，课程编号从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;。同时给你一个二维整数数组&nbsp;<code>relations</code>&nbsp;，其中&nbsp;<code>relations[j] = [prevCourse<sub>j</sub>, nextCourse<sub>j</sub>]</code>&nbsp;，表示课程&nbsp;<code>prevCourse<sub>j</sub></code>&nbsp;必须在课程&nbsp;<code>nextCourse<sub>j</sub></code>&nbsp;<strong>之前</strong>&nbsp;完成（先修课的关系）。同时给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>time</code>&nbsp;，其中&nbsp;<code>time[i]</code>&nbsp;表示完成第&nbsp;<code>(i+1)</code>&nbsp;门课程需要花费的 <strong>月份</strong>&nbsp;数。</p>\n\n<p>请你根据以下规则算出完成所有课程所需要的 <strong>最少</strong>&nbsp;月份数：</p>\n\n<ul>\n\t<li>如果一门课的所有先修课都已经完成，你可以在 <strong>任意</strong>&nbsp;时间开始这门课程。</li>\n\t<li>你可以&nbsp;<strong>同时</strong>&nbsp;上&nbsp;<strong>任意门课程</strong>&nbsp;。</li>\n</ul>\n\n<p>请你返回完成所有课程所需要的 <strong>最少</strong>&nbsp;月份数。</p>\n\n<p><strong>注意：</strong>测试数据保证一定可以完成所有课程（也就是先修课的关系构成一个有向无环图）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/07/ex1.png\" style=\"width: 392px; height: 232px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 3, relations = [[1,3],[2,3]], time = [3,2,5]\n<b>输出：</b>8\n<b>解释：</b>上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。\n你可以在月份 0 同时开始课程 1 和 2 。\n课程 1 花费 3 个月，课程 2 花费 2 个月。\n所以，最早开始课程 3 的时间是月份 3 ，完成所有课程所需时间为 3 + 5 = 8 个月。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/07/ex2.png\" style=\"width: 500px; height: 365px;\"></strong></p>\n\n<pre><b>输入：</b>n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5]\n<b>输出：</b>12\n<b>解释：</b>上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。\n你可以在月份 0 同时开始课程 1 ，2 和 3 。\n在月份 1，2 和 3 分别完成这三门课程。\n课程 4 需在课程 3 之后开始，也就是 3 个月后。课程 4 在 3 + 4 = 7 月完成。\n课程 5 需在课程 1，2，3 和 4 之后开始，也就是在 max(1,2,3,7) = 7 月开始。\n所以完成所有课程所需的最少时间为 7 + 5 = 12 个月。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= relations.length &lt;= min(n * (n - 1) / 2, 5 * 10<sup>4</sup>)</code></li>\n\t<li><code>relations[j].length == 2</code></li>\n\t<li><code>1 &lt;= prevCourse<sub>j</sub>, nextCourse<sub>j</sub> &lt;= n</code></li>\n\t<li><code>prevCourse<sub>j</sub> != nextCourse<sub>j</sub></code></li>\n\t<li>所有的先修课程对&nbsp;<code>[prevCourse<sub>j</sub>, nextCourse<sub>j</sub>]</code>&nbsp;都是 <strong>互不相同</strong>&nbsp;的。</li>\n\t<li><code>time.length == n</code></li>\n\t<li><code>1 &lt;= time[i] &lt;= 10<sup>4</sup></code></li>\n\t<li>先修课程图是一个有向无环图。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2051商店中每个成员的级别",
        "hardRate": "MEDIUM",
        "passRate": "65.19%",
        "problemsUrl": "https://leetcode.cn/problems/the-category-of-each-member-in-the-store/",
        "solutionsUrl": "https://leetcode.cn/problems/the-category-of-each-member-in-the-store/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2052将句子分隔成行的最低成本",
        "hardRate": "MEDIUM",
        "passRate": "48.24%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-separate-sentence-into-rows/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-separate-sentence-into-rows/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2053数组中第 K 个独一无二的字符串",
        "hardRate": "EASY",
        "passRate": "71.13%",
        "problemsUrl": "https://leetcode.cn/problems/kth-distinct-string-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-distinct-string-in-an-array/solution",
        "problemsDesc": "<p><strong>独一无二的字符串</strong>&nbsp;指的是在一个数组中只出现过 <strong>一次</strong>&nbsp;的字符串。</p>\n\n<p>给你一个字符串数组&nbsp;<code>arr</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;，请你返回&nbsp;<code>arr</code>&nbsp;中第&nbsp;<code>k</code>&nbsp;个&nbsp;<strong>独一无二的字符串</strong>&nbsp;。如果&nbsp;<strong>少于</strong>&nbsp;<code>k</code>&nbsp;个独一无二的字符串，那么返回&nbsp;<strong>空字符串</strong>&nbsp;<code>\"\"</code>&nbsp;。</p>\n\n<p>注意，按照字符串在原数组中的 <strong>顺序</strong>&nbsp;找到第 <code>k</code>&nbsp;个独一无二字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><b>输入：</b>arr = [\"d\",\"b\",\"c\",\"b\",\"c\",\"a\"], k = 2\n<b>输出：</b>\"a\"\n<strong>解释：</strong>\narr 中独一无二字符串包括 \"d\" 和 \"a\"<code>&nbsp;。</code>\n\"d\" 首先出现，所以它是第 1 个独一无二字符串。\n\"a\" 第二个出现，所以它是 2 个独一无二字符串。\n由于 k == 2 ，返回 \"a\" 。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><b>输入：</b>arr = [\"aaa\",\"aa\",\"a\"], k = 1\n<b>输出：</b>\"aaa\"\n<strong>解释：</strong>\narr 中所有字符串都是独一无二的，所以返回第 1 个字符串 \"aaa\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>arr = [\"a\",\"b\",\"a\"], k = 3\n<b>输出：</b>\"\"\n<strong>解释：</strong>\n唯一一个独一无二字符串是 \"b\" 。由于少于 3 个独一无二字符串，我们返回空字符串 \"\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= arr[i].length &lt;= 5</code></li>\n\t<li><code>arr[i]</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2054两个最好的不重叠活动",
        "hardRate": "MEDIUM",
        "passRate": "38.25%",
        "problemsUrl": "https://leetcode.cn/problems/two-best-non-overlapping-events/",
        "solutionsUrl": "https://leetcode.cn/problems/two-best-non-overlapping-events/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>events</code>&nbsp;，其中&nbsp;<code>events[i] = [startTime<sub>i</sub>, endTime<sub>i</sub>, value<sub>i</sub>]</code>&nbsp;。第&nbsp;<code>i</code>&nbsp;个活动开始于&nbsp;<code>startTime<sub>i</sub></code>&nbsp;，结束于&nbsp;<code>endTime<sub>i</sub></code>&nbsp;，如果你参加这个活动，那么你可以得到价值&nbsp;<code>value<sub>i</sub></code>&nbsp;。你 <strong>最多</strong>&nbsp;可以参加&nbsp;<strong>两个时间不重叠</strong>&nbsp;活动，使得它们的价值之和 <strong>最大</strong>&nbsp;。</p>\n\n<p>请你返回价值之和的 <strong>最大值</strong>&nbsp;。</p>\n\n<p>注意，活动的开始时间和结束时间是 <strong>包括</strong>&nbsp;在活动时间内的，也就是说，你不能参加两个活动且它们之一的开始时间等于另一个活动的结束时间。更具体的，如果你参加一个活动，且结束时间为 <code>t</code>&nbsp;，那么下一个活动必须在&nbsp;<code>t + 1</code>&nbsp;或之后的时间开始。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/21/picture5.png\" style=\"width: 400px; height: 75px;\"></p>\n\n<pre><b>输入：</b>events = [[1,3,2],[4,5,2],[2,4,3]]\n<b>输出：</b>4\n<strong>解释：</strong>选择绿色的活动 0 和 1 ，价值之和为 2 + 2 = 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"Example 1 Diagram\" src=\"https://assets.leetcode.com/uploads/2021/09/21/picture1.png\" style=\"width: 400px; height: 77px;\"></p>\n\n<pre><b>输入：</b>events = [[1,3,2],[4,5,2],[1,5,5]]\n<b>输出：</b>5\n<strong>解释：</strong>选择活动 2 ，价值和为 5 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/21/picture3.png\" style=\"width: 400px; height: 66px;\"></p>\n\n<pre><b>输入：</b>events = [[1,5,3],[1,5,1],[6,6,5]]\n<b>输出：</b>8\n<strong>解释：</strong>选择活动 0 和 2 ，价值之和为 3 + 5 = 8 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= events.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>events[i].length == 3</code></li>\n\t<li><code>1 &lt;= startTime<sub>i</sub> &lt;= endTime<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= value<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2055蜡烛之间的盘子",
        "hardRate": "MEDIUM",
        "passRate": "43.43%",
        "problemsUrl": "https://leetcode.cn/problems/plates-between-candles/",
        "solutionsUrl": "https://leetcode.cn/problems/plates-between-candles/solution",
        "problemsDesc": "<p>给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>s</code>&nbsp;，它只包含字符&nbsp;<code>'*'</code> 和&nbsp;<code>'|'</code>&nbsp;，其中&nbsp;<code>'*'</code>&nbsp;表示一个 <strong>盘子</strong>&nbsp;，<code>'|'</code>&nbsp;表示一支&nbsp;<strong>蜡烛</strong>&nbsp;。</p>\n\n<p>同时给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>queries</code>&nbsp;，其中&nbsp;<code>queries[i] = [left<sub>i</sub>, right<sub>i</sub>]</code>&nbsp;表示 <strong>子字符串</strong>&nbsp;<code>s[left<sub>i</sub>...right<sub>i</sub>]</code>&nbsp;（<strong>包含左右端点的字符</strong>）。对于每个查询，你需要找到 <strong>子字符串中</strong>&nbsp;在 <strong>两支蜡烛之间</strong>&nbsp;的盘子的 <b>数目</b>&nbsp;。如果一个盘子在 <strong>子字符串中</strong>&nbsp;左边和右边 <strong>都</strong>&nbsp;至少有一支蜡烛，那么这个盘子满足在 <strong>两支蜡烛之间</strong>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，<code>s = \"||**||**|*\"</code>&nbsp;，查询&nbsp;<code>[3, 8]</code>&nbsp;，表示的是子字符串&nbsp;<code>\"*||<strong><em>**</em></strong>|\"</code>&nbsp;。子字符串中在两支蜡烛之间的盘子数目为&nbsp;<code>2</code>&nbsp;，子字符串中右边两个盘子在它们左边和右边 <strong>都 </strong>至少有一支蜡烛。</li>\n</ul>\n\n<p>请你返回一个整数数组&nbsp;<code>answer</code>&nbsp;，其中&nbsp;<code>answer[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个查询的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"ex-1\" src=\"https://assets.leetcode.com/uploads/2021/10/04/ex-1.png\" style=\"width: 400px; height: 134px;\"></p>\n\n<pre><b>输入：</b>s = \"**|**|***|\", queries = [[2,5],[5,9]]\n<b>输出：</b>[2,3]\n<b>解释：</b>\n- queries[0] 有两个盘子在蜡烛之间。\n- queries[1] 有三个盘子在蜡烛之间。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img alt=\"ex-2\" src=\"https://assets.leetcode.com/uploads/2021/10/04/ex-2.png\" style=\"width: 600px; height: 193px;\"></p>\n\n<pre><b>输入：</b>s = \"***|**|*****|**||**|*\", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]\n<b>输出：</b>[9,0,0,0,0]\n<strong>解释：</strong>\n- queries[0] 有 9 个盘子在蜡烛之间。\n- 另一个查询没有盘子在蜡烛之间。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含字符&nbsp;<code>'*'</code> 和&nbsp;<code>'|'</code>&nbsp;。</li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>0 &lt;= left<sub>i</sub> &lt;= right<sub>i</sub> &lt; s.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2056棋盘上有效移动组合的数目",
        "hardRate": "HARD",
        "passRate": "58.68%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-valid-move-combinations-on-chessboard/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-valid-move-combinations-on-chessboard/solution",
        "problemsDesc": "<p>有一个&nbsp;<code>8 x 8</code>&nbsp;的棋盘，它包含&nbsp;<code>n</code>&nbsp;个棋子（棋子包括车，后和象三种）。给你一个长度为 <code>n</code>&nbsp;的字符串数组&nbsp;<code>pieces</code>&nbsp;，其中&nbsp;<code>pieces[i]</code>&nbsp;表示第 <code>i</code>&nbsp;个棋子的类型（车，后或象）。除此以外，还给你一个长度为 <code>n</code>&nbsp;的二维整数数组&nbsp;<code>positions</code>&nbsp;，其中 <code>positions[i] = [r<sub>i</sub>, c<sub>i</sub>]</code>&nbsp;表示第 <code>i</code>&nbsp;个棋子现在在棋盘上的位置为&nbsp;<code>(r<sub>i</sub>, c<sub>i</sub>)</code>&nbsp;，棋盘下标从 <strong>1</strong>&nbsp;开始。</p>\n\n<p>棋盘上每个棋子都可以移动 <b>至多一次</b>&nbsp;。每个棋子的移动中，首先选择移动的 <strong>方向</strong>&nbsp;，然后选择 <strong>移动的步数</strong>&nbsp;，同时你要确保移动过程中棋子不能移到棋盘以外的地方。棋子需按照以下规则移动：</p>\n\n<ul>\n\t<li>车可以 <strong>水平或者竖直</strong>&nbsp;从&nbsp;<code>(r, c)</code>&nbsp;沿着方向&nbsp;<code>(r+1, c)</code>，<code>(r-1, c)</code>，<code>(r, c+1)</code>&nbsp;或者&nbsp;<code>(r, c-1)</code>&nbsp;移动。</li>\n\t<li>后可以 <strong>水平竖直或者斜对角</strong>&nbsp;从&nbsp;<code>(r, c)</code> 沿着方向&nbsp;<code>(r+1, c)</code>，<code>(r-1, c)</code>，<code>(r, c+1)</code>，<code>(r, c-1)</code>，<code>(r+1, c+1)</code>，<code>(r+1, c-1)</code>，<code>(r-1, c+1)</code>，<code>(r-1, c-1)</code>&nbsp;移动。</li>\n\t<li>象可以 <strong>斜对角</strong>&nbsp;从&nbsp;<code>(r, c)</code>&nbsp;沿着方向&nbsp;<code>(r+1, c+1)</code>，<code>(r+1, c-1)</code>，<code>(r-1, c+1)</code>，<code>(r-1, c-1)</code>&nbsp;移动。</li>\n</ul>\n\n<p><strong>移动组合</strong>&nbsp;包含所有棋子的 <strong>移动</strong>&nbsp;。每一秒，每个棋子都沿着它们选择的方向往前移动 <strong>一步</strong>&nbsp;，直到它们到达目标位置。所有棋子从时刻 <code>0</code>&nbsp;开始移动。如果在某个时刻，两个或者更多棋子占据了同一个格子，那么这个移动组合 <strong>不有效</strong>&nbsp;。</p>\n\n<p>请你返回 <strong>有效</strong>&nbsp;移动组合的数目。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>初始时，<strong>不会有两个棋子</strong>&nbsp;在 <strong>同一个位置 。</strong></li>\n\t<li>有可能在一个移动组合中，有棋子不移动。</li>\n\t<li>如果两个棋子 <strong>直接相邻</strong>&nbsp;且两个棋子下一秒要互相占据对方的位置，可以将它们在同一秒内 <strong>交换位置</strong>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/23/a1.png\" style=\"width: 215px; height: 215px;\" /></p>\n\n<pre>\n<b>输入：</b>pieces = [\"rook\"], positions = [[1,1]]\n<b>输出：</b>15\n<b>解释：</b>上图展示了棋子所有可能的移动。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/23/a2.png\" style=\"width: 215px; height: 215px;\" /></p>\n\n<pre>\n<b>输入：</b>pieces = [\"queen\"], positions = [[1,1]]\n<b>输出：</b>22\n<b>解释：</b>上图展示了棋子所有可能的移动。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/23/a3.png\" style=\"width: 214px; height: 215px;\" /></p>\n\n<pre>\n<b>输入：</b>pieces = [\"bishop\"], positions = [[4,3]]\n<b>输出：</b>12\n<b>解释：</b>上图展示了棋子所有可能的移动。\n</pre>\n\n<p><strong>示例 4:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/23/a4.png\" style=\"width: 216px; height: 219px;\" /></p>\n\n<pre>\n<b>输入：</b>pieces = [\"rook\",\"rook\"], positions = [[1,1],[8,8]]\n<b>输出：</b>223\n<b>解释：</b>每个车有 15 种移动，所以总共有 15 * 15 = 225 种移动组合。\n但是，有两个是不有效的移动组合：\n- 将两个车都移动到 (8, 1) ，会导致它们在同一个格子相遇。\n- 将两个车都移动到 (1, 8) ，会导致它们在同一个格子相遇。\n所以，总共有 225 - 2 = 223 种有效移动组合。\n注意，有两种有效的移动组合，分别是一个车在 (1, 8) ，另一个车在 (8, 1) 。\n即使棋盘状态是相同的，这两个移动组合被视为不同的，因为每个棋子移动操作是不相同的。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/23/a5.png\" style=\"width: 214px; height: 213px;\" /></p>\n\n<pre>\n<b>输入：</b>pieces = [\"queen\",\"bishop\"], positions = [[5,7],[3,4]]\n<b>输出：</b>281\n<b>解释：</b>总共有 12 * 24 = 288 种移动组合。\n但是，有一些不有效的移动组合：\n- 如果后停在 (6, 7) ，它会阻挡象到达 (6, 7) 或者 (7, 8) 。\n- 如果后停在 (5, 6) ，它会阻挡象到达 (5, 6) ，(6, 7) 或者 (7, 8) 。\n- 如果象停在 (5, 2) ，它会阻挡后到达 (5, 2) 或者 (5, 1) 。\n在 288 个移动组合当中，281 个是有效的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == pieces.length </code></li>\n\t<li><code>n == positions.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 4</code></li>\n\t<li><code>pieces</code>&nbsp;只包含字符串&nbsp;<code>\"rook\"</code>&nbsp;，<code>\"queen\"</code>&nbsp;和&nbsp;<code>\"bishop\"</code>&nbsp;。</li>\n\t<li>棋盘上总共最多只有一个后。</li>\n\t<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 8</code></li>\n\t<li>每一个&nbsp;<code>positions[i]</code>&nbsp;互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2057值相等的最小索引",
        "hardRate": "EASY",
        "passRate": "75.40%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-index-with-equal-value/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-index-with-equal-value/solution",
        "problemsDesc": "<p>给你一个下标从 0 开始的整数数组 <code>nums</code> ，返回 <code>nums</code> 中满足<em> </em><code>i mod 10 == nums[i]</code><em> </em>的最小下标 <code>i</code> ；如果不存在这样的下标，返回<em> </em><code>-1</code><em> </em>。</p>\n\n<p><code>x mod y</code> 表示 <code>x</code> 除以 <code>y</code> 的 <strong>余数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,2]\n<strong>输出：</strong>0\n<strong>解释：</strong>\ni=0: 0 mod 10 = 0 == nums[0].\ni=1: 1 mod 10 = 1 == nums[1].\ni=2: 2 mod 10 = 2 == nums[2].\n所有下标都满足 i mod 10 == nums[i] ，所以返回最小下标 0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,3,2,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>\ni=0: 0 mod 10 = 0 != nums[0].\ni=1: 1 mod 10 = 1 != nums[1].\ni=2: 2 mod 10 = 2 == nums[2].\ni=3: 3 mod 10 = 3 != nums[3].\n2 唯一一个满足 i mod 10 == nums[i] 的下标\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,5,6,7,8,9,0]\n<strong>输出：</strong>-1\n<strong>解释：</strong>不存在满足 i mod 10 == nums[i] 的下标\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,1,3,5,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>1 是唯一一个满足 i mod 10 == nums[i] 的下标\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2058找出临界点之间的最小和最大距离",
        "hardRate": "MEDIUM",
        "passRate": "56.45%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/solution",
        "problemsDesc": "<p>链表中的 <strong>临界点</strong> 定义为一个 <strong>局部极大值点</strong> <strong>或</strong> <strong>局部极小值点 。</strong></p>\n\n<p>如果当前节点的值 <strong>严格大于</strong> 前一个节点和后一个节点，那么这个节点就是一个<strong>&nbsp; 局部极大值点</strong> 。</p>\n\n<p>如果当前节点的值 <strong>严格小于</strong> 前一个节点和后一个节点，那么这个节点就是一个<strong>&nbsp; 局部极小值点</strong> 。</p>\n\n<p>注意：节点只有在同时存在前一个节点和后一个节点的情况下，才能成为一个 <strong>局部极大值点 / 极小值点</strong> 。</p>\n\n<p>给你一个链表 <code>head</code> ，返回一个长度为 2 的数组<em> </em><code>[minDistance, maxDistance]</code> ，其中<em> </em><code>minDistance</code><em> </em>是任意两个不同临界点之间的最小距离，<code>maxDistance</code> 是任意两个不同临界点之间的最大距离。如果临界点少于两个，则返回 <code>[-1，-1]</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/13/a1.png\" style=\"width: 148px; height: 55px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [3,1]\n<strong>输出：</strong>[-1,-1]\n<strong>解释：</strong>链表 [3,1] 中不存在临界点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/13/a2.png\" style=\"width: 624px; height: 46px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [5,3,1,2,5,1,2]\n<strong>输出：</strong>[1,3]\n<strong>解释：</strong>存在三个临界点：\n- [5,3,<em><strong>1</strong></em>,2,5,1,2]：第三个节点是一个局部极小值点，因为 1 比 3 和 2 小。\n- [5,3,1,2,<em><strong>5</strong></em>,1,2]：第五个节点是一个局部极大值点，因为 5 比 2 和 1 大。\n- [5,3,1,2,5,<em><strong>1</strong></em>,2]：第六个节点是一个局部极小值点，因为 1 比 5 和 2 小。\n第五个节点和第六个节点之间距离最小。minDistance = 6 - 5 = 1 。\n第三个节点和第六个节点之间距离最大。maxDistance = 6 - 3 = 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/14/a5.png\" style=\"width: 624px; height: 39px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,3,2,2,3,2,2,2,7]\n<strong>输出：</strong>[3,3]\n<strong>解释：</strong>存在两个临界点：\n- [1,<em><strong>3</strong></em>,2,2,3,2,2,2,7]：第二个节点是一个局部极大值点，因为 3 比 1 和 2 大。\n- [1,3,2,2,<em><strong>3</strong></em>,2,2,2,7]：第五个节点是一个局部极大值点，因为 3 比 2 和 2 大。\n最小和最大距离都存在于第二个节点和第五个节点之间。\n因此，minDistance 和 maxDistance 是 5 - 2 = 3 。\n注意，最后一个节点不算一个局部极大值点，因为它之后就没有节点了。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/13/a4.png\" style=\"width: 345px; height: 52px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [2,3,3,2]\n<strong>输出：</strong>[-1,-1]\n<strong>解释：</strong>链表 [2,3,3,2] 中不存在临界点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数量在范围 <code>[2, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2059转化数字的最小运算数",
        "hardRate": "MEDIUM",
        "passRate": "48.12%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-convert-number/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-convert-number/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，该数组由 <strong>互不相同</strong> 的数字组成。另给你两个整数 <code>start</code> 和 <code>goal</code> 。</p>\n\n<p>整数 <code>x</code> 的值最开始设为 <code>start</code> ，你打算执行一些运算使 <code>x</code> 转化为 <code>goal</code> 。你可以对数字 <code>x</code> 重复执行下述运算：</p>\n\n<p>如果 <code>0 &lt;= x &lt;= 1000</code> ，那么，对于数组中的任一下标 <code>i</code>（<code>0 &lt;= i &lt; nums.length</code>），可以将 <code>x</code> 设为下述任一值：</p>\n\n<ul>\n\t<li><code>x + nums[i]</code></li>\n\t<li><code>x - nums[i]</code></li>\n\t<li><code>x ^ nums[i]</code>（按位异或 XOR）</li>\n</ul>\n\n<p>注意，你可以按任意顺序使用每个 <code>nums[i]</code> 任意次。使 <code>x</code> 越过 <code>0 &lt;= x &lt;= 1000</code> 范围的运算同样可以生效，但该该运算执行后将不能执行其他运算。</p>\n\n<p>返回将 <code>x = start</code><em> </em>转化为<em> </em><code>goal</code><em> </em>的最小操作数；如果无法完成转化，则返回<em> </em><code>-1</code><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,4,12], start = 2, goal = 12\n<strong>输出：</strong>2\n<strong>解释：</strong>\n可以按 2 → 14 → 12 的转化路径进行，只需执行下述 2 次运算：\n- 2 + 12 = 14\n- 14 - 2 = 12\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,5,7], start = 0, goal = -4\n<strong>输出：</strong>2\n<strong>解释：</strong>\n可以按 0 → 3 → -4 的转化路径进行，只需执行下述 2 次运算：\n- 0 + 3 = 3\n- 3 - 7 = -4\n注意，最后一步运算使 x 超过范围 0 &lt;= x &lt;= 1000 ，但该运算仍然可以生效。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,8,16], start = 0, goal = 1\n<strong>输出：</strong>-1\n<strong>解释：</strong>\n无法将 0 转化为 1</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i], goal &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= start &lt;= 1000</code></li>\n\t<li><code>start != goal</code></li>\n\t<li><code>nums</code> 中的所有整数互不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2060同源字符串检测",
        "hardRate": "HARD",
        "passRate": "40.36%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-an-original-string-exists-given-two-encoded-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-an-original-string-exists-given-two-encoded-strings/solution",
        "problemsDesc": "<p>原字符串由小写字母组成，可以按下述步骤编码：</p>\n\n<ul>\n\t<li>任意将其 <strong>分割</strong> 为由若干 <strong>非空</strong> 子字符串组成的一个 <strong>序列</strong> 。</li>\n\t<li>任意选择序列中的一些元素（也可能不选择），然后将这些元素替换为元素各自的长度（作为一个数字型的字符串）。</li>\n\t<li>重新 <strong>顺次连接</strong> 序列，得到编码后的字符串。</li>\n</ul>\n\n<p>例如，编码 <code>\"abcdefghijklmnop\"</code> 的一种方法可以描述为：</p>\n\n<ul>\n\t<li>将原字符串分割得到一个序列：<code>[\"ab\", \"cdefghijklmn\", \"o\", \"p\"]</code> 。</li>\n\t<li>选出其中第二个和第三个元素并分别替换为它们自身的长度。序列变为 <code>[\"ab\", \"12\", \"1\", \"p\"]</code> 。</li>\n\t<li>重新顺次连接序列中的元素，得到编码后的字符串：<code>\"ab121p\"</code> 。</li>\n</ul>\n\n<p>给你两个编码后的字符串 <code>s1</code> 和 <code>s2</code> ，由小写英文字母和数字 <code>1-9</code> 组成。如果存在能够同时编码得到 <code>s1</code> 和 <code>s2</code> 原字符串，返回 <code>true</code> ；否则，返回 <code>false</code>。</p>\n\n<p><strong>注意：</strong>生成的测试用例满足 <code>s1</code> 和 <code>s2</code> 中连续数字数不超过 <code>3</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"internationalization\", s2 = \"i18n\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\"internationalization\" 可以作为原字符串\n- \"internationalization\" \n  -&gt; 分割：      [\"internationalization\"]\n  -&gt; 不替换任何元素\n  -&gt; 连接：      \"internationalization\"，得到 s1\n- \"internationalization\"\n  -&gt; 分割：      [\"i\", \"nternationalizatio\", \"n\"]\n  -&gt; 替换：      [\"i\", \"18\",                 \"n\"]\n  -&gt; 连接：      \"i18n\"，得到 s2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"l123e\", s2 = \"44\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\"leetcode\" 可以作为原字符串\n- \"leetcode\" \n  -&gt; 分割：       [\"l\", \"e\", \"et\", \"cod\", \"e\"]\n  -&gt; 替换：       [\"l\", \"1\", \"2\",  \"3\",   \"e\"]\n  -&gt; 连接：       \"l123e\"，得到 s1\n- \"leetcode\" \n  -&gt; 分割：       [\"leet\", \"code\"]\n  -&gt; 替换：       [\"4\",    \"4\"]\n  -&gt; 连接：       \"44\"，得到 s2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"a5b\", s2 = \"c5b\"\n<strong>输出：</strong>false\n<strong>解释：</strong>不存在这样的原字符串\n- 编码为 s1 的字符串必须以字母 'a' 开头\n- 编码为 s2 的字符串必须以字母 'c' 开头\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"112s\", s2 = \"g841\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\"gaaaaaaaaaaaas\" 可以作为原字符串\n- \"gaaaaaaaaaaaas\"\n  -&gt; 分割：       [\"g\", \"aaaaaaaaaaaa\", \"s\"]\n  -&gt; 替换：       [\"1\", \"12\",           \"s\"]\n  -&gt; 连接：       \"112s\"，得到 s1\n- \"gaaaaaaaaaaaas\"\n  -&gt; 分割：       [\"g\", \"aaaaaaaa\", \"aaaa\", \"s\"]\n  -&gt; 替换：       [\"g\", \"8\",        \"4\",    \"1\"]\n  -&gt; 连接         \"g841\"，得到 s2\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>s1 = \"ab\", s2 = \"a2\"\n<strong>输出：</strong>false\n<strong>解释：</strong>不存在这样的原字符串\n- 编码为 s1 的字符串由两个字母组成\n- 编码为 s2 的字符串由三个字母组成\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 40</code></li>\n\t<li><code>s1</code> 和 <code>s2</code> 仅由数字 <code>1-9</code> 和小写英文字母组成</li>\n\t<li><code>s1</code> 和 <code>s2</code> 中连续数字数不超过 <code>3</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2061扫地机器人清扫过的空间个数",
        "hardRate": "MEDIUM",
        "passRate": "50.15%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-spaces-cleaning-robot-cleaned/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-spaces-cleaning-robot-cleaned/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2062统计字符串中的元音子字符串",
        "hardRate": "EASY",
        "passRate": "62.68%",
        "problemsUrl": "https://leetcode.cn/problems/count-vowel-substrings-of-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/count-vowel-substrings-of-a-string/solution",
        "problemsDesc": "<p><strong>子字符串</strong> 是字符串中的一个连续（非空）的字符序列。</p>\n\n<p><strong>元音子字符串</strong> 是 <strong>仅</strong> 由元音（<code>'a'</code>、<code>'e'</code>、<code>'i'</code>、<code>'o'</code> 和 <code>'u'</code>）组成的一个子字符串，且必须包含 <strong>全部五种</strong> 元音。</p>\n\n<p>给你一个字符串 <code>word</code> ，统计并返回 <code>word</code> 中 <strong>元音子字符串的数目</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"aeiouu\"\n<strong>输出：</strong>2\n<strong>解释：</strong>下面列出 word 中的元音子字符串（斜体加粗部分）：\n- \"<em><strong>aeiou</strong></em>u\"\n- \"<strong><em>aeiouu</em></strong>\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"unicornarihan\"\n<strong>输出：</strong>0\n<strong>解释：</strong>word 中不含 5 种元音，所以也不会存在元音子字符串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"cuaieuouac\"\n<strong>输出：</strong>7\n<strong>解释：</strong>下面列出 word 中的元音子字符串（斜体加粗部分）：\n- \"c<em><strong>uaieuo</strong></em>uac\"\n- \"c<em><strong>uaieuou</strong></em>ac\"\n- \"c<em><strong>uaieuoua</strong></em>c\"\n- \"cu<em><strong>aieuo</strong></em>uac\"\n- \"cu<em><strong>aieuou</strong></em>ac\"\n- \"cu<em><strong>aieuoua</strong></em>c\"\n- \"cua<em><strong>ieuoua</strong></em>c\"</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"bbaeixoubb\"\n<strong>输出：</strong>0\n<strong>解释：</strong>所有包含全部五种元音的子字符串都含有辅音，所以不存在元音子字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 100</code></li>\n\t<li><code>word</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2063所有子字符串中的元音",
        "hardRate": "MEDIUM",
        "passRate": "51.68%",
        "problemsUrl": "https://leetcode.cn/problems/vowels-of-all-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/vowels-of-all-substrings/solution",
        "problemsDesc": "<p>给你一个字符串 <code>word</code> ，返回 <code>word</code> 的所有子字符串中 <strong>元音的总数</strong> ，元音是指 <code>'a'</code>、<code>'e'</code><em>、</em><code>'i'</code><em>、</em><code>'o'</code><em> </em>和 <code>'u'</code><em> 。</em></p>\n\n<p><strong>子字符串</strong> 是字符串中一个连续（非空）的字符序列。</p>\n\n<p><strong>注意：</strong>由于对 <code>word</code> 长度的限制比较宽松，答案可能超过有符号 32 位整数的范围。计算时需当心。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"aba\"\n<strong>输出：</strong>6\n<strong>解释：</strong>\n所有子字符串是：\"a\"、\"ab\"、\"aba\"、\"b\"、\"ba\" 和 \"a\" 。\n- \"b\" 中有 0 个元音\n- \"a\"、\"ab\"、\"ba\" 和 \"a\" 每个都有 1 个元音\n- \"aba\" 中有 2 个元音\n因此，元音总数 = 0 + 1 + 1 + 1 + 1 + 2 = 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"abc\"\n<strong>输出：</strong>3\n<strong>解释：</strong>\n所有子字符串是：\"a\"、\"ab\"、\"abc\"、\"b\"、\"bc\" 和 \"c\" 。\n- \"a\"、\"ab\" 和 \"abc\" 每个都有 1 个元音\n- \"b\"、\"bc\" 和 \"c\" 每个都有 0 个元音\n因此，元音总数 = 1 + 1 + 1 + 0 + 0 + 0 = 3 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"ltcd\"\n<strong>输出：</strong>0\n<strong>解释：</strong>\"ltcd\" 的子字符串均不含元音。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"noosabasboosa\"\n<strong>输出：</strong>237\n<strong>解释：</strong>所有子字符串中共有 237 个元音。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>word</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2064分配给商店的最多商品的最小值",
        "hardRate": "MEDIUM",
        "passRate": "45.02%",
        "problemsUrl": "https://leetcode.cn/problems/minimized-maximum-of-products-distributed-to-any-store/",
        "solutionsUrl": "https://leetcode.cn/problems/minimized-maximum-of-products-distributed-to-any-store/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;，表示有&nbsp;<code>n</code>&nbsp;间零售商店。总共有&nbsp;<code>m</code>&nbsp;种产品，每种产品的数目用一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>quantities</code>&nbsp;表示，其中&nbsp;<code>quantities[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;种商品的数目。</p>\n\n<p>你需要将 <strong>所有商品</strong>&nbsp;分配到零售商店，并遵守这些规则：</p>\n\n<ul>\n\t<li>一间商店 <strong>至多</strong>&nbsp;只能有 <strong>一种商品</strong> ，但一间商店拥有的商品数目可以为&nbsp;<strong>任意</strong>&nbsp;件。</li>\n\t<li>分配后，每间商店都会被分配一定数目的商品（可能为 <code>0</code>&nbsp;件）。用&nbsp;<code>x</code>&nbsp;表示所有商店中分配商品数目的最大值，你希望 <code>x</code>&nbsp;越小越好。也就是说，你想 <strong>最小化</strong>&nbsp;分配给任意商店商品数目的 <strong>最大值</strong>&nbsp;。</li>\n</ul>\n\n<p>请你返回最小的可能的&nbsp;<code>x</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 6, quantities = [11,6]\n<b>输出：</b>3\n<strong>解释： </strong>一种最优方案为：\n- 11 件种类为 0 的商品被分配到前 4 间商店，分配数目分别为：2，3，3，3 。\n- 6 件种类为 1 的商品被分配到另外 2 间商店，分配数目分别为：3，3 。\n分配给所有商店的最大商品数目为 max(2, 3, 3, 3, 3, 3) = 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 7, quantities = [15,10,10]\n<b>输出：</b>5\n<b>解释：</b>一种最优方案为：\n- 15 件种类为 0 的商品被分配到前 3 间商店，分配数目为：5，5，5 。\n- 10 件种类为 1 的商品被分配到接下来 2 间商店，数目为：5，5 。\n- 10 件种类为 2 的商品被分配到最后 2 间商店，数目为：5，5 。\n分配给所有商店的最大商品数目为 max(5, 5, 5, 5, 5, 5, 5) = 5 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 1, quantities = [100000]\n<b>输出：</b>100000\n<b>解释：</b>唯一一种最优方案为：\n- 所有 100000 件商品 0 都分配到唯一的商店中。\n分配给所有商店的最大商品数目为 max(100000) = 100000 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == quantities.length</code></li>\n\t<li><code>1 &lt;= m &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= quantities[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2065最大化一张图中的路径价值",
        "hardRate": "HARD",
        "passRate": "54.27%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-path-quality-of-a-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-path-quality-of-a-graph/solution",
        "problemsDesc": "<p>给你一张 <strong>无向</strong>&nbsp;图，图中有 <code>n</code>&nbsp;个节点，节点编号从 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;（<strong>都包括</strong>）。同时给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>values</code>&nbsp;，其中&nbsp;<code>values[i]</code>&nbsp;是第 <code>i</code>&nbsp;个节点的 <strong>价值</strong>&nbsp;。同时给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[j] = [u<sub>j</sub>, v<sub>j</sub>, time<sub>j</sub>]</code>&nbsp;表示节点&nbsp;<code>u<sub>j</sub></code> 和&nbsp;<code>v<sub>j</sub></code>&nbsp;之间有一条需要&nbsp;<code>time<sub>j</sub></code>&nbsp;秒才能通过的无向边。最后，给你一个整数&nbsp;<code>maxTime</code>&nbsp;。</p>\n\n<p><strong>合法路径</strong>&nbsp;指的是图中任意一条从节点&nbsp;<code>0</code>&nbsp;开始，最终回到节点 <code>0</code>&nbsp;，且花费的总时间 <strong>不超过</strong>&nbsp;<code>maxTime</code> 秒的一条路径。你可以访问一个节点任意次。一条合法路径的 <b>价值</b>&nbsp;定义为路径中 <strong>不同节点</strong>&nbsp;的价值 <strong>之和</strong>&nbsp;（每个节点的价值 <strong>至多</strong>&nbsp;算入价值总和中一次）。</p>\n\n<p>请你返回一条合法路径的 <strong>最大</strong>&nbsp;价值。</p>\n\n<p><strong>注意：</strong>每个节点 <strong>至多</strong>&nbsp;有 <strong>四条</strong>&nbsp;边与之相连。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/19/ex1drawio.png\" style=\"width: 269px; height: 170px;\" /></p>\n\n<pre>\n<b>输入：</b>values = [0,32,10,43], edges = [[0,1,10],[1,2,15],[0,3,10]], maxTime = 49\n<b>输出：</b>75\n<strong>解释：</strong>\n一条可能的路径为：0 -&gt; 1 -&gt; 0 -&gt; 3 -&gt; 0 。总花费时间为 10 + 10 + 10 + 10 = 40 &lt;= 49 。\n访问过的节点为 0 ，1 和 3 ，最大路径价值为 0 + 32 + 43 = 75 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/19/ex2drawio.png\" style=\"width: 269px; height: 170px;\" /></p>\n\n<pre>\n<b>输入：</b>values = [5,10,15,20], edges = [[0,1,10],[1,2,10],[0,3,10]], maxTime = 30\n<b>输出：</b>25\n<strong>解释：</strong>\n一条可能的路径为：0 -&gt; 3 -&gt; 0 。总花费时间为 10 + 10 = 20 &lt;= 30 。\n访问过的节点为 0 和 3 ，最大路径价值为 5 + 20 = 25 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/19/ex31drawio.png\" style=\"width: 236px; height: 170px;\" /></p>\n\n<pre>\n<b>输入：</b>values = [1,2,3,4], edges = [[0,1,10],[1,2,11],[2,3,12],[1,3,13]], maxTime = 50\n<b>输出：</b>7\n<strong>解释：</strong>\n一条可能的路径为：0 -&gt; 1 -&gt; 3 -&gt; 1 -&gt; 0 。总花费时间为 10 + 13 + 13 + 10 = 46 &lt;= 50 。\n访问过的节点为 0 ，1 和 3 ，最大路径价值为 1 + 2 + 4 = 7 。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/21/ex4drawio.png\" style=\"width: 270px; height: 71px;\" /></strong></p>\n\n<pre>\n<b>输入：</b>values = [0,1,2], edges = [[1,2,10]], maxTime = 10\n<b>输出：</b>0\n<b>解释：</b>\n唯一一条路径为 0 。总花费时间为 0 。\n唯一访问过的节点为 0 ，最大路径价值为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == values.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= values[i] &lt;= 10<sup>8</sup></code></li>\n\t<li><code>0 &lt;= edges.length &lt;= 2000</code></li>\n\t<li><code>edges[j].length == 3 </code></li>\n\t<li><code>0 &lt;= u<sub>j </sub>&lt; v<sub>j</sub> &lt;= n - 1</code></li>\n\t<li><code>10 &lt;= time<sub>j</sub>, maxTime &lt;= 100</code></li>\n\t<li><code>[u<sub>j</sub>, v<sub>j</sub>]</code>&nbsp;所有节点对 <strong>互不相同</strong>&nbsp;。</li>\n\t<li>每个节点 <strong>至多有四条&nbsp;</strong>边。</li>\n\t<li>图可能不连通。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2066账户余额",
        "hardRate": "MEDIUM",
        "passRate": "78.78%",
        "problemsUrl": "https://leetcode.cn/problems/account-balance/",
        "solutionsUrl": "https://leetcode.cn/problems/account-balance/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2067等计数子串的数量",
        "hardRate": "MEDIUM",
        "passRate": "54.48%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-equal-count-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-equal-count-substrings/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2068检查两个字符串是否几乎相等",
        "hardRate": "EASY",
        "passRate": "69.99%",
        "problemsUrl": "https://leetcode.cn/problems/check-whether-two-strings-are-almost-equivalent/",
        "solutionsUrl": "https://leetcode.cn/problems/check-whether-two-strings-are-almost-equivalent/solution",
        "problemsDesc": "<p>如果两个字符串 <code>word1</code>&nbsp;和 <code>word2</code>&nbsp;中从 <code>'a'</code>&nbsp;到 <code>'z'</code>&nbsp;每一个字母出现频率之差都 <strong>不超过</strong>&nbsp;<code>3</code>&nbsp;，那么我们称这两个字符串&nbsp;<code>word1</code> 和&nbsp;<code>word2</code> <strong>几乎相等</strong>&nbsp;。</p>\n\n<p>给你两个长度都为&nbsp;<code>n</code>&nbsp;的字符串&nbsp;<code>word1</code> 和&nbsp;<code>word2</code>&nbsp;，如果&nbsp;<code>word1</code>&nbsp;和&nbsp;<code>word2</code>&nbsp;<strong>几乎相等</strong>&nbsp;，请你返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>一个字母 <code>x</code>&nbsp;的出现 <strong>频率</strong>&nbsp;指的是它在字符串中出现的次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>word1 = \"aaaa\", word2 = \"bccb\"\n<b>输出：</b>false\n<b>解释：</b>字符串 \"aaaa\" 中有 4 个 'a' ，但是 \"bccb\" 中有 0 个 'a' 。\n两者之差为 4 ，大于上限 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>word1 = \"abcdeef\", word2 = \"abaaacc\"\n<b>输出：</b>true\n<b>解释：</b>word1 和 word2 中每个字母出现频率之差至多为 3 ：\n- 'a' 在 word1 中出现了 1 次，在 word2 中出现了 4 次，差为 3 。\n- 'b' 在 word1 中出现了 1 次，在 word2 中出现了 1 次，差为 0 。\n- 'c' 在 word1 中出现了 1 次，在 word2 中出现了 2 次，差为 1 。\n- 'd' 在 word1 中出现了 1 次，在 word2 中出现了 0 次，差为 1 。\n- 'e' 在 word1 中出现了 2 次，在 word2 中出现了 0 次，差为 2 。\n- 'f' 在 word1 中出现了 1 次，在 word2 中出现了 0 次，差为 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>word1 = \"cccddabba\", word2 = \"babababab\"\n<b>输出：</b>true\n<b>解释：</b>word1 和 word2 中每个字母出现频率之差至多为 3 ：\n- 'a' 在 word1 中出现了 2 次，在 word2 中出现了 4 次，差为 2 。\n- 'b' 在 word1 中出现了 2 次，在 word2 中出现了 5 次，差为 3 。\n- 'c' 在 word1 中出现了 3 次，在 word2 中出现了 0 次，差为 3 。\n- 'd' 在 word1 中出现了 2 次，在 word2 中出现了 0 次，差为 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == word1.length == word2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>word1</code> 和&nbsp;<code>word2</code>&nbsp;都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2069模拟行走机器人 II",
        "hardRate": "MEDIUM",
        "passRate": "22.12%",
        "problemsUrl": "https://leetcode.cn/problems/walking-robot-simulation-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/walking-robot-simulation-ii/solution",
        "problemsDesc": "<p>给你一个在 XY 平面上的&nbsp;<code>width x height</code>&nbsp;的网格图，<strong>左下角</strong>&nbsp;的格子为&nbsp;<code>(0, 0)</code>&nbsp;，<strong>右上角</strong>&nbsp;的格子为&nbsp;<code>(width - 1, height - 1)</code>&nbsp;。网格图中相邻格子为四个基本方向之一（<code>\"North\"</code>，<code>\"East\"</code>，<code>\"South\"</code>&nbsp;和&nbsp;<code>\"West\"</code>）。一个机器人 <strong>初始</strong>&nbsp;在格子&nbsp;<code>(0, 0)</code>&nbsp;，方向为&nbsp;<code>\"East\"</code>&nbsp;。</p>\n\n<p>机器人可以根据指令移动指定的 <strong>步数</strong>&nbsp;。每一步，它可以执行以下操作。</p>\n\n<ol>\n\t<li>沿着当前方向尝试 <strong>往前一步</strong>&nbsp;。</li>\n\t<li>如果机器人下一步将到达的格子 <strong>超出了边界</strong>&nbsp;，机器人会 <strong>逆时针</strong>&nbsp;转 90 度，然后再尝试往前一步。</li>\n</ol>\n\n<p>如果机器人完成了指令要求的移动步数，它将停止移动并等待下一个指令。</p>\n\n<p>请你实现&nbsp;<code>Robot</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>Robot(int width, int height)</code>&nbsp;初始化一个&nbsp;<code>width x height</code>&nbsp;的网格图，机器人初始在&nbsp;<code>(0, 0)</code>&nbsp;，方向朝&nbsp;<code>\"East\"</code>&nbsp;。</li>\n\t<li><code>void step(int num)</code>&nbsp;给机器人下达前进&nbsp;<code>num</code>&nbsp;步的指令。</li>\n\t<li><code>int[] getPos()</code>&nbsp;返回机器人当前所处的格子位置，用一个长度为 2 的数组&nbsp;<code>[x, y]</code>&nbsp;表示。</li>\n\t<li><code>String getDir()</code>&nbsp;返回当前机器人的朝向，为&nbsp;<code>\"North\"</code>&nbsp;，<code>\"East\"</code>&nbsp;，<code>\"South\"</code>&nbsp;或者&nbsp;<code>\"West\"</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"example-1\" src=\"https://assets.leetcode.com/uploads/2021/10/09/example-1.png\" style=\"width: 498px; height: 268px;\" /></p>\n\n<pre>\n<strong>输入：</strong>\n[\"Robot\", \"step\", \"step\", \"getPos\", \"getDir\", \"step\", \"step\", \"step\", \"getPos\", \"getDir\"]\n[[6, 3], [2], [2], [], [], [2], [1], [4], [], []]\n<strong>输出：</strong>\n[null, null, null, [4, 0], \"East\", null, null, null, [1, 2], \"West\"]\n\n<strong>解释：</strong>\nRobot robot = new Robot(6, 3); // 初始化网格图，机器人在 (0, 0) ，朝东。\nrobot.step(2);  // 机器人朝东移动 2 步，到达 (2, 0) ，并朝东。\nrobot.step(2);  // 机器人朝东移动 2 步，到达 (4, 0) ，并朝东。\nrobot.getPos(); // 返回 [4, 0]\nrobot.getDir(); // 返回 \"East\"\nrobot.step(2);  // 朝东移动 1 步到达 (5, 0) ，并朝东。\n                // 下一步继续往东移动将出界，所以逆时针转变方向朝北。\n                // 然后，往北移动 1 步到达 (5, 1) ，并朝北。\nrobot.step(1);  // 朝北移动 1 步到达 (5, 2) ，并朝 <strong>北</strong> （不是朝西）。\nrobot.step(4);  // 下一步继续往北移动将出界，所以逆时针转变方向朝西。\n                // 然后，移动 4 步到 (1, 2) ，并朝西。\nrobot.getPos(); // 返回 [1, 2]\nrobot.getDir(); // 返回 \"West\"\n\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= width, height &lt;= 100</code></li>\n\t<li><code>1 &lt;= num &lt;= 10<sup>5</sup></code></li>\n\t<li><code>step</code> ，<code>getPos</code>&nbsp;和&nbsp;<code>getDir</code>&nbsp;<strong>总共&nbsp;</strong>调用次数不超过&nbsp;<code>10<sup>4</sup></code>&nbsp;次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2070每一个查询的最大美丽值",
        "hardRate": "MEDIUM",
        "passRate": "45.08%",
        "problemsUrl": "https://leetcode.cn/problems/most-beautiful-item-for-each-query/",
        "solutionsUrl": "https://leetcode.cn/problems/most-beautiful-item-for-each-query/solution",
        "problemsDesc": "<p>给你一个二维整数数组&nbsp;<code>items</code>&nbsp;，其中&nbsp;<code>items[i] = [price<sub>i</sub>, beauty<sub>i</sub>]</code>&nbsp;分别表示每一个物品的 <strong>价格</strong>&nbsp;和 <strong>美丽值</strong>&nbsp;。</p>\n\n<p>同时给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>queries</code>&nbsp;。对于每个查询&nbsp;<code>queries[j]</code>&nbsp;，你想求出价格小于等于&nbsp;<code>queries[j]</code>&nbsp;的物品中，<strong>最大的美丽值</strong>&nbsp;是多少。如果不存在符合条件的物品，那么查询的结果为&nbsp;<code>0</code>&nbsp;。</p>\n\n<p>请你返回一个长度与 <code>queries</code>&nbsp;相同的数组<em>&nbsp;</em><code>answer</code>，其中<em>&nbsp;</em><code>answer[j]</code>是第&nbsp;<code>j</code>&nbsp;个查询的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]\n<b>输出：</b>[2,4,5,5,6,6]\n<strong>解释：</strong>\n- queries[0]=1 ，[1,2] 是唯一价格 &lt;= 1 的物品。所以这个查询的答案为 2 。\n- queries[1]=2 ，符合条件的物品有 [1,2] 和 [2,4] 。\n  它们中的最大美丽值为 4 。\n- queries[2]=3 和 queries[3]=4 ，符合条件的物品都为 [1,2] ，[3,2] ，[2,4] 和 [3,5] 。\n  它们中的最大美丽值为 5 。\n- queries[4]=5 和 queries[5]=6 ，所有物品都符合条件。\n  所以，答案为所有物品中的最大美丽值，为 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]\n<b>输出：</b>[4]\n<b>解释：</b>\n每个物品的价格均为 1 ，所以我们选择最大美丽值 4 。\n注意，多个物品可能有相同的价格和美丽值。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>items = [[10,1000]], queries = [5]\n<b>输出：</b>[0]\n<strong>解释：</strong>\n没有物品的价格小于等于 5 ，所以没有物品可以选择。\n因此，查询的结果为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= items.length, queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>items[i].length == 2</code></li>\n\t<li><code>1 &lt;= price<sub>i</sub>, beauty<sub>i</sub>, queries[j] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2071你可以安排的最多任务数目",
        "hardRate": "HARD",
        "passRate": "29.95%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-tasks-you-can-assign/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-tasks-you-can-assign/solution",
        "problemsDesc": "<p>给你&nbsp;<code>n</code>&nbsp;个任务和&nbsp;<code>m</code>&nbsp;个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>tasks</code>&nbsp;中，第 <code>i</code>&nbsp;个任务需要&nbsp;<code>tasks[i]</code>&nbsp;的力量才能完成。每个工人的力量值保存在下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>workers</code>&nbsp;中，第&nbsp;<code>j</code>&nbsp;个工人的力量值为&nbsp;<code>workers[j]</code>&nbsp;。每个工人只能完成 <strong>一个</strong>&nbsp;任务，且力量值需要 <strong>大于等于</strong>&nbsp;该任务的力量要求值（即&nbsp;<code>workers[j] &gt;= tasks[i]</code>&nbsp;）。</p>\n\n<p>除此以外，你还有&nbsp;<code>pills</code>&nbsp;个神奇药丸，可以给 <strong>一个工人的力量值</strong>&nbsp;增加&nbsp;<code>strength</code>&nbsp;。你可以决定给哪些工人使用药丸，但每个工人&nbsp;<strong>最多</strong>&nbsp;只能使用&nbsp;<strong>一片</strong>&nbsp;药丸。</p>\n\n<p>给你下标从 <strong>0</strong>&nbsp;开始的整数数组<code>tasks</code> 和&nbsp;<code>workers</code>&nbsp;以及两个整数&nbsp;<code>pills</code> 和&nbsp;<code>strength</code>&nbsp;，请你返回 <strong>最多</strong>&nbsp;有多少个任务可以被完成。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>tasks = [<em><strong>3</strong></em>,<em><strong>2</strong></em>,<em><strong>1</strong></em>], workers = [<em><strong>0</strong></em>,<em><strong>3</strong></em>,<em><strong>3</strong></em>], pills = 1, strength = 1\n<b>输出：</b>3\n<strong>解释：</strong>\n我们可以按照如下方案安排药丸：\n- 给 0 号工人药丸。\n- 0 号工人完成任务 2（0 + 1 &gt;= 1）\n- 1 号工人完成任务 1（3 &gt;= 2）\n- 2 号工人完成任务 0（3 &gt;= 3）\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>tasks = [<em><strong>5</strong></em>,4], workers = [<em><strong>0</strong></em>,0,0], pills = 1, strength = 5\n<b>输出：</b>1\n<strong>解释：</strong>\n我们可以按照如下方案安排药丸：\n- 给 0 号工人药丸。\n- 0 号工人完成任务 0（0 + 5 &gt;= 5）\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>tasks = [<em><strong>10</strong></em>,<em><strong>15</strong></em>,30], workers = [<em><strong>0</strong></em>,<em><strong>10</strong></em>,10,10,10], pills = 3, strength = 10\n<b>输出：</b>2\n<strong>解释：</strong>\n我们可以按照如下方案安排药丸：\n- 给 0 号和 1 号工人药丸。\n- 0 号工人完成任务 0（0 + 10 &gt;= 10）\n- 1 号工人完成任务 1（10 + 10 &gt;= 15）\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>tasks = [<em><strong>5</strong></em>,9,<em><strong>8</strong></em>,<em><strong>5</strong></em>,9], workers = [1,<em><strong>6</strong></em>,<em><strong>4</strong></em>,2,<em><strong>6</strong></em>], pills = 1, strength = 5\n<b>输出：</b>3\n<strong>解释：</strong>\n我们可以按照如下方案安排药丸：\n- 给 2 号工人药丸。\n- 1 号工人完成任务 0（6 &gt;= 5）\n- 2 号工人完成任务 2（4 + 5 &gt;= 8）\n- 4 号工人完成任务 3（6 &gt;= 5）\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == tasks.length</code></li>\n\t<li><code>m == workers.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= pills &lt;= m</code></li>\n\t<li><code>0 &lt;= tasks[i], workers[j], strength &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2072赢得比赛的大学",
        "hardRate": "EASY",
        "passRate": "68.66%",
        "problemsUrl": "https://leetcode.cn/problems/the-winner-university/",
        "solutionsUrl": "https://leetcode.cn/problems/the-winner-university/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2073买票需要的时间",
        "hardRate": "EASY",
        "passRate": "61.68%",
        "problemsUrl": "https://leetcode.cn/problems/time-needed-to-buy-tickets/",
        "solutionsUrl": "https://leetcode.cn/problems/time-needed-to-buy-tickets/solution",
        "problemsDesc": "<p>有 <code>n</code> 个人前来排队买票，其中第 <code>0</code> 人站在队伍 <strong>最前方</strong> ，第 <code>(n - 1)</code> 人站在队伍 <strong>最后方</strong> 。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>tickets</code> ，数组长度为 <code>n</code> ，其中第 <code>i</code> 人想要购买的票数为 <code>tickets[i]</code> 。</p>\n\n<p>每个人买票都需要用掉 <strong>恰好 1 秒</strong> 。一个人 <strong>一次只能买一张票</strong> ，如果需要购买更多票，他必须走到&nbsp; <strong>队尾</strong> 重新排队（<strong>瞬间 </strong>发生，不计时间）。如果一个人没有剩下需要买的票，那他将会 <strong>离开</strong> 队伍。</p>\n\n<p>返回位于位置 <code>k</code>（下标从 <strong>0</strong> 开始）的人完成买票需要的时间（以秒为单位）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>tickets = [2,3,2], k = 2\n<strong>输出：</strong>6\n<strong>解释：</strong> \n- 第一轮，队伍中的每个人都买到一张票，队伍变为 [1, 2, 1] 。\n- 第二轮，队伍中的每个都又都买到一张票，队伍变为 [0, 1, 0] 。\n位置 2 的人成功买到 2 张票，用掉 3 + 3 = 6 秒。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>tickets = [5,1,1,1], k = 0\n<strong>输出：</strong>8\n<strong>解释：</strong>\n- 第一轮，队伍中的每个人都买到一张票，队伍变为 [4, 0, 0, 0] 。\n- 接下来的 4 轮，只有位置 0 的人在买票。\n位置 0 的人成功买到 5 张票，用掉 4 + 1 + 1 + 1 + 1 = 8 秒。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == tickets.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= tickets[i] &lt;= 100</code></li>\n\t<li><code>0 &lt;= k &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2074反转偶数长度组的节点",
        "hardRate": "MEDIUM",
        "passRate": "45.73%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-nodes-in-even-length-groups/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-nodes-in-even-length-groups/solution",
        "problemsDesc": "<p>给你一个链表的头节点 <code>head</code> 。</p>\n\n<p>链表中的节点 <strong>按顺序</strong> 划分成若干 <strong>非空</strong> 组，这些非空组的长度构成一个自然数序列（<code>1, 2, 3, 4, ...</code>）。一个组的 <strong>长度</strong> 就是组中分配到的节点数目。换句话说：</p>\n\n<ul>\n\t<li>节点 <code>1</code> 分配给第一组</li>\n\t<li>节点 <code>2</code> 和 <code>3</code> 分配给第二组</li>\n\t<li>节点 <code>4</code>、<code>5</code> 和 <code>6</code> 分配给第三组，以此类推</li>\n</ul>\n\n<p>注意，最后一组的长度可能小于或者等于 <code>1 + 倒数第二组的长度</code> 。</p>\n\n<p><strong>反转</strong> 每个 <strong>偶数</strong> 长度组中的节点，并返回修改后链表的头节点 <code>head</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/25/eg1.png\" style=\"width: 699px; height: 124px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [5,2,6,3,9,1,7,3,8,4]\n<strong>输出：</strong>[5,6,2,3,9,1,4,8,3,7]\n<strong>解释：</strong>\n- 第一组长度为 1 ，奇数，没有发生反转。\n- 第二组长度为 2 ，偶数，节点反转。\n- 第三组长度为 3 ，奇数，没有发生反转。\n- 最后一组长度为 4 ，偶数，节点反转。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/25/eg2.png\" style=\"width: 284px; height: 114px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,1,0,6]\n<strong>输出：</strong>[1,0,1,6]\n<strong>解释：</strong>\n- 第一组长度为 1 ，没有发生反转。\n- 第二组长度为 2 ，节点反转。\n- 最后一组长度为 1 ，没有发生反转。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/28/eg3.png\" style=\"width: 139px; height: 114px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [2,1]\n<strong>输出：</strong>[2,1]\n<strong>解释：</strong>\n- 第一组长度为 1 ，没有发生反转。\n- 最后一组长度为 1 ，没有发生反转。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点数目范围是 <code>[1, 10<sup>5</sup>]</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2075解码斜向换位密码",
        "hardRate": "MEDIUM",
        "passRate": "46.91%",
        "problemsUrl": "https://leetcode.cn/problems/decode-the-slanted-ciphertext/",
        "solutionsUrl": "https://leetcode.cn/problems/decode-the-slanted-ciphertext/solution",
        "problemsDesc": "<p>字符串 <code>originalText</code> 使用 <strong>斜向换位密码</strong> ，经由 <strong>行数固定</strong> 为 <code>rows</code> 的矩阵辅助，加密得到一个字符串 <code>encodedText</code> 。</p>\n\n<p><code>originalText</code> 先按从左上到右下的方式放置到矩阵中。</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/07/exa11.png\" style=\"width: 300px; height: 185px;\" />\n<p>先填充蓝色单元格，接着是红色单元格，然后是黄色单元格，以此类推，直到到达 <code>originalText</code> 末尾。箭头指示顺序即为单元格填充顺序。所有空单元格用 <code>' '</code> 进行填充。矩阵的列数需满足：用 <code>originalText</code> 填充之后，最右侧列 <strong>不为空</strong> 。</p>\n\n<p>接着按行将字符附加到矩阵中，构造&nbsp;<code>encodedText</code> 。</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/07/exa12.png\" style=\"width: 300px; height: 200px;\" />\n<p>先把蓝色单元格中的字符附加到 <code>encodedText</code> 中，接着是红色单元格，最后是黄色单元格。箭头指示单元格访问顺序。</p>\n\n<p>例如，如果 <code>originalText = \"cipher\"</code> 且 <code>rows = 3</code> ，那么我们可以按下述方法将其编码：</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/25/desc2.png\" style=\"width: 281px; height: 211px;\" />\n<p>蓝色箭头标识 <code>originalText</code> 是如何放入矩阵中的，红色箭头标识形成 <code>encodedText</code> 的顺序。在上述例子中，<code>encodedText = \"ch&nbsp; &nbsp;ie&nbsp; &nbsp;pr\"</code> 。</p>\n\n<p>给你编码后的字符串 <code>encodedText</code> 和矩阵的行数 <code>rows</code> ，返回源字符串 <code>originalText</code> 。</p>\n\n<p><strong>注意：</strong><code>originalText</code> <strong>不</strong> 含任何尾随空格 <code>' '</code> 。生成的测试用例满足 <strong>仅存在一个</strong> 可能的 <code>originalText</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>encodedText = \"ch   ie   pr\", rows = 3\n<strong>输出：</strong>\"cipher\"\n<strong>解释：</strong>此示例与问题描述中的例子相同。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/26/exam1.png\" style=\"width: 250px; height: 168px;\" /></p>\n\n<pre>\n<strong>输入：</strong>encodedText = \"iveo    eed   l te   olc\", rows = 4\n<strong>输出：</strong>\"i love leetcode\"\n<strong>解释：</strong>上图标识用于编码 originalText 的矩阵。 \n蓝色箭头展示如何从 encodedText 找到 originalText 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/26/eg2.png\" style=\"width: 300px; height: 51px;\" /></p>\n\n<pre>\n<strong>输入：</strong>encodedText = \"coding\", rows = 1\n<strong>输出：</strong>\"coding\"\n<strong>解释：</strong>由于只有 1 行，所以 originalText 和 encodedText 是相同的。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/26/exam3.png\" style=\"width: 150px; height: 101px;\" />\n<pre>\n<strong>输入：</strong>encodedText = \" b  ac\", rows = 2\n<strong>输出：</strong>\" abc\"\n<strong>解释：</strong>originalText 不能含尾随空格，但它可能会有一个或者多个前置空格。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= encodedText.length &lt;= 10<sup>6</sup></code></li>\n\t<li><code>encodedText</code> 仅由小写英文字母和 <code>' '</code> 组成</li>\n\t<li><code>encodedText</code> 是对某个 <strong>不含</strong> 尾随空格的 <code>originalText</code> 的一个有效编码</li>\n\t<li><code>1 &lt;= rows &lt;= 1000</code></li>\n\t<li>生成的测试用例满足 <strong>仅存在一个</strong> 可能的 <code>originalText</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2076处理含限制条件的好友请求",
        "hardRate": "HARD",
        "passRate": "50.99%",
        "problemsUrl": "https://leetcode.cn/problems/process-restricted-friend-requests/",
        "solutionsUrl": "https://leetcode.cn/problems/process-restricted-friend-requests/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，表示网络上的用户数目。每个用户按从 <code>0</code> 到 <code>n - 1</code> 进行编号。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>restrictions</code> ，其中 <code>restrictions[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 意味着用户 <code>x<sub>i</sub></code> 和用户 <code>y<sub>i</sub></code> <strong>不能</strong> 成为 <strong>朋友</strong> ，不管是 <strong>直接</strong> 还是通过其他用户 <strong>间接</strong> 。</p>\n\n<p>最初，用户里没有人是其他用户的朋友。给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>requests</code> 表示好友请求的列表，其中 <code>requests[j] = [u<sub>j</sub>, v<sub>j</sub>]</code> 是用户 <code>u<sub>j</sub></code> 和用户 <code>v<sub>j</sub></code> 之间的一条好友请求。</p>\n\n<p>如果 <code>u<sub>j</sub></code> 和 <code>v<sub>j</sub></code> 可以成为 <strong>朋友</strong> ，那么好友请求将会 <strong>成功</strong> 。每个好友请求都会按列表中给出的顺序进行处理（即，<code>requests[j]</code> 会在 <code>requests[j + 1]</code> 前）。一旦请求成功，那么对所有未来的好友请求而言， <code>u<sub>j</sub></code> 和 <code>v<sub>j</sub></code> 将会 <strong>成为直接朋友 。</strong></p>\n\n<p>返回一个 <strong>布尔数组</strong> <code>result</code> ，其中元素遵循此规则：如果第 <code>j</code> 个好友请求 <strong>成功</strong><em> </em>，那么 <code>result[j]</code><em> </em>就是<em> </em><code>true</code><em> </em>；否则，为<em> </em><code>false</code> 。</p>\n\n<p><strong>注意：</strong>如果 <code>u<sub>j</sub></code> 和 <code>v<sub>j</sub></code> 已经是直接朋友，那么他们之间的请求将仍然&nbsp;<strong>成功</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]]\n<strong>输出：</strong>[true,false]\n<strong>解释：\n</strong>请求 0 ：用户 0 和 用户 2 可以成为朋友，所以他们成为直接朋友。 \n请求 1 ：用户 2 和 用户 1 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (1--2--0) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]]\n<strong>输出：</strong>[true,false]\n<strong>解释：</strong>\n请求 0 ：用户 1 和 用户 2 可以成为朋友，所以他们成为直接朋友。 \n请求 1 ：用户 0 和 用户 2 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (0--2--1) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]]\n<strong>输出：</strong>[true,false,true,false]\n<strong>解释：\n</strong>请求 0 ：用户 0 和 用户 4 可以成为朋友，所以他们成为直接朋友。 \n请求 1 ：用户 1 和 用户 2 不能成为朋友，因为他们之间存在限制。\n请求 2 ：用户 3 和 用户 1 可以成为朋友，所以他们成为直接朋友。 \n请求 3 ：用户 3 和 用户 4 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (0--4--3--1) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= restrictions.length &lt;= 1000</code></li>\n\t<li><code>restrictions[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>\n\t<li><code>1 &lt;= requests.length &lt;= 1000</code></li>\n\t<li><code>requests[j].length == 2</code></li>\n\t<li><code>0 &lt;= u<sub>j</sub>, v<sub>j</sub> &lt;= n - 1</code></li>\n\t<li><code>u<sub>j</sub> != v<sub>j</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2077殊途同归",
        "hardRate": "MEDIUM",
        "passRate": "62.89%",
        "problemsUrl": "https://leetcode.cn/problems/paths-in-maze-that-lead-to-same-room/",
        "solutionsUrl": "https://leetcode.cn/problems/paths-in-maze-that-lead-to-same-room/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2078两栋颜色不同且距离最远的房子",
        "hardRate": "EASY",
        "passRate": "72.35%",
        "problemsUrl": "https://leetcode.cn/problems/two-furthest-houses-with-different-colors/",
        "solutionsUrl": "https://leetcode.cn/problems/two-furthest-houses-with-different-colors/solution",
        "problemsDesc": "<p>街上有 <code>n</code> 栋房子整齐地排成一列，每栋房子都粉刷上了漂亮的颜色。给你一个下标从 <strong>0</strong> 开始且长度为 <code>n</code> 的整数数组 <code>colors</code> ，其中 <code>colors[i]</code> 表示第&nbsp; <code>i</code> 栋房子的颜色。</p>\n\n<p>返回 <strong>两栋</strong> 颜色 <strong>不同</strong> 房子之间的 <strong>最大</strong> 距离。</p>\n\n<p>第 <code>i</code> 栋房子和第 <code>j</code> 栋房子之间的距离是 <code>abs(i - j)</code> ，其中 <code>abs(x)</code> 是 <code>x</code> 的绝对值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/31/eg1.png\" style=\"width: 610px; height: 84px;\" /></p>\n\n<pre>\n<strong>输入：</strong>colors = [<strong><em>1</em></strong>,1,1,<em><strong>6</strong></em>,1,1,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>上图中，颜色 1 标识成蓝色，颜色 6 标识成红色。\n两栋颜色不同且距离最远的房子是房子 0 和房子 3 。\n房子 0 的颜色是颜色 1 ，房子 3 的颜色是颜色 6 。两栋房子之间的距离是 abs(0 - 3) = 3 。\n注意，房子 3 和房子 6 也可以产生最佳答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/31/eg2.png\" style=\"width: 426px; height: 84px;\" /></p>\n\n<pre>\n<strong>输入：</strong>colors = [<em><strong>1</strong></em>,8,3,8,<em><strong>3</strong></em>]\n<strong>输出：</strong>4\n<strong>解释：</strong>上图中，颜色 1 标识成蓝色，颜色 8 标识成黄色，颜色 3 标识成绿色。\n两栋颜色不同且距离最远的房子是房子 0 和房子 4 。\n房子 0 的颜色是颜色 1 ，房子 4 的颜色是颜色 3 。两栋房子之间的距离是 abs(0 - 4) = 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>colors = [<em><strong>0</strong></em>,<em><strong>1</strong></em>]\n<strong>输出：</strong>1\n<strong>解释：</strong>两栋颜色不同且距离最远的房子是房子 0 和房子 1 。\n房子 0 的颜色是颜色 0 ，房子 1 的颜色是颜色 1 。两栋房子之间的距离是 abs(0 - 1) = 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n ==&nbsp;colors.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= colors[i] &lt;= 100</code></li>\n\t<li>生成的测试数据满足 <strong>至少 </strong>存在 2 栋颜色不同的房子</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2079给植物浇水",
        "hardRate": "MEDIUM",
        "passRate": "77.70%",
        "problemsUrl": "https://leetcode.cn/problems/watering-plants/",
        "solutionsUrl": "https://leetcode.cn/problems/watering-plants/solution",
        "problemsDesc": "<p>你打算用一个水罐给花园里的 <code>n</code> 株植物浇水。植物排成一行，从左到右进行标记，编号从 <code>0</code> 到 <code>n - 1</code> 。其中，第 <code>i</code> 株植物的位置是 <code>x = i</code> 。<code>x = -1</code>&nbsp;处有一条河，你可以在那里重新灌满你的水罐。</p>\n\n<p>每一株植物都需要浇特定量的水。你将会按下面描述的方式完成浇水：</p>\n\n<ul>\n\t<li>按从左到右的顺序给植物浇水。</li>\n\t<li>在给当前植物浇完水之后，如果你没有足够的水 <strong>完全</strong> 浇灌下一株植物，那么你就需要返回河边重新装满水罐。</li>\n\t<li>你 <strong>不能</strong> 提前重新灌满水罐。</li>\n</ul>\n\n<p>最初，你在河边（也就是，<code>x = -1</code>），在 x 轴上每移动 <strong>一个单位</strong>&nbsp;都需要 <strong>一步</strong> 。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>plants</code> ，数组由 <code>n</code> 个整数组成。其中，<code>plants[i]</code> 为第 <code>i</code> 株植物需要的水量。另有一个整数 <code>capacity</code> 表示水罐的容量，返回浇灌所有植物需要的 <strong>步数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>plants = [2,2,3,3], capacity = 5\n<strong>输出：</strong>14\n<strong>解释：</strong>从河边开始，此时水罐是装满的：\n- 走到植物 0 (1 步) ，浇水。水罐中还有 3 单位的水。\n- 走到植物 1 (1 步) ，浇水。水罐中还有 1 单位的水。\n- 由于不能完全浇灌植物 2 ，回到河边取水 (2 步)。\n- 走到植物 2 (3 步) ，浇水。水罐中还有 2 单位的水。\n- 由于不能完全浇灌植物 3 ，回到河边取水 (3 步)。\n- 走到植物 3 (4 步) ，浇水。\n需要的步数是 = 1 + 1 + 2 + 3 + 3 + 4 = 14 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>plants = [1,1,1,4,2,3], capacity = 4\n<strong>输出：</strong>30\n<strong>解释：</strong>从河边开始，此时水罐是装满的：\n- 走到植物 0，1，2 (3 步) ，浇水。回到河边取水 (3 步)。\n- 走到植物 3 (4 步) ，浇水。回到河边取水 (4 步)。\n- 走到植物 4 (5 步) ，浇水。回到河边取水 (5 步)。\n- 走到植物 5 (6 步) ，浇水。\n需要的步数是 = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>plants = [7,7,7,7,7,7,7], capacity = 8\n<strong>输出：</strong>49\n<strong>解释：</strong>每次浇水都需要重新灌满水罐。\n需要的步数是 = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == plants.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= plants[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>max(plants[i]) &lt;= capacity &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2080区间内查询数字的频率",
        "hardRate": "MEDIUM",
        "passRate": "31.42%",
        "problemsUrl": "https://leetcode.cn/problems/range-frequency-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/range-frequency-queries/solution",
        "problemsDesc": "<p>请你设计一个数据结构，它能求出给定子数组内一个给定值的 <strong>频率</strong>&nbsp;。</p>\n\n<p>子数组中一个值的 <strong>频率</strong>&nbsp;指的是这个子数组中这个值的出现次数。</p>\n\n<p>请你实现&nbsp;<code>RangeFreqQuery</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>RangeFreqQuery(int[] arr)</code>&nbsp;用下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>arr</code>&nbsp;构造一个类的实例。</li>\n\t<li><code>int query(int left, int right, int value)</code>&nbsp;返回子数组&nbsp;<code>arr[left...right]</code>&nbsp;中&nbsp;<code>value</code>&nbsp;的&nbsp;<strong>频率</strong>&nbsp;。</li>\n</ul>\n\n<p>一个 <strong>子数组</strong> 指的是数组中一段连续的元素。<code>arr[left...right]</code>&nbsp;指的是 <code>nums</code>&nbsp;中包含下标 <code>left</code>&nbsp;和 <code>right</code>&nbsp;<strong>在内</strong>&nbsp;的中间一段连续元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>\n[\"RangeFreqQuery\", \"query\", \"query\"]\n[[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]\n<strong>输出：</strong>\n[null, 1, 2]\n\n<strong>解释：</strong>\nRangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]);\nrangeFreqQuery.query(1, 2, 4); // 返回 1 。4 在子数组 [33, 4] 中出现 1 次。\nrangeFreqQuery.query(0, 11, 33); // 返回 2 。33 在整个子数组中出现 2 次。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i], value &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= left &lt;= right &lt; arr.length</code></li>\n\t<li>调用&nbsp;<code>query</code>&nbsp;不超过&nbsp;<code>10<sup>5</sup></code>&nbsp;次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2081k 镜像数字的和",
        "hardRate": "HARD",
        "passRate": "43.56%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-k-mirror-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-k-mirror-numbers/solution",
        "problemsDesc": "<p>一个 <strong>k 镜像数字</strong>&nbsp;指的是一个在十进制和 k 进制下从前往后读和从后往前读都一样的&nbsp;<strong>没有前导 0</strong>&nbsp;的&nbsp;<strong>正</strong>&nbsp;整数。</p>\n\n<ul>\n\t<li>比方说，<code>9</code>&nbsp;是一个 2 镜像数字。<code>9</code>&nbsp;在十进制下为&nbsp;<code>9</code>&nbsp;，二进制下为&nbsp;<code>1001</code>&nbsp;，两者从前往后读和从后往前读都一样。</li>\n\t<li>相反地，<code>4</code>&nbsp;不是一个 2 镜像数字。<code>4</code>&nbsp;在二进制下为&nbsp;<code>100</code>&nbsp;，从前往后和从后往前读不相同。</li>\n</ul>\n\n<p>给你进制&nbsp;<code>k</code>&nbsp;和一个数字&nbsp;<code>n</code>&nbsp;，请你返回 k 镜像数字中 <strong>最小</strong> 的 <code>n</code>&nbsp;个数 <strong>之和</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre><b>输入：</b>k = 2, n = 5\n<b>输出：</b>25\n<strong>解释：\n</strong>最小的 5 个 2 镜像数字和它们的二进制表示如下：\n  十进制       二进制\n    1          1\n    3          11\n    5          101\n    7          111\n    9          1001\n它们的和为 1 + 3 + 5 + 7 + 9 = 25 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>k = 3, n = 7\n<b>输出：</b>499\n<strong>解释：\n</strong>7 个最小的 3 镜像数字和它们的三进制表示如下：\n  十进制       三进制\n    1          1\n    2          2\n    4          11\n    8          22\n    121        11111\n    151        12121\n    212        21212\n它们的和为 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>k = 7, n = 17\n<b>输出：</b>20379000\n<b>解释：</b>17 个最小的 7 镜像数字分别为：\n1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= k &lt;= 9</code></li>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2082富有客户的数量",
        "hardRate": "EASY",
        "passRate": "74.10%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-rich-customers/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-rich-customers/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2083求以相同字母开头和结尾的子串总数",
        "hardRate": "MEDIUM",
        "passRate": "60.92%",
        "problemsUrl": "https://leetcode.cn/problems/substrings-that-begin-and-end-with-the-same-letter/",
        "solutionsUrl": "https://leetcode.cn/problems/substrings-that-begin-and-end-with-the-same-letter/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2084为订单类型为 0 的客户删除类型为 1 的订单",
        "hardRate": "MEDIUM",
        "passRate": "82.48%",
        "problemsUrl": "https://leetcode.cn/problems/drop-type-1-orders-for-customers-with-type-0-orders/",
        "solutionsUrl": "https://leetcode.cn/problems/drop-type-1-orders-for-customers-with-type-0-orders/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2085统计出现过一次的公共字符串",
        "hardRate": "EASY",
        "passRate": "71.42%",
        "problemsUrl": "https://leetcode.cn/problems/count-common-words-with-one-occurrence/",
        "solutionsUrl": "https://leetcode.cn/problems/count-common-words-with-one-occurrence/solution",
        "problemsDesc": "<p>给你两个字符串数组&nbsp;<code>words1</code>&nbsp;和&nbsp;<code>words2</code>&nbsp;，请你返回在两个字符串数组中 <strong>都恰好出现一次</strong>&nbsp;的字符串的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>words1 = [\"leetcode\",\"is\",\"amazing\",\"as\",\"is\"], words2 = [\"amazing\",\"leetcode\",\"is\"]\n<b>输出：</b>2\n<strong>解释：</strong>\n- \"leetcode\" 在两个数组中都恰好出现一次，计入答案。\n- \"amazing\" 在两个数组中都恰好出现一次，计入答案。\n- \"is\" 在两个数组中都出现过，但在 words1 中出现了 2 次，不计入答案。\n- \"as\" 在 words1 中出现了一次，但是在 words2 中没有出现过，不计入答案。\n所以，有 2 个字符串在两个数组中都恰好出现了一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>words1 = [\"b\",\"bb\",\"bbb\"], words2 = [\"a\",\"aa\",\"aaa\"]\n<b>输出：</b>0\n<b>解释：</b>没有字符串在两个数组中都恰好出现一次。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>words1 = [\"a\",\"ab\"], words2 = [\"a\",\"a\",\"a\",\"ab\"]\n<b>输出：</b>1\n<b>解释：</b>唯一在两个数组中都出现一次的字符串是 \"ab\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words1.length, words2.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words1[i].length, words2[j].length &lt;= 30</code></li>\n\t<li><code>words1[i]</code> 和&nbsp;<code>words2[j]</code>&nbsp;都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2086从房屋收集雨水需要的最少水桶数",
        "hardRate": "MEDIUM",
        "passRate": "46.78%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-food-buckets-to-feed-the-hamsters/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-food-buckets-to-feed-the-hamsters/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>street</code>&nbsp;。<code>street</code>&nbsp;中每个字符要么是表示房屋的&nbsp;<code>'H'</code> ，要么是表示空位的&nbsp;<code>'.'</code>&nbsp;。</p>\n\n<p>你可以在 <strong>空位</strong>&nbsp;放置水桶，从相邻的房屋收集雨水。位置在 <code>i - 1</code>&nbsp;<strong>或者</strong> <code>i + 1</code>&nbsp;的水桶可以收集位置为 <code>i</code>&nbsp;处房屋的雨水。一个水桶如果相邻两个位置都有房屋，那么它可以收集 <strong>两个</strong> 房屋的雨水。</p>\n\n<p>在确保 <strong>每个</strong>&nbsp;房屋旁边都 <strong>至少</strong>&nbsp;有一个水桶的前提下，请你返回需要的 <strong>最少</strong>&nbsp;水桶数。如果无解请返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>street = \"H..H\"\n<b>输出：</b>2\n<strong>解释：</strong>\n我们可以在下标为 1 和 2 处放水桶。\n\"H..H\" -&gt; \"HBBH\"（'B' 表示放置水桶）。\n下标为 0 处的房屋右边有水桶，下标为 3 处的房屋左边有水桶。\n所以每个房屋旁边都至少有一个水桶收集雨水。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>street = \".H.H.\"\n<b>输出：</b>1\n<strong>解释：</strong>\n我们可以在下标为 2 处放置一个水桶。\n\".H.H.\" -&gt; \".HBH.\"（'B' 表示放置水桶）。\n下标为 1 处的房屋右边有水桶，下标为 3 处的房屋左边有水桶。\n所以每个房屋旁边都至少有一个水桶收集雨水。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>street = \".HHH.\"\n<b>输出：</b>-1\n<strong>解释：</strong>\n没有空位可以放置水桶收集下标为 2 处的雨水。\n所以没有办法收集所有房屋的雨水。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>street = \"H\"\n<b>输出：</b>-1\n<strong>解释：</strong>\n没有空位放置水桶。\n所以没有办法收集所有房屋的雨水。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><b>输入：</b>street = \".\"\n<b>输出：</b>0\n<strong>解释：</strong>\n没有房屋需要收集雨水。\n所以需要 0 个水桶。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= street.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>street[i]</code>&nbsp;要么是&nbsp;<code>'H'</code>&nbsp;，要么是&nbsp;<code>'.'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2087网格图中机器人回家的最小代价",
        "hardRate": "MEDIUM",
        "passRate": "50.12%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-homecoming-of-a-robot-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-homecoming-of-a-robot-in-a-grid/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的网格图，其中&nbsp;<code>(0, 0)</code>&nbsp;是最左上角的格子，<code>(m - 1, n - 1)</code>&nbsp;是最右下角的格子。给你一个整数数组&nbsp;<code>startPos</code>&nbsp;，<code>startPos = [start<sub>row</sub>, start<sub>col</sub>]</code>&nbsp;表示 <strong>初始</strong>&nbsp;有一个 <strong>机器人</strong>&nbsp;在格子&nbsp;<code>(start<sub>row</sub>, start<sub>col</sub>)</code>&nbsp;处。同时给你一个整数数组&nbsp;<code>homePos</code>&nbsp;，<code>homePos = [home<sub>row</sub>, home<sub>col</sub>]</code>&nbsp;表示机器人的 <strong>家</strong>&nbsp;在格子&nbsp;<code>(home<sub>row</sub>, home<sub>col</sub>)</code>&nbsp;处。</p>\n\n<p>机器人需要回家。每一步它可以往四个方向移动：<strong>上</strong>，<strong>下</strong>，<strong>左</strong>，<strong>右</strong>，同时机器人不能移出边界。每一步移动都有一定代价。再给你两个下标从&nbsp;<strong>0</strong>&nbsp;开始的额整数数组：长度为&nbsp;<code>m</code>&nbsp;的数组&nbsp;<code>rowCosts</code> &nbsp;和长度为 <code>n</code>&nbsp;的数组&nbsp;<code>colCosts</code>&nbsp;。</p>\n\n<ul>\n\t<li>如果机器人往 <strong>上</strong>&nbsp;或者往 <strong>下</strong>&nbsp;移动到第 <code>r</code>&nbsp;<strong>行</strong>&nbsp;的格子，那么代价为&nbsp;<code>rowCosts[r]</code>&nbsp;。</li>\n\t<li>如果机器人往 <strong>左</strong>&nbsp;或者往 <strong>右</strong>&nbsp;移动到第 <code>c</code>&nbsp;<strong>列</strong> 的格子，那么代价为&nbsp;<code>colCosts[c]</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回机器人回家需要的 <strong>最小总代价</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/11/eg-1.png\" style=\"width: 282px; height: 217px;\"></p>\n\n<pre><strong>输入：</strong>startPos = [1, 0], homePos = [2, 3], rowCosts = [5, 4, 3], colCosts = [8, 2, 6, 7]\n<b>输出：</b>18\n<b>解释：</b>一个最优路径为：\n从 (1, 0) 开始\n-&gt; 往下走到 (<em><strong>2</strong></em>, 0) 。代价为 rowCosts[2] = 3 。\n-&gt; 往右走到 (2, <em><strong>1</strong></em>) 。代价为 colCosts[1] = 2 。\n-&gt; 往右走到 (2, <em><strong>2</strong></em>) 。代价为 colCosts[2] = 6 。\n-&gt; 往右走到 (2, <em><strong>3</strong></em>) 。代价为 colCosts[3] = 7 。\n总代价为 3 + 2 + 6 + 7 = 18</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>startPos = [0, 0], homePos = [0, 0], rowCosts = [5], colCosts = [26]\n<b>输出：</b>0\n<b>解释：</b>机器人已经在家了，所以不需要移动。总代价为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == rowCosts.length</code></li>\n\t<li><code>n == colCosts.length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= rowCosts[r], colCosts[c] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>startPos.length == 2</code></li>\n\t<li><code>homePos.length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>row</sub>, home<sub>row</sub> &lt; m</code></li>\n\t<li><code>0 &lt;= start<sub>col</sub>, home<sub>col</sub> &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2088统计农场中肥沃金字塔的数目",
        "hardRate": "HARD",
        "passRate": "63.40%",
        "problemsUrl": "https://leetcode.cn/problems/count-fertile-pyramids-in-a-land/",
        "solutionsUrl": "https://leetcode.cn/problems/count-fertile-pyramids-in-a-land/solution",
        "problemsDesc": "<p>有一个 <strong>矩形网格</strong>&nbsp;状的农场，划分为&nbsp;<code>m</code>&nbsp;行&nbsp;<code>n</code>&nbsp;列的单元格。每个格子要么是 <strong>肥沃的</strong>&nbsp;（用 <code>1</code>&nbsp;表示），要么是 <strong>贫瘠</strong>&nbsp;的（用 <code>0</code>&nbsp;表示）。网格图以外的所有与格子都视为贫瘠的。</p>\n\n<p>农场中的&nbsp;<strong>金字塔</strong>&nbsp;区域定义如下：</p>\n\n<ol>\n\t<li>区域内格子数目 <strong>大于&nbsp;</strong><code>1</code>&nbsp;且所有格子都是 <strong>肥沃的</strong>&nbsp;。</li>\n\t<li>金字塔 <strong>顶端</strong>&nbsp;是这个金字塔 <strong>最上方</strong>&nbsp;的格子。金字塔的高度是它所覆盖的行数。令&nbsp;<code>(r, c)</code>&nbsp;为金字塔的顶端且高度为 <code>h</code>&nbsp;，那么金字塔区域内包含的任一格子&nbsp;<code>(i, j)</code>&nbsp;需满足&nbsp;<code>r &lt;= i &lt;= r + h - 1</code>&nbsp;<strong>且</strong>&nbsp;<code>c - (i - r) &lt;= j &lt;= c + (i - r)</code>&nbsp;。</li>\n</ol>\n\n<p>一个 <strong>倒金字塔</strong>&nbsp;类似定义如下：</p>\n\n<ol>\n\t<li>区域内格子数目 <strong>大于</strong>&nbsp;<code>1</code>&nbsp;且所有格子都是 <b>肥沃的</b>&nbsp;。</li>\n\t<li>倒金字塔的 <strong>顶端</strong>&nbsp;是这个倒金字塔 <strong>最下方</strong>&nbsp;的格子。倒金字塔的高度是它所覆盖的行数。令&nbsp;<code>(r, c)</code>&nbsp;为金字塔的顶端且高度为 <code>h</code>&nbsp;，那么金字塔区域内包含的任一格子&nbsp;<code>(i, j)</code>&nbsp;需满足&nbsp;<code>r - h + 1 &lt;= i &lt;= r</code> <strong>且</strong> <code>c - (r - i) &lt;= j &lt;= c + (r - i)</code>&nbsp;。</li>\n</ol>\n\n<p>下图展示了部分符合定义和不符合定义的金字塔区域。黑色区域表示肥沃的格子。</p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/11/08/image.png\" style=\"width: 700px; height: 156px;\"></p>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始且大小为 <code>m x n</code>&nbsp;的二进制矩阵&nbsp;<code>grid</code>&nbsp;，它表示农场，请你返回 <code>grid</code>&nbsp;中金字塔和倒金字塔的&nbsp;<strong>总数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/eg11.png\" style=\"width: 200px; height: 102px;\">&nbsp;<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/exa12.png\" style=\"width: 200px; height: 102px;\">&nbsp;<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/exa13.png\" style=\"width: 200px; height: 102px;\"></p>\n\n<pre><b>输入：</b>grid = [[0,1,1,0],[1,1,1,1]]\n<b>输出：</b>2\n<strong>解释：</strong>\n2 个可能的金字塔区域分别如上图蓝色和红色区域所示。\n这个网格图中没有倒金字塔区域。\n所以金字塔区域总数为 2 + 0 = 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/eg21.png\" style=\"width: 180px; height: 122px;\">&nbsp;<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/exa22.png\" style=\"width: 180px; height: 122px;\">&nbsp;<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/exa23.png\" style=\"width: 180px; height: 122px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,1,1],[1,1,1]]\n<b>输出：</b>2\n<strong>解释：</strong>\n金字塔区域如上图蓝色区域所示，倒金字塔如上图红色区域所示。\n所以金字塔区域总数目为 1 + 1 = 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/eg3.png\" style=\"width: 149px; height: 150px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,0,1],[0,0,0],[1,0,1]]\n<b>输出：</b>0\n<strong>解释：</strong>\n网格图中没有任何金字塔或倒金字塔区域。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/eg41.png\" style=\"width: 180px; height: 144px;\">&nbsp;<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/eg42.png\" style=\"width: 180px; height: 144px;\">&nbsp;<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/eg43.png\" style=\"width: 180px; height: 144px;\">&nbsp;<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/23/eg44.png\" style=\"width: 180px; height: 144px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]]\n<b>输出：</b>13\n<strong>解释：</strong>\n有 7 个金字塔区域。上图第二和第三张图中展示了它们中的 3 个。\n有 6 个倒金字塔区域。上图中最后一张图展示了它们中的 2 个。\n所以金字塔区域总数目为 7 + 6 = 13.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>grid[i][j]</code>&nbsp;要么是&nbsp;<code>0</code>&nbsp;，要么是&nbsp;<code>1</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2089找出数组排序后的目标下标",
        "hardRate": "EASY",
        "passRate": "78.52%",
        "problemsUrl": "https://leetcode.cn/problems/find-target-indices-after-sorting-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-target-indices-after-sorting-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 以及一个目标元素 <code>target</code> 。</p>\n\n<p><strong>目标下标</strong> 是一个满足&nbsp;<code>nums[i] == target</code> 的下标 <code>i</code> 。</p>\n\n<p>将 <code>nums</code> 按 <strong>非递减</strong> 顺序排序后，返回由 <code>nums</code> 中目标下标组成的列表。如果不存在目标下标，返回一个 <strong>空</strong> 列表。返回的列表必须按 <strong>递增</strong> 顺序排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,5,2,3], target = 2\n<strong>输出：</strong>[1,2]\n<strong>解释：</strong>排序后，nums 变为 [1,<em><strong>2</strong></em>,<em><strong>2</strong></em>,3,5] 。\n满足 nums[i] == 2 的下标是 1 和 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,5,2,3], target = 3\n<strong>输出：</strong>[3]\n<strong>解释：</strong>排序后，nums 变为 [1,2,2,<em><strong>3</strong></em>,5] 。\n满足 nums[i] == 3 的下标是 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,5,2,3], target = 5\n<strong>输出：</strong>[4]\n<strong>解释：</strong>排序后，nums 变为 [1,2,2,3,<em><strong>5</strong></em>] 。\n满足 nums[i] == 5 的下标是 4 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,5,2,3], target = 4\n<strong>输出：</strong>[]\n<strong>解释：</strong>nums 中不含值为 4 的元素。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i], target &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2090半径为 k 的子数组平均值",
        "hardRate": "MEDIUM",
        "passRate": "37.53%",
        "problemsUrl": "https://leetcode.cn/problems/k-radius-subarray-averages/",
        "solutionsUrl": "https://leetcode.cn/problems/k-radius-subarray-averages/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，数组中有 <code>n</code> 个整数，另给你一个整数 <code>k</code> 。</p>\n\n<p><strong>半径为 k 的子数组平均值</strong> 是指：<code>nums</code> 中一个以下标 <code>i</code> 为 <strong>中心</strong> 且 <strong>半径</strong> 为 <code>k</code> 的子数组中所有元素的平均值，即下标在&nbsp;<code>i - k</code> 和 <code>i + k</code> 范围（<strong>含</strong> <code>i - k</code> 和 <code>i + k</code>）内所有元素的平均值。如果在下标 <code>i</code> 前或后不足 <code>k</code> 个元素，那么<strong> 半径为 k 的子数组平均值 </strong>是 <code>-1</code> 。</p>\n\n<p>构建并返回一个长度为 <code>n</code> 的数组<em> </em><code>avgs</code><em> </em>，其中<em> </em><code>avgs[i]</code><em> </em>是以下标 <code>i</code> 为中心的子数组的<strong> 半径为 k 的子数组平均值 </strong>。</p>\n\n<p><code>x</code> 个元素的 <strong>平均值</strong> 是 <code>x</code> 个元素相加之和除以 <code>x</code> ，此时使用截断式 <strong>整数除法</strong> ，即需要去掉结果的小数部分。</p>\n\n<ul>\n\t<li>例如，四个元素 <code>2</code>、<code>3</code>、<code>1</code> 和 <code>5</code> 的平均值是 <code>(2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75</code>，截断后得到 <code>2</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/07/eg1.png\" style=\"width: 343px; height: 119px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [7,4,3,9,1,8,5,2,6], k = 3\n<strong>输出：</strong>[-1,-1,-1,5,4,4,-1,-1,-1]\n<strong>解释：</strong>\n- avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。\n- 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。\n  使用截断式 <strong>整数除法</strong>，avg[3] = 37 / 7 = 5 。\n- 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。\n- 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。\n- avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [100000], k = 0\n<strong>输出：</strong>[100000]\n<strong>解释：</strong>\n- 中心为下标 0 且半径 0 的子数组的元素总和是：100000 。\n  avg[0] = 100000 / 1 = 100000 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [8], k = 100000\n<strong>输出：</strong>[-1]\n<strong>解释：</strong>\n- avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i], k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2091从数组中移除最大值和最小值",
        "hardRate": "MEDIUM",
        "passRate": "56.57%",
        "problemsUrl": "https://leetcode.cn/problems/removing-minimum-and-maximum-from-array/",
        "solutionsUrl": "https://leetcode.cn/problems/removing-minimum-and-maximum-from-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，数组由若干 <strong>互不相同</strong> 的整数组成。</p>\n\n<p><code>nums</code> 中有一个值最小的元素和一个值最大的元素。分别称为 <strong>最小值</strong> 和 <strong>最大值</strong> 。你的目标是从数组中移除这两个元素。</p>\n\n<p>一次 <strong>删除</strong> 操作定义为从数组的 <strong>前面</strong> 移除一个元素或从数组的 <strong>后面</strong> 移除一个元素。</p>\n\n<p>返回将数组中最小值和最大值 <strong>都</strong> 移除需要的最小删除次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,<em><strong>10</strong></em>,7,5,4,<em><strong>1</strong></em>,8,6]\n<strong>输出：</strong>5\n<strong>解释：</strong>\n数组中的最小元素是 nums[5] ，值为 1 。\n数组中的最大元素是 nums[1] ，值为 10 。\n将最大值和最小值都移除需要从数组前面移除 2 个元素，从数组后面移除 3 个元素。\n结果是 2 + 3 = 5 ，这是所有可能情况中的最小删除次数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,<em><strong>-4</strong></em>,<em><strong>19</strong></em>,1,8,-2,-3,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n数组中的最小元素是 nums[1] ，值为 -4 。\n数组中的最大元素是 nums[2] ，值为 19 。\n将最大值和最小值都移除需要从数组前面移除 3 个元素。\n结果是 3 ，这是所有可能情况中的最小删除次数。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<em><strong>101</strong></em>]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n数组中只有这一个元素，那么它既是数组中的最小值又是数组中的最大值。\n移除它只需要 1 次删除操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums</code> 中的整数 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2092找出知晓秘密的所有专家",
        "hardRate": "HARD",
        "passRate": "29.12%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-people-with-secret/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-people-with-secret/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，表示有 <code>n</code> 个专家从 <code>0</code> 到 <code>n - 1</code> 编号。另外给你一个下标从 0 开始的二维整数数组 <code>meetings</code> ，其中 <code>meetings[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>]</code> 表示专家 <code>x<sub>i</sub></code> 和专家 <code>y<sub>i</sub></code> 在时间 <code>time<sub>i</sub></code> 要开一场会。一个专家可以同时参加 <strong>多场会议</strong> 。最后，给你一个整数 <code>firstPerson</code> 。</p>\n\n<p>专家 <code>0</code> 有一个 <strong>秘密</strong> ，最初，他在时间&nbsp;<code>0</code> 将这个秘密分享给了专家 <code>firstPerson</code> 。接着，这个秘密会在每次有知晓这个秘密的专家参加会议时进行传播。更正式的表达是，每次会议，如果专家 <code>x<sub>i</sub></code> 在时间 <code>time<sub>i</sub></code> 时知晓这个秘密，那么他将会与专家 <code>y<sub>i</sub></code> 分享这个秘密，反之亦然。</p>\n\n<p>秘密共享是 <strong>瞬时发生</strong> 的。也就是说，在同一时间，一个专家不光可以接收到秘密，还能在其他会议上与其他专家分享。</p>\n\n<p>在所有会议都结束之后，返回所有知晓这个秘密的专家列表。你可以按 <strong>任何顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1\n<strong>输出：</strong>[0,1,2,3,5]\n<strong>解释：\n</strong>时间 0 ，专家 0 将秘密与专家 1 共享。\n时间 5 ，专家 1 将秘密与专家 2 共享。\n时间 8 ，专家 2 将秘密与专家 3 共享。\n时间 10 ，专家 1 将秘密与专家 5 共享。\n因此，在所有会议结束后，专家 0、1、2、3 和 5 都将知晓这个秘密。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3\n<strong>输出：</strong>[0,1,3]\n<strong>解释：</strong>\n时间 0 ，专家 0 将秘密与专家 3 共享。\n时间 2 ，专家 1 与专家 2 都不知晓这个秘密。\n时间 3 ，专家 3 将秘密与专家 0 和专家 1 共享。\n因此，在所有会议结束后，专家 0、1 和 3 都将知晓这个秘密。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1\n<strong>输出：</strong>[0,1,2,3,4]\n<strong>解释：</strong>\n时间 0 ，专家 0 将秘密与专家 1 共享。\n时间 1 ，专家 1 将秘密与专家 2 共享，专家 2 将秘密与专家 3 共享。\n注意，专家 2 可以在收到秘密的同一时间分享此秘密。\n时间 2 ，专家 3 将秘密与专家 4 共享。\n因此，在所有会议结束后，专家 0、1、2、3 和 4 都将知晓这个秘密。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= meetings.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>meetings[i].length == 3</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i </sub>&lt;= n - 1</code></li>\n\t<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>\n\t<li><code>1 &lt;= time<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= firstPerson &lt;= n - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2093前往目标城市的最小费用",
        "hardRate": "MEDIUM",
        "passRate": "58.63%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-reach-city-with-discounts/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-reach-city-with-discounts/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2094找出 3 位偶数",
        "hardRate": "EASY",
        "passRate": "55.73%",
        "problemsUrl": "https://leetcode.cn/problems/finding-3-digit-even-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/finding-3-digit-even-numbers/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>digits</code> ，其中每个元素是一个数字（<code>0 - 9</code>）。数组中可能存在重复元素。</p>\n\n<p>你需要找出 <strong>所有</strong> 满足下述条件且 <strong>互不相同</strong> 的整数：</p>\n\n<ul>\n\t<li>该整数由 <code>digits</code> 中的三个元素按 <strong>任意</strong> 顺序 <strong>依次连接</strong> 组成。</li>\n\t<li>该整数不含 <strong>前导零</strong></li>\n\t<li>该整数是一个 <strong>偶数</strong></li>\n</ul>\n\n<p>例如，给定的 <code>digits</code> 是 <code>[1, 2, 3]</code> ，整数 <code>132</code> 和 <code>312</code> 满足上面列出的全部条件。</p>\n\n<p>将找出的所有互不相同的整数按 <strong>递增顺序</strong> 排列，并以数组形式返回<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = [2,1,3,0]\n<strong>输出：</strong>[102,120,130,132,210,230,302,310,312,320]\n<strong>解释：</strong>\n所有满足题目条件的整数都在输出数组中列出。 \n注意，答案数组中不含有 <strong>奇数</strong> 或带 <strong>前导零</strong> 的整数。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = [2,2,8,8,2]\n<strong>输出：</strong>[222,228,282,288,822,828,882]\n<strong>解释：</strong>\n同样的数字（0 - 9）在构造整数时可以重复多次，重复次数最多与其在 <code>digits</code> 中出现的次数一样。 \n在这个例子中，数字 8 在构造 288、828 和 882 时都重复了两次。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = [3,7,5]\n<strong>输出：</strong>[]\n<strong>解释：</strong>\n使用给定的 digits 无法构造偶数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;=&nbsp;digits.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= digits[i] &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2095删除链表的中间节点",
        "hardRate": "MEDIUM",
        "passRate": "57.50%",
        "problemsUrl": "https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/solution",
        "problemsDesc": "<p>给你一个链表的头节点 <code>head</code> 。<strong>删除</strong> 链表的 <strong>中间节点</strong> ，并返回修改后的链表的头节点 <code>head</code> 。</p>\n\n<p>长度为 <code>n</code> 链表的中间节点是从头数起第 <code>⌊n / 2⌋</code> 个节点（下标从 <strong>0</strong> 开始），其中 <code>⌊x⌋</code> 表示小于或等于 <code>x</code> 的最大整数。</p>\n\n<ul>\n\t<li>对于 <code>n</code> = <code>1</code>、<code>2</code>、<code>3</code>、<code>4</code> 和 <code>5</code> 的情况，中间节点的下标分别是 <code>0</code>、<code>1</code>、<code>1</code>、<code>2</code> 和 <code>2</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/16/eg1drawio.png\" style=\"width: 500px; height: 77px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,3,4,7,1,2,6]\n<strong>输出：</strong>[1,3,4,1,2,6]\n<strong>解释：</strong>\n上图表示给出的链表。节点的下标分别标注在每个节点的下方。\n由于 n = 7 ，值为 7 的节点 3 是中间节点，用红色标注。\n返回结果为移除节点后的新链表。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/16/eg2drawio.png\" style=\"width: 250px; height: 43px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,3,4]\n<strong>输出：</strong>[1,2,4]\n<strong>解释：</strong>\n上图表示给出的链表。\n对于 n = 4 ，值为 3 的节点 2 是中间节点，用红色标注。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/16/eg3drawio.png\" style=\"width: 150px; height: 58px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [2,1]\n<strong>输出：</strong>[2]\n<strong>解释：</strong>\n上图表示给出的链表。\n对于 n = 2 ，值为 1 的节点 1 是中间节点，用红色标注。\n值为 2 的节点 0 是移除节点 1 后剩下的唯一一个节点。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2096从二叉树一个节点到另一个节点每一步的方向",
        "hardRate": "MEDIUM",
        "passRate": "44.58%",
        "problemsUrl": "https://leetcode.cn/problems/step-by-step-directions-from-a-binary-tree-node-to-another/",
        "solutionsUrl": "https://leetcode.cn/problems/step-by-step-directions-from-a-binary-tree-node-to-another/solution",
        "problemsDesc": "<p>给你一棵 <strong>二叉树</strong>&nbsp;的根节点&nbsp;<code>root</code>&nbsp;，这棵二叉树总共有&nbsp;<code>n</code>&nbsp;个节点。每个节点的值为&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;中的一个整数，且互不相同。给你一个整数&nbsp;<code>startValue</code>&nbsp;，表示起点节点 <code>s</code>&nbsp;的值，和另一个不同的整数&nbsp;<code>destValue</code>&nbsp;，表示终点节点&nbsp;<code>t</code>&nbsp;的值。</p>\n\n<p>请找到从节点&nbsp;<code>s</code>&nbsp;到节点 <code>t</code>&nbsp;的 <strong>最短路径</strong>&nbsp;，并以字符串的形式返回每一步的方向。每一步用 <strong>大写</strong>&nbsp;字母&nbsp;<code>'L'</code>&nbsp;，<code>'R'</code>&nbsp;和&nbsp;<code>'U'</code>&nbsp;分别表示一种方向：</p>\n\n<ul>\n\t<li><code>'L'</code>&nbsp;表示从一个节点前往它的 <strong>左孩子</strong>&nbsp;节点。</li>\n\t<li><code>'R'</code>&nbsp;表示从一个节点前往它的 <strong>右孩子</strong>&nbsp;节点。</li>\n\t<li><code>'U'</code>&nbsp;表示从一个节点前往它的 <strong>父</strong>&nbsp;节点。</li>\n</ul>\n\n<p>请你返回从 <code>s</code>&nbsp;到 <code>t</code>&nbsp;<strong>最短路径</strong>&nbsp;每一步的方向。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/15/eg1.png\" style=\"width: 214px; height: 163px;\"></p>\n\n<pre><b>输入：</b>root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6\n<b>输出：</b>\"UURL\"\n<b>解释：</b>最短路径为：3 → 1 → 5 → 2 → 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/15/eg2.png\" style=\"width: 74px; height: 102px;\"></p>\n\n<pre><b>输入：</b>root = [2,1], startValue = 2, destValue = 1\n<b>输出：</b>\"L\"\n<b>解释：</b>最短路径为：2 → 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目为&nbsp;<code>n</code>&nbsp;。</li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= Node.val &lt;= n</code></li>\n\t<li>树中所有节点的值 <strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>1 &lt;= startValue, destValue &lt;= n</code></li>\n\t<li><code>startValue != destValue</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2097合法重新排列数对",
        "hardRate": "HARD",
        "passRate": "37.97%",
        "problemsUrl": "https://leetcode.cn/problems/valid-arrangement-of-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-arrangement-of-pairs/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>pairs</code>&nbsp;，其中&nbsp;<code>pairs[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>&nbsp;。如果 <code>pairs</code>&nbsp;的一个重新排列，满足对每一个下标 <code>i</code> （&nbsp;<code>1 &lt;= i &lt; pairs.length</code>&nbsp;）都有&nbsp;<code>end<sub>i-1</sub> == start<sub>i</sub></code><sub> </sub>，那么我们就认为这个重新排列是&nbsp;<code>pairs</code> 的一个 <strong>合法重新排列</strong> 。</p>\n\n<p>请你返回 <strong>任意一个</strong>&nbsp;<code>pairs</code> 的合法重新排列。</p>\n\n<p><b>注意：</b>数据保证至少存在一个 <code>pairs</code>&nbsp;的合法重新排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>pairs = [[5,1],[4,5],[11,9],[9,4]]\n<b>输出：</b>[[11,9],[9,4],[4,5],[5,1]]\n<strong>解释：\n</strong>输出的是一个合法重新排列，因为每一个 end<sub>i-1</sub> 都等于 start<sub>i</sub>&nbsp;。\nend<sub>0</sub> = 9 == 9 = start<sub>1</sub> \nend<sub>1</sub> = 4 == 4 = start<sub>2</sub>\nend<sub>2</sub> = 5 == 5 = start<sub>3</sub>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>pairs = [[1,3],[3,2],[2,1]]\n<b>输出：</b>[[1,3],[3,2],[2,1]]\n<strong>解释：</strong>\n输出的是一个合法重新排列，因为每一个 end<sub>i-1</sub> 都等于 start<sub>i</sub>&nbsp;。\nend<sub>0</sub> = 3 == 3 = start<sub>1</sub>\nend<sub>1</sub> = 2 == 2 = start<sub>2</sub>\n重新排列后的数组 [[2,1],[1,3],[3,2]] 和 [[3,2],[2,1],[1,3]] 都是合法的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>pairs = [[1,2],[1,3],[2,1]]\n<b>输出：</b>[[1,2],[2,1],[1,3]]\n<strong>解释：</strong>\n输出的是一个合法重新排列，因为每一个 end<sub>i-1</sub> 都等于 start<sub>i</sub>&nbsp;。\nend<sub>0</sub> = 2 == 2 = start<sub>1</sub>\nend<sub>1</sub> = 1 == 1 = start<sub>2</sub>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pairs.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pairs[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub>, end<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>start<sub>i</sub> != end<sub>i</sub></code></li>\n\t<li><code>pairs</code>&nbsp;中不存在一模一样的数对。</li>\n\t<li>至少 <strong>存在</strong> 一个合法的&nbsp;<code>pairs</code>&nbsp;重新排列。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2098长度为 K 的最大偶数和子序列",
        "hardRate": "MEDIUM",
        "passRate": "35.03%",
        "problemsUrl": "https://leetcode.cn/problems/subsequence-of-size-k-with-the-largest-even-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/subsequence-of-size-k-with-the-largest-even-sum/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2099找到和最大的长度为 K 的子序列",
        "hardRate": "EASY",
        "passRate": "48.40%",
        "problemsUrl": "https://leetcode.cn/problems/find-subsequence-of-length-k-with-the-largest-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/find-subsequence-of-length-k-with-the-largest-sum/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。你需要找到&nbsp;<code>nums</code>&nbsp;中长度为 <code>k</code>&nbsp;的 <strong>子序列</strong>&nbsp;，且这个子序列的&nbsp;<strong>和最大&nbsp;</strong>。</p>\n\n<p>请你返回 <strong>任意</strong> 一个长度为&nbsp;<code>k</code>&nbsp;的整数子序列。</p>\n\n<p><strong>子序列</strong>&nbsp;定义为从一个数组里删除一些元素后，不改变剩下元素的顺序得到的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,1,3,3], k = 2\n<b>输出：</b>[3,3]\n<strong>解释：</strong>\n子序列有最大和：3 + 3 = 6 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [-1,-2,3,4], k = 3\n<b>输出：</b>[-1,3,4]\n<b>解释：</b>\n子序列有最大和：-1 + 3 + 4 = 6 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [3,4,3,3], k = 2\n<b>输出：</b>[3,4]\n<strong>解释：</strong>\n子序列有最大和：3 + 4 = 7 。\n另一个可行的子序列为 [4, 3] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2100适合打劫银行的日子",
        "hardRate": "MEDIUM",
        "passRate": "48.67%",
        "problemsUrl": "https://leetcode.cn/problems/find-good-days-to-rob-the-bank/",
        "solutionsUrl": "https://leetcode.cn/problems/find-good-days-to-rob-the-bank/solution",
        "problemsDesc": "<p>你和一群强盗准备打劫银行。给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>security</code>&nbsp;，其中&nbsp;<code>security[i]</code>&nbsp;是第 <code>i</code>&nbsp;天执勤警卫的数量。日子从 <code>0</code>&nbsp;开始编号。同时给你一个整数&nbsp;<code>time</code>&nbsp;。</p>\n\n<p>如果第 <code>i</code>&nbsp;天满足以下所有条件，我们称它为一个适合打劫银行的日子：</p>\n\n<ul>\n\t<li>第 <code>i</code>&nbsp;天前和后都分别至少有 <code>time</code>&nbsp;天。</li>\n\t<li>第 <code>i</code>&nbsp;天前连续 <code>time</code>&nbsp;天警卫数目都是非递增的。</li>\n\t<li>第 <code>i</code>&nbsp;天后连续 <code>time</code>&nbsp;天警卫数目都是非递减的。</li>\n</ul>\n\n<p>更正式的，第 <code>i</code> 天是一个合适打劫银行的日子当且仅当：<code>security[i - time] &gt;= security[i - time + 1] &gt;= ... &gt;= security[i] &lt;= ... &lt;= security[i + time - 1] &lt;= security[i + time]</code>.</p>\n\n<p>请你返回一个数组，包含 <strong>所有</strong> 适合打劫银行的日子（下标从 <strong>0</strong>&nbsp;开始）。返回的日子可以 <strong>任意</strong>&nbsp;顺序排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>security = [5,3,3,3,5,6,2], time = 2\n<b>输出：</b>[2,3]\n<strong>解释：</strong>\n第 2 天，我们有 security[0] &gt;= security[1] &gt;= security[2] &lt;= security[3] &lt;= security[4] 。\n第 3 天，我们有 security[1] &gt;= security[2] &gt;= security[3] &lt;= security[4] &lt;= security[5] 。\n没有其他日子符合这个条件，所以日子 2 和 3 是适合打劫银行的日子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>security = [1,1,1,1,1], time = 0\n<b>输出：</b>[0,1,2,3,4]\n<strong>解释：</strong>\n因为 time 等于 0 ，所以每一天都是适合打劫银行的日子，所以返回每一天。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>security = [1,2,3,4,5,6], time = 2\n<b>输出：</b>[]\n<strong>解释：</strong>\n没有任何一天的前 2 天警卫数目是非递增的。\n所以没有适合打劫银行的日子，返回空数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= security.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= security[i], time &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2101引爆最多的炸弹",
        "hardRate": "MEDIUM",
        "passRate": "39.71%",
        "problemsUrl": "https://leetcode.cn/problems/detonate-the-maximum-bombs/",
        "solutionsUrl": "https://leetcode.cn/problems/detonate-the-maximum-bombs/solution",
        "problemsDesc": "<p>给你一个炸弹列表。一个炸弹的 <strong>爆炸范围</strong>&nbsp;定义为以炸弹为圆心的一个圆。</p>\n\n<p>炸弹用一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>bombs</code>&nbsp;表示，其中&nbsp;<code>bombs[i] = [x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub>]</code>&nbsp;。<code>x<sub>i</sub></code> 和&nbsp;<code>y<sub>i</sub></code>&nbsp;表示第 <code>i</code>&nbsp;个炸弹的 X 和 Y 坐标，<code>r<sub>i</sub></code>&nbsp;表示爆炸范围的 <strong>半径</strong>&nbsp;。</p>\n\n<p>你需要选择引爆 <strong>一个&nbsp;</strong>炸弹。当这个炸弹被引爆时，<strong>所有</strong> 在它爆炸范围内的炸弹都会被引爆，这些炸弹会进一步将它们爆炸范围内的其他炸弹引爆。</p>\n\n<p>给你数组&nbsp;<code>bombs</code>&nbsp;，请你返回在引爆&nbsp;<strong>一个</strong>&nbsp;炸弹的前提下，<strong>最多</strong>&nbsp;能引爆的炸弹数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-3.png\" style=\"width: 300px; height: 300px;\"></p>\n\n<pre><b>输入：</b>bombs = [[2,1,3],[6,1,4]]\n<b>输出：</b>2\n<strong>解释：</strong>\n上图展示了 2 个炸弹的位置和爆炸范围。\n如果我们引爆左边的炸弹，右边的炸弹不会被影响。\n但如果我们引爆右边的炸弹，两个炸弹都会爆炸。\n所以最多能引爆的炸弹数目是 max(1, 2) = 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-2.png\" style=\"width: 300px; height: 300px;\"></p>\n\n<pre><b>输入：</b>bombs = [[1,1,5],[10,10,5]]\n<b>输出：</b>1\n<strong>解释：\n</strong>引爆任意一个炸弹都不会引爆另一个炸弹。所以最多能引爆的炸弹数目为 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/07/desmos-eg1.png\" style=\"width: 300px; height: 300px;\"></p>\n\n<pre><b>输入：</b>bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]\n<b>输出：</b>5\n<strong>解释：</strong>\n最佳引爆炸弹为炸弹 0 ，因为：\n- 炸弹 0 引爆炸弹 1 和 2 。红色圆表示炸弹 0 的爆炸范围。\n- 炸弹 2 引爆炸弹 3 。蓝色圆表示炸弹 2 的爆炸范围。\n- 炸弹 3 引爆炸弹 4 。绿色圆表示炸弹 3 的爆炸范围。\n所以总共有 5 个炸弹被引爆。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= bombs.length&nbsp;&lt;= 100</code></li>\n\t<li><code>bombs[i].length == 3</code></li>\n\t<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2102序列顺序查询",
        "hardRate": "HARD",
        "passRate": "55.88%",
        "problemsUrl": "https://leetcode.cn/problems/sequentially-ordinal-rank-tracker/",
        "solutionsUrl": "https://leetcode.cn/problems/sequentially-ordinal-rank-tracker/solution",
        "problemsDesc": "<p>一个观光景点由它的名字&nbsp;<code>name</code> 和景点评分&nbsp;<code>score</code>&nbsp;组成，其中&nbsp;<code>name</code>&nbsp;是所有观光景点中&nbsp;<strong>唯一</strong>&nbsp;的字符串，<code>score</code>&nbsp;是一个整数。景点按照最好到最坏排序。景点评分 <strong>越高</strong>&nbsp;，这个景点越好。如果有两个景点的评分一样，那么 <strong>字典序较小</strong>&nbsp;的景点更好。</p>\n\n<p>你需要搭建一个系统，查询景点的排名。初始时系统里没有任何景点。这个系统支持：</p>\n\n<ul>\n\t<li><strong>添加</strong> 景点，每次添加 <strong>一个</strong> 景点。</li>\n\t<li><strong>查询 </strong>已经添加景点中第&nbsp;<code>i</code>&nbsp;<strong>好</strong>&nbsp;的景点，其中&nbsp;<code>i</code>&nbsp;是系统目前位置查询的次数（包括当前这一次）。\n\t<ul>\n\t\t<li>比方说，如果系统正在进行第 <code>4</code>&nbsp;次查询，那么需要返回所有已经添加景点中第 <code>4</code>&nbsp;好的。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>注意，测试数据保证&nbsp;<strong>任意查询时刻</strong>&nbsp;，查询次数都 <strong>不超过</strong>&nbsp;系统中景点的数目。</p>\n\n<p>请你实现&nbsp;<code>SORTracker</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>SORTracker()</code>&nbsp;初始化系统。</li>\n\t<li><code>void add(string name, int score)</code>&nbsp;向系统中添加一个名为&nbsp;<code>name</code> 评分为&nbsp;<code>score</code>&nbsp;的景点。</li>\n\t<li><code>string get()</code>&nbsp;查询第 <code>i</code>&nbsp;好的景点，其中 <code>i</code>&nbsp;是目前系统查询的次数（包括当前这次查询）。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"SORTracker\", \"add\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"get\"]\n[[], [\"bradford\", 2], [\"branford\", 3], [], [\"alps\", 2], [], [\"orland\", 2], [], [\"orlando\", 3], [], [\"alpine\", 2], [], []]\n<strong>输出：</strong>\n[null, null, null, \"branford\", null, \"alps\", null, \"bradford\", null, \"bradford\", null, \"bradford\", \"orland\"]\n\n<strong>解释：</strong>\nSORTracker tracker = new SORTracker(); // 初始化系统\ntracker.add(\"bradford\", 2); // 添加 name=\"bradford\" 且 score=2 的景点。\ntracker.add(\"branford\", 3); // 添加 name=\"branford\" 且 score=3 的景点。\ntracker.get();              // 从好带坏的景点为：branford ，bradford 。\n                            // 注意到 branford 比 bradford 好，因为它的 <strong>评分更高</strong> (3 &gt; 2) 。\n                            // 这是第 1 次调用 get() ，所以返回最好的景点：\"branford\" 。\ntracker.add(\"alps\", 2);     // 添加 name=\"alps\" 且 score=2 的景点。\ntracker.get();              // 从好到坏的景点为：branford, alps, bradford 。\n                            // 注意 alps 比 bradford 好，虽然它们评分相同，都为 2 。\n                            // 这是因为 \"alps\" <strong>字典序</strong>&nbsp;比 \"bradford\" 小。\n                            // 返回第 2 好的地点 \"alps\" ，因为当前为第 2 次调用 get() 。\ntracker.add(\"orland\", 2);   // 添加 name=\"orland\" 且 score=2 的景点。\ntracker.get();              // 从好到坏的景点为：branford, alps, bradford, orland 。\n                            // 返回 \"bradford\" ，因为当前为第 3 次调用 get() 。\ntracker.add(\"orlando\", 3);  // 添加 name=\"orlando\" 且 score=3 的景点。\ntracker.get();              // 从好到坏的景点为：branford, orlando, alps, bradford, orland 。\n                            // 返回 \"bradford\".\ntracker.add(\"alpine\", 2);   // 添加 name=\"alpine\" 且 score=2 的景点。\ntracker.get();              // 从好到坏的景点为：branford, orlando, alpine, alps, bradford, orland 。\n                            // 返回 \"bradford\" 。\ntracker.get();              // 从好到坏的景点为：branford, orlando, alpine, alps, bradford, orland 。\n                            // 返回 \"orland\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>name</code>&nbsp;只包含小写英文字母，且每个景点名字互不相同。</li>\n\t<li><code>1 &lt;= name.length &lt;= 10</code></li>\n\t<li><code>1 &lt;= score &lt;= 10<sup>5</sup></code></li>\n\t<li>任意时刻，调用&nbsp;<code>get</code>&nbsp;的次数都不超过调用&nbsp;<code>add</code>&nbsp;的次数。</li>\n\t<li><strong>总共</strong>&nbsp;调用&nbsp;<code>add</code> 和&nbsp;<code>get</code>&nbsp;不超过&nbsp;<code>4 * 10<sup>4</sup></code>&nbsp;</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2103环和杆",
        "hardRate": "EASY",
        "passRate": "79.62%",
        "problemsUrl": "https://leetcode.cn/problems/rings-and-rods/",
        "solutionsUrl": "https://leetcode.cn/problems/rings-and-rods/solution",
        "problemsDesc": "<p>总计有 <code>n</code> 个环，环的颜色可以是红、绿、蓝中的一种。这些环分布穿在 10 根编号为 <code>0</code> 到 <code>9</code> 的杆上。</p>\n\n<p>给你一个长度为 <code>2n</code> 的字符串 <code>rings</code> ，表示这 <code>n</code> 个环在杆上的分布。<code>rings</code> 中每两个字符形成一个 <strong>颜色位置对</strong> ，用于描述每个环：</p>\n\n<ul>\n\t<li>第 <code>i</code> 对中的 <strong>第一个</strong> 字符表示第 <code>i</code> 个环的 <strong>颜色</strong>（<code>'R'</code>、<code>'G'</code>、<code>'B'</code>）。</li>\n\t<li>第 <code>i</code> 对中的 <strong>第二个</strong> 字符表示第 <code>i</code> 个环的 <strong>位置</strong>，也就是位于哪根杆上（<code>'0'</code> 到 <code>'9'</code>）。</li>\n</ul>\n\n<p>例如，<code>\"R3G2B1\"</code> 表示：共有 <code>n == 3</code> 个环，红色的环在编号为 3 的杆上，绿色的环在编号为 2 的杆上，蓝色的环在编号为 1 的杆上。</p>\n\n<p>找出所有集齐 <strong>全部三种颜色</strong> 环的杆，并返回这种杆的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/23/ex1final.png\" style=\"width: 258px; height: 130px;\">\n<pre><strong>输入：</strong>rings = \"B0B6G0R6R0R6G9\"\n<strong>输出：</strong>1\n<strong>解释：</strong>\n- 编号 0 的杆上有 3 个环，集齐全部颜色：红、绿、蓝。\n- 编号 6 的杆上有 3 个环，但只有红、蓝两种颜色。\n- 编号 9 的杆上只有 1 个绿色环。\n因此，集齐全部三种颜色环的杆的数目为 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/23/ex2final.png\" style=\"width: 266px; height: 130px;\">\n<pre><strong>输入：</strong>rings = \"B0R0G0R9R0B0G0\"\n<strong>输出：</strong>1\n<strong>解释：</strong>\n- 编号 0 的杆上有 6 个环，集齐全部颜色：红、绿、蓝。\n- 编号 9 的杆上只有 1 个红色环。\n因此，集齐全部三种颜色环的杆的数目为 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>rings = \"G4\"\n<strong>输出：</strong>0\n<strong>解释：</strong>\n只给了一个环，因此，不存在集齐全部三种颜色环的杆。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rings.length == 2 * n</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li>如 <code>i</code> 是 <strong>偶数</strong> ，则&nbsp;<code>rings[i]</code> 的值可以取 <code>'R'</code>、<code>'G'</code> 或 <code>'B'</code>（下标从 <strong>0</strong> 开始计数）</li>\n\t<li>如 <code>i</code> 是 <strong>奇数</strong> ，则&nbsp;<code>rings[i]</code> 的值可以取 <code>'0'</code> 到 <code>'9'</code> 中的一个数字（下标从 <strong>0</strong> 开始计数）</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2104子数组范围和",
        "hardRate": "MEDIUM",
        "passRate": "62.90%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-subarray-ranges/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-subarray-ranges/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。<code>nums</code> 中，子数组的 <strong>范围</strong> 是子数组中最大元素和最小元素的差值。</p>\n\n<p>返回 <code>nums</code> 中 <strong>所有</strong> 子数组范围的 <strong>和</strong> <em>。</em></p>\n\n<p>子数组是数组中一个连续 <strong>非空</strong> 的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>4\n<strong>解释：</strong>nums 的 6 个子数组如下所示：\n[1]，范围 = 最大 - 最小 = 1 - 1 = 0 \n[2]，范围 = 2 - 2 = 0\n[3]，范围 = 3 - 3 = 0\n[1,2]，范围 = 2 - 1 = 1\n[2,3]，范围 = 3 - 2 = 1\n[1,2,3]，范围 = 3 - 1 = 2\n所有范围的和是 0 + 0 + 0 + 1 + 1 + 2 = 4</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,3]\n<strong>输出：</strong>4\n<strong>解释：</strong>nums 的 6 个子数组如下所示：\n[1]，范围 = 最大 - 最小 = 1 - 1 = 0\n[3]，范围 = 3 - 3 = 0\n[3]，范围 = 3 - 3 = 0\n[1,3]，范围 = 3 - 1 = 2\n[3,3]，范围 = 3 - 3 = 0\n[1,3,3]，范围 = 3 - 1 = 2\n所有范围的和是 0 + 0 + 0 + 2 + 0 + 2 = 4\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,-2,-3,4,1]\n<strong>输出：</strong>59\n<strong>解释：</strong>nums 中所有子数组范围的和是 59\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以设计一种时间复杂度为 <code>O(n)</code> 的解决方案吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2105给植物浇水 II",
        "hardRate": "MEDIUM",
        "passRate": "53.02%",
        "problemsUrl": "https://leetcode.cn/problems/watering-plants-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/watering-plants-ii/solution",
        "problemsDesc": "<p>Alice 和 Bob 打算给花园里的 <code>n</code> 株植物浇水。植物排成一行，从左到右进行标记，编号从 <code>0</code> 到 <code>n - 1</code> 。其中，第 <code>i</code> 株植物的位置是 <code>x = i</code> 。</p>\n\n<p>每一株植物都需要浇特定量的水。Alice 和 Bob 每人有一个水罐，<strong>最初是满的 </strong>。他们按下面描述的方式完成浇水：</p>\n\n<ul>\n\t<li>&nbsp;Alice 按 <strong>从左到右</strong> 的顺序给植物浇水，从植物 <code>0</code> 开始。Bob 按 <strong>从右到左</strong> 的顺序给植物浇水，从植物 <code>n - 1</code> 开始。他们 <strong>同时</strong> 给植物浇水。</li>\n\t<li>如果没有足够的水 <strong>完全</strong> 浇灌下一株植物，他 / 她会立即重新灌满浇水罐。</li>\n\t<li>不管植物需要多少水，浇水所耗费的时间都是一样的。</li>\n\t<li><strong>不能</strong> 提前重新灌满水罐。</li>\n\t<li>每株植物都可以由 Alice 或者 Bob 来浇水。</li>\n\t<li>如果 Alice 和 Bob 到达同一株植物，那么当前水罐中水更多的人会给这株植物浇水。如果他俩水量相同，那么 Alice 会给这株植物浇水。</li>\n</ul>\n\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>plants</code> ，数组由 <code>n</code> 个整数组成。其中，<code>plants[i]</code> 为第 <code>i</code> 株植物需要的水量。另有两个整数 <code>capacityA</code> 和&nbsp;<code>capacityB</code> 分别表示 Alice 和 Bob 水罐的容量。返回两人浇灌所有植物过程中重新灌满水罐的 <strong>次数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>plants = [2,2,3,3], capacityA = 5, capacityB = 5\n<strong>输出：</strong>1\n<strong>解释：</strong>\n- 最初，Alice 和 Bob 的水罐中各有 5 单元水。\n- Alice 给植物 0 浇水，Bob 给植物 3 浇水。\n- Alice 和 Bob 现在分别剩下 3 单元和 2 单元水。\n- Alice 有足够的水给植物 1 ，所以她直接浇水。Bob 的水不够给植物 2 ，所以他先重新装满水，再浇水。\n所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 + 0 + 1 + 0 = 1 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>plants = [2,2,3,3], capacityA = 3, capacityB = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>\n- 最初，Alice 的水罐中有 3 单元水，Bob 的水罐中有 4 单元水。\n- Alice 给植物 0 浇水，Bob 给植物 3 浇水。\n- Alice 和 Bob 现在都只有 1 单元水，并分别需要给植物 1 和植物 2 浇水。\n- 由于他们的水量均不足以浇水，所以他们重新灌满水罐再进行浇水。\n所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 + 1 + 1 + 0 = 2 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>plants = [5], capacityA = 10, capacityB = 8\n<strong>输出：</strong>0\n<strong>解释：</strong>\n- 只有一株植物\n- Alice 的水罐有 10 单元水，Bob 的水罐有 8 单元水。因此 Alice 的水罐中水更多，她会给这株植物浇水。\n所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == plants.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= plants[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>max(plants[i]) &lt;= capacityA, capacityB &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2106摘水果",
        "hardRate": "HARD",
        "passRate": "45.09%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/solution",
        "problemsDesc": "<p>在一个无限的 x 坐标轴上，有许多水果分布在其中某些位置。给你一个二维整数数组 <code>fruits</code> ，其中 <code>fruits[i] = [position<sub>i</sub>, amount<sub>i</sub>]</code> 表示共有 <code>amount<sub>i</sub></code> 个水果放置在 <code>position<sub>i</sub></code> 上。<code>fruits</code> 已经按 <code>position<sub>i</sub></code> <strong>升序排列</strong> ，每个 <code>position<sub>i</sub></code> <strong>互不相同</strong> 。</p>\n\n<p>另给你两个整数 <code>startPos</code> 和 <code>k</code> 。最初，你位于 <code>startPos</code> 。从任何位置，你可以选择 <strong>向左或者向右</strong> 走。在 x 轴上每移动 <strong>一个单位</strong> ，就记作 <strong>一步</strong> 。你总共可以走 <strong>最多</strong> <code>k</code> 步。你每达到一个位置，都会摘掉全部的水果，水果也将从该位置消失（不会再生）。</p>\n\n<p>返回你可以摘到水果的 <strong>最大总数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/21/1.png\" style=\"width: 472px; height: 115px;\">\n<pre><strong>输入：</strong>fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4\n<strong>输出：</strong>9\n<strong>解释：</strong>\n最佳路线为：\n- 向右移动到位置 6 ，摘到 3 个水果\n- 向右移动到位置 8 ，摘到 6 个水果\n移动 3 步，共摘到 3 + 6 = 9 个水果\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/21/2.png\" style=\"width: 512px; height: 129px;\">\n<pre><strong>输入：</strong>fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4\n<strong>输出：</strong>14\n<strong>解释：</strong>\n可以移动最多 k = 4 步，所以无法到达位置 0 和位置 10 。\n最佳路线为：\n- 在初始位置 5 ，摘到 7 个水果\n- 向左移动到位置 4 ，摘到 1 个水果\n- 向右移动到位置 6 ，摘到 2 个水果\n- 向右移动到位置 7 ，摘到 4 个水果\n移动 1 + 3 = 4 步，共摘到 7 + 1 + 2 + 4 = 14 个水果\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/21/3.png\" style=\"width: 476px; height: 100px;\">\n<pre><strong>输入：</strong>fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2\n<strong>输出：</strong>0\n<strong>解释：</strong>\n最多可以移动 k = 2 步，无法到达任一有水果的地方\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= fruits.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>fruits[i].length == 2</code></li>\n\t<li><code>0 &lt;= startPos, position<sub>i</sub> &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li>对于任意 <code>i &gt; 0</code> ，<code>position<sub>i-1</sub> &lt; position<sub>i</sub></code> 均成立（下标从 <strong>0</strong> 开始计数）</li>\n\t<li><code>1 &lt;= amount<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 2 * 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2107分享 K 个糖果后独特口味的数量",
        "hardRate": "MEDIUM",
        "passRate": "38.83%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-unique-flavors-after-sharing-k-candies/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-unique-flavors-after-sharing-k-candies/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2108找出数组中的第一个回文字符串",
        "hardRate": "EASY",
        "passRate": "77.53%",
        "problemsUrl": "https://leetcode.cn/problems/find-first-palindromic-string-in-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-first-palindromic-string-in-the-array/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>words</code> ，找出并返回数组中的 <strong>第一个回文字符串</strong> 。如果不存在满足要求的字符串，返回一个 <strong>空字符串</strong><em> </em><code>\"\"</code> 。</p>\n\n<p><strong>回文字符串</strong> 的定义为：如果一个字符串正着读和反着读一样，那么该字符串就是一个 <strong>回文字符串</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]\n<strong>输出：</strong>\"ada\"\n<strong>解释：</strong>第一个回文字符串是 \"ada\" 。\n注意，\"racecar\" 也是回文字符串，但它不是第一个。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"notapalindrome\",\"racecar\"]\n<strong>输出：</strong>\"racecar\"\n<strong>解释：</strong>第一个也是唯一一个回文字符串是 \"racecar\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"def\",\"ghi\"]\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>不存在回文字符串，所以返回一个空字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><code>words[i]</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2109向字符串添加空格",
        "hardRate": "MEDIUM",
        "passRate": "61.51%",
        "problemsUrl": "https://leetcode.cn/problems/adding-spaces-to-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/adding-spaces-to-a-string/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，以及一个下标从 <strong>0</strong> 开始的整数数组 <code>spaces</code> 。</p>\n\n<p>数组 <code>spaces</code> 描述原字符串中需要添加空格的下标。每个空格都应该插入到给定索引处的字符值 <strong>之前</strong> 。</p>\n\n<ul>\n\t<li>例如，<code>s = \"EnjoyYourCoffee\"</code> 且 <code>spaces = [5, 9]</code> ，那么我们需要在 <code>'Y'</code> 和 <code>'C'</code> 之前添加空格，这两个字符分别位于下标 <code>5</code> 和下标 <code>9</code> 。因此，最终得到 <code>\"Enjoy <em><strong>Y</strong></em>our <em><strong>C</strong></em>offee\"</code> 。</li>\n</ul>\n\n<p>请你添加空格，并返回修改后的字符串<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"LeetcodeHelpsMeLearn\", spaces = [8,13,15]\n<strong>输出：</strong>\"Leetcode Helps Me Learn\"\n<strong>解释：</strong>\n下标 8、13 和 15 对应 \"Leetcode<em><strong>H</strong></em>elps<em><strong>M</strong></em>e<em><strong>L</strong></em>earn\" 中加粗斜体字符。\n接着在这些字符前添加空格。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"icodeinpython\", spaces = [1,5,7,9]\n<strong>输出：</strong>\"i code in py thon\"\n<strong>解释：</strong>\n下标 1、5、7 和 9 对应 \"i<em><strong>c</strong></em>ode<em><strong>i</strong></em>n<em><strong>p</strong></em>y<em><strong>t</strong></em>hon\" 中加粗斜体字符。\n接着在这些字符前添加空格。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"spacing\", spaces = [0,1,2,3,4,5,6]\n<strong>输出：</strong>\" s p a c i n g\"\n<strong>解释：</strong>\n字符串的第一个字符前可以添加空格。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> 仅由大小写英文字母组成</li>\n\t<li><code>1 &lt;= spaces.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= spaces[i] &lt;= s.length - 1</code></li>\n\t<li><code>spaces</code> 中的所有值 <strong>严格递增</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2110股票平滑下跌阶段的数目",
        "hardRate": "MEDIUM",
        "passRate": "52.81%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-smooth-descent-periods-of-a-stock/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-smooth-descent-periods-of-a-stock/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>prices</code>&nbsp;，表示一支股票的历史每日股价，其中&nbsp;<code>prices[i]</code>&nbsp;是这支股票第&nbsp;<code>i</code>&nbsp;天的价格。</p>\n\n<p>一个 <strong>平滑下降的阶段</strong>&nbsp;定义为：对于&nbsp;<strong>连续一天或者多天</strong>&nbsp;，每日股价都比 <strong>前一日股价恰好少 </strong><code>1</code>&nbsp;，这个阶段第一天的股价没有限制。</p>\n\n<p>请你返回 <strong>平滑下降阶段</strong>&nbsp;的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>prices = [3,2,1,4]\n<b>输出：</b>7\n<b>解释：</b>总共有 7 个平滑下降阶段：\n[3], [2], [1], [4], [3,2], [2,1] 和 [3,2,1]\n注意，仅一天按照定义也是平滑下降阶段。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>prices = [8,6,7,7]\n<b>输出：</b>4\n<b>解释：</b>总共有 4 个连续平滑下降阶段：[8], [6], [7] 和 [7]\n由于 8 - 6 ≠ 1 ，所以 [8,6] 不是平滑下降阶段。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>prices = [1]\n<b>输出：</b>1\n<b>解释：</b>总共有 1 个平滑下降阶段：[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= prices[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2111使数组 K 递增的最少操作次数",
        "hardRate": "HARD",
        "passRate": "34.99%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-array-k-increasing/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-array-k-increasing/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始包含 <code>n</code>&nbsp;个正整数的数组&nbsp;<code>arr</code>&nbsp;，和一个正整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>如果对于每个满足&nbsp;<code>k &lt;= i &lt;= n-1</code>&nbsp;的下标&nbsp;<code>i</code>&nbsp;，都有&nbsp;<code>arr[i-k] &lt;= arr[i]</code>&nbsp;，那么我们称&nbsp;<code>arr</code>&nbsp;是 <strong>K</strong>&nbsp;<strong>递增</strong> 的。</p>\n\n<ul>\n\t<li>比方说，<code>arr = [4, 1, 5, 2, 6, 2]</code>&nbsp;对于&nbsp;<code>k = 2</code>&nbsp;是 K 递增的，因为：\n\n\t<ul>\n\t\t<li><code>arr[0] &lt;= arr[2] (4 &lt;= 5)</code></li>\n\t\t<li><code>arr[1] &lt;= arr[3] (1 &lt;= 2)</code></li>\n\t\t<li><code>arr[2] &lt;= arr[4] (5 &lt;= 6)</code></li>\n\t\t<li><code>arr[3] &lt;= arr[5] (2 &lt;= 2)</code></li>\n\t</ul>\n\t</li>\n\t<li>但是，相同的数组&nbsp;<code>arr</code>&nbsp;对于&nbsp;<code>k = 1</code>&nbsp;不是 K 递增的（因为&nbsp;<code>arr[0] &gt; arr[1]</code>），对于&nbsp;<code>k = 3</code>&nbsp;也不是 K 递增的（因为&nbsp;<code>arr[0] &gt; arr[3]</code>&nbsp;）。</li>\n</ul>\n\n<p>每一次 <strong>操作</strong>&nbsp;中，你可以选择一个下标&nbsp;<code>i</code> 并将&nbsp;<code>arr[i]</code> <strong>改成任意&nbsp;</strong>正整数。</p>\n\n<p>请你返回对于给定的 <code>k</code>&nbsp;，使数组变成 K 递增的 <strong>最少操作次数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>arr = [5,4,3,2,1], k = 1\n<b>输出：</b>4\n<strong>解释：\n</strong>对于 k = 1 ，数组最终必须变成非递减的。\n可行的 K 递增结果数组为 [5,<em><strong>6</strong></em>,<em><strong>7</strong></em>,<em><strong>8</strong></em>,<em><strong>9</strong></em>]，[<em><strong>1</strong></em>,<em><strong>1</strong></em>,<em><strong>1</strong></em>,<em><strong>1</strong></em>,1]，[<em><strong>2</strong></em>,<em><strong>2</strong></em>,3,<em><strong>4</strong></em>,<em><strong>4</strong></em>] 。它们都需要 4 次操作。\n次优解是将数组变成比方说 [<em><strong>6</strong></em>,<em><strong>7</strong></em>,<em><strong>8</strong></em>,<em><strong>9</strong></em>,<em><strong>10</strong></em>] ，因为需要 5 次操作。\n显然我们无法使用少于 4 次操作将数组变成 K 递增的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>arr = [4,1,5,2,6,2], k = 2\n<b>输出：</b>0\n<strong>解释：</strong>\n这是题目描述中的例子。\n对于每个满足 2 &lt;= i &lt;= 5 的下标 i ，有 arr[i-2] &lt;=<b> </b>arr[i] 。\n由于给定数组已经是 K 递增的，我们不需要进行任何操作。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [4,1,5,2,6,2], k = 3\n<b>输出：</b>2\n<strong>解释：</strong>\n下标 3 和 5 是仅有的 3 &lt;= i &lt;= 5 且不满足 arr[i-3] &lt;= arr[i] 的下标。\n将数组变成 K 递增的方法之一是将 arr[3] 变为 4 ，且将 arr[5] 变成 5 。\n数组变为 [4,1,5,<em><strong>4</strong></em>,6,<em><strong>5</strong></em>] 。\n可能有其他方法将数组变为 K 递增的，但没有任何一种方法需要的操作次数小于 2 次。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i], k &lt;= arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2112最繁忙的机场",
        "hardRate": "MEDIUM",
        "passRate": "68.39%",
        "problemsUrl": "https://leetcode.cn/problems/the-airport-with-the-most-traffic/",
        "solutionsUrl": "https://leetcode.cn/problems/the-airport-with-the-most-traffic/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2113查询删除和添加元素后的数组",
        "hardRate": "MEDIUM",
        "passRate": "61.64%",
        "problemsUrl": "https://leetcode.cn/problems/elements-in-array-after-removing-and-replacing-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/elements-in-array-after-removing-and-replacing-elements/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2114句子中的最多单词数",
        "hardRate": "EASY",
        "passRate": "84.97%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-words-found-in-sentences/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-words-found-in-sentences/solution",
        "problemsDesc": "<p>一个 <strong>句子</strong>&nbsp;由一些 <strong>单词</strong>&nbsp;以及它们之间的单个空格组成，句子的开头和结尾不会有多余空格。</p>\n\n<p>给你一个字符串数组&nbsp;<code>sentences</code>&nbsp;，其中&nbsp;<code>sentences[i]</code>&nbsp;表示单个 <strong>句子</strong>&nbsp;。</p>\n\n<p>请你返回单个句子里 <strong>单词的最多数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>sentences = [\"alice and bob love leetcode\", \"i think so too\", <em><strong>\"this is great thanks very much\"</strong></em>]\n<b>输出：</b>6\n<b>解释：</b>\n- 第一个句子 \"alice and bob love leetcode\" 总共有 5 个单词。\n- 第二个句子 \"i think so too\" 总共有 4 个单词。\n- 第三个句子 \"this is great thanks very much\" 总共有 6 个单词。\n所以，单个句子中有最多单词数的是第三个句子，总共有 6 个单词。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>sentences = [\"please wait\", <em><strong>\"continue to fight\"</strong></em>, <em><strong>\"continue to win\"</strong></em>]\n<b>输出：</b>3\n<b>解释：</b>可能有多个句子有相同单词数。\n这个例子中，第二个句子和第三个句子（加粗斜体）有相同数目的单词数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentences.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= sentences[i].length &lt;= 100</code></li>\n\t<li><code>sentences[i]</code>&nbsp;只包含小写英文字母和&nbsp;<code>' '</code>&nbsp;。</li>\n\t<li><code>sentences[i]</code>&nbsp;的开头和结尾都没有空格。</li>\n\t<li><code>sentences[i]</code>&nbsp;中所有单词由单个空格隔开。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2115从给定原材料中找到所有可以做出的菜",
        "hardRate": "MEDIUM",
        "passRate": "42.42%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-possible-recipes-from-given-supplies/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-possible-recipes-from-given-supplies/solution",
        "problemsDesc": "<p>你有 <code>n</code>&nbsp;道不同菜的信息。给你一个字符串数组&nbsp;<code>recipes</code>&nbsp;和一个二维字符串数组&nbsp;<code>ingredients</code>&nbsp;。第&nbsp;<code>i</code>&nbsp;道菜的名字为&nbsp;<code>recipes[i]</code>&nbsp;，如果你有它&nbsp;<strong>所有</strong>&nbsp;的原材料&nbsp;<code>ingredients[i]</code>&nbsp;，那么你可以&nbsp;<strong>做出</strong>&nbsp;这道菜。一道菜的原材料可能是&nbsp;<strong>另一道</strong>&nbsp;菜，也就是说&nbsp;<code>ingredients[i]</code>&nbsp;可能包含&nbsp;<code>recipes</code>&nbsp;中另一个字符串。</p>\n\n<p>同时给你一个字符串数组&nbsp;<code>supplies</code>&nbsp;，它包含你初始时拥有的所有原材料，每一种原材料你都有无限多。</p>\n\n<p>请你返回你可以做出的所有菜。你可以以 <strong>任意顺序</strong>&nbsp;返回它们。</p>\n\n<p>注意两道菜在它们的原材料中可能互相包含。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\n<b>输出：</b>[\"bread\"]\n<strong>解释：</strong>\n我们可以做出 \"bread\" ，因为我们有原材料 \"yeast\" 和 \"flour\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\n<b>输出：</b>[\"bread\",\"sandwich\"]\n<strong>解释：</strong>\n我们可以做出 \"bread\" ，因为我们有原材料 \"yeast\" 和 \"flour\" 。\n我们可以做出 \"sandwich\" ，因为我们有原材料 \"meat\" 且可以做出原材料 \"bread\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\n<b>输出：</b>[\"bread\",\"sandwich\",\"burger\"]\n<strong>解释：</strong>\n我们可以做出 \"bread\" ，因为我们有原材料 \"yeast\" 和 \"flour\" 。\n我们可以做出 \"sandwich\" ，因为我们有原材料 \"meat\" 且可以做出原材料 \"bread\" 。\n我们可以做出 \"burger\" ，因为我们有原材料 \"meat\" 且可以做出原材料 \"bread\" 和 \"sandwich\" 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><b>输入：</b>recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\"]\n<b>输出：</b>[]\n<strong>解释：</strong>\n我们没法做出任何菜，因为我们只有原材料 \"yeast\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == recipes.length == ingredients.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= ingredients[i].length, supplies.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= recipes[i].length, ingredients[i][j].length, supplies[k].length &lt;= 10</code></li>\n\t<li><code>recipes[i], ingredients[i][j]</code>&nbsp;和&nbsp;<code>supplies[k]</code>&nbsp;只包含小写英文字母。</li>\n\t<li>所有&nbsp;<code>recipes</code> 和&nbsp;<code>supplies</code>&nbsp;中的值互不相同。</li>\n\t<li><code>ingredients[i]</code>&nbsp;中的字符串互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2116判断一个括号字符串是否有效",
        "hardRate": "MEDIUM",
        "passRate": "32.03%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-a-parentheses-string-can-be-valid/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-a-parentheses-string-can-be-valid/solution",
        "problemsDesc": "<p>一个括号字符串是只由&nbsp;<code>'('</code> 和&nbsp;<code>')'</code>&nbsp;组成的&nbsp;<strong>非空</strong>&nbsp;字符串。如果一个字符串满足下面 <b>任意</b>&nbsp;一个条件，那么它就是有效的：</p>\n\n<ul>\n\t<li>字符串为&nbsp;<code>()</code>.</li>\n\t<li>它可以表示为 <code>AB</code><span style=\"\">（</span><code>A</code>&nbsp;与&nbsp;<code>B</code>&nbsp;连接），其中<code>A</code> 和&nbsp;<code>B</code>&nbsp;都是有效括号字符串。</li>\n\t<li>它可以表示为&nbsp;<code>(A)</code>&nbsp;，其中&nbsp;<code>A</code>&nbsp;是一个有效括号字符串。</li>\n</ul>\n\n<p>给你一个括号字符串&nbsp;<code>s</code>&nbsp;和一个字符串&nbsp;<code>locked</code>&nbsp;，两者长度都为&nbsp;<code>n</code>&nbsp;。<code>locked</code>&nbsp;是一个二进制字符串，只包含&nbsp;<code>'0'</code>&nbsp;和&nbsp;<code>'1'</code>&nbsp;。对于&nbsp;<code>locked</code>&nbsp;中&nbsp;<strong>每一个</strong>&nbsp;下标&nbsp;<code>i</code> ：</p>\n\n<ul>\n\t<li>如果&nbsp;<code>locked[i]</code>&nbsp;是&nbsp;<code>'1'</code>&nbsp;，你 <strong>不能</strong>&nbsp;改变&nbsp;<code>s[i]</code>&nbsp;。</li>\n\t<li>如果&nbsp;<code>locked[i]</code>&nbsp;是&nbsp;<code>'0'</code>&nbsp;，你&nbsp;<strong>可以</strong>&nbsp;将&nbsp;<code>s[i]</code>&nbsp;变为&nbsp;<code>'('</code>&nbsp;或者&nbsp;<code>')'</code>&nbsp;。</li>\n</ul>\n\n<p>如果你可以将 <code>s</code>&nbsp;变为有效括号字符串，请你返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/06/eg1.png\" style=\"width: 311px; height: 101px;\" /></p>\n\n<pre>\n<b>输入：</b>s = \"))()))\", locked = \"010100\"\n<b>输出：</b>true\n<b>解释：</b>locked[1] == '1' 和 locked[3] == '1' ，所以我们无法改变 s[1] 或者 s[3] 。\n我们可以将 s[0] 和 s[4] 变为 '(' ，不改变 s[2] 和 s[5] ，使 s 变为有效字符串。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"()()\", locked = \"0000\"\n<b>输出：</b>true\n<b>解释：</b>我们不需要做任何改变，因为 s 已经是有效字符串了。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \")\", locked = \"0\"\n<b>输出：</b>false\n<b>解释：</b>locked 允许改变 s[0] 。\n但无论将 s[0] 变为 '(' 或者 ')' 都无法使 s 变为有效字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == s.length == locked.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code>&nbsp;要么是&nbsp;<code>'('</code>&nbsp;要么是&nbsp;<code>')'</code>&nbsp;。</li>\n\t<li><code>locked[i]</code> 要么是&nbsp;<code>'0'</code>&nbsp;要么是&nbsp;<code>'1'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2117一个区间内所有数乘积的缩写",
        "hardRate": "HARD",
        "passRate": "30.79%",
        "problemsUrl": "https://leetcode.cn/problems/abbreviating-the-product-of-a-range/",
        "solutionsUrl": "https://leetcode.cn/problems/abbreviating-the-product-of-a-range/solution",
        "problemsDesc": "<p>给你两个正整数&nbsp;<code>left</code>&nbsp;和&nbsp;<code>right</code>&nbsp;，满足&nbsp;<code>left &lt;= right</code>&nbsp;。请你计算&nbsp;<strong>闭区间</strong>&nbsp;<code>[left, right]</code>&nbsp;中所有整数的&nbsp;<strong>乘积</strong>&nbsp;。</p>\n\n<p>由于乘积可能非常大，你需要将它按照以下步骤 <strong>缩写</strong>&nbsp;：</p>\n\n<ol>\n\t<li>统计乘积中&nbsp;<strong>后缀</strong> 0 的数目，并 <strong>移除</strong> 这些 0 ，将这个数目记为&nbsp;<code>C</code>&nbsp;。\n\n\t<ul>\n\t\t<li>比方说，<code>1000</code>&nbsp;中有 <code>3</code> 个后缀 0&nbsp;，<code>546</code>&nbsp;中没有后缀 0 。</li>\n\t</ul>\n\t</li>\n\t<li>将乘积中剩余数字的位数记为&nbsp;<code>d</code>&nbsp;。如果&nbsp;<code>d &gt; 10</code>&nbsp;，那么将乘积表示为&nbsp;<code>&lt;pre&gt;...&lt;suf&gt;</code>&nbsp;的形式，其中&nbsp;<code>&lt;pre&gt;</code>&nbsp;表示乘积最 <strong>开始</strong>&nbsp;的 <code>5</code>&nbsp;个数位，<code>&lt;suf&gt;</code>&nbsp;表示删除后缀 0 <strong>之后</strong>&nbsp;结尾的 <code>5</code>&nbsp;个数位。如果&nbsp;<code>d &lt;= 10</code>&nbsp;，我们不对它做修改。\n\t<ul>\n\t\t<li>比方说，我们将&nbsp;<code>1234567654321</code>&nbsp;表示为&nbsp;<code>12345...54321</code>&nbsp;，但是&nbsp;<code>1234567</code>&nbsp;仍然表示为&nbsp;<code>1234567</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n\t<li>最后，将乘积表示为 <strong>字符串</strong>&nbsp;<code>\"&lt;pre&gt;...&lt;suf&gt;eC\"</code>&nbsp;。\n\t<ul>\n\t\t<li>比方说，<code>12345678987600000</code>&nbsp;被表示为&nbsp;<code>\"12345...89876e5\"</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n</ol>\n\n<p>请你返回一个字符串，表示 <strong>闭区间</strong>&nbsp;<code>[left, right]</code>&nbsp;中所有整数&nbsp;<strong>乘积</strong>&nbsp;的&nbsp;<strong>缩写</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>left = 1, right = 4\n<b>输出：</b>\"24e0\"\n<strong>解释：</strong>\n乘积为 1 × 2 × 3 × 4 = 24 。\n由于没有后缀 0 ，所以 24 保持不变，缩写的结尾为 \"e0\" 。\n因为乘积的结果是 2 位数，小于 10 ，所欲我们不进一步将它缩写。\n所以，最终将乘积表示为 \"24e0\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>left = 2, right = 11\n<strong>输出：</strong>\"399168e2\"\n<strong>解释：</strong>乘积为 39916800 。\n有 2 个后缀 0 ，删除后得到 399168 。缩写的结尾为 \"e2\" 。 \n删除后缀 0 后是 6 位数，不需要进一步缩写。 \n所以，最终将乘积表示为 \"399168e2\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>left = 371, right = 375\n<strong>输出：</strong>\"7219856259e3\"\n<strong>解释：</strong>乘积为 7219856259000 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= left &lt;= right &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2118建立方程",
        "hardRate": "HARD",
        "passRate": "54.64%",
        "problemsUrl": "https://leetcode.cn/problems/build-the-equation/",
        "solutionsUrl": "https://leetcode.cn/problems/build-the-equation/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2119反转两次的数字",
        "hardRate": "EASY",
        "passRate": "73.68%",
        "problemsUrl": "https://leetcode.cn/problems/a-number-after-a-double-reversal/",
        "solutionsUrl": "https://leetcode.cn/problems/a-number-after-a-double-reversal/solution",
        "problemsDesc": "<p><strong>反转</strong> 一个整数意味着倒置它的所有位。</p>\n\n<ul>\n\t<li>例如，反转 <code>2021</code> 得到 <code>1202</code> 。反转 <code>12300</code> 得到 <code>321</code> ，<strong>不保留前导零</strong> 。</li>\n</ul>\n\n<p>给你一个整数 <code>num</code> ，<strong>反转</strong> <code>num</code> 得到 <code>reversed1</code> ，<strong>接着反转</strong> <code>reversed1</code> 得到 <code>reversed2</code> 。如果 <code>reversed2</code> 等于 <code>num</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 526\n<strong>输出：</strong>true\n<strong>解释：</strong>反转 num 得到 625 ，接着反转 625 得到 526 ，等于 num 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 1800\n<strong>输出：</strong>false\n<strong>解释：</strong>反转 num 得到 81 ，接着反转 81 得到 18 ，不等于 num 。 </pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = 0\n<strong>输出：</strong>true\n<strong>解释：</strong>反转 num 得到 0 ，接着反转 0 得到 0 ，等于 num 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2120执行所有后缀指令",
        "hardRate": "MEDIUM",
        "passRate": "82.47%",
        "problemsUrl": "https://leetcode.cn/problems/execution-of-all-suffix-instructions-staying-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/execution-of-all-suffix-instructions-staying-in-a-grid/solution",
        "problemsDesc": "<p>现有一个 <code>n x n</code> 大小的网格，左上角单元格坐标 <code>(0, 0)</code> ，右下角单元格坐标 <code>(n - 1, n - 1)</code> 。给你整数 <code>n</code> 和一个整数数组 <code>startPos</code> ，其中 <code>startPos = [start<sub>row</sub>, start<sub>col</sub>]</code> 表示机器人最开始在坐标为 <code>(start<sub>row</sub>, start<sub>col</sub>)</code> 的单元格上。</p>\n\n<p>另给你一个长度为 <code>m</code> 、下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，其中 <code>s[i]</code> 是对机器人的第 <code>i</code> 条指令：<code>'L'</code>（向左移动），<code>'R'</code>（向右移动），<code>'U'</code>（向上移动）和 <code>'D'</code>（向下移动）。</p>\n\n<p>机器人可以从 <code>s</code> 中的任一第 <code>i</code> 条指令开始执行。它将会逐条执行指令直到 <code>s</code> 的末尾，但在满足下述条件之一时，机器人将会停止：</p>\n\n<ul>\n\t<li>下一条指令将会导致机器人移动到网格外。</li>\n\t<li>没有指令可以执行。</li>\n</ul>\n\n<p>返回一个长度为 <code>m</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是机器人从第 <code>i</code>&nbsp;条指令 <strong>开始</strong>&nbsp;，可以执行的 <strong>指令数目</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/09/1.png\" style=\"width: 145px; height: 142px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 3, startPos = [0,1], s = \"RRDDLU\"\n<strong>输出：</strong>[1,5,4,3,1,0]\n<strong>解释：</strong>机器人从 startPos 出发，并从第 i 条指令开始执行：\n- 0: \"<em><strong>R</strong></em>RDDLU\" 在移动到网格外之前，只能执行一条 \"R\" 指令。\n- 1:  \"<em><strong>RDDLU</strong></em>\" 可以执行全部五条指令，机器人仍在网格内，最终到达 (0, 0) 。\n- 2:   \"<em><strong>DDLU</strong></em>\" 可以执行全部四条指令，机器人仍在网格内，最终到达 (0, 0) 。\n- 3:    \"<em><strong>DLU</strong></em>\" 可以执行全部三条指令，机器人仍在网格内，最终到达 (0, 0) 。\n- 4:     \"<em><strong>L</strong></em>U\" 在移动到网格外之前，只能执行一条 \"L\" 指令。\n- 5:      \"U\" 如果向上移动，将会移动到网格外。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/09/2.png\" style=\"width: 106px; height: 103px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 2, startPos = [1,1], s = \"LURD\"\n<strong>输出：</strong>[4,1,0,0]\n<strong>解释：</strong>\n- 0: \"<em><strong>LURD</strong></em>\"\n- 1:  \"<em><strong>U</strong></em>RD\"\n- 2:   \"RD\"\n- 3:    \"D\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/09/3.png\" style=\"width: 67px; height: 64px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 1, startPos = [0,0], s = \"LRUD\"\n<strong>输出：</strong>[0,0,0,0]\n<strong>解释：</strong>无论机器人从哪条指令开始执行，都会移动到网格外。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == s.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 500</code></li>\n\t<li><code>startPos.length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>row</sub>, start<sub>col</sub> &lt; n</code></li>\n\t<li><code>s</code> 由 <code>'L'</code>、<code>'R'</code>、<code>'U'</code> 和 <code>'D'</code> 组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2121相同元素的间隔之和",
        "hardRate": "MEDIUM",
        "passRate": "38.64%",
        "problemsUrl": "https://leetcode.cn/problems/intervals-between-identical-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/intervals-between-identical-elements/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、由 <code>n</code> 个整数组成的数组 <code>arr</code> 。</p>\n\n<p><code>arr</code> 中两个元素的 <strong>间隔</strong> 定义为它们下标之间的 <strong>绝对差</strong> 。更正式地，<code>arr[i]</code> 和 <code>arr[j]</code> 之间的间隔是 <code>|i - j|</code> 。</p>\n\n<p>返回一个长度为 <code>n</code> 的数组&nbsp;<code>intervals</code> ，其中 <code>intervals[i]</code> 是<em> </em><code>arr[i]</code><em> </em>和<em> </em><code>arr</code><em> </em>中每个相同元素（与 <code>arr[i]</code> 的值相同）的 <strong>间隔之和</strong> <em>。</em></p>\n\n<p><strong>注意：</strong><code>|x|</code> 是 <code>x</code> 的绝对值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,1,3,1,2,3,3]\n<strong>输出：</strong>[4,2,7,2,4,4,5]\n<strong>解释：</strong>\n- 下标 0 ：另一个 2 在下标 4 ，|0 - 4| = 4\n- 下标 1 ：另一个 1 在下标 3 ，|1 - 3| = 2\n- 下标 2 ：另两个 3 在下标 5 和 6 ，|2 - 5| + |2 - 6| = 7\n- 下标 3 ：另一个 1 在下标 1 ，|3 - 1| = 2\n- 下标 4 ：另一个 2 在下标 0 ，|4 - 0| = 4\n- 下标 5 ：另两个 3 在下标 2 和 6 ，|5 - 2| + |5 - 6| = 4\n- 下标 6 ：另两个 3 在下标 2 和 5 ，|6 - 2| + |6 - 5| = 5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [10,5,10,10]\n<strong>输出：</strong>[5,0,3,4]\n<strong>解释：</strong>\n- 下标 0 ：另两个 10 在下标 2 和 3 ，|0 - 2| + |0 - 3| = 5\n- 下标 1 ：只有这一个 5 在数组中，所以到相同元素的间隔之和是 0\n- 下标 2 ：另两个 10 在下标 0 和 3 ，|2 - 0| + |2 - 3| = 3\n- 下标 3 ：另两个 10 在下标 0 和 2 ，|3 - 0| + |3 - 2| = 4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == arr.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2122还原原数组",
        "hardRate": "HARD",
        "passRate": "42.00%",
        "problemsUrl": "https://leetcode.cn/problems/recover-the-original-array/",
        "solutionsUrl": "https://leetcode.cn/problems/recover-the-original-array/solution",
        "problemsDesc": "<p>Alice 有一个下标从 <strong>0</strong> 开始的数组 <code>arr</code> ，由 <code>n</code> 个正整数组成。她会选择一个任意的 <strong>正整数 </strong><code>k</code> 并按下述方式创建两个下标从 <strong>0</strong> 开始的新整数数组 <code>lower</code> 和 <code>higher</code> ：</p>\n\n<ol>\n\t<li>对每个满足 <code>0 &lt;= i &lt; n</code> 的下标 <code>i</code> ，<code>lower[i] = arr[i] - k</code></li>\n\t<li>对每个满足 <code>0 &lt;= i &lt; n</code> 的下标 <code>i</code> ，<code>higher[i] = arr[i] + k</code></li>\n</ol>\n\n<p>不幸地是，Alice 丢失了全部三个数组。但是，她记住了在数组 <code>lower</code> 和 <code>higher</code> 中出现的整数，但不知道每个整数属于哪个数组。请你帮助 Alice 还原原数组。</p>\n\n<p>给你一个由 2n 个整数组成的整数数组 <code>nums</code> ，其中 <strong>恰好</strong> <code>n</code> 个整数出现在 <code>lower</code> ，剩下的出现在 <code>higher</code> ，还原并返回 <strong>原数组</strong> <code>arr</code> 。如果出现答案不唯一的情况，返回 <strong>任一</strong> 有效数组。</p>\n\n<p><strong>注意：</strong>生成的测试用例保证存在 <strong>至少一个</strong> 有效数组 <code>arr</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,10,6,4,8,12]\n<strong>输出：</strong>[3,7,11]\n<strong>解释：</strong>\n如果 arr = [3,7,11] 且 k = 1 ，那么 lower = [2,6,10] 且 higher = [4,8,12] 。\n组合 lower 和 higher 得到 [2,6,10,4,8,12] ，这是 nums 的一个排列。\n另一个有效的数组是 arr = [5,7,9] 且 k = 3 。在这种情况下，lower = [2,4,6] 且 higher = [8,10,12] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,3,3]\n<strong>输出：</strong>[2,2]\n<strong>解释：</strong>\n如果 arr = [2,2] 且 k = 1 ，那么 lower = [1,1] 且 higher = [3,3] 。\n组合 lower 和 higher 得到 [1,1,3,3] ，这是 nums 的一个排列。\n注意，数组不能是 [1,3] ，因为在这种情况下，获得 [1,1,3,3] 唯一可行的方案是 k = 0 。\n这种方案是无效的，k 必须是一个正整数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,435]\n<strong>输出：</strong>[220]\n<strong>解释：</strong>\n唯一可行的组合是 arr = [220] 且 k = 215 。在这种情况下，lower = [5] 且 higher = [435] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 * n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>生成的测试用例保证存在 <strong>至少一个</strong> 有效数组 <code>arr</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2123使矩阵中的 1 互不相邻的最小操作数",
        "hardRate": "HARD",
        "passRate": "52.98%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-remove-adjacent-ones-in-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-remove-adjacent-ones-in-matrix/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2124检查是否所有 A 都在 B 之前",
        "hardRate": "EASY",
        "passRate": "69.21%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-all-as-appears-before-all-bs/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-all-as-appears-before-all-bs/solution",
        "problemsDesc": "<p>给你一个 <strong>仅</strong> 由字符 <code>'a'</code> 和 <code>'b'</code> 组成的字符串&nbsp; <code>s</code> 。如果字符串中 <strong>每个</strong> <em> </em><code>'a'</code> 都出现在 <strong>每个</strong><em> </em><code>'b'</code><em> </em>之前，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"aaabbb\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\n'a' 位于下标 0、1 和 2 ；而 'b' 位于下标 3、4 和 5 。\n因此，每个 'a' 都出现在每个 'b' 之前，所以返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abab\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\n存在一个 'a' 位于下标 2 ，而一个 'b' 位于下标 1 。\n因此，不能满足每个 'a' 都出现在每个 'b' 之前，所以返回 false 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = \"bbb\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\n不存在 'a' ，因此可以视作每个 'a' 都出现在每个 'b' 之前，所以返回 true 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s[i]</code> 为 <code>'a'</code> 或 <code>'b'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2125银行中的激光束数量",
        "hardRate": "MEDIUM",
        "passRate": "83.07%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-laser-beams-in-a-bank/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-laser-beams-in-a-bank/solution",
        "problemsDesc": "<p>银行内部的防盗安全装置已经激活。给你一个下标从 <strong>0</strong> 开始的二进制字符串数组 <code>bank</code> ，表示银行的平面图，这是一个大小为 <code>m x n</code> 的二维矩阵。 <code>bank[i]</code> 表示第 <code>i</code> 行的设备分布，由若干 <code>'0'</code> 和若干 <code>'1'</code> 组成。<code>'0'</code> 表示单元格是空的，而 <code>'1'</code> 表示单元格有一个安全设备。</p>\n\n<p>对任意两个安全设备而言，<strong>如果</strong><strong>同时</strong> 满足下面两个条件，则二者之间存在 <strong>一个</strong> 激光束：</p>\n\n<ul>\n\t<li>两个设备位于两个 <strong>不同行</strong> ：<code>r<sub>1</sub></code> 和 <code>r<sub>2</sub></code> ，其中 <code>r<sub>1</sub> &lt; r<sub>2</sub></code> 。</li>\n\t<li>满足&nbsp;<code>r<sub>1</sub> &lt; i &lt; r<sub>2</sub></code>&nbsp;的 <strong>所有&nbsp;</strong>行&nbsp;<code>i</code>&nbsp;，都&nbsp;<strong>没有安全设备</strong> 。</li>\n</ul>\n\n<p>激光束是独立的，也就是说，一个激光束既不会干扰另一个激光束，也不会与另一个激光束合并成一束。</p>\n\n<p>返回银行中激光束的总数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/24/laser1.jpg\" style=\"width: 400px; height: 368px;\" /></p>\n\n<pre>\n<strong>输入：</strong>bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\n<strong>输出：</strong>8\n<strong>解释：</strong>在下面每组设备对之间，存在一条激光束。总共是 8 条激光束：\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\n注意，第 0 行和第 3 行上的设备之间不存在激光束。\n这是因为第 2 行存在安全设备，这不满足第 2 个条件。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/24/laser2.jpg\" style=\"width: 244px; height: 325px;\" /></p>\n\n<pre>\n<strong>输入：</strong>bank = [\"000\",\"111\",\"000\"]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在两个位于不同行的设备\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == bank.length</code></li>\n\t<li><code>n == bank[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>bank[i][j]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2126摧毁小行星",
        "hardRate": "MEDIUM",
        "passRate": "48.83%",
        "problemsUrl": "https://leetcode.cn/problems/destroying-asteroids/",
        "solutionsUrl": "https://leetcode.cn/problems/destroying-asteroids/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>mass</code>&nbsp;，它表示一颗行星的初始质量。再给你一个整数数组&nbsp;<code>asteroids</code>&nbsp;，其中&nbsp;<code>asteroids[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;颗小行星的质量。</p>\n\n<p>你可以按 <strong>任意顺序</strong>&nbsp;重新安排小行星的顺序，然后让行星跟它们发生碰撞。如果行星碰撞时的质量 <strong>大于等于</strong>&nbsp;小行星的质量，那么小行星被 <strong>摧毁</strong>&nbsp;，并且行星会 <strong>获得</strong>&nbsp;这颗小行星的质量。否则，行星将被摧毁。</p>\n\n<p>如果所有小行星 <strong>都</strong>&nbsp;能被摧毁，请返回 <code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>mass = 10, asteroids = [3,9,19,5,21]\n<b>输出：</b>true\n<b>解释：</b>一种安排小行星的方式为 [9,19,5,3,21] ：\n- 行星与质量为 9 的小行星碰撞。新的行星质量为：10 + 9 = 19\n- 行星与质量为 19 的小行星碰撞。新的行星质量为：19 + 19 = 38\n- 行星与质量为 5 的小行星碰撞。新的行星质量为：38 + 5 = 43\n- 行星与质量为 3 的小行星碰撞。新的行星质量为：43 + 3 = 46\n- 行星与质量为 21 的小行星碰撞。新的行星质量为：46 + 21 = 67\n所有小行星都被摧毁。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>mass = 5, asteroids = [4,9,23,4]\n<b>输出：</b>false\n<b>解释：</b>\n行星无论如何没法获得足够质量去摧毁质量为 23 的小行星。\n行星把别的小行星摧毁后，质量为 5 + 4 + 9 + 4 = 22 。\n它比 23 小，所以无法摧毁最后一颗小行星。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= mass &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= asteroids.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= asteroids[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2127参加会议的最多员工数",
        "hardRate": "HARD",
        "passRate": "34.12%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/solution",
        "problemsDesc": "<p>一个公司准备组织一场会议，邀请名单上有&nbsp;<code>n</code>&nbsp;位员工。公司准备了一张 <strong>圆形</strong>&nbsp;的桌子，可以坐下 <strong>任意数目</strong>&nbsp;的员工。</p>\n\n<p>员工编号为 <code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;。每位员工都有一位 <strong>喜欢</strong>&nbsp;的员工，每位员工&nbsp;<strong>当且仅当</strong>&nbsp;他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工 <strong>不会</strong>&nbsp;是他自己。</p>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>favorite</code>&nbsp;，其中&nbsp;<code>favorite[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;位员工喜欢的员工。请你返回参加会议的&nbsp;<strong>最多员工数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/14/ex1.png\" style=\"width: 236px; height: 195px;\"></p>\n\n<pre><b>输入：</b>favorite = [2,2,1,2]\n<b>输出：</b>3\n<strong>解释：</strong>\n上图展示了公司邀请员工 0，1 和 2 参加会议以及他们在圆桌上的座位。\n没办法邀请所有员工参与会议，因为员工 2 没办法同时坐在 0，1 和 3 员工的旁边。\n注意，公司也可以邀请员工 1，2 和 3 参加会议。\n所以最多参加会议的员工数目为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>favorite = [1,2,0]\n<b>输出：</b>3\n<b>解释：</b>\n每个员工都至少是另一个员工喜欢的员工。所以公司邀请他们所有人参加会议的前提是所有人都参加了会议。\n座位安排同图 1 所示：\n- 员工 0 坐在员工 2 和 1 之间。\n- 员工 1 坐在员工 0 和 2 之间。\n- 员工 2 坐在员工 1 和 0 之间。\n参与会议的最多员工数目为 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/14/ex2.png\" style=\"width: 219px; height: 220px;\"></p>\n\n<pre><b>输入：</b>favorite = [3,0,1,4,1]\n<b>输出：</b>4\n<b>解释：</b>\n上图展示了公司可以邀请员工 0，1，3 和 4 参加会议以及他们在圆桌上的座位。\n员工 2 无法参加，因为他喜欢的员工 0 旁边的座位已经被占领了。\n所以公司只能不邀请员工 2 。\n参加会议的最多员工数目为 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == favorite.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= favorite[i] &lt;=&nbsp;n - 1</code></li>\n\t<li><code>favorite[i] != i</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2128通过翻转行或列来去除所有的 1",
        "hardRate": "MEDIUM",
        "passRate": "75.50%",
        "problemsUrl": "https://leetcode.cn/problems/remove-all-ones-with-row-and-column-flips/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-all-ones-with-row-and-column-flips/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2129将标题首字母大写",
        "hardRate": "EASY",
        "passRate": "60.69%",
        "problemsUrl": "https://leetcode.cn/problems/capitalize-the-title/",
        "solutionsUrl": "https://leetcode.cn/problems/capitalize-the-title/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>title</code>&nbsp;，它由单个空格连接一个或多个单词组成，每个单词都只包含英文字母。请你按以下规则将每个单词的首字母 <strong>大写</strong>&nbsp;：</p>\n\n<ul>\n\t<li>如果单词的长度为&nbsp;<code>1</code>&nbsp;或者&nbsp;<code>2</code>&nbsp;，所有字母变成小写。</li>\n\t<li>否则，将单词首字母大写，剩余字母变成小写。</li>\n</ul>\n\n<p>请你返回 <strong>大写后</strong>&nbsp;的<em>&nbsp;</em><code>title</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre><b>输入：</b>title = \"capiTalIze tHe titLe\"\n<b>输出：</b>\"Capitalize The Title\"\n<strong>解释：</strong>\n由于所有单词的长度都至少为 3 ，将每个单词首字母大写，剩余字母变为小写。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>title = \"First leTTeR of EACH Word\"\n<b>输出：</b>\"First Letter of Each Word\"\n<strong>解释：</strong>\n单词 \"of\" 长度为 2 ，所以它保持完全小写。\n其他单词长度都至少为 3 ，所以其他单词首字母大写，剩余字母小写。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>title = \"i lOve leetcode\"\n<b>输出：</b>\"i Love Leetcode\"\n<strong>解释：</strong>\n单词 \"i\" 长度为 1 ，所以它保留小写。\n其他单词长度都至少为 3 ，所以其他单词首字母大写，剩余字母小写。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= title.length &lt;= 100</code></li>\n\t<li><code>title</code>&nbsp;由单个空格隔开的单词组成，且不含有任何前导或后缀空格。</li>\n\t<li>每个单词由大写和小写英文字母组成，且都是 <strong>非空</strong>&nbsp;的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2130链表最大孪生和",
        "hardRate": "MEDIUM",
        "passRate": "80.33%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-twin-sum-of-a-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-twin-sum-of-a-linked-list/solution",
        "problemsDesc": "<p>在一个大小为&nbsp;<code>n</code>&nbsp;且 <code>n</code>&nbsp;为&nbsp;<strong>偶数</strong> 的链表中，对于&nbsp;<code>0 &lt;= i &lt;= (n / 2) - 1</code>&nbsp;的 <code>i</code>&nbsp;，第&nbsp;<code>i</code>&nbsp;个节点（下标从 <strong>0</strong>&nbsp;开始）的孪生节点为第&nbsp;<code>(n-1-i)</code>&nbsp;个节点 。</p>\n\n<ul>\n\t<li>比方说，<code>n = 4</code>&nbsp;那么节点&nbsp;<code>0</code>&nbsp;是节点 <code>3</code>&nbsp;的孪生节点，节点 <code>1</code>&nbsp;是节点 <code>2</code>&nbsp;的孪生节点。这是长度为 <code><span style=\"\">n = 4</span></code>&nbsp;的链表中所有的孪生节点。</li>\n</ul>\n\n<p><strong>孪生和</strong>&nbsp;定义为一个节点和它孪生节点两者值之和。</p>\n\n<p>给你一个长度为偶数的链表的头节点&nbsp;<code>head</code>&nbsp;，请你返回链表的 <strong>最大孪生和</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/03/eg1drawio.png\" style=\"width: 250px; height: 70px;\"></p>\n\n<pre><b>输入：</b>head = [5,4,2,1]\n<b>输出：</b>6\n<strong>解释：</strong>\n节点 0 和节点 1 分别是节点 3 和 2 的孪生节点。孪生和都为 6 。\n链表中没有其他孪生节点。\n所以，链表的最大孪生和是 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/03/eg2drawio.png\" style=\"width: 250px; height: 70px;\"></p>\n\n<pre><b>输入：</b>head = [4,2,2,3]\n<b>输出：</b>7\n<strong>解释：</strong>\n链表中的孪生节点为：\n- 节点 0 是节点 3 的孪生节点，孪生和为 4 + 3 = 7 。\n- 节点 1 是节点 2 的孪生节点，孪生和为 2 + 2 = 4 。\n所以，最大孪生和为 max(7, 4) = 7 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/03/eg3drawio.png\" style=\"width: 200px; height: 88px;\"></p>\n\n<pre><b>输入：</b>head = [1,100000]\n<b>输出：</b>100001\n<strong>解释：</strong>\n链表中只有一对孪生节点，孪生和为 1 + 100000 = 100001 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表的节点数目是&nbsp;<code>[2, 10<sup>5</sup>]</code>&nbsp;中的&nbsp;<strong>偶数</strong>&nbsp;。</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2131连接两字母单词得到的最长回文串",
        "hardRate": "MEDIUM",
        "passRate": "42.91%",
        "problemsUrl": "https://leetcode.cn/problems/longest-palindrome-by-concatenating-two-letter-words/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-palindrome-by-concatenating-two-letter-words/solution",
        "problemsDesc": "<p>给你一个字符串数组&nbsp;<code>words</code>&nbsp;。<code>words</code>&nbsp;中每个元素都是一个包含 <strong>两个</strong>&nbsp;小写英文字母的单词。</p>\n\n<p>请你从 <code>words</code>&nbsp;中选择一些元素并按 <b>任意顺序</b>&nbsp;连接它们，并得到一个 <strong>尽可能长的回文串</strong>&nbsp;。每个元素 <strong>至多</strong>&nbsp;只能使用一次。</p>\n\n<p>请你返回你能得到的最长回文串的 <strong>长度</strong>&nbsp;。如果没办法得到任何一个回文串，请你返回 <code>0</code>&nbsp;。</p>\n\n<p><strong>回文串</strong>&nbsp;指的是从前往后和从后往前读一样的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>words = [\"lc\",\"cl\",\"gg\"]\n<b>输出：</b>6\n<b>解释：</b>一个最长的回文串为 \"lc\" + \"gg\" + \"cl\" = \"lcggcl\" ，长度为 6 。\n\"clgglc\" 是另一个可以得到的最长回文串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>words = [\"ab\",\"ty\",\"yt\",\"lc\",\"cl\",\"ab\"]\n<b>输出：</b>8\n<strong>解释：</strong>最长回文串是 \"ty\" + \"lc\" + \"cl\" + \"yt\" = \"tylcclyt\" ，长度为 8 。\n\"lcyttycl\" 是另一个可以得到的最长回文串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>words = [\"cc\",\"ll\",\"xx\"]\n<b>输出：</b>2\n<b>解释：</b>最长回文串是 \"cc\" ，长度为 2 。\n\"ll\" 是另一个可以得到的最长回文串。\"xx\" 也是。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>words[i].length == 2</code></li>\n\t<li><code>words[i]</code>&nbsp;仅包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2132用邮票贴满网格图",
        "hardRate": "HARD",
        "passRate": "30.74%",
        "problemsUrl": "https://leetcode.cn/problems/stamping-the-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/stamping-the-grid/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的二进制矩阵&nbsp;<code>grid</code>&nbsp;，每个格子要么为&nbsp;<code>0</code>&nbsp;（空）要么为&nbsp;<code>1</code>&nbsp;（被占据）。</p>\n\n<p>给你邮票的尺寸为&nbsp;<code>stampHeight x stampWidth</code>&nbsp;。我们想将邮票贴进二进制矩阵中，且满足以下&nbsp;<strong>限制</strong>&nbsp;和&nbsp;<strong>要求</strong>&nbsp;：</p>\n\n<ol>\n\t<li>覆盖所有 <strong>空</strong>&nbsp;格子。</li>\n\t<li>不覆盖任何 <strong>被占据&nbsp;</strong>的格子。</li>\n\t<li>我们可以放入任意数目的邮票。</li>\n\t<li>邮票可以相互有 <strong>重叠</strong>&nbsp;部分。</li>\n\t<li>邮票不允许 <strong>旋转</strong>&nbsp;。</li>\n\t<li>邮票必须完全在矩阵 <strong>内</strong>&nbsp;。</li>\n</ol>\n\n<p>如果在满足上述要求的前提下，可以放入邮票，请返回&nbsp;<code>true</code>&nbsp;，否则返回<i>&nbsp;</i><code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/03/ex1.png\" style=\"width: 180px; height: 237px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3\n<b>输出：</b>true\n<b>解释：</b>我们放入两个有重叠部分的邮票（图中标号为 1 和 2），它们能覆盖所有与空格子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/03/ex2.png\" style=\"width: 170px; height: 179px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 \n<b>输出：</b>false \n<b>解释：</b>没办法放入邮票覆盖所有的空格子，且邮票不超出网格图以外。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[r].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>grid[r][c]</code> 要么是&nbsp;<code>0</code>&nbsp;，要么是&nbsp;<code>1</code> 。</li>\n\t<li><code>1 &lt;= stampHeight, stampWidth &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2133检查是否每一行每一列都包含全部整数",
        "hardRate": "EASY",
        "passRate": "55.66%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-every-row-and-column-contains-all-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-every-row-and-column-contains-all-numbers/solution",
        "problemsDesc": "<p>对一个大小为 <code>n x n</code> 的矩阵而言，如果其每一行和每一列都包含从 <code>1</code> 到 <code>n</code> 的 <strong>全部</strong> 整数（含 <code>1</code> 和 <code>n</code>），则认为该矩阵是一个 <strong>有效</strong> 矩阵。</p>\n\n<p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>matrix</code> ，请你判断矩阵是否为一个有效矩阵：如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/21/example1drawio.png\" style=\"width: 250px; height: 251px;\" /></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3],[3,1,2],[2,3,1]]\n<strong>输出：</strong>true\n<strong>解释：</strong>在此例中，n = 3 ，每一行和每一列都包含数字 1、2、3 。\n因此，返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/21/example2drawio.png\" style=\"width: 250px; height: 251px;\" /></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,1,1],[1,2,3],[1,2,3]]\n<strong>输出：</strong>false\n<strong>解释：</strong>在此例中，n = 3 ，但第一行和第一列不包含数字 2 和 3 。\n因此，返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == matrix.length == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= matrix[i][j] &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2134最少交换次数来组合所有的 1 II",
        "hardRate": "MEDIUM",
        "passRate": "48.79%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together-ii/solution",
        "problemsDesc": "<p><strong>交换</strong> 定义为选中一个数组中的两个 <strong>互不相同</strong> 的位置并交换二者的值。</p>\n\n<p><strong>环形</strong> 数组是一个数组，可以认为 <strong>第一个</strong> 元素和 <strong>最后一个</strong> 元素 <strong>相邻</strong> 。</p>\n\n<p>给你一个 <strong>二进制环形</strong> 数组 <code>nums</code> ，返回在 <strong>任意位置</strong> 将数组中的所有 <code>1</code> 聚集在一起需要的最少交换次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,0,1,1,0,0]\n<strong>输出：</strong>1\n<strong>解释：</strong>这里列出一些能够将所有 1 聚集在一起的方案：\n[0,<strong><em>0</em></strong>,<em><strong>1</strong></em>,1,1,0,0] 交换 1 次。\n[0,1,<em><strong>1</strong></em>,1,<em><strong>0</strong></em>,0,0] 交换 1 次。\n[1,1,0,0,0,0,1] 交换 2 次（利用数组的环形特性）。\n无法在交换 0 次的情况下将数组中的所有 1 聚集在一起。\n因此，需要的最少交换次数为 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,1,1,0,0,1,1,0]\n<strong>输出：</strong>2\n<strong>解释：</strong>这里列出一些能够将所有 1 聚集在一起的方案：\n[1,1,1,0,0,0,0,1,1] 交换 2 次（利用数组的环形特性）。\n[1,1,1,1,1,0,0,0,0] 交换 2 次。\n无法在交换 0 次或 1 次的情况下将数组中的所有 1 聚集在一起。\n因此，需要的最少交换次数为 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,0,0,1]\n<strong>输出：</strong>0\n<strong>解释：</strong>得益于数组的环形特性，所有的 1 已经聚集在一起。\n因此，需要的最少交换次数为 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> 为 <code>0</code> 或者 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2135统计追加字母可以获得的单词数",
        "hardRate": "MEDIUM",
        "passRate": "36.13%",
        "problemsUrl": "https://leetcode.cn/problems/count-words-obtained-after-adding-a-letter/",
        "solutionsUrl": "https://leetcode.cn/problems/count-words-obtained-after-adding-a-letter/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong> 开始的字符串数组 <code>startWords</code> 和 <code>targetWords</code> 。每个字符串都仅由 <strong>小写英文字母</strong> 组成。</p>\n\n<p>对于 <code>targetWords</code> 中的每个字符串，检查是否能够从 <code>startWords</code> 中选出一个字符串，执行一次 <strong>转换操作</strong>&nbsp;，得到的结果与当前&nbsp;<code>targetWords</code> 字符串相等。</p>\n\n<p><strong>转换操作</strong> 如下面两步所述：</p>\n\n<ol>\n\t<li><strong>追加</strong> 任何 <strong>不存在</strong> 于当前字符串的任一小写字母到当前字符串的末尾。\n\n\t<ul>\n\t\t<li>例如，如果字符串为 <code>\"abc\"</code> ，那么字母 <code>'d'</code>、<code>'e'</code> 或 <code>'y'</code> 都可以加到该字符串末尾，但 <code>'a'</code> 就不行。如果追加的是 <code>'d'</code> ，那么结果字符串为 <code>\"abcd\"</code> 。</li>\n\t</ul>\n\t</li>\n\t<li><strong>重排</strong> 新字符串中的字母，可以按 <strong>任意</strong> 顺序重新排布字母。\n\t<ul>\n\t\t<li>例如，<code>\"abcd\"</code> 可以重排为 <code>\"acbd\"</code>、<code>\"bacd\"</code>、<code>\"cbda\"</code>，以此类推。注意，它也可以重排为 <code>\"abcd\"</code> 自身。</li>\n\t</ul>\n\t</li>\n</ol>\n\n<p>找出 <code>targetWords</code> 中有多少字符串能够由&nbsp;<code>startWords</code> 中的 <strong>任一</strong> 字符串执行上述转换操作获得。返回<em> </em><code>targetWords</code><em> </em>中这类 <strong>字符串的数目</strong> 。</p>\n\n<p><strong>注意：</strong>你仅能验证 <code>targetWords</code> 中的字符串是否可以由 <code>startWords</code> 中的某个字符串经执行操作获得。<code>startWords</code>&nbsp; 中的字符串在这一过程中 <strong>不</strong> 发生实际变更。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>startWords = [\"ant\",\"act\",\"tack\"], targetWords = [\"tack\",\"act\",\"acti\"]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n- 为了形成 targetWords[0] = \"tack\" ，可以选用 startWords[1] = \"act\" ，追加字母 'k' ，并重排 \"actk\" 为 \"tack\" 。\n- startWords 中不存在可以用于获得 targetWords[1] = \"act\" 的字符串。\n  注意 \"act\" 确实存在于 startWords ，但是 <strong>必须</strong> 在重排前给这个字符串追加一个字母。\n- 为了形成 targetWords[2] = \"acti\" ，可以选用 startWords[1] = \"act\" ，追加字母 'i' ，并重排 \"acti\" 为 \"acti\" 自身。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>startWords = [\"ab\",\"a\"], targetWords = [\"abc\",\"abcd\"]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n- 为了形成 targetWords[0] = \"abc\" ，可以选用 startWords[0] = \"ab\" ，追加字母 'c' ，并重排为 \"abc\" 。\n- startWords 中不存在可以用于获得 targetWords[1] = \"abcd\" 的字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= startWords.length, targetWords.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= startWords[i].length, targetWords[j].length &lt;= 26</code></li>\n\t<li><code>startWords</code> 和 <code>targetWords</code> 中的每个字符串都仅由小写英文字母组成</li>\n\t<li>在 <code>startWords</code> 或 <code>targetWords</code> 的任一字符串中，每个字母至多出现一次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2136全部开花的最早一天",
        "hardRate": "HARD",
        "passRate": "66.05%",
        "problemsUrl": "https://leetcode.cn/problems/earliest-possible-day-of-full-bloom/",
        "solutionsUrl": "https://leetcode.cn/problems/earliest-possible-day-of-full-bloom/solution",
        "problemsDesc": "<p>你有 <code>n</code> 枚花的种子。每枚种子必须先种下，才能开始生长、开花。播种需要时间，种子的生长也是如此。给你两个下标从 <strong>0</strong> 开始的整数数组 <code>plantTime</code> 和 <code>growTime</code> ，每个数组的长度都是 <code>n</code> ：</p>\n\n<ul>\n\t<li><code>plantTime[i]</code> 是 <strong>播种</strong> 第 <code>i</code> 枚种子所需的 <strong>完整天数</strong> 。每天，你只能为播种某一枚种子而劳作。<strong>无须</strong> 连续几天都在种同一枚种子，但是种子播种必须在你工作的天数达到 <code>plantTime[i]</code> 之后才算完成。</li>\n\t<li><code>growTime[i]</code> 是第 <code>i</code> 枚种子完全种下后生长所需的 <strong>完整天数 </strong>。在它生长的最后一天 <strong>之后</strong> ，将会开花并且永远 <strong>绽放</strong> 。</li>\n</ul>\n\n<p>从第 <code>0</code> 开始，你可以按 <strong>任意</strong> 顺序播种种子。</p>\n\n<p>返回所有种子都开花的 <strong>最早</strong> 一天是第几天。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/21/1.png\" style=\"width: 453px; height: 149px;\">\n<pre><strong>输入：</strong>plantTime = [1,4,3], growTime = [2,3,1]\n<strong>输出：</strong>9\n<strong>解释：</strong>灰色的花盆表示播种的日子，彩色的花盆表示生长的日子，花朵表示开花的日子。\n一种最优方案是：\n第 0 天，播种第 0 枚种子，种子生长 2 整天。并在第 3 天开花。\n第 1、2、3、4 天，播种第 1 枚种子。种子生长 3 整天，并在第 8 天开花。\n第 5、6、7 天，播种第 2 枚种子。种子生长 1 整天，并在第 9 天开花。\n因此，在第 9 天，所有种子都开花。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/21/2.png\" style=\"width: 454px; height: 184px;\">\n<pre><strong>输入：</strong>plantTime = [1,2,3,2], growTime = [2,1,2,1]\n<strong>输出：</strong>9\n<strong>解释：</strong>灰色的花盆表示播种的日子，彩色的花盆表示生长的日子，花朵表示开花的日子。 \n一种最优方案是：\n第 1 天，播种第 0 枚种子，种子生长 2 整天。并在第 4 天开花。\n第 0、3 天，播种第 1 枚种子。种子生长 1 整天，并在第 5 天开花。\n第 2、4、5 天，播种第 2 枚种子。种子生长 2 整天，并在第 8 天开花。\n第 6、7 天，播种第 3 枚种子。种子生长 1 整天，并在第 9 天开花。\n因此，在第 9 天，所有种子都开花。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>plantTime = [1], growTime = [1]\n<strong>输出：</strong>2\n<strong>解释：</strong>第 0 天，播种第 0 枚种子。种子需要生长 1 整天，然后在第 2 天开花。\n因此，在第 2 天，所有种子都开花。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == plantTime.length == growTime.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= plantTime[i], growTime[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2137通过倒水操作让所有的水桶所含水量相等",
        "hardRate": "MEDIUM",
        "passRate": "64.72%",
        "problemsUrl": "https://leetcode.cn/problems/pour-water-between-buckets-to-make-water-levels-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/pour-water-between-buckets-to-make-water-levels-equal/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2138将字符串拆分为若干长度为 k 的组",
        "hardRate": "EASY",
        "passRate": "66.35%",
        "problemsUrl": "https://leetcode.cn/problems/divide-a-string-into-groups-of-size-k/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-a-string-into-groups-of-size-k/solution",
        "problemsDesc": "<p>字符串 <code>s</code> 可以按下述步骤划分为若干长度为 <code>k</code> 的组：</p>\n\n<ul>\n\t<li>第一组由字符串中的前 <code>k</code> 个字符组成，第二组由接下来的 <code>k</code> 个字符串组成，依此类推。每个字符都能够成为 <strong>某一个</strong> 组的一部分。</li>\n\t<li>对于最后一组，如果字符串剩下的字符 <strong>不足</strong> <code>k</code> 个，需使用字符 <code>fill</code> 来补全这一组字符。</li>\n</ul>\n\n<p>注意，在去除最后一个组的填充字符 <code>fill</code>（如果存在的话）并按顺序连接所有的组后，所得到的字符串应该是 <code>s</code> 。</p>\n\n<p>给你一个字符串 <code>s</code> ，以及每组的长度 <code>k</code> 和一个用于填充的字符 <code>fill</code> ，按上述步骤处理之后，返回一个字符串数组，该数组表示 <code>s</code> 分组后 <strong>每个组的组成情况</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abcdefghi\", k = 3, fill = \"x\"\n<strong>输出：</strong>[\"abc\",\"def\",\"ghi\"]\n<strong>解释：</strong>\n前 3 个字符是 \"abc\" ，形成第一组。\n接下来 3 个字符是 \"def\" ，形成第二组。\n最后 3 个字符是 \"ghi\" ，形成第三组。\n由于所有组都可以由字符串中的字符完全填充，所以不需要使用填充字符。\n因此，形成 3 组，分别是 \"abc\"、\"def\" 和 \"ghi\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abcdefghij\", k = 3, fill = \"x\"\n<strong>输出：</strong>[\"abc\",\"def\",\"ghi\",\"jxx\"]\n<strong>解释：</strong>\n与前一个例子类似，形成前三组 \"abc\"、\"def\" 和 \"ghi\" 。\n对于最后一组，字符串中仅剩下字符 'j' 可以用。为了补全这一组，使用填充字符 'x' 两次。\n因此，形成 4 组，分别是 \"abc\"、\"def\"、\"ghi\" 和 \"jxx\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n\t<li><code>fill</code> 是一个小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2139得到目标值的最少行动次数",
        "hardRate": "MEDIUM",
        "passRate": "51.47%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-moves-to-reach-target-score/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-moves-to-reach-target-score/solution",
        "problemsDesc": "<p>你正在玩一个整数游戏。从整数 <code>1</code> 开始，期望得到整数 <code>target</code> 。</p>\n\n<p>在一次行动中，你可以做下述两种操作之一：</p>\n\n<ul>\n\t<li><strong>递增</strong>，将当前整数的值加 1（即， <code>x = x + 1</code>）。</li>\n\t<li><strong>加倍</strong>，使当前整数的值翻倍（即，<code>x = 2 * x</code>）。</li>\n</ul>\n\n<p>在整个游戏过程中，你可以使用 <strong>递增</strong> 操作 <strong>任意</strong> 次数。但是只能使用 <strong>加倍</strong> 操作 <strong>至多</strong> <code>maxDoubles</code> 次。</p>\n\n<p>给你两个整数 <code>target</code> 和 <code>maxDoubles</code> ，返回从 1 开始得到<em> </em><code>target</code><em> </em>需要的最少行动次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>target = 5, maxDoubles = 0\n<strong>输出：</strong>4\n<strong>解释：</strong>一直递增 1 直到得到 target 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>target = 19, maxDoubles = 2\n<strong>输出：</strong>7\n<strong>解释：</strong>最初，x = 1 。\n递增 3 次，x = 4 。\n加倍 1 次，x = 8 。\n递增 1 次，x = 9 。\n加倍 1 次，x = 18 。\n递增 1 次，x = 19 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>target = 10, maxDoubles = 4\n<strong>输出：</strong>4\n<strong>解释：</strong>\n最初，x = 1 。 \n递增 1 次，x = 2 。 \n加倍 1 次，x = 4 。 \n递增 1 次，x = 5 。 \n加倍 1 次，x = 10 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= maxDoubles &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2140解决智力问题",
        "hardRate": "MEDIUM",
        "passRate": "43.93%",
        "problemsUrl": "https://leetcode.cn/problems/solving-questions-with-brainpower/",
        "solutionsUrl": "https://leetcode.cn/problems/solving-questions-with-brainpower/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>questions</code>&nbsp;，其中&nbsp;<code>questions[i] = [points<sub>i</sub>, brainpower<sub>i</sub>]</code>&nbsp;。</p>\n\n<p>这个数组表示一场考试里的一系列题目，你需要 <strong>按顺序</strong>&nbsp;（也就是从问题 <code>0</code><strong>&nbsp;</strong>开始依次解决），针对每个问题选择 <strong>解决</strong>&nbsp;或者 <strong>跳过</strong>&nbsp;操作。解决问题 <code>i</code>&nbsp;将让你 <b>获得</b>&nbsp;&nbsp;<code>points<sub>i</sub></code>&nbsp;的分数，但是你将 <strong>无法</strong>&nbsp;解决接下来的&nbsp;<code>brainpower<sub>i</sub></code>&nbsp;个问题（即只能跳过接下来的 <code>brainpower<sub>i</sub></code><sub>&nbsp;</sub>个问题）。如果你跳过问题&nbsp;<code>i</code>&nbsp;，你可以对下一个问题决定使用哪种操作。</p>\n\n<ul>\n\t<li>比方说，给你&nbsp;<code>questions = [[3, 2], [4, 3], [4, 4], [2, 5]]</code>&nbsp;：\n\n\t<ul>\n\t\t<li>如果问题&nbsp;<code>0</code>&nbsp;被解决了， 那么你可以获得&nbsp;<code>3</code>&nbsp;分，但你不能解决问题&nbsp;<code>1</code> 和&nbsp;<code>2</code>&nbsp;。</li>\n\t\t<li>如果你跳过问题&nbsp;<code>0</code>&nbsp;，且解决问题&nbsp;<code>1</code>&nbsp;，你将获得 <code>4</code> 分但是不能解决问题&nbsp;<code>2</code> 和&nbsp;<code>3</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回这场考试里你能获得的 <strong>最高</strong>&nbsp;分数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>questions = [[3,2],[4,3],[4,4],[2,5]]\n<b>输出：</b>5\n<b>解释：</b>解决问题 0 和 3 得到最高分。\n- 解决问题 0 ：获得 3 分，但接下来 2 个问题都不能解决。\n- 不能解决问题 1 和 2\n- 解决问题 3 ：获得 2 分\n总得分为：3 + 2 = 5 。没有别的办法获得 5 分或者多于 5 分。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]\n<b>输出：</b>7\n<b>解释：</b>解决问题 1 和 4 得到最高分。\n- 跳过问题 0\n- 解决问题 1 ：获得 2 分，但接下来 2 个问题都不能解决。\n- 不能解决问题 2 和 3\n- 解决问题 4 ：获得 5 分\n总得分为：2 + 5 = 7 。没有别的办法获得 7 分或者多于 7 分。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= questions.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>questions[i].length == 2</code></li>\n\t<li><code>1 &lt;= points<sub>i</sub>, brainpower<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2141同时运行 N 台电脑的最长时间",
        "hardRate": "HARD",
        "passRate": "40.58%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-running-time-of-n-computers/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-running-time-of-n-computers/solution",
        "problemsDesc": "<p>你有&nbsp;<code>n</code>&nbsp;台电脑。给你整数&nbsp;<code>n</code>&nbsp;和一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>batteries</code>&nbsp;，其中第&nbsp;<code>i</code>&nbsp;个电池可以让一台电脑 <strong>运行&nbsp;</strong><code>batteries[i]</code>&nbsp;分钟。你想使用这些电池让&nbsp;<strong>全部</strong>&nbsp;<code>n</code>&nbsp;台电脑 <b>同时</b>&nbsp;运行。</p>\n\n<p>一开始，你可以给每台电脑连接 <strong>至多一个电池</strong>&nbsp;。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 <strong>任意次</strong>&nbsp;。新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。</p>\n\n<p>注意，你不能给电池充电。</p>\n\n<p>请你返回你可以让 <code>n</code>&nbsp;台电脑同时运行的 <strong>最长</strong>&nbsp;分钟数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/01/06/example1-fit.png\" style=\"width: 762px; height: 150px;\"></p>\n\n<pre><b>输入：</b>n = 2, batteries = [3,3,3]\n<b>输出：</b>4\n<b>解释：</b>\n一开始，将第一台电脑与电池 0 连接，第二台电脑与电池 1 连接。\n2 分钟后，将第二台电脑与电池 1 断开连接，并连接电池 2 。注意，电池 0 还可以供电 1 分钟。\n在第 3 分钟结尾，你需要将第一台电脑与电池 0 断开连接，然后连接电池 1 。\n在第 4 分钟结尾，电池 1 也被耗尽，第一台电脑无法继续运行。\n我们最多能同时让两台电脑同时运行 4 分钟，所以我们返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/01/06/example2.png\" style=\"width: 629px; height: 150px;\"></p>\n\n<pre><b>输入：</b>n = 2, batteries = [1,1,1,1]\n<b>输出：</b>2\n<b>解释：</b>\n一开始，将第一台电脑与电池 0 连接，第二台电脑与电池 2 连接。\n一分钟后，电池 0 和电池 2 同时耗尽，所以你需要将它们断开连接，并将电池 1 和第一台电脑连接，电池 3 和第二台电脑连接。\n1 分钟后，电池 1 和电池 3 也耗尽了，所以两台电脑都无法继续运行。\n我们最多能让两台电脑同时运行 2 分钟，所以我们返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= batteries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= batteries[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2142每辆车的乘客人数 I",
        "hardRate": "MEDIUM",
        "passRate": "46.63%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-passengers-in-each-bus-i/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-passengers-in-each-bus-i/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2143在两个数组的区间中选取数字",
        "hardRate": "HARD",
        "passRate": "57.14%",
        "problemsUrl": "https://leetcode.cn/problems/choose-numbers-from-two-arrays-in-range/",
        "solutionsUrl": "https://leetcode.cn/problems/choose-numbers-from-two-arrays-in-range/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2144打折购买糖果的最小开销",
        "hardRate": "EASY",
        "passRate": "66.91%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-of-buying-candies-with-discount/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-of-buying-candies-with-discount/solution",
        "problemsDesc": "<p>一家商店正在打折销售糖果。每购买 <strong>两个</strong>&nbsp;糖果，商店会 <strong>免费</strong>&nbsp;送一个糖果。</p>\n\n<p>免费送的糖果唯一的限制是：它的价格需要小于等于购买的两个糖果价格的 <strong>较小值</strong>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，总共有 <code>4</code>&nbsp;个糖果，价格分别为&nbsp;<code>1</code>&nbsp;，<code>2</code>&nbsp;，<code>3</code>&nbsp;和&nbsp;<code>4</code>&nbsp;，一位顾客买了价格为&nbsp;<code>2</code> 和&nbsp;<code>3</code>&nbsp;的糖果，那么他可以免费获得价格为 <code>1</code>&nbsp;的糖果，但不能获得价格为&nbsp;<code>4</code>&nbsp;的糖果。</li>\n</ul>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>cost</code>&nbsp;，其中&nbsp;<code>cost[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个糖果的价格，请你返回获得 <strong>所有</strong>&nbsp;糖果的 <strong>最小</strong>&nbsp;总开销。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>cost = [1,2,3]\n<b>输出：</b>5\n<b>解释：</b>我们购买价格为 2 和 3 的糖果，然后免费获得价格为 1 的糖果。\n总开销为 2 + 3 = 5 。这是开销最小的 <strong>唯一</strong>&nbsp;方案。\n注意，我们不能购买价格为 1 和 3 的糖果，并免费获得价格为 2 的糖果。\n这是因为免费糖果的价格必须小于等于购买的 2 个糖果价格的较小值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>cost = [6,5,7,9,2,2]\n<b>输出：</b>23\n<b>解释：</b>最小总开销购买糖果方案为：\n- 购买价格为 9 和 7 的糖果\n- 免费获得价格为 6 的糖果\n- 购买价格为 5 和 2 的糖果\n- 免费获得价格为 2 的最后一个糖果\n因此，最小总开销为 9 + 7 + 5 + 2 = 23 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>cost = [5,5]\n<b>输出：</b>10\n<b>解释：</b>由于只有 2 个糖果，我们需要将它们都购买，而且没有免费糖果。\n所以总最小开销为 5 + 5 = 10 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= cost.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= cost[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2145统计隐藏数组数目",
        "hardRate": "MEDIUM",
        "passRate": "35.82%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-hidden-sequences/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-hidden-sequences/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始且长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>differences</code>&nbsp;，它表示一个长度为&nbsp;<code>n + 1</code>&nbsp;的&nbsp;<strong>隐藏</strong>&nbsp;数组&nbsp;<strong>相邻</strong>&nbsp;元素之间的&nbsp;<strong>差值</strong>&nbsp;。更正式的表述为：我们将隐藏数组记作&nbsp;<code>hidden</code>&nbsp;，那么&nbsp;<code>differences[i] = hidden[i + 1] - hidden[i]</code>&nbsp;。</p>\n\n<p>同时给你两个整数&nbsp;<code>lower</code> 和&nbsp;<code>upper</code>&nbsp;，它们表示隐藏数组中所有数字的值都在 <strong>闭</strong>&nbsp;区间&nbsp;<code>[lower, upper]</code>&nbsp;之间。</p>\n\n<ul>\n\t<li>比方说，<code>differences = [1, -3, 4]</code>&nbsp;，<code>lower = 1</code>&nbsp;，<code>upper = 6</code>&nbsp;，那么隐藏数组是一个长度为 <code>4</code>&nbsp;且所有值都在&nbsp;<code>1</code>&nbsp;和&nbsp;<code>6</code>&nbsp;（包含两者）之间的数组。\n\n\t<ul>\n\t\t<li><code>[3, 4, 1, 5]</code> 和&nbsp;<code>[4, 5, 2, 6]</code>&nbsp;都是符合要求的隐藏数组。</li>\n\t\t<li><code>[5, 6, 3, 7]</code>&nbsp;不符合要求，因为它包含大于 <code>6</code>&nbsp;的元素。</li>\n\t\t<li><code>[1, 2, 3, 4]</code>&nbsp;不符合要求，因为相邻元素的差值不符合给定数据。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回 <strong>符合</strong>&nbsp;要求的隐藏数组的数目。如果没有符合要求的隐藏数组，请返回 <code>0</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>differences = [1,-3,4], lower = 1, upper = 6\n<b>输出：</b>2\n<b>解释：</b>符合要求的隐藏数组为：\n- [3, 4, 1, 5]\n- [4, 5, 2, 6]\n所以返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>differences = [3,-4,5,1,-2], lower = -4, upper = 5\n<b>输出：</b>4\n<b>解释：</b>符合要求的隐藏数组为：\n- [-3, 0, -4, 1, 2, 0]\n- [-2, 1, -3, 2, 3, 1]\n- [-1, 2, -2, 3, 4, 2]\n- [0, 3, -1, 4, 5, 3]\n所以返回 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>differences = [4,-7,2], lower = 3, upper = 6\n<b>输出：</b>0\n<b>解释：</b>没有符合要求的隐藏数组，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == differences.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= differences[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= lower &lt;= upper &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2146价格范围内最高排名的 K 样物品",
        "hardRate": "MEDIUM",
        "passRate": "40.13%",
        "problemsUrl": "https://leetcode.cn/problems/k-highest-ranked-items-within-a-price-range/",
        "solutionsUrl": "https://leetcode.cn/problems/k-highest-ranked-items-within-a-price-range/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>grid</code>&nbsp;，它的大小为&nbsp;<code>m x n</code>&nbsp;，表示一个商店中物品的分布图。数组中的整数含义为：</p>\n\n<ul>\n\t<li><code>0</code>&nbsp;表示无法穿越的一堵墙。</li>\n\t<li><code>1</code>&nbsp;表示可以自由通过的一个空格子。</li>\n\t<li>所有其他正整数表示该格子内的一样物品的价格。你可以自由经过这些格子。</li>\n</ul>\n\n<p>从一个格子走到上下左右相邻格子花费&nbsp;<code>1</code>&nbsp;步。</p>\n\n<p>同时给你一个整数数组&nbsp;<code>pricing</code> 和&nbsp;<code>start</code>&nbsp;，其中&nbsp;<code>pricing = [low, high]</code> 且&nbsp;<code>start = [row, col]</code>&nbsp;，表示你开始位置为&nbsp;<code>(row, col)</code>&nbsp;，同时你只对物品价格在<strong>&nbsp;闭区间</strong>&nbsp;<code>[low, high]</code>&nbsp;之内的物品感兴趣。同时给你一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>你想知道给定范围 <strong>内</strong>&nbsp;且 <strong>排名最高</strong>&nbsp;的 <code>k</code>&nbsp;件物品的 <strong>位置</strong>&nbsp;。排名按照优先级从高到低的以下规则制定：</p>\n\n<ol>\n\t<li>距离：定义为从&nbsp;<code>start</code>&nbsp;到一件物品的最短路径需要的步数（<strong>较近</strong>&nbsp;距离的排名更高）。</li>\n\t<li>价格：<strong>较低</strong>&nbsp;价格的物品有更高优先级，但只考虑在给定范围之内的价格。</li>\n\t<li>行坐标：<strong>较小</strong>&nbsp;行坐标的有更高优先级。</li>\n\t<li>列坐标：<strong>较小</strong>&nbsp;列坐标的有更高优先级。</li>\n</ol>\n\n<p>请你返回给定价格内排名最高的 <code>k</code>&nbsp;件物品的坐标，将它们按照排名排序后返回。如果给定价格内少于 <code>k</code>&nbsp;件物品，那么请将它们的坐标&nbsp;<strong>全部</strong>&nbsp;返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/16/example1drawio.png\" style=\"width: 200px; height: 151px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,2,0,1],[1,3,0,1],[0,2,5,1]], pricing = [2,5], start = [0,0], k = 3\n<b>输出：</b>[[0,1],[1,1],[2,1]]\n<b>解释：</b>起点为 (0,0) 。\n价格范围为 [2,5] ，我们可以选择的物品坐标为 (0,1)，(1,1)，(2,1) 和 (2,2) 。\n这些物品的排名为：\n- (0,1) 距离为 1\n- (1,1) 距离为 2\n- (2,1) 距离为 3\n- (2,2) 距离为 4\n所以，给定价格范围内排名最高的 3 件物品的坐标为 (0,1)，(1,1) 和 (2,1) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/16/example2drawio1.png\" style=\"width: 200px; height: 151px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,2,0,1],[1,3,3,1],[0,2,5,1]], pricing = [2,3], start = [2,3], k = 2\n<b>输出：</b>[[2,1],[1,2]]\n<b>解释：</b>起点为 (2,3) 。\n价格范围为 [2,3] ，我们可以选择的物品坐标为 (0,1)，(1,1)，(1,2) 和 (2,1) 。\n这些物品的排名为： \n- (2,1) 距离为 2 ，价格为 2\n- (1,2) 距离为 2 ，价格为 3\n- (1,1) 距离为 3\n- (0,1) 距离为 4\n所以，给定价格范围内排名最高的 2 件物品的坐标为 (2,1) 和 (1,2) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/30/example3.png\" style=\"width: 149px; height: 150px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,1,1],[0,0,1],[2,3,4]], pricing = [2,3], start = [0,0], k = 3\n<b>输出：</b>[[2,1],[2,0]]\n<b>解释：</b>起点为 (0,0) 。\n价格范围为 [2,3] ，我们可以选择的物品坐标为 (2,0) 和 (2,1) 。\n这些物品的排名为：\n- (2,1) 距离为 5\n- (2,0) 距离为 6\n所以，给定价格范围内排名最高的 2 件物品的坐标为 (2,1) 和 (2,0) 。\n注意，k = 3 但给定价格范围内只有 2 件物品。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pricing.length == 2</code></li>\n\t<li><code>2 &lt;= low &lt;= high &lt;= 10<sup>5</sup></code></li>\n\t<li><code>start.length == 2</code></li>\n\t<li><code>0 &lt;= row &lt;= m - 1</code></li>\n\t<li><code>0 &lt;= col &lt;= n - 1</code></li>\n\t<li><code>grid[row][col] &gt; 0</code></li>\n\t<li><code>1 &lt;= k &lt;= m * n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2147分隔长廊的方案数",
        "hardRate": "HARD",
        "passRate": "41.48%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-divide-a-long-corridor/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-divide-a-long-corridor/solution",
        "problemsDesc": "<p>在一个图书馆的长廊里，有一些座位和装饰植物排成一列。给你一个下标从 <strong>0</strong>&nbsp;开始，长度为 <code>n</code>&nbsp;的字符串&nbsp;<code>corridor</code>&nbsp;，它包含字母&nbsp;<code>'S'</code> 和&nbsp;<code>'P'</code>&nbsp;，其中每个&nbsp;<code>'S'</code>&nbsp;表示一个座位，每个&nbsp;<code>'P'</code>&nbsp;表示一株植物。</p>\n\n<p>在下标 <code>0</code>&nbsp;的左边和下标 <code>n - 1</code>&nbsp;的右边 <strong>已经</strong>&nbsp;分别各放了一个屏风。你还需要额外放置一些屏风。每一个位置&nbsp;<code>i - 1</code> 和&nbsp;<code>i</code>&nbsp;之间（<code>1 &lt;= i &lt;= n - 1</code>），至多能放一个屏风。</p>\n\n<p>请你将走廊用屏风划分为若干段，且每一段内都 <strong>恰好有两个座位</strong>&nbsp;，而每一段内植物的数目没有要求。可能有多种划分方案，如果两个方案中有任何一个屏风的位置不同，那么它们被视为 <strong>不同</strong> 方案。</p>\n\n<p>请你返回划分走廊的方案数。由于答案可能很大，请你返回它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;的结果。如果没有任何方案，请返回&nbsp;<code>0</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/04/1.png\" style=\"width: 410px; height: 199px;\"></p>\n\n<pre><b>输入：</b>corridor = \"SSPPSPS\"\n<b>输出：</b>3\n<b>解释：</b>总共有 3 种不同分隔走廊的方案。\n上图中黑色的竖线表示已经放置好的屏风。\n上图每种方案中，每一段都恰好有 <strong>两个</strong>&nbsp;座位。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/04/2.png\" style=\"width: 357px; height: 68px;\"></p>\n\n<pre><b>输入：</b>corridor = \"PPSPSP\"\n<b>输出：</b>1\n<b>解释：</b>只有 1 种分隔走廊的方案，就是不放置任何屏风。\n放置任何的屏风都会导致有一段无法恰好有 2 个座位。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/12/3.png\" style=\"width: 115px; height: 68px;\"></p>\n\n<pre><b>输入：</b>corridor = \"S\"\n<b>输出：</b>0\n<b>解释：</b>没有任何方案，因为总是有一段无法恰好有 2 个座位。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == corridor.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>corridor[i]</code>&nbsp;要么是&nbsp;<code>'S'</code>&nbsp;，要么是&nbsp;<code>'P'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2148元素计数",
        "hardRate": "EASY",
        "passRate": "57.79%",
        "problemsUrl": "https://leetcode.cn/problems/count-elements-with-strictly-smaller-and-greater-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/count-elements-with-strictly-smaller-and-greater-elements/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，统计并返回在 <code>nums</code> 中同时至少具有一个严格较小元素和一个严格较大元素的元素数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [11,7,2,15]\n<strong>输出：</strong>2\n<strong>解释：</strong>元素 7 ：严格较小元素是元素 2 ，严格较大元素是元素 11 。\n元素 11 ：严格较小元素是元素 7 ，严格较大元素是元素 15 。\n总计有 2 个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-3,3,3,90]\n<strong>输出：</strong>2\n<strong>解释：</strong>元素 3 ：严格较小元素是元素 -3 ，严格较大元素是元素 90 。\n由于有两个元素的值为 3 ，总计有 2 个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2149按符号重排数组",
        "hardRate": "MEDIUM",
        "passRate": "79.71%",
        "problemsUrl": "https://leetcode.cn/problems/rearrange-array-elements-by-sign/",
        "solutionsUrl": "https://leetcode.cn/problems/rearrange-array-elements-by-sign/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，数组长度为 <strong>偶数</strong> ，由数目相等的正整数和负整数组成。</p>\n\n<p>你需要 <strong>重排</strong> <code>nums</code> 中的元素，使修改后的数组满足下述条件：</p>\n\n<ol>\n\t<li>任意&nbsp;<strong>连续</strong> 的两个整数 <strong>符号相反</strong></li>\n\t<li>对于符号相同的所有整数，<strong>保留</strong> 它们在 <code>nums</code> 中的 <strong>顺序</strong> 。</li>\n\t<li>重排后数组以正整数开头。</li>\n</ol>\n\n<p>重排元素满足上述条件后，返回修改后的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,1,-2,-5,2,-4]\n<strong>输出：</strong>[3,-2,1,-5,2,-4]\n<strong>解释：</strong>\nnums 中的正整数是 [3,1,2] ，负整数是 [-2,-5,-4] 。\n重排的唯一可行方案是 [3,-2,1,-5,2,-4]，能满足所有条件。\n像 [1,-2,2,-5,3,-4]、[3,1,2,-2,-5,-4]、[-2,3,-5,1,-4,2] 这样的其他方案是不正确的，因为不满足一个或者多个条件。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,1]\n<strong>输出：</strong>[1,-1]\n<strong>解释：</strong>\n1 是 nums 中唯一一个正整数，-1 是 nums 中唯一一个负整数。\n所以 nums 重排为 [1,-1] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>nums.length</code> 是 <strong>偶数</strong></li>\n\t<li><code>1 &lt;= |nums[i]| &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums</code> 由 <strong>相等</strong> 数量的正整数和负整数组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2150找出数组中的所有孤独数字",
        "hardRate": "MEDIUM",
        "passRate": "59.58%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-lonely-numbers-in-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-lonely-numbers-in-the-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。如果数字 <code>x</code> 在数组中仅出现 <strong>一次</strong> ，且没有 <strong>相邻</strong> 数字（即，<code>x + 1</code> 和 <code>x - 1</code>）出现在数组中，则认为数字 <code>x</code> 是 <strong>孤独数字</strong> 。</p>\n\n<p>返回<em> </em><code>nums</code> 中的 <strong>所有</strong> 孤独数字。你可以按 <strong>任何顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [10,6,5,8]\n<strong>输出：</strong>[10,8]\n<strong>解释：</strong>\n- 10 是一个孤独数字，因为它只出现一次，并且 9 和 11 没有在 nums 中出现。\n- 8 是一个孤独数字，因为它只出现一次，并且 7 和 9 没有在 nums 中出现。\n- 5 不是一个孤独数字，因为 6 出现在 nums 中，反之亦然。\n因此，nums 中的孤独数字是 [10, 8] 。\n注意，也可以返回 [8, 10] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3,5,3]\n<strong>输出：</strong>[1,5]\n<strong>解释：</strong>\n- 1 是一个孤独数字，因为它只出现一次，并且 0 和 2 没有在 nums 中出现。\n- 5 是一个孤独数字，因为它只出现一次，并且 4 和 6 没有在 nums 中出现。\n- 3 不是一个孤独数字，因为它出现两次。\n因此，nums 中的孤独数字是 [1, 5] 。\n注意，也可以返回 [5, 1] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2151基于陈述统计最多好人数",
        "hardRate": "HARD",
        "passRate": "50.34%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-good-people-based-on-statements/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-good-people-based-on-statements/solution",
        "problemsDesc": "<p>游戏中存在两种角色：</p>\n\n<ul>\n\t<li><strong>好人</strong>：该角色只说真话。</li>\n\t<li><strong>坏人</strong>：该角色可能说真话，也可能说假话。</li>\n</ul>\n\n<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>statements</code> ，大小为 <code>n x n</code> ，表示 <code>n</code> 个玩家对彼此角色的陈述。具体来说，<code>statements[i][j]</code> 可以是下述值之一：</p>\n\n<ul>\n\t<li><code>0</code> 表示 <code>i</code> 的陈述认为 <code>j</code> 是 <strong>坏人</strong> 。</li>\n\t<li><code>1</code> 表示 <code>i</code> 的陈述认为 <code>j</code> 是 <strong>好人</strong> 。</li>\n\t<li><code>2</code> 表示 <code>i</code> 没有对 <code>j</code> 作出陈述。</li>\n</ul>\n\n<p>另外，玩家不会对自己进行陈述。形式上，对所有&nbsp;<code>0 &lt;= i &lt; n</code> ，都有 <code>statements[i][i] = 2</code> 。</p>\n\n<p>根据这 <code>n</code> 个玩家的陈述，返回可以认为是 <strong>好人</strong> 的 <strong>最大</strong> 数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/01/15/logic1.jpg\" style=\"width: 600px; height: 262px;\">\n<pre><strong>输入：</strong>statements = [[2,1,2],[1,2,2],[2,0,2]]\n<strong>输出：</strong>2\n<strong>解释：</strong>每个人都做一条陈述。\n- 0 认为 1 是好人。\n- 1 认为 0 是好人。\n- 2 认为 1 是坏人。\n以 2 为突破点。\n- 假设 2 是一个好人：\n    - 基于 2 的陈述，1 是坏人。\n    - 那么可以确认 1 是坏人，2 是好人。\n    - 基于 1 的陈述，由于 1 是坏人，那么他在陈述时可能：\n        - 说真话。在这种情况下会出现矛盾，所以假设无效。\n        - 说假话。在这种情况下，0 也是坏人并且在陈述时说假话。\n    - <strong>在认为 2 是好人的情况下，这组玩家中只有一个好人。</strong>\n- 假设 2 是一个坏人：\n    - 基于 2 的陈述，由于 2 是坏人，那么他在陈述时可能：\n        - 说真话。在这种情况下，0 和 1 都是坏人。\n            - <strong>在认为 2 是坏人但说真话的情况下，这组玩家中没有一个好人。</strong>\n        - 说假话。在这种情况下，1 是好人。\n            - 由于 1 是好人，0 也是好人。\n            - <strong>在认为 2 是坏人且说假话的情况下，这组玩家中有两个好人。</strong>\n在最佳情况下，至多有两个好人，所以返回 2 。\n注意，能得到此结论的方法不止一种。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/01/15/logic2.jpg\" style=\"width: 600px; height: 262px;\">\n<pre><strong>输入：</strong>statements = [[2,0],[0,2]]\n<strong>输出：</strong>1\n<strong>解释：</strong>每个人都做一条陈述。\n- 0 认为 1 是坏人。\n- 1 认为 0 是坏人。\n以 0 为突破点。\n- 假设 0 是一个好人：\n    - 基于与 0 的陈述，1 是坏人并说假话。\n    - <strong>在认为 0 是好人的情况下，这组玩家中只有一个好人。</strong>\n- 假设 0 是一个坏人：\n    - 基于 0 的陈述，由于 0 是坏人，那么他在陈述时可能：\n        - 说真话。在这种情况下，0 和 1 都是坏人。\n            - <strong>在认为 0 是坏人但说真话的情况下，这组玩家中没有一个好人。</strong>\n        - 说假话。在这种情况下，1 是好人。\n            - <strong>在认为 0 是坏人且说假话的情况下，这组玩家中只有一个好人。</strong>\n在最佳情况下，至多有一个好人，所以返回 1 。 \n注意，能得到此结论的方法不止一种。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == statements.length == statements[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 15</code></li>\n\t<li><code>statements[i][j]</code> 的值为 <code>0</code>、<code>1</code> 或 <code>2</code></li>\n\t<li><code>statements[i][i] == 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2152穿过所有点的所需最少直线数量",
        "hardRate": "MEDIUM",
        "passRate": "52.95%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-lines-to-cover-points/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-lines-to-cover-points/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2153每辆车的乘客人数 II",
        "hardRate": "HARD",
        "passRate": "44.47%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-passengers-in-each-bus-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-passengers-in-each-bus-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2154将找到的值乘以 2",
        "hardRate": "EASY",
        "passRate": "73.46%",
        "problemsUrl": "https://leetcode.cn/problems/keep-multiplying-found-values-by-two/",
        "solutionsUrl": "https://leetcode.cn/problems/keep-multiplying-found-values-by-two/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，另给你一个整数 <code>original</code> ，这是需要在 <code>nums</code> 中搜索的第一个数字。</p>\n\n<p>接下来，你需要按下述步骤操作：</p>\n\n<ol>\n\t<li>如果在 <code>nums</code> 中找到 <code>original</code> ，将 <code>original</code>&nbsp;<strong>乘以</strong> 2 ，得到新 <code>original</code>（即，令 <code>original = 2 * original</code>）。</li>\n\t<li>否则，停止这一过程。</li>\n\t<li>只要能在数组中找到新 <code>original</code> ，就对新 <code>original</code> 继续 <strong>重复</strong> 这一过程<strong>。</strong></li>\n</ol>\n\n<p>返回<em> </em><code>original</code> 的 <strong>最终</strong> 值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,3,6,1,12], original = 3\n<strong>输出：</strong>24\n<strong>解释：</strong> \n- 3 能在 nums 中找到。3 * 2 = 6 。\n- 6 能在 nums 中找到。6 * 2 = 12 。\n- 12 能在 nums 中找到。12 * 2 = 24 。\n- 24 不能在 nums 中找到。因此，返回 24 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,7,9], original = 4\n<strong>输出：</strong>4\n<strong>解释：</strong>\n- 4 不能在 nums 中找到。因此，返回 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i], original &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2155分组得分最高的所有下标",
        "hardRate": "MEDIUM",
        "passRate": "64.58%",
        "problemsUrl": "https://leetcode.cn/problems/all-divisions-with-the-highest-score-of-a-binary-array/",
        "solutionsUrl": "https://leetcode.cn/problems/all-divisions-with-the-highest-score-of-a-binary-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的二进制数组 <code>nums</code> ，数组长度为 <code>n</code> 。<code>nums</code> 可以按下标 <code>i</code>（ <code>0 &lt;= i &lt;= n</code> ）拆分成两个数组（可能为空）：<code>nums<sub>left</sub></code> 和 <code>nums<sub>right</sub></code> 。</p>\n\n<ul>\n\t<li><code>nums<sub>left</sub></code> 包含 <code>nums</code> 中从下标 <code>0</code> 到 <code>i - 1</code> 的所有元素<strong>（包括 </strong><code>0</code><strong> 和 </strong><code>i - 1</code><strong> ）</strong>，而 <code>nums<sub>right</sub></code> 包含 <code>nums</code> 中从下标 <code>i</code> 到 <code>n - 1</code> 的所有元素<strong>（包括 </strong><code>i</code><strong> 和 </strong><code>n - 1</code><strong> ）。</strong></li>\n\t<li>如果 <code>i == 0</code> ，<code>nums<sub>left</sub></code> 为 <strong>空</strong> ，而 <code>nums<sub>right</sub></code> 将包含 <code>nums</code> 中的所有元素。</li>\n\t<li>如果 <code>i == n</code> ，<code>nums<sub>left</sub></code> 将包含 <code>nums</code> 中的所有元素，而 <code>nums<sub>right</sub></code> 为 <strong>空</strong> 。</li>\n</ul>\n\n<p>下标 <code>i</code><strong> </strong>的<strong> 分组得分</strong> 为 <code>nums<sub>left</sub></code> 中 <code>0</code> 的个数和 <code>nums<sub>right</sub></code> 中 <code>1</code> 的个数之<strong> 和</strong> 。</p>\n\n<p>返回 <strong>分组得分 最高</strong> 的 <strong>所有不同下标</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,0,1,0]\n<strong>输出：</strong>[2,4]\n<strong>解释：</strong>按下标分组\n- 0 ：nums<sub>left</sub> 为 [] 。nums<sub>right</sub> 为 [0,0,<em><strong>1</strong></em>,0] 。得分为 0 + 1 = 1 。\n- 1 ：nums<sub>left</sub> 为 [<em><strong>0</strong></em>] 。nums<sub>right</sub> 为 [0,<em><strong>1</strong></em>,0] 。得分为 1 + 1 = 2 。\n- 2 ：nums<sub>left</sub> 为 [<em><strong>0</strong></em>,<em><strong>0</strong></em>] 。nums<sub>right</sub> 为 [<em><strong>1</strong></em>,0] 。得分为 2 + 1 = 3 。\n- 3 ：nums<sub>left</sub> 为 [<em><strong>0</strong></em>,<em><strong>0</strong></em>,1] 。nums<sub>right</sub> 为 [0] 。得分为 2 + 0 = 2 。\n- 4 ：nums<sub>left</sub> 为 [<em><strong>0</strong></em>,<em><strong>0</strong></em>,1,<em><strong>0</strong></em>] 。nums<sub>right</sub> 为 [] 。得分为 3 + 0 = 3 。\n下标 2 和 4 都可以得到最高的分组得分 3 。\n注意，答案 [4,2] 也被视为正确答案。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,0,0]\n<strong>输出：</strong>[3]\n<strong>解释：</strong>按下标分组\n- 0 ：nums<sub>left</sub> 为 [] 。nums<sub>right</sub> 为 [0,0,0] 。得分为 0 + 0 = 0 。\n- 1 ：nums<sub>left</sub> 为 [<em><strong>0</strong></em>] 。nums<sub>right</sub> 为 [0,0] 。得分为 1 + 0 = 1 。\n- 2 ：nums<sub>left</sub> 为 [<em><strong>0</strong></em>,<em><strong>0</strong></em>] 。nums<sub>right</sub> 为 [0] 。得分为 2 + 0 = 2 。\n- 3 ：nums<sub>left</sub> 为 [<em><strong>0</strong></em>,<em><strong>0</strong></em>,<em><strong>0</strong></em>] 。nums<sub>right</sub> 为 [] 。得分为 3 + 0 = 3 。\n只有下标 3 可以得到最高的分组得分 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1]\n<strong>输出：</strong>[0]\n<strong>解释：</strong>按下标分组\n- 0 ：nums<sub>left</sub> 为 [] 。nums<sub>right</sub> 为 [<em><strong>1</strong></em>,<em><strong>1</strong></em>] 。得分为 0 + 2 = 2 。\n- 1 ：nums<sub>left</sub> 为 [1] 。nums<sub>right</sub> 为 [<em><strong>1</strong></em>] 。得分为 0 + 1 = 1 。\n- 2 ：nums<sub>left</sub> 为 [1,1] 。nums<sub>right</sub> 为 [] 。得分为 0 + 0 = 0 。\n只有下标 0 可以得到最高的分组得分 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2156查找给定哈希值的子串",
        "hardRate": "HARD",
        "passRate": "25.23%",
        "problemsUrl": "https://leetcode.cn/problems/find-substring-with-given-hash-value/",
        "solutionsUrl": "https://leetcode.cn/problems/find-substring-with-given-hash-value/solution",
        "problemsDesc": "<p>给定整数 <code>p</code>&nbsp;和 <code>m</code>&nbsp;，一个长度为 <code>k</code>&nbsp;且下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>s</code>&nbsp;的哈希值按照如下函数计算：</p>\n\n<ul>\n\t<li><code>hash(s, p, m) = (val(s[0]) * p<sup>0</sup> + val(s[1]) * p<sup>1</sup> + ... + val(s[k-1]) * p<sup>k-1</sup>) mod m</code>.</li>\n</ul>\n\n<p>其中&nbsp;<code>val(s[i])</code>&nbsp;表示&nbsp;<code>s[i]</code>&nbsp;在字母表中的下标，从&nbsp;<code>val('a') = 1</code> 到&nbsp;<code>val('z') = 26</code>&nbsp;。</p>\n\n<p>给你一个字符串&nbsp;<code>s</code>&nbsp;和整数&nbsp;<code>power</code>，<code>modulo</code>，<code>k</code>&nbsp;和&nbsp;<code>hashValue</code>&nbsp;。请你返回 <code>s</code>&nbsp;中 <strong>第一个</strong> 长度为 <code>k</code>&nbsp;的 <strong>子串</strong>&nbsp;<code>sub</code>&nbsp;，满足<em>&nbsp;</em><code>hash(sub, power, modulo) == hashValue</code>&nbsp;。</p>\n\n<p>测试数据保证一定 <strong>存在</strong>&nbsp;至少一个这样的子串。</p>\n\n<p><strong>子串</strong> 定义为一个字符串中连续非空字符组成的序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"leetcode\", power = 7, modulo = 20, k = 2, hashValue = 0\n<strong>输出：</strong>\"ee\"\n<strong>解释：</strong>\"ee\" 的哈希值为 hash(\"ee\", 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0 。\n\"ee\" 是长度为 2 的第一个哈希值为 0 的子串，所以我们返回 \"ee\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"fbxzaad\", power = 31, modulo = 100, k = 3, hashValue = 32\n<b>输出：</b>\"fbx\"\n<b>解释：</b>\"fbx\" 的哈希值为 hash(\"fbx\", 31, 100) = (6 * 1 + 2 * 31 + 24 * 31<sup>2</sup>) mod 100 = 23132 mod 100 = 32 。\n\"bxz\" 的哈希值为 hash(\"bxz\", 31, 100) = (2 * 1 + 24 * 31 + 26 * 31<sup>2</sup>) mod 100 = 25732 mod 100 = 32 。\n\"fbx\" 是长度为 3 的第一个哈希值为 32 的子串，所以我们返回 \"fbx\" 。\n注意，\"bxz\" 的哈希值也为 32 ，但是它在字符串中比 \"fbx\" 更晚出现。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= s.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= power, modulo &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= hashValue &lt; modulo</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n\t<li>测试数据保证一定 <strong>存在</strong>&nbsp;满足条件的子串。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2157字符串分组",
        "hardRate": "HARD",
        "passRate": "31.28%",
        "problemsUrl": "https://leetcode.cn/problems/groups-of-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/groups-of-strings/solution",
        "problemsDesc": "<p>给你一个下标从&nbsp;<strong>0&nbsp;</strong>开始的字符串数组&nbsp;<code>words</code>&nbsp;。每个字符串都只包含 <strong>小写英文字母</strong>&nbsp;。<code>words</code>&nbsp;中任意一个子串中，每个字母都至多只出现一次。</p>\n\n<p>如果通过以下操作之一，我们可以从 <code>s1</code>&nbsp;的字母集合得到 <code>s2</code>&nbsp;的字母集合，那么我们称这两个字符串为 <strong>关联的</strong>&nbsp;：</p>\n\n<ul>\n\t<li>往&nbsp;<code>s1</code>&nbsp;的字母集合中添加一个字母。</li>\n\t<li>从&nbsp;<code>s1</code>&nbsp;的字母集合中删去一个字母。</li>\n\t<li>将 <code>s1</code>&nbsp;中的一个字母替换成另外任意一个字母（也可以替换为这个字母本身）。</li>\n</ul>\n\n<p>数组&nbsp;<code>words</code>&nbsp;可以分为一个或者多个无交集的 <strong>组</strong>&nbsp;。如果一个字符串与另一个字符串关联，那么它们应当属于同一个组。</p>\n\n<p>注意，你需要确保分好组后，一个组内的任一字符串与其他组的字符串都不关联。可以证明在这个条件下，分组方案是唯一的。</p>\n\n<p>请你返回一个长度为 <code>2</code>&nbsp;的数组&nbsp;<code>ans</code>&nbsp;：</p>\n\n<ul>\n\t<li><code>ans[0]</code>&nbsp;是&nbsp;<code>words</code>&nbsp;分组后的&nbsp;<strong>总组数</strong>&nbsp;。</li>\n\t<li><code>ans[1]</code>&nbsp;是字符串数目最多的组所包含的字符串数目。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"a\",\"b\",\"ab\",\"cde\"]\n<b>输出：</b>[2,3]\n<b>解释：</b>\n- words[0] 可以得到 words[1] （将 'a' 替换为 'b'）和 words[2] （添加 'b'）。所以 words[0] 与 words[1] 和 words[2] 关联。\n- words[1] 可以得到 words[0] （将 'b' 替换为 'a'）和 words[2] （添加 'a'）。所以 words[1] 与 words[0] 和 words[2] 关联。\n- words[2] 可以得到 words[0] （删去 'b'）和 words[1] （删去 'a'）。所以 words[2] 与 words[0] 和 words[1] 关联。\n- words[3] 与 words 中其他字符串都不关联。\n所以，words 可以分成 2 个组 [\"a\",\"b\",\"ab\"] 和 [\"cde\"] 。最大的组大小为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"a\",\"ab\",\"abc\"]\n<b>输出：</b>[1,3]\n<strong>解释：</strong>\n- words[0] 与 words[1] 关联。\n- words[1] 与 words[0] 和 words[2] 关联。\n- words[2] 与 words[1] 关联。\n由于所有字符串与其他字符串都关联，所以它们全部在同一个组内。\n所以最大的组大小为 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 26</code></li>\n\t<li><code>words[i]</code>&nbsp;只包含小写英文字母。</li>\n\t<li><code>words[i]</code> 中每个字母最多只出现一次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2158每天绘制新区域的数量",
        "hardRate": "HARD",
        "passRate": "55.75%",
        "problemsUrl": "https://leetcode.cn/problems/amount-of-new-area-painted-each-day/",
        "solutionsUrl": "https://leetcode.cn/problems/amount-of-new-area-painted-each-day/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2159分别排序两列",
        "hardRate": "MEDIUM",
        "passRate": "61.27%",
        "problemsUrl": "https://leetcode.cn/problems/order-two-columns-independently/",
        "solutionsUrl": "https://leetcode.cn/problems/order-two-columns-independently/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2160拆分数位后四位数字的最小和",
        "hardRate": "EASY",
        "passRate": "84.20%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-sum-of-four-digit-number-after-splitting-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-sum-of-four-digit-number-after-splitting-digits/solution",
        "problemsDesc": "<p>给你一个四位&nbsp;<strong>正</strong>&nbsp;整数&nbsp;<code>num</code>&nbsp;。请你使用 <code>num</code>&nbsp;中的 <strong>数位</strong> ，将&nbsp;<code>num</code>&nbsp;拆成两个新的整数&nbsp;<code>new1</code>&nbsp;和&nbsp;<code>new2</code>&nbsp;。<code>new1</code> 和&nbsp;<code>new2</code>&nbsp;中可以有&nbsp;<strong>前导 0</strong>&nbsp;，且&nbsp;<code>num</code>&nbsp;中 <strong>所有</strong>&nbsp;数位都必须使用。</p>\n\n<ul>\n\t<li>比方说，给你&nbsp;<code>num = 2932</code>&nbsp;，你拥有的数位包括：两个&nbsp;<code>2</code>&nbsp;，一个&nbsp;<code>9</code>&nbsp;和一个&nbsp;<code>3</code>&nbsp;。一些可能的&nbsp;<code>[new1, new2]</code>&nbsp;数对为&nbsp;<code>[22, 93]</code>，<code>[23, 92]</code>，<code>[223, 9]</code> 和&nbsp;<code>[2, 329]</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回可以得到的&nbsp;<code>new1</code>&nbsp;和 <code>new2</code>&nbsp;的 <strong>最小</strong>&nbsp;和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>num = 2932\n<b>输出：</b>52\n<b>解释：</b>可行的 [new1, new2] 数对为 [29, 23] ，[223, 9] 等等。\n最小和为数对 [29, 23] 的和：29 + 23 = 52 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>num = 4009\n<b>输出：</b>13\n<b>解释：</b>可行的 [new1, new2] 数对为 [0, 49] ，[490, 0] 等等。\n最小和为数对 [4, 9] 的和：4 + 9 = 13 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1000 &lt;= num &lt;= 9999</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2161根据给定数字划分数组",
        "hardRate": "MEDIUM",
        "passRate": "82.52%",
        "problemsUrl": "https://leetcode.cn/problems/partition-array-according-to-given-pivot/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-array-according-to-given-pivot/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>pivot</code>&nbsp;。请你将&nbsp;<code>nums</code>&nbsp;重新排列，使得以下条件均成立：</p>\n\n<ul>\n\t<li>所有小于&nbsp;<code>pivot</code>&nbsp;的元素都出现在所有大于&nbsp;<code>pivot</code>&nbsp;的元素&nbsp;<strong>之前</strong>&nbsp;。</li>\n\t<li>所有等于&nbsp;<code>pivot</code>&nbsp;的元素都出现在小于和大于 <code>pivot</code>&nbsp;的元素 <strong>中间</strong>&nbsp;。</li>\n\t<li>小于 <code>pivot</code>&nbsp;的元素之间和大于 <code>pivot</code>&nbsp;的元素之间的 <strong>相对顺序</strong>&nbsp;不发生改变。\n\t<ul>\n\t\t<li>更正式的，考虑每一对&nbsp;<code>p<sub>i</sub></code>，<code>p<sub>j</sub></code>&nbsp;，<code>p<sub>i</sub></code>&nbsp;是初始时位置 <code>i</code>&nbsp;元素的新位置，<code>p<sub>j</sub></code>&nbsp;是初始时位置&nbsp;<code>j</code>&nbsp;元素的新位置。对于小于&nbsp;<code>pivot</code>&nbsp;的元素，如果&nbsp;<code>i &lt; j</code>&nbsp;且&nbsp;<code>nums[i] &lt; pivot</code> 和&nbsp;<code>nums[j] &lt; pivot</code>&nbsp;都成立，那么&nbsp;<code>p<sub>i</sub> &lt; p<sub>j</sub></code>&nbsp;也成立。类似的，对于大于&nbsp;<code>pivot</code>&nbsp;的元素，如果&nbsp;<code>i &lt; j</code> 且&nbsp;<code>nums[i] &gt; pivot</code> 和&nbsp;<code>nums[j] &gt; pivot</code>&nbsp;都成立，那么&nbsp;<code>p<sub>i</sub> &lt; p<sub>j</sub></code>&nbsp;。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>请你返回重新排列 <code>nums</code>&nbsp;数组后的结果数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [9,12,5,10,14,3,10], pivot = 10\n<b>输出：</b>[9,5,3,10,10,12,14]\n<b>解释：</b>\n元素 9 ，5 和 3 小于 pivot ，所以它们在数组的最左边。\n元素 12 和 14 大于 pivot ，所以它们在数组的最右边。\n小于 pivot 的元素的相对位置和大于 pivot 的元素的相对位置分别为 [9, 5, 3] 和 [12, 14] ，它们在结果数组中的相对顺序需要保留。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [-3,4,3,2], pivot = 2\n<b>输出：</b>[-3,2,4,3]\n<b>解释：</b>\n元素 -3 小于 pivot ，所以在数组的最左边。\n元素 4 和 3 大于 pivot ，所以它们在数组的最右边。\n小于 pivot 的元素的相对位置和大于 pivot 的元素的相对位置分别为 [-3] 和 [4, 3] ，它们在结果数组中的相对顺序需要保留。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>6</sup> &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>pivot</code>&nbsp;等于&nbsp;<code>nums</code>&nbsp;中的一个元素。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2162设置时间的最少代价",
        "hardRate": "MEDIUM",
        "passRate": "34.28%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-set-cooking-time/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-set-cooking-time/solution",
        "problemsDesc": "<p>常见的微波炉可以设置加热时间，且加热时间满足以下条件：</p>\n\n<ul>\n\t<li>至少为 <code>1</code>&nbsp;秒钟。</li>\n\t<li>至多为&nbsp;<code>99</code>&nbsp;分&nbsp;<code>99</code>&nbsp;秒。</li>\n</ul>\n\n<p>你可以 <strong>最多</strong>&nbsp;输入&nbsp;<strong>4 个数字</strong>&nbsp;来设置加热时间。如果你输入的位数不足 4 位，微波炉会自动加 <strong>前缀</strong>&nbsp;<strong>0</strong>&nbsp;来补足 4 位。微波炉会将设置好的四位数中，<strong>前</strong>&nbsp;两位当作分钟数，<strong>后</strong>&nbsp;两位当作秒数。它们所表示的总时间就是加热时间。比方说：</p>\n\n<ul>\n\t<li>你输入&nbsp;<code>9</code> <code>5</code> <code>4</code>&nbsp;（三个数字），被自动补足为&nbsp;<code>0954</code>&nbsp;，并表示&nbsp;<code>9</code>&nbsp;分&nbsp;<code>54</code>&nbsp;秒。</li>\n\t<li>你输入&nbsp;<code>0</code> <code>0</code> <code>0</code> <code>8</code>&nbsp;（四个数字），表示&nbsp;<code>0</code>&nbsp;分&nbsp;<code>8</code>&nbsp;秒。</li>\n\t<li>你输入&nbsp;<code>8</code> <code>0</code> <code>9</code> <code>0</code>&nbsp;，表示&nbsp;<code>80</code>&nbsp;分&nbsp;<code>90</code>&nbsp;秒。</li>\n\t<li>你输入&nbsp;<code>8</code> <code>1</code> <code>3</code> <code>0</code>&nbsp;，表示&nbsp;<code>81</code>&nbsp;分&nbsp;<code>30</code>&nbsp;秒。</li>\n</ul>\n\n<p>给你整数&nbsp;<code>startAt</code>&nbsp;，<code>moveCost</code>&nbsp;，<code>pushCost</code>&nbsp;和&nbsp;<code>targetSeconds</code>&nbsp;。<strong>一开始</strong>，你的手指在数字&nbsp;<code>startAt</code>&nbsp;处。将手指移到<strong>&nbsp;任何其他数字</strong>&nbsp;，需要花费&nbsp;<code>moveCost</code>&nbsp;的单位代价。<strong>每</strong>&nbsp;输入你手指所在位置的数字一次，需要花费&nbsp;<code>pushCost</code>&nbsp;的单位代价。</p>\n\n<p>要设置&nbsp;<code>targetSeconds</code>&nbsp;秒的加热时间，可能会有多种设置方法。你想要知道这些方法中，总代价最小为多少。</p>\n\n<p>请你能返回设置&nbsp;<code>targetSeconds</code>&nbsp;秒钟加热时间需要花费的最少代价。</p>\n\n<p>请记住，虽然微波炉的秒数最多可以设置到 <code>99</code>&nbsp;秒，但一分钟等于&nbsp;<code>60</code>&nbsp;秒。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/30/1.png\" style=\"width: 506px; height: 210px;\"></p>\n\n<pre><b>输入：</b>startAt = 1, moveCost = 2, pushCost = 1, targetSeconds = 600\n<b>输出：</b>6\n<b>解释：</b>以下为设置加热时间的所有方法。\n- 1 0 0 0 ，表示 10 分 0 秒。\n&nbsp; 手指一开始就在数字 1 处，输入 1 （代价为 1），移到 0 处（代价为 2），输入 0（代价为 1），输入 0（代价为 1），输入 0（代价为 1）。\n&nbsp; 总代价为：1 + 2 + 1 + 1 + 1 = 6 。这是所有方案中的最小代价。\n- 0 9 6 0，表示 9 分 60 秒。它也表示 600 秒。\n&nbsp; 手指移到 0 处（代价为 2），输入 0 （代价为 1），移到 9 处（代价为 2），输入 9（代价为 1），移到 6 处（代价为 2），输入 6（代价为 1），移到 0 处（代价为 2），输入 0（代价为 1）。\n&nbsp; 总代价为：2 + 1 + 2 + 1 + 2 + 1 + 2 + 1 = 12 。\n- 9 6 0，微波炉自动补全为 0960 ，表示 9 分 60 秒。\n&nbsp; 手指移到 9 处（代价为 2），输入 9 （代价为 1），移到 6 处（代价为 2），输入 6（代价为 1），移到 0 处（代价为 2），输入 0（代价为 1）。\n&nbsp; 总代价为：2 + 1 + 2 + 1 + 2 + 1 = 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/30/2.png\" style=\"width: 505px; height: 73px;\"></p>\n\n<pre><b>输入：</b>startAt = 0, moveCost = 1, pushCost = 2, targetSeconds = 76\n<b>输出：</b>6\n<b>解释：</b>最优方案为输入两个数字 7 6，表示 76 秒。\n手指移到 7 处（代价为 1），输入 7 （代价为 2），移到 6 处（代价为 1），输入 6（代价为 2）。总代价为：1 + 2 + 1 + 2 = 6\n其他可行方案为 0076 ，076 ，0116 和 116 ，但是它们的代价都比 6 大。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= startAt &lt;= 9</code></li>\n\t<li><code>1 &lt;= moveCost, pushCost &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= targetSeconds &lt;= 6039</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2163删除元素后和的最小差值",
        "hardRate": "HARD",
        "passRate": "49.13%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-difference-in-sums-after-removal-of-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-difference-in-sums-after-removal-of-elements/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，它包含&nbsp;<code>3 * n</code>&nbsp;个元素。</p>\n\n<p>你可以从 <code>nums</code>&nbsp;中删除 <strong>恰好</strong>&nbsp;<code>n</code>&nbsp;个元素，剩下的 <code>2 * n</code>&nbsp;个元素将会被分成两个 <strong>相同大小</strong>&nbsp;的部分。</p>\n\n<ul>\n\t<li>前面&nbsp;<code>n</code>&nbsp;个元素属于第一部分，它们的和记为&nbsp;<code>sum<sub>first</sub></code>&nbsp;。</li>\n\t<li>后面&nbsp;<code>n</code>&nbsp;个元素属于第二部分，它们的和记为&nbsp;<code>sum<sub>second</sub></code>&nbsp;。</li>\n</ul>\n\n<p>两部分和的 <strong>差值</strong>&nbsp;记为&nbsp;<code>sum<sub>first</sub> - sum<sub>second</sub></code>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，<code>sum<sub>first</sub> = 3</code> 且&nbsp;<code>sum<sub>second</sub> = 2</code>&nbsp;，它们的差值为&nbsp;<code>1</code>&nbsp;。</li>\n\t<li>再比方，<code>sum<sub>first</sub> = 2</code> 且&nbsp;<code>sum<sub>second</sub> = 3</code>&nbsp;，它们的差值为&nbsp;<code>-1</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回删除 <code>n</code>&nbsp;个元素之后，剩下两部分和的 <strong>差值的最小值</strong>&nbsp;是多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [3,1,2]\n<b>输出：</b>-1\n<b>解释：</b>nums 有 3 个元素，所以 n = 1 。\n所以我们需要从 nums 中删除 1 个元素，并将剩下的元素分成两部分。\n- 如果我们删除 nums[0] = 3 ，数组变为 [1,2] 。两部分和的差值为 1 - 2 = -1 。\n- 如果我们删除 nums[1] = 1 ，数组变为 [3,2] 。两部分和的差值为 3 - 2 = 1 。\n- 如果我们删除 nums[2] = 2 ，数组变为 [3,1] 。两部分和的差值为 3 - 1 = 2 。\n两部分和的最小差值为 min(-1,1,2) = -1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [7,9,5,8,1,3]\n<b>输出：</b>1\n<b>解释：</b>n = 2 。所以我们需要删除 2 个元素，并将剩下元素分为 2 部分。\n如果我们删除元素 nums[2] = 5 和 nums[3] = 8 ，剩下元素为 [7,9,1,3] 。和的差值为 (7+9) - (1+3) = 12 。\n为了得到最小差值，我们应该删除 nums[1] = 9 和 nums[4] = 1 ，剩下的元素为 [7,5,8,3] 。和的差值为 (7+5) - (8+3) = 1 。\n观察可知，最优答案为 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length == 3 * n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2164对奇偶下标分别排序",
        "hardRate": "EASY",
        "passRate": "68.55%",
        "problemsUrl": "https://leetcode.cn/problems/sort-even-and-odd-indices-independently/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-even-and-odd-indices-independently/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。根据下述规则重排 <code>nums</code> 中的值：</p>\n\n<ol>\n\t<li>按 <strong>非递增</strong> 顺序排列 <code>nums</code> <strong>奇数下标</strong> 上的所有值。\n\n\t<ul>\n\t\t<li>举个例子，如果排序前 <code>nums = [4,<em><strong>1</strong></em>,2,<em><strong>3</strong></em>]</code> ，对奇数下标的值排序后变为 <code>[4,<em><strong>3</strong></em>,2,<em><strong>1</strong></em>]</code> 。奇数下标 <code>1</code> 和 <code>3</code> 的值按照非递增顺序重排。</li>\n\t</ul>\n\t</li>\n\t<li>按 <strong>非递减</strong> 顺序排列 <code>nums</code> <strong>偶数下标</strong> 上的所有值。\n\t<ul>\n\t\t<li>举个例子，如果排序前 <code>nums = [<em><strong>4</strong></em>,1,<em><strong>2</strong></em>,3]</code> ，对偶数下标的值排序后变为 <code>[<em><strong>2</strong></em>,1,<em><strong>4</strong></em>,3]</code> 。偶数下标 <code>0</code> 和 <code>2</code> 的值按照非递减顺序重排。</li>\n\t</ul>\n\t</li>\n</ol>\n\n<p>返回重排 <code>nums</code> 的值之后形成的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,1,2,3]\n<strong>输出：</strong>[2,3,4,1]\n<strong>解释：</strong>\n首先，按非递增顺序重排奇数下标（1 和 3）的值。\n所以，nums 从 [4,<em><strong>1</strong></em>,2,<em><strong>3</strong></em>] 变为 [4,<em><strong>3</strong></em>,2,<em><strong>1</strong></em>] 。\n然后，按非递减顺序重排偶数下标（0 和 2）的值。\n所以，nums 从 [<em><strong>4</strong></em>,1,<em><strong>2</strong></em>,3] 变为 [<em><strong>2</strong></em>,3,<em><strong>4</strong></em>,1] 。\n因此，重排之后形成的数组是 [2,3,4,1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1]\n<strong>输出：</strong>[2,1]\n<strong>解释：</strong>\n由于只有一个奇数下标和一个偶数下标，所以不会发生重排。\n形成的结果数组是 [2,1] ，和初始数组一样。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2165重排数字的最小值",
        "hardRate": "MEDIUM",
        "passRate": "55.14%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-value-of-the-rearranged-number/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-value-of-the-rearranged-number/solution",
        "problemsDesc": "<p>给你一个整数 <code>num</code> 。<strong>重排</strong> <code>num</code> 中的各位数字，使其值 <strong>最小化</strong> 且不含 <strong>任何</strong> 前导零。</p>\n\n<p>返回不含前导零且值最小的重排数字。</p>\n\n<p>注意，重排各位数字后，<code>num</code> 的符号不会改变。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 310\n<strong>输出：</strong>103\n<strong>解释：</strong>310 中各位数字的可行排列有：013、031、103、130、301、310 。\n不含任何前导零且值最小的重排数字是 103 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = -7605\n<strong>输出：</strong>-7650\n<strong>解释：</strong>-7605 中各位数字的部分可行排列为：-7650、-6705、-5076、-0567。\n不含任何前导零且值最小的重排数字是 -7650 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-10<sup>15</sup> &lt;= num &lt;= 10<sup>15</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2166设计位集",
        "hardRate": "MEDIUM",
        "passRate": "30.72%",
        "problemsUrl": "https://leetcode.cn/problems/design-bitset/",
        "solutionsUrl": "https://leetcode.cn/problems/design-bitset/solution",
        "problemsDesc": "<p><strong>位集 Bitset</strong> 是一种能以紧凑形式存储位的数据结构。</p>\n\n<p>请你实现 <code>Bitset</code> 类。</p>\n\n<ul>\n\t<li><code>Bitset(int size)</code> 用 <code>size</code> 个位初始化 Bitset ，所有位都是 <code>0</code> 。</li>\n\t<li><code>void fix(int idx)</code> 将下标为 <code>idx</code> 的位上的值更新为 <code>1</code> 。如果值已经是 <code>1</code> ，则不会发生任何改变。</li>\n\t<li><code>void unfix(int idx)</code> 将下标为 <code>idx</code> 的位上的值更新为 <code>0</code> 。如果值已经是 <code>0</code> ，则不会发生任何改变。</li>\n\t<li><code>void flip()</code> 翻转 Bitset 中每一位上的值。换句话说，所有值为 <code>0</code> 的位将会变成 <code>1</code> ，反之亦然。</li>\n\t<li><code>boolean all()</code> 检查&nbsp;Bitset 中 <strong>每一位</strong> 的值是否都是 <code>1</code> 。如果满足此条件，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n\t<li><code>boolean one()</code> 检查&nbsp;Bitset 中 是否&nbsp;<strong>至少一位</strong> 的值是 <code>1</code> 。如果满足此条件，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n\t<li><code>int count()</code> 返回 Bitset 中值为 1 的位的 <strong>总数</strong> 。</li>\n\t<li><code>String toString()</code> 返回 Bitset 的当前组成情况。注意，在结果字符串中，第 <code>i</code> 个下标处的字符应该与 Bitset 中的第 <code>i</code> 位一致。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"Bitset\", \"fix\", \"fix\", \"flip\", \"all\", \"unfix\", \"flip\", \"one\", \"unfix\", \"count\", \"toString\"]\n[[5], [3], [1], [], [], [0], [], [], [0], [], []]\n<strong>输出</strong>\n[null, null, null, null, false, null, null, true, null, 2, \"01010\"]\n\n<strong>解释</strong>\nBitset bs = new Bitset(5); // bitset = \"00000\".\nbs.fix(3);     // 将 idx = 3 处的值更新为 1 ，此时 bitset = \"00010\" 。\nbs.fix(1);     // 将 idx = 1 处的值更新为 1 ，此时 bitset = \"01010\" 。\nbs.flip();     // 翻转每一位上的值，此时 bitset = \"10101\" 。\nbs.all();      // 返回 False ，bitset 中的值不全为 1 。\nbs.unfix(0);   // 将 idx = 0 处的值更新为 0 ，此时 bitset = \"00101\" 。\nbs.flip();     // 翻转每一位上的值，此时 bitset = \"11010\" 。\nbs.one();      // 返回 True ，至少存在一位的值为 1 。\nbs.unfix(0);   // 将 idx = 0 处的值更新为 0 ，此时 bitset = \"01010\" 。\nbs.count();    // 返回 2 ，当前有 2 位的值为 1 。\nbs.toString(); // 返回 \"01010\" ，即 bitset 的当前组成情况。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= size &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= idx &lt;= size - 1</code></li>\n\t<li>至多调用&nbsp;<code>fix</code>、<code>unfix</code>、<code>flip</code>、<code>all</code>、<code>one</code>、<code>count</code> 和 <code>toString</code> 方法 <strong>总共</strong> <code>10<sup>5</sup></code> 次</li>\n\t<li>至少调用 <code>all</code>、<code>one</code>、<code>count</code> 或 <code>toString</code> 方法一次</li>\n\t<li>至多调用&nbsp;<code>toString</code> 方法 <code>5</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2167移除所有载有违禁货物车厢所需的最少时间",
        "hardRate": "HARD",
        "passRate": "49.21%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的二进制字符串 <code>s</code> ，表示一个列车车厢序列。<code>s[i] = '0'</code> 表示第 <code>i</code> 节车厢 <strong>不</strong> 含违禁货物，而 <code>s[i] = '1'</code> 表示第 <code>i</code> 节车厢含违禁货物。</p>\n\n<p>作为列车长，你需要清理掉所有载有违禁货物的车厢。你可以不限次数执行下述三种操作中的任意一个：</p>\n\n<ol>\n\t<li>从列车 <strong>左</strong> 端移除一节车厢（即移除 <code>s[0]</code>），用去 1 单位时间。</li>\n\t<li>从列车 <strong>右</strong> 端移除一节车厢（即移除 <code>s[s.length - 1]</code>），用去 1 单位时间。</li>\n\t<li>从列车车厢序列的 <strong>任意位置</strong> 移除一节车厢，用去 2 单位时间。</li>\n</ol>\n\n<p>返回移除所有载有违禁货物车厢所需要的 <strong>最少</strong> 单位时间数。</p>\n\n<p>注意，空的列车车厢序列视为没有车厢含违禁货物。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"<em><strong>11</strong></em>00<em><strong>1</strong></em>0<em><strong>1</strong></em>\"\n<strong>输出：</strong>5\n<strong>解释：</strong>\n一种从序列中移除所有载有违禁货物的车厢的方法是：\n- 从左端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。\n- 从右端移除一节车厢 1 次。所用时间是 1 。\n- 移除序列中间位置载有违禁货物的车厢。所用时间是 2 。\n总时间是 2 + 1 + 2 = 5 。\n\n一种替代方法是：\n- 从左端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。\n- 从右端移除一节车厢 3 次。所用时间是 3 * 1 = 3 。\n总时间也是 2 + 3 = 5 。\n\n5 是移除所有载有违禁货物的车厢所需要的最少单位时间数。\n没有其他方法能够用更少的时间移除这些车厢。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"00<em><strong>1</strong></em>0\"\n<strong>输出：</strong>2\n<strong>解释：</strong>\n一种从序列中移除所有载有违禁货物的车厢的方法是：\n- 从左端移除一节车厢 3 次。所用时间是 3 * 1 = 3 。\n总时间是 3.\n\n另一种从序列中移除所有载有违禁货物的车厢的方法是：\n- 移除序列中间位置载有违禁货物的车厢。所用时间是 2 。\n总时间是 2.\n\n另一种从序列中移除所有载有违禁货物的车厢的方法是：\n- 从右端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。\n总时间是 2.\n\n2 是移除所有载有违禁货物的车厢所需要的最少单位时间数。\n没有其他方法能够用更少的时间移除这些车厢。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2168每个数字的频率都相同的独特子字符串的数量",
        "hardRate": "MEDIUM",
        "passRate": "63.17%",
        "problemsUrl": "https://leetcode.cn/problems/unique-substrings-with-equal-digit-frequency/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-substrings-with-equal-digit-frequency/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2169得到 0 的操作数",
        "hardRate": "EASY",
        "passRate": "73.61%",
        "problemsUrl": "https://leetcode.cn/problems/count-operations-to-obtain-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/count-operations-to-obtain-zero/solution",
        "problemsDesc": "<p>给你两个 <strong>非负</strong> 整数 <code>num1</code> 和 <code>num2</code> 。</p>\n\n<p>每一步 <strong>操作</strong>&nbsp;中，如果 <code>num1 &gt;= num2</code> ，你必须用 <code>num1</code> 减 <code>num2</code> ；否则，你必须用 <code>num2</code> 减 <code>num1</code> 。</p>\n\n<ul>\n\t<li>例如，<code>num1 = 5</code> 且 <code>num2 = 4</code> ，应该用&nbsp;<code>num1</code> 减 <code>num2</code> ，因此，得到 <code>num1 = 1</code> 和 <code>num2 = 4</code> 。然而，如果 <code>num1 = 4</code>且 <code>num2 = 5</code> ，一步操作后，得到 <code>num1 = 4</code> 和 <code>num2 = 1</code> 。</li>\n</ul>\n\n<p>返回使 <code>num1 = 0</code> 或 <code>num2 = 0</code> 的 <strong>操作数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = 2, num2 = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>\n- 操作 1 ：num1 = 2 ，num2 = 3 。由于 num1 &lt; num2 ，num2 减 num1 得到 num1 = 2 ，num2 = 3 - 2 = 1 。\n- 操作 2 ：num1 = 2 ，num2 = 1 。由于 num1 &gt; num2 ，num1 减 num2 。\n- 操作 3 ：num1 = 1 ，num2 = 1 。由于 num1 == num2 ，num1 减 num2 。\n此时 num1 = 0 ，num2 = 1 。由于 num1 == 0 ，不需要再执行任何操作。\n所以总操作数是 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = 10, num2 = 10\n<strong>输出：</strong>1\n<strong>解释：</strong>\n- 操作 1 ：num1 = 10 ，num2 = 10 。由于 num1 == num2 ，num1 减 num2 得到 num1 = 10 - 10 = 0 。\n此时 num1 = 0 ，num2 = 10 。由于 num1 == 0 ，不需要再执行任何操作。\n所以总操作数是 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num1, num2 &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2170使数组变成交替数组的最少操作数",
        "hardRate": "MEDIUM",
        "passRate": "31.22%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-array-alternating/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-make-the-array-alternating/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，该数组由 <code>n</code> 个正整数组成。</p>\n\n<p>如果满足下述条件，则数组 <code>nums</code> 是一个 <strong>交替数组</strong> ：</p>\n\n<ul>\n\t<li><code>nums[i - 2] == nums[i]</code> ，其中 <code>2 &lt;= i &lt;= n - 1</code> 。</li>\n\t<li><code>nums[i - 1] != nums[i]</code> ，其中 <code>1 &lt;= i &lt;= n - 1</code> 。</li>\n</ul>\n\n<p>在一步 <strong>操作</strong> 中，你可以选择下标 <code>i</code> 并将 <code>nums[i]</code> <strong>更改</strong> 为 <strong>任一</strong> 正整数。</p>\n\n<p>返回使数组变成交替数组的 <strong>最少操作数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,1,3,2,4,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n使数组变成交替数组的方法之一是将该数组转换为 [3,1,3,<em><strong>1</strong></em>,<em><strong>3</strong></em>,<em><strong>1</strong></em>] 。\n在这种情况下，操作数为 3 。\n可以证明，操作数少于 3 的情况下，无法使数组变成交替数组。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2,2,2]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n使数组变成交替数组的方法之一是将该数组转换为 [1,2,<em><strong>1</strong></em>,2,<em><strong>1</strong></em>].\n在这种情况下，操作数为 2 。\n注意，数组不能转换成 [<em><strong>2</strong></em>,2,2,2,2] 。因为在这种情况下，nums[0] == nums[1]，不满足交替数组的条件。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2171拿出最少数目的魔法豆",
        "hardRate": "MEDIUM",
        "passRate": "40.41%",
        "problemsUrl": "https://leetcode.cn/problems/removing-minimum-number-of-magic-beans/",
        "solutionsUrl": "https://leetcode.cn/problems/removing-minimum-number-of-magic-beans/solution",
        "problemsDesc": "<p>给你一个 <strong>正</strong>&nbsp;整数数组&nbsp;<code>beans</code>&nbsp;，其中每个整数表示一个袋子里装的魔法豆的数目。</p>\n\n<p>请你从每个袋子中&nbsp;<strong>拿出</strong>&nbsp;一些豆子（也可以<strong>&nbsp;不拿出</strong>），使得剩下的 <strong>非空</strong> 袋子中（即 <strong>至少</strong>&nbsp;还有 <strong>一颗</strong>&nbsp;魔法豆的袋子）魔法豆的数目&nbsp;<strong>相等</strong>&nbsp;。一旦魔法豆从袋子中取出，你不能将它放到任何其他的袋子中。</p>\n\n<p>请你返回你需要拿出魔法豆的 <strong>最少数目</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>beans = [4,<em><strong>1</strong></em>,6,5]\n<b>输出：</b>4\n<b>解释：</b>\n- 我们从有 1 个魔法豆的袋子中拿出 1 颗魔法豆。\n  剩下袋子中魔法豆的数目为：[4,<em><b>0</b></em>,6,5]\n- 然后我们从有 6 个魔法豆的袋子中拿出 2 个魔法豆。\n  剩下袋子中魔法豆的数目为：[4,0,<em><strong>4</strong></em>,5]\n- 然后我们从有 5 个魔法豆的袋子中拿出 1 个魔法豆。\n  剩下袋子中魔法豆的数目为：[4,0,4,<em><b>4</b></em>]\n总共拿出了 1 + 2 + 1 = 4 个魔法豆，剩下非空袋子中魔法豆的数目相等。\n没有比取出 4 个魔法豆更少的方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>beans = [<em><strong>2</strong></em>,10,<em><strong>3</strong></em>,<em><strong>2</strong></em>]\n<b>输出：</b>7\n<strong>解释：</strong>\n- 我们从有 2 个魔法豆的其中一个袋子中拿出 2 个魔法豆。\n  剩下袋子中魔法豆的数目为：[<em><strong>0</strong></em>,10,3,2]\n- 然后我们从另一个有 2 个魔法豆的袋子中拿出 2 个魔法豆。\n  剩下袋子中魔法豆的数目为：[0,10,3,<em><strong>0</strong></em>]\n- 然后我们从有 3 个魔法豆的袋子中拿出 3 个魔法豆。\n  剩下袋子中魔法豆的数目为：[0,10,<em><strong>0</strong></em>,0]\n总共拿出了 2 + 2 + 3 = 7 个魔法豆，剩下非空袋子中魔法豆的数目相等。\n没有比取出 7 个魔法豆更少的方案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= beans.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= beans[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2172数组的最大与和",
        "hardRate": "HARD",
        "passRate": "50.74%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-and-sum-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-and-sum-of-array/solution",
        "problemsDesc": "<p>给你一个长度为&nbsp;<code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>numSlots</code>&nbsp;，满足<code>2 * numSlots &gt;= n</code>&nbsp;。总共有&nbsp;<code>numSlots</code>&nbsp;个篮子，编号为&nbsp;<code>1</code>&nbsp;到&nbsp;<code>numSlots</code>&nbsp;。</p>\n\n<p>你需要把所有&nbsp;<code>n</code>&nbsp;个整数分到这些篮子中，且每个篮子 <strong>至多</strong>&nbsp;有 2 个整数。一种分配方案的 <strong>与和</strong>&nbsp;定义为每个数与它所在篮子编号的 <strong>按位与运算</strong>&nbsp;结果之和。</p>\n\n<ul>\n\t<li>比方说，将数字&nbsp;<code>[1, 3]</code>&nbsp;放入篮子&nbsp;<strong><em><code>1</code></em></strong>&nbsp;中，<code>[4, 6]</code> 放入篮子&nbsp;<strong><em><code>2</code></em></strong>&nbsp;中，这个方案的与和为&nbsp;<code>(1 AND <strong><em>1</em></strong>) + (3 AND <strong><em>1</em></strong>) + (4 AND <em><strong>2</strong></em>) + (6 AND <em><strong>2</strong></em>) = 1 + 1 + 0 + 2 = 4</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回将 <code>nums</code>&nbsp;中所有数放入<em>&nbsp;</em><code>numSlots</code>&nbsp;个篮子中的最大与和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4,5,6], numSlots = 3\n<b>输出：</b>9\n<b>解释：</b>一个可行的方案是 [1, 4] 放入篮子 <em><strong>1</strong></em>&nbsp;中，[2, 6] 放入篮子 <strong><em>2</em></strong>&nbsp;中，[3, 5] 放入篮子 <strong><em>3</em></strong> 中。\n最大与和为 (1 AND <strong><em>1</em></strong>) + (4 AND <strong><em>1</em></strong>) + (2 AND <strong><em>2</em></strong>) + (6 AND <strong><em>2</em></strong>) + (3 AND <strong><em>3</em></strong>) + (5 AND <em><strong>3</strong></em>) = 1 + 0 + 2 + 2 + 3 + 1 = 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,3,10,4,7,1], numSlots = 9\n<b>输出：</b>24\n<b>解释：</b>一个可行的方案是 [1, 1] 放入篮子 <em><strong>1</strong></em> 中，[3] 放入篮子 <em><strong>3</strong></em> 中，[4] 放入篮子 <strong><em>4</em></strong> 中，[7] 放入篮子 <strong><em>7</em></strong> 中，[10] 放入篮子 <strong><em>9</em></strong>&nbsp;中。\n最大与和为 (1 AND <strong><em>1</em></strong>) + (1 AND <strong><em>1</em></strong>) + (3 AND <strong><em>3</em></strong>) + (4 AND <strong><em>4</em></strong>) + (7 AND <strong><em>7</em></strong>) + (10 AND <strong><em>9</em></strong>) = 1 + 1 + 3 + 4 + 7 + 8 = 24 。\n注意，篮子 2 ，5 ，6 和 8 是空的，这是允许的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= numSlots &lt;= 9</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * numSlots</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 15</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2173最多连胜的次数",
        "hardRate": "HARD",
        "passRate": "56.59%",
        "problemsUrl": "https://leetcode.cn/problems/longest-winning-streak/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-winning-streak/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2174通过翻转行或列来去除所有的 1 II",
        "hardRate": "MEDIUM",
        "passRate": "66.67%",
        "problemsUrl": "https://leetcode.cn/problems/remove-all-ones-with-row-and-column-flips-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-all-ones-with-row-and-column-flips-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2175世界排名的变化",
        "hardRate": "MEDIUM",
        "passRate": "54.89%",
        "problemsUrl": "https://leetcode.cn/problems/the-change-in-global-rankings/",
        "solutionsUrl": "https://leetcode.cn/problems/the-change-in-global-rankings/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2176统计数组中相等且可以被整除的数对",
        "hardRate": "EASY",
        "passRate": "78.84%",
        "problemsUrl": "https://leetcode.cn/problems/count-equal-and-divisible-pairs-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/count-equal-and-divisible-pairs-in-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;，请你返回满足&nbsp;<code>0 &lt;= i &lt; j &lt; n</code>&nbsp;，<code>nums[i] == nums[j]</code> 且&nbsp;<code>(i * j)</code>&nbsp;能被&nbsp;<code>k</code>&nbsp;整除的数对&nbsp;<code>(i, j)</code>&nbsp;的&nbsp;<strong>数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [3,1,2,2,2,1,3], k = 2\n<b>输出：</b>4\n<strong>解释：</strong>\n总共有 4 对数符合所有要求：\n- nums[0] == nums[6] 且 0 * 6 == 0 ，能被 2 整除。\n- nums[2] == nums[3] 且 2 * 3 == 6 ，能被 2 整除。\n- nums[2] == nums[4] 且 2 * 4 == 8 ，能被 2 整除。\n- nums[3] == nums[4] 且 3 * 4 == 12 ，能被 2 整除。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4], k = 1\n<b>输出：</b>0\n<b>解释：</b>由于数组中没有重复数值，所以没有数对 (i,j) 符合所有要求。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2177找到和为给定整数的三个连续整数",
        "hardRate": "MEDIUM",
        "passRate": "69.90%",
        "problemsUrl": "https://leetcode.cn/problems/find-three-consecutive-integers-that-sum-to-a-given-number/",
        "solutionsUrl": "https://leetcode.cn/problems/find-three-consecutive-integers-that-sum-to-a-given-number/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>num</code>&nbsp;，请你返回三个连续的整数，它们的&nbsp;<strong>和</strong>&nbsp;为<em>&nbsp;</em><code>num</code>&nbsp;。如果&nbsp;<code>num</code>&nbsp;无法被表示成三个连续整数的和，请你返回一个 <strong>空</strong>&nbsp;数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>num = 33\n<b>输出：</b>[10,11,12]\n<b>解释：</b>33 可以表示为 10 + 11 + 12 = 33 。\n10, 11, 12 是 3 个连续整数，所以返回 [10, 11, 12] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>num = 4\n<b>输出：</b>[]\n<b>解释：</b>没有办法将 4 表示成 3 个连续整数的和。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 10<sup>15</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2178拆分成最多数目的正偶数之和",
        "hardRate": "MEDIUM",
        "passRate": "56.51%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-split-of-positive-even-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-split-of-positive-even-integers/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>finalSum</code>&nbsp;。请你将它拆分成若干个&nbsp;<strong>互不相同</strong> 的正偶数之和，且拆分出来的正偶数数目&nbsp;<strong>最多</strong>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，给你&nbsp;<code>finalSum = 12</code>&nbsp;，那么这些拆分是&nbsp;<strong>符合要求</strong> 的（互不相同的正偶数且和为&nbsp;<code>finalSum</code>）：<code>(2 + 10)</code>&nbsp;，<code>(2 + 4 + 6)</code>&nbsp;和&nbsp;<code>(4 + 8)</code>&nbsp;。它们中，<code>(2 + 4 + 6)</code>&nbsp;包含最多数目的整数。注意&nbsp;<code>finalSum</code>&nbsp;不能拆分成&nbsp;<code>(2 + 2 + 4 + 4)</code>&nbsp;，因为拆分出来的整数必须互不相同。</li>\n</ul>\n\n<p>请你返回一个整数数组，表示将整数拆分成 <strong>最多</strong> 数目的正偶数数组。如果没有办法将&nbsp;<code>finalSum</code>&nbsp;进行拆分，请你返回一个&nbsp;<strong>空</strong>&nbsp;数组。你可以按 <b>任意</b>&nbsp;顺序返回这些整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>finalSum = 12\n<b>输出：</b>[2,4,6]\n<b>解释：</b>以下是一些符合要求的拆分：<code>(2 + 10)<span style=\"\">，</span></code><code>(2 + 4 + 6) </code>和 <code>(4 + 8) 。</code>\n(2 + 4 + 6) 为最多数目的整数，数目为 3 ，所以我们返回 [2,4,6] 。\n[2,6,4] ，[6,2,4] 等等也都是可行的解。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>finalSum = 7\n<b>输出：</b>[]\n<b>解释：</b>没有办法将 finalSum 进行拆分。\n所以返回空数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>finalSum = 28\n<b>输出：</b>[6,8,2,12]\n<b>解释：</b>以下是一些符合要求的拆分：<code>(2 + 26)<span style=\"\">，</span></code><code>(6 + 8 + 2 + 12)</code> 和 <code>(4 + 24) 。</code>\n<code>(6 + 8 + 2 + 12)</code> 有最多数目的整数，数目为 4 ，所以我们返回 [6,8,2,12] 。\n[10,2,4,12] ，[6,2,4,16] 等等也都是可行的解。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= finalSum &lt;= 10<sup>10</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2179统计数组中好三元组数目",
        "hardRate": "HARD",
        "passRate": "37.39%",
        "problemsUrl": "https://leetcode.cn/problems/count-good-triplets-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/count-good-triplets-in-an-array/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始且长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>&nbsp;，两者都是&nbsp;<code>[0, 1, ..., n - 1]</code>&nbsp;的&nbsp;<strong>排列</strong>&nbsp;。</p>\n\n<p><strong>好三元组&nbsp;</strong>指的是&nbsp;<code>3</code>&nbsp;个&nbsp;<strong>互不相同</strong>&nbsp;的值，且它们在数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;中出现顺序保持一致。换句话说，如果我们将&nbsp;<code>pos1<sub>v</sub></code> 记为值&nbsp;<code>v</code>&nbsp;在&nbsp;<code>nums1</code>&nbsp;中出现的位置，<code>pos2<sub>v</sub></code>&nbsp;为值&nbsp;<code>v</code>&nbsp;在&nbsp;<code>nums2</code>&nbsp;中的位置，那么一个好三元组定义为&nbsp;<code>0 &lt;= x, y, z &lt;= n - 1</code>&nbsp;，且&nbsp;<code>pos1<sub>x</sub> &lt; pos1<sub>y</sub> &lt; pos1<sub>z</sub></code> 和&nbsp;<code>pos2<sub>x</sub> &lt; pos2<sub>y</sub> &lt; pos2<sub>z</sub></code>&nbsp;都成立的&nbsp;<code>(x, y, z)</code>&nbsp;。</p>\n\n<p>请你返回好三元组的 <strong>总数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [2,0,1,3], nums2 = [0,1,2,3]\n<b>输出：</b>1\n<b>解释：</b>\n总共有 4 个三元组 (x,y,z) 满足 pos1<sub>x</sub> &lt; pos1<sub>y</sub> &lt; pos1<sub>z&nbsp;</sub>，分别是 (2,0,1) ，(2,0,3) ，(2,1,3) 和 (0,1,3) 。\n这些三元组中，只有 (0,1,3) 满足 pos2<sub>x</sub> &lt; pos2<sub>y</sub> &lt; pos2<sub>z</sub>&nbsp;。所以只有 1 个好三元组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]\n<b>输出：</b>4\n<b>解释：</b>总共有 4 个好三元组 (4,0,3) ，(4,0,2) ，(4,1,3) 和 (4,1,2) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length == nums2.length</code></li>\n\t<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= n - 1</code></li>\n\t<li><code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>&nbsp;是&nbsp;<code>[0, 1, ..., n - 1]</code> 的排列。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2180统计各位数字之和为偶数的整数个数",
        "hardRate": "EASY",
        "passRate": "67.98%",
        "problemsUrl": "https://leetcode.cn/problems/count-integers-with-even-digit-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/count-integers-with-even-digit-sum/solution",
        "problemsDesc": "<p>给你一个正整数 <code>num</code> ，请你统计并返回 <strong>小于或等于</strong> <code>num</code> 且各位数字之和为 <strong>偶数</strong> 的正整数的数目。</p>\n\n<p>正整数的 <strong>各位数字之和</strong> 是其所有位上的对应数字相加的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>\n只有 2 和 4 满足小于等于 4 且各位数字之和为偶数。    \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 30\n<strong>输出：</strong>14\n<strong>解释：</strong>\n只有 14 个整数满足小于等于 30 且各位数字之和为偶数，分别是： \n2、4、6、8、11、13、15、17、19、20、22、24、26 和 28 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2181合并零之间的节点",
        "hardRate": "MEDIUM",
        "passRate": "84.75%",
        "problemsUrl": "https://leetcode.cn/problems/merge-nodes-in-between-zeros/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-nodes-in-between-zeros/solution",
        "problemsDesc": "<p>给你一个链表的头节点 <code>head</code> ，该链表包含由 <code>0</code> 分隔开的一连串整数。链表的 <strong>开端</strong> 和 <strong>末尾</strong> 的节点都满足 <code>Node.val == 0</code> 。</p>\n\n<p>对于每两个相邻的 <code>0</code> ，请你将它们之间的所有节点合并成一个节点，其值是所有已合并节点的值之和。然后将所有 <code>0</code> 移除，修改后的链表不应该含有任何 <code>0</code> 。</p>\n\n<p>&nbsp;返回修改后链表的头节点 <code>head</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：<br />\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/02/ex1-1.png\" style=\"width: 600px; height: 41px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>head = [0,3,1,0,4,5,2,0]\n<strong>输出：</strong>[4,11]\n<strong>解释：</strong>\n上图表示输入的链表。修改后的链表包含：\n- 标记为绿色的节点之和：3 + 1 = 4\n- 标记为红色的节点之和：4 + 5 + 2 = 11\n</pre>\n\n<p><strong>示例 2：<br />\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/02/ex2-1.png\" style=\"width: 600px; height: 41px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>head = [0,1,0,3,0,2,2,0]\n<strong>输出：</strong>[1,3,4]\n<strong>解释：</strong>\n上图表示输入的链表。修改后的链表包含：\n- 标记为绿色的节点之和：1 = 1\n- 标记为红色的节点之和：3 = 3\n- 标记为黄色的节点之和：2 + 2 = 4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>列表中的节点数目在范围 <code>[3, 2 * 10<sup>5</sup>]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n\t<li><strong>不</strong> 存在连续两个&nbsp;<code>Node.val == 0</code> 的节点</li>\n\t<li>链表的 <strong>开端</strong> 和 <strong>末尾</strong> 节点都满足 <code>Node.val == 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2182构造限制重复的字符串",
        "hardRate": "MEDIUM",
        "passRate": "48.53%",
        "problemsUrl": "https://leetcode.cn/problems/construct-string-with-repeat-limit/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-string-with-repeat-limit/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和一个整数 <code>repeatLimit</code> ，用 <code>s</code> 中的字符构造一个新字符串 <code>repeatLimitedString</code> ，使任何字母 <strong>连续</strong> 出现的次数都不超过 <code>repeatLimit</code> 次。你不必使用 <code>s</code> 中的全部字符。</p>\n\n<p>返回 <strong>字典序最大的</strong><em> </em><code>repeatLimitedString</code> 。</p>\n\n<p>如果在字符串 <code>a</code> 和 <code>b</code> 不同的第一个位置，字符串 <code>a</code> 中的字母在字母表中出现时间比字符串 <code>b</code> 对应的字母晚，则认为字符串 <code>a</code> 比字符串 <code>b</code> <strong>字典序更大</strong> 。如果字符串中前 <code>min(a.length, b.length)</code> 个字符都相同，那么较长的字符串字典序更大。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"cczazcc\", repeatLimit = 3\n<strong>输出：</strong>\"zzcccac\"\n<strong>解释：</strong>使用 s 中的所有字符来构造 repeatLimitedString \"zzcccac\"。\n字母 'a' 连续出现至多 1 次。\n字母 'c' 连续出现至多 3 次。\n字母 'z' 连续出现至多 2 次。\n因此，没有字母连续出现超过 repeatLimit 次，字符串是一个有效的 repeatLimitedString 。\n该字符串是字典序最大的 repeatLimitedString ，所以返回 \"zzcccac\" 。\n注意，尽管 \"zzcccca\" 字典序更大，但字母 'c' 连续出现超过 3 次，所以它不是一个有效的 repeatLimitedString 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"aababab\", repeatLimit = 2\n<strong>输出：</strong>\"bbabaa\"\n<strong>解释：</strong>\n使用 s 中的一些字符来构造 repeatLimitedString \"bbabaa\"。 \n字母 'a' 连续出现至多 2 次。 \n字母 'b' 连续出现至多 2 次。 \n因此，没有字母连续出现超过 repeatLimit 次，字符串是一个有效的 repeatLimitedString 。 \n该字符串是字典序最大的 repeatLimitedString ，所以返回 \"bbabaa\" 。 \n注意，尽管 \"bbabaaa\" 字典序更大，但字母 'a' 连续出现超过 2 次，所以它不是一个有效的 repeatLimitedString 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= repeatLimit &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2183统计可以被 K 整除的下标对数目",
        "hardRate": "HARD",
        "passRate": "28.28%",
        "problemsUrl": "https://leetcode.cn/problems/count-array-pairs-divisible-by-k/",
        "solutionsUrl": "https://leetcode.cn/problems/count-array-pairs-divisible-by-k/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>nums</code> 和一个整数 <code>k</code> ，返回满足下述条件的下标对 <code>(i, j)</code> 的数目：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt;= n - 1</code> 且</li>\n\t<li><code>nums[i] * nums[j]</code> 能被 <code>k</code> 整除。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,5], k = 2\n<strong>输出：</strong>7\n<strong>解释：</strong>\n共有 7 对下标的对应积可以被 2 整除：\n(0, 1)、(0, 3)、(1, 2)、(1, 3)、(1, 4)、(2, 3) 和 (3, 4)\n它们的积分别是 2、4、6、8、10、12 和 20 。\n其他下标对，例如 (0, 2) 和 (2, 4) 的乘积分别是 3 和 15 ，都无法被 2 整除。    \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4], k = 5\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在对应积可以被 5 整除的下标对。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2184建造坚实的砖墙的方法数",
        "hardRate": "MEDIUM",
        "passRate": "55.17%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-build-sturdy-brick-wall/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-build-sturdy-brick-wall/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2185统计包含给定前缀的字符串",
        "hardRate": "EASY",
        "passRate": "81.59%",
        "problemsUrl": "https://leetcode.cn/problems/counting-words-with-a-given-prefix/",
        "solutionsUrl": "https://leetcode.cn/problems/counting-words-with-a-given-prefix/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>words</code> 和一个字符串 <code>pref</code> 。</p>\n\n<p>返回 <code>words</code><em> </em>中以 <code>pref</code> 作为 <strong>前缀</strong> 的字符串的数目。</p>\n\n<p>字符串 <code>s</code> 的 <strong>前缀</strong> 就是&nbsp; <code>s</code> 的任一前导连续字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"pay\",\"<em><strong>at</strong></em>tention\",\"practice\",\"<em><strong>at</strong></em>tend\"], <code>pref </code>= \"at\"\n<strong>输出：</strong>2\n<strong>解释：</strong>以 \"at\" 作为前缀的字符串有两个，分别是：\"<em><strong>at</strong></em>tention\" 和 \"<em><strong>at</strong></em>tend\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"leetcode\",\"win\",\"loops\",\"success\"], <code>pref </code>= \"code\"\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在以 \"code\" 作为前缀的字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length, pref.length &lt;= 100</code></li>\n\t<li><code>words[i]</code> 和 <code>pref</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2186使两字符串互为字母异位词的最少步骤数",
        "hardRate": "MEDIUM",
        "passRate": "72.65%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/solution",
        "problemsDesc": "<p>给你两个字符串 <code>s</code> 和 <code>t</code> 。在一步操作中，你可以给 <code>s</code> 或者 <code>t</code> 追加 <strong>任一字符</strong> 。</p>\n\n<p>返回使 <code>s</code> 和 <code>t</code> 互为 <strong>字母异位词</strong> 所需的最少步骤数<em>。</em></p>\n\n<p><strong>字母异位词 </strong>指字母相同但是顺序不同（或者相同）的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"<em><strong>lee</strong>t</em>co<em><strong>de</strong></em>\", t = \"co<em><strong>a</strong></em>t<em><strong>s</strong></em>\"\n<strong>输出：</strong>7\n<strong>解释：</strong>\n- 执行 2 步操作，将 \"as\" 追加到 s = \"leetcode\" 中，得到 s = \"leetcode<em><strong>as</strong></em>\" 。\n- 执行 5 步操作，将 \"leede\" 追加到 t = \"coats\" 中，得到 t = \"coats<em><strong>leede</strong></em>\" 。\n\"leetcodeas\" 和 \"coatsleede\" 互为字母异位词。\n总共用去 2 + 5 = 7 步。\n可以证明，无法用少于 7 步操作使这两个字符串互为字母异位词。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"night\", t = \"thing\"\n<strong>输出：</strong>0\n<strong>解释：</strong>给出的字符串已经互为字母异位词。因此，不需要任何进一步操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> 和 <code>t</code> 由小写英文字符组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2187完成旅途的最少时间",
        "hardRate": "MEDIUM",
        "passRate": "28.41%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-complete-trips/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-complete-trips/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>time</code>&nbsp;，其中&nbsp;<code>time[i]</code>&nbsp;表示第 <code>i</code>&nbsp;辆公交车完成 <strong>一趟</strong><strong>旅途</strong>&nbsp;所需要花费的时间。</p>\n\n<p>每辆公交车可以 <strong>连续</strong> 完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以 <strong>立马开始</strong>&nbsp;下一趟旅途。每辆公交车 <strong>独立</strong>&nbsp;运行，也就是说可以同时有多辆公交车在运行且互不影响。</p>\n\n<p>给你一个整数&nbsp;<code>totalTrips</code>&nbsp;，表示所有公交车&nbsp;<strong>总共</strong>&nbsp;需要完成的旅途数目。请你返回完成 <strong>至少</strong>&nbsp;<code>totalTrips</code>&nbsp;趟旅途需要花费的 <strong>最少</strong>&nbsp;时间。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>time = [1,2,3], totalTrips = 5\n<b>输出：</b>3\n<strong>解释：</strong>\n- 时刻 t = 1 ，每辆公交车完成的旅途数分别为 [1,0,0] 。\n  已完成的总旅途数为 1 + 0 + 0 = 1 。\n- 时刻 t = 2 ，每辆公交车完成的旅途数分别为 [2,1,0] 。\n  已完成的总旅途数为 2 + 1 + 0 = 3 。\n- 时刻 t = 3 ，每辆公交车完成的旅途数分别为 [3,1,1] 。\n  已完成的总旅途数为 3 + 1 + 1 = 5 。\n所以总共完成至少 5 趟旅途的最少时间为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>time = [2], totalTrips = 1\n<b>输出：</b>2\n<strong>解释：</strong>\n只有一辆公交车，它将在时刻 t = 2 完成第一趟旅途。\n所以完成 1 趟旅途的最少时间为 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= time.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= time[i], totalTrips &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2188完成比赛的最少时间",
        "hardRate": "HARD",
        "passRate": "44.35%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-finish-the-race/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-finish-the-race/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>tires</code>&nbsp;，其中&nbsp;<code>tires[i] = [f<sub>i</sub>, r<sub>i</sub>]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;种轮胎如果连续使用，第&nbsp;<code>x</code>&nbsp;圈需要耗时&nbsp;<code>f<sub>i</sub> * r<sub>i</sub><sup>(x-1)</sup></code>&nbsp;秒。</p>\n\n<ul>\n\t<li>比方说，如果&nbsp;<code>f<sub>i</sub> = 3</code>&nbsp;且&nbsp;<code>r<sub>i</sub> = 2</code>&nbsp;，且一直使用这种类型的同一条轮胎，那么该轮胎完成第&nbsp;<code>1</code>&nbsp;圈赛道耗时 <code>3</code>&nbsp;秒，完成第 <code>2</code>&nbsp;圈耗时&nbsp;<code>3 * 2 = 6</code>&nbsp;秒，完成第 <code>3</code>&nbsp;圈耗时&nbsp;<code>3 * 2<sup>2</sup> = 12</code>&nbsp;秒，依次类推。</li>\n</ul>\n\n<p>同时给你一个整数&nbsp;<code>changeTime</code>&nbsp;和一个整数&nbsp;<code>numLaps</code>&nbsp;。</p>\n\n<p>比赛总共包含&nbsp;<code>numLaps</code>&nbsp;圈，你可以选择 <strong>任意</strong>&nbsp;一种轮胎开始比赛。每一种轮胎都有 <strong>无数条</strong>&nbsp;。每一圈后，你可以选择耗费 <code>changeTime</code>&nbsp;秒 <strong>换成</strong>&nbsp;任意一种轮胎（也可以换成当前种类的新轮胎）。</p>\n\n<p>请你返回完成比赛需要耗费的 <strong>最少</strong>&nbsp;时间。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>tires = [[2,3],[3,4]], changeTime = 5, numLaps = 4\n<b>输出：</b>21\n<b>解释：</b>\n第 1 圈：使用轮胎 0 ，耗时 2 秒。\n第 2 圈：继续使用轮胎 0 ，耗时 2 * 3 = 6 秒。\n第 3 圈：耗费 5 秒换一条新的轮胎 0 ，然后耗时 2 秒完成这一圈。\n第 4 圈：继续使用轮胎 0 ，耗时 2 * 3 = 6 秒。\n总耗时 = 2 + 6 + 5 + 2 + 6 = 21 秒。\n完成比赛的最少时间为 21 秒。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>tires = [[1,10],[2,2],[3,4]], changeTime = 6, numLaps = 5\n<b>输出：</b>25\n<b>解释：</b>\n第 1 圈：使用轮胎 1 ，耗时 2 秒。\n第 2 圈：继续使用轮胎 1 ，耗时 2 * 2 = 4 秒。\n第 3 圈：耗时 6 秒换一条新的轮胎 1 ，然后耗时 2 秒完成这一圈。\n第 4 圈：继续使用轮胎 1 ，耗时 2 * 2 = 4 秒。\n第 5 圈：耗时 6 秒换成轮胎 0 ，然后耗时 1 秒完成这一圈。\n总耗时 = 2 + 4 + 6 + 2 + 4 + 6 + 1 = 25 秒。\n完成比赛的最少时间为 25 秒。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tires.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>tires[i].length == 2</code></li>\n\t<li><code>1 &lt;= f<sub>i</sub>, changeTime &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= r<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= numLaps &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2189建造纸牌屋的方法数",
        "hardRate": "MEDIUM",
        "passRate": "64.87%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-build-house-of-cards/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-build-house-of-cards/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2190数组中紧跟 key 之后出现最频繁的数字",
        "hardRate": "EASY",
        "passRate": "58.69%",
        "problemsUrl": "https://leetcode.cn/problems/most-frequent-number-following-key-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/most-frequent-number-following-key-in-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，同时给你一个整数&nbsp;<code>key</code>&nbsp;，它在&nbsp;<code>nums</code>&nbsp;出现过。</p>\n\n<p><strong>统计&nbsp;</strong>在 <code>nums</code>&nbsp;数组中紧跟着 <code>key</code>&nbsp;后面出现的不同整数&nbsp;<code>target</code>&nbsp;的出现次数。换言之，<code>target</code>&nbsp;的出现次数为满足以下条件的 <code>i</code>&nbsp;的数目：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt;= n - 2</code></li>\n\t<li><code>nums[i] == key</code>&nbsp;且</li>\n\t<li><code>nums[i + 1] == target</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回出现 <strong>最多</strong>&nbsp;次数的<em>&nbsp;</em><code>target</code>&nbsp;。测试数据保证出现次数最多的 <code>target</code>&nbsp;是唯一的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,100,200,1,100], key = 1\n<b>输出：</b>100\n<b>解释：</b>对于 target = 100 ，在下标 1 和 4 处出现过 2 次，且都紧跟着 key 。\n没有其他整数在 key 后面紧跟着出现，所以我们返回 100 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,2,2,2,3], key = 2\n<b>输出：</b>2\n<b>解释：</b>对于 target = 2 ，在下标 1 ，2 和 3 处出现过 3 次，且都紧跟着 key 。\n对于 target = 3 ，在下标 4 出出现过 1 次，且紧跟着 key 。\ntarget = 2 是紧跟着 key 之后出现次数最多的数字，所以我们返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>测试数据保证答案是唯一的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2191将杂乱无章的数字排序",
        "hardRate": "MEDIUM",
        "passRate": "43.53%",
        "problemsUrl": "https://leetcode.cn/problems/sort-the-jumbled-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-the-jumbled-numbers/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>mapping</code>&nbsp;，它表示一个十进制数的映射规则，<code>mapping[i] = j</code>&nbsp;表示这个规则下将数位&nbsp;<code>i</code>&nbsp;映射为数位 <code>j</code>&nbsp;。</p>\n\n<p>一个整数 <strong>映射后的值</strong>&nbsp;为将原数字每一个数位 <code>i</code>&nbsp;（<code>0 &lt;= i &lt;= 9</code>）映射为&nbsp;<code>mapping[i]</code>&nbsp;。</p>\n\n<p>另外给你一个整数数组&nbsp;<code>nums</code>&nbsp;，请你将数组<em>&nbsp;</em><code>nums</code>&nbsp;中每个数按照它们映射后对应数字非递减顺序排序后返回。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>如果两个数字映射后对应的数字大小相同，则将它们按照输入中的 <strong>相对顺序</strong>&nbsp;排序。</li>\n\t<li><code>nums</code>&nbsp;中的元素只有在排序的时候需要按照映射后的值进行比较，返回的值应该是输入的元素本身。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>mapping = [8,9,4,0,2,1,3,5,7,6], nums = [991,338,38]\n<b>输出：</b>[338,38,991]\n<b>解释：</b>\n将数字 991 按照如下规则映射：\n1. mapping[9] = 6 ，所有数位 9 都会变成 6 。\n2. mapping[1] = 9 ，所有数位 1 都会变成 8 。\n所以，991 映射的值为 669 。\n338 映射为 007 ，去掉前导 0 后得到 7 。\n38 映射为 07 ，去掉前导 0 后得到 7 。\n由于 338 和 38 映射后的值相同，所以它们的前后顺序保留原数组中的相对位置关系，338 在 38 的前面。\n所以，排序后的数组为 [338,38,991] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>mapping = [0,1,2,3,4,5,6,7,8,9], nums = [789,456,123]\n<b>输出：</b>[123,456,789]\n<b>解释：</b>789 映射为 789 ，456 映射为 456 ，123 映射为 123 。所以排序后数组为 [123,456,789] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>mapping.length == 10</code></li>\n\t<li><code>0 &lt;= mapping[i] &lt;= 9</code></li>\n\t<li><code>mapping[i]</code>&nbsp;的值 <strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt; 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2192有向无环图中一个节点的所有祖先",
        "hardRate": "MEDIUM",
        "passRate": "45.07%",
        "problemsUrl": "https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/solution",
        "problemsDesc": "<p>给你一个正整数&nbsp;<code>n</code>&nbsp;，它表示一个 <strong>有向无环图</strong>&nbsp;中节点的数目，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;（包括两者）。</p>\n\n<p>给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>]</code>&nbsp;表示图中一条从&nbsp;<code>from<sub>i</sub></code>&nbsp;到&nbsp;<code>to<sub>i</sub></code>&nbsp;的单向边。</p>\n\n<p>请你返回一个数组&nbsp;<code>answer</code>，其中<em>&nbsp;</em><code>answer[i]</code>是第&nbsp;<code>i</code>&nbsp;个节点的所有&nbsp;<strong>祖先</strong>&nbsp;，这些祖先节点&nbsp;<strong>升序</strong>&nbsp;排序。</p>\n\n<p>如果 <code>u</code>&nbsp;通过一系列边，能够到达 <code>v</code>&nbsp;，那么我们称节点 <code>u</code>&nbsp;是节点 <code>v</code>&nbsp;的 <strong>祖先</strong>&nbsp;节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/12/e1.png\" style=\"width: 322px; height: 265px;\"></p>\n\n<pre><b>输入：</b>n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]\n<b>输出：</b>[[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]\n<strong>解释：</strong>\n上图为输入所对应的图。\n- 节点 0 ，1 和 2 没有任何祖先。\n- 节点 3 有 2 个祖先 0 和 1 。\n- 节点 4 有 2 个祖先 0 和 2 。\n- 节点 5 有 3 个祖先 0 ，1 和 3 。\n- 节点 6 有 5 个祖先 0 ，1 ，2 ，3 和 4 。\n- 节点 7 有 4 个祖先 0 ，1 ，2 和 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/12/e2.png\" style=\"width: 343px; height: 299px;\"></p>\n\n<pre><b>输入：</b>n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n<b>输出：</b>[[],[0],[0,1],[0,1,2],[0,1,2,3]]\n<strong>解释：</strong>\n上图为输入所对应的图。\n- 节点 0 没有任何祖先。\n- 节点 1 有 1 个祖先 0 。\n- 节点 2 有 2 个祖先 0 和 1 。\n- 节点 3 有 3 个祖先 0 ，1 和 2 。\n- 节点 4 有 4 个祖先 0 ，1 ，2 和 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= edges.length &lt;= min(2000, n * (n - 1) / 2)</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>\n\t<li>图中不会有重边。</li>\n\t<li>图是 <strong>有向</strong> 且 <strong>无环</strong> 的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2193得到回文串的最少操作次数",
        "hardRate": "HARD",
        "passRate": "49.14%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-moves-to-make-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-moves-to-make-palindrome/solution",
        "problemsDesc": "<p>给你一个只包含小写英文字母的字符串&nbsp;<code>s</code>&nbsp;。</p>\n\n<p>每一次 <strong>操作</strong>&nbsp;，你可以选择 <code>s</code>&nbsp;中两个 <strong>相邻</strong>&nbsp;的字符，并将它们交换。</p>\n\n<p>请你返回将 <code>s</code>&nbsp;变成回文串的 <strong>最少操作次数</strong>&nbsp;。</p>\n\n<p><strong>注意</strong>&nbsp;，输入数据会确保&nbsp;<code>s</code>&nbsp;一定能变成一个回文串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"aabb\"\n<b>输出：</b>2\n<strong>解释：</strong>\n我们可以将 s 变成 2 个回文串，\"abba\" 和 \"baab\" 。\n- 我们可以通过 2 次操作得到 \"abba\" ：\"a<em><strong>ab</strong></em>b\" -&gt; \"ab<em><strong>ab</strong></em>\" -&gt; \"abba\" 。\n- 我们可以通过 2 次操作得到 \"baab\" ：\"a<em><strong>ab</strong></em>b\" -&gt; \"<em><strong>ab</strong></em>ab\" -&gt; \"baab\" 。\n因此，得到回文串的最少总操作次数为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"letelt\"\n<b>输出：</b>2\n<strong>解释：</strong>\n通过 2 次操作从 s 能得到回文串 \"lettel\" 。\n其中一种方法是：\"lete<em><strong>lt</strong></em>\" -&gt; \"let<em><strong>et</strong></em>l\" -&gt; \"lettel\" 。\n其他回文串比方说 \"tleelt\" 也可以通过 2 次操作得到。\n可以证明少于 2 次操作，无法得到回文串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n\t<li><code>s</code>&nbsp;可以通过有限次操作得到一个回文串。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2194Excel 表中某个范围内的单元格",
        "hardRate": "EASY",
        "passRate": "84.10%",
        "problemsUrl": "https://leetcode.cn/problems/cells-in-a-range-on-an-excel-sheet/",
        "solutionsUrl": "https://leetcode.cn/problems/cells-in-a-range-on-an-excel-sheet/solution",
        "problemsDesc": "<p>Excel 表中的一个单元格 <code>(r, c)</code> 会以字符串 <code>\"&lt;col&gt;&lt;row&gt;\"</code> 的形式进行表示，其中：</p>\n\n<ul>\n\t<li><code>&lt;col&gt;</code> 即单元格的列号 <code>c</code> 。用英文字母表中的 <strong>字母</strong> 标识。\n\n\t<ul>\n\t\t<li>例如，第 <code>1</code> 列用 <code>'A'</code> 表示，第 <code>2</code> 列用 <code>'B'</code> 表示，第 <code>3</code> 列用 <code>'C'</code> 表示，以此类推。</li>\n\t</ul>\n\t</li>\n\t<li><code>&lt;row&gt;</code> 即单元格的行号 <code>r</code> 。第 <code>r</code> 行就用 <strong>整数</strong> <code>r</code> 标识。</li>\n</ul>\n\n<p>给你一个格式为 <code>\"&lt;col1&gt;&lt;row1&gt;:&lt;col2&gt;&lt;row2&gt;\"</code> 的字符串 <code>s</code> ，其中 <code>&lt;col1&gt;</code> 表示 <code>c1</code> 列，<code>&lt;row1&gt;</code> 表示 <code>r1</code> 行，<code>&lt;col2&gt;</code> 表示 <code>c2</code> 列，<code>&lt;row2&gt;</code> 表示 <code>r2</code> 行，并满足 <code>r1 &lt;= r2</code> 且 <code>c1 &lt;= c2</code> 。</p>\n\n<p>找出所有满足&nbsp;<code>r1 &lt;= x &lt;= r2</code> 且 <code>c1 &lt;= y &lt;= c2</code> 的单元格，并以列表形式返回。单元格应该按前面描述的格式用 <strong>字符串</strong> 表示，并以 <strong>非递减</strong> 顺序排列（先按列排，再按行排）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/08/ex1drawio.png\" style=\"width: 250px; height: 160px;\" /></p>\n\n<pre>\n<strong>输入：</strong>s = \"K1:L2\"\n<strong>输出：</strong>[\"K1\",\"K2\",\"L1\",\"L2\"]\n<strong>解释：</strong>\n上图显示了列表中应该出现的单元格。\n红色箭头指示单元格的出现顺序。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/09/exam2drawio.png\" style=\"width: 500px; height: 50px;\" /></p>\n\n<pre>\n<strong>输入：</strong>s = \"A1:F1\"\n<strong>输出：</strong>[\"A1\",\"B1\",\"C1\",\"D1\",\"E1\",\"F1\"]\n<strong>解释：</strong>\n上图显示了列表中应该出现的单元格。 \n红色箭头指示单元格的出现顺序。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s.length == 5</code></li>\n\t<li><code>'A' &lt;= s[0] &lt;= s[3] &lt;= 'Z'</code></li>\n\t<li><code>'1' &lt;= s[1] &lt;= s[4] &lt;= '9'</code></li>\n\t<li><code>s</code> 由大写英文字母、数字、和 <code>':'</code> 组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2195向数组中追加 K 个整数",
        "hardRate": "MEDIUM",
        "passRate": "24.02%",
        "problemsUrl": "https://leetcode.cn/problems/append-k-integers-with-minimal-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/append-k-integers-with-minimal-sum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。请你向 <code>nums</code> 中追加 <code>k</code> 个 <strong>未</strong> 出现在 <code>nums</code> 中的、<strong>互不相同</strong> 的 <strong>正</strong> 整数，并使结果数组的元素和 <strong>最小</strong> 。</p>\n\n<p>返回追加到 <code>nums</code> 中的 <code>k</code> 个整数之和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,4,25,10,25], k = 2\n<strong>输出：</strong>5\n<strong>解释：</strong>在该解法中，向数组中追加的两个互不相同且未出现的正整数是 2 和 3 。\nnums 最终元素和为 1 + 4 + 25 + 10 + 25 + 2 + 3 = 70 ，这是所有情况中的最小值。\n所以追加到数组中的两个整数之和是 2 + 3 = 5 ，所以返回 5 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [5,6], k = 6\n<strong>输出：</strong>25\n<strong>解释：</strong>在该解法中，向数组中追加的两个互不相同且未出现的正整数是 1 、2 、3 、4 、7 和 8 。\nnums 最终元素和为 5 + 6 + 1 + 2 + 3 + 4 + 7 + 8 = 36 ，这是所有情况中的最小值。\n所以追加到数组中的两个整数之和是 1 + 2 + 3 + 4 + 7 + 8 = 25 ，所以返回 25 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2196根据描述创建二叉树",
        "hardRate": "MEDIUM",
        "passRate": "72.83%",
        "problemsUrl": "https://leetcode.cn/problems/create-binary-tree-from-descriptions/",
        "solutionsUrl": "https://leetcode.cn/problems/create-binary-tree-from-descriptions/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>descriptions</code> ，其中 <code>descriptions[i] = [parent<sub>i</sub>, child<sub>i</sub>, isLeft<sub>i</sub>]</code> 表示 <code>parent<sub>i</sub></code> 是 <code>child<sub>i</sub></code> 在 <strong>二叉树</strong> 中的 <strong>父节点</strong>，二叉树中各节点的值 <strong>互不相同</strong> 。此外：</p>\n\n<ul>\n\t<li>如果 <code>isLeft<sub>i</sub> == 1</code> ，那么 <code>child<sub>i</sub></code> 就是 <code>parent<sub>i</sub></code> 的左子节点。</li>\n\t<li>如果 <code>isLeft<sub>i</sub> == 0</code> ，那么 <code>child<sub>i</sub></code> 就是 <code>parent<sub>i</sub></code> 的右子节点。</li>\n</ul>\n\n<p>请你根据 <code>descriptions</code> 的描述来构造二叉树并返回其 <strong>根节点</strong> 。</p>\n\n<p>测试用例会保证可以构造出 <strong>有效</strong> 的二叉树。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/09/example1drawio.png\" style=\"width: 300px; height: 236px;\" /></p>\n\n<pre>\n<strong>输入：</strong>descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]\n<strong>输出：</strong>[50,20,80,15,17,19]\n<strong>解释：</strong>根节点是值为 50 的节点，因为它没有父节点。\n结果二叉树如上图所示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/09/example2drawio.png\" style=\"width: 131px; height: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>descriptions = [[1,2,1],[2,3,0],[3,4,1]]\n<strong>输出：</strong>[1,2,null,null,3,4]\n<strong>解释：</strong>根节点是值为 1 的节点，因为它没有父节点。 \n结果二叉树如上图所示。 </pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= descriptions.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>descriptions[i].length == 3</code></li>\n\t<li><code>1 &lt;= parent<sub>i</sub>, child<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= isLeft<sub>i</sub> &lt;= 1</code></li>\n\t<li><code>descriptions</code> 所描述的二叉树是一棵有效二叉树</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2197替换数组中的非互质数",
        "hardRate": "HARD",
        "passRate": "34.66%",
        "problemsUrl": "https://leetcode.cn/problems/replace-non-coprime-numbers-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/replace-non-coprime-numbers-in-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 。请你对数组执行下述操作：</p>\n\n<ol>\n\t<li>从 <code>nums</code> 中找出 <strong>任意</strong> 两个 <strong>相邻</strong> 的 <strong>非互质</strong> 数。</li>\n\t<li>如果不存在这样的数，<strong>终止</strong> 这一过程。</li>\n\t<li>否则，删除这两个数，并 <strong>替换</strong> 为它们的 <strong>最小公倍数</strong>（Least Common Multiple，LCM）。</li>\n\t<li>只要还能找出两个相邻的非互质数就继续 <strong>重复</strong> 这一过程。</li>\n</ol>\n\n<p>返回修改后得到的 <strong>最终</strong> 数组。可以证明的是，以 <strong>任意</strong> 顺序替换相邻的非互质数都可以得到相同的结果。</p>\n\n<p>生成的测试用例可以保证最终数组中的值 <strong>小于或者等于</strong> <code>10<sup>8</sup></code> 。</p>\n\n<p>两个数字 <code>x</code> 和 <code>y</code> 满足 <strong>非互质数</strong> 的条件是：<code>GCD(x, y) &gt; 1</code> ，其中 <code>GCD(x, y)</code> 是 <code>x</code> 和 <code>y</code> 的 <strong>最大公约数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [6,4,3,2,7,6,2]\n<strong>输出：</strong>[12,7,6]\n<strong>解释：</strong>\n- (6, 4) 是一组非互质数，且 LCM(6, 4) = 12 。得到 nums = [<em><strong>12</strong></em>,3,2,7,6,2] 。\n- (12, 3) 是一组非互质数，且 LCM(12, 3) = 12 。得到 nums = [<em><strong>12</strong></em>,2,7,6,2] 。\n- (12, 2) 是一组非互质数，且 LCM(12, 2) = 12 。得到 nums = [<em><strong>12</strong></em>,7,6,2] 。\n- (6, 2) 是一组非互质数，且 LCM(6, 2) = 6 。得到 nums = [12,7,<em><strong>6</strong></em>] 。\n现在，nums 中不存在相邻的非互质数。\n因此，修改后得到的最终数组是 [12,7,6] 。\n注意，存在其他方法可以获得相同的最终数组。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,1,1,3,3,3]\n<strong>输出：</strong>[2,1,1,3]\n<strong>解释：</strong>\n- (3, 3) 是一组非互质数，且 LCM(3, 3) = 3 。得到 nums = [2,2,1,1,<em><strong>3</strong></em>,3] 。\n- (3, 3) 是一组非互质数，且 LCM(3, 3) = 3 。得到 nums = [2,2,1,1,<em><strong>3</strong></em>] 。\n- (2, 2) 是一组非互质数，且 LCM(2, 2) = 2 。得到 nums = [<em><strong>2</strong></em>,1,1,3] 。\n现在，nums 中不存在相邻的非互质数。 \n因此，修改后得到的最终数组是 [2,1,1,3] 。 \n注意，存在其他方法可以获得相同的最终数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li>生成的测试用例可以保证最终数组中的值 <strong>小于或者等于</strong> <code>10<sup>8</sup></code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2198单因数三元组",
        "hardRate": "MEDIUM",
        "passRate": "57.53%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-single-divisor-triplets/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-single-divisor-triplets/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2199找到每篇文章的主题",
        "hardRate": "HARD",
        "passRate": "59.48%",
        "problemsUrl": "https://leetcode.cn/problems/finding-the-topic-of-each-post/",
        "solutionsUrl": "https://leetcode.cn/problems/finding-the-topic-of-each-post/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2200找出数组中的所有 K 近邻下标",
        "hardRate": "EASY",
        "passRate": "53.77%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-k-distant-indices-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-k-distant-indices-in-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和两个整数 <code>key</code> 和 <code>k</code> 。<strong>K 近邻下标</strong> 是 <code>nums</code> 中的一个下标 <code>i</code> ，并满足至少存在一个下标 <code>j</code> 使得 <code>|i - j| &lt;= k</code> 且 <code>nums[j] == key</code> 。</p>\n\n<p>以列表形式返回按 <strong>递增顺序</strong> 排序的所有 K 近邻下标。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,9,1,3,9,5], key = 9, k = 1\n<strong>输出：</strong>[1,2,3,4,5,6]\n<strong>解释：</strong>因此，<code>nums[2] == key</code> 且 <code>nums[5] == key 。\n- 对下标 0 ，|0 - 2| &gt; k 且 |0 - 5| &gt; k ，所以不存在 j</code> 使得 <code>|0 - j| &lt;= k</code> 且 <code>nums[j] == key 。所以 0 不是一个 K 近邻下标。\n- 对下标 1 ，|1 - 2| &lt;= k 且 nums[2] == key ，所以 1 是一个 K 近邻下标。\n- 对下标 2 ，|2 - 2| &lt;= k 且 nums[2] == key ，所以 2 是一个 K 近邻下标。\n- 对下标 3 ，|3 - 2| &lt;= k 且 nums[2] == key ，所以 3 是一个 K 近邻下标。\n- 对下标 4 ，|4 - 5| &lt;= k 且 nums[5] == key ，所以 4 是一个 K 近邻下标。\n- 对下标 5 ，|5 - 5| &lt;= k 且 nums[5] == key ，所以 5 是一个 K 近邻下标。\n- 对下标 6 ，|6 - 5| &lt;= k 且 nums[5] == key ，所以 6 是一个 K 近邻下标。\n</code>因此，按递增顺序返回 [1,2,3,4,5,6] 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,2,2,2], key = 2, k = 2\n<strong>输出：</strong>[0,1,2,3,4]\n<strong>解释：</strong>对 nums 的所有下标 i ，总存在某个下标 j 使得 |i - j| &lt;= k 且 nums[j] == key ，所以每个下标都是一个 <code>K 近邻下标。</code> \n因此，返回 [0,1,2,3,4] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>key</code> 是数组 <code>nums</code> 中的一个整数</li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2201统计可以提取的工件",
        "hardRate": "MEDIUM",
        "passRate": "49.40%",
        "problemsUrl": "https://leetcode.cn/problems/count-artifacts-that-can-be-extracted/",
        "solutionsUrl": "https://leetcode.cn/problems/count-artifacts-that-can-be-extracted/solution",
        "problemsDesc": "<p>存在一个 <code>n x n</code> 大小、下标从 <strong>0</strong> 开始的网格，网格中埋着一些工件。给你一个整数 <code>n</code> 和一个下标从 <strong>0</strong> 开始的二维整数数组 <code>artifacts</code> ，<code>artifacts</code> 描述了矩形工件的位置，其中 <code>artifacts[i] = [r1<sub>i</sub>, c1<sub>i</sub>, r2<sub>i</sub>, c2<sub>i</sub>]</code> 表示第 <code>i</code> 个工件在子网格中的填埋情况：</p>\n\n<ul>\n\t<li><code>(r1<sub>i</sub>, c1<sub>i</sub>)</code> 是第 <code>i</code> 个工件 <strong>左上</strong> 单元格的坐标，且</li>\n\t<li><code>(r2<sub>i</sub>, c2<sub>i</sub>)</code> 是第 <code>i</code> 个工件 <strong>右下</strong> 单元格的坐标。</li>\n</ul>\n\n<p>你将会挖掘网格中的一些单元格，并清除其中的填埋物。如果单元格中埋着工件的一部分，那么该工件这一部分将会裸露出来。如果一个工件的所有部分都都裸露出来，你就可以提取该工件。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>dig</code> ，其中 <code>dig[i] = [r<sub>i</sub>, c<sub>i</sub>]</code> 表示你将会挖掘单元格 <code>(r<sub>i</sub>, c<sub>i</sub>)</code> ，返回你可以提取的工件数目。</p>\n\n<p>生成的测试用例满足：</p>\n\n<ul>\n\t<li>不存在重叠的两个工件。</li>\n\t<li>每个工件最多只覆盖 <code>4</code> 个单元格。</li>\n\t<li><code>dig</code> 中的元素互不相同。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/16/untitled-diagram.jpg\" style=\"width: 216px; height: 216px;\">\n<pre><strong>输入：</strong>n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1]]\n<strong>输出：</strong>1\n<strong>解释：</strong> \n不同颜色表示不同的工件。挖掘的单元格用 'D' 在网格中进行标记。\n有 1 个工件可以提取，即红色工件。\n蓝色工件在单元格 (1,1) 的部分尚未裸露出来，所以无法提取该工件。\n因此，返回 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/16/untitled-diagram-1.jpg\" style=\"width: 216px; height: 216px;\">\n<pre><strong>输入：</strong>n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1],[1,1]]\n<strong>输出：</strong>2\n<strong>解释：</strong>红色工件和蓝色工件的所有部分都裸露出来（用 'D' 标记），都可以提取。因此，返回 2 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= artifacts.length, dig.length &lt;= min(n<sup>2</sup>, 10<sup>5</sup>)</code></li>\n\t<li><code>artifacts[i].length == 4</code></li>\n\t<li><code>dig[i].length == 2</code></li>\n\t<li><code>0 &lt;= r1<sub>i</sub>, c1<sub>i</sub>, r2<sub>i</sub>, c2<sub>i</sub>, r<sub>i</sub>, c<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>r1<sub>i</sub> &lt;= r2<sub>i</sub></code></li>\n\t<li><code>c1<sub>i</sub> &lt;= c2<sub>i</sub></code></li>\n\t<li>不存在重叠的两个工件</li>\n\t<li>每个工件 <strong>最多</strong> 只覆盖 <code>4</code> 个单元格</li>\n\t<li><code>dig</code> 中的元素互不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2202K 次操作后最大化顶端元素",
        "hardRate": "MEDIUM",
        "passRate": "21.67%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-the-topmost-element-after-k-moves/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-the-topmost-element-after-k-moves/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，它表示一个 <strong>栈</strong> ，其中 <code>nums[0]</code>&nbsp;是栈顶的元素。</p>\n\n<p>每一次操作中，你可以执行以下操作 <strong>之一</strong>&nbsp;：</p>\n\n<ul>\n\t<li>如果栈非空，那么 <strong>删除</strong>&nbsp;栈顶端的元素。</li>\n\t<li>如果存在 1 个或者多个被删除的元素，你可以从它们中选择任何一个，<b>添加</b>&nbsp;回栈顶，这个元素成为新的栈顶元素。</li>\n</ul>\n\n<p>同时给你一个整数&nbsp;<code>k</code>&nbsp;，它表示你总共需要执行操作的次数。</p>\n\n<p>请你返回 <strong>恰好</strong>&nbsp;执行 <code>k</code>&nbsp;次操作以后，栈顶元素的 <strong>最大值</strong>&nbsp;。如果执行完 <code>k</code>&nbsp;次操作以后，栈一定为空，请你返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5,2,2,4,0,6], k = 4\n<b>输出：</b>5\n<strong>解释：</strong>\n4 次操作后，栈顶元素为 5 的方法之一为：\n- 第 1 次操作：删除栈顶元素 5 ，栈变为 [2,2,4,0,6] 。\n- 第 2 次操作：删除栈顶元素 2 ，栈变为 [2,4,0,6] 。\n- 第 3 次操作：删除栈顶元素 2 ，栈变为 [4,0,6] 。\n- 第 4 次操作：将 5 添加回栈顶，栈变为 [5,4,0,6] 。\n注意，这不是最后栈顶元素为 5 的唯一方式。但可以证明，4 次操作以后 5 是能得到的最大栈顶元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2], k = 1\n<b>输出：</b>-1\n<b>解释：</b>\n第 1 次操作中，我们唯一的选择是将栈顶元素弹出栈。\n由于 1 次操作后无法得到一个非空的栈，所以我们返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i], k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2203得到要求路径的最小带权子图",
        "hardRate": "HARD",
        "passRate": "37.75%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-weighted-subgraph-with-the-required-paths/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-weighted-subgraph-with-the-required-paths/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;，它表示一个 <strong>带权有向</strong> 图的节点数，节点编号为&nbsp;<code>0</code> 到&nbsp;<code>n - 1</code>&nbsp;。</p>\n\n<p>同时给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>, weight<sub>i</sub>]</code>&nbsp;，表示从&nbsp;<code>from<sub>i</sub></code>&nbsp;到&nbsp;<code>to<sub>i</sub></code>&nbsp;有一条边权为&nbsp;<code>weight<sub>i</sub></code>&nbsp;的 <strong>有向</strong> 边。</p>\n\n<p>最后，给你三个 <strong>互不相同</strong>&nbsp;的整数&nbsp;<code>src1</code>&nbsp;，<code>src2</code>&nbsp;和&nbsp;<code>dest</code>&nbsp;，表示图中三个不同的点。</p>\n\n<p>请你从图中选出一个 <b>边权和最小</b>&nbsp;的子图，使得从 <code>src1</code>&nbsp;和 <code>src2</code>&nbsp;出发，在这个子图中，都 <strong>可以</strong>&nbsp;到达 <code>dest</code>&nbsp;。如果这样的子图不存在，请返回 <code>-1</code>&nbsp;。</p>\n\n<p><strong>子图</strong>&nbsp;中的点和边都应该属于原图的一部分。子图的边权和定义为它所包含的所有边的权值之和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/17/example1drawio.png\" style=\"width: 263px; height: 250px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5\n<b>输出：</b>9\n<strong>解释：</strong>\n上图为输入的图。\n蓝色边为最优子图之一。\n注意，子图 [[1,0,3],[0,5,6]] 也能得到最优解，但无法在满足所有限制的前提下，得到更优解。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/17/example2-1drawio.png\" style=\"width: 350px; height: 51px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2\n<b>输出：</b>-1\n<strong>解释：</strong>\n上图为输入的图。\n可以看到，不存在从节点 1 到节点 2 的路径，所以不存在任何子图满足所有限制。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub>, src1, src2, dest &lt;= n - 1</code></li>\n\t<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>\n\t<li><code>src1</code>&nbsp;，<code>src2</code>&nbsp;和&nbsp;<code>dest</code>&nbsp;两两不同。</li>\n\t<li><code>1 &lt;= weight[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2204无向图中到环的距离",
        "hardRate": "HARD",
        "passRate": "75.45%",
        "problemsUrl": "https://leetcode.cn/problems/distance-to-a-cycle-in-undirected-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/distance-to-a-cycle-in-undirected-graph/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2205有资格享受折扣的用户数量",
        "hardRate": "EASY",
        "passRate": "44.66%",
        "problemsUrl": "https://leetcode.cn/problems/the-number-of-users-that-are-eligible-for-discount/",
        "solutionsUrl": "https://leetcode.cn/problems/the-number-of-users-that-are-eligible-for-discount/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2206将数组划分成相等数对",
        "hardRate": "EASY",
        "passRate": "73.88%",
        "problemsUrl": "https://leetcode.cn/problems/divide-array-into-equal-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-array-into-equal-pairs/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;，它包含&nbsp;<code>2 * n</code>&nbsp;个整数。</p>\n\n<p>你需要将&nbsp;<code>nums</code> 划分成&nbsp;<code>n</code>&nbsp;个数对，满足：</p>\n\n<ul>\n\t<li>每个元素 <strong>只属于一个 </strong>数对。</li>\n\t<li>同一数对中的元素 <strong>相等</strong>&nbsp;。</li>\n</ul>\n\n<p>如果可以将 <code>nums</code>&nbsp;划分成 <code>n</code>&nbsp;个数对，请你返回 <code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,2,3,2,2,2]\n<b>输出：</b>true\n<b>解释：</b>\nnums<code>&nbsp;中总共有 6 个元素，所以它们应该被划分成</code> 6 / 2 = 3 个数对。\nnums 可以划分成 (2, 2) ，(3, 3) 和 (2, 2) ，满足所有要求。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4]\n<b>输出：</b>false\n<b>解释：</b>\n无法将 nums 划分成 4 / 2 = 2 个数对且满足所有要求。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length == 2 * n</code></li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 500</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2207字符串中最多数目的子字符串",
        "hardRate": "MEDIUM",
        "passRate": "31.54%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-number-of-subsequences-in-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-number-of-subsequences-in-a-string/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>text</code>&nbsp;和另一个下标从 <strong>0</strong>&nbsp;开始且长度为 <code>2</code>&nbsp;的字符串&nbsp;<code>pattern</code>&nbsp;，两者都只包含小写英文字母。</p>\n\n<p>你可以在 <code>text</code>&nbsp;中任意位置插入 <strong>一个</strong> 字符，这个插入的字符必须是&nbsp;<code>pattern[0]</code>&nbsp;<b>或者</b>&nbsp;<code>pattern[1]</code>&nbsp;。注意，这个字符可以插入在 <code>text</code>&nbsp;开头或者结尾的位置。</p>\n\n<p>请你返回插入一个字符后，<code>text</code>&nbsp;中最多包含多少个等于 <code>pattern</code>&nbsp;的 <strong>子序列</strong>&nbsp;。</p>\n\n<p><strong>子序列</strong> 指的是将一个字符串删除若干个字符后（也可以不删除），剩余字符保持原本顺序得到的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>text = \"abdcdbc\", pattern = \"ac\"\n<b>输出：</b>4\n<strong>解释：</strong>\n如果我们在 text[1] 和 text[2] 之间添加 pattern[0] = 'a' ，那么我们得到 \"ab<em><strong>a</strong></em>dcdbc\" 。那么 \"ac\" 作为子序列出现 4 次。\n其他得到 4 个 \"ac\" 子序列的方案还有 \"<em><strong>a</strong></em>abdcdbc\" 和 \"abd<em><strong>a</strong></em>cdbc\" 。\n但是，\"abdc<em><strong>a</strong></em>dbc\" ，\"abd<em><strong>c</strong></em>cdbc\" 和 \"abdcdbc<em><strong>c</strong></em>\" 这些字符串虽然是可行的插入方案，但是只出现了 3 次 \"ac\" 子序列，所以不是最优解。\n可以证明插入一个字符后，无法得到超过 4 个 \"ac\" 子序列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>text = \"aabb\", pattern = \"ab\"\n<b>输出：</b>6\n<strong>解释：</strong>\n可以得到 6 个 \"ab\" 子序列的部分方案为 \"<em><strong>a</strong></em>aabb\" ，\"aa<em><strong>a</strong></em>bb\" 和 \"aab<em><strong>b</strong></em>b\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pattern.length == 2</code></li>\n\t<li><code>text</code> 和&nbsp;<code>pattern</code>&nbsp;都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2208将数组和减半的最少操作次数",
        "hardRate": "MEDIUM",
        "passRate": "40.90%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-operations-to-halve-array-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-operations-to-halve-array-sum/solution",
        "problemsDesc": "<p>给你一个正整数数组&nbsp;<code>nums</code>&nbsp;。每一次操作中，你可以从&nbsp;<code>nums</code>&nbsp;中选择 <strong>任意</strong>&nbsp;一个数并将它减小到 <strong>恰好</strong>&nbsp;一半。（注意，在后续操作中你可以对减半过的数继续执行操作）</p>\n\n<p>请你返回将 <code>nums</code>&nbsp;数组和 <strong>至少</strong>&nbsp;减少一半的 <strong>最少</strong>&nbsp;操作数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [5,19,8,1]\n<b>输出：</b>3\n<b>解释：</b>初始 nums 的和为 5 + 19 + 8 + 1 = 33 。\n以下是将数组和减少至少一半的一种方法：\n选择数字 19 并减小为 9.5 。\n选择数字 9.5 并减小为 4.75 。\n选择数字 8 并减小为 4 。\n最终数组为 [5, 4.75, 4, 1] ，和为 5 + 4.75 + 4 + 1 = 14.75 。\nnums 的和减小了 33 - 14.75 = 18.25 ，减小的部分超过了初始数组和的一半，18.25 &gt;= 33/2 = 16.5 。\n我们需要 3 个操作实现题目要求，所以返回 3 。\n可以证明，无法通过少于 3 个操作使数组和减少至少一半。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [3,8,20]\n<b>输出：</b>3\n<strong>解释：</strong>初始 nums 的和为 3 + 8 + 20 = 31 。\n以下是将数组和减少至少一半的一种方法：\n选择数字 20 并减小为 10 。\n选择数字 10 并减小为 5 。\n选择数字 3 并减小为 1.5 。\n最终数组为 [1.5, 8, 5] ，和为 1.5 + 8 + 5 = 14.5 。\nnums 的和减小了 31 - 14.5 = 16.5 ，减小的部分超过了初始数组和的一半， 16.5 &gt;= 31/2 = 16.5 。\n我们需要 3 个操作实现题目要求，所以返回 3 。\n可以证明，无法通过少于 3 个操作使数组和减少至少一半。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2209用地毯覆盖后的最少白色砖块",
        "hardRate": "HARD",
        "passRate": "39.16%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-white-tiles-after-covering-with-carpets/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-white-tiles-after-covering-with-carpets/solution",
        "problemsDesc": "<p>给你一个下标从<strong>&nbsp;0</strong>&nbsp;开始的 <strong>二进制</strong>&nbsp;字符串&nbsp;<code>floor</code>&nbsp;，它表示地板上砖块的颜色。</p>\n\n<ul>\n\t<li><code>floor[i] = '0'</code>&nbsp;表示地板上第&nbsp;<code>i</code>&nbsp;块砖块的颜色是 <strong>黑色</strong>&nbsp;。</li>\n\t<li><code>floor[i] = '1'</code>&nbsp;表示地板上第&nbsp;<code>i</code>&nbsp;块砖块的颜色是 <strong>白色</strong>&nbsp;。</li>\n</ul>\n\n<p>同时给你&nbsp;<code>numCarpets</code> 和&nbsp;<code>carpetLen</code>&nbsp;。你有&nbsp;<code>numCarpets</code>&nbsp;条&nbsp;<strong>黑色</strong>&nbsp;的地毯，每一条&nbsp;<strong>黑色</strong>&nbsp;的地毯长度都为&nbsp;<code>carpetLen</code>&nbsp;块砖块。请你使用这些地毯去覆盖砖块，使得未被覆盖的剩余 <strong>白色</strong>&nbsp;砖块的数目 <strong>最小</strong>&nbsp;。地毯相互之间可以覆盖。</p>\n\n<p>请你返回没被覆盖的白色砖块的 <strong>最少</strong>&nbsp;数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/10/ex1-1.png\" style=\"width: 400px; height: 73px;\"></p>\n\n<pre><b>输入：</b>floor = \"10110101\", numCarpets = 2, carpetLen = 2\n<b>输出：</b>2\n<b>解释：</b>\n上图展示了剩余 2 块白色砖块的方案。\n没有其他方案可以使未被覆盖的白色砖块少于 2 块。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/10/ex2.png\" style=\"width: 353px; height: 123px;\"></p>\n\n<pre><b>输入：</b>floor = \"11111\", numCarpets = 2, carpetLen = 3\n<b>输出：</b>0\n<b>解释：</b>\n上图展示了所有白色砖块都被覆盖的一种方案。\n注意，地毯相互之间可以覆盖。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= carpetLen &lt;= floor.length &lt;= 1000</code></li>\n\t<li><code>floor[i]</code> 要么是&nbsp;<code>'0'</code>&nbsp;，要么是&nbsp;<code>'1'</code>&nbsp;。</li>\n\t<li><code>1 &lt;= numCarpets &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2210统计数组中峰和谷的数量",
        "hardRate": "EASY",
        "passRate": "58.71%",
        "problemsUrl": "https://leetcode.cn/problems/count-hills-and-valleys-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/count-hills-and-valleys-in-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。如果两侧距 <code>i</code> 最近的不相等邻居的值均小于 <code>nums[i]</code> ，则下标 <code>i</code> 是 <code>nums</code> 中，某个峰的一部分。类似地，如果两侧距 <code>i</code> 最近的不相等邻居的值均大于 <code>nums[i]</code> ，则下标 <code>i</code> 是 <code>nums</code> 中某个谷的一部分。对于相邻下标&nbsp;<code>i</code> 和 <code>j</code> ，如果&nbsp;<code>nums[i] == nums[j]</code> ， 则认为这两下标属于 <strong>同一个</strong> 峰或谷。</p>\n\n<p>注意，要使某个下标所做峰或谷的一部分，那么它左右两侧必须 <strong>都</strong> 存在不相等邻居。</p>\n\n<p>返回 <code>nums</code> 中峰和谷的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,4,1,1,6,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n在下标 0 ：由于 2 的左侧不存在不相等邻居，所以下标 0 既不是峰也不是谷。\n在下标 1 ：4 的最近不相等邻居是 2 和 1 。由于 4 &gt; 2 且 4 &gt; 1 ，下标 1 是一个峰。\n在下标 2 ：1 的最近不相等邻居是 4 和 6 。由于 1 &lt; 4 且 1 &lt; 6 ，下标 2 是一个谷。\n在下标 3 ：1 的最近不相等邻居是 4 和 6 。由于 1 &lt; 4 且 1 &lt; 6 ，下标 3 符合谷的定义，但需要注意它和下标 2 是同一个谷的一部分。\n在下标 4 ：6 的最近不相等邻居是 1 和 5 。由于 6 &gt; 1 且 6 &gt; 5 ，下标 4 是一个峰。\n在下标 5 ：由于 5 的右侧不存在不相等邻居，所以下标 5 既不是峰也不是谷。\n共有 3 个峰和谷，所以返回 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [6,6,5,5,4,1]\n<strong>输出：</strong>0\n<strong>解释：</strong>\n在下标 0 ：由于 6 的左侧不存在不相等邻居，所以下标 0 既不是峰也不是谷。\n在下标 1 ：由于 6 的左侧不存在不相等邻居，所以下标 1 既不是峰也不是谷。\n在下标 2 ：5 的最近不相等邻居是 6 和 4 。由于 5 &lt; 6 且 5 &gt; 4 ，下标 2 既不是峰也不是谷。\n在下标 3 ：5 的最近不相等邻居是 6 和 4 。由于 5 &lt; 6 且 5 &gt; 4 ，下标 3 既不是峰也不是谷。\n在下标 4 ：4 的最近不相等邻居是 5 和 1 。由于 4 &lt; 5 且 4 &gt; 1 ，下标 4 既不是峰也不是谷。\n在下标 5 ：由于 1 的右侧不存在不相等邻居，所以下标 5 既不是峰也不是谷。\n共有 0 个峰和谷，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2211统计道路上的碰撞次数",
        "hardRate": "MEDIUM",
        "passRate": "41.03%",
        "problemsUrl": "https://leetcode.cn/problems/count-collisions-on-a-road/",
        "solutionsUrl": "https://leetcode.cn/problems/count-collisions-on-a-road/solution",
        "problemsDesc": "<p>在一条无限长的公路上有 <code>n</code> 辆汽车正在行驶。汽车按从左到右的顺序按从 <code>0</code> 到 <code>n - 1</code> 编号，每辆车都在一个 <strong>独特的</strong> 位置。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>directions</code> ，长度为 <code>n</code> 。<code>directions[i]</code> 可以是 <code>'L'</code>、<code>'R'</code> 或 <code>'S'</code> 分别表示第 <code>i</code> 辆车是向 <strong>左</strong> 、向 <strong>右</strong> 或者 <strong>停留</strong> 在当前位置。每辆车移动时 <strong>速度相同</strong> 。</p>\n\n<p>碰撞次数可以按下述方式计算：</p>\n\n<ul>\n\t<li>当两辆移动方向&nbsp;<strong>相反</strong>&nbsp;的车相撞时，碰撞次数加 <code>2</code> 。</li>\n\t<li>当一辆移动的车和一辆静止的车相撞时，碰撞次数加 <code>1</code> 。</li>\n</ul>\n\n<p>碰撞发生后，涉及的车辆将无法继续移动并停留在碰撞位置。除此之外，汽车不能改变它们的状态或移动方向。</p>\n\n<p>返回在这条道路上发生的 <strong>碰撞总次数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>directions = \"RLRSLL\"\n<strong>输出：</strong>5\n<strong>解释：</strong>\n将会在道路上发生的碰撞列出如下：\n- 车 0 和车 1 会互相碰撞。由于它们按相反方向移动，碰撞数量变为 0 + 2 = 2 。\n- 车 2 和车 3 会互相碰撞。由于 3 是静止的，碰撞数量变为 2 + 1 = 3 。\n- 车 3 和车 4 会互相碰撞。由于 3 是静止的，碰撞数量变为 3 + 1 = 4 。\n- 车 4 和车 5 会互相碰撞。在车 4 和车 3 碰撞之后，车 4 会待在碰撞位置，接着和车 5 碰撞。碰撞数量变为 4 + 1 = 5 。\n因此，将会在道路上发生的碰撞总次数是 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>directions = \"LLRR\"\n<strong>输出：</strong>0\n<strong>解释：</strong>\n不存在会发生碰撞的车辆。因此，将会在道路上发生的碰撞总次数是 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= directions.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>directions[i]</code> 的值为 <code>'L'</code>、<code>'R'</code> 或 <code>'S'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2212射箭比赛中的最大得分",
        "hardRate": "MEDIUM",
        "passRate": "47.84%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-points-in-an-archery-competition/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-points-in-an-archery-competition/solution",
        "problemsDesc": "<p>Alice 和 Bob 是一场射箭比赛中的对手。比赛规则如下：</p>\n\n<ol>\n\t<li>Alice 先射 <code>numArrows</code> 支箭，然后 Bob 也射 <code>numArrows</code> 支箭。</li>\n\t<li>分数按下述规则计算：\n\t<ol>\n\t\t<li>箭靶有若干整数计分区域，范围从 <code>0</code> 到 <code>11</code> （含 <code>0</code> 和 <code>11</code>）。</li>\n\t\t<li>箭靶上每个区域都对应一个得分 <code>k</code>（范围是 <code>0</code> 到 <code>11</code>），Alice 和 Bob 分别在得分 <code>k</code>&nbsp;区域射中&nbsp;<code>a<sub>k</sub></code> 和 <code>b<sub>k</sub></code> 支箭。如果 <code>a<sub>k</sub> &gt;= b<sub>k</sub></code> ，那么 Alice 得 <code>k</code> 分。如果 <code>a<sub>k</sub> &lt; b<sub>k</sub></code> ，则 Bob 得 <code>k</code> 分</li>\n\t\t<li>如果 <code>a<sub>k</sub> == b<sub>k</sub> == 0</code> ，那么无人得到 <code>k</code> 分。</li>\n\t</ol>\n\t</li>\n</ol>\n\n<ul>\n\t<li>\n\t<p>例如，Alice 和 Bob 都向计分为 <code>11</code> 的区域射 <code>2</code> 支箭，那么 Alice 得 <code>11</code> 分。如果 Alice 向计分为 <code>11</code> 的区域射 <code>0</code> 支箭，但 Bob 向同一个区域射 <code>2</code> 支箭，那么 Bob 得&nbsp;<code>11</code> 分。</p>\n\t</li>\n</ul>\n\n<p>给你整数 <code>numArrows</code> 和一个长度为 <code>12</code> 的整数数组 <code>aliceArrows</code> ，该数组表示 Alice 射中&nbsp;<code>0</code> 到 <code>11</code> 每个计分区域的箭数量。现在，Bob 想要尽可能 <strong>最大化</strong> 他所能获得的总分。</p>\n\n<p>返回数组 <code>bobArrows</code><em> </em>，该数组表示 Bob 射中&nbsp;<code>0</code> 到 <code>11</code> <strong>每个</strong> 计分区域的箭数量。且 <code>bobArrows</code> 的总和应当等于 <code>numArrows</code> 。</p>\n\n<p>如果存在多种方法都可以使 Bob 获得最大总分，返回其中 <strong>任意一种</strong> 即可。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1647744752-kQKrXw-image.png\" style=\"width: 600px; height: 120px;\" /></p>\n\n<pre>\n<strong>输入：</strong>numArrows = 9, aliceArrows = [1,1,0,1,0,0,2,1,0,1,2,0]\n<strong>输出：</strong>[0,0,0,0,1,1,0,0,1,2,3,1]\n<strong>解释：</strong>上表显示了比赛得分情况。\nBob 获得总分 4 + 5 + 8 + 9 + 10 + 11 = 47 。\n可以证明 Bob 无法获得比 47 更高的分数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1647744785-cMHzaC-image.png\" style=\"width: 600px; height: 117px;\" /></p>\n\n<pre>\n<strong>输入：</strong>numArrows = 3, aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]\n<strong>输出：</strong>[0,0,0,0,0,0,0,0,1,1,1,0]\n<strong>解释：</strong>上表显示了比赛得分情况。\nBob 获得总分 8 + 9 + 10 = 27 。\n可以证明 Bob 无法获得比 27 更高的分数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numArrows &lt;= 10<sup>5</sup></code></li>\n\t<li><code>aliceArrows.length == bobArrows.length == 12</code></li>\n\t<li><code>0 &lt;= aliceArrows[i], bobArrows[i] &lt;= numArrows</code></li>\n\t<li><code>sum(aliceArrows[i]) == numArrows</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2213由单个字符重复的最长子字符串",
        "hardRate": "HARD",
        "passRate": "40.62%",
        "problemsUrl": "https://leetcode.cn/problems/longest-substring-of-one-repeating-character/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-substring-of-one-repeating-character/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> 。另给你一个下标从 <strong>0</strong> 开始、长度为 <code>k</code> 的字符串 <code>queryCharacters</code> ，一个下标从 <code>0</code> 开始、长度也是 <code>k</code> 的整数 <strong>下标</strong> 数组&nbsp;<code>queryIndices</code> ，这两个都用来描述 <code>k</code> 个查询。</p>\n\n<p>第 <code>i</code> 个查询会将 <code>s</code> 中位于下标 <code>queryIndices[i]</code> 的字符更新为 <code>queryCharacters[i]</code> 。</p>\n\n<p>返回一个长度为 <code>k</code> 的数组 <code>lengths</code> ，其中 <code>lengths[i]</code> 是在执行第 <code>i</code> 个查询 <strong>之后</strong> <code>s</code> 中仅由 <strong>单个字符重复</strong> 组成的 <strong>最长子字符串</strong> 的 <strong>长度</strong> <em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"babacc\", queryCharacters = \"bcb\", queryIndices = [1,3,3]\n<strong>输出：</strong>[3,3,4]\n<strong>解释：</strong>\n- 第 1 次查询更新后 s = \"<em>b<strong>b</strong>b</em>acc\" 。由单个字符重复组成的最长子字符串是 \"bbb\" ，长度为 3 。\n- 第 2 次查询更新后 s = \"bbb<em><strong>c</strong>cc</em>\" 。由单个字符重复组成的最长子字符串是 \"bbb\" 或 \"ccc\"，长度为 3 。\n- 第 3 次查询更新后 s = \"<em>bbb<strong>b</strong></em>cc\" 。由单个字符重复组成的最长子字符串是 \"bbbb\" ，长度为 4 。\n因此，返回 [3,3,4] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abyzz\", queryCharacters = \"aa\", queryIndices = [2,1]\n<strong>输出：</strong>[2,3]\n<strong>解释：</strong>\n- 第 1 次查询更新后 s = \"ab<strong>a</strong><em>zz</em>\" 。由单个字符重复组成的最长子字符串是 \"zz\" ，长度为 2 。\n- 第 2 次查询更新后 s = \"<em>a<strong>a</strong>a</em>zz\" 。由单个字符重复组成的最长子字符串是 \"aaa\" ，长度为 3 。\n因此，返回 [2,3] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n\t<li><code>k == queryCharacters.length == queryIndices.length</code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queryCharacters</code> 由小写英文字母组成</li>\n\t<li><code>0 &lt;= queryIndices[i] &lt; s.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2214通关游戏所需的最低生命值",
        "hardRate": "MEDIUM",
        "passRate": "55.39%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-health-to-beat-game/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-health-to-beat-game/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2215找出两数组的不同",
        "hardRate": "EASY",
        "passRate": "66.88%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-difference-of-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-difference-of-two-arrays/solution",
        "problemsDesc": "<p>给你两个下标从 <code>0</code> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，请你返回一个长度为 <code>2</code> 的列表 <code>answer</code> ，其中：</p>\n\n<ul>\n\t<li><code>answer[0]</code> 是 <code>nums1</code> 中所有<strong> 不 </strong>存在于 <code>nums2</code> 中的 <strong>不同</strong> 整数组成的列表。</li>\n\t<li><code>answer[1]</code> 是 <code>nums2</code> 中所有<strong> 不 </strong>存在于 <code>nums1</code> 中的 <strong>不同</strong> 整数组成的列表。</li>\n</ul>\n\n<p><strong>注意：</strong>列表中的整数可以按 <strong>任意</strong> 顺序返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2,3], nums2 = [2,4,6]\n<strong>输出：</strong>[[1,3],[4,6]]\n<strong>解释：\n</strong>对于 nums1 ，nums1[1] = 2 出现在 nums2 中下标 0 处，然而 nums1[0] = 1 和 nums1[2] = 3 没有出现在 nums2 中。因此，answer[0] = [1,3]。\n对于 nums2 ，nums2[0] = 2 出现在 nums1 中下标 1 处，然而 nums2[1] = 4 和 nums2[2] = 6 没有出现在 nums2 中。因此，answer[1] = [4,6]。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2,3,3], nums2 = [1,1,2,2]\n<strong>输出：</strong>[[3],[]]\n<strong>解释：\n</strong>对于 nums1 ，nums1[2] 和 nums1[3] 没有出现在 nums2 中。由于 nums1[2] == nums1[3] ，二者的值只需要在 answer[0] 中出现一次，故 answer[0] = [3]。\nnums2 中的每个整数都在 nums1 中出现，因此，answer[1] = [] 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2216美化数组的最少删除数",
        "hardRate": "MEDIUM",
        "passRate": "48.63%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-array-beautiful/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-array-beautiful/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，如果满足下述条件，则认为数组 <code>nums</code> 是一个 <strong>美丽数组</strong> ：</p>\n\n<ul>\n\t<li><code>nums.length</code> 为偶数</li>\n\t<li>对所有满足 <code>i % 2 == 0</code> 的下标 <code>i</code> ，<code>nums[i] != nums[i + 1]</code> 均成立</li>\n</ul>\n\n<p>注意，空数组同样认为是美丽数组。</p>\n\n<p>你可以从 <code>nums</code> 中删除任意数量的元素。当你删除一个元素时，被删除元素右侧的所有元素将会向左移动一个单位以填补空缺，而左侧的元素将会保持 <strong>不变</strong> 。</p>\n\n<p>返回使 <code>nums</code> 变为美丽数组所需删除的 <strong>最少</strong> 元素数目<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,2,3,5]\n<strong>输出：</strong>1\n<strong>解释：</strong>可以删除 <code>nums[0]</code> 或 <code>nums[1]</code> ，这样得到的 <code>nums</code> = [1,2,3,5] 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 1 个元素。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,2,2,3,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>可以删除 <code>nums[0]</code> 和 <code>nums[5]</code> ，这样得到的 nums = [1,2,2,3] 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 2 个元素。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2217找到指定长度的回文数",
        "hardRate": "MEDIUM",
        "passRate": "33.65%",
        "problemsUrl": "https://leetcode.cn/problems/find-palindrome-with-fixed-length/",
        "solutionsUrl": "https://leetcode.cn/problems/find-palindrome-with-fixed-length/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>queries</code>&nbsp;和一个 <strong>正</strong>&nbsp;整数&nbsp;<code>intLength</code>&nbsp;，请你返回一个数组&nbsp;<code>answer</code>&nbsp;，其中&nbsp;<code>answer[i]</code> 是长度为&nbsp;<code>intLength</code>&nbsp;的&nbsp;<strong>正回文数</strong> 中第<em>&nbsp;</em><code>queries[i]</code>&nbsp;小的数字，如果不存在这样的回文数，则为 <code>-1</code>&nbsp;。</p>\n\n<p><strong>回文数</strong> 指的是从前往后和从后往前读一模一样的数字。回文数不能有前导 0 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>queries = [1,2,3,4,5,90], intLength = 3\n<b>输出：</b>[101,111,121,131,141,999]\n<strong>解释：</strong>\n长度为 3 的最小回文数依次是：\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, ...\n第 90 个长度为 3 的回文数是 999 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>queries = [2,4,6], intLength = 4\n<b>输出：</b>[1111,1331,1551]\n<strong>解释：</strong>\n长度为 4 的前 6 个回文数是：\n1001, 1111, 1221, 1331, 1441 和 1551 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= queries.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= queries[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= intLength&nbsp;&lt;= 15</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2218从栈中取出 K 个硬币的最大面值和",
        "hardRate": "HARD",
        "passRate": "55.31%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-value-of-k-coins-from-piles/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-value-of-k-coins-from-piles/solution",
        "problemsDesc": "<p>一张桌子上总共有 <code>n</code>&nbsp;个硬币 <b>栈</b>&nbsp;。每个栈有 <strong>正整数</strong>&nbsp;个带面值的硬币。</p>\n\n<p>每一次操作中，你可以从任意一个栈的 <strong>顶部</strong>&nbsp;取出 1 个硬币，从栈中移除它，并放入你的钱包里。</p>\n\n<p>给你一个列表&nbsp;<code>piles</code>&nbsp;，其中&nbsp;<code>piles[i]</code>&nbsp;是一个整数数组，分别表示第 <code>i</code>&nbsp;个栈里 <strong>从顶到底</strong>&nbsp;的硬币面值。同时给你一个正整数&nbsp;<code>k</code>&nbsp;，请你返回在&nbsp;<strong>恰好</strong>&nbsp;进行&nbsp;<code>k</code>&nbsp;次操作的前提下，你钱包里硬币面值之和&nbsp;<strong>最大为多少</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/09/e1.png\" style=\"width: 600px; height: 243px;\" /></p>\n\n<pre>\n<b>输入：</b>piles = [[1,100,3],[7,8,9]], k = 2\n<b>输出：</b>101\n<strong>解释：</strong>\n上图展示了几种选择 k 个硬币的不同方法。\n我们可以得到的最大面值为 101 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7\n<b>输出：</b>706\n<strong>解释：\n</strong>如果我们所有硬币都从最后一个栈中取，可以得到最大面值和。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == piles.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= piles[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= sum(piles[i].length) &lt;= 2000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2219数组的最大总分",
        "hardRate": "MEDIUM",
        "passRate": "64.06%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-score-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-score-of-array/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2220转换数字的最少位翻转次数",
        "hardRate": "EASY",
        "passRate": "82.61%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-bit-flips-to-convert-number/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-bit-flips-to-convert-number/solution",
        "problemsDesc": "<p>一次 <strong>位翻转</strong>&nbsp;定义为将数字&nbsp;<code>x</code>&nbsp;二进制中的一个位进行 <strong>翻转</strong>&nbsp;操作，即将&nbsp;<code>0</code>&nbsp;变成&nbsp;<code>1</code>&nbsp;，或者将&nbsp;<code>1</code>&nbsp;变成&nbsp;<code>0</code>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，<code>x = 7</code>&nbsp;，二进制表示为&nbsp;<code>111</code>&nbsp;，我们可以选择任意一个位（包含没有显示的前导 0 ）并进行翻转。比方说我们可以翻转最右边一位得到&nbsp;<code>110</code>&nbsp;，或者翻转右边起第二位得到&nbsp;<code>101</code>&nbsp;，或者翻转右边起第五位（这一位是前导 0 ）得到&nbsp;<code>10111</code>&nbsp;等等。</li>\n</ul>\n\n<p>给你两个整数&nbsp;<code>start</code> 和&nbsp;<code>goal</code>&nbsp;，请你返回将&nbsp;<code>start</code>&nbsp;转变成&nbsp;<code>goal</code>&nbsp;的&nbsp;<strong>最少位翻转</strong>&nbsp;次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>start = 10, goal = 7\n<b>输出：</b>3\n<b>解释：</b>10 和 7 的二进制表示分别为 1010 和 0111 。我们可以通过 3 步将 10 转变成 7 ：\n- 翻转右边起第一位得到：101<strong><em>0</em></strong> -&gt; 101<strong><em>1 。</em></strong>\n- 翻转右边起第三位：1<strong><em>0</em></strong>11 -&gt; 1<strong><em>1</em></strong>11 。\n- 翻转右边起第四位：<strong><em>1</em></strong>111 -&gt; <strong><em>0</em></strong>111 。\n我们无法在 3 步内将 10 转变成 7 。所以我们返回 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>start = 3, goal = 4\n<b>输出：</b>3\n<b>解释：</b>3 和 4 的二进制表示分别为 011 和 100 。我们可以通过 3 步将 3 转变成 4 ：\n- 翻转右边起第一位：01<strong><em>1</em></strong> -&gt; 01<em><strong>0 </strong></em>。\n- 翻转右边起第二位：0<strong><em>1</em></strong>0 -&gt; 0<strong><em>0</em></strong>0 。\n- 翻转右边起第三位：<strong><em>0</em></strong>00 -&gt; <strong><em>1</em></strong>00 。\n我们无法在 3 步内将 3 变成 4 。所以我们返回 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= start, goal &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2221数组的三角和",
        "hardRate": "MEDIUM",
        "passRate": "79.74%",
        "problemsUrl": "https://leetcode.cn/problems/find-triangular-sum-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-triangular-sum-of-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，其中&nbsp;<code>nums[i]</code>&nbsp;是 <code>0</code>&nbsp;到 <code>9</code>&nbsp;之间（两者都包含）的一个数字。</p>\n\n<p><code>nums</code>&nbsp;的 <strong>三角和</strong>&nbsp;是执行以下操作以后最后剩下元素的值：</p>\n\n<ol>\n\t<li><code>nums</code>&nbsp;初始包含&nbsp;<code>n</code>&nbsp;个元素。如果&nbsp;<code>n == 1</code>&nbsp;，<strong>终止</strong>&nbsp;操作。否则，<strong>创建</strong>&nbsp;一个新的下标从&nbsp;<strong>0</strong>&nbsp;开始的长度为 <code>n - 1</code>&nbsp;的整数数组&nbsp;<code>newNums</code>&nbsp;。</li>\n\t<li>对于满足&nbsp;<code>0 &lt;= i &lt;&nbsp;n - 1</code>&nbsp;的下标&nbsp;<code>i</code>&nbsp;，<code>newNums[i]</code> <strong>赋值</strong>&nbsp;为&nbsp;<code>(nums[i] + nums[i+1]) % 10</code>&nbsp;，<code>%</code>&nbsp;表示取余运算。</li>\n\t<li>将&nbsp;<code>newNums</code>&nbsp;<strong>替换</strong> 数组&nbsp;<code>nums</code>&nbsp;。</li>\n\t<li>从步骤 1 开始&nbsp;<strong>重复</strong>&nbsp;整个过程。</li>\n</ol>\n\n<p>请你返回&nbsp;<code>nums</code>&nbsp;的三角和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/22/ex1drawio.png\" style=\"width: 250px; height: 250px;\" /></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4,5]\n<b>输出：</b>8\n<strong>解释：</strong>\n上图展示了得到数组三角和的过程。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [5]\n<b>输出：</b>5\n<b>解释：</b>\n由于 nums 中只有一个元素，数组的三角和为这个元素自己。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2222选择建筑的方案数",
        "hardRate": "MEDIUM",
        "passRate": "49.92%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-select-buildings/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-select-buildings/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二进制字符串&nbsp;<code>s</code>&nbsp;，它表示一条街沿途的建筑类型，其中：</p>\n\n<ul>\n\t<li><code>s[i] = '0'</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;栋建筑是一栋办公楼，</li>\n\t<li><code>s[i] = '1'</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;栋建筑是一间餐厅。</li>\n</ul>\n\n<p>作为市政厅的官员，你需要随机<strong>&nbsp;选择</strong>&nbsp;3 栋建筑。然而，为了确保多样性，选出来的 3 栋建筑 <strong>相邻</strong>&nbsp;的两栋不能是同一类型。</p>\n\n<ul>\n\t<li>比方说，给你&nbsp;<code>s = \"0<em><strong>0</strong></em>1<em><strong>1</strong></em>0<em><strong>1</strong></em>\"</code>&nbsp;，我们不能选择第&nbsp;<code>1</code>&nbsp;，<code>3</code>&nbsp;和&nbsp;<code>5</code>&nbsp;栋建筑，因为得到的子序列是&nbsp;<code>\"0<em><strong>11</strong></em>\"</code>&nbsp;，有相邻两栋建筑是同一类型，所以 <strong>不合</strong>&nbsp;题意。</li>\n</ul>\n\n<p>请你返回可以选择 3 栋建筑的 <strong>有效方案数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"001101\"\n<b>输出：</b>6\n<b>解释：</b>\n以下下标集合是合法的：\n- [0,2,4] ，从 \"<em><strong>0</strong></em>0<em><strong>1</strong></em>1<em><strong>0</strong></em>1\" 得到 \"010\"\n- [0,3,4] ，从 \"<em><strong>0</strong></em>01<em><strong>10</strong></em>1\" 得到 \"010\"\n- [1,2,4] ，从 \"0<em><strong>01</strong></em>1<em><strong>0</strong></em>1\" 得到 \"010\"\n- [1,3,4] ，从 \"0<em><strong>0</strong></em>1<em><strong>10</strong></em>1\" 得到 \"010\"\n- [2,4,5] ，从 \"00<em><strong>1</strong></em>1<em><strong>01</strong></em>\" 得到 \"101\"\n- [3,4,5] ，从 \"001<em><strong>101</strong></em>\" 得到 \"101\"\n没有别的合法选择，所以总共有 6 种方法。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"11100\"\n<b>输出：</b>0\n<b>解释：</b>没有任何符合题意的选择。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code>&nbsp;要么是&nbsp;<code>'0'</code>&nbsp;，要么是&nbsp;<code>'1'</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2223构造字符串的总得分和",
        "hardRate": "HARD",
        "passRate": "38.36%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-scores-of-built-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-scores-of-built-strings/solution",
        "problemsDesc": "<p>你需要从空字符串开始&nbsp;<strong>构造</strong> 一个长度为 <code>n</code>&nbsp;的字符串 <code>s</code>&nbsp;，构造的过程为每次给当前字符串 <strong>前面</strong>&nbsp;添加 <strong>一个</strong> 字符。构造过程中得到的所有字符串编号为 <code>1</code>&nbsp;到 <code>n</code>&nbsp;，其中长度为 <code>i</code>&nbsp;的字符串编号为 <code>s<sub>i</sub></code>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，<code>s = \"abaca\"</code>&nbsp;，<code>s<sub>1</sub> == \"a\"</code>&nbsp;，<code>s<sub>2</sub> == \"ca\"</code>&nbsp;，<code>s<sub>3</sub> == \"aca\"</code>&nbsp;依次类推。</li>\n</ul>\n\n<p><code>s<sub>i</sub></code>&nbsp;的 <strong>得分</strong>&nbsp;为&nbsp;<code>s<sub>i</sub></code> 和&nbsp;<code>s<sub>n</sub></code>&nbsp;的 <strong>最长公共前缀</strong> 的长度（注意&nbsp;<code>s == s<sub>n</sub></code>&nbsp;）。</p>\n\n<p>给你最终的字符串&nbsp;<code>s</code>&nbsp;，请你返回每一个<em>&nbsp;</em><code>s<sub>i</sub></code>&nbsp;的&nbsp;<strong>得分之和</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"babab\"\n<b>输出：</b>9\n<b>解释：</b>\ns<sub>1</sub> == \"b\" ，最长公共前缀是 \"b\" ，得分为 1 。\ns<sub>2</sub> == \"ab\" ，没有公共前缀，得分为 0 。\ns<sub>3</sub> == \"bab\" ，最长公共前缀为 \"bab\" ，得分为 3 。\ns<sub>4</sub> == \"abab\" ，没有公共前缀，得分为 0 。\ns<sub>5</sub> == \"babab\" ，最长公共前缀为 \"babab\" ，得分为 5 。\n得分和为 1 + 0 + 3 + 0 + 5 = 9 ，所以我们返回 9 。</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"azbazbzaz\"\n<b>输出：</b>14\n<b>解释：</b>\ns<sub>2</sub> == \"az\" ，最长公共前缀为 \"az\" ，得分为 2 。\ns<sub>6</sub> == \"azbzaz\" ，最长公共前缀为 \"azb\" ，得分为 3 。\ns<sub>9</sub> == \"azbazbzaz\" ，最长公共前缀为 \"azbazbzaz\" ，得分为 9 。\n其他 s<sub>i</sub> 得分均为 0 。\n得分和为 2 + 3 + 9 = 14 ，所以我们返回 14 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2224转化时间需要的最少操作数",
        "hardRate": "EASY",
        "passRate": "69.39%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-convert-time/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-convert-time/solution",
        "problemsDesc": "<p>给你两个字符串 <code>current</code> 和 <code>correct</code> ，表示两个 <strong>24 小时制时间</strong> 。</p>\n\n<p><strong>24 小时制时间</strong> 按 <code>\"HH:MM\"</code> 进行格式化，其中 <code>HH</code> 在 <code>00</code> 和 <code>23</code> 之间，而 <code>MM</code> 在 <code>00</code> 和 <code>59</code> 之间。最早的 24 小时制时间为 <code>00:00</code> ，最晚的是 <code>23:59</code> 。</p>\n\n<p>在一步操作中，你可以将 <code>current</code> 这个时间增加 <code>1</code>、<code>5</code>、<code>15</code> 或 <code>60</code> 分钟。你可以执行这一操作 <strong>任意</strong> 次数。</p>\n\n<p>返回将&nbsp;<code>current</code><em> </em>转化为<em> </em><code>correct</code> 需要的 <strong>最少操作数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>current = \"02:30\", correct = \"04:35\"\n<strong>输出：</strong>3\n<strong>解释：\n</strong>可以按下述 3 步操作将 current 转换为 correct ：\n- 为 current 加 60 分钟，current 变为 \"03:30\" 。\n- 为 current 加 60 分钟，current 变为 \"04:30\" 。 \n- 为 current 加 5 分钟，current 变为 \"04:35\" 。\n可以证明，无法用少于 3 步操作将 current 转化为 correct 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>current = \"11:00\", correct = \"11:01\"\n<strong>输出：</strong>1\n<strong>解释：</strong>只需要为 current 加一分钟，所以最小操作数是 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>current</code> 和 <code>correct</code> 都符合 <code>\"HH:MM\"</code> 格式</li>\n\t<li><code>current &lt;= correct</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2225找出输掉零场或一场比赛的玩家",
        "hardRate": "MEDIUM",
        "passRate": "62.99%",
        "problemsUrl": "https://leetcode.cn/problems/find-players-with-zero-or-one-losses/",
        "solutionsUrl": "https://leetcode.cn/problems/find-players-with-zero-or-one-losses/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>matches</code> 其中 <code>matches[i] = [winner<sub>i</sub>, loser<sub>i</sub>]</code> 表示在一场比赛中 <code>winner<sub>i</sub></code> 击败了 <code>loser<sub>i</sub></code> 。</p>\n\n<p>返回一个长度为 2 的列表<em> </em><code>answer</code> ：</p>\n\n<ul>\n\t<li><code>answer[0]</code> 是所有 <strong>没有</strong> 输掉任何比赛的玩家列表。</li>\n\t<li><code>answer[1]</code> 是所有恰好输掉 <strong>一场</strong> 比赛的玩家列表。</li>\n</ul>\n\n<p>两个列表中的值都应该按 <strong>递增</strong> 顺序返回。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>只考虑那些参与 <strong>至少一场</strong> 比赛的玩家。</li>\n\t<li>生成的测试用例保证 <strong>不存在</strong> 两场比赛结果 <strong>相同</strong> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]\n<strong>输出：</strong>[[1,2,10],[4,5,7,8]]\n<strong>解释：</strong>\n玩家 1、2 和 10 都没有输掉任何比赛。\n玩家 4、5、7 和 8 每个都输掉一场比赛。\n玩家 3、6 和 9 每个都输掉两场比赛。\n因此，answer[0] = [1,2,10] 和 answer[1] = [4,5,7,8] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>matches = [[2,3],[1,3],[5,4],[6,4]]\n<strong>输出：</strong>[[1,2,5,6],[]]\n<strong>解释：</strong>\n玩家 1、2、5 和 6 都没有输掉任何比赛。\n玩家 3 和 4 每个都输掉两场比赛。\n因此，answer[0] = [1,2,5,6] 和 answer[1] = [] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= matches.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>matches[i].length == 2</code></li>\n\t<li><code>1 &lt;= winner<sub>i</sub>, loser<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>winner<sub>i</sub> != loser<sub>i</sub></code></li>\n\t<li>所有 <code>matches[i]</code> <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2226每个小孩最多能分到多少糖果",
        "hardRate": "MEDIUM",
        "passRate": "34.17%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/solution",
        "problemsDesc": "<p>给你一个 <strong>下标从 0 开始</strong> 的整数数组 <code>candies</code> 。数组中的每个元素表示大小为 <code>candies[i]</code> 的一堆糖果。你可以将每堆糖果分成任意数量的 <strong>子堆</strong> ，但 <strong>无法</strong> 再将两堆合并到一起。</p>\n\n<p>另给你一个整数 <code>k</code> 。你需要将这些糖果分配给 <code>k</code> 个小孩，使每个小孩分到 <strong>相同</strong> 数量的糖果。每个小孩可以拿走 <strong>至多一堆</strong> 糖果，有些糖果可能会不被分配。</p>\n\n<p>返回每个小孩可以拿走的 <strong>最大糖果数目</strong><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>candies = [5,8,6], k = 3\n<strong>输出：</strong>5\n<strong>解释：</strong>可以将 candies[1] 分成大小分别为 5 和 3 的两堆，然后把 candies[2] 分成大小分别为 5 和 1 的两堆。现在就有五堆大小分别为 5、5、3、5 和 1 的糖果。可以把 3 堆大小为 5 的糖果分给 3 个小孩。可以证明无法让每个小孩得到超过 5 颗糖果。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>candies = [2,5], k = 11\n<strong>输出：</strong>0\n<strong>解释：</strong>总共有 11 个小孩，但只有 7 颗糖果，但如果要分配糖果的话，必须保证每个小孩至少能得到 1 颗糖果。因此，最后每个小孩都没有得到糖果，答案是 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= candies.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= candies[i] &lt;= 10<sup>7</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>12</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2227加密解密字符串",
        "hardRate": "HARD",
        "passRate": "39.53%",
        "problemsUrl": "https://leetcode.cn/problems/encrypt-and-decrypt-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/encrypt-and-decrypt-strings/solution",
        "problemsDesc": "<p>给你一个字符数组 <code>keys</code> ，由若干 <strong>互不相同</strong> 的字符组成。还有一个字符串数组 <code>values</code> ，内含若干长度为 2 的字符串。另给你一个字符串数组 <code>dictionary</code> ，包含解密后所有允许的原字符串。请你设计并实现一个支持加密及解密下标从 <strong>0</strong> 开始字符串的数据结构。</p>\n\n<p>字符串 <strong>加密</strong> 按下述步骤进行：</p>\n\n<ol>\n\t<li>对字符串中的每个字符 <code>c</code> ，先从 <code>keys</code> 中找出满足 <code>keys[i] == c</code> 的下标 <code>i</code> 。</li>\n\t<li>在字符串中，用&nbsp;<code>values[i]</code> 替换字符 <code>c</code> 。</li>\n</ol>\n\n<p>字符串 <strong>解密</strong> 按下述步骤进行：</p>\n\n<ol>\n\t<li>将字符串每相邻 2 个字符划分为一个子字符串，对于每个子字符串 <code>s</code> ，找出满足 <code>values[i] == s</code> 的一个下标 <code>i</code> 。如果存在多个有效的 <code>i</code> ，从中选择 <strong>任意</strong> 一个。这意味着一个字符串解密可能得到多个解密字符串。</li>\n\t<li>在字符串中，用 <code>keys[i]</code> 替换 <code>s</code> 。</li>\n</ol>\n\n<p>实现 <code>Encrypter</code> 类：</p>\n\n<ul>\n\t<li><code>Encrypter(char[] keys, String[] values, String[] dictionary)</code> 用 <code>keys</code>、<code>values</code> 和 <code>dictionary</code> 初始化 <code>Encrypter</code> 类。</li>\n\t<li><code>String encrypt(String word1)</code> 按上述加密过程完成对 <code>word1</code> 的加密，并返回加密后的字符串。</li>\n\t<li><code>int decrypt(String word2)</code> 统计并返回可以由 <code>word2</code> 解密得到且出现在 <code>dictionary</code> 中的字符串数目。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"Encrypter\", \"encrypt\", \"decrypt\"]\n[[['a', 'b', 'c', 'd'], [\"ei\", \"zf\", \"ei\", \"am\"], [\"abcd\", \"acbd\", \"adbc\", \"badc\", \"dacb\", \"cadb\", \"cbda\", \"abad\"]], [\"abcd\"], [\"eizfeiam\"]]\n<strong>输出：</strong>\n[null, \"eizfeiam\", 2]\n\n<strong>解释：</strong>\nEncrypter encrypter = new Encrypter([['a', 'b', 'c', 'd'], [\"ei\", \"zf\", \"ei\", \"am\"], [\"abcd\", \"acbd\", \"adbc\", \"badc\", \"dacb\", \"cadb\", \"cbda\", \"abad\"]);\nencrypter.encrypt(\"abcd\"); // 返回 \"eizfeiam\"。 \n&nbsp;                          // 'a' 映射为 \"ei\"，'b' 映射为 \"zf\"，'c' 映射为 \"ei\"，'d' 映射为 \"am\"。\nencrypter.decrypt(\"eizfeiam\"); // return 2. \n                              // \"ei\" 可以映射为 'a' 或 'c'，\"zf\" 映射为 'b'，\"am\" 映射为 'd'。 \n                              // 因此，解密后可以得到的字符串是 \"abad\"，\"cbad\"，\"abcd\" 和 \"cbcd\"。 \n                              // 其中 2 个字符串，\"abad\" 和 \"abcd\"，在 dictionary 中出现，所以答案是 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= keys.length == values.length &lt;= 26</code></li>\n\t<li><code>values[i].length == 2</code></li>\n\t<li><code>1 &lt;= dictionary.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= dictionary[i].length &lt;= 100</code></li>\n\t<li>所有 <code>keys[i]</code> 和 <code>dictionary[i]</code> <strong>互不相同</strong></li>\n\t<li><code>1 &lt;= word1.length &lt;= 2000</code></li>\n\t<li><code>1 &lt;= word2.length &lt;= 200</code></li>\n\t<li>所有 <code>word1[i]</code> 都出现在 <code>keys</code> 中</li>\n\t<li><code>word2.length</code> 是偶数</li>\n\t<li><code>keys</code>、<code>values[i]</code>、<code>dictionary[i]</code>、<code>word1</code> 和 <code>word2</code> 只含小写英文字母</li>\n\t<li>至多调用 <code>encrypt</code> 和 <code>decrypt</code> <strong>总计</strong> <code>200</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 22287 天内两次购买的用户",
        "hardRate": "MEDIUM",
        "passRate": "47.25%",
        "problemsUrl": "https://leetcode.cn/problems/users-with-two-purchases-within-seven-days/",
        "solutionsUrl": "https://leetcode.cn/problems/users-with-two-purchases-within-seven-days/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2229检查数组是否连贯",
        "hardRate": "EASY",
        "passRate": "69.83%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-an-array-is-consecutive/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-an-array-is-consecutive/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2230查找可享受优惠的用户",
        "hardRate": "EASY",
        "passRate": "49.43%",
        "problemsUrl": "https://leetcode.cn/problems/the-users-that-are-eligible-for-discount/",
        "solutionsUrl": "https://leetcode.cn/problems/the-users-that-are-eligible-for-discount/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2231按奇偶性交换后的最大数字",
        "hardRate": "EASY",
        "passRate": "64.25%",
        "problemsUrl": "https://leetcode.cn/problems/largest-number-after-digit-swaps-by-parity/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-number-after-digit-swaps-by-parity/solution",
        "problemsDesc": "<p>给你一个正整数 <code>num</code> 。你可以交换 <code>num</code> 中 <strong>奇偶性</strong> 相同的任意两位数字（即，都是奇数或者偶数）。</p>\n\n<p>返回交换 <strong>任意</strong> 次之后 <code>num</code> 的 <strong>最大</strong> 可能值<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 1234\n<strong>输出：</strong>3412\n<strong>解释：</strong>交换数字 3 和数字 1 ，结果得到 3214 。\n交换数字 2 和数字 4 ，结果得到 3412 。\n注意，可能存在其他交换序列，但是可以证明 3412 是最大可能值。\n注意，不能交换数字 4 和数字 1 ，因为它们奇偶性不同。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 65875\n<strong>输出：</strong>87655\n<strong>解释：</strong>交换数字 8 和数字 6 ，结果得到 85675 。\n交换数字 5 和数字 7 ，结果得到 87655 。\n注意，可能存在其他交换序列，但是可以证明 87655 是最大可能值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2232向表达式添加括号后的最小结果",
        "hardRate": "MEDIUM",
        "passRate": "61.23%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-result-by-adding-parentheses-to-expression/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-result-by-adding-parentheses-to-expression/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>expression</code> ，格式为 <code>\"&lt;num1&gt;+&lt;num2&gt;\"</code> ，其中 <code>&lt;num1&gt;</code> 和 <code>&lt;num2&gt;</code> 表示正整数。</p>\n\n<p>请你向 <code>expression</code> 中添加一对括号，使得在添加之后， <code>expression</code> 仍然是一个有效的数学表达式，并且计算后可以得到 <strong>最小</strong> 可能值。左括号 <strong>必须</strong> 添加在 <code>'+'</code> 的左侧，而右括号必须添加在 <code>'+'</code> 的右侧。</p>\n\n<p>返回添加一对括号后形成的表达式&nbsp;<code>expression</code> ，且满足<em> </em><code>expression</code><em> </em>计算得到 <strong>最小</strong> 可能值<em>。</em>如果存在多个答案都能产生相同结果，返回任意一个答案。</p>\n\n<p>生成的输入满足：<code>expression</code> 的原始值和添加满足要求的任一对括号之后 <code>expression</code> 的值，都符合 32-bit 带符号整数范围。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>expression = \"247+38\"\n<strong>输出：</strong>\"2(47+38)\"\n<strong>解释：</strong>表达式计算得到 2 * (47 + 38) = 2 * 85 = 170 。\n注意 \"2(4)7+38\" 不是有效的结果，因为右括号必须添加在 <code>'+' 的右侧。</code>\n可以证明 170 是最小可能值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>expression = \"12+34\"\n<strong>输出：</strong>\"1(2+3)4\"\n<strong>解释：</strong>表达式计算得到 1 * (2 + 3) * 4 = 1 * 5 * 4 = 20 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>expression = \"999+999\"\n<strong>输出：</strong>\"(999+999)\"\n<strong>解释：</strong>表达式计算得到 999 + 999 = 1998 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= expression.length &lt;= 10</code></li>\n\t<li><code>expression</code> 仅由数字 <code>'1'</code> 到 <code>'9'</code> 和 <code>'+'</code> 组成</li>\n\t<li><code>expression</code> 由数字开始和结束</li>\n\t<li><code>expression</code> 恰好仅含有一个 <code>'+'</code>.</li>\n\t<li><code>expression</code> 的原始值和添加满足要求的任一对括号之后 <code>expression</code> 的值，都符合 32-bit 带符号整数范围</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2233K 次增加后的最大乘积",
        "hardRate": "MEDIUM",
        "passRate": "36.66%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-product-after-k-increments/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-product-after-k-increments/solution",
        "problemsDesc": "<p>给你一个非负整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。每次操作，你可以选择&nbsp;<code>nums</code>&nbsp;中 <strong>任一</strong>&nbsp;元素并将它 <strong>增加</strong>&nbsp;<code>1</code>&nbsp;。</p>\n\n<p>请你返回 <strong>至多</strong>&nbsp;<code>k</code>&nbsp;次操作后，能得到的<em>&nbsp;</em><code>nums</code>的&nbsp;<strong>最大乘积</strong>&nbsp;。由于答案可能很大，请你将答案对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;取余后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [0,4], k = 5\n<b>输出：</b>20\n<b>解释：</b>将第一个数增加 5 次。\n得到 nums = [5, 4] ，乘积为 5 * 4 = 20 。\n可以证明 20 是能得到的最大乘积，所以我们返回 20 。\n存在其他增加 nums 的方法，也能得到最大乘积。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [6,3,3,2], k = 2\n<b>输出：</b>216\n<b>解释：</b>将第二个数增加 1 次，将第四个数增加 1 次。\n得到 nums = [6, 4, 3, 3] ，乘积为 6 * 4 * 3 * 3 = 216 。\n可以证明 216 是能得到的最大乘积，所以我们返回 216 。\n存在其他增加 nums 的方法，也能得到最大乘积。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2234花园的最大总美丽值",
        "hardRate": "HARD",
        "passRate": "27.88%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-total-beauty-of-the-gardens/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-total-beauty-of-the-gardens/solution",
        "problemsDesc": "<p>Alice 是&nbsp;<code>n</code>&nbsp;个花园的园丁，她想通过种花，最大化她所有花园的总美丽值。</p>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始大小为 <code>n</code>&nbsp;的整数数组&nbsp;<code>flowers</code>&nbsp;，其中&nbsp;<code>flowers[i]</code>&nbsp;是第 <code>i</code>&nbsp;个花园里已经种的花的数目。已经种了的花 <strong>不能</strong>&nbsp;移走。同时给你&nbsp;<code>newFlowers</code>&nbsp;，表示 Alice 额外可以种花的&nbsp;<strong>最大数目</strong>&nbsp;。同时给你的还有整数&nbsp;<code>target</code>&nbsp;，<code>full</code>&nbsp;和&nbsp;<code>partial</code>&nbsp;。</p>\n\n<p>如果一个花园有 <strong>至少</strong>&nbsp;<code>target</code>&nbsp;朵花，那么这个花园称为 <strong>完善的</strong>&nbsp;，花园的 <strong>总美丽值</strong>&nbsp;为以下分数之 <strong>和</strong> ：</p>\n\n<ul>\n\t<li><b>完善</b> 花园数目乘以&nbsp;<code>full</code>.</li>\n\t<li>剩余 <strong>不完善</strong>&nbsp;花园里，花的 <strong>最少数目</strong>&nbsp;乘以&nbsp;<code>partial</code>&nbsp;。如果没有不完善花园，那么这一部分的值为&nbsp;<code>0</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回 Alice 种最多 <code>newFlowers</code>&nbsp;朵花以后，能得到的<strong>&nbsp;最大</strong>&nbsp;总美丽值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>flowers = [1,3,1,1], newFlowers = 7, target = 6, full = 12, partial = 1\n<b>输出：</b>14\n<b>解释：</b>Alice 可以按以下方案种花\n- 在第 0 个花园种 2 朵花\n- 在第 1 个花园种 3 朵花\n- 在第 2 个花园种 1 朵花\n- 在第 3 个花园种 1 朵花\n花园里花的数目为 [3,6,2,2] 。总共种了 2 + 3 + 1 + 1 = 7 朵花。\n只有 1 个花园是完善的。\n不完善花园里花的最少数目是 2 。\n所以总美丽值为 1 * 12 + 2 * 1 = 12 + 2 = 14 。\n没有其他方案可以让花园总美丽值超过 14 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>flowers = [2,4,5,3], newFlowers = 10, target = 5, full = 2, partial = 6\n<b>输出：</b>30\n<b>解释：</b>Alice 可以按以下方案种花\n- 在第 0 个花园种 3 朵花\n- 在第 1 个花园种 0 朵花\n- 在第 2 个花园种 0 朵花\n- 在第 3 个花园种 2 朵花\n花园里花的数目为 [5,4,5,5] 。总共种了 3 + 0 + 0 + 2 = 5 朵花。\n有 3 个花园是完善的。\n不完善花园里花的最少数目为 4 。\n所以总美丽值为 3 * 2 + 4 * 6 = 6 + 24 = 30 。\n没有其他方案可以让花园总美丽值超过 30 。\n注意，Alice可以让所有花园都变成完善的，但这样她的总美丽值反而更小。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= flowers.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= flowers[i], target &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= newFlowers &lt;= 10<sup>10</sup></code></li>\n\t<li><code>1 &lt;= full, partial &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2235两整数相加",
        "hardRate": "EASY",
        "passRate": "84.95%",
        "problemsUrl": "https://leetcode.cn/problems/add-two-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/add-two-integers/solution",
        "problemsDesc": "给你两个整数&nbsp;<code>num1</code> 和 <code>num2</code>，返回这两个整数的和。\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = 12, num2 = 5\n<strong>输出：</strong>17\n<strong>解释：</strong>num1 是 12，num2 是 5 ，它们的和是 12 + 5 = 17 ，因此返回 17 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = -10, num2 = 4\n<strong>输出：</strong>-6\n<strong>解释：</strong>num1 + num2 = -6 ，因此返回 -6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-100 &lt;= num1, num2 &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2236判断根结点是否等于子结点之和",
        "hardRate": "EASY",
        "passRate": "85.79%",
        "problemsUrl": "https://leetcode.cn/problems/root-equals-sum-of-children/",
        "solutionsUrl": "https://leetcode.cn/problems/root-equals-sum-of-children/solution",
        "problemsDesc": "<p>给你一个 <strong>二叉树 </strong>的根结点&nbsp;<code>root</code>，该二叉树由恰好&nbsp;<code>3</code>&nbsp;个结点组成：根结点、左子结点和右子结点。</p>\n\n<p>如果根结点值等于两个子结点值之和，返回&nbsp;<code>true</code>&nbsp;，否则返回<em>&nbsp;</em><code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/08/graph3drawio.png\" style=\"width: 281px; height: 199px;\" />\n<pre>\n<strong>输入：</strong>root = [10,4,6]\n<strong>输出：</strong>true\n<strong>解释：</strong>根结点、左子结点和右子结点的值分别是 10 、4 和 6 。\n由于 10 等于 4 + 6 ，因此返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/08/graph3drawio-1.png\" style=\"width: 281px; height: 199px;\" />\n<pre>\n<strong>输入：</strong>root = [5,3,1]\n<strong>输出：</strong>false\n<strong>解释：</strong>根结点、左子结点和右子结点的值分别是 5 、3 和 1 。\n由于 5 不等于 3 + 1 ，因此返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树只包含根结点、左子结点和右子结点</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2237计算街道上满足所需亮度的位置数量",
        "hardRate": "MEDIUM",
        "passRate": "74.52%",
        "problemsUrl": "https://leetcode.cn/problems/count-positions-on-street-with-required-brightness/",
        "solutionsUrl": "https://leetcode.cn/problems/count-positions-on-street-with-required-brightness/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2238司机成为乘客的次数",
        "hardRate": "MEDIUM",
        "passRate": "69.43%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-times-a-driver-was-a-passenger/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-times-a-driver-was-a-passenger/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2239找到最接近 0 的数字",
        "hardRate": "EASY",
        "passRate": "53.46%",
        "problemsUrl": "https://leetcode.cn/problems/find-closest-number-to-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/find-closest-number-to-zero/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;，请你返回 <code>nums</code>&nbsp;中最 <strong>接近</strong>&nbsp;<code>0</code>&nbsp;的数字。如果有多个答案，请你返回它们中的 <strong>最大值</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [-4,-2,1,4,8]\n<b>输出：</b>1\n<strong>解释：</strong>\n-4 到 0 的距离为 |-4| = 4 。\n-2 到 0 的距离为 |-2| = 2 。\n1 到 0 的距离为 |1| = 1 。\n4 到 0 的距离为 |4| = 4 。\n8 到 0 的距离为 |8| = 8 。\n所以，数组中距离 0 最近的数字为 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2,-1,1]\n<b>输出：</b>1\n<b>解释：</b>1 和 -1 都是距离 0 最近的数字，所以返回较大值 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2240买钢笔和铅笔的方案数",
        "hardRate": "MEDIUM",
        "passRate": "57.42%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-buy-pens-and-pencils/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-buy-pens-and-pencils/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>total</code>&nbsp;，表示你拥有的总钱数。同时给你两个整数&nbsp;<code>cost1</code> 和&nbsp;<code>cost2</code>&nbsp;，分别表示一支钢笔和一支铅笔的价格。你可以花费你部分或者全部的钱，去买任意数目的两种笔。</p>\n\n<p>请你返回购买钢笔和铅笔的&nbsp;<strong>不同方案数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>total = 20, cost1 = 10, cost2 = 5\n<b>输出：</b>9\n<b>解释：</b>一支钢笔的价格为 10 ，一支铅笔的价格为 5 。\n- 如果你买 0 支钢笔，那么你可以买 0 ，1 ，2 ，3 或者 4 支铅笔。\n- 如果你买 1 支钢笔，那么你可以买 0 ，1 或者 2 支铅笔。\n- 如果你买 2 支钢笔，那么你没法买任何铅笔。\n所以买钢笔和铅笔的总方案数为 5 + 3 + 1 = 9 种。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>total = 5, cost1 = 10, cost2 = 10\n<b>输出：</b>1\n<b>解释：</b>钢笔和铅笔的价格都为 10 ，都比拥有的钱数多，所以你没法购买任何文具。所以只有 1 种方案：买 0 支钢笔和 0 支铅笔。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= total, cost1, cost2 &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2241设计一个 ATM 机器",
        "hardRate": "MEDIUM",
        "passRate": "36.25%",
        "problemsUrl": "https://leetcode.cn/problems/design-an-atm-machine/",
        "solutionsUrl": "https://leetcode.cn/problems/design-an-atm-machine/solution",
        "problemsDesc": "<p>一个 ATM 机器，存有&nbsp;<code>5</code>&nbsp;种面值的钞票：<code>20</code>&nbsp;，<code>50</code>&nbsp;，<code>100</code>&nbsp;，<code>200</code>&nbsp;和&nbsp;<code>500</code>&nbsp;美元。初始时，ATM 机是空的。用户可以用它存或者取任意数目的钱。</p>\n\n<p>取款时，机器会优先取 <b>较大</b>&nbsp;数额的钱。</p>\n\n<ul>\n\t<li>比方说，你想取&nbsp;<code>$300</code>&nbsp;，并且机器里有&nbsp;<code>2</code>&nbsp;张 <code>$50</code>&nbsp;的钞票，<code>1</code>&nbsp;张&nbsp;<code>$100</code>&nbsp;的钞票和<code>1</code>&nbsp;张&nbsp;<code>$200</code>&nbsp;的钞票，那么机器会取出&nbsp;<code>$100</code> 和&nbsp;<code>$200</code>&nbsp;的钞票。</li>\n\t<li>但是，如果你想取&nbsp;<code>$600</code>&nbsp;，机器里有&nbsp;<code>3</code>&nbsp;张&nbsp;<code>$200</code>&nbsp;的钞票和<code>1</code>&nbsp;张&nbsp;<code>$500</code>&nbsp;的钞票，那么取款请求会被拒绝，因为机器会先取出&nbsp;<code>$500</code>&nbsp;的钞票，然后无法取出剩余的&nbsp;<code>$100</code>&nbsp;。注意，因为有&nbsp;<code>$500</code>&nbsp;钞票的存在，机器&nbsp;<strong>不能</strong>&nbsp;取&nbsp;<code>$200</code>&nbsp;的钞票。</li>\n</ul>\n\n<p>请你实现 ATM 类：</p>\n\n<ul>\n\t<li><code>ATM()</code>&nbsp;初始化 ATM 对象。</li>\n\t<li><code>void deposit(int[] banknotesCount)</code>&nbsp;分别存入&nbsp;<code>$20</code>&nbsp;，<code>$50</code>，<code>$100</code>，<code>$200</code>&nbsp;和&nbsp;<code>$500</code>&nbsp;钞票的数目。</li>\n\t<li><code>int[] withdraw(int amount)</code>&nbsp;返回一个长度为&nbsp;<code>5</code>&nbsp;的数组，分别表示&nbsp;<code>$20</code>&nbsp;，<code>$50</code>，<code>$100</code>&nbsp;，<code>$200</code>&nbsp;和&nbsp;<code>$500</code>&nbsp;钞票的数目，并且更新 ATM 机里取款后钞票的剩余数量。如果无法取出指定数额的钱，请返回&nbsp;<code>[-1]</code>&nbsp;（这种情况下 <strong>不</strong>&nbsp;取出任何钞票）。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"ATM\", \"deposit\", \"withdraw\", \"deposit\", \"withdraw\", \"withdraw\"]\n[[], [[0,0,1,2,1]], [600], [[0,1,0,1,1]], [600], [550]]\n<strong>输出：</strong>\n[null, null, [0,0,1,0,1], null, [-1], [0,1,0,0,1]]\n\n<strong>解释：</strong>\nATM atm = new ATM();\natm.deposit([0,0,1,2,1]); // 存入 1 张 $100 ，2 张 $200 和 1 张 $500 的钞票。\natm.withdraw(600);        // 返回 [0,0,1,0,1] 。机器返回 1 张 $100 和 1 张 $500 的钞票。机器里剩余钞票的数量为 [0,0,0,2,0] 。\natm.deposit([0,1,0,1,1]); // 存入 1 张 $50 ，1 张 $200 和 1 张 $500 的钞票。\n                          // 机器中剩余钞票数量为 [0,1,0,3,1] 。\natm.withdraw(600);        // 返回 [-1] 。机器会尝试取出 $500 的钞票，然后无法得到剩余的 $100 ，所以取款请求会被拒绝。\n                          // 由于请求被拒绝，机器中钞票的数量不会发生改变。\natm.withdraw(550);        // 返回 [0,1,0,0,1] ，机器会返回 1 张 $50 的钞票和 1 张 $500 的钞票。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>banknotesCount.length == 5</code></li>\n\t<li><code>0 &lt;= banknotesCount[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= amount &lt;= 10<sup>9</sup></code></li>\n\t<li><strong>总共</strong>&nbsp;最多有&nbsp;<code>5000</code>&nbsp;次&nbsp;<code>withdraw</code> 和&nbsp;<code>deposit</code>&nbsp;的调用。</li>\n\t<li><span style=\"\">函数 </span><code>withdraw</code> 和&nbsp;<code>deposit</code>&nbsp;至少各有 <strong>一次&nbsp;</strong>调用。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2242节点序列的最大得分",
        "hardRate": "HARD",
        "passRate": "33.98%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-of-a-node-sequence/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-of-a-node-sequence/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>n</code>&nbsp;个节点的&nbsp;<strong>无向图</strong>&nbsp;，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。</p>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>scores</code>&nbsp;，其中&nbsp;<code>scores[i]</code>&nbsp;是第 <code>i</code>&nbsp;个节点的分数。同时给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;，表示节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条&nbsp;<strong>无向</strong>&nbsp;边。</p>\n\n<p>一个合法的节点序列如果满足以下条件，我们称它是 <strong>合法的</strong>&nbsp;：</p>\n\n<ul>\n\t<li>序列中每&nbsp;<b>相邻</b>&nbsp;节点之间有边相连。</li>\n\t<li>序列中没有节点出现超过一次。</li>\n</ul>\n\n<p>节点序列的分数定义为序列中节点分数之 <strong>和</strong> 。</p>\n\n<p>请你返回一个长度为 <code>4</code>&nbsp;的合法节点序列的最大分数。如果不存在这样的序列，请你返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/15/ex1new3.png\" style=\"width: 290px; height: 215px;\" /></p>\n\n<pre>\n<b>输入：</b>scores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]\n<b>输出：</b>24\n<b>解释：</b>上图为输入的图，节点序列为 [0,1,2,3] 。\n节点序列的分数为 5 + 2 + 9 + 8 = 24 。\n观察可知，没有其他节点序列得分和超过 24 。\n注意节点序列 [3,1,2,0] 和 [1,0,2,3] 也是合法的，且分数为 24 。\n序列 [0,3,2,4] 不是合法的，因为没有边连接节点 0 和 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/17/ex2.png\" style=\"width: 333px; height: 151px;\" /></p>\n\n<pre>\n<b>输入：</b>scores = [9,20,6,4,11,12], edges = [[0,3],[5,3],[2,4],[1,3]]\n<b>输出：</b>-1\n<b>解释：</b>上图为输入的图。\n没有长度为 4 的合法序列，所以我们返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == scores.length</code></li>\n\t<li><code>4 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= scores[i] &lt;= 10<sup>8</sup></code></li>\n\t<li><code>0 &lt;= edges.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>不会有重边。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2243计算字符串的数字和",
        "hardRate": "EASY",
        "passRate": "63.52%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-digit-sum-of-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-digit-sum-of-a-string/solution",
        "problemsDesc": "<p>给你一个由若干数字（<code>0</code> - <code>9</code>）组成的字符串 <code>s</code> ，和一个整数。</p>\n\n<p>如果 <code>s</code> 的长度大于 <code>k</code> ，则可以执行一轮操作。在一轮操作中，需要完成以下工作：</p>\n\n<ol>\n\t<li>将 <code>s</code> <strong>拆分 </strong>成长度为 <code>k</code> 的若干 <strong>连续数字组</strong> ，使得前 <code>k</code> 个字符都分在第一组，接下来的 <code>k</code> 个字符都分在第二组，依此类推。<strong>注意</strong>，最后一个数字组的长度可以小于 <code>k</code> 。</li>\n\t<li>用表示每个数字组中所有数字之和的字符串来 <strong>替换</strong> 对应的数字组。例如，<code>\"346\"</code> 会替换为 <code>\"13\"</code> ，因为 <code>3 + 4 + 6 = 13</code> 。</li>\n\t<li><strong>合并</strong> 所有组以形成一个新字符串。如果新字符串的长度大于 <code>k</code> 则重复第一步。</li>\n</ol>\n\n<p>返回在完成所有轮操作后的 <code>s</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"11111222223\", k = 3\n<strong>输出：</strong>\"135\"\n<strong>解释：</strong>\n- 第一轮，将 s 分成：\"111\"、\"112\"、\"222\" 和 \"23\" 。\n  接着，计算每一组的数字和：1 + 1 + 1 = 3、1 + 1 + 2 = 4、2 + 2 + 2 = 6 和 2 + 3 = 5 。 \n&nbsp; 这样，s 在第一轮之后变成 \"3\" + \"4\" + \"6\" + \"5\" = \"3465\" 。\n- 第二轮，将 s 分成：\"346\" 和 \"5\" 。\n&nbsp; 接着，计算每一组的数字和：3 + 4 + 6 = 13 、5 = 5 。\n&nbsp; 这样，s 在第二轮之后变成 \"13\" + \"5\" = \"135\" 。 \n现在，s.length &lt;= k ，所以返回 \"135\" 作为答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"00000000\", k = 3\n<strong>输出：</strong>\"000\"\n<strong>解释：</strong>\n将 \"000\", \"000\", and \"00\".\n接着，计算每一组的数字和：0 + 0 + 0 = 0 、0 + 0 + 0 = 0 和 0 + 0 = 0 。 \ns 变为 \"0\" + \"0\" + \"0\" = \"000\" ，其长度等于 k ，所以返回 \"000\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>2 &lt;= k &lt;= 100</code></li>\n\t<li><code>s</code> 仅由数字（<code>0</code> - <code>9</code>）组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2244完成所有任务需要的最少轮数",
        "hardRate": "MEDIUM",
        "passRate": "57.13%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-rounds-to-complete-all-tasks/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-rounds-to-complete-all-tasks/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>tasks</code> ，其中 <code>tasks[i]</code> 表示任务的难度级别。在每一轮中，你可以完成 2 个或者 3 个 <strong>相同难度级别</strong> 的任务。</p>\n\n<p>返回完成所有任务需要的 <strong>最少</strong> 轮数，如果无法完成所有任务，返回<em> </em><code>-1</code><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>tasks = [2,2,3,3,2,4,4,4,4,4]\n<strong>输出：</strong>4\n<strong>解释：</strong>要想完成所有任务，一个可能的计划是：\n- 第一轮，完成难度级别为 2 的 3 个任务。 \n- 第二轮，完成难度级别为 3 的 2 个任务。 \n- 第三轮，完成难度级别为 4 的 3 个任务。 \n- 第四轮，完成难度级别为 4 的 2 个任务。 \n可以证明，无法在少于 4 轮的情况下完成所有任务，所以答案为 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>tasks = [2,3,3]\n<strong>输出：</strong>-1\n<strong>解释：</strong>难度级别为 2 的任务只有 1 个，但每一轮执行中，只能选择完成 2 个或者 3 个相同难度级别的任务。因此，无法完成所有任务，答案为 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tasks.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= tasks[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2245转角路径的乘积中最多能有几个尾随零",
        "hardRate": "MEDIUM",
        "passRate": "36.08%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-trailing-zeros-in-a-cornered-path/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-trailing-zeros-in-a-cornered-path/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>grid</code> ，大小为 <code>m x n</code>，其中每个单元格都含一个正整数。</p>\n\n<p><strong>转角路径</strong> 定义为：包含至多一个弯的一组相邻单元。具体而言，路径应该完全 <strong>向水平方向</strong> 或者 <strong>向竖直方向</strong> 移动过弯（如果存在弯），而不能访问之前访问过的单元格。在过弯之后，路径应当完全朝 <strong>另一个</strong> 方向行进：如果之前是向水平方向，那么就应该变为向竖直方向；反之亦然。当然，同样不能访问之前已经访问过的单元格。</p>\n\n<p>一条路径的 <strong>乘积</strong> 定义为：路径上所有值的乘积。</p>\n\n<p>请你从 <code>grid</code> 中找出一条乘积中尾随零数目最多的转角路径，并返回该路径中尾随零的数目。</p>\n\n<p>注意：</p>\n\n<ul>\n\t<li><strong>水平</strong> 移动是指向左或右移动。</li>\n\t<li><strong>竖直 </strong>移动是指向上或下移动。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/23/ex1new2.jpg\" style=\"width: 577px; height: 190px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]\n<strong>输出：</strong>3\n<strong>解释：</strong>左侧的图展示了一条有效的转角路径。\n其乘积为 15 * 20 * 6 * 1 * 10 = 18000 ，共计 3 个尾随零。\n可以证明在这条转角路径的乘积中尾随零数目最多。\n\n中间的图不是一条有效的转角路径，因为它有不止一个弯。\n右侧的图也不是一条有效的转角路径，因为它需要重复访问已经访问过的单元格。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/25/ex2.jpg\" style=\"width: 150px; height: 157px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[4,3,2],[7,6,1],[8,8,8]]\n<strong>输出：</strong>0\n<strong>解释：</strong>网格如上图所示。\n不存在乘积含尾随零的转角路径。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2246相邻字符不同的最长路径",
        "hardRate": "HARD",
        "passRate": "46.99%",
        "problemsUrl": "https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/solution",
        "problemsDesc": "<p>给你一棵 <strong>树</strong>（即一个连通、无向、无环图），根节点是节点 <code>0</code> ，这棵树由编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个节点组成。用下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的数组 <code>parent</code> 来表示这棵树，其中 <code>parent[i]</code> 是节点 <code>i</code> 的父节点，由于节点 <code>0</code> 是根节点，所以 <code>parent[0] == -1</code> 。</p>\n\n<p>另给你一个字符串 <code>s</code> ，长度也是 <code>n</code> ，其中 <code>s[i]</code> 表示分配给节点 <code>i</code> 的字符。</p>\n\n<p>请你找出路径上任意一对相邻节点都没有分配到相同字符的 <strong>最长路径</strong> ，并返回该路径的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/25/testingdrawio.png\" style=\"width: 201px; height: 241px;\" /></p>\n\n<pre>\n<strong>输入：</strong>parent = [-1,0,0,1,1,2], s = \"abacbe\"\n<strong>输出：</strong>3\n<strong>解释：</strong>任意一对相邻节点字符都不同的最长路径是：0 -&gt; 1 -&gt; 3 。该路径的长度是 3 ，所以返回 3 。\n可以证明不存在满足上述条件且比 3 更长的路径。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/25/graph2drawio.png\" style=\"width: 201px; height: 221px;\" /></p>\n\n<pre>\n<strong>输入：</strong>parent = [-1,0,0,0], s = \"aabc\"\n<strong>输出：</strong>3\n<strong>解释：</strong>任意一对相邻节点字符都不同的最长路径是：2 -&gt; 0 -&gt; 3 。该路径的长度为 3 ，所以返回 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == parent.length == s.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li>对所有 <code>i &gt;= 1</code> ，<code>0 &lt;= parent[i] &lt;= n - 1</code> 均成立</li>\n\t<li><code>parent[0] == -1</code></li>\n\t<li><code>parent</code> 表示一棵有效的树</li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2247K 条高速公路的最大旅行费用",
        "hardRate": "HARD",
        "passRate": "56.51%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-cost-of-trip-with-k-highways/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-cost-of-trip-with-k-highways/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2248多个数组求交集",
        "hardRate": "EASY",
        "passRate": "67.09%",
        "problemsUrl": "https://leetcode.cn/problems/intersection-of-multiple-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/intersection-of-multiple-arrays/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 是由 <strong>不同</strong> 正整数组成的一个非空数组，按 <strong>升序排列</strong> 返回一个数组，数组中的每个元素在 <code>nums</code>&nbsp;<strong>所有数组</strong> 中都出现过。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[<em><strong>3</strong></em>,1,2,<em><strong>4</strong></em>,5],[1,2,<em><strong>3</strong></em>,<em><strong>4</strong></em>],[<em><strong>3</strong></em>,<em><strong>4</strong></em>,5,6]]\n<strong>输出：</strong>[3,4]\n<strong>解释：</strong>\nnums[0] = [<em><strong>3</strong></em>,1,2,<em><strong>4</strong></em>,5]，nums[1] = [1,2,<em><strong>3</strong></em>,<em><strong>4</strong></em>]，nums[2] = [<em><strong>3</strong></em>,<em><strong>4</strong></em>,5,6]，在 nums 中每个数组中都出现的数字是 3 和 4 ，所以返回 [3,4] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[1,2,3],[4,5,6]]\n<strong>输出：</strong>[]\n<strong>解释：</strong>\n不存在同时出现在 nums[0] 和 nums[1] 的整数，所以返回一个空列表 [] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= sum(nums[i].length) &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i][j] &lt;= 1000</code></li>\n\t<li><code>nums[i]</code> 中的所有值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2249统计圆内格点数目",
        "hardRate": "MEDIUM",
        "passRate": "53.31%",
        "problemsUrl": "https://leetcode.cn/problems/count-lattice-points-inside-a-circle/",
        "solutionsUrl": "https://leetcode.cn/problems/count-lattice-points-inside-a-circle/solution",
        "problemsDesc": "<p>给你一个二维整数数组 <code>circles</code> ，其中 <code>circles[i] = [x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub>]</code> 表示网格上圆心为 <code>(x<sub>i</sub>, y<sub>i</sub>)</code> 且半径为 <code>r<sub>i</sub></code> 的第 <code>i</code> 个圆，返回出现在<strong> 至少一个 </strong>圆内的 <strong>格点数目</strong> 。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><strong>格点</strong> 是指整数坐标对应的点。</li>\n\t<li><strong>圆周上的点</strong> 也被视为出现在圆内的点。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/exa-11.png\" style=\"width: 300px; height: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>circles = [[2,2,1]]\n<strong>输出：</strong>5\n<strong>解释：</strong>\n给定的圆如上图所示。\n出现在圆内的格点为 (1, 2)、(2, 1)、(2, 2)、(2, 3) 和 (3, 2)，在图中用绿色标识。\n像 (1, 1) 和 (1, 3) 这样用红色标识的点，并未出现在圆内。\n因此，出现在至少一个圆内的格点数目是 5 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/exa-22.png\" style=\"width: 300px; height: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>circles = [[2,2,2],[3,4,1]]\n<strong>输出：</strong>16\n<strong>解释：</strong>\n给定的圆如上图所示。\n共有 16 个格点出现在至少一个圆内。\n其中部分点的坐标是 (0, 2)、(2, 0)、(2, 4)、(3, 2) 和 (4, 4) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= circles.length &lt;= 200</code></li>\n\t<li><code>circles[i].length == 3</code></li>\n\t<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 100</code></li>\n\t<li><code>1 &lt;= r<sub>i</sub> &lt;= min(x<sub>i</sub>, y<sub>i</sub>)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2250统计包含每个点的矩形数目",
        "hardRate": "MEDIUM",
        "passRate": "34.88%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-rectangles-containing-each-point/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-rectangles-containing-each-point/solution",
        "problemsDesc": "<p>给你一个二维整数数组&nbsp;<code>rectangles</code>&nbsp;，其中&nbsp;<code>rectangles[i] = [l<sub>i</sub>, h<sub>i</sub>]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个矩形长为&nbsp;<code>l<sub>i</sub></code>&nbsp;高为&nbsp;<code>h<sub>i</sub></code>&nbsp;。给你一个二维整数数组&nbsp;<code>points</code>&nbsp;，其中&nbsp;<code>points[j] = [x<sub>j</sub>, y<sub>j</sub>]</code>&nbsp;是坐标为&nbsp;<code>(x<sub>j</sub>, y<sub>j</sub>)</code>&nbsp;的一个点。</p>\n\n<p>第&nbsp;<code>i</code>&nbsp;个矩形的 <strong>左下角</strong>&nbsp;在&nbsp;<code>(0, 0)</code>&nbsp;处，<strong>右上角</strong>&nbsp;在&nbsp;<code>(l<sub>i</sub>, h<sub>i</sub>)</code>&nbsp;。</p>\n\n<p>请你返回一个整数数组<em>&nbsp;</em><code>count</code>&nbsp;，长度为&nbsp;<code>points.length</code>，其中<em>&nbsp;</em><code>count[j]</code>是 <strong>包含</strong> 第<em>&nbsp;</em><code>j</code>&nbsp;个点的矩形数目。</p>\n\n<p>如果&nbsp;<code>0 &lt;= x<sub>j</sub> &lt;= l<sub>i</sub></code> 且&nbsp;<code>0 &lt;= y<sub>j</sub> &lt;= h<sub>i</sub></code>&nbsp;，那么我们说第&nbsp;<code>i</code>&nbsp;个矩形包含第&nbsp;<code>j</code>&nbsp;个点。如果一个点刚好在矩形的 <strong>边上</strong>&nbsp;，这个点也被视为被矩形包含。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/example1.png\" style=\"width: 300px; height: 509px;\"></p>\n\n<pre><b>输入：</b>rectangles = [[1,2],[2,3],[2,5]], points = [[2,1],[1,4]]\n<b>输出：</b>[2,1]\n<b>解释：</b>\n第一个矩形不包含任何点。\n第二个矩形只包含一个点 (2, 1) 。\n第三个矩形包含点 (2, 1) 和 (1, 4) 。\n包含点 (2, 1) 的矩形数目为 2 。\n包含点 (1, 4) 的矩形数目为 1 。\n所以，我们返回 [2, 1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/example2.png\" style=\"width: 300px; height: 312px;\"></p>\n\n<pre><b>输入：</b>rectangles = [[1,1],[2,2],[3,3]], points = [[1,3],[1,1]]\n<b>输出：</b>[1,3]\n<strong>解释：\n</strong>第一个矩形只包含点 (1, 1) 。\n第二个矩形只包含点 (1, 1) 。\n第三个矩形包含点 (1, 3) 和 (1, 1) 。\n包含点 (1, 3) 的矩形数目为 1 。\n包含点 (1, 1) 的矩形数目为 3 。\n所以，我们返回 [1, 3] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rectangles.length, points.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>rectangles[i].length == points[j].length == 2</code></li>\n\t<li><code>1 &lt;= l<sub>i</sub>, x<sub>j</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= h<sub>i</sub>, y<sub>j</sub> &lt;= 100</code></li>\n\t<li>所有&nbsp;<code>rectangles</code>&nbsp;<strong>互不相同</strong>&nbsp;。</li>\n\t<li>所有&nbsp;<code>points</code> <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2251花期内花的数目",
        "hardRate": "HARD",
        "passRate": "49.09%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-flowers-in-full-bloom/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-flowers-in-full-bloom/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>flowers</code>&nbsp;，其中&nbsp;<code>flowers[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;朵花的 <strong>花期</strong>&nbsp;从&nbsp;<code>start<sub>i</sub></code>&nbsp;到&nbsp;<code>end<sub>i</sub></code>&nbsp;（都 <strong>包含</strong>）。同时给你一个下标从 <strong>0</strong>&nbsp;开始大小为 <code>n</code>&nbsp;的整数数组&nbsp;<code>persons</code>&nbsp;，<code>persons[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个人来看花的时间。</p>\n\n<p>请你返回一个大小为 <code>n</code>&nbsp;的整数数组<em>&nbsp;</em><code>answer</code>&nbsp;，其中&nbsp;<code>answer[i]</code>是第&nbsp;<code>i</code>&nbsp;个人到达时在花期内花的&nbsp;<strong>数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/ex1new.jpg\" style=\"width: 550px; height: 216px;\"></p>\n\n<pre><b>输入：</b>flowers = [[1,6],[3,7],[9,12],[4,13]], persons = [2,3,7,11]\n<b>输出：</b>[1,2,2,2]\n<strong>解释：</strong>上图展示了每朵花的花期时间，和每个人的到达时间。\n对每个人，我们返回他们到达时在花期内花的数目。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/02/ex2new.jpg\" style=\"width: 450px; height: 195px;\"></p>\n\n<pre><b>输入：</b>flowers = [[1,10],[3,3]], persons = [3,3,2]\n<b>输出：</b>[2,2,1]\n<b>解释：</b>上图展示了每朵花的花期时间，和每个人的到达时间。\n对每个人，我们返回他们到达时在花期内花的数目。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= flowers.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>flowers[i].length == 2</code></li>\n\t<li><code>1 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= persons.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= persons[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2252表的动态旋转",
        "hardRate": "HARD",
        "passRate": "57.31%",
        "problemsUrl": "https://leetcode.cn/problems/dynamic-pivoting-of-a-table/",
        "solutionsUrl": "https://leetcode.cn/problems/dynamic-pivoting-of-a-table/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2253动态取消表的旋转",
        "hardRate": "HARD",
        "passRate": "71.20%",
        "problemsUrl": "https://leetcode.cn/problems/dynamic-unpivoting-of-a-table/",
        "solutionsUrl": "https://leetcode.cn/problems/dynamic-unpivoting-of-a-table/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2254设计视频共享平台",
        "hardRate": "HARD",
        "passRate": "61.30%",
        "problemsUrl": "https://leetcode.cn/problems/design-video-sharing-platform/",
        "solutionsUrl": "https://leetcode.cn/problems/design-video-sharing-platform/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2255统计是给定字符串前缀的字符串数目",
        "hardRate": "EASY",
        "passRate": "78.62%",
        "problemsUrl": "https://leetcode.cn/problems/count-prefixes-of-a-given-string/",
        "solutionsUrl": "https://leetcode.cn/problems/count-prefixes-of-a-given-string/solution",
        "problemsDesc": "<p>给你一个字符串数组&nbsp;<code>words</code>&nbsp;和一个字符串&nbsp;<code>s</code>&nbsp;，其中&nbsp;<code>words[i]</code> 和&nbsp;<code>s</code>&nbsp;只包含 <strong>小写英文字母</strong>&nbsp;。</p>\n\n<p>请你返回 <code>words</code>&nbsp;中是字符串 <code>s</code>&nbsp;<strong>前缀&nbsp;</strong>的 <strong>字符串数目</strong>&nbsp;。</p>\n\n<p>一个字符串的 <strong>前缀</strong>&nbsp;是出现在字符串开头的子字符串。<strong>子字符串</strong>&nbsp;是一个字符串中的连续一段字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>words = [\"a\",\"b\",\"c\",\"ab\",\"bc\",\"abc\"], s = \"abc\"\n<b>输出：</b>3\n<strong>解释：</strong>\nwords 中是 s = \"abc\" 前缀的字符串为：\n\"a\" ，\"ab\" 和 \"abc\" 。\n所以 words 中是字符串 s 前缀的字符串数目为 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>words = [\"a\",\"a\"], s = \"aa\"\n<b>输出：</b>2\n<strong>解释：\n</strong>两个字符串都是 s 的前缀。\n注意，相同的字符串可能在 words 中出现多次，它们应该被计数多次。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length, s.length &lt;= 10</code></li>\n\t<li><code>words[i]</code> 和&nbsp;<code>s</code>&nbsp;<strong>只</strong>&nbsp;包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2256最小平均差",
        "hardRate": "MEDIUM",
        "passRate": "36.76%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-average-difference/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-average-difference/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>下标 <code>i</code>&nbsp;处的 <strong>平均差</strong>&nbsp;指的是 <code>nums</code>&nbsp;中 <strong>前</strong>&nbsp;<code>i + 1</code>&nbsp;个元素平均值和 <strong>后</strong>&nbsp;<code>n - i - 1</code>&nbsp;个元素平均值的 <strong>绝对差</strong>&nbsp;。两个平均值都需要 <strong>向下取整</strong>&nbsp;到最近的整数。</p>\n\n<p>请你返回产生 <strong>最小平均差</strong>&nbsp;的下标。如果有多个下标最小平均差相等，请你返回 <strong>最小</strong>&nbsp;的一个下标。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>两个数的<strong>&nbsp;绝对差</strong>&nbsp;是两者差的绝对值。</li>\n\t<li>&nbsp;<code>n</code>&nbsp;个元素的平均值是 <code>n</code>&nbsp;个元素之 <strong>和</strong>&nbsp;除以（整数除法）&nbsp;<code>n</code>&nbsp;。</li>\n\t<li><code>0</code>&nbsp;个元素的平均值视为&nbsp;<code>0</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,5,3,9,5,3]\n<b>输出：</b>3\n<strong>解释：</strong>\n- 下标 0 处的平均差为：|2 / 1 - (5 + 3 + 9 + 5 + 3) / 5| = |2 / 1 - 25 / 5| = |2 - 5| = 3 。\n- 下标 1 处的平均差为：|(2 + 5) / 2 - (3 + 9 + 5 + 3) / 4| = |7 / 2 - 20 / 4| = |3 - 5| = 2 。\n- 下标 2 处的平均差为：|(2 + 5 + 3) / 3 - (9 + 5 + 3) / 3| = |10 / 3 - 17 / 3| = |3 - 5| = 2 。\n- 下标 3 处的平均差为：|(2 + 5 + 3 + 9) / 4 - (5 + 3) / 2| = |19 / 4 - 8 / 2| = |4 - 4| = 0 。 \n- 下标 4 处的平均差为：|(2 + 5 + 3 + 9 + 5) / 5 - 3 / 1| = |24 / 5 - 3 / 1| = |4 - 3| = 1 。\n- 下标 5 处的平均差为：|(2 + 5 + 3 + 9 + 5 + 3) / 6 - 0| = |27 / 6 - 0| = |4 - 0| = 4 。\n下标 3 处的平均差为最小平均差，所以返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [0]\n<b>输出：</b>0\n<strong>解释：</strong>\n唯一的下标是 0 ，所以我们返回 0 。\n下标 0 处的平均差为：|0 / 1 - 0| = |0 - 0| = 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2257统计网格图中没有被保卫的格子数",
        "hardRate": "MEDIUM",
        "passRate": "52.69%",
        "problemsUrl": "https://leetcode.cn/problems/count-unguarded-cells-in-the-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/count-unguarded-cells-in-the-grid/solution",
        "problemsDesc": "<p>给你两个整数&nbsp;<code>m</code>&nbsp;和&nbsp;<code>n</code>&nbsp;表示一个下标从<strong>&nbsp;0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;网格图。同时给你两个二维整数数组&nbsp;<code>guards</code> 和&nbsp;<code>walls</code>&nbsp;，其中&nbsp;<code>guards[i] = [row<sub>i</sub>, col<sub>i</sub>]</code>&nbsp;且&nbsp;<code>walls[j] = [row<sub>j</sub>, col<sub>j</sub>]</code>&nbsp;，分别表示第 <code>i</code>&nbsp;个警卫和第 <code>j</code>&nbsp;座墙所在的位置。</p>\n\n<p>一个警卫能看到 4 个坐标轴方向（即东、南、西、北）的 <strong>所有</strong>&nbsp;格子，除非他们被一座墙或者另外一个警卫 <strong>挡住</strong>&nbsp;了视线。如果一个格子能被 <strong>至少</strong>&nbsp;一个警卫看到，那么我们说这个格子被 <strong>保卫</strong>&nbsp;了。</p>\n\n<p>请你返回空格子中，有多少个格子是 <strong>没被保卫</strong>&nbsp;的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/example1drawio2.png\" style=\"width: 300px; height: 204px;\"></p>\n\n<pre><b>输入：</b>m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]\n<b>输出：</b>7\n<strong>解释：</strong>上图中，被保卫和没有被保卫的格子分别用红色和绿色表示。\n总共有 7 个没有被保卫的格子，所以我们返回 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/example2drawio.png\" style=\"width: 200px; height: 201px;\"></p>\n\n<pre><b>输入：</b>m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]]\n<b>输出：</b>4\n<b>解释：</b>上图中，没有被保卫的格子用绿色表示。\n总共有 4 个没有被保卫的格子，所以我们返回 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= guards.length, walls.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>2 &lt;= guards.length + walls.length &lt;= m * n</code></li>\n\t<li><code>guards[i].length == walls[j].length == 2</code></li>\n\t<li><code>0 &lt;= row<sub>i</sub>, row<sub>j</sub> &lt; m</code></li>\n\t<li><code>0 &lt;= col<sub>i</sub>, col<sub>j</sub> &lt; n</code></li>\n\t<li><code>guards</code>&nbsp;和&nbsp;<code>walls</code>&nbsp;中所有位置 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2258逃离火灾",
        "hardRate": "HARD",
        "passRate": "35.95%",
        "problemsUrl": "https://leetcode.cn/problems/escape-the-spreading-fire/",
        "solutionsUrl": "https://leetcode.cn/problems/escape-the-spreading-fire/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始大小为 <code>m x n</code>&nbsp;的二维整数数组&nbsp;<code>grid</code>&nbsp;，它表示一个网格图。每个格子为下面 3 个值之一：</p>\n\n<ul>\n\t<li><code>0</code> 表示草地。</li>\n\t<li><code>1</code> 表示着火的格子。</li>\n\t<li><code>2</code>&nbsp;表示一座墙，你跟火都不能通过这个格子。</li>\n</ul>\n\n<p>一开始你在最左上角的格子&nbsp;<code>(0, 0)</code>&nbsp;，你想要到达最右下角的安全屋格子&nbsp;<code>(m - 1, n - 1)</code>&nbsp;。每一分钟，你可以移动到&nbsp;<strong>相邻</strong>&nbsp;的草地格子。每次你移动 <strong>之后</strong>&nbsp;，着火的格子会扩散到所有不是墙的 <strong>相邻</strong>&nbsp;格子。</p>\n\n<p>请你返回你在初始位置可以停留的 <strong>最多 </strong>分钟数，且停留完这段时间后你还能安全到达安全屋。如果无法实现，请你返回 <code>-1</code>&nbsp;。如果不管你在初始位置停留多久，你 <strong>总是</strong>&nbsp;能到达安全屋，请你返回&nbsp;<code>10<sup>9</sup></code>&nbsp;。</p>\n\n<p>注意，如果你到达安全屋后，火马上到了安全屋，这视为你能够安全到达安全屋。</p>\n\n<p>如果两个格子有共同边，那么它们为 <strong>相邻</strong>&nbsp;格子。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/ex1new.jpg\" style=\"width: 650px; height: 404px;\"></p>\n\n<pre><b>输入：</b>grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]\n<b>输出：</b>3\n<b>解释：</b>上图展示了你在初始位置停留 3 分钟后的情形。\n你仍然可以安全到达安全屋。\n停留超过 3 分钟会让你无法安全到达安全屋。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/ex2new2.jpg\" style=\"width: 515px; height: 150px;\"></p>\n\n<pre><b>输入：</b>grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]\n<b>输出：</b>-1\n<b>解释：</b>上图展示了你马上开始朝安全屋移动的情形。\n火会蔓延到你可以移动的所有格子，所以无法安全到达安全屋。\n所以返回 -1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/ex3new.jpg\" style=\"width: 174px; height: 150px;\"></p>\n\n<pre><b>输入：</b>grid = [[0,0,0],[2,2,0],[1,2,0]]\n<b>输出：</b>1000000000\n<b>解释：</b>上图展示了初始网格图。\n注意，由于火被墙围了起来，所以无论如何你都能安全到达安全屋。\n所以返回 10<sup>9</sup> 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>4 &lt;= m * n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>grid[i][j]</code>&nbsp;是&nbsp;<code>0</code>&nbsp;，<code>1</code>&nbsp;或者&nbsp;<code>2</code>&nbsp;。</li>\n\t<li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2259移除指定数字得到的最大结果",
        "hardRate": "EASY",
        "passRate": "50.10%",
        "problemsUrl": "https://leetcode.cn/problems/remove-digit-from-number-to-maximize-result/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-digit-from-number-to-maximize-result/solution",
        "problemsDesc": "<p>给你一个表示某个正整数的字符串 <code>number</code> 和一个字符 <code>digit</code> 。</p>\n\n<p>从 <code>number</code> 中 <strong>恰好</strong> 移除 <strong>一个</strong> 等于&nbsp;<code>digit</code> 的字符后，找出并返回按 <strong>十进制</strong> 表示 <strong>最大</strong> 的结果字符串。生成的测试用例满足 <code>digit</code> 在 <code>number</code> 中出现至少一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>number = \"123\", digit = \"3\"\n<strong>输出：</strong>\"12\"\n<strong>解释：</strong>\"123\" 中只有一个 '3' ，在移除 '3' 之后，结果为 \"12\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>number = \"1231\", digit = \"1\"\n<strong>输出：</strong>\"231\"\n<strong>解释：</strong>可以移除第一个 '1' 得到 \"231\" 或者移除第二个 '1' 得到 \"123\" 。\n由于 231 &gt; 123 ，返回 \"231\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>number = \"551\", digit = \"5\"\n<strong>输出：</strong>\"51\"\n<strong>解释：</strong>可以从 \"551\" 中移除第一个或者第二个 '5' 。\n两种方案的结果都是 \"51\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= number.length &lt;= 100</code></li>\n\t<li><code>number</code> 由数字 <code>'1'</code> 到 <code>'9'</code> 组成</li>\n\t<li><code>digit</code> 是 <code>'1'</code> 到 <code>'9'</code> 中的一个数字</li>\n\t<li><code>digit</code> 在 <code>number</code> 中出现至少一次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2260必须拿起的最小连续卡牌数",
        "hardRate": "MEDIUM",
        "passRate": "51.19%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-consecutive-cards-to-pick-up/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-consecutive-cards-to-pick-up/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>cards</code> ，其中 <code>cards[i]</code> 表示第 <code>i</code> 张卡牌的 <strong>值</strong> 。如果两张卡牌的值相同，则认为这一对卡牌 <strong>匹配</strong> 。</p>\n\n<p>返回你必须拿起的最小连续卡牌数，以使在拿起的卡牌中有一对匹配的卡牌。如果无法得到一对匹配的卡牌，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>cards = [3,4,2,3,4,7]\n<strong>输出：</strong>4\n<strong>解释：</strong>拿起卡牌 [3,4,2,3] 将会包含一对值为 3 的匹配卡牌。注意，拿起 [4,2,3,4] 也是最优方案。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>cards = [1,0,5,3]\n<strong>输出：</strong>-1\n<strong>解释：</strong>无法找出含一对匹配卡牌的一组连续卡牌。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= cards.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= cards[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2261含最多 K 个可整除元素的子数组",
        "hardRate": "MEDIUM",
        "passRate": "52.92%",
        "problemsUrl": "https://leetcode.cn/problems/k-divisible-elements-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/k-divisible-elements-subarrays/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和两个整数 <code>k</code> 和 <code>p</code> ，找出并返回满足要求的不同的子数组数，要求子数组中最多 <code>k</code> 个可被 <code>p</code> 整除的元素。</p>\n\n<p>如果满足下述条件之一，则认为数组 <code>nums1</code> 和 <code>nums2</code> 是 <strong>不同</strong> 数组：</p>\n\n<ul>\n\t<li>两数组长度 <strong>不同</strong> ，或者</li>\n\t<li>存在 <strong>至少 </strong>一个下标 <code>i</code> 满足 <code>nums1[i] != nums2[i]</code> 。</li>\n</ul>\n\n<p><strong>子数组</strong> 定义为：数组中的连续元素组成的一个 <strong>非空</strong> 序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<em><strong>2</strong></em>,3,3,<em><strong>2</strong></em>,<em><strong>2</strong></em>], k = 2, p = 2\n<strong>输出：</strong>11\n<strong>解释：</strong>\n位于下标 0、3 和 4 的元素都可以被 p = 2 整除。\n共计 11 个不同子数组都满足最多含 k = 2 个可以被 2 整除的元素：\n[2]、[2,3]、[2,3,3]、[2,3,3,2]、[3]、[3,3]、[3,3,2]、[3,3,2,2]、[3,2]、[3,2,2] 和 [2,2] 。\n注意，尽管子数组 [2] 和 [3] 在 nums 中出现不止一次，但统计时只计数一次。\n子数组 [2,3,3,2,2] 不满足条件，因为其中有 3 个元素可以被 2 整除。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4], k = 4, p = 1\n<strong>输出：</strong>10\n<strong>解释：</strong>\nnums 中的所有元素都可以被 p = 1 整除。\n此外，nums 中的每个子数组都满足最多 4 个元素可以被 1 整除。\n因为所有子数组互不相同，因此满足所有限制条件的子数组总数为 10 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= nums[i], p &lt;= 200</code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<p>你可以设计并实现时间复杂度为 <code>O(n<sup>2</sup>)</code> 的算法解决此问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2262字符串的总引力",
        "hardRate": "HARD",
        "passRate": "57.54%",
        "problemsUrl": "https://leetcode.cn/problems/total-appeal-of-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/total-appeal-of-a-string/solution",
        "problemsDesc": "<p>字符串的 <strong>引力</strong> 定义为：字符串中 <strong>不同</strong> 字符的数量。</p>\n\n<ul>\n\t<li>例如，<code>\"abbca\"</code> 的引力为 <code>3</code> ，因为其中有 <code>3</code> 个不同字符 <code>'a'</code>、<code>'b'</code> 和 <code>'c'</code> 。</li>\n</ul>\n\n<p>给你一个字符串 <code>s</code> ，返回 <strong>其所有子字符串的总引力</strong> <strong>。</strong></p>\n\n<p><strong>子字符串</strong> 定义为：字符串中的一个连续字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abbca\"\n<strong>输出：</strong>28\n<strong>解释：</strong>\"abbca\" 的子字符串有：\n- 长度为 1 的子字符串：\"a\"、\"b\"、\"b\"、\"c\"、\"a\" 的引力分别为 1、1、1、1、1，总和为 5 。\n- 长度为 2 的子字符串：\"ab\"、\"bb\"、\"bc\"、\"ca\" 的引力分别为 2、1、2、2 ，总和为 7 。\n- 长度为 3 的子字符串：\"abb\"、\"bbc\"、\"bca\" 的引力分别为 2、2、3 ，总和为 7 。\n- 长度为 4 的子字符串：\"abbc\"、\"bbca\" 的引力分别为 3、3 ，总和为 6 。\n- 长度为 5 的子字符串：\"abbca\" 的引力为 3 ，总和为 3 。\n引力总和为 5 + 7 + 7 + 6 + 3 = 28 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"code\"\n<strong>输出：</strong>20\n<strong>解释：</strong>\"code\" 的子字符串有：\n- 长度为 1 的子字符串：\"c\"、\"o\"、\"d\"、\"e\" 的引力分别为 1、1、1、1 ，总和为 4 。\n- 长度为 2 的子字符串：\"co\"、\"od\"、\"de\" 的引力分别为 2、2、2 ，总和为 6 。\n- 长度为 3 的子字符串：\"cod\"、\"ode\" 的引力分别为 3、3 ，总和为 6 。\n- 长度为 4 的子字符串：\"code\" 的引力为 4 ，总和为 4 。\n引力总和为 4 + 6 + 6 + 4 = 20 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2263数组变为有序的最小操作次数",
        "hardRate": "HARD",
        "passRate": "73.96%",
        "problemsUrl": "https://leetcode.cn/problems/make-array-non-decreasing-or-non-increasing/",
        "solutionsUrl": "https://leetcode.cn/problems/make-array-non-decreasing-or-non-increasing/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2264字符串中最大的 3 位相同数字",
        "hardRate": "EASY",
        "passRate": "61.95%",
        "problemsUrl": "https://leetcode.cn/problems/largest-3-same-digit-number-in-string/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-3-same-digit-number-in-string/solution",
        "problemsDesc": "<p>给你一个字符串 <code>num</code> ，表示一个大整数。如果一个整数满足下述所有条件，则认为该整数是一个 <strong>优质整数</strong> ：</p>\n\n<ul>\n\t<li>该整数是 <code>num</code> 的一个长度为 <code>3</code> 的 <strong>子字符串</strong> 。</li>\n\t<li>该整数由唯一一个数字重复 <code>3</code> 次组成。</li>\n</ul>\n\n<p>以字符串形式返回 <strong>最大的优质整数</strong> 。如果不存在满足要求的整数，则返回一个空字符串 <code>\"\"</code> 。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><strong>子字符串</strong> 是字符串中的一个连续字符序列。</li>\n\t<li><code>num</code> 或优质整数中可能存在 <strong>前导零</strong> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"6<em><strong>777</strong></em>133339\"\n<strong>输出：</strong>\"777\"\n<strong>解释：</strong>num 中存在两个优质整数：\"777\" 和 \"333\" 。\n\"777\" 是最大的那个，所以返回 \"777\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"23<em><strong>000</strong></em>19\"\n<strong>输出：</strong>\"000\"\n<strong>解释：</strong>\"000\" 是唯一一个优质整数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"42352338\"\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>不存在长度为 3 且仅由一个唯一数字组成的整数。因此，不存在优质整数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= num.length &lt;= 1000</code></li>\n\t<li><code>num</code> 仅由数字（<code>0</code> - <code>9</code>）组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2265统计值等于子树平均值的节点数",
        "hardRate": "MEDIUM",
        "passRate": "82.65%",
        "problemsUrl": "https://leetcode.cn/problems/count-nodes-equal-to-average-of-subtree/",
        "solutionsUrl": "https://leetcode.cn/problems/count-nodes-equal-to-average-of-subtree/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点 <code>root</code> ，找出并返回满足要求的节点数，要求节点的值等于其 <strong>子树</strong> 中值的 <strong>平均值</strong> 。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><code>n</code> 个元素的平均值可以由 <code>n</code> 个元素 <strong>求和</strong> 然后再除以 <code>n</code> ，并 <strong>向下舍入</strong> 到最近的整数。</li>\n\t<li><code>root</code> 的 <strong>子树</strong> 由 <code>root</code> 和它的所有后代组成。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/03/15/image-20220315203925-1.png\" style=\"width: 300px; height: 212px;\">\n<pre><strong>输入：</strong>root = [4,8,5,0,1,null,6]\n<strong>输出：</strong>5\n<strong>解释：</strong>\n对值为 4 的节点：子树的平均值 (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4 。\n对值为 5 的节点：子树的平均值 (5 + 6) / 2 = 11 / 2 = 5 。\n对值为 0 的节点：子树的平均值 0 / 1 = 0 。\n对值为 1 的节点：子树的平均值 1 / 1 = 1 。\n对值为 6 的节点：子树的平均值 6 / 1 = 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/03/26/image-20220326133920-1.png\" style=\"width: 80px; height: 76px;\">\n<pre><strong>输入：</strong>root = [1]\n<strong>输出：</strong>1\n<strong>解释：</strong>对值为 1 的节点：子树的平均值 1 / 1 = 1。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[1, 1000]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2266统计打字方案数",
        "hardRate": "MEDIUM",
        "passRate": "43.59%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-texts/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-texts/solution",
        "problemsDesc": "<p>Alice 在给 Bob 用手机打字。数字到字母的 <strong>对应</strong>&nbsp;如下图所示。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png\" style=\"width: 200px; height: 162px;\"></p>\n\n<p>为了 <strong>打出</strong>&nbsp;一个字母，Alice 需要 <strong>按</strong>&nbsp;对应字母 <code>i</code>&nbsp;次，<code>i</code>&nbsp;是该字母在这个按键上所处的位置。</p>\n\n<ul>\n\t<li>比方说，为了按出字母&nbsp;<code>'s'</code>&nbsp;，Alice 需要按&nbsp;<code>'7'</code>&nbsp;四次。类似的， Alice 需要按&nbsp;<code>'5'</code>&nbsp;两次得到字母&nbsp;&nbsp;<code>'k'</code>&nbsp;。</li>\n\t<li>注意，数字&nbsp;<code>'0'</code> 和&nbsp;<code>'1'</code>&nbsp;不映射到任何字母，所以&nbsp;Alice <strong>不</strong>&nbsp;使用它们。</li>\n</ul>\n\n<p>但是，由于传输的错误，Bob 没有收到 Alice 打字的字母信息，反而收到了 <strong>按键的字符串信息</strong>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，Alice 发出的信息为&nbsp;<code>\"bob\"</code>&nbsp;，Bob 将收到字符串&nbsp;<code>\"2266622\"</code>&nbsp;。</li>\n</ul>\n\n<p>给你一个字符串&nbsp;<code>pressedKeys</code>&nbsp;，表示 Bob 收到的字符串，请你返回 Alice <strong>总共可能发出多少种文字信息</strong>&nbsp;。</p>\n\n<p>由于答案可能很大，将它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong> 后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>pressedKeys = \"22233\"\n<b>输出：</b>8\n<strong>解释：</strong>\nAlice 可能发出的文字信息包括：\n\"aaadd\", \"abdd\", \"badd\", \"cdd\", \"aaae\", \"abe\", \"bae\" 和 \"ce\" 。\n由于总共有 8 种可能的信息，所以我们返回 8 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>pressedKeys = \"222222222222222222222222222222222222\"\n<b>输出：</b>82876089\n<strong>解释：</strong>\n总共有 2082876103 种 Alice 可能发出的文字信息。\n由于我们需要将答案对 10<sup>9</sup> + 7 取余，所以我们返回 2082876103 % (10<sup>9</sup> + 7) = 82876089 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pressedKeys.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pressedKeys</code> 只包含数字&nbsp;<code>'2'</code>&nbsp;到&nbsp;<code>'9'</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2267检查是否有合法括号字符串路径",
        "hardRate": "HARD",
        "passRate": "37.91%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-there-is-a-valid-parentheses-string-path/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-there-is-a-valid-parentheses-string-path/solution",
        "problemsDesc": "<p>一个括号字符串是一个 <strong>非空</strong>&nbsp;且只包含&nbsp;<code>'('</code>&nbsp;和&nbsp;<code>')'</code>&nbsp;的字符串。如果下面&nbsp;<strong>任意</strong>&nbsp;条件为&nbsp;<strong>真</strong>&nbsp;，那么这个括号字符串就是&nbsp;<strong>合法的</strong>&nbsp;。</p>\n\n<ul>\n\t<li>字符串是&nbsp;<code>()</code>&nbsp;。</li>\n\t<li>字符串可以表示为&nbsp;<code>AB</code>（<code>A</code>&nbsp;连接&nbsp;<code>B</code>），<code>A</code> 和&nbsp;<code>B</code>&nbsp;都是合法括号序列。</li>\n\t<li>字符串可以表示为&nbsp;<code>(A)</code>&nbsp;，其中&nbsp;<code>A</code>&nbsp;是合法括号序列。</li>\n</ul>\n\n<p>给你一个&nbsp;<code>m x n</code>&nbsp;的括号网格图矩阵&nbsp;<code>grid</code>&nbsp;。网格图中一个&nbsp;<strong>合法括号路径</strong>&nbsp;是满足以下所有条件的一条路径：</p>\n\n<ul>\n\t<li>路径开始于左上角格子&nbsp;<code>(0, 0)</code>&nbsp;。</li>\n\t<li>路径结束于右下角格子&nbsp;<code>(m - 1, n - 1)</code>&nbsp;。</li>\n\t<li>路径每次只会向 <strong>下</strong>&nbsp;或者向 <strong>右</strong>&nbsp;移动。</li>\n\t<li>路径经过的格子组成的括号字符串是<strong>&nbsp;合法</strong>&nbsp;的。</li>\n</ul>\n\n<p>如果网格图中存在一条 <strong>合法括号路径</strong>&nbsp;，请返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/15/example1drawio.png\" style=\"width: 521px; height: 300px;\" /></p>\n\n<pre>\n<b>输入：</b>grid = [[\"(\",\"(\",\"(\"],[\")\",\"(\",\")\"],[\"(\",\"(\",\")\"],[\"(\",\"(\",\")\"]]\n<b>输出：</b>true\n<b>解释：</b>上图展示了两条路径，它们都是合法括号字符串路径。\n第一条路径得到的合法字符串是 \"()(())\" 。\n第二条路径得到的合法字符串是 \"((()))\" 。\n注意可能有其他的合法括号字符串路径。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/15/example2drawio.png\" style=\"width: 165px; height: 165px;\" /></p>\n\n<pre>\n<b>输入：</b>grid = [[\")\",\")\"],[\"(\",\"(\"]]\n<b>输出：</b>false\n<b>解释：</b>两条可行路径分别得到 \"))(\" 和 \")((\" 。由于它们都不是合法括号字符串，我们返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>grid[i][j]</code>&nbsp;要么是&nbsp;<code>'('</code>&nbsp;，要么是&nbsp;<code>')'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2268最少按键次数",
        "hardRate": "MEDIUM",
        "passRate": "68.16%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-keypresses/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-keypresses/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2269找到一个数字的 K 美丽值",
        "hardRate": "EASY",
        "passRate": "62.70%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-k-beauty-of-a-number/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-k-beauty-of-a-number/solution",
        "problemsDesc": "<p>一个整数 <code>num</code>&nbsp;的&nbsp;<strong>k&nbsp;</strong>美丽值定义为&nbsp;<code>num</code>&nbsp;中符合以下条件的&nbsp;<strong>子字符串</strong>&nbsp;数目：</p>\n\n<ul>\n\t<li>子字符串长度为&nbsp;<code>k</code>&nbsp;。</li>\n\t<li>子字符串能整除 <code>num</code> 。</li>\n</ul>\n\n<p>给你整数&nbsp;<code>num</code> 和&nbsp;<code>k</code>&nbsp;，请你返回<em>&nbsp;</em><code>num</code>&nbsp;的 k 美丽值。</p>\n\n<p>注意：</p>\n\n<ul>\n\t<li>允许有&nbsp;<strong>前缀</strong>&nbsp;<strong>0</strong>&nbsp;。</li>\n\t<li><code>0</code>&nbsp;不能整除任何值。</li>\n</ul>\n\n<p>一个 <strong>子字符串</strong>&nbsp;是一个字符串里的连续一段字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>num = 240, k = 2\n<b>输出：</b>2\n<b>解释：</b>以下是 num 里长度为 k 的子字符串：\n- \"<em><strong>24</strong></em>0\" 中的 \"24\" ：24 能整除 240 。\n- \"2<em><strong>40</strong></em>\" 中的 \"40\" ：40 能整除 240 。\n所以，k 美丽值为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>num = 430043, k = 2\n<b>输出：</b>2\n<b>解释：</b>以下是 num 里长度为 k 的子字符串：\n- \"<em><strong>43</strong></em>0043\" 中的 \"43\" ：43 能整除 430043 。\n- \"4<em><strong>30</strong></em>043\" 中的 \"30\" ：30 不能整除 430043 。\n- \"43<em><strong>00</strong></em>43\" 中的 \"00\" ：0 不能整除 430043 。\n- \"430<em><strong>04</strong></em>3\" 中的 \"04\" ：4 不能整除 430043 。\n- \"4300<em><strong>43</strong></em>\" 中的 \"43\" ：43 能整除 430043 。\n所以，k 美丽值为 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= num.length</code>&nbsp;（将&nbsp;<code>num</code>&nbsp;视为字符串）</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2270分割数组的方案数",
        "hardRate": "MEDIUM",
        "passRate": "46.46%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-split-array/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-split-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;。<br />\n<span style=\"\">如果以下描述为真，那么</span><span style=\"\"> </span><code>nums</code>&nbsp;在下标 <code>i</code>&nbsp;处有一个 <strong>合法的分割</strong>&nbsp;：</p>\n\n<ul>\n\t<li>前&nbsp;<code>i + 1</code>&nbsp;个元素的和 <strong>大于等于</strong>&nbsp;剩下的&nbsp;<code>n - i - 1</code>&nbsp;个元素的和。</li>\n\t<li>下标 <code>i</code>&nbsp;的右边 <strong>至少有一个</strong>&nbsp;元素，也就是说下标&nbsp;<code>i</code>&nbsp;满足&nbsp;<code>0 &lt;= i &lt; n - 1</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回&nbsp;<code>nums</code>&nbsp;中的&nbsp;<strong>合法分割</strong>&nbsp;方案数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [10,4,-8,7]\n<b>输出：</b>2\n<b>解释：</b>\n总共有 3 种不同的方案可以将 nums 分割成两个非空的部分：\n- 在下标 0 处分割 nums 。那么第一部分为 [10] ，和为 10 。第二部分为 [4,-8,7] ，和为 3 。因为 10 &gt;= 3 ，所以 i = 0 是一个合法的分割。\n- 在下标 1 处分割 nums 。那么第一部分为 [10,4] ，和为 14 。第二部分为 [-8,7] ，和为 -1 。因为 14 &gt;= -1 ，所以 i = 1 是一个合法的分割。\n- 在下标 2 处分割 nums 。那么第一部分为 [10,4,-8] ，和为 6 。第二部分为 [7] ，和为 7 。因为 6 &lt; 7 ，所以 i = 2 不是一个合法的分割。\n所以 nums 中总共合法分割方案受为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,3,1,0]\n<b>输出：</b>2\n<b>解释：</b>\n总共有 2 种 nums 的合法分割：\n- 在下标 1 处分割 nums 。那么第一部分为 [2,3] ，和为 5 。第二部分为 [1,0] ，和为 1 。因为 5 &gt;= 1 ，所以 i = 1 是一个合法的分割。\n- 在下标 2 处分割 nums 。那么第一部分为 [2,3,1] ，和为 6 。第二部分为 [0] ，和为 0 。因为 6 &gt;= 0 ，所以 i = 2 是一个合法的分割。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2271毯子覆盖的最多白色砖块数",
        "hardRate": "MEDIUM",
        "passRate": "32.77%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-white-tiles-covered-by-a-carpet/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-white-tiles-covered-by-a-carpet/solution",
        "problemsDesc": "<p>给你一个二维整数数组&nbsp;<code>tiles</code>&nbsp;，其中&nbsp;<code>tiles[i] = [l<sub>i</sub>, r<sub>i</sub>]</code>&nbsp;，表示所有在&nbsp;<code>l<sub>i</sub> &lt;= j &lt;= r<sub>i</sub></code>&nbsp;之间的每个瓷砖位置 <code>j</code>&nbsp;都被涂成了白色。</p>\n\n<p>同时给你一个整数&nbsp;<code>carpetLen</code>&nbsp;，表示可以放在&nbsp;<strong>任何位置</strong>&nbsp;的一块毯子。</p>\n\n<p>请你返回使用这块毯子，<strong>最多</strong>&nbsp;可以盖住多少块瓷砖。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/25/example1drawio3.png\" style=\"width: 644px; height: 158px;\" /></p>\n\n<pre>\n<b>输入：</b>tiles = [[1,5],[10,11],[12,18],[20,25],[30,32]], carpetLen = 10\n<b>输出：</b>9\n<b>解释：</b>将毯子从瓷砖 10 开始放置。\n总共覆盖 9 块瓷砖，所以返回 9 。\n注意可能有其他方案也可以覆盖 9 块瓷砖。\n可以看出，瓷砖无法覆盖超过 9 块瓷砖。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/24/example2drawio.png\" style=\"width: 231px; height: 168px;\" /></p>\n\n<pre>\n<strong>输入：</strong>tiles = [[10,11],[1,1]], carpetLen = 2\n<b>输出：</b>2\n<b>解释：</b>将毯子从瓷砖 10 开始放置。\n总共覆盖 2 块瓷砖，所以我们返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tiles.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>tiles[i].length == 2</code></li>\n\t<li><code>1 &lt;= l<sub>i</sub> &lt;= r<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= carpetLen &lt;= 10<sup>9</sup></code></li>\n\t<li><code>tiles</code>&nbsp;互相 <strong>不会重叠</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2272最大波动的子字符串",
        "hardRate": "HARD",
        "passRate": "38.83%",
        "problemsUrl": "https://leetcode.cn/problems/substring-with-largest-variance/",
        "solutionsUrl": "https://leetcode.cn/problems/substring-with-largest-variance/solution",
        "problemsDesc": "<p>字符串的 <strong>波动</strong>&nbsp;定义为子字符串中出现次数 <strong>最多</strong>&nbsp;的字符次数与出现次数 <strong>最少</strong>&nbsp;的字符次数之差。</p>\n\n<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，它只包含小写英文字母。请你返回 <code>s</code>&nbsp;里所有 <strong>子字符串的</strong>&nbsp;<strong>最大波动</strong>&nbsp;值。</p>\n\n<p><strong>子字符串</strong> 是一个字符串的一段连续字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"aababbb\"\n<b>输出：</b>3\n<strong>解释：</strong>\n所有可能的波动值和它们对应的子字符串如以下所示：\n- 波动值为 0 的子字符串：\"a\" ，\"aa\" ，\"ab\" ，\"abab\" ，\"aababb\" ，\"ba\" ，\"b\" ，\"bb\" 和 \"bbb\" 。\n- 波动值为 1 的子字符串：\"aab\" ，\"aba\" ，\"abb\" ，\"aabab\" ，\"ababb\" ，\"aababbb\" 和 \"bab\" 。\n- 波动值为 2 的子字符串：\"aaba\" ，\"ababbb\" ，\"abbb\" 和 \"babb\" 。\n- 波动值为 3 的子字符串 \"babbb\" 。\n所以，最大可能波动值为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"abcde\"\n<b>输出：</b>0\n<strong>解释：</strong>\ns 中没有字母出现超过 1 次，所以 s 中每个子字符串的波动值都是 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code>&nbsp; 只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2273移除字母异位词后的结果数组",
        "hardRate": "EASY",
        "passRate": "59.73%",
        "problemsUrl": "https://leetcode.cn/problems/find-resultant-array-after-removing-anagrams/",
        "solutionsUrl": "https://leetcode.cn/problems/find-resultant-array-after-removing-anagrams/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>words</code> ，其中 <code>words[i]</code> 由小写英文字符组成。</p>\n\n<p>在一步操作中，需要选出任一下标 <code>i</code> ，从 <code>words</code> 中 <strong>删除</strong> <code>words[i]</code> 。其中下标 <code>i</code> 需要同时满足下述两个条件：</p>\n\n<ol>\n\t<li><code>0 &lt; i &lt; words.length</code></li>\n\t<li><code>words[i - 1]</code> 和 <code>words[i]</code> 是 <strong>字母异位词</strong> 。</li>\n</ol>\n\n<p>只要可以选出满足条件的下标，就一直执行这个操作。</p>\n\n<p>在执行所有操作后，返回 <code>words</code> 。可以证明，按任意顺序为每步操作选择下标都会得到相同的结果。</p>\n\n<p><strong>字母异位词</strong> 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。例如，<code>\"dacb\"</code> 是 <code>\"abdc\"</code> 的一个字母异位词。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"abba\",\"baba\",\"bbaa\",\"cd\",\"cd\"]\n<strong>输出：</strong>[\"abba\",\"cd\"]\n<strong>解释：</strong>\n获取结果数组的方法之一是执行下述步骤：\n- 由于 words[2] = \"bbaa\" 和 words[1] = \"baba\" 是字母异位词，选择下标 2 并删除 words[2] 。\n  现在 words = [\"abba\",\"baba\",\"cd\",\"cd\"] 。\n- 由于 words[1] = \"baba\" 和 words[0] = \"abba\" 是字母异位词，选择下标 1 并删除 words[1] 。\n  现在 words = [\"abba\",\"cd\",\"cd\"] 。\n- 由于 words[2] = \"cd\" 和 words[1] = \"cd\" 是字母异位词，选择下标 2 并删除 words[2] 。\n  现在 words = [\"abba\",\"cd\"] 。\n无法再执行任何操作，所以 [\"abba\",\"cd\"] 是最终答案。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"a\",\"b\",\"c\",\"d\",\"e\"]\n<strong>输出：</strong>[\"a\",\"b\",\"c\",\"d\",\"e\"]\n<strong>解释：</strong>\nwords 中不存在互为字母异位词的两个相邻字符串，所以无需执行任何操作。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>words[i]</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2274不含特殊楼层的最大连续楼层数",
        "hardRate": "MEDIUM",
        "passRate": "52.56%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-consecutive-floors-without-special-floors/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-consecutive-floors-without-special-floors/solution",
        "problemsDesc": "<p>Alice 管理着一家公司，并租用大楼的部分楼层作为办公空间。Alice 决定将一些楼层作为 <strong>特殊楼层</strong> ，仅用于放松。</p>\n\n<p>给你两个整数 <code>bottom</code> 和 <code>top</code> ，表示 Alice 租用了从 <code>bottom</code> 到 <code>top</code>（含 <code>bottom</code> 和 <code>top</code> 在内）的所有楼层。另给你一个整数数组 <code>special</code> ，其中 <code>special[i]</code> 表示&nbsp; Alice 指定用于放松的特殊楼层。</p>\n\n<p>返回不含特殊楼层的 <strong>最大</strong> 连续楼层数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>bottom = 2, top = 9, special = [4,6]\n<strong>输出：</strong>3\n<strong>解释：</strong>下面列出的是不含特殊楼层的连续楼层范围：\n- (2, 3) ，楼层数为 2 。\n- (5, 5) ，楼层数为 1 。\n- (7, 9) ，楼层数为 3 。\n因此，返回最大连续楼层数 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>bottom = 6, top = 8, special = [7,6,8]\n<strong>输出：</strong>0\n<strong>解释：</strong>每层楼都被规划为特殊楼层，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= special.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= bottom &lt;= special[i] &lt;= top &lt;= 10<sup>9</sup></code></li>\n\t<li><code>special</code> 中的所有值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2275按位与结果大于零的最长组合",
        "hardRate": "MEDIUM",
        "passRate": "60.11%",
        "problemsUrl": "https://leetcode.cn/problems/largest-combination-with-bitwise-and-greater-than-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-combination-with-bitwise-and-greater-than-zero/solution",
        "problemsDesc": "<p>对数组&nbsp;<code>nums</code> 执行 <strong>按位与</strong> 相当于对数组&nbsp;<code>nums</code> 中的所有整数执行 <strong>按位与</strong> 。</p>\n\n<ul>\n\t<li>例如，对 <code>nums = [1, 5, 3]</code> 来说，按位与等于 <code>1 &amp; 5 &amp; 3 = 1</code> 。</li>\n\t<li>同样，对 <code>nums = [7]</code> 而言，按位与等于 <code>7</code> 。</li>\n</ul>\n\n<p>给你一个正整数数组 <code>candidates</code> 。计算 <code>candidates</code> 中的数字每种组合下 <strong>按位与</strong> 的结果。 <code>candidates</code> 中的每个数字在每种组合中只能使用 <strong>一次</strong> 。</p>\n\n<p>返回按位与结果大于 <code>0</code> 的 <strong>最长</strong> 组合的长度<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>candidates = [16,17,71,62,12,24,14]\n<strong>输出：</strong>4\n<strong>解释：</strong>组合 [16,17,62,24] 的按位与结果是 16 &amp; 17 &amp; 62 &amp; 24 = 16 &gt; 0 。\n组合长度是 4 。\n可以证明不存在按位与结果大于 0 且长度大于 4 的组合。\n注意，符合长度最大的组合可能不止一种。\n例如，组合 [62,12,24,14] 的按位与结果是 62 &amp; 12 &amp; 24 &amp; 14 = 8 &gt; 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>candidates = [8,8]\n<strong>输出：</strong>2\n<strong>解释：</strong>最长组合是 [8,8] ，按位与结果 8 &amp; 8 = 8 &gt; 0 。\n组合长度是 2 ，所以返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= candidates.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= candidates[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2276统计区间中的整数数目",
        "hardRate": "HARD",
        "passRate": "36.96%",
        "problemsUrl": "https://leetcode.cn/problems/count-integers-in-intervals/",
        "solutionsUrl": "https://leetcode.cn/problems/count-integers-in-intervals/solution",
        "problemsDesc": "<p>给你区间的 <strong>空</strong> 集，请你设计并实现满足要求的数据结构：</p>\n\n<ul>\n\t<li><strong>新增：</strong>添加一个区间到这个区间集合中。</li>\n\t<li><strong>统计：</strong>计算出现在 <strong>至少一个</strong> 区间中的整数个数。</li>\n</ul>\n\n<p>实现 <code>CountIntervals</code> 类：</p>\n\n<ul>\n\t<li><code>CountIntervals()</code> 使用区间的空集初始化对象</li>\n\t<li><code>void add(int left, int right)</code> 添加区间 <code>[left, right]</code> 到区间集合之中。</li>\n\t<li><code>int count()</code> 返回出现在 <strong>至少一个</strong> 区间中的整数个数。</li>\n</ul>\n\n<p><strong>注意：</strong>区间 <code>[left, right]</code> 表示满足 <code>left &lt;= x &lt;= right</code> 的所有整数 <code>x</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"CountIntervals\", \"add\", \"add\", \"count\", \"add\", \"count\"]\n[[], [2, 3], [7, 10], [], [5, 8], []]\n<strong>输出</strong>\n[null, null, null, 6, null, 8]\n\n<strong>解释</strong>\nCountIntervals countIntervals = new CountIntervals(); // 用一个区间空集初始化对象\ncountIntervals.add(2, 3);  // 将 [2, 3] 添加到区间集合中\ncountIntervals.add(7, 10); // 将 [7, 10] 添加到区间集合中\ncountIntervals.count();    // 返回 6\n                           // 整数 2 和 3 出现在区间 [2, 3] 中\n                           // 整数 7、8、9、10 出现在区间 [7, 10] 中\ncountIntervals.add(5, 8);  // 将 [5, 8] 添加到区间集合中\ncountIntervals.count();    // 返回 8\n                           // 整数 2 和 3 出现在区间 [2, 3] 中\n                           // 整数 5 和 6 出现在区间 [5, 8] 中\n                           // 整数 7 和 8 出现在区间 [5, 8] 和区间 [7, 10] 中\n                           // 整数 9 和 10 出现在区间 [7, 10] 中</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= left &lt;= right &lt;= 10<sup>9</sup></code></li>\n\t<li>最多调用&nbsp; <code>add</code> 和 <code>count</code> 方法 <strong>总计</strong> <code>10<sup>5</sup></code> 次</li>\n\t<li>调用 <code>count</code> 方法至少一次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2277树中最接近路径的节点",
        "hardRate": "HARD",
        "passRate": "71.86%",
        "problemsUrl": "https://leetcode.cn/problems/closest-node-to-path-in-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-node-to-path-in-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2278字母在字符串中的百分比",
        "hardRate": "EASY",
        "passRate": "80.80%",
        "problemsUrl": "https://leetcode.cn/problems/percentage-of-letter-in-string/",
        "solutionsUrl": "https://leetcode.cn/problems/percentage-of-letter-in-string/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和一个字符 <code>letter</code> ，返回在 <code>s</code> 中等于&nbsp;<code>letter</code>&nbsp;字符所占的 <strong>百分比</strong> ，向下取整到最接近的百分比。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"foobar\", letter = \"o\"\n<strong>输出：</strong>33\n<strong>解释：</strong>\n等于字母 'o' 的字符在 s 中占到的百分比是 2 / 6 * 100% = 33% ，向下取整，所以返回 33 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"jjjj\", letter = \"k\"\n<strong>输出：</strong>0\n<strong>解释：</strong>\n等于字母 'k' 的字符在 s 中占到的百分比是 0% ，所以返回 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n\t<li><code>letter</code> 是一个小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2279装满石头的背包的最大数量",
        "hardRate": "MEDIUM",
        "passRate": "63.74%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-bags-with-full-capacity-of-rocks/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-bags-with-full-capacity-of-rocks/solution",
        "problemsDesc": "<p>现有编号从&nbsp;<code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个背包。给你两个下标从 <strong>0</strong> 开始的整数数组 <code>capacity</code> 和 <code>rocks</code> 。第 <code>i</code> 个背包最大可以装 <code>capacity[i]</code> 块石头，当前已经装了 <code>rocks[i]</code> 块石头。另给你一个整数 <code>additionalRocks</code> ，表示<span class=\"text-only\" data-eleid=\"10\" style=\"white-space: pre;\">你可以放置的额外石头数量，石头可以往 </span><strong><span class=\"text-only\" data-eleid=\"11\" style=\"white-space: pre;\">任意</span></strong><span class=\"text-only\" data-eleid=\"12\" style=\"white-space: pre;\"> 背包中放置。</span></p>\n\n<p>请你将额外的石头放入一些背包中，并返回放置后装满石头的背包的 <strong>最大 </strong>数量<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>\n1 块石头放入背包 0 ，1 块石头放入背包 1 。\n每个背包中的石头总数是 [2,3,4,4] 。\n背包 0 、背包 1 和 背包 2 都装满石头。\n总计 3 个背包装满石头，所以返回 3 。\n可以证明不存在超过 3 个背包装满石头的情况。\n注意，可能存在其他放置石头的方案同样能够得到 3 这个结果。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100\n<strong>输出：</strong>3\n<strong>解释：</strong>\n8 块石头放入背包 0 ，2 块石头放入背包 2 。\n每个背包中的石头总数是 [10,2,2] 。\n背包 0 、背包 1 和背包 2 都装满石头。\n总计 3 个背包装满石头，所以返回 3 。\n可以证明不存在超过 3 个背包装满石头的情况。\n注意，不必用完所有的额外石头。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == capacity.length == rocks.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= capacity[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= rocks[i] &lt;= capacity[i]</code></li>\n\t<li><code>1 &lt;= additionalRocks &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2280表示一个折线图的最少线段数",
        "hardRate": "MEDIUM",
        "passRate": "22.44%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-lines-to-represent-a-line-chart/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-lines-to-represent-a-line-chart/solution",
        "problemsDesc": "<p>给你一个二维整数数组&nbsp;<code>stockPrices</code> ，其中&nbsp;<code>stockPrices[i] = [day<sub>i</sub>, price<sub>i</sub>]</code>&nbsp;表示股票在&nbsp;<code>day<sub>i</sub></code>&nbsp;的价格为&nbsp;<code>price<sub>i</sub></code>&nbsp;。<strong>折线图</strong>&nbsp;是一个二维平面上的若干个点组成的图，横坐标表示日期，纵坐标表示价格，折线图由相邻的点连接而成。比方说下图是一个例子：</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/30/1920px-pushkin_population_historysvg.png\" style=\"width: 500px; height: 313px;\">\n<p>请你返回要表示一个折线图所需要的 <strong>最少线段数</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/30/ex0.png\" style=\"width: 400px; height: 400px;\"></p>\n\n<pre><b>输入：</b>stockPrices = [[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]\n<b>输出：</b>3\n<strong>解释：</strong>\n上图为输入对应的图，横坐标表示日期，纵坐标表示价格。\n以下 3 个线段可以表示折线图：\n- 线段 1 （红色）从 (1,7) 到 (4,4) ，经过 (1,7) ，(2,6) ，(3,5) 和 (4,4) 。\n- 线段 2 （蓝色）从 (4,4) 到 (5,4) 。\n- 线段 3 （绿色）从 (5,4) 到 (8,1) ，经过 (5,4) ，(6,3) ，(7,2) 和 (8,1) 。\n可以证明，无法用少于 3 条线段表示这个折线图。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/30/ex1.png\" style=\"width: 325px; height: 325px;\"></p>\n\n<pre><b>输入：</b>stockPrices = [[3,4],[1,2],[7,8],[2,3]]\n<b>输出：</b>1\n<strong>解释：</strong>\n如上图所示，折线图可以用一条线段表示。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= stockPrices.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>stockPrices[i].length == 2</code></li>\n\t<li><code>1 &lt;= day<sub>i</sub>, price<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li>所有&nbsp;<code>day<sub>i</sub></code>&nbsp;<strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2281巫师的总力量和",
        "hardRate": "HARD",
        "passRate": "26.64%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-total-strength-of-wizards/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-total-strength-of-wizards/solution",
        "problemsDesc": "<p>作为国王的统治者，你有一支巫师军队听你指挥。</p>\n\n<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>strength</code>&nbsp;，其中&nbsp;<code>strength[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;位巫师的力量值。对于连续的一组巫师（也就是这些巫师的力量值是&nbsp;<code>strength</code>&nbsp;的&nbsp;<strong>子数组</strong>），<strong>总力量</strong>&nbsp;定义为以下两个值的&nbsp;<strong>乘积</strong>&nbsp;：</p>\n\n<ul>\n\t<li>巫师中 <strong>最弱</strong>&nbsp;的能力值。</li>\n\t<li>组中所有巫师的个人力量值 <strong>之和</strong>&nbsp;。</li>\n</ul>\n\n<p>请你返回 <strong>所有</strong>&nbsp;巫师组的 <strong>总</strong>&nbsp;力量之和。由于答案可能很大，请将答案对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p><strong>子数组</strong>&nbsp;是一个数组里 <strong>非空</strong>&nbsp;连续子序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>strength = [1,3,1,2]\n<b>输出：</b>44\n<b>解释：</b>以下是所有连续巫师组：\n- [<em><strong>1</strong></em>,3,1,2] 中 [1] ，总力量值为 min([1]) * sum([1]) = 1 * 1 = 1\n- [1,<em><strong>3</strong></em>,1,2] 中 [3] ，总力量值为 min([3]) * sum([3]) = 3 * 3 = 9\n- [1,3,<em><strong>1</strong></em>,2] 中 [1] ，总力量值为 min([1]) * sum([1]) = 1 * 1 = 1\n- [1,3,1,<em><strong>2</strong></em>] 中 [2] ，总力量值为 min([2]) * sum([2]) = 2 * 2 = 4\n- [<em><strong>1,3</strong></em>,1,2] 中 [1,3] ，总力量值为 min([1,3]) * sum([1,3]) = 1 * 4 = 4\n- [1,<em><strong>3,1</strong></em>,2] 中 [3,1] ，总力量值为 min([3,1]) * sum([3,1]) = 1 * 4 = 4\n- [1,3,<em><strong>1,2</strong></em>] 中 [1,2] ，总力量值为 min([1,2]) * sum([1,2]) = 1 * 3 = 3\n- [<em><strong>1,3,1</strong></em>,2] 中 [1,3,1] ，总力量值为 min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5\n- [1,<em><strong>3,1,2</strong></em>] 中 [3,1,2] ，总力量值为 min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6\n- [<em><strong>1,3,1,2</strong></em>] 中 [1,3,1,2] ，总力量值为 min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7\n所有力量值之和为 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>strength = [5,4,6]\n<b>输出：</b>213\n<b>解释：</b>以下是所有连续巫师组：\n- [<em><strong>5</strong></em>,4,6] 中 [5] ，总力量值为 min([5]) * sum([5]) = 5 * 5 = 25\n- [5,<em><strong>4</strong></em>,6] 中 [4] ，总力量值为 min([4]) * sum([4]) = 4 * 4 = 16\n- [5,4,<em><strong>6</strong></em>] 中 [6] ，总力量值为 min([6]) * sum([6]) = 6 * 6 = 36\n- [<em><strong>5,4</strong></em>,6] 中 [5,4] ，总力量值为 min([5,4]) * sum([5,4]) = 4 * 9 = 36\n- [5,<em><strong>4,6</strong></em>] 中 [4,6] ，总力量值为 min([4,6]) * sum([4,6]) = 4 * 10 = 40\n- [<em><strong>5,4,6</strong></em>] 中 [5,4,6] ，总力量值为 min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60\n所有力量值之和为 25 + 16 + 36 + 36 + 40 + 60 = 213 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strength.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= strength[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2282在一个网格中可以看到的人数",
        "hardRate": "MEDIUM",
        "passRate": "48.33%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-people-that-can-be-seen-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-people-that-can-be-seen-in-a-grid/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2283判断一个数的数字计数是否等于数位的值",
        "hardRate": "EASY",
        "passRate": "78.96%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-number-has-equal-digit-count-and-digit-value/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-number-has-equal-digit-count-and-digit-value/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的字符串&nbsp;<code>num</code>&nbsp;，它只包含数字。</p>\n\n<p>如果对于 <strong>每个</strong><em>&nbsp;</em><code>0 &lt;= i &lt; n</code>&nbsp;的下标&nbsp;<code>i</code>&nbsp;，都满足数位<em>&nbsp;</em><code>i</code>&nbsp;在 <code>num</code>&nbsp;中出现了&nbsp;<code>num[i]</code>次，那么请你返回&nbsp;<code>true</code>&nbsp;，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>num = \"1210\"\n<b>输出：</b>true\n<strong>解释：</strong>\nnum[0] = '1' 。数字 0 在 num 中出现了一次。\nnum[1] = '2' 。数字 1 在 num 中出现了两次。\nnum[2] = '1' 。数字 2 在 num 中出现了一次。\nnum[3] = '0' 。数字 3 在 num 中出现了零次。\n\"1210\" 满足题目要求条件，所以返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>num = \"030\"\n<b>输出：</b>false\n<strong>解释：</strong>\nnum[0] = '0' 。数字 0 应该出现 0 次，但是在 num 中出现了两次。\nnum[1] = '3' 。数字 1 应该出现 3 次，但是在 num 中出现了零次。\nnum[2] = '0' 。数字 2 在 num 中出现了 0 次。\n下标 0 和 1 都违反了题目要求，所以返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == num.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10</code></li>\n\t<li><code>num</code>&nbsp;只包含数字。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2284最多单词数的发件人",
        "hardRate": "MEDIUM",
        "passRate": "56.84%",
        "problemsUrl": "https://leetcode.cn/problems/sender-with-largest-word-count/",
        "solutionsUrl": "https://leetcode.cn/problems/sender-with-largest-word-count/solution",
        "problemsDesc": "<p>给你一个聊天记录，共包含 <code>n</code>&nbsp;条信息。给你两个字符串数组&nbsp;<code>messages</code> 和&nbsp;<code>senders</code>&nbsp;，其中&nbsp;<code>messages[i]</code>&nbsp;是&nbsp;<code>senders[i]</code>&nbsp;发出的一条&nbsp;<strong>信息</strong>&nbsp;。</p>\n\n<p>一条 <strong>信息</strong>&nbsp;是若干用单个空格连接的 <strong>单词</strong>&nbsp;，信息开头和结尾不会有多余空格。发件人的 <strong>单词计数</strong>&nbsp;是这个发件人总共发出的 <strong>单词数</strong>&nbsp;。注意，一个发件人可能会发出多于一条信息。</p>\n\n<p>请你返回发出单词数 <strong>最多</strong>&nbsp;的发件人名字。如果有多个发件人发出最多单词数，请你返回 <strong>字典序</strong>&nbsp;最大的名字。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>字典序里，大写字母小于小写字母。</li>\n\t<li><code>\"Alice\"</code> 和&nbsp;<code>\"alice\"</code>&nbsp;是不同的名字。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>messages = [\"Hello userTwooo\",\"Hi userThree\",\"Wonderful day Alice\",\"Nice day userThree\"], senders = [\"Alice\",\"userTwo\",\"userThree\",\"Alice\"]\n<b>输出：</b>\"Alice\"\n<b>解释：</b>Alice 总共发出了 2 + 3 = 5 个单词。\nuserTwo 发出了 2 个单词。\nuserThree 发出了 3 个单词。\n由于 Alice 发出单词数最多，所以我们返回 \"Alice\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>messages = [\"How is leetcode for everyone\",\"Leetcode is useful for practice\"], senders = [\"Bob\",\"Charlie\"]\n<b>输出：</b>\"Charlie\"\n<b>解释：</b>Bob 总共发出了 5 个单词。\nCharlie 总共发出了 5 个单词。\n由于最多单词数打平，返回字典序最大的名字，也就是 Charlie 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == messages.length == senders.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= messages[i].length &lt;= 100</code></li>\n\t<li><code>1 &lt;= senders[i].length &lt;= 10</code></li>\n\t<li><code>messages[i]</code>&nbsp;包含大写字母、小写字母和&nbsp;<code>' '</code>&nbsp;。</li>\n\t<li><code>messages[i]</code>&nbsp;中所有单词都由 <strong>单个空格</strong>&nbsp;隔开。</li>\n\t<li><code>messages[i]</code>&nbsp;不包含前导和后缀空格。</li>\n\t<li><code>senders[i]</code>&nbsp;只包含大写英文字母和小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2285道路的最大总重要性",
        "hardRate": "MEDIUM",
        "passRate": "57.55%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-total-importance-of-roads/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-total-importance-of-roads/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;，表示一个国家里的城市数目。城市编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。</p>\n\n<p>给你一个二维整数数组&nbsp;<code>roads</code>&nbsp;，其中&nbsp;<code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示城市&nbsp;<code>a<sub>i</sub></code>&nbsp;和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条&nbsp;<strong>双向</strong>&nbsp;道路。</p>\n\n<p>你需要给每个城市安排一个从 <code>1</code>&nbsp;到 <code>n</code>&nbsp;之间的整数值，且每个值只能被使用 <strong>一次</strong>&nbsp;。道路的 <strong>重要性</strong>&nbsp;定义为这条道路连接的两座城市数值 <strong>之和</strong>&nbsp;。</p>\n\n<p>请你返回在最优安排下，<strong>所有道路重要性</strong> 之和 <strong>最大</strong>&nbsp;为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/07/ex1drawio.png\" style=\"width: 290px; height: 215px;\"></p>\n\n<pre><b>输入：</b>n = 5, roads = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]\n<b>输出：</b>43\n<b>解释：</b>上图展示了国家图和每个城市被安排的值 [2,4,5,3,1] 。\n- 道路 (0,1) 重要性为 2 + 4 = 6 。\n- 道路 (1,2) 重要性为 4 + 5 = 9 。\n- 道路 (2,3) 重要性为 5 + 3 = 8 。\n- 道路 (0,2) 重要性为 2 + 5 = 7 。\n- 道路 (1,3) 重要性为 4 + 3 = 7 。\n- 道路 (2,4) 重要性为 5 + 1 = 6 。\n所有道路重要性之和为 6 + 9 + 8 + 7 + 7 + 6 = 43 。\n可以证明，重要性之和不可能超过 43 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/07/ex2drawio.png\" style=\"width: 281px; height: 151px;\"></p>\n\n<pre><b>输入：</b>n = 5, roads = [[0,3],[2,4],[1,3]]\n<b>输出：</b>20\n<b>解释：</b>上图展示了国家图和每个城市被安排的值 [4,3,2,5,1] 。\n- 道路 (0,3) 重要性为 4 + 5 = 9 。\n- 道路 (2,4) 重要性为 2 + 1 = 3 。\n- 道路 (1,3) 重要性为 3 + 5 = 8 。\n所有道路重要性之和为 9 + 3 + 8 = 20 。\n可以证明，重要性之和不可能超过 20 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= roads.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>roads[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>没有重复道路。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2286以组为单位订音乐会的门票",
        "hardRate": "HARD",
        "passRate": "23.40%",
        "problemsUrl": "https://leetcode.cn/problems/booking-concert-tickets-in-groups/",
        "solutionsUrl": "https://leetcode.cn/problems/booking-concert-tickets-in-groups/solution",
        "problemsDesc": "<p>一个音乐会总共有&nbsp;<code>n</code>&nbsp;排座位，编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，每一排有&nbsp;<code>m</code>&nbsp;个座椅，编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>m - 1</code>&nbsp;。你需要设计一个买票系统，针对以下情况进行座位安排：</p>\n\n<ul>\n\t<li>同一组的 <code>k</code>&nbsp;位观众坐在<strong> 同一排座位，且座位连续 </strong>。</li>\n\t<li><code>k</code>&nbsp;位观众中 <strong>每一位</strong>&nbsp;都有座位坐，但他们 <strong>不一定</strong>&nbsp;坐在一起。</li>\n</ul>\n\n<p>由于观众非常挑剔，所以：</p>\n\n<ul>\n\t<li>只有当一个组里所有成员座位的排数都 <strong>小于等于</strong>&nbsp;<code>maxRow</code>&nbsp;，这个组才能订座位。每一组的&nbsp;<code>maxRow</code>&nbsp;可能 <strong>不同</strong>&nbsp;。</li>\n\t<li>如果有多排座位可以选择，优先选择 <strong>最小</strong>&nbsp;的排数。如果同一排中有多个座位可以坐，优先选择号码 <strong>最小</strong>&nbsp;的。</li>\n</ul>\n\n<p>请你实现&nbsp;<code>BookMyShow</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>BookMyShow(int n, int m)</code>&nbsp;，初始化对象，<code>n</code>&nbsp;是排数，<code>m</code>&nbsp;是每一排的座位数。</li>\n\t<li><code>int[] gather(int k, int maxRow)</code>&nbsp;返回长度为 <code>2</code>&nbsp;的数组，表示 <code>k</code>&nbsp;个成员中 <strong>第一个座位</strong>&nbsp;的排数和座位编号，这 <code>k</code>&nbsp;位成员必须坐在 <strong>同一排座位，且座位连续 </strong>。换言之，返回最小可能的&nbsp;<code>r</code> 和&nbsp;<code>c</code>&nbsp;满足第&nbsp;<code>r</code>&nbsp;排中&nbsp;<code>[c, c + k - 1]</code>&nbsp;的座位都是空的，且&nbsp;<code>r &lt;= maxRow</code>&nbsp;。如果&nbsp;<strong>无法</strong>&nbsp;安排座位，返回&nbsp;<code>[]</code>&nbsp;。</li>\n\t<li><code>boolean scatter(int k, int maxRow)</code>&nbsp;如果组里所有&nbsp;<code>k</code>&nbsp;个成员&nbsp;<strong>不一定</strong>&nbsp;要坐在一起的前提下，都能在第&nbsp;<code>0</code> 排到第&nbsp;<code>maxRow</code>&nbsp;排之间找到座位，那么请返回&nbsp;<code>true</code>&nbsp;。这种情况下，每个成员都优先找排数&nbsp;<strong>最小</strong>&nbsp;，然后是座位编号最小的座位。如果不能安排所有&nbsp;<code>k</code>&nbsp;个成员的座位，请返回&nbsp;<code>false</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"BookMyShow\", \"gather\", \"gather\", \"scatter\", \"scatter\"]\n[[2, 5], [4, 0], [2, 0], [5, 1], [5, 1]]\n<strong>输出：</strong>\n[null, [0, 0], [], true, false]\n\n<strong>解释：</strong>\nBookMyShow bms = new BookMyShow(2, 5); // 总共有 2 排，每排 5 个座位。\nbms.gather(4, 0); // 返回 [0, 0]\n                  // 这一组安排第 0 排 [0, 3] 的座位。\nbms.gather(2, 0); // 返回 []\n                  // 第 0 排只剩下 1 个座位。\n                  // 所以无法安排 2 个连续座位。\nbms.scatter(5, 1); // 返回 True\n                   // 这一组安排第 0 排第 4 个座位和第 1 排 [0, 3] 的座位。\nbms.scatter(5, 1); // 返回 False\n                   // 总共只剩下 2 个座位。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= m, k &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= maxRow &lt;= n - 1</code></li>\n\t<li><code>gather</code> 和&nbsp;<code>scatter</code>&nbsp;<strong>总</strong> 调用次数不超过&nbsp;<code>5 * 10<sup>4</sup></code> 次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2287重排字符形成目标字符串",
        "hardRate": "EASY",
        "passRate": "65.14%",
        "problemsUrl": "https://leetcode.cn/problems/rearrange-characters-to-make-target-string/",
        "solutionsUrl": "https://leetcode.cn/problems/rearrange-characters-to-make-target-string/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong> 开始的字符串 <code>s</code> 和 <code>target</code> 。你可以从 <code>s</code> 取出一些字符并将其重排，得到若干新的字符串。</p>\n\n<p>从 <code>s</code> 中取出字符并重新排列，返回可以形成 <code>target</code> 的 <strong>最大</strong> 副本数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"ilovecodingonleetcode\", target = \"code\"\n<strong>输出：</strong>2\n<strong>解释：</strong>\n对于 \"code\" 的第 1 个副本，选取下标为 4 、5 、6 和 7 的字符。\n对于 \"code\" 的第 2 个副本，选取下标为 17 、18 、19 和 20 的字符。\n形成的字符串分别是 \"ecod\" 和 \"code\" ，都可以重排为 \"code\" 。\n可以形成最多 2 个 \"code\" 的副本，所以返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abcba\", target = \"abc\"\n<strong>输出：</strong>1\n<strong>解释：</strong>\n选取下标为 0 、1 和 2 的字符，可以形成 \"abc\" 的 1 个副本。 \n可以形成最多 1 个 \"abc\" 的副本，所以返回 1 。\n注意，尽管下标 3 和 4 分别有额外的 'a' 和 'b' ，但不能重用下标 2 处的 'c' ，所以无法形成 \"abc\" 的第 2 个副本。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abbaccaddaeea\", target = \"aaaaa\"\n<strong>输出：</strong>1\n<strong>解释：</strong>\n选取下标为 0 、3 、6 、9 和 12 的字符，可以形成 \"aaaaa\" 的 1 个副本。\n可以形成最多 1 个 \"aaaaa\" 的副本，所以返回 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= target.length &lt;= 10</code></li>\n\t<li><code>s</code> 和 <code>target</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2288价格减免",
        "hardRate": "MEDIUM",
        "passRate": "31.47%",
        "problemsUrl": "https://leetcode.cn/problems/apply-discount-to-prices/",
        "solutionsUrl": "https://leetcode.cn/problems/apply-discount-to-prices/solution",
        "problemsDesc": "<p><strong>句子</strong> 是由若干个单词组成的字符串，单词之间用单个空格分隔，其中每个单词可以包含数字、小写字母、和美元符号 <code>'$'</code> 。如果单词的形式为美元符号后跟着一个非负实数，那么这个单词就表示一个 <strong>价格</strong> 。</p>\n\n<ul>\n\t<li>例如 <code>\"$100\"</code>、<code>\"$23\"</code> 和 <code>\"$6\"</code> 表示价格，而 <code>\"100\"</code>、<code>\"$\"</code> 和 <code>\"$1e5</code> 不是。</li>\n</ul>\n\n<p>给你一个字符串 <code>sentence</code> 表示一个句子和一个整数 <code>discount</code> 。对于每个表示价格的单词，都在价格的基础上减免 <code>discount%</code> ，并 <strong>更新</strong> 该单词到句子中。所有更新后的价格应该表示为一个 <strong>恰好保留小数点后两位</strong> 的数字。</p>\n\n<p>返回表示修改后句子的字符串。</p>\n\n<p>注意：所有价格 <strong>最多</strong> 为&nbsp; <code>10</code> 位数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"there are $1 $2 and 5$ candies in the shop\", discount = 50\n<strong>输出：</strong>\"there are $0.50 $1.00 and 5$ candies in the shop\"\n<strong>解释：</strong>\n表示价格的单词是 \"$1\" 和 \"$2\" 。 \n- \"$1\" 减免 50% 为 \"$0.50\" ，所以 \"$1\" 替换为 \"$0.50\" 。\n- \"$2\" 减免 50% 为 \"$1\" ，所以 \"$1\" 替换为 \"$1.00\" 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"1 2 $3 4 $5 $6 7 8$ $9 $10$\", discount = 100\n<strong>输出：</strong>\"1 2 $0.00 4 $0.00 $0.00 7 8$ $0.00 $10$\"\n<strong>解释：</strong>\n任何价格减免 100% 都会得到 0 。\n表示价格的单词分别是 \"$3\"、\"$5\"、\"$6\" 和 \"$9\"。\n每个单词都替换为 \"$0.00\"。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentence.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>sentence</code> 由小写英文字母、数字、<code>' '</code> 和&nbsp;<code>'$'</code> 组成</li>\n\t<li><code>sentence</code> 不含前导和尾随空格</li>\n\t<li><code>sentence</code> 的所有单词都用单个空格分隔</li>\n\t<li>所有价格都是 <strong>正</strong> 整数且不含前导零</li>\n\t<li>所有价格 <strong>最多</strong> 为&nbsp; <code>10</code> 位数字</li>\n\t<li><code>0 &lt;= discount &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2289使数组按非递减顺序排列",
        "hardRate": "MEDIUM",
        "passRate": "21.90%",
        "problemsUrl": "https://leetcode.cn/problems/steps-to-make-array-non-decreasing/",
        "solutionsUrl": "https://leetcode.cn/problems/steps-to-make-array-non-decreasing/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。在一步操作中，移除所有满足&nbsp;<code>nums[i - 1] &gt; nums[i]</code> 的 <code>nums[i]</code> ，其中 <code>0 &lt; i &lt; nums.length</code> 。</p>\n\n<p>重复执行步骤，直到 <code>nums</code> 变为 <strong>非递减</strong> 数组，返回所需执行的操作数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,3,4,4,7,3,6,11,8,5,11]\n<strong>输出：</strong>3\n<strong>解释：</strong>执行下述几个步骤：\n- 步骤 1 ：[5,<em><strong>3</strong></em>,4,4,7,<em><strong>3</strong></em>,6,11,<em><strong>8</strong></em>,<em><strong>5</strong></em>,11] 变为 [5,4,4,7,6,11,11]\n- 步骤 2 ：[5,<em><strong>4</strong></em>,4,7,<em><strong>6</strong></em>,11,11] 变为 [5,4,7,11,11]\n- 步骤 3 ：[5,<em><strong>4</strong></em>,7,11,11] 变为 [5,7,11,11]\n[5,7,11,11] 是一个非递减数组，因此，返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,5,7,7,13]\n<strong>输出：</strong>0\n<strong>解释：</strong>nums 已经是一个非递减数组，因此，返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2290到达角落需要移除障碍物的最小数目",
        "hardRate": "HARD",
        "passRate": "56.17%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>grid</code> ，数组大小为 <code>m x n</code> 。每个单元格都是两个值之一：</p>\n\n<ul>\n\t<li><code>0</code> 表示一个 <strong>空</strong> 单元格，</li>\n\t<li><code>1</code> 表示一个可以移除的 <strong>障碍物</strong> 。</li>\n</ul>\n\n<p>你可以向上、下、左、右移动，从一个空单元格移动到另一个空单元格。</p>\n\n<p>现在你需要从左上角&nbsp;<code>(0, 0)</code> 移动到右下角 <code>(m - 1, n - 1)</code> ，返回需要移除的障碍物的 <strong>最小</strong> 数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/06/example1drawio-1.png\" style=\"width: 605px; height: 246px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,1,1],[1,1,0],[1,1,0]]\n<strong>输出：</strong>2\n<strong>解释：</strong>可以移除位于 (0, 1) 和 (0, 2) 的障碍物来创建从 (0, 0) 到 (2, 2) 的路径。\n可以证明我们至少需要移除两个障碍物，所以返回 2 。\n注意，可能存在其他方式来移除 2 个障碍物，创建出可行的路径。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/06/example1drawio.png\" style=\"width: 405px; height: 246px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\n<strong>输出：</strong>0\n<strong>解释：</strong>不移除任何障碍物就能从 (0, 0) 到 (2, 4) ，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> <strong>或</strong> <code>1</code></li>\n\t<li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2291最大股票收益",
        "hardRate": "MEDIUM",
        "passRate": "58.69%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-profit-from-trading-stocks/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-profit-from-trading-stocks/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2292连续两年有 3 个及以上订单的产品",
        "hardRate": "MEDIUM",
        "passRate": "44.02%",
        "problemsUrl": "https://leetcode.cn/problems/products-with-three-or-more-orders-in-two-consecutive-years/",
        "solutionsUrl": "https://leetcode.cn/problems/products-with-three-or-more-orders-in-two-consecutive-years/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2293极大极小游戏",
        "hardRate": "EASY",
        "passRate": "73.04%",
        "problemsUrl": "https://leetcode.cn/problems/min-max-game/",
        "solutionsUrl": "https://leetcode.cn/problems/min-max-game/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，其长度是 <code>2</code> 的幂。</p>\n\n<p>对 <code>nums</code> 执行下述算法：</p>\n\n<ol>\n\t<li>设 <code>n</code> 等于 <code>nums</code> 的长度，如果 <code>n == 1</code> ，<strong>终止</strong> 算法过程。否则，<strong>创建</strong> 一个新的整数数组&nbsp;<code>newNums</code> ，新数组长度为 <code>n / 2</code> ，下标从 <strong>0</strong> 开始。</li>\n\t<li>对于满足&nbsp;<code>0 &lt;= i &lt; n / 2</code> 的每个 <strong>偶数</strong> 下标 <code>i</code> ，将 <code>newNums[i]</code> <strong>赋值</strong> 为 <code>min(nums[2 * i], nums[2 * i + 1])</code> 。</li>\n\t<li>对于满足&nbsp;<code>0 &lt;= i &lt; n / 2</code> 的每个 <strong>奇数</strong> 下标 <code>i</code> ，将 <code>newNums[i]</code> <strong>赋值</strong> 为 <code>max(nums[2 * i], nums[2 * i + 1])</code> 。</li>\n\t<li>用 <code>newNums</code> 替换 <code>nums</code> 。</li>\n\t<li>从步骤 1 开始 <strong>重复</strong> 整个过程。</li>\n</ol>\n\n<p>执行算法后，返回 <code>nums</code> 中剩下的那个数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/13/example1drawio-1.png\" style=\"width: 500px; height: 240px;\" /></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,5,2,4,8,2,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>重复执行算法会得到下述数组。\n第一轮：nums = [1,5,4,2]\n第二轮：nums = [1,4]\n第三轮：nums = [1]\n1 是最后剩下的那个数字，返回 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3]\n<strong>输出：</strong>3\n<strong>解释：</strong>3 就是最后剩下的数字，返回 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1024</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums.length</code> 是 <code>2</code> 的幂</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2294划分数组使最大差为 K",
        "hardRate": "MEDIUM",
        "passRate": "68.01%",
        "problemsUrl": "https://leetcode.cn/problems/partition-array-such-that-maximum-difference-is-k/",
        "solutionsUrl": "https://leetcode.cn/problems/partition-array-such-that-maximum-difference-is-k/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。你可以将 <code>nums</code> 划分成一个或多个 <strong>子序列</strong> ，使 <code>nums</code> 中的每个元素都 <strong>恰好</strong> 出现在一个子序列中。</p>\n\n<p>在满足每个子序列中最大值和最小值之间的差值最多为 <code>k</code> 的前提下，返回需要划分的 <strong>最少</strong> 子序列数目。</p>\n\n<p><strong>子序列</strong> 本质是一个序列，可以通过删除另一个序列中的某些元素（或者不删除）但不改变剩下元素的顺序得到。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,6,1,2,5], k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>\n可以将 nums 划分为两个子序列 [3,1,2] 和 [6,5] 。\n第一个子序列中最大值和最小值的差值是 3 - 1 = 2 。\n第二个子序列中最大值和最小值的差值是 6 - 5 = 1 。\n由于创建了两个子序列，返回 2 。可以证明需要划分的最少子序列数目就是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3], k = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>\n可以将 nums 划分为两个子序列 [1,2] 和 [3] 。\n第一个子序列中最大值和最小值的差值是 2 - 1 = 1 。\n第二个子序列中最大值和最小值的差值是 3 - 3 = 0 。\n由于创建了两个子序列，返回 2 。注意，另一种最优解法是将 nums 划分成子序列 [1] 和 [2,3] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,4,5], k = 0\n<strong>输出：</strong>3\n<strong>解释：</strong>\n可以将 nums 划分为三个子序列 [2,2]、[4] 和 [5] 。\n第一个子序列中最大值和最小值的差值是 2 - 2 = 0 。\n第二个子序列中最大值和最小值的差值是 4 - 4 = 0 。\n第三个子序列中最大值和最小值的差值是 5 - 5 = 0 。\n由于创建了三个子序列，返回 3 。可以证明需要划分的最少子序列数目就是 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2295替换数组中的元素",
        "hardRate": "MEDIUM",
        "passRate": "57.75%",
        "problemsUrl": "https://leetcode.cn/problems/replace-elements-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/replace-elements-in-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>nums</code>&nbsp;，它包含 <code>n</code>&nbsp;个 <strong>互不相同</strong>&nbsp;的正整数。请你对这个数组执行 <code>m</code>&nbsp;个操作，在第 <code>i</code>&nbsp;个操作中，你需要将数字&nbsp;<code>operations[i][0]</code> 替换成&nbsp;<code>operations[i][1]</code>&nbsp;。</p>\n\n<p>题目保证在第 <code>i</code>&nbsp;个操作中：</p>\n\n<ul>\n\t<li><code>operations[i][0]</code>&nbsp;在&nbsp;<code>nums</code>&nbsp;中存在。</li>\n\t<li><code>operations[i][1]</code>&nbsp;在&nbsp;<code>nums</code>&nbsp;中不存在。</li>\n</ul>\n\n<p>请你返回执行完所有操作后的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,4,6], operations = [[1,3],[4,7],[6,1]]\n<b>输出：</b>[3,2,7,1]\n<b>解释：</b>我们对 nums 执行以下操作：\n- 将数字 1 替换为 3 。nums 变为 [<em><strong>3</strong></em>,2,4,6] 。\n- 将数字 4 替换为 7 。nums 变为 [3,2,<em><strong>7</strong></em>,6] 。\n- 将数字 6 替换为 1 。nums 变为 [3,2,7,<em><strong>1</strong></em>] 。\n返回最终数组 [3,2,7,1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2], operations = [[1,3],[2,1],[3,2]]\n<b>输出：</b>[2,1]\n<b>解释：</b>我们对 nums 执行以下操作：\n- 将数字 1 替换为 3 。nums 变为 [<em><strong>3</strong></em>,2] 。\n- 将数字 2 替换为 1 。nums 变为 [3,<em><strong>1</strong></em>] 。\n- 将数字 3 替换为 2 。nums 变为 [<em><strong>2</strong></em>,1] 。\n返回最终数组 [2,1] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>m == operations.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums</code>&nbsp;中所有数字 <strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>operations[i].length == 2</code></li>\n\t<li><code>1 &lt;= nums[i], operations[i][0], operations[i][1] &lt;= 10<sup>6</sup></code></li>\n\t<li>在执行第&nbsp;<code>i</code> 个操作时，<code>operations[i][0]</code>&nbsp;在&nbsp;<code>nums</code>&nbsp;中存在。</li>\n\t<li>在执行第&nbsp;<code>i</code>&nbsp;个操作时，<code>operations[i][1]</code>&nbsp;在&nbsp;<code>nums</code>&nbsp;中不存在。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2296设计一个文本编辑器",
        "hardRate": "HARD",
        "passRate": "43.78%",
        "problemsUrl": "https://leetcode.cn/problems/design-a-text-editor/",
        "solutionsUrl": "https://leetcode.cn/problems/design-a-text-editor/solution",
        "problemsDesc": "<p>请你设计一个带光标的文本编辑器，它可以实现以下功能：</p>\n\n<ul>\n\t<li><strong>添加：</strong>在光标所在处添加文本。</li>\n\t<li><strong>删除：</strong>在光标所在处删除文本（模拟键盘的删除键）。</li>\n\t<li><strong>移动：</strong>将光标往左或者往右移动。</li>\n</ul>\n\n<p>当删除文本时，只有光标左边的字符会被删除。光标会留在文本内，也就是说任意时候&nbsp;<code>0 &lt;= cursor.position &lt;= currentText.length</code>&nbsp;都成立。</p>\n\n<p>请你实现&nbsp;<code>TextEditor</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>TextEditor()</code>&nbsp;用空文本初始化对象。</li>\n\t<li><code>void addText(string text)</code>&nbsp;将&nbsp;<code>text</code>&nbsp;添加到光标所在位置。添加完后光标在&nbsp;<code>text</code>&nbsp;的右边。</li>\n\t<li><code>int deleteText(int k)</code>&nbsp;删除光标左边&nbsp;<code>k</code>&nbsp;个字符。返回实际删除的字符数目。</li>\n\t<li><code>string cursorLeft(int k)</code> 将光标向左移动&nbsp;<code>k</code>&nbsp;次。返回移动后光标左边&nbsp;<code>min(10, len)</code>&nbsp;个字符，其中&nbsp;<code>len</code>&nbsp;是光标左边的字符数目。</li>\n\t<li><code>string cursorRight(int k)</code>&nbsp;将光标向右移动&nbsp;<code>k</code>&nbsp;次。返回移动后光标左边&nbsp;<code>min(10, len)</code>&nbsp;个字符，其中&nbsp;<code>len</code>&nbsp;是光标左边的字符数目。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"TextEditor\", \"addText\", \"deleteText\", \"addText\", \"cursorRight\", \"cursorLeft\", \"deleteText\", \"cursorLeft\", \"cursorRight\"]\n[[], [\"leetcode\"], [4], [\"practice\"], [3], [8], [10], [2], [6]]\n<strong>输出：</strong>\n[null, null, 4, null, \"etpractice\", \"leet\", 4, \"\", \"practi\"]\n\n<strong>解释：</strong>\nTextEditor textEditor = new TextEditor(); // 当前 text 为 \"|\" 。（'|' 字符表示光标）\ntextEditor.addText(\"leetcode\"); // 当前文本为 \"leetcode|\" 。\ntextEditor.deleteText(4); // 返回 4\n                          // 当前文本为 \"leet|\" 。\n                          // 删除了 4 个字符。\ntextEditor.addText(\"practice\"); // 当前文本为 \"leetpractice|\" 。\ntextEditor.cursorRight(3); // 返回 \"etpractice\"\n                           // 当前文本为 \"leetpractice|\". \n                           // 光标无法移动到文本以外，所以无法移动。\n                           // \"etpractice\" 是光标左边的 10 个字符。\ntextEditor.cursorLeft(8); // 返回 \"leet\"\n                          // 当前文本为 \"leet|practice\" 。\n                          // \"leet\" 是光标左边的 min(10, 4) = 4 个字符。\ntextEditor.deleteText(10); // 返回 4\n                           // 当前文本为 \"|practice\" 。\n                           // 只有 4 个字符被删除了。\ntextEditor.cursorLeft(2); // 返回 \"\"\n                          // 当前文本为 \"|practice\" 。\n                          // 光标无法移动到文本以外，所以无法移动。\n                          // \"\" 是光标左边的 min(10, 0) = 0 个字符。\ntextEditor.cursorRight(6); // 返回 \"practi\"\n                           // 当前文本为 \"practi|ce\" 。\n                           // \"practi\" 是光标左边的 min(10, 6) = 6 个字符。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length, k &lt;= 40</code></li>\n\t<li><code>text</code>&nbsp;只含有小写英文字母。</li>\n\t<li>调用 <code>addText</code>&nbsp;，<code>deleteText</code>&nbsp;，<code>cursorLeft</code> 和&nbsp;<code>cursorRight</code>&nbsp;的 <strong>总</strong> 次数不超过&nbsp;<code>2 * 10<sup>4</sup></code>&nbsp;次。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能设计并实现一个每次调用时间复杂度为 <code>O(k)</code> 的解决方案吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2297跳跃游戏 VIII",
        "hardRate": "MEDIUM",
        "passRate": "57.07%",
        "problemsUrl": "https://leetcode.cn/problems/jump-game-viii/",
        "solutionsUrl": "https://leetcode.cn/problems/jump-game-viii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2298周末任务计数",
        "hardRate": "MEDIUM",
        "passRate": "78.84%",
        "problemsUrl": "https://leetcode.cn/problems/tasks-count-in-the-weekend/",
        "solutionsUrl": "https://leetcode.cn/problems/tasks-count-in-the-weekend/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2299强密码检验器 II",
        "hardRate": "EASY",
        "passRate": "65.61%",
        "problemsUrl": "https://leetcode.cn/problems/strong-password-checker-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/strong-password-checker-ii/solution",
        "problemsDesc": "<p>如果一个密码满足以下所有条件，我们称它是一个 <strong>强</strong>&nbsp;密码：</p>\n\n<ul>\n\t<li>它有至少 <code>8</code>&nbsp;个字符。</li>\n\t<li>至少包含 <strong>一个小写英文</strong>&nbsp;字母。</li>\n\t<li>至少包含 <strong>一个大写英文</strong>&nbsp;字母。</li>\n\t<li>至少包含 <strong>一个数字</strong>&nbsp;。</li>\n\t<li>至少包含 <strong>一个特殊字符</strong>&nbsp;。特殊字符为：<code>\"!@#$%^&amp;*()-+\"</code>&nbsp;中的一个。</li>\n\t<li>它 <strong>不</strong>&nbsp;包含&nbsp;<code>2</code>&nbsp;个连续相同的字符（比方说&nbsp;<code>\"aab\"</code>&nbsp;不符合该条件，但是&nbsp;<code>\"aba\"</code>&nbsp;符合该条件）。</li>\n</ul>\n\n<p>给你一个字符串&nbsp;<code>password</code>&nbsp;，如果它是一个&nbsp;<strong>强</strong>&nbsp;密码，返回&nbsp;<code>true</code>，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>password = \"IloveLe3tcode!\"\n<b>输出：</b>true\n<b>解释：</b>密码满足所有的要求，所以我们返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>password = \"Me+You--IsMyDream\"\n<b>输出：</b>false\n<b>解释：</b>密码不包含数字，且包含 2 个连续相同的字符。所以我们返回 false 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>password = \"1aB!\"\n<b>输出：</b>false\n<b>解释：</b>密码不符合长度要求。所以我们返回 false 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= password.length &lt;= 100</code></li>\n\t<li><code>password</code>&nbsp;包含字母，数字和&nbsp;<code>\"!@#$%^&amp;*()-+\"</code>&nbsp;这些特殊字符。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2300咒语和药水的成功对数",
        "hardRate": "MEDIUM",
        "passRate": "39.35%",
        "problemsUrl": "https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/",
        "solutionsUrl": "https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/solution",
        "problemsDesc": "<p>给你两个正整数数组&nbsp;<code>spells</code> 和&nbsp;<code>potions</code>&nbsp;，长度分别为&nbsp;<code>n</code> 和&nbsp;<code>m</code>&nbsp;，其中&nbsp;<code>spells[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个咒语的能量强度，<code>potions[j]</code>&nbsp;表示第&nbsp;<code>j</code>&nbsp;瓶药水的能量强度。</p>\n\n<p>同时给你一个整数&nbsp;<code>success</code>&nbsp;。一个咒语和药水的能量强度 <strong>相乘</strong> 如果&nbsp;<strong>大于等于</strong>&nbsp;<code>success</code>&nbsp;，那么它们视为一对&nbsp;<strong>成功</strong>&nbsp;的组合。</p>\n\n<p>请你返回一个长度为 <code>n</code>&nbsp;的整数数组<em>&nbsp;</em><code>pairs</code>，其中<em>&nbsp;</em><code>pairs[i]</code>&nbsp;是能跟第 <code>i</code>&nbsp;个咒语成功组合的 <b>药水</b>&nbsp;数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>spells = [5,1,3], potions = [1,2,3,4,5], success = 7\n<b>输出：</b>[4,0,3]\n<strong>解释：</strong>\n- 第 0 个咒语：5 * [1,2,3,4,5] = [5,<em><strong>10</strong></em>,<em><strong>15</strong></em>,<em><strong>20</strong></em>,<em><strong>25</strong></em>] 。总共 4 个成功组合。\n- 第 1 个咒语：1 * [1,2,3,4,5] = [1,2,3,4,5] 。总共 0 个成功组合。\n- 第 2 个咒语：3 * [1,2,3,4,5] = [3,6,<em><strong>9</strong></em>,<em><strong>12</strong></em>,<em><strong>15</strong></em>] 。总共 3 个成功组合。\n所以返回 [4,0,3] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>spells = [3,1,2], potions = [8,5,8], success = 16\n<b>输出：</b>[2,0,2]\n<strong>解释：</strong>\n- 第 0 个咒语：3 * [8,5,8] = [<em><strong>24</strong></em>,15,<em><strong>24</strong></em>] 。总共 2 个成功组合。\n- 第 1 个咒语：1 * [8,5,8] = [8,5,8] 。总共 0 个成功组合。\n- 第 2 个咒语：2 * [8,5,8] = [<em><strong>16</strong></em>,10,<em><strong>16</strong></em>] 。总共 2 个成功组合。\n所以返回 [2,0,2] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == spells.length</code></li>\n\t<li><code>m == potions.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= spells[i], potions[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= success &lt;= 10<sup>10</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2301替换字符后匹配",
        "hardRate": "HARD",
        "passRate": "45.41%",
        "problemsUrl": "https://leetcode.cn/problems/match-substring-after-replacement/",
        "solutionsUrl": "https://leetcode.cn/problems/match-substring-after-replacement/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>s</code> 和&nbsp;<code>sub</code>&nbsp;。同时给你一个二维字符数组&nbsp;<code>mappings</code> ，其中&nbsp;<code>mappings[i] = [old<sub>i</sub>, new<sub>i</sub>]</code>&nbsp;表示你可以将&nbsp;<code>sub</code>&nbsp;中任意数目的&nbsp;<code>old<sub>i</sub></code>&nbsp;字符替换为&nbsp;<code>new<sub>i</sub></code>&nbsp;。<code>sub</code>&nbsp;中每个字符 <b>不能</b>&nbsp;被替换超过一次。</p>\n\n<p>如果使用 <code>mappings</code>&nbsp;替换 0 个或者若干个字符，可以将 <code>sub</code>&nbsp;变成 <code>s</code>&nbsp;的一个子字符串，请你返回&nbsp;<code>true</code>，否则返回&nbsp;<code>false</code>&nbsp;。</p>\n\n<p>一个 <strong>子字符串</strong>&nbsp;是字符串中连续非空的字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"fool3e7bar\", sub = \"leet\", mappings = [[\"e\",\"3\"],[\"t\",\"7\"],[\"t\",\"8\"]]\n<b>输出：</b>true\n<b>解释：</b>将 sub 中第一个 'e' 用 '3' 替换，将 't' 用 '7' 替换。\n现在 sub = \"l3e7\" ，它是 s 的子字符串，所以我们返回 true 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"fooleetbar\", sub = \"f00l\", mappings = [[\"o\",\"0\"]]\n<b>输出：</b>false\n<b>解释：</b>字符串 \"f00l\" 不是 s 的子串且没有可以进行的修改。\n注意我们不能用 'o' 替换 '0' 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"Fool33tbaR\", sub = \"leetd\", mappings = [[\"e\",\"3\"],[\"t\",\"7\"],[\"t\",\"8\"],[\"d\",\"b\"],[\"p\",\"b\"]]\n<b>输出：</b>true\n<b>解释：</b>将 sub 里第一个和第二个 'e' 用 '3' 替换，用 'b' 替换 sub 里的 'd' 。\n得到 sub = \"l33tb\" ，它是 s 的子字符串，所以我们返回 true 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sub.length &lt;= s.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= mappings.length &lt;= 1000</code></li>\n\t<li><code>mappings[i].length == 2</code></li>\n\t<li><code>old<sub>i</sub> != new<sub>i</sub></code></li>\n\t<li><code>s</code> 和&nbsp;<code>sub</code>&nbsp;只包含大写和小写英文字母和数字。</li>\n\t<li><code>old<sub>i</sub></code> 和&nbsp;<code>new<sub>i</sub></code>&nbsp;是大写、小写字母或者是个数字。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2302统计得分小于 K 的子数组数目",
        "hardRate": "HARD",
        "passRate": "50.94%",
        "problemsUrl": "https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/",
        "solutionsUrl": "https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/solution",
        "problemsDesc": "<p>一个数组的 <strong>分数</strong>&nbsp;定义为数组之和 <strong>乘以</strong>&nbsp;数组的长度。</p>\n\n<ul>\n\t<li>比方说，<code>[1, 2, 3, 4, 5]</code>&nbsp;的分数为&nbsp;<code>(1 + 2 + 3 + 4 + 5) * 5 = 75</code>&nbsp;。</li>\n</ul>\n\n<p>给你一个正整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;，请你返回&nbsp;<code>nums</code>&nbsp;中分数&nbsp;<strong>严格小于&nbsp;</strong><code>k</code>&nbsp;的&nbsp;<strong>非空整数子数组数目</strong>。</p>\n\n<p><strong>子数组</strong> 是数组中的一个连续元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,1,4,3,5], k = 10\n<b>输出：</b>6\n<strong>解释：</strong>\n有 6 个子数组的分数小于 10 ：\n- [2] 分数为 2 * 1 = 2 。\n- [1] 分数为 1 * 1 = 1 。\n- [4] 分数为 4 * 1 = 4 。\n- [3] 分数为 3 * 1 = 3 。 \n- [5] 分数为 5 * 1 = 5 。\n- [2,1] 分数为 (2 + 1) * 2 = 6 。\n注意，子数组 [1,4] 和 [4,3,5] 不符合要求，因为它们的分数分别为 10 和 36，但我们要求子数组的分数严格小于 10 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,1,1], k = 5\n<b>输出：</b>5\n<strong>解释：</strong>\n除了 [1,1,1] 以外每个子数组分数都小于 5 。\n[1,1,1] 分数为 (1 + 1 + 1) * 3 = 9 ，大于 5 。\n所以总共有 5 个子数组得分小于 5 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>15</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2303计算应缴税款总额",
        "hardRate": "EASY",
        "passRate": "70.42%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-amount-paid-in-taxes/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-amount-paid-in-taxes/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>brackets</code> ，其中 <code>brackets[i] = [upper<sub>i</sub>, percent<sub>i</sub>]</code> ，表示第 <code>i</code> 个税级的上限是 <code>upper<sub>i</sub></code> ，征收的税率为 <code>percent<sub>i</sub></code> 。税级按上限 <strong>从低到高排序</strong>（在满足 <code>0 &lt; i &lt; brackets.length</code> 的前提下，<code>upper<sub>i-1</sub> &lt; upper<sub>i</sub></code>）。</p>\n\n<p>税款计算方式如下：</p>\n\n<ul>\n\t<li>不超过 <code>upper<sub>0</sub></code> 的收入按税率 <code>percent<sub>0</sub></code> 缴纳</li>\n\t<li>接着 <code>upper<sub>1</sub> - upper<sub>0</sub></code> 的部分按税率 <code>percent<sub>1</sub></code> 缴纳</li>\n\t<li>然后 <code>upper<sub>2</sub> - upper<sub>1</sub></code> 的部分按税率 <code>percent<sub>2</sub></code> 缴纳</li>\n\t<li>以此类推</li>\n</ul>\n\n<p>给你一个整数 <code>income</code> 表示你的总收入。返回你需要缴纳的税款总额。与标准答案误差不超 <code>10<sup>-5</sup></code> 的结果将被视作正确答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>brackets = [[3,50],[7,10],[12,25]], income = 10\n<strong>输出：</strong>2.65000\n<strong>解释：</strong>\n前 $3 的税率为 50% 。需要支付税款 $3 * 50% = $1.50 。\n接下来 $7 - $3 = $4 的税率为 10% 。需要支付税款 $4 * 10% = $0.40 。\n最后 $10 - $7 = $3 的税率为 25% 。需要支付税款 $3 * 25% = $0.75 。\n需要支付的税款总计 $1.50 + $0.40 + $0.75 = $2.65 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>brackets = [[1,0],[4,25],[5,50]], income = 2\n<strong>输出：</strong>0.25000\n<strong>解释：</strong>\n前 $1 的税率为 0% 。需要支付税款 $1 * 0% = $0 。\n剩下 $1 的税率为 25% 。需要支付税款 $1 * 25% = $0.25 。\n需要支付的税款总计 $0 + $0.25 = $0.25 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>brackets = [[2,50]], income = 0\n<strong>输出：</strong>0.00000\n<strong>解释：</strong>\n没有收入，无需纳税，需要支付的税款总计 $0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= brackets.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= upper<sub>i</sub> &lt;= 1000</code></li>\n\t<li><code>0 &lt;= percent<sub>i</sub> &lt;= 100</code></li>\n\t<li><code>0 &lt;= income &lt;= 1000</code></li>\n\t<li><code>upper<sub>i</sub></code> 按递增顺序排列</li>\n\t<li><code>upper<sub>i</sub></code> 中的所有值 <strong>互不相同</strong></li>\n\t<li>最后一个税级的上限大于等于 <code>income</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2304网格中的最小路径代价",
        "hardRate": "MEDIUM",
        "passRate": "64.27%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-path-cost-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-path-cost-in-a-grid/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数矩阵&nbsp;<code>grid</code> ，矩阵大小为 <code>m x n</code> ，由从 <code>0</code> 到 <code>m * n - 1</code> 的不同整数组成。你可以在此矩阵中，从一个单元格移动到 <strong>下一行</strong> 的任何其他单元格。如果你位于单元格 <code>(x, y)</code> ，且满足 <code>x &lt; m - 1</code> ，你可以移动到 <code>(x + 1, 0)</code>, <code>(x + 1, 1)</code>, ..., <code>(x + 1, n - 1)</code><strong> </strong>中的任何一个单元格。<strong>注意：</strong>&nbsp;在最后一行中的单元格不能触发移动。</p>\n\n<p>每次可能的移动都需要付出对应的代价，代价用一个下标从 <strong>0</strong> 开始的二维数组 <code>moveCost</code> 表示，该数组大小为 <code>(m * n) x n</code> ，其中 <code>moveCost[i][j]</code> 是从值为 <code>i</code> 的单元格移动到下一行第 <code>j</code> 列单元格的代价。从&nbsp;<code>grid</code> 最后一行的单元格移动的代价可以忽略。</p>\n\n<p><code>grid</code> 一条路径的代价是：所有路径经过的单元格的 <strong>值之和</strong> 加上 所有移动的 <strong>代价之和 </strong>。从 <strong>第一行</strong> 任意单元格出发，返回到达 <strong>最后一行</strong> 任意单元格的最小路径代价<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/28/griddrawio-2.png\" style=\"width: 301px; height: 281px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\n<strong>输出：</strong>17\n<strong>解释：</strong>最小代价的路径是 5 -&gt; 0 -&gt; 1 。\n- 路径途经单元格值之和 5 + 0 + 1 = 6 。\n- 从 5 移动到 0 的代价为 3 。\n- 从 0 移动到 1 的代价为 8 。\n路径总代价为 6 + 3 + 8 = 17 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n最小代价的路径是 2 -&gt; 3 。 \n- 路径途经单元格值之和 2 + 3 = 5 。 \n- 从 2 移动到 3 的代价为 1 。 \n路径总代价为 5 + 1 = 6 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>grid</code> 由从 <code>0</code> 到 <code>m * n - 1</code> 的不同整数组成</li>\n\t<li><code>moveCost.length == m * n</code></li>\n\t<li><code>moveCost[i].length == n</code></li>\n\t<li><code>1 &lt;= moveCost[i][j] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2305公平分发饼干",
        "hardRate": "MEDIUM",
        "passRate": "72.68%",
        "problemsUrl": "https://leetcode.cn/problems/fair-distribution-of-cookies/",
        "solutionsUrl": "https://leetcode.cn/problems/fair-distribution-of-cookies/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>cookies</code> ，其中 <code>cookies[i]</code> 表示在第 <code>i</code> 个零食包中的饼干数量。另给你一个整数 <code>k</code> 表示等待分发零食包的孩子数量，<strong>所有</strong> 零食包都需要分发。在同一个零食包中的所有饼干都必须分发给同一个孩子，不能分开。</p>\n\n<p>分发的 <strong>不公平程度</strong> 定义为单个孩子在分发过程中能够获得饼干的最大总数。</p>\n\n<p>返回所有分发的最小不公平程度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>cookies = [8,15,10,20,8], k = 2\n<strong>输出：</strong>31\n<strong>解释：</strong>一种最优方案是 [8,15,8] 和 [10,20] 。\n- 第 1 个孩子分到 [8,15,8] ，总计 8 + 15 + 8 = 31 块饼干。\n- 第 2 个孩子分到 [10,20] ，总计 10 + 20 = 30 块饼干。\n分发的不公平程度为 max(31,30) = 31 。\n可以证明不存在不公平程度小于 31 的分发方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>cookies = [6,1,3,2,2,4,1,2], k = 3\n<strong>输出：</strong>7\n<strong>解释：</strong>一种最优方案是 [6,1]、[3,2,2] 和 [4,1,2] 。\n- 第 1 个孩子分到 [6,1] ，总计 6 + 1 = 7 块饼干。 \n- 第 2 个孩子分到 [3,2,2] ，总计 3 + 2 + 2 = 7 块饼干。\n- 第 3 个孩子分到 [4,1,2] ，总计 4 + 1 + 2 = 7 块饼干。\n分发的不公平程度为 max(7,7,7) = 7 。\n可以证明不存在不公平程度小于 7 的分发方案。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= cookies.length &lt;= 8</code></li>\n\t<li><code>1 &lt;= cookies[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= k &lt;= cookies.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2306公司命名",
        "hardRate": "HARD",
        "passRate": "44.54%",
        "problemsUrl": "https://leetcode.cn/problems/naming-a-company/",
        "solutionsUrl": "https://leetcode.cn/problems/naming-a-company/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>ideas</code> 表示在公司命名过程中使用的名字列表。公司命名流程如下：</p>\n\n<ol>\n\t<li>从 <code>ideas</code> 中选择 2 个 <strong>不同</strong> 名字，称为 <code>idea<sub>A</sub></code> 和 <code>idea<sub>B</sub></code> 。</li>\n\t<li>交换 <code>idea<sub>A</sub></code> 和 <code>idea<sub>B</sub></code> 的首字母。</li>\n\t<li>如果得到的两个新名字 <strong>都</strong> 不在 <code>ideas</code> 中，那么 <code>idea<sub>A</sub> idea<sub>B</sub></code>（<strong>串联</strong> <code>idea<sub>A</sub></code> 和 <code>idea<sub>B</sub></code> ，中间用一个空格分隔）是一个有效的公司名字。</li>\n\t<li>否则，不是一个有效的名字。</li>\n</ol>\n\n<p>返回 <strong>不同</strong> 且有效的公司名字的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]\n<strong>输出：</strong>6\n<strong>解释：</strong>下面列出一些有效的选择方案：\n- (\"coffee\", \"donuts\")：对应的公司名字是 \"doffee conuts\" 。\n- (\"donuts\", \"coffee\")：对应的公司名字是 \"conuts doffee\" 。\n- (\"donuts\", \"time\")：对应的公司名字是 \"tonuts dime\" 。\n- (\"donuts\", \"toffee\")：对应的公司名字是 \"tonuts doffee\" 。\n- (\"time\", \"donuts\")：对应的公司名字是 \"dime tonuts\" 。\n- (\"toffee\", \"donuts\")：对应的公司名字是 \"doffee tonuts\" 。\n因此，总共有 6 个不同的公司名字。\n\n下面列出一些无效的选择方案：\n- (\"coffee\", \"time\")：在原数组中存在交换后形成的名字 \"toffee\" 。\n- (\"time\", \"toffee\")：在原数组中存在交换后形成的两个名字。\n- (\"coffee\", \"toffee\")：在原数组中存在交换后形成的两个名字。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>ideas = [\"lack\",\"back\"]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在有效的选择方案。因此，返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= ideas.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= ideas[i].length &lt;= 10</code></li>\n\t<li><code>ideas[i]</code> 由小写英文字母组成</li>\n\t<li><code>ideas</code> 中的所有字符串 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2307检查方程中的矛盾之处",
        "hardRate": "HARD",
        "passRate": "43.97%",
        "problemsUrl": "https://leetcode.cn/problems/check-for-contradictions-in-equations/",
        "solutionsUrl": "https://leetcode.cn/problems/check-for-contradictions-in-equations/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2308按性别排列表格",
        "hardRate": "MEDIUM",
        "passRate": "77.50%",
        "problemsUrl": "https://leetcode.cn/problems/arrange-table-by-gender/",
        "solutionsUrl": "https://leetcode.cn/problems/arrange-table-by-gender/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2309兼具大小写的最好英文字母",
        "hardRate": "EASY",
        "passRate": "71.82%",
        "problemsUrl": "https://leetcode.cn/problems/greatest-english-letter-in-upper-and-lower-case/",
        "solutionsUrl": "https://leetcode.cn/problems/greatest-english-letter-in-upper-and-lower-case/solution",
        "problemsDesc": "<p>给你一个由英文字母组成的字符串 <code>s</code> ，请你找出并返回 <code>s</code> 中的 <strong>最好</strong> 英文字母。返回的字母必须为大写形式。如果不存在满足条件的字母，则返回一个空字符串。</p>\n\n<p><strong>最好</strong> 英文字母的大写和小写形式必须 <strong>都</strong> 在 <code>s</code> 中出现。</p>\n\n<p>英文字母 <code>b</code> 比另一个英文字母&nbsp;<code>a</code>&nbsp;<strong>更好</strong> 的前提是：英文字母表中，<code>b</code> 在 <code>a</code> 之 <strong>后</strong> 出现。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"l<em><strong>Ee</strong></em>TcOd<em><strong>E</strong></em>\"\n<strong>输出：</strong>\"E\"\n<strong>解释：</strong>\n字母 'E' 是唯一一个大写和小写形式都出现的字母。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a<em><strong>rR</strong></em>AzFif\"\n<strong>输出：</strong>\"R\"\n<strong>解释：</strong>\n字母 'R' 是大写和小写形式都出现的最好英文字母。\n注意 'A' 和 'F' 的大写和小写形式也都出现了，但是 'R' 比 'F' 和 'A' 更好。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"AbCdEfGhIjK\"\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>\n不存在大写和小写形式都出现的字母。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> 由小写和大写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2310个位数字为 K 的整数之和",
        "hardRate": "MEDIUM",
        "passRate": "27.60%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-numbers-with-units-digit-k/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-numbers-with-units-digit-k/solution",
        "problemsDesc": "<p>给你两个整数 <code>num</code> 和 <code>k</code> ，考虑具有以下属性的正整数多重集：</p>\n\n<ul>\n\t<li>每个整数个位数字都是 <code>k</code> 。</li>\n\t<li>所有整数之和是 <code>num</code> 。</li>\n</ul>\n\n<p>返回该多重集的最小大小，如果不存在这样的多重集，返回<em> </em><code>-1</code> 。</p>\n\n<p>注意：</p>\n\n<ul>\n\t<li>多重集与集合类似，但多重集可以包含多个同一整数，空多重集的和为 <code>0</code> 。</li>\n\t<li><strong>个位数字</strong> 是数字最右边的数位。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 58, k = 9\n<strong>输出：</strong>2\n<strong>解释：</strong>\n多重集 [9,49] 满足题目条件，和为 58 且每个整数的个位数字是 9 。\n另一个满足条件的多重集是 [19,39] 。\n可以证明 2 是满足题目条件的多重集的最小长度。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 37, k = 2\n<strong>输出：</strong>-1\n<strong>解释：</strong>个位数字为 2 的整数无法相加得到 37 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 0, k = 7\n<strong>输出：</strong>0\n<strong>解释：</strong>空多重集的和为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 3000</code></li>\n\t<li><code>0 &lt;= k &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2311小于等于 K 的最长二进制子序列",
        "hardRate": "MEDIUM",
        "passRate": "36.95%",
        "problemsUrl": "https://leetcode.cn/problems/longest-binary-subsequence-less-than-or-equal-to-k/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-binary-subsequence-less-than-or-equal-to-k/solution",
        "problemsDesc": "<p>给你一个二进制字符串&nbsp;<code>s</code>&nbsp;和一个正整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>请你返回 <code>s</code>&nbsp;的 <strong>最长</strong>&nbsp;子序列，且该子序列对应的 <strong>二进制</strong>&nbsp;数字小于等于 <code>k</code>&nbsp;。</p>\n\n<p>注意：</p>\n\n<ul>\n\t<li>子序列可以有 <strong>前导 0</strong>&nbsp;。</li>\n\t<li>空字符串视为&nbsp;<code>0</code>&nbsp;。</li>\n\t<li><strong>子序列</strong>&nbsp;是指从一个字符串中删除零个或者多个字符后，不改变顺序得到的剩余字符序列。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"1001010\", k = 5\n<b>输出：</b>5\n<b>解释：</b>s 中小于等于 5 的最长子序列是 \"00010\" ，对应的十进制数字是 2 。\n注意 \"00100\" 和 \"00101\" 也是可行的最长子序列，十进制分别对应 4 和 5 。\n最长子序列的长度为 5 ，所以返回 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"00101001\", k = 1\n<b>输出：</b>6\n<b>解释：</b>\"000001\" 是 s 中小于等于 1 的最长子序列，对应的十进制数字是 1 。\n最长子序列的长度为 6 ，所以返回 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i]</code> 要么是&nbsp;<code>'0'</code>&nbsp;，要么是&nbsp;<code>'1'</code> 。</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2312卖木头块",
        "hardRate": "HARD",
        "passRate": "53.72%",
        "problemsUrl": "https://leetcode.cn/problems/selling-pieces-of-wood/",
        "solutionsUrl": "https://leetcode.cn/problems/selling-pieces-of-wood/solution",
        "problemsDesc": "<p>给你两个整数&nbsp;<code>m</code> 和&nbsp;<code>n</code>&nbsp;，分别表示一块矩形木块的高和宽。同时给你一个二维整数数组&nbsp;<code>prices</code>&nbsp;，其中&nbsp;<code>prices[i] = [h<sub>i</sub>, w<sub>i</sub>, price<sub>i</sub>]</code>&nbsp;表示你可以以&nbsp;<code>price<sub>i</sub></code>&nbsp;元的价格卖一块高为&nbsp;<code>h<sub>i</sub></code>&nbsp;宽为&nbsp;<code>w<sub>i</sub></code>&nbsp;的矩形木块。</p>\n\n<p>每一次操作中，你必须按下述方式之一执行切割操作，以得到两块更小的矩形木块：</p>\n\n<ul>\n\t<li>沿垂直方向按高度 <strong>完全</strong> 切割木块，或</li>\n\t<li>沿水平方向按宽度 <strong>完全</strong> 切割木块</li>\n</ul>\n\n<p>在将一块木块切成若干小木块后，你可以根据 <code>prices</code>&nbsp;卖木块。你可以卖多块同样尺寸的木块。你不需要将所有小木块都卖出去。你 <strong>不能</strong>&nbsp;旋转切好后木块的高和宽。</p>\n\n<p>请你返回切割一块大小为<em>&nbsp;</em><code>m x n</code><em> </em>的木块后，能得到的&nbsp;<strong>最多</strong>&nbsp;钱数。</p>\n\n<p>注意你可以切割木块任意次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/27/ex1.png\" style=\"width: 239px; height: 150px;\" /></p>\n\n<pre>\n<b>输入：</b>m = 3, n = 5, prices = [[1,4,2],[2,2,7],[2,1,3]]\n<b>输出：</b>19\n<b>解释：</b>上图展示了一个可行的方案。包括：\n- 2 块 2 x 2 的小木块，售出 2 * 7 = 14 元。\n- 1 块 2 x 1 的小木块，售出 1 * 3 = 3 元。\n- 1 块 1 x 4 的小木块，售出 1 * 2 = 2 元。\n总共售出 14 + 3 + 2 = 19 元。\n19 元是最多能得到的钱数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/27/ex2new.png\" style=\"width: 250px; height: 175px;\" /></p>\n\n<pre>\n<b>输入：</b>m = 4, n = 6, prices = [[3,2,10],[1,4,2],[4,1,3]]\n<b>输出：</b>32\n<b>解释：</b>上图展示了一个可行的方案。包括：\n- 3 块 3 x 2 的小木块，售出 3 * 10 = 30 元。\n- 1 块 1 x 4 的小木块，售出 1 * 2 = 2 元。\n总共售出 30 + 2 = 32 元。\n32 元是最多能得到的钱数。\n注意我们不能旋转 1 x 4 的木块来得到 4 x 1 的木块。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>1 &lt;= prices.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>prices[i].length == 3</code></li>\n\t<li><code>1 &lt;= h<sub>i</sub> &lt;= m</code></li>\n\t<li><code>1 &lt;= w<sub>i</sub> &lt;= n</code></li>\n\t<li><code>1 &lt;= price<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n\t<li>所有&nbsp;<code>(h<sub>i</sub>, w<sub>i</sub>)</code> <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2313二叉树中得到结果所需的最少翻转次数",
        "hardRate": "HARD",
        "passRate": "67.71%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-flips-in-binary-tree-to-get-result/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-flips-in-binary-tree-to-get-result/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2314每个城市最高气温的第一天",
        "hardRate": "MEDIUM",
        "passRate": "71.38%",
        "problemsUrl": "https://leetcode.cn/problems/the-first-day-of-the-maximum-recorded-degree-in-each-city/",
        "solutionsUrl": "https://leetcode.cn/problems/the-first-day-of-the-maximum-recorded-degree-in-each-city/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2315统计星号",
        "hardRate": "EASY",
        "passRate": "85.81%",
        "problemsUrl": "https://leetcode.cn/problems/count-asterisks/",
        "solutionsUrl": "https://leetcode.cn/problems/count-asterisks/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，每&nbsp;<strong>两个</strong>&nbsp;连续竖线&nbsp;<code>'|'</code>&nbsp;为 <strong>一对</strong>&nbsp;。换言之，第一个和第二个&nbsp;<code>'|'</code>&nbsp;为一对，第三个和第四个&nbsp;<code>'|'</code>&nbsp;为一对，以此类推。</p>\n\n<p>请你返回 <strong>不在</strong> 竖线对之间，<code>s</code>&nbsp;中&nbsp;<code>'*'</code>&nbsp;的数目。</p>\n\n<p><strong>注意</strong>，每个竖线&nbsp;<code>'|'</code>&nbsp;都会 <strong>恰好</strong>&nbsp;属于一个对。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"l|*e*et|c**o|*de|\"\n<b>输出：</b>2\n<b>解释：</b>不在竖线对之间的字符加粗加斜体后，得到字符串：\"<strong><em>l</em></strong>|*e*et|<strong><em>c**o</em></strong>|*de|\" 。\n第一和第二条竖线 '|' 之间的字符不计入答案。\n同时，第三条和第四条竖线 '|' 之间的字符也不计入答案。\n不在竖线对之间总共有 2 个星号，所以我们返回 2 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"iamprogrammer\"\n<b>输出：</b>0\n<b>解释：</b>在这个例子中，s 中没有星号。所以返回 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>s = \"yo|uar|e**|b|e***au|tifu|l\"\n<b>输出：</b>5\n<b>解释：</b>需要考虑的字符加粗加斜体后：\"<strong><em>yo</em></strong>|uar|<strong><em>e**</em></strong>|b|<strong><em>e***au</em></strong>|tifu|<strong><em>l</em></strong>\" 。不在竖线对之间总共有 5 个星号。所以我们返回 5 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母，竖线&nbsp;<code>'|'</code>&nbsp;和星号&nbsp;<code>'*'</code>&nbsp;。</li>\n\t<li><code>s</code>&nbsp;包含 <strong>偶数</strong>&nbsp;个竖线&nbsp;<code>'|'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2316统计无向图中无法互相到达点对数",
        "hardRate": "MEDIUM",
        "passRate": "39.08%",
        "problemsUrl": "https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;，表示一张<strong>&nbsp;无向图</strong>&nbsp;中有 <code>n</code>&nbsp;个节点，编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。同时给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条&nbsp;<strong>无向</strong>&nbsp;边。</p>\n\n<p>请你返回 <strong>无法互相到达</strong>&nbsp;的不同 <strong>点对数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/05/tc-3.png\" style=\"width: 267px; height: 169px;\"></p>\n\n<pre><b>输入：</b>n = 3, edges = [[0,1],[0,2],[1,2]]\n<b>输出：</b>0\n<b>解释：</b>所有点都能互相到达，意味着没有点对无法互相到达，所以我们返回 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/05/tc-2.png\" style=\"width: 295px; height: 269px;\"></p>\n\n<pre><b>输入：</b>n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]\n<b>输出：</b>14\n<b>解释：</b>总共有 14 个点对互相无法到达：\n[[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]]\n所以我们返回 14 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= edges.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>不会有重复边。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2317操作后的最大异或和",
        "hardRate": "MEDIUM",
        "passRate": "85.16%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-xor-after-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-xor-after-operations/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。一次操作中，选择 <strong>任意</strong>&nbsp;非负整数&nbsp;<code>x</code>&nbsp;和一个下标&nbsp;<code>i</code>&nbsp;，<strong>更新</strong>&nbsp;<code>nums[i]</code>&nbsp;为&nbsp;<code>nums[i] AND (nums[i] XOR x)</code>&nbsp;。</p>\n\n<p>注意，<code>AND</code>&nbsp;是逐位与运算，<code>XOR</code>&nbsp;是逐位异或运算。</p>\n\n<p>请你执行 <strong>任意次</strong>&nbsp;更新操作，并返回&nbsp;<code>nums</code>&nbsp;中所有元素&nbsp;<strong>最大</strong>&nbsp;逐位异或和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [3,2,4,6]\n<b>输出：</b>7\n<b>解释：</b>选择 x = 4 和 i = 3 进行操作，num[3] = 6 AND (6 XOR 4) = 6 AND 2 = 2 。\n现在，nums = [3, 2, 4, 2] 且所有元素逐位异或得到 3 XOR 2 XOR 4 XOR 2 = 7 。\n可知 7 是能得到的最大逐位异或和。\n注意，其他操作可能也能得到逐位异或和 7 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,9,2]\n<b>输出：</b>11\n<b>解释：</b>执行 0 次操作。\n所有元素的逐位异或和为 1 XOR 2 XOR 3 XOR 9 XOR 2 = 11 。\n可知 11 是能得到的最大逐位异或和。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2318不同骰子序列的数目",
        "hardRate": "HARD",
        "passRate": "57.18%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-distinct-roll-sequences/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-distinct-roll-sequences/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;。你需要掷一个 6 面的骰子&nbsp;<code>n</code>&nbsp;次。请你在满足以下要求的前提下，求出 <strong>不同</strong>&nbsp;骰子序列的数目：</p>\n\n<ol>\n\t<li>序列中任意 <strong>相邻</strong>&nbsp;数字的 <strong>最大公约数</strong>&nbsp;为 <code>1</code>&nbsp;。</li>\n\t<li>序列中 <strong>相等</strong>&nbsp;的值之间，至少有 <code>2</code>&nbsp;个其他值的数字。正式地，如果第&nbsp;<code>i</code>&nbsp;次掷骰子的值 <strong>等于</strong>&nbsp;第&nbsp;<code>j</code>&nbsp;次的值，那么&nbsp;<code>abs(i - j) &gt; 2</code>&nbsp;。</li>\n</ol>\n\n<p>请你返回不同序列的 <strong>总数目</strong>&nbsp;。由于答案可能很大，请你将答案对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>如果两个序列中至少有一个元素不同，那么它们被视为不同的序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 4\n<b>输出：</b>184\n<b>解释：</b>一些可行的序列为 (1, 2, 3, 4) ，(6, 1, 2, 3) ，(1, 2, 3, 1) 等等。\n一些不可行的序列为 (1, 2, 1, 3) ，(1, 2, 3, 6) 。\n(1, 2, 1, 3) 是不可行的，因为第一个和第三个骰子值相等且 abs(1 - 3) = 2 （下标从 1 开始表示）。\n(1, 2, 3, 6) i是不可行的，因为 3 和 6 的最大公约数是 3 。\n总共有 184 个不同的可行序列，所以我们返回 184 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 2\n<b>输出：</b>22\n<b>解释：</b>一些可行的序列为 (1, 2) ，(2, 1) ，(3, 2) 。\n一些不可行的序列为 (3, 6) ，(2, 4) ，因为最大公约数不为 1 。\n总共有 22 个不同的可行序列，所以我们返回 22 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2319判断矩阵是否是一个 X 矩阵",
        "hardRate": "EASY",
        "passRate": "76.23%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-matrix-is-x-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-matrix-is-x-matrix/solution",
        "problemsDesc": "<p>如果一个正方形矩阵满足下述 <strong>全部</strong> 条件，则称之为一个 <strong>X 矩阵</strong> ：</p>\n\n<ol>\n\t<li>矩阵对角线上的所有元素都 <strong>不是 0</strong></li>\n\t<li>矩阵中所有其他元素都是 <strong>0</strong></li>\n</ol>\n\n<p>给你一个大小为 <code>n x n</code> 的二维整数数组 <code>grid</code> ，表示一个正方形矩阵。如果<em> </em><code>grid</code><em> </em>是一个 <strong>X 矩阵 </strong>，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/03/ex1.jpg\" style=\"width: 311px; height: 320px;\">\n<pre><strong>输入：</strong>grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]]\n<strong>输出：</strong>true\n<strong>解释：</strong>矩阵如上图所示。\nX 矩阵应该满足：绿色元素（对角线上）都不是 0 ，红色元素都是 0 。\n因此，grid 是一个 X 矩阵。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/03/ex2.jpg\" style=\"width: 238px; height: 246px;\">\n<pre><strong>输入：</strong>grid = [[5,7,0],[0,3,1],[0,5,0]]\n<strong>输出：</strong>false\n<strong>解释：</strong>矩阵如上图所示。\nX 矩阵应该满足：绿色元素（对角线上）都不是 0 ，红色元素都是 0 。\n因此，grid 不是一个 X 矩阵。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>3 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2320统计放置房子的方式数",
        "hardRate": "MEDIUM",
        "passRate": "40.44%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-ways-to-place-houses/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-ways-to-place-houses/solution",
        "problemsDesc": "<p>一条街道上共有 <code>n * 2</code> 个 <strong>地块</strong> ，街道的两侧各有 <code>n</code> 个地块。每一边的地块都按从 <code>1</code> 到 <code>n</code> 编号。每个地块上都可以放置一所房子。</p>\n\n<p>现要求街道同一侧不能存在两所房子相邻的情况，请你计算并返回放置房屋的方式数目。由于答案可能很大，需要对 <code>10<sup>9</sup> + 7</code> 取余后再返回。</p>\n\n<p>注意，如果一所房子放置在这条街某一侧上的第 <code>i</code> 个地块，不影响在另一侧的第 <code>i</code> 个地块放置房子。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>4\n<strong>解释：</strong>\n可能的放置方式：\n1. 所有地块都不放置房子。\n2. 一所房子放在街道的某一侧。\n3. 一所房子放在街道的另一侧。\n4. 放置两所房子，街道两侧各放置一所。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/12/arrangements.png\" style=\"width: 500px; height: 500px;\">\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>9\n<strong>解释：</strong>如上图所示，共有 9 种可能的放置方式。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2321拼接数组的最大分数",
        "hardRate": "HARD",
        "passRate": "51.34%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-of-spliced-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-of-spliced-array/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，长度都是 <code>n</code> 。</p>\n\n<p>你可以选择两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>0 &lt;= left &lt;= right &lt; n</code> ，接着 <strong>交换</strong> 两个子数组 <code>nums1[left...right]</code> 和 <code>nums2[left...right]</code> 。</p>\n\n<ul>\n\t<li>例如，设 <code>nums1 = [1,2,3,4,5]</code> 和 <code>nums2 = [11,12,13,14,15]</code> ，整数选择 <code>left = 1</code> 和 <code>right = 2</code>，那么 <code>nums1</code> 会变为 <code>[1,<strong><em>12</em>,<em>13</em></strong>,4,5]</code> 而 <code>nums2</code> 会变为 <code>[11,<em><strong>2,3</strong></em>,14,15]</code> 。</li>\n</ul>\n\n<p>你可以选择执行上述操作 <strong>一次</strong> 或不执行任何操作。</p>\n\n<p>数组的 <strong>分数</strong> 取 <code>sum(nums1)</code> 和 <code>sum(nums2)</code> 中的最大值，其中 <code>sum(arr)</code> 是数组 <code>arr</code> 中所有元素之和。</p>\n\n<p>返回 <strong>可能的最大分数</strong> 。</p>\n\n<p><strong>子数组 </strong>是数组中连续的一个元素序列。<code>arr[left...right]</code> 表示子数组包含 <code>nums</code> 中下标 <code>left</code> 和 <code>right</code> 之间的元素<strong>（含</strong> 下标 <code>left</code> 和 <code>right</code> 对应元素<strong>）</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [60,60,60], nums2 = [10,90,10]\n<strong>输出：</strong>210\n<strong>解释：</strong>选择 left = 1 和 right = 1 ，得到 nums1 = [60,<em><strong>90</strong></em>,60] 和 nums2 = [10,<em><strong>60</strong></em>,10] 。\n分数为 max(sum(nums1), sum(nums2)) = max(210, 80) = 210 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [20,40,20,70,30], nums2 = [50,20,50,40,20]\n<strong>输出：</strong>220\n<strong>解释：</strong>选择 left = 3 和 right = 4 ，得到 nums1 = [20,40,20,<em><strong>40,20</strong></em>] 和 nums2 = [50,20,50,<em><strong>70,30</strong></em>] 。\n分数为 max(sum(nums1), sum(nums2)) = max(140, 220) = 220 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [7,11,13], nums2 = [1,1,1]\n<strong>输出：</strong>31\n<strong>解释：</strong>选择不交换任何子数组。\n分数为 max(sum(nums1), sum(nums2)) = max(31, 3) = 31 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length == nums2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2322从树中删除边的最小分数",
        "hardRate": "HARD",
        "passRate": "58.93%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-score-after-removals-on-a-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-score-after-removals-on-a-tree/solution",
        "problemsDesc": "<p>存在一棵无向连通树，树中有编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个节点， 以及 <code>n - 1</code> 条边。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，长度为 <code>n</code> ，其中 <code>nums[i]</code> 表示第 <code>i</code> 个节点的值。另给你一个二维整数数组 <code>edges</code> ，长度为 <code>n - 1</code> ，其中 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示树中存在一条位于节点 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间的边。</p>\n\n<p>删除树中两条 <strong>不同</strong> 的边以形成三个连通组件。对于一种删除边方案，定义如下步骤以计算其分数：</p>\n\n<ol>\n\t<li>分别获取三个组件 <strong>每个</strong> 组件中所有节点值的异或值。</li>\n\t<li><strong>最大</strong> 异或值和 <strong>最小</strong> 异或值的 <strong>差值</strong> 就是这一种删除边方案的分数。</li>\n</ol>\n\n<ul>\n\t<li>例如，三个组件的节点值分别是：<code>[4,5,7]</code>、<code>[1,9]</code> 和 <code>[3,3,3]</code> 。三个异或值分别是 <code>4 ^ 5 ^ 7 = <em><strong>6</strong></em></code>、<code>1 ^ 9 = <em><strong>8</strong></em></code> 和 <code>3 ^ 3 ^ 3 = <em><strong>3</strong></em></code> 。最大异或值是 <code>8</code> ，最小异或值是 <code>3</code> ，分数是 <code>8 - 3 = 5</code> 。</li>\n</ul>\n\n<p>返回在给定树上执行任意删除边方案可能的 <strong>最小</strong> 分数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/03/ex1drawio.png\" style=\"width: 193px; height: 190px;\">\n<pre><strong>输入：</strong>nums = [1,5,5,4,11], edges = [[0,1],[1,2],[1,3],[3,4]]\n<strong>输出：</strong>9\n<strong>解释：</strong>上图展示了一种删除边方案。\n- 第 1 个组件的节点是 [1,3,4] ，值是 [5,4,11] 。异或值是 5 ^ 4 ^ 11 = 10 。\n- 第 2 个组件的节点是 [0] ，值是 [1] 。异或值是 1 = 1 。\n- 第 3 个组件的节点是 [2] ，值是 [5] 。异或值是 5 = 5 。\n分数是最大异或值和最小异或值的差值，10 - 1 = 9 。\n可以证明不存在分数比 9 小的删除边方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/03/ex2drawio.png\" style=\"width: 287px; height: 150px;\">\n<pre><strong>输入：</strong>nums = [5,5,2,4,4,2], edges = [[0,1],[1,2],[5,2],[4,3],[1,3]]\n<strong>输出：</strong>0\n<strong>解释：</strong>上图展示了一种删除边方案。\n- 第 1 个组件的节点是 [3,4] ，值是 [4,4] 。异或值是 4 ^ 4 = 0 。\n- 第 2 个组件的节点是 [1,0] ，值是 [5,5] 。异或值是 5 ^ 5 = 0 。\n- 第 3 个组件的节点是 [2,5] ，值是 [2,2] 。异或值是 2 ^ 2 = 0 。\n分数是最大异或值和最小异或值的差值，0 - 0 = 0 。\n无法获得比 0 更小的分数 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>3 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>8</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>edges</code> 表示一棵有效的树</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2323完成所有工作的最短时间 II",
        "hardRate": "MEDIUM",
        "passRate": "70.70%",
        "problemsUrl": "https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2324产品销售分析 IV",
        "hardRate": "MEDIUM",
        "passRate": "70.95%",
        "problemsUrl": "https://leetcode.cn/problems/product-sales-analysis-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/product-sales-analysis-iv/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2325解密消息",
        "hardRate": "EASY",
        "passRate": "85.69%",
        "problemsUrl": "https://leetcode.cn/problems/decode-the-message/",
        "solutionsUrl": "https://leetcode.cn/problems/decode-the-message/solution",
        "problemsDesc": "<p>给你字符串 <code>key</code> 和 <code>message</code> ，分别表示一个加密密钥和一段加密消息。解密 <code>message</code> 的步骤如下：</p>\n\n<ol>\n\t<li>使用 <code>key</code> 中 26 个英文小写字母第一次出现的顺序作为替换表中的字母 <strong>顺序</strong> 。</li>\n\t<li>将替换表与普通英文字母表对齐，形成对照表。</li>\n\t<li>按照对照表 <strong>替换</strong> <code>message</code> 中的每个字母。</li>\n\t<li>空格 <code>' '</code> 保持不变。</li>\n</ol>\n\n<ul>\n\t<li>例如，<code>key = \"<em><strong>hap</strong></em>p<em><strong>y</strong></em> <em><strong>bo</strong></em>y\"</code>（实际的加密密钥会包含字母表中每个字母 <strong>至少一次</strong>），据此，可以得到部分对照表（<code>'h' -&gt; 'a'</code>、<code>'a' -&gt; 'b'</code>、<code>'p' -&gt; 'c'</code>、<code>'y' -&gt; 'd'</code>、<code>'b' -&gt; 'e'</code>、<code>'o' -&gt; 'f'</code>）。</li>\n</ul>\n\n<p>返回解密后的消息。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/08/ex1new4.jpg\" style=\"width: 752px; height: 150px;\" /></p>\n\n<pre>\n<strong>输入：</strong>key = \"the quick brown fox jumps over the lazy dog\", message = \"vkbs bs t suepuv\"\n<strong>输出：</strong>\"this is a secret\"\n<strong>解释：</strong>对照表如上图所示。\n提取 \"<em><strong>the</strong></em> <em><strong>quick</strong></em> <em><strong>brown</strong></em> <em><strong>f</strong></em>o<em><strong>x</strong></em> <em><strong>j</strong></em>u<em><strong>mps</strong></em> o<em><strong>v</strong></em>er the <em><strong>lazy</strong></em> <em><strong>d</strong></em>o<em><strong>g</strong></em>\" 中每个字母的首次出现可以得到替换表。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/08/ex2new.jpg\" style=\"width: 754px; height: 150px;\" /></p>\n\n<pre>\n<strong>输入：</strong>key = \"eljuxhpwnyrdgtqkviszcfmabo\", message = \"zwx hnfx lqantp mnoeius ycgk vcnjrdb\"\n<strong>输出：</strong>\"the five boxing wizards jump quickly\"\n<strong>解释：</strong>对照表如上图所示。\n提取 \"<em><strong>eljuxhpwnyrdgtqkviszcfmabo</strong></em>\" 中每个字母的首次出现可以得到替换表。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>26 &lt;= key.length &lt;= 2000</code></li>\n\t<li><code>key</code> 由小写英文字母及 <code>' '</code> 组成</li>\n\t<li><code>key</code> 包含英文字母表中每个字符（<code>'a'</code> 到 <code>'z'</code>）<strong>至少一次</strong></li>\n\t<li><code>1 &lt;= message.length &lt;= 2000</code></li>\n\t<li><code>message</code> 由小写英文字母和 <code>' '</code> 组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2326螺旋矩阵 IV",
        "hardRate": "MEDIUM",
        "passRate": "66.77%",
        "problemsUrl": "https://leetcode.cn/problems/spiral-matrix-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/spiral-matrix-iv/solution",
        "problemsDesc": "<p>给你两个整数：<code>m</code> 和 <code>n</code> ，表示矩阵的维数。</p>\n\n<p>另给你一个整数链表的头节点 <code>head</code> 。</p>\n\n<p>请你生成一个大小为 <code>m x n</code> 的螺旋矩阵，矩阵包含链表中的所有整数。链表中的整数从矩阵 <strong>左上角</strong> 开始、<strong>顺时针 </strong>按 <strong>螺旋</strong> 顺序填充。如果还存在剩余的空格，则用 <code>-1</code> 填充。</p>\n\n<p>返回生成的矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/09/ex1new.jpg\" style=\"width: 240px; height: 150px;\">\n<pre><strong>输入：</strong>m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]\n<strong>输出：</strong>[[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]\n<strong>解释：</strong>上图展示了链表中的整数在矩阵中是如何排布的。\n注意，矩阵中剩下的空格用 -1 填充。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/11/ex2.jpg\" style=\"width: 221px; height: 60px;\">\n<pre><strong>输入：</strong>m = 1, n = 4, head = [0,1,2]\n<strong>输出：</strong>[[0,1,2,-1]]\n<strong>解释：</strong>上图展示了链表中的整数在矩阵中是如何从左到右排布的。 \n注意，矩阵中剩下的空格用 -1 填充。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li>链表中节点数目在范围 <code>[1, m * n]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2327知道秘密的人数",
        "hardRate": "MEDIUM",
        "passRate": "45.79%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-people-aware-of-a-secret/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-people-aware-of-a-secret/solution",
        "problemsDesc": "<p>在第 <code>1</code>&nbsp;天，有一个人发现了一个秘密。</p>\n\n<p>给你一个整数&nbsp;<code>delay</code>&nbsp;，表示每个人会在发现秘密后的 <code>delay</code>&nbsp;天之后，<strong>每天</strong>&nbsp;给一个新的人&nbsp;<strong>分享</strong>&nbsp;秘密。同时给你一个整数&nbsp;<code>forget</code>&nbsp;，表示每个人在发现秘密&nbsp;<code>forget</code>&nbsp;天之后会&nbsp;<strong>忘记</strong>&nbsp;这个秘密。一个人&nbsp;<strong>不能</strong>&nbsp;在忘记秘密那一天及之后的日子里分享秘密。</p>\n\n<p>给你一个整数&nbsp;<code>n</code>&nbsp;，请你返回在第 <code>n</code>&nbsp;天结束时，知道秘密的人数。由于答案可能会很大，请你将结果对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 6, delay = 2, forget = 4\n<b>输出：</b>5\n<strong>解释：</strong>\n第 1 天：假设第一个人叫 A 。（一个人知道秘密）\n第 2 天：A 是唯一一个知道秘密的人。（一个人知道秘密）\n第 3 天：A 把秘密分享给 B 。（两个人知道秘密）\n第 4 天：A 把秘密分享给一个新的人 C 。（三个人知道秘密）\n第 5 天：A 忘记了秘密，B 把秘密分享给一个新的人 D 。（三个人知道秘密）\n第 6 天：B 把秘密分享给 E，C 把秘密分享给 F 。（五个人知道秘密）\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 4, delay = 1, forget = 3\n<b>输出：</b>6\n<strong>解释：</strong>\n第 1 天：第一个知道秘密的人为 A 。（一个人知道秘密）\n第 2 天：A 把秘密分享给 B 。（两个人知道秘密）\n第 3 天：A 和 B 把秘密分享给 2 个新的人 C 和 D 。（四个人知道秘密）\n第 4 天：A 忘记了秘密，B、C、D 分别分享给 3 个新的人。（六个人知道秘密）\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= delay &lt; forget &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2328网格图中递增路径的数目",
        "hardRate": "HARD",
        "passRate": "50.94%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的整数网格图&nbsp;<code>grid</code>&nbsp;，你可以从一个格子移动到&nbsp;<code>4</code>&nbsp;个方向相邻的任意一个格子。</p>\n\n<p>请你返回在网格图中从 <strong>任意</strong>&nbsp;格子出发，达到 <strong>任意</strong>&nbsp;格子，且路径中的数字是 <strong>严格递增</strong>&nbsp;的路径数目。由于答案可能会很大，请将结果对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>如果两条路径中访问过的格子不是完全相同的，那么它们视为两条不同的路径。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/10/griddrawio-4.png\" style=\"width: 181px; height: 121px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,1],[3,4]]\n<b>输出：</b>8\n<b>解释：</b>严格递增路径包括：\n- 长度为 1 的路径：[1]，[1]，[3]，[4] 。\n- 长度为 2 的路径：[1 -&gt; 3]，[1 -&gt; 4]，[3 -&gt; 4] 。\n- 长度为 3 的路径：[1 -&gt; 3 -&gt; 4] 。\n路径数目为 4 + 3 + 1 = 8 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>grid = [[1],[2]]\n<b>输出：</b>3\n<b>解释：</b>严格递增路径包括：\n- 长度为 1 的路径：[1]，[2] 。\n- 长度为 2 的路径：[1 -&gt; 2] 。\n路径数目为 2 + 1 = 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2329产品销售分析Ⅴ",
        "hardRate": "EASY",
        "passRate": "72.36%",
        "problemsUrl": "https://leetcode.cn/problems/product-sales-analysis-v/",
        "solutionsUrl": "https://leetcode.cn/problems/product-sales-analysis-v/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2330有效的回文 IV",
        "hardRate": "MEDIUM",
        "passRate": "81.55%",
        "problemsUrl": "https://leetcode.cn/problems/valid-palindrome-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-palindrome-iv/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2331计算布尔二叉树的值",
        "hardRate": "EASY",
        "passRate": "84.01%",
        "problemsUrl": "https://leetcode.cn/problems/evaluate-boolean-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/evaluate-boolean-binary-tree/solution",
        "problemsDesc": "<p>给你一棵 <strong>完整二叉树</strong>&nbsp;的根，这棵树有以下特征：</p>\n\n<ul>\n\t<li><strong>叶子节点</strong>&nbsp;要么值为&nbsp;<code>0</code>&nbsp;要么值为&nbsp;<code>1</code>&nbsp;，其中&nbsp;<code>0</code> 表示&nbsp;<code>False</code>&nbsp;，<code>1</code> 表示&nbsp;<code>True</code>&nbsp;。</li>\n\t<li><strong>非叶子节点 </strong>要么值为 <code>2</code>&nbsp;要么值为 <code>3</code>&nbsp;，其中&nbsp;<code>2</code>&nbsp;表示逻辑或&nbsp;<code>OR</code> ，<code>3</code>&nbsp;表示逻辑与&nbsp;<code>AND</code>&nbsp;。</li>\n</ul>\n\n<p><strong>计算</strong>&nbsp;一个节点的值方式如下：</p>\n\n<ul>\n\t<li>如果节点是个叶子节点，那么节点的 <strong>值</strong>&nbsp;为它本身，即&nbsp;<code>True</code>&nbsp;或者&nbsp;<code>False</code>&nbsp;。</li>\n\t<li>否则，<strong>计算</strong>&nbsp;两个孩子的节点值，然后将该节点的运算符对两个孩子值进行 <strong>运算</strong>&nbsp;。</li>\n</ul>\n\n<p>返回根节点<em>&nbsp;</em><code>root</code>&nbsp;的布尔运算值。</p>\n\n<p><strong>完整二叉树</strong>&nbsp;是每个节点有 <code>0</code>&nbsp;个或者 <code>2</code>&nbsp;个孩子的二叉树。</p>\n\n<p><strong>叶子节点</strong>&nbsp;是没有孩子的节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/16/example1drawio1.png\" style=\"width: 700px; height: 252px;\"></p>\n\n<pre><b>输入：</b>root = [2,1,3,null,null,0,1]\n<b>输出：</b>true\n<b>解释：</b>上图展示了计算过程。\nAND 与运算节点的值为 False AND True = False 。\nOR 运算节点的值为 True OR False = True 。\n根节点的值为 True ，所以我们返回 true 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>root = [0]\n<b>输出：</b>false\n<b>解释：</b>根节点是叶子节点，且值为 false，所以我们返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在&nbsp;<code>[1, 1000]</code>&nbsp;之间。</li>\n\t<li><code>0 &lt;= Node.val &lt;= 3</code></li>\n\t<li>每个节点的孩子数为&nbsp;<code>0</code> 或&nbsp;<code>2</code>&nbsp;。</li>\n\t<li>叶子节点的值为&nbsp;<code>0</code>&nbsp;或&nbsp;<code>1</code>&nbsp;。</li>\n\t<li>非叶子节点的值为&nbsp;<code>2</code>&nbsp;或&nbsp;<code>3</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2332坐上公交的最晚时间",
        "hardRate": "MEDIUM",
        "passRate": "24.37%",
        "problemsUrl": "https://leetcode.cn/problems/the-latest-time-to-catch-a-bus/",
        "solutionsUrl": "https://leetcode.cn/problems/the-latest-time-to-catch-a-bus/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>buses</code>&nbsp;，其中&nbsp;<code>buses[i]</code>&nbsp;表示第 <code>i</code>&nbsp;辆公交车的出发时间。同时给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>m</code>&nbsp;的整数数组&nbsp;<code>passengers</code>&nbsp;，其中&nbsp;<code>passengers[j]</code>&nbsp;表示第&nbsp;<code>j</code>&nbsp;位乘客的到达时间。所有公交车出发的时间互不相同，所有乘客到达的时间也互不相同。</p>\n\n<p>给你一个整数&nbsp;<code>capacity</code>&nbsp;，表示每辆公交车&nbsp;<strong>最多</strong>&nbsp;能容纳的乘客数目。</p>\n\n<p>每位乘客都会搭乘下一辆有座位的公交车。如果你在 <code>y</code>&nbsp;时刻到达，公交在&nbsp;<code>x</code>&nbsp;时刻出发，满足&nbsp;<code>y &lt;= x</code>&nbsp;&nbsp;且公交没有满，那么你可以搭乘这一辆公交。<strong>最早</strong>&nbsp;到达的乘客优先上车。</p>\n\n<p>返回你可以搭乘公交车的最晚到达公交站时间。你 <strong>不能</strong>&nbsp;跟别的乘客同时刻到达。</p>\n\n<p><strong>注意：</strong>数组&nbsp;<code>buses</code> 和&nbsp;<code>passengers</code>&nbsp;不一定是有序的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>buses = [10,20], passengers = [2,17,18,19], capacity = 2\n<b>输出：</b>16\n<strong>解释：</strong>\n第 1 辆公交车载着第 1 位乘客。\n第 2 辆公交车载着你和第 2 位乘客。\n注意你不能跟其他乘客同一时间到达，所以你必须在第二位乘客之前到达。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2\n<b>输出：</b>20\n<b>解释：</b>\n第 1 辆公交车载着第 4 位乘客。\n第 2 辆公交车载着第 6 位和第 2 位乘客。\n第 3 辆公交车载着第 1 位乘客和你。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == buses.length</code></li>\n\t<li><code>m == passengers.length</code></li>\n\t<li><code>1 &lt;= n, m, capacity &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= buses[i], passengers[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>buses</code>&nbsp;中的元素 <strong>互不相同&nbsp;</strong>。</li>\n\t<li><code>passengers</code>&nbsp;中的元素 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2333最小差值平方和",
        "hardRate": "MEDIUM",
        "passRate": "26.70%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-sum-of-squared-difference/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-sum-of-squared-difference/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;，长度为&nbsp;<code>n</code>&nbsp;。</p>\n\n<p>数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;的 <strong>差值平方和</strong>&nbsp;定义为所有满足&nbsp;<code>0 &lt;= i &lt; n</code>&nbsp;的&nbsp;<code>(nums1[i] - nums2[i])<sup>2</sup></code>&nbsp;之和。</p>\n\n<p>同时给你两个正整数&nbsp;<code>k1</code> 和&nbsp;<code>k2</code>&nbsp;。你可以将&nbsp;<code>nums1</code>&nbsp;中的任意元素&nbsp;<code>+1</code> 或者&nbsp;<code>-1</code>&nbsp;至多&nbsp;<code>k1</code>&nbsp;次。类似的，你可以将&nbsp;<code>nums2</code>&nbsp;中的任意元素&nbsp;<code>+1</code> 或者&nbsp;<code>-1</code>&nbsp;至多&nbsp;<code>k2</code>&nbsp;次。</p>\n\n<p>请你返回修改数组<em>&nbsp;</em><code>nums1</code><em>&nbsp;</em>至多<em>&nbsp;</em><code>k1</code>&nbsp;次且修改数组<em>&nbsp;</em><code>nums2</code>&nbsp;至多 <code>k2</code><em>&nbsp;</em>次后的最小&nbsp;<strong>差值平方和</strong>&nbsp;。</p>\n\n<p><strong>注意：</strong>你可以将数组中的元素变成&nbsp;<strong>负</strong>&nbsp;整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,2,3,4], nums2 = [2,10,20,19], k1 = 0, k2 = 0\n<b>输出：</b>579\n<b>解释：</b>nums1 和 nums2 中的元素不能修改，因为 k1 = 0 和 k2 = 0 。\n差值平方和为：(1 - 2)<sup>2 </sup>+ (2 - 10)<sup>2 </sup>+ (3 - 20)<sup>2 </sup>+ (4 - 19)<sup>2</sup>&nbsp;= 579 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,4,10,12], nums2 = [5,8,6,9], k1 = 1, k2 = 1\n<b>输出：</b>43\n<b>解释：</b>一种得到最小差值平方和的方式为：\n- 将 nums1[0] 增加一次。\n- 将 nums2[2] 增加一次。\n最小差值平方和为：\n(2 - 5)<sup>2 </sup>+ (4 - 8)<sup>2 </sup>+ (10 - 7)<sup>2 </sup>+ (12 - 9)<sup>2</sup>&nbsp;= 43 。\n注意，也有其他方式可以得到最小差值平方和，但没有得到比 43 更小答案的方案。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length == nums2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= k1, k2 &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2334元素值大于变化阈值的子数组",
        "hardRate": "HARD",
        "passRate": "47.37%",
        "problemsUrl": "https://leetcode.cn/problems/subarray-with-elements-greater-than-varying-threshold/",
        "solutionsUrl": "https://leetcode.cn/problems/subarray-with-elements-greater-than-varying-threshold/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>threshold</code>&nbsp;。</p>\n\n<p>找到长度为 <code>k</code>&nbsp;的&nbsp;<code>nums</code>&nbsp;子数组，满足数组中&nbsp;<strong>每个</strong>&nbsp;元素都 <strong>大于</strong>&nbsp;<code>threshold / k</code>&nbsp;。</p>\n\n<p>请你返回满足要求的 <strong>任意</strong>&nbsp;子数组的 <strong>大小</strong>&nbsp;。如果没有这样的子数组，返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p><strong>子数组</strong> 是数组中一段连续非空的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,3,4,3,1], threshold = 6\n<b>输出：</b>3\n<b>解释：</b>子数组 [3,4,3] 大小为 3 ，每个元素都大于 6 / 3 = 2 。\n注意这是唯一合法的子数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [6,5,6,5,8], threshold = 7\n<b>输出：</b>1\n<b>解释：</b>子数组 [8] 大小为 1 ，且 8 &gt; 7 / 1 = 7 。所以返回 1 。\n注意子数组 [6,5] 大小为 2 ，每个元素都大于 7 / 2 = 3.5 。\n类似的，子数组 [6,5,6] ，[6,5,6,5] ，[6,5,6,5,8] 都是符合条件的子数组。\n所以返回 2, 3, 4 和 5 都可以。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], threshold &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2335装满杯子需要的最短总时长",
        "hardRate": "EASY",
        "passRate": "64.53%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-amount-of-time-to-fill-cups/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-amount-of-time-to-fill-cups/solution",
        "problemsDesc": "<p>现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满 <code>2</code> 杯 <strong>不同</strong> 类型的水或者 <code>1</code> 杯任意类型的水。</p>\n\n<p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>3</code> 的整数数组 <code>amount</code> ，其中 <code>amount[0]</code>、<code>amount[1]</code> 和 <code>amount[2]</code> 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 <strong>最少</strong> 秒数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>amount = [1,4,2]\n<strong>输出：</strong>4\n<strong>解释：</strong>下面给出一种方案：\n第 1 秒：装满一杯冷水和一杯温水。\n第 2 秒：装满一杯温水和一杯热水。\n第 3 秒：装满一杯温水和一杯热水。\n第 4 秒：装满一杯温水。\n可以证明最少需要 4 秒才能装满所有杯子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>amount = [5,4,4]\n<strong>输出：</strong>7\n<strong>解释：</strong>下面给出一种方案：\n第 1 秒：装满一杯冷水和一杯热水。\n第 2 秒：装满一杯冷水和一杯温水。\n第 3 秒：装满一杯冷水和一杯温水。\n第 4 秒：装满一杯温水和一杯热水。\n第 5 秒：装满一杯冷水和一杯热水。\n第 6 秒：装满一杯冷水和一杯温水。\n第 7 秒：装满一杯热水。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>amount = [5,0,0]\n<strong>输出：</strong>5\n<strong>解释：</strong>每秒装满一杯冷水。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>amount.length == 3</code></li>\n\t<li><code>0 &lt;= amount[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2336无限集中的最小数字",
        "hardRate": "MEDIUM",
        "passRate": "69.87%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-number-in-infinite-set/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-number-in-infinite-set/solution",
        "problemsDesc": "<p>现有一个包含所有正整数的集合 <code>[1, 2, 3, 4, 5, ...]</code> 。</p>\n\n<p>实现 <code>SmallestInfiniteSet</code> 类：</p>\n\n<ul>\n\t<li><code>SmallestInfiniteSet()</code> 初始化 <strong>SmallestInfiniteSet</strong> 对象以包含 <strong>所有</strong> 正整数。</li>\n\t<li><code>int popSmallest()</code> <strong>移除</strong> 并返回该无限集中的最小整数。</li>\n\t<li><code>void addBack(int num)</code> 如果正整数 <code>num</code> <strong>不</strong> 存在于无限集中，则将一个 <code>num</code> <strong>添加</strong> 到该无限集中。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入</strong>\n[\"SmallestInfiniteSet\", \"addBack\", \"popSmallest\", \"popSmallest\", \"popSmallest\", \"addBack\", \"popSmallest\", \"popSmallest\", \"popSmallest\"]\n[[], [2], [], [], [], [1], [], [], []]\n<strong>输出</strong>\n[null, null, 1, 2, 3, null, 1, 4, 5]\n\n<strong>解释</strong>\nSmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet();\nsmallestInfiniteSet.addBack(2);    // 2 已经在集合中，所以不做任何变更。\nsmallestInfiniteSet.popSmallest(); // 返回 1 ，因为 1 是最小的整数，并将其从集合中移除。\nsmallestInfiniteSet.popSmallest(); // 返回 2 ，并将其从集合中移除。\nsmallestInfiniteSet.popSmallest(); // 返回 3 ，并将其从集合中移除。\nsmallestInfiniteSet.addBack(1);    // 将 1 添加到该集合中。\nsmallestInfiniteSet.popSmallest(); // 返回 1 ，因为 1 在上一步中被添加到集合中，\n                                   // 且 1 是最小的整数，并将其从集合中移除。\nsmallestInfiniteSet.popSmallest(); // 返回 4 ，并将其从集合中移除。\nsmallestInfiniteSet.popSmallest(); // 返回 5 ，并将其从集合中移除。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 1000</code></li>\n\t<li>最多调用 <code>popSmallest</code> 和 <code>addBack</code> 方法 <strong>共计</strong> <code>1000</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2337移动片段得到字符串",
        "hardRate": "MEDIUM",
        "passRate": "39.30%",
        "problemsUrl": "https://leetcode.cn/problems/move-pieces-to-obtain-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/move-pieces-to-obtain-a-string/solution",
        "problemsDesc": "<p>给你两个字符串 <code>start</code> 和 <code>target</code> ，长度均为 <code>n</code> 。每个字符串 <strong>仅</strong> 由字符 <code>'L'</code>、<code>'R'</code> 和 <code>'_'</code> 组成，其中：</p>\n\n<ul>\n\t<li>字符 <code>'L'</code> 和 <code>'R'</code> 表示片段，其中片段 <code>'L'</code> 只有在其左侧直接存在一个 <strong>空位</strong> 时才能向 <strong>左</strong> 移动，而片段 <code>'R'</code> 只有在其右侧直接存在一个 <strong>空位</strong> 时才能向 <strong>右</strong> 移动。</li>\n\t<li>字符 <code>'_'</code> 表示可以被 <strong>任意</strong> <code>'L'</code> 或 <code>'R'</code> 片段占据的空位。</li>\n</ul>\n\n<p>如果在移动字符串 <code>start</code> 中的片段任意次之后可以得到字符串 <code>target</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>start = \"_L__R__R_\", target = \"L______RR\"\n<strong>输出：</strong>true\n<strong>解释：</strong>可以从字符串 start 获得 target ，需要进行下面的移动：\n- 将第一个片段向左移动一步，字符串现在变为 \"<strong>L</strong>___R__R_\" 。\n- 将最后一个片段向右移动一步，字符串现在变为 \"L___R___<strong>R</strong>\" 。\n- 将第二个片段向右移动散步，字符串现在变为 \"L______<strong>R</strong>R\" 。\n可以从字符串 start 得到 target ，所以返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>start = \"R_L_\", target = \"__LR\"\n<strong>输出：</strong>false\n<strong>解释：</strong>字符串 start 中的 'R' 片段可以向右移动一步得到 \"_<strong>R</strong>L_\" 。\n但是，在这一步之后，不存在可以移动的片段，所以无法从字符串 start 得到 target 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>start = \"_R\", target = \"R_\"\n<strong>输出：</strong>false\n<strong>解释：</strong>字符串 start 中的片段只能向右移动，所以无法从字符串 start 得到 target 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == start.length == target.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>start</code> 和 <code>target</code> 由字符 <code>'L'</code>、<code>'R'</code> 和 <code>'_'</code> 组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2338统计理想数组的数目",
        "hardRate": "HARD",
        "passRate": "30.71%",
        "problemsUrl": "https://leetcode.cn/problems/count-the-number-of-ideal-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/count-the-number-of-ideal-arrays/solution",
        "problemsDesc": "<p>给你两个整数 <code>n</code> 和 <code>maxValue</code> ，用于描述一个 <strong>理想数组</strong> 。</p>\n\n<p>对于下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>arr</code> ，如果满足以下条件，则认为该数组是一个 <strong>理想数组</strong> ：</p>\n\n<ul>\n\t<li>每个 <code>arr[i]</code> 都是从 <code>1</code> 到 <code>maxValue</code> 范围内的一个值，其中 <code>0 &lt;= i &lt; n</code> 。</li>\n\t<li>每个 <code>arr[i]</code> 都可以被 <code>arr[i - 1]</code> 整除，其中 <code>0 &lt; i &lt; n</code> 。</li>\n</ul>\n\n<p>返回长度为 <code>n</code> 的 <strong>不同</strong> 理想数组的数目。由于答案可能很大，返回对 <code>10<sup>9</sup> + 7</code> 取余的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, maxValue = 5\n<strong>输出：</strong>10\n<strong>解释：</strong>存在以下理想数组：\n- 以 1 开头的数组（5 个）：[1,1]、[1,2]、[1,3]、[1,4]、[1,5]\n- 以 2 开头的数组（2 个）：[2,2]、[2,4]\n- 以 3 开头的数组（1 个）：[3,3]\n- 以 4 开头的数组（1 个）：[4,4]\n- 以 5 开头的数组（1 个）：[5,5]\n共计 5 + 2 + 1 + 1 + 1 = 10 个不同理想数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 5, maxValue = 3\n<strong>输出：</strong>11\n<strong>解释：</strong>存在以下理想数组：\n- 以 1 开头的数组（9 个）：\n   - 不含其他不同值（1 个）：[1,1,1,1,1] \n   - 含一个不同值 2（4 个）：[1,1,1,1,2], [1,1,1,2,2], [1,1,2,2,2], [1,2,2,2,2]\n   - 含一个不同值 3（4 个）：[1,1,1,1,3], [1,1,1,3,3], [1,1,3,3,3], [1,3,3,3,3]\n- 以 2 开头的数组（1 个）：[2,2,2,2,2]\n- 以 3 开头的数组（1 个）：[3,3,3,3,3]\n共计 9 + 1 + 1 = 11 个不同理想数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= maxValue &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2339联赛的所有比赛",
        "hardRate": "EASY",
        "passRate": "75.58%",
        "problemsUrl": "https://leetcode.cn/problems/all-the-matches-of-the-league/",
        "solutionsUrl": "https://leetcode.cn/problems/all-the-matches-of-the-league/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2340生成有效数组的最少交换次数",
        "hardRate": "MEDIUM",
        "passRate": "76.60%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-adjacent-swaps-to-make-a-valid-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-adjacent-swaps-to-make-a-valid-array/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2341数组能形成多少数对",
        "hardRate": "EASY",
        "passRate": "81.16%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-pairs-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-pairs-in-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。在一步操作中，你可以执行以下步骤：</p>\n\n<ul>\n\t<li>从 <code>nums</code> 选出 <strong>两个</strong> <strong>相等的</strong> 整数</li>\n\t<li>从 <code>nums</code> 中移除这两个整数，形成一个 <strong>数对</strong></li>\n</ul>\n\n<p>请你在 <code>nums</code> 上多次执行此操作直到无法继续执行。</p>\n\n<p>返回一个下标从 <strong>0</strong> 开始、长度为 <code>2</code> 的整数数组 <code>answer</code> 作为答案，其中<em> </em><code>answer[0]</code><em> </em>是形成的数对数目，<code>answer[1]</code> 是对 <code>nums</code> 尽可能执行上述操作后剩下的整数数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3,2,1,3,2,2]\n<strong>输出：</strong>[3,1]\n<strong>解释：</strong>\nnums[0] 和 nums[3] 形成一个数对，并从 nums 中移除，nums = [3,2,3,2,2] 。\nnums[0] 和 nums[2] 形成一个数对，并从 nums 中移除，nums = [2,2,2] 。\nnums[0] 和 nums[1] 形成一个数对，并从 nums 中移除，nums = [2] 。\n无法形成更多数对。总共形成 3 个数对，nums 中剩下 1 个数字。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1]\n<strong>输出：</strong>[1,0]\n<strong>解释：</strong>nums[0] 和 nums[1] 形成一个数对，并从 nums 中移除，nums = [] 。\n无法形成更多数对。总共形成 1 个数对，nums 中剩下 0 个数字。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0]\n<strong>输出：</strong>[0,1]\n<strong>解释：</strong>无法形成数对，nums 中剩下 1 个数字。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2342数位和相等数对的最大和",
        "hardRate": "MEDIUM",
        "passRate": "53.59%",
        "problemsUrl": "https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，数组中的元素都是 <strong>正</strong> 整数。请你选出两个下标 <code>i</code> 和 <code>j</code>（<code>i != j</code>），且 <code>nums[i]</code> 的数位和 与&nbsp; <code>nums[j]</code> 的数位和相等。</p>\n\n<p>请你找出所有满足条件的下标 <code>i</code> 和 <code>j</code> ，找出并返回<em> </em><code>nums[i] + nums[j]</code><em> </em>可以得到的 <strong>最大值</strong> <em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [18,43,36,13,7]\n<strong>输出：</strong>54\n<strong>解释：</strong>满足条件的数对 (i, j) 为：\n- (0, 2) ，两个数字的数位和都是 9 ，相加得到 18 + 36 = 54 。\n- (1, 4) ，两个数字的数位和都是 7 ，相加得到 43 + 7 = 50 。\n所以可以获得的最大和是 54 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,12,19,14]\n<strong>输出：</strong>-1\n<strong>解释：</strong>不存在满足条件的数对，返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2343裁剪数字后查询第 K 小的数字",
        "hardRate": "MEDIUM",
        "passRate": "41.33%",
        "problemsUrl": "https://leetcode.cn/problems/query-kth-smallest-trimmed-number/",
        "solutionsUrl": "https://leetcode.cn/problems/query-kth-smallest-trimmed-number/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串数组&nbsp;<code>nums</code>&nbsp;，其中每个字符串 <strong>长度相等</strong>&nbsp;且只包含数字。</p>\n\n<p>再给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>queries</code>&nbsp;，其中&nbsp;<code>queries[i] = [k<sub>i</sub>, trim<sub>i</sub>]</code>&nbsp;。对于每个&nbsp;<code>queries[i]</code>&nbsp;，你需要：</p>\n\n<ul>\n\t<li>将&nbsp;<code>nums</code>&nbsp;中每个数字 <strong>裁剪</strong>&nbsp;到剩下 <strong>最右边</strong>&nbsp;<code>trim<sub>i</sub></code>&nbsp;个数位。</li>\n\t<li>在裁剪过后的数字中，找到 <code>nums</code>&nbsp;中第&nbsp;<code>k<sub>i</sub></code>&nbsp;小数字对应的 <strong>下标</strong>&nbsp;。如果两个裁剪后数字一样大，那么下标 <strong>更小</strong>&nbsp;的数字视为更小的数字。</li>\n\t<li>将 <code>nums</code>&nbsp;中每个数字恢复到原本字符串。</li>\n</ul>\n\n<p>请你返回一个长度与 <code><span style=\"\">queries</span></code>&nbsp;相等的数组<em>&nbsp;</em><code>answer</code>，其中<em>&nbsp;</em><code>answer[i]</code>是第<em>&nbsp;</em><code>i</code><em>&nbsp;</em>次查询的结果。</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>裁剪到剩下最右边 <code>x</code>&nbsp;个数位的意思是不断删除最左边的数位，直到剩下 <code>x</code>&nbsp;个数位。</li>\n\t<li><code>nums</code>&nbsp;中的字符串可能会有前导 0 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [\"102\",\"473\",\"251\",\"814\"], queries = [[1,1],[2,3],[4,2],[1,2]]\n<b>输出：</b>[2,2,1,0]\n<strong>解释：</strong>\n1. 裁剪到只剩 1 个数位后，nums = [\"2\",\"3\",\"1\",\"4\"] 。最小的数字是 1 ，下标为 2 。\n2. 裁剪到剩 3 个数位后，nums 没有变化。第 2 小的数字是 251 ，下标为 2 。\n3. 裁剪到剩 2 个数位后，nums = [\"02\",\"73\",\"51\",\"14\"] 。第 4 小的数字是 73 ，下标为 1 。\n4. 裁剪到剩 2 个数位后，最小数字是 2 ，下标为 0 。\n   注意，裁剪后数字 \"02\" 值为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [\"24\",\"37\",\"96\",\"04\"], queries = [[2,1],[2,2]]\n<b>输出：</b>[3,0]\n<strong>解释：</strong>\n1. 裁剪到剩 1 个数位，nums = [\"4\",\"7\",\"6\",\"4\"] 。第 2 小的数字是 4 ，下标为 3 。\n   有两个 4 ，下标为 0 的 4 视为小于下标为 3 的 4 。\n2. 裁剪到剩 2 个数位，nums 不变。第二小的数字是 24 ，下标为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i].length &lt;= 100</code></li>\n\t<li><code>nums[i]</code> 只包含数字。</li>\n\t<li>所有&nbsp;<code>nums[i].length</code>&nbsp;的长度 <b>相同</b>&nbsp;。</li>\n\t<li><code>1 &lt;= queries.length &lt;= 100</code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>1 &lt;= k<sub>i</sub> &lt;= nums.length</code></li>\n\t<li><code>1 &lt;= trim<sub>i</sub> &lt;= nums[0].length</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能使用 <strong>基数排序算法</strong> 解决此问题吗？这种解法的复杂度又是多少？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2344使数组可以被整除的最少删除次数",
        "hardRate": "HARD",
        "passRate": "53.27%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-array-divisible/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-deletions-to-make-array-divisible/solution",
        "problemsDesc": "<p>给你两个正整数数组&nbsp;<code>nums</code> 和&nbsp;<code>numsDivide</code>&nbsp;。你可以从&nbsp;<code>nums</code>&nbsp;中删除任意数目的元素。</p>\n\n<p>请你返回使 <code>nums</code>&nbsp;中 <strong>最小</strong>&nbsp;元素可以整除 <code>numsDivide</code>&nbsp;中所有元素的 <strong>最少</strong>&nbsp;删除次数。如果无法得到这样的元素，返回 <code>-1</code>&nbsp;。</p>\n\n<p>如果&nbsp;<code>y % x == 0</code>&nbsp;，那么我们说整数&nbsp;<code>x</code>&nbsp;整除&nbsp;<code>y</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [2,3,2,4,3], numsDivide = [9,6,9,3,15]\n<b>输出：</b>2\n<b>解释：</b>\n[2,3,2,4,3] 中最小元素是 2 ，它无法整除 numsDivide 中所有元素。\n我们从 nums 中删除 2 个大小为 2 的元素，得到 nums = [3,4,3] 。\n[3,4,3] 中最小元素为 3 ，它可以整除 numsDivide 中所有元素。\n可以证明 2 是最少删除次数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [4,3,6], numsDivide = [8,2,6,10]\n<b>输出：</b>-1\n<b>解释：</b>\n我们想 nums 中的最小元素可以整除 numsDivide 中的所有元素。\n没有任何办法可以达到这一目的。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, numsDivide.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], numsDivide[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2345寻找可见山的数量",
        "hardRate": "MEDIUM",
        "passRate": "48.16%",
        "problemsUrl": "https://leetcode.cn/problems/finding-the-number-of-visible-mountains/",
        "solutionsUrl": "https://leetcode.cn/problems/finding-the-number-of-visible-mountains/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2346以百分比计算排名",
        "hardRate": "MEDIUM",
        "passRate": "37.49%",
        "problemsUrl": "https://leetcode.cn/problems/compute-the-rank-as-a-percentage/",
        "solutionsUrl": "https://leetcode.cn/problems/compute-the-rank-as-a-percentage/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2347最好的扑克手牌",
        "hardRate": "EASY",
        "passRate": "59.35%",
        "problemsUrl": "https://leetcode.cn/problems/best-poker-hand/",
        "solutionsUrl": "https://leetcode.cn/problems/best-poker-hand/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>ranks</code>&nbsp;和一个字符数组&nbsp;<code>suit</code>&nbsp;。你有&nbsp;<code>5</code>&nbsp;张扑克牌，第&nbsp;<code>i</code>&nbsp;张牌大小为&nbsp;<code>ranks[i]</code>&nbsp;，花色为&nbsp;<code>suits[i]</code>&nbsp;。</p>\n\n<p>下述是从好到坏你可能持有的 <strong>手牌类型&nbsp;</strong>：</p>\n\n<ol>\n\t<li><code>\"Flush\"</code>：同花，五张相同花色的扑克牌。</li>\n\t<li><code>\"Three of a Kind\"</code>：三条，有 3 张大小相同的扑克牌。</li>\n\t<li><code>\"Pair\"</code>：对子，两张大小一样的扑克牌。</li>\n\t<li><code>\"High Card\"</code>：高牌，五张大小互不相同的扑克牌。</li>\n</ol>\n\n<p>请你返回一个字符串，表示给定的 5 张牌中，你能组成的 <strong>最好手牌类型</strong>&nbsp;。</p>\n\n<p><strong>注意：</strong>返回的字符串&nbsp;<strong>大小写</strong>&nbsp;需与题目描述相同。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>ranks = [13,2,3,1,9], suits = [\"a\",\"a\",\"a\",\"a\",\"a\"]\n<b>输出：</b>\"Flush\"\n<b>解释：</b>5 张扑克牌的花色相同，所以返回 \"Flush\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>ranks = [4,4,2,4,4], suits = [\"d\",\"a\",\"a\",\"b\",\"c\"]\n<b>输出：</b>\"Three of a Kind\"\n<b>解释：</b>第一、二和四张牌组成三张相同大小的扑克牌，所以得到 \"Three of a Kind\" 。\n注意我们也可以得到 \"Pair\" ，但是 \"Three of a Kind\" 是更好的手牌类型。\n有其他的 3 张牌也可以组成 \"Three of a Kind\" 手牌类型。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>ranks = [10,10,2,12,9], suits = [\"a\",\"b\",\"c\",\"a\",\"d\"]\n<b>输出：</b>\"Pair\"\n<b>解释：</b>第一和第二张牌大小相同，所以得到 \"Pair\" 。\n我们无法得到 \"Flush\" 或者 \"Three of a Kind\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>ranks.length == suits.length == 5</code></li>\n\t<li><code>1 &lt;= ranks[i] &lt;= 13</code></li>\n\t<li><code>'a' &lt;= suits[i] &lt;= 'd'</code></li>\n\t<li>任意两张扑克牌不会同时有相同的大小和花色。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2348全 0 子数组的数目",
        "hardRate": "MEDIUM",
        "passRate": "56.33%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-zero-filled-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-zero-filled-subarrays/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;，返回全部为&nbsp;<code>0</code>&nbsp;的&nbsp;<strong>子数组</strong>&nbsp;数目。</p>\n\n<p><strong>子数组</strong>&nbsp;是一个数组中一段连续非空元素组成的序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,3,0,0,2,0,0,4]\n<b>输出：</b>6\n<b>解释：</b>\n子数组 [0] 出现了 4 次。\n子数组 [0,0] 出现了 2 次。\n不存在长度大于 2 的全 0 子数组，所以我们返回 6 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [0,0,0,2,0,0]\n<b>输出：</b>9\n<strong>解释：\n</strong>子数组 [0] 出现了 5 次。\n子数组 [0,0] 出现了 3 次。\n子数组 [0,0,0] 出现了 1 次。\n不存在长度大于 3 的全 0 子数组，所以我们返回 9 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [2,10,2019]\n<b>输出：</b>0\n<b>解释：</b>没有全 0 子数组，所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2349设计数字容器系统",
        "hardRate": "MEDIUM",
        "passRate": "37.29%",
        "problemsUrl": "https://leetcode.cn/problems/design-a-number-container-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-a-number-container-system/solution",
        "problemsDesc": "<p>设计一个数字容器系统，可以实现以下功能：</p>\n\n<ul>\n\t<li>在系统中给定下标处&nbsp;<strong>插入</strong>&nbsp;或者 <strong>替换</strong>&nbsp;一个数字。</li>\n\t<li><strong>返回</strong>&nbsp;系统中给定数字的最小下标。</li>\n</ul>\n\n<p>请你实现一个&nbsp;<code>NumberContainers</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>NumberContainers()</code>&nbsp;初始化数字容器系统。</li>\n\t<li><code>void change(int index, int number)</code> 在下标&nbsp;<code>index</code>&nbsp;处填入&nbsp;<code>number</code>&nbsp;。如果该下标&nbsp;<code>index</code>&nbsp;处已经有数字了，那么用 <code>number</code>&nbsp;替换该数字。</li>\n\t<li><code>int find(int number)</code>&nbsp;返回给定数字&nbsp;<code>number</code>&nbsp;在系统中的最小下标。如果系统中没有&nbsp;<code>number</code>&nbsp;，那么返回&nbsp;<code>-1</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"NumberContainers\", \"find\", \"change\", \"change\", \"change\", \"change\", \"find\", \"change\", \"find\"]\n[[], [10], [2, 10], [1, 10], [3, 10], [5, 10], [10], [1, 20], [10]]\n<strong>输出：</strong>\n[null, -1, null, null, null, null, 1, null, 2]\n\n<strong>解释：</strong>\nNumberContainers nc = new NumberContainers();\nnc.find(10); // 没有数字 10 ，所以返回 -1 。\nnc.change(2, 10); // 容器中下标为 2 处填入数字 10 。\nnc.change(1, 10); // 容器中下标为 1 处填入数字 10 。\nnc.change(3, 10); // 容器中下标为 3 处填入数字 10 。\nnc.change(5, 10); // 容器中下标为 5 处填入数字 10 。\nnc.find(10); // 数字 10 所在的下标为 1 ，2 ，3 和 5 。因为最小下标为 1 ，所以返回 1 。\nnc.change(1, 20); // 容器中下标为 1 处填入数字 20 。注意，下标 1 处之前为 10 ，现在被替换为 20 。\nnc.find(10); // 数字 10 所在下标为 2 ，3 和 5 。最小下标为 2 ，所以返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= index, number &lt;= 10<sup>9</sup></code></li>\n\t<li>调用&nbsp;<code>change</code> 和&nbsp;<code>find</code>&nbsp;的&nbsp;<strong>总次数</strong>&nbsp;不超过&nbsp;<code>10<sup>5</sup></code> 次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2350不可能得到的最短骰子序列",
        "hardRate": "HARD",
        "passRate": "64.80%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-impossible-sequence-of-rolls/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-impossible-sequence-of-rolls/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>rolls</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。你扔一个&nbsp;<code>k</code>&nbsp;面的骰子 <code>n</code>&nbsp;次，骰子的每个面分别是&nbsp;<code>1</code>&nbsp;到&nbsp;<code>k</code>&nbsp;，其中第&nbsp;<code>i</code>&nbsp;次扔得到的数字是&nbsp;<code>rolls[i]</code>&nbsp;。</p>\n\n<p>请你返回 <strong>无法</strong>&nbsp;从 <code>rolls</code>&nbsp;中得到的 <strong>最短</strong>&nbsp;骰子子序列的长度。</p>\n\n<p>扔一个 <code>k</code>&nbsp;面的骰子 <code>len</code>&nbsp;次得到的是一个长度为 <code>len</code>&nbsp;的 <strong>骰子子序列</strong>&nbsp;。</p>\n\n<p><strong>注意</strong>&nbsp;，子序列只需要保持在原数组中的顺序，不需要连续。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>rolls = [4,2,1,2,3,3,2,4,1], k = 4\n<b>输出：</b>3\n<b>解释：</b>所有长度为 1 的骰子子序列 [1] ，[2] ，[3] ，[4] 都可以从原数组中得到。\n所有长度为 2 的骰子子序列 [1, 1] ，[1, 2] ，... ，[4, 4] 都可以从原数组中得到。\n子序列 [1, 4, 2] 无法从原数组中得到，所以我们返回 3 。\n还有别的子序列也无法从原数组中得到。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>rolls = [1,1,2,2], k = 2\n<b>输出：</b>2\n<b>解释：</b>所有长度为 1 的子序列 [1] ，[2] 都可以从原数组中得到。\n子序列 [2, 1] 无法从原数组中得到，所以我们返回 2 。\n还有别的子序列也无法从原数组中得到，但 [2, 1] 是最短的子序列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>rolls = [1,1,3,2,2,2,3,3], k = 4\n<b>输出：</b>1\n<b>解释：</b>子序列 [4] 无法从原数组中得到，所以我们返回 1 。\n还有别的子序列也无法从原数组中得到，但 [4] 是最短的子序列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == rolls.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= rolls[i] &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2351第一个出现两次的字母",
        "hardRate": "EASY",
        "passRate": "84.80%",
        "problemsUrl": "https://leetcode.cn/problems/first-letter-to-appear-twice/",
        "solutionsUrl": "https://leetcode.cn/problems/first-letter-to-appear-twice/solution",
        "problemsDesc": "<p>给你一个由小写英文字母组成的字符串 <code>s</code> ，请你找出并返回第一个出现 <strong>两次</strong> 的字母。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>如果 <code>a</code> 的 <strong>第二次</strong> 出现比 <code>b</code> 的 <strong>第二次</strong> 出现在字符串中的位置更靠前，则认为字母 <code>a</code> 在字母 <code>b</code> 之前出现两次。</li>\n\t<li><code>s</code> 包含至少一个出现两次的字母。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abccbaacz\"\n<strong>输出：</strong>\"c\"\n<strong>解释：</strong>\n字母 'a' 在下标 0 、5 和 6 处出现。\n字母 'b' 在下标 1 和 4 处出现。\n字母 'c' 在下标 2 、3 和 7 处出现。\n字母 'z' 在下标 8 处出现。\n字母 'c' 是第一个出现两次的字母，因为在所有字母中，'c' 第二次出现的下标是最小的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abcdd\"\n<strong>输出：</strong>\"d\"\n<strong>解释：</strong>\n只有字母 'd' 出现两次，所以返回 'd' 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n\t<li><code>s</code> 包含至少一个重复字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2352相等行列对",
        "hardRate": "MEDIUM",
        "passRate": "74.03%",
        "problemsUrl": "https://leetcode.cn/problems/equal-row-and-column-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/equal-row-and-column-pairs/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>n x n</code> 的整数矩阵 <code>grid</code> ，返回满足 <code>R<sub>i</sub></code><em> </em>行和<em> </em><code>C<sub>j</sub></code><em> </em>列相等的行列对<em> </em><code>(R<sub>i</sub>, C<sub>j</sub>)</code><em> </em>的数目<em>。</em></p>\n\n<p>如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/01/ex1.jpg\" style=\"width: 150px; height: 153px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[3,2,1],[1,7,6],[2,7,7]]\n<strong>输出：</strong>1\n<strong>解释：</strong>存在一对相等行列对：\n- (第 2 行，第 1 列)：[2,7,7]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/01/ex2.jpg\" style=\"width: 200px; height: 209px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]\n<strong>输出：</strong>3\n<strong>解释：</strong>存在三对相等行列对：\n- (第 0 行，第 0 列)：[3,1,2,2]\n- (第 2 行, 第 2 列)：[2,4,2,2]\n- (第 3 行, 第 2 列)：[2,4,2,2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2353设计食物评分系统",
        "hardRate": "MEDIUM",
        "passRate": "30.69%",
        "problemsUrl": "https://leetcode.cn/problems/design-a-food-rating-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-a-food-rating-system/solution",
        "problemsDesc": "<p>设计一个支持下述操作的食物评分系统：</p>\n\n<ul>\n\t<li><strong>修改</strong> 系统中列出的某种食物的评分。</li>\n\t<li>返回系统中某一类烹饪方式下评分最高的食物。</li>\n</ul>\n\n<p>实现 <code>FoodRatings</code> 类：</p>\n\n<ul>\n\t<li><code>FoodRatings(String[] foods, String[] cuisines, int[] ratings)</code> 初始化系统。食物由 <code>foods</code>、<code>cuisines</code> 和 <code>ratings</code> 描述，长度均为 <code>n</code> 。\n\n\t<ul>\n\t\t<li><code>foods[i]</code> 是第 <code>i</code> 种食物的名字。</li>\n\t\t<li><code>cuisines[i]</code> 是第 <code>i</code> 种食物的烹饪方式。</li>\n\t\t<li><code>ratings[i]</code> 是第 <code>i</code> 种食物的最初评分。</li>\n\t</ul>\n\t</li>\n\t<li><code>void changeRating(String food, int newRating)</code> 修改名字为 <code>food</code> 的食物的评分。</li>\n\t<li><code>String highestRated(String cuisine)</code> 返回指定烹饪方式 <code>cuisine</code> 下评分最高的食物的名字。如果存在并列，返回 <strong>字典序较小</strong> 的名字。</li>\n</ul>\n\n<p>注意，字符串 <code>x</code> 的字典序比字符串 <code>y</code> 更小的前提是：<code>x</code> 在字典中出现的位置在 <code>y</code> 之前，也就是说，要么 <code>x</code> 是 <code>y</code> 的前缀，或者在满足&nbsp;<code>x[i] != y[i]</code> 的第一个位置 <code>i</code> 处，<code>x[i]</code> 在字母表中出现的位置在 <code>y[i]</code> 之前。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入</strong>\n[\"FoodRatings\", \"highestRated\", \"highestRated\", \"changeRating\", \"highestRated\", \"changeRating\", \"highestRated\"]\n[[[\"kimchi\", \"miso\", \"sushi\", \"moussaka\", \"ramen\", \"bulgogi\"], [\"korean\", \"japanese\", \"japanese\", \"greek\", \"japanese\", \"korean\"], [9, 12, 8, 15, 14, 7]], [\"korean\"], [\"japanese\"], [\"sushi\", 16], [\"japanese\"], [\"ramen\", 16], [\"japanese\"]]\n<strong>输出</strong>\n[null, \"kimchi\", \"ramen\", null, \"sushi\", null, \"ramen\"]\n\n<strong>解释</strong>\nFoodRatings foodRatings = new FoodRatings([\"kimchi\", \"miso\", \"sushi\", \"moussaka\", \"ramen\", \"bulgogi\"], [\"korean\", \"japanese\", \"japanese\", \"greek\", \"japanese\", \"korean\"], [9, 12, 8, 15, 14, 7]);\nfoodRatings.highestRated(\"korean\"); // 返回 \"kimchi\"\n                                    // \"kimchi\" 是分数最高的韩式料理，评分为 9 。\nfoodRatings.highestRated(\"japanese\"); // 返回 \"ramen\"\n                                      // \"ramen\" 是分数最高的日式料理，评分为 14 。\nfoodRatings.changeRating(\"sushi\", 16); // \"sushi\" 现在评分变更为 16 。\nfoodRatings.highestRated(\"japanese\"); // 返回 \"sushi\"\n                                      // \"sushi\" 是分数最高的日式料理，评分为 16 。\nfoodRatings.changeRating(\"ramen\", 16); // \"ramen\" 现在评分变更为 16 。\nfoodRatings.highestRated(\"japanese\"); // 返回 \"ramen\"\n                                      // \"sushi\" 和 \"ramen\" 的评分都是 16 。\n                                      // 但是，\"ramen\" 的字典序比 \"sushi\" 更小。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>n == foods.length == cuisines.length == ratings.length</code></li>\n\t<li><code>1 &lt;= foods[i].length, cuisines[i].length &lt;= 10</code></li>\n\t<li><code>foods[i]</code>、<code>cuisines[i]</code> 由小写英文字母组成</li>\n\t<li><code>1 &lt;= ratings[i] &lt;= 10<sup>8</sup></code></li>\n\t<li><code>foods</code> 中的所有字符串 <strong>互不相同</strong></li>\n\t<li>在对&nbsp;<code>changeRating</code> 的所有调用中，<code>food</code> 是系统中食物的名字。</li>\n\t<li>在对&nbsp;<code>highestRated</code> 的所有调用中，<code>cuisine</code> 是系统中 <strong>至少一种</strong> 食物的烹饪方式。</li>\n\t<li>最多调用 <code>changeRating</code> 和 <code>highestRated</code> <strong>总计</strong> <code>2 * 10<sup>4</sup></code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2354优质数对的数目",
        "hardRate": "HARD",
        "passRate": "44.57%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-excellent-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-excellent-pairs/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的正整数数组 <code>nums</code> 和一个正整数 <code>k</code> 。</p>\n\n<p>如果满足下述条件，则数对 <code>(num1, num2)</code> 是 <strong>优质数对</strong> ：</p>\n\n<ul>\n\t<li><code>num1</code> 和 <code>num2</code> <strong>都</strong> 在数组 <code>nums</code> 中存在。</li>\n\t<li><code>num1 OR num2</code> 和 <code>num1 AND num2</code> 的二进制表示中值为 <strong>1</strong> 的位数之和大于等于 <code>k</code> ，其中 <code>OR</code> 是按位 <strong>或</strong> 操作，而 <code>AND</code> 是按位 <strong>与</strong> 操作。</li>\n</ul>\n\n<p>返回 <strong>不同</strong> 优质数对的数目。</p>\n\n<p>如果&nbsp;<code>a != c</code> 或者 <code>b != d</code> ，则认为 <code>(a, b)</code> 和 <code>(c, d)</code> 是不同的两个数对。例如，<code>(1, 2)</code> 和 <code>(2, 1)</code> 不同。</p>\n\n<p><strong>注意：</strong>如果 <code>num1</code> 在数组中至少出现 <strong>一次</strong> ，则满足 <code>num1 == num2</code> 的数对 <code>(num1, num2)</code> 也可以是优质数对。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,1], k = 3\n<strong>输出：</strong>5\n<strong>解释：</strong>有如下几个优质数对：\n- (3, 3)：(3 AND 3) 和 (3 OR 3) 的二进制表示都等于 (11) 。值为 1 的位数和等于 2 + 2 = 4 ，大于等于 k = 3 。\n- (2, 3) 和 (3, 2)： (2 AND 3) 的二进制表示等于 (10) ，(2 OR 3) 的二进制表示等于 (11) 。值为 1 的位数和等于 1 + 2 = 3 。\n- (1, 3) 和 (3, 1)： (1 AND 3) 的二进制表示等于 (01) ，(1 OR 3) 的二进制表示等于 (11) 。值为 1 的位数和等于 1 + 2 = 3 。\n所以优质数对的数目是 5 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,1,1], k = 10\n<strong>输出：</strong>0\n<strong>解释：</strong>该数组中不存在优质数对。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 60</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2355你能拿走的最大图书数量",
        "hardRate": "HARD",
        "passRate": "58.92%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-books-you-can-take/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-books-you-can-take/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2356每位教师所教授的科目种类的数量",
        "hardRate": "EASY",
        "passRate": "80.91%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-unique-subjects-taught-by-each-teacher/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-unique-subjects-taught-by-each-teacher/solution",
        "problemsDesc": "<p>表: <code>Teacher</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| teacher_id  | int  |\n| subject_id  | int  |\n| dept_id     | int  |\n+-------------+------+\n(subject_id, dept_id) 是该表的主键。\n该表中的每一行都表示带有 teacher_id 的教师在系 dept_id 中教授科目 subject_id。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一个 SQL 来查询每位老师在大学里教授的科目种类的数量。</p>\n\n<p data-group=\"1-1\">以 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>查询结果格式示例如下。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nTeacher 表:\n+------------+------------+---------+\n| teacher_id | subject_id | dept_id |\n+------------+------------+---------+\n| 1          | 2          | 3       |\n| 1          | 2          | 4       |\n| 1          | 3          | 3       |\n| 2          | 1          | 1       |\n| 2          | 2          | 1       |\n| 2          | 3          | 1       |\n| 2          | 4          | 1       |\n+------------+------------+---------+\n<strong>输出:</strong>  \n+------------+-----+\n| teacher_id | cnt |\n+------------+-----+\n| 1          | 2   |\n| 2          | 4   |\n+------------+-----+\n<strong>解释:</strong> \n教师 1:\n  - 他在 3、4 系教科目 2。\n  - 他在 3 系教科目 3。\n教师 2:\n  - 他在 1 系教科目 1。\n  - 他在 1 系教科目 2。\n  - 他在 1 系教科目 3。\n  - 他在 1 系教科目 4。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2357使数组中所有元素都等于零",
        "hardRate": "EASY",
        "passRate": "75.87%",
        "problemsUrl": "https://leetcode.cn/problems/make-array-zero-by-subtracting-equal-amounts/",
        "solutionsUrl": "https://leetcode.cn/problems/make-array-zero-by-subtracting-equal-amounts/solution",
        "problemsDesc": "<p>给你一个非负整数数组 <code>nums</code> 。在一步操作中，你必须：</p>\n\n<ul>\n\t<li>选出一个正整数 <code>x</code> ，<code>x</code> 需要小于或等于 <code>nums</code> 中 <strong>最小</strong> 的 <strong>非零</strong> 元素。</li>\n\t<li><code>nums</code> 中的每个正整数都减去 <code>x</code>。</li>\n</ul>\n\n<p>返回使 <code>nums</code> 中所有元素都等于<em> </em><code>0</code> 需要的 <strong>最少</strong> 操作数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5,0,3,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n第一步操作：选出 x = 1 ，之后 nums = [0,4,0,2,4] 。\n第二步操作：选出 x = 2 ，之后 nums = [0,2,0,0,2] 。\n第三步操作：选出 x = 2 ，之后 nums = [0,0,0,0,0] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>0\n<strong>解释：</strong>nums 中的每个元素都已经是 0 ，所以不需要执行任何操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2358分组的最大数量",
        "hardRate": "MEDIUM",
        "passRate": "64.27%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-groups-entering-a-competition/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-groups-entering-a-competition/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>grades</code> ，表示大学中一些学生的成绩。你打算将 <strong>所有</strong> 学生分为一些 <strong>有序</strong> 的非空分组，其中分组间的顺序满足以下全部条件：</p>\n\n<ul>\n\t<li>第 <code>i</code> 个分组中的学生总成绩 <strong>小于</strong> 第 <code>(i + 1)</code> 个分组中的学生总成绩，对所有组均成立（除了最后一组）。</li>\n\t<li>第 <code>i</code> 个分组中的学生总数 <strong>小于</strong> 第 <code>(i + 1)</code> 个分组中的学生总数，对所有组均成立（除了最后一组）。</li>\n</ul>\n\n<p>返回可以形成的 <strong>最大</strong> 组数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>grades = [10,6,12,7,3,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>下面是形成 3 个分组的一种可行方法：\n- 第 1 个分组的学生成绩为 grades = [12] ，总成绩：12 ，学生数：1\n- 第 2 个分组的学生成绩为 grades = [6,7] ，总成绩：6 + 7 = 13 ，学生数：2\n- 第 3 个分组的学生成绩为 grades = [10,3,5] ，总成绩：10 + 3 + 5 = 18 ，学生数：3 \n可以证明无法形成超过 3 个分组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>grades = [8,8]\n<strong>输出：</strong>1\n<strong>解释：</strong>只能形成 1 个分组，因为如果要形成 2 个分组的话，会导致每个分组中的学生数目相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= grades.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= grades[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2359找到离给定两个节点最近的节点",
        "hardRate": "MEDIUM",
        "passRate": "30.25%",
        "problemsUrl": "https://leetcode.cn/problems/find-closest-node-to-given-two-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/find-closest-node-to-given-two-nodes/solution",
        "problemsDesc": "<p>给你一个 <code>n</code>&nbsp;个节点的 <strong>有向图</strong>&nbsp;，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，每个节点 <strong>至多</strong>&nbsp;有一条出边。</p>\n\n<p>有向图用大小为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>edges</code>&nbsp;表示，表示节点&nbsp;<code>i</code>&nbsp;有一条有向边指向&nbsp;<code>edges[i]</code>&nbsp;。如果节点&nbsp;<code>i</code>&nbsp;没有出边，那么&nbsp;<code>edges[i] == -1</code>&nbsp;。</p>\n\n<p>同时给你两个节点&nbsp;<code>node1</code> 和&nbsp;<code>node2</code>&nbsp;。</p>\n\n<p>请你返回一个从 <code>node1</code>&nbsp;和 <code>node2</code>&nbsp;都能到达节点的编号，使节点 <code>node1</code>&nbsp;和节点 <code>node2</code>&nbsp;到这个节点的距离 <b>较大值最小化</b>。如果有多个答案，请返回 <strong>最小</strong>&nbsp;的节点编号。如果答案不存在，返回 <code>-1</code>&nbsp;。</p>\n\n<p>注意&nbsp;<code>edges</code>&nbsp;可能包含环。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-2.png\" style=\"width: 321px; height: 161px;\"></p>\n\n<pre><b>输入：</b>edges = [2,2,3,-1], node1 = 0, node2 = 1\n<b>输出：</b>2\n<b>解释：</b>从节点 0 到节点 2 的距离为 1 ，从节点 1 到节点 2 的距离为 1 。\n两个距离的较大值为 1 。我们无法得到一个比 1 更小的较大值，所以我们返回节点 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-4.png\" style=\"width: 195px; height: 161px;\"></p>\n\n<pre><b>输入：</b>edges = [1,2,-1], node1 = 0, node2 = 2\n<b>输出：</b>2\n<b>解释：</b>节点 0 到节点 2 的距离为 2 ，节点 2 到它自己的距离为 0 。\n两个距离的较大值为 2 。我们无法得到一个比 2 更小的较大值，所以我们返回节点 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-1 &lt;= edges[i] &lt; n</code></li>\n\t<li><code>edges[i] != i</code></li>\n\t<li><code>0 &lt;= node1, node2 &lt; n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2360图中的最长环",
        "hardRate": "HARD",
        "passRate": "37.99%",
        "problemsUrl": "https://leetcode.cn/problems/longest-cycle-in-a-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-cycle-in-a-graph/solution",
        "problemsDesc": "<p>给你一个 <code>n</code>&nbsp;个节点的 <b>有向图</b>&nbsp;，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，其中每个节点&nbsp;<strong>至多</strong>&nbsp;有一条出边。</p>\n\n<p>图用一个大小为 <code>n</code>&nbsp;下标从<strong>&nbsp;0</strong>&nbsp;开始的数组&nbsp;<code>edges</code>&nbsp;表示，节点 <code>i</code>&nbsp;到节点&nbsp;<code>edges[i]</code>&nbsp;之间有一条有向边。如果节点&nbsp;<code>i</code>&nbsp;没有出边，那么&nbsp;<code>edges[i] == -1</code>&nbsp;。</p>\n\n<p>请你返回图中的 <strong>最长</strong>&nbsp;环，如果没有任何环，请返回 <code>-1</code>&nbsp;。</p>\n\n<p>一个环指的是起点和终点是 <strong>同一个</strong>&nbsp;节点的路径。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/08/graph4drawio-5.png\" style=\"width: 335px; height: 191px;\" /></p>\n\n<pre>\n<b>输入：</b>edges = [3,3,4,2,3]\n<b>输出去：</b>3\n<b>解释：</b>图中的最长环是：2 -&gt; 4 -&gt; 3 -&gt; 2 。\n这个环的长度为 3 ，所以返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-1.png\" style=\"width: 171px; height: 161px;\" /></p>\n\n<pre>\n<b>输入：</b>edges = [2,-1,3,1]\n<b>输出：</b>-1\n<b>解释：</b>图中没有任何环。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-1 &lt;= edges[i] &lt; n</code></li>\n\t<li><code>edges[i] != i</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2361乘坐火车路线的最少费用",
        "hardRate": "HARD",
        "passRate": "77.78%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-costs-using-the-train-line/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-costs-using-the-train-line/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2362生成发票",
        "hardRate": "HARD",
        "passRate": "72.93%",
        "problemsUrl": "https://leetcode.cn/problems/generate-the-invoice/",
        "solutionsUrl": "https://leetcode.cn/problems/generate-the-invoice/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2363合并相似的物品",
        "hardRate": "EASY",
        "passRate": "78.20%",
        "problemsUrl": "https://leetcode.cn/problems/merge-similar-items/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-similar-items/solution",
        "problemsDesc": "<p>给你两个二维整数数组&nbsp;<code>items1</code> 和&nbsp;<code>items2</code>&nbsp;，表示两个物品集合。每个数组&nbsp;<code>items</code>&nbsp;有以下特质：</p>\n\n<ul>\n\t<li><code>items[i] = [value<sub>i</sub>, weight<sub>i</sub>]</code> 其中&nbsp;<code>value<sub>i</sub></code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;件物品的&nbsp;<strong>价值</strong>&nbsp;，<code>weight<sub>i</sub></code>&nbsp;表示第 <code>i</code>&nbsp;件物品的 <strong>重量</strong>&nbsp;。</li>\n\t<li><code>items</code>&nbsp;中每件物品的价值都是 <strong>唯一的</strong>&nbsp;。</li>\n</ul>\n\n<p>请你返回一个二维数组&nbsp;<code>ret</code>，其中&nbsp;<code>ret[i] = [value<sub>i</sub>, weight<sub>i</sub>]</code>，&nbsp;<code>weight<sub>i</sub></code>&nbsp;是所有价值为&nbsp;<code>value<sub>i</sub></code><sub>&nbsp;</sub>物品的&nbsp;<strong>重量之和</strong>&nbsp;。</p>\n\n<p><strong>注意：</strong><code>ret</code>&nbsp;应该按价值 <strong>升序</strong>&nbsp;排序后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]]\n<b>输出：</b>[[1,6],[3,9],[4,5]]\n<b>解释：</b>\nvalue = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 5 ，总重量为 1 + 5 = 6 。\nvalue = 3 的物品再 items1 中 weight = 8 ，在 items2 中 weight = 1 ，总重量为 8 + 1 = 9 。\nvalue = 4 的物品在 items1 中 weight = 5 ，总重量为 5 。\n所以，我们返回 [[1,6],[3,9],[4,5]] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]]\n<b>输出：</b>[[1,4],[2,4],[3,4]]\n<b>解释：</b>\nvalue = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 3 ，总重量为 1 + 3 = 4 。\nvalue = 2 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 1 ，总重量为 3 + 1 = 4 。\nvalue = 3 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。\n所以，我们返回 [[1,4],[2,4],[3,4]] 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]]\n<b>输出：</b>[[1,7],[2,4],[7,1]]\n<strong>解释：\n</strong>value = 1 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 4 ，总重量为 3 + 4 = 7 。\nvalue = 2 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。\nvalue = 7 的物品在 items2 中 weight = 1 ，总重量为 1 。\n所以，我们返回 [[1,7],[2,4],[7,1]] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= items1.length, items2.length &lt;= 1000</code></li>\n\t<li><code>items1[i].length == items2[i].length == 2</code></li>\n\t<li><code>1 &lt;= value<sub>i</sub>, weight<sub>i</sub> &lt;= 1000</code></li>\n\t<li><code>items1</code>&nbsp;中每个 <code>value<sub>i</sub></code>&nbsp;都是 <b>唯一的</b>&nbsp;。</li>\n\t<li><code>items2</code>&nbsp;中每个 <code>value<sub>i</sub></code>&nbsp;都是 <b>唯一的</b>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2364统计坏数对的数目",
        "hardRate": "MEDIUM",
        "passRate": "42.22%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-bad-pairs/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-bad-pairs/solution",
        "problemsDesc": "<p>给你一个下标从<strong>&nbsp;0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。如果 <code>i &lt; j</code>&nbsp;且&nbsp;<code>j - i != nums[j] - nums[i]</code>&nbsp;，那么我们称&nbsp;<code>(i, j)</code>&nbsp;是一个 <strong>坏</strong><strong>数对</strong>&nbsp;。</p>\n\n<p>请你返回 <code>nums</code>&nbsp;中 <strong>坏数对</strong>&nbsp;的总数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [4,1,3,3]\n<b>输出：</b>5\n<b>解释：</b>数对 (0, 1) 是坏数对，因为 1 - 0 != 1 - 4 。\n数对 (0, 2) 是坏数对，因为 2 - 0 != 3 - 4, 2 != -1 。\n数对 (0, 3) 是坏数对，因为 3 - 0 != 3 - 4, 3 != -1 。\n数对 (1, 2) 是坏数对，因为 2 - 1 != 3 - 1, 1 != 2 。\n数对 (2, 3) 是坏数对，因为 3 - 2 != 3 - 3, 1 != 0 。\n总共有 5 个坏数对，所以我们返回 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4,5]\n<b>输出：</b>0\n<strong>解释：</strong>没有坏数对。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2365任务调度器 II",
        "hardRate": "MEDIUM",
        "passRate": "48.02%",
        "problemsUrl": "https://leetcode.cn/problems/task-scheduler-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/task-scheduler-ii/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的正整数数组&nbsp;<code>tasks</code>&nbsp;，表示需要 <strong>按顺序</strong>&nbsp;完成的任务，其中&nbsp;<code>tasks[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;件任务的 <strong>类型</strong>&nbsp;。</p>\n\n<p>同时给你一个正整数&nbsp;<code>space</code>&nbsp;，表示一个任务完成&nbsp;<strong>后</strong>&nbsp;，另一个&nbsp;<strong>相同</strong>&nbsp;类型任务完成前需要间隔的&nbsp;<strong>最少</strong>&nbsp;天数。</p>\n\n<p>在所有任务完成前的每一天，你都必须进行以下两种操作中的一种：</p>\n\n<ul>\n\t<li>完成&nbsp;<code>tasks</code>&nbsp;中的下一个任务</li>\n\t<li>休息一天</li>\n</ul>\n\n<p>请你返回完成所有任务所需的 <strong>最少</strong>&nbsp;天数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>tasks = [1,2,1,2,3,1], space = 3\n<b>输出：</b>9\n<strong>解释：</strong>\n9 天完成所有任务的一种方法是：\n第 1 天：完成任务 0 。\n第 2 天：完成任务 1 。\n第 3 天：休息。\n第 4 天：休息。\n第 5 天：完成任务 2 。\n第 6 天：完成任务 3 。\n第 7 天：休息。\n第 8 天：完成任务 4 。\n第 9 天：完成任务 5 。\n可以证明无法少于 9 天完成所有任务。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>tasks = [5,8,8,5], space = 2\n<b>输出：</b>6\n<strong>解释：</strong>\n6 天完成所有任务的一种方法是：\n第 1 天：完成任务 0 。\n第 2 天：完成任务 1 。\n第 3 天：休息。\n第 4 天：休息。\n第 5 天：完成任务 2 。\n第 6 天：完成任务 3 。\n可以证明无法少于 6 天完成所有任务。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tasks.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= tasks[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= space &lt;= tasks.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2366将数组排序的最少替换次数",
        "hardRate": "HARD",
        "passRate": "42.70%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-replacements-to-sort-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-replacements-to-sort-the-array/solution",
        "problemsDesc": "<p>给你一个下表从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。每次操作中，你可以将数组中任何一个元素替换为&nbsp;<strong>任意两个</strong>&nbsp;和为该元素的数字。</p>\n\n<ul>\n\t<li>比方说，<code>nums = [5,6,7]</code>&nbsp;。一次操作中，我们可以将&nbsp;<code>nums[1]</code> 替换成&nbsp;<code>2</code> 和&nbsp;<code>4</code>&nbsp;，将&nbsp;<code>nums</code>&nbsp;转变成&nbsp;<code>[5,2,4,7]</code>&nbsp;。</li>\n</ul>\n\n<p>请你执行上述操作，将数组变成元素按 <strong>非递减</strong> 顺序排列的数组，并返回所需的最少操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [3,9,3]\n<b>输出：</b>2\n<b>解释：</b>以下是将数组变成非递减顺序的步骤：\n- [3,9,3] ，将9 变成 3 和 6 ，得到数组 [3,3,6,3] \n- [3,3,6,3] ，将 6 变成 3 和 3 ，得到数组 [3,3,3,3,3] \n总共需要 2 步将数组变成非递减有序，所以我们返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,3,4,5]\n<b>输出：</b>0\n<b>解释：</b>数组已经是非递减顺序，所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2367算术三元组的数目",
        "hardRate": "EASY",
        "passRate": "83.38%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-arithmetic-triplets/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-arithmetic-triplets/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始、<strong>严格递增</strong> 的整数数组 <code>nums</code> 和一个正整数 <code>diff</code> 。如果满足下述全部条件，则三元组 <code>(i, j, k)</code> 就是一个 <strong>算术三元组</strong> ：</p>\n\n<ul>\n\t<li><code>i &lt; j &lt; k</code> ，</li>\n\t<li><code>nums[j] - nums[i] == diff</code> 且</li>\n\t<li><code>nums[k] - nums[j] == diff</code></li>\n</ul>\n\n<p>返回不同 <strong>算术三元组</strong> 的数目<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,4,6,7,10], diff = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>\n(1, 2, 4) 是算术三元组：7 - 4 == 3 且 4 - 1 == 3 。\n(2, 4, 5) 是算术三元组：10 - 7 == 3 且 7 - 4 == 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,5,6,7,8,9], diff = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>\n(0, 2, 4) 是算术三元组：8 - 6 == 2 且 6 - 4 == 2 。\n(1, 3, 5) 是算术三元组：9 - 7 == 2 且 7 - 5 == 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 200</code></li>\n\t<li><code>1 &lt;= diff &lt;= 50</code></li>\n\t<li><code>nums</code> <strong>严格</strong> 递增</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2368受限条件下可到达节点的数目",
        "hardRate": "MEDIUM",
        "passRate": "46.11%",
        "problemsUrl": "https://leetcode.cn/problems/reachable-nodes-with-restrictions/",
        "solutionsUrl": "https://leetcode.cn/problems/reachable-nodes-with-restrictions/solution",
        "problemsDesc": "<p>现有一棵由 <code>n</code> 个节点组成的无向树，节点编号从 <code>0</code> 到 <code>n - 1</code> ，共有 <code>n - 1</code> 条边。</p>\n\n<p>给你一个二维整数数组 <code>edges</code> ，长度为 <code>n - 1</code> ，其中 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示树中节点 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间存在一条边。另给你一个整数数组 <code>restricted</code> 表示 <strong>受限</strong> 节点。</p>\n\n<p>在不访问受限节点的前提下，返回你可以从节点<em> </em><code>0</code><em> </em>到达的 <strong>最多</strong> 节点数目<em>。</em></p>\n\n<p>注意，节点 <code>0</code> <strong>不</strong> 会标记为受限节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/15/ex1drawio.png\" style=\"width: 402px; height: 322px;\">\n<pre><strong>输入：</strong>n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>上图所示正是这棵树。\n在不访问受限节点的前提下，只有节点 [0,1,2,3] 可以从节点 0 到达。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/15/ex2drawio.png\" style=\"width: 412px; height: 312px;\">\n<pre><strong>输入：</strong>n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>上图所示正是这棵树。\n在不访问受限节点的前提下，只有节点 [0,5,6] 可以从节点 0 到达。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>edges</code> 表示一棵有效的树</li>\n\t<li><code>1 &lt;= restricted.length &lt; n</code></li>\n\t<li><code>1 &lt;= restricted[i] &lt; n</code></li>\n\t<li><code>restricted</code> 中的所有值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2369检查数组是否存在有效划分",
        "hardRate": "MEDIUM",
        "passRate": "38.39%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，你必须将数组划分为一个或多个 <strong>连续</strong> 子数组。</p>\n\n<p>如果获得的这些子数组中每个都能满足下述条件<strong> 之一</strong> ，则可以称其为数组的一种 <strong>有效</strong> 划分：</p>\n\n<ol>\n\t<li>子数组 <strong>恰</strong> 由 <code>2</code> 个相等元素组成，例如，子数组 <code>[2,2]</code> 。</li>\n\t<li>子数组 <strong>恰</strong> 由 <code>3</code> 个相等元素组成，例如，子数组 <code>[4,4,4]</code> 。</li>\n\t<li>子数组 <strong>恰</strong> 由 <code>3</code> 个连续递增元素组成，并且相邻元素之间的差值为 <code>1</code> 。例如，子数组 <code>[3,4,5]</code> ，但是子数组 <code>[1,3,5]</code> 不符合要求。</li>\n</ol>\n\n<p>如果数组 <strong>至少</strong> 存在一种有效划分，返回 <code>true</code><em> </em>，否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,4,4,5,6]\n<strong>输出：</strong>true\n<strong>解释：</strong>数组可以划分成子数组 [4,4] 和 [4,5,6] 。\n这是一种有效划分，所以返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,2]\n<strong>输出：</strong>false\n<strong>解释：</strong>该数组不存在有效划分。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2370最长理想子序列",
        "hardRate": "MEDIUM",
        "passRate": "43.07%",
        "problemsUrl": "https://leetcode.cn/problems/longest-ideal-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-ideal-subsequence/solution",
        "problemsDesc": "<p>给你一个由小写字母组成的字符串 <code>s</code> ，和一个整数 <code>k</code> 。如果满足下述条件，则可以将字符串 <code>t</code> 视作是 <strong>理想字符串</strong> ：</p>\n\n<ul>\n\t<li><code>t</code> 是字符串 <code>s</code> 的一个子序列。</li>\n\t<li><code>t</code> 中每两个 <strong>相邻</strong> 字母在字母表中位次的绝对差值小于或等于 <code>k</code> 。</li>\n</ul>\n\n<p>返回 <strong>最长</strong> 理想字符串的长度。</p>\n\n<p>字符串的子序列同样是一个字符串，并且子序列还满足：可以经由其他字符串删除某些字符（也可以不删除）但不改变剩余字符的顺序得到。</p>\n\n<p><strong>注意：</strong>字母表顺序不会循环。例如，<code>'a'</code> 和 <code>'z'</code> 在字母表中位次的绝对差值是 <code>25</code> ，而不是 <code>1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"acfgbd\", k = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>最长理想字符串是 \"acbd\" 。该字符串长度为 4 ，所以返回 4 。\n注意 \"acfgbd\" 不是理想字符串，因为 'c' 和 'f' 的字母表位次差值为 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\", k = 3\n<strong>输出：</strong>4\n<strong>解释：</strong>最长理想字符串是 \"abcd\" ，该字符串长度为 4 ，所以返回 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 25</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2371最小化网格中的最大值",
        "hardRate": "HARD",
        "passRate": "74.28%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-maximum-value-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-maximum-value-in-a-grid/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2372计算每个销售人员的影响力",
        "hardRate": "MEDIUM",
        "passRate": "77.79%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-the-influence-of-each-salesperson/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-the-influence-of-each-salesperson/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2373矩阵中的局部最大值",
        "hardRate": "EASY",
        "passRate": "85.21%",
        "problemsUrl": "https://leetcode.cn/problems/largest-local-values-in-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-local-values-in-a-matrix/solution",
        "problemsDesc": "<p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>grid</code> 。</p>\n\n<p>生成一个大小为&nbsp;<code>(n - 2) x (n - 2)</code> 的整数矩阵&nbsp; <code>maxLocal</code> ，并满足：</p>\n\n<ul>\n\t<li><code>maxLocal[i][j]</code> 等于 <code>grid</code> 中以 <code>i + 1</code> 行和 <code>j + 1</code> 列为中心的 <code>3 x 3</code> 矩阵中的 <strong>最大值</strong> 。</li>\n</ul>\n\n<p>换句话说，我们希望找出 <code>grid</code> 中每个&nbsp;<code>3 x 3</code> 矩阵中的最大值。</p>\n\n<p>返回生成的矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/21/ex1.png\" style=\"width: 371px; height: 210px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]\n<strong>输出：</strong>[[9,9],[8,6]]\n<strong>解释：</strong>原矩阵和生成的矩阵如上图所示。\n注意，生成的矩阵中，每个值都对应 grid 中一个相接的 3 x 3 矩阵的最大值。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/02/ex2new2.png\" style=\"width: 436px; height: 240px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]\n<strong>输出：</strong>[[2,2,2],[2,2,2],[2,2,2]]\n<strong>解释：</strong>注意，2 包含在 grid 中每个 3 x 3 的矩阵中。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>3 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2374边积分最高的节点",
        "hardRate": "MEDIUM",
        "passRate": "42.32%",
        "problemsUrl": "https://leetcode.cn/problems/node-with-highest-edge-score/",
        "solutionsUrl": "https://leetcode.cn/problems/node-with-highest-edge-score/solution",
        "problemsDesc": "<p>给你一个有向图，图中有 <code>n</code> 个节点，节点编号从 <code>0</code> 到 <code>n - 1</code> ，其中每个节点都 <strong>恰有一条</strong> 出边。</p>\n\n<p>图由一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>edges</code> 表示，其中 <code>edges[i]</code> 表示存在一条从节点 <code>i</code> 到节点 <code>edges[i]</code> 的 <strong>有向</strong> 边。</p>\n\n<p>节点 <code>i</code> 的 <strong>边积分</strong> 定义为：所有存在一条指向节点 <code>i</code> 的边的节点的 <strong>编号</strong> 总和。</p>\n\n<p>返回 <strong>边积分</strong> 最高的节点。如果多个节点的 <strong>边积分</strong> 相同，返回编号 <strong>最小</strong> 的那个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/06/20/image-20220620195403-1.png\" style=\"width: 450px; height: 260px;\">\n<pre><strong>输入：</strong>edges = [1,0,0,0,0,7,7,5]\n<strong>输出：</strong>7\n<strong>解释：</strong>\n- 节点 1、2、3 和 4 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 + 3 + 4 = 10 。\n- 节点 0 有一条指向节点 1 的边，节点 1 的边积分等于 0 。\n- 节点 7 有一条指向节点 5 的边，节点 5 的边积分等于 7 。\n- 节点 5 和 6 都有指向节点 7 的边，节点 7 的边积分等于 5 + 6 = 11 。\n节点 7 的边积分最高，所以返回 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/06/20/image-20220620200212-3.png\" style=\"width: 150px; height: 155px;\">\n<pre><strong>输入：</strong>edges = [2,0,0,2]\n<strong>输出：</strong>0\n<strong>解释：\n</strong>- 节点 1 和 2 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 = 3 。\n- 节点 0 和 3 都有指向节点 2 的边，节点 2 的边积分等于 0 + 3 = 3 。\n节点 0 和 2 的边积分都是 3 。由于节点 0 的编号更小，返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= edges[i] &lt; n</code></li>\n\t<li><code>edges[i] != i</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2375根据模式串构造最小数字",
        "hardRate": "MEDIUM",
        "passRate": "69.96%",
        "problemsUrl": "https://leetcode.cn/problems/construct-smallest-number-from-di-string/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-smallest-number-from-di-string/solution",
        "problemsDesc": "<p>给你下标从 <strong>0</strong> 开始、长度为 <code>n</code>&nbsp;的字符串&nbsp;<code>pattern</code>&nbsp;，它包含两种字符，<code>'I'</code>&nbsp;表示 <strong>上升</strong>&nbsp;，<code>'D'</code>&nbsp;表示 <strong>下降</strong>&nbsp;。</p>\n\n<p>你需要构造一个下标从 <strong>0</strong>&nbsp;开始长度为&nbsp;<code>n + 1</code>&nbsp;的字符串，且它要满足以下条件：</p>\n\n<ul>\n\t<li><code>num</code>&nbsp;包含数字&nbsp;<code>'1'</code>&nbsp;到&nbsp;<code>'9'</code>&nbsp;，其中每个数字&nbsp;<strong>至多</strong>&nbsp;使用一次。</li>\n\t<li>如果&nbsp;<code>pattern[i] == 'I'</code>&nbsp;，那么&nbsp;<code>num[i] &lt; num[i + 1]</code>&nbsp;。</li>\n\t<li>如果&nbsp;<code>pattern[i] == 'D'</code>&nbsp;，那么&nbsp;<code>num[i] &gt; num[i + 1]</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回满足上述条件字典序 <strong>最小</strong>&nbsp;的字符串<em>&nbsp;</em><code>num</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>pattern = \"IIIDIDDD\"\n<b>输出：</b>\"123549876\"\n<strong>解释：\n</strong>下标 0 ，1 ，2 和 4 处，我们需要使 num[i] &lt; num[i+1] 。\n下标 3 ，5 ，6 和 7 处，我们需要使 num[i] &gt; num[i+1] 。\n一些可能的 num 的值为 \"245639871\" ，\"135749862\" 和 \"123849765\" 。\n\"123549876\" 是满足条件最小的数字。\n注意，\"123414321\" 不是可行解因为数字 '1' 使用次数超过 1 次。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>pattern = \"DDD\"\n<b>输出：</b>\"4321\"\n<strong>解释：</strong>\n一些可能的 num 的值为 \"9876\" ，\"7321\" 和 \"8742\" 。\n\"4321\" 是满足条件最小的数字。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pattern.length &lt;= 8</code></li>\n\t<li><code>pattern</code>&nbsp;只包含字符&nbsp;<code>'I'</code> 和&nbsp;<code>'D'</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2376统计特殊整数",
        "hardRate": "HARD",
        "passRate": "51.62%",
        "problemsUrl": "https://leetcode.cn/problems/count-special-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/count-special-integers/solution",
        "problemsDesc": "<p>如果一个正整数每一个数位都是 <strong>互不相同</strong>&nbsp;的，我们称它是 <strong>特殊整数</strong> 。</p>\n\n<p>给你一个 <strong>正</strong>&nbsp;整数&nbsp;<code>n</code>&nbsp;，请你返回区间<em>&nbsp;</em><code>[1, n]</code>&nbsp;之间特殊整数的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>n = 20\n<b>输出：</b>19\n<b>解释：</b>1 到 20 之间所有整数除了 11 以外都是特殊整数。所以总共有 19 个特殊整数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>n = 5\n<b>输出：</b>5\n<b>解释：</b>1 到 5 所有整数都是特殊整数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>n = 135\n<b>输出：</b>110\n<b>解释：</b>从 1 到 135 总共有 110 个整数是特殊整数。\n不特殊的部分数字为：22 ，114 和 131 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2377整理奥运表",
        "hardRate": "EASY",
        "passRate": "80.00%",
        "problemsUrl": "https://leetcode.cn/problems/sort-the-olympic-table/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-the-olympic-table/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2378选择边来最大化树的得分",
        "hardRate": "MEDIUM",
        "passRate": "68.37%",
        "problemsUrl": "https://leetcode.cn/problems/choose-edges-to-maximize-score-in-a-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/choose-edges-to-maximize-score-in-a-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2379得到 K 个黑块的最少涂色次数",
        "hardRate": "EASY",
        "passRate": "61.75%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>blocks</code>&nbsp;，<code>blocks[i]</code>&nbsp;要么是&nbsp;<code>'W'</code>&nbsp;要么是&nbsp;<code>'B'</code>&nbsp;，表示第&nbsp;<code>i</code>&nbsp;块的颜色。字符&nbsp;<code>'W'</code> 和&nbsp;<code>'B'</code>&nbsp;分别表示白色和黑色。</p>\n\n<p>给你一个整数&nbsp;<code>k</code>&nbsp;，表示想要&nbsp;<strong>连续</strong>&nbsp;黑色块的数目。</p>\n\n<p>每一次操作中，你可以选择一个白色块将它 <strong>涂成</strong>&nbsp;黑色块。</p>\n\n<p>请你返回至少出现 <strong>一次</strong>&nbsp;连续 <code>k</code>&nbsp;个黑色块的 <strong>最少</strong>&nbsp;操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>blocks = \"WBBWWBBWBW\", k = 7\n<b>输出：</b>3\n<strong>解释：</strong>\n一种得到 7 个连续黑色块的方法是把第 0 ，3 和 4 个块涂成黑色。\n得到 blocks = \"BBBBBBBWBW\" 。\n可以证明无法用少于 3 次操作得到 7 个连续的黑块。\n所以我们返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>blocks = \"WBWBBBW\", k = 2\n<b>输出：</b>0\n<strong>解释：</strong>\n不需要任何操作，因为已经有 2 个连续的黑块。\n所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>n == blocks.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>blocks[i]</code>&nbsp;要么是&nbsp;<code>'W'</code>&nbsp;，要么是&nbsp;<code>'B'</code> 。</li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2380二进制字符串重新安排顺序需要的时间",
        "hardRate": "MEDIUM",
        "passRate": "56.15%",
        "problemsUrl": "https://leetcode.cn/problems/time-needed-to-rearrange-a-binary-string/",
        "solutionsUrl": "https://leetcode.cn/problems/time-needed-to-rearrange-a-binary-string/solution",
        "problemsDesc": "<p>给你一个二进制字符串&nbsp;<code>s</code>&nbsp;。在一秒之中，<strong>所有</strong>&nbsp;子字符串&nbsp;<code>\"01\"</code> <strong>同时</strong>&nbsp;被替换成&nbsp;<code>\"10\"</code>&nbsp;。这个过程持续进行到没有&nbsp;<code>\"01\"</code>&nbsp;存在。</p>\n\n<p>请你返回完成这个过程所需要的秒数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"0110101\"\n<b>输出：</b>4\n<b>解释：</b>\n一秒后，s 变成 \"1011010\" 。\n再过 1 秒后，s 变成 \"1101100\" 。\n第三秒过后，s 变成 \"1110100\" 。\n第四秒后，s 变成 \"1111000\" 。\n此时没有 \"01\" 存在，整个过程花费 4 秒。\n所以我们返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"11100\"\n<b>输出：</b>0\n<strong>解释：</strong>\ns 中没有 \"01\" 存在，整个过程花费 0 秒。\n所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i]</code>&nbsp;要么是&nbsp;<code>'0'</code>&nbsp;，要么是&nbsp;<code>'1'</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<p>你能以 O(n) 的时间复杂度解决这个问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2381字母移位 II",
        "hardRate": "MEDIUM",
        "passRate": "36.86%",
        "problemsUrl": "https://leetcode.cn/problems/shifting-letters-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/shifting-letters-ii/solution",
        "problemsDesc": "<p>给你一个小写英文字母组成的字符串&nbsp;<code>s</code>&nbsp;和一个二维整数数组&nbsp;<code>shifts</code>&nbsp;，其中&nbsp;<code>shifts[i] = [start<sub>i</sub>, end<sub>i</sub>, direction<sub>i</sub>]</code>&nbsp;。对于每个&nbsp;<code>i</code>&nbsp;，将&nbsp;<code>s</code>&nbsp;中从下标&nbsp;<code>start<sub>i</sub></code>&nbsp;到下标&nbsp;<code>end<sub>i</sub></code>&nbsp;（两者都包含）所有字符都进行移位运算，如果&nbsp;<code>direction<sub>i</sub> = 1</code>&nbsp;将字符向后移位，如果&nbsp;<code>direction<sub>i</sub> = 0</code>&nbsp;将字符向前移位。</p>\n\n<p>将一个字符 <strong>向后</strong>&nbsp;移位的意思是将这个字符用字母表中 <strong>下一个</strong>&nbsp;字母替换（字母表视为环绕的，所以&nbsp;<code>'z'</code>&nbsp;变成&nbsp;<code>'a'</code>）。类似的，将一个字符 <strong>向前</strong>&nbsp;移位的意思是将这个字符用字母表中 <strong>前一个</strong>&nbsp;字母替换（字母表是环绕的，所以&nbsp;<code>'a'</code>&nbsp;变成&nbsp;<code>'z'</code>&nbsp;）。</p>\n\n<p>请你返回对 <code>s</code>&nbsp;进行所有移位操作以后得到的最终字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"abc\", shifts = [[0,1,0],[1,2,1],[0,2,1]]\n<b>输出：</b>\"ace\"\n<b>解释：</b>首先，将下标从 0 到 1 的字母向前移位，得到 s = \"zac\" 。\n然后，将下标从 1 到 2 的字母向后移位，得到 s = \"zbd\" 。\n最后，将下标从 0 到 2 的字符向后移位，得到 s = \"ace\" 。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><b>输入：</b>s = \"dztz\", shifts = [[0,0,0],[1,1,1]]\n<b>输出：</b>\"catz\"\n<b>解释：</b>首先，将下标从 0 到 0 的字母向前移位，得到 s = \"cztz\" 。\n最后，将下标从 1 到 1 的字符向后移位，得到 s = \"catz\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, shifts.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>shifts[i].length == 3</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt; s.length</code></li>\n\t<li><code>0 &lt;= direction<sub>i</sub> &lt;= 1</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2382删除操作后的最大子段和",
        "hardRate": "HARD",
        "passRate": "56.36%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-segment-sum-after-removals/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-segment-sum-after-removals/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code> 和&nbsp;<code>removeQueries</code>&nbsp;，两者长度都为&nbsp;<code>n</code>&nbsp;。对于第&nbsp;<code>i</code>&nbsp;个查询，<code>nums</code>&nbsp;中位于下标&nbsp;<code>removeQueries[i]</code>&nbsp;处的元素被删除，将 <code>nums</code>&nbsp;分割成更小的子段。</p>\n\n<p>一个 <strong>子段</strong>&nbsp;是 <code>nums</code>&nbsp;中连续 <strong>正</strong>&nbsp;整数形成的序列。<strong>子段和</strong>&nbsp;是子段中所有元素的和。</p>\n\n<p>请你返回一个长度为 <code>n</code>&nbsp;的整数数组<em>&nbsp;</em><code>answer</code>&nbsp;，其中<em>&nbsp;</em><code>answer[i]</code>是第&nbsp;<code>i</code>&nbsp;次删除操作以后的&nbsp;<strong>最大</strong>&nbsp;子段和。</p>\n\n<p><strong>注意：</strong>一个下标至多只会被删除一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]\n<b>输出：</b>[14,7,2,2,0]\n<b>解释：</b>用 0 表示被删除的元素，答案如下所示：\n查询 1 ：删除第 0 个元素，nums 变成 [0,2,5,6,1] ，最大子段和为子段 [2,5,6,1] 的和 14 。\n查询 2 ：删除第 3 个元素，nums 变成 [0,2,5,0,1] ，最大子段和为子段 [2,5] 的和 7 。\n查询 3 ：删除第 2 个元素，nums 变成 [0,2,0,0,1] ，最大子段和为子段 [2] 的和 2 。\n查询 4 ：删除第 4 个元素，nums 变成 [0,2,0,0,0] ，最大子段和为子段 [2] 的和 2 。\n查询 5 ：删除第 1 个元素，nums 变成 [0,0,0,0,0] ，最大子段和为 0 ，因为没有任何子段存在。\n所以，我们返回 [14,7,2,2,0] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [3,2,11,1], removeQueries = [3,2,1,0]\n<b>输出：</b>[16,5,3,0]\n<b>解释：</b>用 0 表示被删除的元素，答案如下所示：\n查询 1 ：删除第 3 个元素，nums 变成 [3,2,11,0] ，最大子段和为子段 [3,2,11] 的和 16 。\n查询 2 ：删除第 2 个元素，nums 变成 [3,2,0,0] ，最大子段和为子段 [3,2] 的和 5 。\n查询 3 ：删除第 1 个元素，nums 变成 [3,0,0,0] ，最大子段和为子段 [3] 的和 3 。\n查询 5 ：删除第 0 个元素，nums 变成 [0,0,0,0] ，最大子段和为 0 ，因为没有任何子段存在。\n所以，我们返回 [16,5,3,0] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length == removeQueries.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= removeQueries[i] &lt; n</code></li>\n\t<li><code>removeQueries</code>&nbsp;中所有数字 <strong>互不相同</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2383赢得比赛需要的最少训练时长",
        "hardRate": "EASY",
        "passRate": "47.19%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition/solution",
        "problemsDesc": "<p>你正在参加一场比赛，给你两个 <strong>正</strong> 整数 <code>initialEnergy</code> 和 <code>initialExperience</code> 分别表示你的初始精力和初始经验。</p>\n\n<p>另给你两个下标从 <strong>0</strong> 开始的整数数组 <code>energy</code> 和 <code>experience</code>，长度均为 <code>n</code> 。</p>\n\n<p>你将会 <strong>依次</strong> 对上 <code>n</code> 个对手。第 <code>i</code> 个对手的精力和经验分别用 <code>energy[i]</code> 和 <code>experience[i]</code> 表示。当你对上对手时，需要在经验和精力上都 <strong>严格</strong> 超过对手才能击败他们，然后在可能的情况下继续对上下一个对手。</p>\n\n<p>击败第 <code>i</code> 个对手会使你的经验 <strong>增加</strong> <code>experience[i]</code>，但会将你的精力 <strong>减少</strong>&nbsp; <code>energy[i]</code> 。</p>\n\n<p>在开始比赛前，你可以训练几个小时。每训练一个小时，你可以选择将增加经验增加 1 <strong>或者</strong> 将精力增加 1 。</p>\n\n<p>返回击败全部 <code>n</code> 个对手需要训练的 <strong>最少</strong> 小时数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]\n<strong>输出：</strong>8\n<strong>解释：</strong>在 6 小时训练后，你可以将精力提高到 11 ，并且再训练 2 个小时将经验提高到 5 。\n按以下顺序与对手比赛：\n- 你的精力与经验都超过第 0 个对手，所以获胜。\n  精力变为：11 - 1 = 10 ，经验变为：5 + 2 = 7 。\n- 你的精力与经验都超过第 1 个对手，所以获胜。\n  精力变为：10 - 4 = 6 ，经验变为：7 + 6 = 13 。\n- 你的精力与经验都超过第 2 个对手，所以获胜。\n  精力变为：6 - 3 = 3 ，经验变为：13 + 3 = 16 。\n- 你的精力与经验都超过第 3 个对手，所以获胜。\n  精力变为：3 - 2 = 1 ，经验变为：16 + 1 = 17 。\n在比赛前进行了 8 小时训练，所以返回 8 。\n可以证明不存在更小的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>initialEnergy = 2, initialExperience = 4, energy = [1], experience = [3]\n<strong>输出：</strong>0\n<strong>解释：</strong>你不需要额外的精力和经验就可以赢得比赛，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == energy.length == experience.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= initialEnergy, initialExperience, energy[i], experience[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2384最大回文数字",
        "hardRate": "MEDIUM",
        "passRate": "31.06%",
        "problemsUrl": "https://leetcode.cn/problems/largest-palindromic-number/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-palindromic-number/solution",
        "problemsDesc": "<p>给你一个仅由数字（<code>0 - 9</code>）组成的字符串 <code>num</code> 。</p>\n\n<p>请你找出能够使用 <code>num</code> 中数字形成的 <strong>最大回文</strong> 整数，并以字符串形式返回。该整数不含 <strong>前导零</strong> 。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>你 <strong>无需</strong> 使用 <code>num</code> 中的所有数字，但你必须使用 <strong>至少</strong> 一个数字。</li>\n\t<li>数字可以重新排序。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"444947137\"\n<strong>输出：</strong>\"7449447\"\n<strong>解释：</strong>\n从 \"<em><strong>44494</strong></em><em><strong>7</strong></em>13<em><strong>7</strong></em>\" 中选用数字 \"4449477\"，可以形成回文整数 \"7449447\" 。\n可以证明 \"7449447\" 是能够形成的最大回文整数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"00009\"\n<strong>输出：</strong>\"9\"\n<strong>解释：</strong>\n可以证明 \"9\" 能够形成的最大回文整数。\n注意返回的整数不应含前导零。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>num</code> 由数字（<code>0 - 9</code>）组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2385感染二叉树需要的总时间",
        "hardRate": "MEDIUM",
        "passRate": "46.19%",
        "problemsUrl": "https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/",
        "solutionsUrl": "https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点 <code>root</code> ，二叉树中节点的值 <strong>互不相同</strong> 。另给你一个整数 <code>start</code> 。在第 <code>0</code> 分钟，<strong>感染</strong> 将会从值为 <code>start</code> 的节点开始爆发。</p>\n\n<p>每分钟，如果节点满足以下全部条件，就会被感染：</p>\n\n<ul>\n\t<li>节点此前还没有感染。</li>\n\t<li>节点与一个已感染节点相邻。</li>\n</ul>\n\n<p>返回感染整棵树需要的分钟数<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/25/image-20220625231744-1.png\" style=\"width: 400px; height: 306px;\">\n<pre><strong>输入：</strong>root = [1,5,3,null,4,10,6,9,2], start = 3\n<strong>输出：</strong>4\n<strong>解释：</strong>节点按以下过程被感染：\n- 第 0 分钟：节点 3\n- 第 1 分钟：节点 1、10、6\n- 第 2 分钟：节点5\n- 第 3 分钟：节点 4\n- 第 4 分钟：节点 9 和 2\n感染整棵树需要 4 分钟，所以返回 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/25/image-20220625231812-2.png\" style=\"width: 75px; height: 66px;\">\n<pre><strong>输入：</strong>root = [1], start = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>第 0 分钟，树中唯一一个节点处于感染状态，返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li>每个节点的值 <strong>互不相同</strong></li>\n\t<li>树中必定存在值为 <code>start</code> 的节点</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2386找出数组的第 K 大和",
        "hardRate": "HARD",
        "passRate": "42.31%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-k-sum-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-k-sum-of-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个 <strong>正</strong> 整数 <code>k</code> 。你可以选择数组的任一 <strong>子序列</strong> 并且对其全部元素求和。</p>\n\n<p>数组的 <strong>第 k 大和</strong> 定义为：可以获得的第 <code>k</code> 个 <strong>最大</strong> 子序列和（子序列和允许出现重复）</p>\n\n<p>返回数组的 <strong>第 k 大和</strong> 。</p>\n\n<p>子序列是一个可以由其他数组删除某些或不删除元素排生而来的数组，且派生过程不改变剩余元素的顺序。</p>\n\n<p><strong>注意：</strong>空子序列的和视作 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,4,-2], k = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>所有可能获得的子序列和列出如下，按递减顺序排列：\n- 6、4、4、2、<strong><em>2</em></strong>、0、0、-2\n数组的第 5 大和是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,-2,3,4,-10,12], k = 16\n<strong>输出：</strong>10\n<strong>解释：</strong>数组的第 16 大和是 10 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= min(2000, 2<sup>n</sup>)</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2387行排序矩阵的中位数",
        "hardRate": "MEDIUM",
        "passRate": "76.22%",
        "problemsUrl": "https://leetcode.cn/problems/median-of-a-row-wise-sorted-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/median-of-a-row-wise-sorted-matrix/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2388将表中的空值更改为前一个值",
        "hardRate": "MEDIUM",
        "passRate": "67.76%",
        "problemsUrl": "https://leetcode.cn/problems/change-null-values-in-a-table-to-the-previous-value/",
        "solutionsUrl": "https://leetcode.cn/problems/change-null-values-in-a-table-to-the-previous-value/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2389和有限的最长子序列",
        "hardRate": "EASY",
        "passRate": "70.95%",
        "problemsUrl": "https://leetcode.cn/problems/longest-subsequence-with-limited-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-subsequence-with-limited-sum/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;的整数数组 <code>nums</code> ，和一个长度为 <code>m</code> 的整数数组 <code>queries</code> 。</p>\n\n<p>返回一个长度为 <code>m</code> 的数组<em> </em><code>answer</code><em> </em>，其中<em> </em><code>answer[i]</code><em> </em>是 <code>nums</code> 中<span style=\"\"> </span>元素之和小于等于 <code>queries[i]</code> 的 <strong>子序列</strong> 的 <strong>最大</strong> 长度<span style=\"\">&nbsp;</span><span style=\"\"> </span>。</p>\n\n<p><strong>子序列</strong> 是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,5,2,1], queries = [3,10,21]\n<strong>输出：</strong>[2,3,4]\n<strong>解释：</strong>queries 对应的 answer 如下：\n- 子序列 [2,1] 的和小于或等于 3 。可以证明满足题目要求的子序列的最大长度是 2 ，所以 answer[0] = 2 。\n- 子序列 [4,5,1] 的和小于或等于 10 。可以证明满足题目要求的子序列的最大长度是 3 ，所以 answer[1] = 3 。\n- 子序列 [4,5,2,1] 的和小于或等于 21 。可以证明满足题目要求的子序列的最大长度是 4 ，所以 answer[2] = 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,4,5], queries = [1]\n<strong>输出：</strong>[0]\n<strong>解释：</strong>空子序列是唯一一个满足元素和小于或等于 1 的子序列，所以 answer[0] = 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>m == queries.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i], queries[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2390从字符串中移除星号",
        "hardRate": "MEDIUM",
        "passRate": "69.22%",
        "problemsUrl": "https://leetcode.cn/problems/removing-stars-from-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/removing-stars-from-a-string/solution",
        "problemsDesc": "<p>给你一个包含若干星号 <code>*</code> 的字符串 <code>s</code> 。</p>\n\n<p>在一步操作中，你可以：</p>\n\n<ul>\n\t<li>选中 <code>s</code> 中的一个星号。</li>\n\t<li>移除星号 <strong>左侧</strong> 最近的那个 <strong>非星号</strong> 字符，并移除该星号自身。</li>\n</ul>\n\n<p>返回移除 <strong>所有</strong> 星号之后的字符串<strong>。</strong></p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>生成的输入保证总是可以执行题面中描述的操作。</li>\n\t<li>可以证明结果字符串是唯一的。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"leet**cod*e\"\n<strong>输出：</strong>\"lecoe\"\n<strong>解释：</strong>从左到右执行移除操作：\n- 距离第 1 个星号最近的字符是 \"lee<em><strong>t</strong></em>**cod*e\" 中的 't' ，s 变为 \"lee*cod*e\" 。\n- 距离第 2 个星号最近的字符是 \"le<em><strong>e</strong></em>*cod*e\" 中的 'e' ，s 变为 \"lecod*e\" 。\n- 距离第 3 个星号最近的字符是 \"leco<em><strong>d</strong></em>*e\" 中的 'd' ，s 变为 \"lecoe\" 。\n不存在其他星号，返回 \"lecoe\" 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"erase*****\"\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>整个字符串都会被移除，所以返回空字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写英文字母和星号 <code>*</code> 组成</li>\n\t<li><code>s</code> 可以执行上述操作</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2391收集垃圾的最少总时间",
        "hardRate": "MEDIUM",
        "passRate": "85.69%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-amount-of-time-to-collect-garbage/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-amount-of-time-to-collect-garbage/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串数组&nbsp;<code>garbage</code>&nbsp;，其中&nbsp;<code>garbage[i]</code>&nbsp;表示第 <code>i</code>&nbsp;个房子的垃圾集合。<code>garbage[i]</code>&nbsp;只包含字符&nbsp;<code>'M'</code>&nbsp;，<code>'P'</code> 和&nbsp;<code>'G'</code>&nbsp;，但可能包含多个相同字符，每个字符分别表示一单位的金属、纸和玻璃。垃圾车收拾 <strong>一</strong>&nbsp;单位的任何一种垃圾都需要花费&nbsp;<code>1</code>&nbsp;分钟。</p>\n\n<p>同时给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>travel</code>&nbsp;，其中&nbsp;<code>travel[i]</code>&nbsp;是垃圾车从房子 <code>i</code>&nbsp;行驶到房子 <code>i + 1</code>&nbsp;需要的分钟数。</p>\n\n<p>城市里总共有三辆垃圾车，分别收拾三种垃圾。每辆垃圾车都从房子 <code>0</code>&nbsp;出发，<strong>按顺序</strong>&nbsp;到达每一栋房子。但它们 <strong>不是必须</strong>&nbsp;到达所有的房子。</p>\n\n<p>任何时刻只有 <strong>一辆</strong>&nbsp;垃圾车处在使用状态。当一辆垃圾车在行驶或者收拾垃圾的时候，另外两辆车 <strong>不能</strong>&nbsp;做任何事情。</p>\n\n<p>请你返回收拾完所有垃圾需要花费的 <strong>最少</strong>&nbsp;总分钟数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>garbage = [\"G\",\"P\",\"GP\",\"GG\"], travel = [2,4,3]\n<b>输出：</b>21\n<strong>解释：</strong>\n收拾纸的垃圾车：\n1. 从房子 0 行驶到房子 1\n2. 收拾房子 1 的纸垃圾\n3. 从房子 1 行驶到房子 2\n4. 收拾房子 2 的纸垃圾\n收拾纸的垃圾车总共花费 8 分钟收拾完所有的纸垃圾。\n收拾玻璃的垃圾车：\n1. 收拾房子 0 的玻璃垃圾\n2. 从房子 0 行驶到房子 1\n3. 从房子 1 行驶到房子 2\n4. 收拾房子 2 的玻璃垃圾\n5. 从房子 2 行驶到房子 3\n6. 收拾房子 3 的玻璃垃圾\n收拾玻璃的垃圾车总共花费 13 分钟收拾完所有的玻璃垃圾。\n由于没有金属垃圾，收拾金属的垃圾车不需要花费任何时间。\n所以总共花费 8 + 13 = 21 分钟收拾完所有垃圾。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>garbage = [\"MMM\",\"PGM\",\"GP\"], travel = [3,10]\n<b>输出：</b>37\n<strong>解释：</strong>\n收拾金属的垃圾车花费 7 分钟收拾完所有的金属垃圾。\n收拾纸的垃圾车花费 15 分钟收拾完所有的纸垃圾。\n收拾玻璃的垃圾车花费 15 分钟收拾完所有的玻璃垃圾。\n总共花费 7 + 15 + 15 = 37 分钟收拾完所有的垃圾。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= garbage.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>garbage[i]</code> 只包含字母&nbsp;<code>'M'</code>&nbsp;，<code>'P'</code>&nbsp;和&nbsp;<code>'G'</code>&nbsp;。</li>\n\t<li><code>1 &lt;= garbage[i].length &lt;= 10</code></li>\n\t<li><code>travel.length == garbage.length - 1</code></li>\n\t<li><code>1 &lt;= travel[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2392给定条件下构造矩阵",
        "hardRate": "HARD",
        "passRate": "55.72%",
        "problemsUrl": "https://leetcode.cn/problems/build-a-matrix-with-conditions/",
        "solutionsUrl": "https://leetcode.cn/problems/build-a-matrix-with-conditions/solution",
        "problemsDesc": "<p>给你一个 <strong>正</strong>&nbsp;整数&nbsp;<code>k</code>&nbsp;，同时给你：</p>\n\n<ul>\n\t<li>一个大小为 <code>n</code>&nbsp;的二维整数数组&nbsp;<code>rowConditions</code>&nbsp;，其中&nbsp;<code>rowConditions[i] = [above<sub>i</sub>, below<sub>i</sub>]</code>&nbsp;和</li>\n\t<li>一个大小为 <code>m</code>&nbsp;的二维整数数组&nbsp;<code>colConditions</code>&nbsp;，其中&nbsp;<code>colConditions[i] = [left<sub>i</sub>, right<sub>i</sub>]</code>&nbsp;。</li>\n</ul>\n\n<p>两个数组里的整数都是&nbsp;<code>1</code>&nbsp;到&nbsp;<code>k</code>&nbsp;之间的数字。</p>\n\n<p>你需要构造一个&nbsp;<code>k x k</code>&nbsp;的矩阵，<code>1</code>&nbsp;到&nbsp;<code>k</code>&nbsp;每个数字需要&nbsp;<strong>恰好出现一次</strong>&nbsp;。剩余的数字都是<b>&nbsp;</b><code>0</code>&nbsp;。</p>\n\n<p>矩阵还需要满足以下条件：</p>\n\n<ul>\n\t<li>对于所有 <code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;之间的下标&nbsp;<code>i</code>&nbsp;，数字&nbsp;<code>above<sub>i</sub></code>&nbsp;所在的 <strong>行</strong>&nbsp;必须在数字&nbsp;<code>below<sub>i</sub></code>&nbsp;所在行的上面。</li>\n\t<li>对于所有 <code>0</code>&nbsp;到 <code>m - 1</code>&nbsp;之间的下标&nbsp;<code>i</code>&nbsp;，数字&nbsp;<code>left<sub>i</sub></code>&nbsp;所在的 <b>列</b>&nbsp;必须在数字&nbsp;<code>right<sub>i</sub></code>&nbsp;所在列的左边。</li>\n</ul>\n\n<p>返回满足上述要求的 <strong>任意</strong>&nbsp;矩阵。如果不存在答案，返回一个空的矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/06/gridosdrawio.png\" style=\"width: 211px; height: 211px;\"></p>\n\n<pre><b>输入：</b>k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]]\n<b>输出：</b>[[3,0,0],[0,0,1],[0,2,0]]\n<b>解释：</b>上图为一个符合所有条件的矩阵。\n行要求如下：\n- 数字 1 在第 <strong>1</strong> 行，数字 2 在第 <strong>2</strong>&nbsp;行，1 在 2 的上面。\n- 数字 3 在第 <strong>0</strong>&nbsp;行，数字 2 在第 <strong>2</strong>&nbsp;行，3 在 2 的上面。\n列要求如下：\n- 数字 2 在第 <strong>1</strong>&nbsp;列，数字 1 在第 <strong>2</strong>&nbsp;列，2 在 1 的左边。\n- 数字 3 在第 <strong>0</strong>&nbsp;列，数字 2 在第 <strong>1</strong>&nbsp;列，3 在 2 的左边。\n注意，可能有多种正确的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]]\n<b>输出：</b>[]\n<b>解释：</b>由前两个条件可以得到 3 在 1 的下面，但第三个条件是 3 在 1 的上面。\n没有符合条件的矩阵存在，所以我们返回空矩阵。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= k &lt;= 400</code></li>\n\t<li><code>1 &lt;= rowConditions.length, colConditions.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>rowConditions[i].length == colConditions[i].length == 2</code></li>\n\t<li><code>1 &lt;= above<sub>i</sub>, below<sub>i</sub>, left<sub>i</sub>, right<sub>i</sub> &lt;= k</code></li>\n\t<li><code>above<sub>i</sub> != below<sub>i</sub></code></li>\n\t<li><code>left<sub>i</sub> != right<sub>i</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2393严格递增的子数组个数",
        "hardRate": "MEDIUM",
        "passRate": "78.79%",
        "problemsUrl": "https://leetcode.cn/problems/count-strictly-increasing-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/count-strictly-increasing-subarrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2394开除员工",
        "hardRate": "MEDIUM",
        "passRate": "53.07%",
        "problemsUrl": "https://leetcode.cn/problems/employees-with-deductions/",
        "solutionsUrl": "https://leetcode.cn/problems/employees-with-deductions/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2395和相等的子数组",
        "hardRate": "EASY",
        "passRate": "76.33%",
        "problemsUrl": "https://leetcode.cn/problems/find-subarrays-with-equal-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/find-subarrays-with-equal-sum/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，判断是否存在&nbsp;<strong>两个</strong>&nbsp;长度为&nbsp;<code>2</code>&nbsp;的子数组且它们的&nbsp;<strong>和</strong>&nbsp;相等。注意，这两个子数组起始位置的下标必须&nbsp;<strong>不相同</strong>&nbsp;。</p>\n\n<p>如果这样的子数组存在，请返回&nbsp;<code>true</code>，否则返回&nbsp;<code>false</code><em>&nbsp;</em>。</p>\n\n<p><strong>子数组</strong> 是一个数组中一段连续非空的元素组成的序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [4,2,4]\n<b>输出：</b>true\n<b>解释：</b>元素为 [4,2] 和 [2,4] 的子数组有相同的和 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2,3,4,5]\n<b>输出：</b>false\n<b>解释：</b>没有长度为 2 的两个子数组和相等。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [0,0,0]\n<b>输出：</b>true\n<b>解释：</b>子数组 [nums[0],nums[1]] 和 [nums[1],nums[2]] 的和相等，都为 0 。\n注意即使子数组的元素相同，这两个子数组也视为不相同的子数组，因为它们在原数组中的起始位置不同。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2396严格回文的数字",
        "hardRate": "MEDIUM",
        "passRate": "87.90%",
        "problemsUrl": "https://leetcode.cn/problems/strictly-palindromic-number/",
        "solutionsUrl": "https://leetcode.cn/problems/strictly-palindromic-number/solution",
        "problemsDesc": "<p>如果一个整数 <code>n</code>&nbsp;在 <code>b</code>&nbsp;进制下（<code>b</code>&nbsp;为 <code>2</code>&nbsp;到 <code>n - 2</code>&nbsp;之间的所有整数）对应的字符串&nbsp;<strong>全部</strong>&nbsp;都是 <strong>回文的</strong>&nbsp;，那么我们称这个数&nbsp;<code>n</code>&nbsp;是 <strong>严格回文</strong>&nbsp;的。</p>\n\n<p>给你一个整数&nbsp;<code>n</code>&nbsp;，如果 <code>n</code>&nbsp;是 <strong>严格回文</strong>&nbsp;的，请返回&nbsp;<code>true</code> ，否则返回<em>&nbsp;</em><code>false</code>&nbsp;。</p>\n\n<p>如果一个字符串从前往后读和从后往前读完全相同，那么这个字符串是 <strong>回文的</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 9\n<b>输出：</b>false\n<b>解释：</b>在 2 进制下：9 = 1001 ，是回文的。\n在 3 进制下：9 = 100 ，不是回文的。\n所以，9 不是严格回文数字，我们返回 false 。\n注意在 4, 5, 6 和 7 进制下，n = 9 都不是回文的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 4\n<b>输出：</b>false\n<b>解释：</b>我们只考虑 2 进制：4 = 100 ，不是回文的。\n所以我们返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>4 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2397被列覆盖的最多行数",
        "hardRate": "MEDIUM",
        "passRate": "54.79%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-rows-covered-by-columns/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-rows-covered-by-columns/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;二进制矩阵&nbsp;<code>mat</code>&nbsp;和一个整数&nbsp;<code>cols</code>&nbsp;，表示你需要选出的列数。</p>\n\n<p>如果一行中，所有的 <code>1</code> 都被你选中的列所覆盖，那么我们称这一行 <strong>被覆盖</strong>&nbsp;了。</p>\n\n<p>请你返回在选择 <code>cols</code>&nbsp;列的情况下，<strong>被覆盖</strong>&nbsp;的行数 <strong>最大</strong>&nbsp;为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/14/rowscovered.png\" style=\"width: 250px; height: 417px;\"></strong></p>\n\n<pre><b>输入：</b>mat = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], cols = 2\n<b>输出：</b>3\n<strong>解释：</strong>\n如上图所示，覆盖 3 行的一种可行办法是选择第 0 和第 2 列。\n可以看出，不存在大于 3 行被覆盖的方案，所以我们返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/14/rowscovered2.png\" style=\"width: 83px; height: 247px;\"></strong></p>\n\n<pre><b>输入：</b>mat = [[1],[0]], cols = 1\n<b>输出：</b>2\n<strong>解释：</strong>\n选择唯一的一列，两行都被覆盖了，原因是整个矩阵都被覆盖了。\n所以我们返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 12</code></li>\n\t<li><code>mat[i][j]</code>&nbsp;要么是&nbsp;<code>0</code>&nbsp;要么是&nbsp;<code>1</code>&nbsp;。</li>\n\t<li><code>1 &lt;= cols &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2398预算内的最多机器人数目",
        "hardRate": "HARD",
        "passRate": "34.45%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-robots-within-budget/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-robots-within-budget/solution",
        "problemsDesc": "<p>你有&nbsp;<code>n</code>&nbsp;个机器人，给你两个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>chargeTimes</code> 和&nbsp;<code>runningCosts</code>&nbsp;，两者长度都为&nbsp;<code>n</code>&nbsp;。第&nbsp;<code>i</code>&nbsp;个机器人充电时间为&nbsp;<code>chargeTimes[i]</code>&nbsp;单位时间，花费&nbsp;<code>runningCosts[i]</code>&nbsp;单位时间运行。再给你一个整数&nbsp;<code>budget</code>&nbsp;。</p>\n\n<p>运行&nbsp;<code>k</code>&nbsp;个机器人 <strong>总开销</strong>&nbsp;是&nbsp;<code>max(chargeTimes) + k * sum(runningCosts)</code>&nbsp;，其中&nbsp;<code>max(chargeTimes)</code>&nbsp;是这&nbsp;<code>k</code>&nbsp;个机器人中最大充电时间，<code>sum(runningCosts)</code>&nbsp;是这 <code>k</code>&nbsp;个机器人的运行时间之和。</p>\n\n<p>请你返回在 <strong>不超过</strong>&nbsp;<code>budget</code>&nbsp;的前提下，你 <strong>最多</strong>&nbsp;可以 <strong>连续</strong>&nbsp;运行的机器人数目为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>chargeTimes = [3,6,1,3,4], runningCosts = [2,1,3,4,5], budget = 25\n<b>输出：</b>3\n<b>解释：</b>\n可以在 budget 以内运行所有单个机器人或者连续运行 2 个机器人。\n选择前 3 个机器人，可以得到答案最大值 3 。总开销是 max(3,6,1) + 3 * sum(2,1,3) = 6 + 3 * 6 = 24 ，小于 25 。\n可以看出无法在 budget 以内连续运行超过 3 个机器人，所以我们返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>chargeTimes = [11,12,19], runningCosts = [10,8,7], budget = 19\n<b>输出：</b>0\n<b>解释：</b>即使运行任何一个单个机器人，还是会超出 budget，所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>chargeTimes.length == runningCosts.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= chargeTimes[i], runningCosts[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= budget &lt;= 10<sup>15</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2399检查相同字母间的距离",
        "hardRate": "EASY",
        "passRate": "75.26%",
        "problemsUrl": "https://leetcode.cn/problems/check-distances-between-same-letters/",
        "solutionsUrl": "https://leetcode.cn/problems/check-distances-between-same-letters/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，该字符串仅由小写英文字母组成，<code>s</code> 中的每个字母都 <strong>恰好</strong> 出现 <strong>两次</strong> 。另给你一个下标从 <strong>0</strong> 开始、长度为 <code>26</code> 的的整数数组 <code>distance</code> 。</p>\n\n<p>字母表中的每个字母按从 <code>0</code> 到 <code>25</code> 依次编号（即，<code>'a' -&gt; 0</code>, <code>'b' -&gt; 1</code>, <code>'c' -&gt; 2</code>, ... , <code>'z' -&gt; 25</code>）。</p>\n\n<p>在一个 <strong>匀整</strong> 字符串中，第 <code>i</code> 个字母的两次出现之间的字母数量是 <code>distance[i]</code> 。如果第 <code>i</code> 个字母没有在 <code>s</code> 中出现，那么 <code>distance[i]</code> 可以 <strong>忽略</strong> 。</p>\n\n<p>如果 <code>s</code> 是一个 <strong>匀整</strong> 字符串，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abaccb\", distance = [1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n<strong>输出：</strong>true\n<strong>解释：</strong>\n- 'a' 在下标 0 和下标 2 处出现，所以满足 distance[0] = 1 。\n- 'b' 在下标 1 和下标 5 处出现，所以满足 distance[1] = 3 。\n- 'c' 在下标 3 和下标 4 处出现，所以满足 distance[2] = 0 。\n注意 distance[3] = 5 ，但是由于 'd' 没有在 s 中出现，可以忽略。\n因为 s 是一个匀整字符串，返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"aa\", distance = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n<strong>输出：</strong>false\n<strong>解释：</strong>\n- 'a' 在下标 0 和 1 处出现，所以两次出现之间的字母数量为 0 。\n但是 distance[0] = 1 ，s 不是一个匀整字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 52</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n\t<li><code>s</code> 中的每个字母恰好出现两次</li>\n\t<li><code>distance.length == 26</code></li>\n\t<li><code>0 &lt;= distance[i] &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2400恰好移动 k 步到达某一位置的方法数目",
        "hardRate": "MEDIUM",
        "passRate": "32.66%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/solution",
        "problemsDesc": "<p>给你两个 <strong>正</strong> 整数 <code>startPos</code> 和 <code>endPos</code> 。最初，你站在 <strong>无限</strong> 数轴上位置 <code>startPos</code> 处。在一步移动中，你可以向左或者向右移动一个位置。</p>\n\n<p>给你一个正整数 <code>k</code> ，返回从 <code>startPos</code> 出发、<strong>恰好</strong> 移动 <code>k</code> 步并到达 <code>endPos</code> 的 <strong>不同</strong> 方法数目。由于答案可能会很大，返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p>如果所执行移动的顺序不完全相同，则认为两种方法不同。</p>\n\n<p><strong>注意：</strong>数轴包含负整数<strong>。</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>startPos = 1, endPos = 2, k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>存在 3 种从 1 到 2 且恰好移动 3 步的方法：\n- 1 -&gt; 2 -&gt; 3 -&gt; 2.\n- 1 -&gt; 2 -&gt; 1 -&gt; 2.\n- 1 -&gt; 0 -&gt; 1 -&gt; 2.\n可以证明不存在其他方法，所以返回 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>startPos = 2, endPos = 5, k = 10\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在从 2 到 5 且恰好移动 10 步的方法。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= startPos, endPos, k &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2401最长优雅子数组",
        "hardRate": "MEDIUM",
        "passRate": "49.62%",
        "problemsUrl": "https://leetcode.cn/problems/longest-nice-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-nice-subarray/solution",
        "problemsDesc": "<p>给你一个由 <strong>正</strong> 整数组成的数组 <code>nums</code> 。</p>\n\n<p>如果&nbsp;<code>nums</code> 的子数组中位于 <strong>不同</strong> 位置的每对元素按位 <strong>与（AND）</strong>运算的结果等于 <code>0</code> ，则称该子数组为 <strong>优雅</strong> 子数组。</p>\n\n<p>返回 <strong>最长</strong> 的优雅子数组的长度。</p>\n\n<p><strong>子数组</strong> 是数组中的一个 <strong>连续</strong> 部分。</p>\n\n<p><strong>注意：</strong>长度为 <code>1</code> 的子数组始终视作优雅子数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3,8,48,10]\n<strong>输出：</strong>3\n<strong>解释：</strong>最长的优雅子数组是 [3,8,48] 。子数组满足题目条件：\n- 3 AND 8 = 0\n- 3 AND 48 = 0\n- 8 AND 48 = 0\n可以证明不存在更长的优雅子数组，所以返回 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,1,5,11,13]\n<strong>输出：</strong>1\n<strong>解释：</strong>最长的优雅子数组长度为 1 ，任何长度为 1 的子数组都满足题目条件。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2402会议室 III",
        "hardRate": "HARD",
        "passRate": "32.57%",
        "problemsUrl": "https://leetcode.cn/problems/meeting-rooms-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/meeting-rooms-iii/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code> ，共有编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个会议室。</p>\n\n<p>给你一个二维整数数组 <code>meetings</code> ，其中 <code>meetings[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 表示一场会议将会在 <strong>半闭</strong> 时间区间 <code>[start<sub>i</sub>, end<sub>i</sub>)</code> 举办。所有 <code>start<sub>i</sub></code> 的值 <strong>互不相同</strong> 。</p>\n\n<p>会议将会按以下方式分配给会议室：</p>\n\n<ol>\n\t<li>每场会议都会在未占用且编号 <strong>最小</strong> 的会议室举办。</li>\n\t<li>如果没有可用的会议室，会议将会延期，直到存在空闲的会议室。延期会议的持续时间和原会议持续时间 <strong>相同</strong> 。</li>\n\t<li>当会议室处于未占用状态时，将会优先提供给原 <strong>开始</strong> 时间更早的会议。</li>\n</ol>\n\n<p>返回举办最多次会议的房间 <strong>编号</strong> 。如果存在多个房间满足此条件，则返回编号 <strong>最小</strong> 的房间。</p>\n\n<p><strong>半闭区间 </strong><code>[a, b)</code> 是 <code>a</code> 和 <code>b</code> 之间的区间，<strong>包括</strong> <code>a</code> 但<strong> 不包括</strong> <code>b</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, meetings = [[0,10],[1,5],[2,7],[3,4]]\n<strong>输出：</strong>0\n<strong>解释：</strong>\n- 在时间 0 ，两个会议室都未占用，第一场会议在会议室 0 举办。\n- 在时间 1 ，只有会议室 1 未占用，第二场会议在会议室 1 举办。\n- 在时间 2 ，两个会议室都被占用，第三场会议延期举办。\n- 在时间 3 ，两个会议室都被占用，第四场会议延期举办。\n- 在时间 5 ，会议室 1 的会议结束。第三场会议在会议室 1 举办，时间周期为 [5,10) 。\n- 在时间 10 ，两个会议室的会议都结束。第四场会议在会议室 0 举办，时间周期为 [10,11) 。\n会议室 0 和会议室 1 都举办了 2 场会议，所以返回 0 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n- 在时间 1 ，所有三个会议室都未占用，第一场会议在会议室 0 举办。\n- 在时间 2 ，会议室 1 和 2 未占用，第二场会议在会议室 1 举办。\n- 在时间 3 ，只有会议室 2 未占用，第三场会议在会议室 2 举办。\n- 在时间 4 ，所有三个会议室都被占用，第四场会议延期举办。 \n- 在时间 5 ，会议室 2 的会议结束。第四场会议在会议室 2 举办，时间周期为 [5,10) 。\n- 在时间 6 ，所有三个会议室都被占用，第五场会议延期举办。 \n- 在时间 10 ，会议室 1 和 2 的会议结束。第五场会议在会议室 1 举办，时间周期为 [10,12) 。 \n会议室 1 和会议室 2 都举办了 2 场会议，所以返回 1 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= meetings.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>meetings[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt; end<sub>i</sub> &lt;= 5 * 10<sup>5</sup></code></li>\n\t<li><code>start<sub>i</sub></code> 的所有值 <strong>互不相同</strong></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2403杀死所有怪物的最短时间",
        "hardRate": "HARD",
        "passRate": "70.04%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-kill-all-monsters/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-kill-all-monsters/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2404出现最频繁的偶数元素",
        "hardRate": "EASY",
        "passRate": "58.33%",
        "problemsUrl": "https://leetcode.cn/problems/most-frequent-even-element/",
        "solutionsUrl": "https://leetcode.cn/problems/most-frequent-even-element/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，返回出现最频繁的偶数元素。</p>\n\n<p>如果存在多个满足条件的元素，只需要返回 <strong>最小</strong> 的一个。如果不存在这样的元素，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,2,2,4,4,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n数组中的偶数元素为 0、2 和 4 ，在这些元素中，2 和 4 出现次数最多。\n返回最小的那个，即返回 2 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,4,4,9,2,4]\n<strong>输出：</strong>4\n<strong>解释：</strong>4 是出现最频繁的偶数元素。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [29,47,21,41,13,37,25,7]\n<strong>输出：</strong>-1\n<strong>解释：</strong>不存在偶数元素。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2405子字符串的最优划分",
        "hardRate": "MEDIUM",
        "passRate": "74.89%",
        "problemsUrl": "https://leetcode.cn/problems/optimal-partition-of-string/",
        "solutionsUrl": "https://leetcode.cn/problems/optimal-partition-of-string/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> ，请你将该字符串划分成一个或多个 <strong>子字符串</strong> ，并满足每个子字符串中的字符都是 <strong>唯一</strong> 的。也就是说，在单个子字符串中，字母的出现次数都不超过 <strong>一次</strong> 。</p>\n\n<p>满足题目要求的情况下，返回 <strong>最少</strong> 需要划分多少个子字符串<em>。</em></p>\n\n<p>注意，划分后，原字符串中的每个字符都应该恰好属于一个子字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abacaba\"\n<strong>输出：</strong>4\n<strong>解释：</strong>\n两种可行的划分方法分别是 (\"a\",\"ba\",\"cab\",\"a\") 和 (\"ab\",\"a\",\"ca\",\"ba\") 。\n可以证明最少需要划分 4 个子字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ssssss\"\n<strong>输出：</strong>6\n<strong>解释：\n</strong>只存在一种可行的划分方法 (\"s\",\"s\",\"s\",\"s\",\"s\",\"s\") 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2406将区间分为最少组数",
        "hardRate": "MEDIUM",
        "passRate": "44.66%",
        "problemsUrl": "https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/solution",
        "problemsDesc": "<p>给你一个二维整数数组&nbsp;<code>intervals</code>&nbsp;，其中&nbsp;<code>intervals[i] = [left<sub>i</sub>, right<sub>i</sub>]</code>&nbsp;表示 <strong>闭</strong>&nbsp;区间&nbsp;<code>[left<sub>i</sub>, right<sub>i</sub>]</code>&nbsp;。</p>\n\n<p>你需要将&nbsp;<code>intervals</code> 划分为一个或者多个区间&nbsp;<strong>组</strong>&nbsp;，每个区间 <b>只</b>&nbsp;属于一个组，且同一个组中任意两个区间 <strong>不相交</strong>&nbsp;。</p>\n\n<p>请你返回 <strong>最少</strong>&nbsp;需要划分成多少个组。</p>\n\n<p>如果两个区间覆盖的范围有重叠（即至少有一个公共数字），那么我们称这两个区间是 <strong>相交</strong>&nbsp;的。比方说区间&nbsp;<code>[1, 5]</code> 和&nbsp;<code>[5, 8]</code>&nbsp;相交。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>intervals = [[5,10],[6,8],[1,5],[2,3],[1,10]]\n<b>输出：</b>3\n<b>解释：</b>我们可以将区间划分为如下的区间组：\n- 第 1 组：[1, 5] ，[6, 8] 。\n- 第 2 组：[2, 3] ，[5, 10] 。\n- 第 3 组：[1, 10] 。\n可以证明无法将区间划分为少于 3 个组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>intervals = [[1,3],[5,6],[8,10],[11,13]]\n<b>输出：</b>1\n<b>解释：</b>所有区间互不相交，所以我们可以把它们全部放在一个组内。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>1 &lt;= left<sub>i</sub> &lt;= right<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2407最长递增子序列 II",
        "hardRate": "HARD",
        "passRate": "30.57%",
        "problemsUrl": "https://leetcode.cn/problems/longest-increasing-subsequence-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-increasing-subsequence-ii/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>找到&nbsp;<code>nums</code>&nbsp;中满足以下要求的最长子序列：</p>\n\n<ul>\n\t<li>子序列 <strong>严格递增</strong></li>\n\t<li>子序列中相邻元素的差值 <strong>不超过</strong>&nbsp;<code>k</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回满足上述要求的 <strong>最长子序列</strong>&nbsp;的长度。</p>\n\n<p><strong>子序列</strong>&nbsp;是从一个数组中删除部分元素后，剩余元素不改变顺序得到的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [4,2,1,4,3,4,5,8,15], k = 3\n<b>输出：</b>5\n<strong>解释：</strong>\n满足要求的最长子序列是 [1,3,4,5,8] 。\n子序列长度为 5 ，所以我们返回 5 。\n注意子序列 [1,3,4,5,8,15] 不满足要求，因为 15 - 8 = 7 大于 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [7,4,5,1,8,12,4,7], k = 5\n<b>输出：</b>4\n<strong>解释：</strong>\n满足要求的最长子序列是 [4,5,8,12] 。\n子序列长度为 4 ，所以我们返回 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [1,5], k = 1\n<b>输出：</b>1\n<strong>解释：</strong>\n满足要求的最长子序列是 [1] 。\n子序列长度为 1 ，所以我们返回 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2408设计 SQL",
        "hardRate": "MEDIUM",
        "passRate": "64.04%",
        "problemsUrl": "https://leetcode.cn/problems/design-sql/",
        "solutionsUrl": "https://leetcode.cn/problems/design-sql/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2409统计共同度过的日子数",
        "hardRate": "EASY",
        "passRate": "55.94%",
        "problemsUrl": "https://leetcode.cn/problems/count-days-spent-together/",
        "solutionsUrl": "https://leetcode.cn/problems/count-days-spent-together/solution",
        "problemsDesc": "<p>Alice 和 Bob 计划分别去罗马开会。</p>\n\n<p>给你四个字符串&nbsp;<code>arriveAlice</code>&nbsp;，<code>leaveAlice</code>&nbsp;，<code>arriveBob</code>&nbsp;和&nbsp;<code>leaveBob</code>&nbsp;。Alice 会在日期&nbsp;<code>arriveAlice</code>&nbsp;到&nbsp;<code>leaveAlice</code>&nbsp;之间在城市里（<strong>日期为闭区间</strong>），而 Bob 在日期&nbsp;<code>arriveBob</code>&nbsp;到&nbsp;<code>leaveBob</code>&nbsp;之间在城市里（<strong>日期为闭区间</strong>）。每个字符串都包含 5 个字符，格式为&nbsp;<code>\"MM-DD\"</code>&nbsp;，对应着一个日期的月和日。</p>\n\n<p>请你返回 Alice和 Bob 同时在罗马的天数。</p>\n\n<p>你可以假设所有日期都在 <strong>同一个</strong>&nbsp;自然年，而且 <strong>不是</strong>&nbsp;闰年。每个月份的天数分别为：<code>[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>arriveAlice = \"08-15\", leaveAlice = \"08-18\", arriveBob = \"08-16\", leaveBob = \"08-19\"\n<b>输出：</b>3\n<b>解释：</b>Alice 从 8 月 15 号到 8 月 18 号在罗马。Bob 从 8 月 16 号到 8 月 19 号在罗马，他们同时在罗马的日期为 8 月 16、17 和 18 号。所以答案为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>arriveAlice = \"10-01\", leaveAlice = \"10-31\", arriveBob = \"11-01\", leaveBob = \"12-31\"\n<b>输出：</b>0\n<b>解释：</b>Alice 和 Bob 没有同时在罗马的日子，所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>所有日期的格式均为&nbsp;<code>\"MM-DD\"</code>&nbsp;。</li>\n\t<li>Alice 和 Bob 的到达日期都 <strong>早于或等于</strong> 他们的离开日期。</li>\n\t<li>题目测试用例所给出的日期均为 <strong>非闰年</strong> 的有效日期。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2410运动员和训练师的最大匹配数",
        "hardRate": "MEDIUM",
        "passRate": "64.76%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-matching-of-players-with-trainers/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-matching-of-players-with-trainers/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>players</code>&nbsp;，其中&nbsp;<code>players[i]</code>&nbsp;表示第 <code>i</code>&nbsp;名运动员的 <strong>能力</strong>&nbsp;值，同时给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>trainers</code>&nbsp;，其中&nbsp;<code>trainers[j]</code>&nbsp;表示第 <code>j</code>&nbsp;名训练师的 <strong>训练能力值</strong>&nbsp;。</p>\n\n<p>如果第 <code>i</code>&nbsp;名运动员的能力值 <strong>小于等于</strong>&nbsp;第 <code>j</code>&nbsp;名训练师的能力值，那么第&nbsp;<code>i</code>&nbsp;名运动员可以 <strong>匹配</strong>&nbsp;第&nbsp;<code>j</code>&nbsp;名训练师。除此以外，每名运动员至多可以匹配一位训练师，每位训练师最多可以匹配一位运动员。</p>\n\n<p>请你返回满足上述要求&nbsp;<code>players</code>&nbsp;和 <code>trainers</code>&nbsp;的 <strong>最大</strong> 匹配数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>players = [4,7,9], trainers = [8,2,5,8]\n<b>输出：</b>2\n<b>解释：</b>\n得到两个匹配的一种方案是：\n- players[0] 与 trainers[0] 匹配，因为 4 &lt;= 8 。\n- players[1] 与 trainers[3] 匹配，因为 7 &lt;= 8 。\n可以证明 2 是可以形成的最大匹配数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>players = [1,1,1], trainers = [10]\n<b>输出：</b>1\n<b>解释：</b>\n训练师可以匹配所有 3 个运动员\n每个运动员至多只能匹配一个训练师，所以最大答案是 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= players.length, trainers.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= players[i], trainers[j] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2411按位或最大的最小子数组长度",
        "hardRate": "MEDIUM",
        "passRate": "43.24%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>nums</code>&nbsp;，数组中所有数字均为非负整数。对于&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;之间的每一个下标 <code>i</code>&nbsp;，你需要找出&nbsp;<code>nums</code>&nbsp;中一个 <strong>最小</strong> 非空子数组，它的起始位置为&nbsp;<code>i</code>&nbsp;（包含这个位置），同时有&nbsp;<strong>最大</strong>&nbsp;的 <strong>按位或</strong><b>运算值</b>&nbsp;。</p>\n\n<ul>\n\t<li>换言之，令&nbsp;<code>B<sub>ij</sub></code>&nbsp;表示子数组&nbsp;<code>nums[i...j]</code>&nbsp;的按位或运算的结果，你需要找到一个起始位置为&nbsp;<code>i</code>&nbsp;的最小子数组，这个子数组的按位或运算的结果等于&nbsp;<code>max(B<sub>ik</sub>)</code>&nbsp;，其中&nbsp;<code>i &lt;= k &lt;= n - 1</code>&nbsp;。</li>\n</ul>\n\n<p>一个数组的按位或运算值是这个数组里所有数字按位或运算的结果。</p>\n\n<p>请你返回一个大小为 <code>n</code>&nbsp;的整数数组<em>&nbsp;</em><code>answer</code>，其中<em>&nbsp;</em><code>answer[i]</code>是开始位置为&nbsp;<code>i</code>&nbsp;，按位或运算结果最大，且&nbsp;<strong>最短</strong>&nbsp;子数组的长度。</p>\n\n<p><strong>子数组</strong>&nbsp;是数组里一段连续非空元素组成的序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [1,0,2,1,3]\n<b>输出：</b>[3,3,2,2,1]\n<strong>解释：</strong>\n任何位置开始，最大按位或运算的结果都是 3 。\n- 下标 0 处，能得到结果 3 的最短子数组是 [1,0,2] 。\n- 下标 1 处，能得到结果 3 的最短子数组是 [0,2,1] 。\n- 下标 2 处，能得到结果 3 的最短子数组是 [2,1] 。\n- 下标 3 处，能得到结果 3 的最短子数组是 [1,3] 。\n- 下标 4 处，能得到结果 3 的最短子数组是 [3] 。\n所以我们返回 [3,3,2,2,1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,2]\n<b>输出：</b>[2,1]\n<strong>解释：\n</strong>下标 0 处，能得到最大按位或运算值的最短子数组长度为 2 。\n下标 1 处，能得到最大按位或运算值的最短子数组长度为 1 。\n所以我们返回 [2,1] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2412完成所有交易的初始最少钱数",
        "hardRate": "HARD",
        "passRate": "48.25%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-money-required-before-transactions/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-money-required-before-transactions/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code><font face=\"monospace\">transactions</font></code>，其中<code>transactions[i] = [cost<sub>i</sub>, cashback<sub>i</sub>]</code>&nbsp;。</p>\n\n<p>数组描述了若干笔交易。其中每笔交易必须以 <strong>某种顺序</strong> 恰好完成一次。在任意一个时刻，你有一定数目的钱&nbsp;<code>money</code>&nbsp;，为了完成交易&nbsp;<code>i</code>&nbsp;，<code>money &gt;= cost<sub>i</sub></code>&nbsp;这个条件必须为真。执行交易后，你的钱数&nbsp;<code>money</code> 变成&nbsp;<code>money - cost<sub>i</sub> + cashback<sub>i</sub></code><sub>&nbsp;</sub>。</p>\n\n<p>请你返回 <strong>任意一种</strong> 交易顺序下，你都能完成所有交易的最少钱数<em>&nbsp;</em><code>money</code>&nbsp;是多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>transactions = [[2,1],[5,0],[4,2]]\n<b>输出：</b>10\n<strong>解释：\n</strong>刚开始 money = 10 ，交易可以以任意顺序进行。\n可以证明如果 money &lt; 10 ，那么某些交易无法进行。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>transactions = [[3,0],[0,3]]\n<b>输出：</b>3\n<strong>解释：</strong>\n- 如果交易执行的顺序是 [[3,0],[0,3]] ，完成所有交易需要的最少钱数是 3 。\n- 如果交易执行的顺序是 [[0,3],[3,0]] ，完成所有交易需要的最少钱数是 0 。\n所以，刚开始钱数为 3 ，任意顺序下交易都可以全部完成。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= transactions.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>transactions[i].length == 2</code></li>\n\t<li><code>0 &lt;= cost<sub>i</sub>, cashback<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2413最小偶倍数",
        "hardRate": "EASY",
        "passRate": "87.57%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-even-multiple/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-even-multiple/solution",
        "problemsDesc": "给你一个正整数 <code>n</code> ，返回 <code>2</code><em> </em>和<em> </em><code>n</code> 的最小公倍数（正整数）。\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 5\n<strong>输出：</strong>10\n<strong>解释：</strong>5 和 2 的最小公倍数是 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 6\n<strong>输出：</strong>6\n<strong>解释：</strong>6 和 2 的最小公倍数是 6 。注意数字会是它自身的倍数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 150</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2414最长的字母序连续子字符串的长度",
        "hardRate": "MEDIUM",
        "passRate": "60.42%",
        "problemsUrl": "https://leetcode.cn/problems/length-of-the-longest-alphabetical-continuous-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/length-of-the-longest-alphabetical-continuous-substring/solution",
        "problemsDesc": "<p><strong>字母序连续字符串</strong> 是由字母表中连续字母组成的字符串。换句话说，字符串 <code>\"abcdefghijklmnopqrstuvwxyz\"</code> 的任意子字符串都是 <strong>字母序连续字符串</strong> 。</p>\n\n<ul>\n\t<li>例如，<code>\"abc\"</code> 是一个字母序连续字符串，而 <code>\"acb\"</code> 和 <code>\"za\"</code> 不是。</li>\n</ul>\n\n<p>给你一个仅由小写英文字母组成的字符串 <code>s</code> ，返回其 <strong>最长</strong> 的 字母序连续子字符串 的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abacaba\"\n<strong>输出：</strong>2\n<strong>解释：</strong>共有 4 个不同的字母序连续子字符串 \"a\"、\"b\"、\"c\" 和 \"ab\" 。\n\"ab\" 是最长的字母序连续子字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = \"abcde\"\n<strong>输出：</strong>5\n<strong>解释：</strong>\"abcde\" 是最长的字母序连续子字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2415反转二叉树的奇数层",
        "hardRate": "MEDIUM",
        "passRate": "70.06%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-odd-levels-of-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-odd-levels-of-binary-tree/solution",
        "problemsDesc": "<p>给你一棵 <strong>完美</strong> 二叉树的根节点 <code>root</code> ，请你反转这棵树中每个 <strong>奇数</strong> 层的节点值。</p>\n\n<ul>\n\t<li>例如，假设第 3 层的节点值是 <code>[2,1,3,4,7,11,29,18]</code> ，那么反转后它应该变成 <code>[18,29,11,7,4,3,1,2]</code> 。</li>\n</ul>\n\n<p>反转后，返回树的根节点。</p>\n\n<p><strong>完美</strong> 二叉树需满足：二叉树的所有父节点都有两个子节点，且所有叶子节点都在同一层。</p>\n\n<p>节点的 <strong>层数</strong> 等于该节点到根节点之间的边数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/28/first_case1.png\" style=\"width: 626px; height: 191px;\" />\n<pre>\n<strong>输入：</strong>root = [2,3,5,8,13,21,34]\n<strong>输出：</strong>[2,5,3,8,13,21,34]\n<strong>解释：</strong>\n这棵树只有一个奇数层。\n在第 1 层的节点分别是 3、5 ，反转后为 5、3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/07/28/second_case3.png\" style=\"width: 591px; height: 111px;\" />\n<pre>\n<strong>输入：</strong>root = [7,13,11]\n<strong>输出：</strong>[7,11,13]\n<strong>解释：</strong> \n在第 1 层的节点分别是 13、11 ，反转后为 11、13 。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]\n<strong>输出：</strong>[0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]\n<strong>解释：</strong>奇数层由非零值组成。\n在第 1 层的节点分别是 1、2 ，反转后为 2、1 。\n在第 3 层的节点分别是 1、1、1、1、2、2、2、2 ，反转后为 2、2、2、2、1、1、1、1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数目在范围 <code>[1, 2<sup>14</sup>]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>root</code> 是一棵 <strong>完美</strong> 二叉树</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2416字符串的前缀分数和",
        "hardRate": "HARD",
        "passRate": "40.58%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的数组 <code>words</code> ，该数组由 <strong>非空</strong> 字符串组成。</p>\n\n<p>定义字符串 <code>word</code> 的 <strong>分数</strong> 等于以 <code>word</code> 作为 <strong>前缀</strong> 的 <code>words[i]</code> 的数目。</p>\n\n<ul>\n\t<li>例如，如果 <code>words = [\"a\", \"ab\", \"abc\", \"cab\"]</code> ，那么 <code>\"ab\"</code> 的分数是 <code>2</code> ，因为 <code>\"ab\"</code> 是 <code>\"ab\"</code> 和 <code>\"abc\"</code> 的一个前缀。</li>\n</ul>\n\n<p>返回一个长度为<em> </em><code>n</code> 的数组<em> </em><code>answer</code><em> </em>，其中<em> </em><code>answer[i]</code><em> </em>是<em>&nbsp;</em><code>words[i]</code> 的每个非空前缀的分数 <strong>总和</strong> <em>。</em></p>\n\n<p><strong>注意：</strong>字符串视作它自身的一个前缀。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"abc\",\"ab\",\"bc\",\"b\"]\n<strong>输出：</strong>[5,4,3,2]\n<strong>解释：</strong>对应每个字符串的答案如下：\n- \"abc\" 有 3 个前缀：\"a\"、\"ab\" 和 \"abc\" 。\n- 2 个字符串的前缀为 \"a\" ，2 个字符串的前缀为 \"ab\" ，1 个字符串的前缀为 \"abc\" 。\n总计 answer[0] = 2 + 2 + 1 = 5 。\n- \"ab\" 有 2 个前缀：\"a\" 和 \"ab\" 。\n- 2 个字符串的前缀为 \"a\" ，2 个字符串的前缀为 \"ab\" 。\n总计 answer[1] = 2 + 2 = 4 。\n- \"bc\" 有 2 个前缀：\"b\" 和 \"bc\" 。\n- 2 个字符串的前缀为 \"b\" ，1 个字符串的前缀为 \"bc\" 。 \n总计 answer[2] = 2 + 1 = 3 。\n- \"b\" 有 1 个前缀：\"b\"。\n- 2 个字符串的前缀为 \"b\" 。\n总计 answer[3] = 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [\"abcd\"]\n<strong>输出：</strong>[4]\n<strong>解释：</strong>\n\"abcd\" 有 4 个前缀 \"a\"、\"ab\"、\"abc\" 和 \"abcd\"。\n每个前缀的分数都是 1 ，总计 answer[0] = 1 + 1 + 1 + 1 = 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 1000</code></li>\n\t<li><code>words[i]</code> 由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2417最近的公平整数",
        "hardRate": "MEDIUM",
        "passRate": "45.48%",
        "problemsUrl": "https://leetcode.cn/problems/closest-fair-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-fair-integer/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2418按身高排序",
        "hardRate": "EASY",
        "passRate": "79.41%",
        "problemsUrl": "https://leetcode.cn/problems/sort-the-people/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-the-people/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>names</code> ，和一个由 <strong>互不相同</strong> 的正整数组成的数组 <code>heights</code> 。两个数组的长度均为 <code>n</code> 。</p>\n\n<p>对于每个下标 <code>i</code>，<code>names[i]</code> 和 <code>heights[i]</code> 表示第 <code>i</code> 个人的名字和身高。</p>\n\n<p>请按身高 <strong>降序</strong> 顺序返回对应的名字数组 <code>names</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>names = [\"Mary\",\"John\",\"Emma\"], heights = [180,165,170]\n<strong>输出：</strong>[\"Mary\",\"Emma\",\"John\"]\n<strong>解释：</strong>Mary 最高，接着是 Emma 和 John 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>names = [\"Alice\",\"Bob\",\"Bob\"], heights = [155,185,150]\n<strong>输出：</strong>[\"Bob\",\"Alice\",\"Bob\"]\n<strong>解释：</strong>第一个 Bob 最高，然后是 Alice 和第二个 Bob 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == names.length == heights.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>3</sup></code></li>\n\t<li><code>1 &lt;= names[i].length &lt;= 20</code></li>\n\t<li><code>1 &lt;= heights[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>names[i]</code> 由大小写英文字母组成</li>\n\t<li><code>heights</code> 中的所有值互不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2419按位与最大的最长子数组",
        "hardRate": "MEDIUM",
        "passRate": "42.57%",
        "problemsUrl": "https://leetcode.cn/problems/longest-subarray-with-maximum-bitwise-and/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-subarray-with-maximum-bitwise-and/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 。</p>\n\n<p>考虑 <code>nums</code> 中进行 <strong>按位与（bitwise AND）</strong>运算得到的值 <strong>最大</strong> 的 <strong>非空</strong> 子数组。</p>\n\n<ul>\n\t<li>换句话说，令 <code>k</code> 是 <code>nums</code> <strong>任意</strong> 子数组执行按位与运算所能得到的最大值。那么，只需要考虑那些执行一次按位与运算后等于 <code>k</code> 的子数组。</li>\n</ul>\n\n<p>返回满足要求的 <strong>最长</strong> 子数组的长度。</p>\n\n<p>数组的按位与就是对数组中的所有数字进行按位与运算。</p>\n\n<p><strong>子数组</strong> 是数组中的一个连续元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,3,2,2]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n子数组按位与运算的最大值是 3 。\n能得到此结果的最长子数组是 [3,3]，所以返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n子数组按位与运算的最大值是 4 。 \n能得到此结果的最长子数组是 [4]，所以返回 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2420找到所有好下标",
        "hardRate": "MEDIUM",
        "passRate": "31.39%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-good-indices/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-good-indices/solution",
        "problemsDesc": "<p>给你一个大小为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;和一个正整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>对于&nbsp;<code>k &lt;= i &lt; n - k</code>&nbsp;之间的一个下标&nbsp;<code>i</code>&nbsp;，如果它满足以下条件，我们就称它为一个&nbsp;<strong>好</strong>&nbsp;下标：</p>\n\n<ul>\n\t<li>下标 <code>i</code> <strong>之前</strong> 的 <code>k</code>&nbsp;个元素是 <strong>非递增的</strong>&nbsp;。</li>\n\t<li>下标 <code>i</code> <strong>之后</strong>&nbsp;的 <code>k</code>&nbsp;个元素是 <strong>非递减的</strong>&nbsp;。</li>\n</ul>\n\n<p>按 <strong>升序</strong>&nbsp;返回所有好下标。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,1,1,1,3,4,1], k = 2\n<b>输出：</b>[2,3]\n<b>解释：</b>数组中有两个好下标：\n- 下标 2 。子数组 [2,1] 是非递增的，子数组 [1,3] 是非递减的。\n- 下标 3 。子数组 [1,1] 是非递增的，子数组 [3,4] 是非递减的。\n注意，下标 4 不是好下标，因为 [4,1] 不是非递减的。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,1,1,2], k = 2\n<b>输出：</b>[]\n<b>解释：</b>数组中没有好下标。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n / 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2421好路径的数目",
        "hardRate": "HARD",
        "passRate": "42.65%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-good-paths/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-good-paths/solution",
        "problemsDesc": "<p>给你一棵 <code>n</code>&nbsp;个节点的树（连通无向无环的图），节点编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;且恰好有&nbsp;<code>n - 1</code>&nbsp;条边。</p>\n\n<p>给你一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>vals</code>&nbsp;，分别表示每个节点的值。同时给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code><sub>&nbsp;</sub>之间有一条&nbsp;<strong>无向</strong>&nbsp;边。</p>\n\n<p>一条 <strong>好路径</strong>&nbsp;需要满足以下条件：</p>\n\n<ol>\n\t<li>开始节点和结束节点的值 <strong>相同</strong>&nbsp;。</li>\n\t<li>开始节点和结束节点中间的所有节点值都 <strong>小于等于</strong>&nbsp;开始节点的值（也就是说开始节点的值应该是路径上所有节点的最大值）。</li>\n</ol>\n\n<p>请你返回不同好路径的数目。</p>\n\n<p>注意，一条路径和它反向的路径算作 <strong>同一</strong>&nbsp;路径。比方说，&nbsp;<code>0 -&gt; 1</code>&nbsp;与&nbsp;<code>1 -&gt; 0</code>&nbsp;视为同一条路径。单个节点也视为一条合法路径。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/08/04/f9caaac15b383af9115c5586779dec5.png\" style=\"width: 400px; height: 333px;\"></p>\n\n<pre><b>输入：</b>vals = [1,3,2,1,3], edges = [[0,1],[0,2],[2,3],[2,4]]\n<b>输出：</b>6\n<b>解释：</b>总共有 5 条单个节点的好路径。\n还有 1 条好路径：1 -&gt; 0 -&gt; 2 -&gt; 4 。\n（反方向的路径 4 -&gt; 2 -&gt; 0 -&gt; 1 视为跟 1 -&gt; 0 -&gt; 2 -&gt; 4 一样的路径）\n注意 0 -&gt; 2 -&gt; 3 不是一条好路径，因为 vals[2] &gt; vals[0] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/08/04/149d3065ec165a71a1b9aec890776ff.png\" style=\"width: 273px; height: 350px;\"></p>\n\n<pre><b>输入：</b>vals = [1,1,2,2,3], edges = [[0,1],[1,2],[2,3],[2,4]]\n<b>输出：</b>7\n<strong>解释：</strong>总共有 5 条单个节点的好路径。\n还有 2 条好路径：0 -&gt; 1 和 2 -&gt; 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/08/04/31705e22af3d9c0a557459bc7d1b62d.png\" style=\"width: 100px; height: 88px;\"></p>\n\n<pre><b>输入：</b>vals = [1], edges = []\n<b>输出：</b>1\n<b>解释：</b>这棵树只有一个节点，所以只有一条好路径。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == vals.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= vals[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>edges</code>&nbsp;表示一棵合法的树。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2422使用合并操作将数组转换为回文序列",
        "hardRate": "MEDIUM",
        "passRate": "71.47%",
        "problemsUrl": "https://leetcode.cn/problems/merge-operations-to-turn-array-into-a-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-operations-to-turn-array-into-a-palindrome/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2423删除字符使频率相同",
        "hardRate": "EASY",
        "passRate": "25.14%",
        "problemsUrl": "https://leetcode.cn/problems/remove-letter-to-equalize-frequency/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-letter-to-equalize-frequency/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>word</code>&nbsp;，字符串只包含小写英文字母。你需要选择 <strong>一个</strong>&nbsp;下标并 <strong>删除</strong>&nbsp;下标处的字符，使得 <code>word</code>&nbsp;中剩余每个字母出现 <strong>频率</strong>&nbsp;相同。</p>\n\n<p>如果删除一个字母后，<code>word</code>&nbsp;中剩余所有字母的出现频率都相同，那么返回 <code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>字母&nbsp;<code>x</code>&nbsp;的 <strong>频率</strong><strong>&nbsp;</strong>是这个字母在字符串中出现的次数。</li>\n\t<li>你 <strong>必须</strong>&nbsp;恰好删除一个字母，不能一个字母都不删除。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>word = \"abcc\"\n<b>输出：</b>true\n<b>解释：</b>选择下标 3 并删除该字母，word 变成 \"abc\" 且每个字母出现频率都为 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>word = \"aazz\"\n<b>输出：</b>false\n<b>解释：</b>我们必须删除一个字母，所以要么 \"a\" 的频率变为 1 且 \"z\" 的频率为 2 ，要么两个字母频率反过来。所以不可能让剩余所有字母出现频率相同。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= word.length &lt;= 100</code></li>\n\t<li><code>word</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2424最长上传前缀",
        "hardRate": "MEDIUM",
        "passRate": "56.04%",
        "problemsUrl": "https://leetcode.cn/problems/longest-uploaded-prefix/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-uploaded-prefix/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>n</code>&nbsp;个视频的上传序列，每个视频编号为&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;之间的 <strong>不同</strong>&nbsp;数字，你需要依次将这些视频上传到服务器。请你实现一个数据结构，在上传的过程中计算 <strong>最长上传前缀</strong>&nbsp;。</p>\n\n<p>如果&nbsp;<strong>闭区间</strong>&nbsp;<code>1</code>&nbsp;到&nbsp;<code>i</code>&nbsp;之间的视频全部都已经被上传到服务器，那么我们称 <code>i</code>&nbsp;是上传前缀。最长上传前缀指的是符合定义的 <code>i</code>&nbsp;中的 <strong>最大值</strong>&nbsp;。<br>\n<br>\n请你实现&nbsp;<code>LUPrefix</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>LUPrefix(int n)</code>&nbsp;初始化一个 <code>n</code>&nbsp;个视频的流对象。</li>\n\t<li><code>void upload(int video)</code>&nbsp;上传&nbsp;<code>video</code>&nbsp;到服务器。</li>\n\t<li><code>int longest()</code>&nbsp;返回上述定义的 <strong>最长上传前缀</strong>&nbsp;的长度。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>\n[\"LUPrefix\", \"upload\", \"longest\", \"upload\", \"longest\", \"upload\", \"longest\"]\n[[4], [3], [], [1], [], [2], []]\n<strong>输出：</strong>\n[null, null, 0, null, 1, null, 3]\n\n<strong>解释：</strong>\nLUPrefix server = new LUPrefix(4);   // 初始化 4个视频的上传流\nserver.upload(3);                    // 上传视频 3 。\nserver.longest();                    // 由于视频 1 还没有被上传，最长上传前缀是 0 。\nserver.upload(1);                    // 上传视频 1 。\nserver.longest();                    // 前缀 [1] 是最长上传前缀，所以我们返回 1 。\nserver.upload(2);                    // 上传视频 2 。\nserver.longest();                    // 前缀 [1,2,3] 是最长上传前缀，所以我们返回 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= video &lt;= 10<sup>5</sup></code></li>\n\t<li><code>video</code>&nbsp;中所有值 <strong>互不相同</strong>&nbsp;。</li>\n\t<li><code>upload</code> 和&nbsp;<code>longest</code>&nbsp;<strong>总调用</strong> 次数至多不超过&nbsp;<code>2 * 10<sup>5</sup></code>&nbsp;次。</li>\n\t<li>至少会调用&nbsp;<code>longest</code>&nbsp;一次。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2425所有数对的异或和",
        "hardRate": "MEDIUM",
        "passRate": "64.83%",
        "problemsUrl": "https://leetcode.cn/problems/bitwise-xor-of-all-pairings/",
        "solutionsUrl": "https://leetcode.cn/problems/bitwise-xor-of-all-pairings/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;，两个数组都只包含非负整数。请你求出另外一个数组&nbsp;<code>nums3</code>&nbsp;，包含 <code>nums1</code>&nbsp;和 <code>nums2</code>&nbsp;中 <strong>所有数对</strong>&nbsp;的异或和（<code>nums1</code>&nbsp;中每个整数都跟 <code>nums2</code>&nbsp;中每个整数 <strong>恰好</strong>&nbsp;匹配一次）。</p>\n\n<p>请你返回 <code>nums3</code>&nbsp;中所有整数的 <strong>异或和</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [2,1,3], nums2 = [10,2,5,0]\n<b>输出：</b>13\n<strong>解释：</strong>\n一个可能的 nums3 数组是 [8,0,7,2,11,3,4,1,9,1,6,3] 。\n所有这些数字的异或和是 13 ，所以我们返回 13 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [1,2], nums2 = [3,4]\n<b>输出：</b>0\n<strong>解释：</strong>\n所有数对异或和的结果分别为 nums1[0] ^ nums2[0] ，nums1[0] ^ nums2[1] ，nums1[1] ^ nums2[0] 和 nums1[1] ^ nums2[1] 。\n所以，一个可能的 nums3 数组是 [2,5,1,6] 。\n2 ^ 5 ^ 1 ^ 6 = 0 ，所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[j] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2426满足不等式的数对数目",
        "hardRate": "HARD",
        "passRate": "46.00%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-pairs-satisfying-inequality/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-pairs-satisfying-inequality/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>&nbsp;，两个数组的大小都为&nbsp;<code>n</code>&nbsp;，同时给你一个整数&nbsp;<code>diff</code>&nbsp;，统计满足以下条件的&nbsp;<strong>数对&nbsp;</strong><code>(i, j)</code>&nbsp;：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt;= n - 1</code>&nbsp;<b>且</b></li>\n\t<li><code>nums1[i] - nums1[j] &lt;= nums2[i] - nums2[j] + diff</code>.</li>\n</ul>\n\n<p>请你返回满足条件的 <strong>数对数目</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums1 = [3,2,5], nums2 = [2,2,1], diff = 1\n<b>输出：</b>3\n<strong>解释：</strong>\n总共有 3 个满足条件的数对：\n1. i = 0, j = 1：3 - 2 &lt;= 2 - 2 + 1 。因为 i &lt; j 且 1 &lt;= 1 ，这个数对满足条件。\n2. i = 0, j = 2：3 - 5 &lt;= 2 - 1 + 1 。因为 i &lt; j 且 -2 &lt;= 2 ，这个数对满足条件。\n3. i = 1, j = 2：2 - 5 &lt;= 2 - 1 + 1 。因为 i &lt; j 且 -3 &lt;= 2 ，这个数对满足条件。\n所以，我们返回 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums1 = [3,-1], nums2 = [-2,2], diff = -1\n<b>输出：</b>0\n<strong>解释：</strong>\n没有满足条件的任何数对，所以我们返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length == nums2.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= diff &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2427公因子的数目",
        "hardRate": "EASY",
        "passRate": "81.66%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-common-factors/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-common-factors/solution",
        "problemsDesc": "<p>给你两个正整数 <code>a</code> 和 <code>b</code> ，返回 <code>a</code> 和 <code>b</code> 的 <strong>公</strong> 因子的数目。</p>\n\n<p>如果 <code>x</code> 可以同时整除 <code>a</code> 和 <code>b</code> ，则认为 <code>x</code> 是 <code>a</code> 和 <code>b</code> 的一个 <strong>公因子</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>a = 12, b = 6\n<strong>输出：</strong>4\n<strong>解释：</strong>12 和 6 的公因子是 1、2、3、6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>a = 25, b = 30\n<strong>输出：</strong>2\n<strong>解释：</strong>25 和 30 的公因子是 1、5 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a, b &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2428沙漏的最大总和",
        "hardRate": "MEDIUM",
        "passRate": "74.74%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-of-an-hourglass/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-of-an-hourglass/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m x n</code> 的整数矩阵 <code>grid</code> 。</p>\n\n<p>按以下形式将矩阵的一部分定义为一个 <strong>沙漏</strong> ：</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/08/21/img.jpg\" style=\"width: 243px; height: 243px;\">\n<p>返回沙漏中元素的 <strong>最大</strong> 总和。</p>\n\n<p><strong>注意：</strong>沙漏无法旋转且必须整个包含在矩阵中。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/08/21/1.jpg\" style=\"width: 323px; height: 323px;\">\n<pre><strong>输入：</strong>grid = [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]]\n<strong>输出：</strong>30\n<strong>解释：</strong>上图中的单元格表示元素总和最大的沙漏：6 + 2 + 1 + 2 + 9 + 2 + 8 = 30 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/08/21/2.jpg\" style=\"width: 243px; height: 243px;\">\n<pre><strong>输入：</strong>grid = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>35\n<strong>解释：</strong>上图中的单元格表示元素总和最大的沙漏：1 + 2 + 3 + 5 + 7 + 8 + 9 = 35 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>3 &lt;= m, n &lt;= 150</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2429最小 XOR",
        "hardRate": "MEDIUM",
        "passRate": "44.47%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-xor/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-xor/solution",
        "problemsDesc": "<p>给你两个正整数 <code>num1</code> 和 <code>num2</code> ，找出满足下述条件的整数 <code>x</code> ：</p>\n\n<ul>\n\t<li><code>x</code> 的置位数和 <code>num2</code> 相同，且</li>\n\t<li><code>x XOR num1</code> 的值 <strong>最小</strong></li>\n</ul>\n\n<p>注意 <code>XOR</code> 是按位异或运算。</p>\n\n<p>返回整数<em> </em><code>x</code> 。题目保证，对于生成的测试用例， <code>x</code> 是 <strong>唯一确定</strong> 的。</p>\n\n<p>整数的 <strong>置位数</strong> 是其二进制表示中 <code>1</code> 的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num1 = 3, num2 = 5\n<strong>输出：</strong>3\n<strong>解释：</strong>\nnum1 和 num2 的二进制表示分别是 0011 和 0101 。\n整数 <strong>3</strong> 的置位数与 num2 相同，且 <code>3 XOR 3 = 0</code> 是最小的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num1 = 1, num2 = 12\n<strong>输出：</strong>3\n<strong>解释：</strong>\nnum1 和 num2 的二进制表示分别是 0001 和 1100 。\n整数 <strong>3</strong> 的置位数与 num2 相同，且 <code>3 XOR 1 = 2</code> 是最小的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num1, num2 &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2430对字母串可执行的最大删除数",
        "hardRate": "HARD",
        "passRate": "47.71%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-deletions-on-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-deletions-on-a-string/solution",
        "problemsDesc": "<p>给你一个仅由小写英文字母组成的字符串 <code>s</code> 。在一步操作中，你可以：</p>\n\n<ul>\n\t<li>删除 <strong>整个字符串</strong> <code>s</code> ，或者</li>\n\t<li>对于满足&nbsp;<code>1 &lt;= i &lt;= s.length / 2</code> 的任意 <code>i</code> ，如果 <code>s</code> 中的 <strong>前</strong> <code>i</code> 个字母和接下来的 <code>i</code> 个字母 <strong>相等</strong> ，删除 <strong>前</strong> <code>i</code> 个字母。</li>\n</ul>\n\n<p>例如，如果 <code>s = \"ababc\"</code> ，那么在一步操作中，你可以删除 <code>s</code> 的前两个字母得到 <code>\"abc\"</code> ，因为 <code>s</code> 的前两个字母和接下来的两个字母都等于 <code>\"ab\"</code> 。</p>\n\n<p>返回删除 <code>s</code> 所需的最大操作数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcabcdabc\"\n<strong>输出：</strong>2\n<strong>解释：</strong>\n- 删除前 3 个字母（\"abc\"），因为它们和接下来 3 个字母相等。现在，s = \"abcdabc\"。\n- 删除全部字母。\n一共用了 2 步操作，所以返回 2 。可以证明 2 是所需的最大操作数。\n注意，在第二步操作中无法再次删除 \"abc\" ，因为 \"abc\" 的下一次出现并不是位于接下来的 3 个字母。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aaabaab\"\n<strong>输出：</strong>4\n<strong>解释：</strong>\n- 删除第一个字母（\"a\"），因为它和接下来的字母相等。现在，s = \"aabaab\"。\n- 删除前 3 个字母（\"aab\"），因为它们和接下来 3 个字母相等。现在，s = \"aab\"。 \n- 删除第一个字母（\"a\"），因为它和接下来的字母相等。现在，s = \"ab\"。\n- 删除全部字母。\n一共用了 4 步操作，所以返回 4 。可以证明 4 是所需的最大操作数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aaaaa\"\n<strong>输出：</strong>5\n<strong>解释：</strong>在每一步操作中，都可以仅删除 s 的第一个字母。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 4000</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2431最大限度地提高购买水果的口味",
        "hardRate": "MEDIUM",
        "passRate": "58.76%",
        "problemsUrl": "https://leetcode.cn/problems/maximize-total-tastiness-of-purchased-fruits/",
        "solutionsUrl": "https://leetcode.cn/problems/maximize-total-tastiness-of-purchased-fruits/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2432处理用时最长的那个任务的员工",
        "hardRate": "EASY",
        "passRate": "55.20%",
        "problemsUrl": "https://leetcode.cn/problems/the-employee-that-worked-on-the-longest-task/",
        "solutionsUrl": "https://leetcode.cn/problems/the-employee-that-worked-on-the-longest-task/solution",
        "problemsDesc": "<p>共有 <code>n</code> 位员工，每位员工都有一个从 <code>0</code> 到 <code>n - 1</code> 的唯一 id 。</p>\n\n<p>给你一个二维整数数组 <code>logs</code> ，其中 <code>logs[i] = [id<sub>i</sub>, leaveTime<sub>i</sub>]</code> ：</p>\n\n<ul>\n\t<li><code>id<sub>i</sub></code> 是处理第 <code>i</code> 个任务的员工的 id ，且</li>\n\t<li><code>leaveTime<sub>i</sub></code> 是员工完成第 <code>i</code> 个任务的时刻。所有 <code>leaveTime<sub>i</sub></code> 的值都是 <strong>唯一</strong> 的。</li>\n</ul>\n\n<p>注意，第 <code>i</code> 个任务在第 <code>(i - 1)</code> 个任务结束后立即开始，且第 <code>0</code> 个任务从时刻 <code>0</code> 开始。</p>\n\n<p>返回处理用时最长的那个任务的员工的 id 。如果存在两个或多个员工同时满足，则返回几人中 <strong>最小</strong> 的 id 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10, logs = [[0,3],[2,5],[0,9],[1,15]]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n任务 0 于时刻 0 开始，且在时刻 3 结束，共计 3 个单位时间。\n任务 1 于时刻 3 开始，且在时刻 5 结束，共计 2 个单位时间。\n任务 2 于时刻 5 开始，且在时刻 9 结束，共计 4 个单位时间。\n任务 3 于时刻 9 开始，且在时刻 15 结束，共计 6 个单位时间。\n时间最长的任务是任务 3 ，而 id 为 1 的员工是处理此任务的员工，所以返回 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 26, logs = [[1,1],[3,7],[2,12],[7,17]]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n任务 0 于时刻 0 开始，且在时刻 1 结束，共计 1 个单位时间。\n任务 1 于时刻 1 开始，且在时刻 7 结束，共计 6 个单位时间。\n任务 2 于时刻 7 开始，且在时刻 12 结束，共计 5 个单位时间。\n任务 3 于时刻 12 开始，且在时刻 17 结束，共计 5 个单位时间。\n时间最长的任务是任务 1 ，而 id 为 3 的员工是处理此任务的员工，所以返回 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, logs = [[0,10],[1,20]]\n<strong>输出：</strong>0\n<strong>解释：</strong>\n任务 0 于时刻 0 开始，且在时刻 10 结束，共计 10 个单位时间。\n任务 1 于时刻 10 开始，且在时刻 20 结束，共计 10 个单位时间。\n时间最长的任务是任务 0 和 1 ，处理这两个任务的员工的 id 分别是 0 和 1 ，所以返回最小的 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= logs.length &lt;= 500</code></li>\n\t<li><code>logs[i].length == 2</code></li>\n\t<li><code>0 &lt;= id<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>1 &lt;= leaveTime<sub>i</sub> &lt;= 500</code></li>\n\t<li><code>id<sub>i</sub> != id<sub>i + 1</sub></code></li>\n\t<li><code>leaveTime<sub>i</sub></code> 按严格递增顺序排列</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2433找出前缀异或的原始数组",
        "hardRate": "MEDIUM",
        "passRate": "84.80%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-original-array-of-prefix-xor/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-original-array-of-prefix-xor/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的 <strong>整数</strong> 数组 <code>pref</code> 。找出并返回满足下述条件且长度为 <code>n</code> 的数组<em> </em><code>arr</code> ：</p>\n\n<ul>\n\t<li><code>pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]</code>.</li>\n</ul>\n\n<p>注意 <code>^</code> 表示 <strong>按位异或</strong>（bitwise-xor）运算。</p>\n\n<p>可以证明答案是 <strong>唯一</strong> 的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>pref = [5,2,0,3,1]\n<strong>输出：</strong>[5,7,2,3,2]\n<strong>解释：</strong>从数组 [5,7,2,3,2] 可以得到如下结果：\n- pref[0] = 5\n- pref[1] = 5 ^ 7 = 2\n- pref[2] = 5 ^ 7 ^ 2 = 0\n- pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3\n- pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>pref = [13]\n<strong>输出：</strong>[13]\n<strong>解释：</strong>pref[0] = arr[0] = 13\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pref.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= pref[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2434使用机器人打印字典序最小的字符串",
        "hardRate": "MEDIUM",
        "passRate": "42.09%",
        "problemsUrl": "https://leetcode.cn/problems/using-a-robot-to-print-the-lexicographically-smallest-string/",
        "solutionsUrl": "https://leetcode.cn/problems/using-a-robot-to-print-the-lexicographically-smallest-string/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;和一个机器人，机器人当前有一个空字符串&nbsp;<code>t</code>&nbsp;。执行以下操作之一，直到&nbsp;<code>s</code> 和&nbsp;<code>t</code>&nbsp;<strong>都变成空字符串：</strong></p>\n\n<ul>\n\t<li>删除字符串&nbsp;<code>s</code>&nbsp;的 <strong>第一个</strong>&nbsp;字符，并将该字符给机器人。机器人把这个字符添加到 <code>t</code>&nbsp;的尾部。</li>\n\t<li>删除字符串&nbsp;<code>t</code>&nbsp;的&nbsp;<strong>最后一个</strong>&nbsp;字符，并将该字符给机器人。机器人将该字符写到纸上。</li>\n</ul>\n\n<p>请你返回纸上能写出的字典序最小的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>s = \"zza\"\n<b>输出：</b>\"azz\"\n<b>解释：</b>用 p 表示写出来的字符串。\n一开始，p=\"\" ，s=\"zza\" ，t=\"\" 。\n执行第一个操作三次，得到 p=\"\" ，s=\"\" ，t=\"zza\" 。\n执行第二个操作三次，得到 p=\"azz\" ，s=\"\" ，t=\"\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"bac\"\n<b>输出：</b>\"abc\"\n<b>解释：</b>用 p 表示写出来的字符串。\n执行第一个操作两次，得到 p=\"\" ，s=\"c\" ，t=\"ba\" 。\n执行第二个操作两次，得到 p=\"ab\" ，s=\"c\" ，t=\"\" 。\n执行第一个操作，得到 p=\"ab\" ，s=\"\" ，t=\"c\" 。\n执行第二个操作，得到 p=\"abc\" ，s=\"\" ，t=\"\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>s = \"bdda\"\n<b>输出：</b>\"addb\"\n<b>解释：</b>用 p 表示写出来的字符串。\n一开始，p=\"\" ，s=\"bdda\" ，t=\"\" 。\n执行第一个操作四次，得到 p=\"\" ，s=\"\" ，t=\"bdda\" 。\n执行第二个操作四次，得到 p=\"addb\" ，s=\"\" ，t=\"\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2435矩阵中和能被 K 整除的路径",
        "hardRate": "HARD",
        "passRate": "51.46%",
        "problemsUrl": "https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/",
        "solutionsUrl": "https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;整数矩阵&nbsp;<code>grid</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。你从起点&nbsp;<code>(0, 0)</code>&nbsp;出发，每一步只能往 <strong>下</strong>&nbsp;或者往 <strong>右</strong>&nbsp;，你想要到达终点&nbsp;<code>(m - 1, n - 1)</code>&nbsp;。</p>\n\n<p>请你返回路径和能被 <code>k</code>&nbsp;整除的路径数目，由于答案可能很大，返回答案对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2022/08/13/image-20220813183124-1.png\" style=\"width: 437px; height: 200px;\"></p>\n\n<pre><b>输入：</b>grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3\n<b>输出：</b>2\n<b>解释：</b>有两条路径满足路径上元素的和能被 k 整除。\n第一条路径为上图中用红色标注的路径，和为 5 + 2 + 4 + 5 + 2 = 18 ，能被 3 整除。\n第二条路径为上图中用蓝色标注的路径，和为 5 + 3 + 0 + 5 + 2 = 15 ，能被 3 整除。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/08/17/image-20220817112930-3.png\" style=\"height: 85px; width: 132px;\">\n<pre><b>输入：</b>grid = [[0,0]], k = 5\n<b>输出：</b>1\n<b>解释：</b>红色标注的路径和为 0 + 0 = 0 ，能被 5 整除。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/08/12/image-20220812224605-3.png\" style=\"width: 257px; height: 200px;\">\n<pre><b>输入：</b>grid = [[7,3,4,9],[2,3,6,2],[2,3,7,0]], k = 1\n<b>输出：</b>10\n<b>解释：</b>每个数字都能被 1 整除，所以每一条路径的和都能被 k 整除。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 100</code></li>\n\t<li><code>1 &lt;= k &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2436使子数组最大公约数大于一的最小分割数",
        "hardRate": "MEDIUM",
        "passRate": "76.98%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-split-into-subarrays-with-gcd-greater-than-one/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-split-into-subarrays-with-gcd-greater-than-one/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2437有效时间的数目",
        "hardRate": "EASY",
        "passRate": "50.50%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-valid-clock-times/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-valid-clock-times/solution",
        "problemsDesc": "<p>给你一个长度为&nbsp;<code>5</code>&nbsp;的字符串&nbsp;<code>time</code>&nbsp;，表示一个电子时钟当前的时间，格式为&nbsp;<code>\"hh:mm\"</code>&nbsp;。<strong>最早</strong>&nbsp;可能的时间是&nbsp;<code>\"00:00\"</code>&nbsp;，<strong>最晚</strong>&nbsp;可能的时间是&nbsp;<code>\"23:59\"</code>&nbsp;。</p>\n\n<p>在字符串&nbsp;<code>time</code>&nbsp;中，被字符&nbsp;<code>?</code>&nbsp;替换掉的数位是 <strong>未知的</strong>&nbsp;，被替换的数字可能是&nbsp;<code>0</code>&nbsp;到&nbsp;<code>9</code>&nbsp;中的任何一个。</p>\n\n<p>请你返回一个整数<em>&nbsp;</em><code>answer</code>&nbsp;，将每一个 <code>?</code>&nbsp;都用<em>&nbsp;</em><code>0</code>&nbsp;到<em>&nbsp;</em><code>9</code>&nbsp;中一个数字替换后，可以得到的有效时间的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>time = \"?5:00\"\n<b>输出：</b>2\n<b>解释：</b>我们可以将 ? 替换成 0 或 1 ，得到 \"05:00\" 或者 \"15:00\" 。注意我们不能替换成 2 ，因为时间 \"25:00\" 是无效时间。所以我们有两个选择。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>time = \"0?:0?\"\n<b>输出：</b>100\n<b>解释：</b>两个 ? 都可以被 0 到 9 之间的任意数字替换，所以我们总共有 100 种选择。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>time = \"??:??\"\n<b>输出：</b>1440\n<b>解释：</b>小时总共有 24 种选择，分钟总共有 60 种选择。所以总共有 24 * 60 = 1440 种选择。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>time</code>&nbsp;是一个长度为 <code>5</code>&nbsp;的有效字符串，格式为&nbsp;<code>\"hh:mm\"</code>&nbsp;。</li>\n\t<li><code>\"00\" &lt;= hh &lt;= \"23\"</code></li>\n\t<li><code>\"00\" &lt;= mm &lt;= \"59\"</code></li>\n\t<li>字符串中有的数位是&nbsp;<code>'?'</code>&nbsp;，需要用&nbsp;<code>0</code>&nbsp;到&nbsp;<code>9</code>&nbsp;之间的数字替换。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2438二的幂数组中查询范围内的乘积",
        "hardRate": "MEDIUM",
        "passRate": "41.19%",
        "problemsUrl": "https://leetcode.cn/problems/range-product-queries-of-powers/",
        "solutionsUrl": "https://leetcode.cn/problems/range-product-queries-of-powers/solution",
        "problemsDesc": "<p>给你一个正整数&nbsp;<code>n</code>&nbsp;，你需要找到一个下标从&nbsp;<strong>0</strong>&nbsp;开始的数组&nbsp;<code>powers</code>&nbsp;，它包含 <strong>最少</strong>&nbsp;数目的 <code>2</code>&nbsp;的幂，且它们的和为&nbsp;<code>n</code>&nbsp;。<code>powers</code>&nbsp;数组是&nbsp;<strong>非递减</strong>&nbsp;顺序的。根据前面描述，构造&nbsp;<code>powers</code>&nbsp;数组的方法是唯一的。</p>\n\n<p>同时给你一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>queries</code>&nbsp;，其中&nbsp;<code>queries[i] = [left<sub>i</sub>, right<sub>i</sub>]</code>&nbsp;，其中&nbsp;<code>queries[i]</code>&nbsp;表示请你求出满足&nbsp;<code>left<sub>i</sub> &lt;= j &lt;= right<sub>i</sub></code>&nbsp;的所有&nbsp;<code>powers[j]</code>&nbsp;的乘积。</p>\n\n<p>请你返回一个数组<em>&nbsp;</em><code>answers</code>&nbsp;，长度与<em>&nbsp;</em><code>queries</code>&nbsp;的长度相同，其中<em>&nbsp;</em><code>answers[i]</code>是第<em>&nbsp;</em><code>i</code>&nbsp;个查询的答案。由于查询的结果可能非常大，请你将每个&nbsp;<code>answers[i]</code>&nbsp;都对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>n = 15, queries = [[0,1],[2,2],[0,3]]\n<b>输出：</b>[2,4,64]\n<strong>解释：</strong>\n对于 n = 15 ，得到 powers = [1,2,4,8] 。没法得到元素数目更少的数组。\n第 1 个查询的答案：powers[0] * powers[1] = 1 * 2 = 2 。\n第 2 个查询的答案：powers[2] = 4 。\n第 3 个查询的答案：powers[0] * powers[1] * powers[2] * powers[3] = 1 * 2 * 4 * 8 = 64 。\n每个答案对 10<sup>9</sup> + 7 得到的结果都相同，所以返回 [2,4,64] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 2, queries = [[0,0]]\n<b>输出：</b>[2]\n<strong>解释：</strong>\n对于 n = 2, powers = [2] 。\n唯一一个查询的答案是 powers[0] = 2 。答案对 10<sup>9</sup> + 7 取余后结果相同，所以返回 [2] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt; powers.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2439最小化数组中的最大值",
        "hardRate": "MEDIUM",
        "passRate": "39.16%",
        "problemsUrl": "https://leetcode.cn/problems/minimize-maximum-of-array/",
        "solutionsUrl": "https://leetcode.cn/problems/minimize-maximum-of-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>nums</code>&nbsp;，它含有&nbsp;<code>n</code>&nbsp;个非负整数。</p>\n\n<p>每一步操作中，你需要：</p>\n\n<ul>\n\t<li>选择一个满足&nbsp;<code>1 &lt;= i &lt; n</code>&nbsp;的整数 <code>i</code>&nbsp;，且&nbsp;<code>nums[i] &gt; 0</code>&nbsp;。</li>\n\t<li>将&nbsp;<code>nums[i]</code>&nbsp;减 1 。</li>\n\t<li>将&nbsp;<code>nums[i - 1]</code>&nbsp;加 1 。</li>\n</ul>\n\n<p>你可以对数组执行 <strong>任意</strong>&nbsp;次上述操作，请你返回可以得到的 <code>nums</code>&nbsp;数组中<b>&nbsp;最大值</b>&nbsp;<strong>最小</strong> 为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [3,7,1,6]\n<b>输出：</b>5\n<strong>解释：</strong>\n一串最优操作是：\n1. 选择 i = 1 ，nums 变为 [4,6,1,6] 。\n2. 选择 i = 3 ，nums 变为 [4,6,2,5] 。\n3. 选择 i = 1 ，nums 变为 [5,5,2,5] 。\nnums 中最大值为 5 。无法得到比 5 更小的最大值。\n所以我们返回 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [10,1]\n<b>输出：</b>10\n<strong>解释：</strong>\n最优解是不改动 nums ，10 是最大值，所以返回 10 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2440创建价值相同的连通块",
        "hardRate": "HARD",
        "passRate": "61.40%",
        "problemsUrl": "https://leetcode.cn/problems/create-components-with-same-value/",
        "solutionsUrl": "https://leetcode.cn/problems/create-components-with-same-value/solution",
        "problemsDesc": "<p>有一棵&nbsp;<code>n</code>&nbsp;个节点的无向树，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。</p>\n\n<p>给你一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，其中&nbsp;<code>nums[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个节点的值。同时给你一个长度为 <code>n - 1</code>&nbsp;的二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示节点&nbsp;<code>a<sub>i</sub></code>&nbsp;与&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条边。</p>\n\n<p>你可以 <strong>删除</strong>&nbsp;一些边，将这棵树分成几个连通块。一个连通块的 <strong>价值</strong>&nbsp;定义为这个连通块中 <strong>所有</strong> 节点 <code>i</code>&nbsp;对应的 <code>nums[i]</code>&nbsp;之和。</p>\n\n<p>你需要删除一些边，删除后得到的各个连通块的价值都相等。请返回你可以删除的边数&nbsp;<strong>最多</strong>&nbsp;为多少。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/08/26/diagramdrawio.png\" style=\"width: 441px; height: 351px;\"></p>\n\n<pre><b>输入：</b>nums = [6,2,2,2,6], edges = [[0,1],[1,2],[1,3],[3,4]] \n<b>输出：</b>2 \n<b>解释：</b>上图展示了我们可以删除边 [0,1] 和 [3,4] 。得到的连通块为 [0] ，[1,2,3] 和 [4] 。每个连通块的价值都为 6 。可以证明没有别的更好的删除方案存在了，所以答案为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [2], edges = []\n<b>输出：</b>0\n<b>解释：</b>没有任何边可以删除。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>nums.length == n</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 50</code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= edges[i][0], edges[i][1] &lt;= n - 1</code></li>\n\t<li><code>edges</code>&nbsp;表示一棵合法的树。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2441与对应负数同时存在的最大正整数",
        "hardRate": "EASY",
        "passRate": "72.55%",
        "problemsUrl": "https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/solution",
        "problemsDesc": "<p>给你一个 <strong>不包含</strong> 任何零的整数数组 <code>nums</code> ，找出自身与对应的负数都在数组中存在的最大正整数 <code>k</code> 。</p>\n\n<p>返回正整数<em> </em><code>k</code> ，如果不存在这样的整数，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,2,-3,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>3 是数组中唯一一个满足题目要求的 k 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,10,6,7,-7,1]\n<strong>输出：</strong>7\n<strong>解释：</strong>数组中存在 1 和 7 对应的负数，7 的值更大。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-10,8,6,7,-2,-3]\n<strong>输出：</strong>-1\n<strong>解释：</strong>不存在满足题目要求的 k ，返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>nums[i] != 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2442反转之后不同整数的数目",
        "hardRate": "MEDIUM",
        "passRate": "75.12%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-distinct-integers-after-reverse-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-distinct-integers-after-reverse-operations/solution",
        "problemsDesc": "<p>给你一个由 <strong>正</strong> 整数组成的数组 <code>nums</code> 。</p>\n\n<p>你必须取出数组中的每个整数，<strong>反转其中每个数位</strong>，并将反转后得到的数字添加到数组的末尾。这一操作只针对 <code>nums</code> 中原有的整数执行。</p>\n\n<p>返回结果数组中 <strong>不同</strong> 整数的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,13,10,12,31]\n<strong>输出：</strong>6\n<strong>解释：</strong>反转每个数字后，结果数组是 [1,13,10,12,31,<em><strong>1,31,1,21,13</strong></em>] 。\n反转后得到的数字添加到数组的末尾并按斜体加粗表示。注意对于整数 10 ，反转之后会变成 01 ，即 1 。\n数组中不同整数的数目为 6（数字 1、10、12、13、21 和 31）。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>反转每个数字后，结果数组是 [2,2,2,<em><strong>2,2,2</strong></em>] 。\n数组中不同整数的数目为 1（数字 2）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2443反转之后的数字和",
        "hardRate": "MEDIUM",
        "passRate": "46.46%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-number-and-its-reverse/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-number-and-its-reverse/solution",
        "problemsDesc": "<p>给你一个 <strong>非负</strong> 整数 <code>num</code> 。如果存在某个 <strong>非负</strong> 整数 <code>k</code> 满足 <code>k + reverse(k) = num</code>&nbsp; ，则返回 <code>true</code> ；否则，返回<em> </em><code>false</code> 。</p>\n\n<p><code>reverse(k)</code> 表示 <code>k</code> 反转每个数位后得到的数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 443\n<strong>输出：</strong>true\n<strong>解释：</strong>172 + 271 = 443 ，所以返回 true 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 63\n<strong>输出：</strong>false\n<strong>解释：</strong>63 不能表示为非负整数及其反转后数字之和，返回 false 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 181\n<strong>输出：</strong>true\n<strong>解释：</strong>140 + 041 = 181 ，所以返回 true 。注意，反转后的数字可能包含前导零。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2444统计定界子数组的数目",
        "hardRate": "HARD",
        "passRate": "44.45%",
        "problemsUrl": "https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/",
        "solutionsUrl": "https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和两个整数 <code>minK</code> 以及 <code>maxK</code> 。</p>\n\n<p><code>nums</code> 的定界子数组是满足下述条件的一个子数组：</p>\n\n<ul>\n\t<li>子数组中的 <strong>最小值</strong> 等于 <code>minK</code> 。</li>\n\t<li>子数组中的 <strong>最大值</strong> 等于 <code>maxK</code> 。</li>\n</ul>\n\n<p>返回定界子数组的数目。</p>\n\n<p>子数组是数组中的一个连续部分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,3,5,2,7,5], minK = 1, maxK = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>定界子数组是 [1,3,5] 和 [1,3,5,2] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,1,1], minK = 1, maxK = 1\n<strong>输出：</strong>10\n<strong>解释：</strong>nums 的每个子数组都是一个定界子数组。共有 10 个子数组。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], minK, maxK &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2445值为 1 的节点数",
        "hardRate": "MEDIUM",
        "passRate": "78.33%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-nodes-with-value-one/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-nodes-with-value-one/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2446判断两个事件是否存在冲突",
        "hardRate": "EASY",
        "passRate": "63.53%",
        "problemsUrl": "https://leetcode.cn/problems/determine-if-two-events-have-conflict/",
        "solutionsUrl": "https://leetcode.cn/problems/determine-if-two-events-have-conflict/solution",
        "problemsDesc": "<p>给你两个字符串数组 <code>event1</code> 和&nbsp;<code>event2</code>&nbsp;，表示发生在同一天的两个闭区间时间段事件，其中：</p>\n\n<ul>\n\t<li><code>event1 = [startTime<sub>1</sub>, endTime<sub>1</sub>]</code> 且</li>\n\t<li><code>event2 = [startTime<sub>2</sub>, endTime<sub>2</sub>]</code></li>\n</ul>\n\n<p>事件的时间为有效的 24 小时制且按&nbsp;<code>HH:MM</code>&nbsp;格式给出。</p>\n\n<p>当两个事件存在某个非空的交集时（即，某些时刻是两个事件都包含的），则认为出现 <strong>冲突</strong>&nbsp;。</p>\n\n<p>如果两个事件之间存在冲突，返回&nbsp;<code>true</code><em>&nbsp;</em>；否则，返回<em>&nbsp;</em><code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre>\n<b>输入：</b>event1 = [\"01:15\",\"02:00\"], event2 = [\"02:00\",\"03:00\"]\n<b>输出：</b>true\n<b>解释：</b>两个事件在 2:00 出现交集。\n</pre>\n\n<p><b>示例 2：</b></p>\n\n<pre>\n<b>输入：</b>event1 = [\"01:00\",\"02:00\"], event2 = [\"01:20\",\"03:00\"]\n<b>输出：</b>true\n<b>解释：</b>两个事件的交集从 01:20 开始，到 02:00 结束。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>event1 = [\"10:00\",\"11:00\"], event2 = [\"14:00\",\"15:00\"]\n<b>输出：</b>false\n<b>解释：</b>两个事件不存在交集。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>event1.length == event2.length == 2.</code></li>\n\t<li><code>event1[i].length == event2[i].length == 5</code></li>\n\t<li><code>startTime<sub>1</sub> &lt;= endTime<sub>1</sub></code></li>\n\t<li><code>startTime<sub>2</sub> &lt;= endTime<sub>2</sub></code></li>\n\t<li>所有事件的时间都按照&nbsp;<code>HH:MM</code>&nbsp;格式给出</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2447最大公因数等于 K 的子数组数目",
        "hardRate": "MEDIUM",
        "passRate": "41.24%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-subarrays-with-gcd-equal-to-k/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-subarrays-with-gcd-equal-to-k/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code> ，请你统计并返回 <code>nums</code>&nbsp;的子数组中元素的最大公因数等于 <code>k</code>&nbsp;的子数组数目。</p>\n\n<p><strong>子数组</strong> 是数组中一个连续的非空序列。</p>\n\n<p><strong>数组的最大公因数</strong>&nbsp;是能整除数组中所有元素的最大整数。</p>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n\n<pre><b>输入：</b>nums = [9,3,1,2,6,3], k = 3\n<b>输出：</b>4\n<b>解释：</b>nums 的子数组中，以 3 作为最大公因数的子数组如下：\n- [9,<strong><em>3</em></strong>,1,2,6,3]\n- [9,3,1,2,6,<em><strong>3</strong></em>]\n- [<strong><em>9,3</em></strong>,1,2,6,3]\n- [9,3,1,2,<em><strong>6,3</strong></em>]\n</pre>\n\n<p><b>示例 2：</b></p>\n\n<pre><b>输入：</b>nums = [4], k = 7\n<b>输出：</b>0\n<b>解释：</b>不存在以 7 作为最大公因数的子数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2448使数组相等的最小开销",
        "hardRate": "HARD",
        "passRate": "36.09%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-make-array-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-make-array-equal/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>nums</code> 和&nbsp;<code>cost</code>&nbsp;，分别包含&nbsp;<code>n</code>&nbsp;个&nbsp;<strong>正</strong>&nbsp;整数。</p>\n\n<p>你可以执行下面操作 <strong>任意</strong>&nbsp;次：</p>\n\n<ul>\n\t<li>将&nbsp;<code>nums</code>&nbsp;中 <strong>任意</strong>&nbsp;元素增加或者减小 <code>1</code>&nbsp;。</li>\n</ul>\n\n<p>对第 <code>i</code>&nbsp;个元素执行一次操作的开销是&nbsp;<code>cost[i]</code>&nbsp;。</p>\n\n<p>请你返回使 <code>nums</code>&nbsp;中所有元素 <strong>相等</strong>&nbsp;的 <strong>最少</strong>&nbsp;总开销。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,3,5,2], cost = [2,3,1,14]\n<b>输出：</b>8\n<b>解释：</b>我们可以执行以下操作使所有元素变为 2 ：\n- 增加第 0 个元素 1 次，开销为 2 。\n- 减小第 1 个元素 1 次，开销为 3 。\n- 减小第 2 个元素 3 次，开销为 1 + 1 + 1 = 3 。\n总开销为 2 + 3 + 3 = 8 。\n这是最小开销。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,2,2,2,2], cost = [4,2,8,1,3]\n<b>输出：</b>0\n<b>解释：</b>数组中所有元素已经全部相等，不需要执行额外的操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length == cost.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], cost[i] &lt;= 10<sup>6</sup></code></li>\n\t<li>测试用例确保输出不超过 2<sup>53</sup>-1。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2449使数组相似的最少操作次数",
        "hardRate": "HARD",
        "passRate": "65.44%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-make-arrays-similar/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-make-arrays-similar/solution",
        "problemsDesc": "<p>给你两个正整数数组&nbsp;<code>nums</code> 和&nbsp;<code>target</code>&nbsp;，两个数组长度相等。</p>\n\n<p>在一次操作中，你可以选择两个 <strong>不同</strong>&nbsp;的下标&nbsp;<code>i</code> 和&nbsp;<code>j</code>&nbsp;，其中&nbsp;<code>0 &lt;= i, j &lt; nums.length</code>&nbsp;，并且：</p>\n\n<ul>\n\t<li>令&nbsp;<code>nums[i] = nums[i] + 2</code>&nbsp;且</li>\n\t<li>令&nbsp;<code>nums[j] = nums[j] - 2</code>&nbsp;。</li>\n</ul>\n\n<p>如果两个数组中每个元素出现的频率相等，我们称两个数组是 <strong>相似</strong>&nbsp;的。</p>\n\n<p>请你返回将 <code>nums</code>&nbsp;变得与 <code>target</code>&nbsp;相似的最少操作次数。测试数据保证 <code>nums</code>&nbsp;一定能变得与 <code>target</code>&nbsp;相似。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [8,12,6], target = [2,14,10]\n<b>输出：</b>2\n<b>解释：</b>可以用两步操作将 nums 变得与 target 相似：\n- 选择 i = 0 和 j = 2 ，nums = [10,12,4] 。\n- 选择 i = 1 和 j = 2 ，nums = [10,14,2] 。\n2 次操作是最少需要的操作次数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,2,5], target = [4,1,3]\n<b>输出：</b>1\n<b>解释：</b>一步操作可以使 nums 变得与 target 相似：\n- 选择 i = 1 和 j = 2 ，nums = [1,4,3] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,1,1,1,1], target = [1,1,1,1,1]\n<b>输出：</b>0\n<b>解释：</b>数组 nums 已经与 target 相似。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length == target.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], target[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>nums</code>&nbsp;一定可以变得与&nbsp;<code>target</code> 相似。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2450应用操作后不同二进制字符串的数量",
        "hardRate": "MEDIUM",
        "passRate": "75.59%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-distinct-binary-strings-after-applying-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-distinct-binary-strings-after-applying-operations/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2451差值数组不同的字符串",
        "hardRate": "EASY",
        "passRate": "66.30%",
        "problemsUrl": "https://leetcode.cn/problems/odd-string-difference/",
        "solutionsUrl": "https://leetcode.cn/problems/odd-string-difference/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>words</code>&nbsp;，每一个字符串长度都相同，令所有字符串的长度都为 <code>n</code>&nbsp;。</p>\n\n<p>每个字符串&nbsp;<code>words[i]</code>&nbsp;可以被转化为一个长度为&nbsp;<code>n - 1</code>&nbsp;的&nbsp;<strong>差值整数数组</strong>&nbsp;<code>difference[i]</code>&nbsp;，其中对于&nbsp;<code>0 &lt;= j &lt;= n - 2</code>&nbsp;有&nbsp;<code>difference[i][j] = words[i][j+1] - words[i][j]</code>&nbsp;。注意两个字母的差值定义为它们在字母表中&nbsp;<strong>位置</strong>&nbsp;之差，也就是说&nbsp;<code>'a'</code>&nbsp;的位置是&nbsp;<code>0</code>&nbsp;，<code>'b'</code>&nbsp;的位置是&nbsp;<code>1</code>&nbsp;，<code>'z'</code>&nbsp;的位置是&nbsp;<code>25</code>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，字符串&nbsp;<code>\"acb\"</code>&nbsp;的差值整数数组是&nbsp;<code>[2 - 0, 1 - 2] = [2, -1]</code>&nbsp;。</li>\n</ul>\n\n<p><code>words</code>&nbsp;中所有字符串 <strong>除了一个字符串以外</strong>&nbsp;，其他字符串的差值整数数组都相同。你需要找到那个不同的字符串。</p>\n\n<p>请你返回<em>&nbsp;</em><code>words</code>中&nbsp;<strong>差值整数数组</strong>&nbsp;不同的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"adc\",\"wzy\",\"abc\"]\n<b>输出：</b>\"abc\"\n<b>解释：</b>\n- \"adc\" 的差值整数数组是 [3 - 0, 2 - 3] = [3, -1] 。\n- \"wzy\" 的差值整数数组是 [25 - 22, 24 - 25]= [3, -1] 。\n- \"abc\" 的差值整数数组是 [1 - 0, 2 - 1] = [1, 1] 。\n不同的数组是 [1, 1]，所以返回对应的字符串，\"abc\"。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>words = [\"aaa\",\"bob\",\"ccc\",\"ddd\"]\n<b>输出：</b>\"bob\"\n<b>解释：</b>除了 \"bob\" 的差值整数数组是 [13, -13] 以外，其他字符串的差值整数数组都是 [0, 0] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>n == words[i].length</code></li>\n\t<li><code>2 &lt;= n &lt;= 20</code></li>\n\t<li><code>words[i]</code>&nbsp;只含有小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2452距离字典两次编辑以内的单词",
        "hardRate": "MEDIUM",
        "passRate": "65.02%",
        "problemsUrl": "https://leetcode.cn/problems/words-within-two-edits-of-dictionary/",
        "solutionsUrl": "https://leetcode.cn/problems/words-within-two-edits-of-dictionary/solution",
        "problemsDesc": "<p>给你两个字符串数组&nbsp;<code>queries</code> 和&nbsp;<code>dictionary</code>&nbsp;。数组中所有单词都只包含小写英文字母，且长度都相同。</p>\n\n<p>一次 <strong>编辑</strong>&nbsp;中，你可以从 <code>queries</code>&nbsp;中选择一个单词，将任意一个字母修改成任何其他字母。从&nbsp;<code>queries</code>&nbsp;中找到所有满足以下条件的字符串：<strong>不超过</strong>&nbsp;两次编辑内，字符串与&nbsp;<code>dictionary</code>&nbsp;中某个字符串相同。</p>\n\n<p>请你返回<em>&nbsp;</em><code>queries</code>&nbsp;中的单词列表，这些单词距离&nbsp;<code>dictionary</code>&nbsp;中的单词&nbsp;<strong>编辑次数</strong>&nbsp;不超过&nbsp;<strong>两次</strong>&nbsp;。单词返回的顺序需要与&nbsp;<code>queries</code>&nbsp;中原本顺序相同。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>queries = [\"word\",\"note\",\"ants\",\"wood\"], dictionary = [\"wood\",\"joke\",\"moat\"]\n<b>输出：</b>[\"word\",\"note\",\"wood\"]\n<strong>解释：</strong>\n- 将 \"word\" 中的 'r' 换成 'o' ，得到 dictionary 中的单词 \"wood\" 。\n- 将 \"note\" 中的 'n' 换成 'j' 且将 't' 换成 'k' ，得到 \"joke\" 。\n- \"ants\" 需要超过 2 次编辑才能得到 dictionary 中的单词。\n- \"wood\" 不需要修改（0 次编辑），就得到 dictionary 中相同的单词。\n所以我们返回 [\"word\",\"note\",\"wood\"] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>queries = [\"yes\"], dictionary = [\"not\"]\n<b>输出：</b>[]\n<strong>解释：</strong>\n\"yes\" 需要超过 2 次编辑才能得到 \"not\" 。\n所以我们返回空数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= queries.length, dictionary.length &lt;= 100</code></li>\n\t<li><code>n == queries[i].length == dictionary[j].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li>所有&nbsp;<code>queries[i]</code> 和&nbsp;<code>dictionary[j]</code>&nbsp;都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2453摧毁一系列目标",
        "hardRate": "MEDIUM",
        "passRate": "35.45%",
        "problemsUrl": "https://leetcode.cn/problems/destroy-sequential-targets/",
        "solutionsUrl": "https://leetcode.cn/problems/destroy-sequential-targets/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的数组&nbsp;<code>nums</code>&nbsp;，它包含若干正整数，表示数轴上你需要摧毁的目标所在的位置。同时给你一个整数&nbsp;<code>space</code>&nbsp;。</p>\n\n<p>你有一台机器可以摧毁目标。给机器 <strong>输入</strong>&nbsp;<code>nums[i]</code>&nbsp;，这台机器会摧毁所有位置在&nbsp;<code>nums[i] + c * space</code>&nbsp;的目标，其中&nbsp;<code>c</code>&nbsp;是任意非负整数。你想摧毁&nbsp;<code>nums</code>&nbsp;中 <strong>尽可能多</strong>&nbsp;的目标。</p>\n\n<p>请你返回在摧毁数目最多的前提下，<code>nums[i]</code>&nbsp;的 <strong>最小值</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [3,7,8,1,1,5], space = 2\n<b>输出：</b>1\n<b>解释：</b>如果我们输入 nums[3] ，我们可以摧毁位于 1,3,5,7,9,... 这些位置的目标。\n这种情况下， 我们总共可以摧毁 5 个目标（除了 nums[2]）。\n没有办法摧毁多于 5 个目标，所以我们返回 nums[3] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,3,5,2,4,6], space = 2\n<b>输出：</b>1\n<b>解释：</b>输入 nums[0] 或者 nums[3] 都会摧毁 3 个目标。\n没有办法摧毁多于 3 个目标。\n由于 nums[0] 是最小的可以摧毁 3 个目标的整数，所以我们返回 1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>nums = [6,2,5], space = 100\n<b>输出：</b>2\n<b>解释：</b>无论我们输入哪个数字，都只能摧毁 1 个目标。输入的最小整数是 nums[1] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= space &lt;=&nbsp;10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2454下一个更大元素 IV",
        "hardRate": "HARD",
        "passRate": "49.09%",
        "problemsUrl": "https://leetcode.cn/problems/next-greater-element-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/next-greater-element-iv/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的非负整数数组&nbsp;<code>nums</code>&nbsp;。对于&nbsp;<code>nums</code>&nbsp;中每一个整数，你必须找到对应元素的&nbsp;<strong>第二大</strong>&nbsp;整数。</p>\n\n<p>如果&nbsp;<code>nums[j]</code>&nbsp;满足以下条件，那么我们称它为&nbsp;<code>nums[i]</code>&nbsp;的&nbsp;<strong>第二大</strong>&nbsp;整数：</p>\n\n<ul>\n\t<li><code>j &gt; i</code></li>\n\t<li><code>nums[j] &gt; nums[i]</code></li>\n\t<li>恰好存在 <strong>一个</strong>&nbsp;<code>k</code>&nbsp;满足 <code>i &lt; k &lt; j</code>&nbsp;且&nbsp;<code>nums[k] &gt; nums[i]</code>&nbsp;。</li>\n</ul>\n\n<p>如果不存在&nbsp;<code>nums[j]</code>&nbsp;，那么第二大整数为&nbsp;<code>-1</code>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，数组&nbsp;<code>[1, 2, 4, 3]</code>&nbsp;中，<code>1</code>&nbsp;的第二大整数是&nbsp;<code>4</code>&nbsp;，<code>2</code>&nbsp;的第二大整数是&nbsp;<code>3</code>&nbsp;，<code>3</code> 和&nbsp;<code>4</code>&nbsp;的第二大整数是&nbsp;<code>-1</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回一个整数数组<em>&nbsp;</em><code>answer</code>&nbsp;，其中<em>&nbsp;</em><code>answer[i]</code>是<em>&nbsp;</em><code>nums[i]</code>&nbsp;的第二大整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [2,4,0,9,6]\n<b>输出：</b>[9,6,6,-1,-1]\n<strong>解释：</strong>\n下标为 0 处：2 的右边，4 是大于 2 的第一个整数，9 是第二个大于 2 的整数。\n下标为 1 处：4 的右边，9 是大于 4 的第一个整数，6 是第二个大于 4 的整数。\n下标为 2 处：0 的右边，9 是大于 0 的第一个整数，6 是第二个大于 0 的整数。\n下标为 3 处：右边不存在大于 9 的整数，所以第二大整数为 -1 。\n下标为 4 处：右边不存在大于 6 的整数，所以第二大整数为 -1 。\n所以我们返回 [9,6,6,-1,-1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,3]\n<b>输出：</b>[-1,-1]\n<strong>解释：</strong>\n由于每个数右边都没有更大的数，所以我们返回 [-1,-1] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2455可被三整除的偶数的平均值",
        "hardRate": "EASY",
        "passRate": "63.56%",
        "problemsUrl": "https://leetcode.cn/problems/average-value-of-even-numbers-that-are-divisible-by-three/",
        "solutionsUrl": "https://leetcode.cn/problems/average-value-of-even-numbers-that-are-divisible-by-three/solution",
        "problemsDesc": "<p>给你一个由正整数组成的整数数组 <code>nums</code> ，返回其中可被 <code>3</code> 整除的所有偶数的平均值。</p>\n\n<p>注意：<code>n</code> 个元素的平均值等于 <code>n</code> 个元素 <strong>求和</strong> 再除以 <code>n</code> ，结果 <strong>向下取整</strong> 到最接近的整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,6,10,12,15]\n<strong>输出：</strong>9\n<strong>解释：</strong>6 和 12 是可以被 3 整除的偶数。(6 + 12) / 2 = 9 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,4,7,10]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在满足题目要求的整数，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2456最流行的视频创作者",
        "hardRate": "MEDIUM",
        "passRate": "38.33%",
        "problemsUrl": "https://leetcode.cn/problems/most-popular-video-creator/",
        "solutionsUrl": "https://leetcode.cn/problems/most-popular-video-creator/solution",
        "problemsDesc": "<p>给你两个字符串数组 <code>creators</code> 和 <code>ids</code> ，和一个整数数组 <code>views</code> ，所有数组的长度都是 <code>n</code> 。平台上第 <code>i</code> 个视频者是&nbsp;<code>creator[i]</code> ，视频分配的 id 是 <code>ids[i]</code> ，且播放量为 <code>views[i]</code> 。</p>\n\n<p>视频创作者的 <strong>流行度</strong> 是该创作者的 <strong>所有</strong> 视频的播放量的 <strong>总和</strong> 。请找出流行度 <strong>最高</strong> 创作者以及该创作者播放量 <strong>最大</strong> 的视频的 id 。</p>\n\n<ul>\n\t<li>如果存在多个创作者流行度都最高，则需要找出所有符合条件的创作者。</li>\n\t<li>如果某个创作者存在多个播放量最高的视频，则只需要找出字典序最小的 <code>id</code> 。</li>\n</ul>\n\n<p>返回一个二维字符串数组<em> </em><code>answer</code><em> </em>，其中<em> </em><code>answer[i] = [creator<sub>i</sub>, id<sub>i</sub>]</code><em> </em>表示<em> </em><code>creator<sub>i</sub></code> 的流行度 <strong>最高</strong> 且其最流行的视频 id 是<em> </em><code>id<sub>i</sub></code><em> </em>，可以按任何顺序返回该结果<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>creators = [\"alice\",\"bob\",\"alice\",\"chris\"], ids = [\"one\",\"two\",\"three\",\"four\"], views = [5,10,5,4]\n<strong>输出：</strong>[[\"alice\",\"one\"],[\"bob\",\"two\"]]\n<strong>解释：</strong>\nalice 的流行度是 5 + 5 = 10 。\nbob 的流行度是 10 。\nchris 的流行度是 4 。\nalice 和 bob 是流行度最高的创作者。\nbob 播放量最高的视频 id 为 \"two\" 。\nalice 播放量最高的视频 id 是 \"one\" 和 \"three\" 。由于 \"one\" 的字典序比 \"three\" 更小，所以结果中返回的 id 是 \"one\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>creators = [\"alice\",\"alice\",\"alice\"], ids = [\"a\",\"b\",\"c\"], views = [1,2,2]\n<strong>输出：</strong>[[\"alice\",\"b\"]]\n<strong>解释：</strong>\nid 为 \"b\" 和 \"c\" 的视频都满足播放量最高的条件。\n由于 \"b\" 的字典序比 \"c\" 更小，所以结果中返回的 id 是 \"b\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == creators.length == ids.length == views.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= creators[i].length, ids[i].length &lt;= 5</code></li>\n\t<li><code>creators[i]</code> 和 <code>ids[i]</code> 仅由小写英文字母组成</li>\n\t<li><code>0 &lt;= views[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2457美丽整数的最小增量",
        "hardRate": "MEDIUM",
        "passRate": "39.47%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-addition-to-make-integer-beautiful/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-addition-to-make-integer-beautiful/solution",
        "problemsDesc": "<p>给你两个正整数 <code>n</code> 和 <code>target</code> 。</p>\n\n<p>如果某个整数每一位上的数字相加小于或等于 <code>target</code> ，则认为这个整数是一个 <strong>美丽整数</strong> 。</p>\n\n<p>找出并返回满足 <code>n + x</code> 是 <strong>美丽整数</strong> 的最小非负整数 <code>x</code> 。生成的输入保证总可以使 <code>n</code> 变成一个美丽整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 16, target = 6\n<strong>输出：</strong>4\n<strong>解释：</strong>最初，n 是 16 ，且其每一位数字的和是 1 + 6 = 7 。在加 4 之后，n 变为 20 且每一位数字的和变成 2 + 0 = 2 。可以证明无法加上一个小于 4 的非负整数使 n 变成一个美丽整数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 467, target = 6\n<strong>输出：</strong>33\n<strong>解释：</strong>最初，n 是 467 ，且其每一位数字的和是 4 + 6 + 7 = 17 。在加 33 之后，n 变为 500 且每一位数字的和变成 5 + 0 + 0 = 5 。可以证明无法加上一个小于 33 的非负整数使 n 变成一个美丽整数。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 1, target = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>最初，n 是 1 ，且其每一位数字的和是 1 ，已经小于等于 target 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>12</sup></code></li>\n\t<li><code>1 &lt;= target &lt;= 150</code></li>\n\t<li>生成的输入保证总可以使 <code>n</code> 变成一个美丽整数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2458移除子树后的二叉树高度",
        "hardRate": "HARD",
        "passRate": "41.10%",
        "problemsUrl": "https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries/solution",
        "problemsDesc": "<p>给你一棵 <strong>二叉树</strong> 的根节点 <code>root</code> ，树中有 <code>n</code> 个节点。每个节点都可以被分配一个从 <code>1</code> 到 <code>n</code> 且互不相同的值。另给你一个长度为 <code>m</code> 的数组 <code>queries</code> 。</p>\n\n<p>你必须在树上执行 <code>m</code> 个 <strong>独立</strong> 的查询，其中第 <code>i</code> 个查询你需要执行以下操作：</p>\n\n<ul>\n\t<li>从树中 <strong>移除</strong> 以 <code>queries[i]</code> 的值作为根节点的子树。题目所用测试用例保证 <code>queries[i]</code> <strong>不</strong> 等于根节点的值。</li>\n</ul>\n\n<p>返回一个长度为 <code>m</code> 的数组<em> </em><code>answer</code><em> </em>，其中<em> </em><code>answer[i]</code><em> </em>是执行第 <code>i</code> 个查询后树的高度。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>查询之间是独立的，所以在每个查询执行后，树会回到其 <strong>初始</strong> 状态。</li>\n\t<li>树的高度是从根到树中某个节点的 <strong>最长简单路径中的边数</strong> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/07/binaryytreeedrawio-1.png\" style=\"width: 495px; height: 281px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4]\n<strong>输出：</strong>[2]\n<strong>解释：</strong>上图展示了从树中移除以 4 为根节点的子树。\n树的高度是 2（路径为 1 -&gt; 3 -&gt; 2）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/07/binaryytreeedrawio-2.png\" style=\"width: 301px; height: 284px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,8,9,2,1,3,7,4,6], queries = [3,2,4,8]\n<strong>输出：</strong>[3,2,3,2]\n<strong>解释：</strong>执行下述查询：\n- 移除以 3 为根节点的子树。树的高度变为 3（路径为 5 -&gt; 8 -&gt; 2 -&gt; 4）。\n- 移除以 2 为根节点的子树。树的高度变为 2（路径为 5 -&gt; 8 -&gt; 1）。\n- 移除以 4 为根节点的子树。树的高度变为 3（路径为 5 -&gt; 8 -&gt; 2 -&gt; 6）。\n- 移除以 8 为根节点的子树。树的高度变为 2（路径为 5 -&gt; 9 -&gt; 3）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目是 <code>n</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= Node.val &lt;= n</code></li>\n\t<li>树中的所有值 <strong>互不相同</strong></li>\n\t<li><code>m == queries.length</code></li>\n\t<li><code>1 &lt;= m &lt;= min(n, 10<sup>4</sup>)</code></li>\n\t<li><code>1 &lt;= queries[i] &lt;= n</code></li>\n\t<li><code>queries[i] != root.val</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2459通过移动项目到空白区域来排序数组",
        "hardRate": "HARD",
        "passRate": "60.00%",
        "problemsUrl": "https://leetcode.cn/problems/sort-array-by-moving-items-to-empty-space/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-array-by-moving-items-to-empty-space/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2460对数组执行操作",
        "hardRate": "EASY",
        "passRate": "68.20%",
        "problemsUrl": "https://leetcode.cn/problems/apply-operations-to-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/apply-operations-to-an-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，数组大小为 <code>n</code> ，且由 <strong>非负</strong> 整数组成。</p>\n\n<p>你需要对数组执行 <code>n - 1</code> 步操作，其中第 <code>i</code> 步操作（从 <strong>0</strong> 开始计数）要求对 <code>nums</code> 中第 <code>i</code> 个元素执行下述指令：</p>\n\n<ul>\n\t<li>如果 <code>nums[i] == nums[i + 1]</code> ，则 <code>nums[i]</code> 的值变成原来的 <code>2</code> 倍，<code>nums[i + 1]</code> 的值变成 <code>0</code> 。否则，跳过这步操作。</li>\n</ul>\n\n<p>在执行完 <strong>全部</strong> 操作后，将所有 <code>0</code> <strong>移动</strong> 到数组的 <strong>末尾</strong> 。</p>\n\n<ul>\n\t<li>例如，数组 <code>[1,0,2,0,0,1]</code> 将所有 <code>0</code> 移动到末尾后变为 <code>[1,2,1,0,0,0]</code> 。</li>\n</ul>\n\n<p>返回结果数组。</p>\n\n<p><strong>注意</strong> 操作应当 <strong>依次有序</strong> 执行，而不是一次性全部执行。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2,1,1,0]\n<strong>输出：</strong>[1,4,2,0,0,0]\n<strong>解释：</strong>执行以下操作：\n- i = 0: nums[0] 和 nums[1] 不相等，跳过这步操作。\n- i = 1: nums[1] 和 nums[2] 相等，nums[1] 的值变成原来的 2 倍，nums[2] 的值变成 0 。数组变成 [1,<em><strong>4</strong></em>,<em><strong>0</strong></em>,1,1,0] 。\n- i = 2: nums[2] 和 nums[3] 不相等，所以跳过这步操作。\n- i = 3: nums[3] 和 nums[4] 相等，nums[3] 的值变成原来的 2 倍，nums[4] 的值变成 0 。数组变成 [1,4,0,<em><strong>2</strong></em>,<em><strong>0</strong></em>,0] 。\n- i = 4: nums[4] 和 nums[5] 相等，nums[4] 的值变成原来的 2 倍，nums[5] 的值变成 0 。数组变成 [1,4,0,2,<em><strong>0</strong></em>,<em><strong>0</strong></em>] 。\n执行完所有操作后，将 0 全部移动到数组末尾，得到结果数组 [1,4,2,0,0,0] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1]\n<strong>输出：</strong>[1,0]\n<strong>解释：</strong>无法执行任何操作，只需要将 0 移动到末尾。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 2000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2461长度为 K 子数组中的最大和",
        "hardRate": "MEDIUM",
        "passRate": "30.62%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。请你从 <code>nums</code> 中满足下述条件的全部子数组中找出最大子数组和：</p>\n\n<ul>\n\t<li>子数组的长度是 <code>k</code>，且</li>\n\t<li>子数组中的所有元素 <strong>各不相同 。</strong></li>\n</ul>\n\n<p>返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 <code>0</code> 。</p>\n\n<p><strong>子数组</strong> 是数组中一段连续非空的元素序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,5,4,2,9,9,9], k = 3\n<strong>输出：</strong>15\n<strong>解释：</strong>nums 中长度为 3 的子数组是：\n- [1,5,4] 满足全部条件，和为 10 。\n- [5,4,2] 满足全部条件，和为 11 。\n- [4,2,9] 满足全部条件，和为 15 。\n- [2,9,9] 不满足全部条件，因为元素 9 出现重复。\n- [9,9,9] 不满足全部条件，因为元素 9 出现重复。\n因为 15 是满足全部条件的所有子数组中的最大子数组和，所以返回 15 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,4,4], k = 3\n<strong>输出：</strong>0\n<strong>解释：</strong>nums 中长度为 3 的子数组是：\n- [4,4,4] 不满足全部条件，因为元素 4 出现重复。\n因为不存在满足全部条件的子数组，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2462雇佣 K 位工人的总代价",
        "hardRate": "MEDIUM",
        "passRate": "37.62%",
        "problemsUrl": "https://leetcode.cn/problems/total-cost-to-hire-k-workers/",
        "solutionsUrl": "https://leetcode.cn/problems/total-cost-to-hire-k-workers/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>costs</code>&nbsp;，其中&nbsp;<code>costs[i]</code>&nbsp;是雇佣第 <code>i</code>&nbsp;位工人的代价。</p>\n\n<p>同时给你两个整数&nbsp;<code>k</code> 和&nbsp;<code>candidates</code>&nbsp;。我们想根据以下规则恰好雇佣&nbsp;<code>k</code>&nbsp;位工人：</p>\n\n<ul>\n\t<li>总共进行&nbsp;<code>k</code>&nbsp;轮雇佣，且每一轮恰好雇佣一位工人。</li>\n\t<li>在每一轮雇佣中，从最前面 <code>candidates</code>&nbsp;和最后面 <code>candidates</code>&nbsp;人中选出代价最小的一位工人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。\n\t<ul>\n\t\t<li>比方说，<code>costs = [3,2,7,7,1,2]</code> 且&nbsp;<code>candidates = 2</code>&nbsp;，第一轮雇佣中，我们选择第&nbsp;<code>4</code>&nbsp;位工人，因为他的代价最小&nbsp;<code>[<em>3,2</em>,7,7,<em><strong>1</strong>,2</em>]</code>&nbsp;。</li>\n\t\t<li>第二轮雇佣，我们选择第&nbsp;<code>1</code>&nbsp;位工人，因为他们的代价与第&nbsp;<code>4</code>&nbsp;位工人一样都是最小代价，而且下标更小，<code>[<em>3,<strong>2</strong></em>,7,<em>7,2</em>]</code>&nbsp;。注意每一轮雇佣后，剩余工人的下标可能会发生变化。</li>\n\t</ul>\n\t</li>\n\t<li>如果剩余员工数目不足 <code>candidates</code>&nbsp;人，那么下一轮雇佣他们中代价最小的一人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。</li>\n\t<li>一位工人只能被选择一次。</li>\n</ul>\n\n<p>返回雇佣恰好<em>&nbsp;</em><code>k</code>&nbsp;位工人的总代价。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\n<b>输出：</b>11\n<b>解释：</b>我们总共雇佣 3 位工人。总代价一开始为 0 。\n- 第一轮雇佣，我们从 [<strong><em>17,12,10,2</em></strong>,7,<strong><em>2,11,20,8</em></strong>] 中选择。最小代价是 2 ，有两位工人，我们选择下标更小的一位工人，即第 3 位工人。总代价是 0 + 2 = 2 。\n- 第二轮雇佣，我们从 [<strong><em>17,12,10,7</em></strong>,<strong><em>2,11,20,8</em></strong>] 中选择。最小代价是 2 ，下标为 4 ，总代价是 2 + 2 = 4 。\n- 第三轮雇佣，我们从 [<strong><em>17,12,10,7,11,20,8</em></strong>] 中选择，最小代价是 7 ，下标为 3 ，总代价是 4 + 7 = 11 。注意下标为 3 的工人同时在最前面和最后面 4 位工人中。\n总雇佣代价是 11 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>costs = [1,2,4,1], k = 3, candidates = 3\n<b>输出：</b>4\n<b>解释：</b>我们总共雇佣 3 位工人。总代价一开始为 0 。\n- 第一轮雇佣，我们从 [<strong><em>1,2,4,1</em></strong>] 中选择。最小代价为 1 ，有两位工人，我们选择下标更小的一位工人，即第 0 位工人，总代价是 0 + 1 = 1 。注意，下标为 1 和 2 的工人同时在最前面和最后面 3 位工人中。\n- 第二轮雇佣，我们从 [<strong><em>2,4,1</em></strong>] 中选择。最小代价为 1 ，下标为 2 ，总代价是 1 + 1 = 2 。\n- 第三轮雇佣，少于 3 位工人，我们从剩余工人 [<strong><em>2,4</em></strong>] 中选择。最小代价是 2 ，下标为 0 。总代价为 2 + 2 = 4 。\n总雇佣代价是 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= costs.length &lt;= 10<sup>5 </sup></code></li>\n\t<li><code>1 &lt;= costs[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k, candidates &lt;= costs.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2463最小移动总距离",
        "hardRate": "HARD",
        "passRate": "46.27%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-total-distance-traveled/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-total-distance-traveled/solution",
        "problemsDesc": "<p>X 轴上有一些机器人和工厂。给你一个整数数组&nbsp;<code>robot</code>&nbsp;，其中&nbsp;<code>robot[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个机器人的位置。再给你一个二维整数数组&nbsp;<code>factory</code>&nbsp;，其中&nbsp;<code>factory[j] = [position<sub>j</sub>, limit<sub>j</sub>]</code>&nbsp;，表示第 <code>j</code>&nbsp;个工厂的位置在&nbsp;<code>position<sub>j</sub></code>&nbsp;，且第 <code>j</code>&nbsp;个工厂最多可以修理&nbsp;<code>limit<sub>j</sub></code>&nbsp;个机器人。</p>\n\n<p>每个机器人所在的位置 <strong>互不相同</strong>&nbsp;。每个工厂所在的位置也 <strong>互不相同</strong>&nbsp;。注意一个机器人可能一开始跟一个工厂在 <strong>相同的位置</strong>&nbsp;。</p>\n\n<p>所有机器人一开始都是坏的，他们会沿着设定的方向一直移动。设定的方向要么是 X 轴的正方向，要么是 X 轴的负方向。当一个机器人经过一个没达到上限的工厂时，这个工厂会维修这个机器人，且机器人停止移动。</p>\n\n<p><b>任何时刻</b>，你都可以设置&nbsp;<strong>部分</strong>&nbsp;机器人的移动方向。你的目标是最小化所有机器人总的移动距离。</p>\n\n<p>请你返回所有机器人移动的最小总距离。测试数据保证所有机器人都可以被维修。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>所有机器人移动速度相同。</li>\n\t<li>如果两个机器人移动方向相同，它们永远不会碰撞。</li>\n\t<li>如果两个机器人迎面相遇，它们也不会碰撞，它们彼此之间会擦肩而过。</li>\n\t<li>如果一个机器人经过了一个已经达到上限的工厂，机器人会当作工厂不存在，继续移动。</li>\n\t<li>机器人从位置&nbsp;<code>x</code> 到位置&nbsp;<code>y</code>&nbsp;的移动距离为&nbsp;<code>|y - x|</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1667542978-utuiPv-image.png\" style=\"width: 500px; height: 320px;\" /></p>\n\n<pre>\n<b>输入：</b>robot = [0,4,6], factory = [[2,2],[6,2]]\n<b>输出：</b>4\n<b>解释：</b>如上图所示：\n- 第一个机器人从位置 0 沿着正方向移动，在第一个工厂处维修。\n- 第二个机器人从位置 4 沿着负方向移动，在第一个工厂处维修。\n- 第三个机器人在位置 6 被第二个工厂维修，它不需要移动。\n第一个工厂的维修上限是 2 ，它维修了 2 个机器人。\n第二个工厂的维修上限是 2 ，它维修了 1 个机器人。\n总移动距离是 |2 - 0| + |2 - 4| + |6 - 6| = 4 。没有办法得到比 4 更少的总移动距离。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1667542984-OAIRFN-image.png\" style=\"width: 500px; height: 329px;\" /></p>\n\n<pre>\n<b>输入：</b>robot = [1,-1], factory = [[-2,1],[2,1]]\n<b>输出：</b>2\n<b>解释：</b>如上图所示：\n- 第一个机器人从位置 1 沿着正方向移动，在第二个工厂处维修。\n- 第二个机器人在位置 -1 沿着负方向移动，在第一个工厂处维修。\n第一个工厂的维修上限是 1 ，它维修了 1 个机器人。\n第二个工厂的维修上限是 1 ，它维修了 1 个机器人。\n总移动距离是 |2 - 1| + |(-2) - (-1)| = 2 。没有办法得到比 2 更少的总移动距离。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= robot.length, factory.length &lt;= 100</code></li>\n\t<li><code>factory[j].length == 2</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= robot[i], position<sub>j</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= limit<sub>j</sub> &lt;= robot.length</code></li>\n\t<li>测试数据保证所有机器人都可以被维修。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2464有效分割中的最少子数组数目",
        "hardRate": "MEDIUM",
        "passRate": "63.81%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-subarrays-in-a-valid-split/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-subarrays-in-a-valid-split/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2465不同的平均值数目",
        "hardRate": "EASY",
        "passRate": "72.36%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-distinct-averages/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-distinct-averages/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <strong>偶数</strong>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>只要&nbsp;<code>nums</code> <strong>不是</strong>&nbsp;空数组，你就重复执行以下步骤：</p>\n\n<ul>\n\t<li>找到&nbsp;<code>nums</code>&nbsp;中的最小值，并删除它。</li>\n\t<li>找到&nbsp;<code>nums</code>&nbsp;中的最大值，并删除它。</li>\n\t<li>计算删除两数的平均值。</li>\n</ul>\n\n<p>两数 <code>a</code>&nbsp;和 <code>b</code>&nbsp;的 <strong>平均值</strong>&nbsp;为&nbsp;<code>(a + b) / 2</code>&nbsp;。</p>\n\n<ul>\n\t<li>比方说，<code>2</code>&nbsp;和&nbsp;<code>3</code>&nbsp;的平均值是&nbsp;<code>(2 + 3) / 2 = 2.5</code>&nbsp;。</li>\n</ul>\n\n<p>返回上述过程能得到的 <strong>不同</strong>&nbsp;平均值的数目。</p>\n\n<p><strong>注意</strong>&nbsp;，如果最小值或者最大值有重复元素，可以删除任意一个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>nums = [4,1,4,0,3,5]\n<b>输出：</b>2\n<strong>解释：</strong>\n1. 删除 0 和 5 ，平均值是 (0 + 5) / 2 = 2.5 ，现在 nums = [4,1,4,3] 。\n2. 删除 1 和 4 ，平均值是 (1 + 4) / 2 = 2.5 ，现在 nums = [4,3] 。\n3. 删除 3 和 4 ，平均值是 (3 + 4) / 2 = 3.5 。\n2.5 ，2.5 和 3.5 之中总共有 2 个不同的数，我们返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>nums = [1,100]\n<b>输出：</b>1\n<strong>解释：</strong>\n删除 1 和 100 后只有一个平均值，所以我们返回 1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>nums.length</code>&nbsp;是偶数。</li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2466统计构造好字符串的方案数",
        "hardRate": "MEDIUM",
        "passRate": "46.22%",
        "problemsUrl": "https://leetcode.cn/problems/count-ways-to-build-good-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/count-ways-to-build-good-strings/solution",
        "problemsDesc": "<p>给你整数&nbsp;<code>zero</code>&nbsp;，<code>one</code>&nbsp;，<code>low</code>&nbsp;和&nbsp;<code>high</code>&nbsp;，我们从空字符串开始构造一个字符串，每一步执行下面操作中的一种：</p>\n\n<ul>\n\t<li>将&nbsp;<code>'0'</code>&nbsp;在字符串末尾添加&nbsp;<code>zero</code>&nbsp; 次。</li>\n\t<li>将&nbsp;<code>'1'</code>&nbsp;在字符串末尾添加&nbsp;<code>one</code>&nbsp;次。</li>\n</ul>\n\n<p>以上操作可以执行任意次。</p>\n\n<p>如果通过以上过程得到一个 <strong>长度</strong>&nbsp;在&nbsp;<code>low</code> 和&nbsp;<code>high</code>&nbsp;之间（包含上下边界）的字符串，那么这个字符串我们称为&nbsp;<strong>好</strong>&nbsp;字符串。</p>\n\n<p>请你返回满足以上要求的 <strong>不同</strong>&nbsp;好字符串数目。由于答案可能很大，请将结果对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>low = 3, high = 3, zero = 1, one = 1\n<b>输出：</b>8\n<b>解释：</b>\n一个可能的好字符串是 \"011\" 。\n可以这样构造得到：\"\" -&gt; \"0\" -&gt; \"01\" -&gt; \"011\" 。\n从 \"000\" 到 \"111\" 之间所有的二进制字符串都是好字符串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>low = 2, high = 3, zero = 1, one = 2\n<b>输出：</b>5\n<b>解释：</b>好字符串为 \"00\" ，\"11\" ，\"000\" ，\"110\" 和 \"011\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= low&nbsp;&lt;= high&nbsp;&lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= zero, one &lt;= low</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2467树上最大得分和路径",
        "hardRate": "MEDIUM",
        "passRate": "50.25%",
        "problemsUrl": "https://leetcode.cn/problems/most-profitable-path-in-a-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/most-profitable-path-in-a-tree/solution",
        "problemsDesc": "<p>一个 <code>n</code>&nbsp;个节点的无向树，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，树的根结点是&nbsp;<code>0</code>&nbsp;号节点。给你一个长度为 <code>n - 1</code>&nbsp;的二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;，表示节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;在树中有一条边。</p>\n\n<p>在每一个节点&nbsp;<code>i</code>&nbsp;处有一扇门。同时给你一个都是偶数的数组&nbsp;<code>amount</code>&nbsp;，其中&nbsp;<code>amount[i]</code>&nbsp;表示：</p>\n\n<ul>\n\t<li>如果 <code>amount[i]</code>&nbsp;的值是负数，那么它表示打开节点&nbsp;<code>i</code>&nbsp;处门扣除的分数。</li>\n\t<li>如果 <code>amount[i]</code>&nbsp;的值是正数，那么它表示打开节点 <code>i</code>&nbsp;处门加上的分数。</li>\n</ul>\n\n<p>游戏按照如下规则进行：</p>\n\n<ul>\n\t<li>一开始，Alice 在节点&nbsp;<code>0</code>&nbsp;处，Bob 在节点&nbsp;<code>bob</code>&nbsp;处。</li>\n\t<li>每一秒钟，Alice 和 Bob <strong>分别</strong>&nbsp;移动到相邻的节点。Alice 朝着某个&nbsp;<strong>叶子结点</strong>&nbsp;移动，Bob 朝着节点&nbsp;<code>0</code>&nbsp;移动。</li>\n\t<li>对于他们之间路径上的 <strong>每一个</strong>&nbsp;节点，Alice 和 Bob 要么打开门并扣分，要么打开门并加分。注意：\n\t<ul>\n\t\t<li>如果门 <strong>已经打开</strong>&nbsp;（被另一个人打开），不会有额外加分也不会扣分。</li>\n\t\t<li>如果&nbsp;Alice 和 Bob <strong>同时</strong>&nbsp;到达一个节点，他们会共享这个节点的加分或者扣分。换言之，如果打开这扇门扣&nbsp;<code>c</code>&nbsp;分，那么&nbsp;Alice 和 Bob 分别扣&nbsp;<code>c / 2</code>&nbsp;分。如果这扇门的加分为&nbsp;<code>c</code>&nbsp;，那么他们分别加&nbsp;<code>c / 2</code>&nbsp;分。</li>\n\t</ul>\n\t</li>\n\t<li>如果 Alice 到达了一个叶子结点，她会停止移动。类似的，如果&nbsp;Bob 到达了节点&nbsp;<code>0</code>&nbsp;，他也会停止移动。注意这些事件互相 <strong>独立</strong>&nbsp;，不会影响另一方移动。</li>\n</ul>\n\n<p>请你返回&nbsp;Alice 朝最优叶子结点移动的 <strong>最大</strong>&nbsp;净得分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/29/eg1.png\" style=\"width: 275px; height: 275px;\"></p>\n\n<pre><b>输入：</b>edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6]\n<b>输出：</b>6\n<b>解释：</b>\n上图展示了输入给出的一棵树。游戏进行如下：\n- Alice 一开始在节点 0 处，Bob 在节点 3 处。他们分别打开所在节点的门。\n  Alice 得分为 -2 。\n- Alice 和 Bob 都移动到节点 1 。\n&nbsp; 因为他们同时到达这个节点，他们一起打开门并平分得分。\n&nbsp; Alice 的得分变为 -2 + (4 / 2) = 0 。\n- Alice 移动到节点 3 。因为 Bob 已经打开了这扇门，Alice 得分不变。\n&nbsp; Bob 移动到节点 0 ，并停止移动。\n- Alice 移动到节点 4 并打开这个节点的门，她得分变为 0 + 6 = 6 。\n现在，Alice 和 Bob 都不能进行任何移动了，所以游戏结束。\nAlice 无法得到更高分数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/29/eg2.png\" style=\"width: 250px; height: 78px;\"></p>\n\n<pre><b>输入：</b>edges = [[0,1]], bob = 1, amount = [-7280,2350]\n<b>输出：</b>-7280\n<b>解释：</b>\nAlice 按照路径 0-&gt;1 移动，同时 Bob 按照路径 1-&gt;0 移动。\n所以 Alice 只打开节点 0 处的门，她的得分为 -7280 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>edges</code>&nbsp;表示一棵有效的树。</li>\n\t<li><code>1 &lt;= bob &lt; n</code></li>\n\t<li><code>amount.length == n</code></li>\n\t<li><code>amount[i]</code>&nbsp;是范围&nbsp;<code>[-10<sup>4</sup>, 10<sup>4</sup>]</code>&nbsp;之间的一个&nbsp;<strong>偶数</strong>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2468根据限制分割消息",
        "hardRate": "HARD",
        "passRate": "44.39%",
        "problemsUrl": "https://leetcode.cn/problems/split-message-based-on-limit/",
        "solutionsUrl": "https://leetcode.cn/problems/split-message-based-on-limit/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>message</code>&nbsp;和一个正整数&nbsp;<code>limit</code>&nbsp;。</p>\n\n<p>你需要根据 <code>limit</code>&nbsp;将&nbsp;<code>message</code> <strong>分割</strong>&nbsp;成一个或多个 <strong>部分</strong>&nbsp;。每个部分的结尾都是&nbsp;<code>\"&lt;a/b&gt;\"</code>&nbsp;，其中&nbsp;<code>\"b\"</code>&nbsp;用分割出来的总数 <b>替换</b>，&nbsp;<code>\"a\"</code>&nbsp;用当前部分所在的编号 <strong>替换</strong>&nbsp;，编号从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>b</code>&nbsp;依次编号。除此以外，除了最后一部分长度 <strong>小于等于</strong>&nbsp;<code>limit</code>&nbsp;以外，其他每一部分（包括结尾部分）的长度都应该&nbsp;<strong>等于</strong>&nbsp;<code>limit</code>&nbsp;。</p>\n\n<p>你需要确保分割后的结果数组，删掉每部分的结尾并<strong>&nbsp;按顺序&nbsp;</strong>连起来后，能够得到&nbsp;<code>message</code>&nbsp;。同时，结果数组越短越好。</p>\n\n<p>请你返回<em>&nbsp;</em><code>message</code>&nbsp; 分割后得到的结果数组。如果无法按要求分割&nbsp;<code>message</code>&nbsp;，返回一个空数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><b>输入：</b>message = \"this is really a very awesome message\", limit = 9\n<b>输出：</b>[\"thi&lt;1/14&gt;\",\"s i&lt;2/14&gt;\",\"s r&lt;3/14&gt;\",\"eal&lt;4/14&gt;\",\"ly &lt;5/14&gt;\",\"a v&lt;6/14&gt;\",\"ery&lt;7/14&gt;\",\" aw&lt;8/14&gt;\",\"eso&lt;9/14&gt;\",\"me&lt;10/14&gt;\",\" m&lt;11/14&gt;\",\"es&lt;12/14&gt;\",\"sa&lt;13/14&gt;\",\"ge&lt;14/14&gt;\"]\n<strong>解释：</strong>\n前面 9 个部分分别从 message 中得到 3 个字符。\n接下来的 5 个部分分别从 message 中得到 2 个字符。\n这个例子中，包含最后一个部分在内，每个部分的长度都为 9 。\n可以证明没有办法分割成少于 14 个部分。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>message = \"short message\", limit = 15\n<b>输出：</b>[\"short mess&lt;1/2&gt;\",\"age&lt;2/2&gt;\"]\n<strong>解释：</strong>\n在给定限制下，字符串可以分成两个部分：\n- 第一个部分包含 10 个字符，长度为 15 。\n- 第二个部分包含 3 个字符，长度为 8 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= message.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>message</code>&nbsp;只包含小写英文字母和&nbsp;<code>' '</code>&nbsp;。</li>\n\t<li><code>1 &lt;= limit &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2469温度转换",
        "hardRate": "EASY",
        "passRate": "86.90%",
        "problemsUrl": "https://leetcode.cn/problems/convert-the-temperature/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-the-temperature/solution",
        "problemsDesc": "<p>给你一个四舍五入到两位小数的非负浮点数 <code>celsius</code> 来表示温度，以 <strong>摄氏度</strong>（<strong>Celsius</strong>）为单位。</p>\n\n<p>你需要将摄氏度转换为 <strong>开氏度</strong>（<strong>Kelvin</strong>）和 <strong>华氏度</strong>（<strong>Fahrenheit</strong>），并以数组 <code>ans = [kelvin, fahrenheit]</code> 的形式返回结果。</p>\n\n<p>返回数组<em> <code>ans</code></em> 。与实际答案误差不超过 <code>10<sup>-5</sup></code> 的会视为正确答案<strong>。</strong></p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><code>开氏度 = 摄氏度 + 273.15</code></li>\n\t<li><code>华氏度 = 摄氏度 * 1.80 + 32.00</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1 ：</strong></p>\n\n<pre><strong>输入：</strong>celsius = 36.50\n<strong>输出：</strong>[309.65000,97.70000]\n<strong>解释：</strong>36.50 摄氏度：转换为开氏度是 309.65 ，转换为华氏度是 97.70 。</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre><strong>输入：</strong>celsius = 122.11\n<strong>输出：</strong>[395.26000,251.79800]\n<strong>解释：</strong>122.11 摄氏度：转换为开氏度是 395.26 ，转换为华氏度是 251.798 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= celsius &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2470最小公倍数为 K 的子数组数目",
        "hardRate": "MEDIUM",
        "passRate": "40.71%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-subarrays-with-lcm-equal-to-k/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-subarrays-with-lcm-equal-to-k/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <code>nums</code> 的 <strong>子数组</strong> 中满足 <em>元素最小公倍数为 <code>k</code> </em>的子数组数目。</p>\n\n<p><strong>子数组</strong> 是数组中一个连续非空的元素序列。</p>\n\n<p><strong>数组的最小公倍数</strong> 是可被所有数组元素整除的最小正整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1 ：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,6,2,7,1], k = 6\n<strong>输出：</strong>4\n<strong>解释：</strong>以 6 为最小公倍数的子数组是：\n- [<em><strong>3</strong></em>,<em><strong>6</strong></em>,2,7,1]\n- [<em><strong>3</strong></em>,<em><strong>6</strong></em>,<em><strong>2</strong></em>,7,1]\n- [3,<em><strong>6</strong></em>,2,7,1]\n- [3,<em><strong>6</strong></em>,<em><strong>2</strong></em>,7,1]\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3], k = 2\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在以 2 为最小公倍数的子数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2471逐层排序二叉树所需的最少操作数目",
        "hardRate": "MEDIUM",
        "passRate": "55.67%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/solution",
        "problemsDesc": "<p>给你一个 <strong>值互不相同</strong> 的二叉树的根节点 <code>root</code> 。</p>\n\n<p>在一步操作中，你可以选择 <strong>同一层</strong> 上任意两个节点，交换这两个节点的值。</p>\n\n<p>返回每一层按 <strong>严格递增顺序</strong> 排序所需的最少操作数目。</p>\n\n<p>节点的 <strong>层数</strong> 是该节点和根节点之间的路径的边数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1 ：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/09/18/image-20220918174006-2.png\" style=\"width: 500px; height: 324px;\">\n<pre><strong>输入：</strong>root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n- 交换 4 和 3 。第 2 层变为 [3,4] 。\n- 交换 7 和 5 。第 3 层变为 [5,6,8,7] 。\n- 交换 8 和 7 。第 3 层变为 [5,6,7,8] 。\n共计用了 3 步操作，所以返回 3 。\n可以证明 3 是需要的最少操作数目。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/09/18/image-20220918174026-3.png\" style=\"width: 400px; height: 303px;\">\n<pre><strong>输入：</strong>root = [1,3,2,7,6,5,4]\n<strong>输出：</strong>3\n<strong>解释：\n</strong>- 交换 3 和 2 。第 2 层变为 [2,3] 。 \n- 交换 7 和 4 。第 3 层变为 [4,6,5,7] 。 \n- 交换 6 和 5 。第 3 层变为 [4,5,6,7] 。\n共计用了 3 步操作，所以返回 3 。 \n可以证明 3 是需要的最少操作数目。\n</pre>\n\n<p><strong>示例 3 ：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2022/09/18/image-20220918174052-4.png\" style=\"width: 400px; height: 274px;\">\n<pre><strong>输入：</strong>root = [1,2,3,4,5,6]\n<strong>输出：</strong>0\n<strong>解释：</strong>每一层已经按递增顺序排序，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 10<sup>5</sup>]</code> 。</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li>树中的所有值 <strong>互不相同</strong> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2472不重叠回文子字符串的最大数目",
        "hardRate": "HARD",
        "passRate": "43.96%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code> 和一个 <strong>正</strong> 整数 <code>k</code> 。</p>\n\n<p>从字符串 <code>s</code> 中选出一组满足下述条件且 <strong>不重叠</strong> 的子字符串：</p>\n\n<ul>\n\t<li>每个子字符串的长度 <strong>至少</strong> 为 <code>k</code> 。</li>\n\t<li>每个子字符串是一个 <strong>回文串</strong> 。</li>\n</ul>\n\n<p>返回最优方案中能选择的子字符串的 <strong>最大</strong> 数目。</p>\n\n<p><strong>子字符串</strong> 是字符串中一个连续的字符序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abaccdbbd\", k = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>可以选择 s = \"<em><strong>aba</strong></em>cc<em><strong>dbbd</strong></em>\" 中斜体加粗的子字符串。\"aba\" 和 \"dbbd\" 都是回文，且长度至少为 k = 3 。\n可以证明，无法选出两个以上的有效子字符串。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"adbcda\", k = 2\n<strong>输出：</strong>0\n<strong>解释：</strong>字符串中不存在长度至少为 2 的回文子字符串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2473购买苹果的最低成本",
        "hardRate": "MEDIUM",
        "passRate": "59.76%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-buy-apples/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-buy-apples/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2474购买量严格增加的客户",
        "hardRate": "HARD",
        "passRate": "49.83%",
        "problemsUrl": "https://leetcode.cn/problems/customers-with-strictly-increasing-purchases/",
        "solutionsUrl": "https://leetcode.cn/problems/customers-with-strictly-increasing-purchases/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2475数组中不等三元组的数目",
        "hardRate": "EASY",
        "passRate": "77.82%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-unequal-triplets-in-array/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-unequal-triplets-in-array/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong> 开始的正整数数组 <code>nums</code> 。请你找出并统计满足下述条件的三元组 <code>(i, j, k)</code> 的数目：</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; k &lt; nums.length</code></li>\n\t<li><code>nums[i]</code>、<code>nums[j]</code> 和 <code>nums[k]</code> <strong>两两不同</strong> 。\n\t<ul>\n\t\t<li>换句话说：<code>nums[i] != nums[j]</code>、<code>nums[i] != nums[k]</code> 且 <code>nums[j] != nums[k]</code> 。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>返回满足上述条件三元组的数目<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,4,2,4,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>下面列出的三元组均满足题目条件：\n- (0, 2, 4) 因为 4 != 2 != 3\n- (1, 2, 4) 因为 4 != 2 != 3\n- (2, 3, 4) 因为 2 != 4 != 3\n共计 3 个三元组，返回 3 。\n注意 (2, 0, 4) 不是有效的三元组，因为 2 &gt; 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,1,1]\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在满足条件的三元组，所以返回 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2476二叉搜索树最近节点查询",
        "hardRate": "MEDIUM",
        "passRate": "41.38%",
        "problemsUrl": "https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/solution",
        "problemsDesc": "<p>给你一个 <strong>二叉搜索树</strong> 的根节点 <code>root</code> ，和一个由正整数组成、长度为 <code>n</code> 的数组 <code>queries</code> 。</p>\n\n<p>请你找出一个长度为 <code>n</code> 的 <strong>二维</strong> 答案数组 <code>answer</code> ，其中 <code>answer[i] = [min<sub>i</sub>, max<sub>i</sub>]</code> ：</p>\n\n<ul>\n\t<li><code>min<sub>i</sub></code> 是树中小于等于&nbsp;<code>queries[i]</code> 的 <strong>最大值</strong> 。如果不存在这样的值，则使用 <code>-1</code> 代替。</li>\n\t<li><code>max<sub>i</sub></code> 是树中大于等于&nbsp;<code>queries[i]</code> 的 <strong>最小值</strong> 。如果不存在这样的值，则使用 <code>-1</code> 代替。</li>\n</ul>\n\n<p>返回数组 <code>answer</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1 ：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/28/bstreeedrawioo.png\" style=\"width: 261px; height: 281px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]\n<strong>输出：</strong>[[2,2],[4,6],[15,-1]]\n<strong>解释：</strong>按下面的描述找出并返回查询的答案：\n- 树中小于等于 2 的最大值是 2 ，且大于等于 2 的最小值也是 2 。所以第一个查询的答案是 [2,2] 。\n- 树中小于等于 5 的最大值是 4 ，且大于等于 5 的最小值是 6 。所以第二个查询的答案是 [4,6] 。\n- 树中小于等于 16 的最大值是 15 ，且大于等于 16 的最小值不存在。所以第三个查询的答案是 [15,-1] 。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/28/bstttreee.png\" style=\"width: 101px; height: 121px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [4,null,9], queries = [3]\n<strong>输出：</strong>[[-1,4]]\n<strong>解释：</strong>树中不存在小于等于 3 的最大值，且大于等于 3 的最小值是 4 。所以查询的答案是 [-1,4] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[2, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>\n\t<li><code>n == queries.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= queries[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2477到达首都的最少油耗",
        "hardRate": "MEDIUM",
        "passRate": "52.99%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/solution",
        "problemsDesc": "<p>给你一棵 <code>n</code>&nbsp;个节点的树（一个无向、连通、无环图），每个节点表示一个城市，编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，且恰好有&nbsp;<code>n - 1</code>&nbsp;条路。<code>0</code>&nbsp;是首都。给你一个二维整数数组&nbsp;<code>roads</code>&nbsp;，其中&nbsp;<code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;，表示城市&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条&nbsp;<strong>双向路</strong>&nbsp;。</p>\n\n<p>每个城市里有一个代表，他们都要去首都参加一个会议。</p>\n\n<p>每座城市里有一辆车。给你一个整数&nbsp;<code>seats</code>&nbsp;表示每辆车里面座位的数目。</p>\n\n<p>城市里的代表可以选择乘坐所在城市的车，或者乘坐其他城市的车。相邻城市之间一辆车的油耗是一升汽油。</p>\n\n<p>请你返回到达首都最少需要多少升汽油。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/22/a4c380025e3ff0c379525e96a7d63a3.png\" style=\"width: 303px; height: 332px;\"></p>\n\n<pre><b>输入：</b>roads = [[0,1],[0,2],[0,3]], seats = 5\n<b>输出：</b>3\n<b>解释：</b>\n- 代表 1 直接到达首都，消耗 1 升汽油。\n- 代表 2 直接到达首都，消耗 1 升汽油。\n- 代表 3 直接到达首都，消耗 1 升汽油。\n最少消耗 3 升汽油。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/16/2.png\" style=\"width: 274px; height: 340px;\"></p>\n\n<pre><b>输入：</b>roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2\n<b>输出：</b>7\n<b>解释：</b>\n- 代表 2 到达城市 3 ，消耗 1 升汽油。\n- 代表 2 和代表 3 一起到达城市 1 ，消耗 1 升汽油。\n- 代表 2 和代表 3 一起到达首都，消耗 1 升汽油。\n- 代表 1 直接到达首都，消耗 1 升汽油。\n- 代表 5 直接到达首都，消耗 1 升汽油。\n- 代表 6 到达城市 4 ，消耗 1 升汽油。\n- 代表 4 和代表 6 一起到达首都，消耗 1 升汽油。\n最少消耗 7 升汽油。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/27/efcf7f7be6830b8763639cfd01b690a.png\" style=\"width: 108px; height: 86px;\"></p>\n\n<pre><b>输入：</b>roads = [], seats = 1\n<b>输出：</b>0\n<b>解释：</b>没有代表需要从别的城市到达首都。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>roads.length == n - 1</code></li>\n\t<li><code>roads[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>roads</code>&nbsp;表示一棵合法的树。</li>\n\t<li><code>1 &lt;= seats &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2478完美分割的方案数",
        "hardRate": "HARD",
        "passRate": "39.93%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-beautiful-partitions/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-beautiful-partitions/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，每个字符是数字&nbsp;<code>'1'</code>&nbsp;到&nbsp;<code>'9'</code>&nbsp;，再给你两个整数&nbsp;<code>k</code> 和&nbsp;<code>minLength</code>&nbsp;。</p>\n\n<p>如果对 <code>s</code>&nbsp;的分割满足以下条件，那么我们认为它是一个 <strong>完美</strong>&nbsp;分割：</p>\n\n<ul>\n\t<li><code>s</code>&nbsp;被分成 <code>k</code>&nbsp;段互不相交的子字符串。</li>\n\t<li>每个子字符串长度都 <strong>至少</strong>&nbsp;为&nbsp;<code>minLength</code>&nbsp;。</li>\n\t<li>每个子字符串的第一个字符都是一个 <b>质数</b> 数字，最后一个字符都是一个 <strong>非质数</strong>&nbsp;数字。质数数字为&nbsp;<code>'2'</code>&nbsp;，<code>'3'</code>&nbsp;，<code>'5'</code>&nbsp;和&nbsp;<code>'7'</code>&nbsp;，剩下的都是非质数数字。</li>\n</ul>\n\n<p>请你返回 <code>s</code>&nbsp;的 <strong>完美</strong>&nbsp;分割数目。由于答案可能很大，请返回答案对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后的结果。</p>\n\n<p>一个 <strong>子字符串</strong>&nbsp;是字符串中一段连续字符串序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"23542185131\", k = 3, minLength = 2\n<b>输出：</b>3\n<b>解释：</b>存在 3 种完美分割方案：\n\"2354 | 218 | 5131\"\n\"2354 | 21851 | 31\"\n\"2354218 | 51 | 31\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"23542185131\", k = 3, minLength = 3\n<b>输出：</b>1\n<b>解释：</b>存在一种完美分割方案：\"2354 | 218 | 5131\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>s = \"3312958\", k = 3, minLength = 1\n<b>输出：</b>1\n<b>解释：</b>存在一种完美分割方案：\"331 | 29 | 58\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k, minLength &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code>&nbsp;每个字符都为数字&nbsp;<code>'1'</code>&nbsp;到&nbsp;<code>'9'</code> 之一。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2479两个不重叠子树的最大异或值",
        "hardRate": "HARD",
        "passRate": "65.86%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-xor-of-two-non-overlapping-subtrees/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-xor-of-two-non-overlapping-subtrees/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2480形成化学键",
        "hardRate": "EASY",
        "passRate": "84.17%",
        "problemsUrl": "https://leetcode.cn/problems/form-a-chemical-bond/",
        "solutionsUrl": "https://leetcode.cn/problems/form-a-chemical-bond/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2481分割圆的最少切割次数",
        "hardRate": "EASY",
        "passRate": "58.77%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cuts-to-divide-a-circle/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cuts-to-divide-a-circle/solution",
        "problemsDesc": "<p>圆内一个 <strong>有效切割</strong>&nbsp;，符合以下二者之一：</p>\n\n<ul>\n\t<li>该切割是两个端点在圆上的线段，且该线段经过圆心。</li>\n\t<li>该切割是一端在圆心另一端在圆上的线段。</li>\n</ul>\n\n<p>一些有效和无效的切割如下图所示。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/29/alldrawio.png\" style=\"width: 450px; height: 174px;\" /></p>\n\n<p>给你一个整数&nbsp;<code>n</code>&nbsp;，请你返回将圆切割成相等的&nbsp;<code>n</code>&nbsp;等分的&nbsp;<strong>最少</strong>&nbsp;切割次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/24/11drawio.png\" style=\"width: 200px; height: 200px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 4\n<b>输出：</b>2\n<b>解释：</b>\n上图展示了切割圆 2 次，得到四等分。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/24/22drawio.png\" style=\"width: 200px; height: 201px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 3\n<b>输出：</b>3\n<strong>解释：</strong>\n最少需要切割 3 次，将圆切成三等分。\n少于 3 次切割无法将圆切成大小相等面积相同的 3 等分。\n同时可以观察到，第一次切割无法将圆切割开。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2482行和列中一和零的差值",
        "hardRate": "MEDIUM",
        "passRate": "82.42%",
        "problemsUrl": "https://leetcode.cn/problems/difference-between-ones-and-zeros-in-row-and-column/",
        "solutionsUrl": "https://leetcode.cn/problems/difference-between-ones-and-zeros-in-row-and-column/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;二进制矩阵&nbsp;<code>grid</code>&nbsp;。</p>\n\n<p>我们按照如下过程，定义一个下标从 <strong>0</strong>&nbsp;开始的&nbsp;<code>m x n</code>&nbsp;差值矩阵&nbsp;<code>diff</code>&nbsp;：</p>\n\n<ul>\n\t<li>令第&nbsp;<code>i</code>&nbsp;行一的数目为&nbsp;<code>onesRow<sub>i</sub></code>&nbsp;。</li>\n\t<li>令第&nbsp;<code>j</code>&nbsp;列一的数目为&nbsp;<code>onesCol<sub>j</sub></code><sub>&nbsp;</sub>。</li>\n\t<li>令第&nbsp;<code>i</code>&nbsp;行零的数目为&nbsp;<code>zerosRow<sub>i</sub></code>&nbsp;。</li>\n\t<li>令第&nbsp;<code>j</code>&nbsp;列零的数目为&nbsp;<code>zerosCol<sub>j</sub></code>&nbsp;。</li>\n\t<li><code>diff[i][j] = onesRow<sub>i</sub> + onesCol<sub>j</sub> - zerosRow<sub>i</sub> - zerosCol<sub>j</sub></code></li>\n</ul>\n\n<p>请你返回差值矩阵<em>&nbsp;</em><code>diff</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2022/11/06/image-20221106171729-5.png\" style=\"width: 400px; height: 208px;\"></p>\n\n<pre><b>输入：</b>grid = [[0,1,1],[1,0,1],[0,0,1]]\n<b>输出：</b>[[0,0,4],[0,0,4],[-2,-2,2]]\n<b>解释：</b>\n- diff[0][0] = <code>onesRow<sub>0</sub> + onesCol<sub>0</sub> - zerosRow<sub>0</sub> - zerosCol<sub>0</sub></code> = 2 + 1 - 1 - 2 = 0 \n- diff[0][1] = <code>onesRow<sub>0</sub> + onesCol<sub>1</sub> - zerosRow<sub>0</sub> - zerosCol<sub>1</sub></code> = 2 + 1 - 1 - 2 = 0 \n- diff[0][2] = <code>onesRow<sub>0</sub> + onesCol<sub>2</sub> - zerosRow<sub>0</sub> - zerosCol<sub>2</sub></code> = 2 + 3 - 1 - 0 = 4 \n- diff[1][0] = <code>onesRow<sub>1</sub> + onesCol<sub>0</sub> - zerosRow<sub>1</sub> - zerosCol<sub>0</sub></code> = 2 + 1 - 1 - 2 = 0 \n- diff[1][1] = <code>onesRow<sub>1</sub> + onesCol<sub>1</sub> - zerosRow<sub>1</sub> - zerosCol<sub>1</sub></code> = 2 + 1 - 1 - 2 = 0 \n- diff[1][2] = <code>onesRow<sub>1</sub> + onesCol<sub>2</sub> - zerosRow<sub>1</sub> - zerosCol<sub>2</sub></code> = 2 + 3 - 1 - 0 = 4 \n- diff[2][0] = <code>onesRow<sub>2</sub> + onesCol<sub>0</sub> - zerosRow<sub>2</sub> - zerosCol<sub>0</sub></code> = 1 + 1 - 2 - 2 = -2\n- diff[2][1] = <code>onesRow<sub>2</sub> + onesCol<sub>1</sub> - zerosRow<sub>2</sub> - zerosCol<sub>1</sub></code> = 1 + 1 - 2 - 2 = -2\n- diff[2][2] = <code>onesRow<sub>2</sub> + onesCol<sub>2</sub> - zerosRow<sub>2</sub> - zerosCol<sub>2</sub></code> = 1 + 3 - 2 - 0 = 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2022/11/06/image-20221106171747-6.png\" style=\"width: 358px; height: 150px;\"></p>\n\n<pre><b>输入：</b>grid = [[1,1,1],[1,1,1]]\n<b>输出：</b>[[5,5,5],[5,5,5]]\n<strong>解释：</strong>\n- diff[0][0] = onesRow<sub>0</sub> + onesCol<sub>0</sub> - zerosRow<sub>0</sub> - zerosCol<sub>0</sub> = 3 + 2 - 0 - 0 = 5\n- diff[0][1] = onesRow<sub>0</sub> + onesCol<sub>1</sub> - zerosRow<sub>0</sub> - zerosCol<sub>1</sub> = 3 + 2 - 0 - 0 = 5\n- diff[0][2] = onesRow<sub>0</sub> + onesCol<sub>2</sub> - zerosRow<sub>0</sub> - zerosCol<sub>2</sub> = 3 + 2 - 0 - 0 = 5\n- diff[1][0] = onesRow<sub>1</sub> + onesCol<sub>0</sub> - zerosRow<sub>1</sub> - zerosCol<sub>0</sub> = 3 + 2 - 0 - 0 = 5\n- diff[1][1] = onesRow<sub>1</sub> + onesCol<sub>1</sub> - zerosRow<sub>1</sub> - zerosCol<sub>1</sub> = 3 + 2 - 0 - 0 = 5\n- diff[1][2] = onesRow<sub>1</sub> + onesCol<sub>2</sub> - zerosRow<sub>1</sub> - zerosCol<sub>2</sub> = 3 + 2 - 0 - 0 = 5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>grid[i][j]</code>&nbsp;要么是&nbsp;<code>0</code>&nbsp;，要么是&nbsp;<code>1</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2483商店的最少代价",
        "hardRate": "MEDIUM",
        "passRate": "63.31%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-penalty-for-a-shop/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-penalty-for-a-shop/solution",
        "problemsDesc": "<p>给你一个顾客访问商店的日志，用一个下标从 <strong>0</strong>&nbsp;开始且只包含字符&nbsp;<code>'N'</code> 和&nbsp;<code>'Y'</code>&nbsp;的字符串&nbsp;<code>customers</code>&nbsp;表示：</p>\n\n<ul>\n\t<li>如果第&nbsp;<code>i</code>&nbsp;个字符是&nbsp;<code>'Y'</code>&nbsp;，它表示第&nbsp;<code>i</code>&nbsp;小时有顾客到达。</li>\n\t<li>如果第&nbsp;<code>i</code>&nbsp;个字符是&nbsp;<code>'N'</code>&nbsp;，它表示第 <code>i</code>&nbsp;小时没有顾客到达。</li>\n</ul>\n\n<p>如果商店在第&nbsp;<code>j</code>&nbsp;小时关门（<code>0 &lt;= j &lt;= n</code>），代价按如下方式计算：</p>\n\n<ul>\n\t<li>在开门期间，如果某一个小时没有顾客到达，代价增加 <code>1</code>&nbsp;。</li>\n\t<li>在关门期间，如果某一个小时有顾客到达，代价增加&nbsp;<code>1</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回在确保代价 <strong>最小</strong>&nbsp;的前提下，商店的&nbsp;<strong>最早</strong>&nbsp;关门时间。</p>\n\n<p>注意，商店在第 <code>j</code>&nbsp;小时关门表示在第 <code>j</code> 小时以及之后商店处于关门状态。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>customers = \"YYNY\"\n<b>输出：</b>2\n<b>解释：</b>\n- 第 0 小时关门，总共 1+1+0+1 = 3 代价。\n- 第 1 小时关门，总共 0+1+0+1 = 2 代价。\n- 第 2 小时关门，总共 0+0+0+1 = 1 代价。\n- 第 3 小时关门，总共 0+0+1+1 = 2 代价。\n- 第 4 小时关门，总共 0+0+1+0 = 1 代价。\n在第 2 或第 4 小时关门代价都最小。由于第 2 小时更早，所以最优关门时间是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>customers = \"NNNNN\"\n<b>输出：</b>0\n<b>解释：</b>最优关门时间是 0 ，因为自始至终没有顾客到达。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>customers = \"YYYY\"\n<b>输出：</b>4\n<b>解释：</b>最优关门时间是 4 ，因为每一小时均有顾客到达。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= customers.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>customers</code>&nbsp;只包含字符&nbsp;<code>'Y'</code>&nbsp;和&nbsp;<code>'N'</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2484统计回文子序列数目",
        "hardRate": "HARD",
        "passRate": "47.12%",
        "problemsUrl": "https://leetcode.cn/problems/count-palindromic-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/count-palindromic-subsequences/solution",
        "problemsDesc": "<p>给你数字字符串&nbsp;<code>s</code>&nbsp;，请你返回&nbsp;<code>s</code>&nbsp;中长度为&nbsp;<code>5</code>&nbsp;的 <b>回文子序列</b>&nbsp;数目。由于答案可能很大，请你将答案对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>如果一个字符串从前往后和从后往前读相同，那么它是 <strong>回文字符串</strong>&nbsp;。</li>\n\t<li>子序列是一个字符串中删除若干个字符后，不改变字符顺序，剩余字符构成的字符串。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = \"103301\"\n<b>输出：</b>2\n<b>解释：</b>\n总共有 6 长度为 5 的子序列：\"10330\" ，\"10331\" ，\"10301\" ，\"10301\" ，\"13301\" ，\"03301\" 。\n它们中有两个（都是 \"10301\"）是回文的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>s = \"0000000\"\n<b>输出：</b>21\n<b>解释：</b>所有 21 个长度为 5 的子序列都是 \"00000\" ，都是回文的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><b>输入：</b>s = \"9999900000\"\n<b>输出：</b>2\n<b>解释：</b>仅有的两个回文子序列是 \"99999\" 和 \"00000\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含数字字符。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2485找出中枢整数",
        "hardRate": "EASY",
        "passRate": "80.81%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-pivot-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-pivot-integer/solution",
        "problemsDesc": "<p>给你一个正整数 <code>n</code> ，找出满足下述条件的<strong> 中枢整数</strong> <code>x</code> ：</p>\n\n<ul>\n\t<li><code>1</code> 和 <code>x</code> 之间的所有元素之和等于 <code>x</code> 和 <code>n</code> 之间所有元素之和。</li>\n</ul>\n\n<p>返回中枢整数<em> </em><code>x</code> 。如果不存在中枢整数，则返回 <code>-1</code> 。题目保证对于给定的输入，至多存在一个中枢整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 8\n<strong>输出：</strong>6\n<strong>解释：</strong>6 是中枢整数，因为 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>1 是中枢整数，因为 1 = 1 。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>-1\n<strong>解释：</strong>可以证明不存在满足题目要求的整数。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2486追加字符以获得子序列",
        "hardRate": "MEDIUM",
        "passRate": "65.15%",
        "problemsUrl": "https://leetcode.cn/problems/append-characters-to-string-to-make-subsequence/",
        "solutionsUrl": "https://leetcode.cn/problems/append-characters-to-string-to-make-subsequence/solution",
        "problemsDesc": "<p>给你两个仅由小写英文字母组成的字符串 <code>s</code> 和 <code>t</code> 。</p>\n\n<p>现在需要通过向 <code>s</code> 末尾追加字符的方式使 <code>t</code> 变成 <code>s</code> 的一个 <strong>子序列</strong> ，返回需要追加的最少字符数。</p>\n\n<p>子序列是一个可以由其他字符串删除部分（或不删除）字符但不改变剩下字符顺序得到的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"coaching\", t = \"coding\"\n<strong>输出：</strong>4\n<strong>解释：</strong>向 s 末尾追加字符串 \"ding\" ，s = \"coachingding\" 。\n现在，t 是 s (\"<em><strong>co</strong></em>aching<em><strong>ding</strong></em>\") 的一个子序列。\n可以证明向 s 末尾追加任何 3 个字符都无法使 t 成为 s 的一个子序列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcde\", t = \"a\"\n<strong>输出：</strong>0\n<strong>解释：</strong>t 已经是 s (\"<em><strong>a</strong></em>bcde\") 的一个子序列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"z\", t = \"abcde\"\n<strong>输出：</strong>5\n<strong>解释：</strong>向 s 末尾追加字符串 \"abcde\" ，s = \"zabcde\" 。\n现在，t 是 s (\"z<em><strong>abcde</strong></em>\") 的一个子序列。 \n可以证明向 s 末尾追加任何 4 个字符都无法使 t 成为 s 的一个子序列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 和 <code>t</code> 仅由小写英文字母组成</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2487从链表中移除节点",
        "hardRate": "MEDIUM",
        "passRate": "68.86%",
        "problemsUrl": "https://leetcode.cn/problems/remove-nodes-from-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-nodes-from-linked-list/solution",
        "problemsDesc": "<p>给你一个链表的头节点 <code>head</code> 。</p>\n\n<p>对于列表中的每个节点 <code>node</code> ，如果其右侧存在一个具有 <strong>严格更大</strong> 值的节点，则移除 <code>node</code> 。</p>\n\n<p>返回修改后链表的头节点<em> </em><code>head</code><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/02/drawio.png\" style=\"width: 631px; height: 51px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [5,2,13,3,8]\n<strong>输出：</strong>[13,8]\n<strong>解释：</strong>需要移除的节点是 5 ，2 和 3 。\n- 节点 13 在节点 5 右侧。\n- 节点 13 在节点 2 右侧。\n- 节点 8 在节点 3 右侧。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,1,1,1]\n<strong>输出：</strong>[1,1,1,1]\n<strong>解释：</strong>每个节点的值都是 1 ，所以没有需要移除的节点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给定列表中的节点数目在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2488统计中位数为 K 的子数组",
        "hardRate": "HARD",
        "passRate": "50.77%",
        "problemsUrl": "https://leetcode.cn/problems/count-subarrays-with-median-k/",
        "solutionsUrl": "https://leetcode.cn/problems/count-subarrays-with-median-k/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的数组 <code>nums</code> ，该数组由从 <code>1</code> 到 <code>n</code> 的 <strong>不同</strong> 整数组成。另给你一个正整数 <code>k</code> 。</p>\n\n<p>统计并返回 <code>nums</code> 中的 <strong>中位数</strong> 等于 <code>k</code> 的非空子数组的数目。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>数组的中位数是按 <strong>递增</strong> 顺序排列后位于 <strong>中间</strong> 的那个元素，如果数组长度为偶数，则中位数是位于中间靠 <strong>左</strong> 的那个元素。\n\n\t<ul>\n\t\t<li>例如，<code>[2,3,1,4]</code> 的中位数是 <code>2</code> ，<code>[8,4,3,5,1]</code> 的中位数是 <code>4</code> 。</li>\n\t</ul>\n\t</li>\n\t<li>子数组是数组中的一个连续部分。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,1,4,5], k = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>中位数等于 4 的子数组有：[4]、[4,5] 和 [1,4,5] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,1], k = 3\n<strong>输出：</strong>1\n<strong>解释：</strong>[3] 是唯一一个中位数等于 3 的子数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i], k &lt;= n</code></li>\n\t<li><code>nums</code> 中的整数互不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2489固定比率的子字符串数",
        "hardRate": "MEDIUM",
        "passRate": "68.36%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-substrings-with-fixed-ratio/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-substrings-with-fixed-ratio/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2490回环句",
        "hardRate": "EASY",
        "passRate": "73.66%",
        "problemsUrl": "https://leetcode.cn/problems/circular-sentence/",
        "solutionsUrl": "https://leetcode.cn/problems/circular-sentence/solution",
        "problemsDesc": "<p><strong>句子</strong> 是由单个空格分隔的一组单词，且不含前导或尾随空格。</p>\n\n<ul>\n\t<li>例如，<code>\"Hello World\"</code>、<code>\"HELLO\"</code>、<code>\"hello world hello world\"</code> 都是符合要求的句子。</li>\n</ul>\n\n<p>单词 <strong>仅</strong> 由大写和小写英文字母组成。且大写和小写字母会视作不同字符。</p>\n\n<p>如果句子满足下述全部条件，则认为它是一个 <strong>回环句</strong> ：</p>\n\n<ul>\n\t<li>单词的最后一个字符和下一个单词的第一个字符相等。</li>\n\t<li>最后一个单词的最后一个字符和第一个单词的第一个字符相等。</li>\n</ul>\n\n<p>例如，<code>\"leetcode exercises sound delightful\"</code>、<code>\"eetcode\"</code>、<code>\"leetcode eats soul\"</code> 都是回环句。然而，<code>\"Leetcode is cool\"</code>、<code>\"happy Leetcode\"</code>、<code>\"Leetcode\"</code> 和 <code>\"I like Leetcode\"</code> 都 <strong>不</strong> 是回环句。</p>\n\n<p>给你一个字符串 <code>sentence</code> ，请你判断它是不是一个回环句。如果是，返回 <code>true</code><em> </em>；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"leetcode exercises sound delightful\"\n<strong>输出：</strong>true\n<strong>解释：</strong>句子中的单词是 [\"leetcode\", \"exercises\", \"sound\", \"delightful\"] 。\n- leetcod<strong><em>e</em></strong> 的最后一个字符和 <strong><em>e</em></strong>xercises 的第一个字符相等。\n- exercise<em><strong>s</strong></em> 的最后一个字符和 <em><strong>s</strong></em>ound 的第一个字符相等。\n- <em><strong>s</strong></em>ound 的最后一个字符和 delightfu<em><strong>l</strong></em> 的第一个字符相等。\n- delightfu<em><strong>l</strong></em> 的最后一个字符和 <em><strong>l</strong></em>eetcode 的第一个字符相等。\n这个句子是回环句。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"eetcode\"\n<strong>输出：</strong>true\n<strong>解释：</strong>句子中的单词是 [\"eetcode\"] 。\n- eetcod<em><strong>e</strong></em> 的最后一个字符和 <em><strong>e</strong></em>etcod<em>e</em> 的第一个字符相等。\n这个句子是回环句。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"Leetcode is cool\"\n<strong>输出：</strong>false\n<strong>解释：</strong>句子中的单词是 [\"Leetcode\", \"is\", \"cool\"] 。\n- Leetcod<em><strong>e</strong></em>&nbsp;的最后一个字符和 <em><strong>i</strong></em>s 的第一个字符 <strong>不</strong> 相等。 \n这个句子 <strong>不</strong> 是回环句。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentence.length &lt;= 500</code></li>\n\t<li><code>sentence</code> 仅由大小写英文字母和空格组成</li>\n\t<li><code>sentence</code> 中的单词由单个空格进行分隔</li>\n\t<li>不含任何前导或尾随空格</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2491划分技能点相等的团队",
        "hardRate": "MEDIUM",
        "passRate": "55.30%",
        "problemsUrl": "https://leetcode.cn/problems/divide-players-into-teams-of-equal-skill/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-players-into-teams-of-equal-skill/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>skill</code> ，数组长度为 <strong>偶数</strong> <code>n</code> ，其中 <code>skill[i]</code> 表示第 <code>i</code> 个玩家的技能点。将所有玩家分成 <code>n / 2</code> 个 <code>2</code> 人团队，使每一个团队的技能点之和 <strong>相等</strong> 。</p>\n\n<p>团队的 <strong>化学反应</strong> 等于团队中玩家的技能点 <strong>乘积</strong> 。</p>\n\n<p>返回所有团队的 <strong>化学反应</strong> 之和，如果无法使每个团队的技能点之和相等，则返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>skill = [3,2,5,1,3,4]\n<strong>输出：</strong>22\n<strong>解释：</strong>\n将玩家分成 3 个团队 (1, 5), (2, 4), (3, 3) ，每个团队的技能点之和都是 6 。\n所有团队的化学反应之和是 1 * 5 + 2 * 4 + 3 * 3 = 5 + 8 + 9 = 22 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>skill = [3,4]\n<strong>输出：</strong>12\n<strong>解释：</strong>\n两个玩家形成一个团队，技能点之和是 7 。\n团队的化学反应是 3 * 4 = 12 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>skill = [1,1,2,3]\n<strong>输出：</strong>-1\n<strong>解释：</strong>\n无法将玩家分成每个团队技能点都相等的若干个 2 人团队。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= skill.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>skill.length</code> 是偶数</li>\n\t<li><code>1 &lt;= skill[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2492两个城市间路径的最小分数",
        "hardRate": "MEDIUM",
        "passRate": "41.39%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-score-of-a-path-between-two-cities/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-score-of-a-path-between-two-cities/solution",
        "problemsDesc": "<p>给你一个正整数&nbsp;<code>n</code>&nbsp;，表示总共有&nbsp;<code>n</code>&nbsp;个城市，城市从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;编号。给你一个二维数组&nbsp;<code>roads</code>&nbsp;，其中&nbsp;<code>roads[i] = [a<sub>i</sub>, b<sub>i</sub>, distance<sub>i</sub>]</code>&nbsp;表示城市&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条 <strong>双向</strong>&nbsp;道路，道路距离为&nbsp;<code>distance<sub>i</sub></code>&nbsp;。城市构成的图不一定是连通的。</p>\n\n<p>两个城市之间一条路径的 <strong>分数</strong>&nbsp;定义为这条路径中道路的 <strong>最小</strong>&nbsp;距离。</p>\n\n<p><span class=\"text-only\" data-eleid=\"20\" style=\"white-space: pre;\">城市</span><span class=\"text-only text-font-italic\" data-eleid=\"21\" style=\"white-space: pre;\"> </span><code><span class=\"text-only\" data-eleid=\"22\" style=\"white-space: pre;\">1</span></code><span class=\"text-only text-font-italic\" data-eleid=\"23\" style=\"white-space: pre;\"> </span><span class=\"text-only\" data-eleid=\"24\" style=\"white-space: pre;\">和城市</span><span class=\"text-only text-font-italic\" data-eleid=\"25\" style=\"white-space: pre;\"> </span><span class=\"text-only\" data-eleid=\"26\" style=\"white-space: pre;\"><code>n</code> 之间的所有路径的 </span><strong><span class=\"text-only\" data-eleid=\"27\" style=\"white-space: pre;\">最小</span></strong><span class=\"text-only\" data-eleid=\"28\" style=\"white-space: pre;\"> 分数。</span></p>\n\n<p><b>注意：</b></p>\n\n<ul>\n\t<li>一条路径指的是两个城市之间的道路序列。</li>\n\t<li>一条路径可以 <strong>多次</strong> 包含同一条道路，你也可以沿着路径多次到达城市 <code>1</code>&nbsp;和城市 <code>n</code>&nbsp;。</li>\n\t<li>测试数据保证城市 <code>1</code>&nbsp;和城市<code>n</code>&nbsp;之间 <strong>至少</strong>&nbsp;有一条路径。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/12/graph11.png\" style=\"width: 190px; height: 231px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]\n<b>输出：</b>5\n<b>解释：</b>城市 1 到城市 4 的路径中，分数最小的一条为：1 -&gt; 2 -&gt; 4 。这条路径的分数是 min(9,5) = 5 。\n不存在分数更小的路径。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/12/graph22.png\" style=\"width: 190px; height: 231px;\" /></p>\n\n<pre>\n<b>输入：</b>n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]]\n<b>输出：</b>2\n<b>解释：</b>城市 1 到城市 4 分数最小的路径是：1 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4 。这条路径的分数是 min(2,2,4,7) = 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= roads.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>roads[i].length == 3</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>1 &lt;= distance<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li>不会有重复的边。</li>\n\t<li>城市 <code>1</code>&nbsp;和城市 <code>n</code>&nbsp;之间至少有一条路径。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2493将节点分成尽可能多的组",
        "hardRate": "HARD",
        "passRate": "43.74%",
        "problemsUrl": "https://leetcode.cn/problems/divide-nodes-into-the-maximum-number-of-groups/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-nodes-into-the-maximum-number-of-groups/solution",
        "problemsDesc": "<p>给你一个正整数&nbsp;<code>n</code>&nbsp;，表示一个 <strong>无向</strong>&nbsp;图中的节点数目，节点编号从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;。</p>\n\n<p>同时给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i, </sub>b<sub>i</sub>]</code>&nbsp;表示节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code><sub>&nbsp;</sub>之间有一条&nbsp;<strong>双向</strong>&nbsp;边。注意给定的图可能是不连通的。</p>\n\n<p>请你将图划分为&nbsp;<code>m</code>&nbsp;个组（编号从 <strong>1</strong>&nbsp;开始），满足以下要求：</p>\n\n<ul>\n\t<li>图中每个节点都只属于一个组。</li>\n\t<li>图中每条边连接的两个点&nbsp;<code>[a<sub>i, </sub>b<sub>i</sub>]</code>&nbsp;，如果&nbsp;<code>a<sub>i</sub></code>&nbsp;属于编号为&nbsp;<code>x</code>&nbsp;的组，<code>b<sub>i</sub></code>&nbsp;属于编号为&nbsp;<code>y</code>&nbsp;的组，那么&nbsp;<code>|y - x| = 1</code>&nbsp;。</li>\n</ul>\n\n<p>请你返回最多可以将节点分为多少个组（也就是最大的<em>&nbsp;</em><code>m</code>&nbsp;）。如果没办法在给定条件下分组，请你返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/13/example1.png\" style=\"width: 352px; height: 201px;\"></p>\n\n<pre><b>输入：</b>n = 6, edges = [[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]]\n<b>输出：</b>4\n<b>解释：</b>如上图所示，\n- 节点 5 在第一个组。\n- 节点 1 在第二个组。\n- 节点 2 和节点 4 在第三个组。\n- 节点 3 和节点 6 在第四个组。\n所有边都满足题目要求。\n如果我们创建第五个组，将第三个组或者第四个组中任何一个节点放到第五个组，至少有一条边连接的两个节点所属的组编号不符合题目要求。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>n = 3, edges = [[1,2],[2,3],[3,1]]\n<b>输出：</b>-1\n<b>解释：</b>如果我们将节点 1 放入第一个组，节点 2 放入第二个组，节点 3 放入第三个组，前两条边满足题目要求，但第三条边不满足题目要求。\n没有任何符合题目要求的分组方式。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>两个点之间至多只有一条边。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2494合并在同一个大厅重叠的活动",
        "hardRate": "HARD",
        "passRate": "39.29%",
        "problemsUrl": "https://leetcode.cn/problems/merge-overlapping-events-in-the-same-hall/",
        "solutionsUrl": "https://leetcode.cn/problems/merge-overlapping-events-in-the-same-hall/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2495乘积为偶数的子数组数",
        "hardRate": "MEDIUM",
        "passRate": "68.71%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-subarrays-having-even-product/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-subarrays-having-even-product/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 2496数组中字符串的最大值",
        "hardRate": "EASY",
        "passRate": "79.49%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-value-of-a-string-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-value-of-a-string-in-an-array/solution",
        "problemsDesc": "<p>一个由字母和数字组成的字符串的 <strong>值</strong>&nbsp;定义如下：</p>\n\n<ul>\n\t<li>如果字符串 <strong>只</strong> 包含数字，那么值为该字符串在 <code>10</code>&nbsp;进制下的所表示的数字。</li>\n\t<li>否则，值为字符串的 <strong>长度&nbsp;</strong>。</li>\n</ul>\n\n<p>给你一个字符串数组&nbsp;<code>strs</code>&nbsp;，每个字符串都只由字母和数字组成，请你返回 <code>strs</code>&nbsp;中字符串的 <strong>最大值</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"alic3\",\"bob\",\"3\",\"4\",\"00000\"]\n<b>输出：</b>5\n<b>解释：</b>\n- \"alic3\" 包含字母和数字，所以值为长度 5 。\n- \"bob\" 只包含字母，所以值为长度 3 。\n- \"3\" 只包含数字，所以值为 3 。\n- \"4\" 只包含数字，所以值为 4 。\n- \"00000\" 只包含数字，所以值为 0 。\n所以最大的值为 5 ，是字符串 \"alic3\" 的值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>strs = [\"1\",\"01\",\"001\",\"0001\"]\n<b>输出：</b>1\n<b>解释：</b>\n数组中所有字符串的值都是 1 ，所以我们返回 1 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= strs[i].length &lt;= 9</code></li>\n\t<li><code>strs[i]</code>&nbsp;只包含小写英文字母和数字。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2497图中最大星和",
        "hardRate": "MEDIUM",
        "passRate": "38.24%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-star-sum-of-a-graph/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-star-sum-of-a-graph/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>n</code>&nbsp;个点的无向图，节点从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;编号。给你一个长度为 <code>n</code>&nbsp;下标从&nbsp;<strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>vals</code>&nbsp;，其中&nbsp;<code>vals[i]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个节点的值。</p>\n\n<p>同时给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示节点&nbsp;<code>a<sub>i</sub></code> 和&nbsp;<code>b<sub>i</sub></code>&nbsp;之间有一条双向边。</p>\n\n<p><strong>星图</strong>&nbsp;是给定图中的一个子图，它包含一个中心节点和&nbsp;<code>0</code>&nbsp;个或更多个邻居。换言之，星图是给定图中一个边的子集，且这些边都有一个公共节点。</p>\n\n<p>下图分别展示了有 <code>3</code>&nbsp;个和 <code>4</code>&nbsp;个邻居的星图，蓝色节点为中心节点。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/07/max-star-sum-descdrawio.png\" style=\"width: 400px; height: 179px;\"></p>\n\n<p><strong>星和</strong> 定义为星图中所有节点值的和。</p>\n\n<p>给你一个整数&nbsp;<code>k</code>&nbsp;，请你返回 <strong>至多</strong>&nbsp;包含 <code>k</code>&nbsp;条边的星图中的 <strong>最大星和</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/07/max-star-sum-example1drawio.png\" style=\"width: 300px; height: 291px;\"></p>\n\n<pre><b>输入：</b>vals = [1,2,3,4,10,-10,-20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2\n<b>输出：</b>16\n<b>解释：</b>上图展示了输入示例。\n最大星和对应的星图在上图中用蓝色标出。中心节点是 3 ，星图中还包含邻居 1 和 4 。\n无法得到一个和大于 16 且边数不超过 2 的星图。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><b>输入：</b>vals = [-5], edges = [], k = 0\n<b>输出：</b>-5\n<b>解释：</b>只有一个星图，就是节点 0 自己。\n所以我们返回 -5 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == vals.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= vals[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= edges.length &lt;= min(n * (n - 1) / 2</code><code>, 10<sup>5</sup>)</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li><code>0 &lt;= k &lt;= n - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2498青蛙过河 II",
        "hardRate": "MEDIUM",
        "passRate": "64.50%",
        "problemsUrl": "https://leetcode.cn/problems/frog-jump-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/frog-jump-ii/solution",
        "problemsDesc": "<p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>stones</code>&nbsp;，数组中的元素&nbsp;<strong>严格递增</strong>&nbsp;，表示一条河中石头的位置。</p>\n\n<p>一只青蛙一开始在第一块石头上，它想到达最后一块石头，然后回到第一块石头。同时每块石头 <strong>至多</strong> 到达 <strong>一次。</strong></p>\n\n<p>一次跳跃的 <strong>长度</strong>&nbsp;是青蛙跳跃前和跳跃后所在两块石头之间的距离。</p>\n\n<ul>\n\t<li>更正式的，如果青蛙从&nbsp;<code>stones[i]</code>&nbsp;跳到&nbsp;<code>stones[j]</code>&nbsp;，跳跃的长度为&nbsp;<code>|stones[i] - stones[j]|</code>&nbsp;。</li>\n</ul>\n\n<p>一条路径的 <b>代价</b>&nbsp;是这条路径里的&nbsp;<b>最大跳跃长度</b>&nbsp;。</p>\n\n<p>请你返回这只青蛙的 <strong>最小代价</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/14/example-1.png\" style=\"width: 600px; height: 219px;\" /></p>\n\n<pre>\n<b>输入：</b>stones = [0,2,5,6,7]\n<b>输出：</b>5\n<b>解释：</b>上图展示了一条最优路径。\n这条路径的代价是 5 ，是这条路径中的最大跳跃长度。\n无法得到一条代价小于 5 的路径，我们返回 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/11/14/example-2.png\" style=\"width: 500px; height: 171px;\" /></p>\n\n<pre>\n<b>输入：</b>stones = [0,3,9]\n<b>输出：</b>9\n<b>解释：</b>\n青蛙可以直接跳到最后一块石头，然后跳回第一块石头。\n在这条路径中，每次跳跃长度都是 9 。所以路径代价是 max(9, 9) = 9 。\n这是可行路径中的最小代价。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= stones.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= stones[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>stones[0] == 0</code></li>\n\t<li><code>stones</code>&nbsp;中的元素严格递增。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2499让数组不相等的最小总代价",
        "hardRate": "HARD",
        "passRate": "42.03%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-total-cost-to-make-arrays-unequal/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-total-cost-to-make-arrays-unequal/solution",
        "problemsDesc": "<p>给你两个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>&nbsp;，两者长度都为&nbsp;<code>n</code>&nbsp;。</p>\n\n<p>每次操作中，你可以选择交换 <code>nums1</code>&nbsp;中任意两个下标处的值。操作的 <strong>开销</strong>&nbsp;为两个下标的 <strong>和</strong>&nbsp;。</p>\n\n<p>你的目标是对于所有的 <code>0 &lt;= i &lt;= n - 1</code>&nbsp;，都满足&nbsp;<code>nums1[i] != nums2[i]</code>&nbsp;，你可以进行 <strong>任意次</strong>&nbsp;操作，请你返回达到这个目标的 <strong>最小</strong>&nbsp;总代价。</p>\n\n<p>请你返回让<em>&nbsp;</em><code>nums1</code> 和&nbsp;<code>nums2</code><em>&nbsp;</em>满足上述条件的 <strong>最小总代价</strong> ，如果无法达成目标，返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]\n<b>输出：</b>10\n<b>解释：</b>\n实现目标的其中一种方法为：\n- 交换下标为 0 和 3 的两个值，代价为 0 + 3 = 3 。现在 nums1 = [4,2,3,1,5] 。\n- 交换下标为 1 和 2 的两个值，代价为 1 + 2 = 3 。现在 nums1 = [4,3,2,1,5] 。\n- 交换下标为 0 和 4 的两个值，代价为 0 + 4 = 4 。现在 nums1 = [5,3,2,1,4] 。\n最后，对于每个下标 i ，都有 nums1[i] != nums2[i] 。总代价为 10 。\n还有别的交换值的方法，但是无法得到代价和小于 10 的方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]\n<b>输出：</b>10\n<b>解释：</b>\n实现目标的一种方法为：\n- 交换下标为 2 和 3 的两个值，代价为 2 + 3 = 5 。现在 nums1 = [2,2,1,2,3] 。\n- 交换下标为 1 和 4 的两个值，代价为 1 + 4 = 5 。现在 nums1 = [2,3,1,2,2] 。\n总代价为 10 ，是所有方案中的最小代价。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>nums1 = [1,2,2], nums2 = [1,2,2]\n<b>输出：</b>-1\n<b>解释：</b>\n不管怎么操作，都无法满足题目要求。\n所以返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length == nums2.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 2500删除每行中的最大值",
        "hardRate": "EASY",
        "passRate": "82.69%",
        "problemsUrl": "https://leetcode.cn/problems/delete-greatest-value-in-each-row/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-greatest-value-in-each-row/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 大小的矩阵 <code>grid</code> ，由若干正整数组成。</p>\n\n<p>执行下述操作，直到 <code>grid</code> 变为空矩阵：</p>\n\n<ul>\n\t<li>从每一行删除值最大的元素。如果存在多个这样的值，删除其中任何一个。</li>\n\t<li>将删除元素中的最大值与答案相加。</li>\n</ul>\n\n<p><strong>注意</strong> 每执行一次操作，矩阵中列的数据就会减 1 。</p>\n\n<p>返回执行上述操作后的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/19/q1ex1.jpg\" style=\"width: 600px; height: 135px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,2,4],[3,3,1]]\n<strong>输出：</strong>8\n<strong>解释：</strong>上图展示在每一步中需要移除的值。\n- 在第一步操作中，从第一行删除 4 ，从第二行删除 3（注意，有两个单元格中的值为 3 ，我们可以删除任一）。在答案上加 4 。\n- 在第二步操作中，从第一行删除 2 ，从第二行删除 3 。在答案上加 3 。\n- 在第三步操作中，从第一行删除 1 ，从第二行删除 1 。在答案上加 1 。\n最终，答案 = 4 + 3 + 1 = 8 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/10/19/q1ex2.jpg\" style=\"width: 83px; height: 83px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[10]]\n<strong>输出：</strong>10\n<strong>解释：</strong>上图展示在每一步中需要移除的值。\n- 在第一步操作中，从第一行删除 10 。在答案上加 10 。\n最终，答案 = 10 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    }
]