[
    {
        "problemsName": " 1201.丑数 III",
        "hardRate": "MEDIUM",
        "passRate": "28.47%",
        "problemsUrl": "https://leetcode.cn/problems/ugly-number-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/ugly-number-iii/solution",
        "problemsDesc": "<p>给你四个整数：<code>n</code> 、<code>a</code> 、<code>b</code> 、<code>c</code> ，请你设计一个算法来找出第 <code>n</code> 个丑数。</p>\n\n<p>丑数是可以被 <code>a</code> <strong>或</strong> <code>b</code> <strong>或</strong> <code>c</code> 整除的 <strong>正整数</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, a = 2, b = 3, c = 5\n<strong>输出：</strong>4\n<strong>解释：</strong>丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, a = 2, b = 3, c = 4\n<strong>输出：</strong>6\n<strong>解释：</strong>丑数序列为 2, 3, 4, 6, 8, 9, 10, 12... 其中第 4 个是 6。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, a = 2, b = 11, c = 13\n<strong>输出：</strong>10\n<strong>解释：</strong>丑数序列为 2, 4, 6, 8, 10, 11, 12, 13... 其中第 5 个是 10。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1000000000, a = 2, b = 217983653, c = 336916467\n<strong>输出：</strong>1999999984\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n, a, b, c <= 10^9</code></li>\n\t<li><code>1 <= a * b * c <= 10^18</code></li>\n\t<li>本题结果在 <code>[1, 2 * 10^9]</code> 的范围内</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1202.交换字符串中的元素",
        "hardRate": "MEDIUM",
        "passRate": "51.35%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-string-with-swaps/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-string-with-swaps/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>，以及该字符串中的一些「索引对」数组&nbsp;<code>pairs</code>，其中&nbsp;<code>pairs[i] =&nbsp;[a, b]</code>&nbsp;表示字符串中的两个索引（编号从 0 开始）。</p>\n\n<p>你可以 <strong>任意多次交换</strong> 在&nbsp;<code>pairs</code>&nbsp;中任意一对索引处的字符。</p>\n\n<p>返回在经过若干次交换后，<code>s</code>&nbsp;可以变成的按字典序最小的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;dcab&quot;, pairs = [[0,3],[1,2]]\n<strong>输出：</strong>&quot;bacd&quot;\n<strong>解释：</strong> \n交换 s[0] 和 s[3], s = &quot;bcad&quot;\n交换 s[1] 和 s[2], s = &quot;bacd&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;dcab&quot;, pairs = [[0,3],[1,2],[0,2]]\n<strong>输出：</strong>&quot;abcd&quot;\n<strong>解释：</strong>\n交换 s[0] 和 s[3], s = &quot;bcad&quot;\n交换 s[0] 和 s[2], s = &quot;acbd&quot;\n交换 s[1] 和 s[2], s = &quot;abcd&quot;</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;cba&quot;, pairs = [[0,1],[1,2]]\n<strong>输出：</strong>&quot;abc&quot;\n<strong>解释：</strong>\n交换 s[0] 和 s[1], s = &quot;bca&quot;\n交换 s[1] 和 s[2], s = &quot;bac&quot;\n交换 s[0] 和 s[1], s = &quot;abc&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= pairs.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= pairs[i][0], pairs[i][1] &lt;&nbsp;s.length</code></li>\n\t<li><code>s</code>&nbsp;中只含有小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1203.项目管理",
        "hardRate": "HARD",
        "passRate": "60.83%",
        "problemsUrl": "https://leetcode.cn/problems/sort-items-by-groups-respecting-dependencies/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-items-by-groups-respecting-dependencies/solution",
        "problemsDesc": "<p>有 <code>n</code> 个项目，每个项目或者不属于任何小组，或者属于 <code>m</code> 个小组之一。<code>group[i]</code> 表示第 <code>i</code> 个项目所属的小组，如果第 <code>i</code> 个项目不属于任何小组，则 <code>group[i]</code> 等于 <code>-1</code>。项目和小组都是从零开始编号的。可能存在小组不负责任何项目，即没有任何项目属于这个小组。</p>\n\n<p>请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：</p>\n\n<ul>\n\t<li>同一小组的项目，排序后在列表中彼此相邻。</li>\n\t<li>项目之间存在一定的依赖关系，我们用一个列表 <code>beforeItems</code> 来表示，其中 <code>beforeItems[i]</code> 表示在进行第 <code>i</code> 个项目前（位于第 <code>i</code> 个项目左侧）应该完成的所有项目。</li>\n</ul>\n\n<p>如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个 <strong>空列表 </strong>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/22/1359_ex1.png\" style=\"height: 181px; width: 191px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]\n<strong>输出：</strong>[6,3,4,1,5,2,0,7]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]\n<strong>输出：</strong>[]\n<strong>解释：</strong>与示例 1 大致相同，但是在排序后的列表中，4 必须放在 6 的前面。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= m <= n <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>group.length == beforeItems.length == n</code></li>\n\t<li><code>-1 <= group[i] <= m - 1</code></li>\n\t<li><code>0 <= beforeItems[i].length <= n - 1</code></li>\n\t<li><code>0 <= beforeItems[i][j] <= n - 1</code></li>\n\t<li><code>i != beforeItems[i][j]</code></li>\n\t<li><code>beforeItems[i]</code> 不含重复元素</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1204.最后一个能进入电梯的人",
        "hardRate": "MEDIUM",
        "passRate": "73.97%",
        "problemsUrl": "https://leetcode.cn/problems/last-person-to-fit-in-the-bus/",
        "solutionsUrl": "https://leetcode.cn/problems/last-person-to-fit-in-the-bus/solution",
        "problemsDesc": "<p>表: <code>Queue</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| person_id   | int     |\n| person_name | varchar |\n| weight      | int     |\n| turn        | int     |\n+-------------+---------+\nperson_id 是这个表的主键。\n该表展示了所有等待电梯的人的信息。\n表中 person_id 和 turn 列将包含从 1 到 n 的所有数字，其中 n 是表中的行数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>有一群人在等着上公共汽车。然而，巴士有<code>1000</code>&nbsp;公斤的重量限制，所以可能会有一些人不能上。</p>\n\n<p>写一条 SQL 查询语句查找 <strong>最后一个</strong> 能进入电梯且不超过重量限制的 <code>person_name</code> 。题目确保队列中第一位的人可以进入电梯，不会超重。</p>\n\n<p>查询结果如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nQueue 表\n+-----------+-------------------+--------+------+\n| person_id | person_name       | weight | turn |\n+-----------+-------------------+--------+------+\n| 5         | George Washington | 250    | 1    |\n| 3         | John Adams        | 350    | 2    |\n| 6         | Thomas Jefferson  | 400    | 3    |\n| 2         | Will Johnliams    | 200    | 4    |\n| 4         | Thomas Jefferson  | 175    | 5    |\n| 1         | James Elephant    | 500    | 6    |\n+-----------+-------------------+--------+------+\n<strong>输出：</strong>\n+-------------------+\n| person_name       |\n+-------------------+\n| Thomas Jefferson  |\n+-------------------+\n<strong>解释：</strong>\n为了简化，Queue 表按 turn 列由小到大排序。\n上例中 George Washington(id 5), John Adams(id 3) 和 Thomas Jefferson(id 6) 将可以进入电梯,因为他们的体重和为 250 + 350 + 400 = 1000。\nThomas Jefferson(id 6) 是最后一个体重合适并进入电梯的人。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1205.每月交易II",
        "hardRate": "MEDIUM",
        "passRate": "45.73%",
        "problemsUrl": "https://leetcode.cn/problems/monthly-transactions-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/monthly-transactions-ii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1206.设计跳表",
        "hardRate": "HARD",
        "passRate": "68.25%",
        "problemsUrl": "https://leetcode.cn/problems/design-skiplist/",
        "solutionsUrl": "https://leetcode.cn/problems/design-skiplist/solution",
        "problemsDesc": "<p>不使用任何库函数，设计一个 <strong>跳表</strong> 。</p>\n\n<p><strong>跳表</strong> 是在 <code>O(log(n))</code> 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。</p>\n\n<p>例如，一个跳表包含 <code>[30, 40, 50, 60, 70, 90]</code> ，然后增加 <code>80</code>、<code>45</code> 到跳表中，以下图的方式操作：</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/27/1506_skiplist.gif\" /><br />\n<small>Artyom Kalinin [CC BY-SA 3.0], via <a href=\"https://commons.wikimedia.org/wiki/File:Skip_list_add_element-en.gif\" target=\"_blank\" title=\"Artyom Kalinin [CC BY-SA 3.0 (https://creativecommons.org/licenses/by-sa/3.0)], via Wikimedia Commons\">Wikimedia Commons</a></small></p>\n\n<p>跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 <code>O(n)</code>。跳表的每一个操作的平均时间复杂度是 <code>O(log(n))</code>，空间复杂度是 <code>O(n)</code>。</p>\n\n<p>了解更多 :&nbsp;<a href=\"https://en.wikipedia.org/wiki/Skip_list\" target=\"_blank\">https://en.wikipedia.org/wiki/Skip_list</a></p>\n\n<p>在本题中，你的设计应该要包含这些函数：</p>\n\n<ul>\n\t<li><code>bool search(int target)</code> : 返回target是否存在于跳表中。</li>\n\t<li><code>void add(int num)</code>:&nbsp;插入一个元素到跳表。</li>\n\t<li><code>bool erase(int num)</code>: 在跳表中删除一个值，如果&nbsp;<code>num</code>&nbsp;不存在，直接返回false. 如果存在多个&nbsp;<code>num</code>&nbsp;，删除其中任意一个即可。</li>\n</ul>\n\n<p>注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<b>输入</b>\n[\"Skiplist\", \"add\", \"add\", \"add\", \"search\", \"add\", \"search\", \"erase\", \"erase\", \"search\"]\n[[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]\n<strong>输出</strong>\n[null, null, null, null, false, null, true, false, true, false]\n\n<strong>解释</strong>\nSkiplist skiplist = new Skiplist();\nskiplist.add(1);\nskiplist.add(2);\nskiplist.add(3);\nskiplist.search(0);   // 返回 false\nskiplist.add(4);\nskiplist.search(1);   // 返回 true\nskiplist.erase(0);    // 返回 false，0 不在跳表中\nskiplist.erase(1);    // 返回 true\nskiplist.search(1);   // 返回 false，1 已被擦除\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num, target &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li>调用<code>search</code>, <code>add</code>, &nbsp;<code>erase</code>操作次数不大于&nbsp;<code>5 * 10<sup>4</sup></code>&nbsp;</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1207.独一无二的出现次数",
        "hardRate": "EASY",
        "passRate": "72.79%",
        "problemsUrl": "https://leetcode.cn/problems/unique-number-of-occurrences/",
        "solutionsUrl": "https://leetcode.cn/problems/unique-number-of-occurrences/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code>，请你帮忙统计数组中每个数的出现次数。</p>\n\n<p>如果每个数的出现次数都是独一无二的，就返回&nbsp;<code>true</code>；否则返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,2,1,1,3]\n<strong>输出：</strong>true\n<strong>解释：</strong>在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [-3,0,1,-3,1,1,1,-3,10,0]\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length&nbsp;&lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= arr[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1208.尽可能使字符串相等",
        "hardRate": "MEDIUM",
        "passRate": "50.00%",
        "problemsUrl": "https://leetcode.cn/problems/get-equal-substrings-within-budget/",
        "solutionsUrl": "https://leetcode.cn/problems/get-equal-substrings-within-budget/solution",
        "problemsDesc": "<p>给你两个长度相同的字符串，<code>s</code> 和 <code>t</code>。</p>\n\n<p>将 <code>s</code> 中的第 <code>i</code> 个字符变到 <code>t</code> 中的第 <code>i</code> 个字符需要 <code>|s[i] - t[i]|</code> 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。</p>\n\n<p>用于变更字符串的最大预算是 <code>maxCost</code>。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。</p>\n\n<p>如果你可以将 <code>s</code> 的子字符串转化为它在 <code>t</code> 中对应的子字符串，则返回可以转化的最大长度。</p>\n\n<p>如果 <code>s</code> 中没有子字符串可以转化成 <code>t</code> 中对应的子字符串，则返回 <code>0</code>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\", t = \"bcdf\", maxCost = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>s<strong> </strong>中的<strong> </strong>\"abc\" 可以变为 \"bcd\"。开销为 3，所以最大长度为 3。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\", t = \"cdef\", maxCost = 3\n<strong>输出：</strong>1\n<strong>解释：</strong>s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为<code> 1。</code>\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\", t = \"acde\", maxCost = 0\n<strong>输出：</strong>1\n<strong>解释：</strong>a -> a, cost = 0，字符串未发生变化，所以最大长度为 1。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length, t.length <= 10^5</code></li>\n\t<li><code>0 <= maxCost <= 10^6</code></li>\n\t<li><code>s</code> 和 <code>t</code> 都只含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1209.删除字符串中的所有相邻重复项 II",
        "hardRate": "MEDIUM",
        "passRate": "50.69%",
        "problemsUrl": "https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string-ii/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>，「<code>k</code> 倍重复项删除操作」将会从 <code>s</code>&nbsp;中选择&nbsp;<code>k</code>&nbsp;个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。</p>\n\n<p>你需要对&nbsp;<code>s</code>&nbsp;重复进行无限次这样的删除操作，直到无法继续为止。</p>\n\n<p>在执行完所有删除操作后，返回最终得到的字符串。</p>\n\n<p>本题答案保证唯一。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abcd&quot;, k = 2\n<strong>输出：</strong>&quot;abcd&quot;\n<strong>解释：</strong>没有要删除的内容。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;deeedbbcccbdaa&quot;, k = 3\n<strong>输出：</strong>&quot;aa&quot;\n<strong>解释： \n</strong>先删除 &quot;eee&quot; 和 &quot;ccc&quot;，得到 &quot;ddbbbdaa&quot;\n再删除 &quot;bbb&quot;，得到 &quot;dddaa&quot;\n最后删除 &quot;ddd&quot;，得到 &quot;aa&quot;</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;pbbcggttciiippooaais&quot;, k = 2\n<strong>输出：</strong>&quot;ps&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>2 &lt;= k &lt;= 10^4</code></li>\n\t<li><code>s</code>&nbsp;中只含有小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1210.穿过迷宫的最少移动次数",
        "hardRate": "HARD",
        "passRate": "64.32%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-moves-to-reach-target-with-rotations/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-moves-to-reach-target-with-rotations/solution",
        "problemsDesc": "<p>你还记得那条风靡全球的贪吃蛇吗？</p>\n\n<p>我们在一个&nbsp;<code>n*n</code>&nbsp;的网格上构建了新的迷宫地图，蛇的长度为 2，也就是说它会占去两个单元格。蛇会从左上角（<code>(0, 0)</code>&nbsp;和&nbsp;<code>(0, 1)</code>）开始移动。我们用 <code>0</code> 表示空单元格，用 1 表示障碍物。蛇需要移动到迷宫的右下角（<code>(n-1, n-2)</code>&nbsp;和&nbsp;<code>(n-1, n-1)</code>）。</p>\n\n<p>每次移动，蛇可以这样走：</p>\n\n<ul>\n\t<li>如果没有障碍，则向右移动一个单元格。并仍然保持身体的水平／竖直状态。</li>\n\t<li>如果没有障碍，则向下移动一个单元格。并仍然保持身体的水平／竖直状态。</li>\n\t<li>如果它处于水平状态并且其下面的两个单元都是空的，就顺时针旋转 90 度。蛇从（<code>(r, c)</code>、<code>(r, c+1)</code>）移动到 （<code>(r, c)</code>、<code>(r+1, c)</code>）。<br>\n\t<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/28/image-2.png\" style=\"height: 134px; width: 300px;\"></li>\n\t<li>如果它处于竖直状态并且其右面的两个单元都是空的，就逆时针旋转 90 度。蛇从（<code>(r, c)</code>、<code>(r+1, c)</code>）移动到（<code>(r, c)</code>、<code>(r, c+1)</code>）。<br>\n\t<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/28/image-1.png\" style=\"height: 121px; width: 300px;\"></li>\n</ul>\n\n<p>返回蛇抵达目的地所需的最少移动次数。</p>\n\n<p>如果无法到达目的地，请返回&nbsp;<code>-1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/28/image.png\" style=\"height: 439px; width: 400px;\"></strong></p>\n\n<pre><strong>输入：</strong>grid = [[0,0,0,0,0,1],\n               [1,1,0,0,1,0],\n&nbsp;              [0,0,0,0,1,1],\n&nbsp;              [0,0,1,0,1,0],\n&nbsp;              [0,1,1,0,0,0],\n&nbsp;              [0,1,1,0,0,0]]\n<strong>输出：</strong>11\n<strong>解释：\n</strong>一种可能的解决方案是 [右, 右, 顺时针旋转, 右, 下, 下, 下, 下, 逆时针旋转, 右, 下]。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[0,0,1,1,1,1],\n&nbsp;              [0,0,0,0,1,1],\n&nbsp;              [1,1,0,0,0,1],\n&nbsp;              [1,1,1,0,0,1],\n&nbsp;              [1,1,1,0,0,1],\n&nbsp;              [1,1,1,0,0,0]]\n<strong>输出：</strong>9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 1</code></li>\n\t<li>蛇保证从空单元格开始出发。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1211.查询结果的质量和占比",
        "hardRate": "EASY",
        "passRate": "67.44%",
        "problemsUrl": "https://leetcode.cn/problems/queries-quality-and-percentage/",
        "solutionsUrl": "https://leetcode.cn/problems/queries-quality-and-percentage/solution",
        "problemsDesc": "<p>查询表 <code>Queries</code>：&nbsp;</p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| query_name  | varchar |\n| result      | varchar |\n| position    | int     |\n| rating      | int     |\n+-------------+---------+\n此表没有主键，并可能有重复的行。\n此表包含了一些从数据库中收集的查询信息。\n&ldquo;位置&rdquo;（<code>position</code>）列的值为 1 到 500 。\n&ldquo;评分&rdquo;（<code>rating</code>）列的值为 1 到 5 。评分小于 3 的查询被定义为质量很差的查询。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>将查询结果的质量 <code>quality</code> 定义为：</p>\n\n<blockquote>\n<p>各查询结果的评分与其位置之间比率的平均值。</p>\n</blockquote>\n\n<p>将劣质查询百分比&nbsp;<code>poor_query_percentage</code> 为：</p>\n\n<blockquote>\n<p>评分小于 3 的查询结果占全部查询结果的百分比。</p>\n</blockquote>\n\n<p>编写一组 SQL 来查找每次查询的<code>名称</code>(<code>query_name</code>)、<code>质量</code>(<code>quality</code>) 和&nbsp;<code>劣质查询百分比</code>(<code>poor_query_percentage</code>)。</p>\n\n<p><code>质量</code>(<code>quality</code>) 和<code>劣质查询百分比</code>(<code>poor_query_percentage</code>) 都应四舍五入到小数点后两位。</p>\n\n<p>查询结果格式如下所示：</p>\n\n<pre>\nQueries table:\n+------------+-------------------+----------+--------+\n| query_name | result            | position | rating |\n+------------+-------------------+----------+--------+\n| Dog        | Golden Retriever  | 1        | 5      |\n| Dog        | German Shepherd   | 2        | 5      |\n| Dog        | Mule              | 200      | 1      |\n| Cat        | Shirazi           | 5        | 2      |\n| Cat        | Siamese           | 3        | 3      |\n| Cat        | Sphynx            | 7        | 4      |\n+------------+-------------------+----------+--------+\n\nResult table:\n+------------+---------+-----------------------+\n| query_name | quality | poor_query_percentage |\n+------------+---------+-----------------------+\n| Dog        | 2.50    | 33.33                 |\n| Cat        | 0.66    | 33.33                 |\n+------------+---------+-----------------------+\n\nDog 查询结果的质量为 ((5 / 1) + (5 / 2) + (1 / 200)) / 3 = 2.50\nDog 查询结果的劣质查询百分比为 (1 / 3) * 100 = 33.33\n\nCat 查询结果的质量为 ((2 / 5) + (3 / 3) + (4 / 7)) / 3 = 0.66\nCat 查询结果的劣质查询百分比为 (1 / 3) * 100 = 33.33\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1212.查询球队积分",
        "hardRate": "MEDIUM",
        "passRate": "51.44%",
        "problemsUrl": "https://leetcode.cn/problems/team-scores-in-football-tournament/",
        "solutionsUrl": "https://leetcode.cn/problems/team-scores-in-football-tournament/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1213.三个有序数组的交集",
        "hardRate": "EASY",
        "passRate": "78.32%",
        "problemsUrl": "https://leetcode.cn/problems/intersection-of-three-sorted-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/intersection-of-three-sorted-arrays/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1214.查找两棵二叉搜索树之和",
        "hardRate": "MEDIUM",
        "passRate": "65.89%",
        "problemsUrl": "https://leetcode.cn/problems/two-sum-bsts/",
        "solutionsUrl": "https://leetcode.cn/problems/two-sum-bsts/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1215.步进数",
        "hardRate": "MEDIUM",
        "passRate": "43.32%",
        "problemsUrl": "https://leetcode.cn/problems/stepping-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/stepping-numbers/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1216.验证回文字符串 III",
        "hardRate": "HARD",
        "passRate": "57.77%",
        "problemsUrl": "https://leetcode.cn/problems/valid-palindrome-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/valid-palindrome-iii/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1217.玩筹码",
        "hardRate": "EASY",
        "passRate": "74.64%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-move-chips-to-the-same-position/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-move-chips-to-the-same-position/solution",
        "problemsDesc": "<p>有&nbsp;<code>n</code>&nbsp;个筹码。第 <code>i</code> 个筹码的位置是<meta charset=\"UTF-8\" />&nbsp;<code>position[i]</code>&nbsp;。</p>\n\n<p>我们需要把所有筹码移到同一个位置。在一步中，我们可以将第 <code>i</code> 个筹码的位置从&nbsp;<code>position[i]</code>&nbsp;改变为:</p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>position[i] + 2</code>&nbsp;或&nbsp;<code>position[i] - 2</code>&nbsp;，此时&nbsp;<code>cost = 0</code></li>\n\t<li><code>position[i] + 1</code>&nbsp;或&nbsp;<code>position[i] - 1</code>&nbsp;，此时&nbsp;<code>cost = 1</code></li>\n</ul>\n\n<p>返回将所有筹码移动到同一位置上所需要的 <em>最小代价</em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/15/chips_e1.jpg\" style=\"height: 217px; width: 750px;\" /></p>\n\n<pre>\n<strong>输入：</strong>position = [1,2,3]\n<strong>输出：</strong>1\n<strong>解释：</strong>第一步:将位置3的筹码移动到位置1，成本为0。\n第二步:将位置2的筹码移动到位置1，成本= 1。\n总成本是1。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/15/chip_e2.jpg\" style=\"height: 306px; width: 750px;\" /></p>\n\n<pre>\n<strong>输入：</strong>position = [2,2,2,3,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>我们可以把位置3的两个筹码移到位置2。每一步的成本为1。总成本= 2。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入：</strong>position = [1,1000000000]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= position.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= position[i] &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1218.最长定差子序列",
        "hardRate": "MEDIUM",
        "passRate": "51.60%",
        "problemsUrl": "https://leetcode.cn/problems/longest-arithmetic-subsequence-of-given-difference/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-arithmetic-subsequence-of-given-difference/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> 和一个整数 <code>difference</code>，请你找出并返回 <code>arr</code> 中最长等差子序列的长度，该子序列中相邻元素之间的差等于 <code>difference</code> 。</p>\n\n<p><strong>子序列</strong> 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 <code>arr</code> 派生出来的序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,4], difference = 1\n<strong>输出：</strong>4\n<strong>解释：</strong>最长的等差子序列是 [1,2,3,4]。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,3,5,7], difference = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>最长的等差子序列是任意单个元素。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,5,7,8,5,3,4,2,1], difference = -2\n<strong>输出：</strong>4\n<strong>解释：</strong>最长的等差子序列是 [7,5,3,1]。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= arr.length <= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= arr[i], difference <= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1219.黄金矿工",
        "hardRate": "MEDIUM",
        "passRate": "69.11%",
        "problemsUrl": "https://leetcode.cn/problems/path-with-maximum-gold/",
        "solutionsUrl": "https://leetcode.cn/problems/path-with-maximum-gold/solution",
        "problemsDesc": "<p>你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为&nbsp;<code>m * n</code> 的网格 <code>grid</code> 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 <code>0</code>。</p>\n\n<p>为了使收益最大化，矿工需要按以下规则来开采黄金：</p>\n\n<ul>\n\t<li>每当矿工进入一个单元，就会收集该单元格中的所有黄金。</li>\n\t<li>矿工每次可以从当前位置向上下左右四个方向走。</li>\n\t<li>每个单元格只能被开采（进入）一次。</li>\n\t<li><strong>不得开采</strong>（进入）黄金数目为 <code>0</code> 的单元格。</li>\n\t<li>矿工可以从网格中 <strong>任意一个</strong> 有黄金的单元格出发或者是停止。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[0,6,0],[5,8,7],[0,9,0]]\n<strong>输出：</strong>24\n<strong>解释：</strong>\n[[0,6,0],\n [5,8,7],\n [0,9,0]]\n一种收集最多黄金的路线是：9 -&gt; 8 -&gt; 7。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]\n<strong>输出：</strong>28\n<strong>解释：</strong>\n[[1,0,7],\n [2,0,6],\n [3,4,5],\n [0,3,0],\n [9,0,20]]\n一种收集最多黄金的路线是：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= grid.length,&nbsp;grid[i].length &lt;= 15</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 100</code></li>\n\t<li>最多 <strong>25 </strong>个单元格中有黄金。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1220.统计元音字母序列的数目",
        "hardRate": "HARD",
        "passRate": "60.73%",
        "problemsUrl": "https://leetcode.cn/problems/count-vowels-permutation/",
        "solutionsUrl": "https://leetcode.cn/problems/count-vowels-permutation/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>，请你帮忙统计一下我们可以按下述规则形成多少个长度为&nbsp;<code>n</code>&nbsp;的字符串：</p>\n\n<ul>\n\t<li>字符串中的每个字符都应当是小写元音字母（<code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;u&#39;</code>）</li>\n\t<li>每个元音&nbsp;<code>&#39;a&#39;</code>&nbsp;后面都只能跟着&nbsp;<code>&#39;e&#39;</code></li>\n\t<li>每个元音&nbsp;<code>&#39;e&#39;</code>&nbsp;后面只能跟着&nbsp;<code>&#39;a&#39;</code>&nbsp;或者是&nbsp;<code>&#39;i&#39;</code></li>\n\t<li>每个元音&nbsp;<code>&#39;i&#39;</code>&nbsp;后面&nbsp;<strong>不能</strong> 再跟着另一个&nbsp;<code>&#39;i&#39;</code></li>\n\t<li>每个元音&nbsp;<code>&#39;o&#39;</code>&nbsp;后面只能跟着&nbsp;<code>&#39;i&#39;</code>&nbsp;或者是&nbsp;<code>&#39;u&#39;</code></li>\n\t<li>每个元音&nbsp;<code>&#39;u&#39;</code>&nbsp;后面只能跟着&nbsp;<code>&#39;a&#39;</code></li>\n</ul>\n\n<p>由于答案可能会很大，所以请你返回 模&nbsp;<code>10^9 + 7</code>&nbsp;之后的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>5\n<strong>解释：</strong>所有可能的字符串分别是：&quot;a&quot;, &quot;e&quot;, &quot;i&quot; , &quot;o&quot; 和 &quot;u&quot;。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>10\n<strong>解释：</strong>所有可能的字符串分别是：&quot;ae&quot;, &quot;ea&quot;, &quot;ei&quot;, &quot;ia&quot;, &quot;ie&quot;, &quot;io&quot;, &quot;iu&quot;, &quot;oi&quot;, &quot;ou&quot; 和 &quot;ua&quot;。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 5\n<strong>输出：</strong>68</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1221.分割平衡字符串",
        "hardRate": "EASY",
        "passRate": "85.00%",
        "problemsUrl": "https://leetcode.cn/problems/split-a-string-in-balanced-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/split-a-string-in-balanced-strings/solution",
        "problemsDesc": "<p><strong>平衡字符串</strong> 中，<code>'L'</code> 和 <code>'R'</code> 字符的数量是相同的。</p>\n\n<p>给你一个平衡字符串&nbsp;<code>s</code>，请你将它分割成尽可能多的子字符串，并满足：</p>\n\n<ul>\n\t<li>每个子字符串都是平衡字符串。</li>\n</ul>\n\n<p>返回可以通过分割得到的平衡字符串的 <strong>最大数量</strong> <strong>。</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"RLRRLLRLRL\"\n<strong>输出：</strong>4\n<strong>解释：</strong>s 可以分割为 \"RL\"、\"RRLL\"、\"RL\"、\"RL\" ，每个子字符串中都包含相同数量的 'L' 和 'R' 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"RLRRRLLRLL\"\n<strong>输出：</strong>2\n<strong>解释：</strong>s 可以分割为 \"RL\"、\"RRRLLRLL\"，每个子字符串中都包含相同数量的 'L' 和 'R' 。\n注意，s 无法分割为 \"RL\"、\"RR\"、\"RL\"、\"LR\"、\"LL\" 因为第 2 个和第 5 个子字符串不是平衡字符串。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"LLLLRRRR\"\n<strong>输出：</strong>1\n<strong>解释：</strong>s 只能保持原样 \"LLLLRRRR\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i] = 'L' 或 'R'</code></li>\n\t<li><code>s</code> 是一个 <strong>平衡</strong> 字符串</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1222.可以攻击国王的皇后",
        "hardRate": "MEDIUM",
        "passRate": "69.47%",
        "problemsUrl": "https://leetcode.cn/problems/queens-that-can-attack-the-king/",
        "solutionsUrl": "https://leetcode.cn/problems/queens-that-can-attack-the-king/solution",
        "problemsDesc": "<p>在一个&nbsp;<strong>8x8</strong>&nbsp;的棋盘上，放置着若干「黑皇后」和一个「白国王」。</p>\n\n<p>给定一个由整数坐标组成的数组&nbsp;<code>queens</code>&nbsp;，表示黑皇后的位置；以及一对坐标&nbsp;<code>king</code> ，表示白国王的位置，返回所有可以攻击国王的皇后的坐标(任意顺序)。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/13/untitled-diagram.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]], king = [0,0]\n<strong>输出：</strong>[[0,1],[1,0],[3,3]]\n<strong>解释：</strong> \n[0,1] 的皇后可以攻击到国王，因为他们在同一行上。 \n[1,0] 的皇后可以攻击到国王，因为他们在同一列上。 \n[3,3] 的皇后可以攻击到国王，因为他们在同一条对角线上。 \n[0,4] 的皇后无法攻击到国王，因为她被位于 [0,1] 的皇后挡住了。 \n[4,0] 的皇后无法攻击到国王，因为她被位于 [1,0] 的皇后挡住了。 \n[2,4] 的皇后无法攻击到国王，因为她和国王不在同一行/列/对角线上。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/13/untitled-diagram-1.jpg\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>queens = [[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]], king = [3,3]\n<strong>输出：</strong>[[2,2],[3,4],[4,4]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/13/untitled-diagram-2.jpg\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>queens = [[5,6],[7,7],[2,1],[0,7],[1,6],[5,1],[3,7],[0,3],[4,0],[1,2],[6,3],[5,0],[0,4],[2,2],[1,1],[6,4],[5,4],[0,0],[2,6],[4,5],[5,2],[1,4],[7,5],[2,3],[0,5],[4,2],[1,0],[2,7],[0,1],[4,6],[6,1],[0,6],[4,3],[1,7]], king = [3,4]\n<strong>输出：</strong>[[2,3],[1,4],[1,6],[3,7],[4,3],[5,4],[4,5]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= queens.length&nbsp;&lt;= 63</code></li>\n\t<li><code>queens[i].length == 2</code></li>\n\t<li><code>0 &lt;= queens[i][j] &lt;&nbsp;8</code></li>\n\t<li><code>king.length == 2</code></li>\n\t<li><code>0 &lt;= king[0], king[1] &lt; 8</code></li>\n\t<li>一个棋盘格上最多只能放置一枚棋子。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1223.掷骰子模拟",
        "hardRate": "HARD",
        "passRate": "61.89%",
        "problemsUrl": "https://leetcode.cn/problems/dice-roll-simulation/",
        "solutionsUrl": "https://leetcode.cn/problems/dice-roll-simulation/solution",
        "problemsDesc": "<p>有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。</p>\n\n<p>不过我们在使用它时有个约束，就是使得投掷骰子时，<strong>连续</strong> 掷出数字&nbsp;<code>i</code>&nbsp;的次数不能超过&nbsp;<code>rollMax[i]</code>（<code>i</code>&nbsp;从 1 开始编号）。</p>\n\n<p>现在，给你一个整数数组&nbsp;<code>rollMax</code>&nbsp;和一个整数&nbsp;<code>n</code>，请你来计算掷&nbsp;<code>n</code>&nbsp;次骰子可得到的不同点数序列的数量。</p>\n\n<p>假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 <strong>模&nbsp;<code>10^9 + 7</code></strong>&nbsp;之后的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, rollMax = [1,1,2,2,2,3]\n<strong>输出：</strong>34\n<strong>解释：</strong>我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 = 36 种可能的组合。但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, rollMax = [1,1,1,1,1,1]\n<strong>输出：</strong>30\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 3, rollMax = [1,1,1,2,2,3]\n<strong>输出：</strong>181\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>rollMax.length == 6</code></li>\n\t<li><code>1 &lt;= rollMax[i] &lt;= 15</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1224.最大相等频率",
        "hardRate": "HARD",
        "passRate": "43.63%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-equal-frequency/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-equal-frequency/solution",
        "problemsDesc": "<p>给你一个正整数数组&nbsp;<code>nums</code>，请你帮忙从该数组中找出能满足下面要求的 <strong>最长</strong> 前缀，并返回该前缀的长度：</p>\n\n<ul>\n\t<li>从前缀中 <strong>恰好删除一个</strong> 元素后，剩下每个数字的出现次数都相同。</li>\n</ul>\n\n<p>如果删除这个元素后没有剩余元素存在，仍可认为每个数字都具有相同的出现次数（也就是 0 次）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,1,1,5,3,3,5]\n<strong>输出：</strong>7\n<strong>解释：</strong>对于长度为 7 的子数组 [2,2,1,1,5,3,3]，如果我们从中删去 nums[4] = 5，就可以得到 [2,2,1,1,3,3]，里面每个数字都出现了两次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,2,2,2,3,3,3,4,4,4,5]\n<strong>输出：</strong>13\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1225.报告系统状态的连续日期",
        "hardRate": "HARD",
        "passRate": "53.60%",
        "problemsUrl": "https://leetcode.cn/problems/report-contiguous-dates/",
        "solutionsUrl": "https://leetcode.cn/problems/report-contiguous-dates/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1226.哲学家进餐",
        "hardRate": "MEDIUM",
        "passRate": "59.39%",
        "problemsUrl": "https://leetcode.cn/problems/the-dining-philosophers/",
        "solutionsUrl": "https://leetcode.cn/problems/the-dining-philosophers/solution",
        "problemsDesc": "<p>5 个沉默寡言的哲学家围坐在圆桌前，每人面前一盘意面。叉子放在哲学家之间的桌面上。（5 个哲学家，5 根叉子）</p>\n\n<p>所有的哲学家都只会在思考和进餐两种行为间交替。哲学家只有同时拿到左边和右边的叉子才能吃到面，而同一根叉子在同一时间只能被一个哲学家使用。每个哲学家吃完面后都需要把叉子放回桌面以供其他哲学家吃面。只要条件允许，哲学家可以拿起左边或者右边的叉子，但在没有同时拿到左右叉子时不能进食。</p>\n\n<p>假设面的数量没有限制，哲学家也能随便吃，不需要考虑吃不吃得下。</p>\n\n<p>设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/23/an_illustration_of_the_dining_philosophers_problem.png\" style=\"height: 415px; width: 400px;\"></p>\n\n<p><em>问题描述和图片来自维基百科&nbsp;<a href=\"https://en.wikipedia.org/wiki/Dining_philosophers_problem\" target=\"_blank\">wikipedia.org</a></em></p>\n\n<p>&nbsp;</p>\n\n<p>哲学家从&nbsp;<strong>0</strong> 到 <strong>4</strong> 按 <strong>顺时针</strong> 编号。请实现函数&nbsp;<code>void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork)</code>：</p>\n\n<ul>\n\t<li><code>philosopher</code>&nbsp;哲学家的编号。</li>\n\t<li><code>pickLeftFork</code>&nbsp;和&nbsp;<code>pickRightFork</code>&nbsp;表示拿起左边或右边的叉子。</li>\n\t<li><code>eat</code>&nbsp;表示吃面。</li>\n\t<li><code>putLeftFork</code>&nbsp;和&nbsp;<code>putRightFork</code>&nbsp;表示放下左边或右边的叉子。</li>\n\t<li>由于哲学家不是在吃面就是在想着啥时候吃面，所以思考这个方法没有对应的回调。</li>\n</ul>\n\n<p>给你 5 个线程，每个都代表一个哲学家，请你使用类的同一个对象来模拟这个过程。在最后一次调用结束之前，可能会为同一个哲学家多次调用该函数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>[[4,2,1],[4,1,1],[0,1,1],[2,2,1],[2,1,1],[2,0,3],[2,1,2],[2,2,2],[4,0,3],[4,1,2],[0,2,1],[4,2,2],[3,2,1],[3,1,1],[0,0,3],[0,1,2],[0,2,2],[1,2,1],[1,1,1],[3,0,3],[3,1,2],[3,2,2],[1,0,3],[1,1,2],[1,2,2]]\n<strong>解释:</strong>\nn 表示每个哲学家需要进餐的次数。\n输出数组描述了叉子的控制和进餐的调用，它的格式如下：\noutput[i] = [a, b, c] (3个整数)\n- a 哲学家编号。\n- b 指定叉子：{1 : 左边, 2 : 右边}.\n- c 指定行为：{1 : 拿起, 2 : 放下, 3 : 吃面}。\n如 [4,2,1] 表示 4 号哲学家拿起了右边的叉子。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 60</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1227.飞机座位分配概率",
        "hardRate": "MEDIUM",
        "passRate": "66.97%",
        "problemsUrl": "https://leetcode.cn/problems/airplane-seat-assignment-probability/",
        "solutionsUrl": "https://leetcode.cn/problems/airplane-seat-assignment-probability/solution",
        "problemsDesc": "<p>有 <code>n</code> 位乘客即将登机，飞机正好有 <code>n</code> 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。</p>\n\n<p>剩下的乘客将会：</p>\n\n<ul>\n\t<li>\n\t<p>如果他们自己的座位还空着，就坐到自己的座位上，</p>\n\t</li>\n\t<li>当他们自己的座位被占用时，随机选择其他座位</li>\n</ul>\n\n<p>第 <code>n</code>&nbsp;位乘客坐在自己的座位上的概率是多少？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>1.00000\n<strong>解释：</strong>第一个人只会坐在自己的位置上。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 2\n<strong>输出:</strong> 0.50000\n<strong>解释：</strong>在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1228.等差数列中缺失的数字",
        "hardRate": "EASY",
        "passRate": "53.93%",
        "problemsUrl": "https://leetcode.cn/problems/missing-number-in-arithmetic-progression/",
        "solutionsUrl": "https://leetcode.cn/problems/missing-number-in-arithmetic-progression/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1229.安排会议日程",
        "hardRate": "MEDIUM",
        "passRate": "46.54%",
        "problemsUrl": "https://leetcode.cn/problems/meeting-scheduler/",
        "solutionsUrl": "https://leetcode.cn/problems/meeting-scheduler/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1230.抛掷硬币",
        "hardRate": "MEDIUM",
        "passRate": "54.31%",
        "problemsUrl": "https://leetcode.cn/problems/toss-strange-coins/",
        "solutionsUrl": "https://leetcode.cn/problems/toss-strange-coins/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1231.分享巧克力",
        "hardRate": "HARD",
        "passRate": "58.93%",
        "problemsUrl": "https://leetcode.cn/problems/divide-chocolate/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-chocolate/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1232.缀点成线",
        "hardRate": "EASY",
        "passRate": "45.47%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-it-is-a-straight-line/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-it-is-a-straight-line/solution",
        "problemsDesc": "<p>给定一个数组&nbsp;<code>coordinates</code>&nbsp;，其中&nbsp;<code>coordinates[i] = [x, y]</code>&nbsp;，<meta charset=\"UTF-8\" />&nbsp;<code>[x, y]</code>&nbsp;表示横坐标为 <code>x</code>、纵坐标为 <code>y</code>&nbsp;的点。请你来判断，这些点是否在该坐标系中属于同一条直线上。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/untitled-diagram-2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/untitled-diagram-1.jpg\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;=&nbsp;coordinates.length &lt;= 1000</code></li>\n\t<li><code>coordinates[i].length == 2</code></li>\n\t<li><code>-10^4 &lt;=&nbsp;coordinates[i][0],&nbsp;coordinates[i][1] &lt;= 10^4</code></li>\n\t<li><code>coordinates</code>&nbsp;中不含重复的点</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1233.删除子文件夹",
        "hardRate": "MEDIUM",
        "passRate": "61.53%",
        "problemsUrl": "https://leetcode.cn/problems/remove-sub-folders-from-the-filesystem/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-sub-folders-from-the-filesystem/solution",
        "problemsDesc": "<p>你是一位系统管理员，手里有一份文件夹列表 <code>folder</code>，你的任务是要删除该列表中的所有 <strong>子文件夹</strong>，并以 <strong>任意顺序</strong> 返回剩下的文件夹。</p>\n\n<p>如果文件夹&nbsp;<code>folder[i]</code>&nbsp;位于另一个文件夹&nbsp;<code>folder[j]</code>&nbsp;下，那么&nbsp;<code>folder[i]</code>&nbsp;就是&nbsp;<code>folder[j]</code>&nbsp;的 <strong>子文件夹</strong> 。</p>\n\n<p>文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：<font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">'/'</span></span></font></font>&nbsp;后跟一个或者多个小写英文字母。</p>\n\n<ul>\n\t<li>例如，<code>\"/leetcode\"</code>&nbsp;和&nbsp;<code>\"/leetcode/problems\"</code>&nbsp;都是有效的路径，而空字符串和&nbsp;<code>\"/\"</code>&nbsp;不是。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>folder = [\"/a\",\"/a/b\",\"/c/d\",\"/c/d/e\",\"/c/f\"]\n<strong>输出：</strong>[\"/a\",\"/c/d\",\"/c/f\"]\n<strong>解释：</strong>\"/a/b\" 是 \"/a\" 的子文件夹，而 \"/c/d/e\" 是 \"/c/d\" 的子文件夹。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>folder = [\"/a\",\"/a/b/c\",\"/a/b/d\"]\n<strong>输出：</strong>[\"/a\"]\n<strong>解释：</strong>文件夹 \"/a/b/c\" 和 \"/a/b/d\" 都会被删除，因为它们都是 \"/a\" 的子文件夹。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入:</strong> folder = [\"/a/b/c\",\"/a/b/ca\",\"/a/b/d\"]\n<strong>输出:</strong> [\"/a/b/c\",\"/a/b/ca\",\"/a/b/d\"]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= folder.length &lt;= 4 * 10<sup>4</sup></code></li>\n\t<li><code>2 &lt;= folder[i].length &lt;= 100</code></li>\n\t<li><code>folder[i]</code>&nbsp;只包含小写字母和 <code>'/'</code></li>\n\t<li><code>folder[i]</code>&nbsp;总是以字符 <code>'/'</code>&nbsp;起始</li>\n\t<li><code>folder</code>&nbsp;每个元素都是 <strong>唯一</strong> 的</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1234.替换子串得到平衡字符串",
        "hardRate": "MEDIUM",
        "passRate": "44.90%",
        "problemsUrl": "https://leetcode.cn/problems/replace-the-substring-for-balanced-string/",
        "solutionsUrl": "https://leetcode.cn/problems/replace-the-substring-for-balanced-string/solution",
        "problemsDesc": "<p>有一个只含有&nbsp;<code>'Q', 'W', 'E',&nbsp;'R'</code>&nbsp;四种字符，且长度为 <code>n</code>&nbsp;的字符串。</p>\n\n<p>假如在该字符串中，这四个字符都恰好出现&nbsp;<code>n/4</code>&nbsp;次，那么它就是一个「平衡字符串」。</p>\n\n<p>&nbsp;</p>\n\n<p>给你一个这样的字符串 <code>s</code>，请通过「替换一个子串」的方式，使原字符串 <code>s</code> 变成一个「平衡字符串」。</p>\n\n<p>你可以用和「待替换子串」长度相同的&nbsp;<strong>任何</strong> 其他字符串来完成替换。</p>\n\n<p>请返回待替换子串的最小可能长度。</p>\n\n<p>如果原字符串自身就是一个平衡字符串，则返回 <code>0</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"QWER\"\n<strong>输出：</strong>0\n<strong>解释：</strong>s 已经是平衡的了。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"QQWE\"\n<strong>输出：</strong>1\n<strong>解释：</strong>我们需要把一个 'Q' 替换成 'R'，这样得到的 \"RQWE\" (或 \"QRWE\") 是平衡的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"QQQW\"\n<strong>输出：</strong>2\n<strong>解释：</strong>我们可以把前面的 \"QQ\" 替换成 \"ER\"。 \n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"QQQQ\"\n<strong>输出：</strong>3\n<strong>解释：</strong>我们可以替换后 3 个 'Q'，使 s = \"QWER\"。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>s.length</code>&nbsp;是&nbsp;<code>4</code>&nbsp;的倍数</li>\n\t<li><code>s</code>&nbsp;中只含有&nbsp;<code>'Q'</code>, <code>'W'</code>, <code>'E'</code>,&nbsp;<code>'R'</code>&nbsp;四种字符</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1235.规划兼职工作",
        "hardRate": "HARD",
        "passRate": "57.76%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-profit-in-job-scheduling/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-profit-in-job-scheduling/solution",
        "problemsDesc": "<p>你打算利用空闲时间来做兼职工作赚些零花钱。</p>\n\n<p>这里有&nbsp;<code>n</code>&nbsp;份兼职工作，每份工作预计从&nbsp;<code>startTime[i]</code>&nbsp;开始到&nbsp;<code>endTime[i]</code>&nbsp;结束，报酬为&nbsp;<code>profit[i]</code>。</p>\n\n<p>给你一份兼职工作表，包含开始时间&nbsp;<code>startTime</code>，结束时间&nbsp;<code>endTime</code>&nbsp;和预计报酬&nbsp;<code>profit</code>&nbsp;三个数组，请你计算并返回可以获得的最大报酬。</p>\n\n<p>注意，时间上出现重叠的 2 份工作不能同时进行。</p>\n\n<p>如果你选择的工作在时间&nbsp;<code>X</code>&nbsp;结束，那么你可以立刻进行在时间&nbsp;<code>X</code>&nbsp;开始的下一份工作。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/sample1_1584.png\" style=\"width: 300px;\"></strong></p>\n\n<pre><strong>输入：</strong>startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]\n<strong>输出：</strong>120\n<strong>解释：\n</strong>我们选出第 1 份和第 4 份工作， \n时间范围是 [1-3]+[3-6]，共获得报酬 120 = 50 + 70。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/sample22_1584.png\" style=\"height: 112px; width: 600px;\"> </strong></p>\n\n<pre><strong>输入：</strong>startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]\n<strong>输出：</strong>150\n<strong>解释：\n</strong>我们选择第 1，4，5 份工作。 \n共获得报酬 150 = 20 + 70 + 60。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/sample3_1584.png\" style=\"height: 112px; width: 400px;\"></strong></p>\n\n<pre><strong>输入：</strong>startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]\n<strong>输出：</strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= startTime.length == endTime.length ==&nbsp;profit.length&nbsp;&lt;= 5 * 10^4</code></li>\n\t<li><code>1 &lt;=&nbsp;startTime[i] &lt;&nbsp;endTime[i] &lt;= 10^9</code></li>\n\t<li><code>1 &lt;=&nbsp;profit[i] &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1236.网络爬虫",
        "hardRate": "MEDIUM",
        "passRate": "57.33%",
        "problemsUrl": "https://leetcode.cn/problems/web-crawler/",
        "solutionsUrl": "https://leetcode.cn/problems/web-crawler/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1237.找出给定方程的正整数解",
        "hardRate": "MEDIUM",
        "passRate": "78.17%",
        "problemsUrl": "https://leetcode.cn/problems/find-positive-integer-solution-for-a-given-equation/",
        "solutionsUrl": "https://leetcode.cn/problems/find-positive-integer-solution-for-a-given-equation/solution",
        "problemsDesc": "<p>给你一个函数  <code>f(x, y)</code> 和一个目标结果 <code>z</code>，函数公式未知，请你计算方程 <code>f(x,y) == z</code> 所有可能的正整数 <strong>数对</strong> <code>x</code> 和 <code>y</code>。满足条件的结果数对可以按任意顺序返回。</p>\n\n<p>尽管函数的具体式子未知，但它是单调递增函数，也就是说：</p>\n\n<ul>\n\t<li><code>f(x, y) < f(x + 1, y)</code></li>\n\t<li><code>f(x, y) < f(x, y + 1)</code></li>\n</ul>\n\n<p>函数接口定义如下：</p>\n\n<pre>\ninterface CustomFunction {\npublic:\n  // Returns some positive integer f(x, y) for two positive integers x and y based on a formula.\n  int f(int x, int y);\n};</pre>\n\n<p>你的解决方案将按如下规则进行评判：</p>\n\n<ul>\n\t<li>判题程序有一个由 <code>CustomFunction</code> 的 <code>9</code> 种实现组成的列表，以及一种为特定的 <code>z</code> 生成所有有效数对的答案的方法。</li>\n\t<li>判题程序接受两个输入：<code>function_id</code>（决定使用哪种实现测试你的代码）以及目标结果 <code>z</code> 。</li>\n\t<li>判题程序将会调用你实现的 <code>findSolution</code> 并将你的结果与答案进行比较。</li>\n\t<li>如果你的结果与答案相符，那么解决方案将被视作正确答案，即 <code>Accepted</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>function_id = 1, z = 5\n<strong>输出：</strong>[[1,4],[2,3],[3,2],[4,1]]\n<strong>解释：</strong>function_id = 1 暗含的函数式子为 f(x, y) = x + y\n以下 x 和 y 满足 f(x, y) 等于 5：\nx=1, y=4 -> f(1, 4) = 1 + 4 = 5\nx=2, y=3 -> f(2, 3) = 2 + 3 = 5\nx=3, y=2 -> f(3, 2) = 3 + 2 = 5\nx=4, y=1 -> f(4, 1) = 4 + 1 = 5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>function_id = 2, z = 5\n<strong>输出：</strong>[[1,5],[5,1]]\n<strong>解释：</strong>function_id = 2 暗含的函数式子为 f(x, y) = x * y\n以下 x 和 y 满足 f(x, y) 等于 5：\nx=1, y=5 -> f(1, 5) = 1 * 5 = 5\nx=5, y=1 -> f(5, 1) = 5 * 1 = 5</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= function_id <= 9</code></li>\n\t<li><code>1 <= z <= 100</code></li>\n\t<li>题目保证 <code>f(x, y) == z</code> 的解处于 <code>1 <= x, y <= 1000</code> 的范围内。</li>\n\t<li>在 <code>1 <= x, y <= 1000</code> 的前提下，题目保证 <code>f(x, y)</code> 是一个 32 位有符号整数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1238.循环码排列",
        "hardRate": "MEDIUM",
        "passRate": "77.54%",
        "problemsUrl": "https://leetcode.cn/problems/circular-permutation-in-binary-representation/",
        "solutionsUrl": "https://leetcode.cn/problems/circular-permutation-in-binary-representation/solution",
        "problemsDesc": "<p>给你两个整数&nbsp;<code>n</code> 和 <code>start</code>。你的任务是返回任意 <code>(0,1,2,,...,2^n-1)</code> 的排列 <code>p</code>，并且满足：</p>\n\n<ul>\n\t<li><code>p[0] = start</code></li>\n\t<li><code>p[i]</code> 和 <code>p[i+1]</code>&nbsp;的二进制表示形式只有一位不同</li>\n\t<li><code>p[0]</code> 和 <code>p[2^n -1]</code>&nbsp;的二进制表示形式也只有一位不同</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, start = 3\n<strong>输出：</strong>[3,2,0,1]\n<strong>解释：</strong>这个排列的二进制表示是 (11,10,00,01)\n     所有的相邻元素都有一位是不同的，另一个有效的排列是 [3,1,0,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, start = 2\n<strong>输出：</strong>[2,6,7,5,4,0,1,3]\n<strong>解释：</strong>这个排列的二进制表示是 (010,110,111,101,100,000,001,011)\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 16</code></li>\n\t<li><code>0 &lt;= start&nbsp;&lt;&nbsp;2^n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1239.串联字符串的最大长度",
        "hardRate": "MEDIUM",
        "passRate": "49.09%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-length-of-a-concatenated-string-with-unique-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-length-of-a-concatenated-string-with-unique-characters/solution",
        "problemsDesc": "<p>给定一个字符串数组 <code>arr</code>，字符串 <code>s</code> 是将 <code>arr</code>&nbsp;的含有 <strong>不同字母</strong> 的&nbsp;<strong>子序列</strong> 字符串 <strong>连接</strong> 所得的字符串。</p>\n\n<p>请返回所有可行解 <code>s</code> 中最长长度。</p>\n\n<p><strong>子序列</strong> 是一种可以从另一个数组派生而来的数组，通过删除某些元素或不删除元素而不改变其余元素的顺序。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [\"un\",\"iq\",\"ue\"]\n<strong>输出：</strong>4\n<strong>解释：</strong>所有可能的串联组合是：\n- \"\"\n- \"un\"\n- \"iq\"\n- \"ue\"\n- \"uniq\" (\"un\" + \"iq\")\n- \"ique\" (\"iq\" + \"ue\")\n最大长度为 4。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [\"cha\",\"r\",\"act\",\"ers\"]\n<strong>输出：</strong>6\n<strong>解释：</strong>可能的解答有 \"chaers\" 和 \"acters\"。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [\"abcdefghijklmnopqrstuvwxyz\"]\n<strong>输出：</strong>26\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 16</code></li>\n\t<li><code>1 &lt;= arr[i].length &lt;= 26</code></li>\n\t<li><code>arr[i]</code>&nbsp;中只含有小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1240.铺瓷砖",
        "hardRate": "HARD",
        "passRate": "65.77%",
        "problemsUrl": "https://leetcode.cn/problems/tiling-a-rectangle-with-the-fewest-squares/",
        "solutionsUrl": "https://leetcode.cn/problems/tiling-a-rectangle-with-the-fewest-squares/solution",
        "problemsDesc": "<p>你是一位施工队的工长，根据设计师的要求准备为一套设计风格独特的房子进行室内装修。</p>\n\n<p>房子的客厅大小为&nbsp;<code>n</code>&nbsp;x <code>m</code>，为保持极简的风格，需要使用尽可能少的 <strong>正方形</strong> 瓷砖来铺盖地面。</p>\n\n<p>假设正方形瓷砖的规格不限，边长都是整数。</p>\n\n<p>请你帮设计师计算一下，最少需要用到多少块方形瓷砖？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/25/sample_11_1592.png\" style=\"height: 106px; width: 154px;\"></p>\n\n<pre><strong>输入：</strong>n = 2, m = 3\n<strong>输出：</strong>3\n<code><strong>解释：</strong>3</code> 块地砖就可以铺满卧室。\n<code>     2</code> 块 <code>1x1 地砖</code>\n<code>     1</code> 块 <code>2x2 地砖</code></pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/25/sample_22_1592.png\" style=\"height: 126px; width: 224px;\"></p>\n\n<pre><strong>输入：</strong>n = 5, m = 8\n<strong>输出：</strong>5\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/25/sample_33_1592.png\" style=\"height: 189px; width: 224px;\"></p>\n\n<pre><strong>输入：</strong>n = 11, m = 13\n<strong>输出：</strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 13</code></li>\n\t<li><code>1 &lt;= m&nbsp;&lt;=&nbsp;13</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1241.每个帖子的评论数",
        "hardRate": "EASY",
        "passRate": "59.71%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-comments-per-post/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-comments-per-post/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1242.多线程网页爬虫",
        "hardRate": "MEDIUM",
        "passRate": "48.24%",
        "problemsUrl": "https://leetcode.cn/problems/web-crawler-multithreaded/",
        "solutionsUrl": "https://leetcode.cn/problems/web-crawler-multithreaded/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1243.数组变换",
        "hardRate": "EASY",
        "passRate": "53.82%",
        "problemsUrl": "https://leetcode.cn/problems/array-transformation/",
        "solutionsUrl": "https://leetcode.cn/problems/array-transformation/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1244.力扣排行榜",
        "hardRate": "MEDIUM",
        "passRate": "63.40%",
        "problemsUrl": "https://leetcode.cn/problems/design-a-leaderboard/",
        "solutionsUrl": "https://leetcode.cn/problems/design-a-leaderboard/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1245.树的直径",
        "hardRate": "MEDIUM",
        "passRate": "54.44%",
        "problemsUrl": "https://leetcode.cn/problems/tree-diameter/",
        "solutionsUrl": "https://leetcode.cn/problems/tree-diameter/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1246.删除回文子数组",
        "hardRate": "HARD",
        "passRate": "50.28%",
        "problemsUrl": "https://leetcode.cn/problems/palindrome-removal/",
        "solutionsUrl": "https://leetcode.cn/problems/palindrome-removal/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1247.交换字符使得字符串相同",
        "hardRate": "MEDIUM",
        "passRate": "69.11%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-swaps-to-make-strings-equal/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-swaps-to-make-strings-equal/solution",
        "problemsDesc": "<p>有两个长度相同的字符串&nbsp;<code>s1</code> 和&nbsp;<code>s2</code>，且它们其中&nbsp;<strong>只含有</strong>&nbsp;字符&nbsp;<code>\"x\"</code> 和&nbsp;<code>\"y\"</code>，你需要通过「交换字符」的方式使这两个字符串相同。</p>\n\n<p>每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。</p>\n\n<p>交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换&nbsp;<code>s1[i]</code> 和&nbsp;<code>s2[j]</code>，但不能交换&nbsp;<code>s1[i]</code> 和&nbsp;<code>s1[j]</code>。</p>\n\n<p>最后，请你返回使 <code>s1</code> 和 <code>s2</code> 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回&nbsp;<code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"xx\", s2 = \"yy\"\n<strong>输出：</strong>1\n<strong>解释：\n</strong>交换 s1[0] 和 s2[1]，得到 s1 = \"yx\"，s2 = \"yx\"。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"xy\", s2 = \"yx\"\n<strong>输出：</strong>2\n<strong>解释：\n</strong>交换 s1[0] 和 s2[0]，得到 s1 = \"yy\"，s2 = \"xx\" 。\n交换 s1[0] 和 s2[1]，得到 s1 = \"xy\"，s2 = \"xy\" 。\n注意，你不能交换 s1[0] 和 s1[1] 使得 s1 变成 \"yx\"，因为我们只能交换属于两个不同字符串的字符。</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"xx\", s2 = \"xy\"\n<strong>输出：</strong>-1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 1000</code></li>\n\t<li><code>s1.length == s2.length</code></li>\n\t<li><code>s1, s2</code>&nbsp;只包含&nbsp;<code>'x'</code>&nbsp;或&nbsp;<code>'y'</code>。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1248.统计「优美子数组」",
        "hardRate": "MEDIUM",
        "passRate": "57.94%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-nice-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-nice-subarrays/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code> 和一个整数 <code>k</code>。如果某个连续子数组中恰好有 <code>k</code> 个奇数数字，我们就认为这个子数组是「<strong>优美子数组</strong>」。</p>\n\n<p>请返回这个数组中 <strong>「优美子数组」</strong> 的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,2,1,1], k = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,4,6], k = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>数列中不包含任何奇数，所以不存在优美子数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,2,1,2,2,1,2,2,2], k = 2\n<strong>输出：</strong>16\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 50000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1249.移除无效的括号",
        "hardRate": "MEDIUM",
        "passRate": "59.36%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses/solution",
        "problemsDesc": "<p>给你一个由 <code>'('</code>、<code>')'</code> 和小写字母组成的字符串 <code>s</code>。</p>\n\n<p>你需要从字符串中删除最少数目的 <code>'('</code> 或者 <code>')'</code>&nbsp;（可以删除任意位置的括号)，使得剩下的「括号字符串」有效。</p>\n\n<p>请返回任意一个合法字符串。</p>\n\n<p>有效「括号字符串」应当符合以下&nbsp;<strong>任意一条&nbsp;</strong>要求：</p>\n\n<ul>\n\t<li>空字符串或只包含小写字母的字符串</li>\n\t<li>可以被写作&nbsp;<code>AB</code>（<code>A</code>&nbsp;连接&nbsp;<code>B</code>）的字符串，其中&nbsp;<code>A</code>&nbsp;和&nbsp;<code>B</code>&nbsp;都是有效「括号字符串」</li>\n\t<li>可以被写作&nbsp;<code>(A)</code>&nbsp;的字符串，其中&nbsp;<code>A</code>&nbsp;是一个有效的「括号字符串」</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"lee(t(c)o)de)\"\n<strong>输出：</strong>\"lee(t(c)o)de\"\n<strong>解释：</strong>\"lee(t(co)de)\" , \"lee(t(c)ode)\" 也是一个可行答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a)b(c)d\"\n<strong>输出：</strong>\"ab(c)d\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"))((\"\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>空字符串也是有效的\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code>&nbsp;可能是&nbsp;<code>'('</code>、<code>')'</code>&nbsp;或英文小写字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1250.检查「好数组」",
        "hardRate": "HARD",
        "passRate": "70.99%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-it-is-a-good-array/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-it-is-a-good-array/solution",
        "problemsDesc": "<p>给你一个正整数数组 <code>nums</code>，你需要从中任选一些子集，然后将子集中每一个数乘以一个 <strong>任意整数</strong>，并求出他们的和。</p>\n\n<p>假如该和结果为&nbsp;<code>1</code>，那么原数组就是一个「<strong>好数组</strong>」，则返回 <code>True</code>；否则请返回 <code>False</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [12,5,7,23]\n<strong>输出：</strong>true\n<strong>解释：</strong>挑选数字 5 和 7。\n5*3 + 7*(-2) = 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [29,6,10]\n<strong>输出：</strong>true\n<strong>解释：</strong>挑选数字 29, 6 和 10。\n29*1 + 6*(-3) + 10*(-1) = 1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,6]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1251.平均售价",
        "hardRate": "EASY",
        "passRate": "75.30%",
        "problemsUrl": "https://leetcode.cn/problems/average-selling-price/",
        "solutionsUrl": "https://leetcode.cn/problems/average-selling-price/solution",
        "problemsDesc": "<p>Table: <code>Prices</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| product_id    | int     |\n| start_date    | date    |\n| end_date      | date    |\n| price         | int     |\n+---------------+---------+\n(product_id，start_date，end_date) 是 <code>Prices </code>表的主键。\n<code>Prices </code>表的每一行表示的是某个产品在一段时期内的价格。\n每个产品的对应时间段是不会重叠的，这也意味着同一个产品的价格时段不会出现交叉。</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>UnitsSold</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| product_id    | int     |\n| purchase_date | date    |\n| units         | int     |\n+---------------+---------+\n<code>UnitsSold </code>表没有主键，它可能包含重复项。\n<code>UnitsSold </code>表的每一行表示的是每种产品的出售日期，单位和产品 id。</pre>\n\n<p>&nbsp;</p>\n\n<p>编写SQL查询以查找每种产品的平均售价。<br />\n<code>average_price</code> 应该四舍五入到小数点后两位。<br />\n查询结果格式如下例所示：</p>\n\n<pre>\nPrices table:\n+------------+------------+------------+--------+\n| product_id | start_date | end_date   | price  |\n+------------+------------+------------+--------+\n| 1          | 2019-02-17 | 2019-02-28 | 5      |\n| 1          | 2019-03-01 | 2019-03-22 | 20     |\n| 2          | 2019-02-01 | 2019-02-20 | 15     |\n| 2          | 2019-02-21 | 2019-03-31 | 30     |\n+------------+------------+------------+--------+\n \nUnitsSold table:\n+------------+---------------+-------+\n| product_id | purchase_date | units |\n+------------+---------------+-------+\n| 1          | 2019-02-25    | 100   |\n| 1          | 2019-03-01    | 15    |\n| 2          | 2019-02-10    | 200   |\n| 2          | 2019-03-22    | 30    |\n+------------+---------------+-------+\n\nResult table:\n+------------+---------------+\n| product_id | average_price |\n+------------+---------------+\n| 1          | 6.96          |\n| 2          | 16.96         |\n+------------+---------------+\n平均售价 = 产品总价 / 销售的产品数量。\n产品 1 的平均售价 = ((100 * 5)+(15 * 20) )/ 115 = 6.96\n产品 2 的平均售价 = ((200 * 15)+(30 * 30) )/ 230 = 16.96</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1252.奇数值单元格的数目",
        "hardRate": "EASY",
        "passRate": "79.59%",
        "problemsUrl": "https://leetcode.cn/problems/cells-with-odd-values-in-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/cells-with-odd-values-in-a-matrix/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的矩阵，最开始的时候，每个单元格中的值都是 <code>0</code>。</p>\n\n<p>另有一个二维索引数组 <code>indices</code>，<code>indices[i] = [ri, ci]</code> 指向矩阵中的某个位置，其中 <code>ri</code> 和 <code>ci</code> 分别表示指定的行和列（<strong>从 <code>0</code> 开始编号</strong>）。</p>\n\n<p>对 <code>indices[i]</code> 所指向的每个位置，应同时执行下述增量操作：</p>\n\n<ol>\n\t<li><code>r<sub>i</sub></code> 行上的所有单元格，加 <code>1</code> 。</li>\n\t<li><code>c<sub>i</sub></code> 列上的所有单元格，加 <code>1</code> 。</li>\n</ol>\n\n<p>给你 <code>m</code>、<code>n</code> 和 <code>indices</code> 。请你在执行完所有 <code>indices</code> 指定的增量操作后，返回矩阵中 <strong>奇数值单元格</strong> 的数目。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/06/e1.png\" style=\"height: 118px; width: 600px;\" /></p>\n\n<pre>\n<strong>输入：</strong>m = 2, n = 3, indices = [[0,1],[1,1]]\n<strong>输出：</strong>6\n<strong>解释：</strong>最开始的矩阵是 [[0,0,0],[0,0,0]]。\n第一次增量操作后得到 [[1,2,1],[0,1,0]]。\n最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/06/e2.png\" style=\"height: 150px; width: 600px;\" /></p>\n\n<pre>\n<strong>输入：</strong>m = 2, n = 2, indices = [[1,1],[0,0]]\n<strong>输出：</strong>0\n<strong>解释：</strong>最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= m, n <= 50</code></li>\n\t<li><code>1 <= indices.length <= 100</code></li>\n\t<li><code>0 <= r<sub>i</sub> < m</code></li>\n\t<li><code>0 <= c<sub>i</sub> < n</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(n + m + indices.length)</code> 且仅用 <code>O(n + m)</code> 额外空间的算法来解决此问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1253.重构 2 行二进制矩阵",
        "hardRate": "MEDIUM",
        "passRate": "48.26%",
        "problemsUrl": "https://leetcode.cn/problems/reconstruct-a-2-row-binary-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/reconstruct-a-2-row-binary-matrix/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>2</code>&nbsp;行 <code>n</code> 列的二进制数组：</p>\n\n<ul>\n\t<li>矩阵是一个二进制矩阵，这意味着矩阵中的每个元素不是&nbsp;<code>0</code>&nbsp;就是&nbsp;<code>1</code>。</li>\n\t<li>第 <code>0</code> 行的元素之和为&nbsp;<code>upper</code>。</li>\n\t<li>第 <code>1</code> 行的元素之和为 <code>lower</code>。</li>\n\t<li>第 <code>i</code> 列（从 <code>0</code> 开始编号）的元素之和为&nbsp;<code>colsum[i]</code>，<code>colsum</code>&nbsp;是一个长度为&nbsp;<code>n</code>&nbsp;的整数数组。</li>\n</ul>\n\n<p>你需要利用&nbsp;<code>upper</code>，<code>lower</code>&nbsp;和&nbsp;<code>colsum</code>&nbsp;来重构这个矩阵，并以二维整数数组的形式返回它。</p>\n\n<p>如果有多个不同的答案，那么任意一个都可以通过本题。</p>\n\n<p>如果不存在符合要求的答案，就请返回一个空的二维数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>upper = 2, lower = 1, colsum = [1,1,1]\n<strong>输出：</strong>[[1,1,0],[0,0,1]]\n<strong>解释：</strong>[[1,0,1],[0,1,0]] 和 [[0,1,1],[1,0,0]] 也是正确答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>upper = 2, lower = 3, colsum = [2,2,1,1]\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>upper = 5, lower = 5, colsum = [2,1,2,0,1,0,1,2,0,1]\n<strong>输出：</strong>[[1,1,1,0,1,0,0,1,0,0],[1,0,1,0,0,0,1,1,0,1]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= colsum.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= upper, lower &lt;= colsum.length</code></li>\n\t<li><code>0 &lt;= colsum[i] &lt;= 2</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1254.统计封闭岛屿的数目",
        "hardRate": "MEDIUM",
        "passRate": "64.23%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-closed-islands/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-closed-islands/solution",
        "problemsDesc": "<p>二维矩阵 <code>grid</code>&nbsp;由 <code>0</code>&nbsp;（土地）和 <code>1</code>&nbsp;（水）组成。岛是由最大的4个方向连通的 <code>0</code>&nbsp;组成的群，封闭岛是一个&nbsp;<code>完全</code> 由1包围（左、上、右、下）的岛。</p>\n\n<p>请返回 <em>封闭岛屿</em> 的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/10/31/sample_3_1610.png\" style=\"height: 151px; width: 240px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 1 区域包围）。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/07/sample_4_1610.png\" style=\"height: 98px; width: 160px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,1,1,1,1,1,1],\n&nbsp;            [1,0,0,0,0,0,1],\n&nbsp;            [1,0,1,1,1,0,1],\n&nbsp;            [1,0,1,0,1,0,1],\n&nbsp;            [1,0,1,1,1,0,1],\n&nbsp;            [1,0,0,0,0,0,1],\n             [1,1,1,1,1,1,1]]\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= grid.length, grid[0].length &lt;= 100</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;=1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1255.得分最高的单词集合",
        "hardRate": "HARD",
        "passRate": "79.91%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-words-formed-by-letters/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-words-formed-by-letters/solution",
        "problemsDesc": "<p>你将会得到一份单词表&nbsp;<code>words</code>，一个字母表&nbsp;<code>letters</code>&nbsp;（可能会有重复字母），以及每个字母对应的得分情况表&nbsp;<code>score</code>。</p>\n\n<p>请你帮忙计算玩家在单词拼写游戏中所能获得的「最高得分」：能够由&nbsp;<code>letters</code>&nbsp;里的字母拼写出的&nbsp;<strong>任意</strong>&nbsp;属于 <code>words</code>&nbsp;单词子集中，分数最高的单词集合的得分。</p>\n\n<p>单词拼写游戏的规则概述如下：</p>\n\n<ul>\n\t<li>玩家需要用字母表&nbsp;<code>letters</code> 里的字母来拼写单词表&nbsp;<code>words</code>&nbsp;中的单词。</li>\n\t<li>可以只使用字母表&nbsp;<code>letters</code> 中的部分字母，但是每个字母最多被使用一次。</li>\n\t<li>单词表 <code>words</code>&nbsp;中每个单词只能计分（使用）一次。</li>\n\t<li>根据字母得分情况表<code>score</code>，字母 <code>&#39;a&#39;</code>,&nbsp;<code>&#39;b&#39;</code>,&nbsp;<code>&#39;c&#39;</code>, ... ,&nbsp;<code>&#39;z&#39;</code> 对应的得分分别为 <code>score[0]</code>, <code>score[1]</code>,&nbsp;...,&nbsp;<code>score[25]</code>。</li>\n\t<li>本场游戏的「得分」是指：玩家所拼写出的单词集合里包含的所有字母的得分之和。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;dog&quot;,&quot;cat&quot;,&quot;dad&quot;,&quot;good&quot;], letters = [&quot;a&quot;,&quot;a&quot;,&quot;c&quot;,&quot;d&quot;,&quot;d&quot;,&quot;d&quot;,&quot;g&quot;,&quot;o&quot;,&quot;o&quot;], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]\n<strong>输出：</strong>23\n<strong>解释：</strong>\n字母得分为  a=1, c=9, d=5, g=3, o=2\n使用给定的字母表 letters，我们可以拼写单词 &quot;dad&quot; (5+1+5)和 &quot;good&quot; (3+2+2+5)，得分为 23 。\n而单词 &quot;dad&quot; 和 &quot;dog&quot; 只能得到 21 分。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;xxxz&quot;,&quot;ax&quot;,&quot;bx&quot;,&quot;cx&quot;], letters = [&quot;z&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;x&quot;,&quot;x&quot;,&quot;x&quot;], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]\n<strong>输出：</strong>27\n<strong>解释：</strong>\n字母得分为  a=4, b=4, c=4, x=5, z=10\n使用给定的字母表 letters，我们可以组成单词 &quot;ax&quot; (4+5)， &quot;bx&quot; (4+5) 和 &quot;cx&quot; (4+5) ，总得分为 27 。\n单词 &quot;xxxz&quot; 的得分仅为 25 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;leetcode&quot;], letters = [&quot;l&quot;,&quot;e&quot;,&quot;t&quot;,&quot;c&quot;,&quot;o&quot;,&quot;d&quot;], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]\n<strong>输出：</strong>0\n<strong>解释：</strong>\n字母 &quot;e&quot; 在字母表 letters 中只出现了一次，所以无法组成单词表 words 中的单词。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 14</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 15</code></li>\n\t<li><code>1 &lt;= letters.length &lt;= 100</code></li>\n\t<li><code>letters[i].length == 1</code></li>\n\t<li><code>score.length ==&nbsp;26</code></li>\n\t<li><code>0 &lt;= score[i] &lt;= 10</code></li>\n\t<li><code>words[i]</code>&nbsp;和&nbsp;<code>letters[i]</code>&nbsp;只包含小写的英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1256.加密数字",
        "hardRate": "MEDIUM",
        "passRate": "68.71%",
        "problemsUrl": "https://leetcode.cn/problems/encode-number/",
        "solutionsUrl": "https://leetcode.cn/problems/encode-number/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1257.最小公共区域",
        "hardRate": "MEDIUM",
        "passRate": "59.18%",
        "problemsUrl": "https://leetcode.cn/problems/smallest-common-region/",
        "solutionsUrl": "https://leetcode.cn/problems/smallest-common-region/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1258.近义词句子",
        "hardRate": "MEDIUM",
        "passRate": "59.25%",
        "problemsUrl": "https://leetcode.cn/problems/synonymous-sentences/",
        "solutionsUrl": "https://leetcode.cn/problems/synonymous-sentences/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1259.不相交的握手",
        "hardRate": "HARD",
        "passRate": "53.17%",
        "problemsUrl": "https://leetcode.cn/problems/handshakes-that-dont-cross/",
        "solutionsUrl": "https://leetcode.cn/problems/handshakes-that-dont-cross/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1260.二维网格迁移",
        "hardRate": "EASY",
        "passRate": "65.36%",
        "problemsUrl": "https://leetcode.cn/problems/shift-2d-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/shift-2d-grid/solution",
        "problemsDesc": "<p>给你一个 <code>m</code> 行 <code>n</code> 列的二维网格 <code>grid</code> 和一个整数 <code>k</code>。你需要将 <code>grid</code> 迁移 <code>k</code> 次。</p>\n\n<p>每次「迁移」操作将会引发下述活动：</p>\n\n<ul>\n\t<li>位于 <code>grid[i][j]</code> 的元素将会移动到 <code>grid[i][j + 1]</code>。</li>\n\t<li>位于 <code>grid[i][n - 1]</code> 的元素将会移动到 <code>grid[i + 1][0]</code>。</li>\n\t<li>位于 <code>grid[m - 1][n - 1]</code> 的元素将会移动到 <code>grid[0][0]</code>。</li>\n</ul>\n\n<p>请你返回 <code>k</code> 次迁移操作后最终得到的 <strong>二维网格</strong>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/e1-1.png\" style=\"height: 158px; width: 400px;\" /></p>\n\n<pre>\n<code><strong>输入：</strong>grid</code> = [[1,2,3],[4,5,6],[7,8,9]], k = 1\n<strong>输出：</strong>[[9,1,2],[3,4,5],[6,7,8]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/e2-1.png\" style=\"height: 166px; width: 400px;\" /></p>\n\n<pre>\n<code><strong>输入：</strong>grid</code> = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4\n<strong>输出：</strong>[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<code><strong>输入：</strong>grid</code> = [[1,2,3],[4,5,6],[7,8,9]], k = 9\n<strong>输出：</strong>[[1,2,3],[4,5,6],[7,8,9]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 <= m <= 50</code></li>\n\t<li><code>1 <= n <= 50</code></li>\n\t<li><code>-1000 <= grid[i][j] <= 1000</code></li>\n\t<li><code>0 <= k <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1261.在受污染的二叉树中查找元素",
        "hardRate": "MEDIUM",
        "passRate": "73.55%",
        "problemsUrl": "https://leetcode.cn/problems/find-elements-in-a-contaminated-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/find-elements-in-a-contaminated-binary-tree/solution",
        "problemsDesc": "<p>给出一个满足下述规则的二叉树：</p>\n\n<ol>\n\t<li><code>root.val == 0</code></li>\n\t<li>如果 <code>treeNode.val == x</code> 且&nbsp;<code>treeNode.left != null</code>，那么&nbsp;<code>treeNode.left.val == 2 * x + 1</code></li>\n\t<li>如果 <code>treeNode.val == x</code> 且 <code>treeNode.right != null</code>，那么&nbsp;<code>treeNode.right.val == 2 * x + 2</code></li>\n</ol>\n\n<p>现在这个二叉树受到「污染」，所有的&nbsp;<code>treeNode.val</code>&nbsp;都变成了&nbsp;<code>-1</code>。</p>\n\n<p>请你先还原二叉树，然后实现&nbsp;<code>FindElements</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>FindElements(TreeNode* root)</code>&nbsp;用受污染的二叉树初始化对象，你需要先把它还原。</li>\n\t<li><code>bool find(int target)</code>&nbsp;判断目标值&nbsp;<code>target</code>&nbsp;是否存在于还原后的二叉树中并返回结果。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/untitled-diagram-4-1.jpg\" style=\"height: 119px; width: 320px;\"></strong></p>\n\n<pre><strong>输入：</strong>\n[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;]\n[[[-1,null,-1]],[1],[2]]\n<strong>输出：</strong>\n[null,false,true]\n<strong>解释：</strong>\nFindElements findElements = new FindElements([-1,null,-1]); \nfindElements.find(1); // return False \nfindElements.find(2); // return True </pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/untitled-diagram-4.jpg\" style=\"height: 198px; width: 400px;\"></strong></p>\n\n<pre><strong>输入：</strong>\n[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;]\n[[[-1,-1,-1,-1,-1]],[1],[3],[5]]\n<strong>输出：</strong>\n[null,true,true,false]\n<strong>解释：</strong>\nFindElements findElements = new FindElements([-1,-1,-1,-1,-1]);\nfindElements.find(1); // return True\nfindElements.find(3); // return True\nfindElements.find(5); // return False</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/untitled-diagram-4-1-1.jpg\" style=\"height: 274px; width: 306px;\"></strong></p>\n\n<pre><strong>输入：</strong>\n[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;]\n[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]\n<strong>输出：</strong>\n[null,true,false,false,true]\n<strong>解释：</strong>\nFindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);\nfindElements.find(2); // return True\nfindElements.find(3); // return False\nfindElements.find(4); // return False\nfindElements.find(5); // return True\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>TreeNode.val == -1</code></li>\n\t<li>二叉树的高度不超过&nbsp;<code>20</code></li>\n\t<li>节点的总数在&nbsp;<code>[1,&nbsp;10^4]</code>&nbsp;之间</li>\n\t<li>调用&nbsp;<code>find()</code>&nbsp;的总次数在&nbsp;<code>[1,&nbsp;10^4]</code>&nbsp;之间</li>\n\t<li><code>0 &lt;= target &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1262.可被三整除的最大和",
        "hardRate": "MEDIUM",
        "passRate": "56.29%",
        "problemsUrl": "https://leetcode.cn/problems/greatest-sum-divisible-by-three/",
        "solutionsUrl": "https://leetcode.cn/problems/greatest-sum-divisible-by-three/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>，请你找出并返回能被三整除的元素最大和。</p>\n\n<ol>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,6,5,1,8]\n<strong>输出：</strong>18\n<strong>解释：</strong>选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4]\n<strong>输出：</strong>0\n<strong>解释：</strong>4 不能被 3 整除，所以无法选出数字，返回 0。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,4]\n<strong>输出：</strong>12\n<strong>解释：</strong>选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 4 * 10^4</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1263.推箱子",
        "hardRate": "HARD",
        "passRate": "54.30%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-moves-to-move-a-box-to-their-target-location/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-moves-to-move-a-box-to-their-target-location/solution",
        "problemsDesc": "<p>「推箱子」是一款风靡全球的益智小游戏，玩家需要将箱子推到仓库中的目标位置。</p>\n\n<p>游戏地图用大小为&nbsp;<code>m x n</code>&nbsp;的网格 <code>grid</code> 表示，其中每个元素可以是墙、地板或者是箱子。</p>\n\n<p>现在你将作为玩家参与游戏，按规则将箱子&nbsp;<code>'B'</code>&nbsp;移动到目标位置&nbsp;<code>'T'</code> ：</p>\n\n<ul>\n\t<li>玩家用字符&nbsp;<code>'S'</code>&nbsp;表示，只要他在地板上，就可以在网格中向上、下、左、右四个方向移动。</li>\n\t<li>地板用字符&nbsp;<code>'.'</code>&nbsp;表示，意味着可以自由行走。</li>\n\t<li>墙用字符&nbsp;<code>'#'</code>&nbsp;表示，意味着障碍物，不能通行。&nbsp;</li>\n\t<li>箱子仅有一个，用字符&nbsp;<code>'B'</code>&nbsp;表示。相应地，网格上有一个目标位置&nbsp;<code>'T'</code>。</li>\n\t<li>玩家需要站在箱子旁边，然后沿着箱子的方向进行移动，此时箱子会被移动到相邻的地板单元格。记作一次「推动」。</li>\n\t<li>玩家无法越过箱子。</li>\n</ul>\n\n<p>返回将箱子推到目标位置的最小 <strong>推动</strong> 次数，如果无法做到，请返回&nbsp;<code>-1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/sample_1_1620.png\" style=\"height: 335px; width: 500px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n             [\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\n&nbsp;            [\"#\",\".\",\".\",\"B\",\".\",\"#\"],\n&nbsp;            [\"#\",\".\",\"#\",\"#\",\".\",\"#\"],\n&nbsp;            [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n&nbsp;            [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\n<strong>输出：</strong>3\n<strong>解释：</strong>我们只需要返回推箱子的次数。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n             [\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\n&nbsp;            [\"#\",\".\",\".\",\"B\",\".\",\"#\"],\n&nbsp;            [\"#\",\"#\",\"#\",\"#\",\".\",\"#\"],\n&nbsp;            [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n&nbsp;            [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\n<strong>输出：</strong>-1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n&nbsp;            [\"#\",\"T\",\".\",\".\",\"#\",\"#\"],\n&nbsp;            [\"#\",\".\",\"#\",\"B\",\".\",\"#\"],\n&nbsp;            [\"#\",\".\",\".\",\".\",\".\",\"#\"],\n&nbsp;            [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n&nbsp;            [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\n<strong>输出：</strong>5\n<strong>解释：</strong>向下、向左、向左、向上再向上。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 20</code></li>\n\t<li><code>grid</code> 仅包含字符&nbsp;<code>'.'</code>, <code>'#'</code>,&nbsp; <code>'S'</code> , <code>'T'</code>, 以及&nbsp;<code>'B'</code>。</li>\n\t<li><code>grid</code>&nbsp;中&nbsp;<code>'S'</code>, <code>'B'</code>&nbsp;和&nbsp;<code>'T'</code>&nbsp;各只能出现一个。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1264.页面推荐",
        "hardRate": "MEDIUM",
        "passRate": "56.99%",
        "problemsUrl": "https://leetcode.cn/problems/page-recommendations/",
        "solutionsUrl": "https://leetcode.cn/problems/page-recommendations/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1265.逆序打印不可变链表",
        "hardRate": "MEDIUM",
        "passRate": "90.69%",
        "problemsUrl": "https://leetcode.cn/problems/print-immutable-linked-list-in-reverse/",
        "solutionsUrl": "https://leetcode.cn/problems/print-immutable-linked-list-in-reverse/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1266.访问所有点的最小时间",
        "hardRate": "EASY",
        "passRate": "82.80%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-visiting-all-points/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-visiting-all-points/solution",
        "problemsDesc": "<p>平面上有 <code>n</code> 个点，点的位置用整数坐标表示 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 。请你计算访问所有这些点需要的 <strong>最小时间</strong>（以秒为单位）。</p>\n\n<p>你需要按照下面的规则在平面上移动：</p>\n\n<ul>\n\t<li>每一秒内，你可以：\n\t<ul>\n\t\t<li>沿水平方向移动一个单位长度，或者</li>\n\t\t<li>沿竖直方向移动一个单位长度，或者</li>\n\t\t<li>跨过对角线移动 <code>sqrt(2)</code> 个单位长度（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。</li>\n\t</ul>\n\t</li>\n\t<li>必须按照数组中出现的顺序来访问这些点。</li>\n\t<li>在访问某个点时，可以经过该点后面出现的点，但经过的那些点不算作有效访问。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/24/1626_example_1.png\" style=\"height: 428px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>points = [[1,1],[3,4],[-1,0]]\n<strong>输出：</strong>7\n<strong>解释：</strong>一条最佳的访问路径是： <strong>[1,1]</strong> -> [2,2] -> [3,3] -> <strong>[3,4] </strong>-> [2,3] -> [1,2] -> [0,1] -> <strong>[-1,0]</strong>   \n从 [1,1] 到 [3,4] 需要 3 秒 \n从 [3,4] 到 [-1,0] 需要 4 秒\n一共需要 7 秒</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[3,2],[-2,2]]\n<strong>输出：</strong>5\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>points.length == n</code></li>\n\t<li><code>1 <= n <= 100</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>-1000 <= points[i][0], points[i][1] <= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1267.统计参与通信的服务器",
        "hardRate": "MEDIUM",
        "passRate": "61.87%",
        "problemsUrl": "https://leetcode.cn/problems/count-servers-that-communicate/",
        "solutionsUrl": "https://leetcode.cn/problems/count-servers-that-communicate/solution",
        "problemsDesc": "<p>这里有一幅服务器分布图，服务器的位置标识在&nbsp;<code>m * n</code>&nbsp;的整数矩阵网格&nbsp;<code>grid</code>&nbsp;中，1 表示单元格上有服务器，0 表示没有。</p>\n\n<p>如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。</p>\n\n<p>请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/24/untitled-diagram-6.jpg\" style=\"height: 203px; width: 202px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[1,0],[0,1]]\n<strong>输出：</strong>0\n<strong>解释：</strong>没有一台服务器能与其他服务器进行通信。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/24/untitled-diagram-4-1.jpg\" style=\"height: 203px; width: 203px;\"></strong></p>\n\n<pre><strong>输入：</strong>grid = [[1,0],[1,1]]\n<strong>输出：</strong>3\n<strong>解释：</strong>所有这些服务器都至少可以与一台别的服务器进行通信。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/24/untitled-diagram-1-3.jpg\" style=\"height: 443px; width: 443px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]\n<strong>输出：</strong>4\n<strong>解释：</strong>第一行的两台服务器互相通信，第三列的两台服务器互相通信，但右下角的服务器无法与其他服务器通信。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m &lt;= 250</code></li>\n\t<li><code>1 &lt;= n &lt;= 250</code></li>\n\t<li><code>grid[i][j] == 0 or 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1268.搜索推荐系统",
        "hardRate": "MEDIUM",
        "passRate": "59.41%",
        "problemsUrl": "https://leetcode.cn/problems/search-suggestions-system/",
        "solutionsUrl": "https://leetcode.cn/problems/search-suggestions-system/solution",
        "problemsDesc": "<p>给你一个产品数组&nbsp;<code>products</code>&nbsp;和一个字符串&nbsp;<code>searchWord</code>&nbsp;，<code>products</code>&nbsp; 数组中每个产品都是一个字符串。</p>\n\n<p>请你设计一个推荐系统，在依次输入单词&nbsp;<code>searchWord</code> 的每一个字母后，推荐&nbsp;<code>products</code> 数组中前缀与&nbsp;<code>searchWord</code> 相同的最多三个产品。如果前缀相同的可推荐产品超过三个，请按字典序返回最小的三个。</p>\n\n<p>请你以二维列表的形式，返回在输入&nbsp;<code>searchWord</code>&nbsp;每个字母后相应的推荐产品的列表。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>products = [&quot;mobile&quot;,&quot;mouse&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mousepad&quot;], searchWord = &quot;mouse&quot;\n<strong>输出：</strong>[\n[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],\n[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],\n[&quot;mouse&quot;,&quot;mousepad&quot;],\n[&quot;mouse&quot;,&quot;mousepad&quot;],\n[&quot;mouse&quot;,&quot;mousepad&quot;]\n]\n<strong>解释：</strong>按字典序排序后的产品列表是 [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mouse&quot;,&quot;mousepad&quot;]\n输入 m 和 mo，由于所有产品的前缀都相同，所以系统返回字典序最小的三个产品 [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;]\n输入 mou， mous 和 mouse 后系统都返回 [&quot;mouse&quot;,&quot;mousepad&quot;]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>products = [&quot;havana&quot;], searchWord = &quot;havana&quot;\n<strong>输出：</strong>[[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>products = [&quot;bags&quot;,&quot;baggage&quot;,&quot;banner&quot;,&quot;box&quot;,&quot;cloths&quot;], searchWord = &quot;bags&quot;\n<strong>输出：</strong>[[&quot;baggage&quot;,&quot;bags&quot;,&quot;banner&quot;],[&quot;baggage&quot;,&quot;bags&quot;,&quot;banner&quot;],[&quot;baggage&quot;,&quot;bags&quot;],[&quot;bags&quot;]]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>products = [&quot;havana&quot;], searchWord = &quot;tatiana&quot;\n<strong>输出：</strong>[[],[],[],[],[],[],[]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= products.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= &Sigma; products[i].length &lt;= 2 * 10^4</code></li>\n\t<li><code>products[i]</code>&nbsp;中所有的字符都是小写英文字母。</li>\n\t<li><code>1 &lt;= searchWord.length &lt;= 1000</code></li>\n\t<li><code>searchWord</code>&nbsp;中所有字符都是小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1269.停在原地的方案数",
        "hardRate": "HARD",
        "passRate": "49.03%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/solution",
        "problemsDesc": "<p>有一个长度为 <code>arrLen</code> 的数组，开始有一个指针在索引 <code>0</code> 处。</p>\n\n<p>每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。</p>\n\n<p>给你两个整数 <code>steps</code> 和 <code>arrLen</code> ，请你计算并返回：在恰好执行 <code>steps</code> 次操作以后，指针仍然指向索引 <code>0</code> 处的方案数。</p>\n\n<p>由于答案可能会很大，请返回方案数 <strong>模</strong> <code>10^9 + 7</code> 后的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>steps = 3, arrLen = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>3 步后，总共有 4 种不同的方法可以停在索引 0 处。\n向右，向左，不动\n不动，向右，向左\n向右，不动，向左\n不动，不动，不动\n</pre>\n\n<p><strong>示例  2：</strong></p>\n\n<pre>\n<strong>输入：</strong>steps = 2, arrLen = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>2 步后，总共有 2 种不同的方法可以停在索引 0 处。\n向右，向左\n不动，不动\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>steps = 4, arrLen = 2\n<strong>输出：</strong>8\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= steps <= 500</code></li>\n\t<li><code>1 <= arrLen <= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1270.向公司CEO汇报工作的所有人",
        "hardRate": "MEDIUM",
        "passRate": "79.71%",
        "problemsUrl": "https://leetcode.cn/problems/all-people-report-to-the-given-manager/",
        "solutionsUrl": "https://leetcode.cn/problems/all-people-report-to-the-given-manager/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1271.十六进制魔术数字",
        "hardRate": "EASY",
        "passRate": "52.37%",
        "problemsUrl": "https://leetcode.cn/problems/hexspeak/",
        "solutionsUrl": "https://leetcode.cn/problems/hexspeak/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1272.删除区间",
        "hardRate": "MEDIUM",
        "passRate": "56.84%",
        "problemsUrl": "https://leetcode.cn/problems/remove-interval/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-interval/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1273.删除树节点",
        "hardRate": "MEDIUM",
        "passRate": "57.09%",
        "problemsUrl": "https://leetcode.cn/problems/delete-tree-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-tree-nodes/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1274.矩形内船只的数目",
        "hardRate": "HARD",
        "passRate": "64.90%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ships-in-a-rectangle/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ships-in-a-rectangle/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1275.找出井字棋的获胜者",
        "hardRate": "EASY",
        "passRate": "55.10%",
        "problemsUrl": "https://leetcode.cn/problems/find-winner-on-a-tic-tac-toe-game/",
        "solutionsUrl": "https://leetcode.cn/problems/find-winner-on-a-tic-tac-toe-game/solution",
        "problemsDesc": "<p><em>A</em> 和&nbsp;<em>B</em>&nbsp;在一个&nbsp;<em>3</em>&nbsp;x&nbsp;<em>3</em>&nbsp;的网格上玩井字棋。</p>\n\n<p>井字棋游戏的规则如下：</p>\n\n<ul>\n\t<li>玩家轮流将棋子放在空方格 (&quot; &quot;) 上。</li>\n\t<li>第一个玩家 A 总是用&nbsp;&quot;X&quot; 作为棋子，而第二个玩家 B 总是用 &quot;O&quot; 作为棋子。</li>\n\t<li>&quot;X&quot; 和 &quot;O&quot; 只能放在空方格中，而不能放在已经被占用的方格上。</li>\n\t<li>只要有 3 个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。</li>\n\t<li>如果所有方块都放满棋子（不为空），游戏也会结束。</li>\n\t<li>游戏结束后，棋子无法再进行任何移动。</li>\n</ul>\n\n<p>给你一个数组 <code>moves</code>，其中每个元素是大小为 <code>2</code> 的另一个数组（元素分别对应网格的行和列），它按照 <em>A</em> 和 <em>B</em> 的行动顺序（先 <em>A</em> 后 <em>B</em>）记录了两人各自的棋子位置。</p>\n\n<p>如果游戏存在获胜者（<em>A</em> 或 <em>B</em>），就返回该游戏的获胜者；如果游戏以平局结束，则返回 &quot;Draw&quot;；如果仍会有行动（游戏未结束），则返回 &quot;Pending&quot;。</p>\n\n<p>你可以假设&nbsp;<code>moves</code>&nbsp;都 <strong>有效</strong>（遵循井字棋规则），网格最初是空的，<em>A</em> 将先行动。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]\n<strong>输出：</strong>&quot;A&quot;\n<strong>解释：</strong>&quot;A&quot; 获胜，他总是先走。\n&quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;    &quot;<strong>X</strong>  &quot;\n&quot;   &quot; -&gt; &quot;   &quot; -&gt; &quot; X &quot; -&gt; &quot; X &quot; -&gt; &quot; <strong>X</strong> &quot;\n&quot;   &quot;    &quot;O  &quot;    &quot;O  &quot;    &quot;OO &quot;    &quot;OO<strong>X</strong>&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]\n<strong>输出：</strong>&quot;B&quot;\n<strong>解释：</strong>&quot;B&quot; 获胜。\n&quot;X  &quot;    &quot;X  &quot;    &quot;XX &quot;    &quot;XXO&quot;    &quot;XXO&quot;    &quot;XX<strong>O</strong>&quot;\n&quot;   &quot; -&gt; &quot; O &quot; -&gt; &quot; O &quot; -&gt; &quot; O &quot; -&gt; &quot;XO &quot; -&gt; &quot;X<strong>O</strong> &quot; \n&quot;   &quot;    &quot;   &quot;    &quot;   &quot;    &quot;   &quot;    &quot;   &quot;    &quot;<strong>O</strong>  &quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]\n<strong>输出：</strong>&quot;Draw&quot;\n<strong>输出：</strong>由于没有办法再行动，游戏以平局结束。\n&quot;XXO&quot;\n&quot;OOX&quot;\n&quot;XOX&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>moves = [[0,0],[1,1]]\n<strong>输出：</strong>&quot;Pending&quot;\n<strong>解释：</strong>游戏还没有结束。\n&quot;X  &quot;\n&quot; O &quot;\n&quot;   &quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= moves.length &lt;= 9</code></li>\n\t<li><code>moves[i].length == 2</code></li>\n\t<li><code>0 &lt;= moves[i][j] &lt;= 2</code></li>\n\t<li><code>moves</code>&nbsp;里没有重复的元素。</li>\n\t<li><code>moves</code> 遵循井字棋的规则。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1276.不浪费原料的汉堡制作方案",
        "hardRate": "MEDIUM",
        "passRate": "50.29%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-burgers-with-no-waste-of-ingredients/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-burgers-with-no-waste-of-ingredients/solution",
        "problemsDesc": "<p>圣诞活动预热开始啦，汉堡店推出了全新的汉堡套餐。为了避免浪费原料，请你帮他们制定合适的制作计划。</p>\n\n<p>给你两个整数&nbsp;<code>tomatoSlices</code>&nbsp;和&nbsp;<code>cheeseSlices</code>，分别表示番茄片和奶酪片的数目。不同汉堡的原料搭配如下：</p>\n\n<ul>\n\t<li><strong>巨无霸汉堡：</strong>4 片番茄和 1 片奶酪</li>\n\t<li><strong>小皇堡：</strong>2 片番茄和&nbsp;1 片奶酪</li>\n</ul>\n\n<p>请你以&nbsp;<code>[total_jumbo, total_small]</code>（[巨无霸汉堡总数，小皇堡总数]）的格式返回恰当的制作方案，使得剩下的番茄片&nbsp;<code>tomatoSlices</code>&nbsp;和奶酪片&nbsp;<code>cheeseSlices</code>&nbsp;的数量都是&nbsp;<code>0</code>。</p>\n\n<p>如果无法使剩下的番茄片&nbsp;<code>tomatoSlices</code>&nbsp;和奶酪片&nbsp;<code>cheeseSlices</code>&nbsp;的数量为&nbsp;<code>0</code>，就请返回&nbsp;<code>[]</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>tomatoSlices = 16, cheeseSlices = 7\n<strong>输出：</strong>[1,6]\n<strong>解释：</strong>制作 1 个巨无霸汉堡和 6 个小皇堡需要 4*1 + 2*6 = 16 片番茄和 1 + 6 = 7 片奶酪。不会剩下原料。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>tomatoSlices = 17, cheeseSlices = 4\n<strong>输出：</strong>[]\n<strong>解释：</strong>只制作小皇堡和巨无霸汉堡无法用光全部原料。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>tomatoSlices = 4, cheeseSlices = 17\n<strong>输出：</strong>[]\n<strong>解释：</strong>制作 1 个巨无霸汉堡会剩下 16 片奶酪，制作 2 个小皇堡会剩下 15 片奶酪。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>tomatoSlices = 0, cheeseSlices = 0\n<strong>输出：</strong>[0,0]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>tomatoSlices = 2, cheeseSlices = 1\n<strong>输出：</strong>[0,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= tomatoSlices &lt;= 10^7</code></li>\n\t<li><code>0 &lt;= cheeseSlices &lt;= 10^7</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1277.统计全为 1 的正方形子矩阵",
        "hardRate": "MEDIUM",
        "passRate": "73.50%",
        "problemsUrl": "https://leetcode.cn/problems/count-square-submatrices-with-all-ones/",
        "solutionsUrl": "https://leetcode.cn/problems/count-square-submatrices-with-all-ones/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m * n</code>&nbsp;的矩阵，矩阵中的元素不是 <code>0</code> 就是 <code>1</code>，请你统计并返回其中完全由 <code>1</code> 组成的 <strong>正方形</strong> 子矩阵的个数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>matrix =\n[\n&nbsp; [0,1,1,1],\n&nbsp; [1,1,1,1],\n&nbsp; [0,1,1,1]\n]\n<strong>输出：</strong>15\n<strong>解释：</strong> \n边长为 1 的正方形有 <strong>10</strong> 个。\n边长为 2 的正方形有 <strong>4</strong> 个。\n边长为 3 的正方形有 <strong>1</strong> 个。\n正方形的总数 = 10 + 4 + 1 = <strong>15</strong>.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>matrix = \n[\n  [1,0,1],\n  [1,1,0],\n  [1,1,0]\n]\n<strong>输出：</strong>7\n<strong>解释：</strong>\n边长为 1 的正方形有 <strong>6</strong> 个。 \n边长为 2 的正方形有 <strong>1</strong> 个。\n正方形的总数 = 6 + 1 = <strong>7</strong>.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length&nbsp;&lt;= 300</code></li>\n\t<li><code>1 &lt;= arr[0].length&nbsp;&lt;= 300</code></li>\n\t<li><code>0 &lt;= arr[i][j] &lt;= 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1278.分割回文串 III",
        "hardRate": "HARD",
        "passRate": "62.22%",
        "problemsUrl": "https://leetcode.cn/problems/palindrome-partitioning-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/palindrome-partitioning-iii/solution",
        "problemsDesc": "<p>给你一个由小写字母组成的字符串&nbsp;<code>s</code>，和一个整数&nbsp;<code>k</code>。</p>\n\n<p>请你按下面的要求分割字符串：</p>\n\n<ul>\n\t<li>首先，你可以将&nbsp;<code>s</code>&nbsp;中的部分字符修改为其他的小写英文字母。</li>\n\t<li>接着，你需要把&nbsp;<code>s</code>&nbsp;分割成&nbsp;<code>k</code>&nbsp;个非空且不相交的子串，并且每个子串都是回文串。</li>\n</ul>\n\n<p>请返回以这种方式分割字符串所需修改的最少字符数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abc&quot;, k = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>你可以把字符串分割成 &quot;ab&quot; 和 &quot;c&quot;，并修改 &quot;ab&quot; 中的 1 个字符，将它变成回文串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aabbc&quot;, k = 3\n<strong>输出：</strong>0\n<strong>解释：</strong>你可以把字符串分割成 &quot;aa&quot;、&quot;bb&quot; 和 &quot;c&quot;，它们都是回文串。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;leetcode&quot;, k = 8\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code>&nbsp;中只含有小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1279.红绿灯路口",
        "hardRate": "EASY",
        "passRate": "57.54%",
        "problemsUrl": "https://leetcode.cn/problems/traffic-light-controlled-intersection/",
        "solutionsUrl": "https://leetcode.cn/problems/traffic-light-controlled-intersection/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1280.学生们参加各科测试的次数",
        "hardRate": "EASY",
        "passRate": "49.47%",
        "problemsUrl": "https://leetcode.cn/problems/students-and-examinations/",
        "solutionsUrl": "https://leetcode.cn/problems/students-and-examinations/solution",
        "problemsDesc": "<p>学生表: <code>Students</code></p>\n\n<pre>+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| student_id    | int     |\n| student_name  | varchar |\n+---------------+---------+\n主键为 student_id（学生ID），该表内的每一行都记录有学校一名学生的信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>科目表: <code>Subjects</code></p>\n\n<pre>+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| subject_name | varchar |\n+--------------+---------+\n主键为 subject_name（科目名称），每一行记录学校的一门科目名称。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>考试表: <code>Examinations</code></p>\n\n<pre>+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| student_id   | int     |\n| subject_name | varchar |\n+--------------+---------+\n这张表压根没有主键，可能会有重复行。\n学生表里的一个学生修读科目表里的每一门科目，而这张考试表的每一行记录就表示学生表里的某个学生参加了一次科目表里某门科目的测试。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>要求写一段 SQL 语句，查询出每个学生参加每一门科目测试的次数，结果按 <code>student_id</code> 和 <code>subject_name</code> 排序。</p>\n\n<p>查询结构格式如下所示：</p>\n\n<pre>Students table:\n+------------+--------------+\n| student_id | student_name |\n+------------+--------------+\n| 1          | Alice        |\n| 2          | Bob          |\n| 13         | John         |\n| 6          | Alex         |\n+------------+--------------+\nSubjects table:\n+--------------+\n| subject_name |\n+--------------+\n| Math         |\n| Physics      |\n| Programming  |\n+--------------+\nExaminations table:\n+------------+--------------+\n| student_id | subject_name |\n+------------+--------------+\n| 1          | Math         |\n| 1          | Physics      |\n| 1          | Programming  |\n| 2          | Programming  |\n| 1          | Physics      |\n| 1          | Math         |\n| 13         | Math         |\n| 13         | Programming  |\n| 13         | Physics      |\n| 2          | Math         |\n| 1          | Math         |\n+------------+--------------+\nResult table:\n+------------+--------------+--------------+----------------+\n| student_id | student_name | subject_name | attended_exams |\n+------------+--------------+--------------+----------------+\n| 1          | Alice        | Math         | 3              |\n| 1          | Alice        | Physics      | 2              |\n| 1          | Alice        | Programming  | 1              |\n| 2          | Bob          | Math         | 1              |\n| 2          | Bob          | Physics      | 0              |\n| 2          | Bob          | Programming  | 1              |\n| 6          | Alex         | Math         | 0              |\n| 6          | Alex         | Physics      | 0              |\n| 6          | Alex         | Programming  | 0              |\n| 13         | John         | Math         | 1              |\n| 13         | John         | Physics      | 1              |\n| 13         | John         | Programming  | 1              |\n+------------+--------------+--------------+----------------+\n结果表需包含所有学生和所有科目（即便测试次数为0）：\nAlice 参加了 3 次数学测试, 2 次物理测试，以及 1 次编程测试；\nBob 参加了 1 次数学测试, 1 次编程测试，没有参加物理测试；\nAlex 啥测试都没参加；\nJohn  参加了数学、物理、编程测试各 1 次。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1281.整数的各位积和之差",
        "hardRate": "EASY",
        "passRate": "83.15%",
        "problemsUrl": "https://leetcode.cn/problems/subtract-the-product-and-sum-of-digits-of-an-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/subtract-the-product-and-sum-of-digits-of-an-integer/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 234\n<strong>输出：</strong>15 \n<strong>解释：</strong>\n各位数之积 = 2 * 3 * 4 = 24 \n各位数之和 = 2 + 3 + 4 = 9 \n结果 = 24 - 9 = 15\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 4421\n<strong>输出：</strong>21\n<strong>解释： \n</strong>各位数之积 = 4 * 4 * 2 * 1 = 32 \n各位数之和 = 4 + 4 + 2 + 1 = 11 \n结果 = 32 - 11 = 21\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1282.用户分组",
        "hardRate": "MEDIUM",
        "passRate": "86.46%",
        "problemsUrl": "https://leetcode.cn/problems/group-the-people-given-the-group-size-they-belong-to/",
        "solutionsUrl": "https://leetcode.cn/problems/group-the-people-given-the-group-size-they-belong-to/solution",
        "problemsDesc": "<p>有&nbsp;<code>n</code>&nbsp;个人被分成数量未知的组。每个人都被标记为一个从 <code>0</code> 到 <code>n - 1</code> 的<strong>唯一ID</strong>&nbsp;。</p>\n\n<p>给定一个整数数组 <code>groupSizes</code> ，其中<meta charset=\"UTF-8\" />&nbsp;<code>groupSizes[i]</code>&nbsp;是第 <code>i</code> 个人所在的组的大小。例如，如果&nbsp;<code>groupSizes[1] = 3</code>&nbsp;，则第 <code>1</code> 个人必须位于大小为 <code>3</code> 的组中。</p>\n\n<p>返回一个组列表，使每个人 <code>i</code> 都在一个大小为<meta charset=\"UTF-8\" /><em>&nbsp;<code>groupSizes[i]</code>&nbsp;</em>的组中。</p>\n\n<p>每个人应该&nbsp;<strong>恰好只&nbsp;</strong>出现在&nbsp;<strong>一个组&nbsp;</strong>中，并且每个人必须在一个组中。如果有多个答案，返回其中&nbsp;<strong>任何&nbsp;</strong>一个。可以&nbsp;<strong>保证&nbsp;</strong>给定输入&nbsp;<strong>至少有一个&nbsp;</strong>有效的解。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>groupSizes = [3,3,3,3,3,1,3]\n<strong>输出：</strong>[[5],[0,1,2],[3,4,6]]\n<strong>解释：\n</strong>第一组是 [5]，大小为 1，groupSizes[5] = 1。\n第二组是 [0,1,2]，大小为 3，groupSizes[0] = groupSizes[1] = groupSizes[2] = 3。\n第三组是 [3,4,6]，大小为 3，groupSizes[3] = groupSizes[4] = groupSizes[6] = 3。 \n其他可能的解决方案有 [[2,1,6],[5],[0,4,3]] 和 [[5],[0,6,2],[4,3,1]]。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>groupSizes = [2,1,3,3,3,2]\n<strong>输出：</strong>[[1],[0,5],[2,3,4]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>groupSizes.length == n</code></li>\n\t<li><code>1 &lt;= n&nbsp;&lt;= 500</code></li>\n\t<li><code>1 &lt;=&nbsp;groupSizes[i] &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1283.使结果不超过阈值的最小除数",
        "hardRate": "MEDIUM",
        "passRate": "49.15%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code> 和一个正整数&nbsp;<code>threshold</code> &nbsp;，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。</p>\n\n<p>请你找出能够使上述结果小于等于阈值&nbsp;<code>threshold</code>&nbsp;的除数中 <strong>最小</strong> 的那个。</p>\n\n<p>每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。</p>\n\n<p>题目保证一定有解。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,5,9], threshold = 6\n<strong>输出：</strong>5\n<strong>解释：</strong>如果除数为 1 ，我们可以得到和为 17 （1+2+5+9）。\n如果除数为 4 ，我们可以得到和为 7 (1+1+2+3) 。如果除数为 5 ，和为 5 (1+1+1+2)。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,5,7,11], threshold = 11\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [19], threshold = 5\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10^4</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^6</code></li>\n\t<li><code>nums.length &lt;=&nbsp;threshold &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1284.转化为全零矩阵的最少反转次数",
        "hardRate": "HARD",
        "passRate": "68.01%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的二进制矩阵&nbsp;<code>mat</code>。每一步，你可以选择一个单元格并将它反转（反转表示 <code>0</code> 变 <code>1</code> ，<code>1</code> 变 <code>0</code> ）。如果存在和它相邻的单元格，那么这些相邻的单元格也会被反转。相邻的两个单元格共享同一条边。</p>\n\n<p>请你返回将矩阵&nbsp;<code>mat</code> 转化为全零矩阵的<em>最少反转次数</em>，如果无法转化为全零矩阵，请返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p><strong>二进制矩阵</strong>&nbsp;的每一个格子要么是 <code>0</code> 要么是 <code>1</code> 。</p>\n\n<p><strong>全零矩阵</strong>&nbsp;是所有格子都为 <code>0</code> 的矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/13/matrix.png\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[0,0],[0,1]]\n<strong>输出：</strong>3\n<strong>解释：</strong>一个可能的解是反转 (1, 0)，然后 (0, 1) ，最后是 (1, 1) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[0]]\n<strong>输出：</strong>0\n<strong>解释：</strong>给出的矩阵是全零矩阵，所以你不需要改变它。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1,0,0],[1,0,0]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>该矩阵无法转变成全零矩阵\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m ==&nbsp;mat.length</code></li>\n\t<li><code>n ==&nbsp;mat[0].length</code></li>\n\t<li><code>1 &lt;= m&nbsp;&lt;= 3</code></li>\n\t<li><code>1 &lt;= n&nbsp;&lt;= 3</code></li>\n\t<li><code>mat[i][j]</code>&nbsp;是 0 或 1 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1285.找到连续区间的开始和结束数字",
        "hardRate": "MEDIUM",
        "passRate": "80.94%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-start-and-end-number-of-continuous-ranges/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-start-and-end-number-of-continuous-ranges/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1286.字母组合迭代器",
        "hardRate": "MEDIUM",
        "passRate": "65.10%",
        "problemsUrl": "https://leetcode.cn/problems/iterator-for-combination/",
        "solutionsUrl": "https://leetcode.cn/problems/iterator-for-combination/solution",
        "problemsDesc": "<p>请你设计一个迭代器类&nbsp;<code>CombinationIterator</code>&nbsp;，包括以下内容：</p>\n\n<ul>\n\t<li><code>CombinationIterator(string characters, int combinationLength)</code>&nbsp;一个构造函数，输入参数包括：用一个&nbsp;<strong>有序且字符唯一&nbsp;</strong>的字符串&nbsp;<code>characters</code>（该字符串只包含小写英文字母）和一个数字&nbsp;<code>combinationLength</code>&nbsp;。</li>\n\t<li>函数&nbsp;<em><code>next()</code>&nbsp;</em>，按&nbsp;<strong>字典序&nbsp;</strong>返回长度为&nbsp;<code>combinationLength</code> 的下一个字母组合。</li>\n\t<li>函数&nbsp;<em><code>hasNext()</code>&nbsp;</em>，只有存在长度为&nbsp;<code>combinationLength</code> 的下一个字母组合时，才返回&nbsp;<code>true</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong>\n[\"CombinationIterator\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[\"abc\", 2], [], [], [], [], [], []]\n<strong>输出：</strong>\n[null, \"ab\", true, \"ac\", true, \"bc\", false]\n<strong>解释：\n</strong>CombinationIterator iterator = new CombinationIterator(\"abc\", 2); // 创建迭代器 iterator\niterator.next(); // 返回 \"ab\"\niterator.hasNext(); // 返回 true\niterator.next(); // 返回 \"ac\"\niterator.hasNext(); // 返回 true\niterator.next(); // 返回 \"bc\"\niterator.hasNext(); // 返回 false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= combinationLength &lt;=&nbsp;characters.length &lt;= 15</code></li>\n\t<li>&nbsp;<code>characters</code>&nbsp;中每个字符都 <strong>不同</strong></li>\n\t<li>每组测试数据最多对&nbsp;<code>next</code>&nbsp;和&nbsp;<code>hasNext</code>&nbsp;调用&nbsp;<code>10<sup>4</sup></code>次</li>\n\t<li>题目保证每次调用函数&nbsp;<code>next</code>&nbsp;时都存在下一个字母组合。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1287.有序数组中出现次数超过25%的元素",
        "hardRate": "EASY",
        "passRate": "58.74%",
        "problemsUrl": "https://leetcode.cn/problems/element-appearing-more-than-25-in-sorted-array/",
        "solutionsUrl": "https://leetcode.cn/problems/element-appearing-more-than-25-in-sorted-array/solution",
        "problemsDesc": "<p>给你一个非递减的&nbsp;<strong>有序&nbsp;</strong>整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。</p>\n\n<p>请你找到并返回这个整数</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,2,6,6,6,6,7,10]\n<strong>输出：</strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10^4</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1288.删除被覆盖区间",
        "hardRate": "MEDIUM",
        "passRate": "56.02%",
        "problemsUrl": "https://leetcode.cn/problems/remove-covered-intervals/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-covered-intervals/solution",
        "problemsDesc": "<p>给你一个区间列表，请你删除列表中被其他区间所覆盖的区间。</p>\n\n<p>只有当&nbsp;<code>c &lt;= a</code>&nbsp;且&nbsp;<code>b &lt;= d</code>&nbsp;时，我们才认为区间&nbsp;<code>[a,b)</code> 被区间&nbsp;<code>[c,d)</code> 覆盖。</p>\n\n<p>在完成所有删除操作后，请你返回列表中剩余区间的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,4],[3,6],[2,8]]\n<strong>输出：</strong>2\n<strong>解释：</strong>区间 [3,6] 被区间 [2,8] 覆盖，所以它被删除了。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong>​​​​​​</p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= intervals[i][0] &lt;&nbsp;intervals[i][1] &lt;= 10^5</code></li>\n\t<li>对于所有的&nbsp;<code>i != j</code>：<code>intervals[i] != intervals[j]</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1289.下降路径最小和  II",
        "hardRate": "HARD",
        "passRate": "58.30%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-falling-path-sum-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-falling-path-sum-ii/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>n x n</code> 整数矩阵&nbsp;<code>grid</code>&nbsp;，请你返回 <strong>非零偏移下降路径</strong> 数字和的最小值。</p>\n\n<p><strong>非零偏移下降路径</strong> 定义为：从&nbsp;<code>grid</code> 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/10/falling-grid.jpg\" style=\"width: 244px; height: 245px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>13\n<strong>解释：</strong>\n所有非零偏移下降路径包括：\n[1,5,9], [1,5,7], [1,6,7], [1,6,8],\n[2,4,8], [2,4,9], [2,6,7], [2,6,8],\n[3,4,8], [3,4,9], [3,5,7], [3,5,9]\n下降路径中数字和最小的是&nbsp;[1,5,7] ，所以答案是&nbsp;13 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[7]]\n<strong>输出：</strong>7\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>-99 &lt;= grid[i][j] &lt;= 99</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1290.二进制链表转整数",
        "hardRate": "EASY",
        "passRate": "80.52%",
        "problemsUrl": "https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer/solution",
        "problemsDesc": "<p>给你一个单链表的引用结点&nbsp;<code>head</code>。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。</p>\n\n<p>请你返回该链表所表示数字的 <strong>十进制值</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/15/graph-1.png\" style=\"height: 108px; width: 426px;\"></p>\n\n<pre><strong>输入：</strong>head = [1,0,1]\n<strong>输出：</strong>5\n<strong>解释：</strong>二进制数 (101) 转化为十进制数 (5)\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>head = [0]\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>head = [1]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]\n<strong>输出：</strong>18880\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>head = [0,0]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表不为空。</li>\n\t<li>链表的结点总数不超过&nbsp;<code>30</code>。</li>\n\t<li>每个结点的值不是&nbsp;<code>0</code> 就是 <code>1</code>。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1291.顺次数",
        "hardRate": "MEDIUM",
        "passRate": "53.51%",
        "problemsUrl": "https://leetcode.cn/problems/sequential-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/sequential-digits/solution",
        "problemsDesc": "<p>我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 <code>1</code> 的整数。</p>\n\n<p>请你返回由&nbsp;<code>[low, high]</code>&nbsp;范围内所有顺次数组成的 <strong>有序</strong> 列表（从小到大排序）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输出：</strong>low = 100, high = 300\n<strong>输出：</strong>[123,234]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输出：</strong>low = 1000, high = 13000\n<strong>输出：</strong>[1234,2345,3456,4567,5678,6789,12345]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>10 &lt;= low &lt;= high &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1292.元素和小于等于阈值的正方形的最大边长",
        "hardRate": "MEDIUM",
        "passRate": "50.71%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/solution",
        "problemsDesc": "<p>给你一个大小为&nbsp;<code>m x n</code>&nbsp;的矩阵&nbsp;<code>mat</code>&nbsp;和一个整数阈值&nbsp;<code>threshold</code>。</p>\n\n<p>请你返回元素总和小于或等于阈值的正方形区域的最大边长；如果没有这样的正方形区域，则返回 <strong>0&nbsp;</strong>。<br />\n&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/15/e1.png\" style=\"height: 186px; width: 335px;\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>总和小于或等于 4 的正方形的最大边长为 2，如图所示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>0 &lt;= mat[i][j] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= threshold &lt;= 10<sup>5</sup></code><sup>&nbsp;</sup></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1293.网格中的最短路径",
        "hardRate": "HARD",
        "passRate": "38.34%",
        "problemsUrl": "https://leetcode.cn/problems/shortest-path-in-a-grid-with-obstacles-elimination/",
        "solutionsUrl": "https://leetcode.cn/problems/shortest-path-in-a-grid-with-obstacles-elimination/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m * n</code>&nbsp;的网格，其中每个单元格不是&nbsp;<code>0</code>（空）就是&nbsp;<code>1</code>（障碍物）。每一步，您都可以在空白单元格中上、下、左、右移动。</p>\n\n<p>如果您 <strong>最多</strong> 可以消除 <code>k</code> 个障碍物，请找出从左上角 <code>(0, 0)</code> 到右下角 <code>(m-1, n-1)</code> 的最短路径，并返回通过该路径所需的步数。如果找不到这样的路径，则返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/09/30/short1-grid.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong> grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1\n<strong>输出：</strong>6\n<strong>解释：\n</strong>不消除任何障碍的最短路径是 10。\n消除位置 (3,2) 处的障碍后，最短路径是 6 。该路径是 <code>(0,0) -&gt; (0,1) -&gt; (0,2) -&gt; (1,2) -&gt; (2,2) -&gt; <strong>(3,2)</strong> -&gt; (4,2)</code>.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/09/30/short2-grid.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1\n<strong>输出：</strong>-1\n<strong>解释：</strong>我们至少需要消除两个障碍才能找到这样的路径。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>grid.length&nbsp;== m</code></li>\n\t<li><code>grid[0].length&nbsp;== n</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 40</code></li>\n\t<li><code>1 &lt;= k &lt;= m*n</code></li>\n\t<li><code>grid[i][j]</code>&nbsp;是&nbsp;<code>0</code>&nbsp;或<strong>&nbsp;</strong><code>1</code></li>\n\t<li><code>grid[0][0] == grid[m-1][n-1] == 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1294.不同国家的天气类型",
        "hardRate": "EASY",
        "passRate": "65.55%",
        "problemsUrl": "https://leetcode.cn/problems/weather-type-in-each-country/",
        "solutionsUrl": "https://leetcode.cn/problems/weather-type-in-each-country/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1295.统计位数为偶数的数字",
        "hardRate": "EASY",
        "passRate": "80.06%",
        "problemsUrl": "https://leetcode.cn/problems/find-numbers-with-even-number-of-digits/",
        "solutionsUrl": "https://leetcode.cn/problems/find-numbers-with-even-number-of-digits/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>，请你返回其中位数为&nbsp;<strong>偶数</strong>&nbsp;的数字的个数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [12,345,2,6,7896]\n<strong>输出：</strong>2\n<strong>解释：\n</strong>12 是 2 位数字（位数为偶数）&nbsp;\n345 是 3 位数字（位数为奇数）&nbsp;&nbsp;\n2 是 1 位数字（位数为奇数）&nbsp;\n6 是 1 位数字 位数为奇数）&nbsp;\n7896 是 4 位数字（位数为偶数）&nbsp;&nbsp;\n因此只有 12 和 7896 是位数为偶数的数字\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [555,901,482,1771]\n<strong>输出：</strong>1 \n<strong>解释： </strong>\n只有 1771 是位数为偶数的数字。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1296.划分数组为连续数字的集合",
        "hardRate": "MEDIUM",
        "passRate": "49.10%",
        "problemsUrl": "https://leetcode.cn/problems/divide-array-in-sets-of-k-consecutive-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/divide-array-in-sets-of-k-consecutive-numbers/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;和一个正整数&nbsp;<code>k</code>，请你判断是否可以把这个数组划分成一些由&nbsp;<code>k</code>&nbsp;个连续数字组成的集合。<br />\n如果可以，请返回 <code>true</code>；否则，返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,3,4,4,5,6], k = 4\n<strong>输出：</strong>true\n<strong>解释：</strong>数组可以分成 [1,2,3,4] 和 [3,4,5,6]。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3\n<strong>输出：</strong>true\n<strong>解释：</strong>数组可以分成 [1,2,3] , [2,3,4] , [3,4,5] 和 [9,10,11]。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,3,2,2,1,1], k = 3\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4], k = 3\n<strong>输出：</strong>false\n<strong>解释：</strong>数组不能分成几个大小为 3 的子数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>此题目与 846 重复：<a href=\"https://leetcode-cn.com/problems/hand-of-straights/\" target=\"_blank\">https://leetcode-cn.com/problems/hand-of-straights/</a></p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1297.子串的最大出现次数",
        "hardRate": "MEDIUM",
        "passRate": "48.33%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-occurrences-of-a-substring/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-occurrences-of-a-substring/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code> ，请你返回满足以下条件且出现次数最大的&nbsp;<strong>任意</strong>&nbsp;子串的出现次数：</p>\n\n<ul>\n\t<li>子串中不同字母的数目必须小于等于 <code>maxLetters</code> 。</li>\n\t<li>子串的长度必须大于等于&nbsp;<code>minSize</code> 且小于等于&nbsp;<code>maxSize</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aababcaab&quot;, maxLetters = 2, minSize = 3, maxSize = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>子串 &quot;aab&quot; 在原字符串中出现了 2 次。\n它满足所有的要求：2 个不同的字母，长度为 3 （在 minSize 和 maxSize 范围内）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aaaa&quot;, maxLetters = 1, minSize = 3, maxSize = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>子串 &quot;aaa&quot; 在原字符串中出现了 2 次，且它们有重叠部分。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aabcabcab&quot;, maxLetters = 2, minSize = 2, maxSize = 3\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abcde&quot;, maxLetters = 2, minSize = 3, maxSize = 3\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= maxLetters &lt;= 26</code></li>\n\t<li><code>1 &lt;= minSize &lt;= maxSize &lt;= min(26, s.length)</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1298.你能从盒子里获得的最大糖果数",
        "hardRate": "HARD",
        "passRate": "59.79%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-candies-you-can-get-from-boxes/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-candies-you-can-get-from-boxes/solution",
        "problemsDesc": "<p>给你&nbsp;<code>n</code>&nbsp;个盒子，每个盒子的格式为&nbsp;<code>[status, candies, keys, containedBoxes]</code>&nbsp;，其中：</p>\n\n<ul>\n\t<li>状态字&nbsp;<code>status[i]</code>：整数，如果&nbsp;<code>box[i]</code>&nbsp;是开的，那么是 <strong>1&nbsp;</strong>，否则是 <strong>0&nbsp;</strong>。</li>\n\t<li>糖果数&nbsp;<code>candies[i]</code>: 整数，表示&nbsp;<code>box[i]</code> 中糖果的数目。</li>\n\t<li>钥匙&nbsp;<code>keys[i]</code>：数组，表示你打开&nbsp;<code>box[i]</code>&nbsp;后，可以得到一些盒子的钥匙，每个元素分别为该钥匙对应盒子的下标。</li>\n\t<li>内含的盒子&nbsp;<code>containedBoxes[i]</code>：整数，表示放在&nbsp;<code>box[i]</code>&nbsp;里的盒子所对应的下标。</li>\n</ul>\n\n<p>给你一个&nbsp;<code>initialBoxes</code> 数组，表示你现在得到的盒子，你可以获得里面的糖果，也可以用盒子里的钥匙打开新的盒子，还可以继续探索从这个盒子里找到的其他盒子。</p>\n\n<p>请你按照上述规则，返回可以获得糖果的 <strong>最大数目&nbsp;</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>status = [1,0,1,0], candies = [7,5,4,100], keys = [[],[],[1],[]], containedBoxes = [[1,2],[3],[],[]], initialBoxes = [0]\n<strong>输出：</strong>16\n<strong>解释：\n</strong>一开始你有盒子 0 。你将获得它里面的 7 个糖果和盒子 1 和 2。\n盒子 1 目前状态是关闭的，而且你还没有对应它的钥匙。所以你将会打开盒子 2 ，并得到里面的 4 个糖果和盒子 1 的钥匙。\n在盒子 1 中，你会获得 5 个糖果和盒子 3 ，但是你没法获得盒子 3 的钥匙所以盒子 3 会保持关闭状态。\n你总共可以获得的糖果数目 = 7 + 4 + 5 = 16 个。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>status = [1,0,0,0,0,0], candies = [1,1,1,1,1,1], keys = [[1,2,3,4,5],[],[],[],[],[]], containedBoxes = [[1,2,3,4,5],[],[],[],[],[]], initialBoxes = [0]\n<strong>输出：</strong>6\n<strong>解释：\n</strong>你一开始拥有盒子 0 。打开它你可以找到盒子 1,2,3,4,5 和它们对应的钥匙。\n打开这些盒子，你将获得所有盒子的糖果，所以总糖果数为 6 个。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>status = [1,1,1], candies = [100,1,100], keys = [[],[0,2],[]], containedBoxes = [[],[],[]], initialBoxes = [1]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>status = [1], candies = [100], keys = [[]], containedBoxes = [[]], initialBoxes = []\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>status = [1,1,1], candies = [2,3,2], keys = [[],[],[]], containedBoxes = [[],[],[]], initialBoxes = [2,1,0]\n<strong>输出：</strong>7\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= status.length &lt;= 1000</code></li>\n\t<li><code>status.length == candies.length == keys.length == containedBoxes.length == n</code></li>\n\t<li><code>status[i]</code> 要么是&nbsp;<code>0</code>&nbsp;要么是&nbsp;<code>1</code> 。</li>\n\t<li><code>1 &lt;= candies[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= keys[i].length &lt;= status.length</code></li>\n\t<li><code>0 &lt;= keys[i][j] &lt; status.length</code></li>\n\t<li><code>keys[i]</code>&nbsp;中的值都是互不相同的。</li>\n\t<li><code>0 &lt;= containedBoxes[i].length &lt;= status.length</code></li>\n\t<li><code>0 &lt;= containedBoxes[i][j] &lt; status.length</code></li>\n\t<li><code>containedBoxes[i]</code>&nbsp;中的值都是互不相同的。</li>\n\t<li>每个盒子最多被一个盒子包含。</li>\n\t<li><code>0 &lt;= initialBoxes.length&nbsp;&lt;= status.length</code></li>\n\t<li><code>0 &lt;= initialBoxes[i] &lt; status.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1299.将每个元素替换为右侧最大元素",
        "hardRate": "EASY",
        "passRate": "76.98%",
        "problemsUrl": "https://leetcode.cn/problems/replace-elements-with-greatest-element-on-right-side/",
        "solutionsUrl": "https://leetcode.cn/problems/replace-elements-with-greatest-element-on-right-side/solution",
        "problemsDesc": "<p>给你一个数组 <code>arr</code> ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 <code>-1</code> 替换。</p>\n\n<p>完成所有替换操作后，请你返回这个数组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [17,18,5,4,6,1]\n<strong>输出：</strong>[18,6,6,6,1,-1]\n<strong>解释：</strong>\n- 下标 0 的元素 --> 右侧最大元素是下标 1 的元素 (18)\n- 下标 1 的元素 --> 右侧最大元素是下标 4 的元素 (6)\n- 下标 2 的元素 --> 右侧最大元素是下标 4 的元素 (6)\n- 下标 3 的元素 --> 右侧最大元素是下标 4 的元素 (6)\n- 下标 4 的元素 --> 右侧最大元素是下标 5 的元素 (1)\n- 下标 5 的元素 --> 右侧没有其他元素，替换为 -1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [400]\n<strong>输出：</strong>[-1]\n<strong>解释：</strong>下标<strong> </strong>0 的元素右侧没有其他元素。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= arr.length <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= arr[i] <= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1300.转变数组后最接近目标值的数组和",
        "hardRate": "MEDIUM",
        "passRate": "46.78%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-mutated-array-closest-to-target/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-mutated-array-closest-to-target/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code> 和一个目标值&nbsp;<code>target</code> ，请你返回一个整数&nbsp;<code>value</code>&nbsp;，使得将数组中所有大于&nbsp;<code>value</code> 的值变成&nbsp;<code>value</code> 后，数组的和最接近&nbsp; <code>target</code>&nbsp;（最接近表示两者之差的绝对值最小）。</p>\n\n<p>如果有多种使得和最接近&nbsp;<code>target</code>&nbsp;的方案，请你返回这些整数中的最小值。</p>\n\n<p>请注意，答案不一定是&nbsp;<code>arr</code> 中的数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [4,9,3], target = 10\n<strong>输出：</strong>3\n<strong>解释：</strong>当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,3,5], target = 10\n<strong>输出：</strong>5\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [60864,25176,27249,21296,20204], target = 56803\n<strong>输出：</strong>11361\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10^4</code></li>\n\t<li><code>1 &lt;= arr[i], target &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1301.最大得分的路径数目",
        "hardRate": "HARD",
        "passRate": "37.76%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-paths-with-max-score/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-paths-with-max-score/solution",
        "problemsDesc": "<p>给你一个正方形字符数组&nbsp;<code>board</code>&nbsp;，你从数组最右下方的字符&nbsp;<code>&#39;S&#39;</code>&nbsp;出发。</p>\n\n<p>你的目标是到达数组最左上角的字符&nbsp;<code>&#39;E&#39;</code> ，数组剩余的部分为数字字符&nbsp;<code>1, 2, ..., 9</code>&nbsp;或者障碍 <code>&#39;X&#39;</code>。在每一步移动中，你可以向上、向左或者左上方移动，可以移动的前提是到达的格子没有障碍。</p>\n\n<p>一条路径的 「得分」 定义为：路径上所有数字的和。</p>\n\n<p>请你返回一个列表，包含两个整数：第一个整数是 「得分」 的最大值，第二个整数是得到最大得分的方案数，请把结果对&nbsp;<strong><code>10^9 + 7</code></strong> <strong>取余</strong>。</p>\n\n<p>如果没有任何路径可以到达终点，请返回&nbsp;<code>[0, 0]</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = [&quot;E23&quot;,&quot;2X2&quot;,&quot;12S&quot;]\n<strong>输出：</strong>[7,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = [&quot;E12&quot;,&quot;1X1&quot;,&quot;21S&quot;]\n<strong>输出：</strong>[4,2]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = [&quot;E11&quot;,&quot;XXX&quot;,&quot;11S&quot;]\n<strong>输出：</strong>[0,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= board.length == board[i].length &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1302.层数最深叶子节点的和",
        "hardRate": "MEDIUM",
        "passRate": "85.51%",
        "problemsUrl": "https://leetcode.cn/problems/deepest-leaves-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/deepest-leaves-sum/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点 <code>root</code> ，请你返回 <strong>层数最深的叶子节点的和</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/28/1483_ex1.png\" style=\"height: 265px; width: 273px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,5,null,6,7,null,null,null,null,8]\n<strong>输出：</strong>15\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]\n<strong>输出：</strong>19\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[1, 10<sup>4</sup>]</code> 之间。</li>\n\t<li><code>1 <= Node.val <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1303.求团队人数",
        "hardRate": "EASY",
        "passRate": "82.52%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-team-size/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-team-size/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1304.和为零的 N 个不同整数",
        "hardRate": "EASY",
        "passRate": "70.33%",
        "problemsUrl": "https://leetcode.cn/problems/find-n-unique-integers-sum-up-to-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/find-n-unique-integers-sum-up-to-zero/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>，请你返回 <strong>任意&nbsp;</strong>一个由 <code>n</code>&nbsp;个 <strong>各不相同&nbsp;</strong>的整数组成的数组，并且这 <code>n</code> 个数相加和为 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 5\n<strong>输出：</strong>[-7,-1,1,3,4]\n<strong>解释：</strong>这些数组也是正确的 [-5,-1,1,2,3]，[-3,-1,2,-2,4]。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 3\n<strong>输出：</strong>[-1,0,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>[0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1305.两棵二叉搜索树中的所有元素",
        "hardRate": "MEDIUM",
        "passRate": "78.06%",
        "problemsUrl": "https://leetcode.cn/problems/all-elements-in-two-binary-search-trees/",
        "solutionsUrl": "https://leetcode.cn/problems/all-elements-in-two-binary-search-trees/solution",
        "problemsDesc": "<p>给你&nbsp;<code>root1</code> 和 <code>root2</code>&nbsp;这两棵二叉搜索树。请你返回一个列表，其中包含&nbsp;<strong>两棵树&nbsp;</strong>中的所有整数并按 <strong>升序</strong> 排序。.</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/29/q2-e1.png\" /></p>\n\n<pre>\n<strong>输入：</strong>root1 = [2,1,4], root2 = [1,0,3]\n<strong>输出：</strong>[0,1,1,2,3,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/29/q2-e5-.png\" /></p>\n\n<pre>\n<strong>输入：</strong>root1 = [1,null,8], root2 = [8,1]\n<strong>输出：</strong>[1,1,8,8]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每棵树的节点数在&nbsp;<code>[0, 5000]</code> 范围内</li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1306.跳跃游戏 III",
        "hardRate": "MEDIUM",
        "passRate": "58.18%",
        "problemsUrl": "https://leetcode.cn/problems/jump-game-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/jump-game-iii/solution",
        "problemsDesc": "<p>这里有一个非负整数数组&nbsp;<code>arr</code>，你最开始位于该数组的起始下标&nbsp;<code>start</code>&nbsp;处。当你位于下标&nbsp;<code>i</code>&nbsp;处时，你可以跳到&nbsp;<code>i + arr[i]</code> 或者 <code>i - arr[i]</code>。</p>\n\n<p>请你判断自己是否能够跳到对应元素值为 0 的 <strong>任一</strong> 下标处。</p>\n\n<p>注意，不管是什么情况下，你都无法跳到数组之外。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [4,2,3,0,3,1,2], start = 5\n<strong>输出：</strong>true\n<strong>解释：</strong>\n到达值为 0 的下标 3 有以下可能方案： \n下标 5 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3 \n下标 5 -&gt; 下标 6 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [4,2,3,0,3,1,2], start = 0\n<strong>输出：</strong>true \n<strong>解释：\n</strong>到达值为 0 的下标 3 有以下可能方案： \n下标 0 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,0,2,1,2], start = 2\n<strong>输出：</strong>false\n<strong>解释：</strong>无法到达值为 0 的下标 1 处。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 5 * 10^4</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;&nbsp;arr.length</code></li>\n\t<li><code>0 &lt;= start &lt; arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1307.口算难题",
        "hardRate": "HARD",
        "passRate": "34.98%",
        "problemsUrl": "https://leetcode.cn/problems/verbal-arithmetic-puzzle/",
        "solutionsUrl": "https://leetcode.cn/problems/verbal-arithmetic-puzzle/solution",
        "problemsDesc": "<p>给你一个方程，左边用&nbsp;<code>words</code>&nbsp;表示，右边用&nbsp;<code>result</code> 表示。</p>\n\n<p>你需要根据以下规则检查方程是否可解：</p>\n\n<ul>\n\t<li>每个字符都会被解码成一位数字（0 - 9）。</li>\n\t<li>每对不同的字符必须映射到不同的数字。</li>\n\t<li>每个 <code>words[i]</code> 和 <code>result</code>&nbsp;都会被解码成一个没有前导零的数字。</li>\n\t<li>左侧数字之和（<code>words</code>）等于右侧数字（<code>result</code>）。&nbsp;</li>\n</ul>\n\n<p>如果方程可解，返回&nbsp;<code>True</code>，否则返回&nbsp;<code>False</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;SEND&quot;,&quot;MORE&quot;], result = &quot;MONEY&quot;\n<strong>输出：</strong>true\n<strong>解释：</strong>映射 &#39;S&#39;-&gt; 9, &#39;E&#39;-&gt;5, &#39;N&#39;-&gt;6, &#39;D&#39;-&gt;7, &#39;M&#39;-&gt;1, &#39;O&#39;-&gt;0, &#39;R&#39;-&gt;8, &#39;Y&#39;-&gt;&#39;2&#39;\n所以 &quot;SEND&quot; + &quot;MORE&quot; = &quot;MONEY&quot; ,  9567 + 1085 = 10652</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;SIX&quot;,&quot;SEVEN&quot;,&quot;SEVEN&quot;], result = &quot;TWENTY&quot;\n<strong>输出：</strong>true\n<strong>解释：</strong>映射 &#39;S&#39;-&gt; 6, &#39;I&#39;-&gt;5, &#39;X&#39;-&gt;0, &#39;E&#39;-&gt;8, &#39;V&#39;-&gt;7, &#39;N&#39;-&gt;2, &#39;T&#39;-&gt;1, &#39;W&#39;-&gt;&#39;3&#39;, &#39;Y&#39;-&gt;4\n所以 &quot;SIX&quot; + &quot;SEVEN&quot; + &quot;SEVEN&quot; = &quot;TWENTY&quot; ,  650 + 68782 + 68782 = 138214</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;THIS&quot;,&quot;IS&quot;,&quot;TOO&quot;], result = &quot;FUNNY&quot;\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;LEET&quot;,&quot;CODE&quot;], result = &quot;POINT&quot;\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= words.length &lt;= 5</code></li>\n\t<li><code>1 &lt;= words[i].length,&nbsp;results.length&nbsp;&lt;= 7</code></li>\n\t<li><code>words[i], result</code>&nbsp;只含有大写英文字母</li>\n\t<li>表达式中使用的不同字符数最大为&nbsp;10</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1308.不同性别每日分数总计",
        "hardRate": "MEDIUM",
        "passRate": "73.57%",
        "problemsUrl": "https://leetcode.cn/problems/running-total-for-different-genders/",
        "solutionsUrl": "https://leetcode.cn/problems/running-total-for-different-genders/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1309.解码字母到整数映射",
        "hardRate": "EASY",
        "passRate": "76.80%",
        "problemsUrl": "https://leetcode.cn/problems/decrypt-string-from-alphabet-to-integer-mapping/",
        "solutionsUrl": "https://leetcode.cn/problems/decrypt-string-from-alphabet-to-integer-mapping/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>，它由数字（<code>'0'</code> - <code>'9'</code>）和&nbsp;<code>'#'</code>&nbsp;组成。我们希望按下述规则将&nbsp;<code>s</code>&nbsp;映射为一些小写英文字符：</p>\n\n<ul>\n\t<li>字符（<code>'a'</code> - <code>'i'</code>）分别用（<code>'1'</code> -&nbsp;<code>'9'</code>）表示。</li>\n\t<li>字符（<code>'j'</code> - <code>'z'</code>）分别用（<code>'10#'</code>&nbsp;-&nbsp;<code>'26#'</code>）表示。&nbsp;</li>\n</ul>\n\n<p>返回映射之后形成的新字符串。</p>\n\n<p>题目数据保证映射始终唯一。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"10#11#12\"\n<strong>输出：</strong>\"jkab\"\n<strong>解释：</strong>\"j\" -&gt; \"10#\" , \"k\" -&gt; \"11#\" , \"a\" -&gt; \"1\" , \"b\" -&gt; \"2\".\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1326#\"\n<strong>输出：</strong>\"acz\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i]</code> 只包含数字（<code>'0'</code>-<code>'9'</code>）和&nbsp;<code>'#'</code>&nbsp;字符。</li>\n\t<li><code>s</code>&nbsp;是映射始终存在的有效字符串。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1310.子数组异或查询",
        "hardRate": "MEDIUM",
        "passRate": "72.02%",
        "problemsUrl": "https://leetcode.cn/problems/xor-queries-of-a-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/xor-queries-of-a-subarray/solution",
        "problemsDesc": "<p>有一个正整数数组 <code>arr</code>，现给你一个对应的查询数组 <code>queries</code>，其中 <code>queries[i] = [L<sub>i, </sub>R<sub>i</sub>]</code>。</p>\n\n<p>对于每个查询 <code>i</code>，请你计算从 <code>L<sub>i</sub></code> 到 <code>R<sub>i</sub></code> 的 <strong>XOR</strong> 值（即 <code>arr[L<sub>i</sub>] <strong>xor</strong> arr[L<sub>i</sub>+1] <strong>xor</strong> ... <strong>xor</strong> arr[R<sub>i</sub>]</code>）作为本次查询的结果。</p>\n\n<p>并返回一个包含给定查询 <code>queries</code> 所有结果的数组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]\n<strong>输出：</strong>[2,7,14,8] \n<strong>解释：</strong>\n数组中元素的二进制表示形式是：\n1 = 0001 \n3 = 0011 \n4 = 0100 \n8 = 1000 \n查询的 XOR 值为：\n[0,1] = 1 xor 3 = 2 \n[1,2] = 3 xor 4 = 7 \n[0,3] = 1 xor 3 xor 4 xor 8 = 14 \n[3,3] = 8\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]\n<strong>输出：</strong>[8,0,4,4]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= arr.length <= 3 * 10^4</code></li>\n\t<li><code>1 <= arr[i] <= 10^9</code></li>\n\t<li><code>1 <= queries.length <= 3 * 10^4</code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>0 <= queries[i][0] <= queries[i][1] < arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1311.获取你好友已观看的视频",
        "hardRate": "MEDIUM",
        "passRate": "40.05%",
        "problemsUrl": "https://leetcode.cn/problems/get-watched-videos-by-your-friends/",
        "solutionsUrl": "https://leetcode.cn/problems/get-watched-videos-by-your-friends/solution",
        "problemsDesc": "<p>有&nbsp;<code>n</code> 个人，每个人都有一个&nbsp; <code>0</code>&nbsp;到&nbsp;<code>n-1</code>&nbsp;的唯一&nbsp;<em>id</em>&nbsp;。</p>\n\n<p>给你数组 <code>watchedVideos</code>&nbsp; 和&nbsp;<code>friends</code>&nbsp;，其中&nbsp;<code>watchedVideos[i]</code>&nbsp; 和&nbsp;<code>friends[i]</code>&nbsp;分别表示&nbsp;<code>id = i</code>&nbsp;的人观看过的视频列表和他的好友列表。</p>\n\n<p>Level&nbsp;<strong>1</strong>&nbsp;的视频包含所有你好友观看过的视频，level&nbsp;<strong>2</strong>&nbsp;的视频包含所有你好友的好友观看过的视频，以此类推。一般的，Level 为 <strong>k</strong>&nbsp;的视频包含所有从你出发，最短距离为&nbsp;<strong>k</strong>&nbsp;的好友观看过的视频。</p>\n\n<p>给定你的&nbsp;<code>id</code>&nbsp; 和一个&nbsp;<code>level</code>&nbsp;值，请你找出所有指定 <code>level</code> 的视频，并将它们按观看频率升序返回。如果有频率相同的视频，请将它们按字母顺序从小到大排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/03/leetcode_friends_1.png\" style=\"height: 179px; width: 129px;\"></strong></p>\n\n<pre><strong>输入：</strong>watchedVideos = [[&quot;A&quot;,&quot;B&quot;],[&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1\n<strong>输出：</strong>[&quot;B&quot;,&quot;C&quot;] \n<strong>解释：</strong>\n你的 id 为 0（绿色），你的朋友包括（黄色）：\nid 为 1 -&gt; watchedVideos = [&quot;C&quot;]&nbsp;\nid 为 2 -&gt; watchedVideos = [&quot;B&quot;,&quot;C&quot;]&nbsp;\n你朋友观看过视频的频率为：\nB -&gt; 1&nbsp;\nC -&gt; 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/03/leetcode_friends_2.png\" style=\"height: 179px; width: 129px;\"></strong></p>\n\n<pre><strong>输入：</strong>watchedVideos = [[&quot;A&quot;,&quot;B&quot;],[&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2\n<strong>输出：</strong>[&quot;D&quot;]\n<strong>解释：</strong>\n你的 id 为 0（绿色），你朋友的朋友只有一个人，他的 id 为 3（黄色）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == watchedVideos.length ==&nbsp;friends.length</code></li>\n\t<li><code>2 &lt;= n&nbsp;&lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;watchedVideos[i].length &lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;watchedVideos[i][j].length &lt;= 8</code></li>\n\t<li><code>0 &lt;= friends[i].length &lt; n</code></li>\n\t<li><code>0 &lt;= friends[i][j]&nbsp;&lt; n</code></li>\n\t<li><code>0 &lt;= id &lt; n</code></li>\n\t<li><code>1 &lt;= level &lt; n</code></li>\n\t<li>如果&nbsp;<code>friends[i]</code> 包含&nbsp;<code>j</code>&nbsp;，那么&nbsp;<code>friends[j]</code> 包含&nbsp;<code>i</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1312.让字符串成为回文串的最少插入次数",
        "hardRate": "HARD",
        "passRate": "69.11%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，每一次操作你都可以在字符串的任意位置插入任意字符。</p>\n\n<p>请你返回让&nbsp;<code>s</code>&nbsp;成为回文串的&nbsp;<strong>最少操作次数</strong>&nbsp;。</p>\n\n<p>「回文串」是正读和反读都相同的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"zzazz\"\n<strong>输出：</strong>0\n<strong>解释：</strong>字符串 \"zzazz\" 已经是回文串了，所以不需要做任何插入操作。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"mbadm\"\n<strong>输出：</strong>2\n<strong>解释：</strong>字符串可变为 \"mbdadbm\" 或者 \"mdbabdm\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"leetcode\"\n<strong>输出：</strong>5\n<strong>解释：</strong>插入 5 个字符后字符串变为 \"leetcodocteel\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>s</code>&nbsp;中所有字符都是小写字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1313.解压缩编码列表",
        "hardRate": "EASY",
        "passRate": "83.26%",
        "problemsUrl": "https://leetcode.cn/problems/decompress-run-length-encoded-list/",
        "solutionsUrl": "https://leetcode.cn/problems/decompress-run-length-encoded-list/solution",
        "problemsDesc": "<p>给你一个以行程长度编码压缩的整数列表 <code>nums</code> 。</p>\n\n<p>考虑每对相邻的两个元素 <code>[freq, val] = [nums[2*i], nums[2*i+1]]</code> （其中 <code>i >= 0</code> ），每一对都表示解压后子列表中有 <code>freq</code> 个值为 <code>val</code> 的元素，你需要从左到右连接所有子列表以生成解压后的列表。</p>\n\n<p>请你返回解压后的列表。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>[2,4,4,4]\n<strong>解释：</strong>第一对 [1,2] 代表着 2 的出现频次为 1，所以生成数组 [2]。\n第二对 [3,4] 代表着 4 的出现频次为 3，所以生成数组 [4,4,4]。\n最后将它们串联到一起 [2] + [4,4,4] = [2,4,4,4]。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,2,3]\n<strong>输出：</strong>[1,3,3]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= nums.length <= 100</code></li>\n\t<li><code>nums.length % 2 == 0</code></li>\n\t<li><code>1 <= nums[i] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1314.矩阵区域和",
        "hardRate": "MEDIUM",
        "passRate": "75.54%",
        "problemsUrl": "https://leetcode.cn/problems/matrix-block-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/matrix-block-sum/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的矩阵 <code>mat</code> 和一个整数 <code>k</code> ，请你返回一个矩阵 <code>answer</code> ，其中每个 <code>answer[i][j]</code> 是所有满足下述条件的元素 <code>mat[r][c]</code> 的和： </p>\n\n<ul>\n\t<li><code>i - k <= r <= i + k, </code></li>\n\t<li><code>j - k <= c <= j + k</code> 且</li>\n\t<li><code>(r, c)</code> 在矩阵内。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1\n<strong>输出：</strong>[[12,21,16],[27,45,33],[24,39,28]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2\n<strong>输出：</strong>[[45,45,45],[45,45,45],[45,45,45]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 <= m, n, k <= 100</code></li>\n\t<li><code>1 <= mat[i][j] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1315.祖父节点值为偶数的节点和",
        "hardRate": "MEDIUM",
        "passRate": "81.61%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-nodes-with-even-valued-grandparent/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-nodes-with-even-valued-grandparent/solution",
        "problemsDesc": "<p>给你一棵二叉树，请你返回满足以下条件的所有节点的值之和：</p>\n\n<ul>\n\t<li>该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）</li>\n</ul>\n\n<p>如果不存在祖父节点值为偶数的节点，那么返回&nbsp;<code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/10/1473_ex1.png\" style=\"height: 214px; width: 350px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]\n<strong>输出：</strong>18\n<strong>解释：</strong>图中红色节点的祖父节点的值为偶数，蓝色节点为这些红色节点的祖父节点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在&nbsp;<code>1</code> 到&nbsp;<code>10^4</code>&nbsp;之间。</li>\n\t<li>每个节点的值在&nbsp;<code>1</code> 到&nbsp;<code>100</code> 之间。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1316.不同的循环子字符串",
        "hardRate": "HARD",
        "passRate": "48.35%",
        "problemsUrl": "https://leetcode.cn/problems/distinct-echo-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/distinct-echo-substrings/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>text</code> ，请你返回满足下述条件的&nbsp;<strong>不同</strong> 非空子字符串的数目：</p>\n\n<ul>\n\t<li>可以写成某个字符串与其自身相连接的形式（即，可以写为 <code>a&nbsp;+ a</code>，其中 <code>a</code> 是某个字符串）。</li>\n</ul>\n\n<p>例如，<code>abcabc</code>&nbsp;就是&nbsp;<code>abc</code>&nbsp;和它自身连接形成的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;abcabcabc&quot;\n<strong>输出：</strong>3\n<strong>解释：</strong>3 个子字符串分别为 &quot;abcabc&quot;，&quot;bcabca&quot; 和 &quot;cabcab&quot; 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;leetcodeleetcode&quot;\n<strong>输出：</strong>2\n<strong>解释：</strong>2 个子字符串为 &quot;ee&quot; 和 &quot;leetcodeleetcode&quot; 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 2000</code></li>\n\t<li><code>text</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1317.将整数转换为两个无零整数的和",
        "hardRate": "EASY",
        "passRate": "61.87%",
        "problemsUrl": "https://leetcode.cn/problems/convert-integer-to-the-sum-of-two-no-zero-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-integer-to-the-sum-of-two-no-zero-integers/solution",
        "problemsDesc": "<p>「无零整数」是十进制表示中 <strong>不含任何 0</strong>&nbsp;的正整数。</p>\n\n<p>给你一个整数&nbsp;<code>n</code>，请你返回一个 <strong>由两个整数组成的列表</strong> <code>[A, B]</code>，满足：</p>\n\n<ul>\n\t<li><code>A</code> 和 <code>B</code>&nbsp;都是无零整数</li>\n\t<li><code>A + B = n</code></li>\n</ul>\n\n<p>题目数据保证至少有一个有效的解决方案。</p>\n\n<p>如果存在多个有效解决方案，你可以返回其中任意一个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>[1,1]\n<strong>解释：</strong>A = 1, B = 1. A + B = n 并且 A 和 B 的十进制表示形式都不包含任何 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 11\n<strong>输出：</strong>[2,9]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 10000\n<strong>输出：</strong>[1,9999]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 69\n<strong>输出：</strong>[1,68]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>n = 1010\n<strong>输出：</strong>[11,999]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1318.或运算的最小翻转次数",
        "hardRate": "MEDIUM",
        "passRate": "66.72%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-flips-to-make-a-or-b-equal-to-c/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-flips-to-make-a-or-b-equal-to-c/solution",
        "problemsDesc": "<p>给你三个正整数&nbsp;<code>a</code>、<code>b</code> 和 <code>c</code>。</p>\n\n<p>你可以对 <code>a</code> 和 <code>b</code>&nbsp;的二进制表示进行位翻转操作，返回能够使按位或运算&nbsp; &nbsp;<code>a</code> OR <code>b</code> == <code>c</code>&nbsp;&nbsp;成立的最小翻转次数。</p>\n\n<p>「位翻转操作」是指将一个数的二进制表示任何单个位上的 1 变成 0 或者 0 变成 1 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_3_1676.png\" style=\"height: 87px; width: 260px;\"></p>\n\n<pre><strong>输入：</strong>a = 2, b = 6, c = 5\n<strong>输出：</strong>3\n<strong>解释：</strong>翻转后 a = 1 , b = 4 , c = 5 使得 <code>a</code> OR <code>b</code> == <code>c</code></pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>a = 4, b = 2, c = 7\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>a = 1, b = 2, c = 3\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a &lt;= 10^9</code></li>\n\t<li><code>1 &lt;= b&nbsp;&lt;= 10^9</code></li>\n\t<li><code>1 &lt;= c&nbsp;&lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1319.连通网络的操作次数",
        "hardRate": "MEDIUM",
        "passRate": "62.35%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-operations-to-make-network-connected/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-operations-to-make-network-connected/solution",
        "problemsDesc": "<p>用以太网线缆将&nbsp;<code>n</code>&nbsp;台计算机连接成一个网络，计算机的编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n-1</code>。线缆用&nbsp;<code>connections</code>&nbsp;表示，其中&nbsp;<code>connections[i] = [a, b]</code>&nbsp;连接了计算机&nbsp;<code>a</code>&nbsp;和&nbsp;<code>b</code>。</p>\n\n<p>网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。</p>\n\n<p>给你这个计算机网络的初始布线&nbsp;<code>connections</code>，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回&nbsp;-1 。&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_1_1677.png\" style=\"height: 167px; width: 570px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 4, connections = [[0,1],[0,2],[1,2]]\n<strong>输出：</strong>1\n<strong>解释：</strong>拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_2_1677.png\" style=\"height: 175px; width: 660px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>线缆数量不足。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 5, connections = [[0,1],[0,2],[3,4],[2,3]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= connections.length &lt;= min(n*(n-1)/2, 10^5)</code></li>\n\t<li><code>connections[i].length == 2</code></li>\n\t<li><code>0 &lt;= connections[i][0], connections[i][1]&nbsp;&lt; n</code></li>\n\t<li><code>connections[i][0] != connections[i][1]</code></li>\n\t<li>没有重复的连接。</li>\n\t<li>两台计算机不会通过多条线缆连接。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1320.二指输入的的最小距离",
        "hardRate": "HARD",
        "passRate": "60.67%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-distance-to-type-a-word-using-two-fingers/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-distance-to-type-a-word-using-two-fingers/solution",
        "problemsDesc": "<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/leetcode_keyboard.png\" /></p>\n\n<p>二指输入法定制键盘在 <strong>X-Y</strong> 平面上的布局如上图所示，其中每个大写英文字母都位于某个坐标处。</p>\n\n<ul>\n\t<li>例如字母&nbsp;<strong>A</strong>&nbsp;位于坐标&nbsp;<strong>(0,0)</strong>，字母&nbsp;<strong>B</strong>&nbsp;位于坐标&nbsp;<strong>(0,1)</strong>，字母&nbsp;<strong>P</strong>&nbsp;位于坐标&nbsp;<strong>(2,3)</strong>&nbsp;且字母 <strong>Z</strong>&nbsp;位于坐标&nbsp;<strong>(4,1)</strong>。</li>\n</ul>\n\n<p>给你一个待输入字符串&nbsp;<code>word</code>，请你计算并返回在仅使用两根手指的情况下，键入该字符串需要的最小移动总距离。</p>\n\n<p>坐标<code>&nbsp;<strong>(x<sub>1</sub>,y<sub>1</sub>)</strong> </code>和 <code><strong>(x<sub>2</sub>,y<sub>2</sub>)</strong></code> 之间的 <strong>距离</strong> 是&nbsp;<code><strong>|x<sub>1</sub> - x<sub>2</sub>| + |y<sub>1</sub> - y<sub>2</sub>|</strong></code>。&nbsp;</p>\n\n<p><strong>注意</strong>，两根手指的起始位置是零代价的，不计入移动总距离。你的两根手指的起始位置也不必从首字母或者前两个字母开始。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"CAKE\"\n<strong>输出：</strong>3\n<strong>解释： \n</strong>使用两根手指输入 \"CAKE\" 的最佳方案之一是： \n手指 1 在字母 'C' 上 -&gt; 移动距离 = 0 \n手指 1 在字母 'A' 上 -&gt; 移动距离 = 从字母 'C' 到字母 'A' 的距离 = 2 \n手指 2 在字母 'K' 上 -&gt; 移动距离 = 0 \n手指 2 在字母 'E' 上 -&gt; 移动距离 = 从字母 'K' 到字母 'E' 的距离  = 1 \n总距离 = 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"HAPPY\"\n<strong>输出：</strong>6\n<strong>解释： </strong>\n使用两根手指输入 \"HAPPY\" 的最佳方案之一是：\n手指 1 在字母 'H' 上 -&gt; 移动距离 = 0\n手指 1 在字母 'A' 上 -&gt; 移动距离 = 从字母 'H' 到字母 'A' 的距离 = 2\n手指 2 在字母 'P' 上 -&gt; 移动距离 = 0\n手指 2 在字母 'P' 上 -&gt; 移动距离 = 从字母 'P' 到字母 'P' 的距离 = 0\n手指 1 在字母 'Y' 上 -&gt; 移动距离 = 从字母 'A' 到字母 'Y' 的距离 = 4\n总距离 = 6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= word.length &lt;= 300</code></li>\n\t<li>每个 <code>word[i]</code>&nbsp;都是一个大写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1321.餐馆营业额变化增长",
        "hardRate": "MEDIUM",
        "passRate": "61.84%",
        "problemsUrl": "https://leetcode.cn/problems/restaurant-growth/",
        "solutionsUrl": "https://leetcode.cn/problems/restaurant-growth/solution",
        "problemsDesc": "<p>表: <code>Customer</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| customer_id   | int     |\n| name          | varchar |\n| visited_on    | date    |\n| amount        | int     |\n+---------------+---------+\n(customer_id, visited_on) 是该表的主键。\n该表包含一家餐馆的顾客交易数据。\nvisited_on 表示 (customer_id) 的顾客在 visited_on 那天访问了餐馆。\namount 是一个顾客某一天的消费总额。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>你是餐馆的老板，现在你想分析一下可能的营业额变化增长（每天至少有一位顾客）。</p>\n\n<p>写一条 SQL 查询计算以 7 天（某日期 + 该日期前的 6 天）为一个时间段的顾客消费平均值。<code>average_amount</code>&nbsp;要 <strong>保留两位小数。</strong></p>\n\n<p>查询结果按 <code>visited_on</code> 排序。</p>\n\n<p>查询结果格式的例子如下。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nCustomer 表:\n+-------------+--------------+--------------+-------------+\n| customer_id | name         | visited_on   | amount      |\n+-------------+--------------+--------------+-------------+\n| 1           | Jhon         | 2019-01-01   | 100         |\n| 2           | Daniel       | 2019-01-02   | 110         |\n| 3           | Jade         | 2019-01-03   | 120         |\n| 4           | Khaled       | 2019-01-04   | 130         |\n| 5           | Winston      | 2019-01-05   | 110         | \n| 6           | Elvis        | 2019-01-06   | 140         | \n| 7           | Anna         | 2019-01-07   | 150         |\n| 8           | Maria        | 2019-01-08   | 80          |\n| 9           | Jaze         | 2019-01-09   | 110         | \n| 1           | Jhon         | 2019-01-10   | 130         | \n| 3           | Jade         | 2019-01-10   | 150         | \n+-------------+--------------+--------------+-------------+\n<strong>输出：</strong>\n+--------------+--------------+----------------+\n| visited_on   | amount       | average_amount |\n+--------------+--------------+----------------+\n| 2019-01-07   | 860          | 122.86         |\n| 2019-01-08   | 840          | 120            |\n| 2019-01-09   | 840          | 120            |\n| 2019-01-10   | 1000         | 142.86         |\n+--------------+--------------+----------------+\n<strong>解释：</strong>\n第一个七天消费平均值从 2019-01-01 到 2019-01-07 是restaurant-growth/restaurant-growth/ (100 + 110 + 120 + 130 + 110 + 140 + 150)/7 = 122.86\n第二个七天消费平均值从 2019-01-02 到 2019-01-08 是 (110 + 120 + 130 + 110 + 140 + 150 + 80)/7 = 120\n第三个七天消费平均值从 2019-01-03 到 2019-01-09 是 (120 + 130 + 110 + 140 + 150 + 80 + 110)/7 = 120\n第四个七天消费平均值从 2019-01-04 到 2019-01-10 是 (130 + 110 + 140 + 150 + 80 + 110 + 130 + 150)/7 = 142.86</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1322.广告效果",
        "hardRate": "EASY",
        "passRate": "59.55%",
        "problemsUrl": "https://leetcode.cn/problems/ads-performance/",
        "solutionsUrl": "https://leetcode.cn/problems/ads-performance/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1323.6 和 9 组成的最大数字",
        "hardRate": "EASY",
        "passRate": "74.97%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-69-number/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-69-number/solution",
        "problemsDesc": "<p>给你一个仅由数字 6 和 9 组成的正整数&nbsp;<code>num</code>。</p>\n\n<p>你最多只能翻转一位数字，将 6 变成&nbsp;9，或者把&nbsp;9 变成&nbsp;6 。</p>\n\n<p>请返回你可以得到的最大数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 9669\n<strong>输出：</strong>9969\n<strong>解释：</strong>\n改变第一位数字可以得到 6669 。\n改变第二位数字可以得到 9969 。\n改变第三位数字可以得到 9699 。\n改变第四位数字可以得到 9666 。\n其中最大的数字是 9969 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 9996\n<strong>输出：</strong>9999\n<strong>解释：</strong>将最后一位从 6 变到 9，其结果 9999 是最大的数。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = 9999\n<strong>输出：</strong>9999\n<strong>解释：</strong>无需改变就已经是最大的数字了。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10^4</code></li>\n\t<li><code>num</code>&nbsp;每一位上的数字都是 6 或者&nbsp;9 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1324.竖直打印单词",
        "hardRate": "MEDIUM",
        "passRate": "59.24%",
        "problemsUrl": "https://leetcode.cn/problems/print-words-vertically/",
        "solutionsUrl": "https://leetcode.cn/problems/print-words-vertically/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>。请你按照单词在 <code>s</code> 中的出现顺序将它们全部竖直返回。<br>\n单词应该以字符串列表的形式返回，必要时用空格补位，但输出尾部的空格需要删除（不允许尾随空格）。<br>\n每个单词只能放在一列上，每一列中也只能有一个单词。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;HOW ARE YOU&quot;\n<strong>输出：</strong>[&quot;HAY&quot;,&quot;ORO&quot;,&quot;WEU&quot;]\n<strong>解释：</strong>每个单词都应该竖直打印。 \n &quot;HAY&quot;\n&nbsp;&quot;ORO&quot;\n&nbsp;&quot;WEU&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;TO BE OR NOT TO BE&quot;\n<strong>输出：</strong>[&quot;TBONTB&quot;,&quot;OEROOE&quot;,&quot;   T&quot;]\n<strong>解释：</strong>题目允许使用空格补位，但不允许输出末尾出现空格。\n&quot;TBONTB&quot;\n&quot;OEROOE&quot;\n&quot;   T&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;CONTEST IS COMING&quot;\n<strong>输出：</strong>[&quot;CIC&quot;,&quot;OSO&quot;,&quot;N M&quot;,&quot;T I&quot;,&quot;E N&quot;,&quot;S G&quot;,&quot;T&quot;]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 200</code></li>\n\t<li><code>s</code>&nbsp;仅含大写英文字母。</li>\n\t<li>题目数据保证两个单词之间只有一个空格。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1325.删除给定值的叶子节点",
        "hardRate": "MEDIUM",
        "passRate": "73.30%",
        "problemsUrl": "https://leetcode.cn/problems/delete-leaves-with-a-given-value/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-leaves-with-a-given-value/solution",
        "problemsDesc": "<p>给你一棵以&nbsp;<code>root</code>&nbsp;为根的二叉树和一个整数&nbsp;<code>target</code>&nbsp;，请你删除所有值为&nbsp;<code>target</code> 的&nbsp;<strong>叶子节点</strong> 。</p>\n\n<p>注意，一旦删除值为&nbsp;<code>target</code>&nbsp;的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是&nbsp;<code>target</code> ，那么这个节点也应该被删除。</p>\n\n<p>也就是说，你需要重复此过程直到不能继续删除。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/16/sample_1_1684.png\" style=\"height: 120px; width: 550px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [1,2,3,2,null,2,4], target = 2\n<strong>输出：</strong>[1,null,3,null,4]\n<strong>解释：\n</strong>上面左边的图中，绿色节点为叶子节点，且它们的值与 target 相同（同为 2 ），它们会被删除，得到中间的图。\n有一个新的节点变成了叶子节点且它的值与 target 相同，所以将再次进行删除，从而得到最右边的图。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/16/sample_2_1684.png\" style=\"height: 120px; width: 300px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [1,3,3,3,2], target = 3\n<strong>输出：</strong>[1,3,null,null,2]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/16/sample_3_1684.png\" style=\"width: 450px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [1,2,null,2,null,2], target = 2\n<strong>输出：</strong>[1]\n<strong>解释：</strong>每一步都删除一个绿色的叶子节点（值为 2）。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>root = [1,1,1], target = 1\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>root = [1,2,3], target = 1\n<strong>输出：</strong>[1,2,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target&nbsp;&lt;= 1000</code></li>\n\t<li>每一棵树最多有 <code>3000</code> 个节点。</li>\n\t<li>每一个节点值的范围是&nbsp;<code>[1, 1000]</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1326.灌溉花园的最少水龙头数目",
        "hardRate": "HARD",
        "passRate": "54.17%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/solution",
        "problemsDesc": "<p>在 x 轴上有一个一维的花园。花园长度为&nbsp;<code>n</code>，从点&nbsp;<code>0</code>&nbsp;开始，到点&nbsp;<code>n</code>&nbsp;结束。</p>\n\n<p>花园里总共有&nbsp;<code>n + 1</code> 个水龙头，分别位于&nbsp;<code>[0, 1, ..., n]</code> 。</p>\n\n<p>给你一个整数&nbsp;<code>n</code>&nbsp;和一个长度为&nbsp;<code>n + 1</code> 的整数数组&nbsp;<code>ranges</code>&nbsp;，其中&nbsp;<code>ranges[i]</code> （下标从 0 开始）表示：如果打开点&nbsp;<code>i</code>&nbsp;处的水龙头，可以灌溉的区域为&nbsp;<code>[i -&nbsp; ranges[i], i + ranges[i]]</code>&nbsp;。</p>\n\n<p>请你返回可以灌溉整个花园的&nbsp;<strong>最少水龙头数目</strong>&nbsp;。如果花园始终存在无法灌溉到的地方，请你返回&nbsp;<strong>-1</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/19/1685_example_1.png\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 5, ranges = [3,4,1,1,0,0]\n<strong>输出：</strong>1\n<strong>解释：\n</strong>点 0 处的水龙头可以灌溉区间 [-3,3]\n点 1 处的水龙头可以灌溉区间 [-3,5]\n点 2 处的水龙头可以灌溉区间 [1,3]\n点 3 处的水龙头可以灌溉区间 [2,4]\n点 4 处的水龙头可以灌溉区间 [4,4]\n点 5 处的水龙头可以灌溉区间 [5,5]\n只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, ranges = [0,0,0,0]\n<strong>输出：</strong>-1\n<strong>解释：</strong>即使打开所有水龙头，你也无法灌溉整个花园。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>ranges.length == n + 1</code></li>\n\t<li><code>0 &lt;= ranges[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1327.列出指定时间段内所有的下单产品",
        "hardRate": "EASY",
        "passRate": "69.48%",
        "problemsUrl": "https://leetcode.cn/problems/list-the-products-ordered-in-a-period/",
        "solutionsUrl": "https://leetcode.cn/problems/list-the-products-ordered-in-a-period/solution",
        "problemsDesc": "<p>表: <code>Products</code></p>\n\n<pre>\n+------------------+---------+\n| Column Name      | Type    |\n+------------------+---------+\n| product_id       | int     |\n| product_name     | varchar |\n| product_category | varchar |\n+------------------+---------+\nproduct_id 是该表主键。\n该表包含该公司产品的数据。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>表: <code>Orders</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| product_id    | int     |\n| order_date    | date    |\n| unit          | int     |\n+---------------+---------+\n该表无主键，可能包含重复行。\nproduct_id 是表单 Products 的外键。\nunit 是在日期 order_date 内下单产品的数目。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一个 SQL 语句，要求获取在 2020 年 2 月份下单的数量不少于 100 的产品的名字和数目。</p>\n\n<p>返回结果表单的 <strong>顺序无要求 </strong>。</p>\n\n<p>查询结果的格式如下。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nProducts 表:\n+-------------+-----------------------+------------------+\n| product_id  | product_name          | product_category |\n+-------------+-----------------------+------------------+\n| 1           | Leetcode Solutions    | Book             |\n| 2           | Jewels of Stringology | Book             |\n| 3           | HP                    | Laptop           |\n| 4           | Lenovo                | Laptop           |\n| 5           | Leetcode Kit          | T-shirt          |\n+-------------+-----------------------+------------------+\nOrders 表:\n+--------------+--------------+----------+\n| product_id   | order_date   | unit     |\n+--------------+--------------+----------+\n| 1            | 2020-02-05   | 60       |\n| 1            | 2020-02-10   | 70       |\n| 2            | 2020-01-18   | 30       |\n| 2            | 2020-02-11   | 80       |\n| 3            | 2020-02-17   | 2        |\n| 3            | 2020-02-24   | 3        |\n| 4            | 2020-03-01   | 20       |\n| 4            | 2020-03-04   | 30       |\n| 4            | 2020-03-04   | 60       |\n| 5            | 2020-02-25   | 50       |\n| 5            | 2020-02-27   | 50       |\n| 5            | 2020-03-01   | 50       |\n+--------------+--------------+----------+\n<strong>输出：</strong>\n+--------------------+---------+\n| product_name       | unit    |\n+--------------------+---------+\n| Leetcode Solutions | 130     |\n| Leetcode Kit       | 100     |\n+--------------------+---------+\n<strong>解释：</strong>\n2020 年 2 月份下单 product_id = 1 的产品的数目总和为 (60 + 70) = 130 。\n2020 年 2 月份下单 product_id = 2 的产品的数目总和为 80 。\n2020 年 2 月份下单 product_id = 3 的产品的数目总和为 (2 + 3) = 5 。\n2020 年 2 月份 product_id = 4 的产品并没有下单。\n2020 年 2 月份下单 product_id = 5 的产品的数目总和为 (50 + 50) = 100 。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1328.破坏回文串",
        "hardRate": "MEDIUM",
        "passRate": "47.06%",
        "problemsUrl": "https://leetcode.cn/problems/break-a-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/break-a-palindrome/solution",
        "problemsDesc": "<p>给你一个由小写英文字母组成的回文字符串&nbsp;<code>palindrome</code> ，请你将其中&nbsp;<strong>一个</strong> 字符用任意小写英文字母替换，使得结果字符串的 <strong>字典序最小</strong> ，且&nbsp;<strong>不是</strong>&nbsp;回文串。</p>\n\n<p>请你返回结果字符串。如果无法做到，则返回一个 <strong>空串</strong> 。</p>\n\n<p>如果两个字符串长度相同，那么字符串 <code>a</code> 字典序比字符串 <code>b</code> 小可以这样定义：在 <code>a</code> 和 <code>b</code> 出现不同的第一个位置上，字符串 <code>a</code> 中的字符严格小于 <code>b</code> 中的对应字符。例如，<code>\"abcc”</code> 字典序比 <code>\"abcd\"</code> 小，因为不同的第一个位置是在第四个字符，显然 <code>'c'</code> 比 <code>'d'</code> 小。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>palindrome = \"abccba\"\n<strong>输出：</strong>\"aaccba\"\n<strong>解释：</strong>存在多种方法可以使 \"abccba\" 不是回文，例如 \"<em><strong>z</strong></em>bccba\", \"a<em><strong>a</strong></em>ccba\", 和 \"ab<em><strong>a</strong></em>cba\" 。\n在所有方法中，\"aaccba\" 的字典序最小。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>palindrome = \"a\"\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>不存在替换一个字符使 \"a\" 变成非回文的方法，所以返回空字符串。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= palindrome.length &lt;= 1000</code></li>\n\t<li><code>palindrome</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1329.将矩阵按对角线排序",
        "hardRate": "MEDIUM",
        "passRate": "77.83%",
        "problemsUrl": "https://leetcode.cn/problems/sort-the-matrix-diagonally/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-the-matrix-diagonally/solution",
        "problemsDesc": "<p><strong>矩阵对角线</strong> 是一条从矩阵最上面行或者最左侧列中的某个元素开始的对角线，沿右下方向一直到矩阵末尾的元素。例如，矩阵 <code>mat</code> 有 <code>6</code> 行 <code>3</code> 列，从 <code>mat[2][0]</code> 开始的 <strong>矩阵对角线</strong> 将会经过 <code>mat[2][0]</code>、<code>mat[3][1]</code> 和 <code>mat[4][2]</code> 。</p>\n\n<p>给你一个 <code>m * n</code> 的整数矩阵 <code>mat</code> ，请你将同一条 <strong>矩阵对角线 </strong>上的元素按升序排序后，返回排好序的矩阵。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/25/1482_example_1_2.png\" style=\"height: 198px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]\n<strong>输出：</strong>[[1,1,1,1],[1,2,2,2],[1,2,3,3]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]\n<strong>输出：</strong>[[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 <= m, n <= 100</code></li>\n\t<li><code>1 <= mat[i][j] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1330.翻转子数组得到最大的数组值",
        "hardRate": "HARD",
        "passRate": "57.71%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-subarray-to-maximize-array-value/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-subarray-to-maximize-array-value/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code> 。「数组值」定义为所有满足&nbsp;<code>0 &lt;= i &lt; nums.length-1</code>&nbsp;的&nbsp;<code>|nums[i]-nums[i+1]|</code>&nbsp;的和。</p>\n\n<p>你可以选择给定数组的任意子数组，并将该子数组翻转。但你只能执行这个操作&nbsp;<strong>一次</strong> 。</p>\n\n<p>请你找到可行的最大 <strong>数组值&nbsp;</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,3,1,5,4]\n<strong>输出：</strong>10\n<strong>解释：</strong>通过翻转子数组 [3,1,5] ，数组变成 [2,5,1,3,4] ，数组值为 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,4,9,24,2,1,10]\n<strong>输出：</strong>68\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3*10^4</code></li>\n\t<li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1331.数组序号转换",
        "hardRate": "EASY",
        "passRate": "60.38%",
        "problemsUrl": "https://leetcode.cn/problems/rank-transform-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/rank-transform-of-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code> ，请你将数组中的每个元素替换为它们排序后的序号。</p>\n\n<p>序号代表了一个元素有多大。序号编号的规则如下：</p>\n\n<ul>\n\t<li>序号从 1 开始编号。</li>\n\t<li>一个元素越大，那么序号越大。如果两个元素相等，那么它们的序号相同。</li>\n\t<li>每个数字的序号都应该尽可能地小。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [40,10,20,30]\n<strong>输出：</strong>[4,1,2,3]\n<strong>解释：</strong>40 是最大的元素。 10 是最小的元素。 20 是第二小的数字。 30 是第三小的数字。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [100,100,100]\n<strong>输出：</strong>[1,1,1]\n<strong>解释：</strong>所有元素有相同的序号。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [37,12,28,9,100,56,80,5,12]\n<strong>输出：</strong>[5,3,4,2,8,6,7,1,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1332.删除回文子序列",
        "hardRate": "EASY",
        "passRate": "77.75%",
        "problemsUrl": "https://leetcode.cn/problems/remove-palindromic-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-palindromic-subsequences/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>，它仅由字母&nbsp;<code>'a'</code> 和 <code>'b'</code>&nbsp;组成。每一次删除操作都可以从 <code>s</code> 中删除一个回文 <strong>子序列</strong>。</p>\n\n<p>返回删除给定字符串中所有字符（字符串为空）的最小删除次数。</p>\n\n<p>「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。</p>\n\n<p>「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ababa\"\n<strong>输出：</strong>1\n<strong>解释：</strong>字符串本身就是回文序列，只需要删除一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abb\"\n<strong>输出：</strong>2\n<strong>解释：</strong>\"<strong>a</strong>bb\" -&gt; \"<strong>bb</strong>\" -&gt; \"\". \n先删除回文子序列 \"a\"，然后再删除 \"bb\"。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"baabb\"\n<strong>输出：</strong>2\n<strong>解释：</strong>\"<strong>baa</strong>b<strong>b</strong>\" -&gt; \"b\" -&gt; \"\". \n先删除回文子序列 \"baab\"，然后再删除 \"b\"。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> 仅包含字母&nbsp;<code>'a'</code>&nbsp; 和 <code>'b'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1333.餐厅过滤器",
        "hardRate": "MEDIUM",
        "passRate": "56.71%",
        "problemsUrl": "https://leetcode.cn/problems/filter-restaurants-by-vegan-friendly-price-and-distance/",
        "solutionsUrl": "https://leetcode.cn/problems/filter-restaurants-by-vegan-friendly-price-and-distance/solution",
        "problemsDesc": "<p>给你一个餐馆信息数组&nbsp;<code>restaurants</code>，其中&nbsp;&nbsp;<code>restaurants[i] = [id<sub>i</sub>, rating<sub>i</sub>, veganFriendly<sub>i</sub>, price<sub>i</sub>, distance<sub>i</sub>]</code>。你必须使用以下三个过滤器来过滤这些餐馆信息。</p>\n\n<p>其中素食者友好过滤器&nbsp;<code>veganFriendly</code>&nbsp;的值可以为 <code>true</code> 或者 <code>false</code>，如果为 <em>true</em>&nbsp;就意味着你应该只包括&nbsp;<code>veganFriendly<sub>i</sub></code>&nbsp;为 true 的餐馆，为&nbsp;<em>false</em>&nbsp;则意味着可以包括任何餐馆。此外，我们还有最大价格&nbsp;<code>maxPrice</code>&nbsp;和最大距离&nbsp;<code>maxDistance</code>&nbsp;两个过滤器，它们分别考虑餐厅的价格因素和距离因素的最大值。</p>\n\n<p>过滤后返回餐馆的 <strong><em>id</em></strong>，按照 <em><strong>rating</strong></em>&nbsp;从高到低排序。如果 <em><strong>rating</strong></em> 相同，那么按 <em><strong>id</strong></em> 从高到低排序。简单起见，&nbsp;<code>veganFriendly<sub>i</sub></code> 和 <code>veganFriendly</code>&nbsp;为&nbsp;<em>true</em>&nbsp;时取值为 <em>1</em>，为 <em>false</em> 时，取值为&nbsp;<em>0 。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, maxDistance = 10\n<strong>输出：</strong>[3,1,5] \n<strong>解释： \n</strong>这些餐馆为：\n餐馆 1 [id=1, rating=4, veganFriendly=1, price=40, distance=10]\n餐馆 2 [id=2, rating=8, veganFriendly=0, price=50, distance=5]\n餐馆 3 [id=3, rating=8, veganFriendly=1, price=30, distance=4]\n餐馆 4 [id=4, rating=10, veganFriendly=0, price=10, distance=3]\n餐馆 5 [id=5, rating=1, veganFriendly=1, price=15, distance=1] \n在按照 veganFriendly = 1, maxPrice = 50 和 maxDistance = 10 进行过滤后，我们得到了餐馆 3, 餐馆 1 和 餐馆 5（按评分从高到低排序）。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 50, maxDistance = 10\n<strong>输出：</strong>[4,3,2,1,5]\n<strong>解释：</strong>餐馆与示例 1 相同，但在 veganFriendly = 0 的过滤条件下，应该考虑所有餐馆。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 30, maxDistance = 3\n<strong>输出：</strong>[4,5]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;restaurants.length &lt;= 10^4</code></li>\n\t<li><code>restaurants[i].length == 5</code></li>\n\t<li><code>1 &lt;=&nbsp;id<sub>i</sub>, rating<sub>i</sub>, price<sub>i</sub>, distance<sub>i </sub>&lt;= 10^5</code></li>\n\t<li><code>1 &lt;=&nbsp;maxPrice,&nbsp;maxDistance &lt;= 10^5</code></li>\n\t<li><code>veganFriendly<sub>i</sub></code> 和&nbsp;<code>veganFriendly</code>&nbsp;的值为 0 或 1 。</li>\n\t<li>所有 <code>id<sub>i</sub></code> 各不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1334.阈值距离内邻居最少的城市",
        "hardRate": "MEDIUM",
        "passRate": "52.74%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/solution",
        "problemsDesc": "<p>有 <code>n</code> 个城市，按从 <code>0</code> 到 <code>n-1</code> 编号。给你一个边数组 <code>edges</code>，其中 <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>, weight<sub>i</sub>]</code> 代表 <code>from<sub>i</sub></code> 和 <code>to<sub>i</sub></code><sub> </sub>两个城市之间的双向加权边，距离阈值是一个整数 <code>distanceThreshold</code>。</p>\n\n<p>返回能通过某些路径到达其他城市数目最少、且路径距离 <strong>最大</strong> 为 <code>distanceThreshold</code> 的城市。如果有多个这样的城市，则返回编号最大的城市。</p>\n\n<p>注意，连接城市 <em><strong>i</strong></em> 和 <em><strong>j</strong></em> 的路径的距离等于沿该路径的所有边的权重之和。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/find_the_city_01.png\" style=\"height: 225px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>城市分布图如上。\n每个城市阈值距离 distanceThreshold = 4 内的邻居城市分别是：\n城市 0 -> [城市 1, 城市 2] \n城市 1 -> [城市 0, 城市 2, 城市 3] \n城市 2 -> [城市 0, 城市 1, 城市 3] \n城市 3 -> [城市 1, 城市 2] \n城市 0 和 3 在阈值距离 4 以内都有 2 个邻居城市，但是我们必须返回城市 3，因为它的编号最大。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/find_the_city_02.png\" style=\"height: 225px; width: 300px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2\n<strong>输出：</strong>0\n<strong>解释：</strong>城市分布图如上。 \n每个城市阈值距离 distanceThreshold = 2 内的邻居城市分别是：\n城市 0 -> [城市 1] \n城市 1 -> [城市 0, 城市 4] \n城市 2 -> [城市 3, 城市 4] \n城市 3 -> [城市 2, 城市 4]\n城市 4 -> [城市 1, 城市 2, 城市 3] \n城市 0 在阈值距离 2 以内只有 1 个邻居城市。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 100</code></li>\n\t<li><code>1 <= edges.length <= n * (n - 1) / 2</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 <= from<sub>i</sub> < to<sub>i</sub> < n</code></li>\n\t<li><code>1 <= weight<sub>i</sub>, distanceThreshold <= 10^4</code></li>\n\t<li>所有 <code>(from<sub>i</sub>, to<sub>i</sub>)</code> 都是不同的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1335.工作计划的最低难度",
        "hardRate": "HARD",
        "passRate": "66.69%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-difficulty-of-a-job-schedule/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-difficulty-of-a-job-schedule/solution",
        "problemsDesc": "<p>你需要制定一份&nbsp;<code>d</code>&nbsp;天的工作计划表。工作之间存在依赖，要想执行第&nbsp;<code>i</code>&nbsp;项工作，你必须完成全部&nbsp;<code>j</code>&nbsp;项工作（&nbsp;<code>0 &lt;= j &lt; i</code>）。</p>\n\n<p>你每天 <strong>至少</strong>&nbsp;需要完成一项任务。工作计划的总难度是这&nbsp;<code>d</code>&nbsp;天每一天的难度之和，而一天的工作难度是当天应该完成工作的最大难度。</p>\n\n<p>给你一个整数数组&nbsp;<code>jobDifficulty</code>&nbsp;和一个整数&nbsp;<code>d</code>，分别代表工作难度和需要计划的天数。第&nbsp;<code>i</code>&nbsp;项工作的难度是&nbsp;<code>jobDifficulty[i]</code>。</p>\n\n<p>返回整个工作计划的 <strong>最小难度</strong> 。如果无法制定工作计划，则返回&nbsp;<strong>-1&nbsp;</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/untitled.png\" style=\"height: 304px; width: 365px;\"></p>\n\n<pre><strong>输入：</strong>jobDifficulty = [6,5,4,3,2,1], d = 2\n<strong>输出：</strong>7\n<strong>解释：</strong>第一天，您可以完成前 5 项工作，总难度 = 6.\n第二天，您可以完成最后一项工作，总难度 = 1.\n计划表的难度 = 6 + 1 = 7 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>jobDifficulty = [9,9,9], d = 4\n<strong>输出：</strong>-1\n<strong>解释：</strong>就算你每天完成一项工作，仍然有一天是空闲的，你无法制定一份能够满足既定工作时间的计划表。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>jobDifficulty = [1,1,1], d = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>工作计划为每天一项工作，总难度为 3 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>jobDifficulty = [7,1,7,1,7,1], d = 3\n<strong>输出：</strong>15\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>jobDifficulty = [11,111,22,222,33,333,44,444], d = 6\n<strong>输出：</strong>843\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= jobDifficulty.length &lt;= 300</code></li>\n\t<li><code>0 &lt;=&nbsp;jobDifficulty[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= d &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1336.每次访问的交易次数",
        "hardRate": "HARD",
        "passRate": "45.52%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-transactions-per-visit/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-transactions-per-visit/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1337.矩阵中战斗力最弱的 K 行",
        "hardRate": "EASY",
        "passRate": "68.59%",
        "problemsUrl": "https://leetcode.cn/problems/the-k-weakest-rows-in-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/the-k-weakest-rows-in-a-matrix/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m * n</code> 的矩阵 <code>mat</code>，矩阵由若干军人和平民组成，分别用 1 和 0 表示。</p>\n\n<p>请你返回矩阵中战斗力最弱的 <code>k</code> 行的索引，按从最弱到最强排序。</p>\n\n<p>如果第 <em><strong>i</strong></em> 行的军人数量少于第 <em><strong>j</strong></em> 行，或者两行军人数量相同但<em><strong> i</strong></em> 小于 <em><strong>j</strong></em>，那么我们认为第<em><strong> i </strong></em>行的战斗力比第<em><strong> j </strong></em>行弱。</p>\n\n<p>军人 <strong>总是</strong> 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = \n[[1,1,0,0,0],\n [1,1,1,1,0],\n [1,0,0,0,0],\n [1,1,0,0,0],\n [1,1,1,1,1]], \nk = 3\n<strong>输出：</strong>[2,0,3]\n<strong>解释：</strong>\n每行中的军人数目：\n行 0 -> 2 \n行 1 -> 4 \n行 2 -> 1 \n行 3 -> 2 \n行 4 -> 5 \n从最弱到最强对这些行排序后得到 [2,0,3,1,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = \n[[1,0,0,0],\n [1,1,1,1],\n [1,0,0,0],\n [1,0,0,0]], \nk = 2\n<strong>输出：</strong>[0,2]\n<strong>解释：</strong> \n每行中的军人数目：\n行 0 -> 1 \n行 1 -> 4 \n行 2 -> 1 \n行 3 -> 1 \n从最弱到最强对这些行排序后得到 [0,2,3,1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>2 <= n, m <= 100</code></li>\n\t<li><code>1 <= k <= m</code></li>\n\t<li><code>matrix[i][j]</code> 不是 0 就是 1</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1338.数组大小减半",
        "hardRate": "MEDIUM",
        "passRate": "64.85%",
        "problemsUrl": "https://leetcode.cn/problems/reduce-array-size-to-the-half/",
        "solutionsUrl": "https://leetcode.cn/problems/reduce-array-size-to-the-half/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code>。你可以从中选出一个整数集合，并删除这些整数在数组中的每次出现。</p>\n\n<p>返回&nbsp;<strong>至少</strong>&nbsp;能删除数组中的一半整数的整数集合的最小大小。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [3,3,3,3,5,5,5,2,2,7]\n<strong>输出：</strong>2\n<strong>解释：</strong>选择 {3,7} 使得结果数组为 [5,5,5,2,2]、长度为 5（原数组长度的一半）。\n大小为 2 的可行集合有 {3,5},{3,2},{5,2}。\n选择 {2,7} 是不可行的，它的结果数组为 [3,3,3,3,5,5,5]，新数组长度大于原数组的二分之一。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [7,7,7,7,7,7]\n<strong>输出：</strong>1\n<strong>解释：</strong>我们只能选择集合 {7}，结果数组为空。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>arr.length</code>&nbsp;为偶数</li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1339.分裂二叉树的最大乘积",
        "hardRate": "MEDIUM",
        "passRate": "41.53%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-product-of-splitted-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-product-of-splitted-binary-tree/solution",
        "problemsDesc": "<p>给你一棵二叉树，它的根为&nbsp;<code>root</code> 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。</p>\n\n<p>由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/02/sample_1_1699.png\" style=\"height: 200px; width: 495px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [1,2,3,4,5,6]\n<strong>输出：</strong>110\n<strong>解释：</strong>删除红色的边，得到 2 棵子树，和分别为 11 和 10 。它们的乘积是 110 （11*10）\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/02/sample_2_1699.png\" style=\"height: 200px; width: 495px;\"></p>\n\n<pre><strong>输入：</strong>root = [1,null,2,3,4,null,null,5,6]\n<strong>输出：</strong>90\n<strong>解释：</strong>移除红色的边，得到 2 棵子树，和分别是 15 和 6 。它们的乘积为 90 （15*6）\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>root = [2,3,9,10,7,8,6,5,4,11,1]\n<strong>输出：</strong>1025\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>root = [1,1]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每棵树最多有&nbsp;<code>50000</code>&nbsp;个节点，且至少有&nbsp;<code>2</code>&nbsp;个节点。</li>\n\t<li>每个节点的值在&nbsp;<code>[1, 10000]</code>&nbsp;之间。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1340.跳跃游戏 V",
        "hardRate": "HARD",
        "passRate": "59.28%",
        "problemsUrl": "https://leetcode.cn/problems/jump-game-v/",
        "solutionsUrl": "https://leetcode.cn/problems/jump-game-v/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code> 和一个整数&nbsp;<code>d</code> 。每一步你可以从下标&nbsp;<code>i</code>&nbsp;跳到：</p>\n\n<ul>\n\t<li><code>i + x</code>&nbsp;，其中&nbsp;<code>i + x &lt; arr.length</code>&nbsp;且&nbsp;<code>0 &lt; x &lt;= d</code>&nbsp;。</li>\n\t<li><code>i - x</code>&nbsp;，其中&nbsp;<code>i - x &gt;= 0</code>&nbsp;且&nbsp;<code>0 &lt; x &lt;= d</code>&nbsp;。</li>\n</ul>\n\n<p>除此以外，你从下标&nbsp;<code>i</code> 跳到下标 <code>j</code>&nbsp;需要满足：<code>arr[i] &gt; arr[j]</code>&nbsp;且 <code>arr[i] &gt; arr[k]</code>&nbsp;，其中下标&nbsp;<code>k</code>&nbsp;是所有 <code>i</code>&nbsp;到 <code>j</code>&nbsp;之间的数字（更正式的，<code>min(i, j) &lt; k &lt; max(i, j)</code>）。</p>\n\n<p>你可以选择数组的任意下标开始跳跃。请你返回你 <strong>最多</strong>&nbsp;可以访问多少个下标。</p>\n\n<p>请注意，任何时刻你都不能跳到数组的外面。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/02/meta-chart.jpeg\" style=\"height: 419px; width: 633px;\"></p>\n\n<pre><strong>输入：</strong>arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>你可以从下标 10 出发，然后如上图依次经过 10 --&gt; 8 --&gt; 6 --&gt; 7 。\n注意，如果你从下标 6 开始，你只能跳到下标 7 处。你不能跳到下标 5 处因为 13 &gt; 9 。你也不能跳到下标 4 处，因为下标 5 在下标 4 和 6 之间且 13 &gt; 9 。\n类似的，你不能从下标 3 处跳到下标 2 或者下标 1 处。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,3,3,3,3], d = 3\n<strong>输出：</strong>1\n<strong>解释：</strong>你可以从任意下标处开始且你永远无法跳到任何其他坐标。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [7,6,5,4,3,2,1], d = 1\n<strong>输出：</strong>7\n<strong>解释：</strong>从下标 0 处开始，你可以按照数值从大到小，访问所有的下标。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [7,1,7,1,7,1], d = 2\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [66], d = 1\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= d &lt;= arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1341.电影评分",
        "hardRate": "MEDIUM",
        "passRate": "40.29%",
        "problemsUrl": "https://leetcode.cn/problems/movie-rating/",
        "solutionsUrl": "https://leetcode.cn/problems/movie-rating/solution",
        "problemsDesc": "<p>表：<code>Movies</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| movie_id      | int     |\n| title         | varchar |\n+---------------+---------+\nmovie_id 是这个表的主键。\ntitle 是电影的名字。\n</pre>\n\n<p>表：<code>Users</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| user_id       | int     |\n| name          | varchar |\n+---------------+---------+\nuser_id 是表的主键。\n</pre>\n\n<p>表：<code>MovieRating</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| movie_id      | int     |\n| user_id       | int     |\n| rating        | int     |\n| created_at    | date    |\n+---------------+---------+\n(movie_id, user_id) 是这个表的主键。\n这个表包含用户在其评论中对电影的评分 rating 。\ncreated_at 是用户的点评日期。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p>请你编写一组&nbsp;SQL 查询：</p>\n\n<ul>\n\t<li>查找评论电影数量最多的用户名。如果出现平局，返回字典序较小的用户名。</li>\n\t<li>查找在 <code>February 2020</code><strong> 平均评分最高</strong> 的电影名称。如果出现平局，返回字典序较小的电影名称。</li>\n</ul>\n\n<p><strong>字典序</strong> ，即按字母在字典中出现顺序对字符串排序，字典序较小则意味着排序靠前。</p>\n\n<p>查询结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nMovies 表：\n+-------------+--------------+\n| movie_id    |  title       |\n+-------------+--------------+\n| 1           | Avengers     |\n| 2           | Frozen 2     |\n| 3           | Joker        |\n+-------------+--------------+\nUsers 表：\n+-------------+--------------+\n| user_id     |  name        |\n+-------------+--------------+\n| 1           | Daniel       |\n| 2           | Monica       |\n| 3           | Maria        |\n| 4           | James        |\n+-------------+--------------+\nMovieRating 表：\n+-------------+--------------+--------------+-------------+\n| movie_id    | user_id      | rating       | created_at  |\n+-------------+--------------+--------------+-------------+\n| 1           | 1            | 3            | 2020-01-12  |\n| 1           | 2            | 4            | 2020-02-11  |\n| 1           | 3            | 2            | 2020-02-12  |\n| 1           | 4            | 1            | 2020-01-01  |\n| 2           | 1            | 5            | 2020-02-17  | \n| 2           | 2            | 2            | 2020-02-01  | \n| 2           | 3            | 2            | 2020-03-01  |\n| 3           | 1            | 3            | 2020-02-22  | \n| 3           | 2            | 4            | 2020-02-25  | \n+-------------+--------------+--------------+-------------+\n<strong>输出：</strong>\nResult 表：\n+--------------+\n| results      |\n+--------------+\n| Daniel       |\n| Frozen 2     |\n+--------------+\n<strong>解释：</strong>\nDaniel 和 Monica 都点评了 3 部电影（\"Avengers\", \"Frozen 2\" 和 \"Joker\"） 但是 Daniel 字典序比较小。\nFrozen 2 和 Joker 在 2 月的评分都是 3.5，但是 Frozen 2 的字典序比较小。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1342.将数字变成 0 的操作次数",
        "hardRate": "EASY",
        "passRate": "75.97%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-to-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-to-zero/solution",
        "problemsDesc": "<p>给你一个非负整数&nbsp;<code>num</code>&nbsp;，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 14\n<strong>输出：</strong>6\n<strong>解释：\n</strong>步骤 1) 14 是偶数，除以 2 得到 7 。\n步骤 2） 7 是奇数，减 1 得到 6 。\n步骤 3） 6 是偶数，除以 2 得到 3 。\n步骤 4） 3 是奇数，减 1 得到 2 。\n步骤 5） 2 是偶数，除以 2 得到 1 。\n步骤 6） 1 是奇数，减 1 得到 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 8\n<strong>输出：</strong>4\n<strong>解释：</strong>\n步骤 1） 8 是偶数，除以 2 得到 4 。\n步骤 2） 4 是偶数，除以 2 得到 2 。\n步骤 3） 2 是偶数，除以 2 得到 1 。\n步骤 4） 1 是奇数，减 1 得到 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = 123\n<strong>输出：</strong>12\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1343.大小为 K 且平均值大于等于阈值的子数组数目",
        "hardRate": "MEDIUM",
        "passRate": "57.42%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code>&nbsp;和两个整数 <code>k</code>&nbsp;和 <code>threshold</code>&nbsp;。</p>\n\n<p>请你返回长度为 <code>k</code>&nbsp;且平均值大于等于&nbsp;<code>threshold</code>&nbsp;的子数组数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>子数组 [2,5,5],[5,5,5] 和 [5,5,8] 的平均值分别为 4，5 和 6 。其他长度为 3 的子数组的平均值都小于 4 （threshold 的值)。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5\n<strong>输出：</strong>6\n<strong>解释：</strong>前 6 个长度为 3 的子数组平均值都大于 5 。注意平均值不是整数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= arr.length</code></li>\n\t<li><code>0 &lt;= threshold &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1344.时钟指针的夹角",
        "hardRate": "MEDIUM",
        "passRate": "60.06%",
        "problemsUrl": "https://leetcode.cn/problems/angle-between-hands-of-a-clock/",
        "solutionsUrl": "https://leetcode.cn/problems/angle-between-hands-of-a-clock/solution",
        "problemsDesc": "<p>给你两个数&nbsp;<code>hour</code>&nbsp;和&nbsp;<code>minutes</code>&nbsp;。请你返回在时钟上，由给定时间的时针和分针组成的较小角的角度（60 单位制）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/08/sample_1_1673.png\" style=\"height: 225px; width: 230px;\"></p>\n\n<pre><strong>输入：</strong>hour = 12, minutes = 30\n<strong>输出：</strong>165\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/08/sample_2_1673.png\" style=\"height: 225px; width: 230px;\"></p>\n\n<pre><strong>输入：</strong>hour = 3, minutes = 30\n<strong>输出；</strong>75\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/08/sample_3_1673.png\" style=\"height: 231px; width: 230px;\"></strong></p>\n\n<pre><strong>输入：</strong>hour = 3, minutes = 15\n<strong>输出：</strong>7.5\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>hour = 4, minutes = 50\n<strong>输出：</strong>155\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>hour = 12, minutes = 0\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= hour &lt;= 12</code></li>\n\t<li><code>0 &lt;= minutes &lt;= 59</code></li>\n\t<li>与标准答案误差在&nbsp;<code>10^-5</code>&nbsp;以内的结果都被视为正确结果。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1345.跳跃游戏 IV",
        "hardRate": "HARD",
        "passRate": "45.71%",
        "problemsUrl": "https://leetcode.cn/problems/jump-game-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/jump-game-iv/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code>&nbsp;，你一开始在数组的第一个元素处（下标为 0）。</p>\n\n<p>每一步，你可以从下标&nbsp;<code>i</code>&nbsp;跳到下标&nbsp;<code>i + 1</code> 、<code>i - 1</code> 或者 <code>j</code> ：</p>\n\n<ul>\n\t<li><code>i + 1</code> 需满足：<code>i + 1 &lt; arr.length</code></li>\n\t<li><code>i - 1</code>&nbsp;需满足：<code>i - 1 &gt;= 0</code></li>\n\t<li><code>j</code>&nbsp;需满足：<code>arr[i] == arr[j]</code>&nbsp;且&nbsp;<code>i != j</code></li>\n</ul>\n\n<p>请你返回到达数组最后一个元素的下标处所需的&nbsp;<strong>最少操作次数</strong>&nbsp;。</p>\n\n<p>注意：任何时候你都不能跳到数组外面。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [100,-23,-23,404,100,23,23,23,3,404]\n<strong>输出：</strong>3\n<strong>解释：</strong>那你需要跳跃 3 次，下标依次为 0 --&gt; 4 --&gt; 3 --&gt; 9 。下标 9 为数组的最后一个元素的下标。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [7]\n<strong>输出：</strong>0\n<strong>解释：</strong>一开始就在最后一个元素处，所以你不需要跳跃。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [7,6,9,6,9,6,9,7]\n<strong>输出：</strong>1\n<strong>解释：</strong>你可以直接从下标 0 处跳到下标 7 处，也就是数组的最后一个元素处。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>8</sup>&nbsp;&lt;= arr[i] &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1346.检查整数及其两倍数是否存在",
        "hardRate": "EASY",
        "passRate": "41.96%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-n-and-its-double-exist/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-n-and-its-double-exist/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code>，请你检查是否存在两个整数&nbsp;<code>N</code> 和 <code>M</code>，满足&nbsp;<code>N</code>&nbsp;是&nbsp;<code>M</code>&nbsp;的两倍（即，<code>N = 2 * M</code>）。</p>\n\n<p>更正式地，检查是否存在两个下标&nbsp;<code>i</code> 和 <code>j</code> 满足：</p>\n\n<ul>\n\t<li><code>i != j</code></li>\n\t<li><code>0 &lt;= i, j &lt; arr.length</code></li>\n\t<li><code>arr[i] == 2 * arr[j]</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [10,2,5,3]\n<strong>输出：</strong>true\n<strong>解释：</strong>N<code> = 10</code> 是 M<code> = 5 的两倍</code>，即 <code>10 = 2 * 5 。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [7,1,14,11]\n<strong>输出：</strong>true\n<strong>解释：</strong>N<code> = 14</code> 是 M<code> = 7 的两倍</code>，即 <code>14 = 2 * 7 </code>。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,1,7,11]\n<strong>输出：</strong>false\n<strong>解释：</strong>在该情况下不存在 N 和 M 满足 N = 2 * M 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 500</code></li>\n\t<li><code>-10^3 &lt;= arr[i] &lt;= 10^3</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1347.制造字母异位词的最小步骤数",
        "hardRate": "MEDIUM",
        "passRate": "76.15%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-steps-to-make-two-strings-anagram/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-steps-to-make-two-strings-anagram/solution",
        "problemsDesc": "<p>给你两个长度相等的字符串&nbsp;<code>s</code> 和 <code>t</code>。每一个步骤中，你可以选择将&nbsp;<code>t</code>&nbsp;中的 <strong>任一字符</strong> 替换为 <strong>另一个字符</strong>。</p>\n\n<p>返回使&nbsp;<code>t</code>&nbsp;成为&nbsp;<code>s</code>&nbsp;的字母异位词的最小步骤数。</p>\n\n<p><strong>字母异位词</strong> 指字母相同，但排列不同（也可能相同）的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输出：</strong>s = &quot;bab&quot;, t = &quot;aba&quot;\n<strong>输出：</strong>1\n<strong>提示：</strong>用 &#39;b&#39; 替换 t 中的第一个 &#39;a&#39;，t = &quot;bba&quot; 是 s 的一个字母异位词。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输出：</strong>s = &quot;leetcode&quot;, t = &quot;practice&quot;\n<strong>输出：</strong>5\n<strong>提示：</strong>用合适的字符替换 t 中的 &#39;p&#39;, &#39;r&#39;, &#39;a&#39;, &#39;i&#39; 和 &#39;c&#39;，使 t 变成 s 的字母异位词。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输出：</strong>s = &quot;anagram&quot;, t = &quot;mangaar&quot;\n<strong>输出：</strong>0\n<strong>提示：</strong>&quot;anagram&quot; 和 &quot;mangaar&quot; 本身就是一组字母异位词。 \n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输出：</strong>s = &quot;xxyyzz&quot;, t = &quot;xxyyzz&quot;\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输出：</strong>s = &quot;friend&quot;, t = &quot;family&quot;\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 50000</code></li>\n\t<li><code>s.length == t.length</code></li>\n\t<li><code>s</code> 和 <code>t</code>&nbsp;只包含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1348.推文计数",
        "hardRate": "MEDIUM",
        "passRate": "35.00%",
        "problemsUrl": "https://leetcode.cn/problems/tweet-counts-per-frequency/",
        "solutionsUrl": "https://leetcode.cn/problems/tweet-counts-per-frequency/solution",
        "problemsDesc": "<p>一家社交媒体公司正试图通过分析特定时间段内出现的推文数量来监控其网站上的活动。这些时间段可以根据特定的频率（&nbsp;<strong>每分钟&nbsp;</strong>、<strong>每小时&nbsp;</strong>或 <strong>每一天</strong> ）划分为更小的 <strong>时间段</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p>例如，周期 <code>[10,10000]</code>&nbsp;（以 <strong>秒</strong> 为单位）将被划分为以下频率的 <strong>时间块</strong> :</p>\n\n<ul>\n\t<li>每 <strong>分钟</strong> (60秒 块)：<meta charset=\"UTF-8\" />&nbsp;<code>[10,69]</code>,&nbsp;<code>[70,129]</code>,&nbsp;<code>[130,189]</code>,&nbsp;<code>...</code>,&nbsp;<code>[9970,10000]</code></li>\n\t<li>每 <strong>小时</strong> (3600秒 块)：<meta charset=\"UTF-8\" /><code>[10,3609]</code>,&nbsp;<code>[3610,7209]</code>,&nbsp;<code>[7210,10000]</code></li>\n\t<li>每 <strong>天</strong> (86400秒 块)：<meta charset=\"UTF-8\" />&nbsp;<code>[10,10000]</code></li>\n</ul>\n\n<p>注意，最后一个块可能比指定频率的块大小更短，并且总是以时间段的结束时间结束(在上面的示例中为 <code>10000</code> )。</p>\n\n<p>设计和实现一个API来帮助公司进行分析。</p>\n\n<p>实现 <code>TweetCounts</code> 类:</p>\n\n<ul>\n\t<li><code>TweetCounts()</code> 初始化 <code>TweetCounts</code> 对象。</li>\n\t<li>存储记录时间的 <code>tweetName</code> (以秒为单位)。</li>\n\t<li><code>List&lt;integer&gt; getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime)</code>&nbsp;返回一个整数列表，表示给定时间 <code>[startTime, endTime]</code>&nbsp;（单位秒）和频率频率中，每个 <strong>时间块</strong> 中带有 <code>tweetName</code> 的 <code>tweet</code> 的数量。\n\t<ul>\n\t\t<li><code>freq</code> 是 <code>“minute”</code> 、 <code>“hour”</code> 或 <code>“day”</code> 中的一个，分别表示 <strong>每分钟</strong> 、 <strong>每小时</strong> 或 <strong>每一天</strong> 的频率。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"TweetCounts\",\"recordTweet\",\"recordTweet\",\"recordTweet\",\"getTweetCountsPerFrequency\",\"getTweetCountsPerFrequency\",\"recordTweet\",\"getTweetCountsPerFrequency\"]\n[[],[\"tweet3\",0],[\"tweet3\",60],[\"tweet3\",10],[\"minute\",\"tweet3\",0,59],[\"minute\",\"tweet3\",0,60],[\"tweet3\",120],[\"hour\",\"tweet3\",0,210]]\n\n<strong>输出：</strong>\n[null,null,null,null,[2],[2,1],null,[4]]\n\n<strong>解释：</strong>\nTweetCounts tweetCounts = new TweetCounts();\ntweetCounts.recordTweet(\"tweet3\", 0);\ntweetCounts.recordTweet(\"tweet3\", 60);\ntweetCounts.recordTweet(\"tweet3\", 10);                             //&nbsp;\"tweet3\"&nbsp;发布推文的时间分别是&nbsp;0,&nbsp;10&nbsp;和&nbsp;60 。\ntweetCounts.getTweetCountsPerFrequency(\"minute\", \"tweet3\", 0, 59); //&nbsp;返回&nbsp;[2]。统计频率是每分钟（60 秒），因此只有一个有效时间间隔 [0,60&gt;&nbsp;-&nbsp;&gt;&nbsp;2&nbsp;条推文。\ntweetCounts.getTweetCountsPerFrequency(\"minute\", \"tweet3\", 0, 60); //&nbsp;返回&nbsp;[2,1]。统计频率是每分钟（60 秒），因此有两个有效时间间隔&nbsp;<strong>1)</strong>&nbsp;[0,60&gt;&nbsp;-&nbsp;&gt;&nbsp;2&nbsp;条推文，和&nbsp;<strong>2)</strong>&nbsp;[60,61&gt;&nbsp;-&nbsp;&gt;&nbsp;1&nbsp;条推文。 \ntweetCounts.recordTweet(\"tweet3\", 120);                            // \"tweet3\"&nbsp;发布推文的时间分别是 0, 10, 60 和 120 。\ntweetCounts.getTweetCountsPerFrequency(\"hour\", \"tweet3\", 0, 210);  //&nbsp;返回&nbsp;[4]。统计频率是每小时（3600 秒），因此只有一个有效时间间隔 [0,211&gt;&nbsp;-&nbsp;&gt;&nbsp;4&nbsp;条推文。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= time, startTime, endTime &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= endTime - startTime &lt;= 10<sup>4</sup></code></li>\n\t<li><code>recordTweet</code>&nbsp;和&nbsp;<code>getTweetCountsPerFrequency</code>，最多有<meta charset=\"UTF-8\" />&nbsp;<code>10<sup>4</sup></code>&nbsp;次操作。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1349.参加考试的最大学生数",
        "hardRate": "HARD",
        "passRate": "54.25%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-students-taking-exam/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-students-taking-exam/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m&nbsp;* n</code>&nbsp;的矩阵 <code>seats</code>&nbsp;表示教室中的座位分布。如果座位是坏的（不可用），就用&nbsp;<code>&#39;#&#39;</code>&nbsp;表示；否则，用&nbsp;<code>&#39;.&#39;</code>&nbsp;表示。</p>\n\n<p>学生可以看到左侧、右侧、左上、右上这四个方向上紧邻他的学生的答卷，但是看不到直接坐在他前面或者后面的学生的答卷。请你计算并返回该考场可以容纳的一起参加考试且无法作弊的最大学生人数。</p>\n\n<p>学生必须坐在状况良好的座位上。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/09/image.png\" style=\"height: 197px; width: 339px;\"></p>\n\n<pre><strong>输入：</strong>seats = [[&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;],\n&nbsp;             [&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;],\n&nbsp;             [&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;]]\n<strong>输出：</strong>4\n<strong>解释：</strong>教师可以让 4 个学生坐在可用的座位上，这样他们就无法在考试中作弊。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>seats = [[&quot;.&quot;,&quot;#&quot;],\n&nbsp;             [&quot;#&quot;,&quot;#&quot;],\n&nbsp;             [&quot;#&quot;,&quot;.&quot;],\n&nbsp;             [&quot;#&quot;,&quot;#&quot;],\n&nbsp;             [&quot;.&quot;,&quot;#&quot;]]\n<strong>输出：</strong>3\n<strong>解释：</strong>让所有学生坐在可用的座位上。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>seats = [[&quot;#&quot;,&quot;.&quot;,&quot;<strong>.</strong>&quot;,&quot;.&quot;,&quot;#&quot;],\n&nbsp;             [&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;],\n&nbsp;             [&quot;<strong>.</strong>&quot;,&quot;.&quot;,&quot;#&quot;,&quot;.&quot;,&quot;<strong>.</strong>&quot;],\n&nbsp;             [&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;],\n&nbsp;             [&quot;#&quot;,&quot;.&quot;,&quot;<strong>.</strong>&quot;,&quot;.&quot;,&quot;#&quot;]]\n<strong>输出：</strong>10\n<strong>解释：</strong>让学生坐在第 1、3 和 5 列的可用座位上。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>seats</code>&nbsp;只包含字符&nbsp;<code>&#39;.&#39;&nbsp;和</code><code>&#39;#&#39;</code></li>\n\t<li><code>m ==&nbsp;seats.length</code></li>\n\t<li><code>n ==&nbsp;seats[i].length</code></li>\n\t<li><code>1 &lt;= m &lt;= 8</code></li>\n\t<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1350.院系无效的学生",
        "hardRate": "EASY",
        "passRate": "85.04%",
        "problemsUrl": "https://leetcode.cn/problems/students-with-invalid-departments/",
        "solutionsUrl": "https://leetcode.cn/problems/students-with-invalid-departments/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1351.统计有序矩阵中的负数",
        "hardRate": "EASY",
        "passRate": "74.26%",
        "problemsUrl": "https://leetcode.cn/problems/count-negative-numbers-in-a-sorted-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/count-negative-numbers-in-a-sorted-matrix/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m&nbsp;* n</code>&nbsp;的矩阵&nbsp;<code>grid</code>，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。&nbsp;请你统计并返回&nbsp;<code>grid</code>&nbsp;中 <strong>负数</strong> 的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]\n<strong>输出：</strong>8\n<strong>解释：</strong>矩阵中共有 8 个负数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[3,2],[1,0]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>-100 &lt;= grid[i][j] &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(n + m)</code> 的解决方案吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1352.最后 K 个数的乘积",
        "hardRate": "MEDIUM",
        "passRate": "48.35%",
        "problemsUrl": "https://leetcode.cn/problems/product-of-the-last-k-numbers/",
        "solutionsUrl": "https://leetcode.cn/problems/product-of-the-last-k-numbers/solution",
        "problemsDesc": "<p>请你实现一个「数字乘积类」<code>ProductOfNumbers</code>，要求支持下述两种方法：</p>\n\n<p>1.<code>&nbsp;add(int num)</code></p>\n\n<ul>\n\t<li>将数字&nbsp;<code>num</code>&nbsp;添加到当前数字列表的最后面。</li>\n</ul>\n\n<p>2.<code> getProduct(int k)</code></p>\n\n<ul>\n\t<li>返回当前数字列表中，最后&nbsp;<code>k</code>&nbsp;个数字的乘积。</li>\n\t<li>你可以假设当前列表中始终 <strong>至少</strong> 包含 <code>k</code> 个数字。</li>\n</ul>\n\n<p>题目数据保证：任何时候，任一连续数字序列的乘积都在 32-bit 整数范围内，不会溢出。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>\n[&quot;ProductOfNumbers&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;getProduct&quot;,&quot;getProduct&quot;,&quot;getProduct&quot;,&quot;add&quot;,&quot;getProduct&quot;]\n[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]\n\n<strong>输出：</strong>\n[null,null,null,null,null,null,20,40,0,null,32]\n\n<strong>解释：</strong>\nProductOfNumbers productOfNumbers = new ProductOfNumbers();\nproductOfNumbers.add(3);        // [3]\nproductOfNumbers.add(0);        // [3,0]\nproductOfNumbers.add(2);        // [3,0,2]\nproductOfNumbers.add(5);        // [3,0,2,5]\nproductOfNumbers.add(4);        // [3,0,2,5,4]\nproductOfNumbers.getProduct(2); // 返回 20 。最后 2 个数字的乘积是 5 * 4 = 20\nproductOfNumbers.getProduct(3); // 返回 40 。最后 3 个数字的乘积是 2 * 5 * 4 = 40\nproductOfNumbers.getProduct(4); // 返回  0 。最后 4 个数字的乘积是 0 * 2 * 5 * 4 = 0\nproductOfNumbers.add(8);        // [3,0,2,5,4,8]\nproductOfNumbers.getProduct(2); // 返回 32 。最后 2 个数字的乘积是 4 * 8 = 32 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>add</code> 和 <code>getProduct</code>&nbsp;两种操作加起来总共不会超过&nbsp;<code>40000</code>&nbsp;次。</li>\n\t<li><code>0 &lt;= num&nbsp;&lt;=&nbsp;100</code></li>\n\t<li><code>1 &lt;= k &lt;= 40000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1353.最多可以参加的会议数目",
        "hardRate": "MEDIUM",
        "passRate": "29.48%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>events</code>，其中&nbsp;<code>events[i] = [startDay<sub>i</sub>, endDay<sub>i</sub>]</code>&nbsp;，表示会议&nbsp;<code>i</code>&nbsp;开始于&nbsp;<code>startDay<sub>i</sub></code>&nbsp;，结束于&nbsp;<code>endDay<sub>i</sub></code>&nbsp;。</p>\n\n<p>你可以在满足&nbsp;<code>startDay<sub>i</sub>&nbsp;&lt;= d &lt;= endDay<sub>i</sub></code><sub>&nbsp;</sub>中的任意一天&nbsp;<code>d</code>&nbsp;参加会议&nbsp;<code>i</code>&nbsp;。注意，一天只能参加一个会议。</p>\n\n<p>请你返回你可以参加的&nbsp;<strong>最大&nbsp;</strong>会议数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/16/e1.png\" style=\"height: 267px; width: 400px;\" /></p>\n\n<pre>\n<strong>输入：</strong>events = [[1,2],[2,3],[3,4]]\n<strong>输出：</strong>3\n<strong>解释：</strong>你可以参加所有的三个会议。\n安排会议的一种方案如上图。\n第 1 天参加第一个会议。\n第 2 天参加第二个会议。\n第 3 天参加第三个会议。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>events= [[1,2],[2,3],[3,4],[1,2]]\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong>​​​​​​</p>\n\n<ul>\n\t<li><code>1 &lt;= events.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>events[i].length == 2</code></li>\n\t<li><code>1 &lt;= startDay<sub>i</sub>&nbsp;&lt;= endDay<sub>i</sub>&nbsp;&lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1354.多次求和构造目标数组",
        "hardRate": "HARD",
        "passRate": "28.99%",
        "problemsUrl": "https://leetcode.cn/problems/construct-target-array-with-multiple-sums/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-target-array-with-multiple-sums/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>target</code> 。一开始，你有一个数组&nbsp;<code>A</code> ，它的所有元素均为 1 ，你可以执行以下操作：</p>\n\n<ul>\n\t<li>令&nbsp;<code>x</code>&nbsp;为你数组里所有元素的和</li>\n\t<li>选择满足&nbsp;<code>0 &lt;= i &lt; target.size</code>&nbsp;的任意下标&nbsp;<code>i</code>&nbsp;，并让&nbsp;<code>A</code>&nbsp;数组里下标为&nbsp;<code>i</code>&nbsp;处的值为&nbsp;<code>x</code>&nbsp;。</li>\n\t<li>你可以重复该过程任意次</li>\n</ul>\n\n<p>如果能从&nbsp;<code>A</code>&nbsp;开始构造出目标数组&nbsp;<code>target</code>&nbsp;，请你返回 True ，否则返回 False 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>target = [9,3,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>从 [1, 1, 1] 开始\n[1, 1, 1], 和为 3 ，选择下标 1\n[1, 3, 1], 和为 5， 选择下标 2\n[1, 3, 5], 和为 9， 选择下标 0\n[9, 3, 5] 完成\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>target = [1,1,1,2]\n<strong>输出：</strong>false\n<strong>解释：</strong>不可能从 [1,1,1,1] 出发构造目标数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>target = [8,5]\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>N == target.length</code></li>\n\t<li><code>1 &lt;= target.length&nbsp;&lt;= 5 * 10^4</code></li>\n\t<li><code>1 &lt;= target[i] &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1355.活动参与者",
        "hardRate": "MEDIUM",
        "passRate": "66.81%",
        "problemsUrl": "https://leetcode.cn/problems/activity-participants/",
        "solutionsUrl": "https://leetcode.cn/problems/activity-participants/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1356.根据数字二进制下 1 的数目排序",
        "hardRate": "EASY",
        "passRate": "73.46%",
        "problemsUrl": "https://leetcode.cn/problems/sort-integers-by-the-number-of-1-bits/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-integers-by-the-number-of-1-bits/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code>&nbsp;。请你将数组中的元素按照其二进制表示中数字 <strong>1</strong> 的数目升序排序。</p>\n\n<p>如果存在多个数字二进制中&nbsp;<strong>1</strong>&nbsp;的数目相同，则必须将它们按照数值大小升序排列。</p>\n\n<p>请你返回排序后的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [0,1,2,3,4,5,6,7,8]\n<strong>输出：</strong>[0,1,2,4,8,3,5,6,7]\n<strong>解释：</strong>[0] 是唯一一个有 0 个 1 的数。\n[1,2,4,8] 都有 1 个 1 。\n[3,5,6] 有 2 个 1 。\n[7] 有 3 个 1 。\n按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1024,512,256,128,64,32,16,8,4,2,1]\n<strong>输出：</strong>[1,2,4,8,16,32,64,128,256,512,1024]\n<strong>解释：</strong>数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [10000,10000]\n<strong>输出：</strong>[10000,10000]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,3,5,7,11,13,17,19]\n<strong>输出：</strong>[2,3,5,17,7,11,13,19]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [10,100,1000,10000]\n<strong>输出：</strong>[10,100,10000,1000]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 500</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1357.每隔 n 个顾客打折",
        "hardRate": "MEDIUM",
        "passRate": "54.57%",
        "problemsUrl": "https://leetcode.cn/problems/apply-discount-every-n-orders/",
        "solutionsUrl": "https://leetcode.cn/problems/apply-discount-every-n-orders/solution",
        "problemsDesc": "<p>超市里正在举行打折活动，每隔&nbsp;<code>n</code>&nbsp;个顾客会得到 <code>discount</code>&nbsp;的折扣。</p>\n\n<p>超市里有一些商品，第&nbsp;<code>i</code>&nbsp;种商品为&nbsp;<code>products[i]</code>&nbsp;且每件单品的价格为&nbsp;<code>prices[i]</code>&nbsp;。</p>\n\n<p>结账系统会统计顾客的数目，每隔&nbsp;<code>n</code>&nbsp;个顾客结账时，该顾客的账单都会打折，折扣为&nbsp;<code>discount</code>&nbsp;（也就是如果原本账单为&nbsp;<code>x</code>&nbsp;，那么实际金额会变成&nbsp;<code>x - (discount * x) / 100</code>&nbsp;），然后系统会重新开始计数。</p>\n\n<p>顾客会购买一些商品，&nbsp;<code>product[i]</code>&nbsp;是顾客购买的第&nbsp;<code>i</code>&nbsp;种商品，&nbsp;<code>amount[i]</code>&nbsp;是对应的购买该种商品的数目。</p>\n\n<p>请你实现&nbsp;<code>Cashier</code>&nbsp;类：</p>\n\n<ul>\n\t<li><code>Cashier(int n, int discount, int[] products, int[] prices)</code>&nbsp;初始化实例对象，参数分别为打折频率&nbsp;<code>n</code>&nbsp;，折扣大小 <code>discount</code>&nbsp;，超市里的商品列表 <code>products</code>&nbsp;和它们的价格 <code>prices</code>&nbsp;。</li>\n\t<li><code>double&nbsp;getBill(int[] product, int[] amount)</code>&nbsp;返回账单的实际金额（如果有打折，请返回打折后的结果）。返回结果与标准答案误差在&nbsp;<code>10^-5</code>&nbsp;以内都视为正确结果。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入</strong>\n[&quot;Cashier&quot;,&quot;getBill&quot;,&quot;getBill&quot;,&quot;getBill&quot;,&quot;getBill&quot;,&quot;getBill&quot;,&quot;getBill&quot;,&quot;getBill&quot;]\n[[3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]],[[1,2],[1,2]],[[3,7],[10,10]],[[1,2,3,4,5,6,7],[1,1,1,1,1,1,1]],[[4],[10]],[[7,3],[10,10]],[[7,5,3,1,6,4,2],[10,10,10,9,9,9,7]],[[2,3,5],[5,3,2]]]\n<strong>输出</strong>\n[null,500.0,4000.0,800.0,4000.0,4000.0,7350.0,2500.0]\n<strong>解释</strong>\nCashier cashier = new Cashier(3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]);\ncashier.getBill([1,2],[1,2]);                        // 返回 500.0, 账单金额为 = 1 * 100 + 2 * 200 = 500.\ncashier.getBill([3,7],[10,10]);                      // 返回 4000.0\ncashier.getBill([1,2,3,4,5,6,7],[1,1,1,1,1,1,1]);    // 返回 800.0 ，账单原本为 1600.0 ，但由于该顾客是第三位顾客，他将得到 50% 的折扣，所以实际金额为 1600 - 1600 * (50 / 100) = 800 。\ncashier.getBill([4],[10]);                           // 返回 4000.0\ncashier.getBill([7,3],[10,10]);                      // 返回 4000.0\ncashier.getBill([7,5,3,1,6,4,2],[10,10,10,9,9,9,7]); // 返回 7350.0 ，账单原本为 14700.0 ，但由于系统计数再次达到三，该顾客将得到 50% 的折扣，实际金额为 7350.0 。\ncashier.getBill([2,3,5],[5,3,2]);                    // 返回 2500.0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^4</code></li>\n\t<li><code>0 &lt;= discount &lt;= 100</code></li>\n\t<li><code>1 &lt;= products.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= products[i] &lt;= 200</code></li>\n\t<li><code>products</code>&nbsp;列表中&nbsp;<strong>不会</strong>&nbsp;有重复的元素。</li>\n\t<li><code>prices.length == products.length</code></li>\n\t<li><code>1 &lt;= prices[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= product.length &lt;= products.length</code></li>\n\t<li><code>product[i]</code>&nbsp;在&nbsp;<code>products</code>&nbsp;出现过。</li>\n\t<li><code>amount.length == product.length</code></li>\n\t<li><code>1 &lt;= amount[i] &lt;= 1000</code></li>\n\t<li>最多有&nbsp;<code>1000</code> 次对&nbsp;<code>getBill</code>&nbsp;函数的调用。</li>\n\t<li>返回结果与标准答案误差在&nbsp;<code>10^-5</code>&nbsp;以内都视为正确结果。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1358.包含所有三种字符的子字符串数目",
        "hardRate": "MEDIUM",
        "passRate": "52.94%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code>&nbsp;，它只包含三种字符 a, b 和 c 。</p>\n\n<p>请你返回 a，b 和 c 都&nbsp;<strong>至少&nbsp;</strong>出现过一次的子字符串数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abcabc&quot;\n<strong>输出：</strong>10\n<strong>解释：</strong>包含 a，b 和 c 各至少一次的子字符串为<em> &quot;</em>abc<em>&quot;, &quot;</em>abca<em>&quot;, &quot;</em>abcab<em>&quot;, &quot;</em>abcabc<em>&quot;, &quot;</em>bca<em>&quot;, &quot;</em>bcab<em>&quot;, &quot;</em>bcabc<em>&quot;, &quot;</em>cab<em>&quot;, &quot;</em>cabc<em>&quot; </em>和<em> &quot;</em>abc<em>&quot; </em>(<strong>相同</strong><strong>字符串算多次</strong>)<em>。</em>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aaacb&quot;\n<strong>输出：</strong>3\n<strong>解释：</strong>包含 a，b 和 c 各至少一次的子字符串为<em> &quot;</em>aaacb<em>&quot;, &quot;</em>aacb<em>&quot; </em>和<em> &quot;</em>acb<em>&quot; 。</em>\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abc&quot;\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= s.length &lt;= 5 x 10^4</code></li>\n\t<li><code>s</code>&nbsp;只包含字符 a，b 和 c 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1359.有效的快递序列数目",
        "hardRate": "HARD",
        "passRate": "58.41%",
        "problemsUrl": "https://leetcode.cn/problems/count-all-valid-pickup-and-delivery-options/",
        "solutionsUrl": "https://leetcode.cn/problems/count-all-valid-pickup-and-delivery-options/solution",
        "problemsDesc": "<p>给你&nbsp;<code>n</code>&nbsp;笔订单，每笔订单都需要快递服务。</p>\n\n<p>请你统计所有有效的 收件/配送 序列的数目，确保第 <code>i</code> 个物品的配送服务&nbsp;<code>delivery(i)</code> 总是在其收件服务&nbsp;<code>pickup(i)</code> 之后。</p>\n\n<p>由于答案可能很大，请返回答案对 <code>10^9 + 7</code> 取余的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>只有一种序列 (P1, D1)，物品 1 的配送服务（D1）在物品 1 的收件服务（P1）后。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>6\n<strong>解释：</strong>所有可能的序列包括：\n(P1,P2,D1,D2)，(P1,P2,D2,D1)，(P1,D1,P2,D2)，(P2,P1,D1,D2)，(P2,P1,D2,D1) 和 (P2,D2,P1,D1)。\n(P1,D2,P2,D1) 是一个无效的序列，因为物品 2 的收件服务（P2）不应在物品 2 的配送服务（D2）之后。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 3\n<strong>输出：</strong>90\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1360.日期之间隔几天",
        "hardRate": "EASY",
        "passRate": "51.02%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-days-between-two-dates/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-days-between-two-dates/solution",
        "problemsDesc": "<p>请你编写一个程序来计算两个日期之间隔了多少天。</p>\n\n<p>日期以字符串形式给出，格式为&nbsp;<code>YYYY-MM-DD</code>，如示例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>date1 = &quot;2019-06-29&quot;, date2 = &quot;2019-06-30&quot;\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>date1 = &quot;2020-01-15&quot;, date2 = &quot;2019-12-31&quot;\n<strong>输出：</strong>15\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给定的日期是&nbsp;<code>1971</code>&nbsp;年到 <code>2100</code>&nbsp;年之间的有效日期。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1361.验证二叉树",
        "hardRate": "MEDIUM",
        "passRate": "39.87%",
        "problemsUrl": "https://leetcode.cn/problems/validate-binary-tree-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/validate-binary-tree-nodes/solution",
        "problemsDesc": "<p>二叉树上有 <code>n</code>&nbsp;个节点，按从&nbsp;<code>0</code>&nbsp;到 <code>n - 1</code>&nbsp;编号，其中节点&nbsp;<code>i</code>&nbsp;的两个子节点分别是&nbsp;<code>leftChild[i]</code>&nbsp;和&nbsp;<code>rightChild[i]</code>。</p>\n\n<p>只有 <strong>所有</strong> 节点能够形成且 <strong>只</strong> 形成 <strong>一颗</strong>&nbsp;有效的二叉树时，返回&nbsp;<code>true</code>；否则返回 <code>false</code>。</p>\n\n<p>如果节点&nbsp;<code>i</code>&nbsp;没有左子节点，那么&nbsp;<code>leftChild[i]</code>&nbsp;就等于&nbsp;<code>-1</code>。右子节点也符合该规则。</p>\n\n<p>注意：节点没有值，本问题中仅仅使用节点编号。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/23/1503_ex1.png\" style=\"height: 287px; width: 195px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/23/1503_ex2.png\" style=\"height: 272px; width: 183px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/23/1503_ex3.png\" style=\"height: 174px; width: 82px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 2, leftChild = [1,0], rightChild = [-1,-1]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/23/1503_ex4.png\" style=\"height: 191px; width: 470px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 6, leftChild = [1,-1,-1,4,-1,-1], rightChild = [2,-1,-1,5,-1,-1]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^4</code></li>\n\t<li><code>leftChild.length == rightChild.length == n</code></li>\n\t<li><code>-1 &lt;= leftChild[i], rightChild[i] &lt;= n - 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1362.最接近的因数",
        "hardRate": "MEDIUM",
        "passRate": "54.73%",
        "problemsUrl": "https://leetcode.cn/problems/closest-divisors/",
        "solutionsUrl": "https://leetcode.cn/problems/closest-divisors/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>num</code>，请你找出同时满足下面全部要求的两个整数：</p>\n\n<ul>\n\t<li>两数乘积等于 &nbsp;<code>num + 1</code>&nbsp;或&nbsp;<code>num + 2</code></li>\n\t<li>以绝对差进行度量，两数大小最接近</li>\n</ul>\n\n<p>你可以按任意顺序返回这两个整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 8\n<strong>输出：</strong>[3,3]\n<strong>解释：</strong>对于 num + 1 = 9，最接近的两个因数是 3 &amp; 3；对于 num + 2 = 10, 最接近的两个因数是 2 &amp; 5，因此返回 3 &amp; 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 123\n<strong>输出：</strong>[5,25]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = 999\n<strong>输出：</strong>[40,25]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1363.形成三的最大倍数",
        "hardRate": "HARD",
        "passRate": "35.92%",
        "problemsUrl": "https://leetcode.cn/problems/largest-multiple-of-three/",
        "solutionsUrl": "https://leetcode.cn/problems/largest-multiple-of-three/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>digits</code>，你可以通过按任意顺序连接其中某些数字来形成 <strong>3</strong> 的倍数，请你返回所能得到的最大的 3 的倍数。</p>\n\n<p>由于答案可能不在整数数据类型范围内，请以字符串形式返回答案。</p>\n\n<p>如果无法得到答案，请返回一个空字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>digits = [8,1,9]\n<strong>输出：</strong>&quot;981&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>digits = [8,6,7,1,0]\n<strong>输出：</strong>&quot;8760&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>digits = [1]\n<strong>输出：</strong>&quot;&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>digits = [0,0,0,0,0,0]\n<strong>输出：</strong>&quot;0&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= digits.length &lt;= 10^4</code></li>\n\t<li><code>0 &lt;= digits[i] &lt;= 9</code></li>\n\t<li>返回的结果不应包含不必要的前导零。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1364.顾客的可信联系人数量",
        "hardRate": "MEDIUM",
        "passRate": "68.37%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-trusted-contacts-of-a-customer/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-trusted-contacts-of-a-customer/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1365.有多少小于当前数字的数字",
        "hardRate": "EASY",
        "passRate": "82.37%",
        "problemsUrl": "https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/",
        "solutionsUrl": "https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>nums</code>，对于其中每个元素&nbsp;<code>nums[i]</code>，请你统计数组中比它小的所有数字的数目。</p>\n\n<p>换而言之，对于每个&nbsp;<code>nums[i]</code>&nbsp;你必须计算出有效的&nbsp;<code>j</code>&nbsp;的数量，其中 <code>j</code> 满足&nbsp;<code>j != i</code> <strong>且</strong> <code>nums[j] &lt; nums[i]</code>&nbsp;。</p>\n\n<p>以数组形式返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [8,1,2,2,3]\n<strong>输出：</strong>[4,0,1,1,3]\n<strong>解释：</strong> \n对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 \n对于 nums[1]=1 不存在比它小的数字。\n对于 nums[2]=2 存在一个比它小的数字：（1）。 \n对于 nums[3]=2 存在一个比它小的数字：（1）。 \n对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [6,5,4,8]\n<strong>输出：</strong>[2,1,0,3]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [7,7,7,7]\n<strong>输出：</strong>[0,0,0,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1366.通过投票对团队排名",
        "hardRate": "MEDIUM",
        "passRate": "51.13%",
        "problemsUrl": "https://leetcode.cn/problems/rank-teams-by-votes/",
        "solutionsUrl": "https://leetcode.cn/problems/rank-teams-by-votes/solution",
        "problemsDesc": "<p>现在有一个特殊的排名系统，依据参赛团队在投票人心中的次序进行排名，每个投票者都需要按从高到低的顺序对参与排名的所有团队进行排位。</p>\n\n<p>排名规则如下：</p>\n\n<ul>\n\t<li>参赛团队的排名次序依照其所获「排位第一」的票的多少决定。如果存在多个团队并列的情况，将继续考虑其「排位第二」的票的数量。以此类推，直到不再存在并列的情况。</li>\n\t<li>如果在考虑完所有投票情况后仍然出现并列现象，则根据团队字母的字母顺序进行排名。</li>\n</ul>\n\n<p>给你一个字符串数组&nbsp;<code>votes</code> 代表全体投票者给出的排位情况，请你根据上述排名规则对所有参赛团队进行排名。</p>\n\n<p>请你返回能表示按排名系统 <strong>排序后</strong> 的所有团队排名的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>votes = [&quot;ABC&quot;,&quot;ACB&quot;,&quot;ABC&quot;,&quot;ACB&quot;,&quot;ACB&quot;]\n<strong>输出：</strong>&quot;ACB&quot;\n<strong>解释：</strong>A 队获得五票「排位第一」，没有其他队获得「排位第一」，所以 A 队排名第一。\nB 队获得两票「排位第二」，三票「排位第三」。\nC 队获得三票「排位第二」，两票「排位第三」。\n由于 C 队「排位第二」的票数较多，所以 C 队排第二，B 队排第三。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>votes = [&quot;WXYZ&quot;,&quot;XYZW&quot;]\n<strong>输出：</strong>&quot;XWYZ&quot;\n<strong>解释：</strong>X 队在并列僵局打破后成为排名第一的团队。X 队和 W 队的「排位第一」票数一样，但是 X 队有一票「排位第二」，而 W 没有获得「排位第二」。 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>votes = [&quot;ZMNAGUEDSJYLBOPHRQICWFXTVK&quot;]\n<strong>输出：</strong>&quot;ZMNAGUEDSJYLBOPHRQICWFXTVK&quot;\n<strong>解释：</strong>只有一个投票者，所以排名完全按照他的意愿。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>votes = [&quot;BCA&quot;,&quot;CAB&quot;,&quot;CBA&quot;,&quot;ABC&quot;,&quot;ACB&quot;,&quot;BAC&quot;]\n<strong>输出：</strong>&quot;ABC&quot;\n<strong>解释：</strong> \nA 队获得两票「排位第一」，两票「排位第二」，两票「排位第三」。\nB 队获得两票「排位第一」，两票「排位第二」，两票「排位第三」。\nC 队获得两票「排位第一」，两票「排位第二」，两票「排位第三」。\n完全并列，所以我们需要按照字母升序排名。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>votes = [&quot;M&quot;,&quot;M&quot;,&quot;M&quot;,&quot;M&quot;]\n<strong>输出：</strong>&quot;M&quot;\n<strong>解释：</strong>只有 M 队参赛，所以它排名第一。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= votes.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= votes[i].length &lt;= 26</code></li>\n\t<li><code>votes[i].length ==&nbsp;votes[j].length</code> for&nbsp;<code>0 &lt;= i, j &lt; votes.length</code></li>\n\t<li><code>votes[i][j]</code>&nbsp;是英文 <strong>大写</strong> 字母</li>\n\t<li><code>votes[i]</code>&nbsp;中的所有字母都是唯一的</li>\n\t<li><code>votes[0]</code>&nbsp;中出现的所有字母 <strong>同样也</strong> 出现在&nbsp;<code>votes[j]</code>&nbsp;中，其中&nbsp;<code>1 &lt;= j &lt; votes.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1367.二叉树中的链表",
        "hardRate": "MEDIUM",
        "passRate": "43.72%",
        "problemsUrl": "https://leetcode.cn/problems/linked-list-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/linked-list-in-binary-tree/solution",
        "problemsDesc": "<p>给你一棵以&nbsp;<code>root</code>&nbsp;为根的二叉树和一个&nbsp;<code>head</code>&nbsp;为第一个节点的链表。</p>\n\n<p>如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以&nbsp;<code>head</code>&nbsp;为首的链表中每个节点的值，那么请你返回 <code>True</code> ，否则返回 <code>False</code> 。</p>\n\n<p>一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/sample_1_1720.png\" style=\"height: 280px; width: 220px;\"></strong></p>\n\n<pre><strong>输入：</strong>head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n<strong>输出：</strong>true\n<strong>解释：</strong>树中蓝色的节点构成了与链表对应的子路径。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/sample_2_1720.png\" style=\"height: 280px; width: 220px;\"></strong></p>\n\n<pre><strong>输入：</strong>head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\n<strong>输出：</strong>false\n<strong>解释：</strong>二叉树中不存在一一对应链表的路径。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉树和链表中的每个节点的值都满足&nbsp;<code>1 &lt;= node.val&nbsp;&lt;= 100</code>&nbsp;。</li>\n\t<li>链表包含的节点数目在&nbsp;<code>1</code>&nbsp;到&nbsp;<code>100</code>&nbsp;之间。</li>\n\t<li>二叉树包含的节点数目在&nbsp;<code>1</code>&nbsp;到&nbsp;<code>2500</code>&nbsp;之间。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1368.使网格图至少有一条有效路径的最小代价",
        "hardRate": "HARD",
        "passRate": "59.66%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/solution",
        "problemsDesc": "<p>给你一个 m x n 的网格图&nbsp;<code>grid</code>&nbsp;。&nbsp;<code>grid</code>&nbsp;中每个格子都有一个数字，对应着从该格子出发下一步走的方向。&nbsp;<code>grid[i][j]</code>&nbsp;中的数字可能为以下几种情况：</p>\n\n<ul>\n\t<li><strong>1</strong>&nbsp;，下一步往右走，也就是你会从 <code>grid[i][j]</code>&nbsp;走到 <code>grid[i][j + 1]</code></li>\n\t<li><strong>2</strong>&nbsp;，下一步往左走，也就是你会从 <code>grid[i][j]</code>&nbsp;走到 <code>grid[i][j - 1]</code></li>\n\t<li><strong>3</strong>&nbsp;，下一步往下走，也就是你会从 <code>grid[i][j]</code>&nbsp;走到 <code>grid[i + 1][j]</code></li>\n\t<li><strong>4</strong>&nbsp;，下一步往上走，也就是你会从 <code>grid[i][j]</code>&nbsp;走到 <code>grid[i - 1][j]</code></li>\n</ul>\n\n<p>注意网格图中可能会有&nbsp;<strong>无效数字</strong>&nbsp;，因为它们可能指向&nbsp;<code>grid</code>&nbsp;以外的区域。</p>\n\n<p>一开始，你会从最左上角的格子&nbsp;<code>(0,0)</code>&nbsp;出发。我们定义一条&nbsp;<strong>有效路径</strong>&nbsp;为从格子&nbsp;<code>(0,0)</code>&nbsp;出发，每一步都顺着数字对应方向走，最终在最右下角的格子&nbsp;<code>(m - 1, n - 1)</code>&nbsp;结束的路径。有效路径&nbsp;<strong>不需要是最短路径</strong>&nbsp;。</p>\n\n<p>你可以花费&nbsp;<code>cost = 1</code>&nbsp;的代价修改一个格子中的数字，但每个格子中的数字&nbsp;<strong>只能修改一次</strong>&nbsp;。</p>\n\n<p>请你返回让网格图至少有一条有效路径的最小代价。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid1.png\" style=\"height: 528px; width: 542px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]\n<strong>输出：</strong>3\n<strong>解释：</strong>你将从点 (0, 0) 出发。\n到达 (3, 3) 的路径为： (0, 0) --&gt; (0, 1) --&gt; (0, 2) --&gt; (0, 3) 花费代价 cost = 1 使方向向下 --&gt; (1, 3) --&gt; (1, 2) --&gt; (1, 1) --&gt; (1, 0) 花费代价 cost = 1 使方向向下 --&gt; (2, 0) --&gt; (2, 1) --&gt; (2, 2) --&gt; (2, 3) 花费代价 cost = 1 使方向向下 --&gt; (3, 3)\n总花费为 cost = 3.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid2.png\" style=\"height: 408px; width: 419px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[1,1,3],[3,2,2],[1,1,4]]\n<strong>输出：</strong>0\n<strong>解释：</strong>不修改任何数字你就可以从 (0, 0) 到达 (2, 2) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid3.png\" style=\"height: 302px; width: 314px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[1,2],[4,3]]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[2,2,2],[2,2,2]]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[4]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1369.获取最近第二次的活动",
        "hardRate": "HARD",
        "passRate": "61.58%",
        "problemsUrl": "https://leetcode.cn/problems/get-the-second-most-recent-activity/",
        "solutionsUrl": "https://leetcode.cn/problems/get-the-second-most-recent-activity/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1370.上升下降字符串",
        "hardRate": "EASY",
        "passRate": "78.96%",
        "problemsUrl": "https://leetcode.cn/problems/increasing-decreasing-string/",
        "solutionsUrl": "https://leetcode.cn/problems/increasing-decreasing-string/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，请你根据下面的算法重新构造字符串：</p>\n\n<ol>\n\t<li>从 <code>s</code>&nbsp;中选出 <strong>最小</strong>&nbsp;的字符，将它 <strong>接在</strong>&nbsp;结果字符串的后面。</li>\n\t<li>从 <code>s</code>&nbsp;剩余字符中选出&nbsp;<strong>最小</strong>&nbsp;的字符，且该字符比上一个添加的字符大，将它 <strong>接在</strong>&nbsp;结果字符串后面。</li>\n\t<li>重复步骤 2 ，直到你没法从 <code>s</code>&nbsp;中选择字符。</li>\n\t<li>从 <code>s</code>&nbsp;中选出 <strong>最大</strong>&nbsp;的字符，将它 <strong>接在</strong>&nbsp;结果字符串的后面。</li>\n\t<li>从 <code>s</code>&nbsp;剩余字符中选出&nbsp;<strong>最大</strong>&nbsp;的字符，且该字符比上一个添加的字符小，将它 <strong>接在</strong>&nbsp;结果字符串后面。</li>\n\t<li>重复步骤 5&nbsp;，直到你没法从 <code>s</code>&nbsp;中选择字符。</li>\n\t<li>重复步骤 1 到 6 ，直到 <code>s</code>&nbsp;中所有字符都已经被选过。</li>\n</ol>\n\n<p>在任何一步中，如果最小或者最大字符不止一个&nbsp;，你可以选择其中任意一个，并将其添加到结果字符串。</p>\n\n<p>请你返回将&nbsp;<code>s</code>&nbsp;中字符重新排序后的 <strong>结果字符串</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aaaabbbbcccc&quot;\n<strong>输出：</strong>&quot;abccbaabccba&quot;\n<strong>解释：</strong>第一轮的步骤 1，2，3 后，结果字符串为 result = &quot;abc&quot;\n第一轮的步骤 4，5，6 后，结果字符串为 result = &quot;abccba&quot;\n第一轮结束，现在 s = &quot;aabbcc&quot; ，我们再次回到步骤 1\n第二轮的步骤 1，2，3 后，结果字符串为 result = &quot;abccbaabc&quot;\n第二轮的步骤 4，5，6 后，结果字符串为 result = &quot;abccbaabccba&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;rat&quot;\n<strong>输出：</strong>&quot;art&quot;\n<strong>解释：</strong>单词 &quot;rat&quot; 在上述算法重排序以后变成 &quot;art&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;leetcode&quot;\n<strong>输出：</strong>&quot;cdelotee&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;ggggggg&quot;\n<strong>输出：</strong>&quot;ggggggg&quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;spo&quot;\n<strong>输出：</strong>&quot;ops&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1371.每个元音包含偶数次的最长子字符串",
        "hardRate": "MEDIUM",
        "passRate": "59.08%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即&nbsp;&#39;a&#39;，&#39;e&#39;，&#39;i&#39;，&#39;o&#39;，&#39;u&#39; ，在子字符串中都恰好出现了偶数次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;eleetminicoworoep&quot;\n<strong>输出：</strong>13\n<strong>解释：</strong>最长子字符串是 &quot;leetminicowor&quot; ，它包含 <strong>e，i，o</strong>&nbsp;各 2 个，以及 0 个 <strong>a</strong>，<strong>u </strong>。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;leetcodeisgreat&quot;\n<strong>输出：</strong>5\n<strong>解释：</strong>最长子字符串是 &quot;leetc&quot; ，其中包含 2 个 <strong>e</strong> 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;bcbcbc&quot;\n<strong>输出：</strong>6\n<strong>解释：</strong>这个示例中，字符串 &quot;bcbcbc&quot; 本身就是最长的，因为所有的元音 <strong>a，</strong><strong>e，</strong><strong>i，</strong><strong>o，</strong><strong>u</strong> 都出现了 0 次。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 x 10^5</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1372.二叉树中的最长交错路径",
        "hardRate": "MEDIUM",
        "passRate": "54.72%",
        "problemsUrl": "https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/solution",
        "problemsDesc": "<p>给你一棵以&nbsp;<code>root</code>&nbsp;为根的二叉树，二叉树中的交错路径定义如下：</p>\n\n<ul>\n\t<li>选择二叉树中 <strong>任意</strong>&nbsp;节点和一个方向（左或者右）。</li>\n\t<li>如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。</li>\n\t<li>改变前进方向：左变右或者右变左。</li>\n\t<li>重复第二步和第三步，直到你在树中无法继续移动。</li>\n</ul>\n\n<p>交错路径的长度定义为：<strong>访问过的节点数目 - 1</strong>（单个节点的路径长度为 0 ）。</p>\n\n<p>请你返回给定树中最长 <strong>交错路径</strong>&nbsp;的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/07/sample_1_1702.png\" style=\"height: 283px; width: 151px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>蓝色节点为树中最长交错路径（右 -&gt; 左 -&gt; 右）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/07/sample_2_1702.png\" style=\"height: 253px; width: 120px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [1,1,1,null,1,null,null,1,1,null,1]\n<strong>输出：</strong>4\n<strong>解释：</strong>蓝色节点为树中最长交错路径（左 -&gt; 右 -&gt; 左 -&gt; 右）。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>root = [1]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每棵树最多有&nbsp;<code>50000</code>&nbsp;个节点。</li>\n\t<li>每个节点的值在&nbsp;<code>[1, 100]</code> 之间。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1373.二叉搜索子树的最大键值和",
        "hardRate": "HARD",
        "passRate": "47.81%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/solution",
        "problemsDesc": "<p>给你一棵以 <code>root</code> 为根的 <strong>二叉树</strong> ，请你返回 <strong>任意</strong> 二叉搜索子树的最大键值和。</p>\n\n<p>二叉搜索树的定义如下：</p>\n\n<ul>\n\t<li>任意节点的左子树中的键值都 <strong>小于</strong> 此节点的键值。</li>\n\t<li>任意节点的右子树中的键值都 <strong>大于</strong> 此节点的键值。</li>\n\t<li>任意节点的左子树和右子树都是二叉搜索树。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/07/sample_1_1709.png\" style=\"height: 250px; width: 320px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]\n<strong>输出：</strong>20\n<strong>解释：</strong>键值为 3 的子树是和最大的二叉搜索树。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/07/sample_2_1709.png\" style=\"height: 180px; width: 134px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [4,3,null,1,2]\n<strong>输出：</strong>2\n<strong>解释：</strong>键值为 2 的单节点子树是和最大的二叉搜索树。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [-4,-2,-5]\n<strong>输出：</strong>0\n<strong>解释：</strong>所有节点键值都为负数，和最大的二叉搜索树为空。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [2,1,3]\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [5,4,8,3,null,6,3]\n<strong>输出：</strong>7\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每棵树有 <code>1</code> 到 <code>40000</code> 个节点。</li>\n\t<li>每个节点的键值在 <code>[-4 * 10^4 , 4 * 10^4]</code> 之间。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1374.生成每种字符都是奇数个的字符串",
        "hardRate": "EASY",
        "passRate": "77.65%",
        "problemsUrl": "https://leetcode.cn/problems/generate-a-string-with-characters-that-have-odd-counts/",
        "solutionsUrl": "https://leetcode.cn/problems/generate-a-string-with-characters-that-have-odd-counts/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code>，请你返回一个含<em> <code>n</code> </em>个字符的字符串，其中每种字符在该字符串中都恰好出现 <strong>奇数次</strong> <em><strong>。</strong></em></p>\n\n<p>返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 4\n<strong>输出：</strong>&quot;pppz&quot;\n<strong>解释：</strong>&quot;pppz&quot; 是一个满足题目要求的字符串，因为 &#39;p&#39; 出现 3 次，且 &#39;z&#39; 出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：&quot;ohhh&quot; 和 &quot;love&quot;。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>&quot;xy&quot;\n<strong>解释：</strong>&quot;xy&quot; 是一个满足题目要求的字符串，因为 &#39;x&#39; 和 &#39;y&#39; 各出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：&quot;ag&quot; 和 &quot;ur&quot;。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 7\n<strong>输出：</strong>&quot;holasss&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1375.二进制字符串前缀一致的次数",
        "hardRate": "MEDIUM",
        "passRate": "68.09%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-times-binary-string-is-prefix-aligned/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-times-binary-string-is-prefix-aligned/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 、下标从 <strong>1</strong> 开始的二进制字符串，所有位最开始都是 <code>0</code> 。我们会按步翻转该二进制字符串的所有位（即，将 <code>0</code> 变为 <code>1</code>）。</p>\n\n<p>给你一个下标从 <strong>1</strong> 开始的整数数组 <code>flips</code> ，其中 <code>flips[i]</code> 表示对应下标 <code>i</code> 的位将会在第 <code>i</code> 步翻转。</p>\n\n<p>二进制字符串 <strong>前缀一致</strong> 需满足：在第 <code>i</code> 步之后，在 <strong>闭</strong> 区间&nbsp;<code>[1, i]</code> 内的所有位都是 1 ，而其他位都是 0 。</p>\n\n<p>返回二进制字符串在翻转过程中 <strong>前缀一致</strong> 的次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>flips = [3,2,4,1,5]\n<strong>输出：</strong>2\n<strong>解释：</strong>二进制字符串最开始是 \"00000\" 。\n执行第 1 步：字符串变为 \"00100\" ，不属于前缀一致的情况。\n执行第 2 步：字符串变为 \"01100\" ，不属于前缀一致的情况。\n执行第 3 步：字符串变为 \"01110\" ，不属于前缀一致的情况。\n执行第 4 步：字符串变为 \"11110\" ，属于前缀一致的情况。\n执行第 5 步：字符串变为 \"11111\" ，属于前缀一致的情况。\n在翻转过程中，前缀一致的次数为 2 ，所以返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>flips = [4,1,2,3]\n<strong>输出：</strong>1\n<strong>解释：</strong>二进制字符串最开始是 \"0000\" 。\n执行第 1 步：字符串变为 \"0001\" ，不属于前缀一致的情况。\n执行第 2 步：字符串变为 \"1001\" ，不属于前缀一致的情况。\n执行第 3 步：字符串变为 \"1101\" ，不属于前缀一致的情况。\n执行第 4 步：字符串变为 \"1111\" ，属于前缀一致的情况。\n在翻转过程中，前缀一致的次数为 1 ，所以返回 1 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == flips.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>flips</code> 是范围 <code>[1, n]</code> 中所有整数构成的一个排列</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1376.通知所有员工所需的时间",
        "hardRate": "MEDIUM",
        "passRate": "60.17%",
        "problemsUrl": "https://leetcode.cn/problems/time-needed-to-inform-all-employees/",
        "solutionsUrl": "https://leetcode.cn/problems/time-needed-to-inform-all-employees/solution",
        "problemsDesc": "<p>公司里有 <code>n</code> 名员工，每个员工的 ID 都是独一无二的，编号从 <code>0</code> 到 <code>n - 1</code>。公司的总负责人通过 <code>headID</code> 进行标识。</p>\n\n<p>在 <code>manager</code> 数组中，每个员工都有一个直属负责人，其中 <code>manager[i]</code> 是第 <code>i</code> 名员工的直属负责人。对于总负责人，<code>manager[headID] = -1</code>。题目保证从属关系可以用树结构显示。</p>\n\n<p>公司总负责人想要向公司所有员工通告一条紧急消息。他将会首先通知他的直属下属们，然后由这些下属通知他们的下属，直到所有的员工都得知这条紧急消息。</p>\n\n<p>第 <code>i</code> 名员工需要 <code>informTime[i]</code> 分钟来通知它的所有直属下属（也就是说在 <code>informTime[i]</code> 分钟后，他的所有直属下属都可以开始传播这一消息）。</p>\n\n<p>返回通知所有员工这一紧急消息所需要的 <strong>分钟数</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, headID = 0, manager = [-1], informTime = [0]\n<strong>输出：</strong>0\n<strong>解释：</strong>公司总负责人是该公司的唯一一名员工。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/08/graph.png\" style=\"height: 174px; width: 404px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]\n<strong>输出：</strong>1\n<strong>解释：</strong>id = 2 的员工是公司的总负责人，也是其他所有员工的直属负责人，他需要 1 分钟来通知所有员工。\n上图显示了公司员工的树结构。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= headID &lt; n</code></li>\n\t<li><code>manager.length == n</code></li>\n\t<li><code>0 &lt;= manager[i] &lt; n</code></li>\n\t<li><code>manager[headID] == -1</code></li>\n\t<li><code>informTime.length&nbsp;== n</code></li>\n\t<li><code>0 &lt;= informTime[i] &lt;= 1000</code></li>\n\t<li>如果员工 <code>i</code> 没有下属，<code>informTime[i] == 0</code> 。</li>\n\t<li>题目 <strong>保证</strong> 所有员工都可以收到通知。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1377.T 秒后青蛙的位置",
        "hardRate": "HARD",
        "passRate": "42.66%",
        "problemsUrl": "https://leetcode.cn/problems/frog-position-after-t-seconds/",
        "solutionsUrl": "https://leetcode.cn/problems/frog-position-after-t-seconds/solution",
        "problemsDesc": "<p>给你一棵由 <code>n</code> 个顶点组成的无向树，顶点编号从 <code>1</code> 到 <code>n</code>。青蛙从 <strong>顶点 1</strong> 开始起跳。规则如下：</p>\n\n<ul>\n\t<li>在一秒内，青蛙从它所在的当前顶点跳到另一个 <strong>未访问</strong> 过的顶点（如果它们直接相连）。</li>\n\t<li>青蛙无法跳回已经访问过的顶点。</li>\n\t<li>如果青蛙可以跳到多个不同顶点，那么它跳到其中任意一个顶点上的机率都相同。</li>\n\t<li>如果青蛙不能跳到任何未访问过的顶点上，那么它每次跳跃都会停留在原地。</li>\n</ul>\n\n<p>无向树的边用数组 <code>edges</code> 描述，其中 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 意味着存在一条直接连通 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 两个顶点的边。</p>\n\n<p>返回青蛙在 <em><code>t</code></em> 秒后位于目标顶点 <em><code>target</code> </em>上的概率。与实际答案相差不超过 <code>10<sup>-5</sup></code> 的结果将被视为正确答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/12/21/frog1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4\n<strong>输出：</strong>0.16666666666666666 \n<strong>解释：</strong>上图显示了青蛙的跳跃路径。青蛙从顶点 1 起跳，第 <strong>1 秒</strong> 有 1/3 的概率跳到顶点 2 ，然后第 <strong>2 秒</strong> 有 1/2 的概率跳到顶点 4，因此青蛙在 2 秒后位于顶点 4 的概率是 1/3 * 1/2 = 1/6 = 0.16666666666666666 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/12/21/frog2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7\n<strong>输出：</strong>0.3333333333333333\n<strong>解释：</strong>上图显示了青蛙的跳跃路径。青蛙从顶点 1 起跳，有 1/3 = 0.3333333333333333 的概率能够 <strong>1 秒</strong> 后跳到顶点 7 。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub>&nbsp;&lt;= n</code></li>\n\t<li><code>1 &lt;= t &lt;= 50</code></li>\n\t<li><code>1 &lt;= target &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1378.使用唯一标识码替换员工ID",
        "hardRate": "EASY",
        "passRate": "85.52%",
        "problemsUrl": "https://leetcode.cn/problems/replace-employee-id-with-the-unique-identifier/",
        "solutionsUrl": "https://leetcode.cn/problems/replace-employee-id-with-the-unique-identifier/solution",
        "problemsDesc": "<p><code>Employees</code> 表：</p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| name          | varchar |\n+---------------+---------+\nid 是这张表的主键。\n这张表的每一行分别代表了某公司其中一位员工的名字和 ID 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><code>EmployeeUNI</code>&nbsp;表：</p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| unique_id     | int     |\n+---------------+---------+\n(id, unique_id) 是这张表的主键。\n这张表的每一行包含了该公司某位员工的 ID 和他的唯一标识码（unique ID）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一段SQL查询来展示每位用户的<strong> 唯一标识码（unique ID ）</strong>；如果某位员工没有唯一标识码，使用 null 填充即可。</p>\n\n<p>你可以以<strong> 任意</strong> 顺序返回结果表。</p>\n\n<p>查询结果的格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<code><strong>输入：</strong>\nEmployees</code> 表:\n+----+----------+\n| id | name     |\n+----+----------+\n| 1  | Alice    |\n| 7  | Bob      |\n| 11 | Meir     |\n| 90 | Winston  |\n| 3  | Jonathan |\n+----+----------+\n<code>EmployeeUNI</code> 表:\n+----+-----------+\n| id | unique_id |\n+----+-----------+\n| 3  | 1         |\n| 11 | 2         |\n| 90 | 3         |\n+----+-----------+\n<strong>输出：</strong>\n+-----------+----------+\n| unique_id | name     |\n+-----------+----------+\n| null      | Alice    |\n| null      | Bob      |\n| 2         | Meir     |\n| 3         | Winston  |\n| 1         | Jonathan |\n+-----------+----------+\n<strong>解释：</strong>\nAlice and Bob 没有唯一标识码, 因此我们使用 null 替代。\nMeir 的唯一标识码是 2 。\nWinston 的唯一标识码是 3 。\nJonathan 唯一标识码是 1 。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1379.找出克隆二叉树中的相同节点",
        "hardRate": "EASY",
        "passRate": "83.26%",
        "problemsUrl": "https://leetcode.cn/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/solution",
        "problemsDesc": "<p>给你两棵二叉树，原始树 <code>original</code> 和克隆树 <code>cloned</code>，以及一个位于原始树 <code>original</code>&nbsp;中的目标节点&nbsp;<code>target</code>。</p>\n\n<p>其中，克隆树 <code>cloned</code>&nbsp;是原始树 <code>original</code>&nbsp;的一个<strong> 副本 </strong>。</p>\n\n<p>请找出在树&nbsp;<code>cloned</code>&nbsp;中，与&nbsp;<code>target</code>&nbsp;<strong>相同&nbsp;</strong>的节点，并返回对该节点的引用（在 C/C++ 等有指针的语言中返回 节点指针，其他语言返回节点本身）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>你 <strong>不能</strong> 对两棵二叉树，以及 <code>target</code>&nbsp;节点进行更改。<strong>只能</strong> 返回对克隆树&nbsp;<code>cloned</code>&nbsp;中已有的节点的引用。</p>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/21/e1.png\" /></p>\n\n<pre>\n<strong>输入:</strong> tree = [7,4,3,null,null,6,19], target = 3\n<strong>输出:</strong> 3\n<strong>解释:</strong> 上图画出了树 original 和 cloned。target 节点在树 original 中，用绿色标记。答案是树 cloned 中的黄颜色的节点（其他示例类似）。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/21/e2.png\" /></p>\n\n<pre>\n<strong>输入:</strong> tree = [7], target =  7\n<strong>输出:</strong> 7\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/21/e3.png\" /></p>\n\n<pre>\n<strong>输入:</strong> tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4\n<strong>输出:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数量范围为<meta charset=\"UTF-8\" />&nbsp;<code>[1, 10<sup>4</sup>]</code>&nbsp;。</li>\n\t<li>同一棵树中，没有值相同的节点。</li>\n\t<li><code>target</code>&nbsp;节点是树&nbsp;<code>original</code>&nbsp;中的一个节点，并且不会是&nbsp;<code>null</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>如果树中允许出现值相同的节点，将如何解答？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1380.矩阵中的幸运数",
        "hardRate": "EASY",
        "passRate": "76.35%",
        "problemsUrl": "https://leetcode.cn/problems/lucky-numbers-in-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/lucky-numbers-in-a-matrix/solution",
        "problemsDesc": "<p>给你一个 <code>m * n</code> 的矩阵，矩阵中的数字 <strong>各不相同</strong> 。请你按 <strong>任意</strong> 顺序返回矩阵中的所有幸运数。</p>\n\n<p><strong>幸运数</strong> 是指矩阵中满足同时下列两个条件的元素：</p>\n\n<ul>\n\t<li>在同一行的所有元素中最小</li>\n\t<li>在同一列的所有元素中最大</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[3,7,8],[9,11,13],[15,16,17]]\n<strong>输出：</strong>[15]\n<strong>解释：</strong>15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]\n<strong>输出：</strong>[12]\n<strong>解释：</strong>12 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[7,8],[1,2]]\n<strong>输出：</strong>[7]\n<strong>解释：</strong>7是唯一的幸运数字，因为它是行中的最小值，列中的最大值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 50</code></li>\n\t<li><code>1 &lt;=&nbsp;matrix[i][j]&nbsp;&lt;= 10^5</code></li>\n\t<li>矩阵中的所有元素都是不同的</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1381.设计一个支持增量操作的栈",
        "hardRate": "MEDIUM",
        "passRate": "72.42%",
        "problemsUrl": "https://leetcode.cn/problems/design-a-stack-with-increment-operation/",
        "solutionsUrl": "https://leetcode.cn/problems/design-a-stack-with-increment-operation/solution",
        "problemsDesc": "<p>请你设计一个支持对其元素进行增量操作的栈。</p>\n\n<p>实现自定义栈类 <code>CustomStack</code> ：</p>\n\n<ul>\n\t<li><code>CustomStack(int maxSize)</code>：用 <code>maxSize</code> 初始化对象，<code>maxSize</code> 是栈中最多能容纳的元素数量。</li>\n\t<li><code>void push(int x)</code>：如果栈还未增长到 <code>maxSize</code> ，就将 <code>x</code> 添加到栈顶。</li>\n\t<li><code>int pop()</code>：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 <strong>-1</strong> 。</li>\n\t<li><code>void inc(int k, int val)</code>：栈底的 <code>k</code> 个元素的值都增加 <code>val</code> 。如果栈中元素总数小于 <code>k</code> ，则栈中的所有元素都增加 <code>val</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n<strong>输出：</strong>\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n<strong>解释：</strong>\nCustomStack stk = new CustomStack(3); // 栈是空的 []\nstk.push(1);                          // 栈变为 [1]\nstk.push(2);                          // 栈变为 [1, 2]\nstk.pop();                            // 返回 2 --&gt; 返回栈顶值 2，栈变为 [1]\nstk.push(2);                          // 栈变为 [1, 2]\nstk.push(3);                          // 栈变为 [1, 2, 3]\nstk.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\nstk.increment(5, 100);                // 栈变为 [101, 102, 103]\nstk.increment(2, 100);                // 栈变为 [201, 202, 103]\nstk.pop();                            // 返回 103 --&gt; 返回栈顶值 103，栈变为 [201, 202]\nstk.pop();                            // 返回 202 --&gt; 返回栈顶值 202，栈变为 [201]\nstk.pop();                            // 返回 201 --&gt; 返回栈顶值 201，栈变为 []\nstk.pop();                            // 返回 -1 --&gt; 栈为空，返回 -1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= maxSize, x, k &lt;= 1000</code></li>\n\t<li><code>0 &lt;= val &lt;= 100</code></li>\n\t<li>每种方法 <code>increment</code>，<code>push</code> 以及 <code>pop</code> 分别最多调用 <code>1000</code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1382.将二叉搜索树变平衡",
        "hardRate": "MEDIUM",
        "passRate": "73.60%",
        "problemsUrl": "https://leetcode.cn/problems/balance-a-binary-search-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/balance-a-binary-search-tree/solution",
        "problemsDesc": "<p>给你一棵二叉搜索树，请你返回一棵&nbsp;<strong>平衡后</strong>&nbsp;的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。</p>\n\n<p>如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 <code>1</code> ，我们就称这棵二叉搜索树是&nbsp;<strong>平衡的</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/10/balance1-tree.jpg\" style=\"height: 319px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,null,2,null,3,null,4,null,null]\n<strong>输出：</strong>[2,1,3,null,null,null,4]\n<strong>解释：</strong>这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/08/10/balanced2-tree.jpg\" style=\"height: 145px; width: 224px;\" /></p>\n\n<pre>\n<strong>输入:</strong> root = [2,1,3]\n<strong>输出:</strong> [2,1,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树节点的数目在&nbsp;<code>[1, 10<sup>4</sup>]</code>&nbsp;范围内。</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1383.最大的团队表现值",
        "hardRate": "HARD",
        "passRate": "35.33%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-performance-of-a-team/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-performance-of-a-team/solution",
        "problemsDesc": "<p>公司有编号为 <code>1</code>&nbsp;到 <code>n</code>&nbsp;的 <code>n</code>&nbsp;个工程师，给你两个数组 <code>speed</code>&nbsp;和 <code>efficiency</code>&nbsp;，其中 <code>speed[i]</code>&nbsp;和 <code>efficiency[i]</code>&nbsp;分别代表第 <code>i</code>&nbsp;位工程师的速度和效率。请你返回由最多&nbsp;<code>k</code>&nbsp;个工程师组成的&nbsp;<strong>​​​​​​最大团队表现值</strong>&nbsp;，由于答案可能很大，请你返回结果对 <code>10^9 + 7</code> 取余后的结果。</p>\n\n<p><strong>团队表现值</strong>&nbsp;的定义为：一个团队中「所有工程师速度的和」乘以他们「效率值中的最小值」。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2\n<strong>输出：</strong>60\n<strong>解释：</strong>\n我们选择工程师 2（speed=10 且 efficiency=4）和工程师 5（speed=5 且 efficiency=7）。他们的团队表现值为 performance = (10 + 5) * min(4, 7) = 60 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3\n<strong>输出：</strong>68\n<strong>解释：\n</strong>此示例与第一个示例相同，除了 k = 3 。我们可以选择工程师 1 ，工程师 2 和工程师 5 得到最大的团队表现值。表现值为 performance = (2 + 10 + 5) * min(5, 4, 7) = 68 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4\n<strong>输出：</strong>72\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>speed.length == n</code></li>\n\t<li><code>efficiency.length == n</code></li>\n\t<li><code>1 &lt;= speed[i] &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= efficiency[i] &lt;= 10^8</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1384.按年度列出销售总额",
        "hardRate": "HARD",
        "passRate": "57.69%",
        "problemsUrl": "https://leetcode.cn/problems/total-sales-amount-by-year/",
        "solutionsUrl": "https://leetcode.cn/problems/total-sales-amount-by-year/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1385.两个数组间的距离值",
        "hardRate": "EASY",
        "passRate": "64.08%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-distance-value-between-two-arrays/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-distance-value-between-two-arrays/solution",
        "problemsDesc": "<p>给你两个整数数组&nbsp;<code>arr1</code>&nbsp;，&nbsp;<code>arr2</code>&nbsp;和一个整数&nbsp;<code>d</code>&nbsp;，请你返回两个数组之间的&nbsp;<strong>距离值</strong>&nbsp;。</p>\n\n<p>「<strong>距离值</strong>」<strong>&nbsp;</strong>定义为符合此距离要求的元素数目：对于元素&nbsp;<code>arr1[i]</code>&nbsp;，不存在任何元素&nbsp;<code>arr2[j]</code>&nbsp;满足 <code>|arr1[i]-arr2[j]| &lt;= d</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>\n对于 arr1[0]=4 我们有：\n|4-10|=6 &gt; d=2 \n|4-9|=5 &gt; d=2 \n|4-1|=3 &gt; d=2 \n|4-8|=4 &gt; d=2 \n所以 arr1[0]=4 符合距离要求\n\n对于 arr1[1]=5 我们有：\n|5-10|=5 &gt; d=2 \n|5-9|=4 &gt; d=2 \n|5-1|=4 &gt; d=2 \n|5-8|=3 &gt; d=2\n所以 arr1[1]=5 也符合距离要求\n\n对于 arr1[2]=8 我们有：\n<strong>|8-10|=2 &lt;= d=2</strong>\n<strong>|8-9|=1 &lt;= d=2</strong>\n|8-1|=7 &gt; d=2\n<strong>|8-8|=0 &lt;= d=2</strong>\n存在距离小于等于 2 的情况，不符合距离要求 \n\n故而只有 arr1[0]=4 和 arr1[1]=5 两个符合距离要求，距离值为 2</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr1.length, arr2.length &lt;= 500</code></li>\n\t<li><code>-10^3 &lt;= arr1[i], arr2[j] &lt;= 10^3</code></li>\n\t<li><code>0 &lt;= d &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1386.安排电影院座位",
        "hardRate": "MEDIUM",
        "passRate": "35.53%",
        "problemsUrl": "https://leetcode.cn/problems/cinema-seat-allocation/",
        "solutionsUrl": "https://leetcode.cn/problems/cinema-seat-allocation/solution",
        "problemsDesc": "<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/cinema_seats_1.png\" style=\"height: 149px; width: 400px;\"></p>\n\n<p>如上图所示，电影院的观影厅中有 <code>n</code>&nbsp;行座位，行编号从 1&nbsp;到 <code>n</code>&nbsp;，且每一行内总共有 10 个座位，列编号从 1 到 10 。</p>\n\n<p>给你数组&nbsp;<code>reservedSeats</code>&nbsp;，包含所有已经被预约了的座位。比如说，<code>researvedSeats[i]=[3,8]</code>&nbsp;，它表示第&nbsp;<strong>3</strong>&nbsp;行第&nbsp;<strong>8</strong>&nbsp;个座位被预约了。</p>\n\n<p>请你返回&nbsp;<strong>最多能安排多少个 4 人家庭</strong>&nbsp;。4 人家庭要占据&nbsp;<strong>同一行内连续&nbsp;</strong>的 4 个座位。隔着过道的座位（比方说 [3,3] 和 [3,4]）不是连续的座位，但是如果你可以将 4 人家庭拆成过道两边各坐 2 人，这样子是允许的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/cinema_seats_3.png\" style=\"height: 96px; width: 400px;\"></p>\n\n<pre><strong>输入：</strong>n = 3, reservedSeats = [[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]]\n<strong>输出：</strong>4\n<strong>解释：</strong>上图所示是最优的安排方案，总共可以安排 4 个家庭。蓝色的叉表示被预约的座位，橙色的连续座位表示一个 4 人家庭。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, reservedSeats = [[2,1],[1,8],[2,6]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 4, reservedSeats = [[4,3],[1,4],[4,6],[1,7]]\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^9</code></li>\n\t<li><code>1 &lt;=&nbsp;reservedSeats.length &lt;= min(10*n, 10^4)</code></li>\n\t<li><code>reservedSeats[i].length == 2</code></li>\n\t<li><code>1&nbsp;&lt;=&nbsp;reservedSeats[i][0] &lt;= n</code></li>\n\t<li><code>1 &lt;=&nbsp;reservedSeats[i][1] &lt;= 10</code></li>\n\t<li>所有&nbsp;<code>reservedSeats[i]</code> 都是互不相同的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1387.将整数按权重排序",
        "hardRate": "MEDIUM",
        "passRate": "69.53%",
        "problemsUrl": "https://leetcode.cn/problems/sort-integers-by-the-power-value/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-integers-by-the-power-value/solution",
        "problemsDesc": "<p>我们将整数 <code>x</code>&nbsp;的 <strong>权重</strong> 定义为按照下述规则将 <code>x</code>&nbsp;变成 <code>1</code>&nbsp;所需要的步数：</p>\n\n<ul>\n\t<li>如果&nbsp;<code>x</code>&nbsp;是偶数，那么&nbsp;<code>x = x / 2</code></li>\n\t<li>如果&nbsp;<code>x</code>&nbsp;是奇数，那么&nbsp;<code>x = 3 * x + 1</code></li>\n</ul>\n\n<p>比方说，x=3 的权重为 7 。因为 3 需要 7 步变成 1 （3 --&gt; 10 --&gt; 5 --&gt; 16 --&gt; 8 --&gt; 4 --&gt; 2 --&gt; 1）。</p>\n\n<p>给你三个整数&nbsp;<code>lo</code>，&nbsp;<code>hi</code> 和&nbsp;<code>k</code>&nbsp;。你的任务是将区间&nbsp;<code>[lo, hi]</code>&nbsp;之间的整数按照它们的权重&nbsp;<strong>升序排序&nbsp;</strong>，如果大于等于 2 个整数有&nbsp;<strong>相同</strong>&nbsp;的权重，那么按照数字自身的数值&nbsp;<strong>升序排序</strong>&nbsp;。</p>\n\n<p>请你返回区间&nbsp;<code>[lo, hi]</code>&nbsp;之间的整数按权重排序后的第&nbsp;<code>k</code>&nbsp;个数。</p>\n\n<p>注意，题目保证对于任意整数&nbsp;<code>x</code>&nbsp;<code>（lo &lt;= x &lt;= hi）</code>&nbsp;，它变成&nbsp;<code>1</code> 所需要的步数是一个 32 位有符号整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>lo = 12, hi = 15, k = 2\n<strong>输出：</strong>13\n<strong>解释：</strong>12 的权重为 9（12 --&gt; 6 --&gt; 3 --&gt; 10 --&gt; 5 --&gt; 16 --&gt; 8 --&gt; 4 --&gt; 2 --&gt; 1）\n13 的权重为 9\n14 的权重为 17\n15 的权重为 17\n区间内的数按权重排序以后的结果为 [12,13,14,15] 。对于 k = 2 ，答案是第二个整数也就是 13 。\n注意，12 和 13 有相同的权重，所以我们按照它们本身升序排序。14 和 15 同理。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>lo = 7, hi = 11, k = 4\n<strong>输出：</strong>7\n<strong>解释：</strong>区间内整数 [7, 8, 9, 10, 11] 对应的权重为 [16, 3, 19, 6, 14] 。\n按权重排序后得到的结果为 [8, 10, 11, 7, 9] 。\n排序后数组中第 4 个数字为 7 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= lo &lt;= hi &lt;= 1000</code></li>\n\t<li><code>1 &lt;= k &lt;= hi - lo + 1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1388.3n 块披萨",
        "hardRate": "HARD",
        "passRate": "56.49%",
        "problemsUrl": "https://leetcode.cn/problems/pizza-with-3n-slices/",
        "solutionsUrl": "https://leetcode.cn/problems/pizza-with-3n-slices/solution",
        "problemsDesc": "<p>给你一个披萨，它由 3n 块不同大小的部分组成，现在你和你的朋友们需要按照如下规则来分披萨：</p>\n\n<ul>\n\t<li>你挑选 <strong>任意</strong>&nbsp;一块披萨。</li>\n\t<li>Alice 将会挑选你所选择的披萨逆时针方向的下一块披萨。</li>\n\t<li>Bob 将会挑选你所选择的披萨顺时针方向的下一块披萨。</li>\n\t<li>重复上述过程直到没有披萨剩下。</li>\n</ul>\n\n<p>每一块披萨的大小按顺时针方向由循环数组 <code>slices</code>&nbsp;表示。</p>\n\n<p>请你返回你可以获得的披萨大小总和的最大值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/sample_3_1723.png\" style=\"height: 240px; width: 475px;\" /></p>\n\n<pre>\n<strong>输入：</strong>slices = [1,2,3,4,5,6]\n<strong>输出：</strong>10\n<strong>解释：</strong>选择大小为 4 的披萨，Alice 和 Bob 分别挑选大小为 3 和 5 的披萨。然后你选择大小为 6 的披萨，Alice 和 Bob 分别挑选大小为 2 和 1 的披萨。你获得的披萨总大小为 4 + 6 = 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/sample_4_1723.png\" style=\"height: 250px; width: 475px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>slices = [8,9,8,6,1,1]\n<strong>输出：</strong>16\n<strong>解释：</strong>两轮都选大小为 8 的披萨。如果你选择大小为 9 的披萨，你的朋友们就会选择大小为 8 的披萨，这种情况下你的总和不是最大的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= slices.length &lt;= 500</code></li>\n\t<li><code>slices.length % 3 == 0</code></li>\n\t<li><code>1 &lt;= slices[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1389.按既定顺序创建目标数组",
        "hardRate": "EASY",
        "passRate": "82.99%",
        "problemsUrl": "https://leetcode.cn/problems/create-target-array-in-the-given-order/",
        "solutionsUrl": "https://leetcode.cn/problems/create-target-array-in-the-given-order/solution",
        "problemsDesc": "<p>给你两个整数数组 <code>nums</code> 和 <code>index</code>。你需要按照以下规则创建目标数组：</p>\n\n<ul>\n\t<li>目标数组 <code>target</code> 最初为空。</li>\n\t<li>按从左到右的顺序依次读取 <code>nums[i]</code> 和 <code>index[i]</code>，在 <code>target</code> 数组中的下标 <code>index[i]</code> 处插入值 <code>nums[i]</code> 。</li>\n\t<li>重复上一步，直到在 <code>nums</code> 和 <code>index</code> 中都没有要读取的元素。</li>\n</ul>\n\n<p>请你返回目标数组。</p>\n\n<p>题目保证数字插入位置总是存在。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,2,3,4], index = [0,1,2,2,1]\n<strong>输出：</strong>[0,4,1,3,2]\n<strong>解释：</strong>\nnums       index     target\n0            0        [0]\n1            1        [0,1]\n2            2        [0,1,2]\n3            2        [0,1,3,2]\n4            1        [0,4,1,3,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,0], index = [0,1,2,3,0]\n<strong>输出：</strong>[0,1,2,3,4]\n<strong>解释：</strong>\nnums       index     target\n1            0        [1]\n2            1        [1,2]\n3            2        [1,2,3]\n4            3        [1,2,3,4]\n0            0        [0,1,2,3,4]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1], index = [0]\n<strong>输出：</strong>[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, index.length &lt;= 100</code></li>\n\t<li><code>nums.length == index.length</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>0 &lt;= index[i] &lt;= i</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1390.四因数",
        "hardRate": "MEDIUM",
        "passRate": "38.91%",
        "problemsUrl": "https://leetcode.cn/problems/four-divisors/",
        "solutionsUrl": "https://leetcode.cn/problems/four-divisors/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>，请你返回该数组中恰有四个因数的这些整数的各因数之和。如果数组中不存在满足题意的整数，则返回 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [21,4,7]\n<strong>输出：</strong>32\n<strong>解释：</strong>\n21 有 4 个因数：1, 3, 7, 21\n4 有 3 个因数：1, 2, 4\n7 有 2 个因数：1, 7\n答案仅为 21 的所有因数的和。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [21,21]\n<strong>输出:</strong> 64\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,3,4,5]\n<strong>输出:</strong> 0</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1391.检查网格中是否存在有效路径",
        "hardRate": "MEDIUM",
        "passRate": "41.98%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-there-is-a-valid-path-in-a-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-there-is-a-valid-path-in-a-grid/solution",
        "problemsDesc": "<p>给你一个 <em>m</em> x <em>n</em> 的网格 <code>grid</code>。网格里的每个单元都代表一条街道。<code>grid[i][j]</code> 的街道可以是：</p>\n\n<ul>\n\t<li><strong>1</strong> 表示连接左单元格和右单元格的街道。</li>\n\t<li><strong>2</strong> 表示连接上单元格和下单元格的街道。</li>\n\t<li><strong>3</strong>&nbsp;表示连接左单元格和下单元格的街道。</li>\n\t<li><strong>4</strong> 表示连接右单元格和下单元格的街道。</li>\n\t<li><strong>5</strong> 表示连接左单元格和上单元格的街道。</li>\n\t<li><strong>6</strong> 表示连接右单元格和上单元格的街道。</li>\n</ul>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/main.png\" style=\"height: 708px; width: 450px;\"></p>\n\n<p>你最开始从左上角的单元格 <code>(0,0)</code> 开始出发，网格中的「有效路径」是指从左上方的单元格 <code>(0,0)</code> 开始、一直到右下方的 <code>(m-1,n-1)</code> 结束的路径。<strong>该路径必须只沿着街道走</strong>。</p>\n\n<p><strong>注意：</strong>你 <strong>不能</strong> 变更街道。</p>\n\n<p>如果网格中存在有效的路径，则返回 <code>true</code>，否则返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/e1.png\" style=\"height: 311px; width: 455px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[2,4,3],[6,5,2]]\n<strong>输出：</strong>true\n<strong>解释：</strong>如图所示，你可以从 (0, 0) 开始，访问网格中的所有单元格并到达 (m - 1, n - 1) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/e2.png\" style=\"height: 293px; width: 455px;\"></p>\n\n<pre><strong>输入：</strong>grid = [[1,2,1],[1,2,1]]\n<strong>输出：</strong>false\n<strong>解释：</strong>如图所示，单元格 (0, 0) 上的街道没有与任何其他单元格上的街道相连，你只会停在 (0, 0) 处。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[1,1,2]]\n<strong>输出：</strong>false\n<strong>解释：</strong>你会停在 (0, 1)，而且无法到达 (0, 2) 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[1,1,1,1,1,1,3]]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[2],[2],[2],[2],[2],[2],[6]]\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1392.最长快乐前缀",
        "hardRate": "HARD",
        "passRate": "44.54%",
        "problemsUrl": "https://leetcode.cn/problems/longest-happy-prefix/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-happy-prefix/solution",
        "problemsDesc": "<p><strong>「快乐前缀」</strong>&nbsp;是在原字符串中既是&nbsp;<strong>非空</strong> 前缀也是后缀（不包括原字符串自身）的字符串。</p>\n\n<p>给你一个字符串 <code>s</code>，请你返回它的 <strong>最长快乐前缀</strong>。如果不存在满足题意的前缀，则返回一个空字符串<meta charset=\"UTF-8\" />&nbsp;<code>\"\"</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"level\"\n<strong>输出：</strong>\"l\"\n<strong>解释：</strong>不包括 s 自己，一共有 4 个前缀（\"l\", \"le\", \"lev\", \"leve\"）和 4 个后缀（\"l\", \"el\", \"vel\", \"evel\"）。最长的既是前缀也是后缀的字符串是 \"l\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ababab\"\n<strong>输出：</strong>\"abab\"\n<strong>解释：</strong>\"abab\" 是最长的既是前缀也是后缀的字符串。题目允许前后缀在原字符串中重叠。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 只含有小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1393.股票的资本损益",
        "hardRate": "MEDIUM",
        "passRate": "83.77%",
        "problemsUrl": "https://leetcode.cn/problems/capital-gainloss/",
        "solutionsUrl": "https://leetcode.cn/problems/capital-gainloss/solution",
        "problemsDesc": "<p><code>Stocks</code>&nbsp;表：</p>\n\n<pre>+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| stock_name    | varchar |\n| operation     | enum    |\n| operation_day | int     |\n| price         | int     |\n+---------------+---------+\n(stock_name, day) 是这张表的主键\noperation 列使用的是一种枚举类型，包括：(&#39;Sell&#39;,&#39;Buy&#39;)\n此表的每一行代表了名为 stock_name 的某支股票在 operation_day 这一天的操作价格。\n保证股票的每次&#39;Sell&#39;操作前，都有相应的&#39;Buy&#39;操作。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个SQL查询来报告每支股票的资本损益。</p>\n\n<p>股票的资本损益是一次或多次买卖股票后的全部收益或损失。</p>\n\n<p>以任意顺序返回结果即可。</p>\n\n<p>SQL查询结果的格式如下例所示：</p>\n\n<pre><code>Stocks</code> 表:\n+---------------+-----------+---------------+--------+\n| stock_name    | operation | operation_day | price  |\n+---------------+-----------+---------------+--------+\n| Leetcode      | Buy       | 1             | 1000   |\n| Corona Masks  | Buy       | 2             | 10     |\n| Leetcode      | Sell      | 5             | 9000   |\n| Handbags      | Buy       | 17            | 30000  |\n| Corona Masks  | Sell      | 3             | 1010   |\n| Corona Masks  | Buy       | 4             | 1000   |\n| Corona Masks  | Sell      | 5             | 500    |\n| Corona Masks  | Buy       | 6             | 1000   |\n| Handbags      | Sell      | 29            | 7000   |\n| Corona Masks  | Sell      | 10            | 10000  |\n+---------------+-----------+---------------+--------+\n\nResult 表:\n+---------------+-------------------+\n| stock_name    | capital_gain_loss |\n+---------------+-------------------+\n| Corona Masks  | 9500              |\n| Leetcode      | 8000              |\n| Handbags      | -23000            |\n+---------------+-------------------+\nLeetcode 股票在第一天以1000美元的价格买入，在第五天以9000美元的价格卖出。资本收益=9000-1000=8000美元。\nHandbags 股票在第17天以30000美元的价格买入，在第29天以7000美元的价格卖出。资本损失=7000-30000=-23000美元。\nCorona Masks 股票在第1天以10美元的价格买入，在第3天以1010美元的价格卖出。在第4天以1000美元的价格再次购买，在第5天以500美元的价格出售。最后，它在第6天以1000美元的价格被买走，在第10天以10000美元的价格被卖掉。资本损益是每次（&rsquo;Buy&#39;-&gt;&#39;Sell&#39;）操作资本收益或损失的和=（1010-10）+（500-1000）+（10000-1000）=1000-500+9000=9500美元。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1394.找出数组中的幸运数",
        "hardRate": "EASY",
        "passRate": "65.57%",
        "problemsUrl": "https://leetcode.cn/problems/find-lucky-integer-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/find-lucky-integer-in-an-array/solution",
        "problemsDesc": "<p>在整数数组中，如果一个整数的出现频次和它的数值大小相等，我们就称这个整数为「幸运数」。</p>\n\n<p>给你一个整数数组 <code>arr</code>，请你从中找出并返回一个幸运数。</p>\n\n<ul>\n\t<li>如果数组中存在多个幸运数，只需返回 <strong>最大</strong> 的那个。</li>\n\t<li>如果数组中不含幸运数，则返回 <strong>-1 </strong>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,2,3,4]\n<strong>输出：</strong>2\n<strong>解释：</strong>数组中唯一的幸运数是 2 ，因为数值 2 的出现频次也是 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,2,3,3,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>1、2 以及 3 都是幸运数，只需要返回其中最大的 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,2,2,3,3]\n<strong>输出：</strong>-1\n<strong>解释：</strong>数组中不存在幸运数。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [5]\n<strong>输出：</strong>-1\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [7,7,7,7,7,7,7]\n<strong>输出：</strong>7\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 500</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1395.统计作战单位数",
        "hardRate": "MEDIUM",
        "passRate": "71.30%",
        "problemsUrl": "https://leetcode.cn/problems/count-number-of-teams/",
        "solutionsUrl": "https://leetcode.cn/problems/count-number-of-teams/solution",
        "problemsDesc": "<p> <code>n</code> 名士兵站成一排。每个士兵都有一个 <strong>独一无二</strong> 的评分 <code>rating</code> 。</p>\n\n<p>每 <strong>3</strong> 个士兵可以组成一个作战单位，分组规则如下：</p>\n\n<ul>\n\t<li>从队伍中选出下标分别为 <code>i</code>、<code>j</code>、<code>k</code> 的 3 名士兵，他们的评分分别为 <code>rating[i]</code>、<code>rating[j]</code>、<code>rating[k]</code></li>\n\t<li>作战单位需满足： <code>rating[i] < rating[j] < rating[k]</code> 或者 <code>rating[i] > rating[j] > rating[k]</code> ，其中  <code>0 <= i < j < k < n</code></li>\n</ul>\n\n<p>请你返回按上述条件可以组建的作战单位数量。每个士兵都可以是多个作战单位的一部分。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rating = [2,5,3,4,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>我们可以组建三个作战单位 (2,3,4)、(5,4,1)、(5,3,1) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rating = [2,1,3]\n<strong>输出：</strong>0\n<strong>解释：</strong>根据题目条件，我们无法组建作战单位。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>rating = [1,2,3,4]\n<strong>输出：</strong>4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == rating.length</code></li>\n\t<li><code>3 <= n <= 1000</code></li>\n\t<li><code>1 <= rating[i] <= 10^5</code></li>\n\t<li><code>rating</code> 中的元素都是唯一的</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1396.设计地铁系统",
        "hardRate": "MEDIUM",
        "passRate": "41.92%",
        "problemsUrl": "https://leetcode.cn/problems/design-underground-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-underground-system/solution",
        "problemsDesc": "<p>地铁系统跟踪不同车站之间的乘客出行时间，并使用这一数据来计算从一站到另一站的平均时间。</p>\n\n<p>实现 <code>UndergroundSystem</code> 类：</p>\n\n<ul>\n\t<li><code>void checkIn(int id, string stationName, int t)</code>\n\n\t<ul>\n\t\t<li>通行卡 ID 等于 <code>id</code> 的乘客，在时间 <code>t</code> ，从 <code>stationName</code> 站进入</li>\n\t\t<li>乘客一次只能从一个站进入</li>\n\t</ul>\n\t</li>\n\t<li><code>void checkOut(int id, string stationName, int t)</code>\n\t<ul>\n\t\t<li>通行卡 ID 等于 <code>id</code> 的乘客，在时间 <code>t</code> ，从 <code>stationName</code> 站离开</li>\n\t</ul>\n\t</li>\n\t<li><code>double getAverageTime(string startStation, string endStation)</code>\n\t<ul>\n\t\t<li>返回从 <code>startStation</code> 站到 <code>endStation</code> 站的平均时间</li>\n\t\t<li>平均时间会根据截至目前所有从 <code>startStation</code> 站 <strong>直接</strong> 到达 <code>endStation</code> 站的行程进行计算，也就是从 <code>startStation</code> 站进入并从 <code>endStation</code> 离开的行程</li>\n\t\t<li>从 <code>startStation</code> 到 <code>endStation</code> 的行程时间与从 <code>endStation</code> 到 <code>startStation</code> 的行程时间可能不同</li>\n\t\t<li>在调用 <code>getAverageTime</code> 之前，至少有一名乘客从 <code>startStation</code> 站到达 <code>endStation</code> 站</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>你可以假设对 <code>checkIn</code> 和 <code>checkOut</code> 方法的所有调用都是符合逻辑的。如果一名乘客在时间 <code>t<sub>1</sub></code> 进站、时间 <code>t<sub>2</sub></code> 出站，那么 <code>t<sub>1</sub> &lt; t<sub>2</sub></code> 。所有时间都按时间顺序发生。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"]\n[[],[45,\"Leyton\",3],[32,\"Paradise\",8],[27,\"Leyton\",10],[45,\"Waterloo\",15],[27,\"Waterloo\",20],[32,\"Cambridge\",22],[\"Paradise\",\"Cambridge\"],[\"Leyton\",\"Waterloo\"],[10,\"Leyton\",24],[\"Leyton\",\"Waterloo\"],[10,\"Waterloo\",38],[\"Leyton\",\"Waterloo\"]]\n\n<strong>输出</strong>\n[null,null,null,null,null,null,null,14.00000,11.00000,null,11.00000,null,12.00000]\n\n<strong>解释</strong>\nUndergroundSystem undergroundSystem = new UndergroundSystem();\nundergroundSystem.checkIn(45, \"Leyton\", 3);\nundergroundSystem.checkIn(32, \"Paradise\", 8);\nundergroundSystem.checkIn(27, \"Leyton\", 10);\nundergroundSystem.checkOut(45, \"Waterloo\", 15);  // 乘客 45 \"Leyton\" -&gt; \"Waterloo\" ，用时 15-3 = 12\nundergroundSystem.checkOut(27, \"Waterloo\", 20);  // 乘客 27 \"Leyton\" -&gt; \"Waterloo\" ，用时 20-10 = 10\nundergroundSystem.checkOut(32, \"Cambridge\", 22); // 乘客 32 \"Paradise\" -&gt; \"Cambridge\" ，用时 22-8 = 14\nundergroundSystem.getAverageTime(\"Paradise\", \"Cambridge\"); // 返回 14.00000 。只有一个 \"Paradise\" -&gt; \"Cambridge\" 的行程，(14) / 1 = 14\nundergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\");    // 返回 11.00000 。有两个 \"Leyton\" -&gt; \"Waterloo\" 的行程，(10 + 12) / 2 = 11\nundergroundSystem.checkIn(10, \"Leyton\", 24);\nundergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\");    // 返回 11.00000\nundergroundSystem.checkOut(10, \"Waterloo\", 38);  // 乘客 10 \"Leyton\" -&gt; \"Waterloo\" ，用时 38-24 = 14\nundergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\");    // 返回 12.00000 。有三个 \"Leyton\" -&gt; \"Waterloo\" 的行程，(10 + 12 + 14) / 3 = 12\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"UndergroundSystem\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\",\"checkIn\",\"checkOut\",\"getAverageTime\"]\n[[],[10,\"Leyton\",3],[10,\"Paradise\",8],[\"Leyton\",\"Paradise\"],[5,\"Leyton\",10],[5,\"Paradise\",16],[\"Leyton\",\"Paradise\"],[2,\"Leyton\",21],[2,\"Paradise\",30],[\"Leyton\",\"Paradise\"]]\n\n<strong>输出</strong>\n[null,null,null,5.00000,null,null,5.50000,null,null,6.66667]\n\n<strong>解释</strong>\nUndergroundSystem undergroundSystem = new UndergroundSystem();\nundergroundSystem.checkIn(10, \"Leyton\", 3);\nundergroundSystem.checkOut(10, \"Paradise\", 8); // 乘客 10 \"Leyton\" -&gt; \"Paradise\" ，用时 8-3 = 5\nundergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // 返回 5.00000 ，(5) / 1 = 5\nundergroundSystem.checkIn(5, \"Leyton\", 10);\nundergroundSystem.checkOut(5, \"Paradise\", 16); // 乘客 5 \"Leyton\" -&gt; \"Paradise\" ，用时 16-10 = 6\nundergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // 返回 5.50000 ，(5 + 6) / 2 = 5.5\nundergroundSystem.checkIn(2, \"Leyton\", 21);\nundergroundSystem.checkOut(2, \"Paradise\", 30); // 乘客 2 \"Leyton\" -&gt; \"Paradise\" ，用时 30-21 = 9\nundergroundSystem.getAverageTime(\"Leyton\", \"Paradise\"); // 返回 6.66667 ，(5 + 6 + 9) / 3 = 6.66667\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= id, t &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= stationName.length, startStation.length, endStation.length &lt;= 10</code> 次</li>\n\t<li>所有字符串由大小写英文字母与数字组成</li>\n\t<li>总共最多调用 <code>checkIn</code>、<code>checkOut</code> 和 <code>getAverageTime</code> 方法 <code>2 * 10<sup>4 </sup></code></li>\n\t<li>与标准答案误差在 <code>10<sup>-5</sup></code> 以内的结果都被视为正确结果</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1397.找到所有好字符串",
        "hardRate": "HARD",
        "passRate": "43.73%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-good-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-good-strings/solution",
        "problemsDesc": "<p>给你两个长度为 <code>n</code>&nbsp;的字符串&nbsp;<code>s1</code> 和&nbsp;<code>s2</code>&nbsp;，以及一个字符串&nbsp;<code>evil</code>&nbsp;。请你返回 <strong>好字符串&nbsp;</strong>的数目。</p>\n\n<p><strong>好字符串</strong>&nbsp;的定义为：它的长度为&nbsp;<code>n</code>&nbsp;，字典序大于等于&nbsp;<code>s1</code>&nbsp;，字典序小于等于&nbsp;<code>s2</code>&nbsp;，且不包含&nbsp;<code>evil</code>&nbsp;为子字符串。</p>\n\n<p>由于答案可能很大，请你返回答案对 10^9 + 7 取余的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, s1 = &quot;aa&quot;, s2 = &quot;da&quot;, evil = &quot;b&quot;\n<strong>输出：</strong>51 \n<strong>解释：</strong>总共有 25 个以 &#39;a&#39; 开头的好字符串：&quot;aa&quot;，&quot;ac&quot;，&quot;ad&quot;，...，&quot;az&quot;。还有 25 个以 &#39;c&#39; 开头的好字符串：&quot;ca&quot;，&quot;cc&quot;，&quot;cd&quot;，...，&quot;cz&quot;。最后，还有一个以 &#39;d&#39; 开头的好字符串：&quot;da&quot;。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 8, s1 = &quot;leetcode&quot;, s2 = &quot;leetgoes&quot;, evil = &quot;leet&quot;\n<strong>输出：</strong>0 \n<strong>解释：</strong>所有字典序大于等于 s1 且小于等于 s2 的字符串都以 evil 字符串 &quot;leet&quot; 开头。所以没有好字符串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, s1 = &quot;gx&quot;, s2 = &quot;gz&quot;, evil = &quot;x&quot;\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s1.length == n</code></li>\n\t<li><code>s2.length == n</code></li>\n\t<li><code>s1 &lt;= s2</code></li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>1 &lt;= evil.length &lt;= 50</code></li>\n\t<li>所有字符串都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1398.购买了产品 A 和产品 B 却没有购买产品 C 的顾客",
        "hardRate": "MEDIUM",
        "passRate": "72.16%",
        "problemsUrl": "https://leetcode.cn/problems/customers-who-bought-products-a-and-b-but-not-c/",
        "solutionsUrl": "https://leetcode.cn/problems/customers-who-bought-products-a-and-b-but-not-c/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1399.统计最大组的数目",
        "hardRate": "EASY",
        "passRate": "67.04%",
        "problemsUrl": "https://leetcode.cn/problems/count-largest-group/",
        "solutionsUrl": "https://leetcode.cn/problems/count-largest-group/solution",
        "problemsDesc": "<p>给你一个整数 <code>n</code>&nbsp;。请你先求出从 <code>1</code>&nbsp;到 <code>n</code> 的每个整数 10 进制表示下的数位和（每一位上的数字相加），然后把数位和相等的数字放到同一个组中。</p>\n\n<p>请你统计每个组中的数字数目，并返回数字数目并列最多的组有多少个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 13\n<strong>输出：</strong>4\n<strong>解释：</strong>总共有 9 个组，将 1 到 13 按数位求和后这些组分别是：\n[1,10]，[2,11]，[3,12]，[4,13]，[5]，[6]，[7]，[8]，[9]。总共有 4 个组拥有的数字并列最多。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>总共有 2 个大小为 1 的组 [1]，[2]。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 15\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 24\n<strong>输出：</strong>5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1400.构造 K 个回文字符串",
        "hardRate": "MEDIUM",
        "passRate": "61.29%",
        "problemsUrl": "https://leetcode.cn/problems/construct-k-palindrome-strings/",
        "solutionsUrl": "https://leetcode.cn/problems/construct-k-palindrome-strings/solution",
        "problemsDesc": "<p>给你一个字符串 <code>s</code>&nbsp;和一个整数 <code>k</code>&nbsp;。请你用 <code>s</code>&nbsp;字符串中 <strong>所有字符</strong>&nbsp;构造 <code>k</code>&nbsp;个非空 <strong>回文串</strong>&nbsp;。</p>\n\n<p>如果你可以用&nbsp;<code>s</code>&nbsp;中所有字符构造&nbsp;<code>k</code>&nbsp;个回文字符串，那么请你返回 <strong>True</strong>&nbsp;，否则返回&nbsp;<strong>False</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;annabelle&quot;, k = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>可以用 s 中所有字符构造 2 个回文字符串。\n一些可行的构造方案包括：&quot;anna&quot; + &quot;elble&quot;，&quot;anbna&quot; + &quot;elle&quot;，&quot;anellena&quot; + &quot;b&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;leetcode&quot;, k = 3\n<strong>输出：</strong>false\n<strong>解释：</strong>无法用 s 中所有字符构造 3 个回文串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;true&quot;, k = 4\n<strong>输出：</strong>true\n<strong>解释：</strong>唯一可行的方案是让 s 中每个字符单独构成一个字符串。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;yzyzyzyzyzyzyzy&quot;, k = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>你只需要将所有的 z 放在一个字符串中，所有的 y 放在另一个字符串中。那么两个字符串都是回文串。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = &quot;cr&quot;, k = 7\n<strong>输出：</strong>false\n<strong>解释：</strong>我们没有足够的字符去构造 7 个回文串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>s</code>&nbsp;中所有字符都是小写英文字母。</li>\n\t<li><code>1 &lt;= k &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1401.圆和矩形是否有重叠",
        "hardRate": "MEDIUM",
        "passRate": "51.69%",
        "problemsUrl": "https://leetcode.cn/problems/circle-and-rectangle-overlapping/",
        "solutionsUrl": "https://leetcode.cn/problems/circle-and-rectangle-overlapping/solution",
        "problemsDesc": "<p>给你一个以 <code>(radius, xCenter, yCenter)</code> 表示的圆和一个与坐标轴平行的矩形 <code>(x1, y1, x2, y2)</code> ，其中 <code>(x1, y1)</code> 是矩形左下角的坐标，而 <code>(x2, y2)</code> 是右上角的坐标。</p>\n\n<p>如果圆和矩形有重叠的部分，请你返回 <code>true</code> ，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>换句话说，请你检测是否 <strong>存在</strong> 点 <code>(x<sub>i</sub>, y<sub>i</sub>)</code> ，它既在圆上也在矩形上（两者都包括点落在边界上的情况）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1 ：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/20/sample_4_1728.png\" style=\"width: 258px; height: 167px;\" />\n<pre>\n<strong>输入：</strong>radius = 1, xCenter = 0, yCenter = 0, x1 = 1, y1 = -1, x2 = 3, y2 = 1\n<strong>输出：</strong>true\n<strong>解释：</strong>圆和矩形存在公共点 (1,0) 。\n</pre>\n\n<p><strong class=\"example\">示例 2 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>radius = 1, xCenter = 1, yCenter = 1, x1 = 1, y1 = -3, x2 = 2, y2 = -1\n<strong>输出：</strong>false\n</pre>\n\n<p><strong class=\"example\">示例 3 ：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/20/sample_2_1728.png\" style=\"width: 150px; height: 135px;\" />\n<pre>\n<strong>输入：</strong>radius = 1, xCenter = 0, yCenter = 0, x1 = -1, y1 = 0, x2 = 0, y2 = 1\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= radius &lt;= 2000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= xCenter, yCenter &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= x1 &lt; x2 &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= y1 &lt; y2 &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1402.做菜顺序",
        "hardRate": "HARD",
        "passRate": "76.08%",
        "problemsUrl": "https://leetcode.cn/problems/reducing-dishes/",
        "solutionsUrl": "https://leetcode.cn/problems/reducing-dishes/solution",
        "problemsDesc": "<p>一个厨师收集了他&nbsp;<code>n</code>&nbsp;道菜的满意程度&nbsp;<code>satisfaction</code>&nbsp;，这个厨师做出每道菜的时间都是 1 单位时间。</p>\n\n<p>一道菜的 「喜爱时间」系数定义为烹饪这道菜以及之前每道菜所花费的时间乘以这道菜的满意程度，也就是&nbsp;<code>time[i]</code>*<code>satisfaction[i]</code>&nbsp;。</p>\n\n<p>请你返回做完所有菜 「喜爱时间」总和的最大值为多少。</p>\n\n<p>你可以按&nbsp;<strong>任意</strong>&nbsp;顺序安排做菜的顺序，你也可以选择放弃做某些菜来获得更大的总和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>satisfaction = [-1,-8,0,5,-9]\n<strong>输出：</strong>14\n<strong>解释：</strong>去掉第二道和最后一道菜，最大的喜爱时间系数和为 (-1*1 + 0*2 + 5*3 = 14) 。每道菜都需要花费 1 单位时间完成。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>satisfaction = [4,3,2]\n<strong>输出：</strong>20\n<strong>解释：</strong>按照原来顺序相反的时间做菜 (2*1 + 3*2 + 4*3 = 20)\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>satisfaction = [-1,-4,-5]\n<strong>输出：</strong>0\n<strong>解释：</strong>大家都不喜欢这些菜，所以不做任何菜可以获得最大的喜爱时间系数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == satisfaction.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>-1000 &lt;= satisfaction[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1403.非递增顺序的最小子序列",
        "hardRate": "EASY",
        "passRate": "73.33%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-subsequence-in-non-increasing-order/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-subsequence-in-non-increasing-order/solution",
        "problemsDesc": "<p>给你一个数组 <code>nums</code>，请你从中抽取一个子序列，满足该子序列的元素之和 <strong>严格</strong> 大于未包含在该子序列中的各元素之和。</p>\n\n<p>如果存在多个解决方案，只需返回 <strong>长度最小</strong> 的子序列。如果仍然有多个解决方案，则返回 <strong>元素之和最大</strong> 的子序列。</p>\n\n<p>与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。</p>\n\n<p><strong>注意</strong>，题目数据保证满足所有约束条件的解决方案是 <strong>唯一</strong> 的。同时，返回的答案应当按 <strong>非递增顺序</strong> 排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,3,10,9,8]\n<strong>输出：</strong>[10,9] \n<strong>解释：</strong>子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。&nbsp;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,4,7,6,7]\n<strong>输出：</strong>[7,7,6] \n<strong>解释：</strong>子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。  \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [6]\n<strong>输出：</strong>[6]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1404.将二进制表示减到 1 的步骤数",
        "hardRate": "MEDIUM",
        "passRate": "50.91%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/solution",
        "problemsDesc": "<p>给你一个以二进制形式表示的数字 <code>s</code> 。请你返回按下述规则将其减少到 1 所需要的步骤数：</p>\n\n<ul>\n\t<li>\n\t<p>如果当前数字为偶数，则将其除以 2 。</p>\n\t</li>\n\t<li>\n\t<p>如果当前数字为奇数，则将其加上 1 。</p>\n\t</li>\n</ul>\n\n<p>题目保证你总是可以按上述规则将测试用例变为 1 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1101&quot;\n<strong>输出：</strong>6\n<strong>解释：</strong>&quot;1101&quot; 表示十进制数 13 。\nStep 1) 13 是奇数，加 1 得到 14&nbsp;\nStep 2) 14 是偶数，除 2 得到 7\nStep 3) 7  是奇数，加 1 得到 8\nStep 4) 8  是偶数，除 2 得到 4&nbsp; \nStep 5) 4  是偶数，除 2 得到 2&nbsp;\nStep 6) 2  是偶数，除 2 得到 1&nbsp; \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;10&quot;\n<strong>输出：</strong>1\n<strong>解释：</strong>&quot;10&quot; 表示十进制数 2 。\nStep 1) 2 是偶数，除 2 得到 1 \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1&quot;\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length&nbsp;&lt;= 500</code></li>\n\t<li><code>s</code> 由字符 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code> 组成。</li>\n\t<li><code>s[0] == &#39;1&#39;</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1405.最长快乐字符串",
        "hardRate": "MEDIUM",
        "passRate": "63.56%",
        "problemsUrl": "https://leetcode.cn/problems/longest-happy-string/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-happy-string/solution",
        "problemsDesc": "<p>如果字符串中不含有任何 <code>&#39;aaa&#39;</code>，<code>&#39;bbb&#39;</code> 或 <code>&#39;ccc&#39;</code> 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。</p>\n\n<p>给你三个整数 <code>a</code>，<code>b</code> ，<code>c</code>，请你返回 <strong>任意一个</strong> 满足下列全部条件的字符串 <code>s</code>：</p>\n\n<ul>\n\t<li><code>s</code> 是一个尽可能长的快乐字符串。</li>\n\t<li><code>s</code> 中 <strong>最多</strong> 有<code>a</code> 个字母 <code>&#39;a&#39;</code>、<code>b</code>&nbsp;个字母 <code>&#39;b&#39;</code>、<code>c</code> 个字母 <code>&#39;c&#39;</code> 。</li>\n\t<li><code>s </code>中只含有 <code>&#39;a&#39;</code>、<code>&#39;b&#39;</code> 、<code>&#39;c&#39;</code> 三种字母。</li>\n</ul>\n\n<p>如果不存在这样的字符串 <code>s</code> ，请返回一个空字符串 <code>&quot;&quot;</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>a = 1, b = 1, c = 7\n<strong>输出：</strong>&quot;ccaccbcc&quot;\n<strong>解释：</strong>&quot;ccbccacc&quot; 也是一种正确答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>a = 2, b = 2, c = 1\n<strong>输出：</strong>&quot;aabbc&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>a = 7, b = 1, c = 0\n<strong>输出：</strong>&quot;aabaa&quot;\n<strong>解释：</strong>这是该测试用例的唯一正确答案。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= a, b, c &lt;= 100</code></li>\n\t<li><code>a + b + c &gt; 0</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1406.石子游戏 III",
        "hardRate": "HARD",
        "passRate": "59.18%",
        "problemsUrl": "https://leetcode.cn/problems/stone-game-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/stone-game-iii/solution",
        "problemsDesc": "<p>Alice 和 Bob 继续他们的石子游戏。几堆石子 <strong>排成一行</strong> ，每堆石子都对应一个得分，由数组 <code>stoneValue</code> 给出。</p>\n\n<p>Alice 和 Bob 轮流取石子，<strong>Alice</strong> 总是先开始。在每个玩家的回合中，该玩家可以拿走剩下石子中的的前 <strong>1、2 或 3 堆石子</strong> 。比赛一直持续到所有石头都被拿走。</p>\n\n<p>每个玩家的最终得分为他所拿到的每堆石子的对应得分之和。每个玩家的初始分数都是 <strong>0</strong> 。</p>\n\n<p>比赛的目标是决出最高分，得分最高的选手将会赢得比赛，比赛也可能会出现平局。</p>\n\n<p>假设 Alice 和 Bob 都采取 <strong>最优策略</strong> 。</p>\n\n<p>如果 Alice 赢了就返回 <code>\"Alice\"</code> <em>，</em>Bob 赢了就返回<em> </em><code>\"Bob\"</code><em>，</em>分数相同返回 <code>\"Tie\"</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>values = [1,2,3,7]\n<strong>输出：</strong>\"Bob\"\n<strong>解释：</strong>Alice 总是会输，她的最佳选择是拿走前三堆，得分变成 6 。但是 Bob 的得分为 7，Bob 获胜。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>values = [1,2,3,-9]\n<strong>输出：</strong>\"Alice\"\n<strong>解释：</strong>Alice 要想获胜就必须在第一个回合拿走前三堆石子，给 Bob 留下负分。\n如果 Alice 只拿走第一堆，那么她的得分为 1，接下来 Bob 拿走第二、三堆，得分为 5 。之后 Alice 只能拿到分数 -9 的石子堆，输掉比赛。\n如果 Alice 拿走前两堆，那么她的得分为 3，接下来 Bob 拿走第三堆，得分为 3 。之后 Alice 只能拿到分数 -9 的石子堆，同样会输掉比赛。\n注意，他们都应该采取 <strong>最优策略 </strong>，所以在这里 Alice 将选择能够使她获胜的方案。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>values = [1,2,3,6]\n<strong>输出：</strong>\"Tie\"\n<strong>解释：</strong>Alice 无法赢得比赛。如果她决定选择前三堆，她可以以平局结束比赛，否则她就会输。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= stoneValue.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-1000&nbsp;&lt;= stoneValue[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1407.排名靠前的旅行者",
        "hardRate": "EASY",
        "passRate": "56.78%",
        "problemsUrl": "https://leetcode.cn/problems/top-travellers/",
        "solutionsUrl": "https://leetcode.cn/problems/top-travellers/solution",
        "problemsDesc": "<p>表：<code>Users</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| name          | varchar |\n+---------------+---------+\nid 是该表单主键。\nname 是用户名字。</pre>\n\n<p> </p>\n\n<p>表：<code>Rides</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| user_id       | int     |\n| distance      | int     |\n+---------------+---------+\nid 是该表单主键。\nuser_id 是本次行程的用户的 id, 而该用户此次行程距离为 distance 。\n</pre>\n\n<p> </p>\n\n<p>写一段 SQL , 报告每个用户的旅行距离。</p>\n\n<p>返回的结果表单，以 <code>travelled_distance</code> <strong>降序排列</strong> ，如果有两个或者更多的用户旅行了相同的距离, 那么再以 <code>name</code> <strong>升序排列</strong> 。</p>\n\n<p>查询结果格式如下例所示。</p>\n\n<pre>\nUsers 表：\n+------+-----------+\n| id   | name      |\n+------+-----------+\n| 1    | Alice     |\n| 2    | Bob       |\n| 3    | Alex      |\n| 4    | Donald    |\n| 7    | Lee       |\n| 13   | Jonathan  |\n| 19   | Elvis     |\n+------+-----------+\n\nRides 表：\n+------+----------+----------+\n| id   | user_id  | distance |\n+------+----------+----------+\n| 1    | 1        | 120      |\n| 2    | 2        | 317      |\n| 3    | 3        | 222      |\n| 4    | 7        | 100      |\n| 5    | 13       | 312      |\n| 6    | 19       | 50       |\n| 7    | 7        | 120      |\n| 8    | 19       | 400      |\n| 9    | 7        | 230      |\n+------+----------+----------+\n\nResult 表：\n+----------+--------------------+\n| name     | travelled_distance |\n+----------+--------------------+\n| Elvis    | 450                |\n| Lee      | 450                |\n| Bob      | 317                |\n| Jonathan | 312                |\n| Alex     | 222                |\n| Alice    | 120                |\n| Donald   | 0                  |\n+----------+--------------------+\nElvis 和 Lee 旅行了 450 英里，Elvis 是排名靠前的旅行者，因为他的名字在字母表上的排序比 Lee 更小。\nBob, Jonathan, Alex 和 Alice 只有一次行程，我们只按此次行程的全部距离对他们排序。\nDonald 没有任何行程, 他的旅行距离为 0。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1408.数组中的字符串匹配",
        "hardRate": "EASY",
        "passRate": "64.38%",
        "problemsUrl": "https://leetcode.cn/problems/string-matching-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/string-matching-in-an-array/solution",
        "problemsDesc": "<p>给你一个字符串数组 <code>words</code> ，数组中的每个字符串都可以看作是一个单词。请你按 <strong>任意</strong> 顺序返回 <code>words</code> 中是其他单词的子字符串的所有单词。</p>\n\n<p>如果你可以删除 <code>words[j]</code>&nbsp;最左侧和/或最右侧的若干字符得到 <code>words[i]</code> ，那么字符串 <code>words[i]</code> 就是 <code>words[j]</code> 的一个子字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"mass\",\"as\",\"hero\",\"superhero\"]\n<strong>输出：</strong>[\"as\",\"hero\"]\n<strong>解释：</strong>\"as\" 是 \"mass\" 的子字符串，\"hero\" 是 \"superhero\" 的子字符串。\n[\"hero\",\"as\"] 也是有效的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"leetcode\",\"et\",\"code\"]\n<strong>输出：</strong>[\"et\",\"code\"]\n<strong>解释：</strong>\"et\" 和 \"code\" 都是 \"leetcode\" 的子字符串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"blue\",\"green\",\"bu\"]\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li><code>words[i]</code> 仅包含小写英文字母。</li>\n\t<li>题目数据 <strong>保证</strong> 每个 <code>words[i]</code> 都是独一无二的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1409.查询带键的排列",
        "hardRate": "MEDIUM",
        "passRate": "81.38%",
        "problemsUrl": "https://leetcode.cn/problems/queries-on-a-permutation-with-key/",
        "solutionsUrl": "https://leetcode.cn/problems/queries-on-a-permutation-with-key/solution",
        "problemsDesc": "<p>给你一个待查数组 <code>queries</code> ，数组中的元素为 <code>1</code> 到 <code>m</code> 之间的正整数。 请你根据以下规则处理所有待查项 <code>queries[i]</code>（从 <code>i=0</code> 到 <code>i=queries.length-1</code>）：</p>\n\n<ul>\n\t<li>一开始，排列 <code>P=[1,2,3,...,m]</code>。</li>\n\t<li>对于当前的 <code>i</code> ，请你找出待查项 <code>queries[i]</code> 在排列 <code>P</code> 中的位置（<strong>下标从 0 开始</strong>），然后将其从原位置移动到排列 <code>P</code> 的起始位置（即下标为 0 处）。注意， <code>queries[i]</code> 在 <code>P</code> 中的位置就是 <code>queries[i]</code> 的查询结果。</li>\n</ul>\n\n<p>请你以数组形式返回待查数组&nbsp; <code>queries</code> 的查询结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>queries = [3,1,2,1], m = 5\n<strong>输出：</strong>[2,1,2,1] \n<strong>解释：</strong>待查数组 queries 处理如下：\n对于 i=0: queries[i]=3, P=[1,2,3,4,5], 3 在 P 中的位置是 <strong>2</strong>，接着我们把 3 移动到 P 的起始位置，得到 P=[3,1,2,4,5] 。\n对于 i=1: queries[i]=1, P=[3,1,2,4,5], 1 在 P 中的位置是 <strong>1</strong>，接着我们把 1 移动到 P 的起始位置，得到 P=[1,3,2,4,5] 。 \n对于 i=2: queries[i]=2, P=[1,3,2,4,5], 2 在 P 中的位置是 <strong>2</strong>，接着我们把 2 移动到 P 的起始位置，得到 P=[2,1,3,4,5] 。\n对于 i=3: queries[i]=1, P=[2,1,3,4,5], 1 在 P 中的位置是 <strong>1</strong>，接着我们把 1 移动到 P 的起始位置，得到 P=[1,2,3,4,5] 。 \n因此，返回的结果数组为 [2,1,2,1] 。  \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>queries = [4,1,2,2], m = 4\n<strong>输出：</strong>[3,1,2,0]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>queries = [7,5,5,8,3], m = 8\n<strong>输出：</strong>[6,5,0,7,5]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m &lt;= 10^3</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= m</code></li>\n\t<li><code>1 &lt;= queries[i] &lt;= m</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1410.HTML 实体解析器",
        "hardRate": "MEDIUM",
        "passRate": "47.00%",
        "problemsUrl": "https://leetcode.cn/problems/html-entity-parser/",
        "solutionsUrl": "https://leetcode.cn/problems/html-entity-parser/solution",
        "problemsDesc": "<p>「HTML&nbsp;实体解析器」 是一种特殊的解析器，它将 HTML 代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。</p>\n\n<p>HTML 里这些特殊字符和它们对应的字符实体包括：</p>\n\n<ul>\n\t<li><strong>双引号：</strong>字符实体为&nbsp;<code>&amp;quot;</code>&nbsp;，对应的字符是&nbsp;<code>&quot;</code>&nbsp;。</li>\n\t<li><strong>单引号：</strong>字符实体为&nbsp;<code>&amp;apos;</code>&nbsp;，对应的字符是&nbsp;<code>&#39;</code>&nbsp;。</li>\n\t<li><strong>与符号：</strong>字符实体为&nbsp;<code>&amp;amp;</code>&nbsp;，对应对的字符是&nbsp;<code>&amp;</code>&nbsp;。</li>\n\t<li><strong>大于号：</strong>字符实体为&nbsp;<code>&amp;gt;</code>&nbsp;，对应的字符是&nbsp;<code>&gt;</code>&nbsp;。</li>\n\t<li><strong>小于号：</strong>字符实体为&nbsp;<code>&amp;lt;</code>&nbsp;，对应的字符是&nbsp;<code>&lt;</code>&nbsp;。</li>\n\t<li><strong>斜线号：</strong>字符实体为&nbsp;<code>&amp;frasl;</code>&nbsp;，对应的字符是&nbsp;<code>/</code>&nbsp;。</li>\n</ul>\n\n<p>给你输入字符串&nbsp;<code>text</code>&nbsp;，请你实现一个 HTML&nbsp;实体解析器，返回解析器解析后的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = &quot;&amp;amp; is an HTML entity but &amp;ambassador; is not.&quot;\n<strong>输出：</strong>&quot;&amp; is an HTML entity but &amp;ambassador; is not.&quot;\n<strong>解释：</strong>解析器把字符实体 &amp;amp; 用 &amp; 替换\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = &quot;and I quote: &amp;quot;...&amp;quot;&quot;\n<strong>输出：</strong>&quot;and I quote: \\&quot;...\\&quot;&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = &quot;Stay home! Practice on Leetcode :)&quot;\n<strong>输出：</strong>&quot;Stay home! Practice on Leetcode :)&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = &quot;x &amp;gt; y &amp;amp;&amp;amp; x &amp;lt; y is always false&quot;\n<strong>输出：</strong>&quot;x &gt; y &amp;&amp; x &lt; y is always false&quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>text = &quot;leetcode.com&amp;frasl;problemset&amp;frasl;all&quot;\n<strong>输出：</strong>&quot;leetcode.com/problemset/all&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 10^5</code></li>\n\t<li>字符串可能包含 256 个ASCII 字符中的任意字符。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1411.给 N x 3 网格图涂色的方案数",
        "hardRate": "HARD",
        "passRate": "57.19%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-paint-n-3-grid/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-paint-n-3-grid/solution",
        "problemsDesc": "<p>你有一个 <code>n x 3</code>&nbsp;的网格图 <code>grid</code>&nbsp;，你需要用 <strong>红，黄，绿</strong>&nbsp;三种颜色之一给每一个格子上色，且确保相邻格子颜色不同（也就是有相同水平边或者垂直边的格子颜色不同）。</p>\n\n<p>给你网格图的行数 <code>n</code>&nbsp;。</p>\n\n<p>请你返回给&nbsp;<code>grid</code>&nbsp;涂色的方案数。由于答案可能会非常大，请你返回答案对&nbsp;<code>10^9 + 7</code>&nbsp;取余的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>12\n<strong>解释：</strong>总共有 12 种可行的方法：\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/12/e1.png\" style=\"height: 289px; width: 450px;\">\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>54\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 3\n<strong>输出：</strong>246\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 7\n<strong>输出：</strong>106494\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>n = 5000\n<strong>输出：</strong>30228214\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>grid[i].length == 3</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1412.查找成绩处于中游的学生",
        "hardRate": "HARD",
        "passRate": "54.40%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-quiet-students-in-all-exams/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-quiet-students-in-all-exams/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1413.逐步求和得到正数的最小值",
        "hardRate": "EASY",
        "passRate": "73.06%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-value-to-get-positive-step-by-step-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-value-to-get-positive-step-by-step-sum/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>&nbsp;。你可以选定任意的&nbsp;<strong>正数</strong> startValue 作为初始值。</p>\n\n<p>你需要从左到右遍历 <code>nums</code>&nbsp;数组，并将 startValue 依次累加上&nbsp;<code>nums</code>&nbsp;数组中的值。</p>\n\n<p>请你在确保累加和始终大于等于 1 的前提下，选出一个最小的&nbsp;<strong>正数</strong>&nbsp;作为 startValue 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-3,2,-3,4,2]\n<strong>输出：</strong>5\n<strong>解释：</strong>如果你选择 startValue = 4，在第三次累加时，和小于 1 。\n<strong>                累加求和\n&nbsp;               startValue = 4 | startValue = 5 | nums\n</strong>&nbsp;                 (4 <strong>-3</strong> ) = 1  | (5 <strong>-3</strong> ) = 2    |  -3\n&nbsp;                 (1 <strong>+2</strong> ) = 3  | (2 <strong>+2</strong> ) = 4    |   2\n&nbsp;                 (3 <strong>-3</strong> ) = 0  | (4 <strong>-3</strong> ) = 1    |  -3\n&nbsp;                 (0 <strong>+4</strong> ) = 4  | (1 <strong>+4</strong> ) = 5    |   4\n&nbsp;                 (4 <strong>+2</strong> ) = 6  | (5 <strong>+2</strong> ) = 7    |   2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>最小的 startValue 需要是正数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,-2,-3]\n<strong>输出：</strong>5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1414.和为 K 的最少斐波那契数字数目",
        "hardRate": "MEDIUM",
        "passRate": "70.36%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/solution",
        "problemsDesc": "<p>给你数字 <code>k</code>&nbsp;，请你返回和为&nbsp;<code>k</code>&nbsp;的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。</p>\n\n<p>斐波那契数字定义为：</p>\n\n<ul>\n\t<li>F<sub>1</sub> = 1</li>\n\t<li>F<sub>2</sub> = 1</li>\n\t<li>F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub>&nbsp;， 其中 n &gt; 2 。</li>\n</ul>\n\n<p>数据保证对于给定的 <code>k</code>&nbsp;，一定能找到可行解。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>k = 7\n<strong>输出：</strong>2 \n<strong>解释：</strong>斐波那契数字为：1，1，2，3，5，8，13，&hellip;&hellip;\n对于 k = 7 ，我们可以得到 2 + 5 = 7 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>k = 10\n<strong>输出：</strong>2 \n<strong>解释：</strong>对于 k = 10 ，我们可以得到 2 + 8 = 10 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>k = 19\n<strong>输出：</strong>3 \n<strong>解释：</strong>对于 k = 19 ，我们可以得到 1 + 5 + 13 = 19 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1415.长度为 n 的开心字符串中字典序第 k 小的字符串",
        "hardRate": "MEDIUM",
        "passRate": "68.62%",
        "problemsUrl": "https://leetcode.cn/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/",
        "solutionsUrl": "https://leetcode.cn/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/solution",
        "problemsDesc": "<p>一个 「开心字符串」定义为：</p>\n\n<ul>\n\t<li>仅包含小写字母&nbsp;<code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code>.</li>\n\t<li>对所有在&nbsp;<code>1</code>&nbsp;到&nbsp;<code>s.length - 1</code>&nbsp;之间的&nbsp;<code>i</code>&nbsp;，满足&nbsp;<code>s[i] != s[i + 1]</code>&nbsp;（字符串的下标从 1 开始）。</li>\n</ul>\n\n<p>比方说，字符串&nbsp;<strong>&quot;abc&quot;</strong>，<strong>&quot;ac&quot;，&quot;b&quot;</strong> 和&nbsp;<strong>&quot;abcbabcbcb&quot;</strong>&nbsp;都是开心字符串，但是&nbsp;<strong>&quot;aa&quot;</strong>，<strong>&quot;baa&quot;</strong>&nbsp;和&nbsp;<strong>&quot;ababbc&quot;</strong>&nbsp;都不是开心字符串。</p>\n\n<p>给你两个整数 <code>n</code>&nbsp;和 <code>k</code>&nbsp;，你需要将长度为 <code>n</code>&nbsp;的所有开心字符串按字典序排序。</p>\n\n<p>请你返回排序后的第 k 个开心字符串，如果长度为 <code>n</code>&nbsp;的开心字符串少于 <code>k</code>&nbsp;个，那么请你返回 <strong>空字符串</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 1, k = 3\n<strong>输出：</strong>&quot;c&quot;\n<strong>解释：</strong>列表 [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 包含了所有长度为 1 的开心字符串。按照字典序排序后第三个字符串为 &quot;c&quot; 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 1, k = 4\n<strong>输出：</strong>&quot;&quot;\n<strong>解释：</strong>长度为 1 的开心字符串只有 3 个。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 3, k = 9\n<strong>输出：</strong>&quot;cab&quot;\n<strong>解释：</strong>长度为 3 的开心字符串总共有 12 个 [&quot;aba&quot;, &quot;abc&quot;, &quot;aca&quot;, &quot;acb&quot;, &quot;bab&quot;, &quot;bac&quot;, &quot;bca&quot;, &quot;bcb&quot;, &quot;cab&quot;, &quot;cac&quot;, &quot;cba&quot;, &quot;cbc&quot;] 。第 9 个字符串为 &quot;cab&quot;\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, k = 7\n<strong>输出：</strong>&quot;&quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>n = 10, k = 100\n<strong>输出：</strong>&quot;abacbabacb&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10</code></li>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1416.恢复数组",
        "hardRate": "HARD",
        "passRate": "42.69%",
        "problemsUrl": "https://leetcode.cn/problems/restore-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/restore-the-array/solution",
        "problemsDesc": "<p>某个程序本来应该输出一个整数数组。但是这个程序忘记输出空格了以致输出了一个数字字符串，我们所知道的信息只有：数组中所有整数都在 <code>[1, k]</code>&nbsp;之间，且数组中的数字都没有前导 0 。</p>\n\n<p>给你字符串&nbsp;<code>s</code>&nbsp;和整数&nbsp;<code>k</code>&nbsp;。可能会有多种不同的数组恢复结果。</p>\n\n<p>按照上述程序，请你返回所有可能输出字符串&nbsp;<code>s</code>&nbsp;的数组方案数。</p>\n\n<p>由于数组方案数可能会很大，请你返回它对&nbsp;<code>10^9 + 7</code>&nbsp;<strong>取余</strong>&nbsp;后的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1000&quot;, k = 10000\n<strong>输出：</strong>1\n<strong>解释：</strong>唯一一种可能的数组方案是 [1000]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1000&quot;, k = 10\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在任何数组方案满足所有整数都 &gt;= 1 且 &lt;= 10 同时输出结果为 s 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1317&quot;, k = 2000\n<strong>输出：</strong>8\n<strong>解释：</strong>可行的数组方案为 [1317]，[131,7]，[13,17]，[1,317]，[13,1,7]，[1,31,7]，[1,3,17]，[1,3,1,7]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;2020&quot;, k = 30\n<strong>输出：</strong>1\n<strong>解释：</strong>唯一可能的数组方案是 [20,20] 。 [2020] 不是可行的数组方案，原因是 2020 &gt; 30 。 [2,020] 也不是可行的数组方案，因为 020 含有前导 0 。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1234567890&quot;, k = 90\n<strong>输出：</strong>34\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code>.</li>\n\t<li><code>s</code>&nbsp;只包含数字且不包含前导 0 。</li>\n\t<li><code>1 &lt;= k &lt;= 10^9</code>.</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1417.重新格式化字符串",
        "hardRate": "EASY",
        "passRate": "55.16%",
        "problemsUrl": "https://leetcode.cn/problems/reformat-the-string/",
        "solutionsUrl": "https://leetcode.cn/problems/reformat-the-string/solution",
        "problemsDesc": "<p>给你一个混合了数字和字母的字符串 <code>s</code>，其中的字母均为小写英文字母。</p>\n\n<p>请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。</p>\n\n<p>请你返回 <strong>重新格式化后</strong> 的字符串；如果无法按要求重新格式化，则返回一个 <strong>空字符串</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;a0b1c2&quot;\n<strong>输出：</strong>&quot;0a1b2c&quot;\n<strong>解释：</strong>&quot;0a1b2c&quot; 中任意两个相邻字符的类型都不同。 &quot;a0b1c2&quot;, &quot;0a1b2c&quot;, &quot;0c2a1b&quot; 也是满足题目要求的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;leetcode&quot;\n<strong>输出：</strong>&quot;&quot;\n<strong>解释：</strong>&quot;leetcode&quot; 中只有字母，所以无法满足重新格式化的条件。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1229857369&quot;\n<strong>输出：</strong>&quot;&quot;\n<strong>解释：</strong>&quot;1229857369&quot; 中只有数字，所以无法满足重新格式化的条件。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;covid2019&quot;\n<strong>输出：</strong>&quot;c2o0v1i9d&quot;\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;ab123&quot;\n<strong>输出：</strong>&quot;1a2b3&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>s</code> 仅由小写英文字母和/或数字组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1418.点菜展示表",
        "hardRate": "MEDIUM",
        "passRate": "73.14%",
        "problemsUrl": "https://leetcode.cn/problems/display-table-of-food-orders-in-a-restaurant/",
        "solutionsUrl": "https://leetcode.cn/problems/display-table-of-food-orders-in-a-restaurant/solution",
        "problemsDesc": "<p>给你一个数组 <code>orders</code>，表示客户在餐厅中完成的订单，确切地说， <code>orders[i]=[customerName<sub>i</sub>,tableNumber<sub>i</sub>,foodItem<sub>i</sub>]</code> ，其中 <code>customerName<sub>i</sub></code> 是客户的姓名，<code>tableNumber<sub>i</sub></code> 是客户所在餐桌的桌号，而 <code>foodItem<sub>i</sub></code> 是客户点的餐品名称。</p>\n\n<p>请你返回该餐厅的 <strong>点菜展示表</strong><em> 。</em>在这张表中，表中第一行为标题，其第一列为餐桌桌号 &ldquo;Table&rdquo; ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。</p>\n\n<p>注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>orders = [[&quot;David&quot;,&quot;3&quot;,&quot;Ceviche&quot;],[&quot;Corina&quot;,&quot;10&quot;,&quot;Beef Burrito&quot;],[&quot;David&quot;,&quot;3&quot;,&quot;Fried Chicken&quot;],[&quot;Carla&quot;,&quot;5&quot;,&quot;Water&quot;],[&quot;Carla&quot;,&quot;5&quot;,&quot;Ceviche&quot;],[&quot;Rous&quot;,&quot;3&quot;,&quot;Ceviche&quot;]]\n<strong>输出：</strong>[[&quot;Table&quot;,&quot;Beef Burrito&quot;,&quot;Ceviche&quot;,&quot;Fried Chicken&quot;,&quot;Water&quot;],[&quot;3&quot;,&quot;0&quot;,&quot;2&quot;,&quot;1&quot;,&quot;0&quot;],[&quot;5&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;],[&quot;10&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]] \n<strong>解释：\n</strong>点菜展示表如下所示：\n<strong>Table,Beef Burrito,Ceviche,Fried Chicken,Water</strong>\n3    ,0           ,2      ,1            ,0\n5    ,0           ,1      ,0            ,1\n10   ,1           ,0      ,0            ,0\n对于餐桌 3：David 点了 &quot;Ceviche&quot; 和 &quot;Fried Chicken&quot;，而 Rous 点了 &quot;Ceviche&quot;\n而餐桌 5：Carla 点了 &quot;Water&quot; 和 &quot;Ceviche&quot;\n餐桌 10：Corina 点了 &quot;Beef Burrito&quot; \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>orders = [[&quot;James&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Ratesh&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Amadeus&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Adam&quot;,&quot;1&quot;,&quot;Canadian Waffles&quot;],[&quot;Brianna&quot;,&quot;1&quot;,&quot;Canadian Waffles&quot;]]\n<strong>输出：</strong>[[&quot;Table&quot;,&quot;Canadian Waffles&quot;,&quot;Fried Chicken&quot;],[&quot;1&quot;,&quot;2&quot;,&quot;0&quot;],[&quot;12&quot;,&quot;0&quot;,&quot;3&quot;]] \n<strong>解释：</strong>\n对于餐桌 1：Adam 和 Brianna 都点了 &quot;Canadian Waffles&quot;\n而餐桌 12：James, Ratesh 和 Amadeus 都点了 &quot;Fried Chicken&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>orders = [[&quot;Laura&quot;,&quot;2&quot;,&quot;Bean Burrito&quot;],[&quot;Jhon&quot;,&quot;2&quot;,&quot;Beef Burrito&quot;],[&quot;Melissa&quot;,&quot;2&quot;,&quot;Soda&quot;]]\n<strong>输出：</strong>[[&quot;Table&quot;,&quot;Bean Burrito&quot;,&quot;Beef Burrito&quot;,&quot;Soda&quot;],[&quot;2&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;orders.length &lt;= 5 * 10^4</code></li>\n\t<li><code>orders[i].length == 3</code></li>\n\t<li><code>1 &lt;= customerName<sub>i</sub>.length, foodItem<sub>i</sub>.length &lt;= 20</code></li>\n\t<li><code>customerName<sub>i</sub></code> 和 <code>foodItem<sub>i</sub></code> 由大小写英文字母及空格字符 <code>&#39; &#39;</code> 组成。</li>\n\t<li><code>tableNumber<sub>i</sub></code> 是 <code>1</code> 到 <code>500</code> 范围内的整数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1419.数青蛙",
        "hardRate": "MEDIUM",
        "passRate": "50.22%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-frogs-croaking/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-frogs-croaking/solution",
        "problemsDesc": "<p>给你一个字符串 <code>croakOfFrogs</code>，它表示不同青蛙发出的蛙鸣声（字符串 <code>\"croak\"</code> ）的组合。由于同一时间可以有多只青蛙呱呱作响，所以&nbsp;<code>croakOfFrogs</code> 中会混合多个 <code>“croak”</code> <em>。</em></p>\n\n<p>请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。</p>\n\n<p>要想发出蛙鸣 \"croak\"，青蛙必须 <strong>依序</strong> 输出 <code>‘c’, ’r’, ’o’, ’a’, ’k’</code> 这 5 个字母。如果没有输出全部五个字母，那么它就不会发出声音。如果字符串 <code>croakOfFrogs</code> 不是由若干有效的 \"croak\" 字符混合而成，请返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>croakOfFrogs = \"croakcroak\"\n<strong>输出：</strong>1 \n<strong>解释：</strong>一只青蛙 “呱呱” 两次\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>croakOfFrogs = \"crcoakroak\"\n<strong>输出：</strong>2 \n<strong>解释：</strong>最少需要两只青蛙，“呱呱” 声用黑体标注\n第一只青蛙 \"<strong>cr</strong>c<strong>oak</strong>roak\"\n第二只青蛙 \"cr<strong>c</strong>oak<strong>roak</strong>\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>croakOfFrogs = \"croakcrook\"\n<strong>输出：</strong>-1\n<strong>解释：</strong>给出的字符串不是 \"croak<strong>\"</strong> 的有效组合。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= croakOfFrogs.length &lt;= 10<sup>5</sup></code></li>\n\t<li>字符串中的字符只有 <code>'c'</code>, <code>'r'</code>, <code>'o'</code>, <code>'a'</code> 或者 <code>'k'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1420.生成数组",
        "hardRate": "HARD",
        "passRate": "63.60%",
        "problemsUrl": "https://leetcode.cn/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/",
        "solutionsUrl": "https://leetcode.cn/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/solution",
        "problemsDesc": "<p>给你三个整数 <code>n</code>、<code>m</code> 和 <code>k</code> 。下图描述的算法用于找出正整数数组中最大的元素。</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/19/e.png\" style=\"height: 372px; width: 424px;\"></p>\n\n<p>请你生成一个具有下述属性的数组 <code>arr</code> ：</p>\n\n<ul>\n\t<li><code>arr</code> 中有 <code>n</code> 个整数。</li>\n\t<li><code>1 &lt;= arr[i] &lt;= m</code> 其中 <code>(0 &lt;= i &lt; n)</code> 。</li>\n\t<li>将上面提到的算法应用于 <code>arr</code> ，<code>search_cost</code> 的值等于 <code>k</code> 。</li>\n</ul>\n\n<p>返回上述条件下生成数组 <code>arr</code> 的 <strong>方法数</strong> ，由于答案可能会很大，所以 <strong>必须</strong> 对 <code>10^9 + 7</code> 取余。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2, m = 3, k = 1\n<strong>输出：</strong>6\n<strong>解释：</strong>可能的数组分别为 [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 5, m = 2, k = 3\n<strong>输出：</strong>0\n<strong>解释：</strong>没有数组可以满足上述条件\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 9, m = 1, k = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>可能的数组只有 [1, 1, 1, 1, 1, 1, 1, 1, 1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 50, m = 100, k = 25\n<strong>输出：</strong>34549172\n<strong>解释：</strong>不要忘了对 1000000007 取余\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>n = 37, m = 17, k = 7\n<strong>输出：</strong>418930126\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>1 &lt;= m &lt;= 100</code></li>\n\t<li><code>0 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1421.净现值查询",
        "hardRate": "EASY",
        "passRate": "70.94%",
        "problemsUrl": "https://leetcode.cn/problems/npv-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/npv-queries/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1422.分割字符串的最大得分",
        "hardRate": "EASY",
        "passRate": "56.75%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-score-after-splitting-a-string/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-score-after-splitting-a-string/solution",
        "problemsDesc": "<p>给你一个由若干 0 和 1 组成的字符串 <code>s</code> ，请你计算并返回将该字符串分割成两个 <strong>非空</strong> 子字符串（即&nbsp;<strong>左</strong> 子字符串和 <strong>右</strong> 子字符串）所能获得的最大得分。</p>\n\n<p>「分割字符串的得分」为 <strong>左</strong> 子字符串中 <strong>0</strong> 的数量加上 <strong>右</strong> 子字符串中 <strong>1</strong> 的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;011101&quot;\n<strong>输出：</strong>5 \n<strong>解释：</strong>\n将字符串 s 划分为两个非空子字符串的可行方案有：\n左子字符串 = &quot;0&quot; 且 右子字符串 = &quot;11101&quot;，得分 = 1 + 4 = 5 \n左子字符串 = &quot;01&quot; 且 右子字符串 = &quot;1101&quot;，得分 = 1 + 3 = 4 \n左子字符串 = &quot;011&quot; 且 右子字符串 = &quot;101&quot;，得分 = 1 + 2 = 3 \n左子字符串 = &quot;0111&quot; 且 右子字符串 = &quot;01&quot;，得分 = 1 + 1 = 2 \n左子字符串 = &quot;01110&quot; 且 右子字符串 = &quot;1&quot;，得分 = 2 + 1 = 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;00111&quot;\n<strong>输出：</strong>5\n<strong>解释：</strong>当 左子字符串 = &quot;00&quot; 且 右子字符串 = &quot;111&quot; 时，我们得到最大得分 = 2 + 3 = 5\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;1111&quot;\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 500</code></li>\n\t<li>字符串 <code>s</code> 仅由字符 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1423.可获得的最大点数",
        "hardRate": "MEDIUM",
        "passRate": "55.00%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/solution",
        "problemsDesc": "<p>几张卡牌<strong> 排成一行</strong>，每张卡牌都有一个对应的点数。点数由整数数组 <code>cardPoints</code> 给出。</p>\n\n<p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 <code>k</code> 张卡牌。</p>\n\n<p>你的点数就是你拿到手中的所有卡牌的点数之和。</p>\n\n<p>给你一个整数数组 <code>cardPoints</code> 和整数 <code>k</code>，请你返回可以获得的最大点数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>cardPoints = [1,2,3,4,5,6,1], k = 3\n<strong>输出：</strong>12\n<strong>解释：</strong>第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>cardPoints = [2,2,2], k = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>无论你拿起哪两张卡牌，可获得的点数总是 4 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>cardPoints = [9,7,7,9,7,7,9], k = 7\n<strong>输出：</strong>55\n<strong>解释：</strong>你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>cardPoints = [1,1000,1], k = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。 \n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>cardPoints = [1,79,80,1,1,1,200,1], k = 3\n<strong>输出：</strong>202\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= cardPoints.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= cardPoints[i] &lt;= 10^4</code></li>\n\t<li><code>1 &lt;= k &lt;= cardPoints.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1424.对角线遍历 II",
        "hardRate": "MEDIUM",
        "passRate": "42.25%",
        "problemsUrl": "https://leetcode.cn/problems/diagonal-traverse-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/diagonal-traverse-ii/solution",
        "problemsDesc": "<p>给你一个列表&nbsp;<code>nums</code>&nbsp;，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回&nbsp;<code>nums</code>&nbsp;中对角线上的整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/23/sample_1_1784.png\" style=\"height: 143px; width: 158px;\"></strong></p>\n\n<pre><strong>输入：</strong>nums = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>[1,4,2,7,5,3,8,6,9]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/23/sample_2_1784.png\" style=\"height: 177px; width: 230px;\"></strong></p>\n\n<pre><strong>输入：</strong>nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]\n<strong>输出：</strong>[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]]\n<strong>输出：</strong>[1,4,2,5,3,8,6,9,7,10,11]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums = [[1,2,3,4,5,6]]\n<strong>输出：</strong>[1,2,3,4,5,6]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= nums[i].length &lt;=&nbsp;10^5</code></li>\n\t<li><code>1 &lt;= nums[i][j] &lt;= 10^9</code></li>\n\t<li><code>nums</code>&nbsp;中最多有&nbsp;<code>10^5</code>&nbsp;个数字。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1425.带限制的子序列和",
        "hardRate": "HARD",
        "passRate": "47.55%",
        "problemsUrl": "https://leetcode.cn/problems/constrained-subsequence-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/constrained-subsequence-sum/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;，请你返回 <strong>非空</strong>&nbsp;子序列元素和的最大值，子序列需要满足：子序列中每两个 <strong>相邻</strong>&nbsp;的整数&nbsp;<code>nums[i]</code>&nbsp;和&nbsp;<code>nums[j]</code>&nbsp;，它们在原数组中的下标&nbsp;<code>i</code>&nbsp;和&nbsp;<code>j</code>&nbsp;满足&nbsp;<code>i &lt; j</code>&nbsp;且 <code>j - i &lt;= k</code> 。</p>\n\n<p>数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [10,2,-10,5,20], k = 2\n<strong>输出：</strong>37\n<strong>解释：</strong>子序列为 [10, 2, 5, 20] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [-1,-2,-3], k = 1\n<strong>输出：</strong>-1\n<strong>解释：</strong>子序列必须是非空的，所以我们选择最大的数字。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [10,-2,-10,-5,20], k = 2\n<strong>输出：</strong>23\n<strong>解释：</strong>子序列为 [10, -2, -5, 20] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>-10^4&nbsp;&lt;= nums[i] &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1426.数元素",
        "hardRate": "EASY",
        "passRate": "69.68%",
        "problemsUrl": "https://leetcode.cn/problems/counting-elements/",
        "solutionsUrl": "https://leetcode.cn/problems/counting-elements/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1427.字符串的左右移",
        "hardRate": "EASY",
        "passRate": "58.57%",
        "problemsUrl": "https://leetcode.cn/problems/perform-string-shifts/",
        "solutionsUrl": "https://leetcode.cn/problems/perform-string-shifts/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1428.至少有一个 1 的最左端列",
        "hardRate": "MEDIUM",
        "passRate": "61.39%",
        "problemsUrl": "https://leetcode.cn/problems/leftmost-column-with-at-least-a-one/",
        "solutionsUrl": "https://leetcode.cn/problems/leftmost-column-with-at-least-a-one/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1429.第一个唯一数字",
        "hardRate": "MEDIUM",
        "passRate": "53.43%",
        "problemsUrl": "https://leetcode.cn/problems/first-unique-number/",
        "solutionsUrl": "https://leetcode.cn/problems/first-unique-number/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1430.判断给定的序列是否是二叉树从根到叶的路径",
        "hardRate": "MEDIUM",
        "passRate": "54.58%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1431.拥有最多糖果的孩子",
        "hardRate": "EASY",
        "passRate": "84.58%",
        "problemsUrl": "https://leetcode.cn/problems/kids-with-the-greatest-number-of-candies/",
        "solutionsUrl": "https://leetcode.cn/problems/kids-with-the-greatest-number-of-candies/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>candies</code>&nbsp;和一个整数&nbsp;<code>extraCandies</code>&nbsp;，其中&nbsp;<code>candies[i]</code>&nbsp;代表第 <code>i</code> 个孩子拥有的糖果数目。</p>\n\n<p>对每一个孩子，检查是否存在一种方案，将额外的&nbsp;<code>extraCandies</code>&nbsp;个糖果分配给孩子们之后，此孩子有 <strong>最多</strong>&nbsp;的糖果。注意，允许有多个孩子同时拥有 <strong>最多</strong>&nbsp;的糖果数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>candies = [2,3,5,1,3], extraCandies = 3\n<strong>输出：</strong>[true,true,true,false,true] \n<strong>解释：</strong>\n孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。\n孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。\n孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。\n孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。\n孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>candies = [4,2,1,1,2], extraCandies = 1\n<strong>输出：</strong>[true,false,false,false,false] \n<strong>解释：</strong>只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>candies = [12,1,12], extraCandies = 10\n<strong>输出：</strong>[true,false,true]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= candies.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= candies[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= extraCandies &lt;= 50</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1432.改变一个整数能得到的最大差值",
        "hardRate": "MEDIUM",
        "passRate": "39.89%",
        "problemsUrl": "https://leetcode.cn/problems/max-difference-you-can-get-from-changing-an-integer/",
        "solutionsUrl": "https://leetcode.cn/problems/max-difference-you-can-get-from-changing-an-integer/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>num</code>&nbsp;。你可以对它进行如下步骤恰好 <strong>两次</strong>&nbsp;：</p>\n\n<ul>\n\t<li>选择一个数字&nbsp;<code>x (0&nbsp;&lt;= x &lt;= 9)</code>.</li>\n\t<li>选择另一个数字&nbsp;<code>y (0&nbsp;&lt;= y &lt;= 9)</code>&nbsp;。数字&nbsp;<code>y</code>&nbsp;可以等于&nbsp;<code>x</code>&nbsp;。</li>\n\t<li>将 <code>num</code>&nbsp;中所有出现 <code>x</code>&nbsp;的数位都用 <code>y</code>&nbsp;替换。</li>\n\t<li>得到的新的整数 <strong>不能</strong>&nbsp;有前导 0 ，得到的新整数也 <strong>不能</strong>&nbsp;是 0&nbsp;。</li>\n</ul>\n\n<p>令两次对 <code>num</code>&nbsp;的操作得到的结果分别为&nbsp;<code>a</code>&nbsp;和&nbsp;<code>b</code>&nbsp;。</p>\n\n<p>请你返回&nbsp;<code>a</code> 和&nbsp;<code>b</code>&nbsp;的 <strong>最大差值</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 555\n<strong>输出：</strong>888\n<strong>解释：</strong>第一次选择 x = 5 且 y = 9 ，并把得到的新数字保存在 a 中。\n第二次选择 x = 5 且 y = 1 ，并把得到的新数字保存在 b 中。\n现在，我们有 a = 999 和 b = 111 ，最大差值为 888\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 9\n<strong>输出：</strong>8\n<strong>解释：</strong>第一次选择 x = 9 且 y = 9 ，并把得到的新数字保存在 a 中。\n第二次选择 x = 9 且 y = 1 ，并把得到的新数字保存在 b 中。\n现在，我们有 a = 9 和 b = 1 ，最大差值为 8\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = 123456\n<strong>输出：</strong>820000\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>num = 10000\n<strong>输出：</strong>80000\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>num = 9288\n<strong>输出：</strong>8700\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10^8</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1433.检查一个字符串是否可以打破另一个字符串",
        "hardRate": "MEDIUM",
        "passRate": "64.70%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-a-string-can-break-another-string/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-a-string-can-break-another-string/solution",
        "problemsDesc": "<p>给你两个字符串&nbsp;<code>s1</code>&nbsp;和&nbsp;<code>s2</code>&nbsp;，它们长度相等，请你检查是否存在一个&nbsp;<code>s1</code>&nbsp; 的排列可以打破 <code>s2</code>&nbsp;的一个排列，或者是否存在一个&nbsp;<code>s2</code>&nbsp;的排列可以打破 <code>s1</code> 的一个排列。</p>\n\n<p>字符串&nbsp;<code>x</code>&nbsp;可以打破字符串&nbsp;<code>y</code>&nbsp;（两者长度都为&nbsp;<code>n</code>&nbsp;）需满足对于所有&nbsp;<code>i</code>（在&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;之间）都有&nbsp;<code>x[i] &gt;= y[i]</code>（字典序意义下的顺序）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s1 = &quot;abc&quot;, s2 = &quot;xya&quot;\n<strong>输出：</strong>true\n<strong>解释：</strong>&quot;ayx&quot; 是 s2=&quot;xya&quot; 的一个排列，&quot;abc&quot; 是字符串 s1=&quot;abc&quot; 的一个排列，且 &quot;ayx&quot; 可以打破 &quot;abc&quot; 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s1 = &quot;abe&quot;, s2 = &quot;acd&quot;\n<strong>输出：</strong>false \n<strong>解释：</strong>s1=&quot;abe&quot; 的所有排列包括：&quot;abe&quot;，&quot;aeb&quot;，&quot;bae&quot;，&quot;bea&quot;，&quot;eab&quot; 和 &quot;eba&quot; ，s2=&quot;acd&quot; 的所有排列包括：&quot;acd&quot;，&quot;adc&quot;，&quot;cad&quot;，&quot;cda&quot;，&quot;dac&quot; 和 &quot;dca&quot;。然而没有任何 s1 的排列可以打破 s2 的排列。也没有 s2 的排列能打破 s1 的排列。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s1 = &quot;leetcodee&quot;, s2 = &quot;interview&quot;\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s1.length == n</code></li>\n\t<li><code>s2.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li>所有字符串都只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1434.每个人戴不同帽子的方案数",
        "hardRate": "HARD",
        "passRate": "51.68%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-to-wear-different-hats-to-each-other/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-to-wear-different-hats-to-each-other/solution",
        "problemsDesc": "<p>总共有 <code>n</code>&nbsp;个人和 <code>40</code> 种不同的帽子，帽子编号从 <code>1</code> 到 <code>40</code> 。</p>\n\n<p>给你一个整数列表的列表&nbsp;<code>hats</code>&nbsp;，其中&nbsp;<code>hats[i]</code>&nbsp;是第 <code>i</code>&nbsp;个人所有喜欢帽子的列表。</p>\n\n<p>请你给每个人安排一顶他喜欢的帽子，确保每个人戴的帽子跟别人都不一样，并返回方案数。</p>\n\n<p>由于答案可能很大，请返回它对&nbsp;<code>10^9 + 7</code>&nbsp;取余后的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>hats = [[3,4],[4,5],[5]]\n<strong>输出：</strong>1\n<strong>解释：</strong>给定条件下只有一种方法选择帽子。\n第一个人选择帽子 3，第二个人选择帽子 4，最后一个人选择帽子 5。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>hats = [[3,5,1],[3,5]]\n<strong>输出：</strong>4\n<strong>解释：</strong>总共有 4 种安排帽子的方法：\n(3,5)，(5,3)，(1,3) 和 (1,5)\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]\n<strong>输出：</strong>24\n<strong>解释：</strong>每个人都可以从编号为 1 到 4 的帽子中选。\n(1,2,3,4) 4 个帽子的排列方案数为 24 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>hats = [[1,2,3],[2,3,5,6],[1,3,7,9],[1,8,9],[2,5,7]]\n<strong>输出：</strong>111\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == hats.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10</code></li>\n\t<li><code>1 &lt;= hats[i].length &lt;= 40</code></li>\n\t<li><code>1 &lt;= hats[i][j] &lt;= 40</code></li>\n\t<li><code>hats[i]</code>&nbsp;包含一个数字互不相同的整数列表。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1435.制作会话柱状图",
        "hardRate": "EASY",
        "passRate": "63.74%",
        "problemsUrl": "https://leetcode.cn/problems/create-a-session-bar-chart/",
        "solutionsUrl": "https://leetcode.cn/problems/create-a-session-bar-chart/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1436.旅行终点站",
        "hardRate": "EASY",
        "passRate": "81.75%",
        "problemsUrl": "https://leetcode.cn/problems/destination-city/",
        "solutionsUrl": "https://leetcode.cn/problems/destination-city/solution",
        "problemsDesc": "<p>给你一份旅游线路图，该线路图中的旅行线路用数组 <code>paths</code> 表示，其中 <code>paths[i] = [cityA<sub>i</sub>, cityB<sub>i</sub>]</code> 表示该线路将会从 <code>cityA<sub>i</sub></code> 直接前往 <code>cityB<sub>i</sub></code> 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市<em>。</em></p>\n\n<p>题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>paths = [[\"London\",\"New York\"],[\"New York\",\"Lima\"],[\"Lima\",\"Sao Paulo\"]]\n<strong>输出：</strong>\"Sao Paulo\" \n<strong>解释：</strong>从 \"London\" 出发，最后抵达终点站 \"Sao Paulo\" 。本次旅行的路线是 \"London\" -&gt; \"New York\" -&gt; \"Lima\" -&gt; \"Sao Paulo\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>paths = [[\"B\",\"C\"],[\"D\",\"B\"],[\"C\",\"A\"]]\n<strong>输出：</strong>\"A\"\n<strong>解释：</strong>所有可能的线路是：\n\"D\" -&gt; \"B\" -&gt; \"C\" -&gt; \"A\".&nbsp;\n\"B\" -&gt; \"C\" -&gt; \"A\".&nbsp;\n\"C\" -&gt; \"A\".&nbsp;\n\"A\".&nbsp;\n显然，旅行终点站是 \"A\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>paths = [[\"A\",\"Z\"]]\n<strong>输出：</strong>\"Z\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= paths.length &lt;= 100</code></li>\n\t<li><code>paths[i].length == 2</code></li>\n\t<li><code>1 &lt;=&nbsp;cityA<sub>i</sub>.length,&nbsp;cityB<sub>i</sub>.length &lt;= 10</code></li>\n\t<li><code>cityA<sub>i&nbsp;</sub>!=&nbsp;cityB<sub>i</sub></code></li>\n\t<li>所有字符串均由大小写英文字母和空格字符组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1437.是否所有 1 都至少相隔 k 个元素",
        "hardRate": "EASY",
        "passRate": "55.60%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-all-1s-are-at-least-length-k-places-away/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-all-1s-are-at-least-length-k-places-away/solution",
        "problemsDesc": "<p>给你一个由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>nums</code> 以及整数 <code>k</code>。如果所有 <code>1</code> 都至少相隔 <code>k</code> 个元素，则返回 <code>True</code> ；否则，返回 <code>False</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/03/sample_1_1791.png\" style=\"width: 214px;\"></strong></p>\n\n<pre><strong>输入：</strong>nums = [1,0,0,0,1,0,0,1], k = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>每个 1 都至少相隔 2 个元素。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/03/sample_2_1791.png\" style=\"height: 86px; width: 160px;\"></strong></p>\n\n<pre><strong>输入：</strong>nums = [1,0,0,1,0,1], k = 2\n<strong>输出：</strong>false\n<strong>解释：</strong>第二个 1 和第三个 1 之间只隔了 1 个元素。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,1,1,1], k = 0\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>nums = [0,1,0,1], k = 1\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= k &lt;= nums.length</code></li>\n\t<li><code>nums[i]</code> 的值为 <code>0</code> 或 <code>1</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1438.绝对差不超过限制的最长连续子数组",
        "hardRate": "MEDIUM",
        "passRate": "49.65%",
        "problemsUrl": "https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> ，和一个表示限制的整数 <code>limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 <code>limit</code><em> 。</em></p>\n\n<p>如果不存在满足条件的子数组，则返回 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [8,2,4,7], limit = 4\n<strong>输出：</strong>2 \n<strong>解释：</strong>所有子数组如下：\n[8] 最大绝对差 |8-8| = 0 &lt;= 4.\n[8,2] 最大绝对差 |8-2| = 6 &gt; 4. \n[8,2,4] 最大绝对差 |8-2| = 6 &gt; 4.\n[8,2,4,7] 最大绝对差 |8-2| = 6 &gt; 4.\n[2] 最大绝对差 |2-2| = 0 &lt;= 4.\n[2,4] 最大绝对差 |2-4| = 2 &lt;= 4.\n[2,4,7] 最大绝对差 |2-7| = 5 &gt; 4.\n[4] 最大绝对差 |4-4| = 0 &lt;= 4.\n[4,7] 最大绝对差 |4-7| = 3 &lt;= 4.\n[7] 最大绝对差 |7-7| = 0 &lt;= 4. \n因此，满足题意的最长子数组的长度为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [10,1,2,4,7,2], limit = 5\n<strong>输出：</strong>4 \n<strong>解释：</strong>满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 &lt;= 5 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [4,2,2,2,4,4,2,2], limit = 0\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>\n\t<li><code>0 &lt;= limit &lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1439.有序矩阵中的第 k 个最小数组和",
        "hardRate": "HARD",
        "passRate": "66.51%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/solution",
        "problemsDesc": "<p>给你一个 <code>m&nbsp;* n</code> 的矩阵 <code>mat</code>，以及一个整数 <code>k</code> ，矩阵中的每一行都以非递减的顺序排列。</p>\n\n<p>你可以从每一行中选出 1 个元素形成一个数组。返回所有可能数组中的第 k 个 <strong>最小</strong> 数组和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[1,3,11],[2,4,6]], k = 5\n<strong>输出：</strong>7\n<strong>解释：</strong>从每一行中选出一个元素，前 k 个和最小的数组分别是：\n[1,2], [1,4], [3,2], [3,4], [1,6]。其中第 5 个的和是 7 。  </pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[1,3,11],[2,4,6]], k = 9\n<strong>输出：</strong>17\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7\n<strong>输出：</strong>9\n<strong>解释：</strong>从每一行中选出一个元素，前 k 个和最小的数组分别是：\n[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]。其中第 7 个的和是 9 。 \n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>mat = [[1,1,10],[2,2,9]], k = 7\n<strong>输出：</strong>12\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat.length[i]</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 40</code></li>\n\t<li><code>1 &lt;= k &lt;= min(200, n ^&nbsp;m)</code></li>\n\t<li><code>1 &lt;= mat[i][j] &lt;= 5000</code></li>\n\t<li><code>mat[i]</code> 是一个非递减数组</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1440.计算布尔表达式的值",
        "hardRate": "MEDIUM",
        "passRate": "69.74%",
        "problemsUrl": "https://leetcode.cn/problems/evaluate-boolean-expression/",
        "solutionsUrl": "https://leetcode.cn/problems/evaluate-boolean-expression/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1441.用栈操作构建数组",
        "hardRate": "MEDIUM",
        "passRate": "71.55%",
        "problemsUrl": "https://leetcode.cn/problems/build-an-array-with-stack-operations/",
        "solutionsUrl": "https://leetcode.cn/problems/build-an-array-with-stack-operations/solution",
        "problemsDesc": "<p>给你一个数组 <code>target</code> 和一个整数 <code>n</code>。每次迭代，需要从&nbsp; <code>list = { 1 , 2 , 3 ..., n }</code> 中依次读取一个数字。</p>\n\n<p>请使用下述操作来构建目标数组 <code>target</code> ：</p>\n\n<ul>\n\t<li><code>\"Push\"</code>：从 <code>list</code> 中读取一个新元素， 并将其推入数组中。</li>\n\t<li><code>\"Pop\"</code>：删除数组中的最后一个元素。</li>\n\t<li>如果目标数组构建完成，就停止读取更多元素。</li>\n</ul>\n\n<p>题目数据保证目标数组严格递增，并且只包含 <code>1</code> 到 <code>n</code> 之间的数字。</p>\n\n<p>请返回构建目标数组所用的操作序列。如果存在多个可行方案，返回任一即可。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = [1,3], n = 3\n<strong>输出：</strong>[\"Push\",\"Push\",\"Pop\",\"Push\"]\n<strong>解释： \n</strong>读取 1 并自动推入数组 -&gt; [1]\n读取 2 并自动推入数组，然后删除它 -&gt; [1]\n读取 3 并自动推入数组 -&gt; [1,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = [1,2,3], n = 3\n<strong>输出：</strong>[\"Push\",\"Push\",\"Push\"]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = [1,2], n = 4\n<strong>输出：</strong>[\"Push\",\"Push\"]\n<strong>解释：</strong>只需要读取前 2 个数字就可以停止。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= target[i] &lt;= n</code></li>\n\t<li><code>target</code> 严格递增</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1442.形成两个异或相等数组的三元组数目",
        "hardRate": "MEDIUM",
        "passRate": "79.32%",
        "problemsUrl": "https://leetcode.cn/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/",
        "solutionsUrl": "https://leetcode.cn/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> 。</p>\n\n<p>现需要从数组中取三个下标 <code>i</code>、<code>j</code> 和 <code>k</code> ，其中 <code>(0 &lt;= i &lt; j &lt;= k &lt; arr.length)</code> 。</p>\n\n<p><code>a</code> 和 <code>b</code> 定义如下：</p>\n\n<ul>\n\t<li><code>a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]</code></li>\n\t<li><code>b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]</code></li>\n</ul>\n\n<p>注意：<strong>^</strong> 表示 <strong>按位异或</strong> 操作。</p>\n\n<p>请返回能够令 <code>a == b</code> 成立的三元组 (<code>i</code>, <code>j</code> , <code>k</code>) 的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,3,1,6,7]\n<strong>输出：</strong>4\n<strong>解释：</strong>满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4)\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,1,1,1,1]\n<strong>输出：</strong>10\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [2,3]\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,3,5,7,9]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [7,11,12,9,5,2,7,17,22]\n<strong>输出：</strong>8\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10^8</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1443.收集树上所有苹果的最少时间",
        "hardRate": "MEDIUM",
        "passRate": "43.11%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-time-to-collect-all-apples-in-a-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-time-to-collect-all-apples-in-a-tree/solution",
        "problemsDesc": "<p>给你一棵有&nbsp;<code>n</code>&nbsp;个节点的无向树，节点编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n-1</code>&nbsp;，它们中有一些节点有苹果。通过树上的一条边，需要花费 1 秒钟。你从&nbsp;<strong>节点 0&nbsp;</strong>出发，请你返回最少需要多少秒，可以收集到所有苹果，并回到节点 0 。</p>\n\n<p>无向树的边由&nbsp;<code>edges</code>&nbsp;给出，其中&nbsp;<code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>]</code>&nbsp;，表示有一条边连接&nbsp;<code>from</code>&nbsp;和&nbsp;<code>to<sub>i</sub></code> 。除此以外，还有一个布尔数组&nbsp;<code>hasApple</code> ，其中&nbsp;<code>hasApple[i] = true</code>&nbsp;代表节点&nbsp;<code>i</code>&nbsp;有一个苹果，否则，节点&nbsp;<code>i</code>&nbsp;没有苹果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/10/min_time_collect_apple_1.png\" style=\"height: 212px; width: 300px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n<strong>输出：</strong>8 \n<strong>解释：</strong>上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/10/min_time_collect_apple_2.png\" style=\"height: 212px; width: 300px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n<strong>输出：</strong>6\n<strong>解释：</strong>上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>&nbsp;&lt; b<sub>i</sub>&nbsp;&lt;= n - 1</code></li>\n\t<li><code>hasApple.length == n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1444.切披萨的方案数",
        "hardRate": "HARD",
        "passRate": "54.31%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-ways-of-cutting-a-pizza/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-ways-of-cutting-a-pizza/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>rows x cols</code>&nbsp;大小的矩形披萨和一个整数 <code>k</code>&nbsp;，矩形包含两种字符：&nbsp;<code>&#39;A&#39;</code> （表示苹果）和&nbsp;<code>&#39;.&#39;</code>&nbsp;（表示空白格子）。你需要切披萨 <code>k-1</code> 次，得到&nbsp;<code>k</code>&nbsp;块披萨并送给别人。</p>\n\n<p>切披萨的每一刀，先要选择是向垂直还是水平方向切，再在矩形的边界上选一个切的位置，将披萨一分为二。如果垂直地切披萨，那么需要把左边的部分送给一个人，如果水平地切，那么需要把上面的部分送给一个人。在切完最后一刀后，需要把剩下来的一块送给最后一个人。</p>\n\n<p>请你返回确保每一块披萨包含&nbsp;<strong>至少</strong>&nbsp;一个苹果的切披萨方案数。由于答案可能是个很大的数字，请你返回它对 10^9 + 7 取余的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/10/ways_to_cut_apple_1.png\" style=\"height: 378px; width: 500px;\"></strong></p>\n\n<pre><strong>输入：</strong>pizza = [&quot;A..&quot;,&quot;AAA&quot;,&quot;...&quot;], k = 3\n<strong>输出：</strong>3 \n<strong>解释：</strong>上图展示了三种切披萨的方案。注意每一块披萨都至少包含一个苹果。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>pizza = [&quot;A..&quot;,&quot;AA.&quot;,&quot;...&quot;], k = 3\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>pizza = [&quot;A..&quot;,&quot;A..&quot;,&quot;...&quot;], k = 1\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rows, cols &lt;= 50</code></li>\n\t<li><code>rows ==&nbsp;pizza.length</code></li>\n\t<li><code>cols ==&nbsp;pizza[i].length</code></li>\n\t<li><code>1 &lt;= k &lt;= 10</code></li>\n\t<li><code>pizza</code>&nbsp;只包含字符&nbsp;<code>&#39;A&#39;</code>&nbsp;和&nbsp;<code>&#39;.&#39;</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1445.苹果和桔子",
        "hardRate": "MEDIUM",
        "passRate": "84.15%",
        "problemsUrl": "https://leetcode.cn/problems/apples-oranges/",
        "solutionsUrl": "https://leetcode.cn/problems/apples-oranges/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1446.连续字符",
        "hardRate": "EASY",
        "passRate": "60.30%",
        "problemsUrl": "https://leetcode.cn/problems/consecutive-characters/",
        "solutionsUrl": "https://leetcode.cn/problems/consecutive-characters/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，字符串的<strong>「能量」</strong>定义为：只包含一种字符的最长非空子字符串的长度。</p>\n\n<p>请你返回字符串 <code>s</code> 的 <strong>能量</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"leetcode\"\n<strong>输出：</strong>2\n<strong>解释：</strong>子字符串 \"ee\" 长度为 2 ，只包含字符 'e' 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abbcccddddeeeeedcba\"\n<strong>输出：</strong>5\n<strong>解释：</strong>子字符串 \"eeeee\" 长度为 5 ，只包含字符 'e' 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1447.最简分数",
        "hardRate": "MEDIUM",
        "passRate": "67.50%",
        "problemsUrl": "https://leetcode.cn/problems/simplified-fractions/",
        "solutionsUrl": "https://leetcode.cn/problems/simplified-fractions/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于&nbsp;&nbsp;<code>n</code>&nbsp;的 <strong>最简&nbsp;</strong>分数&nbsp;。分数可以以 <strong>任意&nbsp;</strong>顺序返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>[&quot;1/2&quot;]\n<strong>解释：</strong>&quot;1/2&quot; 是唯一一个分母小于等于 2 的最简分数。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 3\n<strong>输出：</strong>[&quot;1/2&quot;,&quot;1/3&quot;,&quot;2/3&quot;]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 4\n<strong>输出：</strong>[&quot;1/2&quot;,&quot;1/3&quot;,&quot;1/4&quot;,&quot;2/3&quot;,&quot;3/4&quot;]\n<strong>解释：</strong>&quot;2/4&quot; 不是最简分数，因为它可以化简为 &quot;1/2&quot; 。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1448.统计二叉树中好节点的数目",
        "hardRate": "MEDIUM",
        "passRate": "71.58%",
        "problemsUrl": "https://leetcode.cn/problems/count-good-nodes-in-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/count-good-nodes-in-binary-tree/solution",
        "problemsDesc": "<p>给你一棵根为&nbsp;<code>root</code>&nbsp;的二叉树，请你返回二叉树中好节点的数目。</p>\n\n<p>「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/16/test_sample_1.png\" style=\"height: 156px; width: 263px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [3,1,4,3,null,1,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>图中蓝色节点为好节点。\n根节点 (3) 永远是个好节点。\n节点 4 -&gt; (3,4) 是路径中的最大值。\n节点 5 -&gt; (3,4,5) 是路径中的最大值。\n节点 3 -&gt; (3,1,3) 是路径中的最大值。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/16/test_sample_2.png\" style=\"height: 161px; width: 157px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [3,3,null,4,2]\n<strong>输出：</strong>3\n<strong>解释：</strong>节点 2 -&gt; (3, 3, 2) 不是好节点，因为 &quot;3&quot; 比它大。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>root = [1]\n<strong>输出：</strong>1\n<strong>解释：</strong>根节点是好节点。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉树中节点数目范围是&nbsp;<code>[1, 10^5]</code>&nbsp;。</li>\n\t<li>每个节点权值的范围是&nbsp;<code>[-10^4, 10^4]</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1449.数位成本和为目标值的最大数字",
        "hardRate": "HARD",
        "passRate": "62.29%",
        "problemsUrl": "https://leetcode.cn/problems/form-largest-integer-with-digits-that-add-up-to-target/",
        "solutionsUrl": "https://leetcode.cn/problems/form-largest-integer-with-digits-that-add-up-to-target/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>cost</code> 和一个整数 <code>target</code> 。请你返回满足如下规则可以得到的 <strong>最大</strong> 整数：</p>\n\n<ul>\n\t<li>给当前结果添加一个数位（<code>i + 1</code>）的成本为 <code>cost[i]</code> （<code>cost</code> 数组下标从 0 开始）。</li>\n\t<li>总成本必须恰好等于 <code>target</code> 。</li>\n\t<li>添加的数位中没有数字 0 。</li>\n</ul>\n\n<p>由于答案可能会很大，请你以字符串形式返回。</p>\n\n<p>如果按照上述要求无法得到任何整数，请你返回 \"0\" 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>cost = [4,3,2,5,6,7,2,5,5], target = 9\n<strong>输出：</strong>\"7772\"\n<strong>解释：</strong>添加数位 '7' 的成本为 2 ，添加数位 '2' 的成本为 3 。所以 \"7772\" 的代价为 2*3+ 3*1 = 9 。 \"977\" 也是满足要求的数字，但 \"7772\" 是较大的数字。\n<strong> 数字     成本</strong>\n  1  ->   4\n  2  ->   3\n  3  ->   2\n  4  ->   5\n  5  ->   6\n  6  ->   7\n  7  ->   2\n  8  ->   5\n  9  ->   5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>cost = [7,6,5,5,5,6,8,7,8], target = 12\n<strong>输出：</strong>\"85\"\n<strong>解释：</strong>添加数位 '8' 的成本是 7 ，添加数位 '5' 的成本是 5 。\"85\" 的成本为 7 + 5 = 12 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>cost = [2,4,6,2,4,6,4,4,4], target = 5\n<strong>输出：</strong>\"0\"\n<strong>解释：</strong>总成本是 target 的条件下，无法生成任何整数。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>cost = [6,10,15,40,40,40,40,40,40], target = 47\n<strong>输出：</strong>\"32211\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>cost.length == 9</code></li>\n\t<li><code>1 <= cost[i] <= 5000</code></li>\n\t<li><code>1 <= target <= 5000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1450.在既定时间做作业的学生人数",
        "hardRate": "EASY",
        "passRate": "82.38%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/solution",
        "problemsDesc": "<p>给你两个整数数组 <code>startTime</code>（开始时间）和 <code>endTime</code>（结束时间），并指定一个整数 <code>queryTime</code> 作为查询时间。</p>\n\n<p>已知，第 <code>i</code> 名学生在 <code>startTime[i]</code> 时开始写作业并于 <code>endTime[i]</code> 时完成作业。</p>\n\n<p>请返回在查询时间 <code>queryTime</code> 时正在做作业的学生人数。形式上，返回能够使 <code>queryTime</code> 处于区间 <code>[startTime[i], endTime[i]]</code>（含）的学生人数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>startTime = [1,2,3], endTime = [3,2,7], queryTime = 4\n<strong>输出：</strong>1\n<strong>解释：</strong>一共有 3 名学生。\n第一名学生在时间 1 开始写作业，并于时间 3 完成作业，在时间 4 没有处于做作业的状态。\n第二名学生在时间 2 开始写作业，并于时间 2 完成作业，在时间 4 没有处于做作业的状态。\n第三名学生在时间 3 开始写作业，预计于时间 7 完成作业，这是是唯一一名在时间 4 时正在做作业的学生。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>startTime = [4], endTime = [4], queryTime = 4\n<strong>输出：</strong>1\n<strong>解释：</strong>在查询时间只有一名学生在做作业。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>startTime = [4], endTime = [4], queryTime = 5\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>startTime = [1,1,1,1], endTime = [1,3,2,4], queryTime = 7\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>startTime = [9,8,7,6,5,4,3,2,1], endTime = [10,10,10,10,10,10,10,10,10], queryTime = 5\n<strong>输出：</strong>5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>startTime.length == endTime.length</code></li>\n\t<li><code>1 &lt;= startTime.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= startTime[i] &lt;= endTime[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;=&nbsp;queryTime &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1451.重新排列句子中的单词",
        "hardRate": "MEDIUM",
        "passRate": "53.96%",
        "problemsUrl": "https://leetcode.cn/problems/rearrange-words-in-a-sentence/",
        "solutionsUrl": "https://leetcode.cn/problems/rearrange-words-in-a-sentence/solution",
        "problemsDesc": "<p>「句子」是一个用空格分隔单词的字符串。给你一个满足下述格式的句子 <code>text</code> :</p>\n\n<ul>\n\t<li>句子的首字母大写</li>\n\t<li><code>text</code> 中的每个单词都用单个空格分隔。</li>\n</ul>\n\n<p>请你重新排列 <code>text</code> 中的单词，使所有单词按其长度的升序排列。如果两个单词的长度相同，则保留其在原句子中的相对顺序。</p>\n\n<p>请同样按上述格式返回新的句子。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;Leetcode is cool&quot;\n<strong>输出：</strong>&quot;Is cool leetcode&quot;\n<strong>解释：</strong>句子中共有 3 个单词，长度为 8 的 &quot;Leetcode&quot; ，长度为 2 的 &quot;is&quot; 以及长度为 4 的 &quot;cool&quot; 。\n输出需要按单词的长度升序排列，新句子中的第一个单词首字母需要大写。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;Keep calm and code on&quot;\n<strong>输出：</strong>&quot;On and keep calm code&quot;\n<strong>解释：</strong>输出的排序情况如下：\n&quot;On&quot; 2 个字母。\n&quot;and&quot; 3 个字母。\n&quot;keep&quot; 4 个字母，因为存在长度相同的其他单词，所以它们之间需要保留在原句子中的相对顺序。\n&quot;calm&quot; 4 个字母。\n&quot;code&quot; 4 个字母。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;To be or not to be&quot;\n<strong>输出：</strong>&quot;To be or to be not&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>text</code> 以大写字母开头，然后包含若干小写字母以及单词间的单个空格。</li>\n\t<li><code>1 &lt;= text.length &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1452.收藏清单",
        "hardRate": "MEDIUM",
        "passRate": "51.06%",
        "problemsUrl": "https://leetcode.cn/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/",
        "solutionsUrl": "https://leetcode.cn/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/solution",
        "problemsDesc": "<p>给你一个数组 <code>favoriteCompanies</code> ，其中 <code>favoriteCompanies[i]</code> 是第 <code>i</code> 名用户收藏的公司清单（<strong>下标从 0 开始</strong>）。</p>\n\n<p>请找出不是其他任何人收藏的公司清单的子集的收藏清单，并返回该清单下标<em>。</em>下标需要按升序排列<em>。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>favoriteCompanies = [[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;],[&quot;google&quot;,&quot;microsoft&quot;],[&quot;google&quot;,&quot;facebook&quot;],[&quot;google&quot;],[&quot;amazon&quot;]]\n<strong>输出：</strong>[0,1,4] \n<strong>解释：</strong>\nfavoriteCompanies[2]=[&quot;google&quot;,&quot;facebook&quot;] 是 favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;] 的子集。\nfavoriteCompanies[3]=[&quot;google&quot;] 是 favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;] 和 favoriteCompanies[1]=[&quot;google&quot;,&quot;microsoft&quot;] 的子集。\n其余的收藏清单均不是其他任何人收藏的公司清单的子集，因此，答案为 [0,1,4] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>favoriteCompanies = [[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;],[&quot;leetcode&quot;,&quot;amazon&quot;],[&quot;facebook&quot;,&quot;google&quot;]]\n<strong>输出：</strong>[0,1] \n<strong>解释：</strong>favoriteCompanies[2]=[&quot;facebook&quot;,&quot;google&quot;] 是 favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;] 的子集，因此，答案为 [0,1] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>favoriteCompanies = [[&quot;leetcode&quot;],[&quot;google&quot;],[&quot;facebook&quot;],[&quot;amazon&quot;]]\n<strong>输出：</strong>[0,1,2,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;favoriteCompanies.length &lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;favoriteCompanies[i].length &lt;= 500</code></li>\n\t<li><code>1 &lt;=&nbsp;favoriteCompanies[i][j].length &lt;= 20</code></li>\n\t<li><code>favoriteCompanies[i]</code> 中的所有字符串 <strong>各不相同</strong> 。</li>\n\t<li>用户收藏的公司清单也 <strong>各不相同</strong> ，也就是说，即便我们按字母顺序排序每个清单， <code>favoriteCompanies[i] != favoriteCompanies[j] </code>仍然成立。</li>\n\t<li>所有字符串仅包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1453.圆形靶内的最大飞镖数量",
        "hardRate": "HARD",
        "passRate": "37.78%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/solution",
        "problemsDesc": "<p>Alice 向一面非常大的墙上掷出 <code>n</code> 支飞镖。给你一个数组 <code>darts</code> ，其中 <code>darts[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示 Alice 掷出的第 <code>i</code> 支飞镖落在墙上的位置。</p>\n\n<p>Bob 知道墙上所有 <code>n</code> 支飞镖的位置。他想要往墙上放置一个半径为 <code>r</code> 的圆形靶。使 Alice 掷出的飞镖尽可能多地落在靶上。</p>\n\n<p>给你整数 <code>r</code> ，请返回能够落在 <strong>任意</strong> 半径为 <code>r</code> 的圆形靶内或靶上的最大飞镖数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1 ：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/04/29/sample_1_1806.png\" style=\"width: 248px; height: 211px;\" />\n<pre>\n<strong>输入：</strong>darts = [[-2,0],[2,0],[0,2],[0,-2]], r = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>如果圆形靶的圆心为 (0,0) ，半径为 2 ，所有的飞镖都落在靶上，此时落在靶上的飞镖数最大，值为 4 。\n</pre>\n\n<p><strong class=\"example\">示例 2 ：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/04/29/sample_2_1806.png\" style=\"width: 306px; height: 244px;\" />\n<pre>\n<strong>输入：</strong>darts = [[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], r = 5\n<strong>输出：</strong>5\n<strong>解释：</strong>如果圆形靶的圆心为 (0,4) ，半径为 5 ，则除了 (7,8) 之外的飞镖都落在靶上，此时落在靶上的飞镖数最大，值为 5 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= darts.length &lt;= 100</code></li>\n\t<li><code>darts[i].length == 2</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li><code>darts</code> 中的元素互不相同</li>\n\t<li><code>1 &lt;= r &lt;= 5000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1454.活跃用户",
        "hardRate": "MEDIUM",
        "passRate": "38.26%",
        "problemsUrl": "https://leetcode.cn/problems/active-users/",
        "solutionsUrl": "https://leetcode.cn/problems/active-users/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1455.检查单词是否为句中其他单词的前缀",
        "hardRate": "EASY",
        "passRate": "64.80%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/solution",
        "problemsDesc": "<p>给你一个字符串 <code>sentence</code> 作为句子并指定检索词为 <code>searchWord</code> ，其中句子由若干用 <strong>单个空格</strong> 分隔的单词组成。请你检查检索词 <code>searchWord</code> 是否为句子 <code>sentence</code> 中任意单词的前缀。</p>\n\n<p>如果&nbsp;<code>searchWord</code> 是某一个单词的前缀，则返回句子&nbsp;<code>sentence</code> 中该单词所对应的下标（<strong>下标从 1 开始</strong>）。如果 <code>searchWord</code> 是多个单词的前缀，则返回匹配的第一个单词的下标（<strong>最小下标</strong>）。如果 <code>searchWord</code> 不是任何单词的前缀，则返回 <code>-1</code><strong> </strong>。</p>\n\n<p>字符串 <code>s</code> 的 <strong>前缀</strong> 是 <code>s</code> 的任何前导连续子字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"i love eating burger\", searchWord = \"burg\"\n<strong>输出：</strong>4\n<strong>解释：</strong>\"burg\" 是 \"burger\" 的前缀，而 \"burger\" 是句子中第 4 个单词。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"this problem is an easy problem\", searchWord = \"pro\"\n<strong>输出：</strong>2\n<strong>解释：</strong>\"pro\" 是 \"problem\" 的前缀，而 \"problem\" 是句子中第 2 个也是第 6 个单词，但是应该返回最小下标 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>sentence = \"i am tired\", searchWord = \"you\"\n<strong>输出：</strong>-1\n<strong>解释：</strong>\"you\" 不是句子中任何单词的前缀。\n\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentence.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= searchWord.length &lt;= 10</code></li>\n\t<li><code>sentence</code> 由小写英文字母和空格组成。</li>\n\t<li><code>searchWord</code> 由小写英文字母组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1456.定长子串中元音的最大数目",
        "hardRate": "MEDIUM",
        "passRate": "54.59%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solution",
        "problemsDesc": "<p>给你字符串 <code>s</code> 和整数 <code>k</code> 。</p>\n\n<p>请返回字符串 <code>s</code> 中长度为 <code>k</code> 的单个子字符串中可能包含的最大元音字母数。</p>\n\n<p>英文中的 <strong>元音字母 </strong>为（<code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;abciiidef&quot;, k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>子字符串 &quot;iii&quot; 包含 3 个元音字母。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;aeiou&quot;, k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>任意长度为 2 的子字符串都包含 2 个元音字母。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;leetcode&quot;, k = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>&quot;lee&quot;、&quot;eet&quot; 和 &quot;ode&quot; 都包含 2 个元音字母。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;rhythms&quot;, k = 4\n<strong>输出：</strong>0\n<strong>解释：</strong>字符串 s 中不含任何元音字母。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;tryhard&quot;, k = 4\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n\t<li><code>1 &lt;= k &lt;= s.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1457.二叉树中的伪回文路径",
        "hardRate": "MEDIUM",
        "passRate": "62.08%",
        "problemsUrl": "https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/solution",
        "problemsDesc": "<p>给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「<strong>伪回文</strong>」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。</p>\n\n<p>请你返回从根到叶子节点的所有路径中&nbsp;<strong>伪回文&nbsp;</strong>路径的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/23/palindromic_paths_1.png\" style=\"height: 201px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [2,3,1,3,1,null,1]\n<strong>输出：</strong>2 \n<strong>解释：</strong>上图为给定的二叉树。总共有 3 条从根到叶子的路径：红色路径 [2,3,3] ，绿色路径 [2,1,1] 和路径 [2,3,1] 。\n     在这些路径中，只有红色和绿色的路径是伪回文路径，因为红色路径 [2,3,3] 存在回文排列 [3,2,3] ，绿色路径 [2,1,1] 存在回文排列 [1,2,1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/23/palindromic_paths_2.png\" style=\"height: 314px; width: 300px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [2,1,1,1,3,null,null,null,null,null,1]\n<strong>输出：</strong>1 \n<strong>解释：</strong>上图为给定二叉树。总共有 3 条从根到叶子的路径：绿色路径 [2,1,1] ，路径 [2,1,3,1] 和路径 [2,1] 。\n     这些路径中只有绿色路径是伪回文路径，因为 [2,1,1] 存在回文排列 [1,2,1] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [9]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>给定二叉树的节点数目在范围&nbsp;<code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1458.两个子序列的最大点积",
        "hardRate": "HARD",
        "passRate": "46.87%",
        "problemsUrl": "https://leetcode.cn/problems/max-dot-product-of-two-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/max-dot-product-of-two-subsequences/solution",
        "problemsDesc": "<p>给你两个数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>&nbsp;。</p>\n\n<p>请你返回 <code>nums1</code> 和 <code>nums2</code> 中两个长度相同的 <strong>非空</strong> 子序列的最大点积。</p>\n\n<p>数组的非空子序列是通过删除原数组中某些元素（可能一个也不删除）后剩余数字组成的序列，但不能改变数字间相对顺序。比方说，<code>[2,3,5]</code>&nbsp;是&nbsp;<code>[1,2,3,4,5]</code>&nbsp;的一个子序列而&nbsp;<code>[1,5,3]</code>&nbsp;不是。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [2,1,-2,5], nums2 = [3,0,-6]\n<strong>输出：</strong>18\n<strong>解释：</strong>从 nums1 中得到子序列 [2,-2] ，从 nums2 中得到子序列 [3,-6] 。\n它们的点积为 (2*3 + (-2)*(-6)) = 18 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [3,-2], nums2 = [2,-6,7]\n<strong>输出：</strong>21\n<strong>解释：</strong>从 nums1 中得到子序列 [3] ，从 nums2 中得到子序列 [7] 。\n它们的点积为 (3*7) = 21 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [-1,-1], nums2 = [1,1]\n<strong>输出：</strong>-1\n<strong>解释：</strong>从 nums1 中得到子序列 [-1] ，从 nums2 中得到子序列 [1] 。\n它们的点积为 -1 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 500</code></li>\n\t<li><code>-1000 &lt;= nums1[i], nums2[i] &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>点积：</strong></p>\n\n<pre>\n定义 <code><strong>a</strong>&nbsp;= [<em>a</em><sub>1</sub>,&nbsp;<em>a</em><sub>2</sub>,…,&nbsp;<em>a</em><sub><em>n</em></sub>]</code> 和<strong> <code>b</code></strong><code>&nbsp;= [<em>b</em><sub>1</sub>,&nbsp;<em>b</em><sub>2</sub>,…,&nbsp;<em>b</em><sub><em>n</em></sub>]</code> 的点积为：\n\n<img alt=\"\\mathbf{a}\\cdot \\mathbf{b} = \\sum_{i=1}^n a_ib_i = a_1b_1 + a_2b_2 + \\cdots + a_nb_n \" class=\"tex\" src=\"https://pic.leetcode-cn.com/1666164309-PBJMQp-image.png\" />\n\n这里的 <strong>Σ</strong> 指示总和符号。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1459.矩形面积",
        "hardRate": "MEDIUM",
        "passRate": "62.64%",
        "problemsUrl": "https://leetcode.cn/problems/rectangles-area/",
        "solutionsUrl": "https://leetcode.cn/problems/rectangles-area/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1460.通过翻转子数组使两个数组相等",
        "hardRate": "EASY",
        "passRate": "77.17%",
        "problemsUrl": "https://leetcode.cn/problems/make-two-arrays-equal-by-reversing-subarrays/",
        "solutionsUrl": "https://leetcode.cn/problems/make-two-arrays-equal-by-reversing-subarrays/solution",
        "problemsDesc": "<p>给你两个长度相同的整数数组&nbsp;<code>target</code>&nbsp;和&nbsp;<code>arr</code>&nbsp;。每一步中，你可以选择&nbsp;<code>arr</code>&nbsp;的任意 <strong>非空子数组</strong>&nbsp;并将它翻转。你可以执行此过程任意次。</p>\n\n<p><em>如果你能让 <code>arr</code>&nbsp;变得与 <code>target</code>&nbsp;相同，返回 True；否则，返回 False 。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = [1,2,3,4], arr = [2,4,1,3]\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以按照如下步骤使 arr 变成 target：\n1- 翻转子数组 [2,4,1] ，arr 变成 [1,4,2,3]\n2- 翻转子数组 [4,2] ，arr 变成 [1,2,4,3]\n3- 翻转子数组 [4,3] ，arr 变成 [1,2,3,4]\n上述方法并不是唯一的，还存在多种将 arr 变成 target 的方法。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = [7], arr = [7]\n<strong>输出：</strong>true\n<strong>解释：</strong>arr 不需要做任何翻转已经与 target 相等。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = [3,7,9], arr = [3,7,11]\n<strong>输出：</strong>false\n<strong>解释：</strong>arr 没有数字 9 ，所以无论如何也无法变成 target 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>target.length == arr.length</code></li>\n\t<li><code>1 &lt;= target.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= target[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1461.检查一个字符串是否包含所有长度为 K 的二进制子串",
        "hardRate": "MEDIUM",
        "passRate": "52.54%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-a-string-contains-all-binary-codes-of-size-k/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-a-string-contains-all-binary-codes-of-size-k/solution",
        "problemsDesc": "<p>给你一个二进制字符串&nbsp;<code>s</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。如果所有长度为 <code>k</code>&nbsp;的二进制字符串都是 <code>s</code>&nbsp;的子串，请返回 <code>true</code> ，否则请返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"00110110\", k = 2\n<strong>输出：</strong>true\n<strong>解释：</strong>长度为 2 的二进制串包括 \"00\"，\"01\"，\"10\" 和 \"11\"。它们分别是 s 中下标为 0，1，3，2 开始的长度为 2 的子串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0110\", k = 1\n<strong>输出：</strong>true\n<strong>解释：</strong>长度为 1 的二进制串包括 \"0\" 和 \"1\"，显然它们都是 s 的子串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0110\", k = 2\n<strong>输出：</strong>false\n<strong>解释：</strong>长度为 2 的二进制串 \"00\" 没有出现在 s 中。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 不是<code>'0'</code> 就是 <code>'1'</code></li>\n\t<li><code>1 &lt;= k &lt;= 20</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1462.课程表 IV",
        "hardRate": "MEDIUM",
        "passRate": "45.77%",
        "problemsUrl": "https://leetcode.cn/problems/course-schedule-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/course-schedule-iv/solution",
        "problemsDesc": "<p>你总共需要上<meta charset=\"UTF-8\" />&nbsp;<code>numCourses</code>&nbsp;门课，课程编号依次为 <code>0</code>&nbsp;到&nbsp;<code>numCourses-1</code>&nbsp;。你会得到一个数组&nbsp;<code>prerequisite</code> ，其中<meta charset=\"UTF-8\" />&nbsp;<code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示如果你想选<meta charset=\"UTF-8\" />&nbsp;<code>b<sub>i</sub></code> 课程，你<strong> 必须</strong> 先选<meta charset=\"UTF-8\" />&nbsp;<code>a<sub>i</sub></code>&nbsp;课程。</p>\n\n<ul>\n\t<li>有的课会有直接的先修课程，比如如果想上课程 <code>1</code>&nbsp;，你必须先上课程 <code>0</code>&nbsp;，那么会以 <code>[0,1]</code>&nbsp;数对的形式给出先修课程数对。</li>\n</ul>\n\n<p>先决条件也可以是 <strong>间接</strong> 的。如果课程 <code>a</code> 是课程 <code>b</code> 的先决条件，课程 <code>b</code> 是课程 <code>c</code> 的先决条件，那么课程 <code>a</code> 就是课程 <code>c</code> 的先决条件。</p>\n\n<p>你也得到一个数组<meta charset=\"UTF-8\" />&nbsp;<code>queries</code>&nbsp;，其中<meta charset=\"UTF-8\" />&nbsp;<code>queries[j] = [u<sub>j</sub>, v<sub>j</sub>]</code>。对于第 <code>j</code> 个查询，您应该回答课程<meta charset=\"UTF-8\" />&nbsp;<code>u<sub>j</sub></code>&nbsp;是否是课程<meta charset=\"UTF-8\" />&nbsp;<code>v<sub>j</sub></code>&nbsp;的先决条件。</p>\n\n<p>返回一个布尔数组 <code>answer</code> ，其中 <code>answer[j]</code> 是第 <code>j</code> 个查询的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/01/courses4-1-graph.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]\n<strong>输出：</strong>[false,true]\n<strong>解释：</strong>课程 0 不是课程 1 的先修课程，但课程 1 是课程 0 的先修课程。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>numCourses = 2, prerequisites = [], queries = [[1,0],[0,1]]\n<strong>输出：</strong>[false,false]\n<strong>解释：</strong>没有先修课程对，所以每门课程之间是独立的。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/01/courses4-3-graph.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]]\n<strong>输出：</strong>[true,true]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>2 &lt;= numCourses &lt;= 100</code></li>\n\t<li><code>0 &lt;= prerequisites.length &lt;= (numCourses * (numCourses - 1) / 2)</code></li>\n\t<li><code>prerequisites[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub>&nbsp;&lt;= n - 1</code></li>\n\t<li><code>a<sub>i</sub>&nbsp;!= b<sub>i</sub></code></li>\n\t<li>每一对<meta charset=\"UTF-8\" />&nbsp;<code>[a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;都 <strong>不同</strong></li>\n\t<li>先修课程图中没有环。</li>\n\t<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub>&nbsp;&lt;= n - 1</code></li>\n\t<li><code>u<sub>i</sub>&nbsp;!= v<sub>i</sub></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1463.摘樱桃 II",
        "hardRate": "HARD",
        "passRate": "62.14%",
        "problemsUrl": "https://leetcode.cn/problems/cherry-pickup-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/cherry-pickup-ii/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>rows x cols</code> 的矩阵&nbsp;<code>grid</code>&nbsp;来表示一块樱桃地。 <code>grid</code>&nbsp;中每个格子的数字表示你能获得的樱桃数目。</p>\n\n<p>你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 <code>(0,0)</code> 出发，机器人 2 从右上角格子 <code>(0, cols-1)</code> 出发。</p>\n\n<p>请你按照如下规则，返回两个机器人能收集的最多樱桃数目：</p>\n\n<ul>\n\t<li>从格子&nbsp;<code>(i,j)</code> 出发，机器人可以移动到格子&nbsp;<code>(i+1, j-1)</code>，<code>(i+1, j)</code> 或者&nbsp;<code>(i+1, j+1)</code>&nbsp;。</li>\n\t<li>当一个机器人经过某个格子时，它会把该格子内所有的樱桃都摘走，然后这个位置会变成空格子，即没有樱桃的格子。</li>\n\t<li>当两个机器人同时到达同一个格子时，它们中只有一个可以摘到樱桃。</li>\n\t<li>两个机器人在任意时刻都不能移动到 <code>grid</code>&nbsp;外面。</li>\n\t<li>两个机器人最后都要到达&nbsp;<code>grid</code>&nbsp;最底下一行。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_1_1802.png\" style=\"height: 182px; width: 139px;\"></strong></p>\n\n<pre><strong>输入：</strong>grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]\n<strong>输出：</strong>24\n<strong>解释：</strong>机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。\n机器人 1 摘的樱桃数目为 (3 + 2 + 5 + 2) = 12 。\n机器人 2 摘的樱桃数目为 (1 + 5 + 5 + 1) = 12 。\n樱桃总数为： 12 + 12 = 24 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_2_1802.png\" style=\"height: 257px; width: 284px;\"></strong></p>\n\n<pre><strong>输入：</strong>grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]\n<strong>输出：</strong>28\n<strong>解释：</strong>机器人 1 和机器人 2 的路径在上图中分别用绿色和蓝色表示。\n机器人 1 摘的樱桃数目为 (1 + 9 + 5 + 2) = 17 。\n机器人 2 摘的樱桃数目为 (1 + 3 + 4 + 3) = 11 。\n樱桃总数为： 17 + 11 = 28 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[1,0,0,3],[0,0,0,3],[0,0,3,3],[9,0,3,3]]\n<strong>输出：</strong>22\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>grid = [[1,1],[1,1]]\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rows == grid.length</code></li>\n\t<li><code>cols == grid[i].length</code></li>\n\t<li><code>2 &lt;= rows, cols &lt;= 70</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 100&nbsp;</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1464.数组中两元素的最大乘积",
        "hardRate": "EASY",
        "passRate": "78.57%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-product-of-two-elements-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-product-of-two-elements-in-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code>，请你选择数组的两个不同下标 <code>i</code> 和 <code>j</code><em>，</em>使 <code>(nums[i]-1)*(nums[j]-1)</code> 取得最大值。</p>\n\n<p>请你计算并返回该式的最大值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,4,5,2]\n<strong>输出：</strong>12 \n<strong>解释：</strong>如果选择下标 i=1 和 j=2（下标从 0 开始），则可以获得最大值，(nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,5,4,5]\n<strong>输出：</strong>16\n<strong>解释：</strong>选择下标 i=1 和 j=3（下标从 0 开始），则可以获得最大值 (5-1)*(5-1) = 16 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,7]\n<strong>输出：</strong>12\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^3</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1465.切割后面积最大的蛋糕",
        "hardRate": "MEDIUM",
        "passRate": "32.84%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/solution",
        "problemsDesc": "<p>矩形蛋糕的高度为 <code>h</code> 且宽度为 <code>w</code>，给你两个整数数组 <code>horizontalCuts</code> 和 <code>verticalCuts</code>，其中：</p>\n\n<ul>\n\t<li>&nbsp;<code>horizontalCuts[i]</code> 是从矩形蛋糕顶部到第&nbsp; <code>i</code> 个水平切口的距离</li>\n\t<li><code>verticalCuts[j]</code> 是从矩形蛋糕的左侧到第 <code>j</code> 个竖直切口的距离</li>\n</ul>\n\n<p>请你按数组 <em><code>horizontalCuts</code> </em>和<em> <code>verticalCuts</code> </em>中提供的水平和竖直位置切割后，请你找出 <strong>面积最大</strong> 的那份蛋糕，并返回其 <strong>面积</strong> 。由于答案可能是一个很大的数字，因此需要将结果&nbsp;<strong>对</strong>&nbsp;<code>10<sup>9</sup>&nbsp;+ 7</code>&nbsp;<strong>取余</strong> 后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/leetcode_max_area_2.png\" /></p>\n\n<pre>\n<strong>输入：</strong>h = 5, w = 4, horizontalCuts = [1,2,4], verticalCuts = [1,3]\n<strong>输出：</strong>4 \n<strong>解释：</strong>上图所示的矩阵蛋糕中，红色线表示水平和竖直方向上的切口。切割蛋糕后，绿色的那份蛋糕面积最大。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/leetcode_max_area_3.png\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>h = 5, w = 4, horizontalCuts = [3,1], verticalCuts = [1]\n<strong>输出：</strong>6\n<strong>解释：</strong>上图所示的矩阵蛋糕中，红色线表示水平和竖直方向上的切口。切割蛋糕后，绿色和黄色的两份蛋糕面积最大。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>h = 5, w = 4, horizontalCuts = [3], verticalCuts = [3]\n<strong>输出：</strong>9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= h, w &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= horizontalCuts.length &lt;= min(h - 1, 10<sup>5</sup>)</code></li>\n\t<li><code>1 &lt;= verticalCuts.length &lt;= min(w - 1, 10<sup>5</sup>)</code></li>\n\t<li><code>1 &lt;= horizontalCuts[i] &lt; h</code></li>\n\t<li><code>1 &lt;= verticalCuts[i] &lt; w</code></li>\n\t<li>题目数据保证 <code>horizontalCuts</code> 中的所有元素各不相同</li>\n\t<li>题目数据保证 <code>verticalCuts</code>&nbsp;中的所有元素各不相同</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1466.重新规划路线",
        "hardRate": "MEDIUM",
        "passRate": "51.11%",
        "problemsUrl": "https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/solution",
        "problemsDesc": "<p><code>n</code> 座城市，从 <code>0</code> 到 <code>n-1</code> 编号，其间共有 <code>n-1</code> 条路线。因此，要想在两座不同城市之间旅行只有唯一一条路线可供选择（路线网形成一颗树）。去年，交通运输部决定重新规划路线，以改变交通拥堵的状况。</p>\n\n<p>路线用 <code>connections</code> 表示，其中 <code>connections[i] = [a, b]</code> 表示从城市 <code>a</code> 到 <code>b</code> 的一条有向路线。</p>\n\n<p>今年，城市 0 将会举办一场大型比赛，很多游客都想前往城市 0 。</p>\n\n<p>请你帮助重新规划路线方向，使每个城市都可以访问城市 0 。返回需要变更方向的最小路线数。</p>\n\n<p>题目数据 <strong>保证</strong> 每个城市在重新规划路线方向后都能到达城市 0 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_1_1819.png\" style=\"height: 150px; width: 240px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]\n<strong>输出：</strong>3\n<strong>解释：</strong>更改以红色显示的路线的方向，使每个城市都可以到达城市 0 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/sample_2_1819.png\" style=\"height: 60px; width: 380px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]\n<strong>输出：</strong>2\n<strong>解释：</strong>更改以红色显示的路线的方向，使每个城市都可以到达城市 0 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 3, connections = [[1,0],[2,0]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 5 * 10^4</code></li>\n\t<li><code>connections.length == n-1</code></li>\n\t<li><code>connections[i].length == 2</code></li>\n\t<li><code>0 &lt;= connections[i][0], connections[i][1] &lt;= n-1</code></li>\n\t<li><code>connections[i][0] != connections[i][1]</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1467.两个盒子中球的颜色数相同的概率",
        "hardRate": "HARD",
        "passRate": "63.16%",
        "problemsUrl": "https://leetcode.cn/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/",
        "solutionsUrl": "https://leetcode.cn/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/solution",
        "problemsDesc": "<p>桌面上有 <code>2n</code> 个颜色不完全相同的球，球上的颜色共有 <code>k</code> 种。给你一个大小为 <code>k</code> 的整数数组 <code>balls</code> ，其中 <code>balls[i]</code> 是颜色为&nbsp;<code>i</code> 的球的数量。</p>\n\n<p>所有的球都已经 <strong>随机打乱顺序</strong> ，前 <code>n</code> 个球放入第一个盒子，后 <code>n</code> 个球放入另一个盒子（请认真阅读示例 2 的解释部分）。</p>\n\n<p><strong>注意：</strong>这两个盒子是不同的。例如，两个球颜色分别为 <code>a</code> 和 <code>b</code>，盒子分别为 <code>[]</code> 和 <code>()</code>，那么 <code>[a] (b)</code> 和 <code>[b] (a)</code> 这两种分配方式是不同的（请认真阅读示例的解释部分）。</p>\n\n<p>请返回「两个盒子中球的颜色数相同」的情况的概率。答案与真实值误差在 <code>10^-5</code> 以内，则被视为正确答案</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>balls = [1,1]\n<strong>输出：</strong>1.00000\n<strong>解释：</strong>球平均分配的方式只有两种：\n- 颜色为 1 的球放入第一个盒子，颜色为 2 的球放入第二个盒子\n- 颜色为 2 的球放入第一个盒子，颜色为 1 的球放入第二个盒子\n这两种分配，两个盒子中球的颜色数都相同。所以概率为 2/2 = 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>balls = [2,1,1]\n<strong>输出：</strong>0.66667\n<strong>解释：</strong>球的列表为 [1, 1, 2, 3]\n随机打乱，得到 12 种等概率的不同打乱方案，每种方案概率为 1/12 ：\n[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\n然后，我们将前两个球放入第一个盒子，后两个球放入第二个盒子。\n这 12 种可能的随机打乱方式中的 8 种满足「两个盒子中球的颜色数相同」。\n概率 = 8/12 = 0.66667\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>balls = [1,2,1,2]\n<strong>输出：</strong>0.60000\n<strong>解释：</strong>球的列表为 [1, 2, 2, 3, 4, 4]。要想显示所有 180 种随机打乱方案是很难的，但只检查「两个盒子中球的颜色数相同」的 108 种情况是比较容易的。\n概率 = 108 / 180 = 0.6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= balls.length &lt;= 8</code></li>\n\t<li><code>1 &lt;= balls[i] &lt;= 6</code></li>\n\t<li><code>sum(balls)</code> 是偶数</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1468.计算税后工资",
        "hardRate": "MEDIUM",
        "passRate": "69.98%",
        "problemsUrl": "https://leetcode.cn/problems/calculate-salaries/",
        "solutionsUrl": "https://leetcode.cn/problems/calculate-salaries/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1469.寻找所有的独生节点",
        "hardRate": "EASY",
        "passRate": "82.22%",
        "problemsUrl": "https://leetcode.cn/problems/find-all-the-lonely-nodes/",
        "solutionsUrl": "https://leetcode.cn/problems/find-all-the-lonely-nodes/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1470.重新排列数组",
        "hardRate": "EASY",
        "passRate": "84.87%",
        "problemsUrl": "https://leetcode.cn/problems/shuffle-the-array/",
        "solutionsUrl": "https://leetcode.cn/problems/shuffle-the-array/solution",
        "problemsDesc": "<p>给你一个数组 <code>nums</code> ，数组中有 <code>2n</code> 个元素，按 <code>[x<sub>1</sub>,x<sub>2</sub>,...,x<sub>n</sub>,y<sub>1</sub>,y<sub>2</sub>,...,y<sub>n</sub>]</code> 的格式排列。</p>\n\n<p>请你将数组按 <code>[x<sub>1</sub>,y<sub>1</sub>,x<sub>2</sub>,y<sub>2</sub>,...,x<sub>n</sub>,y<sub>n</sub>]</code> 格式重新排列，返回重排后的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,5,1,3,4,7], n = 3\n<strong>输出：</strong>[2,3,5,4,1,7] \n<strong>解释：</strong>由于 x<sub>1</sub>=2, x<sub>2</sub>=5, x<sub>3</sub>=1, y<sub>1</sub>=3, y<sub>2</sub>=4, y<sub>3</sub>=7 ，所以答案为 [2,3,5,4,1,7]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4,4,3,2,1], n = 4\n<strong>输出：</strong>[1,4,2,3,3,2,4,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,2,2], n = 2\n<strong>输出：</strong>[1,2,1,2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>nums.length == 2n</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^3</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1471.数组中的 k 个最强值",
        "hardRate": "MEDIUM",
        "passRate": "55.55%",
        "problemsUrl": "https://leetcode.cn/problems/the-k-strongest-values-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/the-k-strongest-values-in-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> 和一个整数 <code>k</code> 。</p>\n\n<p>设 <code>m</code> 为数组的中位数，只要满足下述两个前提之一，就可以判定 <code>arr[i]</code> 的值比 <code>arr[j]</code> 的值更强：</p>\n\n<ul>\n\t<li>&nbsp;<code>|arr[i] - m| &gt; |arr[j]&nbsp;- m|</code></li>\n\t<li>&nbsp;<code>|arr[i] - m| == |arr[j] - m|</code>，且 <code>arr[i] &gt; arr[j]</code></li>\n</ul>\n\n<p>请返回由数组中最强的 <code>k</code> 个值组成的列表。答案可以以 <strong>任意顺序</strong> 返回。</p>\n\n<p><strong>中位数</strong> 是一个有序整数列表中处于中间位置的值。形式上，如果列表的长度为 <code>n</code> ，那么中位数就是该有序列表（下标从 0 开始）中位于 <code>((n - 1) / 2)</code> 的元素。</p>\n\n<ul>\n\t<li>例如 <code>arr =&nbsp;[6, -3, 7, 2, 11]</code>，<code>n = 5</code>：数组排序后得到 <code>arr = [-3, 2, 6, 7, 11]</code> ，数组的中间位置为 <code>m = ((5 - 1) / 2) = 2</code> ，中位数 <code>arr[m]</code> 的值为 <code>6</code> 。</li>\n\t<li>例如 <code>arr =&nbsp;[-7, 22, 17,&thinsp;3]</code>，<code>n = 4</code>：数组排序后得到&nbsp;<code>arr = [-7, 3, 17, 22]</code> ，数组的中间位置为&nbsp;<code>m = ((4 - 1) / 2) = 1</code> ，中位数 <code>arr[m]</code> 的值为 <code>3</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,2,3,4,5], k = 2\n<strong>输出：</strong>[5,1]\n<strong>解释：</strong>中位数为 3，按从强到弱顺序排序后，数组变为 [5,1,4,2,3]。最强的两个元素是 [5, 1]。[1, 5] 也是正确答案。\n注意，尽管 |5 - 3| == |1 - 3| ，但是 5 比 1 更强，因为 5 &gt; 1 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [1,1,3,5,5], k = 2\n<strong>输出：</strong>[5,5]\n<strong>解释：</strong>中位数为 3, 按从强到弱顺序排序后，数组变为 [5,5,1,1,3]。最强的两个元素是 [5, 5]。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [6,7,11,7,6,8], k = 5\n<strong>输出：</strong>[11,8,6,6,7]\n<strong>解释：</strong>中位数为 7, 按从强到弱顺序排序后，数组变为 [11,8,6,6,7,7]。\n[11,8,6,6,7] 的任何排列都是正确答案。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [6,-3,7,2,11], k = 3\n<strong>输出：</strong>[-3,11,2]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [-7,22,17,3], k = 2\n<strong>输出：</strong>[22,17]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>\n\t<li><code>-10^5 &lt;= arr[i] &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= k &lt;= arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1472.设计浏览器历史记录",
        "hardRate": "MEDIUM",
        "passRate": "61.48%",
        "problemsUrl": "https://leetcode.cn/problems/design-browser-history/",
        "solutionsUrl": "https://leetcode.cn/problems/design-browser-history/solution",
        "problemsDesc": "<p>你有一个只支持单个标签页的 <strong>浏览器</strong>&nbsp;，最开始你浏览的网页是&nbsp;<code>homepage</code>&nbsp;，你可以访问其他的网站&nbsp;<code>url</code>&nbsp;，也可以在浏览历史中后退&nbsp;<code>steps</code>&nbsp;步或前进&nbsp;<code>steps</code>&nbsp;步。</p>\n\n<p>请你实现&nbsp;<code>BrowserHistory</code> 类：</p>\n\n<ul>\n\t<li><code>BrowserHistory(string homepage)</code>&nbsp;，用&nbsp;<code>homepage</code>&nbsp;初始化浏览器类。</li>\n\t<li><code>void visit(string url)</code>&nbsp;从当前页跳转访问 <code>url</code> 对应的页面&nbsp;&nbsp;。执行此操作会把浏览历史前进的记录全部删除。</li>\n\t<li><code>string back(int steps)</code>&nbsp;在浏览历史中后退&nbsp;<code>steps</code>&nbsp;步。如果你只能在浏览历史中后退至多&nbsp;<code>x</code> 步且&nbsp;<code>steps &gt; x</code>&nbsp;，那么你只后退&nbsp;<code>x</code>&nbsp;步。请返回后退 <strong>至多</strong> <code>steps</code>&nbsp;步以后的&nbsp;<code>url</code>&nbsp;。</li>\n\t<li><code>string forward(int steps)</code>&nbsp;在浏览历史中前进&nbsp;<code>steps</code>&nbsp;步。如果你只能在浏览历史中前进至多&nbsp;<code>x</code>&nbsp;步且&nbsp;<code>steps &gt; x</code>&nbsp;，那么你只前进 <code>x</code>&nbsp;步。请返回前进&nbsp;<strong>至多</strong>&nbsp;<code>steps</code>步以后的 <code>url</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre><strong>输入：</strong>\n[&quot;BrowserHistory&quot;,&quot;visit&quot;,&quot;visit&quot;,&quot;visit&quot;,&quot;back&quot;,&quot;back&quot;,&quot;forward&quot;,&quot;visit&quot;,&quot;forward&quot;,&quot;back&quot;,&quot;back&quot;]\n[[&quot;leetcode.com&quot;],[&quot;google.com&quot;],[&quot;facebook.com&quot;],[&quot;youtube.com&quot;],[1],[1],[1],[&quot;linkedin.com&quot;],[2],[2],[7]]\n<strong>输出：</strong>\n[null,null,null,null,&quot;facebook.com&quot;,&quot;google.com&quot;,&quot;facebook.com&quot;,null,&quot;linkedin.com&quot;,&quot;google.com&quot;,&quot;leetcode.com&quot;]\n\n<strong>解释：</strong>\nBrowserHistory browserHistory = new BrowserHistory(&quot;leetcode.com&quot;);\nbrowserHistory.visit(&quot;google.com&quot;);       // 你原本在浏览 &quot;leetcode.com&quot; 。访问 &quot;google.com&quot;\nbrowserHistory.visit(&quot;facebook.com&quot;);     // 你原本在浏览 &quot;google.com&quot; 。访问 &quot;facebook.com&quot;\nbrowserHistory.visit(&quot;youtube.com&quot;);      // 你原本在浏览 &quot;facebook.com&quot; 。访问 &quot;youtube.com&quot;\nbrowserHistory.back(1);                   // 你原本在浏览 &quot;youtube.com&quot; ，后退到 &quot;facebook.com&quot; 并返回 &quot;facebook.com&quot;\nbrowserHistory.back(1);                   // 你原本在浏览 &quot;facebook.com&quot; ，后退到 &quot;google.com&quot; 并返回 &quot;google.com&quot;\nbrowserHistory.forward(1);                // 你原本在浏览 &quot;google.com&quot; ，前进到 &quot;facebook.com&quot; 并返回 &quot;facebook.com&quot;\nbrowserHistory.visit(&quot;linkedin.com&quot;);     // 你原本在浏览 &quot;facebook.com&quot; 。 访问 &quot;linkedin.com&quot;\nbrowserHistory.forward(2);                // 你原本在浏览 &quot;linkedin.com&quot; ，你无法前进任何步数。\nbrowserHistory.back(2);                   // 你原本在浏览 &quot;linkedin.com&quot; ，后退两步依次先到 &quot;facebook.com&quot; ，然后到 &quot;google.com&quot; ，并返回 &quot;google.com&quot;\nbrowserHistory.back(7);                   // 你原本在浏览 &quot;google.com&quot;， 你只能后退一步到 &quot;leetcode.com&quot; ，并返回 &quot;leetcode.com&quot;\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= homepage.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= url.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= steps &lt;= 100</code></li>\n\t<li><code>homepage</code> 和&nbsp;<code>url</code>&nbsp;都只包含&nbsp;&#39;.&#39; 或者小写英文字母。</li>\n\t<li>最多调用&nbsp;<code>5000</code>&nbsp;次&nbsp;<code>visit</code>，&nbsp;<code>back</code>&nbsp;和&nbsp;<code>forward</code>&nbsp;函数。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1473.粉刷房子 III",
        "hardRate": "HARD",
        "passRate": "66.34%",
        "problemsUrl": "https://leetcode.cn/problems/paint-house-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/paint-house-iii/solution",
        "problemsDesc": "<p>在一个小城市里，有 <code>m</code> 个房子排成一排，你需要给每个房子涂上 <code>n</code> 种颜色之一（颜色编号为 <code>1</code> 到 <code>n</code> ）。有的房子去年夏天已经涂过颜色了，所以这些房子不可以被重新涂色。</p>\n\n<p>我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 <code>houses = [1,2,2,3,3,2,1,1]</code> ，它包含 5 个街区 <code> [{1}, {2,2}, {3,3}, {2}, {1,1}]</code> 。）</p>\n\n<p>给你一个数组 <code>houses</code> ，一个 <code>m * n</code> 的矩阵 <code>cost</code> 和一个整数 <code>target</code> ，其中：</p>\n\n<ul>\n\t<li><code>houses[i]</code>：是第 <code>i</code> 个房子的颜色，<strong>0</strong> 表示这个房子还没有被涂色。</li>\n\t<li><code>cost[i][j]</code>：是将第 <code>i</code> 个房子涂成颜色 <code>j+1</code> 的花费。</li>\n</ul>\n\n<p>请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成 <code>target</code> 个街区。如果没有可用的涂色方案，请返回 <strong>-1</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3\n<strong>输出：</strong>9\n<strong>解释：</strong>房子涂色方案为 [1,2,2,1,1]\n此方案包含 target = 3 个街区，分别是 [{1}, {2,2}, {1,1}]。\n涂色的总花费为 (1 + 1 + 1 + 1 + 5) = 9。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3\n<strong>输出：</strong>11\n<strong>解释：</strong>有的房子已经被涂色了，在此基础上涂色方案为 [2,2,1,2,2]\n此方案包含 target = 3 个街区，分别是 [{2,2}, {1}, {2,2}]。\n给第一个和最后一个房子涂色的花费为 (10 + 1) = 11。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>houses = [0,0,0,0,0], cost = [[1,10],[10,1],[1,10],[10,1],[1,10]], m = 5, n = 2, target = 5\n<strong>输出：</strong>5\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3\n<strong>输出：</strong>-1\n<strong>解释：</strong>房子已经被涂色并组成了 4 个街区，分别是 [{3},{1},{2},{3}] ，无法形成 target = 3 个街区。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == houses.length == cost.length</code></li>\n\t<li><code>n == cost[i].length</code></li>\n\t<li><code>1 <= m <= 100</code></li>\n\t<li><code>1 <= n <= 20</code></li>\n\t<li><code>1 <= target <= m</code></li>\n\t<li><code>0 <= houses[i] <= n</code></li>\n\t<li><code>1 <= cost[i][j] <= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1474.删除链表 M 个节点之后的 N 个节点",
        "hardRate": "EASY",
        "passRate": "69.18%",
        "problemsUrl": "https://leetcode.cn/problems/delete-n-nodes-after-m-nodes-of-a-linked-list/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-n-nodes-after-m-nodes-of-a-linked-list/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1475.商品折扣后的最终价格",
        "hardRate": "EASY",
        "passRate": "73.27%",
        "problemsUrl": "https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/",
        "solutionsUrl": "https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/solution",
        "problemsDesc": "<p>给你一个数组&nbsp;<code>prices</code>&nbsp;，其中&nbsp;<code>prices[i]</code>&nbsp;是商店里第&nbsp;<code>i</code>&nbsp;件商品的价格。</p>\n\n<p>商店里正在进行促销活动，如果你要买第&nbsp;<code>i</code>&nbsp;件商品，那么你可以得到与 <code>prices[j]</code> 相等的折扣，其中&nbsp;<code>j</code>&nbsp;是满足&nbsp;<code>j &gt; i</code>&nbsp;且&nbsp;<code>prices[j] &lt;= prices[i]</code>&nbsp;的&nbsp;<strong>最小下标</strong>&nbsp;，如果没有满足条件的&nbsp;<code>j</code>&nbsp;，你将没有任何折扣。</p>\n\n<p>请你返回一个数组，数组中第&nbsp;<code>i</code>&nbsp;个元素是折扣后你购买商品 <code>i</code>&nbsp;最终需要支付的价格。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>prices = [8,4,6,2,3]\n<strong>输出：</strong>[4,2,4,2,3]\n<strong>解释：</strong>\n商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。\n商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。\n商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。\n商品 3 和 4 都没有折扣。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>prices = [1,2,3,4,5]\n<strong>输出：</strong>[1,2,3,4,5]\n<strong>解释：</strong>在这个例子中，所有商品都没有折扣。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>prices = [10,1,1,6]\n<strong>输出：</strong>[9,0,1,6]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= prices[i] &lt;= 10^3</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1476.子矩形查询",
        "hardRate": "MEDIUM",
        "passRate": "86.59%",
        "problemsUrl": "https://leetcode.cn/problems/subrectangle-queries/",
        "solutionsUrl": "https://leetcode.cn/problems/subrectangle-queries/solution",
        "problemsDesc": "<p>请你实现一个类&nbsp;<code>SubrectangleQueries</code>&nbsp;，它的构造函数的参数是一个 <code>rows x cols</code>&nbsp;的矩形（这里用整数矩阵表示），并支持以下两种操作：</p>\n\n<p>1.<code>&nbsp;updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)</code></p>\n\n<ul>\n\t<li>用&nbsp;<code>newValue</code>&nbsp;更新以&nbsp;<code>(row1,col1)</code>&nbsp;为左上角且以&nbsp;<code>(row2,col2)</code>&nbsp;为右下角的子矩形。</li>\n</ul>\n\n<p>2.<code>&nbsp;getValue(int row, int col)</code></p>\n\n<ul>\n\t<li>返回矩形中坐标 <code>(row,col)</code> 的当前值。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>\n[&quot;SubrectangleQueries&quot;,&quot;getValue&quot;,&quot;updateSubrectangle&quot;,&quot;getValue&quot;,&quot;getValue&quot;,&quot;updateSubrectangle&quot;,&quot;getValue&quot;,&quot;getValue&quot;]\n[[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]]\n<strong>输出：</strong>\n[null,1,null,5,5,null,10,5]\n<strong>解释：</strong>\nSubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]);  \n// 初始的 (4x3) 矩形如下：\n// 1 2 1\n// 4 3 4\n// 3 2 1\n// 1 1 1\nsubrectangleQueries.getValue(0, 2); // 返回 1\nsubrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5);\n// 此次更新后矩形变为：\n// 5 5 5\n// 5 5 5\n// 5 5 5\n// 5 5 5 \nsubrectangleQueries.getValue(0, 2); // 返回 5\nsubrectangleQueries.getValue(3, 1); // 返回 5\nsubrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10);\n// 此次更新后矩形变为：\n// 5   5   5\n// 5   5   5\n// 5   5   5\n// 10  10  10 \nsubrectangleQueries.getValue(3, 1); // 返回 10\nsubrectangleQueries.getValue(0, 2); // 返回 5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>\n[&quot;SubrectangleQueries&quot;,&quot;getValue&quot;,&quot;updateSubrectangle&quot;,&quot;getValue&quot;,&quot;getValue&quot;,&quot;updateSubrectangle&quot;,&quot;getValue&quot;]\n[[[[1,1,1],[2,2,2],[3,3,3]]],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]]\n<strong>输出：</strong>\n[null,1,null,100,100,null,20]\n<strong>解释：</strong>\nSubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,1,1],[2,2,2],[3,3,3]]);\nsubrectangleQueries.getValue(0, 0); // 返回 1\nsubrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100);\nsubrectangleQueries.getValue(0, 0); // 返回 100\nsubrectangleQueries.getValue(2, 2); // 返回 100\nsubrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20);\nsubrectangleQueries.getValue(2, 2); // 返回 20\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>最多有&nbsp;<code>500</code>&nbsp;次<code>updateSubrectangle</code> 和&nbsp;<code>getValue</code>&nbsp;操作。</li>\n\t<li><code>1 &lt;= rows, cols &lt;= 100</code></li>\n\t<li><code>rows ==&nbsp;rectangle.length</code></li>\n\t<li><code>cols == rectangle[i].length</code></li>\n\t<li><code>0 &lt;= row1 &lt;= row2 &lt; rows</code></li>\n\t<li><code>0 &lt;= col1 &lt;= col2 &lt; cols</code></li>\n\t<li><code>1 &lt;= newValue, rectangle[i][j] &lt;= 10^9</code></li>\n\t<li><code>0 &lt;= row &lt; rows</code></li>\n\t<li><code>0 &lt;= col &lt; cols</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1477.找两个和为目标值且不重叠的子数组",
        "hardRate": "MEDIUM",
        "passRate": "31.17%",
        "problemsUrl": "https://leetcode.cn/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code> 和一个整数值&nbsp;<code>target</code>&nbsp;。</p>\n\n<p>请你在 <code>arr</code>&nbsp;中找 <strong>两个互不重叠的子数组</strong>&nbsp;且它们的和都等于&nbsp;<code>target</code>&nbsp;。可能会有多种方案，请你返回满足要求的两个子数组长度和的 <strong>最小值</strong> 。</p>\n\n<p>请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 <strong>-1</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,2,2,4,3], target = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>只有两个子数组和为 3 （[3] 和 [3]）。它们的长度和为 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [7,3,4,7], target = 7\n<strong>输出：</strong>2\n<strong>解释：</strong>尽管我们有 3 个互不重叠的子数组和为 7 （[7], [3,4] 和 [7]），但我们会选择第一个和第三个子数组，因为它们的长度和 2 是最小值。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [4,3,2,6,2,3,4], target = 6\n<strong>输出：</strong>-1\n<strong>解释：</strong>我们只有一个和为 6 的子数组。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [5,5,4,4,5], target = 3\n<strong>输出：</strong>-1\n<strong>解释：</strong>我们无法找到和为 3 的子数组。\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,1,1,1,5,1,2,1], target = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>注意子数组 [1,2] 和 [2,1] 不能成为一个方案因为它们重叠了。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= target &lt;= 10^8</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1478.安排邮筒",
        "hardRate": "HARD",
        "passRate": "62.68%",
        "problemsUrl": "https://leetcode.cn/problems/allocate-mailboxes/",
        "solutionsUrl": "https://leetcode.cn/problems/allocate-mailboxes/solution",
        "problemsDesc": "<p>给你一个房屋数组<code>houses</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;，其中&nbsp;<code>houses[i]</code>&nbsp;是第 <code>i</code>&nbsp;栋房子在一条街上的位置，现需要在这条街上安排 <code>k</code>&nbsp;个邮筒。</p>\n\n<p>请你返回每栋房子与离它最近的邮筒之间的距离的 <strong>最小 </strong>总和。</p>\n\n<p>答案保证在 32 位有符号整数范围以内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/13/sample_11_1816.png\" style=\"height: 154px; width: 454px;\"></p>\n\n<pre><strong>输入：</strong>houses = [1,4,8,10,20], k = 3\n<strong>输出：</strong>5\n<strong>解释：</strong>将邮筒分别安放在位置 3， 9 和 20 处。\n每个房子到最近邮筒的距离和为 |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/13/sample_2_1816.png\" style=\"height: 154px; width: 433px;\"></strong></p>\n\n<pre><strong>输入：</strong>houses = [2,3,5,12,18], k = 2\n<strong>输出：</strong>9\n<strong>解释：</strong>将邮筒分别安放在位置 3 和 14 处。\n每个房子到最近邮筒距离和为 |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>houses = [7,4,6,1], k = 1\n<strong>输出：</strong>8\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>houses = [3,6,14,10], k = 4\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == houses.length</code></li>\n\t<li><code>1 &lt;= n&nbsp;&lt;= 100</code></li>\n\t<li><code>1 &lt;= houses[i] &lt;= 10^4</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n\t<li>数组&nbsp;<code>houses</code>&nbsp;中的整数互不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1479.周内每天的销售情况",
        "hardRate": "HARD",
        "passRate": "55.72%",
        "problemsUrl": "https://leetcode.cn/problems/sales-by-day-of-the-week/",
        "solutionsUrl": "https://leetcode.cn/problems/sales-by-day-of-the-week/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1480.一维数组的动态和",
        "hardRate": "EASY",
        "passRate": "76.53%",
        "problemsUrl": "https://leetcode.cn/problems/running-sum-of-1d-array/",
        "solutionsUrl": "https://leetcode.cn/problems/running-sum-of-1d-array/solution",
        "problemsDesc": "<p>给你一个数组 <code>nums</code> 。数组「动态和」的计算公式为：<code>runningSum[i] = sum(nums[0]&hellip;nums[i])</code> 。</p>\n\n<p>请返回 <code>nums</code> 的动态和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>[1,3,6,10]\n<strong>解释：</strong>动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [1,1,1,1,1]\n<strong>输出：</strong>[1,2,3,4,5]\n<strong>解释：</strong>动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>nums = [3,1,2,10,1]\n<strong>输出：</strong>[3,4,6,16,17]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-10^6&nbsp;&lt;= nums[i] &lt;=&nbsp;10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1481.不同整数的最少数目",
        "hardRate": "MEDIUM",
        "passRate": "45.24%",
        "problemsUrl": "https://leetcode.cn/problems/least-number-of-unique-integers-after-k-removals/",
        "solutionsUrl": "https://leetcode.cn/problems/least-number-of-unique-integers-after-k-removals/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> 和一个整数 <code>k</code> 。现需要从数组中恰好移除 <code>k</code> 个元素，请找出移除后数组中不同整数的最少数目。</p>\n\n<ol>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [5,5,4], k = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>移除 1 个 4 ，数组中只剩下 5 一种整数。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [4,3,1,1,3,3,2], k = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>先移除 4、2 ，然后再移除两个 1 中的任意 1 个或者三个 3 中的任意 1 个，最后剩下 1 和 3 两种整数。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length&nbsp;&lt;= 10^5</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10^9</code></li>\n\t<li><code>0 &lt;= k&nbsp;&lt;= arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1482.制作 m 束花所需的最少天数",
        "hardRate": "MEDIUM",
        "passRate": "56.77%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>bloomDay</code>，以及两个整数 <code>m</code> 和 <code>k</code> 。</p>\n\n<p>现需要制作 <code>m</code> 束花。制作花束时，需要使用花园中 <strong>相邻的 <code>k</code> 朵花</strong> 。</p>\n\n<p>花园中有 <code>n</code> 朵花，第 <code>i</code> 朵花会在 <code>bloomDay[i]</code> 时盛开，<strong>恰好</strong> 可以用于 <strong>一束</strong> 花中。</p>\n\n<p>请你返回从花园中摘 <code>m</code> 束花需要等待的最少的天数。如果不能摘到 <code>m</code> 束花则返回 <strong>-1</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>bloomDay = [1,10,3,10,2], m = 3, k = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。\n现在需要制作 3 束花，每束只需要 1 朵。\n1 天后：[x, _, _, _, _]   // 只能制作 1 束花\n2 天后：[x, _, _, _, x]   // 只能制作 2 束花\n3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>bloomDay = [1,10,3,10,2], m = 3, k = 2\n<strong>输出：</strong>-1\n<strong>解释：</strong>要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3\n<strong>输出：</strong>12\n<strong>解释：</strong>要制作 2 束花，每束需要 3 朵。\n花园在 7 天后和 12 天后的情况如下：\n7 天后：[x, x, x, x, _, x, x]\n可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。\n12 天后：[x, x, x, x, x, x, x]\n显然，我们可以用不同的方式制作两束花。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>bloomDay = [1000000000,1000000000], m = 1, k = 1\n<strong>输出：</strong>1000000000\n<strong>解释：</strong>需要等 1000000000 天才能采到花来制作花束\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2\n<strong>输出：</strong>9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>bloomDay.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= bloomDay[i] &lt;= 10^9</code></li>\n\t<li><code>1 &lt;= m &lt;= 10^6</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1483.树节点的第 K 个祖先",
        "hardRate": "HARD",
        "passRate": "44.94%",
        "problemsUrl": "https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/",
        "solutionsUrl": "https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/solution",
        "problemsDesc": "<p>给你一棵树，树上有 <code>n</code> 个节点，按从 <code>0</code> 到 <code>n-1</code> 编号。树以父节点数组的形式给出，其中 <code>parent[i]</code> 是节点 <code>i</code> 的父节点。树的根节点是编号为 <code>0</code> 的节点。</p>\n\n<p>树节点的第 <em><code>k</code> </em>个祖先节点是从该节点到根节点路径上的第 <code>k</code> 个节点。</p>\n\n<p>实现 <code>TreeAncestor</code> 类：</p>\n\n<ul>\n\t<li><code>TreeAncestor（int n， int[] parent）</code> 对树和父数组中的节点数初始化对象。</li>\n\t<li><code>getKthAncestor</code><code>(int node, int k)</code> 返回节点 <code>node</code> 的第 <code>k</code> 个祖先节点。如果不存在这样的祖先节点，返回 <code>-1</code>&nbsp;。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/14/1528_ex1.png\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"TreeAncestor\",\"getKthAncestor\",\"getKthAncestor\",\"getKthAncestor\"]\n[[7,[-1,0,0,1,1,2,2]],[3,1],[5,2],[6,3]]\n\n<strong>输出：</strong>\n[null,1,0,-1]\n\n<strong>解释：</strong>\nTreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);\n\ntreeAncestor.getKthAncestor(3, 1);  // 返回 1 ，它是 3 的父节点\ntreeAncestor.getKthAncestor(5, 2);  // 返回 0 ，它是 5 的祖父节点\ntreeAncestor.getKthAncestor(6, 3);  // 返回 -1 因为不存在满足要求的祖先节点\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>parent[0] == -1</code> 表示编号为 <code>0</code> 的节点是根节点。</li>\n\t<li>对于所有的 <code>0 &lt;&nbsp;i &lt; n</code> ，<code>0 &lt;= parent[i] &lt; n</code> 总成立</li>\n\t<li><code>0 &lt;= node &lt; n</code></li>\n\t<li>至多查询&nbsp;<code>5 * 10<sup>4</sup></code> 次</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1484.按日期分组销售产品",
        "hardRate": "EASY",
        "passRate": "67.75%",
        "problemsUrl": "https://leetcode.cn/problems/group-sold-products-by-the-date/",
        "solutionsUrl": "https://leetcode.cn/problems/group-sold-products-by-the-date/solution",
        "problemsDesc": "<p>表&nbsp;<code>Activities</code>：</p>\n\n<pre>\n+-------------+---------+\n| 列名         | 类型    |\n+-------------+---------+\n| sell_date   | date    |\n| product     | varchar |\n+-------------+---------+\n此表没有主键，它可能包含重复项。\n此表的每一行都包含产品名称和在市场上销售的日期。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个 SQL 查询来查找每个日期、销售的不同产品的数量及其名称。<br />\n每个日期的销售产品名称应按词典序排列。<br />\n返回按&nbsp;<code>sell_date</code> 排序的结果表。<br />\n查询结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<code><strong>输入：</strong>\nActivities</code> 表：\n+------------+-------------+\n| sell_date  | product     |\n+------------+-------------+\n| 2020-05-30 | Headphone   |\n| 2020-06-01 | Pencil      |\n| 2020-06-02 | Mask        |\n| 2020-05-30 | Basketball  |\n| 2020-06-01 | Bible       |\n| 2020-06-02 | Mask        |\n| 2020-05-30 | T-Shirt     |\n+------------+-------------+\n<strong>输出：</strong>\n+------------+----------+------------------------------+\n| sell_date  | num_sold | products                     |\n+------------+----------+------------------------------+\n| 2020-05-30 | 3        | Basketball,Headphone,T-shirt |\n| 2020-06-01 | 2        | Bible,Pencil                 |\n| 2020-06-02 | 1        | Mask                         |\n+------------+----------+------------------------------+\n<strong>解释：</strong>\n对于2020-05-30，出售的物品是 (Headphone, Basketball, T-shirt)，按词典序排列，并用逗号 ',' 分隔。\n对于2020-06-01，出售的物品是 (Pencil, Bible)，按词典序排列，并用逗号分隔。\n对于2020-06-02，出售的物品是 (Mask)，只需返回该物品名。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1485.克隆含随机指针的二叉树",
        "hardRate": "MEDIUM",
        "passRate": "78.64%",
        "problemsUrl": "https://leetcode.cn/problems/clone-binary-tree-with-random-pointer/",
        "solutionsUrl": "https://leetcode.cn/problems/clone-binary-tree-with-random-pointer/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1486.数组异或操作",
        "hardRate": "EASY",
        "passRate": "85.49%",
        "problemsUrl": "https://leetcode.cn/problems/xor-operation-in-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/xor-operation-in-an-array/solution",
        "problemsDesc": "<p>给你两个整数，<code>n</code> 和 <code>start</code> 。</p>\n\n<p>数组 <code>nums</code> 定义为：<code>nums[i] = start + 2*i</code>（下标从 0 开始）且 <code>n == nums.length</code> 。</p>\n\n<p>请返回 <code>nums</code> 中所有元素按位异或（<strong>XOR</strong>）后得到的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 5, start = 0\n<strong>输出：</strong>8\n<strong>解释：</strong>数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。\n     &quot;^&quot; 为按位异或 XOR 运算符。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 4, start = 3\n<strong>输出：</strong>8\n<strong>解释：</strong>数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8.</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 1, start = 7\n<strong>输出：</strong>7\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 10, start = 5\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= start &lt;= 1000</code></li>\n\t<li><code>n == nums.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1487.保证文件名唯一",
        "hardRate": "MEDIUM",
        "passRate": "41.53%",
        "problemsUrl": "https://leetcode.cn/problems/making-file-names-unique/",
        "solutionsUrl": "https://leetcode.cn/problems/making-file-names-unique/solution",
        "problemsDesc": "<p>给你一个长度为 <code>n</code> 的字符串数组 <code>names</code> 。你将会在文件系统中创建 <code>n</code> 个文件夹：在第 <code>i</code> 分钟，新建名为 <code>names[i]</code> 的文件夹。</p>\n\n<p>由于两个文件 <strong>不能</strong> 共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，系统会以 <code>(k)</code> 的形式为新文件夹的文件名添加后缀，其中 <code>k</code> 是能保证文件名唯一的 <strong>最小正整数</strong> 。</p>\n\n<p>返回长度为<em> <code>n</code></em> 的字符串数组，其中 <code>ans[i]</code> 是创建第 <code>i</code> 个文件夹时系统分配给该文件夹的实际名称。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>names = [&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;]\n<strong>输出：</strong>[&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;]\n<strong>解释：</strong>文件系统将会这样创建文件名：\n&quot;pes&quot; --&gt; 之前未分配，仍为 &quot;pes&quot;\n&quot;fifa&quot; --&gt; 之前未分配，仍为 &quot;fifa&quot;\n&quot;gta&quot; --&gt; 之前未分配，仍为 &quot;gta&quot;\n&quot;pes(2019)&quot; --&gt; 之前未分配，仍为 &quot;pes(2019)&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>names = [&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta&quot;,&quot;avalon&quot;]\n<strong>输出：</strong>[&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta(2)&quot;,&quot;avalon&quot;]\n<strong>解释：</strong>文件系统将会这样创建文件名：\n&quot;gta&quot; --&gt; 之前未分配，仍为 &quot;gta&quot;\n&quot;gta(1)&quot; --&gt; 之前未分配，仍为 &quot;gta(1)&quot;\n&quot;gta&quot; --&gt; 文件名被占用，系统为该名称添加后缀 (k)，由于 &quot;gta(1)&quot; 也被占用，所以 k = 2 。实际创建的文件名为 &quot;gta(2)&quot; 。\n&quot;avalon&quot; --&gt; 之前未分配，仍为 &quot;avalon&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>names = [&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece&quot;]\n<strong>输出：</strong>[&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece(4)&quot;]\n<strong>解释：</strong>当创建最后一个文件夹时，最小的正有效 k 为 4 ，文件名变为 &quot;onepiece(4)&quot;。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>names = [&quot;wano&quot;,&quot;wano&quot;,&quot;wano&quot;,&quot;wano&quot;]\n<strong>输出：</strong>[&quot;wano&quot;,&quot;wano(1)&quot;,&quot;wano(2)&quot;,&quot;wano(3)&quot;]\n<strong>解释：</strong>每次创建文件夹 &quot;wano&quot; 时，只需增加后缀中 k 的值即可。</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>names = [&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido&quot;,&quot;kaido(1)&quot;]\n<strong>输出：</strong>[&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido(2)&quot;,&quot;kaido(1)(1)&quot;]\n<strong>解释：</strong>注意，如果含后缀文件名被占用，那么系统也会按规则在名称后添加新的后缀 (k) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= names.length &lt;= 5 * 10^4</code></li>\n\t<li><code>1 &lt;= names[i].length &lt;= 20</code></li>\n\t<li><code>names[i]</code> 由小写英文字母、数字和/或圆括号组成。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1488.避免洪水泛滥",
        "hardRate": "MEDIUM",
        "passRate": "26.32%",
        "problemsUrl": "https://leetcode.cn/problems/avoid-flood-in-the-city/",
        "solutionsUrl": "https://leetcode.cn/problems/avoid-flood-in-the-city/solution",
        "problemsDesc": "<p>你的国家有无数个湖泊，所有湖泊一开始都是空的。当第 <code>n</code>&nbsp;个湖泊下雨前是空的，那么它就会装满水。如果第 <code>n</code>&nbsp;个湖泊下雨前是 <strong>满的&nbsp;</strong>，这个湖泊会发生 <strong>洪水</strong> 。你的目标是避免任意一个湖泊发生洪水。</p>\n\n<p>给你一个整数数组&nbsp;<code>rains</code>&nbsp;，其中：</p>\n\n<ul>\n\t<li><code>rains[i] &gt; 0</code>&nbsp;表示第 <code>i</code>&nbsp;天时，第 <code>rains[i]</code>&nbsp;个湖泊会下雨。</li>\n\t<li><code>rains[i] == 0</code>&nbsp;表示第 <code>i</code>&nbsp;天没有湖泊会下雨，你可以选择 <strong>一个</strong>&nbsp;湖泊并 <strong>抽干</strong>&nbsp;这个湖泊的水。</li>\n</ul>\n\n<p>请返回一个数组<em>&nbsp;</em><code>ans</code>&nbsp;，满足：</p>\n\n<ul>\n\t<li><code>ans.length == rains.length</code></li>\n\t<li>如果&nbsp;<code>rains[i] &gt; 0</code> ，那么<code>ans[i] == -1</code>&nbsp;。</li>\n\t<li>如果&nbsp;<code>rains[i] == 0</code>&nbsp;，<code>ans[i]</code>&nbsp;是你第&nbsp;<code>i</code>&nbsp;天选择抽干的湖泊。</li>\n</ul>\n\n<p>如果有多种可行解，请返回它们中的 <strong>任意一个</strong>&nbsp;。如果没办法阻止洪水，请返回一个 <strong>空的数组</strong>&nbsp;。</p>\n\n<p>请注意，如果你选择抽干一个装满水的湖泊，它会变成一个空的湖泊。但如果你选择抽干一个空的湖泊，那么将无事发生。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rains = [1,2,3,4]\n<strong>输出：</strong>[-1,-1,-1,-1]\n<strong>解释：</strong>第一天后，装满水的湖泊包括 [1]\n第二天后，装满水的湖泊包括 [1,2]\n第三天后，装满水的湖泊包括 [1,2,3]\n第四天后，装满水的湖泊包括 [1,2,3,4]\n没有哪一天你可以抽干任何湖泊的水，也没有湖泊会发生洪水。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rains = [1,2,0,0,2,1]\n<strong>输出：</strong>[-1,-1,2,1,-1,-1]\n<strong>解释：</strong>第一天后，装满水的湖泊包括 [1]\n第二天后，装满水的湖泊包括 [1,2]\n第三天后，我们抽干湖泊 2 。所以剩下装满水的湖泊包括 [1]\n第四天后，我们抽干湖泊 1 。所以暂时没有装满水的湖泊了。\n第五天后，装满水的湖泊包括 [2]。\n第六天后，装满水的湖泊包括 [1,2]。\n可以看出，这个方案下不会有洪水发生。同时， [-1,-1,1,2,-1,-1] 也是另一个可行的没有洪水的方案。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>rains = [1,2,0,1,2]\n<strong>输出：</strong>[]\n<strong>解释：</strong>第二天后，装满水的湖泊包括 [1,2]。我们可以在第三天抽干一个湖泊的水。\n但第三天后，湖泊 1 和 2 都会再次下雨，所以不管我们第三天抽干哪个湖泊的水，另一个湖泊都会发生洪水。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rains.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= rains[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1489.找到最小生成树里的关键边和伪关键边",
        "hardRate": "HARD",
        "passRate": "66.55%",
        "problemsUrl": "https://leetcode.cn/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/solution",
        "problemsDesc": "<p>给你一个 <code>n</code>&nbsp;个点的带权无向连通图，节点编号为 <code>0</code>&nbsp;到 <code>n-1</code>&nbsp;，同时还有一个数组 <code>edges</code>&nbsp;，其中 <code>edges[i] = [from</code><code><sub>i</sub>, to<sub>i</sub>, weight<sub>i</sub>]</code>&nbsp;表示在&nbsp;<code>from<sub>i</sub></code>&nbsp;和&nbsp;<code>to<sub>i</sub></code>&nbsp;节点之间有一条带权无向边。最小生成树&nbsp;(MST) 是给定图中边的一个子集，它连接了所有节点且没有环，而且这些边的权值和最小。</p>\n\n<p>请你找到给定图中最小生成树的所有关键边和伪关键边。如果从图中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。</p>\n\n<p>请注意，你可以分别以任意顺序返回关键边的下标和伪关键边的下标。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/21/ex1.png\" style=\"height: 262px; width: 259px;\"></p>\n\n<pre><strong>输入：</strong>n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\n<strong>输出：</strong>[[0,1],[2,3,4,5]]\n<strong>解释：</strong>上图描述了给定图。\n下图是所有的最小生成树。\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/21/msts.png\" style=\"height: 553px; width: 540px;\">\n注意到第 0 条边和第 1 条边出现在了所有最小生成树中，所以它们是关键边，我们将这两个下标作为输出的第一个列表。\n边 2，3，4 和 5 是所有 MST 的剩余边，所以它们是伪关键边。我们将它们作为输出的第二个列表。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/21/ex2.png\" style=\"height: 253px; width: 247px;\"></p>\n\n<pre><strong>输入：</strong>n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]\n<strong>输出：</strong>[[],[0,1,2,3]]\n<strong>解释：</strong>可以观察到 4 条边都有相同的权值，任选它们中的 3 条可以形成一棵 MST 。所以 4 条边都是伪关键边。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= min(200, n * (n - 1) / 2)</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub> &lt; to<sub>i</sub> &lt; n</code></li>\n\t<li><code>1 &lt;= weight<sub>i</sub>&nbsp;&lt;= 1000</code></li>\n\t<li>所有 <code>(from<sub>i</sub>, to<sub>i</sub>)</code>&nbsp;数对都是互不相同的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1490.克隆 N 叉树",
        "hardRate": "MEDIUM",
        "passRate": "83.52%",
        "problemsUrl": "https://leetcode.cn/problems/clone-n-ary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/clone-n-ary-tree/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1491.去掉最低工资和最高工资后的工资平均值",
        "hardRate": "EASY",
        "passRate": "62.69%",
        "problemsUrl": "https://leetcode.cn/problems/average-salary-excluding-the-minimum-and-maximum-salary/",
        "solutionsUrl": "https://leetcode.cn/problems/average-salary-excluding-the-minimum-and-maximum-salary/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>salary</code>&nbsp;，数组里每个数都是 <strong>唯一</strong>&nbsp;的，其中&nbsp;<code>salary[i]</code> 是第&nbsp;<code>i</code>&nbsp;个员工的工资。</p>\n\n<p>请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>salary = [4000,3000,1000,2000]\n<strong>输出：</strong>2500.00000\n<strong>解释：</strong>最低工资和最高工资分别是 1000 和 4000 。\n去掉最低工资和最高工资以后的平均工资是 (2000+3000)/2= 2500\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>salary = [1000,2000,3000]\n<strong>输出：</strong>2000.00000\n<strong>解释：</strong>最低工资和最高工资分别是 1000 和 3000 。\n去掉最低工资和最高工资以后的平均工资是 (2000)/1= 2000\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>salary = [6000,5000,4000,3000,2000,1000]\n<strong>输出：</strong>3500.00000\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>salary = [8000,9000,2000,3000,6000,1000]\n<strong>输出：</strong>4750.00000\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= salary.length &lt;= 100</code></li>\n\t<li><code>10^3&nbsp;&lt;= salary[i] &lt;= 10^6</code></li>\n\t<li><code>salary[i]</code>&nbsp;是唯一的。</li>\n\t<li>与真实值误差在&nbsp;<code>10^-5</code> 以内的结果都将视为正确答案。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1492.n 的第 k 个因子",
        "hardRate": "MEDIUM",
        "passRate": "60.79%",
        "problemsUrl": "https://leetcode.cn/problems/the-kth-factor-of-n/",
        "solutionsUrl": "https://leetcode.cn/problems/the-kth-factor-of-n/solution",
        "problemsDesc": "<p>给你两个正整数&nbsp;<code>n</code> 和&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>如果正整数 <code>i</code> 满足 <code>n % i == 0</code> ，那么我们就说正整数 <code>i</code> 是整数 <code>n</code>&nbsp;的因子。</p>\n\n<p>考虑整数 <code>n</code>&nbsp;的所有因子，将它们 <strong>升序排列</strong>&nbsp;。请你返回第 <code>k</code>&nbsp;个因子。如果 <code>n</code>&nbsp;的因子数少于 <code>k</code>&nbsp;，请你返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 12, k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>因子列表包括 [1, 2, 3, 4, 6, 12]，第 3 个因子是 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 7, k = 2\n<strong>输出：</strong>7\n<strong>解释：</strong>因子列表包括 [1, 7] ，第 2 个因子是 7 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, k = 4\n<strong>输出：</strong>-1\n<strong>解释：</strong>因子列表包括 [1, 2, 4] ，只有 3 个因子，所以我们应该返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<p>你可以设计时间复杂度小于 O(n) 的算法来解决此问题吗？</p>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1493.删掉一个元素以后全为 1 的最长子数组",
        "hardRate": "MEDIUM",
        "passRate": "59.56%",
        "problemsUrl": "https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/",
        "solutionsUrl": "https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/solution",
        "problemsDesc": "<p>给你一个二进制数组&nbsp;<code>nums</code>&nbsp;，你需要从中删掉一个元素。</p>\n\n<p>请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。</p>\n\n<p>如果不存在这样的子数组，请返回 0 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,0,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,1,1,0,1,1,0,1]\n<strong>输出：</strong>5\n<strong>解释：</strong>删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>你必须要删除一个元素。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code>&nbsp;要么是&nbsp;<code>0</code>&nbsp;要么是&nbsp;<code>1</code> 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1494.并行课程 II",
        "hardRate": "HARD",
        "passRate": "51.86%",
        "problemsUrl": "https://leetcode.cn/problems/parallel-courses-ii/",
        "solutionsUrl": "https://leetcode.cn/problems/parallel-courses-ii/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>&nbsp;表示某所大学里课程的数目，编号为&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;，数组&nbsp;<code>relations</code>&nbsp;中，&nbsp;<code>relations[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp; 表示一个先修课的关系，也就是课程&nbsp;<code>x<sub>i</sub></code>&nbsp;必须在课程&nbsp;<code>y<sub>i</sub></code><sub>&nbsp;</sub>之前上。同时你还有一个整数&nbsp;<code>k</code>&nbsp;。</p>\n\n<p>在一个学期中，你 <strong>最多</strong>&nbsp;可以同时上 <code>k</code>&nbsp;门课，前提是这些课的先修课在之前的学期里已经上过了。</p>\n\n<p>请你返回上完所有课最少需要多少个学期。题目保证一定存在一种上完所有课的方式。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/27/leetcode_parallel_courses_1.png\" style=\"height: 164px; width: 300px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, relations = [[2,1],[3,1],[1,4]], k = 2\n<strong>输出：</strong>3 \n<strong>解释：</strong>上图展示了题目输入的图。在第一个学期中，我们可以上课程 2 和课程 3 。然后第二个学期上课程 1 ，第三个学期上课程 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/27/leetcode_parallel_courses_2.png\" style=\"height: 234px; width: 300px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2\n<strong>输出：</strong>4 \n<strong>解释：</strong>上图展示了题目输入的图。一个最优方案是：第一学期上课程 2 和 3，第二学期上课程 4 ，第三学期上课程 1 ，第四学期上课程 5 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 11, relations = [], k = 2\n<strong>输出：</strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 15</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n\t<li><code>0 &lt;=&nbsp;relations.length &lt;= n * (n-1) / 2</code></li>\n\t<li><code>relations[i].length == 2</code></li>\n\t<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= n</code></li>\n\t<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>\n\t<li>所有先修关系都是不同的，也就是说&nbsp;<code>relations[i] != relations[j]</code>&nbsp;。</li>\n\t<li>题目输入的图是个有向无环图。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1495.上月播放的儿童适宜电影",
        "hardRate": "EASY",
        "passRate": "53.56%",
        "problemsUrl": "https://leetcode.cn/problems/friendly-movies-streamed-last-month/",
        "solutionsUrl": "https://leetcode.cn/problems/friendly-movies-streamed-last-month/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1496.判断路径是否相交",
        "hardRate": "EASY",
        "passRate": "53.52%",
        "problemsUrl": "https://leetcode.cn/problems/path-crossing/",
        "solutionsUrl": "https://leetcode.cn/problems/path-crossing/solution",
        "problemsDesc": "<p>给你一个字符串 <code>path</code>，其中 <code>path[i]</code> 的值可以是 <code>'N'</code>、<code>'S'</code>、<code>'E'</code> 或者 <code>'W'</code>，分别表示向北、向南、向东、向西移动一个单位。</p>\n\n<p>你从二维平面上的原点 <code>(0, 0)</code> 处开始出发，按 <code>path</code> 所指示的路径行走。</p>\n\n<p>如果路径在任何位置上与自身相交，也就是走到之前已经走过的位置，请返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/28/screen-shot-2020-06-10-at-123929-pm.png\" style=\"height: 358px; width: 400px;\" /></p>\n\n<pre>\n<strong>输入：</strong>path = \"NES\"\n<strong>输出：</strong>false \n<strong>解释：</strong>该路径没有在任何位置相交。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/28/screen-shot-2020-06-10-at-123843-pm.png\" style=\"height: 339px; width: 400px;\" /></p>\n\n<pre>\n<strong>输入：</strong>path = \"NESWW\"\n<strong>输出：</strong>true\n<strong>解释：</strong>该路径经过原点两次。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= path.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>path[i]</code> 为 <code>'N'</code>、<code>'S'</code>、<code>'E'</code> 或 <code>'W'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1497.检查数组对是否可以被 k 整除",
        "hardRate": "MEDIUM",
        "passRate": "40.15%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-array-pairs-are-divisible-by-k/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-array-pairs-are-divisible-by-k/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>arr</code> 和一个整数 <code>k</code> ，其中数组长度是偶数，值为 <code>n</code> 。</p>\n\n<p>现在需要把数组恰好分成 <code>n /&nbsp;2</code> 对，以使每对数字的和都能够被 <code>k</code> 整除。</p>\n\n<p>如果存在这样的分法，请返回 <em>True</em> ；否则，返回 <em>False</em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n<strong>输出：</strong>true\n<strong>解释：</strong>划分后的数字对为 (1,9),(2,8),(3,7),(4,6) 以及 (5,10) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,4,5,6], k = 7\n<strong>输出：</strong>true\n<strong>解释：</strong>划分后的数字对为 (1,6),(2,5) 以及 (3,4) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,4,5,6], k = 10\n<strong>输出：</strong>false\n<strong>解释：</strong>无法在将数组中的数字分为三对的同时满足每对数字和能够被 10 整除的条件。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>arr.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>n</code> 为偶数<meta charset=\"UTF-8\" /></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1498.满足条件的子序列数目",
        "hardRate": "MEDIUM",
        "passRate": "38.22%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/solution",
        "problemsDesc": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>\n\n<p>请你统计并返回 <code>nums</code> 中能满足其最小元素与最大元素的 <strong>和</strong> 小于或等于 <code>target</code> 的 <strong>非空</strong> 子序列的数目。</p>\n\n<p>由于答案可能很大，请将结果对<meta charset=\"UTF-8\" />&nbsp;<code>10<sup>9</sup>&nbsp;+ 7</code>&nbsp;取余后返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,5,6,7], target = 9\n<strong>输出：</strong>4\n<strong>解释：</strong>有 4 个子序列满足该条件。\n[3] -&gt; 最小元素 + 最大元素 &lt;= target (3 + 3 &lt;= 9)\n[3,5] -&gt; (3 + 5 &lt;= 9)\n[3,5,6] -&gt; (3 + 6 &lt;= 9)\n[3,6] -&gt; (3 + 6 &lt;= 9)\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,3,6,8], target = 10\n<strong>输出：</strong>6\n<strong>解释：</strong>有 6 个子序列满足该条件。（nums 中可以有重复数字）\n[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,3,4,6,7], target = 12\n<strong>输出：</strong>61\n<strong>解释：</strong>共有 63 个非空子序列，其中 2 个不满足条件（[6,7], [7]）\n有效序列总数为（63 - 2 = 61）\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= target &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1499.满足不等式的最大值",
        "hardRate": "HARD",
        "passRate": "40.97%",
        "problemsUrl": "https://leetcode.cn/problems/max-value-of-equation/",
        "solutionsUrl": "https://leetcode.cn/problems/max-value-of-equation/solution",
        "problemsDesc": "<p>给你一个数组 <code>points</code> 和一个整数 <code>k</code> 。数组中每个元素都表示二维平面上的点的坐标，并按照横坐标 x 的值从小到大排序。也就是说 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> ，并且在 <code>1 &lt;= i &lt; j &lt;= points.length</code> 的前提下， <code>x<sub>i</sub> &lt; x<sub>j</sub></code> 总成立。</p>\n\n<p>请你找出<em> </em><code>y<sub>i</sub>&nbsp;+ y<sub>j</sub>&nbsp;+ |x<sub>i</sub>&nbsp;- x<sub>j</sub>|</code> 的 <strong>最大值</strong>，其中 <code>|x<sub>i</sub>&nbsp;- x<sub>j</sub>|&nbsp;&lt;= k</code> 且 <code>1 &lt;= i &lt; j &lt;= points.length</code>。</p>\n\n<p>题目测试数据保证至少存在一对能够满足 <code>|x<sub>i</sub>&nbsp;- x<sub>j</sub>|&nbsp;&lt;= k</code> 的点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>points = [[1,3],[2,0],[5,10],[6,-10]], k = 1\n<strong>输出：</strong>4\n<strong>解释：</strong>前两个点满足 |x<sub>i</sub>&nbsp;- x<sub>j</sub>| &lt;= 1 ，代入方程计算，则得到值 3 + 0 + |1 - 2| = 4 。第三个和第四个点也满足条件，得到值 10 + -10 + |5 - 6| = 1 。\n没有其他满足条件的点，所以返回 4 和 1 中最大的那个。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>points = [[0,0],[3,0],[9,2]], k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>只有前两个点满足 |x<sub>i</sub>&nbsp;- x<sub>j</sub>| &lt;= 3 ，代入方程后得到值 0 + 0 + |0 - 3| = 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= points.length &lt;= 10^5</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>-10^8&nbsp;&lt;= points[i][0], points[i][1] &lt;= 10^8</code></li>\n\t<li><code>0 &lt;= k &lt;= 2 * 10^8</code></li>\n\t<li>对于所有的<code>1 &lt;= i &lt; j &lt;= points.length</code> ，<code>points[i][0] &lt; points[j][0]</code> 都成立。也就是说，<code>x<sub>i</sub></code> 是严格递增的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1500.设计文件分享系统",
        "hardRate": "MEDIUM",
        "passRate": "29.76%",
        "problemsUrl": "https://leetcode.cn/problems/design-a-file-sharing-system/",
        "solutionsUrl": "https://leetcode.cn/problems/design-a-file-sharing-system/solution",
        "problemsDesc": null,
        "isPlus": true
    }
]