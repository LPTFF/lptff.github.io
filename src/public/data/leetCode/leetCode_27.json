[
    {
        "problemsName": " 1301.最大得分的路径数目",
        "hardRate": "HARD",
        "passRate": "37.67%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-paths-with-max-score/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-paths-with-max-score/solution",
        "problemsDesc": "<p>给你一个正方形字符数组&nbsp;<code>board</code>&nbsp;，你从数组最右下方的字符&nbsp;<code>&#39;S&#39;</code>&nbsp;出发。</p>\n\n<p>你的目标是到达数组最左上角的字符&nbsp;<code>&#39;E&#39;</code> ，数组剩余的部分为数字字符&nbsp;<code>1, 2, ..., 9</code>&nbsp;或者障碍 <code>&#39;X&#39;</code>。在每一步移动中，你可以向上、向左或者左上方移动，可以移动的前提是到达的格子没有障碍。</p>\n\n<p>一条路径的 「得分」 定义为：路径上所有数字的和。</p>\n\n<p>请你返回一个列表，包含两个整数：第一个整数是 「得分」 的最大值，第二个整数是得到最大得分的方案数，请把结果对&nbsp;<strong><code>10^9 + 7</code></strong> <strong>取余</strong>。</p>\n\n<p>如果没有任何路径可以到达终点，请返回&nbsp;<code>[0, 0]</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = [&quot;E23&quot;,&quot;2X2&quot;,&quot;12S&quot;]\n<strong>输出：</strong>[7,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = [&quot;E12&quot;,&quot;1X1&quot;,&quot;21S&quot;]\n<strong>输出：</strong>[4,2]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = [&quot;E11&quot;,&quot;XXX&quot;,&quot;11S&quot;]\n<strong>输出：</strong>[0,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= board.length == board[i].length &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1302.层数最深叶子节点的和",
        "hardRate": "MEDIUM",
        "passRate": "85.51%",
        "problemsUrl": "https://leetcode.cn/problems/deepest-leaves-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/deepest-leaves-sum/solution",
        "problemsDesc": "<p>给你一棵二叉树的根节点 <code>root</code> ，请你返回 <strong>层数最深的叶子节点的和</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/28/1483_ex1.png\" style=\"height: 265px; width: 273px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,5,null,6,7,null,null,null,null,8]\n<strong>输出：</strong>15\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]\n<strong>输出：</strong>19\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[1, 10<sup>4</sup>]</code> 之间。</li>\n\t<li><code>1 <= Node.val <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1303.求团队人数",
        "hardRate": "EASY",
        "passRate": "82.56%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-team-size/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-team-size/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1304.和为零的 N 个不同整数",
        "hardRate": "EASY",
        "passRate": "70.32%",
        "problemsUrl": "https://leetcode.cn/problems/find-n-unique-integers-sum-up-to-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/find-n-unique-integers-sum-up-to-zero/solution",
        "problemsDesc": "<p>给你一个整数&nbsp;<code>n</code>，请你返回 <strong>任意&nbsp;</strong>一个由 <code>n</code>&nbsp;个 <strong>各不相同&nbsp;</strong>的整数组成的数组，并且这 <code>n</code> 个数相加和为 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 5\n<strong>输出：</strong>[-7,-1,1,3,4]\n<strong>解释：</strong>这些数组也是正确的 [-5,-1,1,2,3]，[-3,-1,2,-2,4]。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 3\n<strong>输出：</strong>[-1,0,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 1\n<strong>输出：</strong>[0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1305.两棵二叉搜索树中的所有元素",
        "hardRate": "MEDIUM",
        "passRate": "78.06%",
        "problemsUrl": "https://leetcode.cn/problems/all-elements-in-two-binary-search-trees/",
        "solutionsUrl": "https://leetcode.cn/problems/all-elements-in-two-binary-search-trees/solution",
        "problemsDesc": "<p>给你&nbsp;<code>root1</code> 和 <code>root2</code>&nbsp;这两棵二叉搜索树。请你返回一个列表，其中包含&nbsp;<strong>两棵树&nbsp;</strong>中的所有整数并按 <strong>升序</strong> 排序。.</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/29/q2-e1.png\" /></p>\n\n<pre>\n<strong>输入：</strong>root1 = [2,1,4], root2 = [1,0,3]\n<strong>输出：</strong>[0,1,1,2,3,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/29/q2-e5-.png\" /></p>\n\n<pre>\n<strong>输入：</strong>root1 = [1,null,8], root2 = [8,1]\n<strong>输出：</strong>[1,1,8,8]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每棵树的节点数在&nbsp;<code>[0, 5000]</code> 范围内</li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1306.跳跃游戏 III",
        "hardRate": "MEDIUM",
        "passRate": "58.15%",
        "problemsUrl": "https://leetcode.cn/problems/jump-game-iii/",
        "solutionsUrl": "https://leetcode.cn/problems/jump-game-iii/solution",
        "problemsDesc": "<p>这里有一个非负整数数组&nbsp;<code>arr</code>，你最开始位于该数组的起始下标&nbsp;<code>start</code>&nbsp;处。当你位于下标&nbsp;<code>i</code>&nbsp;处时，你可以跳到&nbsp;<code>i + arr[i]</code> 或者 <code>i - arr[i]</code>。</p>\n\n<p>请你判断自己是否能够跳到对应元素值为 0 的 <strong>任一</strong> 下标处。</p>\n\n<p>注意，不管是什么情况下，你都无法跳到数组之外。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [4,2,3,0,3,1,2], start = 5\n<strong>输出：</strong>true\n<strong>解释：</strong>\n到达值为 0 的下标 3 有以下可能方案： \n下标 5 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3 \n下标 5 -&gt; 下标 6 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [4,2,3,0,3,1,2], start = 0\n<strong>输出：</strong>true \n<strong>解释：\n</strong>到达值为 0 的下标 3 有以下可能方案： \n下标 0 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,0,2,1,2], start = 2\n<strong>输出：</strong>false\n<strong>解释：</strong>无法到达值为 0 的下标 1 处。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 5 * 10^4</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;&nbsp;arr.length</code></li>\n\t<li><code>0 &lt;= start &lt; arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1307.口算难题",
        "hardRate": "HARD",
        "passRate": "34.95%",
        "problemsUrl": "https://leetcode.cn/problems/verbal-arithmetic-puzzle/",
        "solutionsUrl": "https://leetcode.cn/problems/verbal-arithmetic-puzzle/solution",
        "problemsDesc": "<p>给你一个方程，左边用&nbsp;<code>words</code>&nbsp;表示，右边用&nbsp;<code>result</code> 表示。</p>\n\n<p>你需要根据以下规则检查方程是否可解：</p>\n\n<ul>\n\t<li>每个字符都会被解码成一位数字（0 - 9）。</li>\n\t<li>每对不同的字符必须映射到不同的数字。</li>\n\t<li>每个 <code>words[i]</code> 和 <code>result</code>&nbsp;都会被解码成一个没有前导零的数字。</li>\n\t<li>左侧数字之和（<code>words</code>）等于右侧数字（<code>result</code>）。&nbsp;</li>\n</ul>\n\n<p>如果方程可解，返回&nbsp;<code>True</code>，否则返回&nbsp;<code>False</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;SEND&quot;,&quot;MORE&quot;], result = &quot;MONEY&quot;\n<strong>输出：</strong>true\n<strong>解释：</strong>映射 &#39;S&#39;-&gt; 9, &#39;E&#39;-&gt;5, &#39;N&#39;-&gt;6, &#39;D&#39;-&gt;7, &#39;M&#39;-&gt;1, &#39;O&#39;-&gt;0, &#39;R&#39;-&gt;8, &#39;Y&#39;-&gt;&#39;2&#39;\n所以 &quot;SEND&quot; + &quot;MORE&quot; = &quot;MONEY&quot; ,  9567 + 1085 = 10652</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;SIX&quot;,&quot;SEVEN&quot;,&quot;SEVEN&quot;], result = &quot;TWENTY&quot;\n<strong>输出：</strong>true\n<strong>解释：</strong>映射 &#39;S&#39;-&gt; 6, &#39;I&#39;-&gt;5, &#39;X&#39;-&gt;0, &#39;E&#39;-&gt;8, &#39;V&#39;-&gt;7, &#39;N&#39;-&gt;2, &#39;T&#39;-&gt;1, &#39;W&#39;-&gt;&#39;3&#39;, &#39;Y&#39;-&gt;4\n所以 &quot;SIX&quot; + &quot;SEVEN&quot; + &quot;SEVEN&quot; = &quot;TWENTY&quot; ,  650 + 68782 + 68782 = 138214</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;THIS&quot;,&quot;IS&quot;,&quot;TOO&quot;], result = &quot;FUNNY&quot;\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>words = [&quot;LEET&quot;,&quot;CODE&quot;], result = &quot;POINT&quot;\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= words.length &lt;= 5</code></li>\n\t<li><code>1 &lt;= words[i].length,&nbsp;results.length&nbsp;&lt;= 7</code></li>\n\t<li><code>words[i], result</code>&nbsp;只含有大写英文字母</li>\n\t<li>表达式中使用的不同字符数最大为&nbsp;10</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1308.不同性别每日分数总计",
        "hardRate": "MEDIUM",
        "passRate": "73.56%",
        "problemsUrl": "https://leetcode.cn/problems/running-total-for-different-genders/",
        "solutionsUrl": "https://leetcode.cn/problems/running-total-for-different-genders/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1309.解码字母到整数映射",
        "hardRate": "EASY",
        "passRate": "76.79%",
        "problemsUrl": "https://leetcode.cn/problems/decrypt-string-from-alphabet-to-integer-mapping/",
        "solutionsUrl": "https://leetcode.cn/problems/decrypt-string-from-alphabet-to-integer-mapping/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>，它由数字（<code>'0'</code> - <code>'9'</code>）和&nbsp;<code>'#'</code>&nbsp;组成。我们希望按下述规则将&nbsp;<code>s</code>&nbsp;映射为一些小写英文字符：</p>\n\n<ul>\n\t<li>字符（<code>'a'</code> - <code>'i'</code>）分别用（<code>'1'</code> -&nbsp;<code>'9'</code>）表示。</li>\n\t<li>字符（<code>'j'</code> - <code>'z'</code>）分别用（<code>'10#'</code>&nbsp;-&nbsp;<code>'26#'</code>）表示。&nbsp;</li>\n</ul>\n\n<p>返回映射之后形成的新字符串。</p>\n\n<p>题目数据保证映射始终唯一。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"10#11#12\"\n<strong>输出：</strong>\"jkab\"\n<strong>解释：</strong>\"j\" -&gt; \"10#\" , \"k\" -&gt; \"11#\" , \"a\" -&gt; \"1\" , \"b\" -&gt; \"2\".\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1326#\"\n<strong>输出：</strong>\"acz\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i]</code> 只包含数字（<code>'0'</code>-<code>'9'</code>）和&nbsp;<code>'#'</code>&nbsp;字符。</li>\n\t<li><code>s</code>&nbsp;是映射始终存在的有效字符串。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1310.子数组异或查询",
        "hardRate": "MEDIUM",
        "passRate": "72.04%",
        "problemsUrl": "https://leetcode.cn/problems/xor-queries-of-a-subarray/",
        "solutionsUrl": "https://leetcode.cn/problems/xor-queries-of-a-subarray/solution",
        "problemsDesc": "<p>有一个正整数数组 <code>arr</code>，现给你一个对应的查询数组 <code>queries</code>，其中 <code>queries[i] = [L<sub>i, </sub>R<sub>i</sub>]</code>。</p>\n\n<p>对于每个查询 <code>i</code>，请你计算从 <code>L<sub>i</sub></code> 到 <code>R<sub>i</sub></code> 的 <strong>XOR</strong> 值（即 <code>arr[L<sub>i</sub>] <strong>xor</strong> arr[L<sub>i</sub>+1] <strong>xor</strong> ... <strong>xor</strong> arr[R<sub>i</sub>]</code>）作为本次查询的结果。</p>\n\n<p>并返回一个包含给定查询 <code>queries</code> 所有结果的数组。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]\n<strong>输出：</strong>[2,7,14,8] \n<strong>解释：</strong>\n数组中元素的二进制表示形式是：\n1 = 0001 \n3 = 0011 \n4 = 0100 \n8 = 1000 \n查询的 XOR 值为：\n[0,1] = 1 xor 3 = 2 \n[1,2] = 3 xor 4 = 7 \n[0,3] = 1 xor 3 xor 4 xor 8 = 14 \n[3,3] = 8\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]\n<strong>输出：</strong>[8,0,4,4]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= arr.length <= 3 * 10^4</code></li>\n\t<li><code>1 <= arr[i] <= 10^9</code></li>\n\t<li><code>1 <= queries.length <= 3 * 10^4</code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>0 <= queries[i][0] <= queries[i][1] < arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1311.获取你好友已观看的视频",
        "hardRate": "MEDIUM",
        "passRate": "40.09%",
        "problemsUrl": "https://leetcode.cn/problems/get-watched-videos-by-your-friends/",
        "solutionsUrl": "https://leetcode.cn/problems/get-watched-videos-by-your-friends/solution",
        "problemsDesc": "<p>有&nbsp;<code>n</code> 个人，每个人都有一个&nbsp; <code>0</code>&nbsp;到&nbsp;<code>n-1</code>&nbsp;的唯一&nbsp;<em>id</em>&nbsp;。</p>\n\n<p>给你数组 <code>watchedVideos</code>&nbsp; 和&nbsp;<code>friends</code>&nbsp;，其中&nbsp;<code>watchedVideos[i]</code>&nbsp; 和&nbsp;<code>friends[i]</code>&nbsp;分别表示&nbsp;<code>id = i</code>&nbsp;的人观看过的视频列表和他的好友列表。</p>\n\n<p>Level&nbsp;<strong>1</strong>&nbsp;的视频包含所有你好友观看过的视频，level&nbsp;<strong>2</strong>&nbsp;的视频包含所有你好友的好友观看过的视频，以此类推。一般的，Level 为 <strong>k</strong>&nbsp;的视频包含所有从你出发，最短距离为&nbsp;<strong>k</strong>&nbsp;的好友观看过的视频。</p>\n\n<p>给定你的&nbsp;<code>id</code>&nbsp; 和一个&nbsp;<code>level</code>&nbsp;值，请你找出所有指定 <code>level</code> 的视频，并将它们按观看频率升序返回。如果有频率相同的视频，请将它们按字母顺序从小到大排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/03/leetcode_friends_1.png\" style=\"height: 179px; width: 129px;\"></strong></p>\n\n<pre><strong>输入：</strong>watchedVideos = [[&quot;A&quot;,&quot;B&quot;],[&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1\n<strong>输出：</strong>[&quot;B&quot;,&quot;C&quot;] \n<strong>解释：</strong>\n你的 id 为 0（绿色），你的朋友包括（黄色）：\nid 为 1 -&gt; watchedVideos = [&quot;C&quot;]&nbsp;\nid 为 2 -&gt; watchedVideos = [&quot;B&quot;,&quot;C&quot;]&nbsp;\n你朋友观看过视频的频率为：\nB -&gt; 1&nbsp;\nC -&gt; 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/03/leetcode_friends_2.png\" style=\"height: 179px; width: 129px;\"></strong></p>\n\n<pre><strong>输入：</strong>watchedVideos = [[&quot;A&quot;,&quot;B&quot;],[&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2\n<strong>输出：</strong>[&quot;D&quot;]\n<strong>解释：</strong>\n你的 id 为 0（绿色），你朋友的朋友只有一个人，他的 id 为 3（黄色）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == watchedVideos.length ==&nbsp;friends.length</code></li>\n\t<li><code>2 &lt;= n&nbsp;&lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;watchedVideos[i].length &lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;watchedVideos[i][j].length &lt;= 8</code></li>\n\t<li><code>0 &lt;= friends[i].length &lt; n</code></li>\n\t<li><code>0 &lt;= friends[i][j]&nbsp;&lt; n</code></li>\n\t<li><code>0 &lt;= id &lt; n</code></li>\n\t<li><code>1 &lt;= level &lt; n</code></li>\n\t<li>如果&nbsp;<code>friends[i]</code> 包含&nbsp;<code>j</code>&nbsp;，那么&nbsp;<code>friends[j]</code> 包含&nbsp;<code>i</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1312.让字符串成为回文串的最少插入次数",
        "hardRate": "HARD",
        "passRate": "69.11%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;，每一次操作你都可以在字符串的任意位置插入任意字符。</p>\n\n<p>请你返回让&nbsp;<code>s</code>&nbsp;成为回文串的&nbsp;<strong>最少操作次数</strong>&nbsp;。</p>\n\n<p>「回文串」是正读和反读都相同的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"zzazz\"\n<strong>输出：</strong>0\n<strong>解释：</strong>字符串 \"zzazz\" 已经是回文串了，所以不需要做任何插入操作。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"mbadm\"\n<strong>输出：</strong>2\n<strong>解释：</strong>字符串可变为 \"mbdadbm\" 或者 \"mdbabdm\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"leetcode\"\n<strong>输出：</strong>5\n<strong>解释：</strong>插入 5 个字符后字符串变为 \"leetcodocteel\" 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>s</code>&nbsp;中所有字符都是小写字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1313.解压缩编码列表",
        "hardRate": "EASY",
        "passRate": "83.23%",
        "problemsUrl": "https://leetcode.cn/problems/decompress-run-length-encoded-list/",
        "solutionsUrl": "https://leetcode.cn/problems/decompress-run-length-encoded-list/solution",
        "problemsDesc": "<p>给你一个以行程长度编码压缩的整数列表 <code>nums</code> 。</p>\n\n<p>考虑每对相邻的两个元素 <code>[freq, val] = [nums[2*i], nums[2*i+1]]</code> （其中 <code>i >= 0</code> ），每一对都表示解压后子列表中有 <code>freq</code> 个值为 <code>val</code> 的元素，你需要从左到右连接所有子列表以生成解压后的列表。</p>\n\n<p>请你返回解压后的列表。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>[2,4,4,4]\n<strong>解释：</strong>第一对 [1,2] 代表着 2 的出现频次为 1，所以生成数组 [2]。\n第二对 [3,4] 代表着 4 的出现频次为 3，所以生成数组 [4,4,4]。\n最后将它们串联到一起 [2] + [4,4,4] = [2,4,4,4]。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,2,3]\n<strong>输出：</strong>[1,3,3]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= nums.length <= 100</code></li>\n\t<li><code>nums.length % 2 == 0</code></li>\n\t<li><code>1 <= nums[i] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1314.矩阵区域和",
        "hardRate": "MEDIUM",
        "passRate": "75.48%",
        "problemsUrl": "https://leetcode.cn/problems/matrix-block-sum/",
        "solutionsUrl": "https://leetcode.cn/problems/matrix-block-sum/solution",
        "problemsDesc": "<p>给你一个 <code>m x n</code> 的矩阵 <code>mat</code> 和一个整数 <code>k</code> ，请你返回一个矩阵 <code>answer</code> ，其中每个 <code>answer[i][j]</code> 是所有满足下述条件的元素 <code>mat[r][c]</code> 的和： </p>\n\n<ul>\n\t<li><code>i - k <= r <= i + k, </code></li>\n\t<li><code>j - k <= c <= j + k</code> 且</li>\n\t<li><code>(r, c)</code> 在矩阵内。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1\n<strong>输出：</strong>[[12,21,16],[27,45,33],[24,39,28]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2\n<strong>输出：</strong>[[45,45,45],[45,45,45],[45,45,45]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 <= m, n, k <= 100</code></li>\n\t<li><code>1 <= mat[i][j] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1315.祖父节点值为偶数的节点和",
        "hardRate": "MEDIUM",
        "passRate": "81.62%",
        "problemsUrl": "https://leetcode.cn/problems/sum-of-nodes-with-even-valued-grandparent/",
        "solutionsUrl": "https://leetcode.cn/problems/sum-of-nodes-with-even-valued-grandparent/solution",
        "problemsDesc": "<p>给你一棵二叉树，请你返回满足以下条件的所有节点的值之和：</p>\n\n<ul>\n\t<li>该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）</li>\n</ul>\n\n<p>如果不存在祖父节点值为偶数的节点，那么返回&nbsp;<code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/10/1473_ex1.png\" style=\"height: 214px; width: 350px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]\n<strong>输出：</strong>18\n<strong>解释：</strong>图中红色节点的祖父节点的值为偶数，蓝色节点为这些红色节点的祖父节点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在&nbsp;<code>1</code> 到&nbsp;<code>10^4</code>&nbsp;之间。</li>\n\t<li>每个节点的值在&nbsp;<code>1</code> 到&nbsp;<code>100</code> 之间。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1316.不同的循环子字符串",
        "hardRate": "HARD",
        "passRate": "48.52%",
        "problemsUrl": "https://leetcode.cn/problems/distinct-echo-substrings/",
        "solutionsUrl": "https://leetcode.cn/problems/distinct-echo-substrings/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>text</code> ，请你返回满足下述条件的&nbsp;<strong>不同</strong> 非空子字符串的数目：</p>\n\n<ul>\n\t<li>可以写成某个字符串与其自身相连接的形式（即，可以写为 <code>a&nbsp;+ a</code>，其中 <code>a</code> 是某个字符串）。</li>\n</ul>\n\n<p>例如，<code>abcabc</code>&nbsp;就是&nbsp;<code>abc</code>&nbsp;和它自身连接形成的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;abcabcabc&quot;\n<strong>输出：</strong>3\n<strong>解释：</strong>3 个子字符串分别为 &quot;abcabc&quot;，&quot;bcabca&quot; 和 &quot;cabcab&quot; 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>text = &quot;leetcodeleetcode&quot;\n<strong>输出：</strong>2\n<strong>解释：</strong>2 个子字符串为 &quot;ee&quot; 和 &quot;leetcodeleetcode&quot; 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length &lt;= 2000</code></li>\n\t<li><code>text</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1317.将整数转换为两个无零整数的和",
        "hardRate": "EASY",
        "passRate": "61.86%",
        "problemsUrl": "https://leetcode.cn/problems/convert-integer-to-the-sum-of-two-no-zero-integers/",
        "solutionsUrl": "https://leetcode.cn/problems/convert-integer-to-the-sum-of-two-no-zero-integers/solution",
        "problemsDesc": "<p>「无零整数」是十进制表示中 <strong>不含任何 0</strong>&nbsp;的正整数。</p>\n\n<p>给你一个整数&nbsp;<code>n</code>，请你返回一个 <strong>由两个整数组成的列表</strong> <code>[A, B]</code>，满足：</p>\n\n<ul>\n\t<li><code>A</code> 和 <code>B</code>&nbsp;都是无零整数</li>\n\t<li><code>A + B = n</code></li>\n</ul>\n\n<p>题目数据保证至少有一个有效的解决方案。</p>\n\n<p>如果存在多个有效解决方案，你可以返回其中任意一个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>n = 2\n<strong>输出：</strong>[1,1]\n<strong>解释：</strong>A = 1, B = 1. A + B = n 并且 A 和 B 的十进制表示形式都不包含任何 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>n = 11\n<strong>输出：</strong>[2,9]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 10000\n<strong>输出：</strong>[1,9999]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 69\n<strong>输出：</strong>[1,68]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>n = 1010\n<strong>输出：</strong>[11,999]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10^4</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1318.或运算的最小翻转次数",
        "hardRate": "MEDIUM",
        "passRate": "66.81%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-flips-to-make-a-or-b-equal-to-c/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-flips-to-make-a-or-b-equal-to-c/solution",
        "problemsDesc": "<p>给你三个正整数&nbsp;<code>a</code>、<code>b</code> 和 <code>c</code>。</p>\n\n<p>你可以对 <code>a</code> 和 <code>b</code>&nbsp;的二进制表示进行位翻转操作，返回能够使按位或运算&nbsp; &nbsp;<code>a</code> OR <code>b</code> == <code>c</code>&nbsp;&nbsp;成立的最小翻转次数。</p>\n\n<p>「位翻转操作」是指将一个数的二进制表示任何单个位上的 1 变成 0 或者 0 变成 1 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_3_1676.png\" style=\"height: 87px; width: 260px;\"></p>\n\n<pre><strong>输入：</strong>a = 2, b = 6, c = 5\n<strong>输出：</strong>3\n<strong>解释：</strong>翻转后 a = 1 , b = 4 , c = 5 使得 <code>a</code> OR <code>b</code> == <code>c</code></pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>a = 4, b = 2, c = 7\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>a = 1, b = 2, c = 3\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a &lt;= 10^9</code></li>\n\t<li><code>1 &lt;= b&nbsp;&lt;= 10^9</code></li>\n\t<li><code>1 &lt;= c&nbsp;&lt;= 10^9</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1319.连通网络的操作次数",
        "hardRate": "MEDIUM",
        "passRate": "62.35%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-operations-to-make-network-connected/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-operations-to-make-network-connected/solution",
        "problemsDesc": "<p>用以太网线缆将&nbsp;<code>n</code>&nbsp;台计算机连接成一个网络，计算机的编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n-1</code>。线缆用&nbsp;<code>connections</code>&nbsp;表示，其中&nbsp;<code>connections[i] = [a, b]</code>&nbsp;连接了计算机&nbsp;<code>a</code>&nbsp;和&nbsp;<code>b</code>。</p>\n\n<p>网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。</p>\n\n<p>给你这个计算机网络的初始布线&nbsp;<code>connections</code>，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回&nbsp;-1 。&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_1_1677.png\" style=\"height: 167px; width: 570px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 4, connections = [[0,1],[0,2],[1,2]]\n<strong>输出：</strong>1\n<strong>解释：</strong>拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_2_1677.png\" style=\"height: 175px; width: 660px;\"></strong></p>\n\n<pre><strong>输入：</strong>n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>线缆数量不足。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>n = 5, connections = [[0,1],[0,2],[3,4],[2,3]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= connections.length &lt;= min(n*(n-1)/2, 10^5)</code></li>\n\t<li><code>connections[i].length == 2</code></li>\n\t<li><code>0 &lt;= connections[i][0], connections[i][1]&nbsp;&lt; n</code></li>\n\t<li><code>connections[i][0] != connections[i][1]</code></li>\n\t<li>没有重复的连接。</li>\n\t<li>两台计算机不会通过多条线缆连接。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1320.二指输入的的最小距离",
        "hardRate": "HARD",
        "passRate": "60.75%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-distance-to-type-a-word-using-two-fingers/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-distance-to-type-a-word-using-two-fingers/solution",
        "problemsDesc": "<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/leetcode_keyboard.png\" /></p>\n\n<p>二指输入法定制键盘在 <strong>X-Y</strong> 平面上的布局如上图所示，其中每个大写英文字母都位于某个坐标处。</p>\n\n<ul>\n\t<li>例如字母&nbsp;<strong>A</strong>&nbsp;位于坐标&nbsp;<strong>(0,0)</strong>，字母&nbsp;<strong>B</strong>&nbsp;位于坐标&nbsp;<strong>(0,1)</strong>，字母&nbsp;<strong>P</strong>&nbsp;位于坐标&nbsp;<strong>(2,3)</strong>&nbsp;且字母 <strong>Z</strong>&nbsp;位于坐标&nbsp;<strong>(4,1)</strong>。</li>\n</ul>\n\n<p>给你一个待输入字符串&nbsp;<code>word</code>，请你计算并返回在仅使用两根手指的情况下，键入该字符串需要的最小移动总距离。</p>\n\n<p>坐标<code>&nbsp;<strong>(x<sub>1</sub>,y<sub>1</sub>)</strong> </code>和 <code><strong>(x<sub>2</sub>,y<sub>2</sub>)</strong></code> 之间的 <strong>距离</strong> 是&nbsp;<code><strong>|x<sub>1</sub> - x<sub>2</sub>| + |y<sub>1</sub> - y<sub>2</sub>|</strong></code>。&nbsp;</p>\n\n<p><strong>注意</strong>，两根手指的起始位置是零代价的，不计入移动总距离。你的两根手指的起始位置也不必从首字母或者前两个字母开始。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"CAKE\"\n<strong>输出：</strong>3\n<strong>解释： \n</strong>使用两根手指输入 \"CAKE\" 的最佳方案之一是： \n手指 1 在字母 'C' 上 -&gt; 移动距离 = 0 \n手指 1 在字母 'A' 上 -&gt; 移动距离 = 从字母 'C' 到字母 'A' 的距离 = 2 \n手指 2 在字母 'K' 上 -&gt; 移动距离 = 0 \n手指 2 在字母 'E' 上 -&gt; 移动距离 = 从字母 'K' 到字母 'E' 的距离  = 1 \n总距离 = 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"HAPPY\"\n<strong>输出：</strong>6\n<strong>解释： </strong>\n使用两根手指输入 \"HAPPY\" 的最佳方案之一是：\n手指 1 在字母 'H' 上 -&gt; 移动距离 = 0\n手指 1 在字母 'A' 上 -&gt; 移动距离 = 从字母 'H' 到字母 'A' 的距离 = 2\n手指 2 在字母 'P' 上 -&gt; 移动距离 = 0\n手指 2 在字母 'P' 上 -&gt; 移动距离 = 从字母 'P' 到字母 'P' 的距离 = 0\n手指 1 在字母 'Y' 上 -&gt; 移动距离 = 从字母 'A' 到字母 'Y' 的距离 = 4\n总距离 = 6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= word.length &lt;= 300</code></li>\n\t<li>每个 <code>word[i]</code>&nbsp;都是一个大写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1321.餐馆营业额变化增长",
        "hardRate": "MEDIUM",
        "passRate": "61.97%",
        "problemsUrl": "https://leetcode.cn/problems/restaurant-growth/",
        "solutionsUrl": "https://leetcode.cn/problems/restaurant-growth/solution",
        "problemsDesc": "<p>表: <code>Customer</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| customer_id   | int     |\n| name          | varchar |\n| visited_on    | date    |\n| amount        | int     |\n+---------------+---------+\n(customer_id, visited_on) 是该表的主键。\n该表包含一家餐馆的顾客交易数据。\nvisited_on 表示 (customer_id) 的顾客在 visited_on 那天访问了餐馆。\namount 是一个顾客某一天的消费总额。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>你是餐馆的老板，现在你想分析一下可能的营业额变化增长（每天至少有一位顾客）。</p>\n\n<p>写一条 SQL 查询计算以 7 天（某日期 + 该日期前的 6 天）为一个时间段的顾客消费平均值。<code>average_amount</code>&nbsp;要 <strong>保留两位小数。</strong></p>\n\n<p>查询结果按 <code>visited_on</code> 排序。</p>\n\n<p>查询结果格式的例子如下。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nCustomer 表:\n+-------------+--------------+--------------+-------------+\n| customer_id | name         | visited_on   | amount      |\n+-------------+--------------+--------------+-------------+\n| 1           | Jhon         | 2019-01-01   | 100         |\n| 2           | Daniel       | 2019-01-02   | 110         |\n| 3           | Jade         | 2019-01-03   | 120         |\n| 4           | Khaled       | 2019-01-04   | 130         |\n| 5           | Winston      | 2019-01-05   | 110         | \n| 6           | Elvis        | 2019-01-06   | 140         | \n| 7           | Anna         | 2019-01-07   | 150         |\n| 8           | Maria        | 2019-01-08   | 80          |\n| 9           | Jaze         | 2019-01-09   | 110         | \n| 1           | Jhon         | 2019-01-10   | 130         | \n| 3           | Jade         | 2019-01-10   | 150         | \n+-------------+--------------+--------------+-------------+\n<strong>输出：</strong>\n+--------------+--------------+----------------+\n| visited_on   | amount       | average_amount |\n+--------------+--------------+----------------+\n| 2019-01-07   | 860          | 122.86         |\n| 2019-01-08   | 840          | 120            |\n| 2019-01-09   | 840          | 120            |\n| 2019-01-10   | 1000         | 142.86         |\n+--------------+--------------+----------------+\n<strong>解释：</strong>\n第一个七天消费平均值从 2019-01-01 到 2019-01-07 是restaurant-growth/restaurant-growth/ (100 + 110 + 120 + 130 + 110 + 140 + 150)/7 = 122.86\n第二个七天消费平均值从 2019-01-02 到 2019-01-08 是 (110 + 120 + 130 + 110 + 140 + 150 + 80)/7 = 120\n第三个七天消费平均值从 2019-01-03 到 2019-01-09 是 (120 + 130 + 110 + 140 + 150 + 80 + 110)/7 = 120\n第四个七天消费平均值从 2019-01-04 到 2019-01-10 是 (130 + 110 + 140 + 150 + 80 + 110 + 130 + 150)/7 = 142.86</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1322.广告效果",
        "hardRate": "EASY",
        "passRate": "59.60%",
        "problemsUrl": "https://leetcode.cn/problems/ads-performance/",
        "solutionsUrl": "https://leetcode.cn/problems/ads-performance/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1323.6 和 9 组成的最大数字",
        "hardRate": "EASY",
        "passRate": "74.95%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-69-number/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-69-number/solution",
        "problemsDesc": "<p>给你一个仅由数字 6 和 9 组成的正整数&nbsp;<code>num</code>。</p>\n\n<p>你最多只能翻转一位数字，将 6 变成&nbsp;9，或者把&nbsp;9 变成&nbsp;6 。</p>\n\n<p>请返回你可以得到的最大数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 9669\n<strong>输出：</strong>9969\n<strong>解释：</strong>\n改变第一位数字可以得到 6669 。\n改变第二位数字可以得到 9969 。\n改变第三位数字可以得到 9699 。\n改变第四位数字可以得到 9666 。\n其中最大的数字是 9969 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 9996\n<strong>输出：</strong>9999\n<strong>解释：</strong>将最后一位从 6 变到 9，其结果 9999 是最大的数。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = 9999\n<strong>输出：</strong>9999\n<strong>解释：</strong>无需改变就已经是最大的数字了。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10^4</code></li>\n\t<li><code>num</code>&nbsp;每一位上的数字都是 6 或者&nbsp;9 。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1324.竖直打印单词",
        "hardRate": "MEDIUM",
        "passRate": "59.31%",
        "problemsUrl": "https://leetcode.cn/problems/print-words-vertically/",
        "solutionsUrl": "https://leetcode.cn/problems/print-words-vertically/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>。请你按照单词在 <code>s</code> 中的出现顺序将它们全部竖直返回。<br>\n单词应该以字符串列表的形式返回，必要时用空格补位，但输出尾部的空格需要删除（不允许尾随空格）。<br>\n每个单词只能放在一列上，每一列中也只能有一个单词。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;HOW ARE YOU&quot;\n<strong>输出：</strong>[&quot;HAY&quot;,&quot;ORO&quot;,&quot;WEU&quot;]\n<strong>解释：</strong>每个单词都应该竖直打印。 \n &quot;HAY&quot;\n&nbsp;&quot;ORO&quot;\n&nbsp;&quot;WEU&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;TO BE OR NOT TO BE&quot;\n<strong>输出：</strong>[&quot;TBONTB&quot;,&quot;OEROOE&quot;,&quot;   T&quot;]\n<strong>解释：</strong>题目允许使用空格补位，但不允许输出末尾出现空格。\n&quot;TBONTB&quot;\n&quot;OEROOE&quot;\n&quot;   T&quot;\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>s = &quot;CONTEST IS COMING&quot;\n<strong>输出：</strong>[&quot;CIC&quot;,&quot;OSO&quot;,&quot;N M&quot;,&quot;T I&quot;,&quot;E N&quot;,&quot;S G&quot;,&quot;T&quot;]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 200</code></li>\n\t<li><code>s</code>&nbsp;仅含大写英文字母。</li>\n\t<li>题目数据保证两个单词之间只有一个空格。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1325.删除给定值的叶子节点",
        "hardRate": "MEDIUM",
        "passRate": "73.33%",
        "problemsUrl": "https://leetcode.cn/problems/delete-leaves-with-a-given-value/",
        "solutionsUrl": "https://leetcode.cn/problems/delete-leaves-with-a-given-value/solution",
        "problemsDesc": "<p>给你一棵以&nbsp;<code>root</code>&nbsp;为根的二叉树和一个整数&nbsp;<code>target</code>&nbsp;，请你删除所有值为&nbsp;<code>target</code> 的&nbsp;<strong>叶子节点</strong> 。</p>\n\n<p>注意，一旦删除值为&nbsp;<code>target</code>&nbsp;的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是&nbsp;<code>target</code> ，那么这个节点也应该被删除。</p>\n\n<p>也就是说，你需要重复此过程直到不能继续删除。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/16/sample_1_1684.png\" style=\"height: 120px; width: 550px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [1,2,3,2,null,2,4], target = 2\n<strong>输出：</strong>[1,null,3,null,4]\n<strong>解释：\n</strong>上面左边的图中，绿色节点为叶子节点，且它们的值与 target 相同（同为 2 ），它们会被删除，得到中间的图。\n有一个新的节点变成了叶子节点且它的值与 target 相同，所以将再次进行删除，从而得到最右边的图。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/16/sample_2_1684.png\" style=\"height: 120px; width: 300px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [1,3,3,3,2], target = 3\n<strong>输出：</strong>[1,3,null,null,2]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/16/sample_3_1684.png\" style=\"width: 450px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [1,2,null,2,null,2], target = 2\n<strong>输出：</strong>[1]\n<strong>解释：</strong>每一步都删除一个绿色的叶子节点（值为 2）。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>root = [1,1,1], target = 1\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>root = [1,2,3], target = 1\n<strong>输出：</strong>[1,2,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target&nbsp;&lt;= 1000</code></li>\n\t<li>每一棵树最多有 <code>3000</code> 个节点。</li>\n\t<li>每一个节点值的范围是&nbsp;<code>[1, 1000]</code>&nbsp;。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1326.灌溉花园的最少水龙头数目",
        "hardRate": "HARD",
        "passRate": "54.15%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/solution",
        "problemsDesc": "<p>在 x 轴上有一个一维的花园。花园长度为&nbsp;<code>n</code>，从点&nbsp;<code>0</code>&nbsp;开始，到点&nbsp;<code>n</code>&nbsp;结束。</p>\n\n<p>花园里总共有&nbsp;<code>n + 1</code> 个水龙头，分别位于&nbsp;<code>[0, 1, ..., n]</code> 。</p>\n\n<p>给你一个整数&nbsp;<code>n</code>&nbsp;和一个长度为&nbsp;<code>n + 1</code> 的整数数组&nbsp;<code>ranges</code>&nbsp;，其中&nbsp;<code>ranges[i]</code> （下标从 0 开始）表示：如果打开点&nbsp;<code>i</code>&nbsp;处的水龙头，可以灌溉的区域为&nbsp;<code>[i -&nbsp; ranges[i], i + ranges[i]]</code>&nbsp;。</p>\n\n<p>请你返回可以灌溉整个花园的&nbsp;<strong>最少水龙头数目</strong>&nbsp;。如果花园始终存在无法灌溉到的地方，请你返回&nbsp;<strong>-1</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/19/1685_example_1.png\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 5, ranges = [3,4,1,1,0,0]\n<strong>输出：</strong>1\n<strong>解释：\n</strong>点 0 处的水龙头可以灌溉区间 [-3,3]\n点 1 处的水龙头可以灌溉区间 [-3,5]\n点 2 处的水龙头可以灌溉区间 [1,3]\n点 3 处的水龙头可以灌溉区间 [2,4]\n点 4 处的水龙头可以灌溉区间 [4,4]\n点 5 处的水龙头可以灌溉区间 [5,5]\n只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, ranges = [0,0,0,0]\n<strong>输出：</strong>-1\n<strong>解释：</strong>即使打开所有水龙头，你也无法灌溉整个花园。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>ranges.length == n + 1</code></li>\n\t<li><code>0 &lt;= ranges[i] &lt;= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1327.列出指定时间段内所有的下单产品",
        "hardRate": "EASY",
        "passRate": "69.64%",
        "problemsUrl": "https://leetcode.cn/problems/list-the-products-ordered-in-a-period/",
        "solutionsUrl": "https://leetcode.cn/problems/list-the-products-ordered-in-a-period/solution",
        "problemsDesc": "<p>表: <code>Products</code></p>\n\n<pre>\n+------------------+---------+\n| Column Name      | Type    |\n+------------------+---------+\n| product_id       | int     |\n| product_name     | varchar |\n| product_category | varchar |\n+------------------+---------+\nproduct_id 是该表主键。\n该表包含该公司产品的数据。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>表: <code>Orders</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| product_id    | int     |\n| order_date    | date    |\n| unit          | int     |\n+---------------+---------+\n该表无主键，可能包含重复行。\nproduct_id 是表单 Products 的外键。\nunit 是在日期 order_date 内下单产品的数目。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>写一个 SQL 语句，要求获取在 2020 年 2 月份下单的数量不少于 100 的产品的名字和数目。</p>\n\n<p>返回结果表单的 <strong>顺序无要求 </strong>。</p>\n\n<p>查询结果的格式如下。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nProducts 表:\n+-------------+-----------------------+------------------+\n| product_id  | product_name          | product_category |\n+-------------+-----------------------+------------------+\n| 1           | Leetcode Solutions    | Book             |\n| 2           | Jewels of Stringology | Book             |\n| 3           | HP                    | Laptop           |\n| 4           | Lenovo                | Laptop           |\n| 5           | Leetcode Kit          | T-shirt          |\n+-------------+-----------------------+------------------+\nOrders 表:\n+--------------+--------------+----------+\n| product_id   | order_date   | unit     |\n+--------------+--------------+----------+\n| 1            | 2020-02-05   | 60       |\n| 1            | 2020-02-10   | 70       |\n| 2            | 2020-01-18   | 30       |\n| 2            | 2020-02-11   | 80       |\n| 3            | 2020-02-17   | 2        |\n| 3            | 2020-02-24   | 3        |\n| 4            | 2020-03-01   | 20       |\n| 4            | 2020-03-04   | 30       |\n| 4            | 2020-03-04   | 60       |\n| 5            | 2020-02-25   | 50       |\n| 5            | 2020-02-27   | 50       |\n| 5            | 2020-03-01   | 50       |\n+--------------+--------------+----------+\n<strong>输出：</strong>\n+--------------------+---------+\n| product_name       | unit    |\n+--------------------+---------+\n| Leetcode Solutions | 130     |\n| Leetcode Kit       | 100     |\n+--------------------+---------+\n<strong>解释：</strong>\n2020 年 2 月份下单 product_id = 1 的产品的数目总和为 (60 + 70) = 130 。\n2020 年 2 月份下单 product_id = 2 的产品的数目总和为 80 。\n2020 年 2 月份下单 product_id = 3 的产品的数目总和为 (2 + 3) = 5 。\n2020 年 2 月份 product_id = 4 的产品并没有下单。\n2020 年 2 月份下单 product_id = 5 的产品的数目总和为 (50 + 50) = 100 。</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1328.破坏回文串",
        "hardRate": "MEDIUM",
        "passRate": "47.09%",
        "problemsUrl": "https://leetcode.cn/problems/break-a-palindrome/",
        "solutionsUrl": "https://leetcode.cn/problems/break-a-palindrome/solution",
        "problemsDesc": "<p>给你一个由小写英文字母组成的回文字符串&nbsp;<code>palindrome</code> ，请你将其中&nbsp;<strong>一个</strong> 字符用任意小写英文字母替换，使得结果字符串的 <strong>字典序最小</strong> ，且&nbsp;<strong>不是</strong>&nbsp;回文串。</p>\n\n<p>请你返回结果字符串。如果无法做到，则返回一个 <strong>空串</strong> 。</p>\n\n<p>如果两个字符串长度相同，那么字符串 <code>a</code> 字典序比字符串 <code>b</code> 小可以这样定义：在 <code>a</code> 和 <code>b</code> 出现不同的第一个位置上，字符串 <code>a</code> 中的字符严格小于 <code>b</code> 中的对应字符。例如，<code>\"abcc”</code> 字典序比 <code>\"abcd\"</code> 小，因为不同的第一个位置是在第四个字符，显然 <code>'c'</code> 比 <code>'d'</code> 小。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>palindrome = \"abccba\"\n<strong>输出：</strong>\"aaccba\"\n<strong>解释：</strong>存在多种方法可以使 \"abccba\" 不是回文，例如 \"<em><strong>z</strong></em>bccba\", \"a<em><strong>a</strong></em>ccba\", 和 \"ab<em><strong>a</strong></em>cba\" 。\n在所有方法中，\"aaccba\" 的字典序最小。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>palindrome = \"a\"\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>不存在替换一个字符使 \"a\" 变成非回文的方法，所以返回空字符串。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= palindrome.length &lt;= 1000</code></li>\n\t<li><code>palindrome</code>&nbsp;只包含小写英文字母。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1329.将矩阵按对角线排序",
        "hardRate": "MEDIUM",
        "passRate": "77.83%",
        "problemsUrl": "https://leetcode.cn/problems/sort-the-matrix-diagonally/",
        "solutionsUrl": "https://leetcode.cn/problems/sort-the-matrix-diagonally/solution",
        "problemsDesc": "<p><strong>矩阵对角线</strong> 是一条从矩阵最上面行或者最左侧列中的某个元素开始的对角线，沿右下方向一直到矩阵末尾的元素。例如，矩阵 <code>mat</code> 有 <code>6</code> 行 <code>3</code> 列，从 <code>mat[2][0]</code> 开始的 <strong>矩阵对角线</strong> 将会经过 <code>mat[2][0]</code>、<code>mat[3][1]</code> 和 <code>mat[4][2]</code> 。</p>\n\n<p>给你一个 <code>m * n</code> 的整数矩阵 <code>mat</code> ，请你将同一条 <strong>矩阵对角线 </strong>上的元素按升序排序后，返回排好序的矩阵。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/25/1482_example_1_2.png\" style=\"height: 198px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]\n<strong>输出：</strong>[[1,1,1,1],[1,2,2,2],[1,2,3,3]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]\n<strong>输出：</strong>[[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 <= m, n <= 100</code></li>\n\t<li><code>1 <= mat[i][j] <= 100</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1330.翻转子数组得到最大的数组值",
        "hardRate": "HARD",
        "passRate": "57.72%",
        "problemsUrl": "https://leetcode.cn/problems/reverse-subarray-to-maximize-array-value/",
        "solutionsUrl": "https://leetcode.cn/problems/reverse-subarray-to-maximize-array-value/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>nums</code> 。「数组值」定义为所有满足&nbsp;<code>0 &lt;= i &lt; nums.length-1</code>&nbsp;的&nbsp;<code>|nums[i]-nums[i+1]|</code>&nbsp;的和。</p>\n\n<p>你可以选择给定数组的任意子数组，并将该子数组翻转。但你只能执行这个操作&nbsp;<strong>一次</strong> 。</p>\n\n<p>请你找到可行的最大 <strong>数组值&nbsp;</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,3,1,5,4]\n<strong>输出：</strong>10\n<strong>解释：</strong>通过翻转子数组 [3,1,5] ，数组变成 [2,5,1,3,4] ，数组值为 10 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>nums = [2,4,9,24,2,1,10]\n<strong>输出：</strong>68\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3*10^4</code></li>\n\t<li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1331.数组序号转换",
        "hardRate": "EASY",
        "passRate": "60.39%",
        "problemsUrl": "https://leetcode.cn/problems/rank-transform-of-an-array/",
        "solutionsUrl": "https://leetcode.cn/problems/rank-transform-of-an-array/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code> ，请你将数组中的每个元素替换为它们排序后的序号。</p>\n\n<p>序号代表了一个元素有多大。序号编号的规则如下：</p>\n\n<ul>\n\t<li>序号从 1 开始编号。</li>\n\t<li>一个元素越大，那么序号越大。如果两个元素相等，那么它们的序号相同。</li>\n\t<li>每个数字的序号都应该尽可能地小。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [40,10,20,30]\n<strong>输出：</strong>[4,1,2,3]\n<strong>解释：</strong>40 是最大的元素。 10 是最小的元素。 20 是第二小的数字。 30 是第三小的数字。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [100,100,100]\n<strong>输出：</strong>[1,1,1]\n<strong>解释：</strong>所有元素有相同的序号。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [37,12,28,9,100,56,80,5,12]\n<strong>输出：</strong>[5,3,4,2,8,6,7,1,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1332.删除回文子序列",
        "hardRate": "EASY",
        "passRate": "77.74%",
        "problemsUrl": "https://leetcode.cn/problems/remove-palindromic-subsequences/",
        "solutionsUrl": "https://leetcode.cn/problems/remove-palindromic-subsequences/solution",
        "problemsDesc": "<p>给你一个字符串&nbsp;<code>s</code>，它仅由字母&nbsp;<code>'a'</code> 和 <code>'b'</code>&nbsp;组成。每一次删除操作都可以从 <code>s</code> 中删除一个回文 <strong>子序列</strong>。</p>\n\n<p>返回删除给定字符串中所有字符（字符串为空）的最小删除次数。</p>\n\n<p>「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。</p>\n\n<p>「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ababa\"\n<strong>输出：</strong>1\n<strong>解释：</strong>字符串本身就是回文序列，只需要删除一次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abb\"\n<strong>输出：</strong>2\n<strong>解释：</strong>\"<strong>a</strong>bb\" -&gt; \"<strong>bb</strong>\" -&gt; \"\". \n先删除回文子序列 \"a\"，然后再删除 \"bb\"。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"baabb\"\n<strong>输出：</strong>2\n<strong>解释：</strong>\"<strong>baa</strong>b<strong>b</strong>\" -&gt; \"b\" -&gt; \"\". \n先删除回文子序列 \"baab\"，然后再删除 \"b\"。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> 仅包含字母&nbsp;<code>'a'</code>&nbsp; 和 <code>'b'</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1333.餐厅过滤器",
        "hardRate": "MEDIUM",
        "passRate": "56.76%",
        "problemsUrl": "https://leetcode.cn/problems/filter-restaurants-by-vegan-friendly-price-and-distance/",
        "solutionsUrl": "https://leetcode.cn/problems/filter-restaurants-by-vegan-friendly-price-and-distance/solution",
        "problemsDesc": "<p>给你一个餐馆信息数组&nbsp;<code>restaurants</code>，其中&nbsp;&nbsp;<code>restaurants[i] = [id<sub>i</sub>, rating<sub>i</sub>, veganFriendly<sub>i</sub>, price<sub>i</sub>, distance<sub>i</sub>]</code>。你必须使用以下三个过滤器来过滤这些餐馆信息。</p>\n\n<p>其中素食者友好过滤器&nbsp;<code>veganFriendly</code>&nbsp;的值可以为 <code>true</code> 或者 <code>false</code>，如果为 <em>true</em>&nbsp;就意味着你应该只包括&nbsp;<code>veganFriendly<sub>i</sub></code>&nbsp;为 true 的餐馆，为&nbsp;<em>false</em>&nbsp;则意味着可以包括任何餐馆。此外，我们还有最大价格&nbsp;<code>maxPrice</code>&nbsp;和最大距离&nbsp;<code>maxDistance</code>&nbsp;两个过滤器，它们分别考虑餐厅的价格因素和距离因素的最大值。</p>\n\n<p>过滤后返回餐馆的 <strong><em>id</em></strong>，按照 <em><strong>rating</strong></em>&nbsp;从高到低排序。如果 <em><strong>rating</strong></em> 相同，那么按 <em><strong>id</strong></em> 从高到低排序。简单起见，&nbsp;<code>veganFriendly<sub>i</sub></code> 和 <code>veganFriendly</code>&nbsp;为&nbsp;<em>true</em>&nbsp;时取值为 <em>1</em>，为 <em>false</em> 时，取值为&nbsp;<em>0 。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, maxDistance = 10\n<strong>输出：</strong>[3,1,5] \n<strong>解释： \n</strong>这些餐馆为：\n餐馆 1 [id=1, rating=4, veganFriendly=1, price=40, distance=10]\n餐馆 2 [id=2, rating=8, veganFriendly=0, price=50, distance=5]\n餐馆 3 [id=3, rating=8, veganFriendly=1, price=30, distance=4]\n餐馆 4 [id=4, rating=10, veganFriendly=0, price=10, distance=3]\n餐馆 5 [id=5, rating=1, veganFriendly=1, price=15, distance=1] \n在按照 veganFriendly = 1, maxPrice = 50 和 maxDistance = 10 进行过滤后，我们得到了餐馆 3, 餐馆 1 和 餐馆 5（按评分从高到低排序）。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 50, maxDistance = 10\n<strong>输出：</strong>[4,3,2,1,5]\n<strong>解释：</strong>餐馆与示例 1 相同，但在 veganFriendly = 0 的过滤条件下，应该考虑所有餐馆。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 30, maxDistance = 3\n<strong>输出：</strong>[4,5]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;restaurants.length &lt;= 10^4</code></li>\n\t<li><code>restaurants[i].length == 5</code></li>\n\t<li><code>1 &lt;=&nbsp;id<sub>i</sub>, rating<sub>i</sub>, price<sub>i</sub>, distance<sub>i </sub>&lt;= 10^5</code></li>\n\t<li><code>1 &lt;=&nbsp;maxPrice,&nbsp;maxDistance &lt;= 10^5</code></li>\n\t<li><code>veganFriendly<sub>i</sub></code> 和&nbsp;<code>veganFriendly</code>&nbsp;的值为 0 或 1 。</li>\n\t<li>所有 <code>id<sub>i</sub></code> 各不相同。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1334.阈值距离内邻居最少的城市",
        "hardRate": "MEDIUM",
        "passRate": "52.76%",
        "problemsUrl": "https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/",
        "solutionsUrl": "https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/solution",
        "problemsDesc": "<p>有 <code>n</code> 个城市，按从 <code>0</code> 到 <code>n-1</code> 编号。给你一个边数组 <code>edges</code>，其中 <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>, weight<sub>i</sub>]</code> 代表 <code>from<sub>i</sub></code> 和 <code>to<sub>i</sub></code><sub> </sub>两个城市之间的双向加权边，距离阈值是一个整数 <code>distanceThreshold</code>。</p>\n\n<p>返回能通过某些路径到达其他城市数目最少、且路径距离 <strong>最大</strong> 为 <code>distanceThreshold</code> 的城市。如果有多个这样的城市，则返回编号最大的城市。</p>\n\n<p>注意，连接城市 <em><strong>i</strong></em> 和 <em><strong>j</strong></em> 的路径的距离等于沿该路径的所有边的权重之和。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/find_the_city_01.png\" style=\"height: 225px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>城市分布图如上。\n每个城市阈值距离 distanceThreshold = 4 内的邻居城市分别是：\n城市 0 -> [城市 1, 城市 2] \n城市 1 -> [城市 0, 城市 2, 城市 3] \n城市 2 -> [城市 0, 城市 1, 城市 3] \n城市 3 -> [城市 1, 城市 2] \n城市 0 和 3 在阈值距离 4 以内都有 2 个邻居城市，但是我们必须返回城市 3，因为它的编号最大。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/find_the_city_02.png\" style=\"height: 225px; width: 300px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2\n<strong>输出：</strong>0\n<strong>解释：</strong>城市分布图如上。 \n每个城市阈值距离 distanceThreshold = 2 内的邻居城市分别是：\n城市 0 -> [城市 1] \n城市 1 -> [城市 0, 城市 4] \n城市 2 -> [城市 3, 城市 4] \n城市 3 -> [城市 2, 城市 4]\n城市 4 -> [城市 1, 城市 2, 城市 3] \n城市 0 在阈值距离 2 以内只有 1 个邻居城市。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= n <= 100</code></li>\n\t<li><code>1 <= edges.length <= n * (n - 1) / 2</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 <= from<sub>i</sub> < to<sub>i</sub> < n</code></li>\n\t<li><code>1 <= weight<sub>i</sub>, distanceThreshold <= 10^4</code></li>\n\t<li>所有 <code>(from<sub>i</sub>, to<sub>i</sub>)</code> 都是不同的。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1335.工作计划的最低难度",
        "hardRate": "HARD",
        "passRate": "66.70%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-difficulty-of-a-job-schedule/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-difficulty-of-a-job-schedule/solution",
        "problemsDesc": "<p>你需要制定一份&nbsp;<code>d</code>&nbsp;天的工作计划表。工作之间存在依赖，要想执行第&nbsp;<code>i</code>&nbsp;项工作，你必须完成全部&nbsp;<code>j</code>&nbsp;项工作（&nbsp;<code>0 &lt;= j &lt; i</code>）。</p>\n\n<p>你每天 <strong>至少</strong>&nbsp;需要完成一项任务。工作计划的总难度是这&nbsp;<code>d</code>&nbsp;天每一天的难度之和，而一天的工作难度是当天应该完成工作的最大难度。</p>\n\n<p>给你一个整数数组&nbsp;<code>jobDifficulty</code>&nbsp;和一个整数&nbsp;<code>d</code>，分别代表工作难度和需要计划的天数。第&nbsp;<code>i</code>&nbsp;项工作的难度是&nbsp;<code>jobDifficulty[i]</code>。</p>\n\n<p>返回整个工作计划的 <strong>最小难度</strong> 。如果无法制定工作计划，则返回&nbsp;<strong>-1&nbsp;</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/untitled.png\" style=\"height: 304px; width: 365px;\"></p>\n\n<pre><strong>输入：</strong>jobDifficulty = [6,5,4,3,2,1], d = 2\n<strong>输出：</strong>7\n<strong>解释：</strong>第一天，您可以完成前 5 项工作，总难度 = 6.\n第二天，您可以完成最后一项工作，总难度 = 1.\n计划表的难度 = 6 + 1 = 7 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>jobDifficulty = [9,9,9], d = 4\n<strong>输出：</strong>-1\n<strong>解释：</strong>就算你每天完成一项工作，仍然有一天是空闲的，你无法制定一份能够满足既定工作时间的计划表。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>jobDifficulty = [1,1,1], d = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>工作计划为每天一项工作，总难度为 3 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>jobDifficulty = [7,1,7,1,7,1], d = 3\n<strong>输出：</strong>15\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>jobDifficulty = [11,111,22,222,33,333,44,444], d = 6\n<strong>输出：</strong>843\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= jobDifficulty.length &lt;= 300</code></li>\n\t<li><code>0 &lt;=&nbsp;jobDifficulty[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= d &lt;= 10</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1336.每次访问的交易次数",
        "hardRate": "HARD",
        "passRate": "45.56%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-transactions-per-visit/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-transactions-per-visit/solution",
        "problemsDesc": null,
        "isPlus": true
    },
    {
        "problemsName": " 1337.矩阵中战斗力最弱的 K 行",
        "hardRate": "EASY",
        "passRate": "68.58%",
        "problemsUrl": "https://leetcode.cn/problems/the-k-weakest-rows-in-a-matrix/",
        "solutionsUrl": "https://leetcode.cn/problems/the-k-weakest-rows-in-a-matrix/solution",
        "problemsDesc": "<p>给你一个大小为 <code>m * n</code> 的矩阵 <code>mat</code>，矩阵由若干军人和平民组成，分别用 1 和 0 表示。</p>\n\n<p>请你返回矩阵中战斗力最弱的 <code>k</code> 行的索引，按从最弱到最强排序。</p>\n\n<p>如果第 <em><strong>i</strong></em> 行的军人数量少于第 <em><strong>j</strong></em> 行，或者两行军人数量相同但<em><strong> i</strong></em> 小于 <em><strong>j</strong></em>，那么我们认为第<em><strong> i </strong></em>行的战斗力比第<em><strong> j </strong></em>行弱。</p>\n\n<p>军人 <strong>总是</strong> 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = \n[[1,1,0,0,0],\n [1,1,1,1,0],\n [1,0,0,0,0],\n [1,1,0,0,0],\n [1,1,1,1,1]], \nk = 3\n<strong>输出：</strong>[2,0,3]\n<strong>解释：</strong>\n每行中的军人数目：\n行 0 -> 2 \n行 1 -> 4 \n行 2 -> 1 \n行 3 -> 2 \n行 4 -> 5 \n从最弱到最强对这些行排序后得到 [2,0,3,1,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = \n[[1,0,0,0],\n [1,1,1,1],\n [1,0,0,0],\n [1,0,0,0]], \nk = 2\n<strong>输出：</strong>[0,2]\n<strong>解释：</strong> \n每行中的军人数目：\n行 0 -> 1 \n行 1 -> 4 \n行 2 -> 1 \n行 3 -> 1 \n从最弱到最强对这些行排序后得到 [0,2,3,1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>2 <= n, m <= 100</code></li>\n\t<li><code>1 <= k <= m</code></li>\n\t<li><code>matrix[i][j]</code> 不是 0 就是 1</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1338.数组大小减半",
        "hardRate": "MEDIUM",
        "passRate": "64.88%",
        "problemsUrl": "https://leetcode.cn/problems/reduce-array-size-to-the-half/",
        "solutionsUrl": "https://leetcode.cn/problems/reduce-array-size-to-the-half/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code>。你可以从中选出一个整数集合，并删除这些整数在数组中的每次出现。</p>\n\n<p>返回&nbsp;<strong>至少</strong>&nbsp;能删除数组中的一半整数的整数集合的最小大小。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [3,3,3,3,5,5,5,2,2,7]\n<strong>输出：</strong>2\n<strong>解释：</strong>选择 {3,7} 使得结果数组为 [5,5,5,2,2]、长度为 5（原数组长度的一半）。\n大小为 2 的可行集合有 {3,5},{3,2},{5,2}。\n选择 {2,7} 是不可行的，它的结果数组为 [3,3,3,3,5,5,5]，新数组长度大于原数组的二分之一。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [7,7,7,7,7,7]\n<strong>输出：</strong>1\n<strong>解释：</strong>我们只能选择集合 {7}，结果数组为空。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>arr.length</code>&nbsp;为偶数</li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1339.分裂二叉树的最大乘积",
        "hardRate": "MEDIUM",
        "passRate": "41.54%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-product-of-splitted-binary-tree/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-product-of-splitted-binary-tree/solution",
        "problemsDesc": "<p>给你一棵二叉树，它的根为&nbsp;<code>root</code> 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。</p>\n\n<p>由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/02/sample_1_1699.png\" style=\"height: 200px; width: 495px;\"></strong></p>\n\n<pre><strong>输入：</strong>root = [1,2,3,4,5,6]\n<strong>输出：</strong>110\n<strong>解释：</strong>删除红色的边，得到 2 棵子树，和分别为 11 和 10 。它们的乘积是 110 （11*10）\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/02/sample_2_1699.png\" style=\"height: 200px; width: 495px;\"></p>\n\n<pre><strong>输入：</strong>root = [1,null,2,3,4,null,null,5,6]\n<strong>输出：</strong>90\n<strong>解释：</strong>移除红色的边，得到 2 棵子树，和分别是 15 和 6 。它们的乘积为 90 （15*6）\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>root = [2,3,9,10,7,8,6,5,4,11,1]\n<strong>输出：</strong>1025\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>root = [1,1]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每棵树最多有&nbsp;<code>50000</code>&nbsp;个节点，且至少有&nbsp;<code>2</code>&nbsp;个节点。</li>\n\t<li>每个节点的值在&nbsp;<code>[1, 10000]</code>&nbsp;之间。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1340.跳跃游戏 V",
        "hardRate": "HARD",
        "passRate": "59.34%",
        "problemsUrl": "https://leetcode.cn/problems/jump-game-v/",
        "solutionsUrl": "https://leetcode.cn/problems/jump-game-v/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code> 和一个整数&nbsp;<code>d</code> 。每一步你可以从下标&nbsp;<code>i</code>&nbsp;跳到：</p>\n\n<ul>\n\t<li><code>i + x</code>&nbsp;，其中&nbsp;<code>i + x &lt; arr.length</code>&nbsp;且&nbsp;<code>0 &lt; x &lt;= d</code>&nbsp;。</li>\n\t<li><code>i - x</code>&nbsp;，其中&nbsp;<code>i - x &gt;= 0</code>&nbsp;且&nbsp;<code>0 &lt; x &lt;= d</code>&nbsp;。</li>\n</ul>\n\n<p>除此以外，你从下标&nbsp;<code>i</code> 跳到下标 <code>j</code>&nbsp;需要满足：<code>arr[i] &gt; arr[j]</code>&nbsp;且 <code>arr[i] &gt; arr[k]</code>&nbsp;，其中下标&nbsp;<code>k</code>&nbsp;是所有 <code>i</code>&nbsp;到 <code>j</code>&nbsp;之间的数字（更正式的，<code>min(i, j) &lt; k &lt; max(i, j)</code>）。</p>\n\n<p>你可以选择数组的任意下标开始跳跃。请你返回你 <strong>最多</strong>&nbsp;可以访问多少个下标。</p>\n\n<p>请注意，任何时刻你都不能跳到数组的外面。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/02/meta-chart.jpeg\" style=\"height: 419px; width: 633px;\"></p>\n\n<pre><strong>输入：</strong>arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>你可以从下标 10 出发，然后如上图依次经过 10 --&gt; 8 --&gt; 6 --&gt; 7 。\n注意，如果你从下标 6 开始，你只能跳到下标 7 处。你不能跳到下标 5 处因为 13 &gt; 9 。你也不能跳到下标 4 处，因为下标 5 在下标 4 和 6 之间且 13 &gt; 9 。\n类似的，你不能从下标 3 处跳到下标 2 或者下标 1 处。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,3,3,3,3], d = 3\n<strong>输出：</strong>1\n<strong>解释：</strong>你可以从任意下标处开始且你永远无法跳到任何其他坐标。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [7,6,5,4,3,2,1], d = 1\n<strong>输出：</strong>7\n<strong>解释：</strong>从下标 0 处开始，你可以按照数值从大到小，访问所有的下标。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>arr = [7,1,7,1,7,1], d = 2\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>arr = [66], d = 1\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= d &lt;= arr.length</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1341.电影评分",
        "hardRate": "MEDIUM",
        "passRate": "39.83%",
        "problemsUrl": "https://leetcode.cn/problems/movie-rating/",
        "solutionsUrl": "https://leetcode.cn/problems/movie-rating/solution",
        "problemsDesc": "<p>表：<code>Movies</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| movie_id      | int     |\n| title         | varchar |\n+---------------+---------+\nmovie_id 是这个表的主键。\ntitle 是电影的名字。\n</pre>\n\n<p>表：<code>Users</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| user_id       | int     |\n| name          | varchar |\n+---------------+---------+\nuser_id 是表的主键。\n</pre>\n\n<p>表：<code>MovieRating</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| movie_id      | int     |\n| user_id       | int     |\n| rating        | int     |\n| created_at    | date    |\n+---------------+---------+\n(movie_id, user_id) 是这个表的主键。\n这个表包含用户在其评论中对电影的评分 rating 。\ncreated_at 是用户的点评日期。 \n</pre>\n\n<p>&nbsp;</p>\n\n<p>请你编写一组&nbsp;SQL 查询：</p>\n\n<ul>\n\t<li>查找评论电影数量最多的用户名。如果出现平局，返回字典序较小的用户名。</li>\n\t<li>查找在 <code>February 2020</code><strong> 平均评分最高</strong> 的电影名称。如果出现平局，返回字典序较小的电影名称。</li>\n</ul>\n\n<p><strong>字典序</strong> ，即按字母在字典中出现顺序对字符串排序，字典序较小则意味着排序靠前。</p>\n\n<p>查询结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nMovies 表：\n+-------------+--------------+\n| movie_id    |  title       |\n+-------------+--------------+\n| 1           | Avengers     |\n| 2           | Frozen 2     |\n| 3           | Joker        |\n+-------------+--------------+\nUsers 表：\n+-------------+--------------+\n| user_id     |  name        |\n+-------------+--------------+\n| 1           | Daniel       |\n| 2           | Monica       |\n| 3           | Maria        |\n| 4           | James        |\n+-------------+--------------+\nMovieRating 表：\n+-------------+--------------+--------------+-------------+\n| movie_id    | user_id      | rating       | created_at  |\n+-------------+--------------+--------------+-------------+\n| 1           | 1            | 3            | 2020-01-12  |\n| 1           | 2            | 4            | 2020-02-11  |\n| 1           | 3            | 2            | 2020-02-12  |\n| 1           | 4            | 1            | 2020-01-01  |\n| 2           | 1            | 5            | 2020-02-17  | \n| 2           | 2            | 2            | 2020-02-01  | \n| 2           | 3            | 2            | 2020-03-01  |\n| 3           | 1            | 3            | 2020-02-22  | \n| 3           | 2            | 4            | 2020-02-25  | \n+-------------+--------------+--------------+-------------+\n<strong>输出：</strong>\nResult 表：\n+--------------+\n| results      |\n+--------------+\n| Daniel       |\n| Frozen 2     |\n+--------------+\n<strong>解释：</strong>\nDaniel 和 Monica 都点评了 3 部电影（\"Avengers\", \"Frozen 2\" 和 \"Joker\"） 但是 Daniel 字典序比较小。\nFrozen 2 和 Joker 在 2 月的评分都是 3.5，但是 Frozen 2 的字典序比较小。\n</pre>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1342.将数字变成 0 的操作次数",
        "hardRate": "EASY",
        "passRate": "75.93%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-to-zero/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-to-zero/solution",
        "problemsDesc": "<p>给你一个非负整数&nbsp;<code>num</code>&nbsp;，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>num = 14\n<strong>输出：</strong>6\n<strong>解释：\n</strong>步骤 1) 14 是偶数，除以 2 得到 7 。\n步骤 2） 7 是奇数，减 1 得到 6 。\n步骤 3） 6 是偶数，除以 2 得到 3 。\n步骤 4） 3 是奇数，减 1 得到 2 。\n步骤 5） 2 是偶数，除以 2 得到 1 。\n步骤 6） 1 是奇数，减 1 得到 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>num = 8\n<strong>输出：</strong>4\n<strong>解释：</strong>\n步骤 1） 8 是偶数，除以 2 得到 4 。\n步骤 2） 4 是偶数，除以 2 得到 2 。\n步骤 3） 2 是偶数，除以 2 得到 1 。\n步骤 4） 1 是奇数，减 1 得到 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>num = 123\n<strong>输出：</strong>12\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 10^6</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1343.大小为 K 且平均值大于等于阈值的子数组数目",
        "hardRate": "MEDIUM",
        "passRate": "57.42%",
        "problemsUrl": "https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/",
        "solutionsUrl": "https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code>&nbsp;和两个整数 <code>k</code>&nbsp;和 <code>threshold</code>&nbsp;。</p>\n\n<p>请你返回长度为 <code>k</code>&nbsp;且平均值大于等于&nbsp;<code>threshold</code>&nbsp;的子数组数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>子数组 [2,5,5],[5,5,5] 和 [5,5,8] 的平均值分别为 4，5 和 6 。其他长度为 3 的子数组的平均值都小于 4 （threshold 的值)。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5\n<strong>输出：</strong>6\n<strong>解释：</strong>前 6 个长度为 3 的子数组平均值都大于 5 。注意平均值不是整数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= arr.length</code></li>\n\t<li><code>0 &lt;= threshold &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1344.时钟指针的夹角",
        "hardRate": "MEDIUM",
        "passRate": "60.04%",
        "problemsUrl": "https://leetcode.cn/problems/angle-between-hands-of-a-clock/",
        "solutionsUrl": "https://leetcode.cn/problems/angle-between-hands-of-a-clock/solution",
        "problemsDesc": "<p>给你两个数&nbsp;<code>hour</code>&nbsp;和&nbsp;<code>minutes</code>&nbsp;。请你返回在时钟上，由给定时间的时针和分针组成的较小角的角度（60 单位制）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/08/sample_1_1673.png\" style=\"height: 225px; width: 230px;\"></p>\n\n<pre><strong>输入：</strong>hour = 12, minutes = 30\n<strong>输出：</strong>165\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/08/sample_2_1673.png\" style=\"height: 225px; width: 230px;\"></p>\n\n<pre><strong>输入：</strong>hour = 3, minutes = 30\n<strong>输出；</strong>75\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/08/sample_3_1673.png\" style=\"height: 231px; width: 230px;\"></strong></p>\n\n<pre><strong>输入：</strong>hour = 3, minutes = 15\n<strong>输出：</strong>7.5\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>hour = 4, minutes = 50\n<strong>输出：</strong>155\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输入：</strong>hour = 12, minutes = 0\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= hour &lt;= 12</code></li>\n\t<li><code>0 &lt;= minutes &lt;= 59</code></li>\n\t<li>与标准答案误差在&nbsp;<code>10^-5</code>&nbsp;以内的结果都被视为正确结果。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1345.跳跃游戏 IV",
        "hardRate": "HARD",
        "passRate": "45.71%",
        "problemsUrl": "https://leetcode.cn/problems/jump-game-iv/",
        "solutionsUrl": "https://leetcode.cn/problems/jump-game-iv/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code>&nbsp;，你一开始在数组的第一个元素处（下标为 0）。</p>\n\n<p>每一步，你可以从下标&nbsp;<code>i</code>&nbsp;跳到下标&nbsp;<code>i + 1</code> 、<code>i - 1</code> 或者 <code>j</code> ：</p>\n\n<ul>\n\t<li><code>i + 1</code> 需满足：<code>i + 1 &lt; arr.length</code></li>\n\t<li><code>i - 1</code>&nbsp;需满足：<code>i - 1 &gt;= 0</code></li>\n\t<li><code>j</code>&nbsp;需满足：<code>arr[i] == arr[j]</code>&nbsp;且&nbsp;<code>i != j</code></li>\n</ul>\n\n<p>请你返回到达数组最后一个元素的下标处所需的&nbsp;<strong>最少操作次数</strong>&nbsp;。</p>\n\n<p>注意：任何时候你都不能跳到数组外面。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [100,-23,-23,404,100,23,23,23,3,404]\n<strong>输出：</strong>3\n<strong>解释：</strong>那你需要跳跃 3 次，下标依次为 0 --&gt; 4 --&gt; 3 --&gt; 9 。下标 9 为数组的最后一个元素的下标。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [7]\n<strong>输出：</strong>0\n<strong>解释：</strong>一开始就在最后一个元素处，所以你不需要跳跃。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [7,6,9,6,9,6,9,7]\n<strong>输出：</strong>1\n<strong>解释：</strong>你可以直接从下标 0 处跳到下标 7 处，也就是数组的最后一个元素处。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>8</sup>&nbsp;&lt;= arr[i] &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1346.检查整数及其两倍数是否存在",
        "hardRate": "EASY",
        "passRate": "41.94%",
        "problemsUrl": "https://leetcode.cn/problems/check-if-n-and-its-double-exist/",
        "solutionsUrl": "https://leetcode.cn/problems/check-if-n-and-its-double-exist/solution",
        "problemsDesc": "<p>给你一个整数数组&nbsp;<code>arr</code>，请你检查是否存在两个整数&nbsp;<code>N</code> 和 <code>M</code>，满足&nbsp;<code>N</code>&nbsp;是&nbsp;<code>M</code>&nbsp;的两倍（即，<code>N = 2 * M</code>）。</p>\n\n<p>更正式地，检查是否存在两个下标&nbsp;<code>i</code> 和 <code>j</code> 满足：</p>\n\n<ul>\n\t<li><code>i != j</code></li>\n\t<li><code>0 &lt;= i, j &lt; arr.length</code></li>\n\t<li><code>arr[i] == 2 * arr[j]</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>arr = [10,2,5,3]\n<strong>输出：</strong>true\n<strong>解释：</strong>N<code> = 10</code> 是 M<code> = 5 的两倍</code>，即 <code>10 = 2 * 5 。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>arr = [7,1,14,11]\n<strong>输出：</strong>true\n<strong>解释：</strong>N<code> = 14</code> 是 M<code> = 7 的两倍</code>，即 <code>14 = 2 * 7 </code>。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>arr = [3,1,7,11]\n<strong>输出：</strong>false\n<strong>解释：</strong>在该情况下不存在 N 和 M 满足 N = 2 * M 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 500</code></li>\n\t<li><code>-10^3 &lt;= arr[i] &lt;= 10^3</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1347.制造字母异位词的最小步骤数",
        "hardRate": "MEDIUM",
        "passRate": "76.20%",
        "problemsUrl": "https://leetcode.cn/problems/minimum-number-of-steps-to-make-two-strings-anagram/",
        "solutionsUrl": "https://leetcode.cn/problems/minimum-number-of-steps-to-make-two-strings-anagram/solution",
        "problemsDesc": "<p>给你两个长度相等的字符串&nbsp;<code>s</code> 和 <code>t</code>。每一个步骤中，你可以选择将&nbsp;<code>t</code>&nbsp;中的 <strong>任一字符</strong> 替换为 <strong>另一个字符</strong>。</p>\n\n<p>返回使&nbsp;<code>t</code>&nbsp;成为&nbsp;<code>s</code>&nbsp;的字母异位词的最小步骤数。</p>\n\n<p><strong>字母异位词</strong> 指字母相同，但排列不同（也可能相同）的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输出：</strong>s = &quot;bab&quot;, t = &quot;aba&quot;\n<strong>输出：</strong>1\n<strong>提示：</strong>用 &#39;b&#39; 替换 t 中的第一个 &#39;a&#39;，t = &quot;bba&quot; 是 s 的一个字母异位词。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输出：</strong>s = &quot;leetcode&quot;, t = &quot;practice&quot;\n<strong>输出：</strong>5\n<strong>提示：</strong>用合适的字符替换 t 中的 &#39;p&#39;, &#39;r&#39;, &#39;a&#39;, &#39;i&#39; 和 &#39;c&#39;，使 t 变成 s 的字母异位词。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输出：</strong>s = &quot;anagram&quot;, t = &quot;mangaar&quot;\n<strong>输出：</strong>0\n<strong>提示：</strong>&quot;anagram&quot; 和 &quot;mangaar&quot; 本身就是一组字母异位词。 \n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输出：</strong>s = &quot;xxyyzz&quot;, t = &quot;xxyyzz&quot;\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre><strong>输出：</strong>s = &quot;friend&quot;, t = &quot;family&quot;\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 50000</code></li>\n\t<li><code>s.length == t.length</code></li>\n\t<li><code>s</code> 和 <code>t</code>&nbsp;只包含小写英文字母</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1348.推文计数",
        "hardRate": "MEDIUM",
        "passRate": "35.07%",
        "problemsUrl": "https://leetcode.cn/problems/tweet-counts-per-frequency/",
        "solutionsUrl": "https://leetcode.cn/problems/tweet-counts-per-frequency/solution",
        "problemsDesc": "<p>一家社交媒体公司正试图通过分析特定时间段内出现的推文数量来监控其网站上的活动。这些时间段可以根据特定的频率（&nbsp;<strong>每分钟&nbsp;</strong>、<strong>每小时&nbsp;</strong>或 <strong>每一天</strong> ）划分为更小的 <strong>时间段</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p>例如，周期 <code>[10,10000]</code>&nbsp;（以 <strong>秒</strong> 为单位）将被划分为以下频率的 <strong>时间块</strong> :</p>\n\n<ul>\n\t<li>每 <strong>分钟</strong> (60秒 块)：<meta charset=\"UTF-8\" />&nbsp;<code>[10,69]</code>,&nbsp;<code>[70,129]</code>,&nbsp;<code>[130,189]</code>,&nbsp;<code>...</code>,&nbsp;<code>[9970,10000]</code></li>\n\t<li>每 <strong>小时</strong> (3600秒 块)：<meta charset=\"UTF-8\" /><code>[10,3609]</code>,&nbsp;<code>[3610,7209]</code>,&nbsp;<code>[7210,10000]</code></li>\n\t<li>每 <strong>天</strong> (86400秒 块)：<meta charset=\"UTF-8\" />&nbsp;<code>[10,10000]</code></li>\n</ul>\n\n<p>注意，最后一个块可能比指定频率的块大小更短，并且总是以时间段的结束时间结束(在上面的示例中为 <code>10000</code> )。</p>\n\n<p>设计和实现一个API来帮助公司进行分析。</p>\n\n<p>实现 <code>TweetCounts</code> 类:</p>\n\n<ul>\n\t<li><code>TweetCounts()</code> 初始化 <code>TweetCounts</code> 对象。</li>\n\t<li>存储记录时间的 <code>tweetName</code> (以秒为单位)。</li>\n\t<li><code>List&lt;integer&gt; getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime)</code>&nbsp;返回一个整数列表，表示给定时间 <code>[startTime, endTime]</code>&nbsp;（单位秒）和频率频率中，每个 <strong>时间块</strong> 中带有 <code>tweetName</code> 的 <code>tweet</code> 的数量。\n\t<ul>\n\t\t<li><code>freq</code> 是 <code>“minute”</code> 、 <code>“hour”</code> 或 <code>“day”</code> 中的一个，分别表示 <strong>每分钟</strong> 、 <strong>每小时</strong> 或 <strong>每一天</strong> 的频率。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"TweetCounts\",\"recordTweet\",\"recordTweet\",\"recordTweet\",\"getTweetCountsPerFrequency\",\"getTweetCountsPerFrequency\",\"recordTweet\",\"getTweetCountsPerFrequency\"]\n[[],[\"tweet3\",0],[\"tweet3\",60],[\"tweet3\",10],[\"minute\",\"tweet3\",0,59],[\"minute\",\"tweet3\",0,60],[\"tweet3\",120],[\"hour\",\"tweet3\",0,210]]\n\n<strong>输出：</strong>\n[null,null,null,null,[2],[2,1],null,[4]]\n\n<strong>解释：</strong>\nTweetCounts tweetCounts = new TweetCounts();\ntweetCounts.recordTweet(\"tweet3\", 0);\ntweetCounts.recordTweet(\"tweet3\", 60);\ntweetCounts.recordTweet(\"tweet3\", 10);                             //&nbsp;\"tweet3\"&nbsp;发布推文的时间分别是&nbsp;0,&nbsp;10&nbsp;和&nbsp;60 。\ntweetCounts.getTweetCountsPerFrequency(\"minute\", \"tweet3\", 0, 59); //&nbsp;返回&nbsp;[2]。统计频率是每分钟（60 秒），因此只有一个有效时间间隔 [0,60&gt;&nbsp;-&nbsp;&gt;&nbsp;2&nbsp;条推文。\ntweetCounts.getTweetCountsPerFrequency(\"minute\", \"tweet3\", 0, 60); //&nbsp;返回&nbsp;[2,1]。统计频率是每分钟（60 秒），因此有两个有效时间间隔&nbsp;<strong>1)</strong>&nbsp;[0,60&gt;&nbsp;-&nbsp;&gt;&nbsp;2&nbsp;条推文，和&nbsp;<strong>2)</strong>&nbsp;[60,61&gt;&nbsp;-&nbsp;&gt;&nbsp;1&nbsp;条推文。 \ntweetCounts.recordTweet(\"tweet3\", 120);                            // \"tweet3\"&nbsp;发布推文的时间分别是 0, 10, 60 和 120 。\ntweetCounts.getTweetCountsPerFrequency(\"hour\", \"tweet3\", 0, 210);  //&nbsp;返回&nbsp;[4]。统计频率是每小时（3600 秒），因此只有一个有效时间间隔 [0,211&gt;&nbsp;-&nbsp;&gt;&nbsp;4&nbsp;条推文。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= time, startTime, endTime &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= endTime - startTime &lt;= 10<sup>4</sup></code></li>\n\t<li><code>recordTweet</code>&nbsp;和&nbsp;<code>getTweetCountsPerFrequency</code>，最多有<meta charset=\"UTF-8\" />&nbsp;<code>10<sup>4</sup></code>&nbsp;次操作。</li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1349.参加考试的最大学生数",
        "hardRate": "HARD",
        "passRate": "54.20%",
        "problemsUrl": "https://leetcode.cn/problems/maximum-students-taking-exam/",
        "solutionsUrl": "https://leetcode.cn/problems/maximum-students-taking-exam/solution",
        "problemsDesc": "<p>给你一个&nbsp;<code>m&nbsp;* n</code>&nbsp;的矩阵 <code>seats</code>&nbsp;表示教室中的座位分布。如果座位是坏的（不可用），就用&nbsp;<code>&#39;#&#39;</code>&nbsp;表示；否则，用&nbsp;<code>&#39;.&#39;</code>&nbsp;表示。</p>\n\n<p>学生可以看到左侧、右侧、左上、右上这四个方向上紧邻他的学生的答卷，但是看不到直接坐在他前面或者后面的学生的答卷。请你计算并返回该考场可以容纳的一起参加考试且无法作弊的最大学生人数。</p>\n\n<p>学生必须坐在状况良好的座位上。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/09/image.png\" style=\"height: 197px; width: 339px;\"></p>\n\n<pre><strong>输入：</strong>seats = [[&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;],\n&nbsp;             [&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;],\n&nbsp;             [&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;]]\n<strong>输出：</strong>4\n<strong>解释：</strong>教师可以让 4 个学生坐在可用的座位上，这样他们就无法在考试中作弊。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>seats = [[&quot;.&quot;,&quot;#&quot;],\n&nbsp;             [&quot;#&quot;,&quot;#&quot;],\n&nbsp;             [&quot;#&quot;,&quot;.&quot;],\n&nbsp;             [&quot;#&quot;,&quot;#&quot;],\n&nbsp;             [&quot;.&quot;,&quot;#&quot;]]\n<strong>输出：</strong>3\n<strong>解释：</strong>让所有学生坐在可用的座位上。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>seats = [[&quot;#&quot;,&quot;.&quot;,&quot;<strong>.</strong>&quot;,&quot;.&quot;,&quot;#&quot;],\n&nbsp;             [&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;],\n&nbsp;             [&quot;<strong>.</strong>&quot;,&quot;.&quot;,&quot;#&quot;,&quot;.&quot;,&quot;<strong>.</strong>&quot;],\n&nbsp;             [&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;],\n&nbsp;             [&quot;#&quot;,&quot;.&quot;,&quot;<strong>.</strong>&quot;,&quot;.&quot;,&quot;#&quot;]]\n<strong>输出：</strong>10\n<strong>解释：</strong>让学生坐在第 1、3 和 5 列的可用座位上。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>seats</code>&nbsp;只包含字符&nbsp;<code>&#39;.&#39;&nbsp;和</code><code>&#39;#&#39;</code></li>\n\t<li><code>m ==&nbsp;seats.length</code></li>\n\t<li><code>n ==&nbsp;seats[i].length</code></li>\n\t<li><code>1 &lt;= m &lt;= 8</code></li>\n\t<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n",
        "isPlus": false
    },
    {
        "problemsName": " 1350.院系无效的学生",
        "hardRate": "EASY",
        "passRate": "85.06%",
        "problemsUrl": "https://leetcode.cn/problems/students-with-invalid-departments/",
        "solutionsUrl": "https://leetcode.cn/problems/students-with-invalid-departments/solution",
        "problemsDesc": null,
        "isPlus": true
    }
]